/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

char sub_10001000();
char sub_10001010();
int sub_10001020();
char __cdecl sub_10001130(int a1, int a2);
char __cdecl sub_100011E0(int a1);
char __cdecl sub_10001290(char a1, const char *a2);
// char __usercall sub_10001310@<al>(char result@<al>);
// int __usercall sub_10001330@<eax>(int a1@<eax>);
char __cdecl sub_10001360(void *a1, unsigned __int16 a2);
char __cdecl sub_100013D0(int a1, _BYTE *a2);
char __cdecl sub_10001480(int a1, const void *a2);
char __cdecl sub_100014F0(int a1, _BYTE *a2);
char __cdecl sub_10001520(int a1, char *a2);
char __cdecl sub_10001570(int a1, char *a2);
char __cdecl sub_10001650(int a1, char *a2);
char __cdecl sub_100016E0(int a1, char *a2);
char *__cdecl sub_10001820(unsigned int a1);
void __cdecl sub_10001940(int a1, const char *a2, int a3);
void __cdecl sub_100019E0(int a1);
void __cdecl sub_10001C70(_BYTE *a1);
void __cdecl sub_10001E50(int a1, int a2);
void __cdecl sub_10001EC0(const char *a1, int a2);
char __cdecl sub_10001EE0(int a1, int a2);
char __cdecl sub_10002450(int a1);
void __cdecl sub_100024C0(int a1);
void __cdecl sub_10002520(int a1);
// void __usercall sub_10002580(unsigned __int8 a1@<cl>, _BYTE *a2@<edi>, _WORD *a3@<esi>, signed int a4);
char __cdecl sub_100025E0(int a1, _BYTE *a2);
char __cdecl sub_10002810(int a1, int a2);
int sub_10002A00(); // weak
void __cdecl sub_10002A10(int a1);
void __cdecl sub_10002D40(int a1);
void __cdecl sub_10002D80(int a1);
void __cdecl sub_10003850(int a1);
int __cdecl sub_10003A90(int a1);
void __cdecl sub_10003CA0(int a1);
void __cdecl sub_10004610(int a1);
void __cdecl sub_100048F0(int a1);
void __cdecl sub_10004930(int a1);
void __cdecl sub_10004A80(int a1);
void __cdecl sub_10005030(int a1);
void __cdecl sub_10005530(int a1);
void __cdecl sub_10005720(int a1);
void __cdecl sub_10005980(int a1);
void __cdecl sub_10005A70(int a1);
void __cdecl sub_10005F10(int a1);
void __cdecl sub_10006560(int a1);
void __cdecl sub_10006610(int a1);
char __cdecl sub_100066B0(int a1, _BYTE *a2);
char __cdecl sub_10006750(int a1, _BYTE *a2);
char __cdecl sub_100067F0(int a1, _BYTE *a2);
char __cdecl sub_10006830(int a1, _BYTE *a2);
void __cdecl sub_10006880(int a1);
// void __usercall sub_100069B0(int a1@<ebx>);
char __cdecl sub_10006A70(int a1, _BYTE *a2);
void __cdecl sub_10006B10(int a1);
void __cdecl sub_10006E60(int a1);
void __cdecl sub_10007390(int a1, int a2);
signed int sub_10007760();
int __cdecl sub_100077B0(int a1, char *a2, char a3, int a4);
char __thiscall sub_10007810(void *this);
int __cdecl sub_10007830(char *, size_t); // idb
unsigned int __cdecl sub_100078C0(unsigned int a1, char a2);
unsigned int __cdecl sub_100079A0(char a1, char a2);
int __cdecl sub_10007A10(int a1, char a2, void (__cdecl *a3)(int, char *, int), int a4);
int __cdecl sub_10007ED0(_DWORD *a1, unsigned int a2);
int __cdecl sub_10007F30(int a1, unsigned int a2);
int __cdecl sub_10007F70(unsigned int a1);
int sub_10007FC0();
int __cdecl j_HWM_pvg_dspl_bklt_get_actv_led_calib(_DWORD); // weak
int __cdecl j_HWM_pvg_dspl_bklt_get_frmt_avg_adc(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_dspl_bklt_get_rgb_pwm(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_dspl_bklt_get_wht_pnt_sts(_DWORD); // weak
int __cdecl j_HWM_pvg_ethr_get_stats(_DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_get_frmt_adc(_DWORD); // weak
int __cdecl j_HWM_pvg_get_raw_adc(_DWORD); // weak
int __cdecl j_HWM_pvg_get_uart(_DWORD, _DWORD, _DWORD); // weak
int j_HWM_pvg_hsdb_clear_stats(void); // weak
int __cdecl j_HWM_pvg_hsdb_get(_DWORD, _DWORD); // weak
int j_HWM_pvg_hsdb_get_lrus_online(void); // weak
int __cdecl j_HWM_pvg_hsdb_get_router_entry(_DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_hsdb_get_stats(_DWORD); // weak
int __cdecl j_HWM_pvg_hsdb_put(_DWORD); // weak
int __cdecl j_HWM_pvg_hsdb_set_sim_lrus_online(_DWORD); // weak
int __cdecl j_HWM_pvg_log_err(_DWORD); // weak
int __cdecl j_HWM_pvg_put_uart(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_read_keys(_DWORD); // weak
int __cdecl j_HWM_pvg_read_reg(_DWORD); // weak
int __cdecl j_HWM_pvg_hsdb_set_lrus_reject(_DWORD); // weak
char __cdecl sub_10008170(void *a1, int a2);
int __thiscall sub_100081A0(void *this);
char sub_10008600();
// void __usercall sub_10008610(char a1@<bl>);
char __thiscall sub_100086A0(void *this);
char __cdecl sub_10009250(int a1, int a2);
char sub_10009370();
char __cdecl sub_10009480(int a1, int a2);
char __cdecl sub_10009500(int a1, int a2);
char __cdecl sub_10009580(int a1, int a2);
char __cdecl sub_10009600(int a1, int a2);
char __cdecl sub_10009640(int a1, int a2);
char __cdecl sub_100096C0(int a1, int a2);
char __cdecl sub_10009700(int a1, int a2);
char __cdecl sub_10009740(int a1, int a2);
char __cdecl sub_10009780(int a1, int a2);
char __cdecl sub_100097E0(int a1, int a2);
char __cdecl sub_10009820(int a1, int a2);
char __cdecl sub_10009860(int a1, int a2);
char __cdecl sub_100098B0(int a1, int a2);
char __cdecl sub_100098F0(int a1, int a2);
char __cdecl sub_10009990(int a1, int a2);
int sub_100099C0();
char sub_100099E0();
void __thiscall sub_10009D70(void *this);
int sub_10009E00();
void __noreturn sub_1000A080();
char sub_1000A180();
char __cdecl sub_1000A1A0(int a1, int a2);
char __cdecl sub_1000A220(int a1, int a2);
char __cdecl sub_1000A440(int a1, int a2);
char __cdecl sub_1000A660(int a1, int a2);
char __cdecl sub_1000A700(int a1, int a2);
char __cdecl sub_1000A780(char a1, const char *a2);
int sub_1000A800();
void sub_1000A850();
void sub_1000A860();
int __cdecl sub_1000A870(int a1);
char __cdecl sub_1000A880(char *a1);
unsigned int sub_1000A9E0();
// int __usercall sub_1000AA70@<eax>(int a1@<eax>, int a2@<ecx>);
char *__cdecl sub_1000AA90(int a1, const char *a2, unsigned __int16 a3);
signed int sub_1000AC60();
char __cdecl sub_1000ACA0(int a1);
int __cdecl sub_1000AD00(char a1);
signed int sub_1000AD70();
int sub_1000ADB0();
unsigned int sub_1000ADE0();
char __cdecl sub_1000AE10(int a1, int a2);
char __cdecl sub_1000AFA0(int a1, int a2);
int __cdecl sub_1000B060(int a1);
char __cdecl sub_1000B150(int a1, char a2, int a3, __int16 a4);
char __cdecl sub_1000B340(int a1, int a2);
// signed __int16 __usercall sub_1000B550@<ax>(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_1000B570@<eax>(int a1@<esi>, signed int a2);
// int __usercall sub_1000B770@<eax>(int a1@<eax>, int a2@<esi>, int a3);
char __cdecl sub_1000B890(int a1, int a2);
char __cdecl sub_1000B910(_DWORD *a1, _WORD *a2, _DWORD *a3, int a4, int a5);
char __cdecl sub_1000B990(int a1, int a2, void *a3, unsigned __int16 a4);
int __cdecl sub_1000BB80(int a1, int a2);
bool __cdecl sub_1000BBD0(int a1, int a2);
int __cdecl sub_1000BC50(int a1, int a2);
char __cdecl sub_1000BCA0(int a1, int a2, void *a3, unsigned __int16 *a4, unsigned __int16 a5);
int __cdecl sub_1000BEB0(int a1);
int __cdecl sub_1000BF60(int a1);
char __cdecl sub_1000C010(int a1);
int __cdecl sub_1000C410(int a1);
char __cdecl sub_1000C7A0(int a1, char a2, int a3, const void *a4, int a5);
char __cdecl sub_1000CAB0(int a1, unsigned __int16 a2, char a3, int a4, const void *a5, int a6);
char __cdecl sub_1000CDA0(int a1, int a2, int a3);
char __cdecl sub_1000D060(int a1, int a2, void *a3, char a4, int a5);
char __cdecl sub_1000D2F0(int a1, unsigned __int16 a2, int a3, void *a4, char a5, int a6);
int __cdecl sub_1000D580(int a1);
char __cdecl sub_1000D640(int a1, int a2, void *a3);
char __cdecl sub_1000D660(int a1, int a2, void *a3, unsigned __int16 *a4);
int __cdecl sub_1000D690(int a1);
int __cdecl sub_1000D7E0(int a1);
int __cdecl sub_1000D7F0(int a1);
char sub_1000D800();
signed int sub_1000D980();
int sub_1000DAC0();
int sub_1000DAE0();
int __cdecl sub_1000DC40(char a1);
int __cdecl sub_1000DC60(char a1);
signed int sub_1000DC80();
// signed int __usercall sub_1000DCD0@<eax>(char a1@<al>, int a2@<ecx>);
// signed int __usercall sub_1000DD70@<eax>(char a1@<al>, int a2@<ecx>);
// int __usercall sub_1000DE10@<eax>(char a1@<al>);
// int __usercall sub_1000DE30@<eax>(char a1@<al>);
char __cdecl sub_1000DE50(char a1, void *a2, int a3);
// signed __int16 __usercall sub_1000E060@<ax>(char a1@<al>, unsigned __int16 a2@<si>);
char __cdecl sub_1000E270(char a1, unsigned __int16 a2, _BYTE *a3);
char __cdecl sub_1000E3C0(char a1, unsigned __int16 a2, void *a3);
char __cdecl sub_1000E530(char a1, unsigned __int16 a2, _DWORD *a3);
char __cdecl sub_1000E6A0(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_1000E800(int a1, int a2, void *a3, char a4, int a5, int a6);
char __cdecl sub_1000E9B0(char a1, int a2, int a3);
char __cdecl sub_1000EAC0(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6);
char __cdecl sub_1000ED30(char a1, int a2, __int16 a3, __int16 a4, void *a5);
char __cdecl sub_1000ED60(char a1, int a2, void *a3);
char __cdecl sub_1000ED90(char a1, int a2, void *a3, int a4);
const char *__cdecl sub_1000EDC0(int a1, unsigned __int16 a2);
int __cdecl sub_1000EDF0(char a1, int a2);
void __cdecl sub_1000EF10(int a1, __int16 a2, unsigned __int16 a3, const void *a4);
char __cdecl sub_1000EF40(void *a1, int a2);
char __cdecl sub_1000EF70(int a1, int a2);
char __cdecl sub_1000EFF0(__int16 a1, int a2);
unsigned int __cdecl sub_10010050(char *a1);
int __cdecl sub_10010070(_BYTE *a1);
int __cdecl sub_10010090(unsigned __int8 *a1);
unsigned int __cdecl sub_100100B0(int a1, int a2);
unsigned int __cdecl sub_100103E0(int a1, int a2);
unsigned int __cdecl sub_10010820(_BYTE *a1);
int __cdecl sub_10010840(unsigned __int8 *a1);
int __cdecl sub_10010860(unsigned __int8 *a1);
int __cdecl sub_10010880(_BYTE *a1);
int __cdecl sub_100108A0(int a1);
// void __cdecl __noreturn exit(int);
int __cdecl sub_100108F0(unsigned __int8 *a1);
int __cdecl sub_10010910(int a1);
unsigned int __cdecl sub_100109A0(int a1);
signed int __cdecl sub_100109C0(int a1);
unsigned int __cdecl sub_10010A10(int a1);
int __cdecl sub_10010A70(_BYTE *a1);
unsigned int __cdecl sub_10010A90(_BYTE *a1);
int __cdecl sub_10010AB0(unsigned __int8 *a1);
int __cdecl sub_10010AD0(_BYTE *a1);
signed int __cdecl sub_10010AF0(_BYTE *a1, int a2);
int __cdecl sub_10010B20(_BYTE *a1, int a2);
signed int __cdecl sub_10010B60(_BYTE *a1, int a2);
int __cdecl sub_10010B90(int a1, int a2);
int __cdecl sub_10010C20(unsigned __int8 *a1);
int __cdecl sub_10010C40(int a1);
int __cdecl sub_10010C70(unsigned __int8 *a1);
unsigned int __cdecl sub_10010C90(int a1);
int __cdecl sub_10010CC0(int a1);
int __cdecl sub_10010DB0(int a1);
signed int __cdecl sub_10010EC0(unsigned __int8 *a1, int a2);
int __cdecl sub_10010EF0(int a1);
int __cdecl sub_10010F20(unsigned __int8 *a1);
int __cdecl sub_10010F80(int a1);
signed int __cdecl sub_10010F90(_BYTE *a1, int a2);
int __cdecl sub_10010FC0(int a1, int a2);
_DWORD __cdecl sub_10011040(_DWORD); // weak
int __cdecl sub_10011050(int a1);
unsigned int __cdecl sub_100110D0(int a1);
unsigned int __cdecl sub_10011110(int a1);
int __cdecl sub_10011160(int a1);
int __cdecl sub_10011190(int a1);
unsigned int __cdecl sub_100111C0(int a1);
unsigned int __cdecl sub_100111F0(int a1);
unsigned int __cdecl sub_10011210(int a1);
void __cdecl __noreturn sub_10011250(int a1);
signed int __cdecl sub_100113C0(int a1, int a2);
// time_t __cdecl static _mkgmtime(struct tm *Tm);
// signed int __usercall sub_10011420@<eax>(int a1@<eax>, int a2@<edi>);
signed int __cdecl sub_100114F0(int a1);
int __cdecl sub_10011500(int a1, int a2);
signed int __cdecl sub_100115C0(int a1, int a2, int a3);
// char __usercall sub_10011640@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5);
signed int __cdecl sub_10011710(_DWORD *a1, char *a2);
int __cdecl sub_100117F0(int a1, char *a2, size_t a3, int a4);
void sub_10011DD0();
signed int sub_10011DE0();
int __cdecl sub_10011DF0(int a1, int a2, _DWORD *a3);
int __cdecl sub_10011FC0(int a1, int a2);
int __cdecl sub_10012030(int, char, void *); // idb
char __cdecl sub_100120B0(int a1, char a2, char *a3);
void __cdecl sub_10012390(_BYTE *a1, signed int a2, int a3);
int __cdecl sub_10012430(int a1, int a2, int a3, _BYTE *a4);
unsigned int __cdecl sub_100124B0(unsigned int a1, _BYTE *a2, _BYTE *a3);
int __cdecl sub_100124D0(unsigned __int8 a1);
char __cdecl sub_10012510(__int64 a1);
double __cdecl sub_10012540(float a1);
// char __usercall sub_10012600@<al>(int a1@<edi>, unsigned int a2@<esi>, char a3);
char __cdecl sub_10012700(unsigned int a1, int a2);
void __cdecl sub_10012720(unsigned int a1, int a2);
double *__cdecl sub_10012870(char a1, char a2, double *a3);
void __cdecl sub_100129A0(int a1, char *a2);
// char __usercall sub_10012A00@<al>(unsigned __int16 a1@<ax>, void *a2);
// int __usercall sub_10012A60@<eax>(int result@<eax>, int a2@<ecx>);
int __cdecl sub_10012A80(unsigned __int16 a1, int a2);
int __cdecl sub_10012B10(unsigned __int16 a1, int a2);
int __cdecl sub_10012B80(unsigned __int16 a1, int a2);
signed int __cdecl sub_10012BF0(unsigned __int8 a1, unsigned __int8 a2);
char __cdecl sub_10012C50(unsigned __int8 a1, int a2, char a3, int a4);
// char __usercall sub_10012CD0@<al>(int a1@<eax>, unsigned __int8 a2);
int __fastcall sub_10012D70(int a1, int a2);
void __cdecl sub_10012DA0(unsigned int a1, int a2);
char __cdecl sub_10012EE0(unsigned int a1, int a2);
// void __usercall sub_10012F90(int a1@<ecx>, int a2@<esi>);
char __cdecl sub_10012FC0(unsigned int a1, int a2);
unsigned __int8 __cdecl sub_100130E0(unsigned int a1);
int __cdecl sub_10013110(unsigned int a1, unsigned __int8 a2, char a3);
int __cdecl sub_10013190(unsigned int a1);
char __cdecl sub_100131C0(__int64 a1);
int __cdecl sub_10013260(int a1);
signed int __thiscall sub_100132A0(int this);
// signed int __usercall sub_10013350@<eax>(int a1@<edi>);
signed int __thiscall sub_100133E0(int this);
// int __usercall sub_10013480@<eax>(int a1@<esi>);
// char __usercall sub_100134A0@<al>(unsigned int a1@<eax>, unsigned int *a2@<ebx>, _BYTE *a3@<edi>, int a4@<esi>, _DWORD *a5, int *a6);
// void *__usercall sub_10013560@<eax>(int a1@<eax>, char *a2@<esi>);
// __int16 __usercall sub_100135C0@<ax>(int a1@<eax>, int a2@<esi>, int a3);
void *__cdecl sub_10013730(unsigned int a1, char *a2);
signed int __cdecl sub_10013780(unsigned __int8 a1);
// signed int __usercall sub_10013800@<eax>(int a1@<edi>, unsigned __int8 a2);
signed int __cdecl sub_10013870(unsigned __int8 a1);
// int __usercall sub_100138E0@<eax>(int a1@<eax>, char a2);
// void __usercall sub_10013970(int a1@<edi>, int a2, int a3);
int __cdecl sub_100139B0(__int64 a1);
double __cdecl sub_10013A60(int a1);
int __cdecl sub_10013AD0(int a1, int a2);
char __cdecl sub_10013C60(int a1, int a2);
__int16 __cdecl sub_10013CD0(int a1, int a2);
int sub_10013D10();
char __cdecl sub_10013DB0(float *a1);
char __cdecl sub_10014070(int a1, float *a2);
double __cdecl sub_10014090(unsigned int a1);
char *__cdecl sub_10014140(unsigned __int8 a1);
signed int sub_10014200();
int sub_10014220();
int sub_10014280();
char *sub_100142F0();
int __cdecl sub_100143C0(const void *a1);
void __cdecl sub_10014470(unsigned int a1, int a2);
char __cdecl sub_10014650(unsigned int a1, int a2);
int __cdecl sub_100146C0(_BYTE *a1, _BYTE *a2);
int sub_100146F0();
int __fastcall sub_10014700(unsigned __int8 a1);
int __fastcall sub_10014720(unsigned __int8 a1);
void *__cdecl sub_10014740(char a1, void *a2);
int __cdecl sub_10014810(int a1);
char sub_100149D0();
char *__cdecl sub_10014B30(int a1, char *a2, int a3, char *a4, int a5);
char sub_10014C60();
char __cdecl sub_10014C70(char *a1, int a2, char a3, char *a4, int a5);
char __cdecl sub_10014D70(char *a1, int a2, char a3, char *a4);
int __cdecl sub_10014DE0(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6);
char __thiscall sub_10014F70(void *this);
int __thiscall sub_10014FA0(void *this);
int __cdecl sub_10014FC0(char *a1);
char __cdecl sub_10014FE0(char *a1);
char __cdecl sub_10015010(int a1);
char __cdecl sub_10015060(int a1);
bool __cdecl sub_100150B0(float a1, int a2, int a3, int a4);
bool __cdecl sub_10015220(signed int a1, signed int a2, _BYTE *a3);
int __cdecl sub_10015290(int a1, _BYTE *a2, int a3);
int __cdecl sub_100152E0(void *, size_t); // idb
int __cdecl sub_10015310(int, char *, int); // idb
int __cdecl sub_10015370(char *, size_t, char *, va_list); // idb
int sub_100153B0(char *arg0, size_t arg4, char *arg8, ...);
int __cdecl sub_100153E0(const char *a1, _BYTE *a2, int a3);
int __cdecl sub_10015420(int a1, int a2);
int __cdecl sub_10015440(int a1, int a2, int a3);
char __thiscall sub_100154A0(void *this);
int sub_100154D0();
char __cdecl sub_10015500(int a1);
int __cdecl sub_10015520(int, char *); // idb
char __thiscall sub_10015580(void *this);
int __cdecl sub_100155A0(char a1);
char __thiscall sub_100155B0(void *this);
char __thiscall sub_100155D0(void *this);
char __thiscall sub_100155F0(void *this);
int __thiscall sub_10015610(void *this);
int __thiscall sub_10015630(void *this);
char __thiscall sub_10015650(void *this);
char __thiscall sub_10015670(void *this);
int __cdecl sub_10015690(char a1);
int __cdecl sub_100156A0(int a1, unsigned int a2);
__int16 __cdecl sub_10015790(int a1, unsigned int a2);
__int16 __cdecl sub_100157E0(unsigned int *a1, _WORD *a2, _WORD *a3);
char __cdecl sub_10015860(char a1, void *a2);
char __cdecl sub_10015910(char a1, int a2);
int __cdecl sub_100159F0(char, void *); // idb
char __thiscall sub_10015A30(void *this);
// char __usercall sub_10015AA0@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4);
// void *__usercall sub_10015AE0@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4);
char __cdecl sub_10015B80(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10015BC0(char a1, char a2, void *a3);
char __cdecl sub_10015C20(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10015C60(char a1, char a2, void *a3);
char __cdecl sub_10015C90(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10015CD0(char a1, char a2, void *a3);
char __cdecl sub_10015D10(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10015D50(char a1, char a2, void *a3);
char __cdecl sub_10015DA0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10015DE0(char a1, char a2, void *a3);
char __cdecl sub_10015E20(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10015E60(char a1, char a2, void *a3);
char __cdecl sub_10015EA0(char a1, void *a2);
char __cdecl sub_10015ED0(char a1, void *a2);
char __cdecl sub_10015F00(char a1, void *a2);
char __cdecl sub_10015F30(char a1, void *a2);
char __cdecl sub_10015F60(char a1, void *a2);
char __cdecl sub_10015F90(char a1, void *a2);
char __cdecl sub_10015FC0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10016000(char a1, char a2, void *a3);
char __cdecl sub_10016050(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10016090(char a1, char a2, void *a3);
char __cdecl sub_100160C0(char a1, void *a2);
char __cdecl sub_100160F0(char a1, void *a2);
char __cdecl sub_10016120(char a1, void *a2);
char __cdecl sub_10016150(int a1, char a2, char a3, int a4, void *a5);
char __cdecl sub_100164F0(char a1);
char __cdecl sub_10016530(char a1);
char __cdecl sub_100165A0(char a1);
signed int __cdecl sub_10016610(char a1);
char __cdecl sub_10016690(char a1);
char __cdecl sub_10016700(char a1);
char __cdecl sub_100167B0(int a1);
char __cdecl sub_100168B0(char a1);
char __thiscall sub_100168D0(void *this);
char __cdecl sub_100168E0(char a1);
signed int sub_10016920();
signed int sub_10016930();
char __cdecl sub_10016940(int a1, char a2);
char __cdecl sub_10016A20(_DWORD *a1, char a2);
char __cdecl sub_10016AA0(unsigned __int16 a1, unsigned __int16 a2);
BOOL __cdecl sub_10016B50(unsigned int a1);
char __thiscall sub_10016BC0(void *this);
void __cdecl sub_10016BE0(_BYTE *a1, _BYTE *a2, _BYTE *a3);
int __cdecl sub_10016C10(int a1);
signed int sub_10016C30();
void __cdecl sub_10016C60(_BYTE *a1);
char __cdecl sub_10016C80(int a1, size_t a2, void *a3);
int __cdecl sub_10016CC0(int a1);
char __fastcall sub_10016CE0(int *a1);
char sub_10016F00();
int __cdecl sub_10016F20(char a1);
char __cdecl sub_10016F70(int a1, int a2, int a3, int a4, int a5, int a6);
signed int sub_10016FE0();
signed int sub_10016FF0();
signed int sub_10017000();
// char __usercall sub_10017010@<al>(char a1@<bl>, int a2@<edi>, const void *a3@<esi>, char a4, char a5, char a6, unsigned int a7);
char __cdecl sub_10017170(_BYTE *a1);
char __cdecl sub_100171A0(unsigned __int8 a1, _BYTE *a2);
char __cdecl sub_100171D0(char a1, const void *a2);
// void *__usercall sub_10017210@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>);
signed int sub_10017260();
int sub_10019060();
char sub_10019090();
void *sub_10019130();
signed int sub_10019140();
int sub_10019170();
char __cdecl sub_100191B0(int a1, int a2, unsigned __int16 a3);
char *__cdecl sub_10019230(int a1);
char __cdecl sub_10019250(_BYTE *a1);
char __cdecl sub_100193A0(char a1, _BYTE *a2);
char __thiscall sub_10019500(void *this);
char __cdecl sub_10019600(_BYTE *a1);
char __cdecl sub_100196E0(_BYTE *a1);
char __cdecl sub_10019820(_BYTE *a1);
int __cdecl sub_10019970(__int16 a1);
char __cdecl sub_10019A10(_BYTE *a1, _BYTE *a2);
int __cdecl sub_10019B40(_BYTE *a1);
unsigned int __cdecl sub_10019C80(unsigned int a1);
char sub_10019D10();
char __cdecl sub_10019EB0(int a1, int a2);
char __cdecl sub_10019EE0(int a1, int a2, int a3, int a4);
char __cdecl sub_10019F10(int a1, int a2);
char __cdecl sub_10019F40(int a1);
char __cdecl sub_10019F60(int a1);
char __cdecl sub_10019FD0(int a1, void *a2);
int __cdecl sub_1001A040(int a1);
char __cdecl sub_1001A070(int a1, void *a2);
char __cdecl sub_1001A100(int a1, int a2);
char __cdecl sub_1001A220(int a1);
char __cdecl sub_1001A230(int a1);
char __cdecl sub_1001A240(int a1);
int __cdecl sub_1001A250(int, float); // idb
char __cdecl sub_1001A280(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
char __cdecl sub_1001A2E0(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
bool __cdecl sub_1001A340(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_1001A3B0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_1001A410(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1001A480(char a1, _BYTE *a2);
char __thiscall sub_1001A4C0(void *this);
char __cdecl sub_1001A530(char a1, int a2);
char __cdecl sub_1001A560(char a1, int a2);
char __cdecl sub_1001A590(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6);
bool __thiscall sub_1001A760(void *this);
char sub_1001A770();
unsigned int __cdecl sub_1001A7A0(unsigned int a1);
int __cdecl sub_1001A7C0(int a1);
bool __cdecl sub_1001A7D0(int a1);
int __cdecl sub_1001A8A0(int a1);
int __cdecl sub_1001A8C0(int a1, int a2);
bool __cdecl sub_1001A900(int a1);
signed int __cdecl sub_1001A960(int a1, void *a2, unsigned __int16 a3, __int16 a4);
signed int __cdecl sub_1001AA20(int a1, int a2, int a3);
int __cdecl sub_1001AAD0(int a1);
signed int __cdecl sub_1001AAF0(_BYTE *a1, _BYTE *a2, int a3);
// int __usercall sub_1001AB50@<eax>(int a1@<esi>, int a2, char a3);
// int __usercall sub_1001AC60@<eax>(int a1@<eax>, int a2@<esi>);
// signed int __usercall sub_1001AD10@<eax>(int a1@<eax>, int a2@<esi>);
// char __usercall sub_1001AEE0@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_1001AEF0@<eax>(int result@<eax>);
// char __usercall sub_1001AF10@<al>(int a1@<eax>);
// int __usercall sub_1001AF30@<eax>(int a1@<esi>, unsigned __int8 a2);
int __cdecl sub_1001AF70(unsigned int a1);
int __fastcall sub_1001B120(int a1, int a2);
// int __usercall sub_1001B140@<eax>(int result@<eax>, int a2@<ecx>);
// int __usercall sub_1001B150@<eax>(int a1@<esi>);
// signed int __usercall sub_1001B190@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_1001B3A0(void *); // idb
int __cdecl sub_1001B400(int, int, void *, int); // idb
signed int __cdecl sub_1001B500(int a1, unsigned __int64 a2);
signed int __cdecl sub_1001B700(int a1, int a2);
int __cdecl sub_1001B720(int a1);
int __cdecl sub_1001B990(int a1, unsigned int a2);
int __cdecl sub_1001BB30(void *, int, char); // idb
signed int __cdecl sub_1001BC00(unsigned int a1, int a2, int a3);
// int __usercall sub_1001BCA0@<eax>(int a1@<eax>);
// int __usercall sub_1001BCC0@<eax>(int a1@<edi>, int a2);
// signed int __usercall sub_1001BCF0@<eax>(int a1@<eax>, int a2@<ebx>);
int __cdecl sub_1001BD60(int a1, unsigned int a2);
int __cdecl sub_1001BDA0(int, char *, int); // idb
// void __cdecl __noreturn exit_0(int);
signed int __cdecl sub_1001BF10(int a1);
// char __usercall sub_1001BF70@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>);
// signed int __usercall sub_1001BFA0@<eax>(int a1@<eax>);
// BOOL __usercall sub_1001BFD0@<eax>(int a1@<ebx>, int a2);
int __cdecl sub_1001C010(int, char *); // idb
signed int __cdecl sub_1001C040(unsigned int a1);
signed int __cdecl sub_1001C090(int a1, int a2);
// bool __usercall sub_1001C280@<al>(int a1@<eax>);
int __cdecl sub_1001C2B0(int, int, char, void *, int); // idb
signed int __cdecl sub_1001C3C0(unsigned int a1, int a2, int a3);
signed int __cdecl sub_1001C420(unsigned int a1, int a2, int a3);
int __cdecl sub_1001C5B0(int a1, char *a2, int a3, void *a4, int a5);
signed int __cdecl sub_1001C7A0(unsigned int a1);
signed int __cdecl sub_1001C7E0(unsigned int a1, int a2, int a3, int a4);
signed int __cdecl sub_1001C840(unsigned int a1, int a2, int a3);
signed int __cdecl sub_1001C860(unsigned int a1, int a2, int a3);
char __cdecl sub_1001C880(char a1, _BYTE *a2, _BYTE *a3, char a4);
char __thiscall sub_1001C8C0(void *this);
// void __usercall sub_1001C980(unsigned __int16 a1@<bx>, unsigned __int16 *a2@<edi>, int a3, int a4, char a5, int a6);
char __cdecl sub_1001C9E0(unsigned __int8 a1);
// char __usercall sub_1001CA20@<al>(void *a1@<ecx>, int a2@<esi>);
char __cdecl sub_1001CA60(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_1001CFE0(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_1001D040(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_1001D090(char a1, unsigned __int16 a2, int a3, int a4, int a5);
char __cdecl sub_1001D110(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_1001D8C0(char a1, unsigned __int16 a2, int a3, int a4, int a5);
char __cdecl sub_1001D9A0(char a1, unsigned __int16 a2, int a3, int a4, int a5);
char __cdecl sub_1001DA30(char a1, unsigned __int16 a2, int a3, int a4, int a5);
char __cdecl sub_1001DC40(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_1001DE60(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_1001DEC0(char a1, unsigned __int16 a2, int a3, int a4, int a5);
// void *__usercall sub_1001DF20@<eax>(void *a1@<ebx>, const void *a2@<edi>, int a3@<esi>, int a4);
char sub_1001DF50();
char __cdecl sub_1001DF80(int a1);
signed int __cdecl sub_1001DFC0(_BYTE *a1, char a2, int a3);
int __cdecl sub_1001E010(int, float, float, int, int); // idb
unsigned int __cdecl sub_1001E100(char *a1, char a2, char a3, char a4, int a5);
unsigned int __cdecl sub_1001E150(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5);
unsigned int __cdecl sub_1001E210(void *a1, size_t a2, int a3);
int __cdecl sub_1001E270(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
int __cdecl sub_1001E2C0(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5);
int __cdecl sub_1001E360(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
int __cdecl sub_1001E410(unsigned __int8 *a1);
unsigned int __cdecl sub_1001E430(void *a1);
unsigned int __cdecl sub_1001E450(void *a1);
unsigned int __cdecl sub_1001E470(void *a1);
unsigned int __cdecl sub_1001E490(void *a1);
unsigned int __cdecl sub_1001E4B0(void *a1);
int __cdecl sub_1001E4D0(int a1);
int __cdecl sub_1001E520(void *); // idb
unsigned int __cdecl sub_1001E5F0(void *a1);
int __cdecl sub_1001E650(unsigned __int8 *a1);
int __cdecl sub_1001E670(unsigned __int8 *a1, int a2);
int __cdecl sub_1001E6A0(unsigned __int8 *a1);
int __cdecl sub_1001E6C0(_BYTE *a1);
int __cdecl sub_1001E6E0(unsigned __int8 *a1);
int __cdecl sub_1001E700(unsigned __int8 *a1);
int __cdecl sub_1001E720(unsigned __int8 *a1);
int __cdecl sub_1001E740(unsigned __int8 *a1);
_DWORD __cdecl sub_1001E760(_DWORD); // weak
int __cdecl sub_1001E770(int a1);
int __cdecl sub_1001E7B0(int a1);
char __cdecl sub_1001E7D0(_WORD *a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1001E8A0(int a1);
int __cdecl sub_1001E8F0(_BYTE *a1);
char __cdecl sub_1001E920(_BYTE *a1, _BYTE *a2);
char __cdecl sub_1001E970(_BYTE *a1, _BYTE *a2);
int sub_1001E9C0();
__int16 sub_1001EA90();
// int __usercall sub_1001EAF0@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4);
char sub_1001EB70();
int (__cdecl *(*sub_1001ED30())[2])(int, int);
signed int __cdecl sub_1001EE60(int a1);
double __cdecl sub_1001EE80(signed int a1, char a2);
bool __cdecl sub_1001EEC0(unsigned int a1, unsigned __int16 a2);
int __cdecl sub_1001EF00(unsigned __int16 a1);
int __cdecl sub_1001EF30(double, double); // idb
signed int sub_1001EF80();
bool __cdecl sub_1001EF90(char a1, int a2);
int __cdecl sub_1001F1B0(int a1, signed int a2, signed int a3);
int __cdecl sub_1001F1D0(int, double, double); // idb
int __cdecl sub_1001F2B0(int, float, float); // idb
int sub_1001F3A0();
int __cdecl sub_1001F3D0(int a1, int a2);
bool sub_1001F3F0();
bool sub_1001F400();
int __cdecl sub_1001F420(int a1);
signed int __cdecl sub_1001F520(int a1, int a2);
char __cdecl sub_1001F5C0(char a1);
char __cdecl sub_1001F600(char a1);
signed int __cdecl sub_1001F640(char a1);
char __cdecl sub_1001F680(char a1);
char __cdecl sub_1001F6C0(int a1);
// char __usercall sub_1001F700@<al>(int a1@<edi>, char a2, unsigned __int8 a3);
char __cdecl sub_1001F730(char a1);
char __cdecl sub_1001F750(char a1);
char __cdecl sub_1001F770(char a1);
char __cdecl sub_1001F790(char a1);
char __cdecl sub_1001F7C0(char a1);
char __cdecl sub_1001F7F0(char a1);
int __cdecl sub_1001F830(char *a1, char a2);
bool __cdecl sub_1001F8A0(int a1, void *a2);
char __cdecl sub_1001F960(int a1, bool *a2);
char __thiscall sub_1001FA20(void *this);
char __cdecl sub_1001FAB0(int a1, char a2);
char __cdecl sub_1001FB70(int a1, char a2);
char __cdecl sub_1001FC30(char a1);
char __cdecl sub_1001FC60(char a1);
int __cdecl sub_1001FC90(int *a1, int a2);
int __cdecl sub_1001FCB0(int a1);
signed int __cdecl sub_1001FCF0(char a1, char a2);
int __cdecl sub_1001FD50(char a1);
signed int __cdecl sub_1001FD90(char a1, char a2, char a3);
int __cdecl sub_1001FE00(char a1);
int __cdecl sub_1001FE40(char a1);
char __cdecl sub_1001FE80(char a1, int a2);
char __cdecl sub_1001FEA0(char a1, int a2);
char __cdecl sub_1001FED0(char a1, int a2);
char __cdecl sub_1001FF20(char a1, int a2);
char __cdecl sub_1001FF50(int a1);
char __cdecl sub_1001FF70(char a1, int a2);
char __cdecl sub_1001FF90(int a1);
signed int __fastcall sub_1001FFB0(unsigned __int8 a1);
char __cdecl sub_1001FFC0(unsigned __int8 a1);
__int16 __cdecl sub_1001FFE0(unsigned __int8 a1);
char sub_10020000();
int __cdecl sub_10020080(char a1);
char __cdecl sub_100200A0(unsigned __int8 a1);
int __cdecl sub_100200C0(int, void *); // idb
// int __usercall sub_10020120@<eax>(char a1@<al>);
BOOL __cdecl sub_10020150(char a1, int a2);
int __cdecl sub_10020180(int, char, int, int, void *); // idb
char __cdecl sub_100201B0(void *a1);
BOOL __cdecl sub_100201D0(int a1);
char __cdecl sub_100201F0(int a1, char a2, int a3, int a4, void *a5);
bool __cdecl sub_10020220(unsigned __int8 a1, char a2, unsigned int a3);
bool __cdecl sub_100202B0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6);
bool __cdecl sub_10020350(char a1, void *a2);
// signed int __usercall sub_10020390@<eax>(char a1@<al>);
bool __cdecl sub_100203B0(char a1, void *a2);
bool __cdecl sub_100204A0(char a1, char a2, int a3, int a4, void *a5);
BOOL __cdecl sub_100204D0(unsigned __int8 a1);
// BOOL __usercall sub_100204E0@<eax>(unsigned __int8 a1@<al>, char a2);
bool __cdecl sub_10020510(char a1, char a2, unsigned __int8 a3, int a4);
bool __cdecl sub_100206C0(unsigned __int8 a1, int a2);
bool __cdecl sub_10020700(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6);
char sub_100207F0();
BOOL __cdecl sub_10020890(int a1, int a2);
char __cdecl sub_100208B0(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_100208F0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10020990(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10020A10(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10020A80(char a1, void *a2);
char __cdecl sub_10020B00(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10020B80(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10020C00(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10020C70(char a1, char a2, char a3, unsigned __int8 *a4, int a5);
char __cdecl sub_10020D80(char a1, void *a2);
bool __cdecl sub_10020DA0(unsigned __int8 a1, char *a2);
char __cdecl sub_10020DE0(int a1, char a2, int a3, int a4, void *a5);
BOOL sub_10020E20();
char __cdecl sub_10020E80(int a1, char *a2);
BOOL __cdecl sub_10020F70(int a1, int a2);
char __cdecl sub_10020F90(int a1, char a2, int a3, int a4, char *a5);
char __cdecl sub_10020FD0(int a1, int a2);
BOOL __cdecl sub_10021080(int a1, int a2);
char __cdecl sub_100210A0(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_100210E0(void *a1);
char __cdecl sub_10021100(void *a1);
bool __thiscall sub_10021250(void *this);
char __cdecl sub_10021270(unsigned __int8 a1);
char __cdecl sub_100212E0(int a1, char a2, char a3, int a4, void *a5, size_t a6);
char __cdecl sub_10021480(char a1);
// __int16 __usercall sub_100214C0@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_100214D0(unsigned __int8 a1, char *a2);
char __cdecl sub_100215A0(char a1, char a2, char a3, int a4, char *a5, unsigned int a6);
char __cdecl sub_10021620(char a1, char a2, char a3, int a4, void *a5);
int __cdecl sub_10021730(char a1);
char __cdecl sub_10021780(char a1, int a2);
// int __usercall sub_100218F0@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3);
// int __usercall sub_10021930@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3);
signed int sub_10021970();
char __cdecl sub_10021980(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_100219E0(char a1, void *a2);
char __cdecl sub_10021B00(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10021B80(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6);
char __cdecl sub_10021D30(unsigned __int16 a1, char *a2, char a3);
char __cdecl sub_10021E60(char a1, int a2);
bool __cdecl sub_10021EE0(void *a1);
char __cdecl sub_10021F30(char a1, int a2);
// __int16 __usercall sub_10022010@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_10022020(unsigned __int8 a1, int *a2, const void *a3);
char __cdecl sub_100220B0(unsigned __int8 a1, char a2);
bool __cdecl sub_10022170(__int16 a1, char a2, int a3, int a4, void *a5);
void *sub_10022270();
char __cdecl sub_10022310(const void *a1);
char *__cdecl sub_10022380(char **a1);
int sub_100223D0();
int __cdecl sub_10022410(_BYTE *a1, int a2);
signed int __cdecl sub_10022480(_BYTE *a1, int a2);
// char *__usercall sub_10022520@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>);
// const char *__usercall sub_10022580@<eax>(int a1@<eax>);
// int __usercall sub_100225A0@<eax>(unsigned int a1@<ebx>);
// int __usercall sub_100225E0@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>);
// int __usercall sub_10022680@<eax>(int result@<eax>);
char *__cdecl sub_100226C0(int a1, char *a2, int a3, const char *a4);
// int __usercall sub_10022870@<eax>(int a1@<eax>);
// int __usercall sub_100228A0@<eax>(int a1@<esi>);
void __cdecl sub_100228D0(int (**a1)(void), char **a2, _DWORD *a3);
int sub_10022D40();
void *sub_10022D90();
char *sub_10022DF0();
char __cdecl sub_10022E10(int a1, int a2, unsigned int a3);
char **sub_10022E50();
int __cdecl sub_10022E60(int a1, int a2, int a3);
int __cdecl sub_10022F10(int a1, int a2, int a3, const char *a4, const char *a5);
// char *__usercall sub_10023120@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6);
char *__cdecl sub_100231E0(char a1);
int *__cdecl sub_10023280(_BYTE *a1);
// int __usercall sub_10023340@<eax>(int a1@<eax>);
// signed int __usercall sub_100234A0@<eax>(int a1@<esi>);
int __cdecl sub_10023510(int, int); // weak
// signed int __usercall sub_100237F0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_100248A0@<eax>(int a1@<esi>, int a2, unsigned int a3);
// signed int __usercall sub_10024900@<eax>(int a1@<eax>, int a2, int a3);
// void *__usercall sub_10025680@<eax>(void *a1@<eax>);
unsigned int __cdecl sub_100256A0(int a1, unsigned int a2);
// int __usercall sub_10025700@<eax>(int result@<eax>);
// int __usercall sub_10025740@<eax>(int result@<eax>);
// unsigned int __usercall sub_10026E60@<eax>(int a1@<esi>, int a2);
// void *__usercall sub_10026F60@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3);
// void *__usercall sub_10026FE0@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3);
// int __usercall sub_10027080@<eax>(int a1@<edi>, int a2, size_t a3);
// int __usercall sub_10027140@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3);
// int __usercall sub_100271A0@<eax>(char *a1@<edi>);
// int __usercall sub_10027260@<eax>(int a1@<ebx>);
char __cdecl sub_10027320(char *a1, size_t a2, int a3);
char __cdecl sub_10027370(char *a1, unsigned int a2, int a3);
bool __cdecl sub_100273C0(int a1, int a2);
// int __usercall sub_100273F0@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7);
// int __usercall sub_10027600@<eax>(void *a1@<eax>, int a2);
char *__cdecl sub_10027650(int a1, int a2);
signed int __cdecl sub_100276E0(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6);
bool __cdecl sub_10027810(void *a1, int a2);
// BOOL __usercall sub_10027890@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_10027930@<eax>(int result@<eax>);
unsigned int __fastcall sub_100279C0(unsigned int a1, int a2);
// int __usercall sub_100279E0@<eax>(int result@<eax>);
// int __usercall sub_10027A70@<eax>(int result@<eax>, int a2, int a3);
// int __usercall sub_10027EF0@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>);
// void *__usercall sub_10027FA0@<eax>(int a1@<edi>);
// int __usercall sub_10028000@<eax>(int result@<eax>, int a2@<edx>);
// signed int __usercall sub_100281D0@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>);
_WORD *__fastcall sub_10028250(int a1, int a2);
// signed int __usercall sub_100282C0@<eax>(int a1@<esi>);
// unsigned int __usercall sub_10028380@<eax>(int a1@<esi>, unsigned int a2);
// unsigned int __usercall sub_10028530@<eax>(int a1@<esi>, int a2);
// int __usercall sub_10028600@<eax>(int result@<eax>, int a2@<edi>, int a3);
// int __usercall sub_100286B0@<eax>(int result@<eax>, __int16 a2@<cx>);
// unsigned int __usercall sub_100286F0@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3);
// signed int __usercall sub_10028750@<eax>(signed int result@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_10028830@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
_WORD *__fastcall sub_10028DD0(int a1, int a2);
signed int __cdecl sub_10028E30(int a1);
// int __usercall sub_10028EC0@<eax>(int a1@<eax>);
// int __usercall sub_10029100@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4);
// signed int __usercall sub_100291A0@<eax>(int a1@<esi>, int a2);
// unsigned int __usercall sub_10029380@<eax>(int a1@<edi>);
// int __usercall sub_100294C0@<eax>(int a1@<eax>, int a2, int a3, int a4);
signed int __cdecl sub_10029770(int a1, int a2);
signed int __cdecl sub_10029A30(int a1, unsigned __int8 a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8);
// signed int __usercall sub_10029BE0@<eax>(int a1@<eax>);
// _WORD *__usercall sub_10029CB0@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
signed int __cdecl sub_10029ED0(int a1, int a2);
signed int __cdecl sub_1002A1E0(int a1, int a2);
signed int __cdecl sub_1002A5F0(int a1, int a2);
int __cdecl sub_1002A760(unsigned int a1, _BYTE *a2, unsigned int a3);
signed int __cdecl sub_1002A860(int a1);
// signed int __usercall sub_1002A880@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10);
// int (__cdecl *__usercall sub_1002AD20@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD);
// int __usercall sub_1002AD70@<eax>(int result@<eax>, char a2, char a3, int a4, int a5);
signed int __cdecl sub_1002AD90(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_1002B140@<eax>(int a1@<edi>, int a2@<esi>, int a3);
// signed int __usercall sub_1002B280@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4);
// signed int __usercall sub_1002B2D0@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9);
// int __usercall sub_1002B370@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4);
signed int __cdecl sub_1002B390(int a1, int a2, int a3, int a4);
void __cdecl sub_1002B480(int a1);
// int __usercall sub_1002B490@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_1002BB30@<eax>(int a1@<eax>, int a2, int a3);
// signed int __usercall sub_1002C510@<eax>(int a1@<edi>, int a2);
signed int __cdecl sub_1002C840(int a1, int a2);
__int16 *__cdecl sub_1002C860(char a1, unsigned __int16 a2);
int __cdecl sub_1002CAD0(unsigned __int8 a1, char a2);
int __cdecl sub_1002CB50(unsigned __int8 a1, char a2);
int __cdecl sub_1002CBD0(unsigned __int8 a1, char a2);
void *__cdecl sub_1002CC50(unsigned __int8 a1, char a2);
int __cdecl sub_1002CCD0(char a1);
int __cdecl sub_1002CCF0(char a1);
int __cdecl sub_1002CD10(char a1);
void *__cdecl sub_1002CD30(char a1, unsigned __int8 a2, char a3);
void *__cdecl sub_1002CDF0(unsigned __int8 a1, char a2, char a3);
void *__cdecl sub_1002CE90(unsigned __int8 a1, char a2, char a3);
char sub_1002CF60();
BOOL __fastcall sub_1002CF70(int a1);
void *__cdecl sub_1002CFA0(char a1);
char sub_1002CFF0();
int *__cdecl sub_1002D280(char a1);
bool __thiscall sub_1002D2E0(void *this);
void *__cdecl sub_1002D300(char a1);
int __cdecl sub_1002D360(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_1002D430(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
int __cdecl sub_1002D6D0(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_1002D7A0(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_1002D870(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_1002D940(unsigned __int8 a1, char a2);
int __cdecl sub_1002D9D0(unsigned __int8 a1, char a2);
int __cdecl sub_1002DA60(unsigned __int8 a1, char a2);
int __cdecl sub_1002DAF0(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_1002DBC0(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_1002DC90(unsigned __int8 a1, char a2);
int __cdecl sub_1002DD20(unsigned __int8 a1, char a2);
int __cdecl sub_1002DDB0(int a1, unsigned __int8 a2, char a3);
int __cdecl sub_1002DE50(unsigned __int8 a1, char a2);
int __cdecl sub_1002DE70(unsigned __int8 a1, char a2);
char __cdecl sub_1002DE90(char a1, __int16 a2, unsigned __int16 *a3);
void *__cdecl sub_1002DEF0(char a1);
int __cdecl sub_1002DF50(unsigned __int8 a1, char a2);
int __cdecl sub_1002DFD0(unsigned __int8 a1);
int __cdecl sub_1002DFF0(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_1002E0C0(unsigned __int8 a1, char a2);
int __cdecl sub_1002E150(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_1002E220(int a1, unsigned __int8 a2, char a3);
int __cdecl sub_1002E2C0(unsigned __int8 a1, char a2);
char __cdecl sub_1002E2E0(char a1);
char __cdecl sub_1002E320(char a1);
signed int __cdecl sub_1002E360(char a1);
void *__cdecl sub_1002E3B0(char a1);
void *__cdecl sub_1002E410(char a1);
void *__cdecl sub_1002E470(char a1);
int __cdecl sub_1002E4D0(char a1, char a2);
void *__cdecl sub_1002E570(char a1);
void *__cdecl sub_1002E5D0(char a1);
char __cdecl sub_1002E630(char a1);
char __cdecl sub_1002E650(int a1, int a2);
char __cdecl sub_1002E6A0(int a1, int a2);
char __cdecl sub_1002E750(int a1, int a2);
char __cdecl sub_1002E7B0(int a1, int a2);
double __cdecl sub_1002E880(int a1);
bool __cdecl sub_1002E8D0(void *a1);
char __cdecl sub_1002E910(char a1);
char __cdecl sub_1002E940(char a1, void *a2);
int __cdecl sub_1002E9C0(char a1, _DWORD *a2);
char __cdecl sub_1002EA10(char a1);
char __cdecl sub_1002EA40(char a1);
signed int __cdecl sub_1002EAC0(unsigned __int8 a1);
char __cdecl sub_1002EBF0(unsigned __int8 a1, unsigned __int8 a2);
int __cdecl sub_1002ED20(char a1, char a2);
// bool __usercall sub_1002EDD0@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3);
// char __usercall sub_1002EE00@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6);
char __cdecl sub_1002EEA0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1002EF20(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1002EFA0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1002F020(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1002F0A0(char a1);
int __cdecl sub_1002F140(int a1);
char __cdecl sub_1002F150(int a1, unsigned int a2);
int __cdecl sub_1002F180(int a1, int a2, int a3);
// void __cdecl __noreturn exit_1(int);
int __cdecl sub_1002F1F0(int a1, char a2);
int __cdecl sub_1002F210(int a1, int a2, int a3);
int __cdecl sub_1002F240(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1002F280(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_1002F2C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
char __cdecl sub_1002F310(int a1);
int __cdecl sub_1002F340(int a1);
char *sub_1002F360(char *a1, ...);
int __cdecl sub_1002F3A0(int a1, int a2);
int __cdecl sub_1002F400(int a1);
int __cdecl sub_1002F410(int a1, int a2);
int __cdecl sub_1002F470(int a1);
int sub_1002F480();
bool __thiscall sub_1002F4B0(void *this);
char __cdecl sub_1002F4F0(char a1, void *a2);
char __cdecl sub_1002F5A0(char a1);
// int __fastcall TXT_get_hndl(_DWORD, _DWORD); weak
char __cdecl sub_1002F620(unsigned __int8 a1, int a2, int a3);
char __cdecl sub_1002F6A0(void *a1);
char __cdecl sub_1002FE10(void *a1);
int sub_1002FFA0();
int __cdecl sub_1002FFC0(int a1, int a2, int a3);
int __cdecl sub_1002FFF0(int a1, int a2);
__int16 __cdecl sub_10030020(int a1);
int sub_10030040();
int __cdecl sub_10030060(int a1, int a2, int a3, int a4);
int sub_10030090();
int j_TSK_pvg_get_us_timer(void); // weak
int __cdecl sub_100300F0(int a1, int a2, int a3, int a4);
int __cdecl sub_10030120(int a1);
int __cdecl sub_10030140(int a1);
int __cdecl sub_10030160(int a1, int a2);
int __cdecl sub_10030190(int a1, int a2);
int __cdecl sub_100301C0(int a1, int a2, int a3, int a4);
int __cdecl sub_100301F0(int a1, int a2);
int __cdecl sub_10030220(int a1);
int __cdecl sub_10030240(int a1);
char __cdecl sub_10030260(int a1, int a2);
int __cdecl sub_100302D0(_BYTE *a1);
int __cdecl sub_10030310(int a1, int a2);
int __cdecl sub_10030340(int a1, int a2);
int __cdecl j_reg_bkup_to_xml_arch(_DWORD, _DWORD); // weak
int __cdecl sub_10030370(int a1);
const char *__cdecl sub_100303B0(signed int a1);
int __fastcall j_reg_get_tag_hdr(_DWORD, _DWORD); // weak
int nullsub_2(void); // weak
int __cdecl sub_100303F0(int a1, int a2, int a3);
char __cdecl sub_10030410(int a1, int a2, int a3);
int __cdecl sub_10030450(int, void *, int, void *); // idb
int __cdecl sub_10030490(int a1, int a2, int a3);
int __cdecl sub_100304C0(int a1, int a2, int a3);
int __cdecl sub_100304E0(int a1, int a2, int a3);
int __cdecl sub_10030540(int a1, int a2, int a3);
char __cdecl sub_10030580(int a1, _DWORD *a2, int a3, int a4, int a5, unsigned int a6);
int __cdecl sub_10030690(int, void *, int, void *); // idb
char __cdecl sub_100306E0(_DWORD *a1);
// int _RTC_NumErrors(void); weak
bool sub_10030750();
signed int __cdecl sub_10030770(unsigned int a1);
int __cdecl j_FIL_vfs_copy(_DWORD, _DWORD); // weak
int j_FIL_vfs_dyn_linker(void); // weak
int __cdecl j_FIL_vfs_ioctl(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_100307E0(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_mkdir(_DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_10030860(unsigned int a1, void *a2, int a3);
signed int __cdecl sub_100308A0(unsigned int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD); // weak
signed int __cdecl sub_10030930(unsigned int a1, int a2, int a3, int a4);
__int64 __cdecl sub_10030980(int a1);
int j_FIL_vfs_sync_all(void); // weak
int __cdecl sub_100309B0(int a1, int a2, int a3);
int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_100309E0(int a1, int a2, int a3, char a4);
char __cdecl sub_10030A00(int a1);
char __cdecl sub_10030A30(int a1);
int __cdecl sub_10030A60(char *, size_t, int, int); // idb
signed int __cdecl sub_10030C60(unsigned int a1, int a2, int a3);
int __cdecl sub_10030C80(int a1, int a2, int a3);
char __cdecl sub_10030CA0(int a1, char *a2, size_t a3, char a4);
char __cdecl sub_10030D10(int a1, char *a2, size_t a3, char a4);
int __cdecl j_IOP_pvg_net_stat(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_create_id(_DWORD); // weak
int __cdecl sub_10030E20(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl sub_10030E70(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD); // weak
int sub_10030EE0(void); // weak
int __cdecl sub_10030EF0(int a1, int a2);
signed int __cdecl sub_10030F50(int a1);
// int __usercall sub_10030FD0@<eax>(const char **a1@<esi>);
// int __usercall sub_100312D0@<eax>(int a1@<eax>, int a2@<ecx>);
signed int __cdecl sub_100312F0(int a1);
int __cdecl sub_100313C0(LONG Value); // idb
void __cdecl sub_10031450(int a1, _BYTE *a2);
int __cdecl sub_10031480(int a1, int a2);
__int16 __cdecl sub_100314A0(int a1, int a2, int a3, int a4);
int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD); // weak
__int16 __cdecl sub_100314E0(int a1, _DWORD *a2, _BYTE *a3);
int __cdecl sub_10031540(int a1);
int __cdecl sub_10031580(int a1);
int __cdecl sub_100315C0(int a1);
int __cdecl sub_10031600(int a1);
int __cdecl sub_10031640(int a1, int a2, int a3, int a4);
int __cdecl sub_100316B0(int a1, int a2, int a3);
int sub_10031750(void); // weak
char __cdecl sub_10031760(unsigned int a1, unsigned int *a2, int *a3);
unsigned int __cdecl sub_10031A20(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6);
// int __usercall sub_10031BD0@<eax>(int a1@<esi>);
int __cdecl sub_10031C80(int a1, unsigned __int64 a2);
// int __usercall sub_10031D30@<eax>(int a1@<ebx>, unsigned __int64 a2);
unsigned int __cdecl sub_10031DC0(int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_mem_unmap(_DWORD, _DWORD); // weak
void __cdecl sub_10031F20(__int16 a1, _BYTE *a2);
double __cdecl sub_10031F50(char a1);
char sub_10031FE0();
char __cdecl sub_10032030(int a1);
int __cdecl sub_10032280(unsigned __int8 a1, unsigned int a2);
unsigned int __cdecl sub_100322A0(unsigned int *a1, signed int a2, unsigned int a3);
double __cdecl sub_100323D0(double a1, double a2);
double __cdecl sub_10032430(float a1, float a2);
int __cdecl sub_100324B0(double); // idb
double __cdecl sub_100324D0(float a1);
int __cdecl sub_10032510(int a1, int a2);
int __cdecl sub_10032530(int a1, int a2);
int __cdecl sub_10032550(float); // idb
int __cdecl sub_100325B0(int a1, int a2, int a3);
int __cdecl sub_100325E0(float, int, int); // idb
// int __cdecl SIM_proc_rqst(_DWORD); weak
// int SYS_exit_krnl(void); weak
// int __cdecl SYS_pvg_is_booting(_DWORD); weak
// int SYS_enter_krnl(void); weak
// int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_get_hdr(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_get_hdr_text_lvl(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_id_is_set(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_is_acked(_DWORD); weak
// int __cdecl SYS_pvg_alrt_is_set_text(_DWORD, _DWORD); weak
// int TSK_pvg_get_id(void); weak
// int __cdecl TSK_pvg_get_mon_data(_DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_run_state(_DWORD); weak
// int TSK_pvg_get_timer(void); weak
// int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_release_smphr(_DWORD); weak
// int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_set_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_suspend(_DWORD); weak
// int __cdecl TSK_pvg_wait_evnt(_DWORD); weak
// int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_close(void); weak
// int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_read(void); weak
// int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_size(_DWORD); weak
// int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD); weak
// int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD); weak
// void *__cdecl memset(void *, int, size_t);
__int32 __cdecl j__atol(const char *);
// _DWORD __thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *); idb
// int __cdecl isalpha(int);
// int __cdecl isdigit(int);
// int __cdecl isalnum(int);
// int __cdecl toupper(int);
// void *__cdecl memcpy(void *, const void *, size_t);
// int sprintf(char *, const char *, ...);
// char *__cdecl strncpy(char *, const char *, size_t);
// int _snprintf(char *, size_t, const char *, ...);
// char *__cdecl strstr(const char *, const char *);
// void *__cdecl memcpy_0(void *, const void *, size_t);
// int __cdecl strncmp(const char *, const char *, size_t);
// char *__cdecl strchr(const char *, int);
// char *__cdecl strrchr(const char *, int);
// int __cdecl tolower(int);
// void *__cdecl memchr(const void *, int, size_t);
// int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
// char *__cdecl strncat(char *, const char *, size_t);
// int *__cdecl _errno();
// unsigned __int32 *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
// int _getptd(void); weak
// int __cdecl isleadbyte(int);
int __cdecl sub_10036BEF(int, FILE *); // idb
int __cdecl sub_10037784(int a1);
// int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
signed int __cdecl sub_10038D0C(_DWORD *a1);
signed int __cdecl sub_10038D43(_DWORD *a1);
// void __cdecl free(void *);
// _DWORD __cdecl _calloc_crt(size_t, _DWORD); weak
void sub_10039314();
int (*sub_100397C1())(void);
void __cdecl sub_100397E5(); // idb
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int _get_sse2_info(void); weak
int sub_1003E18B();
void sub_1003E198();
DWORD __cdecl sub_1003EC2C(int a1, int a2, int a3, DWORD dwMoveMethod);
// __int64 __cdecl _lseeki64(int, __int64, int);
_WORD *__cdecl sub_1003EDC8(int a1, int a2, DWORD nNumberOfBytesToWrite);
_WORD *__cdecl sub_1003F3EA(int a1, int a2, DWORD nNumberOfBytesToWrite);
// _DWORD __cdecl _getbuf(_DWORD); weak
int __cdecl sub_1003F50A(signed int a1);
void **sub_1003F568();
signed int sub_1003F56E();
// int __cdecl _fileno(FILE *);
int __cdecl sub_1003F8C6(int, int, struct localeinfo_struct *); // idb
int __cdecl sub_1003F96C(int, int, struct localeinfo_struct *); // idb
int sub_10040352();
int __cdecl sub_1004050F(int a1);
int __cdecl sub_10040519(int a1);
int __cdecl sub_10040523(int a1);
int __cdecl sub_10040602(int a1);
signed int __cdecl sub_100414FF(int a1, int a2);
signed int __cdecl sub_10041A41(int a1, int a2);
// int __cdecl mbtowc(wchar_t *, const char *, size_t);
int sub_10042279();
signed int __cdecl sub_10042C37(signed int a1);
signed int __cdecl sub_10042CB8(signed int a1);
// _DWORD __cdecl __lock_fhandle(_DWORD); weak
void __cdecl sub_10042DC9(signed int a1);
// int __cdecl _putwch_nolock(__int16 Buffer); idb
// _DWORD __cdecl flsall(_DWORD); weak
int sub_100430CA();
int __cdecl sub_10043DCA(int a1, int a2, int a3);
signed int __cdecl sub_1004451C(signed int a1);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// UINT __stdcall GetConsoleCP();
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall GetLastError();
// LONG __stdcall InterlockedExchange(volatile LONG *Target, LONG Value);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_1002B240; // weak
char *off_10045CA4[7] = { "B", "C", "D", "D_DBG", "HSDBM", "M", "A" }; // weak
char *off_10046438 = " "; // weak
char byte_1004645A[] = { '\0' }; // weak
char *off_1004672C = "/dev/sys_nand0"; // weak
_UNKNOWN unk_10046730; // weak
int dword_10046734[] = { 0 }; // weak
int dword_10046738[] = { 0 }; // weak
int dword_1004673C[] = { 0 }; // weak
_UNKNOWN unk_100468A4; // weak
_UNKNOWN unk_100468A8; // weak
_UNKNOWN unk_100468CC; // weak
int dword_100468D0[] = { 50 }; // weak
int dword_100468D4[] = { 20000 }; // weak
int dword_100468D8[] = { 30 }; // weak
int dword_100468DC[] = { 20000 }; // weak
_UNKNOWN unk_10046940; // weak
int dword_10046944[] = { 1 }; // weak
_UNKNOWN unk_10046978; // weak
__int16 word_1004697C[] = { 31 }; // weak
_UNKNOWN unk_100469B0; // weak
__int16 word_100469B4[] = { 30 }; // weak
char *off_100469E8[3] = { "sys_nand0", &off_1004672C, "sd_card0" }; // weak
char *off_100469EC[2] = { &off_1004672C, "sd_card0" }; // weak
char byte_1004764C[] = { '\0' }; // weak
char word_10047844[] = { '\r', '\n' }; // idb
void *tsk_app_hdr_ptr = &tsk_app_hdr; // weak
int dword_1004B7F8[] = { 256 }; // weak
__int16 word_1004B7FC[] = { 8 }; // weak
char *off_1004BDD8 = "/shr_mem/iop_diag_intf.shr"; // weak
char *off_1004C3A4 = "/shr_mem/iop_dnld_mngr_intf.shr"; // weak
_UNKNOWN unk_1004D7D0; // weak
_UNKNOWN unk_1004E878; // weak
char *off_1004E9F4 = "/shr_mem/iop_d_dbg_pkt_intf.shr"; // weak
char *off_1004EA08[82] =
{
  "GSD_1_TICK",
  "GSD_2_TICK",
  "GIA_1_DBG",
  "GIA_2_DBG",
  "GIA_1_DBG_CMD",
  "GIA_2_DBG_CMD",
  "GIA_CONIO",
  "GTS_DBG",
  "GTS_DBG_CMD",
  "GTS_CONIO",
  "GWX_DBG",
  "GWX_DBG_CMD",
  "GWX_CONIO",
  "PFD_1_DBG_RX",
  "PFD_1_DBG_TX",
  "MFD_1_DBG_RX",
  "MFD_1_DBG_TX",
  "PFD_2_DBG_RX",
  "PFD_2_DBG_TX",
  "PFD_1_TAWS_LOG",
  "MFD_1_TAWS_LOG",
  "PFD_2_TAWS_LOG",
  "PFD_1_VNAV_LOG",
  "MFD_1_VNAV_LOG",
  "PFD_2_VNAV_LOG",
  "MFD_1_FPL_LOG",
  "GSD_1_DBG",
  "GSD_2_DBG",
  "GSD_1_DBG_CMD",
  "GSD_2_DBG_CMD",
  "GSD_CONIO",
  "PFD_1_ATM",
  "MFD_1_ATM",
  "PFD_2_ATM",
  "CNFG_UPLOAD_STATUS",
  "GDL59_DBG",
  "GDL59_CONIO",
  "GDL59_DBG_CMD",
  "TAWS_LOG_DATA",
  "GDU_TSK_LOG",
  "HSDB_TEST",
  "TEST_TX_ON_PUT",
  "PFD_1_NAV_LOG",
  "MFD_1_NAV_LOG",
  "PFD_2_NAV_LOG",
  "DEMO_ALT",
  "DEMO_HDG",
  "DEMO_POS",
  "DEMO_TRK_MODE",
  "DEMO_VEL",
  "DEMO_VSPD",
  "DEMO_WND_DIR",
  "DEMO_WND_SPD",
  "DEMO_TMOUT_EXT",
  "DEMO_TIME_SCALE",
  "GDU_CNFG_ID",
  "GMA_1_DBG",
  "GMA_1_AUX_DBG",
  "GMA_1_CONIO",
  "GMA_2_DBG",
  "GMA_2_AUX_DBG",
  "GMA_2_CONIO",
  "GMA_1_AUX_CONIO",
  "GMA_2_AUX_CONIO",
  "RGN_NOTIFICATION",
  "RGN_BUFFER",
  "RGN_ACK",
  "GTC_1_DBG_RX",
  "GTC_2_DBG_RX",
  "GTC_1_DBG_TX",
  "GTC_2_DBG_TX",
  "GDR_CONIO",
  "GDR_AUX_CONIO",
  "GSD_3_DBG",
  "GSD_3_DBG_CMD",
  "GSD_3_TICK",
  "SCRN_CAP_ENBLD",
  "GTC_3_DBG_RX",
  "GTC_4_DBG_RX",
  "GTC_3_DBG_TX",
  "GTC_4_DBG_TX",
  "GRA_CONIO"
}; // weak
_UNKNOWN unk_1004EB50; // weak
char *off_1004EC48 = "/shr_mem/iop_d_dbg_pkt_names_intf.shr"; // weak
int dword_1004F5F4[] = { 88 }; // weak
__int16 word_1004FAA4[] = { 836 }; // weak
__int16 word_1004FAB4[] = { 529 }; // weak
char *off_1004FAC4 = "/shr_mem/iop_a_pkt_intf.shr"; // weak
char *off_1004FAD8 = "/shr_mem/iop_b_pkt_intf.shr"; // weak
char *off_1004FAEC = "/shr_mem/iop_c_pkt_intf.shr"; // weak
char *off_1004FB00 = "/shr_mem/iop_d_dbg_pkt_intf.shr"; // weak
char *off_1004FB14 = "/shr_mem/iop_d_pkt_intf.shr"; // weak
char *off_1004FB28 = "/shr_mem/iop_m_pkt_intf.shr"; // weak
char *off_1004FB3C = "/shr_mem/iop_a_pkt_names_intf.shr"; // weak
char *off_1004FB50 = "/shr_mem/iop_b_pkt_names_intf.shr"; // weak
char *off_1004FB64 = "/shr_mem/iop_c_pkt_names_intf.shr"; // weak
char *off_1004FB78 = "/shr_mem/iop_d_dbg_pkt_names_intf.shr"; // weak
char *off_1004FB8C = "/shr_mem/iop_d_pkt_names_intf.shr"; // weak
char *off_1004FBA0 = "/shr_mem/iop_m_pkt_names_intf.shr"; // weak
_UNKNOWN unk_10052A70; // weak
_UNKNOWN unk_10052A71; // weak
_UNKNOWN unk_10052AD0; // weak
_UNKNOWN unk_10052AD1; // weak
_UNKNOWN unk_10052B20; // weak
_UNKNOWN unk_10052B21; // weak
char *off_10052C54 = "/shr_mem/udb_intf.shr"; // weak
_UNKNOWN unk_1005319C; // weak
_UNKNOWN unk_10053208; // weak
char byte_10053800[] = { '\0' }; // weak
char byte_10053801[] = { '\0' }; // weak
char byte_10053802[] = { '\xFF' }; // weak
char byte_10053803[] = { '\xFF' }; // weak
char byte_10053804[] = { '\xFF' }; // weak
char byte_10053834[] = { '\x05' }; // weak
char byte_10053838[] = { '\b' }; // weak
int dword_1005383C[] = { 9 }; // weak
char byte_10053864[] = { ' ' }; // weak
char byte_1005386C[] = { ' ' }; // weak
_UNKNOWN unk_10053874; // weak
char aWgs84[21] = "WGS 84              "; // weak
int dword_10057E10[] = { 1 }; // weak
int off_10057E14[2] = { 268725100, 2 }; // idb
_UNKNOWN unk_10057F14; // weak
_BYTE word_10057F8A[2538] =
{
  0,
  0,
  0,
  0,
  31,
  0,
  59,
  0,
  90,
  0,
  120,
  0,
  151,
  0,
  181,
  0,
  212,
  0,
  243,
  0,
  17,
  1,
  48,
  1,
  78,
  1,
  0,
  0,
  0,
  0,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  74,
  75,
  76,
  77,
  80,
  81,
  82,
  83,
  0,
  0,
  93,
  0,
  90,
  0,
  87,
  0,
  96,
  0,
  1,
  0,
  94,
  0,
  91,
  0,
  88,
  0,
  97,
  0,
  2,
  0,
  95,
  0,
  92,
  0,
  89,
  0,
  98,
  0,
  0,
  0,
  0,
  0,
  226,
  0,
  228,
  0,
  224,
  0,
  1,
  0,
  227,
  0,
  229,
  0,
  225,
  0,
  2,
  0,
  60,
  2,
  61,
  2,
  59,
  2,
  0,
  0,
  220,
  0,
  1,
  0,
  222,
  0,
  2,
  0,
  58,
  2,
  23,
  21,
  3,
  3,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  10,
  18,
  10,
  18,
  10,
  28,
  14,
  29,
  14,
  29,
  14,
  29,
  10,
  29,
  10,
  28,
  10,
  24,
  10,
  24,
  0,
  24,
  0,
  23,
  0,
  22,
  0,
  23,
  0,
  23,
  0,
  23,
  0,
  28,
  0,
  24,
  0,
  22,
  0,
  20,
  10,
  24,
  10,
  18,
  10,
  20,
  10,
  24,
  10,
  13,
  10,
  20,
  10,
  28,
  10,
  18,
  0,
  22,
  0,
  22,
  0,
  20,
  0,
  18,
  10,
  18,
  0,
  28,
  0,
  23,
  0,
  22,
  10,
  28,
  10,
  22,
  10,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  0,
  0,
  0,
  85,
  78,
  75,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  65,
  76,
  69,
  82,
  84,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  0,
  0,
  0,
  80,
  65,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,
  0,
  0,
  0,
  66,
  65,
  82,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  4,
  0,
  0,
  0,
  72,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  5,
  0,
  0,
  0,
  72,
  80,
  65,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  6,
  0,
  0,
  0,
  80,
  83,
  73,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  7,
  0,
  0,
  0,
  70,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  8,
  0,
  0,
  0,
  67,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  9,
  0,
  0,
  0,
  99,
  97,
  114,
  100,
  56,
  32,
  112,
  116,
  0,
  0,
  0,
  0,
  10,
  0,
  0,
  0,
  82,
  65,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  11,
  0,
  0,
  0,
  83,
  95,
  83,
  69,
  77,
  73,
  0,
  0,
  0,
  0,
  0,
  0,
  12,
  0,
  0,
  0,
  83,
  69,
  77,
  73,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  13,
  0,
  0,
  0,
  68,
  69,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  14,
  0,
  0,
  0,
  100,
  105,
  115,
  116,
  97,
  110,
  99,
  101,
  0,
  0,
  0,
  0,
  15,
  0,
  0,
  0,
  83,
  69,
  67,
  79,
  78,
  68,
  83,
  0,
  0,
  0,
  0,
  0,
  16,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  17,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  18,
  0,
  0,
  0,
  109,
  116,
  47,
  115,
  101,
  99,
  0,
  0,
  0,
  0,
  0,
  0,
  19,
  0,
  0,
  0,
  109,
  116,
  47,
  109,
  105,
  110,
  0,
  0,
  0,
  0,
  0,
  0,
  20,
  0,
  0,
  0,
  102,
  116,
  47,
  109,
  105,
  110,
  0,
  0,
  0,
  0,
  0,
  0,
  21,
  0,
  0,
  0,
  107,
  112,
  104,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  22,
  0,
  0,
  0,
  107,
  116,
  115,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  23,
  0,
  0,
  0,
  109,
  112,
  104,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  0,
  0,
  0,
  109,
  116,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  25,
  0,
  0,
  0,
  109,
  116,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  26,
  0,
  0,
  0,
  109,
  105,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  27,
  0,
  0,
  0,
  109,
  105,
  108,
  115,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  28,
  0,
  0,
  0,
  102,
  116,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  29,
  0,
  0,
  0,
  107,
  109,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  30,
  0,
  0,
  0,
  110,
  109,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  31,
  0,
  0,
  0,
  78,
  42,
  109,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  32,
  0,
  0,
  0,
  108,
  98,
  45,
  102,
  116,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  33,
  0,
  0,
  0,
  76,
  66,
  70,
  73,
  78,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  34,
  0,
  0,
  0,
  77,
  47,
  83,
  94,
  50,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  35,
  0,
  0,
  0,
  103,
  39,
  115,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  36,
  0,
  0,
  0,
  108,
  116,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  103,
  108,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  38,
  0,
  0,
  0,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  39,
  0,
  0,
  0,
  108,
  116,
  47,
  115,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  40,
  0,
  0,
  0,
  103,
  108,
  47,
  104,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  41,
  0,
  0,
  0,
  73,
  71,
  47,
  104,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  42,
  0,
  0,
  0,
  107,
  103,
  95,
  65,
  47,
  104,
  0,
  0,
  0,
  0,
  0,
  0,
  43,
  0,
  0,
  0,
  107,
  103,
  95,
  65,
  86,
  47,
  104,
  0,
  0,
  0,
  0,
  0,
  44,
  0,
  0,
  0,
  107,
  103,
  95,
  66,
  47,
  104,
  0,
  0,
  0,
  0,
  0,
  0,
  45,
  0,
  0,
  0,
  107,
  103,
  95,
  68,
  83,
  76,
  47,
  104,
  0,
  0,
  0,
  0,
  46,
  0,
  0,
  0,
  108,
  98,
  95,
  65,
  47,
  104,
  0,
  0,
  0,
  0,
  0,
  0,
  47,
  0,
  0,
  0,
  108,
  98,
  95,
  65,
  86,
  47,
  104,
  0,
  0,
  0,
  0,
  0,
  48,
  0,
  0,
  0,
  108,
  98,
  95,
  66,
  47,
  104,
  0,
  0,
  0,
  0,
  0,
  0,
  49,
  0,
  0,
  0,
  108,
  98,
  95,
  68,
  83,
  76,
  47,
  104,
  0,
  0,
  0,
  0,
  50,
  0,
  0,
  0,
  108,
  116,
  47,
  104,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  51,
  0,
  0,
  0,
  109,
  47,
  108,
  116,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  52,
  0,
  0,
  0,
  109,
  105,
  47,
  103,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  53,
  0,
  0,
  0,
  110,
  109,
  47,
  103,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  54,
  0,
  0,
  0,
  107,
  103,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  55,
  0,
  0,
  0,
  108,
  98,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  56,
  0,
  0,
  0,
  103,
  114,
  109,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  57,
  0,
  0,
  0,
  107,
  103,
  95,
  65,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  58,
  0,
  0,
  0,
  107,
  103,
  95,
  65,
  86,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  59,
  0,
  0,
  0,
  107,
  103,
  95,
  66,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  60,
  0,
  0,
  0,
  107,
  103,
  95,
  68,
  83,
  76,
  0,
  0,
  0,
  0,
  0,
  0,
  61,
  0,
  0,
  0,
  108,
  98,
  95,
  65,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  62,
  0,
  0,
  0,
  108,
  98,
  95,
  65,
  86,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  63,
  0,
  0,
  0,
  108,
  98,
  95,
  66,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  64,
  0,
  0,
  0,
  108,
  98,
  95,
  68,
  83,
  76,
  0,
  0,
  0,
  0,
  0,
  0,
  65,
  0,
  0,
  0,
  82,
  80,
  77,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  66,
  0,
  0,
  0,
  114,
  97,
  100,
  47,
  115,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  67,
  0,
  0,
  0,
  99,
  117,
  32,
  105,
  110,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  73,
  78,
  65,
  67,
  84,
  73,
  86,
  69,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  65,
  67,
  84,
  73,
  86,
  69,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  65,
  95,
  85,
  78,
  75,
  78,
  79,
  87,
  78,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,
  73,
  95,
  85,
  78,
  75,
  78,
  79,
  87,
  78,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  136,
  25,
  0,
  0,
  1,
  0,
  1,
  0,
  137,
  25,
  0,
  0,
  2,
  0,
  1,
  0,
  138,
  25,
  0,
  0,
  4,
  0,
  1,
  0,
  139,
  25,
  0,
  0,
  5,
  0,
  1,
  0,
  140,
  25,
  0,
  0,
  6,
  0,
  1,
  0,
  141,
  25,
  0,
  0,
  18,
  0,
  1,
  0,
  142,
  25,
  0,
  0,
  19,
  0,
  1,
  0,
  143,
  25,
  0,
  0,
  20,
  0,
  1,
  0,
  144,
  25,
  0,
  0,
  21,
  0,
  1,
  0,
  145,
  25,
  0,
  0,
  22,
  0,
  1,
  0,
  146,
  25,
  0,
  0,
  23,
  0,
  1,
  0,
  147,
  25,
  0,
  0,
  25,
  0,
  1,
  0,
  148,
  25,
  0,
  0,
  26,
  0,
  1,
  0,
  149,
  25,
  0,
  0,
  27,
  0,
  1,
  0,
  150,
  25,
  0,
  0,
  28,
  0,
  1,
  0,
  151,
  25,
  0,
  0,
  29,
  0,
  1,
  0,
  152,
  25,
  0,
  0,
  30,
  0,
  1,
  0,
  153,
  25,
  0,
  0,
  31,
  0,
  1,
  0,
  154,
  25,
  0,
  0,
  32,
  0,
  4,
  0,
  155,
  25,
  0,
  0,
  36,
  0,
  4,
  0,
  156,
  25,
  0,
  0,
  40,
  0,
  1,
  0,
  157,
  25,
  0,
  0,
  41,
  0,
  1,
  0,
  158,
  25,
  0,
  0,
  42,
  0,
  1,
  0,
  159,
  25,
  0,
  0,
  43,
  0,
  1,
  0,
  160,
  25,
  0,
  0,
  44,
  0,
  1,
  0,
  161,
  25,
  0,
  0,
  45,
  0,
  1,
  0,
  162,
  25,
  0,
  0,
  46,
  0,
  1,
  0,
  163,
  25,
  0,
  0,
  47,
  0,
  1,
  0,
  164,
  25,
  0,
  0,
  49,
  0,
  1,
  0,
  166,
  25,
  0,
  0,
  50,
  0,
  30,
  0,
  167,
  25,
  0,
  0,
  80,
  0,
  1,
  0,
  168,
  25,
  0,
  0,
  81,
  0,
  1,
  0,
  169,
  25,
  0,
  0,
  84,
  0,
  4,
  0,
  170,
  25,
  0,
  0,
  88,
  0,
  1,
  0,
  171,
  25,
  0,
  0,
  89,
  0,
  1,
  0,
  172,
  25,
  0,
  0,
  92,
  0,
  4,
  0,
  173,
  25,
  0,
  0,
  96,
  0,
  4,
  0,
  174,
  25,
  0,
  0,
  100,
  0,
  1,
  0,
  175,
  25,
  0,
  0,
  208,
  0,
  4,
  0,
  168,
  23,
  0,
  0,
  104,
  0,
  1,
  0,
  177,
  25,
  0,
  0,
  105,
  0,
  1,
  0,
  178,
  25,
  0,
  0,
  106,
  0,
  1,
  0,
  179,
  25,
  0,
  0,
  107,
  0,
  1,
  0,
  180,
  25,
  0,
  0,
  108,
  0,
  1,
  0,
  181,
  25,
  0,
  0,
  109,
  0,
  1,
  0,
  182,
  25,
  0,
  0,
  110,
  0,
  1,
  0,
  183,
  25,
  0,
  0,
  111,
  0,
  1,
  0,
  184,
  25,
  0,
  0,
  112,
  0,
  1,
  0,
  185,
  25,
  0,
  0,
  113,
  0,
  1,
  0,
  186,
  25,
  0,
  0,
  114,
  0,
  1,
  0,
  187,
  25,
  0,
  0,
  115,
  0,
  1,
  0,
  188,
  25,
  0,
  0,
  116,
  0,
  1,
  0,
  189,
  25,
  0,
  0,
  117,
  0,
  1,
  0,
  190,
  25,
  0,
  0,
  118,
  0,
  1,
  0,
  191,
  25,
  0,
  0,
  120,
  0,
  4,
  0,
  192,
  25,
  0,
  0,
  124,
  0,
  4,
  0,
  193,
  25,
  0,
  0,
  128,
  0,
  4,
  0,
  194,
  25,
  0,
  0,
  132,
  0,
  4,
  0,
  195,
  25,
  0,
  0,
  136,
  0,
  4,
  0,
  196,
  25,
  0,
  0,
  140,
  0,
  1,
  0,
  197,
  25,
  0,
  0,
  141,
  0,
  1,
  0,
  198,
  25,
  0,
  0,
  142,
  0,
  1,
  0,
  199,
  25,
  0,
  0,
  144,
  0,
  2,
  0,
  200,
  25,
  0,
  0,
  146,
  0,
  1,
  0,
  201,
  25,
  0,
  0,
  147,
  0,
  1,
  0,
  202,
  25,
  0,
  0,
  148,
  0,
  1,
  0,
  203,
  25,
  0,
  0,
  149,
  0,
  1,
  0,
  204,
  25,
  0,
  0,
  150,
  0,
  1,
  0,
  205,
  25,
  0,
  0,
  151,
  0,
  1,
  0,
  206,
  25,
  0,
  0,
  152,
  0,
  1,
  0,
  207,
  25,
  0,
  0,
  153,
  0,
  1,
  0,
  208,
  25,
  0,
  0,
  154,
  0,
  1,
  0,
  209,
  25,
  0,
  0,
  155,
  0,
  1,
  0,
  210,
  25,
  0,
  0,
  156,
  0,
  1,
  0,
  211,
  25,
  0,
  0,
  157,
  0,
  1,
  0,
  212,
  25,
  0,
  0,
  158,
  0,
  1,
  0,
  213,
  25,
  0,
  0,
  159,
  0,
  1,
  0,
  214,
  25,
  0,
  0,
  160,
  0,
  1,
  0,
  215,
  25,
  0,
  0,
  161,
  0,
  1,
  0,
  216,
  25,
  0,
  0,
  162,
  0,
  1,
  0,
  217,
  25,
  0,
  0,
  163,
  0,
  1,
  0,
  218,
  25,
  0,
  0,
  164,
  0,
  1,
  0,
  219,
  25,
  0,
  0,
  165,
  0,
  1,
  0,
  220,
  25,
  0,
  0,
  166,
  0,
  1,
  0,
  221,
  25,
  0,
  0,
  167,
  0,
  1,
  0,
  222,
  25,
  0,
  0,
  168,
  0,
  1,
  0,
  223,
  25,
  0,
  0,
  169,
  0,
  1,
  0,
  224,
  25,
  0,
  0,
  170,
  0,
  1,
  0,
  225,
  25,
  0,
  0,
  171,
  0,
  1,
  0,
  226,
  25,
  0,
  0,
  172,
  0,
  1,
  0,
  227,
  25,
  0,
  0,
  173,
  0,
  1,
  0,
  228,
  25,
  0,
  0,
  174,
  0,
  1,
  0,
  229,
  25,
  0,
  0,
  177,
  0,
  1,
  0,
  231,
  25,
  0,
  0,
  178,
  0,
  1,
  0,
  232,
  25,
  0,
  0,
  179,
  0,
  1,
  0,
  233,
  25,
  0,
  0,
  180,
  0,
  1,
  0,
  234,
  25,
  0,
  0,
  181,
  0,
  1,
  0,
  235,
  25,
  0,
  0,
  182,
  0,
  5,
  0,
  236,
  25,
  0,
  0,
  187,
  0,
  1,
  0,
  237,
  25,
  0,
  0,
  188,
  0,
  1,
  0,
  238,
  25,
  0,
  0,
  189,
  0,
  1,
  0,
  239,
  25,
  0,
  0,
  190,
  0,
  1,
  0,
  240,
  25,
  0,
  0,
  191,
  0,
  1,
  0,
  241,
  25,
  0,
  0,
  192,
  0,
  1,
  0,
  242,
  25,
  0,
  0,
  193,
  0,
  1,
  0,
  243,
  25,
  0,
  0,
  194,
  0,
  1,
  0,
  244,
  25,
  0,
  0,
  195,
  0,
  1,
  0,
  245,
  25,
  0,
  0,
  196,
  0,
  1,
  0,
  246,
  25,
  0,
  0,
  197,
  0,
  1,
  0,
  28,
  26,
  0,
  0,
  198,
  0,
  1,
  0,
  29,
  26,
  0,
  0,
  199,
  0,
  1,
  0,
  30,
  26,
  0,
  0,
  200,
  0,
  1,
  0,
  117,
  26,
  0,
  0,
  201,
  0,
  1,
  0,
  118,
  26,
  0,
  0,
  202,
  0,
  1,
  0,
  124,
  26,
  0,
  0,
  203,
  0,
  1,
  0,
  144,
  26,
  0,
  0,
  204,
  0,
  1,
  0,
  145,
  26,
  0,
  0,
  205,
  0,
  1,
  0,
  30,
  27,
  0,
  0,
  206,
  0,
  1,
  0,
  149,
  26,
  0,
  0,
  32,
  0,
  0,
  0,
  150,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  167,
  26,
  0,
  0,
  4,
  0,
  0,
  0,
  168,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  169,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  170,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  171,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  172,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  176,
  26,
  0,
  0,
  13,
  0,
  0,
  0,
  241,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  244,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  247,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  248,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  249,
  26,
  0,
  0,
  13,
  0,
  0,
  0,
  29,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  40,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  39,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  47,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  49,
  27,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0
}; // idb
_UNKNOWN unk_10059908; // weak
char *off_1005A1E0 = "/shr_mem/mon_log_intf.shr"; // weak
char *off_1005A1F4 = "/shr_mem/mon_main_intf.shr"; // weak
int (__cdecl *off_1005A730)(int, size_t, void *) = &sub_10016C80; // weak
_UNKNOWN unk_1005BE20; // weak
int dword_1005BE24[] = { 0 }; // weak
_UNKNOWN unk_1005C1C0; // weak
int dword_1005C1C4[] = { 0 }; // weak
char *off_1005C418 = "/shr_mem/iop_cnfg_mngr_intf.shr"; // weak
char *off_1005C42C = "/shr_mem/iop_prod_enbl_intf.shr"; // weak
char *off_1005FD30 = "/shr_mem/nav_intf.shr"; // weak
int (*off_100607F8[4])() = { &sub_10019160, &sub_10019140, &sub_10019150, &sub_10019140 }; // weak
char *off_10061730[62] =
{
  "ERR_NO_ERR: there was no err",
  "ERR_GENERIC: generic error",
  "ERR_ABNRML_PWRDN: abnormal powerdown",
  "ERR_AGAIN: function can do more work if called again.",
  "ERR_ACCES: access error",
  "ERR_ASSERT: UTL_assert()",
  "ERR_BADF: bad file descriptor",
  "ERR_BUSY: dev or system is busy",
  "ERR_DATA_ABORT: cpu data abort occured",
  "ERR_DEV_REM: device was removed (card not inserted)",
  "ERR_DONT_EXISTS: something doesnt exist",
  "ERR_EXIST: something already exists",
  "ERR_FAULT: illegal address",
  "ERR_FBIG: file to big",
  "ERR_INTEGRITY: crc, checksum, ... errors",
  "ERR_INVAL: invalid value",
  "ERR_IO: IO error",
  "ERR_IOP_CMND_PWRDN:",
  "ERR_ISDIR: it is a directory",
  "ERR_LOCK_FAILED: failed to lock (unable to reserve smphr)",
  "ERR_LOOP: possible infinite link loop",
  "ERR_NAMETOOLONG: supplied name is to long",
  "ERR_NFILE: no more file structures",
  "ERR_MFILE: no more file descriptors",
  "ERR_NOENT: no entry. file or path not found",
  "ERR_NOEXEC: file cant be executed or doesn't support mmap",
  "ERR_NOMEM: out of memory",
  "ERR_NOSPC: out of space(disk space)",
  "ERR_NOTBLK: not a blk device",
  "ERR_NOT_COMPLETE: something isn't complete (not complete rd,write)",
  "ERR_NOT_EMPTY: something isnt empty probably directory",
  "ERR_NOT_SUPPORTED: something isnt supported",
  "ERR_NOTDIR: not a directory",
  "ERR_NODEV: no such device",
  "ERR_PERM: no permission to perform operation",
  "ERR_PREFETCH_ABORT: cpu prefectch abort occured",
  "ERR_RTL_TRAP: run time library trap",
  "ERR_SPIPE: seek is not supported on file",
  "ERR_STK_OVFLOW: stack overflow",
  "ERR_TXTBSY: text file is busy. cant get or deny file write access",
  "ERR_UNDEF_INSTR: undefined instruction",
  "ERR_UNDEF_IRQ: undefined cpu irq",
  "ERR_UNDEF_SWI: undefined swi",
  "ERR_EXDEV: external device or different file system",
  "ERR_ASSERT_CONTINUE: UTL_assert_continue()",
  "ERR_HW_FAIL: Hardware Failure",
  "ERR_USING_DEFAULTS: stored value error using defaults",
  "ERR_OUT_OF_RANGE: value is out of range",
  "ERR_BADFUNC: bad function, function not supported",
  "ERR_BADPATH: path not found",
  "ERR_BAD_HNDL: bad handle(socket handle)",
  "ERR_SOCK_CLOSED: socket is closed",
  "ERR_SOCK_INVALID_ST: Socket in invalid state for op",
  "ERR_CONN_CLOSING: connection is closing",
  "ERR_CONN_RESET: connection was reset",
  "ERR_CONN_ABORT: connection was aborted",
  "ERR_CONN_NOT_ESTAB: connection is not established",
  "ERR_TIMEOUT: Normal timeout waiting for something",
  "ERR_WAIT_ABORT: Aborted wait for something",
  "ERR_BAD_FUNC_PARM: Bad function parameter",
  "ERR_IN_PROGRESS: In progress",
  "ERR_SRVR_DOWN: Server Down"
}; // weak
_UNKNOWN unk_10062508; // weak
int dword_1006250C[] = { 1312 }; // weak
__int16 word_100633A6[] = { 1 }; // weak
_UNKNOWN unk_10063402; // weak
char a006D0170[11] = "006-D0170-"; // weak
char *off_10065B18 = "006-D0170-"; // weak
int (__cdecl *(*off_10065B1C)[2])(int, int) = &off_100A1C20; // weak
char *off_10065BB0 = "/shr_mem/pvt_intf.shr"; // weak
_UNKNOWN unk_10068C28; // weak
_UNKNOWN unk_10068C90; // weak
_UNKNOWN unk_10068CF4; // weak
int (__cdecl *off_100692A8[3])(char) = { &sub_10016690, &sub_100165A0, &sub_100164F0 }; // weak
_UNKNOWN unk_1007E080; // weak
_UNKNOWN unk_1007E098; // weak
_UNKNOWN unk_1007E0E0; // weak
int dword_1007E0E4[] = { 6767 }; // weak
_UNKNOWN unk_1007E0F0; // weak
_UNKNOWN unk_1007E108; // weak
_UNKNOWN unk_1007E120; // weak
int dword_1007E124[] = { 6769 }; // weak
_UNKNOWN unk_1007E138; // weak
int dword_1007E13C[] = { 6093 }; // weak
__int16 word_1007E148[] = { 43 }; // weak
char byte_1007E14C[] = { '\x06' }; // weak
char byte_1007F238[] = { '7' }; // weak
int dword_1007F23C[] = { 6829 }; // weak
int dword_100800B0 = 64; // weak
__int16 word_100800B4[] = { 6782 }; // weak
__int16 word_100800B8[] = { 128 }; // weak
_UNKNOWN unk_100800D4; // weak
_DWORD dword_100800D8[10] = { 64, 24, 62, 18, 65, 27525120, 27394467, 27721729, 27591078, 0 }; // idb
__int16 word_100814E8[] = { 1565 }; // weak
__int16 word_100814EC[] = { 534 }; // weak
char byte_100814F0[] = { '\x04' }; // weak
__int16 word_100814F2[] = { 6512 }; // weak
int dword_10081508[] = { 118000 }; // weak
__int16 word_10082E9A[] = { 233 }; // weak
int dword_10082EA0[] = { 6201 }; // weak
__int16 word_10085A50[] = { 114 }; // weak
_UNKNOWN unk_10086288; // weak
int dword_1008628C[] = { 6006 }; // weak
char *off_10087158 = "/shr_mem/iop_gtx_intf.shr"; // weak
__int16 word_10087278[] = { 551 }; // weak
char byte_10087860[] = { '\x01' }; // weak
__int16 word_10087862[] = { 3020 }; // weak
char byte_10089128[] = { '\x01' }; // weak
__int16 word_10089130[] = { 3020 }; // weak
_UNKNOWN unk_1008A758; // weak
char *off_1008AB08 = "failure listener"; // weak
_WORD dword_1008AFF0[512] =
{
  25542,
  42339,
  31992,
  33916,
  30702,
  39287,
  31734,
  36219,
  62207,
  3570,
  27606,
  48491,
  28638,
  45423,
  50577,
  21701,
  12384,
  20528,
  258,
  769,
  26574,
  43367,
  11094,
  32043,
  65255,
  6654,
  55221,
  25303,
  43853,
  59051,
  30444,
  39542,
  51855,
  17866,
  33311,
  40322,
  51593,
  16585,
  32250,
  34685,
  64239,
  5626,
  22962,
  60249,
  18318,
  51527,
  61691,
  3056,
  44353,
  60589,
  54451,
  26580,
  41567,
  64930,
  44869,
  60079,
  39971,
  49052,
  42067,
  63396,
  29412,
  38514,
  49307,
  23488,
  46965,
  49847,
  64993,
  7421,
  37693,
  44691,
  9804,
  27174,
  13932,
  23094,
  16254,
  16703,
  63477,
  759,
  52355,
  20428,
  13416,
  23604,
  42321,
  62629,
  58833,
  13541,
  61945,
  2289,
  29154,
  37745,
  55467,
  29656,
  12642,
  21297,
  5418,
  16149,
  1032,
  3076,
  51093,
  21191,
  9030,
  25891,
  50077,
  24259,
  6192,
  10264,
  38455,
  41366,
  1290,
  3845,
  39471,
  46490,
  1806,
  2311,
  4644,
  13842,
  32795,
  39808,
  58079,
  15842,
  60365,
  9963,
  10062,
  26919,
  45695,
  52658,
  30186,
  40821,
  2322,
  6921,
  33565,
  40579,
  11352,
  29740,
  6708,
  11802,
  6966,
  11547,
  28380,
  45678,
  23220,
  61018,
  41051,
  64416,
  21156,
  63058,
  15222,
  19771,
  54967,
  25046,
  45949,
  52915,
  10578,
  31529,
  58333,
  16099,
  12126,
  28975,
  33811,
  38788,
  21414,
  62803,
  53689,
  26833,
  0,
  0,
  60865,
  11501,
  8256,
  24608,
  64739,
  8188,
  45433,
  51377,
  23478,
  60763,
  27348,
  48746,
  52109,
  18123,
  48743,
  55742,
  14706,
  19257,
  19092,
  56906,
  19608,
  54348,
  22704,
  59480,
  53125,
  19151,
  53435,
  27600,
  61381,
  10991,
  43599,
  58794,
  64493,
  5883,
  17286,
  50499,
  19866,
  55117,
  13158,
  21811,
  34065,
  38021,
  17802,
  53061,
  63977,
  4345,
  516,
  1538,
  32766,
  33151,
  20640,
  61520,
  15480,
  17468,
  40741,
  47775,
  43083,
  58280,
  20898,
  62289,
  41821,
  65187,
  16512,
  49216,
  36613,
  35471,
  37439,
  44434,
  40225,
  48285,
  14448,
  18488,
  62961,
  1269,
  48227,
  57276,
  46711,
  49590,
  55983,
  30170,
  8514,
  25377,
  4128,
  12304,
  65509,
  6911,
  62461,
  3827,
  53951,
  28114,
  52609,
  19661,
  3096,
  5132,
  4902,
  13587,
  60611,
  12268,
  24510,
  57695,
  38709,
  41623,
  17544,
  52292,
  5934,
  14615,
  50323,
  22468,
  42837,
  62119,
  32508,
  33406,
  15738,
  18237,
  25800,
  44132,
  23994,
  59229,
  6450,
  11033,
  29670,
  38259,
  24768,
  41056,
  33049,
  39041,
  20382,
  53583,
  56483,
  32732,
  8772,
  26146,
  10836,
  32298,
  36923,
  43920,
  34827,
  33672,
  18060,
  51782,
  61127,
  10734,
  47211,
  54200,
  5160,
  15380,
  56999,
  31198,
  24252,
  57950,
  2838,
  7435,
  56237,
  30427,
  57563,
  15328,
  12900,
  22066,
  14964,
  20026,
  2580,
  7690,
  18834,
  56137,
  1548,
  2566,
  9288,
  27684,
  23736,
  58460,
  49823,
  24002,
  54205,
  28371,
  44099,
  61356,
  25284,
  42594,
  37177,
  43153,
  38193,
  42133,
  58579,
  14308,
  31218,
  35705,
  59349,
  13031,
  51339,
  17352,
  14190,
  22839,
  28122,
  46957,
  36097,
  35981,
  54705,
  25813,
  20124,
  53838,
  43337,
  57513,
  27864,
  46188,
  22188,
  64086,
  62707,
  2036,
  60111,
  9706,
  26058,
  44901,
  31476,
  36474,
  44615,
  59822,
  2064,
  6152,
  47727,
  54714,
  30960,
  34936,
  9546,
  28453,
  11868,
  29230,
  7224,
  9244,
  42583,
  61862,
  46195,
  51124,
  50839,
  20934,
  59595,
  9192,
  56737,
  31965,
  29928,
  40052,
  7998,
  8479,
  19350,
  56651,
  48481,
  56509,
  35597,
  34443,
  35343,
  34186,
  28896,
  36976,
  15996,
  16958,
  46449,
  50357,
  26316,
  43622,
  18576,
  55368,
  774,
  1283,
  63223,
  502,
  3612,
  4622,
  25026,
  41825,
  13674,
  24373,
  22446,
  63831,
  47465,
  53433,
  34327,
  37254,
  49561,
  22721,
  7482,
  10013,
  40487,
  47518,
  57817,
  14561,
  63723,
  5112,
  38955,
  45976,
  4386,
  13073,
  27090,
  47977,
  55721,
  28889,
  36359,
  35214,
  37939,
  42900,
  39725,
  46747,
  7740,
  8734,
  34581,
  37511,
  59849,
  8425,
  52871,
  18894,
  21930,
  65365,
  10320,
  30760,
  57253,
  31455,
  35843,
  36748,
  41305,
  63649,
  35081,
  32905,
  3354,
  5901,
  48997,
  55999,
  59095,
  12774,
  17028,
  50754,
  26832,
  47208,
  16770,
  49985,
  39209,
  45209,
  11610,
  30509,
  3870,
  4367,
  45179,
  52144,
  21672,
  64596,
  47981,
  54971,
  5676,
  14870
}; // idb
_WORD dword_1008B3F0[512] =
{
  50853,
  25443,
  63620,
  31868,
  61081,
  30583,
  63117,
  31611,
  65293,
  62194,
  54973,
  27499,
  57009,
  28527,
  37204,
  50629,
  24656,
  12336,
  515,
  257,
  52905,
  26471,
  22141,
  11051,
  59161,
  65278,
  46434,
  55255,
  19942,
  43947,
  60570,
  30326,
  36677,
  51914,
  8093,
  33410,
  35136,
  51657,
  64135,
  32125,
  61205,
  64250,
  45803,
  22873,
  36553,
  18247,
  64267,
  61680,
  16876,
  44461,
  45927,
  54484,
  24573,
  41634,
  17898,
  44975,
  9151,
  40092,
  21495,
  42148,
  58518,
  29298,
  39771,
  49344,
  30146,
  47031,
  57628,
  65021,
  15790,
  37779,
  19562,
  9766,
  27738,
  13878,
  32321,
  16191,
  62722,
  63479,
  33615,
  52428,
  26716,
  13364,
  20980,
  42405,
  53556,
  58853,
  63752,
  61937,
  58003,
  29041,
  43891,
  55512,
  25171,
  12593,
  10815,
  5397,
  2060,
  1028,
  38226,
  51143,
  18021,
  8995,
  40286,
  50115,
  12328,
  6168,
  14241,
  38550,
  2575,
  1285,
  12213,
  39578,
  3593,
  1799,
  9270,
  4626,
  7067,
  32896,
  57149,
  58082,
  52518,
  60395,
  20073,
  10023,
  32717,
  45746,
  60063,
  30069,
  4635,
  2313,
  7582,
  33667,
  22644,
  11308,
  13358,
  6682,
  13869,
  6939,
  56498,
  28270,
  46318,
  23130,
  23547,
  41120,
  42230,
  21074,
  30285,
  15163,
  46945,
  54998,
  32206,
  46003,
  21115,
  10537,
  56638,
  58339,
  24177,
  12079,
  5015,
  33924,
  42741,
  21331,
  47464,
  53713,
  0,
  0,
  49452,
  60909,
  16480,
  8224,
  58143,
  64764,
  31176,
  45489,
  46829,
  23387,
  54462,
  27242,
  36166,
  52171,
  26585,
  48830,
  29259,
  14649,
  38110,
  19018,
  39124,
  19532,
  45288,
  22616,
  34122,
  53199,
  47979,
  53456,
  50474,
  61423,
  20453,
  43690,
  60694,
  64507,
  34501,
  17219,
  39639,
  19789,
  26197,
  13107,
  4500,
  34181,
  35535,
  17733,
  59664,
  63993,
  1030,
  514,
  65153,
  32639,
  41200,
  20560,
  30788,
  15420,
  9658,
  40863,
  19427,
  43176,
  41715,
  20817,
  24062,
  41891,
  32960,
  16448,
  1418,
  36751,
  16301,
  37522,
  8636,
  40349,
  28744,
  14392,
  61700,
  62965,
  25567,
  48316,
  30657,
  46774,
  44917,
  56026,
  16995,
  8481,
  8240,
  4112,
  58650,
  65535,
  64782,
  62451,
  49005,
  53970,
  33100,
  52685,
  6164,
  3084,
  9781,
  4883,
  49967,
  60652,
  48865,
  24415,
  13730,
  38807,
  35020,
  17476,
  11833,
  5911,
  37719,
  50372,
  22002,
  42919,
  64642,
  32382,
  31303,
  15677,
  51372,
  25700,
  47847,
  23901,
  12843,
  6425,
  59029,
  29555,
  49312,
  24672,
  6552,
  33153,
  40657,
  20303,
  41855,
  56540,
  17510,
  8738,
  21630,
  10794,
  15275,
  37008,
  2947,
  34952,
  36042,
  17990,
  50985,
  61166,
  27603,
  47288,
  10300,
  5140,
  42873,
  57054,
  48354,
  24158,
  5661,
  2827,
  44406,
  56283,
  56123,
  57568,
  25686,
  12850,
  29774,
  14906,
  5150,
  2570,
  37595,
  18761,
  3082,
  1542,
  18540,
  9252,
  47332,
  23644,
  40797,
  49858,
  48494,
  54227,
  17391,
  44204,
  50342,
  25186,
  14760,
  37265,
  12708,
  38293,
  54071,
  58596,
  62091,
  31097,
  54578,
  59367,
  35651,
  51400,
  28249,
  14135,
  55991,
  28013,
  396,
  36237,
  45412,
  54741,
  40146,
  20046,
  18912,
  43433,
  55476,
  27756,
  44282,
  22102,
  62215,
  62708,
  53029,
  60138,
  51887,
  25957,
  62606,
  31354,
  18409,
  44718,
  4120,
  2056,
  28629,
  47802,
  61576,
  30840,
  19055,
  9509,
  23666,
  11822,
  14372,
  7196,
  22513,
  42662,
  29639,
  46260,
  38737,
  50886,
  52003,
  59624,
  41340,
  56797,
  59548,
  29812,
  15905,
  7967,
  38621,
  19275,
  25052,
  48573,
  3462,
  35723,
  3973,
  35466,
  57488,
  28784,
  31810,
  15934,
  29124,
  46517,
  52394,
  26214,
  37080,
  18504,
  1541,
  771,
  63233,
  63222,
  7186,
  3598,
  49827,
  24929,
  27231,
  13621,
  44793,
  22359,
  27088,
  47545,
  6033,
  34438,
  39256,
  49601,
  14887,
  7453,
  10169,
  40606,
  55608,
  57825,
  60179,
  63736,
  11187,
  39064,
  8755,
  4369,
  53947,
  26985,
  43376,
  55769,
  1929,
  36494,
  13223,
  38036,
  11702,
  39835,
  15394,
  7710,
  5522,
  34695,
  51488,
  59881,
  34633,
  52942,
  43775,
  21845,
  20600,
  10280,
  42362,
  57311,
  911,
  35980,
  23032,
  41377,
  2432,
  35209,
  6679,
  3341,
  26074,
  49087,
  55089,
  59110,
  33990,
  16962,
  53432,
  26728,
  33475,
  16705,
  10672,
  39321,
  23159,
  11565,
  7697,
  3855,
  31691,
  45232,
  43260,
  21588,
  28118,
  48059,
  11322,
  5654
}; // idb
_WORD dword_1008B7F0[512] =
{
  42339,
  25542,
  33916,
  31992,
  39287,
  30702,
  36219,
  31734,
  3570,
  62207,
  48491,
  27606,
  45423,
  28638,
  21701,
  50577,
  20528,
  12384,
  769,
  258,
  43367,
  26574,
  32043,
  11094,
  6654,
  65255,
  25303,
  55221,
  59051,
  43853,
  39542,
  30444,
  17866,
  51855,
  40322,
  33311,
  16585,
  51593,
  34685,
  32250,
  5626,
  64239,
  60249,
  22962,
  51527,
  18318,
  3056,
  61691,
  60589,
  44353,
  26580,
  54451,
  64930,
  41567,
  60079,
  44869,
  49052,
  39971,
  63396,
  42067,
  38514,
  29412,
  23488,
  49307,
  49847,
  46965,
  7421,
  64993,
  44691,
  37693,
  27174,
  9804,
  23094,
  13932,
  16703,
  16254,
  759,
  63477,
  20428,
  52355,
  23604,
  13416,
  62629,
  42321,
  13541,
  58833,
  2289,
  61945,
  37745,
  29154,
  29656,
  55467,
  21297,
  12642,
  16149,
  5418,
  3076,
  1032,
  21191,
  51093,
  25891,
  9030,
  24259,
  50077,
  10264,
  6192,
  41366,
  38455,
  3845,
  1290,
  46490,
  39471,
  2311,
  1806,
  13842,
  4644,
  39808,
  32795,
  15842,
  58079,
  9963,
  60365,
  26919,
  10062,
  52658,
  45695,
  40821,
  30186,
  6921,
  2322,
  40579,
  33565,
  29740,
  11352,
  11802,
  6708,
  11547,
  6966,
  45678,
  28380,
  61018,
  23220,
  64416,
  41051,
  63058,
  21156,
  19771,
  15222,
  25046,
  54967,
  52915,
  45949,
  31529,
  10578,
  16099,
  58333,
  28975,
  12126,
  38788,
  33811,
  62803,
  21414,
  26833,
  53689,
  0,
  0,
  11501,
  60865,
  24608,
  8256,
  8188,
  64739,
  51377,
  45433,
  60763,
  23478,
  48746,
  27348,
  18123,
  52109,
  55742,
  48743,
  19257,
  14706,
  56906,
  19092,
  54348,
  19608,
  59480,
  22704,
  19151,
  53125,
  27600,
  53435,
  10991,
  61381,
  58794,
  43599,
  5883,
  64493,
  50499,
  17286,
  55117,
  19866,
  21811,
  13158,
  38021,
  34065,
  53061,
  17802,
  4345,
  63977,
  1538,
  516,
  33151,
  32766,
  61520,
  20640,
  17468,
  15480,
  47775,
  40741,
  58280,
  43083,
  62289,
  20898,
  65187,
  41821,
  49216,
  16512,
  35471,
  36613,
  44434,
  37439,
  48285,
  40225,
  18488,
  14448,
  1269,
  62961,
  57276,
  48227,
  49590,
  46711,
  30170,
  55983,
  25377,
  8514,
  12304,
  4128,
  6911,
  65509,
  3827,
  62461,
  28114,
  53951,
  19661,
  52609,
  5132,
  3096,
  13587,
  4902,
  12268,
  60611,
  57695,
  24510,
  41623,
  38709,
  52292,
  17544,
  14615,
  5934,
  22468,
  50323,
  62119,
  42837,
  33406,
  32508,
  18237,
  15738,
  44132,
  25800,
  59229,
  23994,
  11033,
  6450,
  38259,
  29670,
  41056,
  24768,
  39041,
  33049,
  53583,
  20382,
  32732,
  56483,
  26146,
  8772,
  32298,
  10836,
  43920,
  36923,
  33672,
  34827,
  51782,
  18060,
  10734,
  61127,
  54200,
  47211,
  15380,
  5160,
  31198,
  56999,
  57950,
  24252,
  7435,
  2838,
  30427,
  56237,
  15328,
  57563,
  22066,
  12900,
  20026,
  14964,
  7690,
  2580,
  56137,
  18834,
  2566,
  1548,
  27684,
  9288,
  58460,
  23736,
  24002,
  49823,
  28371,
  54205,
  61356,
  44099,
  42594,
  25284,
  43153,
  37177,
  42133,
  38193,
  14308,
  58579,
  35705,
  31218,
  13031,
  59349,
  17352,
  51339,
  22839,
  14190,
  46957,
  28122,
  35981,
  36097,
  25813,
  54705,
  53838,
  20124,
  57513,
  43337,
  46188,
  27864,
  64086,
  22188,
  2036,
  62707,
  9706,
  60111,
  44901,
  26058,
  36474,
  31476,
  59822,
  44615,
  6152,
  2064,
  54714,
  47727,
  34936,
  30960,
  28453,
  9546,
  29230,
  11868,
  9244,
  7224,
  61862,
  42583,
  51124,
  46195,
  20934,
  50839,
  9192,
  59595,
  31965,
  56737,
  40052,
  29928,
  8479,
  7998,
  56651,
  19350,
  56509,
  48481,
  34443,
  35597,
  34186,
  35343,
  36976,
  28896,
  16958,
  15996,
  50357,
  46449,
  43622,
  26316,
  55368,
  18576,
  1283,
  774,
  502,
  63223,
  4622,
  3612,
  41825,
  25026,
  24373,
  13674,
  63831,
  22446,
  53433,
  47465,
  37254,
  34327,
  22721,
  49561,
  10013,
  7482,
  47518,
  40487,
  14561,
  57817,
  5112,
  63723,
  45976,
  38955,
  13073,
  4386,
  47977,
  27090,
  28889,
  55721,
  35214,
  36359,
  42900,
  37939,
  46747,
  39725,
  8734,
  7740,
  37511,
  34581,
  8425,
  59849,
  18894,
  52871,
  65365,
  21930,
  30760,
  10320,
  31455,
  57253,
  36748,
  35843,
  63649,
  41305,
  32905,
  35081,
  5901,
  3354,
  55999,
  48997,
  12774,
  59095,
  50754,
  17028,
  47208,
  26832,
  49985,
  16770,
  45209,
  39209,
  30509,
  11610,
  4367,
  3870,
  52144,
  45179,
  64596,
  21672,
  54971,
  47981,
  14870,
  5676
}; // idb
_WORD dword_1008BBF0[512] =
{
  25443,
  50853,
  31868,
  63620,
  30583,
  61081,
  31611,
  63117,
  62194,
  65293,
  27499,
  54973,
  28527,
  57009,
  50629,
  37204,
  12336,
  24656,
  257,
  515,
  26471,
  52905,
  11051,
  22141,
  65278,
  59161,
  55255,
  46434,
  43947,
  19942,
  30326,
  60570,
  51914,
  36677,
  33410,
  8093,
  51657,
  35136,
  32125,
  64135,
  64250,
  61205,
  22873,
  45803,
  18247,
  36553,
  61680,
  64267,
  44461,
  16876,
  54484,
  45927,
  41634,
  24573,
  44975,
  17898,
  40092,
  9151,
  42148,
  21495,
  29298,
  58518,
  49344,
  39771,
  47031,
  30146,
  65021,
  57628,
  37779,
  15790,
  9766,
  19562,
  13878,
  27738,
  16191,
  32321,
  63479,
  62722,
  52428,
  33615,
  13364,
  26716,
  42405,
  20980,
  58853,
  53556,
  61937,
  63752,
  29041,
  58003,
  55512,
  43891,
  12593,
  25171,
  5397,
  10815,
  1028,
  2060,
  51143,
  38226,
  8995,
  18021,
  50115,
  40286,
  6168,
  12328,
  38550,
  14241,
  1285,
  2575,
  39578,
  12213,
  1799,
  3593,
  4626,
  9270,
  32896,
  7067,
  58082,
  57149,
  60395,
  52518,
  10023,
  20073,
  45746,
  32717,
  30069,
  60063,
  2313,
  4635,
  33667,
  7582,
  11308,
  22644,
  6682,
  13358,
  6939,
  13869,
  28270,
  56498,
  23130,
  46318,
  41120,
  23547,
  21074,
  42230,
  15163,
  30285,
  54998,
  46945,
  46003,
  32206,
  10537,
  21115,
  58339,
  56638,
  12079,
  24177,
  33924,
  5015,
  21331,
  42741,
  53713,
  47464,
  0,
  0,
  60909,
  49452,
  8224,
  16480,
  64764,
  58143,
  45489,
  31176,
  23387,
  46829,
  27242,
  54462,
  52171,
  36166,
  48830,
  26585,
  14649,
  29259,
  19018,
  38110,
  19532,
  39124,
  22616,
  45288,
  53199,
  34122,
  53456,
  47979,
  61423,
  50474,
  43690,
  20453,
  64507,
  60694,
  17219,
  34501,
  19789,
  39639,
  13107,
  26197,
  34181,
  4500,
  17733,
  35535,
  63993,
  59664,
  514,
  1030,
  32639,
  65153,
  20560,
  41200,
  15420,
  30788,
  40863,
  9658,
  43176,
  19427,
  20817,
  41715,
  41891,
  24062,
  16448,
  32960,
  36751,
  1418,
  37522,
  16301,
  40349,
  8636,
  14392,
  28744,
  62965,
  61700,
  48316,
  25567,
  46774,
  30657,
  56026,
  44917,
  8481,
  16995,
  4112,
  8240,
  65535,
  58650,
  62451,
  64782,
  53970,
  49005,
  52685,
  33100,
  3084,
  6164,
  4883,
  9781,
  60652,
  49967,
  24415,
  48865,
  38807,
  13730,
  17476,
  35020,
  5911,
  11833,
  50372,
  37719,
  42919,
  22002,
  32382,
  64642,
  15677,
  31303,
  25700,
  51372,
  23901,
  47847,
  6425,
  12843,
  29555,
  59029,
  24672,
  49312,
  33153,
  6552,
  20303,
  40657,
  56540,
  41855,
  8738,
  17510,
  10794,
  21630,
  37008,
  15275,
  34952,
  2947,
  17990,
  36042,
  61166,
  50985,
  47288,
  27603,
  5140,
  10300,
  57054,
  42873,
  24158,
  48354,
  2827,
  5661,
  56283,
  44406,
  57568,
  56123,
  12850,
  25686,
  14906,
  29774,
  2570,
  5150,
  18761,
  37595,
  1542,
  3082,
  9252,
  18540,
  23644,
  47332,
  49858,
  40797,
  54227,
  48494,
  44204,
  17391,
  25186,
  50342,
  37265,
  14760,
  38293,
  12708,
  58596,
  54071,
  31097,
  62091,
  59367,
  54578,
  51400,
  35651,
  14135,
  28249,
  28013,
  55991,
  36237,
  396,
  54741,
  45412,
  20046,
  40146,
  43433,
  18912,
  27756,
  55476,
  22102,
  44282,
  62708,
  62215,
  60138,
  53029,
  25957,
  51887,
  31354,
  62606,
  44718,
  18409,
  2056,
  4120,
  47802,
  28629,
  30840,
  61576,
  9509,
  19055,
  11822,
  23666,
  7196,
  14372,
  42662,
  22513,
  46260,
  29639,
  50886,
  38737,
  59624,
  52003,
  56797,
  41340,
  29812,
  59548,
  7967,
  15905,
  19275,
  38621,
  48573,
  25052,
  35723,
  3462,
  35466,
  3973,
  28784,
  57488,
  15934,
  31810,
  46517,
  29124,
  26214,
  52394,
  18504,
  37080,
  771,
  1541,
  63222,
  63233,
  3598,
  7186,
  24929,
  49827,
  13621,
  27231,
  22359,
  44793,
  47545,
  27088,
  34438,
  6033,
  49601,
  39256,
  7453,
  14887,
  40606,
  10169,
  57825,
  55608,
  63736,
  60179,
  39064,
  11187,
  4369,
  8755,
  26985,
  53947,
  55769,
  43376,
  36494,
  1929,
  38036,
  13223,
  39835,
  11702,
  7710,
  15394,
  34695,
  5522,
  59881,
  51488,
  52942,
  34633,
  21845,
  43775,
  10280,
  20600,
  57311,
  42362,
  35980,
  911,
  41377,
  23032,
  35209,
  2432,
  3341,
  6679,
  49087,
  26074,
  59110,
  55089,
  16962,
  33990,
  26728,
  53432,
  16705,
  33475,
  39321,
  10672,
  11565,
  23159,
  3855,
  7697,
  45232,
  31691,
  21588,
  43260,
  48059,
  28118,
  5654,
  11322
}; // idb
int dword_1008BFF0[] = { 99 }; // weak
int dword_1008C3F0[] = { 25344 }; // weak
int dword_1008C7F0[] = { 6488064 }; // weak
int dword_1008CBF0[] = { 1660944384 }; // weak
int dword_1008D018[] = { 128 }; // weak
int dword_1008D028[] = { 0 }; // weak
int dword_1008D038[] = { 0 }; // weak
char byte_1008D0A9[] = { '\0' }; // weak
char byte_1008D0AA[] = { '\0' }; // weak
char byte_1008D0AB[] = { '\0' }; // weak
char byte_1008D0AC[] = { '\x10' }; // weak
int dword_1008D0C0[] = { 0 }; // weak
_UNKNOWN unk_1008D138; // weak
_UNKNOWN unk_1008D5B8; // weak
char byte_1008D630[] = { '\0' }; // weak
char byte_1008D730[] = { '\0' }; // weak
char byte_1008D830[] = { '\0' }; // weak
int dword_1008D930[] = { 0 }; // weak
int dword_1008D9A8[] = { 0 }; // weak
__int16 word_1008DA20[] = { 0 }; // weak
__int16 word_1008DA22[] = { 0 }; // weak
__int16 word_1008DA24[] = { 0 }; // weak
__int16 word_1008DA26[] = { 0 }; // weak
int (__cdecl *off_1008DA28)(int, int) = &sub_1002A5F0; // weak
void *off_1008DBD4 = &unk_1008D138; // weak
void *off_1008DBE8 = &unk_1008D5B8; // weak
_UNKNOWN unk_1008DBFC; // weak
int dword_1008DC10[] = { 0 }; // weak
int dword_1008DC58[] = { 16 }; // weak
_UNKNOWN unk_1008DCA8; // weak
_UNKNOWN unk_1008DD28; // weak
_UNKNOWN unk_1008DDA8; // weak
_UNKNOWN unk_1008DE20; // weak
_UNKNOWN unk_1008DE98; // weak
_UNKNOWN unk_1008EE98; // weak
_UNKNOWN unk_1008F7A0; // weak
_UNKNOWN unk_1008F7A4; // weak
_UNKNOWN unk_1008F7A8; // weak
_UNKNOWN unk_1008F7AC; // weak
_UNKNOWN unk_1008F7B0; // weak
_UNKNOWN unk_1008F7B4; // weak
_UNKNOWN unk_1008FE68; // weak
void *off_1008FE6C = &unk_1008F7A0; // weak
_UNKNOWN unk_1008FF18; // weak
void *off_1008FF1C = &unk_1008F7A0; // weak
void *off_1008FF28 = &unk_1008F7A4; // weak
void *off_1008FF34 = &unk_1008F7A8; // weak
void *off_1008FF40 = &unk_1008F7AC; // weak
void *off_1008FF4C = &unk_1008F7B0; // weak
void *off_100903D8 = &unk_1008F810; // weak
void *off_100903E4 = &unk_1008F7DC; // weak
void *off_100903F0 = &unk_1008F85C; // weak
void *off_100903FC = &unk_1008F890; // weak
void *off_10090408 = &unk_1008F960; // weak
void *off_10090414 = &unk_1008F94C; // weak
void *off_10090420 = &unk_1008FA3C; // weak
void *off_1009042C = &unk_1008FA60; // weak
void *off_10090438 = &unk_1008FA84; // weak
void *off_10090444 = &unk_1008FAA8; // weak
void *off_10090450 = &unk_1008F7B0; // weak
void *off_10090468 = &unk_1008F7A0; // weak
void *off_10090474 = &unk_1008F7A4; // weak
void *off_10090480 = &unk_1008FDB4; // weak
void *off_1009048C = &unk_1008F7AC; // weak
void *off_10090498 = &unk_1008F7B0; // weak
void *off_100904A4 = &unk_1008F7B4; // weak
void *off_100904B0 = &unk_1008F7A0; // weak
void *off_100904BC = &unk_1008FDC0; // weak
void *off_100904C8 = &unk_1008F7A8; // weak
void *off_100904D4 = &unk_1008F7AC; // weak
void *off_100904E0 = &unk_1008F7B0; // weak
void *off_100904EC = &unk_1008F7B4; // weak
_UNKNOWN unk_100904F8; // weak
void *off_100904FC = &unk_1008F7A4; // weak
void *off_10090508 = &unk_1008FA2C; // weak
_UNKNOWN unk_100907BC; // weak
_UNKNOWN unk_100907C0; // weak
_UNKNOWN unk_100907C4; // weak
_UNKNOWN unk_100907CC; // weak
_UNKNOWN unk_100907D0; // weak
_UNKNOWN unk_10090878; // weak
_UNKNOWN unk_10090888; // weak
_UNKNOWN unk_1009097C; // weak
_UNKNOWN unk_10090A08; // weak
_UNKNOWN unk_10090A0C; // weak
_UNKNOWN unk_10090A10; // weak
_UNKNOWN unk_10090A64; // weak
_UNKNOWN unk_10090A88; // weak
void *off_10094C6C = &unk_10094578; // weak
void *off_10094C74 = &unk_1009457C; // weak
void *off_10094C7C = &unk_10094580; // weak
void *off_10094C84 = &unk_10094584; // weak
void *off_10094C8C = &unk_10094588; // weak
void *off_10095530 = &unk_10094578; // weak
void *off_10095538 = &unk_1009457C; // weak
void *off_10095540 = &unk_10094580; // weak
void *off_10095548 = &unk_10094584; // weak
void *off_10095550 = &unk_10094588; // weak
void *off_100956C0 = &unk_10094578; // weak
void *off_100956C8 = &unk_1009457C; // weak
void *off_100956D0 = &unk_10094580; // weak
void *off_100956D8 = &unk_10094584; // weak
void *off_100956E0 = &unk_10094588; // weak
void *off_10095760 = &unk_10094578; // weak
void *off_10095768 = &unk_1009457C; // weak
void *off_10095770 = &unk_10094580; // weak
void *off_10095778 = &unk_10094584; // weak
void *off_10095780 = &unk_10094588; // weak
void *off_1009591C = &unk_10094578; // weak
void *off_10095924 = &unk_1009457C; // weak
void *off_1009592C = &unk_10094580; // weak
void *off_10095934 = &unk_10094584; // weak
void *off_1009593C = &unk_10094588; // weak
void *off_10095A78 = &unk_10094578; // weak
void *off_10095A80 = &unk_1009457C; // weak
void *off_10095A88 = &unk_10094580; // weak
void *off_10095A90 = &unk_10094584; // weak
void *off_10095A98 = &unk_10094588; // weak
void *off_10095AF0 = &unk_10094578; // weak
void *off_10095AF8 = &unk_1009457C; // weak
void *off_10095B00 = &unk_10091358; // weak
void *off_10095B08 = &unk_10094584; // weak
void *off_10095B10 = &unk_10094588; // weak
void *off_10095B18 = &unk_10093C30; // weak
void *off_10095B20 = &unk_1009457C; // weak
void *off_10095B28 = &unk_10093C40; // weak
void *off_10095B30 = &unk_10094584; // weak
void *off_10095B38 = &unk_10094588; // weak
void *off_10095B40 = &unk_100937E0; // weak
void *off_10095B48 = &unk_10093900; // weak
void *off_10095B50 = &unk_100939F8; // weak
void *off_10095B58 = &unk_10093A78; // weak
void *off_10095B60 = &unk_10093B9C; // weak
void *off_10095B6C = &unk_10094578; // weak
void *off_10095B74 = &unk_1009457C; // weak
void *off_10095B7C = &unk_10094580; // weak
void *off_10095B84 = &unk_10094584; // weak
void *off_10095B8C = &unk_10094588; // weak
void *off_100963DC = &unk_10094578; // weak
void *off_100963E4 = &unk_1009457C; // weak
void *off_100963EC = &unk_10094580; // weak
void *off_100963F4 = &unk_10094584; // weak
void *off_100963FC = &unk_10094588; // weak
void *off_100968FC = &unk_10094578; // weak
void *off_10096904 = &unk_100948F4; // weak
void *off_1009690C = &unk_10094580; // weak
void *off_10096914 = &unk_10094584; // weak
void *off_1009691C = &unk_10094588; // weak
void *off_10096924 = &unk_10094944; // weak
void *off_1009692C = &unk_10094954; // weak
void *off_10096934 = &unk_1009498C; // weak
void *off_1009693C = &unk_10094584; // weak
void *off_10096944 = &unk_10094588; // weak
void *off_1009694C = &unk_10094578; // weak
void *off_10096974 = &unk_10094578; // weak
char byte_10096A20[] = { '\x01' }; // weak
__int16 word_10096A22[] = { 3020 }; // weak
_UNKNOWN unk_10097180; // weak
_UNKNOWN unk_10097184; // weak
_UNKNOWN unk_10097188; // weak
_UNKNOWN unk_10097210; // weak
_UNKNOWN unk_10097284; // weak
void *off_10097364 = &unk_100972BC; // weak
void *off_1009736C = &unk_100972C0; // weak
void *off_10097374 = &unk_10097328; // weak
void *off_1009737C = &unk_1009732C; // weak
void *off_10097384 = &unk_1009735C; // weak
int dword_1009738C[] = { 67108864 }; // weak
void *off_10099798 = &unk_10099784; // weak
void *off_100997A4 = &unk_10098848; // weak
void *off_100997B0 = &unk_100988C8; // weak
void *off_100997BC = &unk_10098928; // weak
void *off_100997C8 = &unk_10098834; // weak
void *off_100997D4 = &unk_10099784; // weak
void *off_10099814 = &unk_10099784; // weak
void *off_10099820 = &unk_10099788; // weak
void *off_1009982C = &unk_1009978C; // weak
void *off_10099838 = &unk_10099790; // weak
void *off_10099844 = &unk_10099794; // weak
void *off_1009A0D4 = &unk_10099784; // weak
void *off_1009A0E0 = &unk_10099788; // weak
void *off_1009A0EC = &unk_1009978C; // weak
void *off_1009A0F8 = &unk_10099790; // weak
void *off_1009A104 = &unk_10099794; // weak
_UNKNOWN unk_1009A9F8; // weak
_UNKNOWN unk_1009A9FC; // weak
_UNKNOWN unk_1009AA00; // weak
_UNKNOWN unk_1009AA04; // weak
_UNKNOWN unk_1009AA08; // weak
_UNKNOWN unk_1009AA0C; // weak
_UNKNOWN unk_1009AA10; // weak
_UNKNOWN unk_1009AA3C; // weak
_UNKNOWN unk_1009AA60; // weak
_UNKNOWN unk_1009AA90; // weak
_UNKNOWN unk_1009AB08; // weak
_UNKNOWN unk_1009AC00; // weak
_UNKNOWN unk_1009AC0C; // weak
_UNKNOWN unk_1009AC20; // weak
void *off_1009AC30 = &unk_1009AA84; // weak
void *off_1009AC40 = &unk_1009AB70; // weak
void *off_1009AC50 = &unk_1009ABA0; // weak
void *off_1009AC60 = &unk_1009ABD0; // weak
void *off_1009AC70 = &unk_1009AA08; // weak
void *off_1009AC80 = &unk_1009AA0C; // weak
_UNKNOWN unk_1009AC90; // weak
_UNKNOWN unk_1009AC94; // weak
_UNKNOWN unk_1009ACC8; // weak
_UNKNOWN unk_1009ACF8; // weak
_UNKNOWN unk_1009AD38; // weak
_UNKNOWN unk_1009AD60; // weak
_UNKNOWN unk_1009AD64; // weak
_UNKNOWN unk_1009AD80; // weak
_UNKNOWN unk_1009ADC4; // weak
_UNKNOWN unk_1009ADD8; // weak
int (__cdecl *off_100A1C20[2])(int, int) = { &sub_1002E750, &sub_1002E7B0 }; // weak
_UNKNOWN unk_100A4838; // weak
char byte_100A4839[] = { '\0' }; // weak
char byte_100A6671[] = { '\x1E' }; // weak
_UNKNOWN unk_100A73E0; // weak
int dword_100A73E4[] = { 0 }; // weak
_UNKNOWN unk_100A73F8; // weak
int dword_100A73FC[] = { 0 }; // weak
_UNKNOWN unk_100A7420; // weak
int dword_100A7424[] = { 0 }; // weak
_UNKNOWN unk_100A7450; // weak
int dword_100A7454[] = { 0 }; // weak
char byte_100AA6FA[] = { '\x04' }; // weak
char byte_100AA6FF[] = { '\a' }; // weak
_UNKNOWN unk_100AE080; // weak
int dword_100AE084[] = { 3535 }; // weak
_UNKNOWN unk_100AE0B8; // weak
int dword_100AE0BC[] = { 6813 }; // weak
_UNKNOWN unk_100AE0F0; // weak
int dword_100AE0F4[] = { 9036 }; // weak
_UNKNOWN unk_100AE128; // weak
int dword_100AE12C[] = { 6763 }; // weak
_UNKNOWN unk_100AF1E0; // weak
int dword_100AFD28[] = { 6103 }; // weak
int dword_100AFD2C[] = { 8000 }; // weak
_UNKNOWN unk_100B0250; // weak
char *off_100B02D0[9] =
{
  "KRNL",
  "LVL_B",
  "LVL_D",
  "PROF",
  "UDB_RTE",
  "UDB_WPT",
  "SYS_CNFG",
  "ERR_RPRT",
  "BKUP_SYS_CNFG"
}; // weak
int dword_100B0DB0[] = { 0 }; // weak
_UNKNOWN unk_100BF3E0; // weak
_UNKNOWN unk_100BF3E8; // weak
int __security_cookie = 3141592654; // weak
_UNKNOWN unk_100C1968; // weak
void *off_100C1DE0 = &unk_1020D840; // weak
_UNKNOWN unk_100C1DF0; // weak
_UNKNOWN unk_100C1E50; // weak
int dword_100C2060 = 2; // weak
int dword_100C2118 = 1024; // weak
int dword_100C211C = 4294966273; // weak
int dword_100C2120 = 53; // weak
int dword_100C2124 = 11; // weak
int dword_100C2128 = 64; // weak
int dword_100C212C = 1023; // weak
int dword_100C2130 = 128; // weak
int dword_100C2134 = 4294967169; // weak
int dword_100C2138 = 24; // weak
int dword_100C213C = 8; // weak
int dword_100C2140 = 32; // weak
int dword_100C2144 = 127; // weak
char byte_100C2780 = '\0'; // weak
char byte_100C2781 = '\0'; // weak
char byte_100C2782 = '\0'; // weak
char byte_100C2783 = '\0'; // weak
int dword_100C2784 = 0; // weak
char byte_100C2788 = '\0'; // weak
char byte_100C2789[] = { '\0' }; // weak
char byte_100C27C9 = '\0'; // weak
char byte_100C27CA = '\0'; // weak
int dword_100C27CC = 0; // weak
__int16 word_100C27D0[] = { 0 }; // weak
__int16 word_100C27D2[] = { 0 }; // weak
__int16 word_100C27D4[] = { 0 }; // weak
__int16 word_100C27D6[] = { 0 }; // weak
__int16 word_100C27D8[] = { 0 }; // weak
__int16 word_100C27DA[] = { 0 }; // weak
__int16 word_100C27DC[] = { 0 }; // weak
__int16 word_100C27DE[] = { 0 }; // weak
int dword_100C27E0[] = { 0 }; // weak
_UNKNOWN unk_100C27E8; // weak
int dword_100C27F4[] = { 0 }; // weak
int dword_100C27F8[] = { 0 }; // weak
int dword_100C27FC[] = { 0 }; // weak
int dword_100C2800[] = { 0 }; // weak
int dword_100C2804[] = { 0 }; // weak
int dword_100C2810[] = { 0 }; // weak
int dword_100C2814[] = { 0 }; // weak
char byte_100C281C[] = { '\0' }; // weak
int dword_100C2820[] = { 0 }; // weak
char byte_100C2824[] = { '\0' }; // weak
int dword_100C2828[] = { 0 }; // weak
int dword_100C282C[] = { 0 }; // weak
int dword_100C2830[] = { 0 }; // weak
int dword_100C2834[] = { 0 }; // weak
int dword_100C47D0; // weak
_UNKNOWN unk_100C47D4; // weak
_UNKNOWN unk_100C47E8; // weak
int dword_100C67D4[]; // weak
int dword_100C67D8[]; // weak
int dword_100C67DC[]; // weak
int dword_100C67E0[]; // weak
int dword_100C6DD4[]; // weak
int dword_100C6DD8[]; // weak
int dword_100C6DDC[]; // weak
int dword_100C6DE0[]; // weak
_UNKNOWN unk_100C6DE8; // weak
int dword_100C73D4; // weak
int dword_100C73D8; // weak
int dword_100C73DC; // weak
__int16 word_100C73E0; // weak
__int16 word_100C73E2[]; // weak
char byte_100C7462[]; // weak
char byte_100C74A4; // weak
char byte_100C74A5; // weak
char byte_100C74A6; // weak
char byte_100C74A7; // weak
_UNKNOWN unk_100C74A8; // weak
__int16 word_100C750C; // weak
char byte_100C750E; // weak
char byte_100C750F; // weak
char byte_100C7510; // weak
__int16 word_100C7574; // weak
char byte_100C7576; // weak
int dword_100C7578[]; // weak
int dword_100C757C[]; // weak
int dword_100C7580[]; // weak
int dword_100C7584[]; // weak
int dword_100C7588[]; // weak
int dword_100C758C[]; // weak
int dword_100C7590[]; // weak
float flt_100C7594[]; // weak
float flt_100C7598[]; // weak
char byte_100C7608; // weak
char byte_100C7609; // weak
char byte_100C760A[]; // weak
char byte_100C7656; // weak
_UNKNOWN unk_100C7EAE; // weak
int dword_100C86FC; // weak
int dword_100C8700[]; // weak
int dword_100C8704[]; // weak
int dword_100C8708; // weak
int dword_100C870C; // weak
int dword_100C8710; // weak
int dword_100C8714; // weak
int dword_100C8718; // weak
int dword_100C871C; // weak
int dword_100C8720; // weak
int dword_100C8724; // weak
int dword_100C8728[]; // weak
int dword_100C872C[]; // weak
int dword_100C8748[]; // weak
int dword_100C874C[]; // weak
int dword_100C8768[]; // weak
char byte_100C8778; // weak
char byte_100C8779; // weak
int dword_100C877C; // weak
int dword_100C8798; // weak
int dword_100C87B4; // weak
int dword_100C87B8; // weak
int dword_100C87BC; // weak
char byte_100C87C0[]; // weak
_UNKNOWN unk_100CE058; // weak
_UNKNOWN unk_100CE079; // weak
__int16 word_100CE0F4[]; // weak
__int16 word_100F5158; // weak
_UNKNOWN unk_100F5160; // weak
_UNKNOWN unk_100F5181; // weak
__int16 word_100F51FC[]; // weak
int dword_101089E0; // weak
int dword_101089E4; // weak
_UNKNOWN unk_101089E8; // weak
_UNKNOWN unk_10108A09; // weak
__int16 word_10108A84[]; // weak
_UNKNOWN unk_1012FAE8; // weak
_UNKNOWN unk_1012FAEA; // weak
_UNKNOWN unk_1013396A; // weak
int dword_1013396C; // weak
_UNKNOWN unk_10133970; // weak
_UNKNOWN unk_10136080; // weak
_UNKNOWN unk_1013616C; // weak
char byte_101361A0; // weak
char byte_101361A1; // weak
int dword_101361A4; // weak
int dword_101361A8; // weak
int dword_101361AC; // weak
char byte_101361B0[51860]; // idb
int dword_10142C44; // weak
int dword_10142C48; // weak
int dword_10142C4C; // weak
int dword_10142C50; // weak
int dword_10142C54; // weak
int dword_10142C58; // weak
int dword_10142C5C; // weak
int dword_10142C60; // weak
int dword_10142C64; // weak
int dword_10142C68; // weak
int dword_10142C6C; // weak
__int16 word_10142C70[]; // weak
int dword_10142C7C[]; // weak
int dword_10142C80; // weak
int dword_10142C84[]; // weak
int dword_10142C88[]; // weak
int dword_10142C9C[]; // weak
_UNKNOWN unk_10145310; // weak
char byte_10145311; // weak
char byte_1014538D[]; // weak
int dword_10145398; // weak
_UNKNOWN unk_1014539C; // weak
_UNKNOWN unk_101453A4; // weak
char byte_101453A5[]; // weak
__int16 word_101474E4; // weak
__int16 word_101474E8; // weak
__int16 word_101474EC; // weak
int dword_101474F0; // weak
void (__cdecl *dword_101474F8[8])(_DWORD, _DWORD, _DWORD); // idb
_UNKNOWN unk_10147518; // weak
char byte_10151BF0; // weak
char byte_10151BF1; // weak
int dword_10151BF8; // weak
_UNKNOWN unk_10151C00; // weak
int dword_10153140; // weak
int dword_10153144; // weak
_UNKNOWN unk_10153148; // weak
_UNKNOWN unk_10153149; // weak
_UNKNOWN unk_1015315F; // weak
_UNKNOWN unk_10153160; // weak
_UNKNOWN unk_10153161; // weak
_UNKNOWN unk_10153162; // weak
_UNKNOWN unk_10153164; // weak
_UNKNOWN unk_10153168; // weak
_UNKNOWN unk_1015316C; // weak
_UNKNOWN unk_1015318C; // weak
_UNKNOWN unk_101531AC; // weak
_UNKNOWN unk_101531CC; // weak
_UNKNOWN unk_101531EC; // weak
_UNKNOWN unk_1015320C; // weak
_UNKNOWN unk_1015322C; // weak
_UNKNOWN unk_1015324C; // weak
_UNKNOWN unk_1015326C; // weak
_UNKNOWN unk_1015328C; // weak
_UNKNOWN unk_101532AC; // weak
_UNKNOWN unk_101532CC; // weak
_UNKNOWN unk_101532EC; // weak
_UNKNOWN unk_1015330C; // weak
_UNKNOWN unk_1015332C; // weak
_UNKNOWN unk_1015334C; // weak
_UNKNOWN unk_1015336C; // weak
_UNKNOWN unk_1015338C; // weak
_UNKNOWN unk_101533AC; // weak
_UNKNOWN unk_101533CC; // weak
_UNKNOWN unk_101533EC; // weak
_UNKNOWN unk_1015340C; // weak
_UNKNOWN unk_1015342C; // weak
_UNKNOWN unk_1015344C; // weak
_UNKNOWN unk_1015346C; // weak
_UNKNOWN unk_1015348C; // weak
_UNKNOWN unk_101534AC; // weak
_UNKNOWN unk_101534CC; // weak
_UNKNOWN unk_101534EC; // weak
_UNKNOWN unk_101534F0; // weak
_UNKNOWN unk_101534F4; // weak
_UNKNOWN unk_101534F8; // weak
_UNKNOWN unk_101534FC; // weak
_UNKNOWN unk_10153500; // weak
_UNKNOWN unk_10153504; // weak
_UNKNOWN unk_10153524; // weak
_UNKNOWN unk_10153544; // weak
_UNKNOWN unk_10153564; // weak
_UNKNOWN unk_10153584; // weak
_UNKNOWN unk_101535A4; // weak
_UNKNOWN unk_101535C4; // weak
_UNKNOWN unk_101535E4; // weak
_UNKNOWN unk_10153604; // weak
_UNKNOWN unk_10153605; // weak
_UNKNOWN unk_10153606; // weak
_UNKNOWN unk_10153658; // weak
_UNKNOWN unk_10153678; // weak
_UNKNOWN unk_10153698; // weak
_UNKNOWN unk_1015369C; // weak
_UNKNOWN unk_101536A0; // weak
_UNKNOWN unk_101536A4; // weak
_UNKNOWN unk_101536C4; // weak
_UNKNOWN unk_101536E4; // weak
_UNKNOWN unk_10153704; // weak
_UNKNOWN unk_10153724; // weak
_UNKNOWN unk_10153744; // weak
_UNKNOWN unk_10153764; // weak
_UNKNOWN unk_10153784; // weak
_UNKNOWN unk_101537A4; // weak
_UNKNOWN unk_101537C4; // weak
_UNKNOWN unk_1015380C; // weak
_UNKNOWN unk_10153854; // weak
_UNKNOWN unk_1015389C; // weak
_UNKNOWN unk_101538E4; // weak
_UNKNOWN unk_1015392C; // weak
_UNKNOWN unk_10153974; // weak
_UNKNOWN unk_101539BC; // weak
_UNKNOWN unk_10153A04; // weak
_UNKNOWN unk_10153A4C; // weak
_UNKNOWN unk_10153A94; // weak
_UNKNOWN unk_10153ADC; // weak
_UNKNOWN unk_10153B24; // weak
_UNKNOWN unk_10153B6C; // weak
_UNKNOWN unk_10153BB4; // weak
_UNKNOWN unk_10153BFC; // weak
_UNKNOWN unk_10153C44; // weak
_UNKNOWN unk_10153C8C; // weak
_UNKNOWN unk_10153CD4; // weak
_UNKNOWN unk_10153D1C; // weak
_UNKNOWN unk_10153D64; // weak
_UNKNOWN unk_10153DAC; // weak
_UNKNOWN unk_10153DF4; // weak
_UNKNOWN unk_10153E3C; // weak
_UNKNOWN unk_10153E84; // weak
_UNKNOWN unk_10153ECC; // weak
_UNKNOWN unk_10153F14; // weak
_UNKNOWN unk_10153F5C; // weak
_UNKNOWN unk_10153FA4; // weak
_UNKNOWN unk_10153FEC; // weak
_UNKNOWN unk_10154034; // weak
_UNKNOWN unk_1015404C; // weak
_UNKNOWN unk_1015406C; // weak
_UNKNOWN unk_1015408C; // weak
_UNKNOWN unk_10154090; // weak
_UNKNOWN unk_10154134; // weak
_UNKNOWN unk_101541D8; // weak
_UNKNOWN unk_1015427C; // weak
_UNKNOWN unk_10154320; // weak
_UNKNOWN unk_101543C4; // weak
_UNKNOWN unk_10154468; // weak
_UNKNOWN unk_1015450C; // weak
_UNKNOWN unk_101545B0; // weak
_UNKNOWN unk_10154654; // weak
_UNKNOWN unk_101546F8; // weak
_UNKNOWN unk_1015479C; // weak
_UNKNOWN unk_10154840; // weak
_UNKNOWN unk_101548E4; // weak
_UNKNOWN unk_10154988; // weak
_UNKNOWN unk_10154A2C; // weak
_UNKNOWN unk_10154AD0; // weak
_UNKNOWN unk_10154B74; // weak
_UNKNOWN unk_10154C18; // weak
_UNKNOWN unk_10154CBC; // weak
_UNKNOWN unk_10154D60; // weak
_UNKNOWN unk_10154E04; // weak
_UNKNOWN unk_10154EA8; // weak
_UNKNOWN unk_10154F4C; // weak
_UNKNOWN unk_10154FF0; // weak
_UNKNOWN unk_10155094; // weak
_UNKNOWN unk_10155138; // weak
_UNKNOWN unk_101551DC; // weak
_UNKNOWN unk_10155280; // weak
_UNKNOWN unk_10155324; // weak
_UNKNOWN unk_101553C8; // weak
_UNKNOWN unk_1015546C; // weak
_UNKNOWN unk_10155510; // weak
_UNKNOWN unk_101555B4; // weak
_UNKNOWN unk_10155658; // weak
_UNKNOWN unk_101556FC; // weak
_UNKNOWN unk_101557A0; // weak
_UNKNOWN unk_10155844; // weak
_UNKNOWN unk_101558E8; // weak
_UNKNOWN unk_1015598C; // weak
_UNKNOWN unk_10155A30; // weak
_UNKNOWN unk_10155AD4; // weak
_UNKNOWN unk_10155B78; // weak
_UNKNOWN unk_10155C1C; // weak
_UNKNOWN unk_10155CC0; // weak
_UNKNOWN unk_10155D64; // weak
_UNKNOWN unk_10155E08; // weak
_UNKNOWN unk_10155EAC; // weak
_UNKNOWN unk_10155F50; // weak
_UNKNOWN unk_10155FF4; // weak
_UNKNOWN unk_10156098; // weak
_UNKNOWN unk_1015613C; // weak
_UNKNOWN unk_101561E0; // weak
_UNKNOWN unk_10156284; // weak
_UNKNOWN unk_10156328; // weak
_UNKNOWN unk_101563CC; // weak
_UNKNOWN unk_10156470; // weak
_UNKNOWN unk_10156514; // weak
_UNKNOWN unk_101565B8; // weak
_UNKNOWN unk_1015665C; // weak
_UNKNOWN unk_10156700; // weak
_UNKNOWN unk_101567A4; // weak
_UNKNOWN unk_10156848; // weak
_UNKNOWN unk_101568EC; // weak
_UNKNOWN unk_10156990; // weak
_UNKNOWN unk_10156A34; // weak
_UNKNOWN unk_10156AD8; // weak
_UNKNOWN unk_10156B7C; // weak
_UNKNOWN unk_10156C20; // weak
_UNKNOWN unk_10156CC4; // weak
_UNKNOWN unk_10156D68; // weak
_UNKNOWN unk_10156E0C; // weak
_UNKNOWN unk_10156EB0; // weak
_UNKNOWN unk_10156F54; // weak
_UNKNOWN unk_10156FF8; // weak
_UNKNOWN unk_1015709C; // weak
_UNKNOWN unk_10157140; // weak
_UNKNOWN unk_101571E4; // weak
_UNKNOWN unk_10157288; // weak
_UNKNOWN unk_1015732C; // weak
_UNKNOWN unk_101573D0; // weak
_UNKNOWN unk_10157474; // weak
_UNKNOWN unk_10157518; // weak
_UNKNOWN unk_101575BC; // weak
_UNKNOWN unk_10157660; // weak
_UNKNOWN unk_10157704; // weak
_UNKNOWN unk_101577A8; // weak
_UNKNOWN unk_1015784C; // weak
_UNKNOWN unk_101578F0; // weak
_UNKNOWN unk_10157994; // weak
_UNKNOWN unk_10157A38; // weak
_UNKNOWN unk_10157ADC; // weak
_UNKNOWN unk_10157B80; // weak
_UNKNOWN unk_10157C24; // weak
_UNKNOWN unk_10157CC8; // weak
_UNKNOWN unk_10157D6C; // weak
_UNKNOWN unk_10157E10; // weak
_UNKNOWN unk_10157EB4; // weak
_UNKNOWN unk_10157F58; // weak
_UNKNOWN unk_10157FFC; // weak
_UNKNOWN unk_101580A0; // weak
_UNKNOWN unk_101580C0; // weak
_UNKNOWN unk_101580E0; // weak
_UNKNOWN unk_10158100; // weak
_UNKNOWN unk_10158120; // weak
_UNKNOWN unk_10158148; // weak
_UNKNOWN unk_10158164; // weak
_UNKNOWN unk_10158180; // weak
_UNKNOWN unk_1015819C; // weak
_UNKNOWN unk_101581B8; // weak
_UNKNOWN unk_101581D4; // weak
_UNKNOWN unk_101581F0; // weak
_UNKNOWN unk_1015820C; // weak
_UNKNOWN unk_10158228; // weak
_UNKNOWN unk_10158244; // weak
_UNKNOWN unk_10158260; // weak
_UNKNOWN unk_1015827C; // weak
_UNKNOWN unk_10158298; // weak
_UNKNOWN unk_101582B4; // weak
_UNKNOWN unk_101582D0; // weak
_UNKNOWN unk_101582EC; // weak
_UNKNOWN unk_10158308; // weak
_UNKNOWN unk_10158324; // weak
_UNKNOWN unk_10158340; // weak
_UNKNOWN unk_1015835C; // weak
_UNKNOWN unk_10158378; // weak
_UNKNOWN unk_10158394; // weak
_UNKNOWN unk_101583B0; // weak
_UNKNOWN unk_101583CC; // weak
_UNKNOWN unk_101583E8; // weak
_UNKNOWN unk_10158404; // weak
_UNKNOWN unk_10158420; // weak
_UNKNOWN unk_1015843C; // weak
_UNKNOWN unk_10158458; // weak
_UNKNOWN unk_10158474; // weak
_UNKNOWN unk_10158490; // weak
_UNKNOWN unk_101584AC; // weak
_UNKNOWN unk_101584C8; // weak
_UNKNOWN unk_101584E4; // weak
_UNKNOWN unk_10158500; // weak
_UNKNOWN unk_1015851C; // weak
_UNKNOWN unk_10158538; // weak
_UNKNOWN unk_10158554; // weak
_UNKNOWN unk_10158570; // weak
_UNKNOWN unk_1015858C; // weak
_UNKNOWN unk_101585A8; // weak
_UNKNOWN unk_101585C4; // weak
_UNKNOWN unk_101585E0; // weak
_UNKNOWN unk_101585FC; // weak
_UNKNOWN unk_10158618; // weak
_UNKNOWN unk_10158634; // weak
_UNKNOWN unk_10158650; // weak
_UNKNOWN unk_1015866C; // weak
_UNKNOWN unk_10158688; // weak
_UNKNOWN unk_101586A4; // weak
_UNKNOWN unk_101586C0; // weak
_UNKNOWN unk_101586DC; // weak
_UNKNOWN unk_101586F8; // weak
_UNKNOWN unk_10158714; // weak
_UNKNOWN unk_10158730; // weak
_UNKNOWN unk_1015874C; // weak
_UNKNOWN unk_10158768; // weak
_UNKNOWN unk_10158784; // weak
_UNKNOWN unk_101587A0; // weak
_UNKNOWN unk_101587BC; // weak
_UNKNOWN unk_101587D8; // weak
_UNKNOWN unk_101587F4; // weak
_UNKNOWN unk_10158810; // weak
_UNKNOWN unk_1015882C; // weak
_UNKNOWN unk_10158848; // weak
_UNKNOWN unk_10158864; // weak
_UNKNOWN unk_10158880; // weak
_UNKNOWN unk_1015889C; // weak
_UNKNOWN unk_101588B8; // weak
_UNKNOWN unk_101588D4; // weak
_UNKNOWN unk_101588F0; // weak
_UNKNOWN unk_1015890C; // weak
_UNKNOWN unk_10158928; // weak
_UNKNOWN unk_10158944; // weak
_UNKNOWN unk_10158960; // weak
_UNKNOWN unk_1015897C; // weak
_UNKNOWN unk_10158998; // weak
_UNKNOWN unk_101589B4; // weak
_UNKNOWN unk_101589D0; // weak
_UNKNOWN unk_101589EC; // weak
_UNKNOWN unk_10158A08; // weak
_UNKNOWN unk_10158A24; // weak
_UNKNOWN unk_10158A40; // weak
_UNKNOWN unk_10158A5C; // weak
_UNKNOWN unk_10158A78; // weak
_UNKNOWN unk_10158A94; // weak
_UNKNOWN unk_10158AB0; // weak
_UNKNOWN unk_10158ACC; // weak
_UNKNOWN unk_10158AE8; // weak
_UNKNOWN unk_10158B04; // weak
_UNKNOWN unk_10158B20; // weak
_UNKNOWN unk_10158B3C; // weak
_UNKNOWN unk_10158B58; // weak
_UNKNOWN unk_10158B74; // weak
_UNKNOWN unk_10158B90; // weak
_UNKNOWN unk_10158BAC; // weak
_UNKNOWN unk_10158BC8; // weak
_UNKNOWN unk_10158BE4; // weak
_UNKNOWN unk_10158C00; // weak
_UNKNOWN unk_10158C1C; // weak
_UNKNOWN unk_10158C38; // weak
_UNKNOWN unk_10158C3C; // weak
_UNKNOWN unk_10158C40; // weak
_UNKNOWN unk_10158C44; // weak
_UNKNOWN unk_10158C48; // weak
_UNKNOWN unk_10158C4C; // weak
_UNKNOWN unk_10158C50; // weak
_UNKNOWN unk_10158C54; // weak
_UNKNOWN unk_10158C58; // weak
_UNKNOWN unk_10158C5C; // weak
_UNKNOWN unk_10158C60; // weak
_UNKNOWN unk_10158C64; // weak
_UNKNOWN unk_10158C68; // weak
_UNKNOWN unk_10158C6C; // weak
_UNKNOWN unk_10158C70; // weak
_UNKNOWN unk_10158C74; // weak
_UNKNOWN unk_10158C78; // weak
_UNKNOWN unk_10158C7C; // weak
_UNKNOWN unk_10158C80; // weak
_UNKNOWN unk_10158D64; // weak
_UNKNOWN unk_10159F24; // weak
_UNKNOWN unk_10159F28; // weak
_UNKNOWN unk_10159F50; // weak
_UNKNOWN unk_10159F78; // weak
_UNKNOWN unk_10159FB8; // weak
_UNKNOWN unk_1015A038; // weak
_UNKNOWN unk_1015A03C; // weak
_UNKNOWN unk_1015A040; // weak
_UNKNOWN unk_1015A042; // weak
_UNKNOWN unk_1015A044; // weak
_UNKNOWN unk_1015A045; // weak
_UNKNOWN unk_1015A046; // weak
_UNKNOWN unk_1015A048; // weak
_UNKNOWN unk_1015A0AC; // weak
_UNKNOWN unk_1015A0B4; // weak
_UNKNOWN unk_1015A0BC; // weak
_UNKNOWN unk_1015A0C4; // weak
_UNKNOWN unk_1015A0CC; // weak
_UNKNOWN unk_1015A0D4; // weak
_UNKNOWN unk_1015A0DC; // weak
_UNKNOWN unk_1015A0E4; // weak
_UNKNOWN unk_1015A0EC; // weak
_UNKNOWN unk_1015A0F4; // weak
_UNKNOWN unk_1015A0FC; // weak
_UNKNOWN unk_1015A104; // weak
_UNKNOWN unk_1015A10C; // weak
_UNKNOWN unk_1015A114; // weak
_UNKNOWN unk_1015A11C; // weak
_UNKNOWN unk_1015A124; // weak
_UNKNOWN unk_1015A12C; // weak
_UNKNOWN unk_1015A134; // weak
_UNKNOWN unk_1015A13C; // weak
_UNKNOWN unk_1015A144; // weak
_UNKNOWN unk_1015A14C; // weak
_UNKNOWN unk_1015A154; // weak
_UNKNOWN unk_1015A15C; // weak
_UNKNOWN unk_1015A164; // weak
_UNKNOWN unk_1015A16C; // weak
_UNKNOWN unk_1015A174; // weak
_UNKNOWN unk_1015A17C; // weak
_UNKNOWN unk_1015A184; // weak
_UNKNOWN unk_1015A18C; // weak
_UNKNOWN unk_1015A194; // weak
_UNKNOWN unk_1015A19C; // weak
_UNKNOWN unk_1015A1A4; // weak
_UNKNOWN unk_1015A1AC; // weak
_UNKNOWN unk_1015A1B4; // weak
_UNKNOWN unk_1015A1BC; // weak
_UNKNOWN unk_1015A1C4; // weak
_UNKNOWN unk_1015A1CC; // weak
_UNKNOWN unk_1015A1D4; // weak
_UNKNOWN unk_1015A1DC; // weak
_UNKNOWN unk_1015A1E4; // weak
_UNKNOWN unk_1015A3CC; // weak
_UNKNOWN unk_1015A3DC; // weak
_UNKNOWN unk_1015A3EC; // weak
_UNKNOWN unk_1015A3FC; // weak
_UNKNOWN unk_1015A3FD; // weak
_UNKNOWN unk_1015A3FE; // weak
_UNKNOWN unk_1015A400; // weak
_UNKNOWN unk_1015A404; // weak
_UNKNOWN unk_1015A4AC; // weak
_UNKNOWN unk_1015A4B0; // weak
_UNKNOWN unk_1015A4B4; // weak
_UNKNOWN unk_1015A504; // weak
_UNKNOWN unk_1015A508; // weak
_UNKNOWN unk_1015A50C; // weak
_UNKNOWN unk_1015A5FC; // weak
_UNKNOWN unk_1015A6EC; // weak
_UNKNOWN unk_1015A6F0; // weak
_UNKNOWN unk_1015A6F8; // weak
_UNKNOWN unk_1015A700; // weak
_UNKNOWN unk_1015A708; // weak
_UNKNOWN unk_1015A710; // weak
_UNKNOWN unk_1015A718; // weak
_UNKNOWN unk_1015A720; // weak
_UNKNOWN unk_1015A728; // weak
_UNKNOWN unk_1015A730; // weak
_UNKNOWN unk_1015A738; // weak
_UNKNOWN unk_1015A740; // weak
_UNKNOWN unk_1015A748; // weak
_UNKNOWN unk_1015A74C; // weak
_UNKNOWN unk_1015A750; // weak
_UNKNOWN unk_1015A754; // weak
_UNKNOWN unk_1015A7A8; // weak
_UNKNOWN unk_1015A7FC; // weak
_UNKNOWN unk_1015A804; // weak
_UNKNOWN unk_1015A808; // weak
_UNKNOWN unk_1015A80C; // weak
_UNKNOWN unk_1015A810; // weak
_UNKNOWN unk_1015A814; // weak
_UNKNOWN unk_1015AA1C; // weak
_UNKNOWN unk_1015AB7C; // weak
_UNKNOWN unk_1015AB94; // weak
_UNKNOWN unk_1015ABAC; // weak
_UNKNOWN unk_1015ABB6; // weak
_UNKNOWN unk_1015ABB8; // weak
_UNKNOWN unk_1015ABC8; // weak
_UNKNOWN unk_1015ABCC; // weak
_UNKNOWN unk_1015ABD0; // weak
_UNKNOWN unk_1015ABD4; // weak
_UNKNOWN unk_1015ABD5; // weak
_UNKNOWN unk_1015ABD8; // weak
_UNKNOWN unk_1015AC28; // weak
_UNKNOWN unk_1015AC2C; // weak
_UNKNOWN unk_1015AC2D; // weak
_UNKNOWN unk_1015AC2E; // weak
_UNKNOWN unk_1015AC2F; // weak
_UNKNOWN unk_1015AC43; // weak
_UNKNOWN unk_1015AC44; // weak
_UNKNOWN unk_1015AC45; // weak
_UNKNOWN unk_1015AC46; // weak
_UNKNOWN unk_1015AC48; // weak
_UNKNOWN unk_1015ACE8; // weak
_UNKNOWN unk_1015AD38; // weak
_UNKNOWN unk_1015AD3C; // weak
_UNKNOWN unk_1015AD40; // weak
_UNKNOWN unk_1015AD44; // weak
_UNKNOWN unk_1015AD48; // weak
_UNKNOWN unk_1015AD4C; // weak
_UNKNOWN unk_1015AD50; // weak
_UNKNOWN unk_1015AD54; // weak
_UNKNOWN unk_1015AD58; // weak
_UNKNOWN unk_1015AD5C; // weak
_UNKNOWN unk_1015AD60; // weak
_UNKNOWN unk_1015AD64; // weak
_UNKNOWN unk_1015AD68; // weak
_UNKNOWN unk_1015AEA8; // weak
_UNKNOWN unk_1015AEB4; // weak
_UNKNOWN unk_1015AEFC; // weak
_UNKNOWN unk_1015AEFD; // weak
_UNKNOWN unk_1015AF28; // weak
_UNKNOWN unk_1015AF58; // weak
_UNKNOWN unk_1015AF80; // weak
_UNKNOWN unk_1015AF84; // weak
_UNKNOWN unk_1015AF88; // weak
_UNKNOWN unk_1015AF8C; // weak
_UNKNOWN unk_1015AFBC; // weak
_UNKNOWN unk_1015AFBD; // weak
_UNKNOWN unk_1015AFBE; // weak
_UNKNOWN unk_1015AFC0; // weak
_UNKNOWN unk_1015AFC4; // weak
_UNKNOWN unk_1015AFC8; // weak
_UNKNOWN unk_1015AFCC; // weak
_UNKNOWN unk_1015AFD0; // weak
_UNKNOWN unk_1015AFD4; // weak
_UNKNOWN unk_1015AFD8; // weak
_UNKNOWN unk_1015AFDC; // weak
_UNKNOWN unk_1015AFE0; // weak
_UNKNOWN unk_1015AFE4; // weak
_UNKNOWN unk_1015B344; // weak
_UNKNOWN unk_1015B348; // weak
_UNKNOWN unk_1015B352; // weak
_UNKNOWN unk_1015B35C; // weak
int dword_1015CB18; // weak
_UNKNOWN unk_1015CB20; // weak
_UNKNOWN unk_1015DB20; // weak
_UNKNOWN unk_101671D8; // weak
int dword_101681D8; // weak
int dword_101681DC; // weak
int dword_101681E0; // weak
int dword_101681E4; // weak
int dword_101681E8; // weak
int dword_101681EC; // weak
int dword_101681F0; // weak
int dword_101681F4; // weak
int dword_101681F8; // weak
char byte_10168200[]; // weak
char byte_10168204[]; // weak
char byte_10168205[]; // weak
int dword_1016820C[]; // weak
int dword_10168214[]; // weak
char byte_10175990[]; // weak
char byte_1017599A[]; // weak
_UNKNOWN unk_101759A9; // weak
_UNKNOWN unk_101759D1; // weak
_UNKNOWN unk_101759D6; // weak
_UNKNOWN unk_10175BC2; // weak
_UNKNOWN unk_10175C69; // weak
_UNKNOWN unk_10175C6A; // weak
_UNKNOWN unk_10175C89; // weak
_UNKNOWN unk_10175CB0; // weak
_UNKNOWN unk_10175CB1; // weak
_UNKNOWN unk_10175CD0; // weak
char byte_10175E5C; // weak
__int16 word_10176430[]; // weak
__int16 word_10176432[]; // weak
__int16 word_10176434[]; // weak
__int16 word_10176436[]; // weak
__int16 word_10176438[]; // weak
__int16 word_10176C00[]; // weak
__int16 word_10176C02[]; // weak
__int16 word_10176C04[]; // weak
__int16 word_10176C06[]; // weak
__int16 word_10176C08[]; // weak
_UNKNOWN unk_101773D0; // weak
_UNKNOWN unk_1017745A; // weak
_UNKNOWN unk_1017B258; // weak
_UNKNOWN unk_1017B259; // weak
_UNKNOWN unk_1017B2DA; // weak
_UNKNOWN unk_1017B2F5; // weak
_UNKNOWN unk_1017B2FA; // weak
_UNKNOWN unk_1017B5C9; // weak
_UNKNOWN unk_1017B5CA; // weak
_UNKNOWN unk_1017B649; // weak
int dword_1017BAEC; // weak
int dword_1017BAF0; // weak
int dword_1017BAF4; // weak
int dword_1017BAF8; // weak
char byte_1017BAFC; // weak
_UNKNOWN unk_1017BB04; // weak
_UNKNOWN unk_1017BB08; // weak
int dword_1017BB0C; // weak
int dword_1017BB80; // weak
_UNKNOWN unk_1017BB88; // weak
char byte_1017BE60[]; // weak
char byte_1017BE61[]; // weak
char byte_1017BE80[]; // weak
char byte_1017BE81[]; // weak
_UNKNOWN unk_1017D0C8; // weak
int dword_1017EA78; // weak
int dword_1017EA7C; // weak
int dword_1017EA80; // weak
int dword_1017EA84; // weak
char byte_101E1060[]; // weak
char byte_101E1061[]; // weak
_UNKNOWN unk_101E1100; // weak
int dword_101E13D0[]; // weak
int dword_101E13D4[]; // weak
_UNKNOWN unk_101E18F0; // weak
_UNKNOWN unk_101E47F8; // weak
_UNKNOWN unk_101E4CF8; // weak
_UNKNOWN unk_101E4DA0; // weak
char byte_101E4DC0; // weak
char byte_101E4DC1; // weak
char byte_101E4DC2; // weak
char byte_101E4DC3; // weak
_UNKNOWN unk_101E4DC8; // weak
_UNKNOWN unk_101E4DE8; // weak
char byte_101E4E08; // weak
char byte_101E4E09; // weak
char byte_101E4E0A; // weak
char byte_101E4E0B; // weak
_UNKNOWN unk_101E4E2C; // weak
int dword_101E4F70[]; // weak
int dword_101E4F74; // weak
int dword_101E4F78; // weak
int dword_101E4F7C; // weak
int dword_101E4F80; // weak
int dword_101E4F84[]; // weak
int dword_101E4F88; // weak
int dword_101E4F8C; // weak
int dword_101E4F90; // weak
int dword_101E4F94; // weak
_UNKNOWN unk_101E4F98; // weak
__int16 word_101E50B0[]; // weak
char byte_101E50B2[]; // weak
__int16 word_101E50B4; // weak
char byte_101E50B6; // weak
int dword_101E5A80[]; // weak
int dword_101E5A84[]; // weak
int dword_101E5A88[]; // weak
int dword_101E5A8C[]; // weak
int dword_101E5A90[]; // weak
int dword_101E5A94[]; // weak
int dword_101E5A98[]; // weak
int dword_101E5A9C[]; // weak
int dword_101E5AA0[]; // weak
int dword_101E5AA4[]; // weak
int dword_101E5AA8[]; // weak
int dword_101E5AAC[]; // weak
int dword_101E5AB0[]; // weak
int dword_101E5ADC; // weak
int dword_101E5AE0; // weak
int dword_101E5AE4; // weak
int dword_101E5AE8; // weak
int dword_101E5AEC; // weak
int dword_101E5AF0; // weak
int dword_101E5AF4; // weak
int dword_101E5AF8; // weak
int dword_101E5AFC; // weak
int dword_101E5B00; // weak
char byte_101E5CB8[254]; // idb
char byte_101E5DB6[]; // weak
char byte_101E5DB7[]; // weak
int dword_101EA8A8[]; // weak
int dword_101EA8BC[]; // weak
int dword_101EC9A0[]; // weak
int dword_101EC9B4[]; // weak
int dword_101EDFA8[]; // weak
int dword_101EDFBC[]; // weak
_DWORD dword_102097E8[16]; // idb
int dword_10209828[]; // weak
int dword_10209868; // weak
int dword_10209870[]; // weak
int dword_102098E0; // weak
int dword_10209C60; // weak
int dword_10209C68; // weak
int dword_10209C74; // weak
int dword_1020A250; // weak
int dword_1020A25C; // weak
int dword_1020A268; // weak
int dword_1020A26C; // weak
int dword_1020A270; // weak
int dword_1020A340; // weak
int dword_1020A344; // weak
int dword_1020A348; // weak
int dword_1020A34C; // weak
int dword_1020A350; // weak
_UNKNOWN unk_1020A540; // weak
_UNKNOWN unk_1020ABC0; // weak
_UNKNOWN unk_1020AC80; // weak
char byte_1020B260; // weak
char byte_1020B261; // weak
char byte_1020B262; // weak
char byte_1020B263; // weak
int dword_1020B264; // weak
int dword_1020B26C; // weak
int dword_1020B270; // weak
int dword_1020B274; // weak
int dword_1020B278; // weak
int dword_1020B27C; // weak
int dword_1020B280; // weak
int dword_1020B284; // weak
int dword_1020B288; // weak
int dword_1020B28C; // weak
int dword_1020B290; // weak
int dword_1020B294; // weak
int dword_1020B298; // weak
int dword_1020B29C; // weak
int dword_1020B2A0; // weak
int dword_1020B2A4; // weak
int dword_1020B2A8; // weak
void *dword_1020B2AC; // idb
int dword_1020B2B0; // weak
int dword_1020B2B4; // weak
int dword_1020B2C0; // weak
int dword_1020B2C4; // weak
int dword_1020B2C8; // weak
int dword_1020B2CC; // weak
int dword_1020B2D0; // weak
int dword_1020B2D4; // weak
_UNKNOWN unk_1020B2E0; // weak
int dword_1020CF60; // weak
char byte_1020CF64; // weak
int dword_1020CF68; // weak
char byte_1020CF6C; // weak
int dword_1020CF70; // weak
char byte_1020CF74; // weak
int dword_1020CF78; // weak
int dword_1020CF7C; // weak
int dword_1020CF80; // weak
int dword_1020CF8C; // weak
int dword_1020CF94; // weak
char byte_1020CF98; // weak
int dword_1020CFA0[]; // weak
__int16 word_1020CFA4[]; // weak
int dword_1020CFA8[]; // weak
int dword_1020CFAC; // weak
int dword_1020CFB0; // weak
int dword_1020CFB4; // weak
int dword_1020CFB8; // weak
__int16 word_1020CFBC; // weak
int dword_1020CFC0; // weak
int dword_1020D008; // weak
int dword_1020D024; // weak
__int16 word_1020D028; // weak
int dword_1020D068; // weak
int dword_1020D098; // weak
int dword_1020D0E0; // weak
int dword_1020D188; // weak
int dword_1020D194; // weak
int dword_1020D1A4; // weak
__int16 word_1020D1A8; // weak
int dword_1020D1B0; // weak
__int16 word_1020D1B4; // weak
int dword_1020D1BC; // weak
__int16 word_1020D1C0; // weak
int dword_1020D2C4; // weak
int dword_1020D33C; // weak
__int16 word_1020D340; // weak
_UNKNOWN unk_1020D6A8; // weak
_UNKNOWN unk_1020D6A9; // weak
_UNKNOWN unk_1020D6AA; // weak
__int16 word_1020D6C0[]; // weak
__int16 word_1020D6C2; // weak
__int16 word_1020D6C4; // weak
__int16 word_1020D6C6; // weak
__int16 word_1020D6C8; // weak
__int16 word_1020D6CA; // weak
__int16 word_1020D6CC; // weak
__int16 word_1020D6CE; // weak
__int16 word_1020D6E4; // weak
__int16 word_1020D6E6; // weak
char byte_1020D7EC; // weak
char byte_1020D7ED; // weak
int dword_1020D7F0; // weak
char byte_1020D7F4; // weak
int dword_1020D7F8; // weak
int dword_1020D800; // weak
int dword_1020D804; // weak
int dword_1020D808; // weak
int dword_1020D80C; // weak
int dword_1020D810; // weak
int dword_1020D814; // weak
int dword_1020D818; // weak
void *dword_1020D834; // idb
int dword_1020E840; // weak
int dword_1020E844; // weak
UINT uNumber; // idb
int dword_1020E860[]; // weak
int dword_1020E960; // weak
int dword_1020E978; // weak


//----- (10001000) --------------------------------------------------------
char sub_10001000()
{
  return byte_100C2781;
}
// 100C2781: using guessed type char byte_100C2781;

//----- (10001010) --------------------------------------------------------
char sub_10001010()
{
  return byte_100C74A4;
}
// 100C74A4: using guessed type char byte_100C74A4;

//----- (10001020) --------------------------------------------------------
int sub_10001020()
{
  int result; // eax@1

  byte_100C2783 = 0;
  byte_100C74A4 = 1;
  byte_100C2781 = 0;
  dword_100C87B8 = 0;
  byte_100C2780 = 0;
  dword_100C87BC = 1;
  byte_100C74A6 = 0;
  byte_100C74A7 = 1;
  byte_100C7576 = 0;
  byte_100C750F = 0;
  word_100C750C = 0;
  memset(byte_100C87C0, 0, 0x5814u);
  word_100C7574 = 0;
  byte_100C74A5 = 97;
  memset(dword_100C7578, 0, 0x90u);
  memset(&byte_100C8778, 0, 0x40u);
  memset(&byte_100C7608, 0, 0x10F8u);
  memset(&byte_100C2788, 0, 0x4D1Cu);
  memset(dword_100C8728, 0, 0x50u);
  result = 0;
  byte_100C2788 = 0;
  byte_100C2782 = 0;
  dword_100C2784 = 0;
  byte_100C7510 = 0;
  byte_100C27CA = 1;
  dword_100C8700[0] = 0;
  dword_100C8704[0] = 0;
  dword_100C8708 = 0;
  dword_100C870C = 0;
  dword_100C8710 = 0;
  dword_100C8714 = 0;
  dword_100C8718 = 0;
  dword_100C871C = 0;
  dword_100C8720 = 0;
  dword_100C8724 = 0;
  return result;
}
// 100C2780: using guessed type char byte_100C2780;
// 100C2781: using guessed type char byte_100C2781;
// 100C2782: using guessed type char byte_100C2782;
// 100C2783: using guessed type char byte_100C2783;
// 100C2784: using guessed type int dword_100C2784;
// 100C2788: using guessed type char byte_100C2788;
// 100C27CA: using guessed type char byte_100C27CA;
// 100C74A4: using guessed type char byte_100C74A4;
// 100C74A5: using guessed type char byte_100C74A5;
// 100C74A6: using guessed type char byte_100C74A6;
// 100C74A7: using guessed type char byte_100C74A7;
// 100C750C: using guessed type __int16 word_100C750C;
// 100C750F: using guessed type char byte_100C750F;
// 100C7510: using guessed type char byte_100C7510;
// 100C7574: using guessed type __int16 word_100C7574;
// 100C7576: using guessed type char byte_100C7576;
// 100C7578: using guessed type int dword_100C7578[];
// 100C7608: using guessed type char byte_100C7608;
// 100C8700: using guessed type int dword_100C8700[];
// 100C8704: using guessed type int dword_100C8704[];
// 100C8708: using guessed type int dword_100C8708;
// 100C870C: using guessed type int dword_100C870C;
// 100C8710: using guessed type int dword_100C8710;
// 100C8714: using guessed type int dword_100C8714;
// 100C8718: using guessed type int dword_100C8718;
// 100C871C: using guessed type int dword_100C871C;
// 100C8720: using guessed type int dword_100C8720;
// 100C8724: using guessed type int dword_100C8724;
// 100C8728: using guessed type int dword_100C8728[];
// 100C8778: using guessed type char byte_100C8778;
// 100C87B8: using guessed type int dword_100C87B8;
// 100C87BC: using guessed type int dword_100C87BC;

//----- (10001130) --------------------------------------------------------
char __cdecl sub_10001130(int a1, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  char result; // al@3
  int v5; // [sp+8h] [bp-6Ch]@1
  char v6; // [sp+Ch] [bp-68h]@1

  v2 = a2;
  memset(&v6, 0, 0x64u);
  v5 = 0;
  v3 = sub_10014DE0(&a1, 2u, (int)&unk_10046940, 8, 7, 7);
  if ( v3 == 7 )
    sub_10014D70("..\\lib\\adl\\iop_cdu_dbg_frmt.c", 1957, 1, 0);
  result = sub_1000D660(a1, v2, &v6, (unsigned __int16 *)&v5);
  if ( result == 1 )
    result = (unsigned int)sub_1000AA90(dword_10046944[2 * v3], &v6, v5);
  return result;
}
// 10046944: using guessed type int dword_10046944[];

//----- (100011E0) --------------------------------------------------------
char __cdecl sub_100011E0(int a1)
{
  unsigned int v1; // eax@3
  unsigned int v2; // esi@3
  int v3; // esi@5
  void (__cdecl *v4)(int); // esi@9

  if ( (unsigned __int8)a1 <= 1u )
    byte_100C750E = a1;
  v1 = sub_10014DE0(&byte_100C2783, 1u, (int)&unk_10046730, 16, 21, 21);
  v2 = v1;
  if ( v1 == 21 )
    LOBYTE(v1) = sub_10014D70("..\\lib\\adl\\iop_cdu_dbg_frmt.c", 2182, 1, 0);
  v3 = 4 * v2;
  if ( dword_1004673C[v3] && (v1 = sub_10030040() - dword_100C87B8, v1 >= dword_100C87BC * dword_1004673C[v3])
    || byte_100C2780 == 1
    || byte_100C8778 == 1 )
  {
    v4 = (void (__cdecl *)(int))dword_10046738[v3];
    if ( v4 )
      v4(a1);
    v1 = sub_10030040();
    dword_100C87B8 = v1;
    byte_100C2780 = 0;
  }
  return v1;
}
// 10046738: using guessed type int dword_10046738[];
// 1004673C: using guessed type int dword_1004673C[];
// 100C2780: using guessed type char byte_100C2780;
// 100C2783: using guessed type char byte_100C2783;
// 100C750E: using guessed type char byte_100C750E;
// 100C8778: using guessed type char byte_100C8778;
// 100C87B8: using guessed type int dword_100C87B8;
// 100C87BC: using guessed type int dword_100C87BC;

//----- (10001290) --------------------------------------------------------
char __cdecl sub_10001290(char a1, const char *a2)
{
  char *v2; // ebx@1
  unsigned __int16 v3; // kr00_2@1
  int v4; // esi@1

  v2 = (char *)a2;
  v3 = strlen(a2);
  v4 = sub_10014DE0(&a1, 4u, (int)&unk_10046978, 8, 7, 7);
  if ( v4 == 7 )
    sub_10014D70("..\\lib\\adl\\iop_cdu_dbg_frmt.c", 2277, 1, 0);
  return sub_1000D2F0((unsigned __int16)word_1004697C[4 * v4], v3, 0xFFFFFFF, v2, 1, (int)&byte_1020B260);
}
// 1004697C: using guessed type __int16 word_1004697C[];
// 1020B260: using guessed type char byte_1020B260;

//----- (10001310) --------------------------------------------------------
char __usercall sub_10001310@<al>(char result@<al>)
{
  byte_100C8778 = 0;
  byte_100C2783 = result;
  byte_100C2780 = 1;
  return result;
}
// 100C2780: using guessed type char byte_100C2780;
// 100C2783: using guessed type char byte_100C2783;
// 100C8778: using guessed type char byte_100C8778;

//----- (10001330) --------------------------------------------------------
int __usercall sub_10001330@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int result; // eax@1

  v1 = 10 * a1;
  result = sub_10011500((int)&dword_100C8704[10 * a1], (int)&unk_100468A8 + 40 * a1);
  LOBYTE(dword_100C8700[v1]) = 1;
  return result;
}
// 100C8700: using guessed type int dword_100C8700[];
// 100C8704: using guessed type int dword_100C8704[];

//----- (10001360) --------------------------------------------------------
char __cdecl sub_10001360(void *a1, unsigned __int16 a2)
{
  void *v2; // ecx@0
  int v3; // esi@1
  int v5; // [sp+0h] [bp-4h]@1

  v5 = sub_10014FA0(v2);
  v3 = sub_10014DE0(&v5, 4u, (int)&unk_100469B0, 8, 7, 7);
  if ( v3 == 7 )
    sub_10014D70("..\\lib\\adl\\iop_cdu_dbg_frmt.c", 3092, 1, 0);
  return sub_1000D2F0((unsigned __int16)word_100469B4[4 * v3], a2, 0xFFFFFFF, a1, 1, (int)&byte_1020B260);
}
// 100469B4: using guessed type __int16 word_100469B4[];
// 1020B260: using guessed type char byte_1020B260;

//----- (100013D0) --------------------------------------------------------
char __cdecl sub_100013D0(int a1, _BYTE *a2)
{
  char v2; // bl@1
  char result; // al@2

  v2 = 0;
  switch ( *a2 )
  {
    case 0x31:
      byte_100C74A6 = 0;
      result = 1;
      break;
    case 0x32:
      byte_100C74A6 = 1;
      result = 1;
      break;
    case 0x33:
      result = 1;
      byte_100C74A6 = 2;
      break;
    case 0x34:
      if ( _RTC_NumErrors() < 4 )
        goto LABEL_8;
      result = 1;
      byte_100C74A6 = 3;
      break;
    case 0x43:
      memset(dword_100C7578, 0, 0x90u);
      v2 = 1;
      goto LABEL_8;
    default:
LABEL_8:
      result = v2;
      break;
  }
  return result;
}
// 10030740: using guessed type int _RTC_NumErrors(void);
// 100C74A6: using guessed type char byte_100C74A6;
// 100C7578: using guessed type int dword_100C7578[];

//----- (10001480) --------------------------------------------------------
char __cdecl sub_10001480(int a1, const void *a2)
{
  char result; // al@1
  char v3; // cl@4

  result = 0;
  if ( !memcmp(a2, "FLOOD", 6u) )
  {
    result = 1;
LABEL_3:
    byte_100C8778 = result;
    return result;
  }
  v3 = *(_BYTE *)a2;
  if ( *(_BYTE *)a2 != 10 )
  {
    if ( v3 == 82 )
    {
      byte_100C8779 = byte_100C8779 == 0;
      return 1;
    }
    if ( v3 != 67 )
      goto LABEL_3;
    memset(&byte_100C8778, 0, 0x40u);
    j_HWM_pvg_hsdb_clear_stats();
    dword_100C87B4 = sub_10030040();
  }
  return 1;
}
// 100080B0: using guessed type int j_HWM_pvg_hsdb_clear_stats(void);
// 100C8778: using guessed type char byte_100C8778;
// 100C8779: using guessed type char byte_100C8779;
// 100C87B4: using guessed type int dword_100C87B4;

//----- (100014F0) --------------------------------------------------------
char __cdecl sub_100014F0(int a1, _BYTE *a2)
{
  char result; // al@1

  result = 0;
  if ( *a2 == 67 || *a2 == 99 )
  {
    dword_100C2784 = 0;
    byte_100C2782 = byte_100C2782 == 0;
    result = 1;
  }
  return result;
}
// 100C2782: using guessed type char byte_100C2782;
// 100C2784: using guessed type int dword_100C2784;

//----- (10001520) --------------------------------------------------------
char __cdecl sub_10001520(int a1, char *a2)
{
  __int32 v2; // eax@2

  if ( !isdigit((unsigned __int8)*a2) )
    return 0;
  v2 = j__atol(a2);
  dword_100C87BC = v2;
  if ( v2 )
  {
    if ( v2 >= 1000 )
      goto LABEL_4;
  }
  else if ( *a2 != 48 )
  {
LABEL_4:
    dword_100C87BC = 1;
    return 0;
  }
  return 1;
}
// 100C87BC: using guessed type int dword_100C87BC;

//----- (10001570) --------------------------------------------------------
char __cdecl sub_10001570(int a1, char *a2)
{
  char v2; // cl@1
  char result; // al@1
  unsigned __int16 v4; // si@6

  v2 = *a2;
  result = 0;
  switch ( *a2 )
  {
    case 0x43:
    case 0x63:
      byte_100C7608 = 1;
      result = 1;
      break;
    case 0x45:
    case 0x65:
      byte_100C7609 = byte_100C7609 == 0;
      result = 1;
      break;
    default:
      if ( (unsigned __int8)v2 >= 0x30u && (unsigned __int8)v2 <= 0x39u )
      {
        v4 = j__atol(a2);
        if ( v4 >= 0x4Cu )
        {
          byte_100C7656 = 0;
          result = 1;
        }
        else
        {
          if ( !byte_100C7656 || byte_100C760A[v4] == 1 )
          {
            byte_100C7656 = 1;
            memset(byte_100C760A, 0, 0x4Cu);
          }
          byte_100C760A[v4] = 1;
          result = 1;
        }
      }
      break;
  }
  return result;
}
// 100C7608: using guessed type char byte_100C7608;
// 100C7609: using guessed type char byte_100C7609;
// 100C7656: using guessed type char byte_100C7656;

//----- (10001650) --------------------------------------------------------
char __cdecl sub_10001650(int a1, char *a2)
{
  char v2; // cl@1
  char result; // al@1
  char v4; // al@10

  v2 = *a2;
  result = 0;
  if ( (unsigned __int8)*a2 >= 0x30u && (unsigned __int8)v2 <= 0x39u
    || (unsigned __int8)v2 >= 0x61u && (unsigned __int8)v2 <= 0x65u
    || (unsigned __int8)v2 >= 0x41u && (unsigned __int8)v2 <= 0x45u
    || v2 == 109
    || v2 == 77 )
  {
    if ( isalpha((unsigned __int8)v2) )
    {
      v4 = toupper((unsigned __int8)*a2);
      byte_100C74A5 = v4;
      if ( (unsigned __int8)v4 > 0x45u && v4 != 77 )
        byte_100C74A5 = 65;
      result = 1;
      word_100C7574 = 0;
    }
    else
    {
      word_100C7574 = j__atol(a2);
      result = 1;
    }
  }
  return result;
}
// 100C74A5: using guessed type char byte_100C74A5;
// 100C7574: using guessed type __int16 word_100C7574;

//----- (100016E0) --------------------------------------------------------
char __cdecl sub_100016E0(int a1, char *a2)
{
  char v2; // cl@1
  char result; // al@1
  unsigned int v4; // eax@2
  unsigned __int32 v5; // eax@9
  unsigned __int32 v6; // esi@9

  v2 = *a2;
  result = 0;
  switch ( *a2 )
  {
    case 0x43:
    case 0x63:
      memcpy(&unk_100C47D4, word_100C27D0, 0x2000u);
      dword_100C73D4 = dword_100C47D0;
      v4 = 0;
      do
      {
        dword_100C67D4[v4] = 0;
        dword_100C67D8[v4] = 0;
        dword_100C67DC[v4] = 0;
        dword_100C67E0[v4] = 0;
        v4 += 6;
      }
      while ( v4 < 384 );
      result = 1;
      break;
    case 0x45:
    case 0x65:
      byte_100C2788 = byte_100C2788 == 0;
      result = 1;
      break;
    case 0x57:
    case 0x77:
      byte_100C27CA = byte_100C27CA == 0;
      result = 1;
      break;
    default:
      if ( (unsigned __int8)v2 >= 0x30u && (unsigned __int8)v2 <= 0x39u )
      {
        v5 = j__atol(a2);
        v6 = v5;
        if ( v5 >= 0x40 )
        {
          byte_100C27C9 = 0;
          result = 1;
        }
        else
        {
          if ( !byte_100C27C9 || byte_100C2789[v5] == 1 )
          {
            byte_100C27C9 = 1;
            memset(byte_100C2789, 0, 0x40u);
          }
          byte_100C2789[v6] = 1;
          result = 1;
        }
      }
      break;
  }
  return result;
}
// 100C2788: using guessed type char byte_100C2788;
// 100C27C9: using guessed type char byte_100C27C9;
// 100C27CA: using guessed type char byte_100C27CA;
// 100C27D0: using guessed type __int16 word_100C27D0[];
// 100C47D0: using guessed type int dword_100C47D0;
// 100C67D4: using guessed type int dword_100C67D4[];
// 100C67D8: using guessed type int dword_100C67D8[];
// 100C67DC: using guessed type int dword_100C67DC[];
// 100C67E0: using guessed type int dword_100C67E0[];
// 100C73D4: using guessed type int dword_100C73D4;

//----- (10001820) --------------------------------------------------------
char *__cdecl sub_10001820(unsigned int a1)
{
  char *result; // eax@1
  int v2; // ebx@2
  int *v3; // esi@2
  void *v4; // edi@2
  unsigned int v5; // eax@5
  unsigned int v6; // eax@7
  unsigned int v7; // ecx@9
  int v8; // eax@9
  int v9; // eax@11
  unsigned int v10; // ecx@13
  unsigned int v11; // eax@13
  unsigned int v12; // eax@15
  unsigned int v13; // ecx@17
  unsigned int v14; // eax@17

  result = (char *)sub_10030040();
  if ( (unsigned int)&result[-dword_100C47D0] >= a1 )
  {
    dword_100C47D0 = (int)result;
    sub_10030060(0, 2, 0, 0);
    v2 = 0;
    v3 = dword_100C6DD4;
    v4 = &unk_100C27E8;
    do
    {
      if ( sub_1002FFC0(v2, (int)v4 - 24, 1) )
      {
        byte_100C7462[v2] = 0;
        result = (char *)memset((char *)v4 - 24, 0, 0x80u);
      }
      else
      {
        byte_100C7462[v2] = 1;
        v5 = *((_DWORD *)v4 - 1);
        if ( *(v3 - 384) > v5 )
          v5 = *(v3 - 384);
        *(v3 - 384) = v5;
        v6 = *((_DWORD *)v4 - 1);
        if ( *v3 > v6 )
          v6 = *v3;
        v7 = *(v3 - 383);
        *v3 = v6;
        v8 = *(_DWORD *)v4;
        if ( v7 > *(_DWORD *)v4 )
          v8 = v7;
        *(v3 - 383) = v8;
        v9 = *(_DWORD *)v4;
        if ( (unsigned int)v3[1] > *(_DWORD *)v4 )
          v9 = v3[1];
        v10 = *(v3 - 382);
        v3[1] = v9;
        v11 = *((_DWORD *)v4 + 1);
        if ( v10 > v11 )
          v11 = v10;
        *(v3 - 382) = v11;
        v12 = *((_DWORD *)v4 + 1);
        if ( v3[2] > v12 )
          v12 = v3[2];
        v13 = *(v3 - 381);
        v3[2] = v12;
        v14 = *((_DWORD *)v4 + 2);
        if ( v13 > v14 )
          v14 = v13;
        *(v3 - 381) = v14;
        result = (char *)*((_DWORD *)v4 + 2);
        if ( v3[3] > (unsigned int)result )
          result = (char *)v3[3];
        v3[3] = (int)result;
      }
      v4 = (char *)v4 + 128;
      ++v2;
      v3 += 6;
    }
    while ( (signed int)v4 < (signed int)&unk_100C47E8 );
  }
  return result;
}
// 100C47D0: using guessed type int dword_100C47D0;
// 100C6DD4: using guessed type int dword_100C6DD4[];

//----- (10001940) --------------------------------------------------------
void __cdecl sub_10001940(int a1, const char *a2, int a3)
{
  void *v3; // ecx@0
  char v4; // bl@1
  int v5; // eax@7

  v4 = 0;
  if ( a3 > 0 )
  {
    if ( byte_100C7576 && (unsigned __int8)a1 <= 1u )
    {
      v4 = 10;
      j_HWM_pvg_put_uart(a1, a2, a3);
    }
    if ( dword_100C871C )
      sub_100115C0((int)dword_100C8704, (int)a2, a3);
    v5 = sub_10014FA0(v3);
    sub_1000AA90(v5, a2, a3);
    if ( byte_100C750F )
    {
      sub_10001360((void *)a2, a3);
      sub_10030240(10);
    }
    else if ( v4 )
    {
      sub_10030240((unsigned __int8)v4);
    }
  }
}
// 10008130: using guessed type int __cdecl j_HWM_pvg_put_uart(_DWORD, _DWORD, _DWORD);
// 100C750F: using guessed type char byte_100C750F;
// 100C7574: using guessed type __int16 word_100C7574;
// 100C7576: using guessed type char byte_100C7576;
// 100C8704: using guessed type int dword_100C8704[];
// 100C871C: using guessed type int dword_100C871C;

//----- (100019E0) --------------------------------------------------------
void __cdecl sub_100019E0(int a1)
{
  void *v1; // ecx@1
  signed int v2; // ecx@3
  int v3; // ST40_4@17
  int v4; // eax@17
  int v5; // eax@17
  int v6; // eax@17
  int v7; // [sp+4h] [bp-80h]@1
  unsigned int v8; // [sp+8h] [bp-7Ch]@1
  int v9; // [sp+Ch] [bp-78h]@11
  unsigned int v10; // [sp+10h] [bp-74h]@12
  int v11; // [sp+14h] [bp-70h]@1
  char v12; // [sp+18h] [bp-6Ch]@1
  char v13; // [sp+1Ch] [bp-68h]@1

  v8 = 0;
  v7 = 0;
  memset(&v13, 0, 0x64u);
  v11 = 0;
  v12 = 0;
  switch ( sub_10014FA0(v1) )
  {
    case 1:
      v11 = 826558032;
      v12 = 0;
      break;
    case 2:
      v2 = 843335248;
      goto LABEL_10;
    case 4:
      v11 = 826558029;
      v12 = 0;
      break;
    case 64:
      v11 = 826496071;
      v12 = 0;
      break;
    case 128:
      v2 = 843273287;
      goto LABEL_10;
    case 16:
      v11 = 860050503;
      v12 = 0;
      break;
    case 32:
      v11 = 876827719;
      v12 = 0;
      break;
    default:
      v2 = 1062556236;
LABEL_10:
      v11 = v2;
      v12 = 0;
      break;
  }
  if ( sub_100303F0(2, (int)&v9, 8) )
  {
    v9 = 0;
    v10 = 0;
  }
  if ( sub_10015060((int)&v8) != 1 )
    v8 = 0;
  if ( sub_10015010((int)&v7) != 1 )
    v7 = 0;
  v3 = j_HWM_pvg_hsdb_get_lrus_online();
  v4 = sub_10030040();
  v5 = sprintf(
         &v13,
         "%s%-4s PwrCnt:%-3lu PwrHrs:%-4lu %02u/%02u/%02u %02u:%02u:%02u Tick:%-6lu Online:0x%08lx\r\n",
         "\x1B[2J",
         &v11,
         v9,
         v10 / 0xE10,
         (unsigned __int8)v8,
         BYTE1(v8),
         HIWORD(v8) % 100,
         (signed __int16)v7,
         BYTE2(v7),
         BYTE3(v7),
         v4,
         v3);
  sub_10001940(a1, &v13, v5);
  v6 = sprintf(&v13, "--------------------------------------------------------------------\r\n");
  sub_10001940(a1, &v13, v6);
}
// 100080D0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (10001C70) --------------------------------------------------------
void __cdecl sub_10001C70(_BYTE *a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  char v3; // al@2
  int v4; // esi@8
  int (__cdecl *v5)(_DWORD, char *); // esi@10
  unsigned int v6; // ebp@12
  char *v7; // esi@13
  unsigned int v8; // ecx@13
  char *v9; // edx@13
  int v10; // edi@17
  int v11; // ecx@18
  _BYTE *v12; // edx@18
  _BYTE *v13; // esi@18
  int v14; // ecx@20
  _BYTE *v15; // edx@20
  _BYTE *v16; // esi@20
  _BYTE *v17; // edx@22
  _BYTE *v18; // esi@22
  signed int v19; // ecx@24
  int v20; // eax@33
  char v21; // [sp+Bh] [bp-6Dh]@12
  char v22[100]; // [sp+10h] [bp-68h]@1

  v1 = sub_10015290((int)v22, a1, 100) - 1;
  v2 = 0;
  if ( v1 <= 0 )
    return;
  while ( 1 )
  {
    v3 = toupper((unsigned __int8)v22[v2]);
    v22[v2] = v3;
    if ( v3 == 10 || v3 == 13 )
      break;
    if ( ++v2 >= v1 )
      goto LABEL_7;
  }
  v1 = v2;
  v22[v2] = 0;
LABEL_7:
  if ( v1 <= 0 )
    return;
  v4 = sub_10014DE0(&byte_100C2783, 1u, (int)&unk_10046730, 16, 21, 21);
  if ( v4 == 21 )
    sub_10014D70("..\\lib\\adl\\iop_cdu_dbg_frmt.c", 1792, 1, 0);
  v5 = (int (__cdecl *)(_DWORD, char *))dword_10046734[4 * v4];
  if ( v5 )
  {
    if ( (unsigned __int8)v5(0, v22) == 1 )
      return;
  }
  v21 = 21;
  v6 = 0;
  do
  {
    v7 = (&off_10046438)[v6];
    v8 = v1;
    v9 = v22;
    if ( (unsigned int)v1 < 4 )
    {
LABEL_16:
      if ( !v8 )
        goto LABEL_26;
    }
    else
    {
      while ( *(_DWORD *)v7 == *(_DWORD *)v9 )
      {
        v8 -= 4;
        v9 += 4;
        v7 += 4;
        if ( v8 < 4 )
          goto LABEL_16;
      }
    }
    v10 = (unsigned __int8)*v7 - (unsigned __int8)*v9;
    if ( (unsigned __int8)*v7 == (unsigned __int8)*v9 )
    {
      v11 = v8 - 1;
      v12 = v9 + 1;
      v13 = v7 + 1;
      if ( !v11
        || (v10 = *v13 - *v12, *v13 == *v12)
        && ((v14 = v11 - 1, v15 = v12 + 1, v16 = v13 + 1, !v14)
         || (v10 = *v16 - *v15, *v16 == *v15)
         && ((v17 = v15 + 1, v18 = v16 + 1, v14 == 1) || (v10 = *v18 - *v17, *v18 == *v17))) )
      {
LABEL_26:
        v19 = 0;
        goto LABEL_27;
      }
    }
    v19 = 1;
    if ( v10 <= 0 )
      v19 = -1;
LABEL_27:
    if ( !v19 )
    {
      if ( v21 != 21 )
        goto LABEL_33;
      v21 = byte_1004645A[v6];
    }
    v6 += 36;
  }
  while ( v6 < 0x2F4 );
  if ( v21 != 21 )
  {
    sub_10001310(v21);
    return;
  }
LABEL_33:
  v20 = sub_100153B0(v22, 0x64u, "Command \"%s\" not found\r\n", a1);
  sub_10001940(0, v22, v20);
}
// 10046438: using guessed type char *off_10046438;
// 10046734: using guessed type int dword_10046734[];
// 100C2783: using guessed type char byte_100C2783;
// 10001C70: using guessed type char var_68[100];

//----- (10001E50) --------------------------------------------------------
void __cdecl sub_10001E50(int a1, int a2)
{
  int v2; // [sp+4h] [bp-6Ch]@1
  char v3; // [sp+8h] [bp-68h]@1

  memset(&v3, 0, 0x64u);
  v2 = 0;
  if ( sub_1000D660(a1, a2, &v3, (unsigned __int16 *)&v2) == 1 )
  {
    byte_100C750F = 1;
    sub_10001C70(&v3);
  }
}
// 100C750F: using guessed type char byte_100C750F;

//----- (10001EC0) --------------------------------------------------------
void __cdecl sub_10001EC0(const char *a1, int a2)
{
  sub_10001940((unsigned __int8)byte_100C750E, a1, a2);
}
// 100C750E: using guessed type char byte_100C750E;

//----- (10001EE0) --------------------------------------------------------
char __cdecl sub_10001EE0(int a1, int a2)
{
  unsigned int v2; // edi@1
  unsigned int v3; // eax@1
  char *v4; // esi@1
  char *v5; // ebx@1
  char *v6; // ebp@1
  bool v7; // zf@6
  signed int v8; // edx@8
  int *v9; // ecx@8
  int *v10; // eax@8
  unsigned int v11; // eax@11
  int v12; // eax@19
  int v13; // edx@20
  int v14; // eax@20
  int v15; // ecx@20
  int v16; // edx@20
  int v17; // eax@20
  bool v18; // sf@21
  unsigned __int8 v19; // of@21
  char *v20; // esi@23
  char *v22; // [sp+10h] [bp-604h]@1
  char *v23; // [sp+14h] [bp-600h]@1
  char *v24; // [sp+18h] [bp-5FCh]@1
  char *v25; // [sp+1Ch] [bp-5F8h]@1
  char *v26; // [sp+20h] [bp-5F4h]@1
  char *v27; // [sp+24h] [bp-5F0h]@1
  char *v28; // [sp+28h] [bp-5ECh]@1
  char *v29; // [sp+2Ch] [bp-5E8h]@1
  char *v30; // [sp+30h] [bp-5E4h]@1
  char *v31; // [sp+34h] [bp-5E0h]@1
  char *v32; // [sp+38h] [bp-5DCh]@1
  char *v33; // [sp+3Ch] [bp-5D8h]@1
  char *v34; // [sp+40h] [bp-5D4h]@1
  char *v35; // [sp+44h] [bp-5D0h]@1
  char *v36; // [sp+48h] [bp-5CCh]@1
  char *v37; // [sp+4Ch] [bp-5C8h]@1
  char *v38; // [sp+50h] [bp-5C4h]@1
  char *v39; // [sp+54h] [bp-5C0h]@1
  char *v40; // [sp+58h] [bp-5BCh]@1
  char *v41; // [sp+5Ch] [bp-5B8h]@1
  char *v42; // [sp+60h] [bp-5B4h]@1
  char *v43; // [sp+64h] [bp-5B0h]@1
  char *v44; // [sp+68h] [bp-5ACh]@1
  signed int v45; // [sp+6Ch] [bp-5A8h]@8
  unsigned int v46; // [sp+70h] [bp-5A4h]@1
  int v47; // [sp+74h] [bp-5A0h]@1
  int *v48; // [sp+78h] [bp-59Ch]@8
  int *v49; // [sp+7Ch] [bp-598h]@8
  int v50; // [sp+80h] [bp-594h]@1
  int v51; // [sp+88h] [bp-58Ch]@24
  __int16 v52; // [sp+8Ch] [bp-588h]@24
  char v53[15]; // [sp+90h] [bp-584h]@1
  char v54; // [sp+9Fh] [bp-575h]@1
  char v55; // [sp+A0h] [bp-574h]@1
  char v56; // [sp+A2h] [bp-572h]@1
  char v57; // [sp+A4h] [bp-570h]@1
  char v58; // [sp+A6h] [bp-56Eh]@1
  char v59; // [sp+A8h] [bp-56Ch]@1
  char v60; // [sp+AAh] [bp-56Ah]@1
  char v61; // [sp+ACh] [bp-568h]@1
  char v62; // [sp+AEh] [bp-566h]@1
  char v63; // [sp+B0h] [bp-564h]@1
  char v64; // [sp+B2h] [bp-562h]@1
  char v65; // [sp+B3h] [bp-561h]@1
  char v66; // [sp+B4h] [bp-560h]@1
  char v67; // [sp+B8h] [bp-55Ch]@1
  char v68; // [sp+BCh] [bp-558h]@1
  char v69; // [sp+C0h] [bp-554h]@1
  char v70; // [sp+C4h] [bp-550h]@1
  char v71; // [sp+C8h] [bp-54Ch]@1
  char v72; // [sp+CCh] [bp-548h]@1
  char v73; // [sp+D0h] [bp-544h]@1
  char v74; // [sp+D4h] [bp-540h]@1
  char v75; // [sp+D8h] [bp-53Ch]@1
  char v76; // [sp+DCh] [bp-538h]@1
  char v77; // [sp+E0h] [bp-534h]@1
  char v78; // [sp+E4h] [bp-530h]@1

  v2 = dword_100C73D8;
  v47 = 0;
  v36 = &v54;
  v34 = &v64;
  v32 = &v78;
  v30 = &v65;
  v28 = &v77;
  v26 = &v76;
  v24 = &v75;
  v22 = &v74;
  v37 = &v73;
  v42 = &v72;
  v35 = &v71;
  v40 = &v66;
  v33 = &v63;
  v38 = &v62;
  v31 = &v61;
  v41 = &v60;
  v29 = &v59;
  v43 = &v58;
  v27 = &v57;
  v50 = sub_10030040();
  v39 = &v56;
  v25 = &v70;
  v3 = 0;
  v46 = 0;
  v4 = v53;
  v44 = &v69;
  v23 = &v68;
  v5 = &v67;
  v6 = &v55;
  do
  {
    if ( v3 >= 0x10 )
      goto LABEL_24;
    if ( v2 < 0x40 )
    {
      if ( v2 )
        goto LABEL_18;
    }
    else
    {
      v2 = 0;
    }
    sub_10001820(0x1F4u);
    v7 = (_WORD)dword_100C47D0 == (_WORD)dword_100C73DC;
    word_100C73E0 = dword_100C47D0 - dword_100C73DC;
    dword_100C73DC = dword_100C47D0;
    if ( v7 )
      word_100C73E0 = 1;
    v8 = 0;
    v9 = (int *)&unk_100C6DE8;
    v10 = dword_100C27E0;
    v45 = 0;
    v48 = (int *)&unk_100C6DE8;
    v49 = dword_100C27E0;
    do
    {
      if ( !byte_100C7462[v8] )
        goto LABEL_15;
      if ( *v9 == *v10 )
      {
        v8 = v45;
LABEL_15:
        byte_100C7462[v8] = 0;
        goto LABEL_16;
      }
      v11 = 10000 * (v10[5] - *(v9 - 1)) / (unsigned int)(unsigned __int16)word_100C73E0;
      word_100C73E2[v45] = v11;
      if ( (unsigned __int16)v11 > 0x7FFFu )
        word_100C73E2[v45] = 0;
      v10 = v49;
      v9 = v48;
      *(v48 - 1) = v49[5];
      *v48 = *v49;
      v8 = v45;
LABEL_16:
      ++v8;
      v10 += 32;
      v9 += 6;
      v45 = v8;
      v49 = v10;
      v48 = v9;
    }
    while ( v8 < 64 );
    v3 = v46;
LABEL_18:
    if ( byte_100C7462[v2] )
    {
      *(_WORD *)v6 = word_100C73E2[v2];
      v13 = dword_100C6DD8[6 * v2];
      *(_DWORD *)v5 = dword_100C6DD4[6 * v2];
      *(_DWORD *)v23 = v13;
      *(_DWORD *)v44 = dword_100C6DDC[6 * v2];
      *(_DWORD *)v25 = dword_100C6DE0[6 * v2];
      v14 = 6 * v2;
      dword_100C6DD4[v14] = 0;
      dword_100C6DD8[v14] = 0;
      dword_100C6DDC[v14] = 0;
      dword_100C6DE0[v14] = 0;
      *(_WORD *)v39 = word_100C27D0[64 * v2];
      *(_WORD *)v27 = word_100C27D2[64 * v2];
      *(_WORD *)v43 = word_100C27D4[64 * v2];
      *(_WORD *)v29 = word_100C27D6[64 * v2];
      *(_WORD *)v41 = word_100C27D8[64 * v2];
      *(_WORD *)v31 = word_100C27DA[64 * v2];
      *(_WORD *)v38 = word_100C27DC[64 * v2];
      *(_WORD *)v33 = word_100C27DE[64 * v2];
      *(_DWORD *)v40 = dword_100C27E0[32 * v2];
      *(_DWORD *)v35 = dword_100C27F4[32 * v2];
      *(_DWORD *)v42 = dword_100C27F8[32 * v2];
      *(_DWORD *)v37 = dword_100C27FC[32 * v2];
      *(_DWORD *)v22 = dword_100C2800[32 * v2];
      *(_DWORD *)v24 = dword_100C2804[32 * v2];
      *(_DWORD *)v26 = dword_100C2810[32 * v2];
      *(_DWORD *)v28 = dword_100C2814[32 * v2];
      *v30 = byte_100C281C[128 * v2];
      *(_DWORD *)v32 = dword_100C2820[32 * v2];
      *v34 = byte_100C2824[128 * v2];
      v15 = dword_100C282C[32 * v2];
      *(_DWORD *)v4 = dword_100C2828[32 * v2];
      v16 = dword_100C2830[32 * v2];
      v17 = dword_100C2834[32 * v2];
      *((_DWORD *)v4 + 1) = v15;
      *((_DWORD *)v4 + 2) = v16;
      *((_DWORD *)v4 + 3) = v17;
      v12 = v46;
      *v36 = 0;
    }
    else
    {
      v23 -= 88;
      v44 -= 88;
      v25 -= 88;
      v39 -= 88;
      v27 -= 88;
      v43 -= 88;
      v29 -= 88;
      v41 -= 88;
      v31 -= 88;
      v38 -= 88;
      v33 -= 88;
      v40 -= 88;
      v35 -= 88;
      v42 -= 88;
      v37 -= 88;
      v22 -= 88;
      v24 -= 88;
      v26 -= 88;
      v28 -= 88;
      v30 -= 88;
      v32 -= 88;
      v34 -= 88;
      v12 = v3 - 1;
      v6 -= 88;
      v5 -= 88;
      v4 -= 88;
      v36 -= 88;
    }
    v23 += 88;
    v44 += 88;
    v25 += 88;
    v39 += 88;
    v27 += 88;
    v43 += 88;
    v29 += 88;
    v41 += 88;
    v31 += 88;
    v38 += 88;
    v33 += 88;
    v40 += 88;
    v35 += 88;
    v42 += 88;
    v37 += 88;
    v22 += 88;
    v24 += 88;
    v26 += 88;
    v28 += 88;
    v30 += 88;
    v32 += 88;
    v34 += 88;
    v36 += 88;
    v6 += 88;
    v5 += 88;
    v4 += 88;
    v3 = v12 + 1;
    ++v2;
    v19 = __OFSUB__(v47 + 1, 64);
    v7 = v47 == 63;
    v18 = v47 - 63 < 0;
    v46 = v3;
    ++v47;
  }
  while ( (unsigned __int8)(v18 ^ v19) | v7 );
  if ( v3 < 0x10 )
  {
    v20 = &v53[88 * v3];
    memset(&v53[88 * v3], 0, 88 * (16 - v3));
    sub_10015290((int)v20, "telnet running", 16);
  }
LABEL_24:
  v51 = dword_100C73DC;
  v52 = word_100C73E0;
  dword_100C73D8 = v2;
  return sub_1000C7A0(a1, 1, a2, &v51, v50);
}
// 100C27D0: using guessed type __int16 word_100C27D0[];
// 100C27D2: using guessed type __int16 word_100C27D2[];
// 100C27D4: using guessed type __int16 word_100C27D4[];
// 100C27D6: using guessed type __int16 word_100C27D6[];
// 100C27D8: using guessed type __int16 word_100C27D8[];
// 100C27DA: using guessed type __int16 word_100C27DA[];
// 100C27DC: using guessed type __int16 word_100C27DC[];
// 100C27DE: using guessed type __int16 word_100C27DE[];
// 100C27E0: using guessed type int dword_100C27E0[];
// 100C27F4: using guessed type int dword_100C27F4[];
// 100C27F8: using guessed type int dword_100C27F8[];
// 100C27FC: using guessed type int dword_100C27FC[];
// 100C2800: using guessed type int dword_100C2800[];
// 100C2804: using guessed type int dword_100C2804[];
// 100C2810: using guessed type int dword_100C2810[];
// 100C2814: using guessed type int dword_100C2814[];
// 100C2820: using guessed type int dword_100C2820[];
// 100C2828: using guessed type int dword_100C2828[];
// 100C282C: using guessed type int dword_100C282C[];
// 100C2830: using guessed type int dword_100C2830[];
// 100C2834: using guessed type int dword_100C2834[];
// 100C47D0: using guessed type int dword_100C47D0;
// 100C6DD4: using guessed type int dword_100C6DD4[];
// 100C6DD8: using guessed type int dword_100C6DD8[];
// 100C6DDC: using guessed type int dword_100C6DDC[];
// 100C6DE0: using guessed type int dword_100C6DE0[];
// 100C73D8: using guessed type int dword_100C73D8;
// 100C73DC: using guessed type int dword_100C73DC;
// 100C73E0: using guessed type __int16 word_100C73E0;
// 100C73E2: using guessed type __int16 word_100C73E2[];
// 10001EE0: using guessed type char var_584[15];

//----- (10002450) --------------------------------------------------------
char __cdecl sub_10002450(int a1)
{
  int v1; // eax@1
  char v3; // [sp+0h] [bp-68h]@1

  memset(&v3, 0, 0x64u);
  v1 = sprintf(&v3, "GENERATING ASSERT...\r\n");
  sub_10001940(a1, &v3, v1);
  return sub_10014D70("..\\lib\\adl\\iop_cdu_dbg_frmt.c", 2847, 1, 0);
}

//----- (100024C0) --------------------------------------------------------
void __cdecl sub_100024C0(int a1)
{
  int v1; // eax@1
  char v2; // [sp+4h] [bp-68h]@1

  memset(&v2, 0, 0x64u);
  v1 = sprintf(&v2, "GENERATING AN EXCEPTION...\r\n");
  sub_10001940(a1, &v2, v1);
  v0 = 0;
}

//----- (10002520) --------------------------------------------------------
void __cdecl sub_10002520(int a1)
{
  int v1; // eax@1
  char v2; // [sp+0h] [bp-68h]@1

  memset(&v2, 0, 0x64u);
  v1 = sprintf(&v2, "GENERATING A FLOATING POINT EXCEPTION...\r\n");
  sub_10001940(a1, &v2, v1);
}

//----- (10002580) --------------------------------------------------------
void __usercall sub_10002580(unsigned __int8 a1@<cl>, _BYTE *a2@<edi>, _WORD *a3@<esi>, signed int a4)
{
  unsigned __int8 v4; // bl@3

  if ( *a3 >= a4 )
  {
    *a3 = 0;
    *a2 = 0;
  }
  v4 = toupper(a1);
  if ( isalnum(v4) )
  {
    a2[(*a3)++] = v4;
  }
  else
  {
    a2[*a3] = 0;
    sub_10001C70(a2);
    *a3 = 0;
    *a2 = 0;
  }
}

//----- (100025E0) --------------------------------------------------------
char __cdecl sub_100025E0(int a1, _BYTE *a2)
{
  char v2; // bl@1
  int v3; // eax@2
  char result; // al@2
  int v5; // eax@3
  int v6; // eax@4
  int v7; // eax@5
  int v8; // eax@6
  int v9; // eax@7
  int v10; // eax@7
  char v11; // [sp+4h] [bp-68h]@1

  v2 = 0;
  memset(&v11, 0, 0x64u);
  switch ( *a2 )
  {
    case 0x42:
    case 0x62:
      v3 = sprintf(&v11, "Capturing when blink ON\r\n");
      sub_10001940(a1, &v11, v3);
      byte_100C2781 = 1;
      result = 1;
      break;
    case 0x4F:
    case 0x6F:
      v5 = sprintf(&v11, "Capturing when blink OFF\r\n");
      sub_10001940(a1, &v11, v5);
      result = 1;
      byte_100C2781 = 2;
      break;
    case 0x49:
    case 0x69:
      v6 = sprintf(&v11, "Capturing immediately\r\n");
      sub_10001940(a1, &v11, v6);
      result = 1;
      byte_100C2781 = 0;
      break;
    case 0x30:
      v7 = sprintf(&v11, "File Flushing Is Off\r\n");
      sub_10001940(a1, &v11, v7);
      result = 1;
      byte_100C74A4 = 0;
      break;
    case 0x31:
      v8 = sprintf(&v11, "File Flushing Is On\r\n");
      sub_10001940(a1, &v11, v8);
      byte_100C74A4 = 1;
      result = 1;
      break;
    case 0x46:
    case 0x66:
      v9 = sprintf(&v11, "Flushing file buffers please wait.\r\n");
      sub_10001940(a1, &v11, v9);
      j_FIL_vfs_sync_all();
      v10 = sprintf(&v11, "Card can now be removed.\r\n");
      sub_10001940(a1, &v11, v10);
      v2 = 1;
      goto LABEL_8;
    default:
LABEL_8:
      result = v2;
      break;
  }
  return result;
}
// 100309A0: using guessed type int j_FIL_vfs_sync_all(void);
// 100C2781: using guessed type char byte_100C2781;
// 100C74A4: using guessed type char byte_100C74A4;

//----- (10002810) --------------------------------------------------------
char __cdecl sub_10002810(int a1, int a2)
{
  char result; // al@1
  _BYTE *v3; // ebx@2
  __int32 v4; // ebp@2
  int v5; // edi@9
  const char *v6; // eax@13
  const char *v7; // esi@13
  int v8; // eax@13
  double v9; // ST30_8@14
  int v10; // eax@14
  int v11; // eax@14
  double v12; // ST30_8@21
  int v13; // eax@21
  int v14; // eax@21
  bool v15; // [sp+1Bh] [bp-75h]@2
  int v16; // [sp+1Ch] [bp-74h]@2
  int v17; // [sp+20h] [bp-70h]@2
  char v18; // [sp+28h] [bp-68h]@13

  result = 0;
  if ( *(_BYTE *)a2 == 69 )
  {
    v3 = (_BYTE *)(a2 + 1);
    v4 = j__atol((const char *)(a2 + 1));
    v16 = sub_10030040();
    v17 = sub_10030090();
    v15 = memcmp((const void *)a2, "EA", 3u) == 0;
    if ( !v15 )
    {
      if ( !isdigit(*v3) )
        return 0;
      if ( v4 )
      {
        if ( v4 >= 43 )
          return 0;
      }
      else if ( *v3 != 48 )
      {
        return 0;
      }
    }
    v5 = 0;
    if ( v15 )
    {
      v4 = 0;
      goto LABEL_12;
    }
    if ( v4 >= 43 )
    {
      v7 = (const char *)v16;
LABEL_21:
      v12 = (double)(unsigned int)(sub_10030090() - v17) / 1000.0;
      v13 = sub_10030040();
      v14 = sub_100153B0(
              &v18,
              0x64u,
              "Registry %s exported successfully.\r\n   Took %i ms total %.2fms cpu time\r\n",
              v7,
              v13 - v16,
              v12);
      sub_10001940(a1, &v18, v14);
    }
    else
    {
LABEL_12:
      while ( v5 >= 0 )
      {
        v6 = sub_100303B0(v4);
        v7 = v6;
        v8 = sub_100153B0(&v18, 0x64u, "Exporting %s\r\n", v6);
        sub_10001940(a1, &v18, v8);
        sub_100153B0(&v18, 0x64u, "reg_%s.xml", v7);
        v5 = j_reg_bkup_to_xml_arch(v4, "/mnt/card0/reg_export.zip");
        if ( v5 < 0 )
        {
          v9 = (double)(unsigned int)(sub_10030090() - v17) / 1000.0;
          v10 = sub_10030040();
          v11 = sub_100153B0(&v18, 0x64u, "Registry %s failed exporting err %i.\r\n", v7, v5, v10 - v16, v9);
          sub_10001940(a1, &v18, v11);
        }
        if ( v15 && ++v4 < 43 )
          continue;
        if ( v5 )
          break;
        if ( v15 )
          v7 = "ALL";
        goto LABEL_21;
      }
    }
    result = 1;
  }
  return result;
}
// 10030360: using guessed type int __cdecl j_reg_bkup_to_xml_arch(_DWORD, _DWORD);

//----- (10002A10) --------------------------------------------------------
void __cdecl sub_10002A10(int a1)
{
  int v1; // eax@1
  int v2; // esi@1
  unsigned int v3; // ebx@1
  unsigned int v4; // eax@2
  unsigned int v5; // edi@2
  int v6; // ST54_4@4
  int v7; // edi@5
  int v8; // eax@5
  float v9; // ST54_4@5
  unsigned __int64 v10; // st6@5
  float v11; // ST54_4@5
  double v12; // st5@5
  int v13; // ST54_4@5
  int v14; // eax@5
  int v15; // eax@5
  int v16; // eax@5
  int v17; // eax@5
  int v18; // ecx@5
  int v19; // edx@5
  int v20; // eax@7
  __int64 *v21; // [sp+3Ch] [bp-DCh]@4
  unsigned __int64 v22; // [sp+40h] [bp-D8h]@4
  int v23; // [sp+48h] [bp-D0h]@5
  int v24; // [sp+4Ch] [bp-CCh]@5
  unsigned __int64 v25; // [sp+50h] [bp-C8h]@5
  int v26; // [sp+58h] [bp-C0h]@5
  int v27; // [sp+5Ch] [bp-BCh]@5
  __int64 v28; // [sp+60h] [bp-B8h]@5
  __int64 v29; // [sp+68h] [bp-B0h]@5
  unsigned __int64 v30; // [sp+70h] [bp-A8h]@5
  __int64 v31; // [sp+78h] [bp-A0h]@5
  unsigned __int64 v32; // [sp+80h] [bp-98h]@5
  __int64 v33; // [sp+88h] [bp-90h]@5
  unsigned __int64 v34; // [sp+90h] [bp-88h]@5
  unsigned __int64 v35; // [sp+98h] [bp-80h]@5
  double v36; // [sp+A0h] [bp-78h]@5
  char v37; // [sp+A8h] [bp-70h]@1

  memset(&v37, 0, 0x64u);
  sub_100019E0(a1);
  v1 = sprintf(&v37, "BLOCK DEVICE STATS\r\n");
  sub_10001940(a1, &v37, v1);
  v2 = 0;
  v3 = 0;
  do
  {
    v4 = j_FIL_vfs_open(*(_DWORD *)off_100469EC[v2], 4, 0);
    v5 = v4;
    if ( v4 < 0xFFFFFFC2 )
    {
      if ( v4 )
      {
        v21 = (__int64 *)&v22;
        v6 = j_FIL_vfs_ioctl(v4, 107, &v21, 4);
        sub_10030770(v5);
        if ( !v6 )
        {
          v7 = sub_10030040();
          v32 = v22 & 0x7FFFFFFFFFFFFFFFi64;
          v34 = v22 & 0x8000000000000000ui64;
          v30 = v25 & 0x7FFFFFFFFFFFFFFFi64;
          v8 = dword_100C872C[v2];
          v35 = v25 & 0x8000000000000000ui64;
          LODWORD(v28) = dword_100C8728[v2];
          v9 = (double)v22 * 0.0009765625;
          *(double *)&v10 = v9;
          LODWORD(v33) = 0;
          HIDWORD(v28) = v8 & 0x7FFFFFFF;
          HIDWORD(v33) = v8 & 0x80000000;
          v11 = (double)v25 * 0.0009765625;
          v12 = v11;
          v13 = v7 - dword_100C8768[v3];
          v36 = v12;
          v14 = sub_100153B0(
                  &v37,
                  0x64u,
                  "\r\n%s\r\nREAD  %10.2fKBys %uerrs %6urqsts %.2fKBy/s\r\n",
                  off_100469E8[v2],
                  (_DWORD)v10,
                  (_DWORD)(v10 >> 32),
                  v23,
                  v24,
                  (*(double *)&v10 - 0.0009765625 * (double)__PAIR__((unsigned int)v8, dword_100C8728[v2]))
                / (double)(unsigned int)v13
                * 1000.0);
          sub_10001940(a1, &v37, v14);
          v15 = dword_100C874C[v2];
          LODWORD(v29) = dword_100C8748[v2];
          HIDWORD(v29) = v15 & 0x7FFFFFFF;
          HIDWORD(v31) = v15 & 0x80000000;
          LODWORD(v31) = 0;
          v16 = sub_100153B0(
                  &v37,
                  0x64u,
                  "WRITE %10.2fKBys %uerrs %6urqsts %.2fKBy/s\r\n",
                  v36,
                  v26,
                  v27,
                  (v36 - (double)__PAIR__((unsigned int)v15, dword_100C8748[v2]) * 0.0009765625)
                / (double)(unsigned int)(v7 - dword_100C8768[v3])
                * 1000.0);
          sub_10001940(a1, &v37, v16);
          v17 = HIDWORD(v22);
          v18 = v25;
          dword_100C8728[v2] = v22;
          v19 = HIDWORD(v25);
          dword_100C872C[v2] = v17;
          dword_100C8748[v2] = v18;
          dword_100C874C[v2] = v19;
          dword_100C8768[v3] = v7;
        }
      }
    }
    ++v3;
    v2 += 2;
  }
  while ( v3 < 4 );
  v20 = sprintf(&v37, "--------------------------------------------------------------------\r\n");
  sub_10001940(a1, &v37, v20);
}
// F: found interdependent unknown calls
// 100307D0: using guessed type int __cdecl j_FIL_vfs_ioctl(_DWORD, _DWORD, _DWORD, _DWORD);
// 10030850: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 100469E8: using guessed type char *off_100469E8[3];
// 100469EC: using guessed type char *off_100469EC[2];
// 100C8728: using guessed type int dword_100C8728[];
// 100C872C: using guessed type int dword_100C872C[];
// 100C8748: using guessed type int dword_100C8748[];
// 100C874C: using guessed type int dword_100C874C[];
// 100C8768: using guessed type int dword_100C8768[];

//----- (10002D40) --------------------------------------------------------
void __cdecl sub_10002D40(int a1)
{
  char v1; // [sp+0h] [bp-68h]@1

  sub_10001940(a1, &v1, 0);
}

//----- (10002D80) --------------------------------------------------------
void __cdecl sub_10002D80(int a1)
{
  int v1; // eax@7
  int v2; // ebx@7
  int v3; // eax@8
  int v4; // edi@9
  unsigned int v5; // ebx@9
  unsigned int v6; // ebp@10
  float v7; // ST64_4@10
  int v8; // eax@10
  double v9; // st6@10
  int v10; // ecx@10
  unsigned int v11; // ebx@10
  int v12; // edx@10
  int v13; // eax@10
  double v14; // st7@17
  unsigned __int16 v15; // bx@20
  unsigned __int16 v16; // di@23
  int v17; // eax@25
  int v18; // eax@25
  int v19; // eax@25
  int v20; // eax@25
  int v21; // eax@25
  int v22; // eax@25
  int v23; // eax@25
  int v24; // eax@25
  int v25; // eax@25
  int v26; // eax@25
  int v27; // eax@25
  int v28; // eax@25
  int v29; // eax@25
  int v30; // eax@25
  int v31; // eax@25
  int v32; // eax@25
  int v33; // eax@25
  int v34; // eax@25
  int v35; // eax@25
  int v36; // eax@25
  int v37; // eax@25
  int v38; // eax@25
  float v39; // [sp+48h] [bp-13Ch]@17
  int v40; // [sp+4Ch] [bp-138h]@7
  float v41; // [sp+4Ch] [bp-138h]@19
  float v42; // [sp+50h] [bp-134h]@0
  float v43; // [sp+54h] [bp-130h]@0
  float v44; // [sp+58h] [bp-12Ch]@0
  float v45; // [sp+5Ch] [bp-128h]@0
  unsigned int v46; // [sp+60h] [bp-124h]@1
  int v47; // [sp+64h] [bp-120h]@25
  int v48; // [sp+68h] [bp-11Ch]@25
  int v49; // [sp+6Ch] [bp-118h]@25
  __int64 v50; // [sp+70h] [bp-114h]@25
  int v51; // [sp+78h] [bp-10Ch]@25
  __int64 v52; // [sp+7Ch] [bp-108h]@25
  unsigned int v53; // [sp+84h] [bp-100h]@10
  __int64 v54; // [sp+88h] [bp-FCh]@25
  __int64 v55; // [sp+90h] [bp-F4h]@25
  __int64 v56; // [sp+98h] [bp-ECh]@25
  int v57; // [sp+A0h] [bp-E4h]@25
  int v58; // [sp+A4h] [bp-E0h]@25
  int v59; // [sp+A8h] [bp-DCh]@25
  __int64 v60; // [sp+B0h] [bp-D4h]@10
  unsigned __int64 v61; // [sp+B8h] [bp-CCh]@10
  char v62; // [sp+C0h] [bp-C4h]@1
  char v63; // [sp+108h] [bp-7Ch]@1
  char v64; // [sp+16Ch] [bp-18h]@2

  memset(&v63, 0, 0x64u);
  memset(&v46, 0, 0x60u);
  memset(&v62, 0, 0x46u);
  sub_100019E0(a1);
  switch ( byte_100C74A6 )
  {
    case 0:
      sprintf(&v64, "PORT 1");
      break;
    case 1:
      sprintf(&v64, "PORT 2");
      break;
    case 2:
      sprintf(&v64, "PORT 3");
      break;
    case 3:
      sprintf(&v64, "PORT 4");
      break;
    default:
      sub_10014D70("..\\lib\\adl\\iop_cdu_dbg_frmt.c", 4900, 1, 0);
      break;
  }
  v1 = sprintf(&v63, "ETHR STATS (%s):  -TYPE # OF DESIRED PORT-\r\n", &v64);
  sub_10001940(a1, &v63, v1);
  v2 = sub_10030040();
  v40 = v2;
  if ( j_HWM_pvg_ethr_get_stats((unsigned __int8)byte_100C74A6, &v46) )
  {
    v3 = sprintf(&v63, "NONE AVAILABLE\r\n");
    sub_10001940(a1, &v63, v3);
  }
  else
  {
    v4 = 9 * (unsigned __int8)byte_100C74A6;
    v5 = v2 - dword_100C7578[v4];
    if ( v5 )
    {
      v45 = (double)(unsigned int)(1000 * (v60 - __PAIR__(dword_100C7588[v4], dword_100C7584[v4])) / v5) / 1000.0;
      v44 = (double)(unsigned int)(1000 * (v61 - __PAIR__(dword_100C7590[v4], dword_100C758C[v4])) / v5) / 1000.0;
      v6 = v53;
      v7 = (double)v5;
      v8 = v46;
      v42 = (double)(1000 * (v53 - dword_100C7580[v4])) / v7;
      v9 = (double)(1000 * (v46 - dword_100C757C[v4]));
      v10 = HIDWORD(v60);
      v11 = v60;
      dword_100C7578[v4] = v40;
      v12 = HIDWORD(v61);
      dword_100C7580[v4] = v6;
      dword_100C757C[v4] = v8;
      v13 = v61;
      dword_100C7584[v4] = v11;
      dword_100C7588[v4] = v10;
      dword_100C758C[v4] = v13;
      dword_100C7590[v4] = v12;
      v43 = v9 / v7;
      if ( v45 > (double)flt_100C7594[v4] )
        flt_100C7594[v4] = v45;
      if ( v44 > (double)flt_100C7598[v4] )
        flt_100C7598[v4] = v44;
    }
    else
    {
      v11 = v60;
      v6 = v53;
      v10 = HIDWORD(v60);
    }
    if ( v10 || v11 > 0xFFFFFFFF )
    {
      v39 = (double)(unsigned int)(__PAIR__((unsigned int)v10, v11) / 0xF4240);
      v14 = (double)(unsigned int)(v61 / 0xF4240);
      v10 = HIDWORD(v60);
    }
    else
    {
      v39 = (double)v11 / 1000000.0;
      v14 = (double)(unsigned int)v61 / 1000000.0;
    }
    v41 = v14;
    if ( v6 )
      v15 = __PAIR__((unsigned int)v10, v11) / v6;
    else
      v15 = 0;
    if ( v46 )
      v16 = v61 / v46;
    else
      v16 = 0;
    sprintf(&v62, "%%-%ds\r\n", 20);
    v17 = sprintf(&v63, &v62, "Good Frames");
    sub_10001940(a1, &v63, v17);
    sub_100153B0(&v62, 0x46u, "%%-%ds%%-%ds%%-%ds%%-%ds%%-%ds%%-%ds%%-%ds%%-%ds\r\n", 10, 10, 10, 10, 10, 10, 10, 10);
    v18 = sub_100153B0(
            &v63,
            0x64u,
            &v62,
            "RxKBy/s",
            "Max",
            "TxKBy/s",
            "Max",
            "RX MByte",
            "TX MByte",
            "Avg RX Sz",
            "Avg TX Sz");
    sub_10001940(a1, &v63, v18);
    sub_100153B0(
      &v62,
      0x46u,
      "%%-%d.03f%%-%d.03f%%-%d.03f%%-%d.03f%%-%d.%df%%-%d.%df%%-%dlu%%-%dlu\r\n",
      10,
      10,
      10,
      10,
      10,
      7 - (signed int)log10(v39 + 1.0),
      10,
      7 - (signed int)log10(v41 + 1.0),
      10,
      10);
    v19 = sub_100153B0(
            &v63,
            0x64u,
            &v62,
            v45,
            flt_100C7594[9 * (unsigned __int8)byte_100C74A6],
            v44,
            flt_100C7598[9 * (unsigned __int8)byte_100C74A6],
            v39,
            v41,
            v15,
            v16);
    sub_10001940(a1, &v63, v19);
    sprintf(&v62, "%%-%ds%%-%ds%%-%ds%%-%ds\r\n", 10, 10, 10, 10);
    v20 = sprintf(&v63, &v62, "RX", "TX", "RX/s", "TX/s");
    sub_10001940(a1, &v63, v20);
    sprintf(&v62, "%%-%dlu%%-%dlu%%-%d.01f%%-%d.01f\r\n", 10, 10, 10, 10);
    v21 = sprintf(&v63, &v62, v53, v46, v42, v43);
    sub_10001940(a1, &v63, v21);
    v22 = sprintf(&v63, "--------------------------------------------------------------------\r\n");
    sub_10001940(a1, &v63, v22);
    sprintf(&v62, "%%-%ds\r\n", 20);
    v23 = sprintf(&v63, &v62, "RX Errors");
    sub_10001940(a1, &v63, v23);
    sprintf(&v62, "%%-%ds%%-%ds%%-%ds%%-%ds%%-%ds%%-%ds\r\n", 10, 10, 10, 10, 10, 10);
    v24 = sprintf(&v63, &v62, "CRC", "Align", "Resource", "Overrun", "Collision", "Shrt Frame");
    sub_10001940(a1, &v63, v24);
    sprintf(&v62, "%%-%dlu%%-%dlu%%-%dlu%%-%dlu%%-%dlu%%-%dlu\r\n", 10, 10, 10, 10, 10, 10);
    v25 = sprintf(&v63, &v62, v54, v55, v56);
    sub_10001940(a1, &v63, v25);
    v26 = sprintf(&v63, "--------------------------------------------------------------------\r\n");
    sub_10001940(a1, &v63, v26);
    sprintf(&v62, "%%-%ds\r\n", 20);
    v27 = sprintf(&v63, &v62, "TX Collisions");
    sub_10001940(a1, &v63, v27);
    sprintf(&v62, "%%-%ds%%-%ds%%-%ds%%-%ds%%-%ds\r\n", 10, 10, 10, 10, 10);
    v28 = sprintf(&v63, &v62, "Max", "Late", "Single", "Multiple", "Total");
    sub_10001940(a1, &v63, v28);
    sprintf(&v62, "%%-%dlu%%-%dlu%%-%dlu%%-%dlu%%-%dlu\r\n", 10, 10, 10, 10, 10);
    v29 = sprintf(&v63, &v62, v47, v48, v51, v52);
    sub_10001940(a1, &v63, v29);
    v30 = sprintf(&v63, "--------------------------------------------------------------------\r\n");
    sub_10001940(a1, &v63, v30);
    sprintf(&v62, "%%-%ds\r\n", 20);
    v31 = sprintf(&v63, &v62, "TX Errors");
    sub_10001940(a1, &v63, v31);
    sprintf(&v62, "%%-%ds%%-%ds%%-%ds\r\n", 10, 10, 10);
    v32 = sprintf(&v63, &v62, "Underrun", "Lost CRS", "Deferred");
    sub_10001940(a1, &v63, v32);
    sprintf(&v62, "%%-%dlu%%-%dlu%%-%dlu\r\n", 10, 10, 10);
    v33 = sprintf(&v63, &v62, v49, v50);
    sub_10001940(a1, &v63, v33);
    v34 = sprintf(&v63, "--------------------------------------------------------------------\r\n");
    sub_10001940(a1, &v63, v34);
    sprintf(&v62, "%%-%ds\r\n", 20);
    v35 = sprintf(&v63, &v62, "Flow Control");
    sub_10001940(a1, &v63, v35);
    sprintf(&v62, "%%-%ds%%-%ds%%-%ds\r\n", 10, 10, 10);
    v36 = sprintf(&v63, &v62, "TX Pause", "RX Pause", "RX Unsupported");
    sub_10001940(a1, &v63, v36);
    sprintf(&v62, "%%-%dlu%%-%dlu%%-%dlu\r\n", 10, 10, 10);
    v37 = sprintf(&v63, &v62, v57, v58, v59);
    sub_10001940(a1, &v63, v37);
    v38 = sprintf(&v63, "--------------------------------------------------------------------\r\n");
    sub_10001940(a1, &v63, v38);
  }
}
// 10008070: using guessed type int __cdecl j_HWM_pvg_ethr_get_stats(_DWORD, _DWORD);
// 100C74A6: using guessed type char byte_100C74A6;
// 100C7578: using guessed type int dword_100C7578[];
// 100C757C: using guessed type int dword_100C757C[];
// 100C7580: using guessed type int dword_100C7580[];
// 100C7584: using guessed type int dword_100C7584[];
// 100C7588: using guessed type int dword_100C7588[];
// 100C758C: using guessed type int dword_100C758C[];
// 100C7590: using guessed type int dword_100C7590[];
// 100C7594: using guessed type float flt_100C7594[];
// 100C7598: using guessed type float flt_100C7598[];

//----- (10003850) --------------------------------------------------------
void __cdecl sub_10003850(int a1)
{
  int v1; // esi@1
  int v2; // eax@1
  int v3; // eax@1
  int v4; // eax@2
  int v5; // eax@3
  int v6; // eax@4
  int v7; // eax@5
  int v8; // eax@6
  int v9; // ebx@8
  const char *v10; // ecx@12
  const char *v11; // eax@14
  int v12; // eax@16
  int v13; // eax@17
  char v14; // [sp+Fh] [bp-71h]@10
  int v15; // [sp+10h] [bp-70h]@2
  const char *v16; // [sp+14h] [bp-6Ch]@1
  char v17; // [sp+18h] [bp-68h]@1

  v1 = 0;
  memset(&v17, 0, 0x64u);
  v16 = 0;
  sub_100019E0(a1);
  v2 = sprintf(&v17, "HSDB CONFIGURATION:\r\n");
  sub_10001940(a1, &v17, v2);
  v3 = sprintf(&v17, "    Press the letter (A,B,C,D,or E) for the level desired.\r\n");
  sub_10001940(a1, &v17, v3);
  switch ( byte_100C74A7 )
  {
    case 0:
      v4 = sprintf(&v17, "LEVEL A CONFIG\r\n");
      sub_10001940(a1, &v17, v4);
      LOBYTE(v15) = 6;
      break;
    case 1:
      v5 = sprintf(&v17, "LEVEL B CONFIG\r\n");
      sub_10001940(a1, &v17, v5);
      LOBYTE(v15) = 0;
      break;
    case 2:
      v6 = sprintf(&v17, "LEVEL C CONFIG\r\n");
      sub_10001940(a1, &v17, v6);
      LOBYTE(v15) = 1;
      break;
    case 3:
      v7 = sprintf(&v17, "LEVEL D CONFIG\r\n");
      sub_10001940(a1, &v17, v7);
      LOBYTE(v15) = 2;
      break;
    case 4:
      v8 = sprintf(&v17, "LEVEL D DBG CONFIG\r\n");
      sub_10001940(a1, &v17, v8);
      LOBYTE(v15) = 3;
      break;
    default:
      sub_10014D70("..\\lib\\adl\\iop_cdu_dbg_frmt.c", 5563, 1, 0);
      break;
  }
  v9 = (unsigned __int16)sub_1000DC40(v15);
  if ( v9 > 0 )
  {
    while ( sub_1000E530(v15, v1, &v16) == 1 && sub_1000E270(v15, v1, &v14) == 1 )
    {
      v10 = "TRUE";
      if ( v14 != 1 )
        goto LABEL_13;
LABEL_14:
      v11 = v16;
      if ( !v16 )
        v11 = "UNKNOWN";
      v12 = sprintf(&v17, "%-4d %-40s  %-5s\r\n", v1, v11, v10);
      sub_10001940(a1, &v17, v12);
      if ( ++v1 >= v9 )
        goto LABEL_17;
    }
    v14 = 0;
LABEL_13:
    v10 = "FALSE";
    goto LABEL_14;
  }
LABEL_17:
  v13 = sprintf(&v17, "--------------------------------------------------------------------\r\n");
  sub_10001940(a1, &v17, v13);
}
// 100C74A7: using guessed type char byte_100C74A7;

//----- (10003A90) --------------------------------------------------------
int __cdecl sub_10003A90(int a1)
{
  int v1; // edi@1
  int v2; // eax@1
  int v3; // esi@2
  void *v4; // ecx@2
  int v5; // esi@2
  int result; // eax@2
  int v7; // esi@2
  int v8; // ebx@2
  int v9; // eax@9
  int v10; // eax@10
  int v11; // eax@12
  int *v12; // esi@13
  int v13; // edi@13
  int v14; // eax@13
  int v15; // esi@13
  int v16; // eax@16
  bool v17; // sf@19
  unsigned __int8 v18; // of@19
  int v19; // [sp+10h] [bp-C0h]@1
  int v20; // [sp+14h] [bp-BCh]@9
  int v21; // [sp+18h] [bp-B8h]@6
  unsigned __int8 v22; // [sp+1Ch] [bp-B4h]@6
  unsigned __int8 v23; // [sp+1Dh] [bp-B3h]@11
  int v24; // [sp+24h] [bp-ACh]@10
  unsigned __int8 v25; // [sp+28h] [bp-A8h]@12
  int v26[11]; // [sp+2Ch] [bp-A4h]@13
  char v27; // [sp+58h] [bp-78h]@9
  char v28; // [sp+68h] [bp-68h]@1

  v1 = 0;
  memset(&v28, 0, 0x64u);
  sub_100019E0(a1);
  v2 = sprintf(&v28, "HSDB ROUTING INFO:\r\n");
  sub_10001940(a1, &v28, v2);
  v19 = 0;
  do
  {
    v3 = j_HWM_pvg_hsdb_get_lrus_online();
    v5 = sub_10014FA0(v4) | v3;
    result = ~v1;
    v7 = ~v1 & v5;
    v8 = 1;
    if ( !v7 )
      break;
    do
    {
      for ( ; v8; v8 *= 2 )
      {
        if ( v8 & v7 )
          break;
      }
      v7 &= ~v8;
      v21 = v7;
      if ( j_HWM_pvg_hsdb_get_router_entry(v8, &v22) )
      {
        v1 |= v8;
      }
      else if ( v22 == v19 )
      {
        v1 |= v8;
        v20 = v1;
        v9 = sprintf(&v28, "--------------------------------------------------------------------\r\n");
        sub_10001940(a1, &v28, v9);
        sub_10015440(v8, (int)&v27, 15);
        v10 = v19 ? sprintf(&v28, "  %s HOPS=%i local_port=%i direct_lrus=0x%08lX\r\n", &v27, v22, v23 + 1, v24) : sprintf(&v28, "  %s (this LRU)          direct_lrus=0x%08lX\r\n", &v27, v24);
        sub_10001940(a1, &v28, v10);
        v11 = 0;
        if ( v25 )
        {
          do
          {
            v12 = &v26[v11];
            v13 = v11 + 1;
            v14 = sprintf(&v28, "                    port=%i  direct_lru=0x%08lX", v11 + 1, v26[v11]);
            sub_10001940(a1, &v28, v14);
            v15 = *v12;
            if ( v15 )
              sub_10015440(v15, (int)&v27, 15);
            else
              v27 = 0;
            v16 = sprintf(&v28, "  %s\r\n", &v27);
            sub_10001940(a1, &v28, v16);
            v11 = v13;
          }
          while ( v13 < v25 );
          v7 = v21;
          v1 = v20;
        }
      }
    }
    while ( v7 );
    result = v19 + 1;
    v18 = __OFSUB__(v19 + 1, 60);
    v17 = v19++ - 59 < 0;
  }
  while ( v17 ^ v18 );
  return result;
}
// 100080D0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 100080E0: using guessed type int __cdecl j_HWM_pvg_hsdb_get_router_entry(_DWORD, _DWORD);
// 10003A90: using guessed type int var_A4[11];

//----- (10003CA0) --------------------------------------------------------
void __cdecl sub_10003CA0(int a1)
{
  signed int v1; // edi@4
  int v2; // esi@5
  int v3; // eax@10
  int v4; // eax@10
  int v5; // eax@10
  int v6; // eax@10
  int v7; // eax@10
  int v8; // eax@10
  int v9; // eax@10
  int v10; // eax@10
  int v11; // eax@10
  int v12; // eax@10
  int v13; // eax@11
  int v14; // eax@11
  double v15; // st7@11
  char v16; // cl@11
  unsigned int v17; // edi@11
  int v18; // eax@11
  char *v19; // ebx@11
  float v20; // STB4_4@13
  float v21; // STB0_4@13
  int v22; // eax@13
  int v23; // eax@15
  int v24; // eax@15
  char v25; // cl@15
  int v26; // ebx@15
  int v27; // eax@15
  char *v28; // edi@15
  float v29; // STB0_4@17
  float v30; // STB4_4@17
  int v31; // eax@17
  int v32; // eax@19
  char v33; // [sp+7Bh] [bp-47Dh]@11
  char v34; // [sp+7Bh] [bp-47Dh]@15
  int v35; // [sp+80h] [bp-478h]@11
  int v36; // [sp+80h] [bp-478h]@15
  int v37; // [sp+8Ch] [bp-46Ch]@10
  int v38; // [sp+90h] [bp-468h]@10
  int v39; // [sp+94h] [bp-464h]@5
  char *v40; // [sp+98h] [bp-460h]@5
  char v41; // [sp+9Ch] [bp-45Ch]@5
  char v42; // [sp+9Dh] [bp-45Bh]@5
  __int16 v43; // [sp+9Eh] [bp-45Ah]@5
  int v44; // [sp+A0h] [bp-458h]@1
  int v45; // [sp+A4h] [bp-454h]@10
  int v46; // [sp+A8h] [bp-450h]@10
  int v47; // [sp+ACh] [bp-44Ch]@10
  int v48; // [sp+B0h] [bp-448h]@10
  int v49; // [sp+B4h] [bp-444h]@10
  int v50; // [sp+B8h] [bp-440h]@10
  int v51; // [sp+BCh] [bp-43Ch]@10
  int v52; // [sp+C0h] [bp-438h]@10
  __int64 v53; // [sp+C4h] [bp-434h]@10
  int v54; // [sp+E8h] [bp-410h]@10
  int v55; // [sp+ECh] [bp-40Ch]@10
  int v56; // [sp+F0h] [bp-408h]@10
  int v57; // [sp+F4h] [bp-404h]@10
  int v58; // [sp+104h] [bp-3F4h]@13
  int v59; // [sp+108h] [bp-3F0h]@13
  int v60; // [sp+10Ch] [bp-3ECh]@17
  int v61[25]; // [sp+110h] [bp-3E8h]@17
  int v62; // [sp+174h] [bp-384h]@13
  int v63; // [sp+178h] [bp-380h]@13
  int v64; // [sp+17Ch] [bp-37Ch]@17
  int v65[26]; // [sp+180h] [bp-378h]@17
  char v66; // [sp+1E8h] [bp-310h]@11
  char v67; // [sp+1FCh] [bp-2FCh]@15
  char v68[2]; // [sp+440h] [bp-B8h]@1
  char v69; // [sp+4A8h] [bp-50h]@1

  memset(v68, 0, 0x64u);
  memset(&v69, 0, 0x46u);
  memset(&v44, 0, 0x39Cu);
  if ( byte_100C8779 )
  {
    sub_10003A90(a1);
  }
  else
  {
    if ( !byte_100C8778 )
      goto LABEL_22;
    v1 = 0;
    strcpy(v68, "\xFF\xFF\\");
    do
    {
      v39 = 0xFFFFFFF;
      v40 = v68;
      v41 = 3;
      v42 = 1;
      v43 = 100;
      v2 = j_HWM_pvg_hsdb_put(&v39);
      if ( v2 )
        sub_10030240(1);
      ++v1;
    }
    while ( !v2 || v1 < 200 );
    if ( (unsigned int)(sub_10030040() - dword_100C87B4) >= 0xBB8 )
    {
LABEL_22:
      sub_100019E0(a1);
      j_HWM_pvg_hsdb_get_stats(&v44);
      v3 = sprintf(v68, "HSDB STATS:\r\n");
      sub_10001940(a1, v68, v3);
      sprintf(&v69, "%%-%ds%%-%ds%%-%ds%%-%ds\r\n", 18, 18, 18, 9);
      v4 = sprintf(v68, &v69, "Periodic", "Ack Rqrd", "Acks", "Pings");
      sub_10001940(a1, v68, v4);
      sprintf(&v69, "%%-%ds%%-%ds%%-%ds%%-%ds%%-%ds%%-%ds%%-%ds\r\n", 9, 9, 9, 9, 9, 9, 9);
      v5 = sprintf(v68, &v69, "RX", "TX", "RX", "TX", "RX", "TX", "TX");
      sub_10001940(a1, v68, v5);
      sprintf(&v69, "%%-%dlu%%-%dlu%%-%dlu%%-%dlu%%-%dlu%%-%dlu%%-%dlu\r\n", 9, 9, 9, 9, 9, 9, 9);
      v6 = sprintf(v68, &v69, v50, v45, v51, v46, v52, v47, v44);
      sub_10001940(a1, v68, v6);
      v7 = sprintf(v68, "--------------------------------------------------------------------\r\n");
      sub_10001940(a1, v68, v7);
      sprintf(&v69, "%%-%ds%%-%ds%%\r\n", 27, 18);
      v8 = sprintf(v68, &v69, "TX", "RX ack time");
      sub_10001940(a1, v68, v8);
      sprintf(&v69, "%%-%ds%%-%ds%%-%ds%%-%ds%%-%ds%%\r\n", 9, 9, 9, 9, 9);
      v9 = sprintf(v68, &v69, "Retry", "Abort", "Wrt fail", "Min", "Max");
      sub_10001940(a1, v68, v9);
      sprintf(&v69, "%%-%dlu%%-%dlu%%-%dlu%%-%dlu%%-%dlu\r\n", 9, 9, 9, 9, 9);
      v10 = sprintf(v68, &v69, v48, v49, v54, v53);
      sub_10001940(a1, v68, v10);
      sprintf(&v69, "%%-%ds%%-%ds%%-%ds%%\r\n", 9, 9, 9);
      v11 = sprintf(v68, &v69, "Pending", "Ln chngs", "Almost Ln chngs");
      sub_10001940(a1, v68, v11);
      sprintf(&v69, "%%-%dlu%%-%dlu%%-%dlu%%\r\n", 9, 9, 9);
      v12 = sprintf(v68, &v69, v55, v57, v56);
      sub_10001940(a1, v68, v12);
      v38 = sub_10030040();
      v37 = v38 - dword_100C87B4;
      if ( v38 != dword_100C87B4 )
      {
        v13 = sprintf(v68, "--------------------------------------------------------------------\r\n");
        sub_10001940(a1, v68, v13);
        sprintf(&v69, "%%-%ds%%-%ds%%-%ds%%-%ds%%-%ds%%-%ds%%-%ds%%-%ds\r\n", 7, 9, 9, 9, 9, 9, 9, 9);
        v14 = sprintf(v68, &v69, "RX", "Crnt Sz", "Crnt Cnt", "Max Sz", "Max Cnt", "Drp Pkt", "Tout Pkt", "KBy/s");
        sub_10001940(a1, v68, v14);
        sprintf(
          &v69,
          "%%-%ds%%%d.2f%%%% %%%d.2f%%%% %%%d.2f%%%% %%%d.2f%%%% %%%du %%%du %%%d.2f\r\n",
          7,
          7,
          7,
          7,
          7,
          7,
          7,
          7);
        v15 = 100.0;
        v16 = 0;
        v17 = 0;
        v18 = 0;
        v33 = 0;
        v19 = &v66;
        v35 = 0;
        do
        {
          if ( v16 != 4 )
          {
            v20 = (double)(unsigned int)dword_100468D0[v17 / 4];
            v21 = (double)(unsigned int)dword_100468D4[v17 / 4];
            v22 = sprintf(
                    v68,
                    &v69,
                    *(char **)((char *)off_10045CA4 + v18),
                    v15 * ((double)*(unsigned int *)((char *)&v63 + v17) / v21),
                    (double)*(unsigned int *)((char *)&v62 + v17) / v20 * v15,
                    (double)*(unsigned int *)((char *)&v59 + v17) / v21 * v15,
                    (double)*(unsigned int *)((char *)&v58 + v17) / v20 * v15,
                    *((_DWORD *)v19 + 7),
                    *((_DWORD *)v19 + 6),
                    (double)(unsigned int)(*(_DWORD *)v19 - *(int *)((char *)&dword_100C877C + v18))
                  / (double)(unsigned int)v37);
            sub_10001940(a1, v68, v22);
            v15 = 100.0;
            *(int *)((char *)&dword_100C877C + v35) = *(_DWORD *)v19;
            v16 = v33;
            v18 = v35;
          }
          ++v16;
          v18 += 4;
          v17 += 16;
          v19 += 40;
          v33 = v16;
          v35 = v18;
        }
        while ( v16 < 7 );
        v23 = sprintf(v68, "--------------------------------------------------------------------\r\n");
        sub_10001940(a1, v68, v23);
        sprintf(&v69, "%%-%ds%%-%ds%%-%ds%%-%ds%%-%ds%%-%ds%%-%ds%%-%ds%%-%ds\r\n", 7, 9, 9, 9, 9, 9, 9, 9, 9);
        v24 = sprintf(
                v68,
                &v69,
                "TX",
                "Crnt Sz",
                "Crnt Cnt",
                "Max Sz",
                "Max Cnt",
                "Drp pkt",
                "Ovr run",
                "KBy/s",
                "Max BW");
        sub_10001940(a1, v68, v24);
        sprintf(
          &v69,
          "%%-%ds%%%d.2f%%%% %%%d.2f%%%% %%%d.2f%%%% %%%d.2f%%%% %%%du %%%du %%%d.2f %%%d.2f%%%%\r\n",
          7,
          7,
          7,
          7,
          7,
          7,
          7,
          7,
          7);
        v25 = 0;
        v26 = 0;
        v27 = 0;
        v34 = 0;
        v28 = &v67;
        v36 = 0;
        do
        {
          if ( v25 != 4 )
          {
            v29 = (double)(unsigned int)dword_100468D8[v26];
            v30 = (double)(unsigned int)dword_100468DC[v26];
            v31 = sprintf(
                    v68,
                    &v69,
                    *(char **)((char *)off_10045CA4 + v27),
                    100.0 * ((double)(unsigned int)v65[v26] / v30),
                    (double)*(unsigned int *)((char *)&v64 + v26 * 4) / v29 * 100.0,
                    (double)(unsigned int)v61[v26] / v30 * 100.0,
                    (double)*(unsigned int *)((char *)&v60 + v26 * 4) / v29 * 100.0,
                    *((_DWORD *)v28 + 3),
                    *(_DWORD *)v28,
                    (double)(unsigned int)(*((_DWORD *)v28 - 4) - *(int *)((char *)&dword_100C8798 + v27))
                  / (double)(unsigned int)v37,
                    (double)*((unsigned int *)v28 - 2) / 100.0);
            sub_10001940(a1, v68, v31);
            *(int *)((char *)&dword_100C8798 + v36) = *((_DWORD *)v28 - 4);
            v25 = v34;
            v27 = v36;
          }
          ++v25;
          v27 += 4;
          v26 += 4;
          v28 += 40;
          v34 = v25;
          v36 = v27;
        }
        while ( v25 < 7 );
        v32 = sprintf(v68, "--------------------------------------------------------------------\r\n");
        sub_10001940(a1, v68, v32);
        dword_100C87B4 = v38;
      }
    }
  }
}
// 100080F0: using guessed type int __cdecl j_HWM_pvg_hsdb_get_stats(_DWORD);
// 10008100: using guessed type int __cdecl j_HWM_pvg_hsdb_put(_DWORD);
// 10045CA4: using guessed type char *off_10045CA4[7];
// 100468D0: using guessed type int dword_100468D0[];
// 100468D4: using guessed type int dword_100468D4[];
// 100468D8: using guessed type int dword_100468D8[];
// 100468DC: using guessed type int dword_100468DC[];
// 100C8778: using guessed type char byte_100C8778;
// 100C8779: using guessed type char byte_100C8779;
// 100C877C: using guessed type int dword_100C877C;
// 100C8798: using guessed type int dword_100C8798;
// 100C87B4: using guessed type int dword_100C87B4;
// 10003CA0: using guessed type int var_3E8[25];
// 10003CA0: using guessed type int var_378[26];

//----- (10004610) --------------------------------------------------------
void __cdecl sub_10004610(int a1)
{
  int v1; // esi@1
  int v2; // eax@1
  int v3; // eax@1
  int v4; // eax@2
  char *v5; // edi@2
  int v6; // eax@4
  int v7; // eax@5
  int v8; // eax@6
  int v9; // eax@7
  int v10; // eax@8
  unsigned __int16 v11; // ax@10
  int v12; // eax@15
  char v13; // [sp+Ch] [bp-2158h]@2
  int v14; // [sp+10h] [bp-2154h]@1
  char *v15; // [sp+14h] [bp-2150h]@1
  char v16; // [sp+18h] [bp-214Ch]@1
  char v17; // [sp+7Ch] [bp-20E8h]@1
  char v18; // [sp+120h] [bp-2044h]@1
  char v19; // [sp+59Ch] [bp-1BC8h]@1
  char v20; // [sp+9C0h] [bp-17A4h]@2
  char v21; // [sp+E6Ch] [bp-12F8h]@1

  v1 = 0;
  memset(&v16, 0, 0x64u);
  v14 = 0;
  v15 = 0;
  memset(&v19, 0, 0x422u);
  memset(&v21, 0, 0x12F2u);
  memset(&v17, 0, 0xA4u);
  memset(&v18, 0, 0x47Au);
  sub_100019E0(a1);
  v2 = sprintf(&v16, "HSDB TX LIST:\r\n");
  sub_10001940(a1, &v16, v2);
  v3 = sprintf(&v16, "    Press the letter (A,B,C,D,or E) for the level desired.\r\n");
  sub_10001940(a1, &v16, v3);
  switch ( byte_100C74A7 )
  {
    case 0:
      v4 = sprintf(&v16, "LEVEL A TX LIST\r\n");
      sub_10001940(a1, &v16, v4);
      v13 = 6;
      v5 = &v20;
      goto LABEL_3;
    case 1:
      v7 = sprintf(&v16, "LEVEL B TX LIST\r\n");
      sub_10001940(a1, &v16, v7);
      v13 = 0;
      v5 = &v19;
      goto LABEL_3;
    case 2:
      v8 = sprintf(&v16, "LEVEL C TX LIST\r\n");
      sub_10001940(a1, &v16, v8);
      v13 = 1;
      v5 = &v21;
      goto LABEL_3;
    case 3:
      v9 = sprintf(&v16, "LEVEL D TX LIST\r\n");
      sub_10001940(a1, &v16, v9);
      v13 = 2;
      v5 = &v18;
      goto LABEL_3;
    case 4:
      v10 = sprintf(&v16, "LEVEL D DBG TX LIST\r\n");
      sub_10001940(a1, &v16, v10);
      v13 = 3;
      v5 = &v17;
LABEL_3:
      if ( sub_1000DE50(v13, v5, (int)&v14) == 1 )
      {
        v11 = sub_1000DC60(v13);
        if ( v14 > v11 )
          sub_10014D70("..\\lib\\adl\\iop_cdu_dbg_frmt.c", 6600, 1, 0);
        if ( v14 > 0 )
        {
          do
          {
            if ( sub_1000E530(v13, *(_WORD *)&v5[2 * v1], &v15) != 1 )
              sprintf(v15, "UNKNOWN");
            v12 = sprintf(&v16, "%-4d %-25s\r\n", *(_WORD *)&v5[2 * v1], v15);
            sub_10001940(a1, &v16, v12);
            ++v1;
          }
          while ( v1 < v14 );
        }
      }
      else
      {
        v6 = sprintf(&v16, "UNAVAILABLE\r\n");
        sub_10001940(a1, &v16, v6);
      }
      break;
    default:
      sub_10014D70("..\\lib\\adl\\iop_cdu_dbg_frmt.c", 6580, 1, 0);
      break;
  }
}
// 100C74A7: using guessed type char byte_100C74A7;

//----- (100048F0) --------------------------------------------------------
void __cdecl sub_100048F0(int a1)
{
  if ( byte_100C2782 == 1 )
  {
    if ( !dword_100C2784 )
      sub_100019E0(a1);
    sub_10007390(a1, dword_100C2784);
    ++dword_100C2784;
  }
  else
  {
    sub_10006E60(a1);
  }
}
// 100C2782: using guessed type char byte_100C2782;
// 100C2784: using guessed type int dword_100C2784;

//----- (10004930) --------------------------------------------------------
void __cdecl sub_10004930(int a1)
{
  int v1; // ebp@1
  char **v2; // edx@1
  char *v3; // eax@2
  char v4; // cl@3
  int v5; // eax@4
  char **v6; // esi@7
  char *v7; // eax@8
  char v8; // dl@9
  char v9; // [sp+10h] [bp-68h]@1

  memset(&v9, 0, 0x64u);
  v1 = 0;
  v2 = &off_10046438;
  do
  {
    v3 = *v2;
    do
      v4 = *v3++;
    while ( v4 );
    v5 = v3 - (*v2 + 1);
    if ( v5 > v1 )
      v1 = v5;
    v2 += 9;
  }
  while ( (signed int)v2 < (signed int)&off_1004672C );
  sub_100019E0(a1);
  sprintf(&v9, "MENU:\r\n");
  sub_10001940(a1, &v9, strlen(&v9));
  sprintf(&v9, "   %s %*s  %-40s\r\n", "COMMAND", v1 - 7, " ", "MODE");
  sub_10001940(a1, &v9, strlen(&v9));
  v6 = &off_10046438;
  do
  {
    v7 = *v6;
    do
      v8 = *v7++;
    while ( v8 );
    sprintf(&v9, "   %s %*s  %-40s\r\n", *v6, v1 - (v7 - (*v6 + 1)), byte_1004764C, v6 + 1);
    sub_10001940(a1, &v9, strlen(&v9));
    v6 += 9;
  }
  while ( (signed int)v6 < (signed int)&off_1004672C );
}
// 10046438: using guessed type char *off_10046438;
// 1004672C: using guessed type char *off_1004672C;

//----- (10004A80) --------------------------------------------------------
void __cdecl sub_10004A80(int a1)
{
  int v1; // esi@1
  int v2; // eax@1
  int v3; // eax@1
  int v4; // eax@2
  int v5; // eax@2
  int v6; // eax@2
  int v7; // eax@3
  signed int v8; // edi@3
  int v9; // eax@4
  void *v10; // ebx@4
  int v11; // eax@7
  const char *v12; // eax@14
  int v13; // eax@19
  int v14; // eax@20
  int v15; // eax@20
  int v16; // eax@20
  int v17; // eax@25
  int v18; // [sp+48h] [bp-170h]@4
  int v19; // [sp+4Ch] [bp-16Ch]@3
  int v20; // [sp+50h] [bp-168h]@3
  int v21; // [sp+90h] [bp-128h]@7
  unsigned __int16 v22; // [sp+94h] [bp-124h]@20
  int v23; // [sp+98h] [bp-120h]@20
  int v24; // [sp+9Ch] [bp-11Ch]@20
  unsigned __int16 v25; // [sp+A0h] [bp-118h]@7
  unsigned __int16 v26; // [sp+A2h] [bp-116h]@20
  unsigned __int16 v27; // [sp+A4h] [bp-114h]@20
  unsigned __int16 v28; // [sp+A6h] [bp-112h]@20
  unsigned __int16 v29; // [sp+A8h] [bp-110h]@20
  unsigned int v30; // [sp+ACh] [bp-10Ch]@20
  unsigned int v31; // [sp+B0h] [bp-108h]@20
  int v32; // [sp+B4h] [bp-104h]@20
  int v33; // [sp+B8h] [bp-100h]@20
  int v34; // [sp+BCh] [bp-FCh]@13
  unsigned __int16 v35; // [sp+C0h] [bp-F8h]@11
  int v36; // [sp+C4h] [bp-F4h]@13
  int v37; // [sp+D4h] [bp-E4h]@13
  char v38; // [sp+E8h] [bp-D0h]@1
  char v39; // [sp+150h] [bp-68h]@13
  char v40; // [sp+168h] [bp-50h]@13
  char v41; // [sp+180h] [bp-38h]@13

  memset(&v38, 0, 0x64u);
  v1 = a1;
  sub_100019E0(a1);
  v2 = sprintf(&v38, "NET STATS:\r\n");
  sub_10001940(a1, &v38, v2);
  v3 = sprintf(&v38, "ID Task            Local address          Remote address         state\r\n");
  sub_10001940(a1, &v38, v3);
  if ( byte_100C7609 )
  {
    v4 = sprintf(&v38, "  nsw-rx    nsw-tx rxused    txleft  txque   unack wtrx(ms) waito(ms)\r\n");
    sub_10001940(a1, &v38, v4);
    v5 = sprintf(&v38, "  rxpkts   rxbytes txpkts   txbytes   retx unreach hwerrs\r\n");
    sub_10001940(a1, &v38, v5);
    v6 = sprintf(&v38, "  prev line but per/second\r\n");
    sub_10001940(a1, &v38, v6);
  }
  v7 = sub_10030040();
  v8 = v7 - dword_100C86FC;
  v20 = v7;
  v19 = v7 - dword_100C86FC;
  if ( v7 != dword_100C86FC )
  {
    v9 = 0;
    v18 = 0;
    v10 = &unk_100C7EAE;
    while ( 1 )
    {
      if ( byte_100C7608 )
      {
        v11 = j_IOP_pvg_net_stat(v9, &v21, 1);
        qmemcpy((char *)v10 - 6, &v25, 0x1Cu);
        v8 = v19;
        v1 = a1;
      }
      else
      {
        v11 = j_IOP_pvg_net_stat(v9, &v21, 0);
      }
      if ( !v11 && (!byte_100C7656 || v35 >= 0x4Cu || byte_100C760A[v35]) )
      {
        sub_10030060((int)&v41, 1, v34, 50);
        sub_10030D10((int)&v36, &v40, 0x16u, 1);
        sub_10030D10((int)&v37, &v39, 0x16u, 1);
        if ( v21 & 0x100 )
        {
          v12 = "closed";
        }
        else if ( v21 & 0x40 )
        {
          v12 = "opening";
        }
        else
        {
          v12 = "closing";
          if ( (char)v21 >= 0 )
            v12 = "estab";
        }
        v13 = sub_100153B0(&v38, 0x64u, "%2i %-15s %-22s %-22s %-7s\r\n", v35, &v41, &v40, &v39, v12);
        sub_10001940(v1, &v38, v13);
        if ( byte_100C7609 )
        {
          v14 = sub_100153B0(
                  &v38,
                  0x64u,
                  "     %i%i%i       %i%i%i %6lu %9lu %6i %7i %7.2f %7.2f\r\n",
                  v21 & 1,
                  ((unsigned int)(unsigned __int16)v21 >> 2) & 1,
                  ((unsigned int)(unsigned __int16)v21 >> 4) & 1,
                  ((unsigned int)(unsigned __int16)v21 >> 1) & 1,
                  ((unsigned int)(unsigned __int16)v21 >> 3) & 1,
                  ((unsigned int)(unsigned __int16)v21 >> 5) & 1,
                  v24,
                  v23,
                  v22,
                  HIWORD(v21),
                  (double)v30 / 1000.0,
                  (double)v31 / 1000.0);
          sub_10001940(v1, &v38, v14);
          v15 = sub_100153B0(
                  &v38,
                  0x64u,
                  "  %6i %9lu %6i %9lu %6i %7i %7i\r\n",
                  v25 - *((_WORD *)v10 - 3),
                  v32 - *(_DWORD *)((char *)v10 + 14),
                  v26 - *((_WORD *)v10 - 2),
                  v33 - *(_DWORD *)((char *)v10 + 18),
                  v27 - *((_WORD *)v10 - 1),
                  v28 - *(_WORD *)v10,
                  v29 - *((_WORD *)v10 + 1));
          sub_10001940(v1, &v38, v15);
          v16 = sub_100153B0(
                  &v38,
                  0x64u,
                  "  %6.2f %9.2f %6.2f %9.2f %6.2f %7.2f %7.2f\r\n\r\n",
                  (double)(1000i64 * (v25 - *((_WORD *)v10 - 1067)) / (unsigned int)v8),
                  (double)(1000i64 * (unsigned int)(v32 - *(_DWORD *)((char *)v10 - 2114)) / (unsigned int)v8),
                  (double)(1000i64 * (v26 - *((_WORD *)v10 - 1066)) / (unsigned int)v8),
                  (double)(1000i64 * (unsigned int)(v33 - *(_DWORD *)((char *)v10 - 2110)) / (unsigned int)v8),
                  (double)(1000i64 * (v27 - *((_WORD *)v10 - 1065)) / (unsigned int)v8),
                  (double)(1000i64 * (v28 - *((_WORD *)v10 - 1064)) / (unsigned int)v8),
                  (double)(1000i64 * (v29 - *((_WORD *)v10 - 1063)) / (unsigned int)v8));
          sub_10001940(a1, &v38, v16);
        }
        qmemcpy((char *)v10 - 2134, &v25, 0x1Cu);
        v8 = v19;
        v1 = a1;
      }
      ++v18;
      v10 = (char *)v10 + 28;
      if ( (signed int)v10 >= (signed int)&dword_100C86FC + 2 )
        break;
      v9 = v18;
    }
    dword_100C86FC = v20;
    if ( byte_100C7608 )
      byte_100C7608 = 0;
    v17 = sprintf(&v38, "--------------------------------------------------------------------\r\n");
    sub_10001940(v1, &v38, v17);
  }
}
// 10030DD0: using guessed type int __cdecl j_IOP_pvg_net_stat(_DWORD, _DWORD, _DWORD);
// 100C7608: using guessed type char byte_100C7608;
// 100C7609: using guessed type char byte_100C7609;
// 100C7656: using guessed type char byte_100C7656;
// 100C86FC: using guessed type int dword_100C86FC;

//----- (10005030) --------------------------------------------------------
void __cdecl sub_10005030(int a1)
{
  signed int v1; // edi@1
  char v2; // bl@1
  unsigned int v3; // ebp@4
  int v4; // eax@18
  int v5; // eax@18
  int v6; // ST4C_4@24
  int v7; // ST48_4@24
  int v8; // ST40_4@24
  int v9; // ST3C_4@24
  int v10; // eax@24
  int v11; // eax@24
  int v12; // eax@24
  int v13; // eax@33
  int v14; // eax@33
  int v15; // eax@33
  int v16; // eax@35
  int v17; // eax@36
  char v18; // [sp+10h] [bp-E4h]@0
  int v19; // [sp+14h] [bp-E0h]@1
  int v20; // [sp+18h] [bp-DCh]@1
  int v21; // [sp+1Ch] [bp-D8h]@1
  int v22; // [sp+20h] [bp-D4h]@1
  int v23; // [sp+24h] [bp-D0h]@1
  int v24; // [sp+28h] [bp-CCh]@1
  int v25; // [sp+2Ch] [bp-C8h]@1
  int v26; // [sp+30h] [bp-C4h]@1
  unsigned __int16 v27; // [sp+34h] [bp-C0h]@1
  char v28; // [sp+3Ch] [bp-B8h]@15
  int v29; // [sp+40h] [bp-B4h]@21
  char v30[4]; // [sp+68h] [bp-8Ch]@1
  __int16 v31; // [sp+6Ch] [bp-88h]@1
  char v32[4]; // [sp+70h] [bp-84h]@1
  __int16 v33; // [sp+74h] [bp-80h]@1
  char v34[4]; // [sp+78h] [bp-7Ch]@1
  __int16 v35; // [sp+7Ch] [bp-78h]@1
  char v36[4]; // [sp+80h] [bp-74h]@1
  int v37; // [sp+84h] [bp-70h]@1
  __int16 v38; // [sp+88h] [bp-6Ch]@1
  char v39; // [sp+8Ch] [bp-68h]@1

  v1 = 0;
  memset(&v39, 0, 0x64u);
  *(_DWORD *)v32 = 0;
  v33 = 0;
  memset(&v27, 0, 0x34u);
  v20 = 0;
  v19 = 0;
  *(_DWORD *)v36 = 0;
  v37 = 0;
  v38 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v2 = 0;
  *(_DWORD *)v34 = 0;
  v35 = 0;
  *(_DWORD *)v30 = 0;
  v31 = 0;
  if ( toupper((unsigned __int8)byte_100C74A5) > 69 && toupper((unsigned __int8)byte_100C74A5) != 77 )
    byte_100C74A5 = 65;
  v3 = sub_10030040();
  switch ( toupper((unsigned __int8)byte_100C74A5) )
  {
    case 65:
      v18 = 6;
      break;
    case 66:
      v18 = 0;
      break;
    case 67:
      v18 = 1;
      break;
    case 68:
      v18 = 2;
      break;
    case 69:
      v18 = 3;
      break;
    case 77:
      v18 = 5;
      break;
    default:
      byte_100C74A5 = 65;
      break;
  }
  if ( sub_1000E3C0(v18, word_100C7574, &v27) == 1
    && sub_1000E6A0(v18, word_100C7574, (int)&v21) == 1
    && sub_1000E530(v18, word_100C7574, &v20) == 1 )
  {
    if ( v28 == 1 )
    {
      v2 = sub_1000ED90(v18, (unsigned __int16)word_100C7574, byte_100C87C0, (int)&v19);
    }
    else
    {
      v2 = sub_1000ED60(v18, (unsigned __int16)word_100C7574, byte_100C87C0);
      v19 = v27;
    }
  }
  sub_100019E0(a1);
  v4 = sprintf(&v39, "PACKET MONITOR: <type in the packet ID or level followed by return>\r\n");
  sub_10001940(a1, &v39, v4);
  v5 = sprintf(&v39, "%-3s  %-3s  %-25s  %-10s  %-10s %-8s\r\n", "LVL", "ID", "Name", "State", "Updt Tick", "Priority");
  sub_10001940(a1, &v39, v5);
  if ( v2 == 1 )
  {
    sprintf(v36, "VALID");
  }
  else if ( (_BYTE)v21 == 1 || v3 <= v25 + 4 * v29 )
  {
    sprintf(v36, "TIMEDOUT");
  }
  else
  {
    sprintf(v36, "INVALID");
  }
  v6 = BYTE2(v21);
  v7 = v25;
  v8 = v20;
  v9 = (unsigned __int16)word_100C7574;
  v10 = toupper((unsigned __int8)byte_100C74A5);
  v11 = sprintf(&v39, "%-3c  %-3d  %-25s  %-10s  %-10lu %-3d\r\n", v10, v9, v8, v36, v7, v6);
  sub_10001940(a1, &v39, v11);
  v12 = sprintf(
          &v39,
          "%-10s  %-8s  %-5s  %-12s  %-8s %-5s  %-10s\r\n",
          "TX Tick",
          "RX Tmout",
          "Valid",
          "TX Proc Tick",
          "New Data",
          "Size",
          "Source");
  sub_10001940(a1, &v39, v12);
  if ( BYTE3(v21) == 1 )
    sprintf(v32, "TRUE");
  else
    sprintf(v32, "FALSE");
  if ( (_BYTE)v21 == 1 )
    sprintf(v34, "TRUE");
  else
    sprintf(v34, "FALSE");
  if ( BYTE1(v21) == 1 )
    sprintf(v30, "TRUE");
  else
    sprintf(v30, "FALSE");
  v13 = sprintf(
          &v39,
          "%-10lu  %-8s  %-5s  %-12lu  %-8s  %-5d  0x%08x\r\n",
          v24,
          v34,
          v30,
          v23,
          v32,
          (unsigned __int16)v22,
          (unsigned __int16)v26);
  sub_10001940(a1, &v39, v13);
  v14 = sprintf(&v39, "--------------------------------------------------------------------\r\n");
  sub_10001940(a1, &v39, v14);
  v15 = sprintf(&v39, "Raw data:\r\n");
  sub_10001940(a1, &v39, v15);
  if ( (unsigned __int16)v19 > 0u )
  {
    do
    {
      if ( !(v1 % 24) )
      {
        v16 = sprintf(&v39, word_10047844);
        sub_10001940(a1, &v39, v16);
      }
      v17 = sprintf(&v39, "%02x ", (unsigned __int8)byte_100C87C0[v1]);
      sub_10001940(a1, &v39, v17);
      ++v1;
    }
    while ( v1 < (unsigned __int16)v19 );
  }
}
// 100C74A5: using guessed type char byte_100C74A5;
// 100C7574: using guessed type __int16 word_100C7574;

//----- (10005530) --------------------------------------------------------
void __cdecl sub_10005530(int a1)
{
  int v1; // eax@3
  int v2; // eax@3
  int v3; // eax@3
  int v4; // eax@3
  int v5; // eax@3
  int v6; // eax@3
  int v7; // eax@3
  int v8; // eax@3
  void *v9; // ecx@3
  int v10; // eax@3
  int v11; // eax@3
  int v12; // eax@3
  int v13; // eax@3
  int v14; // [sp+0h] [bp-80h]@1
  int v15; // [sp+4h] [bp-7Ch]@1
  int v16; // [sp+8h] [bp-78h]@1
  int v17; // [sp+Ch] [bp-74h]@1
  int v18; // [sp+10h] [bp-70h]@2
  char v19; // [sp+18h] [bp-68h]@1

  memset(&v19, 0, 0x64u);
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( sub_100303F0(2061, (int)&v17, 12) )
  {
    v17 = 827671623;
    v18 = 5789744;
  }
  sub_100019E0(a1);
  v1 = sprintf(&v19, "PRODUCT DATA:\r\n");
  sub_10001940(a1, &v19, v1);
  v2 = sprintf(&v19, "    press 'H' for product history\r\n");
  sub_10001940(a1, &v19, v2);
  v3 = sprintf(&v19, "Part #:        %s\r\n", "006-B0319-C1");
  sub_10001940(a1, &v19, v3);
  v4 = sprintf(&v19, "SW Ver #:      %s\r\n", "14.01");
  sub_10001940(a1, &v19, v4);
  v5 = sprintf(&v19, "Prod Str:      %s\r\n", &v17);
  sub_10001940(a1, &v19, v5);
  v6 = sprintf(&v19, "SW Desc:       %s\r\n", "T GDU1XXX System Software");
  sub_10001940(a1, &v19, v6);
  v7 = sprintf(&v19, "Copyright:     %s\r\n", "(c) 2002-13 Garmin Ltd or subs");
  sub_10001940(a1, &v19, v7);
  sub_10014FC0((char *)&v14);
  v8 = sprintf(&v19, "Prod SN:       %s\r\n", &v14);
  sub_10001940(a1, &v19, v8);
  v10 = sub_10014FA0(v9);
  v11 = sprintf(&v19, "Prod Model #:  0x%08lx\r\n", v10);
  sub_10001940(a1, &v19, v11);
  v12 = sprintf(&v19, "Prod Func Present: 0x%08x\r\n", 0);
  sub_10001940(a1, &v19, v12);
  v13 = sprintf(&v19, "--------------------------------------------------------------------\r\n");
  sub_10001940(a1, &v19, v13);
}

//----- (10005720) --------------------------------------------------------
void __cdecl sub_10005720(int a1)
{
  int v1; // eax@3
  int v2; // eax@3
  int v3; // edi@3
  int v4; // eax@7
  int v5; // eax@7
  int v6; // eax@7
  int v7; // eax@7
  int v8; // eax@7
  int v9; // eax@7
  int v10; // eax@7
  unsigned int v11; // [sp+48h] [bp-100h]@7
  char v12; // [sp+50h] [bp-F8h]@4
  char v13; // [sp+51h] [bp-F7h]@6
  char v14; // [sp+52h] [bp-F6h]@7
  char v15; // [sp+6Eh] [bp-DAh]@7
  char v16; // [sp+7Eh] [bp-CAh]@7
  unsigned int v17; // [sp+B8h] [bp-90h]@7
  int v18; // [sp+BCh] [bp-8Ch]@7
  unsigned int v19; // [sp+C0h] [bp-88h]@7
  int v20; // [sp+CCh] [bp-7Ch]@1
  int v21; // [sp+D0h] [bp-78h]@2
  char v22; // [sp+D8h] [bp-70h]@1

  memset(&v22, 0, 0x64u);
  if ( sub_100303F0(2061, (int)&v20, 12) )
  {
    v20 = 827671623;
    v21 = 5789744;
  }
  sub_100019E0(a1);
  v1 = sprintf(&v22, "PRODUCT HISTORY:\r\n");
  sub_10001940(a1, &v22, v1);
  v2 = sprintf(&v22, "--------------------------------------------------------------------\r\n");
  sub_10001940(a1, &v22, v2);
  v3 = 11499;
  do
  {
    if ( !sub_100303F0(v3, (int)&v12, 116) && v12 == 1 && !v13 )
    {
      v4 = sprintf(&v22, "PWR UP CNT:    %08lu\r\n", v18);
      sub_10001940(a1, &v22, v4);
      v5 = sprintf(&v22, "PWR UP Hours:  %6.2f\r\n", (double)v19 / 60.0);
      sub_10001940(a1, &v22, v5);
      sub_100156A0((int)&v11, v17);
      v6 = sprintf(&v22, "~Date:         %02u/%02u/%04u\r\n", (unsigned __int8)v11, BYTE1(v11), HIWORD(v11));
      sub_10001940(a1, &v22, v6);
      v7 = sprintf(&v22, "Part #:        %s\r\n", &v15);
      sub_10001940(a1, &v22, v7);
      v8 = sprintf(&v22, "SW Ver #:      %s\r\n", &v16);
      sub_10001940(a1, &v22, v8);
      v9 = sprintf(&v22, "SW Desc:       %s\r\n", &v14);
      sub_10001940(a1, &v22, v9);
      v10 = sprintf(&v22, "--------------------------------------------------------------------\r\n");
      sub_10001940(a1, &v22, v10);
    }
    --v3;
  }
  while ( v3 >= 11000 );
}

//----- (10005980) --------------------------------------------------------
void __cdecl sub_10005980(int a1)
{
  int v1; // eax@1
  int v2; // eax@1
  int v3; // eax@1
  signed int v4; // esi@1
  const char *v5; // eax@2
  int v6; // eax@2
  int v7; // eax@3
  char v8; // [sp+8h] [bp-68h]@1

  memset(&v8, 0, 0x64u);
  sub_100019E0(a1);
  v1 = sprintf(&v8, "REGISTRY DATA:\r\n");
  sub_10001940(a1, &v8, v1);
  v2 = sprintf(&v8, "    press 'E' then registry ID to export to card\r\n");
  sub_10001940(a1, &v8, v2);
  v3 = sub_100153B0(&v8, 0x64u, "EA = Export ALL\r\n");
  sub_10001940(a1, &v8, v3);
  v4 = 0;
  do
  {
    v5 = sub_100303B0(v4);
    v6 = sub_100153B0(&v8, 0x64u, "E%-2i = %s\r\n", v4, v5);
    sub_10001940(a1, &v8, v6);
    ++v4;
  }
  while ( v4 < 43 );
  v7 = sub_100153B0(&v8, 0x64u, "--------------------------------------------------------------------\r\n");
  sub_10001940(a1, &v8, v7);
}

//----- (10005A70) --------------------------------------------------------
void __cdecl sub_10005A70(int a1)
{
  void *v1; // ecx@1
  signed int v2; // esi@1
  char *v3; // edi@1
  signed int v4; // edi@5
  char *v5; // esi@5
  int v6; // eax@9
  int v7; // eax@9
  int v8; // eax@9
  int v9; // eax@9
  int v10; // eax@9
  int v11; // eax@9
  int v12; // eax@9
  int v13; // eax@9
  int v14; // eax@9
  int v15; // eax@9
  int v16; // eax@9
  int v17; // eax@9
  int v18; // eax@9
  char v19; // [sp+58h] [bp-1C8h]@5
  __int16 v20; // [sp+68h] [bp-1B8h]@9
  __int16 v21; // [sp+6Ah] [bp-1B6h]@9
  __int16 v22; // [sp+6Ch] [bp-1B4h]@9
  __int16 v23; // [sp+84h] [bp-19Ch]@9
  __int16 v24; // [sp+86h] [bp-19Ah]@9
  __int16 v25; // [sp+88h] [bp-198h]@9
  __int16 v26; // [sp+A0h] [bp-180h]@9
  __int16 v27; // [sp+A2h] [bp-17Eh]@9
  __int16 v28; // [sp+A4h] [bp-17Ch]@9
  __int16 v29; // [sp+BCh] [bp-164h]@9
  __int16 v30; // [sp+BEh] [bp-162h]@9
  __int16 v31; // [sp+C0h] [bp-160h]@9
  __int16 v32; // [sp+D8h] [bp-148h]@9
  __int16 v33; // [sp+DAh] [bp-146h]@9
  __int16 v34; // [sp+DCh] [bp-144h]@9
  __int16 v35; // [sp+F4h] [bp-12Ch]@9
  __int16 v36; // [sp+F6h] [bp-12Ah]@9
  __int16 v37; // [sp+F8h] [bp-128h]@9
  __int16 v38; // [sp+110h] [bp-110h]@9
  __int16 v39; // [sp+112h] [bp-10Eh]@9
  __int16 v40; // [sp+114h] [bp-10Ch]@9
  char v41; // [sp+120h] [bp-100h]@1
  float v42; // [sp+164h] [bp-BCh]@9
  float v43; // [sp+1ACh] [bp-74h]@9
  char v44; // [sp+1B0h] [bp-70h]@1

  memset(&v44, 0, 0x64u);
  sub_100168D0(v1);
  v2 = 0;
  v3 = &v41;
  do
  {
    if ( !(unsigned __int8)sub_100159F0(v2, v3) )
      memset(v3, 0, 0x48u);
    ++v2;
    v3 += 72;
  }
  while ( v2 < 2 );
  v4 = 0;
  v5 = &v19;
  do
  {
    if ( !sub_10015910(v4, (int)v5) )
    {
      *(_DWORD *)v5 = 0;
      *((_DWORD *)v5 + 1) = 0;
      *((_DWORD *)v5 + 2) = 0;
      *((_DWORD *)v5 + 3) = 0;
      *((_DWORD *)v5 + 4) = 0;
      *((_DWORD *)v5 + 5) = 0;
      *((_DWORD *)v5 + 6) = 0;
    }
    ++v4;
    v5 += 28;
  }
  while ( v4 < 7 );
  sub_100019E0(a1);
  v6 = sprintf(&v44, "%s\r\n", "SYSTEM THERMAL MONITOR");
  sub_10001940(a1, &v44, v6);
  v7 = sprintf(&v44, "--------------------------------------------------------------------\r\n");
  sub_10001940(a1, &v44, v7);
  v8 = sprintf(&v44, "PFD1:                  MFD1:                   PFD2:\r\n");
  sub_10001940(a1, &v44, v8);
  v9 = sprintf(
         &v44,
         "Temp BEZEL: %06.2fC   Temp BEZEL: %06.2fC    Temp BEZEL: %06.2fC\r\n",
         (double)v23 / 100.0,
         (double)v20 / 100.0,
         (double)v26 / 100.0);
  sub_10001940(a1, &v44, v9);
  v10 = sprintf(
          &v44,
          "Temp GPU:   %06.2fC   Temp GPU:   %06.2fC    Temp GPU:   %06.2fC\r\n",
          (double)v24 / 100.0,
          (double)v21 / 100.0,
          (double)v27 / 100.0);
  sub_10001940(a1, &v44, v10);
  v11 = sprintf(
          &v44,
          "Temp XFMR:  %06.2fC   Temp XFMR:  %06.2fC    Temp XFMR:  %06.2fC\r\n\n",
          (double)v25 / 100.0,
          (double)v22 / 100.0,
          (double)v28 / 100.0);
  sub_10001940(a1, &v44, v11);
  v12 = sprintf(&v44, "GIA1:                  GIA2:\r\n");
  sub_10001940(a1, &v44, v12);
  v13 = sprintf(&v44, "Temp:        %06.2fC   Temp:        %06.2fC\r\n\n", v42 / 100.0, v43 / 100.0);
  sub_10001940(a1, &v44, v13);
  v14 = sprintf(&v44, "GTC1:                  GTC2:                  GTC3:                  GTC4:\r\n");
  sub_10001940(a1, &v44, v14);
  v15 = sprintf(
          &v44,
          "Temp BEZEL: %06.2fC    Temp BEZEL: %06.2fC    Temp BEZEL: %06.2fC    Temp BEZEL: %06.2fC\r\n",
          (double)v29 / 100.0,
          (double)v32 / 100.0,
          (double)v35 / 100.0,
          (double)v38 / 100.0);
  sub_10001940(a1, &v44, v15);
  v16 = sprintf(
          &v44,
          "Temp Main:  %06.2fC    Temp Main:  %06.2fC    Temp Main:  %06.2fC    Temp Main:  %06.2fC\r\n",
          (double)v30 / 100.0,
          (double)v33 / 100.0,
          (double)v36 / 100.0,
          (double)v39 / 100.0);
  sub_10001940(a1, &v44, v16);
  v17 = sprintf(
          &v44,
          "Temp LCD:   %06.2fC    Temp LCD:   %06.2fC    Temp LCD:   %06.2fC    Temp LCD:   %06.2fC\r\n\n",
          (double)v31 / 100.0,
          (double)v34 / 100.0,
          (double)v37 / 100.0,
          (double)v40 / 100.0);
  sub_10001940(a1, &v44, v17);
  v18 = sprintf(&v44, "--------------------------------------------------------------------\r\n");
  sub_10001940(a1, &v44, v18);
}

//----- (10005F10) --------------------------------------------------------
void __cdecl sub_10005F10(int a1)
{
  unsigned int v1; // esi@1
  int v2; // eax@2
  int v3; // eax@6
  int v4; // eax@6
  int v5; // eax@6
  int v6; // esi@6
  char *v7; // ecx@8
  char v8; // dl@9
  char *v9; // eax@13
  char v10; // cl@14
  char *v11; // eax@15
  char v12; // cl@16
  int v13; // ecx@19
  double v14; // st7@20
  int v15; // eax@20
  int *v16; // edi@20
  int *v17; // esi@20
  int v18; // eax@24
  float v19; // ST84_4@25
  float v20; // ST88_4@25
  int v21; // eax@25
  char *v22; // ecx@26
  char v23; // dl@27
  int v24; // eax@30
  char *v25; // ecx@31
  char v26; // dl@32
  int v27; // eax@34
  int v28; // eax@37
  int v29; // [sp+78h] [bp-80h]@20
  float v30; // [sp+7Ch] [bp-7Ch]@25
  int v31; // [sp+80h] [bp-78h]@19
  int v32; // [sp+84h] [bp-74h]@8
  char v33; // [sp+88h] [bp-70h]@1

  memset(&v33, 0, 0x64u);
  v1 = 1;
  do
  {
    v2 = (unsigned __int16)sub_10030020(v1);
    if ( (unsigned __int16)v2 > 1u && v2 != 4 )
      sub_10030190(v1, 32);
    ++v1;
  }
  while ( v1 < 0x40 );
  sub_100019E0(a1);
  v3 = sprintf(&v33, "TASK STATS:\r\n");
  sub_10001940(a1, &v33, v3);
  v4 = sprintf(&v33, "%58s%-12s\r\n", byte_1004764C, "Stack");
  sub_10001940(a1, &v33, v4);
  v5 = sprintf(&v33, "%48s%-12s%-5s %-5s\r\n", byte_1004764C, "Time (ms)", "Krnl", "User");
  sub_10001940(a1, &v33, v5);
  v6 = sprintf(
         &v33,
         "%2s %-15s %5s %5s %6s %6s %6s %6s %5s %5s %3s",
         "ID",
         "Task",
         "CPU%",
         "CPUt",
         "Sec",
         "Overn",
         "Given",
         "Taken",
         "%Used",
         "%Used",
         "Pri");
  if ( byte_100C27CA || !byte_100C2788 )
  {
    v7 = (char *)&v32 + 3;
    do
      v8 = (v7++)[1];
    while ( v8 );
    *(_WORD *)v7 = 2573;
    v7[2] = 0;
    v6 += 2;
  }
  sub_10001940(a1, &v33, v6);
  if ( byte_100C2788 )
  {
    if ( byte_100C27CA )
    {
      qmemcpy(&v33, "      times waiting on others for   times others waiting on us 4", 0x41u);
      v9 = (char *)&v32 + 3;
      do
        v10 = (v9++)[1];
      while ( v10 );
      *(_WORD *)v9 = 2573;
      v9[2] = 0;
      sub_10001940(a1, &v33, strlen(&v33));
      qmemcpy(&v33, "              Sem  Msg q Msg r   Othr    Sem Msg qu Msg re  Othr", 0x41u);
      v11 = (char *)&v32 + 3;
      do
        v12 = (v11++)[1];
      while ( v12 );
      *(_WORD *)v11 = 2573;
      v11[2] = 0;
      sub_10001940(a1, &v33, strlen(&v33));
      sub_10001940(a1, "           context swtch  prdc  ---Max (ms) for events-----\r\n", 61);
      sub_10001940(a1, "            Total  Per/s  Misd   Proc Used dr  Wait   Wait 4 other(sem,msg..)\r\n", 79);
    }
    else
    {
      sub_10001940(a1, "      times waiting on others for   times others waiting on us 4", 64);
      sub_10001940(a1, "           context swtch  prdc  ---Max (ms) for events-----\r\n", 61);
      sub_10001940(a1, "                                                                          ", 74);
      sub_10001940(a1, "              Sem  Msg q Msg r   Othr    Sem Msg qu Msg re  Othr", 64);
      sub_10001940(a1, "            Total  Per/s  Misd   Proc Used dr  Wait   Wait 4 other(sem,msg..)\r\n", 79);
    }
  }
  sub_10001820(1000 * dword_100C87BC / 2 + 10);
  v32 = dword_100C47D0;
  v13 = dword_100C47D0 - dword_100C27CC;
  v31 = dword_100C47D0 - dword_100C27CC;
  if ( (unsigned int)(dword_100C47D0 - dword_100C27CC) > 5 )
  {
    v14 = 100.0;
    v15 = 0;
    v29 = 0;
    v16 = dword_100C67E0;
    v17 = dword_100C2814;
    while ( 1 )
    {
      if ( byte_100C2789[v15] || !byte_100C27C9 )
      {
        v18 = *(v17 - 8);
        if ( v18 )
        {
          v30 = (double)(unsigned int)v13;
          v20 = (double)(unsigned int)(v18 - v17[2041]);
          v19 = (double)(unsigned int)(100 * (v18 - v16[1])) / v30;
          v21 = sprintf(
                  &v33,
                  "%2lu %-15s %5.1f %5.1f %6.1f %6lu %6lu %6lu %5.1f %5.1f %3lu",
                  v17[4],
                  v17 + 5,
                  v19,
                  v14 * v20 / (double)(unsigned int)(v32 - dword_100C73D4),
                  v20 / 1000.0,
                  v17[3] - v17[2052],
                  (*(v17 - 6) - v17[2043]) / 0x3E8u,
                  (*(v17 - 5) - v17[2044]) / 0x3E8u,
                  (double)(unsigned int)*(v17 - 1) / v14,
                  (double)(unsigned int)*v17 / v14,
                  v17[2]);
          if ( byte_100C27CA )
          {
            v22 = (char *)&v32 + 3;
            do
              v23 = (v22++)[1];
            while ( v23 );
            *(_WORD *)v22 = 2573;
            v22[2] = 0;
            v21 += 2;
          }
          sub_10001940(a1, &v33, v21);
          if ( byte_100C2788 )
          {
            v24 = sprintf(
                    &v33,
                    "         %8u %6u %5u %6u %6u %6u %6u %5u",
                    (unsigned __int16)(*((_WORD *)v17 - 34) - *((_WORD *)v17 + 4064)),
                    (unsigned __int16)(*((_WORD *)v17 - 33) - *((_WORD *)v17 + 4065)),
                    (unsigned __int16)(*((_WORD *)v17 - 32) - *((_WORD *)v17 + 4066)),
                    (unsigned __int16)(*((_WORD *)v17 - 31) - *((_WORD *)v17 + 4067)),
                    (unsigned __int16)(*((_WORD *)v17 - 30) - *((_WORD *)v17 + 4068)),
                    (unsigned __int16)(*((_WORD *)v17 - 28) - *((_WORD *)v17 + 4070)),
                    (unsigned __int16)(*((_WORD *)v17 - 29) - *((_WORD *)v17 + 4069)),
                    (unsigned __int16)(*((_WORD *)v17 - 27) - *((_WORD *)v17 + 4071)));
            if ( byte_100C27CA )
            {
              v25 = (char *)&v32 + 3;
              do
                v26 = (v25++)[1];
              while ( v26 );
              *(_WORD *)v25 = 2573;
              v25[2] = 0;
              v24 += 2;
            }
            sub_10001940(a1, &v33, v24);
            v27 = sprintf(
                    &v33,
                    "         %8lu %6.2f %5lu %6lu %6.1f %6.1f %6.1f\r\n",
                    *(v17 - 13) - v17[2036],
                    (double)(unsigned int)(*(v17 - 13) - v16[2]) / (v30 / 1000.0),
                    *(v17 - 7) - v17[2042],
                    *(v16 - 3),
                    (double)(unsigned int)*(v16 - 2) / 1000.0,
                    (double)(unsigned int)*v16 / 1000.0,
                    (double)(unsigned int)*(v16 - 1) / 1000.0);
            sub_10001940(a1, &v33, v27);
          }
          v14 = 100.0;
        }
      }
      v16[1] = *(v17 - 8);
      v16[2] = *(v17 - 13);
      v15 = v29 + 1;
      v17 += 32;
      v16 += 6;
      if ( (unsigned int)++v29 >= 0x40 )
        break;
      v13 = v31;
    }
    dword_100C27CC = dword_100C47D0;
    v28 = sprintf(&v33, "--------------------------------------------------------------------\r\n");
    sub_10001940(a1, &v33, v28);
  }
}
// 100C2788: using guessed type char byte_100C2788;
// 100C27C9: using guessed type char byte_100C27C9;
// 100C27CA: using guessed type char byte_100C27CA;
// 100C27CC: using guessed type int dword_100C27CC;
// 100C2814: using guessed type int dword_100C2814[];
// 100C47D0: using guessed type int dword_100C47D0;
// 100C67E0: using guessed type int dword_100C67E0[];
// 100C73D4: using guessed type int dword_100C73D4;
// 100C87BC: using guessed type int dword_100C87BC;

//----- (10006560) --------------------------------------------------------
void __cdecl sub_10006560(int a1)
{
  char v1; // [sp+4h] [bp-68h]@1

  memset(&v1, 0, 0x64u);
  sub_100019E0(a1);
  sprintf(&v1, "SELECT DATA TO TOGGLE ON/OFF:\r\n");
  sub_10001940(a1, &v1, strlen(&v1));
  sprintf(&v1, "   %3s......%-3s-%-40s\r\n", "KEY", "ON?", "MODE");
  sub_10001940(a1, &v1, strlen(&v1));
}

//----- (10006610) --------------------------------------------------------
void __cdecl sub_10006610(int a1)
{
  int v1; // ebx@1
  unsigned __int8 v2; // [sp+7h] [bp-1h]@1

  v1 = a1;
  v2 = 0;
  if ( (unsigned __int8)a1 <= 1u )
  {
    byte_100C750E = a1;
    if ( j_HWM_pvg_get_uart(a1, &v2, 1) > 0 )
    {
      do
      {
        byte_100C7576 = 1;
        sub_10002580(v2, &unk_100C74A8, &word_100C750C, 100);
      }
      while ( j_HWM_pvg_get_uart(v1, &v2, 1) > 0 );
    }
  }
  if ( !LOBYTE(dword_100C8700[0]) )
    sub_10001330(0);
  sub_10011710(dword_100C8704, (char *)&a1);
  if ( (_BYTE)a1 )
    sub_10001C70(&byte_100C7510);
}
// 100080A0: using guessed type int __cdecl j_HWM_pvg_get_uart(_DWORD, _DWORD, _DWORD);
// 100C750C: using guessed type __int16 word_100C750C;
// 100C750E: using guessed type char byte_100C750E;
// 100C7510: using guessed type char byte_100C7510;
// 100C7576: using guessed type char byte_100C7576;
// 100C8700: using guessed type int dword_100C8700[];
// 100C8704: using guessed type int dword_100C8704[];

//----- (100066B0) --------------------------------------------------------
char __cdecl sub_100066B0(int a1, _BYTE *a2)
{
  char result; // al@1

  result = 0;
  switch ( *a2 )
  {
    case 0x41:
      byte_100C74A7 = 0;
      sub_10003850(a1);
      result = 1;
      break;
    case 0x42:
      byte_100C74A7 = 1;
      sub_10003850(a1);
      result = 1;
      break;
    case 0x43:
      byte_100C74A7 = 2;
      sub_10003850(a1);
      result = 1;
      break;
    case 0x44:
      byte_100C74A7 = 3;
      sub_10003850(a1);
      result = 1;
      break;
    case 0x45:
      byte_100C74A7 = 4;
      sub_10003850(a1);
      result = 1;
      break;
    default:
      return result;
  }
  return result;
}
// 100C74A7: using guessed type char byte_100C74A7;

//----- (10006750) --------------------------------------------------------
char __cdecl sub_10006750(int a1, _BYTE *a2)
{
  char result; // al@1

  result = 0;
  switch ( *a2 )
  {
    case 0x41:
      byte_100C74A7 = 0;
      sub_10004610(a1);
      result = 1;
      break;
    case 0x42:
      byte_100C74A7 = 1;
      sub_10004610(a1);
      result = 1;
      break;
    case 0x43:
      byte_100C74A7 = 2;
      sub_10004610(a1);
      result = 1;
      break;
    case 0x44:
      byte_100C74A7 = 3;
      sub_10004610(a1);
      result = 1;
      break;
    case 0x45:
      byte_100C74A7 = 4;
      sub_10004610(a1);
      result = 1;
      break;
    default:
      return result;
  }
  return result;
}
// 100C74A7: using guessed type char byte_100C74A7;

//----- (100067F0) --------------------------------------------------------
char __cdecl sub_100067F0(int a1, _BYTE *a2)
{
  char result; // al@1
  unsigned int v3; // [sp+0h] [bp-4h]@1

  v3 = (unsigned int)&v3 ^ __security_cookie;
  result = 0;
  if ( *a2 == 72 )
  {
    sub_10005720(a1);
    result = 1;
  }
  return result;
}

//----- (10006830) --------------------------------------------------------
char __cdecl sub_10006830(int a1, _BYTE *a2)
{
  char v2; // bl@1
  void (**v3)(void); // esi@1

  v2 = 0;
  v3 = (void (**)(void))&unk_100468A4;
  do
  {
    if ( v2 )
      break;
    if ( *((_BYTE *)v3 - 36) == *a2 && *v3 )
    {
      v2 = 1;
      (*v3)();
      sub_10030240(10);
      sub_10006560(a1);
    }
    v3 += 10;
  }
  while ( (signed int)v3 < (signed int)&unk_100468CC );
  return v2;
}

//----- (10006880) --------------------------------------------------------
void __cdecl sub_10006880(int a1)
{
  int v1; // eax@1
  int v2; // eax@1
  int v3; // eax@1
  signed int v4; // esi@1
  int v5; // eax@5
  char v6; // [sp+Bh] [bp-2E9h]@1
  char v7; // [sp+Ch] [bp-2E8h]@2
  char v8; // [sp+28Ch] [bp-68h]@1

  memset(&v8, 0, 0x64u);
  sub_100019E0(a1);
  v1 = sprintf(&v8, "ASSERT LOG: (oldest listed first)\r\n");
  sub_10001940(a1, &v8, v1);
  v2 = sprintf(&v8, "    press 'D' for details OR press 'C' to clear log\r\n");
  sub_10001940(a1, &v8, v2);
  v3 = sprintf(&v8, "%-8s %-8s %-6s %-25s %-15s\r\n", "Date", "Time", "PwrCnt", "Type", "Task");
  sub_10001940(a1, &v8, v3);
  v6 = a1;
  v4 = 0;
  do
  {
    if ( !sub_10007ED0(&v7, v4) )
      sub_10007A10((int)&v7, 0, (void (__cdecl *)(int, char *, int))sub_10002A00, (int)&v6);
    ++v4;
  }
  while ( v4 < 100 );
  v5 = sprintf(&v8, "--------------------------------------------------------------------\r\n");
  sub_10001940(a1, &v8, v5);
}
// 10002A00: using guessed type int sub_10002A00();

//----- (100069B0) --------------------------------------------------------
void __usercall sub_100069B0(int a1@<ebx>)
{
  int v1; // eax@1
  signed int v2; // esi@1
  int v3; // eax@5
  int v4; // [sp+0h] [bp-2F4h]@0
  char v5; // [sp+Bh] [bp-2E9h]@1
  char v6; // [sp+Ch] [bp-2E8h]@2
  char v7; // [sp+28Ch] [bp-68h]@1

  sub_100019E0(v4);
  v1 = sprintf(&v7, "ASSERT LOG DETAILS: (oldest listed first)\r\n");
  sub_10001940(a1, &v7, v1);
  v5 = a1;
  v2 = 0;
  do
  {
    if ( !sub_10007ED0(&v6, v2) )
      sub_10007A10((int)&v6, 1, (void (__cdecl *)(int, char *, int))sub_10002A00, (int)&v5);
    ++v2;
  }
  while ( v2 < 100 );
  v3 = sprintf(&v7, "--------------------------------------------------------------------\r\n");
  sub_10001940(a1, &v7, v3);
}
// 10002A00: using guessed type int sub_10002A00();

//----- (10006A70) --------------------------------------------------------
char __cdecl sub_10006A70(int a1, _BYTE *a2)
{
  char result; // al@3
  int v3; // eax@4
  char v4; // [sp+4h] [bp-68h]@1

  memset(&v4, 0, 0x64u);
  if ( *a2 == 67 )
  {
    sub_10007FC0();
    v3 = sprintf(&v4, "ASSERT LOG CLEARED\r\n");
    sub_10001940(a1, &v4, v3);
    result = 1;
  }
  else if ( *a2 == 68 )
  {
    sub_100069B0((unsigned __int8)a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10006B10) --------------------------------------------------------
void __cdecl sub_10006B10(int a1)
{
  signed int v1; // esi@1
  int v2; // ebp@1
  int v3; // eax@1
  int v4; // edi@3
  void *v5; // ecx@3
  int v6; // edi@4
  void *v7; // ecx@4
  bool v8; // zf@5
  bool v9; // sf@5
  unsigned __int8 v10; // of@5
  int v11; // edi@7
  void *v12; // ecx@7
  int v13; // edi@8
  void *v14; // ecx@8
  int v15; // eax@13
  unsigned int v16; // eax@14
  unsigned int v17; // edi@14
  int v18; // eax@17
  int v19; // eax@18
  int v20; // eax@19
  unsigned int v21; // ebx@19
  int v22; // eax@20
  int v23; // eax@22
  double v24; // st7@22
  int v25; // ST10_4@22
  double v26; // st7@23
  int v27; // ST10_4@23
  char v28; // [sp+1Ch] [bp-A8h]@13
  char v29; // [sp+80h] [bp-44h]@14

  v1 = 0;
  v2 = sub_10030040();
  v3 = (unsigned __int8)sub_10001000() - 1;
  if ( v3 )
  {
    if ( v3 != 1 )
      goto LABEL_14;
    while ( 1 )
    {
      v4 = sub_10030040();
      if ( (double)(unsigned int)(v4 - sub_10015610(v5)) >= 850.0 )
      {
        v6 = sub_10030040();
        if ( (double)(unsigned int)(v6 - sub_10015610(v7)) <= 1000.0 )
          break;
      }
      v10 = __OFSUB__(v1, 200);
      v8 = v1 == 200;
      v9 = v1 - 200 < 0;
      if ( v1 >= 200 )
        goto LABEL_12;
      ++v1;
      sub_10030240(25);
    }
  }
  else
  {
    while ( 1 )
    {
      v11 = sub_10030040();
      if ( (double)(unsigned int)(v11 - sub_10015610(v12)) <= 700.0 )
      {
        v13 = sub_10030040();
        if ( (double)(unsigned int)(v13 - sub_10015610(v14)) >= 150.0 )
          break;
      }
      v10 = __OFSUB__(v1, 200);
      v8 = v1 == 200;
      v9 = v1 - 200 < 0;
      if ( v1 >= 200 )
        goto LABEL_12;
      ++v1;
      sub_10030240(25);
    }
  }
  v10 = __OFSUB__(v1, 200);
  v8 = v1 == 200;
  v9 = v1 - 200 < 0;
LABEL_12:
  if ( !((unsigned __int8)(v9 ^ v10) | v8) )
  {
    v15 = sprintf(&v28, "Blink timed out. Screen not captured.\r\n");
    sub_10001940(a1, &v28, v15);
    return;
  }
LABEL_14:
  v16 = sub_10007830(&v29, 0x40u);
  v17 = v16;
  if ( v16 < 0xFFFFFFC2 && v16 )
  {
    v20 = sprintf(&v28, "Copying screen to file %s.\r\n", &v29);
    sub_10001940(a1, &v28, v20);
    v21 = sub_100078C0(v17, 0);
    sub_10030770(v17);
    if ( v21 )
    {
      v22 = sprintf(&v28, "Unable to copy screen to file. Err %i!\r\n", v21);
      sub_10001940(a1, &v28, v22);
    }
    else if ( sub_10001010() )
    {
      v23 = sprintf(&v28, "Flushing file buffers please wait.\r\n");
      sub_10001940(a1, &v28, v23);
      j_FIL_vfs_sync_all();
      v24 = (double)(unsigned int)(sub_10030040() - v2) / 1000.0;
      v25 = sprintf(&v28, "Card can now be removed. Capture took %.1f seconds.\r\n", v24);
      sub_10001940(a1, &v28, v25);
    }
    else
    {
      v26 = (double)(unsigned int)(sub_10030040() - v2) / 1000.0;
      v27 = sprintf(&v28, "Press 'f' to flush data before card is removed. Capture took %.1f seconds.\r\n", v26);
      sub_10001940(a1, &v28, v27);
    }
  }
  else if ( v16 == -11 )
  {
    v18 = sprintf(&v28, "Too many captures in %s!\r\n", "/mnt/card0/print");
    sub_10001940(a1, &v28, v18);
  }
  else
  {
    v19 = sprintf(&v28, "Err %i opening output file %s!\r\n", v16, &v29);
    sub_10001940(a1, &v28, v19);
  }
}
// 100309A0: using guessed type int j_FIL_vfs_sync_all(void);

//----- (10006E60) --------------------------------------------------------
void __cdecl sub_10006E60(int a1)
{
  int v1; // eax@1
  int v2; // eax@1
  double v3; // ST44_8@1
  double v4; // ST3C_8@1
  __int16 v5; // ax@1
  int v6; // eax@1
  double v7; // ST44_8@1
  double v8; // ST3C_8@1
  __int16 v9; // ax@1
  int v10; // eax@1
  double v11; // ST44_8@1
  double v12; // ST3C_8@1
  __int16 v13; // ax@1
  int v14; // eax@1
  double v15; // ST44_8@1
  double v16; // st7@1
  int v17; // eax@1
  double v18; // ST44_8@2
  double v19; // ST3C_8@2
  __int16 v20; // ax@2
  int v21; // eax@2
  int v22; // ST48_4@2
  int v23; // ST44_4@2
  __int16 v24; // ax@2
  int v25; // eax@2
  int v26; // edi@4
  int v27; // ebx@4
  int v28; // eax@4
  int v29; // eax@4
  int v30; // eax@4
  int v31; // eax@4
  int v32; // eax@4
  int v33; // eax@4
  int v34; // eax@4
  int v35; // eax@5
  __int64 v36; // [sp+44h] [bp-15Ch]@4
  int v37; // [sp+4Ch] [bp-154h]@4
  int v38; // [sp+50h] [bp-150h]@4
  int v39; // [sp+54h] [bp-14Ch]@4
  int v40; // [sp+58h] [bp-148h]@4
  int v41; // [sp+64h] [bp-13Ch]@4
  double v42; // [sp+68h] [bp-138h]@4
  double v43; // [sp+70h] [bp-130h]@4
  double v44; // [sp+78h] [bp-128h]@4
  double v45; // [sp+80h] [bp-120h]@4
  unsigned __int8 v46; // [sp+AAh] [bp-F6h]@4
  char v47; // [sp+B0h] [bp-F0h]@4
  unsigned __int8 v48; // [sp+11Ch] [bp-84h]@4
  unsigned __int8 v49; // [sp+11Dh] [bp-83h]@4
  unsigned __int8 v50; // [sp+11Eh] [bp-82h]@4
  char v51; // [sp+130h] [bp-70h]@1

  memset(&v51, 0, 0x64u);
  sub_100019E0(a1);
  v1 = sprintf(&v51, "%s\r\n", "Hardware ADC Channels (Enter 'C' to toggle CSV mode)");
  sub_10001940(a1, &v51, v1);
  v2 = sprintf(&v51, "--------------------------------------------------------------------\r\n");
  sub_10001940(a1, &v51, v2);
  v3 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(2) / 100.0;
  v4 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(8) / 1000.0;
  v5 = j_HWM_pvg_get_frmt_adc(0);
  v6 = sprintf(
         &v51,
         "Photocell Right: %5.2f%%   Power 1.3V:  %5.2fV   Temp Bezel: %5.2fC\n\r",
         (double)v5 / 100.0,
         v4,
         v3);
  sub_10001940(a1, &v51, v6);
  v7 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(15) / 100.0;
  v8 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(5) / 1000.0;
  v9 = j_HWM_pvg_get_frmt_adc(1);
  v10 = sprintf(
          &v51,
          "Photocell Left:  %5.2f%%   Power 3.3V:  %5.2fV   Temp GPU:  %5.2fC\n\r",
          (double)v9 / 100.0,
          v8,
          v7);
  sub_10001940(a1, &v51, v10);
  v11 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(16) / 100.0;
  v12 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(7) / 100.0;
  v13 = j_HWM_pvg_get_frmt_adc(10);
  v14 = sprintf(
          &v51,
          "Light Bus AC:    %5.2f%%   Power 28Va:  %5.2fV   Temp XFMR: %5.2fC\n\r",
          (double)v13 / 100.0,
          v12,
          v11);
  sub_10001940(a1, &v51, v14);
  v15 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(6) / 100.0;
  v16 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(9) / 100.0;
  v17 = sprintf(&v51, "Light Bus DC:    %5.2f%%   Power 28Vb:  %5.2fV\n\r", v16, v15);
  sub_10001940(a1, &v51, v17);
  if ( sub_10030750() )
  {
    v18 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(26) / 100.0;
    v19 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(25) / 100.0;
    v20 = j_HWM_pvg_get_frmt_adc(24);
    v21 = sprintf(
            &v51,
            "Temp LED1:       %5.2fC   Temp LED2:   %5.2fC   Temp LED3: %5.2fC\n\r",
            (double)v20 / 100.0,
            v19,
            v18);
    sub_10001940(a1, &v51, v21);
    v22 = (signed __int16)j_HWM_pvg_get_raw_adc(21);
    v23 = (signed __int16)j_HWM_pvg_get_raw_adc(20);
    v24 = j_HWM_pvg_get_raw_adc(19);
    v25 = sprintf(&v51, "Fan1:              %i      Fan2:          %i      Fan3:        %i\n\r", v24, v23, v22);
    sub_10001940(a1, &v51, v25);
  }
  if ( sub_10030750() )
  {
    j_HWM_pvg_dspl_bklt_get_actv_led_calib(&v47);
    j_HWM_pvg_dspl_bklt_get_frmt_avg_adc(&v38, &v39, &v40);
    j_HWM_pvg_dspl_bklt_get_rgb_pwm(&v36, (char *)&v36 + 4, &v37);
    j_HWM_pvg_dspl_bklt_get_wht_pnt_sts(&v42);
    v26 = (signed __int16)j_HWM_pvg_get_frmt_adc(27);
    v27 = (signed __int16)j_HWM_pvg_get_frmt_adc(28);
    v41 = (signed __int16)j_HWM_pvg_get_frmt_adc(29);
    v28 = sprintf(&v51, "--------------------------------------------------------------------\r\n");
    sub_10001940(a1, &v51, v28);
    v29 = sprintf(&v51, "%s\r\n", "LED Backlight Diagnostic Data");
    sub_10001940(a1, &v51, v29);
    v30 = sprintf(&v51, "--------------------------------------------------------------------\r\n");
    sub_10001940(a1, &v51, v30);
    v31 = sprintf(&v51, "Calibrated: %i Wht Enbl: %i Wht Poss: %i Sts valid: %i\n\r", v48, v49, v50, v46);
    sub_10001940(a1, &v51, v31);
    v32 = sprintf(&v51, "R_PWM: %lu G_PWM: %lu B_PWM: %lu\n\r", v36, v37);
    sub_10001940(a1, &v51, v32);
    v33 = sprintf(
            &v51,
            "R_AVG: %ld R_RAW: %ld G_AVG: %ld G_RAW: %ld B_AVG: %ld B_RAW: %ld\n\r",
            v38,
            v26,
            v39,
            v27,
            v40,
            v41);
    sub_10001940(a1, &v51, v33);
    v34 = sprintf(&v51, "R_MAX: %f G_MAX: %f B_MAX: %f W_MAX: %f\n\r", v43, v44, v45, v42);
    sub_10001940(a1, &v51, v34);
  }
  v35 = sprintf(&v51, "--------------------------------------------------------------------\r\n");
  sub_10001940(a1, &v51, v35);
}
// 10008030: using guessed type int __cdecl j_HWM_pvg_dspl_bklt_get_actv_led_calib(_DWORD);
// 10008040: using guessed type int __cdecl j_HWM_pvg_dspl_bklt_get_frmt_avg_adc(_DWORD, _DWORD, _DWORD);
// 10008050: using guessed type int __cdecl j_HWM_pvg_dspl_bklt_get_rgb_pwm(_DWORD, _DWORD, _DWORD);
// 10008060: using guessed type int __cdecl j_HWM_pvg_dspl_bklt_get_wht_pnt_sts(_DWORD);
// 10008080: using guessed type int __cdecl j_HWM_pvg_get_frmt_adc(_DWORD);
// 10008090: using guessed type int __cdecl j_HWM_pvg_get_raw_adc(_DWORD);

//----- (10007390) --------------------------------------------------------
void __cdecl sub_10007390(int a1, int a2)
{
  int v2; // eax@2
  int v3; // eax@2
  int v4; // eax@2
  int v5; // ST58_4@3
  int v6; // ST58_4@4
  double v7; // ST60_8@5
  double v8; // ST58_8@5
  double v9; // ST50_8@5
  double v10; // ST48_8@5
  double v11; // ST40_8@5
  double v12; // ST38_8@5
  double v13; // ST30_8@5
  double v14; // ST28_8@5
  double v15; // ST20_8@5
  int v16; // eax@5
  int v17; // eax@5
  double v18; // ST60_8@5
  double v19; // ST58_8@5
  double v20; // ST50_8@5
  double v21; // ST48_8@5
  double v22; // ST40_8@5
  double v23; // ST38_8@5
  double v24; // st7@5
  int v25; // eax@5
  int v26; // ST64_4@6
  int v27; // ST60_4@6
  int v28; // ST5C_4@6
  double v29; // ST54_8@6
  double v30; // ST4C_8@6
  double v31; // st7@6
  int v32; // eax@6
  int v33; // eax@7
  char v34; // [sp+58h] [bp-70h]@1

  memset(&v34, 0, 0x64u);
  if ( !a2 )
  {
    v2 = sub_10015290((int)&v34, "line, tsk_get_timer, Photocell A %(right), Photocell B %(left), bezel temp C, ", 100);
    sub_10001940(a1, &v34, v2);
    v3 = sub_10015290(
           (int)&v34,
           "internal temp C, internal temp2 C, ccft curr1, ccft curr2,  pwr 2.5v, pwr 3.3v, pwr 28A, ",
           100);
    sub_10001940(a1, &v34, v3);
    v4 = sub_10015290((int)&v34, "pwr 28B, pwr 1.3V, light bus DC, light bus DC2, light bus AC, light bus AC2", 100);
    sub_10001940(a1, &v34, v4);
    if ( sub_10030750() )
    {
      v5 = sub_10015290((int)&v34, ", LED temp1, LED temp2, LED temp3, Fan1, Fan2, Fan3\r\n", 100);
      sub_10001940(a1, &v34, v5);
    }
    else
    {
      v6 = sub_10015290((int)&v34, word_10047844, 100);
      sub_10001940(a1, &v34, v6);
    }
  }
  v7 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(5) / 1000.0;
  v8 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(4) / 1000.0;
  v9 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(14) / 100.0;
  v10 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(3) / 100.0;
  v11 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(16) / 100.0;
  v12 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(15) / 100.0;
  v13 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(2) / 100.0;
  v14 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(1) / 100.0;
  v15 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(0) / 100.0;
  v16 = sub_10030040();
  v17 = sub_100153B0(
          &v34,
          0x64u,
          "%lu,%lu,%5.2f,%5.2f,%5.2f,%5.2f,%5.2f,%5.2f,%5.2f,%5.2f,%5.2f,",
          a2,
          v16,
          v15,
          v14,
          v13,
          v12,
          v11,
          v10,
          v9,
          v8,
          v7);
  sub_10001940(a1, &v34, v17);
  v18 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(18) / 100.0;
  v19 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(10) / 100.0;
  v20 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(17) / 100.0;
  v21 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(9) / 100.0;
  v22 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(8) / 1000.0;
  v23 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(6) / 100.0;
  v24 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(7) / 100.0;
  v25 = sprintf(&v34, "%5.2f,%5.2f,%5.2f,%5.2f,%5.2f,%5.2f,%5.2f", v24, v23, v22, v21, v20, v19, v18);
  sub_10001940(a1, &v34, v25);
  if ( sub_10030750() )
  {
    v26 = (signed __int16)j_HWM_pvg_get_raw_adc(21);
    v27 = (signed __int16)j_HWM_pvg_get_raw_adc(20);
    v28 = (signed __int16)j_HWM_pvg_get_raw_adc(19);
    v29 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(26) / 100.0;
    v30 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(25) / 100.0;
    v31 = (double)(signed __int16)j_HWM_pvg_get_frmt_adc(24) / 100.0;
    v32 = sprintf(&v34, ",%5.2f,%5.2f,%5.2f,%i,%i,%i\r\n", v31, v30, v29, v28, v27, v26);
    sub_10001940(a1, &v34, v32);
  }
  else
  {
    v33 = sub_10015290((int)&v34, word_10047844, 100);
    sub_10001940(a1, &v34, v33);
  }
}
// 10008080: using guessed type int __cdecl j_HWM_pvg_get_frmt_adc(_DWORD);
// 10008090: using guessed type int __cdecl j_HWM_pvg_get_raw_adc(_DWORD);

//----- (10007760) --------------------------------------------------------
signed int sub_10007760()
{
  signed int result; // eax@1

  sub_10030EE0();
  sub_10019170();
  sub_1000DC80();
  sub_10019130();
  sub_10019060();
  nullsub_2();
  sub_10017260();
  sub_10016FE0();
  sub_1000A180();
  sub_10011DD0();
  sub_10030220(5);
  sub_100099C0();
  sub_10016F00();
  result = -15;
  dword_1020D818 = -15;
  dword_1020D814 = -15;
  return result;
}
// 100303E0: using guessed type int nullsub_2(void);
// 10030EE0: using guessed type int sub_10030EE0(void);
// 1020D814: using guessed type int dword_1020D814;
// 1020D818: using guessed type int dword_1020D818;

//----- (100077B0) --------------------------------------------------------
int __cdecl sub_100077B0(int a1, char *a2, char a3, int a4)
{
  char v5; // [sp+8h] [bp-10h]@1

  v5 = 0;
  sub_10015440(a4, (int)&v5, 8);
  return sub_100153B0(a2, (unsigned __int8)a3, "%s/%s_.bmp", a1, &v5);
}

//----- (10007810) --------------------------------------------------------
char __thiscall sub_10007810(void *this)
{
  int v1; // ecx@1
  char result; // al@2
  char v3; // al@3
  int v4; // [sp-2h] [bp-4h]@3

  if ( sub_10014FA0(this) & 0xF0 )
  {
    v4 = v1;
    BYTE3(v4) = 0;
    v3 = sub_1000ED60(3, 108, (char *)&v4 + 3);
    result = BYTE3(v4) && v3;
  }
  else
  {
    result = sub_10030A00((int)"/mnt/card0/print");
  }
  return result;
}

//----- (10007830) --------------------------------------------------------
int __cdecl sub_10007830(char *a1, size_t a2)
{
  void *v2; // ecx@0
  void *v3; // ecx@2
  int v4; // eax@2
  int result; // eax@2

  if ( sub_10014FA0(v2) & 0xF0 )
  {
    j_FIL_vfs_mkdir("/mnt/sys_nand0/print", 0);
    v4 = sub_10014FA0(v3);
    sub_100077B0((int)"/mnt/sys_nand0/print", a1, 64, v4);
    result = j_FIL_vfs_open(a1, 14, 0);
  }
  else
  {
    j_FIL_vfs_mkdir("/mnt/card0/print", 0);
    if ( (signed int)a2 >= 36 )
    {
      sub_10015290((int)a1, "/mnt/card0/print/GDU_screen.bmp", a2);
      sub_10030A60(a1, a2, 10000, 4);
      result = j_FIL_vfs_open(a1, 30, 0);
    }
    else
    {
      result = -15;
    }
  }
  return result;
}
// 10030830: using guessed type int __cdecl j_FIL_vfs_mkdir(_DWORD, _DWORD);
// 10030850: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (100078C0) --------------------------------------------------------
unsigned int __cdecl sub_100078C0(unsigned int a1, char a2)
{
  unsigned int v2; // esi@1
  char v3; // bl@1
  unsigned int result; // eax@1
  unsigned int v5; // edi@1
  int v6; // ebp@8
  void *v7; // ecx@9
  void *v8; // ecx@9
  int v9; // eax@10
  char v10; // [sp+Ch] [bp-44h]@1

  v2 = a1;
  memset(&v10, 0, 0x40u);
  v3 = 0;
  result = j_FIL_vfs_open("/dev/Display.bmp", 4, 0);
  v5 = result;
  if ( result < 0xFFFFFFC2 && result )
  {
    if ( a1 )
    {
      sub_10015290((int)&v10, "file", 64);
    }
    else
    {
      v3 = 1;
      v2 = sub_10007830(&v10, 0x40u);
    }
    if ( v2 < 0xFFFFFFC2 && v2 )
    {
      v6 = j_FIL_vfs_copy(v2, v5);
      if ( sub_10014FA0(v7) & 0xF0 )
      {
        v9 = sub_10014FA0(v8);
        sub_100191B0(v9, 4, 0x45u);
      }
      if ( a2 )
        j_FIL_vfs_sync_all();
    }
    else
    {
      v6 = v2;
    }
    sub_10030770(v5);
    if ( v3 )
      sub_10030770(v2);
    result = v6;
  }
  return result;
}
// 100307B0: using guessed type int __cdecl j_FIL_vfs_copy(_DWORD, _DWORD);
// 10030850: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 100309A0: using guessed type int j_FIL_vfs_sync_all(void);

//----- (100079A0) --------------------------------------------------------
unsigned int __cdecl sub_100079A0(char a1, char a2)
{
  void *v2; // ecx@0
  void *v3; // ecx@1
  unsigned int result; // eax@7
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1
  int v7; // [sp+Ch] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  if ( sub_10014FA0(v2) & 0xF && sub_10007810(v3) && (unsigned __int8)j_HWM_pvg_read_keys(&v5) && v5 & 0x100 && v5 & 4
    || a2 )
  {
    result = sub_100078C0(0, a1);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10008140: using guessed type int __cdecl j_HWM_pvg_read_keys(_DWORD);

//----- (10007A10) --------------------------------------------------------
int __cdecl sub_10007A10(int a1, char a2, void (__cdecl *a3)(int, char *, int), int a4)
{
  unsigned int v4; // eax@1
  char *v5; // eax@4
  unsigned int v6; // ST40_4@4
  int v7; // eax@4
  double v8; // ST48_8@4
  int v9; // ST44_4@4
  unsigned int v10; // ST3C_4@4
  int v11; // eax@4
  int result; // eax@4
  int v13; // eax@7
  int v14; // eax@8
  int v15; // eax@8
  int v16; // eax@10
  int v17; // eax@10
  int v18; // eax@10
  int v19; // eax@10
  int v20; // eax@10
  int v21; // eax@10
  int v22; // eax@11
  int v23; // esi@12
  int v24; // ebx@14
  int v25; // eax@19
  int v26; // [sp+2Ch] [bp-1A0h]@10
  float v27; // [sp+30h] [bp-19Ch]@4
  int v28; // [sp+34h] [bp-198h]@1
  unsigned int v29; // [sp+38h] [bp-194h]@1
  char v30[4]; // [sp+3Ch] [bp-190h]@10
  int v31; // [sp+40h] [bp-18Ch]@14
  int v32; // [sp+44h] [bp-188h]@14
  int v33; // [sp+48h] [bp-184h]@14
  int v34[60]; // [sp+4Ch] [bp-180h]@14
  char v35[4]; // [sp+13Ch] [bp-90h]@1
  int v36; // [sp+140h] [bp-8Ch]@1
  int v37; // [sp+144h] [bp-88h]@1
  int v38; // [sp+148h] [bp-84h]@1
  int v39; // [sp+14Ch] [bp-80h]@1
  char v40[4]; // [sp+150h] [bp-7Ch]@1
  int v41; // [sp+154h] [bp-78h]@1
  int v42; // [sp+158h] [bp-74h]@1
  int v43; // [sp+15Ch] [bp-70h]@1
  int v44; // [sp+160h] [bp-6Ch]@1
  char v45; // [sp+164h] [bp-68h]@1

  v29 = 0;
  memset(&v45, 0, 0x64u);
  *(_DWORD *)v40 = 0;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  *(_DWORD *)v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v4 = *(_DWORD *)(a1 + 16);
  v28 = 0;
  if ( v4 >= 0x40 )
    sprintf(v35, "%lu", v4);
  else
    sub_10030060((int)v35, 1, v4, 20);
  v5 = sub_10019230(*(_DWORD *)a1);
  strncpy(v40, v5, 0x14u);
  v6 = *(_DWORD *)(a1 + 4);
  BYTE3(v44) = 0;
  sub_100156A0((int)&v29, v6);
  sub_10015790((int)&v28, *(_DWORD *)(a1 + 4));
  v7 = sub_100153B0(
         &v45,
         0x64u,
         "%02u/%02u/%02u %02u:%02u:%02u PwrCnt:%-6lu %-20s %-15s\r\n",
         (unsigned __int8)v29,
         BYTE1(v29),
         HIWORD(v29) % 100,
         (signed __int16)v28,
         BYTE2(v28),
         BYTE3(v28),
         *(_DWORD *)(a1 + 8),
         v40,
         v35);
  a3(a4, &v45, v7);
  LODWORD(v27) = *(_WORD *)(a1 + 594);
  v8 = (double)SLODWORD(v27) / 100.0;
  v9 = *(_BYTE *)(a1 + 600);
  v10 = *(_DWORD *)(a1 + 12) / 0xE10u;
  v27 = (double)*(unsigned int *)(a1 + 596) / 1000.0;
  v11 = sub_100153B0(
          &v45,
          0x64u,
          "    OnSecs:%-9.3f PwrHrs:%-5lu  SwVer:%s Rpt:%-3u Temp:%5.2fC\r\n",
          v27,
          v10,
          a1 + 585,
          v9,
          v8);
  a3(a4, &v45, v11);
  result = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == -5 || result == -44 )
  {
    v14 = sub_100153B0(&v45, 0x64u, "    F:%-30s L:%-5ld\r\n", a1 + 464, *(_DWORD *)(a1 + 460));
    a3(a4, &v45, v14);
    v15 = sub_100153B0(&v45, 0x64u, "    MSG:%-60s\r\n", a1 + 485);
    result = ((int (__cdecl *)(int, char *, int))a3)(a4, &v45, v15);
  }
  else if ( result == -45 )
  {
    v13 = sub_100153B0(&v45, 0x64u, "    MSG:%-60s\r\n", a1 + 485);
    result = ((int (__cdecl *)(int, char *, int))a3)(a4, &v45, v13);
  }
  if ( a2 )
  {
    v16 = sub_100153B0(
            &v45,
            0x64u,
            "    R0=0x%08lX  R5=0x%08lX R10= 0x%08lX PC=   0x%08lX\r\n",
            *(_DWORD *)(a1 + 20),
            *(_DWORD *)(a1 + 40),
            *(_DWORD *)(a1 + 60),
            *(_DWORD *)(a1 + 84));
    a3(a4, &v45, v16);
    v17 = sub_100153B0(
            &v45,
            0x64u,
            "    R1=0x%08lX  R6=0x%08lX R11= 0x%08lX LR=   0x%08lX\r\n",
            *(_DWORD *)(a1 + 24),
            *(_DWORD *)(a1 + 44),
            *(_DWORD *)(a1 + 64),
            *(_DWORD *)(a1 + 76));
    a3(a4, &v45, v17);
    v18 = sub_100153B0(
            &v45,
            0x64u,
            "    R2=0x%08lX  R7=0x%08lX R12= 0x%08lX FSR=  0x%08lX\r\n",
            *(_DWORD *)(a1 + 28),
            *(_DWORD *)(a1 + 48),
            *(_DWORD *)(a1 + 68),
            *(_DWORD *)(a1 + 88));
    a3(a4, &v45, v18);
    v19 = sub_100153B0(
            &v45,
            0x64u,
            "    R3=0x%08lX  R8=0x%08lX CPSR=0x%08lX FADDR=0x%08lX\r\n",
            *(_DWORD *)(a1 + 32),
            *(_DWORD *)(a1 + 52),
            *(_DWORD *)(a1 + 80),
            *(_DWORD *)(a1 + 92));
    a3(a4, &v45, v19);
    v20 = sub_100153B0(
            &v45,
            0x64u,
            "    R4=0x%08lX  R9=0x%08lX SP=  0x%08lX\r\n",
            *(_DWORD *)(a1 + 36),
            *(_DWORD *)(a1 + 56),
            *(_DWORD *)(a1 + 72));
    a3(a4, &v45, v20);
    v26 = 64;
    sub_10011DF0(a1 + 96, (int)v30, &v26);
    v21 = v26;
    if ( v26 > 0 )
    {
      v22 = sub_100153B0(&v45, 0x64u, "CPU Trace:\r\n");
      a3(a4, &v45, v22);
      v21 = v26;
    }
    v23 = 0;
    if ( v21 > 0 )
    {
      do
      {
        if ( v21 - v23 < 5 )
        {
          v24 = sub_100153B0(&v45, 0x64u, "    0x%08lX", *(_DWORD *)&v30[4 * v23]);
          if ( v23 == v26 - 1 )
          {
            sub_100153E0(&v45, word_10047844, 100);
            v24 += 2;
          }
          ++v23;
        }
        else
        {
          v24 = sub_100153B0(
                  &v45,
                  0x64u,
                  "    0x%08lX    0x%08lX    0x%08lX    0x%08lX    0x%08lX\r\n",
                  *(_DWORD *)&v30[4 * v23],
                  *(&v31 + v23),
                  *(&v32 + v23),
                  *(&v33 + v23),
                  v34[v23]);
          v23 += 5;
        }
        a3(a4, &v45, v24);
        v21 = v26;
      }
      while ( v23 < v26 );
    }
    v25 = sub_100153B0(&v45, 0x64u, "--------------------------------------------------------------------\r\n");
    result = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD))a3)(a4, &v45, v25);
  }
  return result;
}
// 10007A10: using guessed type int var_180[60];

//----- (10007ED0) --------------------------------------------------------
int __cdecl sub_10007ED0(_DWORD *a1, unsigned int a2)
{
  int result; // eax@2

  if ( a2 > 0x63 )
  {
    sub_10014D70("..\\lib\\acl\\kernel\\hwm_fil.c", 779, 0, 0);
    result = -15;
  }
  else
  {
    result = sub_100303F0(a2 + 7000, (int)a1, 640);
    if ( !result )
    {
      if ( *a1 > 0 || *a1 <= -62 )
        result = -24;
      else
        result = 0;
    }
  }
  return result;
}

//----- (10007F30) --------------------------------------------------------
int __cdecl sub_10007F30(int a1, unsigned int a2)
{
  int result; // eax@2

  if ( a2 > 0x63 )
  {
    sub_10014D70("..\\lib\\acl\\kernel\\hwm_fil.c", 953, 0, 0);
    result = -15;
  }
  else
  {
    result = sub_100304C0(a2 + 7000, a1, 640);
  }
  return result;
}

//----- (10007F70) --------------------------------------------------------
int __cdecl sub_10007F70(unsigned int a1)
{
  int v2; // [sp+0h] [bp-284h]@1

  v2 = 62;
  return sub_10007F30((int)&v2, a1);
}

//----- (10007FC0) --------------------------------------------------------
int sub_10007FC0()
{
  int v0; // edi@1
  signed int v1; // esi@1
  int v2; // eax@3
  char v4; // [sp+8h] [bp-68h]@4

  v0 = 0;
  v1 = 0;
  do
  {
    if ( v0 )
      break;
    v2 = sub_10007F70(v1++);
    v0 = v2;
  }
  while ( v1 < 100 );
  _snprintf(&v4, 0x64u, "Err log cleared with SW PN %s", "006-B0319-C1");
  sub_10014D70("..\\lib\\acl\\kernel\\hwm_fil.c", 622, 0, &v4);
  return v0;
}

//----- (10008170) --------------------------------------------------------
char __cdecl sub_10008170(void *a1, int a2)
{
  return sub_1000D2F0((unsigned __int16)word_100F5158, 0x1C8u, 0xFFFFFFF, a1, 1, a2);
}
// 100F5158: using guessed type __int16 word_100F5158;

//----- (100081A0) --------------------------------------------------------
int __thiscall sub_100081A0(void *this)
{
  int v1; // eax@1
  void *v2; // ebx@6
  void *v3; // ecx@7
  void *v4; // eax@7
  char *v5; // esi@8
  char v6; // dl@9
  bool v7; // zf@10
  bool v8; // sf@13
  unsigned __int8 v9; // of@13
  void *v10; // ebx@14
  void *v11; // ecx@15
  void *v12; // eax@15
  char *v13; // esi@16
  char v14; // dl@17
  void *v15; // ebx@22
  void *v16; // ecx@23
  void *v17; // eax@23
  char *v18; // esi@24
  char v19; // dl@25
  int result; // eax@29
  int v21; // [sp+10h] [bp-4h]@6
  int v22; // [sp+10h] [bp-4h]@14
  int v23; // [sp+10h] [bp-4h]@22

  dword_1020B2C0 = 1;
  dword_1020B2C4 = (int)&unk_1020B2E0;
  dword_1020B2C8 = 16;
  dword_1020B2CC = 456;
  dword_1020B2D0 = 0;
  dword_1020B2D4 = -1;
  v1 = sub_10014FA0(this) - 1;
  if ( v1 )
  {
    if ( v1 == 3 )
      word_100F5158 = 55;
    else
      word_100F5158 = 56;
  }
  else
  {
    word_100F5158 = 54;
  }
  dword_101089E0 = sub_10030040();
  dword_101089E4 = sub_10030040();
  dword_1013396C = sub_10030040();
  memset(&unk_100CE058, 0, 0x27100u);
  memset(&unk_1012FAE8, 0, 0x3E84u);
  v21 = 0;
  v2 = &unk_100CE079;
  do
  {
    sub_100303F0(v21 + 12000, (int)&unk_1012FAE8, 16004);
    v3 = v2;
    v4 = &unk_1012FAEA;
    v2 = (char *)v2 + 16000;
    do
    {
      *(_WORD *)((char *)v3 + 123) = *((_WORD *)v4 + 77);
      strcpy((char *)v3 - 31, (const char *)v4);
      v5 = (char *)v4 + 31;
      do
      {
        v6 = *v5;
        v5[(_BYTE *)v3 - ((_BYTE *)v4 + 31)] = *v5;
        ++v5;
      }
      while ( v6 );
      v7 = *((char *)v3 - 31) == 0;
      *((_BYTE *)v3 + 101) = *((_BYTE *)v4 + 132);
      *(_DWORD *)((char *)v3 + 107) = *(_DWORD *)((char *)v4 + 138);
      *((_BYTE *)v3 + 102) = *((_BYTE *)v4 + 133);
      *((_BYTE *)v3 + 104) = *((_BYTE *)v4 + 135);
      *(_WORD *)((char *)v3 + 99) = *((_WORD *)v4 + 65);
      *(_DWORD *)((char *)v3 + 111) = *(_DWORD *)((char *)v4 + 142);
      *(_WORD *)((char *)v3 + 105) = *((_WORD *)v4 + 68);
      *(_DWORD *)((char *)v3 + 119) = *(_DWORD *)((char *)v4 + 150);
      *(_WORD *)((char *)v3 - 33) = *((_WORD *)v4 - 1);
      *((_BYTE *)v3 + 93) = *((_BYTE *)v4 + 124);
      *((_BYTE *)v3 + 94) = *((_BYTE *)v4 + 125);
      *(_DWORD *)((char *)v3 + 95) = *(_DWORD *)((char *)v4 + 126);
      *((_BYTE *)v3 + 103) = *((_BYTE *)v4 + 134);
      if ( v7 )
        *(_WORD *)((char *)v3 - 33) = -1;
      v4 = (char *)v4 + 160;
      v3 = (char *)v3 + 160;
    }
    while ( (signed int)v4 < (signed int)&unk_1013396A );
    v9 = __OFSUB__(v21 + 1, 10);
    v8 = v21++ - 9 < 0;
  }
  while ( v8 ^ v9 );
  memset(&unk_100F5160, 0, 0x13880u);
  memset(&unk_1012FAE8, 0, 0x3E84u);
  v22 = 0;
  v10 = &unk_100F5181;
  do
  {
    sub_100303F0(v22 + 23000, (int)&unk_1012FAE8, 16004);
    v11 = v10;
    v12 = &unk_1012FAEA;
    v10 = (char *)v10 + 16000;
    do
    {
      *(_WORD *)((char *)v11 + 123) = *((_WORD *)v12 + 77);
      strcpy((char *)v11 - 31, (const char *)v12);
      v13 = (char *)v12 + 31;
      do
      {
        v14 = *v13;
        v13[(_BYTE *)v11 - ((_BYTE *)v12 + 31)] = *v13;
        ++v13;
      }
      while ( v14 );
      v7 = *((char *)v11 - 31) == 0;
      *((_BYTE *)v11 + 101) = *((_BYTE *)v12 + 132);
      *(_DWORD *)((char *)v11 + 107) = *(_DWORD *)((char *)v12 + 138);
      *((_BYTE *)v11 + 102) = *((_BYTE *)v12 + 133);
      *((_BYTE *)v11 + 104) = *((_BYTE *)v12 + 135);
      *(_WORD *)((char *)v11 + 99) = *((_WORD *)v12 + 65);
      *(_DWORD *)((char *)v11 + 111) = *(_DWORD *)((char *)v12 + 142);
      *(_WORD *)((char *)v11 + 105) = *((_WORD *)v12 + 68);
      *(_DWORD *)((char *)v11 + 119) = *(_DWORD *)((char *)v12 + 150);
      *(_WORD *)((char *)v11 - 33) = *((_WORD *)v12 - 1);
      *((_BYTE *)v11 + 93) = *((_BYTE *)v12 + 124);
      *((_BYTE *)v11 + 94) = *((_BYTE *)v12 + 125);
      *(_DWORD *)((char *)v11 + 95) = *(_DWORD *)((char *)v12 + 126);
      *((_BYTE *)v11 + 103) = *((_BYTE *)v12 + 134);
      if ( v7 )
        *(_WORD *)((char *)v11 - 33) = -1;
      v12 = (char *)v12 + 160;
      v11 = (char *)v11 + 160;
    }
    while ( (signed int)v12 < (signed int)&unk_1013396A );
    v9 = __OFSUB__(v22 + 1, 5);
    v8 = v22++ - 4 < 0;
  }
  while ( v8 ^ v9 );
  memset(&unk_101089E8, 0, 0x27100u);
  memset(&unk_1012FAE8, 0, 0x3E84u);
  v23 = 0;
  v15 = &unk_10108A09;
  do
  {
    sub_100303F0(v23 + 14000, (int)&unk_1012FAE8, 16004);
    v16 = v15;
    v17 = &unk_1012FAEA;
    v15 = (char *)v15 + 16000;
    do
    {
      *(_WORD *)((char *)v16 + 123) = *((_WORD *)v17 + 77);
      strcpy((char *)v16 - 31, (const char *)v17);
      v18 = (char *)v17 + 31;
      do
      {
        v19 = *v18;
        v18[(_BYTE *)v16 - ((_BYTE *)v17 + 31)] = *v18;
        ++v18;
      }
      while ( v19 );
      v7 = *((char *)v16 - 31) == 0;
      *((_BYTE *)v16 + 101) = *((_BYTE *)v17 + 132);
      *(_DWORD *)((char *)v16 + 107) = *(_DWORD *)((char *)v17 + 138);
      *((_BYTE *)v16 + 102) = *((_BYTE *)v17 + 133);
      *((_BYTE *)v16 + 104) = *((_BYTE *)v17 + 135);
      *(_WORD *)((char *)v16 + 99) = *((_WORD *)v17 + 65);
      *(_DWORD *)((char *)v16 + 111) = *(_DWORD *)((char *)v17 + 142);
      *(_WORD *)((char *)v16 + 105) = *((_WORD *)v17 + 68);
      *(_DWORD *)((char *)v16 + 119) = *(_DWORD *)((char *)v17 + 150);
      *(_WORD *)((char *)v16 - 33) = *((_WORD *)v17 - 1);
      *((_BYTE *)v16 + 93) = *((_BYTE *)v17 + 124);
      *((_BYTE *)v16 + 94) = *((_BYTE *)v17 + 125);
      *(_DWORD *)((char *)v16 + 95) = *(_DWORD *)((char *)v17 + 126);
      *((_BYTE *)v16 + 103) = *((_BYTE *)v17 + 134);
      if ( v7 )
        *(_WORD *)((char *)v16 - 33) = -1;
      v17 = (char *)v17 + 160;
      v16 = (char *)v16 + 160;
    }
    while ( (signed int)v17 < (signed int)&unk_1013396A );
    result = v23 + 1;
    v9 = __OFSUB__(v23 + 1, 10);
    v8 = v23++ - 9 < 0;
  }
  while ( v8 ^ v9 );
  return result;
}
// 100F5158: using guessed type __int16 word_100F5158;
// 101089E0: using guessed type int dword_101089E0;
// 101089E4: using guessed type int dword_101089E4;
// 1013396C: using guessed type int dword_1013396C;
// 1020B2C0: using guessed type int dword_1020B2C0;
// 1020B2C4: using guessed type int dword_1020B2C4;
// 1020B2C8: using guessed type int dword_1020B2C8;
// 1020B2CC: using guessed type int dword_1020B2CC;
// 1020B2D0: using guessed type int dword_1020B2D0;
// 1020B2D4: using guessed type int dword_1020B2D4;

//----- (10008600) --------------------------------------------------------
char sub_10008600()
{
  return 0;
}

//----- (10008610) --------------------------------------------------------
void __usercall sub_10008610(char a1@<bl>)
{
  unsigned int v1; // esi@2
  unsigned int v2; // [sp+4h] [bp-4h]@0

  if ( a1 == 1 )
  {
    v1 = j_FIL_vfs_open("/mnt/card0/atm/cas_cov.bin", 2, 0);
  }
  else if ( a1 )
  {
    if ( a1 == 2 )
      v1 = j_FIL_vfs_open("/mnt/card0/atm/sys_cov.bin", 2, 0);
    else
      v1 = v2;
  }
  else
  {
    v1 = j_FIL_vfs_open("/mnt/card0/atm/log_cov.bin", 2, 0);
  }
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    if ( sub_10016940((int)&unk_10133970, a1) )
    {
      j_FIL_vfs_write(v1, &unk_10133970, 10000);
      sub_10030770(v1);
    }
  }
}
// 10030850: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 100309D0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (100086A0) --------------------------------------------------------
char __thiscall sub_100086A0(void *this)
{
  unsigned int v1; // edi@1
  int v2; // ebx@1
  int v3; // edx@1
  char v4; // al@1
  void *v5; // ecx@1
  __int16 v6; // ax@2
  char result; // al@2
  char v8; // al@10
  char v9; // al@14
  int v10; // ecx@18
  unsigned __int16 v11; // dx@19
  void *v12; // ecx@28
  bool v13; // zf@34
  const char *v14; // eax@34
  signed int v15; // esi@38
  const char *v16; // eax@44
  void *v17; // ecx@47
  const char *v18; // eax@47
  unsigned int v19; // eax@50
  unsigned int v20; // esi@50
  unsigned int v21; // eax@56
  unsigned int v22; // esi@56
  unsigned int v23; // eax@61
  unsigned int v24; // esi@61
  unsigned int v25; // eax@67
  unsigned int v26; // esi@67
  unsigned __int8 v27; // bl@72
  unsigned int v28; // esi@74
  int v29; // edi@79
  const void *v30; // esi@81
  char v31; // bl@82
  int v32; // eax@86
  int v33; // esi@92
  int v34; // esi@95
  char *v35; // [sp-Ch] [bp-8D4h]@97
  char *v36; // [sp-4h] [bp-8CCh]@97
  char v37; // [sp+13h] [bp-8B5h]@12
  __int16 v38; // [sp+14h] [bp-8B4h]@52
  char v39; // [sp+16h] [bp-8B2h]@53
  char v40; // [sp+1Bh] [bp-8ADh]@85
  int v41; // [sp+1Ch] [bp-8ACh]@28
  __int16 v42; // [sp+20h] [bp-8A8h]@103
  char v43; // [sp+28h] [bp-8A0h]@23
  __int16 v44; // [sp+2Ch] [bp-89Ch]@13
  char v45; // [sp+2Eh] [bp-89Ah]@13
  char v46; // [sp+2Fh] [bp-899h]@13
  int v47; // [sp+30h] [bp-898h]@16
  char v48; // [sp+50h] [bp-878h]@13
  char v49; // [sp+ECh] [bp-7DCh]@13
  char v50; // [sp+EDh] [bp-7DBh]@1
  int v51; // [sp+1F0h] [bp-6D8h]@10
  int v52; // [sp+290h] [bp-638h]@79
  __int16 v53; // [sp+2C0h] [bp-608h]@107
  char v54; // [sp+2F8h] [bp-5D0h]@14
  char v55; // [sp+461h] [bp-467h]@59

  v1 = 0;
  v2 = (int)this;
  memset(&v50, 0, 0x100u);
  v4 = *(_BYTE *)v2;
  v5 = (void *)*(_BYTE *)v2;
  switch ( v5 )
  {
    case 0u:
      v6 = TXT_get_hndl(v5, v3);
      sub_10019970(v6);
      return 1;
    case 0xBu:
      sub_10019A10((_BYTE *)(v2 + 4), (_BYTE *)(v2 + 68));
      return 1;
    case 1u:
      sub_10019820((_BYTE *)(v2 + 4));
      return 1;
    case 3u:
      sub_100193A0(*(_BYTE *)(v2 + 4), (_BYTE *)(v2 + 5));
      return 1;
    case 2u:
      sub_10019B40((_BYTE *)(v2 + 4));
      return 1;
    case 4u:
      sub_10019D10();
      return 1;
    case 5u:
      sub_10019500(v5);
      return 1;
    case 7u:
      if ( *(_WORD *)(v2 + 40) > 0x7CFu )
        v8 = sub_10019EE0((int)&v51, v2 + 42, *(_BYTE *)(v2 + 166), 3);
      else
        v8 = sub_10019EB0((int)&v51, *(_WORD *)(v2 + 40));
      v37 = v8;
      if ( v8 )
      {
        v49 = 1;
        qmemcpy(&v48, &v51, 0x9Cu);
        HIBYTE(v44) = sub_10019F40(v51);
        v45 = sub_10008600();
        v46 = v45;
        if ( (unsigned __int16)v51 > 0x7CFu )
          v9 = sub_10019F60(v2 + 9);
        else
          v9 = sub_10019F10((int)&v51, (int)&v54);
        LOBYTE(v44) = v9;
        sub_10015290((int)&v47 + 1, (_BYTE *)(v2 + 9), 31);
        if ( (unsigned __int16)(v51 - 1000) > 0x3E7u )
        {
          v10 = 80 * (unsigned __int16)v51;
          if ( (unsigned __int16)v51 > 0x3E7u )
            v11 = word_100F51FC[v10];
          else
            v11 = word_10108A84[v10];
          LOBYTE(v47) = sub_10016AA0(v51, v11) == 2;
        }
        else
        {
          LOBYTE(v47) = sub_10016AA0(v51, word_100CE0F4[80 * (unsigned __int16)v51]) == 2;
        }
      }
      else
      {
        v49 = 0;
        sub_10015290((int)&v50, "Alert does not exist.", 256);
      }
      v43 = 7;
      goto LABEL_24;
    case 8u:
      sub_10019250((_BYTE *)(v2 + 4));
      return 1;
    case 9u:
      sub_100196E0((_BYTE *)(v2 + 4));
      return 1;
    case 0xAu:
      v41 = sub_10015630(v5);
      if ( sub_10014FA0(v12) == 4 && v41 & 1 && v41 & 4 && v41 & 2 )
      {
        SIM_proc_rqst(26 - (*(_BYTE *)(v2 + 4) != 0));
        SIM_proc_rqst(28 - (*(_BYTE *)(v2 + 4) != 0));
      }
      else
      {
        SIM_proc_rqst(26 - (*(_BYTE *)(v2 + 4) != 0));
      }
      v13 = *(_BYTE *)(v2 + 4) == 0;
      v43 = 10;
      v49 = 1;
      v14 = "ON";
      if ( v13 )
        v14 = "OFF";
      sub_100153B0(&v50, 0x100u, "Reversionary mode = %s", v14);
      goto LABEL_37;
    case 0x1Eu:
      v15 = 0;
      switch ( *(_BYTE *)(v2 + 4) )
      {
        case 0x11:
          SIM_proc_rqst(31 - (*(_BYTE *)(v2 + 5) != 0));
          break;
        case 1:
          SIM_proc_rqst(22 - (*(_BYTE *)(v2 + 5) != 0));
          break;
        case 0xC:
          SIM_proc_rqst(26 - (*(_BYTE *)(v2 + 5) != 0));
          break;
        case 0xD:
          SIM_proc_rqst(28 - (*(_BYTE *)(v2 + 5) != 0));
          break;
        default:
          v15 = -15;
          break;
      }
      v13 = *(_BYTE *)(v2 + 5) == 0;
      v43 = 30;
      v49 = v15 == 0;
      v16 = "ON";
      if ( v13 )
        v16 = "OFF";
      sub_100153B0(&v50, 0x100u, "HWM_reg_id_t8 pin %d state = %s", *(_BYTE *)(v2 + 4), v16);
      sub_10008170(&v43, (int)&byte_1020B260);
      return 1;
    case 0xCu:
      sub_100155A0(*(_BYTE *)(v2 + 4));
      v43 = 12;
      v49 = 1;
      v13 = sub_10015580(v17) == 0;
      v18 = "ON";
      if ( v13 )
        v18 = "OFF";
      sub_100153B0(&v50, 0x100u, "Auto test mode = %s", v18);
LABEL_37:
      sub_10008170(&v43, (int)&byte_1020B260);
      return 1;
    case 0xDu:
      v19 = j_FIL_vfs_open("/mnt/sys_nand0/atm_struct.bin", 4, 0);
      v20 = v19;
      if ( v19 < 0xFFFFFFC2 && v19 )
      {
        if ( (unsigned int)sub_10030860(v19, &v38, 3) < 3 )
        {
          v38 = 0;
          v39 = 0;
        }
        sub_10030770(v20);
      }
      else
      {
        v38 = 0;
        v39 = 0;
      }
      LOBYTE(v38) = 1;
      v21 = j_FIL_vfs_open("/mnt/sys_nand0/atm_struct.bin", 10, 0);
      v22 = v21;
      if ( v21 >= 0xFFFFFFC2 || !v21 || (v1 = j_FIL_vfs_write(v21, &v38, 3), sub_10030770(v22), v1 < 3) )
        sub_100153B0(&v55, 0x100u, "IOP_ATM_CLEAR_NONVOL file write failed");
      v43 = 13;
      v49 = v1 == 3;
      sub_10008170(&v43, (int)&byte_1020B260);
      return 1;
    case 0x1Au:
      v23 = j_FIL_vfs_open("/mnt/sys_nand0/atm_struct.bin", 4, 0);
      v24 = v23;
      if ( v23 < 0xFFFFFFC2 && v23 )
      {
        if ( (unsigned int)sub_10030860(v23, &v38, 3) < 3 )
        {
          v38 = 0;
          v39 = 0;
        }
        sub_10030770(v24);
      }
      else
      {
        v38 = 0;
        v39 = 0;
      }
      HIBYTE(v38) = 1;
      v25 = j_FIL_vfs_open("/mnt/sys_nand0/atm_struct.bin", 10, 0);
      v26 = v25;
      if ( v25 >= 0xFFFFFFC2 || !v25 || (v1 = j_FIL_vfs_write(v25, &v38, 3), sub_10030770(v26), v1 < 3) )
        sub_100153B0(&v55, 0x100u, "IOP_ATM_CLEAR_REG file write failed");
      v43 = 26;
      v49 = v1 == 3;
      goto LABEL_24;
    case 0xEu:
      v27 = *(_BYTE *)(v2 + 4);
      v43 = 14;
      v47 = 0;
      v44 = v27;
      if ( v27 )
      {
        if ( v27 == 1 )
          v28 = j_FIL_vfs_open("/mnt/card1", 260, 0);
        else
          v28 = v41;
      }
      else
      {
        v28 = j_FIL_vfs_open("/mnt/card0", 260, 0);
      }
      if ( v28 < 0xFFFFFFC2 )
      {
        if ( v28 )
        {
          v29 = j_FIL_vfs_ioctl(v28, 102, &v52, 48);
          sub_10030770(v28);
          if ( !v29 )
          {
            v47 = v52;
            HIBYTE(v44) = 1;
          }
        }
      }
      goto LABEL_24;
    case 0xFu:
      v30 = (const void *)(v2 + 4);
      if ( sub_10030A30(v2 + 4) && (v31 = *(_BYTE *)(v2 + 132), (unsigned __int8)v31 < 0x39u) )
      {
        sub_100171D0(v31, v30);
        v49 = 1;
        v43 = 15;
        sub_10008170(&v43, (int)&byte_1020B260);
      }
      else
      {
        v49 = 0;
        v43 = 15;
        sub_10008170(&v43, (int)&byte_1020B260);
      }
      return 1;
    case 0x10u:
      v43 = 16;
      v49 = sub_10017170(&v40);
      LOBYTE(v44) = v40;
      sub_10008170(&v43, (int)&byte_1020B260);
      return 1;
    case 0x11u:
      v43 = 17;
      v49 = 1;
      v32 = sub_10014FA0(v5);
      if ( (v32 & *(_DWORD *)(v2 + 4)) == v32 )
      {
        sub_10008170(&v43, (int)&byte_1020B260);
        j_HWM_pvg_hsdb_set_lrus_reject(*(_DWORD *)(v2 + 4));
        result = 1;
      }
      else
      {
        j_HWM_pvg_hsdb_set_lrus_reject(*(_DWORD *)(v2 + 4));
        sub_10008170(&v43, (int)&byte_1020B260);
        result = 1;
      }
      return result;
    case 0x1Bu:
      v43 = 27;
      v49 = 1;
      sub_100304C0(19005, v2 + 4, 4);
      goto LABEL_112;
    case 0x12u:
      v43 = 18;
      v49 = 1;
      j_FIL_vfs_sync_all();
      sub_10008170(&v43, (int)&byte_1020B260);
      return 1;
    case 0x13u:
      sub_10019600((_BYTE *)(v2 + 4));
      return 1;
    case 0x14u:
      v37 = 1;
      v33 = sub_100304C0(19001, (int)&v37, 1);
      if ( v33 )
        sub_100153B0(&v55, 0x100u, "IOP_ATM_LOAD_SPLSH registry write failed");
      v43 = 20;
      v49 = v33 == 0;
      goto LABEL_24;
    case 0x15u:
    case 0x1Cu:
      v37 = 1;
      v34 = sub_100304C0((v4 == 28) + 19003, (int)&v37, 1);
      if ( v34 )
      {
        if ( *(_BYTE *)v2 == 21 )
        {
          v36 = "IOP_ATM_LOAD_AVTN_DB registry write failed";
          v35 = &v55;
        }
        else
        {
          v36 = "IOP_ATM_LOAD_AVTN_DB_2 registry write failed";
          v35 = &v55;
        }
        sub_100153B0(v35, 0x100u, v36);
      }
      v43 = *(_BYTE *)v2;
      v49 = v34 == 0;
      sub_10008170(&v43, (int)&byte_1020B260);
      return 1;
    case 0x16u:
      v43 = 22;
      v49 = sub_100304C0(19000, v2 + 4, 1) == 0;
      goto LABEL_112;
    case 0x17u:
      if ( !memcmp((const void *)(v2 + 4), "CAS", 4u) )
      {
        v42 = -32767;
        sub_100301C0(37, (int)&v42, 1000, 1);
        result = 1;
      }
      else if ( !memcmp((const void *)(v2 + 4), "CMC", 4u) || !memcmp((const void *)(v2 + 4), "LOG", 4u) )
      {
        v53 = -32752;
        sub_100301C0(49, (int)&v53, 1000, 1);
        result = 1;
      }
      else
      {
        v43 = 23;
        v49 = 0;
        sub_100153B0(&v50, 0x100u, "Can only clear 'CAS' or 'LOG'/'CMC' coverage.");
        sub_10008170(&v43, (int)&byte_1020B260);
LABEL_113:
        result = 1;
      }
      return result;
    case 0x19u:
      v49 = 0;
      if ( !sub_100304C0(19002, v2 + 4, 2) )
      {
        v49 = 1;
        sub_10015290((int)&v50, "Could not write display size.", 256);
      }
      v43 = 25;
LABEL_24:
      sub_10008170(&v43, (int)&byte_1020B260);
      return 1;
    case 0x1Du:
      v49 = 1;
      sub_100155A0(0);
      v44 = j_HWM_pvg_read_reg(0);
      sub_100155A0(1);
      v43 = 29;
LABEL_112:
      sub_10008170(&v43, (int)&byte_1020B260);
      goto LABEL_113;
    default:
      goto LABEL_113;
  }
}
// 10008150: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10008160: using guessed type int __cdecl j_HWM_pvg_hsdb_set_lrus_reject(_DWORD);
// 1002F614: using guessed type int __fastcall TXT_get_hndl(_DWORD, _DWORD);
// 100307D0: using guessed type int __cdecl j_FIL_vfs_ioctl(_DWORD, _DWORD, _DWORD, _DWORD);
// 10030850: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 100309A0: using guessed type int j_FIL_vfs_sync_all(void);
// 100309D0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 10032606: using guessed type int __cdecl SIM_proc_rqst(_DWORD);
// 100CE0F4: using guessed type __int16 word_100CE0F4[];
// 100F51FC: using guessed type __int16 word_100F51FC[];
// 10108A84: using guessed type __int16 word_10108A84[];
// 1020B260: using guessed type char byte_1020B260;

//----- (10009250) --------------------------------------------------------
char __cdecl sub_10009250(int a1, int a2)
{
  char result; // al@1
  void *v3; // ecx@3
  char v4; // [sp+4h] [bp-394h]@3
  char v5; // [sp+1CCh] [bp-1CCh]@7
  char v6; // [sp+290h] [bp-108h]@7
  char v7; // [sp+291h] [bp-107h]@1

  memset(&v7, 0, 0x100u);
  result = a1;
  if ( (_WORD)a1 == word_100F5158 && *(_BYTE *)(*(_DWORD *)(a2 + 48) + 1) )
  {
    sub_1000D640(a1, a2, &v4);
    if ( v4 == 12 )
    {
      result = sub_1001A070((int)&dword_1020B2C0, &v4);
    }
    else if ( sub_10015580(v3) )
    {
      result = sub_1001A070((int)&dword_1020B2C0, &v4);
    }
    else
    {
      v5 = v4;
      v6 = 0;
      sub_100153B0(&v7, 0x100u, "Auto test mode must be enabled for this command to be processed.");
      result = sub_10008170(&v5, (int)&byte_1020B260);
    }
  }
  return result;
}
// 100F5158: using guessed type __int16 word_100F5158;
// 1020B260: using guessed type char byte_1020B260;
// 1020B2C0: using guessed type int dword_1020B2C0;

//----- (10009370) --------------------------------------------------------
char sub_10009370()
{
  void *v0; // ecx@1
  char result; // al@11
  unsigned int v2; // [sp+0h] [bp-1D0h]@1
  char v3; // [sp+4h] [bp-1CCh]@2

  v2 = 0;
  if ( sub_1001A040((int)&dword_1020B2C0) )
  {
    sub_10019FD0((int)&dword_1020B2C0, &v3);
    sub_100086A0(&v3);
  }
  if ( sub_10015580(v0) && (unsigned int)(sub_10030040() - dword_101089E0) > 0x2710 )
  {
    dword_101089E0 = sub_10030040();
    if ( sub_10016A20(&v2, 1) && dword_101089E4 < v2 )
    {
      sub_10008610(1);
      dword_101089E4 = sub_10030040();
    }
    if ( sub_10016A20(&v2, 0) )
    {
      if ( dword_1013396C < v2 )
      {
        sub_10008610(0);
        dword_1013396C = sub_10030040();
      }
    }
    result = 1;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 101089E0: using guessed type int dword_101089E0;
// 101089E4: using guessed type int dword_101089E4;
// 1013396C: using guessed type int dword_1013396C;
// 1020B2C0: using guessed type int dword_1020B2C0;

//----- (10009480) --------------------------------------------------------
char __cdecl sub_10009480(int a1, int a2)
{
  char result; // al@1
  char v3; // [sp+0h] [bp-530h]@1
  __int16 v4; // [sp+4h] [bp-52Ch]@2
  int v5; // [sp+8h] [bp-528h]@2

  result = sub_1000D640(a1, a2, &v3);
  if ( result )
  {
    sub_100304C0(2048, (int)&v3, 4);
    v4 = -32752;
    v5 = 2048;
    result = sub_1001A220((int)&v4);
  }
  return result;
}

//----- (10009500) --------------------------------------------------------
char __cdecl sub_10009500(int a1, int a2)
{
  char result; // al@1
  char v3; // [sp+0h] [bp-530h]@1
  __int16 v4; // [sp+4h] [bp-52Ch]@2
  int v5; // [sp+8h] [bp-528h]@2

  result = sub_1000D640(a1, a2, &v3);
  if ( result )
  {
    sub_100304C0(2050, (int)&v3, 4);
    v4 = -32752;
    v5 = 2050;
    result = sub_1001A220((int)&v4);
  }
  return result;
}

//----- (10009580) --------------------------------------------------------
char __cdecl sub_10009580(int a1, int a2)
{
  char result; // al@1
  char v3; // [sp+0h] [bp-53Ch]@1
  __int16 v4; // [sp+10h] [bp-52Ch]@2
  int v5; // [sp+14h] [bp-528h]@2

  result = sub_1000D640(a1, a2, &v3);
  if ( result )
  {
    sub_100304C0(2051, (int)&v3, 16);
    v4 = -32752;
    v5 = 2051;
    result = sub_1001A220((int)&v4);
  }
  return result;
}

//----- (10009600) --------------------------------------------------------
char __cdecl sub_10009600(int a1, int a2)
{
  int v2; // ecx@0
  char result; // al@1
  int v4; // [sp-2h] [bp-4h]@1

  v4 = v2;
  result = sub_1000D640(a1, a2, (char *)&v4 + 3);
  if ( result )
  {
    if ( BYTE3(v4) > 0xFu )
      BYTE3(v4) = 15;
    result = sub_100304C0(2124, (int)&v4 + 3, 1);
  }
  return result;
}

//----- (10009640) --------------------------------------------------------
char __cdecl sub_10009640(int a1, int a2)
{
  char result; // al@1
  char v3; // [sp+3h] [bp-52Dh]@1
  __int16 v4; // [sp+4h] [bp-52Ch]@2
  int v5; // [sp+8h] [bp-528h]@2

  result = sub_1000D640(a1, a2, &v3);
  if ( result )
  {
    sub_100304C0(2119, (int)&v3, 1);
    v4 = -32752;
    v5 = 2119;
    result = sub_1001A220((int)&v4);
  }
  return result;
}

//----- (100096C0) --------------------------------------------------------
char __cdecl sub_100096C0(int a1, int a2)
{
  int v2; // ecx@0
  char result; // al@1
  int v4; // [sp-2h] [bp-4h]@1

  v4 = v2;
  result = sub_1000D640(a1, a2, (char *)&v4 + 3);
  if ( result )
    result = sub_100304C0(2053, (int)&v4 + 3, 1);
  return result;
}

//----- (10009700) --------------------------------------------------------
char __cdecl sub_10009700(int a1, int a2)
{
  int v2; // ecx@0
  char result; // al@1
  int v4; // [sp+0h] [bp-4h]@1

  v4 = v2;
  result = sub_1000D640(a1, a2, &v4);
  if ( result )
    result = sub_100304C0(2054, (int)&v4, 4);
  return result;
}

//----- (10009740) --------------------------------------------------------
char __cdecl sub_10009740(int a1, int a2)
{
  int v2; // ecx@0
  char result; // al@1
  int v4; // [sp+0h] [bp-4h]@1

  v4 = v2;
  result = sub_1000D640(a1, a2, &v4);
  if ( result )
    result = sub_100304C0(2055, (int)&v4, 4);
  return result;
}

//----- (10009780) --------------------------------------------------------
char __cdecl sub_10009780(int a1, int a2)
{
  char result; // al@1
  char v3; // al@2
  float v4; // ST10_4@2
  int v5; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@2

  result = sub_1000D640(a1, a2, &v5);
  if ( result )
  {
    v3 = sub_10031FE0();
    v4 = sub_10031F50(v3);
    sub_1001A250((int)&v6, v4);
    v5 += v6;
    result = sub_100304C0(2056, (int)&v5, 4);
  }
  return result;
}

//----- (100097E0) --------------------------------------------------------
char __cdecl sub_100097E0(int a1, int a2)
{
  int v2; // ecx@0
  char result; // al@1
  int v4; // [sp+0h] [bp-4h]@1

  v4 = v2;
  result = sub_1000D640(a1, a2, &v4);
  if ( result )
    result = sub_100304C0(2057, (int)&v4, 4);
  return result;
}

//----- (10009820) --------------------------------------------------------
char __cdecl sub_10009820(int a1, int a2)
{
  int v2; // eax@1
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = 0;
  LOBYTE(v5) = sub_100306E0(&v4);
  v2 = sub_10030040();
  return sub_1000C7A0(a1, v5, a2, &v4, v2);
}

//----- (10009860) --------------------------------------------------------
char __cdecl sub_10009860(int a1, int a2)
{
  char v2; // ST24_1@1
  int v3; // eax@1

  memset(&unk_10136080, 0, 0xECu);
  v2 = sub_1002F6A0(&unk_10136080);
  v3 = sub_10030040();
  return sub_1000C7A0(a1, v2, a2, &unk_10136080, v3);
}

//----- (100098B0) --------------------------------------------------------
char __cdecl sub_100098B0(int a1, int a2)
{
  char v2; // ST24_1@1
  int v3; // eax@1

  memset(&unk_1013616C, 0, 0x34u);
  v2 = sub_1002FE10(&unk_1013616C);
  v3 = sub_10030040();
  return sub_1000C7A0(a1, v2, a2, &unk_1013616C, v3);
}

//----- (100098F0) --------------------------------------------------------
char __cdecl sub_100098F0(int a1, int a2)
{
  __int16 v2; // kr00_2@1
  int v3; // eax@1
  char v5; // [sp+8h] [bp-5A0h]@1
  char v6; // [sp+2Ch] [bp-57Ch]@1

  sub_10032030((int)&v5);
  memset(&v6, 0, 0x578u);
  sub_100117F0(0, &v6, 0x578u, (int)&v5);
  v2 = strlen(&v6);
  v3 = sub_10030040();
  return sub_1000CAB0(a1, v2 + 1, 1, a2, &v6, v3);
}

//----- (10009990) --------------------------------------------------------
char __cdecl sub_10009990(int a1, int a2)
{
  int v2; // eax@1
  char v4; // [sp+1h] [bp-1h]@1

  v4 = sub_10030A00((int)"/mnt/card0/print");
  v2 = sub_10030040();
  return sub_1000C7A0(a1, 1, a2, &v4, v2);
}

//----- (100099C0) --------------------------------------------------------
int sub_100099C0()
{
  sub_10001020();
  sub_1000ADB0();
  return sub_10030190(32, 16);
}

//----- (100099E0) --------------------------------------------------------
char sub_100099E0()
{
  char v0; // bl@1
  unsigned __int8 v1; // di@2
  unsigned __int16 v2; // si@2
  char v3; // bl@5
  char v4; // bl@7
  char v5; // bl@9
  char v6; // bl@11
  unsigned __int16 v7; // si@17
  char v8; // bl@20
  char v9; // bl@22
  char v10; // bl@24
  char v11; // bl@26
  char result; // al@32
  int v13; // [sp+Ch] [bp-ACh]@1
  int v14; // [sp+10h] [bp-A8h]@1
  int v15; // [sp+14h] [bp-A4h]@5
  int v16; // [sp+18h] [bp-A0h]@1
  char v17; // [sp+1Ch] [bp-9Ch]@1
  char v18; // [sp+38h] [bp-80h]@14
  char v19; // [sp+50h] [bp-68h]@15

  LOBYTE(v13) = -1;
  memset(&v17, 0, 0x34u);
  v0 = 0;
  v14 = 0;
  LOBYTE(v16) = 0;
  do
  {
    v1 = v16;
    v2 = 0;
    do
    {
      sub_1001A280(v2, v1, &v13, &v14);
      switch ( (char)v13 )
      {
        case 6:
          if ( (unsigned __int16)v14 < 0x2E5u )
          {
            v3 = sub_1000E3C0(v13, v14, &v17);
            v0 = sub_1000E530(v13, v14, &v15) | v3;
          }
          break;
        case 0:
          if ( (unsigned __int16)v14 < 0x344u )
          {
            v4 = sub_1000E3C0(v13, v14, &v17);
            v0 = sub_1000E530(v13, v14, &v15) | v4;
          }
          break;
        case 1:
          if ( (unsigned __int16)v14 < 0xBCCu )
          {
            v5 = sub_1000E3C0(v13, v14, &v17);
            v0 = sub_1000E530(v13, v14, &v15) | v5;
          }
          break;
        case 2:
          if ( (unsigned __int16)v14 < 0x388u )
          {
            v6 = sub_1000E3C0(v13, v14, &v17);
            v0 = sub_1000E530(v13, v14, &v15) | v6;
          }
          break;
        default:
          sub_10014D70("..\\lib\\adl\\iop_d_dbg_main.c", 600, 0, 0);
          break;
      }
      if ( v0 && !(v18 & 2) )
      {
        sprintf(&v19, "PKT NOT ENABLED FOR CONFIG MODE: %s\n", v15);
        sub_10014D70("..\\lib\\adl\\iop_d_dbg_main.c", 632, 0, &v19);
      }
      ++v2;
    }
    while ( v2 < 0x319u );
    v7 = 0;
    do
    {
      sub_1001A2E0(v7, v1, &v13, &v14);
      switch ( (char)v13 )
      {
        case 6:
          if ( (unsigned __int16)v14 < 0x2E5u )
          {
            v8 = sub_1000E3C0(v13, v14, &v17);
            v0 = sub_1000E530(v13, v14, &v15) | v8;
          }
          break;
        case 0:
          if ( (unsigned __int16)v14 < 0x344u )
          {
            v9 = sub_1000E3C0(v13, v14, &v17);
            v0 = sub_1000E530(v13, v14, &v15) | v9;
          }
          break;
        case 1:
          if ( (unsigned __int16)v14 < 0xBCCu )
          {
            v10 = sub_1000E3C0(v13, v14, &v17);
            v0 = sub_1000E530(v13, v14, &v15) | v10;
          }
          break;
        case 2:
          if ( (unsigned __int16)v14 < 0x388u )
          {
            v11 = sub_1000E3C0(v13, v14, &v17);
            v0 = sub_1000E530(v13, v14, &v15) | v11;
          }
          break;
        default:
          sub_10014D70("..\\lib\\adl\\iop_d_dbg_main.c", 692, 0, 0);
          break;
      }
      if ( v0 )
      {
        if ( !(v18 & 2) )
        {
          sprintf(&v19, "PKT NOT ENABLED FOR CONFIG MODE: %s\n", v15);
          sub_10014D70("..\\lib\\adl\\iop_d_dbg_main.c", 706, 0, &v19);
        }
      }
      ++v7;
    }
    while ( v7 < 0x145u );
    result = v16 + 1;
    LOBYTE(v16) = v16 + 1;
  }
  while ( (unsigned __int8)v16 < 3u );
  return result;
}

//----- (10009D70) --------------------------------------------------------
void __thiscall sub_10009D70(void *this)
{
  signed int v1; // esi@1
  char v2; // bl@1
  void *v3; // ecx@1
  void *v4; // ecx@1
  char v5; // al@2
  bool v6; // [sp+Ah] [bp-6h]@1
  bool v7; // [sp+Bh] [bp-5h]@1
  int v8; // [sp+Ch] [bp-4h]@1

  v1 = 0;
  v8 = 0;
  v2 = 0;
  v6 = sub_1001A760(this);
  v7 = sub_1001A760(v3);
  do
  {
    v5 = sub_100168D0(v4);
    sub_1001A410(v5, v1, (int)&v8);
    if ( v6 && (unsigned __int8)v8 == 1 )
    {
      v2 = 1;
      sub_10006610(v1);
    }
    if ( v7 && BYTE1(v8) == 1 )
    {
      v2 = 1;
      sub_100011E0(v1);
    }
    ++v1;
  }
  while ( v1 < 2 );
  if ( !v2 )
  {
    sub_10006610(2);
    sub_100011E0(2);
  }
}

//----- (10009E00) --------------------------------------------------------
int sub_10009E00()
{
  int result; // eax@1
  void (__cdecl *v1)(_DWORD, char *); // eax@7
  char v2; // [sp+0h] [bp-530h]@1
  __int16 v3; // [sp+4h] [bp-52Ch]@1
  __int64 v4; // [sp+8h] [bp-528h]@3
  int v5; // [sp+10h] [bp-520h]@4
  char v6; // [sp+14h] [bp-51Ch]@4

  for ( result = sub_1002FFF0((int)&v3, (int)&v2); result != 1; result = sub_1002FFF0((int)&v3, (int)&v2) )
  {
    switch ( v3 )
    {
      case 0x8000:
        if ( BYTE4(v4) )
          sub_1000CAB0(*(int *)((char *)&v4 + 2), WORD3(v4), SBYTE1(v4), (int)&byte_1020B260, &v6, v5);
        else
          sub_1000C7A0(*(int *)((char *)&v4 + 2), SBYTE1(v4), (int)&byte_1020B260, &v6, v5);
        if ( (_BYTE)v4 == 1 )
        {
          v1 = *(void (__cdecl **)(_DWORD, char *))(52 * *(_WORD *)(dword_1020B288 + 2 * WORD1(v4)) + dword_1020B280 + 36);
          if ( v1 )
            v1(*(_DWORD *)((char *)&v4 + 2), &byte_1020B260);
        }
        break;
      case 0x8002:
        sub_1000CDA0(v4, SHIDWORD(v4), (int)&byte_1020B260);
        break;
      case 0x800B:
        sub_1000DAC0();
        break;
      case 0x800D:
        sub_1000A850();
        break;
      case 0x800C:
        sub_1000A860();
        break;
      case 0x800E:
        sub_1000A870(v4);
        break;
      case 0x800F:
        sub_1000A880((char *)&v4);
        break;
      case 0x8011:
        sub_1000EDF0(v4, (int)&byte_1020B260);
        break;
      case 0x8012:
        sub_1000A800();
        break;
      case 0x801B:
        sub_10001EC0((const char *)&v4 + 4, v4);
        break;
      case 0x801D:
        sub_1000A9E0();
        break;
      case 0x802D:
        sub_10008170(&v4, (int)&byte_1020B260);
        break;
      case 0x802E:
        sub_1000D060(*(int *)((char *)&v4 + 2), 0xFFFFFFF, &v6, 1, (int)&byte_1020B260);
        break;
      case 0x8040:
        sub_1000B150(SHIDWORD(v4), v4, v5, SWORD1(v4));
        break;
      default:
        continue;
    }
  }
  return result;
}
// 1020B260: using guessed type char byte_1020B260;
// 1020B280: using guessed type int dword_1020B280;
// 1020B288: using guessed type int dword_1020B288;

//----- (1000A080) --------------------------------------------------------
void __noreturn sub_1000A080()
{
  char v0; // bl@3
  void *v1; // ecx@6
  void *v2; // ecx@6
  char v3; // [sp+4h] [bp-4h]@3

  if ( !sub_10030260(8, 1000) )
    sub_10014D70("..\\lib\\adl\\iop_d_dbg_main.c", 358, 1, 0);
  v0 = 20;
  sub_1001A770();
  sub_100302D0(&v3);
  if ( !(v3 & 0x10) )
    sub_10014D70("..\\lib\\adl\\iop_d_dbg_main.c", 367, 1, 0);
  while ( 1 )
  {
    sub_100302D0(&v3);
    if ( v3 & 1 )
    {
      sub_1000C010((int)&byte_1020B260);
      sub_10009D70(v1);
      sub_1000C410((int)&byte_1020B260);
      sub_10009370();
      if ( sub_10015650(v2) != 4 && --v0 <= 0 )
      {
        sub_1000D580((int)&byte_1020B260);
        v0 = 20;
      }
      sub_100079A0(1, 0);
      sub_1000ADE0();
    }
    if ( v3 & 4 )
      sub_10014D70("..\\lib\\adl\\iop_d_dbg_main.c", 443, 1, 0);
    if ( v3 & 2 )
      sub_10009E00();
  }
}
// 1020B260: using guessed type char byte_1020B260;

//----- (1000A180) --------------------------------------------------------
char sub_1000A180()
{
  void *v0; // ecx@1

  sub_1000DAE0();
  sub_1000AC60();
  sub_100081A0(v0);
  return sub_100099E0();
}

//----- (1000A1A0) --------------------------------------------------------
char __cdecl sub_1000A1A0(int a1, int a2)
{
  char result; // al@1
  int v3; // [sp+4h] [bp-6Ch]@1
  char v4; // [sp+8h] [bp-68h]@1

  memset(&v4, 0, 0x64u);
  result = sub_1000D660(a1, a2, &v4, (unsigned __int16 *)&v3);
  if ( result == 1 )
  {
    if ( (unsigned __int16)a1 == 58 )
    {
      result = (unsigned int)sub_1000AA90(0x8000, &v4, v3);
    }
    else
    {
      result = a1 - 59;
      if ( (unsigned __int16)a1 == 59 )
        result = (unsigned int)sub_1000AA90(0x8000, &v4, v3);
    }
  }
  return result;
}

//----- (1000A220) --------------------------------------------------------
char __cdecl sub_1000A220(int a1, int a2)
{
  char result; // al@1
  int v3; // [sp+4h] [bp-6Ch]@1
  char v4; // [sp+8h] [bp-68h]@1

  memset(&v4, 0, 0x64u);
  result = sub_1000D660(a1, a2, &v4, (unsigned __int16 *)&v3);
  if ( result == 1 )
  {
    switch ( (unsigned __int16)a1 )
    {
      case 6u:
        result = (unsigned int)sub_1000AA90(256, &v4, v3);
        break;
      case 7u:
        result = (unsigned int)sub_1000AA90(512, &v4, v3);
        break;
      case 0xCu:
        result = (unsigned int)sub_1000AA90(768, &v4, v3);
        break;
      case 0x30u:
        result = (unsigned int)sub_1000AA90(4096, &v4, v3);
        break;
      case 0x31u:
        result = (unsigned int)sub_1000AA90(0x2000, &v4, v3);
        break;
      case 0x69u:
        result = (unsigned int)sub_1000AA90(0x80000, &v4, v3);
        break;
      case 0x34u:
        result = (unsigned int)sub_1000AA90(536576, &v4, v3);
        break;
      default:
        result = sub_10014D70("..\\lib\\adl\\iop_dbg_data.c", 276, 1, 0);
        break;
    }
  }
  return result;
}

//----- (1000A440) --------------------------------------------------------
char __cdecl sub_1000A440(int a1, int a2)
{
  char result; // al@1
  int v3; // [sp+4h] [bp-108h]@1
  char v4; // [sp+8h] [bp-104h]@1

  memset(&v4, 0, 0x100u);
  result = sub_1000D660(a1, a2, &v4, (unsigned __int16 *)&v3);
  if ( result == 1 )
  {
    switch ( (unsigned __int16)a1 )
    {
      case 0x54u:
        result = (unsigned int)sub_1000AA90(0x10000, &v4, v3);
        break;
      case 0x57u:
        result = (unsigned int)sub_1000AA90(0x20000, &v4, v3);
        break;
      case 0x56u:
        result = (unsigned int)sub_1000AA90(0x10000, &v4, v3);
        break;
      case 0x59u:
        result = (unsigned int)sub_1000AA90(0x20000, &v4, v3);
        break;
      case 0x55u:
        result = (unsigned int)sub_1000AA90(0x100000, &v4, v3);
        break;
      case 0x58u:
        result = (unsigned int)sub_1000AA90(0x200000, &v4, v3);
        break;
      case 0x5Au:
        result = (unsigned int)sub_1000AA90(0x100000, &v4, v3);
        break;
      case 0x5Bu:
        result = (unsigned int)sub_1000AA90(0x200000, &v4, v3);
        break;
      default:
        result = sub_10014D70("..\\lib\\adl\\iop_dbg_data.c", 377, 1, 0);
        break;
    }
  }
  return result;
}

//----- (1000A660) --------------------------------------------------------
char __cdecl sub_1000A660(int a1, int a2)
{
  char result; // al@1
  int v3; // [sp+4h] [bp-198h]@1
  char v4; // [sp+8h] [bp-194h]@1

  memset(&v4, 0, 0x190u);
  result = sub_1000D660(a1, a2, &v4, (unsigned __int16 *)&v3);
  if ( result == 1 )
  {
    if ( (unsigned __int16)a1 == 18 )
    {
      result = (unsigned int)sub_1000AA90(0x4000, &v4, v3);
    }
    else
    {
      result = a1 - 20;
      if ( (unsigned __int16)a1 == 20 )
        result = (unsigned int)sub_1000AA90(0x4000, &v4, v3);
    }
  }
  return result;
}

//----- (1000A700) --------------------------------------------------------
char __cdecl sub_1000A700(int a1, int a2)
{
  char result; // al@1
  int v3; // [sp+4h] [bp-58h]@1
  char v4; // [sp+8h] [bp-54h]@1

  memset(&v4, 0, 0x50u);
  result = sub_1000D660(a1, a2, &v4, (unsigned __int16 *)&v3);
  if ( result == 1 )
  {
    if ( (unsigned __int16)a1 == 24 )
    {
      result = (unsigned int)sub_1000AA90(1024, &v4, v3);
    }
    else
    {
      result = a1 - 26;
      if ( (unsigned __int16)a1 == 26 )
        result = (unsigned int)sub_1000AA90(1024, &v4, v3);
    }
  }
  return result;
}

//----- (1000A780) --------------------------------------------------------
char __cdecl sub_1000A780(char a1, const char *a2)
{
  char *v2; // ebx@1
  unsigned __int16 v3; // kr00_2@1
  int v4; // esi@1

  v2 = (char *)a2;
  v3 = strlen(a2);
  v4 = sub_10014DE0(&a1, 4u, (int)dword_1004B7F8, 8, 16, 16);
  if ( v4 == 16 )
    sub_10014D70("..\\lib\\adl\\iop_dbg_data.c", 630, 1, 0);
  return sub_1000D2F0((unsigned __int16)word_1004B7FC[4 * v4], v3, dword_1004B7F8[2 * v4], v2, 1, (int)&byte_1020B260);
}
// 1004B7F8: using guessed type int dword_1004B7F8[];
// 1004B7FC: using guessed type __int16 word_1004B7FC[];
// 1020B260: using guessed type char byte_1020B260;

//----- (1000A800) --------------------------------------------------------
int sub_1000A800()
{
  int result; // eax@1

  result = sub_10030160(93, 100);
  if ( !result )
  {
    memset((void *)(dword_101361A8 + 12), 0, 0x1F40u);
    *(_DWORD *)(dword_101361A8 + 4) = 0;
    *(_DWORD *)(dword_101361A8 + 8) = 0;
    byte_101361A0 = 0;
    result = sub_10030140(93);
  }
  return result;
}
// 101361A0: using guessed type char byte_101361A0;
// 101361A8: using guessed type int dword_101361A8;

//----- (1000A850) --------------------------------------------------------
void sub_1000A850()
{
  byte_101361A1 = 0;
}
// 101361A1: using guessed type char byte_101361A1;

//----- (1000A860) --------------------------------------------------------
void sub_1000A860()
{
  byte_101361A1 = 1;
}
// 101361A1: using guessed type char byte_101361A1;

//----- (1000A870) --------------------------------------------------------
int __cdecl sub_1000A870(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101361A4 = a1;
  return result;
}
// 101361A4: using guessed type int dword_101361A4;

//----- (1000A880) --------------------------------------------------------
char __cdecl sub_1000A880(char *a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  unsigned int v3; // ecx@1
  bool v5; // zf@12

  v2 = sub_10014FA0(v1);
  v3 = dword_101361A4;
  if ( v2 == dword_101361A4 )
  {
    sub_10001C70(a1);
    v3 = dword_101361A4;
  }
  if ( v3 > 0x4000 )
  {
    if ( v3 > 0x200000 )
    {
      if ( v3 > 0x4000000 )
      {
        v5 = v3 == 0x8000000;
      }
      else
      {
        if ( v3 == 0x4000000 || v3 == 0x1000000 )
          return sub_1000A780(v3, a1);
        v5 = v3 == 0x2000000;
      }
    }
    else
    {
      if ( v3 == 0x200000 )
        return sub_1000A780(v3, a1);
      if ( v3 > 0x20000 )
      {
        if ( v3 == 0x80000 )
          return sub_1000A780(v3, a1);
        v5 = v3 == 0x100000;
      }
      else
      {
        if ( v3 == 0x20000 || v3 == 0x8000 )
          return sub_1000A780(v3, a1);
        v5 = v3 == 0x10000;
      }
    }
  }
  else
  {
    if ( v3 == 0x4000 )
      return sub_1000A780(v3, a1);
    if ( v3 <= 0x80 )
    {
      if ( v3 == 128 )
        return sub_10001290(v3, a1);
      switch ( v3 )
      {
        case 1u:
        case 2u:
        case 4u:
        case 0x10u:
        case 0x20u:
        case 0x40u:
          return sub_10001290(v3, a1);
        default:
          return sub_10014D70("..\\lib\\adl\\iop_diag.c", 477, 1, 0);
      }
      return sub_10014D70("..\\lib\\adl\\iop_diag.c", 477, 1, 0);
    }
    if ( v3 > 0x400 )
    {
      if ( v3 == 4096 )
        return sub_1000A780(v3, a1);
      v5 = v3 == 0x2000;
    }
    else
    {
      if ( v3 == 1024 || v3 == 256 )
        return sub_1000A780(v3, a1);
      v5 = v3 == 512;
    }
  }
  if ( !v5 )
    return sub_10014D70("..\\lib\\adl\\iop_diag.c", 477, 1, 0);
  return sub_1000A780(v3, a1);
}
// 101361A4: using guessed type int dword_101361A4;

//----- (1000A9E0) --------------------------------------------------------
unsigned int sub_1000A9E0()
{
  unsigned int result; // eax@2
  unsigned int v1; // ST08_4@5

  if ( *(_BYTE *)dword_101361A8 )
  {
    v1 = dword_101361AC;
    *(_BYTE *)dword_101361A8 = 0;
    result = sub_10030770(v1);
  }
  else
  {
    *(_BYTE *)dword_101361A8 = 1;
    result = j_FIL_vfs_open("/mnt/card0/diag_buf_log.txt", 14, 1809);
    dword_101361AC = result;
    if ( result >= 0xFFFFFFC2 || !result )
    {
      result = dword_101361A8;
      *(_BYTE *)dword_101361A8 = 0;
    }
  }
  return result;
}
// 10030850: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 101361A8: using guessed type int dword_101361A8;
// 101361AC: using guessed type int dword_101361AC;

//----- (1000AA70) --------------------------------------------------------
int __usercall sub_1000AA70@<eax>(int a1@<eax>, int a2@<ecx>)
{
  return j_FIL_vfs_write(dword_101361AC, a2, a1);
}
// 100309D0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 101361AC: using guessed type int dword_101361AC;

//----- (1000AA90) --------------------------------------------------------
char *__cdecl sub_1000AA90(int a1, const char *a2, unsigned __int16 a3)
{
  char *result; // eax@1
  char *v4; // ebp@2
  char *i; // eax@8
  const char *v6; // edi@12
  int v7; // ecx@14
  int v8; // esi@14
  int v9; // eax@16
  int v10; // eax@18

  result = (char *)strlen(a2);
  if ( (unsigned int)result >= a3 )
  {
    v4 = (char *)a3;
  }
  else
  {
    result = (char *)strlen(a2);
    v4 = result;
  }
  if ( byte_101361A1 == 1 )
  {
    result = (char *)dword_101361A4;
    if ( (a1 & dword_101361A4) == dword_101361A4 )
    {
      if ( strlen(a2) >= 0x1F40 )
        sub_10014D70("..\\lib\\adl\\iop_diag.c", 251, 0, 0);
      sub_10015290((int)byte_101361B0, a2, 8000);
      for ( i = strstr(byte_101361B0, "\x1B[2J"); i; i = strstr(byte_101361B0, "\x1B[2J") )
        *(_DWORD *)i = 168430090;
      for ( result = strstr(byte_101361B0, "\r"); result; result = strstr(byte_101361B0, "\r") )
        *result = 32;
      v6 = byte_101361B0;
      if ( (signed int)v4 > 0 )
      {
        while ( 1 )
        {
          result = (char *)sub_10030160(93, 100);
          if ( !result )
            break;
LABEL_24:
          if ( (signed int)v4 <= 0 )
            return result;
        }
        v7 = *(_DWORD *)(dword_101361A8 + 8);
        v8 = (int)v4;
        if ( (unsigned int)&v4[v7] > 0x1F40 )
          v8 = 8000 - v7;
        strncpy((char *)(dword_101361A8 + v7 + 12), v6, v8);
        v9 = dword_101361A8;
        if ( *(_BYTE *)dword_101361A8 == 1 )
        {
          sub_1000AA70(v8, (int)v6);
          v9 = dword_101361A8;
        }
        *(_DWORD *)(v9 + 8) += v8;
        v10 = dword_101361A8;
        if ( *(_DWORD *)(dword_101361A8 + 8) < 0x1F40u )
        {
          if ( byte_101361A0 != 1 )
            goto LABEL_22;
        }
        else
        {
          *(_DWORD *)(dword_101361A8 + 8) = 0;
          v10 = dword_101361A8;
          byte_101361A0 = 1;
        }
        *(_DWORD *)(v10 + 4) = *(_DWORD *)(v10 + 8) + 1;
        v10 = dword_101361A8;
        if ( *(_DWORD *)(dword_101361A8 + 4) < 0x1F40u )
        {
LABEL_23:
          v4 -= v8;
          v6 += v8;
          result = (char *)sub_10030140(93);
          goto LABEL_24;
        }
LABEL_22:
        *(_DWORD *)(v10 + 4) = 0;
        goto LABEL_23;
      }
    }
  }
  return result;
}
// 101361A0: using guessed type char byte_101361A0;
// 101361A1: using guessed type char byte_101361A1;
// 101361A4: using guessed type int dword_101361A4;
// 101361A8: using guessed type int dword_101361A8;

//----- (1000AC60) --------------------------------------------------------
signed int sub_1000AC60()
{
  byte_101361A0 = 0;
  byte_101361A1 = 0;
  dword_101361A8 = -15;
  dword_101361A4 = 0;
  memset(byte_101361B0, 0, 0x1F40u);
  if ( !sub_100313C0((LONG)&off_1004BDD8) )
    sub_10014D70("..\\lib\\adl\\iop_diag.c", 575, 1, 0);
  return sub_10030F50((int)&off_1004BDD8);
}
// 1004BDD8: using guessed type char *off_1004BDD8;
// 101361A0: using guessed type char byte_101361A0;
// 101361A1: using guessed type char byte_101361A1;
// 101361A4: using guessed type int dword_101361A4;
// 101361A8: using guessed type int dword_101361A8;

//----- (1000ACA0) --------------------------------------------------------
char __cdecl sub_1000ACA0(int a1)
{
  int v1; // edx@1
  int v2; // eax@1
  int v4; // [sp+4h] [bp-8h]@1
  int v5; // [sp+8h] [bp-4h]@1

  v1 = *(_DWORD *)(a1 + 4);
  HIWORD(v4) = *(_WORD *)a1;
  v5 = v1;
  LOWORD(v4) = 1;
  v2 = sub_10030040();
  sub_1000C7A0(98, 1, (int)&byte_1020B260, &v4, v2);
  return sub_1000CDA0(98, *(_DWORD *)(a1 + 1012), (int)&byte_1020B260);
}
// 1020B260: using guessed type char byte_1020B260;

//----- (1000AD00) --------------------------------------------------------
int __cdecl sub_1000AD00(char a1)
{
  int result; // eax@9

  if ( *(_DWORD *)&byte_101361B0[12176] < 0xFFFFFFC2 && *(_DWORD *)&byte_101361B0[12176] )
    sub_10030770(*(unsigned int *)&byte_101361B0[12176]);
  if ( *(_DWORD *)&byte_101361B0[12296] < 0xFFFFFFC2 && *(_DWORD *)&byte_101361B0[12296] )
  {
    if ( a1 )
      sub_1001C010((int)&byte_101361B0[12180], &byte_101361B0[12112]);
    sub_1001B3A0(&byte_101361B0[12180]);
  }
  j_FIL_vfs_sync_all();
  result = *(_DWORD *)&byte_101361B0[13068];
  *(_DWORD *)&byte_101361B0[12176] = 0;
  *(_DWORD *)&byte_101361B0[12296] = 0;
  **(_BYTE **)&byte_101361B0[13068] = 6;
  return result;
}
// 100309A0: using guessed type int j_FIL_vfs_sync_all(void);

//----- (1000AD70) --------------------------------------------------------
signed int sub_1000AD70()
{
  if ( !sub_100313C0((LONG)&off_1004C3A4) )
    sub_10014D70("..\\lib\\adl\\iop_dnld_mngr.c", 354, 1, 0);
  **(_BYTE **)&byte_101361B0[13068] = 0;
  return sub_10030F50((int)&off_1004C3A4);
}
// 1004C3A4: using guessed type char *off_1004C3A4;

//----- (1000ADB0) --------------------------------------------------------
int sub_1000ADB0()
{
  int result; // eax@1

  *(_DWORD *)&byte_101361B0[13068] = -15;
  sub_1000AD70();
  memset(&byte_101361B0[12096], 0, 0x3CCu);
  result = *(_DWORD *)&byte_101361B0[13068];
  *(_DWORD *)&byte_101361B0[13064] = *(_DWORD *)&byte_101361B0[13068];
  return result;
}

//----- (1000ADE0) --------------------------------------------------------
unsigned int sub_1000ADE0()
{
  unsigned int result; // eax@1

  result = *(_DWORD *)&byte_101361B0[13068];
  if ( **(_BYTE **)&byte_101361B0[13068] == 1 )
  {
    result = sub_10030040();
    if ( result > *(_DWORD *)&byte_101361B0[12104] + 2000 )
      **(_BYTE **)&byte_101361B0[13068] = 4;
  }
  return result;
}

//----- (1000AE10) --------------------------------------------------------
char __cdecl sub_1000AE10(int a1, int a2)
{
  char result; // al@1
  int v3; // eax@4
  int v4; // eax@6
  void *v5; // ecx@7
  int v6; // eax@7
  int v7; // [sp+4h] [bp-418h]@1
  int v8; // [sp+8h] [bp-414h]@1
  int v9; // [sp+Ch] [bp-410h]@1
  int v10; // [sp+10h] [bp-40Ch]@1
  int v11; // [sp+14h] [bp-408h]@1
  int v12; // [sp+18h] [bp-404h]@1
  int v13; // [sp+1Ch] [bp-400h]@1
  __int16 v14; // [sp+20h] [bp-3FCh]@1
  int v15; // [sp+24h] [bp-3F8h]@6
  char v16; // [sp+28h] [bp-3F4h]@6
  int v17; // [sp+410h] [bp-Ch]@4
  int v18; // [sp+414h] [bp-8h]@6

  v7 = 0;
  v8 = 0;
  memset(&v14, 0, 0x3F8u);
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  result = sub_1000D640(a1, a2, &v7);
  if ( result == 1 && *(_DWORD *)&byte_101361B0[13044] < 0xFFFFFFC2 && *(_DWORD *)&byte_101361B0[13044] )
  {
    v3 = *(_DWORD *)&byte_101361B0[13052] - *(_DWORD *)&byte_101361B0[13048];
    v17 = *(_DWORD *)&byte_101361B0[13052] - *(_DWORD *)&byte_101361B0[13048];
    if ( (unsigned int)(*(_DWORD *)&byte_101361B0[13052] - *(_DWORD *)&byte_101361B0[13048]) > 0x3E8 )
    {
      v3 = 1000;
      v17 = 1000;
    }
    sub_10030860(*(unsigned int *)&byte_101361B0[13044], &v16, v3);
    v15 = *(_DWORD *)&byte_101361B0[13048];
    v14 = HIWORD(v7);
    v18 = sub_10014FA0(*(void **)&byte_101361B0[13048]);
    v4 = sub_10030040();
    sub_1000C7A0(97, 1, (int)&byte_1020B260, &v14, v4);
    sub_1000CDA0(97, *(int *)&byte_101361B0[13056], (int)&byte_1020B260);
    result = v17 + byte_101361B0[13048];
    *(_DWORD *)&byte_101361B0[13048] += v17;
    if ( *(_DWORD *)&byte_101361B0[13048] == *(_DWORD *)&byte_101361B0[13052] )
    {
      sub_10030770(*(unsigned int *)&byte_101361B0[13044]);
      *(_DWORD *)&byte_101361B0[13044] = 0;
      LOBYTE(v9) = 1;
      LOWORD(v10) = HIWORD(v7);
      v13 = sub_10014FA0(v5);
      v6 = sub_10030040();
      sub_1000C7A0(96, 1, (int)&byte_1020B260, &v9, v6);
      result = sub_1000CDA0(96, *(int *)&byte_101361B0[13056], (int)&byte_1020B260);
    }
  }
  return result;
}
// 1020B260: using guessed type char byte_1020B260;

//----- (1000AFA0) --------------------------------------------------------
char __cdecl sub_1000AFA0(int a1, int a2)
{
  char result; // al@1
  char v3; // [sp+4h] [bp-3FCh]@1
  int v4; // [sp+8h] [bp-3F8h]@4
  char v5; // [sp+Ch] [bp-3F4h]@5
  int v6; // [sp+3F4h] [bp-Ch]@5

  memset(&v3, 0, 0x3F8u);
  result = sub_1000D640(a1, a2, &v3);
  if ( result == 1 )
  {
    result = byte_101361B0[12176];
    if ( *(_DWORD *)&byte_101361B0[12176] < 0xFFFFFFC2 )
    {
      if ( *(_DWORD *)&byte_101361B0[12176] )
      {
        if ( v4 == *(_DWORD *)&byte_101361B0[12108] )
        {
          sub_1001C860(*(unsigned int *)&byte_101361B0[12176], (int)&v5, v6);
          sub_1000ACA0((int)&v3);
          *(_DWORD *)&byte_101361B0[12108] += v6;
          *(_DWORD *)(*(_DWORD *)&byte_101361B0[13068] + 20) += v6;
          result = byte_101361B0[13068];
          **(_BYTE **)&byte_101361B0[13068] = 2;
        }
      }
    }
  }
  return result;
}

//----- (1000B060) --------------------------------------------------------
int __cdecl sub_1000B060(int a1)
{
  int result; // eax@1
  int v2; // [sp+0h] [bp-34h]@1
  char *v3; // [sp+4h] [bp-30h]@1
  __int16 v4; // [sp+8h] [bp-2Ch]@1
  const char *v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  __int16 v7; // [sp+14h] [bp-20h]@1
  char *v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  char *v10; // [sp+20h] [bp-14h]@1
  int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+28h] [bp-Ch]@1
  char v13; // [sp+2Ch] [bp-8h]@1
  int v14; // [sp+30h] [bp-4h]@1

  sub_100153B0(
    &byte_101361B0[12112],
    0x40u,
    "%d_%d_%d.rgn",
    *(_BYTE *)(a1 + 1),
    *(_DWORD *)(a1 + 8),
    *(_WORD *)(a1 + 4));
  sub_1001B400(
    (int)"/mnt/card0/rgn_dnld.zip",
    14,
    &byte_101361B0[12180],
    (int)"GarminProprietary*$&)kratsaslkd932(lkasdf93023");
  sub_1001C010((int)&byte_101361B0[12180], &byte_101361B0[12112]);
  v2 = 4;
  v3 = &byte_101361B0[12112];
  v4 = strlen(&byte_101361B0[12112]);
  v6 = 0;
  v7 = 0;
  v8 = &byte_101361B0[8000];
  v9 = 4096;
  v10 = &byte_101361B0[13072];
  v12 = 12;
  v13 = 9;
  v14 = 5;
  v11 = 38584;
  v5 = "GarminProprietary*$&)kratsaslkd932(lkasdf93023";
  result = sub_1001C5B0((int)&byte_101361B0[12180], &byte_101361B0[12112], 10, &byte_101361B0[12308], (int)&v2);
  *(_DWORD *)&byte_101361B0[12176] = result;
  return result;
}

//----- (1000B150) --------------------------------------------------------
char __cdecl sub_1000B150(int a1, char a2, int a3, __int16 a4)
{
  void *v4; // ecx@0
  char result; // al@5
  int v6; // eax@6
  int v7; // eax@6
  int v8; // ecx@6
  unsigned int v9; // eax@7
  int v10; // eax@14
  int v11; // [sp+0h] [bp-410h]@1
  int v12; // [sp+4h] [bp-40Ch]@1
  int v13; // [sp+8h] [bp-408h]@1
  int v14; // [sp+Ch] [bp-404h]@1
  int v15; // [sp+10h] [bp-400h]@1
  char v16; // [sp+1Ch] [bp-3F4h]@9
  int v17; // [sp+404h] [bp-Ch]@7

  v11 = 0;
  v12 = 0;
  v14 = 0;
  v13 = a3;
  BYTE1(v11) = a2;
  v15 = sub_10014FA0(v4);
  LOWORD(v12) = a4;
  if ( a1 == v15 )
  {
    if ( a4 == 66 || a4 == 40 || a4 == 22 )
    {
      sub_1000B060((int)&v11);
      v6 = j_FIL_vfs_open("/mnt/sys_nand0/err_rpt.dat", 4, 0);
      *(_DWORD *)&byte_101361B0[13044] = v6;
      *(_DWORD *)&byte_101361B0[13048] = 0;
      v7 = sub_10030980(v6);
      v8 = *(_DWORD *)&byte_101361B0[13048];
      for ( *(_DWORD *)&byte_101361B0[13052] = v7;
            *(_DWORD *)&byte_101361B0[13048] < *(_DWORD *)&byte_101361B0[13052];
            *(_DWORD *)&byte_101361B0[13048] += v17 )
      {
        v9 = v7 - v8;
        v17 = v9;
        if ( v9 > 0x3E8 )
        {
          v9 = 1000;
          v17 = 1000;
        }
        sub_10030860(*(unsigned int *)&byte_101361B0[13044], &v16, v9);
        sub_1001C860(*(unsigned int *)&byte_101361B0[12176], (int)&v16, v17);
        v8 = v17 + *(_DWORD *)&byte_101361B0[13048];
        v7 = *(_DWORD *)&byte_101361B0[13052];
      }
      sub_10030770(*(unsigned int *)&byte_101361B0[13044]);
      *(_DWORD *)&byte_101361B0[13044] = 0;
      result = sub_1000AD00(0);
    }
    else
    {
      result = byte_101361B0[13068];
      **(_BYTE **)&byte_101361B0[13068] = 7;
    }
  }
  else
  {
    if ( a1 )
    {
      **(_BYTE **)&byte_101361B0[13068] = 1;
      LOBYTE(v11) = 5;
      *(_DWORD *)&byte_101361B0[13060] = a1;
      *(_DWORD *)&byte_101361B0[12104] = sub_10030040();
    }
    else
    {
      sub_1000AD00(1);
      **(_BYTE **)&byte_101361B0[13068] = 5;
      LOBYTE(v11) = 6;
    }
    v10 = sub_10030040();
    sub_1000C7A0(96, 1, (int)&byte_1020B260, &v11, v10);
    result = sub_1000CDA0(96, *(int *)&byte_101361B0[13060], (int)&byte_1020B260);
  }
  return result;
}
// 10030850: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1020B260: using guessed type char byte_1020B260;

//----- (1000B340) --------------------------------------------------------
char __cdecl sub_1000B340(int a1, int a2)
{
  char result; // al@1
  void *v3; // ecx@12
  int v4; // eax@12
  int v5; // [sp+8h] [bp-410h]@1
  int v6; // [sp+Ch] [bp-40Ch]@1
  int v7; // [sp+10h] [bp-408h]@1
  int v8; // [sp+14h] [bp-404h]@1
  int v9; // [sp+18h] [bp-400h]@1
  __int16 v10; // [sp+1Ch] [bp-3FCh]@1
  int v11; // [sp+410h] [bp-8h]@15

  memset(&v10, 0, 0x3F8u);
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  result = sub_1000D640(a1, a2, &v5);
  if ( result == 1 )
  {
    if ( (_BYTE)v5 )
    {
      if ( (unsigned __int8)v5 == 5 )
      {
        result = v6;
        if ( (_WORD)v6 == 66 || (_WORD)v6 == 22 || (_WORD)v6 == 40 )
        {
          result = byte_101361B0[13044];
          if ( *(_DWORD *)&byte_101361B0[13044] >= 0xFFFFFFC2 || !*(_DWORD *)&byte_101361B0[13044] )
          {
            *(_DWORD *)&byte_101361B0[13044] = j_FIL_vfs_open("/mnt/sys_nand0/err_rpt.dat", 4, 0);
            *(_DWORD *)&byte_101361B0[13048] = 0;
            *(_DWORD *)&byte_101361B0[13052] = sub_10030980(*(int *)&byte_101361B0[13044]);
            *(_DWORD *)&byte_101361B0[13056] = v9;
            LOBYTE(v5) = 0;
            v9 = sub_10014FA0(v3);
            v8 = *(_DWORD *)&byte_101361B0[13052];
            v4 = sub_10030040();
            sub_1000C7A0(96, 1, (int)&byte_1020B260, &v5, v4);
            result = sub_1000CDA0(96, *(int *)&byte_101361B0[13056], (int)&byte_1020B260);
          }
        }
      }
      else if ( (unsigned __int8)v5 == 6 )
      {
        result = sub_1000AD00(1);
      }
      else
      {
        result = sub_1000AD00(0);
      }
    }
    else
    {
      result = byte_101361B0[12176];
      if ( *(_DWORD *)&byte_101361B0[12176] >= 0xFFFFFFC2 || !*(_DWORD *)&byte_101361B0[12176] )
      {
        sub_1000B060((int)&v5);
        *(_DWORD *)&byte_101361B0[12108] = 0;
        **(_BYTE **)&byte_101361B0[13068] = 3;
        *(_DWORD *)(*(_DWORD *)&byte_101361B0[13068] + 20) = 0;
        *(_DWORD *)(*(_DWORD *)&byte_101361B0[13068] + 16) = v8;
        *(_DWORD *)(*(_DWORD *)&byte_101361B0[13068] + 8) = v7;
        *(_WORD *)(*(_DWORD *)&byte_101361B0[13068] + 6) = v6;
        *(_BYTE *)(*(_DWORD *)&byte_101361B0[13068] + 4) = BYTE1(v5);
        v11 = v9;
        v10 = v6;
        result = sub_1000ACA0((int)&v10);
      }
    }
  }
  return result;
}
// 10030850: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1020B260: using guessed type char byte_1020B260;

//----- (1000B550) --------------------------------------------------------
signed __int16 __usercall sub_1000B550@<ax>(int a1@<eax>, int a2@<ecx>)
{
  signed __int16 result; // ax@2

  a1 = (unsigned __int16)a1;
  if ( (signed int)(unsigned __int16)a1 >= *(_DWORD *)(a2 + 4) )
    result = -1;
  else
    result = *(_WORD *)(*(_DWORD *)(a2 + 40) + 2 * a1);
  return result;
}

//----- (1000B570) --------------------------------------------------------
int __usercall sub_1000B570@<eax>(int a1@<esi>, signed int a2)
{
  int v2; // edx@1
  char v3; // cl@1
  int v4; // ebp@1
  signed int v5; // edx@1
  int v6; // eax@1
  int v7; // edi@2
  int v8; // ecx@3
  bool v9; // zf@3
  int v10; // edi@5
  signed int v11; // ebx@5
  int v12; // ebp@8
  int v13; // edx@9
  int v14; // eax@11
  __int16 v15; // cx@11
  char v16; // dl@11
  int v17; // edx@11
  int v18; // eax@11
  int v19; // ecx@11
  unsigned int v20; // eax@15
  int v21; // ecx@15
  char v23; // [sp+7h] [bp-29h]@5
  int v24; // [sp+8h] [bp-28h]@1
  int v25; // [sp+Ch] [bp-24h]@1
  int v26; // [sp+10h] [bp-20h]@8
  int v27; // [sp+14h] [bp-1Ch]@3
  int v28; // [sp+18h] [bp-18h]@3
  int v29; // [sp+1Ch] [bp-14h]@1
  char v30; // [sp+20h] [bp-10h]@1
  char v31; // [sp+21h] [bp-Fh]@1
  __int16 v32; // [sp+22h] [bp-Eh]@16
  int v33; // [sp+24h] [bp-Ch]@11
  int v34; // [sp+28h] [bp-8h]@11

  v2 = *(_DWORD *)(a1 + 60);
  v3 = *(_BYTE *)(a1 + 1);
  v4 = ~*(_DWORD *)(a1 + 72);
  v29 = *(_DWORD *)(a1 + 16);
  v30 = v3;
  v31 = 1;
  v25 = v4;
  sub_10030160(v2, -1);
  v5 = a2;
  v6 = 0;
  v24 = 0;
  if ( a2 > 0 )
  {
    do
    {
      v7 = *(_DWORD *)(a1 + 48);
      if ( *(_BYTE *)(v7 + 20 * v6) != 1 )
      {
        v8 = v4 & (*(_DWORD *)(v7 + 20 * v6 + 12) | 0xC00000);
        v9 = *(_BYTE *)(a1 + 1) == 6;
        v27 = v4 & (*(_DWORD *)(v7 + 20 * v6 + 12) | 0xC00000);
        v28 = v4 & (*(_DWORD *)(v7 + 20 * v6 + 12) | 0xC00000);
        if ( v9 || !(v8 & *(_DWORD *)(a1 + 84)) )
        {
          v23 = 1;
          v10 = *(_DWORD *)(a1 + 16) + 12;
          v11 = 12;
        }
        else
        {
          v10 = *(_DWORD *)(a1 + 16);
          v23 = 0;
          v11 = 0;
        }
        if ( v6 < v5 )
        {
          v12 = 20 * v6;
          v26 = v5 - v6;
          do
          {
            v13 = *(_DWORD *)(a1 + 48);
            if ( !*(_BYTE *)(v13 + v12) && v8 == (v25 & (*(_DWORD *)(v13 + v12 + 12) | 0xC00000)) )
            {
              v14 = v13 + v12;
              v15 = *(_WORD *)(v13 + v12 + 6);
              LOWORD(v33) = *(_WORD *)(v13 + v12 + 4);
              v16 = *(_BYTE *)(v13 + v12 + 1);
              BYTE1(v34) = *(_BYTE *)(v14 + 2);
              HIWORD(v33) = v15;
              LOBYTE(v34) = v16;
              v17 = v34;
              *(_DWORD *)v10 = v33;
              *(_DWORD *)(v10 + 4) = v17;
              memcpy(
                (void *)(v10 + 8),
                *(const void **)(*(_DWORD *)(a1 + 48) + v12 + 8),
                *(_WORD *)(*(_DWORD *)(a1 + 48) + v12 + 6));
              v18 = *(_DWORD *)(a1 + 48) + v12;
              v19 = *(_WORD *)(v18 + 6);
              v10 += v19 + 8;
              v11 += v19 + 8;
              v8 = v27;
              *(_BYTE *)v18 = 1;
            }
            v12 += 20;
            --v26;
          }
          while ( v26 );
          v4 = v25;
        }
        if ( v23 )
        {
          v20 = sub_100322A0((unsigned int *)(*(_DWORD *)(a1 + 16) + 12), v11 - 12, 0xFFFFFFFF);
          v21 = *(_DWORD *)(a1 + 16);
          v33 = 327678;
          LOWORD(v34) = 1;
          *(_DWORD *)v21 = 327678;
          *(_DWORD *)(v21 + 4) = v34;
          *(_DWORD *)(v21 + 8) = v20;
        }
        v32 = v11;
        if ( j_HWM_pvg_hsdb_put(&v28) == -100 )
          sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 4355, 0, 0);
        v5 = a2;
      }
      v6 = v24 + 1;
      v24 = v6;
      v6 = (unsigned __int16)v6;
    }
    while ( (unsigned __int16)v6 < v5 );
  }
  return sub_10030140(*(_DWORD *)(a1 + 60));
}
// 10008100: using guessed type int __cdecl j_HWM_pvg_hsdb_put(_DWORD);

//----- (1000B770) --------------------------------------------------------
int __usercall sub_1000B770@<eax>(int a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // ebx@1
  int v4; // edi@2
  signed __int16 v5; // ax@3
  int v6; // ebx@3
  int v7; // ebp@3
  int v8; // eax@3
  int v9; // ecx@3
  int v11; // [sp+4h] [bp-8h]@2
  int v12; // [sp+8h] [bp-4h]@3

  v3 = a1;
  sub_10030160(*(_DWORD *)(a2 + 60), -1);
  if ( v3 )
  {
    v4 = 0;
    v11 = v3;
    do
    {
      v12 = *(_WORD *)(v4 + *(_DWORD *)(a2 + 48) + 4);
      v5 = sub_1000B550(v12, a2);
      v6 = (unsigned __int16)v5;
      v7 = 52 * (unsigned __int16)v5;
      memcpy(
        (void *)(*(_DWORD *)(a2 + 28) + *(_DWORD *)(*(_DWORD *)(a2 + 32) + v7 + 4)),
        *(const void **)(v4 + *(_DWORD *)(a2 + 48) + 8),
        *(_WORD *)(v4 + *(_DWORD *)(a2 + 48) + 6));
      v8 = 24 * v6;
      *(_WORD *)(v8 + *(_DWORD *)(a2 + 64) + 4) = *(_WORD *)(v4 + *(_DWORD *)(a2 + 48) + 6);
      *(_BYTE *)(v8 + *(_DWORD *)(a2 + 64) + 1) = *(_BYTE *)(v4 + *(_DWORD *)(a2 + 48) + 1);
      *(_DWORD *)(v8 + *(_DWORD *)(a2 + 64) + 20) = *(_DWORD *)(v4 + *(_DWORD *)(a2 + 48) + 16);
      *(_BYTE *)(v8 + *(_DWORD *)(a2 + 64) + 2) = *(_BYTE *)(v4 + *(_DWORD *)(a2 + 48) + 2);
      *(_DWORD *)(v8 + *(_DWORD *)(a2 + 64) + 16) = a3;
      *(_BYTE *)(v8 + *(_DWORD *)(a2 + 64)) = 0;
      v9 = v7 + *(_DWORD *)(a2 + 32);
      if ( *(_DWORD *)(v9 + 36) && !*(_DWORD *)(v9 + 12) && !(*(_BYTE *)(v8 + *(_DWORD *)(a2 + 64) + 6) & 1) )
      {
        sub_10030140(*(_DWORD *)(a2 + 60));
        (*(void (__cdecl **)(int, int))(*(_DWORD *)(a2 + 32) + v7 + 36))(v12, a2);
        sub_10030160(*(_DWORD *)(a2 + 60), -1);
      }
      v4 += 20;
      --v11;
    }
    while ( v11 );
  }
  return sub_10030140(*(_DWORD *)(a2 + 60));
}

//----- (1000B890) --------------------------------------------------------
char __cdecl sub_1000B890(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@2
  char result; // al@2

  LOWORD(v2) = sub_1000B550(a1, a2);
  if ( (_WORD)v2 == -1 )
  {
    result = sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 670, 0, 0);
  }
  else
  {
    sub_10030160(*(_DWORD *)(a2 + 60), -1);
    v2 = (unsigned __int16)v2;
    v3 = 52 * (unsigned __int16)v2 + *(_DWORD *)(a2 + 32);
    memset((void *)(*(_DWORD *)(a2 + 28) + *(_DWORD *)(v3 + 4)), 0, *(_WORD *)v3);
    result = sub_10030140(*(_DWORD *)(a2 + 60));
    *(_BYTE *)(*(_DWORD *)(a2 + 64) + 24 * v2 + 1) = 0;
  }
  return result;
}

//----- (1000B910) --------------------------------------------------------
char __cdecl sub_1000B910(_DWORD *a1, _WORD *a2, _DWORD *a3, int a4, int a5)
{
  int v5; // eax@1
  int v6; // edx@1
  char result; // al@2
  int v8; // ecx@3

  LOWORD(v5) = sub_1000B550(a4, a5);
  if ( (unsigned __int16)v5 < 0xFFFFu )
  {
    v5 = (unsigned __int16)v5;
    v8 = *(_DWORD *)(v6 + 64) + 24 * (unsigned __int16)v5;
    if ( *(_BYTE *)(v8 + 1) )
    {
      *a1 = *(_DWORD *)(v6 + 28) + *(_DWORD *)(52 * v5 + *(_DWORD *)(v6 + 32) + 4);
      *a2 = *(_WORD *)(v8 + 4);
      *a3 = *(_DWORD *)(v8 + 16);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 791, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1000B990) --------------------------------------------------------
char __cdecl sub_1000B990(int a1, int a2, void *a3, unsigned __int16 a4)
{
  signed __int16 v4; // di@1
  int v5; // ebp@2
  int v6; // eax@2
  int v7; // ST30_4@3
  const char *v8; // eax@3
  int v10; // edx@4
  int v11; // ecx@4
  unsigned __int16 v12; // di@4
  int v13; // ecx@6
  int v14; // ST2C_4@16
  int v15; // ST28_4@16
  const char *v16; // eax@16
  char v17; // [sp+13h] [bp-75h]@4
  unsigned __int16 v18; // [sp+18h] [bp-70h]@1
  unsigned int v19; // [sp+1Ch] [bp-6Ch]@1
  char v20; // [sp+20h] [bp-68h]@3

  v4 = sub_1000B550(a1, a2);
  v18 = v4;
  v19 = sub_10030040();
  if ( v4 == -1 )
  {
    v17 = 0;
    sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 943, 0, 0);
  }
  else
  {
    v5 = 52 * (unsigned __int16)v4;
    v6 = *(_DWORD *)(a2 + 32) + v5;
    if ( *(_BYTE *)(v6 + 8) )
    {
      v7 = *(_BYTE *)(a2 + 1);
      v8 = sub_1000EDC0(a2, v4);
      _snprintf(&v20, 0x64u, "%d-%s is var pipe=%d", (unsigned __int16)a1, v8, v7);
      sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 874, 0, &v20);
      return 0;
    }
    v10 = *(_DWORD *)(a2 + 64);
    v11 = 24 * (unsigned __int16)v4;
    v12 = *(_WORD *)(v10 + v11 + 4);
    v17 = *(_BYTE *)(v10 + v11 + 1);
    if ( *(_BYTE *)(v11 + v10)
      || *(_DWORD *)(v6 + 12)
      && ((v13 = *(_DWORD *)(v11 + *(_DWORD *)(a2 + 64) + 16)) == 0
       || v19 > v13 + *(_DWORD *)(a2 + 36) + *(_DWORD *)(v6 + 16)) )
    {
      v17 = 0;
    }
    if ( v12 && v12 <= a4 && v12 == *(_WORD *)v6 )
    {
      sub_10030160(*(_DWORD *)(a2 + 60), -1);
      memcpy(a3, (const void *)(*(_DWORD *)(a2 + 28) + *(_DWORD *)(*(_DWORD *)(a2 + 32) + v5 + 4)), v12);
      sub_10030140(*(_DWORD *)(a2 + 60));
    }
    else
    {
      v17 = 0;
    }
    if ( v12 > a4 || v12 != *(_WORD *)(*(_DWORD *)(a2 + 32) + v5) )
    {
      v14 = *(_BYTE *)(a2 + 1);
      v15 = *(_WORD *)(*(_DWORD *)(a2 + 32) + v5);
      v16 = sub_1000EDC0(a2, v18);
      _snprintf(&v20, 0x64u, "%d-%s by=%d sz=%d pi=%d bsz=%d", (unsigned __int16)a1, v16, v12, v15, v14, a4);
      sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 936, 0, &v20);
    }
  }
  return v17;
}

//----- (1000BB80) --------------------------------------------------------
int __cdecl sub_1000BB80(int a1, int a2)
{
  signed __int16 v2; // ax@1
  int v3; // edx@1
  int result; // eax@2

  v2 = sub_1000B550(a1, a2);
  if ( v2 == -1 )
  {
    sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 992, 0, 0);
    result = 0;
  }
  else
  {
    result = *(_DWORD *)(*(_DWORD *)(v3 + 64) + 24 * (unsigned __int16)v2 + 20);
  }
  return result;
}

//----- (1000BBD0) --------------------------------------------------------
bool __cdecl sub_1000BBD0(int a1, int a2)
{
  signed __int16 v2; // ax@1
  bool result; // al@4

  v2 = sub_1000B550(a1, a2);
  if ( v2 == -1 )
  {
    sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1043, 0, 0);
    result = 0;
  }
  else
  {
    result = *(_DWORD *)(*(_DWORD *)(a2 + 64) + 24 * (unsigned __int16)v2 + 12)
          && sub_10030040() <= (unsigned int)(*(_DWORD *)(*(_DWORD *)(a2 + 64) + 24 * (unsigned __int16)v2 + 12)
                                            + *(_DWORD *)(52 * (unsigned __int16)v2 + *(_DWORD *)(a2 + 32) + 12));
  }
  return result;
}

//----- (1000BC50) --------------------------------------------------------
int __cdecl sub_1000BC50(int a1, int a2)
{
  signed __int16 v2; // ax@1
  int v3; // edx@1
  int result; // eax@2

  v2 = sub_1000B550(a1, a2);
  if ( v2 == -1 )
  {
    sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1092, 0, 0);
    result = 0;
  }
  else
  {
    result = *(_DWORD *)(*(_DWORD *)(v3 + 64) + 24 * (unsigned __int16)v2 + 16);
  }
  return result;
}

//----- (1000BCA0) --------------------------------------------------------
char __cdecl sub_1000BCA0(int a1, int a2, void *a3, unsigned __int16 *a4, unsigned __int16 a5)
{
  signed __int16 v5; // bp@1
  int v6; // edi@2
  int v7; // ST30_4@3
  const char *v8; // eax@3
  int v10; // ecx@4
  unsigned __int16 v11; // bp@4
  int v12; // eax@4
  int v13; // eax@5
  int v14; // ecx@6
  unsigned __int16 v15; // ax@14
  unsigned __int16 v16; // cx@14
  int v17; // ST2C_4@16
  int v18; // ST28_4@16
  int v19; // ST24_4@16
  const char *v20; // eax@16
  char v21; // [sp+13h] [bp-75h]@4
  unsigned __int16 v22; // [sp+18h] [bp-70h]@1
  unsigned int v23; // [sp+1Ch] [bp-6Ch]@1
  char v24; // [sp+20h] [bp-68h]@3

  v5 = sub_1000B550(a1, a2);
  v22 = v5;
  v23 = sub_10030040();
  if ( v5 == -1 )
  {
    v21 = 0;
    *a4 = 0;
    sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1267, 0, 0);
  }
  else
  {
    v6 = 52 * (unsigned __int16)v5;
    if ( *(_BYTE *)(*(_DWORD *)(a2 + 32) + v6 + 8) != 1 )
    {
      v7 = *(_BYTE *)(a2 + 1);
      v8 = sub_1000EDC0(a2, v5);
      _snprintf(&v24, 0x64u, "%d-%s !var pipe=%d", (unsigned __int16)a1, v8, v7);
      sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1189, 0, &v24);
      return 0;
    }
    v10 = 24 * (unsigned __int16)v5;
    v11 = *(_WORD *)(v10 + *(_DWORD *)(a2 + 64) + 4);
    *a4 = v11;
    v12 = *(_DWORD *)(a2 + 64);
    v21 = *(_BYTE *)(v10 + v12 + 1);
    if ( *(_BYTE *)(v10 + v12)
      || (v13 = *(_DWORD *)(a2 + 32) + v6, *(_DWORD *)(v13 + 12))
      && ((v14 = *(_DWORD *)(v10 + *(_DWORD *)(a2 + 64) + 16)) == 0
       || v23 > v14 + *(_DWORD *)(a2 + 36) + *(_DWORD *)(v13 + 16)) )
    {
      v21 = 0;
    }
    if ( v11 && v11 <= *(_WORD *)(v6 + *(_DWORD *)(a2 + 32)) && v11 <= a5 )
    {
      sub_10030160(*(_DWORD *)(a2 + 60), -1);
      memcpy(a3, (const void *)(*(_DWORD *)(a2 + 28) + *(_DWORD *)(*(_DWORD *)(a2 + 32) + v6 + 4)), *a4);
      sub_10030140(*(_DWORD *)(a2 + 60));
    }
    else
    {
      v21 = 0;
    }
    v15 = *a4;
    v16 = *(_WORD *)(v6 + *(_DWORD *)(a2 + 32));
    if ( *a4 > v16 || v15 > a5 )
    {
      v17 = *(_BYTE *)(a2 + 1);
      v18 = v16;
      v19 = v15;
      v20 = sub_1000EDC0(a2, v22);
      _snprintf(&v24, 0x64u, "%d-%s by=%d sz=%d pipe=%d bsz=%d", (unsigned __int16)a1, v20, v19, v18, v17, a5);
      sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1260, 0, &v24);
    }
  }
  return v21;
}

//----- (1000BEB0) --------------------------------------------------------
int __cdecl sub_1000BEB0(int a1)
{
  int v1; // ebp@1
  int v2; // edi@1
  int v3; // eax@2
  int v4; // ecx@3
  signed int v5; // ebx@7
  unsigned __int16 v6; // cx@7
  int v7; // eax@8
  int v8; // ecx@14

  v1 = *(_DWORD *)(a1 + 8);
  sub_10030160(*(_DWORD *)(a1 + 60), -1);
  v2 = 0;
  if ( *(_DWORD *)(a1 + 4) > 0 )
  {
    do
    {
      LOWORD(v3) = sub_1000B550(v2, a1);
      if ( (_WORD)v3 != -1 )
      {
        v3 = (unsigned __int16)v3;
        v4 = *(_DWORD *)(a1 + 32) + 52 * (unsigned __int16)v3;
        if ( *(_BYTE *)(v4 + 28) & *(_BYTE *)a1 )
        {
          if ( *(_BYTE *)(v3 + *(_DWORD *)(a1 + 24)) == 1
            && *(_DWORD *)(v4 + 12)
            && *(_DWORD *)(v4 + 24) & *(_DWORD *)(a1 + 72) )
          {
            v5 = *(_DWORD *)(a1 + 8);
            v6 = 0;
            if ( v5 > 0 )
            {
              v7 = 0;
              do
              {
                if ( *(_WORD *)(*(_DWORD *)(a1 + 68) + 2 * v7) == (_WORD)v2 )
                  break;
                v7 = ++v6;
              }
              while ( v6 < v5 );
            }
            if ( v6 == v5 )
              *(_WORD *)(*(_DWORD *)(a1 + 68) + 2 * v1++) = v2;
          }
        }
      }
      ++v2;
    }
    while ( (signed int)(unsigned __int16)v2 < *(_DWORD *)(a1 + 4) );
  }
  v8 = *(_DWORD *)(a1 + 60);
  *(_DWORD *)(a1 + 8) = v1;
  return sub_10030140(v8);
}

//----- (1000BF60) --------------------------------------------------------
int __cdecl sub_1000BF60(int a1)
{
  int v1; // ebp@1
  int v2; // edi@1
  signed __int16 v3; // ax@2
  int v4; // ecx@3
  int v5; // eax@3
  int v6; // edx@12

  v1 = 0;
  sub_10030160(*(_DWORD *)(a1 + 60), -1);
  v2 = 0;
  if ( *(_DWORD *)(a1 + 4) > 0 )
  {
    do
    {
      v3 = sub_1000B550(v2, a1);
      if ( v3 != -1 )
      {
        v4 = (unsigned __int16)v3;
        v5 = 52 * (unsigned __int16)v3 + *(_DWORD *)(a1 + 32);
        if ( *(_BYTE *)(v5 + 28) & *(_BYTE *)a1 )
        {
          if ( *(_BYTE *)(v4 + *(_DWORD *)(a1 + 24)) == 1
            && *(_DWORD *)(v5 + 12)
            && *(_DWORD *)(v5 + 20) & *(_DWORD *)(a1 + 72)
            && *(_DWORD *)(v5 + 24) )
          {
            if ( (unsigned int)*(_WORD *)v5 + 20 > *(_DWORD *)(a1 + 20) )
              sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1622, 0, 0);
            else
              *(_WORD *)(*(_DWORD *)(a1 + 76) + 2 * v1++) = v2;
          }
        }
      }
      ++v2;
    }
    while ( (signed int)(unsigned __int16)v2 < *(_DWORD *)(a1 + 4) );
  }
  v6 = *(_DWORD *)(a1 + 60);
  *(_DWORD *)(a1 + 12) = v1;
  return sub_10030140(v6);
}

//----- (1000C010) --------------------------------------------------------
char __cdecl sub_1000C010(int a1)
{
  char v1; // cl@1
  int v2; // eax@2
  int v3; // ebx@3
  signed int v4; // ebp@3
  unsigned int v5; // eax@3
  unsigned int v6; // edi@3
  bool v7; // zf@3
  unsigned int v8; // eax@4
  unsigned int v9; // eax@6
  int v10; // edx@15
  int v11; // eax@15
  int v12; // edi@15
  int v13; // edx@15
  int v14; // ebp@15
  int v15; // ebx@15
  int v16; // eax@15
  int v17; // eax@19
  char v18; // cl@19
  int v19; // ecx@24
  int v20; // edi@25
  int v21; // ecx@30
  int v22; // edx@30
  unsigned int v23; // edi@38
  int v24; // ebp@44
  int v25; // eax@45
  int v26; // edx@45
  int v27; // ecx@45
  void (__cdecl *v28)(int, int); // edi@45
  unsigned int v30; // [sp+10h] [bp-90h]@3
  int v31; // [sp+14h] [bp-8Ch]@3
  int v32; // [sp+18h] [bp-88h]@20
  unsigned int v33; // [sp+18h] [bp-88h]@44
  int v34; // [sp+1Ch] [bp-84h]@1
  int v35; // [sp+20h] [bp-80h]@2
  int v36; // [sp+24h] [bp-7Ch]@1
  char v37; // [sp+28h] [bp-78h]@1
  unsigned __int16 v38; // [sp+2Ah] [bp-76h]@3
  unsigned int v39; // [sp+2Ch] [bp-74h]@1
  int v40; // [sp+30h] [bp-70h]@15
  int v41; // [sp+34h] [bp-6Ch]@3
  char v42; // [sp+38h] [bp-68h]@9

  v1 = *(_BYTE *)(a1 + 1);
  v36 = *(_DWORD *)(a1 + 16);
  v37 = v1;
  v39 = sub_10030040();
  v34 = 0;
LABEL_2:
  while ( 1 )
  {
    v2 = j_HWM_pvg_hsdb_get(&v35, *(_DWORD *)(a1 + 20));
    if ( v2 <= 0 )
      break;
    v3 = *(_DWORD *)(a1 + 16);
    v4 = v38;
    v5 = *(_DWORD *)v3;
    v6 = 0;
    v7 = (unsigned __int16)*(_DWORD *)v3 == -2;
    v31 = v38;
    v30 = 0;
    v41 = *(_DWORD *)(v3 + 4);
    if ( v7 )
    {
      v8 = v5 >> 16;
      v4 = -8 - (unsigned __int16)v8 + v38;
      v31 = -8 - (unsigned __int16)v8 + v38;
      v3 += (unsigned __int16)v8 + 8;
      if ( (unsigned __int16)v8 < 4u || v4 <= 0 )
      {
        v31 = 0;
        v4 = 0;
        v9 = ~v34;
      }
      else
      {
        v34 = *(_DWORD *)(v3 - 4);
        v9 = sub_100322A0((unsigned int *)v3, v4, 0xFFFFFFFF);
      }
      if ( v34 != v9 )
      {
        _snprintf(&v42, 0x64u, "crc error rxsz=%d pipe=%d addr=0x%lx", v38, v37, v35);
        sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1796, 0, &v42);
        continue;
      }
    }
    else if ( *(_BYTE *)(a1 + 1) == 6 )
    {
      _snprintf(&v42, 0x64u, "crc error rxsz=%d pipe=%d addr=0x%lx", v38, v37, v35);
      sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1817, 0, &v42);
      continue;
    }
    if ( v4 > 0 )
    {
      while ( 1 )
      {
        v10 = *(_DWORD *)v3;
        v11 = *(_DWORD *)(v3 + 4);
        v12 = 20 * v6;
        *(_WORD *)(v12 + *(_DWORD *)(a1 + 48) + 4) = *(_DWORD *)v3;
        *(_WORD *)(v12 + *(_DWORD *)(a1 + 48) + 6) = HIWORD(v10);
        *(_BYTE *)(v12 + *(_DWORD *)(a1 + 48) + 1) = v11;
        *(_BYTE *)(v12 + *(_DWORD *)(a1 + 48) + 2) = BYTE1(v11);
        v40 = v10;
        LOWORD(v14) = sub_1000B550(v10, a1);
        *(_DWORD *)(v12 + *(_DWORD *)(a1 + 48) + 16) = v35;
        v15 = v3 + 8;
        *(_DWORD *)(v12 + *(_DWORD *)(a1 + 48) + 8) = v15;
        v16 = *(_WORD *)(v12 + *(_DWORD *)(a1 + 48) + 6);
        v3 = v16 + v15;
        v31 += -8 - v16;
        if ( v31 < 0 )
        {
          _snprintf(
            &v42,
            0x64u,
            "error with pkt id %d rxsz=%d pipe=%d",
            (unsigned __int16)v13,
            HIWORD(v40),
            *(_BYTE *)(a1 + 1));
          sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1877, 0, &v42);
          goto LABEL_2;
        }
        if ( *(_DWORD *)(a1 + 80) )
          (*(void (__cdecl **)(int, int, _DWORD, _DWORD))(a1 + 80))(
            a1,
            v13,
            *(_WORD *)(v12 + *(_DWORD *)(a1 + 48) + 6),
            *(_DWORD *)(*(_DWORD *)(a1 + 48) + v12 + 8));
        if ( (_WORD)v14 == -1 )
        {
LABEL_39:
          v23 = v30;
          goto LABEL_40;
        }
        v14 = (unsigned __int16)v14;
        v17 = 52 * (unsigned __int16)v14 + *(_DWORD *)(a1 + 32);
        v18 = *(_BYTE *)(v17 + 8);
        if ( v18 )
        {
          v32 = v12 + *(_DWORD *)(a1 + 48);
          if ( *(_WORD *)(v32 + 6) <= *(_WORD *)v17 )
            goto LABEL_23;
          if ( v18 )
            goto LABEL_39;
        }
        v32 = v12 + *(_DWORD *)(a1 + 48);
        if ( *(_WORD *)(v32 + 6) != *(_WORD *)v17 )
          goto LABEL_39;
LABEL_23:
        if ( *(_BYTE *)(*(_DWORD *)(a1 + 24) + v14) != 1 )
          goto LABEL_39;
        v19 = *(_DWORD *)(v12 + *(_DWORD *)(a1 + 48) + 16);
        if ( (v19 & *(_DWORD *)(v17 + 20)) != v19 )
        {
          v20 = *(_DWORD *)(v12 + *(_DWORD *)(a1 + 48) + 16);
          if ( (v20 & 0xC00000) != v20 && !(*(_BYTE *)a1 & 4) )
            goto LABEL_39;
        }
        if ( !(*(_DWORD *)(v17 + 24) & *(_DWORD *)(a1 + 72)) || !(*(_BYTE *)(v17 + 28) & *(_BYTE *)a1) )
          goto LABEL_39;
        if ( *(_DWORD *)(v17 + 12) )
        {
          v21 = *(_DWORD *)(a1 + 64) + 24 * v14;
          v22 = *(_DWORD *)(v21 + 16);
          if ( v22 )
          {
            if ( v39 <= v22 + *(_DWORD *)(a1 + 36) + (*(_DWORD *)(v17 + 16) >> 1)
              && (*(_BYTE *)(v32 + 1) != 1 || *(_BYTE *)(v21 + 1) == 1 && *(_BYTE *)(v32 + 2) > *(_BYTE *)(v21 + 2))
              && (*(_BYTE *)(v21 + 1) == 1 || *(_BYTE *)(v32 + 2) > *(_BYTE *)(v21 + 2))
              && *(_BYTE *)(v32 + 2) != *(_BYTE *)(v21 + 2) )
            {
              goto LABEL_39;
            }
          }
        }
        v23 = v30++ + 1;
LABEL_40:
        if ( !v31 || v23 >= *(_DWORD *)(a1 + 52) )
        {
          if ( v23 )
          {
            sub_1000B770(v23, a1, v39);
            if ( v23 )
            {
              v24 = 0;
              v33 = v23;
              do
              {
                v25 = (unsigned __int16)sub_1000B550(*(_WORD *)(*(_DWORD *)(a1 + 48) + v24 + 4), a1);
                v27 = *(_DWORD *)(a1 + 32) + 52 * (unsigned __int16)v25;
                v28 = *(void (__cdecl **)(int, int))(v27 + 36);
                if ( v28 && *(_DWORD *)(v27 + 12) && !(*(_BYTE *)(*(_DWORD *)(a1 + 64) + 24 * v25 + 6) & 1) )
                  v28(v26, a1);
                v24 += 20;
                --v33;
              }
              while ( v33 );
            }
          }
          v30 = 0;
        }
        if ( v31 <= 0 )
          goto LABEL_2;
        v6 = v30;
      }
    }
  }
  if ( v2 == -95 )
    LOBYTE(v2) = sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2094, 0, 0);
  return v2;
}
// 100080C0: using guessed type int __cdecl j_HWM_pvg_hsdb_get(_DWORD, _DWORD);

//----- (1000C410) --------------------------------------------------------
int __cdecl sub_1000C410(int a1)
{
  int result; // eax@1
  signed __int16 v2; // ax@2
  int v3; // ebx@2
  int v4; // edi@2
  unsigned int *v5; // edx@2
  int v6; // ebp@3
  unsigned int v7; // ecx@3
  unsigned int v8; // ebx@4
  unsigned int v9; // eax@4
  int v10; // ecx@5
  int v11; // eax@5
  int v12; // edx@8
  int v13; // ecx@8
  int v14; // edx@8
  unsigned int v15; // eax@12
  int v16; // edx@16
  int v17; // ST24_4@19
  const char *v18; // eax@19
  int v19; // eax@20
  int v20; // ecx@21
  int v21; // ebx@24
  int v22; // edx@26
  int v23; // eax@27
  int v24; // eax@29
  int v25; // eax@31
  int v26; // edx@31
  int v27; // eax@32
  int v28; // ecx@32
  int v29; // ebp@32
  void (__cdecl *v30)(int, int); // ebp@33
  unsigned int v31; // [sp+8h] [bp-8Ch]@1
  signed int v32; // [sp+Ch] [bp-88h]@1
  unsigned int v33; // [sp+10h] [bp-84h]@1
  int v34; // [sp+14h] [bp-80h]@1
  int v35; // [sp+18h] [bp-7Ch]@2
  int v36; // [sp+1Ch] [bp-78h]@1
  unsigned __int16 v37; // [sp+24h] [bp-70h]@2
  int v38; // [sp+28h] [bp-6Ch]@2
  char v39; // [sp+2Ch] [bp-68h]@19

  v33 = 12;
  v36 = j_HWM_pvg_hsdb_get_lrus_online();
  v32 = 0;
  result = sub_10030040();
  v31 = result;
  v34 = 0;
  if ( *(_DWORD *)(a1 + 12) > 0 )
  {
    do
    {
      v35 = *(_WORD *)(*(_DWORD *)(a1 + 76) + 2 * v34);
      v2 = sub_1000B550(v35, a1);
      v3 = (unsigned __int16)v2;
      v4 = 24 * (unsigned __int16)v2;
      v5 = (unsigned int *)(v4 + *(_DWORD *)(a1 + 64) + 8);
      v37 = v2;
      v38 = (unsigned __int16)v2;
      if ( v31 >= *v5 - *(_DWORD *)(a1 + 36) )
      {
        v6 = 52 * (unsigned __int16)v2;
        v7 = *v5 + *(_DWORD *)(*(_DWORD *)(a1 + 32) + 52 * (unsigned __int16)v2 + 12);
        if ( v31 >= v7 )
        {
          v8 = *(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 12);
          v5 = (unsigned int *)(v4 + *(_DWORD *)(a1 + 64) + 8);
          v9 = v8 * ((*(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 12) - v7 + v31 - 1) / v8);
          v3 = v38;
          v7 += v9;
        }
        *v5 = v7;
        v10 = v36;
        v11 = v6 + *(_DWORD *)(a1 + 32);
        if ( v36 & *(_DWORD *)(v11 + 24) || v10 & 0xC00000 || (*(_DWORD *)(v11 + 32) >> 3) & 1 )
        {
          v15 = *(_WORD *)v11 + v33 + 8;
          if ( v32 > 0 && (v15 > *(_DWORD *)(a1 + 20) || v15 > 0x5B0) )
          {
            sub_1000B570(a1, v32);
            v32 = 0;
            v33 = 12;
          }
          v16 = *(_DWORD *)(a1 + 32);
          if ( !*(_DWORD *)(v16 + v6 + 44) || *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 6) & 4 )
            goto LABEL_42;
          if ( (*(_DWORD *)(v16 + v6 + 32) >> 1) & 1 )
          {
            v17 = *(_BYTE *)(a1 + 1);
            v18 = sub_1000EDC0(a1, v37);
            _snprintf(&v39, 0x64u, "%d-%s is TX_ON_PUT, pipe=%d", (unsigned __int16)v35, v18, v17);
            sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2279, 0, &v39);
          }
          v19 = v4 + *(_DWORD *)(a1 + 64);
          if ( *(_BYTE *)(*(_BYTE *)(a1 + 3) + v3 * *(_BYTE *)(a1 + 2) + *(_DWORD *)(a1 + 56)) > *(_BYTE *)(v19 + 2)
            && (v20 = *(_DWORD *)(v19 + 16)) != 0
            && v31 <= *(_DWORD *)(a1 + 36) + v20 + (*(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 16) >> 1)
            && *(_BYTE *)(v19 + 1) == 1 )
          {
LABEL_42:
            v21 = v35;
          }
          else
          {
            v21 = v35;
            (*(void (__cdecl **)(int, int))(*(_DWORD *)(a1 + 32) + v6 + 44))(v35, a1);
          }
          v22 = *(_DWORD *)(a1 + 64);
          if ( *(_BYTE *)(v4 + v22 + 3) == 1 )
          {
            v23 = *(_DWORD *)(v4 + v22 + 16);
            if ( v23 )
            {
              if ( v31 <= *(_DWORD *)(a1 + 36) + v23 + *(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 12) )
              {
                *(_DWORD *)(v4 + *(_DWORD *)(a1 + 64) + 12) = v31;
                *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 3) = 0;
                v24 = *(_DWORD *)(a1 + 64);
                if ( *(_DWORD *)(v4 + v24 + 20) & *(_DWORD *)(a1 + 72) )
                {
                  if ( *(_WORD *)(v4 + v24 + 4) )
                  {
                    v25 = 20 * v32;
                    *(_DWORD *)(v25 + *(_DWORD *)(a1 + 48) + 8) = *(_DWORD *)(a1 + 28)
                                                                + *(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 4);
                    *(_DWORD *)(v25 + *(_DWORD *)(a1 + 48) + 12) = v36 & *(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 24);
                    *(_WORD *)(v25 + *(_DWORD *)(a1 + 48) + 4) = v21;
                    *(_WORD *)(v25 + *(_DWORD *)(a1 + 48) + 6) = *(_WORD *)(v4 + *(_DWORD *)(a1 + 64) + 4);
                    *(_BYTE *)(v25 + *(_DWORD *)(a1 + 48)) = 0;
                    ++v32;
                    *(_BYTE *)(v25 + *(_DWORD *)(a1 + 48) + 1) = *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 1);
                    *(_BYTE *)(v25 + *(_DWORD *)(a1 + 48) + 2) = *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 2);
                    v26 = *(_DWORD *)(a1 + 32);
                    v33 += *(_WORD *)(v26 + v6) + 8;
                    if ( (*(_DWORD *)(v26 + v6 + 32) >> 2) & 1 )
                    {
                      v27 = *(_DWORD *)(a1 + 32);
                      v28 = *(_DWORD *)(v6 + v27 + 24);
                      v29 = v27 + v6;
                      if ( v28 & *(_DWORD *)(a1 + 72) )
                      {
                        v30 = *(void (__cdecl **)(int, int))(v29 + 36);
                        if ( v30 )
                        {
                          if ( !(*(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 6) & 1) )
                            v30(v21, a1);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        else
        {
          v12 = *(_DWORD *)(a1 + 64);
          v13 = *(_DWORD *)(v12 + v4 + 16);
          v14 = v4 + v12;
          if ( (!v13 || v31 > *(_DWORD *)(a1 + 36) + v13 + *(_DWORD *)(v11 + 16)) && *(_BYTE *)(v14 + 1) == 1 )
          {
            *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 1) = 0;
            *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 3) = 0;
          }
        }
      }
      ++v34;
    }
    while ( v34 < *(_DWORD *)(a1 + 12) );
    result = v32;
    if ( v32 > 0 && v33 <= *(_DWORD *)(a1 + 20) )
      result = sub_1000B570(a1, v32);
  }
  return result;
}
// 100080D0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (1000C7A0) --------------------------------------------------------
char __cdecl sub_1000C7A0(int a1, char a2, int a3, const void *a4, int a5)
{
  signed __int16 v5; // ax@1
  int v6; // ebx@2
  int v7; // ebp@2
  int v8; // edi@2
  int v9; // ecx@2
  int v10; // ST2C_4@4
  const char *v11; // eax@4
  int v12; // eax@5
  int v13; // edx@5
  int v14; // ecx@7
  int v15; // edx@7
  int v16; // ecx@7
  int v17; // eax@15
  unsigned int v18; // ecx@15
  int v19; // eax@15
  int v20; // edx@16
  int (__cdecl *v21)(int, int); // ebp@18
  int v22; // ST2C_4@23
  int v23; // ST28_4@23
  int v24; // ST24_4@23
  const char *v25; // eax@23
  unsigned int v26; // eax@4
  unsigned int v28; // [sp+10h] [bp-70h]@5
  char v29; // [sp+18h] [bp-68h]@4

  v5 = sub_1000B550(a1, a3);
  if ( v5 == -1
    || (v6 = (unsigned __int16)v5,
        v7 = 52 * (unsigned __int16)v5,
        v8 = 24 * (unsigned __int16)v5,
        v9 = v7 + *(_DWORD *)(a3 + 32),
        *(_WORD *)(*(_DWORD *)(a3 + 64) + v8 + 4) != *(_WORD *)v9) )
  {
    if ( (signed int)(unsigned __int16)a1 >= *(_DWORD *)(a3 + 4) || v5 == -1 )
    {
      _snprintf(&v29, 0x64u, "pkt:%d lut_id:%d pipe:%d", (unsigned __int16)a1, (unsigned __int16)v5, *(_BYTE *)(a3 + 1));
      LOBYTE(v26) = sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2645, 0, &v29);
    }
    else
    {
      v22 = *(_BYTE *)(a3 + 1);
      v23 = *(_WORD *)(52 * (unsigned __int16)v5 + *(_DWORD *)(a3 + 32));
      v24 = *(_WORD *)(*(_DWORD *)(a3 + 64) + 24 * (unsigned __int16)v5 + 4);
      v25 = sub_1000EDC0(a3, v5);
      _snprintf(&v29, 0x64u, "%d-%s stssz=%d infsz=%d pipe=%d", (unsigned __int16)a1, v25, v24, v23, v22);
      LOBYTE(v26) = sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2660, 0, &v29);
    }
  }
  else if ( *(_BYTE *)(v9 + 8) )
  {
    v10 = *(_BYTE *)(a3 + 1);
    v11 = sub_1000EDC0(a3, v5);
    _snprintf(&v29, 0x64u, "%d-%s is var pipe=%d", (unsigned __int16)a1, v11, v10);
    LOBYTE(v26) = sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2511, 0, &v29);
  }
  else
  {
    v12 = sub_10030040();
    v13 = *(_DWORD *)(a3 + 32);
    v28 = v12;
    if ( !*(_DWORD *)(v13 + v7 + 12)
      || (v26 = *(_DWORD *)(v13 + v7 + 16), v28 <= a5 + v26 + *(_DWORD *)(a3 + 36))
      && ((v14 = *(_DWORD *)(a3 + 64), v15 = *(_DWORD *)(v14 + v8 + 16), v16 = v8 + v14, !v15)
       || v28 > *(_DWORD *)(a3 + 36) + v15 + (v26 >> 1)
       || a2
       && (*(_BYTE *)(v16 + 1) != 1
        || *(_BYTE *)(*(_BYTE *)(a3 + 3) + v6 * *(_BYTE *)(a3 + 2) + *(_DWORD *)(a3 + 56)) <= *(_BYTE *)(v16 + 2))
       || *(_BYTE *)(v16 + 1) != 1
       && *(_BYTE *)(*(_BYTE *)(a3 + 3) + v6 * *(_BYTE *)(a3 + 2) + *(_DWORD *)(a3 + 56)) <= *(_BYTE *)(v16 + 2)
       || (v26 = *(_DWORD *)(a3 + 56),
           *(_BYTE *)(*(_BYTE *)(a3 + 3) + v6 * *(_BYTE *)(a3 + 2) + v26) == *(_BYTE *)(v16 + 2))) )
    {
      sub_10030160(*(_DWORD *)(a3 + 60), -1);
      *(_BYTE *)(*(_DWORD *)(a3 + 64) + v8 + 1) = a2;
      *(_DWORD *)(*(_DWORD *)(a3 + 64) + v8 + 16) = a5;
      *(_BYTE *)(*(_DWORD *)(a3 + 64) + v8 + 2) = *(_BYTE *)(*(_BYTE *)(a3 + 3)
                                                           + v6 * *(_BYTE *)(a3 + 2)
                                                           + *(_DWORD *)(a3 + 56));
      *(_BYTE *)(v8 + *(_DWORD *)(a3 + 64)) = 0;
      *(_BYTE *)(*(_DWORD *)(a3 + 64) + v8 + 3) = 1;
      *(_DWORD *)(*(_DWORD *)(a3 + 64) + v8 + 20) = *(_DWORD *)(a3 + 72);
      v17 = *(_DWORD *)(a3 + 32);
      v18 = *(_DWORD *)(v17 + v7 + 32);
      v19 = v7 + v17;
      if ( (v18 >> 1) & 1 )
      {
        v20 = *(_DWORD *)(a3 + 64);
        if ( v28 < *(_DWORD *)(v20 + v8 + 8) )
          *(_DWORD *)(v20 + v8 + 8) -= *(_DWORD *)(v19 + 12);
      }
      memcpy(
        (void *)(*(_DWORD *)(a3 + 28) + *(_DWORD *)(*(_DWORD *)(a3 + 32) + v7 + 4)),
        a4,
        *(_WORD *)(*(_DWORD *)(a3 + 64) + v8 + 4));
      LOBYTE(v26) = sub_10030140(*(_DWORD *)(a3 + 60));
      v21 = *(int (__cdecl **)(int, int))(*(_DWORD *)(a3 + 32) + v7 + 48);
      if ( v21 && !(*(_BYTE *)(*(_DWORD *)(a3 + 64) + v8 + 6) & 8) )
        LOBYTE(v26) = v21(a1, a3);
    }
  }
  return v26;
}

//----- (1000CAB0) --------------------------------------------------------
char __cdecl sub_1000CAB0(int a1, unsigned __int16 a2, char a3, int a4, const void *a5, int a6)
{
  signed __int16 v6; // ax@1
  int v7; // ebp@2
  int v8; // ebx@2
  int v9; // ecx@2
  int v10; // ST28_4@4
  const char *v11; // eax@4
  unsigned int v12; // edx@5
  int v13; // ecx@5
  unsigned int v14; // ecx@6
  int v15; // edx@7
  int v16; // edi@7
  int v17; // edi@14
  int v18; // eax@14
  int v19; // ecx@15
  int (__cdecl *v20)(int, int); // ebx@17
  int v21; // ST28_4@22
  const char *v22; // eax@22
  int v23; // eax@4
  unsigned int v25; // [sp+10h] [bp-70h]@5
  char v26; // [sp+18h] [bp-68h]@4

  v6 = sub_1000B550(a1, a4);
  if ( v6 == -1
    || (v7 = (unsigned __int16)v6, v8 = 52 * (unsigned __int16)v6, v9 = v8 + *(_DWORD *)(a4 + 32), a2 > *(_WORD *)v9) )
  {
    if ( (signed int)(unsigned __int16)a1 >= *(_DWORD *)(a4 + 4) || v6 == -1 )
    {
      _snprintf(&v26, 0x64u, "pkt:%d lut_id:%d pipe:%d", (unsigned __int16)a1, (unsigned __int16)v6, *(_BYTE *)(a4 + 1));
      LOBYTE(v23) = sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2939, 0, &v26);
    }
    else
    {
      v21 = *(_BYTE *)(a4 + 1);
      v22 = sub_1000EDC0(a4, v6);
      _snprintf(&v26, 0x64u, "%d-%s >max sz sz=%d pipe=%d", (unsigned __int16)a1, v22, a2, v21);
      LOBYTE(v23) = sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2953, 0, &v26);
    }
  }
  else if ( *(_BYTE *)(v9 + 8) == 1 )
  {
    v12 = sub_10030040();
    v13 = *(_DWORD *)(a4 + 32) + v8;
    v25 = v12;
    if ( !*(_DWORD *)(v13 + 12)
      || (v14 = *(_DWORD *)(v13 + 16), v23 = *(_DWORD *)(a4 + 36), v12 <= a6 + v23 + v14)
      && ((v15 = *(_DWORD *)(a4 + 64) + 24 * v7, (v16 = *(_DWORD *)(v15 + 16)) == 0)
       || v25 > v23 + v16 + (v14 >> 1)
       || a3
       && (*(_BYTE *)(v15 + 1) != 1
        || (LOBYTE(v23) = *(_BYTE *)(*(_BYTE *)(a4 + 3) + v7 * *(_BYTE *)(a4 + 2) + *(_DWORD *)(a4 + 56)),
            (unsigned __int8)v23 <= *(_BYTE *)(v15 + 2)))
       || *(_BYTE *)(v15 + 1) != 1
       && (v23 = *(_DWORD *)(a4 + 56),
           *(_BYTE *)(*(_BYTE *)(a4 + 3) + v7 * *(_BYTE *)(a4 + 2) + v23) <= *(_BYTE *)(v15 + 2))) )
    {
      sub_10030160(*(_DWORD *)(a4 + 60), -1);
      v17 = 24 * v7;
      *(_WORD *)(v17 + *(_DWORD *)(a4 + 64) + 4) = a2;
      *(_BYTE *)(v17 + *(_DWORD *)(a4 + 64) + 1) = a3;
      *(_DWORD *)(v17 + *(_DWORD *)(a4 + 64) + 16) = a6;
      *(_BYTE *)(v17 + *(_DWORD *)(a4 + 64) + 2) = *(_BYTE *)(*(_BYTE *)(a4 + 3)
                                                            + v7 * *(_BYTE *)(a4 + 2)
                                                            + *(_DWORD *)(a4 + 56));
      *(_BYTE *)(v17 + *(_DWORD *)(a4 + 64)) = 0;
      *(_BYTE *)(v17 + *(_DWORD *)(a4 + 64) + 3) = 1;
      *(_DWORD *)(v17 + *(_DWORD *)(a4 + 64) + 20) = *(_DWORD *)(a4 + 72);
      v18 = *(_DWORD *)(a4 + 32) + v8;
      if ( (*(_DWORD *)(v18 + 32) >> 1) & 1 )
      {
        v19 = *(_DWORD *)(a4 + 64);
        if ( v25 < *(_DWORD *)(v17 + v19 + 8) )
          *(_DWORD *)(v17 + v19 + 8) -= *(_DWORD *)(v18 + 12);
      }
      memcpy(
        (void *)(*(_DWORD *)(a4 + 28) + *(_DWORD *)(*(_DWORD *)(a4 + 32) + v8 + 4)),
        a5,
        *(_WORD *)(v17 + *(_DWORD *)(a4 + 64) + 4));
      sub_10030140(*(_DWORD *)(a4 + 60));
      v23 = *(_DWORD *)(a4 + 32);
      v20 = *(int (__cdecl **)(int, int))(v23 + v8 + 48);
      if ( v20 && !(*(_BYTE *)(v17 + *(_DWORD *)(a4 + 64) + 6) & 8) )
        LOBYTE(v23) = v20(a1, a4);
    }
  }
  else
  {
    v10 = *(_BYTE *)(a4 + 1);
    v11 = sub_1000EDC0(a4, v6);
    _snprintf(&v26, 0x64u, "%d-%s !var pipe=%d", (unsigned __int16)a1, v11, v10);
    LOBYTE(v23) = sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2802, 0, &v26);
  }
  return v23;
}

//----- (1000CDA0) --------------------------------------------------------
char __cdecl sub_1000CDA0(int a1, int a2, int a3)
{
  signed __int16 v3; // ax@1
  char result; // al@2
  int v5; // ecx@3
  int v6; // ebp@3
  int v7; // eax@3
  int v8; // edi@3
  int v9; // ebx@3
  int v10; // ST24_4@5
  const char *v11; // eax@5
  int v12; // eax@7
  int v13; // ebp@10
  void (__cdecl *v14)(int, int); // eax@10
  char v15; // cl@13
  int v16; // edx@13
  __int16 v17; // ax@13
  bool v18; // cf@13
  bool v19; // zf@13
  int v20; // ebx@17
  int v21; // eax@19
  char v22; // dl@19
  __int16 v23; // cx@19
  unsigned int v24; // eax@20
  int v25; // ecx@20
  int v26; // edi@21
  char v27; // [sp+6h] [bp-7Eh]@3
  char v28; // [sp+7h] [bp-7Dh]@17
  int v29; // [sp+8h] [bp-7Ch]@13
  int v30; // [sp+Ch] [bp-78h]@13
  char v31; // [sp+10h] [bp-74h]@13
  char v32; // [sp+11h] [bp-73h]@15
  __int16 v33; // [sp+12h] [bp-72h]@13
  int v34; // [sp+14h] [bp-70h]@1
  int v35; // [sp+18h] [bp-6Ch]@19
  char v36; // [sp+1Ch] [bp-68h]@5

  v3 = sub_1000B550(a1, a3);
  v34 = (unsigned __int16)v3;
  if ( v3 == -1 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD *)(a3 + 72);
    v6 = (unsigned __int16)v3;
    v7 = *(_DWORD *)(a3 + 32);
    v8 = 52 * v6;
    v9 = a2 & ~v5 & (*(_DWORD *)(v7 + 52 * v6 + 24) | 0xC00000);
    v27 = 1;
    if ( !*(_DWORD *)(52 * v6 + v7 + 12) || (*(_DWORD *)(*(_DWORD *)(a3 + 32) + v8 + 32) >> 6) & 1 )
    {
      if ( *(_BYTE *)(*(_DWORD *)(a3 + 24) + v6) != 1 )
        goto LABEL_26;
      v12 = v8 + *(_DWORD *)(a3 + 32);
      if ( !(v5 & *(_DWORD *)(v12 + 20)) || !(*(_BYTE *)(v12 + 28) & *(_BYTE *)a3) || !v9 )
        goto LABEL_26;
      v13 = 24 * v6;
      *(_DWORD *)(*(_DWORD *)(a3 + 64) + v13 + 12) = sub_10030040();
      v14 = *(void (__cdecl **)(int, int))(*(_DWORD *)(a3 + 32) + v8 + 44);
      if ( v14 && !(*(_BYTE *)(*(_DWORD *)(a3 + 64) + v13 + 6) & 4) )
        v14(a1, a3);
      v15 = *(_BYTE *)(a3 + 1);
      v16 = *(_DWORD *)(a3 + 64);
      v30 = *(_DWORD *)(a3 + 16);
      v31 = v15;
      v29 = v9;
      v17 = *(_WORD *)(v16 + v13 + 4) + 20;
      v18 = (unsigned int)(unsigned __int16)v17 < *(_DWORD *)(a3 + 20);
      v19 = (unsigned __int16)v17 == *(_DWORD *)(a3 + 20);
      v33 = *(_WORD *)(v16 + v13 + 4) + 20;
      if ( !v18 && !v19 )
      {
        sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3198, 1, 0);
        v17 = v33;
      }
      v19 = *(_BYTE *)(a3 + 1) == 6;
      v32 = *(_BYTE *)(*(_DWORD *)(a3 + 32) + v8 + 32) & 1;
      if ( v19 || !(a2 & *(_DWORD *)(a3 + 84)) )
      {
        v28 = 1;
        v20 = *(_DWORD *)(a3 + 16) + 12;
      }
      else
      {
        v20 = *(_DWORD *)(a3 + 16);
        v28 = 0;
        v33 = v17 - 12;
      }
      sub_10030160(*(_DWORD *)(a3 + 60), -1);
      v21 = *(_DWORD *)(a3 + 64) + v13;
      v22 = *(_BYTE *)(v21 + 1);
      LOWORD(v34) = a1;
      v23 = *(_WORD *)(v21 + 4);
      BYTE1(v35) = *(_BYTE *)(v21 + 2);
      HIWORD(v34) = v23;
      *(_DWORD *)v20 = v34;
      LOBYTE(v35) = v22;
      *(_DWORD *)(v20 + 4) = v35;
      memcpy(
        (void *)(v20 + 8),
        (const void *)(*(_DWORD *)(a3 + 28) + *(_DWORD *)(*(_DWORD *)(a3 + 32) + v8 + 4)),
        *(_WORD *)(*(_DWORD *)(a3 + 64) + v13 + 4));
      if ( v28 )
      {
        v24 = sub_100322A0(
                (unsigned int *)(*(_DWORD *)(a3 + 16) + 12),
                *(_WORD *)(*(_DWORD *)(a3 + 64) + v13 + 4) + 8,
                0xFFFFFFFF);
        v25 = *(_DWORD *)(a3 + 16);
        v34 = 327678;
        LOWORD(v35) = 1;
        *(_DWORD *)v25 = 327678;
        *(_DWORD *)(v25 + 4) = v35;
        *(_DWORD *)(v25 + 8) = v24;
      }
      v26 = j_HWM_pvg_hsdb_put(&v29);
      sub_10030140(*(_DWORD *)(a3 + 60));
      if ( v26 < 0 )
LABEL_26:
        v27 = 0;
      result = v27;
    }
    else
    {
      v10 = *(_BYTE *)(a3 + 1);
      v11 = sub_1000EDC0(a3, v34);
      _snprintf(&v36, 0x64u, "%d-%s is prdc pipe=%d", (unsigned __int16)a1, v11, v10);
      sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3123, 0, &v36);
      result = 0;
    }
  }
  return result;
}
// 10008100: using guessed type int __cdecl j_HWM_pvg_hsdb_put(_DWORD);

//----- (1000D060) --------------------------------------------------------
char __cdecl sub_1000D060(int a1, int a2, void *a3, char a4, int a5)
{
  signed __int16 v5; // ax@1
  char result; // al@2
  int v7; // ebp@3
  int v8; // ebx@3
  int v9; // eax@3
  int v10; // ecx@3
  int v11; // edi@3
  int v12; // ST24_4@4
  const char *v13; // eax@4
  int v14; // eax@6
  int v15; // ebp@9
  char v16; // cl@9
  int v17; // edx@9
  __int16 v18; // ax@9
  bool v19; // cf@9
  bool v20; // zf@9
  int v21; // edi@13
  char v22; // bl@13
  int v23; // eax@15
  __int16 v24; // cx@15
  int v25; // ecx@15
  void *v26; // edx@15
  unsigned int v27; // eax@16
  int v28; // ecx@16
  int v29; // edi@17
  char v30; // [sp+7h] [bp-81h]@3
  int v31; // [sp+8h] [bp-80h]@9
  int v32; // [sp+Ch] [bp-7Ch]@9
  char v33; // [sp+10h] [bp-78h]@9
  char v34; // [sp+11h] [bp-77h]@11
  __int16 v35; // [sp+12h] [bp-76h]@9
  void *v36; // [sp+14h] [bp-74h]@1
  int v37; // [sp+18h] [bp-70h]@1
  int v38; // [sp+1Ch] [bp-6Ch]@15
  char v39; // [sp+20h] [bp-68h]@4

  v36 = a3;
  v5 = sub_1000B550(a1, a5);
  v37 = (unsigned __int16)v5;
  if ( v5 == -1 )
  {
    result = 0;
  }
  else
  {
    v7 = (unsigned __int16)v5;
    v8 = 52 * (unsigned __int16)v5;
    v9 = *(_DWORD *)(a5 + 32) + v8;
    v10 = *(_DWORD *)(a5 + 72);
    v11 = a2 & ~v10 & (*(_DWORD *)(v9 + 24) | 0xC00000);
    v30 = 0;
    if ( *(_DWORD *)(v9 + 12) )
    {
      v12 = *(_BYTE *)(a5 + 1);
      v13 = sub_1000EDC0(a5, v37);
      _snprintf(&v39, 0x64u, "%d-%s is prdc pipe=%d", (unsigned __int16)a1, v13, v12);
      sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3486, 0, &v39);
      result = 0;
    }
    else
    {
      if ( *(_BYTE *)(*(_DWORD *)(a5 + 24) + v7) == 1
        && (v14 = v8 + *(_DWORD *)(a5 + 32), v10 & *(_DWORD *)(v14 + 20))
        && *(_BYTE *)(v14 + 28) & *(_BYTE *)a5
        && v11 )
      {
        v15 = 24 * v7;
        *(_DWORD *)(*(_DWORD *)(a5 + 64) + v15 + 12) = sub_10030040();
        v16 = *(_BYTE *)(a5 + 1);
        v17 = *(_DWORD *)(a5 + 64);
        v32 = *(_DWORD *)(a5 + 16);
        v33 = v16;
        v31 = v11;
        v18 = *(_WORD *)(v17 + v15 + 4) + 20;
        v19 = (unsigned int)(unsigned __int16)v18 < *(_DWORD *)(a5 + 20);
        v20 = (unsigned __int16)v18 == *(_DWORD *)(a5 + 20);
        v35 = *(_WORD *)(v17 + v15 + 4) + 20;
        if ( !v19 && !v20 )
        {
          sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3535, 1, 0);
          v18 = v35;
        }
        v20 = *(_BYTE *)(a5 + 1) == 6;
        v34 = *(_BYTE *)(*(_DWORD *)(a5 + 32) + v8 + 32) & 1;
        if ( v20 || !(a2 & *(_DWORD *)(a5 + 84)) )
        {
          v22 = 1;
          v21 = *(_DWORD *)(a5 + 16) + 12;
        }
        else
        {
          v21 = *(_DWORD *)(a5 + 16);
          v22 = 0;
          v35 = v18 - 12;
        }
        sub_10030160(*(_DWORD *)(a5 + 60), -1);
        v23 = *(_DWORD *)(a5 + 64) + v15;
        LOWORD(v37) = a1;
        v24 = *(_WORD *)(v23 + 4);
        LOBYTE(v23) = *(_BYTE *)(v23 + 2);
        HIWORD(v37) = v24;
        v25 = v37;
        LOBYTE(v38) = a4;
        BYTE1(v38) = v23;
        *(_DWORD *)(v21 + 4) = v38;
        v26 = v36;
        *(_DWORD *)v21 = v25;
        memcpy((void *)(v21 + 8), v26, *(_WORD *)(*(_DWORD *)(a5 + 64) + v15 + 4));
        if ( v22 )
        {
          v27 = sub_100322A0(
                  (unsigned int *)(*(_DWORD *)(a5 + 16) + 12),
                  *(_WORD *)(*(_DWORD *)(a5 + 64) + v15 + 4) + 8,
                  0xFFFFFFFF);
          v28 = *(_DWORD *)(a5 + 16);
          v37 = 327678;
          LOWORD(v38) = 1;
          *(_DWORD *)v28 = 327678;
          *(_DWORD *)(v28 + 4) = v38;
          *(_DWORD *)(v28 + 8) = v27;
        }
        v29 = j_HWM_pvg_hsdb_put(&v31);
        sub_10030140(*(_DWORD *)(a5 + 60));
        if ( v29 >= 0 )
          v30 = 1;
      }
      else
      {
        v30 = 0;
      }
      result = v30;
    }
  }
  return result;
}
// 10008100: using guessed type int __cdecl j_HWM_pvg_hsdb_put(_DWORD);

//----- (1000D2F0) --------------------------------------------------------
char __cdecl sub_1000D2F0(int a1, unsigned __int16 a2, int a3, void *a4, char a5, int a6)
{
  signed __int16 v6; // ax@1
  char result; // al@2
  int v8; // ebx@3
  int v9; // ebp@3
  int v10; // eax@3
  int v11; // ecx@3
  int v12; // edi@3
  int v13; // ST24_4@4
  const char *v14; // eax@4
  int v15; // eax@6
  int v16; // ebx@9
  char v17; // cl@9
  unsigned int v18; // edx@9
  bool v19; // cf@9
  bool v20; // zf@9
  int v21; // edi@13
  int v22; // ecx@15
  char v23; // dl@15
  void *v24; // eax@15
  int v25; // edx@15
  unsigned int v26; // eax@16
  int v27; // ecx@16
  int v28; // edi@17
  char v29; // [sp+6h] [bp-82h]@3
  char v30; // [sp+7h] [bp-81h]@13
  int v31; // [sp+8h] [bp-80h]@9
  int v32; // [sp+Ch] [bp-7Ch]@9
  char v33; // [sp+10h] [bp-78h]@9
  char v34; // [sp+11h] [bp-77h]@11
  __int16 v35; // [sp+12h] [bp-76h]@9
  void *v36; // [sp+14h] [bp-74h]@1
  int v37; // [sp+18h] [bp-70h]@1
  int v38; // [sp+1Ch] [bp-6Ch]@15
  char v39; // [sp+20h] [bp-68h]@4

  v36 = a4;
  v6 = sub_1000B550(a1, a6);
  v37 = (unsigned __int16)v6;
  if ( v6 == -1 )
  {
    result = 0;
  }
  else
  {
    v8 = (unsigned __int16)v6;
    v9 = 52 * (unsigned __int16)v6;
    v10 = *(_DWORD *)(a6 + 32) + v9;
    v11 = *(_DWORD *)(a6 + 72);
    v12 = a3 & ~v11 & (*(_DWORD *)(v10 + 24) | 0xC00000);
    v29 = 0;
    if ( *(_DWORD *)(v10 + 12) )
    {
      v13 = *(_BYTE *)(a6 + 1);
      v14 = sub_1000EDC0(a6, v37);
      _snprintf(&v39, 0x64u, "%d-%s is prdc pipe=%d", (unsigned __int16)a1, v14, v13);
      sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3771, 0, &v39);
      result = 0;
    }
    else
    {
      if ( *(_BYTE *)(v8 + *(_DWORD *)(a6 + 24)) == 1
        && (v15 = v9 + *(_DWORD *)(a6 + 32), v11 & *(_DWORD *)(v15 + 20))
        && *(_BYTE *)(v15 + 28) & *(_BYTE *)a6
        && v12 )
      {
        v16 = 24 * v8;
        *(_DWORD *)(*(_DWORD *)(a6 + 64) + v16 + 12) = sub_10030040();
        v17 = *(_BYTE *)(a6 + 1);
        v32 = *(_DWORD *)(a6 + 16);
        v18 = (unsigned __int16)(a2 + 20);
        v19 = v18 < *(_DWORD *)(a6 + 20);
        v20 = v18 == *(_DWORD *)(a6 + 20);
        v31 = v12;
        v33 = v17;
        v35 = a2 + 20;
        if ( !v19 && !v20 )
          sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3832, 1, 0);
        v20 = *(_BYTE *)(a6 + 1) == 6;
        v34 = *(_BYTE *)(*(_DWORD *)(a6 + 32) + v9 + 32) & 1;
        if ( v20 || !(a3 & *(_DWORD *)(a6 + 84)) )
        {
          v30 = 1;
          v21 = *(_DWORD *)(a6 + 16) + 12;
        }
        else
        {
          v21 = *(_DWORD *)(a6 + 16);
          v35 -= 12;
          v30 = 0;
        }
        sub_10030160(*(_DWORD *)(a6 + 60), -1);
        LOWORD(v37) = a1;
        v22 = *(_DWORD *)(a6 + 64);
        LOBYTE(v38) = a5;
        v23 = *(_BYTE *)(v22 + v16 + 2);
        HIWORD(v37) = a2;
        v24 = v36;
        BYTE1(v38) = v23;
        v25 = v38;
        *(_DWORD *)v21 = v37;
        *(_DWORD *)(v21 + 4) = v25;
        memcpy((void *)(v21 + 8), v24, a2);
        if ( v30 )
        {
          v26 = sub_100322A0((unsigned int *)(*(_DWORD *)(a6 + 16) + 12), a2 + 8, 0xFFFFFFFF);
          v27 = *(_DWORD *)(a6 + 16);
          v37 = 327678;
          LOWORD(v38) = 1;
          *(_DWORD *)v27 = 327678;
          *(_DWORD *)(v27 + 4) = v38;
          *(_DWORD *)(v27 + 8) = v26;
        }
        v28 = j_HWM_pvg_hsdb_put(&v31);
        sub_10030140(*(_DWORD *)(a6 + 60));
        if ( v28 >= 0 )
          v29 = 1;
      }
      else
      {
        v29 = 0;
      }
      result = v29;
    }
  }
  return result;
}
// 10008100: using guessed type int __cdecl j_HWM_pvg_hsdb_put(_DWORD);

//----- (1000D580) --------------------------------------------------------
int __cdecl sub_1000D580(int a1)
{
  int result; // eax@1
  int v2; // edi@2
  int v3; // eax@2
  int v4; // ecx@2
  int v5; // edx@2
  int v6; // edx@3
  void (__cdecl *v7)(int, int); // eax@5
  int i; // [sp+4h] [bp-8h]@1
  unsigned int v9; // [sp+8h] [bp-4h]@1

  v9 = sub_10030040();
  result = 0;
  for ( i = 0; i < *(_DWORD *)(a1 + 8); ++i )
  {
    v2 = *(_WORD *)(*(_DWORD *)(a1 + 68) + 2 * result);
    v3 = (unsigned __int16)sub_1000B550(v2, a1);
    v4 = 24 * (unsigned __int16)v3;
    v5 = v4 + *(_DWORD *)(a1 + 64);
    if ( !*(_BYTE *)v5 )
    {
      v6 = *(_DWORD *)(v5 + 16);
      if ( !v6 || v9 > v6 + *(_DWORD *)(a1 + 36) + *(_DWORD *)(52 * v3 + *(_DWORD *)(a1 + 32) + 16) )
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 64) + v4 + 1) = 0;
        *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64)) = 1;
        v7 = *(void (__cdecl **)(int, int))(52 * v3 + *(_DWORD *)(a1 + 32) + 40);
        if ( v7 )
        {
          if ( !(*(_BYTE *)(*(_DWORD *)(a1 + 64) + v4 + 6) & 2) )
            v7(v2, a1);
        }
      }
    }
    result = i + 1;
  }
  return result;
}

//----- (1000D640) --------------------------------------------------------
char __cdecl sub_1000D640(int a1, int a2, void *a3)
{
  return sub_1000B990(a1, a2, a3, 0xFFFFu);
}

//----- (1000D660) --------------------------------------------------------
char __cdecl sub_1000D660(int a1, int a2, void *a3, unsigned __int16 *a4)
{
  return sub_1000BCA0(a1, a2, a3, a4, 0xFFFFu);
}

//----- (1000D690) --------------------------------------------------------
int __cdecl sub_1000D690(int a1)
{
  int v1; // esi@1
  int v2; // ecx@3
  signed __int16 v3; // ax@5
  int v4; // ebp@6
  int v5; // edi@6
  int v6; // ecx@6
  unsigned int v7; // edi@6
  int v8; // ST10_4@10
  int v10; // [sp+8h] [bp-8h]@1
  unsigned int v11; // [sp+Ch] [bp-4h]@4
  int v12; // [sp+14h] [bp+4h]@3

  v1 = a1;
  v10 = sub_10030040();
  if ( *(_BYTE *)(a1 + 3) >= 4u )
    sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1321, 1, 0);
  sub_10030160(*(_DWORD *)(a1 + 60), -1);
  v2 = 0;
  v12 = 0;
  if ( *(_DWORD *)(v1 + 4) > 0 )
  {
    v11 = 0;
    do
    {
      v3 = sub_1000B550(v2, v1);
      if ( v3 != -1 )
      {
        v4 = (unsigned __int16)v3;
        v5 = 52 * (unsigned __int16)v3;
        memset(
          (void *)(*(_DWORD *)(v1 + 28) + *(_DWORD *)(*(_DWORD *)(v1 + 32) + v5 + 4)),
          0,
          *(_WORD *)(*(_DWORD *)(v1 + 32) + v5));
        v6 = 24 * v4;
        *(_BYTE *)(v6 + *(_DWORD *)(v1 + 64)) = 0;
        *(_BYTE *)(*(_DWORD *)(v1 + 64) + v6 + 1) = 0;
        *(_BYTE *)(*(_DWORD *)(v1 + 64) + v6 + 2) = -1;
        *(_WORD *)(*(_DWORD *)(v1 + 64) + v6 + 4) = *(_WORD *)(v5 + *(_DWORD *)(v1 + 32));
        *(_DWORD *)(*(_DWORD *)(v1 + 64) + v6 + 16) = 0;
        *(_DWORD *)(*(_DWORD *)(v1 + 64) + v6 + 12) = 0;
        *(_BYTE *)(*(_DWORD *)(v1 + 64) + v6 + 3) = 0;
        *(_BYTE *)(*(_DWORD *)(v1 + 64) + v6 + 6) = 0;
        v7 = *(_DWORD *)(*(_DWORD *)(v1 + 32) + v5 + 12);
        if ( v7 )
          *(_DWORD *)(*(_DWORD *)(v1 + 64) + v6 + 8) = v10 + 25 * (v11 % (v7 / 0x19));
        else
          *(_DWORD *)(*(_DWORD *)(v1 + 64) + v6 + 8) = v10;
      }
      v2 = v12++ + 1;
      v11 = (unsigned __int16)v12;
    }
    while ( (signed int)(unsigned __int16)v12 < *(_DWORD *)(v1 + 4) );
  }
  v8 = *(_DWORD *)(v1 + 60);
  *(_DWORD *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 12) = 0;
  sub_10030140(v8);
  sub_1000BEB0(v1);
  return sub_1000BF60(v1);
}

//----- (1000D7E0) --------------------------------------------------------
int __cdecl sub_1000D7E0(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1020B2B4 |= a1;
  return result;
}
// 1020B2B4: using guessed type int dword_1020B2B4;

//----- (1000D7F0) --------------------------------------------------------
int __cdecl sub_1000D7F0(int a1)
{
  int result; // eax@1

  result = ~a1;
  dword_1020B2B4 &= ~a1;
  return result;
}
// 1020B2B4: using guessed type int dword_1020B2B4;

//----- (1000D800) --------------------------------------------------------
char sub_1000D800()
{
  memset(&byte_101361B0[51664], 0, 0xBEu);
  memset(*(void **)&byte_101361B0[51656], 0, 0x52u);
  sub_1001CA60(
    3,
    0xBEu,
    *(int *)&byte_101361B0[51656],
    (int)&byte_101361B0[51664],
    *(_DWORD *)&byte_101361B0[51656] + 23096);
  sub_1001DC40(
    3,
    0xBEu,
    *(int *)&byte_101361B0[51656],
    (int)&byte_101361B0[51664],
    *(_DWORD *)&byte_101361B0[51656] + 23096);
  sub_1001D110(
    3,
    0xBEu,
    *(int *)&byte_101361B0[51656],
    (int)&byte_101361B0[51664],
    *(_DWORD *)&byte_101361B0[51656] + 23096);
  sub_1001DA30(
    3,
    0xBEu,
    *(int *)&byte_101361B0[51656],
    (int)&byte_101361B0[51664],
    *(_DWORD *)&byte_101361B0[51656] + 23096);
  sub_1001CFE0(
    3,
    0xBEu,
    *(int *)&byte_101361B0[51656],
    (int)&byte_101361B0[51664],
    *(_DWORD *)&byte_101361B0[51656] + 23096);
  sub_1001D040(
    3,
    0xBEu,
    *(int *)&byte_101361B0[51656],
    (int)&byte_101361B0[51664],
    *(_DWORD *)&byte_101361B0[51656] + 23096);
  sub_1001DE60(
    3,
    0xBEu,
    *(int *)&byte_101361B0[51656],
    (int)&byte_101361B0[51664],
    *(_DWORD *)&byte_101361B0[51656] + 23096);
  sub_1001DEC0(
    3,
    0xBEu,
    *(int *)&byte_101361B0[51656],
    (int)&byte_101361B0[51664],
    *(_DWORD *)&byte_101361B0[51656] + 23096);
  sub_1001D8C0(
    3,
    0xBEu,
    *(int *)&byte_101361B0[51656],
    (int)&byte_101361B0[51664],
    *(_DWORD *)&byte_101361B0[51656] + 23096);
  sub_1001D090(
    3,
    0xBEu,
    *(int *)&byte_101361B0[51656],
    (int)&byte_101361B0[51664],
    *(_DWORD *)&byte_101361B0[51656] + 23096);
  return sub_1001D9A0(
           3,
           0xBEu,
           *(int *)&byte_101361B0[51656],
           (int)&byte_101361B0[51664],
           *(_DWORD *)&byte_101361B0[51656] + 23096);
}

//----- (1000D980) --------------------------------------------------------
signed int sub_1000D980()
{
  void *v0; // ecx@4
  int v1; // ecx@6
  unsigned int v2; // eax@6
  int v3; // edx@9
  signed int result; // eax@13
  int v5; // edi@14
  void **v6; // esi@14
  size_t v7; // eax@15

  if ( sub_100313C0((LONG)&off_1004E9F4) )
  {
    memcpy((void *)(*(_DWORD *)&byte_101361B0[51656] + 18832), &unk_1004D7D0, 0x10A8u);
    qmemcpy((void *)(*(_DWORD *)&byte_101361B0[51656] + 23096), &unk_1004E878, 0x17Cu);
  }
  else
  {
    sub_10014D70("..\\lib\\adl\\iop_hsdb_pkt.c", 1037, 1, 0);
  }
  if ( sub_1001DF50() == 1 && sub_10015650(v0) == 4 )
  {
    v1 = *(_DWORD *)&byte_101361B0[51656];
    v2 = 0;
    do
    {
      if ( *(_DWORD *)(v2 + v1 + 18848) )
      {
        *(_DWORD *)(v2 + v1 + 18848) += 1500;
        v1 = *(_DWORD *)&byte_101361B0[51656];
      }
      v3 = *(_DWORD *)(v2 + v1 + 18900);
      if ( v3 )
      {
        *(_DWORD *)(v2 + v1 + 18900) = v3 + 1500;
        v1 = *(_DWORD *)&byte_101361B0[51656];
      }
      v2 += 104;
    }
    while ( v2 < 0x10A8 );
  }
  sub_10030F50((int)&off_1004E9F4);
  if ( sub_100313C0((LONG)&off_1004EC48) )
  {
    v5 = 0;
    v6 = (void **)off_1004EA08;
    do
    {
      v7 = sub_100152E0(*v6, 0x1Cu);
      memcpy((void *)(v5 + *(_DWORD *)&byte_101361B0[51660]), *v6, v7);
      ++v6;
      v5 += 28;
    }
    while ( (signed int)v6 < (signed int)&unk_1004EB50 );
    result = sub_10030F50((int)&off_1004EC48);
  }
  else
  {
    sub_10014D70("..\\lib\\adl\\iop_hsdb_pkt.c", 1087, 1, 0);
    result = sub_10030F50((int)&off_1004EC48);
  }
  return result;
}
// 1004E9F4: using guessed type char *off_1004E9F4;
// 1004EA08: using guessed type char *off_1004EA08[82];
// 1004EC48: using guessed type char *off_1004EC48;

//----- (1000DAC0) --------------------------------------------------------
int sub_1000DAC0()
{
  sub_1000D800();
  sub_1000BEB0((int)&byte_1020B260);
  return sub_1000BF60((int)&byte_1020B260);
}
// 1020B260: using guessed type char byte_1020B260;

//----- (1000DAE0) --------------------------------------------------------
int sub_1000DAE0()
{
  void *v0; // ecx@1
  void *v1; // ecx@1
  char v2; // al@4
  void *v3; // ecx@4
  int result; // eax@8

  *(_DWORD *)&byte_101361B0[51656] = -15;
  *(_DWORD *)&byte_101361B0[51660] = -15;
  sub_1000D980();
  dword_1020B278 = *(_DWORD *)&byte_101361B0[51656];
  dword_1020B27C = *(_DWORD *)&byte_101361B0[51656] + 2052;
  dword_1020B270 = (int)&unk_1020AC80;
  dword_1020B274 = 1476;
  dword_1020B280 = (int)&unk_1004D7D0;
  dword_1020B284 = 12;
  dword_1020B288 = (int)&unk_1004E878;
  byte_1020B261 = 3;
  dword_1020B264 = 190;
  dword_1020B28C = (int)off_1004EA08;
  dword_1020B290 = (int)&unk_1020A540;
  dword_1020B294 = 82;
  dword_1020B298 = (int)&unk_1004EB50;
  byte_1020B262 = 3;
  byte_1020B263 = sub_1001C8C0(v0);
  dword_1020B2B0 = 0;
  dword_1020B29C = 92;
  dword_1020B2A0 = *(_DWORD *)&byte_101361B0[51656] + 84;
  dword_1020B2A4 = (int)&unk_1020ABC0;
  dword_1020B2B4 = 0;
  if ( sub_1001DF50() == 1 && sub_10015650(v1) == 4 )
    dword_1020B280 = *(_DWORD *)&byte_101361B0[51656] + 18832;
  v2 = sub_10015650(v1);
  byte_1020B260 = v2;
  if ( v2 == 8 )
  {
    byte_1020B260 = 11;
  }
  else if ( v2 == 4 )
  {
    byte_1020B260 = 5;
  }
  dword_1020B2A8 = sub_10014FA0(v3);
  dword_1020B2AC = (void *)(*(_DWORD *)&byte_101361B0[51656] + 23476);
  sub_1000D800();
  result = sub_1000D690((int)&byte_1020B260);
  *(_DWORD *)(*(_DWORD *)&byte_101361B0[51656] + 23640) = dword_1020B26C;
  return result;
}
// 1004EA08: using guessed type char *off_1004EA08[82];
// 1020B260: using guessed type char byte_1020B260;
// 1020B261: using guessed type char byte_1020B261;
// 1020B262: using guessed type char byte_1020B262;
// 1020B263: using guessed type char byte_1020B263;
// 1020B264: using guessed type int dword_1020B264;
// 1020B26C: using guessed type int dword_1020B26C;
// 1020B270: using guessed type int dword_1020B270;
// 1020B274: using guessed type int dword_1020B274;
// 1020B278: using guessed type int dword_1020B278;
// 1020B27C: using guessed type int dword_1020B27C;
// 1020B280: using guessed type int dword_1020B280;
// 1020B284: using guessed type int dword_1020B284;
// 1020B288: using guessed type int dword_1020B288;
// 1020B28C: using guessed type int dword_1020B28C;
// 1020B290: using guessed type int dword_1020B290;
// 1020B294: using guessed type int dword_1020B294;
// 1020B298: using guessed type int dword_1020B298;
// 1020B29C: using guessed type int dword_1020B29C;
// 1020B2A0: using guessed type int dword_1020B2A0;
// 1020B2A4: using guessed type int dword_1020B2A4;
// 1020B2A8: using guessed type int dword_1020B2A8;
// 1020B2B0: using guessed type int dword_1020B2B0;
// 1020B2B4: using guessed type int dword_1020B2B4;

//----- (1000DC40) --------------------------------------------------------
int __cdecl sub_1000DC40(char a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 7 )
    result = (unsigned __int16)word_1004FAA4[a1];
  return result;
}
// 1004FAA4: using guessed type __int16 word_1004FAA4[];

//----- (1000DC60) --------------------------------------------------------
int __cdecl sub_1000DC60(char a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 7 )
    result = (unsigned __int16)word_1004FAB4[a1];
  return result;
}
// 1004FAB4: using guessed type __int16 word_1004FAB4[];

//----- (1000DC80) --------------------------------------------------------
signed int sub_1000DC80()
{
  signed int result; // eax@1

  result = -15;
  dword_10142C5C = -15;
  dword_10142C68 = -15;
  dword_10142C44 = -15;
  dword_10142C6C = -15;
  dword_10142C58 = -15;
  dword_10142C48 = -15;
  *(_DWORD *)&byte_101361B0[51856] = -15;
  dword_10142C54 = -15;
  dword_10142C64 = -15;
  dword_10142C60 = -15;
  dword_10142C50 = -15;
  dword_10142C4C = -15;
  return result;
}
// 10142C44: using guessed type int dword_10142C44;
// 10142C48: using guessed type int dword_10142C48;
// 10142C4C: using guessed type int dword_10142C4C;
// 10142C50: using guessed type int dword_10142C50;
// 10142C54: using guessed type int dword_10142C54;
// 10142C58: using guessed type int dword_10142C58;
// 10142C5C: using guessed type int dword_10142C5C;
// 10142C60: using guessed type int dword_10142C60;
// 10142C64: using guessed type int dword_10142C64;
// 10142C68: using guessed type int dword_10142C68;
// 10142C6C: using guessed type int dword_10142C6C;

//----- (1000DCD0) --------------------------------------------------------
signed int __usercall sub_1000DCD0@<eax>(char a1@<al>, int a2@<ecx>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = sub_100312F0((int)&off_1004FAC4);
      break;
    case 0:
      result = sub_100312F0((int)&off_1004FAD8);
      break;
    case 1:
      result = sub_100312F0((int)&off_1004FAEC);
      break;
    case 2:
      result = sub_100312F0((int)&off_1004FB14);
      break;
    case 3:
      result = sub_100312F0((int)&off_1004FB00);
      break;
    case 5:
      result = sub_100312F0((int)&off_1004FB28);
      break;
    default:
      result = sub_100312F0(a2);
      break;
  }
  return result;
}
// 1004FAC4: using guessed type char *off_1004FAC4;
// 1004FAD8: using guessed type char *off_1004FAD8;
// 1004FAEC: using guessed type char *off_1004FAEC;
// 1004FB00: using guessed type char *off_1004FB00;
// 1004FB14: using guessed type char *off_1004FB14;
// 1004FB28: using guessed type char *off_1004FB28;

//----- (1000DD70) --------------------------------------------------------
signed int __usercall sub_1000DD70@<eax>(char a1@<al>, int a2@<ecx>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = sub_100312F0((int)&off_1004FB3C);
      break;
    case 0:
      result = sub_100312F0((int)&off_1004FB50);
      break;
    case 1:
      result = sub_100312F0((int)&off_1004FB64);
      break;
    case 2:
      result = sub_100312F0((int)&off_1004FB8C);
      break;
    case 3:
      result = sub_100312F0((int)&off_1004FB78);
      break;
    case 5:
      result = sub_100312F0((int)&off_1004FBA0);
      break;
    default:
      result = sub_100312F0(a2);
      break;
  }
  return result;
}
// 1004FB3C: using guessed type char *off_1004FB3C;
// 1004FB50: using guessed type char *off_1004FB50;
// 1004FB64: using guessed type char *off_1004FB64;
// 1004FB78: using guessed type char *off_1004FB78;
// 1004FB8C: using guessed type char *off_1004FB8C;
// 1004FBA0: using guessed type char *off_1004FBA0;

//----- (1000DE10) --------------------------------------------------------
int __usercall sub_1000DE10@<eax>(char a1@<al>)
{
  return sub_10030140(dword_1004F5F4[a1]);
}
// 1004F5F4: using guessed type int dword_1004F5F4[];

//----- (1000DE30) --------------------------------------------------------
int __usercall sub_1000DE30@<eax>(char a1@<al>)
{
  return sub_10030160(dword_1004F5F4[a1], 10);
}
// 1004F5F4: using guessed type int dword_1004F5F4[];

//----- (1000DE50) --------------------------------------------------------
char __cdecl sub_1000DE50(char a1, void *a2, int a3)
{
  int v3; // ecx@1
  char result; // al@2
  int v5; // esi@7
  int v6; // esi@11
  int v7; // eax@16

  if ( sub_1000DE30(a1) )
  {
    result = 0;
  }
  else
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_1000DCD0(a1, v3) != 1 )
          goto LABEL_17;
        qmemcpy(a2, (const void *)(dword_10142C5C + 242694), 0x4ACu);
        *(_DWORD *)a3 = *(_DWORD *)(dword_10142C5C + 243892);
        sub_1000DE10(a1);
        result = 1;
        break;
      case 0:
        if ( (unsigned __int8)sub_1000DCD0(a1, v3) != 1 )
          goto LABEL_17;
        v5 = dword_10142C68 + 286336;
        qmemcpy(a2, (const void *)(dword_10142C68 + 286336), 0x420u);
        *((_WORD *)a2 + 528) = *(_WORD *)(v5 + 1056);
        *(_DWORD *)a3 = *(_DWORD *)(dword_10142C68 + 287396);
        sub_1000DE10(a1);
        result = 1;
        break;
      case 1:
        if ( (unsigned __int8)sub_1000DCD0(a1, v3) != 1 )
          goto LABEL_17;
        memcpy(a2, (const void *)(dword_10142C44 + 453848), 0x12F2u);
        *(_DWORD *)a3 = *(_DWORD *)(dword_10142C44 + 458700);
        sub_1000DE10(a1);
        result = 1;
        break;
      case 2:
        if ( (unsigned __int8)sub_1000DCD0(a1, v3) != 1 )
          goto LABEL_17;
        v6 = dword_10142C6C + 357824;
        qmemcpy(a2, (const void *)(dword_10142C6C + 357824), 0x478u);
        *((_WORD *)a2 + 572) = *(_WORD *)(v6 + 1144);
        *(_DWORD *)a3 = *(_DWORD *)(dword_10142C6C + 358972);
        sub_1000DE10(a1);
        result = 1;
        break;
      case 3:
        if ( dword_1020B26C > 82 )
        {
          sub_1000DE10(a1);
          sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 2051, 0, 0);
          result = 0;
        }
        else
        {
          memcpy(a2, dword_1020B2AC, 2 * dword_1020B26C);
          *(_DWORD *)a3 = dword_1020B26C;
          sub_1000DE10(a1);
          result = 1;
        }
        break;
      case 5:
        if ( (unsigned __int8)sub_1000DCD0(a1, v3) != 1 )
          goto LABEL_17;
        v7 = dword_10142C48;
        *(_DWORD *)a2 = *(_DWORD *)(dword_10142C48 + 1812);
        *((_DWORD *)a2 + 1) = *(_DWORD *)(v7 + 1816);
        *(_DWORD *)a3 = *(_DWORD *)(dword_10142C48 + 1820);
        sub_1000DE10(a1);
        result = 1;
        break;
      default:
LABEL_17:
        sub_1000DE10(a1);
        result = 0;
        break;
    }
  }
  return result;
}
// 10142C44: using guessed type int dword_10142C44;
// 10142C48: using guessed type int dword_10142C48;
// 10142C5C: using guessed type int dword_10142C5C;
// 10142C68: using guessed type int dword_10142C68;
// 10142C6C: using guessed type int dword_10142C6C;
// 1020B26C: using guessed type int dword_1020B26C;

//----- (1000E060) --------------------------------------------------------
signed __int16 __usercall sub_1000E060@<ax>(char a1@<al>, unsigned __int16 a2@<si>)
{
  signed __int16 result; // ax@3
  bool v3; // cf@8

  switch ( a1 )
  {
    case 6:
      if ( a2 < 0x2E5u )
      {
        if ( !(unsigned __int8)sub_1000DCD0(a1, a1) )
        {
          sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3201, 0, 0);
          goto LABEL_6;
        }
        result = *(_WORD *)(dword_10142C5C + 2 * a2 + 241212);
        v3 = (unsigned __int16)result < 0x256u;
        goto LABEL_30;
      }
      sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3186, 0, 0);
      return -1;
    default:
      goto LABEL_6;
    case 0:
      if ( a2 >= 0x344u )
      {
        sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3224, 0, 0);
        return -1;
      }
      if ( (unsigned __int8)sub_1000DCD0(a1, a1) )
      {
        result = *(_WORD *)(dword_10142C68 + 2 * a2 + 284664);
        v3 = (unsigned __int16)result < 0x211u;
        goto LABEL_30;
      }
      if ( sub_10015500(15000) )
        goto LABEL_6;
      sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3242, 0, 0);
      return 0;
    case 1:
      if ( a2 >= 0xBCCu )
      {
        sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3265, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_1000DCD0(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_10142C44 + 2 * a2 + 447808);
      v3 = (unsigned __int16)result < 0x979u;
      goto LABEL_30;
    case 2:
      if ( a2 >= 0x388u )
      {
        sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3302, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_1000DCD0(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_10142C6C + 2 * a2 + 356016);
      v3 = (unsigned __int16)result < 0x23Du;
      goto LABEL_30;
    case 3:
      if ( a2 >= 0xBEu )
      {
        sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3339, 0, 0);
        return -1;
      }
      result = *(_WORD *)(dword_1020B288 + 2 * a2);
      v3 = (unsigned __int16)result < 0x52u;
      goto LABEL_30;
    case 5:
      if ( a2 < 4u )
      {
        if ( (unsigned __int8)sub_1000DCD0(a1, a1) )
        {
          result = *(_WORD *)(dword_10142C48 + 2 * a2 + 1804);
          v3 = (unsigned __int16)result < 4u;
LABEL_30:
          if ( !v3 )
            result = -1;
        }
        else
        {
LABEL_6:
          result = 0;
        }
      }
      else
      {
        sub_10014D70("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3377, 0, 0);
        result = -1;
      }
      return result;
  }
}
// 10142C44: using guessed type int dword_10142C44;
// 10142C48: using guessed type int dword_10142C48;
// 10142C5C: using guessed type int dword_10142C5C;
// 10142C68: using guessed type int dword_10142C68;
// 10142C6C: using guessed type int dword_10142C6C;
// 1020B288: using guessed type int dword_1020B288;

//----- (1000E270) --------------------------------------------------------
char __cdecl sub_1000E270(char a1, unsigned __int16 a2, _BYTE *a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v6; // eax@9

  v3 = sub_1000E060(a1, a2);
  if ( v3 != -1 && !sub_1000DE30(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_1000DCD0(a1, v4) != 1 )
          goto LABEL_16;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_10142C5C);
        sub_1000DE10(a1);
        return 1;
      case 0:
        if ( (unsigned __int8)sub_1000DCD0(a1, v4) != 1 )
          goto LABEL_16;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_10142C68);
        sub_1000DE10(a1);
        return 1;
      case 1:
        if ( (unsigned __int8)sub_1000DCD0(a1, v4) != 1 )
          goto LABEL_16;
        v6 = dword_10142C44;
        goto LABEL_15;
      case 2:
        if ( (unsigned __int8)sub_1000DCD0(a1, v4) != 1 )
          goto LABEL_16;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_10142C6C);
        sub_1000DE10(a1);
        return 1;
      case 3:
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_1020B278);
        sub_1000DE10(a1);
        return 1;
      case 5:
        if ( (unsigned __int8)sub_1000DCD0(a1, v4) != 1 )
          goto LABEL_16;
        v6 = dword_10142C48;
LABEL_15:
        *a3 = *(_BYTE *)((unsigned __int16)v3 + v6);
        sub_1000DE10(a1);
        return 1;
      default:
LABEL_16:
        sub_1000DE10(a1);
        break;
    }
  }
  return 0;
}
// 10142C44: using guessed type int dword_10142C44;
// 10142C48: using guessed type int dword_10142C48;
// 10142C5C: using guessed type int dword_10142C5C;
// 10142C68: using guessed type int dword_10142C68;
// 10142C6C: using guessed type int dword_10142C6C;
// 1020B278: using guessed type int dword_1020B278;

//----- (1000E3C0) --------------------------------------------------------
char __cdecl sub_1000E3C0(char a1, unsigned __int16 a2, void *a3)
{
  int v3; // ecx@1
  signed __int16 v4; // si@1
  char result; // al@2

  v4 = sub_1000E060(a1, a2);
  if ( v4 == -1 )
  {
    result = 0;
  }
  else
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_1000DCD0(a1, v3) != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_10142C5C + 210116), 0x34u);
        result = 1;
        break;
      case 0:
        if ( (unsigned __int8)sub_1000DCD0(a1, v3) != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_10142C68 + 257156), 0x34u);
        result = 1;
        break;
      case 1:
        result = sub_1000DCD0(a1, v3);
        if ( result != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_10142C44 + 321708), 0x34u);
        break;
      case 2:
        if ( (unsigned __int8)sub_1000DCD0(a1, v3) != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_10142C6C + 326220), 0x34u);
        result = 1;
        break;
      case 3:
        qmemcpy(a3, (const void *)(dword_1020B280 + 52 * (unsigned __int16)v4), 0x34u);
        result = 1;
        break;
      case 5:
        if ( (unsigned __int8)sub_1000DCD0(a1, v3) != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_10142C48 + 1596), 0x34u);
        result = 1;
        break;
      default:
LABEL_15:
        result = 0;
        break;
    }
  }
  return result;
}
// 10142C44: using guessed type int dword_10142C44;
// 10142C48: using guessed type int dword_10142C48;
// 10142C5C: using guessed type int dword_10142C5C;
// 10142C68: using guessed type int dword_10142C68;
// 10142C6C: using guessed type int dword_10142C6C;
// 1020B280: using guessed type int dword_1020B280;

//----- (1000E530) --------------------------------------------------------
char __cdecl sub_1000E530(char a1, unsigned __int16 a2, _DWORD *a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  char result; // al@5

  v3 = sub_1000E060(a1, a2);
  if ( v3 == -1 || sub_1000DE30(a1) )
  {
LABEL_16:
    result = 0;
  }
  else
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_1000DD70(a1, v4) != 1 )
          goto LABEL_15;
        *a3 = *(_DWORD *)&byte_101361B0[51856] + 41 * (unsigned __int16)v3;
        sub_1000DE10(a1);
        result = 1;
        break;
      case 0:
        if ( (unsigned __int8)sub_1000DD70(a1, v4) != 1 )
          goto LABEL_15;
        *a3 = dword_10142C54 + 40 * (unsigned __int16)v3;
        sub_1000DE10(a1);
        result = 1;
        break;
      case 1:
        if ( (unsigned __int8)sub_1000DD70(a1, v4) != 1 )
          goto LABEL_15;
        *a3 = dword_10142C64 + 39 * (unsigned __int16)v3;
        sub_1000DE10(a1);
        result = 1;
        break;
      case 2:
        if ( (unsigned __int8)sub_1000DD70(a1, v4) != 1 )
          goto LABEL_15;
        *a3 = dword_10142C60 + 36 * (unsigned __int16)v3;
        sub_1000DE10(a1);
        result = 1;
        break;
      case 3:
        *a3 = *(_DWORD *)(dword_1020B28C + 4 * (unsigned __int16)v3);
        sub_1000DE10(a1);
        result = 1;
        break;
      case 5:
        if ( (unsigned __int8)sub_1000DD70(a1, v4) != 1 )
          goto LABEL_15;
        *a3 = dword_10142C4C + 22 * (unsigned __int16)v3;
        sub_1000DE10(a1);
        result = 1;
        break;
      default:
LABEL_15:
        sub_1000DE10(a1);
        goto LABEL_16;
    }
  }
  return result;
}
// 10142C4C: using guessed type int dword_10142C4C;
// 10142C54: using guessed type int dword_10142C54;
// 10142C60: using guessed type int dword_10142C60;
// 10142C64: using guessed type int dword_10142C64;
// 1020B28C: using guessed type int dword_1020B28C;

//----- (1000E6A0) --------------------------------------------------------
char __cdecl sub_1000E6A0(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v5; // eax@5

  v3 = sub_1000E060(a1, a2);
  if ( v3 != -1 && !sub_1000DE30(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_1000DCD0(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_10142C5C + 24 * ((unsigned __int16)v3 + 25);
        goto LABEL_15;
      case 0:
        if ( (unsigned __int8)sub_1000DCD0(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_10142C68 + 24 * (unsigned __int16)v3 + 532;
        goto LABEL_15;
      case 1:
        if ( (unsigned __int8)sub_1000DCD0(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_10142C44 + 24 * (unsigned __int16)v3 + 2428;
        goto LABEL_15;
      case 2:
        if ( (unsigned __int8)sub_1000DCD0(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_10142C6C + 24 * ((unsigned __int16)v3 + 24);
        goto LABEL_15;
      case 3:
        v5 = dword_1020B2A0 + 24 * (unsigned __int16)v3;
        goto LABEL_15;
      case 5:
        if ( (unsigned __int8)sub_1000DCD0(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_10142C48 + 24 * (unsigned __int16)v3 + 4;
LABEL_15:
        *(_DWORD *)a3 = *(_DWORD *)v5;
        *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(a3 + 12) = *(_DWORD *)(v5 + 12);
        *(_DWORD *)(a3 + 16) = *(_DWORD *)(v5 + 16);
        *(_DWORD *)(a3 + 20) = *(_DWORD *)(v5 + 20);
        sub_1000DE10(a1);
        return 1;
      default:
LABEL_16:
        sub_1000DE10(a1);
        break;
    }
  }
  return 0;
}
// 10142C44: using guessed type int dword_10142C44;
// 10142C48: using guessed type int dword_10142C48;
// 10142C5C: using guessed type int dword_10142C5C;
// 10142C68: using guessed type int dword_10142C68;
// 10142C6C: using guessed type int dword_10142C6C;
// 1020B2A0: using guessed type int dword_1020B2A0;

//----- (1000E800) --------------------------------------------------------
char __cdecl sub_1000E800(int a1, int a2, void *a3, char a4, int a5, int a6)
{
  int v6; // ecx@0
  signed __int16 v7; // ax@1
  int v8; // ebp@2
  __int16 v9; // si@10
  int v11; // [sp-8h] [bp-570h]@16
  __int16 v12; // [sp+8h] [bp-560h]@12
  __int16 v13; // [sp+3Ch] [bp-52Ch]@9
  char v14; // [sp+40h] [bp-528h]@15
  char v15; // [sp+41h] [bp-527h]@9
  __int16 v16; // [sp+42h] [bp-526h]@9
  char v17; // [sp+44h] [bp-524h]@9
  __int16 v18; // [sp+46h] [bp-522h]@14
  int v19; // [sp+48h] [bp-520h]@15
  char v20; // [sp+4Ch] [bp-51Ch]@14

  LOBYTE(v7) = a1;
  switch ( (char)a1 )
  {
    case 6:
      v8 = 28;
      goto LABEL_7;
    case 0:
      v8 = 29;
      goto LABEL_7;
    case 1:
      v8 = 30;
      goto LABEL_7;
    case 2:
      v8 = 31;
      goto LABEL_7;
    case 5:
      v8 = 33;
LABEL_7:
      LOBYTE(v7) = sub_1000DCD0(a1, v6);
      if ( !(_BYTE)v7 )
        return v7;
      v7 = sub_1000E060(a1, a2);
      if ( v7 == -1 )
        return v7;
      v15 = a6;
      LOBYTE(v7) = a4;
      v13 = -32768;
      v16 = a2;
      v17 = a4;
      if ( a4 == 1 )
      {
        v9 = a5;
        if ( (unsigned __int16)a5 > 0x514u )
          return v7;
      }
      else
      {
        if ( sub_1000E3C0(a1, a2, &v12) != 1 )
          goto LABEL_15;
        v9 = v12;
      }
      memcpy(&v20, a3, (unsigned __int16)v9);
      v18 = v9;
LABEL_15:
      v19 = sub_10030040();
      v14 = 0;
      LOBYTE(v7) = sub_1001A100(v8, (int)&v13);
      return v7;
    default:
      return v7;
    case 3:
      v11 = sub_10030040();
      if ( a4 == 1 )
        LOBYTE(v7) = sub_1000CAB0(a2, a5, a6, (int)&byte_1020B260, a3, v11);
      else
        LOBYTE(v7) = sub_1000C7A0(a2, a6, (int)&byte_1020B260, a3, v11);
      return v7;
  }
}
// 1020B260: using guessed type char byte_1020B260;

//----- (1000E9B0) --------------------------------------------------------
char __cdecl sub_1000E9B0(char a1, int a2, int a3)
{
  signed __int16 v3; // ax@1
  int v4; // edi@2
  __int16 v6; // [sp+4h] [bp-52Ch]@8
  __int16 v7; // [sp+8h] [bp-528h]@9
  int v8; // [sp+Ch] [bp-524h]@9

  LOBYTE(v3) = a1;
  switch ( a1 )
  {
    case 6:
      v4 = 28;
      goto LABEL_8;
    case 0:
      v4 = 29;
      goto LABEL_8;
    case 1:
      v4 = 30;
      goto LABEL_8;
    case 2:
      v4 = 31;
      goto LABEL_8;
    case 3:
      LOBYTE(v3) = sub_1000CDA0(a2, a3, (int)&byte_1020B260);
      break;
    case 5:
      v4 = 33;
LABEL_8:
      memset(&v6, 0, 0x528u);
      v3 = sub_1000E060(a1, a2);
      if ( v3 != -1 )
      {
        v6 = -32766;
        v7 = a2;
        v8 = a3;
        LOBYTE(v3) = sub_1001A100(v4, (int)&v6);
      }
      break;
    default:
      return v3;
  }
  return v3;
}
// 1020B260: using guessed type char byte_1020B260;

//----- (1000EAC0) --------------------------------------------------------
char __cdecl sub_1000EAC0(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6)
{
  char result; // al@2
  int v7; // ecx@3
  signed __int16 v8; // si@3
  int v9; // eax@7
  int v10; // ebp@7
  int v11; // esi@7
  int v12; // edi@7
  unsigned int v13; // ebx@7
  int v14; // eax@9
  int v15; // eax@11
  int v16; // eax@13
  int v17; // eax@14
  int v18; // eax@16
  int v19; // eax@24
  char v20; // [sp+7h] [bp-9h]@18
  __int16 v21; // [sp+8h] [bp-8h]@1
  unsigned int v22; // [sp+Ch] [bp-4h]@1

  v22 = sub_10030040();
  v21 = 0;
  if ( a1 < 7 )
  {
    v8 = sub_1000E060(a1, a2);
    if ( v8 == -1 )
    {
      result = 0;
    }
    else
    {
      switch ( a1 )
      {
        case 6:
          if ( !(unsigned __int8)sub_1000DCD0(a1, v7) )
            goto LABEL_29;
          v9 = 3 * (unsigned __int16)v8 + 75;
          v10 = dword_10142C5C + 14952;
          v11 = 52 * (unsigned __int16)v8 + dword_10142C5C + 210116;
          v12 = dword_10142C5C + 8 * v9;
          v13 = 195164;
          goto LABEL_17;
        case 0:
          if ( !(unsigned __int8)sub_1000DCD0(a1, v7) )
            goto LABEL_29;
          v14 = 3 * (unsigned __int16)v8;
          v10 = dword_10142C68 + 13228;
          v11 = 52 * (unsigned __int16)v8 + dword_10142C68 + 257156;
          v12 = dword_10142C68 + 8 * v14 + 532;
          v13 = 243928;
          goto LABEL_17;
        case 1:
          if ( !(unsigned __int8)sub_1000DCD0(a1, v7) )
            goto LABEL_29;
          v15 = 3 * (unsigned __int16)v8;
          v10 = dword_10142C44 + 60628;
          v11 = 52 * (unsigned __int16)v8 + dword_10142C44 + 321708;
          v12 = dword_10142C44 + 8 * v15 + 2428;
          v13 = 261080;
          goto LABEL_17;
        case 2:
          if ( !(unsigned __int8)sub_1000DCD0(a1, v7) )
            goto LABEL_29;
          v16 = 3 * (unsigned __int16)v8 + 72;
          v10 = dword_10142C6C + 14328;
          v11 = 52 * (unsigned __int16)v8 + dword_10142C6C + 326220;
          v12 = dword_10142C6C + 8 * v16;
          v13 = 311892;
          goto LABEL_17;
        case 3:
          v10 = dword_1020B27C;
          v17 = (unsigned __int16)v8;
          v11 = dword_1020B280 + 52 * (unsigned __int16)v8;
          v12 = dword_1020B2A0 + 24 * v17;
          v13 = 16780;
          goto LABEL_17;
        case 5:
          if ( !(unsigned __int8)sub_1000DCD0(a1, v7) )
            goto LABEL_29;
          v18 = 3 * (unsigned __int16)v8;
          v10 = dword_10142C48 + 100;
          v11 = 52 * (unsigned __int16)v8 + dword_10142C48 + 1596;
          v12 = dword_10142C48 + 8 * v18 + 4;
          v13 = 1496;
LABEL_17:
          if ( sub_1000DE30(a1) )
            goto LABEL_29;
          v20 = *(_BYTE *)(v12 + 1);
          if ( *(_BYTE *)(v12 + 1) == 1 && v10 )
          {
            if ( *(_DWORD *)(v11 + 12) && v22 > *(_DWORD *)(v11 + 16) + *(_DWORD *)(v12 + 16) )
              goto LABEL_32;
            v21 = a4;
            if ( !a4 )
              v21 = *(_WORD *)(v12 + 4) - a3;
            v19 = *(_DWORD *)(v11 + 4) + (unsigned __int16)a3;
            if ( !v21 || (unsigned int)(unsigned __int16)v21 + v19 > v13 )
LABEL_32:
              v20 = 0;
            else
              memcpy(a5, (const void *)(v10 + v19), (unsigned __int16)v21);
          }
          *(_WORD *)a6 = v21;
          sub_1000DE10(a1);
          result = v20;
          break;
        default:
LABEL_29:
          result = 0;
          break;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10142C44: using guessed type int dword_10142C44;
// 10142C48: using guessed type int dword_10142C48;
// 10142C58: using guessed type int dword_10142C58;
// 10142C5C: using guessed type int dword_10142C5C;
// 10142C64: using guessed type int dword_10142C64;
// 10142C68: using guessed type int dword_10142C68;
// 10142C6C: using guessed type int dword_10142C6C;
// 1020B27C: using guessed type int dword_1020B27C;
// 1020B280: using guessed type int dword_1020B280;
// 1020B2A0: using guessed type int dword_1020B2A0;

//----- (1000ED30) --------------------------------------------------------
char __cdecl sub_1000ED30(char a1, int a2, __int16 a3, __int16 a4, void *a5)
{
  int v5; // ecx@0
  int v7; // [sp+0h] [bp-4h]@1

  v7 = v5;
  return sub_1000EAC0(a1, a2, a3, a4, a5, (int)&v7);
}

//----- (1000ED60) --------------------------------------------------------
char __cdecl sub_1000ED60(char a1, int a2, void *a3)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v3;
  return sub_1000EAC0(a1, a2, 0, 0, a3, (int)&v5);
}

//----- (1000ED90) --------------------------------------------------------
char __cdecl sub_1000ED90(char a1, int a2, void *a3, int a4)
{
  return sub_1000EAC0(a1, a2, 0, 0, a3, a4);
}

//----- (1000EDC0) --------------------------------------------------------
const char *__cdecl sub_1000EDC0(int a1, unsigned __int16 a2)
{
  int v2; // ecx@1
  const char *result; // eax@1

  v2 = *(_DWORD *)(a1 + 44);
  result = "UNKNOWN";
  if ( v2 )
  {
    if ( a2 <= *(_WORD *)(*(_DWORD *)(a1 + 40) + 2 * *(_DWORD *)(a1 + 4)) )
      result = *(const char **)(v2 + 4 * a2);
  }
  return result;
}

//----- (1000EDF0) --------------------------------------------------------
int __cdecl sub_1000EDF0(char a1, int a2)
{
  void *v2; // ecx@1
  void *v3; // ecx@1
  void *v4; // ecx@2
  int v5; // eax@3
  int v6; // ecx@16

  sub_10030160(*(_DWORD *)(a2 + 60), -1);
  *(_BYTE *)a2 = sub_10015650(v2) | 1;
  if ( a1 == 1 )
  {
    if ( sub_1001DF80(2048) )
      v5 = sub_10014FA0(v4) | 0x300;
    else
      v5 = sub_10014FA0(v4) | 0x83B00;
    *(_DWORD *)(a2 + 72) = v5;
    if ( !sub_1001DF80(0x10000) )
      *(_DWORD *)(a2 + 72) |= 0x110000u;
    if ( !sub_1001DF80(0x20000) )
      *(_DWORD *)(a2 + 72) |= 0x220000u;
    if ( !sub_1001DF80(1024) )
      *(_DWORD *)(a2 + 72) |= 0x400u;
    if ( !sub_1001DF80(0x1000000) )
      *(_DWORD *)(a2 + 72) |= 0x3000000u;
    if ( !sub_1001DF80(0x4000000) )
      *(_DWORD *)(a2 + 72) |= 0x4000000u;
    if ( !sub_1001DF80(0x8000000) )
    {
      v6 = *(_DWORD *)(a2 + 60);
      *(_DWORD *)(a2 + 72) |= 0x8000000u;
      sub_10030140(v6);
      return sub_1000D690(a2);
    }
  }
  else
  {
    *(_DWORD *)(a2 + 72) = sub_10014FA0(v3);
  }
  sub_10030140(*(_DWORD *)(a2 + 60));
  return sub_1000D690(a2);
}

//----- (1000EF10) --------------------------------------------------------
void __cdecl sub_1000EF10(int a1, __int16 a2, unsigned __int16 a3, const void *a4)
{
  int v4; // eax@2

  if ( !a2 )
  {
    v4 = sub_10030040();
    sub_1000CAB0(32, a3, 1, a1, a4, v4);
  }
}

//----- (1000EF40) --------------------------------------------------------
char __cdecl sub_1000EF40(void *a1, int a2)
{
  return sub_1000D2F0(66, 0x90u, 0xFFFFFFF, a1, 1, a2);
}

//----- (1000EF70) --------------------------------------------------------
char __cdecl sub_1000EF70(int a1, int a2)
{
  unsigned __int16 v2; // di@1
  int v3; // eax@1
  char v5; // [sp+8h] [bp-57Ch]@1

  v2 = *(_WORD *)(*(_DWORD *)(a2 + 40) + 84);
  memset(&v5, 0, 0x578u);
  v3 = sub_10030040();
  return sub_1000CAB0(a1, *(_WORD *)(52 * v2 + *(_DWORD *)(a2 + 32)), 1, a2, &v5, v3);
}

//----- (1000EFF0) --------------------------------------------------------
char __cdecl sub_1000EFF0(__int16 a1, int a2)
{
  const void *v2; // ST2C_4@1
  int v3; // eax@1
  bool v4; // al@7
  int *v5; // ecx@7
  unsigned __int16 v6; // di@12
  int v7; // eax@12
  int v8; // edi@13
  int v9; // ST30_4@13
  unsigned __int16 v10; // cx@13
  int v11; // edx@13
  int v12; // eax@17
  int v13; // edi@17
  int v14; // edi@18
  int v15; // ecx@24
  unsigned int v16; // eax@24
  int v17; // ecx@25
  unsigned int v18; // eax@25
  int v19; // eax@25
  _WORD *v20; // ecx@27
  int v21; // eax@27
  int v22; // eax@27
  int v23; // eax@27
  int v24; // edx@32
  unsigned __int16 v26; // [sp-1Ch] [bp-1BCh]@7
  int v27; // [sp+Ch] [bp-194h]@17
  char v28; // [sp+10h] [bp-190h]@3
  int v29; // [sp+14h] [bp-18Ch]@4
  int v30; // [sp+18h] [bp-188h]@4
  int v31; // [sp+1Ch] [bp-184h]@6
  int v32; // [sp+20h] [bp-180h]@4
  bool v33; // [sp+24h] [bp-17Ch]@4
  char v34; // [sp+25h] [bp-17Bh]@4
  int v35; // [sp+9Dh] [bp-103h]@1
  char v36; // [sp+A4h] [bp-FCh]@1
  char v37; // [sp+A5h] [bp-FBh]@1
  char v38; // [sp+A6h] [bp-FAh]@1
  char v39; // [sp+A7h] [bp-F9h]@1
  char v40; // [sp+A8h] [bp-F8h]@1
  char v41; // [sp+A9h] [bp-F7h]@1
  char v42; // [sp+AAh] [bp-F6h]@1
  char v43; // [sp+ABh] [bp-F5h]@1
  char v44; // [sp+ACh] [bp-F4h]@1
  char v45; // [sp+ADh] [bp-F3h]@1
  char v46; // [sp+AEh] [bp-F2h]@1
  char v47; // [sp+AFh] [bp-F1h]@1
  char v48; // [sp+B0h] [bp-F0h]@1
  char v49; // [sp+B1h] [bp-EFh]@1
  char v50; // [sp+B2h] [bp-EEh]@1
  char v51; // [sp+B3h] [bp-EDh]@1
  char v52; // [sp+B4h] [bp-ECh]@1
  char v53; // [sp+B5h] [bp-EBh]@1
  char v54; // [sp+B6h] [bp-EAh]@1
  char v55; // [sp+B7h] [bp-E9h]@1
  char v56; // [sp+B8h] [bp-E8h]@1
  char v57; // [sp+B9h] [bp-E7h]@1
  char v58; // [sp+BAh] [bp-E6h]@1
  char v59; // [sp+BBh] [bp-E5h]@1
  char v60; // [sp+BCh] [bp-E4h]@1
  char v61; // [sp+BDh] [bp-E3h]@1
  char v62; // [sp+BEh] [bp-E2h]@1
  char v63; // [sp+BFh] [bp-E1h]@1
  char v64; // [sp+C0h] [bp-E0h]@1
  char v65; // [sp+C1h] [bp-DFh]@1
  char v66; // [sp+C2h] [bp-DEh]@1
  char v67; // [sp+C3h] [bp-DDh]@1
  char v68; // [sp+C4h] [bp-DCh]@1
  char v69; // [sp+C5h] [bp-DBh]@1
  char v70; // [sp+C6h] [bp-DAh]@1
  char v71; // [sp+C7h] [bp-D9h]@1
  char v72; // [sp+C8h] [bp-D8h]@1
  char v73; // [sp+C9h] [bp-D7h]@1
  char v74; // [sp+CAh] [bp-D6h]@1
  char v75; // [sp+CBh] [bp-D5h]@1
  char v76; // [sp+CCh] [bp-D4h]@1
  char v77; // [sp+CDh] [bp-D3h]@1
  char v78; // [sp+CEh] [bp-D2h]@1
  char v79; // [sp+CFh] [bp-D1h]@1
  char v80; // [sp+D0h] [bp-D0h]@1
  char v81; // [sp+D1h] [bp-CFh]@1
  char v82; // [sp+D2h] [bp-CEh]@1
  char v83; // [sp+D3h] [bp-CDh]@1
  char v84; // [sp+D4h] [bp-CCh]@1
  char v85; // [sp+D5h] [bp-CBh]@1
  char v86; // [sp+D6h] [bp-CAh]@1
  char v87; // [sp+D7h] [bp-C9h]@1
  char v88; // [sp+D8h] [bp-C8h]@1
  char v89; // [sp+D9h] [bp-C7h]@1
  char v90; // [sp+DAh] [bp-C6h]@1
  char v91; // [sp+DBh] [bp-C5h]@1
  char v92; // [sp+DCh] [bp-C4h]@1
  char v93; // [sp+DDh] [bp-C3h]@1
  char v94; // [sp+DEh] [bp-C2h]@1
  char v95; // [sp+DFh] [bp-C1h]@1
  char v96; // [sp+E0h] [bp-C0h]@1
  char v97; // [sp+E1h] [bp-BFh]@1
  char v98; // [sp+E2h] [bp-BEh]@1
  char v99; // [sp+E3h] [bp-BDh]@1
  char v100; // [sp+E4h] [bp-BCh]@1
  char v101; // [sp+E5h] [bp-BBh]@1
  char v102; // [sp+E6h] [bp-BAh]@1
  char v103; // [sp+E7h] [bp-B9h]@1
  char v104; // [sp+E8h] [bp-B8h]@1
  char v105; // [sp+E9h] [bp-B7h]@1
  char v106; // [sp+EAh] [bp-B6h]@1
  char v107; // [sp+EBh] [bp-B5h]@1
  char v108; // [sp+ECh] [bp-B4h]@1
  char v109; // [sp+EDh] [bp-B3h]@1
  char v110; // [sp+EEh] [bp-B2h]@1
  char v111; // [sp+EFh] [bp-B1h]@1
  char v112; // [sp+F0h] [bp-B0h]@1
  char v113; // [sp+F1h] [bp-AFh]@1
  char v114; // [sp+F2h] [bp-AEh]@1
  char v115; // [sp+F3h] [bp-ADh]@1
  char v116; // [sp+F4h] [bp-ACh]@1
  char v117; // [sp+F5h] [bp-ABh]@1
  char v118; // [sp+F6h] [bp-AAh]@1
  char v119; // [sp+F7h] [bp-A9h]@1
  char v120; // [sp+F8h] [bp-A8h]@1
  char v121; // [sp+F9h] [bp-A7h]@1
  char v122; // [sp+FAh] [bp-A6h]@1
  char v123; // [sp+FBh] [bp-A5h]@1
  char v124; // [sp+FCh] [bp-A4h]@1
  char v125; // [sp+FDh] [bp-A3h]@1
  char v126; // [sp+FEh] [bp-A2h]@1
  char v127; // [sp+FFh] [bp-A1h]@1
  char v128; // [sp+100h] [bp-A0h]@1
  char v129; // [sp+101h] [bp-9Fh]@1
  char v130; // [sp+102h] [bp-9Eh]@1
  char v131; // [sp+103h] [bp-9Dh]@1
  char v132; // [sp+104h] [bp-9Ch]@1
  char v133; // [sp+105h] [bp-9Bh]@1
  char v134; // [sp+106h] [bp-9Ah]@1
  char v135; // [sp+107h] [bp-99h]@1
  char v136; // [sp+108h] [bp-98h]@1
  char v137; // [sp+109h] [bp-97h]@1
  char v138; // [sp+10Ah] [bp-96h]@1
  char v139; // [sp+10Bh] [bp-95h]@1
  char v140; // [sp+10Ch] [bp-94h]@1
  char v141; // [sp+10Dh] [bp-93h]@1
  char v142; // [sp+10Eh] [bp-92h]@1
  char v143; // [sp+10Fh] [bp-91h]@1
  char v144; // [sp+110h] [bp-90h]@1
  char v145; // [sp+111h] [bp-8Fh]@1
  char v146; // [sp+112h] [bp-8Eh]@1
  char v147; // [sp+113h] [bp-8Dh]@1
  char v148; // [sp+114h] [bp-8Ch]@1
  char v149; // [sp+115h] [bp-8Bh]@1
  char v150; // [sp+116h] [bp-8Ah]@1
  char v151; // [sp+117h] [bp-89h]@1
  char v152; // [sp+118h] [bp-88h]@1
  char v153; // [sp+119h] [bp-87h]@1
  char v154; // [sp+11Ah] [bp-86h]@1
  char v155; // [sp+11Bh] [bp-85h]@1
  char v156; // [sp+11Ch] [bp-84h]@1
  char v157; // [sp+11Dh] [bp-83h]@1
  char v158; // [sp+11Eh] [bp-82h]@1
  char v159; // [sp+11Fh] [bp-81h]@1
  char v160; // [sp+120h] [bp-80h]@1
  char v161; // [sp+121h] [bp-7Fh]@1
  char v162; // [sp+122h] [bp-7Eh]@1
  char v163; // [sp+123h] [bp-7Dh]@1
  char v164; // [sp+124h] [bp-7Ch]@1
  char v165; // [sp+125h] [bp-7Bh]@1
  char v166; // [sp+126h] [bp-7Ah]@1
  char v167; // [sp+127h] [bp-79h]@1
  char v168; // [sp+128h] [bp-78h]@1
  char v169; // [sp+129h] [bp-77h]@1
  char v170; // [sp+12Ah] [bp-76h]@1
  char v171; // [sp+12Bh] [bp-75h]@1
  char v172; // [sp+12Ch] [bp-74h]@1
  char v173; // [sp+12Dh] [bp-73h]@1
  char v174; // [sp+12Eh] [bp-72h]@1
  char v175; // [sp+12Fh] [bp-71h]@1
  char v176; // [sp+130h] [bp-70h]@1
  char v177; // [sp+131h] [bp-6Fh]@1
  char v178; // [sp+132h] [bp-6Eh]@1
  char v179; // [sp+133h] [bp-6Dh]@1
  char v180; // [sp+134h] [bp-6Ch]@1
  char v181; // [sp+135h] [bp-6Bh]@1
  char v182; // [sp+136h] [bp-6Ah]@1
  char v183; // [sp+137h] [bp-69h]@1
  char v184; // [sp+138h] [bp-68h]@1
  char v185; // [sp+139h] [bp-67h]@1
  char v186; // [sp+13Ah] [bp-66h]@1
  char v187; // [sp+13Bh] [bp-65h]@1
  char v188; // [sp+13Ch] [bp-64h]@1
  char v189; // [sp+13Dh] [bp-63h]@1
  char v190; // [sp+13Eh] [bp-62h]@1
  char v191; // [sp+13Fh] [bp-61h]@1
  char v192; // [sp+140h] [bp-60h]@1
  char v193; // [sp+141h] [bp-5Fh]@1
  char v194; // [sp+142h] [bp-5Eh]@1
  char v195; // [sp+143h] [bp-5Dh]@1
  char v196; // [sp+144h] [bp-5Ch]@1
  char v197; // [sp+145h] [bp-5Bh]@1
  char v198; // [sp+146h] [bp-5Ah]@1
  char v199; // [sp+147h] [bp-59h]@1
  char v200; // [sp+148h] [bp-58h]@1
  char v201; // [sp+149h] [bp-57h]@1
  char v202; // [sp+14Ah] [bp-56h]@1
  char v203; // [sp+14Bh] [bp-55h]@1
  char v204; // [sp+14Ch] [bp-54h]@1
  char v205; // [sp+14Dh] [bp-53h]@1
  char v206; // [sp+14Eh] [bp-52h]@1
  char v207; // [sp+14Fh] [bp-51h]@1
  char v208; // [sp+150h] [bp-50h]@1
  char v209; // [sp+151h] [bp-4Fh]@1
  char v210; // [sp+152h] [bp-4Eh]@1
  char v211; // [sp+153h] [bp-4Dh]@1
  char v212; // [sp+154h] [bp-4Ch]@1
  char v213; // [sp+155h] [bp-4Bh]@1
  char v214; // [sp+156h] [bp-4Ah]@1
  char v215; // [sp+157h] [bp-49h]@1
  char v216; // [sp+158h] [bp-48h]@1
  char v217; // [sp+159h] [bp-47h]@1
  char v218; // [sp+15Ah] [bp-46h]@1
  char v219; // [sp+15Bh] [bp-45h]@1
  char v220; // [sp+15Ch] [bp-44h]@1
  char v221; // [sp+15Dh] [bp-43h]@1
  char v222; // [sp+15Eh] [bp-42h]@1
  char v223; // [sp+15Fh] [bp-41h]@1
  char v224; // [sp+160h] [bp-40h]@1
  char v225; // [sp+161h] [bp-3Fh]@1
  char v226; // [sp+162h] [bp-3Eh]@1
  char v227; // [sp+163h] [bp-3Dh]@1
  char v228; // [sp+164h] [bp-3Ch]@1
  char v229; // [sp+165h] [bp-3Bh]@1
  char v230; // [sp+166h] [bp-3Ah]@1
  char v231; // [sp+167h] [bp-39h]@1
  char v232; // [sp+168h] [bp-38h]@1
  char v233; // [sp+169h] [bp-37h]@1
  char v234; // [sp+16Ah] [bp-36h]@1
  char v235; // [sp+16Bh] [bp-35h]@1
  char v236; // [sp+16Ch] [bp-34h]@1
  char v237; // [sp+16Dh] [bp-33h]@1
  char v238; // [sp+16Eh] [bp-32h]@1
  char v239; // [sp+16Fh] [bp-31h]@1
  char v240; // [sp+170h] [bp-30h]@1
  char v241; // [sp+171h] [bp-2Fh]@1
  char v242; // [sp+172h] [bp-2Eh]@1
  char v243; // [sp+173h] [bp-2Dh]@1
  char v244; // [sp+174h] [bp-2Ch]@1
  char v245; // [sp+175h] [bp-2Bh]@1
  char v246; // [sp+176h] [bp-2Ah]@1
  char v247; // [sp+177h] [bp-29h]@1
  char v248; // [sp+178h] [bp-28h]@1
  char v249; // [sp+179h] [bp-27h]@1
  char v250; // [sp+17Ah] [bp-26h]@1
  char v251; // [sp+17Bh] [bp-25h]@1
  char v252; // [sp+17Ch] [bp-24h]@1
  char v253; // [sp+17Dh] [bp-23h]@1
  char v254; // [sp+17Eh] [bp-22h]@1
  char v255; // [sp+17Fh] [bp-21h]@1
  char v256; // [sp+180h] [bp-20h]@1
  char v257; // [sp+181h] [bp-1Fh]@1
  char v258; // [sp+182h] [bp-1Eh]@1
  char v259; // [sp+183h] [bp-1Dh]@1
  char v260; // [sp+184h] [bp-1Ch]@1
  char v261; // [sp+185h] [bp-1Bh]@1
  char v262; // [sp+186h] [bp-1Ah]@1
  char v263; // [sp+187h] [bp-19h]@1
  char v264; // [sp+188h] [bp-18h]@1
  char v265; // [sp+189h] [bp-17h]@1
  char v266; // [sp+18Ah] [bp-16h]@1
  char v267; // [sp+18Bh] [bp-15h]@1
  char v268; // [sp+18Ch] [bp-14h]@1
  char v269; // [sp+18Dh] [bp-13h]@1
  char v270; // [sp+18Eh] [bp-12h]@1
  char v271; // [sp+18Fh] [bp-11h]@1
  char v272; // [sp+190h] [bp-10h]@1
  char v273; // [sp+191h] [bp-Fh]@1
  char v274; // [sp+192h] [bp-Eh]@1
  char v275; // [sp+193h] [bp-Dh]@1
  char v276; // [sp+194h] [bp-Ch]@1
  char v277; // [sp+195h] [bp-Bh]@1
  char v278; // [sp+196h] [bp-Ah]@1
  char v279; // [sp+197h] [bp-9h]@1
  char v280; // [sp+198h] [bp-8h]@1
  char v281; // [sp+199h] [bp-7h]@1

  v36 = -1;
  v37 = -1;
  v38 = -1;
  v39 = -1;
  v40 = -1;
  v41 = -1;
  v42 = -1;
  v43 = -1;
  v44 = -1;
  v45 = -1;
  v46 = -1;
  v47 = -1;
  v48 = -1;
  v49 = -1;
  v50 = -1;
  v51 = -1;
  v52 = -1;
  v53 = -1;
  v54 = -1;
  v55 = -1;
  v56 = -1;
  v57 = -1;
  v58 = -1;
  v59 = -1;
  v60 = -1;
  v61 = -1;
  v62 = -1;
  v63 = -1;
  v64 = -1;
  v65 = -1;
  v66 = -1;
  v67 = -1;
  v68 = -1;
  v69 = -1;
  v70 = -1;
  v71 = -1;
  v72 = -1;
  v73 = -1;
  v74 = -1;
  v75 = -1;
  v76 = -1;
  v77 = -1;
  v78 = -1;
  v79 = -1;
  v80 = -1;
  v81 = -1;
  v82 = -1;
  v83 = -1;
  v84 = -1;
  v85 = -1;
  v86 = -1;
  v87 = -1;
  v88 = -1;
  v89 = -1;
  v90 = -1;
  v91 = -1;
  v92 = -1;
  v93 = -1;
  v94 = -1;
  v95 = -1;
  v96 = -1;
  v97 = -1;
  v98 = -1;
  v99 = -1;
  v100 = -1;
  v101 = -1;
  v102 = -1;
  v103 = -1;
  v104 = -1;
  v105 = -1;
  v106 = -1;
  v107 = -1;
  v108 = -1;
  v109 = -1;
  v110 = -1;
  v111 = -1;
  v112 = -1;
  v113 = -1;
  v114 = -1;
  v115 = -1;
  v116 = -1;
  v117 = -1;
  v118 = -1;
  v119 = -1;
  v120 = -1;
  v121 = -1;
  v122 = -1;
  v123 = -1;
  v124 = -1;
  v125 = -1;
  v126 = -1;
  v127 = -1;
  v128 = -1;
  v129 = -1;
  v130 = -1;
  v131 = -1;
  v132 = -1;
  v133 = -1;
  v134 = -1;
  v135 = -1;
  v136 = -1;
  v137 = -1;
  v138 = -1;
  v139 = -1;
  v140 = -1;
  v141 = -1;
  v142 = -1;
  v143 = -1;
  v144 = -1;
  v145 = -1;
  v146 = -1;
  v147 = -1;
  v148 = -1;
  v149 = -1;
  v150 = -1;
  v151 = -1;
  v152 = -1;
  v153 = -1;
  v154 = -1;
  v155 = -1;
  v156 = -1;
  v157 = -1;
  v158 = -1;
  v159 = -1;
  v160 = -1;
  v161 = -1;
  v162 = -1;
  v163 = -1;
  v164 = -1;
  v165 = -1;
  v166 = -1;
  v167 = -1;
  v168 = -1;
  v169 = -1;
  v170 = -1;
  v171 = -1;
  v172 = -1;
  v173 = -1;
  v174 = -1;
  v175 = -1;
  v176 = -1;
  v177 = -1;
  v178 = -1;
  v179 = -1;
  v180 = -1;
  v181 = -1;
  v182 = -1;
  v183 = -1;
  v184 = -1;
  v185 = -1;
  v186 = -1;
  v187 = -1;
  v188 = -1;
  v189 = -1;
  v190 = -1;
  v191 = -1;
  v192 = -1;
  v193 = -1;
  v194 = -1;
  v195 = -1;
  v196 = -1;
  v197 = -1;
  v198 = -1;
  v199 = -1;
  v200 = -1;
  v201 = 30;
  v202 = 60;
  v203 = 90;
  v204 = -1;
  v205 = -1;
  v206 = -1;
  v207 = -1;
  v208 = -1;
  v209 = -1;
  v210 = -1;
  v211 = -1;
  v212 = -1;
  v213 = -1;
  v214 = -1;
  v215 = -1;
  v216 = -1;
  v217 = -1;
  v218 = -1;
  v219 = -1;
  v220 = -1;
  v221 = -1;
  v222 = -1;
  v223 = -1;
  v224 = -1;
  v225 = -1;
  v226 = -1;
  v227 = -1;
  v228 = -1;
  v229 = -1;
  v230 = -1;
  v231 = -1;
  v232 = -1;
  v233 = -1;
  v234 = -1;
  v235 = -1;
  v236 = -1;
  v237 = -1;
  v238 = -1;
  v239 = -1;
  v240 = -1;
  v241 = -1;
  v242 = -1;
  v243 = -1;
  v244 = -1;
  v245 = -1;
  v246 = -1;
  v247 = -1;
  v248 = -1;
  v249 = -1;
  v250 = -1;
  v251 = -1;
  v252 = -1;
  v253 = -1;
  v254 = -1;
  v255 = -1;
  v256 = -1;
  v257 = -1;
  v258 = -1;
  v259 = -1;
  v260 = -1;
  v261 = -1;
  v262 = -1;
  v263 = -1;
  v264 = 60;
  v265 = 30;
  v266 = 90;
  v267 = -1;
  v268 = -1;
  v269 = -1;
  v270 = -1;
  v271 = -1;
  v272 = -1;
  v273 = -1;
  v274 = -1;
  v275 = -1;
  v276 = -1;
  v277 = -1;
  v278 = -1;
  v279 = -1;
  v280 = -1;
  v281 = -1;
  v2 = *(const void **)(a2 + 32);
  LOBYTE(v35) = 0;
  LOBYTE(v3) = (unsigned int)memcpy(word_10142C70, v2, 0x2698u);
  if ( a1 == 66 && *(_BYTE *)(*(_DWORD *)(a2 + 48) + 1) )
  {
    sub_1000B990(66, a2, &v28, 0x90u);
    LOBYTE(v3) = v28;
    switch ( v28 )
    {
      case 0:
        v30 = sub_1000BB80(v29, a2);
        v32 = sub_1000BC50(v29, a2);
        v33 = sub_1000BBD0(v29, a2);
        LOBYTE(v35) = sub_1000D640(v29, a2, &v34);
        LOBYTE(v3) = sub_1000EF40(&v28, a2);
        return v3;
      case 1:
        v30 = sub_1000BB80(v29, a2);
        v32 = sub_1000BC50(v29, a2);
        v33 = sub_1000BBD0(v29, a2);
        LOBYTE(v35) = sub_1000B990(v29, a2, &v34, 0x78u);
        LOBYTE(v3) = sub_1000EF40(&v28, a2);
        return v3;
      case 2:
        v30 = sub_1000BB80(v29, a2);
        v32 = sub_1000BC50(v29, a2);
        v33 = sub_1000BBD0(v29, a2);
        LOBYTE(v35) = sub_1000D660(v29, a2, &v34, (unsigned __int16 *)&v31);
        LOBYTE(v3) = sub_1000EF40(&v28, a2);
        return v3;
      case 3:
        v30 = sub_1000BB80(v29, a2);
        v32 = sub_1000BC50(v29, a2);
        v4 = sub_1000BBD0(v29, a2);
        v26 = 120;
        v5 = &v31;
        goto LABEL_8;
      case 5:
        *(_WORD *)(*(_DWORD *)(a2 + 64) + 24 * *(_WORD *)(*(_DWORD *)(a2 + 40) + 2 * (unsigned __int16)v29) + 4) = v31;
        goto LABEL_10;
      case 4:
LABEL_10:
        LOBYTE(v3) = sub_1000C7A0(v29, v35, a2, &v34, v32);
        return v3;
      case 6:
        LOBYTE(v3) = sub_1000CAB0(v29, v31, v35, a2, &v34, v32);
        return v3;
      case 7:
        v6 = *(_WORD *)(*(_DWORD *)(a2 + 40) + 2 * (unsigned __int16)v29);
        v7 = sub_10030040();
        sub_1000C7A0(v29, v35, a2, &v34, v7);
        LOBYTE(v3) = BYTE2(v31);
        *(_BYTE *)(*(_DWORD *)(a2 + 64) + 24 * v6 + 2) = BYTE2(v31);
        return v3;
      case 8:
        v8 = *(_DWORD *)(a2 + 56);
        *(&v36 + *(_BYTE *)(a2 + 3) + *(_BYTE *)(a2 + 2) * *(_WORD *)(*(_DWORD *)(a2 + 40) + 2 * (unsigned __int16)v29)) = BYTE2(v31);
        v9 = v32;
        v10 = v31;
        v11 = v29;
        *(_DWORD *)(a2 + 56) = &v36;
        LOBYTE(v3) = sub_1000CAB0(v11, v10, v35, a2, &v34, v9);
        *(_DWORD *)(a2 + 56) = v8;
        return v3;
      case 9:
        LOBYTE(v3) = sub_1000B890(v29, a2);
        return v3;
      case 0xA:
        *(_DWORD *)(a2 + 80) = sub_1000EF10;
        return v3;
      case 0xB:
        v30 = sub_1000BB80(v29, a2);
        v32 = sub_1000BC50(v29, a2);
        v33 = sub_1000BBD0(v29, a2);
        LOBYTE(v35) = sub_1000B990(v29, a2, &v34, 0);
        LOBYTE(v3) = sub_1000EF40(&v28, a2);
        return v3;
      case 0xC:
        v12 = *(_DWORD *)(a2 + 64);
        v13 = 24 * *(_WORD *)(*(_DWORD *)(a2 + 40) + 2 * (unsigned __int16)v29);
        v27 = *(_WORD *)(v12 + v13 + 4);
        *(_WORD *)(v12 + v13 + 4) = v31;
        v30 = sub_1000BB80(v29, a2);
        v32 = sub_1000BC50(v29, a2);
        v33 = sub_1000BBD0(v29, a2);
        LOBYTE(v35) = sub_1000D640(v29, a2, &v34);
        sub_1000EF40(&v28, a2);
        v3 = *(_DWORD *)(a2 + 64);
        *(_WORD *)(v3 + v13 + 4) = v27;
        return v3;
      case 0xD:
        v14 = *(_WORD *)(*(_DWORD *)(a2 + 40) + 2 * (unsigned __int16)v29);
        *(_WORD *)(*(_DWORD *)(a2 + 64) + 24 * v14 + 4) = v31;
        v30 = sub_1000BB80(v29, a2);
        v32 = sub_1000BC50(v29, a2);
        v33 = sub_1000BBD0(v29, a2);
        LOBYTE(v35) = sub_1000D660(v29, a2, &v34, (unsigned __int16 *)&v27);
        sub_1000EF40(&v28, a2);
        LOWORD(v3) = *(_WORD *)(52 * v14 + *(_DWORD *)(a2 + 32));
        *(_WORD *)(*(_DWORD *)(a2 + 64) + 24 * v14 + 4) = v3;
        return v3;
      case 0xE:
        v30 = sub_1000BB80(v29, a2);
        v32 = sub_1000BC50(v29, a2);
        v4 = sub_1000BBD0(v29, a2);
        v26 = 0;
        v5 = &v27;
LABEL_8:
        v33 = v4;
        LOBYTE(v35) = sub_1000BCA0(v29, a2, &v34, (unsigned __int16 *)v5, v26);
        LOBYTE(v3) = sub_1000EF40(&v28, a2);
        return v3;
      case 0xF:
        LOBYTE(v3) = sub_1000D060(v29, 0xFFFFFFF, &v34, v35, a2);
        return v3;
      case 0x10:
        LOBYTE(v3) = sub_1000D060(v29, 0, &v34, v35, a2);
        return v3;
      case 0x11:
        LOBYTE(v3) = sub_1000D2F0(v29, v31, 0xFFFFFFF, &v34, v35, a2);
        return v3;
      case 0x12:
        LOBYTE(v3) = sub_1000D2F0(v29, v31, 0, &v34, v35, a2);
        return v3;
      case 0x13:
        v15 = *(_DWORD *)(a2 + 40);
        *(_DWORD *)(a2 + 32) = word_10142C70;
        v16 = 52 * *(_WORD *)(v15 + 84);
        word_10142C70[v16 / 2] = 12;
        dword_10142C9C[v16 / 4] = (int)sub_1000EF70;
        dword_10142C7C[v16 / 4] = 25;
        dword_10142C88[v16 / 4] = 4194305;
        v3 = 52 * *(_WORD *)(*(_DWORD *)(a2 + 40) + 124);
        *(int *)((char *)dword_10142C7C + v3) = 25;
        *(int *)((char *)dword_10142C88 + v3) = 4194305;
        return v3;
      case 0x14:
        v17 = *(_DWORD *)(a2 + 40);
        *(_DWORD *)(a2 + 32) = word_10142C70;
        v18 = 52 * *(_WORD *)(v17 + 84);
        word_10142C70[v18 / 2] = 13;
        dword_10142C9C[v18 / 4] = (int)sub_1000EF70;
        dword_10142C7C[v18 / 4] = 25;
        dword_10142C88[v18 / 4] = 4194305;
        v19 = 13 * *(_WORD *)(*(_DWORD *)(a2 + 40) + 124);
        dword_10142C7C[v19] = 25;
        dword_10142C88[v19] = 4194305;
        goto LABEL_26;
      case 0x17:
LABEL_26:
        LOBYTE(v3) = sub_1000D690(a2);
        break;
      case 0x15:
        v20 = *(_WORD **)(a2 + 40);
        *(_DWORD *)(a2 + 32) = word_10142C70;
        *(_DWORD *)(a2 + 52) = 1;
        v21 = *v20;
        dword_10142C84[13 * v21] = 0x400000;
        *(_BYTE *)(v21 + *(_DWORD *)(a2 + 24)) = 1;
        v22 = *(_WORD *)(*(_DWORD *)(a2 + 40) + 2);
        dword_10142C84[13 * v22] = 0x400000;
        *(_BYTE *)(v22 + *(_DWORD *)(a2 + 24)) = 1;
        v23 = *(_WORD *)(*(_DWORD *)(a2 + 40) + 214);
        dword_10142C84[13 * v23] = 0x400000;
        *(_BYTE *)(v23 + *(_DWORD *)(a2 + 24)) = 1;
        LOBYTE(v3) = sub_1000D690(a2);
        break;
      case 0x16:
        *(_DWORD *)(a2 + 20) = (unsigned __int16)v31;
        break;
      case 0x18:
        LOBYTE(v3) = sub_1000D7E0(0x400000);
        break;
      case 0x19:
        LOBYTE(v3) = sub_1000D7F0(0x400000);
        break;
      case 0x1A:
        LOBYTE(v35) = sub_1000B910(&v34, &v27, &v32, v29, a2);
        LOBYTE(v3) = sub_1000EF40(&v28, a2);
        break;
      case 0x1B:
        v24 = *(_DWORD *)(a2 + 40);
        *(_DWORD *)(a2 + 32) = word_10142C70;
        v3 = 52 * *(_WORD *)(v24 + 84);
        *(int *)((char *)dword_10142C9C + v3) = 0;
        *(int *)((char *)&dword_10142C80 + v3) = 1000;
        break;
      case 0x1C:
        LOBYTE(v3) = sub_1000CDA0(v29, 0x400000, a2);
        break;
      default:
        return v3;
    }
  }
  return v3;
}
// 10142C70: using guessed type __int16 word_10142C70[];
// 10142C7C: using guessed type int dword_10142C7C[];
// 10142C80: using guessed type int dword_10142C80;
// 10142C84: using guessed type int dword_10142C84[];
// 10142C88: using guessed type int dword_10142C88[];
// 10142C9C: using guessed type int dword_10142C9C[];

//----- (10010050) --------------------------------------------------------
unsigned int __cdecl sub_10010050(char *a1)
{
  return sub_1001E100(a1, -100, 100, 0, 0);
}

//----- (10010070) --------------------------------------------------------
int __cdecl sub_10010070(_BYTE *a1)
{
  return sub_1001E360(a1, 0x1CCF0u, 0x2171Eu, 0x2171Eu, 0);
}

//----- (10010090) --------------------------------------------------------
int __cdecl sub_10010090(unsigned __int8 *a1)
{
  return sub_1001E270(a1, 0, 1u, 1u, 0);
}

//----- (100100B0) --------------------------------------------------------
unsigned int __cdecl sub_100100B0(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_1001DFC0((_BYTE *)(a1 + 6), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_1001E270((unsigned __int8 *)(a1 + 12), 0, 0xFFu, 0, a2) == 1 )
    v2 = 1;
  result = sub_1001DFC0((_BYTE *)a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 2), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 9), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 3), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001E100((char *)(a1 + 14), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001E270((unsigned __int8 *)(a1 + 7), 0, 0x40u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 10), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 5), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 11), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001E270((unsigned __int8 *)(a1 + 4), 0, 0x40u, 0x30u, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 1), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001E100((char *)(a1 + 17), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 24), 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (100103E0) --------------------------------------------------------
unsigned int __cdecl sub_100103E0(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_1001DFC0((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 24), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 26), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001E100((char *)(a1 + 10), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 31), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 28), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 17), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001E100((char *)(a1 + 13), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001E100((char *)(a1 + 5), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001E100((char *)a1, -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001E100((char *)(a1 + 1), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001E100((char *)(a1 + 2), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001E100((char *)(a1 + 3), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001E100((char *)(a1 + 4), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001E100((char *)(a1 + 12), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001E100((char *)(a1 + 11), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001E100((char *)(a1 + 7), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001E100((char *)(a1 + 9), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001DFC0((_BYTE *)(a1 + 25), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001E100((char *)(a1 + 6), -31, 31, 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10010820) --------------------------------------------------------
unsigned int __cdecl sub_10010820(_BYTE *a1)
{
  return sub_1001E150(a1, -1, 5, -1, 0);
}

//----- (10010840) --------------------------------------------------------
int __cdecl sub_10010840(unsigned __int8 *a1)
{
  return sub_1001E270(a1, 0, 5u, 0, 0);
}

//----- (10010860) --------------------------------------------------------
int __cdecl sub_10010860(unsigned __int8 *a1)
{
  return sub_1001E270(a1, 0, 4u, 2u, 0);
}

//----- (10010880) --------------------------------------------------------
int __cdecl sub_10010880(_BYTE *a1)
{
  return sub_1001E360(a1, 0, 2u, 0, 0);
}

//----- (100108A0) --------------------------------------------------------
int __cdecl sub_100108A0(int a1)
{
  return sub_1001E010(a1, 0.1, 4.0, COERCE_INT(1.5), 0);
}

//----- (100108F0) --------------------------------------------------------
int __cdecl sub_100108F0(unsigned __int8 *a1)
{
  int result; // eax@1

  result = sub_100108A0((int)(a1 + 4));
  if ( !result )
    result = sub_10010860(a1);
  return result;
}

//----- (10010910) --------------------------------------------------------
int __cdecl sub_10010910(int a1)
{
  int result; // eax@1

  result = sub_10010840((unsigned __int8 *)(a1 + 1));
  if ( !result )
  {
    result = sub_10010840((unsigned __int8 *)(a1 + 2));
    if ( !result )
    {
      result = sub_10010840((unsigned __int8 *)(a1 + 3));
      if ( !result )
      {
        result = sub_1001E410((unsigned __int8 *)(a1 + 7));
        if ( !result )
        {
          result = sub_1001DFC0((_BYTE *)(a1 + 5), 0, 0);
          if ( !result )
          {
            result = sub_1001DFC0((_BYTE *)a1, 0, 0);
            if ( !result )
            {
              result = sub_1001DFC0((_BYTE *)(a1 + 4), 0, 0);
              if ( !result )
                result = sub_1001DFC0((_BYTE *)(a1 + 6), 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (100109A0) --------------------------------------------------------
unsigned int __cdecl sub_100109A0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10010820((_BYTE *)a1);
  if ( !result )
    result = sub_10010820((_BYTE *)(a1 + 4));
  return result;
}

//----- (100109C0) --------------------------------------------------------
signed int __cdecl sub_100109C0(int a1)
{
  int v1; // esi@1
  signed int result; // eax@2
  signed int v3; // esi@4

  v1 = 0;
  while ( 1 )
  {
    result = sub_1001DFC0((_BYTE *)(v1 + a1), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      v3 = 0;
      do
      {
        result = sub_1001DFC0((_BYTE *)(a1 + v3 + 6), 0, 0);
        if ( result )
          break;
        ++v3;
      }
      while ( v3 < 6 );
      return result;
    }
  }
  return result;
}

//----- (10010A10) --------------------------------------------------------
unsigned int __cdecl sub_10010A10(int a1)
{
  unsigned int result; // eax@1

  result = sub_10010820((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10010820((_BYTE *)(a1 + 4));
    if ( !result )
    {
      result = sub_10010820((_BYTE *)(a1 + 8));
      if ( !result )
      {
        result = sub_10010820((_BYTE *)(a1 + 12));
        if ( !result )
          result = sub_1001DFC0((_BYTE *)(a1 + 16), 1, 0);
      }
    }
  }
  return result;
}

//----- (10010A70) --------------------------------------------------------
int __cdecl sub_10010A70(_BYTE *a1)
{
  return sub_1001E360(a1, 0, 0x20u, 2u, 0);
}

//----- (10010A90) --------------------------------------------------------
unsigned int __cdecl sub_10010A90(_BYTE *a1)
{
  return sub_1001E150(a1, -1, 4, -1, 0);
}

//----- (10010AB0) --------------------------------------------------------
int __cdecl sub_10010AB0(unsigned __int8 *a1)
{
  return sub_1001E270(a1, 0, 9u, 0, 0);
}

//----- (10010AD0) --------------------------------------------------------
int __cdecl sub_10010AD0(_BYTE *a1)
{
  return sub_1001E360(a1, 0x81u, 0xFFu, 0xC0u, 0);
}

//----- (10010AF0) --------------------------------------------------------
signed int __cdecl sub_10010AF0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1001E360(a1, 0, 0xFFFFFFFF, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10010B20) --------------------------------------------------------
int __cdecl sub_10010B20(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_1001E2C0(a1, 0, 0xFFFu, 640, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10010B60) --------------------------------------------------------
signed int __cdecl sub_10010B60(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1001E2C0(a1, 0, 0xFFFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10010B90) --------------------------------------------------------
int __cdecl sub_10010B90(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@3

  v2 = 0;
  if ( sub_10010AF0((_BYTE *)(a1 + 8), a2) == 1 )
    v2 = 1;
  result = sub_10010B20((_BYTE *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10010B20((_BYTE *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001E670((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10010B20((_BYTE *)(a1 + 6), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10010C20) --------------------------------------------------------
int __cdecl sub_10010C20(unsigned __int8 *a1)
{
  return sub_1001E270(a1, 0, 2u, 0, 0);
}

//----- (10010C40) --------------------------------------------------------
int __cdecl sub_10010C40(int a1)
{
  int result; // eax@1

  result = sub_1001E270((unsigned __int8 *)a1, 0, 0x78u, 0, 0);
  if ( !result )
    result = sub_1001E270((unsigned __int8 *)(a1 + 1), 0, 0x78u, 0, 0);
  return result;
}

//----- (10010C70) --------------------------------------------------------
int __cdecl sub_10010C70(unsigned __int8 *a1)
{
  return sub_1001E270(a1, 0, 3u, 1u, 0);
}

//----- (10010C90) --------------------------------------------------------
unsigned int __cdecl sub_10010C90(int a1)
{
  unsigned int result; // eax@1

  result = sub_1001E150((_BYTE *)a1, -1, 5, -1, 0);
  if ( !result )
    result = sub_1001E150((_BYTE *)(a1 + 4), -1, 5, -1, 0);
  return result;
}

//----- (10010CC0) --------------------------------------------------------
int __cdecl sub_10010CC0(int a1)
{
  int result; // eax@1

  result = sub_1001E010(a1, 0.0, 5.0, COERCE_INT(0.23), 0);
  if ( !result )
  {
    result = sub_1001E010(a1 + 4, -10.0, 10.0, COERCE_INT(0.0), 0);
    if ( !result )
    {
      result = sub_1001E010(a1 + 8, 0.0, 12.9, COERCE_INT(0.86000001), 0);
      if ( !result )
      {
        result = sub_1001E010(a1 + 12, 0.0, 5.0, COERCE_INT(0.23), 0);
        if ( !result )
          result = sub_1001E010(a1 + 16, -10.0, 10.0, COERCE_INT(0.0), 0);
      }
    }
  }
  return result;
}

//----- (10010DB0) --------------------------------------------------------
int __cdecl sub_10010DB0(int a1)
{
  int v1; // edi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_1001DFC0((_BYTE *)(a1 + v1 + 44), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      result = sub_1001E270((unsigned __int8 *)(a1 + 1), 0, 3u, 1u, 0);
      if ( !result )
      {
        result = sub_10010C90(a1 + 36);
        if ( !result )
        {
          result = sub_1001E010(a1 + 52, -9.9999996e24, 9.9999996e24, COERCE_INT(77.166664), 0);
          if ( !result )
          {
            result = sub_10010CC0(a1 + 8);
            if ( !result )
            {
              result = sub_10010C90(a1 + 28);
              if ( !result )
              {
                result = sub_1001E2C0((_BYTE *)(a1 + 2), 0x1F4u, 0x800u, 600, 0);
                if ( !result )
                {
                  result = sub_10010C20((unsigned __int8 *)(a1 + 50));
                  if ( !result )
                  {
                    result = sub_10010C40(a1 + 57);
                    if ( !result )
                    {
                      result = sub_1001DFC0((_BYTE *)(a1 + 56), 0, 0);
                      if ( !result )
                        result = sub_10010C70((unsigned __int8 *)(a1 + 51));
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
  }
  return result;
}

//----- (10010EC0) --------------------------------------------------------
signed int __cdecl sub_10010EC0(unsigned __int8 *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1001E270(a1, 0, 0xFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10010EF0) --------------------------------------------------------
int __cdecl sub_10010EF0(int a1)
{
  int v1; // edi@1
  signed int v2; // esi@1
  int result; // eax@2

  v1 = a1;
  v2 = 0;
  do
  {
    result = sub_1001E7B0(v1);
    if ( result )
      break;
    ++v2;
    v1 += 232;
  }
  while ( v2 < 14 );
  return result;
}

//----- (10010F20) --------------------------------------------------------
int __cdecl sub_10010F20(unsigned __int8 *a1)
{
  return sub_1001E270(a1, 0, 0x64u, 0x64u, 0);
}

//----- (10010F80) --------------------------------------------------------
int __cdecl sub_10010F80(int a1)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_1001DFC0((_BYTE *)(v1 + a1 + 4), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 3 )
      return sub_10010F20((unsigned __int8 *)(a1 + 10));
  }
  return result;
}

//----- (10010F90) --------------------------------------------------------
signed int __cdecl sub_10010F90(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1001E360(a1, 0, 0xFFFFFFFF, 0xFFFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10010FC0) --------------------------------------------------------
int __cdecl sub_10010FC0(int a1, int a2)
{
  signed int v2; // ebp@1
  unsigned __int8 v3; // bl@1
  int result; // eax@3

  v2 = 0;
  v3 = 0;
  do
  {
    switch ( v3 )
    {
      case 4u:
      case 5u:
      case 6u:
      case 9u:
      case 0xAu:
        result = sub_1001E270((unsigned __int8 *)(a1 + v3), 0, 0x3Fu, 0, a2);
        break;
      default:
        result = sub_1001E270((unsigned __int8 *)(a1 + v3), 0, 0xFFu, 0xFFu, a2);
        break;
    }
    if ( result == 1 )
    {
      v2 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v3;
  }
  while ( v3 < 0xDu );
  return v2;
}

//----- (10011050) --------------------------------------------------------
int __cdecl sub_10011050(int a1)
{
  int result; // eax@1

  result = sub_1001E6C0((_BYTE *)(a1 + 3272));
  if ( !result )
  {
    result = sub_1001E6C0((_BYTE *)(a1 + 3274));
    if ( !result )
    {
      result = sub_1001E6A0((unsigned __int8 *)(a1 + 14));
      if ( !result )
      {
        result = sub_10011040(a1 + 24);
        if ( !result )
        {
          result = sub_1001E6A0((unsigned __int8 *)(a1 + 15));
          if ( !result )
          {
            result = sub_1001E650((unsigned __int8 *)(a1 + 12));
            if ( !result )
              result = sub_1001E6A0((unsigned __int8 *)(a1 + 13));
          }
        }
      }
    }
  }
  return result;
}
// 10011040: using guessed type _DWORD __cdecl sub_10011040(_DWORD);

//----- (100110D0) --------------------------------------------------------
unsigned int __cdecl sub_100110D0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10010050((char *)(a1 + 3));
  if ( !result )
  {
    result = sub_10010050((char *)(a1 + 2));
    if ( !result )
    {
      result = sub_10010050((char *)a1);
      if ( !result )
        result = sub_10010050((char *)(a1 + 1));
    }
  }
  return result;
}

//----- (10011110) --------------------------------------------------------
unsigned int __cdecl sub_10011110(int a1)
{
  signed int v1; // esi@1
  int v2; // edi@1
  unsigned int result; // eax@2

  v1 = 0;
  v2 = a1;
  while ( 1 )
  {
    result = sub_100110D0(v2);
    if ( result )
      break;
    ++v1;
    v2 += 4;
    if ( v1 >= 3 )
    {
      result = sub_10010C20((unsigned __int8 *)(a1 + 12));
      if ( !result )
        result = sub_10010090((unsigned __int8 *)(a1 + 13));
      return result;
    }
  }
  return result;
}

//----- (10011160) --------------------------------------------------------
int __cdecl sub_10011160(int a1)
{
  int result; // eax@1

  result = sub_10010070((_BYTE *)(a1 + 4));
  if ( !result )
    result = sub_1001E2C0((_BYTE *)a1, 0, 0x3FFFu, 0x3FFF, 0);
  return result;
}

//----- (10011190) --------------------------------------------------------
int __cdecl sub_10011190(int a1)
{
  int result; // eax@1

  result = sub_10010880((_BYTE *)a1);
  if ( !result )
    result = sub_10010AD0((_BYTE *)(a1 + 4));
  return result;
}

//----- (100111C0) --------------------------------------------------------
unsigned int __cdecl sub_100111C0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10010820((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10010820((_BYTE *)(a1 + 4));
    if ( !result )
      result = sub_10010A90((_BYTE *)(a1 + 8));
  }
  return result;
}

//----- (100111F0) --------------------------------------------------------
unsigned int __cdecl sub_100111F0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10010820((_BYTE *)a1);
  if ( !result )
    result = sub_10010AB0((unsigned __int8 *)(a1 + 4));
  return result;
}

//----- (10011210) --------------------------------------------------------
unsigned int __cdecl sub_10011210(int a1)
{
  unsigned int result; // eax@1

  result = sub_10010820((_BYTE *)a1);
  if ( !result )
  {
    result = sub_1001E270((unsigned __int8 *)(a1 + 8), 0, 0x1Eu, 0x1Eu, 0);
    if ( !result )
      result = sub_10010A90((_BYTE *)(a1 + 4));
  }
  return result;
}

//----- (10011250) --------------------------------------------------------
void __cdecl __noreturn sub_10011250(int a1)
{
  exit(a1 + 4);
}

//----- (100113C0) --------------------------------------------------------
signed int __cdecl sub_100113C0(int a1, int a2)
{
  signed int v2; // ebx@1
  bool v3; // zf@5
  signed int result; // eax@5

  v2 = 0;
  if ( sub_10010EC0((unsigned __int8 *)a1, a2) == 1 )
    v2 = 1;
  if ( sub_10010B60((_BYTE *)(a1 + 2), a2) == 1 )
    v2 = 1;
  v3 = sub_10010EC0((unsigned __int8 *)(a1 + 1), a2) == 1;
  result = 1;
  if ( !v3 )
    result = v2;
  return result;
}

//----- (10011420) --------------------------------------------------------
signed int __usercall sub_10011420@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  signed int v3; // ebx@1
  char v4; // al@5
  signed int result; // eax@8
  int v6; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  if ( sub_100113C0(a1, v6) == 1 )
    v3 = 1;
  if ( a2 == 2 )
  {
    *(_BYTE *)(v2 + 1) = 40;
    v3 = 1;
  }
  v4 = *(_BYTE *)(v2 + 1);
  if ( v4 == 26 || v4 == 12 )
  {
    result = sub_1001E270((unsigned __int8 *)(v2 + 4), 0x20u, 0x20u, 0x20u, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    result = sub_1001DFC0((_BYTE *)(v2 + 37), 0, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    if ( *(_BYTE *)(v2 + 1) == 26 )
      result = sub_100103E0(v2 + 5, a2);
    else
      result = sub_100100B0(v2 + 5, a2);
    if ( result != 1 )
    {
      if ( result )
        return result;
      goto LABEL_25;
    }
    return 1;
  }
  if ( v4 != 40 )
  {
    if ( a2 != 1 )
      return -4;
    *(_BYTE *)(v2 + 1) = 40;
    return 1;
  }
  result = sub_10010F90((_BYTE *)(v2 + 4), a2);
  if ( result != 1 )
LABEL_25:
    result = v3;
  return result;
}

//----- (100114F0) --------------------------------------------------------
signed int __cdecl sub_100114F0(int a1)
{
  return sub_10011420(a1, 0);
}

//----- (10011500) --------------------------------------------------------
int __cdecl sub_10011500(int a1, int a2)
{
  unsigned int v2; // eax@5
  int v3; // eax@8
  int v4; // eax@10
  int result; // eax@11

  if ( a2 && *(_DWORD *)(a2 + 8) && *(_WORD *)(a2 + 12) && *(_DWORD *)(a2 + 4) )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 < 0xFFFFFFC2 && v2 )
    {
      j_IOP_pvg_sk_close(v2, *(_DWORD *)(a2 + 20));
      *(_DWORD *)(a1 + 4) = 0;
    }
    *(_BYTE *)(*(_WORD *)(a2 + 12) + *(_DWORD *)(a2 + 8) - 1) = 0;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 30) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 28) = 0;
    v3 = j_IOP_pvg_sk_create_id(*(_WORD *)a2);
    *(_DWORD *)(a1 + 4) = v3;
    if ( *(_DWORD *)(a2 + 36) )
      j_IOP_pvg_sk_set_addr(v3, 0, *(_DWORD *)(a2 + 36));
    v4 = *(_DWORD *)(a1 + 4);
    if ( *(_BYTE *)(a2 + 14) & 8 )
      result = j_IOP_pvg_sk_connect(v4, *(_DWORD *)(a2 + 16));
    else
      result = j_IOP_pvg_sk_accept(v4, a1 + 8, *(_DWORD *)(a2 + 16));
  }
  else
  {
    result = -59;
  }
  return result;
}
// 10030DE0: using guessed type int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD);
// 10030DF0: using guessed type int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD);
// 10030E00: using guessed type int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD);
// 10030E10: using guessed type int __cdecl j_IOP_pvg_sk_create_id(_DWORD);
// 10030EC0: using guessed type int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD);

//----- (100115C0) --------------------------------------------------------
signed int __cdecl sub_100115C0(int a1, int a2, int a3)
{
  int v3; // esi@1
  __int16 v5; // ax@3
  int v6; // eax@5
  int v7; // ebx@5

  v3 = *(_DWORD *)a1;
  if ( !*(_DWORD *)a1 )
    return -59;
  v5 = 0;
  if ( *(_BYTE *)(v3 + 14) & 0x10 )
    v5 = 2;
  v6 = sub_10030E70(*(_DWORD *)(a1 + 4), a2, a3, v5, *(_DWORD *)(v3 + 28));
  v7 = v6;
  if ( v6 >= 0 )
  {
    *(_DWORD *)(a1 + 32) = sub_10030040();
  }
  else if ( v6 != -57 || (unsigned int)(sub_10030040() - *(_DWORD *)(a1 + 32)) >= *(_DWORD *)(v3 + 32) )
  {
    sub_10011500(a1, v3);
    return v7;
  }
  return v7;
}

//----- (10011640) --------------------------------------------------------
char __usercall sub_10011640@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5)
{
  _WORD *v5; // edx@1
  int v6; // esi@1
  char result; // al@1
  char v8; // cl@5
  unsigned __int16 v9; // cx@11
  signed int v10; // edi@12
  signed int v11; // esi@12
  size_t v12; // ebp@13

  v5 = a4;
  v6 = a1;
  result = 0;
  if ( *a4 >= a3 )
  {
    *a4 = 0;
    *(_BYTE *)a2 = 0;
  }
  if ( a5 == -1 )
    *(_BYTE *)(v6 + 28) = 3;
  v8 = *(_BYTE *)(v6 + 28);
  if ( v8 )
  {
    *(_BYTE *)(v6 + 28) = v8 - 1;
    result = 0;
  }
  else if ( a5 != 13 && a5 != 10 && a5 )
  {
    *(_BYTE *)((*a4)++ + a2) = a5;
  }
  else
  {
    v9 = *a4;
    if ( *a4 )
    {
      v10 = v9;
      v11 = 0;
      if ( (signed int)v9 > 0 )
      {
        v12 = v9 - 1;
        do
        {
          if ( *(_BYTE *)(v11 + a2) == 8 )
          {
            if ( v11 )
            {
              memcpy_0((void *)(v11 + a2 - 1), (const void *)(v11 + a2 + 1), v10 - v11 - 1);
              v10 -= 2;
              v12 -= 2;
              v11 -= 2;
            }
            else
            {
              memcpy_0((void *)a2, (const void *)(a2 + 1), v12);
              --v10;
              --v12;
              v11 = -1;
            }
            v5 = a4;
          }
          ++v11;
        }
        while ( v11 < v10 );
      }
      *(_BYTE *)(v10 + a2) = 0;
      result = 1;
      *v5 = 0;
    }
  }
  return result;
}

//----- (10011710) --------------------------------------------------------
signed int __cdecl sub_10011710(_DWORD *a1, char *a2)
{
  int v2; // esi@1
  int v3; // ebx@4
  int v4; // ebp@4
  int v5; // eax@5
  signed int v6; // edi@5
  int v7; // ST0C_4@9
  char v8; // al@11
  int v10; // [sp+4h] [bp-38h]@4
  __int16 v11; // [sp+8h] [bp-34h]@9

  v2 = (int)a1;
  if ( a1 && *a1 && a2 )
  {
    *a2 = 0;
    v3 = *(_DWORD *)v2;
    v10 = *(_DWORD *)v2;
    v4 = 0;
    while ( 1 )
    {
      v5 = sub_10030E20(*(_DWORD *)(v2 + 4), (int)&a1, 1, 0, v4);
      v6 = v5;
      if ( v5 == -57 )
      {
        if ( v4 == *(_DWORD *)(v3 + 24) )
          return v6;
        v4 = *(_DWORD *)(v3 + 24);
        v6 = 1;
      }
      else
      {
        if ( v5 >= 0 )
        {
          v8 = sub_10011640(v2, *(_DWORD *)(v3 + 8), *(_WORD *)(v3 + 12), (_WORD *)(v2 + 30), (char)a1);
          v3 = v10;
          *a2 = v8;
          *(_DWORD *)(v2 + 24) += v6;
        }
        else
        {
          v7 = *(_DWORD *)(v2 + 4);
          v11 = 0;
          j_IOP_pvg_sk_status(v7, &v11);
          if ( !(v11 & 0x44) )
            sub_10011500(v2, v3);
        }
        if ( v6 <= 0 )
          return v6;
      }
      if ( *a2 )
        return v6;
    }
  }
  return -59;
}
// 10030ED0: using guessed type int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD);

//----- (100117F0) --------------------------------------------------------
int __cdecl sub_100117F0(int a1, char *a2, size_t a3, int a4)
{
  int v4; // esi@1
  int v5; // ebp@1
  unsigned int v6; // edx@3
  const void *v7; // eax@4
  int result; // eax@6
  int v9; // ebp@8
  unsigned __int8 v10; // bl@9
  unsigned __int8 v11; // cl@10
  signed __int16 v12; // si@11
  int v13; // ecx@13
  int v14; // ebx@17
  int v15; // ebx@21
  char v16; // bl@40
  char *v17; // eax@40
  int v18; // edi@45
  char v19; // al@45
  int v20; // esi@47
  char v21; // al@53
  double v22; // ST94_8@53
  double v23; // ST84_8@53
  double v24; // ST74_8@53
  double v25; // ST64_8@53
  signed int v26; // ST54_4@53
  signed int v27; // ST50_4@53
  signed int v28; // ST4C_4@53
  signed int v29; // ST48_4@53
  signed int v30; // ST44_4@53
  char *v31; // ST40_4@53
  char *v32; // ST30_4@53
  int v33; // eax@53
  char v34; // [sp+4Bh] [bp-C1h]@21
  char v35[4]; // [sp+4Ch] [bp-C0h]@17
  const void *v36; // [sp+50h] [bp-BCh]@4
  char v37; // [sp+54h] [bp-B8h]@45
  int v38; // [sp+58h] [bp-B4h]@3
  int v39; // [sp+5Ch] [bp-B0h]@3
  char v40; // [sp+60h] [bp-ACh]@1
  int v41; // [sp+64h] [bp-A8h]@1
  char v42; // [sp+68h] [bp-A4h]@45
  char v43; // [sp+6Ch] [bp-A0h]@21
  int v44; // [sp+70h] [bp-9Ch]@40
  int v45; // [sp+74h] [bp-98h]@40
  int v46; // [sp+78h] [bp-94h]@21
  char *v47; // [sp+7Ch] [bp-90h]@1
  signed int v48; // [sp+80h] [bp-8Ch]@17
  int v49; // [sp+84h] [bp-88h]@1
  char v50; // [sp+88h] [bp-84h]@1
  char v51; // [sp+8Ch] [bp-80h]@21
  char v52; // [sp+92h] [bp-7Ah]@53
  char v53; // [sp+C8h] [bp-44h]@1
  char v54; // [sp+CFh] [bp-3Dh]@45
  char v55; // [sp+D4h] [bp-38h]@21
  char v56; // [sp+DCh] [bp-30h]@1
  char v57; // [sp+E8h] [bp-24h]@1

  v47 = a2;
  v49 = a4;
  *a2 = 0;
  v53 = 0;
  v56 = 0;
  v57 = 0;
  sub_1001E8A0((int)&v57);
  sub_10015420((int)&v57, 0);
  v41 = 0;
  sub_1001E7D0(&v41, (int)&v40, (int)&v40, (int)&v40, (int)&v50);
  v4 = sub_100153B0(a2, a3, "\n\nFlight Plan Report\nAVTN DB: %s (%04d)\n", &v57, (signed __int16)v41);
  v5 = v4 * (v4 > 0);
  if ( v4 > 0 && *(_BYTE *)(a4 + 9) == 3 )
  {
    sub_100129A0(*(_DWORD *)(a4 + 20), &v53);
    v6 = *(_DWORD *)(a4 + 20);
    v38 = 0;
    v39 = 0;
    sub_10012700(v6, (int)&v38);
    v4 = sub_100153B0(
           &a2[v5],
           a3 - v5,
           "NAV_GOTO_OFF: %*s (%+0*.*f, %+0*.*f)\n",
           7,
           &v53,
           8,
           4,
           0.00000008381903171539307 * (double)v38,
           9,
           4,
           (double)v39 * 0.00000008381903171539307);
    v5 += v4 * (v4 > 0);
  }
  sub_10030160(54, 60000);
  v7 = (const void *)sub_100124D0(a1);
  v36 = v7;
  if ( v7 )
    memcpy(&unk_10145310, v7, 0x214Cu);
  result = sub_10030140(54);
  if ( v4 > 0 && v36 )
  {
    result = sub_100153B0(&a2[v5], a3 - v5, "  ## PT IDENT   FIX CC TYPE FLAGS  FROM LAT FROM LON  TO LAT   TO LON\n");
    v9 = result * (result > 0) + v5;
    if ( *(_BYTE *)(a4 + 9) == 3 || (v10 = *(_BYTE *)a4, *(_BYTE *)a4 == -1) )
    {
      v13 = (unsigned __int8)byte_10145311 - 1;
      v12 = 0;
      if ( v13 >= 7 )
        LOWORD(v13) = 7;
    }
    else
    {
      v11 = *(_BYTE *)(a4 + 7);
      if ( v11 == -1 )
        v12 = (unsigned __int8)((v10 - 2) & ((v10 - 2 < 0) - 1));
      else
        v12 = (unsigned __int8)((v11 - 2) & ((v11 - 2 < 0) - 1));
      v13 = v10 + 5;
      if ( (unsigned __int8)byte_10145311 - 1 < v13 )
        LOWORD(v13) = (unsigned __int8)byte_10145311 - 1;
    }
    v14 = (unsigned __int16)v12;
    *(_DWORD *)v35 = (unsigned __int16)v12;
    v36 = (const void *)(unsigned __int16)v12;
    v48 = (signed __int16)v13;
    if ( (unsigned __int16)v12 <= (signed int)(signed __int16)v13 )
    {
      while ( result > 0 )
      {
        sub_10015290((int)&v56, &v53, 12);
        v15 = 84 * v14;
        v53 = 0;
        v55 = 0;
        v46 = v15;
        sub_10012430((int)&unk_1014539C + v15, (int)&v55, (int)&v43, &v34);
        qmemcpy(&v51, (char *)&unk_101453A4 + v15, 0x3Cu);
        if ( v51 == 1
          || v51 == 2
          || v51 == 4
          || v51 == 5
          || v51 == 7
          || v51 == 8
          || v51 == 9
          || v51 == 10
          || v51 == 11
          || v51 == 12
          || v51 == 13
          || v51 == 15
          || v51 == 18
          || v51 == 19
          || v51 == 20
          || v51 == 21
          || v51 == 22 )
        {
          sub_100120B0(a1, v35[0], &v53);
          v55 = 0;
        }
        else
        {
          sub_10015290((int)&v53, &v55, 12);
        }
        v44 = 0;
        v45 = 0;
        v38 = 0;
        v39 = 0;
        sub_1002F620(v35[0], (int)&v44, (int)&v38);
        v16 = byte_101453A5[v15];
        v17 = &v53;
        if ( v53 )
        {
          do
          {
            if ( (unsigned __int8)*v17 > 0x7Eu || (unsigned __int8)*v17 < 0x20u )
              *v17 = 32;
            ++v17;
          }
          while ( *v17 );
        }
        v18 = v49;
        v19 = *(_BYTE *)(v49 + 9);
        v54 = 0;
        v37 = 0;
        v42 = 0;
        if ( v19 != 3 && v19 )
        {
          v20 = *(_DWORD *)v35;
          if ( *(_WORD *)v35 == *(_BYTE *)v49 )
          {
            sub_10015290((int)&v37, "->", 3);
            if ( *(_BYTE *)(v18 + 9) == 1 )
              sub_10015290((int)&v42, "| ", 3);
          }
          else if ( *(_WORD *)v35 == *(_BYTE *)(v49 + 7) )
          {
            sub_10015290((int)&v37, "|-", 3);
          }
        }
        else
        {
          v20 = *(_DWORD *)v35;
        }
        v21 = byte_1014538D[v46];
        v22 = (double)v39 * 0.00000008381903171539307;
        v23 = (double)v38 * 0.00000008381903171539307;
        v24 = (double)v45 * 0.00000008381903171539307;
        v25 = 0.00000008381903171539307 * (double)v44;
        v26 = *(int *)((char *)&dword_10145398 + v46) != 0x3FFFF ? 97 : 32;
        v27 = (byte_1014538D[v46] & 8) != 0 ? 85 : 32;
        v28 = (v21 & 1) != 0 ? 65 : 32;
        v29 = (v21 & 4) != 0 ? 83 : 32;
        v30 = (v21 & 2) != 0 ? 68 : 32;
        v31 = (char *)&unk_10052AD1 + 6 * sub_10014DE0(&v34, 1u, (int)&unk_10052AD0, 6, 13, 9);
        v32 = (char *)&unk_10052B21 + 5 * sub_10014DE0(&v52, 1u, (int)&unk_10052B20, 5, 6, 0);
        v33 = sub_10014DE0(&v51, 1u, (int)&unk_10052A70, 4, 24, 24);
        result = sub_100153B0(
                   &v47[v9],
                   a3 - v9,
                   "%*s%*d %*s %-*s %*s %*s %*s %c%c%c%c%c%c %+0*.*f %+0*.*f %+0*.*f %+0*.*f\n",
                   2,
                   &v37,
                   2,
                   v36,
                   2,
                   (char *)&unk_10052A71 + 4 * v33,
                   7,
                   &v53,
                   3,
                   v32,
                   2,
                   &v43,
                   4,
                   v31,
                   v30,
                   v29,
                   v28,
                   v27,
                   v26,
                   (v16 & 8) != 0 ? 103 : 32,
                   8,
                   4,
                   v25,
                   9,
                   4,
                   v24,
                   8,
                   4,
                   v23,
                   9,
                   4,
                   v22);
        *(_DWORD *)v35 = v20 + 1;
        v9 += result * (result > 0);
        v36 = (const void *)(unsigned __int16)(v20 + 1);
        if ( (signed int)v36 > v48 )
          break;
        v14 = (int)v36;
      }
    }
  }
  return result;
}
// 10145311: using guessed type char byte_10145311;
// 10145398: using guessed type int dword_10145398;

//----- (10011DD0) --------------------------------------------------------
void sub_10011DD0()
{
  dword_1020CF7C = -15;
}
// 1020CF7C: using guessed type int dword_1020CF7C;

//----- (10011DE0) --------------------------------------------------------
signed int sub_10011DE0()
{
  return sub_100312F0((int)&off_10052C54);
}
// 10052C54: using guessed type char *off_10052C54;

//----- (10011DF0) --------------------------------------------------------
int __cdecl sub_10011DF0(int a1, int a2, _DWORD *a3)
{
  int result; // eax@1
  int v4; // esi@1
  int v5; // edi@1
  int v6; // ecx@1
  char v7; // bl@2
  char v8; // dl@2
  int v9; // edx@3
  int v10; // eax@10
  int v11; // ecx@10
  unsigned __int16 v12; // dx@10
  int v13; // edx@14
  _DWORD *v14; // edx@16
  unsigned int v15; // [sp+10h] [bp-8h]@1
  int v16; // [sp+14h] [bp-4h]@1
  int v17; // [sp+1Ch] [bp+4h]@1

  result = -1;
  v4 = 0;
  v5 = a1;
  v15 = 1;
  v17 = 0;
  v16 = 0;
  v6 = 255;
  while ( 2 )
  {
    v7 = *(_BYTE *)(v6 + v5 + 8);
    v8 = *(_BYTE *)(v6 + v5 + 8);
    switch ( *(_BYTE *)(v6 + v5 + 8) & 0xF0 )
    {
      case 0x80:
        v9 = v8 & 0xF;
        goto LABEL_18;
      case 0xF0:
        v17 += 16;
        goto LABEL_19;
      case 0xC0:
        if ( v15 < 2 )
          result = *(_DWORD *)(v5 + 4 * v15);
        --v15;
        goto LABEL_14;
      case 0x90:
      case 0xD0:
        if ( (v7 & 0xF0) == -48 )
          --v15;
        v10 = *(_BYTE *)(v6 + v5 + 7);
        v11 = v6 - 1;
        v16 = v8 & 0xF;
        LOBYTE(v12) = 0;
        HIBYTE(v12) = *(_BYTE *)(v11 + v5 + 7);
        v6 = v11 - 3;
        result = (*(_BYTE *)(v6 + v5 + 8) << 24) | (*(_BYTE *)(v6 + v5 + 9) << 16) | v12 | v10;
        goto LABEL_14;
      default:
        if ( v7 < 0 )
        {
          *a3 = v4;
          return result;
        }
        if ( v7 )
        {
          result = 4 * ((unsigned int)*(_BYTE *)(v6 + v5 + 8) >> 4);
          v16 = *(_BYTE *)(v6 + v5 + 8) & 0xF;
LABEL_14:
          v13 = v17;
          if ( v17 )
          {
            *(_DWORD *)(a2 + 4 * v4++) = result + 4 * v17;
            v13 = 0;
            if ( v4 == *a3 )
            {
              *a3 = v4;
              return result;
            }
          }
          *(_DWORD *)(a2 + 4 * v4) = result + 4 * v13;
          v14 = a3;
          if ( ++v4 == *a3 )
            goto LABEL_23;
          v9 = v16;
LABEL_18:
          v17 = v9;
LABEL_19:
          if ( --v6 < 0 )
          {
            result = (int)a3;
            *a3 = v4;
            return result;
          }
          continue;
        }
        v14 = a3;
LABEL_23:
        *v14 = v4;
        return result;
    }
  }
}

//----- (10011FC0) --------------------------------------------------------
int __cdecl sub_10011FC0(int a1, int a2)
{
  int result; // eax@1

  result = a2;
  *(float *)a2 = 6.2831855;
  *(float *)(a2 + 4) = 6.2831855;
  switch ( *(_BYTE *)a1 )
  {
    case 1:
    case 4:
    case 0x12:
    case 0x14:
    case 0x15:
      *(_DWORD *)a2 = *(_DWORD *)(a1 + 44);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 48);
      break;
    case 2:
    case 5:
    case 0x13:
    case 0x16:
      *(_DWORD *)a2 = *(_DWORD *)(a1 + 52);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 56);
      break;
    default:
      return result;
  }
  return result;
}

//----- (10012030) --------------------------------------------------------
int __cdecl sub_10012030(int a1, char a2, void *a3)
{
  int v3; // eax@1
  int result; // eax@3

  sub_10030160(54, 60000);
  v3 = sub_100124D0(a1);
  if ( v3 && (unsigned __int8)a2 < *(_BYTE *)(v3 + 1) )
  {
    qmemcpy(a3, (const void *)(84 * (unsigned __int8)a2 + v3 + 148), 0x3Cu);
    result = sub_10030140(54);
  }
  else
  {
    memset(a3, 0, 0x3Cu);
    *(_BYTE *)a3 = 24;
    *((_BYTE *)a3 + 1) = 0;
    *((_BYTE *)a3 + 4) = 0;
    *((_BYTE *)a3 + 6) = 0;
    *((_BYTE *)a3 + 7) = 4;
    result = sub_10030140(54);
  }
  return result;
}

//----- (100120B0) --------------------------------------------------------
char __cdecl sub_100120B0(int a1, char a2, char *a3)
{
  char result; // al@2
  int v4; // ebx@6
  unsigned int v5; // esi@8
  float v6; // edi@10
  unsigned int v7; // esi@10
  double v8; // ST28_8@10
  int v9; // eax@10
  int v10; // edi@13
  float v11; // [sp+1Ch] [bp-44h]@6
  float v12; // [sp+1Ch] [bp-44h]@13
  char v13; // [sp+24h] [bp-3Ch]@1
  float v14; // [sp+30h] [bp-30h]@5
  int v15; // [sp+48h] [bp-18h]@1
  float v16; // [sp+50h] [bp-10h]@6
  float v17; // [sp+54h] [bp-Ch]@6

  sub_10012030(a1, a2, &v13);
  if ( v15 == 262142 )
  {
    result = sub_10015290((int)a3, "Locked", 12);
  }
  else
  {
    switch ( v13 )
    {
      case 0:
        result = sub_10015290((int)a3, "DME ARC", 12);
        break;
      case 1:
      case 7:
      case 0x12:
        sub_100153B0(a3, 0xCu, "%d", (signed int)(v14 * 3.280839895013123 + 0.5));
        result = sub_100153E0(a3, &unk_10053208, 12);
        break;
      case 2:
      case 9:
      case 0x13:
        v11 = v17 * 0.0005399568034557236;
        sub_10012720(LODWORD(v16), (int)a3);
        v4 = 3;
        if ( v11 >= 9.9499998 )
          v4 = 4;
        v5 = strlen(a3);
        result = sub_100150B0(v11, v4, 1, (int)&a3[v5]);
        *(&a3[v4] + v5) = 0;
        break;
      case 4:
      case 0x14:
        result = sub_10015290((int)a3, "INTRCPT ", 12);
        break;
      case 5:
      case 0x16:
        v6 = v16;
        sub_10012720(LODWORD(v16), (int)a3);
        v7 = strlen(a3);
        v8 = v17;
        *(float *)&v8 = v8 - sub_10012540(v6);
        *(float *)&v8 = sub_100324D0(*(float *)&v8);
        v9 = sub_10032550(*(float *)&v8);
        if ( !v9 )
          v9 = 360;
        result = sub_100153B0(&a3[v7], 12 - v7, "%03i", v9);
        break;
      case 8:
        v10 = 3;
        v12 = v16 * 0.0005399568034557236;
        if ( v12 >= 9.9499998 )
          v10 = 4;
        *a3 = 68;
        result = sub_100150B0(v12, v10, 1, (int)(a3 + 1));
        a3[v10 + 1] = 0;
        break;
      case 0xA:
      case 0x15:
        result = sub_10015290((int)a3, "MANSEQ", 12);
        break;
      case 0xF:
        result = sub_10015290((int)a3, "PROC. TURN", 12);
        break;
      case 0xB:
      case 0xC:
      case 0xD:
        result = sub_10015290((int)a3, "HOLD", 12);
        break;
      case 0x10:
        result = sub_10015290((int)a3, &unk_1005319C, 12);
        break;
      default:
        result = (char)a3;
        *a3 = 0;
        break;
    }
  }
  return result;
}

//----- (10012390) --------------------------------------------------------
void __cdecl sub_10012390(_BYTE *a1, signed int a2, int a3)
{
  signed int v3; // esi@1
  _BYTE *v4; // ecx@2
  unsigned int v5; // edx@2
  unsigned int v6; // eax@6
  unsigned __int16 v7; // ax@7
  char v8; // al@10

  v3 = 0;
  if ( a2 > 0 )
  {
    v4 = a1;
    v5 = a2;
    do
    {
      if ( v3 & 3 )
      {
        if ( (v3 & 3) == 1 )
        {
          v6 = v5 >> 4;
        }
        else
        {
          --v4;
          if ( (v3 & 3) == 2 )
          {
            HIBYTE(v7) = v4[1];
            LOBYTE(v7) = *v4;
            v5 = v7;
            v6 = (unsigned int)v7 >> 6;
          }
          else
          {
            LOBYTE(v6) = v5;
          }
        }
      }
      else
      {
        BYTE1(v5) = *v4--;
        LOBYTE(v5) = *v4;
        v5 = (unsigned __int16)v5;
        LOWORD(v6) = (unsigned __int16)v5 >> 10;
      }
      v8 = v6 & 0x3F;
      if ( v8 )
      {
        if ( (unsigned __int8)(v8 - 1) > 0x19u )
        {
          if ( (unsigned __int8)(v8 - 32) <= 9u )
            v8 += 16;
        }
        else
        {
          v8 += 64;
        }
        *(_BYTE *)(v3 + a3) = v8;
      }
      else
      {
        *(_BYTE *)(v3 + a3) = 32;
      }
      ++v3;
    }
    while ( v3 < a2 );
  }
}

//----- (10012430) --------------------------------------------------------
int __cdecl sub_10012430(int a1, int a2, int a3, _BYTE *a4)
{
  __int16 v4; // ax@1
  int result; // eax@1
  int v6; // [sp+10h] [bp-10h]@1
  __int16 v7; // [sp+14h] [bp-Ch]@1
  __int16 v8; // [sp+16h] [bp-Ah]@1

  sub_1001EAF0((int)&v6, (_BYTE *)(a1 + 6), 8, (int)&v6);
  v4 = v7;
  *(_DWORD *)a2 = v6;
  *(_WORD *)(a2 + 4) = v4;
  *(_BYTE *)(a2 + 6) = 0;
  result = sub_10015420(a2, 6);
  *(_WORD *)a3 = v8;
  *(_BYTE *)(a3 + 2) = 0;
  *a4 = *(_BYTE *)a1 & 0xF;
  return result;
}

//----- (100124B0) --------------------------------------------------------
unsigned int __cdecl sub_100124B0(unsigned int a1, _BYTE *a2, _BYTE *a3)
{
  unsigned int result; // eax@1

  *a2 = a1;
  result = a1 >> 8;
  *a3 = BYTE1(a1);
  return result;
}

//----- (100124D0) --------------------------------------------------------
int __cdecl sub_100124D0(unsigned __int8 a1)
{
  int v1; // eax@3
  bool v2; // zf@3
  int result; // eax@3

  if ( a1 >= 0x67u
    || !(unsigned __int8)sub_10011DE0()
    || (v1 = 8524 * a1, v2 = a1 == *(_BYTE *)(v1 + dword_1020CF7C + 2004), result = v1 + dword_1020CF7C + 2004, !v2) )
  {
    result = 0;
  }
  return result;
}
// 1020CF7C: using guessed type int dword_1020CF7C;

//----- (10012510) --------------------------------------------------------
char __cdecl sub_10012510(__int64 a1)
{
  char result; // al@5

  if ( (unsigned int)a1 < 0x3E8 || (_DWORD)a1 == 262141 )
  {
    result = 4;
  }
  else if ( (_DWORD)a1 == 0x3FFFF || (_DWORD)a1 == 262142 )
  {
    result = 9;
  }
  else
  {
    result = sub_100131C0(a1);
  }
  return result;
}

//----- (10012540) --------------------------------------------------------
double __cdecl sub_10012540(float a1)
{
  unsigned int v1; // esi@1
  char v2; // al@1
  char v3; // al@2
  double result; // st7@2
  __int64 v5; // [sp-4h] [bp-20h]@0
  char v6; // [sp+4h] [bp-18h]@9
  char v7; // [sp+Ch] [bp-10h]@9

  v1 = LODWORD(a1);
  *(float *)&v5 = a1;
  v2 = sub_10012510(v5);
  if ( v1 == 262141 )
  {
    v3 = sub_10031FE0();
    a1 = sub_10031F50(v3);
    result = a1;
  }
  else
  {
    switch ( v2 )
    {
      case 9:
        a1 = 6.2831855;
        result = (float)6.2831855;
        break;
      case 8:
        a1 = sub_10013A60(v1);
        result = a1;
        break;
      case 3:
        a1 = sub_10014090(v1);
        result = a1;
        break;
      default:
        sub_10012870(0, v1, (double *)&v7);
        sub_10032510((int)&v7, (int)&v6);
        sub_10014070((int)&v6, &a1);
        result = a1;
        break;
    }
  }
  return result;
}

//----- (10012600) --------------------------------------------------------
char __usercall sub_10012600@<al>(int a1@<edi>, unsigned int a2@<esi>, char a3)
{
  char result; // al@2
  __int64 v4; // [sp-4h] [bp-68h]@5
  int v5; // [sp+4h] [bp-60h]@6
  float v6; // [sp+8h] [bp-5Ch]@11
  float v7; // [sp+Ch] [bp-58h]@11
  char v8; // [sp+10h] [bp-54h]@8
  double v9; // [sp+18h] [bp-4Ch]@4
  double v10; // [sp+20h] [bp-44h]@4
  char v11; // [sp+28h] [bp-3Ch]@11

  if ( a2 < 0x3E8 )
    return sub_10012B80(a2, a1);
  if ( a2 == 262141 )
  {
    sub_1001EF90(0, (int)&v9);
    return sub_1001F1D0(a1, v9, v10);
  }
  if ( sub_10012510(v4) == 11 )
  {
    sub_100124B0(a2, &v5, (_BYTE *)&v4 + 4);
    result = v5;
    if ( (_BYTE)v5 )
    {
      if ( (_BYTE)v5 == -1 )
      {
LABEL_12:
        *(_DWORD *)a1 = 2147483648;
        *(_DWORD *)(a1 + 4) = 2147483648;
        return result;
      }
    }
    else if ( a3 != (_BYTE)v5 )
    {
      return sub_1002F620(BYTE4(v4), (int)&v8, a1);
    }
    if ( BYTE4(v4) != -1 )
    {
      sub_10012030(v5, SBYTE4(v4), &v11);
      sub_10011FC0((int)&v11, (int)&v6);
      return sub_1001F2B0(a1, v6, v7);
    }
    goto LABEL_12;
  }
  return sub_10012EE0(a2, a1);
}

//----- (10012700) --------------------------------------------------------
char __cdecl sub_10012700(unsigned int a1, int a2)
{
  return sub_10012600(a2, a1, 1);
}

//----- (10012720) --------------------------------------------------------
void __cdecl sub_10012720(unsigned int a1, int a2)
{
  __int64 v2; // [sp-4h] [bp-24h]@0
  int v3; // [sp+8h] [bp-18h]@10
  char v4[4]; // [sp+Ch] [bp-14h]@10
  char v5; // [sp+10h] [bp-10h]@10

  if ( a1 >= 0x3E8 )
  {
    switch ( a1 )
    {
      case 0x3FFFFu:
        *(_DWORD *)a2 = 1600085855;
        *(_WORD *)(a2 + 4) = 24415;
        *(_BYTE *)(a2 + 6) = 0;
        break;
      case 0x3FFFEu:
        *(_DWORD *)a2 = 1801678668;
        *(_WORD *)(a2 + 4) = 25701;
        *(_BYTE *)(a2 + 6) = 0;
        break;
      case 0x3FFFDu:
        *(_DWORD *)a2 = 1330654800;
        *(_WORD *)(a2 + 4) = 83;
        *(_BYTE *)(a2 + 6) = 0;
        break;
      default:
        LODWORD(v2) = a1;
        if ( sub_10012510(v2) == 11 )
        {
          sub_100124B0(a1, &v3, v4);
          sub_100120B0(v3, v4[0], &v5);
          sub_10015290(a2, &v5, 7);
        }
        else
        {
          sub_10012DA0(a1, a2);
        }
        break;
    }
  }
  else
  {
    sub_10012A80(a1, a2);
  }
}

//----- (10012870) --------------------------------------------------------
double *__cdecl sub_10012870(char a1, char a2, double *a3)
{
  unsigned int v3; // esi@1
  double *result; // eax@10
  __int64 v5; // [sp-4h] [bp-60h]@0
  int v6; // [sp+4h] [bp-58h]@7
  char v7; // [sp+8h] [bp-54h]@10
  double v8; // [sp+10h] [bp-4Ch]@3
  double v9; // [sp+18h] [bp-44h]@10
  char v10; // [sp+20h] [bp-3Ch]@10

  v3 = a2;
  if ( a2 == 0x3FFFF )
    goto LABEL_11;
  if ( (unsigned int)a2 >= 0x3E8 )
  {
    if ( a2 == 262141 )
    {
      sub_1001EF90(a1, (int)&v8);
      goto LABEL_13;
    }
    LODWORD(v5) = a2;
    if ( sub_10012510(v5) != 11 )
    {
      sub_10012FC0(v3, (int)&v8);
      goto LABEL_13;
    }
    sub_100124B0(v3, &v6, &a2);
    if ( (_BYTE)v6 != -1 && a2 != -1 && sub_10012BF0(v6, a2) == v3 )
    {
      sub_10012030(v6, a2, &v10);
      sub_10011FC0((int)&v10, (int)&v7);
      sub_10032530((int)&v7, (int)&v8);
      result = a3;
      *a3 = v8;
      result[1] = v9;
      return result;
    }
LABEL_11:
    result = a3;
    v8 = 6.2831853071796;
    v9 = 6.2831853071796;
    *a3 = 6.2831853071796;
    result[1] = v9;
    return result;
  }
  sub_10012B10(a2, (int)&v8);
LABEL_13:
  result = a3;
  *a3 = v8;
  result[1] = v9;
  return result;
}

//----- (100129A0) --------------------------------------------------------
void __cdecl sub_100129A0(int a1, char *a2)
{
  __int64 v2; // [sp-4h] [bp-10h]@0
  char v3[4]; // [sp+4h] [bp-8h]@2
  int v4; // [sp+8h] [bp-4h]@2

  LODWORD(v2) = a1;
  if ( sub_10012510(v2) == 11 )
  {
    sub_100124B0(a1, &v4, v3);
    sub_100120B0(v4, v3[0], a2);
  }
  else
  {
    sub_10012720(a1, (int)a2);
  }
}

//----- (10012A00) --------------------------------------------------------
char __usercall sub_10012A00@<al>(unsigned __int16 a1@<ax>, void *a2)
{
  unsigned __int16 v2; // si@1
  char result; // al@4

  v2 = a1;
  if ( (unsigned __int8)sub_10011DE0() && v2 < 0x3E8u && *(_WORD *)(dword_1020CF7C + 56 * v2 + 880428) == v2 )
  {
    qmemcpy(a2, (const void *)(dword_1020CF7C + 56 * (v2 + 15721)), 0x38u);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1020CF7C: using guessed type int dword_1020CF7C;

//----- (10012A60) --------------------------------------------------------
int __usercall sub_10012A60@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(double *)result = (double)*(signed int *)a2 * 0.000000001462918079267163;
  *(double *)(result + 8) = 0.000000001462918079267163 * (double)*(signed int *)(a2 + 4);
  return result;
}

//----- (10012A80) --------------------------------------------------------
int __cdecl sub_10012A80(unsigned __int16 a1, int a2)
{
  char v3; // [sp+4h] [bp-3Ch]@1
  char v4; // [sp+8h] [bp-38h]@3

  sub_10030160(58, 60000);
  if ( sub_10012A00(a1, &v3) )
  {
    sub_10012390(&v4, 6, a2);
    sub_10015420(a2, 6);
  }
  else
  {
    *(_DWORD *)a2 = 1600085855;
    *(_WORD *)(a2 + 4) = 24415;
    *(_BYTE *)(a2 + 6) = 0;
  }
  return sub_10030140(58);
}

//----- (10012B10) --------------------------------------------------------
int __cdecl sub_10012B10(unsigned __int16 a1, int a2)
{
  char v3; // [sp+4h] [bp-3Ch]@1
  char v4; // [sp+Ch] [bp-34h]@3

  sub_10030160(58, 60000);
  if ( sub_10012A00(a1, &v3) )
  {
    sub_10012A60(a2, (int)&v4);
  }
  else
  {
    *(double *)a2 = 6.2831853071796;
    *(double *)(a2 + 8) = 6.2831853071796;
  }
  return sub_10030140(58);
}

//----- (10012B80) --------------------------------------------------------
int __cdecl sub_10012B80(unsigned __int16 a1, int a2)
{
  int v2; // edx@3
  char v4; // [sp+4h] [bp-3Ch]@1
  int v5; // [sp+Ch] [bp-34h]@3
  int v6; // [sp+10h] [bp-30h]@3

  sub_10030160(58, 60000);
  if ( sub_10012A00(a1, &v4) )
  {
    v2 = v6;
    *(_DWORD *)a2 = v5;
    *(_DWORD *)(a2 + 4) = v2;
  }
  else
  {
    *(_DWORD *)a2 = 2147483648;
    *(_DWORD *)(a2 + 4) = 2147483648;
  }
  return sub_10030140(58);
}

//----- (10012BF0) --------------------------------------------------------
signed int __cdecl sub_10012BF0(unsigned __int8 a1, unsigned __int8 a2)
{
  signed int v2; // esi@1
  int v3; // eax@1

  sub_10030160(54, 60000);
  v2 = 0x3FFFF;
  v3 = sub_100124D0(a1);
  if ( v3 && a2 < *(_BYTE *)(v3 + 1) )
    v2 = sub_1001EE60(84 * a2 + v3 + 148);
  sub_10030140(54);
  return v2;
}

//----- (10012C50) --------------------------------------------------------
char __cdecl sub_10012C50(unsigned __int8 a1, int a2, char a3, int a4)
{
  char result; // al@2

  if ( (unsigned __int8)(*(int (__cdecl **)(int, signed int, int))dword_1020CF70)(
                          a2 + dword_1005383C[3 * a1] - 3,
                          4,
                          a4) )
  {
    *(_BYTE *)(a4 + 4) = a3;
    *(_BYTE *)a4 &= byte_10053800[5 * a1];
    *(_BYTE *)(a4 + 1) &= byte_10053801[5 * a1];
    *(_BYTE *)(a4 + 2) &= byte_10053802[5 * a1];
    *(_BYTE *)(a4 + 3) &= byte_10053803[5 * a1];
    *(_BYTE *)(a4 + 4) &= byte_10053804[5 * a1];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1005383C: using guessed type int dword_1005383C[];
// 1020CF70: using guessed type int dword_1020CF70;

//----- (10012CD0) --------------------------------------------------------
char __usercall sub_10012CD0@<al>(int a1@<eax>, unsigned __int8 a2)
{
  int v2; // edi@1
  unsigned int v3; // edi@2
  char v4; // dl@2
  signed int v5; // eax@2
  char result; // al@6
  __int16 v7; // [sp+Ch] [bp-1ECh]@1
  char v8[490]; // [sp+Eh] [bp-1EAh]@3

  v2 = a1;
  if ( (unsigned __int8)(*(int (__cdecl **)(int, signed int, __int16 *))dword_1020CF70)(
                          dword_1020CFA0[3 * (unsigned __int8)byte_10053834[12 * a2]],
                          492,
                          &v7) )
  {
    v3 = v2 - *(_DWORD *)(dword_1020D7F0 + 4 * a2 + 20812);
    v4 = 0;
    v5 = 163;
    do
    {
      if ( *(unsigned __int16 *)((char *)&v7 + 3 * v5) + ((v8[3 * v5] & 3u) << 16) <= v3 )
      {
        v4 = v5;
        v5 = 0;
      }
      --v5;
    }
    while ( v5 >= 0 );
    result = v4 + 4;
  }
  else
  {
    result = -92;
  }
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;
// 1020CFA0: using guessed type int dword_1020CFA0[];
// 1020D7F0: using guessed type int dword_1020D7F0;
// 10012CD0: using guessed type char var_1EA[490];

//----- (10012D70) --------------------------------------------------------
int __fastcall sub_10012D70(int a1, int a2)
{
  int result; // eax@1

  result = ((*(_WORD *)a1 << 9) + (*(_WORD *)(a1 + 5) & 0x1FF)) << 7;
  *(_DWORD *)a2 = (*(_BYTE *)(a1 + 4) + (*(_WORD *)(a1 + 2) << 8)) << 7;
  *(_DWORD *)(a2 + 4) = result;
  return result;
}

//----- (10012DA0) --------------------------------------------------------
void __cdecl sub_10012DA0(unsigned int a1, int a2)
{
  unsigned __int8 v2; // bl@4
  int v3; // ebp@4
  char v4; // ST34_1@4
  char v5; // [sp+Ch] [bp-Ch]@4
  char v6; // [sp+10h] [bp-8h]@5

  if ( a1 >= 0x3E8 )
  {
    if ( a1 >= *(_DWORD *)(dword_1020D7F0 + 20828) )
    {
      if ( ((a1 >> 16) & 0xFC00) == 12288 )
        sub_10014470(a1, a2);
      else
        sub_10013AD0(a1, a2);
    }
    else
    {
      v2 = sub_100130E0(a1);
      v3 = sub_10013110(a1, v2, 1);
      v4 = sub_10012CD0(a1, v2);
      if ( sub_10012C50(v2, v3, v4, (int)&v5) )
      {
        sub_10012390(&v6, 6, a2);
        sub_10015420(a2, 6);
      }
      else
      {
        *(_DWORD *)a2 = 1600085855;
        *(_WORD *)(a2 + 4) = 24415;
        *(_BYTE *)(a2 + 6) = 0;
      }
    }
  }
  else
  {
    *(_DWORD *)a2 = 1600085855;
    *(_WORD *)(a2 + 4) = 24415;
    *(_BYTE *)(a2 + 6) = 0;
  }
}
// 1020D7F0: using guessed type int dword_1020D7F0;

//----- (10012EE0) --------------------------------------------------------
char __cdecl sub_10012EE0(unsigned int a1, int a2)
{
  char result; // al@2
  unsigned __int8 v3; // al@4
  int v4; // eax@4
  char v5; // [sp+4h] [bp-8h]@4

  if ( a1 >= 0x3E8 )
  {
    if ( a1 >= *(_DWORD *)(dword_1020D7F0 + 20828) )
    {
      if ( ((a1 >> 16) & 0xFC00) == 12288 )
        result = sub_10014650(a1, a2);
      else
        result = sub_10013CD0(a1, a2);
    }
    else
    {
      v3 = sub_100130E0(a1);
      v4 = sub_10013110(a1, v3, 1);
      (*(void (__cdecl **)(int, signed int, char *))dword_1020CF70)(v4, 7, &v5);
      result = sub_10012D70((int)&v5, a2);
    }
  }
  else
  {
    result = a2;
    *(_DWORD *)a2 = 2147483648;
    *(_DWORD *)(a2 + 4) = 2147483648;
  }
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;
// 1020D7F0: using guessed type int dword_1020D7F0;

//----- (10012F90) --------------------------------------------------------
void __usercall sub_10012F90(int a1@<ecx>, int a2@<esi>)
{
  int v2; // [sp+0h] [bp-8h]@1
  int v3; // [sp+4h] [bp-4h]@1

  sub_10012D70(a1, (int)&v2);
  *(double *)a2 = sub_1001EE80(v2, 24);
  *(double *)(a2 + 8) = sub_1001EE80(v3, 24);
}

//----- (10012FC0) --------------------------------------------------------
char __cdecl sub_10012FC0(unsigned int a1, int a2)
{
  char result; // al@2
  unsigned __int8 v3; // bl@4
  int v4; // eax@4
  unsigned int v5; // ebx@7
  char v6; // bl@13
  int v7; // [sp+4h] [bp-20h]@4
  int v8; // [sp+8h] [bp-1Ch]@10
  unsigned __int8 v9; // [sp+Ch] [bp-18h]@9
  unsigned int v10; // [sp+Eh] [bp-16h]@7
  unsigned int v11; // [sp+14h] [bp-10h]@8

  if ( a1 >= 0x3E8 )
  {
    if ( a1 >= *(_DWORD *)(dword_1020D7F0 + 20828) )
    {
      if ( ((a1 >> 16) & 0xFC00) == 12288 )
      {
        v6 = sub_10014650(a1, (int)&v7);
        if ( v6 )
        {
          sub_1001F1B0(a2, v7, v8);
          result = v6;
        }
        else
        {
          *(double *)a2 = 6.2831853071796;
          *(double *)(a2 + 8) = 6.2831853071796;
          result = 0;
        }
      }
      else
      {
        result = sub_10013C60(a1, a2);
      }
    }
    else
    {
      v3 = sub_100130E0(a1);
      v4 = sub_10013110(a1, v3, 1);
      (*(void (__cdecl **)(int, signed int, int *))dword_1020CF70)(v4, 32, &v7);
      if ( v3 )
      {
        if ( v3 == 1 )
        {
          LOBYTE(v5) = v9 >> 1;
        }
        else if ( v3 == 2 )
        {
          v5 = v11 >> 14;
        }
        else
        {
          v5 = v10 >> 23;
        }
      }
      else
      {
        v5 = (unsigned int)v8 >> 29;
      }
      sub_10012F90((int)&v7, a2);
      result = v5 & 1;
    }
  }
  else
  {
    *(double *)a2 = 6.2831853071796;
    *(double *)(a2 + 8) = 6.2831853071796;
    result = 0;
  }
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;
// 1020D7F0: using guessed type int dword_1020D7F0;

//----- (100130E0) --------------------------------------------------------
unsigned __int8 __cdecl sub_100130E0(unsigned int a1)
{
  unsigned __int8 result; // al@1

  result = 0;
  do
  {
    if ( a1 < *(_DWORD *)(dword_1020D7F0 + 4 * result + 20816) )
      break;
    ++result;
  }
  while ( result < 4u );
  return result;
}
// 1020D7F0: using guessed type int dword_1020D7F0;

//----- (10013110) --------------------------------------------------------
int __cdecl sub_10013110(unsigned int a1, unsigned __int8 a2, char a3)
{
  unsigned int v3; // esi@2
  char v4; // bl@4
  int result; // eax@5

  if ( a2 >= 4u )
  {
    result = 0xFFFFFF;
  }
  else
  {
    v3 = a1;
    if ( a3 )
      v3 = a1 - *(_DWORD *)(dword_1020D7F0 + 4 * a2 + 20812);
    v4 = byte_10053838[12 * a2];
    if ( sub_1001EEC0(v3, (unsigned __int8)byte_10053838[12 * a2]) )
      result = dword_1020CFA0[3 * (unsigned __int8)v4] + v3 * (unsigned __int16)word_1020CFA4[6 * (unsigned __int8)v4];
    else
      result = 0xFFFFFF;
  }
  return result;
}
// 1020CFA0: using guessed type int dword_1020CFA0[];
// 1020CFA4: using guessed type __int16 word_1020CFA4[];
// 1020D7F0: using guessed type int dword_1020D7F0;

//----- (10013190) --------------------------------------------------------
int __cdecl sub_10013190(unsigned int a1)
{
  unsigned __int8 v1; // ST14_1@1

  v1 = sub_100130E0(a1);
  return sub_10013110(a1, v1, 1);
}

//----- (100131C0) --------------------------------------------------------
char __cdecl sub_100131C0(__int64 a1)
{
  char v1; // bl@1
  char result; // al@3
  unsigned __int16 v3; // ax@7

  v1 = 9;
  if ( (unsigned int)a1 < 0x3E8 )
  {
LABEL_13:
    result = v1;
  }
  else
  {
    switch ( sub_100130E0(a1) )
    {
      case 0u:
        result = 0;
        break;
      case 1u:
        result = 1;
        break;
      case 2u:
        result = 2;
        break;
      case 3u:
        result = 3;
        break;
      default:
        v3 = WORD1(a1) >> 10;
        if ( (unsigned __int16)(WORD1(a1) >> 10) >= 0xBu && v3 < 0xDu
          || v3 >= 5u && v3 <= 8u && (unsigned __int16)(a1 - 1000) < (unsigned int)sub_1001EF00(8u) )
        {
          v1 = (*(_DWORD *)((char *)&a1 + 2) >> 10) & 0x3F;
        }
        goto LABEL_13;
    }
  }
  return result;
}

//----- (10013260) --------------------------------------------------------
int __cdecl sub_10013260(int a1)
{
  int result; // eax@1
  signed int v2; // ecx@1
  unsigned __int16 v3; // [sp+Ch] [bp+4h]@1

  result = 0;
  v3 = *(_WORD *)(a1 + 4);
  v2 = 0;
  do
  {
    if ( v3 & (unsigned __int16)(1 << v2) )
      result += (unsigned __int16)word_1020D6C2;
    ++v2;
  }
  while ( v2 < 16 );
  return result;
}
// 1020D6C2: using guessed type __int16 word_1020D6C2;

//----- (100132A0) --------------------------------------------------------
signed int __thiscall sub_100132A0(int this)
{
  int v1; // edi@1
  signed int result; // eax@1
  int v3; // ebx@2
  int v4; // esi@2
  __int16 v5; // cx@2
  char *v6; // eax@2
  unsigned __int16 v7; // [sp+4h] [bp-A4h]@2

  v1 = this;
  result = 0xFFFFFF;
  if ( *(_BYTE *)(this + 4) & 0x10 )
  {
    v3 = *(_DWORD *)this;
    v4 = v3 + sub_10013260(this);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_1020CF70)(v3, 160, &v7);
    v5 = *(_WORD *)(v1 + 4);
    v6 = (char *)&v7;
    if ( v5 & 1 )
    {
      v4 += v7;
      v6 = (char *)&v7 + (unsigned __int16)word_1020D6C2;
    }
    if ( v5 & 2 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_1020D6C2;
    }
    if ( v5 & 4 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_1020D6C2;
    }
    if ( v5 & 8 )
      v4 += *(_WORD *)v6;
    result = v4;
  }
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;
// 1020D6C2: using guessed type __int16 word_1020D6C2;

//----- (10013350) --------------------------------------------------------
signed int __usercall sub_10013350@<eax>(int a1@<edi>)
{
  signed int result; // eax@1
  int v2; // ebx@2
  int v3; // esi@2
  __int16 v4; // ax@2
  char *v5; // ecx@2
  unsigned __int16 v6; // [sp+0h] [bp-A4h]@2

  result = 0xFFFFFF;
  if ( *(_BYTE *)(a1 + 4) & 4 )
  {
    v2 = *(_DWORD *)a1;
    v3 = v2 + sub_10013260(a1);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_1020CF70)(v2, 160, &v6);
    v4 = *(_WORD *)(a1 + 4);
    v5 = (char *)&v6;
    if ( v4 & 1 )
    {
      v3 += v6;
      v5 = (char *)&v6 + (unsigned __int16)word_1020D6C2;
    }
    if ( v4 & 2 )
      v3 += *(_WORD *)v5;
    result = v3;
  }
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;
// 1020D6C2: using guessed type __int16 word_1020D6C2;

//----- (100133E0) --------------------------------------------------------
signed int __thiscall sub_100133E0(int this)
{
  int v1; // edi@1
  signed int result; // eax@1
  int v3; // ebx@2
  int v4; // esi@2
  __int16 v5; // cx@2
  char *v6; // eax@2
  unsigned __int16 v7; // [sp+4h] [bp-A4h]@2

  v1 = this;
  result = 0xFFFFFF;
  if ( *(_BYTE *)(this + 4) & 8 )
  {
    v3 = *(_DWORD *)this;
    v4 = v3 + sub_10013260(this);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_1020CF70)(v3, 160, &v7);
    v5 = *(_WORD *)(v1 + 4);
    v6 = (char *)&v7;
    if ( v5 & 1 )
    {
      v4 += v7;
      v6 = (char *)&v7 + (unsigned __int16)word_1020D6C2;
    }
    if ( v5 & 2 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_1020D6C2;
    }
    if ( v5 & 4 )
      v4 += *(_WORD *)v6;
    result = v4;
  }
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;
// 1020D6C2: using guessed type __int16 word_1020D6C2;

//----- (10013480) --------------------------------------------------------
int __usercall sub_10013480@<eax>(int a1@<esi>)
{
  int result; // eax@1

  result = 0xFFFFFF;
  if ( *(_BYTE *)(a1 + 4) & 1 )
    result = *(_DWORD *)a1 + sub_10013260(a1);
  return result;
}

//----- (100134A0) --------------------------------------------------------
char __usercall sub_100134A0@<al>(unsigned int a1@<eax>, unsigned int *a2@<ebx>, _BYTE *a3@<edi>, int a4@<esi>, _DWORD *a5, int *a6)
{
  int *v6; // ebp@1

  v6 = a6;
  *a6 = 1000;
  *(_BYTE *)a1 = 95;
  *a2 = 1000;
  *a3 = 95;
  if ( *(_BYTE *)(a4 + 3) & 0x1F )
  {
    *v6 = *(_BYTE *)(a4 + 3) & 0x1F;
    *(_BYTE *)a1 = byte_1005386C[((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7];
    *a2 = (*(_BYTE *)(a4 + 3) & 0x1F) + 18;
    a1 = ((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7;
    *a3 = byte_10053864[a1];
  }
  if ( *(_BYTE *)(a4 + 5) & 4 )
  {
    (*(void (__cdecl **)(_DWORD, signed int, int **))dword_1020CF70)(*a5, 1, &a6);
    *a5 += (unsigned __int16)word_1020D6C6;
    LOBYTE(a1) = (_BYTE)a6;
    if ( (unsigned __int8)a6 & 0x1F )
    {
      a1 = ((unsigned __int8)a6 & 0x1F) + 18;
      *a2 = a1;
      *a3 = byte_10053864[((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7];
    }
    else
    {
      *a2 = 1000;
      *a3 = 95;
    }
  }
  return a1;
}
// 1020CF70: using guessed type int dword_1020CF70;
// 1020D6C6: using guessed type __int16 word_1020D6C6;

//----- (10013560) --------------------------------------------------------
void *__usercall sub_10013560@<eax>(int a1@<eax>, char *a2@<esi>)
{
  int v2; // ST0C_4@2
  int v3; // eax@2
  void *result; // eax@2

  if ( *(_WORD *)(a1 + 10) & 0x8000 )
  {
    LOWORD(v2) = *(_WORD *)(a1 + 22);
    HIWORD(v2) = (*(_DWORD *)(a1 + 16) >> 25) & 0x7F;
    v3 = v2 + dword_1020D024;
    *(_DWORD *)a2 = v2 + dword_1020D024;
    result = (void *)(*(int (__cdecl **)(int, signed int, char *, int))dword_1020CF70)(v3, 2, a2 + 4, v2);
    *(_DWORD *)a2 += (unsigned __int16)word_1020D028;
  }
  else
  {
    result = memcpy_0(a2, &unk_10053874, 6u);
  }
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;
// 1020D024: using guessed type int dword_1020D024;
// 1020D028: using guessed type __int16 word_1020D028;

//----- (100135C0) --------------------------------------------------------
__int16 __usercall sub_100135C0@<ax>(int a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // edi@1
  int v4; // eax@1
  int v5; // edi@2
  int v6; // ecx@6
  int v7; // edx@10
  char v8; // cl@10
  unsigned int v9; // eax@10
  int v10; // edx@16
  int v12; // [sp+0h] [bp-20h]@0
  __int16 v13; // [sp+Ch] [bp-14h]@2
  __int16 v14; // [sp+Eh] [bp-12h]@6
  int v15; // [sp+10h] [bp-10h]@2

  v3 = a1;
  sub_10012EE0(a3 & 0x3FFFF, v12);
  *(_DWORD *)a2 >>= 7;
  *(_DWORD *)(a2 + 4) >>= 7;
  LOWORD(v4) = HIWORD(a3) >> 10;
  if ( HIWORD(a3) >> 10 != 5 )
  {
    if ( (_WORD)v4 == 6 )
    {
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_1020CF70)(v3, 9, &v13);
      v7 = *(_DWORD *)a2 - 16 * v14;
      v8 = v15;
      v9 = (unsigned int)(unsigned __int8)v15 >> 4;
    }
    else
    {
      if ( (_WORD)v4 == 7 )
      {
        (*(void (__cdecl **)(int, signed int, __int16 *))dword_1020CF70)(v3, 11, &v13);
      }
      else
      {
        if ( (_WORD)v4 != 8 )
          return v4;
        (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_1020CF70)(v3, 15, &v13);
      }
      v7 = *(_DWORD *)a2 - 16 * v14;
      v8 = v15;
      v9 = (unsigned __int8)v15 >> 4;
    }
    *(_DWORD *)a2 = (v7 - (v8 & 0xF)) << 7;
    v10 = *(_DWORD *)(a2 + 4) - v9;
    v4 = 16 * v13;
    *(_DWORD *)(a2 + 4) = (v10 - v4) << 7;
    return v4;
  }
  (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_1020CF70)(v3, 7, &v13);
  LOWORD(v4) = v15;
  v5 = (unsigned __int16)word_1020D6C4 + v3;
  if ( BYTE1(v15) & 8 )
  {
    if ( BYTE1(v15) & 4 )
      v5 += (unsigned __int16)word_1020D6C6;
    (*(void (__cdecl **)(int, signed int, __int16 *))dword_1020CF70)(v5, 19, &v13);
    if ( (HIWORD(a3) & 0x3FCu) > 0x1FC )
    {
      v4 = (signed __int16)v15;
      *(_DWORD *)a2 -= SHIWORD(v15);
      *(_DWORD *)(a2 + 4) -= v4;
      *(_DWORD *)a2 <<= 7;
      *(_DWORD *)(a2 + 4) <<= 7;
    }
    else
    {
      LOWORD(v4) = v14;
      v6 = v13;
      *(_DWORD *)a2 -= v14;
      *(_DWORD *)(a2 + 4) -= v6;
      *(_DWORD *)a2 <<= 7;
      *(_DWORD *)(a2 + 4) <<= 7;
    }
  }
  else
  {
    *(_DWORD *)a2 = 0x7FFFFFFF;
    *(_DWORD *)(a2 + 4) = 0x7FFFFFFF;
  }
  return v4;
}
// 1020CF70: using guessed type int dword_1020CF70;
// 1020D6C4: using guessed type __int16 word_1020D6C4;
// 1020D6C6: using guessed type __int16 word_1020D6C6;

//----- (10013730) --------------------------------------------------------
void *__cdecl sub_10013730(unsigned int a1, char *a2)
{
  int v2; // eax@2
  __int64 v4; // [sp-4h] [bp-24h]@0
  char v5; // [sp+4h] [bp-1Ch]@2
  __int16 v6; // [sp+Eh] [bp-12h]@1

  v6 &= 0x7FFFu;
  LODWORD(v4) = a1;
  if ( !sub_100131C0(v4) )
  {
    v2 = sub_10013190(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_1020CF70)(v2, 28, &v5);
  }
  return sub_10013560((int)&v5, a2);
}
// 1020CF70: using guessed type int dword_1020CF70;

//----- (10013780) --------------------------------------------------------
signed int __cdecl sub_10013780(unsigned __int8 a1)
{
  int v1; // ecx@0
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-10h]@3
  int v6; // [sp+Eh] [bp-6h]@3

  result = sub_100132A0(v1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a1 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_1020CF70)(v3, 15, &v5);
        if ( !(v6 & 0x400) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_1020D6CC;
        if ( v6 & 0x200 )
          v3 += (unsigned __int16)word_1020D6CE;
        if ( v4 >= a1 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;
// 1020D6CC: using guessed type __int16 word_1020D6CC;
// 1020D6CE: using guessed type __int16 word_1020D6CE;

//----- (10013800) --------------------------------------------------------
signed int __usercall sub_10013800@<eax>(int a1@<edi>, unsigned __int8 a2)
{
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-Ch]@3
  char v6; // [sp+9h] [bp-7h]@3

  result = sub_10013350(a1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a2 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_1020CF70)(v3, 9, &v5);
        if ( !(v6 & 1) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_1020D6E4;
        if ( v4 >= a2 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;
// 1020D6E4: using guessed type __int16 word_1020D6E4;

//----- (10013870) --------------------------------------------------------
signed int __cdecl sub_10013870(unsigned __int8 a1)
{
  int v1; // ecx@0
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-Ch]@3
  int v6; // [sp+Ch] [bp-4h]@3

  result = sub_100133E0(v1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a1 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_1020CF70)(v3, 11, &v5);
        if ( !(v6 & 0x8000) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_1020D6E6;
        if ( v4 >= a1 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;
// 1020D6E6: using guessed type __int16 word_1020D6E6;

//----- (100138E0) --------------------------------------------------------
int __usercall sub_100138E0@<eax>(int a1@<eax>, char a2)
{
  int result; // eax@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // [sp+4h] [bp-8h]@3
  char v6; // [sp+6h] [bp-6h]@3
  char v7; // [sp+9h] [bp-3h]@4

  result = sub_10013480(a1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a2 > 0 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(int, signed int, char *))dword_1020CF70)(v3, 7, &v5);
        if ( !(v6 & 0x80) )
          break;
        v3 += (unsigned __int16)word_1020D6C4;
        ++v4;
        if ( v7 & 4 )
          v3 += (unsigned __int16)word_1020D6C6;
        if ( v7 & 8 )
          v3 += (unsigned __int16)word_1020D6C8;
        if ( v7 & 0x10 )
          v3 += (unsigned __int16)word_1020D6CA;
        if ( v4 >= a2 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;
// 1020D6C4: using guessed type __int16 word_1020D6C4;
// 1020D6C6: using guessed type __int16 word_1020D6C6;
// 1020D6C8: using guessed type __int16 word_1020D6C8;
// 1020D6CA: using guessed type __int16 word_1020D6CA;

//----- (10013970) --------------------------------------------------------
void __usercall sub_10013970(int a1@<edi>, int a2, int a3)
{
  int v3; // [sp+4h] [bp-8h]@1
  int v4; // [sp+8h] [bp-4h]@1

  sub_100135C0(a3, (int)&v3, a2);
  *(double *)a1 = sub_1001EE80(v3, 24);
  *(double *)(a1 + 8) = sub_1001EE80(v4, 24);
}

//----- (100139B0) --------------------------------------------------------
int __cdecl sub_100139B0(__int64 a1)
{
  int result; // eax@2
  char v2; // [sp+0h] [bp-8h]@1

  sub_10013730(a1 & 0x3FFFF, &v2);
  switch ( (unsigned int)WORD1(a1) >> 10 )
  {
    case 5u:
      result = sub_100138E0((int)&v2, (*(_DWORD *)((char *)&a1 + 2) >> 2) & 0x7F);
      break;
    case 6u:
      result = sub_10013800((int)&v2, *(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    case 7u:
      result = sub_10013870(*(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    case 8u:
      result = sub_10013780(*(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    default:
      result = 0xFFFFFF;
      break;
  }
  return result;
}

//----- (10013A60) --------------------------------------------------------
double __cdecl sub_10013A60(int a1)
{
  __int64 v1; // ST08_8@1
  int v2; // eax@1
  float v4; // [sp+0h] [bp-14h]@1
  char v5; // [sp+4h] [bp-10h]@2
  __int16 v6; // [sp+Eh] [bp-6h]@2

  LODWORD(v1) = a1;
  *((float *)&v1 + 1) = 6.2831855;
  v2 = sub_100139B0(v1);
  if ( v2 != 0xFFFFFF )
  {
    (*(void (__cdecl **)(int, signed int, char *))dword_1020CF70)(v2, 15, &v5);
    v4 = (double)(signed __int16)((signed __int16)(v6 << 7) >> 7) * 0.01745329238474369 * 0.5;
  }
  return v4;
}
// 1020CF70: using guessed type int dword_1020CF70;

//----- (10013AD0) --------------------------------------------------------
int __cdecl sub_10013AD0(int a1, int a2)
{
  int result; // eax@1
  int v3; // esi@1
  __int16 v4; // ax@2
  signed int v5; // eax@4
  char v6; // bl@4
  __int64 v7; // [sp-4h] [bp-58h]@0
  char v8; // [sp+Eh] [bp-46h]@3
  char v9; // [sp+Fh] [bp-45h]@3
  int v10; // [sp+10h] [bp-44h]@3
  int v11; // [sp+14h] [bp-40h]@3
  int v12; // [sp+18h] [bp-3Ch]@3
  char v13; // [sp+1Ch] [bp-38h]@3
  char v14; // [sp+23h] [bp-31h]@12
  char v15; // [sp+24h] [bp-30h]@10

  *(_DWORD *)a2 = 1600085855;
  *(_WORD *)(a2 + 4) = 24415;
  LODWORD(v7) = a1;
  *(_BYTE *)(a2 + 6) = 0;
  result = sub_100139B0(v7);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = HIWORD(a1) >> 10;
    if ( HIWORD(a1) >> 10 == 5 )
    {
      (*(void (__cdecl **)(int, signed int, char *))dword_1020CF70)(v3, 12, &v13);
      v10 = (unsigned __int16)word_1020D6C4 + v3;
      sub_100134A0((unsigned int)&v9, (unsigned int *)&v12, &v8, (int)&v13, &v10, &v11);
      if ( (HIWORD(a1) & 0x3FCu) <= 0x1FC )
      {
        v6 = v9;
        v5 = v11;
      }
      else
      {
        v5 = v12;
        v6 = v8;
      }
      *(_BYTE *)a2 = 82;
      *(_BYTE *)(a2 + 1) = 87;
      if ( sub_10015220(v5, 2, (_BYTE *)(a2 + 2)) )
      {
        *(_BYTE *)(a2 + 4) = v6;
        *(_BYTE *)(a2 + 6) = 0;
      }
      else
      {
        *(_DWORD *)(a2 + 2) = 1600085855;
        *(_BYTE *)(a2 + 6) = 0;
      }
    }
    else if ( v4 == 6 )
    {
      (*(void (__cdecl **)(int, signed int, char *))dword_1020CF70)(v3, 9, &v13);
      sub_10012390(&v15, 5, a2);
      *(_BYTE *)(a2 + 5) = 0;
    }
    else if ( v4 == 7 )
    {
      (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_1020CF70)(v3, 11, &v13);
      sub_10012390(&v14, 3, a2);
      *(_BYTE *)(a2 + 3) = 0;
    }
    else
    {
      (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_1020CF70)(v3, 15, &v13);
      sub_10012390(&v14, 4, a2);
      *(_BYTE *)(a2 + 4) = 0;
    }
    result = sub_10015420(a2, 0);
  }
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;
// 1020D6C4: using guessed type __int16 word_1020D6C4;

//----- (10013C60) --------------------------------------------------------
char __cdecl sub_10013C60(int a1, int a2)
{
  char v2; // bl@1
  int v3; // ebp@1
  int v4; // eax@2
  __int64 v6; // [sp-4h] [bp-30h]@0
  char v7; // [sp+10h] [bp-1Ch]@2
  unsigned int v8; // [sp+14h] [bp-18h]@2

  *(double *)a2 = 6.2831853071796;
  LODWORD(v6) = a1;
  *(double *)(a2 + 8) = 6.2831853071796;
  v2 = 0;
  v3 = sub_100139B0(v6);
  if ( v3 != 0xFFFFFF )
  {
    v4 = sub_10013190(a1 & 0x3FFFF);
    (*(void (__cdecl **)(int, signed int, char *))dword_1020CF70)(v4, 28, &v7);
    v2 = (v8 >> 29) & 1;
    sub_10013970(a2, a1, v3);
  }
  return v2;
}
// 1020CF70: using guessed type int dword_1020CF70;

//----- (10013CD0) --------------------------------------------------------
__int16 __cdecl sub_10013CD0(int a1, int a2)
{
  int v2; // eax@1
  __int64 v4; // [sp-4h] [bp-Ch]@0

  LODWORD(v4) = a1;
  *(_DWORD *)a2 = 2147483648;
  *(_DWORD *)(a2 + 4) = 2147483648;
  v2 = sub_100139B0(v4);
  if ( v2 != 0xFFFFFF )
    LOWORD(v2) = sub_100135C0(v2, a2, a1);
  return v2;
}

//----- (10013D10) --------------------------------------------------------
int sub_10013D10()
{
  int result; // eax@2
  unsigned __int8 v1; // [sp+0h] [bp-Ch]@4
  int v2; // [sp+2h] [bp-Ah]@4
  int v3; // [sp+6h] [bp-6h]@4

  if ( sub_1001EEC0(0x4Du, 1u) )
  {
    result = dword_1020D33C;
    dword_101474F0 = dword_1020D33C;
    if ( dword_1020D33C )
    {
      (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_1020CF70)(dword_1020D33C, 8, &v1);
      word_101474E8 = v1;
      result = v3 & 0x1FF;
      dword_101474F0 += (unsigned __int16)word_1020D340;
      word_101474EC = v2 & 0x1FF;
      word_101474E4 = v3 & 0x1FF;
    }
  }
  else
  {
    word_101474E8 = 6;
    word_101474EC = 6;
    result = dword_1020D1BC;
    word_101474E4 = 60;
    dword_101474F0 = dword_1020D1BC;
  }
  return result;
}
// 101474E4: using guessed type __int16 word_101474E4;
// 101474E8: using guessed type __int16 word_101474E8;
// 101474EC: using guessed type __int16 word_101474EC;
// 101474F0: using guessed type int dword_101474F0;
// 1020CF70: using guessed type int dword_1020CF70;
// 1020D1BC: using guessed type int dword_1020D1BC;
// 1020D33C: using guessed type int dword_1020D33C;
// 1020D340: using guessed type __int16 word_1020D340;

//----- (10013DB0) --------------------------------------------------------
char __cdecl sub_10013DB0(float *a1)
{
  int v1; // ecx@0
  int v2; // esi@1
  char v3; // bl@1
  char v4; // al@1
  float v5; // ST44_4@4
  double v6; // st6@4
  signed __int16 v7; // si@4
  signed int v8; // eax@4
  signed __int16 v9; // di@4
  float v10; // ST44_4@7
  __int16 v11; // cx@8
  __int16 v12; // ax@8
  signed int v13; // edi@8
  __int16 v14; // bp@8
  int v15; // esi@8
  __int16 v16; // bx@8
  signed int v17; // esi@8
  int *v18; // edi@8
  signed int v19; // ecx@10
  __int64 v20; // rax@11
  __int16 v21; // si@16
  float v23; // [sp+Ch] [bp-1Ch]@8
  float v24; // [sp+10h] [bp-18h]@4
  float v25; // [sp+10h] [bp-18h]@8
  int v26; // [sp+18h] [bp-10h]@8
  int v27; // [sp+1Ch] [bp-Ch]@8

  *a1 = 0.0;
  v2 = v1;
  v3 = 0;
  v4 = sub_1001F520(v1, 0);
  if ( dword_101474F0 && v4 && sub_1001EEC0(0, 0x2Du) )
  {
    v24 = (*(float *)v2 + 1.570796370506287) * 57.29578018188477;
    v5 = 57.29578018188477 * (*(float *)(v2 + 4) + 3.141592741012573);
    v6 = v5;
    v7 = (signed int)v24;
    v8 = (signed int)v5;
    v9 = v8;
    if ( v7 > 179 )
      v7 = 179;
    if ( v9 >= 360 )
    {
      v9 = v8 - 360;
      v10 = v6 - 360.0;
      v6 = v10;
    }
    v11 = v7 / word_101474E8;
    v12 = v9 / word_101474EC;
    v13 = (signed __int16)(v7 / word_101474E8);
    v14 = v7 / word_101474E8 + 1;
    v23 = v24 / (double)word_101474E8 - (double)v13;
    v15 = v12;
    v25 = v6 / (double)word_101474EC - (double)v12;
    v16 = (v12 + 1) % word_101474E4;
    (*(void (__cdecl **)(int, signed int, int *))dword_1020CF70)(
      dword_101474F0 + (unsigned __int16)word_1020D1C0 * (v12 + v11 * word_101474E4),
      2,
      &v26);
    (*(void (__cdecl **)(int, signed int, char *))dword_1020CF70)(
      dword_101474F0 + (unsigned __int16)word_1020D1C0 * (v16 + v13 * word_101474E4),
      2,
      (char *)&v26 + 2);
    (*(void (__cdecl **)(int, signed int, int *))dword_1020CF70)(
      dword_101474F0 + (unsigned __int16)word_1020D1C0 * (v15 + v14 * word_101474E4),
      2,
      &v27);
    (*(void (__cdecl **)(int, _DWORD, char *))dword_1020CF70)(
      dword_101474F0 + (unsigned __int16)word_1020D1C0 * (v16 + v14 * word_101474E4),
      2,
      (char *)&v27 + 2);
    v3 = 1;
    v17 = 1;
    v18 = &v26;
    do
    {
      if ( !v3 )
        break;
      v19 = v17;
      if ( v17 < 4 )
      {
        while ( 1 )
        {
          v20 = (signed __int16)(*(_WORD *)v18 - *((_WORD *)&v26 + v19));
          if ( (signed int)((HIDWORD(v20) ^ v20) - HIDWORD(v20)) > 1820 )
            break;
          if ( ++v19 >= 4 )
            goto LABEL_15;
        }
        v3 = 0;
      }
LABEL_15:
      ++v17;
      v18 = (int *)((char *)v18 + 2);
    }
    while ( v17 - 1 < 3 );
    v21 = v26 + (signed int)((double)(signed __int16)(v27 - v26) * v23);
    *a1 = (double)(signed __int16)(v21
                                 + (signed int)((double)(signed __int16)(HIWORD(v26)
                                                                       + (signed int)(v23
                                                                                    * (double)(signed __int16)(HIWORD(v27) - HIWORD(v26)))
                                                                       - v21)
                                              * v25))
        * 0.0000958738019107841;
  }
  return v3;
}
// 101474E4: using guessed type __int16 word_101474E4;
// 101474E8: using guessed type __int16 word_101474E8;
// 101474EC: using guessed type __int16 word_101474EC;
// 101474F0: using guessed type int dword_101474F0;
// 1020CF70: using guessed type int dword_1020CF70;
// 1020D1C0: using guessed type __int16 word_1020D1C0;

//----- (10014070) --------------------------------------------------------
char __cdecl sub_10014070(int a1, float *a2)
{
  return sub_10013DB0(a2);
}

//----- (10014090) --------------------------------------------------------
double __cdecl sub_10014090(unsigned int a1)
{
  int v1; // eax@2
  __int64 v3; // [sp-4h] [bp-44h]@0
  float v4; // [sp+4h] [bp-3Ch]@1
  char v5; // [sp+8h] [bp-38h]@5
  char v6; // [sp+10h] [bp-30h]@5
  char v7; // [sp+20h] [bp-20h]@2
  unsigned int v8; // [sp+24h] [bp-1Ch]@2
  int v9; // [sp+2Eh] [bp-12h]@4

  v4 = 6.2831855;
  LODWORD(v3) = a1;
  if ( sub_100131C0(v3) == 3 )
  {
    v1 = sub_10013190(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_1020CF70)(v1, 29, &v7);
    if ( v8 >> 29 != 2 && v8 >> 29 != 6 )
      return (float)((double)(v9 >> 23) * 0.01745329238474369 * 0.5);
    sub_10012FC0(a1, (int)&v6);
    sub_10032510((int)&v6, (int)&v5);
    sub_10014070((int)&v5, &v4);
  }
  return v4;
}
// 1020CF70: using guessed type int dword_1020CF70;

//----- (10014140) --------------------------------------------------------
char *__cdecl sub_10014140(unsigned __int8 a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *result; // eax@1
  signed int v4; // ebp@1
  int v5; // esi@1
  int v6; // edi@1
  int v7; // esi@2
  char v8; // cl@4
  int v9; // ecx@8
  int v10; // [sp+10h] [bp-28h]@2
  int v11; // [sp+14h] [bp-24h]@1
  char v12[28]; // [sp+18h] [bp-20h]@2

  v2 = dword_1020CFA0[3 * a1];
  result = (char *)(12 * a1);
  v4 = *(_DWORD *)&result[(_DWORD)dword_1020CFA8];
  v5 = v1;
  v6 = *(_WORD *)&result[(_DWORD)word_1020CFA4];
  v11 = v1;
  if ( v4 > 0 )
  {
    v7 = v1 - (_DWORD)v12;
    v10 = *(_DWORD *)&result[(_DWORD)dword_1020CFA8];
    do
    {
      (*(void (__cdecl **)(int, int, char *))dword_1020CF70)(v2, v6, v12);
      v12[v6] = 0;
      result = v12;
      do
      {
        v8 = *result;
        result[v7] = *result;
        ++result;
      }
      while ( v8 );
      v2 += v6;
      v7 += 25;
      --v10;
    }
    while ( v10 );
    v5 = v11;
  }
  if ( v4 < 64 )
  {
    result = (char *)(v5 + 25 * v4);
    v9 = 64 - v4;
    do
    {
      *result = 0;
      result += 25;
      --v9;
    }
    while ( v9 );
  }
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;
// 1020CFA0: using guessed type int dword_1020CFA0[];
// 1020CFA4: using guessed type __int16 word_1020CFA4[];
// 1020CFA8: using guessed type int dword_1020CFA8[];
// 10014140: using guessed type char var_20[28];

//----- (10014200) --------------------------------------------------------
signed int sub_10014200()
{
  signed int result; // eax@1

  result = 0xFFFFFF;
  byte_1020CF74 = 0;
  dword_1020CF78 = 0xFFFFFF;
  byte_1020CF64 = 0;
  dword_1020CF68 = 0xFFFFFF;
  return result;
}
// 1020CF64: using guessed type char byte_1020CF64;
// 1020CF68: using guessed type int dword_1020CF68;
// 1020CF74: using guessed type char byte_1020CF74;
// 1020CF78: using guessed type int dword_1020CF78;

//----- (10014220) --------------------------------------------------------
int sub_10014220()
{
  int result; // eax@1

  result = (*(int (**)(void))(dword_1020CF70 + 16))();
  byte_1020CF6C = (_BYTE)result == 0;
  return result;
}
// 1020CF6C: using guessed type char byte_1020CF6C;
// 1020CF70: using guessed type int dword_1020CF70;

//----- (10014280) --------------------------------------------------------
int sub_10014280()
{
  int result; // eax@1

  *(_DWORD *)(dword_1020D7F0 + 20812) = 1000;
  *(_DWORD *)(dword_1020D7F0 + 20816) = dword_1020D008 + *(_DWORD *)(dword_1020D7F0 + 20812);
  *(_DWORD *)(dword_1020D7F0 + 20820) = dword_1020D068 + *(_DWORD *)(dword_1020D7F0 + 20816);
  *(_DWORD *)(dword_1020D7F0 + 20824) = dword_1020D098 + *(_DWORD *)(dword_1020D7F0 + 20820);
  result = dword_1020D7F0;
  *(_DWORD *)(dword_1020D7F0 + 20828) = dword_1020D0E0 + *(_DWORD *)(dword_1020D7F0 + 20824);
  return result;
}
// 1020D008: using guessed type int dword_1020D008;
// 1020D068: using guessed type int dword_1020D068;
// 1020D098: using guessed type int dword_1020D098;
// 1020D0E0: using guessed type int dword_1020D0E0;
// 1020D7F0: using guessed type int dword_1020D7F0;

//----- (100142F0) --------------------------------------------------------
char *sub_100142F0()
{
  sub_10014140(0x40u);
  sub_10014140(0x39u);
  sub_10014140(0x33u);
  sub_10014140(0x31u);
  sub_10014140(0x32u);
  sub_10014140(0x4Eu);
  sub_10014140(0x4Fu);
  sub_10014140(0x3Du);
  sub_10014140(0x3Eu);
  sub_10014140(0x45u);
  return sub_10014140(0x38u);
}
// 1020D7F0: using guessed type int dword_1020D7F0;

//----- (100143C0) --------------------------------------------------------
int __cdecl sub_100143C0(const void *a1)
{
  int result; // eax@1

  qmemcpy(dword_101474F8, a1, 0x1Cu);
  dword_1020CF70 = (int)dword_101474F8;
  dword_1020D7F0 = (int)&unk_10147518;
  memset(&unk_10147518, 0, 0x516Cu);
  dword_101474F8[5](dword_1020D7F0 + 20832, dword_1020D7F0 + 20833, dword_1020D7F0 + 20836);
  (*(void (__cdecl **)(int))(dword_1020CF70 + 24))(dword_1020D7F0 + 20840);
  sub_1001ED30();
  sub_1001E9C0();
  sub_1001EB70();
  sub_1001EA90();
  sub_100142F0();
  sub_10014200();
  sub_100149D0();
  sub_10013D10();
  sub_10014220();
  sub_10014280();
  *(_DWORD *)(dword_1020D7F0 + 20800) = 0;
  *(_DWORD *)(dword_1020D7F0 + 20804) = dword_1020D188;
  result = dword_1020D7F0;
  *(_DWORD *)(dword_1020D7F0 + 20808) = dword_1020D194 + *(_DWORD *)(dword_1020D7F0 + 20804);
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;
// 1020D188: using guessed type int dword_1020D188;
// 1020D194: using guessed type int dword_1020D194;
// 1020D7F0: using guessed type int dword_1020D7F0;

//----- (10014470) --------------------------------------------------------
void __cdecl sub_10014470(unsigned int a1, int a2)
{
  unsigned int v2; // ebx@3
  unsigned int v3; // ebp@4
  unsigned int v4; // eax@5
  int v5; // ecx@5
  int v6; // eax@6
  char v7; // dl@10
  char v8; // cl@10
  char v9; // al@10
  char v10; // cl@11
  char v11; // dl@11
  char v12; // dl@13
  char v13; // cl@13
  char v14; // al@13
  char v15; // cl@14
  char v16; // dl@14
  char v17; // cl@14
  char v18; // [sp+4h] [bp-10h]@5
  char v19; // [sp+5h] [bp-Fh]@10
  char v20; // [sp+6h] [bp-Eh]@10
  char v21; // [sp+8h] [bp-Ch]@5
  char v22; // [sp+Ah] [bp-Ah]@10
  char v23; // [sp+Bh] [bp-9h]@10

  if ( a2 )
  {
    if ( (a1 & 0xFC000000) != 805306368 || (v2 = a1 & 0x1FF, v2 > 0x168) || (v3 = (a1 >> 9) & 0x1FF, v3 > 0x168) )
    {
      *(_DWORD *)a2 = 1600085855;
      *(_WORD *)(a2 + 4) = 24415;
      *(_BYTE *)(a2 + 6) = 0;
    }
    else
    {
      sub_100153B0(&v18, 4u, "%+03d", (signed int)(v2 - 180) / 2);
      sub_100153B0(&v21, 5u, "%+04d", v3 - 180);
      v4 = (v3 - 180) >> 31;
      v5 = (v3 - 180 - v4) ^ ((signed int)(v3 - 180 - v4) >> 31);
      if ( v2 < 0xB4 )
      {
        LOBYTE(v4) = v3 < 0xB4;
        v6 = 4 * v4 + 83;
      }
      else
      {
        LOBYTE(v6) = v3 < 0xB4 ? 78 : 69;
      }
      *(_BYTE *)(a2 + 5) = 0;
      if ( a1 & 1 )
      {
        if ( v5 >= 100 )
        {
          v10 = v22;
          *(_BYTE *)a2 = v19;
          v11 = v23;
          *(_BYTE *)(a2 + 1) = v6;
          *(_BYTE *)(a2 + 2) = v20;
          *(_BYTE *)(a2 + 3) = v10;
          *(_BYTE *)(a2 + 4) = v11;
        }
        else
        {
          v7 = v20;
          *(_BYTE *)(a2 + 1) = v19;
          v8 = v23;
          *(_BYTE *)a2 = v6;
          v9 = v22;
          *(_BYTE *)(a2 + 2) = v7;
          *(_BYTE *)(a2 + 3) = v9;
          *(_BYTE *)(a2 + 4) = v8;
        }
      }
      else if ( v5 < 100 )
      {
        v15 = v20;
        *(_BYTE *)a2 = v19;
        v16 = v22;
        *(_BYTE *)(a2 + 1) = v15;
        v17 = v23;
        *(_BYTE *)(a2 + 2) = v16;
        *(_BYTE *)(a2 + 3) = v17;
        *(_BYTE *)(a2 + 4) = v6;
      }
      else
      {
        v12 = v20;
        *(_BYTE *)a2 = v19;
        v13 = v23;
        *(_BYTE *)(a2 + 2) = v6;
        v14 = v22;
        *(_BYTE *)(a2 + 1) = v12;
        *(_BYTE *)(a2 + 3) = v14;
        *(_BYTE *)(a2 + 4) = v13;
      }
    }
  }
}

//----- (10014650) --------------------------------------------------------
char __cdecl sub_10014650(unsigned int a1, int a2)
{
  char result; // al@1
  unsigned int v3; // edx@3
  unsigned int v4; // ecx@4

  result = 0;
  if ( a2 )
  {
    if ( (a1 & 0xFC000000) == 805306368 )
    {
      v3 = a1 & 0x1FF;
      if ( v3 <= 0x168 )
      {
        v4 = (a1 >> 9) & 0x1FF;
        if ( v4 <= 0x168 )
        {
          *(_DWORD *)a2 = (signed int)(11930464 * (v3 - 180)) / 2;
          *(_DWORD *)(a2 + 4) = 11930464 * (v4 - 180);
          result = 1;
        }
      }
    }
  }
  return result;
}

//----- (100146C0) --------------------------------------------------------
int __cdecl sub_100146C0(_BYTE *a1, _BYTE *a2)
{
  int result; // eax@1

  result = sub_1001EF00(0x2Bu);
  *a1 = result;
  if ( (_BYTE)result )
  {
    result = (int)a2;
    *a2 = 1;
  }
  else
  {
    *a2 = 0;
    *a1 = 1;
  }
  return result;
}

//----- (100146F0) --------------------------------------------------------
int sub_100146F0()
{
  return (*(int (**)(void))(dword_1020CF70 + 8))();
}
// 1020CF70: using guessed type int dword_1020CF70;

//----- (10014700) --------------------------------------------------------
int __fastcall sub_10014700(unsigned __int8 a1)
{
  return dword_1020D1A4 + a1 * (unsigned __int16)word_1020D1A8;
}
// 1020D1A4: using guessed type int dword_1020D1A4;
// 1020D1A8: using guessed type __int16 word_1020D1A8;

//----- (10014720) --------------------------------------------------------
int __fastcall sub_10014720(unsigned __int8 a1)
{
  return dword_1020D1B0 + a1 * (unsigned __int16)word_1020D1B4;
}
// 1020D1B0: using guessed type int dword_1020D1B0;
// 1020D1B4: using guessed type __int16 word_1020D1B4;

//----- (10014740) --------------------------------------------------------
void *__cdecl sub_10014740(char a1, void *a2)
{
  void *result; // eax@2
  int v3; // eax@4
  int v4; // eax@4
  char v5; // [sp+6h] [bp-1Eh]@1
  unsigned __int8 v6; // [sp+7h] [bp-1Dh]@1
  char v7; // [sp+8h] [bp-1Ch]@4
  char v8; // [sp+16h] [bp-Eh]@4

  sub_100146C0(&v6, &v5);
  if ( (unsigned __int8)a1 < v6 )
  {
    if ( v5 )
    {
      v3 = sub_10014700(a1);
      v4 = (*(int (__cdecl **)(int, signed int, char *))dword_1020CF70)(v3, 22, &v7);
      result = (void *)sub_1001EAF0(v4, &v8, 20, (int)a2);
      *((_BYTE *)a2 + 20) = 0;
    }
    else
    {
      result = memcpy_0(a2, &aWgs84[21 * (unsigned __int8)a1], 0x14u);
      *((_BYTE *)a2 + 20) = 0;
    }
  }
  else
  {
    result = (void *)1600085855;
    *(_DWORD *)a2 = 1600085855;
    *((_DWORD *)a2 + 1) = 1600085855;
    *((_DWORD *)a2 + 2) = 1600085855;
    *((_DWORD *)a2 + 3) = 1600085855;
    *((_DWORD *)a2 + 4) = 1600085855;
    *((_BYTE *)a2 + 20) = 0;
  }
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;

//----- (10014810) --------------------------------------------------------
int __cdecl sub_10014810(int a1)
{
  bool v1; // zf@1
  int v2; // eax@2
  signed int v3; // eax@2
  float v4; // ST24_4@2
  unsigned __int8 v5; // cl@2
  int v6; // eax@2
  char v7; // al@2
  char v8; // cl@2
  float v9; // ST24_4@3
  double v10; // st6@3
  float v11; // ST24_4@3
  float v12; // ST24_4@3
  double v13; // st7@3
  float v14; // ST24_4@3
  float v16; // [sp+10h] [bp-34h]@2
  char v17; // [sp+14h] [bp-30h]@2
  char v18; // [sp+15h] [bp-2Fh]@2
  char v19; // [sp+16h] [bp-2Eh]@2
  char v20; // [sp+17h] [bp-2Dh]@2
  char v21; // [sp+26h] [bp-1Eh]@2
  char v22; // [sp+28h] [bp-1Ch]@2
  char v23; // [sp+36h] [bp-Eh]@2
  unsigned __int8 v24; // [sp+37h] [bp-Dh]@2
  __int16 v25; // [sp+38h] [bp-Ch]@2
  __int16 v26; // [sp+3Ah] [bp-Ah]@2
  __int16 v27; // [sp+3Ch] [bp-8h]@2

  *(float *)(a1 + 24) = 0.0;
  *(float *)(a1 + 28) = 0.0;
  *(float *)(a1 + 32) = 0.0;
  *(float *)(a1 + 36) = 6378137.0;
  *(float *)(a1 + 40) = 0.0033528106;
  *(_BYTE *)(a1 + 56) = 0;
  memcpy_0((void *)(a1 + 1), "WGS 84              ", 0x15u);
  v1 = *(_BYTE *)(a1 + 81) == 0;
  *(_BYTE *)(a1 + 80) = 1;
  if ( !v1 )
  {
    v2 = sub_10014700(*(_BYTE *)a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_1020CF70)(v2, 22, &v22);
    sub_1001EAF0((int)&v23, &v23, 20, a1 + 1);
    v3 = v27;
    LODWORD(v4) = v26;
    v5 = v24;
    *(float *)(a1 + 24) = (double)v25;
    *(_BYTE *)(a1 + 21) = 0;
    *(float *)(a1 + 28) = (double)SLODWORD(v4);
    *(float *)(a1 + 32) = (double)v3;
    v6 = sub_10014720(v5);
    (*(void (__cdecl **)(int, signed int, float *))dword_1020CF70)(v6, 23, &v16);
    v7 = v18;
    v8 = v19;
    LOBYTE(v4) = v17;
    *(float *)(a1 + 36) = v16;
    BYTE1(v4) = v7;
    BYTE2(v4) = v8;
    BYTE3(v4) = v20;
    *(float *)(a1 + 40) = v4;
    sub_1001EAF0((int)&v21, &v21, 20, a1 + 56);
    *(_BYTE *)(a1 + 76) = 0;
  }
  *(float *)(a1 + 44) = *(float *)(a1 + 40) + *(float *)(a1 + 40) - *(float *)(a1 + 40) * *(float *)(a1 + 40);
  v9 = *(float *)(a1 + 36) - 6378137.0;
  v10 = v9;
  *(float *)(a1 + 48) = v9;
  v11 = *(float *)(a1 + 40) - 0.003352810628712177;
  v12 = 6378137.0 * v11;
  v13 = v12;
  v14 = v10 * 0.00335281066474748;
  *(float *)(a1 + 52) = v13 + v14;
  return (*(int (__cdecl **)(int))(dword_1020CF70 + 12))(a1);
}
// 1020CF70: using guessed type int dword_1020CF70;

//----- (100149D0) --------------------------------------------------------
char sub_100149D0()
{
  int v0; // eax@1
  unsigned __int8 v1; // bl@1
  char v2; // al@7
  unsigned __int8 v3; // bl@10
  unsigned __int8 v5; // [sp+6h] [bp-76h]@1
  unsigned __int8 v6; // [sp+7h] [bp-75h]@1
  char v7[4]; // [sp+8h] [bp-74h]@1
  char v8; // [sp+Ch] [bp-70h]@10
  unsigned __int8 v9; // [sp+5Ch] [bp-20h]@5
  char v10; // [sp+5Dh] [bp-1Fh]@8
  char v11; // [sp+5Eh] [bp-1Eh]@6
  char v12; // [sp+60h] [bp-1Ch]@2

  sub_100146F0();
  sub_100146C0(&v6, &v5);
  LOBYTE(v0) = v6;
  v1 = 0;
  v5 = v6;
  v7[0] = 0;
  if ( v6 )
  {
    do
    {
      sub_10014740(v7[0], &v12);
      v0 = strcmp(&v12, "WGS 84              ");
      if ( !v0 )
        v5 = v1;
      v7[0] = ++v1;
    }
    while ( v1 < v6 );
  }
  if ( !v9 || v5 != v11 )
  {
    v2 = sub_1001EF00(0x2Bu);
    v9 = v2;
    if ( v2 )
    {
      v10 = 1;
    }
    else
    {
      v2 = 1;
      v10 = 0;
      v9 = 1;
    }
    v3 = 0;
    v8 = v2;
    v11 = v2;
    v7[0] = 0;
    if ( v2 )
    {
      do
      {
        sub_10014740(v7[0], &v12);
        if ( !strcmp(&v12, "WGS 84              ") )
        {
          v11 = v3;
          v8 = v3;
        }
        v7[0] = ++v3;
      }
      while ( v3 < v9 );
    }
    LOBYTE(v0) = sub_10014810((int)&v8);
  }
  return v0;
}

//----- (10014B30) --------------------------------------------------------
char *__cdecl sub_10014B30(int a1, char *a2, int a3, char *a4, int a5)
{
  char *v5; // edi@1
  char *result; // eax@4
  char v7[4]; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v5 = a2;
  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  *(_DWORD *)(a5 + 16) = sub_1002FFA0();
  *(_DWORD *)(a5 + 596) = sub_10030040();
  sub_10030060((int)v7, 1, *(_DWORD *)(a5 + 16), 40);
  *(_WORD *)(a5 + 594) = 0x7FFF;
  sub_10015290(a5 + 585, "14.01", 8);
  *(_DWORD *)a5 = a1;
  sub_10014FE0((char *)(a5 + 4));
  *(_DWORD *)(a5 + 460) = a3;
  if ( strrchr(a2, 92) )
    v5 = strrchr(a2, 92) + 1;
  strncpy((char *)(a5 + 464), v5, 0x14u);
  *(_BYTE *)(a5 + 484) = 0;
  if ( a4 )
  {
    result = strncpy((char *)(a5 + 485), a4, 0x63u);
    *(_BYTE *)(a5 + 584) = 0;
  }
  else
  {
    result = strncpy((char *)(a5 + 485), v7, 0x64u);
  }
  return result;
}

//----- (10014C60) --------------------------------------------------------
char sub_10014C60()
{
  char result; // al@1

  result = 0;
  byte_10151BF0 = 0;
  byte_10151BF1 = 0;
  return result;
}
// 10151BF0: using guessed type char byte_10151BF0;
// 10151BF1: using guessed type char byte_10151BF1;

//----- (10014C70) --------------------------------------------------------
char __cdecl sub_10014C70(char *a1, int a2, char a3, char *a4, int a5)
{
  char result; // al@7
  char v6; // [sp+Bh] [bp-2Dh]@4
  int v7; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( a3 & 3 )
    sub_10014B30(-5, a1, a2, a4, a5);
  else
    sub_10014B30(-44, a1, a2, a4, a5);
  v6 = a3 & 8;
  if ( a3 & 8 )
    sub_100153E0((const char *)(a5 + 485), " DBGA", 100);
  sub_10030060((int)&v7, 0, 0, 40);
  if ( a3 & 3 )
  {
    result = a3 & 8;
    if ( v6 )
    {
      if ( byte_10151BF0 )
        return result;
      if ( v6 )
        goto LABEL_15;
    }
    if ( !byte_10151BF1 )
LABEL_15:
      result = sub_100300F0(36, 1, *(_DWORD *)a5, a5);
  }
  else
  {
    result = j_HWM_pvg_log_err(a5);
  }
  return result;
}
// 10008120: using guessed type int __cdecl j_HWM_pvg_log_err(_DWORD);
// 10151BF0: using guessed type char byte_10151BF0;
// 10151BF1: using guessed type char byte_10151BF1;

//----- (10014D70) --------------------------------------------------------
char __cdecl sub_10014D70(char *a1, int a2, char a3, char *a4)
{
  int v5; // [sp+8h] [bp-284h]@1

  memset(&v5, 0, 0x280u);
  return sub_10014C70(a1, a2, a3, a4, (int)&v5);
}

//----- (10014DE0) --------------------------------------------------------
int __cdecl sub_10014DE0(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@6
  int v7; // ebx@6
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  _DWORD *v21; // esi@23
  unsigned int v22; // ecx@23
  _DWORD *v23; // edx@23
  int v24; // edi@27
  int v25; // ecx@28
  _BYTE *v26; // edx@28
  _BYTE *v27; // esi@28
  int v28; // ecx@30
  _BYTE *v29; // edx@30
  _BYTE *v30; // esi@30
  _BYTE *v31; // edx@32
  _BYTE *v32; // esi@32
  int v33; // edx@33
  signed int v34; // ecx@34
  int v35; // [sp+4h] [bp-4h]@6

  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && a5 > 0 )
  {
    result = a5 - 1;
    v7 = a3 + a4 * (a5 - 1);
    v35 = a5 - 1;
    if ( a5 - 1 > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v35;
        if ( v20 )
        {
          v7 -= a4;
          result = v35 - 1;
          v35 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a1;
    v22 = a2;
    v23 = (_DWORD *)v7;
    if ( a2 < 4 )
    {
LABEL_26:
      if ( !v22 )
        goto LABEL_36;
    }
    else
    {
      while ( *v21 == *v23 )
      {
        v22 -= 4;
        ++v23;
        ++v21;
        if ( v22 < 4 )
          goto LABEL_26;
      }
    }
    v24 = *(_BYTE *)v21 - *(_BYTE *)v23;
    if ( *(_BYTE *)v21 != *(_BYTE *)v23
      || (v25 = v22 - 1, v26 = (char *)v23 + 1, v27 = (char *)v21 + 1, v25)
      && ((v24 = *v27 - *v26, *v27 != *v26)
       || (v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, v28)
       && ((v24 = *v30 - *v29, *v30 != *v29)
        || (v31 = v29 + 1, v32 = v30 + 1, v28 != 1) && (v33 = *v31, v24 = *v32 - v33, *v32 != v33))) )
    {
      v34 = 1;
      if ( v24 <= 0 )
        v34 = -1;
LABEL_37:
      if ( !v34 )
        return result;
      return a6;
    }
LABEL_36:
    v34 = 0;
    goto LABEL_37;
  }
  return a6;
}

//----- (10014F70) --------------------------------------------------------
char __thiscall sub_10014F70(void *this)
{
  char result; // al@1
  bool v2; // zf@2
  void *v3; // [sp-2h] [bp-4h]@1

  v3 = this;
  sub_10015520(4, (char *)&v3 + 3);
  result = BYTE3(v3);
  if ( BYTE3(v3) == 1 )
  {
    v2 = SIM_proc_rqst(50) == 0;
    result = 2;
    if ( v2 )
      result = BYTE3(v3);
  }
  return result;
}
// 10032606: using guessed type int __cdecl SIM_proc_rqst(_DWORD);

//----- (10014FA0) --------------------------------------------------------
int __thiscall sub_10014FA0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10015520(46, (char *)&v2);
  return (int)v2;
}

//----- (10014FC0) --------------------------------------------------------
int __cdecl sub_10014FC0(char *a1)
{
  int result; // eax@1

  result = sub_10015520(50, a1);
  a1[11] = 0;
  return result;
}

//----- (10014FE0) --------------------------------------------------------
char __cdecl sub_10014FE0(char *a1)
{
  int v1; // ecx@0
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  sub_10015520(13, (char *)&v3 + 3);
  sub_10015520(12, a1);
  return BYTE3(v3);
}

//----- (10015010) --------------------------------------------------------
char __cdecl sub_10015010(int a1)
{
  void *v1; // ecx@1
  char v2; // bl@1
  unsigned int v4; // [sp+4h] [bp-4h]@1

  v2 = sub_10014FE0((char *)&v4);
  if ( v2 )
  {
    if ( sub_100154A0(v1) == 1 )
      sub_1001FC90((int *)&v4, v4);
    sub_10015790(a1, v4);
  }
  return v2;
}

//----- (10015060) --------------------------------------------------------
char __cdecl sub_10015060(int a1)
{
  void *v1; // ecx@1
  char v2; // bl@1
  unsigned int v4; // [sp+4h] [bp-4h]@1

  v2 = sub_10014FE0((char *)&v4);
  if ( v2 )
  {
    if ( sub_100154A0(v1) == 1 )
      sub_1001FC90((int *)&v4, v4);
    sub_100156A0(a1, v4);
  }
  return v2;
}

//----- (100150B0) --------------------------------------------------------
bool __cdecl sub_100150B0(float a1, int a2, int a3, int a4)
{
  int v4; // edi@2
  int v5; // esi@3
  int v6; // ecx@8
  unsigned int v7; // eax@9
  float v8; // ST14_4@10
  float v9; // ST14_4@10
  float v10; // ST14_4@10
  float v11; // ST14_4@10
  float v12; // ST14_4@10
  float v13; // ST14_4@10
  float v14; // ST14_4@10
  int v15; // eax@12
  float v16; // ST14_4@14
  signed int v17; // ebx@14
  bool result; // al@19
  int v19; // [sp+8h] [bp-8h]@5

  if ( a4 && (v4 = a3, a3 <= 9) && (v5 = a2, a2 > 0) && a3 <= a2 - 2 )
  {
    v19 = 0;
    if ( a1 < 0.0 )
    {
      v4 = a3 - 1;
      a1 = fabs(a1);
      *(_BYTE *)a4 = 45;
      v19 = 1;
      if ( a3 == 1 )
        v4 = -1;
    }
    v6 = 0;
    if ( v4 >= 8 )
    {
      v7 = ((unsigned int)(v4 - 8) >> 3) + 1;
      v6 = 8 * v7;
      do
      {
        --v7;
        v8 = a1 * 10.0;
        v9 = v8 * 10.0;
        v10 = v9 * 10.0;
        v11 = v10 * 10.0;
        v12 = v11 * 10.0;
        v13 = v12 * 10.0;
        v14 = v13 * 10.0;
        a1 = v14 * 10.0;
      }
      while ( v7 );
    }
    if ( v6 < v4 )
    {
      v15 = v4 - v6;
      do
      {
        --v15;
        a1 = a1 * 10.0;
      }
      while ( v15 );
    }
    v16 = a1 + 0.5;
    v17 = (signed int)v16;
    if ( a2 > v19 )
    {
      do
      {
        if ( --v5 == a2 - v4 - 1 )
        {
          *(_BYTE *)(v5 + a4) = 46;
        }
        else
        {
          *(_BYTE *)(v5 + a4) = v17 % 10 + 48;
          v17 /= 10;
        }
      }
      while ( v5 > v19 );
    }
    result = v17 == 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10015220) --------------------------------------------------------
bool __cdecl sub_10015220(signed int a1, signed int a2, _BYTE *a3)
{
  bool result; // al@2
  signed int v4; // ebx@3
  signed int v5; // edi@3
  signed int i; // esi@5

  if ( a3 )
  {
    v4 = a1;
    v5 = 0;
    if ( a1 < 0 )
    {
      v4 = -a1;
      *a3 = 45;
      v5 = 1;
    }
    for ( i = a2; i > v5; v4 /= 10 )
      a3[--i] = v4 % 10 + 48;
    result = v4 == 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10015290) --------------------------------------------------------
int __cdecl sub_10015290(int a1, _BYTE *a2, int a3)
{
  int v3; // esi@2
  int v4; // eax@2
  _BYTE *v5; // ecx@3
  int result; // eax@7

  if ( a3 <= 0 )
    goto LABEL_11;
  v3 = a3 - 1;
  v4 = 0;
  if ( a3 - 1 > 0 )
  {
    v5 = a2;
    do
    {
      if ( !*v5 )
        break;
      v5[a1 - (_DWORD)a2] = *v5;
      ++v4;
      ++v5;
    }
    while ( v4 < v3 );
  }
  *(_BYTE *)(v4 + a1) = 0;
  *(_BYTE *)(v3 + a1) = 0;
  if ( a2[v4] )
LABEL_11:
    result = -1;
  else
    result = v4 + 1;
  return result;
}

//----- (100152E0) --------------------------------------------------------
int __cdecl sub_100152E0(void *a1, size_t a2)
{
  _BYTE *v2; // eax@1
  int result; // eax@2

  v2 = memchr(a1, 0, a2);
  if ( v2 )
    result = v2 - (_BYTE *)a1;
  else
    result = -2;
  return result;
}

//----- (10015310) --------------------------------------------------------
int __cdecl sub_10015310(int a1, char *a2, int a3)
{
  int v3; // eax@3
  int i; // esi@5
  int v5; // esi@8
  int result; // eax@8

  if ( a1 && a2 )
  {
    v3 = a3;
    if ( !a3 )
      v3 = strlen((const char *)a1);
    for ( i = v3 - 1; i >= 0; --i )
    {
      if ( !strchr(a2, *(_BYTE *)(i + a1)) )
        break;
    }
    v5 = i + 1;
    *(_BYTE *)(v5 + a1) = 0;
    result = v5;
  }
  else
  {
    result = a3;
  }
  return result;
}

//----- (10015370) --------------------------------------------------------
int __cdecl sub_10015370(char *a1, size_t a2, char *a3, va_list a4)
{
  int result; // eax@2

  if ( (signed int)a2 > 0 )
  {
    result = _vsnprintf(a1, a2, a3, a4);
    if ( result < 0 )
      result = -1;
    a1[a2 - 1] = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (100153B0) --------------------------------------------------------
int sub_100153B0(char *a1, size_t a2, char *a3, ...)
{
  int result; // eax@1
  va_list va; // [sp+10h] [bp+10h]@1

  va_start(va, a3);
  result = sub_10015370(a1, a2, a3, va);
  if ( result < 0 )
    result = -1;
  return result;
}

//----- (100153E0) --------------------------------------------------------
int __cdecl sub_100153E0(const char *a1, _BYTE *a2, int a3)
{
  unsigned int v3; // kr00_4@1

  v3 = strlen(a1);
  return sub_10015290((int)&a1[v3], a2, a3 - v3);
}

//----- (10015420) --------------------------------------------------------
int __cdecl sub_10015420(int a1, int a2)
{
  return sub_10015310(a1, "_ ", a2);
}

//----- (10015440) --------------------------------------------------------
int __cdecl sub_10015440(int a1, int a2, int a3)
{
  void *v3; // ecx@0
  int v4; // eax@1
  unsigned int v5; // esi@3
  int result; // eax@7

  v4 = a1;
  if ( !a1 )
    v4 = sub_10014FA0(v3);
  v5 = 0;
  while ( v4 != dword_10057E10[2 * v5] )
  {
    if ( ++v5 >= 0x1C )
      return sub_10015290(a2, &unk_10057F14, a3);
  }
  result = sub_10015290(a2, (_BYTE *)off_10057E14[2 * v5], a3);
  if ( v5 < 0x1C )
    return result;
  return sub_10015290(a2, &unk_10057F14, a3);
}
// 10057E10: using guessed type int dword_10057E10[];

//----- (100154A0) --------------------------------------------------------
char __thiscall sub_100154A0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 1;
  sub_10030690(3008, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (100154D0) --------------------------------------------------------
int sub_100154D0()
{
  int v1; // [sp+0h] [bp-8h]@1
  int v2; // [sp+4h] [bp-4h]@1

  v1 = 0;
  sub_10030690(3012, &v2, 4, &v1);
  return v2;
}

//----- (10015500) --------------------------------------------------------
char __cdecl sub_10015500(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_is_booting(a1);
  SYS_exit_krnl();
  return v1;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 1003268A: using guessed type int __cdecl SYS_pvg_is_booting(_DWORD);
// 10032690: using guessed type int SYS_enter_krnl(void);

//----- (10015520) --------------------------------------------------------
int __cdecl sub_10015520(int a1, char *a2)
{
  if ( (unsigned __int8)a1 >= 0x5Fu )
    sub_10014D70("..\\lib\\adl\\sys_usr.c", 5389, 1, 0);
  if ( !a2 )
    sub_10014D70("..\\lib\\adl\\sys_usr.c", 5390, 1, 0);
  SYS_enter_krnl();
  SYS_pvg_var_ctrl(a1, a2);
  return SYS_exit_krnl();
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 10032696: using guessed type int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD);

//----- (10015580) --------------------------------------------------------
char __thiscall sub_10015580(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10015520(35, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (100155A0) --------------------------------------------------------
int __cdecl sub_100155A0(char a1)
{
  return sub_10015520(79, &a1);
}

//----- (100155B0) --------------------------------------------------------
char __thiscall sub_100155B0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10015520(5, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (100155D0) --------------------------------------------------------
char __thiscall sub_100155D0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10015520(18, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (100155F0) --------------------------------------------------------
char __thiscall sub_100155F0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10015520(17, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10015610) --------------------------------------------------------
int __thiscall sub_10015610(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10015520(27, (char *)&v2);
  return (int)v2;
}

//----- (10015630) --------------------------------------------------------
int __thiscall sub_10015630(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10015520(29, (char *)&v2);
  return (int)v2;
}

//----- (10015650) --------------------------------------------------------
char __thiscall sub_10015650(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10015520(34, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10015670) --------------------------------------------------------
char __thiscall sub_10015670(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10015520(44, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10015690) --------------------------------------------------------
int __cdecl sub_10015690(char a1)
{
  return sub_10015520(56, &a1);
}

//----- (100156A0) --------------------------------------------------------
int __cdecl sub_100156A0(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int result; // eax@1
  unsigned int v4; // edx@1
  char v5; // bl@8
  char v6; // dl@13
  char v7; // cl@13

  v2 = a2 / 0x15180 % 0x5B5;
  result = a1;
  v4 = 4 * (a2 / 0x15180 / 0x5B5) + 1990;
  *(_WORD *)(a1 + 2) = v4;
  if ( v2 > 0x16D )
  {
    do
    {
      v2 -= 365;
      if ( !((unsigned __int16)v4 % 4) )
        --v2;
      LOWORD(v4) = v4 + 1;
    }
    while ( v2 > 0x16D );
    *(_WORD *)(a1 + 2) = v4;
  }
  if ( v2 >= 1 )
  {
    v5 = 0;
    if ( v2 > 0x3B && !(*(_WORD *)(a1 + 2) % 4) )
    {
      --v2;
      v5 = 1;
    }
    *(_BYTE *)a1 = 12;
    if ( v2 <= 0x14E )
    {
      do
        --*(_BYTE *)a1;
      while ( v2 <= *(_WORD *)&word_10057F8A[2 * *(_BYTE *)a1] );
    }
    v6 = *(_BYTE *)a1;
    v7 = v2 - word_10057F8A[2 * *(_BYTE *)a1];
    *(_BYTE *)(a1 + 1) = v7;
    if ( v5 == 1 && v6 == 2 )
      *(_BYTE *)(a1 + 1) = v7 + 1;
  }
  else
  {
    --*(_WORD *)(a1 + 2);
    *(_BYTE *)a1 = 12;
    *(_BYTE *)(a1 + 1) = 31;
  }
  return result;
}

//----- (10015790) --------------------------------------------------------
__int16 __cdecl sub_10015790(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  __int16 result; // ax@1

  v2 = a2 % 0x15180 % 0xE10;
  *(_WORD *)a1 = a2 % 0x15180 / 0xE10;
  *(_BYTE *)(a1 + 2) = v2 / 0x3C;
  result = 60 * (char)(v2 / 0x3C);
  *(_BYTE *)(a1 + 3) = v2 % 0x3C;
  return result;
}

//----- (100157E0) --------------------------------------------------------
__int16 __cdecl sub_100157E0(unsigned int *a1, _WORD *a2, _WORD *a3)
{
  unsigned int v3; // esi@1
  __int16 result; // ax@1
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1

  v3 = *a1;
  sub_10015790((int)&v5, *a1);
  sub_100156A0((int)&v6, v3);
  *a3 = (unsigned __int8)(BYTE3(v5) >> 1) | (unsigned __int16)(32 * (BYTE2(v5) | (unsigned __int16)((_WORD)v5 << 6)));
  result = BYTE1(v6);
  *a2 = BYTE1(v6) | (unsigned __int16)(32 * ((unsigned __int8)v6 | (unsigned __int16)(16 * (HIWORD(v6) - 60))));
  return result;
}

//----- (10015860) --------------------------------------------------------
char __cdecl sub_10015860(char a1, void *a2)
{
  int v2; // eax@2
  char result; // al@11
  char *v4; // eax@12
  signed int v5; // ecx@12

  switch ( a1 )
  {
    case 0:
      v2 = 247;
      break;
    case 2:
      v2 = 248;
      break;
    case 3:
      v2 = 1732;
      break;
    case 4:
      v2 = 1733;
      break;
    case 5:
      v2 = 2279;
      break;
    case 6:
      v2 = 2280;
      break;
    default:
      v2 = 246;
      break;
  }
  if ( !sub_1000ED60(1, v2, a2) || sub_10011050((int)a2) )
  {
    memset(a2, 0, 0xCCCu);
    v4 = (char *)a2 + 26;
    v5 = 14;
    do
    {
      *v4 = 15;
      v4 += 232;
      --v5;
    }
    while ( v5 );
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10015910) --------------------------------------------------------
char __cdecl sub_10015910(char a1, int a2)
{
  char result; // al@1
  int v3; // edx@3
  char v4; // cl@3
  int v5; // edx@3
  char v6; // cl@3
  __int16 v7; // cx@3
  __int16 v8; // cx@3
  __int16 v9; // cx@3
  int v10; // [sp+4h] [bp-CD0h]@1
  int v11; // [sp+8h] [bp-CCCh]@3
  int v12; // [sp+Ch] [bp-CC8h]@3
  char v13; // [sp+10h] [bp-CC4h]@3
  char v14; // [sp+11h] [bp-CC3h]@3
  char v15; // [sp+12h] [bp-CC2h]@3
  char v16; // [sp+13h] [bp-CC1h]@3
  __int16 v17; // [sp+14h] [bp-CC0h]@3
  __int16 v18; // [sp+16h] [bp-CBEh]@3
  __int16 v19; // [sp+18h] [bp-CBCh]@3
  __int16 v20; // [sp+CCCh] [bp-8h]@3
  __int16 v21; // [sp+CCEh] [bp-6h]@3

  result = sub_10015860(a1, &v10);
  if ( result )
  {
    v3 = v10;
    *(_DWORD *)(a2 + 4) = v11;
    v4 = v13;
    *(_DWORD *)a2 = v3;
    v5 = v12;
    *(_BYTE *)(a2 + 12) = v4;
    v6 = v15;
    *(_DWORD *)(a2 + 8) = v5;
    LOBYTE(v5) = v14;
    *(_BYTE *)(a2 + 14) = v6;
    v7 = v17;
    *(_BYTE *)(a2 + 13) = v5;
    LOBYTE(v5) = v16;
    *(_WORD *)(a2 + 16) = v7;
    v8 = v19;
    *(_BYTE *)(a2 + 15) = v5;
    LOWORD(v5) = v18;
    *(_WORD *)(a2 + 20) = v8;
    v9 = v21;
    *(_WORD *)(a2 + 18) = v5;
    LOWORD(v5) = v20;
    *(_WORD *)(a2 + 24) = v9;
    *(_WORD *)(a2 + 22) = v5;
  }
  else
  {
    *(_DWORD *)a2 = 0;
    *(_DWORD *)(a2 + 4) = 0;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 12) = 0;
    *(_DWORD *)(a2 + 16) = 0;
    *(_DWORD *)(a2 + 20) = 0;
    *(_DWORD *)(a2 + 24) = 0;
  }
  return result;
}

//----- (100159F0) --------------------------------------------------------
int __cdecl sub_100159F0(char a1, void *a2)
{
  _BYTE *v2; // esi@3
  char v3; // al@3

  if ( a1 )
  {
    if ( a1 != 1 )
      return 0;
    v2 = a2;
    v3 = sub_1000ED60(6, 14, a2);
  }
  else
  {
    v2 = a2;
    v3 = sub_1000ED60(6, 11, a2);
  }
  if ( v3 && v2[24] )
    return 1;
  return 0;
}

//----- (10015A30) --------------------------------------------------------
char __thiscall sub_10015A30(void *this)
{
  char v1; // bl@1
  void *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_10151BF8 = sub_10015650(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_10151C00, 0, 0xAA0u);
  v1 = 0;
  v4 = 0;
  v2 = &unk_10151C00;
  do
  {
    result = sub_1001FEA0(v4, (int)v2);
    ++v1;
    v2 = (char *)v2 + 2720;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 2u );
  return result;
}
// 10151BF8: using guessed type int dword_10151BF8;

//----- (10015AA0) --------------------------------------------------------
char __usercall sub_10015AA0@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4)
{
  char result; // al@1

  memset(a3, 0, (unsigned __int16)a2);
  result = 0;
  if ( a4 )
  {
    if ( a4 == 1 )
      result = sub_1000ED30(6, 8, a1, a2, a3);
  }
  else
  {
    result = sub_1000ED30(6, 5, a1, a2, a3);
  }
  return result;
}

//----- (10015AE0) --------------------------------------------------------
void *__usercall sub_10015AE0@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4)
{
  int v4; // edi@1
  void *result; // eax@4

  v4 = 0;
  if ( dword_10151BF8 == 1379255385 )
    goto LABEL_4;
  v4 = sub_10030340(86, 10);
  if ( !v4 )
  {
    memset((char *)&unk_10151C00 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
    sub_1001FEA0(a1, (int)&unk_10151C00 + 2720 * (unsigned __int8)a1);
LABEL_4:
    result = memcpy(a4, (char *)&unk_10151C00 + 2720 * (unsigned __int8)a1 + (unsigned __int16)a2, (unsigned __int16)a3);
    goto LABEL_6;
  }
  result = memset(a4, 0, (unsigned __int16)a3);
LABEL_6:
  if ( dword_10151BF8 != 1379255385 )
    result = (void *)sub_10030310(v4, 86);
  return result;
}
// 10151BF8: using guessed type int dword_10151BF8;

//----- (10015B80) --------------------------------------------------------
char __cdecl sub_10015B80(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 <= 0xAu )
    result = sub_10015AA0(4 * (a2 + 6), 4, a3, a1);
  return result;
}

//----- (10015BC0) --------------------------------------------------------
bool __cdecl sub_10015BC0(char a1, char a2, void *a3)
{
  bool result; // al@1
  unsigned __int8 v4; // al@3

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 <= 0xAu )
  {
    sub_10015AE0(a1, 4 * ((unsigned __int8)a2 + 6), 4, a3);
    v4 = *((_BYTE *)a3 + 1);
    result = v4 < 0x33u || v4 >= 0x64u && v4 <= 0x81u || v4 >= 0x96u && v4 <= 0x9Eu;
  }
  return result;
}

//----- (10015C20) --------------------------------------------------------
char __cdecl sub_10015C20(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xAu )
    result = sub_10015AA0(a2, 1, a3, a1);
  return result;
}

//----- (10015C60) --------------------------------------------------------
char __cdecl sub_10015C60(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xAu )
  {
    sub_10015AE0(a1, (unsigned __int8)a2, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10015C90) --------------------------------------------------------
char __cdecl sub_10015C90(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xBu )
    result = sub_10015AA0(a2 + 10, 1, a3, a1);
  return result;
}

//----- (10015CD0) --------------------------------------------------------
char __cdecl sub_10015CD0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xBu )
  {
    sub_10015AE0(a1, (unsigned __int8)a2 + 10, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10015D10) --------------------------------------------------------
char __cdecl sub_10015D10(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 2u )
    result = sub_10015AA0(16 * (a2 + 50), 16, a3, a1);
  return result;
}

//----- (10015D50) --------------------------------------------------------
bool __cdecl sub_10015D50(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 2u )
  {
    sub_10015AE0(a1, 16 * ((unsigned __int8)a2 + 50), 16, a3);
    result = *(_BYTE *)a3 < 8u && *((_BYTE *)a3 + 1) < 8u;
  }
  return result;
}

//----- (10015DA0) --------------------------------------------------------
char __cdecl sub_10015DA0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x29u )
    result = sub_10015AA0(12 * a2 + 68, 12, a3, a1);
  return result;
}

//----- (10015DE0) --------------------------------------------------------
bool __cdecl sub_10015DE0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x29u )
  {
    sub_10015AE0(a1, 12 * (unsigned __int8)a2 + 68, 12, a3);
    result = *((_WORD *)a3 + 1) < 0x319u;
  }
  return result;
}

//----- (10015E20) --------------------------------------------------------
char __cdecl sub_10015E20(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x2Au )
    result = sub_10015AA0(4 * (a2 + 140), 4, a3, a1);
  return result;
}

//----- (10015E60) --------------------------------------------------------
bool __cdecl sub_10015E60(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x2Au )
  {
    sub_10015AE0(a1, 4 * ((unsigned __int8)a2 + 140), 4, a3);
    result = *((_WORD *)a3 + 1) < 0x145u;
  }
  return result;
}

//----- (10015EA0) --------------------------------------------------------
char __cdecl sub_10015EA0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10015AA0(1229, 1, a2, a1);
  return result;
}

//----- (10015ED0) --------------------------------------------------------
char __cdecl sub_10015ED0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10015AE0(a1, 1229, 1, a2);
    result = 1;
  }
  return result;
}

//----- (10015F00) --------------------------------------------------------
char __cdecl sub_10015F00(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10015AA0(1212, 16, a2, a1);
  return result;
}

//----- (10015F30) --------------------------------------------------------
char __cdecl sub_10015F30(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10015AE0(a1, 1212, 16, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10015F60) --------------------------------------------------------
char __cdecl sub_10015F60(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10015AA0(2400, 65, a2, a1);
  return result;
}

//----- (10015F90) --------------------------------------------------------
char __cdecl sub_10015F90(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10015AE0(a1, 2400, 65, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10015FC0) --------------------------------------------------------
char __cdecl sub_10015FC0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 < 8u && (unsigned __int8)a1 < 2u )
    result = sub_10015AA0(4 * (a2 + 182), 4, a3, a1);
  return result;
}

//----- (10016000) --------------------------------------------------------
char __cdecl sub_10016000(char a1, char a2, void *a3)
{
  char result; // al@2

  if ( (unsigned __int8)a2 > 7u )
    result = sub_10014D70("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 1428, 0, 0);
  else
    result = (unsigned int)sub_10015AE0(a1, 4 * ((unsigned __int8)a2 + 182), 4, a3);
  return result;
}

//----- (10016050) --------------------------------------------------------
char __cdecl sub_10016050(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 <= 4u )
    result = sub_10015AA0(8 * (a2 + 95), 8, a3, a1);
  return result;
}

//----- (10016090) --------------------------------------------------------
char __cdecl sub_10016090(char a1, char a2, void *a3)
{
  char result; // al@1

  result = a2;
  if ( (unsigned __int8)a2 <= 4u )
    result = (unsigned int)sub_10015AE0(a1, 8 * ((unsigned __int8)a2 + 95), 8, a3);
  return result;
}

//----- (100160C0) --------------------------------------------------------
char __cdecl sub_100160C0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10015AA0(22, 1, a2, a1);
  return result;
}

//----- (100160F0) --------------------------------------------------------
char __cdecl sub_100160F0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10015AA0(832, 4, a2, a1);
  return result;
}

//----- (10016120) --------------------------------------------------------
char __cdecl sub_10016120(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10015AE0(a1, 832, 4, a2);
    result = 1;
  }
  return result;
}

//----- (10016150) --------------------------------------------------------
char __cdecl sub_10016150(int a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@4
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1001F5C0(a1);
  if ( v6 == 2 )
  {
LABEL_44:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 0:
        if ( a2 )
        {
          sub_10016000(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_10015FC0(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 1:
        if ( a2 )
        {
          sub_10016090(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_10016050(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 2:
        if ( a2 )
          result = sub_10015BC0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10015B80(v6, *(_BYTE *)a4, a5);
        break;
      case 3:
        if ( a2 )
          result = sub_10015DE0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10015DA0(v6, *(_BYTE *)a4, a5);
        break;
      case 4:
        if ( a2 )
          result = sub_10015E60(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10015E20(v6, *(_BYTE *)a4, a5);
        break;
      case 5:
        if ( a2 )
          result = sub_10015C60(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10015C20(v6, *(_BYTE *)a4, a5);
        break;
      case 6:
        if ( a2 )
          result = sub_10015CD0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10015C90(v6, *(_BYTE *)a4, a5);
        break;
      case 7:
        result = sub_100160C0(v6, a5);
        break;
      case 8:
        if ( a2 )
          result = sub_10015F30(v6, a5);
        else
          result = sub_10015F00(v6, a5);
        break;
      case 9:
        if ( a2 )
          result = sub_10015D50(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10015D10(v6, *(_BYTE *)a4, a5);
        break;
      case 0x1D:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10015F90(v6, a5);
        else
          result = sub_10015F60(v6, a5);
        break;
      case 0x21:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10015ED0(v6, a5);
        else
          result = sub_10015EA0(v6, a5);
        break;
      case 0x1B:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10016120(v6, a5);
        else
          result = sub_100160F0(v6, a5);
        break;
      default:
        sub_10014D70("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 2329, 0, 0);
        goto LABEL_44;
    }
  }
  return result;
}
// 10008150: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (100164F0) --------------------------------------------------------
char __cdecl sub_100164F0(char a1)
{
  char result; // al@1

  result = -80;
  switch ( a1 )
  {
    case 3:
      result = -126;
      break;
    case 4:
      result = -123;
      break;
    case 5:
      result = -108;
      break;
    case 6:
      result = -105;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10016530) --------------------------------------------------------
char __cdecl sub_10016530(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 3;
      break;
    case 1:
      result = 4;
      break;
    case 2:
      result = 5;
      break;
    case 3:
      result = 40;
      break;
    case 4:
      result = 41;
      break;
    case 5:
      result = 51;
      break;
    case 6:
      result = 52;
      break;
    default:
      sub_10014D70("..\\lib\\adl\\iop_cdu_unit_intf.c", 490, 0, 0);
      result = 67;
      break;
  }
  return result;
}

//----- (100165A0) --------------------------------------------------------
char __cdecl sub_100165A0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 74;
      break;
    case 1:
      result = 73;
      break;
    case 2:
      result = 75;
      break;
    case 3:
      result = -127;
      break;
    case 4:
      result = -124;
      break;
    case 5:
      result = -109;
      break;
    case 6:
      result = -106;
      break;
    default:
      sub_10014D70("..\\lib\\adl\\iop_cdu_unit_intf.c", 564, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (10016610) --------------------------------------------------------
signed int __cdecl sub_10016610(char a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = 4;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 64;
      break;
    case 4:
      result = 128;
      break;
    case 5:
      result = 16;
      break;
    case 6:
      result = 32;
      break;
    default:
      sub_10014D70("..\\lib\\adl\\iop_cdu_unit_intf.c", 638, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10016690) --------------------------------------------------------
char __cdecl sub_10016690(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 13;
      break;
    case 1:
      result = 12;
      break;
    case 2:
      result = 14;
      break;
    case 3:
      result = -128;
      break;
    case 4:
      result = -125;
      break;
    case 5:
      result = -110;
      break;
    case 6:
      result = -107;
      break;
    default:
      sub_10014D70("..\\lib\\adl\\iop_cdu_unit_intf.c", 712, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (10016700) --------------------------------------------------------
char __cdecl sub_10016700(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 3:
      result = 0;
      break;
    case 4:
      result = 1;
      break;
    case 5:
      result = 2;
      break;
    case 0x28:
      result = 3;
      break;
    case 0x29:
      result = 4;
      break;
    case 0x33:
      result = 5;
      break;
    case 0x34:
      result = 6;
      break;
    default:
      sub_10014D70("..\\lib\\adl\\iop_cdu_unit_intf.c", 786, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (100167B0) --------------------------------------------------------
char __cdecl sub_100167B0(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 4:
      result = 0;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      sub_10014D70("..\\lib\\adl\\iop_cdu_unit_intf.c", 1096, 1, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (100168B0) --------------------------------------------------------
char __cdecl sub_100168B0(char a1)
{
  return sub_1001F700((int)&unk_10059908, a1, 0xBu);
}

//----- (100168D0) --------------------------------------------------------
char __thiscall sub_100168D0(void *this)
{
  int v1; // eax@1

  v1 = sub_10014FA0(this);
  return sub_100167B0(v1);
}

//----- (100168E0) --------------------------------------------------------
char __cdecl sub_100168E0(char a1)
{
  char result; // al@2
  unsigned __int8 v2; // [sp+4h] [bp-4h]@1

  v2 = sub_100168B0(a1);
  if ( v2 == -80 )
    result = 67;
  else
    result = sub_1001FFC0(v2);
  return result;
}

//----- (10016920) --------------------------------------------------------
signed int sub_10016920()
{
  return sub_100312F0((int)&off_1005A1E0);
}
// 1005A1E0: using guessed type char *off_1005A1E0;

//----- (10016930) --------------------------------------------------------
signed int sub_10016930()
{
  return sub_100312F0((int)&off_1005A1F4);
}
// 1005A1F4: using guessed type char *off_1005A1F4;

//----- (10016940) --------------------------------------------------------
char __cdecl sub_10016940(int a1, char a2)
{
  char result; // al@5
  int v3; // edx@5
  unsigned int v4; // ecx@5
  int v5; // edx@9
  unsigned int v6; // ecx@9
  int v7; // edx@13
  unsigned int v8; // ecx@13

  if ( a2 )
  {
    if ( a2 != 1 )
    {
      if ( a2 == 2 && (unsigned __int8)sub_10016930() )
      {
        result = 1;
        v3 = 0;
        v4 = 205212;
        do
        {
          *(_BYTE *)(v3 + a1) = *(_BYTE *)(v4 + dword_1020D814);
          v4 += 12;
          ++v3;
        }
        while ( v4 < 0x37F5C );
        return result;
      }
      return 0;
    }
    if ( !(unsigned __int8)sub_10016930() )
      return 0;
    result = 1;
    v5 = 0;
    v6 = 48;
    do
    {
      *(_BYTE *)(v5 + a1) = *(_BYTE *)(v6 + dword_1020D814);
      v6 += 12;
      ++v5;
    }
    while ( v6 < 0x1D4F0 );
  }
  else
  {
    if ( !(unsigned __int8)sub_10016920() )
      return 0;
    v7 = 0;
    result = 1;
    v8 = 0;
    do
    {
      *(_BYTE *)(v7 + a1) = *(_BYTE *)(v8 + dword_1020D818 + 8);
      v8 += 12;
      ++v7;
    }
    while ( v8 < 0x1D4C0 );
  }
  return result;
}
// 1020D814: using guessed type int dword_1020D814;
// 1020D818: using guessed type int dword_1020D818;

//----- (10016A20) --------------------------------------------------------
char __cdecl sub_10016A20(_DWORD *a1, char a2)
{
  char result; // al@5

  if ( a2 )
  {
    if ( a2 == 1 )
    {
      if ( (unsigned __int8)sub_10016930() )
      {
        result = 1;
        *a1 = *(_DWORD *)(dword_1020D814 + 120040);
        return result;
      }
    }
    else if ( a2 == 2 && (unsigned __int8)sub_10016930() )
    {
      result = 1;
      *a1 = *(_DWORD *)(dword_1020D814 + 229204);
      return result;
    }
  }
  else if ( (unsigned __int8)sub_10016920() )
  {
    result = 1;
    *a1 = *(_DWORD *)(dword_1020D818 + 120000);
    return result;
  }
  return 0;
}
// 1020D814: using guessed type int dword_1020D814;
// 1020D818: using guessed type int dword_1020D818;

//----- (10016AA0) --------------------------------------------------------
char __cdecl sub_10016AA0(unsigned __int16 a1, unsigned __int16 a2)
{
  char result; // al@5

  if ( a2 >= 0x2710u )
  {
    result = 0;
  }
  else
  {
    if ( a1 >= 0x9C4u )
      goto LABEL_16;
    if ( (unsigned __int16)(a1 - 1000) <= 0x3E7u && (unsigned __int8)sub_10016930() )
      return *(_BYTE *)(dword_1020D814 + 12 * a2 + 40);
    if ( (unsigned __int16)(a1 - 2000) <= 0x1F3u && (unsigned __int8)sub_10016930() )
      return *(_BYTE *)(dword_1020D814 + 12 * a2 + 205204);
    if ( a1 <= 0x3E7u && (unsigned __int8)sub_10016920() )
      result = *(_BYTE *)(dword_1020D818 + 12 * a2);
    else
LABEL_16:
      result = 0;
  }
  return result;
}
// 1020D814: using guessed type int dword_1020D814;
// 1020D818: using guessed type int dword_1020D818;

//----- (10016B50) --------------------------------------------------------
BOOL __cdecl sub_10016B50(unsigned int a1)
{
  int v1; // edi@1
  __int16 i; // si@1
  char v4; // [sp+Bh] [bp-1h]@1

  v1 = sub_10030040();
  for ( i = sub_100314A0(6, 0, 1, (int)&v4); i == 12; i = sub_100314A0(6, 0, 1, (int)&v4) )
  {
    if ( sub_10030040() - v1 >= a1 )
      break;
    sub_10030240(100);
  }
  return i == 12;
}

//----- (10016BC0) --------------------------------------------------------
char __thiscall sub_10016BC0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10031450(81, (_BYTE *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10016BE0) --------------------------------------------------------
void __cdecl sub_10016BE0(_BYTE *a1, _BYTE *a2, _BYTE *a3)
{
  sub_10031450(120, a1);
  sub_10031450(124, a2);
  sub_10031450(121, a3);
}

//----- (10016C10) --------------------------------------------------------
int __cdecl sub_10016C10(int a1)
{
  return sub_100303F0(3025, a1, 84);
}

//----- (10016C30) --------------------------------------------------------
signed int sub_10016C30()
{
  bool v0; // zf@1
  signed int result; // eax@1
  char v2; // [sp+3h] [bp-5h]@1
  int v3; // [sp+4h] [bp-4h]@1

  v0 = sub_100314E0(6, &v3, &v2) == 0;
  result = -4;
  if ( v0 )
    result = v3;
  return result;
}

//----- (10016C60) --------------------------------------------------------
void __cdecl sub_10016C60(_BYTE *a1)
{
  sub_10031450(129, a1);
}

//----- (10016C80) --------------------------------------------------------
char __cdecl sub_10016C80(int a1, size_t a2, void *a3)
{
  char result; // al@2

  if ( sub_100314A0(6, a1, a2, (int)a3) )
  {
    memset(a3, 0, a2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10016CC0) --------------------------------------------------------
int __cdecl sub_10016CC0(int a1)
{
  return sub_100304C0(3025, a1, 84);
}

//----- (10016CE0) --------------------------------------------------------
char __fastcall sub_10016CE0(int *a1)
{
  char v1; // bl@1
  unsigned int v2; // eax@7
  int *v3; // edx@7
  int v4; // esi@11
  int v5; // eax@12
  _BYTE *v6; // edx@12
  int v7; // eax@14
  _BYTE *v8; // edx@14
  _BYTE *v9; // edx@16
  signed int v10; // eax@18
  char result; // al@25
  char v12; // [sp+4h] [bp-68h]@1
  int v13; // [sp+8h] [bp-64h]@2
  int v14; // [sp+Ch] [bp-60h]@29
  int v15; // [sp+10h] [bp-5Ch]@29
  char v16; // [sp+12h] [bp-5Ah]@3
  char v17; // [sp+13h] [bp-59h]@4
  int v18; // [sp+14h] [bp-58h]@5
  char v19; // [sp+18h] [bp-54h]@6
  int v20; // [sp+1Ch] [bp-50h]@2
  int v21; // [sp+20h] [bp-4Ch]@29
  int v22; // [sp+24h] [bp-48h]@29
  char v23; // [sp+26h] [bp-46h]@3
  char v24; // [sp+27h] [bp-45h]@4
  int v25; // [sp+28h] [bp-44h]@5
  char v26; // [sp+2Ch] [bp-40h]@6
  int v27; // [sp+2Dh] [bp-3Fh]@7
  int v28; // [sp+31h] [bp-3Bh]@29
  int v29; // [sp+35h] [bp-37h]@29
  int v30; // [sp+3Ch] [bp-30h]@2
  int v31; // [sp+40h] [bp-2Ch]@2
  int v32; // [sp+44h] [bp-28h]@2
  int v33; // [sp+48h] [bp-24h]@2
  int v34; // [sp+4Ch] [bp-20h]@2
  int v35; // [sp+50h] [bp-1Ch]@2
  int v36; // [sp+54h] [bp-18h]@2
  char v37; // [sp+58h] [bp-14h]@2
  int v38; // [sp+5Ch] [bp-10h]@2
  int v39; // [sp+60h] [bp-Ch]@29
  int v40; // [sp+64h] [bp-8h]@29

  v1 = 1;
  v12 = 1;
  if ( byte_1020D7F4 )
  {
    v1 = 3;
    goto LABEL_24;
  }
  sub_10016C80(147, 0xCu, &v38);
  sub_10016C80(129, 0x11u, &v13);
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  sub_10030450(2000, &v20, 29, &v30);
  LOWORD(a1) = v20;
  if ( (_WORD)v20 != (_WORD)v13
    || v23 != v16
    || v24 != v17
    || (LOWORD(a1) = v25, v25 != v18)
    || (LOBYTE(a1) = v26, v26 != v19) )
  {
LABEL_22:
    v1 = 2;
LABEL_24:
    v12 = v1;
    goto LABEL_25;
  }
  v2 = 12;
  a1 = &v38;
  v3 = &v27;
  do
  {
    if ( *v3 != *a1 )
      goto LABEL_11;
    v2 -= 4;
    ++a1;
    ++v3;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_20:
    v10 = 0;
    goto LABEL_21;
  }
LABEL_11:
  v4 = *(_BYTE *)v3 - *(_BYTE *)a1;
  if ( *(_BYTE *)v3 == *(_BYTE *)a1 )
  {
    v5 = v2 - 1;
    a1 = (int *)((char *)a1 + 1);
    v6 = (char *)v3 + 1;
    if ( !v5 )
      goto LABEL_20;
    v4 = *v6 - *(_BYTE *)a1;
    if ( *v6 == *(_BYTE *)a1 )
    {
      v7 = v5 - 1;
      a1 = (int *)((char *)a1 + 1);
      v8 = v6 + 1;
      if ( !v7 )
        goto LABEL_20;
      v4 = *v8 - *(_BYTE *)a1;
      if ( *v8 == *(_BYTE *)a1 )
      {
        a1 = (int *)((char *)a1 + 1);
        v9 = v8 + 1;
        if ( v7 == 1 )
          goto LABEL_20;
        v4 = *v9 - *(_BYTE *)a1;
        if ( *v9 == *(_BYTE *)a1 )
          goto LABEL_20;
      }
    }
  }
  v10 = 1;
  if ( v4 <= 0 )
    v10 = -1;
LABEL_21:
  if ( v10 )
    goto LABEL_22;
LABEL_25:
  result = sub_10014F70(a1);
  if ( !result || result == 3 )
    result = sub_10015690(v12);
  if ( v1 == 2 )
  {
    v22 = v15;
    v20 = v13;
    v21 = v14;
    v27 = v38;
    v25 = v18;
    v26 = v19;
    v28 = v39;
    v29 = v40;
    result = sub_100304C0(2000, (int)&v20, 29);
  }
  return result;
}
// 1020D7F4: using guessed type char byte_1020D7F4;

//----- (10016F00) --------------------------------------------------------
char sub_10016F00()
{
  int *v0; // ecx@1

  sub_10016B50(0x9C40u);
  sub_100143C0(&off_1005A730);
  return sub_10016CE0(v0);
}
// 1005A730: using guessed type int (__cdecl *off_1005A730)(int, size_t, void *);

//----- (10016F20) --------------------------------------------------------
int __cdecl sub_10016F20(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10014DE0(&a1, 1u, (int)&unk_1005C1C0, 8, 67, 0);
  if ( v1 )
  {
    result = dword_1005C1C4[2 * v1];
  }
  else
  {
    sub_10014D70("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 1932, 0, 0);
    result = 0;
  }
  return result;
}
// 1005C1C4: using guessed type int dword_1005C1C4[];

//----- (10016F70) --------------------------------------------------------
char __cdecl sub_10016F70(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int (__cdecl *v7)(int, int, int, int, int, int); // eax@2

  v6 = sub_10014DE0(&a1, 1u, (int)&unk_1005BE20, 16, 58, 57);
  if ( v6 == 57 )
  {
    sub_10014D70("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 2231, 0, 0);
  }
  else
  {
    v7 = (int (__cdecl *)(int, int, int, int, int, int))dword_1005BE24[4 * v6];
    if ( v7 )
      return v7(a1, a2, a3, a4, a5, a6);
  }
  return 0;
}
// 1005BE24: using guessed type int dword_1005BE24[];

//----- (10016FE0) --------------------------------------------------------
signed int sub_10016FE0()
{
  signed int result; // eax@1

  result = -15;
  dword_10153140 = -15;
  dword_10153144 = -15;
  return result;
}
// 10153140: using guessed type int dword_10153140;
// 10153144: using guessed type int dword_10153144;

//----- (10016FF0) --------------------------------------------------------
signed int sub_10016FF0()
{
  return sub_100312F0((int)&off_1005C418);
}
// 1005C418: using guessed type char *off_1005C418;

//----- (10017000) --------------------------------------------------------
signed int sub_10017000()
{
  return sub_100312F0((int)&off_1005C42C);
}
// 1005C42C: using guessed type char *off_1005C42C;

//----- (10017010) --------------------------------------------------------
char __usercall sub_10017010@<al>(char a1@<bl>, int a2@<edi>, const void *a3@<esi>, char a4, char a5, char a6, unsigned int a7)
{
  char v7; // dl@12
  __int16 v9; // [sp+4h] [bp-528h]@1
  char v10; // [sp+8h] [bp-524h]@11
  char v11; // [sp+9h] [bp-523h]@11
  char v12; // [sp+Ah] [bp-522h]@11
  char v13; // [sp+Bh] [bp-521h]@11
  __int16 v14; // [sp+Ch] [bp-520h]@12
  char v15; // [sp+Eh] [bp-51Eh]@12
  char v16; // [sp+Fh] [bp-51Dh]@15
  unsigned int v17; // [sp+524h] [bp-8h]@15

  memset(&v9, 0, 0x524u);
  if ( (unsigned __int8)a1 >= 8u )
    sub_10014D70("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3425, 0, 0);
  if ( (unsigned __int8)a4 >= 0x39u )
    sub_10014D70("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3426, 0, 0);
  if ( (unsigned __int8)a5 >= 2u )
    sub_10014D70("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3427, 0, 0);
  if ( (unsigned __int8)a6 >= 0x2Cu )
    sub_10014D70("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3428, 0, 0);
  if ( a7 >= 0x514 )
    sub_10014D70("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3429, 0, 0);
  v13 = a6;
  v9 = -32749;
  v10 = a1;
  v11 = a4;
  v12 = a5;
  if ( a2 )
  {
    v7 = *(_BYTE *)(a2 + 2);
    v14 = *(_WORD *)a2;
    v15 = v7;
  }
  else
  {
    v14 = 0;
    v15 = 0;
  }
  if ( a3 )
  {
    memcpy(&v16, a3, a7);
    v17 = a7;
  }
  else
  {
    v17 = 0;
  }
  return sub_1001A230((int)&v9);
}

//----- (10017170) --------------------------------------------------------
char __cdecl sub_10017170(_BYTE *a1)
{
  char result; // al@2

  if ( (unsigned __int8)sub_10016FF0() == 1 )
  {
    *a1 = *(_BYTE *)dword_10153140;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10153140: using guessed type int dword_10153140;

//----- (100171A0) --------------------------------------------------------
char __cdecl sub_100171A0(unsigned __int8 a1, _BYTE *a2)
{
  char result; // al@3

  if ( (unsigned __int8)sub_10017000() != 1 || a1 >= 0x43u )
  {
    result = 0;
  }
  else
  {
    *a2 = *(_BYTE *)(a1 + dword_10153144);
    result = 1;
  }
  return result;
}
// 10153144: using guessed type int dword_10153144;

//----- (100171D0) --------------------------------------------------------
char __cdecl sub_100171D0(char a1, const void *a2)
{
  __int16 v3; // [sp+Ch] [bp-4h]@1
  char v4; // [sp+Eh] [bp-2h]@1

  v3 = 0;
  v4 = 0;
  return sub_10017010(1, (int)&v3, a2, a1, 0, 11, strlen((const char *)a2));
}

//----- (10017210) --------------------------------------------------------
void *__usercall sub_10017210@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>)
{
  void *result; // eax@1
  int v4; // [sp+0h] [bp-Ch]@0
  int v5; // [sp+4h] [bp-8h]@0
  int v6; // [sp+8h] [bp-4h]@0

  result = (void *)sub_100303F0(v4, v5, v6);
  if ( a2 == 6011 )
  {
    if ( result || *(_BYTE *)a3 > 0x3Fu )
    {
      *(_BYTE *)a3 = 63;
      result = (void *)sub_10030540(6011, (int)a3, a1);
    }
  }
  else if ( result )
  {
    result = memset(a3, 204, a1);
  }
  return result;
}

//----- (10017260) --------------------------------------------------------
signed int sub_10017260()
{
  int v0; // edi@5
  void *v1; // esi@5
  signed int v2; // ebp@5
  signed int result; // eax@7
  char v4; // [sp+13h] [bp-1h]@1

  dword_1020D810 = 0;
  v4 = 0;
  sub_10031450(94, &v4);
  if ( v4 == 3 )
  {
    v4 = 1;
    sub_100304C0(3201, (int)&v4, 1);
    sub_10031480(94, (int)&v4);
  }
  else if ( v4 == 2 )
  {
    v4 = 0;
    sub_100304C0(3201, (int)&v4, 1);
    sub_10031480(94, (int)&v4);
  }
  sub_10017210(1u, 6011, &unk_10153148);
  sub_10017210(0x16u, 6194, &unk_10153149);
  sub_10017210(1u, 6012, &unk_1015315F);
  sub_10017210(1u, 6013, &unk_10153160);
  sub_10017210(1u, 6014, &unk_10153161);
  sub_10017210(1u, 6015, &unk_10153162);
  sub_10017210(4u, 6078, &unk_10153164);
  sub_10017210(4u, 6104, &unk_10153168);
  sub_10017210(0x20u, 6016, &unk_1015316C);
  sub_10017210(0x20u, 6017, &unk_1015318C);
  sub_10017210(0x20u, 6018, &unk_101531AC);
  sub_10017210(0x20u, 6019, &unk_101531CC);
  sub_10017210(0x20u, 6020, &unk_101531EC);
  sub_10017210(0x20u, 6021, &unk_1015320C);
  sub_10017210(0x20u, 6022, &unk_1015322C);
  sub_10017210(0x20u, 6023, &unk_1015324C);
  sub_10017210(0x20u, 6024, &unk_1015326C);
  sub_10017210(0x20u, 6025, &unk_1015328C);
  sub_10017210(0x20u, 6026, &unk_101532AC);
  sub_10017210(0x20u, 6027, &unk_101532CC);
  sub_10017210(0x20u, 6028, &unk_101532EC);
  sub_10017210(0x20u, 6029, &unk_1015330C);
  sub_10017210(0x20u, 6030, &unk_1015332C);
  sub_10017210(0x20u, 6031, &unk_1015334C);
  sub_10017210(0x20u, 6032, &unk_1015336C);
  sub_10017210(0x20u, 6033, &unk_1015338C);
  sub_10017210(0x20u, 6034, &unk_101533AC);
  sub_10017210(0x20u, 6035, &unk_101533CC);
  sub_10017210(0x20u, 6036, &unk_101533EC);
  sub_10017210(0x20u, 6037, &unk_1015340C);
  sub_10017210(0x20u, 6038, &unk_1015342C);
  sub_10017210(0x20u, 6039, &unk_1015344C);
  sub_10017210(0x20u, 6040, &unk_1015346C);
  sub_10017210(0x20u, 6041, &unk_1015348C);
  sub_10017210(0x20u, 6042, &unk_101534AC);
  sub_10017210(0x20u, 6043, &unk_101534CC);
  sub_10017210(4u, 6044, &unk_101534EC);
  sub_10017210(4u, 6045, &unk_101534F0);
  sub_10017210(4u, 6046, &unk_101534F4);
  sub_10017210(4u, 6357, &unk_101534F8);
  sub_10017210(4u, 6358, &unk_101534FC);
  sub_10017210(4u, 6359, &unk_10153500);
  sub_10017210(0x20u, 6047, &unk_10153504);
  sub_10017210(0x20u, 6048, &unk_10153524);
  sub_10017210(0x20u, 6049, &unk_10153544);
  sub_10017210(0x20u, 6050, &unk_10153564);
  sub_10017210(0x20u, 6051, &unk_10153584);
  sub_10017210(0x20u, 6052, &unk_101535A4);
  sub_10017210(0x20u, 6053, &unk_101535C4);
  sub_10017210(0x20u, 6054, &unk_101535E4);
  sub_10017210(1u, 6511, &unk_10153604);
  sub_10017210(1u, 6522, &unk_10153605);
  sub_10017210(1u, 6057, &unk_10153606);
  sub_10017210(0x20u, 6075, &unk_10153658);
  sub_10017210(0x20u, 6076, &unk_10153678);
  sub_10017210(1u, 6077, &unk_10153698);
  sub_10017210(4u, 6079, &unk_1015369C);
  sub_10017210(4u, 6080, &unk_101536A0);
  sub_10017210(0x20u, 6082, &unk_101536A4);
  sub_10017210(0x20u, 6083, &unk_101536C4);
  sub_10017210(0x20u, 6084, &unk_101536E4);
  sub_10017210(0x20u, 6085, &unk_10153704);
  sub_10017210(0x20u, 6086, &unk_10153724);
  sub_10017210(0x20u, 6087, &unk_10153744);
  sub_10017210(0x20u, 6088, &unk_10153764);
  sub_10017210(0x20u, 6089, &unk_10153784);
  sub_10017210(0x20u, 6123, &unk_101537A4);
  sub_10017210(0x48u, 6906, &unk_101537C4);
  sub_10017210(0x48u, 6907, &unk_1015380C);
  sub_10017210(0x48u, 6908, &unk_10153854);
  sub_10017210(0x48u, 6909, &unk_1015389C);
  sub_10017210(0x48u, 6910, &unk_101538E4);
  sub_10017210(0x48u, 6911, &unk_1015392C);
  sub_10017210(0x48u, 6912, &unk_10153974);
  sub_10017210(0x48u, 6913, &unk_101539BC);
  sub_10017210(0x48u, 6914, &unk_10153A04);
  sub_10017210(0x48u, 6915, &unk_10153A4C);
  sub_10017210(0x48u, 6916, &unk_10153A94);
  sub_10017210(0x48u, 6917, &unk_10153ADC);
  sub_10017210(0x48u, 6918, &unk_10153B24);
  sub_10017210(0x48u, 6919, &unk_10153B6C);
  sub_10017210(0x48u, 6920, &unk_10153BB4);
  sub_10017210(0x48u, 6921, &unk_10153BFC);
  sub_10017210(0x48u, 6922, &unk_10153C44);
  sub_10017210(0x48u, 6923, &unk_10153C8C);
  sub_10017210(0x48u, 6924, &unk_10153CD4);
  sub_10017210(0x48u, 6925, &unk_10153D1C);
  sub_10017210(0x48u, 6926, &unk_10153D64);
  sub_10017210(0x48u, 6927, &unk_10153DAC);
  sub_10017210(0x48u, 6928, &unk_10153DF4);
  sub_10017210(0x48u, 6929, &unk_10153E3C);
  sub_10017210(0x48u, 6930, &unk_10153E84);
  sub_10017210(0x48u, 6931, &unk_10153ECC);
  sub_10017210(0x48u, 6932, &unk_10153F14);
  sub_10017210(0x48u, 6933, &unk_10153F5C);
  sub_10017210(0x48u, 6934, &unk_10153FA4);
  sub_10017210(0x48u, 6935, &unk_10153FEC);
  sub_10017210(0x18u, 6163, &unk_10154034);
  sub_10017210(0x20u, 6164, &unk_1015404C);
  sub_10017210(0x20u, 6165, &unk_1015406C);
  sub_10017210(2u, 6166, &unk_1015408C);
  sub_10017210(0xA4u, 40100, &unk_10154090);
  sub_10017210(0xA4u, 40101, &unk_10154134);
  sub_10017210(0xA4u, 40102, &unk_101541D8);
  sub_10017210(0xA4u, 40103, &unk_1015427C);
  sub_10017210(0xA4u, 40104, &unk_10154320);
  sub_10017210(0xA4u, 40105, &unk_101543C4);
  sub_10017210(0xA4u, 40106, &unk_10154468);
  sub_10017210(0xA4u, 40107, &unk_1015450C);
  sub_10017210(0xA4u, 40108, &unk_101545B0);
  sub_10017210(0xA4u, 40109, &unk_10154654);
  sub_10017210(0xA4u, 40110, &unk_101546F8);
  sub_10017210(0xA4u, 40111, &unk_1015479C);
  sub_10017210(0xA4u, 40112, &unk_10154840);
  sub_10017210(0xA4u, 40113, &unk_101548E4);
  sub_10017210(0xA4u, 40114, &unk_10154988);
  sub_10017210(0xA4u, 40115, &unk_10154A2C);
  sub_10017210(0xA4u, 40116, &unk_10154AD0);
  sub_10017210(0xA4u, 40117, &unk_10154B74);
  sub_10017210(0xA4u, 40118, &unk_10154C18);
  sub_10017210(0xA4u, 40119, &unk_10154CBC);
  sub_10017210(0xA4u, 40120, &unk_10154D60);
  sub_10017210(0xA4u, 40121, &unk_10154E04);
  sub_10017210(0xA4u, 40122, &unk_10154EA8);
  sub_10017210(0xA4u, 40123, &unk_10154F4C);
  sub_10017210(0xA4u, 40124, &unk_10154FF0);
  sub_10017210(0xA4u, 40125, &unk_10155094);
  sub_10017210(0xA4u, 40126, &unk_10155138);
  sub_10017210(0xA4u, 40127, &unk_101551DC);
  sub_10017210(0xA4u, 40128, &unk_10155280);
  sub_10017210(0xA4u, 40129, &unk_10155324);
  sub_10017210(0xA4u, 40130, &unk_101553C8);
  sub_10017210(0xA4u, 40131, &unk_1015546C);
  sub_10017210(0xA4u, 40132, &unk_10155510);
  sub_10017210(0xA4u, 40133, &unk_101555B4);
  sub_10017210(0xA4u, 40134, &unk_10155658);
  sub_10017210(0xA4u, 40135, &unk_101556FC);
  sub_10017210(0xA4u, 40136, &unk_101557A0);
  sub_10017210(0xA4u, 40137, &unk_10155844);
  sub_10017210(0xA4u, 40138, &unk_101558E8);
  sub_10017210(0xA4u, 40139, &unk_1015598C);
  sub_10017210(0xA4u, 40140, &unk_10155A30);
  sub_10017210(0xA4u, 40141, &unk_10155AD4);
  sub_10017210(0xA4u, 40142, &unk_10155B78);
  sub_10017210(0xA4u, 40143, &unk_10155C1C);
  sub_10017210(0xA4u, 40144, &unk_10155CC0);
  sub_10017210(0xA4u, 40145, &unk_10155D64);
  sub_10017210(0xA4u, 40146, &unk_10155E08);
  sub_10017210(0xA4u, 40147, &unk_10155EAC);
  sub_10017210(0xA4u, 40148, &unk_10155F50);
  sub_10017210(0xA4u, 40149, &unk_10155FF4);
  sub_10017210(0xA4u, 40150, &unk_10156098);
  sub_10017210(0xA4u, 40151, &unk_1015613C);
  sub_10017210(0xA4u, 40152, &unk_101561E0);
  sub_10017210(0xA4u, 40153, &unk_10156284);
  sub_10017210(0xA4u, 40154, &unk_10156328);
  sub_10017210(0xA4u, 40155, &unk_101563CC);
  sub_10017210(0xA4u, 40156, &unk_10156470);
  sub_10017210(0xA4u, 40157, &unk_10156514);
  sub_10017210(0xA4u, 40158, &unk_101565B8);
  sub_10017210(0xA4u, 40159, &unk_1015665C);
  sub_10017210(0xA4u, 40160, &unk_10156700);
  sub_10017210(0xA4u, 40161, &unk_101567A4);
  sub_10017210(0xA4u, 40162, &unk_10156848);
  sub_10017210(0xA4u, 40163, &unk_101568EC);
  sub_10017210(0xA4u, 40164, &unk_10156990);
  sub_10017210(0xA4u, 40165, &unk_10156A34);
  sub_10017210(0xA4u, 40166, &unk_10156AD8);
  sub_10017210(0xA4u, 40167, &unk_10156B7C);
  sub_10017210(0xA4u, 40168, &unk_10156C20);
  sub_10017210(0xA4u, 40169, &unk_10156CC4);
  sub_10017210(0xA4u, 40170, &unk_10156D68);
  sub_10017210(0xA4u, 40171, &unk_10156E0C);
  sub_10017210(0xA4u, 40172, &unk_10156EB0);
  sub_10017210(0xA4u, 40173, &unk_10156F54);
  sub_10017210(0xA4u, 40174, &unk_10156FF8);
  sub_10017210(0xA4u, 40175, &unk_1015709C);
  sub_10017210(0xA4u, 40176, &unk_10157140);
  sub_10017210(0xA4u, 40177, &unk_101571E4);
  sub_10017210(0xA4u, 40178, &unk_10157288);
  sub_10017210(0xA4u, 40179, &unk_1015732C);
  sub_10017210(0xA4u, 40180, &unk_101573D0);
  sub_10017210(0xA4u, 40181, &unk_10157474);
  sub_10017210(0xA4u, 40182, &unk_10157518);
  sub_10017210(0xA4u, 40183, &unk_101575BC);
  sub_10017210(0xA4u, 40184, &unk_10157660);
  sub_10017210(0xA4u, 40185, &unk_10157704);
  sub_10017210(0xA4u, 40186, &unk_101577A8);
  sub_10017210(0xA4u, 40187, &unk_1015784C);
  sub_10017210(0xA4u, 40188, &unk_101578F0);
  sub_10017210(0xA4u, 40189, &unk_10157994);
  sub_10017210(0xA4u, 40190, &unk_10157A38);
  sub_10017210(0xA4u, 40191, &unk_10157ADC);
  sub_10017210(0xA4u, 40192, &unk_10157B80);
  sub_10017210(0xA4u, 40193, &unk_10157C24);
  sub_10017210(0xA4u, 40194, &unk_10157CC8);
  sub_10017210(0xA4u, 40195, &unk_10157D6C);
  sub_10017210(0xA4u, 40196, &unk_10157E10);
  sub_10017210(0xA4u, 40197, &unk_10157EB4);
  sub_10017210(0xA4u, 40198, &unk_10157F58);
  sub_10017210(0xA4u, 40199, &unk_10157FFC);
  sub_10017210(0x20u, 6190, &unk_101580A0);
  sub_10017210(0x20u, 6191, &unk_101580C0);
  sub_10017210(0x20u, 6192, &unk_101580E0);
  sub_10017210(0x20u, 6199, &unk_10158100);
  sub_10017210(0x28u, 6207, &unk_10158120);
  sub_10017210(4u, 6231, &unk_10158C38);
  sub_10017210(4u, 6232, &unk_10158C3C);
  sub_10017210(4u, 6233, &unk_10158C40);
  sub_10017210(4u, 6234, &unk_10158C44);
  sub_10017210(0x1Cu, 40000, &unk_10158148);
  sub_10017210(0x1Cu, 40001, &unk_10158164);
  sub_10017210(0x1Cu, 40002, &unk_10158180);
  sub_10017210(0x1Cu, 40003, &unk_1015819C);
  sub_10017210(0x1Cu, 40004, &unk_101581B8);
  sub_10017210(0x1Cu, 40005, &unk_101581D4);
  sub_10017210(0x1Cu, 40006, &unk_101581F0);
  sub_10017210(0x1Cu, 40007, &unk_1015820C);
  sub_10017210(0x1Cu, 40008, &unk_10158228);
  sub_10017210(0x1Cu, 40009, &unk_10158244);
  sub_10017210(0x1Cu, 40010, &unk_10158260);
  sub_10017210(0x1Cu, 40011, &unk_1015827C);
  sub_10017210(0x1Cu, 40012, &unk_10158298);
  sub_10017210(0x1Cu, 40013, &unk_101582B4);
  sub_10017210(0x1Cu, 40014, &unk_101582D0);
  sub_10017210(0x1Cu, 40015, &unk_101582EC);
  sub_10017210(0x1Cu, 40016, &unk_10158308);
  sub_10017210(0x1Cu, 40017, &unk_10158324);
  sub_10017210(0x1Cu, 40018, &unk_10158340);
  sub_10017210(0x1Cu, 40019, &unk_1015835C);
  sub_10017210(0x1Cu, 40020, &unk_10158378);
  sub_10017210(0x1Cu, 40021, &unk_10158394);
  sub_10017210(0x1Cu, 40022, &unk_101583B0);
  sub_10017210(0x1Cu, 40023, &unk_101583CC);
  sub_10017210(0x1Cu, 40024, &unk_101583E8);
  sub_10017210(0x1Cu, 40025, &unk_10158404);
  sub_10017210(0x1Cu, 40026, &unk_10158420);
  sub_10017210(0x1Cu, 40027, &unk_1015843C);
  sub_10017210(0x1Cu, 40028, &unk_10158458);
  sub_10017210(0x1Cu, 40029, &unk_10158474);
  sub_10017210(0x1Cu, 40030, &unk_10158490);
  sub_10017210(0x1Cu, 40031, &unk_101584AC);
  sub_10017210(0x1Cu, 40032, &unk_101584C8);
  sub_10017210(0x1Cu, 40033, &unk_101584E4);
  sub_10017210(0x1Cu, 40034, &unk_10158500);
  sub_10017210(0x1Cu, 40035, &unk_1015851C);
  sub_10017210(0x1Cu, 40036, &unk_10158538);
  sub_10017210(0x1Cu, 40037, &unk_10158554);
  sub_10017210(0x1Cu, 40038, &unk_10158570);
  sub_10017210(0x1Cu, 40039, &unk_1015858C);
  sub_10017210(0x1Cu, 40040, &unk_101585A8);
  sub_10017210(0x1Cu, 40041, &unk_101585C4);
  sub_10017210(0x1Cu, 40042, &unk_101585E0);
  sub_10017210(0x1Cu, 40043, &unk_101585FC);
  sub_10017210(0x1Cu, 40044, &unk_10158618);
  sub_10017210(0x1Cu, 40045, &unk_10158634);
  sub_10017210(0x1Cu, 40046, &unk_10158650);
  sub_10017210(0x1Cu, 40047, &unk_1015866C);
  sub_10017210(0x1Cu, 40048, &unk_10158688);
  sub_10017210(0x1Cu, 40049, &unk_101586A4);
  sub_10017210(0x1Cu, 40050, &unk_101586C0);
  sub_10017210(0x1Cu, 40051, &unk_101586DC);
  sub_10017210(0x1Cu, 40052, &unk_101586F8);
  sub_10017210(0x1Cu, 40053, &unk_10158714);
  sub_10017210(0x1Cu, 40054, &unk_10158730);
  sub_10017210(0x1Cu, 40055, &unk_1015874C);
  sub_10017210(0x1Cu, 40056, &unk_10158768);
  sub_10017210(0x1Cu, 40057, &unk_10158784);
  sub_10017210(0x1Cu, 40058, &unk_101587A0);
  sub_10017210(0x1Cu, 40059, &unk_101587BC);
  sub_10017210(0x1Cu, 40060, &unk_101587D8);
  sub_10017210(0x1Cu, 40061, &unk_101587F4);
  sub_10017210(0x1Cu, 40062, &unk_10158810);
  sub_10017210(0x1Cu, 40063, &unk_1015882C);
  sub_10017210(0x1Cu, 40064, &unk_10158848);
  sub_10017210(0x1Cu, 40065, &unk_10158864);
  sub_10017210(0x1Cu, 40066, &unk_10158880);
  sub_10017210(0x1Cu, 40067, &unk_1015889C);
  sub_10017210(0x1Cu, 40068, &unk_101588B8);
  sub_10017210(0x1Cu, 40069, &unk_101588D4);
  sub_10017210(0x1Cu, 40070, &unk_101588F0);
  sub_10017210(0x1Cu, 40071, &unk_1015890C);
  sub_10017210(0x1Cu, 40072, &unk_10158928);
  sub_10017210(0x1Cu, 40073, &unk_10158944);
  sub_10017210(0x1Cu, 40074, &unk_10158960);
  sub_10017210(0x1Cu, 40075, &unk_1015897C);
  sub_10017210(0x1Cu, 40076, &unk_10158998);
  sub_10017210(0x1Cu, 40077, &unk_101589B4);
  sub_10017210(0x1Cu, 40078, &unk_101589D0);
  sub_10017210(0x1Cu, 40079, &unk_101589EC);
  sub_10017210(0x1Cu, 40080, &unk_10158A08);
  sub_10017210(0x1Cu, 40081, &unk_10158A24);
  sub_10017210(0x1Cu, 40082, &unk_10158A40);
  sub_10017210(0x1Cu, 40083, &unk_10158A5C);
  sub_10017210(0x1Cu, 40084, &unk_10158A78);
  sub_10017210(0x1Cu, 40085, &unk_10158A94);
  sub_10017210(0x1Cu, 40086, &unk_10158AB0);
  sub_10017210(0x1Cu, 40087, &unk_10158ACC);
  sub_10017210(0x1Cu, 40088, &unk_10158AE8);
  sub_10017210(0x1Cu, 40089, &unk_10158B04);
  sub_10017210(0x1Cu, 40090, &unk_10158B20);
  sub_10017210(0x1Cu, 40091, &unk_10158B3C);
  sub_10017210(0x1Cu, 40092, &unk_10158B58);
  sub_10017210(0x1Cu, 40093, &unk_10158B74);
  sub_10017210(0x1Cu, 40094, &unk_10158B90);
  sub_10017210(0x1Cu, 40095, &unk_10158BAC);
  sub_10017210(0x1Cu, 40096, &unk_10158BC8);
  sub_10017210(0x1Cu, 40097, &unk_10158BE4);
  sub_10017210(0x1Cu, 40098, &unk_10158C00);
  sub_10017210(0x1Cu, 40099, &unk_10158C1C);
  sub_10017210(4u, 6238, &unk_10158C48);
  sub_10017210(4u, 6239, &unk_10158C4C);
  sub_10017210(4u, 6240, &unk_10158C50);
  sub_10017210(4u, 6242, &unk_10158C54);
  sub_10017210(4u, 6244, &unk_10158C58);
  sub_10017210(4u, 6245, &unk_10158C5C);
  sub_10017210(4u, 6246, &unk_10158C60);
  sub_10017210(4u, 6251, &unk_10158C64);
  sub_10017210(4u, 6252, &unk_10158C68);
  sub_10017210(4u, 6253, &unk_10158C6C);
  sub_10017210(4u, 6254, &unk_10158C70);
  sub_10017210(1u, 6255, &unk_10158C74);
  sub_10017210(4u, 6256, &unk_10158C78);
  sub_10017210(4u, 6257, &unk_10158C7C);
  sub_10017210(0xE2u, 6286, &unk_10158C80);
  v0 = 18000;
  v1 = &unk_10158D64;
  v2 = 16;
  do
  {
    sub_10017210(0x11Cu, v0, v1);
    v1 = (char *)v1 + 284;
    ++v0;
    --v2;
  }
  while ( v2 );
  sub_10017210(4u, 6262, &unk_10159F24);
  sub_10017210(0x28u, 6263, &unk_10159F28);
  sub_10017210(0x28u, 6264, &unk_10159F50);
  sub_10017210(0x40u, 6268, &unk_10159F78);
  sub_10017210(4u, 6272, &unk_1015A038);
  sub_10017210(4u, 6273, &unk_1015A03C);
  sub_10017210(1u, 6274, &unk_1015A040);
  sub_10017210(2u, 6275, &unk_1015A042);
  sub_10017210(1u, 6276, &unk_1015A044);
  sub_10017210(1u, 6277, &unk_1015A045);
  sub_10017210(1u, 6278, &unk_1015A046);
  sub_10017210(0x40u, 6279, &unk_1015A048);
  sub_10017210(0x28u, 6753, &unk_1015AEFD);
  sub_10017210(0x30u, 6754, &unk_1015AF28);
  sub_10017210(0x28u, 6958, &unk_1015AF58);
  sub_10017210(0x80u, 6802, &unk_10159FB8);
  sub_10017210(1u, 6760, &unk_1015AF80);
  sub_10017210(0x10u, 6312, &unk_1015A3CC);
  sub_10017210(0x10u, 6313, &unk_1015A3DC);
  sub_10017210(0x10u, 6314, &unk_1015A3EC);
  sub_10017210(1u, 6307, &unk_1015A3FC);
  sub_10017210(1u, 6308, &unk_1015A3FD);
  sub_10017210(1u, 6309, &unk_1015A3FE);
  sub_10017210(4u, 6285, &unk_1015A400);
  sub_10017210(0xA8u, 6318, &unk_1015A404);
  sub_10017210(4u, 6319, &unk_1015A4AC);
  sub_10017210(1u, 6350, &unk_1015A4B0);
  sub_10017210(0x50u, 6351, &unk_1015A4B4);
  sub_10017210(4u, 6352, &unk_1015A504);
  sub_10017210(4u, 6353, &unk_1015A508);
  sub_10017210(0x54u, 6448, &unk_1015A754);
  sub_10017210(0x54u, 6449, &unk_1015A7A8);
  sub_10017210(8u, 6287, &unk_1015A0AC);
  sub_10017210(8u, 6288, &unk_1015A0B4);
  sub_10017210(8u, 6289, &unk_1015A0BC);
  sub_10017210(8u, 6290, &unk_1015A0C4);
  sub_10017210(8u, 6291, &unk_1015A0CC);
  sub_10017210(8u, 6292, &unk_1015A0D4);
  sub_10017210(8u, 6293, &unk_1015A0DC);
  sub_10017210(8u, 6294, &unk_1015A0E4);
  sub_10017210(8u, 6295, &unk_1015A0EC);
  sub_10017210(8u, 6296, &unk_1015A0F4);
  sub_10017210(8u, 6297, &unk_1015A0FC);
  sub_10017210(8u, 6298, &unk_1015A104);
  sub_10017210(8u, 6299, &unk_1015A10C);
  sub_10017210(8u, 6300, &unk_1015A114);
  sub_10017210(8u, 6301, &unk_1015A11C);
  sub_10017210(8u, 6302, &unk_1015A124);
  sub_10017210(8u, 6303, &unk_1015A12C);
  sub_10017210(8u, 6304, &unk_1015A134);
  sub_10017210(8u, 6305, &unk_1015A13C);
  sub_10017210(8u, 6306, &unk_1015A144);
  sub_10017210(8u, 6409, &unk_1015A14C);
  sub_10017210(8u, 6410, &unk_1015A154);
  sub_10017210(8u, 6411, &unk_1015A15C);
  sub_10017210(8u, 6412, &unk_1015A164);
  sub_10017210(8u, 6413, &unk_1015A16C);
  sub_10017210(8u, 6414, &unk_1015A174);
  sub_10017210(8u, 6415, &unk_1015A17C);
  sub_10017210(8u, 6416, &unk_1015A184);
  sub_10017210(8u, 6417, &unk_1015A18C);
  sub_10017210(8u, 6418, &unk_1015A194);
  sub_10017210(8u, 6419, &unk_1015A19C);
  sub_10017210(8u, 6420, &unk_1015A1A4);
  sub_10017210(8u, 6421, &unk_1015A1AC);
  sub_10017210(8u, 6422, &unk_1015A1B4);
  sub_10017210(8u, 6423, &unk_1015A1BC);
  sub_10017210(8u, 6424, &unk_1015A1C4);
  sub_10017210(8u, 6425, &unk_1015A1CC);
  sub_10017210(8u, 6426, &unk_1015A1D4);
  sub_10017210(8u, 6427, &unk_1015A1DC);
  sub_10017210(8u, 6428, &unk_1015A1E4);
  sub_10017210(4u, 6429, &unk_1015A6EC);
  sub_10017210(8u, 6430, &unk_1015A6F0);
  sub_10017210(8u, 6431, &unk_1015A6F8);
  sub_10017210(8u, 6432, &unk_1015A700);
  sub_10017210(8u, 6433, &unk_1015A708);
  sub_10017210(8u, 6434, &unk_1015A710);
  sub_10017210(8u, 6435, &unk_1015A718);
  sub_10017210(8u, 6436, &unk_1015A720);
  sub_10017210(8u, 6437, &unk_1015A728);
  sub_10017210(8u, 6438, &unk_1015A730);
  sub_10017210(8u, 6439, &unk_1015A738);
  sub_10017210(8u, 6440, &unk_1015A740);
  sub_10017210(0xAu, 6519, &unk_1015ABAC);
  sub_10017210(4u, 6442, &unk_1015A748);
  sub_10017210(4u, 6443, &unk_1015A74C);
  sub_10017210(0xF0u, 6367, &unk_1015A50C);
  sub_10017210(0xF0u, 6368, &unk_1015A5FC);
  sub_10017210(1u, 6446, &unk_1015A750);
  sub_10017210(6u, 6452, &unk_1015A7FC);
  sub_10017210(4u, 6457, &unk_1015A804);
  sub_10017210(4u, 6458, &unk_1015A808);
  sub_10017210(4u, 6459, &unk_1015A80C);
  sub_10017210(4u, 6460, &unk_1015A810);
  sub_10017210(0x208u, 6515, &unk_1015A814);
  sub_10017210(0x160u, 6516, &unk_1015AA1C);
  sub_10017210(0x18u, 6517, &unk_1015AB7C);
  sub_10017210(0x18u, 6518, &unk_1015AB94);
  sub_10017210(1u, 6520, &unk_1015ABB6);
  sub_10017210(0x10u, 6521, &unk_1015ABB8);
  sub_10017210(4u, 6523, &unk_1015ABC8);
  sub_10017210(4u, 6524, &unk_1015ABCC);
  sub_10017210(4u, 6525, &unk_1015ABD0);
  sub_10017210(1u, 6526, &unk_1015ABD4);
  sub_10017210(1u, 6527, &unk_1015ABD5);
  sub_10017210(0x50u, 6528, &unk_1015ABD8);
  sub_10017210(4u, 6529, &unk_1015AC28);
  sub_10017210(1u, 6530, &unk_1015AC2C);
  sub_10017210(1u, 6531, &unk_1015AC2D);
  sub_10017210(1u, 6532, &unk_1015AC2E);
  sub_10017210(0x14u, 6533, &unk_1015AC2F);
  sub_10017210(0xAu, 6883, &unk_1015B348);
  sub_10017210(0xAu, 6884, &unk_1015B352);
  sub_10017210(0xAu, 6885, &unk_1015B35C);
  sub_10017210(1u, 6664, &unk_1015AC43);
  sub_10017210(1u, 6666, &unk_1015AC44);
  sub_10017210(1u, 6667, &unk_1015AC45);
  sub_10017210(1u, 6668, &unk_1015AC46);
  sub_10017210(0xA0u, 6669, &unk_1015AC48);
  sub_10017210(2u, 6670, &unk_1015AD38);
  sub_10017210(4u, 6671, &unk_1015AD3C);
  sub_10017210(4u, 6672, &unk_1015AD40);
  sub_10017210(4u, 6673, &unk_1015AD44);
  sub_10017210(4u, 6674, &unk_1015AD48);
  sub_10017210(4u, 6675, &unk_1015AD4C);
  sub_10017210(4u, 6676, &unk_1015AD54);
  sub_10017210(4u, 6677, &unk_1015AD5C);
  sub_10017210(4u, 6678, &unk_1015AD60);
  sub_10017210(1u, 6679, &unk_1015AD64);
  sub_10017210(0x140u, 6680, &unk_1015AD68);
  sub_10017210(4u, 6882, &unk_1015B344);
  sub_10017210(0xCu, 6652, &unk_1015AEA8);
  sub_10017210(0x48u, 6653, &unk_1015AEB4);
  sub_10017210(1u, 6688, &unk_1015AEFC);
  sub_10017210(4u, 6771, &unk_1015AF84);
  sub_10017210(4u, 6772, &unk_1015AF88);
  sub_10017210(8u, 6787, &unk_1015AF8C);
  sub_10017210(1u, 6832, &unk_1015AFBC);
  sub_10017210(1u, 6833, &unk_1015AFBD);
  sub_10017210(1u, 6834, &unk_1015AFBE);
  sub_10017210(4u, 6835, &unk_1015AFC0);
  sub_10017210(4u, 6836, &unk_1015AFC4);
  sub_10017210(4u, 6837, &unk_1015AFC8);
  sub_10017210(4u, 6838, &unk_1015AFCC);
  sub_10017210(1u, 6839, &unk_1015AFD0);
  sub_10017210(0x50u, 6840, &unk_1015ACE8);
  sub_10017210(4u, 6841, &unk_1015AFD4);
  sub_10017210(4u, 6842, &unk_1015AFD8);
  sub_10017210(4u, 6843, &unk_1015AFDC);
  sub_10017210(1u, 6844, &unk_1015AFE0);
  sub_10017210(0x360u, 6845, &unk_1015AFE4);
  sub_10017210(4u, 6846, &unk_1015AD50);
  sub_10017210(4u, 6847, &unk_1015AD58);
  result = 1;
  dword_1020D810 = (int)&unk_10153148;
  return result;
}
// 1020D810: using guessed type int dword_1020D810;

//----- (10019060) --------------------------------------------------------
int sub_10019060()
{
  int result; // eax@1

  result = 0;
  dword_1015CB18 = -15;
  dword_1020D80C = 0;
  dword_1020D800 = 0;
  dword_1020D804 = 0;
  dword_1020D808 = 0;
  return result;
}
// 1015CB18: using guessed type int dword_1015CB18;
// 1020D800: using guessed type int dword_1020D800;
// 1020D804: using guessed type int dword_1020D804;
// 1020D808: using guessed type int dword_1020D808;
// 1020D80C: using guessed type int dword_1020D80C;

//----- (10019090) --------------------------------------------------------
char sub_10019090()
{
  char v0; // bl@1
  signed int v1; // esi@2
  char result; // al@4

  v0 = sub_100312F0((int)&off_1005FD30);
  if ( v0 )
  {
    dword_1020D80C = dword_1015CB18;
    v1 = *(_BYTE *)(dword_1015CB18 + 667) != 0 ? 1100 : 2000;
    if ( v1 + *(_DWORD *)(dword_1020D80C + 36) < (unsigned int)sub_10030040() )
      v0 = 0;
    dword_1020D808 = dword_1015CB18 + 56116;
    result = v0;
    dword_1020D800 = dword_1015CB18 + 1516;
    dword_1020D804 = dword_1015CB18 + 20484;
  }
  else
  {
    dword_1020D80C = 0;
    dword_1020D800 = 0;
    dword_1020D804 = 0;
    dword_1020D808 = 0;
    result = 0;
  }
  return result;
}
// 1005FD30: using guessed type char *off_1005FD30;
// 1015CB18: using guessed type int dword_1015CB18;
// 1020D800: using guessed type int dword_1020D800;
// 1020D804: using guessed type int dword_1020D804;
// 1020D808: using guessed type int dword_1020D808;
// 1020D80C: using guessed type int dword_1020D80C;

//----- (10019130) --------------------------------------------------------
void *sub_10019130()
{
  dword_1020D7F8 = -15;
  return sub_10022270();
}
// 1020D7F8: using guessed type int dword_1020D7F8;

//----- (10019140) --------------------------------------------------------
signed int sub_10019140()
{
  return 1000;
}

//----- (10019170) --------------------------------------------------------
int sub_10019170()
{
  return sub_1001FCB0((int)off_100607F8);
}
// 100607F8: using guessed type int (*off_100607F8[4])();

//----- (100191B0) --------------------------------------------------------
char __cdecl sub_100191B0(int a1, int a2, unsigned __int16 a3)
{
  char result; // al@2
  int v4; // [sp+0h] [bp-18h]@2
  int v5; // [sp+4h] [bp-14h]@2
  int v6; // [sp+8h] [bp-10h]@2
  int v7; // [sp+Ch] [bp-Ch]@2
  int v8; // [sp+10h] [bp-8h]@2

  if ( a3 < 0x4Cu )
  {
    v5 = 0;
    LOWORD(v5) = a3;
    v4 = 0;
    v7 = 0;
    LOWORD(v4) = 3;
    v6 = a2;
    v8 = a1;
    sub_1000E800(5, 0, &v4, 0, 20, 1);
    result = sub_1000E9B0(5, 0, a1);
  }
  return result;
}

//----- (10019230) --------------------------------------------------------
char *__cdecl sub_10019230(int a1)
{
  char *result; // eax@2

  if ( (unsigned int)(a1 + 61) > 0x3C )
    result = 0;
  else
    result = off_10061730[-a1];
  return result;
}
// 10061730: using guessed type char *off_10061730[62];

//----- (10019250) --------------------------------------------------------
char __cdecl sub_10019250(_BYTE *a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  void *v3; // ecx@1
  char result; // al@2
  void *v5; // ecx@3
  __int16 v6; // [sp+8h] [bp-298h]@1
  int v7; // [sp+Ch] [bp-294h]@1
  char v8; // [sp+10h] [bp-290h]@1
  char v9; // [sp+D4h] [bp-1CCh]@1
  char v10; // [sp+198h] [bp-108h]@1
  char v11; // [sp+199h] [bp-107h]@1

  v2 = sub_10015650(v1);
  v6 = -32599;
  v7 = 0;
  sub_10015290((int)&v8, a1, 64);
  v9 = 8;
  v10 = 0;
  memset(&v11, 0, 0x100u);
  if ( v2 == 2 )
  {
    result = sub_100301C0(3, (int)&v6, 1000, 1);
  }
  else if ( sub_10015670(v3) == 1 || sub_10014FA0(v5) & 3 )
  {
    if ( sub_100155B0(v5) )
    {
      result = sub_100301C0(1, (int)&v6, 1000, 1);
    }
    else
    {
      sub_10015290((int)&v11, "No available cycles on this page.", 256);
      result = sub_10022310(&v9);
    }
  }
  else
  {
    result = sub_100301C0(9, (int)&v6, 1000, 1);
  }
  return result;
}

//----- (100193A0) --------------------------------------------------------
char __cdecl sub_100193A0(char a1, _BYTE *a2)
{
  void *v2; // ecx@0
  char v3; // bl@1
  void *v4; // ecx@1
  char result; // al@2
  void *v6; // ecx@3
  __int16 v7; // [sp+8h] [bp-298h]@1
  int v8; // [sp+Ch] [bp-294h]@1
  char v9; // [sp+10h] [bp-290h]@1
  char v10; // [sp+11h] [bp-28Fh]@1
  char v11; // [sp+D4h] [bp-1CCh]@1
  char v12; // [sp+198h] [bp-108h]@1
  char v13; // [sp+199h] [bp-107h]@1

  v3 = sub_10015650(v2);
  v7 = -32595;
  v8 = 0;
  v9 = a1;
  sub_10015290((int)&v10, a2, 64);
  v11 = 3;
  v12 = 0;
  memset(&v13, 0, 0x100u);
  if ( v3 == 2 )
  {
    result = sub_100301C0(3, (int)&v7, 1000, 1);
  }
  else if ( sub_10015670(v4) == 1 || sub_10014FA0(v6) & 3 )
  {
    if ( sub_100155B0(v6) )
    {
      result = sub_100301C0(1, (int)&v7, 1000, 1);
    }
    else
    {
      sub_10015290((int)&v13, "No available fields on this page.", 256);
      result = sub_10022310(&v11);
    }
  }
  else
  {
    result = sub_100301C0(9, (int)&v7, 1000, 1);
  }
  return result;
}

//----- (10019500) --------------------------------------------------------
char __thiscall sub_10019500(void *this)
{
  char v1; // bl@1
  void *v2; // ecx@1
  char result; // al@2
  void *v4; // ecx@3
  __int16 v5; // [sp+4h] [bp-298h]@1
  int v6; // [sp+8h] [bp-294h]@1
  char v7; // [sp+D0h] [bp-1CCh]@1
  char v8; // [sp+194h] [bp-108h]@1
  char v9; // [sp+195h] [bp-107h]@1

  v1 = sub_10015650(this);
  v6 = 0;
  v8 = 0;
  v5 = -32596;
  v7 = 5;
  memset(&v9, 0, 0x100u);
  if ( v1 == 2 )
  {
    result = sub_100301C0(3, (int)&v5, 1000, 1);
  }
  else if ( sub_10015670(v2) == 1 || sub_10014FA0(v4) & 3 )
  {
    sub_10015290((int)&v9, "This command is valid only for non-reversionary MFD or Config pages.", 256);
    result = sub_10022310(&v7);
  }
  else
  {
    result = sub_100301C0(9, (int)&v5, 1000, 1);
  }
  return result;
}

//----- (10019600) --------------------------------------------------------
char __cdecl sub_10019600(_BYTE *a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  char result; // al@2
  __int16 v4; // [sp+8h] [bp-298h]@1
  int v5; // [sp+Ch] [bp-294h]@1
  char v6; // [sp+10h] [bp-290h]@1
  char v7; // [sp+D4h] [bp-1CCh]@1
  char v8; // [sp+198h] [bp-108h]@1
  char v9; // [sp+199h] [bp-107h]@1

  v2 = sub_10015650(v1);
  v5 = 0;
  v4 = -32591;
  sub_10015290((int)&v6, a1, 64);
  v7 = 19;
  v8 = 0;
  memset(&v9, 0, 0x100u);
  if ( v2 == 2 )
  {
    result = sub_100301C0(3, (int)&v4, 1000, 1);
  }
  else
  {
    sub_10015290((int)&v9, "This command is valid for use only in configuration mode.", 256);
    result = sub_10022310(&v7);
  }
  return result;
}

//----- (100196E0) --------------------------------------------------------
char __cdecl sub_100196E0(_BYTE *a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  void *v3; // ecx@1
  char result; // al@3
  void *v5; // ecx@6
  __int16 v6; // [sp+8h] [bp-298h]@1
  int v7; // [sp+Ch] [bp-294h]@1
  int v8; // [sp+10h] [bp-290h]@1
  char v9; // [sp+14h] [bp-28Ch]@1
  char v10; // [sp+D4h] [bp-1CCh]@1
  char v11; // [sp+198h] [bp-108h]@1
  char v12; // [sp+199h] [bp-107h]@1

  v2 = sub_10015650(v1);
  v6 = -32598;
  v7 = 0;
  v8 = 83;
  sub_10015290((int)&v9, a1, 64);
  v10 = 9;
  v11 = 0;
  memset(&v12, 0, 0x100u);
  if ( v2 == 8 )
  {
    if ( sub_10030120(21) == 5 )
      return sub_100301C0(16, (int)&v6, 1000, 1);
  }
  else if ( v2 == 2 )
  {
    return sub_100301C0(3, (int)&v6, 1000, 1);
  }
  if ( sub_10015670(v3) == 1 || sub_10014FA0(v5) & 3 )
  {
    if ( sub_100155B0(v5) )
    {
      result = sub_100301C0(1, (int)&v6, 1000, 1);
    }
    else
    {
      sub_10015290((int)&v12, "No available drop down lists on this page.", 256);
      result = sub_10022310(&v10);
    }
  }
  else
  {
    result = sub_100301C0(9, (int)&v6, 1000, 1);
  }
  return result;
}

//----- (10019820) --------------------------------------------------------
char __cdecl sub_10019820(_BYTE *a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  void *v3; // ecx@1
  char result; // al@2
  void *v5; // ecx@3
  __int16 v6; // [sp+8h] [bp-298h]@1
  int v7; // [sp+Ch] [bp-294h]@1
  int v8; // [sp+10h] [bp-290h]@1
  char v9; // [sp+14h] [bp-28Ch]@1
  char v10; // [sp+D4h] [bp-1CCh]@1
  char v11; // [sp+198h] [bp-108h]@1
  char v12; // [sp+199h] [bp-107h]@1

  v2 = sub_10015650(v1);
  v6 = -32597;
  v7 = 0;
  v8 = 83;
  sub_10015290((int)&v9, a1, 64);
  v10 = 1;
  v11 = 0;
  memset(&v12, 0, 0x100u);
  if ( v2 == 2 )
  {
    result = sub_100301C0(3, (int)&v6, 1000, 1);
  }
  else if ( sub_10015670(v3) == 1 || sub_10014FA0(v5) & 3 )
  {
    if ( sub_100155B0(v5) )
    {
      result = sub_100301C0(1, (int)&v6, 1000, 1);
    }
    else
    {
      sub_10015290((int)&v12, "No available lists on this page.", 256);
      result = sub_10022310(&v10);
    }
  }
  else
  {
    result = sub_100301C0(9, (int)&v6, 1000, 1);
  }
  return result;
}

//----- (10019970) --------------------------------------------------------
int __cdecl sub_10019970(__int16 a1)
{
  void *v1; // ecx@0
  char v2; // al@1
  void *v3; // ecx@1
  void *v4; // ecx@3
  int v6; // [sp-10h] [bp-E0h]@2
  __int16 *v7; // [sp-Ch] [bp-DCh]@2
  __int16 v8; // [sp+0h] [bp-D0h]@1
  int v9; // [sp+4h] [bp-CCh]@1
  __int16 v10; // [sp+8h] [bp-C8h]@1

  v2 = sub_10015650(v1);
  LOWORD(v3) = a1;
  v8 = -32593;
  v9 = 0;
  v10 = a1;
  if ( v2 == 2 )
  {
    v7 = &v8;
    v6 = 3;
  }
  else if ( sub_10015670(v3) == 1 || sub_10014FA0(v4) & 3 )
  {
    v7 = &v8;
    v6 = 1;
  }
  else
  {
    v7 = &v8;
    v6 = 9;
  }
  return sub_100301C0(v6, (int)v7, 1000, 1);
}

//----- (10019A10) --------------------------------------------------------
char __cdecl sub_10019A10(_BYTE *a1, _BYTE *a2)
{
  void *v2; // ecx@0
  char v3; // bl@1
  void *v4; // ecx@1
  char result; // al@3
  void *v6; // ecx@6
  __int16 v7; // [sp+Ch] [bp-298h]@1
  int v8; // [sp+10h] [bp-294h]@1
  char v9; // [sp+14h] [bp-290h]@1
  char v10; // [sp+54h] [bp-250h]@1
  char v11; // [sp+D8h] [bp-1CCh]@1
  char v12; // [sp+19Ch] [bp-108h]@1
  char v13; // [sp+19Dh] [bp-107h]@1

  v3 = sub_10015650(v2);
  v8 = 0;
  v7 = -32594;
  sub_10015290((int)&v9, a1, 64);
  sub_10015290((int)&v10, a2, 64);
  v11 = 11;
  v12 = 0;
  memset(&v13, 0, 0x100u);
  if ( v3 == 8 )
  {
    if ( sub_10030120(21) == 5 )
      return sub_100301C0(16, (int)&v7, 1000, 1);
  }
  else if ( v3 == 2 )
  {
    return sub_100301C0(3, (int)&v7, 1000, 1);
  }
  if ( sub_10015670(v4) == 1 || sub_10014FA0(v6) & 3 )
  {
    sub_10015290((int)&v13, "This command is valid only for test code, non-reversionary MFD or Config pages.", 256);
    result = sub_10022310(&v11);
  }
  else
  {
    result = sub_100301C0(9, (int)&v7, 1000, 1);
  }
  return result;
}

//----- (10019B40) --------------------------------------------------------
int __cdecl sub_10019B40(_BYTE *a1)
{
  void *v1; // ecx@0
  int v2; // edx@1
  char v3; // bl@1
  const char *v4; // edi@1
  _BYTE *v5; // esi@1
  signed int v6; // ecx@1
  bool v7; // zf@1
  const char *v8; // edi@5
  _BYTE *v9; // esi@5
  bool v10; // zf@5
  const char *v11; // edi@9
  _BYTE *v12; // esi@9
  bool v13; // zf@9
  const char *v14; // edi@13
  _BYTE *v15; // esi@13
  bool v16; // zf@13
  const char *v17; // edi@17
  _BYTE *v18; // esi@17
  void *v19; // ecx@20
  void *v20; // ecx@25
  int v22; // [sp-10h] [bp-F0h]@22
  __int16 *v23; // [sp-Ch] [bp-ECh]@22
  __int16 v24; // [sp+10h] [bp-D0h]@20
  int v25; // [sp+14h] [bp-CCh]@20
  __int16 v26; // [sp+18h] [bp-C8h]@20

  v3 = sub_10015650(v1);
  v4 = "MSG";
  v5 = a1;
  v6 = 4;
  v7 = 1;
  do
  {
    if ( !v6 )
      break;
    v7 = *v5++ == *v4++;
    --v6;
  }
  while ( v7 );
  if ( !v7 )
  {
    v8 = "ALERTS";
    v9 = a1;
    v6 = 7;
    v2 = 0;
    v10 = 1;
    do
    {
      if ( !v6 )
        break;
      v10 = *v9++ == *v8++;
      --v6;
    }
    while ( v10 );
    if ( !v10 )
    {
      v11 = "WARNING";
      v12 = a1;
      v6 = 8;
      v13 = 1;
      do
      {
        if ( !v6 )
          break;
        v13 = *v12++ == *v11++;
        --v6;
      }
      while ( v13 );
      if ( !v13 )
      {
        v14 = "CAUTION";
        v15 = a1;
        v6 = 8;
        v2 = 0;
        v16 = 1;
        do
        {
          if ( !v6 )
            break;
          v16 = *v15++ == *v14++;
          --v6;
        }
        while ( v16 );
        if ( !v16 )
        {
          v17 = "ADVISORY";
          v18 = a1;
          v6 = 9;
          do
          {
            if ( !v6 )
              break;
            v7 = *v18++ == *v17++;
            --v6;
          }
          while ( v7 );
        }
      }
    }
  }
  v24 = -32592;
  v25 = 0;
  v26 = TXT_get_hndl(v6, v2);
  if ( v3 == 8 )
  {
    if ( sub_10030120(21) == 5 )
    {
      v23 = &v24;
      v22 = 16;
      return sub_100301C0(v22, (int)v23, 1000, 1);
    }
  }
  else if ( v3 == 2 )
  {
    v23 = &v24;
    v22 = 3;
    return sub_100301C0(v22, (int)v23, 1000, 1);
  }
  if ( sub_10015670(v19) == 1 || sub_10014FA0(v20) & 3 )
  {
    v23 = &v24;
    v22 = 14;
  }
  else
  {
    v23 = &v24;
    v22 = 9;
  }
  return sub_100301C0(v22, (int)v23, 1000, 1);
}
// 1002F614: using guessed type int __fastcall TXT_get_hndl(_DWORD, _DWORD);

//----- (10019C80) --------------------------------------------------------
unsigned int __cdecl sub_10019C80(unsigned int a1)
{
  unsigned int result; // eax@1
  unsigned int v2; // ebp@1
  int v3; // ebx@3
  int i; // esi@3
  int v5; // eax@4
  int v6; // edi@6

  result = j_FIL_vfs_open("/dev/Display.bmp", 4, 0);
  v2 = result;
  if ( result < 0xFFFFFFC2 && result )
  {
    v3 = sub_10030980(result);
    for ( i = 0; i < v3; i += v6 )
    {
      v5 = v3 - i;
      if ( v3 - i > 4096 )
        v5 = 4096;
      v6 = sub_10030860(v2, &unk_1015CB20, v5);
      sub_1001C860(a1, (int)&unk_1015CB20, v6);
    }
    sub_10030770(v2);
    result = i != v3 ? 0xFFFFFFF0 : 0;
  }
  return result;
}
// 10030850: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10019D10) --------------------------------------------------------
char sub_10019D10()
{
  unsigned int v0; // edi@1
  bool v1; // zf@1
  char *v2; // eax@2
  char v3; // cl@3
  unsigned int v4; // eax@4
  unsigned int v5; // esi@4
  int v7; // [sp+8h] [bp-588h]@2
  char *v8; // [sp+Ch] [bp-584h]@2
  __int16 v9; // [sp+10h] [bp-580h]@4
  int v10; // [sp+14h] [bp-57Ch]@4
  int v11; // [sp+18h] [bp-578h]@4
  __int16 v12; // [sp+1Ch] [bp-574h]@4
  void *v13; // [sp+20h] [bp-570h]@4
  int v14; // [sp+24h] [bp-56Ch]@4
  void *v15; // [sp+28h] [bp-568h]@4
  int v16; // [sp+2Ch] [bp-564h]@4
  int v17; // [sp+30h] [bp-560h]@4
  char v18; // [sp+34h] [bp-55Ch]@4
  int v19; // [sp+38h] [bp-558h]@4
  int v20; // [sp+3Ch] [bp-554h]@1
  unsigned __int16 v21; // [sp+4Eh] [bp-542h]@2
  char v22; // [sp+BCh] [bp-4D4h]@1
  bool v23; // [sp+180h] [bp-410h]@9
  char v24; // [sp+181h] [bp-40Fh]@1
  char v25; // [sp+284h] [bp-30Ch]@4
  char v26; // [sp+564h] [bp-2Ch]@1
  _BYTE v27[3]; // [sp+565h] [bp-2Bh]@4

  v26 = 0;
  v22 = 4;
  memset(&v24, 0, 0x100u);
  j_FIL_vfs_mkdir("/shr_mem/print", 0);
  v0 = sub_1001B400((int)"/shr_mem/print/screens.zip", 14, &v20, 0);
  v1 = v0 == 0;
  if ( !v0 )
  {
    sub_100153B0(&v26, 0x28u, "screen%04i.bmp", v21);
    v2 = &v26;
    v7 = 0;
    v8 = &v26;
    do
      v3 = *v2++;
    while ( v3 );
    v9 = (_WORD)v2 - (unsigned int)v27;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = &unk_101671D8;
    v14 = 4096;
    v15 = &unk_1015DB20;
    v16 = 38584;
    v17 = 12;
    v18 = 3;
    v19 = 5;
    v4 = sub_1001C5B0((int)&v20, &v26, 10, &v25, (int)&v7);
    v5 = v4;
    if ( v4 < 0xFFFFFFC2 && v4 )
    {
      v0 = sub_10019C80(v4);
      sub_10030770(v5);
    }
    else
    {
      v0 = v4;
    }
    sub_1001B3A0(&v20);
    v1 = v0 == 0;
  }
  v23 = v1;
  if ( !v1 )
    sub_100153B0(&v24, 0x100u, "IOP_ATM_SCREEN_SHOT %s, error code %d", &v26, v0);
  return sub_10022310(&v22);
}
// 10030830: using guessed type int __cdecl j_FIL_vfs_mkdir(_DWORD, _DWORD);

//----- (10019EB0) --------------------------------------------------------
char __cdecl sub_10019EB0(int a1, int a2)
{
  char v2; // bl@1

  SYS_enter_krnl();
  v2 = SYS_pvg_alrt_get_hdr(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 1003269C: using guessed type int __cdecl SYS_pvg_alrt_get_hdr(_DWORD, _DWORD);

//----- (10019EE0) --------------------------------------------------------
char __cdecl sub_10019EE0(int a1, int a2, int a3, int a4)
{
  char v4; // bl@1

  SYS_enter_krnl();
  v4 = SYS_pvg_alrt_get_hdr_text_lvl(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 100326A2: using guessed type int __cdecl SYS_pvg_alrt_get_hdr_text_lvl(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10019F10) --------------------------------------------------------
char __cdecl sub_10019F10(int a1, int a2)
{
  char v2; // bl@1

  SYS_enter_krnl();
  v2 = SYS_pvg_alrt_id_is_set(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 100326A8: using guessed type int __cdecl SYS_pvg_alrt_id_is_set(_DWORD, _DWORD);

//----- (10019F40) --------------------------------------------------------
char __cdecl sub_10019F40(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_is_acked(a1);
  SYS_exit_krnl();
  return v1;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 100326AE: using guessed type int __cdecl SYS_pvg_alrt_is_acked(_DWORD);

//----- (10019F60) --------------------------------------------------------
char __cdecl sub_10019F60(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_is_set_text(a1, 1);
  SYS_exit_krnl();
  return v1;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 100326B4: using guessed type int __cdecl SYS_pvg_alrt_is_set_text(_DWORD, _DWORD);

//----- (10019FD0) --------------------------------------------------------
char __cdecl sub_10019FD0(int a1, void *a2)
{
  int v2; // ecx@3
  char result; // al@4
  int v4; // ecx@5
  int v5; // eax@5
  bool v6; // zf@9

  if ( a1 && a2 )
  {
    v2 = *(_DWORD *)(a1 + 20);
    if ( v2 >= 0 )
    {
      memcpy_0(a2, (const void *)(*(_DWORD *)(a1 + 4) + v2 * *(_DWORD *)(a1 + 12)), *(_DWORD *)(a1 + 12));
      v4 = *(_DWORD *)(a1 + 8);
      v5 = *(_DWORD *)(a1 + 20) + 1;
      if ( v5 < v4 )
      {
        if ( v5 < 0 )
          v5 += v4;
      }
      else
      {
        v5 -= v4;
      }
      v6 = v5 == *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 20) = v5;
      if ( v6 )
        *(_DWORD *)(a1 + 20) = -1;
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001A040) --------------------------------------------------------
int __cdecl sub_1001A040(int a1)
{
  int result; // eax@2
  int v2; // edx@3
  int v3; // ecx@4

  if ( a1 && (v2 = *(_DWORD *)(a1 + 20), v2 >= 0) )
  {
    v3 = *(_DWORD *)(a1 + 16);
    if ( v3 <= v2 )
      result = v3 + *(_DWORD *)(a1 + 8) - v2;
    else
      result = v3 - v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001A070) --------------------------------------------------------
char __cdecl sub_1001A070(int a1, void *a2)
{
  int v2; // eax@3
  int v3; // edx@3
  int v4; // ecx@5
  int v5; // eax@5
  int v6; // ecx@12
  int v7; // eax@12
  char result; // al@13

  if ( a1 && a2 )
  {
    v2 = *(_DWORD *)(a1 + 20);
    v3 = *(_DWORD *)(a1 + 16);
    if ( v2 == v3 )
    {
      if ( !(*(_BYTE *)a1 & 1) )
        return 0;
      v4 = *(_DWORD *)(a1 + 8);
      v5 = v2 + 1;
      if ( v5 < v4 )
      {
        if ( v5 < 0 )
          v5 += v4;
      }
      else
      {
        v5 -= v4;
      }
      *(_DWORD *)(a1 + 20) = v5;
    }
    if ( *(_DWORD *)(a1 + 20) < 0 )
      *(_DWORD *)(a1 + 20) = v3;
    memcpy_0((void *)(*(_DWORD *)(a1 + 4) + v3 * *(_DWORD *)(a1 + 12)), a2, *(_DWORD *)(a1 + 12));
    v6 = *(_DWORD *)(a1 + 8);
    v7 = *(_DWORD *)(a1 + 16) + 1;
    if ( v7 < v6 )
    {
      if ( v7 < 0 )
        v7 += v6;
      *(_DWORD *)(a1 + 16) = v7;
      result = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 16) = v7 - v6;
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001A100) --------------------------------------------------------
char __cdecl sub_1001A100(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@11
  int v4; // eax@16
  int v6; // [sp+8h] [bp-54h]@1
  int v7; // [sp+Ch] [bp-50h]@1
  int v8; // [sp+10h] [bp-4Ch]@1
  int v9; // [sp+14h] [bp-48h]@1
  int v10; // [sp+18h] [bp-44h]@1
  char v11; // [sp+1Ch] [bp-40h]@16

  LOBYTE(v2) = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( a1 == 28 || a1 == 29 || a1 == 30 || a1 == 31 || a1 == 32 || a1 == 48 || a1 == 33 || a1 == 34 )
  {
    v2 = sub_10014DE0((_DWORD *)a2, 2u, (int)&unk_10062508, 8, 77, 77);
    if ( v2 != 77 )
    {
      if ( *(_WORD *)a2 == -32768 )
      {
        v3 = *(_WORD *)(a2 + 10) + 16;
      }
      else if ( *(_WORD *)a2 == -32767 )
      {
        v3 = *(_DWORD *)(a2 + 4) + 8;
      }
      else
      {
        v3 = dword_1006250C[2 * v2] + 4;
      }
      v7 = v3;
      v10 = 65;
      v6 = a2;
      v9 = 10;
      v2 = sub_100301F0(a1, (int)&v6);
      if ( v2 == 16 )
      {
        v4 = sub_1002FFA0();
        sub_100153B0(&v11, 0x3Cu, "message queue timed out sending from: %d to %d", v4, a1);
        LOBYTE(v2) = sub_10014D70("..\\lib\\adl\\iop_msg_intf.c", 433, 0, &v11);
      }
    }
  }
  return v2;
}
// 1006250C: using guessed type int dword_1006250C[];

//----- (1001A220) --------------------------------------------------------
char __cdecl sub_1001A220(int a1)
{
  return sub_1001A100(34, a1);
}

//----- (1001A230) --------------------------------------------------------
char __cdecl sub_1001A230(int a1)
{
  return sub_1001A100(28, a1);
}

//----- (1001A240) --------------------------------------------------------
char __cdecl sub_1001A240(int a1)
{
  return sub_1001A100(32, a1);
}

//----- (1001A250) --------------------------------------------------------
int __cdecl sub_1001A250(int a1, float a2)
{
  int result; // eax@1

  result = (signed int)(sub_100324D0(a2) * 683565248.0);
  *(_DWORD *)a1 = result;
  return result;
}

//----- (1001A280) --------------------------------------------------------
char __cdecl sub_1001A280(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  if ( a1 >= 0x319u )
  {
    sub_10014D70("..\\lib\\acl\\iop\\dscrt\\iop_dscrt_data_tbl_utl.c", 115, 0, 0);
    return 0;
  }
  if ( a2 >= 3u )
    return 0;
  *a3 = byte_10087860[8 * a1];
  *a4 = word_10087862[a2 + 4 * a1];
  return 1;
}
// 10087862: using guessed type __int16 word_10087862[];

//----- (1001A2E0) --------------------------------------------------------
char __cdecl sub_1001A2E0(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  if ( a1 >= 0x145u )
  {
    sub_10014D70("..\\lib\\acl\\iop\\dscrt\\iop_dscrt_data_tbl_utl.c", 320, 0, 0);
    return 0;
  }
  if ( a2 >= 3u )
    return 0;
  *a3 = byte_10089128[16 * a1];
  *a4 = word_10089130[a2 + 8 * a1];
  return 1;
}
// 10089130: using guessed type __int16 word_10089130[];

//----- (1001A340) --------------------------------------------------------
bool __cdecl sub_1001A340(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  char v4; // dl@5
  bool result; // al@5

  v3 = a2;
  if ( a2 >= 0xFFu || a2 > 1u )
  {
    result = 0;
  }
  else
  {
    if ( dword_101681F8 != 1379255385 )
    {
      sub_1001FE80(a1, (int)&byte_10168200[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v4 = byte_10168205[4 * (v3 + 6 * (unsigned __int8)a1)];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_10168204[4 * (v3 + 6 * (unsigned __int8)a1)];
    result = (unsigned __int8)v4 < 0xBu;
  }
  return result;
}
// 101681F8: using guessed type int dword_101681F8;

//----- (1001A3B0) --------------------------------------------------------
bool __cdecl sub_1001A3B0(char a1, unsigned __int8 a2, int a3)
{
  bool result; // al@2

  if ( a2 < 1u )
  {
    if ( dword_101681F8 != 1379255385 )
      sub_1001FE80(a1, (int)&byte_10168200[24 * (unsigned __int8)a1]);
    *(_DWORD *)a3 = dword_10168214[a2 + 6 * (unsigned __int8)a1];
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101681F8: using guessed type int dword_101681F8;
// 10168214: using guessed type int dword_10168214[];

//----- (1001A410) --------------------------------------------------------
bool __cdecl sub_1001A410(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  bool result; // al@1
  int v5; // edx@5

  v3 = a2;
  result = 0;
  if ( (a2 & 0x80u) == 0 && a2 <= 1u )
  {
    if ( dword_101681F8 != 1379255385 )
    {
      sub_1001FE80(a1, (int)&byte_10168200[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v5 = dword_1016820C[v3 + 6 * (unsigned __int8)a1];
    *(_DWORD *)a3 = v5;
    result = (unsigned __int8)v5 < 0x13u && *(_BYTE *)(a3 + 1) < 0x13u;
  }
  return result;
}
// 101681F8: using guessed type int dword_101681F8;
// 1016820C: using guessed type int dword_1016820C[];

//----- (1001A480) --------------------------------------------------------
char __cdecl sub_1001A480(char a1, _BYTE *a2)
{
  if ( dword_101681F8 != 1379255385 )
    sub_1001FE80(a1, (int)&byte_10168200[24 * (unsigned __int8)a1]);
  *a2 = byte_10168200[24 * (unsigned __int8)a1];
  return 1;
}
// 101681F8: using guessed type int dword_101681F8;

//----- (1001A4C0) --------------------------------------------------------
char __thiscall sub_1001A4C0(void *this)
{
  char v1; // bl@1
  char *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_101681F8 = sub_10015650(this) != 2 ? 1379255385 : 1916032632;
  memset(byte_10168200, 0, 0x48u);
  v1 = 0;
  v4 = 0;
  v2 = byte_10168200;
  do
  {
    result = sub_1001FE80(v4, (int)v2);
    ++v1;
    v2 += 24;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 3u );
  return result;
}
// 101681F8: using guessed type int dword_101681F8;

//----- (1001A530) --------------------------------------------------------
char __cdecl sub_1001A530(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_10016610(a1);
  v3 = sub_10031640(a2, 0, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (1001A560) --------------------------------------------------------
char __cdecl sub_1001A560(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_10016610(a1);
  v3 = sub_100316B0(a2, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (1001A590) --------------------------------------------------------
char __cdecl sub_1001A590(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6)
{
  char result; // al@3
  char v7; // [sp+0h] [bp-4h]@1

  v7 = sub_10016700(a1);
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        result = sub_1001A410(v7, *a4, (int)a5);
      }
      else
      {
        sub_10014D70("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 531, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        result = sub_1001A340(v7, *a4, (int)a5);
      }
      else
      {
        sub_10014D70("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 548, 0, 0);
        result = 0;
      }
      break;
    case 3:
      if ( a6 >= 4 )
      {
        result = sub_1001A3B0(v7, *a4, (int)a5);
      }
      else
      {
        sub_10014D70("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 565, 0, 0);
        result = 0;
      }
      break;
    case 7:
      if ( a6 >= 1 )
      {
        result = sub_1001A480(v7, a5);
      }
      else
      {
        sub_10014D70("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 582, 0, 0);
        result = 0;
      }
      break;
    case 0x10:
      if ( a6 >= 0x40 )
      {
        result = sub_1001A560(v7, (int)a5);
      }
      else
      {
        sub_10014D70("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 598, 0, 0);
        result = 0;
      }
      break;
    case 0xF:
      if ( a6 >= 0x68 )
      {
        result = sub_1001A530(v7, (int)a5);
      }
      else
      {
        sub_10014D70("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 616, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10014D70("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 633, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1001A760) --------------------------------------------------------
bool __thiscall sub_1001A760(void *this)
{
  return sub_10015650(this) != 8;
}

//----- (1001A770) --------------------------------------------------------
char sub_1001A770()
{
  void *v0; // ecx@1
  char result; // al@1
  void *v2; // ecx@1
  void *v3; // ecx@1
  void *v4; // ecx@1

  j_FIL_vfs_dyn_linker();
  nullsub_2();
  sub_10022D90();
  sub_1001FA20(v2);
  sub_1001A4C0(v3);
  sub_10015A30(v4);
  sub_1001F3A0();
  sub_10007760();
  dword_101681F4 = sub_10014FA0(v0);
  sub_10030490(6465, (int)&dword_101681D8, 28);
  result = sub_10020000();
  if ( !result )
  {
    result = dword_101681F4;
    dword_101681D8 = dword_101681F4;
    dword_101681DC = dword_101681F4;
    dword_101681E0 = dword_101681F4;
    dword_101681E4 = dword_101681F4;
    dword_101681E8 = dword_101681F4;
    dword_101681EC = dword_101681F4;
    dword_101681F0 = dword_101681F4;
  }
  return result;
}
// 100303E0: using guessed type int nullsub_2(void);
// 100307C0: using guessed type int j_FIL_vfs_dyn_linker(void);
// 101681D8: using guessed type int dword_101681D8;
// 101681DC: using guessed type int dword_101681DC;
// 101681E0: using guessed type int dword_101681E0;
// 101681E4: using guessed type int dword_101681E4;
// 101681E8: using guessed type int dword_101681E8;
// 101681EC: using guessed type int dword_101681EC;
// 101681F0: using guessed type int dword_101681F0;
// 101681F4: using guessed type int dword_101681F4;

//----- (1001A7A0) --------------------------------------------------------
unsigned int __cdecl sub_1001A7A0(unsigned int a1)
{
  unsigned int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = a1 & 0xFFFFFFFC;
  else
    result = 0;
  return result;
}

//----- (1001A7C0) --------------------------------------------------------
int __cdecl sub_1001A7C0(int a1)
{
  return a1 | 1;
}

//----- (1001A7D0) --------------------------------------------------------
bool __cdecl sub_1001A7D0(int a1)
{
  bool result; // al@1
  unsigned int v2; // eax@4
  _DWORD *v3; // edx@4
  _DWORD *v4; // esi@4
  int v5; // ecx@8
  int v6; // eax@9
  _BYTE *v7; // edx@9
  _BYTE *v8; // esi@9
  int v9; // eax@11
  _BYTE *v10; // edx@11
  _BYTE *v11; // esi@11
  _BYTE *v12; // edx@13
  _BYTE *v13; // esi@13
  int v14; // edx@14
  signed int v15; // eax@15

  result = *(_DWORD *)(a1 + 88) == ~*(_DWORD *)(a1 + 36);
  if ( *(_WORD *)(a1 + 30) != 99 || !result && *(_WORD *)(a1 + 684) != 2 )
    return result;
  v2 = 10;
  v3 = (_DWORD *)(a1 + 693);
  v4 = (_DWORD *)(a1 + 721);
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_8;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_17:
    v15 = 0;
    return v15 == 0;
  }
LABEL_8:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_17;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_17;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_17;
        v14 = *v12;
        v5 = *v13 - v14;
        if ( *v13 == v14 )
          goto LABEL_17;
      }
    }
  }
  v15 = 1;
  if ( v5 <= 0 )
    return 0;
  return v15 == 0;
}

//----- (1001A8A0) --------------------------------------------------------
int __cdecl sub_1001A8A0(int a1)
{
  return *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 32) + *(_WORD *)(a1 + 28) + 46;
}

//----- (1001A8C0) --------------------------------------------------------
int __cdecl sub_1001A8C0(int a1, int a2)
{
  int result; // eax@2

  if ( a2 )
    result = *(_WORD *)(a2 + 28) + *(_WORD *)(a2 + 26) + 30;
  else
    result = -16 - *(_WORD *)(a1 + 52) + sub_1001A8A0(a1 + 20);
  return result;
}

//----- (1001A900) --------------------------------------------------------
bool __cdecl sub_1001A900(int a1)
{
  unsigned int v1; // esi@2
  unsigned int v2; // ecx@5
  bool result; // al@11

  result = a1
        && (v1 = *(_DWORD *)(a1 + 116), v1 < 0xFFFFFFC2)
        && v1
        && *(_DWORD *)a1 != -1
        && ((v2 = *(_DWORD *)(a1 + 120), *(_DWORD *)a1 + 22 <= v2)
         && *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 20) + 22 <= v2
         || !v2
         || *(_DWORD *)(a1 + 4) != v1)
        && *(_DWORD *)(a1 + 8) == 101010256
        && *(_WORD *)(a1 + 14) == *(_WORD *)(a1 + 12);
  return result;
}

//----- (1001A960) --------------------------------------------------------
signed int __cdecl sub_1001A960(int a1, void *a2, unsigned __int16 a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // ebp@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 732);
  v6 = 0;
  result = -15;
  v8 = *(_WORD *)(a1 + 48) + *(_DWORD *)(a1 + 16) + 46;
  if ( *(_WORD *)(a1 + 50) >= 4u )
  {
    while ( (unsigned int)(v6 + v8) < *(_DWORD *)(v5 + 120) )
    {
      if ( sub_100308A0(*(_DWORD *)(v5 + 4), &a1, 4, v6 + v8, 0) != 4 )
        return -15;
      if ( (_WORD)a1 == a4 && (unsigned int)HIWORD(a1) + 4 <= a3 )
        return sub_100308A0(*(_DWORD *)(v5 + 4), a2, HIWORD(a1) + 4, v6 + v8, 0);
      v6 += HIWORD(a1) + 4;
      result = -15;
      if ( v6 + 4 > (unsigned int)*(_WORD *)(v4 + 50) )
        return result;
    }
  }
  return result;
}

//----- (1001AA20) --------------------------------------------------------
signed int __cdecl sub_1001AA20(int a1, int a2, int a3)
{
  int v3; // esi@3
  signed int result; // eax@9

  if ( sub_100308A0(*(_DWORD *)(a1 + 116), (void *)a3, 30, *(_DWORD *)(a2 + 42), 0) != 30 )
    goto LABEL_13;
  if ( *(_BYTE *)(a2 + 8) & 8 )
  {
    v3 = *(_DWORD *)(a2 + 42) + *(_DWORD *)(a2 + 20) + sub_1001A8C0(0, a3);
    sub_100308A0(*(_DWORD *)(a1 + 116), (void *)(a3 + 14), 12, v3, 0);
    if ( *(_DWORD *)(a3 + 14) != *(_DWORD *)(a2 + 16) )
      sub_100308A0(*(_DWORD *)(a1 + 116), (void *)(a3 + 14), 12, v3 + 4, 0);
  }
  if ( *(_DWORD *)a3 != 67324752
    || *(_DWORD *)(a3 + 18) != *(_DWORD *)(a2 + 20)
    || *(_DWORD *)(a3 + 14) != *(_DWORD *)(a2 + 16)
    || *(_WORD *)(a3 + 26) != *(_WORD *)(a2 + 28) )
  {
LABEL_13:
    result = -15;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001AAD0) --------------------------------------------------------
int __cdecl sub_1001AAD0(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (1001AAF0) --------------------------------------------------------
signed int __cdecl sub_1001AAF0(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // ebp@1
  _BYTE *v4; // edi@2
  _BYTE *v5; // ebx@2
  int v6; // esi@3
  signed int result; // eax@5
  int v8; // [sp+1Ch] [bp+Ch]@3

  v3 = a3;
  if ( a3 )
  {
    v4 = a2;
    v5 = a1;
    while ( 1 )
    {
      v6 = *v5;
      --v3;
      v8 = tolower(*v4++);
      ++v5;
      if ( tolower(v6) != v8 )
        break;
      if ( !v3 )
        goto LABEL_5;
    }
    result = 1;
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (1001AB50) --------------------------------------------------------
int __usercall sub_1001AB50@<eax>(int a1@<esi>, int a2, char a3)
{
  int v3; // ebp@1
  int v4; // edi@2
  int v5; // ebx@2
  int v6; // ebp@5
  int v7; // eax@5
  int v8; // ST04_4@5
  int v10; // [sp+Ch] [bp-4h]@4
  int v11; // [sp+18h] [bp+8h]@4

  v3 = a2;
  if ( a3 )
  {
    v4 = a2;
    v3 = *(_DWORD *)(a1 + 116);
    v5 = 0;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 116);
    v5 = *(_DWORD *)(a1 + 120);
  }
  v11 = *(_DWORD *)(a1 + 24);
  sub_10030980(v3);
  v10 = sub_100307E0(v4, v5, v3, v11, *(_DWORD *)(a1 + 20));
  if ( !v10 )
  {
    *(_DWORD *)(a1 + 24) = v5;
    *(_DWORD *)(a1 + 4) = v4;
    *(_DWORD *)(a1 + 120) = v11;
    v6 = sub_100309B0(v3, v11, 0);
    v7 = *(_DWORD *)(a1 + 24);
    v8 = v5 + *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 36) = v7;
    v10 = sub_100309B0(v4, v8, 0) | v6;
  }
  *(_DWORD *)(a1 + 120) = sub_10030980(*(_DWORD *)(a1 + 116));
  return v10;
}

//----- (1001AC60) --------------------------------------------------------
int __usercall sub_1001AC60@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // eax@2
  int result; // eax@2
  int v4; // eax@3
  __int16 v5; // cx@3
  int v6; // edx@3

  sub_100273C0(a2 + 721, a1 + 64);
  if ( *(_DWORD *)(a2 + 44) )
  {
    v4 = *(_DWORD *)(a2 + 725);
    v5 = *(_WORD *)(a2 + 729);
    *(_DWORD *)(a2 + 693) = *(_DWORD *)(a2 + 721);
    v6 = *(_DWORD *)(a2 + 732);
    *(_DWORD *)(a2 + 697) = v4;
    *(_WORD *)(a2 + 701) = v5;
    result = j_FIL_vfs_write(*(_DWORD *)(v6 + 116), a2 + 721, 10);
    *(_DWORD *)(a2 + 136) += 10;
    *(_DWORD *)(a2 + 40) += 10;
  }
  else
  {
    v2 = sub_10030980(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116));
    result = sub_100309B0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), v2 - *(_WORD *)(a2 + 50) - *(_DWORD *)(a2 + 40), 0);
    *(_DWORD *)(a2 + 84) -= *(_WORD *)(a2 + 50);
    *(_DWORD *)(a2 + 136) = 0;
    *(_WORD *)(a2 + 28) &= 0xFFFEu;
    *(_DWORD *)(a2 + 40) = 0;
    *(_WORD *)(a2 + 50) = 0;
    *(_WORD *)(a2 + 30) = 0;
    *(_WORD *)(a2 + 80) = 0;
  }
  return result;
}
// 100309D0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (1001AD10) --------------------------------------------------------
signed int __usercall sub_1001AD10@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  char v3; // ST30_1@2
  int v4; // ST28_4@2
  int v5; // eax@2
  __int64 v6; // rax@2
  int v7; // ebx@2
  char *v8; // ebp@2
  __int64 v9; // rax@3
  signed int result; // eax@4
  _WORD *v11; // edi@5
  _WORD *v12; // [sp+Ch] [bp-4h]@4

  v2 = a1;
  if ( *(_BYTE *)(a2 + 8) )
  {
    *(_WORD *)(a1 + 532) = -26367;
    *(_WORD *)(a1 + 534) = 7;
    *(_WORD *)(a1 + 536) = 1;
    *(_BYTE *)(a1 + 538) = 65;
    *(_BYTE *)(a1 + 539) = 69;
    v3 = *(_DWORD *)(a2 + 84);
    *(_DWORD *)(a2 + 76) = a1 + 532;
    v4 = a1 + 532;
    v5 = *(_DWORD *)(a2 + 732);
    *(_WORD *)(a2 + 50) = 11;
    *(_WORD *)(a2 + 80) = 11;
    sub_100309E0(*(_DWORD *)(v5 + 116), v4, 11, v3);
    *(_DWORD *)(a2 + 84) += *(_WORD *)(a2 + 80);
    *(_BYTE *)(v2 + 540) = *(_BYTE *)(*(_DWORD *)(a2 + 732) + 112);
    v6 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v6) & 7) + (signed int)v6) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_10027810((void *)(v2 + 555), v7);
  }
  else
  {
    sub_1001A960(a2, (void *)(a1 + 532), 0xBu, -26367);
    v9 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v9) & 7) + (signed int)v9) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_100308A0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 555), v7, *(_DWORD *)(a2 + 84), 0);
    sub_100308A0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 571), 2, v7 + *(_DWORD *)(a2 + 84), 0);
  }
  v12 = (_WORD *)(v2 + 543);
  result = sub_100276E0(*(_BYTE *)(v2 + 540), (void *)v2, strlen((const char *)v2), v8, (_WORD *)(v2 + 543), v2 + 64);
  if ( *(_BYTE *)(a2 + 8) )
  {
    sub_100309E0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v8, v7, *(_DWORD *)(a2 + 84));
    v11 = (_WORD *)(v2 + 571);
    *v11 = *v12;
    sub_100309E0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v11, 2, v7 + *(_DWORD *)(a2 + 84));
    result = v7 + 2;
    *(_DWORD *)(a2 + 136) += v7 + 2;
    *(_DWORD *)(a2 + 40) += v7 + 2;
  }
  else
  {
    *(_DWORD *)(a2 + 92) += -12 - v7;
    *(_DWORD *)(a2 + 124) += v7 + 2;
  }
  return result;
}

//----- (1001AEE0) --------------------------------------------------------
char __usercall sub_1001AEE0@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  return sub_10027370(a2, a3, a1 + 212);
}

//----- (1001AEF0) --------------------------------------------------------
int __usercall sub_1001AEF0@<eax>(int result@<eax>)
{
  if ( *(_WORD *)(result + 30) == 99 )
    result = sub_1001AC60(result + 148, result);
  return result;
}

//----- (1001AF10) --------------------------------------------------------
char __usercall sub_1001AF10@<al>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = (*(_DWORD *)(a1 + 72) & 0xFFFD | 2) * ((*(_DWORD *)(a1 + 72) & 0xFFFD | 2) ^ 1);
  return BYTE1(v1);
}

//----- (1001AF30) --------------------------------------------------------
int __usercall sub_1001AF30@<eax>(int a1@<esi>, unsigned __int8 a2)
{
  int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@1
  int result; // eax@1

  v2 = sub_10032280(a2, *(_DWORD *)(a1 + 64));
  v3 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 64) = v2;
  v4 = 134775813 * (*(_DWORD *)(a1 + 68) + (unsigned __int8)v2) + 1;
  *(_DWORD *)(a1 + 68) = v4;
  result = sub_10032280(BYTE3(v4), v3);
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

//----- (1001AF70) --------------------------------------------------------
int __cdecl sub_1001AF70(unsigned int a1)
{
  int i; // ebx@1
  int v2; // edi@1
  signed int v3; // eax@1
  signed int v4; // ebp@1
  int result; // eax@2
  int v6; // esi@7
  int v7; // ebx@9
  int v8; // eax@10
  unsigned int v9; // ecx@11
  int *v10; // edx@11
  char *v11; // esi@11
  int v12; // edi@15
  int v13; // ecx@16
  _BYTE *v14; // edx@16
  _BYTE *v15; // esi@16
  int v16; // ecx@18
  _BYTE *v17; // edx@18
  _BYTE *v18; // esi@18
  _BYTE *v19; // edx@20
  _BYTE *v20; // esi@20
  signed int v21; // ecx@22
  signed int v22; // [sp+Ch] [bp-9Ch]@1
  int v23; // [sp+10h] [bp-98h]@7
  signed int v24; // [sp+14h] [bp-94h]@1
  int v25; // [sp+18h] [bp-90h]@1
  int v26; // [sp+20h] [bp-88h]@1
  char v27[128]; // [sp+24h] [bp-84h]@9

  i = 65557;
  v2 = 0;
  v22 = 65557;
  v25 = 0;
  v26 = 101010256;
  v3 = sub_10030980(a1);
  v4 = v3;
  v24 = v3;
  if ( v3 >= 0 )
  {
    if ( (unsigned int)v3 >= 0x10015 )
      goto LABEL_7;
    v22 = v3;
    if ( v3 > 0 )
    {
      for ( i = v3; ; i = v22 )
      {
LABEL_7:
        v6 = v2 + 128;
        v23 = v2 + 128;
        if ( v2 + 128 > i )
        {
          v6 = i;
          v23 = i;
        }
        v7 = v6 - v2;
        if ( sub_100308A0(a1, v27, v6 - v2, v4 - v6, 0) != v6 - v2 )
          break;
        v8 = v7 - 4;
        if ( v7 - 4 >= 0 )
        {
          while ( 1 )
          {
            v9 = 4;
            v10 = &v26;
            v11 = &v27[v8];
            do
            {
              if ( *(_DWORD *)v11 != *v10 )
                goto LABEL_15;
              v9 -= 4;
              ++v10;
              v11 += 4;
            }
            while ( v9 >= 4 );
            if ( !v9 )
            {
LABEL_24:
              v21 = 0;
              goto LABEL_25;
            }
LABEL_15:
            v12 = (unsigned __int8)*v11 - *(_BYTE *)v10;
            if ( (unsigned __int8)*v11 == *(_BYTE *)v10 )
            {
              v13 = v9 - 1;
              v14 = (char *)v10 + 1;
              v15 = v11 + 1;
              if ( !v13 )
                goto LABEL_24;
              v12 = *v15 - *v14;
              if ( *v15 == *v14 )
              {
                v16 = v13 - 1;
                v17 = v14 + 1;
                v18 = v15 + 1;
                if ( !v16 )
                  goto LABEL_24;
                v12 = *v18 - *v17;
                if ( *v18 == *v17 )
                {
                  v19 = v17 + 1;
                  v20 = v18 + 1;
                  if ( v16 == 1 )
                    goto LABEL_24;
                  v12 = *v20 - *v19;
                  if ( *v20 == *v19 )
                    goto LABEL_24;
                }
              }
            }
            v21 = 1;
            if ( v12 <= 0 )
              v21 = -1;
LABEL_25:
            if ( !v21 )
              return v24 + v8 - v23;
            if ( --v8 < 0 )
            {
              v4 = v24;
              v2 = v25;
              v6 = v23;
              break;
            }
          }
        }
        v2 = v2 + v7 - 3;
        v25 = v2;
        if ( v6 >= v22 )
          break;
      }
    }
    result = -1;
  }
  else
  {
    result = -1;
  }
  return result;
}
// 1001AF70: using guessed type char var_84[128];

//----- (1001B120) --------------------------------------------------------
int __fastcall sub_1001B120(int a1, int a2)
{
  int result; // eax@1

  result = *(_WORD *)(a2 + 30);
  if ( *(_WORD *)(a2 + 30) == 99 )
    result = *(_WORD *)(a2 + 689);
  return result;
}

//----- (1001B140) --------------------------------------------------------
int __usercall sub_1001B140@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_DWORD *)(a2 + 732) = result;
  ++*(_DWORD *)(result + 124);
  return result;
}

//----- (1001B150) --------------------------------------------------------
int __usercall sub_1001B150@<eax>(int a1@<esi>)
{
  int v1; // ST1C_4@1
  unsigned int v2; // ST18_4@1
  int v3; // eax@1
  int v4; // ST00_4@1

  v1 = *(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 24);
  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = v1;
  sub_10030C60(v2, v1, 0);
  j_FIL_vfs_write(*(_DWORD *)(a1 + 4), a1 + 8, 22);
  v3 = *(_DWORD *)a1 + 22;
  v4 = *(_DWORD *)(a1 + 116);
  *(_DWORD *)(a1 + 120) = v3;
  return sub_100309B0(v4, v3, 0);
}
// 100309D0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (1001B190) --------------------------------------------------------
signed int __usercall sub_1001B190@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6)
{
  __int16 v6; // ax@1
  unsigned int *v7; // ecx@1
  int v8; // esi@1
  signed int v9; // eax@1
  unsigned int v10; // eax@1
  int v11; // ebx@1
  int v12; // ebx@1
  int v13; // eax@4
  int v14; // ecx@6
  int v15; // ebp@8
  unsigned int v16; // ebx@11
  __int64 v17; // rax@14
  unsigned int v18; // ecx@15
  unsigned int v19; // ebp@15
  int v21; // ebx@20
  signed int v22; // eax@23
  size_t v23; // ebp@29
  int v24; // ebx@33
  int v25; // [sp+Ch] [bp-8h]@1
  __int16 v26; // [sp+10h] [bp-4h]@1

  v6 = sub_1001B120(a1, a3);
  v7 = *(unsigned int **)(a2 + 16);
  v8 = a2 + 28;
  v26 = v6;
  *(_DWORD *)v8 = v7;
  v9 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v8 + 4) = v9;
  v25 = 0;
  v10 = sub_100322A0(v7, v9, *(_DWORD *)a2);
  v11 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)a2 = v10;
  v12 = v11 + 0xFFFFF;
  while ( 1 )
  {
    if ( !*(_DWORD *)(a2 + 32) )
    {
      if ( !a6 )
        goto LABEL_37;
      v13 = *(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(a2 + 44) == v13 && v12 != v13 + 0xFFFFF )
        break;
    }
    v14 = *(_DWORD *)(a2 + 12);
    if ( !v14 )
      break;
    if ( !--v12 )
      break;
    v15 = *(_DWORD *)(a2 + 44);
    if ( !v15 || a6 && v15 != v14 )
    {
      v16 = *(_DWORD *)(a2 + 48);
      if ( v16
        && (v16 >= 0x28
         || *(_WORD *)(a3 + 30) != 99
         || (v17 = ((*(_BYTE *)(a3 + 688) & 3) + 1) << 6, v16 != (((BYTE4(v17) & 7) + (signed int)v17) >> 3) / 2 + 2)) )
      {
        v18 = v14 - v15;
        v19 = v18;
        if ( *(_BYTE *)(a3 + 28) & 1 )
          sub_1001AEE0(a3, *(char **)(a2 + 8), v18);
        if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v19) != v19 )
          return -16;
      }
      else
      {
        v19 = 0;
      }
      v21 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
      v12 = v21 + 0xFFFFF;
      v25 += v19;
      *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    }
    if ( v26 == 8 )
    {
      if ( a6 )
        v22 = sub_10029770(a2 + 28, 4);
      else
        v22 = sub_10029770(a2 + 28, 0);
      if ( v22 && v22 != 1 )
        return -15;
    }
    else
    {
      if ( v26 )
        return -15;
      v23 = *(_DWORD *)(a2 + 44);
      if ( *(_DWORD *)(a2 + 32) < v23 )
        v23 = *(_DWORD *)(a2 + 32);
      memcpy(*(void **)(a2 + 40), *(const void **)v8, v23);
      *(_DWORD *)(a2 + 32) -= v23;
      *(_DWORD *)(a2 + 44) -= v23;
      *(_DWORD *)v8 += v23;
      *(_DWORD *)(a2 + 40) += v23;
      *(_DWORD *)(a2 + 36) += v23;
      *(_DWORD *)(a2 + 48) += v23;
    }
  }
  if ( a6 )
  {
    v24 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44);
    if ( *(_BYTE *)(a3 + 28) & 1 )
      sub_1001AEE0(a3, *(char **)(a2 + 8), *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44));
    if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v24) != v24 )
      return -16;
    v25 += v24;
    *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
  }
LABEL_37:
  *(_DWORD *)(a5 + 24) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a5 + 20) = *(_DWORD *)(a2 + 48);
  return v25;
}
// 100309D0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (1001B3A0) --------------------------------------------------------
int __cdecl sub_1001B3A0(void *a1)
{
  unsigned int v1; // ecx@2
  unsigned int v2; // eax@4
  int v3; // edi@4
  int v4; // edi@7
  int result; // eax@8

  if ( a1 && (v1 = *((_DWORD *)a1 + 29), v1 < 0xFFFFFFC2) && v1 )
  {
    v2 = *((_DWORD *)a1 + 1);
    v3 = 0;
    if ( v1 != v2 && v2 < 0xFFFFFFC2 )
    {
      if ( v2 )
      {
        v4 = sub_1001AB50((int)a1, v2, 0);
        v3 = sub_1001B150((int)a1) | v4;
      }
    }
    sub_10030770(*((_DWORD *)a1 + 29));
    memset(a1, 0, 0x80u);
    result = v3;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (1001B400) --------------------------------------------------------
int __cdecl sub_1001B400(int a1, int a2, void *a3, int a4)
{
  unsigned int v4; // eax@3
  signed int v5; // edi@5
  unsigned int v6; // eax@6
  int v8; // eax@11
  int v9; // eax@17

  memset(a3, 0, 0x80u);
  *((_DWORD *)a3 + 8) = -1;
  *((_DWORD *)a3 + 9) = -1;
  *((_BYTE *)a3 + 48) = 0;
  if ( a4 )
    sub_10015290((int)a3 + 48, (_BYTE *)a4, 64);
  *((_BYTE *)a3 + 112) = 3;
  v4 = j_FIL_vfs_open(a1, a2, 0);
  *((_DWORD *)a3 + 29) = v4;
  if ( v4 >= 0xFFFFFFC2 || !v4 )
  {
    v5 = v4;
    if ( !v4 )
      return v5;
LABEL_6:
    v6 = *((_DWORD *)a3 + 29);
    if ( v6 < 0xFFFFFFC2 )
    {
      if ( v6 )
        sub_10030770(*((_DWORD *)a3 + 29));
    }
    memset(a3, 0, 0x80u);
    return v5;
  }
  *((_DWORD *)a3 + 1) = v4;
  v8 = sub_10030980(v4);
  *((_DWORD *)a3 + 30) = v8;
  if ( v8 < 0 )
  {
LABEL_12:
    v5 = -15;
    goto LABEL_6;
  }
  if ( v8 || !(a2 & 2) )
  {
    v9 = sub_1001AF70(*((_DWORD *)a3 + 29));
    *(_DWORD *)a3 = v9;
    if ( v9 == -1 || (unsigned int)(v9 + 22) > *((_DWORD *)a3 + 30) )
      goto LABEL_12;
    sub_100308A0(*((_DWORD *)a3 + 1), (char *)a3 + 8, 22, v9, 0);
    if ( !sub_1001A900((int)a3) )
    {
      v5 = -15;
      goto LABEL_6;
    }
  }
  else
  {
    *((_DWORD *)a3 + 2) = 101010256;
  }
  return 0;
}
// 10030850: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1001B500) --------------------------------------------------------
signed int __cdecl sub_1001B500(int a1, unsigned __int64 a2)
{
  unsigned int v2; // eax@3
  signed int v3; // esi@3
  unsigned int v4; // ebp@4
  int v5; // edx@8
  void *v6; // eax@9
  unsigned __int16 v7; // si@10
  unsigned __int16 v8; // cx@10
  void *v9; // ecx@17
  unsigned __int16 v10; // ax@19
  signed int result; // eax@24
  int v12; // ecx@25
  int v13; // [sp+8h] [bp-4h]@4

  if ( sub_1001A900(a1) && a2 < *(_WORD *)(a1 + 16) )
  {
    v2 = *(_DWORD *)(a1 + 32);
    v3 = -15;
    if ( (unsigned int)a2 < v2 )
    {
      v4 = *(_DWORD *)(a1 + 24);
      v13 = 0;
LABEL_5:
      while ( v4 < *(_DWORD *)(a1 + 120) )
      {
        v3 = sub_100308A0(*(_DWORD *)(a1 + 4), (void *)(HIDWORD(a2) + 4), 46, v4, 0);
        if ( v3 != 46 || *(_DWORD *)(HIDWORD(a2) + 4) != 33639248 )
        {
          v12 = *(_DWORD *)(a1 + 24);
          *(_DWORD *)(a1 + 32) = 0;
          *(_DWORD *)(a1 + 36) = v12;
          v3 = -15;
          break;
        }
        v5 = a1;
        *(_DWORD *)(a1 + 32) = v13;
        *(_DWORD *)(a1 + 36) = v4;
        if ( v13 == (_DWORD)a2 )
        {
          v6 = *(void **)(HIDWORD(a2) + 52);
          v3 = 0;
          *(_DWORD *)HIDWORD(a2) = v4;
          *(_WORD *)(HIDWORD(a2) + 58) = -1;
          if ( v6 )
          {
            v7 = *(_WORD *)(HIDWORD(a2) + 56);
            v8 = *(_WORD *)(HIDWORD(a2) + 32);
            if ( v7 <= v8 )
            {
              sub_10015290((int)v6, byte_1004764C, v7);
              v5 = a1;
              v3 = -15;
            }
            else if ( sub_100308A0(*(_DWORD *)(a1 + 4), v6, v8, v4 + 46, 0) == *(_WORD *)(HIDWORD(a2) + 32) )
            {
              v5 = a1;
              *(_WORD *)(HIDWORD(a2) + 58) = *(_WORD *)(HIDWORD(a2) + 32);
              v3 = 0;
              *(_BYTE *)(*(_WORD *)(HIDWORD(a2) + 32) + *(_DWORD *)(HIDWORD(a2) + 52)) = 0;
            }
            else
            {
              v5 = a1;
              v3 = -15;
              *(_BYTE *)(*(_WORD *)(HIDWORD(a2) + 32) + *(_DWORD *)(HIDWORD(a2) + 52)) = 0;
            }
          }
          else
          {
            *(_WORD *)(HIDWORD(a2) + 58) = -1;
          }
          v9 = *(void **)(HIDWORD(a2) + 60);
          *(_WORD *)(HIDWORD(a2) + 66) = -1;
          if ( v9 )
          {
            if ( !v3 )
            {
              v10 = *(_WORD *)(HIDWORD(a2) + 34);
              if ( *(_WORD *)(HIDWORD(a2) + 64) < v10
                || sub_100308A0(*(_DWORD *)(v5 + 4), v9, v10, *(_WORD *)(HIDWORD(a2) + 32) + v4 + 46, 0) != *(_WORD *)(HIDWORD(a2) + 34) )
              {
                v3 = -15;
              }
              else
              {
                v3 = 0;
                *(_WORD *)(HIDWORD(a2) + 66) = *(_WORD *)(HIDWORD(a2) + 34);
              }
            }
          }
        }
        v4 += sub_1001A8A0(HIDWORD(a2) + 4);
        if ( ++v13 > (unsigned int)a2 )
          return v3;
      }
    }
    else
    {
      v4 = *(_DWORD *)(a1 + 36);
      v13 = *(_DWORD *)(a1 + 32);
      if ( v2 <= (unsigned int)a2 )
        goto LABEL_5;
    }
    result = v3;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (1001B700) --------------------------------------------------------
signed int __cdecl sub_1001B700(int a1, int a2)
{
  return sub_1001AA20(*(_DWORD *)(a1 + 732), a1 + 20, a2);
}

//----- (1001B720) --------------------------------------------------------
int __cdecl sub_1001B720(int a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  unsigned int v3; // ebp@1
  bool v4; // zf@1
  int v5; // ecx@1
  __int16 v6; // cx@4
  __int16 v7; // ax@4
  __int16 v8; // dx@4
  __int16 v9; // cx@4
  unsigned int v10; // edx@4
  int v11; // eax@4
  unsigned int v12; // ecx@4
  int v13; // eax@4
  int result; // eax@5
  int v15; // eax@6
  unsigned __int16 v16; // ax@7
  int v17; // eax@11
  int v18; // edx@13
  int v19; // edi@13
  int v20; // eax@13
  unsigned __int16 v21; // cx@14
  int v22; // [sp+10h] [bp-28h]@4
  char v23; // [sp+14h] [bp-24h]@3
  int v24; // [sp+18h] [bp-20h]@1
  int v25; // [sp+1Ch] [bp-1Ch]@1
  int v26; // [sp+20h] [bp-18h]@1
  int v27; // [sp+24h] [bp-14h]@1
  __int64 v28; // [sp+28h] [bp-10h]@1
  int v29; // [sp+30h] [bp-8h]@1
  __int16 v30; // [sp+34h] [bp-4h]@1
  int v31; // [sp+3Ch] [bp+4h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 732);
  v31 = *(_DWORD *)(v2 + 116);
  sub_1001AEF0(v1);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_WORD *)(v1 + 32) == 0;
  v5 = ~*(_DWORD *)(v1 + 88);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0i64;
  v29 = 0;
  v30 = 0;
  *(_DWORD *)(v1 + 36) = v5;
  if ( v4 || !*(_WORD *)(v1 + 34) )
  {
    sub_10014FE0(&v23);
    sub_100157E0((unsigned int *)&v23, (_WORD *)(v1 + 34), (_WORD *)(v1 + 32));
  }
  v6 = *(_WORD *)(v1 + 24);
  v7 = *(_WORD *)(v1 + 30);
  HIWORD(v25) = *(_WORD *)(v1 + 28);
  v8 = *(_WORD *)(v1 + 34);
  LOWORD(v25) = v6;
  v9 = *(_WORD *)(v1 + 32);
  LOWORD(v27) = v8;
  v10 = *(_DWORD *)(v1 + 44);
  LOWORD(v26) = v7;
  v11 = *(_DWORD *)(v1 + 36);
  HIWORD(v26) = v9;
  v12 = *(_DWORD *)(v1 + 40);
  *(int *)((char *)&v27 + 2) = v11;
  LOWORD(v11) = *(_WORD *)(v1 + 48);
  *(__int64 *)((char *)&v28 + 2) = __PAIR__(v10, v12);
  LOWORD(v12) = *(_WORD *)(v1 + 50);
  v24 = 67324752;
  HIWORD(v29) = v11;
  v30 = v12;
  v22 = sub_1001A8C0(v1, (int)&v24);
  v13 = sub_10030980(v31);
  if ( v3 == v31 )
  {
    result = sub_100307E0(v31, v13, v31, *(_DWORD *)(v2 + 24), *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v15 = *(_DWORD *)(v2 + 24);
    *(_DWORD *)(v1 + 62) = v15;
    *(_DWORD *)(v1 + 84) = v22 + v15;
  }
  sub_10030C60(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 62), 0);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), &v24, 30);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72));
  v16 = *(_WORD *)(v1 + 80);
  if ( v16 )
    j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 76), v16);
  if ( v3 == v31 )
  {
    result = sub_100307E0(
               v31,
               *(_DWORD *)(v1 + 84),
               v31,
               v22 + *(_DWORD *)(v2 + 120),
               *(_DWORD *)(v1 + 40) + *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v17 = *(_DWORD *)((char *)&v28 + 2) + v22 + *(_DWORD *)(v2 + 24);
  }
  else
  {
    v17 = 0;
  }
  v18 = v17 + *(_DWORD *)(v2 + 20);
  ++*(_WORD *)(v2 + 16);
  ++*(_WORD *)(v2 + 18);
  *(_DWORD *)(v2 + 8) = 101010256;
  *(_DWORD *)(v2 + 24) = v17;
  *(_WORD *)(v2 + 28) = 0;
  sub_10030C60(v3, v18, 0);
  *(_DWORD *)(v2 + 20) += sub_1001A8A0(v1 + 20);
  j_FIL_vfs_write(v3, v1 + 20, 46);
  v19 = j_FIL_vfs_write(v3, *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72)) != *(_WORD *)(v1 + 72) ? 0xFFFFFFF1 : 0;
  v20 = *(_DWORD *)(v1 + 76);
  if ( v20 )
  {
    v21 = *(_WORD *)(v1 + 80);
    if ( v21 )
    {
      v19 |= j_FIL_vfs_write(v3, v20, v21);
      if ( v19 >= 0 )
        v19 = 0;
    }
  }
  *(_DWORD *)v2 = *(_DWORD *)(v2 + 20) + *(_DWORD *)(v2 + 24);
  if ( v3 == v31 )
    sub_1001B150(v2);
  else
    *(_DWORD *)(v2 + 120) = sub_10030980(v31);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(v2 + 24);
  *(_DWORD *)(v2 + 32) = 0;
  return v19;
}
// 100309D0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (1001B990) --------------------------------------------------------
int __cdecl sub_1001B990(int a1, unsigned int a2)
{
  int v2; // ebp@5
  int v3; // eax@5
  int v4; // ebx@5
  int v5; // ecx@5
  int v6; // ecx@5
  int v7; // ecx@8
  int result; // eax@10
  signed int v9; // [sp+8h] [bp-6Ch]@5
  unsigned int v10; // [sp+Ch] [bp-68h]@5
  char v11; // [sp+10h] [bp-64h]@4
  int v12; // [sp+30h] [bp-44h]@3
  char v13; // [sp+34h] [bp-40h]@4
  int v14; // [sp+48h] [bp-2Ch]@5
  unsigned int v15; // [sp+5Eh] [bp-16h]@5

  if ( sub_1001A900(a1) && a2 < *(_WORD *)(a1 + 16) )
  {
    memset(&v12, 0, 0x44u);
    if ( sub_1001B500(a1, __PAIR__(&v12, a2)) || sub_1001AA20(a1, (int)&v13, (int)&v11) )
    {
      result = -15;
    }
    else
    {
      v2 = sub_1001A8A0((int)&v13);
      v3 = sub_1001A8C0(0, (int)&v11);
      v4 = v14 + v3;
      sub_100307E0(*(_DWORD *)(a1 + 116), v12, *(_DWORD *)(a1 + 116), v12 + v2, *(_DWORD *)(a1 + 120) - v12 - v2);
      sub_100307E0(*(_DWORD *)(a1 + 116), v15, *(_DWORD *)(a1 + 116), v15 + v4, *(_DWORD *)(a1 + 120) - v15 - v4);
      *(_DWORD *)(a1 + 20) -= v2;
      *(_DWORD *)(a1 + 24) -= v4;
      --*(_WORD *)(a1 + 16);
      --*(_WORD *)(a1 + 18);
      v5 = *(_DWORD *)(a1 + 116);
      *(_DWORD *)a1 -= v4 + v2;
      sub_100309E0(v5, a1 + 8, 22, *(_DWORD *)a1);
      v6 = v15;
      *(_DWORD *)(a1 + 32) = 0;
      *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 24);
      v10 = v6;
      v9 = 0;
      if ( *(_WORD *)(a1 + 16) )
      {
        do
        {
          if ( !sub_1001B500(a1, __PAIR__(&v12, v9)) && v10 < v15 )
          {
            v7 = *(_DWORD *)(a1 + 116);
            v15 -= v4;
            sub_100309E0(v7, (int)&v15, 4, v12 + 42);
          }
          ++v9;
        }
        while ( v9 < *(_WORD *)(a1 + 16) );
      }
      *(_DWORD *)(a1 + 120) -= v2 + v4;
      result = sub_100309B0(*(_DWORD *)(a1 + 116), *(_DWORD *)(a1 + 120), 0);
    }
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (1001BB30) --------------------------------------------------------
int __cdecl sub_1001BB30(void *a1, int a2, char a3)
{
  _BYTE *v3; // eax@1
  char *v4; // edi@3
  int result; // eax@4

  memset(a1, 0, 0x2E0u);
  *((_DWORD *)a1 + 17) = *(_DWORD *)(a2 + 4);
  *((_WORD *)a1 + 36) = *(_WORD *)(a2 + 8);
  *((_DWORD *)a1 + 19) = *(_DWORD *)(a2 + 16);
  *((_WORD *)a1 + 40) = *(_WORD *)(a2 + 20);
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *((_DWORD *)a1 + 24) = *(_DWORD *)(a2 + 24);
  *((_DWORD *)a1 + 25) = *(_DWORD *)(a2 + 28);
  *((_DWORD *)a1 + 26) = 0;
  *((_DWORD *)a1 + 27) = 0;
  sub_1001AAD0((int)a1 + 116);
  v3 = *(_BYTE **)(a2 + 12);
  if ( v3 )
    sub_10015290((int)a1 + 148, v3, 64);
  v4 = (char *)a1 + 116;
  if ( a3 )
    result = sub_10029A30(
               (int)v4,
               *(_BYTE *)(a2 + 44),
               8,
               -*(_DWORD *)(a2 + 40),
               *(_DWORD *)(a2 + 48),
               0,
               *(_DWORD *)(a2 + 32),
               *(_DWORD *)(a2 + 36));
  else
    result = sub_1002B390((int)v4, -*(_DWORD *)(a2 + 40), *(_DWORD *)(a2 + 32), *(_DWORD *)(a2 + 36));
  return result;
}

//----- (1001BC00) --------------------------------------------------------
signed int __cdecl sub_1001BC00(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ecx@7
  int v5; // eax@10

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    if ( *(_DWORD *)(a1 + 112) == *(_DWORD *)(a1 + 44) && !*(_DWORD *)(a1 + 124) )
      sub_10030C60(*(_DWORD *)(*(_DWORD *)(a1 + 732) + 116), *(_DWORD *)(a1 + 136) + *(_DWORD *)(a1 + 84), 0);
    v4 = *(_DWORD *)(a1 + 112) - a3;
    *(_DWORD *)(a1 + 104) = a2;
    *(_DWORD *)(a1 + 108) = a3;
    v5 = !v4 && *(_DWORD *)(a1 + 136) || !a2;
    result = sub_1001B190(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 88,
               a1,
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 20,
               v5);
    if ( result >= 0 )
    {
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 136);
      *(_DWORD *)(a1 + 112) -= a3;
    }
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (1001BCA0) --------------------------------------------------------
int __usercall sub_1001BCA0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // al@1
  unsigned __int8 *v3; // edx@1

  v1 = a1;
  v2 = sub_1001AF10(a1);
  *v3 ^= v2;
  return sub_1001AF30(v1, *v3);
}

//----- (1001BCC0) --------------------------------------------------------
int __usercall sub_1001BCC0@<eax>(int a1@<edi>, int a2)
{
  int i; // esi@1
  int result; // eax@2

  for ( i = 0; i < a1; ++i )
    result = sub_1001BCA0(a2);
  return result;
}

//----- (1001BCF0) --------------------------------------------------------
signed int __usercall sub_1001BCF0@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // esi@1
  signed int v3; // edi@1
  signed int result; // eax@4

  v2 = a1;
  *(_DWORD *)(a1 + 64) = 305419896;
  *(_DWORD *)(a1 + 68) = 591751049;
  *(_DWORD *)(a1 + 72) = 878082192;
  v3 = 0;
  do
  {
    if ( !*(_BYTE *)(v3 + v2) )
      break;
    sub_1001AF30(v2, *(_BYTE *)(v3++ + v2));
  }
  while ( v3 < 64 );
  result = sub_100308A0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 76), 12, *(_DWORD *)(a2 + 84), 0);
  *(_DWORD *)(a2 + 92) -= 12;
  *(_DWORD *)(a2 + 124) += 12;
  return result;
}

//----- (1001BD60) --------------------------------------------------------
int __cdecl sub_1001BD60(int a1, unsigned int a2)
{
  int result; // eax@3

  if ( sub_1001A900(a1) && a2 < *(_WORD *)(a1 + 16) )
    result = sub_1001B990(a1, a2);
  else
    result = -15;
  return result;
}

//----- (1001BDA0) --------------------------------------------------------
int __cdecl sub_1001BDA0(int a1, char *a2, int a3)
{
  char *v3; // edi@1
  int v4; // ebx@4
  int v5; // esi@6
  int result; // eax@11
  signed int v7; // [sp+8h] [bp-F4h]@6
  char v8; // [sp+Ch] [bp-F0h]@4
  char *v9; // [sp+40h] [bp-BCh]@4
  __int16 v10; // [sp+44h] [bp-B8h]@4
  unsigned __int16 v11; // [sp+46h] [bp-B6h]@8
  char v12; // [sp+50h] [bp-ACh]@4

  v3 = a2;
  if ( sub_1001A900(a1) && a2 && *a2 )
  {
    memset(&v8, 0, 0x44u);
    v9 = &v12;
    v10 = 168;
    v4 = strlen(a2);
    strchr(a2, 92);
    if ( *a2 == 47 )
    {
      v3 = a2 + 1;
      --v4;
    }
    v5 = a3;
    v7 = -24;
    if ( a3 < (unsigned int)*(_WORD *)(a1 + 16) )
    {
      while ( sub_1001B500(a1, __PAIR__(&v8, v5)) || v4 != v11 || sub_1001AAF0(v3, &v12, v4) )
      {
        if ( ++v5 >= (unsigned int)*(_WORD *)(a1 + 16) )
          return -24;
      }
      v7 = v5;
    }
    result = v7;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (1001BF10) --------------------------------------------------------
signed int __cdecl sub_1001BF10(int a1)
{
  signed int result; // eax@5

  if ( a1 && *(_DWORD *)(a1 + 732) )
  {
    --*(_DWORD *)(*(_DWORD *)(a1 + 732) + 124);
    if ( *(_BYTE *)(a1 + 8) )
      exit_0(a1);
    sub_1002A860(a1 + 116);
    result = 0;
    *(_DWORD *)a1 = -858993460;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (1001BF70) --------------------------------------------------------
char __usercall sub_1001BF70@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>)
{
  char result; // al@2

  if ( *(_WORD *)(a3 + 30) == 99 )
    result = sub_10027320(a1, a2, a3 + 212);
  else
    result = sub_1001BCC0(a2, a3 + 148);
  return result;
}

//----- (1001BFA0) --------------------------------------------------------
signed int __usercall sub_1001BFA0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@1
  int v3; // eax@1
  signed int result; // eax@2

  v1 = a1;
  v2 = *(_WORD *)(a1 + 30) == 99;
  v3 = a1 + 148;
  if ( v2 )
    result = sub_1001AD10(v3, v1);
  else
    result = sub_1001BCF0(v3, v1);
  return result;
}

//----- (1001BFD0) --------------------------------------------------------
BOOL __usercall sub_1001BFD0@<eax>(int a1@<ebx>, int a2)
{
  int v2; // ebp@1
  unsigned int v3; // esi@1
  int v4; // edi@1
  char v6; // [sp+10h] [bp+4h]@2

  v2 = a2;
  v3 = 0;
  v4 = a2 + 148;
  do
  {
    v6 = *(_BYTE *)(a1 + v3 + 76);
    sub_1001BCA0(v4);
    ++v3;
  }
  while ( v3 < 0xC );
  return *(_BYTE *)(v2 + 39) == v6;
}

//----- (1001C010) --------------------------------------------------------
int __cdecl sub_1001C010(int a1, char *a2)
{
  int result; // eax@1

  result = sub_1001BDA0(a1, a2, 0);
  if ( result >= 0 )
    result = sub_1001BD60(a1, result);
  return result;
}

//----- (1001C040) --------------------------------------------------------
signed int __cdecl sub_1001C040(unsigned int a1)
{
  signed int result; // eax@3
  int v2; // eax@4
  int v3; // ecx@4
  int v4; // edx@4

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    sub_1001AAD0(a1 + 116);
    v2 = *(_DWORD *)(a1 + 40);
    v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 88) = -1;
    *(_DWORD *)(a1 + 92) = v2;
    *(_DWORD *)(a1 + 112) = v3;
    sub_1002B480(v4);
    if ( *(_BYTE *)(a1 + 28) & 1 )
      sub_1001BFA0(a1);
    result = 0;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (1001C090) --------------------------------------------------------
signed int __cdecl sub_1001C090(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned int v5; // ecx@1
  signed int v6; // eax@4
  size_t v8; // eax@9
  size_t v9; // ebx@10
  int v10; // esi@13
  int v11; // edx@18
  __int16 v12; // ax@20
  size_t v13; // esi@21
  int v14; // ST30_4@25
  unsigned int *v15; // ST34_4@25
  int v16; // ebx@25
  int v17; // [sp+10h] [bp-Ch]@1
  int v18; // [sp+24h] [bp+8h]@7

  v2 = a2;
  v3 = a2 + 28;
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 20);
  v5 = *(_DWORD *)(a2 + 24);
  v17 = 0;
  if ( v4 <= v5 )
    *(_DWORD *)(a2 + 44) = v4;
  else
    *(_DWORD *)(a2 + 44) = v5;
  v6 = 0xFFFFF;
  if ( *(_DWORD *)(a2 + 44) )
  {
    while ( 1 )
    {
      v18 = v6 - 1;
      if ( v6 - 1 <= 0 )
        break;
      if ( *(_DWORD *)(v3 + 4) || (v8 = *(_DWORD *)(v2 + 4)) == 0 )
      {
        v10 = a1;
      }
      else
      {
        v9 = *(_DWORD *)(v2 + 12);
        if ( v8 < v9 )
          v9 = *(_DWORD *)(v2 + 4);
        if ( !v9 )
          return v17;
        v10 = a1;
        if ( sub_100308A0(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               *(void **)(v2 + 8),
               v9,
               *(_DWORD *)(a1 + 84) + *(_DWORD *)(v3 + 8),
               0) != v9 )
          return -15;
        if ( *(_BYTE *)(a1 + 28) & 1 )
        {
          sub_1001BF70(*(char **)(v2 + 8), v9, a1);
          if ( *(_DWORD *)(v2 + 4) == v9 && *(_WORD *)(a1 + 30) == 99 )
          {
            sub_100308A0(
              *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
              (void *)(a1 + 721),
              10,
              *(_DWORD *)(a1 + 84) + v9 + *(_DWORD *)(v3 + 4) + *(_DWORD *)(v3 + 8),
              0);
            sub_100273C0(a1 + 693, a1 + 212);
            v10 = a1;
          }
        }
        v11 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 4) -= v9;
        v18 = 0xFFFFF;
        *(_DWORD *)v3 = v11;
        *(_DWORD *)(v3 + 4) = v9;
      }
      v12 = sub_1001B120(v5, v10);
      if ( v12 )
      {
        if ( v12 != 8 )
          return -15;
        v14 = *(_DWORD *)(v3 + 20);
        v15 = *(unsigned int **)(v3 + 12);
        v16 = (char)sub_1002C840(v3, 2);
        v17 += *(_DWORD *)(v3 + 20) - v14;
        *(_DWORD *)v2 = sub_100322A0(v15, *(_DWORD *)(v3 + 20) - v14, *(_DWORD *)v2);
        if ( v16 == 1 )
          return v17;
        if ( v16 < 0 )
          return -14;
      }
      else
      {
        v13 = *(_DWORD *)(v3 + 4);
        if ( *(_DWORD *)(v3 + 16) < v13 )
          v13 = *(_DWORD *)(v3 + 16);
        memcpy(*(void **)(v3 + 12), *(const void **)v3, v13);
        *(_DWORD *)v2 = sub_100322A0(*(unsigned int **)(v3 + 12), v13, *(_DWORD *)v2);
        *(_DWORD *)(v3 + 4) -= v13;
        *(_DWORD *)(v3 + 16) -= v13;
        *(_DWORD *)(v3 + 12) += v13;
        *(_DWORD *)v3 += v13;
        *(_DWORD *)(v3 + 20) += v13;
        *(_DWORD *)(v3 + 8) += v13;
        v17 += v13;
      }
      if ( !*(_DWORD *)(v3 + 16) )
        return v17;
      v6 = v18;
    }
  }
  return v17;
}

//----- (1001C280) --------------------------------------------------------
bool __usercall sub_1001C280@<al>(int a1@<eax>)
{
  int v1; // ecx@4
  int v2; // edx@4
  int v3; // eax@4
  signed int v4; // ecx@6
  int v5; // eax@2

  if ( *(_WORD *)(a1 + 30) != 99 )
    return sub_1001BFD0(a1 + 148, a1);
  v5 = a1 + 148;
  v1 = v5 + 543;
  v2 = v5 + 571;
  v3 = *(_BYTE *)(v5 + 571) - *(_BYTE *)(v5 + 543);
  if ( v3 || (v3 = *(_BYTE *)(v2 + 1) - *(_BYTE *)(v1 + 1), *(_BYTE *)(v2 + 1) != *(_BYTE *)(v1 + 1)) )
  {
    v4 = 1;
    if ( v3 <= 0 )
      return 0;
  }
  else
  {
    v4 = 0;
  }
  return v4 == 0;
}

//----- (1001C2B0) --------------------------------------------------------
int __cdecl sub_1001C2B0(int a1, int a2, char a3, void *a4, int a5)
{
  int result; // eax@6
  unsigned __int64 v6; // ST04_8@7
  char v7; // [sp+8h] [bp-54h]@8
  int v8; // [sp+28h] [bp-34h]@4
  int v9; // [sp+34h] [bp-28h]@4

  if ( !sub_1001A900(a1) || !a4 || a3 & 2 )
    return -15;
  qmemcpy(&v8, (const void *)a5, 0x34u);
  if ( !v9 )
    v9 = a1 + 48;
  result = sub_1001BB30(a4, (int)&v8, 0);
  if ( !result )
  {
    HIDWORD(v6) = (char *)a4 + 16;
    LODWORD(v6) = a2;
    if ( sub_1001B500(a1, v6) )
      return -15;
    sub_1001B140(a1, (int)a4);
    if ( sub_1001B700((int)a4, (int)&v7) )
    {
      sub_1001C7A0((unsigned int)a4);
      return -15;
    }
    *((_DWORD *)a4 + 21) = *(_DWORD *)((char *)a4 + 62) + sub_1001A8C0((int)a4, (int)&v7);
    *((_DWORD *)a4 + 3) = a2;
    sub_1001C040((unsigned int)a4);
    if ( !(*((_BYTE *)a4 + 28) & 1) || sub_1001C280((int)a4) )
    {
      result = sub_1001A7C0((int)a4);
    }
    else
    {
      sub_1001BF10((int)a4);
      result = -34;
    }
  }
  return result;
}

//----- (1001C3C0) --------------------------------------------------------
signed int __cdecl sub_1001C3C0(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ST04_4@4
  signed int v5; // eax@4
  signed int v6; // ebx@4
  bool v7; // zf@5

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    v4 = a1 + 88;
    *(_DWORD *)(v4 + 16) = a2;
    *(_DWORD *)(v4 + 20) = a3;
    v5 = sub_1001C090(a1, a1 + 88);
    v6 = v5;
    if ( v5 > 0 )
    {
      v7 = *(_DWORD *)(a1 + 112) == v5;
      *(_DWORD *)(a1 + 112) -= v5;
      if ( v7 && !(*(_BYTE *)a1 & 1) && !sub_1001A7D0(a1) )
        v6 = -14;
    }
    result = v6;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (1001C420) --------------------------------------------------------
signed int __cdecl sub_1001C420(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  unsigned int v4; // edx@4
  int v5; // ebx@4
  int v6; // esi@16
  int v7; // eax@17
  char v8; // [sp+4h] [bp-204h]@19

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return -6;
  v4 = *(_DWORD *)(a1 + 44);
  result = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 112);
  v5 = a2;
  if ( a3 == 1 )
  {
    v5 = result + a2;
  }
  else if ( a3 == 2 )
  {
    v5 = v4 + a2;
  }
  if ( v5 > v4 || v5 < 0 )
    return -15;
  if ( result == v5 )
    return result;
  if ( !v5 )
  {
    sub_1001C040(a1);
    return 0;
  }
  if ( !*(_WORD *)(a1 + 30) && *(_BYTE *)a1 & 3 )
  {
    sub_1001AAD0(a1 + 116);
    *(_DWORD *)(a1 + 124) = v5;
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 44) - v5;
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 40) - v5;
    return v5;
  }
  if ( result > v5 )
  {
    sub_1001C040(a1);
    result = 0;
  }
  v6 = v5 - result;
  if ( v5 - result <= 0 )
    return v5;
  while ( 1 )
  {
    v7 = 512;
    if ( (unsigned int)v6 < 0x200 )
      v7 = v6;
    result = sub_1001C3C0(a1, (int)&v8, v7);
    if ( result <= 0 )
      break;
    v6 -= result;
    if ( v6 <= 0 )
      return v5;
  }
  return result;
}

//----- (1001C5B0) --------------------------------------------------------
int __cdecl sub_1001C5B0(int a1, char *a2, int a3, void *a4, int a5)
{
  int result; // eax@10
  bool v6; // zf@11
  int v7; // ST0C_4@16
  int v8; // eax@16
  int v9; // [sp+Ch] [bp-34h]@5
  int v10; // [sp+18h] [bp-28h]@5
  char v11; // [sp+38h] [bp-8h]@11

  if ( sub_1001A900(a1) && a2 && a4 && a5 )
  {
    qmemcpy(&v9, (const void *)a5, 0x34u);
    if ( !v10 )
      v10 = a1 + 48;
    *((_DWORD *)a4 + 1) = a3;
    if ( a3 & 8 )
    {
      if ( *(_WORD *)(a1 + 16) >= 0xFFFFu || *(_WORD *)(a1 + 18) >= 0xFFFFu )
      {
        result = -22;
      }
      else
      {
        result = sub_1001BB30(a4, (int)&v9, 1);
        if ( !result )
        {
          *((_DWORD *)a4 + 1) = a3;
          *((_BYTE *)a4 + 8) = 1;
          *((_DWORD *)a4 + 183) = a1;
          *((_DWORD *)a4 + 3) = *(_WORD *)(a1 + 16);
          *((_DWORD *)a4 + 22) = -1;
          *((_WORD *)a4 + 12) = 20;
          *((_WORD *)a4 + 13) = 20;
          *((_DWORD *)a4 + 5) = 33639248;
          *((_WORD *)a4 + 14) = 0;
          *((_WORD *)a4 + 16) = 0;
          *((_WORD *)a4 + 17) = 0;
          *((_DWORD *)a4 + 9) = 0;
          *((_DWORD *)a4 + 10) = 0;
          *((_DWORD *)a4 + 11) = 0;
          v6 = v11 == 0;
          *((_WORD *)a4 + 24) = strlen(a2);
          *((_WORD *)a4 + 25) = 0;
          *((_WORD *)a4 + 26) = 0;
          *((_WORD *)a4 + 27) = 0;
          *((_WORD *)a4 + 28) = 0;
          *(_DWORD *)((char *)a4 + 58) = 0;
          if ( v6 )
            *((_WORD *)a4 + 15) = 0;
          else
            *((_WORD *)a4 + 15) = 8;
          if ( *(_BYTE *)a4 & 4 )
          {
            *(_WORD *)((char *)a4 + 689) = *((_WORD *)a4 + 15);
            *((_WORD *)a4 + 15) = 99;
            *((_WORD *)a4 + 14) = 1;
          }
          *(_DWORD *)((char *)a4 + 62) = *(_DWORD *)(a1 + 120);
          *((_DWORD *)a4 + 21) = *(_DWORD *)((char *)a4 + 62) + sub_1001A8C0((int)a4, 0);
          sub_1001B140(a1, (int)a4);
          v7 = *(_DWORD *)((char *)a4 + 62);
          v8 = sub_1001A8C0((int)a4, 0);
          sub_100309E0(*(_DWORD *)(a1 + 116), *((_DWORD *)a4 + 24), v8, v7);
          if ( *((_BYTE *)a4 + 28) & 1 )
            sub_1001BFA0((int)a4);
          result = sub_1001A7C0((int)a4);
        }
      }
    }
    else
    {
      *((_BYTE *)a4 + 8) = 0;
      result = sub_1001BDA0(a1, a2, 0);
      if ( result >= 0 )
        result = sub_1001C2B0(a1, result, a3, a4, (int)&v9);
    }
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (1001C7A0) --------------------------------------------------------
signed int __cdecl sub_1001C7A0(unsigned int a1)
{
  int v1; // eax@1

  v1 = sub_1001A7A0(a1);
  return sub_1001BF10(v1);
}

//----- (1001C7E0) --------------------------------------------------------
signed int __cdecl sub_1001C7E0(unsigned int a1, int a2, int a3, int a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  signed int result; // eax@3

  v4 = sub_1001A7A0(a1);
  v5 = v4;
  if ( v4 < 0xFFFFFFC2 && v4 )
  {
    if ( sub_1001C420(v4, a4, 0) == a4 )
      result = sub_1001C3C0(v5, a2, a3);
    else
      result = -15;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (1001C840) --------------------------------------------------------
signed int __cdecl sub_1001C840(unsigned int a1, int a2, int a3)
{
  unsigned int v3; // eax@1

  v3 = sub_1001A7A0(a1);
  return sub_1001C420(v3, a2, a3);
}

//----- (1001C860) --------------------------------------------------------
signed int __cdecl sub_1001C860(unsigned int a1, int a2, int a3)
{
  unsigned int v3; // eax@1

  v3 = sub_1001A7A0(a1);
  return sub_1001BC00(v3, a2, a3);
}

//----- (1001C880) --------------------------------------------------------
char __cdecl sub_1001C880(char a1, _BYTE *a2, _BYTE *a3, char a4)
{
  _BYTE *v4; // eax@2

  if ( a1 == 1 )
  {
    v4 = a2;
    *v4 |= a4;
  }
  else
  {
    LOBYTE(v4) = a1 - 2;
    if ( a1 == 2 )
    {
      *a2 = a4;
      if ( a4 )
      {
        LOBYTE(v4) = *a3 == 0;
        *a2 = (_BYTE)v4;
      }
      else
      {
        LOBYTE(v4) = (_BYTE)a3;
        *a3 = 1;
      }
    }
  }
  return (unsigned int)v4;
}

//----- (1001C8C0) --------------------------------------------------------
char __thiscall sub_1001C8C0(void *this)
{
  char result; // al@2

  switch ( sub_10014FA0(this) )
  {
    case 4:
    case 128:
      result = 1;
      break;
    case 2:
    case 16:
      result = 2;
      break;
    case 32:
      result = 3;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (1001C980) --------------------------------------------------------
void __usercall sub_1001C980(unsigned __int16 a1@<bx>, unsigned __int16 *a2@<edi>, int a3, int a4, char a5, int a6)
{
  int v6; // esi@2
  int v7; // eax@3

  if ( a2 )
  {
    v6 = 0;
    if ( *a2 < a1 )
    {
      v7 = (int)a2;
      do
      {
        if ( *(_WORD *)(a6 + 2 * *(_WORD *)v7) < a1 )
          sub_1001C880(
            *(_BYTE *)(v7 + 2),
            (_BYTE *)(a3 + *(_WORD *)(a6 + 2 * *(_WORD *)v7)),
            (_BYTE *)(*(_WORD *)v7 + a4),
            a5);
        v7 = (int)&a2[2 * ++v6];
      }
      while ( a2[2 * v6] < a1 );
    }
  }
}

//----- (1001C9E0) --------------------------------------------------------
char __cdecl sub_1001C9E0(unsigned __int8 a1)
{
  void *v1; // ecx@0
  char result; // al@2
  bool v3; // zf@3
  void *v4; // [sp-2h] [bp-4h]@1

  v4 = v1;
  BYTE3(v4) = 1;
  if ( sub_10015650(v1) == 2 )
  {
    result = 1;
  }
  else
  {
    v3 = sub_100171A0(a1, (_BYTE *)&v4 + 3) == 1;
    result = 1;
    if ( v3 )
      result = BYTE3(v4);
  }
  return result;
}

//----- (1001CA20) --------------------------------------------------------
char __usercall sub_1001CA20@<al>(void *a1@<ecx>, int a2@<esi>)
{
  char v2; // bl@1
  char v3; // al@1

  v2 = 0;
  v3 = sub_10015650(a1);
  if ( v3 == 2 || v3 == 4 )
  {
    if ( j_HWM_pvg_read_reg(1) )
    {
      v2 = 1;
      memset((void *)a2, 0, 0x74u);
      *(_DWORD *)(a2 + 108) = 5;
      *(_DWORD *)(a2 + 112) = 15;
    }
  }
  return v2;
}
// 10008150: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1001CA60) --------------------------------------------------------
char __cdecl sub_1001CA60(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // ebp@1
  int v6; // esi@1
  signed int v7; // edi@1
  void *v8; // eax@3
  __int16 v9; // cx@8
  __int16 v10; // cx@11
  __int16 v11; // cx@14
  __int16 v12; // cx@17
  int v13; // esi@23
  signed int v14; // edi@23
  void *v15; // eax@25
  __int16 v16; // cx@30
  __int16 v17; // cx@33
  __int16 v18; // cx@36
  __int16 v19; // cx@39
  void *v20; // ecx@45
  int v21; // eax@45
  char v22; // si@46
  signed int v23; // eax@46
  void *v24; // ecx@46
  int v25; // ST18_4@48
  int v26; // ST10_4@48
  unsigned __int16 *v27; // eax@48
  int v28; // ST18_4@48
  int v29; // ST10_4@48
  unsigned __int16 *v30; // eax@48
  int v31; // ecx@48
  int v32; // ST18_4@49
  int v33; // ST10_4@49
  unsigned __int16 *v34; // eax@49
  int v35; // ST18_4@51
  int v36; // ST10_4@51
  unsigned __int16 *v37; // eax@51
  unsigned __int8 v38; // al@52
  char v39; // bp@52
  signed int v40; // ecx@52
  char v41; // al@53
  int v42; // ST18_4@54
  int v43; // ST10_4@54
  int v44; // ST0C_4@54
  unsigned __int16 *v45; // eax@54
  char v46; // al@55
  int v47; // ST18_4@56
  int v48; // ST10_4@56
  int v49; // ST0C_4@56
  unsigned __int16 *v50; // eax@56
  signed int v51; // ebp@58
  char v52; // di@60
  unsigned __int8 v53; // al@60
  int v54; // ST18_4@60
  char v55; // ST14_1@60
  int v56; // ST10_4@60
  int v57; // ST0C_4@60
  unsigned __int16 *v58; // eax@60
  signed int v59; // edi@66
  void *v60; // ecx@66
  int i; // edi@67
  unsigned __int16 v62; // ax@68
  unsigned __int8 v63; // al@75
  char v64; // al@75
  int v65; // ST18_4@75
  char v66; // ST14_1@75
  int v67; // ST10_4@75
  unsigned __int16 *v68; // eax@75
  char result; // al@75
  char v70; // [sp+13h] [bp-49h]@62
  int v71; // [sp+14h] [bp-48h]@1
  int v72; // [sp+18h] [bp-44h]@1
  int v73; // [sp+1Ch] [bp-40h]@1
  int v74; // [sp+20h] [bp-3Ch]@1
  int v75; // [sp+24h] [bp-38h]@52
  unsigned __int16 v76; // [sp+28h] [bp-34h]@62
  int v77; // [sp+2Ch] [bp-30h]@1
  int v78; // [sp+30h] [bp-2Ch]@52
  int v79; // [sp+34h] [bp-28h]@45
  int v80; // [sp+38h] [bp-24h]@60
  int v81; // [sp+3Ch] [bp-20h]@1
  int v82; // [sp+40h] [bp-1Ch]@1
  int v83; // [sp+44h] [bp-18h]@1
  int v84; // [sp+48h] [bp-14h]@1
  int v85; // [sp+4Ch] [bp-10h]@1
  int v86; // [sp+50h] [bp-Ch]@1

  v5 = a3;
  v73 = a4;
  v74 = a3;
  v72 = a5;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v84 = 0;
  v85 = 0;
  v86 = 0;
  memset(word_10176430, 0, 0xFA0u);
  v6 = 0;
  v71 = -1;
  v77 = 0;
  v7 = 0;
  do
  {
    if ( sub_100303F0(v7 + 12000, (int)&unk_101773D0, 16004) )
    {
      v6 += 100;
    }
    else
    {
      v8 = &unk_1017745A;
      do
      {
        if ( *((char *)v8 - 136) && *(_WORD *)v8 )
        {
          word_10176430[v6] = *(_WORD *)v8;
          v71 = v6;
        }
        if ( *((_BYTE *)v8 + 24) )
        {
          v9 = *((_WORD *)v8 + 80);
          if ( v9 )
          {
            word_10176432[v6] = v9;
            v71 = v6 + 1;
          }
        }
        if ( *((_BYTE *)v8 + 184) )
        {
          v10 = *((_WORD *)v8 + 160);
          if ( v10 )
          {
            word_10176434[v6] = v10;
            v71 = v6 + 2;
          }
        }
        if ( *((_BYTE *)v8 + 344) )
        {
          v11 = *((_WORD *)v8 + 240);
          if ( v11 )
          {
            word_10176436[v6] = v11;
            v71 = v6 + 3;
          }
        }
        if ( *((_BYTE *)v8 + 504) )
        {
          v12 = *((_WORD *)v8 + 320);
          if ( v12 )
          {
            word_10176438[v6] = v12;
            v71 = v6 + 4;
          }
        }
        v8 = (char *)v8 + 800;
        v6 += 5;
      }
      while ( (signed int)v8 < (signed int)&unk_1017B2DA );
    }
    ++v7;
  }
  while ( v7 < 10 );
  v13 = 0;
  v14 = 0;
  do
  {
    if ( sub_100303F0(v14 + 14000, (int)&unk_101773D0, 16004) )
    {
      v13 += 100;
    }
    else
    {
      v15 = &unk_1017745A;
      do
      {
        if ( *((char *)v15 - 136) && *(_WORD *)v15 )
        {
          word_10176C00[v13] = *(_WORD *)v15;
          v71 = v13 + 1000;
        }
        if ( *((_BYTE *)v15 + 24) )
        {
          v16 = *((_WORD *)v15 + 80);
          if ( v16 )
          {
            word_10176C02[v13] = v16;
            v71 = v13 + 1001;
          }
        }
        if ( *((_BYTE *)v15 + 184) )
        {
          v17 = *((_WORD *)v15 + 160);
          if ( v17 )
          {
            word_10176C04[v13] = v17;
            v71 = v13 + 1002;
          }
        }
        if ( *((_BYTE *)v15 + 344) )
        {
          v18 = *((_WORD *)v15 + 240);
          if ( v18 )
          {
            word_10176C06[v13] = v18;
            v71 = v13 + 1003;
          }
        }
        if ( *((_BYTE *)v15 + 504) )
        {
          v19 = *((_WORD *)v15 + 320);
          if ( v19 )
          {
            word_10176C08[v13] = v19;
            v71 = v13 + 1004;
          }
        }
        v15 = (char *)v15 + 800;
        v13 += 5;
      }
      while ( (signed int)v15 < (signed int)&unk_1017B2DA );
    }
    ++v14;
  }
  while ( v14 < 10 );
  sub_1001FF50((int)&v77);
  v21 = sub_10014FA0(v20);
  v77 |= v21;
  LOBYTE(v79) = 0;
  do
  {
    v22 = v79;
    v23 = sub_10016610(v79);
    if ( v23 & v77 || sub_10015650(v24) == 4 )
    {
      v25 = v72;
      v26 = v73;
      v27 = (unsigned __int16 *)sub_1002CB50(v22, a1);
      sub_1001C980(a2, v27, v5, v26, 1, v25);
      v28 = v72;
      v29 = v73;
      v30 = (unsigned __int16 *)sub_1002CD30(*(_BYTE *)dword_1020D810, v22, a1);
      sub_1001C980(a2, v30, v5, v29, 1, v28);
      if ( (unsigned __int8)sub_1002CF70(v31) )
      {
        v32 = v72;
        v33 = v73;
        v34 = (unsigned __int16 *)sub_1002CAD0(v22, a1);
        sub_1001C980(a2, v34, v5, v33, 1, v32);
      }
      if ( sub_1002CF60() )
      {
        v35 = v72;
        v36 = v73;
        v37 = (unsigned __int16 *)sub_1002CBD0(v22, a1);
        sub_1001C980(a2, v37, v5, v36, 1, v35);
      }
      v38 = sub_10016530(v22);
      LOBYTE(v75) = sub_1001C9E0(v38);
      sub_1001FE80(v22, (int)&v81);
      v39 = v75;
      v40 = 0;
      v78 = 0;
      do
      {
        v41 = *((_BYTE *)&v84 + 4 * v40);
        if ( v41 )
        {
          v42 = v72;
          v43 = v73;
          v44 = v74;
          v45 = (unsigned __int16 *)sub_1002CE90(v22, v41, a1);
          sub_1001C980(a2, v45, v44, v43, v39, v42);
          v40 = v78;
        }
        v46 = *((_BYTE *)&v84 + 4 * v40 + 1);
        if ( v46 )
        {
          v47 = v72;
          v48 = v73;
          v49 = v74;
          v50 = (unsigned __int16 *)sub_1002CE90(v22, v46, a1);
          sub_1001C980(a2, v50, v49, v48, v39, v47);
          v40 = v78;
        }
        v78 = ++v40;
      }
      while ( v40 <= 1 );
      v51 = 0;
      do
      {
        if ( *((_BYTE *)&v82 + 4 * v51 + 1) )
        {
          LOBYTE(v80) = *((_BYTE *)&v82 + 4 * v51 + 1);
          v52 = v80;
          v53 = sub_100168E0(v80);
          LOBYTE(v75) = sub_1001C9E0(v53);
          v54 = v72;
          v55 = v75;
          v56 = v73;
          v57 = v74;
          v58 = (unsigned __int16 *)sub_1002CDF0(v22, v52, a1);
          sub_1001C980(a2, v58, v57, v56, v55, v54);
        }
        ++v51;
      }
      while ( v51 < 2 );
      if ( sub_1001A280(HIWORD(v86), 0, &v70, &v76) == 1 && v70 == a1 && v76 < a2 )
        *(_BYTE *)(*(_WORD *)(v72 + 2 * v76) + v74) = v75;
      v59 = sub_10016610(v22);
      if ( sub_10014FA0(v60) == v59 )
      {
        for ( i = 0; i <= v71; ++i )
        {
          v62 = word_10176430[i];
          if ( v62 && sub_1001A2E0(v62, 0, &v70, &v76) == 1 && v70 == a1 && v76 < a2 )
            *(_BYTE *)(*(_WORD *)(v72 + 2 * v76) + v74) = v75;
        }
      }
      v5 = v74;
    }
    v63 = sub_10016530(v22);
    v64 = sub_1001C9E0(v63);
    v65 = v72;
    LOBYTE(v75) = v64;
    v66 = v64;
    v67 = v73;
    v68 = (unsigned __int16 *)sub_1002CC50(v22, a1);
    sub_1001C980(a2, v68, v5, v67, v66, v65);
    result = v79 + 1;
    LOBYTE(v79) = v79 + 1;
  }
  while ( (unsigned __int8)v79 < 3u );
  return result;
}
// 10176430: using guessed type __int16 word_10176430[];
// 10176432: using guessed type __int16 word_10176432[];
// 10176434: using guessed type __int16 word_10176434[];
// 10176436: using guessed type __int16 word_10176436[];
// 10176438: using guessed type __int16 word_10176438[];
// 10176C00: using guessed type __int16 word_10176C00[];
// 10176C02: using guessed type __int16 word_10176C02[];
// 10176C04: using guessed type __int16 word_10176C04[];
// 10176C06: using guessed type __int16 word_10176C06[];
// 10176C08: using guessed type __int16 word_10176C08[];
// 1020D810: using guessed type int dword_1020D810;

//----- (1001CFE0) --------------------------------------------------------
void __cdecl sub_1001CFE0(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  char v5; // ST0C_1@2
  int *v6; // eax@2
  int v7; // [sp+0h] [bp-8h]@1
  int v8; // [sp+4h] [bp-4h]@1

  LOBYTE(v8) = sub_1001C9E0(0x1Fu);
  sub_1001FF50((int)&v7);
  if ( v7 & 0x8000 )
  {
    v5 = v8;
    v6 = sub_1002D280(a1);
    sub_1001C980(a2, (unsigned __int16 *)v6, a3, a4, v5, a5);
  }
}

//----- (1001D040) --------------------------------------------------------
void __cdecl sub_1001D040(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  void *v5; // ecx@0
  char v6; // ST0C_1@2
  unsigned __int16 *v7; // eax@2

  if ( sub_1002D2E0(v5) )
  {
    v6 = sub_1001C9E0(0x11u);
    v7 = (unsigned __int16 *)sub_1002CFA0(a1);
    sub_1001C980(a2, v7, a3, a4, v6, a5);
  }
}

//----- (1001D090) --------------------------------------------------------
void __cdecl sub_1001D090(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // ecx@0
  void *v6; // ecx@1
  bool v7; // al@5
  char v8; // ST0C_1@7
  unsigned __int16 *v9; // eax@7
  int v10; // [sp+0h] [bp-4h]@1

  v10 = v5;
  sub_1001FF50((int)&v10);
  if ( v10 & 0x1000000 || sub_10015650(v6) == 4 )
  {
    v7 = sub_1001C9E0(0x32u) && sub_1001C9E0(0x3Eu);
    v8 = v7;
    v9 = (unsigned __int16 *)sub_1002D300(a1);
    sub_1001C980(a2, v9, a3, a4, v8, a5);
  }
}

//----- (1001D110) --------------------------------------------------------
char __cdecl sub_1001D110(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  char v6; // bp@3
  signed int v7; // eax@3
  void *v8; // ecx@3
  unsigned __int8 v9; // al@6
  char v10; // ST18_1@6
  int v11; // ST14_4@6
  unsigned __int16 *v12; // eax@6
  int v13; // ecx@6
  char v14; // ST18_1@7
  int v15; // ST14_4@7
  unsigned __int16 *v16; // eax@7
  char v17; // ST18_1@7
  int v18; // ST14_4@7
  unsigned __int16 *v19; // eax@7
  int v20; // eax@8
  void *v21; // ecx@8
  char v22; // al@9
  char v23; // al@12
  char v24; // ST18_1@14
  int v25; // ST14_4@14
  unsigned __int16 *v26; // eax@14
  unsigned __int16 *v27; // eax@17
  char v28; // al@22
  char v29; // ST18_1@24
  int v30; // ST14_4@24
  unsigned __int16 *v31; // eax@24
  char v32; // ST18_1@25
  int v33; // ST14_4@25
  unsigned __int16 *v34; // eax@25
  signed int v35; // ecx@25
  unsigned __int8 v36; // al@26
  char v37; // ST18_1@27
  int v38; // ST14_4@27
  unsigned __int16 *v39; // eax@27
  signed int v40; // eax@29
  char v41; // ST18_1@31
  int v42; // ST14_4@31
  unsigned __int16 *v43; // eax@31
  unsigned __int16 *v44; // edi@33
  unsigned __int16 *v45; // edi@39
  __int16 *v46; // ecx@45
  char v47; // ST18_1@48
  int v48; // ST14_4@48
  unsigned __int16 *v49; // eax@48
  unsigned __int8 v50; // al@49
  char v51; // ST18_1@52
  int v52; // ST14_4@52
  unsigned __int16 *v53; // eax@52
  __int16 *v54; // eax@55
  int v55; // edi@55
  bool v56; // cf@55
  int v57; // eax@57
  _BYTE *v58; // esi@61
  unsigned __int8 v59; // di@62
  unsigned __int8 v60; // al@62
  char v61; // ST18_1@62
  int v62; // ST14_4@62
  int v63; // ST10_4@62
  unsigned __int16 *v64; // eax@62
  _BYTE *v65; // esi@63
  unsigned __int8 v66; // di@64
  unsigned __int8 v67; // al@64
  char v68; // ST18_1@64
  int v69; // ST14_4@64
  int v70; // ST10_4@64
  unsigned __int16 *v71; // eax@64
  unsigned __int8 v72; // di@65
  unsigned __int8 v73; // al@65
  char v74; // ST18_1@65
  int v75; // ST14_4@65
  int v76; // ST10_4@65
  unsigned __int16 *v77; // eax@65
  char *v78; // eax@67
  unsigned __int8 v79; // di@68
  unsigned __int8 v80; // al@68
  char v81; // al@68
  int v82; // esi@72
  char v83; // ST18_1@72
  int v84; // ST14_4@72
  int v85; // ST10_4@72
  unsigned __int16 *v86; // eax@72
  unsigned __int8 v87; // di@73
  unsigned __int8 v88; // al@73
  char v89; // al@73
  char v90; // ST18_1@77
  int v91; // ST14_4@77
  unsigned __int16 *v92; // eax@77
  char result; // al@79
  int v94; // [sp-10h] [bp-D8h]@17
  int v95; // [sp-Ch] [bp-D4h]@17
  char v96; // [sp-8h] [bp-D0h]@17
  int v97; // [sp-4h] [bp-CCh]@17
  char v98; // [sp+17h] [bp-B1h]@1
  int v99; // [sp+18h] [bp-B0h]@12
  int v100; // [sp+1Ch] [bp-ACh]@6
  int v101; // [sp+20h] [bp-A8h]@1
  int v102; // [sp+24h] [bp-A4h]@25
  __int16 *v103; // [sp+28h] [bp-A0h]@45
  int v104; // [sp+2Ch] [bp-9Ch]@1
  int v105; // [sp+30h] [bp-98h]@1
  unsigned int v106; // [sp+34h] [bp-94h]@68
  unsigned int v107; // [sp+38h] [bp-90h]@64
  unsigned __int8 *v108; // [sp+3Ch] [bp-8Ch]@1
  unsigned __int16 v109[2]; // [sp+40h] [bp-88h]@56
  int v110; // [sp+44h] [bp-84h]@1
  int v111; // [sp+48h] [bp-80h]@1
  unsigned int v112; // [sp+4Ch] [bp-7Ch]@62
  char v113; // [sp+50h] [bp-78h]@1
  unsigned int v114; // [sp+BCh] [bp-Ch]@16
  char v115; // [sp+C0h] [bp-8h]@10

  v5 = a3;
  v101 = a4;
  v104 = a3;
  v98 = 0;
  v111 = 0;
  v105 = 0;
  memset(&v113, 0, 0x74u);
  sub_1001FF50((int)&v111);
  LOBYTE(v110) = 0;
  v108 = (unsigned __int8 *)":#;<";
  while ( 1 )
  {
    v6 = v110;
    v7 = sub_1001F640(v110);
    if ( !(v7 & v111) )
    {
      if ( sub_10015650(v8) != 4 )
        goto LABEL_79;
      v5 = v104;
    }
    v9 = sub_1001F600(v6);
    LOBYTE(v100) = sub_1001C9E0(v9);
    memset(byte_10175990, 0, 0xAA0u);
    sub_1001FEA0(v6, (int)byte_10175990);
    v10 = v100;
    v11 = v101;
    v12 = (unsigned __int16 *)sub_1002DA60(v6, a1);
    sub_1001C980(a2, v12, v5, v11, v10, a5);
    if ( (unsigned __int8)sub_1002CF70(v13) )
    {
      v14 = v100;
      v15 = v101;
      v16 = (unsigned __int16 *)sub_1002DE70(v6, a1);
      sub_1001C980(a2, v16, v5, v15, v14, a5);
      v17 = v100;
      v18 = v101;
      v19 = (unsigned __int16 *)sub_1002DE50(v6, a1);
      sub_1001C980(a2, v19, v5, v18, v17, a5);
    }
    LOBYTE(v20) = sub_1001F680(v6);
    if ( sub_1001F8A0(v20, &v113) || (v22 = sub_1001CA20(v21, (int)&v113), v5 = v104, v22) )
    {
      if ( v115 & 1 )
      {
        if ( !(_BYTE)v100 || (v23 = sub_1001C9E0(*(v108 - 1)), LOBYTE(v99) = 1, !v23) )
          LOBYTE(v99) = 0;
        v24 = v99;
        v25 = v101;
        v26 = (unsigned __int16 *)sub_1002D940(v6, a1);
        sub_1001C980(a2, v26, v5, v25, v24, a5);
      }
      if ( v115 & 2 )
      {
        if ( v114 >= 3 )
        {
          v97 = a5;
          v96 = v100;
          v95 = v101;
          v94 = v5;
          v27 = (unsigned __int16 *)sub_1002DD20(v6, a1);
        }
        else
        {
          v97 = a5;
          v96 = v100;
          v95 = v101;
          v94 = v5;
          v27 = (unsigned __int16 *)sub_1002D9D0(v6, a1);
        }
        sub_1001C980(a2, v27, v94, v95, v96, v97);
      }
      if ( v115 & 8 )
      {
        if ( !(_BYTE)v100 || (v28 = sub_1001C9E0(*v108), LOBYTE(v99) = 1, !v28) )
          LOBYTE(v99) = 0;
        v29 = v99;
        v30 = v101;
        v31 = (unsigned __int16 *)sub_1002DC90(v6, a1);
        sub_1001C980(a2, v31, v5, v30, v29, a5);
      }
    }
    v32 = v100;
    v33 = v101;
    v34 = (unsigned __int16 *)sub_1002D870(v6, byte_10175E5C, a1);
    sub_1001C980(a2, v34, v5, v33, v32, a5);
    v102 = 0;
    v35 = 0;
    do
    {
      v36 = byte_10175990[v35];
      if ( v36 )
      {
        v37 = v100;
        v38 = v101;
        v39 = (unsigned __int16 *)sub_1002D430(v6, v102, v36, a1);
        sub_1001C980(a2, v39, v5, v38, v37, a5);
        v35 = v102;
      }
      v102 = ++v35;
    }
    while ( v35 < 10 );
    v40 = 0;
    v102 = 0;
    do
    {
      if ( byte_1017599A[v40] == 1 )
      {
        v41 = v100;
        v42 = v101;
        v43 = (unsigned __int16 *)sub_1002D6D0(v6, v102, a1);
        sub_1001C980(a2, v43, v5, v42, v41, a5);
        v40 = v102;
      }
      v102 = ++v40;
    }
    while ( v40 < 11 );
    v44 = (unsigned __int16 *)&unk_101759D6;
    do
    {
      if ( sub_1001A280(*v44, v6, &v98, &v105) == 1 && v98 == a1 && (unsigned __int16)v105 < a2 )
        *(_BYTE *)(*(_WORD *)(a5 + 2 * (unsigned __int16)v105) + v5) = v100;
      v44 += 6;
    }
    while ( (signed int)v44 < (signed int)&unk_10175BC2 );
    v45 = (unsigned __int16 *)&unk_10175BC2;
    do
    {
      if ( sub_1001A2E0(*v45, v6, &v98, &v105) == 1 && v98 == a1 && (unsigned __int16)v105 < a2 )
        *(_BYTE *)(*(_WORD *)(a5 + 2 * (unsigned __int16)v105) + v5) = v100;
      v45 += 2;
    }
    while ( (signed int)v45 < (signed int)&unk_10175C6A );
    v46 = (__int16 *)&unk_10175CB0;
    v102 = 0;
    v103 = (__int16 *)&unk_10175CB0;
    do
    {
      if ( *(_BYTE *)v46 == 3 )
      {
        LOWORD(v102) = v46[1] | v102;
      }
      else
      {
        v47 = v100;
        v48 = v101;
        v49 = (unsigned __int16 *)sub_1002D7A0(v6, *(_BYTE *)v46, a1);
        sub_1001C980(a2, v49, v5, v48, v47, a5);
        v46 = v103;
      }
      v50 = *((_BYTE *)v46 + 1);
      if ( v50 != *(_BYTE *)v46 )
      {
        if ( v50 == 3 )
        {
          LOWORD(v102) = v46[1] | v102;
        }
        else
        {
          v51 = v100;
          v52 = v101;
          v53 = (unsigned __int16 *)sub_1002D7A0(v6, v50, a1);
          sub_1001C980(a2, v53, v5, v52, v51, a5);
          v46 = v103;
        }
      }
      v46 += 8;
      v103 = v46;
    }
    while ( (signed int)v46 < (signed int)&unk_10175CD0 );
    if ( (_WORD)v102 )
    {
      v54 = (__int16 *)sub_1002D7A0(v6, 3u, a1);
      v55 = 0;
      v56 = (unsigned __int16)*v54 < a2;
      v103 = v54;
      if ( v56 )
      {
        do
        {
          v105 = (unsigned __int16)*v54;
          if ( !sub_1002DE90(a1, *v54, v109)
            || (v57 = sub_10014DE0((_DWORD *)v109, 2u, (int)"<", 4, 12, 12), v57 >= 12)
            || ((unsigned __int16)v102 & (unsigned __int16)word_100633A6[2 * v57]) != 0 )
          {
            *(_BYTE *)(*(_WORD *)(a5 + 2 * (unsigned __int16)v105) + v5) = v100;
          }
          v54 = &v103[2 * ++v55];
        }
        while ( (unsigned __int16)v103[2 * v55] < a2 );
      }
    }
    v58 = &unk_101759A9;
    do
    {
      LOBYTE(v112) = *v58;
      v59 = v112;
      v60 = sub_1001F790(v112);
      LOBYTE(v99) = sub_1001C9E0(v60);
      v61 = v99;
      v62 = v101;
      v63 = v104;
      v64 = (unsigned __int16 *)sub_1002D360(v6, v59, a1);
      sub_1001C980(a2, v64, v63, v62, v61, a5);
      v58 += 4;
    }
    while ( (signed int)v58 <= (signed int)&unk_101759D1 );
    v65 = &unk_10175C69;
    do
    {
      LOBYTE(v107) = *(v65 - 1);
      v66 = v107;
      v67 = sub_1001F7C0(v107);
      LOBYTE(v99) = sub_1001C9E0(v67);
      v68 = v99;
      v69 = v101;
      v70 = v104;
      v71 = (unsigned __int16 *)sub_1002DAF0(v6, v66, a1);
      sub_1001C980(a2, v71, v70, v69, v68, a5);
      if ( (_BYTE)v107 != *v65 )
      {
        LOBYTE(v107) = *v65;
        v72 = v107;
        v73 = sub_1001F7C0(v107);
        LOBYTE(v99) = sub_1001C9E0(v73);
        v74 = v99;
        v75 = v101;
        v76 = v104;
        v77 = (unsigned __int16 *)sub_1002DAF0(v6, v72, a1);
        sub_1001C980(a2, v77, v76, v75, v74, a5);
      }
      v65 += 4;
    }
    while ( (signed int)v65 < (signed int)&unk_10175C89 );
    v78 = (char *)&unk_10175C89;
    v103 = (__int16 *)&unk_10175C89;
    do
    {
      LOBYTE(v106) = *(v78 - 1);
      v79 = v106;
      v80 = sub_1001F7F0(v106);
      v81 = sub_1001C9E0(v80);
      LOBYTE(v99) = v81;
      if ( (_BYTE)v106 == 4 )
      {
        if ( !(_BYTE)v100 || (LOBYTE(v99) = 1, !v81) )
          LOBYTE(v99) = 0;
      }
      v82 = v104;
      v83 = v99;
      v84 = v101;
      v85 = v104;
      v86 = (unsigned __int16 *)sub_1002DBC0(v6, v79, a1);
      sub_1001C980(a2, v86, v85, v84, v83, a5);
      if ( (_BYTE)v106 != *(_BYTE *)v103 )
      {
        LOBYTE(v106) = *(_BYTE *)v103;
        v87 = v106;
        v88 = sub_1001F7F0(v106);
        v89 = sub_1001C9E0(v88);
        LOBYTE(v99) = v89;
        if ( (_BYTE)v106 == 4 )
        {
          if ( !(_BYTE)v100 || (LOBYTE(v99) = 1, !v89) )
            LOBYTE(v99) = 0;
        }
        v90 = v99;
        v91 = v101;
        v92 = (unsigned __int16 *)sub_1002DBC0(v6, v87, a1);
        sub_1001C980(a2, v92, v82, v91, v90, a5);
      }
      v78 = (char *)(v103 + 4);
      v103 += 4;
    }
    while ( (signed int)v103 < (signed int)&unk_10175CB1 );
LABEL_79:
    v108 += 2;
    result = v110 + 1;
    LOBYTE(v110) = v110 + 1;
    if ( (unsigned __int8)v110 >= 2u )
      return result;
    v5 = v104;
  }
}
// 100633A6: using guessed type __int16 word_100633A6[];
// 10175E5C: using guessed type char byte_10175E5C;

//----- (1001D8C0) --------------------------------------------------------
void __cdecl sub_1001D8C0(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  void *v5; // ecx@1
  void *v6; // ecx@2
  bool v7; // al@5
  char v8; // ST0C_1@7
  unsigned __int16 *v9; // eax@7
  bool v10; // al@12
  char v11; // ST0C_1@14
  unsigned __int16 *v12; // eax@14
  int v13; // [sp+10h] [bp-4h]@1

  sub_1001FF50((int)&v13);
  if ( v13 & 0x10000 || sub_10015650(v5) == 4 )
  {
    v7 = sub_1001C9E0(0x24u) && sub_1001C9E0(0x3Cu);
    v8 = v7;
    v9 = (unsigned __int16 *)sub_1002DEF0(a1);
    sub_1001C980(a2, v9, a3, a4, v8, a5);
  }
  if ( v13 & 0x20000 || sub_10015650(v6) == 4 )
  {
    v10 = sub_1001C9E0(0x25u) && sub_1001C9E0(0x3Du);
    v11 = v10;
    v12 = (unsigned __int16 *)sub_1002DEF0(a1);
    sub_1001C980(a2, v12, a3, a4, v11, a5);
  }
}

//----- (1001D9A0) --------------------------------------------------------
char __cdecl sub_1001D9A0(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // eax@2
  void *v6; // ecx@2
  unsigned __int8 v7; // al@4
  char v8; // ST10_1@4
  unsigned __int16 *v9; // eax@4
  char result; // al@5
  unsigned __int8 v11; // [sp+10h] [bp-8h]@1
  int v12; // [sp+14h] [bp-4h]@1

  sub_1001FF50((int)&v12);
  v11 = 0;
  do
  {
    v5 = sub_1002DFD0(v11);
    if ( v5 & v12 || sub_10015650(v6) == 4 )
    {
      v7 = sub_100200A0(v11);
      v8 = sub_1001C9E0(v7);
      v9 = (unsigned __int16 *)sub_1002DF50(v11, a1);
      sub_1001C980(a2, v9, a3, a4, v8, a5);
    }
    result = v11++ + 1;
  }
  while ( v11 < 2u );
  return result;
}

//----- (1001DA30) --------------------------------------------------------
char __cdecl sub_1001DA30(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  char v5; // si@2
  signed int v6; // eax@2
  unsigned __int8 v7; // al@3
  char v8; // ST14_1@3
  unsigned __int16 *v9; // eax@3
  int v10; // ecx@3
  char v11; // ST14_1@4
  unsigned __int16 *v12; // eax@4
  unsigned __int16 *v13; // edi@5
  unsigned __int16 *v14; // eax@12
  unsigned __int16 *v15; // eax@14
  unsigned __int8 v16; // al@14
  unsigned __int16 *v17; // eax@15
  char result; // al@17
  char v19; // [sp+13h] [bp-1Dh]@6
  unsigned __int16 v20; // [sp+14h] [bp-1Ch]@6
  int v21; // [sp+18h] [bp-18h]@14
  unsigned __int8 *v22; // [sp+1Ch] [bp-14h]@11
  int v23; // [sp+20h] [bp-10h]@3
  int v24; // [sp+24h] [bp-Ch]@1
  int v25; // [sp+28h] [bp-8h]@1
  int v26; // [sp+2Ch] [bp-4h]@12

  sub_1001FF50((int)&v25);
  LOBYTE(v24) = 0;
  do
  {
    v5 = v24;
    v6 = sub_1002E360(v24);
    if ( v6 & v25 )
    {
      memset(&unk_1017B258, 0, 0x890u);
      sub_1001FF20(v5, (int)&unk_1017B258);
      v7 = sub_1002E320(v5);
      LOBYTE(v23) = sub_1001C9E0(v7);
      v8 = v23;
      v9 = (unsigned __int16 *)sub_1002E0C0(v5, a1);
      sub_1001C980(a2, v9, a3, a4, v8, a5);
      if ( (unsigned __int8)sub_1002CF70(v10) )
      {
        v11 = v23;
        v12 = (unsigned __int16 *)sub_1002E2C0(v5, a1);
        sub_1001C980(a2, v12, a3, a4, v11, a5);
      }
      v13 = (unsigned __int16 *)&unk_1017B2FA;
      do
      {
        if ( sub_1001A280(*v13, v5, &v19, &v20) == 1 && v19 == a1 && v20 < a2 )
          *(_BYTE *)(*(_WORD *)(a5 + 2 * v20) + a3) = v23;
        v13 += 8;
      }
      while ( (signed int)v13 < (signed int)&unk_1017B5CA );
      v22 = (unsigned __int8 *)&unk_1017B259;
      do
      {
        LOBYTE(v26) = *v22;
        v14 = (unsigned __int16 *)sub_1002DFF0(v5, v26, a1);
        sub_1001C980(a2, v14, a3, a4, 1, a5);
        v22 += 4;
      }
      while ( (signed int)v22 <= (signed int)&unk_1017B2F5 );
      v22 = (unsigned __int8 *)&unk_1017B5C9;
      do
      {
        LOBYTE(v21) = *(v22 - 1);
        v15 = (unsigned __int16 *)sub_1002E150(v5, v21, a1);
        sub_1001C980(a2, v15, a3, a4, 1, a5);
        v16 = *v22;
        if ( (_BYTE)v21 != *v22 )
        {
          LOBYTE(v21) = *v22;
          v17 = (unsigned __int16 *)sub_1002E150(v5, v16, a1);
          sub_1001C980(a2, v17, a3, a4, 1, a5);
        }
        v22 += 8;
      }
      while ( (signed int)v22 < (signed int)&unk_1017B649 );
    }
    result = v24 + 1;
    LOBYTE(v24) = v24 + 1;
  }
  while ( (unsigned __int8)v24 < 3u );
  return result;
}

//----- (1001DC40) --------------------------------------------------------
char __cdecl sub_1001DC40(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  void *v5; // ecx@1
  int v6; // eax@1
  void *v7; // ecx@1
  signed int v8; // eax@2
  void *v9; // ecx@2
  void *v10; // ecx@3
  unsigned __int8 v11; // al@4
  unsigned __int16 *v12; // eax@4
  char v13; // ST10_1@4
  unsigned __int16 *v14; // eax@4
  __int16 *v15; // eax@4
  int v16; // ecx@4
  unsigned __int16 *v17; // eax@5
  unsigned __int16 *v18; // eax@7
  int v19; // eax@9
  char v21; // [sp+13h] [bp-Dh]@1
  char v22; // [sp+14h] [bp-Ch]@1
  int v23; // [sp+18h] [bp-8h]@1
  int v24; // [sp+1Ch] [bp-4h]@4

  sub_1001FF50((int)&v23);
  v6 = sub_10014FA0(v5);
  v23 |= v6;
  v21 = sub_10015650(v7);
  v22 = 3;
  do
  {
    v8 = sub_10016610(v22);
    if ( v8 & v23 || sub_10015650(v9) == 4 )
    {
      v11 = sub_10016530(v22);
      LOBYTE(v24) = sub_1001C9E0(v11);
      v12 = (unsigned __int16 *)sub_1002E410(a1);
      sub_1001C980(a2, v12, a3, a4, 1, a5);
      v13 = v24;
      v14 = (unsigned __int16 *)sub_1002E4D0(v22, a1);
      sub_1001C980(a2, v14, a3, a4, v13, a5);
      v15 = sub_1002C860(a1, a2);
      sub_1001C980(a2, (unsigned __int16 *)v15, a3, a4, 1, a5);
      if ( (unsigned __int8)sub_1002CF70(v16) )
      {
        v17 = (unsigned __int16 *)sub_1002E3B0(a1);
        sub_1001C980(a2, v17, a3, a4, 1, a5);
      }
      if ( sub_1002CF60() )
      {
        v18 = (unsigned __int16 *)sub_1002E470(a1);
        sub_1001C980(a2, v18, a3, a4, 1, a5);
      }
    }
    ++v22;
  }
  while ( (unsigned __int8)v22 < 7u );
  LOBYTE(v19) = v21;
  if ( v21 == 2 || v21 == 8 )
  {
    LOBYTE(v19) = a1;
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        LOBYTE(v19) = sub_10014FA0(v10);
        if ( v19 & 0xF0 )
        {
          *(_BYTE *)(*(_WORD *)(a5 + 492) + a3) = 1;
          *(_BYTE *)(*(_WORD *)(a5 + 496) + a3) = 1;
          v19 = *(_WORD *)(a5 + 494);
          *(_BYTE *)(v19 + a3) = 1;
        }
      }
    }
    else
    {
      *(_BYTE *)(*(_WORD *)(a5 + 980) + a3) = 1;
      *(_BYTE *)(*(_WORD *)(a5 + 982) + a3) = 1;
      *(_BYTE *)(*(_WORD *)(a5 + 1178) + a3) = 1;
      v19 = *(_WORD *)(a5 + 1180);
      *(_BYTE *)(v19 + a3) = 1;
    }
  }
  else if ( !a1 )
  {
    *(_BYTE *)(*(_WORD *)(a5 + 980) + a3) = sub_1001C9E0(0x28u);
    *(_BYTE *)(*(_WORD *)(a5 + 982) + a3) = sub_1001C9E0(0x29u);
    *(_BYTE *)(*(_WORD *)(a5 + 1178) + a3) = sub_1001C9E0(0x33u);
    LOBYTE(v19) = sub_1001C9E0(0x34u);
    *(_BYTE *)(*(_WORD *)(a5 + 1180) + a3) = v19;
  }
  return v19;
}

//----- (1001DE60) --------------------------------------------------------
void __cdecl sub_1001DE60(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // ecx@0
  void *v6; // ecx@1
  char v7; // ST0C_1@3
  unsigned __int16 *v8; // eax@3
  int v9; // [sp+0h] [bp-4h]@1

  v9 = v5;
  sub_1001FF50((int)&v9);
  if ( v9 & 0x4000 || sub_10015650(v6) == 4 )
  {
    v7 = sub_1001C9E0(0x20u);
    v8 = (unsigned __int16 *)sub_1002E570(a1);
    sub_1001C980(a2, v8, a3, a4, v7, a5);
  }
}

//----- (1001DEC0) --------------------------------------------------------
void __cdecl sub_1001DEC0(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // ecx@0
  void *v6; // ecx@1
  char v7; // ST0C_1@3
  unsigned __int16 *v8; // eax@3
  int v9; // [sp+0h] [bp-4h]@1

  v9 = v5;
  sub_1001FF50((int)&v9);
  if ( v9 & 0x400 || sub_10015650(v6) == 4 )
  {
    v7 = sub_1001C9E0(0x13u);
    v8 = (unsigned __int16 *)sub_1002E5D0(a1);
    sub_1001C980(a2, v8, a3, a4, v7, a5);
  }
}

//----- (1001DF20) --------------------------------------------------------
void *__usercall sub_1001DF20@<eax>(void *a1@<ebx>, const void *a2@<edi>, int a3@<esi>, int a4)
{
  void *result; // eax@1
  int v5; // [sp+0h] [bp-Ch]@0
  int v6; // [sp+4h] [bp-8h]@0

  result = (void *)sub_100303F0(a4, v5, v6);
  if ( result )
  {
    sub_100304C0(a4, (int)a2, a3);
    result = memcpy(a1, a2, (unsigned __int16)a3);
  }
  return result;
}

//----- (1001DF50) --------------------------------------------------------
char sub_1001DF50()
{
  char v1; // [sp+Fh] [bp-1h]@1

  sub_1001DF20(&v1, &unk_10063402, 1, 2119);
  return v1;
}

//----- (1001DF80) --------------------------------------------------------
char __cdecl sub_1001DF80(int a1)
{
  char v1; // bl@1
  int v2; // esi@1
  int v3; // eax@1

  v1 = 0;
  v2 = j_HWM_pvg_hsdb_get_lrus_online();
  j_HWM_pvg_hsdb_set_sim_lrus_online(0);
  v3 = j_HWM_pvg_hsdb_get_lrus_online();
  if ( (a1 & v3) == a1 )
    v1 = 1;
  j_HWM_pvg_hsdb_set_sim_lrus_online(v2 - v3);
  return v1;
}
// 100080D0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 10008110: using guessed type int __cdecl j_HWM_pvg_hsdb_set_sim_lrus_online(_DWORD);

//----- (1001DFC0) --------------------------------------------------------
signed int __cdecl sub_1001DFC0(_BYTE *a1, char a2, int a3)
{
  signed int result; // eax@1

  result = -4;
  if ( a3 && a3 != 1 || (!*a1 || *a1 == 1 ? (result = 0) : (result = -2), a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_11;
  }
  if ( result )
  {
LABEL_11:
    *a1 = a2;
    result = 1;
  }
  return result;
}

//----- (1001E010) --------------------------------------------------------
int __cdecl sub_1001E010(int a1, float a2, float a3, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  char v7; // dl@4
  char v8; // al@4
  char v9; // dl@4
  int result; // eax@5
  double v11; // st7@7
  unsigned int v12; // eax@21

  v5 = a1;
  v6 = a1 & 3;
  if ( a1 & 3 || (unsigned int)&a1 & 3 )
  {
    v7 = *(_BYTE *)(a1 + 1);
    LOBYTE(a1) = *(_BYTE *)a1;
    v8 = *(_BYTE *)(v5 + 2);
    BYTE1(a1) = v7;
    v9 = *(_BYTE *)(v5 + 3);
    BYTE2(a1) = v8;
    BYTE3(a1) = v9;
  }
  else
  {
    a1 = *(int *)a1;
  }
  result = -4;
  if ( a5 && a5 != 1
    || ((v11 = *(float *)&a1, (a1 & 0x7F800000) != 2139095040) ? (a2 <= v11 ? (a3 >= v11 ? (result = 0) : (result = -2)) : (result = -1)) : (result = -3),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v12 = a4;
    *(_BYTE *)(v5 + 1) = BYTE1(a4);
    *(_BYTE *)v5 = v12;
    *(_BYTE *)(v5 + 3) = BYTE3(v12);
    *(_BYTE *)(v5 + 2) = v12 >> 16;
    result = 1;
  }
  else
  {
    *(_DWORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (1001E100) --------------------------------------------------------
unsigned int __cdecl sub_1001E100(char *a1, char a2, char a3, char a4, int a5)
{
  char v5; // dl@1
  unsigned int result; // eax@1
  int v7; // eax@5

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1
    || (v5 >= a2 ? (v7 = v5 < a3, LOBYTE(v7) = v5 <= a3, result = (v7 - 1) & 0xFFFFFFFE) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (1001E150) --------------------------------------------------------
unsigned int __cdecl sub_1001E150(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  _BYTE *v8; // esi@3
  int v9; // eax@9
  signed int v10; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((signed int)v8 >= a2 ? (v9 = (signed int)v8 < a3,
                                LOBYTE(v9) = (signed int)v8 <= a3,
                                result = (v9 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v10 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v10;
    v5[3] = BYTE3(v10);
    v5[2] = v10 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (1001E210) --------------------------------------------------------
unsigned int __cdecl sub_1001E210(void *a1, size_t a2, int a3)
{
  unsigned int result; // eax@1
  int v4; // eax@3
  int v5; // ecx@3
  unsigned int v6; // ecx@3

  result = -4;
  if ( a3 && a3 != 1
    || (v4 = sub_100152E0(a1, a2), v5 = v4 < 0, LOBYTE(v5) = v4 >= 0, v6 = (v5 - 1) & 0xFFFFFFFC, result = v6, a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_7;
  }
  if ( v6 )
  {
LABEL_7:
    memset(a1, 0, a2);
    result = 1;
  }
  return result;
}

//----- (1001E270) --------------------------------------------------------
int __cdecl sub_1001E270(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
  unsigned __int8 v5; // dl@1
  int result; // eax@1

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1 || (v5 >= a2 ? (result = a3 < v5 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (1001E2C0) --------------------------------------------------------
int __cdecl sub_1001E2C0(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // esi@1
  int result; // eax@1
  char v8; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned __int16)a1 >= a2 ? (result = a3 < (unsigned __int16)a1 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v8 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v8;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (1001E360) --------------------------------------------------------
int __cdecl sub_1001E360(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  int result; // eax@1
  _BYTE *v8; // esi@3
  unsigned int v9; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned int)v8 >= a2 ? (result = a3 < (unsigned int)v8 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v9 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v9;
    v5[3] = BYTE3(v9);
    v5[2] = v9 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (1001E410) --------------------------------------------------------
int __cdecl sub_1001E410(unsigned __int8 *a1)
{
  return sub_1001E270(a1, 0, 0, 0, 0);
}

//----- (1001E430) --------------------------------------------------------
unsigned int __cdecl sub_1001E430(void *a1)
{
  return sub_1001E210(a1, 0x20u, 0);
}

//----- (1001E450) --------------------------------------------------------
unsigned int __cdecl sub_1001E450(void *a1)
{
  return sub_1001E210(a1, 0x1Cu, 0);
}

//----- (1001E470) --------------------------------------------------------
unsigned int __cdecl sub_1001E470(void *a1)
{
  return sub_1001E210(a1, 0x10u, 0);
}

//----- (1001E490) --------------------------------------------------------
unsigned int __cdecl sub_1001E490(void *a1)
{
  return sub_1001E210(a1, 0xCu, 0);
}

//----- (1001E4B0) --------------------------------------------------------
unsigned int __cdecl sub_1001E4B0(void *a1)
{
  return sub_1001E210(a1, 8u, 0);
}

//----- (1001E4D0) --------------------------------------------------------
int __cdecl sub_1001E4D0(int a1)
{
  int result; // eax@1

  result = sub_1001E270((unsigned __int8 *)(a1 + 1), 1u, 0x1Fu, 1u, 0);
  if ( !result )
  {
    result = sub_1001E270((unsigned __int8 *)a1, 1u, 0xCu, 1u, 0);
    if ( !result )
      result = sub_1001E2C0((_BYTE *)(a1 + 2), 0x7C6u, 0xFFFFu, 1990, 0);
  }
  return result;
}

//----- (1001E520) --------------------------------------------------------
int __cdecl sub_1001E520(void *a1)
{
  int result; // eax@1

  result = sub_1001E430((char *)a1 + 64);
  if ( !result )
  {
    result = sub_1001E430((char *)a1 + 128);
    if ( !result )
    {
      result = sub_1001E4B0((char *)a1 + 120);
      if ( !result )
      {
        result = sub_1001E450((char *)a1 + 36);
        if ( !result )
        {
          result = sub_1001E4D0((int)a1 + 168);
          if ( !result )
          {
            result = sub_1001E4D0((int)a1 + 160);
            if ( !result )
            {
              result = sub_1001E4D0((int)a1 + 164);
              if ( !result )
              {
                result = sub_1001E470(a1);
                if ( !result )
                {
                  result = sub_1001E490((char *)a1 + 96);
                  if ( !result )
                  {
                    result = sub_1001E490((char *)a1 + 24);
                    if ( !result )
                      result = sub_1001E4B0((char *)a1 + 16);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (1001E5F0) --------------------------------------------------------
unsigned int __cdecl sub_1001E5F0(void *a1)
{
  unsigned int result; // eax@1

  result = sub_1001E430((char *)a1 + 64);
  if ( !result )
  {
    result = sub_1001E450((char *)a1 + 36);
    if ( !result )
    {
      result = sub_1001E470(a1);
      if ( !result )
      {
        result = sub_1001E490((char *)a1 + 96);
        if ( !result )
        {
          result = sub_1001E490((char *)a1 + 24);
          if ( !result )
            result = sub_1001E4B0((char *)a1 + 16);
        }
      }
    }
  }
  return result;
}

//----- (1001E650) --------------------------------------------------------
int __cdecl sub_1001E650(unsigned __int8 *a1)
{
  return sub_1001E270(a1, 0, 0x7Fu, 0, 0);
}

//----- (1001E670) --------------------------------------------------------
int __cdecl sub_1001E670(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1001E270(a1, 0, 0x7Fu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1001E6A0) --------------------------------------------------------
int __cdecl sub_1001E6A0(unsigned __int8 *a1)
{
  return sub_1001E270(a1, 0, 3u, 0, 0);
}

//----- (1001E6C0) --------------------------------------------------------
int __cdecl sub_1001E6C0(_BYTE *a1)
{
  return sub_1001E2C0(a1, 0, 0x2710u, 5000, 0);
}

//----- (1001E6E0) --------------------------------------------------------
int __cdecl sub_1001E6E0(unsigned __int8 *a1)
{
  return sub_1001E270(a1, 0, 5u, 5u, 0);
}

//----- (1001E700) --------------------------------------------------------
int __cdecl sub_1001E700(unsigned __int8 *a1)
{
  return sub_1001E270(a1, 0, 6u, 0, 0);
}

//----- (1001E720) --------------------------------------------------------
int __cdecl sub_1001E720(unsigned __int8 *a1)
{
  return sub_1001E270(a1, 0, 0xEu, 1u, 0);
}

//----- (1001E740) --------------------------------------------------------
int __cdecl sub_1001E740(unsigned __int8 *a1)
{
  return sub_1001E270(a1, 0, 1u, 0, 0);
}

//----- (1001E770) --------------------------------------------------------
int __cdecl sub_1001E770(int a1)
{
  int result; // eax@1

  result = sub_1001E6E0((unsigned __int8 *)a1);
  if ( !result )
  {
    result = sub_1001E760(a1 + 12);
    if ( !result )
    {
      result = sub_1001E740((unsigned __int8 *)(a1 + 1));
      if ( !result )
        result = sub_1001E720((unsigned __int8 *)(a1 + 2));
    }
  }
  return result;
}
// 1001E760: using guessed type _DWORD __cdecl sub_1001E760(_DWORD);

//----- (1001E7B0) --------------------------------------------------------
int __cdecl sub_1001E7B0(int a1)
{
  int result; // eax@1

  result = sub_1001E520((void *)(a1 + 28));
  if ( !result )
    result = sub_1001E770(a1);
  return result;
}

//----- (1001E7D0) --------------------------------------------------------
char __cdecl sub_1001E7D0(_WORD *a1, int a2, int a3, int a4, int a5)
{
  char result; // al@1
  char v6; // cl@2
  char v7; // dl@2
  __int16 v8; // ax@2
  char v9; // cl@2
  char v10; // dl@2
  __int16 v11; // ax@2
  char v12; // cl@2
  char v13; // dl@2
  __int16 v14; // ax@2
  __int16 v15; // cx@2
  char v16; // dl@2
  __int16 v17; // [sp+10h] [bp-14h]@2
  char v18; // [sp+12h] [bp-12h]@2
  char v19; // [sp+13h] [bp-11h]@2
  __int16 v20; // [sp+14h] [bp-10h]@2
  char v21; // [sp+16h] [bp-Eh]@2
  char v22; // [sp+17h] [bp-Dh]@2
  __int16 v23; // [sp+18h] [bp-Ch]@2
  char v24; // [sp+1Ah] [bp-Ah]@2
  char v25; // [sp+1Bh] [bp-9h]@2
  __int16 v26; // [sp+1Ch] [bp-8h]@2
  unsigned __int8 v27; // [sp+1Eh] [bp-6h]@2
  char v28; // [sp+1Fh] [bp-5h]@2
  char v29; // [sp+20h] [bp-4h]@2

  *a1 = 0x7FFF;
  result = -1;
  *(_DWORD *)a2 = -1;
  *(_DWORD *)a3 = -1;
  *(_DWORD *)a4 = -1;
  *(_DWORD *)a5 = -32769;
  if ( !byte_1020D7F4 )
  {
    (*(void (__cdecl **)(signed int, signed int, __int16 *))dword_1020CF70)(129, 17, &v17);
    v6 = v18;
    *a1 = v17;
    v7 = v19;
    v8 = v20;
    *(_BYTE *)a2 = v6;
    v9 = v21;
    *(_BYTE *)(a2 + 1) = v7;
    v10 = v22;
    *(_WORD *)(a2 + 2) = v8;
    v11 = v23;
    *(_BYTE *)a3 = v9;
    v12 = v24;
    *(_BYTE *)(a3 + 1) = v10;
    v13 = v25;
    *(_WORD *)(a3 + 2) = v11;
    v14 = v26;
    *(_BYTE *)a4 = v12;
    v15 = v27;
    *(_BYTE *)(a4 + 1) = v13;
    v16 = v28;
    *(_WORD *)(a4 + 2) = v14;
    result = v29;
    *(_WORD *)a5 = v15;
    *(_BYTE *)(a5 + 2) = v16;
    *(_BYTE *)(a5 + 3) = result;
  }
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;
// 1020D7F4: using guessed type char byte_1020D7F4;

//----- (1001E8A0) --------------------------------------------------------
int __cdecl sub_1001E8A0(int a1)
{
  int result; // eax@1

  result = 538976288;
  *(_DWORD *)a1 = 538976288;
  *(_DWORD *)(a1 + 4) = 538976288;
  *(_DWORD *)(a1 + 8) = 538976288;
  *(_DWORD *)(a1 + 12) = 538976288;
  *(_DWORD *)(a1 + 16) = 538976288;
  *(_DWORD *)(a1 + 20) = 538976288;
  *(_DWORD *)(a1 + 24) = 538976288;
  *(_WORD *)(a1 + 28) = 8224;
  if ( !byte_1020D7F4 )
    result = (*(int (__cdecl **)(signed int, signed int, int))dword_1020CF70)(159, 30, a1);
  *(_BYTE *)(a1 + 30) = 0;
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;
// 1020D7F4: using guessed type char byte_1020D7F4;

//----- (1001E8F0) --------------------------------------------------------
int __cdecl sub_1001E8F0(_BYTE *a1)
{
  int result; // eax@1

  result = (int)a1;
  *a1 = 0;
  if ( !byte_1020D7F4 )
    result = (*(int (__cdecl **)(signed int, signed int, _BYTE *))dword_1020CF70)(146, 1, a1);
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;
// 1020D7F4: using guessed type char byte_1020D7F4;

//----- (1001E920) --------------------------------------------------------
char __cdecl sub_1001E920(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  char v3; // [sp+8h] [bp-14h]@2
  unsigned __int8 v4; // [sp+9h] [bp-13h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_1020D7F4 )
  {
    (*(void (__cdecl **)(int, signed int, char *))dword_1020CF70)(dword_1020D2C4, 18, &v3);
    result = v4 & 0xF;
    *a2 = v4 >> 4;
    *a1 = result;
  }
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;
// 1020D2C4: using guessed type int dword_1020D2C4;
// 1020D7F4: using guessed type char byte_1020D7F4;

//----- (1001E970) --------------------------------------------------------
char __cdecl sub_1001E970(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  unsigned __int8 v3; // [sp+8h] [bp-14h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_1020D7F4 )
  {
    (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_1020CF70)(dword_1020D2C4, 18, &v3);
    result = v3 & 0xF;
    *a2 = v3 >> 4;
    *a1 = result;
  }
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;
// 1020D2C4: using guessed type int dword_1020D2C4;
// 1020D7F4: using guessed type char byte_1020D7F4;

//----- (1001E9C0) --------------------------------------------------------
int sub_1001E9C0()
{
  int result; // eax@1
  unsigned int v1; // ecx@1
  int v2; // edi@4
  int *v3; // esi@5
  int v4; // ebx@5
  int v5; // edx@6
  int v6; // [sp+4h] [bp-Ch]@1
  int v7; // [sp+8h] [bp-8h]@4
  unsigned int v8; // [sp+Ch] [bp-4h]@4

  memset(dword_1020CFA0, 0, 0x708u);
  result = (*(int (__cdecl **)(signed int, int *))dword_1020CF60)(512, &v6);
  v1 = 0;
  do
  {
    word_1020CFA4[v1 / 2] = 0;
    dword_1020CFA8[v1 / 4] = 0;
    dword_1020CFA0[v1 / 4] = 0;
    v1 += 12;
  }
  while ( v1 < 0x708 );
  if ( (_BYTE)result )
  {
    dword_1020CFAC = v6;
    result = v8;
    v2 = (unsigned __int16)v7 + 512;
    dword_1020CFB0 = v7;
    dword_1020CFB4 = v8;
    if ( v8 >= 2 )
    {
      v3 = &dword_1020CFB8;
      v4 = v8 - 1;
      do
      {
        (*(void (__cdecl **)(int, int *))dword_1020CF60)(v2, &v6);
        v5 = v7;
        result = v8;
        *v3 = v6;
        v3[1] = v5;
        v3[2] = result;
        v2 += (unsigned __int16)dword_1020CFB0;
        v3 += 3;
        --v4;
      }
      while ( v4 );
    }
  }
  return result;
}
// 1020CF60: using guessed type int dword_1020CF60;
// 1020CFA0: using guessed type int dword_1020CFA0[];
// 1020CFA4: using guessed type __int16 word_1020CFA4[];
// 1020CFA8: using guessed type int dword_1020CFA8[];
// 1020CFAC: using guessed type int dword_1020CFAC;
// 1020CFB0: using guessed type int dword_1020CFB0;
// 1020CFB4: using guessed type int dword_1020CFB4;
// 1020CFB8: using guessed type int dword_1020CFB8;

//----- (1001EA90) --------------------------------------------------------
__int16 sub_1001EA90()
{
  __int16 result; // ax@1
  unsigned int v1; // ebx@1
  unsigned int v2; // esi@1
  int v3; // edi@1
  int v4; // ebp@2
  __int16 v5; // [sp+Ch] [bp-4h]@3

  result = word_1020CFBC;
  v1 = dword_1020CFC0;
  v2 = 1;
  v3 = dword_1020CFB8;
  if ( (unsigned int)dword_1020CFC0 >= 1 )
  {
    v4 = (unsigned __int16)word_1020CFBC;
    do
    {
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_1020CF70)(v3, 2, &v5);
      result = v5;
      word_1020D6C0[v2++] = v5;
      v3 += v4;
    }
    while ( v2 <= v1 );
  }
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;
// 1020CFB8: using guessed type int dword_1020CFB8;
// 1020CFBC: using guessed type __int16 word_1020CFBC;
// 1020CFC0: using guessed type int dword_1020CFC0;
// 1020D6C0: using guessed type __int16 word_1020D6C0[];

//----- (1001EAF0) --------------------------------------------------------
int __usercall sub_1001EAF0@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4)
{
  signed int v4; // edx@1
  _BYTE *v5; // ecx@2
  unsigned int v6; // ebx@2
  unsigned __int16 v7; // ax@7

  v4 = 0;
  if ( a3 > 0 )
  {
    v5 = a2;
    v6 = a3;
    do
    {
      if ( v4 & 3 )
      {
        if ( (v4 & 3) == 1 )
        {
          result = v6 >> 4;
        }
        else
        {
          --v5;
          result = (v4 & 3) - 2;
          if ( (v4 & 3) == 2 )
          {
            HIBYTE(v7) = v5[1];
            LOBYTE(v7) = *v5;
            v6 = v7;
            result = (unsigned int)v7 >> 6;
          }
          else
          {
            LOBYTE(result) = v6;
          }
        }
      }
      else
      {
        HIWORD(result) = 0;
        BYTE1(result) = *v5--;
        LOBYTE(result) = *v5;
        v6 = (unsigned __int16)result;
        LOWORD(result) = (unsigned __int16)result >> 10;
      }
      LOBYTE(result) = (result & 0x3F) + 32;
      *(_BYTE *)(v4++ + a4) = result;
    }
    while ( v4 < a3 );
  }
  return result;
}

//----- (1001EB70) --------------------------------------------------------
char sub_1001EB70()
{
  char v0; // al@1
  unsigned __int8 v1; // bl@2
  unsigned int v2; // ecx@3
  char *v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // ecx@8
  _BYTE *v7; // eax@8
  _BYTE *v8; // edx@8
  int v9; // ecx@10
  _BYTE *v10; // eax@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // eax@12
  _BYTE *v13; // edx@12
  signed int v14; // eax@14
  char result; // al@24
  char v16; // [sp+Fh] [bp-25h]@20
  char v17; // [sp+10h] [bp-24h]@1
  char v18; // [sp+1Bh] [bp-19h]@2
  char v19; // [sp+1Ch] [bp-18h]@2

  byte_1020D7F4 = 1;
  v0 = (*(int (__cdecl **)(signed int, signed int, char *))dword_1020CF70)(147, 12, &v17);
  byte_1020D7F4 = 1;
  dword_1017BAEC = 0;
  dword_1017BAF0 = 0;
  dword_1017BAF4 = 0;
  dword_1017BAF8 = 0;
  byte_1017BAFC = 0;
  if ( !v0 )
    return (unsigned int)memset(dword_1020CFA0, 0, 0x708u);
  sub_1001EAF0((int)&v19, &v18, 16, (int)&v19);
  v1 = 0;
  while ( 1 )
  {
    v2 = 10;
    v3 = &a006D0170[11 * v1];
    v4 = &v19;
    do
    {
      if ( *(_DWORD *)v4 != *(_DWORD *)v3 )
        goto LABEL_7;
      v2 -= 4;
      v3 += 4;
      v4 += 4;
    }
    while ( v2 >= 4 );
    if ( !v2 )
    {
LABEL_16:
      v14 = 0;
      goto LABEL_17;
    }
LABEL_7:
    v5 = (unsigned __int8)*v4 - (unsigned __int8)*v3;
    if ( (unsigned __int8)*v4 == (unsigned __int8)*v3 )
    {
      v6 = v2 - 1;
      v7 = v3 + 1;
      v8 = v4 + 1;
      if ( !v6 )
        goto LABEL_16;
      v5 = *v8 - *v7;
      if ( *v8 == *v7 )
      {
        v9 = v6 - 1;
        v10 = v7 + 1;
        v11 = v8 + 1;
        if ( !v9 )
          goto LABEL_16;
        v5 = *v11 - *v10;
        if ( *v11 == *v10 )
        {
          v12 = v10 + 1;
          v13 = v11 + 1;
          if ( v9 == 1 )
            goto LABEL_16;
          v5 = *v13 - *v12;
          if ( *v13 == *v12 )
            goto LABEL_16;
        }
      }
    }
    v14 = 1;
    if ( v5 <= 0 )
      v14 = -1;
LABEL_17:
    if ( !v14 )
      break;
    if ( ++v1 >= 3u )
      return (unsigned int)memset(dword_1020CFA0, 0, 0x708u);
  }
  byte_1020D7F4 = 0;
  sub_1001E8F0(&v16);
  if ( v16 != 101 )
  {
    byte_1020D7F4 = 2;
    return (unsigned int)memset(dword_1020CFA0, 0, 0x708u);
  }
  if ( byte_1020D7F4 )
    return (unsigned int)memset(dword_1020CFA0, 0, 0x708u);
  sub_1001E970(&unk_1020D6A8, &byte_1020D7ED);
  byte_1020D7EC = byte_1020D7ED - 1;
  if ( byte_1020D7F4 )
    return (unsigned int)memset(dword_1020CFA0, 0, 0x708u);
  result = sub_1001E920(&unk_1020D6A9, &unk_1020D6AA);
  byte_1020CF98 = 0;
  if ( byte_1020D7F4 )
    return (unsigned int)memset(dword_1020CFA0, 0, 0x708u);
  return result;
}
// 1017BAEC: using guessed type int dword_1017BAEC;
// 1017BAF0: using guessed type int dword_1017BAF0;
// 1017BAF4: using guessed type int dword_1017BAF4;
// 1017BAF8: using guessed type int dword_1017BAF8;
// 1017BAFC: using guessed type char byte_1017BAFC;
// 1020CF70: using guessed type int dword_1020CF70;
// 1020CF98: using guessed type char byte_1020CF98;
// 1020CFA0: using guessed type int dword_1020CFA0[];
// 1020D7EC: using guessed type char byte_1020D7EC;
// 1020D7ED: using guessed type char byte_1020D7ED;
// 1020D7F4: using guessed type char byte_1020D7F4;

//----- (1001ED30) --------------------------------------------------------
int (__cdecl *(*sub_1001ED30())[2])(int, int)
{
  int (__cdecl *(*result)[2])(int, int); // eax@1
  unsigned int v1; // edi@2
  char *v2; // ecx@3
  unsigned int v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // eax@8
  _BYTE *v7; // ecx@8
  _BYTE *v8; // edx@8
  int v9; // eax@10
  _BYTE *v10; // ecx@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // ecx@12
  _BYTE *v13; // edx@12
  char v14; // [sp+0h] [bp-24h]@1
  char v15; // [sp+Bh] [bp-19h]@2
  char v16; // [sp+Ch] [bp-18h]@2

  dword_1020CF60 = (int)off_100A1C20;
  result = (int (__cdecl *(*)[2])(int, int))(*(int (__cdecl **)(signed int, signed int, char *))dword_1020CF70)(
                                              147,
                                              12,
                                              &v14);
  if ( (_BYTE)result )
  {
    sub_1001EAF0((int)&v16, &v15, 16, (int)&v16);
    v1 = 0;
    do
    {
      v2 = (&off_10065B18)[8 * v1];
      v3 = strlen((&off_10065B18)[8 * v1]);
      v4 = &v16;
      if ( v3 < 4 )
      {
LABEL_6:
        if ( !v3 )
          goto LABEL_16;
      }
      else
      {
        while ( *(_DWORD *)v4 == *(_DWORD *)v2 )
        {
          v3 -= 4;
          v2 += 4;
          v4 += 4;
          if ( v3 < 4 )
            goto LABEL_6;
        }
      }
      v5 = (unsigned __int8)*v4 - (unsigned __int8)*v2;
      if ( (unsigned __int8)*v4 == (unsigned __int8)*v2 )
      {
        v6 = v3 - 1;
        v7 = v2 + 1;
        v8 = v4 + 1;
        if ( !v6
          || (v5 = *v8 - *v7, *v8 == *v7)
          && ((v9 = v6 - 1, v10 = v7 + 1, v11 = v8 + 1, !v9)
           || (v5 = *v11 - *v10, *v11 == *v10)
           && ((v12 = v10 + 1, v13 = v11 + 1, v9 == 1) || (v5 = *v13 - *v12, *v13 == *v12))) )
        {
LABEL_16:
          result = 0;
          goto LABEL_17;
        }
      }
      result = (int (__cdecl *(*)[2])(int, int))1;
      if ( v5 <= 0 )
        result = (int (__cdecl *(*)[2])(int, int))-1;
LABEL_17:
      if ( !result )
      {
        result = (&off_10065B1C)[v1];
        dword_1020CF60 = (int)(&off_10065B1C)[v1];
        return result;
      }
      ++v1;
    }
    while ( v1 < 3 );
  }
  return result;
}
// 10065B18: using guessed type char *off_10065B18;
// 10065B1C: using guessed type int (__cdecl *(*off_10065B1C)[2])(int, int);
// 100A1C20: using guessed type int (__cdecl *off_100A1C20[2])(int, int);
// 1020CF60: using guessed type int dword_1020CF60;
// 1020CF70: using guessed type int dword_1020CF70;

//----- (1001EE60) --------------------------------------------------------
signed int __cdecl sub_1001EE60(int a1)
{
  signed int result; // eax@1

  result = 0x3FFFF;
  if ( a1 )
  {
    if ( *(_BYTE *)a1 < 0x17u )
      result = *(_DWORD *)(a1 + 36);
  }
  return result;
}

//----- (1001EE80) --------------------------------------------------------
double __cdecl sub_1001EE80(signed int a1, char a2)
{
  return (double)(a1 >> (31 - a2)) / (double)(1 << a2) * 3.1415926535898;
}

//----- (1001EEC0) --------------------------------------------------------
bool __cdecl sub_1001EEC0(unsigned int a1, unsigned __int16 a2)
{
  unsigned int v2; // eax@2
  bool result; // al@5

  result = 0;
  if ( a2 < 0x96u )
  {
    v2 = 12 * a2;
    if ( a1 < dword_1020CFA8[v2 / 4] && word_1020CFA4[v2 / 2] && dword_1020CFA0[v2 / 4] )
      result = 1;
  }
  return result;
}
// 1020CFA0: using guessed type int dword_1020CFA0[];
// 1020CFA4: using guessed type __int16 word_1020CFA4[];
// 1020CFA8: using guessed type int dword_1020CFA8[];

//----- (1001EF00) --------------------------------------------------------
int __cdecl sub_1001EF00(unsigned __int16 a1)
{
  unsigned __int16 v1; // dx@1
  int result; // eax@2

  if ( sub_1001EEC0(0, a1) )
    result = dword_1020CFA8[3 * v1];
  else
    result = 0;
  return result;
}
// 1020CFA8: using guessed type int dword_1020CFA8[];

//----- (1001EF30) --------------------------------------------------------
int __cdecl sub_1001EF30(double a1, double a2)
{
  double *v2; // ecx@0
  double v3; // ST00_8@1
  double v4; // st7@1
  int result; // eax@4

  v3 = *v2;
  v4 = a1;
  if ( (HIDWORD(v3) & 0x7FF00000) == 2146435072 || a1 < *v2 || (v4 = a2, a2 > *v2) )
  {
    *v2 = v4;
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1001EF80) --------------------------------------------------------
signed int sub_1001EF80()
{
  return sub_100312F0((int)&off_10065BB0);
}
// 10065BB0: using guessed type char *off_10065BB0;

//----- (1001EF90) --------------------------------------------------------
bool __cdecl sub_1001EF90(char a1, int a2)
{
  bool v2; // bl@1
  double v3; // st7@4
  int v4; // eax@4
  int v5; // ecx@8
  int v6; // eax@8
  double v7; // st5@14
  double v8; // st6@14
  float v9; // ST40_4@15
  double v10; // st5@16
  double v11; // st7@19
  float v13; // ST40_4@23
  float v14; // [sp+40h] [bp-10h]@5
  float v15; // [sp+40h] [bp-10h]@12
  float v16; // [sp+40h] [bp-10h]@16
  int v17; // [sp+44h] [bp-Ch]@8
  float v18; // [sp+48h] [bp-8h]@9
  float v19; // [sp+4Ch] [bp-4h]@9

  v2 = 0;
  if ( sub_100303F0(2047, a2, 16) )
  {
    *(double *)a2 = 0.68067840827779;
    *(double *)(a2 + 8) = -1.658062789394617;
  }
  if ( (unsigned __int8)sub_1001EF80() )
  {
    sub_10030160(101, 10000);
    v3 = 0.0;
    v4 = dword_1020CF94;
    v2 = *(_WORD *)(dword_1020CF94 + 1456) > 1u;
    if ( *(_BYTE *)(dword_1020CF94 + 1296) )
    {
      v14 = sub_1002E880(*(_DWORD *)(dword_1020CF94 + 1292));
      v4 = dword_1020CF94;
      v3 = 0.0;
    }
    else
    {
      v14 = 0.0;
    }
    if ( v2 )
    {
      v5 = *(_DWORD *)(v4 + 1524);
      v6 = v4 + 1524;
      *(_DWORD *)a2 = v5;
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(v6 + 4);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v6 + 8);
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(v6 + 12);
      sub_1001EF30(6.2831853071796, -6.2831853071796);
      sub_1001EF30(6.2831853071796, -6.2831853071796);
      sub_100325E0(v14, dword_1020CF94 + 1512, (int)&v17);
      v4 = dword_1020CF94;
      v3 = 0.0;
    }
    else
    {
      *(float *)&v17 = v3;
      v18 = v3;
      v19 = v3;
    }
    if ( a1 == 1 )
    {
      sub_100325B0((int)&v17, v4 + 1432, (int)&v17);
      v3 = 0.0;
      v4 = dword_1020CF94;
    }
    v15 = *(float *)(v4 + 1280);
    if ( (LODWORD(v15) & 0x7F800000) == 2139095040 || v15 > 0.0053898906 )
    {
      v8 = 0.0053898906;
    }
    else
    {
      v7 = v15;
      v8 = 0.0053898906;
      if ( v15 >= v3 )
        goto LABEL_16;
    }
    v9 = v3;
    v7 = v9;
LABEL_16:
    *(double *)a2 = v7 * v18 + *(double *)a2;
    v16 = *(float *)(dword_1020CF94 + 1284);
    v10 = v16;
    if ( (LODWORD(v16) & 0x7F800000) == 2139095040 || v10 > v8 || v10 < v3 )
    {
      v13 = v3;
      v11 = v13;
    }
    else
    {
      v11 = v16;
    }
    *(double *)(a2 + 8) = v11 * *(float *)&v17 + *(double *)(a2 + 8);
    sub_10030140(101);
    sub_1001F420(a2);
  }
  return v2;
}
// 1020CF94: using guessed type int dword_1020CF94;

//----- (1001F1B0) --------------------------------------------------------
int __cdecl sub_1001F1B0(int a1, signed int a2, signed int a3)
{
  int result; // eax@1

  result = a1;
  *(double *)(a1 + 8) = (double)a3 * 0.000000001462918079267163;
  *(double *)a1 = 0.000000001462918079267163 * (double)a2;
  return result;
}

//----- (1001F1D0) --------------------------------------------------------
int __cdecl sub_1001F1D0(int a1, double a2, double a3)
{
  long double v3; // st6@1
  long double v4; // st4@1
  int result; // eax@3
  double v6; // st7@6
  double v7; // [sp+0h] [bp-10h]@6
  double v8; // [sp+8h] [bp-8h]@6

  v3 = fabs(a2);
  v4 = fabs(a3);
  if ( v3 > 1.5707963267949 || v4 >= 3.1415926535898 )
  {
    if ( v3 > 4.7123889803847 || v4 > 12.5663706143592 )
    {
      result = a1;
      *(_DWORD *)a1 = 2147483648;
      *(_DWORD *)(a1 + 4) = 2147483648;
    }
    else
    {
      v7 = a2;
      v8 = a3;
      sub_1001F420((int)&v7);
      v6 = 683565275.5764301 * v8;
      *(_DWORD *)a1 = (signed int)(v7 * 683565275.5764301);
      result = (signed int)v6;
      *(_DWORD *)(a1 + 4) = (signed int)v6;
    }
  }
  else
  {
    *(_DWORD *)a1 = (signed int)(a2 * 683565275.5764301);
    result = (signed int)(683565275.5764301 * a3);
    *(_DWORD *)(a1 + 4) = result;
  }
  return result;
}

//----- (1001F2B0) --------------------------------------------------------
int __cdecl sub_1001F2B0(int a1, float a2, float a3)
{
  double v3; // st7@1
  int result; // eax@3
  double v5; // st7@6
  float v6; // [sp+0h] [bp-14h]@1
  double v7; // [sp+4h] [bp-10h]@6
  double v8; // [sp+Ch] [bp-8h]@6
  float v9; // [sp+1Ch] [bp+8h]@1

  v3 = a2;
  v6 = fabs(a2);
  v9 = fabs(a3);
  if ( v6 > 1.570796370506287 || v9 >= 3.141592741012573 )
  {
    if ( v6 > 4.7123889803847 || v9 > 12.5663706143592 )
    {
      result = a1;
      *(_DWORD *)a1 = 2147483648;
      *(_DWORD *)(a1 + 4) = 2147483648;
    }
    else
    {
      v7 = v3;
      v8 = a3;
      sub_1001F420((int)&v7);
      v5 = 683565275.5764301 * v8;
      *(_DWORD *)a1 = (signed int)(v7 * 683565275.5764301);
      result = (signed int)v5;
      *(_DWORD *)(a1 + 4) = (signed int)v5;
    }
  }
  else
  {
    *(_DWORD *)a1 = (signed int)(v3 * 683565248.0);
    result = (signed int)(683565248.0 * a3);
    *(_DWORD *)(a1 + 4) = result;
  }
  return result;
}

//----- (1001F3A0) --------------------------------------------------------
int sub_1001F3A0()
{
  int result; // eax@1

  sub_10030490(6361, (int)&unk_1017BB04, 4);
  result = sub_10030490(6362, (int)&unk_1017BB08, 4);
  dword_1017BB0C = 1379255385;
  return result;
}
// 1017BB0C: using guessed type int dword_1017BB0C;

//----- (1001F3D0) --------------------------------------------------------
int __cdecl sub_1001F3D0(int a1, int a2)
{
  return sub_1001F2B0(a1, *(float *)a2, *(float *)(a2 + 4));
}

//----- (1001F3F0) --------------------------------------------------------
bool sub_1001F3F0()
{
  return sub_10030140(99) == 0;
}

//----- (1001F400) --------------------------------------------------------
bool sub_1001F400()
{
  return sub_10030160(99, 10000) == 0;
}

//----- (1001F420) --------------------------------------------------------
int __cdecl sub_1001F420(int a1)
{
  double v1; // ST0C_8@2
  double v2; // st6@4
  double v3; // st7@4
  double v4; // ST0C_8@7
  double v5; // rt2@8
  double v6; // st6@8
  double v7; // st7@8
  double v8; // st7@14
  double v9; // st7@18
  int result; // eax@18

  if ( a1 )
  {
    v1 = *(double *)a1;
    if ( (HIDWORD(v1) & 0x7FF00000) == 2146435072 || *(double *)a1 > 6.2831853071796 )
    {
      *(double *)a1 = 6.2831853071796;
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
    }
    else
    {
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
      if ( *(double *)a1 < -6.2831853071796 )
        *(double *)a1 = -6.2831853071796;
    }
    v4 = *(double *)(a1 + 8);
    if ( (HIDWORD(v4) & 0x7FF00000) == 2146435072 )
    {
      *(double *)(a1 + 8) = v3;
    }
    else
    {
      v5 = v2;
      v6 = v3;
      v7 = v5;
      if ( v6 < *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v6;
      }
      else if ( v7 > *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v7;
      }
    }
    if ( *(double *)a1 <= 1.5707963267949 )
    {
      if ( *(double *)a1 >= -1.5707963267949 )
      {
LABEL_18:
        v9 = *(double *)(a1 + 8);
        result = sub_100324B0(v9);
        *(double *)(a1 + 8) = v9;
        return result;
      }
      *(double *)a1 = -3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    else
    {
      *(double *)a1 = 3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    *(double *)(a1 + 8) = v8;
    goto LABEL_18;
  }
  return result;
}

//----- (1001F520) --------------------------------------------------------
signed int __cdecl sub_1001F520(int a1, int a2)
{
  signed int result; // eax@2

  if ( a1 )
  {
    if ( (COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
      || (COERCE_UNSIGNED_INT(*(float *)(a1 + 4)) & 0x7F800000) == 2139095040
      || *(float *)a1 >= 1.570796370506287
      || *(float *)a1 < -1.570796370506287
      || *(float *)(a1 + 4) >= 3.141592741012573
      || *(float *)(a1 + 4) < -3.141592741012573 )
    {
      if ( a2 )
      {
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
      }
      result = 0;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1001F5C0) --------------------------------------------------------
char __cdecl sub_1001F5C0(char a1)
{
  char result; // al@3

  if ( a1 == 6 )
  {
    result = 0;
  }
  else if ( a1 == 7 )
  {
    result = 1;
  }
  else
  {
    sub_10014D70("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 294, 0, 0);
    result = 2;
  }
  return result;
}

//----- (1001F600) --------------------------------------------------------
char __cdecl sub_1001F600(char a1)
{
  char result; // al@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 7;
    }
    else
    {
      sub_10014D70("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 648, 0, 0);
      result = 67;
    }
  }
  else
  {
    result = 6;
  }
  return result;
}

//----- (1001F640) --------------------------------------------------------
signed int __cdecl sub_1001F640(char a1)
{
  signed int result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 512;
    }
    else
    {
      sub_10014D70("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 699, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = 256;
  }
  return result;
}

//----- (1001F680) --------------------------------------------------------
char __cdecl sub_1001F680(char a1)
{
  char result; // al@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 6;
    }
    else
    {
      sub_10014D70("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 750, 0, 0);
      result = -80;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001F6C0) --------------------------------------------------------
char __cdecl sub_1001F6C0(int a1)
{
  char result; // al@3

  if ( a1 == 256 )
  {
    result = 0;
  }
  else if ( a1 == 512 )
  {
    result = 1;
  }
  else
  {
    sub_10014D70("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 800, 0, 0);
    result = 2;
  }
  return result;
}

//----- (1001F700) --------------------------------------------------------
char __usercall sub_1001F700@<al>(int a1@<edi>, char a2, unsigned __int8 a3)
{
  int v3; // esi@1
  int v4; // eax@1
  char result; // al@2

  v3 = a3;
  v4 = sub_10014DE0(&a2, 1u, a1, 2, a3, a3);
  if ( v4 >= v3 )
    result = -80;
  else
    result = *(_BYTE *)(a1 + 2 * v4 + 1);
  return result;
}

//----- (1001F730) --------------------------------------------------------
char __cdecl sub_1001F730(char a1)
{
  return sub_1001F700((int)&unk_10068C28, a1, 0x33u);
}

//----- (1001F750) --------------------------------------------------------
char __cdecl sub_1001F750(char a1)
{
  return sub_1001F700((int)&unk_10068C90, a1, 0x31u);
}

//----- (1001F770) --------------------------------------------------------
char __cdecl sub_1001F770(char a1)
{
  return sub_1001F700((int)&unk_10068CF4, a1, 0x1Du);
}

//----- (1001F790) --------------------------------------------------------
char __cdecl sub_1001F790(char a1)
{
  char result; // al@2
  unsigned __int8 v2; // [sp+4h] [bp-4h]@1

  v2 = sub_1001F730(a1);
  if ( v2 == -80 )
    result = 67;
  else
    result = sub_1001FFC0(v2);
  return result;
}

//----- (1001F7C0) --------------------------------------------------------
char __cdecl sub_1001F7C0(char a1)
{
  char result; // al@2
  unsigned __int8 v2; // [sp+4h] [bp-4h]@1

  v2 = sub_1001F750(a1);
  if ( v2 == -80 )
    result = 67;
  else
    result = sub_1001FFC0(v2);
  return result;
}

//----- (1001F7F0) --------------------------------------------------------
char __cdecl sub_1001F7F0(char a1)
{
  char result; // al@2
  unsigned __int8 v2; // [sp+4h] [bp-4h]@1

  v2 = sub_1001F770(a1);
  if ( v2 == -80 )
  {
    result = 57;
    if ( a1 != 4 )
      result = 67;
  }
  else
  {
    result = sub_1001FFC0(v2);
  }
  return result;
}

//----- (1001F830) --------------------------------------------------------
int __cdecl sub_1001F830(char *a1, char a2)
{
  signed int v2; // eax@2
  int result; // eax@4
  int v4; // [sp+8h] [bp-ECh]@1
  char v5; // [sp+24h] [bp-D0h]@4

  v4 = 0;
  if ( a2 == 1 )
    v2 = 2;
  else
    v2 = a2 == 2;
  result = j_HWM_pvg_rgn_get_info(v2, &v4);
  qmemcpy(a1, &v5, 0x74u);
  return result;
}
// 100314D0: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (1001F8A0) --------------------------------------------------------
bool __cdecl sub_1001F8A0(int a1, void *a2)
{
  void *v2; // ecx@0
  char v3; // si@1
  char v4; // bl@1
  int v5; // esi@4
  bool result; // al@7

  v3 = sub_100168D0(v2);
  v4 = 0;
  do
  {
    if ( (_BYTE)a1 == (char)off_100692A8[(unsigned __int8)v4](v3) )
    {
      sub_1001F830((char *)a2, v4);
      return 1;
    }
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  v5 = (unsigned __int16)sub_1001FFE0(a1);
  if ( (unsigned __int16)v5 >= (unsigned __int16)sub_1000DC40(2) )
    result = 0;
  else
    result = sub_1000ED60(2, v5, a2) == 1 && !sub_1001E5F0(a2);
  return result;
}
// 100692A8: using guessed type int (__cdecl *off_100692A8[3])(char);

//----- (1001F960) --------------------------------------------------------
char __cdecl sub_1001F960(int a1, bool *a2)
{
  char result; // al@3
  char v3; // [sp+8h] [bp-78h]@2
  int v4; // [sp+78h] [bp-8h]@3

  switch ( (unsigned __int8)a1 )
  {
    case 1u:
    case 4u:
    case 7u:
    case 0xAu:
      if ( sub_1001F8A0(a1, &v3) )
      {
        *a2 = (v4 & 1) == 1;
        result = 1;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      *a2 = sub_1001FFC0(a1) != 67;
      result = 1;
      break;
  }
  return result;
}

//----- (1001FA20) --------------------------------------------------------
char __thiscall sub_1001FA20(void *this)
{
  char v1; // di@1
  void *v2; // esi@1
  char v3; // di@3
  void *v4; // esi@3
  char result; // al@4

  dword_1017BB80 = sub_10015650(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_1017BB88, 0, 0x1540u);
  memset(&unk_1017D0C8, 0, 0x19B0u);
  v1 = 0;
  v2 = &unk_1017BB88;
  do
  {
    sub_1001FEA0(v1, (int)v2);
    v2 = (char *)v2 + 2720;
    ++v1;
  }
  while ( (signed int)v2 < (signed int)&unk_1017D0C8 );
  v3 = 0;
  v4 = &unk_1017D0C8;
  do
  {
    result = sub_1001FF20(v3, (int)v4);
    v4 = (char *)v4 + 2192;
    ++v3;
  }
  while ( (signed int)v4 < (signed int)&dword_1017EA78 );
  return result;
}
// 1017BB80: using guessed type int dword_1017BB80;
// 1017EA78: using guessed type int dword_1017EA78;

//----- (1001FAB0) --------------------------------------------------------
char __cdecl sub_1001FAB0(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_1017BB80 != 1379255385;
  v7 = 0;
  v8 = dword_1017BB80 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10030340(86, 10);
      memset((char *)&unk_1017BB88 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_1001FEA0(a1, (int)&unk_1017BB88 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 4 * (680 * (unsigned __int8)a1 + v5);
      if ( byte_1017BE60[v6] == a2 || byte_1017BE61[v6] == a2 )
        break;
      if ( ++v5 >= 8u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_10030310(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1017BB80: using guessed type int dword_1017BB80;

//----- (1001FB70) --------------------------------------------------------
char __cdecl sub_1001FB70(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_1017BB80 != 1379255385;
  v7 = 0;
  v8 = dword_1017BB80 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10030340(86, 10);
      memset((char *)&unk_1017BB88 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_1001FEA0(a1, (int)&unk_1017BB88 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 8 * (340 * (unsigned __int8)a1 + v5);
      if ( byte_1017BE80[v6] == a2 || byte_1017BE81[v6] == a2 )
        break;
      if ( ++v5 >= 5u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_10030310(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1017BB80: using guessed type int dword_1017BB80;

//----- (1001FC30) --------------------------------------------------------
char __cdecl sub_1001FC30(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_1001FAB0(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (1001FC60) --------------------------------------------------------
char __cdecl sub_1001FC60(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_1001FB70(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (1001FC90) --------------------------------------------------------
int __cdecl sub_1001FC90(int *a1, int a2)
{
  int result; // eax@1

  result = a2 + (*(int (**)(void))dword_1020CF8C)();
  *a1 = result;
  return result;
}
// 1020CF8C: using guessed type int dword_1020CF8C;

//----- (1001FCB0) --------------------------------------------------------
int __cdecl sub_1001FCB0(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1017EA78 = *(_DWORD *)a1;
  dword_1017EA7C = *(_DWORD *)(a1 + 4);
  dword_1017EA80 = *(_DWORD *)(a1 + 8);
  dword_1017EA84 = *(_DWORD *)(a1 + 12);
  dword_1020CF8C = (int)&dword_1017EA78;
  return result;
}
// 1017EA78: using guessed type int dword_1017EA78;
// 1017EA7C: using guessed type int dword_1017EA7C;
// 1017EA80: using guessed type int dword_1017EA80;
// 1017EA84: using guessed type int dword_1017EA84;
// 1020CF8C: using guessed type int dword_1020CF8C;

//----- (1001FCF0) --------------------------------------------------------
signed int __cdecl sub_1001FCF0(char a1, char a2)
{
  _DWORD *v2; // esi@3
  int v3; // eax@5
  char *v5; // [sp-18h] [bp-20h]@3
  void *v6; // [sp-10h] [bp-18h]@3
  int v7; // [sp-8h] [bp-10h]@3

  if ( a2 == 11 )
  {
    v7 = 3;
    v2 = &unk_1007E080;
    v6 = &unk_1007E080;
    v5 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v7 = 7;
    v2 = &unk_1007E098;
    v6 = &unk_1007E098;
    v5 = &a1;
  }
  v3 = sub_10014DE0(v5, 1u, (int)v6, 8, v7, 7);
  if ( v3 < 7 )
    return v2[2 * v3 + 1];
  return 42066;
}

//----- (1001FD50) --------------------------------------------------------
int __cdecl sub_1001FD50(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10014DE0(&a1, 1u, (int)&unk_1007E0E0, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_1007E0E4[2 * v1];
  return result;
}
// 1007E0E4: using guessed type int dword_1007E0E4[];

//----- (1001FD90) --------------------------------------------------------
signed int __cdecl sub_1001FD90(char a1, char a2, char a3)
{
  _DWORD *v3; // esi@3
  int v4; // eax@5
  signed int result; // eax@7
  char *v6; // [sp-18h] [bp-20h]@3
  void *v7; // [sp-10h] [bp-18h]@3

  if ( a2 == 11 )
  {
    v3 = &unk_1007E0F0;
    v7 = &unk_1007E0F0;
    v6 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v3 = &unk_1007E108;
    v7 = &unk_1007E108;
    v6 = &a1;
  }
  v4 = sub_10014DE0(v6, 1u, (int)v7, 12, 2, 2);
  if ( v4 == 2 )
    return 42066;
  if ( a3 )
    result = v3[3 * v4 + 1];
  else
    result = v3[3 * v4 + 2];
  return result;
}

//----- (1001FE00) --------------------------------------------------------
int __cdecl sub_1001FE00(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10014DE0(&a1, 1u, (int)&unk_1007E120, 8, 3, 3);
  if ( v1 == 3 )
    result = 42066;
  else
    result = dword_1007E124[2 * v1];
  return result;
}
// 1007E124: using guessed type int dword_1007E124[];

//----- (1001FE40) --------------------------------------------------------
int __cdecl sub_1001FE40(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10014DE0(&a1, 1u, (int)&unk_1007E138, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_1007E13C[2 * v1];
  return result;
}
// 1007E13C: using guessed type int dword_1007E13C[];

//----- (1001FE80) --------------------------------------------------------
char __cdecl sub_1001FE80(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1001FCF0(a1, 11);
  return sub_10030410(v2, a2, 24);
}

//----- (1001FEA0) --------------------------------------------------------
char __cdecl sub_1001FEA0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1001FD50(a1);
  return sub_10030410(v2, a2, 2720);
}

//----- (1001FED0) --------------------------------------------------------
char __cdecl sub_1001FED0(char a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@1

  v2 = sub_1001FD90(a1, 11, 1);
  sub_10030410(v2, a2, 36);
  v3 = sub_1001FD90(a1, 11, 0);
  return sub_10030410(v3, a2 + 36, 32);
}

//----- (1001FF20) --------------------------------------------------------
char __cdecl sub_1001FF20(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1001FE00(a1);
  return sub_10030410(v2, a2, 2192);
}

//----- (1001FF50) --------------------------------------------------------
char __cdecl sub_1001FF50(int a1)
{
  return sub_10030410(6005, a1, 4);
}

//----- (1001FF70) --------------------------------------------------------
char __cdecl sub_1001FF70(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1001FE40(a1);
  return sub_10030410(v2, a2, 60);
}

//----- (1001FF90) --------------------------------------------------------
char __cdecl sub_1001FF90(int a1)
{
  return sub_10030410(6453, a1, 5);
}

//----- (1001FFB0) --------------------------------------------------------
signed int __fastcall sub_1001FFB0(unsigned __int8 a1)
{
  signed int result; // eax@1

  result = 176;
  if ( a1 < 0xB0u )
    result = a1;
  return result;
}

//----- (1001FFC0) --------------------------------------------------------
char __cdecl sub_1001FFC0(unsigned __int8 a1)
{
  return byte_1007E14C[6 * sub_1001FFB0(a1)];
}

//----- (1001FFE0) --------------------------------------------------------
__int16 __cdecl sub_1001FFE0(unsigned __int8 a1)
{
  return word_1007E148[3 * sub_1001FFB0(a1)];
}
// 1007E148: using guessed type __int16 word_1007E148[];

//----- (10020000) --------------------------------------------------------
char sub_10020000()
{
  unsigned __int16 v0; // dx@1
  int v1; // ecx@2
  unsigned __int16 v2; // ax@9
  int v4[7]; // [sp+8h] [bp-1Ch]@1

  sub_10030490(6465, (int)v4, 28);
  v0 = 0;
LABEL_2:
  v1 = v4[v0];
  if ( v1 == 1 || v1 == 2 || v1 == 4 || v1 == 64 || v1 == 128 || v1 == 16 || v1 == 32 )
  {
    v2 = 0;
    while ( v2 == v0 || v4[v2] != v1 )
    {
      if ( ++v2 >= 7u )
      {
        if ( ++v0 < 7u )
          goto LABEL_2;
        return 1;
      }
    }
  }
  return 0;
}
// 10020000: using guessed type int var_1C[7];

//----- (10020080) --------------------------------------------------------
int __cdecl sub_10020080(char a1)
{
  return sub_10014DE0(&a1, 1u, (int)byte_1007F238, 8, 2, 2);
}

//----- (100200A0) --------------------------------------------------------
char __cdecl sub_100200A0(unsigned __int8 a1)
{
  char result; // al@1

  result = 67;
  if ( a1 < 2u )
    result = byte_1007F238[8 * a1];
  return result;
}

//----- (100200C0) --------------------------------------------------------
BOOL __cdecl sub_100200C0(int a1, void *a2)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-18h]@2
  int v5; // [sp+18h] [bp-4h]@3

  v2 = sub_10016F20(a1);
  return sub_1000ED60(0, 604, a2) && sub_1000E6A0(0, 0x25Cu, (int)&v4) && (v2 & v5) == v2;
}

//----- (10020120) --------------------------------------------------------
int __usercall sub_10020120@<eax>(char a1@<al>)
{
  unsigned __int8 v1; // al@1
  int result; // eax@2

  v1 = sub_10020080(a1);
  if ( v1 >= 2u )
    result = 42066;
  else
    result = dword_1007F23C[2 * v1];
  return result;
}
// 1007F23C: using guessed type int dword_1007F23C[];

//----- (10020150) --------------------------------------------------------
BOOL __cdecl sub_10020150(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10020120(a1);
  return sub_100303F0(v2, a2, 16) == 0;
}

//----- (10020180) --------------------------------------------------------
int __cdecl sub_10020180(int a1, char a2, int a3, int a4, void *a5)
{
  int result; // eax@2

  if ( a2 )
    result = sub_10020150(a1, (int)a5);
  else
    result = sub_100200C0(a1, a5);
  return result;
}

//----- (100201B0) --------------------------------------------------------
char __cdecl sub_100201B0(void *a1)
{
  int v1; // ecx@0
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  return sub_1000ED90(1, 1947, a1, (int)&v3);
}

//----- (100201D0) --------------------------------------------------------
BOOL __cdecl sub_100201D0(int a1)
{
  return sub_100303F0(6792, a1, 284) == 0;
}

//----- (100201F0) --------------------------------------------------------
char __cdecl sub_100201F0(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2

  if ( a2 )
    result = sub_100201D0((int)a5);
  else
    result = sub_100201B0(a5);
  return result;
}

//----- (10020220) --------------------------------------------------------
bool __cdecl sub_10020220(unsigned __int8 a1, char a2, unsigned int a3)
{
  int v3; // eax@1
  bool result; // al@5

  v3 = sub_10014DE0(&a2, 4u, (int)&dword_100800B0, 12, 3, 3);
  if ( a3 < 0xFFFFFFC2 && a3 && v3 < 3 && a1 < 2u )
  {
    result = sub_100303F0((unsigned __int16)word_100800B4[a1 + 6 * v3], a3, (unsigned __int16)word_100800B8[6 * v3]) == 0;
  }
  else
  {
    sub_10014D70("..\\lib\\acl\\iop\\gtx\\iop_gtx_intf.c", 254, 0, 0);
    result = 0;
  }
  return result;
}
// 100800B0: using guessed type int dword_100800B0;
// 100800B4: using guessed type __int16 word_100800B4[];
// 100800B8: using guessed type __int16 word_100800B8[];

//----- (100202B0) --------------------------------------------------------
bool __cdecl sub_100202B0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6)
{
  int v6; // eax@1
  int v7; // eax@7
  unsigned int v8; // edx@7
  int v9; // eax@7
  bool result; // al@9
  unsigned __int8 v11; // [sp+4h] [bp-4h]@1

  v11 = sub_1002EA40(a1);
  v6 = sub_10014DE0(&a3, 1u, (int)&unk_100800D4, 8, 3, 3);
  if ( v6 < 3 )
    v6 = sub_10014DE0(&dword_100800D8[2 * v6], 4u, (int)&dword_100800B0, 12, 3, 3);
  if ( a5 < 0xFFFFFFC2
    && a5
    && v6 < 3
    && v11 < 2u
    && (v7 = 6 * v6, v8 = (unsigned __int16)word_100800B8[v7], v9 = 2 * v7, a6 >= v8)
    && a2 == 1 )
  {
    result = sub_10020220(v11, *(int *)((char *)&dword_100800B0 + v9), a5);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100800B0: using guessed type int dword_100800B0;
// 100800B8: using guessed type __int16 word_100800B8[];

//----- (10020350) --------------------------------------------------------
bool __cdecl sub_10020350(char a1, void *a2)
{
  memset(a2, 0, 0x2890u);
  return sub_100303F0((a1 != 36) + 6534, (int)a2, 10384) == 0;
}

//----- (10020390) --------------------------------------------------------
signed int __usercall sub_10020390@<eax>(char a1@<al>)
{
  return a1 != 36 ? 0x20000 : 0x10000;
}

//----- (100203B0) --------------------------------------------------------
bool __cdecl sub_100203B0(char a1, void *a2)
{
  int v2; // esi@1
  bool result; // al@5
  void *v4; // ecx@6
  int v5; // [sp+Ch] [bp-28h]@4
  char v6; // [sp+10h] [bp-24h]@2
  int v7; // [sp+24h] [bp-10h]@3
  __int16 v8; // [sp+28h] [bp-Ch]@8
  int v9; // [sp+2Ch] [bp-8h]@8

  v2 = sub_10020390(a1);
  if ( (v2 & j_HWM_pvg_hsdb_get_lrus_online()) == v2
    && sub_1000E6A0(1, 0x6ACu, (int)&v6)
    && v7 == v2
    && sub_1000ED90(1, 1708, a2, (int)&v5) )
  {
    result = 1;
  }
  else if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    result = sub_10020350(a1, a2);
  }
  else
  {
    v9 = sub_10014FA0(v4);
    v8 = 1708;
    sub_1000E800(1, 0, &v8, 0, 8, 1);
    sub_1000E9B0(1, 0, v2);
    result = 0;
  }
  return result;
}
// 100080D0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 10008150: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (100204A0) --------------------------------------------------------
bool __cdecl sub_100204A0(char a1, char a2, int a3, int a4, void *a5)
{
  bool result; // al@2

  if ( a2 )
    result = sub_10020350(a1, a5);
  else
    result = sub_100203B0(a1, a5);
  return result;
}

//----- (100204D0) --------------------------------------------------------
BOOL __cdecl sub_100204D0(unsigned __int8 a1)
{
  return a1 <= 1u;
}

//----- (100204E0) --------------------------------------------------------
BOOL __usercall sub_100204E0@<eax>(unsigned __int8 a1@<al>, char a2)
{
  _BYTE *v2; // ecx@1

  return (unsigned __int8)sub_100204D0(a1) && *v2 < 3u && a2 == 24;
}

//----- (10020510) --------------------------------------------------------
bool __cdecl sub_10020510(char a1, char a2, unsigned __int8 a3, int a4)
{
  bool v4; // bl@1
  unsigned __int8 v5; // cl@2
  int v6; // esi@3
  char v8; // al@16
  char v9; // cl@16
  char v10; // dl@16
  int v11; // ecx@18
  int v12; // edx@18
  int v13; // eax@18
  char v14; // [sp+Bh] [bp-29h]@3
  int v15; // [sp+Ch] [bp-28h]@9
  struct tm Tm; // [sp+10h] [bp-24h]@5

  v4 = 0;
  if ( a3 < 3u )
  {
    if ( (unsigned __int8)sub_100204D0(a1) )
    {
      v6 = 10 * v5;
      if ( sub_1001F960((unsigned __int8)byte_100814F0[20 * v5], (bool *)&v14) )
      {
        if ( v14 )
        {
          if ( !sub_1000ED60(1, (unsigned __int16)word_100814E8[v6], &Tm.tm_mon) || sub_10011110((int)&Tm.tm_mon) )
            return 0;
          v4 = 1;
        }
        else
        {
          if ( !(unsigned __int8)sub_1002E9C0(a1, &v15) || v15 != dword_10081508[2 * a3] || a2 == 11 )
            return v4;
          Tm.tm_sec = 0;
          Tm.tm_min = 0;
          Tm.tm_hour = 0;
          LOBYTE(Tm.tm_mday) = 0;
          v4 = sub_1000ED60(1, (unsigned __int16)word_100814EC[v6], &Tm) && !_mkgmtime(&Tm);
          v8 = BYTE1(Tm.tm_hour);
          v9 = BYTE2(Tm.tm_min);
          *((_BYTE *)&Tm.tm_mon + 4 * a3) = Tm.tm_min;
          v10 = BYTE2(Tm.tm_hour);
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 2) = v8;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 1) = v9;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 3) = v10;
          if ( !v4 )
            return v4;
        }
        if ( a2 == 11 )
        {
          v11 = Tm.tm_year;
          v12 = Tm.tm_wday;
          *(_DWORD *)a4 = Tm.tm_mon;
          v13 = Tm.tm_yday;
          *(_DWORD *)(a4 + 4) = v11;
          *(_DWORD *)(a4 + 8) = v12;
          *(_DWORD *)(a4 + 12) = v13;
          return v4;
        }
        *(_DWORD *)a4 = *(&Tm.tm_mon + a3);
      }
    }
  }
  return v4;
}
// 100814E8: using guessed type __int16 word_100814E8[];
// 100814EC: using guessed type __int16 word_100814EC[];
// 10081508: using guessed type int dword_10081508[];

//----- (100206C0) --------------------------------------------------------
bool __cdecl sub_100206C0(unsigned __int8 a1, int a2)
{
  bool v2; // dl@1
  unsigned __int8 v3; // cl@1
  bool result; // al@2

  if ( (unsigned __int8)sub_100204D0(a1) )
    result = sub_100303F0((unsigned __int16)word_100814F2[10 * v3], a2, 32) == 0;
  else
    result = v2;
  return result;
}
// 100814F2: using guessed type __int16 word_100814F2[];

//----- (10020700) --------------------------------------------------------
bool __cdecl sub_10020700(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6)
{
  unsigned __int8 v6; // dl@1
  bool result; // al@4
  char v8; // [sp+13h] [bp-29h]@5
  unsigned int v9; // [sp+14h] [bp-28h]@1
  char v10; // [sp+18h] [bp-24h]@7
  int v11[7]; // [sp+1Ch] [bp-20h]@8

  LOBYTE(v9) = sub_1002E910(a1);
  if ( !(unsigned __int8)sub_100204E0(v9, a3) || a6 != 4 )
    goto LABEL_12;
  if ( !a2 )
    return sub_10020510(v9, a3, *a4, (int)a5);
  if ( sub_1001F960((unsigned __int8)byte_100814F0[20 * v6], (bool *)&v8) && v8 && sub_100206C0(v9, (int)&v10) )
  {
    *a5 = v11[*a4];
    result = 1;
  }
  else
  {
LABEL_12:
    result = 0;
  }
  return result;
}
// 10020700: using guessed type int var_20[7];

//----- (100207F0) --------------------------------------------------------
char sub_100207F0()
{
  char v1; // [sp+4h] [bp-100h]@1

  memset(&v1, 0, 0xFCu);
  if ( sub_1000ED60(1, 1309, &v1) )
    sub_10011250((int)&v1);
  return 0;
}

//----- (10020890) --------------------------------------------------------
BOOL __cdecl sub_10020890(int a1, int a2)
{
  return sub_100303F0(6455, a2, 252) == 0;
}

//----- (100208B0) --------------------------------------------------------
char __cdecl sub_100208B0(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10020890(a1, a5);
  }
  else
  {
    result = sub_100207F0();
  }
  return result;
}

//----- (100208F0) --------------------------------------------------------
char __cdecl sub_100208F0(char a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@3
  char v4; // dl@3

  memset(byte_101E1060, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10014D70("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 215, 0, 0);
  }
  else
  {
    sub_1001FF20(a1, (int)byte_101E1060);
    v3 = 4 * a2 - 64;
    v4 = byte_101E1061[v3];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_101E1060[v3];
    if ( (unsigned __int8)v4 < 0x23u
      || (unsigned __int8)v4 >= 0x64u && (unsigned __int8)v4 <= 0x81u
      || (unsigned __int8)v4 >= 0x96u && (unsigned __int8)v4 <= 0x9Bu )
    {
      return 1;
    }
  }
  return 0;
}

//----- (10020990) --------------------------------------------------------
bool __cdecl sub_10020990(char a1, unsigned __int8 a2, int a3)
{
  char *v3; // eax@3
  bool result; // al@3

  memset(byte_101E1060, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10014D70("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 340, 0, 0);
    result = 0;
  }
  else
  {
    sub_1001FF20(a1, (int)byte_101E1060);
    v3 = (char *)&unk_101E1100 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v3;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v3 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v3 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v3 + 3);
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  return result;
}

//----- (10020A10) --------------------------------------------------------
char __cdecl sub_10020A10(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_101E1060, 0, 0x890u);
  sub_1001FF20(a1, (int)byte_101E1060);
  if ( a2 > 0x10u )
  {
    sub_10014D70("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 512, 0, 0);
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = dword_101E13D0[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_101E13D4[2 * a2];
    result = 1;
  }
  return result;
}
// 101E13D0: using guessed type int dword_101E13D0[];
// 101E13D4: using guessed type int dword_101E13D4[];

//----- (10020A80) --------------------------------------------------------
char __cdecl sub_10020A80(char a1, void *a2)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = sub_1000ED60(0, 227, a2);
    }
    else if ( a1 == 2 )
    {
      result = sub_1000ED60(0, 572, a2);
    }
    else
    {
      sub_10014D70("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 991, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_1000ED60(0, 226, a2);
  }
  return result;
}

//----- (10020B00) --------------------------------------------------------
char __cdecl sub_10020B00(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  int v4; // ecx@3

  memset(byte_101E1060, 0, 0x890u);
  if ( a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10014D70("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 153, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10020A80(a1, byte_101E1060);
    v4 = 4 * a2 - 64;
    *(_BYTE *)(a3 + 1) = byte_101E1061[v4];
    *(_BYTE *)a3 = byte_101E1060[v4];
  }
  return result;
}

//----- (10020B80) --------------------------------------------------------
char __cdecl sub_10020B80(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  char *v4; // ecx@3

  memset(byte_101E1060, 0, 0x890u);
  if ( a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10014D70("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 280, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10020A80(a1, byte_101E1060);
    v4 = (char *)&unk_101E1100 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v4;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v4 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v4 + 3);
  }
  return result;
}

//----- (10020C00) --------------------------------------------------------
char __cdecl sub_10020C00(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_101E1060, 0, 0x890u);
  if ( a2 <= 0x10u )
  {
    result = sub_10020A80(a1, byte_101E1060);
    *(_DWORD *)a3 = dword_101E13D0[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_101E13D4[2 * a2];
  }
  else
  {
    sub_10014D70("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 445, 0, 0);
    result = 0;
  }
  return result;
}
// 101E13D0: using guessed type int dword_101E13D0[];
// 101E13D4: using guessed type int dword_101E13D4[];

//----- (10020C70) --------------------------------------------------------
char __cdecl sub_10020C70(char a1, char a2, char a3, unsigned __int8 *a4, int a5)
{
  char result; // al@6
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1002E2E0(a1);
  if ( v6 == 3 )
    return 0;
  if ( a3 == 1 )
  {
    if ( a2 )
      result = sub_10020A10(v6, *a4, a5);
    else
      result = sub_10020C00(v6, *a4, a5);
  }
  else if ( a3 == 2 )
  {
    if ( a2 )
      result = sub_100208F0(v6, *a4, a5);
    else
      result = sub_10020B00(v6, *a4, a5);
  }
  else
  {
    if ( a3 != 3 )
    {
      sub_10014D70("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 915, 0, 0);
      return 0;
    }
    if ( a2 )
      result = sub_10020990(v6, *a4, a5);
    else
      result = sub_10020B80(v6, *a4, a5);
  }
  return result;
}

//----- (10020D80) --------------------------------------------------------
char __cdecl sub_10020D80(char a1, void *a2)
{
  return sub_1000ED60(6, (unsigned __int16)word_10082E9A[8 * (unsigned __int8)a1], a2);
}
// 10082E9A: using guessed type __int16 word_10082E9A[];

//----- (10020DA0) --------------------------------------------------------
bool __cdecl sub_10020DA0(unsigned __int8 a1, char *a2)
{
  int v2; // eax@1
  char v4; // [sp+8h] [bp-30h]@1

  v2 = sub_100303F0(dword_10082EA0[4 * a1], (int)&v4, 48);
  qmemcpy(a2, &v4, 0x2Cu);
  return v2 == 0;
}
// 10082EA0: using guessed type int dword_10082EA0[];

//----- (10020DE0) --------------------------------------------------------
char __cdecl sub_10020DE0(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1002E630(a1);
  if ( a2 )
    result = sub_10020DA0(v6, (char *)a5);
  else
    result = sub_10020D80(v6, a5);
  return result;
}

//----- (10020E20) --------------------------------------------------------
BOOL sub_10020E20()
{
  char v1; // [sp+0h] [bp-78h]@1

  return sub_1001F8A0(69, &v1) && !strncmp(&v1, "006-B0756-", 0xAu);
}

//----- (10020E80) --------------------------------------------------------
char __cdecl sub_10020E80(int a1, char *a2)
{
  char result; // al@5
  char v3; // [sp+13h] [bp-7Dh]@1
  char v4; // [sp+14h] [bp-7Ch]@1
  char v5; // [sp+15h] [bp-7Bh]@2
  int v6; // [sp+30h] [bp-60h]@2
  int v7; // [sp+34h] [bp-5Ch]@2
  int v8; // [sp+38h] [bp-58h]@2
  int v9; // [sp+3Ch] [bp-54h]@2
  int v10; // [sp+40h] [bp-50h]@2
  __int16 v11; // [sp+44h] [bp-4Ch]@2
  char v12; // [sp+46h] [bp-4Ah]@2
  char v13; // [sp+47h] [bp-49h]@2
  float v14; // [sp+48h] [bp-48h]@2
  char v15; // [sp+4Ch] [bp-44h]@2
  char v16; // [sp+4Dh] [bp-43h]@2
  char v17; // [sp+4Eh] [bp-42h]@2
  char v18; // [sp+50h] [bp-40h]@1

  memset(&v18, 0, 0x3Cu);
  v3 = sub_1000ED60(1, 292, &v18);
  qmemcpy(&v4, &v18, 0x3Cu);
  if ( !(unsigned __int8)sub_10020E20() )
  {
    v6 = -1;
    v14 = 77.166664;
    v7 = -1;
    v8 = -1;
    v9 = -1;
    v5 = 1;
    v12 = 0;
    v13 = 1;
    v4 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v10 = 0;
    v11 = 0;
  }
  if ( !v3 || sub_10010DB0((int)&v4) )
  {
    result = 0;
  }
  else
  {
    result = 1;
    qmemcpy(a2, &v18, 0x3Cu);
  }
  return result;
}

//----- (10020F70) --------------------------------------------------------
BOOL __cdecl sub_10020F70(int a1, int a2)
{
  return sub_100303F0(6200, a2, 60) == 0;
}

//----- (10020F90) --------------------------------------------------------
char __cdecl sub_10020F90(int a1, char a2, int a3, int a4, char *a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10020F70(a1, (int)a5);
  }
  else
  {
    result = sub_10020E80(a1, a5);
  }
  return result;
}

//----- (10020FD0) --------------------------------------------------------
char __cdecl sub_10020FD0(int a1, int a2)
{
  int v2; // ecx@3
  int v3; // edx@3
  int v4; // ecx@3
  char result; // al@3
  int v6; // [sp+4h] [bp-1Ch]@1
  int v7; // [sp+8h] [bp-18h]@1
  int v8; // [sp+Ch] [bp-14h]@1
  int v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+14h] [bp-Ch]@1
  __int16 v11; // [sp+18h] [bp-8h]@1
  char v12; // [sp+1Ah] [bp-6h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if ( !sub_1000ED60(2, 284, &v6) || sub_10010F80((int)&v6) )
  {
    result = 0;
  }
  else
  {
    v2 = v8;
    *(_DWORD *)a2 = v7;
    v3 = v9;
    *(_DWORD *)(a2 + 4) = v2;
    v4 = v10;
    *(_DWORD *)(a2 + 8) = v3;
    LOWORD(v3) = v11;
    *(_DWORD *)(a2 + 12) = v4;
    LOBYTE(v4) = v12;
    *(_WORD *)(a2 + 16) = v3;
    *(_BYTE *)(a2 + 18) = v4;
    result = 1;
  }
  return result;
}

//----- (10021080) --------------------------------------------------------
BOOL __cdecl sub_10021080(int a1, int a2)
{
  return sub_100303F0(6169, a2, 40) == 0;
}

//----- (100210A0) --------------------------------------------------------
char __cdecl sub_100210A0(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10021080(a1, a5);
  }
  else
  {
    result = sub_10020FD0(a1, a5);
  }
  return result;
}

//----- (100210E0) --------------------------------------------------------
char __cdecl sub_100210E0(void *a1)
{
  *(_DWORD *)a1 = 0;
  return sub_1000ED60(2, 363, a1);
}

//----- (10021100) --------------------------------------------------------
char __cdecl sub_10021100(void *a1)
{
  int v1; // edx@2
  int v2; // eax@2
  int v3; // ecx@2
  int v4; // eax@2
  int v5; // ecx@2
  void *v6; // esi@2
  signed int v7; // edi@2
  char *v8; // eax@4
  signed int v9; // edx@4
  char result; // al@6
  char v11; // [sp+8h] [bp-208h]@1
  int v12; // [sp+47h] [bp-1C9h]@2
  int v13; // [sp+4Bh] [bp-1C5h]@2
  int v14; // [sp+4Fh] [bp-1C1h]@2
  int v15; // [sp+53h] [bp-1BDh]@2
  int v16; // [sp+58h] [bp-1B8h]@2
  int v17; // [sp+5Ch] [bp-1B4h]@2
  __int16 v18; // [sp+60h] [bp-1B0h]@2
  char v19; // [sp+62h] [bp-1AEh]@2
  char v20; // [sp+B6h] [bp-15Ah]@2
  char v21; // [sp+F6h] [bp-11Ah]@2

  *(_DWORD *)a1 = 0;
  if ( sub_100303F0(6444, (int)&v11, 514) )
  {
    result = 0;
  }
  else
  {
    v1 = v13;
    v2 = v14;
    *((_DWORD *)a1 + 3330) = v12;
    v3 = v15;
    *((_DWORD *)a1 + 3331) = v1;
    LOWORD(v1) = v18;
    *((_DWORD *)a1 + 3332) = v2;
    v4 = v16;
    *((_DWORD *)a1 + 3333) = v3;
    qmemcpy((char *)a1 + 13340, &v19, 0x54u);
    v5 = v17;
    *((_WORD *)a1 + 6668) = v1;
    LOBYTE(v1) = v21;
    *((_DWORD *)a1 + 3009) = v5;
    qmemcpy((char *)a1 + 13424, &v20, 0x40u);
    *((_DWORD *)a1 + 3008) = v4;
    *((_BYTE *)a1 + 13488) = v1 & 2;
    v6 = a1;
    v7 = 32;
    do
    {
      memset(v6, 0, 0x38u);
      *((_DWORD *)v6 + 9) = 2048;
      v6 = (char *)v6 + 56;
      --v7;
    }
    while ( v7 );
    v8 = (char *)a1 + 1799;
    v9 = 512;
    do
    {
      *(_DWORD *)(v8 - 7) = 0;
      *(_DWORD *)(v8 - 3) = 0;
      *(_DWORD *)(v8 + 1) = 0;
      *(_DWORD *)(v8 + 5) = 0;
      *(_DWORD *)(v8 + 9) = 0;
      *v8 = -1;
      v8 += 20;
      --v9;
    }
    while ( v9 );
    result = 1;
  }
  return result;
}

//----- (10021250) --------------------------------------------------------
bool __thiscall sub_10021250(void *this)
{
  return (sub_10015630(this) & 0x8000) == 0x8000;
}

//----- (10021270) --------------------------------------------------------
char __cdecl sub_10021270(unsigned __int8 a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-208h]@1
  char v3[453]; // [sp+3Fh] [bp-1C9h]@2

  if ( sub_100303F0(6444, (int)&v2, 514) == 0 )
    result = v3[a1];
  else
    result = 0;
  return result;
}
// 10021270: using guessed type char var_1C9[453];

//----- (100212E0) --------------------------------------------------------
char __cdecl sub_100212E0(int a1, char a2, char a3, int a4, void *a5, size_t a6)
{
  char result; // al@3
  char v7; // al@6
  char v8; // bl@8
  char v9; // al@10
  char v10; // bl@12
  char v11; // al@14
  char v12; // bl@16
  char v13; // al@18
  char v14; // bl@20

  switch ( a3 )
  {
    case 0x18:
      if ( a2 )
        result = sub_10021100(a5);
      else
        result = sub_100210E0(a5);
      break;
    case 0x19:
      if ( a2 )
        v7 = sub_10021100(&unk_101E18F0);
      else
        v7 = sub_100210E0(&unk_101E18F0);
      v8 = v7;
      memcpy(a5, (char *)&unk_101E18F0 + 56 * *(_BYTE *)a4, a6);
      result = v8;
      break;
    case 0x1A:
      if ( a2 )
        v9 = sub_10021100(&unk_101E18F0);
      else
        v9 = sub_100210E0(&unk_101E18F0);
      v10 = v9;
      memcpy(a5, (char *)&unk_101E47F8 + 40 * *(_BYTE *)a4, a6);
      result = v10;
      break;
    case 0x1B:
      if ( a2 )
        v11 = sub_10021100(&unk_101E18F0);
      else
        v11 = sub_100210E0(&unk_101E18F0);
      v12 = v11;
      memcpy(a5, (char *)&unk_101E4CF8 + *(_BYTE *)a4, a6);
      result = v12;
      break;
    case 0x2B:
      if ( a2 )
        v13 = sub_10021100(&unk_101E18F0);
      else
        v13 = sub_100210E0(&unk_101E18F0);
      v14 = v13;
      memcpy(a5, &unk_101E4DA0, a6);
      result = v14;
      break;
    default:
      sub_10014D70("..\\lib\\acl\\iop\\gdl59\\iop_gdl59_cnfg_intf.c", 709, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10021480) --------------------------------------------------------
char __cdecl sub_10021480(char a1)
{
  char result; // al@3

  if ( a1 == 15 )
  {
    result = 0;
  }
  else if ( a1 == 16 )
  {
    result = 1;
  }
  else
  {
    sub_10014D70("..\\lib\\acl\\iop\\iop_adc_intf.c", 178, 0, 0);
    result = 0;
  }
  return result;
}

//----- (100214C0) --------------------------------------------------------
__int16 __usercall sub_100214C0@<ax>(unsigned __int8 a1@<al>)
{
  return word_10085A50[a1];
}
// 10085A50: using guessed type __int16 word_10085A50[];

//----- (100214D0) --------------------------------------------------------
char __cdecl sub_100214D0(unsigned __int8 a1, char *a2)
{
  int v2; // eax@2
  char result; // al@5
  int v4; // [sp+4h] [bp-150h]@2
  char v5; // [sp+8h] [bp-14Ch]@1
  char v6; // [sp+9h] [bp-14Bh]@3
  char v7; // [sp+Ch] [bp-148h]@5

  memset(&v5, 0, 0x148u);
  if ( a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    LOWORD(v2) = sub_100214C0(a1);
    if ( sub_1000ED90(0, v2, &v5, (int)&v4) && v6 == 3 && (unsigned int)(unsigned __int16)v4 - 4 >= 0xA0 )
    {
      qmemcpy(a2, &v7, 0xA0u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (100215A0) --------------------------------------------------------
char __cdecl sub_100215A0(char a1, char a2, char a3, int a4, char *a5, unsigned int a6)
{
  char result; // al@3
  unsigned __int8 v7; // [sp+4h] [bp-4h]@1

  v7 = sub_10021480(a1);
  if ( a3 != 11 )
  {
    sub_10014D70("..\\lib\\acl\\iop\\iop_adc_intf.c", 564, 0, 0);
    return 0;
  }
  if ( a6 >= 0xA0 )
  {
    if ( a2 )
      return 0;
    result = sub_100214D0(v7, a5);
  }
  else
  {
    sub_10014D70("..\\lib\\acl\\iop\\iop_adc_intf.c", 551, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10021620) --------------------------------------------------------
char __cdecl sub_10021620(char a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@3
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1002F0A0(a1);
  switch ( a3 )
  {
    case 5:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1002EEA0(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 4:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1002EF20(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 0xA:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1002EFA0(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 3:
      if ( a2 != 1 )
        goto LABEL_10;
      result = sub_1002F020(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      break;
    default:
LABEL_10:
      result = 0;
      break;
  }
  return result;
}

//----- (10021730) --------------------------------------------------------
int __cdecl sub_10021730(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10014DE0(&a1, 1u, (int)&unk_10086288, 8, 4, 4);
  if ( v1 == 4 )
  {
    sub_10014D70("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_intf.c", 437, 0, 0);
    result = 42066;
  }
  else
  {
    result = dword_1008628C[2 * v1];
  }
  return result;
}
// 1008628C: using guessed type int dword_1008628C[];

//----- (10021780) --------------------------------------------------------
char __cdecl sub_10021780(char a1, int a2)
{
  char v2; // cl@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // eax@1
  int v10; // ecx@1
  bool v11; // zf@1
  int v12; // eax@3
  int v13; // ecx@3
  char v14; // dl@3
  __int16 v15; // ax@5
  char v16; // dl@5
  int v18; // [sp+4h] [bp-58h]@1
  char v19; // [sp+8h] [bp-54h]@1
  __int64 v20; // [sp+Ch] [bp-50h]@1
  int v21; // [sp+14h] [bp-48h]@1
  int v22; // [sp+18h] [bp-44h]@1
  char v23; // [sp+1Ch] [bp-40h]@1
  __int16 v24; // [sp+1Eh] [bp-3Eh]@1
  int v25; // [sp+20h] [bp-3Ch]@4
  int v26; // [sp+24h] [bp-38h]@4
  char v27; // [sp+28h] [bp-34h]@4
  char v28; // [sp+2Ah] [bp-32h]@1
  char v29; // [sp+2Bh] [bp-31h]@1
  int v30; // [sp+2Ch] [bp-30h]@1
  int v31; // [sp+30h] [bp-2Ch]@1
  int v32; // [sp+34h] [bp-28h]@1
  int v33; // [sp+38h] [bp-24h]@1
  int v34; // [sp+3Ch] [bp-20h]@1
  int v35; // [sp+40h] [bp-1Ch]@1
  int v36; // [sp+44h] [bp-18h]@1
  int v37; // [sp+48h] [bp-14h]@1
  int v38; // [sp+4Ch] [bp-10h]@1
  int v39; // [sp+50h] [bp-Ch]@1
  int v40; // [sp+54h] [bp-8h]@1

  memset(&v23, 0, 0x3Cu);
  v20 = 0i64;
  v21 = 0;
  v22 = 0;
  v18 = 0;
  v19 = 0;
  sub_1001FF70(a1, (int)&v23);
  v2 = v28;
  v3 = v29;
  *(_WORD *)a2 = v24;
  *(_DWORD *)(a2 + 28) = v33;
  v4 = v36;
  *(_BYTE *)(a2 + 12) = v2;
  *(_DWORD *)(a2 + 32) = v34;
  v5 = v37;
  *(_BYTE *)(a2 + 13) = v3;
  *(_DWORD *)(a2 + 36) = v35;
  v6 = v38;
  *(_DWORD *)(a2 + 40) = v4;
  v7 = v30;
  *(_DWORD *)(a2 + 44) = v5;
  v8 = v31;
  *(_DWORD *)(a2 + 16) = v7;
  v9 = v39;
  *(_DWORD *)(a2 + 20) = v8;
  v10 = v40;
  *(_DWORD *)(a2 + 48) = v6;
  v11 = BYTE3(v30) == 1;
  *(_DWORD *)(a2 + 24) = v32;
  *(_DWORD *)(a2 + 52) = v9;
  *(_DWORD *)(a2 + 56) = v10;
  if ( !v11 || sub_100303F0(2105, (int)&v20, 16) )
  {
    v12 = v25;
    v13 = v26;
    v14 = v27;
  }
  else
  {
    v13 = *(_DWORD *)((char *)&v20 + 6);
    v12 = *(_DWORD *)((char *)&v20 + 2);
    v14 = BYTE2(v21);
  }
  *(_DWORD *)(a2 + 2) = v12;
  *(_DWORD *)(a2 + 6) = v13;
  *(_BYTE *)(a2 + 10) = v14;
  sub_1001FF90((int)&v18);
  LOBYTE(v15) = v19;
  v16 = v18;
  v11 = (v19 & 1) == 0;
  *(_BYTE *)(a2 + 63) = BYTE3(v18);
  *(_BYTE *)(a2 + 60) = v16;
  *(_BYTE *)(a2 + 64) = 0;
  if ( !v11 )
    *(_BYTE *)(a2 + 64) = 1;
  *(_BYTE *)(a2 + 65) = 0;
  if ( v15 & 4 )
    *(_BYTE *)(a2 + 65) = 1;
  *(_BYTE *)(a2 + 66) = 0;
  if ( v15 & 2 )
  {
    v15 = *(_WORD *)((char *)&v18 + 1);
    *(_BYTE *)(a2 + 66) = 1;
    *(_WORD *)(a2 + 61) = v15;
  }
  else
  {
    *(_WORD *)(a2 + 61) = *(_WORD *)((char *)&v18 + 1);
  }
  return v15;
}

//----- (100218F0) --------------------------------------------------------
int __usercall sub_100218F0@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@1
  int v5[10]; // [sp+1Ch] [bp-2Ch]@1

  sub_10021780(a1, (int)&v4);
  result = v5[a3];
  *a2 = result;
  return result;
}
// 100218F0: using guessed type int var_2C[10];

//----- (10021930) --------------------------------------------------------
int __usercall sub_10021930@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@3
  int v5[4]; // [sp+34h] [bp-14h]@3

  result = a3;
  if ( (unsigned __int8)a3 < 2u && a1 < 2u )
  {
    sub_10021780(a3, (int)&v4);
    result = v5[a1];
    *a2 = result;
  }
  return result;
}
// 10021930: using guessed type int var_14[4];

//----- (10021970) --------------------------------------------------------
signed int sub_10021970()
{
  return sub_100312F0((int)&off_10087158);
}
// 10087158: using guessed type char *off_10087158;

//----- (10021980) --------------------------------------------------------
char __cdecl sub_10021980(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  int v3; // esi@2
  char result; // al@2

  if ( (unsigned __int8)sub_10021970() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_1020CF80 + 4 * v3 + 29);
    *(_BYTE *)a3 = *(_BYTE *)(dword_1020CF80 + 4 * v3 + 28);
    result = *(_BYTE *)(a2 + 2 * (3 * a1 + 72) + dword_1020CF80);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1020CF80: using guessed type int dword_1020CF80;

//----- (100219E0) --------------------------------------------------------
char __cdecl sub_100219E0(char a1, void *a2)
{
  int v2; // edx@4
  char result; // al@20

  if ( (unsigned __int8)sub_10021970() )
  {
    if ( (sub_1002EA10(a1)
       || *(_BYTE *)(dword_1020CF80 + 2 * (3 * (unsigned __int8)a1 + 72))
       && (v2 = dword_1020CF80 + 6 * (unsigned __int8)a1, *(_BYTE *)(dword_1020CF80 + 6 * (unsigned __int8)a1 + 145))
       && *(_BYTE *)(v2 + 146)
       && *(_BYTE *)(v2 + 147)
       && *(_BYTE *)(v2 + 148)
       && *(_BYTE *)(v2 + 149)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1020CF80 + 142)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1020CF80 + 170)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1020CF80 + 168)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1020CF80 + 166)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1020CF80 + 172)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1020CF80 + 174)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1020CF80 + 176))
      && *(_BYTE *)(dword_1020CF80 + 2 * (unsigned __int8)a1 + 158)
      && *(_BYTE *)(dword_1020CF80 + 2 * (unsigned __int8)a1 + 159)
      && *(_BYTE *)((unsigned __int8)a1 + dword_1020CF80 + 156)
      && *(_BYTE *)((unsigned __int8)a1 + dword_1020CF80 + 162) )
    {
      qmemcpy(a2, (const void *)(dword_1020CF80 + 68 * (unsigned __int8)a1), 0x44u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1020CF80: using guessed type int dword_1020CF80;

//----- (10021B00) --------------------------------------------------------
char __cdecl sub_10021B00(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@2
  char result; // al@2

  if ( (unsigned __int8)sub_10021970() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 2) = *(_BYTE *)(dword_1020CF80 + 4 * v3 + 54);
    *(_BYTE *)a3 = *(_BYTE *)(dword_1020CF80 + 4 * v3 + 52);
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_1020CF80 + 4 * v3 + 53);
    *(_BYTE *)(a3 + 3) = *(_BYTE *)(dword_1020CF80 + 4 * v3 + 55);
    result = *(_BYTE *)(a2 + 2 * a1 + 158 + dword_1020CF80);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1020CF80: using guessed type int dword_1020CF80;

//----- (10021B80) --------------------------------------------------------
char __cdecl sub_10021B80(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6)
{
  char v6; // cl@2
  char result; // al@7
  unsigned __int16 v8; // ax@13

  if ( (_BYTE)a1 == 10 )
  {
    v6 = 0;
  }
  else
  {
    if ( (_BYTE)a1 != 11 )
    {
      sub_10014D70("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 703, 0, 0);
      return 0;
    }
    v6 = 1;
  }
  LOBYTE(a1) = v6;
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        if ( a2 )
        {
          sub_10021930(*a4, a5, a1);
          result = 1;
        }
        else
        {
          result = sub_10021B00(v6, *a4, (int)a5);
        }
      }
      else
      {
        sub_10014D70("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 718, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        v8 = *a4;
        if ( a2 )
        {
          sub_100218F0(v6, a5, v8);
          result = 1;
        }
        else
        {
          result = sub_10021980(v6, v8, (int)a5);
        }
      }
      else
      {
        sub_10014D70("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 750, 0, 0);
        result = 0;
      }
      break;
    case 0xB:
    case 0x12:
    case 0x1C:
      if ( a6 >= 0x44 )
      {
        if ( a2 )
        {
          sub_10021780(v6, (int)a5);
          result = 1;
        }
        else
        {
          result = sub_100219E0(v6, a5);
        }
      }
      else
      {
        sub_10014D70("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 784, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10014D70("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 809, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10021D30) --------------------------------------------------------
char __cdecl sub_10021D30(unsigned __int16 a1, char *a2, char a3)
{
  char result; // al@4
  char v4; // al@5
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
    {
      sub_10014D70("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 188, 0, 0);
      return 0;
    }
    v4 = sub_1000ED90(1, 555, &v5, (int)&a1);
  }
  else
  {
    v4 = sub_1000ED90(1, 550, &v5, (int)&a1);
  }
  if ( !v4 )
    return 0;
  if ( sub_100114F0((int)&v5) )
    return 0;
  result = 1;
  if ( !BYTE1(v14) || (unsigned int)a1 - 4 < 0x20 )
    return 0;
  if ( a3 )
  {
    if ( BYTE1(v5) == 26 )
    {
      qmemcpy(a2, (char *)&v6 + 1, 0x20u);
      qmemcpy(&unk_101E4DC8, (char *)&v6 + 1, 0x20u);
      byte_101E4DC0 = 1;
      byte_101E4DC1 = 0;
      return result;
    }
  }
  else if ( BYTE1(v5) == 12 )
  {
    qmemcpy(a2, (char *)&v6 + 1, 0x20u);
    qmemcpy(&unk_101E4DE8, (char *)&v6 + 1, 0x20u);
    byte_101E4DC1 = 1;
    byte_101E4DC2 = 1;
    return result;
  }
  return 0;
}
// 101E4DC0: using guessed type char byte_101E4DC0;
// 101E4DC1: using guessed type char byte_101E4DC1;
// 101E4DC2: using guessed type char byte_101E4DC2;

//----- (10021E60) --------------------------------------------------------
char __cdecl sub_10021E60(char a1, int a2)
{
  char result; // al@3
  char v3; // [sp+4h] [bp-44h]@1
  char v4; // [sp+8h] [bp-40h]@3
  char v5; // [sp+28h] [bp-20h]@3

  memset(&v3, 0, 0x44u);
  if ( (unsigned __int8)a1 < 2u && a2 )
  {
    result = sub_1001FED0(a1, (int)&v3);
    qmemcpy((void *)a2, &v4, 0x20u);
    qmemcpy((void *)(a2 + 32), &v5, 0x20u);
  }
  else
  {
    result = sub_10014D70("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 570, 0, 0);
  }
  return result;
}

//----- (10021EE0) --------------------------------------------------------
bool __cdecl sub_10021EE0(void *a1)
{
  bool v1; // zf@2
  bool result; // al@4

  if ( a1 )
  {
    v1 = byte_101E4DC0 == 0;
    qmemcpy(a1, &unk_101E4DC8, 0x40u);
    result = !v1 && byte_101E4DC2;
  }
  else
  {
    sub_10014D70("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 617, 0, 0);
    result = 0;
  }
  return result;
}
// 101E4DC0: using guessed type char byte_101E4DC0;
// 101E4DC2: using guessed type char byte_101E4DC2;

//----- (10021F30) --------------------------------------------------------
char __cdecl sub_10021F30(char a1, int a2)
{
  char result; // al@4
  int v3; // edx@5
  const void *v4; // esi@8
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( j_HWM_pvg_read_reg(1) != 1 )
    sub_10014D70("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 857, 1, 0);
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 != 1 )
      return result;
    result = sub_1001FC30(15);
    v3 = 555;
  }
  else
  {
    result = sub_1001FC30(8);
    v3 = 550;
  }
  if ( result )
  {
    v4 = (const void *)a2;
    LOBYTE(v5) = 12;
    BYTE1(v14) = 1;
    LOBYTE(v6) = 32;
    HIWORD(v5) = 34;
    if ( byte_101E4DC1 )
    {
      BYTE1(v5) = 26;
    }
    else
    {
      BYTE1(v5) = 12;
      v4 = (const void *)(a2 + 32);
    }
    qmemcpy((char *)&v6 + 1, v4, 0x20u);
    result = sub_1000E800(1, v3, &v5, 1, 38, 1);
  }
  return result;
}
// 10008150: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 101E4DC1: using guessed type char byte_101E4DC1;

//----- (10022010) --------------------------------------------------------
__int16 __usercall sub_10022010@<ax>(unsigned __int8 a1@<al>)
{
  return word_10087278[a1];
}
// 10087278: using guessed type __int16 word_10087278[];

//----- (10022020) --------------------------------------------------------
char __cdecl sub_10022020(unsigned __int8 a1, int *a2, const void *a3)
{
  int v3; // ebx@1
  unsigned int v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int v7; // [sp+14h] [bp-20h]@1
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+28h] [bp-Ch]@1
  int v13; // [sp+2Ch] [bp-8h]@1
  int v14; // [sp+30h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v3 = (unsigned __int16)sub_10022010(a1);
  v5 = *a2;
  qmemcpy(&v6, a3, 0x24u);
  sub_1000E800(1, v3, &v5, 1, (v5 >> 16) + 4, 1);
  return sub_1000E9B0(1, v3, 0xFFFFFFF);
}

//----- (100220B0) --------------------------------------------------------
char __cdecl sub_100220B0(unsigned __int8 a1, char a2)
{
  int v3; // [sp+4h] [bp-28h]@1
  int v4; // [sp+8h] [bp-24h]@1
  int v5; // [sp+Ch] [bp-20h]@1
  int v6; // [sp+10h] [bp-1Ch]@1
  int v7; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@1
  int v9; // [sp+1Ch] [bp-10h]@1
  int v10; // [sp+20h] [bp-Ch]@1
  int v11; // [sp+24h] [bp-8h]@1
  int v12; // [sp+28h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v3 = 0;
  if ( a1 >= 2u )
  {
    sub_10014D70("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 736, 0, 0);
  }
  else
  {
    HIWORD(v3) = 0;
    LOBYTE(v3) = 12;
    if ( a2 == 11 )
    {
      BYTE1(v3) = byte_101E4DC1 != 0 ? 25 : 11;
      sub_10022020(a1, &v3, &v4);
      return 1;
    }
    if ( a2 == 17 )
    {
      LOWORD(v3) = 10042;
      sub_10022020(a1, &v3, &v4);
      return 1;
    }
  }
  return 0;
}
// 101E4DC1: using guessed type char byte_101E4DC1;

//----- (10022170) --------------------------------------------------------
bool __cdecl sub_10022170(__int16 a1, char a2, int a3, int a4, void *a5)
{
  char v6; // [sp+4h] [bp-40h]@8
  char v7; // [sp+24h] [bp-20h]@11

  if ( (unsigned __int8)a1 == 8 )
  {
    LOBYTE(a1) = 0;
  }
  else
  {
    if ( (unsigned __int8)a1 != 9 )
      return 0;
    LOBYTE(a1) = 1;
  }
  if ( a2 == 1 )
  {
    sub_10021E60(a1, (int)a5);
    return 1;
  }
  if ( byte_101E4DC1 )
  {
    if ( sub_10021D30(a1, &v6, 1) )
    {
LABEL_14:
      byte_101E4DC3 = 0;
      goto LABEL_15;
    }
    if ( (unsigned __int8)++byte_101E4DC3 >= 5u )
    {
      byte_101E4DC0 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( sub_10021D30(a1, &v7, 0) )
      goto LABEL_14;
    if ( (unsigned __int8)++byte_101E4DC3 >= 5u )
    {
      byte_101E4DC2 = 0;
      goto LABEL_14;
    }
  }
LABEL_15:
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    sub_10021E60(a1, (int)&v6);
    sub_10021F30(a1, (int)&v6);
  }
  sub_100220B0(a1, 11);
  return sub_10021EE0(a5);
}
// 10008150: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 101E4DC0: using guessed type char byte_101E4DC0;
// 101E4DC1: using guessed type char byte_101E4DC1;
// 101E4DC2: using guessed type char byte_101E4DC2;
// 101E4DC3: using guessed type char byte_101E4DC3;

//----- (10022270) --------------------------------------------------------
void *sub_10022270()
{
  void *v0; // ebp@1
  void *v1; // esi@2
  signed int v2; // edi@2
  void *result; // eax@3
  signed int v4; // [sp+0h] [bp-14h]@1
  char v5; // [sp+4h] [bp-10h]@1
  float v6; // [sp+8h] [bp-Ch]@1
  int v7; // [sp+Ch] [bp-8h]@1
  int v8; // [sp+10h] [bp-4h]@1

  v6 = 9.9999996e24;
  byte_101E4E08 = 0;
  byte_101E4E09 = 0;
  byte_101E4E0A = 0;
  v5 = 0;
  v7 = 0x7FFFFFFF;
  v8 = 0x7FFFFFFF;
  v0 = &unk_101E4E2C;
  v4 = 2;
  do
  {
    *((_WORD *)v0 - 2) = 0;
    v1 = v0;
    v2 = 10;
    do
    {
      result = memcpy_0(v1, &v5, 0x10u);
      v1 = (char *)v1 + 16;
      --v2;
    }
    while ( v2 );
    v0 = (char *)v0 + 164;
    --v4;
  }
  while ( v4 );
  byte_101E4E0B = 0;
  return result;
}
// 101E4E08: using guessed type char byte_101E4E08;
// 101E4E09: using guessed type char byte_101E4E09;
// 101E4E0A: using guessed type char byte_101E4E0A;
// 101E4E0B: using guessed type char byte_101E4E0B;

//----- (10022310) --------------------------------------------------------
char __cdecl sub_10022310(const void *a1)
{
  __int16 v2; // [sp+8h] [bp-530h]@1
  char v3; // [sp+Ch] [bp-52Ch]@1

  memset(&v2, 0, 0x528u);
  v2 = -32723;
  qmemcpy(&v3, a1, 0x1C8u);
  return sub_1001A240((int)&v2);
}

//----- (10022380) --------------------------------------------------------
char *__cdecl sub_10022380(char **a1)
{
  char *v1; // edx@1
  int v2; // edi@1
  char *result; // eax@1
  char *v4; // eax@3
  char v5; // cl@4
  int v6; // eax@5
  char v7; // cl@7

  v1 = *a1;
  v2 = 0;
  result = byte_1004764C;
  if ( *a1 && *v1 )
  {
    v4 = *a1;
    do
      v5 = *v4++;
    while ( v5 );
    v6 = v4 - (v1 + 1) - 1;
    do
    {
      if ( v6 < 0 )
        break;
      v7 = v1[v6];
      if ( v7 == 47 || v7 == 92 )
        v2 = v6 + 1;
      --v6;
    }
    while ( !v2 );
    result = &v1[v2];
  }
  return result;
}

//----- (100223D0) --------------------------------------------------------
int sub_100223D0()
{
  int v0; // esi@1
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@2

  v0 = 0;
  v1 = sub_1002FFA0();
  result = 0;
  while ( 1 )
  {
    v3 = dword_101E4F84[result];
    if ( v3 == v1 )
      break;
    if ( !v0 && v3 == -1 )
      v0 = result;
    if ( (unsigned int)++result >= 5 )
    {
      dword_101E4F84[v0] = v1;
      return v0;
    }
  }
  return result;
}
// 101E4F84: using guessed type int dword_101E4F84[];

//----- (10022410) --------------------------------------------------------
int __cdecl sub_10022410(_BYTE *a1, int a2)
{
  int result; // eax@3
  int v3; // esi@3
  _BYTE *v4; // ecx@4
  char v5; // dl@5

  if ( a1 )
  {
    if ( a2 )
    {
      result = 0;
      v3 = 0;
      if ( *a1 )
      {
        v4 = a1;
        do
        {
          v5 = v4[a2 - (_DWORD)a1];
          if ( !v5 )
            break;
          if ( *v4 != v5 )
          {
            result = a1[v3] - *(_BYTE *)(v3 + a2);
            if ( a1[v3] != *(_BYTE *)(v3 + a2) )
              return result;
            break;
          }
          ++v4;
          ++v3;
        }
        while ( *v4 );
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(v3 + a2) )
      {
        result = -1;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10022480) --------------------------------------------------------
signed int __cdecl sub_10022480(_BYTE *a1, int a2)
{
  _BYTE *v2; // esi@1
  int v3; // ebp@1
  int v4; // ebx@4
  int v5; // edi@6
  int v6; // eax@6
  signed int result; // eax@11
  int v8; // [sp+8h] [bp-4h]@3

  v2 = a1;
  v3 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v8 = 0;
      if ( *a1 )
      {
        v4 = a2 - (_DWORD)a1;
        while ( v2[v4] )
        {
          v5 = tolower(*v2);
          v6 = tolower(v2[v4]);
          if ( v5 != v6 )
          {
            v8 = v5 - v6;
            if ( v5 != v6 )
              goto LABEL_16;
            break;
          }
          ++v2;
          ++v3;
          if ( !*v2 )
            break;
        }
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(a2 + v3) )
      {
        result = -1;
      }
      else
      {
LABEL_16:
        result = v8;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10022520) --------------------------------------------------------
char *__usercall sub_10022520@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>)
{
  if ( a2 )
  {
    if ( (_BYTE)result && *(_BYTE *)a3 )
    {
      if ( *a2 )
      {
        strncat((char *)a3, " ", 0x100u);
        result = strncat((char *)a3, a2, 0x100u);
        *(_BYTE *)(a3 + 255) = 0;
        return result;
      }
    }
    else
    {
      result = strncpy((char *)a3, a2, 0x100u);
    }
    *(_BYTE *)(a3 + 255) = 0;
  }
  else if ( !(_BYTE)result )
  {
    *(_BYTE *)a3 = 0;
  }
  return result;
}

//----- (10022580) --------------------------------------------------------
const char *__usercall sub_10022580@<eax>(int a1@<eax>)
{
  const char *result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
      result = "Group";
    else
      result = "Command";
  }
  else
  {
    result = "Case";
  }
  return result;
}

//----- (100225A0) --------------------------------------------------------
int __usercall sub_100225A0@<eax>(unsigned int a1@<ebx>)
{
  int (**v1)(void); // esi@1
  unsigned int v2; // edi@1
  int result; // eax@4

  v1 = (int (**)(void))dword_101E4F70[sub_100223D0()];
  v2 = 0;
  if ( a1 )
  {
    while ( v1 && *v1 )
    {
      result = (*v1)();
      ++v2;
      ++v1;
      if ( v2 >= a1 )
        return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101E4F70: using guessed type int dword_101E4F70[];

//----- (100225E0) --------------------------------------------------------
int __usercall sub_100225E0@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>)
{
  _DWORD *v3; // edi@1
  int result; // eax@1
  int v5; // ecx@2
  int v6; // eax@4
  int v7; // edi@4
  int v8; // edi@7

  v3 = a1;
  result = 0;
  if ( a3 )
  {
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        sub_1002F1F0(5, *(_DWORD *)a3);
        v6 = (*(int (**)(void))(a3 + 8))();
        sub_10022E60((int)v3, v6, 0);
        v7 = -*v3;
        sub_1002F1F0(9, *(_DWORD *)a3);
        result = v7;
      }
    }
    else
    {
      sub_1002F1F0(6, *(_DWORD *)a3);
      if ( a2 )
        a2(5, &unk_1008A758);
      sub_1002F140(a3);
      v8 = -*v3;
      if ( a2 )
        a2(6, &unk_1008A758);
      sub_1002F1F0(8, *(_DWORD *)a3);
      result = v8;
    }
  }
  return result;
}

//----- (10022680) --------------------------------------------------------
int __usercall sub_10022680@<eax>(int result@<eax>)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_BYTE *)(result + 33) = 0;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 24) = 1;
  *(_BYTE *)(result + 32) = 1;
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 52) = 0;
  return result;
}

//----- (100226C0) --------------------------------------------------------
char *__cdecl sub_100226C0(int a1, char *a2, int a3, const char *a4)
{
  const char *v4; // ecx@0
  const char *v5; // ebx@1
  char *v6; // eax@1
  char *v7; // ecx@1
  char *result; // eax@3
  char *v9; // eax@5
  const char *v10; // edi@5
  const char **v11; // ebx@8
  char *v12; // eax@10
  const char *v13; // edi@10
  char **v14; // ebp@10
  const char *v15; // edi@12
  char *v16; // [sp+10h] [bp-624h]@8
  signed int v17; // [sp+14h] [bp-620h]@10
  int v18[6]; // [sp+18h] [bp-61Ch]@2
  char v19; // [sp+30h] [bp-604h]@1
  char v20; // [sp+130h] [bp-504h]@5
  char v21; // [sp+230h] [bp-404h]@7
  char v22; // [sp+330h] [bp-304h]@10
  char v23; // [sp+430h] [bp-204h]@10
  char v24; // [sp+530h] [bp-104h]@10

  v5 = v4;
  v6 = 0;
  v7 = &v19;
  do
  {
    v18[(signed int)v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( (unsigned int)v6 < 6 );
  LOBYTE(v6) = 0;
  result = sub_10022520(v6, "command", (int)&v19);
  if ( a3 )
  {
    LOBYTE(result) = 0;
    if ( a4 )
    {
      v9 = sub_10022520(result, a4, (int)&v20);
      v10 = v5;
    }
    else
    {
      v9 = sub_10022520(result, v5, (int)&v20);
      v10 = byte_1004764C;
    }
    LOBYTE(v9) = 0;
    sub_10022520(v9, v10, (int)&v21);
    result = a2;
    if ( a2 )
    {
      v11 = (const char **)(a1 + 36);
      v16 = a2;
      do
      {
        if ( (unsigned int)*(v11 - 6) >= 2 )
        {
          LOBYTE(result) = 0;
          v12 = sub_10022520(result, *v11, (int)&v24);
          v13 = *(v11 - 9);
          LOBYTE(v12) = 1;
          v22 = 0;
          sub_10022520(v12, v13, (int)&v22);
          v23 = 0;
          v14 = (char **)(v11 - 5);
          v17 = 5;
          do
          {
            switch ( *v14 )
            {
              case 1u:
                v15 = "<bool>";
                goto LABEL_19;
              case 2u:
                v15 = "<char>";
                goto LABEL_19;
              case 3u:
                v15 = "<sint32>";
                goto LABEL_19;
              case 4u:
                v15 = "<uint32>";
                goto LABEL_19;
              case 6u:
                v15 = "<float>";
                goto LABEL_19;
              case 5u:
                v15 = "<str>";
                goto LABEL_19;
              case 0u:
                break;
              default:
                v15 = "<*?*>";
LABEL_19:
                sub_10022520(*v14, v15, (int)&v23);
                break;
            }
            ++v14;
            --v17;
          }
          while ( v17 );
          result = (char *)sub_1002F180(2, (int)v18, 6);
        }
        v11 += 10;
        --v16;
      }
      while ( v16 );
    }
  }
  return result;
}
// 100226C0: using guessed type int var_61C[6];

//----- (10022870) --------------------------------------------------------
int __usercall sub_10022870@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ST08_4@1
  char *v3; // eax@1
  int result; // eax@1
  int (__cdecl *v5)(signed int, void *); // esi@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = sub_10022380((char **)a1);
  result = sub_1002F210(4, (int)v3, v2);
  v5 = *(int (__cdecl **)(signed int, void *))(v1 + 16);
  if ( v5 )
    result = v5(4, &unk_1008A758);
  return result;
}

//----- (100228A0) --------------------------------------------------------
int __usercall sub_100228A0@<eax>(int a1@<esi>)
{
  void (__cdecl *v1)(signed int, void *); // eax@1
  char v2; // al@3

  v1 = *(void (__cdecl **)(signed int, void *))(a1 + 16);
  if ( v1 )
    v1(7, &unk_1008A758);
  v2 = (unsigned int)sub_10022380((char **)a1);
  return sub_1002F1F0(10, v2);
}

//----- (100228D0) --------------------------------------------------------
void __cdecl sub_100228D0(int (**a1)(void), char **a2, _DWORD *a3)
{
  int v3; // esi@3
  int (**v4)(void); // ebx@4
  char **v5; // eax@6
  char *v6; // ST1C_4@6
  char *v7; // eax@6
  char *v8; // eax@7
  char *v9; // eax@9
  char *v10; // eax@10
  int v11; // ebp@12
  signed int v12; // ebx@12
  const char *v13; // eax@14
  char *v14; // ST18_4@14
  int v15; // ST14_4@14
  char *v16; // eax@14
  int v17; // ecx@18
  unsigned int v18; // eax@18
  int v19; // eax@20
  int v20; // ecx@20
  char v21; // dl@20
  int v22; // ST14_4@30
  char *v23; // ST10_4@30
  const char *v24; // eax@31
  char *v25; // ST18_4@31
  int v26; // ST14_4@31
  char *v27; // ST10_4@31
  int v28; // edx@34
  int v29; // ecx@34
  int v30; // eax@34
  int v31; // ST14_4@37
  char *v32; // eax@37
  int v33; // eax@38
  int v34; // ST14_4@39
  char *v35; // ST10_4@39
  int v36; // ST14_4@41
  char *v37; // eax@41
  int v38; // eax@42
  int v39; // ST14_4@43
  char *v40; // eax@43
  int v41; // ST14_4@45
  char *v42; // eax@45
  int v43; // ST14_4@48
  char *v44; // eax@48
  int v45; // edx@49
  int v46; // ST14_4@50
  char *v47; // ST10_4@50
  char *v48; // eax@54
  unsigned int v49; // [sp+4h] [bp-8h]@12
  unsigned int v50; // [sp+8h] [bp-4h]@15
  int v51; // [sp+10h] [bp+4h]@16

  if ( a1 )
  {
    if ( *a1 )
    {
      v3 = (*a1)();
      if ( !a2 )
      {
        v4 = a1 + 1;
        if ( a1 != (int (**)(void))-4 )
        {
          do
          {
            if ( !*v4 )
              break;
            v5 = (char **)(*v4)();
            v6 = sub_10022380(v5);
            v7 = sub_10022380((char **)v3);
            if ( !sub_10022410(v7, (int)v6) )
            {
              v8 = sub_10022380((char **)v3);
              sub_1002F280(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"2872",
                (int)v8,
                (int)"Suite name has been used more than once");
              *a3 = 12;
            }
            ++v4;
          }
          while ( v4 );
        }
      }
      v9 = sub_10022380((char **)v3);
      if ( strchr(v9, 32) )
      {
        v10 = sub_10022380((char **)v3);
        sub_1002F280(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"2903",
          (int)v10,
          (int)"Suite name includes spaces so it must be quoted");
        *a3 = 10;
      }
      if ( *(_DWORD *)(v3 + 12) )
      {
        v11 = 0;
        v49 = 1;
        v12 = 20;
        while ( 1 )
        {
          if ( strchr(*(const char **)(*(_DWORD *)(v3 + 8) + v11), 32) )
          {
            v13 = sub_10022580(*(_DWORD *)(*(_DWORD *)(v3 + 8) + v11 + 12));
            v14 = sub_1002F360("%s name includes spaces so it must be quoted", v13);
            v15 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
            v16 = sub_10022380((char **)v3);
            sub_1002F2C0(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_runner.c", (int)"2915", (int)v16, v15, (int)v14);
            *a3 = 10;
          }
          v50 = v49;
          if ( v49 < *(_DWORD *)(v3 + 12) )
          {
            v51 = v11 + 40;
            do
            {
              if ( !sub_10022410(*(_BYTE **)(*(_DWORD *)(v3 + 8) + v11), *(_DWORD *)(v51 + *(_DWORD *)(v3 + 8))) )
              {
                v17 = *(_DWORD *)(v3 + 8);
                v18 = *(_DWORD *)(v17 + v11 + 12);
                if ( v18 < 2 || *(_DWORD *)(v51 + v17 + 12) < 2u )
                {
                  v24 = sub_10022580(v18);
                  v25 = sub_1002F360("%s name has been used more than once", v24);
                  v26 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
                  v27 = sub_10022380((char **)v3);
                  sub_1002F2C0(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2958",
                    (int)v27,
                    v26,
                    (int)v25);
                }
                else
                {
                  v19 = *(_DWORD *)(v3 + 8);
                  v20 = *(_DWORD *)(v51 + v17 + 16);
                  v21 = 0;
                  if ( *(_DWORD *)(v12 + v19 - 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 8) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 12) != v20 || v21 )
                    goto LABEL_33;
                  v22 = *(_DWORD *)(v19 + v11);
                  v23 = sub_10022380((char **)v3);
                  sub_1002F2C0(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2946",
                    (int)v23,
                    v22,
                    (int)"Command name has been used more than once");
                }
                *a3 = 12;
              }
LABEL_33:
              v51 += 40;
              ++v50;
            }
            while ( v50 < *(_DWORD *)(v3 + 12) );
          }
          v28 = *(_DWORD *)(v3 + 8);
          v29 = *(_DWORD *)(v28 + v11 + 12);
          v30 = v28 + v11;
          if ( !v29 )
            break;
          if ( v29 == 1 )
          {
            if ( !*(_DWORD *)(v30 + 8) )
            {
              v36 = *(_DWORD *)v30;
              v37 = sub_10022380((char **)v3);
              sub_1002F2C0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3047",
                (int)v37,
                v36,
                (int)"Test group has a NULL function pointer or a command uses a reserved ID");
              *a3 = 12;
            }
            v38 = *(_DWORD *)(v3 + 8) + v11;
            if ( *(_DWORD *)(v38 + 4) )
            {
              v39 = *(_DWORD *)v38;
              v40 = sub_10022380((char **)v3);
              sub_1002F2C0(
                3,
                (int)"**Warning**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3058",
                (int)v40,
                v39,
                (int)"Test group has a non-NULL test case function pointer");
              *a3 = 10;
            }
            if ( a2 )
            {
              v41 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
              v42 = sub_10022380((char **)v3);
              sub_1002F2C0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3070",
                (int)v42,
                v41,
                (int)"Test group contains a test group");
              *a3 = 12;
            }
            else
            {
              sub_100228D0(*(_DWORD *)(v3 + 8) + v11 + 8, v3, a3);
            }
            goto LABEL_52;
          }
          if ( *(_DWORD *)(v30 + 4) )
          {
            v31 = *(_DWORD *)v30;
            v32 = sub_10022380((char **)v3);
            sub_1002F2C0(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3088",
              (int)v32,
              v31,
              (int)"Command include a non-NULL test case function pointer");
            *a3 = 10;
          }
          v33 = *(_DWORD *)(v3 + 8) + v11;
          if ( *(_DWORD *)(v33 + 8) )
          {
            v34 = *(_DWORD *)v33;
            v35 = sub_10022380((char **)v3);
            sub_1002F2C0(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3099",
              (int)v35,
              v34,
              (int)"Command include a non-NULL test group function pointer");
LABEL_51:
            *a3 = 10;
          }
LABEL_52:
          ++v49;
          v12 += 40;
          v11 += 40;
          if ( v49 - 1 >= *(_DWORD *)(v3 + 12) )
            return;
        }
        if ( !*(_DWORD *)(v30 + 4) )
        {
          v43 = *(_DWORD *)v30;
          v44 = sub_10022380((char **)v3);
          sub_1002F2C0(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"3022",
            (int)v44,
            v43,
            (int)"Test case has a NULL function pointer or a command uses a reserved ID");
          *a3 = 12;
        }
        v45 = *(_DWORD *)(v3 + 8);
        if ( !*(_DWORD *)(v45 + v11 + 8) )
          goto LABEL_52;
        v46 = *(_DWORD *)(v45 + v11);
        v47 = sub_10022380((char **)v3);
        sub_1002F2C0(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"3033",
          (int)v47,
          v46,
          (int)"Test case has a non-NULL group function pointer");
        goto LABEL_51;
      }
    }
    else
    {
      v48 = sub_10022380(a2);
      sub_1002F280(
        3,
        (int)"**Error**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"3114",
        (int)v48,
        (int)"Test suite has a NULL function pointer or a command uses a reserved ID");
      *a3 = 12;
    }
  }
}

//----- (10022D40) --------------------------------------------------------
int sub_10022D40()
{
  int (**i)(void); // esi@1
  int v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  for ( i = (int (**)(void))dword_101E4F70[sub_100223D0()]; i; ++i )
  {
    if ( !*i )
      break;
    sub_100228D0(i, 0, &v2);
  }
  return v2;
}
// 101E4F70: using guessed type int dword_101E4F70[];

//----- (10022D90) --------------------------------------------------------
void *sub_10022D90()
{
  void *result; // eax@1
  signed int v1; // esi@1

  dword_101E4F70[0] = 0;
  dword_101E4F74 = 0;
  dword_101E4F78 = 0;
  dword_101E4F7C = 0;
  dword_101E4F80 = 0;
  result = &unk_101E4F98;
  dword_101E4F84[0] = -1;
  dword_101E4F88 = -1;
  dword_101E4F8C = -1;
  dword_101E4F90 = -1;
  dword_101E4F94 = -1;
  v1 = 5;
  do
  {
    result = (void *)(sub_10022680((int)result) + 56);
    --v1;
  }
  while ( v1 );
  return result;
}
// 101E4F70: using guessed type int dword_101E4F70[];
// 101E4F74: using guessed type int dword_101E4F74;
// 101E4F78: using guessed type int dword_101E4F78;
// 101E4F7C: using guessed type int dword_101E4F7C;
// 101E4F80: using guessed type int dword_101E4F80;
// 101E4F84: using guessed type int dword_101E4F84[];
// 101E4F88: using guessed type int dword_101E4F88;
// 101E4F8C: using guessed type int dword_101E4F8C;
// 101E4F90: using guessed type int dword_101E4F90;
// 101E4F94: using guessed type int dword_101E4F94;

//----- (10022DF0) --------------------------------------------------------
char *sub_10022DF0()
{
  return (char *)&unk_101E4F98 + 56 * sub_100223D0();
}

//----- (10022E10) --------------------------------------------------------
char __cdecl sub_10022E10(int a1, int a2, unsigned int a3)
{
  char *v3; // esi@1
  char result; // al@1

  v3 = sub_10022DF0();
  result = a1 - 6;
  if ( a1 == 6 )
  {
    *(_DWORD *)v3 = 0;
  }
  else
  {
    result = a1 - 7;
    if ( a1 == 7 )
    {
      result = sub_1002F150(a2, a3);
      if ( result )
        ++*(_DWORD *)v3;
    }
  }
  return result;
}

//----- (10022E50) --------------------------------------------------------
char **sub_10022E50()
{
  return &off_1008AB08;
}
// 1008AB08: using guessed type char *off_1008AB08;

//----- (10022E60) --------------------------------------------------------
int __cdecl sub_10022E60(int a1, int a2, int a3)
{
  char *v3; // esi@1
  int result; // eax@2
  unsigned int v5; // ebp@7
  int v6; // [sp+8h] [bp-8h]@0
  int v7; // [sp+8h] [bp-8h]@7
  int v8; // [sp+Ch] [bp-4h]@8

  sub_1002F480();
  v3 = sub_10022DF0();
  if ( v3[34] )
  {
    result = v6;
  }
  else
  {
    result = sub_10022D40();
    if ( result != 12 )
      v3[34] = 1;
  }
  if ( v3[34] )
  {
    sub_10022870(a2);
    if ( a3 )
    {
      v7 = sub_100225E0((_DWORD *)a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), a3);
    }
    else
    {
      v5 = 0;
      v7 = 0;
      if ( *(_DWORD *)(a2 + 12) )
      {
        v8 = 0;
        do
        {
          v7 += sub_100225E0((_DWORD *)a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), v8 + *(_DWORD *)(a2 + 8));
          v8 += 40;
          ++v5;
        }
        while ( v5 < *(_DWORD *)(a2 + 12) );
        sub_100228A0(a2);
        return v7;
      }
    }
    sub_100228A0(a2);
    result = v7;
  }
  return result;
}

//----- (10022F10) --------------------------------------------------------
int __cdecl sub_10022F10(int a1, int a2, int a3, const char *a4, const char *a5)
{
  int v5; // ebp@1
  unsigned int v6; // eax@1
  char *v7; // ecx@1
  int result; // eax@3
  int v9; // eax@5
  char *v10; // eax@7
  char *v11; // eax@7
  char *v12; // eax@7
  char *v13; // eax@7
  char *v14; // eax@7
  char **v15; // eax@7
  char **v16; // esi@7
  char *v17; // eax@7
  char *v18; // eax@7
  char *v19; // eax@7
  char *v20; // eax@7
  char *v21; // eax@8
  char *v22; // eax@9
  const char *v23; // edi@9
  char *v24; // eax@11
  int v25; // [sp+8h] [bp-41Ch]@4
  int v26[4]; // [sp+10h] [bp-414h]@2
  char v27; // [sp+20h] [bp-404h]@1
  char v28; // [sp+120h] [bp-304h]@7
  char v29; // [sp+220h] [bp-204h]@7
  char v30; // [sp+320h] [bp-104h]@11

  v5 = a1;
  v6 = 0;
  v7 = &v27;
  do
  {
    v26[v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( v6 < 4 );
  result = a2;
  if ( a2 )
  {
    v25 = a2;
    do
    {
      v9 = *(_DWORD *)(v5 + 12);
      if ( v9 )
      {
        result = v9 - 1;
        if ( !result )
        {
          v10 = sub_10022520(0, "group", (int)&v27);
          LOBYTE(v10) = 0;
          v11 = sub_10022520(v10, a4, (int)&v28);
          LOBYTE(v11) = 0;
          sub_10022520(v11, *(const char **)v5, (int)&v29);
          v12 = (char *)sub_1002F180(2, (int)v26, 3);
          LOBYTE(v12) = 0;
          v13 = sub_10022520(v12, "group", (int)&v27);
          LOBYTE(v13) = 0;
          v14 = sub_10022520(v13, a4, (int)&v28);
          LOBYTE(v14) = 0;
          sub_10022520(v14, "group-begin", (int)&v29);
          sub_1002F180(2, (int)v26, 3);
          v15 = (char **)(*(int (**)(void))(v5 + 8))();
          v16 = v15;
          v17 = sub_10022380(v15);
          sub_10022F10(v16[2], v16[3], v16[4], v17, a4);
          sub_10022380(v16);
          v18 = sub_100226C0((int)v16[2], v16[3], (int)v16[4], a4);
          LOBYTE(v18) = 0;
          v19 = sub_10022520(v18, "group", (int)&v27);
          LOBYTE(v19) = 0;
          v20 = sub_10022520(v19, a4, (int)&v28);
          LOBYTE(v20) = 0;
          sub_10022520(v20, "group-end", (int)&v29);
          result = sub_1002F180(2, (int)v26, 3);
        }
      }
      else
      {
        v21 = sub_10022520(0, "case", (int)&v27);
        LOBYTE(v21) = 0;
        if ( a5 )
        {
          v22 = sub_10022520(v21, a5, (int)&v28);
          v23 = a4;
        }
        else
        {
          v22 = sub_10022520(v21, a4, (int)&v28);
          v23 = byte_1004764C;
        }
        LOBYTE(v22) = 0;
        v24 = sub_10022520(v22, v23, (int)&v29);
        LOBYTE(v24) = 0;
        sub_10022520(v24, *(const char **)v5, (int)&v30);
        result = sub_1002F180(2, (int)v26, 4);
      }
      v5 += 40;
      --v25;
    }
    while ( v25 );
  }
  return result;
}
// 10022F10: using guessed type int var_414[4];

//----- (10023120) --------------------------------------------------------
char *__usercall sub_10023120@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6)
{
  const char *v6; // edi@1
  char *v7; // eax@1
  char *v8; // ecx@1
  char *v9; // eax@3
  char *result; // eax@3
  int v11[2]; // [sp+Ch] [bp-20Ch]@2
  char v12; // [sp+14h] [bp-204h]@1
  char v13; // [sp+114h] [bp-104h]@3

  v6 = a1;
  v7 = 0;
  v8 = &v12;
  do
  {
    v11[(signed int)v7] = (int)v8;
    *v8 = 0;
    ++v7;
    v8 += 256;
  }
  while ( (unsigned int)v7 < 2 );
  LOBYTE(v7) = 0;
  v9 = sub_10022520(v7, v6, (int)&v12);
  LOBYTE(v9) = 0;
  result = sub_10022520(v9, a2, (int)&v13);
  if ( v13 )
    result = (char *)sub_1002F180(2, (int)v11, 2);
  if ( a6 )
  {
    sub_10022F10(a3, (int)a4, a5, a2, 0);
    result = sub_100226C0(a3, a4, a5, 0);
  }
  return result;
}
// 10023120: using guessed type int var_20C[2];

//----- (100231E0) --------------------------------------------------------
char *__cdecl sub_100231E0(char a1)
{
  int (**i)(void); // edi@1
  int v2; // esi@3
  char *v3; // ebx@3
  char **v4; // esi@4
  signed int v5; // edi@4
  char *result; // eax@5

  for ( i = (int (**)(void))dword_101E4F70[sub_100223D0()]; i; ++i )
  {
    if ( !*i )
      break;
    v2 = (*i)();
    v3 = sub_10022380((char **)v2);
    sub_10023120("suite", v3, *(_DWORD *)(v2 + 8), *(char **)(v2 + 12), *(_DWORD *)(v2 + 16), a1);
  }
  v4 = (char **)(sub_10022DF0() + 36);
  v5 = 5;
  do
  {
    result = *v4;
    if ( *v4 )
    {
      if ( *((_DWORD *)result + 2) )
        result = sub_10023120(
                   "listener",
                   *(const char **)result,
                   *((_DWORD *)result + 3),
                   *((char **)result + 4),
                   *((_DWORD *)result + 2),
                   a1);
    }
    ++v4;
    --v5;
  }
  while ( v5 );
  return result;
}
// 101E4F70: using guessed type int dword_101E4F70[];

//----- (10023280) --------------------------------------------------------
int *__cdecl sub_10023280(_BYTE *a1)
{
  int (**v1)(void); // edi@1
  char **v2; // eax@3
  char **v3; // esi@3
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // ebx@7
  unsigned int v7; // esi@7
  int **v8; // edi@7
  int *result; // eax@8

  v1 = (int (**)(void))dword_101E4F70[sub_100223D0()];
  if ( v1 )
  {
    while ( *v1 )
    {
      v2 = (char **)(*v1)();
      v3 = v2;
      v4 = sub_10022380(v2);
      if ( !sub_10022480(a1, (int)v4) )
      {
        v5 = sub_10022380(v3);
        sub_10023120("suite", v5, (int)v3[2], v3[3], (int)v3[4], 1);
        break;
      }
      ++v1;
      if ( !v1 )
        break;
    }
  }
  v6 = sub_10022DF0();
  v7 = 0;
  v8 = (int **)(v6 + 36);
  while ( 1 )
  {
    result = *v8;
    if ( *v8 )
    {
      result = (int *)sub_10022480(a1, *result);
      if ( !result )
        break;
    }
    ++v7;
    ++v8;
    if ( v7 >= 5 )
      return result;
  }
  return (int *)sub_10023120(
                  "listener",
                  **(const char ***)&v6[4 * v7 + 36],
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 12),
                  *(char **)(*(_DWORD *)&v6[4 * v7 + 36] + 16),
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 8),
                  1);
}
// 101E4F70: using guessed type int dword_101E4F70[];

//----- (10023340) --------------------------------------------------------
int __usercall sub_10023340@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  bool v2; // zf@1
  int result; // eax@1
  signed int v4; // ebp@3
  int v5; // eax@5
  int v6; // eax@8
  int v7; // ecx@14
  int v8; // esi@18
  unsigned int v9; // eax@18
  int v10; // eax@19
  int v11; // edi@25

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 20) == 0;
  result = 12;
  if ( !v2 && !*(_BYTE *)(v1 + 24) )
  {
    v4 = 2;
    if ( !*(_DWORD *)(v1 + 16) )
    {
      *(_DWORD *)(v1 + 16) = sub_100225A0(++*(_DWORD *)(v1 + 12));
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 4) = 0;
    }
    v5 = *(_DWORD *)(v1 + 16);
    if ( v5 )
    {
      if ( *(_DWORD *)(v1 + 20) == 1 )
      {
        sub_10022E60(v1, v5, *(_DWORD *)(v1 + 8));
        v6 = sub_100225A0(++*(_DWORD *)(v1 + 12));
        v2 = *(_DWORD *)(v1 + 28) == 0;
        *(_DWORD *)(v1 + 16) = v6;
        *(_DWORD *)(v1 + 8) = 0;
        if ( !v2 || !v6 )
          *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 28) == 2 )
      {
        sub_10022E60(v1, v5, *(_DWORD *)(v1 + 8));
        *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 8)
             || (*(_DWORD *)(v1 + 4) = 0, v7 = *(_DWORD *)(v5 + 8), (*(_DWORD *)(v1 + 8) = v7) != 0) )
      {
        if ( !*(_DWORD *)(v1 + 4) )
          sub_10022870(v5);
        sub_100225E0(
          (_DWORD *)v1,
          *(void (__cdecl **)(signed int, void *))(*(_DWORD *)(v1 + 16) + 16),
          *(_DWORD *)(v1 + 8));
        v8 = *(_DWORD *)(v1 + 16);
        v9 = ++*(_DWORD *)(v1 + 4);
        if ( *(_DWORD *)(v8 + 12) > v9 )
        {
          *(_DWORD *)(v1 + 8) = *(_DWORD *)(v8 + 8) + 40 * v9;
        }
        else
        {
          sub_100228A0(v8);
          v10 = sub_100225A0(++*(_DWORD *)(v1 + 12));
          *(_DWORD *)(v1 + 16) = v10;
          *(_DWORD *)(v1 + 4) = 0;
          *(_DWORD *)(v1 + 8) = 0;
          if ( !v10 || *(_DWORD *)(v1 + 28) )
            *(_BYTE *)(v1 + 24) = 1;
        }
      }
      else
      {
        *(_BYTE *)(v1 + 24) = 1;
        v4 = 12;
      }
    }
    else
    {
      *(_BYTE *)(v1 + 24) = 1;
      v4 = 12;
    }
    if ( *(_BYTE *)(v1 + 24) && v4 == 2 )
    {
      v11 = *(_DWORD *)v1;
      if ( v11 )
        result = v11 + 12;
      else
        result = 0;
    }
    else
    {
      result = v4;
    }
  }
  return result;
}

//----- (100234A0) --------------------------------------------------------
signed int __usercall sub_100234A0@<eax>(int a1@<esi>)
{
  signed int v1; // ebp@1
  int (**i)(void); // edi@2
  int v3; // eax@4
  signed int result; // eax@5

  v1 = 0;
  if ( *(_DWORD *)(a1 + 20) )
  {
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(_BYTE *)(a1 + 24) = 0;
      result = 1;
    }
    else
    {
      result = 12;
    }
  }
  else
  {
    for ( i = (int (**)(void))dword_101E4F70[sub_100223D0()]; i; ++i )
    {
      if ( !*i )
        break;
      v3 = (*i)();
      v1 += sub_10022E60(a1, v3, 0);
    }
    result = v1;
  }
  return result;
}
// 101E4F70: using guessed type int dword_101E4F70[];

//----- (10023510) --------------------------------------------------------
int __cdecl sub_10023510(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  int v4; // ebx@3
  int result; // eax@3
  _BYTE *v6; // esi@5
  int v7; // ebx@6
  int v8; // ebx@8
  int v9; // ebx@9
  int (**i)(void); // edi@11
  int v11; // eax@13
  int (__cdecl *v12)(int, int); // eax@14
  int (**v13)(void); // esi@19
  int v14; // eax@21
  int (__cdecl *v15)(int, int); // eax@22

  v2 = 0;
  v3 = sub_10022DF0();
  switch ( a1 )
  {
    case 9:
      sub_1002F1F0(2, (unsigned int)"begin");
      if ( *(_DWORD *)a2 )
      {
        if ( *(_DWORD *)a2 == 5 )
        {
          v6 = (_BYTE *)(a2 + 4);
          if ( sub_10022480((_BYTE *)(a2 + 4), (int)"-v") )
          {
            if ( sub_10022480(v6, (int)"-q") )
            {
              sub_10023280(v6);
              v9 = sub_10022D40();
              sub_1002F1F0(2, (unsigned int)"end");
              result = v9;
            }
            else
            {
              sub_100231E0(0);
              v8 = sub_10022D40();
              sub_1002F1F0(2, (unsigned int)"end");
              result = v8;
            }
          }
          else
          {
            sub_100231E0(1);
            v7 = sub_10022D40();
            sub_1002F1F0(2, (unsigned int)"end");
            result = v7;
          }
        }
        else
        {
          sub_1002F240(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"1719",
            (int)"Unsupported argument type for help command (internal error)");
          sub_1002F1F0(2, (unsigned int)"end");
          result = 4;
        }
      }
      else
      {
        sub_100231E0(0);
        v4 = sub_10022D40();
        sub_1002F1F0(2, (unsigned int)"end");
        result = v4;
      }
      return result;
    case 2:
      sub_1002F1F0(0, (unsigned int)"Global reset command");
      for ( i = (int (**)(void))dword_101E4F70[sub_100223D0()]; i; ++i )
      {
        if ( !*i )
          break;
        v11 = (*i)();
        if ( v11 )
        {
          v12 = *(int (__cdecl **)(int, int))(v11 + 16);
          if ( v12 )
          {
            if ( v12 != sub_10023510 )
              v12(2, (int)&unk_1008A758);
          }
        }
      }
      sub_1002F480();
      v3[34] = 0;
      return 0;
    case 3:
      sub_1002F1F0(1, (unsigned int)"Global clear command");
      v13 = (int (**)(void))dword_101E4F70[sub_100223D0()];
      if ( !v13 )
        return v2;
      break;
    case 10:
      if ( !*((_DWORD *)v3 + 5) )
      {
        sub_1002F240(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1764", (int)"Step mode not enabled");
        goto LABEL_29;
      }
      return sub_10023340((int)v3);
    case 11:
      if ( v3[24] )
      {
        *((_DWORD *)v3 + 5) = 0;
        v3[24] = 0;
        result = 0;
      }
      else
      {
        sub_1002F240(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1783", (int)"Step mode is busy");
LABEL_29:
        result = 12;
      }
      return result;
    case 12:
      *((_DWORD *)v3 + 5) = 1;
      return 0;
    case 13:
      *((_DWORD *)v3 + 5) = 2;
      return 0;
    case 8:
      return sub_100234A0((int)v3);
    case 14:
      exit_1(12);
      return result;
    case 4:
    case 5:
    case 6:
    case 7:
      return v2;
    default:
      sub_1002F240(
        3,
        (int)"**Warning**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"1820",
        (int)"Unknown/unsupported command (internal error)");
      return 4;
  }
  while ( *v13 )
  {
    v14 = (*v13)();
    if ( v14 )
    {
      v15 = *(int (__cdecl **)(int, int))(v14 + 16);
      if ( v15 )
      {
        if ( v15 != sub_10023510 )
          v15(3, (int)&unk_1008A758);
      }
    }
    ++v13;
    if ( !v13 )
      return 0;
  }
  return v2;
}
// 10023510: using guessed type int __cdecl sub_10023510(int, int);
// 101E4F70: using guessed type int dword_101E4F70[];

//----- (100237F0) --------------------------------------------------------
signed int __usercall sub_100237F0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // edi@1
  signed int result; // eax@1
  int v5; // esi@1
  unsigned __int16 v6; // bx@2
  unsigned __int16 v7; // ax@2
  unsigned int v8; // ebx@2
  unsigned __int16 v9; // dx@2
  int v10; // edx@2
  int v11; // eax@2
  int v12; // esi@2
  unsigned int v13; // edx@2
  int v14; // eax@2
  int v15; // esi@2
  unsigned int v16; // ST2C_4@4
  unsigned int v17; // ST30_4@4
  unsigned int v18; // ST34_4@4
  unsigned int v19; // esi@4
  unsigned int v20; // ST2C_4@5
  unsigned int v21; // ST30_4@5
  unsigned int v22; // ST34_4@5
  unsigned int v23; // esi@5
  unsigned int v24; // ST30_4@6
  unsigned int v25; // ST34_4@6
  unsigned int v26; // edx@6
  unsigned int v27; // esi@6
  __int16 v28; // ST38_2@6
  unsigned int v29; // ST1C_4@6
  unsigned int v30; // ST20_4@6
  unsigned int v31; // ST24_4@6
  unsigned int v32; // esi@6
  unsigned int v33; // edx@6
  unsigned int v34; // ST30_4@6
  unsigned int v35; // ST34_4@6
  unsigned int v36; // esi@6
  unsigned int v37; // ST1C_4@6
  unsigned int v38; // ST20_4@6
  unsigned int v39; // ST24_4@6
  unsigned int v40; // esi@6
  unsigned int v41; // ST30_4@6
  unsigned int v42; // edx@6
  unsigned int v43; // ST34_4@6
  unsigned int v44; // esi@6
  unsigned int v45; // ST1C_4@6
  unsigned int v46; // ST20_4@6
  unsigned int v47; // ST24_4@6
  unsigned int v48; // esi@6
  unsigned int v49; // edx@6
  unsigned int v50; // ST30_4@6
  unsigned int v51; // ST34_4@6
  unsigned int v52; // esi@6
  unsigned int v53; // ST1C_4@6
  unsigned int v54; // ST20_4@6
  unsigned int v55; // ST24_4@6
  unsigned int v56; // ST28_4@6
  unsigned int v57; // ST30_4@6
  unsigned int v58; // edx@6
  unsigned int v59; // ST34_4@6
  unsigned int v60; // ST38_4@6
  unsigned int v61; // ST20_4@6
  unsigned int v62; // ST24_4@6
  unsigned int v63; // ebx@6
  unsigned int v64; // eax@6
  unsigned int v65; // [sp+14h] [bp-20h]@2
  unsigned int v66; // [sp+18h] [bp-1Ch]@2
  unsigned int v67; // [sp+1Ch] [bp-18h]@2
  unsigned int v68; // [sp+20h] [bp-14h]@2

  v3 = a1;
  result = 0;
  v5 = a2;
  if ( *(_BYTE *)(v3 + 260) & 1 )
  {
    BYTE1(result) = *(_BYTE *)(a2 + 3);
    HIBYTE(v6) = *(_BYTE *)(a2 + 7);
    LOBYTE(result) = *(_BYTE *)(a2 + 2);
    LOBYTE(v6) = *(_BYTE *)(a2 + 6);
    v65 = *(_DWORD *)v3 ^ (*(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (result << 8)) << 8));
    HIBYTE(v7) = *(_BYTE *)(a2 + 11);
    v8 = *(_DWORD *)(v3 + 4) ^ (*(_BYTE *)(a2 + 4) | ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8));
    LOBYTE(v7) = *(_BYTE *)(a2 + 10);
    v66 = v8;
    HIBYTE(v9) = *(_BYTE *)(a2 + 15);
    v67 = *(_DWORD *)(v3 + 8) ^ (*(_BYTE *)(v5 + 8) | ((*(_BYTE *)(v5 + 9) | (v7 << 8)) << 8));
    LOBYTE(v9) = *(_BYTE *)(v5 + 14);
    v10 = *(_BYTE *)(v5 + 13) | (v9 << 8);
    v11 = *(_BYTE *)(v5 + 12);
    v12 = *(_DWORD *)(v3 + 256);
    v13 = *(_DWORD *)(v3 + 12) ^ (v11 | (v10 << 8));
    v14 = v3 + 16 * (v12 - 9);
    v15 = v12 - 12;
    v68 = v13;
    if ( v15 )
    {
      if ( v15 != 2 )
      {
LABEL_6:
        v24 = *(_DWORD *)(v14 + 4) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v66] ^ *(_DWORD *)&dword_1008BBF0[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v68 >> 16)];
        v25 = *(_DWORD *)(v14 + 8) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v66 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v68)];
        v26 = *(_DWORD *)v14 ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v13 >> 24)];
        v27 = *(_DWORD *)(v14 + 12) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v66 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v67 >> 24)];
        v28 = *(_WORD *)(v14 + 12) ^ dword_1008AFF0[2 * (unsigned __int8)v68] ^ dword_1008B3F0[2 * BYTE1(v65)] ^ dword_1008B7F0[2 * (unsigned __int8)(v66 >> 16)] ^ dword_1008BBF0[2 * (v67 >> 24)];
        v29 = *(_DWORD *)(v14 + 16) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v26] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v24)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v25 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v27 >> 24)];
        v30 = *(_DWORD *)(v14 + 20) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v24] ^ *(_DWORD *)&dword_1008BBF0[2 * (v26 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v25)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v27 >> 16)];
        v31 = *(_DWORD *)(v14 + 24) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v25] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v26 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v24 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * HIBYTE(v28)];
        v32 = *(_DWORD *)(v14 + 28) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v28] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v26)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v24 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v25 >> 24)];
        v33 = *(_DWORD *)(v14 + 32) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v29] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v30)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v31 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v32 >> 24)];
        v34 = *(_DWORD *)(v14 + 36) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v30] ^ *(_DWORD *)&dword_1008BBF0[2 * (v29 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v31)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v32 >> 16)];
        v35 = *(_DWORD *)(v14 + 40) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v31] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v29 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v30 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v32)];
        v36 = *(_DWORD *)(v14 + 44) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v32] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v29)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v30 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v31 >> 24)];
        v37 = *(_DWORD *)(v14 + 48) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v33] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v34)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v35 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v36 >> 24)];
        v38 = *(_DWORD *)(v14 + 52) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v34] ^ *(_DWORD *)&dword_1008BBF0[2 * (v33 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v35)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v36 >> 16)];
        v39 = *(_DWORD *)(v14 + 56) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v35] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v33 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v34 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v36)];
        v40 = *(_DWORD *)(v14 + 60) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v36] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v33)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v34 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v35 >> 24)];
        v41 = *(_DWORD *)(v14 + 68) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v38] ^ *(_DWORD *)&dword_1008BBF0[2 * (v37 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v39)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v40 >> 16)];
        v42 = *(_DWORD *)(v14 + 64) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v37] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v38)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v39 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v40 >> 24)];
        v43 = *(_DWORD *)(v14 + 72) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v39] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v37 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v38 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v40)];
        v44 = *(_DWORD *)(v14 + 76) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v40] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v37)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v38 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v39 >> 24)];
        v45 = *(_DWORD *)(v14 + 80) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v42] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v41)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v43 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v44 >> 24)];
        v46 = *(_DWORD *)(v14 + 84) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v41] ^ *(_DWORD *)&dword_1008BBF0[2 * (v42 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v43)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v44 >> 16)];
        v47 = *(_DWORD *)(v14 + 88) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v43] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v42 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v41 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v44)];
        v48 = *(_DWORD *)(v14 + 92) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v44] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v42)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v41 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v43 >> 24)];
        v49 = *(_DWORD *)(v14 + 96) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v45] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v46)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v47 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v48 >> 24)];
        v50 = *(_DWORD *)(v14 + 100) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v46] ^ *(_DWORD *)&dword_1008BBF0[2 * (v45 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v47)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v48 >> 16)];
        v51 = *(_DWORD *)(v14 + 104) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v47] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v45 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v46 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v48)];
        v52 = *(_DWORD *)(v14 + 108) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v48] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v45)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v46 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v47 >> 24)];
        v53 = *(_DWORD *)(v14 + 112) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v49] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v50)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v51 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v52 >> 24)];
        v54 = *(_DWORD *)(v14 + 116) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v50] ^ *(_DWORD *)&dword_1008BBF0[2 * (v49 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v51)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v52 >> 16)];
        v55 = *(_DWORD *)(v14 + 120) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v51] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v49 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v50 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v52)];
        v56 = *(_DWORD *)(v14 + 124) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v52] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v49)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v50 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v51 >> 24)];
        v57 = *(_DWORD *)(v14 + 132) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v54] ^ *(_DWORD *)&dword_1008BBF0[2 * (v53 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v55)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v56 >> 16)];
        v58 = *(_DWORD *)(v14 + 128) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v53] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v54)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v55 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v56 >> 24)];
        v59 = *(_DWORD *)(v14 + 136) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v55] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v53 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v54 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v56)];
        v60 = *(_DWORD *)(v14 + 140) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v56] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v53)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v54 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v55 >> 24)];
        v61 = *(_DWORD *)(v14 + 148) ^ dword_1008BFF0[(unsigned __int8)v57] ^ dword_1008CBF0[v58 >> 24] ^ dword_1008C3F0[BYTE1(v59)] ^ dword_1008C7F0[(unsigned __int8)(v60 >> 16)];
        v62 = *(_DWORD *)(v14 + 152) ^ dword_1008BFF0[(unsigned __int8)v59] ^ dword_1008C7F0[(unsigned __int8)(v58 >> 16)] ^ dword_1008CBF0[v57 >> 24] ^ dword_1008C3F0[BYTE1(v60)];
        v63 = *(_DWORD *)(v14 + 156) ^ dword_1008BFF0[(unsigned __int8)v60] ^ dword_1008C3F0[BYTE1(v58)] ^ dword_1008C7F0[(unsigned __int8)(v57 >> 16)] ^ dword_1008CBF0[v59 >> 24];
        v64 = *(_DWORD *)(v14 + 144) ^ dword_1008BFF0[(unsigned __int8)v58] ^ dword_1008C3F0[BYTE1(v57)] ^ dword_1008C7F0[(unsigned __int8)(v59 >> 16)] ^ dword_1008CBF0[v60 >> 24];
        *(_BYTE *)(a3 + 1) = BYTE1(v64);
        *(_BYTE *)a3 = v64;
        *(_BYTE *)(a3 + 2) = v64 >> 16;
        *(_BYTE *)(a3 + 3) = BYTE3(v64);
        *(_BYTE *)(a3 + 5) = BYTE1(v61);
        *(_BYTE *)(a3 + 4) = v61;
        *(_BYTE *)(a3 + 7) = BYTE3(v61);
        *(_BYTE *)(a3 + 6) = v61 >> 16;
        *(_BYTE *)(a3 + 9) = BYTE1(v62);
        *(_BYTE *)(a3 + 8) = v62;
        *(_BYTE *)(a3 + 11) = BYTE3(v62);
        *(_BYTE *)(a3 + 10) = v62 >> 16;
        *(_BYTE *)(a3 + 12) = v63;
        *(_BYTE *)(a3 + 13) = BYTE1(v63);
        *(_BYTE *)(a3 + 15) = BYTE3(v63);
        *(_BYTE *)(a3 + 14) = v63 >> 16;
        return 1;
      }
      v16 = *(_DWORD *)(v14 - 64) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v13 >> 24)];
      v17 = *(_DWORD *)(v14 - 60) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_1008BBF0[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v13 >> 16)];
      v18 = *(_DWORD *)(v14 - 56) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v68)];
      v19 = *(_DWORD *)(v14 - 52) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v13] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v67 >> 24)];
      v8 = *(_DWORD *)(v14 - 44) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v17] ^ *(_DWORD *)&dword_1008BBF0[2 * (v16 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v18)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v19 >> 16)];
      v67 = *(_DWORD *)(v14 - 40) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v18] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v16 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v17 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v19)];
      v65 = *(_DWORD *)(v14 - 48) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v16] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v17)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v18 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v19 >> 24)];
      v13 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v18 >> 24)];
      v68 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v18 >> 24)];
    }
    v20 = *(_DWORD *)(v14 - 32) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v13 >> 24)];
    v21 = *(_DWORD *)(v14 - 28) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_1008BBF0[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v68 >> 16)];
    v22 = *(_DWORD *)(v14 - 24) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v68)];
    v23 = *(_DWORD *)(v14 - 20) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v67 >> 24)];
    v8 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_1008BBF0[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v23 >> 16)];
    v67 = *(_DWORD *)(v14 - 8) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v22] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v20 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v21 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v23)];
    v65 = *(_DWORD *)(v14 - 16) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v20] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v21)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v22 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v23 >> 24)];
    v66 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_1008BBF0[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v23 >> 16)];
    v13 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v22 >> 24)];
    v68 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_1008AFF0[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_1008B3F0[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_1008B7F0[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_1008BBF0[2 * (v22 >> 24)];
    goto LABEL_6;
  }
  return result;
}
// 1008BFF0: using guessed type int dword_1008BFF0[];
// 1008C3F0: using guessed type int dword_1008C3F0[];
// 1008C7F0: using guessed type int dword_1008C7F0[];
// 1008CBF0: using guessed type int dword_1008CBF0[];

//----- (100248A0) --------------------------------------------------------
int __usercall sub_100248A0@<eax>(int a1@<esi>, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@3
  bool v6; // zf@4

  result = *(_DWORD *)(a1 + 456);
  v4 = 0;
  if ( a3 )
  {
    do
    {
      if ( result == 16 )
      {
        v5 = 0;
        do
        {
          v6 = (*(_BYTE *)(v5 + a1))++ == -1;
          if ( !v6 )
            break;
          ++v5;
        }
        while ( v5 < 8 );
        sub_100237F0(a1 + 32, a1, a1 + 16);
        result = 0;
      }
      *(_BYTE *)(v4++ + a2) ^= *(_BYTE *)(a1 + 16 + result++);
    }
    while ( v4 < a3 );
  }
  *(_DWORD *)(a1 + 456) = result;
  return result;
}

//----- (10024900) --------------------------------------------------------
signed int __usercall sub_10024900@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned __int16 v4; // dx@1
  int v5; // edx@1
  unsigned __int16 v6; // cx@1
  int v7; // esi@1
  int v8; // edi@1
  unsigned int v9; // ecx@1
  unsigned __int16 v10; // dx@2
  int v11; // edx@2
  int v12; // ebx@2
  int v13; // edx@3
  int v14; // ST20_4@3
  int v15; // edx@3
  int v16; // ST24_4@3
  int v17; // edx@3
  int v18; // ST28_4@3
  unsigned int v19; // edx@3
  int v20; // ebp@3
  int v21; // esi@3
  int v22; // edi@3
  unsigned int v23; // ecx@3
  int v24; // ST20_4@3
  int v25; // ebx@3
  unsigned int v26; // edx@3
  int v27; // ST28_4@3
  int v28; // ebp@3
  int v29; // esi@3
  int v30; // edi@3
  unsigned int v31; // ecx@3
  int v32; // ST10_4@3
  int v33; // ebx@3
  int v34; // ebp@3
  unsigned int v35; // edx@3
  int v36; // ST28_4@3
  int v37; // ST24_4@3
  int v38; // ebp@3
  int v39; // esi@3
  int v40; // edi@3
  unsigned int v41; // ecx@3
  int v42; // ebx@3
  unsigned int v43; // edx@3
  int v44; // ebp@3
  int v45; // esi@3
  int v46; // edi@3
  unsigned int v47; // ecx@3
  int v48; // ST10_4@3
  int v49; // ST20_4@3
  int v50; // ebp@3
  int v51; // ebx@3
  unsigned int v52; // edx@3
  int v53; // ST28_4@3
  int v54; // ST24_4@3
  int v55; // ebp@3
  int v56; // esi@3
  int v57; // edi@3
  unsigned int v58; // ecx@3
  int v59; // ebx@3
  unsigned int v60; // edx@3
  int v61; // ST28_4@3
  int v62; // ST24_4@3
  int v63; // ebp@3
  int v64; // esi@3
  int v65; // edi@3
  unsigned int v66; // ecx@3
  int v67; // ST10_4@3
  int v68; // ebx@3
  unsigned int v69; // edx@3
  int v70; // ebp@3
  int v71; // ebp@3
  int v72; // esi@3
  int v73; // edi@3
  signed int result; // eax@3
  int v75; // edx@4
  int v76; // ST20_4@4
  unsigned int v77; // edx@4
  int v78; // ebp@4
  int v79; // esi@4
  int v80; // edi@4
  int v81; // ecx@4
  unsigned int v82; // edx@4
  int v83; // ST20_4@4
  int v84; // ebp@4
  int v85; // esi@4
  int v86; // edi@4
  int v87; // ecx@4
  int v88; // ebx@4
  unsigned int v89; // edx@4
  int v90; // ebp@4
  int v91; // esi@4
  int v92; // edi@4
  int v93; // ecx@4
  unsigned int v94; // edx@4
  int v95; // ST20_4@4
  int v96; // ebp@4
  int v97; // esi@4
  int v98; // edi@4
  int v99; // ecx@4
  unsigned int v100; // edx@4
  int v101; // ST20_4@4
  int v102; // ST10_4@4
  int v103; // ebp@4
  int v104; // esi@4
  int v105; // edi@4
  int v106; // ST10_4@4
  int v107; // ecx@4
  unsigned int v108; // edx@4
  int v109; // ST20_4@4
  int v110; // ebp@4
  int v111; // esi@4
  int v112; // edi@4
  int v113; // ecx@4
  unsigned int v114; // edx@4
  int v115; // ST20_4@4
  int v116; // ebp@4
  int v117; // esi@4
  int v118; // edi@4
  int v119; // ecx@4
  unsigned int v120; // edx@4
  int v121; // ST10_4@4
  int v122; // ebp@4
  int v123; // ebp@4
  int v124; // esi@4
  int v125; // edi@4
  int v126; // ebp@5
  int v127; // esi@5
  int v128; // edi@5
  unsigned int v129; // ecx@5
  int v130; // edx@5
  int v131; // esi@5
  int v132; // edi@5
  unsigned int v133; // ecx@5
  int v134; // ebp@5
  int v135; // esi@5
  int v136; // edi@5
  unsigned int v137; // ecx@5
  int v138; // edx@5
  int v139; // esi@5
  int v140; // edi@5
  unsigned int v141; // ecx@5
  int v142; // ebp@5
  int v143; // esi@5
  int v144; // edi@5
  unsigned int v145; // ecx@5
  int v146; // edx@5
  int v147; // esi@5
  int v148; // edi@5
  unsigned int v149; // ecx@5
  int v150; // ebp@5
  int v151; // esi@5
  int v152; // edi@5
  unsigned int v153; // ecx@5
  int v154; // edx@5
  int v155; // esi@5
  int v156; // edi@5
  unsigned int v157; // ecx@5
  int v158; // ebp@5
  int v159; // esi@5
  int v160; // edi@5
  unsigned int v161; // ecx@5
  int v162; // edx@5
  int v163; // edx@5
  int v164; // esi@5
  int v165; // edi@5
  int v166; // [sp+10h] [bp-20h]@1

  *(_DWORD *)(a1 + 260) = 17;
  v3 = a2;
  HIBYTE(v4) = *(_BYTE *)(a2 + 3);
  LOBYTE(v4) = *(_BYTE *)(a2 + 2);
  v5 = *(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (v4 << 8)) << 8);
  *(_DWORD *)a1 = v5;
  HIBYTE(v6) = *(_BYTE *)(a2 + 7);
  v166 = v5;
  LOBYTE(v6) = *(_BYTE *)(a2 + 6);
  v7 = ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8) | *(_BYTE *)(a2 + 4);
  *(_DWORD *)(a1 + 4) = v7;
  HIBYTE(v6) = *(_BYTE *)(a2 + 11);
  LOBYTE(v6) = *(_BYTE *)(a2 + 10);
  v8 = ((*(_BYTE *)(v3 + 9) | (v6 << 8)) << 8) | *(_BYTE *)(v3 + 8);
  *(_DWORD *)(a1 + 8) = v8;
  HIBYTE(v6) = *(_BYTE *)(a2 + 15);
  LOBYTE(v6) = *(_BYTE *)(a2 + 14);
  v9 = *(_BYTE *)(v3 + 12) | ((*(_BYTE *)(v3 + 13) | (v6 << 8)) << 8);
  *(_DWORD *)(a1 + 12) = v9;
  if ( a3 == 16 )
  {
    v126 = v5 ^ dword_1008CBF0[(unsigned __int8)v9] ^ dword_1008BFF0[BYTE1(v9)] ^ dword_1008C3F0[(unsigned __int8)(v9 >> 16)] ^ dword_1008C7F0[v9 >> 24] ^ 1;
    v127 = v126 ^ v7;
    *(_DWORD *)(a1 + 16) = v126;
    *(_DWORD *)(a1 + 20) = v127;
    v128 = v127 ^ v8;
    *(_DWORD *)(a1 + 24) = v128;
    v129 = v128 ^ v9;
    *(_DWORD *)(a1 + 28) = v129;
    v130 = v126 ^ dword_1008CBF0[(unsigned __int8)v129] ^ dword_1008BFF0[BYTE1(v129)] ^ dword_1008C3F0[(unsigned __int8)(v129 >> 16)] ^ dword_1008C7F0[v129 >> 24] ^ 2;
    v131 = v130 ^ v127;
    *(_DWORD *)(a1 + 32) = v130;
    *(_DWORD *)(a1 + 36) = v131;
    v132 = v131 ^ v128;
    *(_DWORD *)(a1 + 40) = v132;
    v133 = v132 ^ v129;
    *(_DWORD *)(a1 + 44) = v133;
    v134 = v130 ^ dword_1008CBF0[(unsigned __int8)v133] ^ dword_1008BFF0[BYTE1(v133)] ^ dword_1008C3F0[(unsigned __int8)(v133 >> 16)] ^ dword_1008C7F0[v133 >> 24] ^ 4;
    v135 = v134 ^ v131;
    v136 = v135 ^ v132;
    v137 = v136 ^ v133;
    *(_DWORD *)(a1 + 48) = v134;
    *(_DWORD *)(a1 + 52) = v135;
    *(_DWORD *)(a1 + 56) = v136;
    *(_DWORD *)(a1 + 60) = v137;
    v138 = v134 ^ dword_1008CBF0[(unsigned __int8)v137] ^ dword_1008BFF0[BYTE1(v137)] ^ dword_1008C3F0[(unsigned __int8)(v137 >> 16)] ^ dword_1008C7F0[v137 >> 24] ^ 8;
    *(_DWORD *)(a1 + 64) = v138;
    v139 = v138 ^ v135;
    *(_DWORD *)(a1 + 68) = v139;
    v140 = v139 ^ v136;
    *(_DWORD *)(a1 + 72) = v140;
    v141 = v140 ^ v137;
    *(_DWORD *)(a1 + 76) = v141;
    v142 = v138 ^ dword_1008CBF0[(unsigned __int8)v141] ^ dword_1008BFF0[BYTE1(v141)] ^ dword_1008C3F0[(unsigned __int8)(v141 >> 16)] ^ dword_1008C7F0[v141 >> 24] ^ 0x10;
    v143 = v142 ^ v139;
    v144 = v143 ^ v140;
    v145 = v144 ^ v141;
    *(_DWORD *)(a1 + 80) = v142;
    *(_DWORD *)(a1 + 84) = v143;
    *(_DWORD *)(a1 + 88) = v144;
    *(_DWORD *)(a1 + 92) = v145;
    v146 = v142 ^ dword_1008CBF0[(unsigned __int8)v145] ^ dword_1008BFF0[BYTE1(v145)] ^ dword_1008C3F0[(unsigned __int8)(v145 >> 16)] ^ dword_1008C7F0[v145 >> 24] ^ 0x20;
    v147 = v146 ^ v143;
    v148 = v147 ^ v144;
    v149 = v148 ^ v145;
    *(_DWORD *)(a1 + 100) = v147;
    *(_DWORD *)(a1 + 104) = v148;
    *(_DWORD *)(a1 + 108) = v149;
    *(_DWORD *)(a1 + 96) = v146;
    v150 = v146 ^ dword_1008CBF0[(unsigned __int8)v149] ^ dword_1008BFF0[BYTE1(v149)] ^ dword_1008C3F0[(unsigned __int8)(v149 >> 16)] ^ dword_1008C7F0[v149 >> 24] ^ 0x40;
    v151 = v150 ^ v147;
    v152 = v151 ^ v148;
    v153 = v152 ^ v149;
    *(_DWORD *)(a1 + 112) = v150;
    *(_DWORD *)(a1 + 116) = v151;
    *(_DWORD *)(a1 + 120) = v152;
    *(_DWORD *)(a1 + 124) = v153;
    v154 = v150 ^ dword_1008CBF0[(unsigned __int8)v153] ^ dword_1008BFF0[BYTE1(v153)] ^ dword_1008C3F0[(unsigned __int8)(v153 >> 16)] ^ dword_1008C7F0[v153 >> 24] ^ 0x80;
    v155 = v154 ^ v151;
    *(_DWORD *)(a1 + 128) = v154;
    *(_DWORD *)(a1 + 132) = v155;
    v156 = v155 ^ v152;
    *(_DWORD *)(a1 + 136) = v156;
    v157 = v156 ^ v153;
    *(_DWORD *)(a1 + 140) = v157;
    v158 = v154 ^ dword_1008CBF0[(unsigned __int8)v157] ^ dword_1008BFF0[BYTE1(v157)] ^ dword_1008C3F0[(unsigned __int8)(v157 >> 16)] ^ dword_1008C7F0[v157 >> 24] ^ 0x1B;
    v159 = v158 ^ v155;
    v160 = v159 ^ v156;
    v161 = v160 ^ v157;
    *(_DWORD *)(a1 + 148) = v159;
    *(_DWORD *)(a1 + 152) = v160;
    *(_DWORD *)(a1 + 144) = v158;
    *(_DWORD *)(a1 + 156) = v161;
    v162 = dword_1008CBF0[(unsigned __int8)v161] ^ dword_1008BFF0[BYTE1(v161)] ^ dword_1008C3F0[(unsigned __int8)(v161 >> 16)] ^ dword_1008C7F0[v161 >> 24];
    *(_DWORD *)(a1 + 256) = 10;
    v163 = v158 ^ v162 ^ 0x36;
    v164 = v163 ^ v159;
    v165 = v164 ^ v160;
    *(_DWORD *)(a1 + 168) = v165;
    *(_DWORD *)(a1 + 164) = v164;
    *(_DWORD *)(a1 + 160) = v163;
    *(_DWORD *)(a1 + 172) = v165 ^ v161;
    result = 1;
  }
  else
  {
    HIBYTE(v10) = *(_BYTE *)(a2 + 19);
    LOBYTE(v10) = *(_BYTE *)(a2 + 18);
    v11 = v10 << 8;
    v12 = *(_BYTE *)(a2 + 17);
    if ( a3 == 24 )
    {
      v75 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v75;
      v76 = v75;
      BYTE1(v75) = *(_BYTE *)(a2 + 23);
      LOBYTE(v75) = *(_BYTE *)(a2 + 22);
      v77 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v75 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v77;
      v78 = v166 ^ dword_1008CBF0[(unsigned __int8)v77] ^ dword_1008BFF0[BYTE1(v77)] ^ dword_1008C3F0[(unsigned __int8)(v77 >> 16)] ^ dword_1008C7F0[v77 >> 24] ^ 1;
      v79 = v78 ^ v7;
      v80 = v79 ^ v8;
      v81 = v80 ^ v9;
      *(_DWORD *)(a1 + 40) = v81 ^ v76;
      v82 = v81 ^ v76 ^ v77;
      v83 = v81 ^ v76;
      *(_DWORD *)(a1 + 36) = v81;
      *(_DWORD *)(a1 + 24) = v78;
      *(_DWORD *)(a1 + 28) = v79;
      *(_DWORD *)(a1 + 32) = v80;
      *(_DWORD *)(a1 + 44) = v82;
      v84 = v78 ^ dword_1008CBF0[(unsigned __int8)v82] ^ dword_1008BFF0[BYTE1(v82)] ^ dword_1008C3F0[(unsigned __int8)(v82 >> 16)] ^ dword_1008C7F0[v82 >> 24] ^ 2;
      v85 = v84 ^ v79;
      v86 = v85 ^ v80;
      v87 = v86 ^ v81;
      v89 = v87 ^ v83 ^ v82;
      v88 = v87 ^ v83;
      *(_DWORD *)(a1 + 64) = v87 ^ v83;
      *(_DWORD *)(a1 + 48) = v84;
      *(_DWORD *)(a1 + 52) = v85;
      *(_DWORD *)(a1 + 56) = v86;
      *(_DWORD *)(a1 + 60) = v87;
      *(_DWORD *)(a1 + 68) = v89;
      v90 = v84 ^ dword_1008CBF0[(unsigned __int8)v89] ^ dword_1008BFF0[BYTE1(v89)] ^ dword_1008C3F0[(unsigned __int8)(v89 >> 16)] ^ dword_1008C7F0[v89 >> 24] ^ 4;
      v91 = v90 ^ v85;
      v92 = v91 ^ v86;
      v93 = v92 ^ v87;
      *(_DWORD *)(a1 + 88) = v93 ^ v88;
      v94 = v93 ^ v88 ^ v89;
      v95 = v93 ^ v88;
      *(_DWORD *)(a1 + 84) = v93;
      *(_DWORD *)(a1 + 72) = v90;
      *(_DWORD *)(a1 + 76) = v91;
      *(_DWORD *)(a1 + 80) = v92;
      *(_DWORD *)(a1 + 92) = v94;
      v96 = v90 ^ dword_1008CBF0[(unsigned __int8)v94] ^ dword_1008BFF0[BYTE1(v94)] ^ dword_1008C3F0[(unsigned __int8)(v94 >> 16)] ^ dword_1008C7F0[v94 >> 24] ^ 8;
      v97 = v96 ^ v91;
      v98 = v97 ^ v92;
      v99 = v98 ^ v93;
      *(_DWORD *)(a1 + 112) = v99 ^ v95;
      v100 = v99 ^ v95 ^ v94;
      v101 = v99 ^ v95;
      *(_DWORD *)(a1 + 108) = v99;
      v102 = v96;
      *(_DWORD *)(a1 + 96) = v96;
      *(_DWORD *)(a1 + 100) = v97;
      *(_DWORD *)(a1 + 104) = v98;
      *(_DWORD *)(a1 + 116) = v100;
      v103 = v96 ^ dword_1008CBF0[(unsigned __int8)v100] ^ dword_1008BFF0[BYTE1(v100)] ^ dword_1008C3F0[(unsigned __int8)(v100 >> 16)] ^ dword_1008C7F0[v100 >> 24] ^ 0x10;
      v104 = v103 ^ v97;
      v105 = v104 ^ v98;
      v106 = v102 ^ dword_1008CBF0[(unsigned __int8)v100] ^ dword_1008BFF0[BYTE1(v100)] ^ dword_1008C3F0[(unsigned __int8)(v100 >> 16)] ^ dword_1008C7F0[v100 >> 24] ^ 0x10;
      *(_DWORD *)(a1 + 120) = v103;
      *(_DWORD *)(a1 + 124) = v104;
      *(_DWORD *)(a1 + 128) = v105;
      v107 = v105 ^ v99;
      *(_DWORD *)(a1 + 136) = v107 ^ v101;
      v108 = v107 ^ v101 ^ v100;
      v109 = v107 ^ v101;
      *(_DWORD *)(a1 + 132) = v107;
      *(_DWORD *)(a1 + 140) = v108;
      v110 = v106 ^ dword_1008CBF0[(unsigned __int8)v108] ^ dword_1008BFF0[BYTE1(v108)] ^ dword_1008C3F0[(unsigned __int8)(v108 >> 16)] ^ dword_1008C7F0[v108 >> 24] ^ 0x20;
      v111 = v110 ^ v104;
      v112 = v111 ^ v105;
      v113 = v112 ^ v107;
      *(_DWORD *)(a1 + 160) = v113 ^ v109;
      v114 = v113 ^ v109 ^ v108;
      v115 = v113 ^ v109;
      *(_DWORD *)(a1 + 156) = v113;
      *(_DWORD *)(a1 + 144) = v110;
      *(_DWORD *)(a1 + 148) = v111;
      *(_DWORD *)(a1 + 152) = v112;
      *(_DWORD *)(a1 + 164) = v114;
      v116 = v110 ^ dword_1008CBF0[(unsigned __int8)v114] ^ dword_1008BFF0[BYTE1(v114)] ^ dword_1008C3F0[(unsigned __int8)(v114 >> 16)] ^ dword_1008C7F0[v114 >> 24] ^ 0x40;
      v117 = v116 ^ v111;
      v118 = v117 ^ v112;
      v119 = v118 ^ v113;
      v120 = v119 ^ v115 ^ v114;
      *(_DWORD *)(a1 + 180) = v119;
      *(_DWORD *)(a1 + 184) = v119 ^ v115;
      v121 = v116;
      *(_DWORD *)(a1 + 168) = v116;
      *(_DWORD *)(a1 + 172) = v117;
      *(_DWORD *)(a1 + 176) = v118;
      *(_DWORD *)(a1 + 188) = v120;
      v122 = dword_1008CBF0[(unsigned __int8)v120] ^ dword_1008BFF0[BYTE1(v120)] ^ dword_1008C3F0[(unsigned __int8)(v120 >> 16)] ^ dword_1008C7F0[v120 >> 24];
      *(_DWORD *)(a1 + 256) = 12;
      v123 = v121 ^ v122 ^ 0x80;
      v124 = v123 ^ v117;
      v125 = v124 ^ v118;
      *(_DWORD *)(a1 + 200) = v125;
      *(_DWORD *)(a1 + 196) = v124;
      *(_DWORD *)(a1 + 192) = v123;
      *(_DWORD *)(a1 + 204) = v125 ^ v119;
      result = 1;
    }
    else
    {
      v13 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v13;
      v14 = v13;
      BYTE1(v13) = *(_BYTE *)(a2 + 23);
      LOBYTE(v13) = *(_BYTE *)(a2 + 22);
      v15 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v13 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v15;
      v16 = v15;
      BYTE1(v15) = *(_BYTE *)(a2 + 27);
      LOBYTE(v15) = *(_BYTE *)(a2 + 26);
      v17 = *(_BYTE *)(a2 + 24) | ((*(_BYTE *)(a2 + 25) | ((unsigned __int16)v15 << 8)) << 8);
      *(_DWORD *)(a1 + 24) = v17;
      v18 = v17;
      BYTE1(v17) = *(_BYTE *)(a2 + 31);
      LOBYTE(v17) = *(_BYTE *)(a2 + 30);
      v19 = *(_BYTE *)(a2 + 28) | ((*(_BYTE *)(a2 + 29) | ((unsigned __int16)v17 << 8)) << 8);
      *(_DWORD *)(a1 + 28) = v19;
      v20 = v166 ^ dword_1008CBF0[(unsigned __int8)v19] ^ dword_1008BFF0[BYTE1(v19)] ^ dword_1008C3F0[(unsigned __int8)(v19 >> 16)] ^ dword_1008C7F0[v19 >> 24] ^ 1;
      v21 = v20 ^ v7;
      v22 = v21 ^ v8;
      v23 = v22 ^ v9;
      *(_DWORD *)(a1 + 32) = v20;
      *(_DWORD *)(a1 + 36) = v21;
      *(_DWORD *)(a1 + 40) = v22;
      *(_DWORD *)(a1 + 44) = v23;
      v24 = dword_1008BFF0[(unsigned __int8)v23] ^ dword_1008C3F0[BYTE1(v23)] ^ dword_1008C7F0[(unsigned __int8)(v23 >> 16)] ^ dword_1008CBF0[v23 >> 24] ^ v14;
      *(_DWORD *)(a1 + 48) = v24;
      v25 = v24 ^ v16 ^ v18;
      v26 = v25 ^ v19;
      *(_DWORD *)(a1 + 56) = v25;
      v27 = v24 ^ v16 ^ v18;
      *(_DWORD *)(a1 + 52) = v24 ^ v16;
      *(_DWORD *)(a1 + 60) = v26;
      v28 = v20 ^ dword_1008CBF0[(unsigned __int8)v26] ^ dword_1008BFF0[BYTE1(v26)] ^ dword_1008C3F0[(unsigned __int8)(v26 >> 16)] ^ dword_1008C7F0[v26 >> 24] ^ 2;
      v29 = v28 ^ v21;
      *(_DWORD *)(a1 + 64) = v28;
      v30 = v29 ^ v22;
      v31 = v30 ^ v23;
      *(_DWORD *)(a1 + 76) = v31;
      v32 = v28;
      *(_DWORD *)(a1 + 68) = v29;
      *(_DWORD *)(a1 + 72) = v30;
      v33 = dword_1008BFF0[(unsigned __int8)v31] ^ dword_1008C3F0[BYTE1(v31)] ^ dword_1008C7F0[(unsigned __int8)(v31 >> 16)] ^ dword_1008CBF0[v31 >> 24] ^ v24;
      v34 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 80) = v33;
      *(_DWORD *)(a1 + 88) = v34 ^ v27;
      v35 = v34 ^ v27 ^ v26;
      v36 = v34 ^ v27;
      v37 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 84) = v34;
      *(_DWORD *)(a1 + 92) = v35;
      v38 = v32 ^ dword_1008CBF0[(unsigned __int8)v35] ^ dword_1008BFF0[BYTE1(v35)] ^ dword_1008C3F0[(unsigned __int8)(v35 >> 16)] ^ dword_1008C7F0[v35 >> 24] ^ 4;
      v39 = v38 ^ v29;
      *(_DWORD *)(a1 + 96) = v38;
      *(_DWORD *)(a1 + 100) = v39;
      v40 = v39 ^ v30;
      v41 = v40 ^ v31;
      *(_DWORD *)(a1 + 108) = v41;
      *(_DWORD *)(a1 + 104) = v40;
      v42 = dword_1008BFF0[(unsigned __int8)v41] ^ dword_1008C3F0[BYTE1(v41)] ^ dword_1008C7F0[(unsigned __int8)(v41 >> 16)] ^ dword_1008CBF0[v41 >> 24] ^ v33;
      *(_DWORD *)(a1 + 112) = v42;
      v43 = v42 ^ v37 ^ v36 ^ v35;
      *(_DWORD *)(a1 + 120) = v42 ^ v37 ^ v36;
      *(_DWORD *)(a1 + 116) = v42 ^ v37;
      *(_DWORD *)(a1 + 124) = v43;
      v44 = v38 ^ dword_1008CBF0[(unsigned __int8)v43] ^ dword_1008BFF0[BYTE1(v43)] ^ dword_1008C3F0[(unsigned __int8)(v43 >> 16)] ^ dword_1008C7F0[v43 >> 24] ^ 8;
      v45 = v44 ^ v39;
      v46 = v45 ^ v40;
      v47 = v46 ^ v41;
      *(_DWORD *)(a1 + 128) = v44;
      *(_DWORD *)(a1 + 132) = v45;
      *(_DWORD *)(a1 + 136) = v46;
      *(_DWORD *)(a1 + 140) = v47;
      v48 = v44;
      v49 = dword_1008BFF0[(unsigned __int8)v47] ^ dword_1008C3F0[BYTE1(v47)] ^ dword_1008C7F0[(unsigned __int8)(v47 >> 16)] ^ dword_1008CBF0[v47 >> 24] ^ v42;
      *(_DWORD *)(a1 + 144) = v49;
      v50 = v49 ^ v42 ^ v37;
      v51 = v50 ^ v42 ^ v37 ^ v36;
      v52 = v51 ^ v43;
      *(_DWORD *)(a1 + 152) = v51;
      v53 = v51;
      *(_DWORD *)(a1 + 148) = v50;
      v54 = v50;
      *(_DWORD *)(a1 + 156) = v52;
      v55 = v48 ^ dword_1008CBF0[(unsigned __int8)v52] ^ dword_1008BFF0[BYTE1(v52)] ^ dword_1008C3F0[(unsigned __int8)(v52 >> 16)] ^ dword_1008C7F0[v52 >> 24] ^ 0x10;
      v56 = v55 ^ v45;
      *(_DWORD *)(a1 + 160) = v55;
      v57 = v56 ^ v46;
      v58 = v57 ^ v47;
      *(_DWORD *)(a1 + 172) = v58;
      *(_DWORD *)(a1 + 164) = v56;
      *(_DWORD *)(a1 + 168) = v57;
      v59 = dword_1008BFF0[(unsigned __int8)v58] ^ dword_1008C3F0[BYTE1(v58)] ^ dword_1008C7F0[(unsigned __int8)(v58 >> 16)] ^ dword_1008CBF0[v58 >> 24] ^ v49;
      *(_DWORD *)(a1 + 176) = v59;
      *(_DWORD *)(a1 + 184) = v59 ^ v54 ^ v53;
      v60 = v59 ^ v54 ^ v53 ^ v52;
      v61 = v59 ^ v54 ^ v53;
      v62 = v59 ^ v54;
      *(_DWORD *)(a1 + 180) = v62;
      *(_DWORD *)(a1 + 188) = v60;
      v63 = v55 ^ dword_1008CBF0[(unsigned __int8)v60] ^ dword_1008BFF0[BYTE1(v60)] ^ dword_1008C3F0[(unsigned __int8)(v60 >> 16)] ^ dword_1008C7F0[v60 >> 24] ^ 0x20;
      v64 = v63 ^ v56;
      *(_DWORD *)(a1 + 192) = v63;
      v65 = v64 ^ v57;
      v66 = v65 ^ v58;
      *(_DWORD *)(a1 + 204) = v66;
      v67 = v63;
      *(_DWORD *)(a1 + 196) = v64;
      *(_DWORD *)(a1 + 200) = v65;
      v68 = dword_1008BFF0[(unsigned __int8)v66] ^ dword_1008C3F0[BYTE1(v66)] ^ dword_1008C7F0[(unsigned __int8)(v66 >> 16)] ^ dword_1008CBF0[v66 >> 24] ^ v59;
      *(_DWORD *)(a1 + 208) = v68;
      *(_DWORD *)(a1 + 216) = v68 ^ v62 ^ v61;
      v69 = v68 ^ v62 ^ v61 ^ v60;
      *(_DWORD *)(a1 + 212) = v68 ^ v62;
      *(_DWORD *)(a1 + 220) = v69;
      v70 = dword_1008CBF0[(unsigned __int8)v69] ^ dword_1008BFF0[BYTE1(v69)] ^ dword_1008C3F0[(unsigned __int8)(v69 >> 16)] ^ dword_1008C7F0[v69 >> 24];
      *(_DWORD *)(a1 + 256) = 14;
      v71 = v67 ^ v70 ^ 0x40;
      v72 = v71 ^ v64;
      v73 = v72 ^ v65;
      *(_DWORD *)(a1 + 232) = v73;
      *(_DWORD *)(a1 + 228) = v72;
      *(_DWORD *)(a1 + 224) = v71;
      *(_DWORD *)(a1 + 236) = v73 ^ v66;
      result = 1;
    }
  }
  return result;
}
// 1008BFF0: using guessed type int dword_1008BFF0[];
// 1008C3F0: using guessed type int dword_1008C3F0[];
// 1008C7F0: using guessed type int dword_1008C7F0[];
// 1008CBF0: using guessed type int dword_1008CBF0[];

//----- (10025680) --------------------------------------------------------
void *__usercall sub_10025680@<eax>(void *a1@<eax>)
{
  return memset(a1, 0, 0xA0u);
}

//----- (100256A0) --------------------------------------------------------
unsigned int __cdecl sub_100256A0(int a1, unsigned int a2)
{
  int v2; // eax@1
  unsigned int result; // eax@1
  _BYTE *v4; // ecx@3
  char v5; // dl@3
  unsigned __int64 v6; // [sp+Ch] [bp-8h]@1

  v2 = sub_10030040();
  v6 = ((unsigned __int64)(unsigned int)v2 << 32) + (unsigned int)j_TSK_pvg_get_us_timer();
  result = 0;
  do
  {
    if ( result >= a2 )
      break;
    v4 = (_BYTE *)(result + a1);
    v5 = *((_BYTE *)&v6 + result++ + a1 - a1);
    *v4 = v5;
  }
  while ( result < 8 );
  return result;
}
// 100300E0: using guessed type int j_TSK_pvg_get_us_timer(void);

//----- (10025700) --------------------------------------------------------
int __usercall sub_10025700@<eax>(int result@<eax>)
{
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 8) = 1732584193;
  *(_DWORD *)(result + 12) = -271733879;
  *(_DWORD *)(result + 16) = -1732584194;
  *(_DWORD *)(result + 20) = 271733878;
  *(_DWORD *)(result + 24) = -1009589776;
  return result;
}

//----- (10025740) --------------------------------------------------------
int __usercall sub_10025740@<eax>(int result@<eax>)
{
  int v1; // ebx@1
  int v2; // esi@1
  int v3; // edx@1
  unsigned int v4; // ST28_4@1
  int v5; // edx@1
  int v6; // ST18_4@1
  unsigned int v7; // ST2C_4@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // ST14_4@1
  int v12; // ST20_4@1
  unsigned int v13; // ST30_4@1
  int v14; // esi@1
  unsigned int v15; // ST34_4@1
  int v16; // edi@1
  int v17; // edi@1
  int v18; // ecx@1
  int v19; // ST1C_4@1
  int v20; // ebx@1
  unsigned int v21; // ebp@1
  unsigned int v22; // ST38_4@1
  int v23; // edx@1
  int v24; // ST10_4@1
  unsigned int v25; // ST3C_4@1
  int v26; // esi@1
  int v27; // esi@1
  int v28; // ST18_4@1
  int v29; // ebp@1
  unsigned int v30; // ST40_4@1
  int v31; // edi@1
  int v32; // ebx@1
  int v33; // ST14_4@1
  unsigned int v34; // ST44_4@1
  int v35; // edi@1
  int v36; // ST20_4@1
  int v37; // ST1C_4@1
  unsigned int v38; // ST48_4@1
  int v39; // ebx@1
  int v40; // ebx@1
  int v41; // ecx@1
  int v42; // ebp@1
  unsigned int v43; // ST4C_4@1
  int v44; // edx@1
  int v45; // edx@1
  int v46; // ST10_4@1
  int v47; // esi@1
  unsigned int v48; // ST50_4@1
  int v49; // esi@1
  int v50; // ST18_4@1
  unsigned int v51; // ST54_4@1
  int v52; // edi@1
  int v53; // ebx@1
  int v54; // ST14_4@1
  unsigned int v55; // ST58_4@1
  int v56; // edi@1
  int v57; // ST20_4@1
  int v58; // ebx@1
  unsigned int v59; // ST5C_4@1
  int v60; // ebx@1
  int v61; // ecx@1
  int v62; // ST14_4@1
  int v63; // ST1C_4@1
  unsigned int v64; // ST60_4@1
  int v65; // edx@1
  int v66; // edx@1
  int v67; // ST10_4@1
  unsigned int v68; // ST64_4@1
  int v69; // esi@1
  int v70; // esi@1
  int v71; // ST18_4@1
  int v72; // ebp@1
  int v73; // ecx@1
  int v74; // ebx@1
  int v75; // ST68_4@1
  int v76; // edi@1
  int v77; // edi@1
  int v78; // ST14_4@1
  int v79; // ST20_4@1
  int v80; // ecx@1
  int v81; // ST6C_4@1
  int v82; // edi@1
  int v83; // ecx@1
  int v84; // ST70_4@1
  int v85; // ebx@1
  int v86; // ST1C_4@1
  int v87; // ebx@1
  int v88; // ecx@1
  int v89; // ST14_4@1
  int v90; // ecx@1
  int v91; // ST74_4@1
  int v92; // edx@1
  int v93; // edx@1
  int v94; // ST10_4@1
  int v95; // ecx@1
  int v96; // ST78_4@1
  int v97; // esi@1
  int v98; // esi@1
  int v99; // ST18_4@1
  int v100; // ebx@1
  int v101; // ecx@1
  int v102; // edi@1
  int v103; // ST7C_4@1
  int v104; // edi@1
  int v105; // ST20_4@1
  int v106; // ecx@1
  int v107; // ST80_4@1
  int v108; // edx@1
  int v109; // edx@1
  int v110; // ecx@1
  int v111; // ST84_4@1
  int v112; // ebx@1
  int v113; // ebx@1
  int v114; // ST14_4@1
  int v115; // ecx@1
  int v116; // ebp@1
  int v117; // ST88_4@1
  int v118; // edi@1
  int v119; // edi@1
  int v120; // ST10_4@1
  int v121; // ebp@1
  int v122; // ecx@1
  int v123; // ST8C_4@1
  int v124; // edx@1
  int v125; // ebp@1
  int v126; // edx@1
  int v127; // ecx@1
  int v128; // ST18_4@1
  int v129; // ST90_4@1
  int v130; // esi@1
  int v131; // esi@1
  int v132; // ST20_4@1
  int v133; // ecx@1
  int v134; // ST94_4@1
  int v135; // edi@1
  int v136; // edi@1
  int v137; // ecx@1
  int v138; // ST98_4@1
  int v139; // ebx@1
  int v140; // ebx@1
  int v141; // ST14_4@1
  int v142; // ecx@1
  int v143; // ebp@1
  int v144; // ST9C_4@1
  int v145; // esi@1
  int v146; // esi@1
  int v147; // ST10_4@1
  int v148; // ebp@1
  int v149; // ecx@1
  int v150; // STA0_4@1
  int v151; // edi@1
  int v152; // ebp@1
  int v153; // edx@1
  int v154; // ecx@1
  int v155; // ST18_4@1
  int v156; // STA4_4@1
  int v157; // edi@1
  int v158; // edi@1
  int v159; // ST20_4@1
  int v160; // ecx@1
  int v161; // STA8_4@1
  int v162; // esi@1
  int v163; // esi@1
  int v164; // ecx@1
  int v165; // STAC_4@1
  int v166; // ebx@1
  int v167; // ebx@1
  int v168; // ST14_4@1
  int v169; // ecx@1
  int v170; // ebp@1
  int v171; // STB0_4@1
  int v172; // edi@1
  int v173; // edi@1
  int v174; // ST10_4@1
  int v175; // ebp@1
  int v176; // ecx@1
  int v177; // STB4_4@1
  int v178; // esi@1
  int v179; // ebp@1
  int v180; // edx@1
  int v181; // ST18_4@1
  int v182; // ecx@1
  int v183; // STB8_4@1
  int v184; // esi@1
  int v185; // ebx@1
  int v186; // ST20_4@1
  int v187; // esi@1
  int v188; // ecx@1
  int v189; // STBC_4@1
  int v190; // edi@1
  int v191; // edi@1
  int v192; // ST1C_4@1
  int v193; // ecx@1
  int v194; // ebp@1
  int v195; // STC0_4@1
  int v196; // edx@1
  int v197; // ecx@1
  int v198; // esi@1
  int v199; // STC4_4@1
  int v200; // ebp@1
  int v201; // esi@1
  int v202; // ST10_4@1
  int v203; // ecx@1
  int v204; // ebp@1
  int v205; // edi@1
  int v206; // STC8_4@1
  int v207; // ST1C_4@1
  int v208; // ecx@1
  int v209; // STCC_4@1
  int v210; // ebx@1
  int v211; // ST18_4@1
  int v212; // ecx@1
  int v213; // STD0_4@1
  int v214; // edx@1
  int v215; // edi@1
  int v216; // ebx@1
  int v217; // ecx@1
  int v218; // edx@1
  int v219; // ebx@1
  int v220; // ecx@1
  int v221; // ST1C_4@1
  int v222; // ebp@1
  int v223; // STD4_4@1
  int v224; // ST10_4@1
  int v225; // edx@1
  int v226; // ecx@1
  int v227; // ST14_4@1
  int v228; // STD8_4@1
  int v229; // ebp@1
  int v230; // ebx@1
  int v231; // ecx@1
  int v232; // esi@1
  int v233; // ST10_4@1
  int v234; // ecx@1
  int v235; // STDC_4@1
  int v236; // edi@1
  int v237; // ebx@1
  int v238; // ecx@1
  int v239; // edi@1
  int v240; // STE0_4@1
  int v241; // ebx@1
  int v242; // ST18_4@1
  int v243; // ST1C_4@1
  int v244; // ecx@1
  int v245; // edx@1
  int v246; // STE4_4@1
  int v247; // edi@1
  int v248; // ebx@1
  int v249; // ecx@1
  int v250; // edx@1
  int v251; // ebx@1
  int v252; // ecx@1
  int v253; // ST1C_4@1
  int v254; // ebp@1
  int v255; // STE8_4@1
  int v256; // ST10_4@1
  int v257; // edx@1
  int v258; // ecx@1
  int v259; // ebx@1
  int v260; // ST14_4@1
  int v261; // STEC_4@1
  int v262; // ebp@1
  int v263; // ecx@1
  int v264; // esi@1
  int v265; // ST10_4@1
  int v266; // ecx@1
  int v267; // edi@1
  int v268; // STF0_4@1
  int v269; // ebx@1
  int v270; // edi@1
  int v271; // ecx@1
  int v272; // ebx@1
  int v273; // STF4_4@1
  int v274; // ST1C_4@1
  int v275; // ST18_4@1
  int v276; // ecx@1
  int v277; // edx@1
  int v278; // edi@1
  int v279; // STF8_4@1
  int v280; // ebx@1
  int v281; // ecx@1
  int v282; // edx@1
  int v283; // ST1C_4@1
  int v284; // ecx@1
  int v285; // ST10_4@1
  int v286; // STFC_4@1
  int v287; // ebp@1
  int v288; // edx@1
  int v289; // ecx@1
  int v290; // ST100_4@1
  int v291; // ST14_4@1
  int v292; // ebp@1
  int v293; // ebx@1
  int v294; // ecx@1
  int v295; // esi@1
  int v296; // ST10_4@1
  int v297; // ecx@1
  int v298; // edi@1
  int v299; // ST104_4@1
  int v300; // ebx@1
  int v301; // edi@1
  int v302; // ecx@1
  int v303; // ebx@1
  int v304; // ST108_4@1
  int v305; // ST1C_4@1
  int v306; // ST18_4@1
  int v307; // ecx@1
  int v308; // edi@1
  int v309; // ST10C_4@1
  int v310; // ebx@1
  int v311; // edx@1
  int v312; // ecx@1
  int v313; // ST1C_4@1
  int v314; // ecx@1
  int v315; // ST110_4@1
  int v316; // ebp@1
  int v317; // ebx@1
  int v318; // edx@1
  int v319; // ecx@1
  int v320; // ST114_4@1
  int v321; // ST14_4@1
  int v322; // ebp@1
  int v323; // edi@1
  int v324; // ecx@1
  int v325; // edx@1
  int v326; // ebp@1
  int v327; // ST118_4@1
  int v328; // esi@1
  int v329; // ST10_4@1
  int v330; // ecx@1
  int v331; // ST18_4@1
  int v332; // ST11C_4@1
  int v333; // ebx@1
  int v334; // esi@1
  int v335; // edi@1
  int v336; // edi@1
  int v337; // ST20_4@1
  int v338; // ebx@1
  int v339; // ecx@1
  int v340; // edx@1
  int v341; // ST120_4@1
  int v342; // edx@1
  int v343; // ecx@1
  int v344; // ST124_4@1
  int v345; // ebx@1
  int v346; // ebx@1
  int v347; // ecx@1
  int v348; // ST14_4@1
  int v349; // ST128_4@1
  int v350; // ebp@1
  int v351; // edi@1
  int v352; // edi@1
  int v353; // ecx@1
  int v354; // ST10_4@1
  int v355; // ST12C_4@1
  int v356; // ebp@1
  int v357; // edx@1
  int v358; // ST18_4@1
  int v359; // ecx@1
  int v360; // ST130_4@1
  int v361; // edx@1
  int v362; // esi@1
  int v363; // esi@1
  int v364; // ST20_4@1
  int v365; // ecx@1
  int v366; // ebx@1
  int v367; // edi@1
  int v368; // ST134_4@1
  int v369; // edi@1
  int v370; // ecx@1
  int v371; // ebp@1
  int v372; // ST138_4@1
  int v373; // ebx@1
  int v374; // ebx@1
  int v375; // ecx@1
  int v376; // ST14_4@1
  int v377; // ST13C_4@1
  int v378; // ebp@1
  int v379; // esi@1
  int v380; // esi@1
  int v381; // ecx@1
  int v382; // ST10_4@1
  int v383; // ST140_4@1
  int v384; // ebp@1
  int v385; // edi@1
  int v386; // edi@1
  int v387; // ecx@1
  int v388; // ebp@1
  int v389; // edx@1
  int v390; // ST18_4@1
  int v391; // ebx@1
  int v392; // ST20_4@1
  int v393; // edx@1
  int v394; // ST14_4@1
  int v395; // esi@1
  int v396; // ST148_4@1
  int v397; // ST10_4@1
  int v398; // ST1C_4@1
  int v399; // edx@1
  int v400; // ebx@1
  int v401; // ST14C_4@1
  int v402; // esi@1
  int v403; // ebx@1
  int v404; // ST18_4@1
  int v405; // ST14_4@1
  int v406; // edx@1
  int v407; // edi@1
  int v408; // esi@1
  int v409; // ebx@1
  int v410; // ST20_4@1
  int v411; // esi@1
  int v412; // ST10_4@1
  int v413; // ebx@1
  int v414; // edi@1
  int v415; // ebp@1
  int v416; // edi@1
  int v417; // ST24_4@1
  int v418; // ST1C_4@1
  int v419; // edi@1
  int v420; // ebx@1
  int v421; // ST20_4@1
  int v422; // edx@1
  int v423; // ebx@1
  int v424; // edx@1
  int v425; // ebx@1
  int v426; // ST1C_4@1
  int v427; // esi@1
  int v428; // ebx@1
  int v429; // esi@1
  int v430; // ecx@1
  int v431; // ebx@1
  int v432; // ebx@1
  int v433; // edx@1
  int v434; // ecx@1

  v1 = *(_DWORD *)(result + 8);
  v2 = *(_DWORD *)(result + 12);
  v3 = __ROL4__(*(_DWORD *)(result + 8), 5);
  v4 = ((*(_DWORD *)(result + 28) & 0xFF00 | (*(_DWORD *)(result + 28) << 16)) << 8) | (((*(_DWORD *)(result + 28) >> 16) | *(_DWORD *)(result + 28) & 0xFF0000u) >> 8);
  v5 = v4
     + *(_DWORD *)(result + 24)
     + v3
     + (v2 & *(_DWORD *)(result + 16) ^ *(_DWORD *)(result + 20) & ~*(_DWORD *)(result + 12))
     + 1518500249;
  v2 = __ROR4__(v2, 2);
  v6 = v2;
  v7 = ((*(_DWORD *)(result + 32) & 0xFF00 | (*(_DWORD *)(result + 32) << 16)) << 8) | (((*(_DWORD *)(result + 32) >> 16) | *(_DWORD *)(result + 32) & 0xFF0000u) >> 8);
  v8 = v1 & v2 ^ *(_DWORD *)(result + 16) & ~v1;
  v9 = __ROL4__(v5, 5);
  v10 = *(_DWORD *)(result + 20) + v7 + v9 + v8 + 1518500249;
  v1 = __ROR4__(v1, 2);
  v11 = v10;
  v10 = __ROL4__(v10, 5);
  v12 = v1;
  v13 = ((*(_DWORD *)(result + 36) & 0xFF00 | (*(_DWORD *)(result + 36) << 16)) << 8) | (((*(_DWORD *)(result + 36) >> 16) | *(_DWORD *)(result + 36) & 0xFF0000u) >> 8);
  v14 = *(_DWORD *)(result + 16) + v13 + v10 + (v1 & v5 ^ v6 & ~v5) + 1518500249;
  v5 = __ROR4__(v5, 2);
  v15 = ((*(_DWORD *)(result + 40) & 0xFF00 | (*(_DWORD *)(result + 40) << 16)) << 8) | (((*(_DWORD *)(result + 40) >> 16) | *(_DWORD *)(result + 40) & 0xFF0000u) >> 8);
  v16 = __ROL4__(v14, 5);
  v17 = v6 + v15 + v16 + (v11 & v5 ^ v1 & ~v11) + 1518500249;
  v18 = __ROR4__(v11, 2);
  v19 = v5;
  v20 = __ROL4__(v17, 5);
  v21 = (((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8))
      + v20
      + (v14 & v18 ^ v5 & ~v14);
  v22 = ((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8);
  v14 = __ROR4__(v14, 2);
  v23 = v12 + v21 + 1518500249;
  v24 = v14;
  v25 = ((*(_DWORD *)(result + 48) & 0xFF00 | (*(_DWORD *)(result + 48) << 16)) << 8) | (((*(_DWORD *)(result + 48) >> 16) | *(_DWORD *)(result + 48) & 0xFF0000u) >> 8);
  v26 = __ROL4__(v23, 5);
  v27 = v19 + v25 + v26 + (v17 & v24 ^ v18 & ~v17) + 1518500249;
  v17 = __ROR4__(v17, 2);
  v28 = v17;
  v29 = v23 & v17;
  v30 = ((*(_DWORD *)(result + 52) & 0xFF00 | (*(_DWORD *)(result + 52) << 16)) << 8) | (((*(_DWORD *)(result + 52) >> 16) | *(_DWORD *)(result + 52) & 0xFF0000u) >> 8);
  v31 = __ROL4__(v27, 5);
  v32 = v18 + v30 + v31 + (v29 ^ v24 & ~v23) + 1518500249;
  v23 = __ROR4__(v23, 2);
  v33 = v32;
  v32 = __ROL4__(v32, 5);
  v34 = ((*(_DWORD *)(result + 56) & 0xFF00 | (*(_DWORD *)(result + 56) << 16)) << 8) | (((*(_DWORD *)(result + 56) >> 16) | *(_DWORD *)(result + 56) & 0xFF0000u) >> 8);
  v35 = v24 + v34 + v32 + (v23 & v27 ^ v28 & ~v27) + 1518500249;
  v27 = __ROR4__(v27, 2);
  v36 = v23;
  v37 = v27;
  v38 = ((*(_DWORD *)(result + 60) & 0xFF00 | (*(_DWORD *)(result + 60) << 16)) << 8) | (((*(_DWORD *)(result + 60) >> 16) | *(_DWORD *)(result + 60) & 0xFF0000u) >> 8);
  v39 = __ROL4__(v35, 5);
  v40 = v28 + v38 + v39 + (v33 & v27 ^ v23 & ~v33) + 1518500249;
  v41 = __ROR4__(v33, 2);
  v42 = v35 & v41 ^ v27 & ~v35;
  v43 = ((*(_DWORD *)(result + 64) & 0xFF00 | (*(_DWORD *)(result + 64) << 16)) << 8) | (((*(_DWORD *)(result + 64) >> 16) | *(_DWORD *)(result + 64) & 0xFF0000u) >> 8);
  v44 = __ROL4__(v40, 5);
  v35 = __ROR4__(v35, 2);
  v45 = v36 + v43 + v44 + v42 + 1518500249;
  v46 = v35;
  v47 = __ROL4__(v45, 5);
  v48 = ((*(_DWORD *)(result + 68) & 0xFF00 | (*(_DWORD *)(result + 68) << 16)) << 8) | (((*(_DWORD *)(result + 68) >> 16) | *(_DWORD *)(result + 68) & 0xFF0000u) >> 8);
  v49 = v37 + v48 + v47 + (v40 & v35 ^ v41 & ~v40) + 1518500249;
  v40 = __ROR4__(v40, 2);
  v50 = v40;
  v51 = ((*(_DWORD *)(result + 72) & 0xFF00 | (*(_DWORD *)(result + 72) << 16)) << 8) | (((*(_DWORD *)(result + 72) >> 16) | *(_DWORD *)(result + 72) & 0xFF0000u) >> 8);
  v52 = __ROL4__(v49, 5);
  v53 = v41 + v51 + v52 + (v45 & v40 ^ v46 & ~v45) + 1518500249;
  v54 = v53;
  v45 = __ROR4__(v45, 2);
  v53 = __ROL4__(v53, 5);
  v55 = ((*(_DWORD *)(result + 76) & 0xFF00 | (*(_DWORD *)(result + 76) << 16)) << 8) | (((*(_DWORD *)(result + 76) >> 16) | *(_DWORD *)(result + 76) & 0xFF0000u) >> 8);
  v56 = v46 + v55 + v53 + (v45 & v49 ^ v50 & ~v49) + 1518500249;
  v49 = __ROR4__(v49, 2);
  v57 = v45;
  v58 = __ROL4__(v56, 5);
  v59 = ((*(_DWORD *)(result + 80) & 0xFF00 | (*(_DWORD *)(result + 80) << 16)) << 8) | (((*(_DWORD *)(result + 80) >> 16) | *(_DWORD *)(result + 80) & 0xFF0000u) >> 8);
  v60 = v50 + v59 + v58 + (v54 & v49 ^ v45 & ~v54) + 1518500249;
  v61 = __ROR4__(v54, 2);
  v62 = v61;
  v63 = v49;
  v64 = ((*(_DWORD *)(result + 84) & 0xFF00 | (*(_DWORD *)(result + 84) << 16)) << 8) | (((*(_DWORD *)(result + 84) >> 16) | *(_DWORD *)(result + 84) & 0xFF0000u) >> 8);
  v65 = __ROL4__(v60, 5);
  v66 = v57 + v64 + v65 + (v56 & v61 ^ v49 & ~v56) + 1518500249;
  v56 = __ROR4__(v56, 2);
  v67 = v56;
  v68 = ((*(_DWORD *)(result + 88) & 0xFF00 | (*(_DWORD *)(result + 88) << 16)) << 8) | (((*(_DWORD *)(result + 88) >> 16) | *(_DWORD *)(result + 88) & 0xFF0000u) >> 8);
  v69 = __ROL4__(v66, 5);
  v70 = v63 + v68 + v69 + (v60 & v56 ^ v61 & ~v60) + 1518500249;
  v60 = __ROR4__(v60, 2);
  v71 = v60;
  v72 = v60;
  v73 = __ROL4__(v4 ^ v13 ^ v38 ^ v59, 1);
  v74 = v56 & ~v66;
  v75 = v73;
  v76 = __ROL4__(v70, 5);
  v77 = v62 + v73 + v76 + (v66 & v72 ^ v74) + 1518500249;
  v66 = __ROR4__(v66, 2);
  v78 = v77;
  v79 = v66;
  v80 = __ROL4__(v7 ^ v15 ^ v43 ^ v64, 1);
  v81 = v80;
  v77 = __ROL4__(v77, 5);
  v82 = v67 + v80 + v77 + (v66 & v70 ^ v71 & ~v70) + 1518500249;
  v70 = __ROR4__(v70, 2);
  v83 = __ROL4__(v13 ^ v22 ^ v48 ^ v68, 1);
  v84 = v83;
  v85 = __ROL4__(v82, 5);
  v86 = v70;
  v87 = v71 + v83 + v85 + (v78 & v70 ^ v66 & ~v78) + 1518500249;
  v88 = __ROR4__(v78, 2);
  v89 = v88;
  v90 = __ROL4__(v15 ^ v25 ^ v51 ^ v75, 1);
  v91 = v90;
  v92 = __ROL4__(v87, 5);
  v93 = v79 + v90 + v92 + (v82 & v89 ^ v70 & ~v82) + 1518500249;
  v82 = __ROR4__(v82, 2);
  v94 = v82;
  v95 = __ROL4__(v22 ^ v30 ^ v55 ^ v81, 1);
  v96 = v95;
  v97 = __ROL4__(v93, 5);
  v98 = v86 + v95 + v97 + (v87 ^ v82 ^ v89) + 1859775393;
  v87 = __ROR4__(v87, 2);
  v99 = v87;
  v100 = v87 ^ v82;
  v101 = __ROL4__(v25 ^ v34 ^ v59 ^ v84, 1);
  v102 = __ROL4__(v98, 5);
  v103 = v101;
  v104 = v89 + v101 + v102 + (v93 ^ v100) + 1859775393;
  v93 = __ROR4__(v93, 2);
  v105 = v93;
  v106 = __ROL4__(v30 ^ v38 ^ v64 ^ v91, 1);
  v107 = v106;
  v108 = __ROL4__(v104, 5);
  v109 = v94 + v106 + v108 + (v105 ^ v99 ^ v98) + 1859775393;
  v98 = __ROR4__(v98, 2);
  v110 = __ROL4__(v34 ^ v43 ^ v68 ^ v96, 1);
  v111 = v110;
  v112 = __ROL4__(v109, 5);
  v113 = v99 + v110 + v112 + (v105 ^ v104 ^ v98) + 1859775393;
  v104 = __ROR4__(v104, 2);
  v114 = v104;
  v115 = __ROL4__(v38 ^ v48 ^ v75 ^ v103, 1);
  v116 = v109 ^ v104 ^ v98;
  v117 = v115;
  v118 = __ROL4__(v113, 5);
  v119 = v105 + v115 + v118 + v116 + 1859775393;
  v109 = __ROR4__(v109, 2);
  v120 = v109;
  v121 = v109 ^ v114;
  v122 = __ROL4__(v43 ^ v51 ^ v81 ^ v107, 1);
  v123 = v122;
  v124 = __ROL4__(v119, 5);
  v125 = v122 + v124 + (v113 ^ v121);
  v113 = __ROR4__(v113, 2);
  v126 = v98 + v125 + 1859775393;
  v127 = __ROL4__(v48 ^ v55 ^ v84 ^ v111, 1);
  v128 = v113;
  v129 = v127;
  v130 = __ROL4__(v126, 5);
  v131 = v114 + v127 + v130 + (v119 ^ v113 ^ v120) + 1859775393;
  v119 = __ROR4__(v119, 2);
  v132 = v119;
  v133 = __ROL4__(v51 ^ v59 ^ v91 ^ v117, 1);
  v134 = v133;
  v135 = __ROL4__(v131, 5);
  v136 = v120 + v133 + v135 + (v132 ^ v113 ^ v126) + 1859775393;
  v126 = __ROR4__(v126, 2);
  v137 = __ROL4__(v55 ^ v64 ^ v96 ^ v123, 1);
  v138 = v137;
  v139 = __ROL4__(v136, 5);
  v140 = v128 + v137 + v139 + (v132 ^ v131 ^ v126) + 1859775393;
  v131 = __ROR4__(v131, 2);
  v141 = v131;
  v142 = __ROL4__(v59 ^ v68 ^ v103 ^ v129, 1);
  v143 = v136 ^ v131 ^ v126;
  v144 = v142;
  v145 = __ROL4__(v140, 5);
  v146 = v132 + v142 + v145 + v143 + 1859775393;
  v136 = __ROR4__(v136, 2);
  v147 = v136;
  v148 = v136 ^ v141;
  v149 = __ROL4__(v64 ^ v75 ^ v107 ^ v134, 1);
  v150 = v149;
  v151 = __ROL4__(v146, 5);
  v152 = v149 + v151 + (v140 ^ v148);
  v140 = __ROR4__(v140, 2);
  v153 = v126 + v152 + 1859775393;
  v154 = __ROL4__(v68 ^ v81 ^ v111 ^ v138, 1);
  v155 = v140;
  v156 = v154;
  v157 = __ROL4__(v153, 5);
  v158 = v141 + v154 + v157 + (v146 ^ v140 ^ v147) + 1859775393;
  v146 = __ROR4__(v146, 2);
  v159 = v146;
  v160 = __ROL4__(v75 ^ v84 ^ v117 ^ v144, 1);
  v161 = v160;
  v162 = __ROL4__(v158, 5);
  v163 = v147 + v160 + v162 + (v159 ^ v140 ^ v153) + 1859775393;
  v153 = __ROR4__(v153, 2);
  v164 = __ROL4__(v81 ^ v91 ^ v123 ^ v150, 1);
  v165 = v164;
  v166 = __ROL4__(v163, 5);
  v167 = v155 + v164 + v166 + (v159 ^ v158 ^ v153) + 1859775393;
  v158 = __ROR4__(v158, 2);
  v168 = v158;
  v169 = __ROL4__(v84 ^ v96 ^ v129 ^ v156, 1);
  v170 = v163 ^ v158 ^ v153;
  v171 = v169;
  v172 = __ROL4__(v167, 5);
  v173 = v159 + v169 + v172 + v170 + 1859775393;
  v163 = __ROR4__(v163, 2);
  v174 = v163;
  v175 = v163 ^ v168;
  v176 = __ROL4__(v91 ^ v103 ^ v134 ^ v161, 1);
  v177 = v176;
  v178 = __ROL4__(v173, 5);
  v179 = v176 + v178 + (v167 ^ v175);
  v167 = __ROR4__(v167, 2);
  v180 = v153 + v179 + 1859775393;
  v181 = v167;
  v182 = __ROL4__(v96 ^ v107 ^ v138 ^ v165, 1);
  v183 = v182;
  v184 = __ROL4__(v180, 5);
  v185 = v168 + v182 + v184 + (v173 ^ v167 ^ v174) + 1859775393;
  v173 = __ROR4__(v173, 2);
  v186 = v173;
  v187 = v173;
  v188 = __ROL4__(v103 ^ v111 ^ v144 ^ v171, 1);
  v189 = v188;
  v190 = __ROL4__(v185, 5);
  v191 = v174 + v188 + v190 + (v187 ^ v181 ^ v180) + 1859775393;
  v180 = __ROR4__(v180, 2);
  v192 = v180;
  v193 = __ROL4__(v107 ^ v117 ^ v150 ^ v177, 1);
  v194 = __ROL4__(v191, 5);
  v195 = v193;
  v196 = v181 + v193 + v194 + (v187 ^ v185 ^ v180) + 1859775393;
  v185 = __ROR4__(v185, 2);
  v197 = __ROL4__(v111 ^ v123 ^ v156 ^ v183, 1);
  v198 = __ROL4__(v196, 5);
  v199 = v197;
  v200 = v197 + v198 + (v191 ^ v185 ^ v192);
  v191 = __ROR4__(v191, 2);
  v201 = v186 + v200 + 1859775393;
  v202 = v191;
  v203 = __ROL4__(v117 ^ v129 ^ v161 ^ v189, 1);
  v204 = __ROL4__(v201, 5);
  v205 = v192 + v203 + (v196 & v191 ^ v185 & (v196 ^ v191)) + v204 - 1894007588;
  v206 = v203;
  v207 = v205;
  v196 = __ROR4__(v196, 2);
  v208 = __ROL4__(v123 ^ v134 ^ v165 ^ v195, 1);
  v209 = v208;
  v210 = v185 + v208 + (v201 & v196 ^ v202 & (v201 ^ v196));
  v205 = __ROL4__(v205, 5);
  v201 = __ROR4__(v201, 2);
  v211 = v196;
  v212 = __ROL4__(v129 ^ v138 ^ v171 ^ v199, 1);
  v213 = v212;
  v214 = v202 + v212 + (v201 & v196 ^ v207 & (v201 ^ v196));
  v215 = v210 + v205 - 1894007588;
  v216 = __ROL4__(v215, 5);
  v217 = __ROR4__(v207, 2);
  v218 = v214 + v216 - 1894007588;
  v219 = v217;
  v220 = __ROL4__(v134 ^ v144 ^ v177 ^ v206, 1);
  v221 = v219;
  v222 = v211 + v220 + (v201 & v215 ^ v219 & (v201 ^ v215));
  v223 = v220;
  v224 = v218;
  v218 = __ROL4__(v218, 5);
  v215 = __ROR4__(v215, 2);
  v225 = v218 + v222 - 1894007588;
  v226 = __ROL4__(v138 ^ v150 ^ v183 ^ v209, 1);
  v227 = v215;
  v228 = v226;
  v229 = v226 + (v224 & v215 ^ v219 & (v224 ^ v215));
  v230 = __ROL4__(v225, 5);
  v231 = __ROR4__(v224, 2);
  v232 = v230 + v201 + v229 - 1894007588;
  v233 = v231;
  v234 = __ROL4__(v144 ^ v156 ^ v189 ^ v213, 1);
  v235 = v234;
  v236 = v221 + v234 + (v225 & v233 ^ v215 & (v225 ^ v233));
  v237 = __ROL4__(v232, 5);
  v225 = __ROR4__(v225, 2);
  v238 = __ROL4__(v150 ^ v161 ^ v195 ^ v223, 1);
  v239 = v236 + v237 - 1894007588;
  v240 = v238;
  v241 = v227 + v238 + (v232 & v225 ^ v233 & (v232 ^ v225));
  v242 = v225;
  v243 = v239;
  v239 = __ROL4__(v239, 5);
  v232 = __ROR4__(v232, 2);
  v244 = __ROL4__(v156 ^ v165 ^ v199 ^ v228, 1);
  v245 = v233 + v244 + (v232 & v225 ^ v243 & (v232 ^ v225));
  v246 = v244;
  v247 = v241 + v239 - 1894007588;
  v248 = __ROL4__(v247, 5);
  v249 = __ROR4__(v243, 2);
  v250 = v245 + v248 - 1894007588;
  v251 = v249;
  v252 = __ROL4__(v161 ^ v171 ^ v206 ^ v235, 1);
  v253 = v251;
  v254 = v242 + v252 + (v232 & v247 ^ v251 & (v232 ^ v247));
  v255 = v252;
  v256 = v250;
  v250 = __ROL4__(v250, 5);
  v247 = __ROR4__(v247, 2);
  v257 = v250 + v254 - 1894007588;
  v258 = __ROL4__(v165 ^ v177 ^ v209 ^ v240, 1);
  v259 = __ROL4__(v257, 5);
  v260 = v247;
  v261 = v258;
  v262 = v258 + (v256 & v247 ^ v253 & (v256 ^ v247));
  v263 = __ROR4__(v256, 2);
  v264 = v259 + v232 + v262 - 1894007588;
  v265 = v263;
  v266 = __ROL4__(v171 ^ v183 ^ v213 ^ v246, 1);
  v267 = v253 + v266 + (v257 & v265 ^ v247 & (v257 ^ v265));
  v268 = v266;
  v269 = __ROL4__(v264, 5);
  v257 = __ROR4__(v257, 2);
  v270 = v267 + v269 - 1894007588;
  v271 = __ROL4__(v177 ^ v189 ^ v223 ^ v255, 1);
  v272 = v260 + v271 + (v264 & v257 ^ v265 & (v264 ^ v257));
  v273 = v271;
  v274 = v270;
  v270 = __ROL4__(v270, 5);
  v264 = __ROR4__(v264, 2);
  v275 = v257;
  v276 = __ROL4__(v183 ^ v195 ^ v228 ^ v261, 1);
  v277 = v265 + v276 + (v264 & v257 ^ v274 & (v264 ^ v257));
  v278 = v272 + v270 - 1894007588;
  v279 = v276;
  v280 = __ROL4__(v278, 5);
  v281 = __ROR4__(v274, 2);
  v282 = v277 + v280 - 1894007588;
  v283 = v281;
  v284 = __ROL4__(v189 ^ v199 ^ v235 ^ v268, 1);
  v285 = v282;
  v282 = __ROL4__(v282, 5);
  v286 = v284;
  v287 = v275 + v284 + (v264 & v278 ^ v283 & (v264 ^ v278));
  v278 = __ROR4__(v278, 2);
  v288 = v282 + v287 - 1894007588;
  v289 = __ROL4__(v195 ^ v206 ^ v240 ^ v273, 1);
  v290 = v289;
  v291 = v278;
  v292 = v289 + (v285 & v278 ^ v283 & (v285 ^ v278));
  v293 = __ROL4__(v288, 5);
  v294 = __ROR4__(v285, 2);
  v295 = v293 + v264 + v292 - 1894007588;
  v296 = v294;
  v297 = __ROL4__(v199 ^ v209 ^ v246 ^ v279, 1);
  v298 = v283 + v297 + (v288 & v296 ^ v278 & (v288 ^ v296));
  v299 = v297;
  v300 = __ROL4__(v295, 5);
  v288 = __ROR4__(v288, 2);
  v301 = v298 + v300 - 1894007588;
  v302 = __ROL4__(v206 ^ v213 ^ v255 ^ v286, 1);
  v303 = v291 + v302 + (v295 & v288 ^ v296 & (v295 ^ v288));
  v304 = v302;
  v305 = v301;
  v306 = v288;
  v301 = __ROL4__(v301, 5);
  v295 = __ROR4__(v295, 2);
  v307 = __ROL4__(v209 ^ v223 ^ v261 ^ v290, 1);
  v308 = v303 + v301 - 1894007588;
  v309 = v307;
  v310 = __ROL4__(v308, 5);
  v311 = v296 + v307 + (v295 & v288 ^ v305 & (v295 ^ v288)) + v310 - 1894007588;
  v312 = __ROR4__(v305, 2);
  v313 = v312;
  v314 = __ROL4__(v213 ^ v228 ^ v268 ^ v299, 1);
  v315 = v314;
  v316 = v306 + v314 + (v295 & v308 ^ v313 & (v295 ^ v308));
  v317 = v311;
  v311 = __ROL4__(v311, 5);
  v308 = __ROR4__(v308, 2);
  v318 = v311 + v316 - 1894007588;
  v319 = __ROL4__(v223 ^ v235 ^ v273 ^ v304, 1);
  v320 = v319;
  v321 = v308;
  v322 = v319 + (v317 & v308 ^ v313 & (v317 ^ v308));
  v323 = v318;
  v318 = __ROL4__(v318, 5);
  v317 = __ROR4__(v317, 2);
  v324 = __ROL4__(v228 ^ v240 ^ v279 ^ v309, 1);
  v325 = v318 + v295 + v322 - 1894007588;
  v326 = v313 + v324 + (v323 ^ v317 ^ v321);
  v327 = v324;
  v328 = __ROL4__(v325, 5);
  v323 = __ROR4__(v323, 2);
  v329 = v317;
  v330 = __ROL4__(v235 ^ v246 ^ v286 ^ v315, 1);
  v331 = v323;
  v332 = v330;
  v333 = v321 + v330 + (v325 ^ v323 ^ v317);
  v334 = v328 + v326 - 899497514;
  v335 = __ROL4__(v334, 5);
  v336 = v333 + v335 - 899497514;
  v325 = __ROR4__(v325, 2);
  v337 = v325;
  v338 = v325 ^ v331 ^ v334;
  v339 = __ROL4__(v240 ^ v255 ^ v290 ^ v320, 1);
  v340 = __ROL4__(v336, 5);
  v341 = v339;
  v334 = __ROR4__(v334, 2);
  v342 = v329 + v339 + v338 + v340 - 899497514;
  v343 = __ROL4__(v246 ^ v261 ^ v299 ^ v327, 1);
  v344 = v343;
  v345 = __ROL4__(v342, 5);
  v346 = v345 + v331 + v343 + (v337 ^ v336 ^ v334) - 899497514;
  v336 = __ROR4__(v336, 2);
  v347 = __ROL4__(v255 ^ v268 ^ v304 ^ v332, 1);
  v348 = v336;
  v349 = v347;
  v350 = v337 + v347 + (v342 ^ v336 ^ v334);
  v351 = __ROL4__(v346, 5);
  v342 = __ROR4__(v342, 2);
  v352 = v351 + v350 - 899497514;
  v353 = __ROL4__(v261 ^ v273 ^ v309 ^ v341, 1);
  v354 = v342;
  v355 = v353;
  v356 = v353 + (v346 ^ v342 ^ v348);
  v357 = __ROL4__(v352, 5);
  v346 = __ROR4__(v346, 2);
  v358 = v346;
  v359 = __ROL4__(v268 ^ v279 ^ v315 ^ v344, 1);
  v360 = v359;
  v361 = v357 + v334 + v356 - 899497514;
  v362 = __ROL4__(v361, 5);
  v363 = v348 + v359 + (v352 ^ v346 ^ v354) + v362 - 899497514;
  v352 = __ROR4__(v352, 2);
  v364 = v352;
  v365 = __ROL4__(v273 ^ v286 ^ v320 ^ v349, 1);
  v366 = v352 ^ v346 ^ v361;
  v367 = __ROL4__(v363, 5);
  v368 = v365;
  v369 = v354 + v365 + v366 + v367 - 899497514;
  v361 = __ROR4__(v361, 2);
  v370 = __ROL4__(v279 ^ v290 ^ v327 ^ v355, 1);
  v371 = v358 + v370 + (v364 ^ v363 ^ v361);
  v372 = v370;
  v373 = __ROL4__(v369, 5);
  v363 = __ROR4__(v363, 2);
  v374 = v373 + v371 - 899497514;
  v375 = __ROL4__(v286 ^ v299 ^ v332 ^ v360, 1);
  v376 = v363;
  v377 = v375;
  v378 = v364 + v375 + (v369 ^ v363 ^ v361);
  v379 = __ROL4__(v374, 5);
  v380 = v379 + v378 - 899497514;
  v369 = __ROR4__(v369, 2);
  v381 = __ROL4__(v290 ^ v304 ^ v341 ^ v368, 1);
  v382 = v369;
  v383 = v381;
  v384 = v381 + (v374 ^ v369 ^ v376);
  v385 = __ROL4__(v380, 5);
  v386 = v385 + v361 + v384 - 899497514;
  v374 = __ROR4__(v374, 2);
  v387 = __ROL4__(v299 ^ v309 ^ v344 ^ v372, 1);
  v388 = v376 + v387 + (v380 ^ v374 ^ v382);
  v389 = __ROL4__(v386, 5);
  v380 = __ROR4__(v380, 2);
  v390 = v374;
  v391 = v389 + v388 - 899497514;
  v392 = v380;
  v393 = __ROL4__(v304 ^ v315 ^ v349 ^ v377, 1);
  v394 = v391;
  v391 = __ROL4__(v391, 5);
  v395 = v382 + v393 + (v380 ^ v390 ^ v386) + v391 - 899497514;
  v386 = __ROR4__(v386, 2);
  v396 = v393;
  v397 = v395;
  v398 = v386;
  v399 = __ROL4__(v309 ^ v320 ^ v355 ^ v383, 1);
  v400 = __ROL4__(v395, 5);
  v401 = v399;
  v402 = __ROR4__(v394, 2);
  v403 = v400 + v390 + v399 + (v392 ^ v394 ^ v386) - 899497514;
  v404 = v403;
  v405 = v402;
  v406 = __ROL4__(v315 ^ v327 ^ v360 ^ v387, 1);
  v403 = __ROL4__(v403, 5);
  v407 = v392 + v406 + (v397 ^ v402 ^ v386) + v403 - 899497514;
  v408 = __ROR4__(v397, 2);
  v409 = v408;
  v410 = v407;
  v411 = __ROL4__(v320 ^ v332 ^ v368 ^ v396, 1);
  v407 = __ROL4__(v407, 5);
  v412 = v409;
  v413 = v407 + v398 + v411 + (v404 ^ v409 ^ v405) - 899497514;
  v414 = __ROR4__(v404, 2);
  v415 = v414;
  v416 = __ROL4__(v327 ^ v341 ^ v372 ^ v401, 1);
  v417 = v416;
  v418 = v413;
  v413 = __ROL4__(v413, 5);
  v419 = v405 + v416 + (v410 ^ v415 ^ v412) + v413 - 899497514;
  v420 = __ROR4__(v410, 2);
  v421 = v420;
  v422 = __ROL4__(v332 ^ v344 ^ v377 ^ v406, 1);
  v423 = __ROL4__(v419, 5);
  v424 = v412 + (v421 ^ v415 ^ v418) + v423 + v422 - 899497514;
  v425 = __ROR4__(v418, 2);
  v426 = v425;
  v427 = __ROL4__(v341 ^ v349 ^ v383 ^ v411, 1);
  v428 = __ROL4__(v424, 5);
  v429 = v415 + (v421 ^ v419 ^ v426) + v428 + v427 - 899497514;
  v419 = __ROR4__(v419, 2);
  v430 = __ROL4__(v417 ^ v344 ^ v355 ^ v387, 1);
  v431 = __ROL4__(v429, 5);
  v432 = v421 + (v424 ^ v419 ^ v426) + v431 + v430 - 899497514 + *(_DWORD *)(result + 8);
  *(_DWORD *)(result + 12) += v429;
  v424 = __ROR4__(v424, 2);
  v433 = *(_DWORD *)(result + 16) + v424;
  *(_DWORD *)(result + 20) += v419;
  v434 = *(_DWORD *)(result + 24);
  *(_DWORD *)(result + 8) = v432;
  *(_DWORD *)(result + 16) = v433;
  *(_DWORD *)(result + 24) = v426 + v434;
  return result;
}

//----- (10026E60) --------------------------------------------------------
unsigned int __usercall sub_10026E60@<eax>(int a1@<esi>, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@4
  unsigned int v5; // eax@7
  unsigned int result; // eax@7
  int v7; // edx@8

  v2 = *(_DWORD *)a1 & 0x3F;
  v3 = v2 >> 2;
  *(_DWORD *)(a1 + 4 * v3 + 28) = dword_1008D018[*(_BYTE *)a1 & 3] | *(_DWORD *)(a1 + 4 * v3 + 28) & dword_1008D028[*(_BYTE *)a1 & 3];
  if ( v2 > 0x37 )
  {
    if ( v2 < 0x3C )
      *(_DWORD *)(a1 + 88) = 0;
    sub_10025740(a1);
    v4 = 0;
    goto LABEL_6;
  }
  v4 = v3 + 1;
  if ( v3 + 1 < 0xE )
LABEL_6:
    memset((void *)(a1 + 4 * v4 + 28), 0, 4 * (14 - v4));
  v5 = 8 * *(_DWORD *)a1;
  *(_DWORD *)(a1 + 84) = ((((unsigned int)(*(_QWORD *)a1 >> 29) << 16) | (*(_QWORD *)a1 >> 29) & 0xFF00) << 8) | ((((unsigned int)(*(_QWORD *)a1 >> 29) >> 16) | (*(_QWORD *)a1 >> 29) & 0xFF0000) >> 8);
  *(_DWORD *)(a1 + 88) = (((v5 << 16) | v5 & 0xFF00) << 8) | (((v5 >> 16) | v5 & 0xFF0000) >> 8);
  sub_10025740(a1);
  result = 0;
  do
  {
    v7 = *(_DWORD *)(a1 + 4 * (result >> 2) + 8) >> 8 * (~(_BYTE)result & 3);
    *(_BYTE *)(++result + a2 - 1) = v7;
  }
  while ( result < 0x14 );
  return result;
}
// 1008D018: using guessed type int dword_1008D018[];
// 1008D028: using guessed type int dword_1008D028[];

//----- (10026F60) --------------------------------------------------------
void *__usercall sub_10026F60@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3)
{
  int v3; // ebp@1
  size_t v4; // ebx@1
  int v5; // edi@1
  unsigned int v6; // eax@1
  size_t v7; // esi@1
  char *v9; // [sp+14h] [bp+4h]@1

  v3 = (int)a3;
  v4 = a1;
  v5 = *a3 & 0x3F;
  v6 = a1 + *a3;
  v7 = 64 - v5;
  v9 = a2;
  *(_DWORD *)v3 = v6;
  if ( v6 < v4 )
    ++*(_DWORD *)(v3 + 4);
  if ( v4 >= v7 )
  {
    do
    {
      memcpy((void *)(v5 + v3 + 28), v9, v7);
      v9 += v7;
      v4 -= v7;
      v7 = 64;
      v5 = 0;
      sub_10025740(v3);
    }
    while ( v4 >= 0x40 );
  }
  return memcpy((void *)(v5 + v3 + 28), v9, v4);
}

//----- (10026FE0) --------------------------------------------------------
void *__usercall sub_10026FE0@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3)
{
  int v3; // edi@1
  void *result; // eax@1
  unsigned int v5; // eax@4
  _DWORD *v6; // eax@6

  v3 = a1;
  result = *(void **)(a1 + 156);
  if ( result != (void *)-1 )
  {
    if ( (unsigned int)result > 0x40 )
    {
      sub_10026E60(v3 + 64, v3);
      *(_DWORD *)(v3 + 156) = 20;
    }
    memset((void *)(v3 + *(_DWORD *)(v3 + 156)), 0, 64 - *(_DWORD *)(v3 + 156));
    v5 = 0;
    do
      *(_DWORD *)(v3 + 4 * v5++) ^= 0x36363636u;
    while ( v5 < 0x10 );
    v6 = (_DWORD *)sub_10025700(v3 + 64);
    result = sub_10026F60(0x40u, (char *)v3, v6);
    *(_DWORD *)(v3 + 156) = -1;
  }
  if ( a2 )
    result = sub_10026F60(a2, a3, (_DWORD *)(v3 + 64));
  return result;
}

//----- (10027080) --------------------------------------------------------
int __usercall sub_10027080@<eax>(int a1@<edi>, int a2, size_t a3)
{
  unsigned int v3; // eax@3
  int result; // eax@5
  char v5; // [sp+8h] [bp-18h]@3

  if ( *(_DWORD *)(a1 + 156) != -1 )
    sub_10026FE0(a1, 0, 0);
  sub_10026E60(a1 + 64, (int)&v5);
  v3 = 0;
  do
    *(_DWORD *)(a1 + 4 * v3++) ^= 0x6A6A6A6Au;
  while ( v3 < 0x10 );
  sub_10025700(a1 + 64);
  sub_10026F60(0x40u, (char *)a1, (_DWORD *)(a1 + 64));
  sub_10026F60(0x14u, &v5, (_DWORD *)(a1 + 64));
  result = sub_10026E60(a1 + 64, (int)&v5);
  if ( a3 )
    result = (int)memcpy((void *)a2, &v5, a3);
  return result;
}

//----- (10027140) --------------------------------------------------------
int __usercall sub_10027140@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3)
{
  int v3; // eax@1
  int result; // eax@2

  v3 = *(_DWORD *)(a2 + 156);
  if ( v3 + a1 <= 0x40 )
  {
    memcpy((void *)(a2 + v3), a3, a1);
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  else
  {
    sub_10025700(a2 + 64);
    sub_10026F60(*(_DWORD *)(a2 + 156), (char *)a2, (_DWORD *)(a2 + 64));
    sub_10026F60(a1, (char *)a3, (_DWORD *)(a2 + 64));
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  return result;
}

//----- (100271A0) --------------------------------------------------------
int __usercall sub_100271A0@<eax>(char *a1@<edi>)
{
  unsigned int v1; // ebp@1
  signed int v2; // eax@2
  int v3; // edx@4
  int v4; // ecx@4
  int v5; // edx@4
  unsigned int v6; // esi@4
  size_t v7; // eax@4
  int v8; // ebx@6
  int v9; // edx@8
  int result; // eax@8
  int v11; // ecx@8
  int v12; // edx@8
  char v13; // [sp+Ch] [bp-5Ch]@8
  int v14; // [sp+14h] [bp-54h]@4
  int v15; // [sp+18h] [bp-50h]@4
  int v16; // [sp+1Ch] [bp-4Ch]@4
  int v17; // [sp+20h] [bp-48h]@4
  int v18; // [sp+24h] [bp-44h]@4
  char v19[64]; // [sp+28h] [bp-40h]@6

  v1 = 0;
  do
  {
    v2 = v1;
    if ( !v1 )
      v2 = 260;
    v3 = *(_DWORD *)&a1[v2 - 16];
    v14 = *(_DWORD *)&a1[v2 - 20];
    v4 = *(_DWORD *)&a1[v2 - 12];
    v15 = v3;
    v5 = *(_DWORD *)&a1[v2 - 8];
    v6 = 260 - v1;
    v18 = *(_DWORD *)&a1[v2 - 4];
    v16 = v4;
    v17 = v5;
    v7 = 64;
    if ( 260 - v1 <= 0x40 )
      v7 = 260 - v1;
    v8 = (int)&a1[v1];
    memcpy(v19, &a1[v1], v7);
    if ( v6 < 0x40 )
      memcpy(&v19[v6], a1, 64 - v6);
    sub_10025740((int)&v13);
    v9 = v15;
    result = v16;
    *(_DWORD *)v8 = v14;
    v11 = v17;
    *(_DWORD *)(v8 + 4) = v9;
    v12 = v18;
    *(_DWORD *)(v8 + 8) = result;
    v1 += 20;
    *(_DWORD *)(v8 + 12) = v11;
    *(_DWORD *)(v8 + 16) = v12;
  }
  while ( v1 < 0x104 );
  return result;
}
// 100271A0: using guessed type char var_40[64];

//----- (10027260) --------------------------------------------------------
int __usercall sub_10027260@<eax>(int a1@<ebx>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // eax@3
  char v3; // cl@4
  char v4; // dl@4
  char v5; // cl@4
  char v6; // dl@4
  char *v8; // [sp+Ch] [bp-4h]@1

  v8 = (char *)(a1 + 260);
  v1 = 0;
  qmemcpy((void *)(a1 + 260), (const void *)a1, 0x104u);
  do
    v1 += (*(int (__cdecl **)(unsigned int, unsigned int))(a1 + 524))(a1 + v1, 260 - v1);
  while ( v1 < 0x104 );
  v2 = 0;
  do
  {
    v3 = *(_BYTE *)(v2 + a1 + 261);
    *(_BYTE *)(v2 + a1) ^= ~v8[v2];
    v4 = *(_BYTE *)(v2 + a1 + 262);
    *(_BYTE *)(v2 + a1 + 1) ^= ~v3;
    v5 = *(_BYTE *)(v2 + a1 + 263);
    *(_BYTE *)(v2 + a1 + 2) ^= ~v4;
    v6 = *(_BYTE *)(v2 + a1 + 264);
    *(_BYTE *)(v2 + a1 + 3) ^= ~v5;
    *(_BYTE *)(v2 + a1 + 4) ^= ~v6;
    v2 += 5;
  }
  while ( v2 < 0x104 );
  sub_100271A0((char *)a1);
  return sub_100271A0(v8);
}

//----- (10027320) --------------------------------------------------------
char __cdecl sub_10027320(char *a1, size_t a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_10026FE0(a3 + 296, a2, a1);
    sub_100248A0(a3, (int)a1, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10027370) --------------------------------------------------------
char __cdecl sub_10027370(char *a1, unsigned int a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_100248A0(a3, (int)a1, a2);
    sub_10026FE0(a3 + 296, a2, a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100273C0) --------------------------------------------------------
bool __cdecl sub_100273C0(int a1, int a2)
{
  if ( a2 )
    sub_10027080(a2 + 296, a1, 0xAu);
  return a2 != 0;
}

//----- (100273F0) --------------------------------------------------------
int __usercall sub_100273F0@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7)
{
  void *v7; // esi@1
  char *v8; // ebx@1
  int result; // eax@1
  unsigned int v10; // edx@1
  unsigned int v11; // ebx@2
  size_t v12; // edx@3
  char v13; // al@6
  char v14; // al@6
  bool v15; // zf@7
  unsigned int v16; // eax@9
  unsigned int v17; // ecx@9
  int *v18; // [sp+10h] [bp-228h]@2
  unsigned int v19; // [sp+14h] [bp-224h]@2
  int v20; // [sp+18h] [bp-220h]@4
  signed int v21; // [sp+1Ch] [bp-21Ch]@2
  unsigned int v22; // [sp+20h] [bp-218h]@1
  char v23; // [sp+28h] [bp-210h]@3
  char v24; // [sp+C8h] [bp-170h]@1
  char v25; // [sp+168h] [bp-D0h]@1
  int v26; // [sp+20Ch] [bp-2Ch]@2
  int v27; // [sp+210h] [bp-28h]@3
  int v28; // [sp+214h] [bp-24h]@3
  int v29; // [sp+218h] [bp-20h]@3
  int v30; // [sp+21Ch] [bp-1Ch]@3
  int v31; // [sp+220h] [bp-18h]@3
  char v32[16]; // [sp+224h] [bp-14h]@6

  v7 = a2;
  v8 = a1;
  sub_10025680(&v24);
  sub_10027140(a3, (int)&v24, v7);
  qmemcpy(&v25, &v24, 0xA0u);
  sub_10026FE0((int)&v25, a4, v8);
  result = -858993459 * (a7 - 1);
  v10 = (a7 - 1) / 0x14;
  v22 = v10 + 1;
  if ( v10 != -1 )
  {
    v11 = 1;
    v19 = 0;
    v21 = 1;
    v18 = &v26;
    do
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      qmemcpy(&v23, &v25, 0xA0u);
      LOBYTE(v31) = BYTE3(v11);
      BYTE2(v31) = BYTE1(v11);
      BYTE1(v31) = v11 >> 16;
      BYTE3(v31) = v11;
      v12 = 4;
      if ( a5 )
      {
        v20 = a5;
        do
        {
          sub_10026FE0((int)&v23, v12, (char *)&v31);
          sub_10027080((int)&v23, (int)&v31, 0x14u);
          v12 = 0;
          do
          {
            *((_BYTE *)&v26 + v12) ^= *((_BYTE *)&v31 + v12);
            v13 = *((_BYTE *)&v31 + v12 + 2);
            *((_BYTE *)&v26 + v12 + 1) ^= *((_BYTE *)&v31 + v12 + 1);
            *((_BYTE *)&v26 + v12 + 2) ^= v13;
            v14 = v32[v12];
            *((_BYTE *)&v26 + v12 + 3) ^= *((_BYTE *)&v31 + v12 + 3);
            *((_BYTE *)&v27 + v12) ^= v14;
            v12 += 5;
          }
          while ( v12 < 0x14 );
          v15 = v20-- == 1;
          qmemcpy(&v23, &v24, 0xA0u);
        }
        while ( !v15 );
        v11 = v21;
      }
      v16 = v19;
      v17 = 0;
      do
      {
        if ( v16 >= a7 )
          break;
        *(_BYTE *)(v16 + a6) = *((_BYTE *)v18 + v16);
        ++v17;
        ++v16;
      }
      while ( v17 < 0x14 );
      v19 += 20;
      v18 -= 5;
      result = ++v11 - 1;
      v21 = v11;
    }
    while ( v11 - 1 < v22 );
  }
  return result;
}
// 100273F0: using guessed type char var_14[16];

//----- (10027600) --------------------------------------------------------
int __usercall sub_10027600@<eax>(void *a1@<eax>, int a2)
{
  int v2; // ebx@1
  signed int v3; // esi@1

  v2 = (int)a1;
  memset(a1, 0, 0x210u);
  *(_DWORD *)(v2 + 524) = a2;
  sub_10027260(v2);
  v3 = 20;
  do
  {
    sub_100271A0((char *)v2);
    --v3;
  }
  while ( v3 );
  return sub_10027260(v2);
}

//----- (10027650) --------------------------------------------------------
char *__cdecl sub_10027650(int a1, int a2)
{
  void *v2; // ecx@0
  char *result; // eax@1
  unsigned int v4; // ebp@1
  int v5; // edi@1
  char *v6; // ebx@1
  size_t v7; // esi@4

  result = (char *)a2;
  v4 = a1;
  v5 = *(_DWORD *)(a2 + 520);
  v6 = (char *)v2;
  if ( a1 )
  {
    while ( 1 )
    {
      v7 = 260 - v5;
      if ( v4 < 260 - v5 )
        v7 = v4;
      result = (char *)memcpy(v6, &result[v5 + 260], v7);
      v6 += v7;
      v5 += v7;
      v4 -= v7;
      if ( v5 == 260 )
      {
        result = (char *)sub_10027260(a2);
        v5 = 0;
      }
      if ( !v4 )
        break;
      result = (char *)a2;
    }
    *(_DWORD *)(a2 + 520) = v5;
  }
  else
  {
    *(_DWORD *)(a2 + 520) = v5;
  }
  return result;
}

//----- (100276E0) --------------------------------------------------------
signed int __cdecl sub_100276E0(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6)
{
  signed int result; // eax@2
  int v7; // ebx@6
  char v8; // [sp+Ch] [bp-48h]@6
  char v9[8]; // [sp+14h] [bp-40h]@6
  __int16 v10[26]; // [sp+1Ch] [bp-38h]@6

  if ( a3 <= 0x80 )
  {
    if ( (unsigned __int8)(a1 - 1) > 2u )
    {
      result = -101;
    }
    else if ( a6 )
    {
      *(_BYTE *)(a6 + 464) = a1;
      v7 = a1 & 3;
      *(_DWORD *)(a6 + 460) = a3;
      sub_100273F0(a4, a2, a3, 4 * v7 + 4, 1000, (int)&v8, 16 * v7 + 18);
      *(_DWORD *)(a6 + 456) = 16;
      *(_DWORD *)a6 = 0;
      *(_DWORD *)(a6 + 4) = 0;
      *(_DWORD *)(a6 + 8) = 0;
      *(_DWORD *)(a6 + 12) = 0;
      sub_10024900(a6 + 32, (int)&v8, 8 * v7 + 8);
      sub_10025680((void *)(a6 + 296));
      sub_10027140(8 * v7 + 8, a6 + 296, &v9[8 * v7]);
      *a5 = v10[8 * v7];
      result = 0;
    }
    else
    {
      result = -102;
    }
  }
  else
  {
    result = -100;
  }
  return result;
}
// 100276E0: using guessed type char var_40[8];
// 100276E0: using guessed type __int16 var_38[26];

//----- (10027810) --------------------------------------------------------
bool __cdecl sub_10027810(void *a1, int a2)
{
  bool v2; // bl@3
  int v4; // [sp+Ch] [bp-214h]@5

  v2 = a1 && a2;
  sub_10027600(&v4, (int)sub_100256A0);
  if ( v2 )
    sub_10027650(a2, (int)&v4);
  return v2;
}

//----- (10027890) --------------------------------------------------------
BOOL __usercall sub_10027890@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // ecx@3
  int v4; // ecx@4

  *(_WORD *)(*(_DWORD *)(a1 + 5712) + 2 * *(_DWORD *)(a1 + 5728)) = a3;
  *(_BYTE *)(*(_DWORD *)(a1 + 5716) + (*(_DWORD *)(a1 + 5728))++) = a2;
  if ( a3 )
  {
    ++*(_DWORD *)(a1 + 2920);
    ++*(_WORD *)(a1 + 4 * (unsigned __int8)byte_1008D830[a2] + 3964);
    v3 = a3 - 1;
    if ( v3 >= 0x100 )
      v4 = (unsigned __int8)byte_1008D730[v3 >> 7];
    else
      v4 = (unsigned __int8)byte_1008D630[v3];
    ++*(_WORD *)(a1 + 4 * v4 + 5228);
  }
  else
  {
    ++*(_WORD *)(a1 + 4 * a2 + 2936);
  }
  return *(_DWORD *)(a1 + 5728) == *(_DWORD *)(a1 + 5724) - 1;
}

//----- (10027930) --------------------------------------------------------
int __usercall sub_10027930@<eax>(int result@<eax>)
{
  signed int v1; // ecx@1
  __int16 v2; // cx@4

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)((*(_DWORD *)(result + 5812))++ + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
    *(_DWORD *)(result + 2932) = 0;
    *(_WORD *)(result + 2924) = 0;
  }
  else if ( v1 >= 8 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) -= 8;
    *(_WORD *)(result + 2924) = v2;
  }
  return result;
}

//----- (100279C0) --------------------------------------------------------
unsigned int __fastcall sub_100279C0(unsigned int a1, int a2)
{
  unsigned int v2; // eax@1
  int v3; // esi@2

  v2 = 0;
  do
  {
    v3 = a1 & 1;
    --a2;
    a1 >>= 1;
    v2 = 2 * (v3 | v2);
  }
  while ( a2 > 0 );
  return v2 >> 1;
}

//----- (100279E0) --------------------------------------------------------
int __usercall sub_100279E0@<eax>(int result@<eax>)
{
  signed int v1; // edx@1
  char v2; // bl@2
  int v3; // edx@2

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 <= 8 )
  {
    if ( v1 > 0 )
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    v3 = *(_DWORD *)(result + 5800);
    *(_BYTE *)(++*(_DWORD *)(result + 5812) + v3) = v2;
    ++*(_DWORD *)(result + 5812);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  return result;
}

//----- (10027A70) --------------------------------------------------------
int __usercall sub_10027A70@<eax>(int result@<eax>, int a2, int a3)
{
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // ebp@2
  int v6; // esi@2
  int v7; // ecx@2
  int v8; // edi@3
  int v9; // esi@4
  int v10; // edx@4
  int v11; // ecx@4
  int v12; // edx@4
  int v13; // ecx@4
  int v14; // edx@6
  int v15; // edi@7
  int v16; // edx@7
  int v17; // ecx@7
  int v18; // edx@7
  int v19; // edi@9
  int v20; // esi@10
  int v21; // ecx@10
  int v22; // edx@11
  int v23; // ecx@11
  int v24; // edx@11
  int v25; // ecx@11
  unsigned int v26; // ebp@14
  int v27; // edi@15
  int v28; // edx@17
  int v29; // ecx@17
  unsigned __int16 v30; // si@18
  int v31; // edx@18
  int v32; // ecx@18
  int v33; // edx@18
  int v34; // esi@20
  int v35; // ecx@21
  int v36; // ebp@21
  int v37; // edx@22
  int v38; // ecx@22
  int v39; // edx@22
  int v40; // edi@26
  int v41; // ecx@26
  unsigned __int16 v42; // si@27
  int v43; // edx@27
  int v44; // ecx@27
  int v45; // edx@27
  int v46; // [sp+10h] [bp-Ch]@6
  int v47; // [sp+14h] [bp-8h]@6
  int v48; // [sp+14h] [bp-8h]@17
  unsigned int v49; // [sp+18h] [bp-4h]@2

  v3 = a2;
  v4 = 0;
  if ( *(_DWORD *)(result + 5728) )
  {
    do
    {
      v5 = *(_WORD *)(*(_DWORD *)(result + 5712) + 2 * v4);
      v6 = *(_BYTE *)(v4 + *(_DWORD *)(result + 5716));
      v49 = v4 + 1;
      v7 = *(_DWORD *)(result + 2932);
      if ( v5 )
      {
        v14 = (unsigned __int8)byte_1008D830[v6];
        v46 = *(_WORD *)(v3 + 4 * v14 + 1030);
        v47 = (unsigned __int8)byte_1008D830[v6];
        if ( v7 <= 16 - v46 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a2 + 4 * v14 + 1028) << v7;
          *(_DWORD *)(result + 2932) = v46 + v7;
        }
        else
        {
          v15 = *(_WORD *)(a2 + 4 * v14 + 1028);
          v16 = v15 << v7;
          v17 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v16;
          *(_BYTE *)(v17 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v18 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          LOWORD(v15) = (unsigned __int16)v15 >> (16 - v18);
          *(_DWORD *)(result + 2932) = v18 + v46 - 16;
          v14 = v47;
          *(_WORD *)(result + 2924) = v15;
        }
        v19 = dword_1008D038[v14];
        v3 = a2;
        if ( v19 )
        {
          v20 = v6 - dword_1008D930[v14];
          v21 = *(_DWORD *)(result + 2932);
          if ( v21 <= 16 - v19 )
          {
            *(_WORD *)(result + 2924) |= v20 << v21;
            v25 = v19 + v21;
          }
          else
          {
            v22 = v20 << v21;
            v23 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v22;
            *(_BYTE *)(v23 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v24 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v3 = a2;
            v25 = v24 + v19 - 16;
            *(_WORD *)(result + 2924) = (unsigned __int16)v20 >> (16 - v24);
          }
          *(_DWORD *)(result + 2932) = v25;
        }
        v26 = v5 - 1;
        if ( v26 >= 0x100 )
          v27 = (unsigned __int8)byte_1008D730[v26 >> 7];
        else
          v27 = (unsigned __int8)byte_1008D630[v26];
        v28 = *(_WORD *)(a3 + 4 * v27 + 2);
        v29 = *(_DWORD *)(result + 2932);
        v48 = *(_WORD *)(a3 + 4 * v27 + 2);
        if ( v29 <= 16 - v28 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a3 + 4 * v27) << v29;
          *(_DWORD *)(result + 2932) = v28 + v29;
        }
        else
        {
          v30 = *(_WORD *)(a3 + 4 * v27);
          v31 = *(_WORD *)(a3 + 4 * v27) << v29;
          v32 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v31;
          *(_BYTE *)(v32 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v33 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v3 = a2;
          *(_DWORD *)(result + 2932) = v33 + v48 - 16;
          *(_WORD *)(result + 2924) = v30 >> (16 - v33);
        }
        v34 = dword_1008D0C0[v27];
        if ( !v34 )
          goto LABEL_25;
        v35 = *(_DWORD *)(result + 2932);
        v36 = v26 - dword_1008D9A8[v27];
        if ( v35 <= 16 - v34 )
        {
          *(_WORD *)(result + 2924) |= v36 << v35;
          v13 = v34 + v35;
        }
        else
        {
          v37 = v36 << v35;
          v38 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v37;
          *(_BYTE *)(v38 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v39 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v39 + v34 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v36 >> (16 - v39);
        }
      }
      else
      {
        v8 = *(_WORD *)(v3 + 4 * v6 + 2);
        if ( v7 <= 16 - v8 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 4 * v6) << v7;
          v13 = v8 + v7;
        }
        else
        {
          v9 = *(_WORD *)(v3 + 4 * v6);
          v10 = v9 << v7;
          v11 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v10;
          *(_BYTE *)(v11 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v12 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v12 + v8 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v9 >> (16 - v12);
        }
      }
      *(_DWORD *)(result + 2932) = v13;
LABEL_25:
      v4 = v49;
    }
    while ( v49 < *(_DWORD *)(result + 5728) );
  }
  v40 = *(_WORD *)(v3 + 1026);
  v41 = *(_DWORD *)(result + 2932);
  if ( v41 <= 16 - v40 )
  {
    *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 1024) << v41;
    *(_DWORD *)(result + 2932) = v40 + v41;
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  else
  {
    v42 = *(_WORD *)(v3 + 1024);
    v43 = *(_WORD *)(v3 + 1024) << v41;
    v44 = *(_DWORD *)(result + 5800);
    *(_WORD *)(result + 2924) |= v43;
    *(_BYTE *)(v44 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2925);
    v45 = *(_DWORD *)(result + 2932);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) = v45 + v40 - 16;
    *(_WORD *)(result + 2924) = v42 >> (16 - v45);
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  return result;
}
// 1008D038: using guessed type int dword_1008D038[];
// 1008D0C0: using guessed type int dword_1008D0C0[];
// 1008D930: using guessed type int dword_1008D930[];
// 1008D9A8: using guessed type int dword_1008D9A8[];

//----- (10027EF0) --------------------------------------------------------
int __usercall sub_10027EF0@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  _BYTE *v4; // edi@1
  int result; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // edx@1
  int i; // esi@1

  v3 = a3;
  v4 = a2;
  result = sub_100279E0(a1);
  v6 = *(_DWORD *)(result + 5812);
  v7 = *(_DWORD *)(result + 5800);
  *(_DWORD *)(result + 2928) = 8;
  *(_BYTE *)(v6 + v7) = v3;
  v8 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v8) = BYTE1(v3);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~(_BYTE)v3;
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~BYTE1(v3);
  for ( i = ++*(_DWORD *)(result + 5812); v3; ++v4 )
  {
    *(_BYTE *)(i + *(_DWORD *)(result + 5800)) = *v4;
    i = ++*(_DWORD *)(result + 5812);
    --v3;
  }
  return result;
}

//----- (10027FA0) --------------------------------------------------------
void *__usercall sub_10027FA0@<eax>(int a1@<edi>)
{
  void *result; // eax@1
  int v2; // ebx@1
  size_t v3; // esi@1
  bool v4; // zf@4

  result = *(void **)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(v2 + 5812);
  if ( v3 > (unsigned int)result )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    result = memcpy(*(void **)(a1 + 12), *(const void **)(v2 + 5808), v3);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v2 + 5808) += v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) -= v3;
    v4 = *(_DWORD *)(v2 + 5812) == v3;
    *(_DWORD *)(v2 + 5812) -= v3;
    if ( v4 )
      *(_DWORD *)(v2 + 5808) = *(_DWORD *)(v2 + 5800);
  }
  return result;
}

//----- (10028000) --------------------------------------------------------
int __usercall sub_10028000@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx@1
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@3
  int v9; // ecx@3
  int v10; // esi@6
  int v11; // ebx@8
  int i; // ecx@13
  int v13; // edx@17
  int v14; // ebx@18
  int v15; // ecx@19
  int v16; // esi@20
  int v17; // [sp+Ch] [bp-20h]@1
  int *v18; // [sp+10h] [bp-1Ch]@2
  int v19; // [sp+10h] [bp-1Ch]@17
  signed int v20; // [sp+14h] [bp-18h]@2
  int v21; // [sp+18h] [bp-14h]@1
  int v22; // [sp+1Ch] [bp-10h]@2
  int v23; // [sp+20h] [bp-Ch]@1
  int v24; // [sp+24h] [bp-8h]@1
  int v25; // [sp+28h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)a2;
  v24 = *(_DWORD *)(v2 + 8);
  v4 = *(_DWORD *)(v2 + 16);
  v21 = *(_DWORD *)v2;
  v25 = *(_DWORD *)(v2 + 4);
  v5 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  v23 = v5;
  v6 = 0;
  *(_WORD *)(v3 + 4 * *(_DWORD *)(result + 4 * *(_DWORD *)(result + 2328) + 32) + 2) = 0;
  v7 = *(_DWORD *)(result + 2328) + 1;
  v17 = 0;
  if ( v7 < 573 )
  {
    v18 = (int *)(result + 4 * v7 + 32);
    v22 = 573 - v7;
    v20 = 573;
    do
    {
      v8 = *v18;
      v9 = *(_WORD *)(v3 + 4 * *(_WORD *)(v3 + 4 * *v18 + 2) + 2) + 1;
      if ( v9 > v4 )
      {
        ++v6;
        v9 = v4;
        v17 = v6;
      }
      *(_WORD *)(v3 + 4 * v8 + 2) = v9;
      if ( v8 <= v23 )
      {
        ++*(_WORD *)(result + 2 * v9);
        v10 = 0;
        if ( v8 >= v24 )
          v10 = *(_DWORD *)(v25 + 4 * (v8 - v24));
        v11 = *(_WORD *)(v3 + 4 * v8);
        *(_DWORD *)(result + 2912) += v11 * (v10 + v9);
        if ( v21 )
          *(_DWORD *)(result + 2916) += v11 * (v10 + *(_WORD *)(v21 + 4 * v8 + 2));
        v6 = v17;
      }
      ++v18;
      --v22;
    }
    while ( v22 );
    if ( v6 )
    {
      do
      {
        for ( i = v4 - 1; !*(_WORD *)(result + 2 * i); --i )
          ;
        --*(_WORD *)(result + 2 * i);
        *(_WORD *)(result + 2 * i + 2) += 2;
        --*(_WORD *)(result + 2 * v4);
        v6 -= 2;
      }
      while ( v6 > 0 );
      for ( ; v4; --v4 )
      {
        v13 = *(_WORD *)(result + 2 * v4);
        v19 = *(_WORD *)(result + 2 * v4);
        if ( *(_WORD *)(result + 2 * v4) )
        {
          v14 = result + 4 * v20 + 32;
          do
          {
            v15 = *(_DWORD *)(v14 - 4);
            --v20;
            v14 -= 4;
            if ( v15 <= v23 )
            {
              v16 = *(_WORD *)(v3 + 4 * v15 + 2);
              if ( v16 != v4 )
              {
                *(_DWORD *)(result + 2912) += *(_WORD *)(v3 + 4 * v15) * (v4 - v16);
                *(_WORD *)(v3 + 4 * v15 + 2) = v4;
              }
              v13 = --v19;
            }
          }
          while ( v13 );
        }
      }
    }
  }
  return result;
}

//----- (100281D0) --------------------------------------------------------
signed int __usercall sub_100281D0@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // cx@1
  signed int result; // eax@1
  int v5; // edx@1
  int i; // esi@3
  int v7; // edx@4
  unsigned int v8; // ecx@5
  __int16 v9; // [sp+4h] [bp-24h]@2
  char v10; // [sp+6h] [bp-22h]@1

  v3 = 0;
  result = 1;
  v5 = a1 - (_DWORD)&v10;
  do
  {
    v3 = 2 * (v3 + *(__int16 *)((char *)&v9 + 2 * result + v5));
    *(&v9 + result++) = v3;
  }
  while ( result <= 15 );
  for ( i = 0; i <= a2; ++i )
  {
    v7 = *(_WORD *)(a3 + 4 * i + 2);
    if ( *(_WORD *)(a3 + 4 * i + 2) )
    {
      v8 = (unsigned __int16)(*(&v9 + v7))++;
      result = sub_100279C0(v8, v7);
      *(_WORD *)(a3 + 4 * i) = result;
    }
  }
  return result;
}

//----- (10028250) --------------------------------------------------------
_WORD *__fastcall sub_10028250(int a1, int a2)
{
  _WORD *v2; // eax@1
  signed int v3; // ecx@1
  _WORD *v4; // eax@3
  signed int v5; // ecx@3
  _WORD *result; // eax@5
  signed int v7; // ecx@5

  v2 = (_WORD *)(a2 + 2936);
  v3 = 286;
  do
  {
    *v2 = 0;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  v4 = (_WORD *)(a2 + 5228);
  v5 = 30;
  do
  {
    *v4 = 0;
    v4 += 2;
    --v5;
  }
  while ( v5 );
  result = (_WORD *)(a2 + 5472);
  v7 = 19;
  do
  {
    *result = 0;
    result += 2;
    --v7;
  }
  while ( v7 );
  *(_DWORD *)(a2 + 2916) = 0;
  *(_DWORD *)(a2 + 2912) = 0;
  *(_DWORD *)(a2 + 2920) = 0;
  *(_DWORD *)(a2 + 5728) = 0;
  *(_WORD *)(a2 + 3960) = 1;
  return result;
}

//----- (100282C0) --------------------------------------------------------
signed int __usercall sub_100282C0@<eax>(int a1@<esi>)
{
  int v1; // ecx@1
  int v2; // edx@1
  int v3; // eax@1
  int v4; // edx@1
  signed int result; // eax@1

  v1 = *(_DWORD *)(a1 + 5764);
  v2 = *(_DWORD *)(a1 + 5736);
  *(_DWORD *)(a1 + 5744) = 2 * *(_DWORD *)(a1 + 5748);
  *(_WORD *)(v2 + 2 * v1 - 2) = 0;
  memset(*(void **)(a1 + 5736), 0, 2 * *(_DWORD *)(a1 + 5764) - 2);
  v3 = 6 * *(_BYTE *)(a1 + 5784);
  *(_DWORD *)(a1 + 5700) = (unsigned __int16)word_1008DA22[6 * *(_BYTE *)(a1 + 5784)];
  *(_DWORD *)(a1 + 5704) = (unsigned __int16)word_1008DA20[v3];
  *(_DWORD *)(a1 + 5708) = (unsigned __int16)word_1008DA24[v3];
  v4 = (unsigned __int16)word_1008DA26[v3];
  result = 2;
  *(_DWORD *)(a1 + 5680) = 0;
  *(_DWORD *)(a1 + 5664) = 0;
  *(_DWORD *)(a1 + 5688) = 0;
  *(_DWORD *)(a1 + 5676) = 0;
  *(_DWORD *)(a1 + 5760) = 0;
  *(_DWORD *)(a1 + 5696) = v4;
  *(_DWORD *)(a1 + 5692) = 2;
  *(_DWORD *)(a1 + 5668) = 2;
  return result;
}
// 1008DA20: using guessed type __int16 word_1008DA20[];
// 1008DA22: using guessed type __int16 word_1008DA22[];
// 1008DA24: using guessed type __int16 word_1008DA24[];
// 1008DA26: using guessed type __int16 word_1008DA26[];

//----- (10028380) --------------------------------------------------------
unsigned int __usercall sub_10028380@<eax>(int a1@<esi>, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // edi@1
  int v6; // ecx@4
  unsigned int v7; // ebx@4
  int v8; // edx@8
  char v9; // al@11
  int v10; // edx@11
  unsigned int v11; // ecx@12
  _BYTE *v12; // edx@12
  char v13; // al@13
  _BYTE *v14; // edx@13
  char v15; // al@14
  _BYTE *v16; // edx@14
  char v17; // al@15
  _BYTE *v18; // edx@15
  char v19; // al@16
  _BYTE *v20; // edx@16
  char v21; // al@17
  _BYTE *v22; // edx@17
  char v23; // al@18
  _BYTE *v24; // edx@18
  char v25; // al@19
  _BYTE *v26; // edx@19
  char v27; // al@20
  int v28; // edx@22
  unsigned int result; // eax@27
  char v30; // [sp+Fh] [bp-11h]@4
  unsigned int v31; // [sp+10h] [bp-10h]@1
  int v32; // [sp+14h] [bp-Ch]@4
  unsigned int v33; // [sp+18h] [bp-8h]@2
  char v34; // [sp+24h] [bp+4h]@4

  v2 = *(_DWORD *)(a1 + 5748);
  v3 = *(_DWORD *)(a1 + 5680);
  v4 = a2;
  v31 = *(_DWORD *)(a1 + 5696);
  v5 = *(_DWORD *)(a1 + 5692);
  if ( v3 <= v2 - 262 )
    v33 = 0;
  else
    v33 = v3 - v2 + 262;
  v6 = *(_DWORD *)(a1 + 5740) + v3;
  v34 = *(_BYTE *)(v6 + v5 - 1);
  v32 = *(_DWORD *)(a1 + 5708);
  v7 = v6 + 258;
  v30 = *(_BYTE *)(v6 + v5);
  if ( v5 >= *(_DWORD *)(a1 + 5704) )
    v31 >>= 2;
  if ( *(_DWORD *)(a1 + 5708) > *(_DWORD *)(a1 + 5688) )
    v32 = *(_DWORD *)(a1 + 5688);
  do
  {
    v8 = v4 + *(_DWORD *)(a1 + 5740);
    if ( *(_BYTE *)(v8 + v5) == v30 && *(_BYTE *)(v8 + v5 - 1) == v34 && *(_BYTE *)v8 == *(_BYTE *)v6 )
    {
      v9 = *(_BYTE *)(v8 + 1);
      v10 = v8 + 1;
      if ( v9 == *(_BYTE *)(v6 + 1) )
      {
        v11 = v6 + 2;
        v12 = (_BYTE *)(v10 + 1);
        do
        {
          v13 = *(_BYTE *)(v11++ + 1);
          v14 = v12 + 1;
          if ( v13 != *v14 )
            break;
          v15 = *(_BYTE *)(v11++ + 1);
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *(_BYTE *)(v11++ + 1);
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *(_BYTE *)(v11++ + 1);
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *(_BYTE *)(v11++ + 1);
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *(_BYTE *)(v11++ + 1);
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *(_BYTE *)(v11++ + 1);
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *(_BYTE *)(v11++ + 1);
          v12 = v26 + 1;
          if ( v27 != *v12 )
            break;
        }
        while ( v11 < v7 );
        v28 = v11 - v7 + 258;
        v6 = v7 - 258;
        if ( v28 > (signed int)v5 )
        {
          *(_DWORD *)(a1 + 5684) = v4;
          v5 = v28;
          if ( v28 >= v32 )
            break;
          v34 = *(_BYTE *)(v28 + v6 - 1);
          v30 = *(_BYTE *)(v28 + v6);
        }
      }
    }
    v4 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & *(_DWORD *)(a1 + 5756)));
    if ( v4 <= v33 )
      break;
    --v31;
  }
  while ( v31 );
  result = *(_DWORD *)(a1 + 5688);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (10028530) --------------------------------------------------------
unsigned int __usercall sub_10028530@<eax>(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  unsigned int v6; // edi@1
  unsigned int v7; // eax@3
  _BYTE *v8; // ecx@3
  char v9; // dl@4
  _BYTE *v10; // ecx@4
  char v11; // dl@5
  _BYTE *v12; // ecx@5
  char v13; // dl@6
  _BYTE *v14; // ecx@6
  char v15; // dl@7
  _BYTE *v16; // ecx@7
  char v17; // dl@8
  _BYTE *v18; // ecx@8
  char v19; // dl@9
  _BYTE *v20; // ecx@9
  char v21; // dl@10
  _BYTE *v22; // ecx@10
  char v23; // dl@11
  unsigned int v24; // ecx@13
  unsigned int result; // eax@13

  v2 = *(_DWORD *)(a1 + 5740);
  v3 = *(_BYTE *)(v2 + a2);
  v4 = v2 + *(_DWORD *)(a1 + 5680);
  v5 = a2 + v2;
  v6 = v4 + 258;
  if ( v3 != *(_BYTE *)v4 || *(_BYTE *)(v5 + 1) != *(_BYTE *)(v4 + 1) )
  {
    result = 2;
  }
  else
  {
    v7 = v4 + 2;
    v8 = (_BYTE *)(v5 + 2);
    do
    {
      v9 = *(_BYTE *)(v7++ + 1);
      v10 = v8 + 1;
      if ( v9 != *v10 )
        break;
      v11 = *(_BYTE *)(v7++ + 1);
      v12 = v10 + 1;
      if ( v11 != *v12 )
        break;
      v13 = *(_BYTE *)(v7++ + 1);
      v14 = v12 + 1;
      if ( v13 != *v14 )
        break;
      v15 = *(_BYTE *)(v7++ + 1);
      v16 = v14 + 1;
      if ( v15 != *v16 )
        break;
      v17 = *(_BYTE *)(v7++ + 1);
      v18 = v16 + 1;
      if ( v17 != *v18 )
        break;
      v19 = *(_BYTE *)(v7++ + 1);
      v20 = v18 + 1;
      if ( v19 != *v20 )
        break;
      v21 = *(_BYTE *)(v7++ + 1);
      v22 = v20 + 1;
      if ( v21 != *v22 )
        break;
      v23 = *(_BYTE *)(v7++ + 1);
      v8 = v22 + 1;
      if ( v23 != *v8 )
        break;
    }
    while ( v7 < v6 );
    v24 = *(_DWORD *)(a1 + 5688);
    result = v7 - v6 + 258;
    *(_DWORD *)(a1 + 5684) = a2;
    if ( result > v24 )
      result = v24;
  }
  return result;
}

//----- (10028600) --------------------------------------------------------
int __usercall sub_10028600@<eax>(int result@<eax>, int a2@<edi>, int a3)
{
  int v3; // edx@1
  int v4; // ebp@1
  int v5; // ecx@1
  bool v6; // sf@1
  unsigned __int8 v7; // of@1
  int v8; // esi@3
  int v9; // ebp@3
  unsigned __int16 v10; // dx@3
  unsigned __int16 v11; // bx@3
  int v12; // esi@8
  unsigned __int16 v13; // dx@8
  unsigned __int16 v14; // bx@8
  int v15; // edx@11
  int v16; // [sp+8h] [bp-4h]@1

  v3 = *(_DWORD *)(result + 2324);
  v4 = *(_DWORD *)(result + 4 * a3 + 32);
  v5 = 2 * a3;
  v7 = __OFSUB__(2 * a3, v3);
  v6 = 2 * a3 - v3 < 0;
  v16 = *(_DWORD *)(result + 4 * a3 + 32);
  if ( 2 * a3 > v3 )
  {
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  else
  {
    while ( 1 )
    {
      if ( v6 ^ v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v5 + 36);
        v9 = *(_DWORD *)(result + 4 * v5 + 32);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 2332) <= *(_BYTE *)(result + v9 + 2332) )
          ++v5;
        v4 = v16;
      }
      v12 = *(_DWORD *)(result + 4 * v5 + 32);
      v13 = *(_WORD *)(a2 + 4 * v4);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 32) = v4;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v4 + 2332) <= *(_BYTE *)(v12 + result + 2332) )
        break;
      *(_DWORD *)(result + 4 * a3 + 32) = v12;
      v15 = *(_DWORD *)(result + 2324);
      a3 = v5;
      v5 *= 2;
      v7 = __OFSUB__(v5, v15);
      v6 = v5 - v15 < 0;
      if ( v5 > v15 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  return result;
}

//----- (100286B0) --------------------------------------------------------
int __usercall sub_100286B0@<eax>(int result@<eax>, __int16 a2@<cx>)
{
  int v2; // edi@1

  *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = HIBYTE(a2);
  v2 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v2) = a2;
  ++*(_DWORD *)(result + 5812);
  return result;
}

//----- (100286F0) --------------------------------------------------------
unsigned int __usercall sub_100286F0@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3)
{
  int v3; // ecx@1
  unsigned int v4; // edi@1
  unsigned int result; // eax@4

  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 > a1 )
    v4 = a1;
  if ( v4 )
  {
    *(_DWORD *)(a2 + 4) -= v4;
    if ( *(_DWORD *)(v3 + 5780) == 1 )
      *(_DWORD *)(a2 + 28) = sub_1002A760(*(_DWORD *)(a2 + 28), *(_BYTE **)a2, v4);
    memcpy(a3, *(const void **)a2, v4);
    *(_DWORD *)a2 += v4;
    *(_DWORD *)(a2 + 8) += v4;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10028750) --------------------------------------------------------
signed int __usercall sub_10028750@<eax>(signed int result@<eax>, int a2@<ecx>, int a3)
{
  signed int v3; // edi@1
  signed int v4; // edx@1
  signed int v5; // ebp@1
  int v6; // ebx@1
  signed int v7; // ecx@1
  signed int v8; // esi@1
  _WORD *v9; // [sp+10h] [bp-8h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v3 = *(_WORD *)(result + 2);
  v4 = 0;
  v5 = -1;
  v6 = a2;
  v7 = 7;
  v8 = 4;
  if ( !*(_WORD *)(result + 2) )
  {
    v7 = 138;
    v8 = 3;
  }
  *(_WORD *)(result + 4 * v6 + 6) = -1;
  if ( v6 >= 0 )
  {
    v10 = v6 + 1;
    v9 = (_WORD *)(result + 6);
    do
    {
      result = v3;
      v3 = *v9;
      if ( ++v4 >= v7 || result != v3 )
      {
        if ( v4 >= v8 )
        {
          if ( result )
          {
            if ( result != v5 )
              ++*(_WORD *)(a3 + 4 * result + 5472);
            ++*(_WORD *)(a3 + 5536);
          }
          else if ( v4 > 10 )
          {
            ++*(_WORD *)(a3 + 5544);
          }
          else
          {
            ++*(_WORD *)(a3 + 5540);
          }
        }
        else
        {
          *(_WORD *)(a3 + 4 * result + 5472) += v4;
        }
        v4 = 0;
        v5 = result;
        if ( v3 )
        {
          if ( result == v3 )
          {
            v7 = 6;
            v8 = 3;
          }
          else
          {
            v7 = 7;
            v8 = 4;
          }
        }
        else
        {
          v7 = 138;
          v8 = 3;
        }
      }
      v9 += 2;
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (10028830) --------------------------------------------------------
int __usercall sub_10028830@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  signed int v3; // esi@1
  int v4; // ebx@1
  signed int v5; // ecx@1
  signed int v6; // edi@1
  signed int v7; // edx@5
  int v8; // edi@8
  int v9; // ecx@8
  unsigned __int16 v10; // si@9
  int v11; // edx@9
  int v12; // ecx@9
  int v13; // edx@9
  __int16 v14; // si@9
  int v15; // ecx@9
  int v16; // ecx@15
  unsigned __int16 v17; // si@16
  int v18; // edi@16
  int v19; // ecx@16
  int v20; // ebx@16
  int v21; // ecx@16
  int v22; // ecx@19
  unsigned __int16 v23; // si@20
  int v24; // edi@20
  int v25; // ecx@20
  int v26; // ebx@20
  int v27; // ecx@20
  int v28; // esi@22
  int v29; // edi@23
  int v30; // ecx@23
  int v31; // ebx@23
  int v32; // ecx@24
  int v33; // ecx@25
  unsigned __int16 v34; // si@27
  int v35; // edi@27
  int v36; // ecx@27
  int v37; // ebx@27
  int v38; // ecx@27
  int v39; // esi@29
  int v40; // edi@30
  int v41; // ecx@30
  int v42; // ebx@30
  unsigned __int16 v43; // si@33
  int v44; // edi@33
  int v45; // ecx@33
  int v46; // ebx@33
  int v47; // ecx@33
  int v48; // esi@35
  int v49; // edi@36
  int v50; // ecx@36
  int v51; // ebx@36
  signed int v52; // [sp+10h] [bp-18h]@5
  signed int v53; // [sp+14h] [bp-14h]@1
  _WORD *v54; // [sp+18h] [bp-10h]@4
  signed int v55; // [sp+1Ch] [bp-Ch]@1
  int v56; // [sp+1Ch] [bp-Ch]@15
  int v57; // [sp+1Ch] [bp-Ch]@19
  int v58; // [sp+1Ch] [bp-Ch]@26
  int v59; // [sp+1Ch] [bp-Ch]@32
  int v60; // [sp+20h] [bp-8h]@4
  signed int v61; // [sp+24h] [bp-4h]@5

  v3 = 0;
  v4 = a3;
  v5 = 7;
  v6 = 4;
  v53 = *(_WORD *)(a2 + 2);
  v55 = -1;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( v4 >= 0 )
  {
    v54 = (_WORD *)(a2 + 6);
    v60 = v4 + 1;
    do
    {
      v7 = v53;
      ++v3;
      v61 = v53;
      v53 = *v54;
      v52 = v3;
      if ( v3 < v5 && v7 == *v54 )
        goto LABEL_44;
      if ( v3 < v6 )
      {
        do
        {
          v8 = *(_WORD *)(result + 4 * v7 + 5474);
          v9 = *(_DWORD *)(result + 2932);
          if ( v9 <= 16 - v8 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v15 = v8 + v9;
          }
          else
          {
            v10 = *(_WORD *)(result + 4 * v7 + 5472);
            v11 = *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v12 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v11;
            *(_BYTE *)(v12 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v13 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v14 = v10 >> (16 - v13);
            v15 = v13 + v8 - 16;
            v7 = v61;
            *(_WORD *)(result + 2924) = v14;
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v15;
          v52 = v3;
        }
        while ( v3 );
        goto LABEL_39;
      }
      if ( v7 )
      {
        if ( v7 != v55 )
        {
          v16 = *(_DWORD *)(result + 2932);
          v56 = *(_WORD *)(result + 4 * v7 + 5474);
          if ( v16 <= 16 - v56 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v21 = v56 + v16;
          }
          else
          {
            v17 = *(_WORD *)(result + 4 * v7 + 5472);
            v18 = *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v19 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v18;
            *(_BYTE *)(v19 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v20 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v21 = v20 + v56 - 16;
            *(_WORD *)(result + 2924) = v17 >> (16 - v20);
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v21;
          v52 = v3;
        }
        v22 = *(_DWORD *)(result + 2932);
        v57 = *(_WORD *)(result + 5538);
        if ( v22 <= 16 - v57 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5536) << v22;
          v27 = v57 + v22;
        }
        else
        {
          v23 = *(_WORD *)(result + 5536);
          v24 = *(_WORD *)(result + 5536) << v22;
          v25 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v24;
          *(_BYTE *)(v25 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v26 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v27 = v26 + v57 - 16;
          *(_WORD *)(result + 2924) = v23 >> (16 - v26);
          v3 = v52;
        }
        v28 = v3 - 3;
        *(_DWORD *)(result + 2932) = v27;
        if ( v27 > 14 )
        {
          v29 = v28 << v27;
          v30 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v29;
          *(_BYTE *)(v30 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v31 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          *(_DWORD *)(result + 2932) = v31 - 14;
          *(_WORD *)(result + 2924) = (unsigned __int16)v28 >> (16 - v31);
          goto LABEL_39;
        }
        *(_WORD *)(result + 2924) |= v28 << v27;
        v32 = v27 + 2;
      }
      else
      {
        v33 = *(_DWORD *)(result + 2932);
        if ( v3 > 10 )
        {
          v59 = *(_WORD *)(result + 5546);
          if ( v33 <= 16 - v59 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5544) << v33;
            v47 = v59 + v33;
          }
          else
          {
            v43 = *(_WORD *)(result + 5544);
            v44 = *(_WORD *)(result + 5544) << v33;
            v45 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v44;
            *(_BYTE *)(v45 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v46 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v47 = v46 + v59 - 16;
            *(_WORD *)(result + 2924) = v43 >> (16 - v46);
            v3 = v52;
          }
          v48 = v3 - 11;
          *(_DWORD *)(result + 2932) = v47;
          if ( v47 > 9 )
          {
            v49 = v48 << v47;
            v50 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v49;
            *(_BYTE *)(v50 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v51 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v51 - 9;
            *(_WORD *)(result + 2924) = (unsigned __int16)v48 >> (16 - v51);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v48 << v47;
          v32 = v47 + 7;
        }
        else
        {
          v58 = *(_WORD *)(result + 5542);
          if ( v33 <= 16 - v58 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5540) << v33;
            v38 = v58 + v33;
          }
          else
          {
            v34 = *(_WORD *)(result + 5540);
            v35 = *(_WORD *)(result + 5540) << v33;
            v36 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v35;
            *(_BYTE *)(v36 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v37 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v38 = v37 + v58 - 16;
            *(_WORD *)(result + 2924) = v34 >> (16 - v37);
            v3 = v52;
          }
          v39 = v3 - 3;
          *(_DWORD *)(result + 2932) = v38;
          if ( v38 > 13 )
          {
            v40 = v39 << v38;
            v41 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v40;
            *(_BYTE *)(v41 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v42 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v42 - 13;
            *(_WORD *)(result + 2924) = (unsigned __int16)v39 >> (16 - v42);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v39 << v38;
          v32 = v38 + 3;
        }
      }
      *(_DWORD *)(result + 2932) = v32;
LABEL_39:
      v3 = 0;
      v55 = v7;
      if ( v53 )
      {
        if ( v7 == v53 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v54 += 2;
      --v60;
    }
    while ( v60 );
  }
  return result;
}

//----- (10028DD0) --------------------------------------------------------
_WORD *__fastcall sub_10028DD0(int a1, int a2)
{
  *(_DWORD *)(a2 + 5628) = a2 + 2936;
  *(_DWORD *)(a2 + 5652) = a2 + 5472;
  *(_DWORD *)(a2 + 5636) = &off_1008DBD4;
  *(_DWORD *)(a2 + 5640) = a2 + 5228;
  *(_DWORD *)(a2 + 5648) = &off_1008DBE8;
  *(_DWORD *)(a2 + 5660) = &unk_1008DBFC;
  *(_WORD *)(a2 + 2924) = 0;
  *(_DWORD *)(a2 + 2932) = 0;
  *(_DWORD *)(a2 + 2928) = 8;
  return sub_10028250(a2 + 5228, a2);
}
// 1008DBD4: using guessed type void *off_1008DBD4;
// 1008DBE8: using guessed type void *off_1008DBE8;

//----- (10028E30) --------------------------------------------------------
signed int __cdecl sub_10028E30(int a1)
{
  int v1; // esi@2
  int v2; // eax@3
  int v3; // ecx@5
  signed int result; // eax@5

  if ( a1 && (v1 = *(_DWORD *)(a1 + 24)) != 0 )
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(v1 + 5808) = *(_DWORD *)(v1 + 5800);
    v2 = *(_DWORD *)(v1 + 5780);
    *(_DWORD *)(v1 + 5812) = 0;
    if ( v2 < 0 )
      *(_DWORD *)(v1 + 5780) = -v2;
    *(_DWORD *)(v1 + 5788) = *(_DWORD *)(v1 + 5780) != 0 ? 42 : 113;
    *(_DWORD *)(a1 + 28) = sub_1002A760(0, 0, 0);
    *(_DWORD *)(v1 + 5792) = 0;
    sub_10028DD0(v3, v1);
    sub_100282C0(v1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10028EC0) --------------------------------------------------------
int __usercall sub_10028EC0@<eax>(int a1@<eax>)
{
  signed int v1; // ecx@1
  int v2; // edx@2
  signed int v3; // ecx@4
  int v4; // edx@5
  int result; // eax@7
  signed int v6; // ecx@7
  int v7; // edx@9
  signed int v8; // ecx@11
  int v9; // edx@12

  v1 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) |= 2 << v1;
  if ( v1 <= 13 )
  {
    *(_DWORD *)(a1 + 2932) = v1 + 3;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v2 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v2 - 13;
    *(_WORD *)(a1 + 2924) = 2u >> (16 - v2);
  }
  v3 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) = *(_WORD *)(a1 + 2924);
  if ( v3 <= 9 )
  {
    *(_DWORD *)(a1 + 2932) = v3 + 7;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v4 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v4 - 9;
    *(_WORD *)(a1 + 2924) = 0;
  }
  result = sub_10027930(a1);
  v6 = *(_DWORD *)(result + 2932);
  if ( *(_DWORD *)(result + 2928) - v6 + 11 < 9 )
  {
    *(_WORD *)(result + 2924) |= 2 << v6;
    if ( v6 <= 13 )
    {
      *(_DWORD *)(result + 2932) = v6 + 3;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v7 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v7 - 13;
      *(_WORD *)(result + 2924) = 2u >> (16 - v7);
    }
    v8 = *(_DWORD *)(result + 2932);
    *(_WORD *)(result + 2924) = *(_WORD *)(result + 2924);
    if ( v8 > 9 )
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v9 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v9 - 9;
      *(_WORD *)(result + 2924) = 0;
      result = sub_10027930(result);
      *(_DWORD *)(result + 2928) = 7;
      return result;
    }
    *(_DWORD *)(result + 2932) = v8 + 7;
    result = sub_10027930(result);
  }
  *(_DWORD *)(result + 2928) = 7;
  return result;
}

//----- (10029100) --------------------------------------------------------
int __usercall sub_10029100@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4)
{
  int v4; // esi@1
  signed int v5; // ecx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  int result; // eax@2

  v4 = a2;
  v5 = *(_DWORD *)(a1 + 2932);
  if ( v5 <= 13 )
  {
    *(_WORD *)(a1 + 2924) |= v4 << v5;
    *(_DWORD *)(a1 + 2932) = v5 + 3;
    result = sub_10027EF0(a1, a3, a4);
  }
  else
  {
    v6 = v4 << v5;
    v7 = *(_DWORD *)(a1 + 5800);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) = (unsigned __int16)v4 >> (16 - v8);
    *(_DWORD *)(a1 + 2932) = v8 - 13;
    result = sub_10027EF0(a1, a3, a4);
  }
  return result;
}

//----- (100291A0) --------------------------------------------------------
signed int __usercall sub_100291A0@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax@1
  int v3; // ebp@1
  signed int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@1
  signed int v7; // eax@8
  signed int i; // ebp@14
  int v9; // ebx@16
  int v10; // eax@17
  int v11; // edx@17
  int v12; // ebp@17
  int v13; // eax@17
  unsigned __int8 v14; // cl@17
  int v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)v2;
  v17 = *(_DWORD *)(v2 + 12);
  v4 = -1;
  v5 = *(_DWORD *)a2;
  v6 = 0;
  v16 = -1;
  *(_DWORD *)(a1 + 2324) = 0;
  for ( *(_DWORD *)(a1 + 2328) = 573; v6 < v17; ++v6 )
  {
    if ( *(_WORD *)(v5 + 4 * v6) )
    {
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v6;
      v16 = v6;
      *(_BYTE *)(v6 + a1 + 2332) = 0;
      v4 = v6;
    }
    else
    {
      *(_WORD *)(v5 + 4 * v6 + 2) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 2324) < 2 )
  {
    do
    {
      if ( v4 >= 2 )
        v7 = 0;
      else
        v7 = ++v4;
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v7;
      *(_WORD *)(v5 + 4 * v7) = 1;
      *(_BYTE *)(a1 + v7 + 2332) = 0;
      --*(_DWORD *)(a1 + 2912);
      if ( v3 )
        *(_DWORD *)(a1 + 2916) -= *(_WORD *)(v3 + 4 * v7 + 2);
    }
    while ( *(_DWORD *)(a1 + 2324) < 2 );
    v16 = v4;
  }
  *(_DWORD *)(a2 + 4) = v4;
  for ( i = *(_DWORD *)(a1 + 2324) / 2; i >= 1; --i )
    sub_10028600(a1, v5, i);
  v9 = v17;
  do
  {
    v10 = *(_DWORD *)(a1 + 2324);
    v11 = *(_DWORD *)(a1 + 4 * v10 + 32);
    v12 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 2324) = v10 - 1;
    *(_DWORD *)(a1 + 36) = v11;
    sub_10028600(a1, v5, 1);
    v13 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v12;
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v13;
    *(_WORD *)(v5 + 4 * v9) = *(_WORD *)(v5 + 4 * v12) + *(_WORD *)(v5 + 4 * v13);
    v14 = *(_BYTE *)(a1 + v13 + 2332);
    if ( *(_BYTE *)(a1 + v12 + 2332) >= v14 )
      v14 = *(_BYTE *)(a1 + v12 + 2332);
    *(_BYTE *)(a1 + v9 + 2332) = v14 + 1;
    *(_WORD *)(v5 + 4 * v13 + 2) = v9;
    *(_WORD *)(v5 + 4 * v12 + 2) = v9;
    *(_DWORD *)(a1 + 36) = v9++;
    sub_10028600(a1, v5, 1);
  }
  while ( *(_DWORD *)(a1 + 2324) >= 2 );
  *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = *(_DWORD *)(a1 + 36);
  sub_10028000(a1, a2);
  return sub_100281D0(a1, v16, v5);
}

//----- (10029380) --------------------------------------------------------
unsigned int __usercall sub_10029380@<eax>(int a1@<edi>)
{
  size_t v1; // ebx@1
  unsigned int result; // eax@2
  unsigned int v3; // ebp@2
  int v4; // edx@3
  int v5; // eax@3
  _WORD *v6; // ecx@3
  int v7; // eax@4
  __int16 v8; // ax@5
  size_t v9; // edx@8
  _WORD *v10; // ecx@8
  int v11; // eax@9
  int v12; // esi@14
  unsigned int v13; // edx@15
  int v14; // esi@16
  int v15; // eax@16
  int v16; // ecx@16

  v1 = *(_DWORD *)(a1 + 5748);
  do
  {
    result = *(_DWORD *)(a1 + 5680);
    v3 = *(_DWORD *)(a1 + 5744) - result - *(_DWORD *)(a1 + 5688);
    if ( result >= v1 + *(_DWORD *)(a1 + 5748) - 262 )
    {
      memcpy(*(void **)(a1 + 5740), (const void *)(*(_DWORD *)(a1 + 5740) + v1), v1);
      v4 = *(_DWORD *)(a1 + 5764);
      v5 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5684) -= v1;
      *(_DWORD *)(a1 + 5680) -= v1;
      *(_DWORD *)(a1 + 5664) -= v1;
      v6 = (_WORD *)(v5 + 2 * v4);
      do
      {
        v7 = *(v6 - 1);
        --v6;
        if ( v7 < v1 )
          v8 = 0;
        else
          v8 = v7 - v1;
        --v4;
        *v6 = v8;
      }
      while ( v4 );
      v9 = v1;
      v10 = (_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * v1);
      do
      {
        v11 = *(v10 - 1);
        --v10;
        if ( v11 < v1 )
          result = 0;
        else
          result = v11 - v1;
        --v9;
        *v10 = result;
      }
      while ( v9 );
      v3 += v1;
    }
    v12 = *(_DWORD *)(a1 + 2908);
    if ( !*(_DWORD *)(v12 + 4) )
      break;
    result = sub_100286F0(v3, v12, (void *)(*(_DWORD *)(a1 + 5688) + *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)));
    *(_DWORD *)(a1 + 5688) += result;
    v13 = *(_DWORD *)(a1 + 5688);
    if ( v13 >= 3 )
    {
      v14 = *(_DWORD *)(a1 + 5680) + *(_DWORD *)(a1 + 5740);
      v15 = *(_BYTE *)v14;
      v16 = *(_DWORD *)(a1 + 5776);
      *(_DWORD *)(a1 + 5760) = v15;
      result = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v14 + 1) ^ (v15 << v16));
      *(_DWORD *)(a1 + 5760) = result;
    }
  }
  while ( v13 < 0x106 && *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 4) );
  return result;
}

//----- (100294C0) --------------------------------------------------------
int __usercall sub_100294C0@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  signed int v9; // ecx@4
  int v10; // edx@5
  int v11; // ecx@5
  int v12; // edx@5
  signed int v13; // ecx@7
  int v14; // edx@8
  int v15; // ecx@8
  int v16; // edx@8
  int i; // edi@10
  signed int v18; // ecx@11
  int v19; // edx@11
  unsigned __int16 v20; // si@12
  int v21; // edx@12
  int v22; // ecx@12
  int v23; // edx@12
  int v24; // eax@15

  v4 = *(_DWORD *)(a1 + 2932);
  v5 = a4;
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 2932) = v4 + 5;
  }
  else
  {
    v6 = (a2 - 257) << v4;
    v7 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    v5 = a4;
    *(_DWORD *)(a1 + 2932) = v8 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a2 - 257) >> (16 - v8);
  }
  v9 = *(_DWORD *)(a1 + 2932);
  if ( v9 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a3 - 1) << v9;
    *(_DWORD *)(a1 + 2932) = v9 + 5;
  }
  else
  {
    v10 = (a3 - 1) << v9;
    v11 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v10;
    *(_BYTE *)(v11 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v12 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v12 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a3 - 1) >> (16 - v12);
  }
  v13 = *(_DWORD *)(a1 + 2932);
  if ( v13 <= 12 )
  {
    *(_WORD *)(a1 + 2924) |= (v5 - 4) << v13;
    *(_DWORD *)(a1 + 2932) = v13 + 4;
  }
  else
  {
    v14 = (v5 - 4) << v13;
    v15 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v14;
    *(_BYTE *)(v15 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v16 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v16 - 12;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(v5 - 4) >> (16 - v16);
  }
  for ( i = 0; i < v5; ++i )
  {
    v18 = *(_DWORD *)(a1 + 2932);
    v19 = (unsigned __int8)byte_1008D0AC[i];
    if ( v18 <= 13 )
    {
      *(_WORD *)(a1 + 2924) |= *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      *(_DWORD *)(a1 + 2932) = v18 + 3;
    }
    else
    {
      v20 = *(_WORD *)(a1 + 4 * v19 + 5474);
      v21 = *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      v22 = *(_DWORD *)(a1 + 5812);
      *(_WORD *)(a1 + 2924) |= v21;
      *(_BYTE *)(v22 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
      *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
      v23 = *(_DWORD *)(a1 + 2932);
      ++*(_DWORD *)(a1 + 5812);
      v5 = a4;
      *(_DWORD *)(a1 + 2932) = v23 - 13;
      *(_WORD *)(a1 + 2924) = v20 >> (16 - v23);
    }
  }
  v24 = sub_10028830(a1, a1 + 2936, a2 - 1);
  return sub_10028830(v24, v24 + 5228, a3 - 1);
}

//----- (10029770) --------------------------------------------------------
signed int __cdecl sub_10029770(int a1, int a2)
{
  int v2; // esi@3
  int v3; // eax@6
  signed int result; // eax@9
  int v5; // ebx@10
  char v6; // al@12
  int v7; // eax@14
  unsigned int v8; // ecx@17
  int v9; // eax@19
  int v10; // eax@20
  int v11; // eax@29
  signed int v12; // eax@36
  int v13; // eax@50
  bool v14; // zf@50

  if ( !a1 || (unsigned int)a2 > 4 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  if ( !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) )
    return -2;
  v3 = *(_DWORD *)(v2 + 5788);
  if ( v3 == 666 && a2 != 4 )
    return -2;
  if ( !*(_DWORD *)(a1 + 16) )
    return -5;
  v5 = *(_DWORD *)(v2 + 5792);
  *(_DWORD *)(v2 + 2908) = a1;
  *(_DWORD *)(v2 + 5792) = a2;
  if ( v3 == 42 )
  {
    if ( *(_BYTE *)(v2 + 5796) >= 2 || (v6 = *(_BYTE *)(v2 + 5784), v6 < 2) )
    {
      v7 = 0;
    }
    else if ( v6 >= 6 )
    {
      v7 = (v6 != 6) + 2;
    }
    else
    {
      v7 = 1;
    }
    v8 = (v7 << 6) | (((*(_DWORD *)(v2 + 5752) - 8) << 12) + 2048);
    if ( *(_DWORD *)(v2 + 5680) )
      v8 |= 0x20u;
    *(_DWORD *)(v2 + 5788) = 113;
    v9 = sub_100286B0(v2, 31 * (v8 / 0x1F + 1));
    if ( *(_DWORD *)(v2 + 5680) )
    {
      v10 = sub_100286B0(v9, *(_WORD *)(a1 + 30));
      sub_100286B0(v10, *(_WORD *)(a1 + 28));
    }
    *(_DWORD *)(a1 + 28) = sub_1002A760(0, 0, 0);
  }
  if ( *(_DWORD *)(v2 + 5812) )
  {
    sub_10027FA0(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
LABEL_24:
      *(_DWORD *)(v2 + 5792) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v5 && a2 != 4 )
  {
    return -5;
  }
  v11 = *(_DWORD *)(v2 + 5788);
  if ( v11 == 666 )
  {
    if ( *(_DWORD *)(a1 + 4) )
      return -5;
LABEL_33:
    if ( !*(_DWORD *)(v2 + 5688) && (!a2 || v11 == 666) )
      goto LABEL_47;
    goto LABEL_36;
  }
  if ( !*(_DWORD *)(a1 + 4) )
    goto LABEL_33;
LABEL_36:
  v12 = (*(&off_1008DA28 + 3 * *(_BYTE *)(v2 + 5784)))(v2, a2);
  if ( v12 == 2 || v12 == 3 )
    *(_DWORD *)(v2 + 5788) = 666;
  if ( !v12 || v12 == 2 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      return 0;
    *(_DWORD *)(v2 + 5792) = -1;
    return 0;
  }
  if ( v12 == 1 )
  {
    if ( a2 == 1 )
    {
      sub_10028EC0(v2);
    }
    else
    {
      sub_10029100(v2, 0, 0, 0);
      if ( a2 == 3 )
      {
        *(_WORD *)(*(_DWORD *)(v2 + 5736) + 2 * *(_DWORD *)(v2 + 5764) - 2) = 0;
        memset(*(void **)(v2 + 5736), 0, 2 * *(_DWORD *)(v2 + 5764) - 2);
      }
    }
    sub_10027FA0(a1);
    if ( !*(_DWORD *)(a1 + 16) )
      goto LABEL_24;
  }
LABEL_47:
  if ( a2 != 4 )
    return 0;
  if ( *(_DWORD *)(v2 + 5780) > 0 )
  {
    v13 = sub_100286B0(v2, *(_WORD *)(a1 + 30));
    sub_100286B0(v13, *(_WORD *)(a1 + 28));
    sub_10027FA0(a1);
    v14 = *(_DWORD *)(v2 + 5812) == 0;
    *(_DWORD *)(v2 + 5780) = -*(_DWORD *)(v2 + 5780);
    result = v14;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 1008DA28: using guessed type int (__cdecl *off_1008DA28)(int, int);

//----- (10029A30) --------------------------------------------------------
signed int __cdecl sub_10029A30(int a1, unsigned __int8 a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8)
{
  signed int v8; // edx@1
  int v9; // eax@5
  unsigned int v10; // edi@12
  signed int v11; // ebp@12
  signed int v12; // eax@12
  int v13; // ebp@14
  int v14; // esi@14
  int v15; // esi@14
  int v16; // esi@14
  signed int result; // eax@14

  v8 = 1;
  if ( a1 && a7 )
  {
    if ( a2 == -1 )
      a2 = 6;
    v9 = a4;
    if ( a4 < 0 )
    {
      v8 = 0;
      v9 = -a4;
      a4 = -a4;
    }
    if ( (unsigned int)(a5 - 1) > 7 || a3 != 8 || (unsigned int)(v9 - 9) > 6 || a2 > 9u || a6 > 3u )
    {
      result = -2;
    }
    else
    {
      v10 = 1 << (a5 + 6);
      v11 = 1 << v9;
      v12 = 1 << (a5 + 7);
      if ( (signed int)(2 * (v12 + 2 * (v10 + v11) + 2908)) > a8 || a7 & 3 )
      {
        result = -4;
      }
      else
      {
        *(_DWORD *)(a1 + 24) = a7;
        *(_DWORD *)(a7 + 5780) = v8;
        *(_DWORD *)(a7 + 5764) = v12;
        *(_DWORD *)(a7 + 5752) = a4;
        *(_DWORD *)(a7 + 5768) = a5 + 7;
        *(_DWORD *)(a7 + 5772) = v12 - 1;
        *(_DWORD *)(a7 + 5756) = v11 - 1;
        *(_DWORD *)(a7 + 5748) = v11;
        *(_DWORD *)(a7 + 5740) = a7 + 5816;
        v13 = 2 * v11;
        v14 = v13 + a7 + 5816;
        *(_DWORD *)(a7 + 5732) = v14;
        v15 = v13 + v14;
        *(_DWORD *)(a7 + 5776) = (a5 + 9) / 3u;
        *(_DWORD *)(a7 + 5736) = v15;
        v16 = v15 + 2 * (1 << (a5 + 7));
        *(_DWORD *)(a7 + 5804) = 4 * v10;
        *(_DWORD *)(a7 + 5716) = v10 + v16 + 2 * v10;
        *(_DWORD *)(a7 + 5712) = v16 + 2 * (v10 >> 1);
        *(_DWORD *)(a7 + 5724) = v10;
        *(_DWORD *)(a7 + 5800) = v16;
        *(_BYTE *)(a7 + 5784) = a2;
        *(_BYTE *)(a7 + 5796) = a6;
        *(_BYTE *)(a7 + 5720) = 8;
        result = sub_10028E30(a1);
      }
    }
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10029BE0) --------------------------------------------------------
signed int __usercall sub_10029BE0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  signed int result; // eax@1

  v1 = a1;
  sub_10028750(a1 + 2936, *(_DWORD *)(a1 + 5632), a1);
  sub_10028750(v1 + 5228, *(_DWORD *)(v1 + 5644), v1);
  sub_100291A0(v1, v1 + 5652);
  result = 18;
  while ( !*(_WORD *)(v1 + 4 * (unsigned __int8)byte_1008D0AC[result] + 5474) )
  {
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_1008D0AB[result] + 5474) )
    {
      *(_DWORD *)(v1 + 2912) += 3 * --result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_1008D0AA[result] + 5474) )
    {
      result -= 2;
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_1008D0A9[result] + 5474) )
    {
      result -= 3;
      break;
    }
    result -= 4;
    if ( result < 3 )
    {
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
  }
  *(_DWORD *)(v1 + 2912) += 3 * result + 17;
  return result;
}

//----- (10029CB0) --------------------------------------------------------
_WORD *__usercall sub_10029CB0@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // eax@1
  _BYTE *v7; // edi@2
  signed int v8; // eax@5
  unsigned int v9; // edx@5
  unsigned int v10; // ecx@5
  int v11; // ecx@11
  bool v12; // zf@12
  signed int v13; // ecx@12
  int v14; // eax@13
  int v15; // edx@14
  int v16; // ecx@14
  int v17; // edx@14
  int v18; // edx@17
  int v19; // eax@18
  int v20; // ecx@18
  int v21; // ebx@18
  _WORD *result; // eax@21
  signed int v23; // [sp+14h] [bp+4h]@4

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(_DWORD *)(a2 + 5664);
  if ( v6 < 0 )
    v7 = 0;
  else
    v7 = (_BYTE *)(v6 + *(_DWORD *)(a2 + 5740));
  v23 = 0;
  if ( *(_BYTE *)(a2 + 5784) <= 0 )
  {
    v10 = v5 + 5;
LABEL_8:
    v9 = v10;
    goto LABEL_9;
  }
  sub_100291A0(a2, a2 + 5628);
  sub_100291A0(v4, v4 + 5640);
  v8 = sub_10029BE0(v4);
  v9 = (unsigned int)(*(_DWORD *)(v4 + 2912) + 10) >> 3;
  v10 = (unsigned int)(*(_DWORD *)(v4 + 2916) + 10) >> 3;
  v23 = v8;
  if ( v10 <= v9 )
    goto LABEL_8;
LABEL_9:
  if ( v5 + 4 <= v9 && v7 )
  {
    sub_10029100(v4, v3, v7, v5);
  }
  else
  {
    v12 = v10 == v9;
    v13 = *(_DWORD *)(v4 + 2932);
    if ( v12 )
    {
      v14 = v3 + 2;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v14 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v15 = v14 << v13;
        v16 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v15;
        *(_BYTE *)(v16 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v17 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v17 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v14 >> (16 - v17);
      }
      sub_10027A70(v4, (int)&unk_1008D138, (int)&unk_1008D5B8);
    }
    else
    {
      v18 = v3 + 4;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v18 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v19 = v18 << v13;
        v20 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v19;
        *(_BYTE *)(v20 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v21 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v21 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v18 >> (16 - v21);
      }
      sub_100294C0(v4, *(_DWORD *)(v4 + 5632) + 1, *(_DWORD *)(v4 + 5644) + 1, v23 + 1);
      sub_10027A70(v4, v4 + 2936, v4 + 5228);
    }
  }
  result = sub_10028250(v11, v4);
  if ( v3 )
    result = (_WORD *)sub_100279E0(v4);
  return result;
}

//----- (10029ED0) --------------------------------------------------------
signed int __cdecl sub_10029ED0(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  int v4; // edx@7
  int v5; // edi@7
  int v6; // eax@7
  int v7; // ecx@7
  unsigned int v8; // eax@9
  char v9; // cl@10
  unsigned int v10; // eax@11
  unsigned int v11; // eax@16
  BOOL v12; // eax@17
  unsigned int v13; // ecx@17
  int v14; // edi@20
  int v15; // ecx@20
  int v16; // edx@20
  int v17; // ebx@20
  int v19; // edi@22
  int v20; // ecx@22
  int v21; // edx@22
  int v22; // edi@26
  signed int result; // eax@27
  int v24; // edi@28
  int v25; // eax@28

  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_10029380(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    if ( v2 )
    {
      v8 = *(_DWORD *)(a1 + 5680) - v2;
      if ( v8 <= *(_DWORD *)(a1 + 5748) - 262 )
      {
        v9 = *(_BYTE *)(a1 + 5796);
        if ( v9 < 2 )
        {
          v10 = sub_10028380(a1, v2);
LABEL_15:
          *(_DWORD *)(a1 + 5668) = v10;
          goto LABEL_16;
        }
        if ( v9 == 3 && v8 == 1 )
        {
          v10 = sub_10028530(a1, v2);
          goto LABEL_15;
        }
      }
    }
LABEL_16:
    v11 = *(_DWORD *)(a1 + 5668);
    if ( v11 < 3 )
    {
      v12 = sub_10027890(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)), 0);
      --*(_DWORD *)(a1 + 5688);
    }
    else
    {
      v12 = sub_10027890(a1, v11 - 3, *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684));
      v13 = *(_DWORD *)(a1 + 5668);
      *(_DWORD *)(a1 + 5688) -= v13;
      if ( v13 > *(_DWORD *)(a1 + 5700) || *(_DWORD *)(a1 + 5688) < 3u )
      {
        *(_DWORD *)(a1 + 5680) += v13;
        v19 = *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680);
        v20 = *(_DWORD *)(a1 + 5776);
        *(_DWORD *)(a1 + 5668) = 0;
        v21 = *(_BYTE *)v19;
        *(_DWORD *)(a1 + 5760) = v21;
        *(_DWORD *)(a1 + 5760) = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v19 + 1) ^ (v21 << v20));
        goto LABEL_25;
      }
      *(_DWORD *)(a1 + 5668) = v13 - 1;
      do
      {
        v14 = ++*(_DWORD *)(a1 + 5680);
        v15 = *(_DWORD *)(a1 + 5736);
        v16 = *(_DWORD *)(a1 + 5772) & ((*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)) ^ *(_BYTE *)(*(_DWORD *)(a1 + 5740) + v14 + 2));
        v17 = *(_DWORD *)(a1 + 5756);
        *(_DWORD *)(a1 + 5760) = v16;
        *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v14 & v17)) = *(_WORD *)(v15 + 2 * v16);
        v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
        *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
      }
      while ( (*(_DWORD *)(a1 + 5668))-- != 1 );
    }
    ++*(_DWORD *)(a1 + 5680);
LABEL_25:
    if ( v12 )
    {
      sub_10029CB0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
      v22 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_10027FA0(v22);
      if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        return 0;
    }
  }
  sub_10029CB0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v24 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10027FA0(v24);
  v25 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v25) = a2 == 4;
    result = 2 * v25 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (1002A1E0) --------------------------------------------------------
signed int __cdecl sub_1002A1E0(int a1, int a2)
{
  unsigned int v2; // ebp@1
  unsigned int v3; // eax@3
  int v4; // edx@8
  int v5; // edi@8
  int v6; // eax@8
  int v7; // ecx@8
  unsigned int v8; // ecx@9
  int v9; // edx@9
  unsigned int v10; // eax@11
  char v11; // cl@12
  unsigned int v12; // eax@13
  unsigned int v13; // eax@18
  unsigned int v14; // eax@23
  int v15; // ecx@25
  unsigned int v16; // ebp@25
  BOOL v17; // eax@25
  int v18; // ecx@25
  BOOL v19; // ebx@25
  unsigned int v20; // edi@26
  int v21; // ecx@27
  int v22; // edx@27
  int v23; // eax@27
  int v25; // eax@29
  int v26; // edi@30
  signed int result; // eax@31
  int v28; // edi@34
  int v29; // ecx@35
  int v30; // edi@40
  unsigned int v31; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v31 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_10029380(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    v8 = *(_DWORD *)(a1 + 5668);
    v9 = *(_DWORD *)(a1 + 5684);
    *(_DWORD *)(a1 + 5692) = v8;
    *(_DWORD *)(a1 + 5672) = v9;
    *(_DWORD *)(a1 + 5668) = 2;
    if ( !v2 )
      goto LABEL_23;
    if ( v8 >= *(_DWORD *)(a1 + 5700) )
      goto LABEL_23;
    v10 = *(_DWORD *)(a1 + 5680) - v2;
    if ( v10 > *(_DWORD *)(a1 + 5748) - 262 )
      goto LABEL_23;
    v11 = *(_BYTE *)(a1 + 5796);
    if ( v11 < 2 )
    {
      v12 = sub_10028380(a1, v2);
LABEL_17:
      *(_DWORD *)(a1 + 5668) = v12;
      goto LABEL_18;
    }
    if ( v11 == 3 && v10 == 1 )
    {
      v12 = sub_10028530(a1, v2);
      goto LABEL_17;
    }
LABEL_18:
    v13 = *(_DWORD *)(a1 + 5668);
    if ( v13 <= 5
      && (*(_BYTE *)(a1 + 5796) == 1
       || v13 == 3 && (unsigned int)(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684)) > 0x1000) )
    {
      *(_DWORD *)(a1 + 5668) = 2;
    }
LABEL_23:
    v14 = *(_DWORD *)(a1 + 5692);
    if ( v14 < 3 || *(_DWORD *)(a1 + 5668) > v14 )
    {
      if ( *(_DWORD *)(a1 + 5676) )
      {
        if ( sub_10027890(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0) )
        {
          sub_10029CB0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
          v28 = *(_DWORD *)(a1 + 2908);
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
          sub_10027FA0(v28);
        }
        v29 = *(_DWORD *)(a1 + 2908);
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        if ( !*(_DWORD *)(v29 + 16) )
          return 0;
      }
      else
      {
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        *(_DWORD *)(a1 + 5676) = 1;
      }
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 5680);
      v16 = v15 + *(_DWORD *)(a1 + 5688) - 3;
      v17 = sub_10027890(a1, v14 - 3, v15 - *(_DWORD *)(a1 + 5672) - 1);
      v18 = *(_DWORD *)(a1 + 5692);
      v19 = v17;
      *(_DWORD *)(a1 + 5688) += 1 - v18;
      *(_DWORD *)(a1 + 5692) = v18 - 2;
      do
      {
        v20 = ++*(_DWORD *)(a1 + 5680);
        if ( v20 <= v16 )
        {
          v21 = *(_DWORD *)(a1 + 5736);
          v22 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v20 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
          v23 = *(_DWORD *)(a1 + 5756);
          *(_DWORD *)(a1 + 5760) = v22;
          *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v20 & v23)) = *(_WORD *)(v21 + 2 * v22);
          v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
          *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
        }
      }
      while ( (*(_DWORD *)(a1 + 5692))-- != 1 );
      v25 = ++*(_DWORD *)(a1 + 5680);
      *(_DWORD *)(a1 + 5676) = 0;
      *(_DWORD *)(a1 + 5668) = 2;
      if ( v19 )
      {
        sub_10029CB0(v25 - *(_DWORD *)(a1 + 5664), a1, 0);
        v26 = *(_DWORD *)(a1 + 2908);
        *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
        sub_10027FA0(v26);
        if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
          return 0;
      }
      v2 = v31;
    }
  }
  if ( *(_DWORD *)(a1 + 5676) )
  {
    sub_10027890(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0);
    *(_DWORD *)(a1 + 5676) = 0;
  }
  sub_10029CB0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v30 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10027FA0(v30);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
    result = 2 * (a2 == 4) + 1;
  else
    result = a2 != 4 ? 0 : 2;
  return result;
}

//----- (1002A5F0) --------------------------------------------------------
signed int __cdecl sub_1002A5F0(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // eax@3
  bool v4; // zf@5
  int v5; // edx@5
  unsigned int v6; // ecx@5
  unsigned int v7; // eax@5
  int v8; // edi@7
  unsigned int v9; // eax@8
  int v10; // edi@9
  signed int result; // eax@10
  int v12; // edi@12
  int v13; // eax@12

  v2 = 0xFFFF;
  if ( (unsigned int)(*(_DWORD *)(a1 + 5804) - 5) <= 0xFFFF )
    v2 = *(_DWORD *)(a1 + 5804) - 5;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 <= 1 )
    {
      sub_10029380(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( !v3 )
        break;
    }
    v4 = v3 + *(_DWORD *)(a1 + 5680) == 0;
    *(_DWORD *)(a1 + 5680) += v3;
    v5 = *(_DWORD *)(a1 + 5664);
    v6 = *(_DWORD *)(a1 + 5680);
    *(_DWORD *)(a1 + 5688) = 0;
    v7 = v5 + v2;
    if ( !v4 && v6 < v7
      || (*(_DWORD *)(a1 + 5688) = v6 - v7,
          *(_DWORD *)(a1 + 5680) = v7,
          sub_10029CB0(v2, a1, 0),
          v8 = *(_DWORD *)(a1 + 2908),
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680),
          sub_10027FA0(v8),
          *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16)) )
    {
      v9 = *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664);
      if ( v9 < *(_DWORD *)(a1 + 5748) - 262 )
        continue;
      sub_10029CB0(v9, a1, 0);
      v10 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_10027FA0(v10);
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  sub_10029CB0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v12 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10027FA0(v12);
  v13 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v13) = a2 == 4;
    result = 2 * v13 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (1002A760) --------------------------------------------------------
int __cdecl sub_1002A760(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edi@1
  unsigned int v4; // ecx@1
  unsigned int v5; // esi@1
  int result; // eax@2
  unsigned int i; // ebp@3
  unsigned int v8; // ebx@4
  int v9; // eax@8
  signed int v10; // edx@8
  int v11; // ecx@9
  int v12; // esi@9
  int v13; // ecx@9
  int v14; // esi@9
  int v15; // ecx@9
  int v16; // esi@9
  unsigned int v17; // [sp+Ch] [bp+4h]@7

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = a1 >> 16;
  if ( a2 )
  {
    for ( i = a3; i; v5 %= 0xFFF1u )
    {
      v8 = i;
      if ( i >= 0x15B0 )
        v8 = 5552;
      i -= v8;
      if ( (signed int)v8 >= 16 )
      {
        v17 = v8 >> 4;
        v8 += -16 * (v8 >> 4);
        do
        {
          v9 = (int)(v3 + 1);
          v10 = 4;
          do
          {
            v11 = *(_BYTE *)(v9 - 1) + v4;
            v12 = v11 + v5;
            v13 = *(_BYTE *)v9 + v11;
            v14 = v13 + v12;
            v15 = *(_BYTE *)(v9 + 1) + v13;
            v16 = v15 + v14;
            v4 = *(_BYTE *)(v9 + 2) + v15;
            v5 = v4 + v16;
            v9 += 4;
            --v10;
          }
          while ( v10 );
          v3 += 16;
          --v17;
        }
        while ( v17 );
      }
      for ( ; v8; --v8 )
      {
        v4 += *v3++;
        v5 += v4;
      }
      v4 %= 0xFFF1u;
    }
    result = v4 | (v5 << 16);
  }
  else
  {
    result = (int)(a2 + 1);
  }
  return result;
}

//----- (1002A860) --------------------------------------------------------
signed int __cdecl sub_1002A860(int a1)
{
  signed int result; // eax@3

  if ( a1 && *(_DWORD *)(a1 + 24) )
  {
    *(_DWORD *)(a1 + 24) = 0;
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (1002A880) --------------------------------------------------------
signed int __usercall sub_1002A880@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10)
{
  unsigned int v10; // ebp@1
  unsigned int *v11; // edi@1
  _DWORD *v12; // eax@1
  unsigned int v13; // edx@1
  signed int result; // eax@4
  unsigned int v15; // eax@5
  int v16; // ecx@7
  signed int v17; // edx@9
  signed int v18; // esi@13
  int i; // edi@13
  int v20; // esi@14
  int v21; // edi@16
  int v22; // esi@16
  int v23; // edi@17
  int v24; // ebx@17
  int v25; // esi@17
  int v26; // edi@18
  _DWORD *v27; // edi@20
  unsigned int v28; // ebx@20
  int v29; // esi@21
  int v30; // edi@22
  signed int v31; // edi@24
  int v32; // ebx@24
  unsigned int v33; // esi@25
  int v34; // edx@27
  int l; // ebp@28
  unsigned int v36; // edx@31
  unsigned int v37; // ecx@33
  int *v38; // ebp@34
  int v39; // eax@34
  unsigned int v40; // edi@36
  unsigned int v41; // eax@36
  unsigned int v42; // edx@39
  int v43; // eax@40
  unsigned int v44; // eax@41
  int v45; // ecx@41
  int v46; // esi@48
  signed int v47; // edx@50
  unsigned int v48; // eax@50
  int v49; // ecx@51
  unsigned int j; // eax@54
  int v51; // [sp+Ch] [bp-F4h]@7
  unsigned int v52; // [sp+Ch] [bp-F4h]@24
  signed int v53; // [sp+Ch] [bp-F4h]@31
  unsigned int v54; // [sp+10h] [bp-F0h]@9
  int v55; // [sp+14h] [bp-ECh]@24
  int v56; // [sp+18h] [bp-E8h]@26
  _DWORD *v57; // [sp+1Ch] [bp-E4h]@21
  int v58; // [sp+1Ch] [bp-E4h]@31
  unsigned int k; // [sp+20h] [bp-E0h]@24
  int *v60; // [sp+24h] [bp-DCh]@25
  int v61; // [sp+28h] [bp-D8h]@0
  unsigned int v62; // [sp+2Ch] [bp-D4h]@0
  int v63; // [sp+30h] [bp-D0h]@24
  unsigned int *v64; // [sp+34h] [bp-CCh]@24
  int v65; // [sp+38h] [bp-C8h]@11
  int v66; // [sp+3Ch] [bp-C4h]@31
  int v67; // [sp+40h] [bp-C0h]@16
  int v68; // [sp+44h] [bp-BCh]@1
  int v69; // [sp+48h] [bp-B8h]@1
  int v70; // [sp+4Ch] [bp-B4h]@1
  int v71; // [sp+50h] [bp-B0h]@1
  int v72; // [sp+54h] [bp-ACh]@1
  int v73; // [sp+58h] [bp-A8h]@1
  int v74; // [sp+5Ch] [bp-A4h]@1
  int v75; // [sp+60h] [bp-A0h]@1
  int v76; // [sp+64h] [bp-9Ch]@1
  int v77; // [sp+68h] [bp-98h]@1
  int v78; // [sp+6Ch] [bp-94h]@1
  int v79; // [sp+70h] [bp-90h]@1
  int v80; // [sp+74h] [bp-8Ch]@1
  int v81; // [sp+78h] [bp-88h]@1
  int v82; // [sp+7Ch] [bp-84h]@1
  int v83; // [sp+80h] [bp-80h]@1
  int v84; // [sp+84h] [bp-7Ch]@22
  int v85[14]; // [sp+88h] [bp-78h]@17
  int v86; // [sp+C0h] [bp-40h]@41
  int v87[15]; // [sp+C4h] [bp-3Ch]@24
  int v88; // [sp+108h] [bp+8h]@24

  v10 = 0;
  v11 = a1;
  v12 = a2;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v13 = a3;
  do
  {
    ++*(&v68 + *v12);
    ++v12;
    --v13;
  }
  while ( v13 );
  if ( v68 == a3 )
  {
    *a7 = 0;
    *v11 = 0;
    return 0;
  }
  v15 = 1;
  if ( !v69 )
  {
    do
      ++v15;
    while ( !*(&v68 + v15) );
  }
  v16 = v15;
  v51 = v15;
  if ( *v11 > v15 )
    v15 = *v11;
  v54 = v15;
  v17 = 15;
  if ( !v83 )
  {
    do
      --v17;
    while ( !*(&v68 + v17) );
  }
  v65 = v17;
  if ( (signed int)v15 > v17 )
  {
    v54 = v17;
    v15 = v17;
  }
  v18 = 1 << v16;
  *v11 = v15;
  for ( i = v16; i < v17; v18 = 2 * v20 )
  {
    v20 = v18 - *(&v68 + i);
    if ( v20 < 0 )
      return -3;
    ++i;
  }
  v21 = *(&v68 + v17);
  v22 = v18 - v21;
  v67 = v22;
  if ( v22 < 0 )
    return -3;
  v23 = v22 + v21;
  v24 = v17 - 1;
  v25 = 0;
  *(&v68 + v17) = v23;
  v85[0] = 0;
  if ( v17 != 1 )
  {
    v26 = 0;
    do
    {
      v25 += *(int *)((char *)&v69 + v26 * 4);
      ++v26;
      --v24;
      v85[v26] = v25;
    }
    while ( v24 );
  }
  v27 = a2;
  v28 = 0;
  do
  {
    v29 = *v27;
    ++v27;
    v57 = v27;
    if ( v29 )
    {
      v30 = *(&v84 + v29);
      a10[v30] = v28;
      v16 = v51;
      *(&v84 + v29) = v30 + 1;
      v27 = v57;
    }
    ++v28;
  }
  while ( v28 < a3 );
  v88 = *(&v84 + v17);
  v31 = -1;
  v32 = -v15;
  v84 = 0;
  k = 0;
  v64 = a10;
  v87[0] = 0;
  v63 = 0;
  v52 = 0;
  v55 = v16;
  if ( v16 > v17 )
  {
LABEL_60:
    if ( v67 && v17 != 1 )
      result = -5;
    else
      result = 0;
  }
  else
  {
    v33 = v62;
    v60 = &v68 + v16;
    while ( 1 )
    {
      v56 = *v60;
      if ( *v60 )
        break;
LABEL_59:
      v17 = v65;
      ++v60;
      v55 = ++v16;
      if ( v16 > v65 )
        goto LABEL_60;
    }
    while ( 1 )
    {
      --v56;
      v34 = v32 + v15;
      if ( (signed int)(v32 + v15) < v16 )
        break;
LABEL_44:
      BYTE1(v61) = v16 - v32;
      if ( v64 < &a10[v88] )
      {
        v33 = *v64;
        if ( *v64 >= a4 )
        {
          v46 = 4 * (v33 - a4);
          LOBYTE(v61) = *(_BYTE *)(v46 + a6) + 80;
          v33 = *(_DWORD *)(v46 + a5);
        }
        else
        {
          LOBYTE(v61) = v33 < 0x100 ? 0 : 96;
        }
        ++v64;
      }
      else
      {
        LOBYTE(v61) = -64;
      }
      v47 = 1 << (v16 - v32);
      v48 = v10 >> v32;
      if ( v10 >> v32 < v52 )
      {
        v49 = v63 + 8 * v48;
        do
        {
          *(_DWORD *)v49 = v61;
          *(_DWORD *)(v49 + 4) = v33;
          v48 += v47;
          v49 += 8 * v47;
        }
        while ( v48 < v52 );
        v10 = k;
      }
      for ( j = 1 << (v55 - 1); v10 & j; j >>= 1 )
        v10 ^= j;
      v10 ^= j;
      for ( k = v10; (v10 & ((1 << v32) - 1)) != *(&v84 + v31); --v31 )
        v32 -= v54;
      v15 = v54;
      v16 = v55;
      if ( !v56 )
        goto LABEL_59;
    }
    for ( l = v32 - v15; ; l = v58 )
    {
      v66 = v15 + v34;
      v32 += v15;
      ++v31;
      v36 = v65 - v32;
      v53 = v31;
      v58 = v15 + l;
      if ( v65 - v32 > v15 )
        v36 = v15;
      v37 = v16 - v32;
      if ( 1 << v37 > (unsigned int)(v56 + 1) )
      {
        v38 = v60;
        v39 = -1 - v56 + (1 << v37);
        if ( v37 < v36 )
        {
          while ( ++v37 < v36 )
          {
            v40 = v38[1];
            ++v38;
            v41 = 2 * v39;
            if ( v41 <= v40 )
              break;
            v39 = v41 - v40;
          }
        }
        v31 = v53;
      }
      v52 = 1 << v37;
      v42 = *a9 + (1 << v37);
      if ( v42 > 0x5A0 )
        break;
      v43 = a8 + 8 * *a9;
      *a9 = v42;
      v10 = k;
      v87[v31] = v43;
      v63 = v43;
      if ( v31 )
      {
        LOBYTE(v61) = v37;
        v44 = k >> v58;
        v45 = *(&v86 + v31);
        BYTE1(v61) = v54;
        v33 = ((v63 - v45) >> 3) - (k >> v58);
        *(_DWORD *)(v45 + 8 * v44) = v61;
        *(&v84 + v31) = k;
        *(_DWORD *)(v45 + 8 * v44 + 4) = v33;
      }
      else
      {
        *a7 = v43;
      }
      v34 = v66;
      v16 = v55;
      if ( v66 >= v55 )
        goto LABEL_44;
      v15 = v54;
    }
    result = -3;
  }
  return result;
}
// 1002A880: using guessed type int var_78[14];
// 1002A880: using guessed type int var_3C[15];

//----- (1002AD20) --------------------------------------------------------
int (__cdecl *__usercall sub_1002AD20@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax@3
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax@3

  if ( a1 )
    *a1 = *(_DWORD *)(a2 + 14124);
  v3 = *(_DWORD *)(a2 + 14104);
  *(_DWORD *)(a2 + 14112) = v3;
  *(_DWORD *)(a2 + 14116) = v3;
  result = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a2 + 14120);
  *(_BYTE *)a2 = 0;
  *(_DWORD *)(a2 + 1424) = 0;
  *(_DWORD *)(a2 + 1428) = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    *(_DWORD *)(a2 + 14124) = result;
    *(_DWORD *)(a3 + 28) = result;
  }
  return result;
}

//----- (1002AD70) --------------------------------------------------------
int __usercall sub_1002AD70@<eax>(int result@<eax>, char a2, char a3, int a4, int a5)
{
  *(_BYTE *)(result + 16) = a2;
  *(_BYTE *)(result + 17) = a3;
  *(_BYTE *)result = 0;
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(result + 24) = a5;
  return result;
}

//----- (1002AD90) --------------------------------------------------------
signed int __cdecl sub_1002AD90(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // ebp@1
  unsigned int v7; // ecx@1
  unsigned int v8; // edx@1
  _BYTE *v9; // edi@1
  unsigned int v10; // eax@1
  int v11; // esi@6
  int v12; // ebx@8
  int v13; // esi@8
  int v14; // ecx@8
  int v15; // ecx@11
  int v16; // ebx@13
  unsigned int v17; // eax@13
  unsigned int v18; // edx@13
  int v19; // esi@14
  int v20; // ebx@16
  int v21; // esi@16
  unsigned int v22; // edx@16
  unsigned int v23; // eax@16
  int v24; // ecx@18
  int v25; // ecx@18
  int i; // ebx@19
  char v27; // cl@21
  int v28; // ebx@21
  int v29; // ecx@21
  int v30; // esi@22
  _BYTE *v31; // edi@22
  _BYTE *v32; // esi@22
  unsigned int v33; // ecx@23
  unsigned int v34; // ecx@32
  int v35; // ebp@34
  int v36; // ebx@34
  unsigned int v38; // ecx@35
  int v39; // ebp@37
  int v40; // ebx@37
  int v41; // esi@37
  int v42; // eax@37
  unsigned int v43; // ecx@38
  int v44; // ebp@41
  int v45; // ebx@41
  int v46; // ebp@44
  unsigned int v47; // [sp+10h] [bp-14h]@1
  unsigned int v48; // [sp+14h] [bp-10h]@2
  _BYTE *v49; // [sp+18h] [bp-Ch]@1
  int v50; // [sp+1Ch] [bp-8h]@4
  int v51; // [sp+20h] [bp-4h]@4
  unsigned int v52; // [sp+28h] [bp+4h]@21
  unsigned int v53; // [sp+2Ch] [bp+8h]@13
  int v54; // [sp+2Ch] [bp+8h]@24

  v6 = *(_BYTE **)a6;
  v7 = *(_DWORD *)(a5 + 14112);
  v8 = *(_DWORD *)(a5 + 1428);
  v9 = *(_BYTE **)(a5 + 14116);
  v47 = *(_DWORD *)(a6 + 4);
  v10 = *(_DWORD *)(a5 + 1424);
  v49 = *(_BYTE **)a6;
  if ( (unsigned int)v9 >= v7 )
    v48 = *(_DWORD *)(a5 + 14108) - (_DWORD)v9;
  else
    v48 = v7 - (_DWORD)v9 - 1;
  v50 = dword_1008DC10[a1];
  v51 = dword_1008DC10[a2];
  while ( 1 )
  {
    if ( v10 < 0x14 )
    {
      do
      {
        --v47;
        v11 = *v6 << v10;
        v10 += 8;
        ++v6;
        v8 |= v11;
      }
      while ( v10 < 0x14 );
      v49 = v6;
    }
    v12 = *(_BYTE *)(a3 + 8 * (v8 & v50));
    v13 = a3 + 8 * (v8 & v50);
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( v12 )
      break;
LABEL_29:
    v10 -= v14;
    *v9++ = *(_BYTE *)(v13 + 4);
    --v48;
LABEL_30:
    if ( v48 < 0x102 || v47 < 0xA )
    {
      v34 = *(_DWORD *)(a6 + 4) - v47;
      if ( v10 >> 3 < v34 )
        v34 = v10 >> 3;
      v35 = (int)&v6[-v34];
      *(_DWORD *)(a6 + 4) = v34 + v47;
      v36 = v35 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v35;
      *(_DWORD *)(a6 + 8) += v36;
      *(_DWORD *)(a5 + 14116) = v9;
      *(_DWORD *)(a5 + 1424) = v10 - 8 * v34;
      *(_DWORD *)(a5 + 1428) = v8;
      return 0;
    }
  }
  v10 -= *(_BYTE *)(v13 + 1);
  if ( v12 & 0x10 )
  {
LABEL_13:
    v16 = v12 & 0xF;
    v17 = v10 - v16;
    v53 = *(_DWORD *)(v13 + 4) + (v8 & dword_1008DC10[v16]);
    v18 = v8 >> v16;
    if ( v17 < 0xF )
    {
      do
      {
        --v47;
        v19 = *v6 << v17;
        v17 += 8;
        ++v6;
        v18 |= v19;
      }
      while ( v17 < 0xF );
      v49 = v6;
    }
    v20 = *(_BYTE *)(a4 + 8 * (v18 & v51));
    v21 = a4 + 8 * (v18 & v51);
    v22 = v18 >> *(_BYTE *)(v21 + 1);
    v23 = v17 - *(_BYTE *)(v21 + 1);
    if ( !(v20 & 0x10) )
    {
      while ( !(v20 & 0x40) )
      {
        v24 = *(_DWORD *)(v21 + 4) + (v22 & dword_1008DC10[v20]);
        v20 = *(_BYTE *)(v21 + 8 * v24);
        v21 += 8 * v24;
        v25 = *(_BYTE *)(v21 + 1);
        v22 >>= v25;
        v23 -= v25;
        if ( v20 & 0x10 )
          goto LABEL_19;
      }
      v38 = *(_DWORD *)(a6 + 4) - v47;
      if ( v23 >> 3 < v38 )
        v38 = v23 >> 3;
      v39 = (int)&v6[-v38];
      *(_DWORD *)(a6 + 4) = v38 + v47;
      v40 = v39 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v39;
      *(_DWORD *)(a6 + 8) += v40;
      v41 = a5;
      *(_DWORD *)(a5 + 1428) = v22;
      v42 = v23 - 8 * v38;
      goto LABEL_45;
    }
LABEL_19:
    for ( i = v20 & 0xF; v23 < (unsigned __int16)i; ++v49 )
    {
      --v47;
      v22 |= *v6 << v23;
      v6 = v49 + 1;
      v23 += 8;
    }
    v10 = v23 - i;
    v52 = *(_DWORD *)(v21 + 4) + (v22 & dword_1008DC10[i]);
    v27 = i;
    v28 = v53;
    v48 -= v53;
    v8 = v22 >> v27;
    v29 = *(_DWORD *)(a5 + 14104);
    if ( (unsigned int)&v9[-v29] < v52 )
    {
      v33 = v52 + v29 - (_DWORD)v9;
      v32 = (_BYTE *)(*(_DWORD *)(a5 + 14108) - v33);
      if ( v53 > v33 )
      {
        v54 = v53 - v33;
        do
        {
          *v9++ = *v32++;
          --v33;
        }
        while ( v33 );
        v32 = *(_BYTE **)(a5 + 14104);
        v28 = v54;
      }
    }
    else
    {
      v30 = (int)&v9[-v52];
      v31 = v9 + 1;
      *(v31 - 1) = *(_BYTE *)v30;
      *v31 = *(_BYTE *)(v30 + 1);
      v9 = v31 + 1;
      v32 = (_BYTE *)(v30 + 2);
      v28 = v53 - 2;
    }
    do
    {
      *v9++ = *v32++;
      --v28;
    }
    while ( v28 );
    goto LABEL_30;
  }
  while ( !(v12 & 0x40) )
  {
    v15 = *(_DWORD *)(v13 + 4) + (v8 & dword_1008DC10[v12]);
    v12 = *(_BYTE *)(v13 + 8 * v15);
    v13 += 8 * v15;
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( !v12 )
      goto LABEL_29;
    v10 -= *(_BYTE *)(v13 + 1);
    if ( v12 & 0x10 )
      goto LABEL_13;
  }
  v43 = *(_DWORD *)(a6 + 4) - v47;
  if ( !(v12 & 0x20) )
  {
    if ( v10 >> 3 < v43 )
      v43 = v10 >> 3;
    v46 = (int)&v6[-v43];
    *(_DWORD *)(a6 + 4) = v43 + v47;
    *(_DWORD *)(a6 + 8) += v46 - *(_DWORD *)a6;
    *(_DWORD *)a6 = v46;
    v41 = a5;
    *(_DWORD *)(a5 + 1428) = v8;
    v42 = v10 - 8 * v43;
LABEL_45:
    *(_DWORD *)(v41 + 14116) = v9;
    *(_DWORD *)(v41 + 1424) = v42;
    return -3;
  }
  if ( v10 >> 3 < v43 )
    v43 = v10 >> 3;
  *(_DWORD *)(a6 + 4) = v43 + v47;
  v44 = (int)&v6[-v43];
  v45 = v44 - *(_DWORD *)a6;
  *(_DWORD *)a6 = v44;
  *(_DWORD *)(a6 + 8) += v45;
  *(_DWORD *)(a5 + 1428) = v8;
  *(_DWORD *)(a5 + 14116) = v9;
  *(_DWORD *)(a5 + 1424) = v10 - 8 * v43;
  return 1;
}
// 1008DC10: using guessed type int dword_1008DC10[];

//----- (1002B140) --------------------------------------------------------
int __usercall sub_1002B140@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  const void *v3; // ebx@1
  unsigned int v4; // ebp@1
  size_t v5; // eax@3
  size_t v6; // ebp@3
  int (__cdecl *v7)(_DWORD, const void *, size_t); // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int v10; // ebx@10
  const void *v11; // ebx@11
  size_t v12; // eax@13
  size_t v13; // ebp@13
  int (__cdecl *v14)(_DWORD, const void *, size_t); // eax@15
  int v15; // eax@16
  int result; // eax@18
  void *v17; // [sp+8h] [bp-4h]@1
  char *v18; // [sp+8h] [bp-4h]@10

  v3 = *(const void **)(a2 + 14112);
  v4 = *(_DWORD *)(a2 + 14116);
  v17 = *(void **)(a1 + 12);
  if ( (unsigned int)v3 > v4 )
    v4 = *(_DWORD *)(a2 + 14108);
  v5 = *(_DWORD *)(a1 + 16);
  v6 = v4 - (_DWORD)v3;
  if ( v6 > v5 )
    v6 = *(_DWORD *)(a1 + 16);
  if ( v6 && a3 == -5 )
    a3 = 0;
  *(_DWORD *)(a1 + 20) += v6;
  *(_DWORD *)(a1 + 16) = v5 - v6;
  v7 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
  if ( v7 )
  {
    v8 = v7(*(_DWORD *)(a2 + 14124), v3, v6);
    *(_DWORD *)(a2 + 14124) = v8;
    *(_DWORD *)(a1 + 28) = v8;
  }
  memcpy(v17, v3, v6);
  v9 = *(_DWORD *)(a2 + 14108);
  v18 = (char *)v17 + v6;
  v10 = (int)v3 + v6;
  if ( v10 == v9 )
  {
    v11 = *(const void **)(a2 + 14104);
    if ( *(_DWORD *)(a2 + 14116) == v9 )
      *(_DWORD *)(a2 + 14116) = v11;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a2 + 14116) - (_DWORD)v11;
    if ( v13 > v12 )
      v13 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) += v13;
    *(_DWORD *)(a1 + 16) = v12 - v13;
    v14 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
    if ( v14 )
    {
      v15 = v14(*(_DWORD *)(a2 + 14124), v11, v13);
      *(_DWORD *)(a2 + 14124) = v15;
      *(_DWORD *)(a1 + 28) = v15;
    }
    memcpy(v18, v11, v13);
    v18 += v13;
    v10 = (int)v11 + v13;
  }
  *(_DWORD *)(a1 + 12) = v18;
  result = a3;
  *(_DWORD *)(a2 + 14112) = v10;
  return result;
}

//----- (1002B280) --------------------------------------------------------
signed int __usercall sub_1002B280@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4)
{
  signed int result; // eax@1
  int v5; // [sp+0h] [bp-50h]@1
  char v6; // [sp+4h] [bp-4Ch]@1

  v5 = 0;
  result = sub_1002A880(a2, a3, 0x13u, 19, 0, 0, a4, a1, (unsigned int *)&v5, (unsigned int *)&v6);
  if ( result == -5 || !*a2 )
    result = -3;
  return result;
}

//----- (1002B2D0) --------------------------------------------------------
signed int __usercall sub_1002B2D0@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9)
{
  unsigned int *v9; // edi@1
  signed int result; // eax@6
  int v11; // [sp+8h] [bp-4h]@1

  v9 = a1;
  v11 = 0;
  if ( sub_1002A880(a7, a6, a4, 257, (int)&unk_1008DCA8, (int)&unk_1008DD28, a2, a3, (unsigned int *)&v11, a1)
    || !*a7
    || sub_1002A880(a8, &a6[a4], a5, 0, (int)&unk_1008DDA8, (int)&unk_1008DE20, a9, a3, (unsigned int *)&v11, v9)
    || !*a8 && a4 > 0x101 )
  {
    result = -3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002B370) --------------------------------------------------------
int __usercall sub_1002B370@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4)
{
  *a1 = 9;
  *a3 = 5;
  *a2 = &unk_1008DE98;
  *a4 = &unk_1008EE98;
  return 0;
}

//----- (1002B390) --------------------------------------------------------
signed int __cdecl sub_1002B390(int a1, int a2, int a3, int a4)
{
  int v4; // ecx@12
  int v5; // esi@12
  int v6; // ecx@1
  signed int v7; // ebx@1
  signed int result; // eax@9

  v6 = a2;
  v7 = 0;
  if ( a2 < 0 )
  {
    v7 = 1;
    v6 = -a2;
  }
  if ( (1 << v6) + 14152 > a4 || a3 & 3 )
  {
    result = -4;
  }
  else
  {
    *(_DWORD *)(a1 + 24) = a3;
    *(_DWORD *)(a3 + 16) = v6;
    *(_DWORD *)(a3 + 12) = v7;
    *(_DWORD *)(a3 + 4) = 0;
    *(_DWORD *)(a3 + 20) = a3 + 24;
    *(_DWORD *)(a3 + 14128) = a3 + 14152;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14108) = (1 << v6) + *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14104);
    **(_BYTE **)(a3 + 20) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1428) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1424) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14124) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1420) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14112) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14116) = 0;
    if ( *(_DWORD *)(a3 + 12) )
      *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14120) = 0;
    else
      *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14120) = sub_1002A760;
    sub_1002AD20(0, *(_DWORD *)(a3 + 20), a1);
    if ( a1 )
    {
      v4 = *(_DWORD *)(a1 + 24);
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 20) = 0;
      v5 = *(_DWORD *)(v4 + 20);
      *(_BYTE *)v4 = *(_DWORD *)(v4 + 12) != 0 ? 7 : 0;
      sub_1002AD20(0, v5, a1);
      result = 0;
    }
    else
    {
      result = -2;
    }
  }
  return result;
}

//----- (1002B480) --------------------------------------------------------
void __cdecl sub_1002B480(int a1)
{
  JUMPOUT(&loc_1002B240);
}

//----- (1002B490) --------------------------------------------------------
int __usercall sub_1002B490@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // edi@1
  _BYTE *v4; // ebx@1
  int v5; // esi@1
  _BYTE *v6; // edx@1
  unsigned int v7; // ebp@1
  unsigned int v8; // eax@1
  unsigned int v9; // eax@2
  unsigned int v10; // ecx@4
  int v11; // ecx@8
  signed int v12; // eax@8
  int v13; // ecx@8
  unsigned int v14; // eax@8
  int v15; // ecx@13
  int v16; // eax@16
  int v17; // eax@17
  int v18; // ecx@17
  int v19; // eax@17
  int v20; // eax@27
  int v21; // eax@28
  int v22; // ecx@28
  int v23; // ecx@28
  int v24; // eax@31
  int v25; // eax@32
  int v26; // ecx@32
  int v27; // eax@32
  int v28; // eax@38
  int v29; // eax@39
  int v30; // ecx@39
  int v31; // ecx@40
  int v32; // eax@41
  unsigned int v33; // eax@46
  unsigned int v34; // ecx@46
  int v35; // eax@51
  unsigned int v36; // eax@51
  unsigned int v37; // ecx@55
  unsigned int v38; // eax@55
  bool v39; // zf@61
  unsigned int v40; // eax@67
  unsigned int v41; // ecx@67
  int v42; // eax@72
  unsigned int v43; // eax@72
  unsigned int v44; // ecx@76
  unsigned int v45; // eax@76
  int v47; // eax@91
  int v48; // ecx@93
  int v49; // eax@97
  int v50; // ecx@98
  int v51; // eax@101
  int v52; // [sp-4h] [bp-2Ch]@85
  unsigned int v53; // [sp+10h] [bp-18h]@1
  unsigned int v54; // [sp+14h] [bp-14h]@1
  unsigned int v55; // [sp+18h] [bp-10h]@4
  unsigned int v56; // [sp+18h] [bp-10h]@54
  unsigned int v57; // [sp+18h] [bp-10h]@75
  _BYTE *v58; // [sp+20h] [bp-8h]@43
  int v59; // [sp+2Ch] [bp+4h]@51

  v3 = a1;
  v4 = *(_BYTE **)a1;
  v5 = a2;
  v6 = *(_BYTE **)(a2 + 14116);
  v7 = *(_DWORD *)(a2 + 1424);
  v54 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)(a2 + 14112);
  v53 = *(_DWORD *)(a2 + 1428);
  if ( (unsigned int)v6 >= v8 )
    v9 = *(_DWORD *)(a2 + 14108) - (_DWORD)v6;
  else
    v9 = v8 - (_DWORD)v6 - 1;
  v10 = *(_BYTE *)(a2 + 4);
  v55 = v9;
  while ( 2 )
  {
    switch ( v10 )
    {
      case 0u:
        if ( v9 >= 0x102 && v54 >= 0xA )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v11 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v11;
          *(_DWORD *)(v5 + 1428) = v53;
          *(_DWORD *)(v5 + 1424) = v7;
          *(_DWORD *)(v5 + 14116) = v6;
          v12 = sub_1002AD90(
                  *(_BYTE *)(v5 + 20),
                  *(_BYTE *)(v5 + 21),
                  *(_DWORD *)(v5 + 24),
                  *(_DWORD *)(v5 + 28),
                  v5,
                  v3);
          v4 = *(_BYTE **)v3;
          v7 = *(_DWORD *)(v5 + 1424);
          v13 = v12;
          v54 = *(_DWORD *)(v3 + 4);
          v6 = *(_BYTE **)(v5 + 14116);
          v53 = *(_DWORD *)(v5 + 1428);
          v14 = *(_DWORD *)(v5 + 14112);
          a3 = v13;
          v9 = (unsigned int)v6 >= v14 ? *(_DWORD *)(v5 + 14108) - (_DWORD)v6 : v14 - (_DWORD)v6 - 1;
          v55 = v9;
          if ( v13 )
          {
            *(_BYTE *)(v5 + 4) = 2 * (v13 != 1) + 7;
            goto LABEL_84;
          }
        }
        v15 = *(_DWORD *)(v5 + 24);
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 20);
        *(_DWORD *)(v5 + 12) = v15;
        *(_BYTE *)(v5 + 4) = 1;
        goto LABEL_14;
      case 1u:
LABEL_14:
        if ( v7 >= *(_WORD *)(v5 + 16) )
          goto LABEL_17;
        do
        {
          if ( !v54 )
            goto LABEL_91;
          --v54;
          v16 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v16;
        }
        while ( v7 < *(_WORD *)(v5 + 16) );
LABEL_17:
        v17 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_1008DC10[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v17 + 1);
        v18 = v17;
        v7 -= *(_BYTE *)(v17 + 1);
        v19 = *(_BYTE *)v17;
        if ( v19 )
        {
          if ( v19 & 0x10 )
          {
            *(_DWORD *)(v5 + 12) = v19 & 0xF;
            *(_DWORD *)(v5 + 8) = *(_DWORD *)(v18 + 4);
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 2;
          }
          else if ( v19 & 0x40 )
          {
            if ( !(v19 & 0x20) )
              goto LABEL_92;
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 7;
          }
          else
          {
            *(_DWORD *)(v5 + 16) = v19;
            v9 = v55;
            *(_DWORD *)(v5 + 12) = v18 + 8 * *(_DWORD *)(v18 + 4);
          }
        }
        else
        {
          v9 = v55;
          *(_DWORD *)(v5 + 12) = *(_DWORD *)(v18 + 4);
          *(_BYTE *)(v5 + 4) = 6;
        }
        goto LABEL_84;
      case 2u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_28;
        do
        {
          if ( !v54 )
            goto LABEL_93;
          --v54;
          v20 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v20;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_28:
        v21 = *(_DWORD *)(v5 + 12);
        v22 = v53 & dword_1008DC10[v21];
        *(_BYTE *)(v5 + 4) = 3;
        *(_DWORD *)(v5 + 8) += v22;
        v53 >>= v21;
        v23 = *(_DWORD *)(v5 + 28);
        v7 -= v21;
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 21);
        *(_DWORD *)(v5 + 12) = v23;
LABEL_29:
        if ( v7 < *(_WORD *)(v5 + 16) )
        {
          while ( v54 )
          {
            --v54;
            v24 = *v4 << v7;
            v7 += 8;
            ++v4;
            a3 = 0;
            v53 |= v24;
            if ( v7 >= *(_WORD *)(v5 + 16) )
              goto LABEL_32;
          }
LABEL_91:
          v47 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)(v3 + 4) = 0;
          *(_DWORD *)(v3 + 8) += v47;
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v5 + 14116) = v6;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = a3;
          goto LABEL_90;
        }
LABEL_32:
        v25 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_1008DC10[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v25 + 1);
        v26 = v25;
        v7 -= *(_BYTE *)(v25 + 1);
        v27 = *(_BYTE *)v25;
        if ( v27 & 0x10 )
        {
          *(_DWORD *)(v5 + 12) = v27 & 0xF;
          v9 = v55;
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(v26 + 4);
          *(_BYTE *)(v5 + 4) = 4;
        }
        else
        {
          if ( v27 & 0x40 )
          {
LABEL_92:
            *(_BYTE *)(v5 + 4) = 9;
            v52 = -3;
            goto LABEL_86;
          }
          *(_DWORD *)(v5 + 16) = v27;
          v9 = v55;
          *(_DWORD *)(v5 + 12) = v26 + 8 * *(_DWORD *)(v26 + 4);
        }
        goto LABEL_84;
      case 3u:
        goto LABEL_29;
      case 4u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_39;
        do
        {
          if ( !v54 )
          {
LABEL_93:
            v48 = (int)&v4[-*(_DWORD *)v3];
            *(_DWORD *)(v3 + 4) = 0;
            *(_DWORD *)(v3 + 8) += v48;
            v52 = a3;
            goto LABEL_88;
          }
          --v54;
          v28 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v28;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_39:
        v29 = *(_DWORD *)(v5 + 12);
        v30 = v53 & dword_1008DC10[v29];
        *(_BYTE *)(v5 + 4) = 5;
        *(_DWORD *)(v5 + 16) += v30;
        v53 >>= v29;
        v7 -= v29;
LABEL_40:
        v31 = *(_DWORD *)(v5 + 16);
        if ( (signed int)&v6[-*(_DWORD *)(v5 + 14104)] >= v31 )
          v32 = (int)&v6[-v31];
        else
          v32 = (int)&v6[*(_DWORD *)(v5 + 14108) - v31 - *(_DWORD *)(v5 + 14104)];
        v58 = (_BYTE *)v32;
        v9 = v55;
        if ( !*(_DWORD *)(v5 + 8) )
        {
LABEL_83:
          *(_BYTE *)(v5 + 4) = 0;
LABEL_84:
          v10 = *(_BYTE *)(v5 + 4);
          if ( v10 > 9 )
          {
LABEL_85:
            v52 = -2;
LABEL_86:
            *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
            goto LABEL_87;
          }
          continue;
        }
        while ( 1 )
        {
          if ( !v9 )
          {
            if ( v6 != *(_BYTE **)(v5 + 14108)
              || (v33 = *(_DWORD *)(v5 + 14112), v34 = *(_DWORD *)(v5 + 14104), v33 == v34)
              || ((v6 = *(_BYTE **)(v5 + 14104), v34 >= v33) ? (v9 = *(_DWORD *)(v5 + 14108) - v34) : (v9 = v33 - v34 - 1),
                  !v9) )
            {
              *(_DWORD *)(v5 + 14116) = v6;
              v35 = sub_1002B140(v3, v5, a3);
              v6 = *(_BYTE **)(v5 + 14116);
              v59 = v35;
              v36 = *(_DWORD *)(v5 + 14112);
              if ( (unsigned int)v6 >= v36 )
                v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
              else
                v9 = v36 - (_DWORD)v6 - 1;
              v56 = v9;
              if ( v6 == *(_BYTE **)(v5 + 14108) )
              {
                v37 = *(_DWORD *)(v5 + 14104);
                v38 = *(_DWORD *)(v5 + 14112);
                if ( v38 == v37 )
                {
                  v9 = v56;
                }
                else
                {
                  v6 = *(_BYTE **)(v5 + 14104);
                  if ( v37 >= v38 )
                    v9 = *(_DWORD *)(v5 + 14108) - v37;
                  else
                    v9 = v38 - v37 - 1;
                }
              }
              if ( !v9 )
                break;
            }
          }
          *v6 = *v58;
          --v9;
          ++v6;
          v39 = v58 + 1 == *(_BYTE **)(v5 + 14108);
          a3 = 0;
          v55 = v9;
          ++v58;
          if ( v39 )
            v58 = *(_BYTE **)(v5 + 14104);
          if ( !--*(_DWORD *)(v5 + 8) )
            goto LABEL_83;
        }
LABEL_94:
        *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
        v52 = v59;
LABEL_87:
        *(_DWORD *)(v3 + 4) = v54;
LABEL_88:
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
LABEL_89:
        *(_DWORD *)(v5 + 14116) = v6;
LABEL_90:
        *(_DWORD *)(v5 + 1424) = v7;
        return sub_1002B140(v3, v5, v52);
      case 5u:
        goto LABEL_40;
      case 6u:
        if ( !v9 )
        {
          if ( v6 != *(_BYTE **)(v5 + 14108)
            || (v40 = *(_DWORD *)(v5 + 14112), v41 = *(_DWORD *)(v5 + 14104), v40 == v41)
            || ((v6 = *(_BYTE **)(v5 + 14104), v41 >= v40) ? (v9 = *(_DWORD *)(v5 + 14108) - v41) : (v9 = v40 - v41 - 1),
                !v9) )
          {
            *(_DWORD *)(v5 + 14116) = v6;
            v42 = sub_1002B140(v3, v5, a3);
            v6 = *(_BYTE **)(v5 + 14116);
            v59 = v42;
            v43 = *(_DWORD *)(v5 + 14112);
            if ( (unsigned int)v6 >= v43 )
              v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
            else
              v9 = v43 - (_DWORD)v6 - 1;
            v57 = v9;
            if ( v6 == *(_BYTE **)(v5 + 14108) )
            {
              v44 = *(_DWORD *)(v5 + 14104);
              v45 = *(_DWORD *)(v5 + 14112);
              if ( v45 == v44 )
              {
                v9 = v57;
              }
              else
              {
                v6 = *(_BYTE **)(v5 + 14104);
                if ( v44 >= v45 )
                  v9 = *(_DWORD *)(v5 + 14108) - v44;
                else
                  v9 = v45 - v44 - 1;
              }
            }
            if ( !v9 )
              goto LABEL_94;
          }
        }
        *v6++ = *(_BYTE *)(v5 + 12);
        --v9;
        a3 = 0;
        v55 = v9;
        goto LABEL_83;
      case 7u:
        if ( v7 > 7 )
        {
          ++v54;
          v7 -= 8;
          --v4;
        }
        *(_DWORD *)(v5 + 14116) = v6;
        v49 = sub_1002B140(v3, v5, a3);
        v6 = *(_BYTE **)(v5 + 14116);
        if ( *(_BYTE **)(v5 + 14112) != v6 )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v50 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v50;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = v49;
          goto LABEL_89;
        }
        *(_BYTE *)(v5 + 4) = 8;
LABEL_100:
        v52 = 1;
        goto LABEL_86;
      case 8u:
        goto LABEL_100;
      case 9u:
        v51 = (int)&v4[-*(_DWORD *)v3];
        *(_DWORD *)(v3 + 4) = v54;
        *(_DWORD *)(v3 + 8) += v51;
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
        v52 = -3;
        goto LABEL_89;
      default:
        goto LABEL_85;
    }
  }
}
// 1008DC10: using guessed type int dword_1008DC10[];

//----- (1002BB30) --------------------------------------------------------
int __usercall sub_1002BB30@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // edx@1
  unsigned int v5; // ebx@1
  unsigned int v6; // esi@1
  int v7; // edi@1
  size_t v8; // ecx@1
  char *v9; // eax@1
  char *v10; // ecx@1
  int v11; // edx@2
  unsigned int v12; // edx@4
  int v13; // edx@8
  unsigned int v14; // eax@9
  int v15; // eax@10
  int v16; // ebx@14
  int v17; // ecx@14
  int v18; // edx@17
  char *v19; // edx@24
  unsigned int v20; // eax@25
  unsigned int v21; // ecx@25
  int v22; // eax@27
  int v23; // eax@30
  unsigned int v24; // ecx@30
  int v25; // edx@31
  char *v26; // esi@33
  unsigned int v27; // edx@34
  size_t v28; // esi@39
  bool v29; // zf@43
  int v30; // edx@47
  int v31; // ecx@48
  int v32; // edx@54
  unsigned int v33; // ecx@61
  int v34; // edx@63
  int v35; // edx@64
  int v36; // ecx@64
  unsigned int v37; // edx@64
  int v38; // edx@71
  unsigned int v39; // esi@72
  unsigned int v40; // ecx@72
  unsigned int *v41; // eax@77
  unsigned int v42; // esi@81
  int v43; // eax@81
  int v44; // edx@83
  char *v45; // ecx@84
  unsigned int v46; // eax@84
  int v47; // eax@85
  char *v48; // eax@91
  int v49; // ecx@92
  int v50; // ecx@94
  int v51; // edx@96
  int v52; // edx@97
  int v53; // edx@99
  int v55; // eax@102
  int v56; // edx@103
  int v57; // edx@106
  int v58; // [sp-4h] [bp-3Ch]@91
  size_t v59; // [sp+10h] [bp-28h]@1
  char *v60; // [sp+14h] [bp-24h]@1
  char *v61; // [sp+18h] [bp-20h]@1
  unsigned int v62; // [sp+1Ch] [bp-1Ch]@4
  int v63; // [sp+1Ch] [bp-1Ch]@69
  int v64; // [sp+1Ch] [bp-1Ch]@72
  unsigned int v65; // [sp+20h] [bp-18h]@1
  unsigned int v66; // [sp+24h] [bp-14h]@13
  unsigned int v67; // [sp+28h] [bp-10h]@13
  int v68; // [sp+2Ch] [bp-Ch]@13
  int v69; // [sp+30h] [bp-8h]@13
  unsigned int v70; // [sp+34h] [bp-4h]@69
  unsigned int v71; // [sp+3Ch] [bp+4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 14112);
  v5 = *(_DWORD *)(a2 + 1424);
  v6 = *(_DWORD *)(a2 + 1428);
  v7 = a1;
  v8 = *(_DWORD *)(a1 + 4);
  v9 = *(char **)a1;
  v59 = v8;
  v10 = *(char **)(a2 + 14116);
  v61 = v9;
  v71 = *(_DWORD *)(a2 + 1428);
  v65 = v5;
  v60 = v10;
  if ( (unsigned int)v10 >= v4 )
    v11 = *(_DWORD *)(v3 + 14108) - (_DWORD)v10;
  else
    v11 = v4 - (_DWORD)v10 - 1;
  v62 = v11;
  v12 = *(_BYTE *)v3;
  while ( 2 )
  {
    switch ( v12 )
    {
      case 0u:
        for ( ; v5 < 3; v71 = v6 )
        {
          if ( !v59 )
            goto LABEL_91;
          --v59;
          a3 = 0;
          v13 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v13;
        }
        v14 = (v6 & 7) >> 1;
        *(_DWORD *)(v3 + 1420) = v6 & 1;
        if ( !v14 )
        {
          v16 = v5 - 3;
          v17 = v16 & 7;
          v5 = v16 - v17;
          v65 = v5;
          *(_BYTE *)v3 = 1;
          v71 = v6 >> 3 >> v17;
          goto LABEL_89;
        }
        v15 = v14 - 1;
        if ( !v15 )
        {
          sub_1002B370(&v67, &v69, &v66, &v68);
          sub_1002AD70(v3 + 4, v67, v66, v69, v68);
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 6;
          goto LABEL_89;
        }
        if ( v15 == 1 )
        {
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 3;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 9;
        v49 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v49;
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v3 + 1428) = v71 >> 3;
        v5 -= 3;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      case 1u:
        if ( v5 >= 0x20 )
          goto LABEL_18;
        do
        {
          if ( !v59 )
          {
LABEL_91:
            v48 = v61;
            *(_DWORD *)(v7 + 4) = 0;
            *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
            v58 = a3;
            goto LABEL_110;
          }
          --v59;
          a3 = 0;
          v18 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v18;
          v71 = v6;
        }
        while ( v5 < 0x20 );
LABEL_18:
        if ( ~v6 >> 16 != (unsigned __int16)v6 )
          goto LABEL_93;
        v5 = 0;
        *(_DWORD *)(v3 + 4) = (unsigned __int16)v6;
        v65 = 0;
        v71 = 0;
        if ( (_WORD)v6 )
          *(_BYTE *)v3 = 2;
        else
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
LABEL_89:
        v12 = *(_BYTE *)v3;
        if ( v12 <= 9 )
        {
          v10 = v60;
          v9 = v61;
          v6 = v71;
          continue;
        }
LABEL_107:
        v58 = -2;
        goto LABEL_108;
      case 2u:
        if ( !v59 )
          goto LABEL_94;
        if ( !v62 )
        {
          if ( (v19 = *(char **)(v3 + 14108), v60 != v19)
            || (v20 = *(_DWORD *)(v3 + 14112), v21 = *(_DWORD *)(v3 + 14104), v21 == v20)
            || ((v60 = *(char **)(v3 + 14104), v21 >= v20) ? (v22 = (int)&v19[-v21], v62 = (unsigned int)&v19[-v21]) : (v22 = v20 - v21 - 1, v62 = v22),
                !v22) )
          {
            *(_DWORD *)(v3 + 14116) = v60;
            v23 = sub_1002B140(v7, v3, a3);
            v24 = *(_DWORD *)(v3 + 14112);
            v60 = *(char **)(v3 + 14116);
            if ( *(_DWORD *)(v3 + 14116) >= v24 )
              v25 = *(_DWORD *)(v3 + 14108) - (_DWORD)v60;
            else
              v25 = v24 - (_DWORD)v60 - 1;
            v26 = *(char **)(v3 + 14108);
            v62 = v25;
            if ( v60 == v26 )
            {
              v27 = *(_DWORD *)(v3 + 14104);
              if ( v27 != v24 )
              {
                v60 = *(char **)(v3 + 14104);
                if ( v27 >= v24 )
                  v62 = (unsigned int)&v26[-v27];
                else
                  v62 = v24 - v27 - 1;
              }
            }
            if ( !v62 )
              goto LABEL_96;
          }
        }
        v28 = *(_DWORD *)(v3 + 4);
        a3 = 0;
        if ( v28 > v59 )
          v28 = v59;
        if ( v28 > v62 )
          v28 = v62;
        memcpy(v60, v61, v28);
        v61 += v28;
        v59 -= v28;
        v60 += v28;
        v62 -= v28;
        v29 = *(_DWORD *)(v3 + 4) == v28;
        *(_DWORD *)(v3 + 4) -= v28;
        if ( v29 )
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
        goto LABEL_89;
      case 3u:
        if ( v5 >= 0xE )
          goto LABEL_48;
        break;
      case 4u:
        goto LABEL_51;
      case 5u:
        goto LABEL_60;
      case 6u:
        goto LABEL_83;
      case 7u:
        goto LABEL_102;
      case 8u:
        goto LABEL_105;
      case 9u:
        v57 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v7 + 8) += v57;
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      default:
        goto LABEL_107;
    }
    break;
  }
  do
  {
    if ( !v59 )
      goto LABEL_94;
    --v59;
    v30 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v30;
    v71 = v6;
    v61 = v9;
  }
  while ( v5 < 0xE );
LABEL_48:
  v31 = v6 & 0x3FFF;
  *(_DWORD *)(v3 + 4) = v31;
  if ( (v6 & 0x1F) > 0x1D || (v6 & 0x3E0) > 0x3A0 )
  {
LABEL_93:
    *(_BYTE *)v3 = 9;
    v58 = -3;
LABEL_108:
    *(_DWORD *)(v7 + 4) = v59;
LABEL_109:
    v48 = v61;
    *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
    goto LABEL_110;
  }
  v6 >>= 14;
  v5 -= 14;
  v71 = v6;
  v65 = v5;
  *(_DWORD *)(v3 + 8) = 0;
  *(_BYTE *)v3 = 4;
LABEL_51:
  if ( *(_DWORD *)(v3 + 8) < (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
  {
    while ( v5 >= 3 )
    {
LABEL_55:
      *(_DWORD *)(v3 + 4 * dword_1008DC58[(*(_DWORD *)(v3 + 8))++] + 12) = v6 & 7;
      v6 >>= 3;
      v5 -= 3;
      v71 = v6;
      v65 = v5;
      if ( *(_DWORD *)(v3 + 8) >= (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
        goto LABEL_56;
    }
    while ( v59 )
    {
      --v59;
      v32 = (unsigned __int8)*v9++ << v5;
      v5 += 8;
      a3 = 0;
      v6 |= v32;
      v71 = v6;
      v61 = v9;
      if ( v5 >= 3 )
        goto LABEL_55;
    }
    goto LABEL_94;
  }
LABEL_56:
  while ( *(_DWORD *)(v3 + 8) < 0x13u )
    *(_DWORD *)(v3 + 4 * dword_1008DC58[(*(_DWORD *)(v3 + 8))++] + 12) = 0;
  *(_DWORD *)(v3 + 1412) = 7;
  v23 = sub_1002B280(v3 + 1432, (unsigned int *)(v3 + 1412), (_DWORD *)(v3 + 12), (int *)(v3 + 1416));
  if ( v23 )
  {
    *(_BYTE *)v3 = 9;
LABEL_96:
    *(_DWORD *)(v7 + 4) = v59;
    v51 = (int)&v61[-*(_DWORD *)v7];
    *(_DWORD *)v7 = v61;
    *(_DWORD *)(v7 + 8) += v51;
    *(_DWORD *)(v3 + 1428) = v71;
    *(_DWORD *)(v3 + 14116) = v60;
    v58 = v23;
    goto LABEL_111;
  }
  v6 = v71;
  *(_DWORD *)(v3 + 8) = 0;
  v9 = v61;
  *(_BYTE *)v3 = 5;
LABEL_60:
  if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
  {
LABEL_81:
    v42 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 1416) = 0;
    v67 = 9;
    v66 = 6;
    v43 = sub_1002B2D0(
            (unsigned int *)(v3 + 12952),
            &v69,
            v3 + 1432,
            (v42 & 0x1F) + 257,
            ((v42 >> 5) & 0x1F) + 1,
            (_DWORD *)(v3 + 12),
            &v67,
            &v66,
            &v68);
    if ( v43 )
    {
      *(_BYTE *)v3 = 9;
      *(_DWORD *)(v7 + 4) = v59;
      v53 = (int)&v61[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v61;
      *(_DWORD *)(v7 + 8) += v53;
      *(_DWORD *)(v3 + 1428) = v71;
      *(_DWORD *)(v3 + 1424) = v65;
      *(_DWORD *)(v3 + 14116) = v60;
    }
    else
    {
      sub_1002AD70(v3 + 4, v67, v66, v69, v68);
      v5 = v65;
      v10 = v60;
      v9 = v61;
      v6 = v71;
      *(_BYTE *)v3 = 6;
LABEL_83:
      *(_DWORD *)(v7 + 4) = v59;
      v44 = (int)&v9[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 8) += v44;
      *(_DWORD *)(v3 + 14116) = v10;
      *(_DWORD *)(v3 + 1428) = v6;
      *(_DWORD *)(v3 + 1424) = v5;
      v43 = sub_1002B490(v7, v3, a3);
      if ( v43 == 1 )
      {
        v5 = *(_DWORD *)(v3 + 1424);
        v61 = *(char **)v7;
        v45 = *(char **)(v3 + 14116);
        v71 = *(_DWORD *)(v3 + 1428);
        v46 = *(_DWORD *)(v3 + 14112);
        a3 = 0;
        v59 = *(_DWORD *)(v7 + 4);
        v65 = *(_DWORD *)(v3 + 1424);
        v60 = v45;
        if ( (unsigned int)v45 >= v46 )
          v47 = *(_DWORD *)(v3 + 14108) - (_DWORD)v45;
        else
          v47 = v46 - (_DWORD)v45 - 1;
        v62 = v47;
        if ( !*(_DWORD *)(v3 + 1420) )
        {
          *(_BYTE *)v3 = 0;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 7;
LABEL_102:
        *(_DWORD *)(v3 + 14116) = v60;
        v55 = sub_1002B140(v7, v3, a3);
        v60 = *(char **)(v3 + 14116);
        if ( *(_DWORD *)(v3 + 14112) != *(_DWORD *)(v3 + 14116) )
        {
          *(_DWORD *)(v7 + 4) = v59;
          v56 = (int)&v61[-*(_DWORD *)v7];
          *(_DWORD *)v7 = v61;
          *(_DWORD *)(v7 + 8) += v56;
          *(_DWORD *)(v3 + 1428) = v71;
          *(_DWORD *)(v3 + 1424) = v5;
          *(_DWORD *)(v3 + 14116) = v60;
          return sub_1002B140(v7, v3, v55);
        }
        *(_BYTE *)v3 = 8;
LABEL_105:
        *(_DWORD *)(v7 + 4) = v59;
        v58 = 1;
        goto LABEL_109;
      }
    }
    return sub_1002B140(v7, v3, v43);
  }
  while ( 1 )
  {
    v33 = *(_WORD *)(v3 + 1412);
    v67 = *(_WORD *)(v3 + 1412);
    if ( v5 < v33 )
      break;
LABEL_64:
    v35 = *(_DWORD *)(v3 + 1416) + 8 * (v6 & dword_1008DC10[*(_DWORD *)(v3 + 1412)]);
    v36 = *(_BYTE *)(v35 + 1);
    v37 = *(_DWORD *)(v35 + 4);
    v66 = v37;
    if ( v37 >= 0x10 )
    {
      if ( v37 == 18 )
        v67 = 7;
      else
        v67 = v37 - 14;
      v63 = 8 * (v37 == 18) + 3;
      v70 = (unsigned __int16)(v36 + v67);
      if ( v5 < v70 )
      {
        while ( v59 )
        {
          --v59;
          v38 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          a3 = 0;
          v6 |= v38;
          v71 = v6;
          v61 = v9;
          if ( v5 >= v70 )
            goto LABEL_72;
        }
        v52 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v52;
        *(_DWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = a3;
        goto LABEL_111;
      }
LABEL_72:
      v39 = v6 >> v36;
      v64 = (v39 & dword_1008DC10[v67]) + v63;
      v6 = v39 >> v67;
      v5 -= v36 + v67;
      v40 = *(_DWORD *)(v3 + 8);
      v71 = v6;
      v65 = v5;
      if ( v40 + v64 > ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
        goto LABEL_98;
      if ( v66 == 16 )
      {
        if ( v40 < 1 )
        {
LABEL_98:
          *(_BYTE *)v3 = 9;
          *(_DWORD *)(v7 + 4) = v59;
          v58 = -3;
          goto LABEL_109;
        }
        v66 = *(_DWORD *)(v3 + 4 * v40 + 8);
      }
      else
      {
        v66 = 0;
      }
      v41 = (unsigned int *)(v3 + 4 * v40 + 12);
      do
      {
        *v41 = v66;
        ++v40;
        ++v41;
        --v64;
      }
      while ( v64 );
      v9 = v61;
      *(_DWORD *)(v3 + 8) = v40;
    }
    else
    {
      v6 >>= v36;
      v5 -= v36;
      *(_DWORD *)(v3 + 4 * (*(_DWORD *)(v3 + 8))++ + 12) = v37;
      v71 = v6;
      v65 = v5;
    }
    if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
      goto LABEL_81;
  }
  while ( v59 )
  {
    --v59;
    v34 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v34;
    v71 = v6;
    v61 = v9;
    if ( v5 >= v67 )
      goto LABEL_64;
  }
LABEL_94:
  v48 = v61;
  v50 = (int)&v61[-*(_DWORD *)v7];
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) += v50;
  v58 = a3;
LABEL_110:
  *(_DWORD *)v7 = v48;
  *(_DWORD *)(v3 + 14116) = v60;
  *(_DWORD *)(v3 + 1428) = v71;
LABEL_111:
  *(_DWORD *)(v3 + 1424) = v5;
  return sub_1002B140(v7, v3, v58);
}
// 1008DC10: using guessed type int dword_1008DC10[];
// 1008DC58: using guessed type int dword_1008DC58[];

//----- (1002C510) --------------------------------------------------------
signed int __usercall sub_1002C510@<eax>(int a1@<edi>, int a2)
{
  int v2; // ebp@3
  int v3; // ebx@3
  signed int v4; // esi@3
  unsigned int v5; // eax@3
  int v6; // eax@5
  _BYTE *v7; // ecx@6
  int v8; // eax@9
  int v9; // ecx@10
  int v10; // eax@13
  int v11; // eax@21
  int v12; // eax@23
  _BYTE *v13; // edx@24
  int v14; // eax@25
  _BYTE *v15; // ecx@26
  int v16; // eax@27
  signed int result; // eax@32
  int v18; // eax@34
  int v19; // eax@36
  _BYTE *v20; // edx@37
  int v21; // eax@38
  _BYTE *v22; // ecx@39
  int v23; // eax@40
  signed int v24; // [sp+8h] [bp+4h]@3

  if ( !a1 || !*(_DWORD *)a1 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  v3 = -5;
  v4 = a2 != 4 ? 0 : 0xFFFFFFFB;
  v5 = *(_BYTE *)v2;
  v24 = a2 != 4 ? 0 : 0xFFFFFFFB;
  while ( 2 )
  {
    switch ( v5 )
    {
      case 0u:
        v6 = *(_DWORD *)(a1 + 4);
        if ( !v6 )
          goto LABEL_44;
        v7 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v6 - 1;
        *(_DWORD *)(v2 + 4) = *v7;
        ++*(_DWORD *)a1;
        v3 = v4;
        if ( (*(_DWORD *)(v2 + 4) & 0xF) != 8 || (unsigned int)((*(_DWORD *)(v2 + 4) >> 4) + 8) > *(_DWORD *)(v2 + 16) )
          goto LABEL_29;
        *(_BYTE *)v2 = 1;
        goto LABEL_9;
      case 1u:
LABEL_9:
        v8 = *(_DWORD *)(a1 + 4);
        if ( !v8 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v8 - 1;
        v9 = *(_BYTE *)(*(_DWORD *)a1)++;
        v3 = v4;
        if ( (v9 + (*(_DWORD *)(v2 + 4) << 8)) % 0x1Fu )
          goto LABEL_29;
        if ( !(v9 & 0x20) )
        {
          *(_BYTE *)v2 = 7;
LABEL_31:
          v5 = *(_BYTE *)v2;
          if ( v5 > 0xD )
            return -2;
          continue;
        }
        *(_BYTE *)v2 = 2;
LABEL_34:
        v18 = *(_DWORD *)(a1 + 4);
        if ( !v18 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v18 - 1;
        *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
        v3 = v4;
        *(_BYTE *)v2 = 3;
LABEL_36:
        v19 = *(_DWORD *)(a1 + 4);
        if ( !v19 )
          goto LABEL_44;
        v20 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v19 - 1;
        *(_DWORD *)(v2 + 8) += *v20 << 16;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 4;
LABEL_38:
        v21 = *(_DWORD *)(a1 + 4);
        if ( !v21 )
          goto LABEL_44;
        v22 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v21 - 1;
        *(_DWORD *)(v2 + 8) += *v22 << 8;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 5;
LABEL_40:
        v23 = *(_DWORD *)(a1 + 4);
        if ( v23 )
        {
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v23 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(v2 + 8);
          *(_BYTE *)v2 = 6;
          result = 2;
        }
        else
        {
LABEL_44:
          result = v3;
        }
        return result;
      case 7u:
        v10 = sub_1002BB30(a1, *(_DWORD *)(v2 + 20), v3);
        v3 = v10;
        if ( v10 == -3 )
        {
          *(_DWORD *)(v2 + 4) = 0;
        }
        else
        {
          if ( !v10 )
            v3 = v4;
          if ( v3 != 1 )
            goto LABEL_44;
          v3 = v4;
          sub_1002AD20((_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 20), a1);
          v4 = v24;
          if ( *(_DWORD *)(v2 + 12) )
          {
            *(_BYTE *)v2 = 12;
            goto LABEL_31;
          }
          *(_BYTE *)v2 = 8;
LABEL_21:
          v11 = *(_DWORD *)(a1 + 4);
          if ( !v11 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v11 - 1;
          *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
          v3 = v4;
          *(_BYTE *)v2 = 9;
LABEL_23:
          v12 = *(_DWORD *)(a1 + 4);
          if ( !v12 )
            goto LABEL_44;
          v13 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v12 - 1;
          *(_DWORD *)(v2 + 8) += *v13 << 16;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 10;
LABEL_25:
          v14 = *(_DWORD *)(a1 + 4);
          if ( !v14 )
            goto LABEL_44;
          v15 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v14 - 1;
          *(_DWORD *)(v2 + 8) += *v15 << 8;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 11;
LABEL_27:
          v16 = *(_DWORD *)(a1 + 4);
          if ( !v16 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v16 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          v3 = v4;
          if ( *(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
          {
            *(_BYTE *)v2 = 12;
            return 1;
          }
LABEL_29:
          *(_DWORD *)(v2 + 4) = 5;
        }
        *(_BYTE *)v2 = 13;
        goto LABEL_31;
      case 8u:
        goto LABEL_21;
      case 9u:
        goto LABEL_23;
      case 0xAu:
        goto LABEL_25;
      case 0xBu:
        goto LABEL_27;
      case 2u:
        goto LABEL_34;
      case 3u:
        goto LABEL_36;
      case 4u:
        goto LABEL_38;
      case 5u:
        goto LABEL_40;
      case 6u:
        *(_BYTE *)v2 = 13;
        *(_DWORD *)(v2 + 4) = 0;
        return -2;
      case 0xCu:
        return 1;
      case 0xDu:
        return -3;
      default:
        return -2;
    }
  }
}

//----- (1002C840) --------------------------------------------------------
signed int __cdecl sub_1002C840(int a1, int a2)
{
  return sub_1002C510(a1, a2);
}

//----- (1002C860) --------------------------------------------------------
__int16 *__cdecl sub_1002C860(char a1, unsigned __int16 a2)
{
  char *v2; // eax@1
  signed int v3; // ecx@1
  unsigned __int8 v4; // bl@3
  char v5; // cl@6
  int v6; // eax@6
  unsigned __int16 *v7; // esi@25
  int v8; // edi@25
  int v9; // eax@29
  unsigned __int16 *v10; // esi@32
  int v11; // edi@32
  int v12; // eax@36
  char v14; // [sp+8h] [bp-224h]@3
  char v15; // [sp+9h] [bp-223h]@3
  unsigned __int8 v16; // [sp+Ah] [bp-222h]@3
  char v17; // [sp+Bh] [bp-221h]@26
  unsigned __int16 v18; // [sp+Ch] [bp-220h]@26
  char v19[4]; // [sp+10h] [bp-21Ch]@3
  char v20; // [sp+14h] [bp-218h]@4
  char v21[20]; // [sp+15h] [bp-217h]@8
  char v22; // [sp+29h] [bp-203h]@9
  __int16 v23; // [sp+2Ch] [bp-200h]@13
  __int16 v24; // [sp+2Eh] [bp-1FEh]@15
  __int16 v25[100]; // [sp+98h] [bp-194h]@3
  __int16 v26[100]; // [sp+160h] [bp-CCh]@3

  v2 = byte_101E50B2;
  v3 = 203;
  do
  {
    *((_WORD *)v2 - 1) = a2;
    *v2 = 3;
    v2 += 4;
    --v3;
  }
  while ( v3 );
  v4 = 0;
  v14 = 0;
  v16 = 0;
  v15 = 0;
  memset(v26, 0, 0xC8u);
  memset(v25, 0, 0xC8u);
  v19[0] = 0;
  do
  {
    if ( !sub_1002F4F0(v19[0], &v20) )
      goto LABEL_20;
    if ( v20 )
    {
LABEL_9:
      ++v15;
      if ( v22 )
      {
        if ( v22 == 1 )
        {
          if ( !v23 )
            goto LABEL_20;
          v25[v4] = v23;
LABEL_19:
          ++v4;
          goto LABEL_20;
        }
        if ( v22 != 2 )
          goto LABEL_20;
      }
      else if ( v24 )
      {
        v26[v16++] = v24;
      }
      if ( !v23 )
        goto LABEL_20;
      v25[v4] = v23;
      goto LABEL_19;
    }
    v5 = 0;
    v6 = 0;
    while ( v5 )
    {
      v5 = v21[v6++];
      if ( v5 != byte_1004764C[v6] )
        goto LABEL_9;
    }
LABEL_20:
    ++v19[0];
  }
  while ( v19[0] < 0x64u );
  if ( v15 )
  {
    if ( !a1 )
    {
      word_101E50B0[0] = 6;
      byte_101E50B2[0] = 1;
      word_101E50B4 = 10;
      byte_101E50B6 = 1;
      v14 = 2;
    }
    if ( v4 )
    {
      v7 = (unsigned __int16 *)v25;
      v8 = v4;
      do
      {
        if ( sub_1001A2E0(*v7, 0, &v17, &v18) == 1 && v17 == a1 && v18 < a2 )
        {
          v9 = 2 * (unsigned __int8)v14;
          word_101E50B0[v9] = v18;
          byte_101E50B2[v9 * 2] = 1;
          ++v14;
        }
        ++v7;
        --v8;
      }
      while ( v8 );
    }
    if ( v16 )
    {
      v10 = (unsigned __int16 *)v26;
      v11 = v16;
      do
      {
        if ( sub_1001A280(*v10, 0, &v17, &v18) == 1 && v17 == a1 && v18 < a2 )
        {
          v12 = 2 * (unsigned __int8)v14;
          word_101E50B0[v12] = v18;
          byte_101E50B2[v12 * 2] = 1;
          ++v14;
        }
        ++v10;
        --v11;
      }
      while ( v11 );
    }
  }
  return word_101E50B0;
}
// 101E50B0: using guessed type __int16 word_101E50B0[];
// 101E50B4: using guessed type __int16 word_101E50B4;
// 101E50B6: using guessed type char byte_101E50B6;
// 1002C860: using guessed type __int16 var_CC[100];
// 1002C860: using guessed type __int16 var_194[100];
// 1002C860: using guessed type char var_217[20];

//----- (1002CAD0) --------------------------------------------------------
int __cdecl sub_1002CAD0(unsigned __int8 a1, char a2)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 3u )
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_10090468 + a1);
        break;
      case 0:
        result = (int)*(&off_10090474 + a1);
        break;
      case 1:
        result = (int)*(&off_10090480 + a1);
        break;
      case 2:
        result = (int)*(&off_1009048C + a1);
        break;
      case 3:
        result = (int)*(&off_10090498 + a1);
        break;
      case 5:
        result = (int)*(&off_100904A4 + a1);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 10090468: using guessed type void *off_10090468;
// 10090474: using guessed type void *off_10090474;
// 10090480: using guessed type void *off_10090480;
// 1009048C: using guessed type void *off_1009048C;
// 10090498: using guessed type void *off_10090498;
// 100904A4: using guessed type void *off_100904A4;

//----- (1002CB50) --------------------------------------------------------
int __cdecl sub_1002CB50(unsigned __int8 a1, char a2)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 3u )
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100903D8 + a1);
        break;
      case 0:
        result = (int)*(&off_100903E4 + a1);
        break;
      case 1:
        result = (int)*(&off_100903F0 + a1);
        break;
      case 2:
        result = (int)*(&off_100903FC + a1);
        break;
      case 3:
        result = (int)*(&off_10090408 + a1);
        break;
      case 5:
        result = (int)*(&off_10090414 + a1);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 100903D8: using guessed type void *off_100903D8;
// 100903E4: using guessed type void *off_100903E4;
// 100903F0: using guessed type void *off_100903F0;
// 100903FC: using guessed type void *off_100903FC;
// 10090408: using guessed type void *off_10090408;
// 10090414: using guessed type void *off_10090414;

//----- (1002CBD0) --------------------------------------------------------
int __cdecl sub_1002CBD0(unsigned __int8 a1, char a2)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 3u )
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100904B0 + a1);
        break;
      case 0:
        result = (int)*(&off_100904BC + a1);
        break;
      case 1:
        result = (int)*(&off_100904C8 + a1);
        break;
      case 2:
        result = (int)*(&off_100904D4 + a1);
        break;
      case 3:
        result = (int)*(&off_100904E0 + a1);
        break;
      case 5:
        result = (int)*(&off_100904EC + a1);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 100904B0: using guessed type void *off_100904B0;
// 100904BC: using guessed type void *off_100904BC;
// 100904C8: using guessed type void *off_100904C8;
// 100904D4: using guessed type void *off_100904D4;
// 100904E0: using guessed type void *off_100904E0;
// 100904EC: using guessed type void *off_100904EC;

//----- (1002CC50) --------------------------------------------------------
void *__cdecl sub_1002CC50(unsigned __int8 a1, char a2)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 3u )
  {
    switch ( a2 )
    {
      case 6:
        result = *(&off_10090420 + a1);
        break;
      case 0:
        result = *(&off_1009042C + a1);
        break;
      case 1:
        result = *(&off_10090438 + a1);
        break;
      case 2:
        result = *(&off_10090444 + a1);
        break;
      case 3:
        result = *(&off_10090450 + a1);
        break;
      case 5:
        result = &unk_1008F7B4;
        break;
      default:
        return result;
    }
  }
  return result;
}
// 10090420: using guessed type void *off_10090420;
// 1009042C: using guessed type void *off_1009042C;
// 10090438: using guessed type void *off_10090438;
// 10090444: using guessed type void *off_10090444;
// 10090450: using guessed type void *off_10090450;

//----- (1002CCD0) --------------------------------------------------------
int __cdecl sub_1002CCD0(char a1)
{
  return sub_10014DE0(&a1, 1u, (int)&unk_100904F8, 28, 12, 11);
}

//----- (1002CCF0) --------------------------------------------------------
int __cdecl sub_1002CCF0(char a1)
{
  return sub_10014DE0(&a1, 1u, (int)&unk_1008FE68, 16, 11, 11);
}

//----- (1002CD10) --------------------------------------------------------
int __cdecl sub_1002CD10(char a1)
{
  return sub_10014DE0(&a1, 1u, (int)&unk_1008FF18, 64, 19, 19);
}

//----- (1002CD30) --------------------------------------------------------
void *__cdecl sub_1002CD30(char a1, unsigned __int8 a2, char a3)
{
  void *v3; // esi@1
  unsigned __int8 v4; // al@3
  void *result; // eax@4

  v3 = 0;
  if ( a2 >= 3u || (unsigned __int8)a1 > 0x3Fu )
  {
    result = 0;
  }
  else
  {
    v4 = sub_1002CCD0(a1);
    switch ( a3 )
    {
      case 6:
        result = &unk_1008F7A0;
        break;
      case 0:
        result = *(&off_100904FC + a2 + 7 * v4);
        break;
      case 1:
        result = *(&off_10090508 + a2 + 7 * v4);
        break;
      case 2:
        result = &unk_1008F7AC;
        break;
      case 3:
        result = &unk_1008F7B0;
        break;
      case 5:
        v3 = &unk_1008F7B4;
        goto LABEL_10;
      default:
LABEL_10:
        result = v3;
        break;
    }
  }
  return result;
}
// 100904FC: using guessed type void *off_100904FC;
// 10090508: using guessed type void *off_10090508;

//----- (1002CDF0) --------------------------------------------------------
void *__cdecl sub_1002CDF0(unsigned __int8 a1, char a2, char a3)
{
  void *v3; // esi@1
  int v4; // eax@3
  void *result; // eax@4

  v3 = 0;
  if ( a1 >= 3u || (unsigned __int8)a2 >= 0xBu )
  {
    result = 0;
  }
  else
  {
    v4 = sub_1002CCF0(a2);
    switch ( a3 )
    {
      case 6:
        result = *(&off_1008FE6C + a1 + 4 * v4);
        break;
      case 0:
        result = &unk_1008F7A4;
        break;
      case 1:
        result = &unk_1008F7A8;
        break;
      case 2:
        result = &unk_1008F7AC;
        break;
      case 3:
        result = &unk_1008F7B0;
        break;
      case 5:
        v3 = &unk_1008F7B4;
        goto LABEL_10;
      default:
LABEL_10:
        result = v3;
        break;
    }
  }
  return result;
}
// 1008FE6C: using guessed type void *off_1008FE6C;

//----- (1002CE90) --------------------------------------------------------
void *__cdecl sub_1002CE90(unsigned __int8 a1, char a2, char a3)
{
  void *v3; // esi@1
  int v4; // eax@3
  void *result; // eax@4

  v3 = 0;
  if ( a1 >= 3u || (unsigned __int8)a2 >= 0x13u )
  {
    result = 0;
  }
  else
  {
    v4 = sub_1002CD10(a2);
    switch ( a3 )
    {
      case 6:
        result = *(&off_1008FF1C + a1 + 16 * v4);
        break;
      case 0:
        result = *(&off_1008FF28 + a1 + 16 * v4);
        break;
      case 1:
        result = *(&off_1008FF34 + a1 + 16 * v4);
        break;
      case 2:
        result = *(&off_1008FF40 + a1 + 16 * v4);
        break;
      case 3:
        result = *(&off_1008FF4C + a1 + 16 * v4);
        break;
      case 5:
        v3 = &unk_1008F7B4;
        goto LABEL_10;
      default:
LABEL_10:
        result = v3;
        break;
    }
  }
  return result;
}
// 1008FF1C: using guessed type void *off_1008FF1C;
// 1008FF28: using guessed type void *off_1008FF28;
// 1008FF34: using guessed type void *off_1008FF34;
// 1008FF40: using guessed type void *off_1008FF40;
// 1008FF4C: using guessed type void *off_1008FF4C;

//----- (1002CF60) --------------------------------------------------------
char sub_1002CF60()
{
  return *(_BYTE *)(dword_1020D810 + 33316);
}
// 1020D810: using guessed type int dword_1020D810;

//----- (1002CF70) --------------------------------------------------------
BOOL __fastcall sub_1002CF70(int a1)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = a1;
  return sub_10016F70(6, 1, 27, 0, (int)&v2, 4) && v2 & 1;
}

//----- (1002CFA0) --------------------------------------------------------
void *__cdecl sub_1002CFA0(char a1)
{
  void *result; // eax@1

  result = 0;
  switch ( a1 )
  {
    case 6:
      result = &unk_100907BC;
      break;
    case 0:
      result = &unk_100907C0;
      break;
    case 1:
      result = &unk_100907C4;
      break;
    case 2:
      result = &unk_100907D0;
      break;
    case 3:
      result = &unk_100907CC;
      break;
    default:
      return result;
  }
  return result;
}

//----- (1002CFF0) --------------------------------------------------------
char sub_1002CFF0()
{
  signed int v0; // esi@1
  char result; // al@11

  qmemcpy(dword_101E5A80, &unk_10090888, 0x5Cu);
  v0 = 23;
  if ( sub_10021270(0) == 1 )
  {
    dword_101E5ADC = 65569;
    dword_101E5AE0 = 65910;
    dword_101E5AE4 = 65909;
    dword_101E5AE8 = 65912;
    dword_101E5AEC = 65914;
    dword_101E5AF0 = 65913;
    dword_101E5AF4 = 65578;
    dword_101E5AF8 = 65852;
    dword_101E5AFC = 65908;
    dword_101E5B00 = 65898;
    v0 = 33;
  }
  if ( sub_10021270(7u) == 1 || sub_10021270(8u) == 1 )
    dword_101E5A80[v0++] = 65635;
  if ( sub_1002EBF0(0, 4u) || sub_1002EBF0(1u, 4u) )
  {
    dword_101E5A80[v0] = 65951;
    dword_101E5A84[v0] = 65952;
    dword_101E5A88[v0] = 65950;
    dword_101E5A8C[v0] = 65949;
    dword_101E5A90[v0] = 65953;
    v0 += 5;
  }
  if ( sub_10021270(2u) == 1 )
  {
    dword_101E5A80[v0] = 65906;
    dword_101E5A84[v0] = 65905;
    dword_101E5A88[v0] = 65907;
    dword_101E5A8C[v0] = 65912;
    dword_101E5A90[v0] = 65914;
    dword_101E5A94[v0] = 65913;
    dword_101E5A98[v0] = 65578;
    dword_101E5A9C[v0] = 65569;
    dword_101E5AA0[v0] = 65944;
    dword_101E5AA4[v0] = 65945;
    dword_101E5AA8[v0] = 65946;
    dword_101E5AAC[v0] = 65947;
    dword_101E5AB0[v0] = 65954;
    v0 += 13;
  }
  result = sub_1002F5A0(1);
  if ( result )
  {
    dword_101E5A80[v0] = 65569;
    dword_101E5A84[v0] = 65944;
    dword_101E5A88[v0] = 65945;
    dword_101E5A8C[v0] = 65946;
    dword_101E5A90[v0] = 65947;
    result = 122;
    dword_101E5A94[v0] = 65954;
    dword_101E5A98[v0] = 65912;
    dword_101E5A9C[v0] = 65914;
    dword_101E5AA0[v0] = 65913;
    dword_101E5AA4[v0] = 65578;
    v0 += 10;
  }
  LOWORD(dword_101E5A80[v0]) = 904;
  BYTE2(dword_101E5A80[v0]) = 3;
  return result;
}
// 101E5A80: using guessed type int dword_101E5A80[];
// 101E5A84: using guessed type int dword_101E5A84[];
// 101E5A88: using guessed type int dword_101E5A88[];
// 101E5A8C: using guessed type int dword_101E5A8C[];
// 101E5A90: using guessed type int dword_101E5A90[];
// 101E5A94: using guessed type int dword_101E5A94[];
// 101E5A98: using guessed type int dword_101E5A98[];
// 101E5A9C: using guessed type int dword_101E5A9C[];
// 101E5AA0: using guessed type int dword_101E5AA0[];
// 101E5AA4: using guessed type int dword_101E5AA4[];
// 101E5AA8: using guessed type int dword_101E5AA8[];
// 101E5AAC: using guessed type int dword_101E5AAC[];
// 101E5AB0: using guessed type int dword_101E5AB0[];
// 101E5ADC: using guessed type int dword_101E5ADC;
// 101E5AE0: using guessed type int dword_101E5AE0;
// 101E5AE4: using guessed type int dword_101E5AE4;
// 101E5AE8: using guessed type int dword_101E5AE8;
// 101E5AEC: using guessed type int dword_101E5AEC;
// 101E5AF0: using guessed type int dword_101E5AF0;
// 101E5AF4: using guessed type int dword_101E5AF4;
// 101E5AF8: using guessed type int dword_101E5AF8;
// 101E5AFC: using guessed type int dword_101E5AFC;
// 101E5B00: using guessed type int dword_101E5B00;

//----- (1002D280) --------------------------------------------------------
int *__cdecl sub_1002D280(char a1)
{
  int *result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = (int *)&unk_100907BC;
      break;
    case 0:
      result = (int *)&unk_10090878;
      break;
    case 1:
      result = (int *)&unk_100907C4;
      break;
    case 2:
      sub_1002CFF0();
      result = dword_101E5A80;
      break;
    case 3:
      result = (int *)&unk_1009097C;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 101E5A80: using guessed type int dword_101E5A80[];

//----- (1002D2E0) --------------------------------------------------------
bool __thiscall sub_1002D2E0(void *this)
{
  return (sub_10015630(this) & 0x800) == 2048;
}

//----- (1002D300) --------------------------------------------------------
void *__cdecl sub_1002D300(char a1)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 7 )
  {
    switch ( a1 )
    {
      case 6:
        result = &unk_10090A08;
        break;
      case 0:
        result = &unk_10090A0C;
        break;
      case 1:
        result = &unk_10090A10;
        break;
      case 2:
        result = &unk_10090A64;
        break;
      case 3:
        result = &unk_10090A88;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (1002D360) --------------------------------------------------------
int __cdecl sub_1002D360(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 0x33u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_10094C6C + a1 + 11 * a2);
        break;
      case 0:
        result = (int)*(&off_10094C74 + a1 + 11 * a2);
        break;
      case 1:
        result = (int)*(&off_10094C7C + a1 + 11 * a2);
        break;
      case 2:
        result = (int)*(&off_10094C84 + a1 + 11 * a2);
        break;
      case 3:
        result = (int)*(&off_10094C8C + a1 + 11 * a2);
        break;
      default:
        sub_10014D70("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 189, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 10094C6C: using guessed type void *off_10094C6C;
// 10094C74: using guessed type void *off_10094C74;
// 10094C7C: using guessed type void *off_10094C7C;
// 10094C84: using guessed type void *off_10094C84;
// 10094C8C: using guessed type void *off_10094C8C;

//----- (1002D430) --------------------------------------------------------
int __cdecl sub_1002D430(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  unsigned __int8 v4; // cl@2
  int result; // eax@8
  int v6; // [sp-Ch] [bp-7Ch]@13
  char v7; // [sp-8h] [bp-78h]@13
  char v8; // [sp+8h] [bp-68h]@6

  if ( a1 >= 2u || (v4 = a2, a2 >= 0xAu) || a3 >= 4u )
  {
LABEL_22:
    result = 0;
  }
  else if ( a3 == 1 )
  {
    if ( !a2 )
    {
      _snprintf(&v8, 0x64u, "INVALID CONFIG: anlg_in chnl %d - format %d", 0, 1);
      sub_10014D70("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 265, 0, &v8);
      v4 = 0;
    }
    switch ( a4 )
    {
      case 6:
        result = (int)*(&off_10095530 + a1 + 10 * v4);
        break;
      case 0:
        result = (int)*(&off_10095538 + a1 + 10 * v4);
        break;
      case 1:
        result = (int)*(&off_10095540 + a1 + 10 * v4);
        break;
      case 2:
        result = (int)*(&off_10095548 + a1 + 10 * v4);
        break;
      case 3:
        result = (int)*(&off_10095550 + a1 + 10 * v4);
        break;
      default:
        v7 = 0;
        v6 = 292;
        goto LABEL_21;
    }
  }
  else
  {
    switch ( a4 )
    {
      case 6:
        result = (int)*(&off_100956C0 + a1 + 10 * a3);
        break;
      case 0:
        result = (int)*(&off_100956C8 + a1 + 10 * a3);
        break;
      case 1:
        result = (int)*(&off_100956D0 + a1 + 10 * a3);
        break;
      case 2:
        result = (int)*(&off_100956D8 + a1 + 10 * a3);
        break;
      case 3:
        result = (int)*(&off_100956E0 + a1 + 10 * a3);
        break;
      default:
        v7 = 0;
        v6 = 322;
LABEL_21:
        sub_10014D70("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", v6, v7, 0);
        goto LABEL_22;
    }
  }
  return result;
}
// 10095530: using guessed type void *off_10095530;
// 10095538: using guessed type void *off_10095538;
// 10095540: using guessed type void *off_10095540;
// 10095548: using guessed type void *off_10095548;
// 10095550: using guessed type void *off_10095550;
// 100956C0: using guessed type void *off_100956C0;
// 100956C8: using guessed type void *off_100956C8;
// 100956D0: using guessed type void *off_100956D0;
// 100956D8: using guessed type void *off_100956D8;
// 100956E0: using guessed type void *off_100956E0;

//----- (1002D6D0) --------------------------------------------------------
int __cdecl sub_1002D6D0(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 0xBu )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_10095760 + a1 + 10 * a2);
        break;
      case 0:
        result = (int)*(&off_10095768 + a1 + 10 * a2);
        break;
      case 1:
        result = (int)*(&off_10095770 + a1 + 10 * a2);
        break;
      case 2:
        result = (int)*(&off_10095778 + a1 + 10 * a2);
        break;
      case 3:
        result = (int)*(&off_10095780 + a1 + 10 * a2);
        break;
      default:
        sub_10014D70("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 407, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 10095760: using guessed type void *off_10095760;
// 10095768: using guessed type void *off_10095768;
// 10095770: using guessed type void *off_10095770;
// 10095778: using guessed type void *off_10095778;
// 10095780: using guessed type void *off_10095780;

//----- (1002D7A0) --------------------------------------------------------
int __cdecl sub_1002D7A0(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 8u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_1009591C + a1 + 11 * a2);
        break;
      case 0:
        result = (int)*(&off_10095924 + a1 + 11 * a2);
        break;
      case 1:
        result = (int)*(&off_1009592C + a1 + 11 * a2);
        break;
      case 2:
        result = (int)*(&off_10095934 + a1 + 11 * a2);
        break;
      case 3:
        result = (int)*(&off_1009593C + a1 + 11 * a2);
        break;
      default:
        sub_10014D70("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 606, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 1009591C: using guessed type void *off_1009591C;
// 10095924: using guessed type void *off_10095924;
// 1009592C: using guessed type void *off_1009592C;
// 10095934: using guessed type void *off_10095934;
// 1009593C: using guessed type void *off_1009593C;

//----- (1002D870) --------------------------------------------------------
int __cdecl sub_1002D870(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 3u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_10095A78 + a1 + 10 * a2);
        break;
      case 0:
        result = (int)*(&off_10095A80 + a1 + 10 * a2);
        break;
      case 1:
        result = (int)*(&off_10095A88 + a1 + 10 * a2);
        break;
      case 2:
        result = (int)*(&off_10095A90 + a1 + 10 * a2);
        break;
      case 3:
        result = (int)*(&off_10095A98 + a1 + 10 * a2);
        break;
      default:
        sub_10014D70("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 689, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 10095A78: using guessed type void *off_10095A78;
// 10095A80: using guessed type void *off_10095A80;
// 10095A88: using guessed type void *off_10095A88;
// 10095A90: using guessed type void *off_10095A90;
// 10095A98: using guessed type void *off_10095A98;

//----- (1002D940) --------------------------------------------------------
int __cdecl sub_1002D940(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_10095AF0 + a1);
        break;
      case 0:
        result = (int)*(&off_10095AF8 + a1);
        break;
      case 1:
        result = (int)*(&off_10095B00 + a1);
        break;
      case 2:
        result = (int)*(&off_10095B08 + a1);
        break;
      case 3:
        result = (int)*(&off_10095B10 + a1);
        break;
      default:
        sub_10014D70("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 768, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 10095AF0: using guessed type void *off_10095AF0;
// 10095AF8: using guessed type void *off_10095AF8;
// 10095B00: using guessed type void *off_10095B00;
// 10095B08: using guessed type void *off_10095B08;
// 10095B10: using guessed type void *off_10095B10;

//----- (1002D9D0) --------------------------------------------------------
int __cdecl sub_1002D9D0(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_10095B18 + a1);
        break;
      case 0:
        result = (int)*(&off_10095B20 + a1);
        break;
      case 1:
        result = (int)*(&off_10095B28 + a1);
        break;
      case 2:
        result = (int)*(&off_10095B30 + a1);
        break;
      case 3:
        result = (int)*(&off_10095B38 + a1);
        break;
      default:
        sub_10014D70("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 847, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 10095B18: using guessed type void *off_10095B18;
// 10095B20: using guessed type void *off_10095B20;
// 10095B28: using guessed type void *off_10095B28;
// 10095B30: using guessed type void *off_10095B30;
// 10095B38: using guessed type void *off_10095B38;

//----- (1002DA60) --------------------------------------------------------
int __cdecl sub_1002DA60(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_10095B40 + a1);
        break;
      case 0:
        result = (int)*(&off_10095B48 + a1);
        break;
      case 1:
        result = (int)*(&off_10095B50 + a1);
        break;
      case 2:
        result = (int)*(&off_10095B58 + a1);
        break;
      case 3:
        result = (int)*(&off_10095B60 + a1);
        break;
      default:
        sub_10014D70("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 927, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 10095B40: using guessed type void *off_10095B40;
// 10095B48: using guessed type void *off_10095B48;
// 10095B50: using guessed type void *off_10095B50;
// 10095B58: using guessed type void *off_10095B58;
// 10095B60: using guessed type void *off_10095B60;

//----- (1002DAF0) --------------------------------------------------------
int __cdecl sub_1002DAF0(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 0x31u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_10095B6C + a1 + 11 * a2);
        break;
      case 0:
        result = (int)*(&off_10095B74 + a1 + 11 * a2);
        break;
      case 1:
        result = (int)*(&off_10095B7C + a1 + 11 * a2);
        break;
      case 2:
        result = (int)*(&off_10095B84 + a1 + 11 * a2);
        break;
      case 3:
        result = (int)*(&off_10095B8C + a1 + 11 * a2);
        break;
      default:
        sub_10014D70("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1118, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 10095B6C: using guessed type void *off_10095B6C;
// 10095B74: using guessed type void *off_10095B74;
// 10095B7C: using guessed type void *off_10095B7C;
// 10095B84: using guessed type void *off_10095B84;
// 10095B8C: using guessed type void *off_10095B8C;

//----- (1002DBC0) --------------------------------------------------------
int __cdecl sub_1002DBC0(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 0x1Du )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_100963DC + a1 + 11 * a2);
        break;
      case 0:
        result = (int)*(&off_100963E4 + a1 + 11 * a2);
        break;
      case 1:
        result = (int)*(&off_100963EC + a1 + 11 * a2);
        break;
      case 2:
        result = (int)*(&off_100963F4 + a1 + 11 * a2);
        break;
      case 3:
        result = (int)*(&off_100963FC + a1 + 11 * a2);
        break;
      default:
        sub_10014D70("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1308, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 100963DC: using guessed type void *off_100963DC;
// 100963E4: using guessed type void *off_100963E4;
// 100963EC: using guessed type void *off_100963EC;
// 100963F4: using guessed type void *off_100963F4;
// 100963FC: using guessed type void *off_100963FC;

//----- (1002DC90) --------------------------------------------------------
int __cdecl sub_1002DC90(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100968FC + a1);
        break;
      case 0:
        result = (int)*(&off_10096904 + a1);
        break;
      case 1:
        result = (int)*(&off_1009690C + a1);
        break;
      case 2:
        result = (int)*(&off_10096914 + a1);
        break;
      case 3:
        result = (int)*(&off_1009691C + a1);
        break;
      default:
        sub_10014D70("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1466, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 100968FC: using guessed type void *off_100968FC;
// 10096904: using guessed type void *off_10096904;
// 1009690C: using guessed type void *off_1009690C;
// 10096914: using guessed type void *off_10096914;
// 1009691C: using guessed type void *off_1009691C;

//----- (1002DD20) --------------------------------------------------------
int __cdecl sub_1002DD20(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_10096924 + a1);
        break;
      case 0:
        result = (int)*(&off_1009692C + a1);
        break;
      case 1:
        result = (int)*(&off_10096934 + a1);
        break;
      case 2:
        result = (int)*(&off_1009693C + a1);
        break;
      case 3:
        result = (int)*(&off_10096944 + a1);
        break;
      default:
        sub_10014D70("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1545, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 10096924: using guessed type void *off_10096924;
// 1009692C: using guessed type void *off_1009692C;
// 10096934: using guessed type void *off_10096934;
// 1009693C: using guessed type void *off_1009693C;
// 10096944: using guessed type void *off_10096944;

//----- (1002DDB0) --------------------------------------------------------
int __cdecl sub_1002DDB0(int a1, unsigned __int8 a2, char a3)
{
  int result; // eax@3

  if ( a2 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = *(_DWORD *)(a1 + 4 * a2);
        break;
      case 0:
        result = *(_DWORD *)(a1 + 4 * a2 + 8);
        break;
      case 1:
        result = *(_DWORD *)(a1 + 4 * a2 + 16);
        break;
      case 2:
        result = *(_DWORD *)(a1 + 4 * a2 + 24);
        break;
      case 3:
        result = *(_DWORD *)(a1 + 4 * a2 + 32);
        break;
      default:
        sub_10014D70("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1627, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}

//----- (1002DE50) --------------------------------------------------------
int __cdecl sub_1002DE50(unsigned __int8 a1, char a2)
{
  return sub_1002DDB0((int)&off_10096974, a1, a2);
}
// 10096974: using guessed type void *off_10096974;

//----- (1002DE70) --------------------------------------------------------
int __cdecl sub_1002DE70(unsigned __int8 a1, char a2)
{
  return sub_1002DDB0((int)&off_1009694C, a1, a2);
}
// 1009694C: using guessed type void *off_1009694C;

//----- (1002DE90) --------------------------------------------------------
char __cdecl sub_1002DE90(char a1, __int16 a2, unsigned __int16 *a3)
{
  char result; // al@1
  int v4; // ecx@3
  unsigned __int16 v5; // si@5

  result = 0;
  if ( a3 )
  {
    *a3 = 0;
    while ( 1 )
    {
      v4 = 2 * *a3;
      if ( word_10096A22[v4] == a2 && byte_10096A20[v4 * 2] == a1 )
        break;
      v5 = *a3 + 1;
      *a3 = v5;
      if ( v5 >= 0x1D8u )
        return result;
    }
    result = 1;
  }
  return result;
}
// 10096A22: using guessed type __int16 word_10096A22[];

//----- (1002DEF0) --------------------------------------------------------
void *__cdecl sub_1002DEF0(char a1)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 7 )
  {
    switch ( a1 )
    {
      case 6:
        result = &unk_10097180;
        break;
      case 0:
        result = &unk_10097184;
        break;
      case 1:
        result = &unk_10097188;
        break;
      case 2:
        result = &unk_10097210;
        break;
      case 3:
        result = &unk_10097284;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (1002DF50) --------------------------------------------------------
int __cdecl sub_1002DF50(unsigned __int8 a1, char a2)
{
  int result; // eax@1

  result = 0;
  if ( a2 >= 7 || a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_10097364 + a1);
        break;
      case 0:
        result = (int)*(&off_1009736C + a1);
        break;
      case 1:
        result = (int)*(&off_10097374 + a1);
        break;
      case 2:
        result = (int)*(&off_1009737C + a1);
        break;
      case 3:
        result = (int)*(&off_10097384 + a1);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 10097364: using guessed type void *off_10097364;
// 1009736C: using guessed type void *off_1009736C;
// 10097374: using guessed type void *off_10097374;
// 1009737C: using guessed type void *off_1009737C;
// 10097384: using guessed type void *off_10097384;

//----- (1002DFD0) --------------------------------------------------------
int __cdecl sub_1002DFD0(unsigned __int8 a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 2u )
    result = dword_1009738C[a1];
  return result;
}
// 1009738C: using guessed type int dword_1009738C[];

//----- (1002DFF0) --------------------------------------------------------
int __cdecl sub_1002DFF0(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 3u || a2 >= 0x23u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_10099814 + a1 + 16 * a2);
        break;
      case 0:
        result = (int)*(&off_10099820 + a1 + 16 * a2);
        break;
      case 1:
        result = (int)*(&off_1009982C + a1 + 16 * a2);
        break;
      case 2:
        result = (int)*(&off_10099838 + a1 + 16 * a2);
        break;
      case 3:
        result = (int)*(&off_10099844 + a1 + 16 * a2);
        break;
      default:
        sub_10014D70("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 209, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 10099814: using guessed type void *off_10099814;
// 10099820: using guessed type void *off_10099820;
// 1009982C: using guessed type void *off_1009982C;
// 10099838: using guessed type void *off_10099838;
// 10099844: using guessed type void *off_10099844;

//----- (1002E0C0) --------------------------------------------------------
int __cdecl sub_1002E0C0(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 3u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_10099798 + a1);
        break;
      case 0:
        result = (int)*(&off_100997A4 + a1);
        break;
      case 1:
        result = (int)*(&off_100997B0 + a1);
        break;
      case 2:
        result = (int)*(&off_100997BC + a1);
        break;
      case 3:
        result = (int)*(&off_100997C8 + a1);
        break;
      default:
        sub_10014D70("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 313, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 10099798: using guessed type void *off_10099798;
// 100997A4: using guessed type void *off_100997A4;
// 100997B0: using guessed type void *off_100997B0;
// 100997BC: using guessed type void *off_100997BC;
// 100997C8: using guessed type void *off_100997C8;

//----- (1002E150) --------------------------------------------------------
int __cdecl sub_1002E150(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 3u || a2 >= 0x21u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_1009A0D4 + a1 + 16 * a2);
        break;
      case 0:
        result = (int)*(&off_1009A0E0 + a1 + 16 * a2);
        break;
      case 1:
        result = (int)*(&off_1009A0EC + a1 + 16 * a2);
        break;
      case 2:
        result = (int)*(&off_1009A0F8 + a1 + 16 * a2);
        break;
      case 3:
        result = (int)*(&off_1009A104 + a1 + 16 * a2);
        break;
      default:
        sub_10014D70("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 504, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 1009A0D4: using guessed type void *off_1009A0D4;
// 1009A0E0: using guessed type void *off_1009A0E0;
// 1009A0EC: using guessed type void *off_1009A0EC;
// 1009A0F8: using guessed type void *off_1009A0F8;
// 1009A104: using guessed type void *off_1009A104;

//----- (1002E220) --------------------------------------------------------
int __cdecl sub_1002E220(int a1, unsigned __int8 a2, char a3)
{
  int result; // eax@3

  if ( a2 >= 3u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = *(_DWORD *)(a1 + 4 * a2);
        break;
      case 0:
        result = *(_DWORD *)(a1 + 4 * a2 + 12);
        break;
      case 1:
        result = *(_DWORD *)(a1 + 4 * a2 + 24);
        break;
      case 2:
        result = *(_DWORD *)(a1 + 4 * a2 + 36);
        break;
      case 3:
        result = *(_DWORD *)(a1 + 4 * a2 + 48);
        break;
      default:
        sub_10014D70("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 583, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}

//----- (1002E2C0) --------------------------------------------------------
int __cdecl sub_1002E2C0(unsigned __int8 a1, char a2)
{
  return sub_1002E220((int)&off_100997D4, a1, a2);
}
// 100997D4: using guessed type void *off_100997D4;

//----- (1002E2E0) --------------------------------------------------------
char __cdecl sub_1002E2E0(char a1)
{
  char result; // al@4

  switch ( a1 )
  {
    case 25:
      result = 0;
      break;
    case 26:
      result = 1;
      break;
    case 43:
      result = 2;
      break;
    default:
      sub_10014D70("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 169, 0, 0);
      result = 3;
      break;
  }
  return result;
}

//----- (1002E320) --------------------------------------------------------
char __cdecl sub_1002E320(char a1)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 26;
    }
    else if ( a1 == 2 )
    {
      result = 43;
    }
    else
    {
      sub_10014D70("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 259, 0, 0);
      result = 67;
    }
  }
  else
  {
    result = 25;
  }
  return result;
}

//----- (1002E360) --------------------------------------------------------
signed int __cdecl sub_1002E360(char a1)
{
  signed int result; // eax@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 0x2000;
    }
    else if ( a1 == 2 )
    {
      result = 0x80000;
    }
    else
    {
      sub_10014D70("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 317, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = 4096;
  }
  return result;
}

//----- (1002E3B0) --------------------------------------------------------
void *__cdecl sub_1002E3B0(char a1)
{
  void *result; // eax@1

  result = 0;
  switch ( a1 )
  {
    case 6:
      result = &unk_1009A9F8;
      break;
    case 0:
      result = &unk_1009A9FC;
      break;
    case 1:
      result = &unk_1009AC00;
      break;
    case 2:
      result = &unk_1009AA04;
      break;
    case 3:
      result = &unk_1009AA08;
      break;
    case 5:
      result = &unk_1009AA0C;
      break;
    default:
      return result;
  }
  return result;
}

//----- (1002E410) --------------------------------------------------------
void *__cdecl sub_1002E410(char a1)
{
  void *result; // eax@1

  result = 0;
  switch ( a1 )
  {
    case 6:
      result = &unk_1009AA10;
      break;
    case 0:
      result = &unk_1009AA3C;
      break;
    case 1:
      result = &unk_1009AA60;
      break;
    case 2:
      result = &unk_1009AA90;
      break;
    case 3:
      result = &unk_1009AB08;
      break;
    case 5:
      result = &unk_1009AA0C;
      break;
    default:
      return result;
  }
  return result;
}

//----- (1002E470) --------------------------------------------------------
void *__cdecl sub_1002E470(char a1)
{
  void *result; // eax@1

  result = 0;
  switch ( a1 )
  {
    case 6:
      result = &unk_1009A9F8;
      break;
    case 0:
      result = &unk_1009AC0C;
      break;
    case 1:
      result = &unk_1009AA00;
      break;
    case 2:
      result = &unk_1009AC20;
      break;
    case 3:
      result = &unk_1009AA08;
      break;
    case 5:
      result = &unk_1009AA0C;
      break;
    default:
      return result;
  }
  return result;
}

//----- (1002E4D0) --------------------------------------------------------
int __cdecl sub_1002E4D0(char a1, char a2)
{
  int result; // eax@1
  char v3; // cl@2

  result = 0;
  switch ( a1 )
  {
    case 3:
      v3 = 0;
      break;
    case 4:
      v3 = 1;
      break;
    case 5:
      v3 = 2;
      break;
    default:
      if ( a1 != 6 )
        return 0;
      v3 = 3;
      break;
  }
  switch ( a2 )
  {
    case 6:
      result = (int)*(&off_1009AC30 + (unsigned __int8)v3);
      break;
    case 0:
      result = (int)*(&off_1009AC40 + (unsigned __int8)v3);
      break;
    case 1:
      result = (int)*(&off_1009AC50 + (unsigned __int8)v3);
      break;
    case 2:
      result = (int)*(&off_1009AC60 + (unsigned __int8)v3);
      break;
    case 3:
      result = (int)*(&off_1009AC70 + (unsigned __int8)v3);
      break;
    case 5:
      result = (int)*(&off_1009AC80 + (unsigned __int8)v3);
      break;
    default:
      return result;
  }
  return result;
}
// 1009AC30: using guessed type void *off_1009AC30;
// 1009AC40: using guessed type void *off_1009AC40;
// 1009AC50: using guessed type void *off_1009AC50;
// 1009AC60: using guessed type void *off_1009AC60;
// 1009AC70: using guessed type void *off_1009AC70;
// 1009AC80: using guessed type void *off_1009AC80;

//----- (1002E570) --------------------------------------------------------
void *__cdecl sub_1002E570(char a1)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 7 )
  {
    switch ( a1 )
    {
      case 6:
        result = &unk_1009AC90;
        break;
      case 0:
        result = &unk_1009AC94;
        break;
      case 1:
        result = &unk_1009ACC8;
        break;
      case 2:
        result = &unk_1009ACF8;
        break;
      case 3:
        result = &unk_1009AD38;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (1002E5D0) --------------------------------------------------------
void *__cdecl sub_1002E5D0(char a1)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 7 )
  {
    switch ( a1 )
    {
      case 6:
        result = &unk_1009AD60;
        break;
      case 0:
        result = &unk_1009AD64;
        break;
      case 1:
        result = &unk_1009AD80;
        break;
      case 2:
        result = &unk_1009ADC4;
        break;
      case 3:
        result = &unk_1009ADD8;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (1002E630) --------------------------------------------------------
char __cdecl sub_1002E630(char a1)
{
  char result; // al@3

  if ( a1 == 20 )
  {
    result = 0;
  }
  else if ( a1 == 21 )
  {
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1002E650) --------------------------------------------------------
char __cdecl sub_1002E650(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // ecx@2
  int v5; // [sp+0h] [bp-Ch]@1
  __int16 v6; // [sp+4h] [bp-8h]@2
  int v7; // [sp+8h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_1020CF70)(a1, 12, &v5);
  if ( result )
  {
    v3 = v6;
    *(_DWORD *)a2 = v5;
    v4 = v7 & 0xFFFFFF;
    *(_WORD *)(a2 + 4) = v3;
    *(_DWORD *)(a2 + 8) = v4;
    result = 1;
  }
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;

//----- (1002E6A0) --------------------------------------------------------
char __cdecl sub_1002E6A0(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  __int16 v4; // cx@2
  __int16 v5; // dx@2
  __int16 v6; // cx@2
  int v7; // edx@2
  __int16 v8; // cx@2
  unsigned int v9; // ecx@2
  int v10; // edx@2
  __int16 v11; // [sp+0h] [bp-1Ch]@1
  __int16 v12; // [sp+2h] [bp-1Ah]@2
  __int16 v13; // [sp+4h] [bp-18h]@2
  __int16 v14; // [sp+6h] [bp-16h]@2
  __int16 v15; // [sp+8h] [bp-14h]@2
  int v16; // [sp+Ah] [bp-12h]@2
  __int16 v17; // [sp+Eh] [bp-Eh]@2
  int v18; // [sp+12h] [bp-Ah]@2
  unsigned int v19; // [sp+16h] [bp-6h]@2
  char v20; // [sp+1Ah] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_1020CF70)(a1, 27, &v11);
  if ( result )
  {
    v3 = v12;
    *(_WORD *)a2 = v11;
    v4 = v13;
    *(_WORD *)(a2 + 2) = v3;
    v5 = v14;
    *(_WORD *)(a2 + 4) = v4;
    v6 = v15;
    *(_WORD *)(a2 + 6) = v5;
    *(_DWORD *)(a2 + 12) = v16;
    v7 = v18;
    *(_WORD *)(a2 + 8) = v6;
    v8 = v17;
    *(_DWORD *)(a2 + 20) = v7;
    *(_WORD *)(a2 + 16) = v8;
    v9 = v19;
    *(_DWORD *)(a2 + 24) = v19 & 3;
    *(_DWORD *)(a2 + 28) = (v9 >> 2) & 1;
    v10 = (v9 >> 3) & 3;
    *(_DWORD *)(a2 + 36) = (v9 >> 5) & 1;
    LOBYTE(v9) = v20;
    *(_DWORD *)(a2 + 32) = v10;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v9 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v9 >> 6;
    result = 1;
  }
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;

//----- (1002E750) --------------------------------------------------------
char __cdecl sub_1002E750(int a1, int a2)
{
  char result; // al@1
  char v3; // ah^2@2
  __int16 v4; // dx@2
  __int16 v5; // dx@2
  int v6; // [sp+0h] [bp-8h]@1
  unsigned int v7; // [sp+4h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_1020CF70)(a1, 8, &v6);
  if ( result )
  {
    v3 = BYTE3(v6);
    *(_DWORD *)a2 = v6 & 0xFFFFFF;
    LOBYTE(v4) = 0;
    HIBYTE(v4) = v3;
    v5 = (unsigned __int8)v7 ^ v4;
    *(_DWORD *)(a2 + 8) = v7 >> 8;
    *(_WORD *)(a2 + 4) = v5;
    result = 1;
  }
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;

//----- (1002E7B0) --------------------------------------------------------
char __cdecl sub_1002E7B0(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // esi@2
  unsigned int v5; // ecx@2
  __int16 v6; // [sp+0h] [bp-14h]@1
  __int16 v7; // [sp+2h] [bp-12h]@2
  __int16 v8; // [sp+4h] [bp-10h]@2
  __int16 v9; // [sp+6h] [bp-Eh]@2
  __int16 v10; // [sp+8h] [bp-Ch]@2
  unsigned __int16 v11; // [sp+Ah] [bp-Ah]@2
  int v12; // [sp+Ch] [bp-8h]@2
  char v13; // [sp+12h] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_1020CF70)(a1, 19, &v6);
  if ( result )
  {
    v3 = v7;
    *(_WORD *)a2 = v6;
    *(_WORD *)(a2 + 4) = v8;
    *(_WORD *)(a2 + 8) = v10;
    *(_WORD *)(a2 + 2) = v3;
    v4 = v11;
    *(_WORD *)(a2 + 6) = v9;
    LOBYTE(v3) = v13;
    *(_DWORD *)(a2 + 12) = v4 + ((v13 & 7) << 16);
    *(_WORD *)(a2 + 16) = v12 & 0x3FFF;
    v5 = *(int *)((char *)&v12 + 2);
    *(_DWORD *)(a2 + 20) = *(int *)((char *)&v12 + 2) & 0xFFFFFF;
    *(_DWORD *)(a2 + 24) = (v5 >> 24) & 3;
    *(_DWORD *)(a2 + 28) = (v5 >> 26) & 1;
    *(_DWORD *)(a2 + 36) = (v5 >> 29) & 1;
    *(_DWORD *)(a2 + 32) = (v5 >> 27) & 3;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v3 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v3 >> 6;
    result = 1;
  }
  return result;
}
// 1020CF70: using guessed type int dword_1020CF70;

//----- (1002E880) --------------------------------------------------------
double __cdecl sub_1002E880(int a1)
{
  double v1; // st6@1

  v1 = (double)(unsigned int)((*(int (**)(void))(dword_1020CF8C + 8))() - a1);
  return (float)(1.0 / (double)(*(int (**)(void))(dword_1020CF8C + 12))() * v1);
}
// 1020CF8C: using guessed type int dword_1020CF8C;

//----- (1002E8D0) --------------------------------------------------------
bool __cdecl sub_1002E8D0(void *a1)
{
  char v1; // cl@1

  v1 = sub_1000ED60(1, 1946, a1);
  *((_DWORD *)a1 + 1) /= 0x3E8u;
  return v1 && !sub_10011160((int)a1);
}

//----- (1002E910) --------------------------------------------------------
char __cdecl sub_1002E910(char a1)
{
  return byte_100A4839[2 * (unsigned __int8)sub_10014DE0(&a1, 1u, (int)&unk_100A4838, 2, 4, 3)];
}

//----- (1002E940) --------------------------------------------------------
char __cdecl sub_1002E940(char a1, void *a2)
{
  void *v3; // esi@6
  char v4; // al@6

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v3 = a2;
      v4 = sub_1000ED60(1, 546, a2);
    }
    else
    {
      if ( a1 != 2 )
      {
        sub_10014D70("..\\lib\\acl\\iop\\iop_com_intf.c", 187, 0, 0);
        return 0;
      }
      v3 = a2;
      v4 = sub_1002E8D0(a2);
    }
  }
  else
  {
    v3 = a2;
    v4 = sub_1000ED60(1, 538, a2);
  }
  if ( !v4 || sub_10011160((int)v3) )
    return 0;
  return 1;
}

//----- (1002E9C0) --------------------------------------------------------
int __cdecl sub_1002E9C0(char a1, _DWORD *a2)
{
  int result; // eax@1
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  LOBYTE(result) = sub_1002E940(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (1002EA10) --------------------------------------------------------
char __cdecl sub_1002EA10(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_1001FC30(11);
  }
  else
  {
    result = sub_1001FC30(5);
  }
  return result;
}

//----- (1002EA40) --------------------------------------------------------
char __cdecl sub_1002EA40(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xA:
    case 0x30:
      result = 0;
      break;
    case 0xB:
    case 0x31:
      result = 1;
      break;
    default:
      sub_10014D70("..\\lib\\acl\\iop\\iop_xpdr_cnfg_utl.c", 155, 0, 0);
      result = 2;
      break;
  }
  return result;
}

//----- (1002EAC0) --------------------------------------------------------
signed int __cdecl sub_1002EAC0(unsigned __int8 a1)
{
  void *v1; // ecx@0
  bool v2; // dl@2
  unsigned __int8 v3; // cl@2
  signed int v4; // ebp@8
  void *v5; // ecx@8
  unsigned __int8 v6; // bl@9
  signed int result; // eax@14
  int v8; // [sp+8h] [bp-250h]@0
  char v9[68]; // [sp+Ch] [bp-24Ch]@9
  char v10; // [sp+50h] [bp-208h]@2
  char v11[2]; // [sp+A8h] [bp-1B0h]@5
  char v12[426]; // [sp+AAh] [bp-1AEh]@4

  if ( sub_10021250(v1) )
  {
    v2 = sub_100303F0(6444, (int)&v10, 514) == 0;
    v3 = 0;
    while ( !v2 || !v12[12 * v3] || !(a1 & (unsigned __int8)v11[v3]) )
    {
      if ( ++v3 >= 2u )
        goto LABEL_7;
    }
    result = 0x8000;
  }
  else
  {
LABEL_7:
    LOBYTE(v8) = 0;
    while ( 1 )
    {
      v4 = sub_1001F640(v8);
      if ( (v4 & sub_10015630(v5)) == v4 )
        break;
LABEL_13:
      LOBYTE(v8) = v8 + 1;
      if ( (unsigned __int8)v8 >= 2u )
        return 0;
    }
    sub_10015F90(v8, v9);
    v6 = 0;
    while ( !sub_1001FAB0(v8, byte_100A6671[2 * v6]) || !(a1 & (unsigned __int8)v9[12 * v6]) )
    {
      if ( ++v6 >= 2u )
        goto LABEL_13;
    }
    result = v4;
  }
  return result;
}
// 1002EAC0: using guessed type char var_1AE[426];
// 1002EAC0: using guessed type char var_1B0[2];
// 1002EAC0: using guessed type char var_24C[68];

//----- (1002EBF0) --------------------------------------------------------
char __cdecl sub_1002EBF0(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // eax@1
  int v4; // [sp+8h] [bp-250h]@0
  char v5[68]; // [sp+Ch] [bp-24Ch]@7
  char v6; // [sp+50h] [bp-208h]@1
  char v7[2]; // [sp+A8h] [bp-1B0h]@5
  char v8[426]; // [sp+AAh] [bp-1AEh]@4

  memset(&v6, 0, 0x202u);
  v2 = sub_1002EAC0(a2);
  if ( v2 == 256 || v2 == 512 )
  {
    LOBYTE(v4) = sub_1001F6C0(v2);
    sub_10015F90(v4, v5);
    if ( sub_1001FAB0(v4, byte_100A6671[2 * a1]) && (a2 & (unsigned __int8)v5[12 * a1]) == a2 )
      return 1;
  }
  else if ( v2 == 0x8000 )
  {
    sub_100303F0(6444, (int)&v6, 514);
    if ( v8[12 * a1] )
    {
      if ( (a2 & (unsigned __int8)v7[a1]) == a2 )
        return 1;
    }
  }
  return 0;
}
// 1002EBF0: using guessed type char var_1AE[426];
// 1002EBF0: using guessed type char var_1B0[2];
// 1002EBF0: using guessed type char var_24C[68];

//----- (1002ED20) --------------------------------------------------------
int __cdecl sub_1002ED20(char a1, char a2)
{
  int v2; // esi@1
  int result; // eax@4

  v2 = dword_100A73E4[2 * sub_10014DE0(&a1, 1u, (int)&unk_100A73E0, 8, 3, 3)];
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = v2 + dword_100A7424[2 * sub_10014DE0(&a2, 1u, (int)&unk_100A7420, 8, 6, 6)];
    }
    else if ( a1 == 2 )
    {
      result = v2 + dword_100A7454[2 * sub_10014DE0(&a2, 1u, (int)&unk_100A7450, 8, 5, 5)];
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = v2 + dword_100A73FC[2 * sub_10014DE0(&a2, 1u, (int)&unk_100A73F8, 8, 5, 5)];
  }
  return result;
}
// 100A73E4: using guessed type int dword_100A73E4[];
// 100A73FC: using guessed type int dword_100A73FC[];
// 100A7424: using guessed type int dword_100A7424[];
// 100A7454: using guessed type int dword_100A7454[];

//----- (1002EDD0) --------------------------------------------------------
bool __usercall sub_1002EDD0@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3)
{
  return a2 == 7 && a3 >= (unsigned __int8)byte_100AA6FF[44 * a1] - (unsigned __int8)byte_100AA6FA[44 * a1];
}

//----- (1002EE00) --------------------------------------------------------
char __usercall sub_1002EE00@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6)
{
  int v6; // eax@2
  char result; // al@3
  int v8; // eax@4

  if ( sub_1002EDD0(a1, a4, a5) )
  {
    v6 = a3
       + sub_1002ED20(a1, 6)
       + 36 * (a5 + (unsigned __int8)byte_100AA6FA[44 * a1] - (unsigned __int8)byte_100AA6FF[44 * a1]);
    if ( *(_BYTE *)(v6 + 2) == 6 )
    {
      memcpy(a6, (const void *)(v6 + 4), a2);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v8 = sub_1002ED20(a1, a4);
    memcpy(a6, (const void *)(a3 + v8 + a2 * a5), a2);
    result = 1;
  }
  return result;
}

//----- (1002EEA0) --------------------------------------------------------
char __cdecl sub_1002EEA0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10021730(a1);
  sub_10030410(v5, (int)&v7, 3684);
  return sub_1002EE00(a2, 0x2Cu, (int)&v7, a3, a4, a5);
}

//----- (1002EF20) --------------------------------------------------------
char __cdecl sub_1002EF20(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10021730(a1);
  sub_10030410(v5, (int)&v7, 3684);
  return sub_1002EE00(a2, 3u, (int)&v7, a3, a4, a5);
}

//----- (1002EFA0) --------------------------------------------------------
char __cdecl sub_1002EFA0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10021730(a1);
  sub_10030410(v5, (int)&v7, 3684);
  return sub_1002EE00(a2, 0x24u, (int)&v7, a3, a4, a5);
}

//----- (1002F020) --------------------------------------------------------
char __cdecl sub_1002F020(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10021730(a1);
  sub_10030410(v5, (int)&v7, 3684);
  return sub_1002EE00(a2, 0xCu, (int)&v7, a3, a4, a5);
}

//----- (1002F0A0) --------------------------------------------------------
char __cdecl sub_1002F0A0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xC:
    case 0x3F:
      result = 0;
      break;
    case 0xD:
    case 0x40:
      result = 1;
      break;
    case 0xE:
    case 0x41:
      result = 2;
      break;
    case 0x2A:
    case 0x42:
      result = 3;
      break;
    default:
      sub_10014D70("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_utl.c", 139, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1002F140) --------------------------------------------------------
int __cdecl sub_1002F140(int a1)
{
  return (*(int (**)(void))(a1 + 4))();
}

//----- (1002F150) --------------------------------------------------------
char __cdecl sub_1002F150(int a1, unsigned int a2)
{
  char result; // al@1

  result = 1;
  if ( a2 > 4 && !memcmp(*(const void **)(a1 + 16), "PASS", 5u) )
    result = 0;
  return result;
}

//----- (1002F180) --------------------------------------------------------
int __cdecl sub_1002F180(int a1, int a2, int a3)
{
  int *v3; // esi@1
  signed int v4; // edi@1
  int result; // eax@2

  v3 = (int *)(sub_10022DF0() + 36);
  v4 = 5;
  do
  {
    result = *v3;
    if ( *v3 )
    {
      result = *(_DWORD *)(result + 4);
      if ( result )
        result = ((int (__cdecl *)(int, int, int))result)(a1, a2, a3);
    }
    ++v3;
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (1002F1F0) --------------------------------------------------------
int __cdecl sub_1002F1F0(int a1, char a2)
{
  return sub_1002F180(a1, (int)&a2, 1);
}

//----- (1002F210) --------------------------------------------------------
int __cdecl sub_1002F210(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = a2;
  v5 = a3;
  return sub_1002F180(a1, (int)&v4, 2);
}

//----- (1002F240) --------------------------------------------------------
int __cdecl sub_1002F240(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+4h] [bp-Ch]@1
  int v8; // [sp+8h] [bp-8h]@1
  int v9; // [sp+Ch] [bp-4h]@1

  v7 = a3;
  v8 = a4;
  v6 = a2;
  v9 = a5;
  return sub_1002F180(a1, (int)&v6, 4);
}

//----- (1002F280) --------------------------------------------------------
int __cdecl sub_1002F280(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [sp+0h] [bp-14h]@1
  int v8; // [sp+4h] [bp-10h]@1
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1
  int v11; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v9 = a4;
  v10 = a5;
  v8 = a3;
  v11 = a6;
  return sub_1002F180(a1, (int)&v7, 5);
}

//----- (1002F2C0) --------------------------------------------------------
int __cdecl sub_1002F2C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-18h]@1
  int v9; // [sp+4h] [bp-14h]@1
  int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v8 = a2;
  v9 = a3;
  v11 = a5;
  v12 = a6;
  v10 = a4;
  v13 = a7;
  return sub_1002F180(a1, (int)&v8, 6);
}

//----- (1002F310) --------------------------------------------------------
char __cdecl sub_1002F310(int a1)
{
  char v1; // bl@1
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  _DWORD *v4; // eax@1

  v1 = 0;
  v2 = sub_10022DF0();
  v3 = 0;
  v4 = v2 + 36;
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 == a1 )
    {
      v1 = 1;
      *v4 = 0;
    }
    ++v3;
    ++v4;
  }
  while ( !v1 );
  return v1;
}

//----- (1002F340) --------------------------------------------------------
int __cdecl sub_1002F340(int a1)
{
  int result; // eax@1

  result = sub_100223D0();
  dword_101EC9B4[result] = a1;
  return result;
}
// 101EC9B4: using guessed type int dword_101EC9B4[];

//----- (1002F360) --------------------------------------------------------
char *sub_1002F360(char *a1, ...)
{
  int v1; // esi@1
  char *result; // eax@1
  va_list va; // [sp+10h] [bp+8h]@1

  va_start(va, a1);
  v1 = sub_100223D0() << 8;
  _vsnprintf(&byte_101E5CB8[v1], 0x100u, a1, va);
  result = &byte_101E5CB8[v1];
  byte_101E5DB6[v1] = 42;
  byte_101E5DB7[v1] = 0;
  return result;
}

//----- (1002F3A0) --------------------------------------------------------
int __cdecl sub_1002F3A0(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_100223D0();
  dword_101EC9A0[result] = a1;
  if ( a2 >= 0 )
  {
    dword_101EA8BC[result] = a2;
    if ( a2 > 14 )
    {
      v3 = sub_1002F360(
             "Floating point (double) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             14);
      result = sub_1002F240(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"909", (int)v3);
    }
  }
  else
  {
    dword_101EA8BC[result] = 8;
  }
  return result;
}
// 101EA8BC: using guessed type int dword_101EA8BC[];
// 101EC9A0: using guessed type int dword_101EC9A0[];

//----- (1002F400) --------------------------------------------------------
int __cdecl sub_1002F400(int a1)
{
  return sub_1002F3A0(0, a1);
}

//----- (1002F410) --------------------------------------------------------
int __cdecl sub_1002F410(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_100223D0();
  dword_101EDFBC[result] = a1;
  if ( a2 >= 0 )
  {
    dword_101EDFA8[result] = a2;
    if ( a2 > 9 )
    {
      v3 = sub_1002F360(
             "Floating point (float) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             9);
      result = sub_1002F240(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"977", (int)v3);
    }
  }
  else
  {
    dword_101EDFA8[result] = 8;
  }
  return result;
}
// 101EDFA8: using guessed type int dword_101EDFA8[];
// 101EDFBC: using guessed type int dword_101EDFBC[];

//----- (1002F470) --------------------------------------------------------
int __cdecl sub_1002F470(int a1)
{
  return sub_1002F410(0, a1);
}

//----- (1002F480) --------------------------------------------------------
int sub_1002F480()
{
  int v0; // esi@1
  int result; // eax@1

  v0 = sub_100223D0();
  sub_1002F340(1);
  sub_1002F470(-1);
  result = sub_1002F400(-1);
  dword_101EA8A8[v0] = 0;
  return result;
}
// 101EA8A8: using guessed type int dword_101EA8A8[];

//----- (1002F4B0) --------------------------------------------------------
bool __thiscall sub_1002F4B0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  return !sub_100303F0(6569, (int)&v2 + 3, 1) && (BYTE3(v2) == 4 || BYTE3(v2) == 2 || BYTE3(v2) == 5);
}

//----- (1002F4F0) --------------------------------------------------------
char __cdecl sub_1002F4F0(char a1, void *a2)
{
  void *v3; // ecx@3
  char v4; // al@5

  if ( sub_100303F0((unsigned __int8)a1 + 36000, (int)a2, 132) )
    return 0;
  v3 = a2;
  if ( !a2 || *(_BYTE *)a2 )
  {
LABEL_8:
    if ( *((_BYTE *)a2 + 21) == 4 )
    {
      if ( *((_BYTE *)a2 + 24) == 1 )
      {
        if ( !sub_1002F4B0(v3) )
        {
          sub_10014D70("..\\lib\\adl\\sys_utl_airframe_tests.c", 206, 0, 0);
          memset(a2, 0, 0x84u);
        }
      }
      else if ( *((_BYTE *)a2 + 24) == 3 && !*((_BYTE *)a2 + 58) )
      {
        *((_DWORD *)a2 + 15) |= 0x200u;
        return 1;
      }
    }
  }
  else
  {
    v4 = 0;
    while ( v4 )
    {
      v4 = *((_BYTE *)v3 + 1);
      v3 = (char *)v3 + 1;
      if ( v4 != *((_BYTE *)v3 + byte_1004764C - (_BYTE *)a2) )
        goto LABEL_8;
    }
  }
  return 1;
}

//----- (1002F5A0) --------------------------------------------------------
char __cdecl sub_1002F5A0(char a1)
{
  void *v1; // ecx@0
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      sub_10030410(6470, (int)&a1, 1);
      result = a1 && sub_1002EAC0(2u);
    }
    else if ( a1 == 2 )
    {
      result = sub_1001FC60(14);
    }
    else
    {
      sub_10014D70("..\\lib\\adl\\iop_dl_wx_intf_a.c", 475, 1, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_1002D2E0(v1);
  }
  return result;
}

//----- (1002F620) --------------------------------------------------------
char __cdecl sub_1002F620(unsigned __int8 a1, int a2, int a3)
{
  char result; // al@6

  if ( sub_10019090() )
  {
    if ( a1 >= *(_BYTE *)(dword_1020D800 + 4)
      && (a1 == -1 || a1 < *(_BYTE *)(dword_1020D800 + 5) || a1 > *(_BYTE *)(dword_1020D800 + 3)) )
    {
      result = 0;
    }
    else
    {
      sub_1001F400();
      sub_1001F3D0(a2, dword_1020D800 + 180 * (a1 + 4));
      sub_1001F3D0(a3, 180 * a1 + dword_1020D800 + 728);
      sub_1001F3F0();
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1020D800: using guessed type int dword_1020D800;

//----- (1002F6A0) --------------------------------------------------------
char __cdecl sub_1002F6A0(void *a1)
{
  int v1; // eax@2
  int v2; // eax@2
  int v3; // eax@2
  int v4; // eax@2
  int v5; // eax@2
  int v6; // ecx@2
  int v7; // eax@2
  int v8; // ecx@2
  int v9; // eax@2
  char result; // al@2
  char v11; // [sp+4h] [bp-28h]@1
  char v12; // [sp+12h] [bp-1Ah]@2

  sub_10032030((int)&v11);
  if ( sub_10019090() )
  {
    sub_1001F400();
    *(_BYTE *)a1 = *(_BYTE *)(dword_1020D80C + 88);
    *((_BYTE *)a1 + 1) = *(_BYTE *)(dword_1020D80C + 89);
    *((_BYTE *)a1 + 2) = *(_BYTE *)(dword_1020D80C + 95);
    *((_BYTE *)a1 + 3) = *(_BYTE *)(dword_1020D80C + 97);
    *((_BYTE *)a1 + 4) = *(_BYTE *)(dword_1020D80C + 101);
    *((_BYTE *)a1 + 5) = *(_BYTE *)(dword_1020D80C + 102);
    *((_BYTE *)a1 + 8) = *(_BYTE *)(dword_1020D80C + 145);
    *((_BYTE *)a1 + 9) = *(_BYTE *)(dword_1020D80C + 146);
    *((_BYTE *)a1 + 10) = *(_BYTE *)(dword_1020D80C + 156);
    *((_BYTE *)a1 + 11) = *(_BYTE *)(dword_1020D80C + 158);
    *((_BYTE *)a1 + 12) = *(_BYTE *)(dword_1020D80C + 159);
    *((_BYTE *)a1 + 13) = *(_BYTE *)(dword_1020D80C + 160);
    *((float *)a1 + 4) = *(float *)(dword_1020D80C + 180);
    *((float *)a1 + 5) = *(float *)(dword_1020D80C + 184);
    *((_BYTE *)a1 + 24) = *(_BYTE *)(dword_1020D80C + 66);
    *((_BYTE *)a1 + 25) = *(_BYTE *)(dword_1020D80C + 67);
    *((float *)a1 + 9) = *(float *)(dword_1020D80C + 84);
    *((_BYTE *)a1 + 26) = *(_BYTE *)(dword_1020D80C + 141);
    *((_BYTE *)a1 + 27) = *(_BYTE *)(dword_1020D80C + 142);
    *((_BYTE *)a1 + 28) = *(_BYTE *)(dword_1020D80C + 272);
    *((float *)a1 + 10) = *(float *)(dword_1020D80C + 920);
    *((float *)a1 + 11) = *(float *)(dword_1020D80C + 924);
    *((_BYTE *)a1 + 29) = *(_BYTE *)(dword_1020D80C + 784);
    *((float *)a1 + 12) = *(float *)(dword_1020D80C + 796);
    *((float *)a1 + 13) = *(float *)(dword_1020D80C + 800);
    *((_BYTE *)a1 + 30) = *(_BYTE *)(dword_1020D80C + 1210);
    *((_BYTE *)a1 + 31) = *(_BYTE *)(dword_1020D80C + 1211);
    *((float *)a1 + 14) = *(float *)(dword_1020D80C + 1216);
    *((float *)a1 + 15) = *(float *)(dword_1020D80C + 1224);
    *((_BYTE *)a1 + 32) = *(_BYTE *)(dword_1020D80C + 1229);
    v1 = dword_1020D80C;
    *((_DWORD *)a1 + 16) = *(_DWORD *)(dword_1020D80C + 1504);
    *((_DWORD *)a1 + 17) = *(_DWORD *)(v1 + 1508);
    *((_DWORD *)a1 + 18) = *(_DWORD *)(v1 + 1512);
    *((_BYTE *)a1 + 76) = *(_BYTE *)(dword_1020D80C + 288);
    *((_BYTE *)a1 + 77) = *(_BYTE *)(dword_1020D80C + 290);
    *((_BYTE *)a1 + 78) = *(_BYTE *)(dword_1020D80C + 289);
    *((float *)a1 + 20) = *(float *)(dword_1020D80C + 304);
    *((float *)a1 + 22) = *(float *)(dword_1020D80C + 312);
    *((float *)a1 + 23) = *(float *)(dword_1020D80C + 392);
    *((float *)a1 + 24) = *(float *)(dword_1020D80C + 316);
    *((float *)a1 + 25) = *(float *)(dword_1020D80C + 340);
    v2 = dword_1020D80C;
    *((_DWORD *)a1 + 26) = *(_DWORD *)(dword_1020D80C + 360);
    *((_DWORD *)a1 + 27) = *(_DWORD *)(v2 + 364);
    v3 = dword_1020D80C;
    *((_DWORD *)a1 + 28) = *(_DWORD *)(dword_1020D80C + 376);
    *((_DWORD *)a1 + 29) = *(_DWORD *)(v3 + 380);
    *((_BYTE *)a1 + 120) = *(_BYTE *)(dword_1020D80C + 536);
    *((_BYTE *)a1 + 121) = *(_BYTE *)(dword_1020D80C + 538);
    *((_BYTE *)a1 + 122) = *(_BYTE *)(dword_1020D80C + 537);
    *((float *)a1 + 31) = *(float *)(dword_1020D80C + 552);
    *((float *)a1 + 33) = *(float *)(dword_1020D80C + 560);
    *((float *)a1 + 34) = *(float *)(dword_1020D80C + 640);
    *((float *)a1 + 35) = *(float *)(dword_1020D80C + 564);
    *((float *)a1 + 36) = *(float *)(dword_1020D80C + 588);
    v4 = dword_1020D80C;
    *((_DWORD *)a1 + 37) = *(_DWORD *)(dword_1020D80C + 608);
    *((_DWORD *)a1 + 38) = *(_DWORD *)(v4 + 612);
    v5 = dword_1020D80C;
    *((_DWORD *)a1 + 39) = *(_DWORD *)(dword_1020D80C + 624);
    *((_DWORD *)a1 + 40) = *(_DWORD *)(v5 + 628);
    *((_BYTE *)a1 + 164) = v12;
    *((_BYTE *)a1 + 165) = *(_BYTE *)(dword_1020D80C + 812);
    *((_BYTE *)a1 + 166) = *(_BYTE *)(dword_1020D80C + 813);
    *((_BYTE *)a1 + 167) = *(_BYTE *)(dword_1020D80C + 814);
    *((_BYTE *)a1 + 169) = *(_BYTE *)(dword_1020D80C + 815);
    *((_BYTE *)a1 + 170) = *(_BYTE *)(dword_1020D80C + 816);
    *((_BYTE *)a1 + 172) = *(_BYTE *)(dword_1020D80C + 818);
    *((_BYTE *)a1 + 173) = *(_BYTE *)(dword_1020D80C + 819);
    *((_BYTE *)a1 + 168) = *(_BYTE *)(dword_1020D80C + 822);
    *((_BYTE *)a1 + 174) = *(_BYTE *)(dword_1020D80C + 826);
    *((float *)a1 + 44) = *(float *)(dword_1020D80C + 860);
    *((_BYTE *)a1 + 171) = *(_BYTE *)(dword_1020D80C + 1176);
    *((float *)a1 + 45) = *(float *)(dword_1020D80C + 1184);
    *((_BYTE *)a1 + 184) = *(_BYTE *)(180 * *(_BYTE *)(dword_1020D80C + 812) + dword_1020D800 + 671);
    *((_BYTE *)a1 + 189) = *(_BYTE *)(44 * *(_WORD *)(dword_1020D80C + 828) + dword_1020D804 + 326) & 1;
    *((_BYTE *)a1 + 194) = (*(_WORD *)(44 * *(_WORD *)(dword_1020D80C + 828) + dword_1020D804 + 326) >> 12) & 1;
    *((_BYTE *)a1 + 195) = (*(_WORD *)(44 * *(_WORD *)(dword_1020D80C + 828) + dword_1020D804 + 326) >> 13) & 1;
    *((_BYTE *)a1 + 190) = (*(_BYTE *)(44 * *(_WORD *)(dword_1020D80C + 828) + dword_1020D804 + 326) >> 1) & 3;
    *((_BYTE *)a1 + 191) = (*(_BYTE *)(44 * *(_WORD *)(dword_1020D80C + 828) + dword_1020D804 + 326) >> 3) & 1;
    *((_BYTE *)a1 + 192) = (*(_WORD *)(44 * *(_WORD *)(dword_1020D80C + 828) + dword_1020D804 + 326) >> 4) & 0x3F;
    *((_BYTE *)a1 + 193) = (*(_WORD *)(44 * *(_WORD *)(dword_1020D80C + 828) + dword_1020D804 + 326) >> 10) & 3;
    *((float *)a1 + 51) = *(float *)(44 * *(_WORD *)(dword_1020D80C + 828) + dword_1020D804 + 336);
    *((float *)a1 + 52) = *(float *)(44 * *(_WORD *)(dword_1020D80C + 828) + dword_1020D804 + 340);
    *((_WORD *)a1 + 98) = *(_WORD *)(44 * *(_WORD *)(dword_1020D80C + 828) + dword_1020D804 + 328);
    *((_WORD *)a1 + 99) = *(_WORD *)(44 * *(_WORD *)(dword_1020D80C + 828) + dword_1020D804 + 330);
    *((_BYTE *)a1 + 188) = *(_BYTE *)(44 * *(_WORD *)(dword_1020D80C + 828) + dword_1020D804 + 324);
    *((_WORD *)a1 + 100) = *(_WORD *)(44 * *(_WORD *)(dword_1020D80C + 828) + dword_1020D804 + 332);
    *((_WORD *)a1 + 101) = *(_WORD *)(44 * *(_WORD *)(dword_1020D80C + 828) + dword_1020D804 + 334);
    *((float *)a1 + 53) = *(float *)(44 * *(_WORD *)(dword_1020D80C + 828) + dword_1020D804 + 344);
    *((float *)a1 + 56) = *(float *)(44 * *(_WORD *)(dword_1020D80C + 828) + dword_1020D804 + 356);
    v6 = dword_1020D804;
    v7 = 44 * *(_WORD *)(dword_1020D80C + 828);
    *((_DWORD *)a1 + 54) = *(_DWORD *)(v7 + dword_1020D804 + 348);
    *((_DWORD *)a1 + 55) = *(_DWORD *)(v7 + v6 + 352);
    v8 = dword_1020D804;
    v9 = 44 * *(_WORD *)(dword_1020D80C + 828);
    *((_DWORD *)a1 + 57) = *(_DWORD *)(v9 + dword_1020D804 + 360);
    *((_DWORD *)a1 + 58) = *(_DWORD *)(v9 + v8 + 364);
    sub_1001F3F0();
    result = 1;
  }
  else
  {
    memset(a1, 0, 0xECu);
    result = 0;
  }
  return result;
}
// 1020D800: using guessed type int dword_1020D800;
// 1020D804: using guessed type int dword_1020D804;
// 1020D80C: using guessed type int dword_1020D80C;

//----- (1002FE10) --------------------------------------------------------
char __cdecl sub_1002FE10(void *a1)
{
  char result; // al@2

  if ( sub_10019090() )
  {
    sub_1001F400();
    *(_BYTE *)a1 = *(_BYTE *)(dword_1020D80C + 1248);
    *((_BYTE *)a1 + 1) = *(_BYTE *)(dword_1020D80C + 1249);
    *((_BYTE *)a1 + 6) = *(_BYTE *)(dword_1020D80C + 1252);
    *((_BYTE *)a1 + 7) = *(_BYTE *)(dword_1020D80C + 1253);
    *((_BYTE *)a1 + 4) = *(_BYTE *)(dword_1020D80C + 1250);
    *((_BYTE *)a1 + 2) = *(_BYTE *)(dword_1020D80C + 1357);
    *((_BYTE *)a1 + 3) = *(_BYTE *)(dword_1020D80C + 1363);
    *((_BYTE *)a1 + 5) = *(_BYTE *)(dword_1020D80C + 1366);
    *((_BYTE *)a1 + 8) = *(_BYTE *)(dword_1020D80C + 1376);
    *((_BYTE *)a1 + 9) = *(_BYTE *)(dword_1020D80C + 1375);
    *((_BYTE *)a1 + 10) = *(_BYTE *)(dword_1020D80C + 1377);
    *((_BYTE *)a1 + 12) = *(_BYTE *)(dword_1020D80C + 1382);
    *((_BYTE *)a1 + 11) = *(_BYTE *)(dword_1020D80C + 1379);
    *((_DWORD *)a1 + 4) = *(_DWORD *)(dword_1020D80C + 1388);
    *((float *)a1 + 5) = *(float *)(dword_1020D80C + 1476);
    *((float *)a1 + 6) = *(float *)(dword_1020D80C + 1468);
    *((float *)a1 + 7) = *(float *)(dword_1020D80C + 1460);
    *((float *)a1 + 8) = *(float *)(dword_1020D80C + 1424);
    *((float *)a1 + 9) = *(float *)(dword_1020D80C + 1428);
    *((float *)a1 + 10) = *(float *)(dword_1020D80C + 1484);
    *((float *)a1 + 11) = *(float *)(dword_1020D80C + 1488);
    *((float *)a1 + 12) = *(float *)(dword_1020D80C + 1492);
    sub_1001F3F0();
    result = 1;
  }
  else
  {
    memset(a1, 0, 0x34u);
    result = 0;
  }
  return result;
}
// 1020D80C: using guessed type int dword_1020D80C;

//----- (1002FFA0) --------------------------------------------------------
int sub_1002FFA0()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_id();
  SYS_exit_krnl();
  return v0;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 100326BA: using guessed type int TSK_pvg_get_id(void);

//----- (1002FFC0) --------------------------------------------------------
int __cdecl sub_1002FFC0(int a1, int a2, int a3)
{
  int v3; // esi@1

  SYS_enter_krnl();
  v3 = TSK_pvg_get_mon_data(a1, a2, a3);
  SYS_exit_krnl();
  return v3;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 100326C0: using guessed type int __cdecl TSK_pvg_get_mon_data(_DWORD, _DWORD, _DWORD);

//----- (1002FFF0) --------------------------------------------------------
int __cdecl sub_1002FFF0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_get_msg(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 100326C6: using guessed type int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD);

//----- (10030020) --------------------------------------------------------
__int16 __cdecl sub_10030020(int a1)
{
  __int16 v1; // si@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_run_state(a1);
  SYS_exit_krnl();
  return v1;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 100326CC: using guessed type int __cdecl TSK_pvg_get_run_state(_DWORD);

//----- (10030040) --------------------------------------------------------
int sub_10030040()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_timer();
  SYS_exit_krnl();
  return v0;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 100326D2: using guessed type int TSK_pvg_get_timer(void);

//----- (10030060) --------------------------------------------------------
int __cdecl sub_10030060(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_get_tsk_info(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 100326D8: using guessed type int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10030090) --------------------------------------------------------
int sub_10030090()
{
  char v1; // [sp+0h] [bp-84h]@1
  int v2; // [sp+24h] [bp-60h]@1
  int v3; // [sp+34h] [bp-50h]@1

  sub_1002FFC0(-2, (int)&v1, 0);
  return v3 + 1000 * v2;
}

//----- (100300F0) --------------------------------------------------------
int __cdecl sub_100300F0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_kill_process(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 100326E4: using guessed type int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10030120) --------------------------------------------------------
int __cdecl sub_10030120(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_proc_status(a1);
  SYS_exit_krnl();
  return v1;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 100326EA: using guessed type int __cdecl TSK_pvg_proc_status(_DWORD);

//----- (10030140) --------------------------------------------------------
int __cdecl sub_10030140(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_release_smphr(a1);
  SYS_exit_krnl();
  return v1;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 100326F0: using guessed type int __cdecl TSK_pvg_release_smphr(_DWORD);

//----- (10030160) --------------------------------------------------------
int __cdecl sub_10030160(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_reserve_smphr(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 100326F6: using guessed type int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD);

//----- (10030190) --------------------------------------------------------
int __cdecl sub_10030190(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_evnt(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 100326FC: using guessed type int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD);

//----- (100301C0) --------------------------------------------------------
int __cdecl sub_100301C0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_send_msg(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 10032702: using guessed type int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100301F0) --------------------------------------------------------
int __cdecl sub_100301F0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_msg_ex(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 10032708: using guessed type int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD);

//----- (10030220) --------------------------------------------------------
int __cdecl sub_10030220(int a1)
{
  SYS_enter_krnl();
  TSK_pvg_set_proc_status(a1);
  return SYS_exit_krnl();
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 1003270E: using guessed type int __cdecl TSK_pvg_set_proc_status(_DWORD);

//----- (10030240) --------------------------------------------------------
int __cdecl sub_10030240(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_suspend(a1);
  SYS_exit_krnl();
  return v1;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 10032714: using guessed type int __cdecl TSK_pvg_suspend(_DWORD);

//----- (10030260) --------------------------------------------------------
char __cdecl sub_10030260(int a1, int a2)
{
  unsigned int v2; // esi@1
  char result; // al@4

  v2 = a2 + sub_10030040();
  if ( sub_10030120(a1) == 5 )
    goto LABEL_4;
  while ( sub_10030040() < v2 )
  {
    sub_10030240(20);
    if ( sub_10030120(a1) == 5 )
      goto LABEL_4;
  }
  if ( sub_10030120(a1) == 5 )
  {
LABEL_4:
    result = 1;
  }
  else
  {
    sub_10014D70("..\\lib\\acl\\tsk\\tsk_usr.c", 1769, 0, 0);
    result = 0;
  }
  return result;
}

//----- (100302D0) --------------------------------------------------------
int __cdecl sub_100302D0(_BYTE *a1)
{
  int v1; // edi@1
  int v2; // eax@2
  char v4; // [sp+8h] [bp-4h]@2

  SYS_enter_krnl();
  v1 = TSK_pvg_wait_evnt(a1);
  SYS_exit_krnl();
  if ( *a1 & 0x20 )
  {
    v2 = sub_1002FFA0();
    sub_10030060((int)&v4, 5, v2, 4);
  }
  return v1;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 1003271A: using guessed type int __cdecl TSK_pvg_wait_evnt(_DWORD);

//----- (10030310) --------------------------------------------------------
int __cdecl sub_10030310(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) != 1 && !a1 )
    result = sub_10030140(a2);
  return result;
}
// 10049954: using guessed type void *tsk_app_hdr_ptr;

//----- (10030340) --------------------------------------------------------
int __cdecl sub_10030340(int a1, int a2)
{
  int result; // eax@2

  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) == 1 )
    result = 0;
  else
    result = sub_10030160(a1, a2);
  return result;
}
// 10049954: using guessed type void *tsk_app_hdr_ptr;

//----- (10030370) --------------------------------------------------------
int __cdecl sub_10030370(int a1)
{
  int v1; // ecx@1
  int result; // eax@1

  v1 = 0;
  result = 42066;
  while ( dword_100AFD28[2 * v1] != a1 )
  {
    if ( (unsigned int)++v1 >= 0xA5 )
      return result;
  }
  return dword_100AFD2C[2 * v1];
}
// 100AFD28: using guessed type int dword_100AFD28[];
// 100AFD2C: using guessed type int dword_100AFD2C[];

//----- (100303B0) --------------------------------------------------------
const char *__cdecl sub_100303B0(signed int a1)
{
  const char *result; // eax@2

  if ( a1 >= 43 )
    result = "UNKNOWN";
  else
    result = off_100B02D0[a1];
  return result;
}
// 100B02D0: using guessed type char *off_100B02D0[9];

//----- (100303F0) --------------------------------------------------------
int __cdecl sub_100303F0(int a1, int a2, int a3)
{
  return reg_read(a1, a2, a3, 0);
}
// 1003272C: using guessed type int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10030410) --------------------------------------------------------
char __cdecl sub_10030410(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_100303F0(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10014D70("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1255, 1, 0);
  return v3;
}

//----- (10030450) --------------------------------------------------------
int __cdecl sub_10030450(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // esi@1

  result = sub_100303F0(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    result = v5;
  }
  return result;
}

//----- (10030490) --------------------------------------------------------
int __cdecl sub_10030490(int a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_100303F0(a1 | 0x20000, a2, a3);
  if ( result == -46 )
    result = 0;
  return result;
}

//----- (100304C0) --------------------------------------------------------
int __cdecl sub_100304C0(int a1, int a2, int a3)
{
  return reg_write(a1, a2, a3, 0);
}
// 10032732: using guessed type int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100304E0) --------------------------------------------------------
int __cdecl sub_100304E0(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // eax@2
  int result; // eax@4
  int v6; // [sp+10h] [bp-4h]@1

  v6 = sub_100304C0(a1, a2, a3);
  v3 = 0;
  if ( (unsigned __int8)sub_10031750() )
  {
    v4 = sub_10030370(a1);
    if ( v4 != 42066 )
      v3 = sub_100304C0(v4, a2, a3);
  }
  result = v6;
  if ( !v6 )
    result = v3;
  return result;
}
// 10031750: using guessed type int sub_10031750(void);

//----- (10030540) --------------------------------------------------------
int __cdecl sub_10030540(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  result = sub_100304E0(a1, a2, a3);
  v4 = result;
  if ( result )
  {
    sub_10014D70("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1742, 1, 0);
    result = v4;
  }
  return result;
}

//----- (10030580) --------------------------------------------------------
char __cdecl sub_10030580(int a1, _DWORD *a2, int a3, int a4, int a5, unsigned int a6)
{
  char v6; // dl@1
  int v7; // ecx@2
  unsigned int v8; // ebp@4
  unsigned int v9; // esi@5
  char v10; // dl@5
  unsigned int v11; // eax@5
  int v12; // eax@13
  bool v13; // zf@18
  int v15; // [sp+0h] [bp-20h]@1
  int v16; // [sp+4h] [bp-1Ch]@2
  int v17; // [sp+8h] [bp-18h]@13
  int v18; // [sp+Ch] [bp-14h]@2
  unsigned int v19; // [sp+10h] [bp-10h]@4
  char v20; // [sp+14h] [bp-Ch]@13
  int v21; // [sp+18h] [bp-8h]@14
  char v22; // [sp+30h] [bp+10h]@4
  char v23; // [sp+30h] [bp+10h]@13

  v6 = 0;
  v15 = 0;
  if ( a4 )
  {
    v7 = a3 + 4;
    v16 = a3 + 4;
    v18 = a4;
    do
    {
      if ( *(_DWORD *)(v7 - 4) == a1 )
      {
        v22 = 1;
        v19 = *(_DWORD *)(v7 + 4) - *(_DWORD *)v7;
        v8 = 0;
        do
        {
          v9 = v8 + *(_DWORD *)v7;
          v10 = 0;
          v11 = 0;
          if ( a6 )
          {
            v7 = a5;
            while ( !v10 )
            {
              if ( *(_DWORD *)v7 == a1 && *(_DWORD *)(v7 + 4) == v9 )
                v10 = 1;
              ++v11;
              v7 += 10;
              if ( v11 >= a6 )
              {
                if ( v10 )
                  break;
                goto LABEL_13;
              }
            }
          }
          else
          {
LABEL_13:
            v12 = j_reg_get_tag_hdr(v7, v10);
            v23 = v20 & (v12 == 1) & v22;
            v17 = 0;
            if ( !sub_10031760(v9, (unsigned int *)&v15, &v17) )
              v15 = v21;
            v22 = (v17 == 0) & v23;
            *a2 += v15;
          }
          v7 = v16;
          ++v8;
        }
        while ( v8 <= v19 );
        v6 = v22;
      }
      v7 += 12;
      v13 = v18-- == 1;
      v16 = v7;
    }
    while ( !v13 );
  }
  return v6;
}
// 100303D0: using guessed type int __fastcall j_reg_get_tag_hdr(_DWORD, _DWORD);

//----- (10030690) --------------------------------------------------------
int __cdecl sub_10030690(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // edi@1

  result = sub_100303F0(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    sub_100304C0(a1, (int)a4, a3);
    result = v5;
  }
  return result;
}

//----- (100306E0) --------------------------------------------------------
char __cdecl sub_100306E0(_DWORD *a1)
{
  int v1; // eax@1
  unsigned int v2; // esi@1
  char v3; // bl@1
  int *v4; // edi@1

  *a1 = 0;
  v1 = 10;
  v2 = 0;
  v3 = 1;
  v4 = (int *)&unk_100B0250;
  do
  {
    v3 &= sub_10030580(*v4, a1, (int)&unk_100B0250, v1, (int)&unk_100AF1E0, 0x120u);
    v1 = 10;
    ++v2;
    v4 += 3;
  }
  while ( v2 < 0xA );
  return v3;
}

//----- (10030750) --------------------------------------------------------
bool sub_10030750()
{
  unsigned int v0; // eax@1

  v0 = j_HWM_pvg_read_reg(0);
  return v0 >= 0x17 && (v0 <= 0x18 || v0 == 40);
}
// 10008150: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10030770) --------------------------------------------------------
signed int __cdecl sub_10030770(unsigned int a1)
{
  signed int result; // eax@4
  int v2; // eax@8
  int v3; // edx@9

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_16;
  if ( (a1 & 3) == 1 )
    return sub_1001C7A0(a1);
  if ( a1 && (a1 & 3) == 2 )
  {
    v2 = 0;
    if ( !dword_10209868 )
      goto LABEL_11;
    while ( 1 )
    {
      v3 = dword_10209870[v2];
      if ( *(_DWORD *)v3 == a1 )
        break;
      if ( ++v2 >= (unsigned int)dword_10209868 )
        goto LABEL_11;
    }
    if ( v2 != -1 )
    {
      sub_10031A20(
        v2,
        *(_DWORD *)(dword_10209870[v2] + 12),
        *(_DWORD *)(v3 + 16),
        *(_BYTE *)(v3 + 32),
        *(_WORD *)(v3 + 20),
        *(_DWORD *)(v3 + 4));
      result = sub_10030770(a1 & 0xFFFFFFFC);
    }
    else
    {
LABEL_11:
      result = -6;
    }
  }
  else
  {
LABEL_16:
    result = FIL_vfs_close();
  }
  return result;
}
// 10032738: using guessed type int FIL_vfs_close(void);
// 10209868: using guessed type int dword_10209868;
// 10209870: using guessed type int dword_10209870[];

//----- (100307E0) --------------------------------------------------------
int __cdecl sub_100307E0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-1Ch]@1
  __int64 v7; // [sp+4h] [bp-18h]@1
  __int64 v8; // [sp+10h] [bp-Ch]@1

  v7 = a2;
  v8 = a4;
  return FIL_vfs_memmove_swi(&v6, a1, v7, HIDWORD(v7), a3, v8, HIDWORD(v8), a5);
}
// 10032750: using guessed type int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10030860) --------------------------------------------------------
signed int __cdecl sub_10030860(unsigned int a1, void *a2, int a3)
{
  unsigned int v3; // eax@4
  signed int result; // eax@4
  int v5; // eax@7

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
  {
    v3 = sub_1001A7A0(a1);
    return sub_1001C3C0(v3, (int)a2, a3);
  }
  if ( a1 && (a1 & 3) == 2 )
  {
    v5 = sub_10030C60(a1 & 0xFFFFFFFC, 0, 1);
    result = sub_10031DC0(a1, a2, a3, v5, (unsigned __int64)v5 >> 32);
  }
  else
  {
LABEL_11:
    result = FIL_vfs_read();
  }
  return result;
}
// 10032768: using guessed type int FIL_vfs_read(void);

//----- (100308A0) --------------------------------------------------------
signed int __cdecl sub_100308A0(unsigned int a1, void *a2, int a3, int a4, int a5)
{
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
    return sub_1001C7E0(a1, (int)a2, a3, a4);
  if ( a1 && (a1 & 3) == 2 )
    result = sub_10031DC0(a1, a2, a3, a4, a5);
  else
LABEL_11:
    result = FIL_vfs_read_ofst(a1, a2, a3, &a4);
  return result;
}
// 1003276E: using guessed type int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10030930) --------------------------------------------------------
signed int __cdecl sub_10030930(unsigned int a1, int a2, int a3, int a4)
{
  signed int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = sub_1001C840(a1, a2, a4);
  else
    result = FIL_vfs_seek(a1 & 0xFFFFFFFC, a2, a3, a4);
  return result;
}
// 1003277A: using guessed type int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10030980) --------------------------------------------------------
__int64 __cdecl sub_10030980(int a1)
{
  return FIL_vfs_size(a1 & 0xFFFFFFFC);
}
// 10032780: using guessed type int __cdecl FIL_vfs_size(_DWORD);

//----- (100309B0) --------------------------------------------------------
int __cdecl sub_100309B0(int a1, int a2, int a3)
{
  return FIL_vfs_truncate(a1, a2, a3);
}
// 1003278C: using guessed type int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD);

//----- (100309E0) --------------------------------------------------------
int __cdecl sub_100309E0(int a1, int a2, int a3, char a4)
{
  return FIL_vfs_write_ofst(a1, a2, a3, &a4);
}
// 10032798: using guessed type int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10030A00) --------------------------------------------------------
char __cdecl sub_10030A00(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 772, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_10030770(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10030850: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10030A30) --------------------------------------------------------
char __cdecl sub_10030A30(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 516, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_10030770(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10030850: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10030A60) --------------------------------------------------------
int __cdecl sub_10030A60(char *a1, size_t a2, int a3, int a4)
{
  unsigned int v4; // ecx@1
  int v5; // esi@1
  int v6; // eax@5
  unsigned int v7; // kr08_4@5
  char *v8; // eax@5
  char *v9; // esi@5
  char v10; // cl@6
  unsigned int v11; // eax@7
  char *v12; // edi@7
  char v13; // cl@8
  char *v14; // edi@9
  char *v15; // esi@9
  int v16; // ecx@9
  unsigned int v17; // eax@9
  unsigned int v18; // ebp@11
  signed int v19; // edi@11
  unsigned int i; // esi@11
  char v21; // al@21
  char v23; // [sp+Bh] [bp-85h]@7
  char v24[128]; // [sp+Ch] [bp-84h]@5

  v4 = a3 - 1;
  v5 = 0;
  if ( a3 != 1 )
  {
    do
    {
      ++v5;
      v4 /= 0xAu;
    }
    while ( v4 );
  }
  if ( strlen(a1) + 5 > 0x80 || strlen(a1) + v5 + 1 > a2 )
    return -26;
  v6 = sub_10015290((int)v24, a1, 128);
  sub_100153B0(&v24[v6 - a4 - 1], 128 - (v6 - a4 - 1), "%%0%ii", v5);
  v7 = strlen(a1);
  v8 = &a1[v7 - a4];
  v9 = &a1[v7 - a4];
  do
    v10 = *v8++;
  while ( v10 );
  v11 = v8 - v9;
  v12 = &v23;
  do
    v13 = (v12++)[1];
  while ( v13 );
  qmemcpy(v12, v9, 4 * (v11 >> 2));
  v15 = &v9[4 * (v11 >> 2)];
  v14 = &v12[4 * (v11 >> 2)];
  v16 = v11 & 3;
  v17 = (unsigned int)a3 >> 4;
  qmemcpy(v14, v15, v16);
  if ( a3 > (unsigned int)a3 >> 4 )
    v17 = a3;
  v18 = 0;
  v19 = v17;
  for ( i = 0; ; i += v19 )
  {
    if ( i >= a3 )
      i = a3 - 1;
    sub_100153B0(a1, a2, v24, i);
    if ( sub_10030A30((int)a1) )
      break;
    if ( !i )
      goto LABEL_21;
    v19 /= 2;
    i = v18;
    if ( v19 == 1 )
    {
      i = v18 + 1;
      goto LABEL_21;
    }
LABEL_19:
    ;
  }
  v18 = i;
  if ( i < a3 - 1 )
    goto LABEL_19;
  i = 0;
LABEL_21:
  v21 = 1;
  while ( i < a3 )
  {
    sub_100153B0(a1, a2, v24, i);
    v21 = sub_10030A30((int)a1);
    ++i;
    if ( !v21 )
      return 0;
  }
  if ( !v21 )
    return 0;
  return -11;
}
// 10030A60: using guessed type char var_84[128];

//----- (10030C60) --------------------------------------------------------
signed int __cdecl sub_10030C60(unsigned int a1, int a2, int a3)
{
  return sub_10030930(a1, a2, (unsigned __int64)a2 >> 32, a3);
}

//----- (10030C80) --------------------------------------------------------
int __cdecl sub_10030C80(int a1, int a2, int a3)
{
  return sub_100309B0(a1, a2, a3);
}

//----- (10030CA0) --------------------------------------------------------
char __cdecl sub_10030CA0(int a1, char *a2, size_t a3, char a4)
{
  char result; // al@1
  char *v5; // eax@4

  result = 0;
  if ( a1 && *(_BYTE *)a1 == 4 )
  {
    if ( !a2 )
      return result;
    v5 = "%3u.%3u.%3u.%3u";
    if ( !(a4 & 1) )
      v5 = "%u.%u.%u.%u";
    if ( sub_100153B0(a2, a3, v5, *(_BYTE *)(a1 + 4), *(_BYTE *)(a1 + 5), *(_BYTE *)(a1 + 6), *(_BYTE *)(a1 + 7)) > 0 )
      return 1;
    result = 0;
  }
  if ( a2 )
  {
    if ( (signed int)a3 > 0 )
      *a2 = 0;
  }
  return result;
}

//----- (10030D10) --------------------------------------------------------
char __cdecl sub_10030D10(int a1, char *a2, size_t a3, char a4)
{
  char result; // al@1
  char *v5; // eax@5
  unsigned __int16 v6; // cx@7
  char v7; // [sp+10h] [bp-Ch]@7

  result = 0;
  if ( a1 && *(_BYTE *)(a1 + 4) == 4 )
  {
    if ( !a2 )
      return result;
    if ( sub_10030CA0(a1 + 4, a2, a3, a4) )
    {
      v5 = ":%5i";
      if ( !(a4 & 1) )
        v5 = ":%i";
      HIBYTE(v6) = *(_BYTE *)(a1 + 2);
      LOBYTE(v6) = *(_BYTE *)(a1 + 3);
      sub_100153B0(&v7, 7u, v5, v6);
      if ( sub_100153E0(a2, &v7, a3) > 0 )
        return 1;
    }
    result = 0;
  }
  if ( a2 )
  {
    if ( (signed int)a3 > 0 )
      *a2 = 0;
  }
  return result;
}

//----- (10030E20) --------------------------------------------------------
int __cdecl sub_10030E20(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_recv_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 100327BC: using guessed type int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD);

//----- (10030E70) --------------------------------------------------------
int __cdecl sub_10030E70(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_send_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 100327C2: using guessed type int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD);

//----- (10030EF0) --------------------------------------------------------
int __cdecl sub_10030EF0(int a1, int a2)
{
  int v2; // esi@3

  if ( *(_DWORD *)(a1 + 8) < 0 )
    sub_10014D70("..\\lib\\acl\\kernel\\mem_usr_share.c", 127, 0, 0);
  v2 = j_mem_unmap(a2 - 12, *(_DWORD *)(a1 + 8) + 12);
  if ( v2 )
    sub_10014D70("..\\lib\\acl\\kernel\\mem_usr_share.c", 132, 1, 0);
  return v2;
}
// 10031F10: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (10030F50) --------------------------------------------------------
signed int __cdecl sub_10030F50(int a1)
{
  unsigned int v1; // eax@1
  signed int result; // eax@3

  v1 = **(_DWORD **)(a1 + 16);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    if ( *(_BYTE *)(v1 - 3) || *(_BYTE *)(a1 + 4) & 8 )
    {
      if ( *(_BYTE *)(a1 + 4) & 1 )
      {
        *(_BYTE *)(v1 - 3) = 0;
        result = 1;
      }
      else
      {
        sub_10014D70("..\\lib\\acl\\kernel\\mem_usr_share.c", 474, 1, 0);
        result = 0;
      }
    }
    else
    {
      sub_10014D70("..\\lib\\acl\\kernel\\mem_usr_share.c", 465, 1, 0);
      result = 1;
    }
  }
  else
  {
    sub_10014D70("..\\lib\\acl\\kernel\\mem_usr_share.c", 455, 1, 0);
    result = 0;
  }
  return result;
}

//----- (10030FD0) --------------------------------------------------------
int __usercall sub_10030FD0@<eax>(const char **a1@<esi>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // edi@2
  char v3; // ST28_1@2
  unsigned int v4; // eax@5
  char *v5; // edi@9
  char v6; // al@10
  unsigned int v7; // eax@12
  char v8; // ST28_1@12
  signed int v9; // ebx@15
  int v10; // eax@19
  int result; // eax@47
  unsigned int v12; // [sp+Ch] [bp-98h]@1
  int v13; // [sp+14h] [bp-90h]@29
  char v14; // [sp+1Dh] [bp-87h]@30
  char v15; // [sp+1Fh] [bp-85h]@9
  char v16; // [sp+20h] [bp-84h]@8

  v1 = 0;
  v12 = 0;
  if ( *((_BYTE *)a1 + 4) & 2 )
  {
    v2 = j_FIL_vfs_open(*a1, 4, 0);
    v3 = 4;
  }
  else
  {
    strncpy(&v16, *a1, 0x7Du);
    if ( !(*((_BYTE *)a1 + 4) & 8) )
    {
      v5 = &v15;
      do
        v6 = (v5++)[1];
      while ( v6 );
      *(_DWORD *)v5 = 7368052;
    }
    v12 = j_FIL_vfs_open(*a1, 6, 1809);
    v7 = j_FIL_vfs_open(&v16, 14, 1809);
    v2 = v7;
    v8 = 6;
    if ( v7 >= 0xFFFFFFC2 || !v7 )
    {
      sub_10014D70("..\\lib\\acl\\kernel\\mem_usr_share.c", 589, 1, 0);
      goto LABEL_39;
    }
    v9 = sub_10030C60(v7, 0, 2);
    if ( v9 < 0 )
    {
      sub_10014D70("..\\lib\\acl\\kernel\\mem_usr_share.c", 602, 1, 0);
      goto LABEL_39;
    }
    if ( (signed int)a1[2] < 0 )
      sub_10014D70("..\\lib\\acl\\kernel\\mem_usr_share.c", 610, 0, 0);
    v10 = (int)(a1[2] + 12);
    if ( v9 < v10 && sub_10030C80(v2, v10, (unsigned __int64)v10 >> 32) < 0 )
    {
      sub_10014D70("..\\lib\\acl\\kernel\\mem_usr_share.c", 625, 1, 0);
      goto LABEL_39;
    }
  }
  if ( v2 >= 0xFFFFFFC2 )
    goto LABEL_42;
  if ( v2 )
  {
    v4 = ((int (__cdecl *)(unsigned int, _DWORD, const char *, _DWORD))j_FIL_vfs_mmap)(v2, 0, a1[2] + 12, 0);
    v1 = v4;
    if ( v4 < 0xFFFFFFC2 && v4 )
    {
      if ( !(*((_BYTE *)a1 + 4) & 1) )
      {
        if ( *(_BYTE *)(v4 + 9) || *(_BYTE *)(v4 + 8) != 56 )
        {
          sub_10030EF0((int)a1, v4 + 12);
          v1 = 0;
        }
        goto LABEL_39;
      }
      *(_DWORD *)(v4 + 4) = sub_10030040();
      if ( *((_BYTE *)a1 + 4) & 4 )
        memset((void *)(v1 + 12), (int)a1[3], (size_t)a1[2]);
      if ( v12 < 0xFFFFFFC2 && v12 )
      {
        if ( *((_BYTE *)a1 + 4) & 8 )
        {
          ++*(_DWORD *)v1;
        }
        else if ( sub_10030860(v12, &v13, 12) == 12 )
        {
          *(_DWORD *)v1 = ++v13;
          v14 = 1;
          *(_BYTE *)(v1 + 9) = 1;
          if ( sub_100309E0(v12, (int)&v13, 12, 0) != 12 )
          {
            sub_10014D70("..\\lib\\acl\\kernel\\mem_usr_share.c", 725, 1, 0);
            goto LABEL_39;
          }
        }
      }
      else
      {
        *(_BYTE *)(v1 + 9) = 1;
        *(_DWORD *)v1 = 1;
      }
      *(_BYTE *)(v1 + 8) = 56;
      if ( !(*((_BYTE *)a1 + 4) & 8) && j_FIL_vfs_rename(&v16, *a1) )
        sub_10014D70("..\\lib\\acl\\kernel\\mem_usr_share.c", 759, 1, 0);
      goto LABEL_39;
    }
    sub_10014D70("..\\lib\\acl\\kernel\\mem_usr_share.c", 664, 0, 0);
  }
LABEL_39:
  if ( v2 < 0xFFFFFFC2 && v2 )
    sub_10030770(v2);
LABEL_42:
  if ( v12 < 0xFFFFFFC2 && v12 )
    sub_10030770(v12);
  if ( v1 < 0xFFFFFFC2 && v1 )
    result = v1 + 12;
  else
    result = v1;
  return result;
}
// 10030840: using guessed type int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10030850: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10030920: using guessed type int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD);

//----- (100312D0) --------------------------------------------------------
int __usercall sub_100312D0@<eax>(int a1@<eax>, int a2@<ecx>)
{
  return j_mem_unmap(a2 - 12, a1 + 12);
}
// 10031F10: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (100312F0) --------------------------------------------------------
signed int __cdecl sub_100312F0(int a1)
{
  unsigned int v1; // eax@1
  char v2; // bl@1
  int *v3; // edi@6
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // ebp@6
  unsigned int v8; // eax@15

  v1 = **(_DWORD **)(a1 + 16);
  v2 = 0;
  if ( v1 != -858993460 && (v1 < 0xFFFFFFC2 && v1 || v1 == -15) )
  {
    if ( v1 < 0xFFFFFFC2 && v1 && !*(_BYTE *)(v1 - 3) )
      return 1;
  }
  else
  {
    sub_10014D70("..\\lib\\acl\\kernel\\mem_usr_share.c", 211, 0, *(char **)a1);
    **(_DWORD **)(a1 + 16) = -15;
  }
  v3 = *(int **)(a1 + 16);
  v4 = sub_10030340(81, 5000);
  v5 = *v3;
  v6 = v4;
  if ( (unsigned int)*v3 < 0xFFFFFFC2 && v5 )
  {
    if ( !*(_BYTE *)(v5 - 3) )
    {
      sub_10030310(v4, 81);
      return 1;
    }
    *v3 = -15;
    sub_100312D0(*(_DWORD *)(a1 + 8), v5);
  }
  v8 = sub_10030FD0((const char **)a1);
  if ( v8 < 0xFFFFFFC2 && v8 )
  {
    *v3 = v8;
    if ( !*(_BYTE *)(v8 - 3) )
      v2 = 1;
  }
  sub_10030310(v6, 81);
  return (unsigned __int8)v2;
}

//----- (100313C0) --------------------------------------------------------
int __cdecl sub_100313C0(LONG Value)
{
  char v1; // al@1
  int result; // eax@3
  int v3; // edi@3
  unsigned __int32 v4; // eax@5
  int v5; // ebx@5

  v1 = *(_BYTE *)(Value + 4);
  if ( v1 & 2 || !(v1 & 1) )
  {
    sub_10014D70("..\\lib\\acl\\kernel\\mem_usr_share.c", 360, 1, 0);
    result = 0;
  }
  else
  {
    result = sub_10030FD0((const char **)Value);
    v3 = result;
    if ( (unsigned int)result < 0xFFFFFFC2 && result )
    {
      v4 = InterlockedExchange(*(volatile LONG **)(Value + 16), result);
      v5 = v4;
      if ( v4 < 0xFFFFFFC2 && v4 )
      {
        if ( *(_DWORD *)(Value + 8) < 0 )
          sub_10014D70("..\\lib\\acl\\kernel\\mem_usr_share.c", 388, 0, 0);
        sub_100312D0(*(_DWORD *)(Value + 8), v5);
      }
      result = v3;
    }
  }
  return result;
}

//----- (10031450) --------------------------------------------------------
void __cdecl sub_10031450(int a1, _BYTE *a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_get(a1, a2);
  SYS_exit_krnl();
  sub_10031F20(a1, a2);
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 100327D4: using guessed type int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD);

//----- (10031480) --------------------------------------------------------
int __cdecl sub_10031480(int a1, int a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_set(a1, a2);
  return SYS_exit_krnl();
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 100327DA: using guessed type int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD);

//----- (100314A0) --------------------------------------------------------
__int16 __cdecl sub_100314A0(int a1, int a2, int a3, int a4)
{
  __int16 v4; // si@1

  SYS_enter_krnl();
  v4 = HWM_pvg_read_rgn(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10032684: using guessed type int SYS_exit_krnl(void);
// 10032690: using guessed type int SYS_enter_krnl(void);
// 100327E0: using guessed type int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100314E0) --------------------------------------------------------
__int16 __cdecl sub_100314E0(int a1, _DWORD *a2, _BYTE *a3)
{
  __int16 result; // ax@1
  char v4; // [sp+8h] [bp-ECh]@1
  unsigned __int8 v5; // [sp+Ah] [bp-EAh]@1
  int v6; // [sp+10h] [bp-E4h]@1

  j_HWM_pvg_rgn_get_info(a1, &v4);
  result = v5;
  *a2 = v6;
  *a3 = 2;
  return result;
}
// 100314D0: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (10031540) --------------------------------------------------------
int __cdecl sub_10031540(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10014FA0(v1);
  a1 = v2;
  v3 = sub_10014DE0(&a1, 4u, (int)&unk_100AE080, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100AE084[2 * v3];
}
// 100AE084: using guessed type int dword_100AE084[];

//----- (10031580) --------------------------------------------------------
int __cdecl sub_10031580(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10014FA0(v1);
  a1 = v2;
  v3 = sub_10014DE0(&a1, 4u, (int)&unk_100AE0B8, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100AE0BC[2 * v3];
}
// 100AE0BC: using guessed type int dword_100AE0BC[];

//----- (100315C0) --------------------------------------------------------
int __cdecl sub_100315C0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10014FA0(v1);
  a1 = v2;
  v3 = sub_10014DE0(&a1, 4u, (int)&unk_100AE0F0, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100AE0F4[2 * v3];
}
// 100AE0F4: using guessed type int dword_100AE0F4[];

//----- (10031600) --------------------------------------------------------
int __cdecl sub_10031600(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10014FA0(v1);
  a1 = v2;
  v3 = sub_10014DE0(&a1, 4u, (int)&unk_100AE128, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100AE12C[2 * v3];
}
// 100AE12C: using guessed type int dword_100AE12C[];

//----- (10031640) --------------------------------------------------------
int __cdecl sub_10031640(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // eax@2
  int v6; // eax@8

  result = 0;
  if ( a1 )
  {
    v5 = sub_10031580(a4);
    result = sub_100303F0(v5, a1, 104);
  }
  if ( a2 && !result )
    result = sub_100303F0(3532, a2, 2);
  if ( a3 )
  {
    if ( !result )
    {
      v6 = sub_10031540(a4);
      result = sub_100303F0(v6, a3, 6);
    }
  }
  return result;
}

//----- (100316B0) --------------------------------------------------------
int __cdecl sub_100316B0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  int v5; // eax@3
  int v6; // eax@6
  int v7; // eax@7

  result = 0;
  if ( a1 )
  {
    v4 = sub_10031600(a3);
    result = sub_100303F0(v4, a1, 64);
    if ( result == -7 )
    {
      sub_10030240(100);
      v5 = sub_10031600(a3);
      result = sub_100303F0(v5, a1, 64);
    }
  }
  if ( a2 && !result )
  {
    v6 = sub_100315C0(a3);
    result = sub_100303F0(v6, a2, 8);
    if ( result == -7 )
    {
      sub_10030240(100);
      v7 = sub_100315C0(a3);
      result = sub_100303F0(v7, a2, 8);
    }
  }
  return result;
}

//----- (10031760) --------------------------------------------------------
char __cdecl sub_10031760(unsigned int a1, unsigned int *a2, int *a3)
{
  int *v3; // edi@4
  int *v4; // edi@5
  int *v5; // edi@6
  int *v7; // edi@11
  int *v8; // edi@12
  int *v9; // esi@13
  unsigned int *v10; // [sp-18h] [bp-E94h]@4
  signed int v11; // [sp-14h] [bp-E90h]@4
  int v12; // [sp+14h] [bp-E68h]@1
  int v13; // [sp+18h] [bp-E64h]@6
  int v14; // [sp+1Ch] [bp-E60h]@6
  char v15; // [sp+20h] [bp-E5Ch]@6
  char v16; // [sp+22h] [bp-E5Ah]@6
  char v17; // [sp+23h] [bp-E59h]@6
  char v18; // [sp+25h] [bp-E57h]@6
  char v19; // [sp+27h] [bp-E55h]@6
  char v20; // [sp+28h] [bp-E54h]@6
  char v21; // [sp+29h] [bp-E53h]@6
  int v22; // [sp+2Ch] [bp-E50h]@6
  int v23; // [sp+37h] [bp-E45h]@5
  int v24; // [sp+40h] [bp-E3Ch]@12
  int v25; // [sp+F0h] [bp-D8Ch]@13
  int v26; // [sp+E70h] [bp-Ch]@11
  int v27; // [sp+E74h] [bp-8h]@11

  memset(&v12, 0, 0xE64u);
  *_errno() = 0;
  if ( a1 > 0x183A )
  {
    if ( a1 == 6455 )
    {
      v9 = _errno();
      *v9 = sub_100303F0(6455, (int)&v12, 252);
      v25 = 0;
      v11 = 252;
LABEL_14:
      v10 = (unsigned int *)&v12;
      goto LABEL_15;
    }
    if ( a1 != 6649 )
    {
      if ( a1 != 6655 )
        return 0;
      goto LABEL_11;
    }
LABEL_12:
    v8 = _errno();
    *v8 = sub_100303F0(a1, (int)&v12, 48);
    v11 = 48;
    v24 = 0;
    v10 = (unsigned int *)&v12;
    goto LABEL_15;
  }
  if ( a1 >= 0x1839 )
    goto LABEL_12;
  switch ( a1 )
  {
    case 0x17D9u:
    case 0x17DAu:
      v3 = _errno();
      v11 = 36;
      *v3 = sub_100303F0(a1, (int)&v12, 36);
      v12 = 0;
      v10 = (unsigned int *)&v12;
      goto LABEL_15;
    case 0x1819u:
      v4 = _errno();
      *v4 = sub_100303F0(a1, (int)&v12, 40);
      v11 = 40;
      v23 = 0;
      v10 = (unsigned int *)&v12;
      goto LABEL_15;
    case 0x17CDu:
    case 0x17CEu:
      v5 = _errno();
      *v5 = sub_100303F0(a1, (int)&v12, 60);
      v12 = 0;
      v13 = 0;
      v14 = 0;
      v15 = 0;
      v16 = 0;
      v17 = 0;
      v22 = 0;
      v18 = 0;
      v21 = 0;
      v19 = 0;
      v20 = 0;
      v11 = 60;
      goto LABEL_14;
    default:
      return 0;
    case 0x1776u:
    case 0x1777u:
    case 0x1778u:
      break;
  }
LABEL_11:
  v7 = _errno();
  *v7 = sub_100303F0(a1, (int)&v12, 3684);
  v11 = 3684;
  v26 = 0;
  v27 = 0;
  v10 = (unsigned int *)&v12;
LABEL_15:
  *a2 = sub_100322A0(v10, v11, 0xFFFFFFFF);
  *a3 = *_errno();
  return 1;
}

//----- (10031A20) --------------------------------------------------------
unsigned int __cdecl sub_10031A20(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6)
{
  size_t v6; // ebp@1
  int *v7; // esi@1
  size_t v8; // ebx@1
  int v9; // edx@1
  unsigned int v10; // edi@1
  int v11; // ebx@2
  int v12; // edx@3
  int *v13; // ebp@3
  int v14; // eax@3
  int v15; // eax@3
  unsigned int result; // eax@4
  void **v17; // [sp+10h] [bp-Ch]@1
  void **v18; // [sp+20h] [bp+4h]@1

  v6 = 8 * a5;
  v7 = &dword_10209870[a1];
  v8 = 32 * (a3 / (1 << a4));
  v9 = a2 - v8 - v6;
  *v7 = v9 + a3 - 52;
  v17 = (void **)&dword_10209828[a1];
  dword_10209828[a1] = a3 + v9;
  dword_102097E8[a1] = a3 + a2 - v8;
  v18 = (void **)&dword_102097E8[a1];
  memset((void *)(v9 + a3 - 52), 0, 0x34u);
  memset(*v17, 0, v6);
  memset(*v18, 0, v8);
  *(_DWORD *)(*v7 + 24) = 1 << a4;
  *(_DWORD *)(*v7 + 28) = ~(*(_DWORD *)(*v7 + 24) - 1);
  *(_BYTE *)(*v7 + 32) = a4;
  *(_DWORD *)(*v7 + 12) = a2;
  *(_DWORD *)(*v7 + 16) = a3;
  *(_DWORD *)(*v7 + 8) = a3 / (1 << a4) - (v8 + v6 + 52) / (1 << a4) - 1;
  *(_DWORD *)(*v7 + 4) = a6;
  *(_WORD *)(*v7 + 20) = a5;
  *(_DWORD *)*v7 = -1;
  *(_DWORD *)(*v7 + 36) = *v7 + 36;
  *(_DWORD *)(*v7 + 40) = *v7 + 36;
  *(_DWORD *)(*v7 + 44) = *v7 + 44;
  *(_DWORD *)(*v7 + 48) = *v7 + 44;
  v10 = 0;
  if ( *(_DWORD *)(*v7 + 8) )
  {
    v11 = 0;
    do
    {
      v12 = *v7;
      v13 = *(int **)(*v7 + 40);
      v14 = (int)*v18 + v11;
      *(_DWORD *)(v12 + 40) = v14;
      *(_DWORD *)v14 = v12 + 36;
      *(_DWORD *)(v14 + 4) = v13;
      *v13 = v14;
      v15 = a2 + v10++ * *(_DWORD *)(*v7 + 24);
      *(_DWORD *)((char *)*v18 + v11 + 28) = v15;
      v11 += 32;
    }
    while ( v10 < *(_DWORD *)(*v7 + 8) );
  }
  result = 0;
  if ( *(_WORD *)(*v7 + 20) )
  {
    do
    {
      *((_DWORD *)*v17 + 2 * result) = (char *)*v17 + 8 * result;
      *((_DWORD *)*v17 + 2 * result + 1) = (char *)*v17 + 8 * result;
      ++result;
    }
    while ( result < *(_WORD *)(*v7 + 20) );
  }
  return result;
}
// 10209828: using guessed type int dword_10209828[];
// 10209870: using guessed type int dword_10209870[];

//----- (10031BD0) --------------------------------------------------------
int __usercall sub_10031BD0@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int *v2; // ecx@1
  int result; // eax@2
  int v4; // eax@3
  int v5; // ecx@3
  _DWORD *v6; // edx@3
  int v7; // ecx@3
  _DWORD *v8; // edx@3
  int v9; // ecx@3
  int v10; // edx@3

  v1 = dword_10209870[a1];
  v2 = (int *)(v1 + 36);
  if ( (int *)*v2 == v2 )
  {
    v4 = *(_DWORD *)(v1 + 44);
    v5 = *(_DWORD *)(v4 - 8);
    v6 = *(_DWORD **)(v4 - 4);
    result = v4 - 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v7 = *(_DWORD *)(result + 8);
    v8 = *(_DWORD **)(result + 12);
    *(_DWORD *)(v7 + 4) = v8;
    *v8 = v7;
    v9 = dword_10209870[a1];
    v10 = *(_DWORD *)(v9 + 36);
    v9 += 36;
    *(_DWORD *)(v10 + 4) = result;
    *(_DWORD *)result = v10;
    *(_DWORD *)(result + 4) = v9;
    *(_DWORD *)v9 = result;
  }
  else
  {
    result = *v2;
  }
  return result;
}
// 10209870: using guessed type int dword_10209870[];

//----- (10031C80) --------------------------------------------------------
int __cdecl sub_10031C80(int a1, unsigned __int64 a2)
{
  int v2; // edi@1
  int *v3; // ebx@1
  signed int v4; // eax@1
  _DWORD *v5; // ecx@2
  int v6; // eax@2
  int *v7; // eax@2
  int v8; // ecx@2
  _DWORD *v9; // edx@2
  int v10; // eax@2
  int v11; // ecx@2
  int result; // eax@2

  v2 = sub_10031BD0(a1);
  v3 = &dword_10209870[a1];
  v4 = sub_100308A0(
         *(_DWORD *)dword_10209870[a1] & 0xFFFFFFFC,
         *(void **)(v2 + 28),
         *(_DWORD *)(dword_10209870[a1] + 24),
         a2,
         SHIDWORD(a2));
  if ( v4 <= 0 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD **)(v2 + 4);
    *(_WORD *)(v2 + 24) = v4;
    v6 = *(_DWORD *)v2;
    *(_QWORD *)(v2 + 16) = a2;
    *(_DWORD *)(v6 + 4) = v5;
    *v5 = v6;
    v7 = (int *)(dword_10209828[a1] + 8 * ((unsigned int)(a2 >> *(_BYTE *)(*v3 + 32)) % *(_WORD *)(*v3 + 20)));
    v8 = *v7;
    *(_DWORD *)(v8 + 4) = v2;
    *(_DWORD *)(v2 + 4) = v7;
    *(_DWORD *)v2 = v8;
    *v7 = v2;
    v9 = *(_DWORD **)(*v3 + 48);
    v10 = *v3 + 44;
    v11 = v2 + 8;
    *(_DWORD *)(v10 + 4) = v2 + 8;
    *(_DWORD *)v11 = v10;
    result = v2;
    *(_DWORD *)(v11 + 4) = v9;
    *v9 = v2 + 8;
  }
  return result;
}
// 10209828: using guessed type int dword_10209828[];
// 10209870: using guessed type int dword_10209870[];

//----- (10031D30) --------------------------------------------------------
int __usercall sub_10031D30@<eax>(int a1@<ebx>, unsigned __int64 a2)
{
  int *v2; // edi@1
  int *v3; // ecx@1
  int result; // eax@1
  int v5; // edx@5
  _DWORD *v6; // esi@5
  int v7; // ecx@5
  _DWORD *v8; // esi@5
  int v9; // edx@5

  v2 = &dword_10209870[a1];
  v3 = (int *)(dword_10209828[a1]
             + 8 * ((unsigned int)(a2 >> *(_BYTE *)(dword_10209870[a1] + 32)) % *(_WORD *)(dword_10209870[a1] + 20)));
  result = *v3;
  if ( (int *)*v3 == v3 )
  {
LABEL_4:
    result = sub_10031C80(a1, a2);
  }
  else
  {
    while ( *(_QWORD *)(result + 16) != a2 )
    {
      result = *(_DWORD *)result;
      if ( (int *)result == v3 )
        goto LABEL_4;
    }
    v5 = *(_DWORD *)(result + 8);
    v6 = *(_DWORD **)(result + 12);
    v7 = result + 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v8 = *(_DWORD **)(*v2 + 48);
    v9 = *v2 + 44;
    *(_DWORD *)(v9 + 4) = result + 8;
    *(_DWORD *)(v7 + 4) = v8;
    *(_DWORD *)v7 = v9;
    *v8 = result + 8;
  }
  return result;
}
// 10209828: using guessed type int dword_10209828[];
// 10209870: using guessed type int dword_10209870[];

//----- (10031DC0) --------------------------------------------------------
unsigned int __cdecl sub_10031DC0(int a1, void *a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // edx@2
  unsigned int result; // eax@4
  int v10; // eax@7
  int v11; // esi@10
  int v12; // eax@10
  int v13; // ecx@11
  unsigned int v14; // eax@11
  const void *v15; // ecx@11
  size_t v16; // esi@12
  int v17; // ecx@13
  int v18; // et0@17

  v5 = a3;
  v6 = 0;
  v7 = a4;
  if ( !dword_10209868 )
    goto LABEL_24;
  while ( 1 )
  {
    v8 = dword_10209870[v6];
    if ( *(_DWORD *)v8 == a1 )
      break;
    if ( ++v6 >= (unsigned int)dword_10209868 )
      return -1;
  }
  if ( v6 != -1 )
  {
    v10 = *(_DWORD *)(v8 + 4);
    if ( v10 != 138 )
      sub_10030160(v10, -1);
    if ( a3 )
    {
      while ( 1 )
      {
        v11 = v7 & ~*(_DWORD *)(dword_10209870[v6] + 28);
        v12 = sub_10031D30(v6, (unsigned int)v7 & *(_DWORD *)(dword_10209870[v6] + 28));
        if ( !v12 )
          break;
        v13 = *(_DWORD *)(v12 + 28);
        v14 = *(_WORD *)(v12 + 24) - v11;
        v15 = (const void *)(v11 + v13);
        if ( v5 <= v14 )
        {
          v16 = v5;
        }
        else
        {
          v16 = v14;
          if ( !v14 )
            goto LABEL_13;
        }
        memcpy(a2, v15, v16);
        v5 -= v16;
        v18 = (v16 + __PAIR__((unsigned int)a5, v7)) >> 32;
        v7 += v16;
        a5 = v18;
        a2 = (char *)a2 + v16;
        if ( !v5 )
          goto LABEL_13;
      }
      if ( *(_DWORD *)(dword_10209870[v6] + 4) != 138 )
        sub_10030140(*(_DWORD *)(dword_10209870[v6] + 4));
      result = -1;
    }
    else
    {
LABEL_13:
      v17 = dword_10209870[v6];
      if ( *(_DWORD *)(v17 + 4) != 138 )
        sub_10030140(*(_DWORD *)(v17 + 4));
      result = a3 - v5;
    }
  }
  else
  {
LABEL_24:
    result = -1;
  }
  return result;
}
// 10209868: using guessed type int dword_10209868;
// 10209870: using guessed type int dword_10209870[];

//----- (10031F20) --------------------------------------------------------
void __cdecl sub_10031F20(__int16 a1, _BYTE *a2)
{
  void *v2; // ecx@0
  void *v3; // ecx@2

  if ( a1 == 29 && sub_100155F0(v2) && sub_10015670(v3) != 1 )
    *a2 = 0;
}

//----- (10031F50) --------------------------------------------------------
double __cdecl sub_10031F50(char a1)
{
  double v1; // st7@5
  double result; // st7@9
  float v3; // [sp+0h] [bp-4h]@1

  v3 = 0.0;
  if ( !sub_10019090() )
    goto LABEL_13;
  if ( !a1 )
  {
    v1 = *(float *)(dword_1020D80C + 124);
    goto LABEL_8;
  }
  if ( a1 == 2 )
  {
    v1 = *(float *)(dword_1020D80C + 860);
    goto LABEL_8;
  }
  if ( a1 == 3 )
  {
    v1 = *(float *)(dword_1020D80C + 1204);
LABEL_8:
    v3 = v1;
  }
  result = v3;
  if ( (LODWORD(v3) & 0x7F800000) == 2139095040 || result > 3.141592502593994 || result < -3.141592502593994 )
  {
    v3 = 0.0;
LABEL_13:
    result = v3;
  }
  return result;
}
// 1020D80C: using guessed type int dword_1020D80C;

//----- (10031FE0) --------------------------------------------------------
char sub_10031FE0()
{
  unsigned __int8 v0; // cl@2
  signed int v1; // eax@4

  if ( !sub_10019090() )
  {
    LOBYTE(v1) = 0;
    return v1;
  }
  v0 = *(_BYTE *)(dword_1020D80C + 1200);
  if ( v0 || (v0 = *(_BYTE *)(dword_1020D80C + 814)) != 0 )
  {
    LOBYTE(v1) = v0;
    if ( v0 < 4u )
      return v1;
    v1 = 4;
  }
  else
  {
    v1 = *(_BYTE *)(dword_1020D80C + 122) == 0;
  }
  if ( v1 == 4 )
    LOBYTE(v1) = 0;
  return v1;
}
// 1020D80C: using guessed type int dword_1020D80C;

//----- (10032030) --------------------------------------------------------
char __cdecl sub_10032030(int a1)
{
  char result; // al@1
  int v2; // ecx@2
  char v3; // al@4
  unsigned __int8 v4; // al@16

  *(_DWORD *)(a1 + 16) = 0x3FFFF;
  *(_BYTE *)a1 = -1;
  *(_DWORD *)(a1 + 20) = 0x3FFFF;
  *(_BYTE *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_BYTE *)(a1 + 2) = 1;
  *(_BYTE *)(a1 + 3) = 1;
  *(_BYTE *)(a1 + 4) = 6;
  *(_BYTE *)(a1 + 5) = -1;
  *(_BYTE *)(a1 + 6) = 0;
  *(_BYTE *)(a1 + 7) = -1;
  *(_BYTE *)(a1 + 9) = 0;
  *(_BYTE *)(a1 + 13) = 0;
  *(_BYTE *)(a1 + 10) = -1;
  *(_BYTE *)(a1 + 11) = 0;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 12) = 0;
  *(_BYTE *)(a1 + 14) = 1;
  *(_BYTE *)(a1 + 15) = 0;
  result = sub_10019090();
  if ( result )
  {
    sub_1001F400();
    *(_BYTE *)(a1 + 8) = *(_BYTE *)(dword_1020D80C + 815);
    *(_BYTE *)(a1 + 4) = *(_BYTE *)(dword_1020D80C + 94);
    *(_BYTE *)(a1 + 11) = *(_BYTE *)(dword_1020D80C + 97);
    *(_BYTE *)(a1 + 1) = *(_BYTE *)(dword_1020D800 + 239);
    *(_BYTE *)(a1 + 15) = *(_BYTE *)(dword_1020D80C + 826);
    strncpy((char *)(a1 + 24), (const char *)(dword_1020D80C + 872), 0xCu);
    *(_BYTE *)(a1 + 35) = 0;
    *(_BYTE *)(a1 + 6) = *(_BYTE *)(dword_1020D80C + 784);
    *(_BYTE *)(a1 + 14) = 0;
    v2 = dword_1020D80C;
    if ( *(_BYTE *)(dword_1020D80C + 669) && !*(_BYTE *)(dword_1020D80C + 667)
      || (v3 = *(_BYTE *)(dword_1020D80C + 159)) != 0
      && *(_BYTE *)(dword_1020D80C + 667)
      && !*(_BYTE *)(dword_1020D80C + 661)
      && (v3 != 2 || -1.0 == *(float *)(dword_1020D80C + 116))
      || !*(_BYTE *)(dword_1020D80C + 672) )
    {
      *(_BYTE *)(a1 + 14) = 1;
      v2 = dword_1020D80C;
    }
    else if ( *(_BYTE *)(dword_1020D80C + 101) == 4
           && *(_BYTE *)(dword_1020D80C + 812) >= *(_BYTE *)(dword_1020D800 + 241)
           && !*(_BYTE *)(dword_1020D80C + 89)
           && -1.0 == *(float *)(dword_1020D80C + 116) )
    {
      *(_BYTE *)(a1 + 14) = 1;
      v2 = dword_1020D80C;
    }
    *(_BYTE *)(a1 + 9) = *(_BYTE *)(v2 + 816);
    *(_BYTE *)(a1 + 5) = *(_BYTE *)(dword_1020D800 + 241);
    v4 = *(_BYTE *)(a1 + 9) - 1;
    *(_BYTE *)(a1 + 10) = *(_BYTE *)(dword_1020D800 + 244);
    if ( v4 > 2u )
    {
      *(_BYTE *)(a1 + 9) = 0;
      *(_DWORD *)(a1 + 16) = 0x3FFFF;
      *(_DWORD *)(a1 + 20) = 0x3FFFF;
      *(_BYTE *)(a1 + 12) = 0;
      *(_BYTE *)a1 = -1;
      *(_BYTE *)(a1 + 2) = 1;
      *(_BYTE *)(a1 + 3) = 1;
      *(_BYTE *)(a1 + 7) = -1;
      *(_BYTE *)(a1 + 14) = 1;
      result = sub_1001F3F0();
    }
    else
    {
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(dword_1020D80C + 836);
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(dword_1020D80C + 840);
      *(_BYTE *)a1 = *(_BYTE *)(dword_1020D80C + 812);
      *(_BYTE *)(a1 + 13) = *(_BYTE *)(dword_1020D80C + 825);
      if ( *(_DWORD *)(dword_1020D80C + 892) )
        *(_BYTE *)(a1 + 3) = 0;
      else
        *(_BYTE *)(a1 + 3) = *(_BYTE *)(dword_1020D80C + 288);
      *(_BYTE *)(a1 + 2) = *(_BYTE *)(dword_1020D80C + 288);
      *(_BYTE *)(a1 + 7) = *(_BYTE *)(dword_1020D80C + 813);
      *(_BYTE *)(a1 + 12) = *(_BYTE *)(dword_1020D800 + 4);
      result = sub_1001F3F0();
    }
  }
  return result;
}
// 1020D800: using guessed type int dword_1020D800;
// 1020D80C: using guessed type int dword_1020D80C;

//----- (10032280) --------------------------------------------------------
int __cdecl sub_10032280(unsigned __int8 a1, unsigned int a2)
{
  return dword_100B0DB0[a1 ^ (unsigned __int8)a2] ^ (a2 >> 8);
}
// 100B0DB0: using guessed type int dword_100B0DB0[];

//----- (100322A0) --------------------------------------------------------
unsigned int __cdecl sub_100322A0(unsigned int *a1, signed int a2, unsigned int a3)
{
  unsigned int *v3; // edx@1
  unsigned int result; // eax@1
  signed int i; // esi@1
  unsigned int v6; // edi@5
  unsigned int v7; // eax@6
  unsigned int v8; // eax@6
  unsigned int v9; // eax@6
  unsigned int v10; // eax@6
  unsigned int v11; // ecx@6
  unsigned int v12; // ecx@6
  unsigned int v13; // ecx@6

  v3 = a1;
  result = a3;
  for ( i = a2; i; --i )
  {
    if ( !((unsigned __int8)v3 & 3) )
      break;
    result = dword_100B0DB0[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    v3 = (unsigned int *)((char *)v3 + 1);
  }
  if ( i >= 8 )
  {
    v6 = (unsigned int)i >> 3;
    do
    {
      v7 = dword_100B0DB0[(unsigned __int8)result ^ (unsigned __int8)*v3] ^ (result >> 8);
      v8 = dword_100B0DB0[(unsigned __int8)v7 ^ (unsigned __int8)(*(_WORD *)v3 >> 8)] ^ (v7 >> 8);
      v9 = dword_100B0DB0[(unsigned __int8)v8 ^ (unsigned __int8)(*v3 >> 16)] ^ (v8 >> 8);
      v10 = dword_100B0DB0[(unsigned __int8)v9 ^ (*v3 >> 24)] ^ (v9 >> 8);
      v3 += 2;
      v11 = dword_100B0DB0[(unsigned __int8)v10 ^ (unsigned __int8)*(v3 - 1)] ^ (v10 >> 8);
      v12 = dword_100B0DB0[(unsigned __int8)v11 ^ (unsigned __int8)(*((_WORD *)v3 - 2) >> 8)] ^ (v11 >> 8);
      v13 = dword_100B0DB0[(unsigned __int8)v12 ^ (unsigned __int8)(*(v3 - 1) >> 16)] ^ (v12 >> 8);
      i -= 8;
      --v6;
      result = dword_100B0DB0[(unsigned __int8)v13 ^ (*(v3 - 1) >> 24)] ^ (v13 >> 8);
    }
    while ( v6 );
  }
  for ( ; i > 0; v3 = (unsigned int *)((char *)v3 + 1) )
  {
    result = dword_100B0DB0[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    --i;
  }
  return result;
}
// 100B0DB0: using guessed type int dword_100B0DB0[];

//----- (100323D0) --------------------------------------------------------
double __cdecl sub_100323D0(double a1, double a2)
{
  double result; // st7@1
  double v3; // [sp+0h] [bp-8h]@2

  result = 0.0;
  if ( a2 > 0.0 )
  {
    v3 = a2 + a2;
    result = fmod(a1, v3);
    if ( a2 > result )
    {
      if ( -a2 > result )
        result = result + v3;
    }
    else
    {
      result = result - v3;
    }
  }
  return result;
}

//----- (10032430) --------------------------------------------------------
double __cdecl sub_10032430(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@5
  float v6; // [sp+8h] [bp+8h]@3
  float v7; // [sp+8h] [bp+8h]@3
  float v8; // [sp+8h] [bp+8h]@4
  float v9; // [sp+8h] [bp+8h]@6

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v6 = v2 + v2;
    v4 = v6;
    v7 = a1 - (double)(signed int)(a1 / v6) * v6;
    if ( v7 < v2 )
    {
      v5 = v2;
      result = v7;
      if ( -v5 > v7 )
      {
        v9 = result + v4;
        result = v9;
      }
    }
    else
    {
      v8 = v7 - v4;
      result = v8;
    }
  }
  else
  {
    result = 0.0;
  }
  return result;
}

//----- (100324B0) --------------------------------------------------------
void __cdecl sub_100324B0(double a1)
{
  sub_100323D0(a1, 3.1415926535898);
}

//----- (100324D0) --------------------------------------------------------
double __cdecl sub_100324D0(float a1)
{
  double result; // st7@3

  if ( a1 == -3.141592741012573 || a1 == 3.141592741012573 )
    result = -3.1415925;
  else
    result = sub_10032430(a1, 3.1415927);
  return result;
}

//----- (10032510) --------------------------------------------------------
int __cdecl sub_10032510(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(float *)a2 = *(double *)a1;
  *(float *)(a2 + 4) = *(double *)(a1 + 8);
  return result;
}

//----- (10032530) --------------------------------------------------------
int __cdecl sub_10032530(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(double *)a2 = *(float *)a1;
  *(double *)(a2 + 8) = *(float *)(a1 + 4);
  return result;
}

//----- (10032550) --------------------------------------------------------
int __cdecl sub_10032550(float a1)
{
  double v1; // st7@1
  int result; // eax@3
  float v3; // [sp+8h] [bp+4h]@1
  float v4; // [sp+8h] [bp+4h]@2
  float v5; // [sp+8h] [bp+4h]@3

  v3 = sub_100324D0(a1);
  v1 = v3;
  if ( v3 < 0.0 )
  {
    v4 = v1 + 6.283185482025146;
    v1 = v4;
  }
  v5 = v1 * 180.0 / 3.1415926535898;
  result = (signed int)(v5 + 0.5);
  if ( result >= 360 )
    result = 0;
  return result;
}

//----- (100325B0) --------------------------------------------------------
int __cdecl sub_100325B0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(float *)a3 = *(float *)a1 + *(float *)a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) + *(float *)(a2 + 4);
  *(float *)(a3 + 8) = *(float *)(a1 + 8) + *(float *)(a2 + 8);
  return result;
}

//----- (100325E0) --------------------------------------------------------
int __cdecl sub_100325E0(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a2;
  *(float *)a3 = *(float *)a2 * a1;
  *(float *)(a3 + 4) = *(float *)(a2 + 4) * a1;
  *(float *)(a3 + 8) = a1 * *(float *)(a2 + 8);
  return result;
}

//----- (10036BEF) --------------------------------------------------------
int __cdecl sub_10036BEF(int a1, FILE *a2)
{
  FILE *v2; // esi@1
  int v3; // eax@1
  unsigned int v5; // eax@9
  int v6; // eax@15
  char *v7; // edi@15
  signed __int32 v8; // edi@15
  _BYTE *v9; // eax@20
  __int64 v10; // rax@23
  _WORD *v11; // [sp+4h] [bp-4h]@9

  v2 = a2;
  a2 = (FILE *)_fileno(a2);
  v3 = v2->_flag;
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    v2->_flag |= 0x20u;
    return -1;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v3 & 1 )
  {
    v2->_cnt = 0;
    if ( !(v3 & 0x10) )
    {
      v2->_flag = v3 | 0x20;
      return -1;
    }
    v2->_ptr = v2->_base;
    v2->_flag = v3 & 0xFFFFFFFE;
  }
  v5 = v2->_flag & 0xFFFFFFEF | 2;
  v2->_flag = v5;
  v2->_cnt = 0;
  v11 = 0;
  if ( !(v5 & 0x10C)
    && ((void **)v2 != sub_1003F568() + 8 && (void **)v2 != sub_1003F568() + 16 || !sub_1003F50A((signed int)a2)) )
  {
    _getbuf(v2);
  }
  if ( v2->_flag & 0x108 )
  {
    v6 = (int)v2->_base;
    v7 = v2->_ptr;
    v2->_ptr = (char *)(v6 + 1);
    v8 = (signed __int32)&v7[-v6];
    v2->_cnt = v2->_bufsiz - 1;
    if ( v8 <= 0 )
    {
      if ( a2 == (FILE *)-1 || a2 == (FILE *)-2 )
        v9 = &unk_100C1968;
      else
        v9 = (_BYTE *)(dword_1020E860[(signed int)a2 >> 5] + (((unsigned __int8)a2 & 0x1F) << 6));
      if ( v9[4] & 0x20 )
      {
        v10 = _lseeki64((int)a2, 0i64, 2);
        if ( (HIDWORD(v10) & (unsigned int)v10) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v11 = sub_1003F3EA((int)a2, v6, v8);
    }
    *v2->_base = a1;
  }
  else
  {
    v8 = 1;
    v11 = sub_1003F3EA((int)a2, (int)&a1, 1u);
  }
  if ( v11 != (_WORD *)v8 )
  {
LABEL_27:
    v2->_flag |= 0x20u;
    return -1;
  }
  return (unsigned __int8)a1;
}
// 1003F4C6: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 1020E860: using guessed type int dword_1020E860[];

//----- (10037784) --------------------------------------------------------
int __cdecl sub_10037784(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10209C60 = a1;
  return result;
}
// 10209C60: using guessed type int dword_10209C60;

//----- (10038D0C) --------------------------------------------------------
signed int __cdecl sub_10038D0C(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_10209C68 )
  {
    *a1 = dword_10209C68;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1003788A: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10209C68: using guessed type int dword_10209C68;

//----- (10038D43) --------------------------------------------------------
signed int __cdecl sub_10038D43(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_10209C68 )
  {
    *a1 = dword_10209C74;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1003788A: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10209C68: using guessed type int dword_10209C68;
// 10209C74: using guessed type int dword_10209C74;

//----- (10039314) --------------------------------------------------------
void sub_10039314()
{
  void **v0; // esi@1
  void *v1; // edi@2
  unsigned int i; // eax@3

  v0 = (void **)dword_1020E860;
  do
  {
    v1 = *v0;
    if ( *v0 )
    {
      for ( i = (unsigned int)v1 + 2048; (unsigned int)v1 < i; i = (unsigned int)*v0 + 2048 )
      {
        if ( *((_DWORD *)v1 + 2) )
          DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
        v1 = (char *)v1 + 64;
      }
      free(*v0);
      *v0 = 0;
    }
    ++v0;
  }
  while ( (signed int)v0 < (signed int)&dword_1020E960 );
}
// 1020E860: using guessed type int dword_1020E860[];
// 1020E960: using guessed type int dword_1020E960;

//----- (100397C1) --------------------------------------------------------
int (*sub_100397C1())(void)
{
  int (*result)(void); // eax@1
  int (**v1)(void); // esi@1

  result = (int (*)(void))&unk_100BF3E0;
  v1 = (int (**)(void))&unk_100BF3E0;
  if ( &unk_100BF3E0 < &unk_100BF3E0 )
  {
    do
    {
      result = *v1;
      if ( *v1 )
        result = (int (*)(void))result();
      ++v1;
    }
    while ( v1 < (int (**)(void))&unk_100BF3E0 );
  }
  return result;
}

//----- (100397E5) --------------------------------------------------------
void __cdecl sub_100397E5()
{
  void (**v0)(void); // esi@1

  v0 = (void (**)(void))&unk_100BF3E8;
  if ( &unk_100BF3E8 < &unk_100BF3E8 )
  {
    do
    {
      if ( *v0 )
        (*v0)();
      ++v0;
    }
    while ( v0 < (void (**)(void))&unk_100BF3E8 );
  }
}

//----- (1003D474) --------------------------------------------------------
#error "1003D479: positive sp value has been found (funcsize=0)"

//----- (1003D47F) --------------------------------------------------------
#error "1003D484: positive sp value has been found (funcsize=0)"

//----- (1003D48A) --------------------------------------------------------
#error "1003D48F: positive sp value has been found (funcsize=0)"

//----- (1003D490) --------------------------------------------------------
#error "1003D495: positive sp value has been found (funcsize=0)"

//----- (1003D496) --------------------------------------------------------
#error "1003D49B: positive sp value has been found (funcsize=0)"

//----- (1003D49C) --------------------------------------------------------
#error "1003D4A1: positive sp value has been found (funcsize=0)"

//----- (1003D4A2) --------------------------------------------------------
#error "1003D4BD: positive sp value has been found (funcsize=0)"

//----- (1003D4C3) --------------------------------------------------------
#error "1003D4D8: positive sp value has been found (funcsize=0)"

//----- (1003D4DE) --------------------------------------------------------
#error "1003D4F9: positive sp value has been found (funcsize=0)"

//----- (1003D4FA) --------------------------------------------------------
#error "1003D509: positive sp value has been found (funcsize=0)"

//----- (1003D50A) --------------------------------------------------------
#error "1003D51D: positive sp value has been found (funcsize=0)"

//----- (1003D51E) --------------------------------------------------------
#error "1003D52D: positive sp value has been found (funcsize=0)"

//----- (1003D52E) --------------------------------------------------------
#error "1003D54D: positive sp value has been found (funcsize=0)"

//----- (1003D553) --------------------------------------------------------
#error "1003D56C: positive sp value has been found (funcsize=0)"

//----- (1003D572) --------------------------------------------------------
#error "1003D591: positive sp value has been found (funcsize=0)"

//----- (1003D592) --------------------------------------------------------
#error "1003D5A5: positive sp value has been found (funcsize=0)"

//----- (1003D5A6) --------------------------------------------------------
#error "1003D5BD: positive sp value has been found (funcsize=0)"

//----- (1003D5BE) --------------------------------------------------------
#error "1003D5D1: positive sp value has been found (funcsize=0)"

//----- (1003D5D2) --------------------------------------------------------
#error "1003D5F1: positive sp value has been found (funcsize=0)"

//----- (1003D5F7) --------------------------------------------------------
#error "1003D610: positive sp value has been found (funcsize=0)"

//----- (1003D616) --------------------------------------------------------
#error "1003D635: positive sp value has been found (funcsize=0)"

//----- (1003D636) --------------------------------------------------------
#error "1003D649: positive sp value has been found (funcsize=0)"

//----- (1003D64A) --------------------------------------------------------
#error "1003D661: positive sp value has been found (funcsize=0)"

//----- (1003D662) --------------------------------------------------------
#error "1003D675: positive sp value has been found (funcsize=0)"

//----- (1003D676) --------------------------------------------------------
#error "1003D695: positive sp value has been found (funcsize=0)"

//----- (1003D69B) --------------------------------------------------------
#error "1003D6B4: positive sp value has been found (funcsize=0)"

//----- (1003D6BA) --------------------------------------------------------
#error "1003D6D9: positive sp value has been found (funcsize=0)"

//----- (1003D6DA) --------------------------------------------------------
#error "1003D6ED: positive sp value has been found (funcsize=0)"

//----- (1003D6EE) --------------------------------------------------------
#error "1003D705: positive sp value has been found (funcsize=0)"

//----- (1003D706) --------------------------------------------------------
#error "1003D719: positive sp value has been found (funcsize=0)"

//----- (1003D71A) --------------------------------------------------------
#error "1003D739: positive sp value has been found (funcsize=0)"

//----- (1003D73F) --------------------------------------------------------
#error "1003D758: positive sp value has been found (funcsize=0)"

//----- (1003D75E) --------------------------------------------------------
#error "1003D77D: positive sp value has been found (funcsize=0)"

//----- (1003D77E) --------------------------------------------------------
#error "1003D791: positive sp value has been found (funcsize=0)"

//----- (1003D792) --------------------------------------------------------
#error "1003D7A9: positive sp value has been found (funcsize=0)"

//----- (1003D7AA) --------------------------------------------------------
#error "1003D7BD: positive sp value has been found (funcsize=0)"

//----- (1003D7BE) --------------------------------------------------------
#error "1003D7DD: positive sp value has been found (funcsize=0)"

//----- (1003D7E3) --------------------------------------------------------
#error "1003D7FC: positive sp value has been found (funcsize=0)"

//----- (1003D802) --------------------------------------------------------
#error "1003D821: positive sp value has been found (funcsize=0)"

//----- (1003D822) --------------------------------------------------------
#error "1003D835: positive sp value has been found (funcsize=0)"

//----- (1003D836) --------------------------------------------------------
#error "1003D84D: positive sp value has been found (funcsize=0)"

//----- (1003D84E) --------------------------------------------------------
#error "1003D861: positive sp value has been found (funcsize=0)"

//----- (1003D862) --------------------------------------------------------
#error "1003D881: positive sp value has been found (funcsize=0)"

//----- (1003D887) --------------------------------------------------------
#error "1003D8A0: positive sp value has been found (funcsize=0)"

//----- (1003D8A6) --------------------------------------------------------
#error "1003D8C5: positive sp value has been found (funcsize=0)"

//----- (1003D8C6) --------------------------------------------------------
#error "1003D8D9: positive sp value has been found (funcsize=0)"

//----- (1003D8DA) --------------------------------------------------------
#error "1003D8F1: positive sp value has been found (funcsize=0)"

//----- (1003D8F2) --------------------------------------------------------
#error "1003D905: positive sp value has been found (funcsize=0)"

//----- (1003E18B) --------------------------------------------------------
int sub_1003E18B()
{
  dword_1020E978 = _get_sse2_info();
  return 0;
}
// 1003E12B: using guessed type int _get_sse2_info(void);
// 1020E978: using guessed type int dword_1020E978;

//----- (1003E198) --------------------------------------------------------
void sub_1003E198()
{
  dword_1020E844 = 0;
}
// 1020E844: using guessed type int dword_1020E844;

//----- (1003EC2C) --------------------------------------------------------
DWORD __cdecl sub_1003EC2C(int a1, int a2, int a3, DWORD dwMoveMethod)
{
  void *v4; // eax@1
  DWORD v6; // eax@5
  _BYTE *v7; // eax@7
  DWORD lDistanceToMove; // [sp+8h] [bp-8h]@4
  LONG DistanceToMoveHigh; // [sp+Ch] [bp-4h]@1

  DistanceToMoveHigh = a3;
  v4 = (void *)sub_10042CB8(a1);
  if ( v4 == (void *)-1 )
  {
    *_errno() = 9;
    return -1;
  }
  lDistanceToMove = SetFilePointer(v4, a2, &DistanceToMoveHigh, dwMoveMethod);
  if ( lDistanceToMove == -1 )
  {
    v6 = GetLastError();
    if ( v6 )
    {
      _dosmaperr(v6);
      return -1;
    }
  }
  v7 = (_BYTE *)(dword_1020E860[a1 >> 5] + ((a1 & 0x1F) << 6) + 4);
  *v7 &= 0xFDu;
  return lDistanceToMove;
}
// 100350AB: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 1020E860: using guessed type int dword_1020E860[];

//----- (1003EDC8) --------------------------------------------------------
_WORD *__cdecl sub_1003EDC8(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // esi@5
  int v5; // edi@5
  int v6; // eax@5
  char v7; // bl@5
  int v8; // eax@13
  void *v9; // ST18_4@13
  DWORD v10; // eax@16
  const char *v11; // ebx@16
  char v12; // cl@19
  int *v13; // esi@19
  int v14; // eax@19
  int v15; // eax@20
  int v16; // eax@27
  signed int v17; // esi@27
  int v18; // eax@31
  int v19; // esi@36
  __int16 v20; // ax@39
  int v21; // ecx@45
  char v22; // dl@45
  int v23; // eax@46
  DWORD v24; // ecx@51
  char *v25; // eax@51
  char *v26; // edx@53
  char v27; // dl@53
  int v28; // ebx@56
  DWORD v29; // ecx@64
  char *v30; // eax@64
  __int16 *v31; // edx@66
  __int16 v32; // dx@66
  int v33; // ebx@69
  DWORD v34; // ecx@74
  WCHAR *v35; // eax@74
  WCHAR v36; // dx@76
  int v37; // esi@79
  int v38; // ebx@79
  DWORD Mode; // [sp+4h] [bp-7Ch]@13
  int v40; // [sp+8h] [bp-78h]@13
  char v41; // [sp+Fh] [bp-71h]@5
  int *v42; // [sp+10h] [bp-70h]@5
  DWORD v43; // [sp+14h] [bp-6Ch]@56
  int v44; // [sp+18h] [bp-68h]@1
  LPCVOID lpBuffer; // [sp+1Ch] [bp-64h]@1
  _WORD *v46; // [sp+20h] [bp-60h]@1
  DWORD NumberOfBytesWritten; // [sp+24h] [bp-5Ch]@16
  WCHAR WideCharStr[2]; // [sp+28h] [bp-58h]@20
  _WORD *v49; // [sp+2Ch] [bp-54h]@17
  char Buffer; // [sp+30h] [bp-50h]@51
  CHAR v51[688]; // [sp+184h] [bp+104h]@79
  WCHAR v52; // [sp+434h] [bp+3B4h]@74
  CHAR MultiByteStr; // [sp+588h] [bp+508h]@20
  char v54; // [sp+589h] [bp+509h]@20

  lpBuffer = (LPCVOID)a2;
  v46 = 0;
  v44 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a2 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  v4 = &dword_1020E860[a1 >> 5];
  v5 = (a1 & 0x1F) << 6;
  v6 = v5 + *v4;
  v7 = (char)(2 * *(_BYTE *)(v6 + 36)) >> 1;
  v42 = &dword_1020E860[a1 >> 5];
  v41 = v7;
  if ( (v7 == 2 || v7 == 1) && !(~(_BYTE)nNumberOfBytesToWrite & 1) )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  if ( *(_BYTE *)(v6 + 4) & 0x20 )
    sub_1003EC2C(a1, 0, 0, 2u);
  if ( sub_1003F50A(a1) )
  {
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x80 )
    {
      v8 = _getptd();
      v9 = *(void **)(v5 + *v4);
      v40 = *(_DWORD *)(*(_DWORD *)(v8 + 108) + 20) == 0;
      if ( GetConsoleMode(v9, &Mode) )
      {
        if ( !v40 || v7 )
        {
          v10 = GetConsoleCP();
          v11 = (const char *)lpBuffer;
          Mode = v10;
          NumberOfBytesWritten = 0;
          if ( nNumberOfBytesToWrite )
          {
            v49 = 0;
            while ( 1 )
            {
              if ( v41 )
              {
                if ( v41 == 1 || v41 == 2 )
                {
                  v19 = *(_WORD *)v11;
                  v11 += 2;
                  ++v49;
                  *(_DWORD *)WideCharStr = v19;
                  v40 = (_WORD)v19 == 10;
                }
                if ( v41 == 1 || v41 == 2 )
                {
                  v20 = _putwch_nolock(WideCharStr[0]);
                  if ( v20 != WideCharStr[0] )
                    goto LABEL_89;
                  v46 = (_WORD *)((char *)v46 + 1);
                  if ( v40 )
                  {
                    *(_DWORD *)WideCharStr = 13;
                    if ( (unsigned __int16)_putwch_nolock(13) != 13 )
                      goto LABEL_89;
                    v46 = (_WORD *)((char *)v46 + 1);
                    ++v44;
                  }
                }
                goto LABEL_43;
              }
              v12 = *v11;
              v13 = v42;
              v40 = *v11 == 10;
              v14 = v5 + *v42;
              if ( *(_DWORD *)(v14 + 56) )
              {
                MultiByteStr = *(_BYTE *)(v14 + 52);
                v54 = v12;
                *(_DWORD *)(v14 + 56) = 0;
                v15 = mbtowc(WideCharStr, &MultiByteStr, 2u);
              }
              else
              {
                if ( isleadbyte(v12) )
                {
                  if ( nNumberOfBytesToWrite + (_BYTE *)lpBuffer - v11 <= 1 )
                  {
                    v21 = *v13;
                    v22 = *v11;
                    v46 = (_WORD *)((char *)v46 + 1);
                    *(_BYTE *)(v5 + v21 + 52) = v22;
                    *(_DWORD *)(v5 + *v13 + 56) = 1;
                    goto LABEL_90;
                  }
                  if ( mbtowc(WideCharStr, v11, 2u) == -1 )
                    goto LABEL_90;
                  ++v11;
                  v49 = (_WORD *)((char *)v49 + 1);
                  goto LABEL_27;
                }
                v15 = mbtowc(WideCharStr, v11, 1u);
              }
              if ( v15 == -1 )
                goto LABEL_90;
LABEL_27:
              ++v11;
              v49 = (_WORD *)((char *)v49 + 1);
              v16 = WideCharToMultiByte(Mode, 0, WideCharStr, 1, &MultiByteStr, 5, 0, 0);
              v17 = v16;
              if ( !v16 )
                goto LABEL_90;
              if ( !WriteFile(*(HANDLE *)(v5 + *v42), &MultiByteStr, v16, &NumberOfBytesWritten, 0) )
                goto LABEL_89;
              v46 = (_WORD *)((char *)v49 + v44);
              if ( (signed int)NumberOfBytesWritten < v17 )
                goto LABEL_90;
              if ( v40 )
              {
                v18 = *v42;
                MultiByteStr = 13;
                if ( !WriteFile(*(HANDLE *)(v5 + v18), &MultiByteStr, 1u, &NumberOfBytesWritten, 0) )
                  goto LABEL_89;
                if ( (signed int)NumberOfBytesWritten < 1 )
                  goto LABEL_90;
                ++v44;
                v46 = (_WORD *)((char *)v46 + 1);
              }
LABEL_43:
              if ( (unsigned int)v49 >= nNumberOfBytesToWrite )
                goto LABEL_90;
            }
          }
          goto LABEL_91;
        }
      }
    }
  }
  v23 = v5 + *v4;
  if ( *(_BYTE *)(v23 + 4) & 0x80 )
  {
    *(_DWORD *)WideCharStr = 0;
    if ( v7 )
    {
      v49 = lpBuffer;
      if ( v7 == 2 )
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v29 = (char *)v49 - (_BYTE *)lpBuffer;
          v30 = &Buffer;
          do
          {
            if ( v29 >= nNumberOfBytesToWrite )
              break;
            v31 = v49;
            ++v49;
            v32 = *v31;
            v29 += 2;
            if ( v32 == 10 )
            {
              v44 += 2;
              *(_WORD *)v30 = 13;
              v30 += 2;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *(_WORD *)v30 = v32;
            v30 += 2;
          }
          while ( NumberOfBytesWritten < 0x3FF );
          v33 = v30 - &Buffer;
          if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v30 - &Buffer, &v43, 0) )
            break;
          v46 = (_WORD *)((char *)v46 + v43);
          if ( (signed int)v43 < v33 || (char *)v49 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
            goto LABEL_90;
          v4 = v42;
        }
      }
      else
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v34 = (char *)v49 - (_BYTE *)lpBuffer;
          v35 = &v52;
          do
          {
            if ( v34 >= nNumberOfBytesToWrite )
              break;
            v36 = *v49;
            ++v49;
            v34 += 2;
            if ( v36 == 10 )
            {
              *v35 = 13;
              ++v35;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *v35 = v36;
            ++v35;
          }
          while ( NumberOfBytesWritten < 0x152 );
          v37 = 0;
          v38 = WideCharToMultiByte(0xFDE9u, 0, &v52, v35 - &v52, v51, 683, 0, 0);
          if ( !v38 )
            break;
          while ( WriteFile(*(HANDLE *)(v5 + *v42), &v51[v37], v38 - v37, &v43, 0) )
          {
            v37 += v43;
            if ( v38 <= v37 )
              goto LABEL_84;
          }
          *(_DWORD *)WideCharStr = GetLastError();
LABEL_84:
          if ( v38 <= v37 )
          {
            v46 = (_WORD *)((char *)v49 - (_BYTE *)lpBuffer);
            if ( (char *)v49 - (_BYTE *)lpBuffer < nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_90;
        }
      }
    }
    else
    {
      NumberOfBytesWritten = (DWORD)lpBuffer;
      if ( nNumberOfBytesToWrite <= 0 )
        goto LABEL_96;
      while ( 1 )
      {
        v49 = 0;
        v24 = NumberOfBytesWritten - (_DWORD)lpBuffer;
        v25 = &Buffer;
        do
        {
          if ( v24 >= nNumberOfBytesToWrite )
            break;
          v26 = (char *)NumberOfBytesWritten++;
          v27 = *v26;
          ++v24;
          if ( v27 == 10 )
          {
            ++v44;
            *v25++ = 13;
            v49 = (_WORD *)((char *)v49 + 1);
          }
          *v25++ = v27;
          v49 = (_WORD *)((char *)v49 + 1);
        }
        while ( (unsigned int)v49 < 0x400 );
        v28 = v25 - &Buffer;
        if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v25 - &Buffer, &v43, 0) )
          break;
        v46 = (_WORD *)((char *)v46 + v43);
        if ( (signed int)v43 < v28 || NumberOfBytesWritten - (unsigned int)lpBuffer >= nNumberOfBytesToWrite )
          goto LABEL_90;
        v4 = v42;
      }
    }
  }
  else if ( WriteFile(*(HANDLE *)v23, lpBuffer, nNumberOfBytesToWrite, &v43, 0) )
  {
    *(_DWORD *)WideCharStr = 0;
    v46 = (_WORD *)v43;
    goto LABEL_90;
  }
LABEL_89:
  *(_DWORD *)WideCharStr = GetLastError();
LABEL_90:
  if ( !v46 )
  {
LABEL_91:
    if ( *(_DWORD *)WideCharStr )
    {
      if ( *(_DWORD *)WideCharStr == 5 )
      {
        *_errno() = 9;
        *__doserrno() = 5;
      }
      else
      {
        _dosmaperr(*(_DWORD *)WideCharStr);
      }
      return (_WORD *)-1;
    }
    v4 = v42;
LABEL_96:
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x40 && *(_BYTE *)lpBuffer == 26 )
      return 0;
    *_errno() = 28;
    *__doserrno() = 0;
    return (_WORD *)-1;
  }
  return (_WORD *)((char *)v46 - v44);
}
// 100350AB: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 10036265: using guessed type int _getptd(void);
// 1003788A: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1020E860: using guessed type int dword_1020E860[];
// 1003EDC8: using guessed type CHAR var_410[688];

//----- (1003F3EA) --------------------------------------------------------
_WORD *__cdecl sub_1003F3EA(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // ebx@7
  int v5; // esi@7
  _WORD *v6; // [sp+14h] [bp-1Ch]@9

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return (_WORD *)-1;
  }
  if ( a1 < 0
    || a1 >= uNumber
    || (v4 = &dword_1020E860[a1 >> 5], v5 = (a1 & 0x1F) << 6, !(*(_BYTE *)(*v4 + v5 + 4) & 1)) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  __lock_fhandle(a1);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    v6 = sub_1003EDC8(a1, a2, nNumberOfBytesToWrite);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    v6 = (_WORD *)-1;
  }
  sub_10042DC9(a1);
  return v6;
}
// 1003788A: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10042D29: using guessed type _DWORD __cdecl __lock_fhandle(_DWORD);
// 1020E860: using guessed type int dword_1020E860[];

//----- (1003F50A) --------------------------------------------------------
int __cdecl sub_1003F50A(signed int a1)
{
  int result; // eax@2

  if ( a1 == -2 )
  {
    *_errno() = 9;
    result = 0;
  }
  else if ( a1 >= 0 && a1 < uNumber )
  {
    result = *(_BYTE *)(dword_1020E860[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) & 0x40;
  }
  else
  {
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 0;
  }
  return result;
}
// 1003788A: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1020E860: using guessed type int dword_1020E860[];

//----- (1003F568) --------------------------------------------------------
void **sub_1003F568()
{
  return &off_100C1DE0;
}
// 100C1DE0: using guessed type void *off_100C1DE0;

//----- (1003F56E) --------------------------------------------------------
signed int sub_1003F56E()
{
  size_t v0; // eax@1
  void *v1; // eax@6
  signed int result; // eax@8
  int v3; // edx@9
  void **v4; // ecx@9
  signed int v5; // edx@12
  _DWORD *v6; // ecx@12
  int v7; // eax@13

  v0 = dword_1020E840;
  if ( !dword_1020E840 )
  {
    v0 = 512;
LABEL_5:
    dword_1020E840 = v0;
    goto LABEL_6;
  }
  if ( dword_1020E840 < 20 )
  {
    v0 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v1 = (void *)_calloc_crt(v0, 4);
  dword_1020D834 = v1;
  if ( v1 || (dword_1020E840 = 20, v1 = (void *)_calloc_crt(0x14u, 4), (dword_1020D834 = v1) != 0) )
  {
    v3 = 0;
    v4 = &off_100C1DE0;
    while ( 1 )
    {
      *(_DWORD *)((char *)v1 + v3) = v4;
      v4 += 8;
      v3 += 4;
      if ( (signed int)v4 >= (signed int)&dword_100C2060 )
        break;
      v1 = dword_1020D834;
    }
    v5 = 0;
    v6 = &unk_100C1DF0;
    do
    {
      v7 = *(_DWORD *)(((v5 & 0x1F) << 6) + dword_1020E860[v5 >> 5]);
      if ( v7 == -1 || v7 == -2 || !v7 )
        *v6 = -2;
      v6 += 8;
      ++v5;
    }
    while ( (signed int)v6 < (signed int)&unk_100C1E50 );
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 1003902D: using guessed type _DWORD __cdecl _calloc_crt(size_t, _DWORD);
// 100C1DE0: using guessed type void *off_100C1DE0;
// 100C2060: using guessed type int dword_100C2060;
// 1020E840: using guessed type int dword_1020E840;
// 1020E860: using guessed type int dword_1020E860[];

//----- (1003F8C6) --------------------------------------------------------
int __cdecl sub_1003F8C6(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_100414FF((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 1003ACDB: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003F96C) --------------------------------------------------------
int __cdecl sub_1003F96C(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_10041A41((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 1003ACDB: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10040352) --------------------------------------------------------
int sub_10040352()
{
  return _decode_pointer(dword_1020A250);
}
// 10036049: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1020A250: using guessed type int dword_1020A250;

//----- (1004050F) --------------------------------------------------------
int __cdecl sub_1004050F(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1020A25C = a1;
  return result;
}
// 1020A25C: using guessed type int dword_1020A25C;

//----- (10040519) --------------------------------------------------------
int __cdecl sub_10040519(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1020A268 = a1;
  return result;
}
// 1020A268: using guessed type int dword_1020A268;

//----- (10040523) --------------------------------------------------------
int __cdecl sub_10040523(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1020A26C = a1;
  return result;
}
// 1020A26C: using guessed type int dword_1020A26C;

//----- (10040602) --------------------------------------------------------
int __cdecl sub_10040602(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1020A270 = a1;
  return result;
}
// 1020A270: using guessed type int dword_1020A270;

//----- (100414FF) --------------------------------------------------------
signed int __cdecl sub_100414FF(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_100C2120 - 1;
    v64 = v3;
    v65 = dword_100C2120 / 32;
    v9 = dword_100C2120 % 32;
    v10 = (int *)(&v60 + dword_100C2120 / 32);
    v66 = 31 - dword_100C2120 % 32;
    if ( (1 << (31 - dword_100C2120 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_100C211C - dword_100C2120 )
    {
      if ( v3 > dword_100C211C )
      {
        if ( v3 < dword_100C2118 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_100C212C + v3;
          v50 = dword_100C2124 / 32;
          v51 = dword_100C2124 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_100C2124 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_100C2124 / 32;
          v44 = dword_100C2124 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_100C2124 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_100C212C + dword_100C2118;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_100C211C - v64) / 32;
      v62 = v59;
      v18 = (dword_100C211C - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_100C2120 - 1;
      v25 = dword_100C2120 / 32;
      v65 = dword_100C2120 / 32;
      v26 = (int *)(&v60 + dword_100C2120 / 32);
      v64 = 31 - dword_100C2120 % 32;
      if ( (1 << (31 - dword_100C2120 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_100C2120 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_100C2124 + 1) / 32;
      v37 = (dword_100C2124 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_100C2124));
  if ( dword_100C2128 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_100C2128 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 100C2118: using guessed type int dword_100C2118;
// 100C211C: using guessed type int dword_100C211C;
// 100C2120: using guessed type int dword_100C2120;
// 100C2124: using guessed type int dword_100C2124;
// 100C2128: using guessed type int dword_100C2128;
// 100C212C: using guessed type int dword_100C212C;

//----- (10041A41) --------------------------------------------------------
signed int __cdecl sub_10041A41(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_100C2138 - 1;
    v64 = v3;
    v65 = dword_100C2138 / 32;
    v9 = dword_100C2138 % 32;
    v10 = (int *)(&v60 + dword_100C2138 / 32);
    v66 = 31 - dword_100C2138 % 32;
    if ( (1 << (31 - dword_100C2138 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_100C2134 - dword_100C2138 )
    {
      if ( v3 > dword_100C2134 )
      {
        if ( v3 < dword_100C2130 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_100C2144 + v3;
          v50 = dword_100C213C / 32;
          v51 = dword_100C213C % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_100C213C % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_100C213C / 32;
          v44 = dword_100C213C % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_100C213C % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_100C2144 + dword_100C2130;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_100C2134 - v64) / 32;
      v62 = v59;
      v18 = (dword_100C2134 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_100C2138 - 1;
      v25 = dword_100C2138 / 32;
      v65 = dword_100C2138 / 32;
      v26 = (int *)(&v60 + dword_100C2138 / 32);
      v64 = 31 - dword_100C2138 % 32;
      if ( (1 << (31 - dword_100C2138 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_100C2138 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_100C213C + 1) / 32;
      v37 = (dword_100C213C + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_100C213C));
  if ( dword_100C2140 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_100C2140 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 100C2130: using guessed type int dword_100C2130;
// 100C2134: using guessed type int dword_100C2134;
// 100C2138: using guessed type int dword_100C2138;
// 100C213C: using guessed type int dword_100C213C;
// 100C2140: using guessed type int dword_100C2140;
// 100C2144: using guessed type int dword_100C2144;

//----- (10042279) --------------------------------------------------------
int sub_10042279()
{
  return 0;
}

//----- (10042C37) --------------------------------------------------------
signed int __cdecl sub_10042C37(signed int a1)
{
  int *v1; // edi@3
  int v2; // esi@3
  int v3; // eax@3
  DWORD v5; // [sp-8h] [bp-14h]@9

  if ( a1 >= 0 && a1 < uNumber )
  {
    v1 = &dword_1020E860[a1 >> 5];
    v2 = (a1 & 0x1F) << 6;
    v3 = v2 + *v1;
    if ( *(_BYTE *)(v3 + 4) & 1 )
    {
      if ( *(_DWORD *)v3 != -1 )
      {
        if ( dword_102098E0 == 1 )
        {
          if ( !a1 )
          {
            v5 = -10;
            goto LABEL_12;
          }
          if ( a1 == 1 )
          {
            v5 = -11;
            goto LABEL_12;
          }
          if ( a1 == 2 )
          {
            v5 = -12;
LABEL_12:
            SetStdHandle(v5, 0);
            goto LABEL_13;
          }
        }
LABEL_13:
        *(_DWORD *)(v2 + *v1) = -1;
        return 0;
      }
    }
  }
  *_errno() = 9;
  *__doserrno() = 0;
  return -1;
}
// 102098E0: using guessed type int dword_102098E0;
// 1020E860: using guessed type int dword_1020E860[];

//----- (10042CB8) --------------------------------------------------------
signed int __cdecl sub_10042CB8(signed int a1)
{
  signed int result; // eax@2
  int v2; // eax@5

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    result = -1;
  }
  else if ( a1 >= 0 && a1 < uNumber && (v2 = dword_1020E860[a1 >> 5] + ((a1 & 0x1F) << 6), *(_BYTE *)(v2 + 4) & 1) )
  {
    result = *(_DWORD *)v2;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  return result;
}
// 1003788A: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1020E860: using guessed type int dword_1020E860[];

//----- (10042DC9) --------------------------------------------------------
void __cdecl sub_10042DC9(signed int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(dword_1020E860[a1 >> 5] + ((a1 & 0x1F) << 6) + 12));
}
// 1020E860: using guessed type int dword_1020E860[];

//----- (100430CA) --------------------------------------------------------
int sub_100430CA()
{
  return flsall(1);
}
// 10042FF0: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (10043DCA) --------------------------------------------------------
int __cdecl sub_10043DCA(int a1, int a2, int a3)
{
  HMODULE v3; // eax@2
  HMODULE v4; // edi@2
  FARPROC v5; // eax@3
  FARPROC v6; // eax@4
  FARPROC v7; // eax@4
  FARPROC v8; // eax@7
  FARPROC v9; // eax@8
  int (*v10)(void); // esi@11
  int (__stdcall *v11)(int, signed int, char *, signed int, char *); // eax@11
  int (__stdcall *v12)(int, signed int, char *, signed int, char *); // edi@11
  int v13; // eax@13
  int (*v14)(void); // eax@22
  int (__stdcall *v15)(int); // eax@25
  int (__stdcall *v16)(int, int, int, int); // eax@27
  char v18; // [sp+10h] [bp-20h]@14
  char v19; // [sp+18h] [bp-18h]@15
  char v20; // [sp+1Ch] [bp-14h]@14
  unsigned int v21; // [sp+20h] [bp-10h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+28h] [bp-8h]@1
  int v24; // [sp+2Ch] [bp-4h]@1

  v23 = _encoded_null();
  v24 = 0;
  v22 = 0;
  v21 = 0;
  if ( !dword_1020A340 )
  {
    v3 = LoadLibraryA("USER32.DLL");
    v4 = v3;
    if ( !v3 )
      return 0;
    v5 = GetProcAddress(v3, "MessageBoxA");
    if ( !v5 )
      return 0;
    dword_1020A340 = _encode_pointer(v5);
    v6 = GetProcAddress(v4, "GetActiveWindow");
    dword_1020A344 = _encode_pointer(v6);
    v7 = GetProcAddress(v4, "GetLastActivePopup");
    dword_1020A348 = _encode_pointer(v7);
    if ( sub_10038D0C(&v22) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v22 == 2 )
    {
      v8 = GetProcAddress(v4, "GetUserObjectInformationA");
      dword_1020A350 = _encode_pointer(v8);
      if ( dword_1020A350 )
      {
        v9 = GetProcAddress(v4, "GetProcessWindowStation");
        dword_1020A34C = _encode_pointer(v9);
      }
    }
  }
  if ( dword_1020A34C == v23
    || dword_1020A350 == v23
    || (v10 = (int (*)(void))_decode_pointer(dword_1020A34C),
        v11 = (int (__stdcall *)(int, signed int, char *, signed int, char *))_decode_pointer(dword_1020A350),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, &v18, 12, &v20) && v19 & 1 )
  {
    if ( dword_1020A344 != v23 )
    {
      v14 = (int (*)(void))_decode_pointer(dword_1020A344);
      if ( v14 )
      {
        v24 = v14();
        if ( v24 )
        {
          if ( dword_1020A348 != v23 )
          {
            v15 = (int (__stdcall *)(int))_decode_pointer(dword_1020A348);
            if ( v15 )
              v24 = v15(v24);
          }
        }
      }
    }
  }
  else
  {
    if ( sub_10038D43(&v21) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v21 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_1020A340);
  if ( v16 )
    return v16(v24, a1, a2, a3);
  return 0;
}
// 10035FD2: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 10036040: using guessed type int _encoded_null(void);
// 10036049: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1003778E: using guessed type int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1020A340: using guessed type int dword_1020A340;
// 1020A344: using guessed type int dword_1020A344;
// 1020A348: using guessed type int dword_1020A348;
// 1020A34C: using guessed type int dword_1020A34C;
// 1020A350: using guessed type int dword_1020A350;

//----- (1004451C) --------------------------------------------------------
signed int __cdecl sub_1004451C(signed int a1)
{
  signed int v1; // edi@6
  void *v2; // eax@7
  DWORD v3; // edi@8
  signed int result; // eax@11

  if ( sub_10042CB8(a1) == -1
    || (a1 == 1 && *(_BYTE *)(dword_1020E860[0] + 132) & 1 || a1 == 2 && *(_BYTE *)(dword_1020E860[0] + 68) & 1)
    && (v1 = sub_10042CB8(2), sub_10042CB8(1) == v1)
    || (v2 = (void *)sub_10042CB8(a1), CloseHandle(v2)) )
  {
    v3 = 0;
  }
  else
  {
    v3 = GetLastError();
  }
  sub_10042C37(a1);
  *(_BYTE *)(dword_1020E860[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) = 0;
  if ( v3 )
  {
    _dosmaperr(v3);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100350AB: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 1020E860: using guessed type int dword_1020E860[];

#error "There were 48 decompilation failure(s) on 1036 function(s)"
