/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

_DWORD sub_10001000(); // weak
// char __usercall sub_10001030@<al>(void *a1@<esi>);
// char __usercall sub_10001070@<al>(float *a1@<esi>);
char __cdecl sub_10001090(float *a1);
char __cdecl sub_100010F0(float *a1);
char __cdecl sub_10001150(float *a1);
// char __usercall sub_100011B0@<al>(int a1@<esi>);
char __cdecl sub_10001250(float *a1);
char __cdecl sub_100012A0(float *a1);
char __cdecl sub_100012F0(float *a1);
char __cdecl sub_10001350(float *a1);
// char __usercall sub_100013B0@<al>(float *a1@<esi>, char a2);
char __cdecl sub_100014A0(float a1, int a2);
// char __usercall sub_10001510@<al>(float *a1@<esi>);
char __cdecl sub_10001590(float *a1);
char __cdecl sub_100015F0(float *a1);
char __cdecl sub_10001680(float *a1);
// char __usercall sub_10001710@<al>(float *a1@<esi>);
// char __usercall sub_10001AB0@<al>(float *a1@<esi>);
// char __usercall sub_10001B20@<al>(float *a1@<esi>);
// char __usercall sub_10001B40@<al>(float *a1@<esi>);
// void __usercall sub_10001BD0(float *a1@<esi>);
char __cdecl sub_10001C60(float *a1);
// char __usercall sub_10001D80@<al>(float *a1@<esi>, float a2);
// char __usercall sub_10001F80@<al>(float *a1@<esi>, float a2);
// char __usercall sub_10002010@<al>(float *a1@<eax>);
// char __usercall sub_10002020@<al>(float *a1@<eax>);
// char __usercall sub_10002030@<al>(float *a1@<eax>);
// char __usercall sub_10002040@<al>(float *a1@<eax>);
// int __usercall sub_10002050@<eax>(char a1@<dl>, int a2@<ecx>, float *a3);
// char __usercall sub_10002080@<al>(float *a1@<esi>);
// char __usercall sub_10002120@<al>(float *a1@<esi>);
char __cdecl sub_10002200(float *a1);
// char __usercall sub_10002250@<al>(float *a1@<esi>);
// char __usercall sub_10002330@<al>(float *a1@<esi>);
// char __usercall sub_10002410@<al>(float *a1@<esi>);
// char __usercall sub_100024B0@<al>(float *a1@<esi>);
// char __usercall sub_10002550@<al>(float *a1@<esi>);
// char __usercall sub_100025F0@<al>(float *a1@<esi>);
char __cdecl sub_100026D0(float *a1);
bool __cdecl sub_10002770(float *a1);
// char __usercall sub_10002820@<al>(float *a1@<esi>);
// char __usercall sub_100028A0@<al>(float *a1@<esi>);
// char __usercall sub_10002930@<al>(float *a1@<esi>);
int __cdecl sub_100029A0(float *a1);
int __cdecl sub_10002BD0(float *a1);
int __cdecl sub_10002E00(float *a1);
int __cdecl sub_10003030(float *a1);
// char __usercall sub_10003260@<al>(float *a1@<esi>);
// char __usercall sub_100032F0@<al>(float *a1@<esi>);
bool __cdecl sub_10003360(float *a1);
char __cdecl sub_100033C0(float a1, void *a2);
char __cdecl sub_10003C70(int a1, float *a2);
// char __usercall sub_10003CD0@<al>(unsigned __int16 a1@<ax>, int a2@<esi>, float a3, char a4, char a5);
// double __usercall sub_10003DE0@<st0>(int a1@<eax>, _BYTE *a2@<ebx>, int a3, float a4);
unsigned __int8 __cdecl sub_10003EE0(int a1, int a2, char a3, void *a4);
char __cdecl sub_10004070(int a1, void *a2);
_WORD *__cdecl sub_100040D0(int a1, int a2, int a3, _WORD *a4);
int __fastcall sub_100042A0(int a1, int a2);
int __cdecl sub_10004450(int a1);
int __cdecl sub_10004490(int a1, int a2, unsigned __int16 a3);
signed int sub_10004530();
char sub_10004580();
// int __usercall sub_10004610@<eax>(unsigned __int16 a1@<di>);
int __cdecl sub_10004650(unsigned __int16 a1);
int __cdecl sub_10004680(char, int, __int16, __int16, void *); // idb
int sub_10004690();
int sub_100046A0();
char __cdecl sub_100046B0(unsigned __int8 a1);
int sub_10004740();
int sub_100047A0();
char __cdecl sub_100048B0(int a1, void *a2);
int __cdecl sub_10004A10(unsigned __int16 a1);
// int (*__usercall sub_10004A50@<eax>(int (*result)(void)@<eax>, _BYTE *a2@<edx>, int a3@<esi>, float a4))(void);
char __cdecl sub_10004AA0(int a1, int a2, unsigned __int8 a3);
int __cdecl sub_10004C60(char a1);
signed int sub_10004C80();
// signed int __usercall sub_10004CD0@<eax>(char a1@<al>, int a2@<ecx>);
// int __usercall sub_10004D70@<eax>(char a1@<al>);
// int __usercall sub_10004D90@<eax>(char a1@<al>);
// signed __int16 __usercall sub_10004DB0@<ax>(char a1@<al>, unsigned __int16 a2@<si>);
char __cdecl sub_10004FF0(char a1, unsigned __int16 a2, _BYTE *a3);
char __cdecl sub_10005150(char a1, unsigned __int16 a2, void *a3);
char __cdecl sub_100052D0(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_10005430(int a1, int a2, void *a3, char a4, __int16 a5, char a6);
char __cdecl sub_10005570(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_10005650(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6);
char __cdecl sub_100058D0(char a1, int a2, __int16 a3, __int16 a4, void *a5);
char __cdecl sub_10005900(char a1, int a2, void *a3);
char __cdecl sub_10005930(char a1, int a2, void *a3, int a4);
int __cdecl sub_10005960(char a1);
signed int sub_100059B0();
// void *__usercall sub_100059C0@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>);
signed int sub_10005A10();
int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD); // weak
int sub_10007820();
char __cdecl sub_10007850(void *a1);
char __cdecl sub_100078B0(void *a1);
char __cdecl sub_10007910(float *a1);
char __cdecl sub_10007940(float *a1);
char __cdecl sub_100079E0(float a1, int a2);
double sub_10007A80();
double sub_10007AB0();
// void __usercall sub_10007AE0(int a1@<esi>, int a2, float a3);
// char __usercall sub_10007C40@<al>(float *a1@<edi>, unsigned __int16 a2@<si>, unsigned __int8 a3);
// char __usercall sub_10007D30@<al>(unsigned __int16 *a1@<eax>, int a2, float *a3, unsigned __int8 a4);
char __cdecl sub_10008010(float *a1);
char __cdecl sub_10008080(float *a1);
char __cdecl sub_100080A0(float *a1);
char __cdecl sub_100080C0(float *a1);
char __cdecl sub_10008150(float *a1);
char __cdecl sub_100081C0(float *a1);
char __cdecl sub_10008290(float *a1);
char __cdecl sub_10008360(float *a1);
char __cdecl sub_10008430(float *a1);
char __cdecl sub_100084D0(float *a1);
double sub_10008540();
char __cdecl sub_100085A0(float *a1);
void sub_10008640();
signed int sub_10008650();
bool __cdecl sub_10008660(float *a1);
int __cdecl sub_100086C0(char, float, int, int, int); // idb
double sub_10008D10();
double __cdecl sub_10008D40(int a1, float a2, float a3);
char __cdecl sub_10008D80(float *a1, float *a2, float *a3, char a4);
char *__cdecl sub_10009310(int a1, char *a2, int a3, char *a4, int a5);
char sub_10009440();
char __cdecl sub_10009450(char *a1, int a2, char a3, char *a4, int a5);
char __cdecl sub_10009550(char *a1, int a2, char a3, char *a4);
int __cdecl sub_100095C0(int a1, _WORD *a2, int a3);
char __cdecl sub_10009630(int a1, int a2, int a3, unsigned __int16 a4);
int __cdecl sub_10009840(int *a1);
// char __usercall sub_10009870@<al>(int a1@<eax>, int a2@<ecx>);
int __cdecl sub_10009910(const char *a1);
char __cdecl sub_10009950(void *a1);
signed int __cdecl sub_100099A0(unsigned int a1, int a2);
char **sub_10009D40();
int sub_10009D50(void); // weak
int __cdecl sub_10009D80(void *, void *, size_t, int, int); // idb
double sub_10009E30(void); // weak
char __thiscall sub_10009E50(void *this);
char __fastcall sub_10009E80(int a1);
char __cdecl sub_10009ED0(int a1);
int __cdecl sub_10009EF0(int, char *); // idb
char __thiscall sub_10009F50(void *this);
char __thiscall sub_10009F70(void *this);
char __thiscall sub_10009F90(void *this);
char __thiscall sub_10009FB0(void *this);
double __cdecl sub_10009FD0(float a1, float a2, int a3, float a4);
char __cdecl sub_1000A0B0(int a1, int a2);
int __cdecl sub_1000A1D0(char a1);
int __cdecl sub_1000A1F0(int, void *); // idb
// int __usercall sub_1000A250@<eax>(char a1@<al>);
BOOL __cdecl sub_1000A280(char a1, int a2);
int __cdecl sub_1000A2B0(int, char, int, int, void *); // idb
char __cdecl sub_1000A2E0(void *a1);
BOOL __cdecl sub_1000A300(int a1);
char __cdecl sub_1000A320(int a1, char a2, int a3, int a4, void *a5);
bool __cdecl sub_1000A350(unsigned __int8 a1, char a2, unsigned int a3);
bool __cdecl sub_1000A3E0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6);
bool __cdecl sub_1000A480(char a1, void *a2);
// signed int __usercall sub_1000A4C0@<eax>(char a1@<al>);
bool __cdecl sub_1000A4E0(char a1, void *a2);
bool __cdecl sub_1000A5D0(char a1, char a2, int a3, int a4, void *a5);
BOOL __cdecl sub_1000A600(unsigned __int8 a1);
// BOOL __usercall sub_1000A610@<eax>(unsigned __int8 a1@<al>, char a2);
bool __cdecl sub_1000A640(char a1, char a2, unsigned __int8 a3, int a4);
bool __cdecl sub_1000A7F0(unsigned __int8 a1, int a2);
bool __cdecl sub_1000A830(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6);
char sub_1000A920();
BOOL __cdecl sub_1000A9C0(int a1, int a2);
char __cdecl sub_1000A9E0(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_1000AA20(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_1000AAC0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1000AB40(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1000ABB0(char a1, void *a2);
char __cdecl sub_1000AC30(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1000ACB0(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1000AD30(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1000ADA0(char a1, char a2, char a3, unsigned __int8 *a4, int a5);
char __cdecl sub_1000AEB0(char a1, void *a2);
bool __cdecl sub_1000AED0(unsigned __int8 a1, char *a2);
char __cdecl sub_1000AF10(int a1, char a2, int a3, int a4, void *a5);
BOOL sub_1000AF50();
char __cdecl sub_1000AFB0(int a1, char *a2);
BOOL __cdecl sub_1000B0A0(int a1, int a2);
char __cdecl sub_1000B0C0(int a1, char a2, int a3, int a4, char *a5);
char __cdecl sub_1000B100(int a1, int a2);
BOOL __cdecl sub_1000B1B0(int a1, int a2);
char __cdecl sub_1000B1D0(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_1000B210(void *a1);
char __cdecl sub_1000B230(void *a1);
char __cdecl sub_1000B380(int a1, char a2, char a3, int a4, void *a5, size_t a6);
char __cdecl sub_1000B520(char a1);
// __int16 __usercall sub_1000B560@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_1000B570(unsigned __int8 a1, char *a2);
char __cdecl sub_1000B640(char a1, char a2, char a3, int a4, char *a5, unsigned int a6);
char __cdecl sub_1000B6C0(unsigned __int16 a1);
char __cdecl sub_1000B760(char a1, char a2, char a3, int a4, void *a5);
int __cdecl sub_1000B870(char a1);
char __cdecl sub_1000B8C0(char a1, int a2);
// int __usercall sub_1000BA30@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3);
// int __usercall sub_1000BA70@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3);
signed int sub_1000BAB0();
char __cdecl sub_1000BAC0(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_1000BB20(char a1, void *a2);
char __cdecl sub_1000BC40(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1000BCC0(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6);
char __cdecl sub_1000BE70(unsigned __int16 a1, char *a2, char a3);
char __cdecl sub_1000BFA0(char a1, int a2);
bool __cdecl sub_1000C020(void *a1);
char __cdecl sub_1000C070(char a1, int a2);
// __int16 __usercall sub_1000C150@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_1000C160(unsigned __int8 a1, int *a2, const void *a3);
char __cdecl sub_1000C1F0(unsigned __int8 a1, char a2);
bool __cdecl sub_1000C2B0(__int16 a1, char a2, int a3, int a4, void *a5);
char __thiscall sub_1000C3B0(void *this);
// char __usercall sub_1000C420@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4);
// void *__usercall sub_1000C460@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4);
char __cdecl sub_1000C500(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1000C540(char a1, char a2, void *a3);
char __cdecl sub_1000C5A0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1000C5E0(char a1, char a2, void *a3);
char __cdecl sub_1000C610(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1000C650(char a1, char a2, void *a3);
char __cdecl sub_1000C690(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1000C6D0(char a1, char a2, void *a3);
char __cdecl sub_1000C720(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1000C760(char a1, char a2, void *a3);
char __cdecl sub_1000C7A0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1000C7E0(char a1, char a2, void *a3);
char __cdecl sub_1000C820(char a1, void *a2);
char __cdecl sub_1000C850(char a1, void *a2);
char __cdecl sub_1000C880(char a1, void *a2);
char __cdecl sub_1000C8B0(char a1, void *a2);
char __cdecl sub_1000C8E0(char a1, void *a2);
char __cdecl sub_1000C910(char a1, void *a2);
char __cdecl sub_1000C940(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1000C980(char a1, char a2, void *a3);
char __cdecl sub_1000C9D0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1000CA10(char a1, char a2, void *a3);
char __cdecl sub_1000CA40(char a1, void *a2);
char __cdecl sub_1000CA70(char a1, void *a2);
char __cdecl sub_1000CAA0(char a1, void *a2);
char __cdecl sub_1000CAD0(int a1, char a2, char a3, int a4, void *a5);
bool __cdecl sub_1000CE70(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_1000CEE0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_1000CF40(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1000CFB0(char a1, _BYTE *a2);
char __thiscall sub_1000CFF0(void *this);
char __cdecl sub_1000D060(char a1, int a2);
char __cdecl sub_1000D090(char a1, int a2);
char __cdecl sub_1000D0C0(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6);
int __cdecl sub_1000D290(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_1000D420(int a1, _BYTE *a2, int a3);
int __cdecl sub_1000D470(void *, size_t); // idb
int __cdecl sub_1000D4A0(char *, size_t, char *, va_list); // idb
int sub_1000D4E0(char *arg0, size_t arg4, char *arg8, ...);
int __cdecl sub_1000D510(const char *a1, _BYTE *a2, int a3);
char __cdecl sub_1000D550(unsigned __int16 a1, float *a2);
double __cdecl sub_1000D670(float a1);
// char __usercall sub_1000D6D0@<al>(int a1@<esi>, unsigned __int16 a2, float *a3);
char __cdecl sub_1000DC10(unsigned __int8 a1);
signed int sub_1000DC70();
// char __usercall sub_1000DC80@<al>(unsigned __int8 a1@<al>, char a2, void *a3);
char __cdecl sub_1000DD60(int a1, char a2, void *a3);
char __cdecl sub_1000DDE0(int a1, void *a2);
int __cdecl sub_1000DE00(char a1);
unsigned int __cdecl sub_1000DE10(char *a1);
int __cdecl sub_1000DE30(unsigned __int8 *a1);
int __cdecl sub_1000DE50(_BYTE *a1);
int __cdecl sub_1000DE70(unsigned __int8 *a1);
unsigned int __cdecl sub_1000DE90(int a1, int a2);
unsigned int __cdecl sub_1000E1C0(int a1, int a2);
unsigned int __cdecl sub_1000E600(_BYTE *a1);
int __cdecl sub_1000E620(unsigned __int8 *a1);
int __cdecl sub_1000E640(unsigned __int8 *a1);
int __cdecl sub_1000E660(_BYTE *a1);
int __cdecl sub_1000E680(int a1);
// void __cdecl __noreturn exit(int);
int __cdecl sub_1000E6D0(unsigned __int8 *a1);
int __cdecl sub_1000E6F0(int a1);
unsigned int __cdecl sub_1000E780(int a1);
signed int __cdecl sub_1000E7A0(int a1);
unsigned int __cdecl sub_1000E7F0(int a1);
int __cdecl sub_1000E850(_BYTE *a1);
unsigned int __cdecl sub_1000E870(_BYTE *a1);
int __cdecl sub_1000E890(unsigned __int8 *a1);
int __cdecl sub_1000E8B0(_BYTE *a1);
signed int __cdecl sub_1000E8D0(_BYTE *a1, int a2);
int __cdecl sub_1000E900(_BYTE *a1, int a2);
int __cdecl sub_1000E940(int a1, int a2);
int __cdecl sub_1000E9D0(int a1);
int __cdecl sub_1000EA00(unsigned __int8 *a1);
unsigned int __cdecl sub_1000EA20(int a1);
int __cdecl sub_1000EA50(int a1);
int __cdecl sub_1000EB40(int a1);
signed int __cdecl sub_1000EC50(_BYTE *a1, int a2);
signed int __cdecl sub_1000EC80(unsigned __int8 *a1, int a2);
int __cdecl sub_1000ECB0(unsigned __int8 *a1);
int __cdecl sub_1000ED10(int a1);
signed int __cdecl sub_1000ED20(_BYTE *a1, int a2);
int __cdecl sub_1000ED50(int a1, int a2);
unsigned int __cdecl sub_1000EDD0(int a1);
unsigned int __cdecl sub_1000EE10(int a1);
int __cdecl sub_1000EE60(int a1);
int __cdecl sub_1000EE90(int a1);
unsigned int __cdecl sub_1000EEC0(int a1);
unsigned int __cdecl sub_1000EEF0(int a1);
unsigned int __cdecl sub_1000EF10(int a1);
void __cdecl __noreturn sub_1000EF50(int a1);
signed int __cdecl sub_1000F0C0(int a1, int a2);
// time_t __cdecl static _mkgmtime(struct tm *Tm);
// signed int __usercall sub_1000F120@<eax>(int a1@<eax>, int a2@<edi>);
signed int __cdecl sub_1000F1F0(int a1);
signed int __cdecl sub_1000F200(_BYTE *a1, char a2, int a3);
int __cdecl sub_1000F250(int, float, float, int, int); // idb
unsigned int __cdecl sub_1000F340(char *a1, char a2, char a3, char a4, int a5);
unsigned int __cdecl sub_1000F390(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5);
unsigned int __cdecl sub_1000F450(void *a1, size_t a2, int a3);
int __cdecl sub_1000F4B0(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
int __cdecl sub_1000F500(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5);
int __cdecl sub_1000F5A0(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
char __cdecl sub_1000F650(unsigned __int16 a1, _BYTE *a2, _WORD *a3);
double __cdecl sub_1000F6B0(float a1);
char __cdecl sub_1000F730(char *a1);
char *__cdecl sub_1000F760(char **a1);
int sub_1000F7B0();
int __cdecl sub_1000F7F0(_BYTE *a1, int a2);
signed int __cdecl sub_1000F860(_BYTE *a1, int a2);
// int __usercall sub_1000F900@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>);
// signed int __usercall sub_1000F930@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5);
// char *__usercall sub_1000FB00@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>);
// int __usercall sub_1000FB60@<eax>(int a1@<esi>, int a2, _DWORD *a3);
// int __usercall sub_1000FBF0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4);
// char **__usercall sub_1000FC40@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3);
// const char *__usercall sub_1000FCA0@<eax>(int a1@<eax>);
// int __usercall sub_1000FCC0@<eax>(unsigned int a1@<ebx>);
// int __usercall sub_1000FD00@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5);
// int __usercall sub_1000FD90@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4);
// int __usercall sub_1000FEE0@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>);
// int __usercall sub_1000FF80@<eax>(int result@<eax>);
char *__cdecl sub_1000FFC0(int a1, char *a2, int a3, const char *a4);
// int __usercall sub_10010170@<eax>(int a1@<eax>);
// int __usercall sub_100101A0@<eax>(int a1@<esi>);
void __cdecl sub_100101D0(int (**a1)(void), char **a2, _DWORD *a3);
int sub_10010640();
void *sub_10010690();
char *sub_100106F0();
char sub_10010710();
char __cdecl sub_10010720(int a1, int a2, unsigned int a3);
// int *__usercall sub_10010760@<eax>(_DWORD *a1@<ebx>, int a2);
char **sub_100107B0();
int __cdecl sub_100107C0(_DWORD *a1, int a2, int a3);
int __cdecl sub_10010870(int a1, int a2, int a3, const char *a4, const char *a5);
// char *__usercall sub_10010A80@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6);
char *__cdecl sub_10010B40(char a1);
int *__cdecl sub_10010BE0(_BYTE *a1);
// int __usercall sub_10010CA0@<eax>(int a1@<eax>);
// signed int __usercall sub_10010E00@<eax>(int a1@<esi>);
int __cdecl sub_10010E70(int, int); // weak
char **sub_10011150();
// int __usercall sub_10011160@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6);
int __cdecl sub_10011250(char *a1);
int sub_10011490();
int __cdecl sub_10011570(int a1, int a2, char a3);
int __cdecl sub_100115C0(int a1);
int __cdecl sub_100115D0(void *); // idb
int __cdecl sub_10011650(int a1, int a2);
signed int __cdecl sub_10011680(int a1, int a2, int a3);
char __cdecl sub_100116A0(_DWORD *a1);
char __cdecl sub_100117B0(int a1, unsigned int a2);
bool __cdecl sub_100117E0(const void **a1, int a2);
bool __cdecl sub_10011810(const void **a1, int a2);
bool __cdecl sub_10011840(const void **a1, int a2);
bool __cdecl sub_10011870(const void **a1, int a2);
bool __cdecl sub_100118A0(const void **a1, int a2);
bool __cdecl sub_100118D0(int a1, int a2);
bool __cdecl sub_10011910(int a1, int a2);
bool __cdecl sub_10011950(const void **a1, int a2);
bool __cdecl sub_10011980(const void **a1, int a2);
char __cdecl sub_100119B0(int a1, unsigned int a2);
bool __cdecl sub_100119E0(const void **a1, int a2);
bool __cdecl sub_10011A10(const void **a1, int a2);
bool __cdecl sub_10011A40(const void **a1, int a2);
bool __cdecl sub_10011A70(const void **a1, int a2);
bool __cdecl sub_10011AA0(const void **a1, int a2);
bool __cdecl sub_10011AD0(const void **a1, int a2);
bool __cdecl sub_10011B00(const void **a1, int a2);
bool __cdecl sub_10011B30(const void **a1, int a2);
bool __cdecl sub_10011B60(const void **a1, int a2);
bool __cdecl sub_10011B90(const void **a1, int a2);
int __cdecl sub_10011BC0(int a1, int a2, int a3);
// void __cdecl __noreturn exit_0(int);
int __cdecl sub_10011C30(int a1, char a2);
int __cdecl sub_10011C50(int a1, int a2, int a3);
int __cdecl sub_10011C80(int a1, int a2, int a3, int a4);
int __cdecl sub_10011CB0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_10011CF0(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_10011D30(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
char __cdecl sub_10011D80(int a1);
char __cdecl sub_10011DB0(int a1);
char __cdecl sub_10011DC0(int a1, int a2);
signed int __cdecl sub_10011F40(int a1);
signed int __cdecl sub_10011F80(int a1, int a2, int a3);
char __cdecl sub_10012020(int a1);
char __cdecl sub_10012080(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_100120F0(char *a1);
int __cdecl sub_10012190(int a1, int a2, int a3);
bool __cdecl sub_10012200(int a1, unsigned int a2, int a3);
char __cdecl sub_10012290(int a1, int a2, char a3, char a4);
char __cdecl sub_10012340(int a1);
char __cdecl sub_10012350(int a1, void (__cdecl *a2)(int));
int (__cdecl *__cdecl sub_100123D0(int a1, const char *a2))(const char *);
signed int __cdecl sub_10012420(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_10012470(int a1, int a2, int a3, size_t a4, char *a5);
int sub_100125F0();
const char *__cdecl sub_10012600(unsigned int a1);
int __cdecl sub_10012620(int a1, int a2, int a3, int a4);
int __cdecl sub_100126D0(int a1);
int __cdecl sub_100126F0(int a1);
char *sub_10012710(char *a1, ...);
// char *__usercall sub_10012750@<eax>(char a1@<al>, unsigned __int8 a2@<cl>);
// char __usercall sub_10012770@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5);
int sub_10012950();
int sub_10012970();
int __cdecl sub_10012990(int a1, int a2);
int __cdecl sub_100129F0(int a1);
int __cdecl sub_10012A00(int a1, int a2);
int __cdecl sub_10012A60(int a1);
bool __cdecl sub_10012A70(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_10012BB0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_10012F60(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9);
bool __cdecl sub_100133B0(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9);
bool __cdecl sub_10013870(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_10013C30(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9);
bool __cdecl sub_10014030(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_100143F0(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9);
bool __cdecl sub_10014930(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9);
bool __cdecl sub_10014D10(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_100150D0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_10015470(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9);
bool __cdecl sub_10015870(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_10015C10(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9);
bool __cdecl sub_100161F0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9);
bool __cdecl sub_100165E0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
int sub_10016980();
// BOOL __usercall sub_100169B0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6);
// bool __usercall sub_10016B20@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9);
char __cdecl sub_10016D90(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
bool __cdecl sub_10017090(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
bool __cdecl sub_10017140(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8);
const char *__cdecl sub_10017180(int a1, int a2);
char __cdecl sub_100171C0(int a1, int *a2, unsigned int a3);
signed int __cdecl sub_10017F70(int a1, int a2);
char **__cdecl sub_10017FF0(int a1);
int (**sub_10018030())();
int (__cdecl *__cdecl sub_10018040(const char *a1))(const char *);
const char *sub_10018060();
__int64 sub_10018070();
const char *sub_10018080();
// int __usercall sub_10018090@<eax>(_BYTE *a1@<edi>, int a2);
signed int __cdecl sub_100180E0(int a1, int a2);
int sub_10018110(); // weak
// int __usercall sub_10018230@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3);
char __cdecl sub_100185B0(int a1, const void **a2, unsigned int a3);
char **__cdecl sub_100193D0(int a1);
char __thiscall sub_10019490(void *this);
char __cdecl sub_10019520(int a1, char a2);
char __cdecl sub_100195E0(char a1);
char __thiscall sub_10019610(void *this);
double __cdecl sub_10019630(char a1);
double sub_100196B0(void); // weak
char __cdecl sub_100196C0(char a1);
char __cdecl sub_10019700(char a1);
signed int __cdecl sub_10019770(char a1);
char __cdecl sub_100197F0(char a1);
char __cdecl sub_10019860(char a1);
char __cdecl sub_10019910(int a1);
char __thiscall sub_10019A10(void *this);
int __thiscall sub_10019A20(void *this);
char __cdecl sub_10019A40(char a1);
char __cdecl sub_10019AC0(char a1);
char __cdecl sub_10019AF0(char a1);
char __cdecl sub_10019B20(char a1, void *a2);
int __cdecl sub_10019BA0(char a1, _DWORD *a2);
int __cdecl sub_10019BF0(char *a1, char a2);
bool __cdecl sub_10019C60(int a1, void *a2);
char __cdecl sub_10019D20(int a1, bool *a2);
signed int __cdecl sub_10019DE0(char a1, char a2);
int __cdecl sub_10019E40(char a1);
signed int __cdecl sub_10019E80(char a1, char a2, char a3);
int __cdecl sub_10019EF0(char a1);
int __cdecl sub_10019F30(char a1);
char __cdecl sub_10019F70(char a1, int a2);
char __cdecl sub_10019F90(char a1, int a2);
char __cdecl sub_10019FC0(char a1, int a2);
char __cdecl sub_1001A010(char a1, int a2);
char __cdecl sub_1001A040(char a1, int a2);
char __cdecl sub_1001A060(int a1);
char __cdecl sub_1001A080(char a1);
char __cdecl sub_1001A0C0(char a1);
int __cdecl sub_1001A0E0(char a1, char a2);
// bool __usercall sub_1001A190@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3);
// char __usercall sub_1001A1C0@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6);
char __cdecl sub_1001A260(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1001A2E0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1001A360(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1001A3E0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1001A460(char a1);
char __cdecl sub_1001A500(char a1);
char __cdecl sub_1001A540(char a1);
char __thiscall sub_1001A570(void *this);
int __cdecl sub_1001A580(char a1);
_DWORD __cdecl sub_1001A5B0(char); // weak
int __cdecl sub_1001A5C0(unsigned __int8 *a1);
unsigned int __cdecl sub_1001A5E0(void *a1);
unsigned int __cdecl sub_1001A600(void *a1);
unsigned int __cdecl sub_1001A620(void *a1);
unsigned int __cdecl sub_1001A640(void *a1);
unsigned int __cdecl sub_1001A660(void *a1);
unsigned int __cdecl sub_1001A680(void *a1);
int __cdecl sub_1001A6E0(unsigned __int8 *a1, int a2);
int __cdecl sub_1001A710(int a1, unsigned int a2);
__int16 __cdecl sub_1001A800(int a1, unsigned int a2);
__int16 __cdecl sub_1001A850(unsigned int *a1, _WORD *a2, _WORD *a3);
int __cdecl sub_1001A8D0(int a1);
char __cdecl sub_1001A8E0(signed int a1, _DWORD *a2, _DWORD *a3);
char *__cdecl sub_1001A920(const char *a1, int a2);
// char *__usercall sub_1001A990@<eax>(char *result@<eax>);
void __cdecl sub_1001A9C0(char *a1);
void __cdecl sub_1001AA80(char *a1, char *a2);
void *__cdecl sub_1001AAE0(int a1);
int __cdecl sub_1001AC70(int a1, int a2);
// char __usercall sub_1001ADB0@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5);
signed int __cdecl sub_1001AE80(_DWORD *a1, char *a2);
BOOL __cdecl sub_1001AF60(unsigned int a1);
BOOL __cdecl sub_1001AF80(int a1);
_DWORD __cdecl sub_1001AFA0(_DWORD); // weak
unsigned int __cdecl sub_1001AFB0(int a1, char a2);
signed int __cdecl sub_1001B010(void *a1, int a2, unsigned int a3);
int __cdecl sub_1001B030(int a1, int a2, int a3);
char __cdecl sub_1001B050(const char *a1, const char *a2);
int __cdecl sub_1001B190(int a1, int a2, unsigned int a3);
int sub_1001B210();
void __cdecl sub_1001B220(int a1);
int __cdecl sub_1001B250(int a1);
bool __cdecl sub_1001B270(int a1);
void *__cdecl sub_1001B2A0(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5);
// unsigned int __usercall sub_1001B2E0@<eax>(int a1@<edx>, int a2, int a3);
// int __usercall sub_1001B300@<eax>(int result@<eax>, int a2@<ecx>);
char __cdecl sub_1001B320(void (__cdecl *a1)(_DWORD), int a2);
signed int __cdecl sub_1001B350(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5);
void __cdecl sub_1001B430(int a1, int a2, int a3);
// void *__usercall sub_1001B4E0@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3);
void __cdecl sub_1001B760(int a1, int a2);
char __cdecl sub_1001B830(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4);
// int __usercall sub_1001B8A0@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9);
// int __usercall sub_1001BC00@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7);
int __cdecl sub_1001BD10(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10);
char __cdecl sub_1001BEA0(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3);
// char __usercall sub_1001BFF0@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5);
char __cdecl sub_1001C140(int a1, int a2);
signed int __cdecl sub_1001C180(int a1, int a2);
bool __cdecl sub_1001C1E0(signed int a1);
int sub_1001C250();
char sub_1001C570();
char sub_1001C790();
char sub_1001C990();
char sub_1001CB10();
char sub_1001CC90();
char sub_1001CE00();
char sub_1001CF00();
char sub_1001D060();
char sub_1001D1C0();
char sub_1001D320();
char sub_1001D490();
char sub_1001D5F0();
char sub_1001D750();
char sub_1001D970();
char sub_1001DAD0();
char sub_1001DC30();
char sub_1001DD90();
char sub_1001DF00();
char sub_1001E060();
char sub_1001E1C0();
char sub_1001E3E0();
char sub_1001E5E0();
char sub_1001E760();
char sub_1001E8E0();
char sub_1001EA50();
char sub_1001EB40();
char sub_1001ECA0();
char sub_1001EE00();
char sub_1001EF60();
char sub_1001F0D0();
char sub_1001F230();
char sub_1001F390();
char sub_1001F590();
char sub_1001F6F0();
char sub_1001F850();
char sub_1001F9B0();
char sub_1001FB20();
char sub_1001FC80();
char sub_1001FDE0();
char sub_10020380();
char sub_10020590();
char sub_10020780();
char sub_100208F0();
char sub_10020A60();
char sub_10020BC0();
char sub_10020CB0();
char sub_10020E10();
char sub_10020F70();
char sub_100210D0();
char sub_10021240();
char sub_100213A0();
char sub_10021500();
char sub_10021700();
char sub_10021860();
char sub_100219C0();
char sub_10021B20();
char sub_10021C90();
char sub_10021DF0();
char sub_10021F50();
char sub_10022160();
char sub_10022350();
char sub_100224C0();
char sub_10022630();
char sub_10022790();
char sub_10022880();
char sub_100229E0();
char sub_10022B40();
char sub_10022CA0();
char sub_10022E10();
char sub_10022F70();
char sub_100230D0();
char sub_100232D0();
char sub_10023430();
char sub_10023590();
char sub_100236F0();
char sub_10023860();
char sub_100239C0();
char **sub_10023B20();
int __cdecl sub_10023B30(int a1, int a2, int a3);
// int (__cdecl *__usercall sub_10023B50@<eax>(int a1@<eax>, int a2@<ecx>))(int);
// int __usercall sub_10023B60@<eax>(unsigned __int8 *a1@<eax>, int a2);
int (__cdecl *__cdecl sub_10023D90(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10023DE0(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10023E30(int a1, unsigned __int8 *a2))(int);
int (__cdecl *__cdecl sub_10023E80(int a1))(int);
int __cdecl sub_10023F00(int a1, int a2);
int (__cdecl *__cdecl sub_10023F80(int a1, unsigned __int8 *a2, char a3))(int);
int (__cdecl *__cdecl sub_10023FD0(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10024010(int a1, int a2, int a3))(int);
char sub_10024070();
signed int __fastcall sub_100240F0(unsigned __int8 a1);
char __cdecl sub_10024100(unsigned __int8 a1);
__int16 __cdecl sub_10024120(unsigned __int8 a1);
bool __cdecl sub_10024140(void *a1);
char sub_10024180();
double __cdecl sub_10024190(float a1, float a2);
int __cdecl sub_10024230(signed int a1, signed int a2);
double __cdecl sub_10024270(float a1, float a2);
double __cdecl sub_10024310(float a1, float a2);
int __cdecl sub_10024380(int a1);
// int (*__usercall sub_10024390@<eax>(int a1@<eax>, double *a2@<ecx>, int a3@<edi>, int a4@<esi>, int a5, int a6, char a7, double a8, int a9))(void);
// int __usercall sub_10024460@<eax>(int result@<eax>, _DWORD *a2@<edi>, unsigned int a3@<esi>, char a4);
int (*__cdecl sub_100244A0(char a1, double a2, int a3, int a4, int a5, int a6))(void);
int (*__cdecl sub_10024530(char a1, double a2, int a3, int a4, int a5, int a6))(void);
int __cdecl sub_100245B0(unsigned __int8 a1, unsigned int a2);
unsigned int __cdecl sub_100245D0(unsigned int *a1, signed int a2, unsigned int a3);
double __cdecl sub_10024700(float a1);
int __cdecl sub_10024730(int a1);
int sub_10024750();
int __cdecl sub_10024770(int a1, int a2);
__int16 __cdecl sub_100247A0(int a1);
int sub_100247C0();
int __cdecl sub_100247E0(int a1, int a2, int a3, int a4);
int j_TSK_pvg_get_us_timer(void); // weak
int __cdecl sub_10024820(int a1, int a2, int a3, int a4);
int __cdecl sub_10024850(int a1);
int __cdecl sub_10024870(int a1, int a2);
int __cdecl sub_100248A0(int a1, int a2);
int __cdecl sub_100248D0(int a1);
int __cdecl sub_100248F0(int a1);
int __cdecl sub_10024910(_BYTE *a1);
int __cdecl sub_10024950(int a1, int a2);
int __cdecl sub_10024980(int a1, int a2);
int __cdecl sub_100249A0(int a1);
int __cdecl sub_100249E0(int a1, int a2, int a3);
char __cdecl sub_10024A00(int a1, int a2, int a3);
int __cdecl sub_10024A40(int, void *, int, void *); // idb
int __cdecl sub_10024A80(int a1, int a2, int a3);
int __cdecl sub_10024AB0(int a1, int a2, int a3);
int __cdecl sub_10024AD0(int a1, int a2, int a3);
int __cdecl sub_10024AF0(int a1, int a2, int a3);
int __cdecl sub_10024B50(int a1, int a2, int a3);
char __cdecl sub_10024B90(int a1, int a2, int a3);
int __cdecl sub_10024BD0(int, void *, int, void *); // idb
int sub_10024C20(void); // weak
int __cdecl sub_10024C30(int a1, int a2);
signed int __cdecl sub_10024C90(int a1);
// int __usercall sub_10024D10@<eax>(const char **a1@<esi>);
// int __usercall sub_10025010@<eax>(int a1@<eax>, int a2@<ecx>);
signed int __cdecl sub_10025030(int a1);
int __cdecl sub_10025100(LONG Value); // idb
void __cdecl sub_10025190(int a1, _BYTE *a2);
int __cdecl sub_100251C0(int a1, int a2);
int j_HWM_pvg_hsdb_get_lrus_online(void); // weak
int __cdecl j_HWM_pvg_log_err(_DWORD); // weak
int __cdecl j_HWM_pvg_read_reg(_DWORD); // weak
int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_create_id(_DWORD); // weak
int __cdecl sub_10025250(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl sub_100252A0(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD); // weak
signed int __cdecl sub_10025320(unsigned int a1);
int __cdecl j_FIL_vfs_delete(_DWORD); // weak
int j_FIL_vfs_dyn_linker(void); // weak
int __cdecl sub_10025380(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_100253F0(unsigned int a1, void *a2, int a3);
signed int __cdecl sub_10025430(unsigned int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD); // weak
signed int __cdecl sub_100254C0(unsigned int a1, int a2, int a3, int a4);
__int64 __cdecl sub_10025510(int a1);
int __cdecl sub_10025530(int a1, int a2, int a3);
int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_10025560(int a1, int a2, int a3, char a4);
char __cdecl sub_10025580(int a1);
signed int __cdecl sub_100255B0(unsigned int a1, int a2, int a3);
int __cdecl sub_100255D0(int a1, int a2, int a3);
int __cdecl sub_100255F0(int a1);
int __cdecl sub_10025630(int a1);
int __cdecl sub_10025670(int a1);
int __cdecl sub_100256B0(int a1);
int __cdecl sub_100256F0(int a1, int a2, int a3, int a4);
int __cdecl sub_10025760(int a1, int a2, int a3);
int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD); // weak
int sub_10025810(void); // weak
int __cdecl j_mem_unmap(_DWORD, _DWORD); // weak
void __cdecl sub_10025830(__int16 a1, _BYTE *a2);
unsigned int __cdecl sub_10025860(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6);
// int __usercall sub_10025A10@<eax>(int a1@<esi>);
int __cdecl sub_10025AC0(int a1, unsigned __int64 a2);
// int __usercall sub_10025B70@<eax>(int a1@<ebx>, unsigned __int64 a2);
unsigned int __cdecl sub_10025C00(int a1, void *a2, int a3, int a4, int a5);
// int SYS_exit_krnl(void); weak
// int __cdecl SYS_pvg_is_booting(_DWORD); weak
// int SYS_enter_krnl(void); weak
// int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_crit_lvl(_DWORD); weak
// int TSK_pvg_get_id(void); weak
// int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_run_state(_DWORD); weak
// int TSK_pvg_get_timer(void); weak
// int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_release_smphr(_DWORD); weak
// int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_set_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_suspend(_DWORD); weak
// int __cdecl TSK_pvg_wait_evnt(_DWORD); weak
// int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD); weak
// int FIL_vfs_close(void); weak
// int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_read(void); weak
// int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_size(_DWORD); weak
// int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// void *__cdecl memcpy(void *, const void *, size_t);
// void *__cdecl memset(void *, int, size_t);
// char *__cdecl strncpy(char *, const char *, size_t);
// char *__cdecl strstr(const char *, const char *);
// void *__cdecl memcpy_0(void *, const void *, size_t);
// int __cdecl strncmp(const char *, const char *, size_t);
// char *__cdecl strrchr(const char *, int);
// _DWORD __thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *); idb
// int __cdecl isdigit(int);
// int __cdecl isxdigit(int);
// int __cdecl isspace(int);
// int __cdecl isprint(int);
// int sprintf(char *, const char *, ...);
// int __cdecl tolower(int);
// void *__cdecl memchr(const void *, int, size_t);
// char *__cdecl strchr(const char *, int);
// int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
// int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_10027BD2(int a1, int a2, char a3);
// char *__cdecl strncat(char *, const char *, size_t);
// int _snprintf(char *, size_t, const char *, ...);
// double __cdecl floor(double);
// char *__cdecl strpbrk(const char *, const char *);
// int *__cdecl _errno();
// unsigned __int32 *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
signed int __cdecl sub_1002A35B(_DWORD *a1);
signed int __cdecl sub_1002A392(_DWORD *a1);
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
// int _getptd(void); weak
// void __cdecl free(void *);
// _DWORD __cdecl _calloc_crt(size_t, _DWORD); weak
void sub_1002AFD8();
int (*sub_1002B485())(void);
void __cdecl sub_1002B4A9(); // idb
// int __cdecl isleadbyte(int);
int __cdecl sub_1002D6F5(int, FILE *); // idb
int __cdecl sub_1002E28A(int a1);
// int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl __check_float_string(int, void *, int); idb
// int __fastcall _inc(_DWORD, _DWORD); weak
// _DWORD __cdecl _whiteout(_DWORD); weak
int __cdecl sub_1002E4DA(FILE *, int, struct localeinfo_struct *, int); // idb
int __cdecl sub_10030A8C(int, int, struct localeinfo_struct *); // idb
int __cdecl sub_10030B32(int, int, struct localeinfo_struct *); // idb
// int _get_sse2_info(void); weak
int sub_10031052();
void sub_10031334();
int sub_10031822();
int __cdecl sub_100319DF(int a1);
int __cdecl sub_100319E9(int a1);
int __cdecl sub_100319F3(int a1);
int __cdecl sub_10031AD2(int a1);
DWORD __cdecl sub_100333DC(int a1, int a2, int a3, DWORD dwMoveMethod);
// __int64 __cdecl _lseeki64(int, __int64, int);
_WORD *__cdecl sub_10033578(int a1, int a2, DWORD nNumberOfBytesToWrite);
_WORD *__cdecl sub_10033B9A(int a1, int a2, DWORD nNumberOfBytesToWrite);
// _DWORD __cdecl _getbuf(_DWORD); weak
int __cdecl sub_10033CBA(signed int a1);
void **sub_10033D18();
signed int sub_10033D1E();
// int __cdecl _fileno(FILE *);
int __cdecl sub_10034115(FILE *); // idb
int __cdecl sub_10034235(int, FILE *); // idb
// int __cdecl _mbtowc_l(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes, _locale_t Locale);
// int __cdecl mbtowc(wchar_t *, const char *, size_t);
int sub_1003447D();
signed int __cdecl sub_10034C62(int a1, int a2);
signed int __cdecl sub_100351A4(int a1, int a2);
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_10036A9D(int a1, int a2, int a3);
signed int __cdecl sub_10036F80(signed int a1);
signed int __cdecl sub_10037001(signed int a1);
// _DWORD __cdecl __lock_fhandle(_DWORD); weak
void __cdecl sub_10037112(signed int a1);
// int __cdecl _putwch_nolock(__int16 Buffer); idb
// _DWORD __cdecl flsall(_DWORD); weak
int sub_10037413();
// int __cdecl _read(int, void *, unsigned int);
signed int __cdecl sub_1003817C(signed int a1);
signed int __cdecl sub_10038360(unsigned int a1, int a2, int a3, int a4);
signed int __cdecl sub_100383C0(unsigned int a1, int a2, int a3);
unsigned int __cdecl sub_100383E0(unsigned int a1);
bool __cdecl sub_10038400(int a1);
int __cdecl sub_100384D0(int a1);
int __cdecl sub_100384F0(int a1, int a2);
signed int __cdecl sub_10038530(int a1, void *a2, unsigned __int16 a3, __int16 a4);
int __cdecl sub_100385F0(int a1);
// int __usercall sub_10038630@<eax>(int a1@<eax>, int a2@<esi>);
// signed int __usercall sub_100386E0@<eax>(int a1@<eax>, int a2@<esi>);
// char __usercall sub_100388B0@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_100388C0@<eax>(int result@<eax>);
// char __usercall sub_100388E0@<al>(int a1@<eax>);
// int __usercall sub_10038900@<eax>(int a1@<esi>, unsigned __int8 a2);
int __fastcall sub_10038940(int a1, int a2);
// int __usercall sub_10038960@<eax>(int a1@<esi>);
// signed int __usercall sub_100389A0@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_10038BB0(int a1);
signed int __cdecl sub_10038E20(unsigned int a1, int a2, int a3);
// int __usercall sub_10038EC0@<eax>(int a1@<eax>);
// int __usercall sub_10038EE0@<eax>(int a1@<edi>, int a2);
// signed int __usercall sub_10038F10@<eax>(int a1@<eax>, int a2@<ebx>);
// void __cdecl __noreturn exit_1(int);
// char __usercall sub_10039000@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>);
// signed int __usercall sub_10039030@<eax>(int a1@<eax>);
signed int __cdecl sub_10039060(unsigned int a1);
signed int __cdecl sub_100390B0(int a1, int a2);
signed int __cdecl sub_100392A0(unsigned int a1, int a2, int a3);
signed int __cdecl sub_10039300(unsigned int a1, int a2, int a3);
// signed int __usercall sub_10039490@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_1003A540@<eax>(int a1@<esi>, int a2, unsigned int a3);
// signed int __usercall sub_1003A5A0@<eax>(int a1@<eax>, int a2, int a3);
// void *__usercall sub_1003B320@<eax>(void *a1@<eax>);
unsigned int __cdecl sub_1003B340(int a1, unsigned int a2);
// int __usercall sub_1003B3A0@<eax>(int result@<eax>);
// int __usercall sub_1003B3E0@<eax>(int result@<eax>);
// unsigned int __usercall sub_1003CB00@<eax>(int a1@<esi>, int a2);
// void *__usercall sub_1003CC00@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3);
// void *__usercall sub_1003CC80@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3);
// int __usercall sub_1003CD20@<eax>(int a1@<edi>, int a2, size_t a3);
// int __usercall sub_1003CDE0@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3);
// int __usercall sub_1003CE40@<eax>(char *a1@<edi>);
// int __usercall sub_1003CF00@<eax>(int a1@<ebx>);
char __cdecl sub_1003CFC0(char *a1, size_t a2, int a3);
char __cdecl sub_1003D010(char *a1, unsigned int a2, int a3);
bool __cdecl sub_1003D060(int a1, int a2);
// int __usercall sub_1003D090@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7);
// int __usercall sub_1003D2A0@<eax>(void *a1@<eax>, int a2);
char *__cdecl sub_1003D2F0(int a1, int a2);
signed int __cdecl sub_1003D380(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6);
bool __cdecl sub_1003D4B0(void *a1, int a2);
// BOOL __usercall sub_1003D530@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_1003D5D0@<eax>(int result@<eax>);
unsigned int __fastcall sub_1003D660(unsigned int a1, int a2);
// int __usercall sub_1003D680@<eax>(int result@<eax>);
// int __usercall sub_1003D710@<eax>(int result@<eax>, int a2, int a3);
// int __usercall sub_1003DB90@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>);
// void *__usercall sub_1003DC40@<eax>(int a1@<edi>);
// int __usercall sub_1003DCA0@<eax>(int result@<eax>, int a2@<edx>);
// signed int __usercall sub_1003DE70@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>);
_WORD *__fastcall sub_1003DEF0(int a1, int a2);
// unsigned int __usercall sub_1003DF60@<eax>(int a1@<esi>, unsigned int a2);
// unsigned int __usercall sub_1003E110@<eax>(int a1@<esi>, int a2);
// int __usercall sub_1003E1E0@<eax>(int result@<eax>, int a2@<edi>, int a3);
// int __usercall sub_1003E290@<eax>(int result@<eax>, __int16 a2@<cx>);
// unsigned int __usercall sub_1003E2D0@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3);
// signed int __usercall sub_1003E330@<eax>(signed int result@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_1003E410@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_1003E9B0@<eax>(int a1@<eax>);
// int __usercall sub_1003EBF0@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4);
// signed int __usercall sub_1003EC90@<eax>(int a1@<esi>, int a2);
// unsigned int __usercall sub_1003EE70@<eax>(int a1@<edi>);
// int __usercall sub_1003EFB0@<eax>(int a1@<eax>, int a2, int a3, int a4);
signed int __cdecl sub_1003F260(int a1, int a2);
// signed int __usercall sub_1003F520@<eax>(int a1@<eax>);
// _WORD *__usercall sub_1003F5F0@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
signed int __cdecl sub_1003F810(int a1, int a2);
signed int __cdecl sub_1003FB20(int a1, int a2);
signed int __cdecl sub_1003FF30(int a1, int a2);
int __cdecl sub_100400A0(unsigned int a1, _BYTE *a2, unsigned int a3);
signed int __cdecl sub_100401A0(int a1);
// signed int __usercall sub_100401C0@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10);
// int (__cdecl *__usercall sub_10040660@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD);
// int __usercall sub_100406B0@<eax>(int result@<eax>, char a2, char a3, int a4, int a5);
signed int __cdecl sub_100406D0(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_10040A80@<eax>(int a1@<edi>, int a2@<esi>, int a3);
// signed int __usercall sub_10040BC0@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4);
// signed int __usercall sub_10040C10@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9);
// int __usercall sub_10040CB0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4);
signed int __cdecl sub_10040CD0(int a1);
// int __usercall sub_10040CE0@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_10041380@<eax>(int a1@<eax>, int a2, int a3);
// signed int __usercall sub_10041D60@<eax>(int a1@<edi>, int a2);
signed int __cdecl sub_10042090(int a1, int a2);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// UINT __stdcall GetConsoleCP();
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall GetLastError();
// LONG __stdcall InterlockedExchange(volatile LONG *Target, LONG Value);

//-------------------------------------------------------------------------
// Data declarations

void *tsk_app_hdr_ptr = &tsk_app_hdr; // weak
_UNKNOWN unk_100439F0; // weak
__int16 word_10043D18[] = { 464 }; // weak
char byte_10043E60[] = { '\0' }; // weak
_UNKNOWN unk_10043E61; // weak
char *off_10043E64 = "/shr_mem/dat_intf.shr"; // weak
_UNKNOWN unk_10044460; // weak
__int16 word_100444AC[] = { 100 }; // weak
int dword_10045244[] = { 88 }; // weak
__int16 word_100456F4[] = { 836 }; // weak
char *off_10045714 = "/shr_mem/iop_a_pkt_intf.shr"; // weak
char *off_10045728 = "/shr_mem/iop_b_pkt_intf.shr"; // weak
char *off_1004573C = "/shr_mem/iop_c_pkt_intf.shr"; // weak
char *off_10045750 = "/shr_mem/iop_d_dbg_pkt_intf.shr"; // weak
char *off_10045764 = "/shr_mem/iop_d_pkt_intf.shr"; // weak
char *off_10045778 = "/shr_mem/iop_m_pkt_intf.shr"; // weak
_UNKNOWN unk_100472A0; // weak
int dword_100472A4[] = { 0 }; // weak
_UNKNOWN unk_10047869; // weak
_UNKNOWN unk_1004C61C; // weak
wchar_t a___0[8] = L":;<=>?@"; // weak
wchar_t aAbcde[6] = L"ABCDE"; // weak
char *off_1004C6E8 = "/shr_mem/pvt_intf.shr"; // weak
char *off_1004D048[3] = { ".\\test\\tst_tsk_common.c", "$Id$", &off_1004CEB8 }; // weak
_UNKNOWN unk_1004D05C; // weak
_UNKNOWN unk_1004DEB8; // weak
int dword_1004DEBC[] = { 1312 }; // weak
int dword_1004E170[] = { 6829 }; // weak
int dword_1004EFE8 = 64; // weak
__int16 word_1004EFEC[] = { 6782 }; // weak
__int16 word_1004EFF0[] = { 128 }; // weak
_UNKNOWN unk_1004F00C; // weak
_DWORD dword_1004F010[10] = { 64, 24, 62, 18, 65, 27525120, 27394467, 27721729, 27591078, 0 }; // idb
__int16 word_10050420[] = { 1565 }; // weak
__int16 word_10050424[] = { 534 }; // weak
char byte_10050428[] = { '\x04' }; // weak
__int16 word_1005042A[] = { 6512 }; // weak
int dword_10050440[] = { 118000 }; // weak
__int16 word_10051DD2[] = { 233 }; // weak
int dword_10051DD8[] = { 6201 }; // weak
__int16 word_10054988[] = { 114 }; // weak
_UNKNOWN unk_100551C0; // weak
int dword_100551C4[] = { 6006 }; // weak
char *off_10056090 = "/shr_mem/iop_gtx_intf.shr"; // weak
__int16 word_100561B0[] = { 551 }; // weak
char *off_10057170 = "/shr_mem/iop_fltr_data_intf.shr"; // weak
char byte_10058B10[] = { '\x01' }; // weak
__int16 word_10058B12[] = { 3020 }; // weak
_UNKNOWN unk_10059FB8; // weak
char *off_1005A15C[3] = { "***global-commands***", "..\\lib\\utf\\utf_runner.c", &off_1005A170 }; // weak
char *off_1005A300 = "true"; // weak
char byte_1005A304[] = { '\x01' }; // weak
char *off_1005A368 = "failure listener"; // weak
_UNKNOWN unk_1005AB10; // weak
char *off_1005AD24[18] =
{
  "FAIL",
  "PASS",
  "normal",
  "robust",
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_1005AD2C[16] =
{
  "normal",
  "robust",
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_1005AD34[14] =
{
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_1005AD50[7] =
{
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_1005AD5C[4] = { "FALSE", "TRUE", "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
char *off_1005AD64[2] = { "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
_UNKNOWN unk_1005B018; // weak
_UNKNOWN unk_1005B05C; // weak
char *off_1005B418 = "printf_listener"; // weak
__int16 word_1005C04C = 2573; // weak
int (*off_1005C108[2])() = { &sub_10023B20, &sub_10009D40 }; // weak
char *off_1005C1B8 = "gate_listener"; // weak
_UNKNOWN unk_10061690; // weak
char byte_10061691[] = { '\0' }; // weak
int (__cdecl *off_10061C08[3])(char) = { &sub_100197F0, &sub_10019700, &sub_100196C0 }; // weak
_UNKNOWN unk_10061D08; // weak
_UNKNOWN unk_10061D20; // weak
_UNKNOWN unk_10061D68; // weak
int dword_10061D6C[] = { 6767 }; // weak
_UNKNOWN unk_10061D78; // weak
_UNKNOWN unk_10061D90; // weak
_UNKNOWN unk_10061DA8; // weak
int dword_10061DAC[] = { 6769 }; // weak
_UNKNOWN unk_10061DC0; // weak
int dword_10061DC4[] = { 6093 }; // weak
_UNKNOWN unk_10064230; // weak
int dword_10064234[] = { 0 }; // weak
_UNKNOWN unk_10064248; // weak
int dword_1006424C[] = { 0 }; // weak
_UNKNOWN unk_10064270; // weak
int dword_10064274[] = { 0 }; // weak
_UNKNOWN unk_100642A0; // weak
int dword_100642A4[] = { 0 }; // weak
_UNKNOWN unk_10064DB8; // weak
char byte_10064DBC[] = { '\0' }; // weak
_UNKNOWN unk_10065078; // weak
void *off_1006507C = &unk_10064DF0; // weak
char *off_10066FFC = "Cannot send message. Data radio failed."; // weak
_UNKNOWN unk_10067098; // weak
_UNKNOWN unk_100670BC; // weak
_UNKNOWN unk_10067260; // weak
char off_10067E90[] = { '\x10', '', '\x05', '\x10' }; // idb
int dword_10067EAC = 1; // idb
char byte_10067EC8[] = { '\x01' }; // weak
char *off_10067ECC[3] = { "1", "2", "fail_normal_1" }; // weak
char *off_10067ED0[2] = { "2", "fail_normal_1" }; // weak
char off_10067ED4[8] = { 'x', '~', '\x06', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_10067F58[] = { '\0' }; // weak
char byte_10067F59[] = { '\0' }; // weak
int dword_10067F5C[] = { 0 }; // weak
char *off_10067F60 = "0, 0, 0"; // weak
double dbl_100681C8[] = {  0.0 }; // weak
double dbl_100681D0[] = {  0.0 }; // weak
double dbl_100681D8[] = {  0.0 }; // weak
int dword_100681E0[] = { 0 }; // weak
char *off_100681E4 = "0, 0, 0"; // weak
float flt_10068DE8[] = {  0.0 }; // weak
float flt_10068DEC[] = {  0.0 }; // weak
float flt_10068DF0[] = {  0.0 }; // weak
int dword_10068DF4[] = { 0 }; // weak
char off_10068DF8[20] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char *off_1006957C[3] =
{
  "..\\lib\\utf\\utf_validate.c",
  "..\\lib\\utf\\utf_validate.c",
  &off_1007E1D8
}; // weak
int dword_10069590[] = { 0 }; // weak
int dword_10069594[] = { 0 }; // weak
int dword_10069598[] = { 0 }; // weak
int dword_1006959C[] = { 0 }; // weak
char *off_100695A0 = "0, 0, 0"; // weak
__int16 word_10069D28[] = { 0 }; // weak
__int16 word_10069D2A[] = { 0 }; // weak
__int16 word_10069D2C[] = { 0 }; // weak
int dword_10069D30[] = { 0 }; // weak
char *off_10069D34 = "0, 0, 0"; // weak
int dword_1006A338[] = { 0 }; // weak
int dword_1006A33C[] = { 0 }; // weak
int dword_1006A340[] = { 0 }; // weak
int dword_1006A344[] = { 0 }; // weak
char off_1006A348[20] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1006AAD0[] = { 0 }; // weak
int dword_1006AAD4[] = { 0 }; // weak
int dword_1006AAD8[] = { 0 }; // weak
int dword_1006AADC[] = { 0 }; // weak
int dword_1006AAE0[] = { 0 }; // weak
int dword_1006AAE4[] = { 0 }; // weak
int dword_1006AAE8[] = { 0 }; // weak
char off_1006AAEC[32] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1006B6F0[] = { '\0' }; // weak
char byte_1006B6F1[] = { '\0' }; // weak
char byte_1006B6F2[] = { '\0' }; // weak
int dword_1006B6F4[] = { 0 }; // weak
char *off_1006B6F8 = "0, 0, 0"; // weak
int dword_1006BB80[] = { 0 }; // weak
int dword_1006BB84[] = { 0 }; // weak
int dword_1006BB88[] = { 0 }; // weak
int dword_1006BB8C[] = { 0 }; // weak
char *off_1006BB90 = "0, 0, 0"; // weak
int dword_1006C318[] = { 0 }; // weak
int dword_1006C31C[] = { 0 }; // weak
int dword_1006C320[] = { 0 }; // weak
int dword_1006C324[] = { 0 }; // weak
char off_1006C328[20] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_1006C688[] = { 0 }; // weak
__int16 word_1006C68A[] = { 0 }; // weak
__int16 word_1006C68C[] = { 0 }; // weak
int dword_1006C690[] = { 0 }; // weak
char *off_1006C694 = "0, 0, 0"; // weak
int dword_1006C948[] = { 0 }; // weak
int dword_1006C94C[] = { 0 }; // weak
int dword_1006C950[] = { 0 }; // weak
int dword_1006C954[] = { 0 }; // weak
char off_1006C958[20] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1006CCB8[] = { 0 }; // weak
int dword_1006CCBC[] = { 0 }; // weak
int dword_1006CCC0[] = { 0 }; // weak
int dword_1006CCC4[] = { 0 }; // weak
int dword_1006CCC8[] = { 0 }; // weak
int dword_1006CCCC[] = { 0 }; // weak
int dword_1006CCD0[] = { 0 }; // weak
char off_1006CCD4[32] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1006D238[] = { '\0' }; // weak
char byte_1006D239[] = { '\0' }; // weak
char byte_1006D23A[] = { '\0' }; // weak
int dword_1006D23C[] = { 0 }; // weak
char *off_1006D240 = "0, 0, 0"; // weak
int dword_1006D448[] = { 0 }; // weak
int dword_1006D44C[] = { 0 }; // weak
int dword_1006D450[] = { 0 }; // weak
int dword_1006D454[] = { 0 }; // weak
char off_1006D458[20] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1006D7B8[] = { '\x01' }; // weak
char *off_1006D7BC[3] = { "1", "2", "fail_robust_1" }; // weak
char *off_1006D7C0[2] = { "2", "fail_robust_1" }; // weak
char off_1006D7C4[8] = { '', 'y', '\x06', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_1006D848[] = { '\0' }; // weak
char byte_1006D849[] = { '\0' }; // weak
int dword_1006D84C[] = { 0 }; // weak
char *off_1006D850 = "0, 0, 0"; // weak
double dbl_1006DAB8[] = {  0.0 }; // weak
double dbl_1006DAC0[] = {  0.0 }; // weak
double dbl_1006DAC8[] = {  0.0 }; // weak
int dword_1006DAD0[] = { 0 }; // weak
char off_1006DAD4[32] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_1006E6D8[] = {  0.0 }; // weak
float flt_1006E6DC[] = {  0.0 }; // weak
float flt_1006E6E0[] = {  0.0 }; // weak
int dword_1006E6E4[] = { 0 }; // weak
char off_1006E6E8[20] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1006EE70[] = { 0 }; // weak
int dword_1006EE74[] = { 0 }; // weak
int dword_1006EE78[] = { 0 }; // weak
int dword_1006EE7C[] = { 0 }; // weak
char *off_1006EE80 = "0, 0, 0"; // weak
__int16 word_1006F608[] = { 0 }; // weak
__int16 word_1006F60A[] = { 0 }; // weak
__int16 word_1006F60C[] = { 0 }; // weak
int dword_1006F610[] = { 0 }; // weak
char *off_1006F614 = "0, 0, 0"; // weak
int dword_1006FC18[] = { 0 }; // weak
int dword_1006FC1C[] = { 0 }; // weak
int dword_1006FC20[] = { 0 }; // weak
int dword_1006FC24[] = { 0 }; // weak
char off_1006FC28[20] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100703B0[] = { 0 }; // weak
int dword_100703B4[] = { 0 }; // weak
int dword_100703B8[] = { 0 }; // weak
int dword_100703BC[] = { 0 }; // weak
int dword_100703C0[] = { 0 }; // weak
int dword_100703C4[] = { 0 }; // weak
int dword_100703C8[] = { 0 }; // weak
char off_100703CC[32] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10070FD0[] = { '\0' }; // weak
char byte_10070FD1[] = { '\0' }; // weak
char byte_10070FD2[] = { '\0' }; // weak
int dword_10070FD4[] = { 0 }; // weak
char *off_10070FD8 = "0, 0, 0"; // weak
int dword_10071460[] = { 0 }; // weak
int dword_10071464[] = { 0 }; // weak
int dword_10071468[] = { 0 }; // weak
int dword_1007146C[] = { 0 }; // weak
char *off_10071470 = "0, 0, 0"; // weak
int dword_10071BF8[] = { 0 }; // weak
int dword_10071BFC[] = { 0 }; // weak
int dword_10071C00[] = { 0 }; // weak
int dword_10071C04[] = { 0 }; // weak
char off_10071C08[20] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_10071F68[] = { 0 }; // weak
__int16 word_10071F6A[] = { 0 }; // weak
__int16 word_10071F6C[] = { 0 }; // weak
int dword_10071F70[] = { 0 }; // weak
char *off_10071F74 = "0, 0, 0"; // weak
int dword_10072228[] = { 0 }; // weak
int dword_1007222C[] = { 0 }; // weak
int dword_10072230[] = { 0 }; // weak
int dword_10072234[] = { 0 }; // weak
char off_10072238[20] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10072598[] = { 0 }; // weak
int dword_1007259C[] = { 0 }; // weak
int dword_100725A0[] = { 0 }; // weak
int dword_100725A4[] = { 0 }; // weak
int dword_100725A8[] = { 0 }; // weak
int dword_100725AC[] = { 0 }; // weak
int dword_100725B0[] = { 0 }; // weak
char off_100725B4[32] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10072B18[] = { '\0' }; // weak
char byte_10072B19[] = { '\0' }; // weak
char byte_10072B1A[] = { '\0' }; // weak
int dword_10072B1C[] = { 0 }; // weak
char *off_10072B20 = "0, 0, 0"; // weak
int dword_10072D28[] = { 0 }; // weak
int dword_10072D2C[] = { 0 }; // weak
int dword_10072D30[] = { 0 }; // weak
int dword_10072D34[] = { 0 }; // weak
char off_10072D38[20] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10073098[] = { '\x01' }; // weak
char *off_1007309C[3] = { "1", "1", "pass_normal_1" }; // weak
char *off_100730A0[2] = { "1", "pass_normal_1" }; // weak
char off_100730A4[8] = { '`', 'y', '\x06', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100730E8[] = { '\0' }; // weak
char byte_100730E9[] = { '\0' }; // weak
int dword_100730EC[] = { 0 }; // weak
char *off_100730F0 = "0, 0, 0"; // weak
double dbl_10073358[] = {  0.0 }; // weak
double dbl_10073360[] = {  0.0 }; // weak
double dbl_10073368[] = {  0.0 }; // weak
int dword_10073370[] = { 0 }; // weak
char off_10073374[32] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_10073F78[] = {  0.0 }; // weak
float flt_10073F7C[] = {  0.0 }; // weak
float flt_10073F80[] = {  0.0 }; // weak
int dword_10073F84[] = { 0 }; // weak
char off_10073F88[20] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10074710[] = { 0 }; // weak
int dword_10074714[] = { 0 }; // weak
int dword_10074718[] = { 0 }; // weak
int dword_1007471C[] = { 0 }; // weak
char *off_10074720 = "0, 0, 0"; // weak
__int16 word_10074EA8[] = { 0 }; // weak
__int16 word_10074EAA[] = { 0 }; // weak
__int16 word_10074EAC[] = { 0 }; // weak
int dword_10074EB0[] = { 0 }; // weak
char *off_10074EB4 = "0, 0, 0"; // weak
int dword_100754B8[] = { 0 }; // weak
int dword_100754BC[] = { 0 }; // weak
int dword_100754C0[] = { 0 }; // weak
int dword_100754C4[] = { 0 }; // weak
char off_100754C8[20] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10075C50[] = { 0 }; // weak
int dword_10075C54[] = { 0 }; // weak
int dword_10075C58[] = { 0 }; // weak
int dword_10075C5C[] = { 0 }; // weak
int dword_10075C60[] = { 0 }; // weak
int dword_10075C64[] = { 0 }; // weak
int dword_10075C68[] = { 0 }; // weak
char off_10075C6C[32] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10076870[] = { '\0' }; // weak
char byte_10076871[] = { '\0' }; // weak
char byte_10076872[] = { '\0' }; // weak
int dword_10076874[] = { 0 }; // weak
char *off_10076878 = "0, 0, 0"; // weak
int dword_10076D00[] = { 0 }; // weak
int dword_10076D04[] = { 0 }; // weak
int dword_10076D08[] = { 0 }; // weak
int dword_10076D0C[] = { 0 }; // weak
char *off_10076D10 = "0, 0, 0"; // weak
int dword_10077498[] = { 0 }; // weak
int dword_1007749C[] = { 0 }; // weak
int dword_100774A0[] = { 0 }; // weak
int dword_100774A4[] = { 0 }; // weak
char off_100774A8[20] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_10077808[] = { 0 }; // weak
__int16 word_1007780A[] = { 0 }; // weak
__int16 word_1007780C[] = { 0 }; // weak
int dword_10077810[] = { 0 }; // weak
char *off_10077814 = "0, 0, 0"; // weak
int dword_10077AC8[] = { 0 }; // weak
int dword_10077ACC[] = { 0 }; // weak
int dword_10077AD0[] = { 0 }; // weak
int dword_10077AD4[] = { 0 }; // weak
char off_10077AD8[20] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10077E38[] = { 0 }; // weak
int dword_10077E3C[] = { 0 }; // weak
int dword_10077E40[] = { 0 }; // weak
int dword_10077E44[] = { 0 }; // weak
int dword_10077E48[] = { 0 }; // weak
int dword_10077E4C[] = { 0 }; // weak
int dword_10077E50[] = { 0 }; // weak
char off_10077E54[32] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100783B8[] = { '\0' }; // weak
char byte_100783B9[] = { '\0' }; // weak
char byte_100783BA[] = { '\0' }; // weak
int dword_100783BC[] = { 0 }; // weak
char *off_100783C0 = "0, 0, 0"; // weak
int dword_100785C8[] = { 0 }; // weak
int dword_100785CC[] = { 0 }; // weak
int dword_100785D0[] = { 0 }; // weak
int dword_100785D4[] = { 0 }; // weak
char off_100785D8[20] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10078938[] = { '\x01' }; // weak
char *off_1007893C[3] = { "1", "1", "pass_robust_1" }; // weak
char *off_10078940[2] = { "1", "pass_robust_1" }; // weak
char off_10078944[8] = { '\x10', 'y', '\x06', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_10078988[] = { '\0' }; // weak
char byte_10078989[] = { '\0' }; // weak
int dword_1007898C[] = { 0 }; // weak
char *off_10078990 = "0, 0, 0"; // weak
double dbl_10078BF8[] = {  0.0 }; // weak
double dbl_10078C00[] = {  0.0 }; // weak
double dbl_10078C08[] = {  0.0 }; // weak
int dword_10078C10[] = { 0 }; // weak
char off_10078C14[32] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_10079818[] = {  0.0 }; // weak
float flt_1007981C[] = {  0.0 }; // weak
float flt_10079820[] = {  0.0 }; // weak
int dword_10079824[] = { 0 }; // weak
char off_10079828[20] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10079FB0[] = { 0 }; // weak
int dword_10079FB4[] = { 0 }; // weak
int dword_10079FB8[] = { 0 }; // weak
int dword_10079FBC[] = { 0 }; // weak
char *off_10079FC0 = "0, 0, 0"; // weak
__int16 word_1007A748[] = { 0 }; // weak
__int16 word_1007A74A[] = { 0 }; // weak
__int16 word_1007A74C[] = { 0 }; // weak
int dword_1007A750[] = { 0 }; // weak
char *off_1007A754 = "0, 0, 0"; // weak
int dword_1007AD58[] = { 0 }; // weak
int dword_1007AD5C[] = { 0 }; // weak
int dword_1007AD60[] = { 0 }; // weak
int dword_1007AD64[] = { 0 }; // weak
char off_1007AD68[20] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1007B4F0[] = { 0 }; // weak
int dword_1007B4F4[] = { 0 }; // weak
int dword_1007B4F8[] = { 0 }; // weak
int dword_1007B4FC[] = { 0 }; // weak
int dword_1007B500[] = { 0 }; // weak
int dword_1007B504[] = { 0 }; // weak
int dword_1007B508[] = { 0 }; // weak
char off_1007B50C[32] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1007C110[] = { '\0' }; // weak
char byte_1007C111[] = { '\0' }; // weak
char byte_1007C112[] = { '\0' }; // weak
int dword_1007C114[] = { 0 }; // weak
char *off_1007C118 = "0, 0, 0"; // weak
int dword_1007C5A0[] = { 0 }; // weak
int dword_1007C5A4[] = { 0 }; // weak
int dword_1007C5A8[] = { 0 }; // weak
int dword_1007C5AC[] = { 0 }; // weak
char *off_1007C5B0 = "0, 0, 0"; // weak
int dword_1007CD38[] = { 0 }; // weak
int dword_1007CD3C[] = { 0 }; // weak
int dword_1007CD40[] = { 0 }; // weak
int dword_1007CD44[] = { 0 }; // weak
char off_1007CD48[20] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_1007D0A8[] = { 0 }; // weak
__int16 word_1007D0AA[] = { 0 }; // weak
__int16 word_1007D0AC[] = { 0 }; // weak
int dword_1007D0B0[] = { 0 }; // weak
char *off_1007D0B4 = "0, 0, 0"; // weak
int dword_1007D368[] = { 0 }; // weak
int dword_1007D36C[] = { 0 }; // weak
int dword_1007D370[] = { 0 }; // weak
int dword_1007D374[] = { 0 }; // weak
char off_1007D378[20] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1007D6D8[] = { 0 }; // weak
int dword_1007D6DC[] = { 0 }; // weak
int dword_1007D6E0[] = { 0 }; // weak
int dword_1007D6E4[] = { 0 }; // weak
int dword_1007D6E8[] = { 0 }; // weak
int dword_1007D6EC[] = { 0 }; // weak
int dword_1007D6F0[] = { 0 }; // weak
char off_1007D6F4[32] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1007DC58[] = { '\0' }; // weak
char byte_1007DC59[] = { '\0' }; // weak
char byte_1007DC5A[] = { '\0' }; // weak
int dword_1007DC5C[] = { 0 }; // weak
char *off_1007DC60 = "0, 0, 0"; // weak
int dword_1007DE68[] = { 0 }; // weak
int dword_1007DE6C[] = { 0 }; // weak
int dword_1007DE70[] = { 0 }; // weak
int dword_1007DE74[] = { 0 }; // weak
char off_1007DE78[20] =
{
  '',
  '}',
  '\x06',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_1007EE58; // weak
int dword_10082034[] = { 0 }; // weak
_UNKNOWN off_10082038; // weak
_UNKNOWN unk_100820C8; // weak
_UNKNOWN unk_100820CC; // weak
_UNKNOWN unk_100820D0; // weak
_UNKNOWN unk_100820D4; // weak
_UNKNOWN unk_100820D8; // weak
_UNKNOWN unk_100820DC; // weak
_UNKNOWN unk_100820E0; // weak
_UNKNOWN unk_100820E4; // weak
__int16 word_10083C20[] = { 43 }; // weak
char byte_10083C24[] = { '\x06' }; // weak
char byte_1009B30A[] = { '\x04' }; // weak
char byte_1009B30F[] = { '\a' }; // weak
int dword_100A4408[] = { 0 }; // weak
_UNKNOWN unk_100A5CA0; // weak
int dword_100A5CA4[] = { 3535 }; // weak
_UNKNOWN unk_100A5CD8; // weak
int dword_100A5CDC[] = { 6813 }; // weak
_UNKNOWN unk_100A5D10; // weak
int dword_100A5D14[] = { 9036 }; // weak
_UNKNOWN unk_100A5D48; // weak
int dword_100A5D4C[] = { 6763 }; // weak
int dword_100A80D8[] = { 6103 }; // weak
int dword_100A80DC[] = { 8000 }; // weak
_WORD dword_100B1CB0[512] =
{
  25542,
  42339,
  31992,
  33916,
  30702,
  39287,
  31734,
  36219,
  62207,
  3570,
  27606,
  48491,
  28638,
  45423,
  50577,
  21701,
  12384,
  20528,
  258,
  769,
  26574,
  43367,
  11094,
  32043,
  65255,
  6654,
  55221,
  25303,
  43853,
  59051,
  30444,
  39542,
  51855,
  17866,
  33311,
  40322,
  51593,
  16585,
  32250,
  34685,
  64239,
  5626,
  22962,
  60249,
  18318,
  51527,
  61691,
  3056,
  44353,
  60589,
  54451,
  26580,
  41567,
  64930,
  44869,
  60079,
  39971,
  49052,
  42067,
  63396,
  29412,
  38514,
  49307,
  23488,
  46965,
  49847,
  64993,
  7421,
  37693,
  44691,
  9804,
  27174,
  13932,
  23094,
  16254,
  16703,
  63477,
  759,
  52355,
  20428,
  13416,
  23604,
  42321,
  62629,
  58833,
  13541,
  61945,
  2289,
  29154,
  37745,
  55467,
  29656,
  12642,
  21297,
  5418,
  16149,
  1032,
  3076,
  51093,
  21191,
  9030,
  25891,
  50077,
  24259,
  6192,
  10264,
  38455,
  41366,
  1290,
  3845,
  39471,
  46490,
  1806,
  2311,
  4644,
  13842,
  32795,
  39808,
  58079,
  15842,
  60365,
  9963,
  10062,
  26919,
  45695,
  52658,
  30186,
  40821,
  2322,
  6921,
  33565,
  40579,
  11352,
  29740,
  6708,
  11802,
  6966,
  11547,
  28380,
  45678,
  23220,
  61018,
  41051,
  64416,
  21156,
  63058,
  15222,
  19771,
  54967,
  25046,
  45949,
  52915,
  10578,
  31529,
  58333,
  16099,
  12126,
  28975,
  33811,
  38788,
  21414,
  62803,
  53689,
  26833,
  0,
  0,
  60865,
  11501,
  8256,
  24608,
  64739,
  8188,
  45433,
  51377,
  23478,
  60763,
  27348,
  48746,
  52109,
  18123,
  48743,
  55742,
  14706,
  19257,
  19092,
  56906,
  19608,
  54348,
  22704,
  59480,
  53125,
  19151,
  53435,
  27600,
  61381,
  10991,
  43599,
  58794,
  64493,
  5883,
  17286,
  50499,
  19866,
  55117,
  13158,
  21811,
  34065,
  38021,
  17802,
  53061,
  63977,
  4345,
  516,
  1538,
  32766,
  33151,
  20640,
  61520,
  15480,
  17468,
  40741,
  47775,
  43083,
  58280,
  20898,
  62289,
  41821,
  65187,
  16512,
  49216,
  36613,
  35471,
  37439,
  44434,
  40225,
  48285,
  14448,
  18488,
  62961,
  1269,
  48227,
  57276,
  46711,
  49590,
  55983,
  30170,
  8514,
  25377,
  4128,
  12304,
  65509,
  6911,
  62461,
  3827,
  53951,
  28114,
  52609,
  19661,
  3096,
  5132,
  4902,
  13587,
  60611,
  12268,
  24510,
  57695,
  38709,
  41623,
  17544,
  52292,
  5934,
  14615,
  50323,
  22468,
  42837,
  62119,
  32508,
  33406,
  15738,
  18237,
  25800,
  44132,
  23994,
  59229,
  6450,
  11033,
  29670,
  38259,
  24768,
  41056,
  33049,
  39041,
  20382,
  53583,
  56483,
  32732,
  8772,
  26146,
  10836,
  32298,
  36923,
  43920,
  34827,
  33672,
  18060,
  51782,
  61127,
  10734,
  47211,
  54200,
  5160,
  15380,
  56999,
  31198,
  24252,
  57950,
  2838,
  7435,
  56237,
  30427,
  57563,
  15328,
  12900,
  22066,
  14964,
  20026,
  2580,
  7690,
  18834,
  56137,
  1548,
  2566,
  9288,
  27684,
  23736,
  58460,
  49823,
  24002,
  54205,
  28371,
  44099,
  61356,
  25284,
  42594,
  37177,
  43153,
  38193,
  42133,
  58579,
  14308,
  31218,
  35705,
  59349,
  13031,
  51339,
  17352,
  14190,
  22839,
  28122,
  46957,
  36097,
  35981,
  54705,
  25813,
  20124,
  53838,
  43337,
  57513,
  27864,
  46188,
  22188,
  64086,
  62707,
  2036,
  60111,
  9706,
  26058,
  44901,
  31476,
  36474,
  44615,
  59822,
  2064,
  6152,
  47727,
  54714,
  30960,
  34936,
  9546,
  28453,
  11868,
  29230,
  7224,
  9244,
  42583,
  61862,
  46195,
  51124,
  50839,
  20934,
  59595,
  9192,
  56737,
  31965,
  29928,
  40052,
  7998,
  8479,
  19350,
  56651,
  48481,
  56509,
  35597,
  34443,
  35343,
  34186,
  28896,
  36976,
  15996,
  16958,
  46449,
  50357,
  26316,
  43622,
  18576,
  55368,
  774,
  1283,
  63223,
  502,
  3612,
  4622,
  25026,
  41825,
  13674,
  24373,
  22446,
  63831,
  47465,
  53433,
  34327,
  37254,
  49561,
  22721,
  7482,
  10013,
  40487,
  47518,
  57817,
  14561,
  63723,
  5112,
  38955,
  45976,
  4386,
  13073,
  27090,
  47977,
  55721,
  28889,
  36359,
  35214,
  37939,
  42900,
  39725,
  46747,
  7740,
  8734,
  34581,
  37511,
  59849,
  8425,
  52871,
  18894,
  21930,
  65365,
  10320,
  30760,
  57253,
  31455,
  35843,
  36748,
  41305,
  63649,
  35081,
  32905,
  3354,
  5901,
  48997,
  55999,
  59095,
  12774,
  17028,
  50754,
  26832,
  47208,
  16770,
  49985,
  39209,
  45209,
  11610,
  30509,
  3870,
  4367,
  45179,
  52144,
  21672,
  64596,
  47981,
  54971,
  5676,
  14870
}; // idb
_WORD dword_100B20B0[512] =
{
  50853,
  25443,
  63620,
  31868,
  61081,
  30583,
  63117,
  31611,
  65293,
  62194,
  54973,
  27499,
  57009,
  28527,
  37204,
  50629,
  24656,
  12336,
  515,
  257,
  52905,
  26471,
  22141,
  11051,
  59161,
  65278,
  46434,
  55255,
  19942,
  43947,
  60570,
  30326,
  36677,
  51914,
  8093,
  33410,
  35136,
  51657,
  64135,
  32125,
  61205,
  64250,
  45803,
  22873,
  36553,
  18247,
  64267,
  61680,
  16876,
  44461,
  45927,
  54484,
  24573,
  41634,
  17898,
  44975,
  9151,
  40092,
  21495,
  42148,
  58518,
  29298,
  39771,
  49344,
  30146,
  47031,
  57628,
  65021,
  15790,
  37779,
  19562,
  9766,
  27738,
  13878,
  32321,
  16191,
  62722,
  63479,
  33615,
  52428,
  26716,
  13364,
  20980,
  42405,
  53556,
  58853,
  63752,
  61937,
  58003,
  29041,
  43891,
  55512,
  25171,
  12593,
  10815,
  5397,
  2060,
  1028,
  38226,
  51143,
  18021,
  8995,
  40286,
  50115,
  12328,
  6168,
  14241,
  38550,
  2575,
  1285,
  12213,
  39578,
  3593,
  1799,
  9270,
  4626,
  7067,
  32896,
  57149,
  58082,
  52518,
  60395,
  20073,
  10023,
  32717,
  45746,
  60063,
  30069,
  4635,
  2313,
  7582,
  33667,
  22644,
  11308,
  13358,
  6682,
  13869,
  6939,
  56498,
  28270,
  46318,
  23130,
  23547,
  41120,
  42230,
  21074,
  30285,
  15163,
  46945,
  54998,
  32206,
  46003,
  21115,
  10537,
  56638,
  58339,
  24177,
  12079,
  5015,
  33924,
  42741,
  21331,
  47464,
  53713,
  0,
  0,
  49452,
  60909,
  16480,
  8224,
  58143,
  64764,
  31176,
  45489,
  46829,
  23387,
  54462,
  27242,
  36166,
  52171,
  26585,
  48830,
  29259,
  14649,
  38110,
  19018,
  39124,
  19532,
  45288,
  22616,
  34122,
  53199,
  47979,
  53456,
  50474,
  61423,
  20453,
  43690,
  60694,
  64507,
  34501,
  17219,
  39639,
  19789,
  26197,
  13107,
  4500,
  34181,
  35535,
  17733,
  59664,
  63993,
  1030,
  514,
  65153,
  32639,
  41200,
  20560,
  30788,
  15420,
  9658,
  40863,
  19427,
  43176,
  41715,
  20817,
  24062,
  41891,
  32960,
  16448,
  1418,
  36751,
  16301,
  37522,
  8636,
  40349,
  28744,
  14392,
  61700,
  62965,
  25567,
  48316,
  30657,
  46774,
  44917,
  56026,
  16995,
  8481,
  8240,
  4112,
  58650,
  65535,
  64782,
  62451,
  49005,
  53970,
  33100,
  52685,
  6164,
  3084,
  9781,
  4883,
  49967,
  60652,
  48865,
  24415,
  13730,
  38807,
  35020,
  17476,
  11833,
  5911,
  37719,
  50372,
  22002,
  42919,
  64642,
  32382,
  31303,
  15677,
  51372,
  25700,
  47847,
  23901,
  12843,
  6425,
  59029,
  29555,
  49312,
  24672,
  6552,
  33153,
  40657,
  20303,
  41855,
  56540,
  17510,
  8738,
  21630,
  10794,
  15275,
  37008,
  2947,
  34952,
  36042,
  17990,
  50985,
  61166,
  27603,
  47288,
  10300,
  5140,
  42873,
  57054,
  48354,
  24158,
  5661,
  2827,
  44406,
  56283,
  56123,
  57568,
  25686,
  12850,
  29774,
  14906,
  5150,
  2570,
  37595,
  18761,
  3082,
  1542,
  18540,
  9252,
  47332,
  23644,
  40797,
  49858,
  48494,
  54227,
  17391,
  44204,
  50342,
  25186,
  14760,
  37265,
  12708,
  38293,
  54071,
  58596,
  62091,
  31097,
  54578,
  59367,
  35651,
  51400,
  28249,
  14135,
  55991,
  28013,
  396,
  36237,
  45412,
  54741,
  40146,
  20046,
  18912,
  43433,
  55476,
  27756,
  44282,
  22102,
  62215,
  62708,
  53029,
  60138,
  51887,
  25957,
  62606,
  31354,
  18409,
  44718,
  4120,
  2056,
  28629,
  47802,
  61576,
  30840,
  19055,
  9509,
  23666,
  11822,
  14372,
  7196,
  22513,
  42662,
  29639,
  46260,
  38737,
  50886,
  52003,
  59624,
  41340,
  56797,
  59548,
  29812,
  15905,
  7967,
  38621,
  19275,
  25052,
  48573,
  3462,
  35723,
  3973,
  35466,
  57488,
  28784,
  31810,
  15934,
  29124,
  46517,
  52394,
  26214,
  37080,
  18504,
  1541,
  771,
  63233,
  63222,
  7186,
  3598,
  49827,
  24929,
  27231,
  13621,
  44793,
  22359,
  27088,
  47545,
  6033,
  34438,
  39256,
  49601,
  14887,
  7453,
  10169,
  40606,
  55608,
  57825,
  60179,
  63736,
  11187,
  39064,
  8755,
  4369,
  53947,
  26985,
  43376,
  55769,
  1929,
  36494,
  13223,
  38036,
  11702,
  39835,
  15394,
  7710,
  5522,
  34695,
  51488,
  59881,
  34633,
  52942,
  43775,
  21845,
  20600,
  10280,
  42362,
  57311,
  911,
  35980,
  23032,
  41377,
  2432,
  35209,
  6679,
  3341,
  26074,
  49087,
  55089,
  59110,
  33990,
  16962,
  53432,
  26728,
  33475,
  16705,
  10672,
  39321,
  23159,
  11565,
  7697,
  3855,
  31691,
  45232,
  43260,
  21588,
  28118,
  48059,
  11322,
  5654
}; // idb
_WORD dword_100B24B0[512] =
{
  42339,
  25542,
  33916,
  31992,
  39287,
  30702,
  36219,
  31734,
  3570,
  62207,
  48491,
  27606,
  45423,
  28638,
  21701,
  50577,
  20528,
  12384,
  769,
  258,
  43367,
  26574,
  32043,
  11094,
  6654,
  65255,
  25303,
  55221,
  59051,
  43853,
  39542,
  30444,
  17866,
  51855,
  40322,
  33311,
  16585,
  51593,
  34685,
  32250,
  5626,
  64239,
  60249,
  22962,
  51527,
  18318,
  3056,
  61691,
  60589,
  44353,
  26580,
  54451,
  64930,
  41567,
  60079,
  44869,
  49052,
  39971,
  63396,
  42067,
  38514,
  29412,
  23488,
  49307,
  49847,
  46965,
  7421,
  64993,
  44691,
  37693,
  27174,
  9804,
  23094,
  13932,
  16703,
  16254,
  759,
  63477,
  20428,
  52355,
  23604,
  13416,
  62629,
  42321,
  13541,
  58833,
  2289,
  61945,
  37745,
  29154,
  29656,
  55467,
  21297,
  12642,
  16149,
  5418,
  3076,
  1032,
  21191,
  51093,
  25891,
  9030,
  24259,
  50077,
  10264,
  6192,
  41366,
  38455,
  3845,
  1290,
  46490,
  39471,
  2311,
  1806,
  13842,
  4644,
  39808,
  32795,
  15842,
  58079,
  9963,
  60365,
  26919,
  10062,
  52658,
  45695,
  40821,
  30186,
  6921,
  2322,
  40579,
  33565,
  29740,
  11352,
  11802,
  6708,
  11547,
  6966,
  45678,
  28380,
  61018,
  23220,
  64416,
  41051,
  63058,
  21156,
  19771,
  15222,
  25046,
  54967,
  52915,
  45949,
  31529,
  10578,
  16099,
  58333,
  28975,
  12126,
  38788,
  33811,
  62803,
  21414,
  26833,
  53689,
  0,
  0,
  11501,
  60865,
  24608,
  8256,
  8188,
  64739,
  51377,
  45433,
  60763,
  23478,
  48746,
  27348,
  18123,
  52109,
  55742,
  48743,
  19257,
  14706,
  56906,
  19092,
  54348,
  19608,
  59480,
  22704,
  19151,
  53125,
  27600,
  53435,
  10991,
  61381,
  58794,
  43599,
  5883,
  64493,
  50499,
  17286,
  55117,
  19866,
  21811,
  13158,
  38021,
  34065,
  53061,
  17802,
  4345,
  63977,
  1538,
  516,
  33151,
  32766,
  61520,
  20640,
  17468,
  15480,
  47775,
  40741,
  58280,
  43083,
  62289,
  20898,
  65187,
  41821,
  49216,
  16512,
  35471,
  36613,
  44434,
  37439,
  48285,
  40225,
  18488,
  14448,
  1269,
  62961,
  57276,
  48227,
  49590,
  46711,
  30170,
  55983,
  25377,
  8514,
  12304,
  4128,
  6911,
  65509,
  3827,
  62461,
  28114,
  53951,
  19661,
  52609,
  5132,
  3096,
  13587,
  4902,
  12268,
  60611,
  57695,
  24510,
  41623,
  38709,
  52292,
  17544,
  14615,
  5934,
  22468,
  50323,
  62119,
  42837,
  33406,
  32508,
  18237,
  15738,
  44132,
  25800,
  59229,
  23994,
  11033,
  6450,
  38259,
  29670,
  41056,
  24768,
  39041,
  33049,
  53583,
  20382,
  32732,
  56483,
  26146,
  8772,
  32298,
  10836,
  43920,
  36923,
  33672,
  34827,
  51782,
  18060,
  10734,
  61127,
  54200,
  47211,
  15380,
  5160,
  31198,
  56999,
  57950,
  24252,
  7435,
  2838,
  30427,
  56237,
  15328,
  57563,
  22066,
  12900,
  20026,
  14964,
  7690,
  2580,
  56137,
  18834,
  2566,
  1548,
  27684,
  9288,
  58460,
  23736,
  24002,
  49823,
  28371,
  54205,
  61356,
  44099,
  42594,
  25284,
  43153,
  37177,
  42133,
  38193,
  14308,
  58579,
  35705,
  31218,
  13031,
  59349,
  17352,
  51339,
  22839,
  14190,
  46957,
  28122,
  35981,
  36097,
  25813,
  54705,
  53838,
  20124,
  57513,
  43337,
  46188,
  27864,
  64086,
  22188,
  2036,
  62707,
  9706,
  60111,
  44901,
  26058,
  36474,
  31476,
  59822,
  44615,
  6152,
  2064,
  54714,
  47727,
  34936,
  30960,
  28453,
  9546,
  29230,
  11868,
  9244,
  7224,
  61862,
  42583,
  51124,
  46195,
  20934,
  50839,
  9192,
  59595,
  31965,
  56737,
  40052,
  29928,
  8479,
  7998,
  56651,
  19350,
  56509,
  48481,
  34443,
  35597,
  34186,
  35343,
  36976,
  28896,
  16958,
  15996,
  50357,
  46449,
  43622,
  26316,
  55368,
  18576,
  1283,
  774,
  502,
  63223,
  4622,
  3612,
  41825,
  25026,
  24373,
  13674,
  63831,
  22446,
  53433,
  47465,
  37254,
  34327,
  22721,
  49561,
  10013,
  7482,
  47518,
  40487,
  14561,
  57817,
  5112,
  63723,
  45976,
  38955,
  13073,
  4386,
  47977,
  27090,
  28889,
  55721,
  35214,
  36359,
  42900,
  37939,
  46747,
  39725,
  8734,
  7740,
  37511,
  34581,
  8425,
  59849,
  18894,
  52871,
  65365,
  21930,
  30760,
  10320,
  31455,
  57253,
  36748,
  35843,
  63649,
  41305,
  32905,
  35081,
  5901,
  3354,
  55999,
  48997,
  12774,
  59095,
  50754,
  17028,
  47208,
  26832,
  49985,
  16770,
  45209,
  39209,
  30509,
  11610,
  4367,
  3870,
  52144,
  45179,
  64596,
  21672,
  54971,
  47981,
  14870,
  5676
}; // idb
_WORD dword_100B28B0[512] =
{
  25443,
  50853,
  31868,
  63620,
  30583,
  61081,
  31611,
  63117,
  62194,
  65293,
  27499,
  54973,
  28527,
  57009,
  50629,
  37204,
  12336,
  24656,
  257,
  515,
  26471,
  52905,
  11051,
  22141,
  65278,
  59161,
  55255,
  46434,
  43947,
  19942,
  30326,
  60570,
  51914,
  36677,
  33410,
  8093,
  51657,
  35136,
  32125,
  64135,
  64250,
  61205,
  22873,
  45803,
  18247,
  36553,
  61680,
  64267,
  44461,
  16876,
  54484,
  45927,
  41634,
  24573,
  44975,
  17898,
  40092,
  9151,
  42148,
  21495,
  29298,
  58518,
  49344,
  39771,
  47031,
  30146,
  65021,
  57628,
  37779,
  15790,
  9766,
  19562,
  13878,
  27738,
  16191,
  32321,
  63479,
  62722,
  52428,
  33615,
  13364,
  26716,
  42405,
  20980,
  58853,
  53556,
  61937,
  63752,
  29041,
  58003,
  55512,
  43891,
  12593,
  25171,
  5397,
  10815,
  1028,
  2060,
  51143,
  38226,
  8995,
  18021,
  50115,
  40286,
  6168,
  12328,
  38550,
  14241,
  1285,
  2575,
  39578,
  12213,
  1799,
  3593,
  4626,
  9270,
  32896,
  7067,
  58082,
  57149,
  60395,
  52518,
  10023,
  20073,
  45746,
  32717,
  30069,
  60063,
  2313,
  4635,
  33667,
  7582,
  11308,
  22644,
  6682,
  13358,
  6939,
  13869,
  28270,
  56498,
  23130,
  46318,
  41120,
  23547,
  21074,
  42230,
  15163,
  30285,
  54998,
  46945,
  46003,
  32206,
  10537,
  21115,
  58339,
  56638,
  12079,
  24177,
  33924,
  5015,
  21331,
  42741,
  53713,
  47464,
  0,
  0,
  60909,
  49452,
  8224,
  16480,
  64764,
  58143,
  45489,
  31176,
  23387,
  46829,
  27242,
  54462,
  52171,
  36166,
  48830,
  26585,
  14649,
  29259,
  19018,
  38110,
  19532,
  39124,
  22616,
  45288,
  53199,
  34122,
  53456,
  47979,
  61423,
  50474,
  43690,
  20453,
  64507,
  60694,
  17219,
  34501,
  19789,
  39639,
  13107,
  26197,
  34181,
  4500,
  17733,
  35535,
  63993,
  59664,
  514,
  1030,
  32639,
  65153,
  20560,
  41200,
  15420,
  30788,
  40863,
  9658,
  43176,
  19427,
  20817,
  41715,
  41891,
  24062,
  16448,
  32960,
  36751,
  1418,
  37522,
  16301,
  40349,
  8636,
  14392,
  28744,
  62965,
  61700,
  48316,
  25567,
  46774,
  30657,
  56026,
  44917,
  8481,
  16995,
  4112,
  8240,
  65535,
  58650,
  62451,
  64782,
  53970,
  49005,
  52685,
  33100,
  3084,
  6164,
  4883,
  9781,
  60652,
  49967,
  24415,
  48865,
  38807,
  13730,
  17476,
  35020,
  5911,
  11833,
  50372,
  37719,
  42919,
  22002,
  32382,
  64642,
  15677,
  31303,
  25700,
  51372,
  23901,
  47847,
  6425,
  12843,
  29555,
  59029,
  24672,
  49312,
  33153,
  6552,
  20303,
  40657,
  56540,
  41855,
  8738,
  17510,
  10794,
  21630,
  37008,
  15275,
  34952,
  2947,
  17990,
  36042,
  61166,
  50985,
  47288,
  27603,
  5140,
  10300,
  57054,
  42873,
  24158,
  48354,
  2827,
  5661,
  56283,
  44406,
  57568,
  56123,
  12850,
  25686,
  14906,
  29774,
  2570,
  5150,
  18761,
  37595,
  1542,
  3082,
  9252,
  18540,
  23644,
  47332,
  49858,
  40797,
  54227,
  48494,
  44204,
  17391,
  25186,
  50342,
  37265,
  14760,
  38293,
  12708,
  58596,
  54071,
  31097,
  62091,
  59367,
  54578,
  51400,
  35651,
  14135,
  28249,
  28013,
  55991,
  36237,
  396,
  54741,
  45412,
  20046,
  40146,
  43433,
  18912,
  27756,
  55476,
  22102,
  44282,
  62708,
  62215,
  60138,
  53029,
  25957,
  51887,
  31354,
  62606,
  44718,
  18409,
  2056,
  4120,
  47802,
  28629,
  30840,
  61576,
  9509,
  19055,
  11822,
  23666,
  7196,
  14372,
  42662,
  22513,
  46260,
  29639,
  50886,
  38737,
  59624,
  52003,
  56797,
  41340,
  29812,
  59548,
  7967,
  15905,
  19275,
  38621,
  48573,
  25052,
  35723,
  3462,
  35466,
  3973,
  28784,
  57488,
  15934,
  31810,
  46517,
  29124,
  26214,
  52394,
  18504,
  37080,
  771,
  1541,
  63222,
  63233,
  3598,
  7186,
  24929,
  49827,
  13621,
  27231,
  22359,
  44793,
  47545,
  27088,
  34438,
  6033,
  49601,
  39256,
  7453,
  14887,
  40606,
  10169,
  57825,
  55608,
  63736,
  60179,
  39064,
  11187,
  4369,
  8755,
  26985,
  53947,
  55769,
  43376,
  36494,
  1929,
  38036,
  13223,
  39835,
  11702,
  7710,
  15394,
  34695,
  5522,
  59881,
  51488,
  52942,
  34633,
  21845,
  43775,
  10280,
  20600,
  57311,
  42362,
  35980,
  911,
  41377,
  23032,
  35209,
  2432,
  3341,
  6679,
  49087,
  26074,
  59110,
  55089,
  16962,
  33990,
  26728,
  53432,
  16705,
  33475,
  39321,
  10672,
  11565,
  23159,
  3855,
  7697,
  45232,
  31691,
  21588,
  43260,
  48059,
  28118,
  5654,
  11322
}; // idb
int dword_100B2CB0[] = { 99 }; // weak
int dword_100B30B0[] = { 25344 }; // weak
int dword_100B34B0[] = { 6488064 }; // weak
int dword_100B38B0[] = { 1660944384 }; // weak
int dword_100B3CD8[] = { 128 }; // weak
int dword_100B3CE8[] = { 0 }; // weak
int dword_100B3CF8[] = { 0 }; // weak
char byte_100B3D69[] = { '\0' }; // weak
char byte_100B3D6A[] = { '\0' }; // weak
char byte_100B3D6B[] = { '\0' }; // weak
char byte_100B3D6C[] = { '\x10' }; // weak
int dword_100B3D80[] = { 0 }; // weak
_UNKNOWN unk_100B3DF8; // weak
_UNKNOWN unk_100B4278; // weak
char byte_100B42F0[] = { '\0' }; // weak
char byte_100B43F0[] = { '\0' }; // weak
char byte_100B44F0[] = { '\0' }; // weak
int dword_100B45F0[] = { 0 }; // weak
int dword_100B4668[] = { 0 }; // weak
int (__cdecl *off_100B46E8)(int, int) = &sub_1003FF30; // weak
int dword_100B48D0[] = { 0 }; // weak
int dword_100B4918[] = { 16 }; // weak
_UNKNOWN unk_100B4968; // weak
_UNKNOWN unk_100B49E8; // weak
_UNKNOWN unk_100B4A68; // weak
_UNKNOWN unk_100B4AE0; // weak
_UNKNOWN unk_100B4B58; // weak
_UNKNOWN unk_100B5B58; // weak
_UNKNOWN unk_100B5CB0; // weak
_UNKNOWN unk_100B5CB8; // weak
int (*off_100B7264)() = &_fptrap; // weak
_UNKNOWN unk_100B7310; // weak
void *off_100B7ED0 = &unk_101761C0; // weak
_UNKNOWN unk_100B7EE0; // weak
_UNKNOWN unk_100B7F40; // weak
int dword_100B8150 = 9876; // weak
int dword_100B825C = 1024; // weak
int dword_100B8260 = 4294966273; // weak
int dword_100B8264 = 53; // weak
int dword_100B8268 = 11; // weak
int dword_100B826C = 64; // weak
int dword_100B8270 = 1023; // weak
int dword_100B8274 = 128; // weak
int dword_100B8278 = 4294967169; // weak
int dword_100B827C = 24; // weak
int dword_100B8280 = 8; // weak
int dword_100B8284 = 32; // weak
int dword_100B8288 = 127; // weak
int dword_100B8820 = 0; // weak
int dword_100B8828 = 0; // weak
int dword_100B882C = 0; // weak
int dword_100B8830 = 0; // weak
int dword_100B8834 = 0; // weak
int dword_100B8838 = 0; // weak
int dword_100B883C = 0; // weak
int dword_100B8840 = 0; // weak
int dword_100B8844 = 0; // weak
int dword_100B8848 = 0; // weak
int dword_100B884C = 0; // weak
int dword_100B8850 = 0; // weak
int dword_100B8854 = 0; // weak
int dword_100B8858 = 0; // weak
int dword_100B885C = 0; // weak
_UNKNOWN unk_100B8860; // weak
_UNKNOWN unk_100B8861; // weak
_UNKNOWN unk_100B8877; // weak
_UNKNOWN unk_100B8878; // weak
_UNKNOWN unk_100B8879; // weak
_UNKNOWN unk_100B887A; // weak
_UNKNOWN unk_100B887C; // weak
_UNKNOWN unk_100B8880; // weak
_UNKNOWN unk_100B8884; // weak
_UNKNOWN unk_100B88A4; // weak
_UNKNOWN unk_100B88C4; // weak
_UNKNOWN unk_100B88E4; // weak
_UNKNOWN unk_100B8904; // weak
_UNKNOWN unk_100B8924; // weak
_UNKNOWN unk_100B8944; // weak
_UNKNOWN unk_100B8964; // weak
_UNKNOWN unk_100B8984; // weak
_UNKNOWN unk_100B89A4; // weak
_UNKNOWN unk_100B89C4; // weak
_UNKNOWN unk_100B89E4; // weak
_UNKNOWN unk_100B8A04; // weak
_UNKNOWN unk_100B8A24; // weak
_UNKNOWN unk_100B8A44; // weak
_UNKNOWN unk_100B8A64; // weak
_UNKNOWN unk_100B8A84; // weak
_UNKNOWN unk_100B8AA4; // weak
_UNKNOWN unk_100B8AC4; // weak
_UNKNOWN unk_100B8AE4; // weak
_UNKNOWN unk_100B8B04; // weak
_UNKNOWN unk_100B8B24; // weak
_UNKNOWN unk_100B8B44; // weak
_UNKNOWN unk_100B8B64; // weak
_UNKNOWN unk_100B8B84; // weak
_UNKNOWN unk_100B8BA4; // weak
_UNKNOWN unk_100B8BC4; // weak
_UNKNOWN unk_100B8BE4; // weak
_UNKNOWN unk_100B8C04; // weak
_UNKNOWN unk_100B8C08; // weak
_UNKNOWN unk_100B8C0C; // weak
_UNKNOWN unk_100B8C10; // weak
_UNKNOWN unk_100B8C14; // weak
_UNKNOWN unk_100B8C18; // weak
_UNKNOWN unk_100B8C1C; // weak
_UNKNOWN unk_100B8C3C; // weak
_UNKNOWN unk_100B8C5C; // weak
_UNKNOWN unk_100B8C7C; // weak
_UNKNOWN unk_100B8C9C; // weak
_UNKNOWN unk_100B8CBC; // weak
_UNKNOWN unk_100B8CDC; // weak
_UNKNOWN unk_100B8CFC; // weak
_UNKNOWN unk_100B8D1C; // weak
_UNKNOWN unk_100B8D1D; // weak
_UNKNOWN unk_100B8D1E; // weak
_UNKNOWN unk_100B8D70; // weak
_UNKNOWN unk_100B8D90; // weak
_UNKNOWN unk_100B8DB0; // weak
_UNKNOWN unk_100B8DB4; // weak
_UNKNOWN unk_100B8DB8; // weak
_UNKNOWN unk_100B8DBC; // weak
_UNKNOWN unk_100B8DDC; // weak
_UNKNOWN unk_100B8DFC; // weak
_UNKNOWN unk_100B8E1C; // weak
_UNKNOWN unk_100B8E3C; // weak
_UNKNOWN unk_100B8E5C; // weak
_UNKNOWN unk_100B8E7C; // weak
_UNKNOWN unk_100B8E9C; // weak
_UNKNOWN unk_100B8EBC; // weak
_UNKNOWN unk_100B8EDC; // weak
_UNKNOWN unk_100B8F24; // weak
_UNKNOWN unk_100B8F6C; // weak
_UNKNOWN unk_100B8FB4; // weak
_UNKNOWN unk_100B8FFC; // weak
_UNKNOWN unk_100B9044; // weak
_UNKNOWN unk_100B908C; // weak
_UNKNOWN unk_100B90D4; // weak
_UNKNOWN unk_100B911C; // weak
_UNKNOWN unk_100B9164; // weak
_UNKNOWN unk_100B91AC; // weak
_UNKNOWN unk_100B91F4; // weak
_UNKNOWN unk_100B923C; // weak
_UNKNOWN unk_100B9284; // weak
_UNKNOWN unk_100B92CC; // weak
_UNKNOWN unk_100B9314; // weak
_UNKNOWN unk_100B935C; // weak
_UNKNOWN unk_100B93A4; // weak
_UNKNOWN unk_100B93EC; // weak
_UNKNOWN unk_100B9434; // weak
_UNKNOWN unk_100B947C; // weak
_UNKNOWN unk_100B94C4; // weak
_UNKNOWN unk_100B950C; // weak
_UNKNOWN unk_100B9554; // weak
_UNKNOWN unk_100B959C; // weak
_UNKNOWN unk_100B95E4; // weak
_UNKNOWN unk_100B962C; // weak
_UNKNOWN unk_100B9674; // weak
_UNKNOWN unk_100B96BC; // weak
_UNKNOWN unk_100B9704; // weak
_UNKNOWN unk_100B974C; // weak
_UNKNOWN unk_100B9764; // weak
_UNKNOWN unk_100B9784; // weak
_UNKNOWN unk_100B97A4; // weak
_UNKNOWN unk_100B97A8; // weak
_UNKNOWN unk_100B984C; // weak
_UNKNOWN unk_100B98F0; // weak
_UNKNOWN unk_100B9994; // weak
_UNKNOWN unk_100B9A38; // weak
_UNKNOWN unk_100B9ADC; // weak
_UNKNOWN unk_100B9B80; // weak
_UNKNOWN unk_100B9C24; // weak
_UNKNOWN unk_100B9CC8; // weak
_UNKNOWN unk_100B9D6C; // weak
_UNKNOWN unk_100B9E10; // weak
_UNKNOWN unk_100B9EB4; // weak
_UNKNOWN unk_100B9F58; // weak
_UNKNOWN unk_100B9FFC; // weak
_UNKNOWN unk_100BA0A0; // weak
_UNKNOWN unk_100BA144; // weak
_UNKNOWN unk_100BA1E8; // weak
_UNKNOWN unk_100BA28C; // weak
_UNKNOWN unk_100BA330; // weak
_UNKNOWN unk_100BA3D4; // weak
_UNKNOWN unk_100BA478; // weak
_UNKNOWN unk_100BA51C; // weak
_UNKNOWN unk_100BA5C0; // weak
_UNKNOWN unk_100BA664; // weak
_UNKNOWN unk_100BA708; // weak
_UNKNOWN unk_100BA7AC; // weak
_UNKNOWN unk_100BA850; // weak
_UNKNOWN unk_100BA8F4; // weak
_UNKNOWN unk_100BA998; // weak
_UNKNOWN unk_100BAA3C; // weak
_UNKNOWN unk_100BAAE0; // weak
_UNKNOWN unk_100BAB84; // weak
_UNKNOWN unk_100BAC28; // weak
_UNKNOWN unk_100BACCC; // weak
_UNKNOWN unk_100BAD70; // weak
_UNKNOWN unk_100BAE14; // weak
_UNKNOWN unk_100BAEB8; // weak
_UNKNOWN unk_100BAF5C; // weak
_UNKNOWN unk_100BB000; // weak
_UNKNOWN unk_100BB0A4; // weak
_UNKNOWN unk_100BB148; // weak
_UNKNOWN unk_100BB1EC; // weak
_UNKNOWN unk_100BB290; // weak
_UNKNOWN unk_100BB334; // weak
_UNKNOWN unk_100BB3D8; // weak
_UNKNOWN unk_100BB47C; // weak
_UNKNOWN unk_100BB520; // weak
_UNKNOWN unk_100BB5C4; // weak
_UNKNOWN unk_100BB668; // weak
_UNKNOWN unk_100BB70C; // weak
_UNKNOWN unk_100BB7B0; // weak
_UNKNOWN unk_100BB854; // weak
_UNKNOWN unk_100BB8F8; // weak
_UNKNOWN unk_100BB99C; // weak
_UNKNOWN unk_100BBA40; // weak
_UNKNOWN unk_100BBAE4; // weak
_UNKNOWN unk_100BBB88; // weak
_UNKNOWN unk_100BBC2C; // weak
_UNKNOWN unk_100BBCD0; // weak
_UNKNOWN unk_100BBD74; // weak
_UNKNOWN unk_100BBE18; // weak
_UNKNOWN unk_100BBEBC; // weak
_UNKNOWN unk_100BBF60; // weak
_UNKNOWN unk_100BC004; // weak
_UNKNOWN unk_100BC0A8; // weak
_UNKNOWN unk_100BC14C; // weak
_UNKNOWN unk_100BC1F0; // weak
_UNKNOWN unk_100BC294; // weak
_UNKNOWN unk_100BC338; // weak
_UNKNOWN unk_100BC3DC; // weak
_UNKNOWN unk_100BC480; // weak
_UNKNOWN unk_100BC524; // weak
_UNKNOWN unk_100BC5C8; // weak
_UNKNOWN unk_100BC66C; // weak
_UNKNOWN unk_100BC710; // weak
_UNKNOWN unk_100BC7B4; // weak
_UNKNOWN unk_100BC858; // weak
_UNKNOWN unk_100BC8FC; // weak
_UNKNOWN unk_100BC9A0; // weak
_UNKNOWN unk_100BCA44; // weak
_UNKNOWN unk_100BCAE8; // weak
_UNKNOWN unk_100BCB8C; // weak
_UNKNOWN unk_100BCC30; // weak
_UNKNOWN unk_100BCCD4; // weak
_UNKNOWN unk_100BCD78; // weak
_UNKNOWN unk_100BCE1C; // weak
_UNKNOWN unk_100BCEC0; // weak
_UNKNOWN unk_100BCF64; // weak
_UNKNOWN unk_100BD008; // weak
_UNKNOWN unk_100BD0AC; // weak
_UNKNOWN unk_100BD150; // weak
_UNKNOWN unk_100BD1F4; // weak
_UNKNOWN unk_100BD298; // weak
_UNKNOWN unk_100BD33C; // weak
_UNKNOWN unk_100BD3E0; // weak
_UNKNOWN unk_100BD484; // weak
_UNKNOWN unk_100BD528; // weak
_UNKNOWN unk_100BD5CC; // weak
_UNKNOWN unk_100BD670; // weak
_UNKNOWN unk_100BD714; // weak
_UNKNOWN unk_100BD7B8; // weak
_UNKNOWN unk_100BD7D8; // weak
_UNKNOWN unk_100BD7F8; // weak
_UNKNOWN unk_100BD818; // weak
_UNKNOWN unk_100BD838; // weak
_UNKNOWN unk_100BD860; // weak
_UNKNOWN unk_100BD87C; // weak
_UNKNOWN unk_100BD898; // weak
_UNKNOWN unk_100BD8B4; // weak
_UNKNOWN unk_100BD8D0; // weak
_UNKNOWN unk_100BD8EC; // weak
_UNKNOWN unk_100BD908; // weak
_UNKNOWN unk_100BD924; // weak
_UNKNOWN unk_100BD940; // weak
_UNKNOWN unk_100BD95C; // weak
_UNKNOWN unk_100BD978; // weak
_UNKNOWN unk_100BD994; // weak
_UNKNOWN unk_100BD9B0; // weak
_UNKNOWN unk_100BD9CC; // weak
_UNKNOWN unk_100BD9E8; // weak
_UNKNOWN unk_100BDA04; // weak
_UNKNOWN unk_100BDA20; // weak
_UNKNOWN unk_100BDA3C; // weak
_UNKNOWN unk_100BDA58; // weak
_UNKNOWN unk_100BDA74; // weak
_UNKNOWN unk_100BDA90; // weak
_UNKNOWN unk_100BDAAC; // weak
_UNKNOWN unk_100BDAC8; // weak
_UNKNOWN unk_100BDAE4; // weak
_UNKNOWN unk_100BDB00; // weak
_UNKNOWN unk_100BDB1C; // weak
_UNKNOWN unk_100BDB38; // weak
_UNKNOWN unk_100BDB54; // weak
_UNKNOWN unk_100BDB70; // weak
_UNKNOWN unk_100BDB8C; // weak
_UNKNOWN unk_100BDBA8; // weak
_UNKNOWN unk_100BDBC4; // weak
_UNKNOWN unk_100BDBE0; // weak
_UNKNOWN unk_100BDBFC; // weak
_UNKNOWN unk_100BDC18; // weak
_UNKNOWN unk_100BDC34; // weak
_UNKNOWN unk_100BDC50; // weak
_UNKNOWN unk_100BDC6C; // weak
_UNKNOWN unk_100BDC88; // weak
_UNKNOWN unk_100BDCA4; // weak
_UNKNOWN unk_100BDCC0; // weak
_UNKNOWN unk_100BDCDC; // weak
_UNKNOWN unk_100BDCF8; // weak
_UNKNOWN unk_100BDD14; // weak
_UNKNOWN unk_100BDD30; // weak
_UNKNOWN unk_100BDD4C; // weak
_UNKNOWN unk_100BDD68; // weak
_UNKNOWN unk_100BDD84; // weak
_UNKNOWN unk_100BDDA0; // weak
_UNKNOWN unk_100BDDBC; // weak
_UNKNOWN unk_100BDDD8; // weak
_UNKNOWN unk_100BDDF4; // weak
_UNKNOWN unk_100BDE10; // weak
_UNKNOWN unk_100BDE2C; // weak
_UNKNOWN unk_100BDE48; // weak
_UNKNOWN unk_100BDE64; // weak
_UNKNOWN unk_100BDE80; // weak
_UNKNOWN unk_100BDE9C; // weak
_UNKNOWN unk_100BDEB8; // weak
_UNKNOWN unk_100BDED4; // weak
_UNKNOWN unk_100BDEF0; // weak
_UNKNOWN unk_100BDF0C; // weak
_UNKNOWN unk_100BDF28; // weak
_UNKNOWN unk_100BDF44; // weak
_UNKNOWN unk_100BDF60; // weak
_UNKNOWN unk_100BDF7C; // weak
_UNKNOWN unk_100BDF98; // weak
_UNKNOWN unk_100BDFB4; // weak
_UNKNOWN unk_100BDFD0; // weak
_UNKNOWN unk_100BDFEC; // weak
_UNKNOWN unk_100BE008; // weak
_UNKNOWN unk_100BE024; // weak
_UNKNOWN unk_100BE040; // weak
_UNKNOWN unk_100BE05C; // weak
_UNKNOWN unk_100BE078; // weak
_UNKNOWN unk_100BE094; // weak
_UNKNOWN unk_100BE0B0; // weak
_UNKNOWN unk_100BE0CC; // weak
_UNKNOWN unk_100BE0E8; // weak
_UNKNOWN unk_100BE104; // weak
_UNKNOWN unk_100BE120; // weak
_UNKNOWN unk_100BE13C; // weak
_UNKNOWN unk_100BE158; // weak
_UNKNOWN unk_100BE174; // weak
_UNKNOWN unk_100BE190; // weak
_UNKNOWN unk_100BE1AC; // weak
_UNKNOWN unk_100BE1C8; // weak
_UNKNOWN unk_100BE1E4; // weak
_UNKNOWN unk_100BE200; // weak
_UNKNOWN unk_100BE21C; // weak
_UNKNOWN unk_100BE238; // weak
_UNKNOWN unk_100BE254; // weak
_UNKNOWN unk_100BE270; // weak
_UNKNOWN unk_100BE28C; // weak
_UNKNOWN unk_100BE2A8; // weak
_UNKNOWN unk_100BE2C4; // weak
_UNKNOWN unk_100BE2E0; // weak
_UNKNOWN unk_100BE2FC; // weak
_UNKNOWN unk_100BE318; // weak
_UNKNOWN unk_100BE334; // weak
_UNKNOWN unk_100BE350; // weak
_UNKNOWN unk_100BE354; // weak
_UNKNOWN unk_100BE358; // weak
_UNKNOWN unk_100BE35C; // weak
_UNKNOWN unk_100BE360; // weak
_UNKNOWN unk_100BE364; // weak
_UNKNOWN unk_100BE368; // weak
_UNKNOWN unk_100BE36C; // weak
_UNKNOWN unk_100BE370; // weak
_UNKNOWN unk_100BE374; // weak
_UNKNOWN unk_100BE378; // weak
_UNKNOWN unk_100BE37C; // weak
_UNKNOWN unk_100BE380; // weak
_UNKNOWN unk_100BE384; // weak
_UNKNOWN unk_100BE388; // weak
_UNKNOWN unk_100BE38C; // weak
_UNKNOWN unk_100BE390; // weak
_UNKNOWN unk_100BE394; // weak
_UNKNOWN unk_100BE398; // weak
_UNKNOWN unk_100BE47C; // weak
_UNKNOWN unk_100BF63C; // weak
_UNKNOWN unk_100BF640; // weak
_UNKNOWN unk_100BF668; // weak
_UNKNOWN unk_100BF690; // weak
_UNKNOWN unk_100BF6D0; // weak
_UNKNOWN unk_100BF750; // weak
_UNKNOWN unk_100BF754; // weak
_UNKNOWN unk_100BF758; // weak
_UNKNOWN unk_100BF75A; // weak
_UNKNOWN unk_100BF75C; // weak
_UNKNOWN unk_100BF75D; // weak
_UNKNOWN unk_100BF75E; // weak
_UNKNOWN unk_100BF760; // weak
_UNKNOWN unk_100BF7C4; // weak
_UNKNOWN unk_100BF7CC; // weak
_UNKNOWN unk_100BF7D4; // weak
_UNKNOWN unk_100BF7DC; // weak
_UNKNOWN unk_100BF7E4; // weak
_UNKNOWN unk_100BF7EC; // weak
_UNKNOWN unk_100BF7F4; // weak
_UNKNOWN unk_100BF7FC; // weak
_UNKNOWN unk_100BF804; // weak
_UNKNOWN unk_100BF80C; // weak
_UNKNOWN unk_100BF814; // weak
_UNKNOWN unk_100BF81C; // weak
_UNKNOWN unk_100BF824; // weak
_UNKNOWN unk_100BF82C; // weak
_UNKNOWN unk_100BF834; // weak
_UNKNOWN unk_100BF83C; // weak
_UNKNOWN unk_100BF844; // weak
_UNKNOWN unk_100BF84C; // weak
_UNKNOWN unk_100BF854; // weak
_UNKNOWN unk_100BF85C; // weak
_UNKNOWN unk_100BF864; // weak
_UNKNOWN unk_100BF86C; // weak
_UNKNOWN unk_100BF874; // weak
_UNKNOWN unk_100BF87C; // weak
_UNKNOWN unk_100BF884; // weak
_UNKNOWN unk_100BF88C; // weak
_UNKNOWN unk_100BF894; // weak
_UNKNOWN unk_100BF89C; // weak
_UNKNOWN unk_100BF8A4; // weak
_UNKNOWN unk_100BF8AC; // weak
_UNKNOWN unk_100BF8B4; // weak
_UNKNOWN unk_100BF8BC; // weak
_UNKNOWN unk_100BF8C4; // weak
_UNKNOWN unk_100BF8CC; // weak
_UNKNOWN unk_100BF8D4; // weak
_UNKNOWN unk_100BF8DC; // weak
_UNKNOWN unk_100BF8E4; // weak
_UNKNOWN unk_100BF8EC; // weak
_UNKNOWN unk_100BF8F4; // weak
_UNKNOWN unk_100BF8FC; // weak
_UNKNOWN unk_100BFAE4; // weak
_UNKNOWN unk_100BFAF4; // weak
_UNKNOWN unk_100BFB04; // weak
_UNKNOWN unk_100BFB14; // weak
_UNKNOWN unk_100BFB15; // weak
_UNKNOWN unk_100BFB16; // weak
_UNKNOWN unk_100BFB18; // weak
_UNKNOWN unk_100BFB1C; // weak
_UNKNOWN unk_100BFBC4; // weak
_UNKNOWN unk_100BFBC8; // weak
_UNKNOWN unk_100BFBCC; // weak
_UNKNOWN unk_100BFC1C; // weak
_UNKNOWN unk_100BFC20; // weak
_UNKNOWN unk_100BFC24; // weak
_UNKNOWN unk_100BFD14; // weak
_UNKNOWN unk_100BFE04; // weak
_UNKNOWN unk_100BFE08; // weak
_UNKNOWN unk_100BFE10; // weak
_UNKNOWN unk_100BFE18; // weak
_UNKNOWN unk_100BFE20; // weak
_UNKNOWN unk_100BFE28; // weak
_UNKNOWN unk_100BFE30; // weak
_UNKNOWN unk_100BFE38; // weak
_UNKNOWN unk_100BFE40; // weak
_UNKNOWN unk_100BFE48; // weak
_UNKNOWN unk_100BFE50; // weak
_UNKNOWN unk_100BFE58; // weak
_UNKNOWN unk_100BFE60; // weak
_UNKNOWN unk_100BFE64; // weak
_UNKNOWN unk_100BFE68; // weak
_UNKNOWN unk_100BFE6C; // weak
_UNKNOWN unk_100BFEC0; // weak
_UNKNOWN unk_100BFF14; // weak
_UNKNOWN unk_100BFF1C; // weak
_UNKNOWN unk_100BFF20; // weak
_UNKNOWN unk_100BFF24; // weak
_UNKNOWN unk_100BFF28; // weak
_UNKNOWN unk_100BFF2C; // weak
_UNKNOWN unk_100C0134; // weak
_UNKNOWN unk_100C0294; // weak
_UNKNOWN unk_100C02AC; // weak
_UNKNOWN unk_100C02C4; // weak
_UNKNOWN unk_100C02CE; // weak
_UNKNOWN unk_100C02D0; // weak
_UNKNOWN unk_100C02E0; // weak
_UNKNOWN unk_100C02E4; // weak
_UNKNOWN unk_100C02E8; // weak
_UNKNOWN unk_100C02EC; // weak
_UNKNOWN unk_100C02ED; // weak
_UNKNOWN unk_100C02F0; // weak
_UNKNOWN unk_100C0340; // weak
_UNKNOWN unk_100C0344; // weak
_UNKNOWN unk_100C0345; // weak
_UNKNOWN unk_100C0346; // weak
_UNKNOWN unk_100C0347; // weak
_UNKNOWN unk_100C035B; // weak
_UNKNOWN unk_100C035C; // weak
_UNKNOWN unk_100C035D; // weak
_UNKNOWN unk_100C035E; // weak
_UNKNOWN unk_100C0360; // weak
_UNKNOWN unk_100C0400; // weak
_UNKNOWN unk_100C0450; // weak
_UNKNOWN unk_100C0454; // weak
_UNKNOWN unk_100C0458; // weak
_UNKNOWN unk_100C045C; // weak
_UNKNOWN unk_100C0460; // weak
_UNKNOWN unk_100C0464; // weak
_UNKNOWN unk_100C0468; // weak
_UNKNOWN unk_100C046C; // weak
_UNKNOWN unk_100C0470; // weak
_UNKNOWN unk_100C0474; // weak
_UNKNOWN unk_100C0478; // weak
_UNKNOWN unk_100C047C; // weak
_UNKNOWN unk_100C0480; // weak
_UNKNOWN unk_100C05C0; // weak
_UNKNOWN unk_100C05CC; // weak
_UNKNOWN unk_100C0614; // weak
_UNKNOWN unk_100C0615; // weak
_UNKNOWN unk_100C0640; // weak
_UNKNOWN unk_100C0670; // weak
_UNKNOWN unk_100C0698; // weak
_UNKNOWN unk_100C069C; // weak
_UNKNOWN unk_100C06A0; // weak
_UNKNOWN unk_100C06A4; // weak
_UNKNOWN unk_100C06D4; // weak
_UNKNOWN unk_100C06D5; // weak
_UNKNOWN unk_100C06D6; // weak
_UNKNOWN unk_100C06D8; // weak
_UNKNOWN unk_100C06DC; // weak
_UNKNOWN unk_100C06E0; // weak
_UNKNOWN unk_100C06E4; // weak
_UNKNOWN unk_100C06E8; // weak
_UNKNOWN unk_100C06EC; // weak
_UNKNOWN unk_100C06F0; // weak
_UNKNOWN unk_100C06F4; // weak
_UNKNOWN unk_100C06F8; // weak
_UNKNOWN unk_100C06FC; // weak
_UNKNOWN unk_100C0A5C; // weak
_UNKNOWN unk_100C0A60; // weak
_UNKNOWN unk_100C0A6A; // weak
_UNKNOWN unk_100C0A74; // weak
_UNKNOWN unk_100C2230; // weak
_UNKNOWN unk_100C2234; // weak
int dword_100C2238; // weak
char byte_100C223C; // weak
char byte_100C223D; // weak
int dword_100C2240[]; // weak
char byte_100C4AE8[]; // weak
char byte_100C4AE9[]; // weak
_UNKNOWN unk_100C4B88; // weak
int dword_100C4E58[]; // weak
int dword_100C4E5C[]; // weak
_UNKNOWN unk_100C5378; // weak
_UNKNOWN unk_100C8280; // weak
_UNKNOWN unk_100C8780; // weak
_UNKNOWN unk_100C8828; // weak
char byte_100C8848; // weak
char byte_100C8849; // weak
char byte_100C884A; // weak
char byte_100C884B; // weak
_UNKNOWN unk_100C8850; // weak
_UNKNOWN unk_100C8870; // weak
int dword_100C8890; // weak
_UNKNOWN unk_100C8898; // weak
int dword_100C9DD8; // weak
char byte_100C9DE0[]; // weak
char byte_100C9DE4[]; // weak
char byte_100C9DE5[]; // weak
int dword_100C9DEC[]; // weak
int dword_100C9DF4[]; // weak
int dword_100C9E30[]; // weak
int dword_100C9E34; // weak
int dword_100C9E38; // weak
int dword_100C9E3C; // weak
int dword_100C9E40; // weak
int dword_100C9E44[]; // weak
int dword_100C9E48; // weak
int dword_100C9E4C; // weak
int dword_100C9E50; // weak
int dword_100C9E54; // weak
_UNKNOWN unk_100C9E58; // weak
char byte_100C9F70; // idb
char byte_100CA070[254]; // idb
char byte_100CA16E[]; // weak
char byte_100CA16F[]; // weak
char byte_100CA570[2800]; // idb
char byte_100CB060[1022]; // idb
char byte_100CB45E[]; // weak
char byte_100CB45F[]; // weak
char byte_100CB460[1022]; // idb
char byte_100CB85E[]; // weak
char byte_100CB85F[]; // weak
char byte_100CB860[1022]; // idb
char byte_100CBC5E[]; // weak
char byte_100CBC5F[]; // weak
int dword_100CEC60[]; // weak
int dword_100CEC74[]; // weak
char byte_100CEC88[2800]; // idb
char byte_100CF778[2800]; // idb
char byte_100D0268[2800]; // idb
int dword_100D0D58[]; // weak
int dword_100D0D6C[]; // weak
char byte_100D0D80[2796]; // idb
char byte_100D186C[]; // weak
char byte_100D1870[559]; // idb
char byte_100D1A9F[]; // weak
int dword_100D2360[]; // weak
int dword_100D2374[]; // weak
char byte_100D2388[2800]; // idb
int dword_100D2E78; // weak
_UNKNOWN unk_100D2E80; // weak
_UNKNOWN unk_100D39D8; // weak
int dword_100D5D60; // weak
_UNKNOWN unk_100D5D68; // weak
char byte_100D6040[]; // weak
char byte_100D6041[]; // weak
_UNKNOWN unk_100D72A8; // weak
_UNKNOWN unk_100D8C58; // weak
int dword_100D8D08; // weak
char byte_100D8D10[]; // weak
char byte_100D8D60[]; // weak
char byte_100E00B0; // weak
char byte_100E00B1; // weak
_DWORD dword_10153648[16]; // idb
int dword_10153688[]; // weak
int dword_101536C8; // weak
int dword_101536D0[]; // weak
int dword_10153740; // weak
int dword_10153A70; // weak
int dword_10153A7C; // weak
int dword_10153C1C; // weak
int dword_101540A0; // weak
int dword_101540AC; // weak
int dword_101540B8; // weak
int dword_101540BC; // weak
int dword_101540C0; // weak
int dword_101540DC; // weak
int dword_101540E0; // weak
int dword_101540E4; // weak
int dword_101540E8; // weak
int dword_101540EC; // weak
char byte_101618F8; // weak
_UNKNOWN unk_10161900; // weak
__int16 word_1016CB20[]; // weak
__int16 word_1016CB22[]; // weak
int dword_1016CB50; // weak
__int16 word_1016CB60[]; // weak
__int16 word_1016CB62[]; // weak
_UNKNOWN unk_1016CBA0; // weak
int dword_101761A0; // weak
int dword_101761A4; // weak
int dword_101761A8; // weak
int dword_101761AC; // weak
int dword_101761B0; // weak
void *dword_101761B4; // idb
int dword_101771C0; // weak
int dword_101771DC; // weak
UINT uNumber; // idb
int dword_10177200[]; // weak
int dword_10177300; // weak
int dword_10177318; // weak


//----- (10001000) --------------------------------------------------------
#error "10001005: call analysis failed (funcsize=10)"

//----- (10001030) --------------------------------------------------------
char __usercall sub_10001030@<al>(void *a1@<esi>)
{
  char result; // al@2
  bool v2; // zf@3
  void *v3; // [sp+0h] [bp-8h]@0

  if ( sub_100048B0(4035, v3) )
  {
    result = 1;
  }
  else
  {
    v2 = (unsigned __int8)sub_10004680(1, 741, 0, 4, a1) == 0;
    result = 1;
    if ( v2 )
      result = 0;
  }
  return result;
}

//----- (10001070) --------------------------------------------------------
char __usercall sub_10001070@<al>(float *a1@<esi>)
{
  char result; // al@1
  void *v2; // [sp+0h] [bp-8h]@0

  result = sub_100078B0(v2);
  if ( result )
    result = 1;
  else
    *a1 = 9.8999998e24;
  return result;
}

//----- (10001090) --------------------------------------------------------
char __cdecl sub_10001090(float *a1)
{
  char v1; // bl@1
  double v2; // st7@1
  char result; // al@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v5 = 9.8999998e24;
  v1 = 0;
  sub_10024A40(6081, &v4, 4, &v5);
  v2 = v4;
  if ( v4 != 9.8999998e24 )
  {
    v1 = 1;
    v4 = v2 / 3600.0;
    v2 = v4;
  }
  result = v1;
  *a1 = v2;
  return result;
}

//----- (100010F0) --------------------------------------------------------
char __cdecl sub_100010F0(float *a1)
{
  char v1; // bl@1
  double v2; // st7@1
  char result; // al@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v5 = 9.8999998e24;
  v1 = 0;
  sub_10024A40(6937, &v4, 4, &v5);
  v2 = v4;
  if ( v4 != 9.8999998e24 )
  {
    v1 = 1;
    v4 = v2 / 3600.0;
    v2 = v4;
  }
  result = v1;
  *a1 = v2;
  return result;
}

//----- (10001150) --------------------------------------------------------
char __cdecl sub_10001150(float *a1)
{
  char v1; // bl@1
  double v2; // st7@1
  char result; // al@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v5 = 9.8999998e24;
  v1 = 0;
  sub_10024A40(6938, &v4, 4, &v5);
  v2 = v4;
  if ( v4 != 9.8999998e24 )
  {
    v1 = 1;
    v4 = v2 / 3600.0;
    v2 = v4;
  }
  result = v1;
  *a1 = v2;
  return result;
}

//----- (100011B0) --------------------------------------------------------
char __usercall sub_100011B0@<al>(int a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st7@2
  float v4; // ST14_4@5
  char result; // al@5
  float v6; // [sp+Ch] [bp-8h]@1
  float v7; // [sp+10h] [bp-4h]@1

  v1 = sub_10004070(1206, &v6);
  v2 = sub_10004070(1207, &v7);
  if ( v1 )
  {
    v3 = v6;
    if ( v2 )
    {
      if ( v7 <= v3 )
        v3 = v7;
      v4 = v3;
      result = sub_100079E0(v4, a1);
    }
    else
    {
      result = sub_100079E0(v6, a1);
    }
  }
  else if ( v2 )
  {
    result = sub_100079E0(v7, a1);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10001250) --------------------------------------------------------
char __cdecl sub_10001250(float *a1)
{
  char result; // al@2
  float v2; // [sp+4h] [bp-4h]@1

  if ( (unsigned __int8)sub_10004680(1, 949, 0, 4, &v2) )
  {
    result = 1;
    *a1 = 1000.0 * v2 / (10.0 - v2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100012A0) --------------------------------------------------------
char __cdecl sub_100012A0(float *a1)
{
  char result; // al@2
  float v2; // [sp+4h] [bp-4h]@1

  if ( (unsigned __int8)sub_10004680(1, 950, 0, 4, &v2) )
  {
    result = 1;
    *a1 = 1000.0 * v2 / (10.0 - v2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100012F0) --------------------------------------------------------
char __cdecl sub_100012F0(float *a1)
{
  char result; // al@3
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( (unsigned __int8)sub_10004680(0, 400, 0, 4, &v3) && (unsigned __int8)sub_10004680(1, 527, 0, 4, &v2) )
  {
    result = 1;
    *a1 = v2 * v3 * 0.1047197580337524;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10001350) --------------------------------------------------------
char __cdecl sub_10001350(float *a1)
{
  char result; // al@3
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( (unsigned __int8)sub_10004680(0, 401, 0, 4, &v3) && (unsigned __int8)sub_10004680(1, 530, 0, 4, &v2) )
  {
    result = 1;
    *a1 = v2 * v3 * 0.1047197580337524;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100013B0) --------------------------------------------------------
char __usercall sub_100013B0@<al>(float *a1@<esi>, char a2)
{
  char v2; // bl@1
  char result; // al@6
  float v4; // [sp+4h] [bp-Ch]@1
  int v5; // [sp+8h] [bp-8h]@1
  float v6; // [sp+Ch] [bp-4h]@1
  char v7; // [sp+14h] [bp+4h]@2
  char v8; // [sp+14h] [bp+4h]@7

  v4 = 9.8999998e24;
  v6 = 9.8999998e24;
  v2 = 0;
  v5 = 0;
  if ( a2 )
  {
    v7 = sub_10004680(6, 617, 0, 4, &v5);
    if ( sub_100048B0(4026, &v4) )
    {
      v2 = 1;
      if ( v7 && v5 & 0x1000 && sub_100048B0(4028, &v6) )
      {
LABEL_6:
        result = 1;
        *a1 = v6 + v4;
        return result;
      }
      goto LABEL_11;
    }
  }
  else
  {
    v8 = sub_10004680(6, 620, 0, 4, &v5);
    if ( sub_100048B0(4027, &v4) )
    {
      v2 = 1;
      if ( v8 && v5 & 0x1000 && sub_100048B0(4029, &v6) )
        goto LABEL_6;
LABEL_11:
      *a1 = v4;
      return v2;
    }
  }
  return v2;
}

//----- (100014A0) --------------------------------------------------------
char __cdecl sub_100014A0(float a1, int a2)
{
  float v2; // ecx@0
  char v3; // al@3
  char result; // al@5
  float v5; // [sp+0h] [bp-4h]@1

  v5 = v2;
  if ( LOBYTE(a1) == 1 )
  {
    if ( !sub_100048B0(65, &v5) )
      return 0;
    v3 = sub_100048B0(498, &a1);
  }
  else
  {
    if ( !sub_100048B0(61, &v5) )
      return 0;
    v3 = sub_100048B0(477, &a1);
  }
  if ( v3 )
  {
    result = 1;
    *(float *)a2 = (a1 + v5) * 0.5;
    return result;
  }
  return 0;
}

//----- (10001510) --------------------------------------------------------
char __usercall sub_10001510@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st7@2
  char result; // al@4
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_10004680(1, 740, 0, 4, &v5);
  v2 = sub_10004680(1, 2172, 0, 4, &v6);
  if ( v1 )
  {
    v3 = v5;
    if ( !v2 || (v5 = v3 - v6, LODWORD(v5) &= 0x7FFFFFFFu, v5 <= 304.8) )
    {
      *a1 = v3;
      return 1;
    }
  }
  else if ( v2 )
  {
    result = 1;
    *a1 = v6;
    return result;
  }
  return 0;
}

//----- (10001590) --------------------------------------------------------
char __cdecl sub_10001590(float *a1)
{
  char result; // al@4
  int v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( (unsigned __int8)sub_10004680(1, 120, 0, 4, &v3)
    && (unsigned __int8)sub_10004680(1, 1775, 0, 4, &v2)
    && !(v2 & 0x7C0000) )
  {
    *a1 = v3;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100015F0) --------------------------------------------------------
char __cdecl sub_100015F0(float *a1)
{
  char v1; // bl@1
  int v2; // eax@3
  char result; // al@14
  int v4; // [sp+4h] [bp-8h]@2
  float v5; // [sp+8h] [bp-4h]@1

  v1 = 0;
  if ( !(unsigned __int8)sub_10004680(1, 122, 0, 4, &v5) || !(unsigned __int8)sub_10004680(1, 996, 0, 4, &v4) )
    goto LABEL_18;
  v2 = v4;
  if ( v4 & 0x40000 )
    v1 = 1;
  if ( v2 & 0x80000 )
    ++v1;
  if ( v2 & 0x100000 )
    ++v1;
  if ( v2 & 0x200000 )
    ++v1;
  if ( v2 & 0x400000 )
    ++v1;
  if ( (unsigned __int8)v1 < 2u )
  {
    *a1 = v5;
    result = 1;
  }
  else
  {
LABEL_18:
    result = 0;
  }
  return result;
}

//----- (10001680) --------------------------------------------------------
char __cdecl sub_10001680(float *a1)
{
  char v1; // bl@1
  int v2; // eax@3
  char result; // al@14
  int v4; // [sp+4h] [bp-8h]@2
  float v5; // [sp+8h] [bp-4h]@1

  v1 = 0;
  if ( !(unsigned __int8)sub_10004680(1, 127, 0, 4, &v5) || !(unsigned __int8)sub_10004680(1, 1004, 0, 4, &v4) )
    goto LABEL_18;
  v2 = v4;
  if ( v4 & 0x40000 )
    v1 = 1;
  if ( v2 & 0x80000 )
    ++v1;
  if ( v2 & 0x100000 )
    ++v1;
  if ( v2 & 0x200000 )
    ++v1;
  if ( v2 & 0x400000 )
    ++v1;
  if ( (unsigned __int8)v1 < 2u )
  {
    *a1 = v5;
    result = 1;
  }
  else
  {
LABEL_18:
    result = 0;
  }
  return result;
}

//----- (10001710) --------------------------------------------------------
char __usercall sub_10001710@<al>(float *a1@<esi>)
{
  double v1; // st7@15
  double v2; // st6@19
  double v3; // st7@25
  double v4; // st7@31
  char result; // al@36
  char v6; // [sp+4h] [bp-2Ch]@2
  char v7; // [sp+5h] [bp-2Bh]@5
  char v8; // [sp+6h] [bp-2Ah]@8
  char v9; // [sp+7h] [bp-29h]@11
  float v10; // [sp+8h] [bp-28h]@2
  float v11; // [sp+Ch] [bp-24h]@21
  float v12; // [sp+10h] [bp-20h]@17
  float v13; // [sp+14h] [bp-1Ch]@14
  float v14; // [sp+18h] [bp-18h]@23
  float v15; // [sp+1Ch] [bp-14h]@29
  float v16; // [sp+20h] [bp-10h]@1
  float v17; // [sp+24h] [bp-Ch]@21
  double v18; // [sp+28h] [bp-8h]@21

  *a1 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10004680(1, 1744, 0, 4, &v16) )
    goto LABEL_40;
  v16 = v16 * 61.02374267578125;
  v10 = v16;
  if ( (unsigned __int8)sub_10004680(1, 134, 0, 1, &v6) && !v6 )
    v10 = v10 + 39.90000152587891;
  if ( (unsigned __int8)sub_10004680(1, 634, 0, 1, &v7) && !v7 )
    v10 = v10 + 2.5;
  if ( (unsigned __int8)sub_10004680(1, 649, 0, 1, &v8) && !v8 )
    v10 = v10 + 2.5;
  if ( (unsigned __int8)sub_10004680(1, 1757, 0, 1, &v9) && v9 )
    v10 = v10 + 13.5;
  if ( sub_100078B0(&v13) )
    v1 = v13 * 1.799999952316284 + 32.0;
  else
    v1 = -65.0;
  v13 = v1;
  if ( (unsigned __int8)sub_10004680(1, 1743, 0, 4, &v12) && v12 != 0.0 )
    v2 = v12 * 0.000145037702168338;
  else
    v2 = 3040.0;
  v12 = v2;
  v17 = v13 + 460.0;
  v18 = 0.0000344 - (v17 - 528.0) * 0.00000005;
  v11 = v18 * (v12 - 100.0) + 1.003999948501587;
  v11 = 100.0 - v17 * (v11 * 248.0) / v12;
  if ( v11 > 0.0 )
    v10 = v11 + v10;
  if ( (unsigned __int8)sub_10004680(1, 1741, 0, 4, &v14) && v14 != 0.0 )
    v3 = v14 * 0.000145037702168338;
  else
    v3 = 3040.0;
  v14 = v3;
  v11 = (v14 - 100.0) * v18 + 1.003999948501587;
  v11 = 50.0 - v11 * 124.0 * v17 / v14;
  if ( v11 > 0.0 )
    v10 = v11 + v10;
  v4 = (unsigned __int8)sub_10004680(1, 1742, 0, 4, &v15) && v15 != 0.0 ? v15 * 0.000145037702168338 : 3040.0;
  v15 = v4;
  v16 = (v15 - 100.0) * v18 + 1.003999948501587;
  v11 = 50.0 - v16 * 124.0 * v17 / v15;
  if ( v11 > 0.0 )
    v10 = v11 + v10;
  v17 = v12 * 631.0 / 250000.0;
  v10 = v17 + v10;
  v17 = 631.0 * ((v13 - 59.0) * 0.0004556);
  v17 = v17 + v10;
  v17 = (v17 - 300.0 + 100.0) / 100.0;
  if ( v17 <= 1.25 )
  {
    *a1 = v17;
    result = 1;
  }
  else
  {
LABEL_40:
    result = 0;
  }
  return result;
}

//----- (10001AB0) --------------------------------------------------------
char __usercall sub_10001AB0@<al>(float *a1@<esi>)
{
  char result; // al@4
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  *a1 = 0.0;
  if ( sub_10004070(1037, &v3) && sub_10004070(1038, &v2) && v2 != 0.0 )
  {
    result = 1;
    *a1 = v3 / v2 * 11.35624027252197 + 0.1147093996405602;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10001B20) --------------------------------------------------------
char __usercall sub_10001B20@<al>(float *a1@<esi>)
{
  char result; // al@1
  float *v2; // [sp+0h] [bp-8h]@0

  result = sub_10007940(v2);
  if ( result )
    result = 1;
  else
    *a1 = 9.8999998e24;
  return result;
}

//----- (10001B40) --------------------------------------------------------
char __usercall sub_10001B40@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st6@3
  char result; // al@4
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_10004070(79, &v5);
  v2 = sub_10004070(2026, &v6);
  if ( v1 )
  {
    if ( !v2 )
    {
      result = 1;
      *a1 = v5;
      return result;
    }
    v3 = v5;
    v5 = v6 - v5;
    LODWORD(v5) &= 0x7FFFFFFFu;
    if ( v5 <= 34473.789 )
    {
      result = 1;
      *a1 = (v6 + v3) * 0.5;
      return result;
    }
  }
  else if ( v2 )
  {
    result = 1;
    *a1 = v6;
    return result;
  }
  return 0;
}

//----- (10001BD0) --------------------------------------------------------
void __usercall sub_10001BD0(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st6@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v1 = sub_10004070(81, &v4);
  v2 = sub_10004070(2027, &v5);
  if ( v1 )
  {
    if ( !v2 )
    {
      *a1 = v4;
      return;
    }
    v3 = v4;
    v4 = v5 - v4;
    LODWORD(v4) &= 0x7FFFFFFFu;
    if ( v4 <= 5.0 )
    {
      *a1 = (v5 + v3) * 0.5;
      return;
    }
  }
  else if ( v2 )
  {
    *a1 = v5;
    return;
  }
  *a1 = 21.1;
}

//----- (10001C60) --------------------------------------------------------
char __cdecl sub_10001C60(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  float v3; // [sp+8h] [bp-18h]@1
  double v4; // [sp+Ch] [bp-14h]@1
  float v5; // [sp+14h] [bp-Ch]@2
  double v6; // [sp+18h] [bp-8h]@2

  v1 = sub_10001B40((float *)&v4);
  sub_10001BD0(&v3);
  if ( v1 )
  {
    v5 = (v3 + 67.77799987792969) / 27.77799987792969;
    v3 = (*(float *)&v4 + 517.0900268554688) / 4137139.5;
    v4 = v5 * 27.79999923706055;
    v5 = pow(315.0 - v4, 2.0);
    v6 = v5 * 5.470000147278498e-11;
    v5 = pow(v3 * 41.40000152587891, 2.0);
    v6 = v5 * v6;
    v5 = pow(215.0 - v4, 2.0);
    v5 = v6 - v5 * 0.00000005260000079942984 * 41.40000152587891 * v3 + 1.0;
    *a1 = v3 / (v4 + 205.3000030517578) * (1.0 / v5 * 127823.0) - 195.0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10001D80) --------------------------------------------------------
char __usercall sub_10001D80@<al>(float *a1@<esi>, float a2)
{
  char v2; // bl@1
  double v3; // st7@3
  long double v4; // st7@3
  float v6; // [sp+0h] [bp-20h]@1
  float v7; // [sp+4h] [bp-1Ch]@1
  float v8; // [sp+8h] [bp-18h]@3
  float v9; // [sp+Ch] [bp-14h]@1
  int v10; // [sp+10h] [bp-10h]@3
  float v11; // [sp+14h] [bp-Ch]@5
  float v12; // [sp+18h] [bp-8h]@5
  float v13; // [sp+1Ch] [bp-4h]@5
  float v14; // [sp+24h] [bp+4h]@3
  float v15; // [sp+24h] [bp+4h]@3
  unsigned __int8 v16; // [sp+24h] [bp+4h]@3

  v2 = 0;
  v9 = a2 * 32.0 * 0.0005787039990536869;
  v7 = 0.0;
  v6 = 0.0;
  if ( sub_10004070(79, &v7) && sub_10004070(81, &v6) )
  {
    *(float *)&v10 = v7 / 101325.0;
    v14 = v6 + 273.0;
    v7 = v7 * 0.000145037702168338;
    v6 = v6 * 1.799999952316284 + 32.0;
    v15 = v14 * 0.08205779641866684 / *(float *)&v10;
    v3 = v15 * 0.002983009908348322;
    v16 = 0;
    v8 = v3;
    v4 = v9;
    do
    {
      if ( v16 >= 5u )
        break;
      v12 = pow(v4, 2.0);
      v11 = pow(v8 / v9, 2.0);
      v11 = (v9 - 0.5099999904632568 * v8) * (v11 * 5140.0 + v7 + 14.69999980926514)
          - (v6 + 460.0) * 10.71000003814697 * v8;
      v13 = v11;
      v11 = pow(v8, 2.0);
      v12 = -((v11 * 7864200.0 + 10710.0 * v12 * v6 + v12 * 510.0 * v7 - 10280000.0 * v9 * v8 + v12 * 4934097.0)
            / (v12
             * 1000.0));
      v13 = v13 / v12;
      v8 = v8 - v13;
      v4 = v9;
      v10 = LODWORD(v13) & 0x7FFFFFFF;
      if ( COERCE_FLOAT(LODWORD(v13) & 0x7FFFFFFF) < 0.001 )
      {
        v2 = 1;
        *a1 = v8 / 0.002983009908348322;
      }
      ++v16;
    }
    while ( !v2 );
  }
  return v2;
}

//----- (10001F80) --------------------------------------------------------
char __usercall sub_10001F80@<al>(float *a1@<esi>, float a2)
{
  char v2; // al@3
  char result; // al@5
  float v4; // [sp+4h] [bp-4h]@3

  if ( LOBYTE(a2) )
  {
    if ( !sub_100058D0(1, 1516, 0, 4, &a2) )
      return 0;
    v2 = sub_100058D0(0, 356, 0, 4, &v4);
  }
  else
  {
    if ( !sub_100058D0(1, 2447, 0, 4, &a2) )
      return 0;
    v2 = sub_100058D0(0, 357, 0, 4, &v4);
  }
  if ( v2 )
  {
    result = 1;
    *a1 = a2 - v4;
    return result;
  }
  return 0;
}

//----- (10002010) --------------------------------------------------------
char __usercall sub_10002010@<al>(float *a1@<eax>)
{
  return sub_100081C0(a1);
}

//----- (10002020) --------------------------------------------------------
char __usercall sub_10002020@<al>(float *a1@<eax>)
{
  return sub_10008290(a1);
}

//----- (10002030) --------------------------------------------------------
char __usercall sub_10002030@<al>(float *a1@<eax>)
{
  return sub_10008360(a1);
}

//----- (10002040) --------------------------------------------------------
char __usercall sub_10002040@<al>(float *a1@<eax>)
{
  return sub_10008430(a1);
}

//----- (10002050) --------------------------------------------------------
int __usercall sub_10002050@<eax>(char a1@<dl>, int a2@<ecx>, float *a3)
{
  int result; // eax@1
  int v4; // [sp+0h] [bp-4h]@1

  v4 = a2;
  result = sub_10004680(a1, a2, 0, 4, &v4);
  if ( (_BYTE)result )
    *a3 = (double)v4 * 0.00000008381903171539307;
  return result;
}

//----- (10002080) --------------------------------------------------------
char __usercall sub_10002080@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  double v2; // st7@3
  char result; // al@9
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@2

  v1 = 0;
  if ( sub_100058D0(6, 41, 0, 4, &v4) && sub_100058D0(6, 42, 0, 4, &v5) )
  {
    v2 = (v5 + v4) * 0.5;
LABEL_8:
    *a1 = v2;
    v1 = 1;
    goto LABEL_9;
  }
  if ( sub_100058D0(6, 41, 0, 4, &v4) )
  {
    v2 = v4;
    goto LABEL_8;
  }
  if ( sub_100058D0(6, 42, 0, 4, &v5) )
  {
    v2 = v5;
    goto LABEL_8;
  }
LABEL_9:
  result = v1;
  *a1 = *a1 * 1.943844437599182;
  return result;
}

//----- (10002120) --------------------------------------------------------
char __usercall sub_10002120@<al>(float *a1@<esi>)
{
  char result; // al@6
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+6h] [bp-B6h]@3
  char v4; // [sp+7h] [bp-B5h]@4
  char v5; // [sp+8h] [bp-B4h]@5
  char v6; // [sp+9h] [bp-B3h]@2
  float v7; // [sp+14h] [bp-A8h]@6
  float v8; // [sp+20h] [bp-9Ch]@9

  if ( (unsigned __int8)sub_10004680(6, 429, 0, 180, &v2) )
  {
    if ( v6 )
    {
LABEL_9:
      result = 1;
      *a1 = v8;
      return result;
    }
    if ( (!v3 || !v4) && v5 )
      goto LABEL_6;
  }
  if ( (unsigned __int8)sub_10004680(6, 430, 0, 180, &v2) )
  {
    if ( v6 )
      goto LABEL_9;
    if ( (!v3 || !v4) && v5 )
    {
LABEL_6:
      result = 1;
      *a1 = v7;
      return result;
    }
  }
  return 0;
}

//----- (10002200) --------------------------------------------------------
char __cdecl sub_10002200(float *a1)
{
  char result; // al@3
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( sub_100048B0(87, &v3) && sub_100048B0(88, &v2) )
  {
    result = 1;
    *a1 = (v2 + v3) * 0.5;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10002250) --------------------------------------------------------
char __usercall sub_10002250@<al>(float *a1@<esi>)
{
  char result; // al@5
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+6h] [bp-B6h]@2
  char v4; // [sp+7h] [bp-B5h]@3
  float v5; // [sp+Ch] [bp-B0h]@5
  float v6; // [sp+18h] [bp-A4h]@9

  if ( (unsigned __int8)sub_10004680(6, 429, 0, 180, &v2) )
  {
    if ( v3 && v4 )
      goto LABEL_9;
    if ( v2 )
    {
LABEL_5:
      result = 1;
      *a1 = v5;
      return result;
    }
  }
  if ( (unsigned __int8)sub_10004680(6, 430, 0, 180, &v2) )
  {
    if ( v3 && v4 )
    {
LABEL_9:
      result = 1;
      *a1 = v6;
      return result;
    }
    if ( v2 )
      goto LABEL_5;
  }
  return 0;
}

//----- (10002330) --------------------------------------------------------
char __usercall sub_10002330@<al>(float *a1@<esi>)
{
  char result; // al@5
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+5h] [bp-B7h]@4
  char v4; // [sp+6h] [bp-B6h]@3
  char v5; // [sp+7h] [bp-B5h]@2
  float v6; // [sp+10h] [bp-ACh]@5
  float v7; // [sp+1Ch] [bp-A0h]@9

  if ( (unsigned __int8)sub_10004680(6, 429, 0, 180, &v2) )
  {
    if ( v5 && v4 )
      goto LABEL_9;
    if ( v3 )
    {
LABEL_5:
      result = 1;
      *a1 = v6;
      return result;
    }
  }
  if ( (unsigned __int8)sub_10004680(6, 430, 0, 180, &v2) )
  {
    if ( v5 && v4 )
    {
LABEL_9:
      result = 1;
      *a1 = v7;
      return result;
    }
    if ( v3 )
      goto LABEL_5;
  }
  return 0;
}

//----- (10002410) --------------------------------------------------------
char __usercall sub_10002410@<al>(float *a1@<esi>)
{
  char result; // al@3
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+44h] [bp-78h]@2
  float v4; // [sp+50h] [bp-6Ch]@3

  if ( (unsigned __int8)sub_10004680(6, 429, 0, 180, &v2) && v3
    || (unsigned __int8)sub_10004680(6, 430, 0, 180, &v2) && v3 )
  {
    result = 1;
    *a1 = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100024B0) --------------------------------------------------------
char __usercall sub_100024B0@<al>(float *a1@<esi>)
{
  char result; // al@3
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+40h] [bp-7Ch]@2
  float v4; // [sp+48h] [bp-74h]@3

  if ( (unsigned __int8)sub_10004680(6, 429, 0, 180, &v2) && v3
    || (unsigned __int8)sub_10004680(6, 430, 0, 180, &v2) && v3 )
  {
    result = 1;
    *a1 = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10002550) --------------------------------------------------------
char __usercall sub_10002550@<al>(float *a1@<esi>)
{
  char result; // al@3
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+41h] [bp-7Bh]@2
  float v4; // [sp+4Ch] [bp-70h]@3

  if ( (unsigned __int8)sub_10004680(6, 429, 0, 180, &v2) && v3
    || (unsigned __int8)sub_10004680(6, 430, 0, 180, &v2) && v3 )
  {
    result = 1;
    *a1 = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100025F0) --------------------------------------------------------
char __usercall sub_100025F0@<al>(float *a1@<esi>)
{
  char result; // al@4
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+80h] [bp-3Ch]@2
  char v4; // [sp+81h] [bp-3Bh]@3
  float v5; // [sp+8Ch] [bp-30h]@7
  float v6; // [sp+98h] [bp-24h]@4

  if ( (unsigned __int8)sub_10004680(6, 429, 0, 180, &v2) )
  {
    if ( v3 )
    {
LABEL_7:
      result = 1;
      *a1 = v5;
      return result;
    }
    if ( v4 )
    {
LABEL_4:
      result = 1;
      *a1 = v6;
      return result;
    }
  }
  if ( (unsigned __int8)sub_10004680(6, 430, 0, 180, &v2) )
  {
    if ( v3 )
      goto LABEL_7;
    if ( v4 )
      goto LABEL_4;
  }
  return 0;
}

//----- (100026D0) --------------------------------------------------------
char __cdecl sub_100026D0(float *a1)
{
  double v1; // st7@2
  char result; // al@5
  float v3; // ST04_4@5
  float v4; // [sp+0h] [bp-Ch]@1
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v4 = 9.8999998e24;
  v5 = sub_10008540();
  if ( sub_100080C0(&v6) && (v1 = v5, v5 != 9.8999998e24) )
  {
    if ( v1 >= 3785.411865234375 || v6 <= 0.0001051503277267329 )
    {
      result = 1;
      *a1 = v4;
    }
    else
    {
      result = 1;
      v3 = v1 / v6;
      *a1 = v3;
    }
  }
  else
  {
    *a1 = v4;
    result = 0;
  }
  return result;
}

//----- (10002770) --------------------------------------------------------
bool __cdecl sub_10002770(float *a1)
{
  char v1; // bl@1
  bool v2; // al@1
  double v3; // st6@5
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_100026D0(&v5);
  v2 = sub_10008660(&v6);
  if ( !v1
    || !v2
    || v5 == 9.8999998e24
    || (LODWORD(v6) & 0x7F800000) == 2139095040
    || (v5 = v5 * v6, v3 = v5, v5 > 37040000.0) )
  {
    v5 = 9.8999998e24;
    v3 = (float)9.8999998e24;
  }
  *a1 = v3;
  return v2 && v1 && v3 != 9.8999998e24;
}

//----- (10002820) --------------------------------------------------------
char __usercall sub_10002820@<al>(float *a1@<esi>)
{
  char result; // al@5
  float v2; // [sp+4h] [bp-8h]@1
  float v3; // [sp+8h] [bp-4h]@2

  *a1 = 9.8999998e24;
  if ( (unsigned __int8)sub_10004680(1, 90, 0, 4, &v2)
    && (unsigned __int8)sub_10004680(1, 115, 0, 4, &v3)
    && v2 != 9.8999998e24
    && v3 != 9.8999998e24 )
  {
    result = 1;
    *a1 = v3 - v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100028A0) --------------------------------------------------------
char __usercall sub_100028A0@<al>(float *a1@<esi>)
{
  char result; // al@5
  float v2; // [sp+4h] [bp-8h]@1
  float v3; // [sp+8h] [bp-4h]@2

  *a1 = 9.8999998e24;
  if ( (unsigned __int8)sub_10004680(1, 527, 0, 4, &v2)
    && (unsigned __int8)sub_10004680(1, 530, 0, 4, &v3)
    && v2 != 9.8999998e24
    && v3 != 9.8999998e24 )
  {
    result = 1;
    *a1 = v3 - v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10002930) --------------------------------------------------------
char __usercall sub_10002930@<al>(float *a1@<esi>)
{
  char result; // al@4
  float v2; // [sp+0h] [bp-Ch]@1
  float v3; // [sp+4h] [bp-8h]@2
  float v4; // [sp+8h] [bp-4h]@3

  *a1 = 9.8999998e24;
  if ( sub_10008660(&v2) && (v3 = v2, (LODWORD(v2) & 0x7F800000) != 2139095040) && sub_100080C0(&v4) )
  {
    result = 1;
    if ( v4 > 0.0001051503277267329 )
      *a1 = v2 / v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100029A0) --------------------------------------------------------
int __cdecl sub_100029A0(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_10004680(1, 74, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10004680(1, 75, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10004680(1, 76, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10004680(1, 77, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10004680(1, 78, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10004680(1, 79, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + 0.05000000074505806 >= v6 )
  {
    v2 = 0.05000000074505806;
  }
  else
  {
    v2 = 0.05000000074505806;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (10002BD0) --------------------------------------------------------
int __cdecl sub_10002BD0(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_10004680(1, 99, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10004680(1, 100, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10004680(1, 101, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10004680(1, 102, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10004680(1, 103, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10004680(1, 104, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + 0.05000000074505806 >= v6 )
  {
    v2 = 0.05000000074505806;
  }
  else
  {
    v2 = 0.05000000074505806;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (10002E00) --------------------------------------------------------
int __cdecl sub_10002E00(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_10004680(1, 68, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10004680(1, 69, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10004680(1, 70, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10004680(1, 71, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10004680(1, 72, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10004680(1, 73, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + 0.05000000074505806 >= v6 )
  {
    v2 = 0.05000000074505806;
  }
  else
  {
    v2 = 0.05000000074505806;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (10003030) --------------------------------------------------------
int __cdecl sub_10003030(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_10004680(1, 93, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10004680(1, 94, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10004680(1, 95, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10004680(1, 96, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10004680(1, 97, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10004680(1, 98, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + 0.05000000074505806 >= v6 )
  {
    v2 = 0.05000000074505806;
  }
  else
  {
    v2 = 0.05000000074505806;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (10003260) --------------------------------------------------------
char __usercall sub_10003260@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char result; // al@4
  float v3; // [sp+4h] [bp-24h]@1
  float v4; // [sp+8h] [bp-20h]@1
  char v5; // [sp+Ch] [bp-1Ch]@1
  float v6; // [sp+18h] [bp-10h]@1

  v3 = 9.8999998e24;
  v1 = 0;
  v4 = sub_10008540();
  sub_10024A40(41109, &v5, 24, &unk_100439F0);
  if ( v6 != 9.8999998e24 && v4 != 9.8999998e24 )
  {
    v1 = 1;
    v3 = v4 - v6;
  }
  result = v1;
  *a1 = v3;
  return result;
}

//----- (100032F0) --------------------------------------------------------
char __usercall sub_100032F0@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char result; // al@3
  float v3; // [sp+4h] [bp-20h]@1
  char v4; // [sp+8h] [bp-1Ch]@1
  float v5; // [sp+14h] [bp-10h]@1

  v3 = 9.8999998e24;
  v1 = 0;
  sub_10024A40(41109, &v4, 24, &unk_100439F0);
  if ( v5 != 9.8999998e24 )
  {
    v3 = v5;
    v1 = 1;
  }
  result = v1;
  *a1 = v3;
  return result;
}

//----- (10003360) --------------------------------------------------------
bool __cdecl sub_10003360(float *a1)
{
  bool v1; // bl@1
  bool result; // al@3
  float v3; // [sp+4h] [bp-4h]@1

  v3 = 9.8999998e24;
  v1 = sub_10008D80(&v3, 0, 0, 2) != 0;
  if ( 9.8999998e24 != v3 )
    v3 = sub_10008D10() + v3;
  result = v1;
  *a1 = v3;
  return result;
}

//----- (100033C0) --------------------------------------------------------
char __cdecl sub_100033C0(float a1, void *a2)
{
  __int16 v2; // cx@1
  char result; // al@4
  double v4; // st7@32
  double v5; // st7@69
  float v6; // ST0C_4@70
  float v7; // [sp+Ch] [bp-4h]@1
  float v8; // [sp+14h] [bp+4h]@32
  float v9; // [sp+14h] [bp+4h]@35

  HIBYTE(v2) = BYTE1(a1);
  v7 = 9.8999998e24;
  if ( (signed int)LOWORD(a1) > 301 )
  {
    switch ( LOWORD(a1) )
    {
      case 0x12Eu:
        v5 = 511.0;
        goto LABEL_70;
      case 0x12Fu:
        v5 = 1000.0;
        goto LABEL_70;
      case 0x191u:
        result = sub_10001AB0((float *)a2);
        break;
      case 0x192u:
        result = sub_100014A0(0.0, (int)a2);
        break;
      case 0x193u:
        result = sub_100014A0(COERCE_FLOAT(1), (int)a2);
        break;
      case 0x194u:
        result = sub_10002200((float *)a2);
        break;
      case 0x195u:
        result = sub_100011B0((int)a2);
        break;
      case 0x196u:
      case 0x197u:
        result = sub_100013B0((float *)a2, LOWORD(a1) == 406);
        break;
      case 0x198u:
      case 0x199u:
        LOBYTE(v2) = LOWORD(a1) == 408;
        result = ((char (__usercall *)@<al>(float *@<esi>, __int16))sub_10001F80)((float *)a2, v2);
        break;
      case 0x19Au:
        result = sub_10002080((float *)a2);
        break;
      case 0x19Bu:
        result = sub_10001030(a2);
        break;
      case 0x19Cu:
        result = sub_10002020((float *)a2);
        break;
      case 0x19Du:
        result = sub_10002030((float *)a2);
        break;
      case 0x19Eu:
        result = sub_10002010((float *)a2);
        break;
      case 0x19Fu:
        result = sub_10002040((float *)a2);
        break;
      case 0x1A0u:
        result = sub_10024A40(9145, a2, 4, &v7) == 0;
        break;
      default:
LABEL_88:
        sub_10009550("..\\lib\\adl\\dat_custom_proc_prj.c", 724, 0, 0);
        result = 0;
        break;
    }
  }
  else if ( LOWORD(a1) == 301 )
  {
    v5 = 295.0;
LABEL_70:
    v6 = v5;
    result = sub_10001D80((float *)a2, v6);
  }
  else
  {
    switch ( LOWORD(a1) )
    {
      case 0u:
        return sub_10002410((float *)a2);
      case 1u:
        return sub_100025F0((float *)a2);
      case 2u:
        return sub_10002250((float *)a2);
      case 3u:
        return sub_10002330((float *)a2);
      case 4u:
        return sub_10002120((float *)a2);
      case 5u:
        return sub_10001C60((float *)a2);
      case 7u:
        return sub_100024B0((float *)a2);
      case 6u:
        return sub_10002550((float *)a2);
      case 9u:
        return sub_10001250((float *)a2);
      case 0xAu:
        return sub_100012A0((float *)a2);
      case 0xBu:
        return sub_10001710((float *)a2);
      case 0xDu:
        *(float *)a2 = sub_10007AB0();
        return 1;
      case 0x38u:
        return sub_10001B40((float *)a2);
      case 0x39u:
        sub_10001BD0((float *)a2);
        goto LABEL_18;
      case 0x3Au:
        return sub_100015F0((float *)a2);
      case 0x3Bu:
        return sub_10001680((float *)a2);
      case 0x3Cu:
        return sub_10001590((float *)a2);
      case 0x3Du:
        return sub_10001510((float *)a2);
      case 8u:
        return sub_10001070((float *)a2);
      case 0xCu:
        return sub_10001B20((float *)a2);
      case 0xEu:
        return sub_10008150((float *)a2);
      case 0xFu:
        return sub_100084D0((float *)a2);
      case 0x10u:
        return sub_10008010((float *)a2);
      case 0x11u:
        return sub_100085A0((float *)a2);
      case 0x12u:
        return sub_10008080((float *)a2);
      case 0x13u:
        return sub_100080A0((float *)a2);
      case 0x14u:
        return sub_100080C0((float *)a2);
      case 0x15u:
        v8 = sub_10008540();
        v4 = v8;
        *(float *)a2 = v8;
        goto LABEL_33;
      case 0x35u:
        v9 = sub_10007A80();
        v4 = v9;
        *(float *)a2 = v9;
LABEL_33:
        if ( 9.8999998e24 == v4 )
          result = 0;
        else
LABEL_18:
          result = 1;
        break;
      case 0x16u:
        result = sub_100012F0((float *)a2);
        break;
      case 0x17u:
        result = sub_10001350((float *)a2);
        break;
      case 0x18u:
        result = sub_100026D0((float *)a2);
        break;
      case 0x19u:
        result = sub_10002770((float *)a2);
        break;
      case 0x1Au:
        result = sub_10002820((float *)a2);
        break;
      case 0x1Bu:
        result = sub_100028A0((float *)a2);
        break;
      case 0x1Cu:
        result = sub_10002930((float *)a2);
        break;
      case 0x1Du:
        result = sub_100029A0((float *)a2);
        break;
      case 0x1Eu:
        result = sub_10002BD0((float *)a2);
        break;
      case 0x1Fu:
        result = sub_10002E00((float *)a2);
        break;
      case 0x20u:
        result = sub_10003030((float *)a2);
        break;
      case 0x21u:
        result = sub_10002050(6, 59, (float *)a2);
        break;
      case 0x22u:
        result = sub_10002050(6, 60, (float *)a2);
        break;
      case 0x23u:
        result = sub_10002050(6, 61, (float *)a2);
        break;
      case 0x24u:
        result = sub_10002050(6, 62, (float *)a2);
        break;
      case 0x25u:
        result = sub_10001090((float *)a2);
        break;
      case 0x26u:
        result = sub_100010F0((float *)a2);
        break;
      case 0x27u:
        result = sub_10001150((float *)a2);
        break;
      case 0x2Au:
        result = sub_10024A40(9000, a2, 4, &v7) == 0;
        break;
      case 0x2Bu:
        result = sub_10024A40(9001, a2, 4, &v7) == 0;
        break;
      case 0x2Cu:
        result = sub_10024A40(9002, a2, 4, &v7) == 0;
        break;
      case 0x2Du:
        result = sub_10024A40(9003, a2, 4, &v7) == 0;
        break;
      case 0x2Eu:
        result = sub_10024A40(9004, a2, 4, &v7) == 0;
        break;
      case 0x2Fu:
        result = sub_10024A40(9005, a2, 4, &v7) == 0;
        break;
      case 0x30u:
        result = sub_10024A40(9006, a2, 4, &v7) == 0;
        break;
      case 0x31u:
        result = sub_10024A40(9007, a2, 4, &v7) == 0;
        break;
      case 0x32u:
        result = sub_10024A40(9008, a2, 4, &v7) == 0;
        break;
      case 0x33u:
        result = sub_10024A40(9009, a2, 4, &v7) == 0;
        break;
      case 0x34u:
        result = sub_10024A40(9010, a2, 4, &v7) == 0;
        break;
      case 0x28u:
        result = sub_10003260((float *)a2);
        break;
      case 0x29u:
        result = sub_100032F0((float *)a2);
        break;
      case 0x36u:
        result = sub_10003360((float *)a2);
        break;
      case 0x37u:
        result = sub_10008D80((float *)a2, 0, 0, 2) != 0;
        break;
      default:
        goto LABEL_88;
    }
  }
  return result;
}

//----- (10003C70) --------------------------------------------------------
char __cdecl sub_10003C70(int a1, float *a2)
{
  char v2; // bl@1
  char result; // al@8

  v2 = 1;
  if ( *(float *)(a1 + 4) > (double)*a2 )
  {
    if ( *(_BYTE *)(a1 + 19) )
    {
      if ( *(_BYTE *)(a1 + 19) == 1 )
        *a2 = *(float *)(a1 + 4);
    }
    else
    {
      v2 = 0;
    }
  }
  if ( *(float *)a1 >= (double)*a2 )
  {
    result = v2;
  }
  else if ( *(_BYTE *)(a1 + 20) )
  {
    result = v2;
    if ( *(_BYTE *)(a1 + 20) == 1 )
      *a2 = *(float *)a1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10003CD0) --------------------------------------------------------
char __usercall sub_10003CD0@<al>(unsigned __int16 a1@<ax>, int a2@<esi>, float a3, char a4, char a5)
{
  unsigned __int8 v5; // cl@1
  char v6; // dl@2
  char v7; // bl@4
  double v8; // st7@6
  int v9; // edi@6
  int v10; // ecx@6
  bool v11; // zf@10
  unsigned int v12; // eax@18
  char v14; // [sp+3h] [bp-5h]@1
  char v15; // [sp+4h] [bp-4h]@2
  char v16; // [sp+10h] [bp+8h]@10
  char v17; // [sp+14h] [bp+Ch]@10

  v5 = *(_BYTE *)(a2 + 10 * a1 + 22535);
  v14 = 10;
  if ( (unsigned __int8)a4 >= 9u )
  {
    v15 = 9;
    v6 = 9;
  }
  else
  {
    v6 = a4;
    v15 = a4;
  }
  v7 = a5;
  if ( (unsigned __int8)a5 >= 9u )
    v7 = 9;
  v8 = a3;
  v9 = v5;
  v10 = 10 * v5;
  if ( *(float *)(a2 + 4 * (v10 + (unsigned __int8)v6) + 53416) >= (double)a3 )
  {
    if ( *(float *)(a2 + 4 * (v10 + (unsigned __int8)v7) + 53416) <= v8 )
    {
      v11 = v7 == v6;
      v16 = 1;
      v17 = 0;
      if ( (unsigned __int8)v7 > (unsigned __int8)v6 )
      {
        v16 = -1;
        v17 = -1;
        v11 = v7 == v6;
      }
      if ( !v11 )
      {
        while ( *(float *)(a2 + 4 * ((unsigned __int8)v7 + v10) + 53416) > v8
             || *(float *)(a2 + 4 * (v10 + (unsigned __int8)v7 + v16) + 53416) < v8 )
        {
          v7 += v16;
          if ( v7 == v15 )
            goto LABEL_18;
        }
        v14 = v7 + v17;
      }
    }
    else
    {
      v14 = v7;
    }
  }
  else
  {
    v14 = v6;
  }
LABEL_18:
  v12 = *(_BYTE *)(44 * v9 + a2 + 52576) - 2;
  if ( (unsigned __int8)v14 < v12 )
    LOBYTE(v12) = v14;
  return v12;
}

//----- (10003DE0) --------------------------------------------------------
double __usercall sub_10003DE0@<st0>(int a1@<eax>, _BYTE *a2@<ebx>, int a3, float a4)
{
  int v4; // esi@1
  unsigned __int8 v5; // al@1
  int v6; // edi@2
  unsigned __int8 v7; // al@2
  char v8; // al@6
  double v9; // st7@7
  double result; // st7@7
  char v11; // [sp+14h] [bp-8h]@4
  char v12; // [sp+18h] [bp-4h]@4
  float v13; // [sp+24h] [bp+8h]@7

  v4 = a1;
  v5 = *(_BYTE *)(a1 + 10 * (unsigned __int16)a3 + 22535);
  if ( v5 >= 0x14u )
  {
    *a2 = 1;
    result = a4;
  }
  else
  {
    v6 = v5;
    v7 = *(_BYTE *)(44 * v5 + v4 + 52576);
    if ( v7 <= 1u || v7 > 0xAu )
      goto LABEL_12;
    v11 = 0;
    v12 = v7 - 1;
    if ( *(float *)(v4 + 4 * (10 * v6 + (unsigned __int8)(v7 - 1)) + 53416) < (double)*(float *)(v4 + 40 * v6 + 53416) )
    {
      v11 = v7 - 1;
      v12 = 0;
    }
    v8 = sub_10003CD0(a3, v4, a4, v12, v11);
    if ( (unsigned __int8)v8 >= 9u )
    {
LABEL_12:
      *a2 = 1;
      result = a4;
    }
    else
    {
      v9 = *(float *)(v4 + 4 * ((unsigned __int8)v8 + 2 * (9 * v6 + 6777))) * a4
         + *(float *)(v4 + 4 * ((unsigned __int8)v8 + 18 * v6) + 54252);
      *a2 = 1;
      v13 = v9;
      result = v13;
    }
  }
  return result;
}

//----- (10003EE0) --------------------------------------------------------
unsigned __int8 __cdecl sub_10003EE0(int a1, int a2, char a3, void *a4)
{
  int v4; // esi@1
  int v5; // ecx@1
  unsigned __int8 result; // al@1
  int v7; // edi@1
  int v8; // esi@4
  char v9; // bl@7
  int v10; // edi@7
  char v11; // al@7
  int v12; // edx@7
  char v13; // al@8
  char v14; // dl@8
  unsigned __int8 v15; // [sp+16h] [bp-156h]@1
  char v16; // [sp+17h] [bp-155h]@7
  int v17; // [sp+18h] [bp-154h]@1
  int v18; // [sp+1Ch] [bp-150h]@1
  int v19; // [sp+20h] [bp-14Ch]@1
  char v20[12]; // [sp+24h] [bp-148h]@7
  float v21[78]; // [sp+30h] [bp-13Ch]@8

  *(float *)a4 = 9.8999998e24;
  v4 = a2;
  v5 = *(_WORD *)(a2 + 16);
  result = 0;
  v7 = a1;
  v17 = a1;
  v19 = a2;
  v15 = 0;
  v18 = v5;
  while ( v15 < *(_BYTE *)(v4 + 18) )
  {
    v5 = (unsigned __int16)v5;
    v8 = v7 + 10 * (unsigned __int16)v5 + 22534;
    switch ( *(_BYTE *)v8 )
    {
      case 1:
        result = sub_10004680(
                   *(_BYTE *)(v7 + 10 * (unsigned __int16)v5 + 22538),
                   *(_WORD *)(v7 + 2 * (5 * v5 + 11270)),
                   *(_WORD *)(v7 + 10 * (unsigned __int16)v5 + 22542),
                   4,
                   a4);
        break;
      case 3:
        result = sub_100033C0(COERCE_FLOAT(*(_WORD *)(v7 + 10 * (unsigned __int16)v5 + 22538)), a4);
        break;
      case 4:
        v9 = *(_BYTE *)(v7 + 10 * (unsigned __int16)v5 + 22539);
        v10 = *(_BYTE *)(v7 + 10 * (unsigned __int16)v5 + 22539);
        v11 = sub_10024230((unsigned int)*(_BYTE *)(v8 + 5) >> 3, 1);
        v12 = *(_BYTE *)(v8 + 4);
        v16 = v11;
        result = sub_10004680(6, (unsigned __int16)word_10043D18[v12], 0, 324, v20);
        if ( result )
        {
          v13 = v16;
          v14 = v16;
          *(float *)a4 = v21[v10];
          result = ((unsigned __int8)v20[(unsigned __int8)v13] >> (v9 - 8 * v14)) & 1;
        }
        v7 = v17;
        break;
    }
    ++v15;
    v5 = v18++ + 1;
    if ( result )
    {
      v15 = result;
      goto LABEL_15;
    }
    v4 = v19;
  }
  v15 = result;
  if ( !result )
    return result;
LABEL_15:
  if ( a3 )
  {
    *(float *)a4 = sub_10003DE0(v7, &v15, v5 - 1, *(float *)a4);
    result = v15;
  }
  return result;
}
// 10043D18: using guessed type __int16 word_10043D18[];
// 10003EE0: using guessed type char var_148[12];
// 10003EE0: using guessed type float var_13C[78];

//----- (10004070) --------------------------------------------------------
char __cdecl sub_10004070(int a1, void *a2)
{
  int v2; // esi@1
  int v3; // eax@1
  char result; // al@4

  *(float *)a2 = 9.8999998e24;
  v2 = sub_10004650(a1);
  v3 = sub_10004690();
  if ( v2 && v3 && *(_WORD *)(v2 + 12) == 6 )
  {
    result = sub_10003EE0(v3, v2, 1, a2);
    if ( result )
      result = sub_10003C70(v2, (float *)a2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100040D0) --------------------------------------------------------
_WORD *__cdecl sub_100040D0(int a1, int a2, int a3, _WORD *a4)
{
  _WORD *result; // eax@1
  int v5; // esi@1
  signed int v6; // ebp@1
  char v7; // bl@2

  *(_WORD *)(a2 + 12) = *(_WORD *)(a3 + 2);
  *(_WORD *)(a2 + 14) = *(_WORD *)(a3 + 4);
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 64);
  *(_DWORD *)a2 = *(_DWORD *)(a3 + 68);
  *(_BYTE *)(a2 + 19) = *(_BYTE *)(a3 + 72);
  result = a4;
  *(_BYTE *)(a2 + 20) = *(_BYTE *)(a3 + 73);
  *(_BYTE *)(a2 + 18) = 0;
  *(_WORD *)(a2 + 16) = *a4;
  v5 = a3 + 8;
  *(float *)(a2 + 8) = *(float *)(a3 + 60);
  v6 = 5;
  do
  {
    v7 = *(_BYTE *)v5;
    if ( *(_BYTE *)v5 )
    {
      switch ( v7 )
      {
        case 1:
          *(_BYTE *)(a1 + 10 * *a4 + 22534) = v7;
          *(_BYTE *)(a1 + 10 * *a4 + 22538) = *(_BYTE *)(v5 + 4);
          *(_WORD *)(a1 + 10 * (*a4 + 2254)) = *(_WORD *)(v5 + 6);
          *(_WORD *)(a1 + 10 * *a4 + 22542) = *(_WORD *)(v5 + 8);
          break;
        case 3:
          *(_BYTE *)(a1 + 10 * *a4 + 22534) = v7;
          *(_WORD *)(a1 + 10 * *a4 + 22538) = *(_WORD *)(v5 + 4);
          break;
        case 2:
          *(_BYTE *)(a1 + 10 * *a4 + 22534) = *(_BYTE *)v5;
          *(_BYTE *)(a1 + 10 * *a4 + 22538) = *(_BYTE *)(v5 + 4);
          switch ( *(_BYTE *)(v5 + 4) )
          {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
              *(_BYTE *)(a1 + 10 * *a4 + 22539) = *(_BYTE *)(v5 + 5);
              break;
            case 9:
            case 0xA:
            case 0xB:
            case 0xC:
              *(_BYTE *)(a1 + 10 * *a4 + 22539) = *(_BYTE *)(v5 + 5);
              break;
            default:
              goto LABEL_10;
          }
          break;
        case 4:
          *(_BYTE *)(a1 + 10 * *a4 + 22534) = *(_BYTE *)v5;
          *(_BYTE *)(a1 + 10 * *a4 + 22538) = *(_BYTE *)(v5 + 4);
          *(_BYTE *)(a1 + 10 * *a4 + 22539) = *(_BYTE *)(v5 + 5);
          break;
        default:
LABEL_10:
          *(_BYTE *)(a1 + 10 * *a4 + 22534) = 0;
          break;
      }
      *(_BYTE *)(a1 + 10 * *a4 + 22535) = *(_BYTE *)(v5 + 1);
      ++*(_BYTE *)(a2 + 18);
      ++*a4;
    }
    v5 += 10;
    --v6;
  }
  while ( v6 );
  return result;
}

//----- (100042A0) --------------------------------------------------------
int __fastcall sub_100042A0(int a1, int a2)
{
  double v2; // st7@1
  double v3; // st6@1
  double v4; // st5@1
  int v5; // ebp@1
  int result; // eax@1
  int v7; // ebx@1
  signed int v8; // ecx@1
  double v9; // rt0@2
  double v10; // st5@2
  double v11; // rt1@2
  double v12; // rt2@3
  double v13; // st5@3
  double v14; // rtt@3
  double v15; // rt0@4
  double v16; // st5@4
  double v17; // st7@4
  double v18; // rt1@4
  double v19; // st5@4
  double v20; // st6@4
  unsigned int v21; // eax@5
  int v22; // esi@7
  int v23; // ecx@8
  double v24; // rt2@9
  double v25; // st5@9
  double v26; // st7@9
  float *v27; // edi@9
  int v28; // ebp@10
  bool v29; // c0@10
  bool v30; // c3@10
  float *v31; // ebp@10
  int v32; // esi@11
  float v33; // ST2C_4@13
  double v34; // st4@13
  float v35; // ST2C_4@14
  float v36; // ST2C_4@14
  float v37; // ST2C_4@15
  double v38; // rtt@17
  bool v39; // zf@18
  unsigned __int8 v40; // [sp+13h] [bp-1Dh]@7
  int v41; // [sp+14h] [bp-1Ch]@1
  int v42; // [sp+18h] [bp-18h]@1
  _BYTE *v43; // [sp+1Ch] [bp-14h]@1
  int v44; // [sp+24h] [bp-Ch]@1
  signed int v45; // [sp+28h] [bp-8h]@1

  v2 = 1.0;
  v3 = 0.0;
  v4 = 9.8999998e24;
  v5 = 0;
  v43 = (_BYTE *)(a2 + 52576);
  result = a2 + 54216;
  v7 = 0;
  v42 = 0;
  v41 = 0;
  v44 = a2 + 54216;
  v45 = 20;
  v8 = 9;
  while ( 1 )
  {
    while ( 1 )
    {
      v15 = v4;
      v16 = v2;
      v17 = v15;
      result += 4;
      --v8;
      *(float *)(result - 4) = v16;
      v18 = v16;
      v19 = v3;
      v20 = v18;
      *(float *)(result + 32) = v19;
      if ( !v8 )
        break;
      v12 = v19;
      v13 = v20;
      v3 = v12;
      v14 = v13;
      v4 = v17;
      v2 = v14;
    }
    v21 = *v43;
    if ( v21 >= 0xA )
      LOBYTE(v21) = 10;
    v22 = (unsigned __int8)v21 - 1;
    v40 = 0;
    if ( v22 > 0 )
    {
      v23 = 0;
      do
      {
        v24 = v19;
        v25 = v17;
        v26 = v24;
        v27 = (float *)(a2 + 4 * (v23 + v5 + 13134));
        if ( v25 > *v27 )
        {
          v28 = v23 + v5;
          v29 = v25 < *(float *)(a2 + 4 * v28 + 52540);
          v30 = v25 == *(float *)(a2 + 4 * v28 + 52540);
          v31 = (float *)(a2 + 4 * v28 + 52540);
          if ( !v29 && !v30 )
          {
            v32 = v42 + v23;
            if ( v25 > *(float *)(a2 + 4 * (v42 + v23) + 53416) && v25 > *(float *)(a2 + 4 * v32 + 53420) )
            {
              v33 = *(float *)(a2 + 4 * v32 + 53420) - *(float *)(a2 + 4 * v32 + 53416);
              v34 = v33;
              if ( v33 != v26 )
              {
                v35 = *v31 - *v27;
                v36 = v35 / v34;
                *(float *)(a2 + 4 * (v7 + v23 + 13554)) = v36;
              }
              v37 = *v27 - *(float *)(a2 + 4 * (v7 + v23 + 13554)) * *(float *)(a2 + 4 * v32 + 53416);
              *(float *)(a2 + 4 * (v7 + v23) + 54252) = v37;
            }
            v22 = (unsigned __int8)v21 - 1;
          }
        }
        v38 = v25;
        v19 = v26;
        v17 = v38;
        v5 = v41;
        v23 = ++v40;
      }
      while ( v40 < v22 );
    }
    v42 += 10;
    v43 += 44;
    result = v44 + 72;
    v5 += 11;
    v7 += 18;
    v39 = v45-- == 1;
    v44 += 72;
    v41 = v5;
    if ( v39 )
      break;
    v9 = v19;
    v10 = v20;
    v3 = v9;
    v8 = 9;
    v11 = v10;
    v4 = v17;
    v2 = v11;
  }
  return result;
}

//----- (10004450) --------------------------------------------------------
int __cdecl sub_10004450(int a1)
{
  int v1; // ecx@1

  sub_10024A80(6776, a1 + 52536, 880);
  sub_10024A80(6777, a1 + 53416, 800);
  return sub_100042A0(v1, a1);
}

//----- (10004490) --------------------------------------------------------
int __cdecl sub_10004490(int a1, int a2, unsigned __int16 a3)
{
  unsigned __int16 v3; // si@1
  int v4; // edi@2
  unsigned __int16 v5; // ax@4
  int v7; // [sp+Ch] [bp-4h]@1
  int v8; // [sp+1Ch] [bp+Ch]@2

  memset((void *)(a1 + 14400), 0xFFu, 0x1FC4u);
  v3 = 0;
  *(_WORD *)(a1 + 22532) = -1;
  v7 = 0;
  if ( a3 )
  {
    v4 = a2;
    v8 = a3;
    do
    {
      if ( *(_BYTE *)(v4 + 6) & 1 )
      {
        v5 = *(_WORD *)v4;
        if ( *(_WORD *)v4 )
        {
          if ( v5 < 0xFE3u && v3 < 0x258u )
          {
            *(_WORD *)(a1 + 2 * v5 + 14400) = v3;
            sub_100040D0(a1, a1 + 24 * v3++, v4, &v7);
          }
        }
      }
      v4 += 76;
      --v8;
    }
    while ( v8 );
  }
  return sub_10004450(a1);
}

//----- (10004530) --------------------------------------------------------
signed int sub_10004530()
{
  if ( !sub_10025100((LONG)&off_10043E64) )
    sub_10009550("..\\lib\\adl\\dat_init_prj.c", 223, 1, 0);
  dword_101761A0 = dword_100B8820;
  dword_1016CB50 = dword_100B8820 + 55656;
  return sub_10024C90((int)&off_10043E64);
}
// 10043E64: using guessed type char *off_10043E64;
// 100B8820: using guessed type int dword_100B8820;
// 1016CB50: using guessed type int dword_1016CB50;
// 101761A0: using guessed type int dword_101761A0;

//----- (10004580) --------------------------------------------------------
char sub_10004580()
{
  int v0; // esi@1
  void *v1; // ebx@1
  void *v2; // edi@1
  signed int v3; // ebp@1

  dword_100B8820 = -15;
  sub_10004530();
  v0 = 31000;
  v1 = &unk_1016CBA0;
  v2 = &unk_10161900;
  v3 = 600;
  do
  {
    sub_10024AB0(v0 - 1000, (int)v2, 76);
    sub_10024AB0(v0, (int)v1, 64);
    v2 = (char *)v2 + 76;
    v1 = (char *)v1 + 64;
    ++v0;
    --v3;
  }
  while ( v3 );
  sub_10004490(dword_101761A0, (int)&unk_10161900, 0x258u);
  return sub_10009630(dword_1016CB50, (int)&unk_10161900, (int)&unk_1016CBA0, 0x258u);
}
// 100B8820: using guessed type int dword_100B8820;
// 1016CB50: using guessed type int dword_1016CB50;
// 101761A0: using guessed type int dword_101761A0;

//----- (10004610) --------------------------------------------------------
int __usercall sub_10004610@<eax>(unsigned __int16 a1@<di>)
{
  int v1; // eax@1
  unsigned __int16 v2; // cx@3
  int result; // eax@4

  v1 = sub_10004690();
  if ( v1 && a1 < 0xFE3u && (v2 = *(_WORD *)(v1 + 2 * a1 + 14400), v2 < 0x3840u) )
    result = v1 + 24 * v2;
  else
    result = 0;
  return result;
}

//----- (10004650) --------------------------------------------------------
int __cdecl sub_10004650(unsigned __int16 a1)
{
  int result; // eax@1
  int v2; // esi@1

  result = sub_10004610(a1);
  v2 = result;
  if ( !result )
  {
    sub_10009550("..\\lib\\acl\\dat\\dat_intf.c", 100, 0, 0);
    result = v2;
  }
  return result;
}

//----- (10004690) --------------------------------------------------------
int sub_10004690()
{
  return dword_101761A0;
}
// 101761A0: using guessed type int dword_101761A0;

//----- (100046A0) --------------------------------------------------------
int sub_100046A0()
{
  return dword_1016CB50;
}
// 1016CB50: using guessed type int dword_1016CB50;

//----- (100046B0) --------------------------------------------------------
char __cdecl sub_100046B0(unsigned __int8 a1)
{
  int v1; // ebp@1
  unsigned __int16 v2; // di@2
  int v3; // esi@2
  unsigned __int8 v4; // bl@2
  char result; // al@4
  unsigned __int8 v6; // [sp+10h] [bp-8h]@1
  _BYTE *v7; // [sp+14h] [bp-4h]@1

  v6 = 1;
  v7 = &unk_10043E61;
  v1 = 4 * a1;
  do
  {
    v2 = word_1016CB62[v1];
    v3 = dword_1016CB50 + (unsigned __int16)word_1016CB22[v1];
    v4 = 0;
    if ( v2 )
    {
      do
      {
        sub_10004AA0(dword_101761A0, v3, v6);
        ++v4;
        v3 += *v7;
      }
      while ( v4 < v2 );
    }
    ++v7;
    result = v6 + 1;
    ++v1;
    ++v6;
  }
  while ( v6 < 4u );
  return result;
}
// 1016CB22: using guessed type __int16 word_1016CB22[];
// 1016CB50: using guessed type int dword_1016CB50;
// 1016CB62: using guessed type __int16 word_1016CB62[];
// 101761A0: using guessed type int dword_101761A0;

//----- (10004740) --------------------------------------------------------
int sub_10004740()
{
  int result; // eax@1
  int v1; // eax@3
  __int16 v2; // [sp+0h] [bp-8h]@1
  char v3; // [sp+4h] [bp-4h]@1

  for ( result = sub_10024770((int)&v2, (int)&v3); result != 1; result = sub_10024770((int)&v2, (int)&v3) )
  {
    if ( v2 == -32767 )
    {
      v1 = sub_10004690();
      sub_10004450(v1);
    }
  }
  return result;
}

//----- (100047A0) --------------------------------------------------------
int sub_100047A0()
{
  int result; // eax@2
  unsigned __int8 v1; // bl@3
  unsigned int v2; // ebp@3
  _BYTE *v3; // edi@3
  int *v4; // esi@3
  char v5; // [sp+0h] [bp-104h]@1
  int v6; // [sp+4h] [bp-100h]@3
  int v7; // [sp+8h] [bp-FCh]@1
  int v8; // [sp+Ch] [bp-F8h]@1
  int v9; // [sp+10h] [bp-F4h]@1
  int v10; // [sp+14h] [bp-F0h]@1
  int v11; // [sp+18h] [bp-ECh]@1
  int v12; // [sp+1Ch] [bp-E8h]@1
  char v13; // [sp+20h] [bp-E4h]@1

  byte_101618F8 = 1;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  sub_10009D50();
  sub_10009950(&v13);
  sub_10008640();
  sub_10024910(&v5);
  do
  {
    result = sub_10024910(&v5);
    if ( v5 & 1 )
    {
      v1 = 0;
      v2 = sub_100247C0();
      LOBYTE(v6) = 0;
      v3 = &unk_10044460;
      v4 = &v7;
      do
      {
        if ( *v4 <= v2 )
        {
          v2 = sub_100247C0();
          sub_100046B0(v6);
          *v4 = 25 * *v3 + v2 - 12;
        }
        ++v1;
        ++v3;
        ++v4;
        LOBYTE(v6) = v1;
      }
      while ( v1 < 6u );
      result = sub_10009840((int *)&v13);
    }
    if ( v5 & 2 )
      result = sub_10004740();
  }
  while ( byte_101618F8 );
  return result;
}
// 10009D50: using guessed type int sub_10009D50(void);
// 101618F8: using guessed type char byte_101618F8;

//----- (100048B0) --------------------------------------------------------
char __cdecl sub_100048B0(int a1, void *a2)
{
  int v2; // ebx@1
  int v3; // eax@1
  void *v4; // ecx@1
  int v5; // edi@1
  char result; // al@5
  int v7; // eax@7
  int v8; // ebp@7
  int v9; // [sp+8h] [bp-10h]@1
  int v10; // [sp+Ch] [bp-Ch]@1
  float v11; // [sp+10h] [bp-8h]@1

  v11 = 9.8999998e24;
  *(float *)a2 = 9.8999998e24;
  LOBYTE(v9) = 0;
  v10 = 0;
  v2 = sub_10004650(a1);
  v3 = sub_10004A10(a1);
  v5 = v3;
  if ( !v2 )
    goto LABEL_15;
  if ( !v3 )
    return sub_10004070(a1, a2);
  if ( *(_WORD *)(v2 + 12) != 6 )
    goto LABEL_15;
  if ( sub_10009F90(v4) == 4 )
  {
    *(float *)a2 = *(float *)(v2 + 8);
    return 1;
  }
  if ( (unsigned __int8)(*(_BYTE *)(v5 + 2) - 1) <= 2u )
  {
    v7 = sub_10009D80(&v9, (void *)(v5 + 4), 0xCu, 27, 100);
    *(float *)a2 = v11;
    v8 = v7;
    result = sub_100247C0() - v10 < (unsigned int)(unsigned __int16)word_100444AC[*(_BYTE *)(v5 + 3)] ? v9 : 0;
    if ( v8 >= 0 )
    {
      if ( result )
        result = sub_10003C70(v2, (float *)a2);
    }
    else
    {
      sub_10009550("..\\lib\\acl\\dat\\dat_proc_float.c", 174, 0, 0);
      result = 0;
    }
  }
  else
  {
LABEL_15:
    result = 0;
  }
  return result;
}
// 100444AC: using guessed type __int16 word_100444AC[];

//----- (10004A10) --------------------------------------------------------
int __cdecl sub_10004A10(unsigned __int16 a1)
{
  int v1; // ecx@1
  unsigned __int16 v2; // ax@3
  int result; // eax@4

  v1 = sub_100046A0();
  if ( v1 && a1 < 0xFE3u && (v2 = *(_WORD *)(v1 + 2 * a1 + 0x2000), v2 < 0x2000u) )
    result = v1 + v2;
  else
    result = 0;
  return result;
}

//----- (10004A50) --------------------------------------------------------
int (*__usercall sub_10004A50@<eax>(int (*result)(void)@<eax>, _BYTE *a2@<edx>, int a3@<esi>, float a4))(void)
{
  if ( *((_BYTE *)result + 16) == 1 )
  {
    result = sub_100244A0(1, a4, (int)result + 20, (int)result + 68, (int)a2, a3);
  }
  else if ( *((_BYTE *)result + 16) == 2 )
  {
    result = sub_10024530(1, a4, (int)result + 20, (int)result + 68, (int)a2, a3);
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

//----- (10004AA0) --------------------------------------------------------
char __cdecl sub_10004AA0(int a1, int a2, unsigned __int8 a3)
{
  int v3; // eax@1
  int v4; // edx@8
  float v5; // ST20_4@8
  float v6; // ST18_4@8
  double v7; // st7@8
  _BYTE *v8; // esi@10
  int v10; // [sp+4h] [bp-38h]@11
  char v11; // [sp+8h] [bp-34h]@11
  float v12; // [sp+1Ch] [bp-20h]@2
  float v13; // [sp+20h] [bp-1Ch]@8
  double v14; // [sp+24h] [bp-18h]@1
  int v15; // [sp+2Ch] [bp-10h]@1
  int v16; // [sp+30h] [bp-Ch]@1
  float v17; // [sp+34h] [bp-8h]@1

  v17 = 9.8999998e24;
  v15 = 0;
  v16 = 0;
  v14 = 0.0;
  v3 = sub_10004650(*(_WORD *)a2);
  if ( *(_WORD *)(v3 + 12) != 6 )
  {
    *(_BYTE *)(a2 + 4) = 0;
    return v3;
  }
  LOBYTE(v3) = sub_10003EE0(a1, v3, 1, &v12);
  LOBYTE(v15) = v3;
  if ( !(_BYTE)v3 )
    return v3;
  if ( a3 == 1 )
  {
    v17 = sub_10009FD0(v12, *(float *)(a2 + 12), *(_BYTE *)(a2 + 20), *(float *)(a2 + 16));
    v8 = (_BYTE *)(a2 + 4);
    v16 = sub_100247C0();
    v3 = sub_10009D80((void *)(a2 + 4), &v15, 0xCu, 27, 100);
    if ( v3 == 1 )
    {
      v11 = 0;
      v10 = 161;
      goto LABEL_12;
    }
  }
  else
  {
    if ( a3 <= 1u )
      return v3;
    if ( a3 > 3u )
      return v3;
    LOBYTE(v3) = (unsigned int)sub_10004A50((int (*)(void))a2, &v15, (int)&v14, v12);
    if ( !(_BYTE)v15 )
      return v3;
    if ( a3 == 3 )
    {
      v4 = *(_BYTE *)(a2 + 116);
      v5 = *(float *)(a2 + 112);
      v6 = *(float *)(a2 + 12);
      v13 = v14;
      v7 = sub_10009FD0(v13, v6, v4, v5);
    }
    else
    {
      v7 = v14;
    }
    v17 = v7;
    v16 = sub_100247C0();
    v8 = (_BYTE *)(a2 + 4);
    v3 = sub_10009D80((void *)(a2 + 4), &v15, 0xCu, 27, 100);
    if ( v3 == 1 )
    {
      v11 = 0;
      v10 = 198;
LABEL_12:
      LOBYTE(v3) = sub_10009550("..\\lib\\acl\\dat\\dat_proc_intf.c", v10, v11, 0);
      return v3;
    }
  }
  if ( v3 == -1 )
    *v8 = 0;
  return v3;
}

//----- (10004C60) --------------------------------------------------------
int __cdecl sub_10004C60(char a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 7 )
    result = (unsigned __int16)word_100456F4[a1];
  return result;
}
// 100456F4: using guessed type __int16 word_100456F4[];

//----- (10004C80) --------------------------------------------------------
signed int sub_10004C80()
{
  signed int result; // eax@1

  result = -15;
  dword_100B8844 = -15;
  dword_100B8850 = -15;
  dword_100B882C = -15;
  dword_100B8854 = -15;
  dword_100B8840 = -15;
  dword_100B8830 = -15;
  dword_100B8828 = -15;
  dword_100B883C = -15;
  dword_100B884C = -15;
  dword_100B8848 = -15;
  dword_100B8838 = -15;
  dword_100B8834 = -15;
  return result;
}
// 100B8828: using guessed type int dword_100B8828;
// 100B882C: using guessed type int dword_100B882C;
// 100B8830: using guessed type int dword_100B8830;
// 100B8834: using guessed type int dword_100B8834;
// 100B8838: using guessed type int dword_100B8838;
// 100B883C: using guessed type int dword_100B883C;
// 100B8840: using guessed type int dword_100B8840;
// 100B8844: using guessed type int dword_100B8844;
// 100B8848: using guessed type int dword_100B8848;
// 100B884C: using guessed type int dword_100B884C;
// 100B8850: using guessed type int dword_100B8850;
// 100B8854: using guessed type int dword_100B8854;

//----- (10004CD0) --------------------------------------------------------
signed int __usercall sub_10004CD0@<eax>(char a1@<al>, int a2@<ecx>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = sub_10025030((int)&off_10045714);
      break;
    case 0:
      result = sub_10025030((int)&off_10045728);
      break;
    case 1:
      result = sub_10025030((int)&off_1004573C);
      break;
    case 2:
      result = sub_10025030((int)&off_10045764);
      break;
    case 3:
      result = sub_10025030((int)&off_10045750);
      break;
    case 5:
      result = sub_10025030((int)&off_10045778);
      break;
    default:
      result = sub_10025030(a2);
      break;
  }
  return result;
}
// 10045714: using guessed type char *off_10045714;
// 10045728: using guessed type char *off_10045728;
// 1004573C: using guessed type char *off_1004573C;
// 10045750: using guessed type char *off_10045750;
// 10045764: using guessed type char *off_10045764;
// 10045778: using guessed type char *off_10045778;

//----- (10004D70) --------------------------------------------------------
int __usercall sub_10004D70@<eax>(char a1@<al>)
{
  return sub_10024850(dword_10045244[a1]);
}
// 10045244: using guessed type int dword_10045244[];

//----- (10004D90) --------------------------------------------------------
int __usercall sub_10004D90@<eax>(char a1@<al>)
{
  return sub_10024870(dword_10045244[a1], 10);
}
// 10045244: using guessed type int dword_10045244[];

//----- (10004DB0) --------------------------------------------------------
signed __int16 __usercall sub_10004DB0@<ax>(char a1@<al>, unsigned __int16 a2@<si>)
{
  signed __int16 result; // ax@3
  bool v3; // cf@8

  switch ( a1 )
  {
    case 6:
      if ( a2 < 0x2E5u )
      {
        if ( !(unsigned __int8)sub_10004CD0(a1, a1) )
        {
          sub_10009550("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3201, 0, 0);
          goto LABEL_6;
        }
        result = *(_WORD *)(dword_100B8844 + 2 * a2 + 241212);
        v3 = (unsigned __int16)result < 0x256u;
        goto LABEL_32;
      }
      sub_10009550("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3186, 0, 0);
      return -1;
    default:
      goto LABEL_6;
    case 0:
      if ( a2 >= 0x344u )
      {
        sub_10009550("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3224, 0, 0);
        return -1;
      }
      if ( (unsigned __int8)sub_10004CD0(a1, a1) )
      {
        result = *(_WORD *)(dword_100B8850 + 2 * a2 + 284664);
        v3 = (unsigned __int16)result < 0x211u;
        goto LABEL_32;
      }
      if ( sub_10009ED0(15000) )
        goto LABEL_6;
      sub_10009550("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3242, 0, 0);
      return 0;
    case 1:
      if ( a2 >= 0xBCCu )
      {
        sub_10009550("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3265, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10004CD0(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_100B882C + 2 * a2 + 447808);
      v3 = (unsigned __int16)result < 0x979u;
      goto LABEL_32;
    case 2:
      if ( a2 >= 0x388u )
      {
        sub_10009550("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3302, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10004CD0(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_100B8854 + 2 * a2 + 356016);
      v3 = (unsigned __int16)result < 0x23Du;
      goto LABEL_32;
    case 3:
      if ( a2 >= 0xBEu )
      {
        sub_10009550("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3339, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10004CD0(a1, a1) )
      {
        sub_10009550("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3354, 0, 0);
        return 0;
      }
      result = *(_WORD *)(dword_100B8840 + 2 * a2 + 23096);
      v3 = (unsigned __int16)result < 0x52u;
      goto LABEL_32;
    case 5:
      if ( a2 < 4u )
      {
        if ( (unsigned __int8)sub_10004CD0(a1, a1) )
        {
          result = *(_WORD *)(dword_100B8830 + 2 * a2 + 1804);
          v3 = (unsigned __int16)result < 4u;
LABEL_32:
          if ( !v3 )
            result = -1;
        }
        else
        {
LABEL_6:
          result = 0;
        }
      }
      else
      {
        sub_10009550("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3377, 0, 0);
        result = -1;
      }
      return result;
  }
}
// 100B882C: using guessed type int dword_100B882C;
// 100B8830: using guessed type int dword_100B8830;
// 100B8840: using guessed type int dword_100B8840;
// 100B8844: using guessed type int dword_100B8844;
// 100B8850: using guessed type int dword_100B8850;
// 100B8854: using guessed type int dword_100B8854;

//----- (10004FF0) --------------------------------------------------------
char __cdecl sub_10004FF0(char a1, unsigned __int16 a2, _BYTE *a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v6; // eax@9

  v3 = sub_10004DB0(a1, a2);
  if ( v3 != -1 && !sub_10004D90(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10004CD0(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_100B8844);
        sub_10004D70(a1);
        return 1;
      case 0:
        if ( (unsigned __int8)sub_10004CD0(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_100B8850);
        sub_10004D70(a1);
        return 1;
      case 1:
        if ( (unsigned __int8)sub_10004CD0(a1, v4) != 1 )
          goto LABEL_17;
        v6 = dword_100B882C;
        goto LABEL_16;
      case 2:
        if ( (unsigned __int8)sub_10004CD0(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_100B8854);
        sub_10004D70(a1);
        return 1;
      case 3:
        if ( (unsigned __int8)sub_10004CD0(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_100B8840);
        sub_10004D70(a1);
        return 1;
      case 5:
        if ( (unsigned __int8)sub_10004CD0(a1, v4) != 1 )
          goto LABEL_17;
        v6 = dword_100B8830;
LABEL_16:
        *a3 = *(_BYTE *)((unsigned __int16)v3 + v6);
        sub_10004D70(a1);
        return 1;
      default:
LABEL_17:
        sub_10004D70(a1);
        break;
    }
  }
  return 0;
}
// 100B882C: using guessed type int dword_100B882C;
// 100B8830: using guessed type int dword_100B8830;
// 100B8840: using guessed type int dword_100B8840;
// 100B8844: using guessed type int dword_100B8844;
// 100B8850: using guessed type int dword_100B8850;
// 100B8854: using guessed type int dword_100B8854;

//----- (10005150) --------------------------------------------------------
char __cdecl sub_10005150(char a1, unsigned __int16 a2, void *a3)
{
  int v3; // ecx@1
  signed __int16 v4; // si@1
  char result; // al@2

  v4 = sub_10004DB0(a1, a2);
  if ( v4 == -1 )
  {
    result = 0;
  }
  else
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10004CD0(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_100B8844 + 210116), 0x34u);
        result = 1;
        break;
      case 0:
        if ( (unsigned __int8)sub_10004CD0(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_100B8850 + 257156), 0x34u);
        result = 1;
        break;
      case 1:
        result = sub_10004CD0(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_100B882C + 321708), 0x34u);
        break;
      case 2:
        if ( (unsigned __int8)sub_10004CD0(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_100B8854 + 326220), 0x34u);
        result = 1;
        break;
      case 3:
        if ( (unsigned __int8)sub_10004CD0(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_100B8840 + 18832), 0x34u);
        result = 1;
        break;
      case 5:
        result = sub_10004CD0(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_100B8830 + 1596), 0x34u);
        break;
      default:
LABEL_16:
        result = 0;
        break;
    }
  }
  return result;
}
// 100B882C: using guessed type int dword_100B882C;
// 100B8830: using guessed type int dword_100B8830;
// 100B8840: using guessed type int dword_100B8840;
// 100B8844: using guessed type int dword_100B8844;
// 100B8850: using guessed type int dword_100B8850;
// 100B8854: using guessed type int dword_100B8854;

//----- (100052D0) --------------------------------------------------------
char __cdecl sub_100052D0(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v5; // eax@5

  v3 = sub_10004DB0(a1, a2);
  if ( v3 != -1 && !sub_10004D90(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10004CD0(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_100B8844 + 24 * ((unsigned __int16)v3 + 25);
        goto LABEL_16;
      case 0:
        if ( (unsigned __int8)sub_10004CD0(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_100B8850 + 24 * (unsigned __int16)v3 + 532;
        goto LABEL_16;
      case 1:
        if ( (unsigned __int8)sub_10004CD0(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_100B882C + 24 * (unsigned __int16)v3 + 2428;
        goto LABEL_16;
      case 2:
        if ( (unsigned __int8)sub_10004CD0(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_100B8854 + 24 * ((unsigned __int16)v3 + 24);
        goto LABEL_16;
      case 3:
        if ( (unsigned __int8)sub_10004CD0(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_100B8840 + 24 * (unsigned __int16)v3 + 84;
        goto LABEL_16;
      case 5:
        if ( (unsigned __int8)sub_10004CD0(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_100B8830 + 24 * (unsigned __int16)v3 + 4;
LABEL_16:
        *(_DWORD *)a3 = *(_DWORD *)v5;
        *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(a3 + 12) = *(_DWORD *)(v5 + 12);
        *(_DWORD *)(a3 + 16) = *(_DWORD *)(v5 + 16);
        *(_DWORD *)(a3 + 20) = *(_DWORD *)(v5 + 20);
        sub_10004D70(a1);
        return 1;
      default:
LABEL_17:
        sub_10004D70(a1);
        break;
    }
  }
  return 0;
}
// 100B882C: using guessed type int dword_100B882C;
// 100B8830: using guessed type int dword_100B8830;
// 100B8840: using guessed type int dword_100B8840;
// 100B8844: using guessed type int dword_100B8844;
// 100B8850: using guessed type int dword_100B8850;
// 100B8854: using guessed type int dword_100B8854;

//----- (10005430) --------------------------------------------------------
char __cdecl sub_10005430(int a1, int a2, void *a3, char a4, __int16 a5, char a6)
{
  int v6; // ecx@0
  signed __int16 v7; // ax@1
  int v8; // edi@2
  __int16 v9; // si@11
  __int16 v11; // [sp+8h] [bp-560h]@13
  __int16 v12; // [sp+3Ch] [bp-52Ch]@10
  char v13; // [sp+40h] [bp-528h]@16
  char v14; // [sp+41h] [bp-527h]@10
  __int16 v15; // [sp+42h] [bp-526h]@10
  char v16; // [sp+44h] [bp-524h]@10
  __int16 v17; // [sp+46h] [bp-522h]@15
  int v18; // [sp+48h] [bp-520h]@16
  char v19; // [sp+4Ch] [bp-51Ch]@15

  LOBYTE(v7) = a1;
  switch ( (char)a1 )
  {
    case 6:
      v8 = 28;
      goto LABEL_8;
    case 0:
      v8 = 29;
      goto LABEL_8;
    case 1:
      v8 = 30;
      goto LABEL_8;
    case 2:
      v8 = 31;
      goto LABEL_8;
    case 3:
      v8 = 32;
      goto LABEL_8;
    case 5:
      v8 = 33;
LABEL_8:
      LOBYTE(v7) = sub_10004CD0(a1, v6);
      if ( !(_BYTE)v7 )
        return v7;
      v7 = sub_10004DB0(a1, a2);
      if ( v7 == -1 )
        return v7;
      v14 = a6;
      LOBYTE(v7) = a4;
      v12 = -32768;
      v15 = a2;
      v16 = a4;
      if ( a4 == 1 )
      {
        v9 = a5;
        if ( (unsigned __int16)a5 > 0x514u )
          return v7;
      }
      else
      {
        if ( sub_10005150(a1, a2, &v11) != 1 )
          goto LABEL_16;
        v9 = v11;
      }
      memcpy(&v19, a3, (unsigned __int16)v9);
      v17 = v9;
LABEL_16:
      v18 = sub_100247C0();
      v13 = 0;
      LOBYTE(v7) = sub_1000A0B0(v8, (int)&v12);
      return v7;
    default:
      return v7;
  }
}

//----- (10005570) --------------------------------------------------------
char __cdecl sub_10005570(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // ax@1
  int v4; // edi@2
  __int16 v6; // [sp+4h] [bp-52Ch]@8
  unsigned __int16 v7; // [sp+8h] [bp-528h]@9
  int v8; // [sp+Ch] [bp-524h]@9

  LOBYTE(v3) = a1;
  switch ( a1 )
  {
    case 6:
      v4 = 28;
      goto LABEL_8;
    case 0:
      v4 = 29;
      goto LABEL_8;
    case 1:
      v4 = 30;
      goto LABEL_8;
    case 2:
      v4 = 31;
      goto LABEL_8;
    case 3:
      v4 = 32;
      goto LABEL_8;
    case 5:
      v4 = 33;
LABEL_8:
      memset(&v6, 0, 0x528u);
      v3 = sub_10004DB0(a1, a2);
      if ( v3 != -1 )
      {
        v6 = -32766;
        v7 = a2;
        v8 = a3;
        LOBYTE(v3) = sub_1000A0B0(v4, (int)&v6);
      }
      break;
    default:
      return v3;
  }
  return v3;
}

//----- (10005650) --------------------------------------------------------
char __cdecl sub_10005650(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6)
{
  char result; // al@2
  int v7; // ecx@3
  signed __int16 v8; // si@3
  int v9; // eax@7
  int v10; // ebp@7
  int v11; // esi@7
  int v12; // edi@7
  unsigned int v13; // ebx@7
  int v14; // eax@9
  int v15; // eax@11
  int v16; // eax@13
  int v17; // eax@15
  int v18; // eax@17
  int v19; // eax@25
  char v20; // [sp+7h] [bp-9h]@19
  __int16 v21; // [sp+8h] [bp-8h]@1
  unsigned int v22; // [sp+Ch] [bp-4h]@1

  v22 = sub_100247C0();
  v21 = 0;
  if ( a1 < 7 )
  {
    v8 = sub_10004DB0(a1, a2);
    if ( v8 == -1 )
    {
      result = 0;
    }
    else
    {
      switch ( a1 )
      {
        case 6:
          if ( !(unsigned __int8)sub_10004CD0(a1, v7) )
            goto LABEL_30;
          v9 = 3 * (unsigned __int16)v8 + 75;
          v10 = dword_100B8844 + 14952;
          v11 = 52 * (unsigned __int16)v8 + dword_100B8844 + 210116;
          v12 = dword_100B8844 + 8 * v9;
          v13 = 195164;
          goto LABEL_18;
        case 0:
          if ( !(unsigned __int8)sub_10004CD0(a1, v7) )
            goto LABEL_30;
          v14 = 3 * (unsigned __int16)v8;
          v10 = dword_100B8850 + 13228;
          v11 = 52 * (unsigned __int16)v8 + dword_100B8850 + 257156;
          v12 = dword_100B8850 + 8 * v14 + 532;
          v13 = 243928;
          goto LABEL_18;
        case 1:
          if ( !(unsigned __int8)sub_10004CD0(a1, v7) )
            goto LABEL_30;
          v15 = 3 * (unsigned __int16)v8;
          v10 = dword_100B882C + 60628;
          v11 = 52 * (unsigned __int16)v8 + dword_100B882C + 321708;
          v12 = dword_100B882C + 8 * v15 + 2428;
          v13 = 261080;
          goto LABEL_18;
        case 2:
          if ( !(unsigned __int8)sub_10004CD0(a1, v7) )
            goto LABEL_30;
          v16 = 3 * (unsigned __int16)v8 + 72;
          v10 = dword_100B8854 + 14328;
          v11 = 52 * (unsigned __int16)v8 + dword_100B8854 + 326220;
          v12 = dword_100B8854 + 8 * v16;
          v13 = 311892;
          goto LABEL_18;
        case 3:
          if ( !(unsigned __int8)sub_10004CD0(a1, v7) )
            goto LABEL_30;
          v17 = 3 * (unsigned __int16)v8;
          v10 = dword_100B8840 + 2052;
          v11 = 52 * (unsigned __int16)v8 + dword_100B8840 + 18832;
          v12 = dword_100B8840 + 8 * v17 + 84;
          v13 = 16780;
          goto LABEL_18;
        case 5:
          if ( !(unsigned __int8)sub_10004CD0(a1, v7) )
            goto LABEL_30;
          v18 = 3 * (unsigned __int16)v8;
          v10 = dword_100B8830 + 100;
          v11 = 52 * (unsigned __int16)v8 + dword_100B8830 + 1596;
          v12 = dword_100B8830 + 8 * v18 + 4;
          v13 = 1496;
LABEL_18:
          if ( sub_10004D90(a1) )
            goto LABEL_30;
          v20 = *(_BYTE *)(v12 + 1);
          if ( *(_BYTE *)(v12 + 1) == 1 && v10 )
          {
            if ( *(_DWORD *)(v11 + 12) && v22 > *(_DWORD *)(v11 + 16) + *(_DWORD *)(v12 + 16) )
              goto LABEL_33;
            v21 = a4;
            if ( !a4 )
              v21 = *(_WORD *)(v12 + 4) - a3;
            v19 = *(_DWORD *)(v11 + 4) + (unsigned __int16)a3;
            if ( !v21 || (unsigned int)(unsigned __int16)v21 + v19 > v13 )
LABEL_33:
              v20 = 0;
            else
              memcpy(a5, (const void *)(v10 + v19), (unsigned __int16)v21);
          }
          *(_WORD *)a6 = v21;
          sub_10004D70(a1);
          result = v20;
          break;
        default:
LABEL_30:
          result = 0;
          break;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100B8828: using guessed type int dword_100B8828;
// 100B882C: using guessed type int dword_100B882C;
// 100B8830: using guessed type int dword_100B8830;
// 100B883C: using guessed type int dword_100B883C;
// 100B8840: using guessed type int dword_100B8840;
// 100B8844: using guessed type int dword_100B8844;
// 100B884C: using guessed type int dword_100B884C;
// 100B8850: using guessed type int dword_100B8850;
// 100B8854: using guessed type int dword_100B8854;

//----- (100058D0) --------------------------------------------------------
char __cdecl sub_100058D0(char a1, int a2, __int16 a3, __int16 a4, void *a5)
{
  int v5; // ecx@0
  int v7; // [sp+0h] [bp-4h]@1

  v7 = v5;
  return sub_10005650(a1, a2, a3, a4, a5, (int)&v7);
}

//----- (10005900) --------------------------------------------------------
char __cdecl sub_10005900(char a1, int a2, void *a3)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v3;
  return sub_10005650(a1, a2, 0, 0, a3, (int)&v5);
}

//----- (10005930) --------------------------------------------------------
char __cdecl sub_10005930(char a1, int a2, void *a3, int a4)
{
  return sub_10005650(a1, a2, 0, 0, a3, a4);
}

//----- (10005960) --------------------------------------------------------
int __cdecl sub_10005960(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1000D290(&a1, 1u, (int)&unk_100472A0, 8, 67, 0);
  if ( v1 )
  {
    result = dword_100472A4[2 * v1];
  }
  else
  {
    sub_10009550("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 1932, 0, 0);
    result = 0;
  }
  return result;
}
// 100472A4: using guessed type int dword_100472A4[];

//----- (100059B0) --------------------------------------------------------
signed int sub_100059B0()
{
  signed int result; // eax@1

  result = -15;
  dword_100B8858 = -15;
  dword_100B885C = -15;
  return result;
}
// 100B8858: using guessed type int dword_100B8858;
// 100B885C: using guessed type int dword_100B885C;

//----- (100059C0) --------------------------------------------------------
void *__usercall sub_100059C0@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>)
{
  void *result; // eax@1
  int v4; // [sp+0h] [bp-Ch]@0
  int v5; // [sp+4h] [bp-8h]@0
  int v6; // [sp+8h] [bp-4h]@0

  result = (void *)sub_100249E0(v4, v5, v6);
  if ( a2 == 6011 )
  {
    if ( result || *(_BYTE *)a3 > 0x3Fu )
    {
      *(_BYTE *)a3 = 63;
      result = (void *)sub_10024B50(6011, (int)a3, a1);
    }
  }
  else if ( result )
  {
    result = memset(a3, 204, a1);
  }
  return result;
}

//----- (10005A10) --------------------------------------------------------
signed int sub_10005A10()
{
  int v0; // edi@5
  void *v1; // esi@5
  signed int v2; // ebp@5
  signed int result; // eax@7
  char v4; // [sp+13h] [bp-1h]@1

  dword_101761B0 = 0;
  v4 = 0;
  sub_10025190(94, &v4);
  if ( v4 == 3 )
  {
    v4 = 1;
    sub_10024AD0(3201, (int)&v4, 1);
    sub_100251C0(94, (int)&v4);
  }
  else if ( v4 == 2 )
  {
    v4 = 0;
    sub_10024AD0(3201, (int)&v4, 1);
    sub_100251C0(94, (int)&v4);
  }
  sub_100059C0(1u, 6011, &unk_100B8860);
  sub_100059C0(0x16u, 6194, &unk_100B8861);
  sub_100059C0(1u, 6012, &unk_100B8877);
  sub_100059C0(1u, 6013, &unk_100B8878);
  sub_100059C0(1u, 6014, &unk_100B8879);
  sub_100059C0(1u, 6015, &unk_100B887A);
  sub_100059C0(4u, 6078, &unk_100B887C);
  sub_100059C0(4u, 6104, &unk_100B8880);
  sub_100059C0(0x20u, 6016, &unk_100B8884);
  sub_100059C0(0x20u, 6017, &unk_100B88A4);
  sub_100059C0(0x20u, 6018, &unk_100B88C4);
  sub_100059C0(0x20u, 6019, &unk_100B88E4);
  sub_100059C0(0x20u, 6020, &unk_100B8904);
  sub_100059C0(0x20u, 6021, &unk_100B8924);
  sub_100059C0(0x20u, 6022, &unk_100B8944);
  sub_100059C0(0x20u, 6023, &unk_100B8964);
  sub_100059C0(0x20u, 6024, &unk_100B8984);
  sub_100059C0(0x20u, 6025, &unk_100B89A4);
  sub_100059C0(0x20u, 6026, &unk_100B89C4);
  sub_100059C0(0x20u, 6027, &unk_100B89E4);
  sub_100059C0(0x20u, 6028, &unk_100B8A04);
  sub_100059C0(0x20u, 6029, &unk_100B8A24);
  sub_100059C0(0x20u, 6030, &unk_100B8A44);
  sub_100059C0(0x20u, 6031, &unk_100B8A64);
  sub_100059C0(0x20u, 6032, &unk_100B8A84);
  sub_100059C0(0x20u, 6033, &unk_100B8AA4);
  sub_100059C0(0x20u, 6034, &unk_100B8AC4);
  sub_100059C0(0x20u, 6035, &unk_100B8AE4);
  sub_100059C0(0x20u, 6036, &unk_100B8B04);
  sub_100059C0(0x20u, 6037, &unk_100B8B24);
  sub_100059C0(0x20u, 6038, &unk_100B8B44);
  sub_100059C0(0x20u, 6039, &unk_100B8B64);
  sub_100059C0(0x20u, 6040, &unk_100B8B84);
  sub_100059C0(0x20u, 6041, &unk_100B8BA4);
  sub_100059C0(0x20u, 6042, &unk_100B8BC4);
  sub_100059C0(0x20u, 6043, &unk_100B8BE4);
  sub_100059C0(4u, 6044, &unk_100B8C04);
  sub_100059C0(4u, 6045, &unk_100B8C08);
  sub_100059C0(4u, 6046, &unk_100B8C0C);
  sub_100059C0(4u, 6357, &unk_100B8C10);
  sub_100059C0(4u, 6358, &unk_100B8C14);
  sub_100059C0(4u, 6359, &unk_100B8C18);
  sub_100059C0(0x20u, 6047, &unk_100B8C1C);
  sub_100059C0(0x20u, 6048, &unk_100B8C3C);
  sub_100059C0(0x20u, 6049, &unk_100B8C5C);
  sub_100059C0(0x20u, 6050, &unk_100B8C7C);
  sub_100059C0(0x20u, 6051, &unk_100B8C9C);
  sub_100059C0(0x20u, 6052, &unk_100B8CBC);
  sub_100059C0(0x20u, 6053, &unk_100B8CDC);
  sub_100059C0(0x20u, 6054, &unk_100B8CFC);
  sub_100059C0(1u, 6511, &unk_100B8D1C);
  sub_100059C0(1u, 6522, &unk_100B8D1D);
  sub_100059C0(1u, 6057, &unk_100B8D1E);
  sub_100059C0(0x20u, 6075, &unk_100B8D70);
  sub_100059C0(0x20u, 6076, &unk_100B8D90);
  sub_100059C0(1u, 6077, &unk_100B8DB0);
  sub_100059C0(4u, 6079, &unk_100B8DB4);
  sub_100059C0(4u, 6080, &unk_100B8DB8);
  sub_100059C0(0x20u, 6082, &unk_100B8DBC);
  sub_100059C0(0x20u, 6083, &unk_100B8DDC);
  sub_100059C0(0x20u, 6084, &unk_100B8DFC);
  sub_100059C0(0x20u, 6085, &unk_100B8E1C);
  sub_100059C0(0x20u, 6086, &unk_100B8E3C);
  sub_100059C0(0x20u, 6087, &unk_100B8E5C);
  sub_100059C0(0x20u, 6088, &unk_100B8E7C);
  sub_100059C0(0x20u, 6089, &unk_100B8E9C);
  sub_100059C0(0x20u, 6123, &unk_100B8EBC);
  sub_100059C0(0x48u, 6906, &unk_100B8EDC);
  sub_100059C0(0x48u, 6907, &unk_100B8F24);
  sub_100059C0(0x48u, 6908, &unk_100B8F6C);
  sub_100059C0(0x48u, 6909, &unk_100B8FB4);
  sub_100059C0(0x48u, 6910, &unk_100B8FFC);
  sub_100059C0(0x48u, 6911, &unk_100B9044);
  sub_100059C0(0x48u, 6912, &unk_100B908C);
  sub_100059C0(0x48u, 6913, &unk_100B90D4);
  sub_100059C0(0x48u, 6914, &unk_100B911C);
  sub_100059C0(0x48u, 6915, &unk_100B9164);
  sub_100059C0(0x48u, 6916, &unk_100B91AC);
  sub_100059C0(0x48u, 6917, &unk_100B91F4);
  sub_100059C0(0x48u, 6918, &unk_100B923C);
  sub_100059C0(0x48u, 6919, &unk_100B9284);
  sub_100059C0(0x48u, 6920, &unk_100B92CC);
  sub_100059C0(0x48u, 6921, &unk_100B9314);
  sub_100059C0(0x48u, 6922, &unk_100B935C);
  sub_100059C0(0x48u, 6923, &unk_100B93A4);
  sub_100059C0(0x48u, 6924, &unk_100B93EC);
  sub_100059C0(0x48u, 6925, &unk_100B9434);
  sub_100059C0(0x48u, 6926, &unk_100B947C);
  sub_100059C0(0x48u, 6927, &unk_100B94C4);
  sub_100059C0(0x48u, 6928, &unk_100B950C);
  sub_100059C0(0x48u, 6929, &unk_100B9554);
  sub_100059C0(0x48u, 6930, &unk_100B959C);
  sub_100059C0(0x48u, 6931, &unk_100B95E4);
  sub_100059C0(0x48u, 6932, &unk_100B962C);
  sub_100059C0(0x48u, 6933, &unk_100B9674);
  sub_100059C0(0x48u, 6934, &unk_100B96BC);
  sub_100059C0(0x48u, 6935, &unk_100B9704);
  sub_100059C0(0x18u, 6163, &unk_100B974C);
  sub_100059C0(0x20u, 6164, &unk_100B9764);
  sub_100059C0(0x20u, 6165, &unk_100B9784);
  sub_100059C0(2u, 6166, &unk_100B97A4);
  sub_100059C0(0xA4u, 40100, &unk_100B97A8);
  sub_100059C0(0xA4u, 40101, &unk_100B984C);
  sub_100059C0(0xA4u, 40102, &unk_100B98F0);
  sub_100059C0(0xA4u, 40103, &unk_100B9994);
  sub_100059C0(0xA4u, 40104, &unk_100B9A38);
  sub_100059C0(0xA4u, 40105, &unk_100B9ADC);
  sub_100059C0(0xA4u, 40106, &unk_100B9B80);
  sub_100059C0(0xA4u, 40107, &unk_100B9C24);
  sub_100059C0(0xA4u, 40108, &unk_100B9CC8);
  sub_100059C0(0xA4u, 40109, &unk_100B9D6C);
  sub_100059C0(0xA4u, 40110, &unk_100B9E10);
  sub_100059C0(0xA4u, 40111, &unk_100B9EB4);
  sub_100059C0(0xA4u, 40112, &unk_100B9F58);
  sub_100059C0(0xA4u, 40113, &unk_100B9FFC);
  sub_100059C0(0xA4u, 40114, &unk_100BA0A0);
  sub_100059C0(0xA4u, 40115, &unk_100BA144);
  sub_100059C0(0xA4u, 40116, &unk_100BA1E8);
  sub_100059C0(0xA4u, 40117, &unk_100BA28C);
  sub_100059C0(0xA4u, 40118, &unk_100BA330);
  sub_100059C0(0xA4u, 40119, &unk_100BA3D4);
  sub_100059C0(0xA4u, 40120, &unk_100BA478);
  sub_100059C0(0xA4u, 40121, &unk_100BA51C);
  sub_100059C0(0xA4u, 40122, &unk_100BA5C0);
  sub_100059C0(0xA4u, 40123, &unk_100BA664);
  sub_100059C0(0xA4u, 40124, &unk_100BA708);
  sub_100059C0(0xA4u, 40125, &unk_100BA7AC);
  sub_100059C0(0xA4u, 40126, &unk_100BA850);
  sub_100059C0(0xA4u, 40127, &unk_100BA8F4);
  sub_100059C0(0xA4u, 40128, &unk_100BA998);
  sub_100059C0(0xA4u, 40129, &unk_100BAA3C);
  sub_100059C0(0xA4u, 40130, &unk_100BAAE0);
  sub_100059C0(0xA4u, 40131, &unk_100BAB84);
  sub_100059C0(0xA4u, 40132, &unk_100BAC28);
  sub_100059C0(0xA4u, 40133, &unk_100BACCC);
  sub_100059C0(0xA4u, 40134, &unk_100BAD70);
  sub_100059C0(0xA4u, 40135, &unk_100BAE14);
  sub_100059C0(0xA4u, 40136, &unk_100BAEB8);
  sub_100059C0(0xA4u, 40137, &unk_100BAF5C);
  sub_100059C0(0xA4u, 40138, &unk_100BB000);
  sub_100059C0(0xA4u, 40139, &unk_100BB0A4);
  sub_100059C0(0xA4u, 40140, &unk_100BB148);
  sub_100059C0(0xA4u, 40141, &unk_100BB1EC);
  sub_100059C0(0xA4u, 40142, &unk_100BB290);
  sub_100059C0(0xA4u, 40143, &unk_100BB334);
  sub_100059C0(0xA4u, 40144, &unk_100BB3D8);
  sub_100059C0(0xA4u, 40145, &unk_100BB47C);
  sub_100059C0(0xA4u, 40146, &unk_100BB520);
  sub_100059C0(0xA4u, 40147, &unk_100BB5C4);
  sub_100059C0(0xA4u, 40148, &unk_100BB668);
  sub_100059C0(0xA4u, 40149, &unk_100BB70C);
  sub_100059C0(0xA4u, 40150, &unk_100BB7B0);
  sub_100059C0(0xA4u, 40151, &unk_100BB854);
  sub_100059C0(0xA4u, 40152, &unk_100BB8F8);
  sub_100059C0(0xA4u, 40153, &unk_100BB99C);
  sub_100059C0(0xA4u, 40154, &unk_100BBA40);
  sub_100059C0(0xA4u, 40155, &unk_100BBAE4);
  sub_100059C0(0xA4u, 40156, &unk_100BBB88);
  sub_100059C0(0xA4u, 40157, &unk_100BBC2C);
  sub_100059C0(0xA4u, 40158, &unk_100BBCD0);
  sub_100059C0(0xA4u, 40159, &unk_100BBD74);
  sub_100059C0(0xA4u, 40160, &unk_100BBE18);
  sub_100059C0(0xA4u, 40161, &unk_100BBEBC);
  sub_100059C0(0xA4u, 40162, &unk_100BBF60);
  sub_100059C0(0xA4u, 40163, &unk_100BC004);
  sub_100059C0(0xA4u, 40164, &unk_100BC0A8);
  sub_100059C0(0xA4u, 40165, &unk_100BC14C);
  sub_100059C0(0xA4u, 40166, &unk_100BC1F0);
  sub_100059C0(0xA4u, 40167, &unk_100BC294);
  sub_100059C0(0xA4u, 40168, &unk_100BC338);
  sub_100059C0(0xA4u, 40169, &unk_100BC3DC);
  sub_100059C0(0xA4u, 40170, &unk_100BC480);
  sub_100059C0(0xA4u, 40171, &unk_100BC524);
  sub_100059C0(0xA4u, 40172, &unk_100BC5C8);
  sub_100059C0(0xA4u, 40173, &unk_100BC66C);
  sub_100059C0(0xA4u, 40174, &unk_100BC710);
  sub_100059C0(0xA4u, 40175, &unk_100BC7B4);
  sub_100059C0(0xA4u, 40176, &unk_100BC858);
  sub_100059C0(0xA4u, 40177, &unk_100BC8FC);
  sub_100059C0(0xA4u, 40178, &unk_100BC9A0);
  sub_100059C0(0xA4u, 40179, &unk_100BCA44);
  sub_100059C0(0xA4u, 40180, &unk_100BCAE8);
  sub_100059C0(0xA4u, 40181, &unk_100BCB8C);
  sub_100059C0(0xA4u, 40182, &unk_100BCC30);
  sub_100059C0(0xA4u, 40183, &unk_100BCCD4);
  sub_100059C0(0xA4u, 40184, &unk_100BCD78);
  sub_100059C0(0xA4u, 40185, &unk_100BCE1C);
  sub_100059C0(0xA4u, 40186, &unk_100BCEC0);
  sub_100059C0(0xA4u, 40187, &unk_100BCF64);
  sub_100059C0(0xA4u, 40188, &unk_100BD008);
  sub_100059C0(0xA4u, 40189, &unk_100BD0AC);
  sub_100059C0(0xA4u, 40190, &unk_100BD150);
  sub_100059C0(0xA4u, 40191, &unk_100BD1F4);
  sub_100059C0(0xA4u, 40192, &unk_100BD298);
  sub_100059C0(0xA4u, 40193, &unk_100BD33C);
  sub_100059C0(0xA4u, 40194, &unk_100BD3E0);
  sub_100059C0(0xA4u, 40195, &unk_100BD484);
  sub_100059C0(0xA4u, 40196, &unk_100BD528);
  sub_100059C0(0xA4u, 40197, &unk_100BD5CC);
  sub_100059C0(0xA4u, 40198, &unk_100BD670);
  sub_100059C0(0xA4u, 40199, &unk_100BD714);
  sub_100059C0(0x20u, 6190, &unk_100BD7B8);
  sub_100059C0(0x20u, 6191, &unk_100BD7D8);
  sub_100059C0(0x20u, 6192, &unk_100BD7F8);
  sub_100059C0(0x20u, 6199, &unk_100BD818);
  sub_100059C0(0x28u, 6207, &unk_100BD838);
  sub_100059C0(4u, 6231, &unk_100BE350);
  sub_100059C0(4u, 6232, &unk_100BE354);
  sub_100059C0(4u, 6233, &unk_100BE358);
  sub_100059C0(4u, 6234, &unk_100BE35C);
  sub_100059C0(0x1Cu, 40000, &unk_100BD860);
  sub_100059C0(0x1Cu, 40001, &unk_100BD87C);
  sub_100059C0(0x1Cu, 40002, &unk_100BD898);
  sub_100059C0(0x1Cu, 40003, &unk_100BD8B4);
  sub_100059C0(0x1Cu, 40004, &unk_100BD8D0);
  sub_100059C0(0x1Cu, 40005, &unk_100BD8EC);
  sub_100059C0(0x1Cu, 40006, &unk_100BD908);
  sub_100059C0(0x1Cu, 40007, &unk_100BD924);
  sub_100059C0(0x1Cu, 40008, &unk_100BD940);
  sub_100059C0(0x1Cu, 40009, &unk_100BD95C);
  sub_100059C0(0x1Cu, 40010, &unk_100BD978);
  sub_100059C0(0x1Cu, 40011, &unk_100BD994);
  sub_100059C0(0x1Cu, 40012, &unk_100BD9B0);
  sub_100059C0(0x1Cu, 40013, &unk_100BD9CC);
  sub_100059C0(0x1Cu, 40014, &unk_100BD9E8);
  sub_100059C0(0x1Cu, 40015, &unk_100BDA04);
  sub_100059C0(0x1Cu, 40016, &unk_100BDA20);
  sub_100059C0(0x1Cu, 40017, &unk_100BDA3C);
  sub_100059C0(0x1Cu, 40018, &unk_100BDA58);
  sub_100059C0(0x1Cu, 40019, &unk_100BDA74);
  sub_100059C0(0x1Cu, 40020, &unk_100BDA90);
  sub_100059C0(0x1Cu, 40021, &unk_100BDAAC);
  sub_100059C0(0x1Cu, 40022, &unk_100BDAC8);
  sub_100059C0(0x1Cu, 40023, &unk_100BDAE4);
  sub_100059C0(0x1Cu, 40024, &unk_100BDB00);
  sub_100059C0(0x1Cu, 40025, &unk_100BDB1C);
  sub_100059C0(0x1Cu, 40026, &unk_100BDB38);
  sub_100059C0(0x1Cu, 40027, &unk_100BDB54);
  sub_100059C0(0x1Cu, 40028, &unk_100BDB70);
  sub_100059C0(0x1Cu, 40029, &unk_100BDB8C);
  sub_100059C0(0x1Cu, 40030, &unk_100BDBA8);
  sub_100059C0(0x1Cu, 40031, &unk_100BDBC4);
  sub_100059C0(0x1Cu, 40032, &unk_100BDBE0);
  sub_100059C0(0x1Cu, 40033, &unk_100BDBFC);
  sub_100059C0(0x1Cu, 40034, &unk_100BDC18);
  sub_100059C0(0x1Cu, 40035, &unk_100BDC34);
  sub_100059C0(0x1Cu, 40036, &unk_100BDC50);
  sub_100059C0(0x1Cu, 40037, &unk_100BDC6C);
  sub_100059C0(0x1Cu, 40038, &unk_100BDC88);
  sub_100059C0(0x1Cu, 40039, &unk_100BDCA4);
  sub_100059C0(0x1Cu, 40040, &unk_100BDCC0);
  sub_100059C0(0x1Cu, 40041, &unk_100BDCDC);
  sub_100059C0(0x1Cu, 40042, &unk_100BDCF8);
  sub_100059C0(0x1Cu, 40043, &unk_100BDD14);
  sub_100059C0(0x1Cu, 40044, &unk_100BDD30);
  sub_100059C0(0x1Cu, 40045, &unk_100BDD4C);
  sub_100059C0(0x1Cu, 40046, &unk_100BDD68);
  sub_100059C0(0x1Cu, 40047, &unk_100BDD84);
  sub_100059C0(0x1Cu, 40048, &unk_100BDDA0);
  sub_100059C0(0x1Cu, 40049, &unk_100BDDBC);
  sub_100059C0(0x1Cu, 40050, &unk_100BDDD8);
  sub_100059C0(0x1Cu, 40051, &unk_100BDDF4);
  sub_100059C0(0x1Cu, 40052, &unk_100BDE10);
  sub_100059C0(0x1Cu, 40053, &unk_100BDE2C);
  sub_100059C0(0x1Cu, 40054, &unk_100BDE48);
  sub_100059C0(0x1Cu, 40055, &unk_100BDE64);
  sub_100059C0(0x1Cu, 40056, &unk_100BDE80);
  sub_100059C0(0x1Cu, 40057, &unk_100BDE9C);
  sub_100059C0(0x1Cu, 40058, &unk_100BDEB8);
  sub_100059C0(0x1Cu, 40059, &unk_100BDED4);
  sub_100059C0(0x1Cu, 40060, &unk_100BDEF0);
  sub_100059C0(0x1Cu, 40061, &unk_100BDF0C);
  sub_100059C0(0x1Cu, 40062, &unk_100BDF28);
  sub_100059C0(0x1Cu, 40063, &unk_100BDF44);
  sub_100059C0(0x1Cu, 40064, &unk_100BDF60);
  sub_100059C0(0x1Cu, 40065, &unk_100BDF7C);
  sub_100059C0(0x1Cu, 40066, &unk_100BDF98);
  sub_100059C0(0x1Cu, 40067, &unk_100BDFB4);
  sub_100059C0(0x1Cu, 40068, &unk_100BDFD0);
  sub_100059C0(0x1Cu, 40069, &unk_100BDFEC);
  sub_100059C0(0x1Cu, 40070, &unk_100BE008);
  sub_100059C0(0x1Cu, 40071, &unk_100BE024);
  sub_100059C0(0x1Cu, 40072, &unk_100BE040);
  sub_100059C0(0x1Cu, 40073, &unk_100BE05C);
  sub_100059C0(0x1Cu, 40074, &unk_100BE078);
  sub_100059C0(0x1Cu, 40075, &unk_100BE094);
  sub_100059C0(0x1Cu, 40076, &unk_100BE0B0);
  sub_100059C0(0x1Cu, 40077, &unk_100BE0CC);
  sub_100059C0(0x1Cu, 40078, &unk_100BE0E8);
  sub_100059C0(0x1Cu, 40079, &unk_100BE104);
  sub_100059C0(0x1Cu, 40080, &unk_100BE120);
  sub_100059C0(0x1Cu, 40081, &unk_100BE13C);
  sub_100059C0(0x1Cu, 40082, &unk_100BE158);
  sub_100059C0(0x1Cu, 40083, &unk_100BE174);
  sub_100059C0(0x1Cu, 40084, &unk_100BE190);
  sub_100059C0(0x1Cu, 40085, &unk_100BE1AC);
  sub_100059C0(0x1Cu, 40086, &unk_100BE1C8);
  sub_100059C0(0x1Cu, 40087, &unk_100BE1E4);
  sub_100059C0(0x1Cu, 40088, &unk_100BE200);
  sub_100059C0(0x1Cu, 40089, &unk_100BE21C);
  sub_100059C0(0x1Cu, 40090, &unk_100BE238);
  sub_100059C0(0x1Cu, 40091, &unk_100BE254);
  sub_100059C0(0x1Cu, 40092, &unk_100BE270);
  sub_100059C0(0x1Cu, 40093, &unk_100BE28C);
  sub_100059C0(0x1Cu, 40094, &unk_100BE2A8);
  sub_100059C0(0x1Cu, 40095, &unk_100BE2C4);
  sub_100059C0(0x1Cu, 40096, &unk_100BE2E0);
  sub_100059C0(0x1Cu, 40097, &unk_100BE2FC);
  sub_100059C0(0x1Cu, 40098, &unk_100BE318);
  sub_100059C0(0x1Cu, 40099, &unk_100BE334);
  sub_100059C0(4u, 6238, &unk_100BE360);
  sub_100059C0(4u, 6239, &unk_100BE364);
  sub_100059C0(4u, 6240, &unk_100BE368);
  sub_100059C0(4u, 6242, &unk_100BE36C);
  sub_100059C0(4u, 6244, &unk_100BE370);
  sub_100059C0(4u, 6245, &unk_100BE374);
  sub_100059C0(4u, 6246, &unk_100BE378);
  sub_100059C0(4u, 6251, &unk_100BE37C);
  sub_100059C0(4u, 6252, &unk_100BE380);
  sub_100059C0(4u, 6253, &unk_100BE384);
  sub_100059C0(4u, 6254, &unk_100BE388);
  sub_100059C0(1u, 6255, &unk_100BE38C);
  sub_100059C0(4u, 6256, &unk_100BE390);
  sub_100059C0(4u, 6257, &unk_100BE394);
  sub_100059C0(0xE2u, 6286, &unk_100BE398);
  v0 = 18000;
  v1 = &unk_100BE47C;
  v2 = 16;
  do
  {
    sub_100059C0(0x11Cu, v0, v1);
    v1 = (char *)v1 + 284;
    ++v0;
    --v2;
  }
  while ( v2 );
  sub_100059C0(4u, 6262, &unk_100BF63C);
  sub_100059C0(0x28u, 6263, &unk_100BF640);
  sub_100059C0(0x28u, 6264, &unk_100BF668);
  sub_100059C0(0x40u, 6268, &unk_100BF690);
  sub_100059C0(4u, 6272, &unk_100BF750);
  sub_100059C0(4u, 6273, &unk_100BF754);
  sub_100059C0(1u, 6274, &unk_100BF758);
  sub_100059C0(2u, 6275, &unk_100BF75A);
  sub_100059C0(1u, 6276, &unk_100BF75C);
  sub_100059C0(1u, 6277, &unk_100BF75D);
  sub_100059C0(1u, 6278, &unk_100BF75E);
  sub_100059C0(0x40u, 6279, &unk_100BF760);
  sub_100059C0(0x28u, 6753, &unk_100C0615);
  sub_100059C0(0x30u, 6754, &unk_100C0640);
  sub_100059C0(0x28u, 6958, &unk_100C0670);
  sub_100059C0(0x80u, 6802, &unk_100BF6D0);
  sub_100059C0(1u, 6760, &unk_100C0698);
  sub_100059C0(0x10u, 6312, &unk_100BFAE4);
  sub_100059C0(0x10u, 6313, &unk_100BFAF4);
  sub_100059C0(0x10u, 6314, &unk_100BFB04);
  sub_100059C0(1u, 6307, &unk_100BFB14);
  sub_100059C0(1u, 6308, &unk_100BFB15);
  sub_100059C0(1u, 6309, &unk_100BFB16);
  sub_100059C0(4u, 6285, &unk_100BFB18);
  sub_100059C0(0xA8u, 6318, &unk_100BFB1C);
  sub_100059C0(4u, 6319, &unk_100BFBC4);
  sub_100059C0(1u, 6350, &unk_100BFBC8);
  sub_100059C0(0x50u, 6351, &unk_100BFBCC);
  sub_100059C0(4u, 6352, &unk_100BFC1C);
  sub_100059C0(4u, 6353, &unk_100BFC20);
  sub_100059C0(0x54u, 6448, &unk_100BFE6C);
  sub_100059C0(0x54u, 6449, &unk_100BFEC0);
  sub_100059C0(8u, 6287, &unk_100BF7C4);
  sub_100059C0(8u, 6288, &unk_100BF7CC);
  sub_100059C0(8u, 6289, &unk_100BF7D4);
  sub_100059C0(8u, 6290, &unk_100BF7DC);
  sub_100059C0(8u, 6291, &unk_100BF7E4);
  sub_100059C0(8u, 6292, &unk_100BF7EC);
  sub_100059C0(8u, 6293, &unk_100BF7F4);
  sub_100059C0(8u, 6294, &unk_100BF7FC);
  sub_100059C0(8u, 6295, &unk_100BF804);
  sub_100059C0(8u, 6296, &unk_100BF80C);
  sub_100059C0(8u, 6297, &unk_100BF814);
  sub_100059C0(8u, 6298, &unk_100BF81C);
  sub_100059C0(8u, 6299, &unk_100BF824);
  sub_100059C0(8u, 6300, &unk_100BF82C);
  sub_100059C0(8u, 6301, &unk_100BF834);
  sub_100059C0(8u, 6302, &unk_100BF83C);
  sub_100059C0(8u, 6303, &unk_100BF844);
  sub_100059C0(8u, 6304, &unk_100BF84C);
  sub_100059C0(8u, 6305, &unk_100BF854);
  sub_100059C0(8u, 6306, &unk_100BF85C);
  sub_100059C0(8u, 6409, &unk_100BF864);
  sub_100059C0(8u, 6410, &unk_100BF86C);
  sub_100059C0(8u, 6411, &unk_100BF874);
  sub_100059C0(8u, 6412, &unk_100BF87C);
  sub_100059C0(8u, 6413, &unk_100BF884);
  sub_100059C0(8u, 6414, &unk_100BF88C);
  sub_100059C0(8u, 6415, &unk_100BF894);
  sub_100059C0(8u, 6416, &unk_100BF89C);
  sub_100059C0(8u, 6417, &unk_100BF8A4);
  sub_100059C0(8u, 6418, &unk_100BF8AC);
  sub_100059C0(8u, 6419, &unk_100BF8B4);
  sub_100059C0(8u, 6420, &unk_100BF8BC);
  sub_100059C0(8u, 6421, &unk_100BF8C4);
  sub_100059C0(8u, 6422, &unk_100BF8CC);
  sub_100059C0(8u, 6423, &unk_100BF8D4);
  sub_100059C0(8u, 6424, &unk_100BF8DC);
  sub_100059C0(8u, 6425, &unk_100BF8E4);
  sub_100059C0(8u, 6426, &unk_100BF8EC);
  sub_100059C0(8u, 6427, &unk_100BF8F4);
  sub_100059C0(8u, 6428, &unk_100BF8FC);
  sub_100059C0(4u, 6429, &unk_100BFE04);
  sub_100059C0(8u, 6430, &unk_100BFE08);
  sub_100059C0(8u, 6431, &unk_100BFE10);
  sub_100059C0(8u, 6432, &unk_100BFE18);
  sub_100059C0(8u, 6433, &unk_100BFE20);
  sub_100059C0(8u, 6434, &unk_100BFE28);
  sub_100059C0(8u, 6435, &unk_100BFE30);
  sub_100059C0(8u, 6436, &unk_100BFE38);
  sub_100059C0(8u, 6437, &unk_100BFE40);
  sub_100059C0(8u, 6438, &unk_100BFE48);
  sub_100059C0(8u, 6439, &unk_100BFE50);
  sub_100059C0(8u, 6440, &unk_100BFE58);
  sub_100059C0(0xAu, 6519, &unk_100C02C4);
  sub_100059C0(4u, 6442, &unk_100BFE60);
  sub_100059C0(4u, 6443, &unk_100BFE64);
  sub_100059C0(0xF0u, 6367, &unk_100BFC24);
  sub_100059C0(0xF0u, 6368, &unk_100BFD14);
  sub_100059C0(1u, 6446, &unk_100BFE68);
  sub_100059C0(6u, 6452, &unk_100BFF14);
  sub_100059C0(4u, 6457, &unk_100BFF1C);
  sub_100059C0(4u, 6458, &unk_100BFF20);
  sub_100059C0(4u, 6459, &unk_100BFF24);
  sub_100059C0(4u, 6460, &unk_100BFF28);
  sub_100059C0(0x208u, 6515, &unk_100BFF2C);
  sub_100059C0(0x160u, 6516, &unk_100C0134);
  sub_100059C0(0x18u, 6517, &unk_100C0294);
  sub_100059C0(0x18u, 6518, &unk_100C02AC);
  sub_100059C0(1u, 6520, &unk_100C02CE);
  sub_100059C0(0x10u, 6521, &unk_100C02D0);
  sub_100059C0(4u, 6523, &unk_100C02E0);
  sub_100059C0(4u, 6524, &unk_100C02E4);
  sub_100059C0(4u, 6525, &unk_100C02E8);
  sub_100059C0(1u, 6526, &unk_100C02EC);
  sub_100059C0(1u, 6527, &unk_100C02ED);
  sub_100059C0(0x50u, 6528, &unk_100C02F0);
  sub_100059C0(4u, 6529, &unk_100C0340);
  sub_100059C0(1u, 6530, &unk_100C0344);
  sub_100059C0(1u, 6531, &unk_100C0345);
  sub_100059C0(1u, 6532, &unk_100C0346);
  sub_100059C0(0x14u, 6533, &unk_100C0347);
  sub_100059C0(0xAu, 6883, &unk_100C0A60);
  sub_100059C0(0xAu, 6884, &unk_100C0A6A);
  sub_100059C0(0xAu, 6885, &unk_100C0A74);
  sub_100059C0(1u, 6664, &unk_100C035B);
  sub_100059C0(1u, 6666, &unk_100C035C);
  sub_100059C0(1u, 6667, &unk_100C035D);
  sub_100059C0(1u, 6668, &unk_100C035E);
  sub_100059C0(0xA0u, 6669, &unk_100C0360);
  sub_100059C0(2u, 6670, &unk_100C0450);
  sub_100059C0(4u, 6671, &unk_100C0454);
  sub_100059C0(4u, 6672, &unk_100C0458);
  sub_100059C0(4u, 6673, &unk_100C045C);
  sub_100059C0(4u, 6674, &unk_100C0460);
  sub_100059C0(4u, 6675, &unk_100C0464);
  sub_100059C0(4u, 6676, &unk_100C046C);
  sub_100059C0(4u, 6677, &unk_100C0474);
  sub_100059C0(4u, 6678, &unk_100C0478);
  sub_100059C0(1u, 6679, &unk_100C047C);
  sub_100059C0(0x140u, 6680, &unk_100C0480);
  sub_100059C0(4u, 6882, &unk_100C0A5C);
  sub_100059C0(0xCu, 6652, &unk_100C05C0);
  sub_100059C0(0x48u, 6653, &unk_100C05CC);
  sub_100059C0(1u, 6688, &unk_100C0614);
  sub_100059C0(4u, 6771, &unk_100C069C);
  sub_100059C0(4u, 6772, &unk_100C06A0);
  sub_100059C0(8u, 6787, &unk_100C06A4);
  sub_100059C0(1u, 6832, &unk_100C06D4);
  sub_100059C0(1u, 6833, &unk_100C06D5);
  sub_100059C0(1u, 6834, &unk_100C06D6);
  sub_100059C0(4u, 6835, &unk_100C06D8);
  sub_100059C0(4u, 6836, &unk_100C06DC);
  sub_100059C0(4u, 6837, &unk_100C06E0);
  sub_100059C0(4u, 6838, &unk_100C06E4);
  sub_100059C0(1u, 6839, &unk_100C06E8);
  sub_100059C0(0x50u, 6840, &unk_100C0400);
  sub_100059C0(4u, 6841, &unk_100C06EC);
  sub_100059C0(4u, 6842, &unk_100C06F0);
  sub_100059C0(4u, 6843, &unk_100C06F4);
  sub_100059C0(1u, 6844, &unk_100C06F8);
  sub_100059C0(0x360u, 6845, &unk_100C06FC);
  sub_100059C0(4u, 6846, &unk_100C0468);
  sub_100059C0(4u, 6847, &unk_100C0470);
  result = 1;
  dword_101761B0 = (int)&unk_100B8860;
  return result;
}
// 101761B0: using guessed type int dword_101761B0;

//----- (10007820) --------------------------------------------------------
int sub_10007820()
{
  int result; // eax@1

  sub_10024A80(6361, (int)&unk_100C2230, 4);
  result = sub_10024A80(6362, (int)&unk_100C2234, 4);
  dword_100C2238 = 1379255385;
  return result;
}
// 100C2238: using guessed type int dword_100C2238;

//----- (10007850) --------------------------------------------------------
char __cdecl sub_10007850(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_1000DDE0(7, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
     || *(float *)a1 > 39950.746
     || *(float *)a1 < -39950.746) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (100078B0) --------------------------------------------------------
char __cdecl sub_100078B0(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_1000DDE0(2, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040 || *(float *)a1 > 512.0 || *(float *)a1 < -512.0) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10007910) --------------------------------------------------------
char __cdecl sub_10007910(float *a1)
{
  float *v1; // esi@1
  char v2; // bl@1

  v1 = a1;
  *a1 = 0.0;
  v2 = sub_10007850(&a1);
  if ( v2 )
    *v1 = sub_10009E30() + *(float *)&a1;
  return v2;
}
// 10009E30: using guessed type double sub_10009E30(void);

//----- (10007940) --------------------------------------------------------
char __cdecl sub_10007940(float *a1)
{
  float *v1; // esi@1
  char result; // al@4
  float v3; // [sp+8h] [bp-4h]@1

  v1 = a1;
  *a1 = 9.8999998e24;
  if ( sub_100078B0(&v3) && sub_10007910((float *)&a1) )
  {
    *(float *)&a1 = *(float *)&a1 * 3.280839920043945;
    if ( *(float *)&a1 < 36089.0 )
    {
      result = 1;
      *v1 = v3 - (15.0 - *(float *)&a1 / 1000.0 * 1.981199979782104);
    }
    else
    {
      result = 1;
      *v1 = v3 - -56.5;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100079E0) --------------------------------------------------------
char __cdecl sub_100079E0(float a1, int a2)
{
  double v2; // st7@1
  long double v3; // st7@1
  char result; // al@2
  float v5; // [sp+4h] [bp+4h]@1
  float v6; // [sp+4h] [bp+4h]@4
  float v7; // [sp+4h] [bp+4h]@5

  v2 = a1;
  v5 = a1 / 101325.0;
  v3 = v2 / 22631.953125;
  if ( v3 > 0.0 )
  {
    if ( v5 <= 0.223360002040863 )
    {
      v7 = log(v3);
      result = 1;
      *(float *)a2 = 11000.232421875 - v7 * 6341.615234375;
    }
    else
    {
      v6 = pow(v5, 0.1902630904662425);
      result = 1;
      *(float *)a2 = (v6 - 1.0) * -44330.76953125;
    }
  }
  else
  {
    *(float *)a2 = 9.8999998e24;
    result = 0;
  }
  return result;
}

//----- (10007A80) --------------------------------------------------------
double sub_10007A80()
{
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v1 = 9.8999998e24;
  sub_10024A40(10043, &v2, 4, &v1);
  return v2;
}

//----- (10007AB0) --------------------------------------------------------
double sub_10007AB0()
{
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v1 = 9.8999998e24;
  sub_10024A40(10002, &v2, 4, &v1);
  return v2;
}

//----- (10007AE0) --------------------------------------------------------
void __usercall sub_10007AE0(int a1@<esi>, int a2, float a3)
{
  signed int v3; // ebx@1
  int v4; // ecx@1
  int v5; // edx@1
  double v6; // st7@3
  double v7; // st6@4
  double v8; // st6@5
  double v9; // st7@5
  double v10; // st6@8
  double v11; // st7@8
  int v12; // edi@10
  signed int v13; // ecx@10
  int v14; // ebx@11
  signed int v15; // edx@11
  int v16; // ebp@13
  float *v17; // eax@19
  int v18; // [sp+4h] [bp-4h]@13
  float *v19; // [sp+10h] [bp+8h]@11
  float v20; // [sp+10h] [bp+8h]@19

  v3 = *(_BYTE *)(a1 + 320);
  v4 = v3 - 1;
  v5 = 0;
  if ( *(float *)(a1 + 8 * v3 - 4) < (double)*(float *)(a1 + 4) )
  {
    v5 = v3 - 1;
    v4 = 0;
  }
  v6 = a3;
  if ( *(float *)(a1 + 8 * v4 + 4) < (double)a3 )
  {
    v7 = 0.0;
    if ( 0.0 != v6 )
    {
      v8 = *(float *)(a1 + 8 * v4) / v6;
      v9 = 0.0;
      *(float *)a2 = v8;
      *(float *)(a2 + 4) = *(float *)&v9;
      return;
    }
LABEL_9:
    *(float *)a2 = v7;
    *(float *)(a2 + 4) = v7;
    return;
  }
  if ( *(float *)(a1 + 8 * v5 + 4) > v6 )
  {
    v7 = 0.0;
    if ( 0.0 != v6 )
    {
      v10 = *(float *)(a1 + 8 * v5) / v6;
      v11 = 0.0;
      *(float *)a2 = v10;
      *(float *)(a2 + 4) = *(float *)&v11;
      return;
    }
    goto LABEL_9;
  }
  v12 = 0;
  v13 = 1;
  if ( v3 <= 1 )
  {
LABEL_18:
    *(float *)a2 = 0.0;
    *(float *)(a2 + 4) = *(float *)(a1 + 8 * v12);
  }
  else
  {
    v14 = 0;
    v15 = 8;
    v19 = (float *)(a1 + 12);
    while ( 1 )
    {
      if ( *(float *)(v14 + a1 + 4) >= (double)*v19 )
      {
        v12 = v13 - 1;
        v14 = v15 - 8;
        v16 = v13;
        v18 = v15;
      }
      else
      {
        v12 = v13;
        v14 = v15;
        v16 = v13 - 1;
        v18 = v15 - 8;
      }
      if ( *(float *)(v14 + a1 + 4) > v6 && *(float *)(v18 + a1 + 4) <= v6 )
        break;
      v19 += 2;
      ++v13;
      v15 += 8;
      if ( v13 >= *(_BYTE *)(a1 + 320) )
        goto LABEL_18;
    }
    v17 = (float *)(a1 + 8 * v12 + 4);
    v20 = (*(float *)(a1 + 8 * v12) - *(float *)(a1 + 8 * v16)) / (*v17 - *(float *)(a1 + 8 * v16 + 4));
    *(float *)a2 = v20;
    *(float *)(a2 + 4) = *(float *)(a1 + 8 * v12) - v20 * *v17;
  }
}

//----- (10007C40) --------------------------------------------------------
char __usercall sub_10007C40@<al>(float *a1@<edi>, unsigned __int16 a2@<si>, unsigned __int8 a3)
{
  double v3; // st7@8
  char result; // al@10
  char v5; // [sp+7h] [bp-29h]@3
  float v6; // [sp+8h] [bp-28h]@1
  float v7; // [sp+Ch] [bp-24h]@3
  int v8; // [sp+10h] [bp-20h]@1
  int v9; // [sp+14h] [bp-1Ch]@1
  int v10; // [sp+18h] [bp-18h]@1
  int v11; // [sp+1Ch] [bp-14h]@1
  float v12[4]; // [sp+20h] [bp-10h]@1

  v6 = 0.0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  if ( sub_10024A40(6117, v12, 16, &v8) )
    sub_10009550("..\\lib\\adl\\iop_eis_intf.c", 2716, 0, 0);
  sub_10004FF0(1, 0x50u, &v5);
  if ( sub_10024A80(6354, (int)&v7, 4) )
    sub_10009550("..\\lib\\adl\\iop_eis_intf.c", 2735, 0, 0);
  if ( (sub_1000B6C0(a2) || v5) && sub_1000D550(a2, &v6) )
  {
    v6 = v12[2 * a3] * v6;
    v3 = v6;
    *a1 = v6;
    if ( v7 > v3 )
      *a1 = 0.0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10007C40: using guessed type float var_10[4];

//----- (10007D30) --------------------------------------------------------
char __usercall sub_10007D30@<al>(unsigned __int16 *a1@<eax>, int a2, float *a3, unsigned __int8 a4)
{
  int v4; // ecx@1
  unsigned __int16 *v5; // esi@1
  char v6; // al@1
  double v7; // st7@1
  int v8; // ebp@1
  unsigned __int8 v9; // bl@4
  char result; // al@7
  int v11; // eax@9
  unsigned __int16 *v12; // edi@9
  int v13; // eax@11
  int v14; // eax@14
  int v15; // eax@17
  double v16; // st7@22
  double v17; // st7@24
  int v18; // edi@31
  int v19; // [sp-8h] [bp-A0h]@12
  int v20; // [sp-4h] [bp-9Ch]@12
  float v21; // [sp+0h] [bp-98h]@12
  float v22; // [sp+14h] [bp-84h]@1
  float v23; // [sp+18h] [bp-80h]@1
  int v24; // [sp+1Ch] [bp-7Ch]@1
  int v25; // [sp+20h] [bp-78h]@5
  float v26; // [sp+24h] [bp-74h]@6
  float v27; // [sp+28h] [bp-70h]@9
  float v28; // [sp+2Ch] [bp-6Ch]@9
  float v29; // [sp+38h] [bp-60h]@10
  float v30; // [sp+3Ch] [bp-5Ch]@11
  float v31; // [sp+48h] [bp-50h]@13
  float v32; // [sp+4Ch] [bp-4Ch]@14
  float v33; // [sp+70h] [bp-28h]@16
  float v34; // [sp+74h] [bp-24h]@17

  v4 = a2;
  v5 = a1;
  *a3 = -1.0;
  v6 = *(_BYTE *)(a2 + 320);
  v7 = 0.0;
  v8 = 0;
  v22 = 0.0;
  v23 = 0.0;
  v24 = 0;
  if ( !v6 || v6 == 1 && 0.0 == *(float *)a2 )
  {
    if ( a4 )
    {
      v18 = a4;
      do
      {
        if ( sub_1000B6C0(*v5) )
        {
          ++v8;
          if ( sub_1000D6D0((int)v5, *v5, &v22) )
          {
            ++v24;
            v23 = v23 + v22;
          }
        }
        ++v5;
        --v18;
      }
      while ( v18 );
      if ( v8 != v24 )
        goto LABEL_42;
    }
    *a3 = v23;
    if ( v8 <= 0 )
LABEL_42:
      result = 0;
    else
      result = 1;
    return result;
  }
  v9 = 0;
  if ( !a4 )
    goto LABEL_5;
  while ( 2 )
  {
    v28 = v7;
    v11 = v5[v9];
    v27 = v7;
    v12 = &v5[v9];
    switch ( v11 )
    {
      case 58:
      case 59:
        if ( !sub_100249E0(6091, (int)&v29, 16) )
        {
          v13 = 8 * *v12 - 464;
          v28 = *(float *)((char *)&v29 + v13);
          v27 = *(float *)((char *)&v30 + v13);
          goto LABEL_20;
        }
        v21 = 0.0;
        v20 = 0;
        v19 = 2889;
        goto LABEL_19;
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
        if ( !sub_100249E0(6090, (int)&v31, 40) )
        {
          v14 = 8 * *v12 - 480;
          v28 = *(float *)((char *)&v31 + v14);
          v27 = *(float *)((char *)&v32 + v14);
          goto LABEL_20;
        }
        v21 = 0.0;
        v20 = 0;
        v19 = 2921;
        goto LABEL_19;
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
        if ( sub_100249E0(6092, (int)&v33, 40) )
        {
          v21 = 0.0;
          v20 = 0;
          v19 = 2953;
LABEL_19:
          sub_10009550("..\\lib\\adl\\iop_eis_intf.c", v19, v20, (char *)LODWORD(v21));
        }
        else
        {
          v15 = 8 * *v12 - 520;
          v28 = *(float *)((char *)&v33 + v15);
          v27 = *(float *)((char *)&v34 + v15);
        }
LABEL_20:
        if ( sub_1000B6C0(*v12) )
        {
          ++v8;
          if ( sub_1000D550(*v12, &v22) )
          {
            v16 = v22;
            if ( v27 >= (double)v22 )
              v16 = v27;
            v22 = v16;
            v17 = v22;
            if ( v28 <= (double)v22 )
              v17 = v28;
            ++v24;
            v22 = v17;
            v23 = v22 + v23;
          }
        }
        if ( ++v9 < a4 )
        {
          v7 = 0.0;
          continue;
        }
        v4 = a2;
LABEL_5:
        sub_10007AE0(v4, (int)&v25, v23);
        if ( v8 != v24 || (*a3 = *(float *)&v25 * v23 + v26, v8 <= 0) )
LABEL_29:
          result = 0;
        else
          result = 1;
        return result;
      default:
        goto LABEL_29;
    }
  }
}

//----- (10008010) --------------------------------------------------------
char __cdecl sub_10008010(float *a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-144h]@1

  if ( sub_100249E0(6266, (int)&v2, 324) )
  {
    sub_10009550("..\\lib\\adl\\iop_eis_intf.c", 590, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10007D30((unsigned __int16 *)&unk_1004C61C, (int)&v2, a1, 2u);
  }
  return result;
}

//----- (10008080) --------------------------------------------------------
char __cdecl sub_10008080(float *a1)
{
  return sub_10007C40(a1, 0x14u, 0);
}

//----- (100080A0) --------------------------------------------------------
char __cdecl sub_100080A0(float *a1)
{
  return sub_10007C40(a1, 0x2Du, 1u);
}

//----- (100080C0) --------------------------------------------------------
char __cdecl sub_100080C0(float *a1)
{
  char v1; // bl@1
  char result; // al@4
  float v3; // [sp+4h] [bp-8h]@1
  float v4; // [sp+8h] [bp-4h]@1

  v3 = 0.0;
  v4 = 0.0;
  v1 = 0;
  if ( sub_10008080(&v3) )
  {
    v1 = 1;
    v4 = v3 + 0.0;
  }
  if ( sub_100080A0(&v3) )
  {
    result = 1;
    v4 = v4 + v3;
    *a1 = v4;
  }
  else if ( v1 )
  {
    result = v1;
    *a1 = v4;
  }
  else
  {
    *a1 = 9.8999998e24;
    result = 0;
  }
  return result;
}

//----- (10008150) --------------------------------------------------------
char __cdecl sub_10008150(float *a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-144h]@1

  if ( sub_100249E0(6265, (int)&v2, 324) )
  {
    sub_10009550("..\\lib\\adl\\iop_eis_intf.c", 1606, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10007D30(L"<=>?@", (int)&v2, a1, 5u);
  }
  return result;
}
// 1004C628: using guessed type wchar_t a__[6];

//----- (100081C0) --------------------------------------------------------
char __cdecl sub_100081C0(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  const wchar_t *v3; // esi@3
  int v4; // [sp+4h] [bp-154h]@5
  char v5[4]; // [sp+8h] [bp-150h]@5
  int v6; // [sp+Ch] [bp-14Ch]@5
  char v7; // [sp+10h] [bp-148h]@6
  char v8; // [sp+14h] [bp-144h]@1

  v1 = 0;
  if ( sub_100249E0(6266, (int)&v8, 324) )
  {
    sub_10009550("..\\lib\\adl\\iop_eis_intf.c", 1847, 0, "Center cal points undefined");
    result = 0;
  }
  else
  {
    v3 = L":;<=>?@";
    while ( !v1 )
    {
      LOWORD(v4) = *v3;
      v1 = sub_1000F650(v4, v5, &v6);
      if ( v1 )
        v1 = sub_10005900(v5[0], v6, &v7);
      ++v3;
      if ( (signed int)v3 >= (signed int)L"\u3b00\u3c00\u3d00\u3e00\u3f00\u4000" )
      {
        if ( !v1 )
          goto LABEL_10;
        break;
      }
    }
    v1 = sub_10007D30((unsigned __int16 *)&v4, (int)&v8, a1, 1u);
LABEL_10:
    result = v1;
  }
  return result;
}
// 1004C634: using guessed type wchar_t a___0[8];

//----- (10008290) --------------------------------------------------------
char __cdecl sub_10008290(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  wchar_t *v3; // esi@3
  int v4; // [sp+4h] [bp-154h]@5
  char v5[4]; // [sp+8h] [bp-150h]@5
  int v6; // [sp+Ch] [bp-14Ch]@5
  char v7; // [sp+10h] [bp-148h]@6
  char v8; // [sp+14h] [bp-144h]@1

  v1 = 0;
  if ( sub_100249E0(6265, (int)&v8, 324) )
  {
    sub_10009550("..\\lib\\adl\\iop_eis_intf.c", 1946, 0, "Left cal points undefined");
    result = 0;
  }
  else
  {
    v3 = L"\u3b00\u3c00\u3d00\u3e00\u3f00\u4000";
    while ( !v1 )
    {
      LOWORD(v4) = *v3;
      v1 = sub_1000F650(v4, v5, &v6);
      if ( v1 )
        v1 = sub_10005900(v5[0], v6, &v7);
      ++v3;
      if ( (signed int)v3 >= (signed int)&a___0[7] )
      {
        if ( !v1 )
          goto LABEL_10;
        break;
      }
    }
    v1 = sub_10007D30((unsigned __int16 *)&v4, (int)&v8, a1, 1u);
LABEL_10:
    result = v1;
  }
  return result;
}
// 1004C634: using guessed type wchar_t a___0[8];

//----- (10008360) --------------------------------------------------------
char __cdecl sub_10008360(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  const wchar_t *v3; // esi@3
  int v4; // [sp+4h] [bp-154h]@5
  char v5[4]; // [sp+8h] [bp-150h]@5
  int v6; // [sp+Ch] [bp-14Ch]@5
  char v7; // [sp+10h] [bp-148h]@6
  char v8; // [sp+14h] [bp-144h]@1

  v1 = 0;
  if ( sub_100249E0(6267, (int)&v8, 324) )
  {
    sub_10009550("..\\lib\\adl\\iop_eis_intf.c", 2045, 0, "Right cal points undefined");
    result = 0;
  }
  else
  {
    v3 = L"ABCDE";
    while ( !v1 )
    {
      LOWORD(v4) = *v3;
      v1 = sub_1000F650(v4, v5, &v6);
      if ( v1 )
        v1 = sub_10005900(v5[0], v6, &v7);
      ++v3;
      if ( (signed int)v3 >= (signed int)&aAbcde[5] )
      {
        if ( !v1 )
          goto LABEL_10;
        break;
      }
    }
    v1 = sub_10007D30((unsigned __int16 *)&v4, (int)&v8, a1, 1u);
LABEL_10:
    result = v1;
  }
  return result;
}
// 1004C644: using guessed type wchar_t aAbcde[6];

//----- (10008430) --------------------------------------------------------
char __cdecl sub_10008430(float *a1)
{
  char v1; // bl@1
  char result; // al@6
  float v3; // [sp+4h] [bp-8h]@1
  float v4; // [sp+8h] [bp-4h]@1

  v3 = 0.0;
  v4 = 0.0;
  v1 = 0;
  if ( sub_100081C0(&v3) )
  {
    v1 = 1;
    v4 = v3 + 0.0;
  }
  if ( sub_10008290(&v3) )
  {
    v1 = 1;
    v4 = v4 + v3;
  }
  if ( sub_10008360(&v3) )
  {
    v4 = v4 + v3;
    *a1 = v4;
    result = 1;
  }
  else
  {
    if ( v1 )
      *a1 = v4;
    result = v1;
  }
  return result;
}

//----- (100084D0) --------------------------------------------------------
char __cdecl sub_100084D0(float *a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-144h]@1

  if ( sub_100249E0(6267, (int)&v2, 324) )
  {
    sub_10009550("..\\lib\\adl\\iop_eis_intf.c", 2199, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10007D30(L"ABCDE", (int)&v2, a1, 5u);
  }
  return result;
}
// 1004C650: using guessed type wchar_t aAbcde_0[6];

//----- (10008540) --------------------------------------------------------
double sub_10008540()
{
  int v0; // eax@1
  double result; // st7@1
  float v2; // [sp+0h] [bp-10h]@1
  float v3; // [sp+4h] [bp-Ch]@1
  double v4; // [sp+8h] [bp-8h]@2

  v3 = 9.8999998e24;
  v0 = sub_10024A40(10009, &v2, 4, &v3);
  result = v2;
  if ( !v0 )
  {
    v4 = v2;
    v2 = v4 - sub_10007AB0();
    if ( v2 >= 0.0 )
    {
      result = v2;
    }
    else
    {
      v2 = 0.0;
      result = (float)0.0;
    }
  }
  return result;
}

//----- (100085A0) --------------------------------------------------------
char __cdecl sub_100085A0(float *a1)
{
  char v1; // bl@1
  char result; // al@6
  float v3; // [sp+4h] [bp-8h]@1
  float v4; // [sp+8h] [bp-4h]@1

  v3 = 0.0;
  v4 = 0.0;
  v1 = 0;
  if ( sub_10008150(&v3) )
  {
    v1 = 1;
    v4 = v3 + 0.0;
  }
  if ( sub_10008010(&v3) )
  {
    v1 = 1;
    v4 = v4 + v3;
  }
  if ( sub_100084D0(&v3) )
  {
    v4 = v4 + v3;
    *a1 = v4;
    result = 1;
  }
  else
  {
    if ( v1 )
      *a1 = v4;
    result = v1;
  }
  return result;
}

//----- (10008640) --------------------------------------------------------
void sub_10008640()
{
  dword_101761AC = -15;
}
// 101761AC: using guessed type int dword_101761AC;

//----- (10008650) --------------------------------------------------------
signed int sub_10008650()
{
  return sub_10025030((int)&off_1004C6E8);
}
// 1004C6E8: using guessed type char *off_1004C6E8;

//----- (10008660) --------------------------------------------------------
bool __cdecl sub_10008660(float *a1)
{
  bool v1; // bl@1
  int v2; // eax@2

  *a1 = 0.0;
  v1 = 0;
  if ( (unsigned __int8)sub_10008650() )
  {
    sub_10024870(101, 60000);
    v2 = dword_101761AC;
    if ( *(_BYTE *)(dword_101761AC + 1451) )
    {
      *a1 = *(float *)(dword_101761AC + 1480);
      v2 = dword_101761AC;
    }
    v1 = *(_WORD *)(v2 + 1456) > 1u;
    sub_10024850(101);
  }
  return v1;
}
// 101761AC: using guessed type int dword_101761AC;

//----- (100086C0) --------------------------------------------------------
int __cdecl sub_100086C0(char a1, float a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  unsigned int v6; // esi@7
  int result; // eax@7
  double v8; // st6@11
  unsigned int v9; // ecx@14
  unsigned int v10; // edi@14
  char *v11; // edx@14
  signed int v12; // ebx@14
  int v13; // edx@56
  int v14; // edi@56
  char *v15; // ecx@56
  signed int v16; // ebp@56
  int v17; // ebp@63
  unsigned int v18; // ecx@63
  double v19; // st7@63
  signed int v20; // edi@64
  char *v21; // edx@64
  float *v22; // edx@81
  char v23; // [sp+Fh] [bp-4D9h]@7
  int v24; // [sp+18h] [bp-4D0h]@7
  float v25; // [sp+1Ch] [bp-4CCh]@61
  float v26; // [sp+20h] [bp-4C8h]@7
  float v27; // [sp+24h] [bp-4C4h]@11
  float v28[4]; // [sp+28h] [bp-4C0h]@11
  char v29; // [sp+38h] [bp-4B0h]@64
  float v30; // [sp+278h] [bp-270h]@7
  float v31; // [sp+27Ch] [bp-26Ch]@10
  float v32; // [sp+280h] [bp-268h]@9
  char v33; // [sp+284h] [bp-264h]@14
  char v34; // [sp+4C4h] [bp-24h]@56

  v5 = 0;
  if ( a3 )
    *(float *)a3 = 0.0;
  if ( a4 )
    *(float *)a4 = 0.0;
  if ( a5 )
    *(float *)a5 = 0.0;
  *(float *)&v24 = 9.8999998e24;
  v23 = 0;
  v6 = 0;
  memset(&v26, 0, 0x258u);
  result = sub_100249E0(42065, (int)&v30, 624);
  if ( !a1 )
  {
    if ( v30 == 0.0 )
    {
      v8 = 9.8999998e24;
    }
    else if ( v32 == 9.8999998e24 || v31 == 9.8999998e24 )
    {
      v8 = 9.8999998e24;
    }
    else
    {
      v6 = 1;
      v26 = v30;
      v28[0] = v32;
      v8 = 9.8999998e24;
      v27 = v31;
    }
    v9 = 12 * v6;
    v10 = 0;
    v11 = &v33;
    v12 = 6;
    do
    {
      if ( 0.0 != *(float *)v11
        && *(float *)((char *)&v26 + v10) < (double)*(float *)v11
        && v8 != *((float *)v11 + 2)
        && v8 != *((float *)v11 + 1) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *(float *)v11;
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 2);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 1);
      }
      if ( 0.0 != *((float *)v11 + 3)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 3)
        && v8 != *((float *)v11 + 5)
        && v8 != *((float *)v11 + 4) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 3);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 5);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 4);
      }
      if ( 0.0 != *((float *)v11 + 6)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 6)
        && v8 != *((float *)v11 + 8)
        && v8 != *((float *)v11 + 7) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 6);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 8);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 7);
      }
      if ( 0.0 != *((float *)v11 + 9)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 9)
        && v8 != *((float *)v11 + 11)
        && v8 != *((float *)v11 + 10) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 9);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 11);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 10);
      }
      if ( 0.0 != *((float *)v11 + 12)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 12)
        && v8 != *((float *)v11 + 14)
        && v8 != *((float *)v11 + 13) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 12);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 14);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 13);
      }
      if ( 0.0 != *((float *)v11 + 15)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 15)
        && v8 != *((float *)v11 + 17)
        && v8 != *((float *)v11 + 16) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 15);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 17);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 16);
      }
      if ( 0.0 != *((float *)v11 + 18)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 18)
        && v8 != *((float *)v11 + 20)
        && v8 != *((float *)v11 + 19) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 18);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 20);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 19);
      }
      if ( 0.0 != *((float *)v11 + 21)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 21)
        && v8 != *((float *)v11 + 23)
        && v8 != *((float *)v11 + 22) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 21);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 23);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 22);
      }
      v11 += 96;
      --v12;
    }
    while ( v12 );
    v13 = 12 * v6;
    v14 = 12 * v5;
    v15 = &v34;
    v16 = 1;
    do
    {
      if ( 0.0 != *(float *)v15
        && *(float *)((char *)&v26 + v14) < (double)*(float *)v15
        && v8 != *((float *)v15 + 2)
        && v8 != *((float *)v15 + 1) )
      {
        v14 = v13;
        *(float *)((char *)&v26 + v13) = *(float *)v15;
        ++v6;
        v13 += 12;
        *(float *)((char *)&v25 + v13) = *((float *)v15 + 2);
        *(int *)((char *)&v24 + v13) = *((int *)v15 + 1);
      }
      v15 += 12;
      --v16;
    }
    while ( v16 );
    v17 = 0;
    v18 = 0;
    v19 = a2;
    if ( (signed int)v6 < 4 )
    {
LABEL_80:
      if ( v18 < v6 )
      {
        v22 = &v26 + 3 * v18;
        do
        {
          if ( v23 )
            break;
          if ( v19 == *v22 )
          {
            v23 = 1;
            v17 = v18;
          }
          else
          {
            v25 = *v22 - v19;
            if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
            {
              v17 = v18;
              v24 = LODWORD(v25) & 0x7FFFFFFF;
            }
          }
          ++v18;
          v22 += 3;
        }
        while ( v18 < v6 );
      }
    }
    else
    {
      v20 = 3;
      v21 = &v29;
      while ( !v23 )
      {
        if ( v19 == *((float *)v21 - 6) )
        {
          v17 = v18;
          break;
        }
        v25 = *((float *)v21 - 6) - v19;
        if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
        {
          v17 = v18;
          v24 = LODWORD(v25) & 0x7FFFFFFF;
        }
        if ( v19 == *((float *)v21 - 3) )
        {
          v17 = v18 + 1;
          break;
        }
        v25 = *((float *)v21 - 3) - v19;
        if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
        {
          v17 = v20 - 2;
          v24 = LODWORD(v25) & 0x7FFFFFFF;
        }
        if ( v19 == *(float *)v21 )
        {
          v17 = v18 + 2;
          break;
        }
        v25 = *(float *)v21 - v19;
        if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
        {
          v17 = v20 - 1;
          v24 = LODWORD(v25) & 0x7FFFFFFF;
        }
        if ( v19 == *((float *)v21 + 3) )
        {
          v23 = 1;
          v17 = v20;
        }
        else
        {
          v25 = *((float *)v21 + 3) - v19;
          if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
          {
            v17 = v20;
            v24 = LODWORD(v25) & 0x7FFFFFFF;
          }
        }
        v18 += 4;
        v21 += 48;
        v20 += 4;
        if ( v18 >= v6 - 3 )
          goto LABEL_80;
      }
    }
    if ( a3 )
      *(float *)a3 = sub_1000F6B0(*(&v26 + 3 * v17));
    if ( a4 )
      *(float *)a4 = v28[3 * v17] * 0.02539999969303608;
    result = a5;
    if ( a5 )
      *(float *)a5 = 0.02539999969303608 * *(&v27 + 3 * v17);
  }
  return result;
}
// 100086C0: using guessed type float var_4C0[4];

//----- (10008D10) --------------------------------------------------------
double sub_10008D10()
{
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v1 = 0.0;
  v2 = 0.0;
  sub_10024BD0(3875, &v1, 4, &v2);
  return v1;
}

//----- (10008D40) --------------------------------------------------------
double __cdecl sub_10008D40(int a1, float a2, float a3)
{
  int v3; // ecx@0
  double result; // st7@2

  if ( sub_10009E80(v3) == 24 )
  {
    *(float *)a1 = a2 * 453.5924;
    result = a2;
  }
  else
  {
    *(float *)a1 = a3 * 1000.0;
    result = a3;
  }
  return result;
}

//----- (10008D80) --------------------------------------------------------
char __cdecl sub_10008D80(float *a1, float *a2, float *a3, char a4)
{
  float *v4; // ecx@10
  signed int v5; // edx@10
  double v6; // st7@29
  double v7; // st7@34
  double v8; // st7@37
  double v9; // st6@37
  double v10; // st5@43
  double v11; // rtt@48
  double v12; // st5@48
  double v13; // st7@48
  char result; // al@48
  char v15; // [sp+22h] [bp-3EEh]@1
  char v16; // [sp+23h] [bp-3EDh]@1
  float v17; // [sp+24h] [bp-3ECh]@1
  float v18; // [sp+28h] [bp-3E8h]@1
  float v19; // [sp+2Ch] [bp-3E4h]@1
  float v20; // [sp+30h] [bp-3E0h]@1
  float v21; // [sp+34h] [bp-3DCh]@1
  float v22; // [sp+38h] [bp-3D8h]@1
  int v23; // [sp+3Ch] [bp-3D4h]@1
  int v24; // [sp+40h] [bp-3D0h]@1
  float v25; // [sp+44h] [bp-3CCh]@29
  int v26; // [sp+48h] [bp-3C8h]@10
  char v27; // [sp+4Ch] [bp-3C4h]@10
  char v28; // [sp+68h] [bp-3A8h]@10
  char v29; // [sp+6Ch] [bp-3A4h]@10
  char v30; // [sp+8Ch] [bp-384h]@10
  char v31; // [sp+ACh] [bp-364h]@10
  char v32; // [sp+CCh] [bp-344h]@10
  char v33; // [sp+ECh] [bp-324h]@10
  char v34; // [sp+10Ch] [bp-304h]@10
  char v35; // [sp+12Ch] [bp-2E4h]@10
  char v36; // [sp+14Ch] [bp-2C4h]@10
  char v37; // [sp+16Ch] [bp-2A4h]@10
  char v38; // [sp+18Ch] [bp-284h]@10
  char v39; // [sp+1ACh] [bp-264h]@10
  char v40; // [sp+1CCh] [bp-244h]@10
  char v41; // [sp+1ECh] [bp-224h]@10
  char v42; // [sp+20Ch] [bp-204h]@10
  char v43; // [sp+22Ch] [bp-1E4h]@10
  char v44; // [sp+24Ch] [bp-1C4h]@10
  char v45; // [sp+26Ch] [bp-1A4h]@10
  char v46; // [sp+28Ch] [bp-184h]@10
  char v47; // [sp+2ACh] [bp-164h]@10
  char v48; // [sp+2CCh] [bp-144h]@10
  char v49; // [sp+2ECh] [bp-124h]@10
  char v50; // [sp+30Ch] [bp-104h]@10
  char v51; // [sp+32Ch] [bp-E4h]@10
  char v52; // [sp+34Ch] [bp-C4h]@10
  char v53; // [sp+36Ch] [bp-A4h]@10
  char v54; // [sp+38Ch] [bp-84h]@10
  char v55; // [sp+3ACh] [bp-64h]@10
  char v56; // [sp+3CCh] [bp-44h]@10
  char v57; // [sp+3ECh] [bp-24h]@10

  v20 = 0.0;
  *(float *)&v24 = 0.0;
  *(float *)&v23 = 0.0;
  v21 = 0.0;
  v18 = 0.0;
  v19 = 0.0;
  v22 = 0.0;
  v16 = 0;
  v17 = 0.0;
  v15 = 0;
  if ( a1 && 9.8999998e24 != *a1 )
    *a1 = 0.0;
  if ( a3 && 9.8999998e24 != *a3 )
    *a3 = 0.0;
  if ( a2 && 9.8999998e24 != *a2 )
    *a2 = 0.0;
  sub_10008D40((int)&v26, 5.0, 2.0);
  sub_100249E0(41113, (int)&v15, 1);
  sub_100249E0(9149, (int)&v16, 1);
  sub_100249E0(42004, (int)&v27, 32);
  sub_100249E0(42006, (int)&v29, 32);
  sub_100249E0(42008, (int)&v30, 32);
  sub_100249E0(42010, (int)&v31, 32);
  sub_100249E0(42012, (int)&v32, 32);
  sub_100249E0(42014, (int)&v33, 32);
  sub_100249E0(42016, (int)&v34, 32);
  sub_100249E0(42018, (int)&v35, 32);
  sub_100249E0(42020, (int)&v36, 32);
  sub_100249E0(42022, (int)&v37, 32);
  sub_100249E0(42024, (int)&v38, 32);
  sub_100249E0(42026, (int)&v39, 32);
  sub_100249E0(42028, (int)&v40, 32);
  sub_100249E0(42030, (int)&v41, 32);
  sub_100249E0(42032, (int)&v42, 32);
  sub_100249E0(42034, (int)&v43, 32);
  sub_100249E0(42036, (int)&v44, 32);
  sub_100249E0(42038, (int)&v45, 32);
  sub_100249E0(42040, (int)&v46, 32);
  sub_100249E0(42042, (int)&v47, 32);
  sub_100249E0(42044, (int)&v48, 32);
  sub_100249E0(42046, (int)&v49, 32);
  sub_100249E0(42048, (int)&v50, 32);
  sub_100249E0(42050, (int)&v51, 32);
  sub_100249E0(42052, (int)&v52, 32);
  sub_100249E0(42054, (int)&v53, 32);
  sub_100249E0(42056, (int)&v54, 32);
  sub_100249E0(42058, (int)&v55, 32);
  sub_100249E0(42060, (int)&v56, 32);
  sub_100249E0(42062, (int)&v57, 32);
  v4 = (float *)&v28;
  v5 = 30;
  do
  {
    if ( *((_BYTE *)v4 - 28) == 1 )
    {
      if ( 9.8999998e24 != *(v4 - 1) )
        v20 = *(v4 - 1) + v20;
      if ( a4 )
      {
        if ( 9.8999998e24 != *v4 )
        {
          v22 = *v4 + v22;
          if ( 9.8999998e24 != *v4 )
          {
            if ( 9.8999998e24 != *(v4 - 3) )
              v19 = *v4 * *(v4 - 3) + v19;
            if ( 9.8999998e24 != *(v4 - 2) )
              v18 = *v4 * *(v4 - 2) + v18;
          }
        }
      }
      if ( 9.8999998e24 != *(v4 - 1) )
      {
        if ( 9.8999998e24 != *(v4 - 3) )
          v19 = *(v4 - 3) * *(v4 - 1) + v19;
        if ( 9.8999998e24 != *(v4 - 2) )
          v18 = *(v4 - 2) * *(v4 - 1) + v18;
      }
    }
    v4 += 8;
    --v5;
  }
  while ( v5 );
  if ( v16 && a4 == 2 )
  {
    v25 = sub_10008540();
    v21 = sub_1000F6B0(v25);
    v21 = sub_10024310(v21, *(float *)&v26);
    sub_100086C0(0, v25, 0, (int)&v24, (int)&v23);
    *(float *)&v24 = *(float *)&v24 * 39.37007904052734;
    *(float *)&v23 = 39.37007904052734 * *(float *)&v23;
    v6 = v21;
    v18 = v21 * *(float *)&v24 + v18;
    v19 = v21 * *(float *)&v23 + v19;
  }
  else
  {
    v6 = v21;
  }
  if ( a4 )
  {
    if ( a4 == 1 )
    {
      v7 = v22 + v20;
    }
    else
    {
      if ( a4 != 2 )
      {
        v8 = 0.0;
        goto LABEL_40;
      }
      v7 = v6 + v20 + v22;
    }
  }
  else
  {
    v7 = v20;
  }
  v17 = v7;
  v8 = 0.0;
  v9 = v17;
  if ( v17 >= 0.0 )
    goto LABEL_41;
  v17 = 0.0;
LABEL_40:
  v9 = v17;
LABEL_41:
  if ( a1 )
    *a1 = v9;
  v10 = 0.02539999969303608;
  if ( a3 )
  {
    if ( v9 > v8 )
      *a3 = v18 / v9 * 0.02539999969303608;
    v10 = 0.02539999969303608;
  }
  if ( a2 )
  {
    v11 = v10;
    v12 = v8;
    v13 = v11;
    result = v15;
    if ( v12 < v9 )
      *a2 = v13 * (v19 / v9);
  }
  else
  {
    result = v15;
  }
  return result;
}

//----- (10009310) --------------------------------------------------------
char *__cdecl sub_10009310(int a1, char *a2, int a3, char *a4, int a5)
{
  char *v5; // edi@1
  char *result; // eax@4
  char v7[4]; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v5 = a2;
  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  *(_DWORD *)(a5 + 16) = sub_10024750();
  *(_DWORD *)(a5 + 596) = sub_100247C0();
  sub_100247E0((int)v7, 1, *(_DWORD *)(a5 + 16), 40);
  *(_WORD *)(a5 + 594) = 0x7FFF;
  sub_1000D420(a5 + 585, "14.01", 8);
  *(_DWORD *)a5 = a1;
  sub_1000F730((char *)(a5 + 4));
  *(_DWORD *)(a5 + 460) = a3;
  if ( strrchr(a2, 92) )
    v5 = strrchr(a2, 92) + 1;
  strncpy((char *)(a5 + 464), v5, 0x14u);
  *(_BYTE *)(a5 + 484) = 0;
  if ( a4 )
  {
    result = strncpy((char *)(a5 + 485), a4, 0x63u);
    *(_BYTE *)(a5 + 584) = 0;
  }
  else
  {
    result = strncpy((char *)(a5 + 485), v7, 0x64u);
  }
  return result;
}

//----- (10009440) --------------------------------------------------------
char sub_10009440()
{
  char result; // al@1

  result = 0;
  byte_100C223C = 0;
  byte_100C223D = 0;
  return result;
}
// 100C223C: using guessed type char byte_100C223C;
// 100C223D: using guessed type char byte_100C223D;

//----- (10009450) --------------------------------------------------------
char __cdecl sub_10009450(char *a1, int a2, char a3, char *a4, int a5)
{
  char result; // al@7
  char v6; // [sp+Bh] [bp-2Dh]@4
  int v7; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( a3 & 3 )
    sub_10009310(-5, a1, a2, a4, a5);
  else
    sub_10009310(-44, a1, a2, a4, a5);
  v6 = a3 & 8;
  if ( a3 & 8 )
    sub_1000D510((const char *)(a5 + 485), " DBGA", 100);
  sub_100247E0((int)&v7, 0, 0, 40);
  if ( a3 & 3 )
  {
    result = a3 & 8;
    if ( v6 )
    {
      if ( byte_100C223C )
        return result;
      if ( v6 )
        goto LABEL_15;
    }
    if ( !byte_100C223D )
LABEL_15:
      result = sub_10024820(36, 1, *(_DWORD *)a5, a5);
  }
  else
  {
    result = j_HWM_pvg_log_err(a5);
  }
  return result;
}
// 100251F0: using guessed type int __cdecl j_HWM_pvg_log_err(_DWORD);
// 100C223C: using guessed type char byte_100C223C;
// 100C223D: using guessed type char byte_100C223D;

//----- (10009550) --------------------------------------------------------
char __cdecl sub_10009550(char *a1, int a2, char a3, char *a4)
{
  int v5; // [sp+8h] [bp-284h]@1

  memset(&v5, 0, 0x280u);
  return sub_10009450(a1, a2, a3, a4, (int)&v5);
}

//----- (100095C0) --------------------------------------------------------
int __cdecl sub_100095C0(int a1, _WORD *a2, int a3)
{
  int result; // eax@1
  const void *v4; // esi@2
  void *v5; // edi@2

  result = a1;
  *(_WORD *)a1 = *a2;
  *(_BYTE *)(a1 + 2) = *(_BYTE *)(a3 + 1);
  *(_BYTE *)(a1 + 3) = *(_BYTE *)a3;
  if ( *(_BYTE *)(a3 + 1) == 1 )
  {
    *(float *)(a1 + 16) = *(float *)(a3 + 4);
    *(_BYTE *)(a1 + 20) = *(_BYTE *)(a3 + 8);
  }
  else
  {
    v4 = (const void *)(a3 + 16);
    v5 = (void *)(a1 + 20);
    if ( *(_BYTE *)(a3 + 1) == 2 )
    {
      *(_BYTE *)(a1 + 16) = *(_BYTE *)(a3 + 12);
      qmemcpy(v5, v4, 0x30u);
    }
    else
    {
      *(float *)(a1 + 112) = *(float *)(a3 + 4);
      *(_BYTE *)(a1 + 116) = *(_BYTE *)(a3 + 8);
      *(_BYTE *)(a1 + 16) = *(_BYTE *)(a3 + 12);
      qmemcpy(v5, v4, 0x30u);
    }
  }
  return result;
}

//----- (10009630) --------------------------------------------------------
char __cdecl sub_10009630(int a1, int a2, int a3, unsigned __int16 a4)
{
  int v4; // edx@2
  _BYTE *v5; // eax@2
  int v6; // esi@2
  unsigned __int8 v7; // cl@6
  int v8; // ecx@8
  unsigned int v9; // edx@10
  int v10; // eax@10
  signed int v11; // edi@10
  char *v12; // ecx@11
  signed int v13; // esi@11
  int v14; // ebx@12
  unsigned __int16 v15; // ax@16
  int v16; // ebp@17
  int v17; // edi@17
  int v18; // ecx@24
  unsigned __int8 v19; // bl@24
  char *v20; // esi@24
  int v21; // eax@24
  int v23; // [sp+10h] [bp-28h]@17
  int v24; // [sp+1Ch] [bp-1Ch]@1
  int v25; // [sp+20h] [bp-18h]@1
  int v26; // [sp+24h] [bp-14h]@1
  int v27; // [sp+28h] [bp-10h]@1
  int v28; // [sp+2Ch] [bp-Ch]@1
  int v29; // [sp+30h] [bp-8h]@1

  memset(word_1016CB60, 0, 0x30u);
  memset(word_1016CB20, 0, 0x30u);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  memset((void *)(a1 + 0x2000), 0xFFu, 0x1FC4u);
  *(_WORD *)(a1 + 16324) = -1;
  if ( a4 )
  {
    v4 = a2;
    v5 = (_BYTE *)(a3 + 1);
    v6 = a4;
    do
    {
      if ( *(_BYTE *)(v4 + 6) & 1 )
      {
        if ( *(_WORD *)v4 )
        {
          if ( *(_WORD *)v4 < 0xFE3u )
          {
            v7 = *(v5 - 1);
            if ( v7 < 6u && *v5 < 4u )
            {
              v8 = *v5 + 4 * v7;
              ++word_1016CB60[v8];
            }
          }
        }
      }
      v4 += 76;
      v5 += 64;
      --v6;
    }
    while ( v6 );
  }
  v9 = 0;
  v10 = 0;
  v11 = 6;
  do
  {
    v12 = byte_10043E60;
    v13 = 4;
    do
    {
      v14 = (unsigned __int8)*v12 * (unsigned __int16)word_1016CB60[v10];
      word_1016CB20[v10] = v9;
      v9 += v14;
      ++v10;
      ++v12;
      --v13;
    }
    while ( v13 );
    --v11;
  }
  while ( v11 );
  if ( v9 > 0x2000 || v9 & 3 )
  {
    memset(word_1016CB20, 0, 0x30u);
    LOBYTE(v15) = (unsigned int)memset(word_1016CB60, 0, 0x30u);
  }
  else
  {
    LOBYTE(v15) = a4;
    if ( a4 )
    {
      v16 = a2;
      v17 = a3;
      v23 = a4;
      do
      {
        if ( *(_BYTE *)(v16 + 6) & 1 )
        {
          v15 = *(_WORD *)v16;
          if ( *(_WORD *)v16 )
          {
            if ( v15 < 0xFE3u && *(_BYTE *)v17 < 6u && *(_BYTE *)(v17 + 1) >= 1u )
            {
              LOBYTE(v15) = *(_BYTE *)(v17 + 1);
              if ( (unsigned __int8)v15 < 4u )
              {
                v18 = (unsigned __int8)v15 + 4 * *(_BYTE *)v17;
                v19 = *((_BYTE *)&v24 + v18);
                v20 = (char *)&v24 + v18;
                v21 = (unsigned __int16)word_1016CB20[v18] + v19 * (unsigned __int8)byte_10043E60[(unsigned __int8)v15];
                *(_WORD *)(a1 + 2 * *(_WORD *)v16 + 0x2000) = v21;
                LOBYTE(v15) = sub_100095C0(v21 + a1, (_WORD *)v16, v17);
                *v20 = v19 + 1;
              }
            }
          }
        }
        v17 += 64;
        v16 += 76;
        --v23;
      }
      while ( v23 );
    }
  }
  return v15;
}
// 1016CB20: using guessed type __int16 word_1016CB20[];
// 1016CB60: using guessed type __int16 word_1016CB60[];

//----- (10009840) --------------------------------------------------------
int __cdecl sub_10009840(int *a1)
{
  int result; // eax@1

  result = sub_10011650((int)(a1 + 1), 0);
  if ( result )
  {
    *a1 = sub_100247C0();
    result = sub_10011490();
  }
  return result;
}

//----- (10009870) --------------------------------------------------------
char __usercall sub_10009870@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@2
  char *v3; // eax@2
  char result; // al@2
  int v5; // eax@4
  char *v6; // eax@4

  if ( a2 == 13 )
  {
    v2 = sub_10024870(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 88));
    v3 = sub_10012710("%i %i\r\n", 13, v2);
    sub_10011CB0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"356", (int)v3);
    result = 1;
  }
  else if ( a2 == 14 )
  {
    v5 = sub_10024850(*(_DWORD *)(a1 + 4));
    v6 = sub_10012710("%i %i\r\n", 14, v5);
    sub_10011CB0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)&unk_1004D05C, (int)v6);
    result = 1;
  }
  else
  {
    sub_10009550(".\\test\\tst_tsk_common.c", 405, 1, 0);
    result = 0;
  }
  return result;
}

//----- (10009910) --------------------------------------------------------
int __cdecl sub_10009910(const char *a1)
{
  int result; // eax@1

  result = sub_1000F7B0();
  if ( a1 )
    result = sub_10011680(dword_100C2240[result] + 4, (int)a1, strlen(a1));
  return result;
}
// 100C2240: using guessed type int dword_100C2240[];

//----- (10009950) --------------------------------------------------------
char __cdecl sub_10009950(void *a1)
{
  int (**v1)(); // eax@1
  char **v2; // eax@1

  memset(a1, 0, 0xE0u);
  sub_100115D0((char *)a1 + 4);
  v1 = sub_10018030();
  sub_10011570((int)v1, 0, 0);
  dword_100C2240[sub_1000F7B0()] = (int)a1;
  v2 = sub_10017FF0((int)sub_10009910);
  return sub_100116A0(v2);
}
// 100C2240: using guessed type int dword_100C2240[];

//----- (100099A0) --------------------------------------------------------
signed int __cdecl sub_100099A0(unsigned int a1, int a2)
{
  signed int v2; // edi@1
  int v3; // eax@1
  unsigned int v4; // ebx@1
  int v5; // ebp@1
  signed int result; // eax@3
  char *v7; // eax@10
  __int16 v8; // ax@11
  char *v9; // eax@13
  char *v10; // eax@14
  char *v11; // eax@16
  int v12; // ebx@17
  char *v13; // eax@18
  char *v14; // eax@19
  char **v15; // eax@23
  char **v16; // eax@23
  char **v17; // eax@23
  char **v18; // eax@24
  char **v19; // eax@24
  char **v20; // eax@24
  int v21; // [sp-4h] [bp-30h]@9
  int v22; // [sp-4h] [bp-30h]@17
  char v23; // [sp+10h] [bp-1Ch]@6
  char v24; // [sp+14h] [bp-18h]@14

  v2 = 4;
  v3 = sub_100247C0();
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3;
  if ( a1 < 8 )
  {
LABEL_28:
    result = v2;
  }
  else
  {
    switch ( a1 )
    {
      case 0xBu:
        sub_100248F0(*(_DWORD *)(a2 + 4));
        result = 0;
        break;
      case 0xCu:
        if ( sub_100247C0() - v3 < v4 )
        {
          do
          {
            if ( *(_BYTE *)(a2 + 88) )
              sub_10024910(&v23);
          }
          while ( sub_100247C0() - v5 < v4 );
        }
        result = 0;
        break;
      case 8u:
        v21 = *(_DWORD *)(a2 + 4);
        if ( v4 < 0x40 )
        {
          v8 = sub_100247A0(v21);
          if ( v8 & 0xF32 || v8 & 0xC4 )
          {
            sub_100247E0((int)&v24, 1, *(_DWORD *)(a2 + 4), 20);
            v10 = sub_10012710("The %s task is loaded.", &v24);
            sub_10011CB0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"512", (int)v10);
            result = 0;
          }
          else
          {
            v9 = sub_10012710("Task #%d is not loaded.", *(_DWORD *)(a2 + 4));
            sub_10011CB0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"520", (int)v9);
            result = 12;
          }
        }
        else
        {
          v7 = sub_10012710("Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.", v21);
          sub_10011CB0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"489", (int)v7);
          result = 9;
        }
        break;
      case 9u:
        if ( v4 >= 0x40 )
        {
          v11 = sub_10012710(
                  "Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.",
                  *(_DWORD *)(a2 + 4));
          sub_10011CB0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"543", (int)v11);
        }
        v12 = sub_10024730(*(_DWORD *)(a2 + 4));
        v22 = *(_DWORD *)(a2 + 88);
        if ( v12 == *(_DWORD *)(a2 + 88) )
        {
          v13 = sub_10012710("The %d task's level is equal to %d.", *(_DWORD *)(a2 + 4), v22);
          sub_10011CB0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"557", (int)v13);
          v2 = 0;
        }
        else
        {
          v14 = sub_10012710("The %d task's level is equal to %d, not %d.", *(_DWORD *)(a2 + 4), v12, v22);
          sub_10011CB0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"562", (int)v14);
          v2 = 12;
        }
        if ( v12 )
          goto LABEL_28;
        sub_10011CB0(
          3,
          (int)"**MSG**",
          (int)".\\test\\tst_tsk_common.c",
          (int)"572",
          (int)"The task's criticality level is zero, make sure the task is running.");
        result = v2;
        break;
      case 0xAu:
        sub_10024820(v4, *(_DWORD *)(a2 + 88), 0, 0);
        result = 4;
        break;
      case 0x12u:
        v15 = sub_10017FF0((int)sub_10009910);
        sub_10011D80((int)v15);
        v16 = sub_100193D0((int)sub_10009910);
        sub_10011D80((int)v16);
        v17 = sub_100193D0((int)sub_10009910);
        sub_100116A0(v17);
        result = 4;
        break;
      case 0x13u:
        v18 = sub_10017FF0((int)sub_10009910);
        sub_10011D80((int)v18);
        v19 = sub_100193D0((int)sub_10009910);
        sub_10011D80((int)v19);
        v20 = sub_10017FF0((int)sub_10009910);
        sub_100116A0(v20);
        result = 4;
        break;
      default:
        if ( a1 - 13 > 4 )
        {
          v2 = 11;
          goto LABEL_28;
        }
        result = sub_10009870(a2, a1) != 0 ? 0 : 12;
        break;
    }
  }
  return result;
}

//----- (10009D40) --------------------------------------------------------
char **sub_10009D40()
{
  return off_1004D048;
}
// 1004D048: using guessed type char *off_1004D048[3];

//----- (10009D50) --------------------------------------------------------
#error "10009D55: call analysis failed (funcsize=28)"

//----- (10009D80) --------------------------------------------------------
int __cdecl sub_10009D80(void *a1, void *a2, size_t a3, int a4, int a5)
{
  int result; // eax@8

  if ( a3 > 4 || a3 == 3 || a3 - 1 > 3 || ((unsigned int)a2 | (unsigned int)a1) & (a3 - 1) )
  {
    if ( sub_10024870(a4, a5) )
    {
      result = -1;
    }
    else
    {
      memcpy(a1, a2, a3);
      sub_10024850(a4);
      result = 1;
    }
  }
  else
  {
    switch ( a3 )
    {
      case 1u:
        result = 0;
        *(_BYTE *)a1 = *(_BYTE *)a2;
        break;
      case 2u:
        *(_WORD *)a1 = *(_WORD *)a2;
        result = 0;
        break;
      case 4u:
        result = 0;
        *(_DWORD *)a1 = *(_DWORD *)a2;
        break;
      default:
        memcpy(a1, a2, a3);
        result = 0;
        break;
    }
  }
  return result;
}

//----- (10009E30) --------------------------------------------------------
void sub_10009E30()
{
  float v0; // ST00_4@1

  v0 = sub_100196B0();
  sub_10024700(v0);
}
// 100196B0: using guessed type double sub_100196B0(void);

//----- (10009E50) --------------------------------------------------------
char __thiscall sub_10009E50(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_10024BD0(6077, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10009E80) --------------------------------------------------------
char __fastcall sub_10009E80(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_10025190(42, (_BYTE *)&v2 + 2);
  if ( sub_100249E0(3162, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_10024B90(3162, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10009ED0) --------------------------------------------------------
char __cdecl sub_10009ED0(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_is_booting(a1);
  SYS_exit_krnl();
  return v1;
}
// 10025D4C: using guessed type int SYS_exit_krnl(void);
// 10025D52: using guessed type int __cdecl SYS_pvg_is_booting(_DWORD);
// 10025D58: using guessed type int SYS_enter_krnl(void);

//----- (10009EF0) --------------------------------------------------------
int __cdecl sub_10009EF0(int a1, char *a2)
{
  if ( (unsigned __int8)a1 >= 0x5Fu )
    sub_10009550("..\\lib\\adl\\sys_usr.c", 5389, 1, 0);
  if ( !a2 )
    sub_10009550("..\\lib\\adl\\sys_usr.c", 5390, 1, 0);
  SYS_enter_krnl();
  SYS_pvg_var_ctrl(a1, a2);
  return SYS_exit_krnl();
}
// 10025D4C: using guessed type int SYS_exit_krnl(void);
// 10025D58: using guessed type int SYS_enter_krnl(void);
// 10025D5E: using guessed type int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD);

//----- (10009F50) --------------------------------------------------------
char __thiscall sub_10009F50(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10009EF0(18, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10009F70) --------------------------------------------------------
char __thiscall sub_10009F70(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10009EF0(17, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10009F90) --------------------------------------------------------
char __thiscall sub_10009F90(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10009EF0(34, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10009FB0) --------------------------------------------------------
char __thiscall sub_10009FB0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10009EF0(44, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10009FD0) --------------------------------------------------------
double __cdecl sub_10009FD0(float a1, float a2, int a3, float a4)
{
  double v4; // st7@2
  double v5; // st7@4
  bool v6; // c0@5
  double v7; // st7@5
  double v9; // st5@7
  bool v10; // c0@7
  bool v11; // c3@7
  float v12; // [sp+8h] [bp-8h]@4
  float v13; // [sp+Ch] [bp-4h]@4
  int v14; // [sp+1Ch] [bp+Ch]@4
  int v15; // [sp+1Ch] [bp+Ch]@4
  int v16; // [sp+1Ch] [bp+Ch]@4
  int v17; // [sp+1Ch] [bp+Ch]@9

  if ( (unsigned __int8)a3 <= 0x64u )
    v4 = (double)(unsigned __int8)a3;
  else
    v4 = 100.0;
  *(float *)&v14 = v4;
  *(float *)&v15 = *(float *)&v14 / 100.0 * a4;
  v12 = (*(float *)&v15 + a4) * 0.5;
  v13 = sub_10024270(a1, a4);
  *(float *)&v16 = sub_10024190(a1, a4);
  v5 = a1;
  if ( a1 < (double)a2 )
  {
    v9 = *(float *)&v16 - v12;
    v10 = v9 < v5;
    v11 = v9 == v5;
    v7 = *(float *)&v16;
    if ( !v10 && !v11 )
      v7 = v13;
  }
  else
  {
    v6 = v13 + v12 < v5;
    v7 = v13;
    if ( v6 )
      return *(float *)&v16;
  }
  *(float *)&v17 = v7;
  return *(float *)&v17;
}

//----- (1000A0B0) --------------------------------------------------------
char __cdecl sub_1000A0B0(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@11
  int v4; // eax@16
  int v6; // [sp+8h] [bp-54h]@1
  int v7; // [sp+Ch] [bp-50h]@1
  int v8; // [sp+10h] [bp-4Ch]@1
  int v9; // [sp+14h] [bp-48h]@1
  int v10; // [sp+18h] [bp-44h]@1
  char v11; // [sp+1Ch] [bp-40h]@16

  LOBYTE(v2) = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( a1 == 28 || a1 == 29 || a1 == 30 || a1 == 31 || a1 == 32 || a1 == 48 || a1 == 33 || a1 == 34 )
  {
    v2 = sub_1000D290((_DWORD *)a2, 2u, (int)&unk_1004DEB8, 8, 77, 77);
    if ( v2 != 77 )
    {
      if ( *(_WORD *)a2 == -32768 )
      {
        v3 = *(_WORD *)(a2 + 10) + 16;
      }
      else if ( *(_WORD *)a2 == -32767 )
      {
        v3 = *(_DWORD *)(a2 + 4) + 8;
      }
      else
      {
        v3 = dword_1004DEBC[2 * v2] + 4;
      }
      v7 = v3;
      v10 = 65;
      v6 = a2;
      v9 = 10;
      v2 = sub_100248A0(a1, (int)&v6);
      if ( v2 == 16 )
      {
        v4 = sub_10024750();
        sub_1000D4E0(&v11, 0x3Cu, "message queue timed out sending from: %d to %d", v4, a1);
        LOBYTE(v2) = sub_10009550("..\\lib\\adl\\iop_msg_intf.c", 433, 0, &v11);
      }
    }
  }
  return v2;
}
// 1004DEBC: using guessed type int dword_1004DEBC[];

//----- (1000A1D0) --------------------------------------------------------
int __cdecl sub_1000A1D0(char a1)
{
  return sub_1000D290(&a1, 1u, (int)"7", 8, 2, 2);
}

//----- (1000A1F0) --------------------------------------------------------
BOOL __cdecl sub_1000A1F0(int a1, void *a2)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-18h]@2
  int v5; // [sp+18h] [bp-4h]@3

  v2 = sub_10005960(a1);
  return sub_10005900(0, 604, a2) && sub_100052D0(0, 0x25Cu, (int)&v4) && (v2 & v5) == v2;
}

//----- (1000A250) --------------------------------------------------------
int __usercall sub_1000A250@<eax>(char a1@<al>)
{
  unsigned __int8 v1; // al@1
  int result; // eax@2

  v1 = sub_1000A1D0(a1);
  if ( v1 >= 2u )
    result = 42066;
  else
    result = dword_1004E170[2 * v1];
  return result;
}
// 1004E170: using guessed type int dword_1004E170[];

//----- (1000A280) --------------------------------------------------------
BOOL __cdecl sub_1000A280(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1000A250(a1);
  return sub_100249E0(v2, a2, 16) == 0;
}

//----- (1000A2B0) --------------------------------------------------------
int __cdecl sub_1000A2B0(int a1, char a2, int a3, int a4, void *a5)
{
  int result; // eax@2

  if ( a2 )
    result = sub_1000A280(a1, (int)a5);
  else
    result = sub_1000A1F0(a1, a5);
  return result;
}

//----- (1000A2E0) --------------------------------------------------------
char __cdecl sub_1000A2E0(void *a1)
{
  int v1; // ecx@0
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  return sub_10005930(1, 1947, a1, (int)&v3);
}

//----- (1000A300) --------------------------------------------------------
BOOL __cdecl sub_1000A300(int a1)
{
  return sub_100249E0(6792, a1, 284) == 0;
}

//----- (1000A320) --------------------------------------------------------
char __cdecl sub_1000A320(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2

  if ( a2 )
    result = sub_1000A300((int)a5);
  else
    result = sub_1000A2E0(a5);
  return result;
}

//----- (1000A350) --------------------------------------------------------
bool __cdecl sub_1000A350(unsigned __int8 a1, char a2, unsigned int a3)
{
  int v3; // eax@1
  bool result; // al@5

  v3 = sub_1000D290(&a2, 4u, (int)&dword_1004EFE8, 12, 3, 3);
  if ( a3 < 0xFFFFFFC2 && a3 && v3 < 3 && a1 < 2u )
  {
    result = sub_100249E0((unsigned __int16)word_1004EFEC[a1 + 6 * v3], a3, (unsigned __int16)word_1004EFF0[6 * v3]) == 0;
  }
  else
  {
    sub_10009550("..\\lib\\acl\\iop\\gtx\\iop_gtx_intf.c", 254, 0, 0);
    result = 0;
  }
  return result;
}
// 1004EFE8: using guessed type int dword_1004EFE8;
// 1004EFEC: using guessed type __int16 word_1004EFEC[];
// 1004EFF0: using guessed type __int16 word_1004EFF0[];

//----- (1000A3E0) --------------------------------------------------------
bool __cdecl sub_1000A3E0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6)
{
  int v6; // eax@1
  int v7; // eax@7
  unsigned int v8; // edx@7
  int v9; // eax@7
  bool result; // al@9
  unsigned __int8 v11; // [sp+4h] [bp-4h]@1

  v11 = sub_10019A40(a1);
  v6 = sub_1000D290(&a3, 1u, (int)&unk_1004F00C, 8, 3, 3);
  if ( v6 < 3 )
    v6 = sub_1000D290(&dword_1004F010[2 * v6], 4u, (int)&dword_1004EFE8, 12, 3, 3);
  if ( a5 < 0xFFFFFFC2
    && a5
    && v6 < 3
    && v11 < 2u
    && (v7 = 6 * v6, v8 = (unsigned __int16)word_1004EFF0[v7], v9 = 2 * v7, a6 >= v8)
    && a2 == 1 )
  {
    result = sub_1000A350(v11, *(int *)((char *)&dword_1004EFE8 + v9), a5);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1004EFE8: using guessed type int dword_1004EFE8;
// 1004EFF0: using guessed type __int16 word_1004EFF0[];

//----- (1000A480) --------------------------------------------------------
bool __cdecl sub_1000A480(char a1, void *a2)
{
  memset(a2, 0, 0x2890u);
  return sub_100249E0((a1 != 36) + 6534, (int)a2, 10384) == 0;
}

//----- (1000A4C0) --------------------------------------------------------
signed int __usercall sub_1000A4C0@<eax>(char a1@<al>)
{
  return a1 != 36 ? 0x20000 : 0x10000;
}

//----- (1000A4E0) --------------------------------------------------------
bool __cdecl sub_1000A4E0(char a1, void *a2)
{
  int v2; // esi@1
  bool result; // al@5
  void *v4; // ecx@6
  int v5; // [sp+Ch] [bp-28h]@4
  char v6; // [sp+10h] [bp-24h]@2
  int v7; // [sp+24h] [bp-10h]@3
  __int16 v8; // [sp+28h] [bp-Ch]@8
  int v9; // [sp+2Ch] [bp-8h]@8

  v2 = sub_1000A4C0(a1);
  if ( (v2 & j_HWM_pvg_hsdb_get_lrus_online()) == v2
    && sub_100052D0(1, 0x6ACu, (int)&v6)
    && v7 == v2
    && sub_10005930(1, 1708, a2, (int)&v5) )
  {
    result = 1;
  }
  else if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    result = sub_1000A480(a1, a2);
  }
  else
  {
    v9 = sub_10019A20(v4);
    v8 = 1708;
    sub_10005430(1, 0, &v8, 0, 8, 1);
    sub_10005570(1, 0, v2);
    result = 0;
  }
  return result;
}
// 100251E0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 10025200: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1000A5D0) --------------------------------------------------------
bool __cdecl sub_1000A5D0(char a1, char a2, int a3, int a4, void *a5)
{
  bool result; // al@2

  if ( a2 )
    result = sub_1000A480(a1, a5);
  else
    result = sub_1000A4E0(a1, a5);
  return result;
}

//----- (1000A600) --------------------------------------------------------
BOOL __cdecl sub_1000A600(unsigned __int8 a1)
{
  return a1 <= 1u;
}

//----- (1000A610) --------------------------------------------------------
BOOL __usercall sub_1000A610@<eax>(unsigned __int8 a1@<al>, char a2)
{
  _BYTE *v2; // ecx@1

  return (unsigned __int8)sub_1000A600(a1) && *v2 < 3u && a2 == 24;
}

//----- (1000A640) --------------------------------------------------------
bool __cdecl sub_1000A640(char a1, char a2, unsigned __int8 a3, int a4)
{
  bool v4; // bl@1
  unsigned __int8 v5; // cl@2
  int v6; // esi@3
  char v8; // al@16
  char v9; // cl@16
  char v10; // dl@16
  int v11; // ecx@18
  int v12; // edx@18
  int v13; // eax@18
  char v14; // [sp+Bh] [bp-29h]@3
  int v15; // [sp+Ch] [bp-28h]@9
  struct tm Tm; // [sp+10h] [bp-24h]@5

  v4 = 0;
  if ( a3 < 3u )
  {
    if ( (unsigned __int8)sub_1000A600(a1) )
    {
      v6 = 10 * v5;
      if ( sub_10019D20((unsigned __int8)byte_10050428[20 * v5], (bool *)&v14) )
      {
        if ( v14 )
        {
          if ( !sub_10005900(1, (unsigned __int16)word_10050420[v6], &Tm.tm_mon) || sub_1000EE10((int)&Tm.tm_mon) )
            return 0;
          v4 = 1;
        }
        else
        {
          if ( !(unsigned __int8)sub_10019BA0(a1, &v15) || v15 != dword_10050440[2 * a3] || a2 == 11 )
            return v4;
          Tm.tm_sec = 0;
          Tm.tm_min = 0;
          Tm.tm_hour = 0;
          LOBYTE(Tm.tm_mday) = 0;
          v4 = sub_10005900(1, (unsigned __int16)word_10050424[v6], &Tm) && !_mkgmtime(&Tm);
          v8 = BYTE1(Tm.tm_hour);
          v9 = BYTE2(Tm.tm_min);
          *((_BYTE *)&Tm.tm_mon + 4 * a3) = Tm.tm_min;
          v10 = BYTE2(Tm.tm_hour);
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 2) = v8;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 1) = v9;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 3) = v10;
          if ( !v4 )
            return v4;
        }
        if ( a2 == 11 )
        {
          v11 = Tm.tm_year;
          v12 = Tm.tm_wday;
          *(_DWORD *)a4 = Tm.tm_mon;
          v13 = Tm.tm_yday;
          *(_DWORD *)(a4 + 4) = v11;
          *(_DWORD *)(a4 + 8) = v12;
          *(_DWORD *)(a4 + 12) = v13;
          return v4;
        }
        *(_DWORD *)a4 = *(&Tm.tm_mon + a3);
      }
    }
  }
  return v4;
}
// 10050420: using guessed type __int16 word_10050420[];
// 10050424: using guessed type __int16 word_10050424[];
// 10050440: using guessed type int dword_10050440[];

//----- (1000A7F0) --------------------------------------------------------
bool __cdecl sub_1000A7F0(unsigned __int8 a1, int a2)
{
  bool v2; // dl@1
  unsigned __int8 v3; // cl@1
  bool result; // al@2

  if ( (unsigned __int8)sub_1000A600(a1) )
    result = sub_100249E0((unsigned __int16)word_1005042A[10 * v3], a2, 32) == 0;
  else
    result = v2;
  return result;
}
// 1005042A: using guessed type __int16 word_1005042A[];

//----- (1000A830) --------------------------------------------------------
bool __cdecl sub_1000A830(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6)
{
  unsigned __int8 v6; // dl@1
  bool result; // al@4
  char v8; // [sp+13h] [bp-29h]@5
  unsigned int v9; // [sp+14h] [bp-28h]@1
  char v10; // [sp+18h] [bp-24h]@7
  int v11[7]; // [sp+1Ch] [bp-20h]@8

  LOBYTE(v9) = sub_10019AF0(a1);
  if ( !(unsigned __int8)sub_1000A610(v9, a3) || a6 != 4 )
    goto LABEL_12;
  if ( !a2 )
    return sub_1000A640(v9, a3, *a4, (int)a5);
  if ( sub_10019D20((unsigned __int8)byte_10050428[20 * v6], (bool *)&v8) && v8 && sub_1000A7F0(v9, (int)&v10) )
  {
    *a5 = v11[*a4];
    result = 1;
  }
  else
  {
LABEL_12:
    result = 0;
  }
  return result;
}
// 1000A830: using guessed type int var_20[7];

//----- (1000A920) --------------------------------------------------------
char sub_1000A920()
{
  char v1; // [sp+4h] [bp-100h]@1

  memset(&v1, 0, 0xFCu);
  if ( sub_10005900(1, 1309, &v1) )
    sub_1000EF50((int)&v1);
  return 0;
}

//----- (1000A9C0) --------------------------------------------------------
BOOL __cdecl sub_1000A9C0(int a1, int a2)
{
  return sub_100249E0(6455, a2, 252) == 0;
}

//----- (1000A9E0) --------------------------------------------------------
char __cdecl sub_1000A9E0(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1000A9C0(a1, a5);
  }
  else
  {
    result = sub_1000A920();
  }
  return result;
}

//----- (1000AA20) --------------------------------------------------------
char __cdecl sub_1000AA20(char a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@3
  char v4; // dl@3

  memset(byte_100C4AE8, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10009550("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 215, 0, 0);
  }
  else
  {
    sub_1001A010(a1, (int)byte_100C4AE8);
    v3 = 4 * a2 - 64;
    v4 = byte_100C4AE9[v3];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_100C4AE8[v3];
    if ( (unsigned __int8)v4 < 0x23u
      || (unsigned __int8)v4 >= 0x64u && (unsigned __int8)v4 <= 0x81u
      || (unsigned __int8)v4 >= 0x96u && (unsigned __int8)v4 <= 0x9Bu )
    {
      return 1;
    }
  }
  return 0;
}

//----- (1000AAC0) --------------------------------------------------------
bool __cdecl sub_1000AAC0(char a1, unsigned __int8 a2, int a3)
{
  char *v3; // eax@3
  bool result; // al@3

  memset(byte_100C4AE8, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10009550("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 340, 0, 0);
    result = 0;
  }
  else
  {
    sub_1001A010(a1, (int)byte_100C4AE8);
    v3 = (char *)&unk_100C4B88 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v3;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v3 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v3 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v3 + 3);
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  return result;
}

//----- (1000AB40) --------------------------------------------------------
char __cdecl sub_1000AB40(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_100C4AE8, 0, 0x890u);
  sub_1001A010(a1, (int)byte_100C4AE8);
  if ( a2 > 0x10u )
  {
    sub_10009550("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 512, 0, 0);
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = dword_100C4E58[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_100C4E5C[2 * a2];
    result = 1;
  }
  return result;
}
// 100C4E58: using guessed type int dword_100C4E58[];
// 100C4E5C: using guessed type int dword_100C4E5C[];

//----- (1000ABB0) --------------------------------------------------------
char __cdecl sub_1000ABB0(char a1, void *a2)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = sub_10005900(0, 227, a2);
    }
    else if ( a1 == 2 )
    {
      result = sub_10005900(0, 572, a2);
    }
    else
    {
      sub_10009550("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 991, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_10005900(0, 226, a2);
  }
  return result;
}

//----- (1000AC30) --------------------------------------------------------
char __cdecl sub_1000AC30(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  int v4; // ecx@3

  memset(byte_100C4AE8, 0, 0x890u);
  if ( a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10009550("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 153, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_1000ABB0(a1, byte_100C4AE8);
    v4 = 4 * a2 - 64;
    *(_BYTE *)(a3 + 1) = byte_100C4AE9[v4];
    *(_BYTE *)a3 = byte_100C4AE8[v4];
  }
  return result;
}

//----- (1000ACB0) --------------------------------------------------------
char __cdecl sub_1000ACB0(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  char *v4; // ecx@3

  memset(byte_100C4AE8, 0, 0x890u);
  if ( a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10009550("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 280, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_1000ABB0(a1, byte_100C4AE8);
    v4 = (char *)&unk_100C4B88 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v4;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v4 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v4 + 3);
  }
  return result;
}

//----- (1000AD30) --------------------------------------------------------
char __cdecl sub_1000AD30(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_100C4AE8, 0, 0x890u);
  if ( a2 <= 0x10u )
  {
    result = sub_1000ABB0(a1, byte_100C4AE8);
    *(_DWORD *)a3 = dword_100C4E58[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_100C4E5C[2 * a2];
  }
  else
  {
    sub_10009550("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 445, 0, 0);
    result = 0;
  }
  return result;
}
// 100C4E58: using guessed type int dword_100C4E58[];
// 100C4E5C: using guessed type int dword_100C4E5C[];

//----- (1000ADA0) --------------------------------------------------------
char __cdecl sub_1000ADA0(char a1, char a2, char a3, unsigned __int8 *a4, int a5)
{
  char result; // al@6
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1001A080(a1);
  if ( v6 == 3 )
    return 0;
  if ( a3 == 1 )
  {
    if ( a2 )
      result = sub_1000AB40(v6, *a4, a5);
    else
      result = sub_1000AD30(v6, *a4, a5);
  }
  else if ( a3 == 2 )
  {
    if ( a2 )
      result = sub_1000AA20(v6, *a4, a5);
    else
      result = sub_1000AC30(v6, *a4, a5);
  }
  else
  {
    if ( a3 != 3 )
    {
      sub_10009550("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 915, 0, 0);
      return 0;
    }
    if ( a2 )
      result = sub_1000AAC0(v6, *a4, a5);
    else
      result = sub_1000ACB0(v6, *a4, a5);
  }
  return result;
}

//----- (1000AEB0) --------------------------------------------------------
char __cdecl sub_1000AEB0(char a1, void *a2)
{
  return sub_10005900(6, (unsigned __int16)word_10051DD2[8 * (unsigned __int8)a1], a2);
}
// 10051DD2: using guessed type __int16 word_10051DD2[];

//----- (1000AED0) --------------------------------------------------------
bool __cdecl sub_1000AED0(unsigned __int8 a1, char *a2)
{
  int v2; // eax@1
  char v4; // [sp+8h] [bp-30h]@1

  v2 = sub_100249E0(dword_10051DD8[4 * a1], (int)&v4, 48);
  qmemcpy(a2, &v4, 0x2Cu);
  return v2 == 0;
}
// 10051DD8: using guessed type int dword_10051DD8[];

//----- (1000AF10) --------------------------------------------------------
char __cdecl sub_1000AF10(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1001A0C0(a1);
  if ( a2 )
    result = sub_1000AED0(v6, (char *)a5);
  else
    result = sub_1000AEB0(v6, a5);
  return result;
}

//----- (1000AF50) --------------------------------------------------------
BOOL sub_1000AF50()
{
  char v1; // [sp+0h] [bp-78h]@1

  return sub_10019C60(69, &v1) && !strncmp(&v1, "006-B0756-", 0xAu);
}

//----- (1000AFB0) --------------------------------------------------------
char __cdecl sub_1000AFB0(int a1, char *a2)
{
  char result; // al@5
  char v3; // [sp+13h] [bp-7Dh]@1
  char v4; // [sp+14h] [bp-7Ch]@1
  char v5; // [sp+15h] [bp-7Bh]@2
  int v6; // [sp+30h] [bp-60h]@2
  int v7; // [sp+34h] [bp-5Ch]@2
  int v8; // [sp+38h] [bp-58h]@2
  int v9; // [sp+3Ch] [bp-54h]@2
  int v10; // [sp+40h] [bp-50h]@2
  __int16 v11; // [sp+44h] [bp-4Ch]@2
  char v12; // [sp+46h] [bp-4Ah]@2
  char v13; // [sp+47h] [bp-49h]@2
  float v14; // [sp+48h] [bp-48h]@2
  char v15; // [sp+4Ch] [bp-44h]@2
  char v16; // [sp+4Dh] [bp-43h]@2
  char v17; // [sp+4Eh] [bp-42h]@2
  char v18; // [sp+50h] [bp-40h]@1

  memset(&v18, 0, 0x3Cu);
  v3 = sub_10005900(1, 292, &v18);
  qmemcpy(&v4, &v18, 0x3Cu);
  if ( !(unsigned __int8)sub_1000AF50() )
  {
    v6 = -1;
    v14 = 77.166664;
    v7 = -1;
    v8 = -1;
    v9 = -1;
    v5 = 1;
    v12 = 0;
    v13 = 1;
    v4 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v10 = 0;
    v11 = 0;
  }
  if ( !v3 || sub_1000EB40((int)&v4) )
  {
    result = 0;
  }
  else
  {
    result = 1;
    qmemcpy(a2, &v18, 0x3Cu);
  }
  return result;
}

//----- (1000B0A0) --------------------------------------------------------
BOOL __cdecl sub_1000B0A0(int a1, int a2)
{
  return sub_100249E0(6200, a2, 60) == 0;
}

//----- (1000B0C0) --------------------------------------------------------
char __cdecl sub_1000B0C0(int a1, char a2, int a3, int a4, char *a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1000B0A0(a1, (int)a5);
  }
  else
  {
    result = sub_1000AFB0(a1, a5);
  }
  return result;
}

//----- (1000B100) --------------------------------------------------------
char __cdecl sub_1000B100(int a1, int a2)
{
  int v2; // ecx@3
  int v3; // edx@3
  int v4; // ecx@3
  char result; // al@3
  int v6; // [sp+4h] [bp-1Ch]@1
  int v7; // [sp+8h] [bp-18h]@1
  int v8; // [sp+Ch] [bp-14h]@1
  int v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+14h] [bp-Ch]@1
  __int16 v11; // [sp+18h] [bp-8h]@1
  char v12; // [sp+1Ah] [bp-6h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if ( !sub_10005900(2, 284, &v6) || sub_1000ED10((int)&v6) )
  {
    result = 0;
  }
  else
  {
    v2 = v8;
    *(_DWORD *)a2 = v7;
    v3 = v9;
    *(_DWORD *)(a2 + 4) = v2;
    v4 = v10;
    *(_DWORD *)(a2 + 8) = v3;
    LOWORD(v3) = v11;
    *(_DWORD *)(a2 + 12) = v4;
    LOBYTE(v4) = v12;
    *(_WORD *)(a2 + 16) = v3;
    *(_BYTE *)(a2 + 18) = v4;
    result = 1;
  }
  return result;
}

//----- (1000B1B0) --------------------------------------------------------
BOOL __cdecl sub_1000B1B0(int a1, int a2)
{
  return sub_100249E0(6169, a2, 40) == 0;
}

//----- (1000B1D0) --------------------------------------------------------
char __cdecl sub_1000B1D0(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1000B1B0(a1, a5);
  }
  else
  {
    result = sub_1000B100(a1, a5);
  }
  return result;
}

//----- (1000B210) --------------------------------------------------------
char __cdecl sub_1000B210(void *a1)
{
  *(_DWORD *)a1 = 0;
  return sub_10005900(2, 363, a1);
}

//----- (1000B230) --------------------------------------------------------
char __cdecl sub_1000B230(void *a1)
{
  int v1; // edx@2
  int v2; // eax@2
  int v3; // ecx@2
  int v4; // eax@2
  int v5; // ecx@2
  void *v6; // esi@2
  signed int v7; // edi@2
  char *v8; // eax@4
  signed int v9; // edx@4
  char result; // al@6
  char v11; // [sp+8h] [bp-208h]@1
  int v12; // [sp+47h] [bp-1C9h]@2
  int v13; // [sp+4Bh] [bp-1C5h]@2
  int v14; // [sp+4Fh] [bp-1C1h]@2
  int v15; // [sp+53h] [bp-1BDh]@2
  int v16; // [sp+58h] [bp-1B8h]@2
  int v17; // [sp+5Ch] [bp-1B4h]@2
  __int16 v18; // [sp+60h] [bp-1B0h]@2
  char v19; // [sp+62h] [bp-1AEh]@2
  char v20; // [sp+B6h] [bp-15Ah]@2
  char v21; // [sp+F6h] [bp-11Ah]@2

  *(_DWORD *)a1 = 0;
  if ( sub_100249E0(6444, (int)&v11, 514) )
  {
    result = 0;
  }
  else
  {
    v1 = v13;
    v2 = v14;
    *((_DWORD *)a1 + 3330) = v12;
    v3 = v15;
    *((_DWORD *)a1 + 3331) = v1;
    LOWORD(v1) = v18;
    *((_DWORD *)a1 + 3332) = v2;
    v4 = v16;
    *((_DWORD *)a1 + 3333) = v3;
    qmemcpy((char *)a1 + 13340, &v19, 0x54u);
    v5 = v17;
    *((_WORD *)a1 + 6668) = v1;
    LOBYTE(v1) = v21;
    *((_DWORD *)a1 + 3009) = v5;
    qmemcpy((char *)a1 + 13424, &v20, 0x40u);
    *((_DWORD *)a1 + 3008) = v4;
    *((_BYTE *)a1 + 13488) = v1 & 2;
    v6 = a1;
    v7 = 32;
    do
    {
      memset(v6, 0, 0x38u);
      *((_DWORD *)v6 + 9) = 2048;
      v6 = (char *)v6 + 56;
      --v7;
    }
    while ( v7 );
    v8 = (char *)a1 + 1799;
    v9 = 512;
    do
    {
      *(_DWORD *)(v8 - 7) = 0;
      *(_DWORD *)(v8 - 3) = 0;
      *(_DWORD *)(v8 + 1) = 0;
      *(_DWORD *)(v8 + 5) = 0;
      *(_DWORD *)(v8 + 9) = 0;
      *v8 = -1;
      v8 += 20;
      --v9;
    }
    while ( v9 );
    result = 1;
  }
  return result;
}

//----- (1000B380) --------------------------------------------------------
char __cdecl sub_1000B380(int a1, char a2, char a3, int a4, void *a5, size_t a6)
{
  char result; // al@3
  char v7; // al@6
  char v8; // bl@8
  char v9; // al@10
  char v10; // bl@12
  char v11; // al@14
  char v12; // bl@16
  char v13; // al@18
  char v14; // bl@20

  switch ( a3 )
  {
    case 0x18:
      if ( a2 )
        result = sub_1000B230(a5);
      else
        result = sub_1000B210(a5);
      break;
    case 0x19:
      if ( a2 )
        v7 = sub_1000B230(&unk_100C5378);
      else
        v7 = sub_1000B210(&unk_100C5378);
      v8 = v7;
      memcpy(a5, (char *)&unk_100C5378 + 56 * *(_BYTE *)a4, a6);
      result = v8;
      break;
    case 0x1A:
      if ( a2 )
        v9 = sub_1000B230(&unk_100C5378);
      else
        v9 = sub_1000B210(&unk_100C5378);
      v10 = v9;
      memcpy(a5, (char *)&unk_100C8280 + 40 * *(_BYTE *)a4, a6);
      result = v10;
      break;
    case 0x1B:
      if ( a2 )
        v11 = sub_1000B230(&unk_100C5378);
      else
        v11 = sub_1000B210(&unk_100C5378);
      v12 = v11;
      memcpy(a5, (char *)&unk_100C8780 + *(_BYTE *)a4, a6);
      result = v12;
      break;
    case 0x2B:
      if ( a2 )
        v13 = sub_1000B230(&unk_100C5378);
      else
        v13 = sub_1000B210(&unk_100C5378);
      v14 = v13;
      memcpy(a5, &unk_100C8828, a6);
      result = v14;
      break;
    default:
      sub_10009550("..\\lib\\acl\\iop\\gdl59\\iop_gdl59_cnfg_intf.c", 709, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1000B520) --------------------------------------------------------
char __cdecl sub_1000B520(char a1)
{
  char result; // al@3

  if ( a1 == 15 )
  {
    result = 0;
  }
  else if ( a1 == 16 )
  {
    result = 1;
  }
  else
  {
    sub_10009550("..\\lib\\acl\\iop\\iop_adc_intf.c", 178, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1000B560) --------------------------------------------------------
__int16 __usercall sub_1000B560@<ax>(unsigned __int8 a1@<al>)
{
  return word_10054988[a1];
}
// 10054988: using guessed type __int16 word_10054988[];

//----- (1000B570) --------------------------------------------------------
char __cdecl sub_1000B570(unsigned __int8 a1, char *a2)
{
  int v2; // eax@2
  char result; // al@5
  int v4; // [sp+4h] [bp-150h]@2
  char v5; // [sp+8h] [bp-14Ch]@1
  char v6; // [sp+9h] [bp-14Bh]@3
  char v7; // [sp+Ch] [bp-148h]@5

  memset(&v5, 0, 0x148u);
  if ( a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    LOWORD(v2) = sub_1000B560(a1);
    if ( sub_10005930(0, v2, &v5, (int)&v4) && v6 == 3 && (unsigned int)(unsigned __int16)v4 - 4 >= 0xA0 )
    {
      qmemcpy(a2, &v7, 0xA0u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (1000B640) --------------------------------------------------------
char __cdecl sub_1000B640(char a1, char a2, char a3, int a4, char *a5, unsigned int a6)
{
  char result; // al@3
  unsigned __int8 v7; // [sp+4h] [bp-4h]@1

  v7 = sub_1000B520(a1);
  if ( a3 != 11 )
  {
    sub_10009550("..\\lib\\acl\\iop\\iop_adc_intf.c", 564, 0, 0);
    return 0;
  }
  if ( a6 >= 0xA0 )
  {
    if ( a2 )
      return 0;
    result = sub_1000B570(v7, a5);
  }
  else
  {
    sub_10009550("..\\lib\\acl\\iop\\iop_adc_intf.c", 551, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1000B6C0) --------------------------------------------------------
char __cdecl sub_1000B6C0(unsigned __int16 a1)
{
  char v1; // bl@1
  char result; // al@5
  char v3; // [sp+Bh] [bp-411h]@2
  int v4; // [sp+Ch] [bp-410h]@1
  int v5; // [sp+10h] [bp-40Ch]@1
  char v6[1028]; // [sp+14h] [bp-408h]@5

  v1 = 0;
  if ( sub_1000F650(a1, &v5, &v4) && sub_10004FF0(v5, v4, &v3) && (v1 = v3) != 0
    || a1 >= 0x1D8u
    || (sub_10024A80(6943, (int)v6, 1028), result = 1, !v6[a1]) )
  {
    result = v1;
  }
  return result;
}
// 1000B6C0: using guessed type char var_408[1028];

//----- (1000B760) --------------------------------------------------------
char __cdecl sub_1000B760(char a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@3
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1001A460(a1);
  switch ( a3 )
  {
    case 5:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1001A260(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 4:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1001A2E0(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 0xA:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1001A360(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 3:
      if ( a2 != 1 )
        goto LABEL_10;
      result = sub_1001A3E0(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      break;
    default:
LABEL_10:
      result = 0;
      break;
  }
  return result;
}

//----- (1000B870) --------------------------------------------------------
int __cdecl sub_1000B870(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1000D290(&a1, 1u, (int)&unk_100551C0, 8, 4, 4);
  if ( v1 == 4 )
  {
    sub_10009550("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_intf.c", 437, 0, 0);
    result = 42066;
  }
  else
  {
    result = dword_100551C4[2 * v1];
  }
  return result;
}
// 100551C4: using guessed type int dword_100551C4[];

//----- (1000B8C0) --------------------------------------------------------
char __cdecl sub_1000B8C0(char a1, int a2)
{
  char v2; // cl@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // eax@1
  int v10; // ecx@1
  bool v11; // zf@1
  int v12; // eax@3
  int v13; // ecx@3
  char v14; // dl@3
  __int16 v15; // ax@5
  char v16; // dl@5
  int v18; // [sp+4h] [bp-58h]@1
  char v19; // [sp+8h] [bp-54h]@1
  __int64 v20; // [sp+Ch] [bp-50h]@1
  int v21; // [sp+14h] [bp-48h]@1
  int v22; // [sp+18h] [bp-44h]@1
  char v23; // [sp+1Ch] [bp-40h]@1
  __int16 v24; // [sp+1Eh] [bp-3Eh]@1
  int v25; // [sp+20h] [bp-3Ch]@4
  int v26; // [sp+24h] [bp-38h]@4
  char v27; // [sp+28h] [bp-34h]@4
  char v28; // [sp+2Ah] [bp-32h]@1
  char v29; // [sp+2Bh] [bp-31h]@1
  int v30; // [sp+2Ch] [bp-30h]@1
  int v31; // [sp+30h] [bp-2Ch]@1
  int v32; // [sp+34h] [bp-28h]@1
  int v33; // [sp+38h] [bp-24h]@1
  int v34; // [sp+3Ch] [bp-20h]@1
  int v35; // [sp+40h] [bp-1Ch]@1
  int v36; // [sp+44h] [bp-18h]@1
  int v37; // [sp+48h] [bp-14h]@1
  int v38; // [sp+4Ch] [bp-10h]@1
  int v39; // [sp+50h] [bp-Ch]@1
  int v40; // [sp+54h] [bp-8h]@1

  memset(&v23, 0, 0x3Cu);
  v20 = 0i64;
  v21 = 0;
  v22 = 0;
  v18 = 0;
  v19 = 0;
  sub_1001A040(a1, (int)&v23);
  v2 = v28;
  v3 = v29;
  *(_WORD *)a2 = v24;
  *(_DWORD *)(a2 + 28) = v33;
  v4 = v36;
  *(_BYTE *)(a2 + 12) = v2;
  *(_DWORD *)(a2 + 32) = v34;
  v5 = v37;
  *(_BYTE *)(a2 + 13) = v3;
  *(_DWORD *)(a2 + 36) = v35;
  v6 = v38;
  *(_DWORD *)(a2 + 40) = v4;
  v7 = v30;
  *(_DWORD *)(a2 + 44) = v5;
  v8 = v31;
  *(_DWORD *)(a2 + 16) = v7;
  v9 = v39;
  *(_DWORD *)(a2 + 20) = v8;
  v10 = v40;
  *(_DWORD *)(a2 + 48) = v6;
  v11 = BYTE3(v30) == 1;
  *(_DWORD *)(a2 + 24) = v32;
  *(_DWORD *)(a2 + 52) = v9;
  *(_DWORD *)(a2 + 56) = v10;
  if ( !v11 || sub_100249E0(2105, (int)&v20, 16) )
  {
    v12 = v25;
    v13 = v26;
    v14 = v27;
  }
  else
  {
    v13 = *(_DWORD *)((char *)&v20 + 6);
    v12 = *(_DWORD *)((char *)&v20 + 2);
    v14 = BYTE2(v21);
  }
  *(_DWORD *)(a2 + 2) = v12;
  *(_DWORD *)(a2 + 6) = v13;
  *(_BYTE *)(a2 + 10) = v14;
  sub_1001A060((int)&v18);
  LOBYTE(v15) = v19;
  v16 = v18;
  v11 = (v19 & 1) == 0;
  *(_BYTE *)(a2 + 63) = BYTE3(v18);
  *(_BYTE *)(a2 + 60) = v16;
  *(_BYTE *)(a2 + 64) = 0;
  if ( !v11 )
    *(_BYTE *)(a2 + 64) = 1;
  *(_BYTE *)(a2 + 65) = 0;
  if ( v15 & 4 )
    *(_BYTE *)(a2 + 65) = 1;
  *(_BYTE *)(a2 + 66) = 0;
  if ( v15 & 2 )
  {
    v15 = *(_WORD *)((char *)&v18 + 1);
    *(_BYTE *)(a2 + 66) = 1;
    *(_WORD *)(a2 + 61) = v15;
  }
  else
  {
    *(_WORD *)(a2 + 61) = *(_WORD *)((char *)&v18 + 1);
  }
  return v15;
}

//----- (1000BA30) --------------------------------------------------------
int __usercall sub_1000BA30@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@1
  int v5[10]; // [sp+1Ch] [bp-2Ch]@1

  sub_1000B8C0(a1, (int)&v4);
  result = v5[a3];
  *a2 = result;
  return result;
}
// 1000BA30: using guessed type int var_2C[10];

//----- (1000BA70) --------------------------------------------------------
int __usercall sub_1000BA70@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@3
  int v5[4]; // [sp+34h] [bp-14h]@3

  result = a3;
  if ( (unsigned __int8)a3 < 2u && a1 < 2u )
  {
    sub_1000B8C0(a3, (int)&v4);
    result = v5[a1];
    *a2 = result;
  }
  return result;
}
// 1000BA70: using guessed type int var_14[4];

//----- (1000BAB0) --------------------------------------------------------
signed int sub_1000BAB0()
{
  return sub_10025030((int)&off_10056090);
}
// 10056090: using guessed type char *off_10056090;

//----- (1000BAC0) --------------------------------------------------------
char __cdecl sub_1000BAC0(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  int v3; // esi@2
  char result; // al@2

  if ( (unsigned __int8)sub_1000BAB0() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_101761A4 + 4 * v3 + 29);
    *(_BYTE *)a3 = *(_BYTE *)(dword_101761A4 + 4 * v3 + 28);
    result = *(_BYTE *)(a2 + 2 * (3 * a1 + 72) + dword_101761A4);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101761A4: using guessed type int dword_101761A4;

//----- (1000BB20) --------------------------------------------------------
char __cdecl sub_1000BB20(char a1, void *a2)
{
  int v2; // edx@4
  char result; // al@20

  if ( (unsigned __int8)sub_1000BAB0() )
  {
    if ( (sub_10019AC0(a1)
       || *(_BYTE *)(dword_101761A4 + 2 * (3 * (unsigned __int8)a1 + 72))
       && (v2 = dword_101761A4 + 6 * (unsigned __int8)a1, *(_BYTE *)(dword_101761A4 + 6 * (unsigned __int8)a1 + 145))
       && *(_BYTE *)(v2 + 146)
       && *(_BYTE *)(v2 + 147)
       && *(_BYTE *)(v2 + 148)
       && *(_BYTE *)(v2 + 149)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101761A4 + 142)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101761A4 + 170)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101761A4 + 168)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101761A4 + 166)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101761A4 + 172)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101761A4 + 174)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101761A4 + 176))
      && *(_BYTE *)(dword_101761A4 + 2 * (unsigned __int8)a1 + 158)
      && *(_BYTE *)(dword_101761A4 + 2 * (unsigned __int8)a1 + 159)
      && *(_BYTE *)((unsigned __int8)a1 + dword_101761A4 + 156)
      && *(_BYTE *)((unsigned __int8)a1 + dword_101761A4 + 162) )
    {
      qmemcpy(a2, (const void *)(dword_101761A4 + 68 * (unsigned __int8)a1), 0x44u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101761A4: using guessed type int dword_101761A4;

//----- (1000BC40) --------------------------------------------------------
char __cdecl sub_1000BC40(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@2
  char result; // al@2

  if ( (unsigned __int8)sub_1000BAB0() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 2) = *(_BYTE *)(dword_101761A4 + 4 * v3 + 54);
    *(_BYTE *)a3 = *(_BYTE *)(dword_101761A4 + 4 * v3 + 52);
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_101761A4 + 4 * v3 + 53);
    *(_BYTE *)(a3 + 3) = *(_BYTE *)(dword_101761A4 + 4 * v3 + 55);
    result = *(_BYTE *)(a2 + 2 * a1 + 158 + dword_101761A4);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101761A4: using guessed type int dword_101761A4;

//----- (1000BCC0) --------------------------------------------------------
char __cdecl sub_1000BCC0(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6)
{
  char v6; // cl@2
  char result; // al@7
  unsigned __int16 v8; // ax@13

  if ( (_BYTE)a1 == 10 )
  {
    v6 = 0;
  }
  else
  {
    if ( (_BYTE)a1 != 11 )
    {
      sub_10009550("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 703, 0, 0);
      return 0;
    }
    v6 = 1;
  }
  LOBYTE(a1) = v6;
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        if ( a2 )
        {
          sub_1000BA70(*a4, a5, a1);
          result = 1;
        }
        else
        {
          result = sub_1000BC40(v6, *a4, (int)a5);
        }
      }
      else
      {
        sub_10009550("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 718, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        v8 = *a4;
        if ( a2 )
        {
          sub_1000BA30(v6, a5, v8);
          result = 1;
        }
        else
        {
          result = sub_1000BAC0(v6, v8, (int)a5);
        }
      }
      else
      {
        sub_10009550("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 750, 0, 0);
        result = 0;
      }
      break;
    case 0xB:
    case 0x12:
    case 0x1C:
      if ( a6 >= 0x44 )
      {
        if ( a2 )
        {
          sub_1000B8C0(v6, (int)a5);
          result = 1;
        }
        else
        {
          result = sub_1000BB20(v6, a5);
        }
      }
      else
      {
        sub_10009550("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 784, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10009550("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 809, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1000BE70) --------------------------------------------------------
char __cdecl sub_1000BE70(unsigned __int16 a1, char *a2, char a3)
{
  char result; // al@4
  char v4; // al@5
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
    {
      sub_10009550("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 188, 0, 0);
      return 0;
    }
    v4 = sub_10005930(1, 555, &v5, (int)&a1);
  }
  else
  {
    v4 = sub_10005930(1, 550, &v5, (int)&a1);
  }
  if ( !v4 )
    return 0;
  if ( sub_1000F1F0((int)&v5) )
    return 0;
  result = 1;
  if ( !BYTE1(v14) || (unsigned int)a1 - 4 < 0x20 )
    return 0;
  if ( a3 )
  {
    if ( BYTE1(v5) == 26 )
    {
      qmemcpy(a2, (char *)&v6 + 1, 0x20u);
      qmemcpy(&unk_100C8850, (char *)&v6 + 1, 0x20u);
      byte_100C8848 = 1;
      byte_100C8849 = 0;
      return result;
    }
  }
  else if ( BYTE1(v5) == 12 )
  {
    qmemcpy(a2, (char *)&v6 + 1, 0x20u);
    qmemcpy(&unk_100C8870, (char *)&v6 + 1, 0x20u);
    byte_100C8849 = 1;
    byte_100C884A = 1;
    return result;
  }
  return 0;
}
// 100C8848: using guessed type char byte_100C8848;
// 100C8849: using guessed type char byte_100C8849;
// 100C884A: using guessed type char byte_100C884A;

//----- (1000BFA0) --------------------------------------------------------
char __cdecl sub_1000BFA0(char a1, int a2)
{
  char result; // al@3
  char v3; // [sp+4h] [bp-44h]@1
  char v4; // [sp+8h] [bp-40h]@3
  char v5; // [sp+28h] [bp-20h]@3

  memset(&v3, 0, 0x44u);
  if ( (unsigned __int8)a1 < 2u && a2 )
  {
    result = sub_10019FC0(a1, (int)&v3);
    qmemcpy((void *)a2, &v4, 0x20u);
    qmemcpy((void *)(a2 + 32), &v5, 0x20u);
  }
  else
  {
    result = sub_10009550("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 570, 0, 0);
  }
  return result;
}

//----- (1000C020) --------------------------------------------------------
bool __cdecl sub_1000C020(void *a1)
{
  bool v1; // zf@2
  bool result; // al@4

  if ( a1 )
  {
    v1 = byte_100C8848 == 0;
    qmemcpy(a1, &unk_100C8850, 0x40u);
    result = !v1 && byte_100C884A;
  }
  else
  {
    sub_10009550("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 617, 0, 0);
    result = 0;
  }
  return result;
}
// 100C8848: using guessed type char byte_100C8848;
// 100C884A: using guessed type char byte_100C884A;

//----- (1000C070) --------------------------------------------------------
char __cdecl sub_1000C070(char a1, int a2)
{
  char result; // al@4
  int v3; // edx@5
  const void *v4; // esi@8
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( j_HWM_pvg_read_reg(1) != 1 )
    sub_10009550("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 857, 1, 0);
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 != 1 )
      return result;
    result = sub_100195E0(15);
    v3 = 555;
  }
  else
  {
    result = sub_100195E0(8);
    v3 = 550;
  }
  if ( result )
  {
    v4 = (const void *)a2;
    LOBYTE(v5) = 12;
    BYTE1(v14) = 1;
    LOBYTE(v6) = 32;
    HIWORD(v5) = 34;
    if ( byte_100C8849 )
    {
      BYTE1(v5) = 26;
    }
    else
    {
      BYTE1(v5) = 12;
      v4 = (const void *)(a2 + 32);
    }
    qmemcpy((char *)&v6 + 1, v4, 0x20u);
    result = sub_10005430(1, v3, &v5, 1, 38, 1);
  }
  return result;
}
// 10025200: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 100C8849: using guessed type char byte_100C8849;

//----- (1000C150) --------------------------------------------------------
__int16 __usercall sub_1000C150@<ax>(unsigned __int8 a1@<al>)
{
  return word_100561B0[a1];
}
// 100561B0: using guessed type __int16 word_100561B0[];

//----- (1000C160) --------------------------------------------------------
char __cdecl sub_1000C160(unsigned __int8 a1, int *a2, const void *a3)
{
  int v3; // ebx@1
  int v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int v7; // [sp+14h] [bp-20h]@1
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+28h] [bp-Ch]@1
  int v13; // [sp+2Ch] [bp-8h]@1
  int v14; // [sp+30h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v3 = (unsigned __int16)sub_1000C150(a1);
  v5 = *a2;
  qmemcpy(&v6, a3, 0x24u);
  sub_10005430(1, v3, &v5, 1, HIWORD(v5) + 4, 1);
  return sub_10005570(1, v3, 0xFFFFFFF);
}

//----- (1000C1F0) --------------------------------------------------------
char __cdecl sub_1000C1F0(unsigned __int8 a1, char a2)
{
  int v3; // [sp+4h] [bp-28h]@1
  int v4; // [sp+8h] [bp-24h]@1
  int v5; // [sp+Ch] [bp-20h]@1
  int v6; // [sp+10h] [bp-1Ch]@1
  int v7; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@1
  int v9; // [sp+1Ch] [bp-10h]@1
  int v10; // [sp+20h] [bp-Ch]@1
  int v11; // [sp+24h] [bp-8h]@1
  int v12; // [sp+28h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v3 = 0;
  if ( a1 >= 2u )
  {
    sub_10009550("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 736, 0, 0);
  }
  else
  {
    HIWORD(v3) = 0;
    LOBYTE(v3) = 12;
    if ( a2 == 11 )
    {
      BYTE1(v3) = byte_100C8849 != 0 ? 25 : 11;
      sub_1000C160(a1, &v3, &v4);
      return 1;
    }
    if ( a2 == 17 )
    {
      LOWORD(v3) = 10042;
      sub_1000C160(a1, &v3, &v4);
      return 1;
    }
  }
  return 0;
}
// 100C8849: using guessed type char byte_100C8849;

//----- (1000C2B0) --------------------------------------------------------
bool __cdecl sub_1000C2B0(__int16 a1, char a2, int a3, int a4, void *a5)
{
  char v6; // [sp+4h] [bp-40h]@8
  char v7; // [sp+24h] [bp-20h]@11

  if ( (unsigned __int8)a1 == 8 )
  {
    LOBYTE(a1) = 0;
  }
  else
  {
    if ( (unsigned __int8)a1 != 9 )
      return 0;
    LOBYTE(a1) = 1;
  }
  if ( a2 == 1 )
  {
    sub_1000BFA0(a1, (int)a5);
    return 1;
  }
  if ( byte_100C8849 )
  {
    if ( sub_1000BE70(a1, &v6, 1) )
    {
LABEL_14:
      byte_100C884B = 0;
      goto LABEL_15;
    }
    if ( (unsigned __int8)++byte_100C884B >= 5u )
    {
      byte_100C8848 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( sub_1000BE70(a1, &v7, 0) )
      goto LABEL_14;
    if ( (unsigned __int8)++byte_100C884B >= 5u )
    {
      byte_100C884A = 0;
      goto LABEL_14;
    }
  }
LABEL_15:
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    sub_1000BFA0(a1, (int)&v6);
    sub_1000C070(a1, (int)&v6);
  }
  sub_1000C1F0(a1, 11);
  return sub_1000C020(a5);
}
// 10025200: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 100C8848: using guessed type char byte_100C8848;
// 100C8849: using guessed type char byte_100C8849;
// 100C884A: using guessed type char byte_100C884A;
// 100C884B: using guessed type char byte_100C884B;

//----- (1000C3B0) --------------------------------------------------------
char __thiscall sub_1000C3B0(void *this)
{
  char v1; // bl@1
  void *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_100C8890 = sub_10009F90(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_100C8898, 0, 0xAA0u);
  v1 = 0;
  v4 = 0;
  v2 = &unk_100C8898;
  do
  {
    result = sub_10019F90(v4, (int)v2);
    ++v1;
    v2 = (char *)v2 + 2720;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 2u );
  return result;
}
// 100C8890: using guessed type int dword_100C8890;

//----- (1000C420) --------------------------------------------------------
char __usercall sub_1000C420@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4)
{
  char result; // al@1

  memset(a3, 0, (unsigned __int16)a2);
  result = 0;
  if ( a4 )
  {
    if ( a4 == 1 )
      result = sub_100058D0(6, 8, a1, a2, a3);
  }
  else
  {
    result = sub_100058D0(6, 5, a1, a2, a3);
  }
  return result;
}

//----- (1000C460) --------------------------------------------------------
void *__usercall sub_1000C460@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4)
{
  int v4; // edi@1
  void *result; // eax@4

  v4 = 0;
  if ( dword_100C8890 == 1379255385 )
    goto LABEL_4;
  v4 = sub_10024980(86, 10);
  if ( !v4 )
  {
    memset((char *)&unk_100C8898 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
    sub_10019F90(a1, (int)&unk_100C8898 + 2720 * (unsigned __int8)a1);
LABEL_4:
    result = memcpy(a4, (char *)&unk_100C8898 + 2720 * (unsigned __int8)a1 + (unsigned __int16)a2, (unsigned __int16)a3);
    goto LABEL_6;
  }
  result = memset(a4, 0, (unsigned __int16)a3);
LABEL_6:
  if ( dword_100C8890 != 1379255385 )
    result = (void *)sub_10024950(v4, 86);
  return result;
}
// 100C8890: using guessed type int dword_100C8890;

//----- (1000C500) --------------------------------------------------------
char __cdecl sub_1000C500(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 <= 0xAu )
    result = sub_1000C420(4 * (a2 + 6), 4, a3, a1);
  return result;
}

//----- (1000C540) --------------------------------------------------------
bool __cdecl sub_1000C540(char a1, char a2, void *a3)
{
  bool result; // al@1
  unsigned __int8 v4; // al@3

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 <= 0xAu )
  {
    sub_1000C460(a1, 4 * ((unsigned __int8)a2 + 6), 4, a3);
    v4 = *((_BYTE *)a3 + 1);
    result = v4 < 0x33u || v4 >= 0x64u && v4 <= 0x81u || v4 >= 0x96u && v4 <= 0x9Eu;
  }
  return result;
}

//----- (1000C5A0) --------------------------------------------------------
char __cdecl sub_1000C5A0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xAu )
    result = sub_1000C420(a2, 1, a3, a1);
  return result;
}

//----- (1000C5E0) --------------------------------------------------------
char __cdecl sub_1000C5E0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xAu )
  {
    sub_1000C460(a1, (unsigned __int8)a2, 1, a3);
    result = 1;
  }
  return result;
}

//----- (1000C610) --------------------------------------------------------
char __cdecl sub_1000C610(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xBu )
    result = sub_1000C420(a2 + 10, 1, a3, a1);
  return result;
}

//----- (1000C650) --------------------------------------------------------
char __cdecl sub_1000C650(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xBu )
  {
    sub_1000C460(a1, (unsigned __int8)a2 + 10, 1, a3);
    result = 1;
  }
  return result;
}

//----- (1000C690) --------------------------------------------------------
char __cdecl sub_1000C690(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 2u )
    result = sub_1000C420(16 * (a2 + 50), 16, a3, a1);
  return result;
}

//----- (1000C6D0) --------------------------------------------------------
bool __cdecl sub_1000C6D0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 2u )
  {
    sub_1000C460(a1, 16 * ((unsigned __int8)a2 + 50), 16, a3);
    result = *(_BYTE *)a3 < 8u && *((_BYTE *)a3 + 1) < 8u;
  }
  return result;
}

//----- (1000C720) --------------------------------------------------------
char __cdecl sub_1000C720(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x29u )
    result = sub_1000C420(12 * a2 + 68, 12, a3, a1);
  return result;
}

//----- (1000C760) --------------------------------------------------------
bool __cdecl sub_1000C760(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x29u )
  {
    sub_1000C460(a1, 12 * (unsigned __int8)a2 + 68, 12, a3);
    result = *((_WORD *)a3 + 1) < 0x319u;
  }
  return result;
}

//----- (1000C7A0) --------------------------------------------------------
char __cdecl sub_1000C7A0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x2Au )
    result = sub_1000C420(4 * (a2 + 140), 4, a3, a1);
  return result;
}

//----- (1000C7E0) --------------------------------------------------------
bool __cdecl sub_1000C7E0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x2Au )
  {
    sub_1000C460(a1, 4 * ((unsigned __int8)a2 + 140), 4, a3);
    result = *((_WORD *)a3 + 1) < 0x145u;
  }
  return result;
}

//----- (1000C820) --------------------------------------------------------
char __cdecl sub_1000C820(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1000C420(1229, 1, a2, a1);
  return result;
}

//----- (1000C850) --------------------------------------------------------
char __cdecl sub_1000C850(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1000C460(a1, 1229, 1, a2);
    result = 1;
  }
  return result;
}

//----- (1000C880) --------------------------------------------------------
char __cdecl sub_1000C880(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1000C420(1212, 16, a2, a1);
  return result;
}

//----- (1000C8B0) --------------------------------------------------------
char __cdecl sub_1000C8B0(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1000C460(a1, 1212, 16, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000C8E0) --------------------------------------------------------
char __cdecl sub_1000C8E0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1000C420(2400, 65, a2, a1);
  return result;
}

//----- (1000C910) --------------------------------------------------------
char __cdecl sub_1000C910(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1000C460(a1, 2400, 65, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000C940) --------------------------------------------------------
char __cdecl sub_1000C940(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 < 8u && (unsigned __int8)a1 < 2u )
    result = sub_1000C420(4 * (a2 + 182), 4, a3, a1);
  return result;
}

//----- (1000C980) --------------------------------------------------------
char __cdecl sub_1000C980(char a1, char a2, void *a3)
{
  char result; // al@2

  if ( (unsigned __int8)a2 > 7u )
    result = sub_10009550("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 1428, 0, 0);
  else
    result = (unsigned int)sub_1000C460(a1, 4 * ((unsigned __int8)a2 + 182), 4, a3);
  return result;
}

//----- (1000C9D0) --------------------------------------------------------
char __cdecl sub_1000C9D0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 <= 4u )
    result = sub_1000C420(8 * (a2 + 95), 8, a3, a1);
  return result;
}

//----- (1000CA10) --------------------------------------------------------
char __cdecl sub_1000CA10(char a1, char a2, void *a3)
{
  char result; // al@1

  result = a2;
  if ( (unsigned __int8)a2 <= 4u )
    result = (unsigned int)sub_1000C460(a1, 8 * ((unsigned __int8)a2 + 95), 8, a3);
  return result;
}

//----- (1000CA40) --------------------------------------------------------
char __cdecl sub_1000CA40(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1000C420(22, 1, a2, a1);
  return result;
}

//----- (1000CA70) --------------------------------------------------------
char __cdecl sub_1000CA70(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1000C420(832, 4, a2, a1);
  return result;
}

//----- (1000CAA0) --------------------------------------------------------
char __cdecl sub_1000CAA0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1000C460(a1, 832, 4, a2);
    result = 1;
  }
  return result;
}

//----- (1000CAD0) --------------------------------------------------------
char __cdecl sub_1000CAD0(int a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@4
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1001A500(a1);
  if ( v6 == 2 )
  {
LABEL_44:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 0:
        if ( a2 )
        {
          sub_1000C980(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_1000C940(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 1:
        if ( a2 )
        {
          sub_1000CA10(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_1000C9D0(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 2:
        if ( a2 )
          result = sub_1000C540(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1000C500(v6, *(_BYTE *)a4, a5);
        break;
      case 3:
        if ( a2 )
          result = sub_1000C760(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1000C720(v6, *(_BYTE *)a4, a5);
        break;
      case 4:
        if ( a2 )
          result = sub_1000C7E0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1000C7A0(v6, *(_BYTE *)a4, a5);
        break;
      case 5:
        if ( a2 )
          result = sub_1000C5E0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1000C5A0(v6, *(_BYTE *)a4, a5);
        break;
      case 6:
        if ( a2 )
          result = sub_1000C650(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1000C610(v6, *(_BYTE *)a4, a5);
        break;
      case 7:
        result = sub_1000CA40(v6, a5);
        break;
      case 8:
        if ( a2 )
          result = sub_1000C8B0(v6, a5);
        else
          result = sub_1000C880(v6, a5);
        break;
      case 9:
        if ( a2 )
          result = sub_1000C6D0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1000C690(v6, *(_BYTE *)a4, a5);
        break;
      case 0x1D:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_1000C910(v6, a5);
        else
          result = sub_1000C8E0(v6, a5);
        break;
      case 0x21:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_1000C850(v6, a5);
        else
          result = sub_1000C820(v6, a5);
        break;
      case 0x1B:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_1000CAA0(v6, a5);
        else
          result = sub_1000CA70(v6, a5);
        break;
      default:
        sub_10009550("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 2329, 0, 0);
        goto LABEL_44;
    }
  }
  return result;
}
// 10025200: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1000CE70) --------------------------------------------------------
bool __cdecl sub_1000CE70(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  char v4; // dl@5
  bool result; // al@5

  v3 = a2;
  if ( a2 >= 0xFFu || a2 > 1u )
  {
    result = 0;
  }
  else
  {
    if ( dword_100C9DD8 != 1379255385 )
    {
      sub_10019F70(a1, (int)&byte_100C9DE0[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v4 = byte_100C9DE5[4 * (v3 + 6 * (unsigned __int8)a1)];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_100C9DE4[4 * (v3 + 6 * (unsigned __int8)a1)];
    result = (unsigned __int8)v4 < 0xBu;
  }
  return result;
}
// 100C9DD8: using guessed type int dword_100C9DD8;

//----- (1000CEE0) --------------------------------------------------------
bool __cdecl sub_1000CEE0(char a1, unsigned __int8 a2, int a3)
{
  bool result; // al@2

  if ( a2 < 1u )
  {
    if ( dword_100C9DD8 != 1379255385 )
      sub_10019F70(a1, (int)&byte_100C9DE0[24 * (unsigned __int8)a1]);
    *(_DWORD *)a3 = dword_100C9DF4[a2 + 6 * (unsigned __int8)a1];
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100C9DD8: using guessed type int dword_100C9DD8;
// 100C9DF4: using guessed type int dword_100C9DF4[];

//----- (1000CF40) --------------------------------------------------------
bool __cdecl sub_1000CF40(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  bool result; // al@1
  int v5; // edx@5

  v3 = a2;
  result = 0;
  if ( (a2 & 0x80u) == 0 && a2 <= 1u )
  {
    if ( dword_100C9DD8 != 1379255385 )
    {
      sub_10019F70(a1, (int)&byte_100C9DE0[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v5 = dword_100C9DEC[v3 + 6 * (unsigned __int8)a1];
    *(_DWORD *)a3 = v5;
    result = (unsigned __int8)v5 < 0x13u && *(_BYTE *)(a3 + 1) < 0x13u;
  }
  return result;
}
// 100C9DD8: using guessed type int dword_100C9DD8;
// 100C9DEC: using guessed type int dword_100C9DEC[];

//----- (1000CFB0) --------------------------------------------------------
char __cdecl sub_1000CFB0(char a1, _BYTE *a2)
{
  if ( dword_100C9DD8 != 1379255385 )
    sub_10019F70(a1, (int)&byte_100C9DE0[24 * (unsigned __int8)a1]);
  *a2 = byte_100C9DE0[24 * (unsigned __int8)a1];
  return 1;
}
// 100C9DD8: using guessed type int dword_100C9DD8;

//----- (1000CFF0) --------------------------------------------------------
char __thiscall sub_1000CFF0(void *this)
{
  char v1; // bl@1
  char *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_100C9DD8 = sub_10009F90(this) != 2 ? 1379255385 : 1916032632;
  memset(byte_100C9DE0, 0, 0x48u);
  v1 = 0;
  v4 = 0;
  v2 = byte_100C9DE0;
  do
  {
    result = sub_10019F70(v4, (int)v2);
    ++v1;
    v2 += 24;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 3u );
  return result;
}
// 100C9DD8: using guessed type int dword_100C9DD8;

//----- (1000D060) --------------------------------------------------------
char __cdecl sub_1000D060(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_10019770(a1);
  v3 = sub_100256F0(a2, 0, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (1000D090) --------------------------------------------------------
char __cdecl sub_1000D090(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_10019770(a1);
  v3 = sub_10025760(a2, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (1000D0C0) --------------------------------------------------------
char __cdecl sub_1000D0C0(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6)
{
  char result; // al@3
  char v7; // [sp+0h] [bp-4h]@1

  v7 = sub_10019860(a1);
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        result = sub_1000CF40(v7, *a4, (int)a5);
      }
      else
      {
        sub_10009550("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 531, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        result = sub_1000CE70(v7, *a4, (int)a5);
      }
      else
      {
        sub_10009550("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 548, 0, 0);
        result = 0;
      }
      break;
    case 3:
      if ( a6 >= 4 )
      {
        result = sub_1000CEE0(v7, *a4, (int)a5);
      }
      else
      {
        sub_10009550("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 565, 0, 0);
        result = 0;
      }
      break;
    case 7:
      if ( a6 >= 1 )
      {
        result = sub_1000CFB0(v7, a5);
      }
      else
      {
        sub_10009550("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 582, 0, 0);
        result = 0;
      }
      break;
    case 0x10:
      if ( a6 >= 0x40 )
      {
        result = sub_1000D090(v7, (int)a5);
      }
      else
      {
        sub_10009550("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 598, 0, 0);
        result = 0;
      }
      break;
    case 0xF:
      if ( a6 >= 0x68 )
      {
        result = sub_1000D060(v7, (int)a5);
      }
      else
      {
        sub_10009550("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 616, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10009550("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 633, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1000D290) --------------------------------------------------------
int __cdecl sub_1000D290(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@6
  int v7; // ebx@6
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  _DWORD *v21; // esi@23
  unsigned int v22; // ecx@23
  _DWORD *v23; // edx@23
  int v24; // edi@27
  int v25; // ecx@28
  _BYTE *v26; // edx@28
  _BYTE *v27; // esi@28
  int v28; // ecx@30
  _BYTE *v29; // edx@30
  _BYTE *v30; // esi@30
  _BYTE *v31; // edx@32
  _BYTE *v32; // esi@32
  int v33; // edx@33
  signed int v34; // ecx@34
  int v35; // [sp+4h] [bp-4h]@6

  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && a5 > 0 )
  {
    result = a5 - 1;
    v7 = a3 + a4 * (a5 - 1);
    v35 = a5 - 1;
    if ( a5 - 1 > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v35;
        if ( v20 )
        {
          v7 -= a4;
          result = v35 - 1;
          v35 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a1;
    v22 = a2;
    v23 = (_DWORD *)v7;
    if ( a2 < 4 )
    {
LABEL_26:
      if ( !v22 )
        goto LABEL_36;
    }
    else
    {
      while ( *v21 == *v23 )
      {
        v22 -= 4;
        ++v23;
        ++v21;
        if ( v22 < 4 )
          goto LABEL_26;
      }
    }
    v24 = *(_BYTE *)v21 - *(_BYTE *)v23;
    if ( *(_BYTE *)v21 != *(_BYTE *)v23
      || (v25 = v22 - 1, v26 = (char *)v23 + 1, v27 = (char *)v21 + 1, v25)
      && ((v24 = *v27 - *v26, *v27 != *v26)
       || (v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, v28)
       && ((v24 = *v30 - *v29, *v30 != *v29)
        || (v31 = v29 + 1, v32 = v30 + 1, v28 != 1) && (v33 = *v31, v24 = *v32 - v33, *v32 != v33))) )
    {
      v34 = 1;
      if ( v24 <= 0 )
        v34 = -1;
LABEL_37:
      if ( !v34 )
        return result;
      return a6;
    }
LABEL_36:
    v34 = 0;
    goto LABEL_37;
  }
  return a6;
}

//----- (1000D420) --------------------------------------------------------
int __cdecl sub_1000D420(int a1, _BYTE *a2, int a3)
{
  int v3; // esi@2
  int v4; // eax@2
  _BYTE *v5; // ecx@3
  int result; // eax@7

  if ( a3 <= 0 )
    goto LABEL_11;
  v3 = a3 - 1;
  v4 = 0;
  if ( a3 - 1 > 0 )
  {
    v5 = a2;
    do
    {
      if ( !*v5 )
        break;
      v5[a1 - (_DWORD)a2] = *v5;
      ++v4;
      ++v5;
    }
    while ( v4 < v3 );
  }
  *(_BYTE *)(v4 + a1) = 0;
  *(_BYTE *)(v3 + a1) = 0;
  if ( a2[v4] )
LABEL_11:
    result = -1;
  else
    result = v4 + 1;
  return result;
}

//----- (1000D470) --------------------------------------------------------
int __cdecl sub_1000D470(void *a1, size_t a2)
{
  _BYTE *v2; // eax@1
  int result; // eax@2

  v2 = memchr(a1, 0, a2);
  if ( v2 )
    result = v2 - (_BYTE *)a1;
  else
    result = -2;
  return result;
}

//----- (1000D4A0) --------------------------------------------------------
int __cdecl sub_1000D4A0(char *a1, size_t a2, char *a3, va_list a4)
{
  int result; // eax@2

  if ( (signed int)a2 > 0 )
  {
    result = _vsnprintf(a1, a2, a3, a4);
    if ( result < 0 )
      result = -1;
    a1[a2 - 1] = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1000D4E0) --------------------------------------------------------
int sub_1000D4E0(char *a1, size_t a2, char *a3, ...)
{
  int result; // eax@1
  va_list va; // [sp+10h] [bp+10h]@1

  va_start(va, a3);
  result = sub_1000D4A0(a1, a2, a3, va);
  if ( result < 0 )
    result = -1;
  return result;
}

//----- (1000D510) --------------------------------------------------------
int __cdecl sub_1000D510(const char *a1, _BYTE *a2, int a3)
{
  unsigned int v3; // kr00_4@1

  v3 = strlen(a1);
  return sub_1000D420((int)&a1[v3], a2, a3 - v3);
}

//----- (1000D550) --------------------------------------------------------
char __cdecl sub_1000D550(unsigned __int16 a1, float *a2)
{
  unsigned __int16 v2; // ax@2
  char result; // al@5
  char v4[4]; // [sp+1Ch] [bp-74h]@1
  int v5; // [sp+20h] [bp-70h]@3
  int v6; // [sp+24h] [bp-6Ch]@1
  char v7; // [sp+28h] [bp-68h]@1

  memset(&v7, 0, 0x64u);
  v6 = 0;
  if ( sub_1000F650(a1, v4, &v6) == 1 )
  {
    v2 = sub_10004C60(v4[0]);
    if ( (unsigned __int16)v6 >= v2 )
    {
      if ( a1 )
      {
        sprintf(&v7, "NO PKT FOR TYPE %d\n", a1);
        sub_10009550("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 593, 0, &v7);
      }
    }
    else if ( sub_10005900(v4[0], v6, &v5) && !sub_1000F250((int)&v5, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0) )
    {
      result = 1;
      *a2 = *(float *)&v5;
      return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000D670) --------------------------------------------------------
double __cdecl sub_1000D670(float a1)
{
  int v1; // ecx@0
  double result; // st7@1
  float v3; // [sp+0h] [bp-4h]@1
  float v4; // [sp+8h] [bp+4h]@1
  float v5; // [sp+8h] [bp+4h]@3

  v4 = *(float *)v1 * a1 + *(float *)(v1 + 4);
  v3 = *(float *)(v1 + 8);
  result = v4;
  if ( v3 >= (double)v4 )
    result = v3;
  v5 = *(float *)(v1 + 12);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (1000D6D0) --------------------------------------------------------
char __usercall sub_1000D6D0@<al>(int a1@<esi>, unsigned __int16 a2, float *a3)
{
  char v3; // dl@39
  char result; // al@39
  float v5; // [sp+0h] [bp-280h]@11
  float v6[19]; // [sp+4h] [bp-27Ch]@11
  float v7; // [sp+50h] [bp-230h]@11
  float v8[76]; // [sp+54h] [bp-22Ch]@11
  int v9; // [sp+17Ch] [bp-104h]@29
  int v10; // [sp+180h] [bp-100h]@29
  float v11; // [sp+184h] [bp-FCh]@29
  char v12; // [sp+197h] [bp-E9h]@1
  float v13; // [sp+198h] [bp-E8h]@1
  float v14; // [sp+19Ch] [bp-E4h]@1
  float v15; // [sp+1A0h] [bp-E0h]@1
  float v16; // [sp+1A4h] [bp-DCh]@1
  float v17; // [sp+1A8h] [bp-D8h]@1
  float v18; // [sp+1ACh] [bp-D4h]@1
  float v19; // [sp+1B0h] [bp-D0h]@17
  float v20; // [sp+1B4h] [bp-CCh]@37
  float v21; // [sp+1B8h] [bp-C8h]@22
  float v22; // [sp+1BCh] [bp-C4h]@17
  int v23; // [sp+1C0h] [bp-C0h]@1
  int v24[3]; // [sp+1C4h] [bp-BCh]@1
  int v25; // [sp+1D0h] [bp-B0h]@1
  int v26[3]; // [sp+1D4h] [bp-ACh]@1
  int v27; // [sp+1E0h] [bp-A0h]@1
  int v28; // [sp+1E4h] [bp-9Ch]@1
  int v29; // [sp+208h] [bp-78h]@1
  int v30; // [sp+20Ch] [bp-74h]@1
  int v31; // [sp+230h] [bp-50h]@1
  int v32; // [sp+234h] [bp-4Ch]@1
  int v33; // [sp+258h] [bp-28h]@1
  int v34; // [sp+25Ch] [bp-24h]@1

  v12 = 0;
  v25 = 0;
  v26[0] = 0;
  v23 = 0;
  v24[0] = 0;
  v27 = 0;
  v28 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v29 = 0;
  v30 = 0;
  v13 = 0.0;
  v14 = 0.0;
  v15 = 0.0;
  v16 = 0.0;
  v17 = 0.0;
  v18 = 0.0;
  switch ( a2 )
  {
    case 0x3Au:
    case 0x3Bu:
      if ( sub_100249E0(6091, (int)&v23, 16) )
        sub_10009550("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 192, 0, 0);
      if ( sub_100249E0(6115, (int)&v25, 16) )
        sub_10009550("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 193, 0, 0);
      v16 = *((float *)&v23 + 2 * a1);
      v15 = *(float *)&v24[2 * a1];
      v13 = *((float *)&v25 + 2 * a1);
      v14 = *(float *)&v26[2 * a1];
      goto LABEL_37;
    case 0x3Cu:
    case 0x3Du:
    case 0x3Eu:
    case 0x3Fu:
    case 0x40u:
      if ( sub_100249E0(6090, (int)&v31, 40) )
        sub_10009550("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 205, 0, 0);
      if ( sub_100249E0(6114, (int)&v27, 40) )
        sub_10009550("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 206, 0, 0);
      v16 = *(&v7 + 2 * a2);
      v15 = v8[2 * a2];
      v13 = *(&v5 + 2 * a2);
      v14 = v6[2 * a2];
      goto LABEL_37;
    case 0x41u:
    case 0x42u:
    case 0x43u:
    case 0x44u:
    case 0x45u:
      if ( sub_100249E0(6092, (int)&v29, 40) )
        sub_10009550("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 218, 0, 0);
      if ( sub_100249E0(6116, (int)&v33, 40) )
        sub_10009550("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 219, 0, 0);
      v16 = *(&v5 + 2 * a2);
      v15 = v6[2 * a2];
      v13 = *(&v7 + 2 * a2);
      v14 = v8[2 * a2];
      goto LABEL_37;
    case 0x4Eu:
      v19 = 9.8999998e24;
      if ( sub_10024A40(6355, &v22, 4, &v19) )
        sub_10009550("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 228, 0, 0);
      sub_10025190(14, &v12);
      if ( v12 == 10 )
        v22 = v22 * 0.5555555820465088;
      v16 = 9.9999996e24;
      v15 = -9.9999996e24;
      v17 = -9.9999996e24;
      v18 = 9.9999996e24;
      v14 = v22;
      v13 = 1.0;
      goto LABEL_37;
    case 0x4Fu:
      v19 = 9.8999998e24;
      if ( sub_10024A40(6356, &v21, 4, &v19) )
        sub_10009550("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 250, 0, 0);
      sub_10025190(14, &v12);
      if ( v12 == 10 )
        v21 = v21 * 0.5555555820465088;
      v16 = 9.9999996e24;
      v15 = -9.9999996e24;
      v17 = -9.9999996e24;
      v18 = 9.9999996e24;
      v14 = v21;
      v13 = 1.0;
      goto LABEL_37;
    case 0x98u:
    case 0x99u:
      v16 = 9.9999996e24;
      v15 = -9.9999996e24;
      v13 = 1.0;
      v14 = 0.0;
      goto LABEL_37;
    case 0x67u:
      if ( !sub_100249E0(6162, (int)&v13, 24) )
        goto LABEL_37;
      v11 = 0.0;
      v10 = 0;
      v9 = 282;
      goto LABEL_36;
    case 0x68u:
    case 0xC0u:
      if ( !sub_100249E0(6161, (int)&v13, 24) )
        goto LABEL_37;
      v11 = 0.0;
      v10 = 0;
      v9 = 287;
      goto LABEL_36;
    case 0x69u:
      if ( !sub_100249E0(6160, (int)&v13, 24) )
        goto LABEL_37;
      v11 = 0.0;
      v10 = 0;
      v9 = 291;
      goto LABEL_36;
    case 0x70u:
      if ( sub_100249E0(6235, (int)&v13, 24) )
      {
        v11 = 0.0;
        v10 = 0;
        v9 = 295;
LABEL_36:
        sub_10009550("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", v9, v10, (char *)LODWORD(v11));
      }
LABEL_37:
      if ( sub_1000D550(a2, &v20) && (LODWORD(v20) & 0x7F800000) != 2139095040 )
      {
        *a3 = sub_1000D670(v20);
        result = v3;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 1000D6D0: using guessed type int var_AC[3];
// 1000D6D0: using guessed type int var_BC[3];
// 1000D6D0: using guessed type float var_22C[76];
// 1000D6D0: using guessed type float var_27C[19];

//----- (1000DC10) --------------------------------------------------------
char __cdecl sub_1000DC10(unsigned __int8 a1)
{
  void *v1; // ecx@0
  char v2; // al@1
  int v3; // eax@1
  char result; // al@2
  char v5[68]; // [sp+0h] [bp-48h]@1

  v2 = sub_1001A570(v1);
  v3 = sub_1000DE00(v2);
  if ( sub_100249E0(v3, (int)v5, 67) )
    result = 0;
  else
    result = v5[a1];
  return result;
}
// 1000DC10: using guessed type char var_48[68];

//----- (1000DC70) --------------------------------------------------------
signed int sub_1000DC70()
{
  return sub_10025030((int)&off_10057170);
}
// 10057170: using guessed type char *off_10057170;

//----- (1000DC80) --------------------------------------------------------
char __usercall sub_1000DC80@<al>(unsigned __int8 a1@<al>, char a2, void *a3)
{
  unsigned __int8 v3; // bl@1
  char result; // al@7

  v3 = a1;
  if ( (unsigned __int8)(a1 - 53) > 0xDu
    || (unsigned __int8)a2 >= 3u
    || !(unsigned __int8)sub_1000DC70()
    || sub_10024870(33, 10) )
  {
    sub_10009550("..\\lib\\adl\\iop_data.c", 366, 0, 0);
    result = 0;
  }
  else if ( (unsigned int)(sub_100247C0()
                         - *(_DWORD *)(dword_101761A8 + 4 * (v3 - 33 + (unsigned __int8)a2 + 2 * (v3 - 33)))) <= 0x258
         && *(_BYTE *)(v3 + (unsigned __int8)a2 + 2 * v3 + dword_101761A8 + 37) )
  {
    memcpy(
      a3,
      (const void *)(dword_101761A8 + 4 * (v3 - 53 + (unsigned __int8)a2 + 2 * (v3 - 53))),
      *(_WORD *)(dword_101761A8 + 2 * v3 + 62));
    sub_10024850(33);
    result = 1;
  }
  else
  {
    sub_10024850(33);
    result = 0;
  }
  return result;
}
// 101761A8: using guessed type int dword_101761A8;

//----- (1000DD60) --------------------------------------------------------
char __cdecl sub_1000DD60(int a1, char a2, void *a3)
{
  char result; // al@1
  int v4; // eax@4
  int v5; // esi@6
  int v6; // edi@7

  result = 0;
  if ( (unsigned __int8)a1 < 0x43u && (unsigned __int8)a2 < 3u )
  {
    if ( (unsigned __int8)a1 > 0x34u )
    {
      result = sub_1000DC80(a1, a2, a3);
    }
    else
    {
      v4 = sub_1001A5B0(a1);
      if ( v4
        && (v5 = v4 + 4 * (unsigned __int8)a2, *(_BYTE *)v5 < 7)
        && (v6 = *(_WORD *)(v5 + 2), (unsigned __int16)v6 < (unsigned __int16)sub_10004C60(*(_BYTE *)v5)) )
      {
        result = sub_10005900(*(_BYTE *)v5, v6, a3);
      }
      else
      {
        result = 0;
      }
    }
  }
  return result;
}
// 1001A5B0: using guessed type _DWORD __cdecl sub_1001A5B0(char);

//----- (1000DDE0) --------------------------------------------------------
char __cdecl sub_1000DDE0(int a1, void *a2)
{
  char v2; // al@1

  v2 = sub_1000DC10(a1);
  return sub_1000DD60(a1, v2, a2);
}

//----- (1000DE00) --------------------------------------------------------
int __cdecl sub_1000DE00(char a1)
{
  return 9190 - (a1 != 1);
}

//----- (1000DE10) --------------------------------------------------------
unsigned int __cdecl sub_1000DE10(char *a1)
{
  return sub_1000F340(a1, -100, 100, 0, 0);
}

//----- (1000DE30) --------------------------------------------------------
int __cdecl sub_1000DE30(unsigned __int8 *a1)
{
  return sub_1000F4B0(a1, 0, 2u, 0, 0);
}

//----- (1000DE50) --------------------------------------------------------
int __cdecl sub_1000DE50(_BYTE *a1)
{
  return sub_1000F5A0(a1, 0x1CCF0u, 0x2171Eu, 0x2171Eu, 0);
}

//----- (1000DE70) --------------------------------------------------------
int __cdecl sub_1000DE70(unsigned __int8 *a1)
{
  return sub_1000F4B0(a1, 0, 1u, 1u, 0);
}

//----- (1000DE90) --------------------------------------------------------
unsigned int __cdecl sub_1000DE90(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_1000F200((_BYTE *)(a1 + 6), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_1000F4B0((unsigned __int8 *)(a1 + 12), 0, 0xFFu, 0, a2) == 1 )
    v2 = 1;
  result = sub_1000F200((_BYTE *)a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 2), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 9), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 3), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F340((char *)(a1 + 14), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F4B0((unsigned __int8 *)(a1 + 7), 0, 0x40u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 10), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 5), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 11), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F4B0((unsigned __int8 *)(a1 + 4), 0, 0x40u, 0x30u, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 1), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F340((char *)(a1 + 17), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 24), 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (1000E1C0) --------------------------------------------------------
unsigned int __cdecl sub_1000E1C0(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_1000F200((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 24), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 26), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F340((char *)(a1 + 10), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 31), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 28), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 17), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F340((char *)(a1 + 13), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F340((char *)(a1 + 5), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F340((char *)a1, -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F340((char *)(a1 + 1), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F340((char *)(a1 + 2), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F340((char *)(a1 + 3), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F340((char *)(a1 + 4), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F340((char *)(a1 + 12), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F340((char *)(a1 + 11), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F340((char *)(a1 + 7), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F340((char *)(a1 + 9), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F200((_BYTE *)(a1 + 25), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000F340((char *)(a1 + 6), -31, 31, 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (1000E600) --------------------------------------------------------
unsigned int __cdecl sub_1000E600(_BYTE *a1)
{
  return sub_1000F390(a1, -1, 5, -1, 0);
}

//----- (1000E620) --------------------------------------------------------
int __cdecl sub_1000E620(unsigned __int8 *a1)
{
  return sub_1000F4B0(a1, 0, 5u, 0, 0);
}

//----- (1000E640) --------------------------------------------------------
int __cdecl sub_1000E640(unsigned __int8 *a1)
{
  return sub_1000F4B0(a1, 0, 4u, 2u, 0);
}

//----- (1000E660) --------------------------------------------------------
int __cdecl sub_1000E660(_BYTE *a1)
{
  return sub_1000F5A0(a1, 0, 2u, 0, 0);
}

//----- (1000E680) --------------------------------------------------------
int __cdecl sub_1000E680(int a1)
{
  return sub_1000F250(a1, 0.1, 4.0, COERCE_INT(1.5), 0);
}

//----- (1000E6D0) --------------------------------------------------------
int __cdecl sub_1000E6D0(unsigned __int8 *a1)
{
  int result; // eax@1

  result = sub_1000E680((int)(a1 + 4));
  if ( !result )
    result = sub_1000E640(a1);
  return result;
}

//----- (1000E6F0) --------------------------------------------------------
int __cdecl sub_1000E6F0(int a1)
{
  int result; // eax@1

  result = sub_1000E620((unsigned __int8 *)(a1 + 1));
  if ( !result )
  {
    result = sub_1000E620((unsigned __int8 *)(a1 + 2));
    if ( !result )
    {
      result = sub_1000E620((unsigned __int8 *)(a1 + 3));
      if ( !result )
      {
        result = sub_1001A5C0((unsigned __int8 *)(a1 + 7));
        if ( !result )
        {
          result = sub_1000F200((_BYTE *)(a1 + 5), 0, 0);
          if ( !result )
          {
            result = sub_1000F200((_BYTE *)a1, 0, 0);
            if ( !result )
            {
              result = sub_1000F200((_BYTE *)(a1 + 4), 0, 0);
              if ( !result )
                result = sub_1000F200((_BYTE *)(a1 + 6), 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (1000E780) --------------------------------------------------------
unsigned int __cdecl sub_1000E780(int a1)
{
  unsigned int result; // eax@1

  result = sub_1000E600((_BYTE *)a1);
  if ( !result )
    result = sub_1000E600((_BYTE *)(a1 + 4));
  return result;
}

//----- (1000E7A0) --------------------------------------------------------
signed int __cdecl sub_1000E7A0(int a1)
{
  int v1; // esi@1
  signed int result; // eax@2
  signed int v3; // esi@4

  v1 = 0;
  while ( 1 )
  {
    result = sub_1000F200((_BYTE *)(v1 + a1), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      v3 = 0;
      do
      {
        result = sub_1000F200((_BYTE *)(a1 + v3 + 6), 0, 0);
        if ( result )
          break;
        ++v3;
      }
      while ( v3 < 6 );
      return result;
    }
  }
  return result;
}

//----- (1000E7F0) --------------------------------------------------------
unsigned int __cdecl sub_1000E7F0(int a1)
{
  unsigned int result; // eax@1

  result = sub_1000E600((_BYTE *)a1);
  if ( !result )
  {
    result = sub_1000E600((_BYTE *)(a1 + 4));
    if ( !result )
    {
      result = sub_1000E600((_BYTE *)(a1 + 8));
      if ( !result )
      {
        result = sub_1000E600((_BYTE *)(a1 + 12));
        if ( !result )
          result = sub_1000F200((_BYTE *)(a1 + 16), 1, 0);
      }
    }
  }
  return result;
}

//----- (1000E850) --------------------------------------------------------
int __cdecl sub_1000E850(_BYTE *a1)
{
  return sub_1000F5A0(a1, 0, 0x20u, 2u, 0);
}

//----- (1000E870) --------------------------------------------------------
unsigned int __cdecl sub_1000E870(_BYTE *a1)
{
  return sub_1000F390(a1, -1, 4, -1, 0);
}

//----- (1000E890) --------------------------------------------------------
int __cdecl sub_1000E890(unsigned __int8 *a1)
{
  return sub_1000F4B0(a1, 0, 9u, 0, 0);
}

//----- (1000E8B0) --------------------------------------------------------
int __cdecl sub_1000E8B0(_BYTE *a1)
{
  return sub_1000F5A0(a1, 0x81u, 0xFFu, 0xC0u, 0);
}

//----- (1000E8D0) --------------------------------------------------------
signed int __cdecl sub_1000E8D0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1000F5A0(a1, 0, 0xFFFFFFFF, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (1000E900) --------------------------------------------------------
int __cdecl sub_1000E900(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_1000F500(a1, 0, 0xFFFu, 640, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1000E940) --------------------------------------------------------
int __cdecl sub_1000E940(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@3

  v2 = 0;
  if ( sub_1000E8D0((_BYTE *)(a1 + 8), a2) == 1 )
    v2 = 1;
  result = sub_1000E900((_BYTE *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000E900((_BYTE *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A6E0((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1000E900((_BYTE *)(a1 + 6), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (1000E9D0) --------------------------------------------------------
int __cdecl sub_1000E9D0(int a1)
{
  int result; // eax@1

  result = sub_1000F4B0((unsigned __int8 *)a1, 0, 0x78u, 0, 0);
  if ( !result )
    result = sub_1000F4B0((unsigned __int8 *)(a1 + 1), 0, 0x78u, 0, 0);
  return result;
}

//----- (1000EA00) --------------------------------------------------------
int __cdecl sub_1000EA00(unsigned __int8 *a1)
{
  return sub_1000F4B0(a1, 0, 3u, 1u, 0);
}

//----- (1000EA20) --------------------------------------------------------
unsigned int __cdecl sub_1000EA20(int a1)
{
  unsigned int result; // eax@1

  result = sub_1000F390((_BYTE *)a1, -1, 5, -1, 0);
  if ( !result )
    result = sub_1000F390((_BYTE *)(a1 + 4), -1, 5, -1, 0);
  return result;
}

//----- (1000EA50) --------------------------------------------------------
int __cdecl sub_1000EA50(int a1)
{
  int result; // eax@1

  result = sub_1000F250(a1, 0.0, 5.0, COERCE_INT(0.23), 0);
  if ( !result )
  {
    result = sub_1000F250(a1 + 4, -10.0, 10.0, COERCE_INT(0.0), 0);
    if ( !result )
    {
      result = sub_1000F250(a1 + 8, 0.0, 12.9, COERCE_INT(0.86000001), 0);
      if ( !result )
      {
        result = sub_1000F250(a1 + 12, 0.0, 5.0, COERCE_INT(0.23), 0);
        if ( !result )
          result = sub_1000F250(a1 + 16, -10.0, 10.0, COERCE_INT(0.0), 0);
      }
    }
  }
  return result;
}

//----- (1000EB40) --------------------------------------------------------
int __cdecl sub_1000EB40(int a1)
{
  int v1; // edi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_1000F200((_BYTE *)(a1 + v1 + 44), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      result = sub_1000F4B0((unsigned __int8 *)(a1 + 1), 0, 3u, 1u, 0);
      if ( !result )
      {
        result = sub_1000EA20(a1 + 36);
        if ( !result )
        {
          result = sub_1000F250(a1 + 52, -9.9999996e24, 9.9999996e24, COERCE_INT(77.166664), 0);
          if ( !result )
          {
            result = sub_1000EA50(a1 + 8);
            if ( !result )
            {
              result = sub_1000EA20(a1 + 28);
              if ( !result )
              {
                result = sub_1000F500((_BYTE *)(a1 + 2), 0x1F4u, 0x800u, 600, 0);
                if ( !result )
                {
                  result = sub_1000DE30((unsigned __int8 *)(a1 + 50));
                  if ( !result )
                  {
                    result = sub_1000E9D0(a1 + 57);
                    if ( !result )
                    {
                      result = sub_1000F200((_BYTE *)(a1 + 56), 0, 0);
                      if ( !result )
                        result = sub_1000EA00((unsigned __int8 *)(a1 + 51));
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
  }
  return result;
}

//----- (1000EC50) --------------------------------------------------------
signed int __cdecl sub_1000EC50(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1000F500(a1, 0, 0xFFFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (1000EC80) --------------------------------------------------------
signed int __cdecl sub_1000EC80(unsigned __int8 *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1000F4B0(a1, 0, 0xFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (1000ECB0) --------------------------------------------------------
int __cdecl sub_1000ECB0(unsigned __int8 *a1)
{
  return sub_1000F4B0(a1, 0, 0x64u, 0x64u, 0);
}

//----- (1000ED10) --------------------------------------------------------
int __cdecl sub_1000ED10(int a1)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_1000F200((_BYTE *)(v1 + a1 + 4), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 3 )
      return sub_1000ECB0((unsigned __int8 *)(a1 + 10));
  }
  return result;
}

//----- (1000ED20) --------------------------------------------------------
signed int __cdecl sub_1000ED20(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1000F5A0(a1, 0, 0xFFFFFFFF, 0xFFFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (1000ED50) --------------------------------------------------------
int __cdecl sub_1000ED50(int a1, int a2)
{
  signed int v2; // ebp@1
  unsigned __int8 v3; // bl@1
  int result; // eax@3

  v2 = 0;
  v3 = 0;
  do
  {
    switch ( v3 )
    {
      case 4u:
      case 5u:
      case 6u:
      case 9u:
      case 0xAu:
        result = sub_1000F4B0((unsigned __int8 *)(a1 + v3), 0, 0x3Fu, 0, a2);
        break;
      default:
        result = sub_1000F4B0((unsigned __int8 *)(a1 + v3), 0, 0xFFu, 0xFFu, a2);
        break;
    }
    if ( result == 1 )
    {
      v2 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v3;
  }
  while ( v3 < 0xDu );
  return v2;
}

//----- (1000EDD0) --------------------------------------------------------
unsigned int __cdecl sub_1000EDD0(int a1)
{
  unsigned int result; // eax@1

  result = sub_1000DE10((char *)(a1 + 3));
  if ( !result )
  {
    result = sub_1000DE10((char *)(a1 + 2));
    if ( !result )
    {
      result = sub_1000DE10((char *)a1);
      if ( !result )
        result = sub_1000DE10((char *)(a1 + 1));
    }
  }
  return result;
}

//----- (1000EE10) --------------------------------------------------------
unsigned int __cdecl sub_1000EE10(int a1)
{
  signed int v1; // esi@1
  int v2; // edi@1
  unsigned int result; // eax@2

  v1 = 0;
  v2 = a1;
  while ( 1 )
  {
    result = sub_1000EDD0(v2);
    if ( result )
      break;
    ++v1;
    v2 += 4;
    if ( v1 >= 3 )
    {
      result = sub_1000DE30((unsigned __int8 *)(a1 + 12));
      if ( !result )
        result = sub_1000DE70((unsigned __int8 *)(a1 + 13));
      return result;
    }
  }
  return result;
}

//----- (1000EE60) --------------------------------------------------------
int __cdecl sub_1000EE60(int a1)
{
  int result; // eax@1

  result = sub_1000DE50((_BYTE *)(a1 + 4));
  if ( !result )
    result = sub_1000F500((_BYTE *)a1, 0, 0x3FFFu, 0x3FFF, 0);
  return result;
}

//----- (1000EE90) --------------------------------------------------------
int __cdecl sub_1000EE90(int a1)
{
  int result; // eax@1

  result = sub_1000E660((_BYTE *)a1);
  if ( !result )
    result = sub_1000E8B0((_BYTE *)(a1 + 4));
  return result;
}

//----- (1000EEC0) --------------------------------------------------------
unsigned int __cdecl sub_1000EEC0(int a1)
{
  unsigned int result; // eax@1

  result = sub_1000E600((_BYTE *)a1);
  if ( !result )
  {
    result = sub_1000E600((_BYTE *)(a1 + 4));
    if ( !result )
      result = sub_1000E870((_BYTE *)(a1 + 8));
  }
  return result;
}

//----- (1000EEF0) --------------------------------------------------------
unsigned int __cdecl sub_1000EEF0(int a1)
{
  unsigned int result; // eax@1

  result = sub_1000E600((_BYTE *)a1);
  if ( !result )
    result = sub_1000E890((unsigned __int8 *)(a1 + 4));
  return result;
}

//----- (1000EF10) --------------------------------------------------------
unsigned int __cdecl sub_1000EF10(int a1)
{
  unsigned int result; // eax@1

  result = sub_1000E600((_BYTE *)a1);
  if ( !result )
  {
    result = sub_1000F4B0((unsigned __int8 *)(a1 + 8), 0, 0x1Eu, 0x1Eu, 0);
    if ( !result )
      result = sub_1000E870((_BYTE *)(a1 + 4));
  }
  return result;
}

//----- (1000EF50) --------------------------------------------------------
void __cdecl __noreturn sub_1000EF50(int a1)
{
  exit(a1 + 4);
}

//----- (1000F0C0) --------------------------------------------------------
signed int __cdecl sub_1000F0C0(int a1, int a2)
{
  signed int v2; // ebx@1
  bool v3; // zf@5
  signed int result; // eax@5

  v2 = 0;
  if ( sub_1000EC80((unsigned __int8 *)a1, a2) == 1 )
    v2 = 1;
  if ( sub_1000EC50((_BYTE *)(a1 + 2), a2) == 1 )
    v2 = 1;
  v3 = sub_1000EC80((unsigned __int8 *)(a1 + 1), a2) == 1;
  result = 1;
  if ( !v3 )
    result = v2;
  return result;
}

//----- (1000F120) --------------------------------------------------------
signed int __usercall sub_1000F120@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  signed int v3; // ebx@1
  char v4; // al@5
  signed int result; // eax@8
  int v6; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  if ( sub_1000F0C0(a1, v6) == 1 )
    v3 = 1;
  if ( a2 == 2 )
  {
    *(_BYTE *)(v2 + 1) = 40;
    v3 = 1;
  }
  v4 = *(_BYTE *)(v2 + 1);
  if ( v4 == 26 || v4 == 12 )
  {
    result = sub_1000F4B0((unsigned __int8 *)(v2 + 4), 0x20u, 0x20u, 0x20u, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    result = sub_1000F200((_BYTE *)(v2 + 37), 0, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    if ( *(_BYTE *)(v2 + 1) == 26 )
      result = sub_1000E1C0(v2 + 5, a2);
    else
      result = sub_1000DE90(v2 + 5, a2);
    if ( result != 1 )
    {
      if ( result )
        return result;
      goto LABEL_25;
    }
    return 1;
  }
  if ( v4 != 40 )
  {
    if ( a2 != 1 )
      return -4;
    *(_BYTE *)(v2 + 1) = 40;
    return 1;
  }
  result = sub_1000ED20((_BYTE *)(v2 + 4), a2);
  if ( result != 1 )
LABEL_25:
    result = v3;
  return result;
}

//----- (1000F1F0) --------------------------------------------------------
signed int __cdecl sub_1000F1F0(int a1)
{
  return sub_1000F120(a1, 0);
}

//----- (1000F200) --------------------------------------------------------
signed int __cdecl sub_1000F200(_BYTE *a1, char a2, int a3)
{
  signed int result; // eax@1

  result = -4;
  if ( a3 && a3 != 1 || (!*a1 || *a1 == 1 ? (result = 0) : (result = -2), a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_11;
  }
  if ( result )
  {
LABEL_11:
    *a1 = a2;
    result = 1;
  }
  return result;
}

//----- (1000F250) --------------------------------------------------------
int __cdecl sub_1000F250(int a1, float a2, float a3, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  char v7; // dl@4
  char v8; // al@4
  char v9; // dl@4
  int result; // eax@5
  double v11; // st7@7
  unsigned int v12; // eax@21

  v5 = a1;
  v6 = a1 & 3;
  if ( a1 & 3 || (unsigned int)&a1 & 3 )
  {
    v7 = *(_BYTE *)(a1 + 1);
    LOBYTE(a1) = *(_BYTE *)a1;
    v8 = *(_BYTE *)(v5 + 2);
    BYTE1(a1) = v7;
    v9 = *(_BYTE *)(v5 + 3);
    BYTE2(a1) = v8;
    BYTE3(a1) = v9;
  }
  else
  {
    a1 = *(int *)a1;
  }
  result = -4;
  if ( a5 && a5 != 1
    || ((v11 = *(float *)&a1, (a1 & 0x7F800000) != 2139095040) ? (a2 <= v11 ? (a3 >= v11 ? (result = 0) : (result = -2)) : (result = -1)) : (result = -3),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v12 = a4;
    *(_BYTE *)(v5 + 1) = BYTE1(a4);
    *(_BYTE *)v5 = v12;
    *(_BYTE *)(v5 + 3) = BYTE3(v12);
    *(_BYTE *)(v5 + 2) = v12 >> 16;
    result = 1;
  }
  else
  {
    *(_DWORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (1000F340) --------------------------------------------------------
unsigned int __cdecl sub_1000F340(char *a1, char a2, char a3, char a4, int a5)
{
  char v5; // dl@1
  unsigned int result; // eax@1
  int v7; // eax@5

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1
    || (v5 >= a2 ? (v7 = v5 < a3, LOBYTE(v7) = v5 <= a3, result = (v7 - 1) & 0xFFFFFFFE) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (1000F390) --------------------------------------------------------
unsigned int __cdecl sub_1000F390(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  _BYTE *v8; // esi@3
  int v9; // eax@9
  signed int v10; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((signed int)v8 >= a2 ? (v9 = (signed int)v8 < a3,
                                LOBYTE(v9) = (signed int)v8 <= a3,
                                result = (v9 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v10 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v10;
    v5[3] = BYTE3(v10);
    v5[2] = v10 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (1000F450) --------------------------------------------------------
unsigned int __cdecl sub_1000F450(void *a1, size_t a2, int a3)
{
  unsigned int result; // eax@1
  int v4; // eax@3
  int v5; // ecx@3
  unsigned int v6; // ecx@3

  result = -4;
  if ( a3 && a3 != 1
    || (v4 = sub_1000D470(a1, a2), v5 = v4 < 0, LOBYTE(v5) = v4 >= 0, v6 = (v5 - 1) & 0xFFFFFFFC, result = v6, a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_7;
  }
  if ( v6 )
  {
LABEL_7:
    memset(a1, 0, a2);
    result = 1;
  }
  return result;
}

//----- (1000F4B0) --------------------------------------------------------
int __cdecl sub_1000F4B0(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
  unsigned __int8 v5; // dl@1
  int result; // eax@1

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1 || (v5 >= a2 ? (result = a3 < v5 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (1000F500) --------------------------------------------------------
int __cdecl sub_1000F500(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // esi@1
  int result; // eax@1
  char v8; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned __int16)a1 >= a2 ? (result = a3 < (unsigned __int16)a1 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v8 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v8;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (1000F5A0) --------------------------------------------------------
int __cdecl sub_1000F5A0(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  int result; // eax@1
  _BYTE *v8; // esi@3
  unsigned int v9; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned int)v8 >= a2 ? (result = a3 < (unsigned int)v8 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v9 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v9;
    v5[3] = BYTE3(v9);
    v5[2] = v9 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (1000F650) --------------------------------------------------------
char __cdecl sub_1000F650(unsigned __int16 a1, _BYTE *a2, _WORD *a3)
{
  char result; // al@4

  if ( a1 < 0x1D8u && a2 && a3 )
  {
    *a2 = byte_10058B10[4 * a1];
    *a3 = word_10058B12[2 * a1];
    result = 1;
  }
  else
  {
    sub_10009550("..\\lib\\adl\\iop_eau_data_tbl.c", 614, 0, 0);
    result = 0;
  }
  return result;
}
// 10058B12: using guessed type __int16 word_10058B12[];

//----- (1000F6B0) --------------------------------------------------------
double __cdecl sub_1000F6B0(float a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@2
  double result; // st7@4
  float v5; // [sp+8h] [bp+4h]@4
  float v6; // [sp+8h] [bp+4h]@5
  float v7; // [sp+8h] [bp+4h]@6
  float v8; // [sp+8h] [bp+4h]@7

  v2 = (unsigned __int8)sub_10009E50(v1);
  if ( (_BYTE)v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        v6 = (float)778.90802 * a1;
        result = v6;
      }
      else
      {
        v5 = (float)850.76703 * a1;
        result = v5;
      }
    }
    else
    {
      v7 = (float)804.0722 * a1;
      result = v7;
    }
  }
  else
  {
    v8 = (float)718.95856 * a1;
    result = v8;
  }
  return result;
}

//----- (1000F730) --------------------------------------------------------
char __cdecl sub_1000F730(char *a1)
{
  int v1; // ecx@0
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  sub_10009EF0(13, (char *)&v3 + 3);
  sub_10009EF0(12, a1);
  return BYTE3(v3);
}

//----- (1000F760) --------------------------------------------------------
char *__cdecl sub_1000F760(char **a1)
{
  char *v1; // edx@1
  int v2; // edi@1
  char *result; // eax@1
  char *v4; // eax@3
  char v5; // cl@4
  int v6; // eax@5
  char v7; // cl@7

  v1 = *a1;
  v2 = 0;
  result = (char *)&unk_10047869;
  if ( *a1 && *v1 )
  {
    v4 = *a1;
    do
      v5 = *v4++;
    while ( v5 );
    v6 = v4 - (v1 + 1) - 1;
    do
    {
      if ( v6 < 0 )
        break;
      v7 = v1[v6];
      if ( v7 == 47 || v7 == 92 )
        v2 = v6 + 1;
      --v6;
    }
    while ( !v2 );
    result = &v1[v2];
  }
  return result;
}

//----- (1000F7B0) --------------------------------------------------------
int sub_1000F7B0()
{
  int v0; // esi@1
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@2

  v0 = 0;
  v1 = sub_10024750();
  result = 0;
  while ( 1 )
  {
    v3 = dword_100C9E44[result];
    if ( v3 == v1 )
      break;
    if ( !v0 && v3 == -1 )
      v0 = result;
    if ( (unsigned int)++result >= 5 )
    {
      dword_100C9E44[v0] = v1;
      return v0;
    }
  }
  return result;
}
// 100C9E44: using guessed type int dword_100C9E44[];

//----- (1000F7F0) --------------------------------------------------------
int __cdecl sub_1000F7F0(_BYTE *a1, int a2)
{
  int result; // eax@3
  int v3; // esi@3
  _BYTE *v4; // ecx@4
  char v5; // dl@5

  if ( a1 )
  {
    if ( a2 )
    {
      result = 0;
      v3 = 0;
      if ( *a1 )
      {
        v4 = a1;
        do
        {
          v5 = v4[a2 - (_DWORD)a1];
          if ( !v5 )
            break;
          if ( *v4 != v5 )
          {
            result = a1[v3] - *(_BYTE *)(v3 + a2);
            if ( a1[v3] != *(_BYTE *)(v3 + a2) )
              return result;
            break;
          }
          ++v4;
          ++v3;
        }
        while ( *v4 );
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(v3 + a2) )
      {
        result = -1;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1000F860) --------------------------------------------------------
signed int __cdecl sub_1000F860(_BYTE *a1, int a2)
{
  _BYTE *v2; // esi@1
  int v3; // ebp@1
  int v4; // ebx@4
  int v5; // edi@6
  int v6; // eax@6
  signed int result; // eax@11
  int v8; // [sp+8h] [bp-4h]@3

  v2 = a1;
  v3 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v8 = 0;
      if ( *a1 )
      {
        v4 = a2 - (_DWORD)a1;
        while ( v2[v4] )
        {
          v5 = tolower(*v2);
          v6 = tolower(v2[v4]);
          if ( v5 != v6 )
          {
            v8 = v5 - v6;
            if ( v5 != v6 )
              goto LABEL_16;
            break;
          }
          ++v2;
          ++v3;
          if ( !*v2 )
            break;
        }
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(a2 + v3) )
      {
        result = -1;
      }
      else
      {
LABEL_16:
        result = v8;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1000F900) --------------------------------------------------------
int __usercall sub_1000F900@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>)
{
  int result; // eax@5

  if ( a1 && *a1 )
  {
    if ( a2 && *a2 )
      result = 3 - (sub_1000F860(a2, (int)a1) != 0);
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000F930) --------------------------------------------------------
signed int __usercall sub_1000F930@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5)
{
  int v5; // ebp@1
  int v6; // edi@1
  signed int result; // eax@2
  const char *v8; // [sp-8h] [bp-18h]@11
  int v9; // [sp-4h] [bp-14h]@11
  int v10; // [sp+8h] [bp-8h]@14
  int v11; // [sp+Ch] [bp-4h]@17
  signed int v12; // [sp+14h] [bp+4h]@3

  v5 = a4;
  v6 = 0;
  *(_DWORD *)a4 = a1;
  switch ( a1 )
  {
    case 0:
      sprintf(a5, "Too many arguments for command");
      result = 8;
      break;
    case 1:
      v12 = 9;
      while ( sub_1000F860((_BYTE *)a3, (int)(&off_1005A300)[8 * v6]) )
      {
        if ( (unsigned int)++v6 >= 0xD )
        {
          sprintf(a5, "Error converting '%s' to a boolean", a3);
          goto LABEL_25;
        }
      }
      ++*a2;
      result = 0;
      *(_BYTE *)(v5 + 4) = byte_1005A304[8 * v6];
      break;
    case 2:
      if ( !*(_BYTE *)a3 || *(_BYTE *)(a3 + 1) )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a char";
        goto LABEL_12;
      }
      *(_BYTE *)(a4 + 4) = *(_BYTE *)a3;
      result = 0;
      break;
    case 3:
      if ( sub_10027BD2(a3, (int)"%ld", (unsigned int)&v10) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a sint32";
        goto LABEL_12;
      }
      *(_DWORD *)(a4 + 4) = v10;
      ++*a2;
      result = 0;
      break;
    case 4:
      if ( sub_10027BD2(a3, (int)"%lu", (unsigned int)&v11) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a uint32";
LABEL_12:
        sprintf(a5, v8, v9);
        goto LABEL_13;
      }
      *(_DWORD *)(a4 + 4) = v11;
      ++*a2;
      result = 0;
      break;
    case 6:
      if ( sub_10027BD2(a3, (int)"%f", a4 + 4) == 1 )
        goto LABEL_23;
      sprintf(a5, "Error converting '%s' to a float", a3);
LABEL_13:
      result = 9;
      break;
    case 5:
      strncpy((char *)(a4 + 4), (const char *)a3, 0x50u);
LABEL_23:
      ++*a2;
      result = 0;
      break;
    default:
      v12 = 9;
      *(_DWORD *)v5 = 0;
      sprintf(a5, "Command definition error: Unsupported argument type (%d)", a1);
LABEL_25:
      result = v12;
      break;
  }
  return result;
}
// 1005A300: using guessed type char *off_1005A300;

//----- (1000FB00) --------------------------------------------------------
char *__usercall sub_1000FB00@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>)
{
  if ( a2 )
  {
    if ( (_BYTE)result && *(_BYTE *)a3 )
    {
      if ( *a2 )
      {
        strncat((char *)a3, " ", 0x100u);
        result = strncat((char *)a3, a2, 0x100u);
        *(_BYTE *)(a3 + 255) = 0;
        return result;
      }
    }
    else
    {
      result = strncpy((char *)a3, a2, 0x100u);
    }
    *(_BYTE *)(a3 + 255) = 0;
  }
  else if ( !(_BYTE)result )
  {
    *(_BYTE *)a3 = 0;
  }
  return result;
}

//----- (1000FB60) --------------------------------------------------------
int __usercall sub_1000FB60@<eax>(int a1@<esi>, int a2, _DWORD *a3)
{
  unsigned int v3; // edi@4
  int v4; // ebx@5
  int v5; // eax@6
  int result; // eax@9
  int v7; // ecx@10

  if ( a1 && *(_DWORD *)(a1 + 8) && *(_BYTE *)(80 * *a3 + a2) )
  {
    v3 = 0;
    if ( *(_DWORD *)(a1 + 12) <= 0u )
    {
      result = 0;
    }
    else
    {
      v4 = 0;
      while ( 1 )
      {
        v5 = v4 + *(_DWORD *)(a1 + 8);
        if ( *(_DWORD *)(v5 + 12) < 2u && !sub_1000F860((_BYTE *)(a2 + 80 * *a3), *(_DWORD *)v5) )
          break;
        ++v3;
        v4 += 40;
        if ( v3 >= *(_DWORD *)(a1 + 12) )
          return 0;
      }
      v7 = *(_DWORD *)(a1 + 8);
      ++*a3;
      result = v7 + 40 * v3;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000FBF0) --------------------------------------------------------
int __usercall sub_1000FBF0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4)
{
  int v4; // edi@1
  unsigned int v5; // ebp@1
  int v6; // esi@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  do
  {
    if ( v5 >= a3 )
      break;
    if ( *(_DWORD *)(v6 + 12) >= 2u && sub_1000F900(*(_BYTE **)v6, (_BYTE *)(a4 + 80 * *a2)) == 3 )
    {
      ++*a2;
      v4 = v6;
    }
    ++v5;
    v6 += 40;
  }
  while ( !v4 );
  return v4;
}

//----- (1000FC40) --------------------------------------------------------
char **__usercall sub_1000FC40@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3)
{
  char **result; // eax@1
  int v4; // edi@1
  int (**v5)(void); // eax@2
  char **v6; // eax@3
  char **v7; // esi@3
  char *v8; // eax@3

  result = 0;
  v4 = 0;
  if ( *a1 )
  {
    v5 = a1;
    while ( 1 )
    {
      v6 = (char **)(*v5)();
      v7 = v6;
      v8 = sub_1000F760(v6);
      if ( !sub_1000F860((_BYTE *)(a2 + 80 * *a3), (int)v8) )
        break;
      v5 = &a1[++v4];
      if ( !a1[v4] )
        return 0;
    }
    ++*a3;
    result = v7;
  }
  return result;
}

//----- (1000FCA0) --------------------------------------------------------
const char *__usercall sub_1000FCA0@<eax>(int a1@<eax>)
{
  const char *result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
      result = "Group";
    else
      result = "Command";
  }
  else
  {
    result = "Case";
  }
  return result;
}

//----- (1000FCC0) --------------------------------------------------------
int __usercall sub_1000FCC0@<eax>(unsigned int a1@<ebx>)
{
  int (**v1)(void); // esi@1
  unsigned int v2; // edi@1
  int result; // eax@4

  v1 = (int (**)(void))dword_100C9E30[sub_1000F7B0()];
  v2 = 0;
  if ( a1 )
  {
    while ( v1 && *v1 )
    {
      result = (*v1)();
      ++v2;
      ++v1;
      if ( v2 >= a1 )
        return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100C9E30: using guessed type int dword_100C9E30[];

//----- (1000FD00) --------------------------------------------------------
int __usercall sub_1000FD00@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5)
{
  signed int *v5; // ebx@1
  int result; // eax@1
  _DWORD *v7; // edi@2
  int *v8; // ebp@2
  _BYTE *v9; // esi@4
  signed int v10; // ebx@9
  signed int v11; // [sp+8h] [bp-4h]@2

  v5 = a1;
  result = 0;
  if ( a3 )
  {
    v7 = a2;
    v8 = (int *)(a3 + 16);
    v11 = 5;
    do
    {
      if ( result || (v9 = (_BYTE *)(80 * *v5 + a4), !*v9) )
        *v7 = 0;
      else
        result = sub_1000F930(*v8, v5, (int)v9, (int)v7, a5);
      ++v8;
      v7 += 21;
      --v11;
    }
    while ( v11 );
    if ( !result )
    {
      v10 = *v5;
      if ( v10 < 5 )
      {
        if ( *(_DWORD *)(a3 + 4 * v10 + 16) )
        {
          sprintf(a5, "Missing required command argument");
          result = 7;
        }
      }
    }
  }
  return result;
}

//----- (1000FD90) --------------------------------------------------------
int __usercall sub_1000FD90@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4)
{
  int v4; // ebx@1
  signed int v5; // edx@1
  _BYTE *v6; // edi@1
  signed int v7; // ebp@1
  signed int v8; // ecx@1
  int v9; // ecx@3
  char v10; // al@4
  signed int v11; // edi@21
  int result; // eax@27
  char v13; // [sp+Fh] [bp-9h]@1
  signed int v14; // [sp+10h] [bp-8h]@1
  int v15; // [sp+14h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  v14 = 3;
  v15 = 0;
  v7 = 0;
  v13 = 0;
  *a2 = 0;
  v8 = 9;
  do
  {
    *a1 = 0;
    a1 += 80;
    --v8;
  }
  while ( v8 );
  v9 = a3;
  if ( !*(_BYTE *)a3 )
    return 3;
  while ( 1 )
  {
    v10 = *(_BYTE *)(v4 + v9);
    if ( v13 )
    {
      if ( v13 != v10 )
        goto LABEL_15;
      v13 = 0;
LABEL_18:
      v9 = a3;
      goto LABEL_19;
    }
    if ( v10 != 34 && v10 != 39 )
      break;
    v13 = *(_BYTE *)(v4 + v9);
LABEL_19:
    if ( !*(_BYTE *)(++v4 + v9) )
      goto LABEL_23;
  }
  if ( v10 == 32 || v10 == 9 )
  {
    if ( v7 )
    {
      ++*a2;
      v7 = 0;
      v5 = 0;
    }
    v15 = v4;
    goto LABEL_19;
  }
LABEL_15:
  if ( *a2 >= 8 )
  {
    v11 = 5;
    sprintf(a4, "Too many parameters. Maximum of %d parameters supported.", 8);
    goto LABEL_24;
  }
  if ( v5 < 80 )
  {
    *(&v6[80 * *a2] + v5) = v10;
    v7 = 1;
    ++v5;
    v14 = 0;
    *(&v6[80 * *a2] + v5) = 0;
    goto LABEL_18;
  }
  v14 = 6;
  sprintf(a4, "Parameter too long (starting at %s). Maximum parameter length supported is %d.", v15 + a3 + 1, 80);
LABEL_23:
  v11 = v14;
LABEL_24:
  if ( v7 )
  {
    if ( !v13 )
    {
      ++*a2;
      goto LABEL_27;
    }
    sprintf(a4, "Parameter %d missing closing quote", *a2);
    result = 6;
  }
  else
  {
LABEL_27:
    result = v11;
  }
  return result;
}

//----- (1000FEE0) --------------------------------------------------------
int __usercall sub_1000FEE0@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>)
{
  _DWORD *v3; // edi@1
  int result; // eax@1
  int v5; // ecx@2
  int v6; // eax@4
  int v7; // edi@4
  int v8; // edi@7

  v3 = a1;
  result = 0;
  if ( a3 )
  {
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        sub_10011C30(5, *(_DWORD *)a3);
        v6 = (*(int (**)(void))(a3 + 8))();
        sub_100107C0(v3, v6, 0);
        v7 = -*v3;
        sub_10011C30(9, *(_DWORD *)a3);
        result = v7;
      }
    }
    else
    {
      sub_10011C30(6, *(_DWORD *)a3);
      if ( a2 )
        a2(5, &unk_10059FB8);
      sub_1001A8D0(a3);
      v8 = -*v3;
      if ( a2 )
        a2(6, &unk_10059FB8);
      sub_10011C30(8, *(_DWORD *)a3);
      result = v8;
    }
  }
  return result;
}

//----- (1000FF80) --------------------------------------------------------
int __usercall sub_1000FF80@<eax>(int result@<eax>)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_BYTE *)(result + 33) = 0;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 24) = 1;
  *(_BYTE *)(result + 32) = 1;
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 52) = 0;
  return result;
}

//----- (1000FFC0) --------------------------------------------------------
char *__cdecl sub_1000FFC0(int a1, char *a2, int a3, const char *a4)
{
  const char *v4; // ecx@0
  const char *v5; // ebx@1
  char *v6; // eax@1
  char *v7; // ecx@1
  char *result; // eax@3
  char *v9; // eax@5
  const char *v10; // edi@5
  const char **v11; // ebx@8
  char *v12; // eax@10
  const char *v13; // edi@10
  char **v14; // ebp@10
  const char *v15; // edi@12
  char *v16; // [sp+10h] [bp-624h]@8
  signed int v17; // [sp+14h] [bp-620h]@10
  int v18[6]; // [sp+18h] [bp-61Ch]@2
  char v19; // [sp+30h] [bp-604h]@1
  char v20; // [sp+130h] [bp-504h]@5
  char v21; // [sp+230h] [bp-404h]@7
  char v22; // [sp+330h] [bp-304h]@10
  char v23; // [sp+430h] [bp-204h]@10
  char v24; // [sp+530h] [bp-104h]@10

  v5 = v4;
  v6 = 0;
  v7 = &v19;
  do
  {
    v18[(signed int)v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( (unsigned int)v6 < 6 );
  LOBYTE(v6) = 0;
  result = sub_1000FB00(v6, "command", (int)&v19);
  if ( a3 )
  {
    LOBYTE(result) = 0;
    if ( a4 )
    {
      v9 = sub_1000FB00(result, a4, (int)&v20);
      v10 = v5;
    }
    else
    {
      v9 = sub_1000FB00(result, v5, (int)&v20);
      v10 = (const char *)&unk_10047869;
    }
    LOBYTE(v9) = 0;
    sub_1000FB00(v9, v10, (int)&v21);
    result = a2;
    if ( a2 )
    {
      v11 = (const char **)(a1 + 36);
      v16 = a2;
      do
      {
        if ( (unsigned int)*(v11 - 6) >= 2 )
        {
          LOBYTE(result) = 0;
          v12 = sub_1000FB00(result, *v11, (int)&v24);
          v13 = *(v11 - 9);
          LOBYTE(v12) = 1;
          v22 = 0;
          sub_1000FB00(v12, v13, (int)&v22);
          v23 = 0;
          v14 = (char **)(v11 - 5);
          v17 = 5;
          do
          {
            switch ( *v14 )
            {
              case 1u:
                v15 = "<bool>";
                goto LABEL_19;
              case 2u:
                v15 = "<char>";
                goto LABEL_19;
              case 3u:
                v15 = "<sint32>";
                goto LABEL_19;
              case 4u:
                v15 = "<uint32>";
                goto LABEL_19;
              case 6u:
                v15 = "<float>";
                goto LABEL_19;
              case 5u:
                v15 = "<str>";
                goto LABEL_19;
              case 0u:
                break;
              default:
                v15 = "<*?*>";
LABEL_19:
                sub_1000FB00(*v14, v15, (int)&v23);
                break;
            }
            ++v14;
            --v17;
          }
          while ( v17 );
          result = (char *)sub_10011BC0(2, (int)v18, 6);
        }
        v11 += 10;
        --v16;
      }
      while ( v16 );
    }
  }
  return result;
}
// 1000FFC0: using guessed type int var_61C[6];

//----- (10010170) --------------------------------------------------------
int __usercall sub_10010170@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ST08_4@1
  char *v3; // eax@1
  int result; // eax@1
  int (__cdecl *v5)(signed int, void *); // esi@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = sub_1000F760((char **)a1);
  result = sub_10011C50(4, (int)v3, v2);
  v5 = *(int (__cdecl **)(signed int, void *))(v1 + 16);
  if ( v5 )
    result = v5(4, &unk_10059FB8);
  return result;
}

//----- (100101A0) --------------------------------------------------------
int __usercall sub_100101A0@<eax>(int a1@<esi>)
{
  void (__cdecl *v1)(signed int, void *); // eax@1
  char v2; // al@3

  v1 = *(void (__cdecl **)(signed int, void *))(a1 + 16);
  if ( v1 )
    v1(7, &unk_10059FB8);
  v2 = (unsigned int)sub_1000F760((char **)a1);
  return sub_10011C30(10, v2);
}

//----- (100101D0) --------------------------------------------------------
void __cdecl sub_100101D0(int (**a1)(void), char **a2, _DWORD *a3)
{
  int v3; // esi@3
  int (**v4)(void); // ebx@4
  char **v5; // eax@6
  char *v6; // ST1C_4@6
  char *v7; // eax@6
  char *v8; // eax@7
  char *v9; // eax@9
  char *v10; // eax@10
  int v11; // ebp@12
  signed int v12; // ebx@12
  const char *v13; // eax@14
  char *v14; // ST18_4@14
  int v15; // ST14_4@14
  char *v16; // eax@14
  int v17; // ecx@18
  unsigned int v18; // eax@18
  int v19; // eax@20
  int v20; // ecx@20
  char v21; // dl@20
  int v22; // ST14_4@30
  char *v23; // ST10_4@30
  const char *v24; // eax@31
  char *v25; // ST18_4@31
  int v26; // ST14_4@31
  char *v27; // ST10_4@31
  int v28; // edx@34
  int v29; // ecx@34
  int v30; // eax@34
  int v31; // ST14_4@37
  char *v32; // eax@37
  int v33; // eax@38
  int v34; // ST14_4@39
  char *v35; // ST10_4@39
  int v36; // ST14_4@41
  char *v37; // eax@41
  int v38; // eax@42
  int v39; // ST14_4@43
  char *v40; // eax@43
  int v41; // ST14_4@45
  char *v42; // eax@45
  int v43; // ST14_4@48
  char *v44; // eax@48
  int v45; // edx@49
  int v46; // ST14_4@50
  char *v47; // ST10_4@50
  char *v48; // eax@54
  unsigned int v49; // [sp+4h] [bp-8h]@12
  unsigned int v50; // [sp+8h] [bp-4h]@15
  int v51; // [sp+10h] [bp+4h]@16

  if ( a1 )
  {
    if ( *a1 )
    {
      v3 = (*a1)();
      if ( !a2 )
      {
        v4 = a1 + 1;
        if ( a1 != (int (**)(void))-4 )
        {
          do
          {
            if ( !*v4 )
              break;
            v5 = (char **)(*v4)();
            v6 = sub_1000F760(v5);
            v7 = sub_1000F760((char **)v3);
            if ( !sub_1000F7F0(v7, (int)v6) )
            {
              v8 = sub_1000F760((char **)v3);
              sub_10011CF0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"2872",
                (int)v8,
                (int)"Suite name has been used more than once");
              *a3 = 12;
            }
            ++v4;
          }
          while ( v4 );
        }
      }
      v9 = sub_1000F760((char **)v3);
      if ( strchr(v9, 32) )
      {
        v10 = sub_1000F760((char **)v3);
        sub_10011CF0(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"2903",
          (int)v10,
          (int)"Suite name includes spaces so it must be quoted");
        *a3 = 10;
      }
      if ( *(_DWORD *)(v3 + 12) )
      {
        v11 = 0;
        v49 = 1;
        v12 = 20;
        while ( 1 )
        {
          if ( strchr(*(const char **)(*(_DWORD *)(v3 + 8) + v11), 32) )
          {
            v13 = sub_1000FCA0(*(_DWORD *)(*(_DWORD *)(v3 + 8) + v11 + 12));
            v14 = sub_10012710("%s name includes spaces so it must be quoted", v13);
            v15 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
            v16 = sub_1000F760((char **)v3);
            sub_10011D30(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_runner.c", (int)"2915", (int)v16, v15, (int)v14);
            *a3 = 10;
          }
          v50 = v49;
          if ( v49 < *(_DWORD *)(v3 + 12) )
          {
            v51 = v11 + 40;
            do
            {
              if ( !sub_1000F7F0(*(_BYTE **)(*(_DWORD *)(v3 + 8) + v11), *(_DWORD *)(v51 + *(_DWORD *)(v3 + 8))) )
              {
                v17 = *(_DWORD *)(v3 + 8);
                v18 = *(_DWORD *)(v17 + v11 + 12);
                if ( v18 < 2 || *(_DWORD *)(v51 + v17 + 12) < 2u )
                {
                  v24 = sub_1000FCA0(v18);
                  v25 = sub_10012710("%s name has been used more than once", v24);
                  v26 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
                  v27 = sub_1000F760((char **)v3);
                  sub_10011D30(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2958",
                    (int)v27,
                    v26,
                    (int)v25);
                }
                else
                {
                  v19 = *(_DWORD *)(v3 + 8);
                  v20 = *(_DWORD *)(v51 + v17 + 16);
                  v21 = 0;
                  if ( *(_DWORD *)(v12 + v19 - 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 8) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 12) != v20 || v21 )
                    goto LABEL_33;
                  v22 = *(_DWORD *)(v19 + v11);
                  v23 = sub_1000F760((char **)v3);
                  sub_10011D30(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2946",
                    (int)v23,
                    v22,
                    (int)"Command name has been used more than once");
                }
                *a3 = 12;
              }
LABEL_33:
              v51 += 40;
              ++v50;
            }
            while ( v50 < *(_DWORD *)(v3 + 12) );
          }
          v28 = *(_DWORD *)(v3 + 8);
          v29 = *(_DWORD *)(v28 + v11 + 12);
          v30 = v28 + v11;
          if ( !v29 )
            break;
          if ( v29 == 1 )
          {
            if ( !*(_DWORD *)(v30 + 8) )
            {
              v36 = *(_DWORD *)v30;
              v37 = sub_1000F760((char **)v3);
              sub_10011D30(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3047",
                (int)v37,
                v36,
                (int)"Test group has a NULL function pointer or a command uses a reserved ID");
              *a3 = 12;
            }
            v38 = *(_DWORD *)(v3 + 8) + v11;
            if ( *(_DWORD *)(v38 + 4) )
            {
              v39 = *(_DWORD *)v38;
              v40 = sub_1000F760((char **)v3);
              sub_10011D30(
                3,
                (int)"**Warning**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3058",
                (int)v40,
                v39,
                (int)"Test group has a non-NULL test case function pointer");
              *a3 = 10;
            }
            if ( a2 )
            {
              v41 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
              v42 = sub_1000F760((char **)v3);
              sub_10011D30(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3070",
                (int)v42,
                v41,
                (int)"Test group contains a test group");
              *a3 = 12;
            }
            else
            {
              sub_100101D0(*(_DWORD *)(v3 + 8) + v11 + 8, v3, a3);
            }
            goto LABEL_52;
          }
          if ( *(_DWORD *)(v30 + 4) )
          {
            v31 = *(_DWORD *)v30;
            v32 = sub_1000F760((char **)v3);
            sub_10011D30(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3088",
              (int)v32,
              v31,
              (int)"Command include a non-NULL test case function pointer");
            *a3 = 10;
          }
          v33 = *(_DWORD *)(v3 + 8) + v11;
          if ( *(_DWORD *)(v33 + 8) )
          {
            v34 = *(_DWORD *)v33;
            v35 = sub_1000F760((char **)v3);
            sub_10011D30(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3099",
              (int)v35,
              v34,
              (int)"Command include a non-NULL test group function pointer");
LABEL_51:
            *a3 = 10;
          }
LABEL_52:
          ++v49;
          v12 += 40;
          v11 += 40;
          if ( v49 - 1 >= *(_DWORD *)(v3 + 12) )
            return;
        }
        if ( !*(_DWORD *)(v30 + 4) )
        {
          v43 = *(_DWORD *)v30;
          v44 = sub_1000F760((char **)v3);
          sub_10011D30(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"3022",
            (int)v44,
            v43,
            (int)"Test case has a NULL function pointer or a command uses a reserved ID");
          *a3 = 12;
        }
        v45 = *(_DWORD *)(v3 + 8);
        if ( !*(_DWORD *)(v45 + v11 + 8) )
          goto LABEL_52;
        v46 = *(_DWORD *)(v45 + v11);
        v47 = sub_1000F760((char **)v3);
        sub_10011D30(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"3033",
          (int)v47,
          v46,
          (int)"Test case has a non-NULL group function pointer");
        goto LABEL_51;
      }
    }
    else
    {
      v48 = sub_1000F760(a2);
      sub_10011CF0(
        3,
        (int)"**Error**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"3114",
        (int)v48,
        (int)"Test suite has a NULL function pointer or a command uses a reserved ID");
      *a3 = 12;
    }
  }
}

//----- (10010640) --------------------------------------------------------
int sub_10010640()
{
  int (**i)(void); // esi@1
  int v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  for ( i = (int (**)(void))dword_100C9E30[sub_1000F7B0()]; i; ++i )
  {
    if ( !*i )
      break;
    sub_100101D0(i, 0, &v2);
  }
  return v2;
}
// 100C9E30: using guessed type int dword_100C9E30[];

//----- (10010690) --------------------------------------------------------
void *sub_10010690()
{
  void *result; // eax@1
  signed int v1; // esi@1

  dword_100C9E30[0] = 0;
  dword_100C9E34 = 0;
  dword_100C9E38 = 0;
  dword_100C9E3C = 0;
  dword_100C9E40 = 0;
  result = &unk_100C9E58;
  dword_100C9E44[0] = -1;
  dword_100C9E48 = -1;
  dword_100C9E4C = -1;
  dword_100C9E50 = -1;
  dword_100C9E54 = -1;
  v1 = 5;
  do
  {
    result = (void *)(sub_1000FF80((int)result) + 56);
    --v1;
  }
  while ( v1 );
  return result;
}
// 100C9E30: using guessed type int dword_100C9E30[];
// 100C9E34: using guessed type int dword_100C9E34;
// 100C9E38: using guessed type int dword_100C9E38;
// 100C9E3C: using guessed type int dword_100C9E3C;
// 100C9E40: using guessed type int dword_100C9E40;
// 100C9E44: using guessed type int dword_100C9E44[];
// 100C9E48: using guessed type int dword_100C9E48;
// 100C9E4C: using guessed type int dword_100C9E4C;
// 100C9E50: using guessed type int dword_100C9E50;
// 100C9E54: using guessed type int dword_100C9E54;

//----- (100106F0) --------------------------------------------------------
char *sub_100106F0()
{
  return (char *)&unk_100C9E58 + 56 * sub_1000F7B0();
}

//----- (10010710) --------------------------------------------------------
char sub_10010710()
{
  return sub_100106F0()[33];
}

//----- (10010720) --------------------------------------------------------
char __cdecl sub_10010720(int a1, int a2, unsigned int a3)
{
  char *v3; // esi@1
  char result; // al@1

  v3 = sub_100106F0();
  result = a1 - 6;
  if ( a1 == 6 )
  {
    *(_DWORD *)v3 = 0;
  }
  else
  {
    result = a1 - 7;
    if ( a1 == 7 )
    {
      result = sub_100117B0(a2, a3);
      if ( result )
        ++*(_DWORD *)v3;
    }
  }
  return result;
}

//----- (10010760) --------------------------------------------------------
int *__usercall sub_10010760@<eax>(_DWORD *a1@<ebx>, int a2)
{
  int *v2; // edi@1
  unsigned int v3; // ebp@1
  int **v4; // esi@1

  v2 = 0;
  v3 = 0;
  v4 = (int **)(sub_100106F0() + 36);
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 && !sub_1000F860((_BYTE *)(a2 + 80 * *a1), **v4) )
    {
      v2 = *v4;
      ++*a1;
    }
    ++v3;
    ++v4;
  }
  while ( !v2 );
  return v2;
}

//----- (100107B0) --------------------------------------------------------
char **sub_100107B0()
{
  return &off_1005A368;
}
// 1005A368: using guessed type char *off_1005A368;

//----- (100107C0) --------------------------------------------------------
int __cdecl sub_100107C0(_DWORD *a1, int a2, int a3)
{
  char *v3; // esi@1
  int result; // eax@2
  unsigned int v5; // ebp@7
  int v6; // [sp+8h] [bp-8h]@0
  int v7; // [sp+8h] [bp-8h]@7
  int v8; // [sp+Ch] [bp-4h]@8

  sub_10016980();
  v3 = sub_100106F0();
  if ( v3[34] )
  {
    result = v6;
  }
  else
  {
    result = sub_10010640();
    if ( result != 12 )
      v3[34] = 1;
  }
  if ( v3[34] )
  {
    sub_10010170(a2);
    if ( a3 )
    {
      v7 = sub_1000FEE0(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), a3);
    }
    else
    {
      v5 = 0;
      v7 = 0;
      if ( *(_DWORD *)(a2 + 12) )
      {
        v8 = 0;
        do
        {
          v7 += sub_1000FEE0(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), v8 + *(_DWORD *)(a2 + 8));
          v8 += 40;
          ++v5;
        }
        while ( v5 < *(_DWORD *)(a2 + 12) );
        sub_100101A0(a2);
        return v7;
      }
    }
    sub_100101A0(a2);
    result = v7;
  }
  return result;
}

//----- (10010870) --------------------------------------------------------
int __cdecl sub_10010870(int a1, int a2, int a3, const char *a4, const char *a5)
{
  int v5; // ebp@1
  unsigned int v6; // eax@1
  char *v7; // ecx@1
  int result; // eax@3
  int v9; // eax@5
  char *v10; // eax@7
  char *v11; // eax@7
  char *v12; // eax@7
  char *v13; // eax@7
  char *v14; // eax@7
  char **v15; // eax@7
  char **v16; // esi@7
  char *v17; // eax@7
  char *v18; // eax@7
  char *v19; // eax@7
  char *v20; // eax@7
  char *v21; // eax@8
  char *v22; // eax@9
  const char *v23; // edi@9
  char *v24; // eax@11
  int v25; // [sp+8h] [bp-41Ch]@4
  int v26[4]; // [sp+10h] [bp-414h]@2
  char v27; // [sp+20h] [bp-404h]@1
  char v28; // [sp+120h] [bp-304h]@7
  char v29; // [sp+220h] [bp-204h]@7
  char v30; // [sp+320h] [bp-104h]@11

  v5 = a1;
  v6 = 0;
  v7 = &v27;
  do
  {
    v26[v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( v6 < 4 );
  result = a2;
  if ( a2 )
  {
    v25 = a2;
    do
    {
      v9 = *(_DWORD *)(v5 + 12);
      if ( v9 )
      {
        result = v9 - 1;
        if ( !result )
        {
          v10 = sub_1000FB00(0, "group", (int)&v27);
          LOBYTE(v10) = 0;
          v11 = sub_1000FB00(v10, a4, (int)&v28);
          LOBYTE(v11) = 0;
          sub_1000FB00(v11, *(const char **)v5, (int)&v29);
          v12 = (char *)sub_10011BC0(2, (int)v26, 3);
          LOBYTE(v12) = 0;
          v13 = sub_1000FB00(v12, "group", (int)&v27);
          LOBYTE(v13) = 0;
          v14 = sub_1000FB00(v13, a4, (int)&v28);
          LOBYTE(v14) = 0;
          sub_1000FB00(v14, "group-begin", (int)&v29);
          sub_10011BC0(2, (int)v26, 3);
          v15 = (char **)(*(int (**)(void))(v5 + 8))();
          v16 = v15;
          v17 = sub_1000F760(v15);
          sub_10010870(v16[2], v16[3], v16[4], v17, a4);
          sub_1000F760(v16);
          v18 = sub_1000FFC0((int)v16[2], v16[3], (int)v16[4], a4);
          LOBYTE(v18) = 0;
          v19 = sub_1000FB00(v18, "group", (int)&v27);
          LOBYTE(v19) = 0;
          v20 = sub_1000FB00(v19, a4, (int)&v28);
          LOBYTE(v20) = 0;
          sub_1000FB00(v20, "group-end", (int)&v29);
          result = sub_10011BC0(2, (int)v26, 3);
        }
      }
      else
      {
        v21 = sub_1000FB00(0, "case", (int)&v27);
        LOBYTE(v21) = 0;
        if ( a5 )
        {
          v22 = sub_1000FB00(v21, a5, (int)&v28);
          v23 = a4;
        }
        else
        {
          v22 = sub_1000FB00(v21, a4, (int)&v28);
          v23 = (const char *)&unk_10047869;
        }
        LOBYTE(v22) = 0;
        v24 = sub_1000FB00(v22, v23, (int)&v29);
        LOBYTE(v24) = 0;
        sub_1000FB00(v24, *(const char **)v5, (int)&v30);
        result = sub_10011BC0(2, (int)v26, 4);
      }
      v5 += 40;
      --v25;
    }
    while ( v25 );
  }
  return result;
}
// 10010870: using guessed type int var_414[4];

//----- (10010A80) --------------------------------------------------------
char *__usercall sub_10010A80@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6)
{
  const char *v6; // edi@1
  char *v7; // eax@1
  char *v8; // ecx@1
  char *v9; // eax@3
  char *result; // eax@3
  int v11[2]; // [sp+Ch] [bp-20Ch]@2
  char v12; // [sp+14h] [bp-204h]@1
  char v13; // [sp+114h] [bp-104h]@3

  v6 = a1;
  v7 = 0;
  v8 = &v12;
  do
  {
    v11[(signed int)v7] = (int)v8;
    *v8 = 0;
    ++v7;
    v8 += 256;
  }
  while ( (unsigned int)v7 < 2 );
  LOBYTE(v7) = 0;
  v9 = sub_1000FB00(v7, v6, (int)&v12);
  LOBYTE(v9) = 0;
  result = sub_1000FB00(v9, a2, (int)&v13);
  if ( v13 )
    result = (char *)sub_10011BC0(2, (int)v11, 2);
  if ( a6 )
  {
    sub_10010870(a3, (int)a4, a5, a2, 0);
    result = sub_1000FFC0(a3, a4, a5, 0);
  }
  return result;
}
// 10010A80: using guessed type int var_20C[2];

//----- (10010B40) --------------------------------------------------------
char *__cdecl sub_10010B40(char a1)
{
  int (**i)(void); // edi@1
  int v2; // esi@3
  char *v3; // ebx@3
  char **v4; // esi@4
  signed int v5; // edi@4
  char *result; // eax@5

  for ( i = (int (**)(void))dword_100C9E30[sub_1000F7B0()]; i; ++i )
  {
    if ( !*i )
      break;
    v2 = (*i)();
    v3 = sub_1000F760((char **)v2);
    sub_10010A80("suite", v3, *(_DWORD *)(v2 + 8), *(char **)(v2 + 12), *(_DWORD *)(v2 + 16), a1);
  }
  v4 = (char **)(sub_100106F0() + 36);
  v5 = 5;
  do
  {
    result = *v4;
    if ( *v4 )
    {
      if ( *((_DWORD *)result + 2) )
        result = sub_10010A80(
                   "listener",
                   *(const char **)result,
                   *((_DWORD *)result + 3),
                   *((char **)result + 4),
                   *((_DWORD *)result + 2),
                   a1);
    }
    ++v4;
    --v5;
  }
  while ( v5 );
  return result;
}
// 100C9E30: using guessed type int dword_100C9E30[];

//----- (10010BE0) --------------------------------------------------------
int *__cdecl sub_10010BE0(_BYTE *a1)
{
  int (**v1)(void); // edi@1
  char **v2; // eax@3
  char **v3; // esi@3
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // ebx@7
  unsigned int v7; // esi@7
  int **v8; // edi@7
  int *result; // eax@8

  v1 = (int (**)(void))dword_100C9E30[sub_1000F7B0()];
  if ( v1 )
  {
    while ( *v1 )
    {
      v2 = (char **)(*v1)();
      v3 = v2;
      v4 = sub_1000F760(v2);
      if ( !sub_1000F860(a1, (int)v4) )
      {
        v5 = sub_1000F760(v3);
        sub_10010A80("suite", v5, (int)v3[2], v3[3], (int)v3[4], 1);
        break;
      }
      ++v1;
      if ( !v1 )
        break;
    }
  }
  v6 = sub_100106F0();
  v7 = 0;
  v8 = (int **)(v6 + 36);
  while ( 1 )
  {
    result = *v8;
    if ( *v8 )
    {
      result = (int *)sub_1000F860(a1, *result);
      if ( !result )
        break;
    }
    ++v7;
    ++v8;
    if ( v7 >= 5 )
      return result;
  }
  return (int *)sub_10010A80(
                  "listener",
                  **(const char ***)&v6[4 * v7 + 36],
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 12),
                  *(char **)(*(_DWORD *)&v6[4 * v7 + 36] + 16),
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 8),
                  1);
}
// 100C9E30: using guessed type int dword_100C9E30[];

//----- (10010CA0) --------------------------------------------------------
int __usercall sub_10010CA0@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  bool v2; // zf@1
  int result; // eax@1
  signed int v4; // ebp@3
  int v5; // eax@5
  int v6; // eax@8
  int v7; // ecx@14
  int v8; // esi@18
  unsigned int v9; // eax@18
  int v10; // eax@19
  int v11; // edi@25

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 20) == 0;
  result = 12;
  if ( !v2 && !*(_BYTE *)(v1 + 24) )
  {
    v4 = 2;
    if ( !*(_DWORD *)(v1 + 16) )
    {
      *(_DWORD *)(v1 + 16) = sub_1000FCC0(++*(_DWORD *)(v1 + 12));
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 4) = 0;
    }
    v5 = *(_DWORD *)(v1 + 16);
    if ( v5 )
    {
      if ( *(_DWORD *)(v1 + 20) == 1 )
      {
        sub_100107C0((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        v6 = sub_1000FCC0(++*(_DWORD *)(v1 + 12));
        v2 = *(_DWORD *)(v1 + 28) == 0;
        *(_DWORD *)(v1 + 16) = v6;
        *(_DWORD *)(v1 + 8) = 0;
        if ( !v2 || !v6 )
          *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 28) == 2 )
      {
        sub_100107C0((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 8)
             || (*(_DWORD *)(v1 + 4) = 0, v7 = *(_DWORD *)(v5 + 8), (*(_DWORD *)(v1 + 8) = v7) != 0) )
      {
        if ( !*(_DWORD *)(v1 + 4) )
          sub_10010170(v5);
        sub_1000FEE0(
          (_DWORD *)v1,
          *(void (__cdecl **)(signed int, void *))(*(_DWORD *)(v1 + 16) + 16),
          *(_DWORD *)(v1 + 8));
        v8 = *(_DWORD *)(v1 + 16);
        v9 = ++*(_DWORD *)(v1 + 4);
        if ( *(_DWORD *)(v8 + 12) > v9 )
        {
          *(_DWORD *)(v1 + 8) = *(_DWORD *)(v8 + 8) + 40 * v9;
        }
        else
        {
          sub_100101A0(v8);
          v10 = sub_1000FCC0(++*(_DWORD *)(v1 + 12));
          *(_DWORD *)(v1 + 16) = v10;
          *(_DWORD *)(v1 + 4) = 0;
          *(_DWORD *)(v1 + 8) = 0;
          if ( !v10 || *(_DWORD *)(v1 + 28) )
            *(_BYTE *)(v1 + 24) = 1;
        }
      }
      else
      {
        *(_BYTE *)(v1 + 24) = 1;
        v4 = 12;
      }
    }
    else
    {
      *(_BYTE *)(v1 + 24) = 1;
      v4 = 12;
    }
    if ( *(_BYTE *)(v1 + 24) && v4 == 2 )
    {
      v11 = *(_DWORD *)v1;
      if ( v11 )
        result = v11 + 12;
      else
        result = 0;
    }
    else
    {
      result = v4;
    }
  }
  return result;
}

//----- (10010E00) --------------------------------------------------------
signed int __usercall sub_10010E00@<eax>(int a1@<esi>)
{
  signed int v1; // ebp@1
  int (**i)(void); // edi@2
  int v3; // eax@4
  signed int result; // eax@5

  v1 = 0;
  if ( *(_DWORD *)(a1 + 20) )
  {
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(_BYTE *)(a1 + 24) = 0;
      result = 1;
    }
    else
    {
      result = 12;
    }
  }
  else
  {
    for ( i = (int (**)(void))dword_100C9E30[sub_1000F7B0()]; i; ++i )
    {
      if ( !*i )
        break;
      v3 = (*i)();
      v1 += sub_100107C0((_DWORD *)a1, v3, 0);
    }
    result = v1;
  }
  return result;
}
// 100C9E30: using guessed type int dword_100C9E30[];

//----- (10010E70) --------------------------------------------------------
int __cdecl sub_10010E70(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  int v4; // ebx@3
  int result; // eax@3
  _BYTE *v6; // esi@5
  int v7; // ebx@6
  int v8; // ebx@8
  int v9; // ebx@9
  int (**i)(void); // edi@11
  int v11; // eax@13
  int (__cdecl *v12)(int, int); // eax@14
  int (**v13)(void); // esi@19
  int v14; // eax@21
  int (__cdecl *v15)(int, int); // eax@22

  v2 = 0;
  v3 = sub_100106F0();
  switch ( a1 )
  {
    case 9:
      sub_10011C30(2, (unsigned int)"begin");
      if ( *(_DWORD *)a2 )
      {
        if ( *(_DWORD *)a2 == 5 )
        {
          v6 = (_BYTE *)(a2 + 4);
          if ( sub_1000F860((_BYTE *)(a2 + 4), (int)"-v") )
          {
            if ( sub_1000F860(v6, (int)"-q") )
            {
              sub_10010BE0(v6);
              v9 = sub_10010640();
              sub_10011C30(2, (unsigned int)"end");
              result = v9;
            }
            else
            {
              sub_10010B40(0);
              v8 = sub_10010640();
              sub_10011C30(2, (unsigned int)"end");
              result = v8;
            }
          }
          else
          {
            sub_10010B40(1);
            v7 = sub_10010640();
            sub_10011C30(2, (unsigned int)"end");
            result = v7;
          }
        }
        else
        {
          sub_10011CB0(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"1719",
            (int)"Unsupported argument type for help command (internal error)");
          sub_10011C30(2, (unsigned int)"end");
          result = 4;
        }
      }
      else
      {
        sub_10010B40(0);
        v4 = sub_10010640();
        sub_10011C30(2, (unsigned int)"end");
        result = v4;
      }
      return result;
    case 2:
      sub_10011C30(0, (unsigned int)"Global reset command");
      for ( i = (int (**)(void))dword_100C9E30[sub_1000F7B0()]; i; ++i )
      {
        if ( !*i )
          break;
        v11 = (*i)();
        if ( v11 )
        {
          v12 = *(int (__cdecl **)(int, int))(v11 + 16);
          if ( v12 )
          {
            if ( v12 != sub_10010E70 )
              v12(2, (int)&unk_10059FB8);
          }
        }
      }
      sub_10016980();
      v3[34] = 0;
      return 0;
    case 3:
      sub_10011C30(1, (unsigned int)"Global clear command");
      v13 = (int (**)(void))dword_100C9E30[sub_1000F7B0()];
      if ( !v13 )
        return v2;
      break;
    case 10:
      if ( !*((_DWORD *)v3 + 5) )
      {
        sub_10011CB0(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1764", (int)"Step mode not enabled");
        goto LABEL_29;
      }
      return sub_10010CA0((int)v3);
    case 11:
      if ( v3[24] )
      {
        *((_DWORD *)v3 + 5) = 0;
        v3[24] = 0;
        result = 0;
      }
      else
      {
        sub_10011CB0(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1783", (int)"Step mode is busy");
LABEL_29:
        result = 12;
      }
      return result;
    case 12:
      *((_DWORD *)v3 + 5) = 1;
      return 0;
    case 13:
      *((_DWORD *)v3 + 5) = 2;
      return 0;
    case 8:
      return sub_10010E00((int)v3);
    case 14:
      exit_0(12);
      return result;
    case 4:
    case 5:
    case 6:
    case 7:
      return v2;
    default:
      sub_10011CB0(
        3,
        (int)"**Warning**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"1820",
        (int)"Unknown/unsupported command (internal error)");
      return 4;
  }
  while ( *v13 )
  {
    v14 = (*v13)();
    if ( v14 )
    {
      v15 = *(int (__cdecl **)(int, int))(v14 + 16);
      if ( v15 )
      {
        if ( v15 != sub_10010E70 )
          v15(3, (int)&unk_10059FB8);
      }
    }
    ++v13;
    if ( !v13 )
      return 0;
  }
  return v2;
}
// 10010E70: using guessed type int __cdecl sub_10010E70(int, int);
// 100C9E30: using guessed type int dword_100C9E30[];

//----- (10011150) --------------------------------------------------------
char **sub_10011150()
{
  return off_1005A15C;
}
// 1005A15C: using guessed type char *off_1005A15C[3];

//----- (10011160) --------------------------------------------------------
int __usercall sub_10011160@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int result; // eax@2
  char **v9; // eax@6
  signed int v10; // ebx@6
  int v11; // [sp+0h] [bp-1C0h]@0
  int (__cdecl *v12)(_DWORD, char *); // [sp+14h] [bp-1ACh]@1
  char v13; // [sp+18h] [bp-1A8h]@2

  v12 = a2;
  v6 = sub_1000FBF0(a4, a5, a1, v11);
  v7 = v6;
  if ( v6 )
  {
    result = sub_1000FD00(a5, &v13, v6, a3, a6);
    if ( !result )
    {
      if ( v12 )
      {
        result = v12(*(_DWORD *)(v7 + 12), &v13);
      }
      else
      {
        sprintf(a6, "'%s' does not support commands", a3);
        result = 11;
      }
    }
  }
  else
  {
    v9 = sub_10011150();
    v10 = *a5;
    if ( (char *)a4 == v9[2] )
      sprintf(a6, "Invalid or missing test suite, listener, or command: '%s'", a3 + 80 * v10);
    else
      sprintf(a6, "Invalid or mising test case or command: '%s'", a3 + 80 * v10);
    result = 10;
  }
  return result;
}

//----- (10011250) --------------------------------------------------------
int __cdecl sub_10011250(char *a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *v3; // edi@1
  char *v4; // eax@1
  int result; // eax@1
  int v6; // eax@4
  char **v7; // ebx@4
  int v8; // eax@5
  int *v9; // eax@20
  char **v10; // eax@22
  int v11; // [sp+10h] [bp-2DCh]@4
  int v12; // [sp+14h] [bp-2D8h]@1
  char v13[720]; // [sp+18h] [bp-2D4h]@1

  v2 = v1;
  v3 = sub_100106F0();
  *a1 = 0;
  v4 = sub_10012710("Processing command '%s'", v2);
  sub_10011CB0(3, (int)&unk_1005AB10, (int)"..\\lib\\utf\\utf_runner.c", (int)"1215", (int)v4);
  result = sub_1000FD90(v13, &v12, v2, a1);
  if ( result )
  {
    if ( result == 3 )
    {
      if ( *((_DWORD *)v3 + 5) && !v3[24] )
        result = sub_10010CA0((int)v3);
    }
    else
    {
      sprintf(a1, "Invalid command: '%s'", v2);
      result = 10;
    }
  }
  else
  {
    if ( !v12 )
      return sub_10010E00((int)v3);
    v11 = 0;
    v6 = sub_1000F7B0();
    v7 = sub_1000FC40((int (**)(void))dword_100C9E30[v6], (int)v13, &v11);
    if ( v7 )
    {
      v8 = sub_1000FB60((int)v7, (int)v13, &v11);
      if ( !v8 )
        goto LABEL_30;
      if ( *(_DWORD *)(v8 + 12) == 1 )
      {
        v7 = (char **)(*(int (**)(void))(v8 + 8))();
        v8 = sub_1000FB60((int)v7, (int)v13, &v11);
      }
      if ( v8 )
      {
        if ( v11 >= v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_100107C0(v3, (int)v7, v8);
          *((_DWORD *)v3 + 2) = v8;
          *((_DWORD *)v3 + 4) = v7;
          *((_DWORD *)v3 + 3) = 0;
          *((_DWORD *)v3 + 1) = 0;
          *((_DWORD *)v3 + 7) = 2;
          v3[24] = 0;
          result = 1;
        }
        else
        {
          sprintf(a1, "Unsupported argument to test case: '%s'", &v13[80 * v11]);
          result = 9;
        }
      }
      else
      {
LABEL_30:
        if ( v11 == v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_100107C0(v3, (int)v7, v8);
          if ( v3[24] )
          {
            *((_DWORD *)v3 + 2) = v8;
            result = 1;
            *((_DWORD *)v3 + 4) = v7;
            *((_DWORD *)v3 + 3) = 0;
            *((_DWORD *)v3 + 1) = 0;
            *((_DWORD *)v3 + 7) = 1;
            v3[24] = 0;
          }
          else
          {
            result = 12;
          }
        }
        else
        {
          result = sub_10011160(
                     (unsigned int)v7[3],
                     (int (__cdecl *)(_DWORD, char *))v7[4],
                     (int)v13,
                     (int)v7[2],
                     &v11,
                     a1);
        }
      }
    }
    else
    {
      v9 = sub_10010760(&v11, (int)v13);
      if ( v9 )
      {
        result = sub_10011160(v9[4], (int (__cdecl *)(_DWORD, char *))v9[2], (int)v13, v9[3], &v11, a1);
      }
      else
      {
        v10 = sub_10011150();
        result = sub_10011160(
                   (unsigned int)v10[3],
                   (int (__cdecl *)(_DWORD, char *))v10[4],
                   (int)v13,
                   (int)v10[2],
                   &v11,
                   a1);
      }
    }
  }
  return result;
}
// 100C9E30: using guessed type int dword_100C9E30[];
// 10011250: using guessed type char var_2D4[720];

//----- (10011490) --------------------------------------------------------
int sub_10011490()
{
  int v0; // esi@1
  char *v1; // eax@4
  int result; // eax@4
  char *v3; // eax@5
  char v4; // [sp+4h] [bp-104h]@1

  v4 = 0;
  v0 = sub_10011250(&v4);
  if ( !sub_100106F0()[32] )
    sub_10011C30(11, (unsigned int)"Non-interactive command complete");
  if ( v4 )
  {
    v3 = sub_10012710("%s %i, %s", "Command status:", v0, &v4);
    sub_10011CB0(3, (int)&unk_1005AB10, (int)"..\\lib\\utf\\utf_runner.c", (int)"773", (int)v3);
    result = v0;
  }
  else
  {
    v1 = sub_10012710("%s %i", "Command status:", v0);
    sub_10011CB0(3, (int)&unk_1005AB10, (int)"..\\lib\\utf\\utf_runner.c", (int)"767", (int)v1);
    result = v0;
  }
  return result;
}

//----- (10011570) --------------------------------------------------------
int __cdecl sub_10011570(int a1, int a2, char a3)
{
  char **v3; // eax@1

  dword_100C9E30[sub_1000F7B0()] = a1;
  sub_100106F0()[32] = a3;
  sub_10016980();
  sub_1001AAE0(a2);
  v3 = sub_100107B0();
  sub_100116A0(v3);
  return sub_10011490();
}
// 100C9E30: using guessed type int dword_100C9E30[];

//----- (100115C0) --------------------------------------------------------
int __cdecl sub_100115C0(int a1)
{
  return a1 + 9;
}

//----- (100115D0) --------------------------------------------------------
int __cdecl sub_100115D0(void *a1)
{
  int v1; // edi@1
  __int16 v2; // ax@1
  _WORD *v3; // ecx@1

  v1 = sub_10024750();
  memset(a1, 0, 0xDCu);
  sub_1000D4E0((char *)a1 + 204, 0xFu, "test sk %i", v1);
  v2 = sub_100115C0(v1);
  *v3 = v2;
  *((_DWORD *)a1 + 10) = (char *)a1 + 204;
  *((_DWORD *)a1 + 11) = (char *)a1 + 76;
  *((_WORD *)a1 + 24) = 128;
  *((_BYTE *)a1 + 50) = 22;
  *((_DWORD *)a1 + 13) = 0;
  *((_DWORD *)a1 + 14) = 300;
  *((_DWORD *)a1 + 15) = 0;
  *((_DWORD *)a1 + 16) = 500;
  *((_DWORD *)a1 + 17) = 0;
  return sub_1001AC70((int)a1, (int)v3);
}

//----- (10011650) --------------------------------------------------------
int __cdecl sub_10011650(int a1, int a2)
{
  int v2; // esi@1
  _DWORD *v3; // ST00_4@1
  int result; // eax@2

  v2 = a1;
  v3 = (_DWORD *)a1;
  *(_DWORD *)(a1 + 60) = a2;
  sub_1001AE80(v3, (char *)&a1);
  if ( (_BYTE)a1 )
    result = v2 + 76;
  else
    result = 0;
  return result;
}

//----- (10011680) --------------------------------------------------------
signed int __cdecl sub_10011680(int a1, int a2, int a3)
{
  signed int result; // eax@1
  int v4; // esi@2
  __int16 v5; // ax@4
  int v6; // eax@6
  int v7; // ebx@6

  result = 0;
  if ( a3 )
  {
    v4 = *(_DWORD *)a1;
    if ( !*(_DWORD *)a1 )
      return -59;
    v5 = 0;
    if ( *(_BYTE *)(v4 + 14) & 0x10 )
      v5 = 2;
    v6 = sub_100252A0(*(_DWORD *)(a1 + 4), a2, a3, v5, *(_DWORD *)(v4 + 28));
    v7 = v6;
    if ( v6 >= 0 )
    {
      *(_DWORD *)(a1 + 32) = sub_100247C0();
    }
    else if ( v6 != -57 || (unsigned int)(sub_100247C0() - *(_DWORD *)(a1 + 32)) >= *(_DWORD *)(v4 + 32) )
    {
      sub_1001AC70(a1, v4);
      return v7;
    }
    result = v7;
  }
  return result;
}

//----- (100116A0) --------------------------------------------------------
char __cdecl sub_100116A0(_DWORD *a1)
{
  char v1; // bl@1
  unsigned int v2; // ebp@1
  char *v3; // edi@1
  char *v4; // eax@4
  char *v5; // eax@7
  char v7; // [sp+13h] [bp-105h]@1
  char v8; // [sp+14h] [bp-104h]@5
  char v9; // [sp+113h] [bp-5h]@5

  v1 = 0;
  v7 = 0;
  v2 = 0;
  v3 = sub_100106F0() + 36;
  do
  {
    if ( v2 >= 5 )
      break;
    if ( !*(_DWORD *)v3 )
    {
      v1 = 1;
      v7 = 1;
      *(_DWORD *)v3 = a1;
      v4 = sub_1001A920("CFG_OutputFile", 0);
      if ( v4 )
      {
        _snprintf(&v8, 0x100u, "'%s' file '%s'", *a1, v4);
        v9 = 0;
        if ( sub_10011490() )
          v7 = 0;
      }
      v5 = sub_1001A920("CFG_OutputPath", 0);
      if ( v5 )
      {
        _snprintf(&v8, 0x100u, "'%s' path '%s'", *a1, v5);
        v9 = 0;
        if ( sub_10011490() )
          v7 = 0;
      }
    }
    ++v2;
    v3 += 4;
  }
  while ( !v1 );
  return v7;
}

//----- (100117B0) --------------------------------------------------------
char __cdecl sub_100117B0(int a1, unsigned int a2)
{
  char result; // al@1

  result = 1;
  if ( a2 > 4 && !memcmp(*(const void **)(a1 + 16), "PASS", 5u) )
    result = 0;
  return result;
}

//----- (100117E0) --------------------------------------------------------
bool __cdecl sub_100117E0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "begin", 6u);
}

//----- (10011810) --------------------------------------------------------
bool __cdecl sub_10011810(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "case", 5u);
}

//----- (10011840) --------------------------------------------------------
bool __cdecl sub_10011840(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "command", 8u);
}

//----- (10011870) --------------------------------------------------------
bool __cdecl sub_10011870(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "end", 4u);
}

//----- (100118A0) --------------------------------------------------------
bool __cdecl sub_100118A0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "group", 6u);
}

//----- (100118D0) --------------------------------------------------------
bool __cdecl sub_100118D0(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-begin", 0xCu);
}

//----- (10011910) --------------------------------------------------------
bool __cdecl sub_10011910(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-end", 0xAu);
}

//----- (10011950) --------------------------------------------------------
bool __cdecl sub_10011950(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "listener", 9u);
}

//----- (10011980) --------------------------------------------------------
bool __cdecl sub_10011980(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "suite", 6u);
}

//----- (100119B0) --------------------------------------------------------
char __cdecl sub_100119B0(int a1, unsigned int a2)
{
  char result; // al@1

  result = 0;
  if ( a2 > 5 && !memcmp(*(const void **)(a1 + 20), "robust", 7u) )
    result = 1;
  return result;
}

//----- (100119E0) --------------------------------------------------------
bool __cdecl sub_100119E0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Error**", 0xAu);
}

//----- (10011A10) --------------------------------------------------------
bool __cdecl sub_10011A10(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**MSG**", 8u);
}

//----- (10011A40) --------------------------------------------------------
bool __cdecl sub_10011A40(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**METHOD**", 0xBu);
}

//----- (10011A70) --------------------------------------------------------
bool __cdecl sub_10011A70(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**RESULT**", 0xBu);
}

//----- (10011AA0) --------------------------------------------------------
bool __cdecl sub_10011AA0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, &unk_1005AB10, 9u);
}

//----- (10011AD0) --------------------------------------------------------
bool __cdecl sub_10011AD0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**SUBGROUP**", 0xDu);
}

//----- (10011B00) --------------------------------------------------------
bool __cdecl sub_10011B00(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TITLE**", 0xAu);
}

//----- (10011B30) --------------------------------------------------------
bool __cdecl sub_10011B30(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "Tested Requirement:", 0x14u);
}

//----- (10011B60) --------------------------------------------------------
bool __cdecl sub_10011B60(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TYPE**", 9u);
}

//----- (10011B90) --------------------------------------------------------
bool __cdecl sub_10011B90(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Warning**", 0xCu);
}

//----- (10011BC0) --------------------------------------------------------
int __cdecl sub_10011BC0(int a1, int a2, int a3)
{
  int *v3; // esi@1
  signed int v4; // edi@1
  int result; // eax@2

  v3 = (int *)(sub_100106F0() + 36);
  v4 = 5;
  do
  {
    result = *v3;
    if ( *v3 )
    {
      result = *(_DWORD *)(result + 4);
      if ( result )
        result = ((int (__cdecl *)(int, int, int))result)(a1, a2, a3);
    }
    ++v3;
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (10011C30) --------------------------------------------------------
int __cdecl sub_10011C30(int a1, char a2)
{
  return sub_10011BC0(a1, (int)&a2, 1);
}

//----- (10011C50) --------------------------------------------------------
int __cdecl sub_10011C50(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = a2;
  v5 = a3;
  return sub_10011BC0(a1, (int)&v4, 2);
}

//----- (10011C80) --------------------------------------------------------
int __cdecl sub_10011C80(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-Ch]@1
  int v6; // [sp+4h] [bp-8h]@1
  int v7; // [sp+8h] [bp-4h]@1

  v5 = a2;
  v6 = a3;
  v7 = a4;
  return sub_10011BC0(a1, (int)&v5, 3);
}

//----- (10011CB0) --------------------------------------------------------
int __cdecl sub_10011CB0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+4h] [bp-Ch]@1
  int v8; // [sp+8h] [bp-8h]@1
  int v9; // [sp+Ch] [bp-4h]@1

  v7 = a3;
  v8 = a4;
  v6 = a2;
  v9 = a5;
  return sub_10011BC0(a1, (int)&v6, 4);
}

//----- (10011CF0) --------------------------------------------------------
int __cdecl sub_10011CF0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [sp+0h] [bp-14h]@1
  int v8; // [sp+4h] [bp-10h]@1
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1
  int v11; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v9 = a4;
  v10 = a5;
  v8 = a3;
  v11 = a6;
  return sub_10011BC0(a1, (int)&v7, 5);
}

//----- (10011D30) --------------------------------------------------------
int __cdecl sub_10011D30(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-18h]@1
  int v9; // [sp+4h] [bp-14h]@1
  int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v8 = a2;
  v9 = a3;
  v11 = a5;
  v12 = a6;
  v10 = a4;
  v13 = a7;
  return sub_10011BC0(a1, (int)&v8, 6);
}

//----- (10011D80) --------------------------------------------------------
char __cdecl sub_10011D80(int a1)
{
  char v1; // bl@1
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  _DWORD *v4; // eax@1

  v1 = 0;
  v2 = sub_100106F0();
  v3 = 0;
  v4 = v2 + 36;
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 == a1 )
    {
      v1 = 1;
      *v4 = 0;
    }
    ++v3;
    ++v4;
  }
  while ( !v1 );
  return v1;
}

//----- (10011DB0) --------------------------------------------------------
char __cdecl sub_10011DB0(int a1)
{
  ++*(_DWORD *)(a1 + 328);
  return *(_BYTE *)(a1 + 52);
}

//----- (10011DC0) --------------------------------------------------------
char __cdecl sub_10011DC0(int a1, int a2)
{
  int v2; // esi@1
  bool v3; // zf@1
  int v4; // ebp@1
  char *v5; // eax@1
  int v6; // edi@1
  int v7; // ecx@2
  char *v8; // ecx@7
  char v9; // dl@8
  char v10; // cl@9
  const char *v11; // ecx@10
  char *v12; // edx@13
  char v13; // cl@14
  int v14; // eax@17
  char v16[255]; // [sp+10h] [bp-104h]@12
  char v17; // [sp+10Fh] [bp-5h]@12

  v2 = a1;
  ++*(_DWORD *)(v2 + 324);
  ++*(_DWORD *)(v2 + 328);
  v3 = *(_BYTE *)(a1 + 53) == 0;
  v4 = *(_DWORD *)(a1 + 324);
  v5 = (char *)(a1 + 53);
  v6 = *(_DWORD *)(a1 + 328);
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  if ( !v3 )
  {
    v7 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
    if ( !v7 )
    {
LABEL_6:
      if ( *(_BYTE *)(a1 + 52) )
      {
        v8 = (char *)(a1 + 53);
        do
          v9 = *v8++;
        while ( v9 );
        v10 = *(&v8[a1 - 2] - a1);
        if ( v10 == 92 || (v3 = v10 == 47, v11 = "/", v3) )
          v11 = (const char *)&unk_10047869;
        _snprintf(v16, 0x100u, "%s%s%s%s", a1 + 53, v11, a2, *(_DWORD *)(a1 + 48));
        v17 = 0;
      }
      else
      {
        v12 = (char *)(v16 - v5);
        do
        {
          v13 = *v5;
          v5[(_DWORD)v12] = *v5;
          ++v5;
        }
        while ( v13 );
      }
      if ( (unsigned __int8)sub_1001AFA0(v16) )
        sub_1001AF80((int)v16);
      *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = sub_1001AFB0((int)v16, 1);
      v14 = *(_DWORD *)a1;
      if ( !*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) && v14 > 0 )
        *(_DWORD *)a1 = v14 - 1;
      return 1;
    }
    if ( *(_BYTE *)(a1 + 52) )
    {
      if ( v7 )
        ++*(_DWORD *)a1;
      goto LABEL_6;
    }
  }
  if ( v6 == 1 && v4 == 1 )
    return 1;
  return 0;
}
// 1001AFA0: using guessed type _DWORD __cdecl sub_1001AFA0(_DWORD);
// 10011DC0: using guessed type char var_104[255];

//----- (10011F40) --------------------------------------------------------
signed int __cdecl sub_10011F40(int a1)
{
  signed int result; // eax@1
  int v2; // edx@1
  int v3; // edx@1

  result = 1;
  v2 = 16 * *(_DWORD *)a1;
  *(_DWORD *)(v2 + a1 + 4) = 0;
  v3 = v2 + a1 + 4;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 312) = 5;
  return result;
}

//----- (10011F80) --------------------------------------------------------
signed int __cdecl sub_10011F80(int a1, int a2, int a3)
{
  char *v3; // eax@3
  char v4; // cl@4
  signed int result; // eax@5

  switch ( a1 )
  {
    case 8:
    case 9:
      if ( *(_DWORD *)a2 != 5 )
        goto LABEL_6;
      v3 = (char *)(a2 + 4);
      do
      {
        v4 = *v3;
        v3[a3 + 53 - (a2 + 4)] = *v3;
        ++v3;
      }
      while ( v4 );
      *(_BYTE *)(a3 + 52) = a1 != 8;
      result = 0;
      break;
    case 10:
      if ( *(_DWORD *)a2 )
        goto LABEL_6;
      *(_BYTE *)(a3 + 53) = 0;
      *(_BYTE *)(a3 + 52) = 0;
      result = 0;
      break;
    case 11:
      if ( *(_DWORD *)a2 == 1 )
      {
        *(_BYTE *)(a3 + 309) = *(_BYTE *)(a2 + 4);
        result = 0;
      }
      else
      {
LABEL_6:
        result = 9;
      }
      break;
    default:
      result = 4;
      break;
  }
  return result;
}

//----- (10012020) --------------------------------------------------------
char __cdecl sub_10012020(int a1)
{
  int v1; // edx@3

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( *(_DWORD *)(a1 + 328) == 1 )
    {
      v1 = 16 * *(_DWORD *)a1 + a1 + 4;
      *(_DWORD *)v1 = 0;
      *(_DWORD *)(v1 + 4) = 0;
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 12) = 0;
      if ( *(_DWORD *)a1 > 0 )
        --*(_DWORD *)a1;
    }
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return *(_BYTE *)(a1 + 52);
}

//----- (10012080) --------------------------------------------------------
char __cdecl sub_10012080(int a1, void (__cdecl *a2)(int))
{
  char result; // al@6

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( a2 )
      a2(a1);
    sub_1001AF60(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    result = 1;
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return result;
}

//----- (100120F0) --------------------------------------------------------
char *__cdecl sub_100120F0(char *a1)
{
  char *v1; // esi@1
  size_t v2; // edi@1
  char *v3; // eax@1
  char *v4; // eax@2
  unsigned int v5; // eax@3
  char *v6; // eax@5
  char *v7; // eax@7

  v1 = a1;
  v2 = 255;
  v3 = strstr(a1, "$Id: ");
  if ( v3 )
  {
    v1 = v3 + 5;
    v4 = strchr(v3 + 5, 44);
    if ( v4 )
    {
      v5 = v4 - v1;
      if ( v5 < 0x100 )
        goto LABEL_9;
    }
  }
  else
  {
    v6 = strrchr(a1, 47);
    if ( v6 )
    {
      v1 = v6 + 1;
      v2 = strlen(v6 + 1);
    }
    v7 = strrchr(v1, 92);
    if ( v7 )
    {
      v1 = v7 + 1;
      v5 = strlen(v7 + 1);
LABEL_9:
      v2 = v5;
      goto LABEL_10;
    }
  }
LABEL_10:
  strncpy(&byte_100C9F70, v1, v2);
  *(&byte_100C9F70 + v2) = 0;
  return &byte_100C9F70;
}

//----- (10012190) --------------------------------------------------------
int __cdecl sub_10012190(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 44) = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 48) = a3;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 53) = 0;
  *(_BYTE *)(a1 + 309) = 1;
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (10012200) --------------------------------------------------------
bool __cdecl sub_10012200(int a1, unsigned int a2, int a3)
{
  bool result; // al@9
  int v4; // ecx@11
  int v5; // edx@11
  int v6; // [sp+4h] [bp-4h]@3

  if ( a2 <= 4
    || sub_10027BD2(*(_DWORD *)(a1 + 12), (int)"%d", (unsigned int)&a2) != 1
    || sub_10027BD2(*(_DWORD *)(a1 + 16), (int)"%d", (unsigned int)&v6) != 1 )
  {
    result = 0;
    *(_BYTE *)(a3 + 316) = 0;
  }
  else
  {
    result = a2 == 4 || !a2 || a2 == 1 || a2 == 2 || a2 == 3;
    v4 = a3;
    *(_DWORD *)(a3 + 312) = a2;
    v5 = v6;
    *(_BYTE *)(v4 + 316) = result;
    *(_DWORD *)(v4 + 320) = v5;
  }
  return result;
}

//----- (10012290) --------------------------------------------------------
char __cdecl sub_10012290(int a1, int a2, char a3, char a4)
{
  int v4; // ecx@2
  int v5; // eax@3
  bool v6; // zf@3
  signed int v7; // eax@6
  char result; // al@14

  switch ( a2 )
  {
    case 3:
      v4 = a1;
      if ( a3 )
        goto LABEL_11;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 1;
      goto LABEL_4;
    case 7:
      v4 = a1;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 2;
LABEL_4:
      if ( !v6 && v5 != 3 )
        goto LABEL_12;
      v7 = *(_DWORD *)(v4 + 320);
      if ( v7 <= 1 )
      {
        *(_DWORD *)(v4 + 320) = 0;
LABEL_11:
        *(_DWORD *)(v4 + 312) = 5;
      }
      else
      {
        *(_DWORD *)(v4 + 320) = v7 - 1;
      }
LABEL_12:
      if ( *(_BYTE *)(v4 + 316) )
      {
        if ( *(_DWORD *)(v4 + 312) == 5 )
        {
          result = 1;
          *(_BYTE *)(v4 + 316) = 0;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = a4;
      }
      return result;
    default:
      v4 = a1;
      goto LABEL_11;
  }
}

//----- (10012340) --------------------------------------------------------
char __cdecl sub_10012340(int a1)
{
  return *(_BYTE *)(a1 + 316);
}

//----- (10012350) --------------------------------------------------------
char __cdecl sub_10012350(int a1, void (__cdecl *a2)(int))
{
  char v2; // bl@1

  v2 = 0;
  if ( !*(_BYTE *)(a1 + 52) && *(_DWORD *)(a1 + 324) > 0 || *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    v2 = 1;
    if ( a2 )
      a2(a1);
  }
  if ( *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    sub_1001AF60(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    v2 = 1;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return v2;
}

//----- (100123D0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100123D0(int a1, const char *a2))(const char *)
{
  int v2; // edx@1
  int (__cdecl *result)(const char *); // eax@2

  v2 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
  if ( v2 )
  {
    result = (int (__cdecl *)(const char *))sub_1001B030((int)a2, strlen(a2), v2);
  }
  else
  {
    result = *(int (__cdecl **)(const char *))(a1 + 44);
    if ( result )
      result = (int (__cdecl *)(const char *))result(a2);
  }
  return result;
}

//----- (10012420) --------------------------------------------------------
signed int __cdecl sub_10012420(int a1, void (__cdecl *a2)(int))
{
  signed int result; // eax@1

  sub_10012350(a1, a2);
  result = 1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (10012470) --------------------------------------------------------
char *__cdecl sub_10012470(int a1, int a2, int a3, size_t a4, char *a5)
{
  char v5; // cl@1
  int v6; // eax@1
  int v7; // esi@1
  int v8; // edi@2
  char *v9; // eax@14
  char *v10; // eax@14
  char *v11; // eax@15
  unsigned int v12; // ecx@19
  char v13; // cl@20
  bool v14; // zf@21
  const char *v15; // ecx@21
  char v17[256]; // [sp+Ch] [bp-104h]@8

  v5 = *(_BYTE *)a1;
  v6 = 0;
  v7 = 0;
  if ( !*(_BYTE *)a1 )
    goto LABEL_12;
  v8 = a1;
  do
  {
    if ( v5 == 46 )
    {
      v7 = v6;
    }
    else if ( v5 == 47 || v5 == 92 )
    {
      v6 = 0;
      v7 = 0;
      goto LABEL_9;
    }
    v17[v6++] = v5;
LABEL_9:
    v5 = *(_BYTE *)(v8++ + 1);
  }
  while ( v5 );
  if ( v7 )
  {
    v17[v7] = 0;
    goto LABEL_13;
  }
LABEL_12:
  v17[v6] = 0;
LABEL_13:
  switch ( a2 )
  {
    case 1:
      v9 = sub_1001A920("CFG_ActDir", (int)&unk_10047869);
      v10 = sub_1001A920("CFG_ActDirRuntime", (int)v9);
      break;
    case 2:
      v11 = sub_1001A920("CFG_ExpDir", (int)&unk_10047869);
      v10 = sub_1001A920("CFG_ExpDirRuntime", (int)v11);
      break;
    case 3:
      v10 = sub_1001A920("CFG_ActDir", (int)&unk_10047869);
      break;
    case 4:
      v10 = sub_1001A920("CFG_ExpDir", (int)&unk_10047869);
      break;
    default:
      v10 = (char *)&unk_10047869;
      break;
  }
  v12 = strlen(v10);
  if ( !v12 || (v13 = v10[v12 - 1], v13 == 47) || (v14 = v13 == 92, v15 = "/", v14) )
    v15 = (const char *)&unk_10047869;
  _snprintf(a5, a4, "%s%s%s_%s.bmp", v10, v15, v17, a3);
  a5[a4 - 1] = 0;
  return a5;
}
// 10012470: using guessed type char var_104[256];

//----- (100125F0) --------------------------------------------------------
int sub_100125F0()
{
  return dword_100CEC60[sub_1000F7B0()];
}
// 100CEC60: using guessed type int dword_100CEC60[];

//----- (10012600) --------------------------------------------------------
const char *__cdecl sub_10012600(unsigned int a1)
{
  const char *result; // eax@2

  if ( a1 >= 3 )
    result = "Unknown Type Of Testing";
  else
    result = off_1005AD50[a1];
  return result;
}
// 1005AD50: using guessed type char *off_1005AD50[7];

//----- (10012620) --------------------------------------------------------
int __cdecl sub_10012620(int a1, int a2, int a3, int a4)
{
  char v5; // [sp+8h] [bp-204h]@1
  char v6; // [sp+107h] [bp-105h]@1
  char v7; // [sp+108h] [bp-104h]@1
  char v8; // [sp+207h] [bp-5h]@1

  _snprintf(&v5, 0x100u, "%d", a3);
  v6 = 0;
  _snprintf(&v7, 0x100u, "%d", a4);
  v8 = 0;
  return sub_10011CF0(3, (int)"**SUBGROUP**", a1, a2, (int)&v5, (int)&v7);
}

//----- (100126D0) --------------------------------------------------------
int __cdecl sub_100126D0(int a1)
{
  int result; // eax@1

  result = sub_1000F7B0();
  dword_100D0D6C[result] = a1;
  return result;
}
// 100D0D6C: using guessed type int dword_100D0D6C[];

//----- (100126F0) --------------------------------------------------------
int __cdecl sub_100126F0(int a1)
{
  int result; // eax@1

  result = sub_1000F7B0();
  dword_100CEC60[result] = a1;
  return result;
}
// 100CEC60: using guessed type int dword_100CEC60[];

//----- (10012710) --------------------------------------------------------
char *sub_10012710(char *a1, ...)
{
  int v1; // esi@1
  char *result; // eax@1
  va_list va; // [sp+10h] [bp+8h]@1

  va_start(va, a1);
  v1 = sub_1000F7B0() << 8;
  _vsnprintf(&byte_100CA070[v1], 0x100u, a1, va);
  result = &byte_100CA070[v1];
  byte_100CA16E[v1] = 42;
  byte_100CA16F[v1] = 0;
  return result;
}

//----- (10012750) --------------------------------------------------------
char *__usercall sub_10012750@<eax>(char a1@<al>, unsigned __int8 a2@<cl>)
{
  char *result; // eax@3

  if ( a2 && a2 != 1 )
    result = off_1005AD64[a1 & 1];
  else
    result = off_1005AD5C[a2];
  return result;
}
// 1005AD5C: using guessed type char *off_1005AD5C[4];
// 1005AD64: using guessed type char *off_1005AD64[2];

//----- (10012770) --------------------------------------------------------
char __usercall sub_10012770@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5)
{
  const char *v5; // ebp@1
  int v6; // edi@1
  char v7; // cl@1
  char result; // al@5
  long double v9; // st7@6
  signed int v10; // eax@7
  int v11; // ecx@10
  int v12; // ebp@10
  int v13; // edx@10
  int v14; // edi@10
  int v15; // edi@16
  int v16; // eax@30
  char v17; // [sp+18h] [bp+4h]@1

  v5 = a2;
  v6 = sub_1000F7B0();
  v17 = a2[a3 - 2];
  v7 = v17;
  if ( v17 == 100 || v17 == 117 )
  {
    v16 = sub_100125F0() - 1;
    if ( v16 )
    {
      if ( v16 == 1 )
      {
        strncpy((char *)(a1 + 1), v5, a4 - 1);
        *(_BYTE *)(a1 + 1) = 35;
        *(_BYTE *)a1 = 37;
        result = 0;
        *(_BYTE *)(a3 + a1 - 1) = 111;
      }
      else
      {
        strncpy((char *)a1, v5, a4);
        result = 0;
      }
    }
    else
    {
      strncpy((char *)(a1 + 1), v5, a4 - 1);
      *(_BYTE *)(a1 + 1) = 35;
      *(_BYTE *)a1 = 37;
      result = 0;
      *(_BYTE *)(a3 + a1 - 1) = 120;
    }
  }
  else if ( v17 == 102 || v17 == 103 )
  {
    v9 = fabs(a5);
    if ( 0.0 == v9 )
    {
      v10 = 0;
    }
    else
    {
      v10 = (signed int)floor(log10(v9));
      v7 = v17;
    }
    if ( v7 == 102 )
    {
      v11 = dword_100D2360[v6];
      v12 = dword_100D2374[v6];
      v13 = v11 + v10;
      v14 = v11 + v10;
      if ( v11 + v10 >= 9 )
        v14 = 9;
      if ( v11 <= v14 )
      {
        if ( v13 >= 9 )
          v13 = 9;
      }
      else
      {
        v13 = v11;
      }
    }
    else
    {
      v11 = dword_100CEC74[v6];
      v12 = dword_100D0D58[v6];
      v13 = v11 + v10;
      v15 = v11 + v10;
      if ( v11 + v10 >= 14 )
        v15 = 14;
      if ( v11 <= v15 )
      {
        if ( v13 >= 14 )
          v13 = 14;
      }
      else
      {
        v13 = v11;
      }
    }
    if ( v12 )
    {
      if ( v12 == 1 )
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
      else if ( v11 <= v10 || v10 < -4 )
      {
        _snprintf((char *)a1, a4, "%%.%de", v13);
        result = 1;
      }
      else
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
    }
    else
    {
      _snprintf((char *)a1, a4, "%%.%de", v13);
      result = 1;
    }
  }
  else
  {
    strncpy((char *)a1, v5, a4);
    result = 0;
  }
  return result;
}
// 100CEC74: using guessed type int dword_100CEC74[];
// 100D0D58: using guessed type int dword_100D0D58[];
// 100D2360: using guessed type int dword_100D2360[];
// 100D2374: using guessed type int dword_100D2374[];

//----- (10012950) --------------------------------------------------------
int sub_10012950()
{
  nullsub_1("..\\lib\\utf\\utf_verify.c", "2370", "UTF_NO_BITMAP_CMP was defined. Bitmap comparison not supported");
  return 0;
}
// 10007810: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);

//----- (10012970) --------------------------------------------------------
int sub_10012970()
{
  return nullsub_1(
           "..\\lib\\utf\\utf_verify.c",
           "2396",
           "UTF_NO_BITMAP_CMP was defined. Bitmap comparison not supported");
}
// 10007810: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);

//----- (10012990) --------------------------------------------------------
int __cdecl sub_10012990(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_1000F7B0();
  dword_100D0D58[result] = a1;
  if ( a2 >= 0 )
  {
    dword_100CEC74[result] = a2;
    if ( a2 > 14 )
    {
      v3 = sub_10012710(
             "Floating point (double) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             14);
      result = sub_10011CB0(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"909", (int)v3);
    }
  }
  else
  {
    dword_100CEC74[result] = 8;
  }
  return result;
}
// 100CEC74: using guessed type int dword_100CEC74[];
// 100D0D58: using guessed type int dword_100D0D58[];

//----- (100129F0) --------------------------------------------------------
int __cdecl sub_100129F0(int a1)
{
  return sub_10012990(0, a1);
}

//----- (10012A00) --------------------------------------------------------
int __cdecl sub_10012A00(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_1000F7B0();
  dword_100D2374[result] = a1;
  if ( a2 >= 0 )
  {
    dword_100D2360[result] = a2;
    if ( a2 > 9 )
    {
      v3 = sub_10012710(
             "Floating point (float) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             9);
      result = sub_10011CB0(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"977", (int)v3);
    }
  }
  else
  {
    dword_100D2360[result] = 8;
  }
  return result;
}
// 100D2360: using guessed type int dword_100D2360[];
// 100D2374: using guessed type int dword_100D2374[];

//----- (10012A60) --------------------------------------------------------
int __cdecl sub_10012A60(int a1)
{
  return sub_10012A00(0, a1);
}

//----- (10012A70) --------------------------------------------------------
bool __cdecl sub_10012A70(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  bool v8; // bl@4
  char *v9; // eax@7
  char *v10; // edx@7
  int v11; // esi@8
  int v12; // edi@19
  char *v14; // [sp+Ch] [bp-2Ch]@7
  int v15; // [sp+10h] [bp-28h]@7
  int v16; // [sp+14h] [bp-24h]@7
  int v17; // [sp+18h] [bp-20h]@7
  char *v18; // [sp+1Ch] [bp-1Ch]@7
  char *v19; // [sp+20h] [bp-18h]@7
  const char *v20; // [sp+24h] [bp-14h]@7
  char *v21; // [sp+28h] [bp-10h]@7
  char *v22; // [sp+2Ch] [bp-Ch]@7
  int v23; // [sp+30h] [bp-8h]@8
  int v24; // [sp+34h] [bp-4h]@8

  if ( a2 )
  {
    if ( a6 == 1 )
    {
      if ( a7 )
        goto LABEL_4;
    }
    else if ( a6 || a7 != 1 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
  else
  {
    if ( a6 == 1 )
    {
      if ( a7 != 1 )
      {
LABEL_4:
        v8 = 0;
        goto LABEL_5;
      }
    }
    else if ( a6 || a7 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
LABEL_5:
  if ( sub_10010710() )
    v8 = v8 == 0;
  v9 = off_1005AD34[a2];
  v15 = a3;
  v14 = v9;
  v17 = a5;
  v16 = a4;
  v20 = "bool";
  v10 = off_1005AD24[v8 != 0];
  v19 = off_1005AD2C[a1];
  v18 = v10;
  v21 = sub_10012750(0, a6);
  v22 = sub_10012750(1, a7);
  if ( a8 )
  {
    v23 = 0;
    v24 = a8;
    v11 = 11;
  }
  else
  {
    v11 = 9;
  }
  v12 = sub_1001B210();
  sub_10011BC0(7, (int)&v14, v11);
  sub_1001B220(v12);
  return v8;
}
// 1005AD24: using guessed type char *off_1005AD24[18];
// 1005AD2C: using guessed type char *off_1005AD2C[16];
// 1005AD34: using guessed type char *off_1005AD34[14];

//----- (10012BB0) --------------------------------------------------------
bool __cdecl sub_10012BB0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  int v8; // edi@1
  unsigned __int8 v9; // al@14
  unsigned __int8 v10; // al@17
  int v11; // edi@25
  char *v12; // esi@26
  char *v13; // edx@28
  int v14; // ebx@30
  bool v16; // [sp+1Bh] [bp-5Dh]@2
  char v17; // [sp+1Fh] [bp-59h]@25
  unsigned int v18; // [sp+20h] [bp-58h]@1
  char *v19; // [sp+3Ch] [bp-3Ch]@28
  int v20; // [sp+40h] [bp-38h]@28
  int v21; // [sp+44h] [bp-34h]@28
  int v22; // [sp+48h] [bp-30h]@28
  char *v23; // [sp+4Ch] [bp-2Ch]@28
  char *v24; // [sp+50h] [bp-28h]@28
  const char *v25; // [sp+54h] [bp-24h]@28
  const char *v26; // [sp+58h] [bp-20h]@28
  const char *v27; // [sp+5Ch] [bp-1Ch]@28
  char *v28; // [sp+60h] [bp-18h]@28
  int v29; // [sp+64h] [bp-14h]@29
  char v30; // [sp+68h] [bp-10h]@25

  v8 = sub_1000F7B0();
  v18 = 9;
  switch ( a2 )
  {
    case 0:
      v16 = a6 == a7;
      break;
    case 1:
      v16 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 4:
      v16 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 6:
      if ( a7 )
        v9 = a7;
      else
        v9 = 0;
      if ( a6 < v9 )
        goto LABEL_38;
      v10 = a7;
      if ( (signed int)a7 >= 255 )
        v10 = -1;
      v16 = 1;
      if ( a6 > v10 )
LABEL_38:
        v16 = 0;
      v18 = 10;
      break;
    default:
LABEL_22:
      v16 = 0;
      break;
  }
  if ( sub_10010710() )
    v16 = v16 == 0;
  sub_10012770((int)&v30, "%c", 3, 0xCu, (double)a6);
  v11 = 3072 * v8;
  _snprintf(&byte_100CB060[v11], 0x400u, &v30, a6);
  byte_100CB45E[v11] = 42;
  byte_100CB45F[v11] = 0;
  v17 = sub_10012770((int)&v30, "%c", 3, 0xCu, (double)a7);
  _snprintf(&byte_100CB460[v11], 0x400u, &v30, a7);
  byte_100CB85E[v11] = 42;
  byte_100CB85F[v11] = 0;
  if ( v18 <= 9 )
  {
    v12 = &byte_100CB860[v11];
    byte_100CB860[v11] = 0;
  }
  else
  {
    v17 = sub_10012770((int)&v30, "%c", 3, 0xCu, 0.0);
    v12 = &byte_100CB860[v11];
    _snprintf(&byte_100CB860[v11], 0x400u, &v30, 0);
    byte_100CBC5E[v11] = 42;
    byte_100CBC5F[v11] = 0;
  }
  v19 = off_1005AD34[a2];
  v21 = a4;
  v22 = a5;
  v20 = a3;
  v25 = "char";
  v26 = &byte_100CB060[v11];
  v27 = &byte_100CB460[v11];
  v13 = off_1005AD2C[a1];
  v23 = off_1005AD24[v16 != 0];
  v24 = v13;
  v28 = v12;
  if ( a8 )
  {
    v29 = a8;
    v18 = 11;
  }
  v14 = sub_1001B210();
  sub_10011BC0(7, (int)&v19, v18);
  if ( v17 && a6 != a7 && fabs((double)(a6 - a7)) > 0.0 && !strcmp(v26, v27) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10011CB0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1001B220(v14);
  return v16;
}
// 10007810: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 1005AD24: using guessed type char *off_1005AD24[18];
// 1005AD2C: using guessed type char *off_1005AD2C[16];
// 1005AD34: using guessed type char *off_1005AD34[14];

//----- (10012F60) --------------------------------------------------------
bool __cdecl sub_10012F60(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9)
{
  double v9; // st6@1
  long double v10; // st7@4
  int v11; // edi@8
  int v12; // edi@21
  char *v13; // esi@22
  double v14; // st5@28
  double v15; // st3@30
  double v16; // st5@30
  char *v17; // ecx@37
  int v18; // ebx@39
  bool v20; // [sp+27h] [bp-61h]@10
  char v21; // [sp+2Bh] [bp-5Dh]@21
  unsigned int v22; // [sp+2Ch] [bp-5Ch]@8
  char *v23; // [sp+4Ch] [bp-3Ch]@37
  int v24; // [sp+50h] [bp-38h]@37
  int v25; // [sp+54h] [bp-34h]@37
  int v26; // [sp+58h] [bp-30h]@37
  char *v27; // [sp+5Ch] [bp-2Ch]@37
  char *v28; // [sp+60h] [bp-28h]@37
  const char *v29; // [sp+64h] [bp-24h]@37
  const char *v30; // [sp+68h] [bp-20h]@37
  const char *v31; // [sp+6Ch] [bp-1Ch]@37
  char *v32; // [sp+70h] [bp-18h]@37
  int v33; // [sp+74h] [bp-14h]@38
  char v34; // [sp+78h] [bp-10h]@21

  v9 = a8;
  if ( a2 != 6
    || -0.000001 != a8
    || (a7 >= 0.0 ? (v9 = a7 * 0.000001, v10 = 0.000001) : (v10 = 0.000001, v9 = -0.000001 * a7), v9 >= v10) )
  {
    v10 = v9;
  }
  v11 = sub_1000F7B0();
  v22 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 1:
      v20 = a7 != a6;
      break;
    case 2:
      if ( a7 != a6 && a7 < a6 )
        goto LABEL_18;
      goto LABEL_14;
    case 3:
      if ( a7 == a6 || a7 < a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 5:
      if ( a7 != a6 && a7 >= a6 )
        goto LABEL_18;
LABEL_14:
      v20 = 1;
      break;
    case 6:
      v14 = v10 - 1.797693134862316e308;
      if ( a7 > v10 - 1.797693134862316e308 )
        v14 = a7;
      v15 = v14;
      v16 = a7;
      if ( v15 - v10 > a6 )
        goto LABEL_47;
      if ( 1.797693134862316e308 - v10 <= a7 )
        v16 = 1.797693134862316e308 - v10;
      if ( v10 + v16 < a6 )
      {
LABEL_47:
        v20 = 0;
        v22 = 10;
      }
      else
      {
        v20 = 1;
        v22 = 10;
      }
      break;
    default:
LABEL_18:
      v20 = 0;
      break;
  }
  if ( sub_10010710() )
    v20 = v20 == 0;
  sub_10012770((int)&v34, (char *)&unk_1005B018, 3, 0xCu, a6);
  v12 = 3072 * v11;
  _snprintf(&byte_100CB060[v12], 0x400u, &v34);
  byte_100CB45E[v12] = 42;
  byte_100CB45F[v12] = 0;
  v21 = sub_10012770((int)&v34, (char *)&unk_1005B018, 3, 0xCu, a7);
  _snprintf(&byte_100CB460[v12], 0x400u, &v34, a7);
  byte_100CB85E[v12] = 42;
  byte_100CB85F[v12] = 0;
  if ( v22 <= 9 )
  {
    v13 = &byte_100CB860[v12];
    byte_100CB860[v12] = 0;
  }
  else
  {
    v13 = &byte_100CB860[v12];
    v21 = sub_10012770((int)&v34, (char *)&unk_1005B018, 3, 0xCu, v10);
    _snprintf(&byte_100CB860[v12], 0x400u, &v34, LODWORD(v10), (_DWORD)(*(unsigned __int64 *)&v10 >> 32));
    byte_100CBC5E[v12] = 42;
    byte_100CBC5F[v12] = 0;
  }
  v23 = off_1005AD34[a2];
  v26 = a5;
  v25 = a4;
  v24 = a3;
  v29 = "double";
  v30 = &byte_100CB060[v12];
  v32 = v13;
  v17 = off_1005AD2C[a1];
  v27 = off_1005AD24[v20 != 0];
  v28 = v17;
  v31 = &byte_100CB460[v12];
  if ( a9 )
  {
    v33 = a9;
    v22 = 11;
  }
  v18 = sub_1001B210();
  sub_10011BC0(7, (int)&v23, v22);
  if ( v21 && a6 != a7 && fabs(a6 - a7) > v10 && !strcmp(v30, v31) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10011CB0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1001B220(v18);
  return v20;
}
// 10007810: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 1005AD24: using guessed type char *off_1005AD24[18];
// 1005AD2C: using guessed type char *off_1005AD2C[16];
// 1005AD34: using guessed type char *off_1005AD34[14];

//----- (100133B0) --------------------------------------------------------
bool __cdecl sub_100133B0(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9)
{
  double v9; // st7@1
  double v10; // st6@1
  double v11; // st7@4
  float v12; // ST38_4@6
  double v13; // st7@6
  double v14; // st7@8
  double v15; // st6@8
  int v16; // edi@8
  double v17; // st5@24
  double v18; // st3@26
  double v19; // st5@26
  int v20; // edi@35
  char *v21; // esi@36
  char *v22; // ecx@38
  int v23; // ebx@40
  bool v25; // [sp+1Bh] [bp-59h]@10
  char v26; // [sp+1Fh] [bp-55h]@35
  unsigned int v27; // [sp+20h] [bp-54h]@8
  float v28; // [sp+24h] [bp-50h]@8
  char *v29; // [sp+38h] [bp-3Ch]@38
  int v30; // [sp+3Ch] [bp-38h]@38
  int v31; // [sp+40h] [bp-34h]@38
  int v32; // [sp+44h] [bp-30h]@38
  char *v33; // [sp+48h] [bp-2Ch]@38
  char *v34; // [sp+4Ch] [bp-28h]@38
  const char *v35; // [sp+50h] [bp-24h]@38
  const char *v36; // [sp+54h] [bp-20h]@38
  const char *v37; // [sp+58h] [bp-1Ch]@38
  char *v38; // [sp+5Ch] [bp-18h]@38
  int v39; // [sp+60h] [bp-14h]@39
  char v40; // [sp+64h] [bp-10h]@35

  v9 = a7;
  v10 = a8;
  if ( a2 != 6
    || -0.0000099999997 != v10
    || (v9 >= 0.0 ? (v11 = v9 * 0.000009999999747378752) : (v11 = v9 * -0.000009999999747378752),
        v12 = v11,
        v13 = 0.0000099999997,
        v10 = v12,
        v12 >= 0.0000099999997) )
  {
    v13 = v10;
  }
  v28 = v13;
  v14 = v28;
  v15 = a6;
  v16 = sub_1000F7B0();
  v27 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 1:
      v25 = a7 != a6;
      break;
    case 2:
      if ( a7 != v15 && a7 < (double)a6 )
        goto LABEL_32;
      goto LABEL_14;
    case 3:
      if ( a7 == v15 || a7 < (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 4:
      if ( a7 >= (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 5:
      if ( a7 != v15 && a7 >= (double)a6 )
        goto LABEL_32;
LABEL_14:
      v25 = 1;
      break;
    case 6:
      v17 = v14 - 3.402823466385289e38;
      if ( a7 > v14 - 3.402823466385289e38 )
        v17 = a7;
      v18 = v17 - v14;
      v19 = a7;
      if ( v18 > v15 )
        goto LABEL_48;
      if ( 3.402823466385289e38 - v14 <= v19 )
        v19 = 3.402823466385289e38 - v14;
      if ( v15 > v14 + v19 )
      {
LABEL_48:
        v25 = 0;
        v27 = 10;
      }
      else
      {
        v25 = 1;
        v27 = 10;
      }
      break;
    default:
LABEL_32:
      v25 = 0;
      break;
  }
  if ( sub_10010710() )
    v25 = v25 == 0;
  sub_10012770((int)&v40, "%f", 3, 0xCu, a6);
  v20 = 3072 * v16;
  _snprintf(&byte_100CB060[v20], 0x400u, &v40);
  byte_100CB45E[v20] = 42;
  byte_100CB45F[v20] = 0;
  v26 = sub_10012770((int)&v40, "%f", 3, 0xCu, a7);
  _snprintf(&byte_100CB460[v20], 0x400u, &v40, a7);
  byte_100CB85E[v20] = 42;
  byte_100CB85F[v20] = 0;
  if ( v27 <= 9 )
  {
    v21 = &byte_100CB860[v20];
    byte_100CB860[v20] = 0;
  }
  else
  {
    v21 = &byte_100CB860[v20];
    v26 = sub_10012770((int)&v40, "%f", 3, 0xCu, v28);
    _snprintf(&byte_100CB860[v20], 0x400u, &v40, v28);
    byte_100CBC5E[v20] = 42;
    byte_100CBC5F[v20] = 0;
  }
  v29 = off_1005AD34[a2];
  v32 = a5;
  v31 = a4;
  v30 = a3;
  v35 = "float";
  v36 = &byte_100CB060[v20];
  v37 = &byte_100CB460[v20];
  v38 = v21;
  v22 = off_1005AD24[v25 != 0];
  v34 = off_1005AD2C[a1];
  v33 = v22;
  if ( a9 )
  {
    v39 = a9;
    v27 = 11;
  }
  v23 = sub_1001B210();
  sub_10011BC0(7, (int)&v29, v27);
  if ( v26 && a7 != a6 && v28 < fabs(a6 - a7) && !strcmp(v36, v37) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10011CB0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1001B220(v23);
  return v25;
}
// 10007810: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 1005AD24: using guessed type char *off_1005AD24[18];
// 1005AD2C: using guessed type char *off_1005AD2C[16];
// 1005AD34: using guessed type char *off_1005AD34[14];

//----- (10013870) --------------------------------------------------------
bool __cdecl sub_10013870(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  void *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_1000F7B0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10010710() )
    v17 = v17 == 0;
  sub_10012770((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100CB060[v12], 0x400u, &v31, a6);
  byte_100CB45E[v12] = 42;
  byte_100CB45F[v12] = 0;
  v18 = sub_10012770((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_100CB460[v12], 0x400u, &v31, a7);
  byte_100CB85E[v12] = 42;
  byte_100CB85F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100CB860[v12];
    byte_100CB860[v12] = 0;
  }
  else
  {
    v18 = sub_10012770((int)&v31, "%d", 3, 0xCu, (double)a8);
    v13 = &byte_100CB860[v12];
    _snprintf(&byte_100CB860[v12], 0x400u, &v31, a8);
    byte_100CBC5E[v12] = 42;
    byte_100CBC5F[v12] = 0;
  }
  v20 = off_1005AD34[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = &unk_1005B05C;
  v27 = &byte_100CB060[v12];
  v28 = &byte_100CB460[v12];
  v29 = v13;
  v14 = off_1005AD24[v17 != 0];
  v25 = off_1005AD2C[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1001B210();
  sub_10011BC0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10011CB0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1001B220(v15);
  return v17;
}
// 10007810: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 1005AD24: using guessed type char *off_1005AD24[18];
// 1005AD2C: using guessed type char *off_1005AD2C[16];
// 1005AD34: using guessed type char *off_1005AD34[14];

//----- (10013C30) --------------------------------------------------------
bool __cdecl sub_10013C30(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9)
{
  int v9; // edi@1
  __int16 v10; // ax@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1000F7B0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 0x8000;
      if ( v11 < a7 )
        LOWORD(v11) = a7;
      if ( a6 < (signed __int16)(v11 - a8) )
        goto LABEL_37;
      if ( 0x7FFF - a8 <= a7 )
        v10 = 0x7FFF - a8;
      v17 = 1;
      if ( a6 > (signed __int16)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10010710() )
    v17 = v17 == 0;
  sub_10012770((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100CB060[v12], 0x400u, &v31, a6);
  byte_100CB45E[v12] = 42;
  byte_100CB45F[v12] = 0;
  v18 = sub_10012770((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_100CB460[v12], 0x400u, &v31, a7);
  byte_100CB85E[v12] = 42;
  byte_100CB85F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100CB860[v12];
    byte_100CB860[v12] = 0;
  }
  else
  {
    v13 = &byte_100CB860[v12];
    v18 = sub_10012770((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_100CB860[v12], 0x400u, &v31, a8);
    byte_100CBC5E[v12] = 42;
    byte_100CBC5F[v12] = 0;
  }
  v20 = off_1005AD34[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_100CB060[v12];
  v21 = a3;
  v26 = "sint16";
  v28 = &byte_100CB460[v12];
  v29 = v13;
  v14 = off_1005AD2C[a1];
  v24 = off_1005AD24[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1001B210();
  sub_10011BC0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10011CB0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1001B220(v15);
  return v17;
}
// 10007810: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 1005AD24: using guessed type char *off_1005AD24[18];
// 1005AD2C: using guessed type char *off_1005AD2C[16];
// 1005AD34: using guessed type char *off_1005AD34[14];

//----- (10014030) --------------------------------------------------------
bool __cdecl sub_10014030(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_1000F7B0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10010710() )
    v17 = v17 == 0;
  sub_10012770((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100CB060[v12], 0x400u, &v31, a6);
  byte_100CB45E[v12] = 42;
  byte_100CB45F[v12] = 0;
  v18 = sub_10012770((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_100CB460[v12], 0x400u, &v31, a7);
  byte_100CB85E[v12] = 42;
  byte_100CB85F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100CB860[v12];
    byte_100CB860[v12] = 0;
  }
  else
  {
    v18 = sub_10012770((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_100CB860[v12];
    _snprintf(&byte_100CB860[v12], 0x400u, &v31, a8);
    byte_100CBC5E[v12] = 42;
    byte_100CBC5F[v12] = 0;
  }
  v20 = off_1005AD34[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "sint32";
  v27 = &byte_100CB060[v12];
  v28 = &byte_100CB460[v12];
  v29 = v13;
  v14 = off_1005AD24[v17 != 0];
  v25 = off_1005AD2C[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1001B210();
  sub_10011BC0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10011CB0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1001B220(v15);
  return v17;
}
// 10007810: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 1005AD24: using guessed type char *off_1005AD24[18];
// 1005AD2C: using guessed type char *off_1005AD2C[16];
// 1005AD34: using guessed type char *off_1005AD34[14];

//----- (100143F0) --------------------------------------------------------
bool __cdecl sub_100143F0(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9)
{
  unsigned int v9; // edx@22
  unsigned int v10; // esi@22
  unsigned int v11; // eax@27
  int v12; // ecx@27
  int v13; // edi@37
  char *v14; // esi@38
  char *v15; // edx@40
  int v16; // ebx@42
  bool v18; // [sp+1Bh] [bp-5Dh]@3
  char v19; // [sp+1Fh] [bp-59h]@37
  unsigned int v20; // [sp+20h] [bp-58h]@1
  int v21; // [sp+30h] [bp-48h]@1
  char *v22; // [sp+3Ch] [bp-3Ch]@40
  int v23; // [sp+40h] [bp-38h]@40
  int v24; // [sp+44h] [bp-34h]@40
  int v25; // [sp+48h] [bp-30h]@40
  char *v26; // [sp+4Ch] [bp-2Ch]@40
  char *v27; // [sp+50h] [bp-28h]@40
  const char *v28; // [sp+54h] [bp-24h]@40
  const char *v29; // [sp+58h] [bp-20h]@40
  const char *v30; // [sp+5Ch] [bp-1Ch]@40
  char *v31; // [sp+60h] [bp-18h]@40
  int v32; // [sp+64h] [bp-14h]@41
  char v33; // [sp+68h] [bp-10h]@37

  v21 = sub_1000F7B0();
  v20 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 1:
      v18 = a6 != a7;
      goto LABEL_35;
    case 2:
      if ( a6 != a7
        && SHIDWORD(a6) >= SHIDWORD(a7)
        && (SHIDWORD(a6) > SHIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || SHIDWORD(a6) > SHIDWORD(a7) )
        goto LABEL_34;
      if ( SHIDWORD(a6) < SHIDWORD(a7) )
      {
LABEL_9:
        v18 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_34:
        v18 = 0;
      }
      else
      {
        v18 = 1;
      }
LABEL_35:
      if ( sub_10010710() )
        v18 = v18 == 0;
      sub_10012770((int)&v33, "%I64d", 6, 0xCu, (double)a6);
      v13 = 3072 * v21;
      _snprintf(&byte_100CB060[3072 * v21], 0x400u, &v33, a6);
      byte_100CB45E[v13] = 42;
      byte_100CB45F[v13] = 0;
      v19 = sub_10012770((int)&v33, "%I64d", 6, 0xCu, (double)a7);
      _snprintf(&byte_100CB460[3072 * v21], 0x400u, &v33, a7);
      byte_100CB85E[v13] = 42;
      byte_100CB85F[v13] = 0;
      if ( v20 <= 9 )
      {
        v14 = &byte_100CB860[v13];
        byte_100CB860[v13] = 0;
      }
      else
      {
        v19 = sub_10012770((int)&v33, "%I64d", 6, 0xCu, (double)a8);
        v14 = &byte_100CB860[v13];
        _snprintf(&byte_100CB860[v13], 0x400u, &v33, a8);
        byte_100CBC5E[v13] = 42;
        byte_100CBC5F[v13] = 0;
      }
      v22 = off_1005AD34[a2];
      v24 = a4;
      v25 = a5;
      v23 = a3;
      v28 = "sint64";
      v29 = &byte_100CB060[3072 * v21];
      v30 = &byte_100CB460[3072 * v21];
      v15 = off_1005AD2C[a1];
      v26 = off_1005AD24[v18 != 0];
      v27 = v15;
      v31 = v14;
      if ( a9 )
      {
        v32 = a9;
        v20 = 11;
      }
      v16 = sub_1001B210();
      sub_10011BC0(7, (int)&v22, v20);
      if ( v19 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v29, v30) )
      {
        nullsub_1(
          a3,
          a4,
          "Test definition error: Floating point values differ by less than the floating point output precision. The outp"
          "ut can not accurately represent the difference between the actual and expected values in this test case.");
        sub_10011CB0(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_1001B220(v16);
      return v18;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 5:
      if ( a6 != a7
        && SHIDWORD(a6) <= SHIDWORD(a7)
        && (SHIDWORD(a6) < SHIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      v18 = 1;
      goto LABEL_35;
    case 6:
      v9 = a8;
      v10 = HIDWORD(a8) + 2147483648;
      if ( (signed int)(HIDWORD(a8) + 2147483648) < SHIDWORD(a7)
        || (signed int)(HIDWORD(a8) + 2147483648) <= SHIDWORD(a7) && (unsigned int)a8 < (unsigned int)a7 )
      {
        v10 = HIDWORD(a7);
        v9 = a7;
      }
      if ( a6 < (signed __int64)(__PAIR__(v10, v9) - a8) )
        goto LABEL_50;
      v11 = -1 - a8;
      v12 = 0x7FFFFFFF - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > SHIDWORD(a7) || v12 >= SHIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_50:
        v18 = 0;
        v20 = 10;
      }
      else
      {
        v18 = 1;
        v20 = 10;
      }
      goto LABEL_35;
    default:
      goto LABEL_34;
  }
}
// 10007810: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 1005AD24: using guessed type char *off_1005AD24[18];
// 1005AD2C: using guessed type char *off_1005AD2C[16];
// 1005AD34: using guessed type char *off_1005AD34[14];

//----- (10014930) --------------------------------------------------------
bool __cdecl sub_10014930(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9)
{
  int v9; // edi@1
  char v10; // al@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1000F7B0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 128;
      if ( v11 < a7 )
        LOBYTE(v11) = a7;
      if ( a6 < (char)(v11 - a8) )
        goto LABEL_37;
      if ( 127 - a8 <= a7 )
        v10 = 127 - a8;
      v17 = 1;
      if ( a6 > (char)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10010710() )
    v17 = v17 == 0;
  sub_10012770((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100CB060[v12], 0x400u, &v31, a6);
  byte_100CB45E[v12] = 42;
  byte_100CB45F[v12] = 0;
  v18 = sub_10012770((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_100CB460[v12], 0x400u, &v31, a7);
  byte_100CB85E[v12] = 42;
  byte_100CB85F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100CB860[v12];
    byte_100CB860[v12] = 0;
  }
  else
  {
    v13 = &byte_100CB860[v12];
    v18 = sub_10012770((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_100CB860[v12], 0x400u, &v31, a8);
    byte_100CBC5E[v12] = 42;
    byte_100CBC5F[v12] = 0;
  }
  v20 = off_1005AD34[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_100CB060[v12];
  v21 = a3;
  v26 = "sint8";
  v28 = &byte_100CB460[v12];
  v29 = v13;
  v14 = off_1005AD2C[a1];
  v24 = off_1005AD24[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1001B210();
  sub_10011BC0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10011CB0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1001B220(v15);
  return v17;
}
// 10007810: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 1005AD24: using guessed type char *off_1005AD24[18];
// 1005AD2C: using guessed type char *off_1005AD2C[16];
// 1005AD34: using guessed type char *off_1005AD34[14];

//----- (10014D10) --------------------------------------------------------
bool __cdecl sub_10014D10(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_1000F7B0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10010710() )
    v17 = v17 == 0;
  sub_10012770((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100CB060[v12], 0x400u, &v31, a6);
  byte_100CB45E[v12] = 42;
  byte_100CB45F[v12] = 0;
  v18 = sub_10012770((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_100CB460[v12], 0x400u, &v31, a7);
  byte_100CB85E[v12] = 42;
  byte_100CB85F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100CB860[v12];
    byte_100CB860[v12] = 0;
  }
  else
  {
    v18 = sub_10012770((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_100CB860[v12];
    _snprintf(&byte_100CB860[v12], 0x400u, &v31, a8);
    byte_100CBC5E[v12] = 42;
    byte_100CBC5F[v12] = 0;
  }
  v20 = off_1005AD34[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "long int";
  v27 = &byte_100CB060[v12];
  v28 = &byte_100CB460[v12];
  v29 = v13;
  v14 = off_1005AD24[v17 != 0];
  v25 = off_1005AD2C[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1001B210();
  sub_10011BC0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10011CB0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1001B220(v15);
  return v17;
}
// 10007810: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 1005AD24: using guessed type char *off_1005AD24[18];
// 1005AD2C: using guessed type char *off_1005AD2C[16];
// 1005AD34: using guessed type char *off_1005AD34[14];

//----- (100150D0) --------------------------------------------------------
bool __cdecl sub_100150D0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1000F7B0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10010710() )
    v17 = v17 == 0;
  sub_10012770((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100CB060[v12], 0x400u, &v31, a6);
  byte_100CB45E[v12] = 42;
  byte_100CB45F[v12] = 0;
  v18 = sub_10012770((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_100CB460[v12], 0x400u, &v31, a7);
  byte_100CB85E[v12] = 42;
  byte_100CB85F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100CB860[v12];
    byte_100CB860[v12] = 0;
  }
  else
  {
    v18 = sub_10012770((int)&v31, "%u", 3, 0xCu, (double)a8);
    v13 = &byte_100CB860[v12];
    _snprintf(&byte_100CB860[v12], 0x400u, &v31, a8);
    byte_100CBC5E[v12] = 42;
    byte_100CBC5F[v12] = 0;
  }
  v20 = off_1005AD34[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned int";
  v29 = v13;
  v14 = off_1005AD24[v17 != 0];
  v25 = off_1005AD2C[a1];
  v24 = v14;
  v27 = &byte_100CB060[v12];
  v28 = &byte_100CB460[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1001B210();
  sub_10011BC0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10011CB0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1001B220(v15);
  return v17;
}
// 10007810: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 1005AD24: using guessed type char *off_1005AD24[18];
// 1005AD2C: using guessed type char *off_1005AD2C[16];
// 1005AD34: using guessed type char *off_1005AD34[14];

//----- (10015470) --------------------------------------------------------
bool __cdecl sub_10015470(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9)
{
  int v9; // edi@1
  unsigned __int16 v10; // ax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1000F7B0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int16)(v10 - a8) )
        goto LABEL_37;
      v11 = 0xFFFF - a8;
      if ( v11 > a7 )
        LOWORD(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int16)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10010710() )
    v17 = v17 == 0;
  sub_10012770((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100CB060[v12], 0x400u, &v31, a6);
  byte_100CB45E[v12] = 42;
  byte_100CB45F[v12] = 0;
  v18 = sub_10012770((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_100CB460[v12], 0x400u, &v31, a7);
  byte_100CB85E[v12] = 42;
  byte_100CB85F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100CB860[v12];
    byte_100CB860[v12] = 0;
  }
  else
  {
    v13 = &byte_100CB860[v12];
    v18 = sub_10012770((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_100CB860[v12], 0x400u, &v31, a8);
    byte_100CBC5E[v12] = 42;
    byte_100CBC5F[v12] = 0;
  }
  v20 = off_1005AD34[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_100CB060[v12];
  v21 = a3;
  v26 = "uint16";
  v28 = &byte_100CB460[v12];
  v29 = v13;
  v14 = off_1005AD2C[a1];
  v24 = off_1005AD24[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1001B210();
  sub_10011BC0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10011CB0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1001B220(v15);
  return v17;
}
// 10007810: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 1005AD24: using guessed type char *off_1005AD24[18];
// 1005AD2C: using guessed type char *off_1005AD2C[16];
// 1005AD34: using guessed type char *off_1005AD34[14];

//----- (10015870) --------------------------------------------------------
bool __cdecl sub_10015870(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1000F7B0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10010710() )
    v17 = v17 == 0;
  sub_10012770((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100CB060[v12], 0x400u, &v31, a6);
  byte_100CB45E[v12] = 42;
  byte_100CB45F[v12] = 0;
  v18 = sub_10012770((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_100CB460[v12], 0x400u, &v31, a7);
  byte_100CB85E[v12] = 42;
  byte_100CB85F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100CB860[v12];
    byte_100CB860[v12] = 0;
  }
  else
  {
    v18 = sub_10012770((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_100CB860[v12];
    _snprintf(&byte_100CB860[v12], 0x400u, &v31, a8);
    byte_100CBC5E[v12] = 42;
    byte_100CBC5F[v12] = 0;
  }
  v20 = off_1005AD34[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "uint32";
  v29 = v13;
  v14 = off_1005AD24[v17 != 0];
  v25 = off_1005AD2C[a1];
  v24 = v14;
  v27 = &byte_100CB060[v12];
  v28 = &byte_100CB460[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1001B210();
  sub_10011BC0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10011CB0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1001B220(v15);
  return v17;
}
// 10007810: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 1005AD24: using guessed type char *off_1005AD24[18];
// 1005AD2C: using guessed type char *off_1005AD2C[16];
// 1005AD34: using guessed type char *off_1005AD34[14];

//----- (10015C10) --------------------------------------------------------
bool __cdecl sub_10015C10(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9)
{
  unsigned int v9; // esi@22
  unsigned int v10; // edx@23
  unsigned int v11; // eax@26
  unsigned int v12; // ecx@26
  int v13; // edi@36
  char *v14; // ebx@36
  char *v15; // esi@37
  char *v16; // ecx@39
  int v17; // ebx@41
  bool v19; // [sp+18h] [bp-64h]@3
  char v20; // [sp+27h] [bp-55h]@36
  unsigned int v21; // [sp+28h] [bp-54h]@1
  int v22; // [sp+2Ch] [bp-50h]@1
  char *v23; // [sp+2Ch] [bp-50h]@36
  char *v24; // [sp+40h] [bp-3Ch]@39
  int v25; // [sp+44h] [bp-38h]@39
  int v26; // [sp+48h] [bp-34h]@39
  int v27; // [sp+4Ch] [bp-30h]@39
  char *v28; // [sp+50h] [bp-2Ch]@39
  char *v29; // [sp+54h] [bp-28h]@39
  const char *v30; // [sp+58h] [bp-24h]@39
  const char *v31; // [sp+5Ch] [bp-20h]@39
  const char *v32; // [sp+60h] [bp-1Ch]@39
  char *v33; // [sp+64h] [bp-18h]@39
  int v34; // [sp+68h] [bp-14h]@40
  char v35; // [sp+6Ch] [bp-10h]@36

  v22 = sub_1000F7B0();
  v21 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 1:
      v19 = a6 != a7;
      goto LABEL_34;
    case 2:
      if ( a6 != a7 && HIDWORD(a6) >= HIDWORD(a7) && (HIDWORD(a6) > HIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
        goto LABEL_33;
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || HIDWORD(a6) > HIDWORD(a7) )
        goto LABEL_33;
      if ( HIDWORD(a6) < HIDWORD(a7) )
      {
LABEL_9:
        v19 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_33:
        v19 = 0;
      }
      else
      {
        v19 = 1;
      }
LABEL_34:
      if ( sub_10010710() )
        v19 = v19 == 0;
      sub_10012770((int)&v35, "%I64u", 6, 0xCu, (double)a6);
      v13 = 3072 * v22;
      v14 = &byte_100CB060[3072 * v22];
      _snprintf(&byte_100CB060[3072 * v22], 0x400u, &v35, a6);
      byte_100CB45E[v13] = 42;
      byte_100CB45F[v13] = 0;
      v20 = sub_10012770((int)&v35, "%I64u", 6, 0xCu, (double)a7);
      v23 = &byte_100CB460[3072 * v22];
      _snprintf(&byte_100CB460[v13], 0x400u, &v35, a7);
      byte_100CB85E[v13] = 42;
      byte_100CB85F[v13] = 0;
      if ( v21 <= 9 )
      {
        v15 = &byte_100CB860[v13];
        byte_100CB860[v13] = 0;
      }
      else
      {
        v20 = sub_10012770((int)&v35, "%I64u", 6, 0xCu, (double)a8);
        v15 = &byte_100CB860[v13];
        _snprintf(&byte_100CB860[v13], 0x400u, &v35, a8);
        byte_100CBC5E[v13] = 42;
        byte_100CBC5F[v13] = 0;
      }
      v24 = off_1005AD34[a2];
      v27 = a5;
      v26 = a4;
      v33 = v15;
      v25 = a3;
      v30 = "uint64";
      v31 = v14;
      v16 = off_1005AD2C[a1];
      v28 = off_1005AD24[v19 != 0];
      v29 = v16;
      v32 = v23;
      if ( a9 )
      {
        v34 = a9;
        v21 = 11;
      }
      v17 = sub_1001B210();
      sub_10011BC0(7, (int)&v24, v21);
      if ( v20 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v31, v32) )
      {
        nullsub_1(
          a3,
          a4,
          "Test definition error: Floating point values differ by less than the floating point output precision. The outp"
          "ut can not accurately represent the difference between the actual and expected values in this test case.");
        sub_10011CB0(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_1001B220(v17);
      return v19;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 5:
      if ( a6 != a7 && HIDWORD(a6) <= HIDWORD(a7) && (HIDWORD(a6) < HIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 6:
      v9 = HIDWORD(a7);
      if ( a8 < a7 )
      {
        v10 = a7;
      }
      else
      {
        v9 = HIDWORD(a8);
        v10 = a8;
      }
      if ( a6 < __PAIR__(v9, v10) - a8 )
        goto LABEL_49;
      v11 = -1 - a8;
      v12 = -1 - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > HIDWORD(a7) || v12 >= HIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_49:
        v19 = 0;
        v21 = 10;
      }
      else
      {
        v19 = 1;
        v21 = 10;
      }
      goto LABEL_34;
    default:
      goto LABEL_33;
  }
}
// 10007810: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 1005AD24: using guessed type char *off_1005AD24[18];
// 1005AD2C: using guessed type char *off_1005AD2C[16];
// 1005AD34: using guessed type char *off_1005AD34[14];

//----- (100161F0) --------------------------------------------------------
bool __cdecl sub_100161F0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9)
{
  int v9; // edi@1
  unsigned __int8 v10; // al@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1000F7B0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int8)(v10 - a8) )
        goto LABEL_37;
      v11 = 255 - a8;
      if ( v11 > a7 )
        LOBYTE(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int8)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10010710() )
    v17 = v17 == 0;
  sub_10012770((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100CB060[v12], 0x400u, &v31, a6);
  byte_100CB45E[v12] = 42;
  byte_100CB45F[v12] = 0;
  v18 = sub_10012770((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_100CB460[v12], 0x400u, &v31, a7);
  byte_100CB85E[v12] = 42;
  byte_100CB85F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100CB860[v12];
    byte_100CB860[v12] = 0;
  }
  else
  {
    v13 = &byte_100CB860[v12];
    v18 = sub_10012770((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_100CB860[v12], 0x400u, &v31, a8);
    byte_100CBC5E[v12] = 42;
    byte_100CBC5F[v12] = 0;
  }
  v20 = off_1005AD34[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_100CB060[v12];
  v21 = a3;
  v26 = "uint8";
  v28 = &byte_100CB460[v12];
  v29 = v13;
  v14 = off_1005AD2C[a1];
  v24 = off_1005AD24[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1001B210();
  sub_10011BC0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10011CB0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1001B220(v15);
  return v17;
}
// 10007810: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 1005AD24: using guessed type char *off_1005AD24[18];
// 1005AD2C: using guessed type char *off_1005AD2C[16];
// 1005AD34: using guessed type char *off_1005AD34[14];

//----- (100165E0) --------------------------------------------------------
bool __cdecl sub_100165E0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1000F7B0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10010710() )
    v17 = v17 == 0;
  sub_10012770((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100CB060[v12], 0x400u, &v31, a6);
  byte_100CB45E[v12] = 42;
  byte_100CB45F[v12] = 0;
  v18 = sub_10012770((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_100CB460[v12], 0x400u, &v31, a7);
  byte_100CB85E[v12] = 42;
  byte_100CB85F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100CB860[v12];
    byte_100CB860[v12] = 0;
  }
  else
  {
    v18 = sub_10012770((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_100CB860[v12];
    _snprintf(&byte_100CB860[v12], 0x400u, &v31, a8);
    byte_100CBC5E[v12] = 42;
    byte_100CBC5F[v12] = 0;
  }
  v20 = off_1005AD34[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned long int";
  v29 = v13;
  v14 = off_1005AD24[v17 != 0];
  v25 = off_1005AD2C[a1];
  v24 = v14;
  v27 = &byte_100CB060[v12];
  v28 = &byte_100CB460[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1001B210();
  sub_10011BC0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10011CB0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1001B220(v15);
  return v17;
}
// 10007810: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 1005AD24: using guessed type char *off_1005AD24[18];
// 1005AD2C: using guessed type char *off_1005AD2C[16];
// 1005AD34: using guessed type char *off_1005AD34[14];

//----- (10016980) --------------------------------------------------------
int sub_10016980()
{
  int v0; // esi@1
  int result; // eax@1

  v0 = sub_1000F7B0();
  sub_100126D0(1);
  sub_10012A60(-1);
  result = sub_100129F0(-1);
  dword_100CEC60[v0] = 0;
  return result;
}
// 100CEC60: using guessed type int dword_100CEC60[];

//----- (100169B0) --------------------------------------------------------
BOOL __usercall sub_100169B0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6)
{
  const char **v6; // ebp@1
  _BYTE *v7; // esi@1
  int v8; // edi@1
  int v9; // esi@6
  const char *v11; // [sp+Ch] [bp-34h]@6
  char v12; // [sp+10h] [bp-30h]@1
  char v13; // [sp+20h] [bp-20h]@1
  char v14; // [sp+30h] [bp-10h]@1

  v6 = a6;
  v7 = a1;
  LOBYTE(a6) = 0;
  v8 = sub_1000F7B0();
  sub_1001B250((int)&v13);
  sub_1001B250((int)&v14);
  sub_1001B250((int)&v12);
  if ( !v7 || !*v7 )
  {
    v11 = "Actual file not supplied";
    goto LABEL_13;
  }
  if ( !a2 || !*a2 )
  {
    v11 = "Expected file not supplied";
LABEL_13:
    v9 = 1;
    goto LABEL_14;
  }
  if ( sub_1001BEA0((int (__cdecl *)(unsigned int))sub_10012950, v7, (int)&v13) )
  {
    if ( sub_1001BEA0((int (__cdecl *)(unsigned int))sub_10012950, a2, (int)&v14) )
    {
      v9 = sub_1001BD10(
             dword_100D0D6C[v8],
             (int)&v13,
             (int)&v14,
             a3,
             a4,
             (int (__cdecl *)(unsigned int))sub_10012950,
             (void (__cdecl *)(_DWORD))sub_10012970,
             (int)&v12,
             (char *)&a6,
             &v11);
      if ( (_BYTE)a6 )
        sub_1001C140((int)&v12, a5);
    }
    else
    {
      v11 = "Expected bitmap file read failed";
      v9 = 2;
    }
  }
  else
  {
    v11 = "Actual bitmap file read failed";
    v9 = 2;
  }
LABEL_14:
  sub_1001B320((void (__cdecl *)(_DWORD))sub_10012970, (int)&v12);
  sub_1001B320((void (__cdecl *)(_DWORD))sub_10012970, (int)&v13);
  sub_1001B320((void (__cdecl *)(_DWORD))sub_10012970, (int)&v14);
  if ( v6 )
    *v6 = v11;
  return v9 == 0;
}
// 100D0D6C: using guessed type int dword_100D0D6C[];

//----- (10016B20) --------------------------------------------------------
bool __usercall sub_10016B20@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9)
{
  const char *v9; // ebp@1
  const char *v10; // esi@1
  unsigned int v11; // ebx@8
  unsigned int v12; // edi@8
  bool v13; // zf@11
  bool v14; // bl@13
  int v15; // esi@15
  char *v16; // eax@15
  char *v17; // edx@15
  char *v18; // ecx@15
  int v19; // esi@16
  int v20; // edi@18
  const char *v22; // [sp+14h] [bp-148h]@1
  int v23; // [sp+18h] [bp-144h]@1
  int v24; // [sp+24h] [bp-138h]@1
  int v25; // [sp+28h] [bp-134h]@1
  char *v26; // [sp+2Ch] [bp-130h]@15
  int v27; // [sp+30h] [bp-12Ch]@15
  int v28; // [sp+34h] [bp-128h]@15
  int v29; // [sp+38h] [bp-124h]@15
  char *v30; // [sp+3Ch] [bp-120h]@15
  char *v31; // [sp+40h] [bp-11Ch]@15
  const char *v32; // [sp+44h] [bp-118h]@15
  char *v33; // [sp+48h] [bp-114h]@15
  char *v34; // [sp+4Ch] [bp-110h]@15
  int v35; // [sp+50h] [bp-10Ch]@16
  int v36; // [sp+54h] [bp-108h]@16
  char v37; // [sp+58h] [bp-104h]@9
  char v38; // [sp+156h] [bp-6h]@9
  char v39; // [sp+157h] [bp-5h]@9

  v9 = a6;
  v10 = a7;
  v25 = a2;
  v23 = a1;
  v22 = a7;
  v24 = sub_1000F7B0();
  if ( !a6 )
    v9 = "(NULL)";
  if ( !a7 )
  {
    v22 = "(NULL)";
    v10 = "(NULL)";
  }
  if ( a8 )
  {
    if ( !a4 && !sub_10010710() )
    {
      v11 = strlen(v9);
      v12 = strlen(v10);
      if ( v11 != v12 )
      {
        _snprintf(&v37, 0x100u, "%s - strlen()", v23);
        v38 = 42;
        v39 = 0;
        sub_100150D0(0, 0, (int)"..\\lib\\utf\\utf_verify.c", (int)"2499", (int)&v37, v11, v12, 0, 0);
      }
    }
  }
  if ( !strcmp(v9, v10) )
    v13 = a4 == 0;
  else
    v13 = a4 == 1;
  v14 = v13;
  if ( sub_10010710() )
    v14 = v14 == 0;
  v15 = 3072 * v24;
  _snprintf(&byte_100CB060[3072 * v24], 0x400u, "%s", v9);
  byte_100CB45E[v15] = 42;
  byte_100CB45F[v15] = 0;
  _snprintf(&byte_100CB460[3072 * v24], 0x400u, "%s", v22);
  v16 = off_1005AD34[a4];
  v27 = a5;
  v26 = v16;
  v29 = v23;
  v28 = v25;
  byte_100CB85E[v15] = 42;
  v17 = off_1005AD24[v14 != 0];
  v18 = off_1005AD2C[a3];
  byte_100CB85F[v15] = 0;
  v30 = v17;
  v31 = v18;
  v32 = "string";
  v33 = &byte_100CB060[3072 * v24];
  v34 = &byte_100CB460[3072 * v24];
  if ( a9 )
  {
    v35 = 0;
    v36 = a9;
    v19 = 11;
  }
  else
  {
    v19 = 9;
  }
  v20 = sub_1001B210();
  sub_10011BC0(7, (int)&v26, v19);
  sub_1001B220(v20);
  return v14;
}
// 1005AD24: using guessed type char *off_1005AD24[18];
// 1005AD2C: using guessed type char *off_1005AD2C[16];
// 1005AD34: using guessed type char *off_1005AD34[14];

//----- (10016D90) --------------------------------------------------------
char __cdecl sub_10016D90(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  int v9; // esi@1
  int v10; // esi@4
  char *v11; // eax@4
  char v12; // cl@5
  char *v13; // eax@6
  char v14; // cl@7
  char v15; // bl@8
  char *v16; // edx@10
  bool v17; // zf@10
  int v18; // esi@12
  int v19; // edi@17
  unsigned int v21; // [sp+10h] [bp-258h]@2
  char *v22; // [sp+14h] [bp-254h]@4
  int v23; // [sp+18h] [bp-250h]@1
  char *v24; // [sp+1Ch] [bp-24Ch]@4
  int v25; // [sp+20h] [bp-248h]@1
  char *v26; // [sp+24h] [bp-244h]@4
  char *v27; // [sp+28h] [bp-240h]@4
  int v28; // [sp+2Ch] [bp-23Ch]@1
  int v29; // [sp+30h] [bp-238h]@1
  char *v30; // [sp+34h] [bp-234h]@10
  int v31; // [sp+38h] [bp-230h]@10
  int v32; // [sp+3Ch] [bp-22Ch]@10
  int v33; // [sp+40h] [bp-228h]@10
  char *v34; // [sp+44h] [bp-224h]@10
  char *v35; // [sp+48h] [bp-220h]@10
  const char *v36; // [sp+4Ch] [bp-21Ch]@10
  char *v37; // [sp+50h] [bp-218h]@12
  char *v38; // [sp+54h] [bp-214h]@12
  char *v39; // [sp+58h] [bp-210h]@12
  char *v40; // [sp+5Ch] [bp-20Ch]@14
  char v41[2]; // [sp+64h] [bp-204h]@2
  char v42; // [sp+163h] [bp-105h]@3
  char v43; // [sp+164h] [bp-104h]@14
  char v44; // [sp+263h] [bp-5h]@14

  v28 = a4;
  v23 = a5;
  v25 = a7;
  v9 = sub_1000F7B0();
  v29 = v9;
  if ( a8 == 65278 )
  {
    v21 = dword_100D0D6C[v9] != 0 ? 0x32 : 0;
    strcpy(v41, "0");
  }
  else
  {
    v21 = a8;
    _snprintf(v41, 0x100u, "%u", a8);
    v42 = 0;
  }
  v10 = 560 * v9;
  v22 = &byte_100D2388[v10];
  sub_10012470(a3, 1, a6, 0x230u, &byte_100D2388[v10]);
  v27 = &byte_100CEC88[v10];
  sub_10012470(a3, 2, a7, 0x230u, &byte_100CEC88[v10]);
  v24 = &byte_100D0268[v10];
  sub_10012470(a3, 3, a6, 0x230u, &byte_100D0268[v10]);
  v26 = &byte_100D0D80[v10];
  sub_10012470(a3, 4, a7, 0x230u, &byte_100D0D80[v10]);
  _snprintf(&byte_100D1870[v10], 0x230u, "%s_Diff_", a6);
  v11 = &byte_100D1870[v10];
  byte_100D1A9F[v10] = 0;
  do
    v12 = *v11++;
  while ( v12 );
  sub_10012470(a3, 0, v25, 560 - (v11 - &byte_100D1870[v10 + 1]), &byte_100D1870[v10] + v11 - &byte_100D1870[v10 + 1]);
  v13 = &byte_100D1870[v10];
  byte_100D1A9F[v10] = 0;
  do
    v14 = *v13++;
  while ( v14 );
  *(&byte_100D186C[v10] + v13 - &byte_100D1870[v10 + 1]) = 0;
  sub_10012470(a3, 1, (int)&byte_100D1870[v10], 0x230u, &byte_100CA570[v10]);
  sub_10012470(a3, 1, (int)&byte_100D1870[v10], 0x230u, &byte_100CF778[v10]);
  v15 = sub_100169B0(v22, v27, v21, a2 == 1, (int)&byte_100CA570[v10], (const char **)&v22);
  if ( sub_10010710() )
    v15 = v15 == 0;
  v30 = off_1005AD34[a2];
  v32 = v28;
  v33 = v23;
  v31 = a3;
  v36 = "bitmap-strict";
  v16 = off_1005AD2C[a1];
  v34 = off_1005AD24[v15 != 0];
  v17 = dword_100D0D6C[v29] == 0;
  v35 = v16;
  if ( !v17 )
    v36 = "bitmap-lenient";
  v37 = v24;
  v38 = v26;
  v39 = v41;
  v18 = 10;
  if ( !v15 && v22 )
  {
    _snprintf(&v43, 0x100u, "Info: %s", v22);
    v44 = 0;
    v40 = &v43;
    v18 = 11;
  }
  if ( a9 )
    (&v30)[4 * v18++] = (char *)a9;
  v19 = sub_1001B210();
  sub_10011BC0(7, (int)&v30, v18);
  sub_1001B220(v19);
  return v15;
}
// 1005AD24: using guessed type char *off_1005AD24[18];
// 1005AD2C: using guessed type char *off_1005AD2C[16];
// 1005AD34: using guessed type char *off_1005AD34[14];
// 100D0D6C: using guessed type int dword_100D0D6C[];

//----- (10017090) --------------------------------------------------------
bool __cdecl sub_10017090(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v9; // [sp+Ch] [bp-104h]@1
  char v10; // [sp+10Ah] [bp-6h]@1
  char v11; // [sp+10Bh] [bp-5h]@1

  _snprintf(&v9, 0x100u, "%s (ptr diff)", a5);
  v10 = 42;
  v11 = 0;
  return sub_10013870(a1, a2, a3, a4, (int)&v9, a6 - a7, 0, 0, a8);
}

//----- (10017140) --------------------------------------------------------
bool __cdecl sub_10017140(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8)
{
  return sub_10016B20(a5, a4, a1, a2, a3, a6, a7, 1, a8);
}

//----- (10017180) --------------------------------------------------------
const char *__cdecl sub_10017180(int a1, int a2)
{
  const char *result; // eax@3

  if ( a2 <= 0 )
  {
    result = "\x1B[32;40mPASS\x1B[0m";
    if ( !*(_BYTE *)(a1 + 576) )
      result = "PASS";
  }
  else if ( *(_BYTE *)(a1 + 576) )
  {
    result = "\x1B[31;40mFAILED\x1B[0m";
  }
  else
  {
    result = "FAIL";
  }
  return result;
}

//----- (100171C0) --------------------------------------------------------
char __cdecl sub_100171C0(int a1, int *a2, unsigned int a3)
{
  int *v3; // ebx@1
  int v4; // ebp@1
  int v5; // eax@1
  char *v6; // ebp@1
  char *v7; // eax@11
  int v8; // ecx@12
  int v9; // ST44_4@13
  bool v10; // zf@18
  signed int v11; // edx@24
  const char *v12; // eax@32
  _BYTE *v13; // eax@39
  int v14; // eax@44
  bool v15; // sf@44
  char v16; // cl@45
  char *v17; // eax@50
  int v18; // edx@52
  int v19; // edi@53
  unsigned int v20; // eax@53
  const char *v21; // ecx@53
  _DWORD *v22; // edx@53
  int v23; // esi@57
  int v24; // eax@58
  _BYTE *v25; // ecx@58
  _BYTE *v26; // edx@58
  int v27; // eax@60
  _BYTE *v28; // ecx@60
  _BYTE *v29; // edx@60
  _BYTE *v30; // ecx@62
  _BYTE *v31; // edx@62
  signed int v32; // eax@64
  signed int v33; // edi@73
  int v34; // esi@74
  int v35; // ecx@76
  int v36; // edx@82
  int v37; // eax@83
  int *v38; // eax@106
  void *v39; // ebx@106
  void *v40; // edi@109
  void *v41; // esi@112
  const char *v42; // eax@114
  int v43; // ST30_4@123
  const char *v44; // eax@142
  const char *v45; // eax@148
  char *v47; // [sp-14h] [bp-340h]@69
  char v48; // [sp+12h] [bp-31Ah]@24
  char v49; // [sp+13h] [bp-319h]@21
  signed int v50; // [sp+18h] [bp-314h]@52
  void *v51; // [sp+18h] [bp-314h]@94
  void *v52; // [sp+1Ch] [bp-310h]@97
  void *v53; // [sp+20h] [bp-30Ch]@103
  void *v54; // [sp+24h] [bp-308h]@45
  char v55[508]; // [sp+28h] [bp-304h]@11
  char v56; // [sp+224h] [bp-108h]@44
  char v57; // [sp+227h] [bp-105h]@11
  char v58; // [sp+228h] [bp-104h]@123
  char v59; // [sp+327h] [bp-5h]@123

  v3 = a2;
  v4 = sub_1000F7B0();
  LOBYTE(v5) = a1;
  v6 = (char *)&unk_100D2E80 + 580 * v4;
  switch ( a1 )
  {
    case 0:
      LOBYTE(v5) = sub_10012420((int)v6, 0);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_100123D0((int)v6, "Resetting test status\r\n");
      return v5;
    case 1:
      LOBYTE(v5) = sub_10011F40((int)v6);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_100123D0((int)v6, "Clearing test status\r\n");
      return v5;
    case 11:
      LOBYTE(v5) = sub_10012420((int)v6, 0);
      return v5;
    case 4:
      sub_10011DC0((int)v6, *a2);
      if ( v6[577] && !v6[578] )
      {
        v7 = sub_100120F0((char *)a2[1]);
        _snprintf(v55, 0x200u, "Test Suite: %s (%s)\r\n", *a2, v7);
        v57 = 0;
        sub_100123D0((int)v6, v55);
      }
      LOBYTE(v5) = 0;
      v8 = (int)&v6[16 * *(_DWORD *)v6 + 4];
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      *(_DWORD *)(v8 + 8) = 0;
      *(_DWORD *)(v8 + 12) = 0;
      return v5;
    case 5:
      v9 = *a2;
      LOBYTE(v5) = sub_10011DB0((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Group: %s - Begin\r\n\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 6:
      LOBYTE(v5) = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8] = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4] = 0;
      v10 = v6[577] == 0;
      *((_DWORD *)v6 + 143) = 0;
      if ( !v10 && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Case: %s\r\n\r\n", *a2);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_100123D0((int)v6, v55);
      }
      return v5;
    case 7:
      v49 = sub_100117B0((int)a2, a3);
      if ( !v49 && !v6[577] )
        goto LABEL_83;
      if ( v6[578] )
        goto LABEL_81;
      v11 = 0;
      v48 = 0;
      if ( a3 > 7 )
        v11 = strlen((const char *)a2[7]);
      if ( a3 > 8 )
        v11 += strlen((const char *)a2[8]);
      if ( a3 > 3 )
        v11 += strlen((const char *)a2[3]);
      if ( v11 > 100 )
        v48 = 1;
      v12 = sub_10017180((int)v6, (unsigned __int8)v49);
      _snprintf(v55, 0x200u, "%s ", v12);
      v57 = 0;
      sub_100123D0((int)v6, v55);
      if ( a3 > 7 )
      {
        _snprintf(v55, 0x200u, " ACT: %-17s", a2[7]);
        v57 = 0;
        sub_100123D0((int)v6, v55);
        if ( v48 )
          sub_100123D0((int)v6, "\r\n     ");
      }
      if ( a3 > 8 )
      {
        _snprintf(v55, 0x200u, " EXP: %-17s", a2[8]);
        v57 = 0;
        sub_100123D0((int)v6, v55);
        if ( v48 )
          sub_100123D0((int)v6, "\r\n     ");
      }
      if ( a3 > 9 )
      {
        v13 = (_BYTE *)a2[9];
        if ( v13 )
        {
          if ( *v13 )
          {
            if ( memcmp((const void *)a2[9], "0", 2u) )
            {
              _snprintf(v55, 0x200u, " TOL: %-17s", a2[9]);
              v57 = 0;
              sub_100123D0((int)v6, v55);
              if ( v48 )
                sub_100123D0((int)v6, "\r\n     ");
            }
          }
        }
      }
      v14 = _snprintf(v55, 0x1FCu, " %s", a2[3]);
      v15 = v14 < 0;
      v56 = 0;
      if ( v14 > 0 )
      {
        do
        {
          v16 = *((_BYTE *)&v54 + v14 + 3);
          if ( v16 != 10 && v16 != 13 )
            break;
          *((_BYTE *)&v54 + --v14 + 4) = 0;
        }
        while ( v14 > 0 );
        v15 = v14 < 0;
      }
      if ( !v15 )
      {
        v17 = &v55[v14];
        *(_WORD *)v17 = 2573;
        v17[2] = 0;
      }
      sub_100123D0((int)v6, v55);
      if ( a3 <= 0xA )
        goto LABEL_72;
      v18 = 10;
      v50 = 10;
      if ( (signed int)a3 <= 10 )
        goto LABEL_72;
      do
      {
        v19 = v3[v18];
        v20 = 6;
        v21 = "Info: ";
        v22 = (_DWORD *)v3[v18];
        do
        {
          if ( *v22 != *(_DWORD *)v21 )
            goto LABEL_57;
          v20 -= 4;
          v21 += 4;
          ++v22;
        }
        while ( v20 >= 4 );
        if ( !v20 )
          goto LABEL_67;
LABEL_57:
        v23 = *(_BYTE *)v22 - *v21;
        if ( *(_BYTE *)v22 == *v21 )
        {
          v24 = v20 - 1;
          v25 = v21 + 1;
          v26 = (char *)v22 + 1;
          if ( !v24
            || (v23 = *v26 - *v25, *v26 == *v25)
            && ((v27 = v24 - 1, v28 = v25 + 1, v29 = v26 + 1, !v27)
             || (v23 = *v29 - *v28, *v29 == *v28)
             && ((v30 = v28 + 1, v31 = v29 + 1, v27 == 1) || (v23 = *v31 - *v30, *v31 == *v30))) )
          {
            v3 = a2;
LABEL_67:
            v32 = 0;
            goto LABEL_68;
          }
        }
        v3 = a2;
        v32 = 1;
        if ( v23 <= 0 )
          v32 = -1;
LABEL_68:
        if ( v32 )
        {
          _snprintf(v55, 0x200u, "      Post Analysis: %s\r\n", v19);
          v47 = v55;
        }
        else
        {
          _snprintf(v55, 0x200u, "      Compare Info: %s\r\n", v19 + 6);
          v47 = v55;
        }
        v57 = 0;
        sub_100123D0((int)v6, v47);
        v18 = v50++ + 1;
      }
      while ( v50 < (signed int)a3 );
LABEL_72:
      if ( v6[309] )
      {
        v33 = 0;
        if ( *((_DWORD *)v6 + 143) > 0 )
        {
          v34 = (int)(v6 + 336);
          do
          {
            if ( v33 >= 20 )
              break;
            v35 = *(_DWORD *)(v34 - 4);
            if ( *(_DWORD *)(v34 + 4) )
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s - %s\r\n", v33, v35, *(_DWORD *)v34, *(_DWORD *)(v34 + 4));
            else
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s\r\n", v33, v35, *(_DWORD *)v34);
            v57 = 0;
            sub_100123D0((int)v6, v55);
            ++v33;
            v34 += 12;
          }
          while ( v33 < *((_DWORD *)v6 + 143) );
        }
        _snprintf(v55, 0x200u, "      Location: %s:%s\r\n", v3[1], v3[2]);
        v57 = 0;
        sub_100123D0((int)v6, v55);
      }
LABEL_81:
      if ( v49 )
      {
        v36 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v36 + 4];
        v5 = (int)&v6[v36 + 4];
      }
      else
      {
LABEL_83:
        v37 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v37 + 8];
        v5 = (int)&v6[v37 + 8];
      }
      return v5;
    case 9:
      LOBYTE(v5) = sub_10012020((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "Test Group: %s - End\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 3:
      LOBYTE(v5) = sub_10011AD0((const void **)a2, a3);
      if ( !(_BYTE)v5 && !v6[578] )
      {
        if ( v6[577]
          || sub_10011B90((const void **)a2, a3)
          || (LOBYTE(v5) = sub_100119E0((const void **)a2, a3), (_BYTE)v5) )
        {
          if ( a3 <= 8 )
            v51 = &unk_10047869;
          else
            v51 = (void *)a2[8];
          if ( a3 <= 7 )
            v52 = &unk_10047869;
          else
            v52 = (void *)a2[7];
          if ( a3 <= 6 )
            v54 = &unk_10047869;
          else
            v54 = (void *)a2[6];
          if ( a3 <= 5 )
            v53 = &unk_10047869;
          else
            v53 = (void *)a2[5];
          if ( a3 <= 4 )
          {
            v38 = a2;
            v39 = &unk_10047869;
          }
          else
          {
            v38 = a2;
            v39 = (void *)a2[4];
          }
          if ( a3 <= 3 )
            v40 = &unk_10047869;
          else
            v40 = (void *)v38[3];
          if ( a3 )
            v41 = (void *)*v38;
          else
            v41 = &unk_10047869;
          v10 = sub_10011AA0((const void **)a2, a3) == 0;
          v42 = (const char *)&unk_10047869;
          if ( v10 )
            v42 = "   ";
          _snprintf(v55, 0x200u, "%s%s %s %s %s %s %s %s\r\n", v42, v41, v40, v39, v53, v54, v52, v51);
          v57 = 0;
          LOBYTE(v5) = (unsigned int)sub_100123D0((int)v6, v55);
        }
      }
      return v5;
    case 2:
      if ( v6[578] )
        return v5;
      if ( sub_100117E0((const void **)a2, a3) )
      {
        dword_100D2E78 = 2;
        sub_100123D0((int)v6, (const char *)&word_1005C04C);
        sub_100123D0((int)v6, "   Command Format:\r\n");
        sub_100123D0(
          (int)v6,
          "       <global-command> [<arguments>]  : Runs the global command with the optional arguments\r\n");
        sub_100123D0(
          (int)v6,
          "                                         Commands may consist of multiple words. Arguments may\r\n");
        sub_100123D0(
          (int)v6,
          "                                         or may not be required and will be either booleans,\r\n");
        sub_100123D0(
          (int)v6,
          "                                         integers (32-bit signed or unsigned), floats, or\r\n");
        sub_100123D0((int)v6, "                                         strings depending upon the command\r\n");
        sub_100123D0((int)v6, "       <suite>                         : Runs all the test cases of the test suite\r\n");
        sub_100123D0(
          (int)v6,
          "       <suite> <case>                  : Runs the specific test case of the test suite\r\n");
        sub_100123D0(
          (int)v6,
          "       <suite> <command> [<arguments>] : Runs the test suite specific command with optional arguments\r\n");
        sub_100123D0((int)v6, (const char *)&word_1005C04C);
        sub_100123D0((int)v6, "   Notes:\r\n");
        sub_100123D0((int)v6, "       Commands, suite names and test case names are case-insensitive.\r\n");
        sub_100123D0((int)v6, (const char *)&word_1005C04C);
        sub_100123D0(
          (int)v6,
          "       In the command table below, indentation indicates the command is a sub-command of the unindented\r\n");
        sub_100123D0(
          (int)v6,
          "       command. Each test case and test suite command is shown indented below the test suite. To run\r\n");
        sub_100123D0(
          (int)v6,
          "       a test case or test suite command, you must enter the full command which consists of the both\r\n");
        sub_100123D0((int)v6, "       the suite name and the test case or test suite command.\r\n");
        sub_100123D0((int)v6, (const char *)&word_1005C04C);
        sub_100123D0(
          (int)v6,
          "       In the command table below, ***global-commands*** is a place-holder to identify the set of\r\n");
        sub_100123D0(
          (int)v6,
          "       global commands and is not a real test suite name. The global commands should be entered\r\n");
        sub_100123D0((int)v6, "       without a test suite name.\r\n");
        sub_100123D0((int)v6, (const char *)&word_1005C04C);
        sub_100123D0((int)v6, "   Examples:\r\n");
        sub_100123D0(
          (int)v6,
          "       help                            : Displays a brief help message showing all the test suites\r\n");
        sub_100123D0((int)v6, "       help -q                         : Quite help; Equivalent to help\r\n");
        sub_100123D0(
          (int)v6,
          "       help -v                         : Verbose help; Displays all available help information\r\n");
        sub_100123D0(
          (int)v6,
          "       help utf_validate.c             : Displays verbose help for the utf_validate.c test suite\r\n");
        sub_100123D0(
          (int)v6,
          "       all                             : Will run all the test cases of the test suites\r\n");
        sub_100123D0(
          (int)v6,
          "       utf_validate.c                  : Runs all the test cases of the utf_validate.c suite\r\n");
        sub_100123D0(
          (int)v6,
          "       utf_validate.c FAIL ON          : Enables the failing test cases of the utf_validate.c test suite\r\n");
        sub_100123D0(
          (int)v6,
          "       utf_validate.c Failing_Cases    : Runs the failing test case of the utf_validate.c test suite\r\n");
        sub_100123D0((int)v6, (const char *)&word_1005C04C);
        sub_100123D0((int)v6, "   Command                                 Description\r\n");
        LOBYTE(v5) = (unsigned int)sub_100123D0(
                                     (int)v6,
                                     "   --------------------------------        --------------------------------\r\n");
        return v5;
      }
      if ( sub_10011870((const void **)a2, a3) )
      {
        LOBYTE(v5) = (unsigned int)sub_100123D0((int)v6, (const char *)&word_1005C04C);
        return v5;
      }
      if ( sub_10011840((const void **)a2, a3) )
      {
        _snprintf(&v58, 0x100u, "%s %s", a2[3], a2[4]);
        v43 = a2[5];
        v59 = 0;
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s %s\r\n",
          dword_100D2E78,
          &unk_10047869,
          &v58,
          6 - dword_100D2E78,
          " ",
          v43);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_100123D0((int)v6, v55);
        return v5;
      }
      if ( sub_100118A0((const void **)a2, a3) )
      {
        LOBYTE(v5) = sub_100118D0((int)a2, a3);
        if ( (_BYTE)v5 )
        {
          dword_100D2E78 += 2;
          return v5;
        }
        if ( sub_10011910((int)a2, a3) )
        {
          LOBYTE(v5) = 2;
          if ( dword_100D2E78 < 2 )
            dword_100D2E78 = 0;
          else
            dword_100D2E78 -= 2;
          return v5;
        }
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s group\r\n",
          dword_100D2E78,
          &unk_10047869,
          a2[2],
          6 - dword_100D2E78,
          " ",
          a2[2]);
LABEL_134:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_100123D0((int)v6, v55);
        return v5;
      }
      if ( sub_10011810((const void **)a2, a3) )
      {
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s case\r\n",
          dword_100D2E78,
          &unk_10047869,
          a2[3],
          6 - dword_100D2E78,
          " ",
          a2[3]);
        goto LABEL_134;
      }
      if ( sub_10011980((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s Runs the %s suite\r\n", a2[1], a2[1]);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_100123D0((int)v6, v55);
      }
      else if ( sub_10011950((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s A test results listener\r\n", a2[1]);
LABEL_17:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_100123D0((int)v6, v55);
      }
      else
      {
        LOBYTE(v5) = (unsigned int)sub_100123D0((int)v6, "Unknown test help event\r\n");
      }
      return v5;
    case 8:
      if ( v6[577] && !v6[578] )
      {
        v44 = sub_10017180((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        _snprintf(v55, 0x200u, "\r\n   Test Case Results: %s\r\n", v44);
        v57 = 0;
        sub_100123D0((int)v6, v55);
        _snprintf(v55, 0x200u, "      Passed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8]);
        v57 = 0;
        sub_100123D0((int)v6, v55);
        _snprintf(v55, 0x200u, "      Failed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        v57 = 0;
        sub_100123D0((int)v6, v55);
      }
      v5 = (int)&v6[16 * *(_DWORD *)v6];
      if ( *(_DWORD *)(v5 + 4) )
        ++*(_DWORD *)(v5 + 12);
      else
        ++*(_DWORD *)(v5 + 16);
      return v5;
    case 10:
      if ( v6[577] && !v6[578] )
      {
        v45 = sub_10017180((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        _snprintf(v55, 0x200u, "\r\nTest Suite Results: %s\r\n", v45);
        v57 = 0;
        sub_100123D0((int)v6, v55);
        _snprintf(v55, 0x200u, "   Passed Cases: %4d\r\n", *(_DWORD *)&v6[16 * (*(_DWORD *)v6 + 1)]);
        v57 = 0;
        sub_100123D0((int)v6, v55);
        _snprintf(v55, 0x200u, "   Failed Cases: %4d\r\n\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        v57 = 0;
        sub_100123D0((int)v6, v55);
      }
      LOBYTE(v5) = sub_10012080((int)v6, 0);
      return v5;
    case 12:
      LOBYTE(v5) = sub_10012350((int)v6, 0);
      return v5;
    case 13:
      if ( a3 >= 2 )
      {
        v5 = *((_DWORD *)v6 + 143);
        if ( v5 < 20 )
        {
          *(_DWORD *)&v6[12 * v5 + 332] = *a2;
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143) + 28)] = a2[1];
          v5 = 3 * *((_DWORD *)v6 + 143);
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143))++ + 340] = a2[2];
        }
      }
      return v5;
    case 14:
      --*((_DWORD *)v6 + 143);
      return v5;
    default:
      if ( !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_100123D0((int)v6, "Unknown test event\r\n");
      return v5;
  }
}
// 1005C04C: using guessed type __int16 word_1005C04C;
// 100D2E78: using guessed type int dword_100D2E78;
// 100171C0: using guessed type char var_304[508];

//----- (10017F70) --------------------------------------------------------
signed int __cdecl sub_10017F70(int a1, int a2)
{
  char *v2; // eax@1

  v2 = (char *)&unk_100D2E80 + 580 * sub_1000F7B0();
  if ( a1 == 12 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[576] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else if ( a1 == 13 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[577] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else
  {
    if ( a1 != 14 )
      return sub_10011F80(a1, a2, (int)v2);
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[578] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  return 9;
}

//----- (10017FF0) --------------------------------------------------------
char **__cdecl sub_10017FF0(int a1)
{
  char *v1; // eax@1

  v1 = (char *)&unk_100D2E80 + 580 * sub_1000F7B0();
  v1[576] = 1;
  v1[577] = 1;
  v1[578] = 0;
  sub_10012190((int)v1, a1, (int)".txt");
  return &off_1005B418;
}
// 1005B418: using guessed type char *off_1005B418;

//----- (10018030) --------------------------------------------------------
int (**sub_10018030())()
{
  return off_1005C108;
}
// 1005C108: using guessed type int (*off_1005C108[2])();

//----- (10018040) --------------------------------------------------------
int (__cdecl *__cdecl sub_10018040(const char *a1))(const char *)
{
  int v1; // eax@1

  v1 = sub_1000F7B0();
  return sub_100123D0((int)&unk_100D39D8 + 1812 * v1, a1);
}

//----- (10018060) --------------------------------------------------------
const char *sub_10018060()
{
  return "See version control for test execution date";
}

//----- (10018070) --------------------------------------------------------
__int64 sub_10018070()
{
  return 0i64;
}

//----- (10018080) --------------------------------------------------------
const char *sub_10018080()
{
  return "Not Available";
}

//----- (10018090) --------------------------------------------------------
int __usercall sub_10018090@<eax>(_BYTE *a1@<edi>, int a2)
{
  char v2; // al@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // cl@3
  _BYTE *v6; // edx@4

  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    v4 = *(_BYTE *)(v3 + a2);
    if ( !v4 )
      break;
    v5 = *a1;
    if ( *a1 )
    {
      v6 = a1;
      while ( v5 != v4 )
      {
        v5 = (v6++)[1];
        if ( !v5 )
          goto LABEL_9;
      }
      v2 = 1;
    }
LABEL_9:
    ++v3;
    if ( v2 )
      return v3 - 1;
  }
  if ( v2 )
    --v3;
  return v3;
}

//----- (100180E0) --------------------------------------------------------
signed int __cdecl sub_100180E0(int a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1000F7B0();
  return sub_10011F80(a1, a2, (int)&unk_100D39D8 + 1812 * v2);
}

//----- (10018230) --------------------------------------------------------
int __usercall sub_10018230@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3)
{
  char *v3; // edi@1
  char *v4; // eax@1
  unsigned int v5; // kr00_4@1
  char v6; // cl@1
  char *v7; // eax@4
  char *v8; // eax@4
  char *v9; // eax@5
  unsigned __int8 *v10; // eax@6
  unsigned __int8 *v11; // eax@9
  signed int i; // edi@9
  int result; // eax@11
  int v14; // ecx@11
  unsigned __int8 *v15; // [sp+8h] [bp-10Ch]@9
  unsigned __int8 *v16; // [sp+Ch] [bp-108h]@1
  char v17; // [sp+10h] [bp-104h]@1
  char v18[253]; // [sp+11h] [bp-103h]@3
  char v19; // [sp+10Eh] [bp-6h]@1

  v3 = a1;
  sub_10023B30((int)&a2[151 * (*a2 + 1)], (int)sub_10018040, 0);
  *(_QWORD *)&a2[2 * *a2 + 147] = sub_10018070();
  v4 = sub_1001A920("CFG_StyleSheetDir", (int)"/Starteam/GDU1XXX/Verification/Automated_Test_Scripts/Stylesheets/");
  _snprintf(&v17, 0xFFu, v4);
  v19 = 0;
  v5 = strlen(&v17);
  v6 = (char)(&v16)[v5 + 3];
  if ( v6 != 92 && v6 != 47 )
  {
    *(&v17 + v5) = 47;
    v18[v5] = 0;
  }
  sub_10023F80((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<?xml version=\"1.0\" encoding=\"Windows-1252\"?>", 0);
  v7 = sub_1001A920("CFG_StyleSheet", (int)"std_output_frmt.xsl");
  _snprintf((char *)&a2[151 * *a2 + 174], 0x200u, "<?xml-stylesheet type=\"text/xsl\" href=\"%s%s\"?>", &v17, v7);
  BYTE3(a2[151 * *a2 + 301]) = 0;
  sub_10023F80((int)&a2[151 * *a2 + 151], (unsigned __int8 *)&a2[151 * *a2 + 174], 0);
  sub_10023F80((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<!-- saved from url=(0021)http://www.garmin.com -->", 0);
  sub_10023F00((int)&a2[151 * (*a2 + 1)], (int)"TestResults");
  sub_10023D90((int)&a2[151 * (*a2 + 1)], (int)"xmlns", (unsigned __int8 *)"http://www.garmin.com/GATE");
  v8 = sub_1001A920("CFG_OutputTestRevision", (int)"False");
  if ( !sub_1000F860(v8, (int)"True") )
  {
    v9 = strstr(v3, "$Id: ");
    if ( v9 )
      v10 = (unsigned __int8 *)(v9 + 5);
    else
      v10 = (unsigned __int8 *)v3;
    sub_10023FD0((int)&a2[151 * (*a2 + 1)], (int)"Version", v10);
    sub_10023FD0((int)&a2[151 * (*a2 + 1)], (int)"ResultVersion", (unsigned __int8 *)"$Id$");
  }
  sub_10023F00((int)&a2[151 * (*a2 + 1)], (int)"Config");
  sub_10023F00((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
  sub_10023FD0((int)&a2[151 * (*a2 + 1)], (int)"Name", (unsigned __int8 *)"CFG_TestFile");
  v11 = (unsigned __int8 *)sub_100120F0(v3);
  sub_10023FD0((int)&a2[151 * (*a2 + 1)], (int)"Value", v11);
  sub_10023E80((int)&a2[151 * (*a2 + 1)]);
  for ( i = 0; sub_1001A8E0(i, &v15, &v16); ++i )
  {
    sub_10023F00((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
    sub_10023FD0((int)&a2[151 * (*a2 + 1)], (int)"Name", v15);
    sub_10023FD0((int)&a2[151 * (*a2 + 1)], (int)"Value", v16);
    sub_10023E80((int)&a2[151 * (*a2 + 1)]);
  }
  sub_10023E80((int)&a2[151 * (*a2 + 1)]);
  sub_10023F00((int)&a2[151 * (*a2 + 1)], (int)"TestProcedure");
  sub_10023D90((int)&a2[151 * (*a2 + 1)], (int)"name", (unsigned __int8 *)a3);
  result = 0;
  v14 = (int)&a2[4 * *a2 + 1];
  *(_DWORD *)v14 = 0;
  *(_DWORD *)(v14 + 4) = 0;
  *(_DWORD *)(v14 + 8) = 0;
  *(_DWORD *)(v14 + 12) = 0;
  return result;
}
// 10018230: using guessed type char var_103[253];

//----- (100185B0) --------------------------------------------------------
char __cdecl sub_100185B0(int a1, const void **a2, unsigned int a3)
{
  int v3; // ebp@1
  int v4; // eax@1
  char *v5; // ebp@1
  const char *v6; // ebx@3
  int v7; // esi@4
  int v8; // ST14_4@5
  int v9; // eax@12
  const char *v10; // eax@13
  const char *v11; // eax@15
  int v12; // ST14_4@17
  int v13; // ecx@29
  const void *v14; // ST24_4@43
  int v15; // ST04_4@44
  _BYTE *v16; // eax@87
  _BYTE *v17; // eax@94
  _BYTE *v18; // eax@100
  int v19; // ST20_4@104
  unsigned int v20; // esi@105
  _DWORD *v21; // edx@106
  unsigned int v22; // eax@106
  const char *v23; // ecx@106
  int v24; // esi@110
  int v25; // eax@111
  _BYTE *v26; // ecx@111
  _BYTE *v27; // edx@111
  int v28; // eax@113
  _BYTE *v29; // ecx@113
  _BYTE *v30; // edx@113
  _BYTE *v31; // ecx@115
  _BYTE *v32; // edx@115
  bool v33; // zf@117
  bool v34; // sf@117
  signed int v35; // eax@117
  const char *v36; // eax@129
  const char *v37; // eax@131
  const char *v39; // [sp-10h] [bp-124h]@73
  unsigned __int8 *v40; // [sp-Ch] [bp-120h]@73
  char v41; // [sp+9h] [bp-10Bh]@46
  char v42; // [sp+Ah] [bp-10Ah]@46
  char v43; // [sp+Bh] [bp-109h]@46
  const char *v44; // [sp+Ch] [bp-108h]@91
  signed int v45; // [sp+Ch] [bp-108h]@105
  char v46[255]; // [sp+10h] [bp-104h]@5
  char v47; // [sp+10Fh] [bp-5h]@44

  v3 = sub_1000F7B0();
  LOBYTE(v4) = a1;
  v5 = (char *)&unk_100D39D8 + 1812 * v3;
  switch ( a1 )
  {
    case 3:
      if ( sub_10011B30(a2, a3) )
      {
        v6 = (const char *)a2[3];
        do
        {
          v4 = sub_10018090(", \t", (int)v6);
          v7 = v4;
          if ( v4 )
          {
            strncpy(v46, v6, v4);
            v8 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
            v46[v7] = 0;
            sub_10023F00(v8, (int)"Req");
            sub_10023D90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"id", (unsigned __int8 *)v46);
            LOBYTE(v4) = (unsigned int)sub_10023E80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
            v6 += v7;
          }
          else
          {
            ++v6;
          }
        }
        while ( *v6 );
      }
      else if ( sub_10011B00(a2, a3) )
      {
        if ( sub_10012290((int)v5, 3, 1, 0) )
          sub_10023E80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        v9 = *((_DWORD *)v5 + 146);
        if ( v9 > 0 )
        {
          *((_DWORD *)v5 + 146) = v9 - 1;
          sub_10023F00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
          v10 = "true";
          if ( *((_DWORD *)v5 + 144) <= 0 )
            v10 = "false";
          sub_10023D90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v10);
          v11 = "true";
          if ( *((_DWORD *)v5 + 145) <= 0 )
            v11 = "false";
          sub_10023D90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v11);
          sub_10023E80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          v12 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          *((_DWORD *)v5 + 144) = 0;
          *((_DWORD *)v5 + 145) = 0;
          sub_10023E80(v12);
          sub_10023F00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        }
        LOBYTE(v4) = (unsigned int)sub_10023D90(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"title",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_10011A40(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_10023FD0(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"Method",
                                     (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 146);
      }
      else if ( sub_10011B60(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_10023FD0(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"TestType",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_10011AD0(a2, a3) )
      {
        if ( sub_10012290((int)v5, 3, 1, 0) )
          sub_10023E80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_10012200((int)a2, a3, (int)v5);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = sub_10023F00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      }
      else if ( sub_10011A70(a2, a3) )
      {
        sub_10023F00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Results");
        v13 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        if ( *(_BYTE *)a2[3] == 48 )
        {
          sub_10023D90(v13, (int)"success", (unsigned __int8 *)"0");
          sub_10023D90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"error_msg", (unsigned __int8 *)a2[3] + 1);
        }
        else
        {
          sub_10023D90(v13, (int)"success", (unsigned __int8 *)"1");
        }
        if ( v5[309] )
        {
          sub_10023D90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
          sub_10023D90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
        }
        sub_10023E80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_10012290((int)v5, 3, 0, 0);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = (unsigned int)sub_10023E80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      else
      {
        LOBYTE(v4) = sub_10011A10(a2, a3);
        if ( (_BYTE)v4 )
        {
          if ( !sub_10012340((int)v5) )
            sub_10023F00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
          sub_10023FD0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
          LOBYTE(v4) = sub_10012290((int)v5, 3, 0, 1);
          if ( (_BYTE)v4 )
            LOBYTE(v4) = (unsigned int)sub_10023E80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      return v4;
    case 4:
      LOBYTE(v4) = sub_10011DC0((int)v5, (int)*a2);
      if ( (_BYTE)v4 )
        LOBYTE(v4) = sub_10018230((char *)a2[1], v5, (int)*a2);
      return v4;
    case 5:
      v14 = *a2;
      LOBYTE(v4) = sub_10011DB0((int)v5);
      if ( !(_BYTE)v4 )
      {
        sub_10023F00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        _snprintf(v46, 0x100u, "Test Group: %s", *a2);
        v15 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        v47 = 0;
        sub_10023FD0(v15, (int)"Method", (unsigned __int8 *)v46);
        LOBYTE(v4) = (unsigned int)sub_10023E80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      return v4;
    case 6:
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      LOBYTE(v4) = sub_10023F00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
      return v4;
    case 7:
      v41 = 0;
      v42 = 0;
      v43 = 0;
      if ( a3 <= 6 )
        goto LABEL_56;
      if ( !memcmp(a2[6], "bool", 5u) || !memcmp(a2[6], "char", 5u) || !memcmp(a2[6], "string", 7u) )
      {
        v42 = 1;
        goto LABEL_56;
      }
      if ( !memcmp(a2[6], "bitmap", 7u) || !memcmp(a2[6], "bitmap-lenient", 0xFu) )
        goto LABEL_55;
      if ( !memcmp(a2[6], "bitmap-strict", 0xEu) )
      {
        v43 = 1;
LABEL_55:
        v41 = 1;
      }
LABEL_56:
      if ( !*((_DWORD *)v5 + 146) )
      {
        sub_10023FD0(
          (int)&v5[604 * (*(_DWORD *)v5 + 1)],
          (int)"Method",
          (unsigned __int8 *)"Method Placeholder -- Add UTF_grp to test case");
        sub_10023FD0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestType", (unsigned __int8 *)"Low Level Testing");
        ++*((_DWORD *)v5 + 146);
      }
      if ( !sub_10012340((int)v5) )
        sub_10023F00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      if ( sub_100119B0((int)a2, a3) )
      {
        if ( *(_BYTE *)a2[3] )
        {
          sub_10023F00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction");
          sub_10023E30((int)&v5[604 * (*(_DWORD *)v5 + 1)], (unsigned __int8 *)a2[3]);
          sub_10023E80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
        ++*((_DWORD *)v5 + 145);
      }
      else
      {
        if ( *(_BYTE *)a2[3] )
          sub_10023FD0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 144);
      }
      sub_10023F00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Compare");
      if ( sub_100117B0((int)a2, a3) )
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 4];
        sub_10023D90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Fail");
      }
      else
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 8];
        sub_10023D90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Pass");
      }
      sub_10023D90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"type", (unsigned __int8 *)*a2);
      sub_10023D90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"class", (unsigned __int8 *)a2[5]);
      if ( a3 <= 6 )
        goto LABEL_77;
      if ( v41 )
      {
        sub_10023D90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"datatype", (unsigned __int8 *)"bitmap");
        if ( !v43 )
        {
          sub_10023D90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"strict", (unsigned __int8 *)"false");
          goto LABEL_77;
        }
        v40 = (unsigned __int8 *)"true";
        v39 = "strict";
      }
      else
      {
        v40 = (unsigned __int8 *)a2[6];
        v39 = "datatype";
      }
      sub_10023D90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)v39, v40);
LABEL_77:
      if ( v5[309] )
      {
        sub_10023D90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
        sub_10023D90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
      }
      if ( a3 > 7 )
      {
        sub_10023F00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Actual");
        if ( v42 )
          sub_10023DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        else
          sub_10023D90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        sub_10023E80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      if ( a3 > 8 )
      {
        if ( v42 )
        {
          sub_10023F00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Expected");
          sub_10023DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)a2[8]);
          sub_10023E80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          if ( a3 > 9 )
          {
            v16 = a2[9];
            if ( v16 )
            {
              if ( *v16 )
              {
                sub_10023F00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Tolerance");
                sub_10023DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"tolerance", (unsigned __int8 *)a2[9]);
                sub_10023E80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
              }
            }
          }
        }
        else
        {
          if ( v41 )
          {
            v44 = "!";
            if ( memcmp(*a2, "NE", 3u) )
              v44 = (const char *)&unk_10047869;
            if ( a3 > 9 && (v17 = a2[9]) != 0 && *v17 && memcmp(a2[9], "0", 2u) )
              _snprintf(v46, 0x100u, "%s%s+/-%s", v44, a2[8], a2[9]);
            else
              _snprintf(v46, 0x100u, "%s%s", v44, a2[8]);
          }
          else if ( a3 > 9 && (v18 = a2[9]) != 0 && *v18 )
          {
            _snprintf(v46, 0x100u, "N EQ %s(+/-)%s", a2[8], a2[9]);
          }
          else
          {
            _snprintf(v46, 0x100u, "N %s %s", *a2, a2[8]);
          }
          v19 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          v47 = 0;
          sub_10023F00(v19, (int)"Expected");
          sub_10023D90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)v46);
          sub_10023E80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      v20 = 10;
      v45 = 10;
      if ( a3 <= 0xA )
        goto LABEL_125;
      break;
    case 8:
      if ( sub_10012290((int)v5, 8, 1, 0) )
        sub_10023E80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      sub_10023F00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
      v36 = "true";
      if ( *((_DWORD *)v5 + 144) <= 0 )
        v36 = "false";
      sub_10023D90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v36);
      v37 = "true";
      if ( *((_DWORD *)v5 + 145) <= 0 )
        v37 = "false";
      sub_10023D90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v37);
      sub_10023E80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      LOBYTE(v4) = (unsigned int)sub_10023E80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      return v4;
    case 9:
      LOBYTE(v4) = sub_10012020((int)v5);
      return v4;
    case 10:
      LOBYTE(v4) = sub_10012080((int)v5, (void (__cdecl *)(int))sub_10018110);
      return v4;
    case 0:
    case 11:
      sub_10012420((int)v5, (void (__cdecl *)(int))sub_10018110);
      goto LABEL_139;
    case 1:
      sub_10011F40((int)v5);
      goto LABEL_139;
    case 12:
      sub_10012350((int)v5, (void (__cdecl *)(int))sub_10018110);
LABEL_139:
      LOBYTE(v4) = 0;
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      return v4;
    default:
      return v4;
  }
  do
  {
    v21 = a2[v20];
    v22 = 6;
    v23 = "Info: ";
    do
    {
      if ( *v21 != *(_DWORD *)v23 )
        goto LABEL_110;
      v22 -= 4;
      v23 += 4;
      ++v21;
    }
    while ( v22 >= 4 );
    if ( !v22 )
      goto LABEL_120;
LABEL_110:
    v24 = *(_BYTE *)v21 - *v23;
    if ( *(_BYTE *)v21 == *v23 )
    {
      v25 = v22 - 1;
      v26 = v23 + 1;
      v27 = (char *)v21 + 1;
      if ( !v25
        || (v24 = *v27 - *v26, *v27 == *v26)
        && ((v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, !v28)
         || (v24 = *v30 - *v29, *v30 == *v29)
         && ((v31 = v29 + 1, v32 = v30 + 1, v28 == 1) || (v24 = *v32 - *v31, *v32 == *v31))) )
      {
        v20 = v45;
LABEL_120:
        v35 = 0;
        goto LABEL_121;
      }
    }
    v33 = v24 == 0;
    v34 = v24 < 0;
    v20 = v45;
    v35 = 1;
    if ( v34 || v33 )
      v35 = -1;
LABEL_121:
    if ( v35 )
    {
      sub_10023F00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"PostAnalysis");
      sub_10023D90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"note", (unsigned __int8 *)a2[v20]);
      sub_10023E80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    else
    {
      sub_10023F00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"CompareInfo");
      sub_10023D90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"comp_info", (unsigned __int8 *)a2[v20] + 6);
      sub_10023E80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    v45 = ++v20;
  }
  while ( v20 < a3 );
LABEL_125:
  sub_10023E80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  LOBYTE(v4) = sub_10012290((int)v5, 7, 0, 1);
  if ( (_BYTE)v4 )
    LOBYTE(v4) = (unsigned int)sub_10023E80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  return v4;
}
// 10018110: using guessed type int sub_10018110();
// 100185B0: using guessed type char var_104[255];

//----- (100193D0) --------------------------------------------------------
char **__cdecl sub_100193D0(int a1)
{
  char *v1; // esi@1
  int v2; // esi@1
  signed int v3; // edi@1

  v1 = (char *)&unk_100D39D8 + 1812 * sub_1000F7B0();
  *((_DWORD *)v1 + 146) = 0;
  sub_10012190((int)v1, a1, (int)".xml");
  v2 = (int)(v1 + 604);
  v3 = 2;
  do
  {
    sub_10023B30(v2, (int)sub_10018040, 0);
    v2 += 604;
    --v3;
  }
  while ( v3 );
  return &off_1005C1B8;
}
// 1005C1B8: using guessed type char *off_1005C1B8;

//----- (10019490) --------------------------------------------------------
char __thiscall sub_10019490(void *this)
{
  char v1; // di@1
  void *v2; // esi@1
  char v3; // di@3
  void *v4; // esi@3
  char result; // al@4

  dword_100D5D60 = sub_10009F90(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_100D5D68, 0, 0x1540u);
  memset(&unk_100D72A8, 0, 0x19B0u);
  v1 = 0;
  v2 = &unk_100D5D68;
  do
  {
    sub_10019F90(v1, (int)v2);
    v2 = (char *)v2 + 2720;
    ++v1;
  }
  while ( (signed int)v2 < (signed int)&unk_100D72A8 );
  v3 = 0;
  v4 = &unk_100D72A8;
  do
  {
    result = sub_1001A010(v3, (int)v4);
    v4 = (char *)v4 + 2192;
    ++v3;
  }
  while ( (signed int)v4 < (signed int)&unk_100D8C58 );
  return result;
}
// 100D5D60: using guessed type int dword_100D5D60;

//----- (10019520) --------------------------------------------------------
char __cdecl sub_10019520(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_100D5D60 != 1379255385;
  v7 = 0;
  v8 = dword_100D5D60 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10024980(86, 10);
      memset((char *)&unk_100D5D68 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_10019F90(a1, (int)&unk_100D5D68 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 4 * (680 * (unsigned __int8)a1 + v5);
      if ( byte_100D6040[v6] == a2 || byte_100D6041[v6] == a2 )
        break;
      if ( ++v5 >= 8u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_10024950(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100D5D60: using guessed type int dword_100D5D60;

//----- (100195E0) --------------------------------------------------------
char __cdecl sub_100195E0(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_10019520(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (10019610) --------------------------------------------------------
char __thiscall sub_10019610(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10024A80(3190, (int)&v2 + 3, 1);
  return BYTE3(v2);
}

//----- (10019630) --------------------------------------------------------
double __cdecl sub_10019630(char a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  void *v3; // ecx@1
  char v5; // [sp+4h] [bp-Ch]@2
  float v6; // [sp+8h] [bp-8h]@2

  v2 = sub_1001A570(v1);
  if ( sub_10019610(v3) )
    goto LABEL_2;
  if ( a1 )
  {
    if ( v2 )
    {
      sub_10024A80(2015, (int)&v5, 12);
      return v6;
    }
    sub_10024A80(2101, (int)&v5, 12);
  }
  else
  {
    if ( !v2 )
    {
LABEL_2:
      sub_10024A80(2015, (int)&v5, 12);
      return v6;
    }
    sub_10024A80(2101, (int)&v5, 12);
  }
  return v6;
}

//----- (100196B0) --------------------------------------------------------
void sub_100196B0()
{
  sub_10019630(0);
}

//----- (100196C0) --------------------------------------------------------
char __cdecl sub_100196C0(char a1)
{
  char result; // al@1

  result = -80;
  switch ( a1 )
  {
    case 3:
      result = -126;
      break;
    case 4:
      result = -123;
      break;
    case 5:
      result = -108;
      break;
    case 6:
      result = -105;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10019700) --------------------------------------------------------
char __cdecl sub_10019700(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 74;
      break;
    case 1:
      result = 73;
      break;
    case 2:
      result = 75;
      break;
    case 3:
      result = -127;
      break;
    case 4:
      result = -124;
      break;
    case 5:
      result = -109;
      break;
    case 6:
      result = -106;
      break;
    default:
      sub_10009550("..\\lib\\adl\\iop_cdu_unit_intf.c", 564, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (10019770) --------------------------------------------------------
signed int __cdecl sub_10019770(char a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = 4;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 64;
      break;
    case 4:
      result = 128;
      break;
    case 5:
      result = 16;
      break;
    case 6:
      result = 32;
      break;
    default:
      sub_10009550("..\\lib\\adl\\iop_cdu_unit_intf.c", 638, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (100197F0) --------------------------------------------------------
char __cdecl sub_100197F0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 13;
      break;
    case 1:
      result = 12;
      break;
    case 2:
      result = 14;
      break;
    case 3:
      result = -128;
      break;
    case 4:
      result = -125;
      break;
    case 5:
      result = -110;
      break;
    case 6:
      result = -107;
      break;
    default:
      sub_10009550("..\\lib\\adl\\iop_cdu_unit_intf.c", 712, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (10019860) --------------------------------------------------------
char __cdecl sub_10019860(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 3:
      result = 0;
      break;
    case 4:
      result = 1;
      break;
    case 5:
      result = 2;
      break;
    case 0x28:
      result = 3;
      break;
    case 0x29:
      result = 4;
      break;
    case 0x33:
      result = 5;
      break;
    case 0x34:
      result = 6;
      break;
    default:
      sub_10009550("..\\lib\\adl\\iop_cdu_unit_intf.c", 786, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10019910) --------------------------------------------------------
char __cdecl sub_10019910(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 4:
      result = 0;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      sub_10009550("..\\lib\\adl\\iop_cdu_unit_intf.c", 1096, 1, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10019A10) --------------------------------------------------------
char __thiscall sub_10019A10(void *this)
{
  int v1; // eax@1

  v1 = sub_10019A20(this);
  return sub_10019910(v1);
}

//----- (10019A20) --------------------------------------------------------
int __thiscall sub_10019A20(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10009EF0(46, (char *)&v2);
  return (int)v2;
}

//----- (10019A40) --------------------------------------------------------
char __cdecl sub_10019A40(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xA:
    case 0x30:
      result = 0;
      break;
    case 0xB:
    case 0x31:
      result = 1;
      break;
    default:
      sub_10009550("..\\lib\\acl\\iop\\iop_xpdr_cnfg_utl.c", 155, 0, 0);
      result = 2;
      break;
  }
  return result;
}

//----- (10019AC0) --------------------------------------------------------
char __cdecl sub_10019AC0(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_100195E0(11);
  }
  else
  {
    result = sub_100195E0(5);
  }
  return result;
}

//----- (10019AF0) --------------------------------------------------------
char __cdecl sub_10019AF0(char a1)
{
  return byte_10061691[2 * (unsigned __int8)sub_1000D290(&a1, 1u, (int)&unk_10061690, 2, 4, 3)];
}

//----- (10019B20) --------------------------------------------------------
char __cdecl sub_10019B20(char a1, void *a2)
{
  void *v3; // esi@6
  char v4; // al@6

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v3 = a2;
      v4 = sub_10005900(1, 546, a2);
    }
    else
    {
      if ( a1 != 2 )
      {
        sub_10009550("..\\lib\\acl\\iop\\iop_com_intf.c", 187, 0, 0);
        return 0;
      }
      v3 = a2;
      v4 = sub_10024140(a2);
    }
  }
  else
  {
    v3 = a2;
    v4 = sub_10005900(1, 538, a2);
  }
  if ( !v4 || sub_1000EE60((int)v3) )
    return 0;
  return 1;
}

//----- (10019BA0) --------------------------------------------------------
int __cdecl sub_10019BA0(char a1, _DWORD *a2)
{
  int result; // eax@1
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  LOBYTE(result) = sub_10019B20(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (10019BF0) --------------------------------------------------------
int __cdecl sub_10019BF0(char *a1, char a2)
{
  signed int v2; // eax@2
  int result; // eax@4
  int v4; // [sp+8h] [bp-ECh]@1
  char v5; // [sp+24h] [bp-D0h]@4

  v4 = 0;
  if ( a2 == 1 )
    v2 = 2;
  else
    v2 = a2 == 2;
  result = j_HWM_pvg_rgn_get_info(v2, &v4);
  qmemcpy(a1, &v5, 0x74u);
  return result;
}
// 10025800: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (10019C60) --------------------------------------------------------
bool __cdecl sub_10019C60(int a1, void *a2)
{
  void *v2; // ecx@0
  char v3; // si@1
  char v4; // bl@1
  int v5; // esi@4
  bool result; // al@7

  v3 = sub_10019A10(v2);
  v4 = 0;
  do
  {
    if ( (_BYTE)a1 == (char)off_10061C08[(unsigned __int8)v4](v3) )
    {
      sub_10019BF0((char *)a2, v4);
      return 1;
    }
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  v5 = (unsigned __int16)sub_10024120(a1);
  if ( (unsigned __int16)v5 >= (unsigned __int16)sub_10004C60(2) )
    result = 0;
  else
    result = sub_10005900(2, v5, a2) == 1 && !sub_1001A680(a2);
  return result;
}
// 10061C08: using guessed type int (__cdecl *off_10061C08[3])(char);

//----- (10019D20) --------------------------------------------------------
char __cdecl sub_10019D20(int a1, bool *a2)
{
  char result; // al@3
  char v3; // [sp+8h] [bp-78h]@2
  int v4; // [sp+78h] [bp-8h]@3

  switch ( (unsigned __int8)a1 )
  {
    case 1u:
    case 4u:
    case 7u:
    case 0xAu:
      if ( sub_10019C60(a1, &v3) )
      {
        *a2 = (v4 & 1) == 1;
        result = 1;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      *a2 = sub_10024100(a1) != 67;
      result = 1;
      break;
  }
  return result;
}

//----- (10019DE0) --------------------------------------------------------
signed int __cdecl sub_10019DE0(char a1, char a2)
{
  _DWORD *v2; // esi@3
  int v3; // eax@5
  char *v5; // [sp-18h] [bp-20h]@3
  void *v6; // [sp-10h] [bp-18h]@3
  int v7; // [sp-8h] [bp-10h]@3

  if ( a2 == 11 )
  {
    v7 = 3;
    v2 = &unk_10061D08;
    v6 = &unk_10061D08;
    v5 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v7 = 7;
    v2 = &unk_10061D20;
    v6 = &unk_10061D20;
    v5 = &a1;
  }
  v3 = sub_1000D290(v5, 1u, (int)v6, 8, v7, 7);
  if ( v3 < 7 )
    return v2[2 * v3 + 1];
  return 42066;
}

//----- (10019E40) --------------------------------------------------------
int __cdecl sub_10019E40(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1000D290(&a1, 1u, (int)&unk_10061D68, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_10061D6C[2 * v1];
  return result;
}
// 10061D6C: using guessed type int dword_10061D6C[];

//----- (10019E80) --------------------------------------------------------
signed int __cdecl sub_10019E80(char a1, char a2, char a3)
{
  _DWORD *v3; // esi@3
  int v4; // eax@5
  signed int result; // eax@7
  char *v6; // [sp-18h] [bp-20h]@3
  void *v7; // [sp-10h] [bp-18h]@3

  if ( a2 == 11 )
  {
    v3 = &unk_10061D78;
    v7 = &unk_10061D78;
    v6 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v3 = &unk_10061D90;
    v7 = &unk_10061D90;
    v6 = &a1;
  }
  v4 = sub_1000D290(v6, 1u, (int)v7, 12, 2, 2);
  if ( v4 == 2 )
    return 42066;
  if ( a3 )
    result = v3[3 * v4 + 1];
  else
    result = v3[3 * v4 + 2];
  return result;
}

//----- (10019EF0) --------------------------------------------------------
int __cdecl sub_10019EF0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1000D290(&a1, 1u, (int)&unk_10061DA8, 8, 3, 3);
  if ( v1 == 3 )
    result = 42066;
  else
    result = dword_10061DAC[2 * v1];
  return result;
}
// 10061DAC: using guessed type int dword_10061DAC[];

//----- (10019F30) --------------------------------------------------------
int __cdecl sub_10019F30(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1000D290(&a1, 1u, (int)&unk_10061DC0, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_10061DC4[2 * v1];
  return result;
}
// 10061DC4: using guessed type int dword_10061DC4[];

//----- (10019F70) --------------------------------------------------------
char __cdecl sub_10019F70(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10019DE0(a1, 11);
  return sub_10024A00(v2, a2, 24);
}

//----- (10019F90) --------------------------------------------------------
char __cdecl sub_10019F90(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10019E40(a1);
  return sub_10024A00(v2, a2, 2720);
}

//----- (10019FC0) --------------------------------------------------------
char __cdecl sub_10019FC0(char a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@1

  v2 = sub_10019E80(a1, 11, 1);
  sub_10024A00(v2, a2, 36);
  v3 = sub_10019E80(a1, 11, 0);
  return sub_10024A00(v3, a2 + 36, 32);
}

//----- (1001A010) --------------------------------------------------------
char __cdecl sub_1001A010(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10019EF0(a1);
  return sub_10024A00(v2, a2, 2192);
}

//----- (1001A040) --------------------------------------------------------
char __cdecl sub_1001A040(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10019F30(a1);
  return sub_10024A00(v2, a2, 60);
}

//----- (1001A060) --------------------------------------------------------
char __cdecl sub_1001A060(int a1)
{
  return sub_10024A00(6453, a1, 5);
}

//----- (1001A080) --------------------------------------------------------
char __cdecl sub_1001A080(char a1)
{
  char result; // al@4

  switch ( a1 )
  {
    case 25:
      result = 0;
      break;
    case 26:
      result = 1;
      break;
    case 43:
      result = 2;
      break;
    default:
      sub_10009550("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 169, 0, 0);
      result = 3;
      break;
  }
  return result;
}

//----- (1001A0C0) --------------------------------------------------------
char __cdecl sub_1001A0C0(char a1)
{
  char result; // al@3

  if ( a1 == 20 )
  {
    result = 0;
  }
  else if ( a1 == 21 )
  {
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1001A0E0) --------------------------------------------------------
int __cdecl sub_1001A0E0(char a1, char a2)
{
  int v2; // esi@1
  int result; // eax@4

  v2 = dword_10064234[2 * sub_1000D290(&a1, 1u, (int)&unk_10064230, 8, 3, 3)];
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = v2 + dword_10064274[2 * sub_1000D290(&a2, 1u, (int)&unk_10064270, 8, 6, 6)];
    }
    else if ( a1 == 2 )
    {
      result = v2 + dword_100642A4[2 * sub_1000D290(&a2, 1u, (int)&unk_100642A0, 8, 5, 5)];
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = v2 + dword_1006424C[2 * sub_1000D290(&a2, 1u, (int)&unk_10064248, 8, 5, 5)];
  }
  return result;
}
// 10064234: using guessed type int dword_10064234[];
// 1006424C: using guessed type int dword_1006424C[];
// 10064274: using guessed type int dword_10064274[];
// 100642A4: using guessed type int dword_100642A4[];

//----- (1001A190) --------------------------------------------------------
bool __usercall sub_1001A190@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3)
{
  return a2 == 7 && a3 >= (unsigned __int8)byte_1009B30F[44 * a1] - (unsigned __int8)byte_1009B30A[44 * a1];
}

//----- (1001A1C0) --------------------------------------------------------
char __usercall sub_1001A1C0@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6)
{
  int v6; // eax@2
  char result; // al@3
  int v8; // eax@4

  if ( sub_1001A190(a1, a4, a5) )
  {
    v6 = a3
       + sub_1001A0E0(a1, 6)
       + 36 * (a5 + (unsigned __int8)byte_1009B30A[44 * a1] - (unsigned __int8)byte_1009B30F[44 * a1]);
    if ( *(_BYTE *)(v6 + 2) == 6 )
    {
      memcpy(a6, (const void *)(v6 + 4), a2);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v8 = sub_1001A0E0(a1, a4);
    memcpy(a6, (const void *)(a3 + v8 + a2 * a5), a2);
    result = 1;
  }
  return result;
}

//----- (1001A260) --------------------------------------------------------
char __cdecl sub_1001A260(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1000B870(a1);
  sub_10024A00(v5, (int)&v7, 3684);
  return sub_1001A1C0(a2, 0x2Cu, (int)&v7, a3, a4, a5);
}

//----- (1001A2E0) --------------------------------------------------------
char __cdecl sub_1001A2E0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1000B870(a1);
  sub_10024A00(v5, (int)&v7, 3684);
  return sub_1001A1C0(a2, 3u, (int)&v7, a3, a4, a5);
}

//----- (1001A360) --------------------------------------------------------
char __cdecl sub_1001A360(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1000B870(a1);
  sub_10024A00(v5, (int)&v7, 3684);
  return sub_1001A1C0(a2, 0x24u, (int)&v7, a3, a4, a5);
}

//----- (1001A3E0) --------------------------------------------------------
char __cdecl sub_1001A3E0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1000B870(a1);
  sub_10024A00(v5, (int)&v7, 3684);
  return sub_1001A1C0(a2, 0xCu, (int)&v7, a3, a4, a5);
}

//----- (1001A460) --------------------------------------------------------
char __cdecl sub_1001A460(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xC:
    case 0x3F:
      result = 0;
      break;
    case 0xD:
    case 0x40:
      result = 1;
      break;
    case 0xE:
    case 0x41:
      result = 2;
      break;
    case 0x2A:
    case 0x42:
      result = 3;
      break;
    default:
      sub_10009550("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_utl.c", 139, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1001A500) --------------------------------------------------------
char __cdecl sub_1001A500(char a1)
{
  char result; // al@3

  if ( a1 == 6 )
  {
    result = 0;
  }
  else if ( a1 == 7 )
  {
    result = 1;
  }
  else
  {
    sub_10009550("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 294, 0, 0);
    result = 2;
  }
  return result;
}

//----- (1001A540) --------------------------------------------------------
char __cdecl sub_1001A540(char a1)
{
  char result; // al@1

  result = sub_10024180();
  if ( result == 2 )
    result = byte_10064DBC[8 * sub_1000D290(&a1, 4u, (int)&unk_10064DB8, 8, 7, 7)];
  return result;
}

//----- (1001A570) --------------------------------------------------------
char __thiscall sub_1001A570(void *this)
{
  char v1; // al@1

  v1 = sub_10019A20(this);
  return sub_1001A540(v1);
}

//----- (1001A580) --------------------------------------------------------
int __cdecl sub_1001A580(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1000D290(&a1, 1u, (int)&unk_10065078, 8, 53, 67);
  if ( v1 == 67 )
    result = 0;
  else
    result = (int)*(&off_1006507C + 2 * v1);
  return result;
}
// 1006507C: using guessed type void *off_1006507C;

//----- (1001A5C0) --------------------------------------------------------
int __cdecl sub_1001A5C0(unsigned __int8 *a1)
{
  return sub_1000F4B0(a1, 0, 0, 0, 0);
}

//----- (1001A5E0) --------------------------------------------------------
unsigned int __cdecl sub_1001A5E0(void *a1)
{
  return sub_1000F450(a1, 0x20u, 0);
}

//----- (1001A600) --------------------------------------------------------
unsigned int __cdecl sub_1001A600(void *a1)
{
  return sub_1000F450(a1, 0x1Cu, 0);
}

//----- (1001A620) --------------------------------------------------------
unsigned int __cdecl sub_1001A620(void *a1)
{
  return sub_1000F450(a1, 0x10u, 0);
}

//----- (1001A640) --------------------------------------------------------
unsigned int __cdecl sub_1001A640(void *a1)
{
  return sub_1000F450(a1, 0xCu, 0);
}

//----- (1001A660) --------------------------------------------------------
unsigned int __cdecl sub_1001A660(void *a1)
{
  return sub_1000F450(a1, 8u, 0);
}

//----- (1001A680) --------------------------------------------------------
unsigned int __cdecl sub_1001A680(void *a1)
{
  unsigned int result; // eax@1

  result = sub_1001A5E0((char *)a1 + 64);
  if ( !result )
  {
    result = sub_1001A600((char *)a1 + 36);
    if ( !result )
    {
      result = sub_1001A620(a1);
      if ( !result )
      {
        result = sub_1001A640((char *)a1 + 96);
        if ( !result )
        {
          result = sub_1001A640((char *)a1 + 24);
          if ( !result )
            result = sub_1001A660((char *)a1 + 16);
        }
      }
    }
  }
  return result;
}

//----- (1001A6E0) --------------------------------------------------------
int __cdecl sub_1001A6E0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1000F4B0(a1, 0, 0x7Fu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1001A710) --------------------------------------------------------
int __cdecl sub_1001A710(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int result; // eax@1
  unsigned int v4; // edx@1
  char v5; // bl@8
  char v6; // dl@13
  char v7; // cl@13

  v2 = a2 / 0x15180 % 0x5B5;
  result = a1;
  v4 = 4 * (a2 / 0x15180 / 0x5B5) + 1990;
  *(_WORD *)(a1 + 2) = v4;
  if ( v2 > 0x16D )
  {
    do
    {
      v2 -= 365;
      if ( !((unsigned __int16)v4 % 4) )
        --v2;
      LOWORD(v4) = v4 + 1;
    }
    while ( v2 > 0x16D );
    *(_WORD *)(a1 + 2) = v4;
  }
  if ( v2 >= 1 )
  {
    v5 = 0;
    if ( v2 > 0x3B && !(*(_WORD *)(a1 + 2) % 4) )
    {
      --v2;
      v5 = 1;
    }
    *(_BYTE *)a1 = 12;
    if ( v2 <= 0x14E )
    {
      do
        --*(_BYTE *)a1;
      while ( v2 <= LOWORD((&off_10066FFC)[2 * *(_BYTE *)a1 + 2]) );
    }
    v6 = *(_BYTE *)a1;
    v7 = v2 - LOBYTE((&off_10066FFC)[2 * *(_BYTE *)a1 + 2]);
    *(_BYTE *)(a1 + 1) = v7;
    if ( v5 == 1 && v6 == 2 )
      *(_BYTE *)(a1 + 1) = v7 + 1;
  }
  else
  {
    --*(_WORD *)(a1 + 2);
    *(_BYTE *)a1 = 12;
    *(_BYTE *)(a1 + 1) = 31;
  }
  return result;
}
// 10066FFC: using guessed type char *;

//----- (1001A800) --------------------------------------------------------
__int16 __cdecl sub_1001A800(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  __int16 result; // ax@1

  v2 = a2 % 0x15180 % 0xE10;
  *(_WORD *)a1 = a2 % 0x15180 / 0xE10;
  *(_BYTE *)(a1 + 2) = v2 / 0x3C;
  result = 60 * (char)(v2 / 0x3C);
  *(_BYTE *)(a1 + 3) = v2 % 0x3C;
  return result;
}

//----- (1001A850) --------------------------------------------------------
__int16 __cdecl sub_1001A850(unsigned int *a1, _WORD *a2, _WORD *a3)
{
  unsigned int v3; // esi@1
  __int16 result; // ax@1
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1

  v3 = *a1;
  sub_1001A800((int)&v5, *a1);
  sub_1001A710((int)&v6, v3);
  *a3 = (unsigned __int8)(BYTE3(v5) >> 1) | (unsigned __int16)(32 * (BYTE2(v5) | (unsigned __int16)((_WORD)v5 << 6)));
  result = BYTE1(v6);
  *a2 = BYTE1(v6) | (unsigned __int16)(32 * ((unsigned __int8)v6 | (unsigned __int16)(16 * (HIWORD(v6) - 60))));
  return result;
}

//----- (1001A8D0) --------------------------------------------------------
int __cdecl sub_1001A8D0(int a1)
{
  return (*(int (**)(void))(a1 + 4))();
}

//----- (1001A8E0) --------------------------------------------------------
char __cdecl sub_1001A8E0(signed int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax@2
  char result; // al@4

  if ( a1 < 50 && ((v3 = 592 * a1, byte_100D8D10[592 * a1]) || byte_100D8D60[v3]) )
  {
    *a2 = &byte_100D8D10[v3];
    *a3 = &byte_100D8D60[v3];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001A920) --------------------------------------------------------
char *__cdecl sub_1001A920(const char *a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edi@1
  unsigned int v4; // esi@1

  v2 = 0;
  v3 = byte_100D8D10;
  v4 = 0;
  while ( strcmp(v3, a1) )
  {
    v4 += 592;
    ++v2;
    v3 += 592;
    if ( v4 >= 0x73A0 )
      return (char *)a2;
  }
  return &byte_100D8D60[592 * v2];
}

//----- (1001A990) --------------------------------------------------------
char *__usercall sub_1001A990@<eax>(char *result@<eax>)
{
  char v1; // cl@2

  for ( ; *result; ++result )
  {
    v1 = *result;
    if ( *result == 10 || v1 == 35 )
    {
      *result = 0;
    }
    else if ( v1 == 92 )
    {
      *result = 47;
    }
  }
  return result;
}

//----- (1001A9C0) --------------------------------------------------------
void __cdecl sub_1001A9C0(char *a1)
{
  char *v1; // eax@3
  char *v2; // edi@3
  char *v3; // eax@4
  int v4; // ST14_4@5
  char *v5; // eax@5
  char v6; // [sp+4h] [bp-204h]@1

  v6 = 0;
  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = strstr(a1, "$$(");
      v2 = v1;
      if ( v1 )
      {
        v3 = strchr(v1 + 3, 41);
        if ( v3 )
        {
          *v2 = 0;
          *v3 = 0;
          v4 = (int)(v3 + 1);
          v5 = sub_1001A920(v2 + 3, (int)&unk_10047869);
          sprintf(&v6, "%s%s%s", a1, v5, v4);
          sub_1001A9C0(&v6);
          strcpy(a1, &v6);
        }
      }
    }
  }
}

//----- (1001AA80) --------------------------------------------------------
void __cdecl sub_1001AA80(char *a1, char *a2)
{
  char *v2; // eax@2
  int v3; // edx@2
  char *v4; // esi@2
  char v5; // cl@3
  char *v6; // eax@4
  char *v7; // esi@4
  char *v8; // edx@4
  char v9; // cl@5

  if ( dword_100D8D08 < 50 )
  {
    v2 = a1;
    v3 = 592 * dword_100D8D08;
    v4 = (char *)(&byte_100D8D10[592 * dword_100D8D08] - a1);
    do
    {
      v5 = *v2;
      v2[(_DWORD)v4] = *v2;
      ++v2;
    }
    while ( v5 );
    v6 = a2;
    v7 = &byte_100D8D60[v3];
    v8 = (char *)(&byte_100D8D60[v3] - a2);
    do
    {
      v9 = *v6;
      v6[(_DWORD)v8] = *v6;
      ++v6;
    }
    while ( v9 );
    sub_1001A9C0(v7);
    ++dword_100D8D08;
  }
}
// 100D8D08: using guessed type int dword_100D8D08;

//----- (1001AAE0) --------------------------------------------------------
void *__cdecl sub_1001AAE0(int a1)
{
  void *result; // eax@1
  unsigned int v2; // eax@2
  unsigned int v3; // ebp@2
  char *v4; // edi@4
  char *v5; // esi@4
  char *v6; // eax@4
  const char *v7; // esi@6
  const char *v8; // ebx@6
  char *v9; // edi@6
  char *v10; // eax@6
  char v11; // [sp+4h] [bp-204h]@3

  result = memset(byte_100D8D10, 0, 0x73A0u);
  dword_100D8D08 = 0;
  if ( a1 )
  {
    v2 = sub_1001AFB0(a1, 0);
    v3 = v2;
    if ( v2 )
    {
      if ( sub_1001B190((int)&v11, 512, v2) )
      {
        do
        {
          sub_1001A990(&v11);
          v4 = strstr(&v11, "=");
          v5 = strstr(&v11, "<Var name=\"");
          v6 = strstr(&v11, " value=\"");
          if ( v5 && v6 )
          {
            v7 = v5 + 11;
            v8 = v6 + 8;
            v9 = strchr(v7, 34);
            v10 = strchr(v8, 34);
            if ( v9 )
            {
              if ( v10 )
              {
                *v9 = 0;
                *v10 = 0;
                sub_1001AA80((char *)v7, (char *)v8);
              }
            }
          }
          else if ( v4 && !strpbrk(&v11, "<>") )
          {
            *v4 = 0;
            sub_1001AA80(&v11, v4 + 1);
          }
        }
        while ( sub_1001B190((int)&v11, 512, v3) );
      }
      result = (void *)sub_1001AF60(v3);
    }
    else
    {
      result = (void *)sub_10011D30(
                         3,
                         (int)"**Warning**",
                         (int)"..\\lib\\utf\\utf_cnfg.c",
                         (int)"269",
                         (int)"Configuration File",
                         a1,
                         (int)"Unable to open configuration file");
    }
  }
  return result;
}
// 100D8D08: using guessed type int dword_100D8D08;

//----- (1001AC70) --------------------------------------------------------
int __cdecl sub_1001AC70(int a1, int a2)
{
  unsigned int v2; // eax@5
  int v3; // eax@8
  int v4; // eax@10
  int result; // eax@11

  if ( a2 && *(_DWORD *)(a2 + 8) && *(_WORD *)(a2 + 12) && *(_DWORD *)(a2 + 4) )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 < 0xFFFFFFC2 && v2 )
    {
      j_IOP_pvg_sk_close(v2, *(_DWORD *)(a2 + 20));
      *(_DWORD *)(a1 + 4) = 0;
    }
    *(_BYTE *)(*(_WORD *)(a2 + 12) + *(_DWORD *)(a2 + 8) - 1) = 0;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 30) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 28) = 0;
    v3 = j_IOP_pvg_sk_create_id(*(_WORD *)a2);
    *(_DWORD *)(a1 + 4) = v3;
    if ( *(_DWORD *)(a2 + 36) )
      j_IOP_pvg_sk_set_addr(v3, 0, *(_DWORD *)(a2 + 36));
    v4 = *(_DWORD *)(a1 + 4);
    if ( *(_BYTE *)(a2 + 14) & 8 )
      result = j_IOP_pvg_sk_connect(v4, *(_DWORD *)(a2 + 16));
    else
      result = j_IOP_pvg_sk_accept(v4, a1 + 8, *(_DWORD *)(a2 + 16));
  }
  else
  {
    result = -59;
  }
  return result;
}
// 10025210: using guessed type int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD);
// 10025220: using guessed type int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD);
// 10025230: using guessed type int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD);
// 10025240: using guessed type int __cdecl j_IOP_pvg_sk_create_id(_DWORD);
// 100252F0: using guessed type int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD);

//----- (1001ADB0) --------------------------------------------------------
char __usercall sub_1001ADB0@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5)
{
  _WORD *v5; // edx@1
  int v6; // esi@1
  char result; // al@1
  char v8; // cl@5
  unsigned __int16 v9; // cx@11
  signed int v10; // edi@12
  signed int v11; // esi@12
  size_t v12; // ebp@13

  v5 = a4;
  v6 = a1;
  result = 0;
  if ( *a4 >= a3 )
  {
    *a4 = 0;
    *(_BYTE *)a2 = 0;
  }
  if ( a5 == -1 )
    *(_BYTE *)(v6 + 28) = 3;
  v8 = *(_BYTE *)(v6 + 28);
  if ( v8 )
  {
    *(_BYTE *)(v6 + 28) = v8 - 1;
    result = 0;
  }
  else if ( a5 != 13 && a5 != 10 && a5 )
  {
    *(_BYTE *)((*a4)++ + a2) = a5;
  }
  else
  {
    v9 = *a4;
    if ( *a4 )
    {
      v10 = v9;
      v11 = 0;
      if ( (signed int)v9 > 0 )
      {
        v12 = v9 - 1;
        do
        {
          if ( *(_BYTE *)(v11 + a2) == 8 )
          {
            if ( v11 )
            {
              memcpy_0((void *)(v11 + a2 - 1), (const void *)(v11 + a2 + 1), v10 - v11 - 1);
              v10 -= 2;
              v12 -= 2;
              v11 -= 2;
            }
            else
            {
              memcpy_0((void *)a2, (const void *)(a2 + 1), v12);
              --v10;
              --v12;
              v11 = -1;
            }
            v5 = a4;
          }
          ++v11;
        }
        while ( v11 < v10 );
      }
      *(_BYTE *)(v10 + a2) = 0;
      result = 1;
      *v5 = 0;
    }
  }
  return result;
}

//----- (1001AE80) --------------------------------------------------------
signed int __cdecl sub_1001AE80(_DWORD *a1, char *a2)
{
  int v2; // esi@1
  int v3; // ebx@4
  int v4; // ebp@4
  int v5; // eax@5
  signed int v6; // edi@5
  int v7; // ST0C_4@9
  char v8; // al@11
  int v10; // [sp+4h] [bp-38h]@4
  __int16 v11; // [sp+8h] [bp-34h]@9

  v2 = (int)a1;
  if ( a1 && *a1 && a2 )
  {
    *a2 = 0;
    v3 = *(_DWORD *)v2;
    v10 = *(_DWORD *)v2;
    v4 = 0;
    while ( 1 )
    {
      v5 = sub_10025250(*(_DWORD *)(v2 + 4), (int)&a1, 1, 0, v4);
      v6 = v5;
      if ( v5 == -57 )
      {
        if ( v4 == *(_DWORD *)(v3 + 24) )
          return v6;
        v4 = *(_DWORD *)(v3 + 24);
        v6 = 1;
      }
      else
      {
        if ( v5 >= 0 )
        {
          v8 = sub_1001ADB0(v2, *(_DWORD *)(v3 + 8), *(_WORD *)(v3 + 12), (_WORD *)(v2 + 30), (char)a1);
          v3 = v10;
          *a2 = v8;
          *(_DWORD *)(v2 + 24) += v6;
        }
        else
        {
          v7 = *(_DWORD *)(v2 + 4);
          v11 = 0;
          j_IOP_pvg_sk_status(v7, &v11);
          if ( !(v11 & 0x44) )
            sub_1001AC70(v2, v3);
        }
        if ( v6 <= 0 )
          return v6;
      }
      if ( *a2 )
        return v6;
    }
  }
  return -59;
}
// 10025300: using guessed type int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD);

//----- (1001AF60) --------------------------------------------------------
BOOL __cdecl sub_1001AF60(unsigned int a1)
{
  j_FIL_vfs_clean_invalidate_cache(a1);
  return sub_10025320(a1) == 0;
}
// 10025310: using guessed type int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD);

//----- (1001AF80) --------------------------------------------------------
BOOL __cdecl sub_1001AF80(int a1)
{
  return j_FIL_vfs_delete(a1) == 0;
}
// 10025360: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);

//----- (1001AFB0) --------------------------------------------------------
unsigned int __cdecl sub_1001AFB0(int a1, char a2)
{
  unsigned int result; // eax@7
  int v3; // [sp-Ch] [bp-Ch]@3
  signed int v4; // [sp-8h] [bp-8h]@2

  switch ( a2 )
  {
    case 0:
      v4 = 4;
      goto LABEL_6;
    case 1:
      v4 = 10;
      v3 = a1;
      goto LABEL_7;
    case 2:
      v4 = 14;
      v3 = a1;
      goto LABEL_7;
    case 3:
      v4 = 78;
LABEL_6:
      v3 = a1;
LABEL_7:
      result = j_FIL_vfs_open(v3, v4, 0);
      if ( result >= 0xFFFFFFC2 || !result )
        goto LABEL_9;
      break;
    default:
LABEL_9:
      result = 0;
      break;
  }
  return result;
}
// 100253E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1001B010) --------------------------------------------------------
signed int __cdecl sub_1001B010(void *a1, int a2, unsigned int a3)
{
  return sub_100253F0(a3, a1, a2);
}

//----- (1001B030) --------------------------------------------------------
int __cdecl sub_1001B030(int a1, int a2, int a3)
{
  return j_FIL_vfs_write(a3, a1, a2);
}
// 10025550: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (1001B050) --------------------------------------------------------
char __cdecl sub_1001B050(const char *a1, const char *a2)
{
  bool v2; // bl@1
  unsigned int v3; // edi@6
  unsigned int v4; // ebp@7
  int v5; // esi@8
  bool i; // zf@8
  char v8; // [sp+Ch] [bp-204h]@8

  v2 = 0;
  if ( !a1 || !*a1 || !a2 || !*a2 )
    return v2;
  if ( strcmp(a1, a2) )
  {
    v3 = sub_1001AFB0((int)a1, 0);
    if ( v3 )
    {
      v4 = sub_1001AFB0((int)a2, 1);
      if ( v4 )
      {
        v5 = sub_1001B010(&v8, 512, v3);
        for ( i = v5 == 0; v5 > 0; i = v5 == 0 )
        {
          v5 -= sub_1001B030((int)&v8, v5, v4);
          if ( !v5 )
            v5 = sub_1001B010(&v8, 512, v3);
        }
        v2 = i;
        sub_1001AF60(v4);
      }
      sub_1001AF60(v3);
    }
    return v2;
  }
  return 1;
}

//----- (1001B190) --------------------------------------------------------
int __cdecl sub_1001B190(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // esi@1
  unsigned __int8 v5; // [sp+13h] [bp-1h]@2

  v3 = 0;
  while ( 1 )
  {
    if ( sub_1001B010(&v5, 1, a3) <= 0 || v5 == -1 )
    {
      *(_BYTE *)(v3 + a1) = 0;
      return v3 > 0 ? a1 : 0;
    }
    if ( v5 == 10 )
      break;
    if ( v5 != 13 )
    {
      *(_BYTE *)(v3++ + a1) = v5;
      if ( v3 >= a2 - 2 )
      {
        *(_BYTE *)(v3 + a1 + 1) = 0;
        return a1;
      }
    }
  }
  *(_BYTE *)(v3 + a1) = 0;
  return a1;
}

//----- (1001B210) --------------------------------------------------------
int sub_1001B210()
{
  return 0;
}

//----- (1001B220) --------------------------------------------------------
void __cdecl sub_1001B220(int a1)
{
  if ( a1 > 0 )
    exit_0(14);
}

//----- (1001B250) --------------------------------------------------------
int __cdecl sub_1001B250(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (1001B270) --------------------------------------------------------
bool __cdecl sub_1001B270(int a1)
{
  return *(_DWORD *)a1 && *(_DWORD *)(a1 + 4) && *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 12);
}

//----- (1001B2A0) --------------------------------------------------------
void *__cdecl sub_1001B2A0(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5)
{
  void *v5; // eax@1

  *(_DWORD *)a5 = a1;
  *(_DWORD *)(a5 + 4) = a2;
  *(_DWORD *)(a5 + 8) = a3;
  v5 = (void *)a4(a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
  *(_DWORD *)(a5 + 12) = v5;
  return memset(v5, 0, a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
}

//----- (1001B2E0) --------------------------------------------------------
unsigned int __usercall sub_1001B2E0@<eax>(int a1@<edx>, int a2, int a3)
{
  return *(_DWORD *)(a1 + 12) + ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3) * (a3 + a2 * *(_DWORD *)(a1 + 4));
}

//----- (1001B300) --------------------------------------------------------
int __usercall sub_1001B300@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_BYTE *)(result + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(result + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)result = *(_BYTE *)a2;
  return result;
}

//----- (1001B320) --------------------------------------------------------
char __cdecl sub_1001B320(void (__cdecl *a1)(_DWORD), int a2)
{
  char result; // al@1

  result = sub_1001B270(a2);
  if ( result )
  {
    a1(*(_DWORD *)(a2 + 12));
    result = sub_1001B250(a2);
  }
  return result;
}

//----- (1001B350) --------------------------------------------------------
signed int __cdecl sub_1001B350(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5)
{
  int v5; // ebp@1
  signed int result; // eax@1
  unsigned int v7; // ebx@1
  bool v8; // zf@1
  unsigned int v9; // esi@2
  unsigned int v10; // edi@3
  _BYTE *v11; // eax@3
  _BYTE *v12; // ecx@3
  __int64 v13; // rax@3
  __int64 v14; // rax@4
  __int64 v15; // rax@5
  int v16; // eax@6
  signed int v17; // [sp+Ch] [bp+4h]@1

  v5 = (int)a1;
  result = 0;
  v7 = 0;
  v8 = *a1 == 0;
  v17 = 0;
  if ( v8 )
  {
    *a5 = 0;
  }
  else
  {
    do
    {
      v9 = 0;
      if ( *(_DWORD *)(v5 + 4) )
      {
        do
        {
          v10 = sub_1001B2E0(v5, v7, v9);
          v11 = (_BYTE *)sub_1001B2E0(a2, v7, v9);
          v12 = v11;
          v13 = *(_BYTE *)v10 - *v11;
          if ( (signed int)((HIDWORD(v13) ^ v13) - HIDWORD(v13)) > a3
            || (v14 = *(_BYTE *)(v10 + 1) - v12[1], (signed int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) > a3)
            || (v15 = *(_BYTE *)(v10 + 2) - v12[2], (signed int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) > a3) )
          {
            v17 = 4;
            v16 = sub_1001B2E0(a4, v7, v9);
            sub_1001B300(v16, (int)&unk_100670BC);
          }
          ++v9;
        }
        while ( v9 < *(_DWORD *)(v5 + 4) );
      }
      ++v7;
    }
    while ( v7 < *(_DWORD *)v5 );
    result = v17;
    *a5 = 0;
  }
  return result;
}

//----- (1001B430) --------------------------------------------------------
void __cdecl sub_1001B430(int a1, int a2, int a3)
{
  unsigned int *v3; // edx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // eax@2
  unsigned int v6; // esi@3
  unsigned int v7; // edi@4
  unsigned int v8; // ebx@4
  unsigned int v9; // ebp@4
  __int64 v10; // rax@4
  __int64 v11; // rax@4
  unsigned int v12; // [sp+4h] [bp-4h]@1

  v3 = (unsigned int *)a1;
  v4 = 0;
  v12 = 0;
  if ( *(_DWORD *)a1 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    do
    {
      v6 = 0;
      if ( v5 )
      {
        do
        {
          v7 = sub_1001B2E0((int)v3, v4, v6);
          v8 = sub_1001B2E0(a2, v4, v6);
          v9 = sub_1001B2E0(a3, v4, v6);
          v10 = *(_BYTE *)(v7 + 2) - *(_BYTE *)(v8 + 2);
          *(_BYTE *)(v9 + 2) = (BYTE4(v10) ^ v10) - BYTE4(v10);
          v11 = *(_BYTE *)(v7 + 1) - *(_BYTE *)(v8 + 1);
          *(_BYTE *)(v9 + 1) = (BYTE4(v11) ^ v11) - BYTE4(v11);
          v3 = (unsigned int *)a1;
          *(_BYTE *)v9 = abs(*(_BYTE *)v7 - *(_BYTE *)v8);
          v5 = *(_DWORD *)(a1 + 4);
          v4 = v12;
          ++v6;
        }
        while ( v6 < v5 );
      }
      v12 = ++v4;
    }
    while ( v4 < *v3 );
  }
}

//----- (1001B4E0) --------------------------------------------------------
void *__usercall sub_1001B4E0@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3)
{
  int v3; // eax@1
  unsigned int v4; // ebx@3
  int v5; // ebp@4
  int v6; // eax@4
  int v7; // ebp@4
  int v8; // eax@4
  int v9; // ST5C_4@4
  int v10; // eax@4
  int v11; // ebp@4
  int v12; // eax@4
  unsigned int v13; // ebx@6
  size_t v14; // ST3C_4@7
  const void *v15; // ST38_4@7
  void *v16; // eax@7
  unsigned int i; // ebp@8
  unsigned int v18; // ebx@9
  int v19; // ST5C_4@10
  int v20; // eax@10
  int v21; // ST5C_4@10
  int v22; // eax@10
  size_t v23; // ST3C_4@11
  const void *v24; // ST38_4@11
  void *v25; // eax@11
  unsigned int v26; // ebx@12
  size_t v27; // ST3C_4@13
  const void *v28; // ST38_4@13
  void *v29; // eax@13
  void *result; // eax@13
  int v31; // [sp+8h] [bp-18h]@1
  unsigned int v32; // [sp+Ch] [bp-14h]@1
  int v33; // [sp+10h] [bp-10h]@3
  int v34; // [sp+14h] [bp-Ch]@1
  int v35; // [sp+18h] [bp-8h]@1

  v3 = 2 * a3 + *(_DWORD *)a2;
  v35 = 2 * a3 + *(_DWORD *)a2;
  v34 = 2 * a3 + *(_DWORD *)(a2 + 4);
  v32 = (unsigned int)(*(_DWORD *)(a2 + 8) + 7) >> 3;
  v31 = 0;
  while ( 1 )
  {
    v4 = 0;
    v33 = v3 - v31 - 1;
    do
    {
      v5 = sub_1001B2E0(a1, v31, v4);
      v6 = sub_1001B2E0(a2, 0, 0);
      sub_1001B300(v5, v6);
      v7 = sub_1001B2E0(a1, v33, v4);
      v8 = sub_1001B2E0(a2, *(_DWORD *)a2 - 1, 0);
      sub_1001B300(v7, v8);
      v9 = sub_1001B2E0(a1, v31, v34 - v4 - 1);
      v10 = sub_1001B2E0(a2, 0, *(_DWORD *)(a2 + 4) - 1);
      sub_1001B300(v9, v10);
      v11 = sub_1001B2E0(a1, v33, v34 - v4 - 1);
      v12 = sub_1001B2E0(a2, *(_DWORD *)a2 - 1, *(_DWORD *)(a2 + 4) - 1);
      sub_1001B300(v11, v12);
      ++v4;
    }
    while ( v4 <= a3 );
    if ( ++v31 > a3 )
      break;
    v3 = v35;
  }
  v13 = 0;
  do
  {
    v14 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v15 = (const void *)sub_1001B2E0(a2, 0, 1);
    v16 = (void *)sub_1001B2E0(a1, v13, a3 + 1);
    memcpy(v16, v15, v14);
    ++v13;
  }
  while ( v13 <= a3 );
  for ( i = 1; i < *(_DWORD *)a2 - 1; ++i )
  {
    v18 = 0;
    do
    {
      v19 = sub_1001B2E0(a1, a3 + i, v18);
      v20 = sub_1001B2E0(a2, i, 0);
      sub_1001B300(v19, v20);
      v21 = sub_1001B2E0(a1, i + a3, v34 - v18 - 1);
      v22 = sub_1001B2E0(a2, i, *(_DWORD *)(a2 + 4) - 1);
      sub_1001B300(v21, v22);
      ++v18;
    }
    while ( v18 <= a3 );
    v23 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v24 = (const void *)sub_1001B2E0(a2, i, 1);
    v25 = (void *)sub_1001B2E0(a1, a3 + i, a3 + 1);
    memcpy(v25, v24, v23);
  }
  v26 = 0;
  do
  {
    v27 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v28 = (const void *)sub_1001B2E0(a2, *(_DWORD *)a2 - 1, 1);
    v29 = (void *)sub_1001B2E0(a1, v35 - v26 - 1, a3 + 1);
    result = memcpy(v29, v28, v27);
    ++v26;
  }
  while ( v26 <= a3 );
  return result;
}

//----- (1001B760) --------------------------------------------------------
void __cdecl sub_1001B760(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  unsigned int v4; // esi@3
  unsigned int v5; // edi@4
  unsigned int v6; // ecx@4
  char v7; // al@4

  v2 = 0;
  if ( *(_DWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    do
    {
      v4 = 0;
      if ( v3 )
      {
        do
        {
          v5 = sub_1001B2E0(a1, v2, v4);
          v6 = sub_1001B2E0(a2, v2, v4++);
          v7 = (signed int)((double)*(_BYTE *)(v5 + 2) * 0.300000011920929
                          + (double)*(_BYTE *)(v5 + 1) * 0.5899999737739563
                          + (double)*(_BYTE *)v5 * 0.1099999994039536);
          *(_BYTE *)(v6 + 2) = v7;
          *(_BYTE *)(v6 + 1) = v7;
          *(_BYTE *)v6 = v7;
          v3 = *(_DWORD *)(a1 + 4);
        }
        while ( v4 < v3 );
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)a1 );
  }
}

//----- (1001B830) --------------------------------------------------------
char __cdecl sub_1001B830(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4)
{
  char result; // al@1

  result = sub_1001B270(a1);
  if ( result )
  {
    result = sub_1001B270(a4);
    if ( result )
    {
      sub_1001B320(a3, a4);
      sub_1001B2A0(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), a2, a4);
      result = (unsigned int)memcpy(
                               *(void **)(a4 + 12),
                               *(const void **)(a1 + 12),
                               *(_DWORD *)(a1 + 4) * *(_DWORD *)a1 * ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3));
    }
  }
  return result;
}

//----- (1001B8A0) --------------------------------------------------------
int __usercall sub_1001B8A0@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9)
{
  int (__cdecl *v9)(unsigned int); // edi@1
  long double v10; // st7@1
  unsigned int v11; // ecx@1
  signed int v12; // kr00_4@1
  int v13; // ebx@1
  int v14; // esi@3
  int result; // eax@5
  double v16; // st6@7
  int v17; // eax@7
  double v18; // st3@7
  int v19; // edi@9
  double v20; // rt0@11
  double v21; // st3@11
  double v22; // st6@11
  int v23; // eax@11
  int v24; // ecx@12
  int v25; // ebp@14
  float *v26; // esi@14
  unsigned int v27; // eax@15
  signed int v28; // ecx@15
  float v29; // ST50_4@15
  signed int v30; // edx@15
  signed int v31; // eax@15
  int v32; // ecx@20
  double v33; // st2@20
  double v34; // rtt@21
  double v35; // rt0@23
  double v36; // st2@23
  double v37; // st3@23
  double v38; // rtt@26
  unsigned int v39; // eax@28
  bool v40; // sf@28
  unsigned __int8 v41; // of@28
  float v42; // [sp+8h] [bp-48h]@11
  int v43; // [sp+Ch] [bp-44h]@8
  int v44; // [sp+10h] [bp-40h]@9
  int v45; // [sp+14h] [bp-3Ch]@6
  int v46; // [sp+18h] [bp-38h]@7
  int v47; // [sp+20h] [bp-30h]@11
  signed int v48; // [sp+24h] [bp-2Ch]@1
  int v49; // [sp+28h] [bp-28h]@12
  float v50; // [sp+30h] [bp-20h]@22
  float v51; // [sp+34h] [bp-1Ch]@11
  float v52; // [sp+38h] [bp-18h]@11
  float v53; // [sp+3Ch] [bp-14h]@11
  char v54; // [sp+40h] [bp-10h]@6

  v9 = a2;
  v10 = sqrt((double)a1);
  v11 = (signed int)v10;
  v12 = (signed int)v10;
  v13 = (signed int)v10 / 2;
  v48 = (signed int)v10;
  if ( v9 && a7 )
  {
    v14 = a3;
    if ( *(_DWORD *)(a3 + 4) >= v11 || *(_DWORD *)a3 >= v11 )
    {
      *(_DWORD *)a9 = 0;
      sub_1001B2A0(2 * v13 + *(_DWORD *)a3, 2 * v13 + *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8), v9, (int)&v54);
      sub_1001B4E0((int)&v54, a3, v12 / 2);
      v45 = v12 / 2;
      if ( v13 < v13 + *(_DWORD *)a3 )
      {
        v16 = 0.0;
        v17 = v13 + *(_DWORD *)(a3 + 4);
        v46 = 0;
        v18 = a6;
        do
        {
          v43 = v12 / 2;
          if ( v13 < v17 )
          {
            v19 = v12 / -2;
            v44 = 0;
            while ( 1 )
            {
              v20 = v18;
              v21 = v16;
              v22 = v20;
              v51 = 0.0;
              v42 = v21;
              v52 = 0.0;
              v53 = 0.0;
              v23 = v19;
              v47 = v19;
              if ( v19 <= v13 )
              {
                v24 = v48 * (v19 + v13);
                v49 = v48 * (v19 + v13);
                do
                {
                  if ( v19 <= v13 )
                  {
                    v25 = v23 + v45;
                    v26 = (float *)(a4 + 4 * (v13 + v19 + v24));
                    do
                    {
                      v27 = sub_1001B2E0((int)&v54, v25, v19 + v43);
                      v28 = *(_BYTE *)(v27 + 2);
                      v29 = *v26;
                      v30 = *(_BYTE *)(v27 + 1);
                      v31 = *(_BYTE *)v27;
                      ++v19;
                      ++v26;
                      v51 = (double)v28 * v29 + v51;
                      v52 = (double)v30 * v29 + v52;
                      v53 = (double)v31 * v29 + v53;
                      v42 = v29 + v42;
                    }
                    while ( v19 <= v13 );
                    v14 = a3;
                    v23 = v47;
                    v24 = v49;
                    v19 = v12 / -2;
                  }
                  v24 += v48;
                  v47 = ++v23;
                  v49 = v24;
                }
                while ( v23 <= v13 );
              }
              if ( v21 == v22 )
                v22 = v42;
              v32 = 0;
              v33 = a5 + v22;
              while ( 1 )
              {
                v50 = *(&v51 + v32) / v33;
                *(&v51 + v32) = v50;
                if ( v50 > v21 )
                {
                  if ( v50 > 255.0 )
                    *(&v51 + v32) = 255.0;
                  v38 = v33;
                  v36 = v21;
                  v37 = v38;
                }
                else
                {
                  v35 = v33;
                  v36 = v21;
                  v37 = v35;
                  *(&v51 + v32) = v36;
                }
                if ( (unsigned int)++v32 >= 3 )
                  break;
                v34 = v36;
                v33 = v37;
                v21 = v34;
              }
              v39 = sub_1001B2E0(a8, v46, v44++);
              *(_BYTE *)(v39 + 2) = (signed int)v51;
              *(_BYTE *)(v39 + 1) = (signed int)v52;
              *(_BYTE *)v39 = (signed int)v53;
              v17 = *(_DWORD *)(v14 + 4) + v13;
              v41 = __OFSUB__(v43 + 1, v17);
              v40 = v43++ + 1 - v17 < 0;
              v18 = v22;
              v16 = v36;
              if ( !(v40 ^ v41) )
                break;
              v19 = v12 / -2;
            }
          }
          ++v46;
          ++v45;
        }
        while ( v45 < v13 + *(_DWORD *)v14 );
      }
      sub_1001B320((void (__cdecl *)(_DWORD))a7, (int)&v54);
      result = 0;
    }
    else
    {
      *(_DWORD *)a9 = "Bitmap too small to filter -- filtering has been disabled";
      sub_1001B830(a3, v9, (void (__cdecl *)(_DWORD))a7, a8);
      result = 0;
    }
  }
  else
  {
    *(_DWORD *)a9 = "Dynamic memory function pointers are required for bitmap filtering";
    result = 1;
  }
  return result;
}

//----- (1001BC00) --------------------------------------------------------
int __usercall sub_1001BC00@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7)
{
  int (__cdecl *v7)(unsigned int); // edi@1
  int v8; // esi@1
  unsigned int v9; // ebx@1
  int v10; // ebp@1
  unsigned int v11; // edi@2
  unsigned int v12; // eax@3
  int v13; // eax@6
  int v15; // [sp+24h] [bp-20h]@1
  int v16; // [sp+34h] [bp-10h]@1

  v7 = a1;
  v8 = a2;
  sub_1001B2A0(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(a2 + 8), a1, (int)&v16);
  sub_1001B430(v8, a3, (int)&v16);
  sub_1001B2A0(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(v8 + 8), v7, (int)&v15);
  v9 = 0;
  v10 = sub_1001B8A0(9u, v7, (int)&v16, (int)&unk_10067098, 0.0, 0.0, (int)a5, (int)&v15, a7);
  if ( *(_DWORD *)v8 )
  {
    do
    {
      v11 = 0;
      if ( *(_DWORD *)(v8 + 4) )
      {
        do
        {
          v12 = sub_1001B2E0((int)&v15, v9, v11);
          if ( *(_BYTE *)(v12 + 2) > a4 || *(_BYTE *)(v12 + 1) > a4 || *(_BYTE *)v12 > a4 )
          {
            v10 = 4;
            v13 = sub_1001B2E0(a6, v9, v11);
            sub_1001B300(v13, (int)&unk_100670BC);
          }
          ++v11;
        }
        while ( v11 < *(_DWORD *)(v8 + 4) );
      }
      ++v9;
    }
    while ( v9 < *(_DWORD *)v8 );
  }
  sub_1001B320(a5, (int)&v15);
  sub_1001B320(a5, (int)&v16);
  return v10;
}

//----- (1001BD10) --------------------------------------------------------
int __cdecl sub_1001BD10(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10)
{
  bool v10; // cl@6
  bool v11; // al@13
  bool v12; // zf@16
  int result; // eax@16
  const char *v14; // ecx@17
  int v15; // ecx@22
  int v16; // eax@23
  char v17; // [sp+Bh] [bp-5h]@1
  const char *v18; // [sp+Ch] [bp-4h]@1

  v17 = 0;
  v18 = 0;
  v10 = a2 && *(_DWORD *)a2 && *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 12);
  v11 = a3 && *(_DWORD *)a3 && *(_DWORD *)(a3 + 4) && *(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 12);
  if ( !v10 )
  {
    v12 = v11 == 0;
    result = 2;
    if ( v12 )
      v14 = "Actual and Expected bitmaps unavailable";
    else
      v14 = "Actual bitmap is unavailable";
    goto LABEL_33;
  }
  if ( !v11 )
  {
    v14 = "Expected bitmap is unavailable";
    result = 2;
    goto LABEL_33;
  }
  if ( *(_DWORD *)a2 != *(_DWORD *)a3
    || (v15 = *(_DWORD *)(a2 + 4), v15 != *(_DWORD *)(a3 + 4))
    || (v16 = *(_DWORD *)(a2 + 8), v16 != *(_DWORD *)(a3 + 8)) )
  {
    v14 = "Bitmap sizes are different";
    result = 3;
    goto LABEL_33;
  }
  if ( !a6 || !a7 )
  {
    v14 = "Dynamic memory function pointers are required for comparison (build environment error)";
    result = 1;
    goto LABEL_33;
  }
  sub_1001B2A0(*(_DWORD *)a2, v15, v16, a6, a8);
  sub_1001B760(a3, a8);
  if ( a1 )
    result = sub_1001BC00(a6, a2, a3, a4, a7, a8, (int)&v18);
  else
    result = sub_1001B350((_DWORD *)a2, a3, a4, a8, &v18);
  if ( !a5 )
    goto LABEL_48;
  if ( result == 4 )
  {
    result = 0;
LABEL_32:
    v14 = v18;
    goto LABEL_33;
  }
  if ( result )
  {
LABEL_48:
    if ( result != 4 )
      goto LABEL_32;
  }
  else
  {
    result = 4;
  }
  if ( a5 )
  {
    v14 = "Images match";
  }
  else
  {
    v17 = 1;
    v14 = "Pixel mismatch";
  }
LABEL_33:
  if ( a10 )
    *a10 = v14;
  if ( a9 )
    *a9 = v17;
  return result;
}

//----- (1001BEA0) --------------------------------------------------------
char __cdecl sub_1001BEA0(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3)
{
  char v3; // bl@1
  unsigned int v4; // eax@5
  unsigned int v5; // esi@5
  char *v6; // ebp@11
  int v7; // esi@11
  unsigned int v8; // ebx@11
  int v9; // edi@11
  char result; // al@20
  char v11; // [sp+8h] [bp-40h]@14
  unsigned int v12; // [sp+Ch] [bp-3Ch]@5
  __int16 v13; // [sp+10h] [bp-38h]@6
  int v14; // [sp+1Ah] [bp-2Eh]@8
  char v15; // [sp+20h] [bp-28h]@9
  int v16; // [sp+24h] [bp-24h]@11
  unsigned int v17; // [sp+28h] [bp-20h]@11
  unsigned __int16 v18; // [sp+2Eh] [bp-1Ah]@10
  char v19; // [sp+4Ch] [bp+4h]@11

  v3 = 0;
  if ( a1 && a2 && *a2 )
  {
    if ( a3 )
    {
      v4 = sub_1001AFB0((int)a2, 0);
      v5 = v4;
      v12 = v4;
      if ( v4 )
      {
        if ( sub_1001B010(&v13, 14, v4) == 14
          && v13 == 19778
          && v14 == 54
          && sub_1001B010(&v15, 40, v5) == 40
          && v18 == 24 )
        {
          sub_1001B2A0(v17, v16, 24, a1, a3);
          v6 = *(char **)(a3 + 12);
          v7 = v16 * (((unsigned int)v18 + 7) >> 3);
          v8 = 0;
          v9 = -(v16 * (((unsigned int)v18 + 7) >> 3)) & 3;
          v19 = 1;
          if ( v17 )
          {
            while ( sub_1001B010(v6, v7, v12) == v7 && (!v9 || sub_1001B010(&v11, v9, v12) == v9) )
            {
              ++v8;
              v6 += v7;
              if ( v8 >= v17 )
                goto LABEL_18;
            }
            v19 = 0;
          }
LABEL_18:
          v3 = v19;
          v5 = v12;
        }
        sub_1001AF60(v5);
      }
      result = v3;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001BFF0) --------------------------------------------------------
char __usercall sub_1001BFF0@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // esi@1
  int v7; // edi@1
  int v8; // eax@1
  int v9; // eax@1
  unsigned int v10; // ebx@1
  int v12; // [sp+10h] [bp-40h]@4
  int v13; // [sp+14h] [bp-3Ch]@4
  __int16 v14; // [sp+18h] [bp-38h]@1
  int v15; // [sp+1Ah] [bp-36h]@1
  __int16 v16; // [sp+1Eh] [bp-32h]@1
  __int16 v17; // [sp+20h] [bp-30h]@1
  int v18; // [sp+22h] [bp-2Eh]@1
  int v19; // [sp+28h] [bp-28h]@1
  int v20; // [sp+2Ch] [bp-24h]@1
  unsigned int v21; // [sp+30h] [bp-20h]@1
  __int16 v22; // [sp+34h] [bp-1Ch]@1
  __int16 v23; // [sp+36h] [bp-1Ah]@1
  int v24; // [sp+38h] [bp-18h]@1
  int v25; // [sp+3Ch] [bp-14h]@1
  int v26; // [sp+40h] [bp-10h]@1
  int v27; // [sp+44h] [bp-Ch]@1
  int v28; // [sp+48h] [bp-8h]@1
  int v29; // [sp+4Ch] [bp-4h]@1
  char v30; // [sp+54h] [bp+4h]@1

  v5 = a3;
  v6 = a1 * ((unsigned int)(a2 + 7) >> 3);
  v7 = -(a1 * ((unsigned int)(a2 + 7) >> 3)) & 3;
  v8 = a3 * (v7 + v6);
  v25 = v8;
  v15 = v8 + 54;
  v16 = 0;
  v17 = 0;
  v29 = 0;
  v28 = 0;
  v24 = 0;
  v26 = 0;
  v27 = 0;
  v30 = 0;
  v14 = 19778;
  v18 = 54;
  v19 = 40;
  v23 = a2;
  v21 = v5;
  v20 = a1;
  v22 = 1;
  v9 = sub_1001AFB0(a5, 1);
  v10 = v9;
  if ( v9 )
  {
    if ( sub_1001B030((int)&v14, 14, v9) == 14 && sub_1001B030((int)&v19, 40, v10) == 40 )
    {
      v30 = 1;
      v12 = a4;
      v13 = 0;
      if ( v5 )
      {
        while ( sub_1001B030(v12, v6, v10) == v6 && (!v7 || sub_1001B030((int)&unk_10067260, v7, v10) == v7) )
        {
          v12 += v6;
          if ( ++v13 >= v5 )
          {
            sub_1001AF60(v10);
            return 1;
          }
        }
        v30 = 0;
      }
    }
    sub_1001AF60(v10);
  }
  return v30;
}

//----- (1001C140) --------------------------------------------------------
char __cdecl sub_1001C140(int a1, int a2)
{
  char result; // al@2

  if ( sub_1001B270(a1) )
    result = sub_1001BFF0(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)a1, *(_DWORD *)(a1 + 12), a2);
  else
    result = 0;
  return result;
}

//----- (1001C180) --------------------------------------------------------
signed int __cdecl sub_1001C180(int a1, int a2)
{
  signed int result; // eax@1

  result = 4;
  if ( a1 == 2 )
  {
    byte_100E00B1 = 1;
    byte_100E00B0 = 0;
  }
  else
  {
    if ( a1 == 8 )
    {
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_100E00B0 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    else
    {
      if ( a1 != 9 )
        return result;
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_100E00B1 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    result = 9;
  }
  return result;
}
// 100E00B0: using guessed type char byte_100E00B0;
// 100E00B1: using guessed type char byte_100E00B1;

//----- (1001C1E0) --------------------------------------------------------
bool __cdecl sub_1001C1E0(signed int a1)
{
  if ( a1 > 1 )
  {
    sub_10011C80(13, (int)"..\\lib\\utf\\utf_validate.c", (int)&unk_1007EE58, (int)"failing_subroutine( depth-1 )");
    sub_1001C1E0(a1 - 1);
    exit_0(14);
  }
  return sub_10017140(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"583",
           (int)"Check FAIL macro",
           "UTF_verify_fail: forced fail",
           "UTF_verify_fail: fail forced",
           (int)"This test is expected to fail");
}

//----- (1001C250) --------------------------------------------------------
int sub_1001C250()
{
  const char *v0; // eax@1

  sub_10011CB0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"All Fail Miscellaneous Test Group");
  v0 = sub_10012600(0);
  sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"610", (int)v0);
  sub_10011CB0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"Verify miscellaneous macros");
  if ( byte_100E00B0 )
  {
    sub_10017140(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"620",
      (int)"Check FAIL macro",
      "UTF_verify_fail: forced fail",
      "UTF_verify_fail: fail forced",
      (int)"This test is expected to fail");
    sub_10011C80(13, (int)"..\\lib\\utf\\utf_validate.c", (int)"621", (int)"failing_subroutine( 1 )");
    sub_1001C1E0(1);
    exit_0(14);
  }
  return sub_10011CB0(
           3,
           (int)"**MSG**",
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"616",
           (int)"Failing tests currently disabled. Use FAIL ON command to enable");
}
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001C570) --------------------------------------------------------
char sub_1001C570()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_10011CB0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"All Fail Test Group For Type 'bitmap'");
  v0 = sub_10012600(0);
  sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"700", (int)v0);
  sub_10011CB0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_100E00B0 )
  {
    v2 = 0;
    do
    {
      if ( off_10067ECC[v2] )
      {
        sub_10012470((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_10067ED4[v2 * 4], 0x100u, &v11);
        sub_10012470((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_10067ECC[v2], 0x100u, &v12);
        sub_1001B050(&v12, &v11);
      }
      if ( byte_10067EC8[v2 * 4] )
      {
        sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"725", 2, 2);
        v3 = off_10067ED0[v2];
        v4 = *(char **)&off_10067ED4[v2 * 4];
        v5 = sub_10012710(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10067ED4[v2 * 4],
               off_10067ED0[v2]);
        v6 = sub_10016D90(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"730",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_10012A70(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"731",
                   (int)"Return value from previous UTF_verify_eq_bitmap() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"735", 2, 2);
        v7 = off_10067ED0[v2];
        v8 = *(char **)&off_10067ED4[v2 * 4];
        v9 = sub_10012710(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10067ED4[v2 * 4],
               off_10067ED0[v2]);
        v10 = sub_10016D90(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"740",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_10012A70(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"741",
                   (int)"Return value from previous UTF_verify_ne_bitmap() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 4;
    }
    while ( v2 < 36 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"704",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10067ECC: using guessed type char *off_10067ECC[3];
// 10067ED0: using guessed type char *off_10067ED0[2];
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001C790) --------------------------------------------------------
char sub_1001C790()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10011CB0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_10012600(0);
  sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"768", (int)v0);
  sub_10011CB0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_100E00B0 )
  {
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"776", 2, 2);
    v2 = sub_10012A70(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"777",
           (int)"UTF_verify_eq_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_10012A70(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"778",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"780", 2, 2);
    v3 = sub_10012A70(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"781",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_10012A70(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"782",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"784", 2, 2);
    v4 = sub_10012A70(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"785",
           (int)"UTF_verify_ne_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_10012A70(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"786",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"788", 2, 2);
    v5 = sub_10012A70(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"789",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_10012A70(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"790",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"772",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001C990) --------------------------------------------------------
char sub_1001C990()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"830", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_10067F5C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"830", 2, 2);
        v3 = byte_10067F59[v2 * 4];
        v4 = byte_10067F58[v2 * 4];
        v5 = sub_10012710(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + dword_10067F5C[v2])],
               (&off_10067F60)[v2 * 4]);
        v6 = sub_10012BB0(
               0,
               *(&dword_10067EAC + dword_10067F5C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"830",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_10012710(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_10067F5C[v2]],
               (&off_10067F60)[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"830",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"830",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10067F5C: using guessed type int dword_10067F5C[];
// 10067F60: using guessed type char *off_10067F60;
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001CB10) --------------------------------------------------------
char sub_1001CB10()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"864", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_100681E0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_100681D8[v2 / 8];
        v4 = dbl_100681D0[v2 / 8];
        v5 = dbl_100681C8[v2 / 8];
        v6 = sub_10012710(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               (&off_100681E4)[v2]);
        v7 = sub_10012F60(
               0,
               *(&dword_10067EAC + dword_100681E0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"864",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_100681E0[v2 / 4]],
               (&off_100681E4)[v2]);
        LOBYTE(v0) = sub_10012A70(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"864",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"864",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100681C8: using guessed type double dbl_100681C8[];
// 100681D0: using guessed type double dbl_100681D0[];
// 100681D8: using guessed type double dbl_100681D8[];
// 100681E0: using guessed type int dword_100681E0[];
// 100681E4: using guessed type char *off_100681E4;
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001CC90) --------------------------------------------------------
char sub_1001CC90()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"900", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_10068DF4[v2];
      if ( v0 != 6 )
      {
        v3 = flt_10068DF0[v2];
        v4 = flt_10068DEC[v2];
        v5 = flt_10068DE8[v2];
        v6 = sub_10012710(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               *(_DWORD *)&off_10068DF8[v2 * 4]);
        v7 = sub_100133B0(
               0,
               *(&dword_10067EAC + dword_10068DF4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"900",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_10068DF4[v2]],
               *(_DWORD *)&off_10068DF8[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"900",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"900",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10068DE8: using guessed type float flt_10068DE8[];
// 10068DEC: using guessed type float flt_10068DEC[];
// 10068DF0: using guessed type float flt_10068DF0[];
// 10068DF4: using guessed type int dword_10068DF4[];
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001CE00) --------------------------------------------------------
char sub_1001CE00()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10011CB0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10012600(0);
  sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"922", (int)v0);
  sub_10011CB0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_100E00B0 )
  {
    sub_10017090(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"930",
      (int)"Check ptr for equality",
      (int)sub_1001CE00,
      (int)sub_1001CE00,
      (int)"This test is expected to fail");
    sub_10017090(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"931",
      (int)"Check ptr for inequality",
      (int)sub_1001CE00,
      0,
      (int)"This test is expected to fail");
    result = sub_10017090(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"932",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1001CE00,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"926",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001CF00) --------------------------------------------------------
char sub_1001CF00()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"959", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_1006959C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10069598[v2];
        v4 = dword_10069594[v2];
        v5 = dword_10069590[v2];
        v6 = sub_10012710(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               (&off_100695A0)[v2 * 4]);
        v7 = sub_10013870(
               0,
               *(&dword_10067EAC + dword_1006959C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"959",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_1006959C[v2]],
               (&off_100695A0)[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"959",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"959",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10069590: using guessed type int dword_10069590[];
// 10069594: using guessed type int dword_10069594[];
// 10069598: using guessed type int dword_10069598[];
// 1006959C: using guessed type int dword_1006959C[];
// 100695A0: using guessed type char *off_100695A0;
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001D060) --------------------------------------------------------
char sub_1001D060()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"985", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_10069D30[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_10069D2C[v2 / 2];
        v4 = word_10069D2A[v2 / 2];
        v5 = word_10069D28[v2 / 2];
        v6 = sub_10012710(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               (&off_10069D34)[v2]);
        v7 = sub_10013C30(
               0,
               *(&dword_10067EAC + dword_10069D30[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"985",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_10069D30[v2 / 4]],
               (&off_10069D34)[v2]);
        LOBYTE(v0) = sub_10012A70(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"985",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"985",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10069D28: using guessed type __int16 word_10069D28[];
// 10069D2A: using guessed type __int16 word_10069D2A[];
// 10069D2C: using guessed type __int16 word_10069D2C[];
// 10069D30: using guessed type int dword_10069D30[];
// 10069D34: using guessed type char *off_10069D34;
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001D1C0) --------------------------------------------------------
char sub_1001D1C0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1011", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_1006A344[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1006A340[v2];
        v4 = dword_1006A33C[v2];
        v5 = dword_1006A338[v2];
        v6 = sub_10012710(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               *(_DWORD *)&off_1006A348[v2 * 4]);
        v7 = sub_10014030(
               0,
               *(&dword_10067EAC + dword_1006A344[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1011",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_1006A344[v2]],
               *(_DWORD *)&off_1006A348[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1011",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1011",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1006A338: using guessed type int dword_1006A338[];
// 1006A33C: using guessed type int dword_1006A33C[];
// 1006A340: using guessed type int dword_1006A340[];
// 1006A344: using guessed type int dword_1006A344[];
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001D320) --------------------------------------------------------
char sub_1001D320()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1037", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_1006AAE8[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1006AAE4[v2];
        LODWORD(v3) = dword_1006AAE0[v2];
        HIDWORD(v4) = dword_1006AADC[v2];
        LODWORD(v4) = dword_1006AAD8[v2];
        HIDWORD(v5) = dword_1006AAD4[v2];
        LODWORD(v5) = dword_1006AAD0[v2];
        v6 = sub_10012710(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               *(_DWORD *)&off_1006AAEC[v2 * 4]);
        v7 = sub_100143F0(
               0,
               *(&dword_10067EAC + dword_1006AAE8[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1037",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_1006AAE8[v2]],
               *(_DWORD *)&off_1006AAEC[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1037",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1037",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1006AAD0: using guessed type int dword_1006AAD0[];
// 1006AAD4: using guessed type int dword_1006AAD4[];
// 1006AAD8: using guessed type int dword_1006AAD8[];
// 1006AADC: using guessed type int dword_1006AADC[];
// 1006AAE0: using guessed type int dword_1006AAE0[];
// 1006AAE4: using guessed type int dword_1006AAE4[];
// 1006AAE8: using guessed type int dword_1006AAE8[];
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001D490) --------------------------------------------------------
char sub_1001D490()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1063", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_1006B6F4[v2];
      if ( v0 != 6 )
      {
        v3 = byte_1006B6F2[v2 * 4];
        v4 = byte_1006B6F1[v2 * 4];
        v5 = byte_1006B6F0[v2 * 4];
        v6 = sub_10012710(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               (&off_1006B6F8)[v2 * 4]);
        v7 = sub_10014930(
               0,
               *(&dword_10067EAC + dword_1006B6F4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1063",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_1006B6F4[v2]],
               (&off_1006B6F8)[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1063",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1063",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1006B6F4: using guessed type int dword_1006B6F4[];
// 1006B6F8: using guessed type char *off_1006B6F8;
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001D5F0) --------------------------------------------------------
char sub_1001D5F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1089", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_1006BB8C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1006BB88[v2];
        v4 = dword_1006BB84[v2];
        v5 = dword_1006BB80[v2];
        v6 = sub_10012710(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               (&off_1006BB90)[v2 * 4]);
        v7 = sub_10014D10(
               0,
               *(&dword_10067EAC + dword_1006BB8C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1089",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_1006BB8C[v2]],
               (&off_1006BB90)[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1089",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1089",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1006BB80: using guessed type int dword_1006BB80[];
// 1006BB84: using guessed type int dword_1006BB84[];
// 1006BB88: using guessed type int dword_1006BB88[];
// 1006BB8C: using guessed type int dword_1006BB8C[];
// 1006BB90: using guessed type char *off_1006BB90;
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001D750) --------------------------------------------------------
char sub_1001D750()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10011CB0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_10012600(0);
  sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1113", (int)v0);
  sub_10011CB0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_100E00B0 )
  {
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"1121", 2, 2);
    v2 = sub_10017140(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1122",
           (int)"UTF_verify_eq_str( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_10047869,
           (int)"This test is expected to fail");
    sub_10012A70(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1123",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"1125", 2, 2);
    v3 = sub_10017140(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1126",
           (int)"UTF_verify_eq_str( *, \"\", \"a\" ) data comparison",
           (const char *)&unk_10047869,
           "a",
           (int)"This test is expected to fail");
    sub_10012A70(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1127",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"1129", 2, 2);
    v4 = sub_10017140(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1130",
           (int)"UTF_verify_ne_str( *, \"\", \"\" ) data comparison",
           (const char *)&unk_10047869,
           (const char *)&unk_10047869,
           (int)"This test is expected to fail");
    sub_10012A70(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1131",
      (int)"Return value from previous UTF_verify_ne_str() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"1133", 2, 2);
    v5 = sub_10017140(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1134",
           (int)"UTF_verify_ne_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           (int)"This test is expected to fail");
    result = sub_10012A70(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1135",
               (int)"Return value from previous UTF_verify_ne_str() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1117",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001D970) --------------------------------------------------------
char sub_1001D970()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1162", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_1006C324[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1006C320[v2];
        v4 = dword_1006C31C[v2];
        v5 = dword_1006C318[v2];
        v6 = sub_10012710(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               *(_DWORD *)&off_1006C328[v2 * 4]);
        v7 = sub_100150D0(
               0,
               *(&dword_10067EAC + dword_1006C324[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1162",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_1006C324[v2]],
               *(_DWORD *)&off_1006C328[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1162",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1162",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1006C318: using guessed type int dword_1006C318[];
// 1006C31C: using guessed type int dword_1006C31C[];
// 1006C320: using guessed type int dword_1006C320[];
// 1006C324: using guessed type int dword_1006C324[];
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001DAD0) --------------------------------------------------------
char sub_1001DAD0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1188", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_1006C690[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_1006C68C[v2 / 2];
        v4 = word_1006C68A[v2 / 2];
        v5 = word_1006C688[v2 / 2];
        v6 = sub_10012710(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               (&off_1006C694)[v2]);
        v7 = sub_10015470(
               0,
               *(&dword_10067EAC + dword_1006C690[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1188",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_1006C690[v2 / 4]],
               (&off_1006C694)[v2]);
        LOBYTE(v0) = sub_10012A70(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1188",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1188",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1006C688: using guessed type __int16 word_1006C688[];
// 1006C68A: using guessed type __int16 word_1006C68A[];
// 1006C68C: using guessed type __int16 word_1006C68C[];
// 1006C690: using guessed type int dword_1006C690[];
// 1006C694: using guessed type char *off_1006C694;
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001DC30) --------------------------------------------------------
char sub_1001DC30()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1214", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_1006C954[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1006C950[v2];
        v4 = dword_1006C94C[v2];
        v5 = dword_1006C948[v2];
        v6 = sub_10012710(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               *(_DWORD *)&off_1006C958[v2 * 4]);
        v7 = sub_10015870(
               0,
               *(&dword_10067EAC + dword_1006C954[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1214",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_1006C954[v2]],
               *(_DWORD *)&off_1006C958[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1214",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1214",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1006C948: using guessed type int dword_1006C948[];
// 1006C94C: using guessed type int dword_1006C94C[];
// 1006C950: using guessed type int dword_1006C950[];
// 1006C954: using guessed type int dword_1006C954[];
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001DD90) --------------------------------------------------------
char sub_1001DD90()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1240", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_1006CCD0[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1006CCCC[v2];
        LODWORD(v3) = dword_1006CCC8[v2];
        HIDWORD(v4) = dword_1006CCC4[v2];
        LODWORD(v4) = dword_1006CCC0[v2];
        HIDWORD(v5) = dword_1006CCBC[v2];
        LODWORD(v5) = dword_1006CCB8[v2];
        v6 = sub_10012710(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               *(_DWORD *)&off_1006CCD4[v2 * 4]);
        v7 = sub_10015C10(
               0,
               *(&dword_10067EAC + dword_1006CCD0[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1240",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_1006CCD0[v2]],
               *(_DWORD *)&off_1006CCD4[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1240",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1240",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1006CCB8: using guessed type int dword_1006CCB8[];
// 1006CCBC: using guessed type int dword_1006CCBC[];
// 1006CCC0: using guessed type int dword_1006CCC0[];
// 1006CCC4: using guessed type int dword_1006CCC4[];
// 1006CCC8: using guessed type int dword_1006CCC8[];
// 1006CCCC: using guessed type int dword_1006CCCC[];
// 1006CCD0: using guessed type int dword_1006CCD0[];
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001DF00) --------------------------------------------------------
char sub_1001DF00()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1266", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_1006D23C[v2];
      if ( v0 != 6 )
      {
        v3 = byte_1006D23A[v2 * 4];
        v4 = byte_1006D239[v2 * 4];
        v5 = byte_1006D238[v2 * 4];
        v6 = sub_10012710(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               (&off_1006D240)[v2 * 4]);
        v7 = sub_100161F0(
               0,
               *(&dword_10067EAC + dword_1006D23C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1266",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_1006D23C[v2]],
               (&off_1006D240)[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1266",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1266",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1006D23C: using guessed type int dword_1006D23C[];
// 1006D240: using guessed type char *off_1006D240;
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001E060) --------------------------------------------------------
char sub_1001E060()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1292", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_1006D454[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1006D450[v2];
        v4 = dword_1006D44C[v2];
        v5 = dword_1006D448[v2];
        v6 = sub_10012710(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               *(_DWORD *)&off_1006D458[v2 * 4]);
        v7 = sub_100165E0(
               0,
               *(&dword_10067EAC + dword_1006D454[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1292",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_1006D454[v2]],
               *(_DWORD *)&off_1006D458[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1292",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1292",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1006D448: using guessed type int dword_1006D448[];
// 1006D44C: using guessed type int dword_1006D44C[];
// 1006D450: using guessed type int dword_1006D450[];
// 1006D454: using guessed type int dword_1006D454[];
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001E1C0) --------------------------------------------------------
char sub_1001E1C0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_10011CB0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"All Fail Robustness Test Group For Type 'bitmap'");
  v0 = sub_10012600(0);
  sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1337", (int)v0);
  sub_10011CB0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_100E00B0 )
  {
    v2 = 0;
    do
    {
      if ( off_1006D7BC[v2] )
      {
        sub_10012470((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_1006D7C4[v2 * 4], 0x100u, &v11);
        sub_10012470((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_1006D7BC[v2], 0x100u, &v12);
        sub_1001B050(&v12, &v11);
      }
      if ( byte_1006D7B8[v2 * 4] )
      {
        sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"1362", 2, 2);
        v3 = off_1006D7C0[v2];
        v4 = *(char **)&off_1006D7C4[v2 * 4];
        v5 = sub_10012710(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1006D7C4[v2 * 4],
               off_1006D7C0[v2]);
        v6 = sub_10016D90(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1367",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_10012A70(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1369",
                   (int)"Return value from previous UTF_verify_eq_bitmap_rt() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"1373", 2, 2);
        v7 = off_1006D7C0[v2];
        v8 = *(char **)&off_1006D7C4[v2 * 4];
        v9 = sub_10012710(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1006D7C4[v2 * 4],
               off_1006D7C0[v2]);
        v10 = sub_10016D90(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"1378",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_10012A70(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1380",
                   (int)"Return value from previous UTF_verify_ne_bitmap_rt() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 4;
    }
    while ( v2 < 36 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1341",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1006D7BC: using guessed type char *off_1006D7BC[3];
// 1006D7C0: using guessed type char *off_1006D7C0[2];
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001E3E0) --------------------------------------------------------
char sub_1001E3E0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10011CB0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_10012600(0);
  sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1407", (int)v0);
  sub_10011CB0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"Verify relationship between boolean values using the UTF_verify_bool_rt() function");
  if ( byte_100E00B0 )
  {
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"1415", 2, 2);
    v2 = sub_10012A70(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1416",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_10012A70(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1417",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"1419", 2, 2);
    v3 = sub_10012A70(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1420",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_10012A70(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1421",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"1423", 2, 2);
    v4 = sub_10012A70(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1424",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_10012A70(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1425",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"1427", 2, 2);
    v5 = sub_10012A70(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1428",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_10012A70(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1429",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1411",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001E5E0) --------------------------------------------------------
char sub_1001E5E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1469", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_1006D84C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"1469", 2, 2);
        v3 = byte_1006D849[v2 * 4];
        v4 = byte_1006D848[v2 * 4];
        v5 = sub_10012710(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + dword_1006D84C[v2])],
               (&off_1006D850)[v2 * 4]);
        v6 = sub_10012BB0(
               1,
               *(&dword_10067EAC + dword_1006D84C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1469",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_10012710(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_1006D84C[v2]],
               (&off_1006D850)[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1469",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1469",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1006D84C: using guessed type int dword_1006D84C[];
// 1006D850: using guessed type char *off_1006D850;
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001E760) --------------------------------------------------------
char sub_1001E760()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1503", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_1006DAD0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_1006DAC8[v2 / 8];
        v4 = dbl_1006DAC0[v2 / 8];
        v5 = dbl_1006DAB8[v2 / 8];
        v6 = sub_10012710(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               *(_DWORD *)&off_1006DAD4[v2]);
        v7 = sub_10012F60(
               1,
               *(&dword_10067EAC + dword_1006DAD0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1503",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_1006DAD0[v2 / 4]],
               *(_DWORD *)&off_1006DAD4[v2]);
        LOBYTE(v0) = sub_10012A70(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1503",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1503",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1006DAB8: using guessed type double dbl_1006DAB8[];
// 1006DAC0: using guessed type double dbl_1006DAC0[];
// 1006DAC8: using guessed type double dbl_1006DAC8[];
// 1006DAD0: using guessed type int dword_1006DAD0[];
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001E8E0) --------------------------------------------------------
char sub_1001E8E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1539", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_1006E6E4[v2];
      if ( v0 != 6 )
      {
        v3 = flt_1006E6E0[v2];
        v4 = flt_1006E6DC[v2];
        v5 = flt_1006E6D8[v2];
        v6 = sub_10012710(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               *(_DWORD *)&off_1006E6E8[v2 * 4]);
        v7 = sub_100133B0(
               1,
               *(&dword_10067EAC + dword_1006E6E4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1539",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_1006E6E4[v2]],
               *(_DWORD *)&off_1006E6E8[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1539",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1539",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1006E6D8: using guessed type float flt_1006E6D8[];
// 1006E6DC: using guessed type float flt_1006E6DC[];
// 1006E6E0: using guessed type float flt_1006E6E0[];
// 1006E6E4: using guessed type int dword_1006E6E4[];
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001EA50) --------------------------------------------------------
char sub_1001EA50()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10011CB0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10012600(0);
  sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1561", (int)v0);
  sub_10011CB0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_100E00B0 )
  {
    sub_10017090(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1569",
      (int)"Check ptr for equality",
      (int)sub_1001EA50,
      (int)sub_1001EA50,
      0);
    sub_10017090(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1570",
      (int)"Check ptr for inequality",
      (int)sub_1001EA50,
      0,
      0);
    result = sub_10017090(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1571",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1001EA50,
               0);
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1565",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001EB40) --------------------------------------------------------
char sub_1001EB40()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1598", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_1006EE7C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1006EE78[v2];
        v4 = dword_1006EE74[v2];
        v5 = dword_1006EE70[v2];
        v6 = sub_10012710(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               (&off_1006EE80)[v2 * 4]);
        v7 = sub_10013870(
               1,
               *(&dword_10067EAC + dword_1006EE7C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1598",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_1006EE7C[v2]],
               (&off_1006EE80)[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1598",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1598",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1006EE70: using guessed type int dword_1006EE70[];
// 1006EE74: using guessed type int dword_1006EE74[];
// 1006EE78: using guessed type int dword_1006EE78[];
// 1006EE7C: using guessed type int dword_1006EE7C[];
// 1006EE80: using guessed type char *off_1006EE80;
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001ECA0) --------------------------------------------------------
char sub_1001ECA0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1624", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_1006F610[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_1006F60C[v2 / 2];
        v4 = word_1006F60A[v2 / 2];
        v5 = word_1006F608[v2 / 2];
        v6 = sub_10012710(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               (&off_1006F614)[v2]);
        v7 = sub_10013C30(
               1,
               *(&dword_10067EAC + dword_1006F610[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1624",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_1006F610[v2 / 4]],
               (&off_1006F614)[v2]);
        LOBYTE(v0) = sub_10012A70(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1624",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1624",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1006F608: using guessed type __int16 word_1006F608[];
// 1006F60A: using guessed type __int16 word_1006F60A[];
// 1006F60C: using guessed type __int16 word_1006F60C[];
// 1006F610: using guessed type int dword_1006F610[];
// 1006F614: using guessed type char *off_1006F614;
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001EE00) --------------------------------------------------------
char sub_1001EE00()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1650", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_1006FC24[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1006FC20[v2];
        v4 = dword_1006FC1C[v2];
        v5 = dword_1006FC18[v2];
        v6 = sub_10012710(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               *(_DWORD *)&off_1006FC28[v2 * 4]);
        v7 = sub_10014030(
               1,
               *(&dword_10067EAC + dword_1006FC24[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1650",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_1006FC24[v2]],
               *(_DWORD *)&off_1006FC28[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1650",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1650",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1006FC18: using guessed type int dword_1006FC18[];
// 1006FC1C: using guessed type int dword_1006FC1C[];
// 1006FC20: using guessed type int dword_1006FC20[];
// 1006FC24: using guessed type int dword_1006FC24[];
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001EF60) --------------------------------------------------------
char sub_1001EF60()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1676", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_100703C8[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100703C4[v2];
        LODWORD(v3) = dword_100703C0[v2];
        HIDWORD(v4) = dword_100703BC[v2];
        LODWORD(v4) = dword_100703B8[v2];
        HIDWORD(v5) = dword_100703B4[v2];
        LODWORD(v5) = dword_100703B0[v2];
        v6 = sub_10012710(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               *(_DWORD *)&off_100703CC[v2 * 4]);
        v7 = sub_100143F0(
               1,
               *(&dword_10067EAC + dword_100703C8[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1676",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_100703C8[v2]],
               *(_DWORD *)&off_100703CC[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1676",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1676",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100703B0: using guessed type int dword_100703B0[];
// 100703B4: using guessed type int dword_100703B4[];
// 100703B8: using guessed type int dword_100703B8[];
// 100703BC: using guessed type int dword_100703BC[];
// 100703C0: using guessed type int dword_100703C0[];
// 100703C4: using guessed type int dword_100703C4[];
// 100703C8: using guessed type int dword_100703C8[];
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001F0D0) --------------------------------------------------------
char sub_1001F0D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1702", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_10070FD4[v2];
      if ( v0 != 6 )
      {
        v3 = byte_10070FD2[v2 * 4];
        v4 = byte_10070FD1[v2 * 4];
        v5 = byte_10070FD0[v2 * 4];
        v6 = sub_10012710(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               (&off_10070FD8)[v2 * 4]);
        v7 = sub_10014930(
               1,
               *(&dword_10067EAC + dword_10070FD4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1702",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_10070FD4[v2]],
               (&off_10070FD8)[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1702",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1702",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10070FD4: using guessed type int dword_10070FD4[];
// 10070FD8: using guessed type char *off_10070FD8;
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001F230) --------------------------------------------------------
char sub_1001F230()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1728", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_1007146C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10071468[v2];
        v4 = dword_10071464[v2];
        v5 = dword_10071460[v2];
        v6 = sub_10012710(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               (&off_10071470)[v2 * 4]);
        v7 = sub_10014D10(
               1,
               *(&dword_10067EAC + dword_1007146C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1728",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_1007146C[v2]],
               (&off_10071470)[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1728",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1728",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10071460: using guessed type int dword_10071460[];
// 10071464: using guessed type int dword_10071464[];
// 10071468: using guessed type int dword_10071468[];
// 1007146C: using guessed type int dword_1007146C[];
// 10071470: using guessed type char *off_10071470;
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001F390) --------------------------------------------------------
char sub_1001F390()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10011CB0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_10012600(0);
  sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1752", (int)v0);
  sub_10011CB0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_100E00B0 )
  {
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"1760", 2, 2);
    v2 = sub_10017140(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1761",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_10047869,
           0);
    sub_10012A70(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1762",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"1764", 2, 2);
    v3 = sub_10017140(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1765",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"a\" ) data comparison",
           (const char *)&unk_10047869,
           "a",
           0);
    sub_10012A70(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1766",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"1768", 2, 2);
    v4 = sub_10017140(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1769",
           (int)"UTF_verify_ne_str_rt( *, \"\", \"\" ) data comparison",
           (const char *)&unk_10047869,
           (const char *)&unk_10047869,
           0);
    sub_10012A70(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1770",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"1772", 2, 2);
    v5 = sub_10017140(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1773",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    result = sub_10012A70(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1774",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1756",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001F590) --------------------------------------------------------
char sub_1001F590()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1801", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_10071C04[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10071C00[v2];
        v4 = dword_10071BFC[v2];
        v5 = dword_10071BF8[v2];
        v6 = sub_10012710(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               *(_DWORD *)&off_10071C08[v2 * 4]);
        v7 = sub_100150D0(
               1,
               *(&dword_10067EAC + dword_10071C04[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1801",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_10071C04[v2]],
               *(_DWORD *)&off_10071C08[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1801",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1801",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10071BF8: using guessed type int dword_10071BF8[];
// 10071BFC: using guessed type int dword_10071BFC[];
// 10071C00: using guessed type int dword_10071C00[];
// 10071C04: using guessed type int dword_10071C04[];
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001F6F0) --------------------------------------------------------
char sub_1001F6F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1827", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_10071F70[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_10071F6C[v2 / 2];
        v4 = word_10071F6A[v2 / 2];
        v5 = word_10071F68[v2 / 2];
        v6 = sub_10012710(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               (&off_10071F74)[v2]);
        v7 = sub_10015470(
               1,
               *(&dword_10067EAC + dword_10071F70[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1827",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_10071F70[v2 / 4]],
               (&off_10071F74)[v2]);
        LOBYTE(v0) = sub_10012A70(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1827",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1827",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10071F68: using guessed type __int16 word_10071F68[];
// 10071F6A: using guessed type __int16 word_10071F6A[];
// 10071F6C: using guessed type __int16 word_10071F6C[];
// 10071F70: using guessed type int dword_10071F70[];
// 10071F74: using guessed type char *off_10071F74;
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001F850) --------------------------------------------------------
char sub_1001F850()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1853", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_10072234[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10072230[v2];
        v4 = dword_1007222C[v2];
        v5 = dword_10072228[v2];
        v6 = sub_10012710(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               *(_DWORD *)&off_10072238[v2 * 4]);
        v7 = sub_10015870(
               1,
               *(&dword_10067EAC + dword_10072234[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1853",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_10072234[v2]],
               *(_DWORD *)&off_10072238[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1853",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1853",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10072228: using guessed type int dword_10072228[];
// 1007222C: using guessed type int dword_1007222C[];
// 10072230: using guessed type int dword_10072230[];
// 10072234: using guessed type int dword_10072234[];
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001F9B0) --------------------------------------------------------
char sub_1001F9B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1879", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_100725B0[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100725AC[v2];
        LODWORD(v3) = dword_100725A8[v2];
        HIDWORD(v4) = dword_100725A4[v2];
        LODWORD(v4) = dword_100725A0[v2];
        HIDWORD(v5) = dword_1007259C[v2];
        LODWORD(v5) = dword_10072598[v2];
        v6 = sub_10012710(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               *(_DWORD *)&off_100725B4[v2 * 4]);
        v7 = sub_10015C10(
               1,
               *(&dword_10067EAC + dword_100725B0[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1879",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_100725B0[v2]],
               *(_DWORD *)&off_100725B4[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1879",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1879",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10072598: using guessed type int dword_10072598[];
// 1007259C: using guessed type int dword_1007259C[];
// 100725A0: using guessed type int dword_100725A0[];
// 100725A4: using guessed type int dword_100725A4[];
// 100725A8: using guessed type int dword_100725A8[];
// 100725AC: using guessed type int dword_100725AC[];
// 100725B0: using guessed type int dword_100725B0[];
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001FB20) --------------------------------------------------------
char sub_1001FB20()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1905", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_10072B1C[v2];
      if ( v0 != 6 )
      {
        v3 = byte_10072B1A[v2 * 4];
        v4 = byte_10072B19[v2 * 4];
        v5 = byte_10072B18[v2 * 4];
        v6 = sub_10012710(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               (&off_10072B20)[v2 * 4]);
        v7 = sub_100161F0(
               1,
               *(&dword_10067EAC + dword_10072B1C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1905",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_10072B1C[v2]],
               (&off_10072B20)[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1905",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1905",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10072B1C: using guessed type int dword_10072B1C[];
// 10072B20: using guessed type char *off_10072B20;
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001FC80) --------------------------------------------------------
char sub_1001FC80()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_100E00B0 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1931", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_10072D34[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10072D30[v2];
        v4 = dword_10072D2C[v2];
        v5 = dword_10072D28[v2];
        v6 = sub_10012710(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * *(&dword_10067EAC + v0)],
               *(_DWORD *)&off_10072D38[v2 * 4]);
        v7 = sub_100165E0(
               1,
               *(&dword_10067EAC + dword_10072D34[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1931",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10012710(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_10072D34[v2]],
               *(_DWORD *)&off_10072D38[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1931",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1931",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10072D28: using guessed type int dword_10072D28[];
// 10072D2C: using guessed type int dword_10072D2C[];
// 10072D30: using guessed type int dword_10072D30[];
// 10072D34: using guessed type int dword_10072D34[];
// 100E00B0: using guessed type char byte_100E00B0;

//----- (1001FDE0) --------------------------------------------------------
char sub_1001FDE0()
{
  const char *v0; // eax@1
  int v1; // esi@1
  char result; // al@2
  char v3; // al@5

  sub_10011CB0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"All Pass Miscellaneous Test Group");
  v0 = sub_10012600(0);
  sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1968", (int)v0);
  sub_10011CB0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"Verify miscellaneous macros");
  v1 = 5;
  if ( byte_100E00B1 )
  {
    sub_10017140(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1978",
      (int)"Check PASS macro",
      "UTF_verify_pass unconditional pass",
      "UTF_verify_pass unconditional pass",
      0);
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"1987", 0, 0);
    sub_10011CB0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1988", (int)"Sub-group A, msg 1");
    sub_10011CB0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1989", (int)"Sub-group A, msg 2");
    sub_10011CB0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1990", (int)"Sub-group A, msg 3");
    sub_10011CB0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1991", (int)"Sub-group A, msg 4");
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"1993", 0, 0);
    sub_10011CB0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1994", (int)"Sub-group B, msg 1");
    sub_10011CB0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1995", (int)"Sub-group B, msg 2");
    sub_10011CB0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1996", (int)"Sub-group B, msg 3");
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"1998", 1, 2);
    sub_10013870(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"1999", (int)"Sub-group C verify 1", 1, 1, 0, 0);
    sub_10011CB0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2000", (int)"Sub-group C, msg 1");
    sub_10011CB0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2001", (int)"Sub-group C, msg 2");
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2003", 2, 2);
    sub_10011CB0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2004", (int)"Sub-group D, msg 1");
    sub_10013870(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2005", (int)"Sub-group D verify 1", 1, 1, 0, 0);
    sub_10011CB0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2006", (int)"Sub-group D, msg 2");
    sub_10013870(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2007", (int)"Sub-group D verify 2", 2, 2, 0, 0);
    sub_10011CB0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2009", (int)"non sub-group msg 1");
    sub_10011CB0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2010", (int)"non sub-group msg 2");
    sub_10013870(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2011", (int)"non sub-group verify 1", 1, 1, 0, 0);
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2013", 3, 4);
    sub_10011CB0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2014", (int)"Sub-group E, msg 1");
    sub_10013870(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2015", (int)"Sub-group E verify 1", 1, 1, 0, 0);
    sub_10011CB0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2016", (int)"Sub-group E, msg 2");
    sub_10013870(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2017", (int)"Sub-group E verify 2", 2, 2, 0, 0);
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2019", 3, 4);
    sub_10013870(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2020", (int)"Sub-group F verify 1", 1, 1, 0, 0);
    sub_10011CB0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2021", (int)"Sub-group F, msg 1");
    sub_10013870(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2022", (int)"Sub-group F verify 2", 2, 2, 0, 0);
    sub_10011CB0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2023", (int)"Sub-group F, msg 2");
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2025", 4, 0);
    sub_10013870(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2026", (int)"Sub-group G verify 1", 1, 1, 0, 0);
    sub_10011CB0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2027", (int)"Sub-group G, msg 1");
    sub_10011CB0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2028", (int)"Sub-group G, msg 2");
    sub_10013870(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2029", (int)"Sub-group G verify 2", 2, 2, 0, 0);
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2030", 5, 0);
    sub_10011CB0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2032", (int)"non sub-group msg 3");
    sub_10011CB0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2033", (int)"non sub-group msg 4");
    sub_10013870(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2034", (int)"non sub-group verify 2", 2, 2, 0, 0);
    if ( !sub_10010710() )
      v1 = 3;
    sub_10013870(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2037",
      (int)"Verify x is 3 using UTF_CALL_UNIT",
      v1,
      3,
      0,
      0);
    v3 = sub_10010710();
    sub_10013870(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2040",
      (int)"Verify x is 4 using UTF_CALL_UNIT2",
      v3 != 0 ? 6 : 4,
      4,
      0,
      0);
    sub_10011CB0(
      3,
      (int)"**MSG**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2042",
      (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceeds the int"
           "ernal UTF buffer size, can be written to the output without the system crashing or otherwise demonstrating ha"
           "rmful side-effects. If the system does crash while writing this message, it is a sign that possibly the UTF h"
           "as some buffer overlow issues that should be examined and corrected. If the system runs successfully, it does"
           " not prove the UTF is defect free in this regard, only that this particular scenario is succesfully handled u"
           "nder the current conditions. Other invocations of UTF interfaces with large messages may be problematic, but "
           "at least on the surface, things seem to be OK for now.");
    result = sub_10013870(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2043",
               (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceed"
                    "s the internal UTF buffer size, can be written to the output without the system crashing or otherwis"
                    "e demonstrating harmful side-effects. If the system does crash while writing this message, it is a s"
                    "ign that possibly the UTF has some buffer overlow issues that should be examined and corrected. If t"
                    "he system runs successfully, it does not prove the UTF is defect free in this regard, only that this"
                    " particular scenario is succesfully handled under the current conditions. Other invocations of UTF i"
                    "nterfaces with large messages may be problematic, but at least on the surface, things seem to be OK for now.",
               4,
               4,
               0,
               0);
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1974",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10020380) --------------------------------------------------------
char sub_10020380()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  char *v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_10011CB0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"All Pass Test Group For Type 'bitmap'");
  v0 = sub_10012600(0);
  sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2085", (int)v0);
  sub_10011CB0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_100E00B1 )
  {
    v2 = 0;
    do
    {
      if ( off_1007309C[v2] )
      {
        sub_10012470((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100730A4[v2 * 4], 0x100u, &v13);
        sub_10012470((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_1007309C[v2], 0x100u, &v14);
        sub_1001B050(&v14, &v13);
      }
      if ( byte_10073098[v2 * 4] )
      {
        sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2110", 2, 2);
        v3 = off_100730A0[v2];
        v4 = *(char **)&off_100730A4[v2 * 4];
        v5 = sub_10012710(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100730A4[v2 * 4],
               off_100730A0[v2]);
        v12 = 1;
        v11 = sub_10016D90(
                0,
                0,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2114",
                (int)v5,
                (int)v4,
                (int)v3,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_eq_bitmap() call";
        v9 = "2115";
      }
      else
      {
        sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2119", 2, 2);
        v6 = off_100730A0[v2];
        v7 = *(char **)&off_100730A4[v2 * 4];
        v8 = sub_10012710(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100730A4[v2 * 4],
               off_100730A0[v2]);
        v12 = 1;
        v11 = sub_10016D90(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2123",
                (int)v8,
                (int)v7,
                (int)v6,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_ne_bitmap() call";
        v9 = "2124";
      }
      result = sub_10012A70(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 4;
    }
    while ( v2 < 20 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2089",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1007309C: using guessed type char *off_1007309C[3];
// 100730A0: using guessed type char *off_100730A0[2];
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10020590) --------------------------------------------------------
char sub_10020590()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10011CB0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_10012600(0);
  sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2151", (int)v0);
  sub_10011CB0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_100E00B1 )
  {
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2159", 2, 2);
    v2 = sub_10012A70(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2160",
           (int)"UTF_verify_eq_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_10012A70(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2161",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      0);
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2163", 2, 2);
    v3 = sub_10012A70(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2164",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_10012A70(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2165",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      0);
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2167", 2, 2);
    v4 = sub_10012A70(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2168",
           (int)"UTF_verify_ne_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_10012A70(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2169",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      0);
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2171", 2, 2);
    v5 = sub_10012A70(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2172",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_10012A70(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2173",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2155",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10020780) --------------------------------------------------------
char sub_10020780()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_100730EC[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2213", 2, 2);
        v3 = byte_100730E9[v2 * 4];
        v4 = byte_100730E8[v2 * 4];
        v5 = sub_10012710(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * dword_100730EC[v2]],
               (&off_100730F0)[v2 * 4]);
        v6 = sub_10012BB0(0, dword_100730EC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v5, v4, v3, 0);
        v7 = sub_10012710(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_100730EC[v2]],
               (&off_100730F0)[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2213",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 100730EC: using guessed type int dword_100730EC[];
// 100730F0: using guessed type char *off_100730F0;
// 100E00B1: using guessed type char byte_100E00B1;

//----- (100208F0) --------------------------------------------------------
char sub_100208F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2247", 2, 2);
      v3 = dbl_10073368[v2 / 2];
      v4 = dbl_10073360[v2 / 2];
      v5 = dbl_10073358[v2 / 2];
      v6 = sub_10012710(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_10073370[v2]],
             *(_DWORD *)&off_10073374[v2 * 4]);
      v7 = sub_10012F60(0, dword_10073370[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_10073370[v2]],
             *(_DWORD *)&off_10073374[v2 * 4]);
      result = sub_10012A70(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2247",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10073358: using guessed type double dbl_10073358[];
// 10073360: using guessed type double dbl_10073360[];
// 10073368: using guessed type double dbl_10073368[];
// 10073370: using guessed type int dword_10073370[];
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10020A60) --------------------------------------------------------
char sub_10020A60()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2283", 2, 2);
      v3 = flt_10073F80[v2];
      v4 = flt_10073F7C[v2];
      v5 = flt_10073F78[v2];
      v6 = sub_10012710(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_10073F84[v2]],
             *(_DWORD *)&off_10073F88[v2 * 4]);
      v7 = sub_100133B0(0, dword_10073F84[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_10073F84[v2]],
             *(_DWORD *)&off_10073F88[v2 * 4]);
      result = sub_10012A70(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2283",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10073F78: using guessed type float flt_10073F78[];
// 10073F7C: using guessed type float flt_10073F7C[];
// 10073F80: using guessed type float flt_10073F80[];
// 10073F84: using guessed type int dword_10073F84[];
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10020BC0) --------------------------------------------------------
char sub_10020BC0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10011CB0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10012600(0);
  sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2305", (int)v0);
  sub_10011CB0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_100E00B1 )
  {
    sub_10017090(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2313",
      (int)"Check ptr for equality",
      (int)sub_10020BC0,
      (int)sub_10020BC0,
      0);
    sub_10017090(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2314",
      (int)"Check ptr for inequality",
      (int)sub_10020BC0,
      0,
      0);
    result = sub_10017090(
               0,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2315",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10020BC0,
               0);
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2309",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10020CB0) --------------------------------------------------------
char sub_10020CB0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2342", 2, 2);
      v3 = dword_10074718[v2];
      v4 = dword_10074714[v2];
      v5 = dword_10074710[v2];
      v6 = sub_10012710(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_1007471C[v2]],
             (&off_10074720)[v2 * 4]);
      v7 = sub_10013870(0, dword_1007471C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_1007471C[v2]],
             (&off_10074720)[v2 * 4]);
      result = sub_10012A70(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2342",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10074710: using guessed type int dword_10074710[];
// 10074714: using guessed type int dword_10074714[];
// 10074718: using guessed type int dword_10074718[];
// 1007471C: using guessed type int dword_1007471C[];
// 10074720: using guessed type char *off_10074720;
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10020E10) --------------------------------------------------------
char sub_10020E10()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2368", 2, 2);
      v3 = word_10074EAC[v2 / 2];
      v4 = word_10074EAA[v2 / 2];
      v5 = word_10074EA8[v2 / 2];
      v6 = sub_10012710(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_10074EB0[v2 / 4]],
             (&off_10074EB4)[v2]);
      v7 = sub_10013C30(
             0,
             dword_10074EB0[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2368",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_10074EB0[v2 / 4]],
             (&off_10074EB4)[v2]);
      result = sub_10012A70(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2368",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10074EA8: using guessed type __int16 word_10074EA8[];
// 10074EAA: using guessed type __int16 word_10074EAA[];
// 10074EAC: using guessed type __int16 word_10074EAC[];
// 10074EB0: using guessed type int dword_10074EB0[];
// 10074EB4: using guessed type char *off_10074EB4;
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10020F70) --------------------------------------------------------
char sub_10020F70()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2394", 2, 2);
      v3 = dword_100754C0[v2];
      v4 = dword_100754BC[v2];
      v5 = dword_100754B8[v2];
      v6 = sub_10012710(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_100754C4[v2]],
             *(_DWORD *)&off_100754C8[v2 * 4]);
      v7 = sub_10014030(0, dword_100754C4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_100754C4[v2]],
             *(_DWORD *)&off_100754C8[v2 * 4]);
      result = sub_10012A70(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2394",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100754B8: using guessed type int dword_100754B8[];
// 100754BC: using guessed type int dword_100754BC[];
// 100754C0: using guessed type int dword_100754C0[];
// 100754C4: using guessed type int dword_100754C4[];
// 100E00B1: using guessed type char byte_100E00B1;

//----- (100210D0) --------------------------------------------------------
char sub_100210D0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2420", 2, 2);
      HIDWORD(v3) = dword_10075C64[v2];
      LODWORD(v3) = dword_10075C60[v2];
      HIDWORD(v4) = dword_10075C5C[v2];
      LODWORD(v4) = dword_10075C58[v2];
      HIDWORD(v5) = dword_10075C54[v2];
      LODWORD(v5) = dword_10075C50[v2];
      v6 = sub_10012710(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_10075C68[v2]],
             *(_DWORD *)&off_10075C6C[v2 * 4]);
      v7 = sub_100143F0(0, dword_10075C68[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_10075C68[v2]],
             *(_DWORD *)&off_10075C6C[v2 * 4]);
      result = sub_10012A70(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2420",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10075C50: using guessed type int dword_10075C50[];
// 10075C54: using guessed type int dword_10075C54[];
// 10075C58: using guessed type int dword_10075C58[];
// 10075C5C: using guessed type int dword_10075C5C[];
// 10075C60: using guessed type int dword_10075C60[];
// 10075C64: using guessed type int dword_10075C64[];
// 10075C68: using guessed type int dword_10075C68[];
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10021240) --------------------------------------------------------
char sub_10021240()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2446", 2, 2);
      v3 = byte_10076872[v2 * 4];
      v4 = byte_10076871[v2 * 4];
      v5 = byte_10076870[v2 * 4];
      v6 = sub_10012710(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_10076874[v2]],
             (&off_10076878)[v2 * 4]);
      v7 = sub_10014930(0, dword_10076874[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_10076874[v2]],
             (&off_10076878)[v2 * 4]);
      result = sub_10012A70(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2446",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10076874: using guessed type int dword_10076874[];
// 10076878: using guessed type char *off_10076878;
// 100E00B1: using guessed type char byte_100E00B1;

//----- (100213A0) --------------------------------------------------------
char sub_100213A0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2472", 2, 2);
      v3 = dword_10076D08[v2];
      v4 = dword_10076D04[v2];
      v5 = dword_10076D00[v2];
      v6 = sub_10012710(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_10076D0C[v2]],
             (&off_10076D10)[v2 * 4]);
      v7 = sub_10014D10(0, dword_10076D0C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_10076D0C[v2]],
             (&off_10076D10)[v2 * 4]);
      result = sub_10012A70(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2472",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10076D00: using guessed type int dword_10076D00[];
// 10076D04: using guessed type int dword_10076D04[];
// 10076D08: using guessed type int dword_10076D08[];
// 10076D0C: using guessed type int dword_10076D0C[];
// 10076D10: using guessed type char *off_10076D10;
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10021500) --------------------------------------------------------
char sub_10021500()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10011CB0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_10012600(0);
  sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2496", (int)v0);
  sub_10011CB0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_100E00B1 )
  {
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2504", 2, 2);
    v2 = sub_10017140(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2505",
           (int)"UTF_verify_eq_str( *, \"\", \"\" ) data comparison",
           (const char *)&unk_10047869,
           (const char *)&unk_10047869,
           0);
    sub_10012A70(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2506",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      0);
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2508", 2, 2);
    v3 = sub_10017140(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2509",
           (int)"UTF_verify_eq_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_10012A70(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2510",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      0);
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2512", 2, 2);
    v4 = sub_10017140(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2513",
           (int)"UTF_verify_ne_str( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_10047869,
           0);
    sub_10012A70(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2514",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v4,
      1u,
      0);
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2516", 2, 2);
    v5 = sub_10017140(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2517",
           (int)"UTF_verify_ne_str( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_10012A70(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2518",
               (int)"Return value from previous UTF_verify_eq_str() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2500",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10021700) --------------------------------------------------------
char sub_10021700()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2545", 2, 2);
      v3 = dword_100774A0[v2];
      v4 = dword_1007749C[v2];
      v5 = dword_10077498[v2];
      v6 = sub_10012710(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_100774A4[v2]],
             *(_DWORD *)&off_100774A8[v2 * 4]);
      v7 = sub_100150D0(0, dword_100774A4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_100774A4[v2]],
             *(_DWORD *)&off_100774A8[v2 * 4]);
      result = sub_10012A70(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2545",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10077498: using guessed type int dword_10077498[];
// 1007749C: using guessed type int dword_1007749C[];
// 100774A0: using guessed type int dword_100774A0[];
// 100774A4: using guessed type int dword_100774A4[];
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10021860) --------------------------------------------------------
char sub_10021860()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2571", 2, 2);
      v3 = word_1007780C[v2 / 2];
      v4 = word_1007780A[v2 / 2];
      v5 = word_10077808[v2 / 2];
      v6 = sub_10012710(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_10077810[v2 / 4]],
             (&off_10077814)[v2]);
      v7 = sub_10015470(
             0,
             dword_10077810[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2571",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_10077810[v2 / 4]],
             (&off_10077814)[v2]);
      result = sub_10012A70(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2571",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10077808: using guessed type __int16 word_10077808[];
// 1007780A: using guessed type __int16 word_1007780A[];
// 1007780C: using guessed type __int16 word_1007780C[];
// 10077810: using guessed type int dword_10077810[];
// 10077814: using guessed type char *off_10077814;
// 100E00B1: using guessed type char byte_100E00B1;

//----- (100219C0) --------------------------------------------------------
char sub_100219C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2597", 2, 2);
      v3 = dword_10077AD0[v2];
      v4 = dword_10077ACC[v2];
      v5 = dword_10077AC8[v2];
      v6 = sub_10012710(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_10077AD4[v2]],
             *(_DWORD *)&off_10077AD8[v2 * 4]);
      v7 = sub_10015870(0, dword_10077AD4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_10077AD4[v2]],
             *(_DWORD *)&off_10077AD8[v2 * 4]);
      result = sub_10012A70(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2597",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10077AC8: using guessed type int dword_10077AC8[];
// 10077ACC: using guessed type int dword_10077ACC[];
// 10077AD0: using guessed type int dword_10077AD0[];
// 10077AD4: using guessed type int dword_10077AD4[];
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10021B20) --------------------------------------------------------
char sub_10021B20()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2623", 2, 2);
      HIDWORD(v3) = dword_10077E4C[v2];
      LODWORD(v3) = dword_10077E48[v2];
      HIDWORD(v4) = dword_10077E44[v2];
      LODWORD(v4) = dword_10077E40[v2];
      HIDWORD(v5) = dword_10077E3C[v2];
      LODWORD(v5) = dword_10077E38[v2];
      v6 = sub_10012710(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_10077E50[v2]],
             *(_DWORD *)&off_10077E54[v2 * 4]);
      v7 = sub_10015C10(0, dword_10077E50[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_10077E50[v2]],
             *(_DWORD *)&off_10077E54[v2 * 4]);
      result = sub_10012A70(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2623",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10077E38: using guessed type int dword_10077E38[];
// 10077E3C: using guessed type int dword_10077E3C[];
// 10077E40: using guessed type int dword_10077E40[];
// 10077E44: using guessed type int dword_10077E44[];
// 10077E48: using guessed type int dword_10077E48[];
// 10077E4C: using guessed type int dword_10077E4C[];
// 10077E50: using guessed type int dword_10077E50[];
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10021C90) --------------------------------------------------------
char sub_10021C90()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2649", 2, 2);
      v3 = byte_100783BA[v2 * 4];
      v4 = byte_100783B9[v2 * 4];
      v5 = byte_100783B8[v2 * 4];
      v6 = sub_10012710(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_100783BC[v2]],
             (&off_100783C0)[v2 * 4]);
      v7 = sub_100161F0(0, dword_100783BC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_100783BC[v2]],
             (&off_100783C0)[v2 * 4]);
      result = sub_10012A70(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2649",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100783BC: using guessed type int dword_100783BC[];
// 100783C0: using guessed type char *off_100783C0;
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10021DF0) --------------------------------------------------------
char sub_10021DF0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2675", 2, 2);
      v3 = dword_100785D0[v2];
      v4 = dword_100785CC[v2];
      v5 = dword_100785C8[v2];
      v6 = sub_10012710(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_100785D4[v2]],
             *(_DWORD *)&off_100785D8[v2 * 4]);
      v7 = sub_100165E0(0, dword_100785D4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_100785D4[v2]],
             *(_DWORD *)&off_100785D8[v2 * 4]);
      result = sub_10012A70(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2675",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100785C8: using guessed type int dword_100785C8[];
// 100785CC: using guessed type int dword_100785CC[];
// 100785D0: using guessed type int dword_100785D0[];
// 100785D4: using guessed type int dword_100785D4[];
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10021F50) --------------------------------------------------------
char sub_10021F50()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  char *v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_10011CB0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"All Pass Robustness Test Group For Type 'bitmap'");
  v0 = sub_10012600(0);
  sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2716", (int)v0);
  sub_10011CB0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_100E00B1 )
  {
    v2 = 0;
    do
    {
      if ( off_1007893C[v2] )
      {
        sub_10012470((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_10078944[v2 * 4], 0x100u, &v13);
        sub_10012470((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_1007893C[v2], 0x100u, &v14);
        sub_1001B050(&v14, &v13);
      }
      if ( byte_10078938[v2 * 4] )
      {
        sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2741", 2, 2);
        v3 = off_10078940[v2];
        v4 = *(char **)&off_10078944[v2 * 4];
        v5 = sub_10012710(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10078944[v2 * 4],
               off_10078940[v2]);
        v12 = 1;
        v11 = sub_10016D90(
                1,
                0,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2745",
                (int)v5,
                (int)v4,
                (int)v3,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_eq_bitmap_rt() call";
        v9 = "2746";
      }
      else
      {
        sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2750", 2, 2);
        v6 = off_10078940[v2];
        v7 = *(char **)&off_10078944[v2 * 4];
        v8 = sub_10012710(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10078944[v2 * 4],
               off_10078940[v2]);
        v12 = 1;
        v11 = sub_10016D90(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2754",
                (int)v8,
                (int)v7,
                (int)v6,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_ne_bitmap_rt() call";
        v9 = "2755";
      }
      result = sub_10012A70(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 4;
    }
    while ( v2 < 20 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2720",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1007893C: using guessed type char *off_1007893C[3];
// 10078940: using guessed type char *off_10078940[2];
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10022160) --------------------------------------------------------
char sub_10022160()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10011CB0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_10012600(0);
  sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2782", (int)v0);
  sub_10011CB0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_100E00B1 )
  {
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2790", 2, 2);
    v2 = sub_10012A70(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2791",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_10012A70(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2792",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      0);
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2794", 2, 2);
    v3 = sub_10012A70(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2795",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_10012A70(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2796",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      0);
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2798", 2, 2);
    v4 = sub_10012A70(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2799",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_10012A70(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2800",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      0);
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2802", 2, 2);
    v5 = sub_10012A70(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2803",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_10012A70(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2804",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2786",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10022350) --------------------------------------------------------
char sub_10022350()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      v0 = dword_1007898C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2844", 2, 2);
        v3 = byte_10078989[v2 * 4];
        v4 = byte_10078988[v2 * 4];
        v5 = sub_10012710(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10067E90[4 * dword_1007898C[v2]],
               (&off_10078990)[v2 * 4]);
        v6 = sub_10012BB0(1, dword_1007898C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v5, v4, v3, 0);
        v7 = sub_10012710(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10067E90[4 * dword_1007898C[v2]],
               (&off_10078990)[v2 * 4]);
        LOBYTE(v0) = sub_10012A70(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10011CB0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2844",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 1007898C: using guessed type int dword_1007898C[];
// 10078990: using guessed type char *off_10078990;
// 100E00B1: using guessed type char byte_100E00B1;

//----- (100224C0) --------------------------------------------------------
char sub_100224C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2878", 2, 2);
      v3 = dbl_10078C08[v2 / 2];
      v4 = dbl_10078C00[v2 / 2];
      v5 = dbl_10078BF8[v2 / 2];
      v6 = sub_10012710(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_10078C10[v2]],
             *(_DWORD *)&off_10078C14[v2 * 4]);
      v7 = sub_10012F60(1, dword_10078C10[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_10078C10[v2]],
             *(_DWORD *)&off_10078C14[v2 * 4]);
      result = sub_10012A70(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2878",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10078BF8: using guessed type double dbl_10078BF8[];
// 10078C00: using guessed type double dbl_10078C00[];
// 10078C08: using guessed type double dbl_10078C08[];
// 10078C10: using guessed type int dword_10078C10[];
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10022630) --------------------------------------------------------
char sub_10022630()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2914", 2, 2);
      v3 = flt_10079820[v2];
      v4 = flt_1007981C[v2];
      v5 = flt_10079818[v2];
      v6 = sub_10012710(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_10079824[v2]],
             *(_DWORD *)&off_10079828[v2 * 4]);
      v7 = sub_100133B0(1, dword_10079824[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_10079824[v2]],
             *(_DWORD *)&off_10079828[v2 * 4]);
      result = sub_10012A70(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2914",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10079818: using guessed type float flt_10079818[];
// 1007981C: using guessed type float flt_1007981C[];
// 10079820: using guessed type float flt_10079820[];
// 10079824: using guessed type int dword_10079824[];
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10022790) --------------------------------------------------------
char sub_10022790()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10011CB0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10012600(0);
  sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2936", (int)v0);
  sub_10011CB0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_100E00B1 )
  {
    sub_10017090(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2944",
      (int)"Check ptr for equality",
      (int)sub_10022790,
      (int)sub_10022790,
      0);
    sub_10017090(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2945",
      (int)"Check ptr for inequality",
      (int)sub_10022790,
      0,
      0);
    result = sub_10017090(
               1,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2946",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10022790,
               0);
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2940",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10022880) --------------------------------------------------------
char sub_10022880()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2973", 2, 2);
      v3 = dword_10079FB8[v2];
      v4 = dword_10079FB4[v2];
      v5 = dword_10079FB0[v2];
      v6 = sub_10012710(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_10079FBC[v2]],
             (&off_10079FC0)[v2 * 4]);
      v7 = sub_10013870(1, dword_10079FBC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_10079FBC[v2]],
             (&off_10079FC0)[v2 * 4]);
      result = sub_10012A70(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2973",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10079FB0: using guessed type int dword_10079FB0[];
// 10079FB4: using guessed type int dword_10079FB4[];
// 10079FB8: using guessed type int dword_10079FB8[];
// 10079FBC: using guessed type int dword_10079FBC[];
// 10079FC0: using guessed type char *off_10079FC0;
// 100E00B1: using guessed type char byte_100E00B1;

//----- (100229E0) --------------------------------------------------------
char sub_100229E0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"2999", 2, 2);
      v3 = word_1007A74C[v2 / 2];
      v4 = word_1007A74A[v2 / 2];
      v5 = word_1007A748[v2 / 2];
      v6 = sub_10012710(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_1007A750[v2 / 4]],
             (&off_1007A754)[v2]);
      v7 = sub_10013C30(
             1,
             dword_1007A750[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2999",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_1007A750[v2 / 4]],
             (&off_1007A754)[v2]);
      result = sub_10012A70(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2999",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1007A748: using guessed type __int16 word_1007A748[];
// 1007A74A: using guessed type __int16 word_1007A74A[];
// 1007A74C: using guessed type __int16 word_1007A74C[];
// 1007A750: using guessed type int dword_1007A750[];
// 1007A754: using guessed type char *off_1007A754;
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10022B40) --------------------------------------------------------
char sub_10022B40()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"3025", 2, 2);
      v3 = dword_1007AD60[v2];
      v4 = dword_1007AD5C[v2];
      v5 = dword_1007AD58[v2];
      v6 = sub_10012710(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_1007AD64[v2]],
             *(_DWORD *)&off_1007AD68[v2 * 4]);
      v7 = sub_10014030(1, dword_1007AD64[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_1007AD64[v2]],
             *(_DWORD *)&off_1007AD68[v2 * 4]);
      result = sub_10012A70(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3025",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1007AD58: using guessed type int dword_1007AD58[];
// 1007AD5C: using guessed type int dword_1007AD5C[];
// 1007AD60: using guessed type int dword_1007AD60[];
// 1007AD64: using guessed type int dword_1007AD64[];
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10022CA0) --------------------------------------------------------
char sub_10022CA0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"3051", 2, 2);
      HIDWORD(v3) = dword_1007B504[v2];
      LODWORD(v3) = dword_1007B500[v2];
      HIDWORD(v4) = dword_1007B4FC[v2];
      LODWORD(v4) = dword_1007B4F8[v2];
      HIDWORD(v5) = dword_1007B4F4[v2];
      LODWORD(v5) = dword_1007B4F0[v2];
      v6 = sub_10012710(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_1007B508[v2]],
             *(_DWORD *)&off_1007B50C[v2 * 4]);
      v7 = sub_100143F0(1, dword_1007B508[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_1007B508[v2]],
             *(_DWORD *)&off_1007B50C[v2 * 4]);
      result = sub_10012A70(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3051",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1007B4F0: using guessed type int dword_1007B4F0[];
// 1007B4F4: using guessed type int dword_1007B4F4[];
// 1007B4F8: using guessed type int dword_1007B4F8[];
// 1007B4FC: using guessed type int dword_1007B4FC[];
// 1007B500: using guessed type int dword_1007B500[];
// 1007B504: using guessed type int dword_1007B504[];
// 1007B508: using guessed type int dword_1007B508[];
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10022E10) --------------------------------------------------------
char sub_10022E10()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"3077", 2, 2);
      v3 = byte_1007C112[v2 * 4];
      v4 = byte_1007C111[v2 * 4];
      v5 = byte_1007C110[v2 * 4];
      v6 = sub_10012710(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_1007C114[v2]],
             (&off_1007C118)[v2 * 4]);
      v7 = sub_10014930(1, dword_1007C114[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_1007C114[v2]],
             (&off_1007C118)[v2 * 4]);
      result = sub_10012A70(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3077",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1007C114: using guessed type int dword_1007C114[];
// 1007C118: using guessed type char *off_1007C118;
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10022F70) --------------------------------------------------------
char sub_10022F70()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"3103", 2, 2);
      v3 = dword_1007C5A8[v2];
      v4 = dword_1007C5A4[v2];
      v5 = dword_1007C5A0[v2];
      v6 = sub_10012710(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_1007C5AC[v2]],
             (&off_1007C5B0)[v2 * 4]);
      v7 = sub_10014D10(1, dword_1007C5AC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_1007C5AC[v2]],
             (&off_1007C5B0)[v2 * 4]);
      result = sub_10012A70(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3103",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1007C5A0: using guessed type int dword_1007C5A0[];
// 1007C5A4: using guessed type int dword_1007C5A4[];
// 1007C5A8: using guessed type int dword_1007C5A8[];
// 1007C5AC: using guessed type int dword_1007C5AC[];
// 1007C5B0: using guessed type char *off_1007C5B0;
// 100E00B1: using guessed type char byte_100E00B1;

//----- (100230D0) --------------------------------------------------------
char sub_100230D0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10011CB0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_10012600(0);
  sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3127", (int)v0);
  sub_10011CB0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_100E00B1 )
  {
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"3135", 2, 2);
    v2 = sub_10017140(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3136",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"\" ) data comparison",
           (const char *)&unk_10047869,
           (const char *)&unk_10047869,
           0);
    sub_10012A70(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3137",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"3139", 2, 2);
    v3 = sub_10017140(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3140",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_10012A70(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3141",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"3143", 2, 2);
    v4 = sub_10017140(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3144",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_10047869,
           0);
    sub_10012A70(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3145",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"3147", 2, 2);
    v5 = sub_10017140(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3148",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_10012A70(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3149",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3131",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100E00B1: using guessed type char byte_100E00B1;

//----- (100232D0) --------------------------------------------------------
char sub_100232D0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"3176", 2, 2);
      v3 = dword_1007CD40[v2];
      v4 = dword_1007CD3C[v2];
      v5 = dword_1007CD38[v2];
      v6 = sub_10012710(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_1007CD44[v2]],
             *(_DWORD *)&off_1007CD48[v2 * 4]);
      v7 = sub_100150D0(1, dword_1007CD44[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_1007CD44[v2]],
             *(_DWORD *)&off_1007CD48[v2 * 4]);
      result = sub_10012A70(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3176",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1007CD38: using guessed type int dword_1007CD38[];
// 1007CD3C: using guessed type int dword_1007CD3C[];
// 1007CD40: using guessed type int dword_1007CD40[];
// 1007CD44: using guessed type int dword_1007CD44[];
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10023430) --------------------------------------------------------
char sub_10023430()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"3202", 2, 2);
      v3 = word_1007D0AC[v2 / 2];
      v4 = word_1007D0AA[v2 / 2];
      v5 = word_1007D0A8[v2 / 2];
      v6 = sub_10012710(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_1007D0B0[v2 / 4]],
             (&off_1007D0B4)[v2]);
      v7 = sub_10015470(
             1,
             dword_1007D0B0[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"3202",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_1007D0B0[v2 / 4]],
             (&off_1007D0B4)[v2]);
      result = sub_10012A70(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3202",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1007D0A8: using guessed type __int16 word_1007D0A8[];
// 1007D0AA: using guessed type __int16 word_1007D0AA[];
// 1007D0AC: using guessed type __int16 word_1007D0AC[];
// 1007D0B0: using guessed type int dword_1007D0B0[];
// 1007D0B4: using guessed type char *off_1007D0B4;
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10023590) --------------------------------------------------------
char sub_10023590()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"3228", 2, 2);
      v3 = dword_1007D370[v2];
      v4 = dword_1007D36C[v2];
      v5 = dword_1007D368[v2];
      v6 = sub_10012710(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_1007D374[v2]],
             *(_DWORD *)&off_1007D378[v2 * 4]);
      v7 = sub_10015870(1, dword_1007D374[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_1007D374[v2]],
             *(_DWORD *)&off_1007D378[v2 * 4]);
      result = sub_10012A70(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3228",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1007D368: using guessed type int dword_1007D368[];
// 1007D36C: using guessed type int dword_1007D36C[];
// 1007D370: using guessed type int dword_1007D370[];
// 1007D374: using guessed type int dword_1007D374[];
// 100E00B1: using guessed type char byte_100E00B1;

//----- (100236F0) --------------------------------------------------------
char sub_100236F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"3254", 2, 2);
      HIDWORD(v3) = dword_1007D6EC[v2];
      LODWORD(v3) = dword_1007D6E8[v2];
      HIDWORD(v4) = dword_1007D6E4[v2];
      LODWORD(v4) = dword_1007D6E0[v2];
      HIDWORD(v5) = dword_1007D6DC[v2];
      LODWORD(v5) = dword_1007D6D8[v2];
      v6 = sub_10012710(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_1007D6F0[v2]],
             *(_DWORD *)&off_1007D6F4[v2 * 4]);
      v7 = sub_10015C10(1, dword_1007D6F0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_1007D6F0[v2]],
             *(_DWORD *)&off_1007D6F4[v2 * 4]);
      result = sub_10012A70(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3254",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1007D6D8: using guessed type int dword_1007D6D8[];
// 1007D6DC: using guessed type int dword_1007D6DC[];
// 1007D6E0: using guessed type int dword_1007D6E0[];
// 1007D6E4: using guessed type int dword_1007D6E4[];
// 1007D6E8: using guessed type int dword_1007D6E8[];
// 1007D6EC: using guessed type int dword_1007D6EC[];
// 1007D6F0: using guessed type int dword_1007D6F0[];
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10023860) --------------------------------------------------------
char sub_10023860()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"3280", 2, 2);
      v3 = byte_1007DC5A[v2 * 4];
      v4 = byte_1007DC59[v2 * 4];
      v5 = byte_1007DC58[v2 * 4];
      v6 = sub_10012710(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_1007DC5C[v2]],
             (&off_1007DC60)[v2 * 4]);
      v7 = sub_100161F0(1, dword_1007DC5C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_1007DC5C[v2]],
             (&off_1007DC60)[v2 * 4]);
      result = sub_10012A70(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3280",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1007DC5C: using guessed type int dword_1007DC5C[];
// 1007DC60: using guessed type char *off_1007DC60;
// 100E00B1: using guessed type char byte_100E00B1;

//----- (100239C0) --------------------------------------------------------
char sub_100239C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_100E00B1 )
  {
    sub_10011CB0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_10012600(0);
    sub_10011CB0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v1);
    sub_10011CB0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_100126F0(0);
    v2 = 0;
    do
    {
      sub_10012620((int)"..\\lib\\utf\\utf_validate.c", (int)"3306", 2, 2);
      v3 = dword_1007DE70[v2];
      v4 = dword_1007DE6C[v2];
      v5 = dword_1007DE68[v2];
      v6 = sub_10012710(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10067E90[4 * dword_1007DE74[v2]],
             *(_DWORD *)&off_1007DE78[v2 * 4]);
      v7 = sub_100165E0(1, dword_1007DE74[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v6, v5, v4, v3, 0);
      v8 = sub_10012710(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10067E90[4 * dword_1007DE74[v2]],
             *(_DWORD *)&off_1007DE78[v2 * 4]);
      result = sub_10012A70(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10011CB0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3306",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1007DE68: using guessed type int dword_1007DE68[];
// 1007DE6C: using guessed type int dword_1007DE6C[];
// 1007DE70: using guessed type int dword_1007DE70[];
// 1007DE74: using guessed type int dword_1007DE74[];
// 100E00B1: using guessed type char byte_100E00B1;

//----- (10023B20) --------------------------------------------------------
char **sub_10023B20()
{
  return off_1006957C;
}
// 1006957C: using guessed type char *off_1006957C[3];

//----- (10023B30) --------------------------------------------------------
int __cdecl sub_10023B30(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = a3;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 88) = a2;
  return result;
}

//----- (10023B50) --------------------------------------------------------
int (__cdecl *__usercall sub_10023B50@<eax>(int a1@<eax>, int a2@<ecx>))(int)
{
  int (__cdecl *result)(int); // eax@1

  result = *(int (__cdecl **)(int))(a1 + 88);
  if ( result )
    result = (int (__cdecl *)(int))result(a2);
  return result;
}

//----- (10023B60) --------------------------------------------------------
int __usercall sub_10023B60@<eax>(unsigned __int8 *a1@<eax>, int a2)
{
  signed int v2; // edi@1
  int v3; // ebp@1
  unsigned __int8 *v4; // ebx@1
  unsigned __int8 v5; // al@2
  int v6; // esi@4

  v2 = 0;
  v3 = a2 + 92;
  *(_BYTE *)(a2 + 92) = 0;
  v4 = a1;
  do
  {
    v5 = *v4;
    if ( !*v4 )
      break;
    switch ( v5 )
    {
      case 0x22u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1869967654;
        *(_WORD *)(v6 + 4) = 15220;
        *(_BYTE *)(v6 + 6) = 0;
        break;
      case 0x3Cu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997485606;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x3Eu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997484326;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x26u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1886216486;
        *(_WORD *)(v6 + 4) = 59;
        break;
      case 7u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 24924;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 8u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 25180;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xCu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 26204;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xAu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 28252;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xDu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29276;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 9u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29788;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xBu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 30300;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      default:
        v6 = v2 + v3;
        if ( isprint(v5) )
        {
          *(_BYTE *)v6 = *v4;
          *(_BYTE *)(v2 + a2 + 93) = 0;
        }
        else
        {
          _snprintf((char *)(v2 + v3), 512 - v2, "\\x%x", *v4);
          *(_BYTE *)(a2 + 603) = 0;
        }
        break;
    }
    v2 += strlen((const char *)v6);
    ++v4;
  }
  while ( v2 < 502 );
  return a2 + 92;
}

//----- (10023D90) --------------------------------------------------------
int (__cdecl *__cdecl sub_10023D90(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_10023B50(a1, (int)" ");
  sub_10023B50(a1, a2);
  sub_10023B50(a1, (int)&unk_100820CC);
  v3 = sub_10023B60(a3, a1);
  sub_10023B50(a1, v3);
  return sub_10023B50(a1, (int)&unk_100820C8);
}

//----- (10023DE0) --------------------------------------------------------
int (__cdecl *__cdecl sub_10023DE0(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_10023B50(a1, (int)" ");
  sub_10023B50(a1, a2);
  sub_10023B50(a1, (int)&unk_100820D4);
  v3 = sub_10023B60(a3, a1);
  sub_10023B50(a1, v3);
  return sub_10023B50(a1, (int)&unk_100820D0);
}

//----- (10023E30) --------------------------------------------------------
int (__cdecl *__cdecl sub_10023E30(int a1, unsigned __int8 *a2))(int)
{
  int (__cdecl *result)(int); // eax@1
  int v3; // eax@4

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      sub_10023B50(a1, (int)&unk_100820D8);
      *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    }
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 7) = 1;
    v3 = sub_10023B60(a2, a1);
    result = sub_10023B50(a1, v3);
  }
  return result;
}

//----- (10023E80) --------------------------------------------------------
int (__cdecl *__cdecl sub_10023E80(int a1))(int)
{
  int (__cdecl *result)(int); // eax@1
  void *v2; // ecx@3
  bool v3; // zf@7

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      v2 = &unk_100820E0;
    }
    else
    {
      if ( !*(_BYTE *)(a1 + 8 * (_DWORD)result - 7) )
        sub_10023B50(a1, dword_10082034[(signed int)result]);
      sub_10023B50(a1, (int)&unk_100820DC);
      sub_10023B50(a1, *(_DWORD *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 4));
      v2 = &unk_100820D8;
    }
    result = sub_10023B50(a1, (int)v2);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    v3 = (*(_DWORD *)(a1 + 80))-- == 1;
    if ( v3 )
      result = sub_10023B50(a1, (int)&word_1005C04C);
  }
  return result;
}
// 1005C04C: using guessed type __int16 word_1005C04C;
// 10082034: using guessed type int dword_10082034[];

//----- (10023F00) --------------------------------------------------------
int __cdecl sub_10023F00(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@4

  v2 = *(_DWORD *)(a1 + 80);
  if ( v2 > 0 && *(_BYTE *)(a1 + 8 * v2 - 8) )
  {
    sub_10023B50(a1, (int)&unk_100820D8);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
  }
  sub_10023B50(a1, *((_DWORD *)&off_10082038 + *(_DWORD *)(a1 + 80) + *(_DWORD *)(a1 + 84)));
  sub_10023B50(a1, (int)&unk_100820E4);
  sub_10023B50(a1, a2);
  *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80)) = 1;
  result = *(_DWORD *)(a1 + 80);
  *(_BYTE *)(a1 + 8 * result + 1) = 0;
  *(_DWORD *)(a1 + 8 * (*(_DWORD *)(a1 + 80))++ + 4) = a2;
  return result;
}

//----- (10023F80) --------------------------------------------------------
int (__cdecl *__cdecl sub_10023F80(int a1, unsigned __int8 *a2, char a3))(int)
{
  int v3; // eax@2
  int (__cdecl *result)(int); // eax@2

  if ( a3 )
  {
    v3 = sub_10023B60(a2, a1);
    sub_10023B50(a1, v3);
    result = sub_10023B50(a1, (int)&word_1005C04C);
  }
  else
  {
    sub_10023B50(a1, (int)a2);
    result = sub_10023B50(a1, (int)&word_1005C04C);
  }
  return result;
}
// 1005C04C: using guessed type __int16 word_1005C04C;

//----- (10023FD0) --------------------------------------------------------
int (__cdecl *__cdecl sub_10023FD0(int a1, int a2, unsigned __int8 *a3))(int)
{
  sub_10023F00(a1, a2);
  if ( a3 && *a3 )
    sub_10023E30(a1, a3);
  return sub_10023E80(a1);
}

//----- (10024010) --------------------------------------------------------
int (__cdecl *__cdecl sub_10024010(int a1, int a2, int a3))(int)
{
  char v4; // [sp+8h] [bp-24h]@1
  char v5; // [sp+27h] [bp-5h]@1

  _snprintf(&v4, 0x20u, "%d", a3);
  v5 = 0;
  return sub_10023FD0(a1, a2, (unsigned __int8 *)&v4);
}

//----- (10024070) --------------------------------------------------------
char sub_10024070()
{
  unsigned __int16 v0; // dx@1
  int v1; // ecx@2
  unsigned __int16 v2; // ax@9
  int v4[7]; // [sp+8h] [bp-1Ch]@1

  sub_10024A80(6465, (int)v4, 28);
  v0 = 0;
LABEL_2:
  v1 = v4[v0];
  if ( v1 == 1 || v1 == 2 || v1 == 4 || v1 == 64 || v1 == 128 || v1 == 16 || v1 == 32 )
  {
    v2 = 0;
    while ( v2 == v0 || v4[v2] != v1 )
    {
      if ( ++v2 >= 7u )
      {
        if ( ++v0 < 7u )
          goto LABEL_2;
        return 1;
      }
    }
  }
  return 0;
}
// 10024070: using guessed type int var_1C[7];

//----- (100240F0) --------------------------------------------------------
signed int __fastcall sub_100240F0(unsigned __int8 a1)
{
  signed int result; // eax@1

  result = 176;
  if ( a1 < 0xB0u )
    result = a1;
  return result;
}

//----- (10024100) --------------------------------------------------------
char __cdecl sub_10024100(unsigned __int8 a1)
{
  return byte_10083C24[6 * sub_100240F0(a1)];
}

//----- (10024120) --------------------------------------------------------
__int16 __cdecl sub_10024120(unsigned __int8 a1)
{
  return word_10083C20[3 * sub_100240F0(a1)];
}
// 10083C20: using guessed type __int16 word_10083C20[];

//----- (10024140) --------------------------------------------------------
bool __cdecl sub_10024140(void *a1)
{
  char v1; // cl@1

  v1 = sub_10005900(1, 1946, a1);
  *((_DWORD *)a1 + 1) /= 0x3E8u;
  return v1 && !sub_1000EE60((int)a1);
}

//----- (10024180) --------------------------------------------------------
char sub_10024180()
{
  return 2;
}

//----- (10024190) --------------------------------------------------------
double __cdecl sub_10024190(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 != v4 && (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v11 = v2 + v9;
        result = v11;
      }
      else
      {
        v10 = v4;
        result = v10;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10024230) --------------------------------------------------------
int __cdecl sub_10024230(signed int a1, signed int a2)
{
  int result; // eax@2

  if ( a2 > 0 )
  {
    result = a2 * (a1 / a2);
    if ( a1 == result )
    {
      result = a1;
    }
    else if ( a1 < 0 )
    {
      result -= a2;
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10024270) --------------------------------------------------------
double __cdecl sub_10024270(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 == v4 || (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v10 = v4;
        result = v10;
      }
      else
      {
        v11 = v9 - v2;
        result = v11;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10024310) --------------------------------------------------------
double __cdecl sub_10024310(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  float v4; // [sp+8h] [bp+8h]@5

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    if ( a1 < 0.0 )
      a2 = -v2;
    v4 = v2 * (double)(signed int)((a1 + a2 * 0.5) / v2);
    result = v4;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10024380) --------------------------------------------------------
int __cdecl sub_10024380(int a1)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)a1 = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return result;
}

//----- (10024390) --------------------------------------------------------
int (*__usercall sub_10024390@<eax>(int a1@<eax>, double *a2@<ecx>, int a3@<edi>, int a4@<esi>, int a5, int a6, char a7, double a8, int a9))(void)
{
  double *v9; // ebx@1
  int (*v10)(void); // eax@4
  double v11; // st7@6
  int (*result)(void); // eax@7

  v9 = a2;
  if ( a5 == a1 + 1 )
  {
    if ( !*(_BYTE *)a4 )
    {
      *(_BYTE *)a4 = 1;
      if ( *(_DWORD *)(a3 + 40) )
      {
        v10 = *(int (**)(void))(a3 + 44);
        if ( v10 )
          *(_DWORD *)(a4 + 4) = v10();
      }
    }
    goto LABEL_6;
  }
  if ( a5 != a1 || !*(_BYTE *)a4 || a7 )
  {
LABEL_6:
    v11 = a8;
    goto LABEL_7;
  }
  v11 = *(double *)(a4 + 12);
LABEL_7:
  result = (int (*)(void))a6;
  if ( a5 >= (unsigned int)a6 )
  {
    *v9 = *(double *)(a3 + 16) * v11
        + *(double *)(a3 + 24) * *(double *)(a4 + 12)
        + *(double *)(a3 + 32) * *(double *)(a4 + 20)
        - *(double *)(a4 + 28) * *(double *)a3
        - *(double *)(a3 + 8) * *(double *)(a4 + 36);
    *(double *)(a4 + 20) = *(double *)(a4 + 12);
    *(double *)(a4 + 12) = v11;
    *(double *)(a4 + 36) = *(double *)(a4 + 28);
    *(double *)(a4 + 28) = *v9;
  }
  if ( (a5 == a6 || !*(_BYTE *)a4) && !a7 )
    result = (int (*)(void))sub_10024380(a4);
  *(_BYTE *)a9 = 0;
  if ( *(_BYTE *)a4 )
  {
    if ( !*(_DWORD *)(a3 + 40)
      || (result = *(int (**)(void))(a3 + 44)) != 0
      && (result = (int (*)(void))(result() - *(_DWORD *)(a4 + 4)), (unsigned int)result >= *(_DWORD *)(a3 + 40)) )
    {
      *(_BYTE *)a9 = 1;
    }
  }
  return result;
}

//----- (10024460) --------------------------------------------------------
int __usercall sub_10024460@<eax>(int result@<eax>, _DWORD *a2@<edi>, unsigned int a3@<esi>, char a4)
{
  unsigned int v4; // ecx@3

  *(_DWORD *)(result + 8) >>= 1;
  if ( a4 )
    *(_DWORD *)(result + 8) |= 1 << a3;
  *a2 = 0;
  v4 = 0;
  do
  {
    if ( (1 << v4) & *(_DWORD *)(result + 8) )
      ++*a2;
    ++v4;
  }
  while ( v4 <= a3 );
  return result;
}

//----- (100244A0) --------------------------------------------------------
int (*__cdecl sub_100244A0(char a1, double a2, int a3, int a4, int a5, int a6))(void)
{
  int v6; // eax@1
  int v7; // ecx@1
  int v9; // [sp+18h] [bp-4h]@1

  v6 = sub_10024460(a4, &v9, 5u, a1);
  v7 = v9;
  if ( v9 == 1 )
  {
    if ( a1 )
      *(double *)(v6 + 20) = a2;
  }
  else if ( v9 == 2 )
  {
    if ( a1 )
    {
      *(double *)(v6 + 12) = a2;
      *(double *)(v6 + 36) = 0.0;
    }
  }
  else if ( v9 == 3 && a1 )
  {
    *(double *)(v6 + 28) = 0.0;
    *(double *)(v6 + 20) = *(double *)(v6 + 12);
    *(double *)(v6 + 12) = a2;
  }
  return sub_10024390(5, (double *)a6, a3, v6, v7, 4, a1, a2, a5);
}

//----- (10024530) --------------------------------------------------------
int (*__cdecl sub_10024530(char a1, double a2, int a3, int a4, int a5, int a6))(void)
{
  int v6; // eax@1
  int v7; // ecx@1
  int v9; // [sp+18h] [bp-4h]@1

  v6 = sub_10024460(a4, &v9, 4u, a1);
  v7 = v9;
  if ( v9 == 1 )
  {
    if ( a1 )
    {
      *(double *)(v6 + 20) = a2;
      *(double *)(v6 + 36) = a2;
    }
  }
  else if ( v9 == 2 && a1 )
  {
    *(double *)(v6 + 12) = a2;
    *(double *)(v6 + 28) = (*(double *)(v6 + 20) + a2) * 0.5;
  }
  return sub_10024390(4, (double *)a6, a3, v6, v7, 3, a1, a2, a5);
}

//----- (100245B0) --------------------------------------------------------
int __cdecl sub_100245B0(unsigned __int8 a1, unsigned int a2)
{
  return dword_100A4408[a1 ^ (unsigned __int8)a2] ^ (a2 >> 8);
}
// 100A4408: using guessed type int dword_100A4408[];

//----- (100245D0) --------------------------------------------------------
unsigned int __cdecl sub_100245D0(unsigned int *a1, signed int a2, unsigned int a3)
{
  unsigned int *v3; // edx@1
  unsigned int result; // eax@1
  signed int i; // esi@1
  unsigned int v6; // edi@5
  unsigned int v7; // eax@6
  unsigned int v8; // eax@6
  unsigned int v9; // eax@6
  unsigned int v10; // eax@6
  unsigned int v11; // ecx@6
  unsigned int v12; // ecx@6
  unsigned int v13; // ecx@6

  v3 = a1;
  result = a3;
  for ( i = a2; i; --i )
  {
    if ( !((unsigned __int8)v3 & 3) )
      break;
    result = dword_100A4408[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    v3 = (unsigned int *)((char *)v3 + 1);
  }
  if ( i >= 8 )
  {
    v6 = (unsigned int)i >> 3;
    do
    {
      v7 = dword_100A4408[(unsigned __int8)result ^ (unsigned __int8)*v3] ^ (result >> 8);
      v8 = dword_100A4408[(unsigned __int8)v7 ^ (unsigned __int8)(*(_WORD *)v3 >> 8)] ^ (v7 >> 8);
      v9 = dword_100A4408[(unsigned __int8)v8 ^ (unsigned __int8)(*v3 >> 16)] ^ (v8 >> 8);
      v10 = dword_100A4408[(unsigned __int8)v9 ^ (*v3 >> 24)] ^ (v9 >> 8);
      v3 += 2;
      v11 = dword_100A4408[(unsigned __int8)v10 ^ (unsigned __int8)*(v3 - 1)] ^ (v10 >> 8);
      v12 = dword_100A4408[(unsigned __int8)v11 ^ (unsigned __int8)(*((_WORD *)v3 - 2) >> 8)] ^ (v11 >> 8);
      v13 = dword_100A4408[(unsigned __int8)v12 ^ (unsigned __int8)(*(v3 - 1) >> 16)] ^ (v12 >> 8);
      i -= 8;
      --v6;
      result = dword_100A4408[(unsigned __int8)v13 ^ (*(v3 - 1) >> 24)] ^ (v13 >> 8);
    }
    while ( v6 );
  }
  for ( ; i > 0; v3 = (unsigned int *)((char *)v3 + 1) )
  {
    result = dword_100A4408[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    --i;
  }
  return result;
}
// 100A4408: using guessed type int dword_100A4408[];

//----- (10024700) --------------------------------------------------------
double __cdecl sub_10024700(float a1)
{
  float v2; // [sp+4h] [bp+4h]@1

  v2 = pow(a1 / 101325.0, 0.190228059887886);
  return (float)((1.0 - v2) * -44330.765625);
}

//----- (10024730) --------------------------------------------------------
int __cdecl sub_10024730(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_crit_lvl(a1);
  SYS_exit_krnl();
  return v1;
}
// 10025D4C: using guessed type int SYS_exit_krnl(void);
// 10025D58: using guessed type int SYS_enter_krnl(void);
// 10025D64: using guessed type int __cdecl TSK_pvg_get_crit_lvl(_DWORD);

//----- (10024750) --------------------------------------------------------
int sub_10024750()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_id();
  SYS_exit_krnl();
  return v0;
}
// 10025D4C: using guessed type int SYS_exit_krnl(void);
// 10025D58: using guessed type int SYS_enter_krnl(void);
// 10025D6A: using guessed type int TSK_pvg_get_id(void);

//----- (10024770) --------------------------------------------------------
int __cdecl sub_10024770(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_get_msg(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10025D4C: using guessed type int SYS_exit_krnl(void);
// 10025D58: using guessed type int SYS_enter_krnl(void);
// 10025D70: using guessed type int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD);

//----- (100247A0) --------------------------------------------------------
__int16 __cdecl sub_100247A0(int a1)
{
  __int16 v1; // si@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_run_state(a1);
  SYS_exit_krnl();
  return v1;
}
// 10025D4C: using guessed type int SYS_exit_krnl(void);
// 10025D58: using guessed type int SYS_enter_krnl(void);
// 10025D76: using guessed type int __cdecl TSK_pvg_get_run_state(_DWORD);

//----- (100247C0) --------------------------------------------------------
int sub_100247C0()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_timer();
  SYS_exit_krnl();
  return v0;
}
// 10025D4C: using guessed type int SYS_exit_krnl(void);
// 10025D58: using guessed type int SYS_enter_krnl(void);
// 10025D7C: using guessed type int TSK_pvg_get_timer(void);

//----- (100247E0) --------------------------------------------------------
int __cdecl sub_100247E0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_get_tsk_info(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10025D4C: using guessed type int SYS_exit_krnl(void);
// 10025D58: using guessed type int SYS_enter_krnl(void);
// 10025D82: using guessed type int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10024820) --------------------------------------------------------
int __cdecl sub_10024820(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_kill_process(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10025D4C: using guessed type int SYS_exit_krnl(void);
// 10025D58: using guessed type int SYS_enter_krnl(void);
// 10025D8E: using guessed type int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10024850) --------------------------------------------------------
int __cdecl sub_10024850(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_release_smphr(a1);
  SYS_exit_krnl();
  return v1;
}
// 10025D4C: using guessed type int SYS_exit_krnl(void);
// 10025D58: using guessed type int SYS_enter_krnl(void);
// 10025D94: using guessed type int __cdecl TSK_pvg_release_smphr(_DWORD);

//----- (10024870) --------------------------------------------------------
int __cdecl sub_10024870(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_reserve_smphr(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10025D4C: using guessed type int SYS_exit_krnl(void);
// 10025D58: using guessed type int SYS_enter_krnl(void);
// 10025D9A: using guessed type int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD);

//----- (100248A0) --------------------------------------------------------
int __cdecl sub_100248A0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_msg_ex(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10025D4C: using guessed type int SYS_exit_krnl(void);
// 10025D58: using guessed type int SYS_enter_krnl(void);
// 10025DA0: using guessed type int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD);

//----- (100248D0) --------------------------------------------------------
int __cdecl sub_100248D0(int a1)
{
  SYS_enter_krnl();
  TSK_pvg_set_proc_status(a1);
  return SYS_exit_krnl();
}
// 10025D4C: using guessed type int SYS_exit_krnl(void);
// 10025D58: using guessed type int SYS_enter_krnl(void);
// 10025DA6: using guessed type int __cdecl TSK_pvg_set_proc_status(_DWORD);

//----- (100248F0) --------------------------------------------------------
int __cdecl sub_100248F0(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_suspend(a1);
  SYS_exit_krnl();
  return v1;
}
// 10025D4C: using guessed type int SYS_exit_krnl(void);
// 10025D58: using guessed type int SYS_enter_krnl(void);
// 10025DAC: using guessed type int __cdecl TSK_pvg_suspend(_DWORD);

//----- (10024910) --------------------------------------------------------
int __cdecl sub_10024910(_BYTE *a1)
{
  int v1; // edi@1
  int v2; // eax@2
  char v4; // [sp+8h] [bp-4h]@2

  SYS_enter_krnl();
  v1 = TSK_pvg_wait_evnt(a1);
  SYS_exit_krnl();
  if ( *a1 & 0x20 )
  {
    v2 = sub_10024750();
    sub_100247E0((int)&v4, 5, v2, 4);
  }
  return v1;
}
// 10025D4C: using guessed type int SYS_exit_krnl(void);
// 10025D58: using guessed type int SYS_enter_krnl(void);
// 10025DB2: using guessed type int __cdecl TSK_pvg_wait_evnt(_DWORD);

//----- (10024950) --------------------------------------------------------
int __cdecl sub_10024950(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) != 1 && !a1 )
    result = sub_10024850(a2);
  return result;
}
// 10043900: using guessed type void *tsk_app_hdr_ptr;

//----- (10024980) --------------------------------------------------------
int __cdecl sub_10024980(int a1, int a2)
{
  int result; // eax@2

  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) == 1 )
    result = 0;
  else
    result = sub_10024870(a1, a2);
  return result;
}
// 10043900: using guessed type void *tsk_app_hdr_ptr;

//----- (100249A0) --------------------------------------------------------
int __cdecl sub_100249A0(int a1)
{
  int v1; // ecx@1
  int result; // eax@1

  v1 = 0;
  result = 42066;
  while ( dword_100A80D8[2 * v1] != a1 )
  {
    if ( (unsigned int)++v1 >= 0xA5 )
      return result;
  }
  return dword_100A80DC[2 * v1];
}
// 100A80D8: using guessed type int dword_100A80D8[];
// 100A80DC: using guessed type int dword_100A80DC[];

//----- (100249E0) --------------------------------------------------------
int __cdecl sub_100249E0(int a1, int a2, int a3)
{
  return reg_read(a1, a2, a3, 0);
}
// 10025DB8: using guessed type int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10024A00) --------------------------------------------------------
char __cdecl sub_10024A00(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_100249E0(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10009550("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1255, 1, 0);
  return v3;
}

//----- (10024A40) --------------------------------------------------------
int __cdecl sub_10024A40(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // esi@1

  result = sub_100249E0(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    result = v5;
  }
  return result;
}

//----- (10024A80) --------------------------------------------------------
int __cdecl sub_10024A80(int a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_100249E0(a1 | 0x20000, a2, a3);
  if ( result == -46 )
    result = 0;
  return result;
}

//----- (10024AB0) --------------------------------------------------------
int __cdecl sub_10024AB0(int a1, int a2, int a3)
{
  return sub_10024A80(a1 | 0x40000, a2, a3);
}

//----- (10024AD0) --------------------------------------------------------
int __cdecl sub_10024AD0(int a1, int a2, int a3)
{
  return reg_write(a1, a2, a3, 0);
}
// 10025DBE: using guessed type int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10024AF0) --------------------------------------------------------
int __cdecl sub_10024AF0(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // eax@2
  int result; // eax@4
  int v6; // [sp+10h] [bp-4h]@1

  v6 = sub_10024AD0(a1, a2, a3);
  v3 = 0;
  if ( (unsigned __int8)sub_10025810() )
  {
    v4 = sub_100249A0(a1);
    if ( v4 != 42066 )
      v3 = sub_10024AD0(v4, a2, a3);
  }
  result = v6;
  if ( !v6 )
    result = v3;
  return result;
}
// 10025810: using guessed type int sub_10025810(void);

//----- (10024B50) --------------------------------------------------------
int __cdecl sub_10024B50(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  result = sub_10024AF0(a1, a2, a3);
  v4 = result;
  if ( result )
  {
    sub_10009550("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1742, 1, 0);
    result = v4;
  }
  return result;
}

//----- (10024B90) --------------------------------------------------------
char __cdecl sub_10024B90(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_10024AD0(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10009550("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1826, 1, 0);
  return v3;
}

//----- (10024BD0) --------------------------------------------------------
int __cdecl sub_10024BD0(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // edi@1

  result = sub_100249E0(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    sub_10024AD0(a1, (int)a4, a3);
    result = v5;
  }
  return result;
}

//----- (10024C30) --------------------------------------------------------
int __cdecl sub_10024C30(int a1, int a2)
{
  int v2; // esi@3

  if ( *(_DWORD *)(a1 + 8) < 0 )
    sub_10009550("..\\lib\\acl\\kernel\\mem_usr_share.c", 127, 0, 0);
  v2 = j_mem_unmap(a2 - 12, *(_DWORD *)(a1 + 8) + 12);
  if ( v2 )
    sub_10009550("..\\lib\\acl\\kernel\\mem_usr_share.c", 132, 1, 0);
  return v2;
}
// 10025820: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (10024C90) --------------------------------------------------------
signed int __cdecl sub_10024C90(int a1)
{
  unsigned int v1; // eax@1
  signed int result; // eax@3

  v1 = **(_DWORD **)(a1 + 16);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    if ( *(_BYTE *)(v1 - 3) || *(_BYTE *)(a1 + 4) & 8 )
    {
      if ( *(_BYTE *)(a1 + 4) & 1 )
      {
        *(_BYTE *)(v1 - 3) = 0;
        result = 1;
      }
      else
      {
        sub_10009550("..\\lib\\acl\\kernel\\mem_usr_share.c", 474, 1, 0);
        result = 0;
      }
    }
    else
    {
      sub_10009550("..\\lib\\acl\\kernel\\mem_usr_share.c", 465, 1, 0);
      result = 1;
    }
  }
  else
  {
    sub_10009550("..\\lib\\acl\\kernel\\mem_usr_share.c", 455, 1, 0);
    result = 0;
  }
  return result;
}

//----- (10024D10) --------------------------------------------------------
int __usercall sub_10024D10@<eax>(const char **a1@<esi>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // edi@2
  char v3; // ST28_1@2
  unsigned int v4; // eax@5
  char *v5; // edi@9
  char v6; // al@10
  unsigned int v7; // eax@12
  char v8; // ST28_1@12
  signed int v9; // ebx@15
  int v10; // eax@19
  int result; // eax@47
  unsigned int v12; // [sp+Ch] [bp-98h]@1
  int v13; // [sp+14h] [bp-90h]@29
  char v14; // [sp+1Dh] [bp-87h]@30
  char v15; // [sp+1Fh] [bp-85h]@9
  char v16; // [sp+20h] [bp-84h]@8

  v1 = 0;
  v12 = 0;
  if ( *((_BYTE *)a1 + 4) & 2 )
  {
    v2 = j_FIL_vfs_open(*a1, 4, 0);
    v3 = 4;
  }
  else
  {
    strncpy(&v16, *a1, 0x7Du);
    if ( !(*((_BYTE *)a1 + 4) & 8) )
    {
      v5 = &v15;
      do
        v6 = (v5++)[1];
      while ( v6 );
      *(_DWORD *)v5 = 7368052;
    }
    v12 = j_FIL_vfs_open(*a1, 6, 1809);
    v7 = j_FIL_vfs_open(&v16, 14, 1809);
    v2 = v7;
    v8 = 6;
    if ( v7 >= 0xFFFFFFC2 || !v7 )
    {
      sub_10009550("..\\lib\\acl\\kernel\\mem_usr_share.c", 589, 1, 0);
      goto LABEL_39;
    }
    v9 = sub_100255B0(v7, 0, 2);
    if ( v9 < 0 )
    {
      sub_10009550("..\\lib\\acl\\kernel\\mem_usr_share.c", 602, 1, 0);
      goto LABEL_39;
    }
    if ( (signed int)a1[2] < 0 )
      sub_10009550("..\\lib\\acl\\kernel\\mem_usr_share.c", 610, 0, 0);
    v10 = (int)(a1[2] + 12);
    if ( v9 < v10 && sub_100255D0(v2, v10, (unsigned __int64)v10 >> 32) < 0 )
    {
      sub_10009550("..\\lib\\acl\\kernel\\mem_usr_share.c", 625, 1, 0);
      goto LABEL_39;
    }
  }
  if ( v2 >= 0xFFFFFFC2 )
    goto LABEL_42;
  if ( v2 )
  {
    v4 = ((int (__cdecl *)(unsigned int, _DWORD, const char *, _DWORD))j_FIL_vfs_mmap)(v2, 0, a1[2] + 12, 0);
    v1 = v4;
    if ( v4 < 0xFFFFFFC2 && v4 )
    {
      if ( !(*((_BYTE *)a1 + 4) & 1) )
      {
        if ( *(_BYTE *)(v4 + 9) || *(_BYTE *)(v4 + 8) != 56 )
        {
          sub_10024C30((int)a1, v4 + 12);
          v1 = 0;
        }
        goto LABEL_39;
      }
      *(_DWORD *)(v4 + 4) = sub_100247C0();
      if ( *((_BYTE *)a1 + 4) & 4 )
        memset((void *)(v1 + 12), (int)a1[3], (size_t)a1[2]);
      if ( v12 < 0xFFFFFFC2 && v12 )
      {
        if ( *((_BYTE *)a1 + 4) & 8 )
        {
          ++*(_DWORD *)v1;
        }
        else if ( sub_100253F0(v12, &v13, 12) == 12 )
        {
          *(_DWORD *)v1 = ++v13;
          v14 = 1;
          *(_BYTE *)(v1 + 9) = 1;
          if ( sub_10025560(v12, (int)&v13, 12, 0) != 12 )
          {
            sub_10009550("..\\lib\\acl\\kernel\\mem_usr_share.c", 725, 1, 0);
            goto LABEL_39;
          }
        }
      }
      else
      {
        *(_BYTE *)(v1 + 9) = 1;
        *(_DWORD *)v1 = 1;
      }
      *(_BYTE *)(v1 + 8) = 56;
      if ( !(*((_BYTE *)a1 + 4) & 8) && j_FIL_vfs_rename(&v16, *a1) )
        sub_10009550("..\\lib\\acl\\kernel\\mem_usr_share.c", 759, 1, 0);
      goto LABEL_39;
    }
    sub_10009550("..\\lib\\acl\\kernel\\mem_usr_share.c", 664, 0, 0);
  }
LABEL_39:
  if ( v2 < 0xFFFFFFC2 && v2 )
    sub_10025320(v2);
LABEL_42:
  if ( v12 < 0xFFFFFFC2 && v12 )
    sub_10025320(v12);
  if ( v1 < 0xFFFFFFC2 && v1 )
    result = v1 + 12;
  else
    result = v1;
  return result;
}
// 100253D0: using guessed type int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100253E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 100254B0: using guessed type int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD);

//----- (10025010) --------------------------------------------------------
int __usercall sub_10025010@<eax>(int a1@<eax>, int a2@<ecx>)
{
  return j_mem_unmap(a2 - 12, a1 + 12);
}
// 10025820: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (10025030) --------------------------------------------------------
signed int __cdecl sub_10025030(int a1)
{
  unsigned int v1; // eax@1
  char v2; // bl@1
  int *v3; // edi@6
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // ebp@6
  unsigned int v8; // eax@15

  v1 = **(_DWORD **)(a1 + 16);
  v2 = 0;
  if ( v1 != -858993460 && (v1 < 0xFFFFFFC2 && v1 || v1 == -15) )
  {
    if ( v1 < 0xFFFFFFC2 && v1 && !*(_BYTE *)(v1 - 3) )
      return 1;
  }
  else
  {
    sub_10009550("..\\lib\\acl\\kernel\\mem_usr_share.c", 211, 0, *(char **)a1);
    **(_DWORD **)(a1 + 16) = -15;
  }
  v3 = *(int **)(a1 + 16);
  v4 = sub_10024980(81, 5000);
  v5 = *v3;
  v6 = v4;
  if ( (unsigned int)*v3 < 0xFFFFFFC2 && v5 )
  {
    if ( !*(_BYTE *)(v5 - 3) )
    {
      sub_10024950(v4, 81);
      return 1;
    }
    *v3 = -15;
    sub_10025010(*(_DWORD *)(a1 + 8), v5);
  }
  v8 = sub_10024D10((const char **)a1);
  if ( v8 < 0xFFFFFFC2 && v8 )
  {
    *v3 = v8;
    if ( !*(_BYTE *)(v8 - 3) )
      v2 = 1;
  }
  sub_10024950(v6, 81);
  return (unsigned __int8)v2;
}

//----- (10025100) --------------------------------------------------------
int __cdecl sub_10025100(LONG Value)
{
  char v1; // al@1
  int result; // eax@3
  int v3; // edi@3
  unsigned __int32 v4; // eax@5
  int v5; // ebx@5

  v1 = *(_BYTE *)(Value + 4);
  if ( v1 & 2 || !(v1 & 1) )
  {
    sub_10009550("..\\lib\\acl\\kernel\\mem_usr_share.c", 360, 1, 0);
    result = 0;
  }
  else
  {
    result = sub_10024D10((const char **)Value);
    v3 = result;
    if ( (unsigned int)result < 0xFFFFFFC2 && result )
    {
      v4 = InterlockedExchange(*(volatile LONG **)(Value + 16), result);
      v5 = v4;
      if ( v4 < 0xFFFFFFC2 && v4 )
      {
        if ( *(_DWORD *)(Value + 8) < 0 )
          sub_10009550("..\\lib\\acl\\kernel\\mem_usr_share.c", 388, 0, 0);
        sub_10025010(*(_DWORD *)(Value + 8), v5);
      }
      result = v3;
    }
  }
  return result;
}

//----- (10025190) --------------------------------------------------------
void __cdecl sub_10025190(int a1, _BYTE *a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_get(a1, a2);
  SYS_exit_krnl();
  sub_10025830(a1, a2);
}
// 10025D4C: using guessed type int SYS_exit_krnl(void);
// 10025D58: using guessed type int SYS_enter_krnl(void);
// 10025DC4: using guessed type int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD);

//----- (100251C0) --------------------------------------------------------
int __cdecl sub_100251C0(int a1, int a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_set(a1, a2);
  return SYS_exit_krnl();
}
// 10025D4C: using guessed type int SYS_exit_krnl(void);
// 10025D58: using guessed type int SYS_enter_krnl(void);
// 10025DCA: using guessed type int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD);

//----- (10025250) --------------------------------------------------------
int __cdecl sub_10025250(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_recv_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 10025D4C: using guessed type int SYS_exit_krnl(void);
// 10025D58: using guessed type int SYS_enter_krnl(void);
// 10025DFA: using guessed type int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD);

//----- (100252A0) --------------------------------------------------------
int __cdecl sub_100252A0(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_send_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 10025D4C: using guessed type int SYS_exit_krnl(void);
// 10025D58: using guessed type int SYS_enter_krnl(void);
// 10025E00: using guessed type int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD);

//----- (10025320) --------------------------------------------------------
signed int __cdecl sub_10025320(unsigned int a1)
{
  signed int result; // eax@7
  int v2; // eax@8
  int v3; // edx@9
  unsigned int v4; // [sp+4h] [bp+4h]@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return FIL_vfs_close();
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_100383E0(a1);
    if ( v4 && *(_DWORD *)(v4 + 732) )
    {
      --*(_DWORD *)(*(_DWORD *)(v4 + 732) + 124);
      if ( *(_BYTE *)(v4 + 8) )
        exit_1(v4);
      sub_100401A0(v4 + 116);
      result = 0;
      *(_DWORD *)v4 = -858993460;
    }
    else
    {
      result = -6;
    }
    return result;
  }
  if ( !a1 || (a1 & 3) != 2 )
    return FIL_vfs_close();
  v2 = 0;
  if ( !dword_101536C8 )
    goto LABEL_11;
  while ( 1 )
  {
    v3 = dword_101536D0[v2];
    if ( *(_DWORD *)v3 == a1 )
      break;
    if ( ++v2 >= (unsigned int)dword_101536C8 )
      goto LABEL_11;
  }
  if ( v2 != -1 )
  {
    sub_10025860(
      v2,
      *(_DWORD *)(dword_101536D0[v2] + 12),
      *(_DWORD *)(v3 + 16),
      *(_BYTE *)(v3 + 32),
      *(_WORD *)(v3 + 20),
      *(_DWORD *)(v3 + 4));
    result = sub_10025320(a1 & 0xFFFFFFFC);
  }
  else
  {
LABEL_11:
    result = -6;
  }
  return result;
}
// 10025E18: using guessed type int FIL_vfs_close(void);
// 101536C8: using guessed type int dword_101536C8;
// 101536D0: using guessed type int dword_101536D0[];

//----- (10025380) --------------------------------------------------------
int __cdecl sub_10025380(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-1Ch]@1
  __int64 v7; // [sp+4h] [bp-18h]@1
  __int64 v8; // [sp+10h] [bp-Ch]@1

  v7 = a2;
  v8 = a4;
  return FIL_vfs_memmove_swi(&v6, a1, v7, HIDWORD(v7), a3, v8, HIDWORD(v8), a5);
}
// 10025E2A: using guessed type int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100253F0) --------------------------------------------------------
signed int __cdecl sub_100253F0(unsigned int a1, void *a2, int a3)
{
  int v3; // eax@7
  unsigned int v4; // eax@4
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_100383E0(a1);
    return sub_100392A0(v4, (int)a2, a3);
  }
  if ( a1 && (a1 & 3) == 2 )
  {
    v3 = sub_100255B0(a1 & 0xFFFFFFFC, 0, 1);
    result = sub_10025C00(a1, a2, a3, v3, (unsigned __int64)v3 >> 32);
  }
  else
  {
LABEL_11:
    result = FIL_vfs_read();
  }
  return result;
}
// 10025E3C: using guessed type int FIL_vfs_read(void);

//----- (10025430) --------------------------------------------------------
signed int __cdecl sub_10025430(unsigned int a1, void *a2, int a3, int a4, int a5)
{
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
    return sub_10038360(a1, (int)a2, a3, a4);
  if ( a1 && (a1 & 3) == 2 )
    result = sub_10025C00(a1, a2, a3, a4, a5);
  else
LABEL_11:
    result = FIL_vfs_read_ofst(a1, a2, a3, &a4);
  return result;
}
// 10025E42: using guessed type int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100254C0) --------------------------------------------------------
signed int __cdecl sub_100254C0(unsigned int a1, int a2, int a3, int a4)
{
  signed int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = sub_100383C0(a1, a2, a4);
  else
    result = FIL_vfs_seek(a1 & 0xFFFFFFFC, a2, a3, a4);
  return result;
}
// 10025E4E: using guessed type int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10025510) --------------------------------------------------------
__int64 __cdecl sub_10025510(int a1)
{
  return FIL_vfs_size(a1 & 0xFFFFFFFC);
}
// 10025E54: using guessed type int __cdecl FIL_vfs_size(_DWORD);

//----- (10025530) --------------------------------------------------------
int __cdecl sub_10025530(int a1, int a2, int a3)
{
  return FIL_vfs_truncate(a1, a2, a3);
}
// 10025E5A: using guessed type int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD);

//----- (10025560) --------------------------------------------------------
int __cdecl sub_10025560(int a1, int a2, int a3, char a4)
{
  return FIL_vfs_write_ofst(a1, a2, a3, &a4);
}
// 10025E66: using guessed type int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10025580) --------------------------------------------------------
char __cdecl sub_10025580(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 516, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_10025320(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100253E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (100255B0) --------------------------------------------------------
signed int __cdecl sub_100255B0(unsigned int a1, int a2, int a3)
{
  return sub_100254C0(a1, a2, (unsigned __int64)a2 >> 32, a3);
}

//----- (100255D0) --------------------------------------------------------
int __cdecl sub_100255D0(int a1, int a2, int a3)
{
  return sub_10025530(a1, a2, a3);
}

//----- (100255F0) --------------------------------------------------------
int __cdecl sub_100255F0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10019A20(v1);
  a1 = v2;
  v3 = sub_1000D290(&a1, 4u, (int)&unk_100A5CA0, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100A5CA4[2 * v3];
}
// 100A5CA4: using guessed type int dword_100A5CA4[];

//----- (10025630) --------------------------------------------------------
int __cdecl sub_10025630(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10019A20(v1);
  a1 = v2;
  v3 = sub_1000D290(&a1, 4u, (int)&unk_100A5CD8, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100A5CDC[2 * v3];
}
// 100A5CDC: using guessed type int dword_100A5CDC[];

//----- (10025670) --------------------------------------------------------
int __cdecl sub_10025670(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10019A20(v1);
  a1 = v2;
  v3 = sub_1000D290(&a1, 4u, (int)&unk_100A5D10, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100A5D14[2 * v3];
}
// 100A5D14: using guessed type int dword_100A5D14[];

//----- (100256B0) --------------------------------------------------------
int __cdecl sub_100256B0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10019A20(v1);
  a1 = v2;
  v3 = sub_1000D290(&a1, 4u, (int)&unk_100A5D48, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100A5D4C[2 * v3];
}
// 100A5D4C: using guessed type int dword_100A5D4C[];

//----- (100256F0) --------------------------------------------------------
int __cdecl sub_100256F0(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // eax@2
  int v6; // eax@8

  result = 0;
  if ( a1 )
  {
    v5 = sub_10025630(a4);
    result = sub_100249E0(v5, a1, 104);
  }
  if ( a2 && !result )
    result = sub_100249E0(3532, a2, 2);
  if ( a3 )
  {
    if ( !result )
    {
      v6 = sub_100255F0(a4);
      result = sub_100249E0(v6, a3, 6);
    }
  }
  return result;
}

//----- (10025760) --------------------------------------------------------
int __cdecl sub_10025760(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  int v5; // eax@3
  int v6; // eax@6
  int v7; // eax@7

  result = 0;
  if ( a1 )
  {
    v4 = sub_100256B0(a3);
    result = sub_100249E0(v4, a1, 64);
    if ( result == -7 )
    {
      sub_100248F0(100);
      v5 = sub_100256B0(a3);
      result = sub_100249E0(v5, a1, 64);
    }
  }
  if ( a2 && !result )
  {
    v6 = sub_10025670(a3);
    result = sub_100249E0(v6, a2, 8);
    if ( result == -7 )
    {
      sub_100248F0(100);
      v7 = sub_10025670(a3);
      result = sub_100249E0(v7, a2, 8);
    }
  }
  return result;
}

//----- (10025830) --------------------------------------------------------
void __cdecl sub_10025830(__int16 a1, _BYTE *a2)
{
  void *v2; // ecx@0
  void *v3; // ecx@2

  if ( a1 == 29 && sub_10009F70(v2) && sub_10009FB0(v3) != 1 )
    *a2 = 0;
}

//----- (10025860) --------------------------------------------------------
unsigned int __cdecl sub_10025860(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6)
{
  size_t v6; // ebp@1
  int *v7; // esi@1
  size_t v8; // ebx@1
  int v9; // edx@1
  unsigned int v10; // edi@1
  int v11; // ebx@2
  int v12; // edx@3
  int *v13; // ebp@3
  int v14; // eax@3
  int v15; // eax@3
  unsigned int result; // eax@4
  void **v17; // [sp+10h] [bp-Ch]@1
  void **v18; // [sp+20h] [bp+4h]@1

  v6 = 8 * a5;
  v7 = &dword_101536D0[a1];
  v8 = 32 * (a3 / (1 << a4));
  v9 = a2 - v8 - v6;
  *v7 = v9 + a3 - 52;
  v17 = (void **)&dword_10153688[a1];
  dword_10153688[a1] = a3 + v9;
  dword_10153648[a1] = a3 + a2 - v8;
  v18 = (void **)&dword_10153648[a1];
  memset((void *)(v9 + a3 - 52), 0, 0x34u);
  memset(*v17, 0, v6);
  memset(*v18, 0, v8);
  *(_DWORD *)(*v7 + 24) = 1 << a4;
  *(_DWORD *)(*v7 + 28) = ~(*(_DWORD *)(*v7 + 24) - 1);
  *(_BYTE *)(*v7 + 32) = a4;
  *(_DWORD *)(*v7 + 12) = a2;
  *(_DWORD *)(*v7 + 16) = a3;
  *(_DWORD *)(*v7 + 8) = a3 / (1 << a4) - (v8 + v6 + 52) / (1 << a4) - 1;
  *(_DWORD *)(*v7 + 4) = a6;
  *(_WORD *)(*v7 + 20) = a5;
  *(_DWORD *)*v7 = -1;
  *(_DWORD *)(*v7 + 36) = *v7 + 36;
  *(_DWORD *)(*v7 + 40) = *v7 + 36;
  *(_DWORD *)(*v7 + 44) = *v7 + 44;
  *(_DWORD *)(*v7 + 48) = *v7 + 44;
  v10 = 0;
  if ( *(_DWORD *)(*v7 + 8) )
  {
    v11 = 0;
    do
    {
      v12 = *v7;
      v13 = *(int **)(*v7 + 40);
      v14 = (int)*v18 + v11;
      *(_DWORD *)(v12 + 40) = v14;
      *(_DWORD *)v14 = v12 + 36;
      *(_DWORD *)(v14 + 4) = v13;
      *v13 = v14;
      v15 = a2 + v10++ * *(_DWORD *)(*v7 + 24);
      *(_DWORD *)((char *)*v18 + v11 + 28) = v15;
      v11 += 32;
    }
    while ( v10 < *(_DWORD *)(*v7 + 8) );
  }
  result = 0;
  if ( *(_WORD *)(*v7 + 20) )
  {
    do
    {
      *((_DWORD *)*v17 + 2 * result) = (char *)*v17 + 8 * result;
      *((_DWORD *)*v17 + 2 * result + 1) = (char *)*v17 + 8 * result;
      ++result;
    }
    while ( result < *(_WORD *)(*v7 + 20) );
  }
  return result;
}
// 10153688: using guessed type int dword_10153688[];
// 101536D0: using guessed type int dword_101536D0[];

//----- (10025A10) --------------------------------------------------------
int __usercall sub_10025A10@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int *v2; // ecx@1
  int result; // eax@2
  int v4; // eax@3
  int v5; // ecx@3
  _DWORD *v6; // edx@3
  int v7; // ecx@3
  _DWORD *v8; // edx@3
  int v9; // ecx@3
  int v10; // edx@3

  v1 = dword_101536D0[a1];
  v2 = (int *)(v1 + 36);
  if ( (int *)*v2 == v2 )
  {
    v4 = *(_DWORD *)(v1 + 44);
    v5 = *(_DWORD *)(v4 - 8);
    v6 = *(_DWORD **)(v4 - 4);
    result = v4 - 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v7 = *(_DWORD *)(result + 8);
    v8 = *(_DWORD **)(result + 12);
    *(_DWORD *)(v7 + 4) = v8;
    *v8 = v7;
    v9 = dword_101536D0[a1];
    v10 = *(_DWORD *)(v9 + 36);
    v9 += 36;
    *(_DWORD *)(v10 + 4) = result;
    *(_DWORD *)result = v10;
    *(_DWORD *)(result + 4) = v9;
    *(_DWORD *)v9 = result;
  }
  else
  {
    result = *v2;
  }
  return result;
}
// 101536D0: using guessed type int dword_101536D0[];

//----- (10025AC0) --------------------------------------------------------
int __cdecl sub_10025AC0(int a1, unsigned __int64 a2)
{
  int v2; // edi@1
  int *v3; // ebx@1
  signed int v4; // eax@1
  _DWORD *v5; // ecx@2
  int v6; // eax@2
  int *v7; // eax@2
  int v8; // ecx@2
  _DWORD *v9; // edx@2
  int v10; // eax@2
  int v11; // ecx@2
  int result; // eax@2

  v2 = sub_10025A10(a1);
  v3 = &dword_101536D0[a1];
  v4 = sub_10025430(
         *(_DWORD *)dword_101536D0[a1] & 0xFFFFFFFC,
         *(void **)(v2 + 28),
         *(_DWORD *)(dword_101536D0[a1] + 24),
         a2,
         SHIDWORD(a2));
  if ( v4 <= 0 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD **)(v2 + 4);
    *(_WORD *)(v2 + 24) = v4;
    v6 = *(_DWORD *)v2;
    *(_QWORD *)(v2 + 16) = a2;
    *(_DWORD *)(v6 + 4) = v5;
    *v5 = v6;
    v7 = (int *)(dword_10153688[a1] + 8 * ((unsigned int)(a2 >> *(_BYTE *)(*v3 + 32)) % *(_WORD *)(*v3 + 20)));
    v8 = *v7;
    *(_DWORD *)(v8 + 4) = v2;
    *(_DWORD *)(v2 + 4) = v7;
    *(_DWORD *)v2 = v8;
    *v7 = v2;
    v9 = *(_DWORD **)(*v3 + 48);
    v10 = *v3 + 44;
    v11 = v2 + 8;
    *(_DWORD *)(v10 + 4) = v2 + 8;
    *(_DWORD *)v11 = v10;
    result = v2;
    *(_DWORD *)(v11 + 4) = v9;
    *v9 = v2 + 8;
  }
  return result;
}
// 10153688: using guessed type int dword_10153688[];
// 101536D0: using guessed type int dword_101536D0[];

//----- (10025B70) --------------------------------------------------------
int __usercall sub_10025B70@<eax>(int a1@<ebx>, unsigned __int64 a2)
{
  int *v2; // edi@1
  int *v3; // ecx@1
  int result; // eax@1
  int v5; // edx@5
  _DWORD *v6; // esi@5
  int v7; // ecx@5
  _DWORD *v8; // esi@5
  int v9; // edx@5

  v2 = &dword_101536D0[a1];
  v3 = (int *)(dword_10153688[a1]
             + 8 * ((unsigned int)(a2 >> *(_BYTE *)(dword_101536D0[a1] + 32)) % *(_WORD *)(dword_101536D0[a1] + 20)));
  result = *v3;
  if ( (int *)*v3 == v3 )
  {
LABEL_4:
    result = sub_10025AC0(a1, a2);
  }
  else
  {
    while ( *(_QWORD *)(result + 16) != a2 )
    {
      result = *(_DWORD *)result;
      if ( (int *)result == v3 )
        goto LABEL_4;
    }
    v5 = *(_DWORD *)(result + 8);
    v6 = *(_DWORD **)(result + 12);
    v7 = result + 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v8 = *(_DWORD **)(*v2 + 48);
    v9 = *v2 + 44;
    *(_DWORD *)(v9 + 4) = result + 8;
    *(_DWORD *)(v7 + 4) = v8;
    *(_DWORD *)v7 = v9;
    *v8 = result + 8;
  }
  return result;
}
// 10153688: using guessed type int dword_10153688[];
// 101536D0: using guessed type int dword_101536D0[];

//----- (10025C00) --------------------------------------------------------
unsigned int __cdecl sub_10025C00(int a1, void *a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // edx@2
  unsigned int result; // eax@4
  int v10; // eax@7
  int v11; // esi@10
  int v12; // eax@10
  int v13; // ecx@11
  unsigned int v14; // eax@11
  const void *v15; // ecx@11
  size_t v16; // esi@12
  int v17; // ecx@13
  int v18; // et0@17

  v5 = a3;
  v6 = 0;
  v7 = a4;
  if ( !dword_101536C8 )
    goto LABEL_24;
  while ( 1 )
  {
    v8 = dword_101536D0[v6];
    if ( *(_DWORD *)v8 == a1 )
      break;
    if ( ++v6 >= (unsigned int)dword_101536C8 )
      return -1;
  }
  if ( v6 != -1 )
  {
    v10 = *(_DWORD *)(v8 + 4);
    if ( v10 != 138 )
      sub_10024870(v10, -1);
    if ( a3 )
    {
      while ( 1 )
      {
        v11 = v7 & ~*(_DWORD *)(dword_101536D0[v6] + 28);
        v12 = sub_10025B70(v6, (unsigned int)v7 & *(_DWORD *)(dword_101536D0[v6] + 28));
        if ( !v12 )
          break;
        v13 = *(_DWORD *)(v12 + 28);
        v14 = *(_WORD *)(v12 + 24) - v11;
        v15 = (const void *)(v11 + v13);
        if ( v5 <= v14 )
        {
          v16 = v5;
        }
        else
        {
          v16 = v14;
          if ( !v14 )
            goto LABEL_13;
        }
        memcpy(a2, v15, v16);
        v5 -= v16;
        v18 = (v16 + __PAIR__((unsigned int)a5, v7)) >> 32;
        v7 += v16;
        a5 = v18;
        a2 = (char *)a2 + v16;
        if ( !v5 )
          goto LABEL_13;
      }
      if ( *(_DWORD *)(dword_101536D0[v6] + 4) != 138 )
        sub_10024850(*(_DWORD *)(dword_101536D0[v6] + 4));
      result = -1;
    }
    else
    {
LABEL_13:
      v17 = dword_101536D0[v6];
      if ( *(_DWORD *)(v17 + 4) != 138 )
        sub_10024850(*(_DWORD *)(v17 + 4));
      result = a3 - v5;
    }
  }
  else
  {
LABEL_24:
    result = -1;
  }
  return result;
}
// 101536C8: using guessed type int dword_101536C8;
// 101536D0: using guessed type int dword_101536D0[];

//----- (10027BD2) --------------------------------------------------------
int __cdecl sub_10027BD2(int a1, int a2, char a3)
{
  return vscan_fn(sub_1002E4DA, a2, 0, &a3);
}
// 10027B6A: using guessed type int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1002A35B) --------------------------------------------------------
signed int __cdecl sub_1002A35B(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_10153A70 )
  {
    *a1 = dword_10153A70;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1002E390: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10153A70: using guessed type int dword_10153A70;

//----- (1002A392) --------------------------------------------------------
signed int __cdecl sub_1002A392(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_10153A70 )
  {
    *a1 = dword_10153A7C;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1002E390: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10153A70: using guessed type int dword_10153A70;
// 10153A7C: using guessed type int dword_10153A7C;

//----- (1002AFD8) --------------------------------------------------------
void sub_1002AFD8()
{
  void **v0; // esi@1
  void *v1; // edi@2
  unsigned int i; // eax@3

  v0 = (void **)dword_10177200;
  do
  {
    v1 = *v0;
    if ( *v0 )
    {
      for ( i = (unsigned int)v1 + 2048; (unsigned int)v1 < i; i = (unsigned int)*v0 + 2048 )
      {
        if ( *((_DWORD *)v1 + 2) )
          DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
        v1 = (char *)v1 + 64;
      }
      free(*v0);
      *v0 = 0;
    }
    ++v0;
  }
  while ( (signed int)v0 < (signed int)&dword_10177300 );
}
// 10177200: using guessed type int dword_10177200[];
// 10177300: using guessed type int dword_10177300;

//----- (1002B485) --------------------------------------------------------
int (*sub_1002B485())(void)
{
  int (*result)(void); // eax@1
  int (**v1)(void); // esi@1

  result = (int (*)(void))&unk_100B5CB0;
  v1 = (int (**)(void))&unk_100B5CB0;
  if ( &unk_100B5CB0 < &unk_100B5CB0 )
  {
    do
    {
      result = *v1;
      if ( *v1 )
        result = (int (*)(void))result();
      ++v1;
    }
    while ( v1 < (int (**)(void))&unk_100B5CB0 );
  }
  return result;
}

//----- (1002B4A9) --------------------------------------------------------
void __cdecl sub_1002B4A9()
{
  void (**v0)(void); // esi@1

  v0 = (void (**)(void))&unk_100B5CB8;
  if ( &unk_100B5CB8 < &unk_100B5CB8 )
  {
    do
    {
      if ( *v0 )
        (*v0)();
      ++v0;
    }
    while ( v0 < (void (**)(void))&unk_100B5CB8 );
  }
}

//----- (1002D6F5) --------------------------------------------------------
int __cdecl sub_1002D6F5(int a1, FILE *a2)
{
  FILE *v2; // esi@1
  int v3; // eax@1
  unsigned int v5; // eax@9
  int v6; // eax@15
  char *v7; // edi@15
  signed __int32 v8; // edi@15
  _BYTE *v9; // eax@20
  __int64 v10; // rax@23
  _WORD *v11; // [sp+4h] [bp-4h]@9

  v2 = a2;
  a2 = (FILE *)_fileno(a2);
  v3 = v2->_flag;
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    v2->_flag |= 0x20u;
    return -1;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v3 & 1 )
  {
    v2->_cnt = 0;
    if ( !(v3 & 0x10) )
    {
      v2->_flag = v3 | 0x20;
      return -1;
    }
    v2->_ptr = v2->_base;
    v2->_flag = v3 & 0xFFFFFFFE;
  }
  v5 = v2->_flag & 0xFFFFFFEF | 2;
  v2->_flag = v5;
  v2->_cnt = 0;
  v11 = 0;
  if ( !(v5 & 0x10C)
    && ((void **)v2 != sub_10033D18() + 8 && (void **)v2 != sub_10033D18() + 16 || !sub_10033CBA((signed int)a2)) )
  {
    _getbuf(v2);
  }
  if ( v2->_flag & 0x108 )
  {
    v6 = (int)v2->_base;
    v7 = v2->_ptr;
    v2->_ptr = (char *)(v6 + 1);
    v8 = (signed __int32)&v7[-v6];
    v2->_cnt = v2->_bufsiz - 1;
    if ( v8 <= 0 )
    {
      if ( a2 == (FILE *)-1 || a2 == (FILE *)-2 )
        v9 = &unk_100B7310;
      else
        v9 = (_BYTE *)(dword_10177200[(signed int)a2 >> 5] + (((unsigned __int8)a2 & 0x1F) << 6));
      if ( v9[4] & 0x20 )
      {
        v10 = _lseeki64((int)a2, 0i64, 2);
        if ( (HIDWORD(v10) & (unsigned int)v10) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v11 = sub_10033B9A((int)a2, v6, v8);
    }
    *v2->_base = a1;
  }
  else
  {
    v8 = 1;
    v11 = sub_10033B9A((int)a2, (int)&a1, 1u);
  }
  if ( v11 != (_WORD *)v8 )
  {
LABEL_27:
    v2->_flag |= 0x20u;
    return -1;
  }
  return (unsigned __int8)a1;
}
// 10033C76: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 10177200: using guessed type int dword_10177200[];

//----- (1002E28A) --------------------------------------------------------
int __cdecl sub_1002E28A(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10153C1C = a1;
  return result;
}
// 10153C1C: using guessed type int dword_10153C1C;

//----- (1002E4DA) --------------------------------------------------------
int __cdecl sub_1002E4DA(FILE *a1, int a2, struct localeinfo_struct *a3, int a4)
{
  unsigned __int8 *v4; // edi@1
  int result; // eax@2
  int *v6; // edi@7
  _BYTE *v7; // eax@7
  int *v8; // edi@12
  _BYTE *v9; // eax@12
  unsigned __int8 v10; // al@16
  unsigned __int8 *v11; // edi@17
  int v12; // eax@19
  _WORD *v13; // esi@24
  int v14; // ebx@25
  int v15; // eax@25
  int v16; // ST10_4@25
  int v17; // ecx@25
  int v18; // eax@35
  unsigned __int8 v19; // al@59
  signed int v20; // ebx@62
  int v21; // eax@65
  int v22; // ecx@69
  int v23; // edi@79
  signed int v24; // ebx@82
  int v25; // ebx@84
  int i; // eax@90
  int v27; // eax@91
  int v28; // ecx@92
  int v29; // eax@96
  int j; // eax@98
  int v31; // eax@99
  int v32; // ecx@100
  int v33; // eax@106
  int v34; // ecx@107
  int v35; // ecx@108
  int v36; // eax@112
  int k; // eax@115
  int v38; // eax@116
  int v39; // ecx@117
  void *v40; // ST0C_4@124
  _WORD *v41; // ST08_4@124
  int v42; // ST04_4@124
  void (__cdecl *v43)(int, _WORD *, void *, struct localeinfo_struct *); // eax@124
  _WORD *v44; // edi@129
  int v45; // ST10_4@130
  int v46; // eax@132
  signed int v47; // eax@133
  _BYTE *v48; // edi@156
  unsigned __int8 *v49; // esi@156
  unsigned __int8 v50; // dl@159
  unsigned __int8 v51; // al@165
  unsigned int v52; // edi@168
  int v53; // edx@168
  unsigned int v54; // ecx@172
  unsigned int v55; // eax@172
  unsigned __int8 v56; // al@173
  int v57; // eax@181
  int v58; // ecx@181
  int v59; // eax@219
  int v60; // ST10_4@219
  int v61; // ecx@219
  unsigned int v62; // esi@222
  int v63; // eax@225
  int v64; // ST10_4@225
  int v65; // eax@238
  int v66; // ST10_4@238
  int v67; // ecx@238
  int v68; // edi@241
  int v69; // eax@244
  int v70; // ST10_4@244
  int v71; // ebx@265
  int v72; // eax@265
  int v73; // eax@267
  int v74; // ecx@267
  bool v75; // zf@275
  int v76; // [sp-4h] [bp-80h]@18
  int v77; // [sp-4h] [bp-80h]@94
  int v78; // [sp-4h] [bp-80h]@143
  int v79; // [sp-4h] [bp-80h]@266
  _WORD **v80; // [sp+Ch] [bp-70h]@0
  struct localeinfo_struct Locale; // [sp+10h] [bp-6Ch]@16
  int v82; // [sp+18h] [bp-64h]@288
  char v83; // [sp+1Ch] [bp-60h]@287
  wchar_t DstCh[2]; // [sp+20h] [bp-5Ch]@1
  _WORD **v85; // [sp+24h] [bp-58h]@1
  int v86; // [sp+28h] [bp-54h]@24
  char SrcCh; // [sp+2Ch] [bp-50h]@143
  char v88; // [sp+2Dh] [bp-4Fh]@144
  int v89; // [sp+30h] [bp-4Ch]@1
  int v90; // [sp+34h] [bp-48h]@24
  int v91; // [sp+38h] [bp-44h]@1
  unsigned __int8 v92; // [sp+3Fh] [bp-3Dh]@24
  int v93; // [sp+40h] [bp-3Ch]@16
  _WORD *v94; // [sp+44h] [bp-38h]@58
  unsigned __int64 v95; // [sp+48h] [bp-34h]@36
  int v96; // [sp+50h] [bp-2Ch]@24
  unsigned __int8 *v97; // [sp+54h] [bp-28h]@1
  void *v98; // [sp+58h] [bp-24h]@1
  int v99; // [sp+5Ch] [bp-20h]@62
  int v100; // [sp+60h] [bp-1Ch]@24
  char v101; // [sp+64h] [bp-18h]@24
  char v102; // [sp+65h] [bp-17h]@24
  char v103; // [sp+66h] [bp-16h]@24
  char v104; // [sp+67h] [bp-15h]@16
  FILE *v105; // [sp+68h] [bp-14h]@1
  char v106; // [sp+6Eh] [bp-Eh]@24
  char v107; // [sp+6Fh] [bp-Dh]@24
  int v108; // [sp+70h] [bp-Ch]@24
  char v109; // [sp+77h] [bp-5h]@24
  int v110; // [sp+78h] [bp-4h]@1
  char v111; // [sp+7Fh] [bp+3h]@24
  int v112; // [sp+80h] [bp+4h]@16
  char v113; // [sp+84h] [bp+8h]@1
  char v114[11]; // [sp+1E4h] [bp+168h]@140
  char v115; // [sp+1EFh] [bp+173h]@159

  v4 = (unsigned __int8 *)a2;
  v85 = (_WORD **)a4;
  v105 = a1;
  v97 = (unsigned __int8 *)a2;
  v98 = &v113;
  v89 = 350;
  v91 = 0;
  *(_DWORD *)DstCh = 0;
  v110 = 0;
  if ( !a2 || !a1 )
    goto LABEL_294;
  if ( a1->_flag & 0x40 )
    goto LABEL_16;
  if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
  {
    v7 = &unk_100B7310;
  }
  else
  {
    v6 = &dword_10177200[_fileno(a1) >> 5];
    v7 = (_BYTE *)(*v6 + ((_fileno(a1) & 0x1F) << 6));
  }
  if ( v7[36] & 0x7F
    || (_fileno(a1) == -1 || _fileno(a1) == -2 ? (v9 = &unk_100B7310) : (v8 = &dword_10177200[_fileno(a1) >> 5],
                                                                         v9 = (_BYTE *)(*v8 + ((_fileno(a1) & 0x1F) << 6))),
        v9[36] & 0x80) )
  {
LABEL_294:
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v4 = v97;
LABEL_16:
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a3);
  v10 = *v4;
  v75 = *v4 == 0;
  v104 = 0;
  v112 = 0;
  v93 = 0;
  if ( v75 )
    goto LABEL_289;
  v11 = v97;
  while ( 2 )
  {
    if ( isspace(v10) )
    {
      --v112;
      v12 = _whiteout(v105);
      if ( v12 != -1 )
        sub_10034235(v12, v105);
      do
        ++v11;
      while ( isspace(*v11) );
      goto LABEL_273;
    }
    if ( *v11 != 37 )
    {
      ++v112;
      v71 = _inc(v76, v105);
      v72 = *v11++;
      v110 = v71;
      v97 = v11;
      if ( v72 == v71 )
      {
        if ( !isleadbyte((unsigned __int8)v71) )
          goto LABEL_269;
        ++v112;
        v73 = _inc(v79, v105);
        v74 = *v11++;
        v97 = v11;
        if ( v74 == v73 )
        {
          --v112;
          goto LABEL_269;
        }
        if ( v73 != -1 )
          sub_10034235(v73, v105);
      }
      v75 = v71 == -1;
      goto LABEL_279;
    }
    v86 = 0;
    v92 = 0;
    v100 = 0;
    v96 = 0;
    v108 = 0;
    v101 = 0;
    v102 = 0;
    v107 = 0;
    v111 = 0;
    v103 = 0;
    v109 = 0;
    v106 = 1;
    v90 = 0;
    v13 = 0;
    do
    {
      v14 = *++v11;
      v15 = isdigit(v14);
      v17 = v16;
      if ( v15 )
      {
        ++v96;
        v108 = 10 * v108 + v14 - 48;
        continue;
      }
      if ( v14 > 78 )
      {
        if ( v14 == 104 )
        {
          --v106;
          --v109;
        }
        else
        {
          if ( v14 == 108 )
          {
            v18 = (int)(v11 + 1);
            if ( v11[1] == 108 )
              goto LABEL_36;
            ++v106;
          }
          else if ( v14 != 119 )
          {
            goto LABEL_50;
          }
          ++v109;
        }
      }
      else
      {
        if ( v14 == 78 )
          continue;
        if ( v14 == 42 )
        {
          ++v107;
          continue;
        }
        if ( v14 == 70 )
          continue;
        if ( v14 != 73 )
        {
          if ( v14 == 76 )
          {
            ++v106;
            continue;
          }
LABEL_50:
          ++v111;
          continue;
        }
        LOBYTE(v17) = v11[1];
        if ( (_BYTE)v17 == 54 )
        {
          v18 = (int)(v11 + 2);
          if ( v11[2] == 52 )
          {
LABEL_36:
            ++v90;
            v11 = (unsigned __int8 *)v18;
            v95 = 0i64;
            continue;
          }
        }
        if ( (_BYTE)v17 == 51 && v11[2] == 50 )
        {
          v11 += 2;
          continue;
        }
        if ( (_BYTE)v17 != 100 && (_BYTE)v17 != 105 && (_BYTE)v17 != 111 && (_BYTE)v17 != 120 && (_BYTE)v17 != 88 )
          goto LABEL_50;
      }
    }
    while ( !v111 );
    v97 = v11;
    if ( !v107 )
    {
      v13 = *v85;
      v80 = v85;
      ++v85;
    }
    v94 = v13;
    v111 = 0;
    if ( !v109 )
    {
      v19 = *v11;
      if ( *v11 == 83 || (v109 = -1, v19 == 67) )
        v109 = 1;
    }
    v99 = *v11 | 0x20;
    v20 = v99;
    if ( v99 != 110 )
    {
      if ( v99 == 99 || v99 == 123 )
      {
        ++v112;
        v21 = _inc(v17, v105);
      }
      else
      {
        v21 = _whiteout(v105);
      }
      v110 = v21;
      if ( v21 == -1 )
        goto LABEL_281;
      v13 = v94;
      v11 = v97;
    }
    v22 = v96;
    if ( v96 && !v108 )
      goto LABEL_275;
    if ( v20 > 111 )
    {
      if ( v20 == 112 )
      {
        v106 = 1;
      }
      else
      {
        if ( v20 == 115 )
        {
LABEL_127:
          if ( v109 > 0 )
            v103 = 1;
          goto LABEL_129;
        }
        if ( v20 != 117 )
        {
          if ( v20 == 120 )
            goto LABEL_82;
          if ( v20 != 123 )
            goto LABEL_151;
          if ( v109 > 0 )
            v103 = 1;
          v48 = v11 + 1;
          v49 = v48;
          if ( *v48 == 94 )
          {
            v49 = v48 + 1;
            v101 = -1;
          }
          memset(v114, 0, 0x20u);
          if ( *v49 == 93 )
          {
            v50 = 93;
            ++v49;
            v115 = 32;
          }
          else
          {
            v50 = v92;
          }
          while ( 1 )
          {
            v56 = *v49;
            if ( *v49 == 93 )
              break;
            ++v49;
            if ( v56 == 45 && v50 && (LOBYTE(v22) = *v49, *v49 != 93) )
            {
              ++v49;
              if ( v50 >= (unsigned __int8)v22 )
              {
                v51 = v50;
                v50 = v22;
              }
              else
              {
                v51 = v22;
              }
              if ( v50 <= v51 )
              {
                v52 = v50;
                v53 = (unsigned __int8)(v51 - v50 + 1);
                do
                {
                  v22 = v52 & 7;
                  v114[v52 >> 3] |= 1 << v22;
                  ++v52;
                  --v53;
                }
                while ( v53 );
                v20 = v99;
              }
              v50 = 0;
            }
            else
            {
              v54 = v56;
              v50 = v56;
              v55 = v54;
              v22 = v54 & 7;
              v114[v55 >> 3] |= 1 << v22;
              v20 = v99;
            }
          }
          v97 = v49;
          v13 = v94;
LABEL_129:
          --v112;
          v44 = v13;
          if ( v110 != -1 )
          {
            sub_10034235(v110, v105);
            v22 = v45;
          }
          while ( 1 )
          {
            if ( v96 )
            {
              v46 = v108--;
              if ( !v46 )
                goto LABEL_200;
            }
            ++v112;
            v47 = _inc(v22, v105);
            v110 = v47;
            if ( v47 == -1 )
              goto LABEL_198;
            if ( v20 != 99 )
            {
              if ( v20 != 115 )
                goto LABEL_295;
              if ( v47 >= 9 && v47 <= 13 )
              {
LABEL_198:
                --v112;
                if ( v47 != -1 )
                  sub_10034235(v47, v105);
LABEL_200:
                if ( v44 != v13 )
                {
                  if ( !v107 )
                  {
                    ++v93;
                    if ( v20 != 99 )
                    {
                      if ( v103 )
                        *v94 = 0;
                      else
                        *(_BYTE *)v94 = 0;
                    }
                  }
                  goto LABEL_264;
                }
                goto LABEL_281;
              }
              if ( v47 == 32 )
              {
LABEL_295:
                if ( v20 != 123 )
                  goto LABEL_198;
                v22 = v101 ^ v114[v47 >> 3];
                v20 = v99;
                if ( !((1 << (v47 & 7)) & v22) )
                  goto LABEL_198;
              }
            }
            if ( v107 )
            {
              v44 = (_WORD *)((char *)v44 + 1);
            }
            else
            {
              if ( v103 )
              {
                SrcCh = v47;
                if ( isleadbyte((unsigned __int8)v47) )
                {
                  ++v112;
                  v88 = _inc(v78, v105);
                }
                *(_DWORD *)DstCh = 63;
                _mbtowc_l(DstCh, &SrcCh, Locale.locinfo->mb_cur_max, &Locale);
                *v13 = DstCh[0];
                ++v13;
              }
              else
              {
                *(_BYTE *)v13 = v47;
                v13 = (_WORD *)((char *)v13 + 1);
              }
              v94 = v13;
            }
          }
        }
      }
LABEL_207:
      v24 = v110;
      if ( v110 == 45 )
      {
        v102 = 1;
      }
      else if ( v110 != 43 )
      {
        goto LABEL_215;
      }
      if ( !--v108 && v96 )
      {
        v111 = 1;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v96, v105);
      goto LABEL_214;
    }
    if ( v20 == 111 )
      goto LABEL_207;
    if ( v20 == 99 )
    {
      if ( !v96 )
      {
        ++v108;
        v96 = 1;
      }
      goto LABEL_127;
    }
    if ( v20 == 100 )
      goto LABEL_207;
    if ( v20 <= 100 )
      goto LABEL_151;
    if ( v20 <= 103 )
    {
      v25 = 0;
      if ( v110 == 45 )
      {
        *(_BYTE *)v98 = 45;
        v25 = 1;
        goto LABEL_87;
      }
      if ( v110 == 43 )
      {
LABEL_87:
        --v108;
        ++v112;
        v110 = _inc(v22, v105);
      }
      if ( !v96 )
        v108 = -1;
      for ( i = (unsigned __int8)v110; isdigit(i); i = (unsigned __int8)v110 )
      {
        v27 = v108--;
        if ( !v27 )
          break;
        ++v100;
        *((_BYTE *)v98 + v25++) = v110;
        if ( !__check_float_string(v25, &v113, (int)&v91) )
          goto LABEL_281;
        ++v112;
        v110 = _inc(v28, v105);
      }
      v101 = **(_BYTE **)Locale.locinfo->lconv;
      if ( v101 == (_BYTE)v110 )
      {
        v29 = v108--;
        if ( v29 )
        {
          ++v112;
          v110 = _inc(v77, v105);
          *((_BYTE *)v98 + v25++) = v101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          for ( j = (unsigned __int8)v110; isdigit(j); j = (unsigned __int8)v110 )
          {
            v31 = v108--;
            if ( !v31 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v32, v105);
          }
        }
      }
      if ( v100 && (v110 == 101 || v110 == 69) )
      {
        v33 = v108--;
        if ( v33 )
        {
          *((_BYTE *)v98 + v25++) = 101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          ++v112;
          v110 = _inc(v34, v105);
          if ( v110 == 45 )
          {
            *((_BYTE *)v98 + v25++) = 45;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
LABEL_112:
            v36 = v108--;
            if ( v36 )
            {
              ++v112;
              v110 = _inc(v35, v105);
            }
            else
            {
              v108 = 0;
            }
          }
          else if ( v110 == 43 )
          {
            goto LABEL_112;
          }
          for ( k = (unsigned __int8)v110; isdigit(k); k = (unsigned __int8)v110 )
          {
            v38 = v108--;
            if ( !v38 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v39, v105);
          }
        }
      }
      --v112;
      if ( v110 != -1 )
        sub_10034235(v110, v105);
      if ( v100 )
      {
        if ( !v107 )
        {
          ++v93;
          v40 = v98;
          v41 = v94;
          *((_BYTE *)v98 + v25) = 0;
          v42 = v106 - 1;
          v43 = (void (__cdecl *)(int, _WORD *, void *, struct localeinfo_struct *))_decode_pointer(off_100B7264);
          v43(v42, v41, v40, &Locale);
        }
        goto LABEL_264;
      }
      goto LABEL_281;
    }
    if ( v20 != 105 )
    {
      if ( v20 == 110 )
      {
        v23 = v112;
        if ( !v107 )
        {
LABEL_259:
          if ( v90 )
          {
            *(_QWORD *)v13 = v95;
          }
          else if ( v106 )
          {
            *(_DWORD *)v13 = v23;
          }
          else
          {
            *v13 = v23;
          }
        }
        goto LABEL_264;
      }
LABEL_151:
      if ( *v11 == v110 )
      {
        --v104;
        if ( !v107 )
          v85 = v80;
        goto LABEL_264;
      }
LABEL_275:
      v75 = v110 == -1;
LABEL_279:
      if ( !v75 )
        sub_10034235(v110, v105);
      goto LABEL_281;
    }
    v99 = 100;
LABEL_82:
    v24 = v110;
    if ( v110 == 45 )
    {
      v102 = 1;
      goto LABEL_176;
    }
    if ( v110 == 43 )
    {
LABEL_176:
      if ( --v108 || !v96 )
      {
        ++v112;
        v24 = _inc(v96, v105);
        v110 = v24;
      }
      else
      {
        v111 = 1;
      }
    }
    if ( v24 == 48 )
    {
      ++v112;
      v57 = _inc(v22, v105);
      v24 = v57;
      v110 = v57;
      if ( (_BYTE)v57 != 120 && (_BYTE)v57 != 88 )
      {
        v100 = 1;
        if ( v99 != 120 )
        {
          if ( v96 )
          {
            if ( !--v108 )
              ++v111;
          }
          v99 = 111;
          goto LABEL_215;
        }
        --v112;
        if ( v57 != -1 )
          sub_10034235(v57, v105);
        v24 = 48;
LABEL_214:
        v110 = v24;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v58, v105);
      v110 = v24;
      if ( v96 )
      {
        v108 -= 2;
        if ( v108 < 1 )
          ++v111;
      }
      v99 = 120;
    }
LABEL_215:
    if ( !v90 )
    {
      v23 = v86;
      if ( !v111 )
      {
        while ( 1 )
        {
          if ( v99 == 120 || v99 == 112 )
          {
            if ( !isxdigit((unsigned __int8)v24) )
            {
LABEL_250:
              --v112;
              if ( v24 != -1 )
                sub_10034235(v24, v105);
              break;
            }
            v68 = 16 * v23;
            v69 = isdigit((unsigned __int8)v24);
            v67 = v70;
            v24 = (char)v24;
            if ( !v69 )
              v24 = (v24 & 0xFFFFFFDF) - 7;
            v110 = v24;
          }
          else
          {
            v65 = isdigit((unsigned __int8)v24);
            v67 = v66;
            if ( !v65 )
              goto LABEL_250;
            if ( v99 == 111 )
            {
              if ( v24 >= 56 )
                goto LABEL_250;
              v68 = 8 * v23;
            }
            else
            {
              v68 = 10 * v23;
            }
          }
          ++v100;
          v23 = v68 + v24 - 48;
          if ( v96 )
          {
            if ( !--v108 )
              break;
          }
          ++v112;
          v24 = _inc(v67, v105);
          v110 = v24;
        }
      }
      if ( v102 )
        v23 = -v23;
      goto LABEL_254;
    }
    if ( v111 )
      goto LABEL_233;
    while ( 2 )
    {
      if ( v99 != 120 && v99 != 112 )
      {
        v59 = isdigit((unsigned __int8)v24);
        v61 = v60;
        if ( !v59 )
          break;
        if ( v99 == 111 )
        {
          if ( v24 >= 56 )
            break;
          v62 = 8 * v95;
          HIDWORD(v95) = v95 >> 29;
        }
        else
        {
          HIDWORD(v95) = 10 * v95 >> 32;
          v62 = 10 * v95;
        }
        goto LABEL_228;
      }
      if ( isxdigit((unsigned __int8)v24) )
      {
        v62 = 16 * v95;
        HIDWORD(v95) = v95 >> 28;
        v63 = isdigit((unsigned __int8)v24);
        v61 = v64;
        v24 = (char)v24;
        if ( !v63 )
          v24 = (v24 & 0xFFFFFFDF) - 7;
        v110 = v24;
LABEL_228:
        ++v100;
        v95 = v24 - 48 + __PAIR__(HIDWORD(v95), v62);
        if ( v96 )
        {
          if ( !--v108 )
            goto LABEL_233;
        }
        ++v112;
        v24 = _inc(v61, v105);
        v110 = v24;
        continue;
      }
      break;
    }
    --v112;
    if ( v24 != -1 )
      sub_10034235(v24, v105);
LABEL_233:
    v23 = v86;
    if ( v102 )
      v95 = -(signed __int64)v95;
LABEL_254:
    if ( v99 == 70 )
      v100 = 0;
    if ( !v100 )
      goto LABEL_281;
    if ( !v107 )
    {
      ++v93;
      v13 = v94;
      goto LABEL_259;
    }
LABEL_264:
    ++v104;
    v11 = v97++ + 1;
LABEL_269:
    if ( v110 != -1 )
    {
LABEL_273:
      v10 = *v11;
      if ( !*v11 )
        goto LABEL_281;
      continue;
    }
    break;
  }
  if ( *v11 == 37 && v97[1] == 110 )
  {
    v11 = v97;
    goto LABEL_273;
  }
LABEL_281:
  if ( v91 == 1 )
    free(v98);
  if ( v110 == -1 )
  {
    result = v93;
    if ( !v93 && v104 == (_BYTE)v93 )
      result = -1;
    if ( v83 )
      *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
    return result;
  }
LABEL_289:
  if ( v83 )
    *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
  return v93;
}
// 1002A691: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1002E390: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1002E49F: using guessed type int __fastcall _inc(_DWORD, _DWORD);
// 1002E4B5: using guessed type _DWORD __cdecl _whiteout(_DWORD);
// 100B7264: using guessed type int (*off_100B7264)();
// 10177200: using guessed type int dword_10177200[];
// 1002E4DA: using guessed type char var_24[11];

//----- (1002FB34) --------------------------------------------------------
#error "1002FB39: positive sp value has been found (funcsize=0)"

//----- (1002FB3F) --------------------------------------------------------
#error "1002FB44: positive sp value has been found (funcsize=0)"

//----- (1002FB4A) --------------------------------------------------------
#error "1002FB4F: positive sp value has been found (funcsize=0)"

//----- (1002FB50) --------------------------------------------------------
#error "1002FB55: positive sp value has been found (funcsize=0)"

//----- (1002FB56) --------------------------------------------------------
#error "1002FB5B: positive sp value has been found (funcsize=0)"

//----- (1002FB5C) --------------------------------------------------------
#error "1002FB61: positive sp value has been found (funcsize=0)"

//----- (1002FB62) --------------------------------------------------------
#error "1002FB7D: positive sp value has been found (funcsize=0)"

//----- (1002FB83) --------------------------------------------------------
#error "1002FB98: positive sp value has been found (funcsize=0)"

//----- (1002FB9E) --------------------------------------------------------
#error "1002FBB9: positive sp value has been found (funcsize=0)"

//----- (1002FBBA) --------------------------------------------------------
#error "1002FBC9: positive sp value has been found (funcsize=0)"

//----- (1002FBCA) --------------------------------------------------------
#error "1002FBDD: positive sp value has been found (funcsize=0)"

//----- (1002FBDE) --------------------------------------------------------
#error "1002FBED: positive sp value has been found (funcsize=0)"

//----- (1002FBEE) --------------------------------------------------------
#error "1002FC0D: positive sp value has been found (funcsize=0)"

//----- (1002FC13) --------------------------------------------------------
#error "1002FC2C: positive sp value has been found (funcsize=0)"

//----- (1002FC32) --------------------------------------------------------
#error "1002FC51: positive sp value has been found (funcsize=0)"

//----- (1002FC52) --------------------------------------------------------
#error "1002FC65: positive sp value has been found (funcsize=0)"

//----- (1002FC66) --------------------------------------------------------
#error "1002FC7D: positive sp value has been found (funcsize=0)"

//----- (1002FC7E) --------------------------------------------------------
#error "1002FC91: positive sp value has been found (funcsize=0)"

//----- (1002FC92) --------------------------------------------------------
#error "1002FCB1: positive sp value has been found (funcsize=0)"

//----- (1002FCB7) --------------------------------------------------------
#error "1002FCD0: positive sp value has been found (funcsize=0)"

//----- (1002FCD6) --------------------------------------------------------
#error "1002FCF5: positive sp value has been found (funcsize=0)"

//----- (1002FCF6) --------------------------------------------------------
#error "1002FD09: positive sp value has been found (funcsize=0)"

//----- (1002FD0A) --------------------------------------------------------
#error "1002FD21: positive sp value has been found (funcsize=0)"

//----- (1002FD22) --------------------------------------------------------
#error "1002FD35: positive sp value has been found (funcsize=0)"

//----- (1002FD36) --------------------------------------------------------
#error "1002FD55: positive sp value has been found (funcsize=0)"

//----- (1002FD5B) --------------------------------------------------------
#error "1002FD74: positive sp value has been found (funcsize=0)"

//----- (1002FD7A) --------------------------------------------------------
#error "1002FD99: positive sp value has been found (funcsize=0)"

//----- (1002FD9A) --------------------------------------------------------
#error "1002FDAD: positive sp value has been found (funcsize=0)"

//----- (1002FDAE) --------------------------------------------------------
#error "1002FDC5: positive sp value has been found (funcsize=0)"

//----- (1002FDC6) --------------------------------------------------------
#error "1002FDD9: positive sp value has been found (funcsize=0)"

//----- (1002FDDA) --------------------------------------------------------
#error "1002FDF9: positive sp value has been found (funcsize=0)"

//----- (1002FDFF) --------------------------------------------------------
#error "1002FE18: positive sp value has been found (funcsize=0)"

//----- (1002FE1E) --------------------------------------------------------
#error "1002FE3D: positive sp value has been found (funcsize=0)"

//----- (1002FE3E) --------------------------------------------------------
#error "1002FE51: positive sp value has been found (funcsize=0)"

//----- (1002FE52) --------------------------------------------------------
#error "1002FE69: positive sp value has been found (funcsize=0)"

//----- (1002FE6A) --------------------------------------------------------
#error "1002FE7D: positive sp value has been found (funcsize=0)"

//----- (1002FE7E) --------------------------------------------------------
#error "1002FE9D: positive sp value has been found (funcsize=0)"

//----- (1002FEA3) --------------------------------------------------------
#error "1002FEBC: positive sp value has been found (funcsize=0)"

//----- (1002FEC2) --------------------------------------------------------
#error "1002FEE1: positive sp value has been found (funcsize=0)"

//----- (1002FEE2) --------------------------------------------------------
#error "1002FEF5: positive sp value has been found (funcsize=0)"

//----- (1002FEF6) --------------------------------------------------------
#error "1002FF0D: positive sp value has been found (funcsize=0)"

//----- (1002FF0E) --------------------------------------------------------
#error "1002FF21: positive sp value has been found (funcsize=0)"

//----- (1002FF22) --------------------------------------------------------
#error "1002FF41: positive sp value has been found (funcsize=0)"

//----- (1002FF47) --------------------------------------------------------
#error "1002FF60: positive sp value has been found (funcsize=0)"

//----- (1002FF66) --------------------------------------------------------
#error "1002FF85: positive sp value has been found (funcsize=0)"

//----- (1002FF86) --------------------------------------------------------
#error "1002FF99: positive sp value has been found (funcsize=0)"

//----- (1002FF9A) --------------------------------------------------------
#error "1002FFB1: positive sp value has been found (funcsize=0)"

//----- (1002FFB2) --------------------------------------------------------
#error "1002FFC5: positive sp value has been found (funcsize=0)"

//----- (10030A8C) --------------------------------------------------------
int __cdecl sub_10030A8C(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_10034C62((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 100356E6: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10030B32) --------------------------------------------------------
int __cdecl sub_10030B32(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_100351A4((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 100356E6: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10031052) --------------------------------------------------------
int sub_10031052()
{
  dword_10177318 = _get_sse2_info();
  return 0;
}
// 10030FF2: using guessed type int _get_sse2_info(void);
// 10177318: using guessed type int dword_10177318;

//----- (10031334) --------------------------------------------------------
void sub_10031334()
{
  dword_101771DC = 0;
}
// 101771DC: using guessed type int dword_101771DC;

//----- (10031822) --------------------------------------------------------
int sub_10031822()
{
  return _decode_pointer(dword_101540A0);
}
// 1002A691: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 101540A0: using guessed type int dword_101540A0;

//----- (100319DF) --------------------------------------------------------
int __cdecl sub_100319DF(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101540AC = a1;
  return result;
}
// 101540AC: using guessed type int dword_101540AC;

//----- (100319E9) --------------------------------------------------------
int __cdecl sub_100319E9(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101540B8 = a1;
  return result;
}
// 101540B8: using guessed type int dword_101540B8;

//----- (100319F3) --------------------------------------------------------
int __cdecl sub_100319F3(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101540BC = a1;
  return result;
}
// 101540BC: using guessed type int dword_101540BC;

//----- (10031AD2) --------------------------------------------------------
int __cdecl sub_10031AD2(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101540C0 = a1;
  return result;
}
// 101540C0: using guessed type int dword_101540C0;

//----- (100333DC) --------------------------------------------------------
DWORD __cdecl sub_100333DC(int a1, int a2, int a3, DWORD dwMoveMethod)
{
  void *v4; // eax@1
  DWORD v6; // eax@5
  _BYTE *v7; // eax@7
  DWORD lDistanceToMove; // [sp+8h] [bp-8h]@4
  LONG DistanceToMoveHigh; // [sp+Ch] [bp-4h]@1

  DistanceToMoveHigh = a3;
  v4 = (void *)sub_10037001(a1);
  if ( v4 == (void *)-1 )
  {
    *_errno() = 9;
    return -1;
  }
  lDistanceToMove = SetFilePointer(v4, a2, &DistanceToMoveHigh, dwMoveMethod);
  if ( lDistanceToMove == -1 )
  {
    v6 = GetLastError();
    if ( v6 )
    {
      _dosmaperr(v6);
      return -1;
    }
  }
  v7 = (_BYTE *)(dword_10177200[a1 >> 5] + ((a1 & 0x1F) << 6) + 4);
  *v7 &= 0xFDu;
  return lDistanceToMove;
}
// 1002834B: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 10177200: using guessed type int dword_10177200[];

//----- (10033578) --------------------------------------------------------
_WORD *__cdecl sub_10033578(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // esi@5
  int v5; // edi@5
  int v6; // eax@5
  char v7; // bl@5
  int v8; // eax@13
  void *v9; // ST18_4@13
  DWORD v10; // eax@16
  const char *v11; // ebx@16
  char v12; // cl@19
  int *v13; // esi@19
  int v14; // eax@19
  int v15; // eax@20
  int v16; // eax@27
  signed int v17; // esi@27
  int v18; // eax@31
  int v19; // esi@36
  __int16 v20; // ax@39
  int v21; // ecx@45
  char v22; // dl@45
  int v23; // eax@46
  DWORD v24; // ecx@51
  char *v25; // eax@51
  char *v26; // edx@53
  char v27; // dl@53
  int v28; // ebx@56
  DWORD v29; // ecx@64
  char *v30; // eax@64
  __int16 *v31; // edx@66
  __int16 v32; // dx@66
  int v33; // ebx@69
  DWORD v34; // ecx@74
  WCHAR *v35; // eax@74
  WCHAR v36; // dx@76
  int v37; // esi@79
  int v38; // ebx@79
  DWORD Mode; // [sp+4h] [bp-7Ch]@13
  int v40; // [sp+8h] [bp-78h]@13
  char v41; // [sp+Fh] [bp-71h]@5
  int *v42; // [sp+10h] [bp-70h]@5
  DWORD v43; // [sp+14h] [bp-6Ch]@56
  int v44; // [sp+18h] [bp-68h]@1
  LPCVOID lpBuffer; // [sp+1Ch] [bp-64h]@1
  _WORD *v46; // [sp+20h] [bp-60h]@1
  DWORD NumberOfBytesWritten; // [sp+24h] [bp-5Ch]@16
  WCHAR WideCharStr[2]; // [sp+28h] [bp-58h]@20
  _WORD *v49; // [sp+2Ch] [bp-54h]@17
  char Buffer; // [sp+30h] [bp-50h]@51
  CHAR v51[688]; // [sp+184h] [bp+104h]@79
  WCHAR v52; // [sp+434h] [bp+3B4h]@74
  CHAR MultiByteStr; // [sp+588h] [bp+508h]@20
  char v54; // [sp+589h] [bp+509h]@20

  lpBuffer = (LPCVOID)a2;
  v46 = 0;
  v44 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a2 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  v4 = &dword_10177200[a1 >> 5];
  v5 = (a1 & 0x1F) << 6;
  v6 = v5 + *v4;
  v7 = (char)(2 * *(_BYTE *)(v6 + 36)) >> 1;
  v42 = &dword_10177200[a1 >> 5];
  v41 = v7;
  if ( (v7 == 2 || v7 == 1) && !(~(_BYTE)nNumberOfBytesToWrite & 1) )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  if ( *(_BYTE *)(v6 + 4) & 0x20 )
    sub_100333DC(a1, 0, 0, 2u);
  if ( sub_10033CBA(a1) )
  {
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x80 )
    {
      v8 = _getptd();
      v9 = *(void **)(v5 + *v4);
      v40 = *(_DWORD *)(*(_DWORD *)(v8 + 108) + 20) == 0;
      if ( GetConsoleMode(v9, &Mode) )
      {
        if ( !v40 || v7 )
        {
          v10 = GetConsoleCP();
          v11 = (const char *)lpBuffer;
          Mode = v10;
          NumberOfBytesWritten = 0;
          if ( nNumberOfBytesToWrite )
          {
            v49 = 0;
            while ( 1 )
            {
              if ( v41 )
              {
                if ( v41 == 1 || v41 == 2 )
                {
                  v19 = *(_WORD *)v11;
                  v11 += 2;
                  ++v49;
                  *(_DWORD *)WideCharStr = v19;
                  v40 = (_WORD)v19 == 10;
                }
                if ( v41 == 1 || v41 == 2 )
                {
                  v20 = _putwch_nolock(WideCharStr[0]);
                  if ( v20 != WideCharStr[0] )
                    goto LABEL_89;
                  v46 = (_WORD *)((char *)v46 + 1);
                  if ( v40 )
                  {
                    *(_DWORD *)WideCharStr = 13;
                    if ( (unsigned __int16)_putwch_nolock(13) != 13 )
                      goto LABEL_89;
                    v46 = (_WORD *)((char *)v46 + 1);
                    ++v44;
                  }
                }
                goto LABEL_43;
              }
              v12 = *v11;
              v13 = v42;
              v40 = *v11 == 10;
              v14 = v5 + *v42;
              if ( *(_DWORD *)(v14 + 56) )
              {
                MultiByteStr = *(_BYTE *)(v14 + 52);
                v54 = v12;
                *(_DWORD *)(v14 + 56) = 0;
                v15 = mbtowc(WideCharStr, &MultiByteStr, 2u);
              }
              else
              {
                if ( isleadbyte(v12) )
                {
                  if ( nNumberOfBytesToWrite + (_BYTE *)lpBuffer - v11 <= 1 )
                  {
                    v21 = *v13;
                    v22 = *v11;
                    v46 = (_WORD *)((char *)v46 + 1);
                    *(_BYTE *)(v5 + v21 + 52) = v22;
                    *(_DWORD *)(v5 + *v13 + 56) = 1;
                    goto LABEL_90;
                  }
                  if ( mbtowc(WideCharStr, v11, 2u) == -1 )
                    goto LABEL_90;
                  ++v11;
                  v49 = (_WORD *)((char *)v49 + 1);
                  goto LABEL_27;
                }
                v15 = mbtowc(WideCharStr, v11, 1u);
              }
              if ( v15 == -1 )
                goto LABEL_90;
LABEL_27:
              ++v11;
              v49 = (_WORD *)((char *)v49 + 1);
              v16 = WideCharToMultiByte(Mode, 0, WideCharStr, 1, &MultiByteStr, 5, 0, 0);
              v17 = v16;
              if ( !v16 )
                goto LABEL_90;
              if ( !WriteFile(*(HANDLE *)(v5 + *v42), &MultiByteStr, v16, &NumberOfBytesWritten, 0) )
                goto LABEL_89;
              v46 = (_WORD *)((char *)v49 + v44);
              if ( (signed int)NumberOfBytesWritten < v17 )
                goto LABEL_90;
              if ( v40 )
              {
                v18 = *v42;
                MultiByteStr = 13;
                if ( !WriteFile(*(HANDLE *)(v5 + v18), &MultiByteStr, 1u, &NumberOfBytesWritten, 0) )
                  goto LABEL_89;
                if ( (signed int)NumberOfBytesWritten < 1 )
                  goto LABEL_90;
                ++v44;
                v46 = (_WORD *)((char *)v46 + 1);
              }
LABEL_43:
              if ( (unsigned int)v49 >= nNumberOfBytesToWrite )
                goto LABEL_90;
            }
          }
          goto LABEL_91;
        }
      }
    }
  }
  v23 = v5 + *v4;
  if ( *(_BYTE *)(v23 + 4) & 0x80 )
  {
    *(_DWORD *)WideCharStr = 0;
    if ( v7 )
    {
      v49 = lpBuffer;
      if ( v7 == 2 )
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v29 = (char *)v49 - (_BYTE *)lpBuffer;
          v30 = &Buffer;
          do
          {
            if ( v29 >= nNumberOfBytesToWrite )
              break;
            v31 = v49;
            ++v49;
            v32 = *v31;
            v29 += 2;
            if ( v32 == 10 )
            {
              v44 += 2;
              *(_WORD *)v30 = 13;
              v30 += 2;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *(_WORD *)v30 = v32;
            v30 += 2;
          }
          while ( NumberOfBytesWritten < 0x3FF );
          v33 = v30 - &Buffer;
          if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v30 - &Buffer, &v43, 0) )
            break;
          v46 = (_WORD *)((char *)v46 + v43);
          if ( (signed int)v43 < v33 || (char *)v49 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
            goto LABEL_90;
          v4 = v42;
        }
      }
      else
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v34 = (char *)v49 - (_BYTE *)lpBuffer;
          v35 = &v52;
          do
          {
            if ( v34 >= nNumberOfBytesToWrite )
              break;
            v36 = *v49;
            ++v49;
            v34 += 2;
            if ( v36 == 10 )
            {
              *v35 = 13;
              ++v35;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *v35 = v36;
            ++v35;
          }
          while ( NumberOfBytesWritten < 0x152 );
          v37 = 0;
          v38 = WideCharToMultiByte(0xFDE9u, 0, &v52, v35 - &v52, v51, 683, 0, 0);
          if ( !v38 )
            break;
          while ( WriteFile(*(HANDLE *)(v5 + *v42), &v51[v37], v38 - v37, &v43, 0) )
          {
            v37 += v43;
            if ( v38 <= v37 )
              goto LABEL_84;
          }
          *(_DWORD *)WideCharStr = GetLastError();
LABEL_84:
          if ( v38 <= v37 )
          {
            v46 = (_WORD *)((char *)v49 - (_BYTE *)lpBuffer);
            if ( (char *)v49 - (_BYTE *)lpBuffer < nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_90;
        }
      }
    }
    else
    {
      NumberOfBytesWritten = (DWORD)lpBuffer;
      if ( nNumberOfBytesToWrite <= 0 )
        goto LABEL_96;
      while ( 1 )
      {
        v49 = 0;
        v24 = NumberOfBytesWritten - (_DWORD)lpBuffer;
        v25 = &Buffer;
        do
        {
          if ( v24 >= nNumberOfBytesToWrite )
            break;
          v26 = (char *)NumberOfBytesWritten++;
          v27 = *v26;
          ++v24;
          if ( v27 == 10 )
          {
            ++v44;
            *v25++ = 13;
            v49 = (_WORD *)((char *)v49 + 1);
          }
          *v25++ = v27;
          v49 = (_WORD *)((char *)v49 + 1);
        }
        while ( (unsigned int)v49 < 0x400 );
        v28 = v25 - &Buffer;
        if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v25 - &Buffer, &v43, 0) )
          break;
        v46 = (_WORD *)((char *)v46 + v43);
        if ( (signed int)v43 < v28 || NumberOfBytesWritten - (unsigned int)lpBuffer >= nNumberOfBytesToWrite )
          goto LABEL_90;
        v4 = v42;
      }
    }
  }
  else if ( WriteFile(*(HANDLE *)v23, lpBuffer, nNumberOfBytesToWrite, &v43, 0) )
  {
    *(_DWORD *)WideCharStr = 0;
    v46 = (_WORD *)v43;
    goto LABEL_90;
  }
LABEL_89:
  *(_DWORD *)WideCharStr = GetLastError();
LABEL_90:
  if ( !v46 )
  {
LABEL_91:
    if ( *(_DWORD *)WideCharStr )
    {
      if ( *(_DWORD *)WideCharStr == 5 )
      {
        *_errno() = 9;
        *__doserrno() = 5;
      }
      else
      {
        _dosmaperr(*(_DWORD *)WideCharStr);
      }
      return (_WORD *)-1;
    }
    v4 = v42;
LABEL_96:
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x40 && *(_BYTE *)lpBuffer == 26 )
      return 0;
    *_errno() = 28;
    *__doserrno() = 0;
    return (_WORD *)-1;
  }
  return (_WORD *)((char *)v46 - v44);
}
// 1002834B: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 1002A8AD: using guessed type int _getptd(void);
// 1002E390: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10177200: using guessed type int dword_10177200[];
// 10033578: using guessed type CHAR var_410[688];

//----- (10033B9A) --------------------------------------------------------
_WORD *__cdecl sub_10033B9A(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // ebx@7
  int v5; // esi@7
  _WORD *v6; // [sp+14h] [bp-1Ch]@9

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return (_WORD *)-1;
  }
  if ( a1 < 0
    || a1 >= uNumber
    || (v4 = &dword_10177200[a1 >> 5], v5 = (a1 & 0x1F) << 6, !(*(_BYTE *)(*v4 + v5 + 4) & 1)) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  __lock_fhandle(a1);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    v6 = sub_10033578(a1, a2, nNumberOfBytesToWrite);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    v6 = (_WORD *)-1;
  }
  sub_10037112(a1);
  return v6;
}
// 1002E390: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10037072: using guessed type _DWORD __cdecl __lock_fhandle(_DWORD);
// 10177200: using guessed type int dword_10177200[];

//----- (10033CBA) --------------------------------------------------------
int __cdecl sub_10033CBA(signed int a1)
{
  int result; // eax@2

  if ( a1 == -2 )
  {
    *_errno() = 9;
    result = 0;
  }
  else if ( a1 >= 0 && a1 < uNumber )
  {
    result = *(_BYTE *)(dword_10177200[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) & 0x40;
  }
  else
  {
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 0;
  }
  return result;
}
// 1002E390: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10177200: using guessed type int dword_10177200[];

//----- (10033D18) --------------------------------------------------------
void **sub_10033D18()
{
  return &off_100B7ED0;
}
// 100B7ED0: using guessed type void *off_100B7ED0;

//----- (10033D1E) --------------------------------------------------------
signed int sub_10033D1E()
{
  size_t v0; // eax@1
  void *v1; // eax@6
  signed int result; // eax@8
  int v3; // edx@9
  void **v4; // ecx@9
  signed int v5; // edx@12
  _DWORD *v6; // ecx@12
  int v7; // eax@13

  v0 = dword_101771C0;
  if ( !dword_101771C0 )
  {
    v0 = 512;
LABEL_5:
    dword_101771C0 = v0;
    goto LABEL_6;
  }
  if ( dword_101771C0 < 20 )
  {
    v0 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v1 = (void *)_calloc_crt(v0, 4);
  dword_101761B4 = v1;
  if ( v1 || (dword_101771C0 = 20, v1 = (void *)_calloc_crt(0x14u, 4), (dword_101761B4 = v1) != 0) )
  {
    v3 = 0;
    v4 = &off_100B7ED0;
    while ( 1 )
    {
      *(_DWORD *)((char *)v1 + v3) = v4;
      v4 += 8;
      v3 += 4;
      if ( (signed int)v4 >= (signed int)&dword_100B8150 )
        break;
      v1 = dword_101761B4;
    }
    v5 = 0;
    v6 = &unk_100B7EE0;
    do
    {
      v7 = *(_DWORD *)(((v5 & 0x1F) << 6) + dword_10177200[v5 >> 5]);
      if ( v7 == -1 || v7 == -2 || !v7 )
        *v6 = -2;
      v6 += 8;
      ++v5;
    }
    while ( (signed int)v6 < (signed int)&unk_100B7F40 );
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 1002ACA1: using guessed type _DWORD __cdecl _calloc_crt(size_t, _DWORD);
// 100B7ED0: using guessed type void *off_100B7ED0;
// 100B8150: using guessed type int dword_100B8150;
// 101771C0: using guessed type int dword_101771C0;
// 10177200: using guessed type int dword_10177200[];

//----- (10034115) --------------------------------------------------------
int __cdecl sub_10034115(FILE *a1)
{
  int v1; // eax@3
  int v2; // eax@7
  int v3; // ST10_4@10
  char *v4; // ST0C_4@10
  int v5; // eax@10
  int v6; // eax@10
  int *v7; // edi@15
  _BYTE *v8; // eax@15
  int v9; // eax@20
  char *v10; // ecx@23
  int result; // eax@23

  if ( !a1 )
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v1 = a1->_flag;
  if ( !(v1 & 0x83) || v1 & 0x40 )
    return -1;
  if ( v1 & 2 )
  {
    a1->_flag = v1 | 0x20;
    return -1;
  }
  v2 = v1 | 1;
  a1->_flag = v2;
  if ( v2 & 0x10C )
    a1->_ptr = a1->_base;
  else
    _getbuf(a1);
  v3 = a1->_bufsiz;
  v4 = a1->_base;
  v5 = _fileno(a1);
  v6 = _read(v5, v4, v3);
  a1->_cnt = v6;
  if ( !v6 || v6 == -1 )
  {
    a1->_flag |= v6 != 0 ? 32 : 16;
    a1->_cnt = 0;
    return -1;
  }
  if ( !(a1->_flag & 0x82) )
  {
    if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
    {
      v8 = &unk_100B7310;
    }
    else
    {
      v7 = &dword_10177200[_fileno(a1) >> 5];
      v8 = (_BYTE *)(*v7 + ((_fileno(a1) & 0x1F) << 6));
    }
    if ( (v8[4] & 0x82) == -126 )
      a1->_flag |= 0x2000u;
  }
  if ( a1->_bufsiz == 512 )
  {
    v9 = a1->_flag;
    if ( v9 & 8 )
    {
      if ( !(v9 & 0x400) )
        a1->_bufsiz = 4096;
    }
  }
  v10 = a1->_ptr;
  --a1->_cnt;
  result = (unsigned __int8)*v10;
  a1->_ptr = v10 + 1;
  return result;
}
// 1002E390: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10033C76: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 10177200: using guessed type int dword_10177200[];

//----- (10034235) --------------------------------------------------------
int __cdecl sub_10034235(int a1, FILE *a2)
{
  int *v2; // edi@4
  _BYTE *v3; // eax@4
  int *v4; // edi@9
  _BYTE *v5; // eax@9
  int v7; // eax@16
  char *v8; // eax@24
  int v9; // eax@28

  if ( !(a2->_flag & 0x40) )
  {
    if ( _fileno(a2) == -1 || _fileno(a2) == -2 )
    {
      v3 = &unk_100B7310;
    }
    else
    {
      v2 = &dword_10177200[_fileno(a2) >> 5];
      v3 = (_BYTE *)(*v2 + ((_fileno(a2) & 0x1F) << 6));
    }
    if ( v3[36] & 0x7F
      || (_fileno(a2) == -1 || _fileno(a2) == -2 ? (v5 = &unk_100B7310) : (v4 = &dword_10177200[_fileno(a2) >> 5],
                                                                           v5 = (_BYTE *)(*v4
                                                                                        + ((_fileno(a2) & 0x1F) << 6))),
          v5[36] & 0x80) )
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
  }
  if ( a1 == -1 )
    return -1;
  v7 = a2->_flag;
  if ( !(v7 & 1) && ((char)v7 >= 0 || v7 & 2) )
    return -1;
  if ( !a2->_base )
    _getbuf(a2);
  if ( a2->_ptr == a2->_base )
  {
    if ( a2->_cnt )
      return -1;
    ++a2->_ptr;
  }
  v8 = --a2->_ptr;
  if ( a2->_flag & 0x40 )
  {
    if ( *v8 != (_BYTE)a1 )
    {
      a2->_ptr = v8 + 1;
      return -1;
    }
  }
  else
  {
    *v8 = a1;
  }
  v9 = a2->_flag;
  ++a2->_cnt;
  a2->_flag = v9 & 0xFFFFFFEF | 1;
  return (unsigned __int8)a1;
}
// 1002E390: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10033C76: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 10177200: using guessed type int dword_10177200[];

//----- (1003447D) --------------------------------------------------------
int sub_1003447D()
{
  return 0;
}

//----- (10034C62) --------------------------------------------------------
signed int __cdecl sub_10034C62(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_100B8264 - 1;
    v64 = v3;
    v65 = dword_100B8264 / 32;
    v9 = dword_100B8264 % 32;
    v10 = (int *)(&v60 + dword_100B8264 / 32);
    v66 = 31 - dword_100B8264 % 32;
    if ( (1 << (31 - dword_100B8264 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_100B8260 - dword_100B8264 )
    {
      if ( v3 > dword_100B8260 )
      {
        if ( v3 < dword_100B825C )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_100B8270 + v3;
          v50 = dword_100B8268 / 32;
          v51 = dword_100B8268 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_100B8268 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_100B8268 / 32;
          v44 = dword_100B8268 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_100B8268 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_100B8270 + dword_100B825C;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_100B8260 - v64) / 32;
      v62 = v59;
      v18 = (dword_100B8260 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_100B8264 - 1;
      v25 = dword_100B8264 / 32;
      v65 = dword_100B8264 / 32;
      v26 = (int *)(&v60 + dword_100B8264 / 32);
      v64 = 31 - dword_100B8264 % 32;
      if ( (1 << (31 - dword_100B8264 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_100B8264 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_100B8268 + 1) / 32;
      v37 = (dword_100B8268 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_100B8268));
  if ( dword_100B826C == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_100B826C == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 100B825C: using guessed type int dword_100B825C;
// 100B8260: using guessed type int dword_100B8260;
// 100B8264: using guessed type int dword_100B8264;
// 100B8268: using guessed type int dword_100B8268;
// 100B826C: using guessed type int dword_100B826C;
// 100B8270: using guessed type int dword_100B8270;

//----- (100351A4) --------------------------------------------------------
signed int __cdecl sub_100351A4(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_100B827C - 1;
    v64 = v3;
    v65 = dword_100B827C / 32;
    v9 = dword_100B827C % 32;
    v10 = (int *)(&v60 + dword_100B827C / 32);
    v66 = 31 - dword_100B827C % 32;
    if ( (1 << (31 - dword_100B827C % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_100B8278 - dword_100B827C )
    {
      if ( v3 > dword_100B8278 )
      {
        if ( v3 < dword_100B8274 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_100B8288 + v3;
          v50 = dword_100B8280 / 32;
          v51 = dword_100B8280 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_100B8280 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_100B8280 / 32;
          v44 = dword_100B8280 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_100B8280 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_100B8288 + dword_100B8274;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_100B8278 - v64) / 32;
      v62 = v59;
      v18 = (dword_100B8278 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_100B827C - 1;
      v25 = dword_100B827C / 32;
      v65 = dword_100B827C / 32;
      v26 = (int *)(&v60 + dword_100B827C / 32);
      v64 = 31 - dword_100B827C % 32;
      if ( (1 << (31 - dword_100B827C % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_100B827C % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_100B8280 + 1) / 32;
      v37 = (dword_100B8280 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_100B8280));
  if ( dword_100B8284 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_100B8284 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 100B8274: using guessed type int dword_100B8274;
// 100B8278: using guessed type int dword_100B8278;
// 100B827C: using guessed type int dword_100B827C;
// 100B8280: using guessed type int dword_100B8280;
// 100B8284: using guessed type int dword_100B8284;
// 100B8288: using guessed type int dword_100B8288;

//----- (10036A9D) --------------------------------------------------------
int __cdecl sub_10036A9D(int a1, int a2, int a3)
{
  HMODULE v3; // eax@2
  HMODULE v4; // edi@2
  FARPROC v5; // eax@3
  FARPROC v6; // eax@4
  FARPROC v7; // eax@4
  FARPROC v8; // eax@7
  FARPROC v9; // eax@8
  int (*v10)(void); // esi@11
  int (__stdcall *v11)(int, signed int, char *, signed int, char *); // eax@11
  int (__stdcall *v12)(int, signed int, char *, signed int, char *); // edi@11
  int v13; // eax@13
  int (*v14)(void); // eax@22
  int (__stdcall *v15)(int); // eax@25
  int (__stdcall *v16)(int, int, int, int); // eax@27
  char v18; // [sp+10h] [bp-20h]@14
  char v19; // [sp+18h] [bp-18h]@15
  char v20; // [sp+1Ch] [bp-14h]@14
  unsigned int v21; // [sp+20h] [bp-10h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+28h] [bp-8h]@1
  int v24; // [sp+2Ch] [bp-4h]@1

  v23 = _encoded_null();
  v24 = 0;
  v22 = 0;
  v21 = 0;
  if ( !dword_101540DC )
  {
    v3 = LoadLibraryA("USER32.DLL");
    v4 = v3;
    if ( !v3 )
      return 0;
    v5 = GetProcAddress(v3, "MessageBoxA");
    if ( !v5 )
      return 0;
    dword_101540DC = _encode_pointer(v5);
    v6 = GetProcAddress(v4, "GetActiveWindow");
    dword_101540E0 = _encode_pointer(v6);
    v7 = GetProcAddress(v4, "GetLastActivePopup");
    dword_101540E4 = _encode_pointer(v7);
    if ( sub_1002A35B(&v22) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v22 == 2 )
    {
      v8 = GetProcAddress(v4, "GetUserObjectInformationA");
      dword_101540EC = _encode_pointer(v8);
      if ( dword_101540EC )
      {
        v9 = GetProcAddress(v4, "GetProcessWindowStation");
        dword_101540E8 = _encode_pointer(v9);
      }
    }
  }
  if ( dword_101540E8 == v23
    || dword_101540EC == v23
    || (v10 = (int (*)(void))_decode_pointer(dword_101540E8),
        v11 = (int (__stdcall *)(int, signed int, char *, signed int, char *))_decode_pointer(dword_101540EC),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, &v18, 12, &v20) && v19 & 1 )
  {
    if ( dword_101540E0 != v23 )
    {
      v14 = (int (*)(void))_decode_pointer(dword_101540E0);
      if ( v14 )
      {
        v24 = v14();
        if ( v24 )
        {
          if ( dword_101540E4 != v23 )
          {
            v15 = (int (__stdcall *)(int))_decode_pointer(dword_101540E4);
            if ( v15 )
              v24 = v15(v24);
          }
        }
      }
    }
  }
  else
  {
    if ( sub_1002A392(&v21) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v21 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_101540DC);
  if ( v16 )
    return v16(v24, a1, a2, a3);
  return 0;
}
// 1002A61A: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 1002A688: using guessed type int _encoded_null(void);
// 1002A691: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1002E294: using guessed type int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101540DC: using guessed type int dword_101540DC;
// 101540E0: using guessed type int dword_101540E0;
// 101540E4: using guessed type int dword_101540E4;
// 101540E8: using guessed type int dword_101540E8;
// 101540EC: using guessed type int dword_101540EC;

//----- (10036F80) --------------------------------------------------------
signed int __cdecl sub_10036F80(signed int a1)
{
  int *v1; // edi@3
  int v2; // esi@3
  int v3; // eax@3
  DWORD v5; // [sp-8h] [bp-14h]@9

  if ( a1 >= 0 && a1 < uNumber )
  {
    v1 = &dword_10177200[a1 >> 5];
    v2 = (a1 & 0x1F) << 6;
    v3 = v2 + *v1;
    if ( *(_BYTE *)(v3 + 4) & 1 )
    {
      if ( *(_DWORD *)v3 != -1 )
      {
        if ( dword_10153740 == 1 )
        {
          if ( !a1 )
          {
            v5 = -10;
            goto LABEL_12;
          }
          if ( a1 == 1 )
          {
            v5 = -11;
            goto LABEL_12;
          }
          if ( a1 == 2 )
          {
            v5 = -12;
LABEL_12:
            SetStdHandle(v5, 0);
            goto LABEL_13;
          }
        }
LABEL_13:
        *(_DWORD *)(v2 + *v1) = -1;
        return 0;
      }
    }
  }
  *_errno() = 9;
  *__doserrno() = 0;
  return -1;
}
// 10153740: using guessed type int dword_10153740;
// 10177200: using guessed type int dword_10177200[];

//----- (10037001) --------------------------------------------------------
signed int __cdecl sub_10037001(signed int a1)
{
  signed int result; // eax@2
  int v2; // eax@5

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    result = -1;
  }
  else if ( a1 >= 0 && a1 < uNumber && (v2 = dword_10177200[a1 >> 5] + ((a1 & 0x1F) << 6), *(_BYTE *)(v2 + 4) & 1) )
  {
    result = *(_DWORD *)v2;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  return result;
}
// 1002E390: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10177200: using guessed type int dword_10177200[];

//----- (10037112) --------------------------------------------------------
void __cdecl sub_10037112(signed int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(dword_10177200[a1 >> 5] + ((a1 & 0x1F) << 6) + 12));
}
// 10177200: using guessed type int dword_10177200[];

//----- (10037413) --------------------------------------------------------
int sub_10037413()
{
  return flsall(1);
}
// 10037339: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (1003817C) --------------------------------------------------------
signed int __cdecl sub_1003817C(signed int a1)
{
  signed int v1; // edi@6
  void *v2; // eax@7
  DWORD v3; // edi@8
  signed int result; // eax@11

  if ( sub_10037001(a1) == -1
    || (a1 == 1 && *(_BYTE *)(dword_10177200[0] + 132) & 1 || a1 == 2 && *(_BYTE *)(dword_10177200[0] + 68) & 1)
    && (v1 = sub_10037001(2), sub_10037001(1) == v1)
    || (v2 = (void *)sub_10037001(a1), CloseHandle(v2)) )
  {
    v3 = 0;
  }
  else
  {
    v3 = GetLastError();
  }
  sub_10036F80(a1);
  *(_BYTE *)(dword_10177200[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) = 0;
  if ( v3 )
  {
    _dosmaperr(v3);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1002834B: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 10177200: using guessed type int dword_10177200[];

//----- (10038360) --------------------------------------------------------
signed int __cdecl sub_10038360(unsigned int a1, int a2, int a3, int a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  signed int result; // eax@3

  v4 = sub_100383E0(a1);
  v5 = v4;
  if ( v4 < 0xFFFFFFC2 && v4 )
  {
    if ( sub_10039300(v4, a4, 0) == a4 )
      result = sub_100392A0(v5, a2, a3);
    else
      result = -15;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (100383C0) --------------------------------------------------------
signed int __cdecl sub_100383C0(unsigned int a1, int a2, int a3)
{
  unsigned int v3; // eax@1

  v3 = sub_100383E0(a1);
  return sub_10039300(v3, a2, a3);
}

//----- (100383E0) --------------------------------------------------------
unsigned int __cdecl sub_100383E0(unsigned int a1)
{
  unsigned int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = a1 & 0xFFFFFFFC;
  else
    result = 0;
  return result;
}

//----- (10038400) --------------------------------------------------------
bool __cdecl sub_10038400(int a1)
{
  bool result; // al@1
  unsigned int v2; // eax@4
  _DWORD *v3; // edx@4
  _DWORD *v4; // esi@4
  int v5; // ecx@8
  int v6; // eax@9
  _BYTE *v7; // edx@9
  _BYTE *v8; // esi@9
  int v9; // eax@11
  _BYTE *v10; // edx@11
  _BYTE *v11; // esi@11
  _BYTE *v12; // edx@13
  _BYTE *v13; // esi@13
  int v14; // edx@14
  signed int v15; // eax@15

  result = *(_DWORD *)(a1 + 88) == ~*(_DWORD *)(a1 + 36);
  if ( *(_WORD *)(a1 + 30) != 99 || !result && *(_WORD *)(a1 + 684) != 2 )
    return result;
  v2 = 10;
  v3 = (_DWORD *)(a1 + 693);
  v4 = (_DWORD *)(a1 + 721);
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_8;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_17:
    v15 = 0;
    return v15 == 0;
  }
LABEL_8:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_17;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_17;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_17;
        v14 = *v12;
        v5 = *v13 - v14;
        if ( *v13 == v14 )
          goto LABEL_17;
      }
    }
  }
  v15 = 1;
  if ( v5 <= 0 )
    return 0;
  return v15 == 0;
}

//----- (100384D0) --------------------------------------------------------
int __cdecl sub_100384D0(int a1)
{
  return *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 32) + *(_WORD *)(a1 + 28) + 46;
}

//----- (100384F0) --------------------------------------------------------
int __cdecl sub_100384F0(int a1, int a2)
{
  int result; // eax@2

  if ( a2 )
    result = *(_WORD *)(a2 + 28) + *(_WORD *)(a2 + 26) + 30;
  else
    result = -16 - *(_WORD *)(a1 + 52) + sub_100384D0(a1 + 20);
  return result;
}

//----- (10038530) --------------------------------------------------------
signed int __cdecl sub_10038530(int a1, void *a2, unsigned __int16 a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // ebp@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 732);
  v6 = 0;
  result = -15;
  v8 = *(_WORD *)(a1 + 48) + *(_DWORD *)(a1 + 16) + 46;
  if ( *(_WORD *)(a1 + 50) >= 4u )
  {
    while ( (unsigned int)(v6 + v8) < *(_DWORD *)(v5 + 120) )
    {
      if ( sub_10025430(*(_DWORD *)(v5 + 4), &a1, 4, v6 + v8, 0) != 4 )
        return -15;
      if ( (_WORD)a1 == a4 && (unsigned int)HIWORD(a1) + 4 <= a3 )
        return sub_10025430(*(_DWORD *)(v5 + 4), a2, HIWORD(a1) + 4, v6 + v8, 0);
      v6 += HIWORD(a1) + 4;
      result = -15;
      if ( v6 + 4 > (unsigned int)*(_WORD *)(v4 + 50) )
        return result;
    }
  }
  return result;
}

//----- (100385F0) --------------------------------------------------------
int __cdecl sub_100385F0(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (10038630) --------------------------------------------------------
int __usercall sub_10038630@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // eax@2
  int result; // eax@2
  int v4; // eax@3
  __int16 v5; // cx@3
  int v6; // edx@3

  sub_1003D060(a2 + 721, a1 + 64);
  if ( *(_DWORD *)(a2 + 44) )
  {
    v4 = *(_DWORD *)(a2 + 725);
    v5 = *(_WORD *)(a2 + 729);
    *(_DWORD *)(a2 + 693) = *(_DWORD *)(a2 + 721);
    v6 = *(_DWORD *)(a2 + 732);
    *(_DWORD *)(a2 + 697) = v4;
    *(_WORD *)(a2 + 701) = v5;
    result = j_FIL_vfs_write(*(_DWORD *)(v6 + 116), a2 + 721, 10);
    *(_DWORD *)(a2 + 136) += 10;
    *(_DWORD *)(a2 + 40) += 10;
  }
  else
  {
    v2 = sub_10025510(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116));
    result = sub_10025530(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), v2 - *(_WORD *)(a2 + 50) - *(_DWORD *)(a2 + 40), 0);
    *(_DWORD *)(a2 + 84) -= *(_WORD *)(a2 + 50);
    *(_DWORD *)(a2 + 136) = 0;
    *(_WORD *)(a2 + 28) &= 0xFFFEu;
    *(_DWORD *)(a2 + 40) = 0;
    *(_WORD *)(a2 + 50) = 0;
    *(_WORD *)(a2 + 30) = 0;
    *(_WORD *)(a2 + 80) = 0;
  }
  return result;
}
// 10025550: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (100386E0) --------------------------------------------------------
signed int __usercall sub_100386E0@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  char v3; // ST30_1@2
  int v4; // ST28_4@2
  int v5; // eax@2
  __int64 v6; // rax@2
  int v7; // ebx@2
  char *v8; // ebp@2
  __int64 v9; // rax@3
  signed int result; // eax@4
  _WORD *v11; // edi@5
  _WORD *v12; // [sp+Ch] [bp-4h]@4

  v2 = a1;
  if ( *(_BYTE *)(a2 + 8) )
  {
    *(_WORD *)(a1 + 532) = -26367;
    *(_WORD *)(a1 + 534) = 7;
    *(_WORD *)(a1 + 536) = 1;
    *(_BYTE *)(a1 + 538) = 65;
    *(_BYTE *)(a1 + 539) = 69;
    v3 = *(_DWORD *)(a2 + 84);
    *(_DWORD *)(a2 + 76) = a1 + 532;
    v4 = a1 + 532;
    v5 = *(_DWORD *)(a2 + 732);
    *(_WORD *)(a2 + 50) = 11;
    *(_WORD *)(a2 + 80) = 11;
    sub_10025560(*(_DWORD *)(v5 + 116), v4, 11, v3);
    *(_DWORD *)(a2 + 84) += *(_WORD *)(a2 + 80);
    *(_BYTE *)(v2 + 540) = *(_BYTE *)(*(_DWORD *)(a2 + 732) + 112);
    v6 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v6) & 7) + (signed int)v6) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_1003D4B0((void *)(v2 + 555), v7);
  }
  else
  {
    sub_10038530(a2, (void *)(a1 + 532), 0xBu, -26367);
    v9 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v9) & 7) + (signed int)v9) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_10025430(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 555), v7, *(_DWORD *)(a2 + 84), 0);
    sub_10025430(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 571), 2, v7 + *(_DWORD *)(a2 + 84), 0);
  }
  v12 = (_WORD *)(v2 + 543);
  result = sub_1003D380(*(_BYTE *)(v2 + 540), (void *)v2, strlen((const char *)v2), v8, (_WORD *)(v2 + 543), v2 + 64);
  if ( *(_BYTE *)(a2 + 8) )
  {
    sub_10025560(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v8, v7, *(_DWORD *)(a2 + 84));
    v11 = (_WORD *)(v2 + 571);
    *v11 = *v12;
    sub_10025560(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v11, 2, v7 + *(_DWORD *)(a2 + 84));
    result = v7 + 2;
    *(_DWORD *)(a2 + 136) += v7 + 2;
    *(_DWORD *)(a2 + 40) += v7 + 2;
  }
  else
  {
    *(_DWORD *)(a2 + 92) += -12 - v7;
    *(_DWORD *)(a2 + 124) += v7 + 2;
  }
  return result;
}

//----- (100388B0) --------------------------------------------------------
char __usercall sub_100388B0@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  return sub_1003D010(a2, a3, a1 + 212);
}

//----- (100388C0) --------------------------------------------------------
int __usercall sub_100388C0@<eax>(int result@<eax>)
{
  if ( *(_WORD *)(result + 30) == 99 )
    result = sub_10038630(result + 148, result);
  return result;
}

//----- (100388E0) --------------------------------------------------------
char __usercall sub_100388E0@<al>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = (*(_DWORD *)(a1 + 72) & 0xFFFD | 2) * ((*(_DWORD *)(a1 + 72) & 0xFFFD | 2) ^ 1);
  return BYTE1(v1);
}

//----- (10038900) --------------------------------------------------------
int __usercall sub_10038900@<eax>(int a1@<esi>, unsigned __int8 a2)
{
  int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@1
  int result; // eax@1

  v2 = sub_100245B0(a2, *(_DWORD *)(a1 + 64));
  v3 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 64) = v2;
  v4 = 134775813 * (*(_DWORD *)(a1 + 68) + (unsigned __int8)v2) + 1;
  *(_DWORD *)(a1 + 68) = v4;
  result = sub_100245B0(BYTE3(v4), v3);
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

//----- (10038940) --------------------------------------------------------
int __fastcall sub_10038940(int a1, int a2)
{
  int result; // eax@1

  result = *(_WORD *)(a2 + 30);
  if ( *(_WORD *)(a2 + 30) == 99 )
    result = *(_WORD *)(a2 + 689);
  return result;
}

//----- (10038960) --------------------------------------------------------
int __usercall sub_10038960@<eax>(int a1@<esi>)
{
  int v1; // ST1C_4@1
  unsigned int v2; // ST18_4@1
  int v3; // eax@1
  int v4; // ST00_4@1

  v1 = *(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 24);
  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = v1;
  sub_100255B0(v2, v1, 0);
  j_FIL_vfs_write(*(_DWORD *)(a1 + 4), a1 + 8, 22);
  v3 = *(_DWORD *)a1 + 22;
  v4 = *(_DWORD *)(a1 + 116);
  *(_DWORD *)(a1 + 120) = v3;
  return sub_10025530(v4, v3, 0);
}
// 10025550: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (100389A0) --------------------------------------------------------
signed int __usercall sub_100389A0@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6)
{
  __int16 v6; // ax@1
  unsigned int *v7; // ecx@1
  int v8; // esi@1
  signed int v9; // eax@1
  unsigned int v10; // eax@1
  int v11; // ebx@1
  int v12; // ebx@1
  int v13; // eax@4
  int v14; // ecx@6
  int v15; // ebp@8
  unsigned int v16; // ebx@11
  __int64 v17; // rax@14
  unsigned int v18; // ecx@15
  unsigned int v19; // ebp@15
  int v21; // ebx@20
  signed int v22; // eax@23
  size_t v23; // ebp@29
  int v24; // ebx@33
  int v25; // [sp+Ch] [bp-8h]@1
  __int16 v26; // [sp+10h] [bp-4h]@1

  v6 = sub_10038940(a1, a3);
  v7 = *(unsigned int **)(a2 + 16);
  v8 = a2 + 28;
  v26 = v6;
  *(_DWORD *)v8 = v7;
  v9 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v8 + 4) = v9;
  v25 = 0;
  v10 = sub_100245D0(v7, v9, *(_DWORD *)a2);
  v11 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)a2 = v10;
  v12 = v11 + 0xFFFFF;
  while ( 1 )
  {
    if ( !*(_DWORD *)(a2 + 32) )
    {
      if ( !a6 )
        goto LABEL_37;
      v13 = *(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(a2 + 44) == v13 && v12 != v13 + 0xFFFFF )
        break;
    }
    v14 = *(_DWORD *)(a2 + 12);
    if ( !v14 )
      break;
    if ( !--v12 )
      break;
    v15 = *(_DWORD *)(a2 + 44);
    if ( !v15 || a6 && v15 != v14 )
    {
      v16 = *(_DWORD *)(a2 + 48);
      if ( v16
        && (v16 >= 0x28
         || *(_WORD *)(a3 + 30) != 99
         || (v17 = ((*(_BYTE *)(a3 + 688) & 3) + 1) << 6, v16 != (((BYTE4(v17) & 7) + (signed int)v17) >> 3) / 2 + 2)) )
      {
        v18 = v14 - v15;
        v19 = v18;
        if ( *(_BYTE *)(a3 + 28) & 1 )
          sub_100388B0(a3, *(char **)(a2 + 8), v18);
        if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v19) != v19 )
          return -16;
      }
      else
      {
        v19 = 0;
      }
      v21 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
      v12 = v21 + 0xFFFFF;
      v25 += v19;
      *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    }
    if ( v26 == 8 )
    {
      if ( a6 )
        v22 = sub_1003F260(a2 + 28, 4);
      else
        v22 = sub_1003F260(a2 + 28, 0);
      if ( v22 && v22 != 1 )
        return -15;
    }
    else
    {
      if ( v26 )
        return -15;
      v23 = *(_DWORD *)(a2 + 44);
      if ( *(_DWORD *)(a2 + 32) < v23 )
        v23 = *(_DWORD *)(a2 + 32);
      memcpy(*(void **)(a2 + 40), *(const void **)v8, v23);
      *(_DWORD *)(a2 + 32) -= v23;
      *(_DWORD *)(a2 + 44) -= v23;
      *(_DWORD *)v8 += v23;
      *(_DWORD *)(a2 + 40) += v23;
      *(_DWORD *)(a2 + 36) += v23;
      *(_DWORD *)(a2 + 48) += v23;
    }
  }
  if ( a6 )
  {
    v24 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44);
    if ( *(_BYTE *)(a3 + 28) & 1 )
      sub_100388B0(a3, *(char **)(a2 + 8), *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44));
    if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v24) != v24 )
      return -16;
    v25 += v24;
    *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
  }
LABEL_37:
  *(_DWORD *)(a5 + 24) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a5 + 20) = *(_DWORD *)(a2 + 48);
  return v25;
}
// 10025550: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10038BB0) --------------------------------------------------------
int __cdecl sub_10038BB0(int a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  unsigned int v3; // ebp@1
  bool v4; // zf@1
  int v5; // ecx@1
  __int16 v6; // cx@4
  __int16 v7; // ax@4
  __int16 v8; // dx@4
  __int16 v9; // cx@4
  unsigned int v10; // edx@4
  int v11; // eax@4
  unsigned int v12; // ecx@4
  int v13; // eax@4
  int result; // eax@5
  int v15; // eax@6
  unsigned __int16 v16; // ax@7
  int v17; // eax@11
  int v18; // edx@13
  int v19; // edi@13
  int v20; // eax@13
  unsigned __int16 v21; // cx@14
  int v22; // [sp+10h] [bp-28h]@4
  char v23; // [sp+14h] [bp-24h]@3
  int v24; // [sp+18h] [bp-20h]@1
  int v25; // [sp+1Ch] [bp-1Ch]@1
  int v26; // [sp+20h] [bp-18h]@1
  int v27; // [sp+24h] [bp-14h]@1
  __int64 v28; // [sp+28h] [bp-10h]@1
  int v29; // [sp+30h] [bp-8h]@1
  __int16 v30; // [sp+34h] [bp-4h]@1
  int v31; // [sp+3Ch] [bp+4h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 732);
  v31 = *(_DWORD *)(v2 + 116);
  sub_100388C0(v1);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_WORD *)(v1 + 32) == 0;
  v5 = ~*(_DWORD *)(v1 + 88);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0i64;
  v29 = 0;
  v30 = 0;
  *(_DWORD *)(v1 + 36) = v5;
  if ( v4 || !*(_WORD *)(v1 + 34) )
  {
    sub_1000F730(&v23);
    sub_1001A850((unsigned int *)&v23, (_WORD *)(v1 + 34), (_WORD *)(v1 + 32));
  }
  v6 = *(_WORD *)(v1 + 24);
  v7 = *(_WORD *)(v1 + 30);
  HIWORD(v25) = *(_WORD *)(v1 + 28);
  v8 = *(_WORD *)(v1 + 34);
  LOWORD(v25) = v6;
  v9 = *(_WORD *)(v1 + 32);
  LOWORD(v27) = v8;
  v10 = *(_DWORD *)(v1 + 44);
  LOWORD(v26) = v7;
  v11 = *(_DWORD *)(v1 + 36);
  HIWORD(v26) = v9;
  v12 = *(_DWORD *)(v1 + 40);
  *(int *)((char *)&v27 + 2) = v11;
  LOWORD(v11) = *(_WORD *)(v1 + 48);
  *(__int64 *)((char *)&v28 + 2) = __PAIR__(v10, v12);
  LOWORD(v12) = *(_WORD *)(v1 + 50);
  v24 = 67324752;
  HIWORD(v29) = v11;
  v30 = v12;
  v22 = sub_100384F0(v1, (int)&v24);
  v13 = sub_10025510(v31);
  if ( v3 == v31 )
  {
    result = sub_10025380(v31, v13, v31, *(_DWORD *)(v2 + 24), *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v15 = *(_DWORD *)(v2 + 24);
    *(_DWORD *)(v1 + 62) = v15;
    *(_DWORD *)(v1 + 84) = v22 + v15;
  }
  sub_100255B0(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 62), 0);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), &v24, 30);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72));
  v16 = *(_WORD *)(v1 + 80);
  if ( v16 )
    j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 76), v16);
  if ( v3 == v31 )
  {
    result = sub_10025380(
               v31,
               *(_DWORD *)(v1 + 84),
               v31,
               v22 + *(_DWORD *)(v2 + 120),
               *(_DWORD *)(v1 + 40) + *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v17 = *(_DWORD *)((char *)&v28 + 2) + v22 + *(_DWORD *)(v2 + 24);
  }
  else
  {
    v17 = 0;
  }
  v18 = v17 + *(_DWORD *)(v2 + 20);
  ++*(_WORD *)(v2 + 16);
  ++*(_WORD *)(v2 + 18);
  *(_DWORD *)(v2 + 8) = 101010256;
  *(_DWORD *)(v2 + 24) = v17;
  *(_WORD *)(v2 + 28) = 0;
  sub_100255B0(v3, v18, 0);
  *(_DWORD *)(v2 + 20) += sub_100384D0(v1 + 20);
  j_FIL_vfs_write(v3, v1 + 20, 46);
  v19 = j_FIL_vfs_write(v3, *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72)) != *(_WORD *)(v1 + 72) ? 0xFFFFFFF1 : 0;
  v20 = *(_DWORD *)(v1 + 76);
  if ( v20 )
  {
    v21 = *(_WORD *)(v1 + 80);
    if ( v21 )
    {
      v19 |= j_FIL_vfs_write(v3, v20, v21);
      if ( v19 >= 0 )
        v19 = 0;
    }
  }
  *(_DWORD *)v2 = *(_DWORD *)(v2 + 20) + *(_DWORD *)(v2 + 24);
  if ( v3 == v31 )
    sub_10038960(v2);
  else
    *(_DWORD *)(v2 + 120) = sub_10025510(v31);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(v2 + 24);
  *(_DWORD *)(v2 + 32) = 0;
  return v19;
}
// 10025550: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10038E20) --------------------------------------------------------
signed int __cdecl sub_10038E20(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ecx@7
  int v5; // eax@10

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    if ( *(_DWORD *)(a1 + 112) == *(_DWORD *)(a1 + 44) && !*(_DWORD *)(a1 + 124) )
      sub_100255B0(*(_DWORD *)(*(_DWORD *)(a1 + 732) + 116), *(_DWORD *)(a1 + 136) + *(_DWORD *)(a1 + 84), 0);
    v4 = *(_DWORD *)(a1 + 112) - a3;
    *(_DWORD *)(a1 + 104) = a2;
    *(_DWORD *)(a1 + 108) = a3;
    v5 = !v4 && *(_DWORD *)(a1 + 136) || !a2;
    result = sub_100389A0(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 88,
               a1,
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 20,
               v5);
    if ( result >= 0 )
    {
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 136);
      *(_DWORD *)(a1 + 112) -= a3;
    }
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10038EC0) --------------------------------------------------------
int __usercall sub_10038EC0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // al@1
  unsigned __int8 *v3; // edx@1

  v1 = a1;
  v2 = sub_100388E0(a1);
  *v3 ^= v2;
  return sub_10038900(v1, *v3);
}

//----- (10038EE0) --------------------------------------------------------
int __usercall sub_10038EE0@<eax>(int a1@<edi>, int a2)
{
  int i; // esi@1
  int result; // eax@2

  for ( i = 0; i < a1; ++i )
    result = sub_10038EC0(a2);
  return result;
}

//----- (10038F10) --------------------------------------------------------
signed int __usercall sub_10038F10@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // esi@1
  signed int v3; // edi@1
  signed int result; // eax@4

  v2 = a1;
  *(_DWORD *)(a1 + 64) = 305419896;
  *(_DWORD *)(a1 + 68) = 591751049;
  *(_DWORD *)(a1 + 72) = 878082192;
  v3 = 0;
  do
  {
    if ( !*(_BYTE *)(v3 + v2) )
      break;
    sub_10038900(v2, *(_BYTE *)(v3++ + v2));
  }
  while ( v3 < 64 );
  result = sub_10025430(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 76), 12, *(_DWORD *)(a2 + 84), 0);
  *(_DWORD *)(a2 + 92) -= 12;
  *(_DWORD *)(a2 + 124) += 12;
  return result;
}

//----- (10039000) --------------------------------------------------------
char __usercall sub_10039000@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>)
{
  char result; // al@2

  if ( *(_WORD *)(a3 + 30) == 99 )
    result = sub_1003CFC0(a1, a2, a3 + 212);
  else
    result = sub_10038EE0(a2, a3 + 148);
  return result;
}

//----- (10039030) --------------------------------------------------------
signed int __usercall sub_10039030@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@1
  int v3; // eax@1
  signed int result; // eax@2

  v1 = a1;
  v2 = *(_WORD *)(a1 + 30) == 99;
  v3 = a1 + 148;
  if ( v2 )
    result = sub_100386E0(v3, v1);
  else
    result = sub_10038F10(v3, v1);
  return result;
}

//----- (10039060) --------------------------------------------------------
signed int __cdecl sub_10039060(unsigned int a1)
{
  signed int result; // eax@3
  int v2; // eax@4
  int v3; // ecx@4
  int v4; // edx@4

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    sub_100385F0(a1 + 116);
    v2 = *(_DWORD *)(a1 + 40);
    v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 88) = -1;
    *(_DWORD *)(a1 + 92) = v2;
    *(_DWORD *)(a1 + 112) = v3;
    sub_10040CD0(v4);
    if ( *(_BYTE *)(a1 + 28) & 1 )
      sub_10039030(a1);
    result = 0;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (100390B0) --------------------------------------------------------
signed int __cdecl sub_100390B0(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned int v5; // ecx@1
  signed int v6; // eax@4
  size_t v8; // eax@9
  size_t v9; // ebx@10
  int v10; // esi@13
  int v11; // edx@18
  __int16 v12; // ax@20
  size_t v13; // esi@21
  int v14; // ST30_4@25
  unsigned int *v15; // ST34_4@25
  int v16; // ebx@25
  int v17; // [sp+10h] [bp-Ch]@1
  int v18; // [sp+24h] [bp+8h]@7

  v2 = a2;
  v3 = a2 + 28;
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 20);
  v5 = *(_DWORD *)(a2 + 24);
  v17 = 0;
  if ( v4 <= v5 )
    *(_DWORD *)(a2 + 44) = v4;
  else
    *(_DWORD *)(a2 + 44) = v5;
  v6 = 0xFFFFF;
  if ( *(_DWORD *)(a2 + 44) )
  {
    while ( 1 )
    {
      v18 = v6 - 1;
      if ( v6 - 1 <= 0 )
        break;
      if ( *(_DWORD *)(v3 + 4) || (v8 = *(_DWORD *)(v2 + 4)) == 0 )
      {
        v10 = a1;
      }
      else
      {
        v9 = *(_DWORD *)(v2 + 12);
        if ( v8 < v9 )
          v9 = *(_DWORD *)(v2 + 4);
        if ( !v9 )
          return v17;
        v10 = a1;
        if ( sub_10025430(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               *(void **)(v2 + 8),
               v9,
               *(_DWORD *)(a1 + 84) + *(_DWORD *)(v3 + 8),
               0) != v9 )
          return -15;
        if ( *(_BYTE *)(a1 + 28) & 1 )
        {
          sub_10039000(*(char **)(v2 + 8), v9, a1);
          if ( *(_DWORD *)(v2 + 4) == v9 && *(_WORD *)(a1 + 30) == 99 )
          {
            sub_10025430(
              *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
              (void *)(a1 + 721),
              10,
              *(_DWORD *)(a1 + 84) + v9 + *(_DWORD *)(v3 + 4) + *(_DWORD *)(v3 + 8),
              0);
            sub_1003D060(a1 + 693, a1 + 212);
            v10 = a1;
          }
        }
        v11 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 4) -= v9;
        v18 = 0xFFFFF;
        *(_DWORD *)v3 = v11;
        *(_DWORD *)(v3 + 4) = v9;
      }
      v12 = sub_10038940(v5, v10);
      if ( v12 )
      {
        if ( v12 != 8 )
          return -15;
        v14 = *(_DWORD *)(v3 + 20);
        v15 = *(unsigned int **)(v3 + 12);
        v16 = (char)sub_10042090(v3, 2);
        v17 += *(_DWORD *)(v3 + 20) - v14;
        *(_DWORD *)v2 = sub_100245D0(v15, *(_DWORD *)(v3 + 20) - v14, *(_DWORD *)v2);
        if ( v16 == 1 )
          return v17;
        if ( v16 < 0 )
          return -14;
      }
      else
      {
        v13 = *(_DWORD *)(v3 + 4);
        if ( *(_DWORD *)(v3 + 16) < v13 )
          v13 = *(_DWORD *)(v3 + 16);
        memcpy(*(void **)(v3 + 12), *(const void **)v3, v13);
        *(_DWORD *)v2 = sub_100245D0(*(unsigned int **)(v3 + 12), v13, *(_DWORD *)v2);
        *(_DWORD *)(v3 + 4) -= v13;
        *(_DWORD *)(v3 + 16) -= v13;
        *(_DWORD *)(v3 + 12) += v13;
        *(_DWORD *)v3 += v13;
        *(_DWORD *)(v3 + 20) += v13;
        *(_DWORD *)(v3 + 8) += v13;
        v17 += v13;
      }
      if ( !*(_DWORD *)(v3 + 16) )
        return v17;
      v6 = v18;
    }
  }
  return v17;
}

//----- (100392A0) --------------------------------------------------------
signed int __cdecl sub_100392A0(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ST04_4@4
  signed int v5; // eax@4
  signed int v6; // ebx@4
  bool v7; // zf@5

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    v4 = a1 + 88;
    *(_DWORD *)(v4 + 16) = a2;
    *(_DWORD *)(v4 + 20) = a3;
    v5 = sub_100390B0(a1, a1 + 88);
    v6 = v5;
    if ( v5 > 0 )
    {
      v7 = *(_DWORD *)(a1 + 112) == v5;
      *(_DWORD *)(a1 + 112) -= v5;
      if ( v7 && !(*(_BYTE *)a1 & 1) && !sub_10038400(a1) )
        v6 = -14;
    }
    result = v6;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10039300) --------------------------------------------------------
signed int __cdecl sub_10039300(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  unsigned int v4; // edx@4
  int v5; // ebx@4
  int v6; // esi@16
  int v7; // eax@17
  char v8; // [sp+4h] [bp-204h]@19

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return -6;
  v4 = *(_DWORD *)(a1 + 44);
  result = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 112);
  v5 = a2;
  if ( a3 == 1 )
  {
    v5 = result + a2;
  }
  else if ( a3 == 2 )
  {
    v5 = v4 + a2;
  }
  if ( v5 > v4 || v5 < 0 )
    return -15;
  if ( result == v5 )
    return result;
  if ( !v5 )
  {
    sub_10039060(a1);
    return 0;
  }
  if ( !*(_WORD *)(a1 + 30) && *(_BYTE *)a1 & 3 )
  {
    sub_100385F0(a1 + 116);
    *(_DWORD *)(a1 + 124) = v5;
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 44) - v5;
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 40) - v5;
    return v5;
  }
  if ( result > v5 )
  {
    sub_10039060(a1);
    result = 0;
  }
  v6 = v5 - result;
  if ( v5 - result <= 0 )
    return v5;
  while ( 1 )
  {
    v7 = 512;
    if ( (unsigned int)v6 < 0x200 )
      v7 = v6;
    result = sub_100392A0(a1, (int)&v8, v7);
    if ( result <= 0 )
      break;
    v6 -= result;
    if ( v6 <= 0 )
      return v5;
  }
  return result;
}

//----- (10039490) --------------------------------------------------------
signed int __usercall sub_10039490@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // edi@1
  signed int result; // eax@1
  int v5; // esi@1
  unsigned __int16 v6; // bx@2
  unsigned __int16 v7; // ax@2
  unsigned int v8; // ebx@2
  unsigned __int16 v9; // dx@2
  int v10; // edx@2
  int v11; // eax@2
  int v12; // esi@2
  unsigned int v13; // edx@2
  int v14; // eax@2
  int v15; // esi@2
  unsigned int v16; // ST2C_4@4
  unsigned int v17; // ST30_4@4
  unsigned int v18; // ST34_4@4
  unsigned int v19; // esi@4
  unsigned int v20; // ST2C_4@5
  unsigned int v21; // ST30_4@5
  unsigned int v22; // ST34_4@5
  unsigned int v23; // esi@5
  unsigned int v24; // ST30_4@6
  unsigned int v25; // ST34_4@6
  unsigned int v26; // edx@6
  unsigned int v27; // esi@6
  __int16 v28; // ST38_2@6
  unsigned int v29; // ST1C_4@6
  unsigned int v30; // ST20_4@6
  unsigned int v31; // ST24_4@6
  unsigned int v32; // esi@6
  unsigned int v33; // edx@6
  unsigned int v34; // ST30_4@6
  unsigned int v35; // ST34_4@6
  unsigned int v36; // esi@6
  unsigned int v37; // ST1C_4@6
  unsigned int v38; // ST20_4@6
  unsigned int v39; // ST24_4@6
  unsigned int v40; // esi@6
  unsigned int v41; // ST30_4@6
  unsigned int v42; // edx@6
  unsigned int v43; // ST34_4@6
  unsigned int v44; // esi@6
  unsigned int v45; // ST1C_4@6
  unsigned int v46; // ST20_4@6
  unsigned int v47; // ST24_4@6
  unsigned int v48; // esi@6
  unsigned int v49; // edx@6
  unsigned int v50; // ST30_4@6
  unsigned int v51; // ST34_4@6
  unsigned int v52; // esi@6
  unsigned int v53; // ST1C_4@6
  unsigned int v54; // ST20_4@6
  unsigned int v55; // ST24_4@6
  unsigned int v56; // ST28_4@6
  unsigned int v57; // ST30_4@6
  unsigned int v58; // edx@6
  unsigned int v59; // ST34_4@6
  unsigned int v60; // ST38_4@6
  unsigned int v61; // ST20_4@6
  unsigned int v62; // ST24_4@6
  unsigned int v63; // ebx@6
  unsigned int v64; // eax@6
  unsigned int v65; // [sp+14h] [bp-20h]@2
  unsigned int v66; // [sp+18h] [bp-1Ch]@2
  unsigned int v67; // [sp+1Ch] [bp-18h]@2
  unsigned int v68; // [sp+20h] [bp-14h]@2

  v3 = a1;
  result = 0;
  v5 = a2;
  if ( *(_BYTE *)(v3 + 260) & 1 )
  {
    BYTE1(result) = *(_BYTE *)(a2 + 3);
    HIBYTE(v6) = *(_BYTE *)(a2 + 7);
    LOBYTE(result) = *(_BYTE *)(a2 + 2);
    LOBYTE(v6) = *(_BYTE *)(a2 + 6);
    v65 = *(_DWORD *)v3 ^ (*(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (result << 8)) << 8));
    HIBYTE(v7) = *(_BYTE *)(a2 + 11);
    v8 = *(_DWORD *)(v3 + 4) ^ (*(_BYTE *)(a2 + 4) | ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8));
    LOBYTE(v7) = *(_BYTE *)(a2 + 10);
    v66 = v8;
    HIBYTE(v9) = *(_BYTE *)(a2 + 15);
    v67 = *(_DWORD *)(v3 + 8) ^ (*(_BYTE *)(v5 + 8) | ((*(_BYTE *)(v5 + 9) | (v7 << 8)) << 8));
    LOBYTE(v9) = *(_BYTE *)(v5 + 14);
    v10 = *(_BYTE *)(v5 + 13) | (v9 << 8);
    v11 = *(_BYTE *)(v5 + 12);
    v12 = *(_DWORD *)(v3 + 256);
    v13 = *(_DWORD *)(v3 + 12) ^ (v11 | (v10 << 8));
    v14 = v3 + 16 * (v12 - 9);
    v15 = v12 - 12;
    v68 = v13;
    if ( v15 )
    {
      if ( v15 != 2 )
      {
LABEL_6:
        v24 = *(_DWORD *)(v14 + 4) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v66] ^ *(_DWORD *)&dword_100B28B0[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v68 >> 16)];
        v25 = *(_DWORD *)(v14 + 8) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v66 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v68)];
        v26 = *(_DWORD *)v14 ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v13 >> 24)];
        v27 = *(_DWORD *)(v14 + 12) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v66 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v67 >> 24)];
        v28 = *(_WORD *)(v14 + 12) ^ dword_100B1CB0[2 * (unsigned __int8)v68] ^ dword_100B20B0[2 * BYTE1(v65)] ^ dword_100B24B0[2 * (unsigned __int8)(v66 >> 16)] ^ dword_100B28B0[2 * (v67 >> 24)];
        v29 = *(_DWORD *)(v14 + 16) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v26] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v24)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v25 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v27 >> 24)];
        v30 = *(_DWORD *)(v14 + 20) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v24] ^ *(_DWORD *)&dword_100B28B0[2 * (v26 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v25)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v27 >> 16)];
        v31 = *(_DWORD *)(v14 + 24) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v25] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v26 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v24 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * HIBYTE(v28)];
        v32 = *(_DWORD *)(v14 + 28) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v28] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v26)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v24 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v25 >> 24)];
        v33 = *(_DWORD *)(v14 + 32) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v29] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v30)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v31 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v32 >> 24)];
        v34 = *(_DWORD *)(v14 + 36) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v30] ^ *(_DWORD *)&dword_100B28B0[2 * (v29 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v31)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v32 >> 16)];
        v35 = *(_DWORD *)(v14 + 40) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v31] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v29 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v30 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v32)];
        v36 = *(_DWORD *)(v14 + 44) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v32] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v29)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v30 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v31 >> 24)];
        v37 = *(_DWORD *)(v14 + 48) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v33] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v34)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v35 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v36 >> 24)];
        v38 = *(_DWORD *)(v14 + 52) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v34] ^ *(_DWORD *)&dword_100B28B0[2 * (v33 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v35)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v36 >> 16)];
        v39 = *(_DWORD *)(v14 + 56) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v35] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v33 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v34 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v36)];
        v40 = *(_DWORD *)(v14 + 60) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v36] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v33)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v34 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v35 >> 24)];
        v41 = *(_DWORD *)(v14 + 68) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v38] ^ *(_DWORD *)&dword_100B28B0[2 * (v37 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v39)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v40 >> 16)];
        v42 = *(_DWORD *)(v14 + 64) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v37] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v38)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v39 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v40 >> 24)];
        v43 = *(_DWORD *)(v14 + 72) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v39] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v37 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v38 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v40)];
        v44 = *(_DWORD *)(v14 + 76) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v40] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v37)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v38 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v39 >> 24)];
        v45 = *(_DWORD *)(v14 + 80) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v42] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v41)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v43 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v44 >> 24)];
        v46 = *(_DWORD *)(v14 + 84) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v41] ^ *(_DWORD *)&dword_100B28B0[2 * (v42 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v43)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v44 >> 16)];
        v47 = *(_DWORD *)(v14 + 88) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v43] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v42 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v41 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v44)];
        v48 = *(_DWORD *)(v14 + 92) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v44] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v42)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v41 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v43 >> 24)];
        v49 = *(_DWORD *)(v14 + 96) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v45] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v46)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v47 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v48 >> 24)];
        v50 = *(_DWORD *)(v14 + 100) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v46] ^ *(_DWORD *)&dword_100B28B0[2 * (v45 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v47)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v48 >> 16)];
        v51 = *(_DWORD *)(v14 + 104) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v47] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v45 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v46 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v48)];
        v52 = *(_DWORD *)(v14 + 108) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v48] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v45)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v46 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v47 >> 24)];
        v53 = *(_DWORD *)(v14 + 112) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v49] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v50)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v51 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v52 >> 24)];
        v54 = *(_DWORD *)(v14 + 116) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v50] ^ *(_DWORD *)&dword_100B28B0[2 * (v49 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v51)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v52 >> 16)];
        v55 = *(_DWORD *)(v14 + 120) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v51] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v49 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v50 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v52)];
        v56 = *(_DWORD *)(v14 + 124) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v52] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v49)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v50 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v51 >> 24)];
        v57 = *(_DWORD *)(v14 + 132) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v54] ^ *(_DWORD *)&dword_100B28B0[2 * (v53 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v55)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v56 >> 16)];
        v58 = *(_DWORD *)(v14 + 128) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v53] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v54)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v55 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v56 >> 24)];
        v59 = *(_DWORD *)(v14 + 136) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v55] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v53 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v54 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v56)];
        v60 = *(_DWORD *)(v14 + 140) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v56] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v53)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v54 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v55 >> 24)];
        v61 = *(_DWORD *)(v14 + 148) ^ dword_100B2CB0[(unsigned __int8)v57] ^ dword_100B38B0[v58 >> 24] ^ dword_100B30B0[BYTE1(v59)] ^ dword_100B34B0[(unsigned __int8)(v60 >> 16)];
        v62 = *(_DWORD *)(v14 + 152) ^ dword_100B2CB0[(unsigned __int8)v59] ^ dword_100B34B0[(unsigned __int8)(v58 >> 16)] ^ dword_100B38B0[v57 >> 24] ^ dword_100B30B0[BYTE1(v60)];
        v63 = *(_DWORD *)(v14 + 156) ^ dword_100B2CB0[(unsigned __int8)v60] ^ dword_100B30B0[BYTE1(v58)] ^ dword_100B34B0[(unsigned __int8)(v57 >> 16)] ^ dword_100B38B0[v59 >> 24];
        v64 = *(_DWORD *)(v14 + 144) ^ dword_100B2CB0[(unsigned __int8)v58] ^ dword_100B30B0[BYTE1(v57)] ^ dword_100B34B0[(unsigned __int8)(v59 >> 16)] ^ dword_100B38B0[v60 >> 24];
        *(_BYTE *)(a3 + 1) = BYTE1(v64);
        *(_BYTE *)a3 = v64;
        *(_BYTE *)(a3 + 2) = v64 >> 16;
        *(_BYTE *)(a3 + 3) = BYTE3(v64);
        *(_BYTE *)(a3 + 5) = BYTE1(v61);
        *(_BYTE *)(a3 + 4) = v61;
        *(_BYTE *)(a3 + 7) = BYTE3(v61);
        *(_BYTE *)(a3 + 6) = v61 >> 16;
        *(_BYTE *)(a3 + 9) = BYTE1(v62);
        *(_BYTE *)(a3 + 8) = v62;
        *(_BYTE *)(a3 + 11) = BYTE3(v62);
        *(_BYTE *)(a3 + 10) = v62 >> 16;
        *(_BYTE *)(a3 + 12) = v63;
        *(_BYTE *)(a3 + 13) = BYTE1(v63);
        *(_BYTE *)(a3 + 15) = BYTE3(v63);
        *(_BYTE *)(a3 + 14) = v63 >> 16;
        return 1;
      }
      v16 = *(_DWORD *)(v14 - 64) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v13 >> 24)];
      v17 = *(_DWORD *)(v14 - 60) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100B28B0[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v13 >> 16)];
      v18 = *(_DWORD *)(v14 - 56) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v68)];
      v19 = *(_DWORD *)(v14 - 52) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v13] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v67 >> 24)];
      v8 = *(_DWORD *)(v14 - 44) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v17] ^ *(_DWORD *)&dword_100B28B0[2 * (v16 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v18)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v19 >> 16)];
      v67 = *(_DWORD *)(v14 - 40) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v18] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v16 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v17 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v19)];
      v65 = *(_DWORD *)(v14 - 48) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v16] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v17)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v18 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v19 >> 24)];
      v13 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v18 >> 24)];
      v68 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v18 >> 24)];
    }
    v20 = *(_DWORD *)(v14 - 32) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v13 >> 24)];
    v21 = *(_DWORD *)(v14 - 28) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100B28B0[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v68 >> 16)];
    v22 = *(_DWORD *)(v14 - 24) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v68)];
    v23 = *(_DWORD *)(v14 - 20) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v67 >> 24)];
    v8 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100B28B0[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v23 >> 16)];
    v67 = *(_DWORD *)(v14 - 8) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v22] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v20 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v21 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v23)];
    v65 = *(_DWORD *)(v14 - 16) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v20] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v21)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v22 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v23 >> 24)];
    v66 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100B28B0[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v23 >> 16)];
    v13 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v22 >> 24)];
    v68 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100B1CB0[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100B20B0[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100B24B0[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100B28B0[2 * (v22 >> 24)];
    goto LABEL_6;
  }
  return result;
}
// 100B2CB0: using guessed type int dword_100B2CB0[];
// 100B30B0: using guessed type int dword_100B30B0[];
// 100B34B0: using guessed type int dword_100B34B0[];
// 100B38B0: using guessed type int dword_100B38B0[];

//----- (1003A540) --------------------------------------------------------
int __usercall sub_1003A540@<eax>(int a1@<esi>, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@3
  bool v6; // zf@4

  result = *(_DWORD *)(a1 + 456);
  v4 = 0;
  if ( a3 )
  {
    do
    {
      if ( result == 16 )
      {
        v5 = 0;
        do
        {
          v6 = (*(_BYTE *)(v5 + a1))++ == -1;
          if ( !v6 )
            break;
          ++v5;
        }
        while ( v5 < 8 );
        sub_10039490(a1 + 32, a1, a1 + 16);
        result = 0;
      }
      *(_BYTE *)(v4++ + a2) ^= *(_BYTE *)(a1 + 16 + result++);
    }
    while ( v4 < a3 );
  }
  *(_DWORD *)(a1 + 456) = result;
  return result;
}

//----- (1003A5A0) --------------------------------------------------------
signed int __usercall sub_1003A5A0@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned __int16 v4; // dx@1
  int v5; // edx@1
  unsigned __int16 v6; // cx@1
  int v7; // esi@1
  int v8; // edi@1
  unsigned int v9; // ecx@1
  unsigned __int16 v10; // dx@2
  int v11; // edx@2
  int v12; // ebx@2
  int v13; // edx@3
  int v14; // ST20_4@3
  int v15; // edx@3
  int v16; // ST24_4@3
  int v17; // edx@3
  int v18; // ST28_4@3
  unsigned int v19; // edx@3
  int v20; // ebp@3
  int v21; // esi@3
  int v22; // edi@3
  unsigned int v23; // ecx@3
  int v24; // ST20_4@3
  int v25; // ebx@3
  unsigned int v26; // edx@3
  int v27; // ST28_4@3
  int v28; // ebp@3
  int v29; // esi@3
  int v30; // edi@3
  unsigned int v31; // ecx@3
  int v32; // ST10_4@3
  int v33; // ebx@3
  int v34; // ebp@3
  unsigned int v35; // edx@3
  int v36; // ST28_4@3
  int v37; // ST24_4@3
  int v38; // ebp@3
  int v39; // esi@3
  int v40; // edi@3
  unsigned int v41; // ecx@3
  int v42; // ebx@3
  unsigned int v43; // edx@3
  int v44; // ebp@3
  int v45; // esi@3
  int v46; // edi@3
  unsigned int v47; // ecx@3
  int v48; // ST10_4@3
  int v49; // ST20_4@3
  int v50; // ebp@3
  int v51; // ebx@3
  unsigned int v52; // edx@3
  int v53; // ST28_4@3
  int v54; // ST24_4@3
  int v55; // ebp@3
  int v56; // esi@3
  int v57; // edi@3
  unsigned int v58; // ecx@3
  int v59; // ebx@3
  unsigned int v60; // edx@3
  int v61; // ST28_4@3
  int v62; // ST24_4@3
  int v63; // ebp@3
  int v64; // esi@3
  int v65; // edi@3
  unsigned int v66; // ecx@3
  int v67; // ST10_4@3
  int v68; // ebx@3
  unsigned int v69; // edx@3
  int v70; // ebp@3
  int v71; // ebp@3
  int v72; // esi@3
  int v73; // edi@3
  signed int result; // eax@3
  int v75; // edx@4
  int v76; // ST20_4@4
  unsigned int v77; // edx@4
  int v78; // ebp@4
  int v79; // esi@4
  int v80; // edi@4
  int v81; // ecx@4
  unsigned int v82; // edx@4
  int v83; // ST20_4@4
  int v84; // ebp@4
  int v85; // esi@4
  int v86; // edi@4
  int v87; // ecx@4
  int v88; // ebx@4
  unsigned int v89; // edx@4
  int v90; // ebp@4
  int v91; // esi@4
  int v92; // edi@4
  int v93; // ecx@4
  unsigned int v94; // edx@4
  int v95; // ST20_4@4
  int v96; // ebp@4
  int v97; // esi@4
  int v98; // edi@4
  int v99; // ecx@4
  unsigned int v100; // edx@4
  int v101; // ST20_4@4
  int v102; // ST10_4@4
  int v103; // ebp@4
  int v104; // esi@4
  int v105; // edi@4
  int v106; // ST10_4@4
  int v107; // ecx@4
  unsigned int v108; // edx@4
  int v109; // ST20_4@4
  int v110; // ebp@4
  int v111; // esi@4
  int v112; // edi@4
  int v113; // ecx@4
  unsigned int v114; // edx@4
  int v115; // ST20_4@4
  int v116; // ebp@4
  int v117; // esi@4
  int v118; // edi@4
  int v119; // ecx@4
  unsigned int v120; // edx@4
  int v121; // ST10_4@4
  int v122; // ebp@4
  int v123; // ebp@4
  int v124; // esi@4
  int v125; // edi@4
  int v126; // ebp@5
  int v127; // esi@5
  int v128; // edi@5
  unsigned int v129; // ecx@5
  int v130; // edx@5
  int v131; // esi@5
  int v132; // edi@5
  unsigned int v133; // ecx@5
  int v134; // ebp@5
  int v135; // esi@5
  int v136; // edi@5
  unsigned int v137; // ecx@5
  int v138; // edx@5
  int v139; // esi@5
  int v140; // edi@5
  unsigned int v141; // ecx@5
  int v142; // ebp@5
  int v143; // esi@5
  int v144; // edi@5
  unsigned int v145; // ecx@5
  int v146; // edx@5
  int v147; // esi@5
  int v148; // edi@5
  unsigned int v149; // ecx@5
  int v150; // ebp@5
  int v151; // esi@5
  int v152; // edi@5
  unsigned int v153; // ecx@5
  int v154; // edx@5
  int v155; // esi@5
  int v156; // edi@5
  unsigned int v157; // ecx@5
  int v158; // ebp@5
  int v159; // esi@5
  int v160; // edi@5
  unsigned int v161; // ecx@5
  int v162; // edx@5
  int v163; // edx@5
  int v164; // esi@5
  int v165; // edi@5
  int v166; // [sp+10h] [bp-20h]@1

  *(_DWORD *)(a1 + 260) = 17;
  v3 = a2;
  HIBYTE(v4) = *(_BYTE *)(a2 + 3);
  LOBYTE(v4) = *(_BYTE *)(a2 + 2);
  v5 = *(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (v4 << 8)) << 8);
  *(_DWORD *)a1 = v5;
  HIBYTE(v6) = *(_BYTE *)(a2 + 7);
  v166 = v5;
  LOBYTE(v6) = *(_BYTE *)(a2 + 6);
  v7 = ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8) | *(_BYTE *)(a2 + 4);
  *(_DWORD *)(a1 + 4) = v7;
  HIBYTE(v6) = *(_BYTE *)(a2 + 11);
  LOBYTE(v6) = *(_BYTE *)(a2 + 10);
  v8 = ((*(_BYTE *)(v3 + 9) | (v6 << 8)) << 8) | *(_BYTE *)(v3 + 8);
  *(_DWORD *)(a1 + 8) = v8;
  HIBYTE(v6) = *(_BYTE *)(a2 + 15);
  LOBYTE(v6) = *(_BYTE *)(a2 + 14);
  v9 = *(_BYTE *)(v3 + 12) | ((*(_BYTE *)(v3 + 13) | (v6 << 8)) << 8);
  *(_DWORD *)(a1 + 12) = v9;
  if ( a3 == 16 )
  {
    v126 = v5 ^ dword_100B38B0[(unsigned __int8)v9] ^ dword_100B2CB0[BYTE1(v9)] ^ dword_100B30B0[(unsigned __int8)(v9 >> 16)] ^ dword_100B34B0[v9 >> 24] ^ 1;
    v127 = v126 ^ v7;
    *(_DWORD *)(a1 + 16) = v126;
    *(_DWORD *)(a1 + 20) = v127;
    v128 = v127 ^ v8;
    *(_DWORD *)(a1 + 24) = v128;
    v129 = v128 ^ v9;
    *(_DWORD *)(a1 + 28) = v129;
    v130 = v126 ^ dword_100B38B0[(unsigned __int8)v129] ^ dword_100B2CB0[BYTE1(v129)] ^ dword_100B30B0[(unsigned __int8)(v129 >> 16)] ^ dword_100B34B0[v129 >> 24] ^ 2;
    v131 = v130 ^ v127;
    *(_DWORD *)(a1 + 32) = v130;
    *(_DWORD *)(a1 + 36) = v131;
    v132 = v131 ^ v128;
    *(_DWORD *)(a1 + 40) = v132;
    v133 = v132 ^ v129;
    *(_DWORD *)(a1 + 44) = v133;
    v134 = v130 ^ dword_100B38B0[(unsigned __int8)v133] ^ dword_100B2CB0[BYTE1(v133)] ^ dword_100B30B0[(unsigned __int8)(v133 >> 16)] ^ dword_100B34B0[v133 >> 24] ^ 4;
    v135 = v134 ^ v131;
    v136 = v135 ^ v132;
    v137 = v136 ^ v133;
    *(_DWORD *)(a1 + 48) = v134;
    *(_DWORD *)(a1 + 52) = v135;
    *(_DWORD *)(a1 + 56) = v136;
    *(_DWORD *)(a1 + 60) = v137;
    v138 = v134 ^ dword_100B38B0[(unsigned __int8)v137] ^ dword_100B2CB0[BYTE1(v137)] ^ dword_100B30B0[(unsigned __int8)(v137 >> 16)] ^ dword_100B34B0[v137 >> 24] ^ 8;
    *(_DWORD *)(a1 + 64) = v138;
    v139 = v138 ^ v135;
    *(_DWORD *)(a1 + 68) = v139;
    v140 = v139 ^ v136;
    *(_DWORD *)(a1 + 72) = v140;
    v141 = v140 ^ v137;
    *(_DWORD *)(a1 + 76) = v141;
    v142 = v138 ^ dword_100B38B0[(unsigned __int8)v141] ^ dword_100B2CB0[BYTE1(v141)] ^ dword_100B30B0[(unsigned __int8)(v141 >> 16)] ^ dword_100B34B0[v141 >> 24] ^ 0x10;
    v143 = v142 ^ v139;
    v144 = v143 ^ v140;
    v145 = v144 ^ v141;
    *(_DWORD *)(a1 + 80) = v142;
    *(_DWORD *)(a1 + 84) = v143;
    *(_DWORD *)(a1 + 88) = v144;
    *(_DWORD *)(a1 + 92) = v145;
    v146 = v142 ^ dword_100B38B0[(unsigned __int8)v145] ^ dword_100B2CB0[BYTE1(v145)] ^ dword_100B30B0[(unsigned __int8)(v145 >> 16)] ^ dword_100B34B0[v145 >> 24] ^ 0x20;
    v147 = v146 ^ v143;
    v148 = v147 ^ v144;
    v149 = v148 ^ v145;
    *(_DWORD *)(a1 + 100) = v147;
    *(_DWORD *)(a1 + 104) = v148;
    *(_DWORD *)(a1 + 108) = v149;
    *(_DWORD *)(a1 + 96) = v146;
    v150 = v146 ^ dword_100B38B0[(unsigned __int8)v149] ^ dword_100B2CB0[BYTE1(v149)] ^ dword_100B30B0[(unsigned __int8)(v149 >> 16)] ^ dword_100B34B0[v149 >> 24] ^ 0x40;
    v151 = v150 ^ v147;
    v152 = v151 ^ v148;
    v153 = v152 ^ v149;
    *(_DWORD *)(a1 + 112) = v150;
    *(_DWORD *)(a1 + 116) = v151;
    *(_DWORD *)(a1 + 120) = v152;
    *(_DWORD *)(a1 + 124) = v153;
    v154 = v150 ^ dword_100B38B0[(unsigned __int8)v153] ^ dword_100B2CB0[BYTE1(v153)] ^ dword_100B30B0[(unsigned __int8)(v153 >> 16)] ^ dword_100B34B0[v153 >> 24] ^ 0x80;
    v155 = v154 ^ v151;
    *(_DWORD *)(a1 + 128) = v154;
    *(_DWORD *)(a1 + 132) = v155;
    v156 = v155 ^ v152;
    *(_DWORD *)(a1 + 136) = v156;
    v157 = v156 ^ v153;
    *(_DWORD *)(a1 + 140) = v157;
    v158 = v154 ^ dword_100B38B0[(unsigned __int8)v157] ^ dword_100B2CB0[BYTE1(v157)] ^ dword_100B30B0[(unsigned __int8)(v157 >> 16)] ^ dword_100B34B0[v157 >> 24] ^ 0x1B;
    v159 = v158 ^ v155;
    v160 = v159 ^ v156;
    v161 = v160 ^ v157;
    *(_DWORD *)(a1 + 148) = v159;
    *(_DWORD *)(a1 + 152) = v160;
    *(_DWORD *)(a1 + 144) = v158;
    *(_DWORD *)(a1 + 156) = v161;
    v162 = dword_100B38B0[(unsigned __int8)v161] ^ dword_100B2CB0[BYTE1(v161)] ^ dword_100B30B0[(unsigned __int8)(v161 >> 16)] ^ dword_100B34B0[v161 >> 24];
    *(_DWORD *)(a1 + 256) = 10;
    v163 = v158 ^ v162 ^ 0x36;
    v164 = v163 ^ v159;
    v165 = v164 ^ v160;
    *(_DWORD *)(a1 + 168) = v165;
    *(_DWORD *)(a1 + 164) = v164;
    *(_DWORD *)(a1 + 160) = v163;
    *(_DWORD *)(a1 + 172) = v165 ^ v161;
    result = 1;
  }
  else
  {
    HIBYTE(v10) = *(_BYTE *)(a2 + 19);
    LOBYTE(v10) = *(_BYTE *)(a2 + 18);
    v11 = v10 << 8;
    v12 = *(_BYTE *)(a2 + 17);
    if ( a3 == 24 )
    {
      v75 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v75;
      v76 = v75;
      BYTE1(v75) = *(_BYTE *)(a2 + 23);
      LOBYTE(v75) = *(_BYTE *)(a2 + 22);
      v77 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v75 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v77;
      v78 = v166 ^ dword_100B38B0[(unsigned __int8)v77] ^ dword_100B2CB0[BYTE1(v77)] ^ dword_100B30B0[(unsigned __int8)(v77 >> 16)] ^ dword_100B34B0[v77 >> 24] ^ 1;
      v79 = v78 ^ v7;
      v80 = v79 ^ v8;
      v81 = v80 ^ v9;
      *(_DWORD *)(a1 + 40) = v81 ^ v76;
      v82 = v81 ^ v76 ^ v77;
      v83 = v81 ^ v76;
      *(_DWORD *)(a1 + 36) = v81;
      *(_DWORD *)(a1 + 24) = v78;
      *(_DWORD *)(a1 + 28) = v79;
      *(_DWORD *)(a1 + 32) = v80;
      *(_DWORD *)(a1 + 44) = v82;
      v84 = v78 ^ dword_100B38B0[(unsigned __int8)v82] ^ dword_100B2CB0[BYTE1(v82)] ^ dword_100B30B0[(unsigned __int8)(v82 >> 16)] ^ dword_100B34B0[v82 >> 24] ^ 2;
      v85 = v84 ^ v79;
      v86 = v85 ^ v80;
      v87 = v86 ^ v81;
      v89 = v87 ^ v83 ^ v82;
      v88 = v87 ^ v83;
      *(_DWORD *)(a1 + 64) = v87 ^ v83;
      *(_DWORD *)(a1 + 48) = v84;
      *(_DWORD *)(a1 + 52) = v85;
      *(_DWORD *)(a1 + 56) = v86;
      *(_DWORD *)(a1 + 60) = v87;
      *(_DWORD *)(a1 + 68) = v89;
      v90 = v84 ^ dword_100B38B0[(unsigned __int8)v89] ^ dword_100B2CB0[BYTE1(v89)] ^ dword_100B30B0[(unsigned __int8)(v89 >> 16)] ^ dword_100B34B0[v89 >> 24] ^ 4;
      v91 = v90 ^ v85;
      v92 = v91 ^ v86;
      v93 = v92 ^ v87;
      *(_DWORD *)(a1 + 88) = v93 ^ v88;
      v94 = v93 ^ v88 ^ v89;
      v95 = v93 ^ v88;
      *(_DWORD *)(a1 + 84) = v93;
      *(_DWORD *)(a1 + 72) = v90;
      *(_DWORD *)(a1 + 76) = v91;
      *(_DWORD *)(a1 + 80) = v92;
      *(_DWORD *)(a1 + 92) = v94;
      v96 = v90 ^ dword_100B38B0[(unsigned __int8)v94] ^ dword_100B2CB0[BYTE1(v94)] ^ dword_100B30B0[(unsigned __int8)(v94 >> 16)] ^ dword_100B34B0[v94 >> 24] ^ 8;
      v97 = v96 ^ v91;
      v98 = v97 ^ v92;
      v99 = v98 ^ v93;
      *(_DWORD *)(a1 + 112) = v99 ^ v95;
      v100 = v99 ^ v95 ^ v94;
      v101 = v99 ^ v95;
      *(_DWORD *)(a1 + 108) = v99;
      v102 = v96;
      *(_DWORD *)(a1 + 96) = v96;
      *(_DWORD *)(a1 + 100) = v97;
      *(_DWORD *)(a1 + 104) = v98;
      *(_DWORD *)(a1 + 116) = v100;
      v103 = v96 ^ dword_100B38B0[(unsigned __int8)v100] ^ dword_100B2CB0[BYTE1(v100)] ^ dword_100B30B0[(unsigned __int8)(v100 >> 16)] ^ dword_100B34B0[v100 >> 24] ^ 0x10;
      v104 = v103 ^ v97;
      v105 = v104 ^ v98;
      v106 = v102 ^ dword_100B38B0[(unsigned __int8)v100] ^ dword_100B2CB0[BYTE1(v100)] ^ dword_100B30B0[(unsigned __int8)(v100 >> 16)] ^ dword_100B34B0[v100 >> 24] ^ 0x10;
      *(_DWORD *)(a1 + 120) = v103;
      *(_DWORD *)(a1 + 124) = v104;
      *(_DWORD *)(a1 + 128) = v105;
      v107 = v105 ^ v99;
      *(_DWORD *)(a1 + 136) = v107 ^ v101;
      v108 = v107 ^ v101 ^ v100;
      v109 = v107 ^ v101;
      *(_DWORD *)(a1 + 132) = v107;
      *(_DWORD *)(a1 + 140) = v108;
      v110 = v106 ^ dword_100B38B0[(unsigned __int8)v108] ^ dword_100B2CB0[BYTE1(v108)] ^ dword_100B30B0[(unsigned __int8)(v108 >> 16)] ^ dword_100B34B0[v108 >> 24] ^ 0x20;
      v111 = v110 ^ v104;
      v112 = v111 ^ v105;
      v113 = v112 ^ v107;
      *(_DWORD *)(a1 + 160) = v113 ^ v109;
      v114 = v113 ^ v109 ^ v108;
      v115 = v113 ^ v109;
      *(_DWORD *)(a1 + 156) = v113;
      *(_DWORD *)(a1 + 144) = v110;
      *(_DWORD *)(a1 + 148) = v111;
      *(_DWORD *)(a1 + 152) = v112;
      *(_DWORD *)(a1 + 164) = v114;
      v116 = v110 ^ dword_100B38B0[(unsigned __int8)v114] ^ dword_100B2CB0[BYTE1(v114)] ^ dword_100B30B0[(unsigned __int8)(v114 >> 16)] ^ dword_100B34B0[v114 >> 24] ^ 0x40;
      v117 = v116 ^ v111;
      v118 = v117 ^ v112;
      v119 = v118 ^ v113;
      v120 = v119 ^ v115 ^ v114;
      *(_DWORD *)(a1 + 180) = v119;
      *(_DWORD *)(a1 + 184) = v119 ^ v115;
      v121 = v116;
      *(_DWORD *)(a1 + 168) = v116;
      *(_DWORD *)(a1 + 172) = v117;
      *(_DWORD *)(a1 + 176) = v118;
      *(_DWORD *)(a1 + 188) = v120;
      v122 = dword_100B38B0[(unsigned __int8)v120] ^ dword_100B2CB0[BYTE1(v120)] ^ dword_100B30B0[(unsigned __int8)(v120 >> 16)] ^ dword_100B34B0[v120 >> 24];
      *(_DWORD *)(a1 + 256) = 12;
      v123 = v121 ^ v122 ^ 0x80;
      v124 = v123 ^ v117;
      v125 = v124 ^ v118;
      *(_DWORD *)(a1 + 200) = v125;
      *(_DWORD *)(a1 + 196) = v124;
      *(_DWORD *)(a1 + 192) = v123;
      *(_DWORD *)(a1 + 204) = v125 ^ v119;
      result = 1;
    }
    else
    {
      v13 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v13;
      v14 = v13;
      BYTE1(v13) = *(_BYTE *)(a2 + 23);
      LOBYTE(v13) = *(_BYTE *)(a2 + 22);
      v15 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v13 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v15;
      v16 = v15;
      BYTE1(v15) = *(_BYTE *)(a2 + 27);
      LOBYTE(v15) = *(_BYTE *)(a2 + 26);
      v17 = *(_BYTE *)(a2 + 24) | ((*(_BYTE *)(a2 + 25) | ((unsigned __int16)v15 << 8)) << 8);
      *(_DWORD *)(a1 + 24) = v17;
      v18 = v17;
      BYTE1(v17) = *(_BYTE *)(a2 + 31);
      LOBYTE(v17) = *(_BYTE *)(a2 + 30);
      v19 = *(_BYTE *)(a2 + 28) | ((*(_BYTE *)(a2 + 29) | ((unsigned __int16)v17 << 8)) << 8);
      *(_DWORD *)(a1 + 28) = v19;
      v20 = v166 ^ dword_100B38B0[(unsigned __int8)v19] ^ dword_100B2CB0[BYTE1(v19)] ^ dword_100B30B0[(unsigned __int8)(v19 >> 16)] ^ dword_100B34B0[v19 >> 24] ^ 1;
      v21 = v20 ^ v7;
      v22 = v21 ^ v8;
      v23 = v22 ^ v9;
      *(_DWORD *)(a1 + 32) = v20;
      *(_DWORD *)(a1 + 36) = v21;
      *(_DWORD *)(a1 + 40) = v22;
      *(_DWORD *)(a1 + 44) = v23;
      v24 = dword_100B2CB0[(unsigned __int8)v23] ^ dword_100B30B0[BYTE1(v23)] ^ dword_100B34B0[(unsigned __int8)(v23 >> 16)] ^ dword_100B38B0[v23 >> 24] ^ v14;
      *(_DWORD *)(a1 + 48) = v24;
      v25 = v24 ^ v16 ^ v18;
      v26 = v25 ^ v19;
      *(_DWORD *)(a1 + 56) = v25;
      v27 = v24 ^ v16 ^ v18;
      *(_DWORD *)(a1 + 52) = v24 ^ v16;
      *(_DWORD *)(a1 + 60) = v26;
      v28 = v20 ^ dword_100B38B0[(unsigned __int8)v26] ^ dword_100B2CB0[BYTE1(v26)] ^ dword_100B30B0[(unsigned __int8)(v26 >> 16)] ^ dword_100B34B0[v26 >> 24] ^ 2;
      v29 = v28 ^ v21;
      *(_DWORD *)(a1 + 64) = v28;
      v30 = v29 ^ v22;
      v31 = v30 ^ v23;
      *(_DWORD *)(a1 + 76) = v31;
      v32 = v28;
      *(_DWORD *)(a1 + 68) = v29;
      *(_DWORD *)(a1 + 72) = v30;
      v33 = dword_100B2CB0[(unsigned __int8)v31] ^ dword_100B30B0[BYTE1(v31)] ^ dword_100B34B0[(unsigned __int8)(v31 >> 16)] ^ dword_100B38B0[v31 >> 24] ^ v24;
      v34 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 80) = v33;
      *(_DWORD *)(a1 + 88) = v34 ^ v27;
      v35 = v34 ^ v27 ^ v26;
      v36 = v34 ^ v27;
      v37 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 84) = v34;
      *(_DWORD *)(a1 + 92) = v35;
      v38 = v32 ^ dword_100B38B0[(unsigned __int8)v35] ^ dword_100B2CB0[BYTE1(v35)] ^ dword_100B30B0[(unsigned __int8)(v35 >> 16)] ^ dword_100B34B0[v35 >> 24] ^ 4;
      v39 = v38 ^ v29;
      *(_DWORD *)(a1 + 96) = v38;
      *(_DWORD *)(a1 + 100) = v39;
      v40 = v39 ^ v30;
      v41 = v40 ^ v31;
      *(_DWORD *)(a1 + 108) = v41;
      *(_DWORD *)(a1 + 104) = v40;
      v42 = dword_100B2CB0[(unsigned __int8)v41] ^ dword_100B30B0[BYTE1(v41)] ^ dword_100B34B0[(unsigned __int8)(v41 >> 16)] ^ dword_100B38B0[v41 >> 24] ^ v33;
      *(_DWORD *)(a1 + 112) = v42;
      v43 = v42 ^ v37 ^ v36 ^ v35;
      *(_DWORD *)(a1 + 120) = v42 ^ v37 ^ v36;
      *(_DWORD *)(a1 + 116) = v42 ^ v37;
      *(_DWORD *)(a1 + 124) = v43;
      v44 = v38 ^ dword_100B38B0[(unsigned __int8)v43] ^ dword_100B2CB0[BYTE1(v43)] ^ dword_100B30B0[(unsigned __int8)(v43 >> 16)] ^ dword_100B34B0[v43 >> 24] ^ 8;
      v45 = v44 ^ v39;
      v46 = v45 ^ v40;
      v47 = v46 ^ v41;
      *(_DWORD *)(a1 + 128) = v44;
      *(_DWORD *)(a1 + 132) = v45;
      *(_DWORD *)(a1 + 136) = v46;
      *(_DWORD *)(a1 + 140) = v47;
      v48 = v44;
      v49 = dword_100B2CB0[(unsigned __int8)v47] ^ dword_100B30B0[BYTE1(v47)] ^ dword_100B34B0[(unsigned __int8)(v47 >> 16)] ^ dword_100B38B0[v47 >> 24] ^ v42;
      *(_DWORD *)(a1 + 144) = v49;
      v50 = v49 ^ v42 ^ v37;
      v51 = v50 ^ v42 ^ v37 ^ v36;
      v52 = v51 ^ v43;
      *(_DWORD *)(a1 + 152) = v51;
      v53 = v51;
      *(_DWORD *)(a1 + 148) = v50;
      v54 = v50;
      *(_DWORD *)(a1 + 156) = v52;
      v55 = v48 ^ dword_100B38B0[(unsigned __int8)v52] ^ dword_100B2CB0[BYTE1(v52)] ^ dword_100B30B0[(unsigned __int8)(v52 >> 16)] ^ dword_100B34B0[v52 >> 24] ^ 0x10;
      v56 = v55 ^ v45;
      *(_DWORD *)(a1 + 160) = v55;
      v57 = v56 ^ v46;
      v58 = v57 ^ v47;
      *(_DWORD *)(a1 + 172) = v58;
      *(_DWORD *)(a1 + 164) = v56;
      *(_DWORD *)(a1 + 168) = v57;
      v59 = dword_100B2CB0[(unsigned __int8)v58] ^ dword_100B30B0[BYTE1(v58)] ^ dword_100B34B0[(unsigned __int8)(v58 >> 16)] ^ dword_100B38B0[v58 >> 24] ^ v49;
      *(_DWORD *)(a1 + 176) = v59;
      *(_DWORD *)(a1 + 184) = v59 ^ v54 ^ v53;
      v60 = v59 ^ v54 ^ v53 ^ v52;
      v61 = v59 ^ v54 ^ v53;
      v62 = v59 ^ v54;
      *(_DWORD *)(a1 + 180) = v62;
      *(_DWORD *)(a1 + 188) = v60;
      v63 = v55 ^ dword_100B38B0[(unsigned __int8)v60] ^ dword_100B2CB0[BYTE1(v60)] ^ dword_100B30B0[(unsigned __int8)(v60 >> 16)] ^ dword_100B34B0[v60 >> 24] ^ 0x20;
      v64 = v63 ^ v56;
      *(_DWORD *)(a1 + 192) = v63;
      v65 = v64 ^ v57;
      v66 = v65 ^ v58;
      *(_DWORD *)(a1 + 204) = v66;
      v67 = v63;
      *(_DWORD *)(a1 + 196) = v64;
      *(_DWORD *)(a1 + 200) = v65;
      v68 = dword_100B2CB0[(unsigned __int8)v66] ^ dword_100B30B0[BYTE1(v66)] ^ dword_100B34B0[(unsigned __int8)(v66 >> 16)] ^ dword_100B38B0[v66 >> 24] ^ v59;
      *(_DWORD *)(a1 + 208) = v68;
      *(_DWORD *)(a1 + 216) = v68 ^ v62 ^ v61;
      v69 = v68 ^ v62 ^ v61 ^ v60;
      *(_DWORD *)(a1 + 212) = v68 ^ v62;
      *(_DWORD *)(a1 + 220) = v69;
      v70 = dword_100B38B0[(unsigned __int8)v69] ^ dword_100B2CB0[BYTE1(v69)] ^ dword_100B30B0[(unsigned __int8)(v69 >> 16)] ^ dword_100B34B0[v69 >> 24];
      *(_DWORD *)(a1 + 256) = 14;
      v71 = v67 ^ v70 ^ 0x40;
      v72 = v71 ^ v64;
      v73 = v72 ^ v65;
      *(_DWORD *)(a1 + 232) = v73;
      *(_DWORD *)(a1 + 228) = v72;
      *(_DWORD *)(a1 + 224) = v71;
      *(_DWORD *)(a1 + 236) = v73 ^ v66;
      result = 1;
    }
  }
  return result;
}
// 100B2CB0: using guessed type int dword_100B2CB0[];
// 100B30B0: using guessed type int dword_100B30B0[];
// 100B34B0: using guessed type int dword_100B34B0[];
// 100B38B0: using guessed type int dword_100B38B0[];

//----- (1003B320) --------------------------------------------------------
void *__usercall sub_1003B320@<eax>(void *a1@<eax>)
{
  return memset(a1, 0, 0xA0u);
}

//----- (1003B340) --------------------------------------------------------
unsigned int __cdecl sub_1003B340(int a1, unsigned int a2)
{
  int v2; // eax@1
  unsigned int result; // eax@1
  _BYTE *v4; // ecx@3
  char v5; // dl@3
  unsigned __int64 v6; // [sp+Ch] [bp-8h]@1

  v2 = sub_100247C0();
  v6 = ((unsigned __int64)(unsigned int)v2 << 32) + (unsigned int)j_TSK_pvg_get_us_timer();
  result = 0;
  do
  {
    if ( result >= a2 )
      break;
    v4 = (_BYTE *)(result + a1);
    v5 = *((_BYTE *)&v6 + result++ + a1 - a1);
    *v4 = v5;
  }
  while ( result < 8 );
  return result;
}
// 10024810: using guessed type int j_TSK_pvg_get_us_timer(void);

//----- (1003B3A0) --------------------------------------------------------
int __usercall sub_1003B3A0@<eax>(int result@<eax>)
{
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 8) = 1732584193;
  *(_DWORD *)(result + 12) = -271733879;
  *(_DWORD *)(result + 16) = -1732584194;
  *(_DWORD *)(result + 20) = 271733878;
  *(_DWORD *)(result + 24) = -1009589776;
  return result;
}

//----- (1003B3E0) --------------------------------------------------------
int __usercall sub_1003B3E0@<eax>(int result@<eax>)
{
  int v1; // ebx@1
  int v2; // esi@1
  int v3; // edx@1
  unsigned int v4; // ST28_4@1
  int v5; // edx@1
  int v6; // ST18_4@1
  unsigned int v7; // ST2C_4@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // ST14_4@1
  int v12; // ST20_4@1
  unsigned int v13; // ST30_4@1
  int v14; // esi@1
  unsigned int v15; // ST34_4@1
  int v16; // edi@1
  int v17; // edi@1
  int v18; // ecx@1
  int v19; // ST1C_4@1
  int v20; // ebx@1
  unsigned int v21; // ebp@1
  unsigned int v22; // ST38_4@1
  int v23; // edx@1
  int v24; // ST10_4@1
  unsigned int v25; // ST3C_4@1
  int v26; // esi@1
  int v27; // esi@1
  int v28; // ST18_4@1
  int v29; // ebp@1
  unsigned int v30; // ST40_4@1
  int v31; // edi@1
  int v32; // ebx@1
  int v33; // ST14_4@1
  unsigned int v34; // ST44_4@1
  int v35; // edi@1
  int v36; // ST20_4@1
  int v37; // ST1C_4@1
  unsigned int v38; // ST48_4@1
  int v39; // ebx@1
  int v40; // ebx@1
  int v41; // ecx@1
  int v42; // ebp@1
  unsigned int v43; // ST4C_4@1
  int v44; // edx@1
  int v45; // edx@1
  int v46; // ST10_4@1
  int v47; // esi@1
  unsigned int v48; // ST50_4@1
  int v49; // esi@1
  int v50; // ST18_4@1
  unsigned int v51; // ST54_4@1
  int v52; // edi@1
  int v53; // ebx@1
  int v54; // ST14_4@1
  unsigned int v55; // ST58_4@1
  int v56; // edi@1
  int v57; // ST20_4@1
  int v58; // ebx@1
  unsigned int v59; // ST5C_4@1
  int v60; // ebx@1
  int v61; // ecx@1
  int v62; // ST14_4@1
  int v63; // ST1C_4@1
  unsigned int v64; // ST60_4@1
  int v65; // edx@1
  int v66; // edx@1
  int v67; // ST10_4@1
  unsigned int v68; // ST64_4@1
  int v69; // esi@1
  int v70; // esi@1
  int v71; // ST18_4@1
  int v72; // ebp@1
  int v73; // ecx@1
  int v74; // ebx@1
  int v75; // ST68_4@1
  int v76; // edi@1
  int v77; // edi@1
  int v78; // ST14_4@1
  int v79; // ST20_4@1
  int v80; // ecx@1
  int v81; // ST6C_4@1
  int v82; // edi@1
  int v83; // ecx@1
  int v84; // ST70_4@1
  int v85; // ebx@1
  int v86; // ST1C_4@1
  int v87; // ebx@1
  int v88; // ecx@1
  int v89; // ST14_4@1
  int v90; // ecx@1
  int v91; // ST74_4@1
  int v92; // edx@1
  int v93; // edx@1
  int v94; // ST10_4@1
  int v95; // ecx@1
  int v96; // ST78_4@1
  int v97; // esi@1
  int v98; // esi@1
  int v99; // ST18_4@1
  int v100; // ebx@1
  int v101; // ecx@1
  int v102; // edi@1
  int v103; // ST7C_4@1
  int v104; // edi@1
  int v105; // ST20_4@1
  int v106; // ecx@1
  int v107; // ST80_4@1
  int v108; // edx@1
  int v109; // edx@1
  int v110; // ecx@1
  int v111; // ST84_4@1
  int v112; // ebx@1
  int v113; // ebx@1
  int v114; // ST14_4@1
  int v115; // ecx@1
  int v116; // ebp@1
  int v117; // ST88_4@1
  int v118; // edi@1
  int v119; // edi@1
  int v120; // ST10_4@1
  int v121; // ebp@1
  int v122; // ecx@1
  int v123; // ST8C_4@1
  int v124; // edx@1
  int v125; // ebp@1
  int v126; // edx@1
  int v127; // ecx@1
  int v128; // ST18_4@1
  int v129; // ST90_4@1
  int v130; // esi@1
  int v131; // esi@1
  int v132; // ST20_4@1
  int v133; // ecx@1
  int v134; // ST94_4@1
  int v135; // edi@1
  int v136; // edi@1
  int v137; // ecx@1
  int v138; // ST98_4@1
  int v139; // ebx@1
  int v140; // ebx@1
  int v141; // ST14_4@1
  int v142; // ecx@1
  int v143; // ebp@1
  int v144; // ST9C_4@1
  int v145; // esi@1
  int v146; // esi@1
  int v147; // ST10_4@1
  int v148; // ebp@1
  int v149; // ecx@1
  int v150; // STA0_4@1
  int v151; // edi@1
  int v152; // ebp@1
  int v153; // edx@1
  int v154; // ecx@1
  int v155; // ST18_4@1
  int v156; // STA4_4@1
  int v157; // edi@1
  int v158; // edi@1
  int v159; // ST20_4@1
  int v160; // ecx@1
  int v161; // STA8_4@1
  int v162; // esi@1
  int v163; // esi@1
  int v164; // ecx@1
  int v165; // STAC_4@1
  int v166; // ebx@1
  int v167; // ebx@1
  int v168; // ST14_4@1
  int v169; // ecx@1
  int v170; // ebp@1
  int v171; // STB0_4@1
  int v172; // edi@1
  int v173; // edi@1
  int v174; // ST10_4@1
  int v175; // ebp@1
  int v176; // ecx@1
  int v177; // STB4_4@1
  int v178; // esi@1
  int v179; // ebp@1
  int v180; // edx@1
  int v181; // ST18_4@1
  int v182; // ecx@1
  int v183; // STB8_4@1
  int v184; // esi@1
  int v185; // ebx@1
  int v186; // ST20_4@1
  int v187; // esi@1
  int v188; // ecx@1
  int v189; // STBC_4@1
  int v190; // edi@1
  int v191; // edi@1
  int v192; // ST1C_4@1
  int v193; // ecx@1
  int v194; // ebp@1
  int v195; // STC0_4@1
  int v196; // edx@1
  int v197; // ecx@1
  int v198; // esi@1
  int v199; // STC4_4@1
  int v200; // ebp@1
  int v201; // esi@1
  int v202; // ST10_4@1
  int v203; // ecx@1
  int v204; // ebp@1
  int v205; // edi@1
  int v206; // STC8_4@1
  int v207; // ST1C_4@1
  int v208; // ecx@1
  int v209; // STCC_4@1
  int v210; // ebx@1
  int v211; // ST18_4@1
  int v212; // ecx@1
  int v213; // STD0_4@1
  int v214; // edx@1
  int v215; // edi@1
  int v216; // ebx@1
  int v217; // ecx@1
  int v218; // edx@1
  int v219; // ebx@1
  int v220; // ecx@1
  int v221; // ST1C_4@1
  int v222; // ebp@1
  int v223; // STD4_4@1
  int v224; // ST10_4@1
  int v225; // edx@1
  int v226; // ecx@1
  int v227; // ST14_4@1
  int v228; // STD8_4@1
  int v229; // ebp@1
  int v230; // ebx@1
  int v231; // ecx@1
  int v232; // esi@1
  int v233; // ST10_4@1
  int v234; // ecx@1
  int v235; // STDC_4@1
  int v236; // edi@1
  int v237; // ebx@1
  int v238; // ecx@1
  int v239; // edi@1
  int v240; // STE0_4@1
  int v241; // ebx@1
  int v242; // ST18_4@1
  int v243; // ST1C_4@1
  int v244; // ecx@1
  int v245; // edx@1
  int v246; // STE4_4@1
  int v247; // edi@1
  int v248; // ebx@1
  int v249; // ecx@1
  int v250; // edx@1
  int v251; // ebx@1
  int v252; // ecx@1
  int v253; // ST1C_4@1
  int v254; // ebp@1
  int v255; // STE8_4@1
  int v256; // ST10_4@1
  int v257; // edx@1
  int v258; // ecx@1
  int v259; // ebx@1
  int v260; // ST14_4@1
  int v261; // STEC_4@1
  int v262; // ebp@1
  int v263; // ecx@1
  int v264; // esi@1
  int v265; // ST10_4@1
  int v266; // ecx@1
  int v267; // edi@1
  int v268; // STF0_4@1
  int v269; // ebx@1
  int v270; // edi@1
  int v271; // ecx@1
  int v272; // ebx@1
  int v273; // STF4_4@1
  int v274; // ST1C_4@1
  int v275; // ST18_4@1
  int v276; // ecx@1
  int v277; // edx@1
  int v278; // edi@1
  int v279; // STF8_4@1
  int v280; // ebx@1
  int v281; // ecx@1
  int v282; // edx@1
  int v283; // ST1C_4@1
  int v284; // ecx@1
  int v285; // ST10_4@1
  int v286; // STFC_4@1
  int v287; // ebp@1
  int v288; // edx@1
  int v289; // ecx@1
  int v290; // ST100_4@1
  int v291; // ST14_4@1
  int v292; // ebp@1
  int v293; // ebx@1
  int v294; // ecx@1
  int v295; // esi@1
  int v296; // ST10_4@1
  int v297; // ecx@1
  int v298; // edi@1
  int v299; // ST104_4@1
  int v300; // ebx@1
  int v301; // edi@1
  int v302; // ecx@1
  int v303; // ebx@1
  int v304; // ST108_4@1
  int v305; // ST1C_4@1
  int v306; // ST18_4@1
  int v307; // ecx@1
  int v308; // edi@1
  int v309; // ST10C_4@1
  int v310; // ebx@1
  int v311; // edx@1
  int v312; // ecx@1
  int v313; // ST1C_4@1
  int v314; // ecx@1
  int v315; // ST110_4@1
  int v316; // ebp@1
  int v317; // ebx@1
  int v318; // edx@1
  int v319; // ecx@1
  int v320; // ST114_4@1
  int v321; // ST14_4@1
  int v322; // ebp@1
  int v323; // edi@1
  int v324; // ecx@1
  int v325; // edx@1
  int v326; // ebp@1
  int v327; // ST118_4@1
  int v328; // esi@1
  int v329; // ST10_4@1
  int v330; // ecx@1
  int v331; // ST18_4@1
  int v332; // ST11C_4@1
  int v333; // ebx@1
  int v334; // esi@1
  int v335; // edi@1
  int v336; // edi@1
  int v337; // ST20_4@1
  int v338; // ebx@1
  int v339; // ecx@1
  int v340; // edx@1
  int v341; // ST120_4@1
  int v342; // edx@1
  int v343; // ecx@1
  int v344; // ST124_4@1
  int v345; // ebx@1
  int v346; // ebx@1
  int v347; // ecx@1
  int v348; // ST14_4@1
  int v349; // ST128_4@1
  int v350; // ebp@1
  int v351; // edi@1
  int v352; // edi@1
  int v353; // ecx@1
  int v354; // ST10_4@1
  int v355; // ST12C_4@1
  int v356; // ebp@1
  int v357; // edx@1
  int v358; // ST18_4@1
  int v359; // ecx@1
  int v360; // ST130_4@1
  int v361; // edx@1
  int v362; // esi@1
  int v363; // esi@1
  int v364; // ST20_4@1
  int v365; // ecx@1
  int v366; // ebx@1
  int v367; // edi@1
  int v368; // ST134_4@1
  int v369; // edi@1
  int v370; // ecx@1
  int v371; // ebp@1
  int v372; // ST138_4@1
  int v373; // ebx@1
  int v374; // ebx@1
  int v375; // ecx@1
  int v376; // ST14_4@1
  int v377; // ST13C_4@1
  int v378; // ebp@1
  int v379; // esi@1
  int v380; // esi@1
  int v381; // ecx@1
  int v382; // ST10_4@1
  int v383; // ST140_4@1
  int v384; // ebp@1
  int v385; // edi@1
  int v386; // edi@1
  int v387; // ecx@1
  int v388; // ebp@1
  int v389; // edx@1
  int v390; // ST18_4@1
  int v391; // ebx@1
  int v392; // ST20_4@1
  int v393; // edx@1
  int v394; // ST14_4@1
  int v395; // esi@1
  int v396; // ST148_4@1
  int v397; // ST10_4@1
  int v398; // ST1C_4@1
  int v399; // edx@1
  int v400; // ebx@1
  int v401; // ST14C_4@1
  int v402; // esi@1
  int v403; // ebx@1
  int v404; // ST18_4@1
  int v405; // ST14_4@1
  int v406; // edx@1
  int v407; // edi@1
  int v408; // esi@1
  int v409; // ebx@1
  int v410; // ST20_4@1
  int v411; // esi@1
  int v412; // ST10_4@1
  int v413; // ebx@1
  int v414; // edi@1
  int v415; // ebp@1
  int v416; // edi@1
  int v417; // ST24_4@1
  int v418; // ST1C_4@1
  int v419; // edi@1
  int v420; // ebx@1
  int v421; // ST20_4@1
  int v422; // edx@1
  int v423; // ebx@1
  int v424; // edx@1
  int v425; // ebx@1
  int v426; // ST1C_4@1
  int v427; // esi@1
  int v428; // ebx@1
  int v429; // esi@1
  int v430; // ecx@1
  int v431; // ebx@1
  int v432; // ebx@1
  int v433; // edx@1
  int v434; // ecx@1

  v1 = *(_DWORD *)(result + 8);
  v2 = *(_DWORD *)(result + 12);
  v3 = __ROL4__(*(_DWORD *)(result + 8), 5);
  v4 = ((*(_DWORD *)(result + 28) & 0xFF00 | (*(_DWORD *)(result + 28) << 16)) << 8) | (((*(_DWORD *)(result + 28) >> 16) | *(_DWORD *)(result + 28) & 0xFF0000u) >> 8);
  v5 = v4
     + *(_DWORD *)(result + 24)
     + v3
     + (v2 & *(_DWORD *)(result + 16) ^ *(_DWORD *)(result + 20) & ~*(_DWORD *)(result + 12))
     + 1518500249;
  v2 = __ROR4__(v2, 2);
  v6 = v2;
  v7 = ((*(_DWORD *)(result + 32) & 0xFF00 | (*(_DWORD *)(result + 32) << 16)) << 8) | (((*(_DWORD *)(result + 32) >> 16) | *(_DWORD *)(result + 32) & 0xFF0000u) >> 8);
  v8 = v1 & v2 ^ *(_DWORD *)(result + 16) & ~v1;
  v9 = __ROL4__(v5, 5);
  v10 = *(_DWORD *)(result + 20) + v7 + v9 + v8 + 1518500249;
  v1 = __ROR4__(v1, 2);
  v11 = v10;
  v10 = __ROL4__(v10, 5);
  v12 = v1;
  v13 = ((*(_DWORD *)(result + 36) & 0xFF00 | (*(_DWORD *)(result + 36) << 16)) << 8) | (((*(_DWORD *)(result + 36) >> 16) | *(_DWORD *)(result + 36) & 0xFF0000u) >> 8);
  v14 = *(_DWORD *)(result + 16) + v13 + v10 + (v1 & v5 ^ v6 & ~v5) + 1518500249;
  v5 = __ROR4__(v5, 2);
  v15 = ((*(_DWORD *)(result + 40) & 0xFF00 | (*(_DWORD *)(result + 40) << 16)) << 8) | (((*(_DWORD *)(result + 40) >> 16) | *(_DWORD *)(result + 40) & 0xFF0000u) >> 8);
  v16 = __ROL4__(v14, 5);
  v17 = v6 + v15 + v16 + (v11 & v5 ^ v1 & ~v11) + 1518500249;
  v18 = __ROR4__(v11, 2);
  v19 = v5;
  v20 = __ROL4__(v17, 5);
  v21 = (((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8))
      + v20
      + (v14 & v18 ^ v5 & ~v14);
  v22 = ((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8);
  v14 = __ROR4__(v14, 2);
  v23 = v12 + v21 + 1518500249;
  v24 = v14;
  v25 = ((*(_DWORD *)(result + 48) & 0xFF00 | (*(_DWORD *)(result + 48) << 16)) << 8) | (((*(_DWORD *)(result + 48) >> 16) | *(_DWORD *)(result + 48) & 0xFF0000u) >> 8);
  v26 = __ROL4__(v23, 5);
  v27 = v19 + v25 + v26 + (v17 & v24 ^ v18 & ~v17) + 1518500249;
  v17 = __ROR4__(v17, 2);
  v28 = v17;
  v29 = v23 & v17;
  v30 = ((*(_DWORD *)(result + 52) & 0xFF00 | (*(_DWORD *)(result + 52) << 16)) << 8) | (((*(_DWORD *)(result + 52) >> 16) | *(_DWORD *)(result + 52) & 0xFF0000u) >> 8);
  v31 = __ROL4__(v27, 5);
  v32 = v18 + v30 + v31 + (v29 ^ v24 & ~v23) + 1518500249;
  v23 = __ROR4__(v23, 2);
  v33 = v32;
  v32 = __ROL4__(v32, 5);
  v34 = ((*(_DWORD *)(result + 56) & 0xFF00 | (*(_DWORD *)(result + 56) << 16)) << 8) | (((*(_DWORD *)(result + 56) >> 16) | *(_DWORD *)(result + 56) & 0xFF0000u) >> 8);
  v35 = v24 + v34 + v32 + (v23 & v27 ^ v28 & ~v27) + 1518500249;
  v27 = __ROR4__(v27, 2);
  v36 = v23;
  v37 = v27;
  v38 = ((*(_DWORD *)(result + 60) & 0xFF00 | (*(_DWORD *)(result + 60) << 16)) << 8) | (((*(_DWORD *)(result + 60) >> 16) | *(_DWORD *)(result + 60) & 0xFF0000u) >> 8);
  v39 = __ROL4__(v35, 5);
  v40 = v28 + v38 + v39 + (v33 & v27 ^ v23 & ~v33) + 1518500249;
  v41 = __ROR4__(v33, 2);
  v42 = v35 & v41 ^ v27 & ~v35;
  v43 = ((*(_DWORD *)(result + 64) & 0xFF00 | (*(_DWORD *)(result + 64) << 16)) << 8) | (((*(_DWORD *)(result + 64) >> 16) | *(_DWORD *)(result + 64) & 0xFF0000u) >> 8);
  v44 = __ROL4__(v40, 5);
  v35 = __ROR4__(v35, 2);
  v45 = v36 + v43 + v44 + v42 + 1518500249;
  v46 = v35;
  v47 = __ROL4__(v45, 5);
  v48 = ((*(_DWORD *)(result + 68) & 0xFF00 | (*(_DWORD *)(result + 68) << 16)) << 8) | (((*(_DWORD *)(result + 68) >> 16) | *(_DWORD *)(result + 68) & 0xFF0000u) >> 8);
  v49 = v37 + v48 + v47 + (v40 & v35 ^ v41 & ~v40) + 1518500249;
  v40 = __ROR4__(v40, 2);
  v50 = v40;
  v51 = ((*(_DWORD *)(result + 72) & 0xFF00 | (*(_DWORD *)(result + 72) << 16)) << 8) | (((*(_DWORD *)(result + 72) >> 16) | *(_DWORD *)(result + 72) & 0xFF0000u) >> 8);
  v52 = __ROL4__(v49, 5);
  v53 = v41 + v51 + v52 + (v45 & v40 ^ v46 & ~v45) + 1518500249;
  v54 = v53;
  v45 = __ROR4__(v45, 2);
  v53 = __ROL4__(v53, 5);
  v55 = ((*(_DWORD *)(result + 76) & 0xFF00 | (*(_DWORD *)(result + 76) << 16)) << 8) | (((*(_DWORD *)(result + 76) >> 16) | *(_DWORD *)(result + 76) & 0xFF0000u) >> 8);
  v56 = v46 + v55 + v53 + (v45 & v49 ^ v50 & ~v49) + 1518500249;
  v49 = __ROR4__(v49, 2);
  v57 = v45;
  v58 = __ROL4__(v56, 5);
  v59 = ((*(_DWORD *)(result + 80) & 0xFF00 | (*(_DWORD *)(result + 80) << 16)) << 8) | (((*(_DWORD *)(result + 80) >> 16) | *(_DWORD *)(result + 80) & 0xFF0000u) >> 8);
  v60 = v50 + v59 + v58 + (v54 & v49 ^ v45 & ~v54) + 1518500249;
  v61 = __ROR4__(v54, 2);
  v62 = v61;
  v63 = v49;
  v64 = ((*(_DWORD *)(result + 84) & 0xFF00 | (*(_DWORD *)(result + 84) << 16)) << 8) | (((*(_DWORD *)(result + 84) >> 16) | *(_DWORD *)(result + 84) & 0xFF0000u) >> 8);
  v65 = __ROL4__(v60, 5);
  v66 = v57 + v64 + v65 + (v56 & v61 ^ v49 & ~v56) + 1518500249;
  v56 = __ROR4__(v56, 2);
  v67 = v56;
  v68 = ((*(_DWORD *)(result + 88) & 0xFF00 | (*(_DWORD *)(result + 88) << 16)) << 8) | (((*(_DWORD *)(result + 88) >> 16) | *(_DWORD *)(result + 88) & 0xFF0000u) >> 8);
  v69 = __ROL4__(v66, 5);
  v70 = v63 + v68 + v69 + (v60 & v56 ^ v61 & ~v60) + 1518500249;
  v60 = __ROR4__(v60, 2);
  v71 = v60;
  v72 = v60;
  v73 = __ROL4__(v4 ^ v13 ^ v38 ^ v59, 1);
  v74 = v56 & ~v66;
  v75 = v73;
  v76 = __ROL4__(v70, 5);
  v77 = v62 + v73 + v76 + (v66 & v72 ^ v74) + 1518500249;
  v66 = __ROR4__(v66, 2);
  v78 = v77;
  v79 = v66;
  v80 = __ROL4__(v7 ^ v15 ^ v43 ^ v64, 1);
  v81 = v80;
  v77 = __ROL4__(v77, 5);
  v82 = v67 + v80 + v77 + (v66 & v70 ^ v71 & ~v70) + 1518500249;
  v70 = __ROR4__(v70, 2);
  v83 = __ROL4__(v13 ^ v22 ^ v48 ^ v68, 1);
  v84 = v83;
  v85 = __ROL4__(v82, 5);
  v86 = v70;
  v87 = v71 + v83 + v85 + (v78 & v70 ^ v66 & ~v78) + 1518500249;
  v88 = __ROR4__(v78, 2);
  v89 = v88;
  v90 = __ROL4__(v15 ^ v25 ^ v51 ^ v75, 1);
  v91 = v90;
  v92 = __ROL4__(v87, 5);
  v93 = v79 + v90 + v92 + (v82 & v89 ^ v70 & ~v82) + 1518500249;
  v82 = __ROR4__(v82, 2);
  v94 = v82;
  v95 = __ROL4__(v22 ^ v30 ^ v55 ^ v81, 1);
  v96 = v95;
  v97 = __ROL4__(v93, 5);
  v98 = v86 + v95 + v97 + (v87 ^ v82 ^ v89) + 1859775393;
  v87 = __ROR4__(v87, 2);
  v99 = v87;
  v100 = v87 ^ v82;
  v101 = __ROL4__(v25 ^ v34 ^ v59 ^ v84, 1);
  v102 = __ROL4__(v98, 5);
  v103 = v101;
  v104 = v89 + v101 + v102 + (v93 ^ v100) + 1859775393;
  v93 = __ROR4__(v93, 2);
  v105 = v93;
  v106 = __ROL4__(v30 ^ v38 ^ v64 ^ v91, 1);
  v107 = v106;
  v108 = __ROL4__(v104, 5);
  v109 = v94 + v106 + v108 + (v105 ^ v99 ^ v98) + 1859775393;
  v98 = __ROR4__(v98, 2);
  v110 = __ROL4__(v34 ^ v43 ^ v68 ^ v96, 1);
  v111 = v110;
  v112 = __ROL4__(v109, 5);
  v113 = v99 + v110 + v112 + (v105 ^ v104 ^ v98) + 1859775393;
  v104 = __ROR4__(v104, 2);
  v114 = v104;
  v115 = __ROL4__(v38 ^ v48 ^ v75 ^ v103, 1);
  v116 = v109 ^ v104 ^ v98;
  v117 = v115;
  v118 = __ROL4__(v113, 5);
  v119 = v105 + v115 + v118 + v116 + 1859775393;
  v109 = __ROR4__(v109, 2);
  v120 = v109;
  v121 = v109 ^ v114;
  v122 = __ROL4__(v43 ^ v51 ^ v81 ^ v107, 1);
  v123 = v122;
  v124 = __ROL4__(v119, 5);
  v125 = v122 + v124 + (v113 ^ v121);
  v113 = __ROR4__(v113, 2);
  v126 = v98 + v125 + 1859775393;
  v127 = __ROL4__(v48 ^ v55 ^ v84 ^ v111, 1);
  v128 = v113;
  v129 = v127;
  v130 = __ROL4__(v126, 5);
  v131 = v114 + v127 + v130 + (v119 ^ v113 ^ v120) + 1859775393;
  v119 = __ROR4__(v119, 2);
  v132 = v119;
  v133 = __ROL4__(v51 ^ v59 ^ v91 ^ v117, 1);
  v134 = v133;
  v135 = __ROL4__(v131, 5);
  v136 = v120 + v133 + v135 + (v132 ^ v113 ^ v126) + 1859775393;
  v126 = __ROR4__(v126, 2);
  v137 = __ROL4__(v55 ^ v64 ^ v96 ^ v123, 1);
  v138 = v137;
  v139 = __ROL4__(v136, 5);
  v140 = v128 + v137 + v139 + (v132 ^ v131 ^ v126) + 1859775393;
  v131 = __ROR4__(v131, 2);
  v141 = v131;
  v142 = __ROL4__(v59 ^ v68 ^ v103 ^ v129, 1);
  v143 = v136 ^ v131 ^ v126;
  v144 = v142;
  v145 = __ROL4__(v140, 5);
  v146 = v132 + v142 + v145 + v143 + 1859775393;
  v136 = __ROR4__(v136, 2);
  v147 = v136;
  v148 = v136 ^ v141;
  v149 = __ROL4__(v64 ^ v75 ^ v107 ^ v134, 1);
  v150 = v149;
  v151 = __ROL4__(v146, 5);
  v152 = v149 + v151 + (v140 ^ v148);
  v140 = __ROR4__(v140, 2);
  v153 = v126 + v152 + 1859775393;
  v154 = __ROL4__(v68 ^ v81 ^ v111 ^ v138, 1);
  v155 = v140;
  v156 = v154;
  v157 = __ROL4__(v153, 5);
  v158 = v141 + v154 + v157 + (v146 ^ v140 ^ v147) + 1859775393;
  v146 = __ROR4__(v146, 2);
  v159 = v146;
  v160 = __ROL4__(v75 ^ v84 ^ v117 ^ v144, 1);
  v161 = v160;
  v162 = __ROL4__(v158, 5);
  v163 = v147 + v160 + v162 + (v159 ^ v140 ^ v153) + 1859775393;
  v153 = __ROR4__(v153, 2);
  v164 = __ROL4__(v81 ^ v91 ^ v123 ^ v150, 1);
  v165 = v164;
  v166 = __ROL4__(v163, 5);
  v167 = v155 + v164 + v166 + (v159 ^ v158 ^ v153) + 1859775393;
  v158 = __ROR4__(v158, 2);
  v168 = v158;
  v169 = __ROL4__(v84 ^ v96 ^ v129 ^ v156, 1);
  v170 = v163 ^ v158 ^ v153;
  v171 = v169;
  v172 = __ROL4__(v167, 5);
  v173 = v159 + v169 + v172 + v170 + 1859775393;
  v163 = __ROR4__(v163, 2);
  v174 = v163;
  v175 = v163 ^ v168;
  v176 = __ROL4__(v91 ^ v103 ^ v134 ^ v161, 1);
  v177 = v176;
  v178 = __ROL4__(v173, 5);
  v179 = v176 + v178 + (v167 ^ v175);
  v167 = __ROR4__(v167, 2);
  v180 = v153 + v179 + 1859775393;
  v181 = v167;
  v182 = __ROL4__(v96 ^ v107 ^ v138 ^ v165, 1);
  v183 = v182;
  v184 = __ROL4__(v180, 5);
  v185 = v168 + v182 + v184 + (v173 ^ v167 ^ v174) + 1859775393;
  v173 = __ROR4__(v173, 2);
  v186 = v173;
  v187 = v173;
  v188 = __ROL4__(v103 ^ v111 ^ v144 ^ v171, 1);
  v189 = v188;
  v190 = __ROL4__(v185, 5);
  v191 = v174 + v188 + v190 + (v187 ^ v181 ^ v180) + 1859775393;
  v180 = __ROR4__(v180, 2);
  v192 = v180;
  v193 = __ROL4__(v107 ^ v117 ^ v150 ^ v177, 1);
  v194 = __ROL4__(v191, 5);
  v195 = v193;
  v196 = v181 + v193 + v194 + (v187 ^ v185 ^ v180) + 1859775393;
  v185 = __ROR4__(v185, 2);
  v197 = __ROL4__(v111 ^ v123 ^ v156 ^ v183, 1);
  v198 = __ROL4__(v196, 5);
  v199 = v197;
  v200 = v197 + v198 + (v191 ^ v185 ^ v192);
  v191 = __ROR4__(v191, 2);
  v201 = v186 + v200 + 1859775393;
  v202 = v191;
  v203 = __ROL4__(v117 ^ v129 ^ v161 ^ v189, 1);
  v204 = __ROL4__(v201, 5);
  v205 = v192 + v203 + (v196 & v191 ^ v185 & (v196 ^ v191)) + v204 - 1894007588;
  v206 = v203;
  v207 = v205;
  v196 = __ROR4__(v196, 2);
  v208 = __ROL4__(v123 ^ v134 ^ v165 ^ v195, 1);
  v209 = v208;
  v210 = v185 + v208 + (v201 & v196 ^ v202 & (v201 ^ v196));
  v205 = __ROL4__(v205, 5);
  v201 = __ROR4__(v201, 2);
  v211 = v196;
  v212 = __ROL4__(v129 ^ v138 ^ v171 ^ v199, 1);
  v213 = v212;
  v214 = v202 + v212 + (v201 & v196 ^ v207 & (v201 ^ v196));
  v215 = v210 + v205 - 1894007588;
  v216 = __ROL4__(v215, 5);
  v217 = __ROR4__(v207, 2);
  v218 = v214 + v216 - 1894007588;
  v219 = v217;
  v220 = __ROL4__(v134 ^ v144 ^ v177 ^ v206, 1);
  v221 = v219;
  v222 = v211 + v220 + (v201 & v215 ^ v219 & (v201 ^ v215));
  v223 = v220;
  v224 = v218;
  v218 = __ROL4__(v218, 5);
  v215 = __ROR4__(v215, 2);
  v225 = v218 + v222 - 1894007588;
  v226 = __ROL4__(v138 ^ v150 ^ v183 ^ v209, 1);
  v227 = v215;
  v228 = v226;
  v229 = v226 + (v224 & v215 ^ v219 & (v224 ^ v215));
  v230 = __ROL4__(v225, 5);
  v231 = __ROR4__(v224, 2);
  v232 = v230 + v201 + v229 - 1894007588;
  v233 = v231;
  v234 = __ROL4__(v144 ^ v156 ^ v189 ^ v213, 1);
  v235 = v234;
  v236 = v221 + v234 + (v225 & v233 ^ v215 & (v225 ^ v233));
  v237 = __ROL4__(v232, 5);
  v225 = __ROR4__(v225, 2);
  v238 = __ROL4__(v150 ^ v161 ^ v195 ^ v223, 1);
  v239 = v236 + v237 - 1894007588;
  v240 = v238;
  v241 = v227 + v238 + (v232 & v225 ^ v233 & (v232 ^ v225));
  v242 = v225;
  v243 = v239;
  v239 = __ROL4__(v239, 5);
  v232 = __ROR4__(v232, 2);
  v244 = __ROL4__(v156 ^ v165 ^ v199 ^ v228, 1);
  v245 = v233 + v244 + (v232 & v225 ^ v243 & (v232 ^ v225));
  v246 = v244;
  v247 = v241 + v239 - 1894007588;
  v248 = __ROL4__(v247, 5);
  v249 = __ROR4__(v243, 2);
  v250 = v245 + v248 - 1894007588;
  v251 = v249;
  v252 = __ROL4__(v161 ^ v171 ^ v206 ^ v235, 1);
  v253 = v251;
  v254 = v242 + v252 + (v232 & v247 ^ v251 & (v232 ^ v247));
  v255 = v252;
  v256 = v250;
  v250 = __ROL4__(v250, 5);
  v247 = __ROR4__(v247, 2);
  v257 = v250 + v254 - 1894007588;
  v258 = __ROL4__(v165 ^ v177 ^ v209 ^ v240, 1);
  v259 = __ROL4__(v257, 5);
  v260 = v247;
  v261 = v258;
  v262 = v258 + (v256 & v247 ^ v253 & (v256 ^ v247));
  v263 = __ROR4__(v256, 2);
  v264 = v259 + v232 + v262 - 1894007588;
  v265 = v263;
  v266 = __ROL4__(v171 ^ v183 ^ v213 ^ v246, 1);
  v267 = v253 + v266 + (v257 & v265 ^ v247 & (v257 ^ v265));
  v268 = v266;
  v269 = __ROL4__(v264, 5);
  v257 = __ROR4__(v257, 2);
  v270 = v267 + v269 - 1894007588;
  v271 = __ROL4__(v177 ^ v189 ^ v223 ^ v255, 1);
  v272 = v260 + v271 + (v264 & v257 ^ v265 & (v264 ^ v257));
  v273 = v271;
  v274 = v270;
  v270 = __ROL4__(v270, 5);
  v264 = __ROR4__(v264, 2);
  v275 = v257;
  v276 = __ROL4__(v183 ^ v195 ^ v228 ^ v261, 1);
  v277 = v265 + v276 + (v264 & v257 ^ v274 & (v264 ^ v257));
  v278 = v272 + v270 - 1894007588;
  v279 = v276;
  v280 = __ROL4__(v278, 5);
  v281 = __ROR4__(v274, 2);
  v282 = v277 + v280 - 1894007588;
  v283 = v281;
  v284 = __ROL4__(v189 ^ v199 ^ v235 ^ v268, 1);
  v285 = v282;
  v282 = __ROL4__(v282, 5);
  v286 = v284;
  v287 = v275 + v284 + (v264 & v278 ^ v283 & (v264 ^ v278));
  v278 = __ROR4__(v278, 2);
  v288 = v282 + v287 - 1894007588;
  v289 = __ROL4__(v195 ^ v206 ^ v240 ^ v273, 1);
  v290 = v289;
  v291 = v278;
  v292 = v289 + (v285 & v278 ^ v283 & (v285 ^ v278));
  v293 = __ROL4__(v288, 5);
  v294 = __ROR4__(v285, 2);
  v295 = v293 + v264 + v292 - 1894007588;
  v296 = v294;
  v297 = __ROL4__(v199 ^ v209 ^ v246 ^ v279, 1);
  v298 = v283 + v297 + (v288 & v296 ^ v278 & (v288 ^ v296));
  v299 = v297;
  v300 = __ROL4__(v295, 5);
  v288 = __ROR4__(v288, 2);
  v301 = v298 + v300 - 1894007588;
  v302 = __ROL4__(v206 ^ v213 ^ v255 ^ v286, 1);
  v303 = v291 + v302 + (v295 & v288 ^ v296 & (v295 ^ v288));
  v304 = v302;
  v305 = v301;
  v306 = v288;
  v301 = __ROL4__(v301, 5);
  v295 = __ROR4__(v295, 2);
  v307 = __ROL4__(v209 ^ v223 ^ v261 ^ v290, 1);
  v308 = v303 + v301 - 1894007588;
  v309 = v307;
  v310 = __ROL4__(v308, 5);
  v311 = v296 + v307 + (v295 & v288 ^ v305 & (v295 ^ v288)) + v310 - 1894007588;
  v312 = __ROR4__(v305, 2);
  v313 = v312;
  v314 = __ROL4__(v213 ^ v228 ^ v268 ^ v299, 1);
  v315 = v314;
  v316 = v306 + v314 + (v295 & v308 ^ v313 & (v295 ^ v308));
  v317 = v311;
  v311 = __ROL4__(v311, 5);
  v308 = __ROR4__(v308, 2);
  v318 = v311 + v316 - 1894007588;
  v319 = __ROL4__(v223 ^ v235 ^ v273 ^ v304, 1);
  v320 = v319;
  v321 = v308;
  v322 = v319 + (v317 & v308 ^ v313 & (v317 ^ v308));
  v323 = v318;
  v318 = __ROL4__(v318, 5);
  v317 = __ROR4__(v317, 2);
  v324 = __ROL4__(v228 ^ v240 ^ v279 ^ v309, 1);
  v325 = v318 + v295 + v322 - 1894007588;
  v326 = v313 + v324 + (v323 ^ v317 ^ v321);
  v327 = v324;
  v328 = __ROL4__(v325, 5);
  v323 = __ROR4__(v323, 2);
  v329 = v317;
  v330 = __ROL4__(v235 ^ v246 ^ v286 ^ v315, 1);
  v331 = v323;
  v332 = v330;
  v333 = v321 + v330 + (v325 ^ v323 ^ v317);
  v334 = v328 + v326 - 899497514;
  v335 = __ROL4__(v334, 5);
  v336 = v333 + v335 - 899497514;
  v325 = __ROR4__(v325, 2);
  v337 = v325;
  v338 = v325 ^ v331 ^ v334;
  v339 = __ROL4__(v240 ^ v255 ^ v290 ^ v320, 1);
  v340 = __ROL4__(v336, 5);
  v341 = v339;
  v334 = __ROR4__(v334, 2);
  v342 = v329 + v339 + v338 + v340 - 899497514;
  v343 = __ROL4__(v246 ^ v261 ^ v299 ^ v327, 1);
  v344 = v343;
  v345 = __ROL4__(v342, 5);
  v346 = v345 + v331 + v343 + (v337 ^ v336 ^ v334) - 899497514;
  v336 = __ROR4__(v336, 2);
  v347 = __ROL4__(v255 ^ v268 ^ v304 ^ v332, 1);
  v348 = v336;
  v349 = v347;
  v350 = v337 + v347 + (v342 ^ v336 ^ v334);
  v351 = __ROL4__(v346, 5);
  v342 = __ROR4__(v342, 2);
  v352 = v351 + v350 - 899497514;
  v353 = __ROL4__(v261 ^ v273 ^ v309 ^ v341, 1);
  v354 = v342;
  v355 = v353;
  v356 = v353 + (v346 ^ v342 ^ v348);
  v357 = __ROL4__(v352, 5);
  v346 = __ROR4__(v346, 2);
  v358 = v346;
  v359 = __ROL4__(v268 ^ v279 ^ v315 ^ v344, 1);
  v360 = v359;
  v361 = v357 + v334 + v356 - 899497514;
  v362 = __ROL4__(v361, 5);
  v363 = v348 + v359 + (v352 ^ v346 ^ v354) + v362 - 899497514;
  v352 = __ROR4__(v352, 2);
  v364 = v352;
  v365 = __ROL4__(v273 ^ v286 ^ v320 ^ v349, 1);
  v366 = v352 ^ v346 ^ v361;
  v367 = __ROL4__(v363, 5);
  v368 = v365;
  v369 = v354 + v365 + v366 + v367 - 899497514;
  v361 = __ROR4__(v361, 2);
  v370 = __ROL4__(v279 ^ v290 ^ v327 ^ v355, 1);
  v371 = v358 + v370 + (v364 ^ v363 ^ v361);
  v372 = v370;
  v373 = __ROL4__(v369, 5);
  v363 = __ROR4__(v363, 2);
  v374 = v373 + v371 - 899497514;
  v375 = __ROL4__(v286 ^ v299 ^ v332 ^ v360, 1);
  v376 = v363;
  v377 = v375;
  v378 = v364 + v375 + (v369 ^ v363 ^ v361);
  v379 = __ROL4__(v374, 5);
  v380 = v379 + v378 - 899497514;
  v369 = __ROR4__(v369, 2);
  v381 = __ROL4__(v290 ^ v304 ^ v341 ^ v368, 1);
  v382 = v369;
  v383 = v381;
  v384 = v381 + (v374 ^ v369 ^ v376);
  v385 = __ROL4__(v380, 5);
  v386 = v385 + v361 + v384 - 899497514;
  v374 = __ROR4__(v374, 2);
  v387 = __ROL4__(v299 ^ v309 ^ v344 ^ v372, 1);
  v388 = v376 + v387 + (v380 ^ v374 ^ v382);
  v389 = __ROL4__(v386, 5);
  v380 = __ROR4__(v380, 2);
  v390 = v374;
  v391 = v389 + v388 - 899497514;
  v392 = v380;
  v393 = __ROL4__(v304 ^ v315 ^ v349 ^ v377, 1);
  v394 = v391;
  v391 = __ROL4__(v391, 5);
  v395 = v382 + v393 + (v380 ^ v390 ^ v386) + v391 - 899497514;
  v386 = __ROR4__(v386, 2);
  v396 = v393;
  v397 = v395;
  v398 = v386;
  v399 = __ROL4__(v309 ^ v320 ^ v355 ^ v383, 1);
  v400 = __ROL4__(v395, 5);
  v401 = v399;
  v402 = __ROR4__(v394, 2);
  v403 = v400 + v390 + v399 + (v392 ^ v394 ^ v386) - 899497514;
  v404 = v403;
  v405 = v402;
  v406 = __ROL4__(v315 ^ v327 ^ v360 ^ v387, 1);
  v403 = __ROL4__(v403, 5);
  v407 = v392 + v406 + (v397 ^ v402 ^ v386) + v403 - 899497514;
  v408 = __ROR4__(v397, 2);
  v409 = v408;
  v410 = v407;
  v411 = __ROL4__(v320 ^ v332 ^ v368 ^ v396, 1);
  v407 = __ROL4__(v407, 5);
  v412 = v409;
  v413 = v407 + v398 + v411 + (v404 ^ v409 ^ v405) - 899497514;
  v414 = __ROR4__(v404, 2);
  v415 = v414;
  v416 = __ROL4__(v327 ^ v341 ^ v372 ^ v401, 1);
  v417 = v416;
  v418 = v413;
  v413 = __ROL4__(v413, 5);
  v419 = v405 + v416 + (v410 ^ v415 ^ v412) + v413 - 899497514;
  v420 = __ROR4__(v410, 2);
  v421 = v420;
  v422 = __ROL4__(v332 ^ v344 ^ v377 ^ v406, 1);
  v423 = __ROL4__(v419, 5);
  v424 = v412 + (v421 ^ v415 ^ v418) + v423 + v422 - 899497514;
  v425 = __ROR4__(v418, 2);
  v426 = v425;
  v427 = __ROL4__(v341 ^ v349 ^ v383 ^ v411, 1);
  v428 = __ROL4__(v424, 5);
  v429 = v415 + (v421 ^ v419 ^ v426) + v428 + v427 - 899497514;
  v419 = __ROR4__(v419, 2);
  v430 = __ROL4__(v417 ^ v344 ^ v355 ^ v387, 1);
  v431 = __ROL4__(v429, 5);
  v432 = v421 + (v424 ^ v419 ^ v426) + v431 + v430 - 899497514 + *(_DWORD *)(result + 8);
  *(_DWORD *)(result + 12) += v429;
  v424 = __ROR4__(v424, 2);
  v433 = *(_DWORD *)(result + 16) + v424;
  *(_DWORD *)(result + 20) += v419;
  v434 = *(_DWORD *)(result + 24);
  *(_DWORD *)(result + 8) = v432;
  *(_DWORD *)(result + 16) = v433;
  *(_DWORD *)(result + 24) = v426 + v434;
  return result;
}

//----- (1003CB00) --------------------------------------------------------
unsigned int __usercall sub_1003CB00@<eax>(int a1@<esi>, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@4
  unsigned int v5; // eax@7
  unsigned int result; // eax@7
  int v7; // edx@8

  v2 = *(_DWORD *)a1 & 0x3F;
  v3 = v2 >> 2;
  *(_DWORD *)(a1 + 4 * v3 + 28) = dword_100B3CD8[*(_BYTE *)a1 & 3] | *(_DWORD *)(a1 + 4 * v3 + 28) & dword_100B3CE8[*(_BYTE *)a1 & 3];
  if ( v2 > 0x37 )
  {
    if ( v2 < 0x3C )
      *(_DWORD *)(a1 + 88) = 0;
    sub_1003B3E0(a1);
    v4 = 0;
    goto LABEL_6;
  }
  v4 = v3 + 1;
  if ( v3 + 1 < 0xE )
LABEL_6:
    memset((void *)(a1 + 4 * v4 + 28), 0, 4 * (14 - v4));
  v5 = 8 * *(_DWORD *)a1;
  *(_DWORD *)(a1 + 84) = ((((unsigned int)(*(_QWORD *)a1 >> 29) << 16) | (*(_QWORD *)a1 >> 29) & 0xFF00) << 8) | ((((unsigned int)(*(_QWORD *)a1 >> 29) >> 16) | (*(_QWORD *)a1 >> 29) & 0xFF0000) >> 8);
  *(_DWORD *)(a1 + 88) = (((v5 << 16) | v5 & 0xFF00) << 8) | (((v5 >> 16) | v5 & 0xFF0000) >> 8);
  sub_1003B3E0(a1);
  result = 0;
  do
  {
    v7 = *(_DWORD *)(a1 + 4 * (result >> 2) + 8) >> 8 * (~(_BYTE)result & 3);
    *(_BYTE *)(++result + a2 - 1) = v7;
  }
  while ( result < 0x14 );
  return result;
}
// 100B3CD8: using guessed type int dword_100B3CD8[];
// 100B3CE8: using guessed type int dword_100B3CE8[];

//----- (1003CC00) --------------------------------------------------------
void *__usercall sub_1003CC00@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3)
{
  int v3; // ebp@1
  size_t v4; // ebx@1
  int v5; // edi@1
  unsigned int v6; // eax@1
  size_t v7; // esi@1
  char *v9; // [sp+14h] [bp+4h]@1

  v3 = (int)a3;
  v4 = a1;
  v5 = *a3 & 0x3F;
  v6 = a1 + *a3;
  v7 = 64 - v5;
  v9 = a2;
  *(_DWORD *)v3 = v6;
  if ( v6 < v4 )
    ++*(_DWORD *)(v3 + 4);
  if ( v4 >= v7 )
  {
    do
    {
      memcpy((void *)(v5 + v3 + 28), v9, v7);
      v9 += v7;
      v4 -= v7;
      v7 = 64;
      v5 = 0;
      sub_1003B3E0(v3);
    }
    while ( v4 >= 0x40 );
  }
  return memcpy((void *)(v5 + v3 + 28), v9, v4);
}

//----- (1003CC80) --------------------------------------------------------
void *__usercall sub_1003CC80@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3)
{
  int v3; // edi@1
  void *result; // eax@1
  unsigned int v5; // eax@4
  _DWORD *v6; // eax@6

  v3 = a1;
  result = *(void **)(a1 + 156);
  if ( result != (void *)-1 )
  {
    if ( (unsigned int)result > 0x40 )
    {
      sub_1003CB00(v3 + 64, v3);
      *(_DWORD *)(v3 + 156) = 20;
    }
    memset((void *)(v3 + *(_DWORD *)(v3 + 156)), 0, 64 - *(_DWORD *)(v3 + 156));
    v5 = 0;
    do
      *(_DWORD *)(v3 + 4 * v5++) ^= 0x36363636u;
    while ( v5 < 0x10 );
    v6 = (_DWORD *)sub_1003B3A0(v3 + 64);
    result = sub_1003CC00(0x40u, (char *)v3, v6);
    *(_DWORD *)(v3 + 156) = -1;
  }
  if ( a2 )
    result = sub_1003CC00(a2, a3, (_DWORD *)(v3 + 64));
  return result;
}

//----- (1003CD20) --------------------------------------------------------
int __usercall sub_1003CD20@<eax>(int a1@<edi>, int a2, size_t a3)
{
  unsigned int v3; // eax@3
  int result; // eax@5
  char v5; // [sp+8h] [bp-18h]@3

  if ( *(_DWORD *)(a1 + 156) != -1 )
    sub_1003CC80(a1, 0, 0);
  sub_1003CB00(a1 + 64, (int)&v5);
  v3 = 0;
  do
    *(_DWORD *)(a1 + 4 * v3++) ^= 0x6A6A6A6Au;
  while ( v3 < 0x10 );
  sub_1003B3A0(a1 + 64);
  sub_1003CC00(0x40u, (char *)a1, (_DWORD *)(a1 + 64));
  sub_1003CC00(0x14u, &v5, (_DWORD *)(a1 + 64));
  result = sub_1003CB00(a1 + 64, (int)&v5);
  if ( a3 )
    result = (int)memcpy((void *)a2, &v5, a3);
  return result;
}

//----- (1003CDE0) --------------------------------------------------------
int __usercall sub_1003CDE0@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3)
{
  int v3; // eax@1
  int result; // eax@2

  v3 = *(_DWORD *)(a2 + 156);
  if ( v3 + a1 <= 0x40 )
  {
    memcpy((void *)(a2 + v3), a3, a1);
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  else
  {
    sub_1003B3A0(a2 + 64);
    sub_1003CC00(*(_DWORD *)(a2 + 156), (char *)a2, (_DWORD *)(a2 + 64));
    sub_1003CC00(a1, (char *)a3, (_DWORD *)(a2 + 64));
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  return result;
}

//----- (1003CE40) --------------------------------------------------------
int __usercall sub_1003CE40@<eax>(char *a1@<edi>)
{
  unsigned int v1; // ebp@1
  signed int v2; // eax@2
  int v3; // edx@4
  int v4; // ecx@4
  int v5; // edx@4
  unsigned int v6; // esi@4
  size_t v7; // eax@4
  int v8; // ebx@6
  int v9; // edx@8
  int result; // eax@8
  int v11; // ecx@8
  int v12; // edx@8
  char v13; // [sp+Ch] [bp-5Ch]@8
  int v14; // [sp+14h] [bp-54h]@4
  int v15; // [sp+18h] [bp-50h]@4
  int v16; // [sp+1Ch] [bp-4Ch]@4
  int v17; // [sp+20h] [bp-48h]@4
  int v18; // [sp+24h] [bp-44h]@4
  char v19[64]; // [sp+28h] [bp-40h]@6

  v1 = 0;
  do
  {
    v2 = v1;
    if ( !v1 )
      v2 = 260;
    v3 = *(_DWORD *)&a1[v2 - 16];
    v14 = *(_DWORD *)&a1[v2 - 20];
    v4 = *(_DWORD *)&a1[v2 - 12];
    v15 = v3;
    v5 = *(_DWORD *)&a1[v2 - 8];
    v6 = 260 - v1;
    v18 = *(_DWORD *)&a1[v2 - 4];
    v16 = v4;
    v17 = v5;
    v7 = 64;
    if ( 260 - v1 <= 0x40 )
      v7 = 260 - v1;
    v8 = (int)&a1[v1];
    memcpy(v19, &a1[v1], v7);
    if ( v6 < 0x40 )
      memcpy(&v19[v6], a1, 64 - v6);
    sub_1003B3E0((int)&v13);
    v9 = v15;
    result = v16;
    *(_DWORD *)v8 = v14;
    v11 = v17;
    *(_DWORD *)(v8 + 4) = v9;
    v12 = v18;
    *(_DWORD *)(v8 + 8) = result;
    v1 += 20;
    *(_DWORD *)(v8 + 12) = v11;
    *(_DWORD *)(v8 + 16) = v12;
  }
  while ( v1 < 0x104 );
  return result;
}
// 1003CE40: using guessed type char var_40[64];

//----- (1003CF00) --------------------------------------------------------
int __usercall sub_1003CF00@<eax>(int a1@<ebx>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // eax@3
  char v3; // cl@4
  char v4; // dl@4
  char v5; // cl@4
  char v6; // dl@4
  char *v8; // [sp+Ch] [bp-4h]@1

  v8 = (char *)(a1 + 260);
  v1 = 0;
  qmemcpy((void *)(a1 + 260), (const void *)a1, 0x104u);
  do
    v1 += (*(int (__cdecl **)(unsigned int, unsigned int))(a1 + 524))(a1 + v1, 260 - v1);
  while ( v1 < 0x104 );
  v2 = 0;
  do
  {
    v3 = *(_BYTE *)(v2 + a1 + 261);
    *(_BYTE *)(v2 + a1) ^= ~v8[v2];
    v4 = *(_BYTE *)(v2 + a1 + 262);
    *(_BYTE *)(v2 + a1 + 1) ^= ~v3;
    v5 = *(_BYTE *)(v2 + a1 + 263);
    *(_BYTE *)(v2 + a1 + 2) ^= ~v4;
    v6 = *(_BYTE *)(v2 + a1 + 264);
    *(_BYTE *)(v2 + a1 + 3) ^= ~v5;
    *(_BYTE *)(v2 + a1 + 4) ^= ~v6;
    v2 += 5;
  }
  while ( v2 < 0x104 );
  sub_1003CE40((char *)a1);
  return sub_1003CE40(v8);
}

//----- (1003CFC0) --------------------------------------------------------
char __cdecl sub_1003CFC0(char *a1, size_t a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_1003CC80(a3 + 296, a2, a1);
    sub_1003A540(a3, (int)a1, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003D010) --------------------------------------------------------
char __cdecl sub_1003D010(char *a1, unsigned int a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_1003A540(a3, (int)a1, a2);
    sub_1003CC80(a3 + 296, a2, a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003D060) --------------------------------------------------------
bool __cdecl sub_1003D060(int a1, int a2)
{
  if ( a2 )
    sub_1003CD20(a2 + 296, a1, 0xAu);
  return a2 != 0;
}

//----- (1003D090) --------------------------------------------------------
int __usercall sub_1003D090@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7)
{
  void *v7; // esi@1
  char *v8; // ebx@1
  int result; // eax@1
  unsigned int v10; // edx@1
  unsigned int v11; // ebx@2
  size_t v12; // edx@3
  char v13; // al@6
  char v14; // al@6
  bool v15; // zf@7
  unsigned int v16; // eax@9
  unsigned int v17; // ecx@9
  int *v18; // [sp+10h] [bp-228h]@2
  unsigned int v19; // [sp+14h] [bp-224h]@2
  int v20; // [sp+18h] [bp-220h]@4
  signed int v21; // [sp+1Ch] [bp-21Ch]@2
  unsigned int v22; // [sp+20h] [bp-218h]@1
  char v23; // [sp+28h] [bp-210h]@3
  char v24; // [sp+C8h] [bp-170h]@1
  char v25; // [sp+168h] [bp-D0h]@1
  int v26; // [sp+20Ch] [bp-2Ch]@2
  int v27; // [sp+210h] [bp-28h]@3
  int v28; // [sp+214h] [bp-24h]@3
  int v29; // [sp+218h] [bp-20h]@3
  int v30; // [sp+21Ch] [bp-1Ch]@3
  int v31; // [sp+220h] [bp-18h]@3
  char v32[16]; // [sp+224h] [bp-14h]@6

  v7 = a2;
  v8 = a1;
  sub_1003B320(&v24);
  sub_1003CDE0(a3, (int)&v24, v7);
  qmemcpy(&v25, &v24, 0xA0u);
  sub_1003CC80((int)&v25, a4, v8);
  result = -858993459 * (a7 - 1);
  v10 = (a7 - 1) / 0x14;
  v22 = v10 + 1;
  if ( v10 != -1 )
  {
    v11 = 1;
    v19 = 0;
    v21 = 1;
    v18 = &v26;
    do
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      qmemcpy(&v23, &v25, 0xA0u);
      LOBYTE(v31) = BYTE3(v11);
      BYTE2(v31) = BYTE1(v11);
      BYTE1(v31) = v11 >> 16;
      BYTE3(v31) = v11;
      v12 = 4;
      if ( a5 )
      {
        v20 = a5;
        do
        {
          sub_1003CC80((int)&v23, v12, (char *)&v31);
          sub_1003CD20((int)&v23, (int)&v31, 0x14u);
          v12 = 0;
          do
          {
            *((_BYTE *)&v26 + v12) ^= *((_BYTE *)&v31 + v12);
            v13 = *((_BYTE *)&v31 + v12 + 2);
            *((_BYTE *)&v26 + v12 + 1) ^= *((_BYTE *)&v31 + v12 + 1);
            *((_BYTE *)&v26 + v12 + 2) ^= v13;
            v14 = v32[v12];
            *((_BYTE *)&v26 + v12 + 3) ^= *((_BYTE *)&v31 + v12 + 3);
            *((_BYTE *)&v27 + v12) ^= v14;
            v12 += 5;
          }
          while ( v12 < 0x14 );
          v15 = v20-- == 1;
          qmemcpy(&v23, &v24, 0xA0u);
        }
        while ( !v15 );
        v11 = v21;
      }
      v16 = v19;
      v17 = 0;
      do
      {
        if ( v16 >= a7 )
          break;
        *(_BYTE *)(v16 + a6) = *((_BYTE *)v18 + v16);
        ++v17;
        ++v16;
      }
      while ( v17 < 0x14 );
      v19 += 20;
      v18 -= 5;
      result = ++v11 - 1;
      v21 = v11;
    }
    while ( v11 - 1 < v22 );
  }
  return result;
}
// 1003D090: using guessed type char var_14[16];

//----- (1003D2A0) --------------------------------------------------------
int __usercall sub_1003D2A0@<eax>(void *a1@<eax>, int a2)
{
  int v2; // ebx@1
  signed int v3; // esi@1

  v2 = (int)a1;
  memset(a1, 0, 0x210u);
  *(_DWORD *)(v2 + 524) = a2;
  sub_1003CF00(v2);
  v3 = 20;
  do
  {
    sub_1003CE40((char *)v2);
    --v3;
  }
  while ( v3 );
  return sub_1003CF00(v2);
}

//----- (1003D2F0) --------------------------------------------------------
char *__cdecl sub_1003D2F0(int a1, int a2)
{
  void *v2; // ecx@0
  char *result; // eax@1
  unsigned int v4; // ebp@1
  int v5; // edi@1
  char *v6; // ebx@1
  size_t v7; // esi@4

  result = (char *)a2;
  v4 = a1;
  v5 = *(_DWORD *)(a2 + 520);
  v6 = (char *)v2;
  if ( a1 )
  {
    while ( 1 )
    {
      v7 = 260 - v5;
      if ( v4 < 260 - v5 )
        v7 = v4;
      result = (char *)memcpy(v6, &result[v5 + 260], v7);
      v6 += v7;
      v5 += v7;
      v4 -= v7;
      if ( v5 == 260 )
      {
        result = (char *)sub_1003CF00(a2);
        v5 = 0;
      }
      if ( !v4 )
        break;
      result = (char *)a2;
    }
    *(_DWORD *)(a2 + 520) = v5;
  }
  else
  {
    *(_DWORD *)(a2 + 520) = v5;
  }
  return result;
}

//----- (1003D380) --------------------------------------------------------
signed int __cdecl sub_1003D380(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6)
{
  signed int result; // eax@2
  int v7; // ebx@6
  char v8; // [sp+Ch] [bp-48h]@6
  char v9[8]; // [sp+14h] [bp-40h]@6
  __int16 v10[26]; // [sp+1Ch] [bp-38h]@6

  if ( a3 <= 0x80 )
  {
    if ( (unsigned __int8)(a1 - 1) > 2u )
    {
      result = -101;
    }
    else if ( a6 )
    {
      *(_BYTE *)(a6 + 464) = a1;
      v7 = a1 & 3;
      *(_DWORD *)(a6 + 460) = a3;
      sub_1003D090(a4, a2, a3, 4 * v7 + 4, 1000, (int)&v8, 16 * v7 + 18);
      *(_DWORD *)(a6 + 456) = 16;
      *(_DWORD *)a6 = 0;
      *(_DWORD *)(a6 + 4) = 0;
      *(_DWORD *)(a6 + 8) = 0;
      *(_DWORD *)(a6 + 12) = 0;
      sub_1003A5A0(a6 + 32, (int)&v8, 8 * v7 + 8);
      sub_1003B320((void *)(a6 + 296));
      sub_1003CDE0(8 * v7 + 8, a6 + 296, &v9[8 * v7]);
      *a5 = v10[8 * v7];
      result = 0;
    }
    else
    {
      result = -102;
    }
  }
  else
  {
    result = -100;
  }
  return result;
}
// 1003D380: using guessed type char var_40[8];
// 1003D380: using guessed type __int16 var_38[26];

//----- (1003D4B0) --------------------------------------------------------
bool __cdecl sub_1003D4B0(void *a1, int a2)
{
  bool v2; // bl@3
  int v4; // [sp+Ch] [bp-214h]@5

  v2 = a1 && a2;
  sub_1003D2A0(&v4, (int)sub_1003B340);
  if ( v2 )
    sub_1003D2F0(a2, (int)&v4);
  return v2;
}

//----- (1003D530) --------------------------------------------------------
BOOL __usercall sub_1003D530@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // ecx@3
  int v4; // ecx@4

  *(_WORD *)(*(_DWORD *)(a1 + 5712) + 2 * *(_DWORD *)(a1 + 5728)) = a3;
  *(_BYTE *)(*(_DWORD *)(a1 + 5716) + (*(_DWORD *)(a1 + 5728))++) = a2;
  if ( a3 )
  {
    ++*(_DWORD *)(a1 + 2920);
    ++*(_WORD *)(a1 + 4 * (unsigned __int8)byte_100B44F0[a2] + 3964);
    v3 = a3 - 1;
    if ( v3 >= 0x100 )
      v4 = (unsigned __int8)byte_100B43F0[v3 >> 7];
    else
      v4 = (unsigned __int8)byte_100B42F0[v3];
    ++*(_WORD *)(a1 + 4 * v4 + 5228);
  }
  else
  {
    ++*(_WORD *)(a1 + 4 * a2 + 2936);
  }
  return *(_DWORD *)(a1 + 5728) == *(_DWORD *)(a1 + 5724) - 1;
}

//----- (1003D5D0) --------------------------------------------------------
int __usercall sub_1003D5D0@<eax>(int result@<eax>)
{
  signed int v1; // ecx@1
  __int16 v2; // cx@4

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)((*(_DWORD *)(result + 5812))++ + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
    *(_DWORD *)(result + 2932) = 0;
    *(_WORD *)(result + 2924) = 0;
  }
  else if ( v1 >= 8 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) -= 8;
    *(_WORD *)(result + 2924) = v2;
  }
  return result;
}

//----- (1003D660) --------------------------------------------------------
unsigned int __fastcall sub_1003D660(unsigned int a1, int a2)
{
  unsigned int v2; // eax@1
  int v3; // esi@2

  v2 = 0;
  do
  {
    v3 = a1 & 1;
    --a2;
    a1 >>= 1;
    v2 = 2 * (v3 | v2);
  }
  while ( a2 > 0 );
  return v2 >> 1;
}

//----- (1003D680) --------------------------------------------------------
int __usercall sub_1003D680@<eax>(int result@<eax>)
{
  signed int v1; // edx@1
  char v2; // bl@2
  int v3; // edx@2

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 <= 8 )
  {
    if ( v1 > 0 )
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    v3 = *(_DWORD *)(result + 5800);
    *(_BYTE *)(++*(_DWORD *)(result + 5812) + v3) = v2;
    ++*(_DWORD *)(result + 5812);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  return result;
}

//----- (1003D710) --------------------------------------------------------
int __usercall sub_1003D710@<eax>(int result@<eax>, int a2, int a3)
{
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // ebp@2
  int v6; // esi@2
  int v7; // ecx@2
  int v8; // edi@3
  int v9; // esi@4
  int v10; // edx@4
  int v11; // ecx@4
  int v12; // edx@4
  int v13; // ecx@4
  int v14; // edx@6
  int v15; // edi@7
  int v16; // edx@7
  int v17; // ecx@7
  int v18; // edx@7
  int v19; // edi@9
  int v20; // esi@10
  int v21; // ecx@10
  int v22; // edx@11
  int v23; // ecx@11
  int v24; // edx@11
  int v25; // ecx@11
  unsigned int v26; // ebp@14
  int v27; // edi@15
  int v28; // edx@17
  int v29; // ecx@17
  unsigned __int16 v30; // si@18
  int v31; // edx@18
  int v32; // ecx@18
  int v33; // edx@18
  int v34; // esi@20
  int v35; // ecx@21
  int v36; // ebp@21
  int v37; // edx@22
  int v38; // ecx@22
  int v39; // edx@22
  int v40; // edi@26
  int v41; // ecx@26
  unsigned __int16 v42; // si@27
  int v43; // edx@27
  int v44; // ecx@27
  int v45; // edx@27
  int v46; // [sp+10h] [bp-Ch]@6
  int v47; // [sp+14h] [bp-8h]@6
  int v48; // [sp+14h] [bp-8h]@17
  unsigned int v49; // [sp+18h] [bp-4h]@2

  v3 = a2;
  v4 = 0;
  if ( *(_DWORD *)(result + 5728) )
  {
    do
    {
      v5 = *(_WORD *)(*(_DWORD *)(result + 5712) + 2 * v4);
      v6 = *(_BYTE *)(v4 + *(_DWORD *)(result + 5716));
      v49 = v4 + 1;
      v7 = *(_DWORD *)(result + 2932);
      if ( v5 )
      {
        v14 = (unsigned __int8)byte_100B44F0[v6];
        v46 = *(_WORD *)(v3 + 4 * v14 + 1030);
        v47 = (unsigned __int8)byte_100B44F0[v6];
        if ( v7 <= 16 - v46 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a2 + 4 * v14 + 1028) << v7;
          *(_DWORD *)(result + 2932) = v46 + v7;
        }
        else
        {
          v15 = *(_WORD *)(a2 + 4 * v14 + 1028);
          v16 = v15 << v7;
          v17 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v16;
          *(_BYTE *)(v17 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v18 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          LOWORD(v15) = (unsigned __int16)v15 >> (16 - v18);
          *(_DWORD *)(result + 2932) = v18 + v46 - 16;
          v14 = v47;
          *(_WORD *)(result + 2924) = v15;
        }
        v19 = dword_100B3CF8[v14];
        v3 = a2;
        if ( v19 )
        {
          v20 = v6 - dword_100B45F0[v14];
          v21 = *(_DWORD *)(result + 2932);
          if ( v21 <= 16 - v19 )
          {
            *(_WORD *)(result + 2924) |= v20 << v21;
            v25 = v19 + v21;
          }
          else
          {
            v22 = v20 << v21;
            v23 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v22;
            *(_BYTE *)(v23 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v24 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v3 = a2;
            v25 = v24 + v19 - 16;
            *(_WORD *)(result + 2924) = (unsigned __int16)v20 >> (16 - v24);
          }
          *(_DWORD *)(result + 2932) = v25;
        }
        v26 = v5 - 1;
        if ( v26 >= 0x100 )
          v27 = (unsigned __int8)byte_100B43F0[v26 >> 7];
        else
          v27 = (unsigned __int8)byte_100B42F0[v26];
        v28 = *(_WORD *)(a3 + 4 * v27 + 2);
        v29 = *(_DWORD *)(result + 2932);
        v48 = *(_WORD *)(a3 + 4 * v27 + 2);
        if ( v29 <= 16 - v28 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a3 + 4 * v27) << v29;
          *(_DWORD *)(result + 2932) = v28 + v29;
        }
        else
        {
          v30 = *(_WORD *)(a3 + 4 * v27);
          v31 = *(_WORD *)(a3 + 4 * v27) << v29;
          v32 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v31;
          *(_BYTE *)(v32 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v33 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v3 = a2;
          *(_DWORD *)(result + 2932) = v33 + v48 - 16;
          *(_WORD *)(result + 2924) = v30 >> (16 - v33);
        }
        v34 = dword_100B3D80[v27];
        if ( !v34 )
          goto LABEL_25;
        v35 = *(_DWORD *)(result + 2932);
        v36 = v26 - dword_100B4668[v27];
        if ( v35 <= 16 - v34 )
        {
          *(_WORD *)(result + 2924) |= v36 << v35;
          v13 = v34 + v35;
        }
        else
        {
          v37 = v36 << v35;
          v38 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v37;
          *(_BYTE *)(v38 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v39 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v39 + v34 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v36 >> (16 - v39);
        }
      }
      else
      {
        v8 = *(_WORD *)(v3 + 4 * v6 + 2);
        if ( v7 <= 16 - v8 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 4 * v6) << v7;
          v13 = v8 + v7;
        }
        else
        {
          v9 = *(_WORD *)(v3 + 4 * v6);
          v10 = v9 << v7;
          v11 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v10;
          *(_BYTE *)(v11 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v12 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v12 + v8 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v9 >> (16 - v12);
        }
      }
      *(_DWORD *)(result + 2932) = v13;
LABEL_25:
      v4 = v49;
    }
    while ( v49 < *(_DWORD *)(result + 5728) );
  }
  v40 = *(_WORD *)(v3 + 1026);
  v41 = *(_DWORD *)(result + 2932);
  if ( v41 <= 16 - v40 )
  {
    *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 1024) << v41;
    *(_DWORD *)(result + 2932) = v40 + v41;
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  else
  {
    v42 = *(_WORD *)(v3 + 1024);
    v43 = *(_WORD *)(v3 + 1024) << v41;
    v44 = *(_DWORD *)(result + 5800);
    *(_WORD *)(result + 2924) |= v43;
    *(_BYTE *)(v44 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2925);
    v45 = *(_DWORD *)(result + 2932);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) = v45 + v40 - 16;
    *(_WORD *)(result + 2924) = v42 >> (16 - v45);
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  return result;
}
// 100B3CF8: using guessed type int dword_100B3CF8[];
// 100B3D80: using guessed type int dword_100B3D80[];
// 100B45F0: using guessed type int dword_100B45F0[];
// 100B4668: using guessed type int dword_100B4668[];

//----- (1003DB90) --------------------------------------------------------
int __usercall sub_1003DB90@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  _BYTE *v4; // edi@1
  int result; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // edx@1
  int i; // esi@1

  v3 = a3;
  v4 = a2;
  result = sub_1003D680(a1);
  v6 = *(_DWORD *)(result + 5812);
  v7 = *(_DWORD *)(result + 5800);
  *(_DWORD *)(result + 2928) = 8;
  *(_BYTE *)(v6 + v7) = v3;
  v8 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v8) = BYTE1(v3);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~(_BYTE)v3;
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~BYTE1(v3);
  for ( i = ++*(_DWORD *)(result + 5812); v3; ++v4 )
  {
    *(_BYTE *)(i + *(_DWORD *)(result + 5800)) = *v4;
    i = ++*(_DWORD *)(result + 5812);
    --v3;
  }
  return result;
}

//----- (1003DC40) --------------------------------------------------------
void *__usercall sub_1003DC40@<eax>(int a1@<edi>)
{
  void *result; // eax@1
  int v2; // ebx@1
  size_t v3; // esi@1
  bool v4; // zf@4

  result = *(void **)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(v2 + 5812);
  if ( v3 > (unsigned int)result )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    result = memcpy(*(void **)(a1 + 12), *(const void **)(v2 + 5808), v3);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v2 + 5808) += v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) -= v3;
    v4 = *(_DWORD *)(v2 + 5812) == v3;
    *(_DWORD *)(v2 + 5812) -= v3;
    if ( v4 )
      *(_DWORD *)(v2 + 5808) = *(_DWORD *)(v2 + 5800);
  }
  return result;
}

//----- (1003DCA0) --------------------------------------------------------
int __usercall sub_1003DCA0@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx@1
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@3
  int v9; // ecx@3
  int v10; // esi@6
  int v11; // ebx@8
  int i; // ecx@13
  int v13; // edx@17
  int v14; // ebx@18
  int v15; // ecx@19
  int v16; // esi@20
  int v17; // [sp+Ch] [bp-20h]@1
  int *v18; // [sp+10h] [bp-1Ch]@2
  int v19; // [sp+10h] [bp-1Ch]@17
  signed int v20; // [sp+14h] [bp-18h]@2
  int v21; // [sp+18h] [bp-14h]@1
  int v22; // [sp+1Ch] [bp-10h]@2
  int v23; // [sp+20h] [bp-Ch]@1
  int v24; // [sp+24h] [bp-8h]@1
  int v25; // [sp+28h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)a2;
  v24 = *(_DWORD *)(v2 + 8);
  v4 = *(_DWORD *)(v2 + 16);
  v21 = *(_DWORD *)v2;
  v25 = *(_DWORD *)(v2 + 4);
  v5 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  v23 = v5;
  v6 = 0;
  *(_WORD *)(v3 + 4 * *(_DWORD *)(result + 4 * *(_DWORD *)(result + 2328) + 32) + 2) = 0;
  v7 = *(_DWORD *)(result + 2328) + 1;
  v17 = 0;
  if ( v7 < 573 )
  {
    v18 = (int *)(result + 4 * v7 + 32);
    v22 = 573 - v7;
    v20 = 573;
    do
    {
      v8 = *v18;
      v9 = *(_WORD *)(v3 + 4 * *(_WORD *)(v3 + 4 * *v18 + 2) + 2) + 1;
      if ( v9 > v4 )
      {
        ++v6;
        v9 = v4;
        v17 = v6;
      }
      *(_WORD *)(v3 + 4 * v8 + 2) = v9;
      if ( v8 <= v23 )
      {
        ++*(_WORD *)(result + 2 * v9);
        v10 = 0;
        if ( v8 >= v24 )
          v10 = *(_DWORD *)(v25 + 4 * (v8 - v24));
        v11 = *(_WORD *)(v3 + 4 * v8);
        *(_DWORD *)(result + 2912) += v11 * (v10 + v9);
        if ( v21 )
          *(_DWORD *)(result + 2916) += v11 * (v10 + *(_WORD *)(v21 + 4 * v8 + 2));
        v6 = v17;
      }
      ++v18;
      --v22;
    }
    while ( v22 );
    if ( v6 )
    {
      do
      {
        for ( i = v4 - 1; !*(_WORD *)(result + 2 * i); --i )
          ;
        --*(_WORD *)(result + 2 * i);
        *(_WORD *)(result + 2 * i + 2) += 2;
        --*(_WORD *)(result + 2 * v4);
        v6 -= 2;
      }
      while ( v6 > 0 );
      for ( ; v4; --v4 )
      {
        v13 = *(_WORD *)(result + 2 * v4);
        v19 = *(_WORD *)(result + 2 * v4);
        if ( *(_WORD *)(result + 2 * v4) )
        {
          v14 = result + 4 * v20 + 32;
          do
          {
            v15 = *(_DWORD *)(v14 - 4);
            --v20;
            v14 -= 4;
            if ( v15 <= v23 )
            {
              v16 = *(_WORD *)(v3 + 4 * v15 + 2);
              if ( v16 != v4 )
              {
                *(_DWORD *)(result + 2912) += *(_WORD *)(v3 + 4 * v15) * (v4 - v16);
                *(_WORD *)(v3 + 4 * v15 + 2) = v4;
              }
              v13 = --v19;
            }
          }
          while ( v13 );
        }
      }
    }
  }
  return result;
}

//----- (1003DE70) --------------------------------------------------------
signed int __usercall sub_1003DE70@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // cx@1
  signed int result; // eax@1
  int v5; // edx@1
  int i; // esi@3
  int v7; // edx@4
  unsigned int v8; // ecx@5
  __int16 v9; // [sp+4h] [bp-24h]@2
  char v10; // [sp+6h] [bp-22h]@1

  v3 = 0;
  result = 1;
  v5 = a1 - (_DWORD)&v10;
  do
  {
    v3 = 2 * (v3 + *(__int16 *)((char *)&v9 + 2 * result + v5));
    *(&v9 + result++) = v3;
  }
  while ( result <= 15 );
  for ( i = 0; i <= a2; ++i )
  {
    v7 = *(_WORD *)(a3 + 4 * i + 2);
    if ( *(_WORD *)(a3 + 4 * i + 2) )
    {
      v8 = (unsigned __int16)(*(&v9 + v7))++;
      result = sub_1003D660(v8, v7);
      *(_WORD *)(a3 + 4 * i) = result;
    }
  }
  return result;
}

//----- (1003DEF0) --------------------------------------------------------
_WORD *__fastcall sub_1003DEF0(int a1, int a2)
{
  _WORD *v2; // eax@1
  signed int v3; // ecx@1
  _WORD *v4; // eax@3
  signed int v5; // ecx@3
  _WORD *result; // eax@5
  signed int v7; // ecx@5

  v2 = (_WORD *)(a2 + 2936);
  v3 = 286;
  do
  {
    *v2 = 0;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  v4 = (_WORD *)(a2 + 5228);
  v5 = 30;
  do
  {
    *v4 = 0;
    v4 += 2;
    --v5;
  }
  while ( v5 );
  result = (_WORD *)(a2 + 5472);
  v7 = 19;
  do
  {
    *result = 0;
    result += 2;
    --v7;
  }
  while ( v7 );
  *(_DWORD *)(a2 + 2916) = 0;
  *(_DWORD *)(a2 + 2912) = 0;
  *(_DWORD *)(a2 + 2920) = 0;
  *(_DWORD *)(a2 + 5728) = 0;
  *(_WORD *)(a2 + 3960) = 1;
  return result;
}

//----- (1003DF60) --------------------------------------------------------
unsigned int __usercall sub_1003DF60@<eax>(int a1@<esi>, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // edi@1
  int v6; // ecx@4
  unsigned int v7; // ebx@4
  int v8; // edx@8
  char v9; // al@11
  int v10; // edx@11
  unsigned int v11; // ecx@12
  _BYTE *v12; // edx@12
  char v13; // al@13
  _BYTE *v14; // edx@13
  char v15; // al@14
  _BYTE *v16; // edx@14
  char v17; // al@15
  _BYTE *v18; // edx@15
  char v19; // al@16
  _BYTE *v20; // edx@16
  char v21; // al@17
  _BYTE *v22; // edx@17
  char v23; // al@18
  _BYTE *v24; // edx@18
  char v25; // al@19
  _BYTE *v26; // edx@19
  char v27; // al@20
  int v28; // edx@22
  unsigned int result; // eax@27
  char v30; // [sp+Fh] [bp-11h]@4
  unsigned int v31; // [sp+10h] [bp-10h]@1
  int v32; // [sp+14h] [bp-Ch]@4
  unsigned int v33; // [sp+18h] [bp-8h]@2
  char v34; // [sp+24h] [bp+4h]@4

  v2 = *(_DWORD *)(a1 + 5748);
  v3 = *(_DWORD *)(a1 + 5680);
  v4 = a2;
  v31 = *(_DWORD *)(a1 + 5696);
  v5 = *(_DWORD *)(a1 + 5692);
  if ( v3 <= v2 - 262 )
    v33 = 0;
  else
    v33 = v3 - v2 + 262;
  v6 = *(_DWORD *)(a1 + 5740) + v3;
  v34 = *(_BYTE *)(v6 + v5 - 1);
  v32 = *(_DWORD *)(a1 + 5708);
  v7 = v6 + 258;
  v30 = *(_BYTE *)(v6 + v5);
  if ( v5 >= *(_DWORD *)(a1 + 5704) )
    v31 >>= 2;
  if ( *(_DWORD *)(a1 + 5708) > *(_DWORD *)(a1 + 5688) )
    v32 = *(_DWORD *)(a1 + 5688);
  do
  {
    v8 = v4 + *(_DWORD *)(a1 + 5740);
    if ( *(_BYTE *)(v8 + v5) == v30 && *(_BYTE *)(v8 + v5 - 1) == v34 && *(_BYTE *)v8 == *(_BYTE *)v6 )
    {
      v9 = *(_BYTE *)(v8 + 1);
      v10 = v8 + 1;
      if ( v9 == *(_BYTE *)(v6 + 1) )
      {
        v11 = v6 + 2;
        v12 = (_BYTE *)(v10 + 1);
        do
        {
          v13 = *(_BYTE *)(v11++ + 1);
          v14 = v12 + 1;
          if ( v13 != *v14 )
            break;
          v15 = *(_BYTE *)(v11++ + 1);
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *(_BYTE *)(v11++ + 1);
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *(_BYTE *)(v11++ + 1);
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *(_BYTE *)(v11++ + 1);
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *(_BYTE *)(v11++ + 1);
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *(_BYTE *)(v11++ + 1);
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *(_BYTE *)(v11++ + 1);
          v12 = v26 + 1;
          if ( v27 != *v12 )
            break;
        }
        while ( v11 < v7 );
        v28 = v11 - v7 + 258;
        v6 = v7 - 258;
        if ( v28 > (signed int)v5 )
        {
          *(_DWORD *)(a1 + 5684) = v4;
          v5 = v28;
          if ( v28 >= v32 )
            break;
          v34 = *(_BYTE *)(v28 + v6 - 1);
          v30 = *(_BYTE *)(v28 + v6);
        }
      }
    }
    v4 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & *(_DWORD *)(a1 + 5756)));
    if ( v4 <= v33 )
      break;
    --v31;
  }
  while ( v31 );
  result = *(_DWORD *)(a1 + 5688);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (1003E110) --------------------------------------------------------
unsigned int __usercall sub_1003E110@<eax>(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  unsigned int v6; // edi@1
  unsigned int v7; // eax@3
  _BYTE *v8; // ecx@3
  char v9; // dl@4
  _BYTE *v10; // ecx@4
  char v11; // dl@5
  _BYTE *v12; // ecx@5
  char v13; // dl@6
  _BYTE *v14; // ecx@6
  char v15; // dl@7
  _BYTE *v16; // ecx@7
  char v17; // dl@8
  _BYTE *v18; // ecx@8
  char v19; // dl@9
  _BYTE *v20; // ecx@9
  char v21; // dl@10
  _BYTE *v22; // ecx@10
  char v23; // dl@11
  unsigned int v24; // ecx@13
  unsigned int result; // eax@13

  v2 = *(_DWORD *)(a1 + 5740);
  v3 = *(_BYTE *)(v2 + a2);
  v4 = v2 + *(_DWORD *)(a1 + 5680);
  v5 = a2 + v2;
  v6 = v4 + 258;
  if ( v3 != *(_BYTE *)v4 || *(_BYTE *)(v5 + 1) != *(_BYTE *)(v4 + 1) )
  {
    result = 2;
  }
  else
  {
    v7 = v4 + 2;
    v8 = (_BYTE *)(v5 + 2);
    do
    {
      v9 = *(_BYTE *)(v7++ + 1);
      v10 = v8 + 1;
      if ( v9 != *v10 )
        break;
      v11 = *(_BYTE *)(v7++ + 1);
      v12 = v10 + 1;
      if ( v11 != *v12 )
        break;
      v13 = *(_BYTE *)(v7++ + 1);
      v14 = v12 + 1;
      if ( v13 != *v14 )
        break;
      v15 = *(_BYTE *)(v7++ + 1);
      v16 = v14 + 1;
      if ( v15 != *v16 )
        break;
      v17 = *(_BYTE *)(v7++ + 1);
      v18 = v16 + 1;
      if ( v17 != *v18 )
        break;
      v19 = *(_BYTE *)(v7++ + 1);
      v20 = v18 + 1;
      if ( v19 != *v20 )
        break;
      v21 = *(_BYTE *)(v7++ + 1);
      v22 = v20 + 1;
      if ( v21 != *v22 )
        break;
      v23 = *(_BYTE *)(v7++ + 1);
      v8 = v22 + 1;
      if ( v23 != *v8 )
        break;
    }
    while ( v7 < v6 );
    v24 = *(_DWORD *)(a1 + 5688);
    result = v7 - v6 + 258;
    *(_DWORD *)(a1 + 5684) = a2;
    if ( result > v24 )
      result = v24;
  }
  return result;
}

//----- (1003E1E0) --------------------------------------------------------
int __usercall sub_1003E1E0@<eax>(int result@<eax>, int a2@<edi>, int a3)
{
  int v3; // edx@1
  int v4; // ebp@1
  int v5; // ecx@1
  bool v6; // sf@1
  unsigned __int8 v7; // of@1
  int v8; // esi@3
  int v9; // ebp@3
  unsigned __int16 v10; // dx@3
  unsigned __int16 v11; // bx@3
  int v12; // esi@8
  unsigned __int16 v13; // dx@8
  unsigned __int16 v14; // bx@8
  int v15; // edx@11
  int v16; // [sp+8h] [bp-4h]@1

  v3 = *(_DWORD *)(result + 2324);
  v4 = *(_DWORD *)(result + 4 * a3 + 32);
  v5 = 2 * a3;
  v7 = __OFSUB__(2 * a3, v3);
  v6 = 2 * a3 - v3 < 0;
  v16 = *(_DWORD *)(result + 4 * a3 + 32);
  if ( 2 * a3 > v3 )
  {
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  else
  {
    while ( 1 )
    {
      if ( v6 ^ v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v5 + 36);
        v9 = *(_DWORD *)(result + 4 * v5 + 32);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 2332) <= *(_BYTE *)(result + v9 + 2332) )
          ++v5;
        v4 = v16;
      }
      v12 = *(_DWORD *)(result + 4 * v5 + 32);
      v13 = *(_WORD *)(a2 + 4 * v4);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 32) = v4;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v4 + 2332) <= *(_BYTE *)(v12 + result + 2332) )
        break;
      *(_DWORD *)(result + 4 * a3 + 32) = v12;
      v15 = *(_DWORD *)(result + 2324);
      a3 = v5;
      v5 *= 2;
      v7 = __OFSUB__(v5, v15);
      v6 = v5 - v15 < 0;
      if ( v5 > v15 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  return result;
}

//----- (1003E290) --------------------------------------------------------
int __usercall sub_1003E290@<eax>(int result@<eax>, __int16 a2@<cx>)
{
  int v2; // edi@1

  *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = HIBYTE(a2);
  v2 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v2) = a2;
  ++*(_DWORD *)(result + 5812);
  return result;
}

//----- (1003E2D0) --------------------------------------------------------
unsigned int __usercall sub_1003E2D0@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3)
{
  int v3; // ecx@1
  unsigned int v4; // edi@1
  unsigned int result; // eax@4

  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 > a1 )
    v4 = a1;
  if ( v4 )
  {
    *(_DWORD *)(a2 + 4) -= v4;
    if ( *(_DWORD *)(v3 + 5780) == 1 )
      *(_DWORD *)(a2 + 28) = sub_100400A0(*(_DWORD *)(a2 + 28), *(_BYTE **)a2, v4);
    memcpy(a3, *(const void **)a2, v4);
    *(_DWORD *)a2 += v4;
    *(_DWORD *)(a2 + 8) += v4;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003E330) --------------------------------------------------------
signed int __usercall sub_1003E330@<eax>(signed int result@<eax>, int a2@<ecx>, int a3)
{
  signed int v3; // edi@1
  signed int v4; // edx@1
  signed int v5; // ebp@1
  int v6; // ebx@1
  signed int v7; // ecx@1
  signed int v8; // esi@1
  _WORD *v9; // [sp+10h] [bp-8h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v3 = *(_WORD *)(result + 2);
  v4 = 0;
  v5 = -1;
  v6 = a2;
  v7 = 7;
  v8 = 4;
  if ( !*(_WORD *)(result + 2) )
  {
    v7 = 138;
    v8 = 3;
  }
  *(_WORD *)(result + 4 * v6 + 6) = -1;
  if ( v6 >= 0 )
  {
    v10 = v6 + 1;
    v9 = (_WORD *)(result + 6);
    do
    {
      result = v3;
      v3 = *v9;
      if ( ++v4 >= v7 || result != v3 )
      {
        if ( v4 >= v8 )
        {
          if ( result )
          {
            if ( result != v5 )
              ++*(_WORD *)(a3 + 4 * result + 5472);
            ++*(_WORD *)(a3 + 5536);
          }
          else if ( v4 > 10 )
          {
            ++*(_WORD *)(a3 + 5544);
          }
          else
          {
            ++*(_WORD *)(a3 + 5540);
          }
        }
        else
        {
          *(_WORD *)(a3 + 4 * result + 5472) += v4;
        }
        v4 = 0;
        v5 = result;
        if ( v3 )
        {
          if ( result == v3 )
          {
            v7 = 6;
            v8 = 3;
          }
          else
          {
            v7 = 7;
            v8 = 4;
          }
        }
        else
        {
          v7 = 138;
          v8 = 3;
        }
      }
      v9 += 2;
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (1003E410) --------------------------------------------------------
int __usercall sub_1003E410@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  signed int v3; // esi@1
  int v4; // ebx@1
  signed int v5; // ecx@1
  signed int v6; // edi@1
  signed int v7; // edx@5
  int v8; // edi@8
  int v9; // ecx@8
  unsigned __int16 v10; // si@9
  int v11; // edx@9
  int v12; // ecx@9
  int v13; // edx@9
  __int16 v14; // si@9
  int v15; // ecx@9
  int v16; // ecx@15
  unsigned __int16 v17; // si@16
  int v18; // edi@16
  int v19; // ecx@16
  int v20; // ebx@16
  int v21; // ecx@16
  int v22; // ecx@19
  unsigned __int16 v23; // si@20
  int v24; // edi@20
  int v25; // ecx@20
  int v26; // ebx@20
  int v27; // ecx@20
  int v28; // esi@22
  int v29; // edi@23
  int v30; // ecx@23
  int v31; // ebx@23
  int v32; // ecx@24
  int v33; // ecx@25
  unsigned __int16 v34; // si@27
  int v35; // edi@27
  int v36; // ecx@27
  int v37; // ebx@27
  int v38; // ecx@27
  int v39; // esi@29
  int v40; // edi@30
  int v41; // ecx@30
  int v42; // ebx@30
  unsigned __int16 v43; // si@33
  int v44; // edi@33
  int v45; // ecx@33
  int v46; // ebx@33
  int v47; // ecx@33
  int v48; // esi@35
  int v49; // edi@36
  int v50; // ecx@36
  int v51; // ebx@36
  signed int v52; // [sp+10h] [bp-18h]@5
  signed int v53; // [sp+14h] [bp-14h]@1
  _WORD *v54; // [sp+18h] [bp-10h]@4
  signed int v55; // [sp+1Ch] [bp-Ch]@1
  int v56; // [sp+1Ch] [bp-Ch]@15
  int v57; // [sp+1Ch] [bp-Ch]@19
  int v58; // [sp+1Ch] [bp-Ch]@26
  int v59; // [sp+1Ch] [bp-Ch]@32
  int v60; // [sp+20h] [bp-8h]@4
  signed int v61; // [sp+24h] [bp-4h]@5

  v3 = 0;
  v4 = a3;
  v5 = 7;
  v6 = 4;
  v53 = *(_WORD *)(a2 + 2);
  v55 = -1;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( v4 >= 0 )
  {
    v54 = (_WORD *)(a2 + 6);
    v60 = v4 + 1;
    do
    {
      v7 = v53;
      ++v3;
      v61 = v53;
      v53 = *v54;
      v52 = v3;
      if ( v3 < v5 && v7 == *v54 )
        goto LABEL_44;
      if ( v3 < v6 )
      {
        do
        {
          v8 = *(_WORD *)(result + 4 * v7 + 5474);
          v9 = *(_DWORD *)(result + 2932);
          if ( v9 <= 16 - v8 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v15 = v8 + v9;
          }
          else
          {
            v10 = *(_WORD *)(result + 4 * v7 + 5472);
            v11 = *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v12 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v11;
            *(_BYTE *)(v12 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v13 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v14 = v10 >> (16 - v13);
            v15 = v13 + v8 - 16;
            v7 = v61;
            *(_WORD *)(result + 2924) = v14;
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v15;
          v52 = v3;
        }
        while ( v3 );
        goto LABEL_39;
      }
      if ( v7 )
      {
        if ( v7 != v55 )
        {
          v16 = *(_DWORD *)(result + 2932);
          v56 = *(_WORD *)(result + 4 * v7 + 5474);
          if ( v16 <= 16 - v56 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v21 = v56 + v16;
          }
          else
          {
            v17 = *(_WORD *)(result + 4 * v7 + 5472);
            v18 = *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v19 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v18;
            *(_BYTE *)(v19 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v20 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v21 = v20 + v56 - 16;
            *(_WORD *)(result + 2924) = v17 >> (16 - v20);
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v21;
          v52 = v3;
        }
        v22 = *(_DWORD *)(result + 2932);
        v57 = *(_WORD *)(result + 5538);
        if ( v22 <= 16 - v57 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5536) << v22;
          v27 = v57 + v22;
        }
        else
        {
          v23 = *(_WORD *)(result + 5536);
          v24 = *(_WORD *)(result + 5536) << v22;
          v25 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v24;
          *(_BYTE *)(v25 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v26 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v27 = v26 + v57 - 16;
          *(_WORD *)(result + 2924) = v23 >> (16 - v26);
          v3 = v52;
        }
        v28 = v3 - 3;
        *(_DWORD *)(result + 2932) = v27;
        if ( v27 > 14 )
        {
          v29 = v28 << v27;
          v30 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v29;
          *(_BYTE *)(v30 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v31 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          *(_DWORD *)(result + 2932) = v31 - 14;
          *(_WORD *)(result + 2924) = (unsigned __int16)v28 >> (16 - v31);
          goto LABEL_39;
        }
        *(_WORD *)(result + 2924) |= v28 << v27;
        v32 = v27 + 2;
      }
      else
      {
        v33 = *(_DWORD *)(result + 2932);
        if ( v3 > 10 )
        {
          v59 = *(_WORD *)(result + 5546);
          if ( v33 <= 16 - v59 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5544) << v33;
            v47 = v59 + v33;
          }
          else
          {
            v43 = *(_WORD *)(result + 5544);
            v44 = *(_WORD *)(result + 5544) << v33;
            v45 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v44;
            *(_BYTE *)(v45 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v46 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v47 = v46 + v59 - 16;
            *(_WORD *)(result + 2924) = v43 >> (16 - v46);
            v3 = v52;
          }
          v48 = v3 - 11;
          *(_DWORD *)(result + 2932) = v47;
          if ( v47 > 9 )
          {
            v49 = v48 << v47;
            v50 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v49;
            *(_BYTE *)(v50 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v51 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v51 - 9;
            *(_WORD *)(result + 2924) = (unsigned __int16)v48 >> (16 - v51);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v48 << v47;
          v32 = v47 + 7;
        }
        else
        {
          v58 = *(_WORD *)(result + 5542);
          if ( v33 <= 16 - v58 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5540) << v33;
            v38 = v58 + v33;
          }
          else
          {
            v34 = *(_WORD *)(result + 5540);
            v35 = *(_WORD *)(result + 5540) << v33;
            v36 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v35;
            *(_BYTE *)(v36 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v37 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v38 = v37 + v58 - 16;
            *(_WORD *)(result + 2924) = v34 >> (16 - v37);
            v3 = v52;
          }
          v39 = v3 - 3;
          *(_DWORD *)(result + 2932) = v38;
          if ( v38 > 13 )
          {
            v40 = v39 << v38;
            v41 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v40;
            *(_BYTE *)(v41 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v42 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v42 - 13;
            *(_WORD *)(result + 2924) = (unsigned __int16)v39 >> (16 - v42);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v39 << v38;
          v32 = v38 + 3;
        }
      }
      *(_DWORD *)(result + 2932) = v32;
LABEL_39:
      v3 = 0;
      v55 = v7;
      if ( v53 )
      {
        if ( v7 == v53 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v54 += 2;
      --v60;
    }
    while ( v60 );
  }
  return result;
}

//----- (1003E9B0) --------------------------------------------------------
int __usercall sub_1003E9B0@<eax>(int a1@<eax>)
{
  signed int v1; // ecx@1
  int v2; // edx@2
  signed int v3; // ecx@4
  int v4; // edx@5
  int result; // eax@7
  signed int v6; // ecx@7
  int v7; // edx@9
  signed int v8; // ecx@11
  int v9; // edx@12

  v1 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) |= 2 << v1;
  if ( v1 <= 13 )
  {
    *(_DWORD *)(a1 + 2932) = v1 + 3;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v2 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v2 - 13;
    *(_WORD *)(a1 + 2924) = 2u >> (16 - v2);
  }
  v3 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) = *(_WORD *)(a1 + 2924);
  if ( v3 <= 9 )
  {
    *(_DWORD *)(a1 + 2932) = v3 + 7;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v4 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v4 - 9;
    *(_WORD *)(a1 + 2924) = 0;
  }
  result = sub_1003D5D0(a1);
  v6 = *(_DWORD *)(result + 2932);
  if ( *(_DWORD *)(result + 2928) - v6 + 11 < 9 )
  {
    *(_WORD *)(result + 2924) |= 2 << v6;
    if ( v6 <= 13 )
    {
      *(_DWORD *)(result + 2932) = v6 + 3;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v7 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v7 - 13;
      *(_WORD *)(result + 2924) = 2u >> (16 - v7);
    }
    v8 = *(_DWORD *)(result + 2932);
    *(_WORD *)(result + 2924) = *(_WORD *)(result + 2924);
    if ( v8 > 9 )
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v9 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v9 - 9;
      *(_WORD *)(result + 2924) = 0;
      result = sub_1003D5D0(result);
      *(_DWORD *)(result + 2928) = 7;
      return result;
    }
    *(_DWORD *)(result + 2932) = v8 + 7;
    result = sub_1003D5D0(result);
  }
  *(_DWORD *)(result + 2928) = 7;
  return result;
}

//----- (1003EBF0) --------------------------------------------------------
int __usercall sub_1003EBF0@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4)
{
  int v4; // esi@1
  signed int v5; // ecx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  int result; // eax@2

  v4 = a2;
  v5 = *(_DWORD *)(a1 + 2932);
  if ( v5 <= 13 )
  {
    *(_WORD *)(a1 + 2924) |= v4 << v5;
    *(_DWORD *)(a1 + 2932) = v5 + 3;
    result = sub_1003DB90(a1, a3, a4);
  }
  else
  {
    v6 = v4 << v5;
    v7 = *(_DWORD *)(a1 + 5800);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) = (unsigned __int16)v4 >> (16 - v8);
    *(_DWORD *)(a1 + 2932) = v8 - 13;
    result = sub_1003DB90(a1, a3, a4);
  }
  return result;
}

//----- (1003EC90) --------------------------------------------------------
signed int __usercall sub_1003EC90@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax@1
  int v3; // ebp@1
  signed int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@1
  signed int v7; // eax@8
  signed int i; // ebp@14
  int v9; // ebx@16
  int v10; // eax@17
  int v11; // edx@17
  int v12; // ebp@17
  int v13; // eax@17
  unsigned __int8 v14; // cl@17
  int v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)v2;
  v17 = *(_DWORD *)(v2 + 12);
  v4 = -1;
  v5 = *(_DWORD *)a2;
  v6 = 0;
  v16 = -1;
  *(_DWORD *)(a1 + 2324) = 0;
  for ( *(_DWORD *)(a1 + 2328) = 573; v6 < v17; ++v6 )
  {
    if ( *(_WORD *)(v5 + 4 * v6) )
    {
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v6;
      v16 = v6;
      *(_BYTE *)(v6 + a1 + 2332) = 0;
      v4 = v6;
    }
    else
    {
      *(_WORD *)(v5 + 4 * v6 + 2) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 2324) < 2 )
  {
    do
    {
      if ( v4 >= 2 )
        v7 = 0;
      else
        v7 = ++v4;
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v7;
      *(_WORD *)(v5 + 4 * v7) = 1;
      *(_BYTE *)(a1 + v7 + 2332) = 0;
      --*(_DWORD *)(a1 + 2912);
      if ( v3 )
        *(_DWORD *)(a1 + 2916) -= *(_WORD *)(v3 + 4 * v7 + 2);
    }
    while ( *(_DWORD *)(a1 + 2324) < 2 );
    v16 = v4;
  }
  *(_DWORD *)(a2 + 4) = v4;
  for ( i = *(_DWORD *)(a1 + 2324) / 2; i >= 1; --i )
    sub_1003E1E0(a1, v5, i);
  v9 = v17;
  do
  {
    v10 = *(_DWORD *)(a1 + 2324);
    v11 = *(_DWORD *)(a1 + 4 * v10 + 32);
    v12 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 2324) = v10 - 1;
    *(_DWORD *)(a1 + 36) = v11;
    sub_1003E1E0(a1, v5, 1);
    v13 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v12;
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v13;
    *(_WORD *)(v5 + 4 * v9) = *(_WORD *)(v5 + 4 * v12) + *(_WORD *)(v5 + 4 * v13);
    v14 = *(_BYTE *)(a1 + v13 + 2332);
    if ( *(_BYTE *)(a1 + v12 + 2332) >= v14 )
      v14 = *(_BYTE *)(a1 + v12 + 2332);
    *(_BYTE *)(a1 + v9 + 2332) = v14 + 1;
    *(_WORD *)(v5 + 4 * v13 + 2) = v9;
    *(_WORD *)(v5 + 4 * v12 + 2) = v9;
    *(_DWORD *)(a1 + 36) = v9++;
    sub_1003E1E0(a1, v5, 1);
  }
  while ( *(_DWORD *)(a1 + 2324) >= 2 );
  *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = *(_DWORD *)(a1 + 36);
  sub_1003DCA0(a1, a2);
  return sub_1003DE70(a1, v16, v5);
}

//----- (1003EE70) --------------------------------------------------------
unsigned int __usercall sub_1003EE70@<eax>(int a1@<edi>)
{
  size_t v1; // ebx@1
  unsigned int result; // eax@2
  unsigned int v3; // ebp@2
  int v4; // edx@3
  int v5; // eax@3
  _WORD *v6; // ecx@3
  int v7; // eax@4
  __int16 v8; // ax@5
  size_t v9; // edx@8
  _WORD *v10; // ecx@8
  int v11; // eax@9
  int v12; // esi@14
  unsigned int v13; // edx@15
  int v14; // esi@16
  int v15; // eax@16
  int v16; // ecx@16

  v1 = *(_DWORD *)(a1 + 5748);
  do
  {
    result = *(_DWORD *)(a1 + 5680);
    v3 = *(_DWORD *)(a1 + 5744) - result - *(_DWORD *)(a1 + 5688);
    if ( result >= v1 + *(_DWORD *)(a1 + 5748) - 262 )
    {
      memcpy(*(void **)(a1 + 5740), (const void *)(*(_DWORD *)(a1 + 5740) + v1), v1);
      v4 = *(_DWORD *)(a1 + 5764);
      v5 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5684) -= v1;
      *(_DWORD *)(a1 + 5680) -= v1;
      *(_DWORD *)(a1 + 5664) -= v1;
      v6 = (_WORD *)(v5 + 2 * v4);
      do
      {
        v7 = *(v6 - 1);
        --v6;
        if ( v7 < v1 )
          v8 = 0;
        else
          v8 = v7 - v1;
        --v4;
        *v6 = v8;
      }
      while ( v4 );
      v9 = v1;
      v10 = (_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * v1);
      do
      {
        v11 = *(v10 - 1);
        --v10;
        if ( v11 < v1 )
          result = 0;
        else
          result = v11 - v1;
        --v9;
        *v10 = result;
      }
      while ( v9 );
      v3 += v1;
    }
    v12 = *(_DWORD *)(a1 + 2908);
    if ( !*(_DWORD *)(v12 + 4) )
      break;
    result = sub_1003E2D0(v3, v12, (void *)(*(_DWORD *)(a1 + 5688) + *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)));
    *(_DWORD *)(a1 + 5688) += result;
    v13 = *(_DWORD *)(a1 + 5688);
    if ( v13 >= 3 )
    {
      v14 = *(_DWORD *)(a1 + 5680) + *(_DWORD *)(a1 + 5740);
      v15 = *(_BYTE *)v14;
      v16 = *(_DWORD *)(a1 + 5776);
      *(_DWORD *)(a1 + 5760) = v15;
      result = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v14 + 1) ^ (v15 << v16));
      *(_DWORD *)(a1 + 5760) = result;
    }
  }
  while ( v13 < 0x106 && *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 4) );
  return result;
}

//----- (1003EFB0) --------------------------------------------------------
int __usercall sub_1003EFB0@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  signed int v9; // ecx@4
  int v10; // edx@5
  int v11; // ecx@5
  int v12; // edx@5
  signed int v13; // ecx@7
  int v14; // edx@8
  int v15; // ecx@8
  int v16; // edx@8
  int i; // edi@10
  signed int v18; // ecx@11
  int v19; // edx@11
  unsigned __int16 v20; // si@12
  int v21; // edx@12
  int v22; // ecx@12
  int v23; // edx@12
  int v24; // eax@15

  v4 = *(_DWORD *)(a1 + 2932);
  v5 = a4;
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 2932) = v4 + 5;
  }
  else
  {
    v6 = (a2 - 257) << v4;
    v7 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    v5 = a4;
    *(_DWORD *)(a1 + 2932) = v8 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a2 - 257) >> (16 - v8);
  }
  v9 = *(_DWORD *)(a1 + 2932);
  if ( v9 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a3 - 1) << v9;
    *(_DWORD *)(a1 + 2932) = v9 + 5;
  }
  else
  {
    v10 = (a3 - 1) << v9;
    v11 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v10;
    *(_BYTE *)(v11 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v12 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v12 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a3 - 1) >> (16 - v12);
  }
  v13 = *(_DWORD *)(a1 + 2932);
  if ( v13 <= 12 )
  {
    *(_WORD *)(a1 + 2924) |= (v5 - 4) << v13;
    *(_DWORD *)(a1 + 2932) = v13 + 4;
  }
  else
  {
    v14 = (v5 - 4) << v13;
    v15 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v14;
    *(_BYTE *)(v15 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v16 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v16 - 12;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(v5 - 4) >> (16 - v16);
  }
  for ( i = 0; i < v5; ++i )
  {
    v18 = *(_DWORD *)(a1 + 2932);
    v19 = (unsigned __int8)byte_100B3D6C[i];
    if ( v18 <= 13 )
    {
      *(_WORD *)(a1 + 2924) |= *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      *(_DWORD *)(a1 + 2932) = v18 + 3;
    }
    else
    {
      v20 = *(_WORD *)(a1 + 4 * v19 + 5474);
      v21 = *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      v22 = *(_DWORD *)(a1 + 5812);
      *(_WORD *)(a1 + 2924) |= v21;
      *(_BYTE *)(v22 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
      *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
      v23 = *(_DWORD *)(a1 + 2932);
      ++*(_DWORD *)(a1 + 5812);
      v5 = a4;
      *(_DWORD *)(a1 + 2932) = v23 - 13;
      *(_WORD *)(a1 + 2924) = v20 >> (16 - v23);
    }
  }
  v24 = sub_1003E410(a1, a1 + 2936, a2 - 1);
  return sub_1003E410(v24, v24 + 5228, a3 - 1);
}

//----- (1003F260) --------------------------------------------------------
signed int __cdecl sub_1003F260(int a1, int a2)
{
  int v2; // esi@3
  int v3; // eax@6
  signed int result; // eax@9
  int v5; // ebx@10
  char v6; // al@12
  int v7; // eax@14
  unsigned int v8; // ecx@17
  int v9; // eax@19
  int v10; // eax@20
  int v11; // eax@29
  signed int v12; // eax@36
  int v13; // eax@50
  bool v14; // zf@50

  if ( !a1 || (unsigned int)a2 > 4 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  if ( !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) )
    return -2;
  v3 = *(_DWORD *)(v2 + 5788);
  if ( v3 == 666 && a2 != 4 )
    return -2;
  if ( !*(_DWORD *)(a1 + 16) )
    return -5;
  v5 = *(_DWORD *)(v2 + 5792);
  *(_DWORD *)(v2 + 2908) = a1;
  *(_DWORD *)(v2 + 5792) = a2;
  if ( v3 == 42 )
  {
    if ( *(_BYTE *)(v2 + 5796) >= 2 || (v6 = *(_BYTE *)(v2 + 5784), v6 < 2) )
    {
      v7 = 0;
    }
    else if ( v6 >= 6 )
    {
      v7 = (v6 != 6) + 2;
    }
    else
    {
      v7 = 1;
    }
    v8 = (v7 << 6) | (((*(_DWORD *)(v2 + 5752) - 8) << 12) + 2048);
    if ( *(_DWORD *)(v2 + 5680) )
      v8 |= 0x20u;
    *(_DWORD *)(v2 + 5788) = 113;
    v9 = sub_1003E290(v2, 31 * (v8 / 0x1F + 1));
    if ( *(_DWORD *)(v2 + 5680) )
    {
      v10 = sub_1003E290(v9, *(_WORD *)(a1 + 30));
      sub_1003E290(v10, *(_WORD *)(a1 + 28));
    }
    *(_DWORD *)(a1 + 28) = sub_100400A0(0, 0, 0);
  }
  if ( *(_DWORD *)(v2 + 5812) )
  {
    sub_1003DC40(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
LABEL_24:
      *(_DWORD *)(v2 + 5792) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v5 && a2 != 4 )
  {
    return -5;
  }
  v11 = *(_DWORD *)(v2 + 5788);
  if ( v11 == 666 )
  {
    if ( *(_DWORD *)(a1 + 4) )
      return -5;
LABEL_33:
    if ( !*(_DWORD *)(v2 + 5688) && (!a2 || v11 == 666) )
      goto LABEL_47;
    goto LABEL_36;
  }
  if ( !*(_DWORD *)(a1 + 4) )
    goto LABEL_33;
LABEL_36:
  v12 = (*(&off_100B46E8 + 3 * *(_BYTE *)(v2 + 5784)))(v2, a2);
  if ( v12 == 2 || v12 == 3 )
    *(_DWORD *)(v2 + 5788) = 666;
  if ( !v12 || v12 == 2 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      return 0;
    *(_DWORD *)(v2 + 5792) = -1;
    return 0;
  }
  if ( v12 == 1 )
  {
    if ( a2 == 1 )
    {
      sub_1003E9B0(v2);
    }
    else
    {
      sub_1003EBF0(v2, 0, 0, 0);
      if ( a2 == 3 )
      {
        *(_WORD *)(*(_DWORD *)(v2 + 5736) + 2 * *(_DWORD *)(v2 + 5764) - 2) = 0;
        memset(*(void **)(v2 + 5736), 0, 2 * *(_DWORD *)(v2 + 5764) - 2);
      }
    }
    sub_1003DC40(a1);
    if ( !*(_DWORD *)(a1 + 16) )
      goto LABEL_24;
  }
LABEL_47:
  if ( a2 != 4 )
    return 0;
  if ( *(_DWORD *)(v2 + 5780) > 0 )
  {
    v13 = sub_1003E290(v2, *(_WORD *)(a1 + 30));
    sub_1003E290(v13, *(_WORD *)(a1 + 28));
    sub_1003DC40(a1);
    v14 = *(_DWORD *)(v2 + 5812) == 0;
    *(_DWORD *)(v2 + 5780) = -*(_DWORD *)(v2 + 5780);
    result = v14;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 100B46E8: using guessed type int (__cdecl *off_100B46E8)(int, int);

//----- (1003F520) --------------------------------------------------------
signed int __usercall sub_1003F520@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  signed int result; // eax@1

  v1 = a1;
  sub_1003E330(a1 + 2936, *(_DWORD *)(a1 + 5632), a1);
  sub_1003E330(v1 + 5228, *(_DWORD *)(v1 + 5644), v1);
  sub_1003EC90(v1, v1 + 5652);
  result = 18;
  while ( !*(_WORD *)(v1 + 4 * (unsigned __int8)byte_100B3D6C[result] + 5474) )
  {
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100B3D6B[result] + 5474) )
    {
      *(_DWORD *)(v1 + 2912) += 3 * --result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100B3D6A[result] + 5474) )
    {
      result -= 2;
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100B3D69[result] + 5474) )
    {
      result -= 3;
      break;
    }
    result -= 4;
    if ( result < 3 )
    {
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
  }
  *(_DWORD *)(v1 + 2912) += 3 * result + 17;
  return result;
}

//----- (1003F5F0) --------------------------------------------------------
_WORD *__usercall sub_1003F5F0@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // eax@1
  _BYTE *v7; // edi@2
  signed int v8; // eax@5
  unsigned int v9; // edx@5
  unsigned int v10; // ecx@5
  int v11; // ecx@11
  bool v12; // zf@12
  signed int v13; // ecx@12
  int v14; // eax@13
  int v15; // edx@14
  int v16; // ecx@14
  int v17; // edx@14
  int v18; // edx@17
  int v19; // eax@18
  int v20; // ecx@18
  int v21; // ebx@18
  _WORD *result; // eax@21
  signed int v23; // [sp+14h] [bp+4h]@4

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(_DWORD *)(a2 + 5664);
  if ( v6 < 0 )
    v7 = 0;
  else
    v7 = (_BYTE *)(v6 + *(_DWORD *)(a2 + 5740));
  v23 = 0;
  if ( *(_BYTE *)(a2 + 5784) <= 0 )
  {
    v10 = v5 + 5;
LABEL_8:
    v9 = v10;
    goto LABEL_9;
  }
  sub_1003EC90(a2, a2 + 5628);
  sub_1003EC90(v4, v4 + 5640);
  v8 = sub_1003F520(v4);
  v9 = (unsigned int)(*(_DWORD *)(v4 + 2912) + 10) >> 3;
  v10 = (unsigned int)(*(_DWORD *)(v4 + 2916) + 10) >> 3;
  v23 = v8;
  if ( v10 <= v9 )
    goto LABEL_8;
LABEL_9:
  if ( v5 + 4 <= v9 && v7 )
  {
    sub_1003EBF0(v4, v3, v7, v5);
  }
  else
  {
    v12 = v10 == v9;
    v13 = *(_DWORD *)(v4 + 2932);
    if ( v12 )
    {
      v14 = v3 + 2;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v14 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v15 = v14 << v13;
        v16 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v15;
        *(_BYTE *)(v16 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v17 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v17 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v14 >> (16 - v17);
      }
      sub_1003D710(v4, (int)&unk_100B3DF8, (int)&unk_100B4278);
    }
    else
    {
      v18 = v3 + 4;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v18 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v19 = v18 << v13;
        v20 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v19;
        *(_BYTE *)(v20 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v21 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v21 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v18 >> (16 - v21);
      }
      sub_1003EFB0(v4, *(_DWORD *)(v4 + 5632) + 1, *(_DWORD *)(v4 + 5644) + 1, v23 + 1);
      sub_1003D710(v4, v4 + 2936, v4 + 5228);
    }
  }
  result = sub_1003DEF0(v11, v4);
  if ( v3 )
    result = (_WORD *)sub_1003D680(v4);
  return result;
}

//----- (1003F810) --------------------------------------------------------
signed int __cdecl sub_1003F810(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  int v4; // edx@7
  int v5; // edi@7
  int v6; // eax@7
  int v7; // ecx@7
  unsigned int v8; // eax@9
  char v9; // cl@10
  unsigned int v10; // eax@11
  unsigned int v11; // eax@16
  BOOL v12; // eax@17
  unsigned int v13; // ecx@17
  int v14; // edi@20
  int v15; // ecx@20
  int v16; // edx@20
  int v17; // ebx@20
  int v19; // edi@22
  int v20; // ecx@22
  int v21; // edx@22
  int v22; // edi@26
  signed int result; // eax@27
  int v24; // edi@28
  int v25; // eax@28

  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_1003EE70(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    if ( v2 )
    {
      v8 = *(_DWORD *)(a1 + 5680) - v2;
      if ( v8 <= *(_DWORD *)(a1 + 5748) - 262 )
      {
        v9 = *(_BYTE *)(a1 + 5796);
        if ( v9 < 2 )
        {
          v10 = sub_1003DF60(a1, v2);
LABEL_15:
          *(_DWORD *)(a1 + 5668) = v10;
          goto LABEL_16;
        }
        if ( v9 == 3 && v8 == 1 )
        {
          v10 = sub_1003E110(a1, v2);
          goto LABEL_15;
        }
      }
    }
LABEL_16:
    v11 = *(_DWORD *)(a1 + 5668);
    if ( v11 < 3 )
    {
      v12 = sub_1003D530(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)), 0);
      --*(_DWORD *)(a1 + 5688);
    }
    else
    {
      v12 = sub_1003D530(a1, v11 - 3, *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684));
      v13 = *(_DWORD *)(a1 + 5668);
      *(_DWORD *)(a1 + 5688) -= v13;
      if ( v13 > *(_DWORD *)(a1 + 5700) || *(_DWORD *)(a1 + 5688) < 3u )
      {
        *(_DWORD *)(a1 + 5680) += v13;
        v19 = *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680);
        v20 = *(_DWORD *)(a1 + 5776);
        *(_DWORD *)(a1 + 5668) = 0;
        v21 = *(_BYTE *)v19;
        *(_DWORD *)(a1 + 5760) = v21;
        *(_DWORD *)(a1 + 5760) = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v19 + 1) ^ (v21 << v20));
        goto LABEL_25;
      }
      *(_DWORD *)(a1 + 5668) = v13 - 1;
      do
      {
        v14 = ++*(_DWORD *)(a1 + 5680);
        v15 = *(_DWORD *)(a1 + 5736);
        v16 = *(_DWORD *)(a1 + 5772) & ((*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)) ^ *(_BYTE *)(*(_DWORD *)(a1 + 5740) + v14 + 2));
        v17 = *(_DWORD *)(a1 + 5756);
        *(_DWORD *)(a1 + 5760) = v16;
        *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v14 & v17)) = *(_WORD *)(v15 + 2 * v16);
        v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
        *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
      }
      while ( (*(_DWORD *)(a1 + 5668))-- != 1 );
    }
    ++*(_DWORD *)(a1 + 5680);
LABEL_25:
    if ( v12 )
    {
      sub_1003F5F0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
      v22 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_1003DC40(v22);
      if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        return 0;
    }
  }
  sub_1003F5F0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v24 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_1003DC40(v24);
  v25 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v25) = a2 == 4;
    result = 2 * v25 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (1003FB20) --------------------------------------------------------
signed int __cdecl sub_1003FB20(int a1, int a2)
{
  unsigned int v2; // ebp@1
  unsigned int v3; // eax@3
  int v4; // edx@8
  int v5; // edi@8
  int v6; // eax@8
  int v7; // ecx@8
  unsigned int v8; // ecx@9
  int v9; // edx@9
  unsigned int v10; // eax@11
  char v11; // cl@12
  unsigned int v12; // eax@13
  unsigned int v13; // eax@18
  unsigned int v14; // eax@23
  int v15; // ecx@25
  unsigned int v16; // ebp@25
  BOOL v17; // eax@25
  int v18; // ecx@25
  BOOL v19; // ebx@25
  unsigned int v20; // edi@26
  int v21; // ecx@27
  int v22; // edx@27
  int v23; // eax@27
  int v25; // eax@29
  int v26; // edi@30
  signed int result; // eax@31
  int v28; // edi@34
  int v29; // ecx@35
  int v30; // edi@40
  unsigned int v31; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v31 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_1003EE70(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    v8 = *(_DWORD *)(a1 + 5668);
    v9 = *(_DWORD *)(a1 + 5684);
    *(_DWORD *)(a1 + 5692) = v8;
    *(_DWORD *)(a1 + 5672) = v9;
    *(_DWORD *)(a1 + 5668) = 2;
    if ( !v2 )
      goto LABEL_23;
    if ( v8 >= *(_DWORD *)(a1 + 5700) )
      goto LABEL_23;
    v10 = *(_DWORD *)(a1 + 5680) - v2;
    if ( v10 > *(_DWORD *)(a1 + 5748) - 262 )
      goto LABEL_23;
    v11 = *(_BYTE *)(a1 + 5796);
    if ( v11 < 2 )
    {
      v12 = sub_1003DF60(a1, v2);
LABEL_17:
      *(_DWORD *)(a1 + 5668) = v12;
      goto LABEL_18;
    }
    if ( v11 == 3 && v10 == 1 )
    {
      v12 = sub_1003E110(a1, v2);
      goto LABEL_17;
    }
LABEL_18:
    v13 = *(_DWORD *)(a1 + 5668);
    if ( v13 <= 5
      && (*(_BYTE *)(a1 + 5796) == 1
       || v13 == 3 && (unsigned int)(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684)) > 0x1000) )
    {
      *(_DWORD *)(a1 + 5668) = 2;
    }
LABEL_23:
    v14 = *(_DWORD *)(a1 + 5692);
    if ( v14 < 3 || *(_DWORD *)(a1 + 5668) > v14 )
    {
      if ( *(_DWORD *)(a1 + 5676) )
      {
        if ( sub_1003D530(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0) )
        {
          sub_1003F5F0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
          v28 = *(_DWORD *)(a1 + 2908);
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
          sub_1003DC40(v28);
        }
        v29 = *(_DWORD *)(a1 + 2908);
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        if ( !*(_DWORD *)(v29 + 16) )
          return 0;
      }
      else
      {
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        *(_DWORD *)(a1 + 5676) = 1;
      }
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 5680);
      v16 = v15 + *(_DWORD *)(a1 + 5688) - 3;
      v17 = sub_1003D530(a1, v14 - 3, v15 - *(_DWORD *)(a1 + 5672) - 1);
      v18 = *(_DWORD *)(a1 + 5692);
      v19 = v17;
      *(_DWORD *)(a1 + 5688) += 1 - v18;
      *(_DWORD *)(a1 + 5692) = v18 - 2;
      do
      {
        v20 = ++*(_DWORD *)(a1 + 5680);
        if ( v20 <= v16 )
        {
          v21 = *(_DWORD *)(a1 + 5736);
          v22 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v20 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
          v23 = *(_DWORD *)(a1 + 5756);
          *(_DWORD *)(a1 + 5760) = v22;
          *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v20 & v23)) = *(_WORD *)(v21 + 2 * v22);
          v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
          *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
        }
      }
      while ( (*(_DWORD *)(a1 + 5692))-- != 1 );
      v25 = ++*(_DWORD *)(a1 + 5680);
      *(_DWORD *)(a1 + 5676) = 0;
      *(_DWORD *)(a1 + 5668) = 2;
      if ( v19 )
      {
        sub_1003F5F0(v25 - *(_DWORD *)(a1 + 5664), a1, 0);
        v26 = *(_DWORD *)(a1 + 2908);
        *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
        sub_1003DC40(v26);
        if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
          return 0;
      }
      v2 = v31;
    }
  }
  if ( *(_DWORD *)(a1 + 5676) )
  {
    sub_1003D530(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0);
    *(_DWORD *)(a1 + 5676) = 0;
  }
  sub_1003F5F0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v30 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_1003DC40(v30);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
    result = 2 * (a2 == 4) + 1;
  else
    result = a2 != 4 ? 0 : 2;
  return result;
}

//----- (1003FF30) --------------------------------------------------------
signed int __cdecl sub_1003FF30(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // eax@3
  bool v4; // zf@5
  int v5; // edx@5
  unsigned int v6; // ecx@5
  unsigned int v7; // eax@5
  int v8; // edi@7
  unsigned int v9; // eax@8
  int v10; // edi@9
  signed int result; // eax@10
  int v12; // edi@12
  int v13; // eax@12

  v2 = 0xFFFF;
  if ( (unsigned int)(*(_DWORD *)(a1 + 5804) - 5) <= 0xFFFF )
    v2 = *(_DWORD *)(a1 + 5804) - 5;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 <= 1 )
    {
      sub_1003EE70(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( !v3 )
        break;
    }
    v4 = v3 + *(_DWORD *)(a1 + 5680) == 0;
    *(_DWORD *)(a1 + 5680) += v3;
    v5 = *(_DWORD *)(a1 + 5664);
    v6 = *(_DWORD *)(a1 + 5680);
    *(_DWORD *)(a1 + 5688) = 0;
    v7 = v5 + v2;
    if ( !v4 && v6 < v7
      || (*(_DWORD *)(a1 + 5688) = v6 - v7,
          *(_DWORD *)(a1 + 5680) = v7,
          sub_1003F5F0(v2, a1, 0),
          v8 = *(_DWORD *)(a1 + 2908),
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680),
          sub_1003DC40(v8),
          *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16)) )
    {
      v9 = *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664);
      if ( v9 < *(_DWORD *)(a1 + 5748) - 262 )
        continue;
      sub_1003F5F0(v9, a1, 0);
      v10 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_1003DC40(v10);
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  sub_1003F5F0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v12 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_1003DC40(v12);
  v13 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v13) = a2 == 4;
    result = 2 * v13 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (100400A0) --------------------------------------------------------
int __cdecl sub_100400A0(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edi@1
  unsigned int v4; // ecx@1
  unsigned int v5; // esi@1
  int result; // eax@2
  unsigned int i; // ebp@3
  unsigned int v8; // ebx@4
  int v9; // eax@8
  signed int v10; // edx@8
  int v11; // ecx@9
  int v12; // esi@9
  int v13; // ecx@9
  int v14; // esi@9
  int v15; // ecx@9
  int v16; // esi@9
  unsigned int v17; // [sp+Ch] [bp+4h]@7

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = a1 >> 16;
  if ( a2 )
  {
    for ( i = a3; i; v5 %= 0xFFF1u )
    {
      v8 = i;
      if ( i >= 0x15B0 )
        v8 = 5552;
      i -= v8;
      if ( (signed int)v8 >= 16 )
      {
        v17 = v8 >> 4;
        v8 += -16 * (v8 >> 4);
        do
        {
          v9 = (int)(v3 + 1);
          v10 = 4;
          do
          {
            v11 = *(_BYTE *)(v9 - 1) + v4;
            v12 = v11 + v5;
            v13 = *(_BYTE *)v9 + v11;
            v14 = v13 + v12;
            v15 = *(_BYTE *)(v9 + 1) + v13;
            v16 = v15 + v14;
            v4 = *(_BYTE *)(v9 + 2) + v15;
            v5 = v4 + v16;
            v9 += 4;
            --v10;
          }
          while ( v10 );
          v3 += 16;
          --v17;
        }
        while ( v17 );
      }
      for ( ; v8; --v8 )
      {
        v4 += *v3++;
        v5 += v4;
      }
      v4 %= 0xFFF1u;
    }
    result = v4 | (v5 << 16);
  }
  else
  {
    result = (int)(a2 + 1);
  }
  return result;
}

//----- (100401A0) --------------------------------------------------------
signed int __cdecl sub_100401A0(int a1)
{
  signed int result; // eax@3

  if ( a1 && *(_DWORD *)(a1 + 24) )
  {
    *(_DWORD *)(a1 + 24) = 0;
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (100401C0) --------------------------------------------------------
signed int __usercall sub_100401C0@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10)
{
  unsigned int v10; // ebp@1
  unsigned int *v11; // edi@1
  _DWORD *v12; // eax@1
  unsigned int v13; // edx@1
  signed int result; // eax@4
  unsigned int v15; // eax@5
  int v16; // ecx@7
  signed int v17; // edx@9
  signed int v18; // esi@13
  int i; // edi@13
  int v20; // esi@14
  int v21; // edi@16
  int v22; // esi@16
  int v23; // edi@17
  int v24; // ebx@17
  int v25; // esi@17
  int v26; // edi@18
  _DWORD *v27; // edi@20
  unsigned int v28; // ebx@20
  int v29; // esi@21
  int v30; // edi@22
  signed int v31; // edi@24
  int v32; // ebx@24
  unsigned int v33; // esi@25
  int v34; // edx@27
  int l; // ebp@28
  unsigned int v36; // edx@31
  unsigned int v37; // ecx@33
  int *v38; // ebp@34
  int v39; // eax@34
  unsigned int v40; // edi@36
  unsigned int v41; // eax@36
  unsigned int v42; // edx@39
  int v43; // eax@40
  unsigned int v44; // eax@41
  int v45; // ecx@41
  int v46; // esi@48
  signed int v47; // edx@50
  unsigned int v48; // eax@50
  int v49; // ecx@51
  unsigned int j; // eax@54
  int v51; // [sp+Ch] [bp-F4h]@7
  unsigned int v52; // [sp+Ch] [bp-F4h]@24
  signed int v53; // [sp+Ch] [bp-F4h]@31
  unsigned int v54; // [sp+10h] [bp-F0h]@9
  int v55; // [sp+14h] [bp-ECh]@24
  int v56; // [sp+18h] [bp-E8h]@26
  _DWORD *v57; // [sp+1Ch] [bp-E4h]@21
  int v58; // [sp+1Ch] [bp-E4h]@31
  unsigned int k; // [sp+20h] [bp-E0h]@24
  int *v60; // [sp+24h] [bp-DCh]@25
  int v61; // [sp+28h] [bp-D8h]@0
  unsigned int v62; // [sp+2Ch] [bp-D4h]@0
  int v63; // [sp+30h] [bp-D0h]@24
  unsigned int *v64; // [sp+34h] [bp-CCh]@24
  int v65; // [sp+38h] [bp-C8h]@11
  int v66; // [sp+3Ch] [bp-C4h]@31
  int v67; // [sp+40h] [bp-C0h]@16
  int v68; // [sp+44h] [bp-BCh]@1
  int v69; // [sp+48h] [bp-B8h]@1
  int v70; // [sp+4Ch] [bp-B4h]@1
  int v71; // [sp+50h] [bp-B0h]@1
  int v72; // [sp+54h] [bp-ACh]@1
  int v73; // [sp+58h] [bp-A8h]@1
  int v74; // [sp+5Ch] [bp-A4h]@1
  int v75; // [sp+60h] [bp-A0h]@1
  int v76; // [sp+64h] [bp-9Ch]@1
  int v77; // [sp+68h] [bp-98h]@1
  int v78; // [sp+6Ch] [bp-94h]@1
  int v79; // [sp+70h] [bp-90h]@1
  int v80; // [sp+74h] [bp-8Ch]@1
  int v81; // [sp+78h] [bp-88h]@1
  int v82; // [sp+7Ch] [bp-84h]@1
  int v83; // [sp+80h] [bp-80h]@1
  int v84; // [sp+84h] [bp-7Ch]@22
  int v85[14]; // [sp+88h] [bp-78h]@17
  int v86; // [sp+C0h] [bp-40h]@41
  int v87[15]; // [sp+C4h] [bp-3Ch]@24
  int v88; // [sp+108h] [bp+8h]@24

  v10 = 0;
  v11 = a1;
  v12 = a2;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v13 = a3;
  do
  {
    ++*(&v68 + *v12);
    ++v12;
    --v13;
  }
  while ( v13 );
  if ( v68 == a3 )
  {
    *a7 = 0;
    *v11 = 0;
    return 0;
  }
  v15 = 1;
  if ( !v69 )
  {
    do
      ++v15;
    while ( !*(&v68 + v15) );
  }
  v16 = v15;
  v51 = v15;
  if ( *v11 > v15 )
    v15 = *v11;
  v54 = v15;
  v17 = 15;
  if ( !v83 )
  {
    do
      --v17;
    while ( !*(&v68 + v17) );
  }
  v65 = v17;
  if ( (signed int)v15 > v17 )
  {
    v54 = v17;
    v15 = v17;
  }
  v18 = 1 << v16;
  *v11 = v15;
  for ( i = v16; i < v17; v18 = 2 * v20 )
  {
    v20 = v18 - *(&v68 + i);
    if ( v20 < 0 )
      return -3;
    ++i;
  }
  v21 = *(&v68 + v17);
  v22 = v18 - v21;
  v67 = v22;
  if ( v22 < 0 )
    return -3;
  v23 = v22 + v21;
  v24 = v17 - 1;
  v25 = 0;
  *(&v68 + v17) = v23;
  v85[0] = 0;
  if ( v17 != 1 )
  {
    v26 = 0;
    do
    {
      v25 += *(int *)((char *)&v69 + v26 * 4);
      ++v26;
      --v24;
      v85[v26] = v25;
    }
    while ( v24 );
  }
  v27 = a2;
  v28 = 0;
  do
  {
    v29 = *v27;
    ++v27;
    v57 = v27;
    if ( v29 )
    {
      v30 = *(&v84 + v29);
      a10[v30] = v28;
      v16 = v51;
      *(&v84 + v29) = v30 + 1;
      v27 = v57;
    }
    ++v28;
  }
  while ( v28 < a3 );
  v88 = *(&v84 + v17);
  v31 = -1;
  v32 = -v15;
  v84 = 0;
  k = 0;
  v64 = a10;
  v87[0] = 0;
  v63 = 0;
  v52 = 0;
  v55 = v16;
  if ( v16 > v17 )
  {
LABEL_60:
    if ( v67 && v17 != 1 )
      result = -5;
    else
      result = 0;
  }
  else
  {
    v33 = v62;
    v60 = &v68 + v16;
    while ( 1 )
    {
      v56 = *v60;
      if ( *v60 )
        break;
LABEL_59:
      v17 = v65;
      ++v60;
      v55 = ++v16;
      if ( v16 > v65 )
        goto LABEL_60;
    }
    while ( 1 )
    {
      --v56;
      v34 = v32 + v15;
      if ( (signed int)(v32 + v15) < v16 )
        break;
LABEL_44:
      BYTE1(v61) = v16 - v32;
      if ( v64 < &a10[v88] )
      {
        v33 = *v64;
        if ( *v64 >= a4 )
        {
          v46 = 4 * (v33 - a4);
          LOBYTE(v61) = *(_BYTE *)(v46 + a6) + 80;
          v33 = *(_DWORD *)(v46 + a5);
        }
        else
        {
          LOBYTE(v61) = v33 < 0x100 ? 0 : 96;
        }
        ++v64;
      }
      else
      {
        LOBYTE(v61) = -64;
      }
      v47 = 1 << (v16 - v32);
      v48 = v10 >> v32;
      if ( v10 >> v32 < v52 )
      {
        v49 = v63 + 8 * v48;
        do
        {
          *(_DWORD *)v49 = v61;
          *(_DWORD *)(v49 + 4) = v33;
          v48 += v47;
          v49 += 8 * v47;
        }
        while ( v48 < v52 );
        v10 = k;
      }
      for ( j = 1 << (v55 - 1); v10 & j; j >>= 1 )
        v10 ^= j;
      v10 ^= j;
      for ( k = v10; (v10 & ((1 << v32) - 1)) != *(&v84 + v31); --v31 )
        v32 -= v54;
      v15 = v54;
      v16 = v55;
      if ( !v56 )
        goto LABEL_59;
    }
    for ( l = v32 - v15; ; l = v58 )
    {
      v66 = v15 + v34;
      v32 += v15;
      ++v31;
      v36 = v65 - v32;
      v53 = v31;
      v58 = v15 + l;
      if ( v65 - v32 > v15 )
        v36 = v15;
      v37 = v16 - v32;
      if ( 1 << v37 > (unsigned int)(v56 + 1) )
      {
        v38 = v60;
        v39 = -1 - v56 + (1 << v37);
        if ( v37 < v36 )
        {
          while ( ++v37 < v36 )
          {
            v40 = v38[1];
            ++v38;
            v41 = 2 * v39;
            if ( v41 <= v40 )
              break;
            v39 = v41 - v40;
          }
        }
        v31 = v53;
      }
      v52 = 1 << v37;
      v42 = *a9 + (1 << v37);
      if ( v42 > 0x5A0 )
        break;
      v43 = a8 + 8 * *a9;
      *a9 = v42;
      v10 = k;
      v87[v31] = v43;
      v63 = v43;
      if ( v31 )
      {
        LOBYTE(v61) = v37;
        v44 = k >> v58;
        v45 = *(&v86 + v31);
        BYTE1(v61) = v54;
        v33 = ((v63 - v45) >> 3) - (k >> v58);
        *(_DWORD *)(v45 + 8 * v44) = v61;
        *(&v84 + v31) = k;
        *(_DWORD *)(v45 + 8 * v44 + 4) = v33;
      }
      else
      {
        *a7 = v43;
      }
      v34 = v66;
      v16 = v55;
      if ( v66 >= v55 )
        goto LABEL_44;
      v15 = v54;
    }
    result = -3;
  }
  return result;
}
// 100401C0: using guessed type int var_78[14];
// 100401C0: using guessed type int var_3C[15];

//----- (10040660) --------------------------------------------------------
int (__cdecl *__usercall sub_10040660@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax@3
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax@3

  if ( a1 )
    *a1 = *(_DWORD *)(a2 + 14124);
  v3 = *(_DWORD *)(a2 + 14104);
  *(_DWORD *)(a2 + 14112) = v3;
  *(_DWORD *)(a2 + 14116) = v3;
  result = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a2 + 14120);
  *(_BYTE *)a2 = 0;
  *(_DWORD *)(a2 + 1424) = 0;
  *(_DWORD *)(a2 + 1428) = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    *(_DWORD *)(a2 + 14124) = result;
    *(_DWORD *)(a3 + 28) = result;
  }
  return result;
}

//----- (100406B0) --------------------------------------------------------
int __usercall sub_100406B0@<eax>(int result@<eax>, char a2, char a3, int a4, int a5)
{
  *(_BYTE *)(result + 16) = a2;
  *(_BYTE *)(result + 17) = a3;
  *(_BYTE *)result = 0;
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(result + 24) = a5;
  return result;
}

//----- (100406D0) --------------------------------------------------------
signed int __cdecl sub_100406D0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // ebp@1
  unsigned int v7; // ecx@1
  unsigned int v8; // edx@1
  _BYTE *v9; // edi@1
  unsigned int v10; // eax@1
  int v11; // esi@6
  int v12; // ebx@8
  int v13; // esi@8
  int v14; // ecx@8
  int v15; // ecx@11
  int v16; // ebx@13
  unsigned int v17; // eax@13
  unsigned int v18; // edx@13
  int v19; // esi@14
  int v20; // ebx@16
  int v21; // esi@16
  unsigned int v22; // edx@16
  unsigned int v23; // eax@16
  int v24; // ecx@18
  int v25; // ecx@18
  int i; // ebx@19
  char v27; // cl@21
  int v28; // ebx@21
  int v29; // ecx@21
  int v30; // esi@22
  _BYTE *v31; // edi@22
  _BYTE *v32; // esi@22
  unsigned int v33; // ecx@23
  unsigned int v34; // ecx@32
  int v35; // ebp@34
  int v36; // ebx@34
  unsigned int v38; // ecx@35
  int v39; // ebp@37
  int v40; // ebx@37
  int v41; // esi@37
  int v42; // eax@37
  unsigned int v43; // ecx@38
  int v44; // ebp@41
  int v45; // ebx@41
  int v46; // ebp@44
  unsigned int v47; // [sp+10h] [bp-14h]@1
  unsigned int v48; // [sp+14h] [bp-10h]@2
  _BYTE *v49; // [sp+18h] [bp-Ch]@1
  int v50; // [sp+1Ch] [bp-8h]@4
  int v51; // [sp+20h] [bp-4h]@4
  unsigned int v52; // [sp+28h] [bp+4h]@21
  unsigned int v53; // [sp+2Ch] [bp+8h]@13
  int v54; // [sp+2Ch] [bp+8h]@24

  v6 = *(_BYTE **)a6;
  v7 = *(_DWORD *)(a5 + 14112);
  v8 = *(_DWORD *)(a5 + 1428);
  v9 = *(_BYTE **)(a5 + 14116);
  v47 = *(_DWORD *)(a6 + 4);
  v10 = *(_DWORD *)(a5 + 1424);
  v49 = *(_BYTE **)a6;
  if ( (unsigned int)v9 >= v7 )
    v48 = *(_DWORD *)(a5 + 14108) - (_DWORD)v9;
  else
    v48 = v7 - (_DWORD)v9 - 1;
  v50 = dword_100B48D0[a1];
  v51 = dword_100B48D0[a2];
  while ( 1 )
  {
    if ( v10 < 0x14 )
    {
      do
      {
        --v47;
        v11 = *v6 << v10;
        v10 += 8;
        ++v6;
        v8 |= v11;
      }
      while ( v10 < 0x14 );
      v49 = v6;
    }
    v12 = *(_BYTE *)(a3 + 8 * (v8 & v50));
    v13 = a3 + 8 * (v8 & v50);
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( v12 )
      break;
LABEL_29:
    v10 -= v14;
    *v9++ = *(_BYTE *)(v13 + 4);
    --v48;
LABEL_30:
    if ( v48 < 0x102 || v47 < 0xA )
    {
      v34 = *(_DWORD *)(a6 + 4) - v47;
      if ( v10 >> 3 < v34 )
        v34 = v10 >> 3;
      v35 = (int)&v6[-v34];
      *(_DWORD *)(a6 + 4) = v34 + v47;
      v36 = v35 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v35;
      *(_DWORD *)(a6 + 8) += v36;
      *(_DWORD *)(a5 + 14116) = v9;
      *(_DWORD *)(a5 + 1424) = v10 - 8 * v34;
      *(_DWORD *)(a5 + 1428) = v8;
      return 0;
    }
  }
  v10 -= *(_BYTE *)(v13 + 1);
  if ( v12 & 0x10 )
  {
LABEL_13:
    v16 = v12 & 0xF;
    v17 = v10 - v16;
    v53 = *(_DWORD *)(v13 + 4) + (v8 & dword_100B48D0[v16]);
    v18 = v8 >> v16;
    if ( v17 < 0xF )
    {
      do
      {
        --v47;
        v19 = *v6 << v17;
        v17 += 8;
        ++v6;
        v18 |= v19;
      }
      while ( v17 < 0xF );
      v49 = v6;
    }
    v20 = *(_BYTE *)(a4 + 8 * (v18 & v51));
    v21 = a4 + 8 * (v18 & v51);
    v22 = v18 >> *(_BYTE *)(v21 + 1);
    v23 = v17 - *(_BYTE *)(v21 + 1);
    if ( !(v20 & 0x10) )
    {
      while ( !(v20 & 0x40) )
      {
        v24 = *(_DWORD *)(v21 + 4) + (v22 & dword_100B48D0[v20]);
        v20 = *(_BYTE *)(v21 + 8 * v24);
        v21 += 8 * v24;
        v25 = *(_BYTE *)(v21 + 1);
        v22 >>= v25;
        v23 -= v25;
        if ( v20 & 0x10 )
          goto LABEL_19;
      }
      v38 = *(_DWORD *)(a6 + 4) - v47;
      if ( v23 >> 3 < v38 )
        v38 = v23 >> 3;
      v39 = (int)&v6[-v38];
      *(_DWORD *)(a6 + 4) = v38 + v47;
      v40 = v39 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v39;
      *(_DWORD *)(a6 + 8) += v40;
      v41 = a5;
      *(_DWORD *)(a5 + 1428) = v22;
      v42 = v23 - 8 * v38;
      goto LABEL_45;
    }
LABEL_19:
    for ( i = v20 & 0xF; v23 < (unsigned __int16)i; ++v49 )
    {
      --v47;
      v22 |= *v6 << v23;
      v6 = v49 + 1;
      v23 += 8;
    }
    v10 = v23 - i;
    v52 = *(_DWORD *)(v21 + 4) + (v22 & dword_100B48D0[i]);
    v27 = i;
    v28 = v53;
    v48 -= v53;
    v8 = v22 >> v27;
    v29 = *(_DWORD *)(a5 + 14104);
    if ( (unsigned int)&v9[-v29] < v52 )
    {
      v33 = v52 + v29 - (_DWORD)v9;
      v32 = (_BYTE *)(*(_DWORD *)(a5 + 14108) - v33);
      if ( v53 > v33 )
      {
        v54 = v53 - v33;
        do
        {
          *v9++ = *v32++;
          --v33;
        }
        while ( v33 );
        v32 = *(_BYTE **)(a5 + 14104);
        v28 = v54;
      }
    }
    else
    {
      v30 = (int)&v9[-v52];
      v31 = v9 + 1;
      *(v31 - 1) = *(_BYTE *)v30;
      *v31 = *(_BYTE *)(v30 + 1);
      v9 = v31 + 1;
      v32 = (_BYTE *)(v30 + 2);
      v28 = v53 - 2;
    }
    do
    {
      *v9++ = *v32++;
      --v28;
    }
    while ( v28 );
    goto LABEL_30;
  }
  while ( !(v12 & 0x40) )
  {
    v15 = *(_DWORD *)(v13 + 4) + (v8 & dword_100B48D0[v12]);
    v12 = *(_BYTE *)(v13 + 8 * v15);
    v13 += 8 * v15;
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( !v12 )
      goto LABEL_29;
    v10 -= *(_BYTE *)(v13 + 1);
    if ( v12 & 0x10 )
      goto LABEL_13;
  }
  v43 = *(_DWORD *)(a6 + 4) - v47;
  if ( !(v12 & 0x20) )
  {
    if ( v10 >> 3 < v43 )
      v43 = v10 >> 3;
    v46 = (int)&v6[-v43];
    *(_DWORD *)(a6 + 4) = v43 + v47;
    *(_DWORD *)(a6 + 8) += v46 - *(_DWORD *)a6;
    *(_DWORD *)a6 = v46;
    v41 = a5;
    *(_DWORD *)(a5 + 1428) = v8;
    v42 = v10 - 8 * v43;
LABEL_45:
    *(_DWORD *)(v41 + 14116) = v9;
    *(_DWORD *)(v41 + 1424) = v42;
    return -3;
  }
  if ( v10 >> 3 < v43 )
    v43 = v10 >> 3;
  *(_DWORD *)(a6 + 4) = v43 + v47;
  v44 = (int)&v6[-v43];
  v45 = v44 - *(_DWORD *)a6;
  *(_DWORD *)a6 = v44;
  *(_DWORD *)(a6 + 8) += v45;
  *(_DWORD *)(a5 + 1428) = v8;
  *(_DWORD *)(a5 + 14116) = v9;
  *(_DWORD *)(a5 + 1424) = v10 - 8 * v43;
  return 1;
}
// 100B48D0: using guessed type int dword_100B48D0[];

//----- (10040A80) --------------------------------------------------------
int __usercall sub_10040A80@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  const void *v3; // ebx@1
  unsigned int v4; // ebp@1
  size_t v5; // eax@3
  size_t v6; // ebp@3
  int (__cdecl *v7)(_DWORD, const void *, size_t); // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int v10; // ebx@10
  const void *v11; // ebx@11
  size_t v12; // eax@13
  size_t v13; // ebp@13
  int (__cdecl *v14)(_DWORD, const void *, size_t); // eax@15
  int v15; // eax@16
  int result; // eax@18
  void *v17; // [sp+8h] [bp-4h]@1
  char *v18; // [sp+8h] [bp-4h]@10

  v3 = *(const void **)(a2 + 14112);
  v4 = *(_DWORD *)(a2 + 14116);
  v17 = *(void **)(a1 + 12);
  if ( (unsigned int)v3 > v4 )
    v4 = *(_DWORD *)(a2 + 14108);
  v5 = *(_DWORD *)(a1 + 16);
  v6 = v4 - (_DWORD)v3;
  if ( v6 > v5 )
    v6 = *(_DWORD *)(a1 + 16);
  if ( v6 && a3 == -5 )
    a3 = 0;
  *(_DWORD *)(a1 + 20) += v6;
  *(_DWORD *)(a1 + 16) = v5 - v6;
  v7 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
  if ( v7 )
  {
    v8 = v7(*(_DWORD *)(a2 + 14124), v3, v6);
    *(_DWORD *)(a2 + 14124) = v8;
    *(_DWORD *)(a1 + 28) = v8;
  }
  memcpy(v17, v3, v6);
  v9 = *(_DWORD *)(a2 + 14108);
  v18 = (char *)v17 + v6;
  v10 = (int)v3 + v6;
  if ( v10 == v9 )
  {
    v11 = *(const void **)(a2 + 14104);
    if ( *(_DWORD *)(a2 + 14116) == v9 )
      *(_DWORD *)(a2 + 14116) = v11;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a2 + 14116) - (_DWORD)v11;
    if ( v13 > v12 )
      v13 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) += v13;
    *(_DWORD *)(a1 + 16) = v12 - v13;
    v14 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
    if ( v14 )
    {
      v15 = v14(*(_DWORD *)(a2 + 14124), v11, v13);
      *(_DWORD *)(a2 + 14124) = v15;
      *(_DWORD *)(a1 + 28) = v15;
    }
    memcpy(v18, v11, v13);
    v18 += v13;
    v10 = (int)v11 + v13;
  }
  *(_DWORD *)(a1 + 12) = v18;
  result = a3;
  *(_DWORD *)(a2 + 14112) = v10;
  return result;
}

//----- (10040BC0) --------------------------------------------------------
signed int __usercall sub_10040BC0@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4)
{
  signed int result; // eax@1
  int v5; // [sp+0h] [bp-50h]@1
  char v6; // [sp+4h] [bp-4Ch]@1

  v5 = 0;
  result = sub_100401C0(a2, a3, 0x13u, 19, 0, 0, a4, a1, (unsigned int *)&v5, (unsigned int *)&v6);
  if ( result == -5 || !*a2 )
    result = -3;
  return result;
}

//----- (10040C10) --------------------------------------------------------
signed int __usercall sub_10040C10@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9)
{
  unsigned int *v9; // edi@1
  signed int result; // eax@6
  int v11; // [sp+8h] [bp-4h]@1

  v9 = a1;
  v11 = 0;
  if ( sub_100401C0(a7, a6, a4, 257, (int)&unk_100B4968, (int)&unk_100B49E8, a2, a3, (unsigned int *)&v11, a1)
    || !*a7
    || sub_100401C0(a8, &a6[a4], a5, 0, (int)&unk_100B4A68, (int)&unk_100B4AE0, a9, a3, (unsigned int *)&v11, v9)
    || !*a8 && a4 > 0x101 )
  {
    result = -3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10040CB0) --------------------------------------------------------
int __usercall sub_10040CB0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4)
{
  *a1 = 9;
  *a3 = 5;
  *a2 = &unk_100B4B58;
  *a4 = &unk_100B5B58;
  return 0;
}

//----- (10040CD0) --------------------------------------------------------
signed int __cdecl sub_10040CD0(int a1)
{
  signed int result; // eax@2
  int v2; // ecx@3
  int v3; // esi@3

  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    v3 = *(_DWORD *)(v2 + 20);
    *(_BYTE *)v2 = *(_DWORD *)(v2 + 12) != 0 ? 7 : 0;
    sub_10040660(0, v3, a1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10040CE0) --------------------------------------------------------
int __usercall sub_10040CE0@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // edi@1
  _BYTE *v4; // ebx@1
  int v5; // esi@1
  _BYTE *v6; // edx@1
  unsigned int v7; // ebp@1
  unsigned int v8; // eax@1
  unsigned int v9; // eax@2
  unsigned int v10; // ecx@4
  int v11; // ecx@8
  signed int v12; // eax@8
  int v13; // ecx@8
  unsigned int v14; // eax@8
  int v15; // ecx@13
  int v16; // eax@16
  int v17; // eax@17
  int v18; // ecx@17
  int v19; // eax@17
  int v20; // eax@27
  int v21; // eax@28
  int v22; // ecx@28
  int v23; // ecx@28
  int v24; // eax@31
  int v25; // eax@32
  int v26; // ecx@32
  int v27; // eax@32
  int v28; // eax@38
  int v29; // eax@39
  int v30; // ecx@39
  int v31; // ecx@40
  int v32; // eax@41
  unsigned int v33; // eax@46
  unsigned int v34; // ecx@46
  int v35; // eax@51
  unsigned int v36; // eax@51
  unsigned int v37; // ecx@55
  unsigned int v38; // eax@55
  bool v39; // zf@61
  unsigned int v40; // eax@67
  unsigned int v41; // ecx@67
  int v42; // eax@72
  unsigned int v43; // eax@72
  unsigned int v44; // ecx@76
  unsigned int v45; // eax@76
  int v47; // eax@91
  int v48; // ecx@93
  int v49; // eax@97
  int v50; // ecx@98
  int v51; // eax@101
  int v52; // [sp-4h] [bp-2Ch]@85
  unsigned int v53; // [sp+10h] [bp-18h]@1
  unsigned int v54; // [sp+14h] [bp-14h]@1
  unsigned int v55; // [sp+18h] [bp-10h]@4
  unsigned int v56; // [sp+18h] [bp-10h]@54
  unsigned int v57; // [sp+18h] [bp-10h]@75
  _BYTE *v58; // [sp+20h] [bp-8h]@43
  int v59; // [sp+2Ch] [bp+4h]@51

  v3 = a1;
  v4 = *(_BYTE **)a1;
  v5 = a2;
  v6 = *(_BYTE **)(a2 + 14116);
  v7 = *(_DWORD *)(a2 + 1424);
  v54 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)(a2 + 14112);
  v53 = *(_DWORD *)(a2 + 1428);
  if ( (unsigned int)v6 >= v8 )
    v9 = *(_DWORD *)(a2 + 14108) - (_DWORD)v6;
  else
    v9 = v8 - (_DWORD)v6 - 1;
  v10 = *(_BYTE *)(a2 + 4);
  v55 = v9;
  while ( 2 )
  {
    switch ( v10 )
    {
      case 0u:
        if ( v9 >= 0x102 && v54 >= 0xA )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v11 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v11;
          *(_DWORD *)(v5 + 1428) = v53;
          *(_DWORD *)(v5 + 1424) = v7;
          *(_DWORD *)(v5 + 14116) = v6;
          v12 = sub_100406D0(
                  *(_BYTE *)(v5 + 20),
                  *(_BYTE *)(v5 + 21),
                  *(_DWORD *)(v5 + 24),
                  *(_DWORD *)(v5 + 28),
                  v5,
                  v3);
          v4 = *(_BYTE **)v3;
          v7 = *(_DWORD *)(v5 + 1424);
          v13 = v12;
          v54 = *(_DWORD *)(v3 + 4);
          v6 = *(_BYTE **)(v5 + 14116);
          v53 = *(_DWORD *)(v5 + 1428);
          v14 = *(_DWORD *)(v5 + 14112);
          a3 = v13;
          v9 = (unsigned int)v6 >= v14 ? *(_DWORD *)(v5 + 14108) - (_DWORD)v6 : v14 - (_DWORD)v6 - 1;
          v55 = v9;
          if ( v13 )
          {
            *(_BYTE *)(v5 + 4) = 2 * (v13 != 1) + 7;
            goto LABEL_84;
          }
        }
        v15 = *(_DWORD *)(v5 + 24);
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 20);
        *(_DWORD *)(v5 + 12) = v15;
        *(_BYTE *)(v5 + 4) = 1;
        goto LABEL_14;
      case 1u:
LABEL_14:
        if ( v7 >= *(_WORD *)(v5 + 16) )
          goto LABEL_17;
        do
        {
          if ( !v54 )
            goto LABEL_91;
          --v54;
          v16 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v16;
        }
        while ( v7 < *(_WORD *)(v5 + 16) );
LABEL_17:
        v17 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100B48D0[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v17 + 1);
        v18 = v17;
        v7 -= *(_BYTE *)(v17 + 1);
        v19 = *(_BYTE *)v17;
        if ( v19 )
        {
          if ( v19 & 0x10 )
          {
            *(_DWORD *)(v5 + 12) = v19 & 0xF;
            *(_DWORD *)(v5 + 8) = *(_DWORD *)(v18 + 4);
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 2;
          }
          else if ( v19 & 0x40 )
          {
            if ( !(v19 & 0x20) )
              goto LABEL_92;
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 7;
          }
          else
          {
            *(_DWORD *)(v5 + 16) = v19;
            v9 = v55;
            *(_DWORD *)(v5 + 12) = v18 + 8 * *(_DWORD *)(v18 + 4);
          }
        }
        else
        {
          v9 = v55;
          *(_DWORD *)(v5 + 12) = *(_DWORD *)(v18 + 4);
          *(_BYTE *)(v5 + 4) = 6;
        }
        goto LABEL_84;
      case 2u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_28;
        do
        {
          if ( !v54 )
            goto LABEL_93;
          --v54;
          v20 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v20;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_28:
        v21 = *(_DWORD *)(v5 + 12);
        v22 = v53 & dword_100B48D0[v21];
        *(_BYTE *)(v5 + 4) = 3;
        *(_DWORD *)(v5 + 8) += v22;
        v53 >>= v21;
        v23 = *(_DWORD *)(v5 + 28);
        v7 -= v21;
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 21);
        *(_DWORD *)(v5 + 12) = v23;
LABEL_29:
        if ( v7 < *(_WORD *)(v5 + 16) )
        {
          while ( v54 )
          {
            --v54;
            v24 = *v4 << v7;
            v7 += 8;
            ++v4;
            a3 = 0;
            v53 |= v24;
            if ( v7 >= *(_WORD *)(v5 + 16) )
              goto LABEL_32;
          }
LABEL_91:
          v47 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)(v3 + 4) = 0;
          *(_DWORD *)(v3 + 8) += v47;
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v5 + 14116) = v6;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = a3;
          goto LABEL_90;
        }
LABEL_32:
        v25 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100B48D0[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v25 + 1);
        v26 = v25;
        v7 -= *(_BYTE *)(v25 + 1);
        v27 = *(_BYTE *)v25;
        if ( v27 & 0x10 )
        {
          *(_DWORD *)(v5 + 12) = v27 & 0xF;
          v9 = v55;
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(v26 + 4);
          *(_BYTE *)(v5 + 4) = 4;
        }
        else
        {
          if ( v27 & 0x40 )
          {
LABEL_92:
            *(_BYTE *)(v5 + 4) = 9;
            v52 = -3;
            goto LABEL_86;
          }
          *(_DWORD *)(v5 + 16) = v27;
          v9 = v55;
          *(_DWORD *)(v5 + 12) = v26 + 8 * *(_DWORD *)(v26 + 4);
        }
        goto LABEL_84;
      case 3u:
        goto LABEL_29;
      case 4u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_39;
        do
        {
          if ( !v54 )
          {
LABEL_93:
            v48 = (int)&v4[-*(_DWORD *)v3];
            *(_DWORD *)(v3 + 4) = 0;
            *(_DWORD *)(v3 + 8) += v48;
            v52 = a3;
            goto LABEL_88;
          }
          --v54;
          v28 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v28;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_39:
        v29 = *(_DWORD *)(v5 + 12);
        v30 = v53 & dword_100B48D0[v29];
        *(_BYTE *)(v5 + 4) = 5;
        *(_DWORD *)(v5 + 16) += v30;
        v53 >>= v29;
        v7 -= v29;
LABEL_40:
        v31 = *(_DWORD *)(v5 + 16);
        if ( (signed int)&v6[-*(_DWORD *)(v5 + 14104)] >= v31 )
          v32 = (int)&v6[-v31];
        else
          v32 = (int)&v6[*(_DWORD *)(v5 + 14108) - v31 - *(_DWORD *)(v5 + 14104)];
        v58 = (_BYTE *)v32;
        v9 = v55;
        if ( !*(_DWORD *)(v5 + 8) )
        {
LABEL_83:
          *(_BYTE *)(v5 + 4) = 0;
LABEL_84:
          v10 = *(_BYTE *)(v5 + 4);
          if ( v10 > 9 )
          {
LABEL_85:
            v52 = -2;
LABEL_86:
            *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
            goto LABEL_87;
          }
          continue;
        }
        while ( 1 )
        {
          if ( !v9 )
          {
            if ( v6 != *(_BYTE **)(v5 + 14108)
              || (v33 = *(_DWORD *)(v5 + 14112), v34 = *(_DWORD *)(v5 + 14104), v33 == v34)
              || ((v6 = *(_BYTE **)(v5 + 14104), v34 >= v33) ? (v9 = *(_DWORD *)(v5 + 14108) - v34) : (v9 = v33 - v34 - 1),
                  !v9) )
            {
              *(_DWORD *)(v5 + 14116) = v6;
              v35 = sub_10040A80(v3, v5, a3);
              v6 = *(_BYTE **)(v5 + 14116);
              v59 = v35;
              v36 = *(_DWORD *)(v5 + 14112);
              if ( (unsigned int)v6 >= v36 )
                v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
              else
                v9 = v36 - (_DWORD)v6 - 1;
              v56 = v9;
              if ( v6 == *(_BYTE **)(v5 + 14108) )
              {
                v37 = *(_DWORD *)(v5 + 14104);
                v38 = *(_DWORD *)(v5 + 14112);
                if ( v38 == v37 )
                {
                  v9 = v56;
                }
                else
                {
                  v6 = *(_BYTE **)(v5 + 14104);
                  if ( v37 >= v38 )
                    v9 = *(_DWORD *)(v5 + 14108) - v37;
                  else
                    v9 = v38 - v37 - 1;
                }
              }
              if ( !v9 )
                break;
            }
          }
          *v6 = *v58;
          --v9;
          ++v6;
          v39 = v58 + 1 == *(_BYTE **)(v5 + 14108);
          a3 = 0;
          v55 = v9;
          ++v58;
          if ( v39 )
            v58 = *(_BYTE **)(v5 + 14104);
          if ( !--*(_DWORD *)(v5 + 8) )
            goto LABEL_83;
        }
LABEL_94:
        *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
        v52 = v59;
LABEL_87:
        *(_DWORD *)(v3 + 4) = v54;
LABEL_88:
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
LABEL_89:
        *(_DWORD *)(v5 + 14116) = v6;
LABEL_90:
        *(_DWORD *)(v5 + 1424) = v7;
        return sub_10040A80(v3, v5, v52);
      case 5u:
        goto LABEL_40;
      case 6u:
        if ( !v9 )
        {
          if ( v6 != *(_BYTE **)(v5 + 14108)
            || (v40 = *(_DWORD *)(v5 + 14112), v41 = *(_DWORD *)(v5 + 14104), v40 == v41)
            || ((v6 = *(_BYTE **)(v5 + 14104), v41 >= v40) ? (v9 = *(_DWORD *)(v5 + 14108) - v41) : (v9 = v40 - v41 - 1),
                !v9) )
          {
            *(_DWORD *)(v5 + 14116) = v6;
            v42 = sub_10040A80(v3, v5, a3);
            v6 = *(_BYTE **)(v5 + 14116);
            v59 = v42;
            v43 = *(_DWORD *)(v5 + 14112);
            if ( (unsigned int)v6 >= v43 )
              v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
            else
              v9 = v43 - (_DWORD)v6 - 1;
            v57 = v9;
            if ( v6 == *(_BYTE **)(v5 + 14108) )
            {
              v44 = *(_DWORD *)(v5 + 14104);
              v45 = *(_DWORD *)(v5 + 14112);
              if ( v45 == v44 )
              {
                v9 = v57;
              }
              else
              {
                v6 = *(_BYTE **)(v5 + 14104);
                if ( v44 >= v45 )
                  v9 = *(_DWORD *)(v5 + 14108) - v44;
                else
                  v9 = v45 - v44 - 1;
              }
            }
            if ( !v9 )
              goto LABEL_94;
          }
        }
        *v6++ = *(_BYTE *)(v5 + 12);
        --v9;
        a3 = 0;
        v55 = v9;
        goto LABEL_83;
      case 7u:
        if ( v7 > 7 )
        {
          ++v54;
          v7 -= 8;
          --v4;
        }
        *(_DWORD *)(v5 + 14116) = v6;
        v49 = sub_10040A80(v3, v5, a3);
        v6 = *(_BYTE **)(v5 + 14116);
        if ( *(_BYTE **)(v5 + 14112) != v6 )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v50 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v50;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = v49;
          goto LABEL_89;
        }
        *(_BYTE *)(v5 + 4) = 8;
LABEL_100:
        v52 = 1;
        goto LABEL_86;
      case 8u:
        goto LABEL_100;
      case 9u:
        v51 = (int)&v4[-*(_DWORD *)v3];
        *(_DWORD *)(v3 + 4) = v54;
        *(_DWORD *)(v3 + 8) += v51;
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
        v52 = -3;
        goto LABEL_89;
      default:
        goto LABEL_85;
    }
  }
}
// 100B48D0: using guessed type int dword_100B48D0[];

//----- (10041380) --------------------------------------------------------
int __usercall sub_10041380@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // edx@1
  unsigned int v5; // ebx@1
  unsigned int v6; // esi@1
  int v7; // edi@1
  size_t v8; // ecx@1
  char *v9; // eax@1
  char *v10; // ecx@1
  int v11; // edx@2
  unsigned int v12; // edx@4
  int v13; // edx@8
  unsigned int v14; // eax@9
  int v15; // eax@10
  int v16; // ebx@14
  int v17; // ecx@14
  int v18; // edx@17
  char *v19; // edx@24
  unsigned int v20; // eax@25
  unsigned int v21; // ecx@25
  int v22; // eax@27
  int v23; // eax@30
  unsigned int v24; // ecx@30
  int v25; // edx@31
  char *v26; // esi@33
  unsigned int v27; // edx@34
  size_t v28; // esi@39
  bool v29; // zf@43
  int v30; // edx@47
  int v31; // ecx@48
  int v32; // edx@54
  unsigned int v33; // ecx@61
  int v34; // edx@63
  int v35; // edx@64
  int v36; // ecx@64
  unsigned int v37; // edx@64
  int v38; // edx@71
  unsigned int v39; // esi@72
  unsigned int v40; // ecx@72
  unsigned int *v41; // eax@77
  unsigned int v42; // esi@81
  int v43; // eax@81
  int v44; // edx@83
  char *v45; // ecx@84
  unsigned int v46; // eax@84
  int v47; // eax@85
  char *v48; // eax@91
  int v49; // ecx@92
  int v50; // ecx@94
  int v51; // edx@96
  int v52; // edx@97
  int v53; // edx@99
  int v55; // eax@102
  int v56; // edx@103
  int v57; // edx@106
  int v58; // [sp-4h] [bp-3Ch]@91
  size_t v59; // [sp+10h] [bp-28h]@1
  char *v60; // [sp+14h] [bp-24h]@1
  char *v61; // [sp+18h] [bp-20h]@1
  unsigned int v62; // [sp+1Ch] [bp-1Ch]@4
  int v63; // [sp+1Ch] [bp-1Ch]@69
  int v64; // [sp+1Ch] [bp-1Ch]@72
  unsigned int v65; // [sp+20h] [bp-18h]@1
  unsigned int v66; // [sp+24h] [bp-14h]@13
  unsigned int v67; // [sp+28h] [bp-10h]@13
  int v68; // [sp+2Ch] [bp-Ch]@13
  int v69; // [sp+30h] [bp-8h]@13
  unsigned int v70; // [sp+34h] [bp-4h]@69
  unsigned int v71; // [sp+3Ch] [bp+4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 14112);
  v5 = *(_DWORD *)(a2 + 1424);
  v6 = *(_DWORD *)(a2 + 1428);
  v7 = a1;
  v8 = *(_DWORD *)(a1 + 4);
  v9 = *(char **)a1;
  v59 = v8;
  v10 = *(char **)(a2 + 14116);
  v61 = v9;
  v71 = *(_DWORD *)(a2 + 1428);
  v65 = v5;
  v60 = v10;
  if ( (unsigned int)v10 >= v4 )
    v11 = *(_DWORD *)(v3 + 14108) - (_DWORD)v10;
  else
    v11 = v4 - (_DWORD)v10 - 1;
  v62 = v11;
  v12 = *(_BYTE *)v3;
  while ( 2 )
  {
    switch ( v12 )
    {
      case 0u:
        for ( ; v5 < 3; v71 = v6 )
        {
          if ( !v59 )
            goto LABEL_91;
          --v59;
          a3 = 0;
          v13 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v13;
        }
        v14 = (v6 & 7) >> 1;
        *(_DWORD *)(v3 + 1420) = v6 & 1;
        if ( !v14 )
        {
          v16 = v5 - 3;
          v17 = v16 & 7;
          v5 = v16 - v17;
          v65 = v5;
          *(_BYTE *)v3 = 1;
          v71 = v6 >> 3 >> v17;
          goto LABEL_89;
        }
        v15 = v14 - 1;
        if ( !v15 )
        {
          sub_10040CB0(&v67, &v69, &v66, &v68);
          sub_100406B0(v3 + 4, v67, v66, v69, v68);
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 6;
          goto LABEL_89;
        }
        if ( v15 == 1 )
        {
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 3;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 9;
        v49 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v49;
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v3 + 1428) = v71 >> 3;
        v5 -= 3;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      case 1u:
        if ( v5 >= 0x20 )
          goto LABEL_18;
        do
        {
          if ( !v59 )
          {
LABEL_91:
            v48 = v61;
            *(_DWORD *)(v7 + 4) = 0;
            *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
            v58 = a3;
            goto LABEL_110;
          }
          --v59;
          a3 = 0;
          v18 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v18;
          v71 = v6;
        }
        while ( v5 < 0x20 );
LABEL_18:
        if ( ~v6 >> 16 != (unsigned __int16)v6 )
          goto LABEL_93;
        v5 = 0;
        *(_DWORD *)(v3 + 4) = (unsigned __int16)v6;
        v65 = 0;
        v71 = 0;
        if ( (_WORD)v6 )
          *(_BYTE *)v3 = 2;
        else
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
LABEL_89:
        v12 = *(_BYTE *)v3;
        if ( v12 <= 9 )
        {
          v10 = v60;
          v9 = v61;
          v6 = v71;
          continue;
        }
LABEL_107:
        v58 = -2;
        goto LABEL_108;
      case 2u:
        if ( !v59 )
          goto LABEL_94;
        if ( !v62 )
        {
          if ( (v19 = *(char **)(v3 + 14108), v60 != v19)
            || (v20 = *(_DWORD *)(v3 + 14112), v21 = *(_DWORD *)(v3 + 14104), v21 == v20)
            || ((v60 = *(char **)(v3 + 14104), v21 >= v20) ? (v22 = (int)&v19[-v21], v62 = (unsigned int)&v19[-v21]) : (v22 = v20 - v21 - 1, v62 = v22),
                !v22) )
          {
            *(_DWORD *)(v3 + 14116) = v60;
            v23 = sub_10040A80(v7, v3, a3);
            v24 = *(_DWORD *)(v3 + 14112);
            v60 = *(char **)(v3 + 14116);
            if ( *(_DWORD *)(v3 + 14116) >= v24 )
              v25 = *(_DWORD *)(v3 + 14108) - (_DWORD)v60;
            else
              v25 = v24 - (_DWORD)v60 - 1;
            v26 = *(char **)(v3 + 14108);
            v62 = v25;
            if ( v60 == v26 )
            {
              v27 = *(_DWORD *)(v3 + 14104);
              if ( v27 != v24 )
              {
                v60 = *(char **)(v3 + 14104);
                if ( v27 >= v24 )
                  v62 = (unsigned int)&v26[-v27];
                else
                  v62 = v24 - v27 - 1;
              }
            }
            if ( !v62 )
              goto LABEL_96;
          }
        }
        v28 = *(_DWORD *)(v3 + 4);
        a3 = 0;
        if ( v28 > v59 )
          v28 = v59;
        if ( v28 > v62 )
          v28 = v62;
        memcpy(v60, v61, v28);
        v61 += v28;
        v59 -= v28;
        v60 += v28;
        v62 -= v28;
        v29 = *(_DWORD *)(v3 + 4) == v28;
        *(_DWORD *)(v3 + 4) -= v28;
        if ( v29 )
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
        goto LABEL_89;
      case 3u:
        if ( v5 >= 0xE )
          goto LABEL_48;
        break;
      case 4u:
        goto LABEL_51;
      case 5u:
        goto LABEL_60;
      case 6u:
        goto LABEL_83;
      case 7u:
        goto LABEL_102;
      case 8u:
        goto LABEL_105;
      case 9u:
        v57 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v7 + 8) += v57;
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      default:
        goto LABEL_107;
    }
    break;
  }
  do
  {
    if ( !v59 )
      goto LABEL_94;
    --v59;
    v30 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v30;
    v71 = v6;
    v61 = v9;
  }
  while ( v5 < 0xE );
LABEL_48:
  v31 = v6 & 0x3FFF;
  *(_DWORD *)(v3 + 4) = v31;
  if ( (v6 & 0x1F) > 0x1D || (v6 & 0x3E0) > 0x3A0 )
  {
LABEL_93:
    *(_BYTE *)v3 = 9;
    v58 = -3;
LABEL_108:
    *(_DWORD *)(v7 + 4) = v59;
LABEL_109:
    v48 = v61;
    *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
    goto LABEL_110;
  }
  v6 >>= 14;
  v5 -= 14;
  v71 = v6;
  v65 = v5;
  *(_DWORD *)(v3 + 8) = 0;
  *(_BYTE *)v3 = 4;
LABEL_51:
  if ( *(_DWORD *)(v3 + 8) < (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
  {
    while ( v5 >= 3 )
    {
LABEL_55:
      *(_DWORD *)(v3 + 4 * dword_100B4918[(*(_DWORD *)(v3 + 8))++] + 12) = v6 & 7;
      v6 >>= 3;
      v5 -= 3;
      v71 = v6;
      v65 = v5;
      if ( *(_DWORD *)(v3 + 8) >= (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
        goto LABEL_56;
    }
    while ( v59 )
    {
      --v59;
      v32 = (unsigned __int8)*v9++ << v5;
      v5 += 8;
      a3 = 0;
      v6 |= v32;
      v71 = v6;
      v61 = v9;
      if ( v5 >= 3 )
        goto LABEL_55;
    }
    goto LABEL_94;
  }
LABEL_56:
  while ( *(_DWORD *)(v3 + 8) < 0x13u )
    *(_DWORD *)(v3 + 4 * dword_100B4918[(*(_DWORD *)(v3 + 8))++] + 12) = 0;
  *(_DWORD *)(v3 + 1412) = 7;
  v23 = sub_10040BC0(v3 + 1432, (unsigned int *)(v3 + 1412), (_DWORD *)(v3 + 12), (int *)(v3 + 1416));
  if ( v23 )
  {
    *(_BYTE *)v3 = 9;
LABEL_96:
    *(_DWORD *)(v7 + 4) = v59;
    v51 = (int)&v61[-*(_DWORD *)v7];
    *(_DWORD *)v7 = v61;
    *(_DWORD *)(v7 + 8) += v51;
    *(_DWORD *)(v3 + 1428) = v71;
    *(_DWORD *)(v3 + 14116) = v60;
    v58 = v23;
    goto LABEL_111;
  }
  v6 = v71;
  *(_DWORD *)(v3 + 8) = 0;
  v9 = v61;
  *(_BYTE *)v3 = 5;
LABEL_60:
  if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
  {
LABEL_81:
    v42 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 1416) = 0;
    v67 = 9;
    v66 = 6;
    v43 = sub_10040C10(
            (unsigned int *)(v3 + 12952),
            &v69,
            v3 + 1432,
            (v42 & 0x1F) + 257,
            ((v42 >> 5) & 0x1F) + 1,
            (_DWORD *)(v3 + 12),
            &v67,
            &v66,
            &v68);
    if ( v43 )
    {
      *(_BYTE *)v3 = 9;
      *(_DWORD *)(v7 + 4) = v59;
      v53 = (int)&v61[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v61;
      *(_DWORD *)(v7 + 8) += v53;
      *(_DWORD *)(v3 + 1428) = v71;
      *(_DWORD *)(v3 + 1424) = v65;
      *(_DWORD *)(v3 + 14116) = v60;
    }
    else
    {
      sub_100406B0(v3 + 4, v67, v66, v69, v68);
      v5 = v65;
      v10 = v60;
      v9 = v61;
      v6 = v71;
      *(_BYTE *)v3 = 6;
LABEL_83:
      *(_DWORD *)(v7 + 4) = v59;
      v44 = (int)&v9[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 8) += v44;
      *(_DWORD *)(v3 + 14116) = v10;
      *(_DWORD *)(v3 + 1428) = v6;
      *(_DWORD *)(v3 + 1424) = v5;
      v43 = sub_10040CE0(v7, v3, a3);
      if ( v43 == 1 )
      {
        v5 = *(_DWORD *)(v3 + 1424);
        v61 = *(char **)v7;
        v45 = *(char **)(v3 + 14116);
        v71 = *(_DWORD *)(v3 + 1428);
        v46 = *(_DWORD *)(v3 + 14112);
        a3 = 0;
        v59 = *(_DWORD *)(v7 + 4);
        v65 = *(_DWORD *)(v3 + 1424);
        v60 = v45;
        if ( (unsigned int)v45 >= v46 )
          v47 = *(_DWORD *)(v3 + 14108) - (_DWORD)v45;
        else
          v47 = v46 - (_DWORD)v45 - 1;
        v62 = v47;
        if ( !*(_DWORD *)(v3 + 1420) )
        {
          *(_BYTE *)v3 = 0;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 7;
LABEL_102:
        *(_DWORD *)(v3 + 14116) = v60;
        v55 = sub_10040A80(v7, v3, a3);
        v60 = *(char **)(v3 + 14116);
        if ( *(_DWORD *)(v3 + 14112) != *(_DWORD *)(v3 + 14116) )
        {
          *(_DWORD *)(v7 + 4) = v59;
          v56 = (int)&v61[-*(_DWORD *)v7];
          *(_DWORD *)v7 = v61;
          *(_DWORD *)(v7 + 8) += v56;
          *(_DWORD *)(v3 + 1428) = v71;
          *(_DWORD *)(v3 + 1424) = v5;
          *(_DWORD *)(v3 + 14116) = v60;
          return sub_10040A80(v7, v3, v55);
        }
        *(_BYTE *)v3 = 8;
LABEL_105:
        *(_DWORD *)(v7 + 4) = v59;
        v58 = 1;
        goto LABEL_109;
      }
    }
    return sub_10040A80(v7, v3, v43);
  }
  while ( 1 )
  {
    v33 = *(_WORD *)(v3 + 1412);
    v67 = *(_WORD *)(v3 + 1412);
    if ( v5 < v33 )
      break;
LABEL_64:
    v35 = *(_DWORD *)(v3 + 1416) + 8 * (v6 & dword_100B48D0[*(_DWORD *)(v3 + 1412)]);
    v36 = *(_BYTE *)(v35 + 1);
    v37 = *(_DWORD *)(v35 + 4);
    v66 = v37;
    if ( v37 >= 0x10 )
    {
      if ( v37 == 18 )
        v67 = 7;
      else
        v67 = v37 - 14;
      v63 = 8 * (v37 == 18) + 3;
      v70 = (unsigned __int16)(v36 + v67);
      if ( v5 < v70 )
      {
        while ( v59 )
        {
          --v59;
          v38 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          a3 = 0;
          v6 |= v38;
          v71 = v6;
          v61 = v9;
          if ( v5 >= v70 )
            goto LABEL_72;
        }
        v52 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v52;
        *(_DWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = a3;
        goto LABEL_111;
      }
LABEL_72:
      v39 = v6 >> v36;
      v64 = (v39 & dword_100B48D0[v67]) + v63;
      v6 = v39 >> v67;
      v5 -= v36 + v67;
      v40 = *(_DWORD *)(v3 + 8);
      v71 = v6;
      v65 = v5;
      if ( v40 + v64 > ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
        goto LABEL_98;
      if ( v66 == 16 )
      {
        if ( v40 < 1 )
        {
LABEL_98:
          *(_BYTE *)v3 = 9;
          *(_DWORD *)(v7 + 4) = v59;
          v58 = -3;
          goto LABEL_109;
        }
        v66 = *(_DWORD *)(v3 + 4 * v40 + 8);
      }
      else
      {
        v66 = 0;
      }
      v41 = (unsigned int *)(v3 + 4 * v40 + 12);
      do
      {
        *v41 = v66;
        ++v40;
        ++v41;
        --v64;
      }
      while ( v64 );
      v9 = v61;
      *(_DWORD *)(v3 + 8) = v40;
    }
    else
    {
      v6 >>= v36;
      v5 -= v36;
      *(_DWORD *)(v3 + 4 * (*(_DWORD *)(v3 + 8))++ + 12) = v37;
      v71 = v6;
      v65 = v5;
    }
    if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
      goto LABEL_81;
  }
  while ( v59 )
  {
    --v59;
    v34 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v34;
    v71 = v6;
    v61 = v9;
    if ( v5 >= v67 )
      goto LABEL_64;
  }
LABEL_94:
  v48 = v61;
  v50 = (int)&v61[-*(_DWORD *)v7];
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) += v50;
  v58 = a3;
LABEL_110:
  *(_DWORD *)v7 = v48;
  *(_DWORD *)(v3 + 14116) = v60;
  *(_DWORD *)(v3 + 1428) = v71;
LABEL_111:
  *(_DWORD *)(v3 + 1424) = v5;
  return sub_10040A80(v7, v3, v58);
}
// 100B48D0: using guessed type int dword_100B48D0[];
// 100B4918: using guessed type int dword_100B4918[];

//----- (10041D60) --------------------------------------------------------
signed int __usercall sub_10041D60@<eax>(int a1@<edi>, int a2)
{
  int v2; // ebp@3
  int v3; // ebx@3
  signed int v4; // esi@3
  unsigned int v5; // eax@3
  int v6; // eax@5
  _BYTE *v7; // ecx@6
  int v8; // eax@9
  int v9; // ecx@10
  int v10; // eax@13
  int v11; // eax@21
  int v12; // eax@23
  _BYTE *v13; // edx@24
  int v14; // eax@25
  _BYTE *v15; // ecx@26
  int v16; // eax@27
  signed int result; // eax@32
  int v18; // eax@34
  int v19; // eax@36
  _BYTE *v20; // edx@37
  int v21; // eax@38
  _BYTE *v22; // ecx@39
  int v23; // eax@40
  signed int v24; // [sp+8h] [bp+4h]@3

  if ( !a1 || !*(_DWORD *)a1 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  v3 = -5;
  v4 = a2 != 4 ? 0 : 0xFFFFFFFB;
  v5 = *(_BYTE *)v2;
  v24 = a2 != 4 ? 0 : 0xFFFFFFFB;
  while ( 2 )
  {
    switch ( v5 )
    {
      case 0u:
        v6 = *(_DWORD *)(a1 + 4);
        if ( !v6 )
          goto LABEL_44;
        v7 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v6 - 1;
        *(_DWORD *)(v2 + 4) = *v7;
        ++*(_DWORD *)a1;
        v3 = v4;
        if ( (*(_DWORD *)(v2 + 4) & 0xF) != 8 || (unsigned int)((*(_DWORD *)(v2 + 4) >> 4) + 8) > *(_DWORD *)(v2 + 16) )
          goto LABEL_29;
        *(_BYTE *)v2 = 1;
        goto LABEL_9;
      case 1u:
LABEL_9:
        v8 = *(_DWORD *)(a1 + 4);
        if ( !v8 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v8 - 1;
        v9 = *(_BYTE *)(*(_DWORD *)a1)++;
        v3 = v4;
        if ( (v9 + (*(_DWORD *)(v2 + 4) << 8)) % 0x1Fu )
          goto LABEL_29;
        if ( !(v9 & 0x20) )
        {
          *(_BYTE *)v2 = 7;
LABEL_31:
          v5 = *(_BYTE *)v2;
          if ( v5 > 0xD )
            return -2;
          continue;
        }
        *(_BYTE *)v2 = 2;
LABEL_34:
        v18 = *(_DWORD *)(a1 + 4);
        if ( !v18 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v18 - 1;
        *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
        v3 = v4;
        *(_BYTE *)v2 = 3;
LABEL_36:
        v19 = *(_DWORD *)(a1 + 4);
        if ( !v19 )
          goto LABEL_44;
        v20 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v19 - 1;
        *(_DWORD *)(v2 + 8) += *v20 << 16;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 4;
LABEL_38:
        v21 = *(_DWORD *)(a1 + 4);
        if ( !v21 )
          goto LABEL_44;
        v22 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v21 - 1;
        *(_DWORD *)(v2 + 8) += *v22 << 8;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 5;
LABEL_40:
        v23 = *(_DWORD *)(a1 + 4);
        if ( v23 )
        {
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v23 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(v2 + 8);
          *(_BYTE *)v2 = 6;
          result = 2;
        }
        else
        {
LABEL_44:
          result = v3;
        }
        return result;
      case 7u:
        v10 = sub_10041380(a1, *(_DWORD *)(v2 + 20), v3);
        v3 = v10;
        if ( v10 == -3 )
        {
          *(_DWORD *)(v2 + 4) = 0;
        }
        else
        {
          if ( !v10 )
            v3 = v4;
          if ( v3 != 1 )
            goto LABEL_44;
          v3 = v4;
          sub_10040660((_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 20), a1);
          v4 = v24;
          if ( *(_DWORD *)(v2 + 12) )
          {
            *(_BYTE *)v2 = 12;
            goto LABEL_31;
          }
          *(_BYTE *)v2 = 8;
LABEL_21:
          v11 = *(_DWORD *)(a1 + 4);
          if ( !v11 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v11 - 1;
          *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
          v3 = v4;
          *(_BYTE *)v2 = 9;
LABEL_23:
          v12 = *(_DWORD *)(a1 + 4);
          if ( !v12 )
            goto LABEL_44;
          v13 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v12 - 1;
          *(_DWORD *)(v2 + 8) += *v13 << 16;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 10;
LABEL_25:
          v14 = *(_DWORD *)(a1 + 4);
          if ( !v14 )
            goto LABEL_44;
          v15 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v14 - 1;
          *(_DWORD *)(v2 + 8) += *v15 << 8;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 11;
LABEL_27:
          v16 = *(_DWORD *)(a1 + 4);
          if ( !v16 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v16 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          v3 = v4;
          if ( *(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
          {
            *(_BYTE *)v2 = 12;
            return 1;
          }
LABEL_29:
          *(_DWORD *)(v2 + 4) = 5;
        }
        *(_BYTE *)v2 = 13;
        goto LABEL_31;
      case 8u:
        goto LABEL_21;
      case 9u:
        goto LABEL_23;
      case 0xAu:
        goto LABEL_25;
      case 0xBu:
        goto LABEL_27;
      case 2u:
        goto LABEL_34;
      case 3u:
        goto LABEL_36;
      case 4u:
        goto LABEL_38;
      case 5u:
        goto LABEL_40;
      case 6u:
        *(_BYTE *)v2 = 13;
        *(_DWORD *)(v2 + 4) = 0;
        return -2;
      case 0xCu:
        return 1;
      case 0xDu:
        return -3;
      default:
        return -2;
    }
  }
}

//----- (10042090) --------------------------------------------------------
signed int __cdecl sub_10042090(int a1, int a2)
{
  return sub_10041D60(a1, a2);
}

#error "There were 50 decompilation failure(s) on 900 function(s)"
