/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

_DWORD sub_10001000(); // weak
// int __usercall sub_10001080@<eax>(int result@<eax>, int a2@<ecx>);
bool __cdecl sub_100010B0(void *a1);
int __cdecl sub_100012A0(int a1, int a2);
int __cdecl sub_100012D0(int a1, char a2);
bool __cdecl sub_100012F0(int a1, int a2, _DWORD *a3);
bool __cdecl sub_10001330(int a1, _DWORD *a2);
unsigned int __cdecl sub_10001360(int a1, int a2);
char __cdecl sub_100013D0(int a1, int a2);
void __cdecl sub_10001480(int a1, int a2, unsigned __int8 a3, _BYTE *a4, int a5);
void __cdecl sub_10001D10(int a1, int a2, _BYTE *a3, int a4, int a5);
void __cdecl sub_10001D30(int a1, int a2, _BYTE *a3, int a4);
void __cdecl sub_10001D50(int a1, int a2, _BYTE *a3, int a4);
void __cdecl sub_10001D70(int a1, int a2, int a3);
void __cdecl sub_10001D90(int a1, int a2);
void __cdecl sub_10001DB0(int a1, int a2, _BYTE *a3, int a4);
void __cdecl sub_10001DD0(int a1, int a2, _BYTE *a3, int a4);
void __cdecl sub_10001DF0(int a1, int a2, _BYTE *a3, int a4);
void __cdecl sub_10001E30(int a1, int a2, _BYTE *a3, int a4);
void __cdecl sub_10001E70(int a1, int a2, _BYTE *a3, int a4);
void __cdecl sub_10001E90(int a1, int a2, _BYTE *a3, int a4);
void __cdecl sub_10001EB0(int a1, int a2, _BYTE *a3, int a4);
void __cdecl sub_10001EF0(int a1, int a2, char a3, int a4);
unsigned int __cdecl sub_10001F10(_BYTE *a1, unsigned int a2, int a3);
int __cdecl sub_10001F70(int a1, int a2, int a3);
int __cdecl sub_10001F90(int a1);
char __cdecl sub_10001FB0(int a1);
char __cdecl sub_10001FE0(int a1, int a2);
int *__cdecl sub_10002040(_BYTE *a1, int a2, int *a3, _DWORD *a4);
int __cdecl sub_10002090(_BYTE *a1, int a2, int a3, int a4);
char __cdecl sub_10002130(char a1, int a2);
unsigned int __cdecl sub_100021C0(int a1, int a2, int a3, char a4, int a5, int a6, unsigned int a7);
char __cdecl sub_10002320(int a1, char a2, char a3);
bool __cdecl sub_100024B0(_DWORD *a1);
int __cdecl sub_10002550(int a1, int a2);
int __fastcall sub_10002570(int a1, unsigned __int16 a2);
// int *__usercall sub_10002590@<eax>(int a1@<ebx>);
int *__fastcall sub_100025F0(int a1, char a2);
// unsigned int __usercall sub_10002620@<eax>(void *a1@<ecx>, int a2@<edi>, int a3@<esi>);
// void *__usercall sub_10002680@<eax>(int a1@<eax>, int a2@<ebx>, int a3@<esi>, __int16 a4, __int16 a5, char a6);
// bool __usercall sub_100026F0@<al>(int a1@<esi>);
int *__cdecl sub_10002730(int a1, int a2);
int *__cdecl sub_10002910(int a1);
int *__cdecl sub_10002D60(int a1);
// void __usercall sub_10002EE0(int *a1@<edx>, int a2@<ecx>, char a3, char a4);
void __cdecl sub_10002FB0(unsigned __int8 a1);
int __cdecl sub_10003060(int a1, __int16 a2, __int16 a3, char a4, int a5, int a6, unsigned __int8 a7);
void __cdecl sub_10003240(int a1, int *a2);
// void __usercall sub_10003290(int *a1@<eax>, int a2@<ecx>, int a3);
int __cdecl sub_10003380(int a1, int a2, void *a3, int a4, unsigned int a5);
int __cdecl sub_10003470(unsigned __int8 a1);
// void __usercall sub_100034C0(int a1@<eax>, unsigned int a2@<ebx>, _DWORD **a3@<esi>);
void sub_10003510();
// int __usercall sub_10003570@<eax>(size_t a1@<ecx>, unsigned __int8 a2@<al>, int *a3@<edi>, char a4, __int16 a5, void *a6);
void __cdecl sub_100035E0(size_t a1);
char __cdecl sub_10003820(int a1, int a2, char a3, size_t a4, void *a5);
char __cdecl sub_10003890(int a1, char a2, char a3);
char __cdecl sub_100038D0(int a1, char a2);
char __cdecl sub_10003900(int a1, char a2, void *a3, char a4);
char __cdecl sub_100039B0(int a1, char a2);
signed __int16 __cdecl sub_100039F0(int a1);
int __cdecl sub_10003A10(void *, int, int, char); // idb
bool __cdecl sub_10003A40(int a1);
bool __cdecl sub_10003A70(int a1, int a2);
// int __usercall sub_10003AB0@<eax>(int a1@<eax>);
// int __usercall sub_10003AD0@<eax>(int result@<eax>, int a2@<ecx>);
// int __usercall sub_10003B00@<eax>(int result@<eax>, int a2@<esi>, char a3);
// char __usercall sub_10003B40@<al>(int a1@<eax>, int a2@<ecx>);
// char __usercall sub_10003B80@<al>(int a1@<eax>, int a2@<ecx>, char a3);
// char __usercall sub_10003BD0@<al>(int a1@<edi>, int a2@<esi>, char a3);
// char __usercall sub_10003C80@<al>(int a1@<edi>, int a2);
// char __usercall sub_10003E00@<al>(int a1@<eax>, int a2@<ecx>, char a3);
// int __usercall sub_10003E40@<eax>(int a1@<eax>);
// int __usercall sub_10003E60@<eax>(int a1@<edi>);
// char __usercall sub_10003F10@<al>(int a1@<eax>);
int __cdecl sub_10003FA0(int a1, int a2, __int16 a3);
char __cdecl sub_10003FE0(int a1, unsigned int a2, int a3, _DWORD *a4);
int __cdecl sub_100040A0(int a1);
void __cdecl sub_100040C0(int a1, int a2);
int __cdecl sub_100040E0(int a1, char a2, int a3, int a4, __int16 a5, __int16 a6);
// char __usercall sub_10004190@<al>(int a1@<ecx>, int a2@<esi>);
char __cdecl sub_10004240(int a1, int a2);
char __cdecl sub_10004280(int a1, int *a2);
char __cdecl sub_10004520(int a1, int a2, void *a3, int a4);
char __cdecl sub_100045B0(int a1);
int __cdecl sub_10004620(int a1);
// signed int __usercall sub_10004630@<eax>(int a1@<eax>);
// signed int __usercall sub_10004650@<eax>(int a1@<eax>);
// char __usercall sub_10004670@<al>(unsigned int a1@<edi>, int a2@<esi>);
// char __usercall sub_100046D0@<al>(char a1@<bl>, int a2@<esi>, int *a3, char a4);
int *__thiscall sub_100047C0(void *this);
// int __usercall sub_100047F0@<eax>(int a1@<eax>, int *a2@<edi>);
// int __usercall sub_10004850@<eax>(int a1@<esi>);
// int __usercall sub_100048A0@<eax>(int a1@<esi>);
// int __usercall sub_100048B0@<eax>(int result@<eax>);
void __cdecl sub_100048C0(int a1);
char sub_10004940();
char sub_100049B0();
// signed int __usercall sub_100049D0@<eax>(int a1@<eax>);
// void __usercall sub_10004A90(int a1@<esi>);
// char __usercall sub_10004AB0@<al>(char a1@<al>, int a2@<ecx>, int a3@<edi>);
int sub_10004AE0(); // weak
// int __usercall sub_10004BA0@<eax>(int a1@<eax>);
// void __usercall sub_10004BE0(int a1@<eax>, char a2@<bl>);
// void __usercall sub_10004CA0(char a1@<al>, int a2@<ecx>);
// void __usercall sub_10004D50(char a1@<al>, int a2@<ecx>);
char __cdecl sub_10004DE0(int a1, char a2);
char __cdecl sub_10005000(int a1);
int sub_10005070(); // weak
int sub_100051A0(); // weak
int sub_10005260(); // weak
int sub_10005290(); // weak
int sub_10005330(); // weak
void __cdecl sub_100054B0(void *a1, int a2, int a3, int a4);
int sub_100055F0();
int sub_10005630();
unsigned int __cdecl sub_10005720(int a1);
signed int __cdecl sub_10005750(int a1);
int __cdecl sub_10005790(int a1, int a2, int a3, unsigned int a4, int a5, int a6);
signed int __cdecl sub_10005850(int a1, int a2, int a3, unsigned int a4, int a5);
signed int __cdecl sub_100058F0(int a1, int a2, int a3, unsigned int a4, int a5);
signed int __cdecl sub_100059A0(int a1, int a2, int a3, unsigned int a4, int a5);
signed int __cdecl sub_10005A00(int a1, int a2, int a3, unsigned int a4, int a5);
signed int sub_10005A60();
char __cdecl sub_10005A90(int a1);
char __cdecl sub_10005B20(const void *a1);
int sub_10005C40();
int *sub_10005CA0();
char sub_10005CB0();
void sub_10005CD0();
// char __usercall sub_10005D00@<al>(int a1@<eax>);
void __thiscall sub_10005D70(void *this);
void sub_10005E00();
int __cdecl sub_10005E70(int a1);
_DWORD *sub_10005E80();
char __cdecl sub_10005E90(int a1);
void __cdecl sub_10005F10(int a1, unsigned int a2, char a3);
void __cdecl sub_10005FC0(char a1, char a2);
void __cdecl sub_10005FF0(char a1);
char __cdecl sub_10006020(char *a1);
void __cdecl sub_10006050(int a1, void *a2, size_t a3);
void __cdecl sub_10006110(int a1, void *a2, size_t a3);
void __cdecl sub_100061C0(int a1, void *a2, size_t a3);
void __cdecl sub_10006290(int a1, int a2, int a3);
// int __usercall sub_10006310@<eax>(int a1@<esi>);
// int __usercall sub_10006340@<eax>(int a1@<eax>, int a2@<esi>);
int __cdecl sub_10006370(int a1, int a2, int a3, void *a4, size_t a5);
void __cdecl sub_10006400(int a1, int a2, int a3, _BYTE *a4, int a5);
void __cdecl sub_100064B0(int a1, int a2, int a3, _BYTE *a4, int a5);
char __cdecl sub_100065B0(int a1, int a2, int a3, unsigned __int8 *a4, int a5);
void __cdecl sub_100066C0(char *a1, int a2, int a3, char *a4);
char __cdecl sub_100067D0(char *a1, int a2, int a3, char *a4);
int sub_100068C0(); // weak
int __cdecl sub_10006950(int a1, int a2, __int16 a3, unsigned int a4, int a5, int a6, unsigned int a7);
char __cdecl sub_10006AE0(int a1, void *a2, size_t a3);
char __cdecl sub_10006B50(int a1);
// int __usercall sub_10006B80@<eax>(int result@<eax>);
// void *__usercall sub_10006B90@<eax>(size_t a1@<eax>, char a2@<cl>, int a3@<esi>, char a4, void *a5);
// int __usercall sub_10006BC0@<eax>(int a1@<edi>);
char __cdecl sub_10006C20(int a1, int a2, _DWORD *a3, _BYTE *a4, unsigned int a5);
// int __usercall sub_10006D50@<eax>(int a1@<eax>, int a2@<esi>);
// char __usercall sub_10006D80@<al>(int a1@<edx>, int a2@<ecx>, int a3@<edi>, int a4@<esi>);
int __cdecl sub_10006DD0(int a1, int a2, int a3, char a4, void *a5, size_t a6);
char __cdecl sub_10006E80(int a1, char a2, void *a3, size_t a4);
void __cdecl sub_10006F90(int a1, void *a2, size_t a3);
// char __usercall sub_10007040@<al>(int a1@<esi>);
// int __usercall sub_10007070@<eax>(int a1@<esi>);
// char __usercall sub_10007090@<al>(int a1@<esi>);
// char __usercall sub_100070D0@<al>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>, int a4);
// char __usercall sub_10007190@<al>(int a1@<eax>, int a2@<edi>, int a3@<esi>, int a4, _BYTE *a5);
char __cdecl sub_10007220(int a1, int a2, int a3, _BYTE *a4, int a5);
char __cdecl sub_100073F0(char *a1, int a2, _BYTE *a3, char *a4);
char __cdecl sub_100074F0(int a1, int a2, _BYTE *a3, unsigned int a4);
int __cdecl sub_10007600(int a1, int a2, __int16 a3, unsigned int a4, int a5, int a6, unsigned int a7);
char __cdecl sub_10007980(int a1, char a2, void *a3, size_t a4);
int __cdecl sub_10007AC0(int a1, int a2);
// _BYTE *__usercall sub_10007B10@<eax>(int a1@<ecx>, int a2@<edx>, char a3@<al>, char a4);
// _BYTE *__usercall sub_10007B30@<eax>(int a1@<ecx>, char a2@<al>, __int16 a3@<bx>, int a4);
// _BYTE *__usercall sub_10007B50@<eax>(int a1@<ecx>, char a2@<al>, unsigned int a3@<ebx>, int a4);
// int __usercall sub_10007B80@<eax>(int a1@<ecx>, int a2@<edx>, int a3@<eax>);
// int __usercall sub_10007BB0@<eax>(int a1@<eax>, int a2@<ecx>, const void *a3, int a4, const void *a5, __int16 a6);
int __fastcall sub_10007E20(int a1, int a2);
// _BYTE *__usercall sub_10007E50@<eax>(int a1@<eax>, char a2@<dl>, int a3);
// char __usercall sub_10007E80@<al>(int a1@<eax>, unsigned int a2@<edi>, int a3@<esi>, unsigned int a4);
// void *__usercall sub_10007ED0@<eax>(char a1@<al>, const void *a2@<edx>, int a3@<ecx>, int a4@<edi>);
// int __usercall sub_10007F00@<eax>(int a1@<eax>, int a2, _DWORD *a3, int a4);
signed int __thiscall sub_10008060(int this);
// char __usercall sub_10008070@<al>(char *a1@<esi>);
// int __usercall sub_100080A0@<eax>(_BYTE *a1@<edx>, int a2@<ecx>, unsigned int a3);
// char __usercall sub_10008140@<al>(int a1@<eax>);
// signed __int16 __usercall sub_10008160@<ax>(int a1@<edi>, int a2@<esi>);
// int __usercall sub_10008180@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<edi>, int a4);
bool __fastcall sub_100081F0(int a1, int a2);
int __cdecl sub_100082A0(int a1);
// int __usercall sub_100082B0@<eax>(int a1@<edi>, int a2@<esi>, char a3);
// char __usercall sub_10008300@<al>(_BYTE *a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>, int a4, int a5);
// signed int __usercall sub_10008340@<eax>(signed int result@<eax>, int a2@<ecx>);
// unsigned int __usercall sub_10008360@<eax>(unsigned int result@<eax>, int a2@<ecx>);
// int __usercall sub_10008390@<eax>(int a1@<ecx>, int a2@<ebx>, char a3);
unsigned __int8 __fastcall sub_10008410(int a1, int a2);
// int __usercall sub_100084B0@<eax>(int a1@<esi>);
// char __usercall sub_10008510@<al>(int a1@<esi>, int a2, unsigned int a3, int a4, int a5, int a6);
// int __usercall sub_100088C0@<eax>(int a1@<eax>, int a2@<edx>, __int16 a3@<cx>, int a4@<esi>, char a5, char a6, void *a7, size_t a8, int a9, int a10);
int __cdecl sub_10008920(int a1, __int16 a2, int a3, int a4, int a5, int a6, unsigned int a7);
// int __usercall sub_10008AB0@<eax>(int a1@<eax>, _DWORD *a2@<ecx>, char a3@<bl>, int a4);
// char __usercall sub_10008B30@<al>(int a1@<eax>, int a2@<edi>, int a3@<esi>);
void __cdecl sub_10008C10(int a1, _BYTE *a2, size_t a3, int a4);
// char __usercall sub_10008CF0@<al>(signed int a1@<eax>, int a2@<ecx>, int a3, int a4);
// int __usercall sub_10008E40@<eax>(int a1@<eax>);
// int __usercall sub_10008F10@<eax>(int a1@<eax>, void *a2, size_t a3);
// int __usercall sub_10009050@<eax>(int a1@<eax>, void *a2, size_t a3);
// size_t __usercall sub_100091F0@<eax>(int a1@<eax>, void *a2, size_t a3);
// unsigned int __usercall sub_100092C0@<eax>(int a1@<eax>, int a2@<edx>, __int16 a3@<cx>, char a4, int a5, char *a6);
// int __usercall sub_10009350@<eax>(size_t a1@<edx>, int a2@<ebx>, __int16 a3, int a4, char a5, void *a6);
// BOOL __usercall sub_100093A0@<eax>(int a1@<edi>, int a2@<esi>);
int __cdecl sub_10009400(int a1, int a2, int a3, void *a4, size_t a5);
char __cdecl sub_100094E0(int a1, void *a2, size_t a3);
char __cdecl sub_10009540(int a1, void *a2, unsigned int a3);
char __cdecl sub_10009630(int a1, void *a2, size_t a3);
// void *__usercall sub_10009740@<eax>(int a1@<eax>, int a2@<ebx>, int a3@<esi>);
char __cdecl sub_100097C0(int a1, void *a2, size_t a3, int a4);
char __cdecl sub_100098D0(int a1, void *a2, size_t a3, signed int a4);
char __cdecl sub_10009960(int a1, int a2, int a3);
int __cdecl sub_10009A00(int a1, void *a2, size_t a3);
// int __usercall sub_10009AF0@<eax>(int a1@<eax>);
// unsigned int __usercall sub_10009BC0@<eax>(unsigned int result@<eax>);
// char __usercall sub_10009C90@<al>(int a1@<edi>, int a2, _DWORD *a3, size_t a4, char *a5, char *a6);
// unsigned int __usercall sub_10009DC0@<eax>(unsigned int a1@<eax>);
// int __usercall sub_10009E50@<eax>(int a1@<eax>);
char __cdecl sub_10009EF0(int a1, _BYTE *a2, size_t a3, int a4, int a5);
// char __usercall sub_10009FA0@<al>(int a1@<eax>, int a2, unsigned int a3, _DWORD *a4, char *a5);
// char __usercall sub_1000A1E0@<al>(char *a1@<ecx>, size_t a2@<eax>, int a3, _DWORD *a4, char *a5);
size_t __cdecl sub_1000A250(int a1);
size_t __cdecl sub_1000A320(int a1, int a2, void *a3, size_t a4);
void *__cdecl sub_1000A370(int a1, int a2, char a3, size_t a4);
char __cdecl sub_1000A400(_BYTE *a1, int a2, int a3);
bool __cdecl sub_1000A470(_BYTE *a1, int a2);
// signed int __usercall sub_1000A4B0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<esi>);
char __cdecl sub_1000A520(int a1, _BYTE *a2, int a3, int a4, int a5);
bool __cdecl sub_1000A5B0(_BYTE *a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_1000A670(int a1);
// BOOL __usercall sub_1000A6C0@<eax>(int a1@<ecx>, int a2@<eax>);
int sub_1000A710();
int __cdecl sub_1000A740(int a1);
// char __usercall sub_1000A770@<al>(int a1@<ecx>, _DWORD *a2@<edi>, int a3@<esi>);
// char __usercall sub_1000A7B0@<al>(int a1@<ecx>, _DWORD *a2@<edi>, int a3@<esi>);
char __cdecl sub_1000A7F0(int a1, char a2, int a3);
int sub_1000A8F0(); // weak
int sub_1000A930(void); // weak
// int __usercall sub_1000A980@<eax>(int a1@<eax>, int a2@<ecx>);
// void __usercall sub_1000A990(int a1@<eax>, const void *a2@<edx>);
// void __usercall sub_1000A9B0(int a1@<eax>, int a2@<ecx>);
void __cdecl sub_1000A9C0(int a1, char a2, int a3, char a4);
void __cdecl sub_1000AAA0(int a1, int a2, char a3);
char __cdecl sub_1000AB60(int a1, char a2, int a3);
void __cdecl sub_1000AC40(int a1, int a2);
// int __usercall sub_1000AD00@<eax>(int a1@<esi>);
// int __usercall sub_1000AD40@<eax>(int a1@<esi>);
// void __usercall sub_1000AD80(int a1@<edi>, int a2@<esi>);
// char __usercall sub_1000ADF0@<al>(int a1@<eax>, int a2@<ecx>);
// char __usercall sub_1000AE70@<al>(int a1@<eax>, int a2@<ecx>);
int sub_1000AEB0(); // weak
int sub_1000AF00(); // weak
int sub_1000AF50(); // weak
void __cdecl sub_1000AF70(char *a1, char *a2, int a3, char *a4);
int __cdecl sub_1000B160(void *a1, int a2);
int __cdecl sub_1000B180(int a1, int a2);
int __cdecl sub_1000B1B0(int a1, int a2);
int __cdecl sub_1000B1F0(_BYTE *a1);
bool __cdecl sub_1000B210(char a1, _DWORD *a2, unsigned int a3);
signed int __cdecl sub_1000B250(int a1, int a2, _DWORD *a3, unsigned int a4, int a5, int a6);
int __thiscall sub_1000B2D0(int this);
int __cdecl sub_1000B370(int a1, int a2, int a3, unsigned int a4, int a5, int a6);
__int16 __cdecl sub_1000B3F0(int a1);
unsigned int __cdecl sub_1000B530(unsigned int a1);
int sub_1000B580();
// char __usercall sub_1000B590@<al>(const char *a1@<eax>, size_t a2@<edx>, char a3);
char sub_1000B600();
char sub_1000B630();
signed int sub_1000B6D0();
char sub_1000B6F0();
// int __usercall sub_1000B720@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4);
// char __usercall sub_1000B7F0@<al>(int a1@<esi>);
int __thiscall sub_1000B8A0(void *this);
// int __usercall sub_1000B8F0@<eax>(int a1@<edi>, int a2);
// int __usercall sub_1000B950@<eax>(int result@<eax>);
// int __usercall sub_1000B980@<eax>(unsigned int a1@<edi>, int a2@<esi>);
// int __usercall sub_1000B9D0@<eax>(int a1@<eax>);
// int __usercall sub_1000BA30@<eax>(unsigned int a1@<ecx>, int a2@<esi>);
void *sub_1000BA60();
// unsigned int __usercall sub_1000BAD0@<eax>(int a1@<esi>);
// int *__usercall sub_1000BB40@<eax>(int a1@<eax>, int a2@<ecx>);
// bool __usercall sub_1000BB80@<al>(_BYTE *a1@<ecx>, int a2@<edi>);
// void __usercall sub_1000BE80(int a1@<ebx>);
// char __usercall sub_1000BF00@<al>(int a1@<edi>, int a2@<esi>, char a3);
// unsigned int __usercall sub_1000BFA0@<eax>(int a1@<eax>, int a2@<ebx>, void *a3@<edi>);
char sub_1000BFD0();
// BOOL __usercall sub_1000C040@<eax>(int a1@<eax>, int a2@<esi>, int a3);
// BOOL __usercall sub_1000C0D0@<eax>(int a1@<esi>, int a2);
signed int sub_1000C150();
// char __usercall sub_1000C1F0@<al>(int a1@<eax>, int a2);
// char __usercall sub_1000C350@<al>(int a1@<eax>, char a2);
char __thiscall sub_1000C3C0(void *this);
// bool __usercall sub_1000C440@<al>(int a1@<eax>);
// bool __usercall sub_1000C4A0@<al>(int a1@<eax>);
char __cdecl sub_1000C4B0(unsigned int a1);
// int __usercall sub_1000C5C0@<eax>(int a1@<eax>, unsigned int a2@<ecx>, char a3);
// int *__usercall sub_1000C600@<eax>(int a1@<eax>, int a2@<ecx>, char a3);
char __cdecl sub_1000C6A0(int a1, int a2, char a3);
// int __usercall sub_1000C760@<eax>(int a1@<esi>);
// char __usercall sub_1000C7C0@<al>(int a1@<eax>, int a2);
unsigned int __cdecl sub_1000CB30(int a1, char a2);
// int __usercall sub_1000CC50@<eax>(char a1@<bl>, int a2@<edi>, int a3, char a4, int a5);
int sub_1000CD20(); // weak
int __cdecl sub_1000CEA0(int a1, char a2);
signed int __cdecl sub_1000CF40(char a1);
// char __usercall sub_1000CFE0@<al>(int **a1@<esi>, int a2);
// void __usercall sub_1000D060(_BYTE *a1@<ebx>, unsigned int *a2@<edi>, int a3, int **a4, int a5);
// void __usercall sub_1000D100(int a1@<edi>, int a2@<esi>, int a3, _BYTE *a4, int **a5, int *a6, int a7);
// char __usercall sub_1000D330@<al>(int **a1@<ebx>, int a2@<esi>, int a3, _BYTE *a4, int a5);
void *sub_1000D570();
char sub_1000D5C0();
unsigned int __cdecl sub_1000D620(int a1, int a2);
unsigned int __cdecl sub_1000D740(int a1, int a2);
// void __usercall sub_1000D800(char a1@<al>, int a2@<edx>, int a3@<ecx>);
// void __usercall sub_1000D910(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_1000D9E0@<eax>(int a1@<edx>, int a2@<esi>, int a3);
char __cdecl sub_1000DA40(_DWORD *a1);
// int __usercall sub_1000DA80@<eax>(int *a1@<edx>, int a2@<ecx>, char a3, int a4, char a5);
int sub_1000DD10(); // weak
char __cdecl sub_1000E130(int a1, int a2);
// void __usercall sub_1000E490(int a1@<edi>, int a2, int a3);
// void __usercall sub_1000E550(int a1@<eax>, int a2, int a3);
char sub_1000E6B0();
// char __usercall sub_1000E710@<al>(int *a1@<eax>, int a2@<ecx>, int a3, int **a4, int a5);
// void __usercall sub_1000E7B0(int a1@<edi>);
char sub_1000EB80();
// char __usercall sub_1000EC40@<al>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4@<edi>, int **a5, int *a6, int a7);
int __cdecl sub_1000EE90(__int16 *a1);
// _DWORD *__usercall sub_1000EEF0@<eax>(int a1@<edi>);
void __cdecl sub_1000EF20(int a1, char *a2, int a3, int a4);
// bool __usercall sub_1000F120@<al>(int a1@<edx>, int **a2@<esi>);
void __cdecl sub_1000F190(int a1, int a2);
void __cdecl sub_1000F330(int a1, int a2);
_DWORD *__cdecl sub_1000F400(_DWORD *a1, int a2);
int *__cdecl sub_1000F430(int a1, char a2);
int __cdecl sub_1000F480(int a1, int a2);
// int __usercall sub_1000F4C0@<eax>(int a1@<eax>);
// int __usercall sub_1000F510@<eax>(int a1@<eax>, unsigned __int8 a2@<dl>, int a3@<ecx>);
// int __usercall sub_1000F560@<eax>(int a1@<eax>, int a2@<esi>);
int __cdecl sub_1000F580(int a1);
void __cdecl sub_1000F5A0(int a1, int a2, unsigned __int8 a3, _BYTE *a4, int a5);
void __cdecl sub_1000FD70(int a1, int a2, int a3, int a4);
void __cdecl sub_1000FD90(int a1, int a2, int a3, int a4);
void __cdecl sub_1000FDB0(int a1, int a2, int a3, int a4);
void __cdecl sub_1000FDD0(int a1, int a2, int a3, int a4);
_DWORD *__cdecl sub_1000FDF0(int a1);
void __cdecl sub_1000FE40(int a1, int a2, int a3, int a4);
void __cdecl sub_1000FE60(int a1, int a2, int a3, int a4);
void __cdecl sub_1000FEA0(int a1, int a2, int a3, int a4);
void __cdecl sub_1000FEC0(int a1, int a2, char a3, int a4, int a5);
void __cdecl sub_1000FF30(int a1, int a2, int a3, int a4);
void __cdecl sub_1000FF50(int a1, int a2, int a3, int a4);
void __cdecl sub_1000FF70(int a1, int a2);
int sub_1000FF90(); // weak
int sub_1000FFD0(); // weak
void __cdecl sub_10010050(_DWORD *a1, int a2, int a3, int a4);
int sub_10010240(); // weak
int sub_10010290(); // weak
void __cdecl sub_100102E0(int a1, int a2, _BYTE *a3, int a4, int a5);
void __cdecl sub_10010340(int a1, int a2, int a3, int a4);
void __cdecl sub_10010360(int a1, int a2, int a3, int a4);
void __cdecl sub_100103A0(int a1, int a2, int a3);
void __cdecl sub_100103C0(int a1, int a2, char a3, int a4);
void __cdecl sub_100103F0(int a1, int a2, int a3);
void __cdecl sub_10010410(int a1, int a2, char a3, int a4);
int *__cdecl sub_10010470(int a1, const void *a2, _BYTE *a3, int a4, int a5, char a6);
void __cdecl sub_100104D0(int a1, int a2, char a3, int a4);
int __cdecl sub_10010520(int a1, int a2, __int16 a3, unsigned int a4, int a5, int a6, int a7);
_DWORD __cdecl sub_10010670(_DWORD); // weak
int sub_10010680(void); // weak
int __cdecl sub_10010690(int a1);
// void *__usercall sub_100106A0@<eax>(_BYTE *a1@<ecx>, int a2@<edi>);
unsigned int __cdecl sub_100106E0(int a1, char a2, _BYTE *a3, _BYTE *a4, unsigned int a5);
int sub_10010730();
int __cdecl sub_10010740(int a1, int a2, int a3, int a4, int a5, int a6);
unsigned int __cdecl sub_100107F0(int a1, unsigned int a2);
signed int __cdecl sub_10010880(int a1, _BYTE *a2, unsigned int a3);
signed int __cdecl sub_100108E0(int a1, int a2, unsigned int a3);
signed int __cdecl sub_100109B0(int a1, int a2, unsigned int a3);
int __cdecl sub_10010A40(int, int, void *, size_t); // idb
char __cdecl sub_10010AC0(int a1, int a2);
// signed int __usercall sub_10010AF0@<eax>(_BYTE *a1@<eax>, int a2);
// int __usercall sub_10010B20@<eax>(int result@<eax>, char **a2@<edx>, int a3@<ecx>, int a4@<esi>, unsigned int a5, int (__cdecl *a6)(char **));
// signed int __usercall sub_10010BA0@<eax>(unsigned int a1@<eax>, signed int *a2@<ebx>, int a3@<edi>);
int __cdecl sub_10010C10(int a1);
// signed int __usercall sub_10010C20@<eax>(_WORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, unsigned int a4);
// _WORD *__usercall sub_10010C90@<eax>(int a1@<eax>, _WORD *a2@<ecx>);
signed int __thiscall sub_10010CB0(void *this);
int __thiscall sub_10010CD0(int this);
// void *__usercall sub_10010D00@<eax>(int a1@<eax>, void *a2@<esi>, void *a3, int a4);
// signed int __usercall sub_10010D40@<eax>(_WORD *a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>, unsigned int a4);
// signed int __usercall sub_10010DA0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<esi>, unsigned int a5);
// signed int __usercall sub_10010E20@<eax>(int a1@<eax>, unsigned int a2@<edx>);
// int __usercall sub_10010E50@<eax>(int a1@<edx>, int a2@<ecx>, unsigned int a3@<esi>, _DWORD *a4);
// signed int __usercall sub_10010E90@<eax>(int a1@<eax>);
// int __usercall sub_10010EB0@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, int a4);
unsigned int __cdecl sub_10010ED0(int a1);
unsigned int __fastcall sub_10010F10(int a1, int a2);
// int __usercall sub_10010F40@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>);
// int __usercall sub_10010F70@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_10010FB0@<eax>(int result@<eax>, int a2);
// signed int __usercall sub_10010FC0@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>, int a4, unsigned int a5);
// signed int __usercall sub_10011040@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>, int a4);
// signed int __usercall sub_100110E0@<eax>(_BYTE *a1@<ebx>, int a2@<edi>, int a3@<esi>);
// signed int __usercall sub_10011180@<eax>(int a1@<eax>, int a2@<ebx>, _BYTE *a3@<edi>, unsigned int a4);
int __fastcall sub_10011230(int a1, int a2);
signed int __cdecl sub_100112A0(char **a1, int a2, int a3, unsigned int a4, int a5);
signed int __cdecl sub_100113A0(char **a1, int a2, int a3, unsigned int a4, int a5);
signed int __cdecl sub_100114E0(int a1, int a2, _DWORD *a3, unsigned int a4, int a5);
signed int __cdecl sub_100115B0(int a1, int a2, _DWORD *a3, unsigned int a4, int a5);
int __cdecl sub_100116C0(char **a1, int a2, int a3, unsigned int a4, int a5);
int __cdecl sub_10011830(int, int, void *, int, int); // idb
int __cdecl sub_10011950(int, int, int, void *, size_t); // idb
// int __usercall sub_10011990@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<edi>, unsigned int a4, int a5);
// int __usercall sub_10011A00@<eax>(int a1@<ecx>, int a2@<edi>, int a3, unsigned int a4, int a5);
// signed int __usercall sub_10011AB0@<eax>(int a1@<eax>, int a2@<ecx>, int a3, unsigned int a4);
// signed int __usercall sub_10011B00@<eax>(_BYTE *a1@<eax>, int a2@<ecx>);
// signed int __usercall sub_10011B30@<eax>(int a1@<eax>, int a2@<esi>, unsigned int a3);
signed int __cdecl sub_10011B90(int a1, int a2, int a3, unsigned int a4, int a5, int a6);
int __cdecl sub_10011CC0(int a1, int a2, int a3, unsigned int a4, int a5, int a6);
int __cdecl sub_10011E00(int a1, int a2, int a3, unsigned int a4, int a5, int a6);
int __cdecl sub_10011F60(int a1, int a2, int a3, unsigned int a4, int a5, int a6);
int __cdecl sub_100120D0(_BYTE *a1, int a2, int a3, unsigned int a4, int a5, int a6);
int __cdecl sub_10012210(int a1, int a2, int a3, unsigned int a4, int a5, int a6);
void __cdecl sub_10012350(int a1, int a2);
char __cdecl sub_100123E0(int a1);
// char *__usercall sub_10012400@<eax>(int a1@<eax>, int a2);
int __cdecl sub_10012480(int, int, int, float); // idb
int __cdecl sub_10012C90(int a1, int a2, int a3);
char __cdecl sub_10012CB0(char a1, _BYTE *a2);
char __cdecl sub_10012E60(int a1, int a2);
void sub_10013030();
char __thiscall sub_10013040(void *this);
int __cdecl sub_10013140(int a1, int a2);
// void __usercall sub_100131F0(int a1@<edi>);
void sub_100132A0();
char __cdecl sub_10013350(int a1, int a2);
void sub_10013430();
void __cdecl sub_10013490(int a1, int a2);
char __cdecl sub_10013500(int a1, int a2);
char __cdecl sub_10013550(int a1, int a2);
char __cdecl sub_10013580(int a1, int a2);
char __cdecl sub_100135F0(int a1, int a2);
int sub_100136E0();
char __cdecl sub_10013710(__int16 a1);
char __cdecl sub_10013780(int a1, int a2);
char sub_100137F0();
char __cdecl sub_10013900(int a1, int a2);
char __cdecl sub_10013970(int a1, int a2);
void __cdecl sub_10013A60(int a1, int a2);
char __cdecl sub_10013AE0(int a1, int a2);
char __cdecl sub_10013B60(int a1, int a2);
char __cdecl sub_10013D50(int a1, int a2);
char __cdecl sub_10013E10(int a1, int a2);
char __cdecl sub_100140B0(int a1, int a2);
char __cdecl sub_10014220(int a1, int a2);
void __cdecl sub_100142D0(int a1, int a2);
char __cdecl sub_10014350(int a1, int a2);
char __cdecl sub_100143C0(__int16 a1);
char __cdecl sub_10014450(int a1, int a2);
char __cdecl sub_10014490(int a1, int a2);
char __cdecl sub_100144D0(float a1, int a2);
char __cdecl sub_100145B0(int a1, int a2);
char __cdecl sub_10014670(int a1, int a2);
char __cdecl sub_100146B0(int a1, int a2);
char __cdecl sub_100146F0(int a1, int a2);
char __cdecl sub_10014760(int a1, int a2);
char __cdecl sub_10014800(int a1, int a2);
char __cdecl sub_100148D0(int a1, int a2);
char __cdecl sub_10014940(int a1, int a2);
char __cdecl sub_10014A40(int a1, int a2);
char __cdecl sub_10014A90(int a1, int a2);
char __cdecl sub_10014BC0(int a1, int a2);
char __cdecl sub_10014DC0(int a1, int a2);
char __cdecl sub_10014E10(int a1, int a2);
char __cdecl sub_10014E40(int a1, int a2);
char __cdecl sub_10014EC0(int a1, int a2);
char __cdecl sub_10014F70(int a1, int a2);
char __cdecl sub_10014FB0(int a1, int a2);
char __cdecl sub_10015190(int a1, int a2);
char __cdecl sub_10015210(int a1, int a2);
char __cdecl sub_10015270(float a1, int a2);
char __cdecl sub_10015300(int a1, int a2);
char __cdecl sub_10015390(int a1, int a2);
char __cdecl sub_100153D0(int a1, int a2);
char __cdecl sub_10015410(int a1, int a2);
char __cdecl sub_10015450(int a1, int a2);
char __cdecl sub_10015490(int a1, int a2);
char __cdecl sub_100154C0(int a1, int a2);
char __cdecl sub_10015650(int a1, int a2);
char __cdecl sub_100156A0(int a1, int a2);
char __cdecl sub_10015710(int a1, int a2);
char __cdecl sub_10015750(int a1, int a2);
char __cdecl sub_100158C0(int a1, int a2);
char __cdecl sub_10015980(int a1, int a2);
char __cdecl sub_10015A00(int a1, int a2);
char __cdecl sub_10015A40(int a1, int a2);
char __cdecl sub_10015CB0(int a1, int a2);
char __cdecl sub_10015CE0(int a1, int a2);
char __cdecl sub_10015D20(int a1, int a2);
char __cdecl sub_10015D50(int a1, int a2);
char __cdecl sub_10015D90(int a1, int a2);
void __cdecl sub_10015DE0(int a1, int a2);
int __cdecl sub_10015F50(int a1, unsigned int a2);
// unsigned __int16 __usercall sub_10016170@<ax>(unsigned __int8 a1@<dl>, char a2@<cl>, unsigned __int16 *a3@<edi>, unsigned int a4, unsigned __int8 a5);
// char __usercall sub_100162F0@<al>(int a1@<esi>);
// unsigned int __usercall sub_100163E0@<eax>(_DWORD *a1@<ecx>, unsigned int a2@<ebx>, unsigned int a3, unsigned __int8 a4, int a5);
bool __cdecl sub_100166F0(__int16 a1);
// char __usercall sub_10016720@<al>(unsigned int *a1@<edi>, int a2@<esi>, int a3, int a4);
char sub_100167D0();
// char __usercall sub_10016A80@<al>(unsigned int a1@<ebx>, int a2, int a3);
char __cdecl sub_10016C10(int a1, int a2);
char __cdecl sub_10016C30(int a1, int a2);
char __cdecl sub_10016C50(int a1, int a2);
void *sub_10017250();
char __cdecl sub_10017280(int a1, int a2);
char __cdecl sub_10017310(void *a1);
char __cdecl sub_100173A0(int a1, int a2);
char __cdecl sub_100173E0(int a1, int a2);
char __cdecl sub_10017420(int a1, int a2);
char __cdecl sub_10017460(int a1, int a2);
char sub_100174A0();
char __cdecl sub_10017B20(int a1);
char __cdecl sub_10017BE0(float a1, int a2);
char sub_10017DB0();
// unsigned int __usercall sub_10017E20@<eax>(int a1@<eax>);
int sub_10017E40();
// void __usercall __noreturn sub_10018290(int a1@<edi>);
signed int __cdecl sub_10018440(int a1);
signed int __cdecl sub_10018460(int a1);
char **sub_100184A0();
// char __usercall sub_100184B0@<al>(char a1@<dl>, int a2@<ecx>, int a3);
char __cdecl sub_10018500(int a1, int a2, char a3);
char __cdecl sub_10018520(int a1, int a2);
char __cdecl sub_10018590(int a1, int a2, int a3, int a4, int a5, int a6, unsigned __int16 a7, char a8);
int __cdecl sub_10018630(char a1, int a2);
char __cdecl sub_10018680(int a1, int a2);
int __cdecl sub_100186A0(char a1, int a2);
int __cdecl sub_100186C0(int a1);
int sub_100186E0();
char sub_100186F0();
int sub_10018700();
char sub_10018710();
void sub_10018720();
int (__cdecl *sub_10018730())(_DWORD);
int __cdecl sub_10018760(char, char, char, char, int, void *, size_t); // idb
void *__cdecl sub_10018810(int a1);
// signed int __usercall sub_100188D0@<eax>(unsigned int a1@<eax>, int a2, char *a3, unsigned __int16 a4);
signed int sub_10018AB0();
void *sub_10018B00();
void *sub_10018B20();
void *sub_10018B40();
char __cdecl sub_10018B60(char a1, char a2, char a3, char a4, int a5, void *a6, size_t a7);
void *sub_10018D00();
// char __usercall sub_10018D50@<al>(char *a1@<eax>, int a2@<ebx>, unsigned __int16 a3@<di>, unsigned int a4);
char __cdecl sub_10018E20(char *a1);
int sub_10019100();
char __cdecl sub_100193C0(int a1);
unsigned __int8 __cdecl sub_100195E0(unsigned __int8 a1);
int __cdecl sub_10019770(unsigned __int8 a1);
char __cdecl sub_10019820(signed int a1);
// char __usercall sub_10019910@<al>(unsigned __int8 a1@<bl>, __int16 *a2@<esi>);
char __cdecl sub_10019990(int a1);
char __cdecl sub_10019A20(int a1, int a2, int a3, int a4, char a5, char *a6);
char sub_10019AA0();
void *sub_10019AE0();
// char __usercall sub_10019B40@<al>(int a1@<ecx>, unsigned __int8 a2@<bl>, char a3);
// char __usercall sub_10019BC0@<al>(unsigned __int8 a1@<bl>, void *a2);
// char __usercall sub_10019C00@<al>(unsigned __int8 a1@<cl>, _DWORD *a2@<esi>);
char __cdecl sub_10019C50(unsigned __int8 a1, int a2, unsigned __int8 a3);
// char __usercall sub_10019D00@<al>(int a1@<edx>, unsigned __int8 a2@<cl>, unsigned __int8 a3, char a4);
char __cdecl sub_10019F00(unsigned __int8 a1, char a2, unsigned __int8 a3);
// char __usercall sub_1001A100@<al>(int a1@<ecx>, unsigned __int8 a2@<bl>);
// int __usercall sub_1001A160@<eax>(unsigned __int8 a1@<bl>, int a2);
// BOOL __usercall sub_1001A190@<eax>(unsigned __int8 a1@<al>, char a2@<bl>, _BYTE *a3);
char __cdecl sub_1001A1D0(char a1);
bool __cdecl sub_1001A330(char a1, char a2, unsigned __int8 *a3);
char __cdecl sub_1001A5A0(char a1, int a2, char a3, unsigned __int8 *a4, const void *a5, int a6);
char __cdecl sub_1001A730(char a1, char a2, char a3, _BYTE *a4);
bool __cdecl sub_1001A840(char a1, char a2, unsigned __int8 *a3);
void __cdecl sub_1001AAB0(char a1, int a2);
int __fastcall sub_1001ABC0(unsigned __int8 a1);
// char __usercall sub_1001ABF0@<al>(unsigned __int8 a1@<al>, unsigned __int8 a2@<bl>);
// char __usercall sub_1001AC40@<al>(int a1@<edi>, unsigned __int8 a2);
// char __usercall sub_1001ACC0@<al>(signed int a1@<eax>);
char sub_1001AD60();
int sub_1001AE90();
// char __usercall sub_1001B110@<al>(int a1@<eax>, unsigned __int8 a2@<dl>);
int __cdecl sub_1001B170(signed int a1);
unsigned __int8 __cdecl sub_1001B1C0(signed int a1, int a2);
int sub_1001B290();
char __cdecl sub_1001B350(unsigned __int8 a1, unsigned __int8 a2);
// char __usercall sub_1001B430@<al>(unsigned __int8 a1@<cl>, int a2@<edi>);
// char __usercall sub_1001B4E0@<al>(int a1@<eax>, unsigned __int8 a2@<cl>, int a3, char a4);
BOOL __cdecl sub_1001B6D0(int a1, int a2);
int sub_1001B7E0();
// char __usercall sub_1001B7F0@<al>(char result@<al>);
// char __usercall sub_1001B880@<al>(int a1@<esi>);
char __cdecl sub_1001B8F0(unsigned __int8 a1, int a2);
char __cdecl sub_1001B9B0(int a1, int a2);
char __cdecl sub_1001BA90(int a1, int a2, int a3, int a4, char a5, int a6);
char sub_1001BAE0();
char sub_1001BB50();
char sub_1001BC80();
char __cdecl sub_1001BCC0(char a1, _BYTE *a2);
char __cdecl sub_1001BD10(unsigned __int8 a1, char a2);
// char __usercall sub_1001BD30@<al>(unsigned int *a1@<esi>);
char sub_1001BD90();
char __cdecl sub_1001BE10(char a1);
char sub_1001BE30();
char __cdecl sub_1001BE80(int a1, char a2);
char __cdecl sub_1001BFA0(int a1, int a2, int a3, int a4, void *a5, size_t a6);
char __cdecl sub_1001C030(unsigned __int8 a1, signed int a2);
char __cdecl sub_1001C100(void *a1);
// char __usercall sub_1001C170@<al>(char a1@<bl>);
char sub_1001C240();
char __cdecl sub_1001C2A0(char a1);
// char __usercall sub_1001C2D0@<al>(int a1@<eax>, char a2);
char __cdecl sub_1001C330(int a1);
char __cdecl sub_1001C350(int a1);
char sub_1001C360();
char sub_1001C460();
void *sub_1001C490();
// char __usercall sub_1001C4C0@<al>(unsigned __int8 a1@<al>);
// char __usercall sub_1001C4E0@<al>(unsigned __int8 a1@<bl>, signed int a2);
// int __usercall sub_1001C5B0@<eax>(char a1@<bl>, int a2);
// int __usercall sub_1001C630@<eax>(char a1@<bl>, int a2);
char __cdecl sub_1001C680(char a1, int a2, int a3, int a4, char a5, char *a6);
char __cdecl sub_1001C6F0(char a1, char a2, int a3);
char __cdecl sub_1001C870(unsigned __int8 a1, int a2, int a3, int a4, signed int a5, int a6);
char __cdecl sub_1001C920(unsigned __int8 a1, int a2, int a3, int a4, signed int a5, int a6);
char __cdecl sub_1001C930(char a1, char a2, char a3, int a4, int *a5);
void __cdecl sub_1001CA20(__int16 a1);
char __cdecl sub_1001CAC0(int a1);
char __cdecl sub_1001CC00(__int16 a1);
// char __usercall sub_1001CCB0@<al>(char result@<al>, char a2);
int __cdecl sub_1001CE30(char a1, char a2);
// char __usercall sub_1001CED0@<al>(int a1@<eax>, void *a2@<ecx>, __int16 a3@<bx>);
void sub_1001CF40();
char __cdecl sub_1001D0D0(int a1, int a2);
signed int sub_1001D350();
char __cdecl sub_1001D3B0(char a1, _BYTE *a2);
char sub_1001D430();
char sub_1001D440();
char __cdecl sub_1001D470(char a1);
// signed int __usercall sub_1001D480@<eax>(char a1@<al>);
bool __cdecl sub_1001D4A0(char a1);
char __cdecl sub_1001D4B0(char a1, char a2);
// char __usercall sub_1001D530@<al>(void *a1@<esi>, int a2);
// char __usercall sub_1001D590@<al>(void *a1@<esi>, char a2);
// char __usercall sub_1001D5C0@<al>(int a1@<ecx>, char a2@<dl>, int a3@<eax>, int a4@<esi>, void *a5, int a6);
char __cdecl sub_1001D5F0(char a1);
char __cdecl sub_1001D640(char a1, int a2, char a3, int a4, char *a5);
char __cdecl sub_1001D8F0(char a1, int a2, int a3, int a4, char a5, int a6);
char __cdecl sub_1001D950(char a1, char a2);
char __cdecl sub_1001D9D0(char a1, char a2, int a3);
char sub_1001DE20();
char __cdecl sub_1001DE50(unsigned __int8 a1, signed int a2);
char __cdecl sub_1001DF80(char a1);
char __cdecl sub_1001DFC0(char a1);
char __fastcall sub_1001E160(unsigned int a1);
char __cdecl sub_1001E190(signed int a1);
char __cdecl sub_1001E220(signed int a1, int a2, int a3, __int16 a4);
int __cdecl sub_1001E2B0(float); // idb
int __cdecl sub_1001E2D0(double, double); // idb
int sub_1001E320();
// __int16 __usercall sub_1001E340@<ax>(int a1@<esi>, unsigned __int8 a2);
// char __usercall sub_1001E3D0@<al>(__int16 a1@<ax>);
bool __cdecl sub_1001E440(char a1, __int16 a2);
// unsigned __int8 __usercall sub_1001E470@<al>(__int16 a1@<di>);
// char __usercall sub_1001E510@<al>(__int16 a1@<si>);
// void __usercall sub_1001E580(__int16 a1@<si>);
// char __usercall sub_1001E7F0@<al>(int a1@<esi>);
// char __usercall sub_1001E830@<al>(char a1@<al>);
// char __usercall sub_1001E840@<al>(__int16 a1@<cx>, int a2@<edi>, char a3);
void __cdecl sub_1001EA80(int a1, int a2);
int sub_1001EB20();
char __cdecl sub_1001EB40(int a1, int a2);
char __cdecl sub_1001EC50(char a1);
void __cdecl sub_1001EC70(__int16 a1);
int __cdecl sub_1001EC90(int a1);
char sub_1001ECA0();
void __cdecl sub_1001ED70(int a1, int a2);
char __cdecl sub_1001EDF0(_BYTE *a1);
char __cdecl sub_1001EE30(int a1, int a2, int a3, int a4, char a5, int a6);
char sub_1001EE80();
char sub_1001EE90();
char sub_1001EFA0();
char __cdecl sub_1001EFD0(char a1);
BOOL sub_1001EFE0();
char __cdecl sub_1001F010(void *a1, int a2);
// int __usercall sub_1001F040@<eax>(int result@<eax>, char a2);
// char __usercall sub_1001F060@<al>(int a1@<ecx>, char a2@<dl>, int a3@<eax>, int a4@<esi>, void *a5);
char sub_1001F090();
char __cdecl sub_1001F0C0(signed int a1);
char __cdecl sub_1001F160(char a1);
// char __usercall sub_1001F1E0@<al>(const void *a1@<ebx>);
char __cdecl sub_1001F280(int a1, char a2);
char __cdecl sub_1001F400(char a1, int a2, char a3, int a4, int *a5, int a6);
char __cdecl sub_1001F520(int a1, char a2);
char __thiscall sub_1001F610(void *this);
char __cdecl sub_1001F660(signed int a1);
char __cdecl sub_1001F6D0(int a1);
char __cdecl sub_1001F720(unsigned __int16 a1);
char sub_1001F7F0();
// unsigned __int8 __usercall sub_1001F900@<al>(__int16 a1@<si>, int a2);
// __int16 __usercall sub_1001F960@<ax>(__int16 a1@<ax>, char a2);
char __thiscall sub_1001FA50(void *this);
signed int sub_1001FA90();
int sub_1001FB30(void); // weak
// int __usercall sub_1001FB40@<eax>(int a1@<eax>, int a2@<ecx>, unsigned __int16 a3);
// signed int __usercall sub_1001FC00@<eax>(int a1@<edi>, int a2, unsigned __int16 a3, unsigned __int16 a4);
// char __usercall sub_1001FCF0@<al>(char a1@<bl>);
int *__cdecl sub_1001FD40(char a1, char a2);
// char __usercall sub_1001FE80@<al>(unsigned __int16 a1@<si>);
// int __usercall sub_1001FF30@<eax>(unsigned __int16 a1@<ax>, int a2);
char __cdecl sub_1001FF70(__int16 a1, int a2);
char __cdecl sub_10020190(int a1);
signed int sub_10020540();
char __cdecl sub_10020680(unsigned __int16 a1);
// unsigned int __usercall sub_10020810@<eax>(int a1@<edi>);
// char __usercall sub_10020A80@<al>(unsigned __int16 a1@<ax>);
char __cdecl sub_10020BB0(int a1, int a2);
char __cdecl sub_10021370(_BYTE *a1);
char __cdecl sub_100213E0(int a1, int a2, int a3, int a4, char a5, char *a6);
char sub_10021430();
char sub_10021440();
char __cdecl sub_10021470(char a1);
int __thiscall sub_10021480(int this);
char __cdecl sub_10021620(void *a1, int a2);
// int __usercall sub_10021650@<eax>(int result@<eax>, char a2);
// char __usercall sub_10021670@<al>(int a1@<ecx>, char a2@<dl>, int a3@<eax>, int a4@<esi>, void *a5);
char __cdecl sub_100216A0(int a1);
char sub_10021890();
char __cdecl sub_100218C0(signed int a1);
char __thiscall sub_10021960(void *this);
// char __usercall sub_100219E0@<al>(int a1@<ebx>);
char __cdecl sub_10021A70(int a1, char a2);
char __cdecl sub_10021BE0(char a1, int a2, int a3, int a4, int a5, int a6);
char __cdecl sub_10021DC0(int a1, char a2);
char sub_10021EB0();
char __cdecl sub_10021F10(signed int a1);
char __cdecl sub_10021F90(int a1);
// signed __int16 __usercall sub_10022000@<ax>(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_10022020@<eax>(int a1@<esi>, signed int a2);
// int __usercall sub_10022220@<eax>(int a1@<eax>, int a2@<esi>, int a3);
char __cdecl sub_10022340(int a1, int a2);
signed __int16 __cdecl sub_100223C0(int a1, int a2);
char __cdecl sub_100223D0(_DWORD *a1, _WORD *a2, _DWORD *a3, int a4, int a5);
char __cdecl sub_10022450(int a1, int a2, void *a3, unsigned __int16 a4);
int __cdecl sub_10022640(int a1, int a2);
char __cdecl sub_10022690(int a1, int a2, void *a3, unsigned __int16 *a4, unsigned __int16 a5);
int __cdecl sub_100228A0(int a1);
int __cdecl sub_10022950(int a1);
char __cdecl sub_10022A00(int a1);
int __cdecl sub_10022E00(int a1);
char __cdecl sub_10023190(int a1, char a2, int a3, const void *a4, int a5);
char __cdecl sub_100234A0(int a1, unsigned __int16 a2, char a3, int a4, const void *a5, int a6);
char __cdecl sub_10023790(int a1, int a2, int a3);
char __cdecl sub_10023A50(int a1, int a2, void *a3, char a4, int a5);
int __cdecl sub_10023CE0(int a1);
char __cdecl sub_10023DA0(int a1, int a2, void *a3);
char __cdecl sub_10023DC0(int a1, int a2, void *a3, unsigned __int16 *a4);
int __cdecl sub_10023DF0(int a1);
char __cdecl sub_10023F40(int a1, int a2);
char sub_10023FC0();
int __cdecl sub_10023FD0(int a1);
int __cdecl sub_10023FE0(int a1, int a2, unsigned __int16 a3, char a4, char a5);
int __cdecl sub_10024090(int a1);
char __cdecl sub_100240A0(int a1, int a2);
char sub_10024240();
signed int sub_100243C0();
int sub_10024550();
int sub_10024570();
int __cdecl sub_100246D0(char a1);
signed int sub_100246F0();
// signed int __usercall sub_10024740@<eax>(char a1@<al>, int a2@<ecx>);
// int __usercall sub_100247E0@<eax>(char a1@<al>);
// int __usercall sub_10024800@<eax>(char a1@<al>);
// signed __int16 __usercall sub_10024820@<ax>(char a1@<al>, unsigned __int16 a2@<si>);
char __cdecl sub_10024A50(char a1, unsigned __int16 a2, _BYTE *a3);
char __cdecl sub_10024BA0(char a1, unsigned __int16 a2, void *a3);
char __cdecl sub_10024D10(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_10024E60(int a1, int a2, void *a3, char a4, int a5, int a6);
char __cdecl sub_10025010(char a1, int a2, int a3);
char __cdecl sub_10025120(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6);
char __cdecl sub_10025390(char a1, int a2, __int16 a3, __int16 a4, void *a5);
char __cdecl sub_100253C0(char a1, int a2, void *a3);
char __cdecl sub_100253F0(char a1, int a2, void *a3, int a4);
const char *__cdecl sub_10025420(int a1, unsigned __int16 a2);
int __cdecl sub_10025450(char a1, int a2);
char __cdecl sub_10025570(char a1);
int sub_100255E0();
char __cdecl sub_100255F0(int a1, int a2);
unsigned __int8 __cdecl sub_10025750(int a1, int a2);
int __cdecl sub_100257B0(int a1);
int __thiscall sub_100259E0(void *this);
char __cdecl sub_10025A10(int a1, float a2, float a3, int a4);
char __cdecl sub_10025B00(int a1, float a2, float a3);
void __thiscall sub_10025B50(void *this);
int __thiscall sub_10025C30(void *this);
// bool __usercall sub_10025E20@<al>(void *a1@<ecx>, int a2@<esi>);
void sub_10025E50();
signed int __cdecl sub_10026240(unsigned int a1);
// _BYTE *__usercall sub_10026270@<eax>(char a1@<bl>, int a2@<esi>);
// _DWORD *__usercall sub_10026310@<eax>(int a1@<ecx>, int a2@<esi>);
// signed int __usercall sub_10026330@<eax>(int a1@<eax>, int a2@<edx>, void *a3@<ecx>);
signed int sub_10026350();
// char __usercall sub_100263D0@<al>(int a1@<esi>, char a2, int a3, char a4, int a5, int a6, int a7, int a8, __int16 a9, int a10);
// char __usercall sub_10026810@<al>(const void *a1@<eax>, int a2@<ebx>, char a3, unsigned __int16 a4);
int sub_100268A0();
char __cdecl sub_10026940(char a1, int a2, char a3, int a4, const char *a5, int a6, int a7, __int16 a8, int a9);
_BYTE *__cdecl sub_100269B0(char a1);
// _BYTE *__usercall sub_10026A70@<eax>(_BYTE *result@<eax>, int a2@<edx>, int a3@<ecx>);
// __int16 __usercall sub_10026D90@<ax>(unsigned __int64 a1@<edx:eax>);
char __thiscall sub_10026FA0(void *this);
// _BYTE *__usercall sub_100272C0@<eax>(int a1@<esi>);
char __thiscall sub_10027540(int this);
char __cdecl sub_100276B0(int a1, int a2);
void __thiscall sub_100277B0(int *this);
char sub_10027840();
char __cdecl sub_100278D0(int a1, int a2);
char __cdecl sub_10027930(int a1, int a2, __int16 a3);
int __cdecl sub_10027980(int a1, int a2);
char __cdecl sub_100279D0(int a1);
__int16 __thiscall sub_10027A80(void *this);
char __cdecl sub_10027AB0(int a1, int a2, unsigned __int16 a3);
char __cdecl sub_10027C10(const void *a1, unsigned __int16 a2, int a3);
char __cdecl sub_10027C50(int a1, int a2);
int __cdecl sub_10027CE0(int a1, __int16 a2, int a3);
char __cdecl sub_10027D90(int a1, int a2);
int sub_10027DE0();
int __cdecl sub_10027E30(char a1);
char __cdecl sub_10027E60(int a1, int a2, int a3, int a4, char a5, char *a6);
void *sub_10027EC0();
char __cdecl sub_10027EF0(char a1, int a2);
int __cdecl sub_100280A0(char a1, __int16 a2);
char __cdecl sub_10028110(char a1, char a2, _BYTE *a3);
char __cdecl sub_10028400(char a1, int a2, char a3, int a4, int a5, size_t a6);
char __cdecl sub_10028780(char a1, char a2, char a3, int a4, __int16 *a5);
char __cdecl sub_10028980(char a1, char a2);
char sub_10028C50();
void __cdecl sub_10028C80(__int16 a1);
int __cdecl sub_10028CF0(unsigned __int8 a1);
int __cdecl sub_10028D50(unsigned __int8 a1, unsigned __int8 a2, _BYTE *a3);
char __cdecl sub_10028F90(char a1, _BYTE *a2, char a3);
char sub_100291D0();
char __cdecl sub_10029200(char a1);
char sub_10029380();
bool __thiscall sub_10029410(void *this);
char sub_10029460();
void __cdecl sub_10029560(int a1, int a2);
_DWORD sub_10029FA0(); // weak
int __cdecl sub_10029FB0(char, void *, size_t, int); // idb
char **sub_1002A020();
char **sub_1002A030();
char sub_1002A040();
char sub_1002A190();
bool __thiscall sub_1002A1D0(void *this);
char sub_1002A300();
bool sub_1002A410();
int (**sub_1002A460())();
char __cdecl sub_1002A470(int a1);
int __cdecl sub_1002A6C0(float, float, float); // idb
double __cdecl sub_1002A710(char a1);
signed int __cdecl sub_1002A7A0(char a1);
char __cdecl sub_1002A7C0(float *a1);
char sub_1002A930();
bool __cdecl sub_1002A950(_BYTE *a1, _BYTE *a2, float *a3);
char __cdecl sub_1002A9C0(int a1);
char __cdecl sub_1002AA10(char a1);
char __cdecl sub_1002AA80(char a1, char a2, float *a3);
char __cdecl sub_1002ABC0(char a1, float *a2);
char sub_1002AD10();
double __cdecl sub_1002AD60(_BYTE *a1);
char __cdecl sub_1002AEA0(float *a1);
char __cdecl sub_1002B0D0(float *a1);
double __cdecl sub_1002B240(float a1);
char __cdecl sub_1002B2B0(float *a1);
char __cdecl sub_1002B450(float *a1);
unsigned int __cdecl sub_1002B600(char a1, _BYTE *a2, float *a3);
void __cdecl sub_1002B7F0(float *a1, float *a2, int a3);
double __cdecl sub_1002B8B0(int a1, int a2);
bool __cdecl sub_1002B8D0(unsigned __int8 a1, float *a2);
signed __int16 sub_1002B9D0();
char sub_1002B9F0();
char __cdecl sub_1002BA50(float *a1);
char __cdecl sub_1002BAA0(float *a1, float *a2);
char __cdecl sub_1002BB90(float *a1, float *a2, float *a3, float *a4);
char __cdecl sub_1002BCE0(float *a1, float *a2, _BYTE *a3);
char __cdecl sub_1002BD60(float *a1);
char __cdecl sub_1002BE00(char a1);
void __cdecl sub_1002BE50(int a1, int a2, int a3, float *a4, int a5);
char sub_1002BF80();
char sub_1002BFA0();
char __cdecl sub_1002BFC0(_BYTE *a1, int a2);
int __cdecl sub_1002C040(_BYTE *a1, int a2);
int __cdecl sub_1002C090(_BYTE *a1, unsigned int a2);
signed int __cdecl sub_1002C160(_BYTE *a1, int a2);
void *__cdecl sub_1002C1E0(void *a1);
void __cdecl sub_1002C200(int a1);
char __cdecl sub_1002C400(unsigned __int8 a1, int a2);
bool __cdecl sub_1002C450(int a1);
int __cdecl sub_1002C480(char, float); // idb
char __cdecl sub_1002C520(unsigned int a1);
BOOL __cdecl sub_1002C550(int a1);
int __cdecl sub_1002C580(unsigned __int8 a1);
int __cdecl sub_1002C5A0(unsigned __int8 a1);
char sub_1002C5C0();
char __cdecl sub_1002C5D0(int a1, unsigned __int8 a2);
char __cdecl sub_1002C610(int a1, char a2, float a3, int a4, char a5, char a6, float a7, float a8, int a9, int a10);
char __cdecl sub_1002C750(int a1, char a2, int a3, char a4, char a5, float a6, float a7, int a8, int a9);
char __cdecl sub_1002C7A0(float a1, int a2, int a3);
char __cdecl sub_1002C850(float a1, int a2, int a3);
int __cdecl sub_1002CAB0(int, float, int); // idb
void __cdecl sub_1002CAD0(int a1, int a2, int a3, int a4, int a5, float a6);
char __cdecl sub_1002CB40(int a1, int a2);
bool __cdecl sub_1002CB80(int a1);
void __cdecl sub_1002CD10(void *a1);
int __cdecl sub_1002CDC0(int a1);
BOOL __cdecl sub_1002CE10(char a1);
char __cdecl sub_1002CE60(int a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
char __cdecl sub_1002D210(void *a1);
void sub_1002D280();
signed int sub_1002D290();
char sub_1002D2A0();
__int16 __cdecl sub_1002D2C0(char a1, char a2);
__int16 __cdecl sub_1002D330(char a1, char a2);
char __cdecl sub_1002D3A0(char a1, signed __int16 *a2);
char __thiscall sub_1002D4D0(void *this);
char __cdecl sub_1002D4F0(void *a1, char *a2);
bool __cdecl sub_1002D570(char a1, bool *a2);
bool __cdecl sub_1002D5F0(char a1, bool *a2);
char sub_1002D670();
char __cdecl sub_1002D750(void *a1);
char __cdecl sub_1002D8A0(__int16 a1, char *a2, __int16 a3, int a4);
int __cdecl sub_1002D9D0(char *a1, __int16 a2);
signed int __cdecl sub_1002DAB0(char *a1, char *a2);
const char *__cdecl sub_1002DBF0(const char *a1, int a2);
void sub_1002DC70();
signed int sub_1002DC80();
char __cdecl sub_1002DC90(unsigned int a1);
int __cdecl sub_1002DD90(unsigned __int8 a1);
char __cdecl sub_1002DDC0(unsigned __int8 a1, int a2, char a3, int a4);
// signed int __usercall sub_1002DE40@<eax>(signed int result@<eax>, int a2@<ecx>);
// char __usercall sub_1002DE60@<al>(int a1@<eax>, unsigned __int8 a2);
int __cdecl sub_1002DF00(int a1);
// signed int __usercall sub_1002DF40@<eax>(unsigned __int8 a1@<bl>, int a2);
// char __usercall sub_1002E0B0@<al>(char a1@<al>);
int __fastcall sub_1002E0E0(int a1, int a2);
void __cdecl sub_1002E110(unsigned int a1, int a2);
char __cdecl sub_1002E250(int a1, int a2);
int __cdecl sub_1002E300(char a1, int a2);
signed int __cdecl sub_1002E330(unsigned __int8 a1);
// signed int __usercall sub_1002E450@<eax>(unsigned __int8 a1@<dl>, int a2@<ecx>, _DWORD *a3);
// void __usercall sub_1002E560(int a1@<ecx>, int a2@<esi>);
signed int __cdecl sub_1002E590(const char *a1, int a2, signed int *a3);
signed int __cdecl sub_1002E680(char a1, const char *a2, int a3, signed int *a4);
char __cdecl sub_1002E770(unsigned int a1, int a2);
void __cdecl sub_1002E890(unsigned int a1, int a2);
double *__cdecl sub_1002E9E0(char a1, char a2, double *a3);
void __cdecl sub_1002EB10(unsigned int a1, char *a2);
unsigned __int8 __cdecl sub_1002EB70(unsigned int a1);
int __cdecl sub_1002EBA0(unsigned int a1, unsigned __int8 a2, char a3);
int __cdecl sub_1002EC20(unsigned int a1);
char __cdecl sub_1002EC50(__int64 a1);
double __cdecl sub_1002ECF0(unsigned int a1);
char sub_1002ED60();
// int __usercall sub_1002ED80@<eax>(int result@<eax>, char a2@<dl>, char a3@<cl>, char a4, char a5, char a6, char a7);
int sub_1002EDB0();
// char __usercall sub_1002EDE0@<al>(char a1@<bl>, char *a2@<edi>, int a3@<esi>, int a4, int a5, char a6, void *a7, size_t a8);
char __cdecl sub_1002F000(int a1, char a2, char a3, int a4, void *a5, size_t a6);
char __cdecl sub_1002F090(int a1, char a2, char a3, int a4, void *a5, size_t a6);
signed int __cdecl sub_1002F140(int a1, int a2);
signed int __cdecl sub_1002F240(int a1, int a2);
int __cdecl sub_1002F340(int a1, unsigned __int8 a2);
int __cdecl sub_1002F380(int a1, unsigned __int8 a2);
char __cdecl sub_1002F3C0(int a1, int a2, char a3);
int __cdecl sub_1002F4D0(int a1, int a2);
int __thiscall sub_1002F500(int this);
// int __usercall sub_1002F540@<eax>(int a1@<edx>, int a2@<edi>, int a3@<esi>);
int __cdecl sub_1002F5A0(int a1);
char __fastcall sub_1002F5B0(int a1, int a2);
// char __usercall sub_1002F5D0@<al>(int a1@<eax>, int a2@<ecx>, int a3);
// unsigned int __usercall sub_1002F5F0@<eax>(char a1@<dl>, int a2@<ecx>, int a3);
// int __usercall sub_1002F610@<eax>(int a1@<eax>, int a2@<edi>, int a3@<esi>);
int __cdecl sub_1002F680(int a1, _DWORD *a2);
char __cdecl sub_1002F6D0(int a1, int a2);
int __cdecl sub_1002F710(int a1, int a2, char a3);
int __cdecl sub_1002F770(int a1, int a2, int a3, unsigned int a4, int a5, int a6, int a7);
char __cdecl sub_1002F8C0(int a1, int a2);
unsigned int __cdecl sub_1002F920(int a1, int a2, void *a3);
// char __usercall sub_1002F9A0@<al>(int a1@<eax>, int a2@<ebx>, int a3, int a4);
char __cdecl sub_1002FB00(int a1);
BOOL __cdecl sub_1002FC20(signed int a1);
// char __usercall sub_1002FC40@<al>(int a1@<edi>, unsigned int a2@<esi>, char a3);
// char __usercall sub_1002FD00@<al>(char a1@<bl>, int a2@<edi>);
char sub_1002FD80();
// char __usercall sub_1002FE40@<al>(int a1@<eax>);
// char __usercall sub_1002FE70@<al>(int a1@<esi>, char *a2);
char __cdecl sub_1002FF40(char a1);
char __cdecl sub_1002FF60(char a1, unsigned __int8 a2, int a3, char a4);
char __cdecl sub_10030060(char a1, int a2, char a3, char a4, char a5, int a6, char a7, char a8);
char __cdecl sub_10030260(unsigned __int8 a1, int a2, char a3, char a4, char a5, char a6, char a7);
// void __usercall sub_100303B0(int a1@<eax>, int a2@<esi>, char a3);
// char __usercall sub_10030450@<al>(int a1@<esi>, int a2, int a3, int a4, int a5, char a6, char a7, float a8);
char *__cdecl sub_10030640(char a1, char *a2);
// char __usercall sub_100306A0@<al>(_BYTE *a1@<edi>, _BYTE *a2@<esi>, int a3, char a4, _BYTE *a5);
signed int __cdecl sub_10030750(signed int a1, char a2);
// int __usercall sub_100307C0@<eax>(unsigned __int16 a1@<di>, signed int a2, signed int a3, unsigned __int8 a4);
signed int __cdecl sub_10030B70(int a1, char a2, char a3);
// int __usercall sub_10030BF0@<eax>(int a1@<eax>, unsigned __int8 a2);
// int __usercall sub_10030C50@<eax>(unsigned __int8 a1@<al>, int a2, char a3, char a4);
// char __usercall sub_10030C80@<al>(int a1@<eax>, int a2);
// char __usercall sub_10030CE0@<al>(int a1@<esi>, int a2, unsigned __int16 a3);
// char __usercall sub_10030D80@<al>(int a1@<eax>, int a2);
signed int __thiscall sub_10030DE0(int this);
// int __usercall sub_10030ED0@<eax>(char a1@<al>, char a2@<dl>, int a3@<ecx>, _DWORD *a4@<edi>, unsigned __int8 a5, char a6, _BYTE *a7, int *a8);
// int __usercall sub_10030F80@<eax>(int result@<eax>);
// char __usercall sub_10030FD0@<al>(_BYTE *a1@<edi>, int *a2@<esi>);
// char __usercall sub_10031010@<al>(_BYTE *a1@<edi>, _DWORD *a2@<esi>, unsigned __int16 a3);
char __cdecl sub_10031080(unsigned int a1);
char __cdecl sub_10031130(unsigned int a1, unsigned __int8 a2, char a3, _BYTE *a4, _BYTE *a5, _BYTE *a6);
char __cdecl sub_100311B0(unsigned int a1, unsigned __int8 a2, char a3, _DWORD *a4);
char __cdecl sub_10031240(unsigned int a1, unsigned __int8 a2, int a3);
char __cdecl sub_100312A0(unsigned int a1, unsigned __int8 a2, char a3, char a4, int a5);
char __cdecl sub_10031310(unsigned int a1);
char __cdecl sub_100313B0(unsigned int a1);
// int __usercall sub_10031450@<eax>(int a1@<eax>, unsigned __int8 a2);
// int __usercall sub_100314B0@<eax>(unsigned __int8 a1@<al>, int a2, char a3, char a4);
signed int __cdecl sub_100314E0(unsigned __int8 a1);
// void __usercall sub_10031550(int *a1@<ecx>, int a2@<esi>, int a3);
// void __usercall sub_10032570(unsigned int a1@<ebx>, int a2, int *a3, int a4);
char __cdecl sub_100325C0(int a1, int a2, void *a3);
char __cdecl sub_10032620(unsigned int a1, unsigned __int8 a2, int a3);
char __cdecl sub_10032680(unsigned int a1, unsigned __int8 a2, char a3, char a4, int a5);
double __cdecl sub_100326F0(int a1, float a2);
int __cdecl sub_10032750(char a1, char a2, _DWORD *a3, unsigned __int16 *a4, float *a5, float *a6, _BYTE *a7, _BYTE *a8, _BYTE *a9);
bool __cdecl sub_10032860(int a1);
char __cdecl sub_10032A50(_DWORD *a1, unsigned __int8 a2, _BYTE *a3);
int __cdecl sub_10032A90(unsigned __int16 a1, int a2);
int __cdecl sub_10032B20(int *a1);
char __cdecl sub_10032B70(int a1, int a2, void *a3);
char __cdecl sub_100332D0(int a1, _BYTE *a2);
char __cdecl sub_10033300(_DWORD *a1);
int __cdecl sub_10033350(int a1, char a2, int a3);
bool __cdecl sub_10033390(unsigned int a1);
signed int __cdecl sub_100333A0(unsigned int a1, int a2);
// void __usercall sub_10033530(int a1@<esi>, int a2, unsigned int a3, _BYTE *a4);
int __cdecl sub_10033AF0(__int16 a1, unsigned __int16 a2);
signed int __cdecl sub_10033B10(int a1);
signed int __cdecl sub_10033C70(int a1);
signed int __cdecl sub_10033D60(int a1);
signed int __cdecl sub_10033EF0(int a1);
signed int __cdecl sub_10034010(int a1);
signed int __cdecl sub_10034180(int a1);
char __cdecl sub_10034280(_DWORD *a1);
// char __usercall sub_100342D0@<al>(signed int *a1@<edi>, signed int a2, signed int a3, unsigned __int8 a4, _BYTE *a5);
signed int __cdecl sub_10034570(int a1, unsigned __int8 a2, _BYTE *a3);
void __cdecl sub_10034710(unsigned int a1, unsigned __int8 a2, int a3);
char __cdecl sub_100347C0(int a1, unsigned __int8 a2, _DWORD *a3);
signed int __cdecl sub_10034990(unsigned __int8 a1, unsigned __int8 a2);
char __cdecl sub_100349E0(unsigned __int8 a1, unsigned __int8 a2);
int __cdecl sub_10034A30(unsigned __int8 a1, unsigned __int8 a2);
int __cdecl sub_10034A90(int a1, int a2);
char __cdecl sub_10034B00(unsigned __int8 a1);
signed int __cdecl sub_10034B50(unsigned __int8 a1);
int __cdecl sub_10034BD0(int, char, void *); // idb
signed int __cdecl sub_10034C50(unsigned __int8 a1);
char __cdecl sub_10034CB0(int a1);
char __cdecl sub_10034CF0(int a1);
char __cdecl sub_10034D20(int a1);
// char __usercall sub_10034D60@<al>(int a1@<edi>, int a2@<esi>, unsigned int a3);
void __cdecl sub_10034E40(int a1, unsigned __int8 a2, char *a3, char *a4, int a5, bool *a6);
char __cdecl sub_10035150(unsigned __int8 a1);
char __cdecl sub_10035190(unsigned __int8 a1);
char __cdecl sub_100351D0(int a1, char a2, char *a3);
char __cdecl sub_100354B0(unsigned __int8 a1);
signed int __cdecl sub_100354F0(unsigned __int8 a1);
char __cdecl sub_10035530(unsigned __int8 a1);
signed int __cdecl sub_10035570(unsigned __int8 a1, unsigned __int8 a2);
signed int __cdecl sub_100355D0(unsigned __int8 a1);
char __cdecl sub_10035610(int a1);
char __cdecl sub_10035650(int a1);
char __cdecl sub_10035690(int a1);
char __cdecl sub_100356D0(unsigned __int8 a1);
char __cdecl sub_10035710(unsigned __int8 a1);
char __cdecl sub_10035750(unsigned __int8 a1);
double __cdecl sub_10035790(float a1);
double sub_10035810(void); // weak
char sub_10035820();
// char __usercall sub_10035880@<al>(char a1@<al>);
void __cdecl sub_10035890(_BYTE *a1, unsigned __int8 a2);
unsigned __int8 __cdecl sub_10035960(int a1);
int __cdecl sub_10035EB0(int, float, char, char, char, float, int, int, int); // idb
unsigned __int8 __cdecl sub_100360B0(int a1);
int __cdecl sub_10036180(int a1);
char __cdecl sub_100361C0(unsigned int a1, unsigned int *a2, _BYTE *a3, _BYTE *a4);
int __cdecl sub_100361F0(int a1);
// signed int __usercall sub_10036230@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
signed int __thiscall sub_10036270(int this);
// signed int __usercall sub_10036320@<eax>(int a1@<edi>);
signed int __thiscall sub_100363B0(int this);
// int __usercall sub_10036450@<eax>(int a1@<esi>);
// char __usercall sub_10036470@<al>(unsigned int a1@<eax>, unsigned int *a2@<ebx>, _BYTE *a3@<edi>, int a4@<esi>, _DWORD *a5, int *a6);
// void *__usercall sub_10036530@<eax>(int a1@<eax>, char *a2@<esi>);
// char __usercall sub_10036590@<al>(int a1@<ecx>, _BYTE *a2@<edi>);
// int __usercall sub_10036620@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>);
// __int16 __usercall sub_100366C0@<ax>(int a1@<eax>, int a2@<esi>, int a3);
void *__cdecl sub_10036830(unsigned int a1, char *a2);
signed int __cdecl sub_10036880(unsigned __int8 a1);
// signed int __usercall sub_10036900@<eax>(int a1@<edi>, unsigned __int8 a2);
signed int __cdecl sub_10036970(unsigned __int8 a1);
// int __usercall sub_100369E0@<eax>(int a1@<eax>, char a2);
// void __usercall sub_10036A70(int a1@<edi>, int a2, int a3);
signed int __cdecl sub_10036AB0(unsigned int a1, unsigned __int8 a2);
signed int __cdecl sub_10036B20(unsigned int a1, char a2, char a3);
__int16 __cdecl sub_10036BA0(unsigned int a1, char a2, int a3);
char __cdecl sub_10037080(unsigned int a1);
char __cdecl sub_100370D0(unsigned int a1);
int __cdecl sub_10037140(__int64 a1);
double __cdecl sub_100371F0(unsigned int a1);
double __cdecl sub_10037270(unsigned int a1);
double __cdecl sub_100372F0(int a1);
int __cdecl sub_10037360(int a1, int a2);
char __cdecl sub_100374F0(int a1, int a2);
__int16 __cdecl sub_10037560(int a1, int a2);
void __cdecl sub_100375A0(int a1, int a2, void *a3);
int __cdecl sub_10037840(int, void *); // idb
// bool __usercall sub_100378E0@<al>(unsigned int a1@<esi>, int a2, float a3, char a4, char a5, char a6, float a7, char a8);
bool __cdecl sub_10037A50(int a1, int a2, float a3, int a4, int a5, float a6);
float sub_10037A90();
void __cdecl sub_10037AF0(unsigned int a1, char *a2, float *a3, int a4, char a5);
void __cdecl sub_10037E30(signed int a1, char *a2);
int __cdecl sub_10037E70(int, int, int, void *, int); // idb
char __cdecl sub_10037F00(__int64 a1);
char __cdecl sub_10037F30(unsigned int a1);
double __cdecl sub_10037F60(float a1);
signed int __cdecl sub_10038020(const void *a1, _DWORD *a2, _BYTE *a3);
double __cdecl sub_10038280(float a1, float a2, float a3, float a4, float a5);
double __cdecl sub_10038300(float a1, float a2, float a3, float a4);
char __cdecl sub_10038360(float a1, float a2, float a3, int a4);
char __cdecl sub_100384D0(float a1, float a2, float a3, float a4, int a5);
// void __usercall sub_100386C0(float *a1@<esi>, float a2, float a3, float a4, float a5, float a6);
// void __usercall sub_10038890(float *a1@<esi>, float a2, float a3, float a4, float a5, float a6);
// void __usercall sub_10038A90(float *a1@<esi>, float a2, float a3, float a4, float a5);
// void __usercall sub_10038C00(float *a1@<esi>, float a2, float a3, float a4, float a5);
// void __usercall sub_10038CE0(float *a1@<esi>, float a2, float a3, float a4, float a5, float a6);
char __cdecl sub_10038DD0(float *a1);
char __cdecl sub_10038EA0(float *a1);
bool __cdecl sub_10039530(float a1, float a2);
bool __cdecl sub_100395C0(unsigned __int8 a1, int a2);
char __cdecl sub_100396E0(__int16 a1);
char __cdecl sub_10039840();
char __cdecl sub_10039850(int *a1);
char sub_10039890();
char __cdecl sub_100398B0(char a1);
// void __usercall sub_100398D0(unsigned __int8 a1@<bl>, char a2, char a3, char a4);
void __cdecl sub_100399E0(unsigned __int8 a1);
int __cdecl sub_10039A80(signed int a1);
bool __cdecl sub_10039AD0(char a1, char a2, int a3, float a4);
_DWORD __cdecl sub_10039B20(_DWORD); // weak
bool sub_10039B30();
bool sub_10039B40();
_DWORD __cdecl sub_10039B60(_DWORD, _DWORD); // weak
char __cdecl sub_10039B70(void *a1);
int __cdecl sub_10039C50(unsigned __int8 a1);
signed int __cdecl sub_10039C90(__int16 a1, char a2, char a3, const void *a4, int a5, int a6);
int __cdecl sub_10039E00(int, int, void *); // idb
char *__cdecl sub_10039E60(unsigned __int8 a1);
signed int sub_10039F20();
int sub_10039F40();
int sub_10039FA0();
char *sub_1003A010();
int __cdecl sub_1003A0E0(const void *a1);
int __cdecl sub_1003A190(int a1);
void __cdecl sub_1003A3C0(unsigned int a1, int a2);
char __cdecl sub_1003A5A0(unsigned int a1, int a2);
int __cdecl sub_1003A610(_BYTE *a1, _BYTE *a2, int a3);
int __cdecl sub_1003A640(int a1, int a2);
void __cdecl sub_1003A7A0(_BYTE *a1, signed int a2, int a3);
unsigned int __cdecl sub_1003A840(unsigned int a1, _BYTE *a2, _BYTE *a3);
signed int __cdecl sub_1003A860(int a1, _WORD *a2, _BYTE *a3);
// char __usercall sub_1003A960@<al>(unsigned __int16 a1@<ax>, void *a2);
// int __usercall sub_1003A9C0@<eax>(int result@<eax>, int a2@<ecx>);
int __cdecl sub_1003A9E0(unsigned __int16 a1, int a2);
int __cdecl sub_1003AA70(unsigned __int16 a1, int a2);
signed int __cdecl sub_1003AAE0(int a1, _WORD *a2, _BYTE *a3);
signed int __cdecl sub_1003AB30(int a1);
signed int __cdecl sub_1003AB90(char a1, char a2);
signed int __cdecl sub_1003ABB0(char a1);
signed int __cdecl sub_1003ABD0(char a1);
signed int __cdecl sub_1003ABF0(char a1);
signed int __cdecl sub_1003AC10(char a1, char a2, int a3, char a4);
int __cdecl sub_1003AC60(int, int, char, char, float); // idb
signed int __cdecl sub_1003ACC0(char a1, int a2, char a3, char a4, char a5, int a6, char a7, char a8);
signed int __cdecl sub_1003AD40(char a1, int a2, char a3, char a4, char a5, char a6, char a7);
signed int __cdecl sub_1003ADC0(char a1, char a2, int a3, char a4);
signed int __cdecl sub_1003AE10(char a1, char a2);
signed int __cdecl sub_1003AE50(char a1, char a2, const void *a3);
char __cdecl sub_1003AEA0(int a1, void *a2);
double __cdecl sub_1003AFB0(unsigned int a1);
void __cdecl sub_1003B060(unsigned int a1, int a2);
int sub_1003B2D0();
char __cdecl sub_1003B370(float *a1);
char __cdecl sub_1003B630(int a1, float *a2);
unsigned __int8 __cdecl sub_1003B650(unsigned __int8 a1, unsigned __int8 a2, int a3, int a4, int a5);
// char __usercall sub_1003B7B0@<al>(char a1@<al>, char a2@<cl>, char a3);
int __cdecl sub_1003B810(char, char, float, float); // idb
int __cdecl sub_1003B860(_BYTE *a1, _BYTE *a2);
int sub_1003B890();
int __fastcall sub_1003B8A0(unsigned __int8 a1);
int __fastcall sub_1003B8C0(unsigned __int8 a1);
void *__cdecl sub_1003B8E0(char a1, void *a2);
int __cdecl sub_1003B9B0(int a1);
char sub_1003BB70();
__int32 __cdecl j_j__atol(const char *);
BOOL __cdecl sub_1003BCE0(unsigned int a1);
char __thiscall sub_1003BD50(void *this);
void __cdecl sub_1003BD70(_BYTE *a1, _BYTE *a2, _BYTE *a3);
int __cdecl sub_1003BDA0(int a1);
signed int sub_1003BDC0();
void __cdecl sub_1003BDF0(_BYTE *a1);
char __cdecl sub_1003BE10(int a1, size_t a2, void *a3);
int __cdecl sub_1003BE50(int a1);
char __fastcall sub_1003BE70(int *a1);
char sub_1003C070();
char sub_1003C090();
void sub_1003C0B0();
int __cdecl sub_1003C0C0(char, int, __int16, __int16, void *); // idb
signed int sub_1003C0D0();
int sub_1003C0E0();
int sub_1003C0F0();
_DWORD sub_1003C110(); // weak
char __fastcall sub_1003C120(int a1);
BOOL __cdecl sub_1003C170(char a1);
char __cdecl sub_1003C270(unsigned int a1);
char __cdecl sub_1003C2E0(char a1);
char __cdecl sub_1003C330(char a1);
char __cdecl sub_1003C380(char a1);
BOOL __cdecl sub_1003C3B0(char a1);
char __cdecl sub_1003C420(char a1);
char __cdecl sub_1003C450(char a1);
void sub_1003C4A0();
char __cdecl sub_1003C4B0(char a1, int a2);
// char __usercall sub_1003C530@<al>(unsigned __int8 a1@<al>, _BYTE *a2);
// char __usercall sub_1003C560@<al>(bool *a1@<esi>);
signed int sub_1003C590();
char __cdecl sub_1003C5A0(char a1);
char __cdecl sub_1003C610(void *a1, int a2);
__int16 __cdecl sub_1003C8C0(char a1);
bool __cdecl sub_1003CA50(int a1);
char __cdecl sub_1003CAA0(int a1, void *a2);
char __cdecl sub_1003CB00(int a1);
char __cdecl sub_1003CB30(int a1);
char __cdecl sub_1003CB60(int a1);
// char __usercall sub_1003CB90@<al>(void *a1@<esi>, int a2);
bool __cdecl sub_1003CC00(int a1);
char __cdecl sub_1003CCA0(int a1, void *a2);
bool __cdecl sub_1003CDD0(int a1, int a2);
char __cdecl sub_1003CF20(int a1);
char __cdecl sub_1003D0E0(unsigned __int16 a1);
int __cdecl sub_1003D230(char *a1, char a2);
bool __cdecl sub_1003D2A0(int a1, void *a2);
char __cdecl sub_1003D360(int a1, bool *a2);
void sub_1003D420();
char __cdecl sub_1003D430(unsigned __int16 a1, float *a2);
void sub_1003D550();
double __cdecl sub_1003D560(float a1);
signed int sub_1003D5C0();
// char __usercall sub_1003D5D0@<al>(int a1@<esi>, unsigned __int16 a2, float *a3);
char __cdecl sub_1003DB10(unsigned __int8 a1, _DWORD *a2);
int __cdecl sub_1003DB80(char a1);
char __cdecl sub_1003DBD0(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_1003DC40(char a1, _WORD *a2);
char __cdecl sub_1003DC80(unsigned int a1);
signed int sub_1003DCE0();
signed int sub_1003DCF0();
signed int sub_1003DD00();
// char __usercall sub_1003DD10@<al>(char a1@<bl>, int a2@<edi>, const void *a3@<esi>, char a4, char a5, char a6, unsigned int a7);
char __cdecl sub_1003DE70(_BYTE *a1);
char __cdecl sub_1003DEA0(unsigned __int8 a1, _BYTE *a2);
char __cdecl sub_1003DED0(char a1, char a2, int a3);
char __cdecl sub_1003DF00(unsigned __int8 a1, char a2);
bool __cdecl sub_1003DF80(int a1);
// void __usercall sub_1003DFA0(void *a1@<ecx>, bool *a2@<esi>);
// void __usercall sub_1003DFD0(_BYTE *a1@<esi>, unsigned __int16 a2);
// _BYTE *__usercall sub_1003E020@<eax>(_BYTE *result@<eax>, __int16 a2@<dx>, _BYTE *a3@<ecx>, char a4);
char __thiscall sub_1003E0A0(void *this);
int __thiscall sub_1003E0E0(void *this);
// char __usercall sub_1003E270@<al>(char result@<al>, unsigned __int8 a2@<dl>, unsigned __int8 a3@<cl>, unsigned __int8 a4);
void __cdecl sub_1003E300(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
char __cdecl sub_1003E360(void *a1);
// char __usercall sub_1003E3B0@<al>(char a1@<al>, char a2@<dl>, int a3@<ecx>, int a4);
void sub_1003E420();
char __cdecl sub_1003E440(int a1);
bool __thiscall sub_1003E4C0(void *this);
char __cdecl sub_1003E520(unsigned __int8 a1);
void __cdecl sub_1003E580(char a1, __int16 a2);
char __cdecl sub_1003E660(__int16 a1);
void __fastcall sub_1003E790(int a1, char a2);
char __thiscall sub_1003E830(void *this);
bool __fastcall sub_1003E890(int a1);
void sub_1003E8D0();
char __cdecl sub_1003E8E0(const void *a1);
signed int sub_1003E930();
char __cdecl sub_1003E940(void *a1);
bool sub_1003E990();
signed int sub_1003E9D0();
char __thiscall sub_1003EA10(void *this);
char __thiscall sub_1003EA30(void *this);
char __cdecl sub_1003EA60(char a1);
int sub_1003EAB0();
char sub_1003EAE0();
char __thiscall sub_1003EB10(void *this);
char __thiscall sub_1003EB30(void *this);
int __cdecl sub_1003EB70(void *); // idb
char __thiscall sub_1003EBC0(void *this);
int __cdecl sub_1003EBF0(void *); // idb
char __thiscall sub_1003EC40(void *this);
int __cdecl sub_1003EC70(void *); // idb
char sub_1003ECD0();
int __cdecl sub_1003ED00(int a1);
char sub_1003ED50();
char sub_1003ED90();
int __cdecl sub_1003EEB0(float a1, int a2, char a3);
double __cdecl sub_1003F040(char a1);
char __cdecl sub_1003F0C0(signed int a1, char a2);
int __cdecl sub_1003F150(unsigned __int8 a1);
int __cdecl sub_1003F170(unsigned __int8 a1);
double __cdecl sub_1003F190(float a1);
// bool __usercall sub_1003F1F0@<al>(int a1@<eax>);
char __cdecl sub_1003F260(char *a1);
double sub_1003F3E0();
double sub_1003F440(void); // weak
char sub_1003F450();
char __fastcall sub_1003F480(int a1);
char __fastcall sub_1003F4C0(int a1);
int __cdecl sub_1003F500(int a1);
// int __usercall sub_1003F530@<eax>(void *a1@<ecx>, int a2@<edi>, int a3@<esi>, unsigned __int8 a4);
int __thiscall sub_1003F570(void *this);
char __cdecl sub_1003F600(signed int a1, char a2);
void sub_1003F640();
char __cdecl sub_1003F650(unsigned __int8 a1);
signed int sub_1003F6B0();
// char __usercall sub_1003F6C0@<al>(unsigned __int8 a1@<al>, char a2, void *a3);
char __cdecl sub_1003F7A0(int a1, char a2, void *a3);
char __cdecl sub_1003F820(int a1, void *a2);
char __cdecl sub_1003F840(int a1, void *a2);
int __cdecl sub_1003F8A0(char *, char *); // idb
// void *__usercall sub_1003F8E0@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>);
signed int sub_1003F930();
int __cdecl sub_10041730(int a1);
int sub_10041740();
char sub_10041770();
void sub_10041810();
signed int sub_10041820();
// char __usercall sub_10041830@<al>(float *a1@<esi>);
char __cdecl sub_100418A0(__int16 a1);
signed int sub_10041980();
bool __cdecl sub_100419B0(char a1, int a2);
char __cdecl sub_10041BD0(float *a1);
char sub_10041C30();
bool sub_10041CA0();
char sub_10041CE0();
char sub_10041D00();
char sub_10041D20();
char sub_10041D90();
bool __cdecl sub_10041DA0(float *a1);
bool __cdecl sub_10041E50(float *a1);
int sub_10041EB0(void); // weak
signed int sub_10041EC0();
int sub_10041EE0();
signed int __cdecl sub_10041EF0(unsigned int a1);
signed int __cdecl sub_10041F30(unsigned int a1, int a2, int a3, int a4);
signed int __cdecl sub_10041F90(unsigned int a1, int a2, int a3);
bool __cdecl sub_10041FB0(float a1, int a2, int a3, int a4);
bool __cdecl sub_10042120(signed int a1, signed int a2, _BYTE *a3);
void __cdecl sub_10042190(const char *a1, unsigned int a2, int a3);
int __cdecl sub_100421E0(int a1, _BYTE *a2, int a3);
signed int __cdecl sub_10042230(_BYTE *a1, _BYTE *a2, int a3);
int __cdecl sub_100422A0(void *, size_t); // idb
int __cdecl sub_100422D0(int, char *, int); // idb
int __cdecl sub_10042330(char *, size_t, char *, va_list); // idb
int sub_10042370(char *arg0, size_t arg4, char *arg8, ...);
int __cdecl sub_100423A0(const char *a1, _BYTE *a2, int a3);
int __cdecl sub_100423E0(int a1, int a2);
__int16 __cdecl sub_10042400(__int16 a1);
char __cdecl sub_10042450(char a1, char a2, void *a3, size_t a4);
void sub_100424C0();
char __cdecl sub_100424D0(void *a1, int a2);
char __cdecl sub_10042530(void *a1, size_t a2, void *a3, size_t a4);
char __cdecl sub_100425D0(unsigned __int8 a1, char a2);
char __cdecl sub_10042610(void *a1);
char __cdecl sub_10042630(void *a1);
char __cdecl sub_10042650(_DWORD *a1);
BOOL __fastcall sub_100426B0(int a1);
char *__cdecl sub_100426E0(int a1, char *a2, int a3, char *a4, int a5);
char sub_10042810();
char __cdecl sub_10042820(char *a1, int a2, char a3, char *a4, int a5);
char __cdecl sub_10042920(char a1);
char __cdecl sub_10042930(char *a1, int a2, char a3, char *a4);
char __thiscall sub_100429A0(void *this);
int __thiscall sub_100429D0(void *this);
bool __cdecl sub_100429F0(char a1);
int __cdecl sub_10042A60(int a1, unsigned int a2);
int __cdecl sub_10042B50(int *a1, unsigned int a2);
__int16 __cdecl sub_10042C40(int a1, unsigned int a2);
int __cdecl sub_10042C90(int *a1, unsigned int a2);
__int16 __cdecl sub_10042CC0(unsigned int *a1, _WORD *a2, _WORD *a3);
int __cdecl sub_10042D40(int a1, int a2);
int __cdecl sub_10042D90(int a1, int a2, int a3);
char __cdecl sub_10042DC0(char *a1);
char __cdecl sub_10042DF0(int a1);
char __cdecl sub_10042E40(int a1);
char __cdecl sub_10042E90(char a1, _DWORD *a2);
// __int16 __usercall sub_10042ED0@<ax>(int a1@<edi>, char a2);
// signed __int16 __usercall sub_10043070@<ax>(void *a1@<ecx>, signed __int16 a2@<bx>, const char *a3@<esi>);
char __cdecl sub_100432C0(signed __int16 a1);
char __cdecl sub_10043350(char a1, int a2);
int __cdecl sub_10043370(signed __int16 a1);
char __cdecl sub_10043480(unsigned __int16 a1);
char __cdecl sub_10043520(const void *a1);
int __cdecl sub_10043590(unsigned __int8 a1);
char __cdecl sub_10043620(unsigned __int8 a1, unsigned __int8 a2);
char sub_10043670();
char sub_100437B0();
char __cdecl sub_100438F0(int a1, char a2);
signed int __cdecl sub_10043970(_BYTE *a1, _BYTE *a2, int a3);
signed int __cdecl sub_100439B0(int a1);
signed int __cdecl sub_100439D0(signed int a1);
unsigned __int8 __cdecl sub_10043A00(const char *a1, int a2);
double __cdecl sub_10043B40(signed int a1, char a2);
bool __cdecl sub_10043B80(unsigned int a1, unsigned __int16 a2);
// char __usercall sub_10043BC0@<al>(unsigned int a1@<eax>);
char __cdecl sub_10043BE0(char a1, char *a2, char *a3);
char __cdecl sub_10043C80(int a1, int a2);
int __cdecl sub_10043F80(unsigned __int16 a1);
bool __cdecl sub_10043FB0(unsigned int a1, unsigned __int16 a2);
int __cdecl sub_10043FF0(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_10044180(_DWORD *a1, unsigned int a2, int a3, int a4, int a5);
unsigned int __cdecl sub_100442A0(int a1, int a2, size_t a3, int a4, int a5);
int sub_10044400(); // weak
unsigned int __cdecl sub_10044420(int a1, int a2, size_t a3, int a4);
int __cdecl sub_10044450(float, char *); // idb
double sub_100444D0();
double sub_10044500();
int __cdecl sub_10044530(float); // idb
// void __usercall sub_10044570(int a1@<esi>, int a2, float a3);
// char __usercall sub_100446D0@<al>(float *a1@<edi>, unsigned __int16 a2@<si>, unsigned __int8 a3);
// char __usercall sub_100447C0@<al>(unsigned __int16 *a1@<eax>, int a2, float *a3, unsigned __int8 a4);
char __cdecl sub_10044AA0(float *a1);
char __cdecl sub_10044B10(float *a1);
char __cdecl sub_10044B30(float *a1);
char __cdecl sub_10044B50(float *a1);
char __cdecl sub_10044BE0(float *a1);
char __cdecl sub_10044C50(float *a1);
char __cdecl sub_10044D20(float *a1);
char __cdecl sub_10044DF0(float *a1);
char __cdecl sub_10044EC0(float *a1);
char __cdecl sub_10044F60(float *a1);
double sub_10044FD0();
char __cdecl sub_10045030(float *a1);
int __cdecl sub_100450D0(char a1);
// int __usercall sub_100450E0@<eax>(char *a1@<eax>, char a2@<cl>);
// char __usercall sub_100450F0@<al>(char a1@<bl>, char a2);
// char __usercall sub_100451B0@<al>(char a1@<dl>, char a2@<cl>, char a3);
char __cdecl sub_10045200(char a1, char a2);
char __cdecl sub_10045220(char a1, char a2);
char __cdecl sub_10045250(char a1);
char __thiscall sub_10045280(void *this);
char sub_10045290();
void __cdecl sub_100452D0(float a1, int a2);
char __cdecl sub_10045330(float a1, int a2);
void __cdecl sub_100453D0(float a1, float a2, int a3);
void __cdecl sub_10045440(float a1, float a2, int a3);
double __cdecl sub_100454B0(float a1, float a2, int a3, float a4);
char __cdecl sub_10045590(int a1, void *a2);
char __cdecl sub_100455E0(int a1, void *a2);
bool __cdecl sub_10045630(int a1, void *a2, int a3);
bool __cdecl sub_100456B0(int a1, void *a2, int a3);
char __cdecl sub_10045730(unsigned __int16 a1);
bool __cdecl sub_100457A0(int a1, void *a2);
bool __cdecl sub_100457D0(int a1, void *a2);
int __cdecl sub_10045800(float, float); // idb
bool __cdecl sub_10045850(float *a1);
int sub_100458F0();
// char __usercall sub_10045920@<al>(int a1@<eax>, float *a2@<esi>, float a3, float a4);
char __cdecl sub_10045980(void *a1);
char __cdecl sub_100459E0(void *a1);
char __cdecl sub_10045A40(float *a1);
char __cdecl sub_10045B40(void *a1);
char __cdecl sub_10045BA0(void *a1);
char __cdecl sub_10045C00(void *a1);
char __cdecl sub_10045C60(void *a1);
char __cdecl sub_10045D40(float *a1);
char __cdecl sub_10045D70(float *a1);
double sub_10045E10(void); // weak
char __thiscall sub_10045E30(void *this);
char __thiscall sub_10045E70(void *this);
char __thiscall sub_10045EA0(void *this);
char __thiscall sub_10045EC0(void *this);
int sub_10045EF0();
char __fastcall sub_10045F20(int a1);
char __cdecl sub_10045F70(int a1);
char sub_10045F90();
bool __cdecl sub_10045FC0(int a1);
int __cdecl sub_10045FE0(int, char *); // idb
char __thiscall sub_10046040(void *this);
char __thiscall sub_10046060(void *this);
char __thiscall sub_10046080(void *this);
int __thiscall sub_100460A0(void *this);
char __thiscall sub_100460C0(void *this);
char __thiscall sub_100460E0(void *this);
char __thiscall sub_10046100(void *this);
int __cdecl sub_10046120(char a1);
int __cdecl sub_10046130(char a1, char a2);
char __cdecl sub_10046170(int a1);
char __thiscall sub_10046190(void *this);
bool __thiscall sub_100461B0(void *this);
bool __cdecl sub_100461D0(void *a1);
int __cdecl sub_10046210(char a1);
char __cdecl sub_10046260(int a1);
char __cdecl sub_100462C0(char a1);
char __cdecl sub_100462F0(char a1, int a2);
void __cdecl sub_10046330(char a1);
signed int __cdecl sub_10046360(char a1, char a2);
int __cdecl sub_100463C0(char a1);
signed int __cdecl sub_10046400(char a1, char a2, char a3);
int __cdecl sub_10046470(char a1);
int __cdecl sub_100464B0(char a1);
char __cdecl sub_100464F0(int a1, int a2);
char __cdecl sub_10046510(char a1, int a2);
char __cdecl sub_10046530(char a1, int a2);
char __cdecl sub_10046560(char a1, int a2);
char __cdecl sub_100465B0(char a1, int a2);
char __cdecl sub_100465E0(int a1);
char __cdecl sub_10046600(char a1, int a2);
char __cdecl sub_10046620(int a1);
char sub_10046640();
char __cdecl sub_10046650(unsigned __int16 a1, char *a2, char a3);
char __cdecl sub_10046780(__int16 a1, _DWORD *a2);
char __cdecl sub_10046840(char a1, int a2);
char __cdecl sub_100468A0(char a1, int a2);
bool __cdecl sub_10046920(void *a1);
void *sub_10046970();
char __cdecl sub_100469A0(char a1, int a2);
// __int16 __usercall sub_10046A80@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_10046A90(unsigned __int8 a1, int *a2, const void *a3);
char __cdecl sub_10046B20(unsigned __int8 a1, char a2);
bool __cdecl sub_10046BE0(__int16 a1, char a2, int a3, int a4, void *a5);
int __thiscall sub_10046CE0(void *this);
char __thiscall sub_10046D00(void *this);
char __cdecl sub_10046D90(char a1);
char __cdecl sub_10046E00(int a1, char a2);
char __cdecl sub_10046EC0(int a1, char a2);
char __cdecl sub_10046F80(int a1, char a2);
char __cdecl sub_10047040(int a1, char a2);
char __cdecl sub_100470F0(char a1, char a2);
char sub_10047140();
char sub_10047160();
char __cdecl sub_10047190(char a1);
char __cdecl sub_100471C0(char a1);
char __cdecl sub_100471F0(char a1);
char __cdecl sub_10047220(char a1);
char __cdecl sub_10047250(char a1);
char __cdecl sub_10047290(char a1, _BYTE *a2);
bool sub_100472E0();
char __cdecl sub_10047320(char a1);
BOOL sub_10047380();
char __cdecl sub_100473B0(bool *a1);
bool __thiscall sub_100474F0(void *this);
char sub_10047520();
char __cdecl sub_10047670(int a1, int a2);
char __cdecl sub_10047790(int a1);
char __cdecl sub_100477A0(int a1);
char __cdecl sub_100477B0(int a1);
char __cdecl sub_100477C0(int a1);
char __cdecl sub_100477D0(int a1);
char __cdecl sub_100477E0(int a1);
char __cdecl sub_100477F0(char a1);
char __cdecl sub_10047860(char a1, void *a2);
char __cdecl sub_10047990(char a1, int a2, int a3, int a4, char a5);
char __cdecl sub_10047A30(int a1, int a2, int a3);
char __cdecl sub_10047A60(__int16 a1);
char __cdecl sub_10047AC0(int a1);
char __cdecl sub_10047AE0(int a1);
char __cdecl sub_10047B50(char a1, int a2, int a3);
void __cdecl sub_10047C60(char a1, int a2);
int __cdecl sub_10048200(int, float); // idb
char __thiscall sub_10048230(void *this);
char sub_10048260();
int __cdecl sub_100482C0(char a1, int a2, int *a3);
int __cdecl sub_100483C0(char a1, int a2);
int __cdecl sub_10048430(int a1);
bool __cdecl sub_10048450(unsigned int a1);
char __cdecl sub_10048480(char a1, void *a2);
char __cdecl sub_100484D0(char a1, char *a2);
char __cdecl sub_10048590(char a1, _WORD *a2);
int __cdecl sub_10048600(char a1, _DWORD *a2);
char __cdecl sub_10048640(void *a1);
char __cdecl sub_10048650(void *a1);
BOOL sub_10048660();
// int __usercall sub_10048690@<eax>(char a1@<al>, int a2@<ecx>);
char __thiscall sub_100486C0(void *this);
char __thiscall sub_10048720(void *this);
char __cdecl sub_10048790(char a1, char a2, int *a3);
char __cdecl sub_10048940(char a1, int *a2, char a3);
char __cdecl sub_100489B0(char a1, int *a2);
int __cdecl sub_100489E0(int a1, signed int a2, signed int a3);
int __cdecl sub_10048A00(int, double, double); // idb
int __cdecl sub_10048AE0(int, float, float); // idb
char __cdecl sub_10048BD0(float a1, float a2, int a3);
char __thiscall sub_10048C30(void *this);
char __cdecl sub_10048C90(float *a1);
bool __cdecl sub_10048CD0(char a1);
int sub_10048D70();
char sub_10048E10();
char sub_10048ED0();
char sub_10048F50();
char sub_100491F0();
char __cdecl sub_100493F0(_BYTE *a1, unsigned __int8 a2);
char __cdecl sub_10049580(char *a1);
bool __cdecl sub_10049600(void *a1);
char __cdecl sub_10049840(char a1);
char __cdecl sub_10049870(char a1, void *a2);
bool __cdecl sub_100498F0(char a1);
int __cdecl sub_10049990(char a1, _DWORD *a2);
char __cdecl sub_100499E0(unsigned __int8 a1, char a2, int a3);
char __cdecl sub_10049B30(char a1, char a2);
char __cdecl sub_10049B90(char a1);
char __cdecl sub_10049BD0(char a1);
char __cdecl sub_10049C40(char a1);
signed int __cdecl sub_10049CB0(char a1);
char __cdecl sub_10049D30(char a1);
char __cdecl sub_10049DA0(char a1);
char __cdecl sub_10049E50(int a1);
char __cdecl sub_10049F60(int a1);
// char __usercall sub_1004A060@<al>(int a1@<edi>, char a2, unsigned __int8 a3);
char __cdecl sub_1004A090(char a1);
char __thiscall sub_1004A0B0(void *this);
char __cdecl sub_1004A0C0(char a1);
void sub_1004A0F0();
void sub_1004A100();
signed int sub_1004A110();
signed int sub_1004A120();
char __cdecl sub_1004A130(int a1);
int __thiscall sub_1004A190(void *this);
// bool __usercall sub_1004A260@<al>(int a1@<eax>, int a2@<esi>);
bool __cdecl sub_1004A290(_BYTE *a1, int a2);
bool __cdecl sub_1004A2C0(_BYTE *a1, int a2);
char __cdecl sub_1004A2F0(_DWORD *a1);
int __cdecl sub_1004A330(_BYTE *a1);
char __cdecl sub_1004A360(_BYTE *a1, _BYTE *a2);
char __cdecl sub_1004A3B0(_BYTE *a1, _BYTE *a2);
int sub_1004A400();
__int16 sub_1004A4D0();
// int __usercall sub_1004A530@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4);
signed int __cdecl sub_1004A5B0(int a1);
char sub_1004A6A0();
int (__cdecl *(*sub_1004A860())[2])(int, int);
int __cdecl sub_1004A990(int *a1);
// char __usercall sub_1004A9C0@<al>(int a1@<eax>, int a2@<ecx>);
int __cdecl sub_1004AA60(const char *a1);
char __cdecl sub_1004AAA0(void *a1);
signed int __cdecl sub_1004AAF0(unsigned int a1, int a2);
char **sub_1004AE90();
int sub_1004AEA0(void); // weak
char sub_1004AED0();
int __cdecl sub_1004AEF0(signed int a1, char a2);
char __cdecl sub_1004B0B0(char a1, char a2, int a3);
BOOL __cdecl sub_1004B270(unsigned __int8 a1);
// BOOL __usercall sub_1004B280@<eax>(unsigned __int8 a1@<al>, char a2);
bool __cdecl sub_1004B2B0(char a1, char a2, unsigned __int8 a3, int a4);
bool __cdecl sub_1004B460(unsigned __int8 a1, int a2);
char __cdecl sub_1004B4A0(unsigned __int8 a1, char a2);
bool __cdecl sub_1004B4F0(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6);
int __cdecl sub_1004B5E0(unsigned __int8 *a1, int a2);
int __cdecl sub_1004B610(unsigned __int8 *a1, int a2);
int __cdecl sub_1004B640(unsigned __int8 *a1, int a2);
int __cdecl sub_1004B670(unsigned __int8 *a1, int a2);
int __cdecl sub_1004B6A0(unsigned __int8 *a1, int a2);
signed int __cdecl sub_1004B6D0(unsigned __int8 *a1, int a2);
int __cdecl sub_1004B700(unsigned __int8 *a1, int a2);
int __cdecl sub_1004B730(unsigned __int8 *a1, int a2);
int __cdecl sub_1004B760(unsigned __int8 *a1, int a2);
int __cdecl sub_1004B790(unsigned __int8 *a1, int a2);
int __cdecl sub_1004B7C0(unsigned __int8 *a1, int a2);
int __cdecl sub_1004B7F0(unsigned __int8 *a1, int a2);
int __cdecl sub_1004B820(unsigned __int8 *a1);
int __cdecl sub_1004B840(unsigned __int8 *a1, int a2);
int __cdecl sub_1004B870(unsigned __int8 *a1, int a2);
int __cdecl sub_1004B8A0(unsigned __int8 *a1, int a2);
unsigned int __cdecl sub_1004B8D0(char *a1);
unsigned int __cdecl sub_1004B8F0(_BYTE *a1);
unsigned int __cdecl sub_1004B910(char *a1);
unsigned int __cdecl sub_1004B930(char *a1, int a2);
int __cdecl sub_1004B960(unsigned __int8 *a1, int a2);
int __cdecl sub_1004B990(_BYTE *a1);
int __cdecl sub_1004B9B0(unsigned __int8 *a1);
int __cdecl sub_1004B9D0(unsigned __int8 *a1, int a2);
int __cdecl sub_1004BA00(unsigned __int8 *a1, int a2);
unsigned int __cdecl sub_1004BA30(int a1, int a2);
unsigned int __cdecl sub_1004BD60(int a1, int a2);
int __cdecl sub_1004C1A0(unsigned __int8 *a1);
int __cdecl sub_1004C1C0(unsigned __int8 *a1);
int __cdecl sub_1004C1E0(int a1);
unsigned int __cdecl sub_1004C210(_BYTE *a1);
int __cdecl sub_1004C230(unsigned __int8 *a1);
int __cdecl sub_1004C250(_BYTE *a1);
int __cdecl sub_1004C270(int a1);
// void __cdecl __noreturn exit(int);
int __cdecl sub_1004C2C0(unsigned __int8 *a1);
int __cdecl sub_1004C2E0(int a1);
unsigned int __cdecl sub_1004C370(int a1);
signed int __cdecl sub_1004C390(int a1);
unsigned int __cdecl sub_1004C3E0(int a1);
int __cdecl sub_1004C440(_BYTE *a1);
unsigned int __cdecl sub_1004C460(_BYTE *a1);
int __cdecl sub_1004C480(unsigned __int8 *a1);
int __cdecl sub_1004C4A0(unsigned __int8 *a1);
int __cdecl sub_1004C4C0(int a1);
int __cdecl sub_1004C4F0(unsigned __int8 *a1);
int __cdecl sub_1004C510(int a1);
int __cdecl sub_1004C580(_BYTE *a1);
signed int __cdecl sub_1004C5A0(_BYTE *a1, int a2);
int __cdecl sub_1004C5D0(_BYTE *a1);
int __cdecl sub_1004C5F0(_BYTE *a1, int a2);
int __cdecl sub_1004C630(int a1, int a2);
int __cdecl sub_1004C6C0(unsigned __int8 *a1);
int __cdecl sub_1004C6E0(int a1);
int __cdecl sub_1004C710(unsigned __int8 *a1);
unsigned int __cdecl sub_1004C730(int a1);
int __cdecl sub_1004C760(int a1);
int __cdecl sub_1004C850(int a1);
int __cdecl sub_1004C960(_BYTE *a1);
signed int __cdecl sub_1004C980(_BYTE *a1, int a2);
int __cdecl sub_1004C9B0(int a1);
int __cdecl sub_1004C9E0(int a1);
int __cdecl sub_1004CA10(_BYTE *a1);
int __cdecl sub_1004CA30(unsigned __int8 *a1);
int __cdecl sub_1004CA50(unsigned __int8 *a1);
signed int __cdecl sub_1004CA70(int a1, int a2);
int __cdecl sub_1004CF80(_BYTE *a1, int a2);
signed int __cdecl sub_1004CFB0(_BYTE *a1, int a2);
int __cdecl sub_1004D020(unsigned __int8 *a1);
int __cdecl sub_1004D080(int a1);
int __cdecl sub_1004D090(unsigned __int8 *a1);
int __cdecl sub_1004D0B0(unsigned __int8 *a1);
int __cdecl sub_1004D0D0(unsigned __int8 *a1, int a2);
unsigned int __cdecl sub_1004D100(char *a1);
int __cdecl sub_1004D120(unsigned __int8 *a1);
int __cdecl sub_1004D140(unsigned __int8 *a1);
int __cdecl sub_1004D160(unsigned __int8 *a1, int a2);
int __cdecl sub_1004D190(unsigned __int8 *a1);
signed int __cdecl sub_1004D1B0(_BYTE *a1, int a2);
int __cdecl sub_1004D1E0(int a1, int a2);
unsigned int __cdecl sub_1004D280(int a1);
unsigned int __cdecl sub_1004D2C0(int a1);
_DWORD __cdecl sub_1004D310(_DWORD); // weak
int __cdecl sub_1004D320(int a1);
unsigned int __cdecl sub_1004D3A0(int a1);
unsigned int __cdecl sub_1004D3E0(int a1, int a2);
unsigned int __cdecl sub_1004D460(int a1);
signed int __cdecl sub_1004D4B0(int a1, int a2);
int __cdecl sub_1004D540(int a1);
int __cdecl sub_1004D570(int a1);
unsigned int __cdecl sub_1004D5A0(int a1);
unsigned int __cdecl sub_1004D5D0(int a1);
unsigned int __cdecl sub_1004D5F0(int a1);
void __cdecl __noreturn sub_1004D630(int a1);
unsigned int __cdecl sub_1004D7A0(_BYTE *a1);
unsigned int __cdecl sub_1004D7E0(int a1);
int __cdecl sub_1004D860(unsigned __int8 *a1);
unsigned int __cdecl sub_1004D880(int a1);
signed int __cdecl sub_1004D8B0(int a1, int a2);
int __cdecl sub_1004D900(int a1, int a2);
int __cdecl sub_1004D950(int a1);
int __cdecl sub_1004D9C0(_BYTE *a1, int a2);
// time_t __cdecl static _mkgmtime(struct tm *Tm);
// int __usercall sub_1004D9E0@<eax>(unsigned __int8 *a1@<eax>, int a2@<edi>);
// signed int __usercall sub_1004DA30@<eax>(int a1@<eax>, int a2@<edi>);
// int __usercall sub_1004DB00@<eax>(unsigned __int8 *a1@<eax>, int a2@<esi>);
int __cdecl sub_1004DBF0(unsigned __int8 *a1);
int __cdecl sub_1004DC00(unsigned __int8 *a1);
signed int __cdecl sub_1004DC10(int a1);
signed int sub_1004DC20();
void sub_1004DC90();
int sub_1004DCA0();
BOOL sub_1004DCB0();
BOOL __cdecl sub_1004DCD0(int a1);
char __cdecl sub_1004DCF0(char a1, void *a2);
int __cdecl sub_1004DD90(char a1, int a2);
signed int sub_1004DDD0();
char __thiscall sub_1004DDE0(void *this);
// char __usercall sub_1004DE50@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4);
// void *__usercall sub_1004DE90@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4);
char __cdecl sub_1004DF30(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1004DF70(char a1, char a2, void *a3);
char __cdecl sub_1004DFD0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1004E010(char a1, char a2, void *a3);
char __cdecl sub_1004E040(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1004E080(char a1, char a2, void *a3);
char __cdecl sub_1004E0C0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1004E100(char a1, char a2, void *a3);
char __cdecl sub_1004E150(int a1, char a2, void *a3);
char __cdecl sub_1004E1C0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1004E200(char a1, char a2, void *a3);
char __cdecl sub_1004E240(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1004E280(char a1, char a2, void *a3);
char __cdecl sub_1004E2C0(char a1, void *a2);
char __cdecl sub_1004E2F0(char a1, void *a2);
char __cdecl sub_1004E320(char a1, void *a2);
char __cdecl sub_1004E350(char a1, void *a2);
char __cdecl sub_1004E380(char a1, void *a2);
char __cdecl sub_1004E3B0(char a1, void *a2);
char __cdecl sub_1004E3E0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1004E420(char a1, char a2, void *a3);
char __cdecl sub_1004E470(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1004E4B0(char a1, char a2, void *a3);
char __cdecl sub_1004E4E0(char a1, void *a2);
char __cdecl sub_1004E510(char a1, void *a2);
char __cdecl sub_1004E540(char a1, void *a2);
char __cdecl sub_1004E570(int a1, char a2, char a3, int a4, void *a5);
char __cdecl sub_1004E910(void *a1);
BOOL __cdecl sub_1004E930(int a1);
char __cdecl sub_1004E950(int a1);
char __cdecl sub_1004E970(int a1, char a2, int a3, int a4, void *a5);
char __cdecl sub_1004E9A0(int a1);
char sub_1004E9E0();
int sub_1004E9F0();
char sub_1004EA00();
bool __cdecl sub_1004EA10(char a1, void *a2);
bool __cdecl sub_1004EA50(char a1, unsigned int *a2);
char __cdecl sub_1004EA90(char a1, void *a2);
bool __cdecl sub_1004EB50(char a1, void *a2);
bool __cdecl sub_1004EC40(char a1, char a2, int a3, int a4, void *a5);
int __cdecl sub_1004EC70(char a1);
_DWORD __cdecl sub_1004ECA0(char); // weak
char __cdecl sub_1004ECB0(char a1, char a2, __int16 a3);
char __cdecl sub_1004ECF0(char a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
char __cdecl sub_1004ED30(void *a1);
bool __thiscall sub_1004ED50(void *this);
char sub_1004ED70();
BOOL __cdecl sub_1004EE10(int a1, int a2);
char __cdecl sub_1004EE30(int a1, unsigned int *a2);
char __cdecl sub_1004EEB0(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_1004EEF0(int a1, unsigned int *a2);
char __cdecl sub_1004EF40(_BYTE *a1);
BOOL sub_1004EF80();
bool __thiscall sub_1004EFE0(void *this);
char __cdecl sub_1004F000(int a1, char *a2);
BOOL __cdecl sub_1004F0F0(int a1, int a2);
__int16 sub_1004F110();
char __cdecl sub_1004F160(int a1, unsigned int *a2);
BOOL sub_1004F1C0();
char __cdecl sub_1004F200(int a1, char a2, int a3, int a4, char *a5);
char __cdecl sub_1004F240(int a1, unsigned int *a2);
char __cdecl sub_1004F290(char a1, _BYTE *a2, _BYTE *a3, char a4);
char __thiscall sub_1004F2D0(void *this);
// void __usercall sub_1004F390(unsigned __int16 a1@<bx>, unsigned __int16 *a2@<edi>, int a3, int a4, char a5, int a6);
char __cdecl sub_1004F3F0(unsigned __int8 a1);
// char __usercall sub_1004F430@<al>(void *a1@<ecx>, int a2@<esi>);
char __cdecl sub_1004F470(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_1004F9F0(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_1004FA50(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_1004FAA0(char a1, unsigned __int16 a2, int a3, int a4, int a5);
char __cdecl sub_1004FB20(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_100502D0(char a1, unsigned __int16 a2, int a3, int a4, int a5);
char __cdecl sub_100503B0(char a1, unsigned __int16 a2, int a3, int a4, int a5);
char __cdecl sub_10050440(char a1, unsigned __int16 a2, int a3, int a4, int a5);
char __cdecl sub_10050650(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_10050870(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_100508D0(char a1, unsigned __int16 a2, int a3, int a4, int a5);
// void *__usercall sub_10050930@<eax>(void *a1@<ebx>, const void *a2@<edi>, int a3@<esi>, int a4);
char __cdecl sub_10050960(unsigned __int8 a1);
char sub_100509C0();
double __cdecl sub_100509F0(int a1);
unsigned int __cdecl sub_10050A40(unsigned int a1);
int __cdecl sub_10050A60(int a1);
bool __cdecl sub_10050A70(int a1);
int __cdecl sub_10050B40(int a1);
int __cdecl sub_10050B60(int a1, int a2);
bool __cdecl sub_10050BA0(int a1);
signed int __cdecl sub_10050C00(int a1, void *a2, unsigned __int16 a3, __int16 a4);
signed int __cdecl sub_10050CC0(int a1, int a2, int a3);
int __cdecl sub_10050D70(int a1);
signed int __cdecl sub_10050D90(_BYTE *a1, _BYTE *a2, int a3);
// int __usercall sub_10050DF0@<eax>(int a1@<esi>, int a2, char a3);
// int __usercall sub_10050F00@<eax>(int a1@<eax>, int a2@<esi>);
// signed int __usercall sub_10050FB0@<eax>(int a1@<eax>, int a2@<esi>);
// char __usercall sub_10051180@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_10051190@<eax>(int result@<eax>);
// char __usercall sub_100511B0@<al>(int a1@<eax>);
// int __usercall sub_100511D0@<eax>(int a1@<esi>, unsigned __int8 a2);
int __cdecl sub_10051210(unsigned int a1);
int __fastcall sub_100513C0(int a1, int a2);
// int __usercall sub_100513E0@<eax>(int result@<eax>, int a2@<ecx>);
// int __usercall sub_100513F0@<eax>(int a1@<esi>);
// signed int __usercall sub_10051430@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_10051640(void *); // idb
int __cdecl sub_100516A0(int, int, void *, int); // idb
signed int __cdecl sub_100517A0(int a1, unsigned __int64 a2);
signed int __cdecl sub_100519A0(int a1, int a2);
int __cdecl sub_100519C0(int a1);
int __cdecl sub_10051C30(void *, int, char); // idb
signed int __cdecl sub_10051D00(unsigned int a1, int a2, int a3);
// int __usercall sub_10051DA0@<eax>(int a1@<eax>);
// int __usercall sub_10051DC0@<eax>(int a1@<edi>, int a2);
// signed int __usercall sub_10051DF0@<eax>(int a1@<eax>, int a2@<ebx>);
int __cdecl sub_10051E60(int, char *, int); // idb
// void __cdecl __noreturn exit_0(int);
signed int __cdecl sub_10051FD0(int a1);
// char __usercall sub_10052030@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>);
// signed int __usercall sub_10052060@<eax>(int a1@<eax>);
// BOOL __usercall sub_10052090@<eax>(int a1@<ebx>, int a2);
signed int __cdecl sub_100520D0(unsigned int a1);
signed int __cdecl sub_10052120(int a1, int a2);
// bool __usercall sub_10052310@<al>(int a1@<eax>);
int __cdecl sub_10052340(int, int, char, void *, int); // idb
signed int __cdecl sub_10052450(unsigned int a1, int a2, int a3);
signed int __cdecl sub_100524B0(unsigned int a1, int a2, int a3);
int __cdecl sub_10052640(int a1, char *a2, int a3, void *a4, int a5);
int __cdecl sub_10052830(char a1, __int16 a2, int a3);
char __cdecl sub_100528A0(char a1);
char __cdecl sub_10052920(unsigned __int16 a1, _WORD *a2);
char __cdecl sub_100529A0(unsigned __int16 a1, _WORD *a2);
char __cdecl sub_10052A00(char a1);
signed int __cdecl sub_10052A40(int a1, int a2);
char __cdecl sub_10052BF0(char *a1);
char __cdecl sub_10052C60(int a1, char a2);
char __cdecl sub_10052D70(int a1, char a2);
char __cdecl sub_10052DE0(char a1, int a2);
char __cdecl sub_10052F50(unsigned __int8 a1, char a2, int a3);
// int __usercall sub_10053040@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3);
// int __usercall sub_10053080@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3);
signed int sub_100530C0();
// char __usercall sub_100530D0@<al>(int a1@<eax>, int a2@<edi>);
// bool __usercall sub_10053140@<al>(char a1@<al>, char a2);
// bool __usercall sub_100531B0@<al>(char a1@<al>, char a2);
char __cdecl sub_10053220(char a1, char a2);
// char __usercall sub_100532B0@<al>(unsigned __int8 a1@<al>, unsigned __int8 a2@<cl>, char a3);
// char __usercall sub_10053300@<al>(signed int a1@<edx>, unsigned __int8 a2@<cl>, int a3@<esi>);
// bool __usercall sub_100533C0@<al>(char a1@<al>, char a2);
char __cdecl sub_10053430(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_10053490(char a1, void *a2);
char __cdecl sub_100535B0(unsigned __int8 a1, char a2, _WORD *a3);
char __cdecl sub_10053600(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10053680(int a1);
char __cdecl sub_100538F0(int a1, signed int a2, int a3);
// char __usercall sub_10053A50@<al>(unsigned __int8 a1@<bl>, int a2@<esi>);
// char __usercall sub_10053AA0@<al>(unsigned __int8 a1@<cl>, int a2@<edi>);
char __cdecl sub_10053B50(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6);
char __cdecl sub_10053D00(int a1, int a2, char a3);
__int16 __cdecl sub_10054290(char a1);
__int16 __cdecl sub_100542C0(char a1, char a2);
char __cdecl sub_10054330(char a1);
__int16 __cdecl sub_10054360(char a1, char a2);
signed int __cdecl sub_100543D0(_BYTE *a1, char a2, int a3);
int __cdecl sub_10054420(int, float, float, int, int); // idb
unsigned int __cdecl sub_10054510(char *a1, char a2, char a3, char a4, int a5);
unsigned int __cdecl sub_10054560(_BYTE *a1, __int16 a2, __int16 a3, __int16 a4, int a5);
unsigned int __cdecl sub_10054600(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5);
unsigned int __cdecl sub_100546C0(void *a1, size_t a2, int a3);
int __cdecl sub_10054720(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
int __cdecl sub_10054770(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5);
int __cdecl sub_10054810(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
char *__cdecl sub_100548C0(int a1, int a2, int a3, size_t a4, char *a5);
int sub_10054A40();
const char *__cdecl sub_10054A50(unsigned int a1);
int __cdecl sub_10054A70(int a1, int a2, int a3, int a4);
int __cdecl sub_10054B20(int a1);
int __cdecl sub_10054B40(int a1);
char *sub_10054B60(char *a1, ...);
// char *__usercall sub_10054BA0@<eax>(char a1@<al>, unsigned __int8 a2@<cl>);
// char __usercall sub_10054BC0@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5);
int sub_10054DA0();
int sub_10054DC0();
int __cdecl sub_10054DE0(int a1, int a2);
int __cdecl sub_10054E40(int a1);
int __cdecl sub_10054E50(int a1, int a2);
int __cdecl sub_10054EB0(int a1);
bool __cdecl sub_10054EC0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_10055000(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_100553B0(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9);
bool __cdecl sub_10055800(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9);
bool __cdecl sub_10055CC0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_10056080(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9);
bool __cdecl sub_10056480(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_10056840(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9);
bool __cdecl sub_10056D80(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9);
bool __cdecl sub_10057160(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_10057520(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_100578C0(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9);
bool __cdecl sub_10057CC0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_10058060(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9);
bool __cdecl sub_10058640(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9);
bool __cdecl sub_10058A30(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
int sub_10058DD0();
// BOOL __usercall sub_10058E00@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6);
// bool __usercall sub_10058F70@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9);
char __cdecl sub_100591E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
bool __cdecl sub_100594E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
bool __cdecl sub_10059590(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8);
char __cdecl sub_100595D0(_DWORD *a1);
char __cdecl sub_100596E0(int a1, unsigned int a2);
bool __cdecl sub_10059710(const void **a1, int a2);
bool __cdecl sub_10059740(const void **a1, int a2);
bool __cdecl sub_10059770(const void **a1, int a2);
bool __cdecl sub_100597A0(const void **a1, int a2);
bool __cdecl sub_100597D0(const void **a1, int a2);
bool __cdecl sub_10059800(int a1, int a2);
bool __cdecl sub_10059840(int a1, int a2);
bool __cdecl sub_10059880(const void **a1, int a2);
bool __cdecl sub_100598B0(const void **a1, int a2);
char __cdecl sub_100598E0(int a1, unsigned int a2);
bool __cdecl sub_10059910(const void **a1, int a2);
bool __cdecl sub_10059940(const void **a1, int a2);
bool __cdecl sub_10059970(const void **a1, int a2);
bool __cdecl sub_100599A0(const void **a1, int a2);
bool __cdecl sub_100599D0(const void **a1, int a2);
bool __cdecl sub_10059A00(const void **a1, int a2);
bool __cdecl sub_10059A30(const void **a1, int a2);
bool __cdecl sub_10059A60(const void **a1, int a2);
bool __cdecl sub_10059A90(const void **a1, int a2);
bool __cdecl sub_10059AC0(const void **a1, int a2);
int __cdecl sub_10059AF0(int a1, int a2, int a3);
// void __cdecl __noreturn exit_1(int);
int __cdecl sub_10059B60(int a1, char a2);
int __cdecl sub_10059B80(int a1, int a2, int a3);
int __cdecl sub_10059BB0(int a1, int a2, int a3, int a4);
int __cdecl sub_10059BE0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_10059C20(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_10059C60(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
char __cdecl sub_10059CB0(int a1);
char __cdecl sub_10059CE0(int a1);
char __cdecl sub_10059CF0(int a1, int a2);
signed int __cdecl sub_10059E70(int a1);
signed int __cdecl sub_10059EB0(int a1, int a2, int a3);
char __cdecl sub_10059F50(int a1);
char __cdecl sub_10059FB0(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_1005A020(char *a1);
int __cdecl sub_1005A0C0(int a1, int a2, int a3);
bool __cdecl sub_1005A130(int a1, unsigned int a2, int a3);
char __cdecl sub_1005A1C0(int a1, int a2, char a3, char a4);
char __cdecl sub_1005A270(int a1);
char __cdecl sub_1005A280(int a1, void (__cdecl *a2)(int));
int (__cdecl *__cdecl sub_1005A300(int a1, const char *a2))(const char *);
signed int __cdecl sub_1005A350(int a1, void (__cdecl *a2)(int));
int __cdecl sub_1005A3A0(int a1);
int __cdecl sub_1005A3B0(void *); // idb
int __cdecl sub_1005A430(int a1, int a2);
signed int __cdecl sub_1005A460(int a1, int a2, int a3);
signed int __cdecl sub_1005A480(int a1, int a2);
bool __cdecl sub_1005A4E0(signed int a1);
int sub_1005A550();
char sub_1005A870();
char sub_1005AA90();
char sub_1005AC90();
char sub_1005AE10();
char sub_1005AF90();
char sub_1005B100();
char sub_1005B200();
char sub_1005B360();
char sub_1005B4C0();
char sub_1005B620();
char sub_1005B790();
char sub_1005B8F0();
char sub_1005BA50();
char sub_1005BC70();
char sub_1005BDD0();
char sub_1005BF30();
char sub_1005C090();
char sub_1005C200();
char sub_1005C360();
char sub_1005C4C0();
char sub_1005C6E0();
char sub_1005C8E0();
char sub_1005CA60();
char sub_1005CBE0();
char sub_1005CD50();
char sub_1005CE40();
char sub_1005CFA0();
char sub_1005D100();
char sub_1005D260();
char sub_1005D3D0();
char sub_1005D530();
char sub_1005D690();
char sub_1005D890();
char sub_1005D9F0();
char sub_1005DB50();
char sub_1005DCB0();
char sub_1005DE20();
char sub_1005DF80();
char sub_1005E0E0();
char sub_1005E680();
char sub_1005E890();
char sub_1005EA80();
char sub_1005EBF0();
char sub_1005ED60();
char sub_1005EEC0();
char sub_1005EFB0();
char sub_1005F110();
char sub_1005F270();
char sub_1005F3D0();
char sub_1005F540();
char sub_1005F6A0();
char sub_1005F800();
char sub_1005FA00();
char sub_1005FB60();
char sub_1005FCC0();
char sub_1005FE20();
char sub_1005FF90();
char sub_100600F0();
char sub_10060250();
char sub_10060460();
char sub_10060650();
char sub_100607C0();
char sub_10060930();
char sub_10060A90();
char sub_10060B80();
char sub_10060CE0();
char sub_10060E40();
char sub_10060FA0();
char sub_10061110();
char sub_10061270();
char sub_100613D0();
char sub_100615D0();
char sub_10061730();
char sub_10061890();
char sub_100619F0();
char sub_10061B60();
char sub_10061CC0();
char **sub_10061E20();
_DWORD __cdecl sub_10061E30(_DWORD); // weak
bool sub_10061E40();
bool sub_10061E50();
char __cdecl sub_10061E70(__int16 a1, void *a2);
signed int __fastcall sub_10061F10(unsigned __int8 a1);
char __cdecl sub_10061F20(unsigned __int8 a1);
__int16 __cdecl sub_10061F40(unsigned __int8 a1);
__int16 __cdecl sub_10061F60(unsigned __int8 a1);
int __cdecl sub_10061F80(int a1);
signed int __cdecl sub_10062080(int a1, int a2);
char __cdecl sub_10062120(int a1, float *a2);
// char __usercall sub_10062180@<al>(unsigned __int16 a1@<ax>, int a2@<esi>, float a3, char a4, char a5);
// double __usercall sub_10062290@<st0>(int a1@<eax>, _BYTE *a2@<ebx>, int a3, float a4);
unsigned __int8 __cdecl sub_10062390(int a1, int a2, char a3, void *a4);
char __cdecl sub_10062520(unsigned __int16 a1, void *a2);
// int __usercall sub_10062580@<eax>(unsigned __int16 a1@<di>);
int __cdecl sub_100625C0(unsigned __int16 a1);
BOOL __cdecl sub_100625F0(unsigned __int16 a1);
char __cdecl sub_10062610(char a1, void *a2);
char __cdecl sub_100626C0(char a1);
char __cdecl sub_10062720(char a1);
char __cdecl sub_10062760(char a1);
signed int __cdecl sub_100627A0(char a1);
char __cdecl sub_100627E0(char a1);
char __cdecl sub_10062820(int a1);
char __cdecl sub_10062860(char a1);
char __cdecl sub_10062880(char a1);
char __cdecl sub_100628A0(char a1);
char __cdecl sub_100628C0(char a1);
char __cdecl sub_100628F0(char a1);
char __cdecl sub_10062920(char a1);
bool __cdecl sub_10062960(unsigned __int8 a1, char a2, unsigned int a3);
bool __cdecl sub_100629F0(char a1, char a2, void *a3);
// char __usercall sub_10062A70@<al>(void *a1@<eax>, int a2);
bool __cdecl sub_10062AA0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6);
char __cdecl sub_10062B40(int a1, char a2, void *a3);
int __cdecl sub_10062C60(unsigned __int8 *a1);
unsigned int __cdecl sub_10062C80(void *a1);
unsigned int __cdecl sub_10062CA0(void *a1);
unsigned int __cdecl sub_10062CC0(void *a1);
unsigned int __cdecl sub_10062CE0(void *a1);
unsigned int __cdecl sub_10062D00(void *a1);
int __cdecl sub_10062D20(int a1);
signed int __cdecl sub_10062D70(_BYTE *a1, int a2);
int __cdecl sub_10062DA0(void *); // idb
unsigned int __cdecl sub_10062E70(void *a1);
char __cdecl sub_10062ED0(unsigned __int16 a1, _BYTE *a2, _WORD *a3);
char __cdecl sub_10062F30(char a1, __int16 a2, unsigned __int16 *a3);
int __cdecl sub_10062F90(char a1);
char __cdecl sub_10062FB0(unsigned __int8 a1);
int __cdecl sub_10062FD0(int, void *); // idb
// int __usercall sub_10063030@<eax>(char a1@<al>);
BOOL __cdecl sub_10063060(char a1, int a2);
int __cdecl sub_10063090(int, char, int, int, void *); // idb
char __cdecl sub_100630C0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10063160(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_100631E0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10063250(char a1, void *a2);
char __cdecl sub_100632D0(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10063350(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_100633D0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10063440(char a1, char a2, char a3, unsigned __int8 *a4, int a5);
char __cdecl sub_10063550(char a1, void *a2);
bool __cdecl sub_10063570(unsigned __int8 a1, char *a2);
char __cdecl sub_100635B0(int a1, char a2, int a3, int a4, void *a5);
char __cdecl sub_100635F0(int a1, int a2);
BOOL __cdecl sub_100636A0(int a1, int a2);
char __cdecl sub_100636C0(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_10063700(void *a1);
char __cdecl sub_10063720(void *a1);
bool __thiscall sub_10063870(void *this);
char __cdecl sub_10063890(unsigned __int8 a1);
char __cdecl sub_10063900(int a1, char a2, char a3, int a4, void *a5, size_t a6);
char __cdecl sub_10063AA0(char a1);
// __int16 __usercall sub_10063AE0@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_10063AF0(unsigned __int8 a1, char *a2);
char __cdecl sub_10063BC0(char a1, char a2, char a3, int a4, char *a5, unsigned int a6);
char __cdecl sub_10063C40(unsigned __int16 a1);
char __cdecl sub_10063CE0(char a1, char a2, char a3, int a4, void *a5);
int __cdecl sub_10063DF0(char a1);
bool __cdecl sub_10063E40(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10063EB0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10063F10(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10063F80(char a1, _BYTE *a2);
char __thiscall sub_10063FC0(void *this);
char __cdecl sub_10064030(char a1, int a2);
char __cdecl sub_10064060(char a1, int a2);
char __cdecl sub_10064090(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6);
char __cdecl sub_10064260(char a1);
int __cdecl sub_10064280(int a1);
int __cdecl sub_100642C0(int *a1, int a2);
_DWORD __cdecl sub_100642E0(_DWORD, _DWORD); // weak
int __cdecl sub_100642F0(char a1, char *a2);
char sub_10064340();
char sub_10064350();
char __cdecl sub_10064360(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
char __cdecl sub_100643C0(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
char sub_10064420();
char __cdecl sub_100644A0(_DWORD *a1);
int __cdecl sub_10064510(_BYTE *a1);
int __cdecl sub_10064530(unsigned __int8 *a1);
int __cdecl sub_10064550(unsigned __int8 *a1);
int __cdecl sub_10064570(unsigned __int8 *a1);
int __cdecl sub_10064590(unsigned __int8 *a1);
_DWORD __cdecl sub_100645B0(_DWORD); // weak
int __cdecl sub_100645C0(int a1);
int __cdecl sub_10064600(int a1);
char __cdecl sub_10064620(int a1, int a2);
char __cdecl sub_10064670(int a1, int a2);
char __cdecl sub_10064720(int a1, int a2);
char __cdecl sub_10064780(int a1, int a2);
char *__cdecl sub_10064850(char **a1);
int sub_100648A0();
int __cdecl sub_100648E0(_BYTE *a1, int a2);
signed int __cdecl sub_10064950(_BYTE *a1, int a2);
// int __usercall sub_100649F0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>);
// signed int __usercall sub_10064A20@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5);
// char *__usercall sub_10064BF0@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>);
// int __usercall sub_10064C50@<eax>(int a1@<esi>, int a2, _DWORD *a3);
// int __usercall sub_10064CE0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4);
// char **__usercall sub_10064D30@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3);
// const char *__usercall sub_10064D90@<eax>(int a1@<eax>);
// int __usercall sub_10064DB0@<eax>(unsigned int a1@<ebx>);
// int __usercall sub_10064DF0@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5);
// int __usercall sub_10064E80@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4);
// int __usercall sub_10064FD0@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>);
// int __usercall sub_10065070@<eax>(int result@<eax>);
char *__cdecl sub_100650B0(int a1, char *a2, int a3, const char *a4);
// int __usercall sub_10065260@<eax>(int a1@<eax>);
// int __usercall sub_10065290@<eax>(int a1@<esi>);
void __cdecl sub_100652C0(int (**a1)(void), char **a2, _DWORD *a3);
int sub_10065730();
void *sub_10065780();
char *sub_100657E0();
char sub_10065800();
char __cdecl sub_10065810(int a1, int a2, unsigned int a3);
// int *__usercall sub_10065850@<eax>(_DWORD *a1@<ebx>, int a2);
char **sub_100658A0();
int __cdecl sub_100658B0(_DWORD *a1, int a2, int a3);
int __cdecl sub_10065960(int a1, int a2, int a3, const char *a4, const char *a5);
// char *__usercall sub_10065B70@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6);
char *__cdecl sub_10065C30(char a1);
int *__cdecl sub_10065CD0(_BYTE *a1);
// int __usercall sub_10065D90@<eax>(int a1@<eax>);
// signed int __usercall sub_10065EF0@<eax>(int a1@<esi>);
int __cdecl sub_10065F60(int, int); // weak
char **sub_10066240();
// int __usercall sub_10066250@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6);
int __cdecl sub_10066340(char *a1);
int sub_10066580();
int __cdecl sub_10066660(int a1, int a2, char a3);
const char *__cdecl sub_100666B0(int a1, int a2);
char __cdecl sub_100666F0(int a1, int *a2, unsigned int a3);
signed int __cdecl sub_100674A0(int a1, int a2);
char **__cdecl sub_10067520(int a1);
int (__cdecl *__cdecl sub_10067560(const char *a1))(const char *);
const char *sub_10067580();
__int64 sub_10067590();
const char *sub_100675A0();
// int __usercall sub_100675B0@<eax>(_BYTE *a1@<edi>, int a2);
signed int __cdecl sub_10067600(int a1, int a2);
int sub_10067630(); // weak
// int __usercall sub_10067750@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3);
char __cdecl sub_10067AD0(int a1, const void **a2, unsigned int a3);
char **__cdecl sub_100688F0(int a1);
int __cdecl sub_10068960(unsigned __int8 *a1);
int __cdecl sub_10068980(unsigned __int8 *a1, int a2);
int __cdecl sub_100689B0(unsigned __int8 *a1);
__int16 *__cdecl sub_100689D0(char a1, unsigned __int16 a2);
int __cdecl sub_10068C40(unsigned __int8 a1, char a2);
int __cdecl sub_10068CC0(unsigned __int8 a1, char a2);
int __cdecl sub_10068D40(unsigned __int8 a1, char a2);
void *__cdecl sub_10068DC0(unsigned __int8 a1, char a2);
int __cdecl sub_10068E40(char a1);
int __cdecl sub_10068E60(char a1);
int __cdecl sub_10068E80(char a1);
void *__cdecl sub_10068EA0(char a1, unsigned __int8 a2, char a3);
void *__cdecl sub_10068F60(unsigned __int8 a1, char a2, char a3);
void *__cdecl sub_10069000(unsigned __int8 a1, char a2, char a3);
char sub_100690D0();
void *__cdecl sub_100690E0(char a1);
char sub_10069130();
int *__cdecl sub_100693C0(char a1);
bool __thiscall sub_10069420(void *this);
void *__cdecl sub_10069440(char a1);
int __cdecl sub_100694A0(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_10069570(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
int __cdecl sub_10069810(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_100698E0(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_100699B0(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_10069A80(unsigned __int8 a1, char a2);
int __cdecl sub_10069B10(unsigned __int8 a1, char a2);
int __cdecl sub_10069BA0(unsigned __int8 a1, char a2);
int __cdecl sub_10069C30(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_10069D00(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_10069DD0(unsigned __int8 a1, char a2);
int __cdecl sub_10069E60(unsigned __int8 a1, char a2);
int __cdecl sub_10069EF0(int a1, unsigned __int8 a2, char a3);
int __cdecl sub_10069F90(unsigned __int8 a1, char a2);
int __cdecl sub_10069FB0(unsigned __int8 a1, char a2);
void *__cdecl sub_10069FD0(char a1);
int __cdecl sub_1006A030(unsigned __int8 a1, char a2);
int __cdecl sub_1006A0B0(unsigned __int8 a1);
int __cdecl sub_1006A0D0(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_1006A1A0(unsigned __int8 a1, char a2);
int __cdecl sub_1006A230(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_1006A300(int a1, unsigned __int8 a2, char a3);
int __cdecl sub_1006A3A0(unsigned __int8 a1, char a2);
char __cdecl sub_1006A3C0(char a1);
char __cdecl sub_1006A400(char a1);
signed int __cdecl sub_1006A440(char a1);
void *__cdecl sub_1006A490(char a1);
void *__cdecl sub_1006A4F0(char a1);
void *__cdecl sub_1006A550(char a1);
int __cdecl sub_1006A5B0(char a1, char a2);
void *__cdecl sub_1006A650(char a1);
void *__cdecl sub_1006A6B0(char a1);
// signed int __usercall sub_1006A710@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_1006B7C0@<eax>(int a1@<esi>, int a2, unsigned int a3);
// signed int __usercall sub_1006B820@<eax>(int a1@<eax>, int a2, int a3);
// void *__usercall sub_1006C5A0@<eax>(void *a1@<eax>);
unsigned int __cdecl sub_1006C5C0(int a1, unsigned int a2);
// int __usercall sub_1006C620@<eax>(int result@<eax>);
// int __usercall sub_1006C660@<eax>(int result@<eax>);
// unsigned int __usercall sub_1006DD80@<eax>(int a1@<esi>, int a2);
// void *__usercall sub_1006DE80@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3);
// void *__usercall sub_1006DF00@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3);
// int __usercall sub_1006DFA0@<eax>(int a1@<edi>, int a2, size_t a3);
// int __usercall sub_1006E060@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3);
// int __usercall sub_1006E0C0@<eax>(char *a1@<edi>);
// int __usercall sub_1006E180@<eax>(int a1@<ebx>);
char __cdecl sub_1006E240(char *a1, size_t a2, int a3);
char __cdecl sub_1006E290(char *a1, unsigned int a2, int a3);
bool __cdecl sub_1006E2E0(int a1, int a2);
// int __usercall sub_1006E310@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7);
// int __usercall sub_1006E520@<eax>(void *a1@<eax>, int a2);
char *__cdecl sub_1006E570(int a1, int a2);
signed int __cdecl sub_1006E600(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6);
bool __cdecl sub_1006E730(void *a1, int a2);
// BOOL __usercall sub_1006E7B0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_1006E850@<eax>(int result@<eax>);
unsigned int __fastcall sub_1006E8E0(unsigned int a1, int a2);
// int __usercall sub_1006E900@<eax>(int result@<eax>);
// int __usercall sub_1006E990@<eax>(int result@<eax>, int a2, int a3);
// int __usercall sub_1006EE10@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>);
// void *__usercall sub_1006EEC0@<eax>(int a1@<edi>);
// int __usercall sub_1006EF20@<eax>(int result@<eax>, int a2@<edx>);
// signed int __usercall sub_1006F0F0@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>);
_WORD *__fastcall sub_1006F170(int a1, int a2);
// signed int __usercall sub_1006F1E0@<eax>(int a1@<esi>);
// unsigned int __usercall sub_1006F2A0@<eax>(int a1@<esi>, unsigned int a2);
// unsigned int __usercall sub_1006F450@<eax>(int a1@<esi>, int a2);
// int __usercall sub_1006F520@<eax>(int result@<eax>, int a2@<edi>, int a3);
// int __usercall sub_1006F5D0@<eax>(int result@<eax>, __int16 a2@<cx>);
// unsigned int __usercall sub_1006F610@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3);
// signed int __usercall sub_1006F670@<eax>(signed int result@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_1006F750@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
_WORD *__fastcall sub_1006FCF0(int a1, int a2);
signed int __cdecl sub_1006FD50(int a1);
// int __usercall sub_1006FDE0@<eax>(int a1@<eax>);
// int __usercall sub_10070020@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4);
// signed int __usercall sub_100700C0@<eax>(int a1@<esi>, int a2);
// unsigned int __usercall sub_100702A0@<eax>(int a1@<edi>);
// int __usercall sub_100703E0@<eax>(int a1@<eax>, int a2, int a3, int a4);
signed int __cdecl sub_10070690(int a1, int a2);
signed int __cdecl sub_10070950(int a1, unsigned __int8 a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8);
// signed int __usercall sub_10070B00@<eax>(int a1@<eax>);
// _WORD *__usercall sub_10070BD0@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
signed int __cdecl sub_10070DF0(int a1, int a2);
signed int __cdecl sub_10071100(int a1, int a2);
signed int __cdecl sub_10071510(int a1, int a2);
int __cdecl sub_10071680(unsigned int a1, _BYTE *a2, unsigned int a3);
signed int __cdecl sub_10071780(int a1);
// signed int __usercall sub_100717A0@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10);
// int (__cdecl *__usercall sub_10071C40@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD);
// int __usercall sub_10071C90@<eax>(int result@<eax>, char a2, char a3, int a4, int a5);
signed int __cdecl sub_10071CB0(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_10072060@<eax>(int a1@<edi>, int a2@<esi>, int a3);
// signed int __usercall sub_100721A0@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4);
// signed int __usercall sub_100721F0@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9);
// int __usercall sub_10072290@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4);
signed int __cdecl sub_100722B0(int a1, int a2, int a3, int a4);
signed int __cdecl sub_100723A0(int a1);
// int __usercall sub_100723B0@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_10072A50@<eax>(int a1@<eax>, int a2, int a3);
// signed int __usercall sub_10073430@<eax>(int a1@<edi>, int a2);
signed int __cdecl sub_10073760(int a1, int a2);
char __cdecl sub_10073780(signed int a1, _DWORD *a2, _DWORD *a3);
char *__cdecl sub_100737C0(const char *a1, int a2);
// char *__usercall sub_10073830@<eax>(char *result@<eax>);
void __cdecl sub_10073860(char *a1);
void __cdecl sub_10073920(char *a1, char *a2);
void *__cdecl sub_10073980(int a1);
void __cdecl sub_10073B10(int a1);
int __cdecl sub_10073B40(int a1);
bool __cdecl sub_10073B60(int a1);
void *__cdecl sub_10073B90(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5);
// unsigned int __usercall sub_10073BD0@<eax>(int a1@<edx>, int a2, int a3);
// int __usercall sub_10073BF0@<eax>(int result@<eax>, int a2@<ecx>);
char __cdecl sub_10073C10(void (__cdecl *a1)(_DWORD), int a2);
signed int __cdecl sub_10073C40(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5);
void __cdecl sub_10073D20(int a1, int a2, int a3);
// void *__usercall sub_10073DD0@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3);
void __cdecl sub_10074050(int a1, int a2);
char __cdecl sub_10074120(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4);
// int __usercall sub_10074190@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9);
// int __usercall sub_100744F0@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7);
int __cdecl sub_10074600(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10);
char __cdecl sub_10074790(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3);
// char __usercall sub_100748E0@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5);
char __cdecl sub_10074A30(int a1, int a2);
BOOL __cdecl sub_10074A70(unsigned int a1);
BOOL __cdecl sub_10074A90(int a1);
_DWORD __cdecl sub_10074AB0(_DWORD); // weak
unsigned int __cdecl sub_10074AC0(int a1, char a2);
signed int __cdecl sub_10074B20(void *a1, int a2, unsigned int a3);
_DWORD __cdecl sub_10074B40(_DWORD, _DWORD, _DWORD); // weak
char __cdecl sub_10074B60(const char *a1, const char *a2);
int __cdecl sub_10074CA0(int a1, int a2, unsigned int a3);
int __cdecl sub_10074D20(int a1, int a2);
// char __usercall sub_10074E60@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5);
signed int __cdecl sub_10074F30(_DWORD *a1, char *a2);
// char __usercall sub_10075010@<al>(void *a1@<esi>);
// char __usercall sub_10075050@<al>(float *a1@<esi>);
char __cdecl sub_10075070(float *a1);
char __cdecl sub_100750D0(float *a1);
char __cdecl sub_10075130(float *a1);
// char __usercall sub_10075190@<al>(int a1@<esi>);
char __cdecl sub_10075230(float *a1);
char __cdecl sub_10075280(float *a1);
char __cdecl sub_100752D0(float *a1);
char __cdecl sub_10075330(float *a1);
// char __usercall sub_10075390@<al>(float *a1@<esi>, char a2);
char __cdecl sub_10075480(float a1, int a2);
// char __usercall sub_100754F0@<al>(float *a1@<esi>);
char __cdecl sub_10075570(float *a1);
char __cdecl sub_100755D0(float *a1);
char __cdecl sub_10075660(float *a1);
// char __usercall sub_100756F0@<al>(float *a1@<esi>);
// char __usercall sub_10075A90@<al>(float *a1@<esi>);
// char __usercall sub_10075B00@<al>(float *a1@<esi>);
// char __usercall sub_10075B20@<al>(float *a1@<esi>);
// void __usercall sub_10075BB0(float *a1@<esi>);
char __cdecl sub_10075C40(float *a1);
// char __usercall sub_10075D60@<al>(float *a1@<esi>, float a2);
// char __usercall sub_10075F60@<al>(float *a1@<esi>, float a2);
// char __usercall sub_10075FF0@<al>(float *a1@<eax>);
// char __usercall sub_10076000@<al>(float *a1@<eax>);
// char __usercall sub_10076010@<al>(float *a1@<eax>);
// char __usercall sub_10076020@<al>(float *a1@<eax>);
// int __usercall sub_10076030@<eax>(char a1@<dl>, int a2@<ecx>, float *a3);
// char __usercall sub_10076060@<al>(float *a1@<esi>);
// char __usercall sub_10076100@<al>(float *a1@<esi>);
char __cdecl sub_100761E0(float *a1);
// char __usercall sub_10076230@<al>(float *a1@<esi>);
// char __usercall sub_10076310@<al>(float *a1@<esi>);
// char __usercall sub_100763F0@<al>(float *a1@<esi>);
// char __usercall sub_10076490@<al>(float *a1@<esi>);
// char __usercall sub_10076530@<al>(float *a1@<esi>);
// char __usercall sub_100765D0@<al>(float *a1@<esi>);
char __cdecl sub_100766B0(float *a1);
bool __cdecl sub_10076750(float *a1);
// char __usercall sub_10076800@<al>(float *a1@<esi>);
// char __usercall sub_10076880@<al>(float *a1@<esi>);
// char __usercall sub_10076910@<al>(float *a1@<esi>);
int __cdecl sub_10076980(float *a1);
int __cdecl sub_10076BB0(float *a1);
int __cdecl sub_10076DE0(float *a1);
int __cdecl sub_10077010(float *a1);
// char __usercall sub_10077240@<al>(float *a1@<esi>);
// char __usercall sub_100772D0@<al>(float *a1@<esi>);
bool __cdecl sub_10077340(float *a1);
char __cdecl sub_100773A0(float a1, void *a2);
char __cdecl sub_10077C50(char a1);
signed int __cdecl sub_10077C70(unsigned __int8 a1);
char __cdecl sub_10077DA0(unsigned __int8 a1, unsigned __int8 a2);
int __cdecl sub_10077ED0(char a1, char a2);
// bool __usercall sub_10077F80@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3);
// char __usercall sub_10077FB0@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6);
char __cdecl sub_10078050(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_100780D0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10078150(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_100781D0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10078250(char a1);
int __cdecl sub_100782F0(int a1);
int __cdecl sub_10078300(int a1, int a2, int a3);
// int (__cdecl *__usercall sub_10078320@<eax>(int a1@<eax>, int a2@<ecx>))(int);
// int __usercall sub_10078330@<eax>(unsigned __int8 *a1@<eax>, int a2);
int (__cdecl *__cdecl sub_10078560(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_100785B0(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10078600(int a1, unsigned __int8 *a2))(int);
int (__cdecl *__cdecl sub_10078650(int a1))(int);
int __cdecl sub_100786D0(int a1, int a2);
int (__cdecl *__cdecl sub_10078750(int a1, unsigned __int8 *a2, char a3))(int);
int (__cdecl *__cdecl sub_100787A0(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_100787E0(int a1, int a2, int a3))(int);
bool __thiscall sub_10078840(void *this);
char __cdecl sub_10078880(char a1, void *a2);
char __cdecl sub_10078930(char a1);
char __cdecl sub_100789B0(int a1, float *a2);
int __cdecl sub_10078B10(char, float, int, int, int); // idb
double sub_10079160();
double __cdecl sub_10079190(int a1, float a2, float a3);
char __cdecl sub_100791D0(float *a1, float *a2, float *a3, char a4);
int __cdecl sub_10079760(void *, void *, size_t, int, int); // idb
int __cdecl sub_10079810(unsigned __int16 a1);
double __cdecl sub_10079850(float a1);
int __cdecl sub_100798D0(int a1, int a2);
signed int __cdecl sub_10079900(signed int *a1, signed int a2);
int __cdecl sub_10079930(int a1, int a2);
void __cdecl sub_10079960(int a1, signed int a2, signed int a3);
int __cdecl nullsub_1(_DWORD);
signed int sub_100799C0();
__int16 __cdecl sub_10079A10(signed int a1, signed int a2, int a3);
signed int __cdecl sub_10079E90(signed int a1, signed int a2, signed int a3, signed int a4, int *a5, int *a6);
char __cdecl sub_10079F50(signed int a1, signed int a2, int a3);
int __cdecl sub_10079FC0(signed int a1, signed int a2, signed int a3);
void __cdecl sub_1007A070(int a1, unsigned __int16 a2, void (__cdecl *a3)(int, signed int, int, int), int a4, int a5, int a6);
int __cdecl sub_1007A0E0(char, void *, size_t, int); // idb
// int __usercall sub_1007A110@<eax>(int a1@<esi>);
int __cdecl sub_1007A150(char, void *, char); // idb
int __cdecl sub_1007A1F0(char, void *, size_t, int, size_t, int, size_t, int, size_t, int, int, int, size_t); // idb
int __cdecl sub_1007A500(char, int, int, void *); // idb
char sub_1007A660();
void *sub_1007A720();
// signed int __usercall sub_1007A750@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<esi>);
int __thiscall sub_1007A820(int this);
// int __usercall sub_1007A8D0@<eax>(int a1@<eax>, __int16 a2@<bx>, int a3@<esi>, int a4);
int __cdecl sub_1007AA80(__int16 a1, int a2, unsigned __int16 a3, void (__cdecl *a4)(int, int, int, int), int a5, int a6, int a7, int a8, int a9);
int __cdecl sub_1007AD40(char a1, int a2);
unsigned __int16 __cdecl sub_1007ADD0(unsigned __int16 a1, int a2);
signed int __cdecl sub_1007AF50(int a1);
int __cdecl sub_1007B060(int a1);
int __cdecl sub_1007B080(int a1);
int __cdecl sub_1007B110(int a1);
// __int16 __usercall sub_1007B130@<ax>(int a1@<ecx>, int a2@<esi>, unsigned __int16 a3, unsigned __int16 a4, unsigned __int8 a5);
// __int16 __usercall sub_1007B3F0@<ax>(int a1@<edi>, int a2@<esi>, char a3, __int16 a4);
int __cdecl sub_1007B6E0(int a1, unsigned __int16 *a2, int a3, unsigned __int16 a4);
unsigned __int16 __cdecl sub_1007B820(_BYTE *a1, int a2, unsigned __int16 a3, char a4);
int __cdecl sub_1007B8A0(unsigned __int8 a1, unsigned int a2);
unsigned int __cdecl sub_1007B8C0(unsigned int *a1, signed int a2, unsigned int a3);
unsigned int __cdecl sub_1007B9F0(_BYTE *a1, int a2, unsigned int a3);
double __cdecl sub_1007BA30(float a1, float a2);
int __cdecl sub_1007BAD0(signed int a1, signed int a2);
double __cdecl sub_1007BB10(float a1, float a2);
double __cdecl sub_1007BBB0(double a1, double a2);
double __cdecl sub_1007BC10(float a1, float a2);
int __cdecl sub_1007BC90(double); // idb
double __cdecl sub_1007BCB0(float a1);
int __cdecl sub_1007BCF0(int a1, int a2);
int __cdecl sub_1007BD10(float); // idb
double __cdecl sub_1007BD40(float a1, float a2);
int __cdecl sub_1007BDB0(float, int, int); // idb
int __cdecl sub_1007BDD0(int a1, int a2);
int __cdecl sub_1007BDF0(float); // idb
double __cdecl sub_1007BE50(double a1, double a2);
double __cdecl sub_1007BEC0(float a1, float a2);
int __cdecl sub_1007BF50(int a1, int a2, int a3);
int __cdecl sub_1007BF80(float, int, int); // idb
int __cdecl sub_1007BFB0(int a1);
int sub_1007BFD0();
int __cdecl sub_1007BFF0(int a1, int a2);
__int16 __cdecl sub_1007C020(int a1);
int sub_1007C040();
int __cdecl sub_1007C060(int a1, int a2, int a3, int a4);
int j_TSK_pvg_get_us_timer(void); // weak
int __cdecl sub_1007C0A0(int a1, int a2, int a3, int a4);
int __cdecl sub_1007C0D0(int a1);
int __cdecl sub_1007C0F0(int a1);
int __cdecl sub_1007C110(int a1, int a2);
int __cdecl sub_1007C140(int a1, int a2);
int __cdecl sub_1007C170(int a1, int a2, int a3, int a4);
int __cdecl sub_1007C1A0(int a1, int a2);
int __cdecl sub_1007C1D0(int a1);
int __cdecl sub_1007C1F0(int a1);
char __cdecl sub_1007C210(int a1, int a2);
int __cdecl sub_1007C280(_BYTE *a1);
int __cdecl sub_1007C2C0(int a1, int a2);
int __cdecl sub_1007C2F0(int a1, int a2);
int __cdecl sub_1007C310(int a1);
int __cdecl j_REG_pvg_flush_que(_DWORD, _DWORD, _DWORD); // weak
unsigned int __cdecl sub_1007C360(unsigned int a1);
int __cdecl j_reg_get_tag_hdr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_reg_get_xfil_tag_data(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_1007C3B0(int a1, int a2, int a3);
int __cdecl sub_1007C3D0(int a1, int a2, __int16 a3, int a4, int a5);
char __cdecl sub_1007C430(int a1, int a2, int a3);
int __cdecl sub_1007C470(int, void *, int, void *); // idb
int __cdecl sub_1007C4B0(int a1, int a2, int a3);
int __cdecl sub_1007C4E0(int a1, int a2, int a3);
int __cdecl sub_1007C500(int a1, int a2, int a3);
int __cdecl sub_1007C520(int a1, int a2, int a3);
int __cdecl sub_1007C580(int a1, int a2, int a3);
int __cdecl sub_1007C5C0(int a1, int a2, int a3, int a4);
char __cdecl sub_1007C5E0(int a1, int a2, int a3);
int __cdecl j_REG_pvg_xfil_read_data(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_REG_pvg_xfil_shld_rqst_tag(_DWORD); // weak
int __cdecl j_REG_pvg_xfil_write_data(_DWORD, _DWORD); // weak
int __cdecl sub_1007C650(int, void *, int, void *); // idb
int sub_1007C6A0(void); // weak
__int16 __cdecl sub_1007C6B0(int a1, int a2, int a3, int a4);
int __cdecl sub_1007C6E0(char a1);
int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_rgn_set_info(_DWORD, _DWORD, _DWORD); // weak
__int16 __cdecl sub_1007C760(int a1, _DWORD *a2, _BYTE *a3);
__int16 __cdecl sub_1007C7C0(int a1, _DWORD *a2);
int __cdecl j_HWM_pvg_get_anlg_outp(_DWORD); // weak
int __cdecl j_HWM_pvg_get_frmt_adc(_DWORD); // weak
int __cdecl j_HWM_pvg_hsdb_get(_DWORD, _DWORD); // weak
int j_HWM_pvg_hsdb_get_lrus_online(void); // weak
int __cdecl j_HWM_pvg_hsdb_get_router_entry(_DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_hsdb_put(_DWORD); // weak
int __cdecl j_HWM_pvg_hsdb_set_sim_lrus_online(_DWORD); // weak
int __cdecl j_HWM_pvg_log_err(_DWORD); // weak
int __cdecl j_HWM_pvg_read_reg(_DWORD); // weak
int sub_1007C870();
int __cdecl sub_1007C890(int a1, int a2);
signed int __cdecl sub_1007C8F0(int a1);
// int __usercall sub_1007C970@<eax>(const char **a1@<esi>);
// int __usercall sub_1007CC70@<eax>(int a1@<eax>, int a2@<ecx>);
signed int __cdecl sub_1007CC90(int a1);
int __cdecl sub_1007CD60(LONG Value); // idb
int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD); // weak
signed int __cdecl sub_1007CE00(unsigned int a1);
int __cdecl j_FIL_vfs_delete(_DWORD); // weak
int j_FIL_vfs_dyn_linker(void); // weak
int __cdecl sub_1007CE60(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_1007CED0(unsigned int a1, void *a2, int a3);
signed int __cdecl sub_1007CF10(unsigned int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD); // weak
signed int __cdecl sub_1007CFA0(unsigned int a1, int a2, int a3, int a4);
__int64 __cdecl sub_1007CFF0(int a1);
int j_FIL_vfs_sync_all(void); // weak
int __cdecl sub_1007D020(int a1, int a2, int a3);
int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
int __cdecl sub_1007D050(int a1, int a2, int a3, char a4);
char __cdecl sub_1007D070(int a1);
signed int __cdecl sub_1007D0A0(unsigned int a1, int a2, int a3);
int __cdecl sub_1007D0C0(int a1, int a2, int a3);
int __cdecl sub_1007D0E0(int a1, int a2);
int __cdecl sub_1007D150(char a1);
void __cdecl sub_1007D180(int a1, _BYTE *a2);
int __cdecl sub_1007D1B0(int a1, int a2);
int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_create_id(_DWORD); // weak
int __cdecl sub_1007D210(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl sub_1007D260(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD); // weak
int __cdecl sub_1007D2D0(int a1);
int __cdecl sub_1007D310(int a1);
int __cdecl sub_1007D350(int a1);
int __cdecl sub_1007D390(int a1);
int __cdecl sub_1007D3D0(int a1, int a2, int a3, int a4);
int __cdecl sub_1007D440(int a1, int a2, int a3);
int sub_1007D4E0(void); // weak
bool sub_1007D4F0();
int __cdecl j_mem_unmap(_DWORD, _DWORD); // weak
unsigned int __cdecl sub_1007D520(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6);
// int __usercall sub_1007D6D0@<eax>(int a1@<esi>);
int __cdecl sub_1007D780(int a1, unsigned __int64 a2);
// int __usercall sub_1007D830@<eax>(int a1@<ebx>, unsigned __int64 a2);
unsigned int __cdecl sub_1007D8C0(int a1, void *a2, int a3, int a4, int a5);
void __cdecl sub_1007DA10(__int16 a1, _BYTE *a2);
// int __cdecl SIM_proc_rqst(_DWORD); weak
// int SYS_exit_krnl(void); weak
// int __cdecl SYS_pvg_is_booting(_DWORD); weak
// int SYS_enter_krnl(void); weak
// int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_get_hdr_text(_DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_id_is_set(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_is_set_queued(_DWORD); weak
// int __cdecl SYS_pvg_alrt_is_set_text(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_crit_lvl(_DWORD); weak
// int TSK_pvg_get_id(void); weak
// int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_run_state(_DWORD); weak
// int TSK_pvg_get_timer(void); weak
// int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_release_smphr(_DWORD); weak
// int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_set_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_suspend(_DWORD); weak
// int __cdecl TSK_pvg_wait_evnt(_DWORD); weak
// int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_read_from_xml(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_close(void); weak
// int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_read(void); weak
// int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_size(_DWORD); weak
// int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD); weak
// void *__cdecl memset(void *, int, size_t);
// int __cdecl strncmp(const char *, const char *, size_t);
// char *__cdecl strncpy(char *, const char *, size_t);
// void *__cdecl memcpy(void *, const void *, size_t);
// void *__cdecl memcpy_0(void *, const void *, size_t);
// char *__cdecl strstr(const char *, const char *);
// char *__cdecl strncat(char *, const char *, size_t);
// int sprintf(char *, const char *, ...);
// int _snprintf(char *, size_t, const char *, ...);
// double __cdecl floor(double);
// _DWORD __thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *); idb
// int __cdecl isdigit(int);
// int __cdecl isxdigit(int);
// int __cdecl isspace(int);
// int __cdecl isprint(int);
// char *__cdecl strchr(const char *, int);
// int __cdecl tolower(int);
// void *__cdecl memchr(const void *, int, size_t);
// int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
// char *__cdecl strrchr(const char *, int);
// int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_10080408(int a1, int a2, char a3);
// char *__cdecl strpbrk(const char *, const char *);
// int *__cdecl _errno();
// unsigned __int32 *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
int __cdecl sub_10081404(int, FILE *); // idb
int __cdecl sub_10081F99(int a1);
// int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
signed int __cdecl sub_1008216C(_DWORD *a1);
signed int __cdecl sub_100821A3(_DWORD *a1);
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
// int _getptd(void); weak
// void __cdecl free(void *);
// _DWORD __cdecl _calloc_crt(size_t, _DWORD); weak
void sub_10082DE9();
int (*sub_10083296())(void);
void __cdecl sub_100832BA(); // idb
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl isleadbyte(int);
// int __cdecl __check_float_string(int, void *, int); idb
// int __fastcall _inc(_DWORD, _DWORD); weak
// _DWORD __cdecl _whiteout(_DWORD); weak
int __cdecl sub_100885EF(FILE *, int, struct localeinfo_struct *, int); // idb
void sub_1008A29B();
// int _get_sse2_info(void); weak
int sub_1008A353();
int __cdecl sub_1008A360(int, int, struct localeinfo_struct *); // idb
int __cdecl sub_1008A406(int, int, struct localeinfo_struct *); // idb
DWORD __cdecl sub_1008A872(int a1, int a2, int a3, DWORD dwMoveMethod);
// __int64 __cdecl _lseeki64(int, __int64, int);
_WORD *__cdecl sub_1008AA0E(int a1, int a2, DWORD nNumberOfBytesToWrite);
_WORD *__cdecl sub_1008B030(int a1, int a2, DWORD nNumberOfBytesToWrite);
// _DWORD __cdecl _getbuf(_DWORD); weak
int __cdecl sub_1008B150(signed int a1);
void **sub_1008B1AE();
signed int sub_1008B1B4();
// int __cdecl _fileno(FILE *);
int sub_1008BA92();
int __cdecl sub_1008BC4F(int a1);
int __cdecl sub_1008BC59(int a1);
int __cdecl sub_1008BC63(int a1);
int __cdecl sub_1008BD42(int a1);
int sub_1008CEC7();
signed int __cdecl sub_1008DE4D(int a1, int a2);
signed int __cdecl sub_1008E38F(int a1, int a2);
int __cdecl sub_1008ECCC(FILE *); // idb
int __cdecl sub_1008EDEC(int, FILE *); // idb
// int __cdecl _mbtowc_l(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes, _locale_t Locale);
// int __cdecl mbtowc(wchar_t *, const char *, size_t);
signed int __cdecl sub_1008FD2B(signed int a1);
signed int __cdecl sub_1008FDAC(signed int a1);
// _DWORD __cdecl __lock_fhandle(_DWORD); weak
void __cdecl sub_1008FEBD(signed int a1);
// int __cdecl _putwch_nolock(__int16 Buffer); idb
// _DWORD __cdecl flsall(_DWORD); weak
int sub_100901BE();
int __cdecl sub_100901C7(int a1, int a2, int a3);
// int __cdecl _read(int, void *, unsigned int);
signed int __cdecl sub_10090FD1(signed int a1);
void __cdecl sub_10091170(float *a1, float *a2, float *a3, int a4);
int __cdecl sub_100911D0(float, float, int); // idb
void __cdecl sub_10091390(int a1, int a2, float *a3, float *a4, float *a5);
void __cdecl sub_10091760(int a1, int a2, float *a3, float *a4);
double __cdecl sub_10091840(float a1);
double __cdecl sub_10091870(float a1, float a2, float a3, float a4, float a5);
double __cdecl sub_100919F0(float a1, float a2, float a3, float a4);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// UINT __stdcall GetConsoleCP();
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall GetLastError();
// LONG __stdcall InterlockedExchange(volatile LONG *Target, LONG Value);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_10003EF0; // weak
_UNKNOWN loc_1000A6E0; // weak
_UNKNOWN loc_10072160; // weak
// extern _UNKNOWN SIM_intf; weak
void *tsk_app_hdr_ptr = &tsk_app_hdr; // weak
char byte_100930C0 = '\0'; // idb
char *off_100939E8 = "Fully-encoded-data"; // weak
char *off_10093E6C = "ACSE-apdu"; // weak
char byte_10093E88[] = { '\x04' }; // weak
char byte_10093E89[] = { '\x01' }; // weak
int dword_1009452C = 455803910; // weak
char *off_10095764 = "CMAircraftMessage"; // weak
char *off_100958F8 = "CMGroundMessage"; // weak
int dword_10095960[] = { 0 }; // weak
int dword_10095964[] = { 0 }; // weak
char *off_1009648C = "ATCDownlinkMessage"; // weak
char *off_100966BC = "ATCUplinkMessage"; // weak
char *off_1009DF88 = "PseudoCPDLCMessage"; // weak
char *off_1009E040 = "AircraftPDUs"; // weak
char *off_1009E128 = "GroundPDUs"; // weak
char byte_1009E578[] = { '\n' }; // weak
char byte_1009E579[] = { '\x01' }; // weak
char word_1009F07C[] = { ' ', '\0' }; // idb
_UNKNOWN unk_1009F0A4; // weak
_UNKNOWN unk_100A031C; // weak
__int16 word_100A031E[] = { 19 }; // weak
_UNKNOWN unk_100A0328; // weak
char byte_100A032C[] = { '\x03' }; // weak
char *off_100A1308 = "/shr_mem/iop_atn_log_intf.shr"; // weak
char *off_100A1418[3] = { "IOP_C_test.c", "$Id$", &off_100A13A0 }; // weak
int (__cdecl *off_100A142C)(int) = &sub_10018440; // weak
char byte_100A3E00[] = { '\b' }; // weak
int (__cdecl *off_100A3E04)(char, int, int) = &sub_1001C6F0; // weak
int (__cdecl *off_100A3E08)(char, int, int, int, int, int) = &sub_1001C870; // weak
int (*off_100A3E0C)() = &sub_1001C920; // weak
int dword_100A3E10[] = { 0 }; // weak
int (*off_100A3E14[2])() = { &sub_1001C360, &sub_1001C460 }; // weak
int (*off_100A3E18)() = &sub_1001C460; // weak
int (__cdecl *off_100A3E1C)(char, char, char, int, int) = &sub_1001C930; // weak
int (__cdecl *off_100A3E20)(char, int, int, int, char, char *) = &sub_1001C680; // weak
int dword_100A3E24[] = { 0 }; // weak
int (*off_100A3E28)() = &sub_1001C6E0; // weak
char *off_100A3FE4 = "/shr_mem/iop_c_cnfg_mngr_intf.shr"; // weak
__int16 word_100A54B8[] = { 31 }; // weak
__int16 word_100A54BE[] = { 1640 }; // weak
__int16 word_100A54C0[] = { 1565 }; // weak
__int16 word_100A54C2[] = { 1566 }; // weak
__int16 word_100A54C4[] = { 534 }; // weak
__int16 word_100A54C6[] = { 535 }; // weak
char byte_100A54C8[] = { '\x04' }; // weak
__int16 word_100A54CA[] = { 6512 }; // weak
int dword_100A54E0[] = { 118000 }; // weak
char byte_100A562C[] = { '\x02' }; // weak
char byte_100A562D[] = { '\x04' }; // weak
char byte_100A562E[] = { '\x03' }; // weak
char byte_100A562F[] = { '\0' }; // weak
char byte_100A5630[] = { '\0' }; // weak
_UNKNOWN unk_100A5B80; // weak
int dword_100A5B84[] = { 73775 }; // weak
_UNKNOWN unk_100A60B8; // weak
_BYTE byte_100A60B9[2525] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  68,
  82,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  82,
  69,
  81,
  85,
  69,
  83,
  84,
  73,
  78,
  71,
  32,
  71,
  68,
  82,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,
  86,
  69,
  82,
  73,
  70,
  89,
  73,
  78,
  71,
  32,
  71,
  68,
  82,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  4,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  68,
  82,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  6,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  68,
  82,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  7,
  71,
  68,
  82,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  8,
  71,
  68,
  82,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  32,
  70,
  65,
  73,
  76,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  9,
  71,
  68,
  82,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  32,
  67,
  65,
  78,
  67,
  69,
  76,
  76,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  10,
  83,
  84,
  79,
  82,
  73,
  78,
  71,
  32,
  71,
  68,
  82,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  74,
  75,
  76,
  77,
  80,
  81,
  82,
  83,
  0,
  0,
  93,
  0,
  90,
  0,
  87,
  0,
  96,
  0,
  1,
  0,
  94,
  0,
  91,
  0,
  88,
  0,
  97,
  0,
  2,
  0,
  95,
  0,
  92,
  0,
  89,
  0,
  98,
  0,
  0,
  0,
  0,
  0,
  226,
  0,
  228,
  0,
  224,
  0,
  1,
  0,
  227,
  0,
  229,
  0,
  225,
  0,
  2,
  0,
  60,
  2,
  61,
  2,
  59,
  2,
  0,
  0,
  220,
  0,
  1,
  0,
  222,
  0,
  2,
  0,
  58,
  2,
  23,
  21,
  3,
  3,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  10,
  18,
  10,
  18,
  10,
  28,
  14,
  29,
  14,
  29,
  14,
  29,
  10,
  29,
  10,
  28,
  10,
  24,
  10,
  24,
  0,
  24,
  0,
  23,
  0,
  22,
  0,
  23,
  0,
  23,
  0,
  23,
  0,
  28,
  0,
  24,
  0,
  22,
  0,
  20,
  10,
  24,
  10,
  18,
  10,
  20,
  10,
  24,
  10,
  13,
  10,
  20,
  10,
  28,
  10,
  18,
  0,
  22,
  0,
  22,
  0,
  20,
  0,
  18,
  10,
  18,
  0,
  28,
  0,
  23,
  0,
  22,
  10,
  28,
  10,
  22,
  10,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  0,
  1,
  0,
  136,
  25,
  0,
  0,
  1,
  0,
  1,
  0,
  137,
  25,
  0,
  0,
  2,
  0,
  1,
  0,
  138,
  25,
  0,
  0,
  4,
  0,
  1,
  0,
  139,
  25,
  0,
  0,
  5,
  0,
  1,
  0,
  140,
  25,
  0,
  0,
  6,
  0,
  1,
  0,
  141,
  25,
  0,
  0,
  18,
  0,
  1,
  0,
  142,
  25,
  0,
  0,
  19,
  0,
  1,
  0,
  143,
  25,
  0,
  0,
  20,
  0,
  1,
  0,
  144,
  25,
  0,
  0,
  21,
  0,
  1,
  0,
  145,
  25,
  0,
  0,
  22,
  0,
  1,
  0,
  146,
  25,
  0,
  0,
  23,
  0,
  1,
  0,
  147,
  25,
  0,
  0,
  25,
  0,
  1,
  0,
  148,
  25,
  0,
  0,
  26,
  0,
  1,
  0,
  149,
  25,
  0,
  0,
  27,
  0,
  1,
  0,
  150,
  25,
  0,
  0,
  28,
  0,
  1,
  0,
  151,
  25,
  0,
  0,
  29,
  0,
  1,
  0,
  152,
  25,
  0,
  0,
  30,
  0,
  1,
  0,
  153,
  25,
  0,
  0,
  31,
  0,
  1,
  0,
  154,
  25,
  0,
  0,
  32,
  0,
  4,
  0,
  155,
  25,
  0,
  0,
  36,
  0,
  4,
  0,
  156,
  25,
  0,
  0,
  40,
  0,
  1,
  0,
  157,
  25,
  0,
  0,
  41,
  0,
  1,
  0,
  158,
  25,
  0,
  0,
  42,
  0,
  1,
  0,
  159,
  25,
  0,
  0,
  43,
  0,
  1,
  0,
  160,
  25,
  0,
  0,
  44,
  0,
  1,
  0,
  161,
  25,
  0,
  0,
  45,
  0,
  1,
  0,
  162,
  25,
  0,
  0,
  46,
  0,
  1,
  0,
  163,
  25,
  0,
  0,
  47,
  0,
  1,
  0,
  164,
  25,
  0,
  0,
  49,
  0,
  1,
  0,
  166,
  25,
  0,
  0,
  50,
  0,
  30,
  0,
  167,
  25,
  0,
  0,
  80,
  0,
  1,
  0,
  168,
  25,
  0,
  0,
  81,
  0,
  1,
  0,
  169,
  25,
  0,
  0,
  84,
  0,
  4,
  0,
  170,
  25,
  0,
  0,
  88,
  0,
  1,
  0,
  171,
  25,
  0,
  0,
  89,
  0,
  1,
  0,
  172,
  25,
  0,
  0,
  92,
  0,
  4,
  0,
  173,
  25,
  0,
  0,
  96,
  0,
  4,
  0,
  174,
  25,
  0,
  0,
  100,
  0,
  1,
  0,
  175,
  25,
  0,
  0,
  208,
  0,
  4,
  0,
  168,
  23,
  0,
  0,
  104,
  0,
  1,
  0,
  177,
  25,
  0,
  0,
  105,
  0,
  1,
  0,
  178,
  25,
  0,
  0,
  106,
  0,
  1,
  0,
  179,
  25,
  0,
  0,
  107,
  0,
  1,
  0,
  180,
  25,
  0,
  0,
  108,
  0,
  1,
  0,
  181,
  25,
  0,
  0,
  109,
  0,
  1,
  0,
  182,
  25,
  0,
  0,
  110,
  0,
  1,
  0,
  183,
  25,
  0,
  0,
  111,
  0,
  1,
  0,
  184,
  25,
  0,
  0,
  112,
  0,
  1,
  0,
  185,
  25,
  0,
  0,
  113,
  0,
  1,
  0,
  186,
  25,
  0,
  0,
  114,
  0,
  1,
  0,
  187,
  25,
  0,
  0,
  115,
  0,
  1,
  0,
  188,
  25,
  0,
  0,
  116,
  0,
  1,
  0,
  189,
  25,
  0,
  0,
  117,
  0,
  1,
  0,
  190,
  25,
  0,
  0,
  118,
  0,
  1,
  0,
  191,
  25,
  0,
  0,
  120,
  0,
  4,
  0,
  192,
  25,
  0,
  0,
  124,
  0,
  4,
  0,
  193,
  25,
  0,
  0,
  128,
  0,
  4,
  0,
  194,
  25,
  0,
  0,
  132,
  0,
  4,
  0,
  195,
  25,
  0,
  0,
  136,
  0,
  4,
  0,
  196,
  25,
  0,
  0,
  140,
  0,
  1,
  0,
  197,
  25,
  0,
  0,
  141,
  0,
  1,
  0,
  198,
  25,
  0,
  0,
  142,
  0,
  1,
  0,
  199,
  25,
  0,
  0,
  144,
  0,
  2,
  0,
  200,
  25,
  0,
  0,
  146,
  0,
  1,
  0,
  201,
  25,
  0,
  0,
  147,
  0,
  1,
  0,
  202,
  25,
  0,
  0,
  148,
  0,
  1,
  0,
  203,
  25,
  0,
  0,
  149,
  0,
  1,
  0,
  204,
  25,
  0,
  0,
  150,
  0,
  1,
  0,
  205,
  25,
  0,
  0,
  151,
  0,
  1,
  0,
  206,
  25,
  0,
  0,
  152,
  0,
  1,
  0,
  207,
  25,
  0,
  0,
  153,
  0,
  1,
  0,
  208,
  25,
  0,
  0,
  154,
  0,
  1,
  0,
  209,
  25,
  0,
  0,
  155,
  0,
  1,
  0,
  210,
  25,
  0,
  0,
  156,
  0,
  1,
  0,
  211,
  25,
  0,
  0,
  157,
  0,
  1,
  0,
  212,
  25,
  0,
  0,
  158,
  0,
  1,
  0,
  213,
  25,
  0,
  0,
  159,
  0,
  1,
  0,
  214,
  25,
  0,
  0,
  160,
  0,
  1,
  0,
  215,
  25,
  0,
  0,
  161,
  0,
  1,
  0,
  216,
  25,
  0,
  0,
  162,
  0,
  1,
  0,
  217,
  25,
  0,
  0,
  163,
  0,
  1,
  0,
  218,
  25,
  0,
  0,
  164,
  0,
  1,
  0,
  219,
  25,
  0,
  0,
  165,
  0,
  1,
  0,
  220,
  25,
  0,
  0,
  166,
  0,
  1,
  0,
  221,
  25,
  0,
  0,
  167,
  0,
  1,
  0,
  222,
  25,
  0,
  0,
  168,
  0,
  1,
  0,
  223,
  25,
  0,
  0,
  169,
  0,
  1,
  0,
  224,
  25,
  0,
  0,
  170,
  0,
  1,
  0,
  225,
  25,
  0,
  0,
  171,
  0,
  1,
  0,
  226,
  25,
  0,
  0,
  172,
  0,
  1,
  0,
  227,
  25,
  0,
  0,
  173,
  0,
  1,
  0,
  228,
  25,
  0,
  0,
  174,
  0,
  1,
  0,
  229,
  25,
  0,
  0,
  177,
  0,
  1,
  0,
  231,
  25,
  0,
  0,
  178,
  0,
  1,
  0,
  232,
  25,
  0,
  0,
  179,
  0,
  1,
  0,
  233,
  25,
  0,
  0,
  180,
  0,
  1,
  0,
  234,
  25,
  0,
  0,
  181,
  0,
  1,
  0,
  235,
  25,
  0,
  0,
  182,
  0,
  5,
  0,
  236,
  25,
  0,
  0,
  187,
  0,
  1,
  0,
  237,
  25,
  0,
  0,
  188,
  0,
  1,
  0,
  238,
  25,
  0,
  0,
  189,
  0,
  1,
  0,
  239,
  25,
  0,
  0,
  190,
  0,
  1,
  0,
  240,
  25,
  0,
  0,
  191,
  0,
  1,
  0,
  241,
  25,
  0,
  0,
  192,
  0,
  1,
  0,
  242,
  25,
  0,
  0,
  193,
  0,
  1,
  0,
  243,
  25,
  0,
  0,
  194,
  0,
  1,
  0,
  244,
  25,
  0,
  0,
  195,
  0,
  1,
  0,
  245,
  25,
  0,
  0,
  196,
  0,
  1,
  0,
  246,
  25,
  0,
  0,
  197,
  0,
  1,
  0,
  28,
  26,
  0,
  0,
  198,
  0,
  1,
  0,
  29,
  26,
  0,
  0,
  199,
  0,
  1,
  0,
  30,
  26,
  0,
  0,
  200,
  0,
  1,
  0,
  117,
  26,
  0,
  0,
  201,
  0,
  1,
  0,
  118,
  26,
  0,
  0,
  202,
  0,
  1,
  0,
  124,
  26,
  0,
  0,
  203,
  0,
  1,
  0,
  144,
  26,
  0,
  0,
  204,
  0,
  1,
  0,
  145,
  26,
  0,
  0,
  205,
  0,
  1,
  0,
  30,
  27,
  0,
  0,
  206,
  0,
  1,
  0,
  149,
  26,
  0,
  0,
  32,
  0,
  0,
  0,
  150,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  167,
  26,
  0,
  0,
  4,
  0,
  0,
  0,
  168,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  169,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  170,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  171,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  172,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  176,
  26,
  0,
  0,
  13,
  0,
  0,
  0,
  241,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  244,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  247,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  248,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  249,
  26,
  0,
  0,
  13,
  0,
  0,
  0,
  29,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  40,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  39,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  47,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  49,
  27,
  0,
  0,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  74,
  75,
  76,
  77,
  80,
  81,
  82,
  83,
  0,
  0,
  93,
  0,
  90,
  0,
  87,
  0,
  96,
  0,
  1,
  0,
  94,
  0,
  91,
  0,
  88,
  0,
  97,
  0,
  2,
  0,
  95,
  0,
  92,
  0,
  89,
  0,
  98,
  0,
  0,
  0,
  0,
  0,
  226,
  0,
  228,
  0,
  224,
  0,
  1,
  0,
  227,
  0,
  229,
  0,
  225,
  0,
  2,
  0,
  60,
  2,
  61,
  2,
  59,
  2,
  0,
  0,
  220,
  0,
  1,
  0,
  222,
  0,
  2,
  0,
  58,
  2,
  23,
  21,
  3,
  3,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  10,
  18,
  10,
  18,
  10,
  28,
  14,
  29,
  14,
  29,
  14,
  29,
  10,
  29,
  10,
  28,
  10,
  24,
  10,
  24,
  0,
  24,
  0,
  23,
  0,
  22,
  0,
  23,
  0,
  23,
  0,
  23,
  0,
  28,
  0,
  24,
  0,
  22,
  0,
  20,
  10,
  24,
  10,
  18,
  10,
  20,
  10,
  24,
  10,
  13,
  10,
  20,
  10,
  28,
  10,
  18,
  0,
  22,
  0,
  22,
  0,
  20,
  0,
  18,
  10,
  18,
  0,
  28,
  0,
  23,
  0,
  22,
  10,
  28,
  10,
  22,
  10,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28
}; // idb
_UNKNOWN unk_100A6AB8; // weak
char byte_100A6AB9[2010] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'M',
  'A',
  ' ',
  '#',
  '1',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'M',
  'A',
  ' ',
  '#',
  '2',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x02',
  'R',
  'E',
  'Q',
  'U',
  'E',
  'S',
  'T',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'M',
  'A',
  ' ',
  '#',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'R',
  'E',
  'Q',
  'U',
  'E',
  'S',
  'T',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'M',
  'A',
  ' ',
  '#',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x03',
  'V',
  'E',
  'R',
  'I',
  'F',
  'Y',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'M',
  'A',
  ' ',
  '#',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'V',
  'E',
  'R',
  'I',
  'F',
  'Y',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'M',
  'A',
  ' ',
  '#',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x04',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'M',
  'A',
  ' ',
  '#',
  '1',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'M',
  'A',
  ' ',
  '#',
  '2',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'M',
  'A',
  ' ',
  '#',
  '1',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'M',
  'A',
  ' ',
  '#',
  '2',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\a',
  'G',
  'M',
  'A',
  ' ',
  '#',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'M',
  'A',
  ' ',
  '#',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  'G',
  'M',
  'A',
  ' ',
  '#',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'F',
  'A',
  'I',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'M',
  'A',
  ' ',
  '#',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'F',
  'A',
  'I',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\t',
  'G',
  'M',
  'A',
  ' ',
  '#',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'C',
  'A',
  'N',
  'C',
  'E',
  'L',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'M',
  'A',
  ' ',
  '#',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'C',
  'A',
  'N',
  'C',
  'E',
  'L',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\n',
  'S',
  'T',
  'O',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'M',
  'A',
  ' ',
  '#',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'S',
  'T',
  'O',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'M',
  'A',
  ' ',
  '#',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char *off_100A7800 = "/shr_mem/iop_gma_dig_intf.shr"; // weak
_UNKNOWN unk_100A781C; // weak
int dword_100A7820[] = { 115332 }; // weak
int dword_100A7824[] = { 36 }; // weak
_UNKNOWN unk_100A7EC8; // weak
_BYTE byte_100A7EC9[3417] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  77,
  65,
  32,
  35,
  49,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  77,
  65,
  32,
  35,
  50,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  82,
  69,
  81,
  85,
  69,
  83,
  84,
  73,
  78,
  71,
  32,
  71,
  77,
  65,
  32,
  35,
  49,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  82,
  69,
  81,
  85,
  69,
  83,
  84,
  73,
  78,
  71,
  32,
  71,
  77,
  65,
  32,
  35,
  50,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,
  86,
  69,
  82,
  73,
  70,
  89,
  73,
  78,
  71,
  32,
  71,
  77,
  65,
  32,
  35,
  49,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  86,
  69,
  82,
  73,
  70,
  89,
  73,
  78,
  71,
  32,
  71,
  77,
  65,
  32,
  35,
  50,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  4,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  77,
  65,
  32,
  35,
  49,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  77,
  65,
  32,
  35,
  50,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  6,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  77,
  65,
  32,
  35,
  49,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  77,
  65,
  32,
  35,
  50,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  7,
  71,
  77,
  65,
  32,
  35,
  49,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  71,
  77,
  65,
  32,
  35,
  50,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  8,
  71,
  77,
  65,
  32,
  35,
  49,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  32,
  70,
  65,
  73,
  76,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  71,
  77,
  65,
  32,
  35,
  50,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  32,
  70,
  65,
  73,
  76,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  9,
  71,
  77,
  65,
  32,
  35,
  49,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  32,
  67,
  65,
  78,
  67,
  69,
  76,
  76,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  71,
  77,
  65,
  32,
  35,
  50,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  32,
  67,
  65,
  78,
  67,
  69,
  76,
  76,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  10,
  83,
  84,
  79,
  82,
  73,
  78,
  71,
  32,
  71,
  77,
  65,
  32,
  35,
  49,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  83,
  84,
  79,
  82,
  73,
  78,
  71,
  32,
  71,
  77,
  65,
  32,
  35,
  50,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  74,
  75,
  76,
  77,
  80,
  81,
  82,
  83,
  0,
  0,
  93,
  0,
  90,
  0,
  87,
  0,
  96,
  0,
  1,
  0,
  94,
  0,
  91,
  0,
  88,
  0,
  97,
  0,
  2,
  0,
  95,
  0,
  92,
  0,
  89,
  0,
  98,
  0,
  0,
  0,
  0,
  0,
  226,
  0,
  228,
  0,
  224,
  0,
  1,
  0,
  227,
  0,
  229,
  0,
  225,
  0,
  2,
  0,
  60,
  2,
  61,
  2,
  59,
  2,
  0,
  0,
  220,
  0,
  1,
  0,
  222,
  0,
  2,
  0,
  58,
  2,
  23,
  21,
  3,
  3,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  10,
  18,
  10,
  18,
  10,
  28,
  14,
  29,
  14,
  29,
  14,
  29,
  10,
  29,
  10,
  28,
  10,
  24,
  10,
  24,
  0,
  24,
  0,
  23,
  0,
  22,
  0,
  23,
  0,
  23,
  0,
  23,
  0,
  28,
  0,
  24,
  0,
  22,
  0,
  20,
  10,
  24,
  10,
  18,
  10,
  20,
  10,
  24,
  10,
  13,
  10,
  20,
  10,
  28,
  10,
  18,
  0,
  22,
  0,
  22,
  0,
  20,
  0,
  18,
  10,
  18,
  0,
  28,
  0,
  23,
  0,
  22,
  10,
  28,
  10,
  22,
  10,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  74,
  75,
  76,
  77,
  80,
  81,
  82,
  83,
  0,
  0,
  93,
  0,
  90,
  0,
  87,
  0,
  96,
  0,
  1,
  0,
  94,
  0,
  91,
  0,
  88,
  0,
  97,
  0,
  2,
  0,
  95,
  0,
  92,
  0,
  89,
  0,
  98,
  0,
  0,
  0,
  0,
  0,
  226,
  0,
  228,
  0,
  224,
  0,
  1,
  0,
  227,
  0,
  229,
  0,
  225,
  0,
  2,
  0,
  60,
  2,
  61,
  2,
  59,
  2,
  0,
  0,
  220,
  0,
  1,
  0,
  222,
  0,
  2,
  0,
  58,
  2,
  23,
  21,
  3,
  3,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  10,
  18,
  10,
  18,
  10,
  28,
  14,
  29,
  14,
  29,
  14,
  29,
  10,
  29,
  10,
  28,
  10,
  24,
  10,
  24,
  0,
  24,
  0,
  23,
  0,
  22,
  0,
  23,
  0,
  23,
  0,
  23,
  0,
  28,
  0,
  24,
  0,
  22,
  0,
  20,
  10,
  24,
  10,
  18,
  10,
  20,
  10,
  24,
  10,
  13,
  10,
  20,
  10,
  28,
  10,
  18,
  0,
  22,
  0,
  22,
  0,
  20,
  0,
  18,
  10,
  18,
  0,
  28,
  0,
  23,
  0,
  22,
  10,
  28,
  10,
  22,
  10,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  0,
  1,
  0,
  136,
  25,
  0,
  0,
  1,
  0,
  1,
  0,
  137,
  25,
  0,
  0,
  2,
  0,
  1,
  0,
  138,
  25,
  0,
  0,
  4,
  0,
  1,
  0,
  139,
  25,
  0,
  0,
  5,
  0,
  1,
  0,
  140,
  25,
  0,
  0,
  6,
  0,
  1,
  0,
  141,
  25,
  0,
  0,
  18,
  0,
  1,
  0,
  142,
  25,
  0,
  0,
  19,
  0,
  1,
  0,
  143,
  25,
  0,
  0,
  20,
  0,
  1,
  0,
  144,
  25,
  0,
  0,
  21,
  0,
  1,
  0,
  145,
  25,
  0,
  0,
  22,
  0,
  1,
  0,
  146,
  25,
  0,
  0,
  23,
  0,
  1,
  0,
  147,
  25,
  0,
  0,
  25,
  0,
  1,
  0,
  148,
  25,
  0,
  0,
  26,
  0,
  1,
  0,
  149,
  25,
  0,
  0,
  27,
  0,
  1,
  0,
  150,
  25,
  0,
  0,
  28,
  0,
  1,
  0,
  151,
  25,
  0,
  0,
  29,
  0,
  1,
  0,
  152,
  25,
  0,
  0,
  30,
  0,
  1,
  0,
  153,
  25,
  0,
  0,
  31,
  0,
  1,
  0,
  154,
  25,
  0,
  0,
  32,
  0,
  4,
  0,
  155,
  25,
  0,
  0,
  36,
  0,
  4,
  0,
  156,
  25,
  0,
  0,
  40,
  0,
  1,
  0,
  157,
  25,
  0,
  0,
  41,
  0,
  1,
  0,
  158,
  25,
  0,
  0,
  42,
  0,
  1,
  0,
  159,
  25,
  0,
  0,
  43,
  0,
  1,
  0,
  160,
  25,
  0,
  0,
  44,
  0,
  1,
  0,
  161,
  25,
  0,
  0,
  45,
  0,
  1,
  0,
  162,
  25,
  0,
  0,
  46,
  0,
  1,
  0,
  163,
  25,
  0,
  0,
  47,
  0,
  1,
  0,
  164,
  25,
  0,
  0,
  49,
  0,
  1,
  0,
  166,
  25,
  0,
  0,
  50,
  0,
  30,
  0,
  167,
  25,
  0,
  0,
  80,
  0,
  1,
  0,
  168,
  25,
  0,
  0,
  81,
  0,
  1,
  0,
  169,
  25,
  0,
  0,
  84,
  0,
  4,
  0,
  170,
  25,
  0,
  0,
  88,
  0,
  1,
  0,
  171,
  25,
  0,
  0,
  89,
  0,
  1,
  0,
  172,
  25,
  0,
  0,
  92,
  0,
  4,
  0,
  173,
  25,
  0,
  0,
  96,
  0,
  4,
  0,
  174,
  25,
  0,
  0,
  100,
  0,
  1,
  0,
  175,
  25,
  0,
  0,
  208,
  0,
  4,
  0,
  168,
  23,
  0,
  0,
  104,
  0,
  1,
  0,
  177,
  25,
  0,
  0,
  105,
  0,
  1,
  0,
  178,
  25,
  0,
  0,
  106,
  0,
  1,
  0,
  179,
  25,
  0,
  0,
  107,
  0,
  1,
  0,
  180,
  25,
  0,
  0,
  108,
  0,
  1,
  0,
  181,
  25,
  0,
  0,
  109,
  0,
  1,
  0,
  182,
  25,
  0,
  0,
  110,
  0,
  1,
  0,
  183,
  25,
  0,
  0,
  111,
  0,
  1,
  0,
  184,
  25,
  0,
  0,
  112,
  0,
  1,
  0,
  185,
  25,
  0,
  0,
  113,
  0,
  1,
  0,
  186,
  25,
  0,
  0,
  114,
  0,
  1,
  0,
  187,
  25,
  0,
  0,
  115,
  0,
  1,
  0,
  188,
  25,
  0,
  0,
  116,
  0,
  1,
  0,
  189,
  25,
  0,
  0,
  117,
  0,
  1,
  0,
  190,
  25,
  0,
  0,
  118,
  0,
  1,
  0,
  191,
  25,
  0,
  0,
  120,
  0,
  4,
  0,
  192,
  25,
  0,
  0,
  124,
  0,
  4,
  0,
  193,
  25,
  0,
  0,
  128,
  0,
  4,
  0,
  194,
  25,
  0,
  0,
  132,
  0,
  4,
  0,
  195,
  25,
  0,
  0,
  136,
  0,
  4,
  0,
  196,
  25,
  0,
  0,
  140,
  0,
  1,
  0,
  197,
  25,
  0,
  0,
  141,
  0,
  1,
  0,
  198,
  25,
  0,
  0,
  142,
  0,
  1,
  0,
  199,
  25,
  0,
  0,
  144,
  0,
  2,
  0,
  200,
  25,
  0,
  0,
  146,
  0,
  1,
  0,
  201,
  25,
  0,
  0,
  147,
  0,
  1,
  0,
  202,
  25,
  0,
  0,
  148,
  0,
  1,
  0,
  203,
  25,
  0,
  0,
  149,
  0,
  1,
  0,
  204,
  25,
  0,
  0,
  150,
  0,
  1,
  0,
  205,
  25,
  0,
  0,
  151,
  0,
  1,
  0,
  206,
  25,
  0,
  0,
  152,
  0,
  1,
  0,
  207,
  25,
  0,
  0,
  153,
  0,
  1,
  0,
  208,
  25,
  0,
  0,
  154,
  0,
  1,
  0,
  209,
  25,
  0,
  0,
  155,
  0,
  1,
  0,
  210,
  25,
  0,
  0,
  156,
  0,
  1,
  0,
  211,
  25,
  0,
  0,
  157,
  0,
  1,
  0,
  212,
  25,
  0,
  0,
  158,
  0,
  1,
  0,
  213,
  25,
  0,
  0,
  159,
  0,
  1,
  0,
  214,
  25,
  0,
  0,
  160,
  0,
  1,
  0,
  215,
  25,
  0,
  0,
  161,
  0,
  1,
  0,
  216,
  25,
  0,
  0,
  162,
  0,
  1,
  0,
  217,
  25,
  0,
  0,
  163,
  0,
  1,
  0,
  218,
  25,
  0,
  0,
  164,
  0,
  1,
  0,
  219,
  25,
  0,
  0,
  165,
  0,
  1,
  0,
  220,
  25,
  0,
  0,
  166,
  0,
  1,
  0,
  221,
  25,
  0,
  0,
  167,
  0,
  1,
  0,
  222,
  25,
  0,
  0,
  168,
  0,
  1,
  0,
  223,
  25,
  0,
  0,
  169,
  0,
  1,
  0,
  224,
  25,
  0,
  0,
  170,
  0,
  1,
  0,
  225,
  25,
  0,
  0,
  171,
  0,
  1,
  0,
  226,
  25,
  0,
  0,
  172,
  0,
  1,
  0,
  227,
  25,
  0,
  0,
  173,
  0,
  1,
  0,
  228,
  25,
  0,
  0,
  174,
  0,
  1,
  0,
  229,
  25,
  0,
  0,
  177,
  0,
  1,
  0,
  231,
  25,
  0,
  0,
  178,
  0,
  1,
  0,
  232,
  25,
  0,
  0,
  179,
  0,
  1,
  0,
  233,
  25,
  0,
  0,
  180,
  0,
  1,
  0,
  234,
  25,
  0,
  0,
  181,
  0,
  1,
  0,
  235,
  25,
  0,
  0,
  182,
  0,
  5,
  0,
  236,
  25,
  0,
  0,
  187,
  0,
  1,
  0,
  237,
  25,
  0,
  0,
  188,
  0,
  1,
  0,
  238,
  25,
  0,
  0,
  189,
  0,
  1,
  0,
  239,
  25,
  0,
  0,
  190,
  0,
  1,
  0,
  240,
  25,
  0,
  0,
  191,
  0,
  1,
  0,
  241,
  25,
  0,
  0,
  192,
  0,
  1,
  0,
  242,
  25,
  0,
  0,
  193,
  0,
  1,
  0,
  243,
  25,
  0,
  0,
  194,
  0,
  1,
  0,
  244,
  25,
  0,
  0,
  195,
  0,
  1,
  0,
  245,
  25,
  0,
  0,
  196,
  0,
  1,
  0,
  246,
  25,
  0,
  0,
  197,
  0,
  1,
  0,
  28,
  26,
  0,
  0,
  198,
  0,
  1,
  0,
  29,
  26,
  0,
  0,
  199,
  0,
  1,
  0,
  30,
  26,
  0,
  0,
  200,
  0,
  1,
  0,
  117,
  26,
  0,
  0,
  201,
  0,
  1,
  0,
  118,
  26,
  0,
  0,
  202,
  0,
  1,
  0,
  124,
  26,
  0,
  0,
  203,
  0,
  1,
  0,
  144,
  26,
  0,
  0,
  204,
  0,
  1,
  0,
  145,
  26,
  0,
  0,
  205,
  0,
  1,
  0,
  30,
  27,
  0,
  0,
  206,
  0,
  1,
  0,
  149,
  26,
  0,
  0,
  32,
  0
}; // idb
__int16 word_100A8CB0[] = { 51 }; // weak
__int16 word_100A8CB4[] = { 52 }; // weak
_UNKNOWN unk_100A8CB8; // weak
_UNKNOWN unk_100AA080; // weak
_BYTE byte_100AA081[2323] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  84,
  83,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  82,
  69,
  81,
  85,
  69,
  83,
  84,
  73,
  78,
  71,
  32,
  71,
  84,
  83,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,
  86,
  69,
  82,
  73,
  70,
  89,
  73,
  78,
  71,
  32,
  71,
  84,
  83,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  4,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  84,
  83,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  6,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  84,
  83,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  7,
  71,
  84,
  83,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  8,
  71,
  84,
  83,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  32,
  70,
  65,
  73,
  76,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  9,
  71,
  84,
  83,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  32,
  67,
  65,
  78,
  67,
  69,
  76,
  76,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  10,
  83,
  84,
  79,
  82,
  73,
  78,
  71,
  32,
  71,
  84,
  83,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  74,
  75,
  76,
  77,
  80,
  81,
  82,
  83,
  0,
  0,
  93,
  0,
  90,
  0,
  87,
  0,
  96,
  0,
  1,
  0,
  94,
  0,
  91,
  0,
  88,
  0,
  97,
  0,
  2,
  0,
  95,
  0,
  92,
  0,
  89,
  0,
  98,
  0,
  0,
  0,
  0,
  0,
  226,
  0,
  228,
  0,
  224,
  0,
  1,
  0,
  227,
  0,
  229,
  0,
  225,
  0,
  2,
  0,
  60,
  2,
  61,
  2,
  59,
  2,
  0,
  0,
  220,
  0,
  1,
  0,
  222,
  0,
  2,
  0,
  58,
  2,
  23,
  21,
  3,
  3,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  10,
  18,
  10,
  18,
  10,
  28,
  14,
  29,
  14,
  29,
  14,
  29,
  10,
  29,
  10,
  28,
  10,
  24,
  10,
  24,
  0,
  24,
  0,
  23,
  0,
  22,
  0,
  23,
  0,
  23,
  0,
  23,
  0,
  28,
  0,
  24,
  0,
  22,
  0,
  20,
  10,
  24,
  10,
  18,
  10,
  20,
  10,
  24,
  10,
  13,
  10,
  20,
  10,
  28,
  10,
  18,
  0,
  22,
  0,
  22,
  0,
  20,
  0,
  18,
  10,
  18,
  0,
  28,
  0,
  23,
  0,
  22,
  10,
  28,
  10,
  22,
  10,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  0,
  1,
  0,
  136,
  25,
  0,
  0,
  1,
  0,
  1,
  0,
  137,
  25,
  0,
  0,
  2,
  0,
  1,
  0,
  138,
  25,
  0,
  0,
  4,
  0,
  1,
  0,
  139,
  25,
  0,
  0,
  5,
  0,
  1,
  0,
  140,
  25,
  0,
  0,
  6,
  0,
  1,
  0,
  141,
  25,
  0,
  0,
  18,
  0,
  1,
  0,
  142,
  25,
  0,
  0,
  19,
  0,
  1,
  0,
  143,
  25,
  0,
  0,
  20,
  0,
  1,
  0,
  144,
  25,
  0,
  0,
  21,
  0,
  1,
  0,
  145,
  25,
  0,
  0,
  22,
  0,
  1,
  0,
  146,
  25,
  0,
  0,
  23,
  0,
  1,
  0,
  147,
  25,
  0,
  0,
  25,
  0,
  1,
  0,
  148,
  25,
  0,
  0,
  26,
  0,
  1,
  0,
  149,
  25,
  0,
  0,
  27,
  0,
  1,
  0,
  150,
  25,
  0,
  0,
  28,
  0,
  1,
  0,
  151,
  25,
  0,
  0,
  29,
  0,
  1,
  0,
  152,
  25,
  0,
  0,
  30,
  0,
  1,
  0,
  153,
  25,
  0,
  0,
  31,
  0,
  1,
  0,
  154,
  25,
  0,
  0,
  32,
  0,
  4,
  0,
  155,
  25,
  0,
  0,
  36,
  0,
  4,
  0,
  156,
  25,
  0,
  0,
  40,
  0,
  1,
  0,
  157,
  25,
  0,
  0,
  41,
  0,
  1,
  0,
  158,
  25,
  0,
  0,
  42,
  0,
  1,
  0,
  159,
  25,
  0,
  0,
  43,
  0,
  1,
  0,
  160,
  25,
  0,
  0,
  44,
  0,
  1,
  0,
  161,
  25,
  0,
  0,
  45,
  0,
  1,
  0,
  162,
  25,
  0,
  0,
  46,
  0,
  1,
  0,
  163,
  25,
  0,
  0,
  47,
  0,
  1,
  0,
  164,
  25,
  0,
  0,
  49,
  0,
  1,
  0,
  166,
  25,
  0,
  0,
  50,
  0,
  30,
  0,
  167,
  25,
  0,
  0,
  80,
  0,
  1,
  0,
  168,
  25,
  0,
  0,
  81,
  0,
  1,
  0,
  169,
  25,
  0,
  0,
  84,
  0,
  4,
  0,
  170,
  25,
  0,
  0,
  88,
  0,
  1,
  0,
  171,
  25,
  0,
  0,
  89,
  0,
  1,
  0,
  172,
  25,
  0,
  0,
  92,
  0,
  4,
  0,
  173,
  25,
  0,
  0,
  96,
  0,
  4,
  0,
  174,
  25,
  0,
  0,
  100,
  0,
  1,
  0,
  175,
  25,
  0,
  0,
  208,
  0,
  4,
  0,
  168,
  23,
  0,
  0,
  104,
  0,
  1,
  0,
  177,
  25,
  0,
  0,
  105,
  0,
  1,
  0,
  178,
  25,
  0,
  0,
  106,
  0,
  1,
  0,
  179,
  25,
  0,
  0,
  107,
  0,
  1,
  0,
  180,
  25,
  0,
  0,
  108,
  0,
  1,
  0,
  181,
  25,
  0,
  0,
  109,
  0,
  1,
  0,
  182,
  25,
  0,
  0,
  110,
  0,
  1,
  0,
  183,
  25,
  0,
  0,
  111,
  0,
  1,
  0,
  184,
  25,
  0,
  0,
  112,
  0,
  1,
  0,
  185,
  25,
  0,
  0,
  113,
  0,
  1,
  0,
  186,
  25,
  0,
  0,
  114,
  0,
  1,
  0,
  187,
  25,
  0,
  0,
  115,
  0,
  1,
  0,
  188,
  25,
  0,
  0,
  116,
  0,
  1,
  0,
  189,
  25,
  0,
  0,
  117,
  0,
  1,
  0,
  190,
  25,
  0,
  0,
  118,
  0,
  1,
  0,
  191,
  25,
  0,
  0,
  120,
  0,
  4,
  0,
  192,
  25,
  0,
  0,
  124,
  0,
  4,
  0,
  193,
  25,
  0,
  0,
  128,
  0,
  4,
  0,
  194,
  25,
  0,
  0,
  132,
  0,
  4,
  0,
  195,
  25,
  0,
  0,
  136,
  0,
  4,
  0,
  196,
  25,
  0,
  0,
  140,
  0,
  1,
  0,
  197,
  25,
  0,
  0,
  141,
  0,
  1,
  0,
  198,
  25,
  0,
  0,
  142,
  0,
  1,
  0,
  199,
  25,
  0,
  0,
  144,
  0,
  2,
  0,
  200,
  25,
  0,
  0,
  146,
  0,
  1,
  0,
  201,
  25,
  0,
  0,
  147,
  0,
  1,
  0,
  202,
  25,
  0,
  0,
  148,
  0,
  1,
  0,
  203,
  25,
  0,
  0,
  149,
  0,
  1,
  0,
  204,
  25,
  0,
  0,
  150,
  0,
  1,
  0,
  205,
  25,
  0,
  0,
  151,
  0,
  1,
  0,
  206,
  25,
  0,
  0,
  152,
  0,
  1,
  0,
  207,
  25,
  0,
  0,
  153,
  0,
  1,
  0,
  208,
  25,
  0,
  0,
  154,
  0,
  1,
  0,
  209,
  25,
  0,
  0,
  155,
  0,
  1,
  0,
  210,
  25,
  0,
  0,
  156,
  0,
  1,
  0,
  211,
  25,
  0,
  0,
  157,
  0,
  1,
  0,
  212,
  25,
  0,
  0,
  158,
  0,
  1,
  0,
  213,
  25,
  0,
  0,
  159,
  0,
  1,
  0,
  214,
  25,
  0,
  0,
  160,
  0,
  1,
  0,
  215,
  25,
  0,
  0,
  161,
  0,
  1,
  0,
  216,
  25,
  0,
  0,
  162,
  0,
  1,
  0,
  217,
  25,
  0,
  0,
  163,
  0,
  1,
  0,
  218,
  25,
  0,
  0,
  164,
  0,
  1,
  0,
  219,
  25,
  0,
  0,
  165,
  0,
  1,
  0,
  220,
  25,
  0,
  0,
  166,
  0,
  1,
  0,
  221,
  25,
  0,
  0,
  167,
  0,
  1,
  0,
  222,
  25,
  0,
  0,
  168,
  0,
  1,
  0,
  223,
  25,
  0,
  0,
  169,
  0,
  1,
  0,
  224,
  25,
  0,
  0,
  170,
  0,
  1,
  0,
  225,
  25,
  0,
  0,
  171,
  0,
  1,
  0,
  226,
  25,
  0,
  0,
  172,
  0,
  1,
  0,
  227,
  25,
  0,
  0,
  173,
  0,
  1,
  0,
  228,
  25,
  0,
  0,
  174,
  0,
  1,
  0,
  229,
  25,
  0,
  0,
  177,
  0,
  1,
  0,
  231,
  25,
  0,
  0,
  178,
  0,
  1,
  0,
  232,
  25,
  0,
  0,
  179,
  0,
  1,
  0,
  233,
  25,
  0,
  0,
  180,
  0,
  1,
  0,
  234,
  25,
  0,
  0,
  181,
  0,
  1,
  0,
  235,
  25,
  0,
  0,
  182,
  0,
  5,
  0,
  236,
  25,
  0,
  0,
  187,
  0,
  1,
  0,
  237,
  25,
  0,
  0,
  188,
  0,
  1,
  0,
  238,
  25,
  0,
  0,
  189,
  0,
  1,
  0,
  239,
  25,
  0,
  0,
  190,
  0,
  1,
  0,
  240,
  25,
  0,
  0,
  191,
  0,
  1,
  0,
  241,
  25,
  0,
  0,
  192,
  0,
  1,
  0,
  242,
  25,
  0,
  0,
  193,
  0,
  1,
  0,
  243,
  25,
  0,
  0,
  194,
  0,
  1,
  0,
  244,
  25,
  0,
  0,
  195,
  0,
  1,
  0,
  245,
  25,
  0,
  0,
  196,
  0,
  1,
  0,
  246,
  25,
  0,
  0,
  197,
  0,
  1,
  0,
  28,
  26,
  0,
  0,
  198,
  0,
  1,
  0,
  29,
  26,
  0,
  0,
  199,
  0,
  1,
  0,
  30,
  26,
  0,
  0,
  200,
  0,
  1,
  0,
  117,
  26,
  0,
  0,
  201,
  0,
  1,
  0,
  118,
  26,
  0,
  0,
  202,
  0,
  1,
  0,
  124,
  26,
  0,
  0,
  203,
  0,
  1,
  0,
  144,
  26,
  0,
  0,
  204,
  0,
  1,
  0,
  145,
  26,
  0,
  0,
  205,
  0,
  1,
  0,
  30,
  27,
  0,
  0,
  206,
  0,
  1,
  0,
  149,
  26,
  0,
  0,
  32,
  0,
  0,
  0,
  150,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  167,
  26,
  0,
  0,
  4,
  0,
  0,
  0,
  168,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  169,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  170,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  171,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  172,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  176,
  26,
  0,
  0,
  13,
  0,
  0,
  0,
  241,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  244,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  247,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  248,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  249,
  26,
  0,
  0,
  13,
  0,
  0,
  0,
  29,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  40,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  39,
  27,
  0,
  0,
  1,
  0,
  0,
  0
}; // idb
char *off_100AAEE8 = "/shr_mem/iop_gwx_intf.shr"; // weak
_UNKNOWN unk_100ABDF0; // weak
char byte_100ABDF1[2323] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'W',
  'X',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x02',
  'R',
  'E',
  'Q',
  'U',
  'E',
  'S',
  'T',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'W',
  'X',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x03',
  'V',
  'E',
  'R',
  'I',
  'F',
  'Y',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'W',
  'X',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x04',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'W',
  'X',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'W',
  'X',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\a',
  'G',
  'W',
  'X',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  'G',
  'W',
  'X',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'F',
  'A',
  'I',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\t',
  'G',
  'W',
  'X',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'C',
  'A',
  'N',
  'C',
  'E',
  'L',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\n',
  'S',
  'T',
  'O',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'W',
  'X',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'A',
  'B',
  'C',
  'D',
  'E',
  'F',
  'G',
  'H',
  'J',
  'K',
  'L',
  'M',
  'P',
  'Q',
  'R',
  'S',
  '\0',
  '\0',
  ']',
  '\0',
  'Z',
  '\0',
  'W',
  '\0',
  '`',
  '\0',
  '\x01',
  '\0',
  '^',
  '\0',
  '[',
  '\0',
  'X',
  '\0',
  'a',
  '\0',
  '\x02',
  '\0',
  '_',
  '\0',
  '\\',
  '\0',
  'Y',
  '\0',
  'b',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  '\0',
  '',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\0',
  '',
  '\0',
  '',
  '\0',
  '\x02',
  '\0',
  '<',
  '\x02',
  '=',
  '\x02',
  ';',
  '\x02',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\0',
  '\x02',
  '\0',
  ':',
  '\x02',
  '\x17',
  '\x15',
  '\x03',
  '\x03',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\n',
  '\x12',
  '\n',
  '\x12',
  '\n',
  '\x1C',
  '\x0E',
  '\x1D',
  '\x0E',
  '\x1D',
  '\x0E',
  '\x1D',
  '\n',
  '\x1D',
  '\n',
  '\x1C',
  '\n',
  '\x18',
  '\n',
  '\x18',
  '\0',
  '\x18',
  '\0',
  '\x17',
  '\0',
  '\x16',
  '\0',
  '\x17',
  '\0',
  '\x17',
  '\0',
  '\x17',
  '\0',
  '\x1C',
  '\0',
  '\x18',
  '\0',
  '\x16',
  '\0',
  '\x14',
  '\n',
  '\x18',
  '\n',
  '\x12',
  '\n',
  '\x14',
  '\n',
  '\x18',
  '\n',
  '\r',
  '\n',
  '\x14',
  '\n',
  '\x1C',
  '\n',
  '\x12',
  '\0',
  '\x16',
  '\0',
  '\x16',
  '\0',
  '\x14',
  '\0',
  '\x12',
  '\n',
  '\x12',
  '\0',
  '\x1C',
  '\0',
  '\x17',
  '\0',
  '\x16',
  '\n',
  '\x1C',
  '\n',
  '\x16',
  '\n',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x02',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x12',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x13',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x14',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x15',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x16',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x17',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x19',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x1A',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x1B',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x1C',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x1D',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x1E',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x1F',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  ' ',
  '\0',
  '\x04',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '$',
  '\0',
  '\x04',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '(',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  ')',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '*',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '+',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  ',',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '-',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '.',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '/',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '1',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '2',
  '\0',
  '\x1E',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'P',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'Q',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'T',
  '\0',
  '\x04',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'X',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'Y',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\\',
  '\0',
  '\x04',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '`',
  '\0',
  '\x04',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'd',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x04',
  '\0',
  '',
  '\x17',
  '\0',
  '\0',
  'h',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'i',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'j',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'k',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'l',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'm',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'n',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'o',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'p',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'q',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'r',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  's',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  't',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'u',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'v',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'x',
  '\0',
  '\x04',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '|',
  '\0',
  '\x04',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x04',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x04',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x04',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x02',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x05',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '\x1C',
  '\x1A',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '\x1D',
  '\x1A',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '\x1E',
  '\x1A',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  'u',
  '\x1A',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  'v',
  '\x1A',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '|',
  '\x1A',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '\x1E',
  '\x1B',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  ' ',
  '\0',
  '\0',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\0',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '\r',
  '\0',
  '\0',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '\r',
  '\0',
  '\0',
  '\0',
  '\x1D',
  '\x1B',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '(',
  '\x1B',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\'',
  '\x1B',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_100B9EF0; // weak
_UNKNOWN unk_100D8B84; // weak
_UNKNOWN unk_100D8B88; // weak
char *off_100DA320[2426] =
{
  "GET_HSDB",
  "GIA_1_DATE_TIME",
  "GIA_2_DATE_TIME",
  "DATE_TIME_SET",
  "ACTV_PFD1_AFCS_KEY_STS",
  "ACTV_PFD2_AFCS_KEY_STS",
  "ACTV_PIL_ALT_SELECT",
  "ACTV_COPIL_ALT_SELECT",
  "ACTV_PIL_BARO_SELECT",
  "ACTV_COPIL_BARO_SELECT",
  "ACTV_PIL_CRS_SELECT",
  "ACTV_COPIL_CRS_SELECT",
  "ACTV_PIL_GPS_NAVIGATION",
  "ACTV_COPIL_GPS_NAVIGATION",
  "ENG_1_FADEC_SERIAL_NUM",
  "ENG_2_FADEC_SERIAL_NUM",
  "ACTV_PIL_HDG_SELECT",
  "ACTV_COPIL_HDG_SELECT",
  "ACTV_PIL_VLC_DB_DATA",
  "ACTV_COPIL_VLC_DB_DATA",
  "ACTV_PIL_MAG_VAR",
  "ACTV_COPIL_MAG_VAR",
  "ACTV_PIL_NAV_SENSOR",
  "ACTV_COPIL_NAV_SENSOR",
  "EAU_FLAP_VOLTS",
  "EAU_BAGGAGE_DOOR_OPEN",
  "ACTV_PIL_PVT_DATA",
  "ACTV_COPIL_PVT_DATA",
  "ACTV_PIL_ROLL_STRNG",
  "ACTV_COPIL_ROLL_STRNG",
  "EAU_AC_DOOR_VOLTS",
  "EAU_AC_VOLTS",
  "GSD_1_TICK",
  "GSD_2_TICK",
  "ACTV_PIL_VLOC_NAVIGATION",
  "ACTV_COPIL_VLOC_NAVIGATION",
  "GO_AROUND_BCKUP_GIA_1",
  "GO_AROUND_BCKUP_GIA_2",
  "ACTV_MFD1_AFCS_KEY_STS",
  "AFCS_SELECTED_FD",
  "FADEC_LH_DATA_LOSS",
  "HF_1_MAINTENANCE_351",
  "ACTV_PIL_VSPD",
  "ACTV_COPIL_VSPD",
  "ACTV_PIL_WIND_DATA",
  "ACTV_COPIL_WIND_DATA",
  "AFCS_1_ANNUNC",
  "AFCS_2_ANNUNC",
  "AFCS_1_FD_CMND",
  "AFCS_2_FD_CMND",
  "EAU_STALL_HEATER_LOAD",
  "EAU_LOW_MAIN_FUEL_L_IN",
  "EAU_LOW_MAIN_FUEL_R_IN",
  "EAU_AC_DOOR_EXT",
  "EAU_AFT_DOOR_OPEN",
  "EAU_ALT_AMPS_1",
  "EAU_ALT_AMPS_2",
  "EAU_ALT_FAIL_1",
  "EAU_ANNUNC_TEST",
  "EAU_BATT_AMPS_1",
  "EAU_BATT_VOLTS_1",
  "EAU_BATT_VOLTS_2",
  "EAU_DEICE_PRESS",
  "EAU_ENG_1_CHT_1",
  "EAU_ENG_1_CHT_2",
  "EAU_ENG_1_CHT_3",
  "EAU_ENG_1_CHT_4",
  "EAU_ENG_1_CHT_5",
  "EAU_ENG_1_CHT_6",
  "EAU_ENG_1_EGT_1",
  "EAU_ENG_1_EGT_2",
  "EAU_ENG_1_EGT_3",
  "EAU_ENG_1_EGT_4",
  "EAU_ENG_1_EGT_5",
  "EAU_ENG_1_EGT_6",
  "EAU_ENG_1_FFLOW",
  "EAU_ENG_1_FFLOW_RETURN",
  "EAU_ENG_1_FUEL_PRESS",
  "EAU_ENG_1_MAP",
  "EAU_ENG_1_N3",
  "EAU_ENG_1_OP",
  "EAU_ENG_1_OT",
  "EAU_ENG_1_TACH",
  "EAU_ENG_1_TIT",
  "EAU_ENG_1_VAC",
  "EAU_ENG_2_CHT_1",
  "EAU_ENG_2_CHT_2",
  "EAU_ENG_2_CHT_3",
  "EAU_ENG_2_CHT_4",
  "EAU_ENG_2_CHT_5",
  "EAU_ENG_2_CHT_6",
  "EAU_ENG_2_EGT_1",
  "EAU_ENG_2_EGT_2",
  "EAU_ENG_2_EGT_3",
  "EAU_ENG_2_EGT_4",
  "EAU_ENG_2_EGT_5",
  "EAU_ENG_2_EGT_6",
  "EAU_ENG_2_FFLOW",
  "EAU_ENG_2_FFLOW_RETURN",
  "EAU_ENG_2_FUEL_PRESS",
  "DSCRT_IN_AFCS_ROLL_DISC",
  "EAU_ENG_2_MAP",
  "DSCRT_IN_COM_3_MIC_KEYED",
  "ATN_ERR_RPT",
  "EAU_ENG_2_N3",
  "EAU_ENG_2_OP",
  "EAU_ENG_2_OT",
  "EAU_ENG_2_TACH",
  "EAU_ENG_2_TIT",
  "EAU_ENG_2_VAC",
  "INST_DATA",
  "STICK_LIMIT_ACTV",
  "EAU_FUEL_QNTY_C_1",
  "EAU_FUEL_QNTY_C_2",
  "EAU_FUEL_QNTY_L_1",
  "EAU_FUEL_QNTY_L_2",
  "EAU_FUEL_QNTY_L_3",
  "EAU_FUEL_QNTY_L_4",
  "EAU_FUEL_QNTY_L_5",
  "EAU_FUEL_QNTY_R_1",
  "EAU_FUEL_QNTY_R_2",
  "EAU_FUEL_QNTY_R_3",
  "EAU_FUEL_QNTY_R_4",
  "EAU_FUEL_QNTY_R_5",
  "EAU_FWD_DOOR_OPEN",
  "EAU_GEAR_L",
  "EAU_GEAR_N",
  "EAU_GEAR_R",
  "EAU_PITOT_HEAT_AMPS",
  "EAU_PROP_DEICE_AMPS_1",
  "EAU_PROP_DEICE_AMPS_2",
  "EAU_STALL_WARN",
  "EAU_ENG_1_START_IMPL_VOLTS",
  "EAU_ENG_1_START_RQST_VOLTS",
  "EAU_STARTER_ENGAGE",
  "EAU_HYDRAULIC_PRESS",
  "EAU_LOW_AUX_FUEL_L",
  "EAU_LOW_AUX_FUEL_R",
  "EAU_ENG_1_START_IMPL",
  "EAU_ENG_1_START_RQST",
  "EAU_ENG_2_START_IMPL",
  "EAU_ENG_2_START_RQST",
  "EAU_LOW_VOLTS_L",
  "EAU_LOW_VOLTS_R",
  "EAU_ENG_1_FIRE",
  "EAU_ENG_2_FIRE",
  "EAU_ENG_1_LOW_WATER",
  "EAU_ENG_2_LOW_WATER",
  "EAU_FUEL_XFER_PUMP_SWITCH_ON_L",
  "EAU_FUEL_XFER_PUMP_SWITCH_ON_R",
  "EAU_AUX_FUEL_XFER_L",
  "EAU_AUX_FUEL_XFER_R",
  "EAU_PITOT_POWER_VOLTS",
  "EAU_PITOT_LOAD_VOLTS",
  "EAU_FUEL_TEMP_L",
  "EAU_FUEL_TEMP_R",
  "EAU_STALL_HEATER_AMPS",
  "EAU_STALL_HEATER_PWR_VLTS",
  "EAU_AUX_FUEL_XFER_ANLG_L",
  "EAU_AUX_FUEL_XFER_ANLG_R",
  "EAU_ENG_2_START_IMPL_VOLTS",
  "EAU_ENG_2_START_RQST_VOLTS",
  "EAU_TRIM_FAIL",
  "EAU_ENG_1_TN1",
  "EAU_ENG_2_TN1",
  "EAU_BATT_AMPS_2",
  "EAU_PROP_1_HEAT_ON",
  "EAU_PROP_1_HEAT_FAIL",
  "EAU_ENG_1_LOW_OIL_PRESS",
  "EAU_ENG_1_COOLANT_TEMP",
  "EAU_ENG_2_COOLANT_TEMP",
  "EAU_ENG_1_GEAR_BOX_TEMP",
  "EAU_ENG_2_GEAR_BOX_TEMP",
  "EAU_STALL_HEATER_LD_VLTS",
  "EAU_ENG_1_GLOWPLUG_ON",
  "EAU_ENG_2_GLOWPLUG_ON",
  "EAU_ENG_1_PWR_LVL",
  "EAU_ENG_2_PWR_LVL",
  "EAU_ALT_FAIL_2",
  "EAU_ENG_1_ECU_A_FAIL",
  "EAU_ENG_1_ECU_B_FAIL",
  "EAU_ENG_2_ECU_A_FAIL",
  "EAU_ENG_2_ECU_B_FAIL",
  "EAU_ENG_1_ALT_FAIL_VOLTS",
  "EAU_ENG_2_ALT_FAIL_VOLTS",
  "FADEC_LH_MAJ_FAIL",
  "FADEC_LH_MIN_FAIL",
  "FADEC_RH_MAJ_FAIL",
  "FADEC_RH_MIN_FAIL",
  "GPS_ANNUN",
  "GPS_APPROACH_ANNUN",
  "GPS_1_FDE_STATUS",
  "GWX_STATUS",
  "GWX_RDR_CMD",
  "GWX_SYS_CMD",
  "GWX_WTHR_DATA",
  "EAU_PITOT_HEAT_SWITCH",
  "GPS_1_PVT_RAIM_PERF",
  "EAU_PITOT_HEAT_CURRENT",
  "DME_1_DATA",
  "GPS_1_PVT_MSG",
  "GPS_1_RAIM_RQST",
  "GPS_1_RAIM_RSLT",
  "GPS_1_RCV_STATE",
  "DME_2_DATA",
  "GPS_1_STATE",
  "GPS_1_STATUS",
  "GPS_1_SYC_EVNT",
  "GPS_2_FDE_STATUS",
  "RGN_NOTIFICATION",
  "RGN_BUFFER",
  "RGN_ACK",
  "DME_1_TUNE",
  "DME_2_TUNE",
  "GPS_2_PVT_RAIM_PERF",
  "ADF_1_DATA",
  "ADF_2_DATA",
  "GPS_2_PVT_MSG",
  "GPS_2_RAIM_RQST",
  "GPS_2_RAIM_RSLT",
  "GPS_2_RCV_STATE",
  "ADF_1_TUNE",
  "GPS_2_STATE",
  "GPS_2_STATUS",
  "GPS_2_SYC_EVNT",
  "FADEC_LH_INJ_MODE",
  "EAU_GEAR_VOLTS",
  "FADEC_INV_CHAN_CFG",
  "EAU_BUS_TIE_RELAY_OUT",
  "HDNG_VAL_ANNUN",
  "ADF_2_TUNE",
  "EAU_DEICE_PRES_LO",
  "PFD_1_STATUS",
  "MFD_1_STATUS",
  "PFD_2_STATUS",
  "FADEC_LH_MIX_CAL_MODE",
  "FADEC_LH_CWL_FLP_POS",
  "FADEC_LH_FL_PRES_SENS_FLT",
  "FADEC_LH_MNFLD_PRES_SENS_FLT",
  "FADEC_LH_CHT_SENS_FLT",
  "FADEC_LH_CYL_IN_BKUP_CTRL_MODE",
  "FADEC_LH_MNFLD_TMP_SENS_FLT",
  "FADEC_LH_CWL_FLP_SW_STS",
  "FADEC_LH_EGT_SENS_FLT",
  "FADEC_LH_FL_BST_SC_DETECT",
  "FADEC_LH_CHT_OVRTMP",
  "FADEC_LH_EGT_OVRTMP",
  "EAU_EIS_FLAPS_STATE",
  "FADEC_LH_ENG_TIMING_FLT",
  "XFIL_REG_DATA_PFD_1",
  "XFIL_REG_DATA_MFD_1",
  "XFIL_REG_DATA_PFD_2",
  "XFIL_REG_DATA_RQST",
  "XFIL_REG_TAG_TBL_PFD_1",
  "XFIL_REG_TAG_TBL_MFD_1",
  "XFIL_REG_TAG_TBL_PFD_2",
  "EAU_DEICE_PRES_HI",
  "EAU_DEICE_LVL_LO",
  "EAU_STICK_LIMIT_FAIL",
  "EAU_CABIN_TEMP",
  "AIRBORNE_STATUS",
  "EAU_LOW_MAIN_FUEL_L_OUT",
  "EAU_LOW_MAIN_FUEL_R_OUT",
  "EAU_CHECK_GEAR_WARNING",
  "EAU_BATTERY_1_SELECTED",
  "EAU_BATTERY_2_SELECTED",
  "EAU_BATT_NON_ESSENTIAL_BUS_UNPWRD",
  "EAU_RUDDER_TRIM",
  "EAU_ELEVATOR_TRIM",
  "EAU_FLAPS_POSITION",
  "GIA_BUS_TIE_NOT_OPEN_GIA_1",
  "GIA_BUS_TIE_NOT_OPEN_GIA_2",
  "EAU_DEICE_QNTY_1",
  "EAU_DEICE_QNTY_2",
  "EAU_DEICE_QNTY_3",
  "GIA_1_AFCS_STATUS",
  "GIA_2_AFCS_STATUS",
  "GWX_AHRS",
  "GWX_CFG_ACT",
  "GWX_CFG_CRC",
  "GWX_CFG_SET",
  "EAU_DEICE_SWITCH_ON_VOLTS",
  "FADEC_LH_MECH_FL_PMP_FAIL",
  "COPIL_CWS_GIA_1",
  "COPIL_CWS_GIA_2",
  "DSCRT_IN_RESERVE_14",
  "DSCRT_IN_RESERVE_15",
  "DSCRT_IN_RESERVE_16",
  "DSCRT_IN_RESERVE_17",
  "DSCRT_IN_RESERVE_18",
  "DSCRT_IN_RESERVE_19",
  "DSCRT_IN_RESERVE_20",
  "DSCRT_IN_RESERVE_21",
  "DSCRT_IN_RESERVE_22",
  "DSCRT_IN_RESERVE_23",
  "DSCRT_IN_RESERVE_24",
  "DSCRT_IN_RESERVE_25",
  "GO_AROUND_GIA_1",
  "GO_AROUND_GIA_2",
  "PIL_CWS_GIA_1",
  "PIL_CWS_GIA_2",
  "DSCRT_IN_RESERVE_26",
  "DSCRT_IN_RESERVE_27",
  "DSCRT_IN_RESERVE_28",
  "DSCRT_IN_RESERVE_29",
  "DSCRT_IN_RESERVE_30",
  "DSCRT_IN_RESERVE_31",
  "DSCRT_IN_RESERVE_32",
  "DSCRT_IN_RESERVE_33",
  "DSCRT_IN_RESERVE_34",
  "DSCRT_IN_RESERVE_35",
  "DSCRT_IN_RESERVE_36",
  "DSCRT_IN_RESERVE_37",
  "DSCRT_IN_RESERVE_38",
  "DSCRT_IN_RESERVE_39",
  "DSCRT_IN_RESERVE_40",
  "DSCRT_IN_RESERVE_41",
  "DSCRT_IN_RESERVE_42",
  "DSCRT_IN_RESERVE_43",
  "FLAP_EXTEND_GIA_1",
  "FLAP_EXTEND_GIA_2",
  "FLAP_RETRACT_GIA_1",
  "FLAP_RETRACT_GIA_2",
  "DSCRT_OUT_RESERVE_6",
  "DSCRT_OUT_RESERVE_7",
  "DSCRT_OUT_RESERVE_8",
  "DSCRT_OUT_RESERVE_9",
  "DSCRT_OUT_RESERVE_10",
  "DSCRT_OUT_RESERVE_11",
  "EAU_ALT_SWITCH_1",
  "PRESS_A429_LBL_270",
  "EAU_FUEL_BOOST_CAUT_L",
  "EAU_FUEL_BOOST_CAUT_R",
  "ENG_1_ITT_HI_CAUT",
  "ENG_2_ITT_HI_CAUT",
  "ENG_1_ITT_HI_WARN",
  "ENG_2_ITT_HI_WARN",
  "ENG_1_N1_HI_WARN",
  "ENG_2_N1_HI_WARN",
  "ENG_1_N2_HI_WARN",
  "ENG_2_N2_HI_WARN",
  "ENG_1_OIL_PRES_HI_CAUT",
  "ENG_2_OIL_PRES_HI_CAUT",
  "ENG_1_OIL_PRES_HI_WARN",
  "ENG_2_OIL_PRES_HI_WARN",
  "ENG_1_OIL_PRES_LO_CAUT",
  "ENG_2_OIL_PRES_LO_CAUT",
  "ENG_1_OIL_PRES_LO_WARN",
  "ENG_2_OIL_PRES_LO_WARN",
  "ENG_1_OIL_TEMP_HI_CAUT",
  "ENG_2_OIL_TEMP_HI_CAUT",
  "ENG_1_OIL_TEMP_HI_WARN",
  "ENG_2_OIL_TEMP_HI_WARN",
  "ENG_1_OIL_TEMP_LO_CAUT",
  "ENG_2_OIL_TEMP_LO_CAUT",
  "ENG_1_OIL_TEMP_LO_WARN",
  "ENG_2_OIL_TEMP_LO_WARN",
  "DSCRT_IN_AOA_VALID",
  "DSCRT_IN_RESERVE_2",
  "ANTISKID_FAIL",
  "AVN_FAN_OFF",
  "AVN_FAN_FAIL",
  "CAB_ALT_1_GT_10K",
  "CAB_ALT_1_GT_14_5K",
  "CAB_ALT_2_GT_10K",
  "CAB_ALT_2_GT_14_5K",
  "ELEV_TRIM_NOT_IN_TAKEOFF",
  "EMERGENCY_BUS_SWITCH",
  "FDR_FAIL",
  "FLAP_POS_VALID",
  "HYDRAULIC_PRESS_LOW",
  "HYDRAULIC_PUMP_ON",
  "LH_FUEL_FW_SHUTOFF_CLOSED",
  "RH_FUEL_FW_SHUTOFF_CLOSED",
  "LH_AI_LOGIC_1",
  "LH_AI_LOGIC_2",
  "LH_GEN_OFF",
  "RH_GEN_OFF",
  "LH_PITOT_STATIC_HTR_OFF",
  "RH_PITOT_STATIC_HTR_OFF",
  "LH_WINDSHIELD_AI_FAIL",
  "RH_WINDSHIELD_AI_FAIL",
  "LH_WINDSHIELD_AI_ON",
  "RH_WINDSHIELD_AI_ON",
  "LH_WINDSHIELD_OHEAT",
  "RH_WINDSHIELD_OHEAT",
  "MC_ACKNOWLEDGE_1",
  "MC_ACKNOWLEDGE_2",
  "MW_ACKNOWLEDGE_1",
  "MW_ACKNOWLEDGE_2",
  "OXYGEN_OFF",
  "PRESS_STNDBY",
  "PRESS_BIT_FAIL",
  "PRESS_OFF",
  "ROTARY_TEST_ANNUNC",
  "ROTARY_TEST_CABIN_ALT",
  "ROTARY_TEST_OFF",
  "ROTARY_TEST_OVRSPD",
  "SPINDOWN_FAIL",
  "STALL_TEST",
  "STALL_WARN_FAIL",
  "STALL_WARN_VANE_HTR_FAIL",
  "FLIGHT_HOUR_METER",
  "IAS_GT_130_KTS",
  "MC_ON",
  "MW_ON",
  "EAU_CHK_DOORS",
  "EAU_ENG_1_AI_COLD_CAUT",
  "EAU_ENG_2_AI_COLD_CAUT",
  "EAU_ENG_1_AI_COLD_ADV",
  "EAU_ENG_2_AI_COLD_ADV",
  "EAU_LNDG_GEAR_HNDL_EXTEND",
  "EAU_LH_AFT_CB_TRIPPED",
  "EAU_RH_AFT_CB_TRIPPED",
  "EAU_LH_AFT_LIMITER_BLOWN",
  "EAU_RH_AFT_LIMITER_BLOWN",
  "EAU_LH_FUEL_BOOST_ON",
  "EAU_RH_FUEL_BOOST_ON",
  "EAU_LH_FUEL_BYPASS_CLSD",
  "EAU_RH_FUEL_BYPASS_CLSD",
  "EAU_LH_FUEL_PRESSURE_LOW",
  "EAU_RH_FUEL_PRESSURE_LOW",
  "EAU_RH_FWD_DOOR_OPEN",
  "EAU_LH_T2_HTR_FAIL",
  "EAU_RH_T2_HTR_FAIL",
  "EAU_LH_SPEED_BRAKE_EXTEND",
  "EAU_SURFACE_1_DEICE_ON",
  "EAU_SURFACE_2_DEICE_ON",
  "EAU_TAIL_DEICE_FAIL",
  "EAU_WING_DEICE_FAIL",
  "EAU_AILERON_TRIM_A",
  "EAU_AILERON_TRIM_B",
  "EAU_ALTERNATOR_VOLTS_1",
  "EAU_ALTERNATOR_VOLTS_2",
  "EAU_BATT_TEMP",
  "EAU_CABIN_PRESSURE",
  "EAU_LH_CABIN_DUCT_TEMP",
  "EAU_RH_CABIN_DUCT_TEMP",
  "EAU_RUDDER_TRIM_A",
  "EAU_RUDDER_TRIM_B",
  "EAU_RH_SPEED_BRAKE_EXTEND",
  "ENG_1_RAT_CHNL_A",
  "ENG_1_RAT_CHNL_B",
  "ENG_2_RAT_CHNL_A",
  "ENG_2_RAT_CHNL_B",
  "EAU_FUEL_ALT_L_1",
  "EAU_FUEL_ALT_R_1",
  "EAU_STALL_WARN_HI",
  "EAU_ANGLE_OF_ATTACK_NORM",
  "EAU_FUEL_LOW_INOP_L",
  "EAU_FUEL_LOW_INOP_R",
  "EAU_ENG_1_START_IMPL_B",
  "EAU_ENG_2_START_IMPL_B",
  "ENG_1_N1_HI_WARN_ON",
  "ENG_2_N1_HI_WARN_ON",
  "ENG_1_EVENT_MARKER_ON",
  "ENG_2_EVENT_MARKER_ON",
  "ENG_1_N2_HI_WARN_ON",
  "ENG_2_N2_HI_WARN_ON",
  "ENG_1_ITT_HI_CAUT_ON",
  "ENG_2_ITT_HI_CAUT_ON",
  "ENG_1_ITT_HI_WARN_ON",
  "ENG_2_ITT_HI_WARN_ON",
  "EAU_AIR_PUMP_1",
  "EAU_AIR_PUMP_2",
  "DSCRT_IN_BETA",
  "EAU_EMERGENCY_POWER_LEVER",
  "EAU_FOD_DOOR_BYPASS",
  "EAU_FOD_DOOR_NORM",
  "DSCRT_IN_IGNITION_ON",
  "EAU_LH_PITOT_STATIC_HTR_FAIL",
  "EAU_RH_PITOT_STATIC_HTR_FAIL",
  "EAU_STANDBY_POWER",
  "AFCS_DISCONNECT_IN_CFG",
  "DSCRT_IN_SELCAL",
  "GA_ANNUNC",
  "FUEL_SELECT_OFF",
  "RH_AI_LOGIC_1",
  "RH_AI_LOGIC_2",
  "EAU_RUDDER_LIMIT_INHIBIT",
  "EAU_IN_RESERVE_1",
  "EAU_IN_RESERVE_2",
  "EAU_IN_RESERVE_3",
  "EAU_IN_RESERVE_4",
  "EAU_IN_RESERVE_5",
  "EAU_IN_RESERVE_6",
  "EAU_IN_RESERVE_7",
  "EAU_IN_RESERVE_8",
  "EAU_IN_RESERVE_9",
  "EAU_IN_RESERVE_10",
  "DSCRT_IN_AUDIO_INHIBIT_1",
  "DSCRT_IN_AUDIO_INHIBIT_2",
  "DSCRT_IN_AUDIO_INHIBIT_3",
  "DSCRT_OUT_AUDIO_INHIBIT_1",
  "DSCRT_OUT_AUDIO_INHIBIT_2",
  "DSCRT_OUT_AUDIO_INHIBIT_3",
  "EAU_FUEL_SLCT_L",
  "EAU_FUEL_SLCT_R",
  "EAU_OXY_TANK_PRESS",
  "EAU_OXY_VALVE_PRESS",
  "EAU_OXY_ON",
  "EAU_OXY_OFF",
  "EAU_FUEL_SELECT_OFF",
  "EAU_VAPOR_SUPPRESS_L",
  "EAU_VAPOR_SUPPRESS_R",
  "EAU_RUDDER_HOLD",
  "DSCRT_OUT_RA_TEST",
  "EAU_ENG_1_NP",
  "EAU_ENG_1_NG",
  "EAU_IN_RESERVE_17",
  "EAU_ENG_2_NP",
  "EAU_ENG_2_NG",
  "EAU_IN_RESERVE_18",
  "DSCRT_IN_IMPENDING_STALL",
  "COM_1_CAL_RX",
  "COM_1_CAL_TX",
  "COM_1_CMND_RX",
  "COM_1_CMND_TX",
  "COM_1_DATA",
  "COM_1_TUNE_FREQ",
  "COM_1_TUNE_STATUS",
  "COM_1_VOL_TX",
  "COM_2_CAL_RX",
  "COM_2_CAL_TX",
  "COM_2_CMND_RX",
  "COM_2_CMND_TX",
  "COM_2_DATA",
  "COM_2_TUNE_FREQ",
  "COM_2_TUNE_STATUS",
  "COM_2_VOL_TX",
  "GMA_1_INST_RX",
  "GMA_1_INST_TX",
  "GMA_1_STATE",
  "GMA_1_LGHT_LVLS",
  "GMA_1_FAILURE_STATUS",
  "GMA_2_INST_RX",
  "GMA_2_INST_TX",
  "GMA_2_STATE",
  "GMA_2_LGHT_LVLS",
  "GMA_2_FAILURE_STATUS",
  "FLAPS_FAIL_A",
  "DSCRT_IN_LOW_FUEL_L",
  "DSCRT_IN_LOW_FUEL_R",
  "DSCRT_IN_LOW_FUEL_RES",
  "DSCRT_IN_STARTER_ON",
  "DSCRT_IN_ECS_FCSOV_1",
  "DSCRT_IN_ECS_FCSOV_2",
  "DSCRT_IN_ICE",
  "DSCRT_IN_ICE_FAIL",
  "DSCRT_IN_CVDR_TEST_MODE",
  "AUD_PTH_STAT_GIA_1",
  "AUD_PTH_STAT_GIA_2",
  "GWX7X_WAAS_SUBSET_1",
  "TC_BLEED_LEAK",
  "DSCRT_IN_ENG_1_OIL_IMP_BYPASS",
  "DSCRT_IN_ENG_2_OIL_IMP_BYPASS",
  "DSCRT_IN_FSOV1_CMD_TO_CLOSE",
  "DSCRT_IN_FSOV2_CMD_TO_CLOSE",
  "EAU_FLAPS_FAIL_5V",
  "EAU_ENG_1_CARB_TEMP",
  "FLAPS_FAIL_B",
  "GWX7X_WAAS_SUBSET_2",
  "ENG_1_N1_TAKEOFF",
  "ENG_2_N1_TAKEOFF",
  "ENG_1_N1_CLIMB",
  "ENG_2_N1_CLIMB",
  "ENG_1_N1_CRUISE",
  "ENG_2_N1_CRUISE",
  "ENG_1_FADEC_LBL_270",
  "ENG_1_FADEC_LBL_270_CH_A",
  "ENG_1_FADEC_LBL_270_CH_B",
  "ENG_2_FADEC_LBL_270",
  "ENG_2_FADEC_LBL_270_CH_A",
  "ENG_2_FADEC_LBL_270_CH_B",
  "ENG_1_FADEC_LBL_271",
  "DSCRT_IN_RESERVE_3",
  "DSCRT_IN_RESERVE_4",
  "ENG_2_FADEC_LBL_271",
  "DSCRT_IN_RESERVE_5",
  "DSCRT_IN_RESERVE_6",
  "ENG_1_FADEC_LBL_275",
  "ENG_1_FADEC_LBL_275_CH_A",
  "ENG_1_FADEC_LBL_275_CH_B",
  "ENG_2_FADEC_LBL_275",
  "ENG_2_FADEC_LBL_275_CH_A",
  "ENG_2_FADEC_LBL_275_CH_B",
  "ENG_1_FADEC_LBL_276",
  "ENG_1_FADEC_LBL_276_CH_A",
  "ENG_1_FADEC_LBL_276_CH_B",
  "ENG_2_FADEC_LBL_276",
  "ENG_2_FADEC_LBL_276_CH_A",
  "ENG_2_FADEC_LBL_276_CH_B",
  "DSCRT_IN_AIR_COND_ON",
  "DSCRT_IN_ALTI_CAB",
  "DSCRT_IN_AUTO_FUEL_SEL",
  "DSCRT_IN_FUEL_BOOST_AUTO",
  "DSCRT_IN_BAT_OFF",
  "DSCRT_IN_BAT_OVHT",
  "DSCRT_IN_BLEED_ON",
  "DSCRT_IN_BLEED_OVER_TMP",
  "DSCRT_IN_CHIP_ON",
  "DSCRT_IN_DEMIST_ON",
  "DSCRT_IN_DIFF_PRESS_CAB",
  "DSCRT_IN_DUMP_ON",
  "DSCRT_IN_ECS_FAULT",
  "DSCRT_IN_ELT_ON",
  "DSCRT_IN_FAN_ON",
  "DSCRT_IN_FAN_SPEED",
  "DSCRT_IN_FRONT_PRESS_ON",
  "DSCRT_IN_GEAR_WARN",
  "DSCRT_IN_GPU_SELECT",
  "DSCRT_IN_IN_SEP_DI_EXTD",
  "DSCRT_IN_IN_SEP_DI_SEL",
  "DSCRT_IN_L_LDG_DN",
  "DSCRT_IN_L_LDG_UP",
  "DSCRT_IN_LO_POWER",
  "DSCRT_IN_MAIN_GEN",
  "DSCRT_IN_NS_LDG_DN",
  "DSCRT_IN_NS_LDG_UP",
  "DSCRT_IN_O_SPEED_VALVE",
  "DSCRT_IN_PARK_BRAKE",
  "DSCRT_IN_PIT1_DI_PWR",
  "DSCRT_IN_PIT1_DI_SEL",
  "DSCRT_IN_PIT2_DI_PWR",
  "DSCRT_IN_PIT2_DI_SEL",
  "DSCRT_IN_PRESS_HIGH",
  "DSCRT_IN_PROP_1_HEAT_PWR",
  "DSCRT_IN_PRSOV_ON",
  "DSCRT_IN_R_LDG_DN",
  "DSCRT_IN_R_LDG_UP",
  "DSCRT_IN_REAR_PRESS_ON",
  "DSCRT_IN_SIGN_75_DN",
  "DSCRT_IN_TEMP_DUCT_H",
  "DSCRT_IN_TEMP_HIGH",
  "DSCRT_IN_VAC_LO",
  "EAU_FUEL_SELECT_L",
  "EAU_FUEL_SELECT_R",
  "DSCRT_IN_TAXI_LIGHT_ON",
  "DSCRT_IN_LNDG_LIGHT_ON",
  "PARK_BRAKE_PRESS",
  "AOA_SENSE_BOTTOM_1",
  "AOA_SENSE_TOP_1",
  "AOA_SENSE_BOTTOM_2",
  "AOA_SENSE_TOP_2",
  "DSCRT_IN_RESERVE_7",
  "DSCRT_IN_RESERVE_8",
  "EAU_RH_ELEVATOR_TRIM",
  "EAU_RH_ELEVATOR_TRIM_2",
  "EAU_EMER_DOOR_OPEN",
  "HYDRAULIC_TEMP_1_HI",
  "HYDRAULIC_TEMP_2_HI",
  "HYDRAULIC_SHUTOFF_1",
  "RH_HYDRAULIC_PRESS_LOW",
  "HYDRAULIC_SHUTOFF_2",
  "BRAKE_FAIL",
  "NOSE_FAN_FAIL",
  "PANEL_FAN_FAIL",
  "EAU_GEAR_SILENCER",
  "GEAR_FIRE_1",
  "GEAR_FIRE_FAIL_1",
  "GEAR_FIRE_2",
  "GEAR_FIRE_FAIL_2",
  "CARGO_SMOKE_FAIL_1",
  "CARGO_SMOKE_FAIL_2",
  "CARGO_SMOKE_1",
  "CARGO_SMOKE_2",
  "EMER_LIGHT_ARMED",
  "PIL_AP_DISCONNECT_GIA_1",
  "PIL_AP_DISCONNECT_GIA_2",
  "COPIL_AP_DISCONNECT_GIA_1",
  "COPIL_AP_DISCONNECT_GIA_2",
  "STALL_WARN_INHIBITED_1",
  "STALL_WARN_INHIBITED_2",
  "PITOT_HTR_1_ON",
  "PITOT_HTR_2_ON",
  "STATIC_HTR_1A_ON",
  "STATIC_HTR_1B_ON",
  "STATIC_HTR_2A_ON",
  "STATIC_HTR_2B_ON",
  "AOA_HEATER_ON",
  "PIL_TIMER_SWITCH",
  "COPIL_TIMER_SWITCH",
  "TAKEOFF_CONFIG_SWITCH",
  "EAU_LH_ELEVATOR_TRIM_FAIL",
  "EAU_LH_ELEVATOR_TRIM_FAIL_2",
  "ELEVATOR_TRIM_PWR_ACTIVE",
  "EAU_RH_ELEVATOR_TRIM_FAIL",
  "EAU_RH_ELEVATOR_TRIM_FAIL_2",
  "RH_ELEVATOR_TRIM_PWR_ACTIVE",
  "PIL_PTCH_CMND_VALID_1",
  "PIL_PTCH_CMND_VALID_2",
  "COPIL_PTCH_CMND_VALID_1",
  "COPIL_PTCH_CMND_VALID_2",
  "YAW_CMND_VALID",
  "RH_GIA_PTCH_UP",
  "RH_GIA_PTCH_DN",
  "LH_GIA_PTCH_UP",
  "LH_GIA_PTCH_DN",
  "EAU_AILERON_TRIM_FAIL",
  "LH_RUDDER_LIMIT",
  "RH_RUDDER_LIMIT",
  "FADEC_LH_DEAD_CYL_DETECT",
  "FADEC_LH_LEAN_MSFR_DETECT",
  "MACH_TRIM_OUT_CMD_UP",
  "MACH_TRIM_OUT_CMD_DOWN",
  "MACH_TRIM_OUT_CMD_VALID",
  "PTCH_OUT_CMD_VALID",
  "PTCH_OUT_UP",
  "PTCH_OUT_DOWN",
  "PTCH_TRIM_HIGH_RATE",
  "YAW_OUT_CMD_VALID",
  "YAW_OUT_RIGHT",
  "YAW_OUT_LEFT",
  "BRAKE_WARN_LBL",
  "BRAKE_FAIL_LBL_1",
  "BRAKE_FAIL_LBL_2",
  "BRAKE_FAIL_LBL_3",
  "EAU_FLAPS_STATUS_LBL",
  "EAU_FLAPS_LEVER_POS",
  "EAU_FLAPS_FAIL_LBL",
  "EAU_CABIN_ALT",
  "EAU_CABIN_ALT_RATE",
  "EAU_CABIN_DIFF_PRESS",
  "EAU_PRESS_WARN_STATUS",
  "EAU_PRESS_FAULT_STATUS_1",
  "EAU_PRESS_FAULT_STATUS_2",
  "EAU_PRESS_FAULT_STATUS_3",
  "EAU_PRESS_FAULT_STATUS_4",
  "EAU_CABIN_ALT_HI_WARN",
  "EAU_MCP_FAULT_LMP",
  "EAU_TARGET_CABIN_ALT",
  "BLEED_1_RING_1_LEAK",
  "BLEED_1_RING_2_LEAK",
  "BLEED_2_RING_1_LEAK",
  "BLEED_2_RING_2_LEAK",
  "BLEED_1_VLV_CLOSED",
  "BLEED_1_VLV_PRESS",
  "BLEED_1_OVERTEMP",
  "BLEED_2_VLV_CLOSED",
  "BLEED_2_VLV_PRESS",
  "BLEED_2_OVERTEMP",
  "RAM_AIR_VALVE_OPEN",
  "RAM_AIR_VALVE_CMD_CLOSED",
  "EBAY_OVERTEMP",
  "REAR_RACK_FAN_ON",
  "BLOWER_ON",
  "BAG_TEMP_LOW",
  "BAG_HEAT_FAIL_1",
  "BAG_HEAT_FAIL_2",
  "EAU_RH_DEICE_PRESS",
  "EAU_DEICE_STATUS",
  "EAU_DEICE_FAIL",
  "EAU_ICE_DETECTED",
  "EAU_DEICE_CMD_ON",
  "EAU_OXYGEN_PRESS",
  "EAU_OXYGEN_TEMP",
  "OXYGEN_PAX_PRESS_LOW",
  "OXYGEN_CREW_PRESS_LOW",
  "EAU_CABIN_ALT_HI_SWITCH",
  "EAU_OXYGEN_MASK_AUTO",
  "LH_WINDSHIELD_FAIL_1",
  "LH_WINDSHIELD_FAIL_2",
  "LH_WINDSHIELD_FAULT_1",
  "LH_WINDSHIELD_FAULT_2",
  "LH_WINDSHIELD_STATUS_1",
  "LH_WINDSHIELD_STATUS_2",
  "RH_WINDSHIELD_FAIL_1",
  "RH_WINDSHIELD_FAIL_2",
  "RH_WINDSHIELD_FAULT_1",
  "RH_WINDSHIELD_FAULT_2",
  "RH_WINDSHIELD_STATUS_1",
  "RH_WINDSHIELD_STATUS_2",
  "EAU_ENG_1_EXTINGUISH",
  "EAU_ENG_2_EXTINGUISH",
  "EAU_ENG_1_FIRE_DETECT_FAIL",
  "EAU_ENG_2_FIRE_DETECT_FAIL",
  "EAU_ENG_1_EXTING_FAIL",
  "EAU_ENG_2_EXTING_FAIL",
  "EAU_EXTINGUISH_LOW_PRESS",
  "EAU_DC_BUS_1_VOLTS",
  "EAU_DC_BUS_2_VOLTS",
  "EAU_EMER_BUS_VOLTS",
  "EAU_CENTRAL_BUS_VOLTS",
  "EAU_SHED_BUS_1_VOLTS",
  "EAU_SHED_BUS_2_VOLTS",
  "EAU_BC_1_CLOSED",
  "EAU_BC_2_CLOSED",
  "EAU_EBC_1_CLOSED",
  "EAU_EBC_2_CLOSED",
  "EAU_LH_GLC_1_CLOSED",
  "EAU_LH_GLC_2_CLOSED",
  "EAU_RH_GLC_1_CLOSED",
  "EAU_RH_GLC_2_CLOSED",
  "EAU_LH_SC_1_CLOSED",
  "EAU_LH_SC_2_CLOSED",
  "EAU_RH_SC_1_CLOSED",
  "EAU_RH_SC_2_CLOSED",
  "EAU_QSC_CLOSED",
  "EAU_BTC_1_CLOSED",
  "EAU_BTC_2_CLOSED",
  "EAU_GPU_VOLTS",
  "EAU_GPU_SW_ON",
  "EAU_RH_ALT_AMPS_1",
  "EAU_RH_ALT_AMPS_2",
  "EAU_RH_BATT_TEMP",
  "EAU_GPC_CLOSED",
  "EAU_BTC_SW_1_OPEN",
  "EAU_BTC_SW_2_OPEN",
  "EAU_LH_GCU_STATUS_1",
  "EAU_LH_GCU_STATUS_2",
  "EAU_RH_GCU_STATUS_1",
  "EAU_RH_GCU_STATUS_2",
  "EAU_FUEL_XFER_PUMP_ON_L",
  "EAU_FUEL_XFER_PUMP_ON_R",
  "EAU_FUEL_XFER_VALVE_OPEN",
  "EAU_FUEL_XFER_VALVE_CLOSED",
  "EAU_FUEL_XFER_CMD_OPEN",
  "EAU_FUEL_XFER_CMD_CLOSED",
  "LH_FUEL_FW_SHUTOFF_CMD_OPEN",
  "LH_FUEL_FW_SHUTOFF_CMD_CLOSED",
  "RH_FUEL_FW_SHUTOFF_CMD_OPEN",
  "RH_FUEL_FW_SHUTOFF_CMD_CLOSED",
  "LH_FUEL_FW_SHUTOFF_OPEN",
  "RH_FUEL_FW_SHUTOFF_OPEN",
  "AFCS_1_CMC_PRMTR",
  "AFCS_2_CMC_PRMTR",
  "AFCS_1_CMC_PFT",
  "AFCS_2_CMC_PFT",
  "EAU_FUEL_SYSTEM_ID",
  "EAU_LH_FUEL_WARN_LBL",
  "EAU_RH_FUEL_WARN_LBL",
  "ENG_1_FADEC_STATUS_1",
  "ENG_1_FADEC_STATUS_2",
  "DSCRT_IN_RESERVE_9",
  "ENG_1_FADEC_FAULT",
  "ENG_1_FADEC_INPUT_FAULT",
  "ENG_1_FUEL_SYS_STATUS",
  "ENG_1_FADEC_EXCEEDANCES",
  "ENG_1_FADEC_STATUS_SELECT",
  "ENG_1_FADEC_COMM_STATUS",
  "ENG_1_FADEC_HW_ID",
  "ENG_1_TLA_BIAS",
  "TLERT_ENG_1_CH_A_ACTV",
  "EAU_ENG_1_N1_RPM",
  "EAU_ENG_1_N2_RPM",
  "ENG_1_N1_MAX_TAKEOFF",
  "ENG_1_N1_MAX_CONT",
  "ENG_1_N1_MAX_GOAROUND",
  "ENG_1_N1_MAX_CLIMB",
  "ENG_1_N1_MAX_CRUISE",
  "ENG_1_N1_MAX_ATR",
  "ENG_1_N1_TRIM",
  "ENG_1_ITT_TRIM",
  "ENG_1_N1_HI_CAUT",
  "ENG_1_N2_HI_CAUT",
  "ENG_1_N1_CRUISE_MAX_LMT",
  "ENG_1_N1_CRUISE_MIN_LMT",
  "ENG_1_TARGET_FFLOW",
  "ENG_1_CORRECTED_N2",
  "ENG_1_BLEED_POS_FEEDBACK",
  "ENG_1_N1_PEAK_EXCEED",
  "ENG_1_N2_PEAK_EXCEED",
  "ENG_1_ITT_PEAK_EXCEED",
  "ENG_1_OP_PEAK_EXCEED",
  "ENG_1_OT_PEAK_EXCEED",
  "ENG_1_FT_PEAK_EXCEED",
  "ENG_1_N1_PEAK_DURATION",
  "ENG_1_N2_PEAK_DURATION",
  "ENG_1_ITT_PEAK_DURATION",
  "ENG_1_OP_PEAK_DURATION",
  "ENG_1_OT_PEAK_DURATION",
  "ENG_1_FUEL_PEAK_DURATION",
  "ENG_1_RUN_TIME",
  "ENG_1_CUM_FLIGHT_TIME",
  "ENG_2_FADEC_STATUS_1",
  "ENG_2_FADEC_STATUS_2",
  "DSCRT_IN_RESERVE_10",
  "ENG_2_FADEC_FAULT",
  "ENG_2_FADEC_INPUT_FAULT",
  "ENG_2_FUEL_SYS_STATUS",
  "ENG_2_FADEC_EXCEEDANCES",
  "ENG_2_FADEC_STATUS_SELECT",
  "ENG_2_FADEC_COMM_STATUS",
  "ENG_2_FADEC_HW_ID",
  "ENG_2_TLA_BIAS",
  "TLERT_ENG_1_CH_B_ACTV",
  "EAU_ENG_2_N1_RPM",
  "EAU_ENG_2_N2_RPM",
  "ENG_2_N1_MAX_TAKEOFF",
  "ENG_2_N1_MAX_CONT",
  "ENG_2_N1_MAX_GOAROUND",
  "ENG_2_N1_MAX_CLIMB",
  "ENG_2_N1_MAX_CRUISE",
  "ENG_2_N1_MAX_ATR",
  "ENG_2_N1_TRIM",
  "ENG_2_ITT_TRIM",
  "ENG_2_N1_HI_CAUT",
  "ENG_2_N2_HI_CAUT",
  "ENG_2_N1_CRUISE_MAX_LMT",
  "ENG_2_N1_CRUISE_MIN_LMT",
  "ENG_2_TARGET_FFLOW",
  "ENG_2_CORRECTED_N2",
  "ENG_2_BLEED_POS_FEEDBACK",
  "ENG_2_N1_PEAK_EXCEED",
  "ENG_2_N2_PEAK_EXCEED",
  "ENG_2_ITT_PEAK_EXCEED",
  "ENG_2_OP_PEAK_EXCEED",
  "ENG_2_OT_PEAK_EXCEED",
  "ENG_2_FT_PEAK_EXCEED",
  "ENG_2_N1_PEAK_DURATION",
  "ENG_2_N2_PEAK_DURATION",
  "ENG_2_ITT_PEAK_DURATION",
  "ENG_2_OP_PEAK_DURATION",
  "ENG_2_OT_PEAK_DURATION",
  "ENG_2_FUEL_PEAK_DURATION",
  "ENG_2_RUN_TIME",
  "ENG_2_CUM_FLIGHT_TIME",
  "ENG_1_FADEC_OAT",
  "ENG_2_FADEC_OAT",
  "SELECTED_OAT",
  "EAU_WHEEL_SPEED_L",
  "EAU_WHEEL_SPEED_R",
  "EAU_FADEC_ATR_ON",
  "EAU_FADEC_CON_ENBL",
  "RH_BLOWER_ON",
  "ENG_1_TT0",
  "ENG_1_STATIC_PRESS",
  "ENG_2_TT0",
  "ENG_2_STATIC_PRESS",
  "EAU_ENG_1_CHIP_DETECTOR",
  "EAU_ENG_2_CHIP_DETECTOR",
  "EAU_ENG_1_TT0_HEATER",
  "EAU_ENG_2_TT0_HEATER",
  "EAU_ENG_1_STOP_POS",
  "EAU_ENG_2_STOP_POS",
  "EAU_FUEL_TANK_TEMP",
  "ECS_CREW_STATUS_1",
  "ECS_CREW_STATUS_2",
  "ECS_CREW_TEMP_SET",
  "ECS_CREW_TEMP",
  "ECS_CREW_BLEED_PRES",
  "ECS_PAX_STATUS_1",
  "ECS_PAX_STATUS_2",
  "ECS_PAX_TEMP_SET",
  "ECS_PAX_TEMP",
  "ECS_PAX_BLEED_PRES",
  "ECS_CREW_CTRL_FAIL",
  "ECS_PAX_CTRL_FAIL",
  "ENG_1_FADEC_LBL_272_CH_A",
  "ENG_1_FADEC_LBL_273_CH_A",
  "ENG_1_FADEC_LBL_274_CH_A",
  "ENG_1_FADEC_LBL_344_CH_A",
  "ENG_1_FADEC_LBL_350_CH_A",
  "ENG_1_FADEC_LBL_351_CH_A",
  "ENG_1_FADEC_LBL_272_CH_B",
  "ENG_1_FADEC_LBL_273_CH_B",
  "ENG_1_FADEC_LBL_274_CH_B",
  "ENG_1_FADEC_LBL_344_CH_B",
  "ENG_1_FADEC_LBL_350_CH_B",
  "ENG_1_FADEC_LBL_351_CH_B",
  "ENG_2_FADEC_LBL_272_CH_A",
  "ENG_2_FADEC_LBL_273_CH_A",
  "ENG_2_FADEC_LBL_274_CH_A",
  "ENG_2_FADEC_LBL_344_CH_A",
  "ENG_2_FADEC_LBL_350_CH_A",
  "ENG_2_FADEC_LBL_351_CH_A",
  "ENG_2_FADEC_LBL_272_CH_B",
  "ENG_2_FADEC_LBL_273_CH_B",
  "ENG_2_FADEC_LBL_274_CH_B",
  "ENG_2_FADEC_LBL_344_CH_B",
  "ENG_2_FADEC_LBL_350_CH_B",
  "ENG_2_FADEC_LBL_351_CH_B",
  "ATN_CLNP_DN_PDU",
  "ATN_CLNP_UP_PDU",
  "FUEL_CH_1_LBL_272",
  "FUEL_CH_1_LBL_273",
  "FUEL_CH_1_LBL_350",
  "FUEL_CH_1_LBL_351",
  "FUEL_CH_1_LBL_352",
  "FUEL_CH_1_LBL_353",
  "ATN_RTR_STS",
  "GWX_WTHR_DATA_GX000",
  "FUEL_CH_2_LBL_272",
  "FUEL_CH_2_LBL_273",
  "FUEL_CH_2_LBL_350",
  "FUEL_CH_2_LBL_351",
  "FUEL_CH_2_LBL_352",
  "FUEL_CH_2_LBL_353",
  "AIRCRAFT_XPDR_ADDR",
  "ENG_1_CLEAR_EXCEED",
  "ENG_2_CLEAR_EXCEED",
  "ENG_1_CHIP_DETECTED_ON",
  "ENG_2_CHIP_DETECTED_ON",
  "EAU_FLAPS_FAIL_LBL_2",
  "EAU_EMERGENCY_BLEED",
  "EAU_PROP_FEATHER",
  "EAU_STBY_ATT_BATT_HEATER_FAIL",
  "EAU_STBY_ATTITUDE_TEST",
  "EAU_GENERATOR_FAIL",
  "DSCRT_IN_FDR_TEST_MODE",
  "EAU_FUEL_RETURN",
  "EAU_LEFT_WING_HEAVY",
  "EAU_RIGHT_WING_HEAVY",
  "EAU_OVER_PERCENT_NG",
  "DSCRT_IN_FUEL_SLCT_OFF_L",
  "DSCRT_IN_FUEL_SLCT_OFF_R",
  "DSCRT_IN_A_ICE_NORM_MODE",
  "DSCRT_IN_A_ICE_HIGH_MODE",
  "DSCRT_IN_STBY_PWR_INOP",
  "DSCRT_IN_ALT_OVRHT",
  "DSCRT_IN_CHIP_ACC",
  "DSCRT_IN_CHIP_RED",
  "DSCRT_IN_BAT_HOT",
  "DSCRT_IN_ETM_FAULT",
  "DSCRT_IN_ETM_EVENT_1",
  "DSCRT_IN_ETM_EVENT_2",
  "DSCRT_IN_ETM_ENG_OFF",
  "DSCRT_IN_ETM_CAPTURE",
  "DSCRT_IN_PROP_HEAT_AUTO",
  "DSCRT_IN_CB_NOT_ENGAGED",
  "DSCRT_IN_CABIN_HEAT_ON",
  "DSCRT_IN_STALL_WARN_VANE_HTR_ON",
  "DSCRT_IN_GEN_OVRHT",
  "EAU_STALL_HEATER_TEMP",
  "FUEL_SELECT_OFF_A",
  "FUEL_SELECT_OFF_B",
  "ETM_TREND",
  "DSCRT_IN_BLEED_OFF",
  "DSCRT_IN_BLEED_TEMP",
  "DSCRT_IN_ECS_FAULT_1",
  "DSCRT_IN_ECS_FAULT_2",
  "DSCRT_IN_P3_STATUS",
  "EAU_WINDSHIELD_HEAT",
  "ALRT_DSCRT_OUT_0",
  "ALRT_DSCRT_OUT_1",
  "ALRT_DSCRT_OUT_2",
  "ALRT_DSCRT_OUT_3",
  "ALRT_DSCRT_OUT_4",
  "ALRT_DSCRT_OUT_5",
  "ALRT_DSCRT_OUT_6",
  "ALRT_DSCRT_OUT_7",
  "ALRT_DSCRT_OUT_8",
  "ALRT_DSCRT_OUT_9",
  "ALRT_DSCRT_OUT_10",
  "ALRT_DSCRT_OUT_11",
  "ALRT_DSCRT_OUT_12",
  "ALRT_DSCRT_OUT_13",
  "ALRT_DSCRT_OUT_14",
  "ALRT_DSCRT_OUT_15",
  "ALRT_DSCRT_OUT_16",
  "ALRT_DSCRT_OUT_17",
  "ALRT_DSCRT_OUT_18",
  "ALRT_DSCRT_OUT_19",
  "FADEC_LH_FADEC_CHAN_DSBLD",
  "FADEC_LH_FADEC_LW_VOLT_FLT",
  "FADEC_LH_OIL_PRES_SENS_FLT",
  "FADEC_LH_OIL_TEMP_SENS_FLT",
  "FADEC_LH_ENG_OVRSPD",
  "FADEC_LH_HIGH_OIL_TEMP",
  "FADEC_LH_LW_IDL_OIL_PRES",
  "FADEC_LH_HIGH_OIL_PRES",
  "FADEC_LH_CHT_OVRTMP_FW4",
  "FADEC_LH_EGT_OVRTMP_FW4",
  "FADEC_LH_HOT_HD_OPERATION",
  "FADEC_LH_LW_TKFF_OIL_TEMP",
  "FADEC_LH_LW_TKFF_CHT",
  "FADEC_LH_FADEC_TST_STATUS",
  "EAU_BRAKE_TEMP_L",
  "EAU_BRAKE_TEMP_R",
  "EAU_ENG_1_MAT",
  "DSCRT_IN_ALT_AIR_DOOR_OPEN",
  "DSCRT_IN_FLAPS_100_PCNT",
  "DSCRT_IN_FLAPS_50_PCNT",
  "DSCRT_IN_FLAPS_0_PCNT",
  "DSCRT_IN_FUEL_FLTR_BYPASS",
  "DSCRT_IN_DEICE_PUMP_SETTING_MAX",
  "DSCRT_IN_DEICE_PUMP_SETTING_NRML",
  "DSCRT_IN_OXYGEN_SYS_FAULT",
  "DSCRT_IN_OXYGEN_SYS_OFF",
  "DSCRT_IN_OXYGEN_RQD",
  "LOW_OIL_PRESS",
  "LANDING_GEAR",
  "EAU_FREQUENCY",
  "AFCS_1_ALERTS",
  "AFCS_2_ALERTS",
  "DSCRT_IN_CVR_ERASE",
  "DSCRT_IN_CVR_FAIL",
  "AOA_LOCAL",
  "EAU_FUEL_QNTY_L_FAIL",
  "EAU_FUEL_QNTY_R_FAIL",
  "ENG_1_FADEC_LBL_272",
  "ENG_2_FADEC_LBL_272",
  "ENG_1_FADEC_LBL_350",
  "ENG_2_FADEC_LBL_350",
  "ENG_1_ITT_GAUGE_MAX_1",
  "ENG_1_ITT_GAUGE_MAX_2",
  "ENG_1_ITT_GAUGE_TRANS_MAX_1",
  "ENG_1_ITT_GAUGE_TRANS_MAX_1_DUR",
  "ENG_1_ITT_GAUGE_TRANS_MAX_2",
  "ENG_1_ITT_GAUGE_TRANS_MAX_2_DUR",
  "ENG_1_ITT_GAUGE_TRANS_MAX_3",
  "ENG_1_ITT_GAUGE_TRANS_MAX_3_DUR",
  "ENG_1_ITT_GAUGE_TRANS_MAX_4",
  "ENG_1_ITT_GAUGE_TRANS_MAX_4_DUR",
  "ENG_1_N1_BUG",
  "ENG_1_N1_HI_WARN_DUR",
  "ENG_1_N2_HI_WARN_DUR",
  "ENG_1_OIL_PRES_HI_WARN_DUR",
  "ENG_1_OIL_PRES_LO_WARN_DUR",
  "ENG_1_OIL_TEMP_HI_WARN_DUR",
  "ENG_1_OIL_PRES_LO_CAUT_2",
  "EAU_MAINT_FAULT_RESET",
  "EAU_FLT_IDLE_SELECT",
  "DSCRT_OUT_RESERVE_5",
  "ENG_1_GAS_GEN_IDLE_SPD",
  "ENG_2_GAS_GEN_IDLE_SPD",
  "ENG_1_BLEED_CMD",
  "ENG_2_BLEED_CMD",
  "ENG_1_GAS_GEN_REQ_SPD",
  "ENG_2_GAS_GEN_REQ_SPD",
  "ENG_1_TORQUE_MTR_CURRENT",
  "ENG_2_TORQUE_MTR_CURRENT",
  "ENG_1_FADEC_CTRL_LOOP",
  "ENG_2_FADEC_CTRL_LOOP",
  "GWX_RDR_CMD_GX000",
  "ENG_1_ECU_TS",
  "ENG_2_ECU_TS",
  "DSCRT_OUT_RESERVE_1",
  "DSCRT_OUT_RESERVE_2",
  "DSCRT_OUT_RESERVE_3",
  "ENG_1_FADEC_CSC_FAULT",
  "ENG_2_FADEC_CSC_FAULT",
  "FUEL_CH_1_LBL_274",
  "FUEL_CH_2_LBL_274",
  "EAU_IN_RESERVE_11",
  "EAU_IN_RESERVE_12",
  "EAU_IN_RESERVE_13",
  "EAU_IN_RESERVE_14",
  "EAU_IN_RESERVE_15",
  "EAU_IN_RESERVE_16",
  "DSCRT_IN_CAPS_HNDL_PULLED",
  "DSCRT_IN_CAPS_RCKT_DEPLOYED",
  "FUEL_XFEED_SWITCH_LOW_L",
  "FUEL_XFEED_SWITCH_LOW_R",
  "ECS_AI_WNG_STB_CTRL_PRS_LH",
  "ECS_AI_WNG_STB_CTRL_PRS_RH",
  "ECS_BLD_CTRL_PRS_LH",
  "ECS_BLD_CTRL_PRS_RH",
  "ECS_CAS_MESSAGE_272",
  "ECS_CMC_MSG_LH_350",
  "ECS_CMC_MSG_RH_350",
  "ECS_CMC_MESSAGE_BL_351",
  "ECS_FCV_COMMAND_LH_306",
  "ECS_FCV_COMMAND_RH_306",
  "ECS_SYS_STAT_270",
  "EAU_ANGLE_OF_ATTACK",
  "EAU_FUEL_TEMP_VALID_L",
  "EAU_FUEL_TEMP_VALID_R",
  "AIR_FILTER",
  "COOLANT_LVL_LOW",
  "GLOW_PLUG_ON",
  "FADEC_A_FAIL",
  "FADEC_B_FAIL",
  "FORCE_FADEC_B",
  "WATER_DETECT",
  "TLERT_ENG_2_CH_A_ACTV",
  "TLERT_ENG_2_CH_B_ACTV",
  "EAU_ALT_SWITCH_2",
  "EAU_SWITCH_1",
  "EAU_SWITCH_2",
  "EAU_SWITCH_3",
  "EAU_SWITCH_4",
  "EAU_VAC_LO_2",
  "EAU_FADEC_BUS_A_VOLTS",
  "EAU_FADEC_BUS_B_VOLTS",
  "EAU_EXTERNAL_PWR_VOLTS",
  "EAU_ENG_2_LOW_OIL_PRESS",
  "XPDR_1_A429_CFG_RX",
  "XPDR_1_A429_CFG_TX",
  "XPDR_1_CMND",
  "XPDR_1_CNFG_CRC",
  "XPDR_1_DATA",
  "XPDR_1_DATA_RX",
  "XPDR_1_INSTL_RX",
  "XPDR_1_INSTL_TX",
  "XPDR_1_RS232_CFG_RX",
  "XPDR_1_RS232_CFG_TX",
  "XPDR_1_REPLY",
  "XPDR_1_STATUS",
  "XPDR_2_A429_CFG_RX",
  "XPDR_2_A429_CFG_TX",
  "XPDR_2_CMND",
  "XPDR_2_CNFG_CRC",
  "XPDR_2_DATA",
  "XPDR_2_DATA_RX",
  "XPDR_2_INSTL_RX",
  "XPDR_2_INSTL_TX",
  "XPDR_2_RS232_CFG_RX",
  "XPDR_2_RS232_CFG_TX",
  "XPDR_2_REPLY",
  "XPDR_2_STATUS",
  "YD_AUTO_DISENGAGE",
  "ENG_1_FADEC_OAT_CH_A",
  "ENG_1_FADEC_OAT_CH_B",
  "ENG_2_FADEC_OAT_CH_A",
  "ENG_2_FADEC_OAT_CH_B",
  "ADC_2_ACTV_SENSOR",
  "GMA_1_VOL_CMD",
  "GMA_2_VOL_CMD",
  "GMA_1_VOL_SQL_STATUS",
  "GMA_2_VOL_SQL_STATUS",
  "EAU_ENG_1_FP_WARN",
  "EAU_ENG_2_FP_WARN",
  "EAU_ENG_1_OL",
  "EAU_ENG_2_OL",
  "EAU_ENG_1_GLOW_ON",
  "EAU_ENG_2_GLOW_ON",
  "DSCRT_IN_INHIBIT_GPWS",
  "DSCRT_IN_INHIBIT_GPWS_FLAPS",
  "DSCRT_IN_INHIBIT_GPWS_GSD",
  "DSCRT_IN_INHIBIT_TAWS",
  "DSCRT_IN_INHIBIT_GPWS_TAWS_ALL",
  "DSCRT_OUT_INHIBIT_GPWS",
  "DSCRT_OUT_INHIBIT_GPWS_FLAPS",
  "DSCRT_OUT_INHIBIT_GPWS_GSD",
  "DSCRT_OUT_INHIBIT_TAWS",
  "DSCRT_OUT_INHIBIT_GPWS_TAWS_ALL",
  "ECS_FSHNESS_COUNTER",
  "ECS_SYS_STAT_270_CH_A",
  "ECS_AMS_SOFTWARE_VER_207",
  "ECS_CAS_MESSAGE_271_CH_A",
  "ECS_PRSOV_PSN_LH",
  "ECS_PRSOV_PSN_RH",
  "ECS_PRSOV_TRQ_MTR_LH",
  "ECS_PRSOV_TRQ_MTR_RH",
  "ECS_FAV_POSITION_LH",
  "ECS_FAV_POSITION_RH",
  "ECS_FAV_TRQ_MTR_LH",
  "ECS_FAV_TRQ_MTR_RH",
  "ECS_XBV_POSITION",
  "ECS_XBV_TRQ_MTR_CRNT",
  "ECS_AIV_POSITION_LH",
  "ECS_AIV_POSITION_RH",
  "ECS_AIV_TRQ_MTR_LH",
  "ECS_AIV_TRQ_MTR_RH",
  "ECS_AI_WNG_TP_PRS_LH",
  "ECS_AI_WNG_TP_PRS_RH",
  "ECS_AI_STB_TIP_PRS_LH",
  "ECS_AI_STB_TIP_PRS_RH",
  "ECS_BLD_CTRL_TEMP_LH",
  "ECS_BLD_CTRL_TEMP_RH",
  "ECS_BLD_MON_TEMP_LH",
  "ECS_BLD_MON_TEMP_RH",
  "ECS_BLD_MON_PRS_LH",
  "ECS_BLD_MON_PRS_RH",
  "ENG_1_N1_MIN_AI",
  "ENG_2_N1_MIN_AI",
  "ENG_1_N1_GA_RSV",
  "ENG_2_N1_GA_RSV",
  "ECS_CAS_MESSAGE_272_CH_A",
  "ECS_CAS_MESSAGE_272_CH_B",
  "ADF_1_DIAGNOSTIC_350",
  "ADF_1_BFO",
  "ADF_1_ANT_ADF",
  "ADF_1_FREQUENCY_IN",
  "EAU_ENG_1_AI_VALVE_POS",
  "EAU_ENG_2_AI_VALVE_POS",
  "DSCRT_IN_RUDDER_GUST_LOCK",
  "GWX_STATUS_GX000",
  "ATN_CM_CMD",
  "ATN_CM_STS",
  "EAU_BRAKE_PRESS_L",
  "EAU_BRAKE_PRESS_R",
  "EAU_BRAKE_PEDAL_DISP_L",
  "EAU_BRAKE_PEDAL_DISP_R",
  "ATN_IS_CFG",
  "ATN_DLR_PDU",
  "ECS_SYS_STAT_270_CH_B",
  "ECS_CAS_MESSAGE_271",
  "ECS_CAS_MESSAGE_271_CH_B",
  "CRTCL_PHSE_OF_FLGHT",
  "GTS_CFG_ACT",
  "GTS_CFG_CRC",
  "GTS_CFG_SET",
  "GTS_CFG_AUD_RQST",
  "GTS_SYS_CMD",
  "GTS_SYS_STATUS",
  "GTS_TRF_CMD",
  "GTS_CMD_STATUS",
  "EAU_FADEC_TAKEOFF_LATCH",
  "ECS_1_BUS_VALID",
  "ECS_2_BUS_VALID",
  "ENG_1_FADEC_LBL_353_CH_A",
  "ENG_1_FADEC_LBL_353_CH_B",
  "ENG_2_FADEC_LBL_353_CH_A",
  "ENG_2_FADEC_LBL_353_CH_B",
  "FUEL_XFEED_SWITCH_OFF",
  "ENG_1_GAS_GEN_SPD_DERIV",
  "ENG_2_GAS_GEN_SPD_DERIV",
  "ENG_1_GAS_GEN_SPD_DBL_DERIV",
  "ENG_2_GAS_GEN_SPD_DBL_DERIV",
  "ENG_1_STAT_1_FAN_SPD",
  "ENG_2_STAT_1_FAN_SPD",
  "ENG_1_GAS_GEN_ACCEL_REF",
  "ENG_2_GAS_GEN_ACCEL_REF",
  "ENG_1_GAS_GEN_DECEL_REF",
  "ENG_2_GAS_GEN_DECEL_REF",
  "ENG_1_STAT_1_GAS_GEN_SPD",
  "ENG_2_STAT_1_GAS_GEN_SPD",
  "ENG_1_STAT_25_GAS_GEN_SPD",
  "ENG_2_STAT_25_GAS_GEN_SPD",
  "ENG_1_FAN_SPD_DERIV",
  "ENG_2_FAN_SPD_DERIV",
  "ENG_1_FAN_SPD_DBL_DERIV",
  "ENG_2_FAN_SPD_DBL_DERIV",
  "ENG_1_N2_AICE_IDLE_SPD",
  "ENG_2_N2_AICE_IDLE_SPD",
  "EAU_ACCELERATION_X",
  "EAU_ACCELERATION_Y",
  "EAU_ACCELERATION_Z",
  "EAU_ENG_1_FUEL_PRESS_MV",
  "EAU_ENG_2_FUEL_PRESS_MV",
  "ECS_CKPT_FCSOV_AIR_IN",
  "ECS_CABIN_FCSOV_AIR_IN",
  "FADEC_RH_DATA_LOSS",
  "FADEC_RH_INJ_MODE",
  "ENG_1_TLA_TRIM_SLOPE",
  "ENG_2_TLA_TRIM_SLOPE",
  "ENG_1_N2_AICE_IDLE_OEI_SPD",
  "ENG_2_N2_AICE_IDLE_OEI_SPD",
  "ENG_1_FADEC_LBL_357",
  "ENG_2_FADEC_LBL_357",
  "FUEL_USED_TOTALIZER",
  "DSCRT_OUT_GPWS_NOT_AV",
  "DSCRT_OUT_GSD_CTN",
  "DSCRT_OUT_TAWS_CTN",
  "DSCRT_OUT_TAWS_NOT_AV",
  "DSCRT_OUT_TAWS_WARN",
  "XPDR_1_ADSB_STATE",
  "XPDR_2_ADSB_STATE",
  "XPDR_1_AIRCRFT_SZ_CFG_RX",
  "XPDR_1_AIRCRFT_SZ_CFG_TX",
  "XPDR_2_AIRCRFT_SZ_CFG_RX",
  "XPDR_2_AIRCRFT_SZ_CFG_TX",
  "XPDR_1_ADSB_TX_CFG_RX",
  "XPDR_1_ADSB_TX_CFG_TX",
  "XPDR_2_ADSB_TX_CFG_RX",
  "XPDR_2_ADSB_TX_CFG_TX",
  "XPDR_1_EHS_CFG_RX",
  "XPDR_1_EHS_CFG_TX",
  "XPDR_2_EHS_CFG_RX",
  "XPDR_2_EHS_CFG_TX",
  "XPDR_1_SIL_CFG_RX",
  "XPDR_1_SIL_CFG_TX",
  "XPDR_2_SIL_CFG_RX",
  "XPDR_2_SIL_CFG_TX",
  "EAU_DEICE_FLUID_FLW_RATE",
  "DSCRT_IN_LH_DEICE_EMPTY",
  "DSCRT_IN_RH_DEICE_EMPTY",
  "DSCRT_IN_DEICE_PUMP_BKUP",
  "XPDR_1_CFG_CRC_NO_FLT_ID",
  "XPDR_2_CFG_CRC_NO_FLT_ID",
  "XPDR_1_FORCED_STBY_STATE",
  "XPDR_2_FORCED_STBY_STATE",
  "FLC_SPD_REF_ACTV",
  "FADEC_LH_FW_1",
  "FADEC_LH_FW_2",
  "FADEC_LH_FW_3",
  "FADEC_LH_FW_4",
  "FADEC_LH_CTRL_STAT",
  "AICE_TANK_SEL_MODE",
  "ENG_1_FADEC_CSC_CAS",
  "ENG_2_FADEC_CSC_CAS",
  "ENG_1_FADEC_CSC_MACH",
  "ENG_2_FADEC_CSC_MACH",
  "EAU_LH_GCU_STATUS_3",
  "EAU_RH_GCU_STATUS_3",
  "ECS_CKPT_VCS_H_PRS",
  "ECS_CKPT_VCS_L_PRS",
  "ECS_CKPT_DTS",
  "ECS_CBIN_VCS_H_PRS",
  "ECS_CBIN_VCS_L_PRS",
  "ECS_CBIN_DTS",
  "DSCRT_IN_RESERVE_12",
  "DSCRT_IN_RESERVE_13",
  "AFCS_SPD_BUG_ANNUNC",
  "ACTV_SPD_REF_LIMITS",
  "ACTV_SPD_REF_AFCS_LIM_OFST",
  "EAU_FLAPS_LEVER_POSITION",
  "EAU_PITOT_HEAT_AMPS_2",
  "EAU_FUEL_PUMP_AMPS",
  "EAU_T2_HEAT_1_AMPS",
  "EAU_T2_HEAT_2_AMPS",
  "EAU_BLEED_DUCT_TEMP",
  "DSCRT_IN_FIRE_ALRM_1",
  "DSCRT_IN_FIRE_ALRM_2",
  "DSCRT_BUS_TIE_CLSD",
  "DSCRT_FUEL_PUMP_ON",
  "DSCRT_FSOV_CLSD",
  "DSCRT_FSOV_OPEN",
  "DSCRT_FUEL_PRESS_LOW",
  "DSCRT_FUEL_PRESS_NOT_LOW",
  "DSCRT_FUEL_FLTR_NOT_BYPASS",
  "DSCRT_OIL_PRESS_NOT_LOW",
  "DSCRT_OIL_FLTR_BYPASS",
  "DSCRT_OIL_FLTR_NOT_BYPASS",
  "PRESS_SYS_TEST",
  "PREDICTED_ASPD",
  "BRAKE_LH_CVC",
  "BRAKE_RH_CVC",
  "BRAKE_SVC",
  "BRAKE_LH_BPP_PIL",
  "BRAKE_RH_BPP_PIL",
  "BRAKE_LH_BPP_COPIL",
  "BRAKE_RH_BPP_COPIL",
  "BRAKE_FAIL_LBL_4",
  "BRAKE_STAT_LBL_271",
  "BRAKE_STAT_LBL_272",
  "ECS_LH_350_CH_A",
  "ECS_RH_350_CH_A",
  "ECS_LH_350_CH_B",
  "ECS_RH_350_CH_B",
  "ECS_LBL_351_CH_A",
  "ECS_LBL_351_CH_B",
  "ENG_1_FLT_FDC_OAT",
  "ENG_2_FLT_FDC_OAT",
  "ENG_1_FILTERED_ITT",
  "ENG_2_FILTERED_ITT",
  "FUEL_CH1_PRB_CAP_1",
  "FUEL_CH1_PRB_CAP_2",
  "FUEL_CH1_PRB_CAP_3",
  "FUEL_CH1_PRB_CAP_4",
  "FUEL_CH2_PRB_CAP_1",
  "FUEL_CH2_PRB_CAP_2",
  "FUEL_CH2_PRB_CAP_3",
  "FUEL_CH2_PRB_CAP_4",
  "EAU_T2_HTR_ON",
  "ECS_LH_306_CH_A",
  "ECS_RH_306_CH_A",
  "ECS_LH_306_CH_B",
  "ECS_RH_306_CH_B",
  "EAU_FUEL_TEMP",
  "EAU_FUEL_TEMP_C",
  "DSCRT_IN_YD_ACTV",
  "ENG_1_FADEC_LBL_351",
  "ENG_2_FADEC_LBL_351",
  "ENG_1_FADEC_LBL_273",
  "ENG_2_FADEC_LBL_273",
  "ENG_1_TT2",
  "ENG_2_TT2",
  "ENG_1_N2_BUG",
  "EAU_ENG_1_TN2",
  "EAU_ENG_2_TN2",
  "ENG_1_FFLOW_OFST",
  "CAL_FUEL_QTY_L",
  "CAL_FUEL_QTY_R",
  "ELEC_LBL_170",
  "ELEC_LBL_171",
  "EAU_OXYGEN_FAIL",
  "EAU_OXYGEN_FAULT",
  "EAU_DEICE_TEMP",
  "EAU_ELEC_DOOR_OPEN",
  "EAU_TOT_FUEL_QNTY",
  "ECS_BLD_CTRL_TEMP_LH_CH_A",
  "ECS_BLD_CTRL_TEMP_RH_CH_A",
  "ECS_BLD_CTRL_TEMP_LH_CH_B",
  "ECS_BLD_CTRL_TEMP_RH_CH_B",
  "ECS_BLD_MON_TEMP_LH_CH_A",
  "ECS_BLD_MON_TEMP_RH_CH_A",
  "ECS_BLD_MON_TEMP_LH_CH_B",
  "ECS_BLD_MON_TEMP_RH_CH_B",
  "ECS_BLD_CTRL_PRS_LH_CH_A",
  "ECS_BLD_CTRL_PRS_RH_CH_A",
  "ECS_BLD_CTRL_PRS_LH_CH_B",
  "ECS_BLD_CTRL_PRS_RH_CH_B",
  "ECS_AMS_SOFTWARE_VER_207_CH_A",
  "ECS_AMS_SOFTWARE_VER_207_CH_B",
  "ECS_PRSOV_PSN_LH_CH_A",
  "ECS_PRSOV_PSN_RH_CH_A",
  "ECS_PRSOV_PSN_LH_CH_B",
  "ECS_PRSOV_PSN_RH_CH_B",
  "ECS_PRSOV_TRQ_MTR_LH_CH_A",
  "ECS_PRSOV_TRQ_MTR_RH_CH_A",
  "ECS_PRSOV_TRQ_MTR_LH_CH_B",
  "ECS_PRSOV_TRQ_MTR_RH_CH_B",
  "ECS_FAV_POSITION_LH_CH_A",
  "ECS_FAV_POSITION_RH_CH_A",
  "ECS_FAV_POSITION_LH_CH_B",
  "ECS_FAV_POSITION_RH_CH_B",
  "ECS_FAV_TRQ_MTR_LH_CH_A",
  "ECS_FAV_TRQ_MTR_RH_CH_A",
  "ECS_FAV_TRQ_MTR_LH_CH_B",
  "ECS_FAV_TRQ_MTR_RH_CH_B",
  "ECS_XBV_POSITION_CH_A",
  "ECS_XBV_POSITION_CH_B",
  "ECS_XBV_TRQ_MTR_CRNT_CH_A",
  "ECS_XBV_TRQ_MTR_CRNT_CH_B",
  "ECS_FSHNESS_COUNTER_CH_A",
  "ECS_FSHNESS_COUNTER_CH_B",
  "COM_1_INSTALL_CAL_RX",
  "COM_1_INSTALL_CAL_TX",
  "COM_2_INSTALL_CAL_RX",
  "COM_2_INSTALL_CAL_TX",
  "LOAD_APPR",
  "LOAD_ARVL",
  "LOAD_DPRT",
  "LOAD_WPT",
  "DSCRT_IN_FLOAT_TEST_GROUND",
  "DSCRT_IN_ENG_DEICE_PRES_HI",
  "DSCRT_IN_AUTO_RELITE",
  "DSCRT_IN_LITTER_DOOR_OPEN",
  "DSCRT_IN_LH_FUEL_BOOST_FL",
  "DSCRT_IN_LH_FUEL_XFER_FL",
  "DSCRT_IN_RH_FUEL_BOOST_FL",
  "DSCRT_IN_RH_FUEL_XFER_FL",
  "DSCRT_IN_FUEL_VALVE_FL",
  "DSCRT_IN_FADEC_FLT",
  "DSCRT_IN_RESTART_FLT",
  "DSCRT_IN_FADEC_FL",
  "DSCRT_IN_FADEC_DGRD",
  "DSCRT_IN_FADEC_MAN",
  "DSCRT_IN_CHIP_XMSN",
  "DSCRT_IN_CHIP_TR",
  "DSCRT_IN_XMSN_LOW_OIL_PRESS",
  "DSCRT_IN_BATT_RLY_FL",
  "DSCRT_IN_XMSN_OIL_TEMP_HI",
  "DSCRT_IN_CYCLIC_NOT_CENTERED",
  "DSCRT_IN_ENG_OUT",
  "DSCRT_IN_PEDAL_STOP_FLT",
  "DSCRT_IN_RPM_LIMIT",
  "DSCRT_IN_FUEL_QTY_INV",
  "DSCRT_IN_AUX_TANK_INST",
  "DSCRT_IN_PEDAL_STOP_A",
  "DSCRT_IN_FWD_TANK_SEL",
  "DSCRT_IN_QUIET_MODE",
  "DSCRT_IN_QUIET_MODE_ON",
  "DSCRT_IN_PEDAL_STOP_TEST",
  "DSCRT_IN_REV_ACTV",
  "DSCRT_IN_ROTOR_BRK_1",
  "DSCRT_IN_ENG_PAGE",
  "DSCRT_IN_ROTOR_BRK_2",
  "DSCRT_IN_ENG_OP_SW",
  "DSCRT_IN_ENG_OT_SW",
  "DSCRT_OUT_ENG_OUT",
  "DSCRT_OUT_PEDAL_STOP_CTRL",
  "DSCRT_OUT_ROTOR_RPM",
  "DSCRT_OUT_LOW_RPM_WARN",
  "DSCRT_OUT_RPM_WARN",
  "DSCRT_IN_FLOAT_TEST",
  "DSCRT_IN_FLOAT_ARMED",
  "DSCRT_IN_HEATER_OVERTEMP",
  "DSCRT_IN_ENG_DEICE_OFF",
  "DSCRT_IN_FUEL_VALVE_OPEN",
  "DSCRT_IN_FUEL_VALVE_CLSD",
  "DSCRT_IN_CARGO_HOOK_ARM",
  "DSCRT_IN_PEDAL_STOP_B",
  "EAU_XMSN_OT_1",
  "EAU_XMSN_OT_2",
  "EAU_XMSN_OP",
  "EAU_GEN_AMPS",
  "EAU_GEN_AMPS_MON1",
  "EAU_GEN_AMPS_MON2",
  "LRU_PKT_ENBL",
  "LOAD_DIRECT_TO",
  "SET_USR_WPT",
  "PILOT_EP_ENABLED",
  "SPEED_FROM_APPROACH",
  "AFCS_ENGAGE_EDM",
  "COM_1_CAL_CRC",
  "COM_2_CAL_CRC",
  "DSCRT_IN_BRAKE_TEMP_L_WARN",
  "DSCRT_IN_BRAKE_TEMP_R_WARN",
  "DSCRT_IN_BRAKE_TEMP_L_CAUT",
  "DSCRT_IN_BRAKE_TEMP_R_CAUT",
  "DSCRT_IN_RPM_MUTE",
  "DSCRT_IN_FADEC_MUTE",
  "DSCRT_IN_RP_MODE_SELECT",
  "GPS_ALT_AGL",
  "DSCRT_OUT_RP_MODE_SELECT",
  "DSCRT_IN_TAWS_MUTE_CTN",
  "DSCRT_OUT_TAWS_MUTE_CTN",
  "GDR_STAT",
  "GDR_VD_SELECT",
  "GDR_LINK_STATUS",
  "GDR_CMND_RX",
  "GDR_CMND_TX",
  "GDR_TUNE_FREQ",
  "GDR_VOL_TX",
  "GDR_SYS_CMD",
  "ARC_EVENT",
  "ARC_OPTION",
  "ARC_TEXT",
  "ARC_VOL_SQ_DATA",
  "ARC_ANNUN_DATA",
  "GMA_1_STATUS",
  "GMA_1_AUX_STATUS",
  "GMA_2_STATUS",
  "GMA_2_AUX_STATUS",
  "GMA_1_SYS_CMD",
  "GMA_1_AUX_SYS_CMD",
  "GMA_2_SYS_CMD",
  "GMA_2_AUX_SYS_CMD",
  "GMA_1_TEST_DATA",
  "GMA_2_TEST_DATA",
  "GMA_PTC_CLICK",
  "GMA_1_MKR_SENSE",
  "GMA_2_MKR_SENSE",
  "GMA_CFG_DATA",
  "GMA_CFG_CRC",
  "GMA_1_LGHT_DATA",
  "GMA_2_LGHT_DATA",
  "GMA_1_MODE",
  "GMA_2_MODE",
  "GMA_1_AUX_MODE",
  "GMA_2_AUX_MODE",
  "DSCRT_IN_AFCS_LVL_GIA1",
  "DSCRT_IN_AFCS_LVL_BCKUP_GIA1",
  "DSCRT_IN_AFCS_LVL_GIA2",
  "DSCRT_IN_AFCS_LVL_BCKUP_GIA2",
  "GTC_1_STATUS",
  "GTC_2_STATUS",
  "XFIL_REG_TAG_TBL_GTC_1",
  "XFIL_REG_TAG_TBL_GTC_2",
  "XFIL_REG_DATA_GTC_1",
  "XFIL_REG_DATA_GTC_2",
  "OXYGEN_PAX_OFF",
  "OXYGEN_VALVE_OPEN",
  "OXYGEN_VALVE_CLOSED",
  "EAU_HYDRAULIC_ACC_BRAKE",
  "EAU_HYDRAULIC_ACC_EMER",
  "EAU_HYDRAULIC_ACC_MAIN",
  "EAU_HYDRAULIC_FLUID",
  "EPS_GCU1_LBL_270",
  "EPS_GCU2_LBL_276",
  "EPS_PDU1_LBL_231",
  "EPS_PDU1_LBL_233",
  "EPS_PDU1_LBL_234",
  "EPS_PDU2_LBL_271",
  "EPS_PDU2_LBL_273",
  "EPS_PDU2_LBL_274",
  "BRAKE_LEFT_XDCR_FAIL",
  "BRAKE_RIGHT_XDCR_FAIL",
  "BRAKE_WOW_DSGR",
  "SPEED_BRAKE_LEVER",
  "SPEED_BRAKE_ACT",
  "SPEED_BRAKE_RETR",
  "NS_GEAR_ON_GROUND",
  "NS_GEAR_ON_GROUND_2",
  "OXYGEN_PRESS_LOW",
  "EAU_LH_FUEL_BOOST_FAIL",
  "EAU_RH_FUEL_BOOST_FAIL",
  "HYDRAULIC_FAULT",
  "HYD_PUMP_MAINT_SWTCH",
  "IRPS_LEFT_WDSH_TEMP",
  "IRPS_RIGHT_WDSH_TEMP",
  "IRPS_LEFT_WDSH_SWITCH",
  "IRPS_RIGHT_WDSH_SWITCH",
  "EAU_WHEEL_SPEED",
  "IRPS_WDSH_CTRL_1_FAIL",
  "IRPS_WDSH_CTRL_2_FAIL",
  "IRPS_WDSH_LEFT_OVERHEAT",
  "IRPS_WDSH_RIGHT_OVERHEAT",
  "FUEL_CH_3_LBL_350",
  "ENG_1_FADEC_LBL_322",
  "ENG_1_FADEC_LBL_322_CH_A",
  "ENG_1_FADEC_LBL_322_CH_B",
  "ENG_2_FADEC_LBL_322",
  "ENG_2_FADEC_LBL_322_CH_A",
  "ENG_2_FADEC_LBL_322_CH_B",
  "ENG_1_FADEC_LBL_323",
  "ENG_1_FADEC_LBL_323_CH_A",
  "ENG_1_FADEC_LBL_323_CH_B",
  "ENG_2_FADEC_LBL_323",
  "ENG_2_FADEC_LBL_323_CH_A",
  "ENG_2_FADEC_LBL_323_CH_B",
  "ENG_1_FADEC_LBL_274",
  "ENG_2_FADEC_LBL_274",
  "ENG_1_FUEL_FLTR_DIFF_PRES",
  "ENG_2_FUEL_FLTR_DIFF_PRES",
  "ENG_1_FUEL_FLTR_IMP_BYP",
  "ENG_2_FUEL_FLTR_IMP_BYP",
  "ENG_1_FUEL_FLTR_BYP",
  "ENG_2_FUEL_FLTR_BYP",
  "ENG_1_OIL_FLTR_DIFF_PRES",
  "ENG_2_OIL_FLTR_DIFF_PRES",
  "ENG_1_OIL_FLTR_IMP_BYP",
  "ENG_2_OIL_FLTR_IMP_BYP",
  "ENG_1_OIL_FLTR_BYP",
  "ENG_2_OIL_FLTR_BYP",
  "ENG_1_MIN_NO_CHIP_LVL",
  "ENG_2_MIN_NO_CHIP_LVL",
  "FUEL_DNSTY_L",
  "FUEL_DNSTY_R",
  "EAU_CAB_DOOR_OPEN",
  "EAU_LAV_SRVC_DOOR_OPEN",
  "EAU_TAIL_ACC_DOOR_OPEN",
  "EAU_ELEC_SRVC_DOOR_OPEN",
  "EAU_RH_ELEC_SRVC_DOOR_OPEN",
  "EAU_HYD_SRVC_DOOR_OPEN",
  "NOSE_WHEEL_STRG_CTRL_INOP",
  "BATT_SOC_050_1",
  "BATT_SOC_050_2",
  "BATT_SOH_051_1",
  "BATT_SOH_051_2",
  "BATT_ENG_052_1",
  "BATT_ENG_052_2",
  "BATT_TMP_055_1",
  "BATT_TMP_055_2",
  "BATT_DSC_270_1",
  "BATT_DSC_270_2",
  "BATT_DSC_271_1",
  "BATT_DSC_271_2",
  "HYD_RES_EMPTY",
  "NOSE_WHEEL_TRANS_CMD",
  "EAU_CAB_DOOR_OPEN_2",
  "ENG_1_OIL_PRES_MIN_TEMP",
  "ENG_2_OIL_PRES_MIN_TEMP",
  "EAU_ENG_1_FIRE_PUSH",
  "EAU_ENG_2_FIRE_PUSH",
  "EAU_ENG_1_EXT_ARM",
  "EAU_ENG_2_EXT_ARM",
  "EAU_ENG_1_FIRE_BTL_PRES",
  "EAU_ENG_2_FIRE_BTL_PRES",
  "ALT_WARN_STATUS",
  "EPS_PDU1_LBL_300",
  "EPS_PDU2_LBL_340",
  "COWL_TEMP_L",
  "COWL_TEMP_R",
  "MANI_TEMP_L",
  "MANI_TEMP_R",
  "BLEED_TEMP_L",
  "BLEED_TEMP_R",
  "WING_AIV_TEMP_L_1_A",
  "WING_AIV_TEMP_L_2_A",
  "WING_AIV_TEMP_L_3_A",
  "WING_AIV_TEMP_R_1_A",
  "WING_AIV_TEMP_R_2_A",
  "WING_AIV_TEMP_R_3_A",
  "COWL_PRES_L",
  "COWL_PRES_R",
  "MANI_PRES_L",
  "MANI_PRES_R",
  "AFCS_1_HND_CSC",
  "AFCS_2_HND_CSC",
  "WING_AIV_TEMP_L_1_B",
  "WING_AIV_TEMP_L_2_B",
  "WING_AIV_TEMP_L_3_B",
  "WING_AIV_TEMP_R_1_B",
  "WING_AIV_TEMP_R_2_B",
  "WING_AIV_TEMP_R_3_B",
  "ECS_MODE_NORM",
  "EAU_HOT_BUS_VOLTS_1",
  "EAU_HOT_BUS_VOLTS_2",
  "EAU_XSTART_VOLTS_1",
  "EAU_XSTART_VOLTS_2",
  "EAU_SNODE_VOLTS_1",
  "EAU_SNODE_VOLTS_2",
  "EPS_PDU1_LBL_230",
  "EPS_PDU1_LBL_232",
  "EPS_PDU1_LBL_304",
  "EPS_PDU1_LBL_305",
  "EAU_CPT_BLWR_SPD",
  "EAU_CAB_BLWR_SPD",
  "EAU_XFEED_VOLTS",
  "EAU_EXT_PWR_SNSE_VOLTS",
  "EPS_PDU2_LBL_270",
  "EPS_PDU2_LBL_272",
  "EPS_PDU2_LBL_344",
  "EPS_PDU2_LBL_345",
  "DSCRT_OUT_ICE_DETECTED",
  "VCS_CAB_HI_PRESS",
  "VCS_CPT_HI_PRESS",
  "VCS_CAB_LO_PRESS",
  "VCS_CPT_LO_PRESS",
  "VCS_CAB_DIS_0",
  "VCS_CPT_DIS_0",
  "VCS_CAB_DIS_1",
  "VCS_CPT_DIS_1",
  "VCS_CAB_DIS_2",
  "VCS_CPT_DIS_2",
  "VCS_CAB_DIS_3",
  "VCS_CPT_DIS_3",
  "VCS_CAB_DIS_4",
  "VCS_CPT_DIS_4",
  "WORLD_PEACE_MODE_ACTV",
  "EDC_FAULT_BIT_0",
  "EDC_FAULT_BIT_1",
  "EDC_FAULT_BIT_2",
  "DSCRT_IN_RESERVE_1",
  "GDR_AUX_STAT",
  "GDR_AUX_SYS_CMD",
  "GDR_MODE",
  "GDR_AUX_MODE",
  "GDR_COM_DATA",
  "GDR_CFG_DATA",
  "GDR_CFG_CRC",
  "LH_LVR_RATE_FEEDBACK_DSC",
  "LH_LVR_RATE_FEEDBACK_MAG",
  "RH_LVR_RATE_FEEDBACK_DSC",
  "RH_LVR_RATE_FEEDBACK_MAG",
  "TQA_GNR_FAULT_RPT",
  "TQA_SERVO_FAULT_RPT",
  "GMA_3D_CFG_DATA",
  "FDSS_L_ENG_FIRE_DET",
  "FDSS_L_ENG_FIRE_EXT",
  "FDSS_L_ENG_SQUIB",
  "FDSS_R_ENG_FIRE_DET",
  "FDSS_R_ENG_FIRE_EXT",
  "FDSS_R_ENG_SQUIB",
  "ENG_1_MAX_CHIP_LVL",
  "ENG_2_MAX_CHIP_LVL",
  "ENG_1_MIN_CHIP_INV_LVL",
  "ENG_2_MIN_CHIP_INV_LVL",
  "ENG_1_FADEC_LBL_157",
  "ENG_2_FADEC_LBL_157",
  "ENG_1_FADEC_LBL_160",
  "ENG_2_FADEC_LBL_160",
  "EPS_PDU1_LBL_320",
  "EPS_PDU1_LBL_321",
  "EPS_PDU1_LBL_322",
  "EPS_PDU1_LBL_323",
  "EPS_PDU1_LBL_324",
  "EPS_PDU1_LBL_325",
  "EPS_PDU1_LBL_326",
  "EPS_PDU1_LBL_327",
  "EPS_PDU2_LBL_360",
  "EPS_PDU2_LBL_361",
  "EPS_PDU2_LBL_362",
  "EPS_PDU2_LBL_363",
  "EPS_PDU2_LBL_364",
  "EPS_PDU2_LBL_365",
  "EPS_PDU2_LBL_366",
  "EPS_PDU2_LBL_367",
  "EAU_SEL_CABIN_ALT_RATE",
  "EQUIV_PRESS_CYCLES",
  "ENG_1_PT2",
  "ENG_2_PT2",
  "ENG_1_N1_COMP",
  "ENG_2_N1_COMP",
  "ENG_1_LBL_001",
  "ENG_1_LBL_002",
  "ENG_1_LBL_003",
  "ENG_1_LBL_004",
  "ENG_1_LBL_005",
  "ENG_1_LBL_006",
  "ENG_1_LBL_007",
  "ENG_1_LBL_010",
  "ENG_1_LBL_011",
  "ENG_1_LBL_012",
  "ENG_1_LBL_046",
  "ENG_1_LBL_350",
  "ENG_1_LBL_351",
  "ENG_1_LBL_352",
  "ENG_1_LBL_353",
  "ENG_1_LBL_354",
  "ENG_1_LBL_355",
  "ENG_1_LBL_356",
  "ENG_2_LBL_001",
  "ENG_2_LBL_002",
  "ENG_2_LBL_003",
  "ENG_2_LBL_004",
  "ENG_2_LBL_005",
  "ENG_2_LBL_006",
  "ENG_2_LBL_007",
  "ENG_2_LBL_010",
  "ENG_2_LBL_011",
  "ENG_2_LBL_012",
  "ENG_2_LBL_046",
  "ENG_2_LBL_350",
  "ENG_2_LBL_351",
  "ENG_2_LBL_352",
  "ENG_2_LBL_353",
  "ENG_2_LBL_354",
  "ENG_2_LBL_355",
  "ENG_2_LBL_356",
  "ENG_2_N1_BUG",
  "ADF_1_DIAGNOSTIC_371",
  "ECS_CPT_STATUS",
  "ECS_CAB_STATUS",
  "ADF_2_DIAGNOSTIC_350",
  "ADF_2_BFO",
  "ADF_2_ANT_ADF",
  "ADF_2_FREQUENCY_IN",
  "ADF_2_DIAGNOSTIC_371",
  "DME_1_LBL_300",
  "DME_1_LBL_350",
  "DME_1_LBL_371",
  "DME_2_LBL_300",
  "DME_2_LBL_350",
  "DME_2_LBL_371",
  "EAU_RUDDER_POSITION",
  "EAU_ELEVATOR_POSITION_L",
  "EAU_ELEVATOR_POSITION_R",
  "EAU_LH_COCKPIT_DUCT_TEMP",
  "EAU_RH_COCKPIT_DUCT_TEMP",
  "EAU_PILOT_RUDDER_PEDAL_POSITION",
  "EAU_PILOT_WHEEL_PITCH_POSITION",
  "EAU_PILOT_WHEEL_ROLL_POSITION",
  "EAU_ENG_1_FIRE_BTTL_L",
  "EAU_ENG_1_FIRE_BTTL_R",
  "EAU_ENG_2_FIRE_BTTL_L",
  "EAU_ENG_2_FIRE_BTTL_R",
  "EAU_BRAKE_PRESS_L_2",
  "EAU_BRAKE_PRESS_R_2",
  "EAU_COPILOT_RUDDER_PEDAL_POSITION",
  "EAU_COPILOT_WHEEL_PITCH_POSITION",
  "EAU_COPILOT_WHEEL_ROLL_POSITION",
  "EAU_AILERON_POSITION_L",
  "EAU_AILERON_POSITION_R",
  "EAU_PILOT_RUDDER_PEDAL_FORCE",
  "EAU_COPILOT_RUDDER_PEDAL_FORCE",
  "EAU_PILOT_WHEEL_PITCH_FORCE",
  "EAU_COPILOT_WHEEL_PITCH_FORCE",
  "EAU_PILOT_WHEEL_ROLL_FORCE",
  "EAU_COPILOT_WHEEL_ROLL_FORCE",
  "EAU_APU_AMPS",
  "DSCRT_OUT_BATT_L_SOC_TEST",
  "DSCRT_OUT_BATT_R_SOC_TEST",
  "DSCRT_OUT_ENG_1_FIRE_BTTL_L_ARM",
  "DSCRT_OUT_ENG_1_FIRE_BTTL_R_ARM",
  "DSCRT_OUT_ENG_2_FIRE_BTTL_L_ARM",
  "DSCRT_OUT_ENG_2_FIRE_BTTL_R_ARM",
  "DSCRT_OUT_ANNUNC_TEST",
  "DSCRT_OUT_GEAR_TEST",
  "DSCRT_OUT_FLAPS_TEST",
  "DSCRT_OUT_ANTI_ICE_TEST",
  "DSCRT_OUT_EMER_BATT_FAULT_RESET",
  "DSCRT_OUT_EMER_BATT_SOC_TEST",
  "TOTAL_FUEL_USED",
  "DSCRT_OUT_FIRE_DETECT_TEST",
  "EAU_EMER_BATT_TEMP",
  "ECS_CPT_WARMER",
  "ECS_CPT_COOLER",
  "ECS_CAB_WARMER",
  "ECS_CAB_COOLER",
  "ECS_CPT_TEMP_CTL_MAN",
  "ECS_CAB_TEMP_CTL_MAN",
  "FLC_SPD_REF_FMS",
  "FLC_SPD_REF_MAN",
  "ACTV_SPD_REF_MODE",
  "ACTV_SPD_REF_FMS_PROF",
  "IRPS_LEFT_WDSH_TEMP_2",
  "IRPS_RIGHT_WDSH_TEMP_2",
  "ECS_BLD_1_LBL_274",
  "ECS_BLD_2_LBL_274",
  "ECS_BLD_1_LBL_275",
  "ECS_BLD_2_LBL_275",
  "ANTI_ICE_1_BAGGAGE_TEMP",
  "ANTI_ICE_2_BAGGAGE_TEMP",
  "ANTI_ICE_1_CABIN_TEMP",
  "ANTI_ICE_2_CABIN_TEMP",
  "ANTI_ICE_1_ENGINE_TEMP",
  "ANTI_ICE_2_ENGINE_TEMP",
  "ANTI_ICE_1_PYLON_TEMP_1",
  "ANTI_ICE_2_PYLON_TEMP_1",
  "ANTI_ICE_1_PYLON_TEMP_2",
  "ANTI_ICE_2_PYLON_TEMP_2",
  "ANTI_ICE_1_SLAT_TEMP_1",
  "ANTI_ICE_2_SLAT_TEMP_1",
  "ANTI_ICE_1_SLAT_TEMP_2",
  "ANTI_ICE_2_SLAT_TEMP_2",
  "ANTI_ICE_1_STAB_TEMP_1",
  "ANTI_ICE_2_STAB_TEMP_1",
  "ANTI_ICE_1_STAB_TEMP_2",
  "ANTI_ICE_2_STAB_TEMP_2",
  "ANTI_ICE_1_SUPPLY_TEMP",
  "ANTI_ICE_2_SUPPLY_TEMP",
  "ANTI_ICE_1_TAIL_TEMP_1",
  "ANTI_ICE_2_TAIL_TEMP_1",
  "ANTI_ICE_1_TAIL_TEMP_2",
  "ANTI_ICE_2_TAIL_TEMP_2",
  "ANTI_ICE_1_WING_TEMP_1",
  "ANTI_ICE_2_WING_TEMP_1",
  "ANTI_ICE_1_WING_TEMP_2",
  "ANTI_ICE_2_WING_TEMP_2",
  "ANTI_ICE_1_WING_TEMP_3",
  "ANTI_ICE_2_WING_TEMP_3",
  "ANTI_ICE_1_WING_TEMP_4",
  "ANTI_ICE_2_WING_TEMP_4",
  "ANTI_ICE_1_WING_TEMP_5",
  "ANTI_ICE_2_WING_TEMP_5",
  "ANTI_ICE_1_WING_TEMP_6",
  "ANTI_ICE_2_WING_TEMP_6",
  "ANTI_ICE_1_WING_TEMP_7",
  "ANTI_ICE_2_WING_TEMP_7",
  "FUEL_PRESSURE_LOW_L",
  "FUEL_PRESSURE_LOW_R",
  "ENGINE_RUNNING",
  "REFUEL_VALVE",
  "ENG_1_FADEC_LBL_147",
  "ENG_2_FADEC_LBL_147",
  "GSD_3_TICK",
  "EAU_CABIN_ALT_2",
  "EAU_CABIN_ALT_RATE_2",
  "EAU_CABIN_DIFF_PRESS_2",
  "EAU_PRESS_WARN_STATUS_2",
  "ALT_WARN_STATUS_2",
  "PRESS_A429_LBL_270_2",
  "ENG_1_ITT_HI_WARN_START",
  "ENG_2_ITT_HI_WARN_START",
  "ENG_1_ITT_HI_WARN_AIR_START",
  "ENG_2_ITT_HI_WARN_AIR_START",
  "DSCRT_OUT_APU_TEST",
  "DSCRT_OUT_APU_TEST_PASS",
  "EAU_APU_RPM",
  "EAU_APU_EGT",
  "APU_OP_HOURS",
  "APU_START_CYCLES",
  "APU_STATUS_WORD_1",
  "APU_STATUS_WORD_2",
  "DSCRT_FUEL_QNTY_L_FAIL",
  "DSCRT_FUEL_QNTY_R_FAIL",
  "DSCRT_FUEL_QNTY_C_FAIL",
  "DSCRT_FUEL_QNTY_C_2_FAIL",
  "EAU_FUEL_QNTY_C_3",
  "EAU_OXYGEN_PRESS_2",
  "EAU_OXYGEN_TEMP_2",
  "ENG_1_LBL_264",
  "ENG_2_LBL_264",
  "ENG_1_LBL_265",
  "ENG_2_LBL_265",
  "ENG_1_FADEC_LBL_265_CH_A",
  "ENG_1_FADEC_LBL_265_CH_B",
  "ENG_2_FADEC_LBL_265_CH_A",
  "ENG_2_FADEC_LBL_265_CH_B",
  "ENG_1_FADEC_LBL_352_CH_A",
  "ENG_1_FADEC_LBL_352_CH_B",
  "ENG_2_FADEC_LBL_352_CH_A",
  "ENG_2_FADEC_LBL_352_CH_B",
  "ENG_1_FADEC_LBL_354_CH_A",
  "ENG_1_FADEC_LBL_354_CH_B",
  "ENG_2_FADEC_LBL_354_CH_A",
  "ENG_2_FADEC_LBL_354_CH_B",
  "ENG_1_FADEC_LBL_355_CH_A",
  "ENG_1_FADEC_LBL_355_CH_B",
  "ENG_2_FADEC_LBL_355_CH_A",
  "ENG_2_FADEC_LBL_355_CH_B",
  "ENG_1_FADEC_LBL_356_CH_A",
  "ENG_1_FADEC_LBL_356_CH_B",
  "ENG_2_FADEC_LBL_356_CH_A",
  "ENG_2_FADEC_LBL_356_CH_B",
  "DSCRT_OUT_RUN_STOP_ANNUNC",
  "OXYGEN_FLOW_RATE",
  "OXYGEN_PERCENT",
  "BRAKE_WARN_LBL_A",
  "BRAKE_WARN_LBL_B",
  "BRAKE_STAT_LBL_271_A",
  "BRAKE_STAT_LBL_271_B",
  "BRAKE_FAIL_LBL_1_A",
  "BRAKE_FAIL_LBL_1_B",
  "FUEL_CH_1_LBL_270",
  "FUEL_CH_2_LBL_270",
  "DSCRT_IN_SPDBRK_SW_POS",
  "DSCRT_IN_SPLR_POS_LFT",
  "DSCRT_IN_SPLR_POS_RGT",
  "DSCRT_OUT_SPDBRK_CMD_INHIBIT",
  "ATN_IS_CFG_2",
  "ENG_1_BLEED_LEVEL_OFF",
  "ENG_1_BLEED_LEVEL_0",
  "ENG_1_BLEED_LEVEL_1",
  "ENG_1_BLEED_LEVEL_2",
  "ENG_1_BLEED_LEVEL_VALID",
  "ENG_2_BLEED_LEVEL_OFF",
  "ENG_2_BLEED_LEVEL_0",
  "ENG_2_BLEED_LEVEL_1",
  "ENG_2_BLEED_LEVEL_2",
  "ENG_2_BLEED_LEVEL_VALID",
  "GTC_3_STATUS",
  "GTC_4_STATUS",
  "XFIL_REG_TAG_TBL_GTC_3",
  "XFIL_REG_TAG_TBL_GTC_4",
  "XFIL_REG_DATA_GTC_3",
  "XFIL_REG_DATA_GTC_4",
  "AFCS_USP_DBG_1",
  "AFCS_USP_DBG_2",
  "EAU_EMER_BATT_HTR_MON",
  "EPS_PDU1_LBL_310",
  "EPS_PDU2_LBL_350",
  "HF_1_STS_WRD_0_LBL_37",
  "HF_1_STS_WRD_1_LBL_37",
  "HF_1_STS_WRD_7_LBL_37",
  "HF_1_MAINT_WD_351",
  "HF_1_CHAN_NUM",
  "HF_1_RECEIVE_FREQ",
  "HF_1_REC_EM_MODE",
  "HF_1_TRANS_FREQ",
  "HF_1_TRANS_EM_MODE",
  "HF_2_STS_WRD_0_LBL_37",
  "HF_2_STS_WRD_1_LBL_37",
  "HF_2_STS_WRD_7_LBL_37",
  "HF_2_MAINT_WD_351",
  "HF_2_CHAN_NUM",
  "HF_2_RECEIVE_FREQ",
  "HF_2_REC_EM_MODE",
  "HF_2_TRANS_FREQ",
  "HF_2_TRANS_EM_MODE",
  "HF_1_CONTROL",
  "HF_2_CONTROL",
  "XPDR_2_SELECTED",
  "STBY_MAG_CAL",
  "GROUND_COOLING",
  "CVR_TEST",
  "CVR_ERASE",
  "POWER_OUTLET_ON",
  "ECS_CREW_DUCT_TEMP",
  "ECS_PAX_DUCT_TEMP",
  "HF_2_MAINTENANCE_351",
  "DSCRT_OUT_TCAS_GEAR_EXTND",
  "FADEC_RH_MIX_CAL_MODE",
  "FADEC_RH_CWL_FLP_POS",
  "FADEC_RH_FW_1",
  "FADEC_RH_FW_2",
  "FADEC_RH_FW_3",
  "FADEC_RH_FW_4",
  "FADEC_RH_CTRL_STAT",
  "FADEC_RH_MNFLD_PRES_SENS_FLT",
  "FADEC_RH_FL_PRES_SENS_FLT",
  "FADEC_RH_MNFLD_TMP_SENS_FLT",
  "FADEC_RH_CHT_SENS_FLT",
  "FADEC_RH_EGT_SENS_FLT",
  "FADEC_RH_FL_BST_SC_DETECT",
  "FADEC_RH_CHT_OVRTMP",
  "FADEC_RH_EGT_OVRTMP",
  "FADEC_RH_ENG_TIMING_FLT",
  "FADEC_RH_MECH_FL_PMP_FAIL",
  "FADEC_RH_DEAD_CYL_DETECT",
  "FADEC_RH_LEAN_MSFR_DETECT",
  "FADEC_RH_CYL_IN_BKUP_CTRL_MODE",
  "FADEC_RH_FADEC_CHAN_DSBLD",
  "FADEC_RH_FADEC_LW_VOLT_FLT",
  "FADEC_RH_OIL_PRES_SENS_FLT",
  "FADEC_RH_OIL_TEMP_SENS_FLT",
  "FADEC_RH_ENG_OVRSPD",
  "FADEC_RH_HIGH_OIL_TEMP",
  "FADEC_RH_LW_IDL_OIL_PRES",
  "FADEC_RH_HIGH_OIL_PRES",
  "FADEC_RH_CHT_OVRTMP_FW4",
  "FADEC_RH_EGT_OVRTMP_FW4",
  "FADEC_RH_HOT_HD_OPERATION",
  "FADEC_RH_LW_TKFF_OIL_TEMP",
  "FADEC_RH_LW_TKFF_CHT",
  "FADEC_RH_FADEC_TST_STATUS",
  "FADEC_RH_CWL_FLP_SW_STS",
  "EAU_WHEEL_SPEED_L_A",
  "EAU_WHEEL_SPEED_L_B",
  "EAU_WHEEL_SPEED_R_A",
  "EAU_WHEEL_SPEED_R_B",
  "BRAKE_FAIL_2",
  "ANTISKID_FAIL_2",
  "GMA_SELCAL_CODE",
  "AFCS_STEEP_APPR_ENGAGED",
  "OXYGEN_TEMPERATURE",
  "OXYGEN_PRESSURE",
  "STAB_TRIM_LBL_270",
  "STAB_TRIM_LBL_271",
  "STAB_TRIM_LBL_272",
  "STAB_TRIM_LBL_273",
  "PITCH_FEEL_LBL_273",
  "RUDDER_LIMIT_L_LBL_275",
  "RUDDER_LIMIT_R_LBL_275",
  "MACH_TRIM_LBL_275",
  "PCU_MONITOR_LBL_275",
  "DSCRT_OUT_TRU_LH_TEST",
  "DSCRT_OUT_TRU_RH_TEST",
  "DSCRT_OUT_WINDSHIELD_TEST",
  "DSCRT_OUT_STAB_TRIM_TEST",
  "DSCRT_OUT_BLEED_LEAK_TEST",
  "DSCRT_OUT_RAT_HEAT_LH_TEST",
  "DSCRT_OUT_RAT_HEAT_RH_TEST",
  "DSCRT_OUT_CAB_ALT_HIGH_L",
  "DSCRT_OUT_CAB_ALT_HIGH_R",
  "DSCRT_OUT_CAB_ALT_SEL_MODE",
  "DSCRT_OUT_NAV_LIGHTS_ON",
  "DSCRT_OUT_BEACON_LIGHTS_ON",
  "DSCRT_OUT_TCAS_PULSE_LIGHTS_ON",
  "ENG_1_N1_MAX_CRUISE_LBL",
  "ENG_1_N1_MAX_CLIMB_LBL",
  "ENG_1_N1_MAX_TAKEOFF_LBL",
  "ENG_1_N1_MAX_ATR_LBL",
  "ENG_2_N1_MAX_CRUISE_LBL",
  "ENG_2_N1_MAX_CLIMB_LBL",
  "ENG_2_N1_MAX_TAKEOFF_LBL",
  "ENG_2_N1_MAX_ATR_LBL",
  "DSCRT_OUT_AOA_TEST",
  "ECS_CREW_TEMP_SUPPLY",
  "ECS_PAX_TEMP_SUPPLY",
  "DSCRT_OUT_CABIN_DOOR_LOCKED",
  "STAB_TRIM_LBL_270_SEC",
  "STAB_TRIM_LBL_271_SEC",
  "STAB_TRIM_LBL_272_SEC",
  "STAB_TRIM_LBL_273_SEC",
  "STAB_TRIM_LBL_274",
  "ENG_1_FADEC_LBL_147_CH_A",
  "ENG_1_FADEC_LBL_147_CH_B",
  "ENG_2_FADEC_LBL_147_CH_A",
  "ENG_2_FADEC_LBL_147_CH_B",
  "APU_COMMAND_WORD",
  "DSCRT_OUT_RUN_STOP_ANNUNC_R",
  "DSCRT_OUT_ECS_CREW_FAN_RECIRC",
  "EAU_ELEVATOR_TRIM_SEC",
  "DSCRT_OUT_OVERSPEED_TEST",
  "DSCRT_OUT_RUDDER_BIAS_TEST",
  "DSCRT_OUT_ANTISKID_TEST",
  "DSCRT_OUT_FLOOD_COOLING_FAN",
  "DSCRT_OUT_FWD_EVAP_FAN_HI",
  "DSCRT_OUT_FWD_EVAP_FAN_LO",
  "DSCRT_OUT_AFT_EVAP_FAN_HI",
  "DSCRT_OUT_AFT_EVAP_FAN_LO",
  "DSCRT_OUT_DEFOG_FAN_HI",
  "DSCRT_OUT_DEFOG_FAN_LO",
  "DSCRT_OUT_AIR_FLOW_HI",
  "DSCRT_OUT_AIR_FLOW_LO",
  "DSCRT_OUT_TLA_GTE_1_DEG_L",
  "DSCRT_OUT_TLA_GTE_1_DEG_R",
  "DSCRT_OUT_TLA_LT_26_5_DEG",
  "ENG_2_N2_HI_WARN_DUR",
  "ENG_2_OIL_TEMP_HI_WARN_DUR",
  "ENG_2_OIL_PRES_HI_WARN_DUR",
  "ENG_2_OIL_PRES_LO_CAUT_2",
  "ENG_2_ITT_GAUGE_MAX_1",
  "ENG_2_ITT_GAUGE_MAX_2",
  "ENG_2_ITT_GAUGE_TRANS_MAX_1",
  "ENG_2_ITT_GAUGE_TRANS_MAX_1_DUR",
  "ENG_2_ITT_GAUGE_TRANS_MAX_2",
  "ENG_2_ITT_GAUGE_TRANS_MAX_2_DUR",
  "ENG_2_ITT_GAUGE_TRANS_MAX_3",
  "ENG_2_ITT_GAUGE_TRANS_MAX_3_DUR",
  "ENG_2_ITT_GAUGE_TRANS_MAX_4",
  "ENG_2_ITT_GAUGE_TRANS_MAX_4_DUR",
  "ENG_2_OIL_PRES_LO_WARN_DUR",
  "ENG_2_FFLOW_OFST",
  "ENG_2_N2_BUG",
  "ENG_2_N1_HI_WARN_DUR",
  "ENG_1_FADEC_LBL_343",
  "ENG_2_FADEC_LBL_343",
  "ENG_1_EIS_EXCEEDANCES",
  "ENG_2_EIS_EXCEEDANCES",
  "DSCRT_OUT_CABIN_ALT_TEST",
  "DSCRT_OUT_SMOKE_DETECT_TEST",
  "DSCRT_OUT_FADEC_RESET_L",
  "DSCRT_OUT_FADEC_RESET_R",
  "DSCRT_OUT_GND_REC_LT_OUT",
  "DSCRT_OUT_TAIL_FLOOD_LT_OUT",
  "DSCRT_OUT_CVR_DATALINK_REC_ENABLE",
  "DSCRT_OUT_CVR_SHUTDOWN",
  "DSCRT_OUT_FDR_SHUTDOWN",
  "DOOR_1_LBL_270",
  "DOOR_1_LBL_271",
  "DOOR_2_LBL_270",
  "DOOR_2_LBL_271",
  "ENG_1_N1_T_BUG",
  "ENG_2_N1_T_BUG",
  "ENG_1_N1_TRIM_A",
  "ENG_1_N1_TRIM_B",
  "ENG_2_N1_TRIM_A",
  "ENG_2_N1_TRIM_B",
  "INLET_TOTAL_TEMP_1_A",
  "INLET_TOTAL_TEMP_1_B",
  "INLET_TOTAL_TEMP_2_A",
  "INLET_TOTAL_TEMP_2_B",
  "ENG_1_N1_T_BUG_A",
  "ENG_1_N1_T_BUG_B",
  "ENG_2_N1_T_BUG_A",
  "ENG_2_N1_T_BUG_B",
  "ENG_1_N1_CMMD_A",
  "ENG_1_N1_CMMD_B",
  "ENG_2_N1_CMMD_A",
  "ENG_2_N1_CMMD_B",
  "DSCRT_OUT_GFC_AP_ENGAGED",
  "ENG_1_FADEC_LBL_271_CH_A",
  "ENG_1_FADEC_LBL_271_CH_B",
  "ENG_2_FADEC_LBL_271_CH_A",
  "ENG_2_FADEC_LBL_271_CH_B",
  "EAU_PILOT_RUDDER_PEDAL_FORCE_2",
  "EAU_COPILOT_RUDDER_PEDAL_FORCE_2",
  "GSD_1_A429_PORT_1",
  "GSD_1_A429_PORT_2",
  "GSD_1_A429_PORT_3",
  "GSD_1_A429_PORT_4",
  "GSD_1_A429_PORT_5",
  "GSD_1_A429_PORT_6",
  "GSD_1_A429_PORT_7",
  "GSD_1_A429_PORT_8",
  "GSD_1_A429_PORT_9",
  "GSD_1_A429_PORT_10",
  "GSD_1_A429_PORT_11",
  "GSD_1_A429_PORT_12",
  "GSD_1_A429_PORT_13",
  "GSD_1_A429_PORT_14",
  "GSD_1_A429_PORT_15",
  "GSD_2_A429_PORT_1",
  "GSD_2_A429_PORT_2",
  "GSD_2_A429_PORT_3",
  "GSD_2_A429_PORT_4",
  "GSD_2_A429_PORT_5",
  "GSD_2_A429_PORT_6",
  "GSD_2_A429_PORT_7",
  "GSD_2_A429_PORT_8",
  "GSD_2_A429_PORT_9",
  "GSD_2_A429_PORT_10",
  "GSD_2_A429_PORT_11",
  "GSD_2_A429_PORT_12",
  "GSD_2_A429_PORT_13",
  "GSD_2_A429_PORT_14",
  "GSD_2_A429_PORT_15",
  "GSD_3_A429_PORT_1",
  "GSD_3_A429_PORT_2",
  "GSD_3_A429_PORT_3",
  "GSD_3_A429_PORT_4",
  "GSD_3_A429_PORT_5",
  "GSD_3_A429_PORT_6",
  "GSD_3_A429_PORT_7",
  "GSD_3_A429_PORT_8",
  "GSD_3_A429_PORT_9",
  "GSD_3_A429_PORT_10",
  "GSD_3_A429_PORT_11",
  "GSD_3_A429_PORT_12",
  "GSD_3_A429_PORT_13",
  "GSD_3_A429_PORT_14",
  "GSD_3_A429_PORT_15",
  "GIA_1_A429_PORT_1",
  "GIA_1_A429_PORT_2",
  "GIA_1_A429_PORT_3",
  "GIA_1_A429_PORT_4",
  "GIA_1_A429_PORT_5",
  "GIA_1_A429_PORT_6",
  "GIA_1_A429_PORT_7",
  "GIA_1_A429_PORT_8",
  "GIA_2_A429_PORT_1",
  "GIA_2_A429_PORT_2",
  "GIA_2_A429_PORT_3",
  "GIA_2_A429_PORT_4",
  "GIA_2_A429_PORT_5",
  "GIA_2_A429_PORT_6",
  "GIA_2_A429_PORT_7",
  "GIA_2_A429_PORT_8",
  "XPDR_1_1090_CFG_RX",
  "XPDR_2_1090_CFG_RX",
  "XPDR_1_UAT_CFG_RX",
  "XPDR_2_UAT_CFG_RX",
  "XPDR_1_GPS_OFST_CFG_RX",
  "XPDR_2_GPS_OFST_CFG_RX",
  "AFCS_L_R_COL_DISCONNECT",
  "ENG_1_FADEC_RUN_TIME",
  "ENG_2_FADEC_RUN_TIME",
  "XPDR_1_1090_CFG_TX",
  "XPDR_2_1090_CFG_TX",
  "XPDR_1_UAT_CFG_TX",
  "XPDR_2_UAT_CFG_TX",
  "XPDR_1_GPS_OFST_CFG_TX",
  "XPDR_2_GPS_OFST_CFG_TX",
  "AIRBORNE_BROADBAND_STATUS",
  "ENG_1_HIGH_OIL_PRES_MIN_TEMP",
  "ENG_2_HIGH_OIL_PRES_MIN_TEMP",
  "BATT_1_FAIL_MODS_LBL_275",
  "BATT_2_FAIL_MODS_LBL_275",
  "BATT_1_DSCRT_LBL_276",
  "BATT_2_DSCRT_LBL_276",
  "RGN_ACK_VAR",
  "BRK_ACCU_LO_PRES",
  "DSCRT_IN_GND_SPLR_CMD_LOW",
  "DSCRT_IN_GND_SPLR_CMD_HIGH",
  "DSCRT_IN_GND_SPLR_ARMED",
  "DSCRT_OUT_WHEEL_SPEED_L",
  "DSCRT_OUT_WHEEL_SPEED_R",
  "DME_3_TUNE",
  "DME_3_LBL_300",
  "DME_4_TUNE",
  "DME_4_LBL_300",
  "DME_5_TUNE",
  "DME_5_LBL_300",
  "DME_6_TUNE",
  "DME_6_LBL_300",
  "MACH_TRIM_TARGET_PERCENT",
  "MACH_TRIM_ACTUATOR_PERCENT",
  "CMD_DATA",
  "CMD_ACK",
  "ECU_ENG_1_POT",
  "ECU_ENG_1_PILOT_MODE",
  "ECU_ENG_1_SNSR_STAT_1",
  "ECU_ENG_1_SNSR_STAT_2",
  "ECU_ENG_1_TEMP_STAT",
  "ECU_ENG_1_PRES_STAT",
  "ECU_ENG_1_SW_STAT",
  "ECU_ENG_1_START_STAT",
  "ECU_ENG_1_ALPHA_1",
  "ECU_ENG_1_ALPHA_2",
  "ECU_ENG_1_ALPHA_3",
  "ECU_ENG_1_BETA_1",
  "ECU_ENG_1_BETA_2",
  "ECU_ENG_1_OTP_VER",
  "ECU_ENG_1_ECU_SER_NUM",
  "ECU_ENG_1_OTP_CHKSM",
  "ECU_ENG_1_SW_VER",
  "ECU_ENG_1_SW_CHKSM",
  "ECU_ENG_1_CARTO_VER",
  "ECU_ENG_1_CARTO_NAME",
  "ECU_ENG_1_CARTO_CHKSM",
  "ECU_RESET_CMD",
  "ECU_ENG_1_NMOT_1",
  "ECU_ENG_1_NMOT_2",
  "ECU_ENG_1_SWITCH_MODE",
  "EAU_LOAD_FACTOR",
  "EAU_ADI_QTY",
  "DIS_IN_ECU_MAJOR_FAULT",
  "DIS_IN_ECU_MINOR_FAULT",
  "DIS_IN_ENGINE_PREHEAT",
  "YD_AUTO_ENGAGE",
  "RGN_BUFFER_VAR",
  "DSCRT_OUT_VIDEO_DISPLAYED",
  "DIS_IN_MKR_BCN_INNER",
  "DIS_IN_MKR_BCN_MIDDLE",
  "DIS_IN_MKR_BCN_OUTER",
  "GFCC_IAS_HOLD_REF",
  "GFCC_VS_HOLD_REF",
  "GFCC_BEEP_REF",
  "GFCC_BEEP_REF_LBL",
  "GFCC_FD_ARM_MODES",
  "GFCC_FD_CPL_MODES",
  "GFCC_STS_LBL_147",
  "GFCC_STS_LBL_270",
  "DSCRT_OUT_BOOST_PUMP_ENABLE",
  "BRAKE_LEFT_BCV_CURRENT",
  "BRAKE_RGHT_BCV_CURRENT",
  "BRAKE_SYSTEM_STATUS",
  "/shr_mem/iop_c_pkt_intf.shr"
}; // weak
char *off_100DC904 = "/shr_mem/iop_c_pkt_intf.shr"; // weak
_UNKNOWN unk_100DC918; // weak
char *off_100DE584 = "/shr_mem/iop_c_pkt_names_intf.shr"; // weak
int dword_100DEF3C[] = { 88 }; // weak
__int16 word_100DF3EC[] = { 836 }; // weak
char *off_100DF40C = "/shr_mem/iop_a_pkt_intf.shr"; // weak
char *off_100DF420 = "/shr_mem/iop_b_pkt_intf.shr"; // weak
char *off_100DF434 = "/shr_mem/iop_c_pkt_intf.shr"; // weak
char *off_100DF448 = "/shr_mem/iop_d_dbg_pkt_intf.shr"; // weak
char *off_100DF45C = "/shr_mem/iop_d_pkt_intf.shr"; // weak
char *off_100DF470 = "/shr_mem/iop_m_pkt_intf.shr"; // weak
_UNKNOWN unk_100E00B0; // weak
__int16 word_100E00B2[] = { 2 }; // weak
int dword_100E0610[] = { 6081 }; // weak
int dword_100E0614[] = { 8002 }; // weak
__int16 word_100E0618[] = { 30 }; // weak
_DWORD off_100E061C[4] = { 269353176, 6937, 8166, 55 }; // idb
float flt_100E0640 =  43200.0; // weak
int dword_100E1900[] = { 16384 }; // weak
int dword_100E1904[] = { 0 }; // weak
int (__cdecl *off_100E1908[2])(int) = { &sub_1001F6D0, &sub_1001F660 }; // weak
int (__cdecl *off_100E190C)(int) = &sub_1001F660; // weak
char *off_100E1980 = "/shr_mem/iop_c_upld_mngr_intf.shr"; // weak
_UNKNOWN unk_100E1F50; // weak
__int16 word_100E1F54[] = { 263 }; // weak
_UNKNOWN unk_100E2508; // weak
int dword_100E250C[] = { 1 }; // weak
_UNKNOWN unk_100E2620; // weak
char byte_100E2621[4422] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'X',
  'P',
  'D',
  'R',
  ' ',
  '#',
  '1',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'X',
  'P',
  'D',
  'R',
  ' ',
  '#',
  '2',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x02',
  'R',
  'E',
  'Q',
  'U',
  'E',
  'S',
  'T',
  'I',
  'N',
  'G',
  ' ',
  'X',
  'P',
  'D',
  'R',
  ' ',
  '#',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'R',
  'E',
  'Q',
  'U',
  'E',
  'S',
  'T',
  'I',
  'N',
  'G',
  ' ',
  'X',
  'P',
  'D',
  'R',
  ' ',
  '#',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x03',
  'V',
  'E',
  'R',
  'I',
  'F',
  'Y',
  'I',
  'N',
  'G',
  ' ',
  'X',
  'P',
  'D',
  'R',
  ' ',
  '#',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'V',
  'E',
  'R',
  'I',
  'F',
  'Y',
  'I',
  'N',
  'G',
  ' ',
  'X',
  'P',
  'D',
  'R',
  ' ',
  '#',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x04',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'X',
  'P',
  'D',
  'R',
  ' ',
  '#',
  '1',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'X',
  'P',
  'D',
  'R',
  ' ',
  '#',
  '2',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'X',
  'P',
  'D',
  'R',
  ' ',
  '#',
  '1',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'X',
  'P',
  'D',
  'R',
  ' ',
  '#',
  '2',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\a',
  'X',
  'P',
  'D',
  'R',
  ' ',
  '#',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'X',
  'P',
  'D',
  'R',
  ' ',
  '#',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  'X',
  'P',
  'D',
  'R',
  ' ',
  '#',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'F',
  'A',
  'I',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'X',
  'P',
  'D',
  'R',
  ' ',
  '#',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'F',
  'A',
  'I',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\t',
  'X',
  'P',
  'D',
  'R',
  ' ',
  '#',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'C',
  'A',
  'N',
  'C',
  'E',
  'L',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'X',
  'P',
  'D',
  'R',
  ' ',
  '#',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'C',
  'A',
  'N',
  'C',
  'E',
  'L',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\n',
  'S',
  'T',
  'O',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'X',
  'P',
  'D',
  'R',
  ' ',
  '#',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'S',
  'T',
  'O',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'X',
  'P',
  'D',
  'R',
  ' ',
  '#',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'A',
  'B',
  'C',
  'D',
  'E',
  'F',
  'G',
  'H',
  'J',
  'K',
  'L',
  'M',
  'P',
  'Q',
  'R',
  'S',
  '\0',
  '\0',
  ']',
  '\0',
  'Z',
  '\0',
  'W',
  '\0',
  '`',
  '\0',
  '\x01',
  '\0',
  '^',
  '\0',
  '[',
  '\0',
  'X',
  '\0',
  'a',
  '\0',
  '\x02',
  '\0',
  '_',
  '\0',
  '\\',
  '\0',
  'Y',
  '\0',
  'b',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  '\0',
  '',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\0',
  '',
  '\0',
  '',
  '\0',
  '\x02',
  '\0',
  '<',
  '\x02',
  '=',
  '\x02',
  ';',
  '\x02',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\0',
  '\x02',
  '\0',
  ':',
  '\x02',
  '\x17',
  '\x15',
  '\x03',
  '\x03',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\n',
  '\x12',
  '\n',
  '\x12',
  '\n',
  '\x1C',
  '\x0E',
  '\x1D',
  '\x0E',
  '\x1D',
  '\x0E',
  '\x1D',
  '\n',
  '\x1D',
  '\n',
  '\x1C',
  '\n',
  '\x18',
  '\n',
  '\x18',
  '\0',
  '\x18',
  '\0',
  '\x17',
  '\0',
  '\x16',
  '\0',
  '\x17',
  '\0',
  '\x17',
  '\0',
  '\x17',
  '\0',
  '\x1C',
  '\0',
  '\x18',
  '\0',
  '\x16',
  '\0',
  '\x14',
  '\n',
  '\x18',
  '\n',
  '\x12',
  '\n',
  '\x14',
  '\n',
  '\x18',
  '\n',
  '\r',
  '\n',
  '\x14',
  '\n',
  '\x1C',
  '\n',
  '\x12',
  '\0',
  '\x16',
  '\0',
  '\x16',
  '\0',
  '\x14',
  '\0',
  '\x12',
  '\n',
  '\x12',
  '\0',
  '\x1C',
  '\0',
  '\x17',
  '\0',
  '\x16',
  '\n',
  '\x1C',
  '\n',
  '\x16',
  '\n',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\x1C',
  '\0',
  '\0',
  '\0',
  '\0',
  'U',
  'N',
  'K',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  'A',
  'L',
  'E',
  'R',
  'T',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  'P',
  'A',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\0',
  'B',
  'A',
  'R',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\0',
  '\0',
  'H',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0',
  'H',
  'P',
  'A',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\0',
  '\0',
  'P',
  'S',
  'I',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\a',
  '\0',
  '\0',
  '\0',
  'F',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  '\0',
  '\0',
  '\0',
  'C',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\t',
  '\0',
  '\0',
  '\0',
  'c',
  'a',
  'r',
  'd',
  '8',
  ' ',
  'p',
  't',
  '\0',
  '\0',
  '\0',
  '\0',
  '\n',
  '\0',
  '\0',
  '\0',
  'R',
  'A',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\v',
  '\0',
  '\0',
  '\0',
  'S',
  '_',
  'S',
  'E',
  'M',
  'I',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\f',
  '\0',
  '\0',
  '\0',
  'S',
  'E',
  'M',
  'I',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\r',
  '\0',
  '\0',
  '\0',
  'D',
  'E',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x0E',
  '\0',
  '\0',
  '\0',
  'd',
  'i',
  's',
  't',
  'a',
  'n',
  'c',
  'e',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x0F',
  '\0',
  '\0',
  '\0',
  'S',
  'E',
  'C',
  'O',
  'N',
  'D',
  'S',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x10',
  '\0',
  '\0',
  '\0',
  '%',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x11',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x12',
  '\0',
  '\0',
  '\0',
  'm',
  't',
  '/',
  's',
  'e',
  'c',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x13',
  '\0',
  '\0',
  '\0',
  'm',
  't',
  '/',
  'm',
  'i',
  'n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x14',
  '\0',
  '\0',
  '\0',
  'f',
  't',
  '/',
  'm',
  'i',
  'n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x15',
  '\0',
  '\0',
  '\0',
  'k',
  'p',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x16',
  '\0',
  '\0',
  '\0',
  'k',
  't',
  's',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x17',
  '\0',
  '\0',
  '\0',
  'm',
  'p',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x18',
  '\0',
  '\0',
  '\0',
  'm',
  't',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x19',
  '\0',
  '\0',
  '\0',
  'm',
  't',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x1A',
  '\0',
  '\0',
  '\0',
  'm',
  'i',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x1B',
  '\0',
  '\0',
  '\0',
  'm',
  'i',
  'l',
  's',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x1C',
  '\0',
  '\0',
  '\0',
  'f',
  't',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x1D',
  '\0',
  '\0',
  '\0',
  'k',
  'm',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x1E',
  '\0',
  '\0',
  '\0',
  'n',
  'm',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x1F',
  '\0',
  '\0',
  '\0',
  'N',
  '*',
  'm',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  ' ',
  '\0',
  '\0',
  '\0',
  'l',
  'b',
  '-',
  'f',
  't',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '!',
  '\0',
  '\0',
  '\0',
  'L',
  'B',
  'F',
  'I',
  'N',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\"',
  '\0',
  '\0',
  '\0',
  'M',
  '/',
  'S',
  '^',
  '2',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '#',
  '\0',
  '\0',
  '\0',
  'g',
  '\'',
  's',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '$',
  '\0',
  '\0',
  '\0',
  'l',
  't',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '%',
  '\0',
  '\0',
  '\0',
  'g',
  'l',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '&',
  '\0',
  '\0',
  '\0',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\'',
  '\0',
  '\0',
  '\0',
  'l',
  't',
  '/',
  's',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '(',
  '\0',
  '\0',
  '\0',
  'g',
  'l',
  '/',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  ')',
  '\0',
  '\0',
  '\0',
  'I',
  'G',
  '/',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '*',
  '\0',
  '\0',
  '\0',
  'k',
  'g',
  '_',
  'A',
  '/',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '+',
  '\0',
  '\0',
  '\0',
  'k',
  'g',
  '_',
  'A',
  'V',
  '/',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  ',',
  '\0',
  '\0',
  '\0',
  'k',
  'g',
  '_',
  'B',
  '/',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '-',
  '\0',
  '\0',
  '\0',
  'k',
  'g',
  '_',
  'D',
  'S',
  'L',
  '/',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '.',
  '\0',
  '\0',
  '\0',
  'l',
  'b',
  '_',
  'A',
  '/',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '/',
  '\0',
  '\0',
  '\0',
  'l',
  'b',
  '_',
  'A',
  'V',
  '/',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '\0',
  '\0',
  '\0',
  'l',
  'b',
  '_',
  'B',
  '/',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '1',
  '\0',
  '\0',
  '\0',
  'l',
  'b',
  '_',
  'D',
  'S',
  'L',
  '/',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '2',
  '\0',
  '\0',
  '\0',
  'l',
  't',
  '/',
  'h',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '3',
  '\0',
  '\0',
  '\0',
  'm',
  '/',
  'l',
  't',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '4',
  '\0',
  '\0',
  '\0',
  'm',
  'i',
  '/',
  'g',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '5',
  '\0',
  '\0',
  '\0',
  'n',
  'm',
  '/',
  'g',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '6',
  '\0',
  '\0',
  '\0',
  'k',
  'g',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '7',
  '\0',
  '\0',
  '\0',
  'l',
  'b',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '8',
  '\0',
  '\0',
  '\0',
  'g',
  'r',
  'm',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '9',
  '\0',
  '\0',
  '\0',
  'k',
  'g',
  '_',
  'A',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  ':',
  '\0',
  '\0',
  '\0',
  'k',
  'g',
  '_',
  'A',
  'V',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  ';',
  '\0',
  '\0',
  '\0',
  'k',
  'g',
  '_',
  'B',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '<',
  '\0',
  '\0',
  '\0',
  'k',
  'g',
  '_',
  'D',
  'S',
  'L',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '=',
  '\0',
  '\0',
  '\0',
  'l',
  'b',
  '_',
  'A',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '>',
  '\0',
  '\0',
  '\0',
  'l',
  'b',
  '_',
  'A',
  'V',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '?',
  '\0',
  '\0',
  '\0',
  'l',
  'b',
  '_',
  'B',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '@',
  '\0',
  '\0',
  '\0',
  'l',
  'b',
  '_',
  'D',
  'S',
  'L',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'A',
  '\0',
  '\0',
  '\0',
  'R',
  'P',
  'M',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'B',
  '\0',
  '\0',
  '\0',
  'r',
  'a',
  'd',
  '/',
  's',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'C',
  '\0',
  '\0',
  '\0',
  'c',
  'u',
  ' ',
  'i',
  'n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'I',
  'N',
  'A',
  'C',
  'T',
  'I',
  'V',
  'E',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  'A',
  'C',
  'T',
  'I',
  'V',
  'E',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x02',
  'A',
  '_',
  'U',
  'N',
  'K',
  'N',
  'O',
  'W',
  'N',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x03',
  'I',
  '_',
  'U',
  'N',
  'K',
  'N',
  'O',
  'W',
  'N',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x02',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x12',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x13',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x14',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x15',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x16',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x17',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x19',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x1A',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x1B',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x1C',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x1D',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x1E',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\x1F',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  ' ',
  '\0',
  '\x04',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '$',
  '\0',
  '\x04',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '(',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  ')',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '*',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '+',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  ',',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '-',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '.',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '/',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '1',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '2',
  '\0',
  '\x1E',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'P',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'Q',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'T',
  '\0',
  '\x04',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'X',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'Y',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '\\',
  '\0',
  '\x04',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '`',
  '\0',
  '\x04',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'd',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x04',
  '\0',
  '',
  '\x17',
  '\0',
  '\0',
  'h',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'i',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'j',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'k',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'l',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'm',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'n',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'o',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'p',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'q',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'r',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  's',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  't',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'u',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'v',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  'x',
  '\0',
  '\x04',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '|',
  '\0',
  '\x04',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x04',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x04',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x04',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x02',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x05',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x19',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '\x1C',
  '\x1A',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '\x1D',
  '\x1A',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '\x1E',
  '\x1A',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  'u',
  '\x1A',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  'v',
  '\x1A',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '|',
  '\x1A',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '\x1E',
  '\x1B',
  '\0',
  '\0',
  '',
  '\0',
  '\x01',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  ' ',
  '\0',
  '\0',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\0',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '',
  '\x1A',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '',
  '\x1A',
  '\0'
}; // idb
int dword_100E3C68[] = { 1 }; // weak
char *off_100E3D80[3] = { "test_com", "$Id$", &off_100E3D08 }; // weak
char *off_100E3ED8 = "test_gma_dig"; // weak
_UNKNOWN unk_100E4010; // weak
_UNKNOWN unk_100E4014; // weak
_UNKNOWN unk_100E4628; // weak
int (*off_100E48E8[3])() = { &sub_10061E20, &sub_1004AE90, &sub_100184A0 }; // weak
char *off_100E4BF0 = "/shr_mem/iop_trfc_intf.shr"; // weak
_UNKNOWN unk_100E513C; // weak
int dword_100E5140[] = { 1 }; // weak
int dword_100E5144[] = { 4 }; // weak
char *off_100E70B4 = "/shr_mem/udb_intf.shr"; // weak
char byte_100E70C8[] = { '\0' }; // weak
char byte_100E70C9[] = { '\0' }; // weak
char byte_100E70CA[] = { '\xFF' }; // weak
char byte_100E70CB[] = { '\xFF' }; // weak
char byte_100E70CC[] = { '\xFF' }; // weak
char byte_100E711C[] = { '\x05' }; // weak
char byte_100E7120[] = { '\b' }; // weak
int dword_100E7124[] = { 9 }; // weak
__int16 word_100E7170 = 0; // weak
char byte_100E7172[] = { '\0' }; // weak
__int16 word_100E7440 = 0; // weak
char byte_100E7442[] = { '\0' }; // weak
_UNKNOWN unk_100E7B61; // weak
float flt_100E7B64 =  6.2831855; // weak
_UNKNOWN unk_100E7C4E; // weak
_UNKNOWN unk_100E8154; // weak
_UNKNOWN unk_100E86D8; // weak
_UNKNOWN unk_100E86DC; // weak
char byte_100E86E8[] = { ' ' }; // weak
char byte_100E86F0[] = { ' ' }; // weak
_UNKNOWN unk_100E86F8; // weak
_UNKNOWN unk_100E8CE8; // weak
_UNKNOWN unk_100E8DF0; // weak
float flt_100E8DF4[] = {  2588.2505 }; // weak
float flt_100E8DF8[] = {  0.00038636138 }; // weak
_UNKNOWN unk_100E9598; // weak
char byte_100E9599[] = { '\x03' }; // weak
char byte_100E959A[] = { '\x04' }; // weak
__int16 word_100EA488[] = { 116 }; // weak
__int16 word_100EA48C[] = { 118 }; // weak
__int16 word_100EA48E[] = { 120 }; // weak
__int16 word_100EA490[] = { 116 }; // weak
__int16 word_100EA492[] = { 244 }; // weak
__int16 word_100EA494[] = { 122 }; // weak
__int16 word_100EBB48[] = { 32828 }; // weak
int dword_100EBB4C[] = { 1200 }; // weak
int dword_100EBB80 = 1600085855; // weak
char aWgs84[21] = "WGS 84              "; // weak
_UNKNOWN unk_100ED048; // weak
int (__cdecl *off_100ED590)(int, size_t, void *) = &sub_1003BE10; // weak
char *off_100ED608 = "/shr_mem/dat_intf.shr"; // weak
_UNKNOWN unk_100EF2F0; // weak
__int16 word_100EF2F2[] = { 492 }; // weak
char byte_100EF300[] = { '@' }; // weak
char byte_100EF301[] = { '\x04' }; // weak
char *off_100EF30C = "/shr_mem/iop_gtx_intf.shr"; // weak
int (__cdecl *off_100EF870[3])(char) = { &sub_10049D30, &sub_10049C40, &sub_10049B90 }; // weak
char *off_100F00B8 = "/shr_mem/iop_gea_intf.shr"; // weak
_UNKNOWN unk_100F17CC; // weak
_UNKNOWN unk_100F17D8; // weak
int dword_100F17DC[] = { 0 }; // weak
void *off_100F17E0 = &unk_100F06B0; // weak
__int16 word_100F17E4[] = { 978 }; // weak
_UNKNOWN unk_100F1B78; // weak
int dword_100F1B7C[] = { 0 }; // weak
_UNKNOWN unk_100F1D90; // weak
char *off_100F1DD0 = "/shr_mem/iop_cnfg_mngr_intf.shr"; // weak
char *off_100F1DE4 = "/shr_mem/iop_prod_enbl_intf.shr"; // weak
char byte_100F2343[] = { '\a' }; // weak
char byte_100F2344[] = { '\x06' }; // weak
char byte_100F2345[] = { '\x05' }; // weak
char byte_100F2346[] = { '\x01' }; // weak
char byte_100F2347[] = { '\0' }; // weak
char byte_100F2348[] = { '\x01' }; // weak
char byte_100F2349[] = { '\0' }; // weak
char byte_100F234A[] = { '\x01' }; // weak
_UNKNOWN unk_100F2438; // weak
char byte_100F243A[] = { '\x06' }; // weak
char byte_100F243B[] = { '\xFF' }; // weak
char *off_100F25D0 = "/shr_mem/iop_tcas_ii_intf.shr"; // weak
int dword_100F3458[] = { 9032 }; // weak
char *off_100F34C4 = "/shr_mem/iop_fltr_data_intf.shr"; // weak
char *off_100F6DC0 = "/shr_mem/nav_intf.shr"; // weak
char *off_100F6DEC = "/shr_mem/pvt_intf.shr"; // weak
int (*off_100F7358[4])() = { &sub_10041ED0, &sub_10041EC0, &sub_10041EB0, &sub_10041EC0 }; // weak
int dword_100F73EC[] = { 10733 }; // weak
_BYTE word_100F798E[26] =
{
  0,
  0,
  0,
  0,
  31,
  0,
  59,
  0,
  90,
  0,
  120,
  0,
  151,
  0,
  181,
  0,
  212,
  0,
  243,
  0,
  17,
  1,
  48,
  1,
  78,
  1
}; // idb
int dword_100F8F18 = 1391376; // weak
_UNKNOWN unk_100F9480; // weak
_UNKNOWN unk_100FA304; // weak
wchar_t a___0[8] = L":;<=>?@"; // weak
wchar_t aAbcde_0[6] = L"ABCDE"; // weak
_UNKNOWN unk_100FB3C0; // weak
char byte_100FB3C4[] = { '\0' }; // weak
_UNKNOWN unk_100FB3F8; // weak
char byte_100FB3FC[] = { '\0' }; // weak
_UNKNOWN unk_100FBB40; // weak
_UNKNOWN unk_100FD228; // weak
_UNKNOWN unk_100FD240; // weak
_UNKNOWN unk_100FD288; // weak
int dword_100FD28C[] = { 6767 }; // weak
_UNKNOWN unk_100FD298; // weak
_UNKNOWN unk_100FD2B0; // weak
_UNKNOWN unk_100FD2C8; // weak
int dword_100FD2CC[] = { 6769 }; // weak
_UNKNOWN unk_100FD2E0; // weak
int dword_100FD2E4[] = { 6093 }; // weak
__int16 word_100FD3D0[] = { 551 }; // weak
_UNKNOWN unk_100FD928; // weak
char byte_100FD929[] = { '' }; // weak
char byte_100FD92A[] = { '' }; // weak
char byte_100FD94C[] = { '\x02' }; // weak
char byte_100FD94D[] = { '\0' }; // weak
_UNKNOWN unk_100FDF30; // weak
_UNKNOWN unk_100FDF38; // weak
char byte_100FDF40[] = { '\x01' }; // weak
_UNKNOWN unk_100FDFE0; // weak
int dword_100FDFE4[] = { 1312 }; // weak
_UNKNOWN unk_100FF628; // weak
_UNKNOWN unk_100FF668; // weak
__int16 word_100FFC8C[] = { 137 }; // weak
__int16 word_101011A4[] = { 538 }; // weak
char byte_101011B0[] = { '\x04' }; // weak
_UNKNOWN unk_101011E0; // weak
char byte_101011E1[] = { '\0' }; // weak
_UNKNOWN unk_10101760; // weak
char *off_1010189C = "/shr_mem/prx_intf.shr"; // weak
char a006D0170[11] = "006-D0170-"; // weak
char *off_10102FD0 = "006-D0170-"; // weak
int (__cdecl *(*off_10102FD4)[2])(int, int) = &off_101446C8; // weak
char *off_10103398[3] = { ".\\test\\tst_tsk_common.c", "$Id$", &off_10103208 }; // weak
_UNKNOWN unk_101033AC; // weak
_UNKNOWN unk_101033B0; // weak
__int16 word_101049B2[] = { 537 }; // weak
__int16 word_101049B8[] = { 1565 }; // weak
__int16 word_101049BC[] = { 534 }; // weak
char byte_101049C0[] = { '\x04' }; // weak
__int16 word_101049C2[] = { 6512 }; // weak
int dword_101049D8[] = { 118000 }; // weak
_UNKNOWN unk_101058F8; // weak
__int16 word_101058FA[] = { 10014 }; // weak
char byte_101058FC[] = { '\0' }; // weak
_UNKNOWN unk_101066D0; // weak
void *off_101066D4 = &unk_10106448; // weak
__int16 word_10108A86[] = { 1 }; // weak
_UNKNOWN unk_10108AE2; // weak
_UNKNOWN unk_10108B10; // weak
char byte_1010A2F4[] = { '\n' }; // weak
char *off_1010A43C = "Cannot send message. Data radio failed."; // weak
char byte_1010A440[] = { 'A' }; // weak
char *off_1010B360 = "/shr_mem/iop_gtx_intf.shr"; // weak
__int16 word_1010B374[] = { 2569 }; // weak
__int16 word_1010B376[] = { 2571 }; // weak
_UNKNOWN unk_1010B3A0; // weak
__int16 word_1010B3A4[] = { 63 }; // weak
_UNKNOWN unk_1010B3D0; // weak
char byte_1010B3D4[] = { '\0' }; // weak
_UNKNOWN unk_1010B3E0; // weak
__int16 word_1010B3E4[] = { 0 }; // weak
__int16 word_1010B3E6[] = { 1 }; // weak
_UNKNOWN unk_1010B418; // weak
__int16 word_1010B41C[] = { 0 }; // weak
__int16 word_1010B41E[] = { 1 }; // weak
char *off_1010B4F8[5] = { "FAIL", "PASS", "normal", "robust", "EQ" }; // weak
char *off_1010B500[3] = { "normal", "robust", "EQ" }; // weak
char *off_1010B508 = "EQ"; // weak
char *off_1010B524[7] =
{
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_1010B530[4] = { "FALSE", "TRUE", "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
char *off_1010B538[2] = { "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
_UNKNOWN unk_1010B810; // weak
_UNKNOWN unk_1010B84C; // weak
_UNKNOWN unk_1010BA88; // weak
char off_1010C718[] = { '', '', '\x10', '\x10' }; // idb
int dword_1010C734 = 1; // idb
char byte_1010C750[] = { '\x01' }; // weak
void *off_1010C754 = &unk_100ED048; // weak
char *off_1010C758[2] = { "2", "fail_normal_1" }; // weak
char off_1010C75C[8] = { '\0', '', '\x10', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_1010C7E0[] = { '\0' }; // weak
char byte_1010C7E1[] = { '\0' }; // weak
int dword_1010C7E4[] = { 0 }; // weak
char *off_1010C7E8 = "0, 0, 0"; // weak
double dbl_1010CA50[] = {  0.0 }; // weak
double dbl_1010CA58[] = {  0.0 }; // weak
double dbl_1010CA60[] = {  0.0 }; // weak
int dword_1010CA68[] = { 0 }; // weak
char off_1010CA6C[32] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_1010D670[] = {  0.0 }; // weak
float flt_1010D674[] = {  0.0 }; // weak
float flt_1010D678[] = {  0.0 }; // weak
int dword_1010D67C[] = { 0 }; // weak
char *off_1010D680 = "0, 0, 0"; // weak
char *off_1010DE04[3] =
{
  "..\\lib\\utf\\utf_validate.c",
  "..\\lib\\utf\\utf_validate.c",
  &off_10122A60
}; // weak
int dword_1010DE18[] = { 0 }; // weak
int dword_1010DE1C[] = { 0 }; // weak
int dword_1010DE20[] = { 0 }; // weak
int dword_1010DE24[] = { 0 }; // weak
char off_1010DE28[20] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_1010E5B0[] = { 0 }; // weak
__int16 word_1010E5B2[] = { 0 }; // weak
__int16 word_1010E5B4[] = { 0 }; // weak
int dword_1010E5B8[] = { 0 }; // weak
char off_1010E5BC[16] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1010EBC0[] = { 0 }; // weak
int dword_1010EBC4[] = { 0 }; // weak
int dword_1010EBC8[] = { 0 }; // weak
int dword_1010EBCC[] = { 0 }; // weak
char *off_1010EBD0 = "0, 0, 0"; // weak
int dword_1010F358[] = { 0 }; // weak
int dword_1010F35C[] = { 0 }; // weak
int dword_1010F360[] = { 0 }; // weak
int dword_1010F364[] = { 0 }; // weak
int dword_1010F368[] = { 0 }; // weak
int dword_1010F36C[] = { 0 }; // weak
int dword_1010F370[] = { 0 }; // weak
char off_1010F374[32] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1010FF78[] = { '\0' }; // weak
char byte_1010FF79[] = { '\0' }; // weak
char byte_1010FF7A[] = { '\0' }; // weak
int dword_1010FF7C[] = { 0 }; // weak
char *off_1010FF80 = "0, 0, 0"; // weak
int dword_10110408[] = { 0 }; // weak
int dword_1011040C[] = { 0 }; // weak
int dword_10110410[] = { 0 }; // weak
int dword_10110414[] = { 0 }; // weak
char off_10110418[20] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10110BA0[] = { 0 }; // weak
int dword_10110BA4[] = { 0 }; // weak
int dword_10110BA8[] = { 0 }; // weak
int dword_10110BAC[] = { 0 }; // weak
char *off_10110BB0 = "0, 0, 0"; // weak
__int16 word_10110F10[] = { 0 }; // weak
__int16 word_10110F12[] = { 0 }; // weak
__int16 word_10110F14[] = { 0 }; // weak
int dword_10110F18[] = { 0 }; // weak
char off_10110F1C[16] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_101111D0[] = { 0 }; // weak
int dword_101111D4[] = { 0 }; // weak
int dword_101111D8[] = { 0 }; // weak
int dword_101111DC[] = { 0 }; // weak
char *off_101111E0 = "0, 0, 0"; // weak
int dword_10111540[] = { 0 }; // weak
int dword_10111544[] = { 0 }; // weak
int dword_10111548[] = { 0 }; // weak
int dword_1011154C[] = { 0 }; // weak
int dword_10111550[] = { 0 }; // weak
int dword_10111554[] = { 0 }; // weak
int dword_10111558[] = { 0 }; // weak
char off_1011155C[32] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10111AC0[] = { '\0' }; // weak
char byte_10111AC1[] = { '\0' }; // weak
char byte_10111AC2[] = { '\0' }; // weak
int dword_10111AC4[] = { 0 }; // weak
char *off_10111AC8 = "0, 0, 0"; // weak
int dword_10111CD0[] = { 0 }; // weak
int dword_10111CD4[] = { 0 }; // weak
int dword_10111CD8[] = { 0 }; // weak
int dword_10111CDC[] = { 0 }; // weak
char *off_10111CE0 = "0, 0, 0"; // weak
char byte_10112040[] = { '\x01' }; // weak
void *off_10112044 = &unk_100ED048; // weak
char *off_10112048[2] = { "2", "fail_robust_1" }; // weak
char off_1011204C[8] = { 'x', '', '\x10', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_101120D0[] = { '\0' }; // weak
char byte_101120D1[] = { '\0' }; // weak
int dword_101120D4[] = { 0 }; // weak
char *off_101120D8 = "0, 0, 0"; // weak
double dbl_10112340[] = {  0.0 }; // weak
double dbl_10112348[] = {  0.0 }; // weak
double dbl_10112350[] = {  0.0 }; // weak
int dword_10112358[] = { 0 }; // weak
char off_1011235C[32] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_10112F60[] = {  0.0 }; // weak
float flt_10112F64[] = {  0.0 }; // weak
float flt_10112F68[] = {  0.0 }; // weak
int dword_10112F6C[] = { 0 }; // weak
char *off_10112F70 = "0, 0, 0"; // weak
int dword_101136F8[] = { 0 }; // weak
int dword_101136FC[] = { 0 }; // weak
int dword_10113700[] = { 0 }; // weak
int dword_10113704[] = { 0 }; // weak
char off_10113708[20] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_10113E90[] = { 0 }; // weak
__int16 word_10113E92[] = { 0 }; // weak
__int16 word_10113E94[] = { 0 }; // weak
int dword_10113E98[] = { 0 }; // weak
char off_10113E9C[16] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_101144A0[] = { 0 }; // weak
int dword_101144A4[] = { 0 }; // weak
int dword_101144A8[] = { 0 }; // weak
int dword_101144AC[] = { 0 }; // weak
char *off_101144B0 = "0, 0, 0"; // weak
int dword_10114C38[] = { 0 }; // weak
int dword_10114C3C[] = { 0 }; // weak
int dword_10114C40[] = { 0 }; // weak
int dword_10114C44[] = { 0 }; // weak
int dword_10114C48[] = { 0 }; // weak
int dword_10114C4C[] = { 0 }; // weak
int dword_10114C50[] = { 0 }; // weak
char off_10114C54[32] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10115858[] = { '\0' }; // weak
char byte_10115859[] = { '\0' }; // weak
char byte_1011585A[] = { '\0' }; // weak
int dword_1011585C[] = { 0 }; // weak
char *off_10115860 = "0, 0, 0"; // weak
int dword_10115CE8[] = { 0 }; // weak
int dword_10115CEC[] = { 0 }; // weak
int dword_10115CF0[] = { 0 }; // weak
int dword_10115CF4[] = { 0 }; // weak
char off_10115CF8[20] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10116480[] = { 0 }; // weak
int dword_10116484[] = { 0 }; // weak
int dword_10116488[] = { 0 }; // weak
int dword_1011648C[] = { 0 }; // weak
char *off_10116490 = "0, 0, 0"; // weak
__int16 word_101167F0[] = { 0 }; // weak
__int16 word_101167F2[] = { 0 }; // weak
__int16 word_101167F4[] = { 0 }; // weak
int dword_101167F8[] = { 0 }; // weak
char off_101167FC[16] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10116AB0[] = { 0 }; // weak
int dword_10116AB4[] = { 0 }; // weak
int dword_10116AB8[] = { 0 }; // weak
int dword_10116ABC[] = { 0 }; // weak
char *off_10116AC0 = "0, 0, 0"; // weak
int dword_10116E20[] = { 0 }; // weak
int dword_10116E24[] = { 0 }; // weak
int dword_10116E28[] = { 0 }; // weak
int dword_10116E2C[] = { 0 }; // weak
int dword_10116E30[] = { 0 }; // weak
int dword_10116E34[] = { 0 }; // weak
int dword_10116E38[] = { 0 }; // weak
char off_10116E3C[32] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_101173A0[] = { '\0' }; // weak
char byte_101173A1[] = { '\0' }; // weak
char byte_101173A2[] = { '\0' }; // weak
int dword_101173A4[] = { 0 }; // weak
char *off_101173A8 = "0, 0, 0"; // weak
int dword_101175B0[] = { 0 }; // weak
int dword_101175B4[] = { 0 }; // weak
int dword_101175B8[] = { 0 }; // weak
int dword_101175BC[] = { 0 }; // weak
char *off_101175C0 = "0, 0, 0"; // weak
char byte_10117920[] = { '\x01' }; // weak
void *off_10117924 = &unk_100ED048; // weak
void *off_10117928 = &unk_100ED048; // weak
char off_1011792C[8] = { '', '', '\x10', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_10117970[] = { '\0' }; // weak
char byte_10117971[] = { '\0' }; // weak
int dword_10117974[] = { 0 }; // weak
char *off_10117978 = "0, 0, 0"; // weak
double dbl_10117BE0[] = {  0.0 }; // weak
double dbl_10117BE8[] = {  0.0 }; // weak
double dbl_10117BF0[] = {  0.0 }; // weak
int dword_10117BF8[] = { 0 }; // weak
char off_10117BFC[32] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_10118800[] = {  0.0 }; // weak
float flt_10118804[] = {  0.0 }; // weak
float flt_10118808[] = {  0.0 }; // weak
int dword_1011880C[] = { 0 }; // weak
char *off_10118810 = "0, 0, 0"; // weak
int dword_10118F98[] = { 0 }; // weak
int dword_10118F9C[] = { 0 }; // weak
int dword_10118FA0[] = { 0 }; // weak
int dword_10118FA4[] = { 0 }; // weak
char off_10118FA8[20] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_10119730[] = { 0 }; // weak
__int16 word_10119732[] = { 0 }; // weak
__int16 word_10119734[] = { 0 }; // weak
int dword_10119738[] = { 0 }; // weak
char off_1011973C[16] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10119D40[] = { 0 }; // weak
int dword_10119D44[] = { 0 }; // weak
int dword_10119D48[] = { 0 }; // weak
int dword_10119D4C[] = { 0 }; // weak
char *off_10119D50 = "0, 0, 0"; // weak
int dword_1011A4D8[] = { 0 }; // weak
int dword_1011A4DC[] = { 0 }; // weak
int dword_1011A4E0[] = { 0 }; // weak
int dword_1011A4E4[] = { 0 }; // weak
int dword_1011A4E8[] = { 0 }; // weak
int dword_1011A4EC[] = { 0 }; // weak
int dword_1011A4F0[] = { 0 }; // weak
char off_1011A4F4[32] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1011B0F8[] = { '\0' }; // weak
char byte_1011B0F9[] = { '\0' }; // weak
char byte_1011B0FA[] = { '\0' }; // weak
int dword_1011B0FC[] = { 0 }; // weak
char *off_1011B100 = "0, 0, 0"; // weak
int dword_1011B588[] = { 0 }; // weak
int dword_1011B58C[] = { 0 }; // weak
int dword_1011B590[] = { 0 }; // weak
int dword_1011B594[] = { 0 }; // weak
char off_1011B598[20] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1011BD20[] = { 0 }; // weak
int dword_1011BD24[] = { 0 }; // weak
int dword_1011BD28[] = { 0 }; // weak
int dword_1011BD2C[] = { 0 }; // weak
char *off_1011BD30 = "0, 0, 0"; // weak
__int16 word_1011C090[] = { 0 }; // weak
__int16 word_1011C092[] = { 0 }; // weak
__int16 word_1011C094[] = { 0 }; // weak
int dword_1011C098[] = { 0 }; // weak
char off_1011C09C[16] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1011C350[] = { 0 }; // weak
int dword_1011C354[] = { 0 }; // weak
int dword_1011C358[] = { 0 }; // weak
int dword_1011C35C[] = { 0 }; // weak
char *off_1011C360 = "0, 0, 0"; // weak
int dword_1011C6C0[] = { 0 }; // weak
int dword_1011C6C4[] = { 0 }; // weak
int dword_1011C6C8[] = { 0 }; // weak
int dword_1011C6CC[] = { 0 }; // weak
int dword_1011C6D0[] = { 0 }; // weak
int dword_1011C6D4[] = { 0 }; // weak
int dword_1011C6D8[] = { 0 }; // weak
char off_1011C6DC[32] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1011CC40[] = { '\0' }; // weak
char byte_1011CC41[] = { '\0' }; // weak
char byte_1011CC42[] = { '\0' }; // weak
int dword_1011CC44[] = { 0 }; // weak
char *off_1011CC48 = "0, 0, 0"; // weak
int dword_1011CE50[] = { 0 }; // weak
int dword_1011CE54[] = { 0 }; // weak
int dword_1011CE58[] = { 0 }; // weak
int dword_1011CE5C[] = { 0 }; // weak
char *off_1011CE60 = "0, 0, 0"; // weak
char byte_1011D1C0[] = { '\x01' }; // weak
void *off_1011D1C4 = &unk_100ED048; // weak
void *off_1011D1C8 = &unk_100ED048; // weak
char off_1011D1CC[8] = { '', '', '\x10', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_1011D210[] = { '\0' }; // weak
char byte_1011D211[] = { '\0' }; // weak
int dword_1011D214[] = { 0 }; // weak
char *off_1011D218 = "0, 0, 0"; // weak
double dbl_1011D480[] = {  0.0 }; // weak
double dbl_1011D488[] = {  0.0 }; // weak
double dbl_1011D490[] = {  0.0 }; // weak
int dword_1011D498[] = { 0 }; // weak
char off_1011D49C[32] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_1011E0A0[] = {  0.0 }; // weak
float flt_1011E0A4[] = {  0.0 }; // weak
float flt_1011E0A8[] = {  0.0 }; // weak
int dword_1011E0AC[] = { 0 }; // weak
char *off_1011E0B0 = "0, 0, 0"; // weak
int dword_1011E838[] = { 0 }; // weak
int dword_1011E83C[] = { 0 }; // weak
int dword_1011E840[] = { 0 }; // weak
int dword_1011E844[] = { 0 }; // weak
char off_1011E848[20] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_1011EFD0[] = { 0 }; // weak
__int16 word_1011EFD2[] = { 0 }; // weak
__int16 word_1011EFD4[] = { 0 }; // weak
int dword_1011EFD8[] = { 0 }; // weak
char off_1011EFDC[16] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1011F5E0[] = { 0 }; // weak
int dword_1011F5E4[] = { 0 }; // weak
int dword_1011F5E8[] = { 0 }; // weak
int dword_1011F5EC[] = { 0 }; // weak
char *off_1011F5F0 = "0, 0, 0"; // weak
int dword_1011FD78[] = { 0 }; // weak
int dword_1011FD7C[] = { 0 }; // weak
int dword_1011FD80[] = { 0 }; // weak
int dword_1011FD84[] = { 0 }; // weak
int dword_1011FD88[] = { 0 }; // weak
int dword_1011FD8C[] = { 0 }; // weak
int dword_1011FD90[] = { 0 }; // weak
char off_1011FD94[32] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10120998[] = { '\0' }; // weak
char byte_10120999[] = { '\0' }; // weak
char byte_1012099A[] = { '\0' }; // weak
int dword_1012099C[] = { 0 }; // weak
char *off_101209A0 = "0, 0, 0"; // weak
int dword_10120E28[] = { 0 }; // weak
int dword_10120E2C[] = { 0 }; // weak
int dword_10120E30[] = { 0 }; // weak
int dword_10120E34[] = { 0 }; // weak
char off_10120E38[20] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_101215C0[] = { 0 }; // weak
int dword_101215C4[] = { 0 }; // weak
int dword_101215C8[] = { 0 }; // weak
int dword_101215CC[] = { 0 }; // weak
char *off_101215D0 = "0, 0, 0"; // weak
__int16 word_10121930[] = { 0 }; // weak
__int16 word_10121932[] = { 0 }; // weak
__int16 word_10121934[] = { 0 }; // weak
int dword_10121938[] = { 0 }; // weak
char off_1012193C[16] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10121BF0[] = { 0 }; // weak
int dword_10121BF4[] = { 0 }; // weak
int dword_10121BF8[] = { 0 }; // weak
int dword_10121BFC[] = { 0 }; // weak
char *off_10121C00 = "0, 0, 0"; // weak
int dword_10121F60[] = { 0 }; // weak
int dword_10121F64[] = { 0 }; // weak
int dword_10121F68[] = { 0 }; // weak
int dword_10121F6C[] = { 0 }; // weak
int dword_10121F70[] = { 0 }; // weak
int dword_10121F74[] = { 0 }; // weak
int dword_10121F78[] = { 0 }; // weak
char off_10121F7C[32] =
{
  'h',
  '',
  '\x10',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_101224E0[] = { '\0' }; // weak
char byte_101224E1[] = { '\0' }; // weak
char byte_101224E2[] = { '\0' }; // weak
int dword_101224E4[] = { 0 }; // weak
char *off_101224E8 = "0, 0, 0"; // weak
int dword_101226F0[] = { 0 }; // weak
int dword_101226F4[] = { 0 }; // weak
int dword_101226F8[] = { 0 }; // weak
int dword_101226FC[] = { 0 }; // weak
char *off_10122700 = "0, 0, 0"; // weak
_UNKNOWN unk_101236E0; // weak
__int16 word_10126740[] = { 43 }; // weak
__int16 word_10126742[] = { 111 }; // weak
char byte_10126744[] = { '\x06' }; // weak
char byte_10127BB0[] = { '\0' }; // weak
__int16 word_101283AC[] = { 464 }; // weak
_UNKNOWN unk_1013A01A; // weak
int dword_1013A01C = 9429; // idb
int dword_1013AD14[] = { 9826 }; // weak
_UNKNOWN unk_1013AD18; // weak
_UNKNOWN unk_1013AE90; // weak
__int16 word_1013AE92[] = { 301 }; // weak
__int16 word_1013AE94[] = { 302 }; // weak
__int16 word_1013AE96[] = { 303 }; // weak
__int16 word_1013AE98[] = { 304 }; // weak
__int16 word_1013AE9A[] = { 305 }; // weak
__int16 word_1013AE9C[] = { 306 }; // weak
__int16 word_1013AE9E[] = { 307 }; // weak
_UNKNOWN unk_1013D410; // weak
_UNKNOWN unk_1013D478; // weak
_UNKNOWN unk_1013D4DC; // weak
int dword_1013E3A8 = 64; // weak
__int16 word_1013E3AC[] = { 6782 }; // weak
__int16 word_1013E3B0[] = { 128 }; // weak
_UNKNOWN unk_1013E3CC; // weak
_DWORD dword_1013E3D0[4] = { 64, 24, 62, 18 }; // idb
_UNKNOWN unk_1013E3E4; // weak
__int16 word_1013E3E6[] = { 420 }; // weak
int dword_1013E3F4[] = { 0 }; // weak
_UNKNOWN unk_1013E400; // weak
__int16 word_1013E402[] = { 0 }; // weak
char byte_1013E448[] = { '\x01' }; // weak
__int16 word_1013E44A[] = { 3020 }; // weak
char byte_1013EBC8[] = { '7' }; // weak
int dword_1013EBCC[] = { 6829 }; // weak
__int16 word_1013F6DA[] = { 233 }; // weak
int dword_1013F6E0[] = { 6201 }; // weak
__int16 word_10141418[] = { 114 }; // weak
_UNKNOWN unk_10141C50; // weak
int dword_10141C54[] = { 6006 }; // weak
_UNKNOWN unk_101437E0; // weak
_UNKNOWN unk_101437E1; // weak
_UNKNOWN unk_10144648; // weak
__int16 word_1014464A[] = { 565 }; // weak
int (__cdecl *off_101446C8[2])(int, int) = { &sub_10064720, &sub_10064780 }; // weak
_UNKNOWN unk_10144898; // weak
char *off_10144A3C[3] = { "***global-commands***", "..\\lib\\utf\\utf_runner.c", &off_10144A50 }; // weak
char *off_10144BE0 = "true"; // weak
char byte_10144BE4[] = { '\x01' }; // weak
char *off_10144C48 = "failure listener"; // weak
char *off_10145600 = "printf_listener"; // weak
__int16 word_10146234 = 2573; // weak
char *off_10146390 = "gate_listener"; // weak
_UNKNOWN unk_101495F0; // weak
_UNKNOWN unk_101495F4; // weak
_UNKNOWN unk_101495F8; // weak
_UNKNOWN unk_101495FC; // weak
_UNKNOWN unk_10149600; // weak
_UNKNOWN unk_10149604; // weak
_UNKNOWN unk_10149CB8; // weak
void *off_10149CBC = &unk_101495F0; // weak
_UNKNOWN unk_10149D68; // weak
void *off_10149D6C = &unk_101495F0; // weak
void *off_10149D78 = &unk_101495F4; // weak
void *off_10149D84 = &unk_101495F8; // weak
void *off_10149D90 = &unk_101495FC; // weak
void *off_10149D9C = &unk_10149600; // weak
void *off_1014A228 = &unk_10149660; // weak
void *off_1014A234 = &unk_1014962C; // weak
void *off_1014A240 = &unk_101496AC; // weak
void *off_1014A24C = &unk_101496E0; // weak
void *off_1014A258 = &unk_101497B0; // weak
void *off_1014A264 = &unk_1014979C; // weak
void *off_1014A270 = &unk_1014988C; // weak
void *off_1014A27C = &unk_101498B0; // weak
void *off_1014A288 = &unk_101498D4; // weak
void *off_1014A294 = &unk_101498F8; // weak
void *off_1014A2A0 = &unk_10149600; // weak
void *off_1014A2B8 = &unk_101495F0; // weak
void *off_1014A2C4 = &unk_101495F4; // weak
void *off_1014A2D0 = &unk_10149C04; // weak
void *off_1014A2DC = &unk_101495FC; // weak
void *off_1014A2E8 = &unk_10149600; // weak
void *off_1014A2F4 = &unk_10149604; // weak
void *off_1014A300 = &unk_101495F0; // weak
void *off_1014A30C = &unk_10149C10; // weak
void *off_1014A318 = &unk_101495F8; // weak
void *off_1014A324 = &unk_101495FC; // weak
void *off_1014A330 = &unk_10149600; // weak
void *off_1014A33C = &unk_10149604; // weak
_UNKNOWN unk_1014A348; // weak
void *off_1014A34C = &unk_101495F4; // weak
void *off_1014A358 = &unk_1014987C; // weak
_UNKNOWN unk_1014A5CC; // weak
_UNKNOWN unk_1014A5D0; // weak
_UNKNOWN unk_1014A5D4; // weak
_UNKNOWN unk_1014A5DC; // weak
_UNKNOWN unk_1014A5E0; // weak
_UNKNOWN unk_1014A688; // weak
_UNKNOWN unk_1014A698; // weak
_UNKNOWN unk_1014A78C; // weak
_UNKNOWN unk_1014A818; // weak
_UNKNOWN unk_1014A81C; // weak
_UNKNOWN unk_1014A820; // weak
_UNKNOWN unk_1014A874; // weak
_UNKNOWN unk_1014A898; // weak
void *off_1014EA7C = &unk_1014E388; // weak
void *off_1014EA84 = &unk_1014E38C; // weak
void *off_1014EA8C = &unk_1014E390; // weak
void *off_1014EA94 = &unk_1014E394; // weak
void *off_1014EA9C = &unk_1014E398; // weak
void *off_1014F340 = &unk_1014E388; // weak
void *off_1014F348 = &unk_1014E38C; // weak
void *off_1014F350 = &unk_1014E390; // weak
void *off_1014F358 = &unk_1014E394; // weak
void *off_1014F360 = &unk_1014E398; // weak
void *off_1014F4D0 = &unk_1014E388; // weak
void *off_1014F4D8 = &unk_1014E38C; // weak
void *off_1014F4E0 = &unk_1014E390; // weak
void *off_1014F4E8 = &unk_1014E394; // weak
void *off_1014F4F0 = &unk_1014E398; // weak
void *off_1014F570 = &unk_1014E388; // weak
void *off_1014F578 = &unk_1014E38C; // weak
void *off_1014F580 = &unk_1014E390; // weak
void *off_1014F588 = &unk_1014E394; // weak
void *off_1014F590 = &unk_1014E398; // weak
void *off_1014F72C = &unk_1014E388; // weak
void *off_1014F734 = &unk_1014E38C; // weak
void *off_1014F73C = &unk_1014E390; // weak
void *off_1014F744 = &unk_1014E394; // weak
void *off_1014F74C = &unk_1014E398; // weak
void *off_1014F888 = &unk_1014E388; // weak
void *off_1014F890 = &unk_1014E38C; // weak
void *off_1014F898 = &unk_1014E390; // weak
void *off_1014F8A0 = &unk_1014E394; // weak
void *off_1014F8A8 = &unk_1014E398; // weak
void *off_1014F900 = &unk_1014E388; // weak
void *off_1014F908 = &unk_1014E38C; // weak
void *off_1014F910 = &unk_1014B168; // weak
void *off_1014F918 = &unk_1014E394; // weak
void *off_1014F920 = &unk_1014E398; // weak
void *off_1014F928 = &unk_1014DA40; // weak
void *off_1014F930 = &unk_1014E38C; // weak
void *off_1014F938 = &unk_1014DA50; // weak
void *off_1014F940 = &unk_1014E394; // weak
void *off_1014F948 = &unk_1014E398; // weak
void *off_1014F950 = &unk_1014D5F0; // weak
void *off_1014F958 = &unk_1014D710; // weak
void *off_1014F960 = &unk_1014D808; // weak
void *off_1014F968 = &unk_1014D888; // weak
void *off_1014F970 = &unk_1014D9AC; // weak
void *off_1014F97C = &unk_1014E388; // weak
void *off_1014F984 = &unk_1014E38C; // weak
void *off_1014F98C = &unk_1014E390; // weak
void *off_1014F994 = &unk_1014E394; // weak
void *off_1014F99C = &unk_1014E398; // weak
void *off_101501EC = &unk_1014E388; // weak
void *off_101501F4 = &unk_1014E38C; // weak
void *off_101501FC = &unk_1014E390; // weak
void *off_10150204 = &unk_1014E394; // weak
void *off_1015020C = &unk_1014E398; // weak
void *off_1015070C = &unk_1014E388; // weak
void *off_10150714 = &unk_1014E704; // weak
void *off_1015071C = &unk_1014E390; // weak
void *off_10150724 = &unk_1014E394; // weak
void *off_1015072C = &unk_1014E398; // weak
void *off_10150734 = &unk_1014E754; // weak
void *off_1015073C = &unk_1014E764; // weak
void *off_10150744 = &unk_1014E79C; // weak
void *off_1015074C = &unk_1014E394; // weak
void *off_10150754 = &unk_1014E398; // weak
void *off_1015075C = &unk_1014E388; // weak
void *off_10150784 = &unk_1014E388; // weak
_UNKNOWN unk_10150830; // weak
_UNKNOWN unk_10150834; // weak
_UNKNOWN unk_10150838; // weak
_UNKNOWN unk_101508C0; // weak
_UNKNOWN unk_10150934; // weak
void *off_10150A14 = &unk_1015096C; // weak
void *off_10150A1C = &unk_10150970; // weak
void *off_10150A24 = &unk_101509D8; // weak
void *off_10150A2C = &unk_101509DC; // weak
void *off_10150A34 = &unk_10150A0C; // weak
int dword_10150A3C[] = { 67108864 }; // weak
void *off_10152E48 = &unk_10152E34; // weak
void *off_10152E54 = &unk_10151EF8; // weak
void *off_10152E60 = &unk_10151F78; // weak
void *off_10152E6C = &unk_10151FD8; // weak
void *off_10152E78 = &unk_10151EE4; // weak
void *off_10152E84 = &unk_10152E34; // weak
void *off_10152EC4 = &unk_10152E34; // weak
void *off_10152ED0 = &unk_10152E38; // weak
void *off_10152EDC = &unk_10152E3C; // weak
void *off_10152EE8 = &unk_10152E40; // weak
void *off_10152EF4 = &unk_10152E44; // weak
void *off_10153784 = &unk_10152E34; // weak
void *off_10153790 = &unk_10152E38; // weak
void *off_1015379C = &unk_10152E3C; // weak
void *off_101537A8 = &unk_10152E40; // weak
void *off_101537B4 = &unk_10152E44; // weak
_UNKNOWN unk_101540A8; // weak
_UNKNOWN unk_101540AC; // weak
_UNKNOWN unk_101540B0; // weak
_UNKNOWN unk_101540B4; // weak
_UNKNOWN unk_101540B8; // weak
_UNKNOWN unk_101540BC; // weak
_UNKNOWN unk_101540C0; // weak
_UNKNOWN unk_101540EC; // weak
_UNKNOWN unk_10154110; // weak
_UNKNOWN unk_10154140; // weak
_UNKNOWN unk_101541B8; // weak
_UNKNOWN unk_101542B0; // weak
_UNKNOWN unk_101542BC; // weak
_UNKNOWN unk_101542D0; // weak
void *off_101542E0 = &unk_10154134; // weak
void *off_101542F0 = &unk_10154220; // weak
void *off_10154300 = &unk_10154250; // weak
void *off_10154310 = &unk_10154280; // weak
void *off_10154320 = &unk_101540B8; // weak
void *off_10154330 = &unk_101540BC; // weak
_UNKNOWN unk_10154340; // weak
_UNKNOWN unk_10154344; // weak
_UNKNOWN unk_10154378; // weak
_UNKNOWN unk_101543A8; // weak
_UNKNOWN unk_101543E8; // weak
_UNKNOWN unk_10154410; // weak
_UNKNOWN unk_10154414; // weak
_UNKNOWN unk_10154430; // weak
_UNKNOWN unk_10154474; // weak
_UNKNOWN unk_10154488; // weak
_WORD dword_101544B0[512] =
{
  25542,
  42339,
  31992,
  33916,
  30702,
  39287,
  31734,
  36219,
  62207,
  3570,
  27606,
  48491,
  28638,
  45423,
  50577,
  21701,
  12384,
  20528,
  258,
  769,
  26574,
  43367,
  11094,
  32043,
  65255,
  6654,
  55221,
  25303,
  43853,
  59051,
  30444,
  39542,
  51855,
  17866,
  33311,
  40322,
  51593,
  16585,
  32250,
  34685,
  64239,
  5626,
  22962,
  60249,
  18318,
  51527,
  61691,
  3056,
  44353,
  60589,
  54451,
  26580,
  41567,
  64930,
  44869,
  60079,
  39971,
  49052,
  42067,
  63396,
  29412,
  38514,
  49307,
  23488,
  46965,
  49847,
  64993,
  7421,
  37693,
  44691,
  9804,
  27174,
  13932,
  23094,
  16254,
  16703,
  63477,
  759,
  52355,
  20428,
  13416,
  23604,
  42321,
  62629,
  58833,
  13541,
  61945,
  2289,
  29154,
  37745,
  55467,
  29656,
  12642,
  21297,
  5418,
  16149,
  1032,
  3076,
  51093,
  21191,
  9030,
  25891,
  50077,
  24259,
  6192,
  10264,
  38455,
  41366,
  1290,
  3845,
  39471,
  46490,
  1806,
  2311,
  4644,
  13842,
  32795,
  39808,
  58079,
  15842,
  60365,
  9963,
  10062,
  26919,
  45695,
  52658,
  30186,
  40821,
  2322,
  6921,
  33565,
  40579,
  11352,
  29740,
  6708,
  11802,
  6966,
  11547,
  28380,
  45678,
  23220,
  61018,
  41051,
  64416,
  21156,
  63058,
  15222,
  19771,
  54967,
  25046,
  45949,
  52915,
  10578,
  31529,
  58333,
  16099,
  12126,
  28975,
  33811,
  38788,
  21414,
  62803,
  53689,
  26833,
  0,
  0,
  60865,
  11501,
  8256,
  24608,
  64739,
  8188,
  45433,
  51377,
  23478,
  60763,
  27348,
  48746,
  52109,
  18123,
  48743,
  55742,
  14706,
  19257,
  19092,
  56906,
  19608,
  54348,
  22704,
  59480,
  53125,
  19151,
  53435,
  27600,
  61381,
  10991,
  43599,
  58794,
  64493,
  5883,
  17286,
  50499,
  19866,
  55117,
  13158,
  21811,
  34065,
  38021,
  17802,
  53061,
  63977,
  4345,
  516,
  1538,
  32766,
  33151,
  20640,
  61520,
  15480,
  17468,
  40741,
  47775,
  43083,
  58280,
  20898,
  62289,
  41821,
  65187,
  16512,
  49216,
  36613,
  35471,
  37439,
  44434,
  40225,
  48285,
  14448,
  18488,
  62961,
  1269,
  48227,
  57276,
  46711,
  49590,
  55983,
  30170,
  8514,
  25377,
  4128,
  12304,
  65509,
  6911,
  62461,
  3827,
  53951,
  28114,
  52609,
  19661,
  3096,
  5132,
  4902,
  13587,
  60611,
  12268,
  24510,
  57695,
  38709,
  41623,
  17544,
  52292,
  5934,
  14615,
  50323,
  22468,
  42837,
  62119,
  32508,
  33406,
  15738,
  18237,
  25800,
  44132,
  23994,
  59229,
  6450,
  11033,
  29670,
  38259,
  24768,
  41056,
  33049,
  39041,
  20382,
  53583,
  56483,
  32732,
  8772,
  26146,
  10836,
  32298,
  36923,
  43920,
  34827,
  33672,
  18060,
  51782,
  61127,
  10734,
  47211,
  54200,
  5160,
  15380,
  56999,
  31198,
  24252,
  57950,
  2838,
  7435,
  56237,
  30427,
  57563,
  15328,
  12900,
  22066,
  14964,
  20026,
  2580,
  7690,
  18834,
  56137,
  1548,
  2566,
  9288,
  27684,
  23736,
  58460,
  49823,
  24002,
  54205,
  28371,
  44099,
  61356,
  25284,
  42594,
  37177,
  43153,
  38193,
  42133,
  58579,
  14308,
  31218,
  35705,
  59349,
  13031,
  51339,
  17352,
  14190,
  22839,
  28122,
  46957,
  36097,
  35981,
  54705,
  25813,
  20124,
  53838,
  43337,
  57513,
  27864,
  46188,
  22188,
  64086,
  62707,
  2036,
  60111,
  9706,
  26058,
  44901,
  31476,
  36474,
  44615,
  59822,
  2064,
  6152,
  47727,
  54714,
  30960,
  34936,
  9546,
  28453,
  11868,
  29230,
  7224,
  9244,
  42583,
  61862,
  46195,
  51124,
  50839,
  20934,
  59595,
  9192,
  56737,
  31965,
  29928,
  40052,
  7998,
  8479,
  19350,
  56651,
  48481,
  56509,
  35597,
  34443,
  35343,
  34186,
  28896,
  36976,
  15996,
  16958,
  46449,
  50357,
  26316,
  43622,
  18576,
  55368,
  774,
  1283,
  63223,
  502,
  3612,
  4622,
  25026,
  41825,
  13674,
  24373,
  22446,
  63831,
  47465,
  53433,
  34327,
  37254,
  49561,
  22721,
  7482,
  10013,
  40487,
  47518,
  57817,
  14561,
  63723,
  5112,
  38955,
  45976,
  4386,
  13073,
  27090,
  47977,
  55721,
  28889,
  36359,
  35214,
  37939,
  42900,
  39725,
  46747,
  7740,
  8734,
  34581,
  37511,
  59849,
  8425,
  52871,
  18894,
  21930,
  65365,
  10320,
  30760,
  57253,
  31455,
  35843,
  36748,
  41305,
  63649,
  35081,
  32905,
  3354,
  5901,
  48997,
  55999,
  59095,
  12774,
  17028,
  50754,
  26832,
  47208,
  16770,
  49985,
  39209,
  45209,
  11610,
  30509,
  3870,
  4367,
  45179,
  52144,
  21672,
  64596,
  47981,
  54971,
  5676,
  14870
}; // idb
_WORD dword_101548B0[512] =
{
  50853,
  25443,
  63620,
  31868,
  61081,
  30583,
  63117,
  31611,
  65293,
  62194,
  54973,
  27499,
  57009,
  28527,
  37204,
  50629,
  24656,
  12336,
  515,
  257,
  52905,
  26471,
  22141,
  11051,
  59161,
  65278,
  46434,
  55255,
  19942,
  43947,
  60570,
  30326,
  36677,
  51914,
  8093,
  33410,
  35136,
  51657,
  64135,
  32125,
  61205,
  64250,
  45803,
  22873,
  36553,
  18247,
  64267,
  61680,
  16876,
  44461,
  45927,
  54484,
  24573,
  41634,
  17898,
  44975,
  9151,
  40092,
  21495,
  42148,
  58518,
  29298,
  39771,
  49344,
  30146,
  47031,
  57628,
  65021,
  15790,
  37779,
  19562,
  9766,
  27738,
  13878,
  32321,
  16191,
  62722,
  63479,
  33615,
  52428,
  26716,
  13364,
  20980,
  42405,
  53556,
  58853,
  63752,
  61937,
  58003,
  29041,
  43891,
  55512,
  25171,
  12593,
  10815,
  5397,
  2060,
  1028,
  38226,
  51143,
  18021,
  8995,
  40286,
  50115,
  12328,
  6168,
  14241,
  38550,
  2575,
  1285,
  12213,
  39578,
  3593,
  1799,
  9270,
  4626,
  7067,
  32896,
  57149,
  58082,
  52518,
  60395,
  20073,
  10023,
  32717,
  45746,
  60063,
  30069,
  4635,
  2313,
  7582,
  33667,
  22644,
  11308,
  13358,
  6682,
  13869,
  6939,
  56498,
  28270,
  46318,
  23130,
  23547,
  41120,
  42230,
  21074,
  30285,
  15163,
  46945,
  54998,
  32206,
  46003,
  21115,
  10537,
  56638,
  58339,
  24177,
  12079,
  5015,
  33924,
  42741,
  21331,
  47464,
  53713,
  0,
  0,
  49452,
  60909,
  16480,
  8224,
  58143,
  64764,
  31176,
  45489,
  46829,
  23387,
  54462,
  27242,
  36166,
  52171,
  26585,
  48830,
  29259,
  14649,
  38110,
  19018,
  39124,
  19532,
  45288,
  22616,
  34122,
  53199,
  47979,
  53456,
  50474,
  61423,
  20453,
  43690,
  60694,
  64507,
  34501,
  17219,
  39639,
  19789,
  26197,
  13107,
  4500,
  34181,
  35535,
  17733,
  59664,
  63993,
  1030,
  514,
  65153,
  32639,
  41200,
  20560,
  30788,
  15420,
  9658,
  40863,
  19427,
  43176,
  41715,
  20817,
  24062,
  41891,
  32960,
  16448,
  1418,
  36751,
  16301,
  37522,
  8636,
  40349,
  28744,
  14392,
  61700,
  62965,
  25567,
  48316,
  30657,
  46774,
  44917,
  56026,
  16995,
  8481,
  8240,
  4112,
  58650,
  65535,
  64782,
  62451,
  49005,
  53970,
  33100,
  52685,
  6164,
  3084,
  9781,
  4883,
  49967,
  60652,
  48865,
  24415,
  13730,
  38807,
  35020,
  17476,
  11833,
  5911,
  37719,
  50372,
  22002,
  42919,
  64642,
  32382,
  31303,
  15677,
  51372,
  25700,
  47847,
  23901,
  12843,
  6425,
  59029,
  29555,
  49312,
  24672,
  6552,
  33153,
  40657,
  20303,
  41855,
  56540,
  17510,
  8738,
  21630,
  10794,
  15275,
  37008,
  2947,
  34952,
  36042,
  17990,
  50985,
  61166,
  27603,
  47288,
  10300,
  5140,
  42873,
  57054,
  48354,
  24158,
  5661,
  2827,
  44406,
  56283,
  56123,
  57568,
  25686,
  12850,
  29774,
  14906,
  5150,
  2570,
  37595,
  18761,
  3082,
  1542,
  18540,
  9252,
  47332,
  23644,
  40797,
  49858,
  48494,
  54227,
  17391,
  44204,
  50342,
  25186,
  14760,
  37265,
  12708,
  38293,
  54071,
  58596,
  62091,
  31097,
  54578,
  59367,
  35651,
  51400,
  28249,
  14135,
  55991,
  28013,
  396,
  36237,
  45412,
  54741,
  40146,
  20046,
  18912,
  43433,
  55476,
  27756,
  44282,
  22102,
  62215,
  62708,
  53029,
  60138,
  51887,
  25957,
  62606,
  31354,
  18409,
  44718,
  4120,
  2056,
  28629,
  47802,
  61576,
  30840,
  19055,
  9509,
  23666,
  11822,
  14372,
  7196,
  22513,
  42662,
  29639,
  46260,
  38737,
  50886,
  52003,
  59624,
  41340,
  56797,
  59548,
  29812,
  15905,
  7967,
  38621,
  19275,
  25052,
  48573,
  3462,
  35723,
  3973,
  35466,
  57488,
  28784,
  31810,
  15934,
  29124,
  46517,
  52394,
  26214,
  37080,
  18504,
  1541,
  771,
  63233,
  63222,
  7186,
  3598,
  49827,
  24929,
  27231,
  13621,
  44793,
  22359,
  27088,
  47545,
  6033,
  34438,
  39256,
  49601,
  14887,
  7453,
  10169,
  40606,
  55608,
  57825,
  60179,
  63736,
  11187,
  39064,
  8755,
  4369,
  53947,
  26985,
  43376,
  55769,
  1929,
  36494,
  13223,
  38036,
  11702,
  39835,
  15394,
  7710,
  5522,
  34695,
  51488,
  59881,
  34633,
  52942,
  43775,
  21845,
  20600,
  10280,
  42362,
  57311,
  911,
  35980,
  23032,
  41377,
  2432,
  35209,
  6679,
  3341,
  26074,
  49087,
  55089,
  59110,
  33990,
  16962,
  53432,
  26728,
  33475,
  16705,
  10672,
  39321,
  23159,
  11565,
  7697,
  3855,
  31691,
  45232,
  43260,
  21588,
  28118,
  48059,
  11322,
  5654
}; // idb
_WORD dword_10154CB0[512] =
{
  42339,
  25542,
  33916,
  31992,
  39287,
  30702,
  36219,
  31734,
  3570,
  62207,
  48491,
  27606,
  45423,
  28638,
  21701,
  50577,
  20528,
  12384,
  769,
  258,
  43367,
  26574,
  32043,
  11094,
  6654,
  65255,
  25303,
  55221,
  59051,
  43853,
  39542,
  30444,
  17866,
  51855,
  40322,
  33311,
  16585,
  51593,
  34685,
  32250,
  5626,
  64239,
  60249,
  22962,
  51527,
  18318,
  3056,
  61691,
  60589,
  44353,
  26580,
  54451,
  64930,
  41567,
  60079,
  44869,
  49052,
  39971,
  63396,
  42067,
  38514,
  29412,
  23488,
  49307,
  49847,
  46965,
  7421,
  64993,
  44691,
  37693,
  27174,
  9804,
  23094,
  13932,
  16703,
  16254,
  759,
  63477,
  20428,
  52355,
  23604,
  13416,
  62629,
  42321,
  13541,
  58833,
  2289,
  61945,
  37745,
  29154,
  29656,
  55467,
  21297,
  12642,
  16149,
  5418,
  3076,
  1032,
  21191,
  51093,
  25891,
  9030,
  24259,
  50077,
  10264,
  6192,
  41366,
  38455,
  3845,
  1290,
  46490,
  39471,
  2311,
  1806,
  13842,
  4644,
  39808,
  32795,
  15842,
  58079,
  9963,
  60365,
  26919,
  10062,
  52658,
  45695,
  40821,
  30186,
  6921,
  2322,
  40579,
  33565,
  29740,
  11352,
  11802,
  6708,
  11547,
  6966,
  45678,
  28380,
  61018,
  23220,
  64416,
  41051,
  63058,
  21156,
  19771,
  15222,
  25046,
  54967,
  52915,
  45949,
  31529,
  10578,
  16099,
  58333,
  28975,
  12126,
  38788,
  33811,
  62803,
  21414,
  26833,
  53689,
  0,
  0,
  11501,
  60865,
  24608,
  8256,
  8188,
  64739,
  51377,
  45433,
  60763,
  23478,
  48746,
  27348,
  18123,
  52109,
  55742,
  48743,
  19257,
  14706,
  56906,
  19092,
  54348,
  19608,
  59480,
  22704,
  19151,
  53125,
  27600,
  53435,
  10991,
  61381,
  58794,
  43599,
  5883,
  64493,
  50499,
  17286,
  55117,
  19866,
  21811,
  13158,
  38021,
  34065,
  53061,
  17802,
  4345,
  63977,
  1538,
  516,
  33151,
  32766,
  61520,
  20640,
  17468,
  15480,
  47775,
  40741,
  58280,
  43083,
  62289,
  20898,
  65187,
  41821,
  49216,
  16512,
  35471,
  36613,
  44434,
  37439,
  48285,
  40225,
  18488,
  14448,
  1269,
  62961,
  57276,
  48227,
  49590,
  46711,
  30170,
  55983,
  25377,
  8514,
  12304,
  4128,
  6911,
  65509,
  3827,
  62461,
  28114,
  53951,
  19661,
  52609,
  5132,
  3096,
  13587,
  4902,
  12268,
  60611,
  57695,
  24510,
  41623,
  38709,
  52292,
  17544,
  14615,
  5934,
  22468,
  50323,
  62119,
  42837,
  33406,
  32508,
  18237,
  15738,
  44132,
  25800,
  59229,
  23994,
  11033,
  6450,
  38259,
  29670,
  41056,
  24768,
  39041,
  33049,
  53583,
  20382,
  32732,
  56483,
  26146,
  8772,
  32298,
  10836,
  43920,
  36923,
  33672,
  34827,
  51782,
  18060,
  10734,
  61127,
  54200,
  47211,
  15380,
  5160,
  31198,
  56999,
  57950,
  24252,
  7435,
  2838,
  30427,
  56237,
  15328,
  57563,
  22066,
  12900,
  20026,
  14964,
  7690,
  2580,
  56137,
  18834,
  2566,
  1548,
  27684,
  9288,
  58460,
  23736,
  24002,
  49823,
  28371,
  54205,
  61356,
  44099,
  42594,
  25284,
  43153,
  37177,
  42133,
  38193,
  14308,
  58579,
  35705,
  31218,
  13031,
  59349,
  17352,
  51339,
  22839,
  14190,
  46957,
  28122,
  35981,
  36097,
  25813,
  54705,
  53838,
  20124,
  57513,
  43337,
  46188,
  27864,
  64086,
  22188,
  2036,
  62707,
  9706,
  60111,
  44901,
  26058,
  36474,
  31476,
  59822,
  44615,
  6152,
  2064,
  54714,
  47727,
  34936,
  30960,
  28453,
  9546,
  29230,
  11868,
  9244,
  7224,
  61862,
  42583,
  51124,
  46195,
  20934,
  50839,
  9192,
  59595,
  31965,
  56737,
  40052,
  29928,
  8479,
  7998,
  56651,
  19350,
  56509,
  48481,
  34443,
  35597,
  34186,
  35343,
  36976,
  28896,
  16958,
  15996,
  50357,
  46449,
  43622,
  26316,
  55368,
  18576,
  1283,
  774,
  502,
  63223,
  4622,
  3612,
  41825,
  25026,
  24373,
  13674,
  63831,
  22446,
  53433,
  47465,
  37254,
  34327,
  22721,
  49561,
  10013,
  7482,
  47518,
  40487,
  14561,
  57817,
  5112,
  63723,
  45976,
  38955,
  13073,
  4386,
  47977,
  27090,
  28889,
  55721,
  35214,
  36359,
  42900,
  37939,
  46747,
  39725,
  8734,
  7740,
  37511,
  34581,
  8425,
  59849,
  18894,
  52871,
  65365,
  21930,
  30760,
  10320,
  31455,
  57253,
  36748,
  35843,
  63649,
  41305,
  32905,
  35081,
  5901,
  3354,
  55999,
  48997,
  12774,
  59095,
  50754,
  17028,
  47208,
  26832,
  49985,
  16770,
  45209,
  39209,
  30509,
  11610,
  4367,
  3870,
  52144,
  45179,
  64596,
  21672,
  54971,
  47981,
  14870,
  5676
}; // idb
_WORD dword_101550B0[512] =
{
  25443,
  50853,
  31868,
  63620,
  30583,
  61081,
  31611,
  63117,
  62194,
  65293,
  27499,
  54973,
  28527,
  57009,
  50629,
  37204,
  12336,
  24656,
  257,
  515,
  26471,
  52905,
  11051,
  22141,
  65278,
  59161,
  55255,
  46434,
  43947,
  19942,
  30326,
  60570,
  51914,
  36677,
  33410,
  8093,
  51657,
  35136,
  32125,
  64135,
  64250,
  61205,
  22873,
  45803,
  18247,
  36553,
  61680,
  64267,
  44461,
  16876,
  54484,
  45927,
  41634,
  24573,
  44975,
  17898,
  40092,
  9151,
  42148,
  21495,
  29298,
  58518,
  49344,
  39771,
  47031,
  30146,
  65021,
  57628,
  37779,
  15790,
  9766,
  19562,
  13878,
  27738,
  16191,
  32321,
  63479,
  62722,
  52428,
  33615,
  13364,
  26716,
  42405,
  20980,
  58853,
  53556,
  61937,
  63752,
  29041,
  58003,
  55512,
  43891,
  12593,
  25171,
  5397,
  10815,
  1028,
  2060,
  51143,
  38226,
  8995,
  18021,
  50115,
  40286,
  6168,
  12328,
  38550,
  14241,
  1285,
  2575,
  39578,
  12213,
  1799,
  3593,
  4626,
  9270,
  32896,
  7067,
  58082,
  57149,
  60395,
  52518,
  10023,
  20073,
  45746,
  32717,
  30069,
  60063,
  2313,
  4635,
  33667,
  7582,
  11308,
  22644,
  6682,
  13358,
  6939,
  13869,
  28270,
  56498,
  23130,
  46318,
  41120,
  23547,
  21074,
  42230,
  15163,
  30285,
  54998,
  46945,
  46003,
  32206,
  10537,
  21115,
  58339,
  56638,
  12079,
  24177,
  33924,
  5015,
  21331,
  42741,
  53713,
  47464,
  0,
  0,
  60909,
  49452,
  8224,
  16480,
  64764,
  58143,
  45489,
  31176,
  23387,
  46829,
  27242,
  54462,
  52171,
  36166,
  48830,
  26585,
  14649,
  29259,
  19018,
  38110,
  19532,
  39124,
  22616,
  45288,
  53199,
  34122,
  53456,
  47979,
  61423,
  50474,
  43690,
  20453,
  64507,
  60694,
  17219,
  34501,
  19789,
  39639,
  13107,
  26197,
  34181,
  4500,
  17733,
  35535,
  63993,
  59664,
  514,
  1030,
  32639,
  65153,
  20560,
  41200,
  15420,
  30788,
  40863,
  9658,
  43176,
  19427,
  20817,
  41715,
  41891,
  24062,
  16448,
  32960,
  36751,
  1418,
  37522,
  16301,
  40349,
  8636,
  14392,
  28744,
  62965,
  61700,
  48316,
  25567,
  46774,
  30657,
  56026,
  44917,
  8481,
  16995,
  4112,
  8240,
  65535,
  58650,
  62451,
  64782,
  53970,
  49005,
  52685,
  33100,
  3084,
  6164,
  4883,
  9781,
  60652,
  49967,
  24415,
  48865,
  38807,
  13730,
  17476,
  35020,
  5911,
  11833,
  50372,
  37719,
  42919,
  22002,
  32382,
  64642,
  15677,
  31303,
  25700,
  51372,
  23901,
  47847,
  6425,
  12843,
  29555,
  59029,
  24672,
  49312,
  33153,
  6552,
  20303,
  40657,
  56540,
  41855,
  8738,
  17510,
  10794,
  21630,
  37008,
  15275,
  34952,
  2947,
  17990,
  36042,
  61166,
  50985,
  47288,
  27603,
  5140,
  10300,
  57054,
  42873,
  24158,
  48354,
  2827,
  5661,
  56283,
  44406,
  57568,
  56123,
  12850,
  25686,
  14906,
  29774,
  2570,
  5150,
  18761,
  37595,
  1542,
  3082,
  9252,
  18540,
  23644,
  47332,
  49858,
  40797,
  54227,
  48494,
  44204,
  17391,
  25186,
  50342,
  37265,
  14760,
  38293,
  12708,
  58596,
  54071,
  31097,
  62091,
  59367,
  54578,
  51400,
  35651,
  14135,
  28249,
  28013,
  55991,
  36237,
  396,
  54741,
  45412,
  20046,
  40146,
  43433,
  18912,
  27756,
  55476,
  22102,
  44282,
  62708,
  62215,
  60138,
  53029,
  25957,
  51887,
  31354,
  62606,
  44718,
  18409,
  2056,
  4120,
  47802,
  28629,
  30840,
  61576,
  9509,
  19055,
  11822,
  23666,
  7196,
  14372,
  42662,
  22513,
  46260,
  29639,
  50886,
  38737,
  59624,
  52003,
  56797,
  41340,
  29812,
  59548,
  7967,
  15905,
  19275,
  38621,
  48573,
  25052,
  35723,
  3462,
  35466,
  3973,
  28784,
  57488,
  15934,
  31810,
  46517,
  29124,
  26214,
  52394,
  18504,
  37080,
  771,
  1541,
  63222,
  63233,
  3598,
  7186,
  24929,
  49827,
  13621,
  27231,
  22359,
  44793,
  47545,
  27088,
  34438,
  6033,
  49601,
  39256,
  7453,
  14887,
  40606,
  10169,
  57825,
  55608,
  63736,
  60179,
  39064,
  11187,
  4369,
  8755,
  26985,
  53947,
  55769,
  43376,
  36494,
  1929,
  38036,
  13223,
  39835,
  11702,
  7710,
  15394,
  34695,
  5522,
  59881,
  51488,
  52942,
  34633,
  21845,
  43775,
  10280,
  20600,
  57311,
  42362,
  35980,
  911,
  41377,
  23032,
  35209,
  2432,
  3341,
  6679,
  49087,
  26074,
  59110,
  55089,
  16962,
  33990,
  26728,
  53432,
  16705,
  33475,
  39321,
  10672,
  11565,
  23159,
  3855,
  7697,
  45232,
  31691,
  21588,
  43260,
  48059,
  28118,
  5654,
  11322
}; // idb
int dword_101554B0[] = { 99 }; // weak
int dword_101558B0[] = { 25344 }; // weak
int dword_10155CB0[] = { 6488064 }; // weak
int dword_101560B0[] = { 1660944384 }; // weak
int dword_101564D8[] = { 128 }; // weak
int dword_101564E8[] = { 0 }; // weak
int dword_101564F8[] = { 0 }; // weak
char byte_10156569[] = { '\0' }; // weak
char byte_1015656A[] = { '\0' }; // weak
char byte_1015656B[] = { '\0' }; // weak
char byte_1015656C[] = { '\x10' }; // weak
int dword_10156580[] = { 0 }; // weak
_UNKNOWN unk_101565F8; // weak
_UNKNOWN unk_10156A78; // weak
char byte_10156AF0[] = { '\0' }; // weak
char byte_10156BF0[] = { '\0' }; // weak
char byte_10156CF0[] = { '\0' }; // weak
int dword_10156DF0[] = { 0 }; // weak
int dword_10156E68[] = { 0 }; // weak
__int16 word_10156EE0[] = { 0 }; // weak
__int16 word_10156EE2[] = { 0 }; // weak
__int16 word_10156EE4[] = { 0 }; // weak
__int16 word_10156EE6[] = { 0 }; // weak
int (__cdecl *off_10156EE8)(int, int) = &sub_10071510; // weak
void *off_10157094 = &unk_101565F8; // weak
void *off_101570A8 = &unk_10156A78; // weak
_UNKNOWN unk_101570BC; // weak
int dword_101570D0[] = { 0 }; // weak
int dword_10157118[] = { 16 }; // weak
_UNKNOWN unk_10157168; // weak
_UNKNOWN unk_101571E8; // weak
_UNKNOWN unk_10157268; // weak
_UNKNOWN unk_101572E0; // weak
_UNKNOWN unk_10157358; // weak
_UNKNOWN unk_10158358; // weak
_UNKNOWN unk_101584D8; // weak
_UNKNOWN unk_101584FC; // weak
_UNKNOWN unk_101586A0; // weak
_UNKNOWN unk_10158788; // weak
char byte_10159A39[] = { '\x1E' }; // weak
_UNKNOWN unk_1015A248; // weak
int dword_1015A24C[] = { 0 }; // weak
_UNKNOWN unk_1015A260; // weak
int dword_1015A264[] = { 0 }; // weak
_UNKNOWN unk_1015A288; // weak
int dword_1015A28C[] = { 0 }; // weak
_UNKNOWN unk_1015A2B8; // weak
int dword_1015A2BC[] = { 0 }; // weak
char byte_1015A370[] = { '\x01' }; // weak
__int16 word_1015A372[] = { 3020 }; // weak
char byte_1015BC38[] = { '\x01' }; // weak
__int16 word_1015BC40[] = { 3020 }; // weak
int dword_1015D234[] = { 0 }; // weak
__int16 *off_1015D238 = &word_10146234; // weak
_UNKNOWN unk_1015D2C8; // weak
_UNKNOWN unk_1015D2CC; // weak
_UNKNOWN unk_1015D2D0; // weak
_UNKNOWN unk_1015D2D4; // weak
_UNKNOWN unk_1015D2D8; // weak
_UNKNOWN unk_1015D2DC; // weak
_UNKNOWN unk_1015D2E0; // weak
_UNKNOWN unk_1015D2E4; // weak
__int16 word_10161B1C[] = { 100 }; // weak
char byte_101639CA[] = { '\x04' }; // weak
char byte_101639CF[] = { '\a' }; // weak
char *off_10167860[3] = { "04T1", "04B1", "04A1" }; // weak
char byte_1016787C[] = { '\0' }; // weak
char byte_101678A0[] = { '\b' }; // weak
__int16 word_10167A20[] = { 0 }; // weak
__int16 word_10167C20[] = { 0 }; // weak
int dword_10167E20[] = { 0 }; // weak
int dword_10168220[] = { 0 }; // weak
char byte_101691D0[] = { '\0' }; // weak
__int16 word_101691D2[] = { 0 }; // weak
char byte_10169948[] = { '\0' }; // weak
int dword_1016994C[] = { 29 }; // weak
_UNKNOWN unk_1016A3D8; // weak
int dword_1016A3DC[] = { 3535 }; // weak
_UNKNOWN unk_1016A410; // weak
int dword_1016A414[] = { 6813 }; // weak
_UNKNOWN unk_1016A448; // weak
int dword_1016A44C[] = { 9036 }; // weak
_UNKNOWN unk_1016A480; // weak
int dword_1016A484[] = { 6763 }; // weak
int dword_1016C080[] = { 6103 }; // weak
int dword_1016C084[] = { 8000 }; // weak
_UNKNOWN unk_1017A380; // weak
_UNKNOWN unk_1017A388; // weak
int (*off_1017C29C[3])() = { &_fptrap, &_fptrap, &_fptrap }; // weak
_UNKNOWN unk_1017C2C0; // weak
void *off_1017CD10 = &unk_103370C0; // weak
_UNKNOWN unk_1017CD20; // weak
_UNKNOWN unk_1017CD80; // weak
int dword_1017CF90 = 2; // weak
int dword_1017D290 = 1024; // weak
int dword_1017D294 = 4294966273; // weak
int dword_1017D298 = 53; // weak
int dword_1017D29C = 11; // weak
int dword_1017D2A0 = 64; // weak
int dword_1017D2A4 = 1023; // weak
int dword_1017D2A8 = 128; // weak
int dword_1017D2AC = 4294967169; // weak
int dword_1017D2B0 = 24; // weak
int dword_1017D2B4 = 8; // weak
int dword_1017D2B8 = 32; // weak
int dword_1017D2BC = 127; // weak
int dword_1017D950 = 0; // weak
int dword_1017D954 = 0; // weak
int dword_1017D958 = 0; // weak
int dword_1017D95C = 0; // weak
int dword_1017D960 = 0; // weak
int dword_1017D964 = 0; // weak
int dword_1017D968 = 0; // weak
int dword_1017D96C = 0; // weak
int dword_1017DA18 = 0; // weak
int dword_1017DA1C = 0; // weak
int dword_1017DA20 = 0; // weak
int dword_1017DA24 = 0; // weak
int dword_1017DAD0 = 0; // weak
int dword_1017DAD4 = 0; // weak
int dword_1017DAD8 = 0; // weak
int dword_1017DADC = 0; // weak
int dword_1017DB88 = 0; // weak
int dword_1017DB8C = 0; // weak
int dword_1017DB90 = 0; // weak
int dword_1017DB94 = 0; // weak
int dword_1017DC40 = 0; // weak
int dword_1017DC44 = 0; // weak
int dword_1017DC48 = 0; // weak
int dword_1017DC4C = 0; // weak
int dword_1017DC50 = 0; // weak
int dword_1017DC54 = 0; // weak
_UNKNOWN unk_1017DC60; // weak
int dword_1017DC78 = 0; // weak
_UNKNOWN unk_1017DC7C; // weak
char byte_1017DCF4 = '\0'; // weak
_UNKNOWN unk_1017DCF5; // weak
char byte_1017DD6D = '\0'; // weak
char byte_1017DD74 = '\0'; // weak
__int16 word_1017DD78 = 0; // weak
_UNKNOWN unk_1017DD80; // weak
_UNKNOWN unk_1017DE80; // weak
int dword_1019FE80; // weak
int dword_1019FE84; // weak
int dword_1019FE88[]; // weak
int dword_1019FE8C[]; // weak
int dword_1019FE90[]; // weak
int dword_1019FE94; // weak
int dword_1019FE98; // weak
int dword_1019FE9C; // weak
int dword_1019FEA0; // weak
_UNKNOWN unk_1019FEA8; // weak
char byte_101C19A4; // weak
int dword_101C19A8; // weak
_UNKNOWN unk_101C19AC; // weak
int dword_101C19B0; // weak
char byte_101C19B4; // weak
int dword_101C19B8; // weak
int dword_101C19BC; // weak
int dword_101C19C0; // weak
int dword_101C19C4; // weak
int dword_101C19C8; // weak
__int16 word_101C19CC; // weak
char byte_101C19D0; // weak
int dword_101C19D4; // weak
int dword_101C19D8; // weak
char byte_101C19DC; // weak
int dword_101C19DE; // weak
int dword_101C19E2; // weak
int dword_101C19E6; // weak
int dword_101C19EA; // weak
int dword_101C19EE; // weak
__int16 word_101C19F2; // weak
_UNKNOWN unk_101C19F4; // weak
char byte_101C39F8; // weak
_UNKNOWN unk_101C39FC; // weak
_UNKNOWN unk_101C3A02; // weak
_UNKNOWN unk_101C3A08; // weak
char byte_101C3A18; // weak
int dword_101C3A1C[]; // weak
int dword_101C3A20; // weak
int dword_101C3A24; // weak
char byte_101C3A29; // weak
_UNKNOWN unk_101C3A30; // weak
_UNKNOWN unk_101C3A3C; // weak
_UNKNOWN unk_101C3E40; // weak
int dword_101C6658; // weak
int dword_101C665C; // weak
char byte_101C6660; // weak
int dword_101C6661; // weak
int dword_101C6665; // weak
char byte_101C6669; // weak
int dword_101C666A; // weak
int dword_101C666E; // weak
int dword_101C6672; // weak
int dword_101C6676; // weak
int dword_101C667A; // weak
__int16 word_101C667E; // weak
int dword_101C6690; // weak
int dword_101C6694; // weak
char byte_101C6698; // weak
char byte_101C669C; // weak
char byte_101C669D; // weak
int dword_101C66A0; // weak
int dword_101C66A4; // weak
char byte_101C66A8; // weak
int dword_101C66B0; // weak
int dword_101C66B4; // weak
int dword_101C66B8; // weak
int dword_101C66BC; // weak
int dword_101C66C0; // weak
int dword_101C66C4; // weak
int dword_101C66C8; // weak
int dword_101C66CC; // weak
int dword_101C66D0; // weak
int dword_101C66D4; // weak
__int16 word_101C66D8; // weak
_UNKNOWN unk_101C66E0; // weak
_UNKNOWN unk_101E7DF0; // weak
_UNKNOWN unk_101EBEC8; // weak
int dword_101EC2C8; // weak
int dword_101EC2CC; // weak
_UNKNOWN unk_101EC2D0; // weak
int dword_101F8BCC; // weak
int dword_101F8BD0; // weak
int dword_101F8BF0; // weak
__int16 word_101F8BF4; // weak
char byte_101F8BF6; // weak
_UNKNOWN unk_101F8BF7; // weak
__int16 word_101FBD68; // weak
char byte_101FBD6A; // weak
char byte_101FBD6B; // weak
int dword_101FBD6C; // weak
int dword_101FBD70; // weak
int dword_101FBD74; // weak
int dword_101FBD78; // weak
char byte_101FBD7C; // weak
char byte_101FBD7D; // weak
char byte_101FBD7E; // weak
char byte_101FBD7F; // weak
int dword_101FBD80; // weak
int dword_101FBD84; // weak
int dword_101FBD88; // weak
char dword_101FBD8C[]; // idb
int dword_101FBD90; // weak
char byte_101FBD94; // weak
int dword_101FBD98; // weak
int dword_101FBD9C; // weak
__int16 word_101FCFBC; // weak
_UNKNOWN unk_101FCFC0; // weak
int dword_102289D4; // weak
_UNKNOWN unk_102289D8; // weak
int dword_10228FF0; // weak
int dword_10228FF4; // weak
_BYTE byte_10228FF8[8192]; // idb
int dword_1022AFF8; // weak
int dword_1022AFFC; // weak
int dword_1022B000; // weak
char byte_1022B004; // weak
int dword_1022B008; // weak
int dword_1022B00C; // weak
char byte_1022B010; // weak
int dword_1022B018[]; // weak
int dword_1022B918[]; // weak
int dword_1022C218; // weak
int dword_1022C220; // weak
char byte_1022C228; // weak
int dword_1022C22C; // weak
int dword_1022C230; // weak
int dword_1022C234; // weak
char byte_1022C238; // weak
_UNKNOWN unk_1022C23C; // weak
int dword_1022C250; // weak
__int16 word_1022C254; // weak
char byte_1022C256; // weak
char byte_1022C257; // weak
char byte_1022C358; // weak
char byte_1022C359[1031]; // idb
int dword_1022C760; // weak
int dword_1022C764; // weak
int dword_1022C768; // weak
int dword_1022C76C; // weak
int dword_1022C770; // weak
int dword_1022C774; // weak
int dword_1022C778; // weak
int dword_1022C77C; // weak
_UNKNOWN unk_1022C798; // weak
_UNKNOWN unk_1022C79C; // weak
_UNKNOWN unk_1022C7A0; // weak
_UNKNOWN unk_1022C7A4; // weak
char byte_1022C7A8; // weak
char byte_1022C7A9; // weak
char byte_1022C7AA; // weak
_UNKNOWN unk_1022C7B0; // weak
char byte_1022CD48; // weak
_UNKNOWN unk_1022CD4C; // weak
_UNKNOWN unk_1022CD50; // weak
int dword_1022CD5C; // weak
_UNKNOWN unk_1022CD88; // weak
_UNKNOWN unk_1022CD94; // weak
int dword_1022CDC8[]; // weak
int dword_1022CDCC; // weak
int dword_1022CDD0[]; // weak
int dword_1022CDD4; // weak
int dword_1022CDD8[]; // weak
int dword_1022CDDC; // weak
char byte_1022CDE0; // weak
int dword_1022CDE4; // weak
char byte_1022CDE8; // weak
char byte_1022CDE9; // weak
char byte_1022CDEA; // weak
char byte_1022CDEB; // weak
int dword_1022CDEC; // weak
int dword_1022CDF0; // weak
float flt_1022CDF4; // weak
char byte_1022CDF8; // weak
char byte_1022CDF9; // weak
char byte_1022CDFA; // weak
char byte_1022CDFB; // weak
int dword_1022CDFC; // weak
int dword_1022CE00; // weak
int dword_1022CE04; // weak
int dword_1022CE08; // weak
int dword_1022CE0C; // weak
char byte_1022CE10; // weak
char byte_1022CE11; // weak
char byte_1022CE12; // weak
char byte_1022CE13; // weak
int dword_1022CE14; // weak
float flt_1022CE18; // weak
int dword_1022CE1C; // weak
int dword_1022CE20; // weak
int dword_1022CE24; // weak
char byte_1022CE28; // weak
char byte_1022CE29; // weak
char byte_1022CE2A; // weak
char byte_1022CE2C; // weak
char byte_1022CE2D; // weak
int dword_1022CE30; // weak
int dword_1022CE34; // weak
char byte_1022CE38; // weak
char byte_1022CE39; // weak
_UNKNOWN unk_1022CE40; // weak
_UNKNOWN unk_1022D750; // weak
char byte_1022D752; // weak
_UNKNOWN unk_1022D784; // weak
_UNKNOWN unk_1022D790; // weak
_UNKNOWN unk_1022D7AC; // weak
char byte_1022D7E4; // idb
_UNKNOWN unk_1022D7EC; // weak
int dword_1022D80C; // weak
int dword_1022D810; // weak
int dword_1022D814; // weak
_UNKNOWN unk_1022D838; // weak
char byte_1022D83A; // weak
_UNKNOWN unk_1022D854; // weak
char byte_1022D864; // idb
_UNKNOWN unk_1022D878; // weak
_UNKNOWN unk_1022D894; // weak
_UNKNOWN unk_1022D8CC; // weak
_UNKNOWN unk_1022D8D4; // weak
int dword_1022D8F4; // weak
int dword_1022D8F8; // weak
char byte_1022D8FC; // weak
char byte_1022D8FD; // weak
__int16 word_1022D8FE; // weak
int dword_1022DAF0; // weak
int dword_1022DAF4; // weak
int dword_1022DAF8; // weak
int dword_102332F8; // weak
int dword_102332FC; // weak
char byte_10233300; // weak
int dword_10233304; // weak
int dword_10233308; // weak
int dword_1023330C; // weak
int dword_10233310; // weak
__int16 word_10238B10; // weak
char byte_10238B12; // weak
int dword_10238B14; // weak
int dword_10238B18[]; // weak
int dword_10238B1C; // weak
int dword_10238B20; // weak
int dword_10238B24; // weak
int dword_10238B28; // weak
int dword_10238B2C; // weak
int dword_10238B30; // weak
int dword_10238B34; // weak
char byte_10238B38[100]; // idb
int dword_10238B9C[]; // weak
int dword_10238BA0; // weak
char byte_10238BA8; // weak
char byte_10238BB0[]; // weak
char byte_10238BB1[]; // weak
char byte_10238BB2[]; // weak
char byte_10238BB3[]; // weak
char byte_10238BB4[]; // weak
int dword_10238BB8[]; // weak
int dword_10238BBC[]; // weak
int dword_10238BC0[]; // weak
int dword_10238BC4[]; // weak
char byte_10238BC8[]; // weak
int dword_10238C58; // weak
__int16 word_10238C5C; // weak
char byte_10238C60; // weak
char byte_10238C61; // weak
char byte_10238C62; // weak
_UNKNOWN unk_10238C68; // weak
int dword_10238D84; // weak
_UNKNOWN unk_10238D88; // weak
char byte_10238EA4[]; // weak
int dword_10238EA8; // weak
char byte_10238EB0; // weak
int dword_10238EB4; // weak
_UNKNOWN unk_10238EB8; // weak
int dword_10238EF8; // weak
int dword_10238EFC; // weak
int dword_10238F00; // weak
int dword_10238F04; // weak
char byte_10238F08; // weak
char byte_10238F09; // weak
char byte_10238F0A; // weak
char byte_10238F0B; // weak
int dword_10238F0C; // weak
char byte_10238F10; // weak
char byte_10238F11; // weak
char byte_10238F12; // weak
char byte_10238F13; // weak
char byte_10238F14; // weak
_UNKNOWN unk_10238F15; // weak
char byte_10238F16; // weak
char byte_10238F17; // weak
int dword_10238F18; // weak
char byte_10238F20; // weak
char byte_10238F21; // weak
char byte_10238F22; // weak
_UNKNOWN unk_10238F28; // weak
char byte_10238F2C; // weak
char byte_10238F2D; // weak
__int16 word_10238F2E; // weak
char byte_10238F30[]; // weak
char byte_10239174[]; // weak
char byte_1023A374[]; // weak
char byte_1023B574[]; // weak
_BYTE word_1023B5D4[192]; // idb
_DWORD dword_1023B694[8]; // idb
_UNKNOWN unk_1023B6B4; // weak
_UNKNOWN unk_1023B7B8; // weak
char byte_1023B7BC; // weak
char byte_1023B7BD; // weak
char byte_1023B7BE; // weak
char byte_1023B7BF; // weak
char byte_1023B7C0[]; // weak
char byte_1023BA04[]; // weak
char byte_1023CC04[]; // weak
char byte_1023DE04[]; // weak
char byte_1023DE64[]; // weak
_UNKNOWN unk_1023DF24; // weak
_UNKNOWN unk_1023DF44; // weak
int dword_1023E048; // weak
int dword_1023E04C; // weak
int dword_1023E050; // weak
char byte_1023E054; // weak
char byte_1023E055; // weak
int dword_1023E058; // weak
char byte_1023E05C; // weak
int dword_1023E060; // weak
char byte_1023E068; // weak
char byte_1023E069; // weak
_UNKNOWN unk_1023E070; // weak
int dword_1023E16C; // weak
char byte_1023E170; // weak
char byte_1023E171; // weak
char byte_1023E172; // weak
char byte_1023E173; // weak
int dword_1023E174[]; // weak
char byte_1023E184; // weak
char byte_1023E185; // weak
char byte_1023E186; // weak
char byte_1023E187; // weak
__int16 word_1023E188[]; // weak
int dword_1023E18C[]; // weak
int dword_1023E190[]; // weak
char byte_1023E199[]; // weak
char byte_1023E19A[]; // weak
__int16 word_1023E19C[]; // weak
char byte_1023E1A0[]; // weak
char byte_1023E1A2[]; // weak
__int16 word_1023E1A4[]; // weak
char byte_1023E1A8[]; // weak
char byte_1023E1A9[]; // weak
__int16 word_1023E1AA[]; // weak
char byte_1023E1AC[]; // weak
char byte_1023E1AD[]; // weak
char byte_1023E1AE[]; // weak
char byte_1023E1AF[]; // weak
int dword_1023E1B0[]; // weak
int dword_1023E1B4[]; // weak
int dword_1023E1B8[]; // weak
int dword_1023E1BC[]; // weak
int dword_1023E268; // weak
char byte_1023E26C; // weak
char byte_1023E26D; // weak
char byte_1023E26E; // weak
char byte_1023E26F; // weak
int dword_1023E270; // weak
int dword_1023E274; // weak
int dword_1023E278; // weak
char byte_1023E27C[]; // weak
char byte_1023E280[]; // weak
_UNKNOWN unk_1023E282; // weak
__int16 word_1023E284; // weak
int dword_1023E288; // weak
__int16 word_1023E28C; // weak
char byte_1023E290[]; // weak
int dword_1023E294; // weak
char byte_1023E298; // weak
char byte_1023E299; // weak
int dword_1023E29C; // weak
char byte_1023E2A0; // weak
char byte_1023E2A1; // weak
int dword_1023E2A8; // weak
int dword_1023E2AC; // weak
int dword_1023E2B0; // weak
int dword_1023E2B4; // weak
int dword_1023E2B8; // weak
int dword_1023E2BC; // weak
int dword_1023E2C0; // weak
int dword_1023E2C4; // weak
int dword_1023E2C8; // weak
int dword_1023E2CC; // weak
__int16 word_1023E2D0; // weak
char byte_1023E2D2; // weak
char byte_1023E2D3; // weak
float flt_1023E2D4; // weak
char byte_1023E2D8; // weak
__int16 word_1023E2D9; // weak
char byte_1023E2DB; // weak
void *dword_1023E2E0; // idb
int dword_1023E2E4; // weak
_BYTE byte_1023E2E8[3020]; // idb
int dword_1023EEB4; // weak
int dword_1023EEB8; // weak
int dword_1023EEBC; // weak
int dword_1023EEC0; // weak
int dword_1023EEC4; // weak
int dword_1023EEC8; // weak
int dword_1023EECC; // weak
int dword_1023EED0; // weak
int dword_1023EED4; // weak
int dword_1023EED8; // weak
int dword_1023EEDC; // weak
int dword_1023EEE0; // weak
int dword_1023EEE4; // weak
int dword_1023EEE8; // weak
float flt_1023EEEC[]; // weak
__int16 word_1023EEF8[]; // weak
float flt_1023EF00[]; // weak
int dword_1023EF0C[]; // weak
int dword_1023EF10; // weak
float flt_1023EF14; // weak
int dword_1023EF18; // weak
int dword_1023EF1C; // weak
float flt_1023EF20; // weak
int dword_1023EF24; // weak
char byte_1023EF28[]; // weak
char byte_1023EF29; // weak
char byte_1023EF2A; // weak
int dword_1023EF2C; // weak
char byte_1023EF30; // weak
char byte_1023EF31; // weak
char byte_1023EF32; // weak
int dword_1023EF34; // weak
int dword_1023EF38; // weak
char byte_1023EF40; // weak
__int16 word_1023EF42; // weak
int dword_1023EF44; // weak
int dword_1023EF4C; // weak
char byte_1023EFF1; // weak
char byte_1023EFF2; // weak
char byte_1023EFF3; // weak
int dword_1023EFF4; // weak
int dword_1024AFB4; // weak
int dword_1024B2D4; // weak
int dword_10250BA8; // weak
int dword_10250BAC; // weak
int dword_10250BB0; // weak
char byte_10250C40; // weak
char byte_10250C41; // weak
int dword_10250C44; // weak
int dword_10250C48; // weak
int dword_10250C4C; // weak
int dword_10250C50; // weak
int dword_10250C54; // weak
char byte_10250C58; // weak
int dword_1025645C; // weak
int dword_10256460; // weak
int dword_10256464; // weak
int dword_10256468; // weak
_UNKNOWN unk_10256470; // weak
char byte_10256818; // weak
char byte_10256819; // weak
__int16 word_10256820; // weak
char byte_10256830; // weak
char byte_10256831; // weak
int dword_1025683C[]; // weak
int dword_10256840; // weak
int dword_10256844; // weak
int dword_10256848; // weak
int dword_1025684C; // weak
int dword_10256850; // weak
char byte_10256854[]; // weak
_UNKNOWN unk_10256855; // weak
char byte_10256856[]; // weak
char byte_10256857[]; // weak
int dword_10256858; // weak
int dword_10256864; // weak
__int16 word_10256868; // weak
char byte_1025686A; // weak
char byte_1025686B; // weak
__int16 word_1025686C; // weak
int dword_10256870; // weak
__int16 word_10256874; // weak
int dword_10256878[]; // weak
int dword_1025687C; // weak
int dword_102569B8; // weak
__int16 word_102569C0; // weak
_UNKNOWN unk_102569C2; // weak
char byte_102569C3; // weak
char byte_102569C4; // weak
char byte_102569C5; // weak
char byte_102569C6; // weak
int dword_102569CA; // weak
int dword_102569CE; // weak
int dword_102569D2; // weak
int dword_102569D6; // weak
int dword_102569DA; // weak
int dword_102569DE; // weak
char byte_102573B4; // weak
char byte_102573B5; // weak
char byte_102573B6; // weak
char byte_102573B8[]; // weak
float flt_102574B8; // weak
float flt_102574BC; // weak
char byte_102574C0; // weak
char byte_102574C1; // weak
char byte_102574C8; // weak
char byte_102574CC; // weak
float flt_102574D0[]; // weak
float flt_102574D4[]; // weak
float flt_10257548[]; // weak
float flt_1025754C[]; // weak
char byte_102575C4; // weak
char byte_102575C8; // weak
float flt_102575CC[]; // weak
float flt_102575D0[]; // weak
float flt_10257644[]; // weak
float flt_10257648[]; // weak
char byte_10257748; // weak
_UNKNOWN unk_1025774C; // weak
int dword_10257750; // weak
int dword_10257754; // weak
_UNKNOWN unk_10257758; // weak
_UNKNOWN unk_1025776C; // weak
_UNKNOWN unk_1025AA58; // weak
void (__cdecl *dword_1025CBA8[8])(_DWORD, _DWORD, _DWORD); // idb
_UNKNOWN unk_1025CBC8; // weak
__int16 word_10261D34; // weak
__int16 word_10261D38; // weak
__int16 word_10261D3C; // weak
int dword_10261D40; // weak
int dword_10261D4C; // weak
int dword_10261D50; // weak
int dword_10261D54; // weak
int dword_10261D58; // weak
int dword_10261D5C; // weak
int dword_10261D60; // weak
char byte_10261D64; // weak
char byte_10261D65; // weak
char byte_10261D68; // weak
int dword_10261D6C; // weak
__int16 word_10261D70; // weak
__int16 word_10261D72; // weak
__int16 word_10261D74; // weak
__int16 word_10261D76; // weak
__int16 word_10261D78; // weak
int dword_10261D7C; // weak
_UNKNOWN unk_10261D80; // weak
char byte_10261D89; // weak
char byte_10261D8A; // weak
_UNKNOWN unk_10261DAA; // weak
_UNKNOWN unk_10261DD2; // weak
char byte_10261DFA[]; // weak
char byte_10261DFB[]; // weak
char byte_10261E07[]; // weak
__int16 word_10261E46[]; // weak
int dword_10263AD4; // weak
char byte_10263AD8; // weak
_UNKNOWN unk_10263AE0; // weak
_UNKNOWN unk_10263AE1; // weak
_UNKNOWN unk_10263AF7; // weak
_UNKNOWN unk_10263AF8; // weak
_UNKNOWN unk_10263AF9; // weak
_UNKNOWN unk_10263AFA; // weak
_UNKNOWN unk_10263AFC; // weak
_UNKNOWN unk_10263B00; // weak
_UNKNOWN unk_10263B04; // weak
_UNKNOWN unk_10263B24; // weak
_UNKNOWN unk_10263B44; // weak
_UNKNOWN unk_10263B64; // weak
_UNKNOWN unk_10263B84; // weak
_UNKNOWN unk_10263BA4; // weak
_UNKNOWN unk_10263BC4; // weak
_UNKNOWN unk_10263BE4; // weak
_UNKNOWN unk_10263C04; // weak
_UNKNOWN unk_10263C24; // weak
_UNKNOWN unk_10263C44; // weak
_UNKNOWN unk_10263C64; // weak
_UNKNOWN unk_10263C84; // weak
_UNKNOWN unk_10263CA4; // weak
_UNKNOWN unk_10263CC4; // weak
_UNKNOWN unk_10263CE4; // weak
_UNKNOWN unk_10263D04; // weak
_UNKNOWN unk_10263D24; // weak
_UNKNOWN unk_10263D44; // weak
_UNKNOWN unk_10263D64; // weak
_UNKNOWN unk_10263D84; // weak
_UNKNOWN unk_10263DA4; // weak
_UNKNOWN unk_10263DC4; // weak
_UNKNOWN unk_10263DE4; // weak
_UNKNOWN unk_10263E04; // weak
_UNKNOWN unk_10263E24; // weak
_UNKNOWN unk_10263E44; // weak
_UNKNOWN unk_10263E64; // weak
_UNKNOWN unk_10263E84; // weak
_UNKNOWN unk_10263E88; // weak
_UNKNOWN unk_10263E8C; // weak
_UNKNOWN unk_10263E90; // weak
_UNKNOWN unk_10263E94; // weak
_UNKNOWN unk_10263E98; // weak
_UNKNOWN unk_10263E9C; // weak
_UNKNOWN unk_10263EBC; // weak
_UNKNOWN unk_10263EDC; // weak
_UNKNOWN unk_10263EFC; // weak
_UNKNOWN unk_10263F1C; // weak
_UNKNOWN unk_10263F3C; // weak
_UNKNOWN unk_10263F5C; // weak
_UNKNOWN unk_10263F7C; // weak
_UNKNOWN unk_10263F9C; // weak
_UNKNOWN unk_10263F9D; // weak
_UNKNOWN unk_10263F9E; // weak
_UNKNOWN unk_10263FF0; // weak
_UNKNOWN unk_10264010; // weak
_UNKNOWN unk_10264030; // weak
_UNKNOWN unk_10264034; // weak
_UNKNOWN unk_10264038; // weak
_UNKNOWN unk_1026403C; // weak
_UNKNOWN unk_1026405C; // weak
_UNKNOWN unk_1026407C; // weak
_UNKNOWN unk_1026409C; // weak
_UNKNOWN unk_102640BC; // weak
_UNKNOWN unk_102640DC; // weak
_UNKNOWN unk_102640FC; // weak
_UNKNOWN unk_1026411C; // weak
_UNKNOWN unk_1026413C; // weak
_UNKNOWN unk_1026415C; // weak
_UNKNOWN unk_102641A4; // weak
_UNKNOWN unk_102641EC; // weak
_UNKNOWN unk_10264234; // weak
_UNKNOWN unk_1026427C; // weak
_UNKNOWN unk_102642C4; // weak
_UNKNOWN unk_1026430C; // weak
_UNKNOWN unk_10264354; // weak
_UNKNOWN unk_1026439C; // weak
_UNKNOWN unk_102643E4; // weak
_UNKNOWN unk_1026442C; // weak
_UNKNOWN unk_10264474; // weak
_UNKNOWN unk_102644BC; // weak
_UNKNOWN unk_10264504; // weak
_UNKNOWN unk_1026454C; // weak
_UNKNOWN unk_10264594; // weak
_UNKNOWN unk_102645DC; // weak
_UNKNOWN unk_10264624; // weak
_UNKNOWN unk_1026466C; // weak
_UNKNOWN unk_102646B4; // weak
_UNKNOWN unk_102646FC; // weak
_UNKNOWN unk_10264744; // weak
_UNKNOWN unk_1026478C; // weak
_UNKNOWN unk_102647D4; // weak
_UNKNOWN unk_1026481C; // weak
_UNKNOWN unk_10264864; // weak
_UNKNOWN unk_102648AC; // weak
_UNKNOWN unk_102648F4; // weak
_UNKNOWN unk_1026493C; // weak
_UNKNOWN unk_10264984; // weak
_UNKNOWN unk_102649CC; // weak
_UNKNOWN unk_102649E4; // weak
_UNKNOWN unk_10264A04; // weak
_UNKNOWN unk_10264A24; // weak
_UNKNOWN unk_10264A28; // weak
_UNKNOWN unk_10264ACC; // weak
_UNKNOWN unk_10264B70; // weak
_UNKNOWN unk_10264C14; // weak
_UNKNOWN unk_10264CB8; // weak
_UNKNOWN unk_10264D5C; // weak
_UNKNOWN unk_10264E00; // weak
_UNKNOWN unk_10264EA4; // weak
_UNKNOWN unk_10264F48; // weak
_UNKNOWN unk_10264FEC; // weak
_UNKNOWN unk_10265090; // weak
_UNKNOWN unk_10265134; // weak
_UNKNOWN unk_102651D8; // weak
_UNKNOWN unk_1026527C; // weak
_UNKNOWN unk_10265320; // weak
_UNKNOWN unk_102653C4; // weak
_UNKNOWN unk_10265468; // weak
_UNKNOWN unk_1026550C; // weak
_UNKNOWN unk_102655B0; // weak
_UNKNOWN unk_10265654; // weak
_UNKNOWN unk_102656F8; // weak
_UNKNOWN unk_1026579C; // weak
_UNKNOWN unk_10265840; // weak
_UNKNOWN unk_102658E4; // weak
_UNKNOWN unk_10265988; // weak
_UNKNOWN unk_10265A2C; // weak
_UNKNOWN unk_10265AD0; // weak
_UNKNOWN unk_10265B74; // weak
_UNKNOWN unk_10265C18; // weak
_UNKNOWN unk_10265CBC; // weak
_UNKNOWN unk_10265D60; // weak
_UNKNOWN unk_10265E04; // weak
_UNKNOWN unk_10265EA8; // weak
_UNKNOWN unk_10265F4C; // weak
_UNKNOWN unk_10265FF0; // weak
_UNKNOWN unk_10266094; // weak
_UNKNOWN unk_10266138; // weak
_UNKNOWN unk_102661DC; // weak
_UNKNOWN unk_10266280; // weak
_UNKNOWN unk_10266324; // weak
_UNKNOWN unk_102663C8; // weak
_UNKNOWN unk_1026646C; // weak
_UNKNOWN unk_10266510; // weak
_UNKNOWN unk_102665B4; // weak
_UNKNOWN unk_10266658; // weak
_UNKNOWN unk_102666FC; // weak
_UNKNOWN unk_102667A0; // weak
_UNKNOWN unk_10266844; // weak
_UNKNOWN unk_102668E8; // weak
_UNKNOWN unk_1026698C; // weak
_UNKNOWN unk_10266A30; // weak
_UNKNOWN unk_10266AD4; // weak
_UNKNOWN unk_10266B78; // weak
_UNKNOWN unk_10266C1C; // weak
_UNKNOWN unk_10266CC0; // weak
_UNKNOWN unk_10266D64; // weak
_UNKNOWN unk_10266E08; // weak
_UNKNOWN unk_10266EAC; // weak
_UNKNOWN unk_10266F50; // weak
_UNKNOWN unk_10266FF4; // weak
_UNKNOWN unk_10267098; // weak
_UNKNOWN unk_1026713C; // weak
_UNKNOWN unk_102671E0; // weak
_UNKNOWN unk_10267284; // weak
_UNKNOWN unk_10267328; // weak
_UNKNOWN unk_102673CC; // weak
_UNKNOWN unk_10267470; // weak
_UNKNOWN unk_10267514; // weak
_UNKNOWN unk_102675B8; // weak
_UNKNOWN unk_1026765C; // weak
_UNKNOWN unk_10267700; // weak
_UNKNOWN unk_102677A4; // weak
_UNKNOWN unk_10267848; // weak
_UNKNOWN unk_102678EC; // weak
_UNKNOWN unk_10267990; // weak
_UNKNOWN unk_10267A34; // weak
_UNKNOWN unk_10267AD8; // weak
_UNKNOWN unk_10267B7C; // weak
_UNKNOWN unk_10267C20; // weak
_UNKNOWN unk_10267CC4; // weak
_UNKNOWN unk_10267D68; // weak
_UNKNOWN unk_10267E0C; // weak
_UNKNOWN unk_10267EB0; // weak
_UNKNOWN unk_10267F54; // weak
_UNKNOWN unk_10267FF8; // weak
_UNKNOWN unk_1026809C; // weak
_UNKNOWN unk_10268140; // weak
_UNKNOWN unk_102681E4; // weak
_UNKNOWN unk_10268288; // weak
_UNKNOWN unk_1026832C; // weak
_UNKNOWN unk_102683D0; // weak
_UNKNOWN unk_10268474; // weak
_UNKNOWN unk_10268518; // weak
_UNKNOWN unk_102685BC; // weak
_UNKNOWN unk_10268660; // weak
_UNKNOWN unk_10268704; // weak
_UNKNOWN unk_102687A8; // weak
_UNKNOWN unk_1026884C; // weak
_UNKNOWN unk_102688F0; // weak
_UNKNOWN unk_10268994; // weak
_UNKNOWN unk_10268A38; // weak
_UNKNOWN unk_10268A58; // weak
_UNKNOWN unk_10268A78; // weak
_UNKNOWN unk_10268A98; // weak
_UNKNOWN unk_10268AB8; // weak
_UNKNOWN unk_10268AE0; // weak
_UNKNOWN unk_10268AFC; // weak
_UNKNOWN unk_10268B18; // weak
_UNKNOWN unk_10268B34; // weak
_UNKNOWN unk_10268B50; // weak
_UNKNOWN unk_10268B6C; // weak
_UNKNOWN unk_10268B88; // weak
_UNKNOWN unk_10268BA4; // weak
_UNKNOWN unk_10268BC0; // weak
_UNKNOWN unk_10268BDC; // weak
_UNKNOWN unk_10268BF8; // weak
_UNKNOWN unk_10268C14; // weak
_UNKNOWN unk_10268C30; // weak
_UNKNOWN unk_10268C4C; // weak
_UNKNOWN unk_10268C68; // weak
_UNKNOWN unk_10268C84; // weak
_UNKNOWN unk_10268CA0; // weak
_UNKNOWN unk_10268CBC; // weak
_UNKNOWN unk_10268CD8; // weak
_UNKNOWN unk_10268CF4; // weak
_UNKNOWN unk_10268D10; // weak
_UNKNOWN unk_10268D2C; // weak
_UNKNOWN unk_10268D48; // weak
_UNKNOWN unk_10268D64; // weak
_UNKNOWN unk_10268D80; // weak
_UNKNOWN unk_10268D9C; // weak
_UNKNOWN unk_10268DB8; // weak
_UNKNOWN unk_10268DD4; // weak
_UNKNOWN unk_10268DF0; // weak
_UNKNOWN unk_10268E0C; // weak
_UNKNOWN unk_10268E28; // weak
_UNKNOWN unk_10268E44; // weak
_UNKNOWN unk_10268E60; // weak
_UNKNOWN unk_10268E7C; // weak
_UNKNOWN unk_10268E98; // weak
_UNKNOWN unk_10268EB4; // weak
_UNKNOWN unk_10268ED0; // weak
_UNKNOWN unk_10268EEC; // weak
_UNKNOWN unk_10268F08; // weak
_UNKNOWN unk_10268F24; // weak
_UNKNOWN unk_10268F40; // weak
_UNKNOWN unk_10268F5C; // weak
_UNKNOWN unk_10268F78; // weak
_UNKNOWN unk_10268F94; // weak
_UNKNOWN unk_10268FB0; // weak
_UNKNOWN unk_10268FCC; // weak
_UNKNOWN unk_10268FE8; // weak
_UNKNOWN unk_10269004; // weak
_UNKNOWN unk_10269020; // weak
_UNKNOWN unk_1026903C; // weak
_UNKNOWN unk_10269058; // weak
_UNKNOWN unk_10269074; // weak
_UNKNOWN unk_10269090; // weak
_UNKNOWN unk_102690AC; // weak
_UNKNOWN unk_102690C8; // weak
_UNKNOWN unk_102690E4; // weak
_UNKNOWN unk_10269100; // weak
_UNKNOWN unk_1026911C; // weak
_UNKNOWN unk_10269138; // weak
_UNKNOWN unk_10269154; // weak
_UNKNOWN unk_10269170; // weak
_UNKNOWN unk_1026918C; // weak
_UNKNOWN unk_102691A8; // weak
_UNKNOWN unk_102691C4; // weak
_UNKNOWN unk_102691E0; // weak
_UNKNOWN unk_102691FC; // weak
_UNKNOWN unk_10269218; // weak
_UNKNOWN unk_10269234; // weak
_UNKNOWN unk_10269250; // weak
_UNKNOWN unk_1026926C; // weak
_UNKNOWN unk_10269288; // weak
_UNKNOWN unk_102692A4; // weak
_UNKNOWN unk_102692C0; // weak
_UNKNOWN unk_102692DC; // weak
_UNKNOWN unk_102692F8; // weak
_UNKNOWN unk_10269314; // weak
_UNKNOWN unk_10269330; // weak
_UNKNOWN unk_1026934C; // weak
_UNKNOWN unk_10269368; // weak
_UNKNOWN unk_10269384; // weak
_UNKNOWN unk_102693A0; // weak
_UNKNOWN unk_102693BC; // weak
_UNKNOWN unk_102693D8; // weak
_UNKNOWN unk_102693F4; // weak
_UNKNOWN unk_10269410; // weak
_UNKNOWN unk_1026942C; // weak
_UNKNOWN unk_10269448; // weak
_UNKNOWN unk_10269464; // weak
_UNKNOWN unk_10269480; // weak
_UNKNOWN unk_1026949C; // weak
_UNKNOWN unk_102694B8; // weak
_UNKNOWN unk_102694D4; // weak
_UNKNOWN unk_102694F0; // weak
_UNKNOWN unk_1026950C; // weak
_UNKNOWN unk_10269528; // weak
_UNKNOWN unk_10269544; // weak
_UNKNOWN unk_10269560; // weak
_UNKNOWN unk_1026957C; // weak
_UNKNOWN unk_10269598; // weak
_UNKNOWN unk_102695B4; // weak
_UNKNOWN unk_102695D0; // weak
_UNKNOWN unk_102695D4; // weak
_UNKNOWN unk_102695D8; // weak
_UNKNOWN unk_102695DC; // weak
_UNKNOWN unk_102695E0; // weak
_UNKNOWN unk_102695E4; // weak
_UNKNOWN unk_102695E8; // weak
_UNKNOWN unk_102695EC; // weak
_UNKNOWN unk_102695F0; // weak
_UNKNOWN unk_102695F4; // weak
_UNKNOWN unk_102695F8; // weak
_UNKNOWN unk_102695FC; // weak
_UNKNOWN unk_10269600; // weak
_UNKNOWN unk_10269604; // weak
_UNKNOWN unk_10269608; // weak
_UNKNOWN unk_1026960C; // weak
_UNKNOWN unk_10269610; // weak
_UNKNOWN unk_10269614; // weak
_UNKNOWN unk_10269618; // weak
_UNKNOWN unk_102696FC; // weak
_UNKNOWN unk_1026A8BC; // weak
_UNKNOWN unk_1026A8C0; // weak
_UNKNOWN unk_1026A8E8; // weak
_UNKNOWN unk_1026A910; // weak
_UNKNOWN unk_1026A950; // weak
_UNKNOWN unk_1026A9D0; // weak
_UNKNOWN unk_1026A9D4; // weak
_UNKNOWN unk_1026A9D8; // weak
_UNKNOWN unk_1026A9DA; // weak
_UNKNOWN unk_1026A9DC; // weak
_UNKNOWN unk_1026A9DD; // weak
_UNKNOWN unk_1026A9DE; // weak
_UNKNOWN unk_1026A9E0; // weak
_UNKNOWN unk_1026AA44; // weak
_UNKNOWN unk_1026AA4C; // weak
_UNKNOWN unk_1026AA54; // weak
_UNKNOWN unk_1026AA5C; // weak
_UNKNOWN unk_1026AA64; // weak
_UNKNOWN unk_1026AA6C; // weak
_UNKNOWN unk_1026AA74; // weak
_UNKNOWN unk_1026AA7C; // weak
_UNKNOWN unk_1026AA84; // weak
_UNKNOWN unk_1026AA8C; // weak
_UNKNOWN unk_1026AA94; // weak
_UNKNOWN unk_1026AA9C; // weak
_UNKNOWN unk_1026AAA4; // weak
_UNKNOWN unk_1026AAAC; // weak
_UNKNOWN unk_1026AAB4; // weak
_UNKNOWN unk_1026AABC; // weak
_UNKNOWN unk_1026AAC4; // weak
_UNKNOWN unk_1026AACC; // weak
_UNKNOWN unk_1026AAD4; // weak
_UNKNOWN unk_1026AADC; // weak
_UNKNOWN unk_1026AAE4; // weak
_UNKNOWN unk_1026AAEC; // weak
_UNKNOWN unk_1026AAF4; // weak
_UNKNOWN unk_1026AAFC; // weak
_UNKNOWN unk_1026AB04; // weak
_UNKNOWN unk_1026AB0C; // weak
_UNKNOWN unk_1026AB14; // weak
_UNKNOWN unk_1026AB1C; // weak
_UNKNOWN unk_1026AB24; // weak
_UNKNOWN unk_1026AB2C; // weak
_UNKNOWN unk_1026AB34; // weak
_UNKNOWN unk_1026AB3C; // weak
_UNKNOWN unk_1026AB44; // weak
_UNKNOWN unk_1026AB4C; // weak
_UNKNOWN unk_1026AB54; // weak
_UNKNOWN unk_1026AB5C; // weak
_UNKNOWN unk_1026AB64; // weak
_UNKNOWN unk_1026AB6C; // weak
_UNKNOWN unk_1026AB74; // weak
_UNKNOWN unk_1026AB7C; // weak
_UNKNOWN unk_1026AD64; // weak
_UNKNOWN unk_1026AD74; // weak
_UNKNOWN unk_1026AD84; // weak
_UNKNOWN unk_1026AD94; // weak
_UNKNOWN unk_1026AD95; // weak
_UNKNOWN unk_1026AD96; // weak
_UNKNOWN unk_1026AD98; // weak
_UNKNOWN unk_1026AD9C; // weak
_UNKNOWN unk_1026AE44; // weak
_UNKNOWN unk_1026AE48; // weak
_UNKNOWN unk_1026AE4C; // weak
_UNKNOWN unk_1026AE9C; // weak
_UNKNOWN unk_1026AEA0; // weak
_UNKNOWN unk_1026AEA4; // weak
_UNKNOWN unk_1026AF94; // weak
_UNKNOWN unk_1026B084; // weak
_UNKNOWN unk_1026B088; // weak
_UNKNOWN unk_1026B090; // weak
_UNKNOWN unk_1026B098; // weak
_UNKNOWN unk_1026B0A0; // weak
_UNKNOWN unk_1026B0A8; // weak
_UNKNOWN unk_1026B0B0; // weak
_UNKNOWN unk_1026B0B8; // weak
_UNKNOWN unk_1026B0C0; // weak
_UNKNOWN unk_1026B0C8; // weak
_UNKNOWN unk_1026B0D0; // weak
_UNKNOWN unk_1026B0D8; // weak
_UNKNOWN unk_1026B0E0; // weak
_UNKNOWN unk_1026B0E4; // weak
_UNKNOWN unk_1026B0E8; // weak
_UNKNOWN unk_1026B0EC; // weak
_UNKNOWN unk_1026B140; // weak
_UNKNOWN unk_1026B194; // weak
_UNKNOWN unk_1026B19C; // weak
_UNKNOWN unk_1026B1A0; // weak
_UNKNOWN unk_1026B1A4; // weak
_UNKNOWN unk_1026B1A8; // weak
_UNKNOWN unk_1026B1AC; // weak
_UNKNOWN unk_1026B3B4; // weak
_UNKNOWN unk_1026B514; // weak
_UNKNOWN unk_1026B52C; // weak
_UNKNOWN unk_1026B544; // weak
_UNKNOWN unk_1026B54E; // weak
_UNKNOWN unk_1026B550; // weak
_UNKNOWN unk_1026B560; // weak
_UNKNOWN unk_1026B564; // weak
_UNKNOWN unk_1026B568; // weak
_UNKNOWN unk_1026B56C; // weak
_UNKNOWN unk_1026B56D; // weak
_UNKNOWN unk_1026B570; // weak
_UNKNOWN unk_1026B5C0; // weak
_UNKNOWN unk_1026B5C4; // weak
_UNKNOWN unk_1026B5C5; // weak
_UNKNOWN unk_1026B5C6; // weak
_UNKNOWN unk_1026B5C7; // weak
_UNKNOWN unk_1026B5DB; // weak
_UNKNOWN unk_1026B5DC; // weak
_UNKNOWN unk_1026B5DD; // weak
_UNKNOWN unk_1026B5DE; // weak
_UNKNOWN unk_1026B5E0; // weak
_UNKNOWN unk_1026B680; // weak
_UNKNOWN unk_1026B6D0; // weak
_UNKNOWN unk_1026B6D4; // weak
_UNKNOWN unk_1026B6D8; // weak
_UNKNOWN unk_1026B6DC; // weak
_UNKNOWN unk_1026B6E0; // weak
_UNKNOWN unk_1026B6E4; // weak
_UNKNOWN unk_1026B6E8; // weak
_UNKNOWN unk_1026B6EC; // weak
_UNKNOWN unk_1026B6F0; // weak
_UNKNOWN unk_1026B6F4; // weak
_UNKNOWN unk_1026B6F8; // weak
_UNKNOWN unk_1026B6FC; // weak
_UNKNOWN unk_1026B700; // weak
_UNKNOWN unk_1026B840; // weak
_UNKNOWN unk_1026B84C; // weak
_UNKNOWN unk_1026B894; // weak
_UNKNOWN unk_1026B895; // weak
_UNKNOWN unk_1026B8C0; // weak
_UNKNOWN unk_1026B8F0; // weak
_UNKNOWN unk_1026B918; // weak
_UNKNOWN unk_1026B91C; // weak
_UNKNOWN unk_1026B920; // weak
_UNKNOWN unk_1026B924; // weak
_UNKNOWN unk_1026B954; // weak
_UNKNOWN unk_1026B955; // weak
_UNKNOWN unk_1026B956; // weak
_UNKNOWN unk_1026B958; // weak
_UNKNOWN unk_1026B95C; // weak
_UNKNOWN unk_1026B960; // weak
_UNKNOWN unk_1026B964; // weak
_UNKNOWN unk_1026B968; // weak
_UNKNOWN unk_1026B96C; // weak
_UNKNOWN unk_1026B970; // weak
_UNKNOWN unk_1026B974; // weak
_UNKNOWN unk_1026B978; // weak
_UNKNOWN unk_1026B97C; // weak
_UNKNOWN unk_1026BCDC; // weak
_UNKNOWN unk_1026BCE0; // weak
_UNKNOWN unk_1026BCEA; // weak
_UNKNOWN unk_1026BCF4; // weak
int dword_1026D4B0; // weak
_UNKNOWN unk_1027AC00; // weak
char byte_1027B198; // weak
char byte_1027B199; // weak
_UNKNOWN unk_1027B19A; // weak
char byte_1027B29A; // weak
char byte_1027B29B; // weak
char byte_1027B2A0[104]; // idb
_UNKNOWN unk_1027B308; // weak
_UNKNOWN unk_1027B5D1; // weak
_UNKNOWN unk_1027B85C; // weak
_UNKNOWN unk_1027B8B9; // weak
_UNKNOWN unk_1027B916; // weak
int dword_1027BA4C[]; // weak
__int16 word_1027BA50[]; // weak
int dword_1027BA54; // weak
__int16 word_1027BA58; // weak
int dword_1027BA5C; // weak
__int16 word_1027BA60; // weak
int dword_1027BA64; // weak
__int16 word_1027BA68; // weak
int dword_1027BA6C; // weak
__int16 word_1027BA70; // weak
_UNKNOWN unk_1027BA78; // weak
_UNKNOWN unk_1027BAA6; // weak
_UNKNOWN unk_1027BAD0; // weak
_UNKNOWN unk_1027BAD6; // weak
_UNKNOWN unk_1027BADC; // weak
int dword_1027BAF0[]; // weak
__int16 word_1027BAF4[]; // weak
int dword_1027BAF8; // weak
__int16 word_1027BAFC; // weak
int dword_1027BB00; // weak
__int16 word_1027BB04; // weak
int dword_1027BB08; // weak
__int16 word_1027BB0C; // weak
int dword_1027BB10; // weak
__int16 word_1027BB14; // weak
float flt_1027BB18; // weak
float flt_1027BB1C; // weak
int dword_1027BB20; // weak
char byte_1027BB28; // weak
char byte_1027BB29; // weak
char byte_1027BB2A; // weak
char byte_1027BB2B; // weak
_UNKNOWN unk_1027BB30; // weak
_UNKNOWN unk_1027BB50; // weak
int dword_1027BB70; // weak
_UNKNOWN unk_1027BB78; // weak
char byte_1027BB91[]; // weak
char byte_1027BE50[]; // weak
char byte_1027BE51[]; // weak
char byte_1027BE70[]; // weak
char byte_1027BE71[]; // weak
_UNKNOWN unk_1027D0B8; // weak
_UNKNOWN unk_1027D0B9; // weak
int dword_1027EA68; // weak
char byte_1027EA9C; // weak
int dword_1027EAA0; // weak
__int16 word_1027EAA4; // weak
int dword_1027EAA8; // weak
int dword_1027EAAC; // weak
int dword_1027EAB0; // weak
int dword_1027EAB4; // weak
char byte_1027EAB8; // weak
int dword_1027EABC[]; // weak
int dword_1027EAD8; // weak
_UNKNOWN unk_1027EAE0; // weak
_UNKNOWN unk_10280020; // weak
char byte_102828B0[]; // weak
char byte_102828BA[]; // weak
_UNKNOWN unk_102828C9; // weak
_UNKNOWN unk_102828F1; // weak
_UNKNOWN unk_102828F6; // weak
_UNKNOWN unk_10282AE2; // weak
_UNKNOWN unk_10282B89; // weak
_UNKNOWN unk_10282B8A; // weak
_UNKNOWN unk_10282BA9; // weak
_UNKNOWN unk_10282BD0; // weak
_UNKNOWN unk_10282BD1; // weak
_UNKNOWN unk_10282BF0; // weak
char byte_10282D7C; // weak
__int16 word_10283350[]; // weak
__int16 word_10283352[]; // weak
__int16 word_10283354[]; // weak
__int16 word_10283356[]; // weak
__int16 word_10283358[]; // weak
__int16 word_10283B20[]; // weak
__int16 word_10283B22[]; // weak
__int16 word_10283B24[]; // weak
__int16 word_10283B26[]; // weak
__int16 word_10283B28[]; // weak
_UNKNOWN unk_102842F0; // weak
_UNKNOWN unk_1028437A; // weak
_UNKNOWN unk_10288178; // weak
_UNKNOWN unk_10288179; // weak
_UNKNOWN unk_102881FA; // weak
_UNKNOWN unk_10288215; // weak
_UNKNOWN unk_1028821A; // weak
_UNKNOWN unk_102884E9; // weak
_UNKNOWN unk_102884EA; // weak
_UNKNOWN unk_10288569; // weak
char byte_10288A10[254]; // idb
char byte_10288B0E[]; // weak
char byte_10288B0F[]; // weak
char byte_10288F10[2800]; // idb
char byte_10289A00[1022]; // idb
char byte_10289DFE[]; // weak
char byte_10289DFF[]; // weak
char byte_10289E00[1022]; // idb
char byte_1028A1FE[]; // weak
char byte_1028A1FF[]; // weak
char byte_1028A200[1022]; // idb
char byte_1028A5FE[]; // weak
char byte_1028A5FF[]; // weak
int dword_1028D600[]; // weak
int dword_1028D614[]; // weak
char byte_1028D628[2800]; // idb
char byte_1028E118[2800]; // idb
char byte_1028EC08[2800]; // idb
int dword_1028F6F8[]; // weak
int dword_1028F70C[]; // weak
char byte_1028F720[2796]; // idb
char byte_1029020C[]; // weak
char byte_10290210[559]; // idb
char byte_1029043F[]; // weak
int dword_10290D00[]; // weak
int dword_10290D14[]; // weak
char byte_10290D28[2800]; // idb
char byte_10291818; // idb
char byte_10291918; // weak
char byte_10291919; // weak
char byte_10291C70[]; // weak
char byte_10291C71[]; // weak
_UNKNOWN unk_10291D10; // weak
int dword_10291FE0[]; // weak
int dword_10291FE4[]; // weak
_UNKNOWN unk_10292500; // weak
_UNKNOWN unk_10295408; // weak
_UNKNOWN unk_10295908; // weak
_UNKNOWN unk_102959B0; // weak
int dword_102959D0; // weak
char byte_102959D8[]; // weak
char byte_102959DC[]; // weak
char byte_102959DD[]; // weak
int dword_102959E4[]; // weak
int dword_102959EC[]; // weak
int dword_10295A20; // weak
int dword_10295A24; // weak
int dword_10295A28; // weak
int dword_10295A2C; // weak
int dword_102F5778[]; // weak
int dword_102F577C; // weak
int dword_102F5780; // weak
int dword_102F5784; // weak
int dword_102F5788; // weak
int dword_102F578C[]; // weak
int dword_102F5790; // weak
int dword_102F5794; // weak
int dword_102F5798; // weak
int dword_102F579C; // weak
_UNKNOWN unk_102F57A0; // weak
int dword_102F58B8; // weak
_UNKNOWN unk_102F58C0; // weak
_UNKNOWN unk_102F6418; // weak
__int16 word_102F8780[]; // weak
char byte_102F8782[]; // weak
__int16 word_102F8784; // weak
char byte_102F8786; // weak
int dword_102F8AB0[]; // weak
int dword_102F8AB4[]; // weak
int dword_102F8AB8[]; // weak
int dword_102F8ABC[]; // weak
int dword_102F8AC0[]; // weak
int dword_102F8AC4[]; // weak
int dword_102F8AC8[]; // weak
int dword_102F8ACC[]; // weak
int dword_102F8AD0[]; // weak
int dword_102F8AD4[]; // weak
int dword_102F8AD8[]; // weak
int dword_102F8ADC[]; // weak
int dword_102F8AE0[]; // weak
int dword_102F8B0C; // weak
int dword_102F8B10; // weak
int dword_102F8B14; // weak
int dword_102F8B18; // weak
int dword_102F8B1C; // weak
int dword_102F8B20; // weak
int dword_102F8B24; // weak
int dword_102F8B28; // weak
int dword_102F8B2C; // weak
int dword_102F8B30; // weak
int dword_102F8BB0; // weak
char byte_102F8BB8[]; // weak
char byte_102F8C08[]; // weak
_UNKNOWN unk_10300FE0; // weak
int dword_10300FE8; // weak
int dword_10300FEC; // weak
int dword_10300FF0; // weak
int dword_10300FF4; // weak
int dword_10301000; // weak
_UNKNOWN unk_10301010; // weak
char byte_10304210; // weak
_UNKNOWN unk_10304220; // weak
_UNKNOWN unk_1030424C; // weak
_UNKNOWN unk_1030B2CC; // weak
int dword_1030B31C; // weak
_UNKNOWN unk_1030B320; // weak
int dword_1030B330; // weak
int dword_1030B334; // weak
int dword_1030B338; // weak
int dword_1030B33C; // weak
__int16 word_1030B34C[]; // weak
int dword_1030CF6C; // weak
int dword_1030CF70; // weak
int dword_1030CF74; // weak
int dword_1030CF78; // weak
int dword_1030CF7C; // weak
int dword_1030CF80; // weak
int dword_1030CF84; // weak
int dword_1030CF88; // weak
int dword_1030CF8C; // weak
int dword_1030CF90; // weak
int dword_1030CF94; // weak
int dword_1030CF98; // weak
int dword_1030CF9C; // weak
int dword_1030CFA0; // weak
int dword_1030CFA4; // weak
int dword_1030CFA8; // weak
int dword_1030CFAC; // weak
int dword_1030CFB0; // weak
int dword_1030CFB4; // weak
int dword_1030CFB8; // weak
char byte_1030CFD8; // weak
_DWORD dword_1031F7C8[16]; // idb
int dword_1031F808[]; // weak
int dword_1031F848; // weak
int dword_1031F850[]; // weak
int dword_1031F8C0; // weak
int dword_1031FBEC; // weak
int dword_1031FBF4; // weak
int dword_1031FC00; // weak
int dword_10320228; // weak
int dword_10320234; // weak
int dword_10320240; // weak
int dword_10320244; // weak
int dword_10320248; // weak
int dword_10320264; // weak
int dword_10320268; // weak
int dword_1032026C; // weak
int dword_10320270; // weak
int dword_10320274; // weak
_UNKNOWN unk_10320340; // weak
_UNKNOWN unk_10320420; // weak
_UNKNOWN unk_10325476; // weak
_UNKNOWN unk_10325C60; // weak
_UNKNOWN unk_103319E0; // weak
int dword_10332CD4; // weak
void *dword_10332CD8; // idb
_UNKNOWN unk_10332CE0; // weak
__int16 word_10332EE0; // weak
char byte_10332F00; // weak
char byte_10332F01; // weak
char byte_10332F02; // weak
char byte_10332F03; // weak
int dword_10332F04; // weak
int dword_10332F0C; // weak
int dword_10332F10; // weak
int dword_10332F14; // weak
int dword_10332F18; // weak
int dword_10332F1C; // weak
int dword_10332F20; // weak
int dword_10332F24; // weak
int dword_10332F28; // weak
int dword_10332F2C; // weak
int dword_10332F30; // weak
int dword_10332F34; // weak
int dword_10332F38; // weak
int dword_10332F3C; // weak
int dword_10332F40; // weak
int dword_10332F44; // weak
int dword_10332F48; // weak
int dword_10332F4C; // weak
int dword_10332F50; // weak
int dword_10332F54; // weak
int dword_10332F58; // weak
int dword_10332F5C; // weak
_UNKNOWN unk_10332F60; // weak
_UNKNOWN unk_10333160; // weak
char byte_10333170; // weak
int dword_10333180; // weak
int dword_10333184; // weak
int dword_10333188; // weak
int dword_1033318C; // weak
int dword_10333190; // weak
int dword_10333194; // weak
_UNKNOWN unk_103331A0; // weak
int dword_103331AC; // weak
int dword_103331C0; // weak
int dword_103331C4; // weak
int dword_103331C8; // weak
char byte_103331CC; // weak
char byte_103331D4; // weak
int dword_103331D8; // weak
int dword_103331DC; // weak
int dword_103331E0; // weak
int dword_103331E4; // weak
int dword_103331E8; // weak
_UNKNOWN unk_10333208; // weak
char byte_10333214; // weak
int dword_10333218; // weak
char byte_1033321C; // weak
char byte_1033326C; // weak
int dword_10333270; // weak
int dword_10333274; // weak
int dword_10333278; // weak
char byte_1033327C; // weak
char byte_10333288; // weak
int dword_1033328C; // weak
int dword_10333290; // weak
int dword_10333294; // weak
char byte_10333298; // weak
_UNKNOWN unk_103332A0; // weak
_UNKNOWN unk_103332C0; // weak
int dword_103334C8; // weak
char byte_103334CC; // weak
int dword_103334D0; // weak
char byte_103334D4; // weak
int dword_103334D8; // weak
char byte_103334DC; // weak
int dword_103334E0; // weak
int dword_103334E4; // weak
int dword_103334E8; // weak
char byte_103334EC; // weak
int dword_103334F4; // weak
char byte_103334F8; // weak
int dword_10333500[]; // weak
__int16 word_10333504[]; // weak
int dword_10333508[]; // weak
int dword_1033350C; // weak
int dword_10333510; // weak
int dword_10333514; // weak
int dword_10333518; // weak
__int16 word_1033351C; // weak
int dword_10333520; // weak
int dword_10333568; // weak
int dword_10333584; // weak
__int16 word_10333588; // weak
int dword_10333590; // weak
__int16 word_10333594; // weak
int dword_103335C8; // weak
__int16 word_103335F4; // weak
int dword_103335F8; // weak
__int16 word_1033363C; // weak
int dword_10333640; // weak
int dword_103336E8; // weak
int dword_103336F4; // weak
int dword_10333704; // weak
__int16 word_10333708; // weak
int dword_10333710; // weak
__int16 word_10333714; // weak
int dword_1033371C; // weak
__int16 word_10333720; // weak
int dword_10333824; // weak
int dword_1033389C; // weak
__int16 word_103338A0; // weak
int dword_10333944; // weak
__int16 word_10333948; // weak
_UNKNOWN unk_10333C08; // weak
_UNKNOWN unk_10333C09; // weak
_UNKNOWN unk_10333C0A; // weak
__int16 word_10333C20[]; // weak
__int16 word_10333C22; // weak
__int16 word_10333C24; // weak
__int16 word_10333C26; // weak
__int16 word_10333C28; // weak
__int16 word_10333C2A; // weak
__int16 word_10333C2C; // weak
__int16 word_10333C2E; // weak
__int16 word_10333C44; // weak
__int16 word_10333C46; // weak
__int16 word_10333C48; // weak
__int16 word_10333C4A; // weak
__int16 word_10333C4C; // weak
__int16 word_10333C4E; // weak
__int16 word_10333C52; // weak
__int16 word_10333C54; // weak
__int16 word_10333C56; // weak
__int16 word_10333C58; // weak
__int16 word_10333C5A; // weak
__int16 word_10333C5C; // weak
__int16 word_10333C5E; // weak
__int16 word_10333C60; // weak
__int16 word_10333C62; // weak
__int16 word_10333C64; // weak
__int16 word_10333C66; // weak
__int16 word_10333C68; // weak
__int16 word_10333C6A; // weak
__int16 word_10333C6C; // weak
__int16 word_10333C6E; // weak
__int16 word_10333C70; // weak
__int16 word_10333C72; // weak
__int16 word_10333C74; // weak
__int16 word_10333C76; // weak
__int16 word_10333C78; // weak
__int16 word_10333C7A; // weak
__int16 word_10333C7C; // weak
__int16 word_10333C7E; // weak
__int16 word_10333C80; // weak
__int16 word_10333C82; // weak
__int16 word_10333C84; // weak
__int16 word_10333C86; // weak
__int16 word_10333C88; // weak
__int16 word_10333C8A; // weak
__int16 word_10333C8C; // weak
__int16 word_10333CB0; // weak
char byte_10333D4C; // weak
char byte_10333D4D; // weak
int dword_10333D50; // weak
char byte_10333D54; // weak
int dword_10333D58; // weak
int dword_10333D5C; // weak
int dword_10333D60; // weak
int dword_10333D68; // weak
int dword_10333D6C; // weak
char byte_10333D80; // weak
char byte_10333D82; // weak
char byte_10333D83; // weak
char byte_10333D84; // weak
char byte_10333D85; // weak
char byte_10333DAC; // weak
_UNKNOWN unk_10333E68; // weak
_UNKNOWN unk_10333E9C; // weak
_UNKNOWN unk_10335A08; // weak
_UNKNOWN unk_10335A1C; // weak
char byte_10335A8C; // weak
char byte_10335AF0; // weak
float flt_10335AF4; // weak
int dword_10337070; // weak
int dword_10337074; // weak
void *dword_10337078; // idb
int dword_1033707C; // weak
int dword_10337080; // weak
int dword_10337084; // weak
int dword_10337088; // weak
char byte_1033708C; // weak
__int16 word_1033708E; // weak
__int16 word_10337090; // weak
char byte_10337092; // weak
__int16 word_10337094; // weak
char byte_10337096; // weak
void *dword_103370B0; // idb
int dword_103380C0; // weak
int dword_103380C4; // weak
UINT uNumber; // idb
int dword_103380E0[]; // weak
int dword_103381E0; // weak
int dword_103381F8; // weak


//----- (10001000) --------------------------------------------------------
#error "10001014: call analysis failed (funcsize=141)"

//----- (10001080) --------------------------------------------------------
int __usercall sub_10001080@<eax>(int result@<eax>, int a2@<ecx>)
{
  if ( *(_WORD *)(a2 + 2) < 0x7C6u )
  {
    *(_BYTE *)(result + 1) = 1;
    *(_BYTE *)result = 1;
    *(_WORD *)(result + 2) = 1990;
  }
  else
  {
    *(_BYTE *)(result + 1) = *(_BYTE *)(a2 + 1);
    *(_BYTE *)result = *(_BYTE *)a2;
    *(_WORD *)(result + 2) = *(_WORD *)(a2 + 2);
  }
  return result;
}

//----- (100010B0) --------------------------------------------------------
bool __cdecl sub_100010B0(void *a1)
{
  char v1; // cl@4
  char v2; // al@4
  __int16 v3; // dx@4
  int v4; // ecx@4
  int v5; // edx@4
  bool result; // al@6
  int v7; // [sp+4h] [bp-10Ch]@1
  int v8; // [sp+8h] [bp-108h]@1
  char v9; // [sp+Ch] [bp-104h]@4
  char v10; // [sp+10h] [bp-100h]@4
  char v11; // [sp+14h] [bp-FCh]@4
  char v12; // [sp+18h] [bp-F8h]@4
  char v13; // [sp+1Ch] [bp-F4h]@4
  unsigned __int8 v14; // [sp+20h] [bp-F0h]@4
  char v15; // [sp+21h] [bp-EFh]@4
  char v16; // [sp+22h] [bp-EEh]@4
  __int16 v17; // [sp+23h] [bp-EDh]@4
  __int16 v18; // [sp+25h] [bp-EBh]@4
  char v19; // [sp+27h] [bp-E9h]@4
  char v20; // [sp+33h] [bp-DDh]@4
  char v21; // [sp+51h] [bp-BFh]@4
  char v22; // [sp+6Ah] [bp-A6h]@4
  int v23; // [sp+9Ch] [bp-74h]@4
  char v24; // [sp+A0h] [bp-70h]@4
  int v25; // [sp+FEh] [bp-12h]@4
  int v26; // [sp+102h] [bp-Eh]@4
  int v27; // [sp+106h] [bp-Ah]@4

  memset(a1, 0, 0xD8u);
  memset(&v8, 0, 0x102u);
  result = 0;
  if ( !sub_1007C7C0(48, &v7) && v7 - 258 > 0 && !sub_1007C6B0(48, v7 - 258, 258, (int)&v8) )
  {
    *(_DWORD *)a1 = v8;
    strncpy((char *)a1 + 4, &v9, 4u);
    sub_10001080((int)a1 + 10, (int)&v10);
    sub_10001080((int)a1 + 14, (int)&v11);
    sub_10001080((int)a1 + 18, (int)&v12);
    sub_10001080((int)a1 + 22, (int)&v13);
    v1 = v16;
    v2 = v15;
    *((_WORD *)a1 + 13) = v14;
    v3 = v17;
    *((_BYTE *)a1 + 29) = v1;
    *((_WORD *)a1 + 15) = v3;
    *((_BYTE *)a1 + 28) = v2;
    *((_WORD *)a1 + 16) = v18;
    strncpy((char *)a1 + 34, &v19, 0xCu);
    strncpy((char *)a1 + 47, &v20, 0x1Eu);
    strncpy((char *)a1 + 78, &v21, 0x19u);
    strncpy((char *)a1 + 104, &v22, 0x32u);
    *((_DWORD *)a1 + 39) = v23;
    strncpy((char *)a1 + 160, &v24, 0x28u);
    v4 = v26;
    v5 = v27;
    *((_DWORD *)a1 + 51) = v25;
    *((_DWORD *)a1 + 52) = v4;
    *((_DWORD *)a1 + 53) = v5;
    if ( strncmp(&v19, "006-D1430", 9u) <= 0 && v23 == v7 - v25 - 8 )
      result = 1;
  }
  return result;
}

//----- (100012A0) --------------------------------------------------------
int __cdecl sub_100012A0(int a1, int a2)
{
  int result; // eax@1

  result = a2;
  *(_BYTE *)a2 = 0;
  *(_BYTE *)(a2 + 1) = 0;
  *(_BYTE *)(a2 + 2) = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_BYTE *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a1 + 12) = a2;
  return result;
}

//----- (100012D0) --------------------------------------------------------
int __cdecl sub_100012D0(int a1, char a2)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)a1 = 43;
  *(_BYTE *)(a1 + 1) = 27;
  *(_BYTE *)(a1 + 2) = 3;
  *(_BYTE *)(a1 + 3) = a2;
  return result;
}

//----- (100012F0) --------------------------------------------------------
bool __cdecl sub_100012F0(int a1, int a2, _DWORD *a3)
{
  int v3; // eax@1

  v3 = sub_10011950((int)&off_100939E8, a1, a2, &unk_103332A0, 0x10u);
  *a3 = &unk_103332A0;
  return v3 == 0;
}
// 100939E8: using guessed type char *off_100939E8;

//----- (10001330) --------------------------------------------------------
bool __cdecl sub_10001330(int a1, _DWORD *a2)
{
  int v2; // eax@1

  v2 = sub_10010A40((int)&off_10093E6C, a1, &dword_103331C0, 0xDCu);
  *a2 = &dword_103331C0;
  return v2 == 0;
}
// 10093E6C: using guessed type char *off_10093E6C;
// 103331C0: using guessed type int dword_103331C0;

//----- (10001360) --------------------------------------------------------
unsigned int __cdecl sub_10001360(int a1, int a2)
{
  unsigned __int16 v2; // bx@1
  unsigned int result; // eax@1

  LOBYTE(v2) = 0;
  HIBYTE(v2) = (a2 & 0xFFFFFFu) >> 21;
  result = a2 & 0x7F | ((((v2 | ((a2 & 0xFFFFFFu) >> 14) & 0x7F | 0x8080) << 8) | (unsigned __int8)((a2 & 0xFFFFFFu) >> 7) | 0x80) << 8);
  *(_BYTE *)(a1 + 3) = BYTE3(result);
  *(_BYTE *)(a1 + 4) = result >> 16;
  *(_BYTE *)a1 = 43;
  *(_BYTE *)(a1 + 1) = 27;
  *(_BYTE *)(a1 + 2) = 1;
  *(_BYTE *)(a1 + 5) = BYTE1(result);
  *(_BYTE *)(a1 + 6) = a2 & 0x7F;
  *(_BYTE *)(a1 + 7) = 0;
  return result;
}

//----- (100013D0) --------------------------------------------------------
char __cdecl sub_100013D0(int a1, int a2)
{
  unsigned __int8 v2; // bl@1
  unsigned int v3; // eax@1
  char v4; // al@5
  char v6; // [sp+Fh] [bp-1h]@4

  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_BYTE *)(a2 + 8) = 0;
  v2 = 0;
  v3 = sub_100107F0(a1, 8u);
  if ( v3 == 43 )
  {
    v3 = sub_100107F0(a1, 8u);
    if ( v3 == 27 )
    {
      v3 = sub_100107F0(a1, 8u);
      if ( v3 == 2 )
      {
        if ( sub_10010880(a1, &v6, 8u) )
        {
LABEL_8:
          v4 = v6;
        }
        else
        {
          while ( 1 )
          {
            v4 = v6;
            if ( v6 >= 0 || v2 >= 9u )
              break;
            *(_BYTE *)(v2++ + a2) = (v6 & 0x3F) + 64;
            if ( sub_10010880(a1, &v6, 8u) )
              goto LABEL_8;
          }
        }
        LOBYTE(v3) = (v3 & 0x3F) + 64;
        *(_BYTE *)(v2 + a2) = v3;
      }
    }
  }
  return v3;
}

//----- (10001480) --------------------------------------------------------
void __cdecl sub_10001480(int a1, int a2, unsigned __int8 a3, _BYTE *a4, int a5)
{
  int v5; // eax@2
  int v6; // edi@4
  int v7; // eax@4
  int v8; // eax@6
  bool v9; // zf@21
  int v10; // ST2C_4@50
  _DWORD *v11; // ST28_4@50
  int v12; // ST2C_4@51
  _DWORD *v13; // ST28_4@51
  _DWORD *v14; // eax@52
  signed int v15; // eax@54
  int v16; // [sp+10h] [bp-14h]@3
  int v17; // [sp+14h] [bp-10h]@12
  char v18; // [sp+18h] [bp-Ch]@12

  if ( a2 )
  {
    v5 = 8 * a3;
    *(_BYTE *)(*(_DWORD *)(a2 + 12) + 1) = byte_10093E88[2 * (v5 + **(_BYTE **)(a2 + 12))];
    **(_BYTE **)(a2 + 12) = byte_10093E89[2 * (v5 + **(_BYTE **)(a2 + 12))];
    switch ( *(_BYTE *)(*(_DWORD *)(a2 + 12) + 1) )
    {
      case 1:
        v16 = 0;
        if ( sub_10001330(a5, &v16) == 1 )
        {
          v6 = v16;
          v7 = *(_DWORD *)(a2 + 12);
          if ( *(_BYTE *)(v16 + 84) )
          {
            sub_100013D0(v16 + 72, v7 + 8);
          }
          else
          {
            v8 = v7 + 8;
            *(_DWORD *)v8 = 0;
            *(_DWORD *)(v8 + 4) = 0;
            *(_BYTE *)(v8 + 8) = 0;
          }
          if ( *(_BYTE *)(v6 + 216) )
            sub_1000FF30(a1, a2, (int)a4, v6 + 204);
          else
            sub_1000FF30(a1, a2, (int)a4, 0);
        }
        break;
      case 2:
        sub_1000FEC0(a1, a2, 0, (int)a4, a5);
        break;
      case 3:
        sub_1000FEC0(a1, a2, 2, (int)a4, a5);
        break;
      case 4:
        memset(&dword_103331C0, 0, 0xDCu);
        dword_103331C0 = 1;
        sub_10001F70((int)&byte_103331D4, a2 + 76, 4);
        byte_10333214 = 1;
        sub_10042650(&v17);
        sub_10001360((int)&v18, v17);
        sub_10001F70((int)&unk_10333208, (int)&v18, 8);
        byte_1033321C = 1;
        dword_10333218 = *(_DWORD *)(a2 + 72);
        if ( a5 )
        {
          byte_10333298 = 1;
          dword_1033328C = *(_DWORD *)a5;
          dword_10333290 = *(_DWORD *)(a5 + 4);
          dword_10333294 = *(_DWORD *)(a5 + 8);
          byte_10333288 = 3;
        }
        if ( sub_10010740((int)&off_10093E6C, (int)&dword_103331C0, 220, (int)&unk_103332C0, 512, (int)&unk_103331A0) < 0 )
          goto LABEL_60;
        sub_1000FD90(a1, a2, (int)a4, (int)&unk_103331A0);
        break;
      case 5:
        memset(&dword_103331C0, 0, 0xDCu);
        dword_103331C0 = 2;
        sub_10001F70((int)&byte_103331D4, a2 + 76, 4);
        dword_103331E0 = 0;
        dword_103331E4 = 1;
        dword_103331E8 = 0;
        if ( a5 )
        {
          byte_1033327C = 1;
          dword_10333270 = *(_DWORD *)a5;
          dword_10333274 = *(_DWORD *)(a5 + 4);
          dword_10333278 = *(_DWORD *)(a5 + 8);
          byte_1033326C = 3;
        }
        if ( sub_10010740((int)&off_10093E6C, (int)&dword_103331C0, 220, (int)&unk_103332C0, 512, (int)&unk_103331A0) < 0 )
          goto LABEL_19;
        sub_1000FDD0(a1, a2, (int)a4, (int)&unk_103331A0);
        break;
      case 6:
        memset(&dword_103331C0, 0, 0xDCu);
        dword_103331C0 = 2;
        sub_10001F70((int)&byte_103331D4, a2 + 76, 4);
        v9 = *a4 == 2;
        dword_103331E4 = 1;
        dword_103331E8 = 0;
        dword_103331E0 = !v9 + 1;
        if ( a5 )
        {
          byte_1033327C = 1;
          dword_10333270 = *(_DWORD *)a5;
          dword_10333274 = *(_DWORD *)(a5 + 4);
          dword_10333278 = *(_DWORD *)(a5 + 8);
          byte_1033326C = 3;
        }
        if ( sub_10010740((int)&off_10093E6C, (int)&dword_103331C0, 220, (int)&unk_103332C0, 512, (int)&unk_103331A0) < 0 )
          goto LABEL_24;
        sub_1000FDB0(a1, a2, (int)a4, (int)&unk_103331A0);
        break;
      case 7:
        sub_100103A0(a1, a2, a5);
        break;
      case 8:
        sub_10010360(a1, a2, (int)a4, a5);
        break;
      case 9:
        sub_10010340(a1, a2, (int)a4, a5);
        break;
      case 0xA:
        memset(&dword_103331C0, 0, 0xDCu);
        dword_103331C0 = 3;
        if ( a4 )
        {
          LOBYTE(dword_103331C8) = 1;
          dword_103331C4 = *(_DWORD *)a4;
        }
        if ( a5 )
        {
          LOBYTE(dword_103331E4) = 1;
          dword_103331D8 = *(_DWORD *)a5;
          dword_103331DC = *(_DWORD *)(a5 + 4);
          dword_103331E0 = *(_DWORD *)(a5 + 8);
          byte_103331D4 = 3;
        }
        if ( sub_10010740((int)&off_10093E6C, (int)&dword_103331C0, 220, (int)&unk_103332C0, 512, (int)&unk_103331A0) < 0 )
        {
LABEL_19:
          sub_10006290(*(_DWORD *)(*(_DWORD *)(a2 + 12) + 4), 0, 0);
          sub_1000FF70(a1, a2);
        }
        else
        {
          sub_1000FEA0(a1, a2, (int)a4, (int)&unk_103331A0);
        }
        break;
      case 0xB:
        memset(&dword_103331C0, 0, 0xDCu);
        dword_103331AC = 0;
        dword_103331C0 = 4;
        LOBYTE(dword_103331C8) = 1;
        dword_103331C4 = 0;
        if ( a5 )
        {
          LOBYTE(dword_103331E4) = 1;
          dword_103331D8 = *(_DWORD *)a5;
          dword_103331DC = *(_DWORD *)(a5 + 4);
          dword_103331E0 = *(_DWORD *)(a5 + 8);
          byte_103331D4 = 3;
        }
        if ( sub_10010740((int)&off_10093E6C, (int)&dword_103331C0, 220, (int)&unk_103332C0, 512, (int)&unk_103331A0) >= 0 )
        {
          sub_1000FE60(a1, a2, (int)a4, (int)&unk_103331A0);
        }
        else
        {
          sub_10006290(*(_DWORD *)(*(_DWORD *)(a2 + 12) + 4), 0, 0);
          sub_1000FF70(a1, a2);
        }
        break;
      case 0xC:
        memset(&dword_103331C0, 0, 0xDCu);
        dword_103331AC = 1;
        dword_103331C0 = 4;
        LOBYTE(dword_103331C8) = 1;
        dword_103331C4 = 1;
        if ( a5 )
        {
          LOBYTE(dword_103331E4) = 1;
          dword_103331D8 = *(_DWORD *)a5;
          dword_103331DC = *(_DWORD *)(a5 + 4);
          dword_103331E0 = *(_DWORD *)(a5 + 8);
          byte_103331D4 = 3;
        }
        if ( sub_10010740((int)&off_10093E6C, (int)&dword_103331C0, 220, (int)&unk_103332C0, 512, (int)&unk_103331A0) < 0 )
          goto LABEL_24;
        sub_1000FE40(a1, a2, (int)a4, (int)&unk_103331A0);
        break;
      case 0xD:
        if ( a5 )
        {
          if ( sub_10001330(a5, &v16) != 1 || *(_DWORD *)v16 != 5 )
          {
            v14 = (_DWORD *)(v16 + 4);
            *v14 = 1;
            sub_1000FF50(a1, a2, (int)v14, 0);
          }
          else if ( !*(_BYTE *)(v16 + 12) || *(_DWORD *)(v16 + 8) )
          {
            v12 = v16 + 28;
            v13 = (_DWORD *)(v16 + 4);
            *v13 = 1;
            sub_1000FF50(a1, a2, (int)v13, v12);
          }
          else
          {
            v10 = v16 + 28;
            v11 = (_DWORD *)(v16 + 4);
            *v11 = 0;
            sub_1000FF50(a1, a2, (int)v11, v10);
          }
        }
        else
        {
          dword_103331C4 = 0;
          sub_1000FF50(a1, a2, (int)&dword_103331C4, 0);
        }
        break;
      case 0xE:
        memset(&dword_103331C0, 0, 0xDCu);
        dword_103331C0 = 5;
        if ( *a4 )
        {
          v15 = 1;
          byte_103331CC = 1;
        }
        else
        {
          v15 = 0;
          byte_103331CC = 1;
        }
        dword_103331C8 = v15;
        dword_103331C4 = v15;
        if ( a5 )
        {
          LOBYTE(dword_103331E8) = 1;
          LOBYTE(dword_103331D8) = 3;
          dword_103331DC = *(_DWORD *)a5;
          dword_103331E0 = *(_DWORD *)(a5 + 4);
          dword_103331E4 = *(_DWORD *)(a5 + 8);
        }
        if ( sub_10010740((int)&off_10093E6C, (int)&dword_103331C0, 220, (int)&unk_103332C0, 512, (int)&unk_103331A0) < 0 )
        {
LABEL_24:
          sub_10006290(*(_DWORD *)(*(_DWORD *)(a2 + 12) + 4), 0, 0);
          sub_1000FF70(a1, a2);
        }
        else
        {
          sub_1000FD70(a1, a2, (int)a4, (int)&unk_103331A0);
        }
        break;
      case 0xF:
LABEL_60:
        sub_1000FF70(a1, a2);
        break;
      default:
        return;
    }
  }
}
// 10093E6C: using guessed type char *off_10093E6C;
// 103331AC: using guessed type int dword_103331AC;
// 103331C0: using guessed type int dword_103331C0;
// 103331C4: using guessed type int dword_103331C4;
// 103331C8: using guessed type int dword_103331C8;
// 103331CC: using guessed type char byte_103331CC;
// 103331D4: using guessed type char byte_103331D4;
// 103331D8: using guessed type int dword_103331D8;
// 103331DC: using guessed type int dword_103331DC;
// 103331E0: using guessed type int dword_103331E0;
// 103331E4: using guessed type int dword_103331E4;
// 103331E8: using guessed type int dword_103331E8;
// 10333214: using guessed type char byte_10333214;
// 10333218: using guessed type int dword_10333218;
// 1033321C: using guessed type char byte_1033321C;
// 1033326C: using guessed type char byte_1033326C;
// 10333270: using guessed type int dword_10333270;
// 10333274: using guessed type int dword_10333274;
// 10333278: using guessed type int dword_10333278;
// 1033327C: using guessed type char byte_1033327C;
// 10333288: using guessed type char byte_10333288;
// 1033328C: using guessed type int dword_1033328C;
// 10333290: using guessed type int dword_10333290;
// 10333294: using guessed type int dword_10333294;
// 10333298: using guessed type char byte_10333298;

//----- (10001D10) --------------------------------------------------------
void __cdecl sub_10001D10(int a1, int a2, _BYTE *a3, int a4, int a5)
{
  sub_10001480(a1, a2, 5u, a3, a5);
}

//----- (10001D30) --------------------------------------------------------
void __cdecl sub_10001D30(int a1, int a2, _BYTE *a3, int a4)
{
  sub_10001480(a1, a2, 4u, a3, a4);
}

//----- (10001D50) --------------------------------------------------------
void __cdecl sub_10001D50(int a1, int a2, _BYTE *a3, int a4)
{
  sub_10001480(a1, a2, 3u, a3, a4);
}

//----- (10001D70) --------------------------------------------------------
void __cdecl sub_10001D70(int a1, int a2, int a3)
{
  sub_10001480(a1, a2, 0xFu, 0, a3);
}

//----- (10001D90) --------------------------------------------------------
void __cdecl sub_10001D90(int a1, int a2)
{
  sub_10001480(a1, a2, 0x10u, 0, 0);
}

//----- (10001DB0) --------------------------------------------------------
void __cdecl sub_10001DB0(int a1, int a2, _BYTE *a3, int a4)
{
  sub_10001480(a1, a2, 0xDu, a3, a4);
}

//----- (10001DD0) --------------------------------------------------------
void __cdecl sub_10001DD0(int a1, int a2, _BYTE *a3, int a4)
{
  sub_10001480(a1, a2, 0xCu, a3, a4);
}

//----- (10001DF0) --------------------------------------------------------
void __cdecl sub_10001DF0(int a1, int a2, _BYTE *a3, int a4)
{
  if ( *(_BYTE *)(a2 + 97) )
    sub_10001480(a1, a2, 0xAu, a3, a4);
  else
    sub_10001480(a1, a2, 0xBu, a3, a4);
}

//----- (10001E30) --------------------------------------------------------
void __cdecl sub_10001E30(int a1, int a2, _BYTE *a3, int a4)
{
  if ( *a3 )
    sub_10001480(a1, a2, 2u, a3, a4);
  else
    sub_10001480(a1, a2, 1u, 0, a4);
}

//----- (10001E70) --------------------------------------------------------
void __cdecl sub_10001E70(int a1, int a2, _BYTE *a3, int a4)
{
  sub_10001480(a1, a2, 0, a3, a4);
}

//----- (10001E90) --------------------------------------------------------
void __cdecl sub_10001E90(int a1, int a2, _BYTE *a3, int a4)
{
  sub_10001480(a1, a2, 0xEu, a3, a4);
}

//----- (10001EB0) --------------------------------------------------------
void __cdecl sub_10001EB0(int a1, int a2, _BYTE *a3, int a4)
{
  if ( *a3 )
    sub_10001480(a1, a2, 9u, a3, a4);
  else
    sub_10001480(a1, a2, 8u, 0, a4);
}

//----- (10001EF0) --------------------------------------------------------
void __cdecl sub_10001EF0(int a1, int a2, char a3, int a4)
{
  sub_10001480(a1, a2, 7u, &a3, a4);
}

//----- (10001F10) --------------------------------------------------------
unsigned int __cdecl sub_10001F10(_BYTE *a1, unsigned int a2, int a3)
{
  unsigned int v3; // esi@1
  unsigned int result; // eax@2
  int v5; // edx@3
  int v6; // [sp+4h] [bp-Ch]@3
  unsigned int v7; // [sp+8h] [bp-8h]@3
  int v8; // [sp+Ch] [bp-4h]@3

  v3 = (unsigned int)(*(_DWORD *)(a3 + 4) + 7) >> 3;
  if ( v3 <= a2 )
  {
    v5 = *(_DWORD *)(a3 + 8);
    v6 = *(_DWORD *)a3;
    v7 = *(_DWORD *)(a3 + 4);
    v8 = v5;
    sub_10010880((int)&v6, a1, v7);
    result = v3;
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_asn1_utl.c", 98, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10001F70) --------------------------------------------------------
int __cdecl sub_10001F70(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = 8 * a3;
  *(_DWORD *)(a1 + 8) = 0;
  return result;
}

//----- (10001F90) --------------------------------------------------------
int __cdecl sub_10001F90(int a1)
{
  return sub_1007C4E0(6789, a1, 12);
}

//----- (10001FB0) --------------------------------------------------------
char __cdecl sub_10001FB0(int a1)
{
  signed int v1; // ecx@1

  v1 = 255
     * (((signed int)(((unsigned __int64)(2139062143i64 * a1) >> 32) - a1) >> 7)
      + ((unsigned int)(((unsigned __int64)(2139062143i64 * a1) >> 32) - a1) >> 31))
     + a1;
  if ( v1 < 0 )
    LOBYTE(v1) = v1 - 1;
  return v1;
}

//----- (10001FE0) --------------------------------------------------------
char __cdecl sub_10001FE0(int a1, int a2)
{
  int v2; // esi@1
  char result; // al@1

  v2 = a1;
  *(_BYTE *)a2 = sub_10001FB0(-(*(_DWORD *)(a1 + 12) + *(_DWORD *)a1 + *(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 4)));
  *(_BYTE *)(a2 + 1) = sub_10001FB0(*(_DWORD *)(v2 + 4) + 3 * *(_DWORD *)(v2 + 12) + 2 * *(_DWORD *)(v2 + 8));
  *(_BYTE *)(a2 + 2) = sub_10001FB0(-*(_DWORD *)(v2 + 8) - 3 * *(_DWORD *)(v2 + 12));
  result = *(_BYTE *)(a1 + 12);
  *(_BYTE *)(a2 + 3) = result;
  return result;
}

//----- (10002040) --------------------------------------------------------
int *__cdecl sub_10002040(_BYTE *a1, int a2, int *a3, _DWORD *a4)
{
  int v4; // edi@1
  int v5; // ecx@1
  int v6; // edx@1
  _BYTE *v7; // esi@2
  int v8; // eax@3
  int v9; // eax@5
  int *result; // eax@8

  v4 = a2;
  v5 = 0;
  v6 = 0;
  if ( a2 )
  {
    v7 = a1;
    do
    {
      v8 = v5 + *v7;
      --v4;
      if ( v8 >= 255 )
        v8 -= 255;
      v5 = v8;
      v9 = v6 + v8;
      ++v7;
      if ( v9 >= 255 )
        v9 -= 255;
      v6 = v9;
    }
    while ( v4 );
  }
  result = a3;
  *a3 = v5;
  *a4 = v6;
  return result;
}

//----- (10002090) --------------------------------------------------------
int __cdecl sub_10002090(_BYTE *a1, int a2, int a3, int a4)
{
  int v4; // ecx@2
  int v5; // edx@2
  int v6; // esi@2
  int v7; // edi@2
  int v8; // ebp@4
  _BYTE *v9; // ebx@5
  int v10; // eax@6
  int v11; // eax@8
  int v12; // eax@10
  int v13; // eax@12
  int result; // eax@15

  if ( a3 )
  {
    v4 = *(_DWORD *)a3;
    v5 = *(_DWORD *)(a3 + 4);
    v6 = *(_DWORD *)(a3 + 8);
    v7 = *(_DWORD *)(a3 + 12);
  }
  else
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    v7 = 0;
  }
  v8 = a2;
  if ( a2 )
  {
    v9 = a1;
    do
    {
      v10 = v4 + *v9;
      --v8;
      if ( v10 >= 255 )
        v10 -= 255;
      v4 = v10;
      v11 = v5 + v10;
      ++v9;
      if ( v11 >= 255 )
        v11 -= 255;
      v5 = v11;
      v12 = v6 + v11;
      if ( v12 >= 255 )
        v12 -= 255;
      v6 = v12;
      v13 = v7 + v12;
      if ( v13 >= 255 )
        v13 -= 255;
      v7 = v13;
    }
    while ( v8 );
  }
  result = a4;
  *(_DWORD *)(a4 + 12) = v7;
  *(_DWORD *)(a4 + 8) = v6;
  *(_DWORD *)a4 = v4;
  *(_DWORD *)(a4 + 4) = v5;
  return result;
}

//----- (10002130) --------------------------------------------------------
char __cdecl sub_10002130(char a1, int a2)
{
  int v2; // edx@1
  char result; // al@2
  int v4; // eax@3
  int *v5; // ecx@3

  v2 = dword_1017DC40;
  if ( (unsigned int)dword_1017DC40 < 2 )
  {
    *(_DWORD *)a2 = dword_1017DC44;
    *(_DWORD *)(a2 + 4) = dword_1017DC48;
    *(_DWORD *)(a2 + 8) = dword_1017DC4C;
    *(_DWORD *)(a2 + 12) = dword_1017DC50;
    *(_DWORD *)(a2 + 16) = dword_1017DC54;
    *(_BYTE *)(a2 + 19) = a1;
    v4 = 3 * v2;
    LOBYTE(dword_1019FE88[v4]) = a1;
    v5 = &dword_1019FE8C[3 * v2];
    *v5 = (int)v5;
    dword_1019FE90[v4] = (int)v5;
    dword_1017DC40 = v2 + 1;
    result = 1;
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_clnp.c", 1057, 0, 0);
    result = 0;
  }
  return result;
}
// 1017DC40: using guessed type int dword_1017DC40;
// 1017DC44: using guessed type int dword_1017DC44;
// 1017DC48: using guessed type int dword_1017DC48;
// 1017DC4C: using guessed type int dword_1017DC4C;
// 1017DC50: using guessed type int dword_1017DC50;
// 1017DC54: using guessed type int dword_1017DC54;
// 1019FE88: using guessed type int dword_1019FE88[];
// 1019FE8C: using guessed type int dword_1019FE8C[];
// 1019FE90: using guessed type int dword_1019FE90[];

//----- (100021C0) --------------------------------------------------------
unsigned int __cdecl sub_100021C0(int a1, int a2, int a3, char a4, int a5, int a6, unsigned int a7)
{
  int v7; // ecx@1
  __int16 v8; // ax@1
  unsigned int result; // eax@1
  unsigned int v10; // ebp@2
  int v11; // ecx@3
  int v12; // edx@5
  int v13; // edx@5
  unsigned int v14; // edi@5
  int v15; // [sp+14h] [bp-A4h]@1
  int v16; // [sp+B0h] [bp-8h]@1

  sub_10003A10(&v15, (int)&unk_1017DD80, 255, 1);
  sub_100040E0(v15, -68, a2, a1, word_1017DD78, 0);
  v16 = a3;
  sub_100038D0((int)&v15, a4);
  sub_10004240((int)&v15, a5);
  sub_100039B0((int)&v15, 0);
  v7 = v15 + 55;
  v8 = a7 + *(_BYTE *)(v15 + 1);
  *(_BYTE *)v7 = HIBYTE(v8);
  *(_BYTE *)(v7 + 1) = v8;
  result = 0;
  if ( a7 )
  {
    v10 = (512 - *(_BYTE *)(v15 + 1)) & 0xFFF8;
    do
    {
      v11 = a7 - result;
      if ( a7 - result > v10 )
        v11 = v10;
      v12 = v15 + 5;
      *(_BYTE *)v12 = BYTE1(v11);
      *(_BYTE *)(v12 + 1) = v11;
      v13 = v15 + 53;
      v14 = v11 + result;
      *(_BYTE *)v13 = BYTE1(result);
      *(_BYTE *)(v13 + 1) = result;
      if ( v11 + result >= a7 )
        *(_BYTE *)(v15 + 4) &= 0xBFu;
      else
        *(_BYTE *)(v15 + 4) |= 0x40u;
      sub_10003FA0((int)&v15, result + a6, v11);
      sub_100123E0((int)&v15);
      result = v14;
    }
    while ( v14 < a7 );
  }
  ++word_1017DD78;
  return result;
}
// 1017DD78: using guessed type __int16 word_1017DD78;

//----- (10002320) --------------------------------------------------------
char __cdecl sub_10002320(int a1, char a2, char a3)
{
  void *v3; // eax@1
  size_t v4; // edi@1
  int v5; // eax@3
  int v6; // eax@14
  unsigned int v7; // eax@15
  int v9; // [sp+Ch] [bp-A4h]@7

  v3 = *(void **)a1;
  v4 = *(_BYTE *)(*(_DWORD *)a1 + 1);
  if ( v4 > *(_DWORD *)(a1 + 4) )
    v4 = *(_DWORD *)(a1 + 4);
  sub_10042450(6, a2, v3, v4);
  v5 = *(_DWORD *)a1;
  if ( (*(_BYTE *)(*(_DWORD *)a1 + 4) & 0x1F) != 1
    && *(_BYTE *)(*(_DWORD *)a1 + 4) & 0x20
    && (!(*(_BYTE *)(a1 + 148) & 0x40) || *(_BYTE *)(*(_BYTE *)(a1 + 141) + v5 + 2) != 1) )
  {
    sub_10003A10(&v9, (int)&unk_1017DD80, 255, 1);
    sub_100040E0(v9, 1, *(_DWORD *)a1 + 31, (int)&dword_1017DC44, 0, 0);
    if ( *(_WORD *)(a1 + 148) & 0x200 )
      sub_100038D0((int)&v9, *(_BYTE *)(a1 + 16));
    if ( *(_BYTE *)(a1 + 148) & 4 )
      sub_100039B0((int)&v9, *(_BYTE *)(a1 + 17) & 0x3F);
    if ( *(_BYTE *)(a1 + 148) & 0x10 )
      sub_10004240((int)&v9, a1 + 150);
    if ( *(_BYTE *)(a1 + 148) & 0x80 )
    {
      v6 = *(_DWORD *)a1 + *(_BYTE *)(a1 + 19);
      if ( !*(_BYTE *)(v6 + 2) )
      {
        v7 = (signed int)((unsigned __int64)(818089009i64 * (*(_BYTE *)(v6 + 1) - 2)) >> 32) >> 2;
        sub_10003900((int)&v9, v7 + (v7 >> 31), 0, 0);
      }
    }
    sub_10003890((int)&v9, a2, a3);
    sub_10003FA0((int)&v9, *(_DWORD *)a1, v4);
    LOBYTE(v5) = sub_100123E0((int)&v9);
  }
  return v5;
}
// 1017DC44: using guessed type int dword_1017DC44;

//----- (100024B0) --------------------------------------------------------
bool __cdecl sub_100024B0(_DWORD *a1)
{
  _DWORD *v1; // ecx@1
  unsigned int v2; // esi@1
  int *v3; // eax@1
  int v4; // edx@5
  int v5; // esi@6
  _BYTE *v6; // eax@6
  _BYTE *v7; // ecx@6
  int v8; // esi@8
  _BYTE *v9; // eax@8
  _BYTE *v10; // ecx@8
  _BYTE *v11; // eax@10
  _BYTE *v12; // ecx@10
  signed int v13; // eax@12

  v1 = a1;
  v2 = 19;
  v3 = &dword_1017DC44;
  do
  {
    if ( *v1 != *v3 )
      goto LABEL_5;
    v2 -= 4;
    ++v3;
    ++v1;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_14:
    v13 = 0;
    return v13 == 0;
  }
LABEL_5:
  v4 = *(_BYTE *)v1 - *(_BYTE *)v3;
  if ( *(_BYTE *)v1 == *(_BYTE *)v3 )
  {
    v5 = v2 - 1;
    v6 = (char *)v3 + 1;
    v7 = (char *)v1 + 1;
    if ( !v5 )
      goto LABEL_14;
    v4 = *v7 - *v6;
    if ( *v7 == *v6 )
    {
      v8 = v5 - 1;
      v9 = v6 + 1;
      v10 = v7 + 1;
      if ( !v8 )
        goto LABEL_14;
      v4 = *v10 - *v9;
      if ( *v10 == *v9 )
      {
        v11 = v9 + 1;
        v12 = v10 + 1;
        if ( v8 == 1 )
          goto LABEL_14;
        v4 = *v12 - *v11;
        if ( *v12 == *v11 )
          goto LABEL_14;
      }
    }
  }
  v13 = 1;
  if ( v4 <= 0 )
    return 0;
  return v13 == 0;
}
// 1017DC44: using guessed type int dword_1017DC44;

//----- (10002550) --------------------------------------------------------
int __cdecl sub_10002550(int a1, int a2)
{
  unsigned __int8 v2; // al@1
  unsigned __int8 v3; // cl@1
  int result; // eax@2

  v2 = *(_BYTE *)(a1 + 36);
  v3 = *(_BYTE *)(a2 + 36);
  if ( v3 <= v2 )
    result = -(v3 < v2);
  else
    result = 1;
  return result;
}

//----- (10002570) --------------------------------------------------------
int __fastcall sub_10002570(int a1, unsigned __int16 a2)
{
  int result; // eax@1
  int i; // ecx@1

  result = *(_DWORD *)(a1 + 12);
  for ( i = a1 + 8; result != i; result = *(_DWORD *)(result + 4) )
  {
    if ( *(_WORD *)(result + 12) < a2 )
      break;
  }
  return result;
}

//----- (10002590) --------------------------------------------------------
int *__usercall sub_10002590@<eax>(int a1@<ebx>)
{
  int v1; // eax@1
  _DWORD *v2; // ecx@1
  _DWORD *v3; // edx@2
  _DWORD *v4; // esi@2
  int *v5; // edx@2
  bool v6; // zf@2
  int *result; // eax@3

  v1 = *(_DWORD *)(a1 + 8);
  v2 = *(_DWORD **)v1;
  if ( v1 != a1 + 8 )
  {
    do
    {
      v3 = *(_DWORD **)v1;
      v4 = *(_DWORD **)(v1 + 4);
      v3[1] = v4;
      *v4 = v3;
      v5 = (int *)dword_1019FE84;
      dword_1019FE84 = v1;
      *(_DWORD *)v1 = &dword_1019FE80;
      *(_DWORD *)(v1 + 4) = v5;
      *v5 = v1;
      v1 = (int)v2;
      v6 = v2 == (_DWORD *)(a1 + 8);
      v2 = (_DWORD *)*v2;
    }
    while ( !v6 );
  }
  result = (int *)dword_1017D95C;
  dword_1017D95C = a1;
  *(_DWORD *)a1 = &dword_1017D958;
  *(_DWORD *)(a1 + 4) = result;
  *result = a1;
  return result;
}
// 1017D958: using guessed type int dword_1017D958;
// 1017D95C: using guessed type int dword_1017D95C;
// 1019FE80: using guessed type int dword_1019FE80;
// 1019FE84: using guessed type int dword_1019FE84;

//----- (100025F0) --------------------------------------------------------
int *__fastcall sub_100025F0(int a1, char a2)
{
  unsigned int v2; // eax@1
  int *v3; // ecx@2
  int *result; // eax@5

  v2 = 0;
  if ( dword_1017DC40 )
  {
    v3 = dword_1019FE88;
    while ( *(_BYTE *)v3 != a2 )
    {
      ++v2;
      v3 += 3;
      if ( v2 >= dword_1017DC40 )
        goto LABEL_5;
    }
    result = &dword_1019FE88[3 * v2];
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}
// 1017DC40: using guessed type int dword_1017DC40;
// 1019FE88: using guessed type int dword_1019FE88[];

//----- (10002620) --------------------------------------------------------
unsigned int __usercall sub_10002620@<eax>(void *a1@<ecx>, int a2@<edi>, int a3@<esi>)
{
  void *v3; // ecx@1
  unsigned int result; // eax@1

  sub_100429D0(a1);
  *(_DWORD *)a3 = *(_DWORD *)a2;
  v3 = *(void **)(a2 + 4);
  *(_DWORD *)(a3 + 4) = v3;
  *(_WORD *)(a3 + 8) = *(_WORD *)(a2 + 8);
  *(_BYTE *)(a3 + 10) = *(_BYTE *)(a2 + 10);
  *(_BYTE *)(a3 + 11) = 0;
  *(_BYTE *)(a3 + 12) = 0;
  *(_BYTE *)(a3 + 13) = 0;
  *(_BYTE *)(a3 + 14) = 0;
  result = sub_100429D0(v3);
  *(_BYTE *)(a3 + 15) = BYTE3(result);
  *(_BYTE *)(a3 + 16) = result >> 16;
  *(_BYTE *)(a3 + 17) = BYTE1(result);
  *(_BYTE *)(a3 + 18) = result;
  *(_BYTE *)(a3 + 19) = 0;
  return result;
}

//----- (10002680) --------------------------------------------------------
void *__usercall sub_10002680@<eax>(int a1@<eax>, int a2@<ebx>, int a3@<esi>, __int16 a4, __int16 a5, char a6)
{
  void *result; // eax@1

  *(_DWORD *)(a3 + 16) = *(_DWORD *)a1;
  *(_DWORD *)(a3 + 20) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a3 + 24) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a3 + 28) = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a3 + 32) = *(_DWORD *)(a1 + 16);
  result = memset((void *)(a3 + 36), 0, 0x8Cu);
  *(_BYTE *)(a3 + 36) = a6;
  *(_DWORD *)(a3 + 38) = *(_DWORD *)a2;
  LOWORD(result) = *(_WORD *)(a2 + 4);
  *(_WORD *)(a3 + 42) = (_WORD)result;
  *(_WORD *)(a3 + 176) = a4;
  *(_WORD *)(a3 + 178) = a5;
  *(_BYTE *)(a3 + 180) = -1;
  return result;
}

//----- (100026F0) --------------------------------------------------------
bool __usercall sub_100026F0@<al>(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // ecx@1
  bool result; // al@6

  v1 = *(_DWORD *)(a1 + 8);
  v2 = 0;
  if ( v1 == a1 + 8 )
  {
LABEL_6:
    result = v2 == *(_WORD *)(a1 + 178);
  }
  else
  {
    while ( *(_WORD *)(v1 + 12) == v2 )
    {
      if ( *(_BYTE *)(v1 + 8) == 1 )
        v2 += *(_WORD *)(v1 + 10);
      v1 = *(_DWORD *)v1;
      if ( v1 == a1 + 8 )
        goto LABEL_6;
    }
    result = 0;
  }
  return result;
}

//----- (10002730) --------------------------------------------------------
int *__cdecl sub_10002730(int a1, int a2)
{
  unsigned int v2; // edx@1
  _DWORD *v3; // eax@1
  _DWORD *v4; // ecx@1
  int v5; // esi@5
  int v6; // edx@6
  _BYTE *v7; // eax@6
  _BYTE *v8; // ecx@6
  int v9; // edx@8
  _BYTE *v10; // eax@8
  _BYTE *v11; // ecx@8
  _BYTE *v12; // eax@10
  _BYTE *v13; // ecx@10
  signed int v14; // eax@12
  int v15; // eax@16
  unsigned int v16; // edx@17
  void *v17; // ecx@18
  int v18; // eax@18
  int v19; // esi@21
  char v20; // dl@24
  int v21; // eax@27
  _DWORD *v22; // ecx@27
  int v24; // [sp+Ch] [bp-A8h]@21
  char v25; // [sp+10h] [bp-A4h]@21
  char v26; // [sp+24h] [bp-90h]@25
  unsigned __int8 v27; // [sp+9Ch] [bp-18h]@24

  v2 = 20;
  v3 = (_DWORD *)(*(_DWORD *)a2 + 31);
  v4 = &unk_1017DC60;
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_5;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_14:
    v14 = 0;
    goto LABEL_15;
  }
LABEL_5:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_14;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_14;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_14;
        v5 = *v13 - *v12;
        if ( *v13 == *v12 )
          goto LABEL_14;
      }
    }
  }
  v14 = 1;
  if ( v5 <= 0 )
    v14 = -1;
LABEL_15:
  if ( !v14 )
  {
    v15 = sub_1007C040();
    byte_1017DD74 = 4;
    dword_1017DC78 = v15;
    if ( sub_10003A40(a2) )
    {
      v16 = 0;
      if ( *(_BYTE *)(a2 + 140) )
      {
        v17 = &unk_1017DC7C;
        v18 = a2 + 20;
        do
        {
          *(_DWORD *)v17 = *(_DWORD *)v18;
          *((_DWORD *)v17 + 1) = *(_DWORD *)(v18 + 4);
          *((_DWORD *)v17 + 2) = *(_DWORD *)(v18 + 8);
          *((_DWORD *)v17 + 3) = *(_DWORD *)(v18 + 12);
          *((_DWORD *)v17 + 4) = *(_DWORD *)(v18 + 16);
          ++v16;
          v18 += 20;
          v17 = (char *)v17 + 20;
        }
        while ( v16 < *(_BYTE *)(a2 + 140) );
      }
      byte_1017DCF4 = *(_BYTE *)(a2 + 140);
    }
    byte_1017DD6D = 0;
    v19 = *(_DWORD *)(a2 + 8);
    sub_10003A10(&v25, *(_DWORD *)(a2 + 8), 255, 0);
    if ( !sub_10003FE0(v19, *(_BYTE *)(v19 + 1), (int)&v25, &v24)
      && !sub_10004280((int)&v25, &v24)
      && sub_10003A40((int)&v25) )
    {
      v20 = v27;
      if ( v27 )
        qmemcpy(&unk_1017DCF5, &v26, 4 * (20 * (unsigned int)v27 >> 2));
      byte_1017DD6D = v20;
    }
  }
  v21 = *(_DWORD *)a1;
  v22 = *(_DWORD **)(a1 + 4);
  *(_DWORD *)(v21 + 4) = v22;
  *v22 = v21;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  return sub_10002590(a1);
}
// 1017DC78: using guessed type int dword_1017DC78;
// 1017DCF4: using guessed type char byte_1017DCF4;
// 1017DD6D: using guessed type char byte_1017DD6D;
// 1017DD74: using guessed type char byte_1017DD74;

//----- (10002910) --------------------------------------------------------
int *__cdecl sub_10002910(int a1)
{
  int v1; // ecx@0
  int v2; // edi@1
  int v3; // ebp@2
  int v4; // esi@5
  char v5; // al@6
  char v6; // ST24_1@13
  int v7; // eax@15
  int v8; // esi@17
  char v9; // al@18
  char v10; // ST24_1@25
  int v11; // eax@26
  int v12; // eax@27
  __int16 v13; // dx@28
  __int16 v14; // si@28
  __int16 v15; // dx@32
  __int16 v16; // cx@32
  __int16 v17; // bx@34
  int v18; // edx@34
  int v19; // esi@34
  _DWORD *v20; // ebp@34
  int v21; // edi@34
  int v22; // eax@40
  unsigned __int16 v23; // cx@42
  unsigned __int16 v24; // bx@44
  int v25; // eax@49
  __int16 v26; // cx@49
  int v27; // eax@49
  int v28; // eax@49
  int v29; // eax@53
  _DWORD *v30; // ecx@53
  int *result; // eax@53
  unsigned __int16 v32; // [sp+10h] [bp-15Ch]@34
  unsigned __int16 v33; // [sp+14h] [bp-158h]@30
  _DWORD *v34; // [sp+18h] [bp-154h]@34
  __int16 v35; // [sp+20h] [bp-14Ch]@34
  char v36; // [sp+24h] [bp-148h]@3
  int v37; // [sp+28h] [bp-144h]@1
  int v38; // [sp+2Ch] [bp-140h]@14
  __int16 v39; // [sp+BCh] [bp-B0h]@16
  char v40; // [sp+C8h] [bp-A4h]@3
  int v41; // [sp+D8h] [bp-94h]@7
  char v42[4]; // [sp+154h] [bp-18h]@13
  int v43; // [sp+15Ch] [bp-10h]@4

  v2 = v1;
  sub_10003A10(&v37, (int)&unk_1017DD80, 255, 1);
  sub_100040E0(v37, -1, *(_DWORD *)v2 + 31, (int)&dword_1017DC44, 0, 0);
  if ( *(_WORD *)(v2 + 12) < 0x33u
    || (v3 = *(_DWORD *)(v2 + 8), *(_BYTE *)v3 != -127)
    || (sub_10003A10(&v40, v3, 255, 1), sub_10004280((int)&v40, (int *)&v36))
    || v43 & 0x400 )
  {
    v8 = sub_100040A0(*(_DWORD *)v2);
    if ( v8 )
    {
      do
      {
        v9 = *(_BYTE *)v8;
        if ( *(_BYTE *)v8 == -61 )
        {
          sub_100039B0((int)&v37, *(_BYTE *)(v2 + 17) & 0x3F);
        }
        else
        {
          switch ( v9 )
          {
            case -59:
              sub_10004240((int)&v37, v2 + 150);
              break;
            case -51:
              sub_100038D0((int)&v37, *(_BYTE *)(v2 + 16));
              break;
            case -53:
              v10 = *(_BYTE *)(v8 + 1);
              *(_BYTE *)(v8 + 3) = 3;
              sub_10003900((int)&v37, 6, (void *)(v8 + 2), v10);
              break;
          }
        }
        sub_100040C0(*(_DWORD *)v2, v8);
        v8 = v11;
      }
      while ( v11 );
    }
  }
  else
  {
    *(_BYTE *)(v37 + 3) = *(_BYTE *)(v3 + 3);
    v4 = sub_100040A0(v3);
    if ( v4 )
    {
      do
      {
        v5 = *(_BYTE *)v4;
        if ( *(_BYTE *)v4 == -51 )
        {
          sub_100038D0((int)&v37, v41);
        }
        else
        {
          switch ( v5 )
          {
            case -61:
              sub_100039B0((int)&v37, BYTE1(v41) & 0x3F);
              break;
            case -59:
              sub_10004240((int)&v37, (int)&v43 + 2);
              break;
            case -53:
              v6 = *(_BYTE *)(v4 + 1);
              *(_BYTE *)(v4 + 3) = 3;
              sub_10003900((int)&v37, v42[0], (void *)(v4 + 2), v6);
              break;
            default:
              sub_10003820(v37, v38, v5, *(_BYTE *)(v4 + 1), (void *)(v4 + 2));
              break;
          }
        }
        sub_100040C0(v3, v4);
        v4 = v7;
      }
      while ( v7 );
    }
    v39 |= v43;
  }
  v12 = *(_DWORD *)v2;
  if ( *(_BYTE *)(*(_DWORD *)v2 + 4) & 0x80 )
  {
    v13 = *(_BYTE *)(v12 + 55);
    v14 = *(_BYTE *)(v12 + 56);
  }
  else
  {
    v13 = *(_BYTE *)(v12 + 5);
    v14 = *(_BYTE *)(v12 + 6);
  }
  v33 = v14 + (v13 << 8);
  if ( *(_BYTE *)(*(_DWORD *)v2 + 4) & 0x80 && *(_BYTE *)(*(_DWORD *)v2 + 56) + (*(_BYTE *)(*(_DWORD *)v2 + 55) << 8) )
  {
    v15 = *(_BYTE *)(v12 + 56);
    v16 = *(_BYTE *)(*(_DWORD *)v2 + 55) << 8;
  }
  else
  {
    v16 = *(_BYTE *)(v12 + 6);
    v15 = *(_BYTE *)(*(_DWORD *)v2 + 5) << 8;
  }
  v17 = v15 + v16 + *(_BYTE *)(v37 + 1);
  v18 = a1;
  v19 = *(_DWORD *)(a1 + 8);
  v20 = *(_DWORD **)(a1 + 8);
  LOWORD(v21) = 0;
  v35 = v17;
  v32 = 0;
  v34 = (_DWORD *)*v20;
  if ( v20 != (_DWORD *)(a1 + 8) )
  {
    do
    {
      if ( *((_WORD *)v20 + 5) )
      {
        if ( *((_BYTE *)v20 + 8) )
          *(_WORD *)(v19 + 10) = 0;
        else
          v20 = (_DWORD *)*v20;
        if ( *(_WORD *)(v19 + 10) < 0x100u )
        {
          do
          {
            v22 = *(_WORD *)(v19 + 10);
            if ( v32 + v22 >= v33 )
              break;
            v21 = (unsigned __int16)v21;
            v23 = v22 + *((_WORD *)v20 + 5) - (unsigned __int16)v21 >= 256 ? 256 - v22 : *((_WORD *)v20 + 5) - v21;
            v24 = v23;
            memcpy((void *)(v22 + v19 + 14), (char *)v20 + v21 + 14, v23);
            *(_WORD *)(v19 + 10) += v24;
            if ( v21 + v24 == *((_WORD *)v20 + 5) )
            {
              LOWORD(v21) = 0;
              *((_WORD *)v20 + 5) = 0;
            }
            else
            {
              LOWORD(v21) = v24;
            }
            v20 = (_DWORD *)*v20;
          }
          while ( *(_WORD *)(v19 + 10) < 0x100u );
          v17 = v35;
        }
        v25 = v37 + 53;
        *(_BYTE *)(v25 + 1) = v32;
        v26 = word_1017DD78;
        *(_BYTE *)v25 = HIBYTE(v32);
        v27 = v37 + 55;
        *(_BYTE *)v27 = HIBYTE(v17);
        *(_BYTE *)(v27 + 1) = v17;
        v28 = v37 + 51;
        *(_BYTE *)v28 = HIBYTE(v26);
        *(_BYTE *)(v28 + 1) = v26;
        v32 += *(_WORD *)(v19 + 10);
        if ( v32 == v33 )
          *(_BYTE *)(v37 + 4) &= 0xBFu;
        sub_10003FA0((int)&v37, v19 + 14, *(_WORD *)(v19 + 10));
        sub_100123E0((int)&v37);
        v18 = a1;
      }
      v20 = v34;
      v34 = (_DWORD *)*v34;
    }
    while ( v20 != (_DWORD *)(v18 + 8) );
  }
  v29 = *(_DWORD *)v18;
  v30 = *(_DWORD **)(v18 + 4);
  *(_DWORD *)(v29 + 4) = v30;
  *v30 = v29;
  *(_DWORD *)v18 = 0;
  *(_DWORD *)(v18 + 4) = 0;
  result = sub_10002590(v18);
  ++word_1017DD78;
  return result;
}
// 1017DC44: using guessed type int dword_1017DC44;
// 1017DD78: using guessed type __int16 word_1017DD78;

//----- (10002D60) --------------------------------------------------------
int *__cdecl sub_10002D60(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // ecx@1
  void *v4; // eax@1
  signed int v5; // edx@1
  int *result; // eax@3

  word_1017DD78 = 0;
  dword_1019FEA0 = 0;
  dword_1019FE80 = (int)&dword_1019FE80;
  dword_1019FE84 = (int)&dword_1019FE80;
  dword_1017D958 = (int)&dword_1017D958;
  dword_1017D95C = (int)&dword_1017D958;
  dword_1017D950 = (int)&dword_1017D950;
  dword_1017D954 = (int)&dword_1017D950;
  sub_10002620(v1, a1, (int)&dword_1017DC44);
  memset(&dword_1017D960, 0, 0x2E0u);
  dword_1017D968 = (int)&dword_1017D968;
  dword_1017D96C = (int)&dword_1017D968;
  v2 = dword_1017D958;
  *(_DWORD *)(dword_1017D958 + 4) = &dword_1017D960;
  dword_1017D960 = v2;
  dword_1017DA20 = (int)&dword_1017DA20;
  dword_1017DA24 = (int)&dword_1017DA20;
  dword_1017DAD8 = (int)&dword_1017DAD8;
  dword_1017DADC = (int)&dword_1017DAD8;
  dword_1017DB90 = (int)&dword_1017DB90;
  dword_1017DB94 = (int)&dword_1017DB90;
  dword_1017D964 = (int)&dword_1017DA18;
  dword_1017DA18 = (int)&dword_1017D960;
  dword_1017DA1C = (int)&dword_1017DAD0;
  dword_1017DAD0 = (int)&dword_1017DA18;
  dword_1017DAD4 = (int)&dword_1017DB88;
  dword_1017DB88 = (int)&dword_1017DAD0;
  dword_1017DB8C = (int)&dword_1017D958;
  dword_1017D958 = (int)&dword_1017DB88;
  memset(&unk_1017DE80, 0, 0x22000u);
  v3 = dword_1019FE80;
  v4 = &unk_1017DE80;
  v5 = 512;
  do
  {
    *(_DWORD *)(v3 + 4) = v4;
    *(_DWORD *)v4 = v3;
    *((_DWORD *)v4 + 1) = &dword_1019FE80;
    v3 = (int)v4;
    v4 = (char *)v4 + 272;
    --v5;
  }
  while ( v5 );
  dword_1019FE88[0] = 0;
  dword_1019FE94 = 0;
  dword_1017DC40 = 0;
  dword_1019FE8C[0] = (int)dword_1019FE8C;
  dword_1019FE90[0] = (int)dword_1019FE8C;
  result = &dword_1019FE98;
  dword_1019FE80 = v3;
  dword_1019FE98 = (int)&dword_1019FE98;
  dword_1019FE9C = (int)&dword_1019FE98;
  return result;
}
// 1017D950: using guessed type int dword_1017D950;
// 1017D954: using guessed type int dword_1017D954;
// 1017D958: using guessed type int dword_1017D958;
// 1017D95C: using guessed type int dword_1017D95C;
// 1017D960: using guessed type int dword_1017D960;
// 1017D964: using guessed type int dword_1017D964;
// 1017D968: using guessed type int dword_1017D968;
// 1017D96C: using guessed type int dword_1017D96C;
// 1017DA18: using guessed type int dword_1017DA18;
// 1017DA1C: using guessed type int dword_1017DA1C;
// 1017DA20: using guessed type int dword_1017DA20;
// 1017DA24: using guessed type int dword_1017DA24;
// 1017DAD0: using guessed type int dword_1017DAD0;
// 1017DAD4: using guessed type int dword_1017DAD4;
// 1017DAD8: using guessed type int dword_1017DAD8;
// 1017DADC: using guessed type int dword_1017DADC;
// 1017DB88: using guessed type int dword_1017DB88;
// 1017DB8C: using guessed type int dword_1017DB8C;
// 1017DB90: using guessed type int dword_1017DB90;
// 1017DB94: using guessed type int dword_1017DB94;
// 1017DC40: using guessed type int dword_1017DC40;
// 1017DC44: using guessed type int dword_1017DC44;
// 1017DD78: using guessed type __int16 word_1017DD78;
// 1019FE80: using guessed type int dword_1019FE80;
// 1019FE84: using guessed type int dword_1019FE84;
// 1019FE88: using guessed type int dword_1019FE88[];
// 1019FE8C: using guessed type int dword_1019FE8C[];
// 1019FE90: using guessed type int dword_1019FE90[];
// 1019FE94: using guessed type int dword_1019FE94;
// 1019FE98: using guessed type int dword_1019FE98;
// 1019FE9C: using guessed type int dword_1019FE9C;
// 1019FEA0: using guessed type int dword_1019FEA0;

//----- (10002EE0) --------------------------------------------------------
void __usercall sub_10002EE0(int *a1@<edx>, int a2@<ecx>, char a3, char a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // eax@11
  _DWORD *v7; // ecx@13
  char v8; // [sp+Ch] [bp-ACh]@7
  int v9; // [sp+10h] [bp-A8h]@7

  v4 = 0;
  v5 = a2;
  if ( a1 )
  {
    v4 = *a1;
  }
  else if ( a2 )
  {
    v4 = *(_DWORD *)(a2 + 8) + 14;
  }
  if ( *(_BYTE *)(v4 + 4) & 0x20 )
  {
    if ( a1 )
    {
      qmemcpy(&v9, a1, 0xA0u);
    }
    else
    {
      sub_10003A10(&v9, v4, 255, 0);
      v9 = v4;
      sub_10004280((int)&v9, (int *)&v8);
    }
    sub_10002320((int)&v9, a3, a4);
  }
  if ( v5 )
  {
    v6 = *(_DWORD *)v5;
    if ( *(_DWORD *)v5 || *(_DWORD *)(v5 + 4) )
    {
      v7 = *(_DWORD **)(v5 + 4);
      *(_DWORD *)(v6 + 4) = v7;
      *v7 = v6;
      *(_DWORD *)v5 = 0;
      *(_DWORD *)(v5 + 4) = 0;
    }
    sub_10002590(v5);
  }
}

//----- (10002FB0) --------------------------------------------------------
void __cdecl sub_10002FB0(unsigned __int8 a1)
{
  int v1; // eax@1
  int i; // esi@1
  unsigned __int8 v3; // cl@3
  unsigned __int8 v4; // dl@3
  int *v5; // edi@9
  int v6; // ebx@9
  int j; // eax@10
  unsigned __int8 v8; // cl@12
  unsigned __int8 v9; // dl@12

  v1 = dword_1017D950;
  for ( i = 0; (int *)v1 != &dword_1017D950; v1 = *(_DWORD *)v1 )
  {
    if ( i )
    {
      v3 = *(_BYTE *)(v1 + 36);
      v4 = *(_BYTE *)(i + 36);
      if ( v3 >= v4 && (v3 != v4 || *(_BYTE *)(v1 + 180) >= *(_BYTE *)(i + 180)) )
        continue;
    }
    i = v1;
  }
  if ( dword_1017DC40 )
  {
    v5 = dword_1019FE8C;
    v6 = dword_1017DC40;
    do
    {
      for ( j = *v5; (int *)j != v5; j = *(_DWORD *)j )
      {
        if ( i )
        {
          v8 = *(_BYTE *)(j + 36);
          v9 = *(_BYTE *)(i + 36);
          if ( v8 >= v9 && (v8 != v9 || *(_BYTE *)(j + 180) >= *(_BYTE *)(i + 180)) )
            continue;
        }
        i = j;
      }
      v5 += 3;
      --v6;
    }
    while ( v6 );
  }
  if ( i )
  {
    if ( *(_BYTE *)(i + 36) < a1 )
      sub_10002EE0(0, i, 3, 51);
  }
}
// 1017D950: using guessed type int dword_1017D950;
// 1017DC40: using guessed type int dword_1017DC40;
// 1019FE8C: using guessed type int dword_1019FE8C[];

//----- (10003060) --------------------------------------------------------
int __cdecl sub_10003060(int a1, __int16 a2, __int16 a3, char a4, int a5, int a6, unsigned __int8 a7)
{
  int v7; // edi@1
  unsigned int v8; // eax@2
  _DWORD *v9; // ecx@2
  _DWORD *v10; // edx@2
  int v11; // esi@6
  int v12; // eax@7
  _BYTE *v13; // ecx@7
  _BYTE *v14; // edx@7
  int v15; // eax@9
  _BYTE *v16; // ecx@9
  _BYTE *v17; // edx@9
  _BYTE *v18; // ecx@11
  _BYTE *v19; // edx@11
  signed int v20; // eax@13
  int result; // eax@23
  int v22; // esi@25
  _DWORD *v23; // edx@28
  int v24; // eax@28
  int *v25; // eax@28
  unsigned __int8 v26; // dl@30
  int v27; // ecx@32
  int v28; // eax@32
  int v29; // ebp@32
  int v30; // ecx@32

  v7 = dword_1017D950;
  if ( (int *)dword_1017D950 != &dword_1017D950 )
  {
    while ( 1 )
    {
      v8 = 20;
      v9 = (_DWORD *)a1;
      v10 = (_DWORD *)(v7 + 16);
      do
      {
        if ( *v10 != *v9 )
          goto LABEL_6;
        v8 -= 4;
        ++v9;
        ++v10;
      }
      while ( v8 >= 4 );
      if ( !v8 )
      {
LABEL_15:
        v20 = 0;
        goto LABEL_16;
      }
LABEL_6:
      v11 = *(_BYTE *)v10 - *(_BYTE *)v9;
      if ( *(_BYTE *)v10 == *(_BYTE *)v9 )
      {
        v12 = v8 - 1;
        v13 = (char *)v9 + 1;
        v14 = (char *)v10 + 1;
        if ( !v12 )
          goto LABEL_15;
        v11 = *v14 - *v13;
        if ( *v14 == *v13 )
        {
          v15 = v12 - 1;
          v16 = v13 + 1;
          v17 = v14 + 1;
          if ( !v15 )
            goto LABEL_15;
          v11 = *v17 - *v16;
          if ( *v17 == *v16 )
          {
            v18 = v16 + 1;
            v19 = v17 + 1;
            if ( v15 == 1 )
              goto LABEL_15;
            v11 = *v19 - *v18;
            if ( *v19 == *v18 )
              goto LABEL_15;
          }
        }
      }
      v20 = 1;
      if ( v11 <= 0 )
        v20 = -1;
LABEL_16:
      if ( !v20 && *(_WORD *)(v7 + 176) == a2 )
        break;
      v7 = *(_DWORD *)v7;
      if ( (int *)v7 == &dword_1017D950 )
        goto LABEL_25;
    }
    if ( *(_WORD *)(v7 + 178) == a3 && *(_BYTE *)(v7 + 36) == a4 && sub_10003A70(v7 + 38, a5) )
      return v7;
    sub_10002EE0(0, v7, 3, 5);
  }
LABEL_25:
  v22 = dword_1017D958;
  if ( (int *)dword_1017D958 != &dword_1017D958
    || (sub_10002FB0(a4), v22 = dword_1017D958, (int *)dword_1017D958 != &dword_1017D958) )
  {
    v23 = *(_DWORD **)(v22 + 4);
    v24 = *(_DWORD *)v22;
    *(_DWORD *)(v24 + 4) = v23;
    *v23 = v24;
    v25 = (int *)dword_1017D954;
    dword_1017D954 = v22;
    *(_DWORD *)(v22 + 4) = v25;
    *(_DWORD *)v22 = &dword_1017D950;
    *v25 = v22;
    sub_10002680(a1, a5, v22, a2, a3, a4);
    if ( a6 && a7 )
    {
      v26 = 0;
      if ( a7 )
      {
        do
        {
          if ( v26 >= 6u )
            break;
          v27 = 20 * v26;
          v28 = v27 + a6;
          *(_DWORD *)(v27 + v22 + 52) = *(_DWORD *)(v27 + a6);
          v29 = *(_DWORD *)(v27 + a6 + 4);
          v30 = v27 + v22 + 52;
          *(_DWORD *)(v30 + 4) = v29;
          *(_DWORD *)(v30 + 8) = *(_DWORD *)(v28 + 8);
          *(_DWORD *)(v30 + 12) = *(_DWORD *)(v28 + 12);
          ++v26;
          *(_DWORD *)(v30 + 16) = *(_DWORD *)(v28 + 16);
        }
        while ( v26 < a7 );
      }
      *(_BYTE *)(v22 + 172) = v26;
    }
    result = v22;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1017D950: using guessed type int dword_1017D950;
// 1017D954: using guessed type int dword_1017D954;
// 1017D958: using guessed type int dword_1017D958;

//----- (10003240) --------------------------------------------------------
void __cdecl sub_10003240(int a1, int *a2)
{
  if ( *(_BYTE *)(*a2 + 4) & 0x80 && (unsigned __int16)(*(_BYTE *)(*a2 + 56) + (*(_BYTE *)(*a2 + 55) << 8)) > 0xFF01u )
    sub_10002EE0(a2, a1, 1, 55);
  else
    sub_10002910(a1);
}

//----- (10003290) --------------------------------------------------------
void __usercall sub_10003290(int *a1@<eax>, int a2@<ecx>, int a3)
{
  int *v3; // esi@1
  int v4; // eax@1
  int v5; // ebx@1
  int i; // edx@2
  int *v7; // eax@5
  int v8; // eax@10
  _DWORD *v9; // ecx@10

  v3 = a1;
  v4 = *a1;
  v5 = a2;
  switch ( *(_BYTE *)(v4 + 4) & 0x1F )
  {
    case 0x1C:
      for ( i = *(_DWORD *)(a3 + 4); i != a3 + 4; i = *(_DWORD *)i )
      {
        if ( sub_10002550(i, v5) > 0 )
          break;
      }
      v7 = *(int **)(i + 4);
      *(_DWORD *)(i + 4) = v5;
      *(_DWORD *)v5 = i;
      *(_DWORD *)(v5 + 4) = v7;
      *v7 = v5;
      break;
    case 0x1E:
      sub_10003240(a2, v3);
      break;
    case 0x1F:
      sub_10002730(a2, (int)v3);
      break;
    case 1:
      sub_10042450(6, 19, (void *)v4, *(_BYTE *)(v4 + 1));
      goto LABEL_10;
    default:
      sub_10002320((int)v3, 8, 0);
LABEL_10:
      v8 = *(_DWORD *)v5;
      v9 = *(_DWORD **)(v5 + 4);
      *(_DWORD *)(v8 + 4) = v9;
      *v9 = v8;
      *(_DWORD *)v5 = 0;
      *(_DWORD *)(v5 + 4) = 0;
      sub_10002590(v5);
      break;
  }
}

//----- (10003380) --------------------------------------------------------
int __cdecl sub_10003380(int a1, int a2, void *a3, int a4, unsigned int a5)
{
  int v5; // ecx@0
  int *v6; // eax@1
  int v7; // ebp@1
  int *v9; // eax@4
  int v10; // ebx@5
  int v11; // eax@5
  _DWORD *v12; // ecx@5
  int v13; // esi@5

  v6 = sub_100025F0(v5, *(_BYTE *)(a1 + 19));
  v7 = 0;
  if ( !v6 )
  {
    sub_10042930("..\\lib\\atn\\atn_clnp.c", 966, 0, 0);
    return 0;
  }
  v9 = v6 + 1;
  if ( (int *)*v9 == v9 )
    return 0;
  v10 = *v9;
  v11 = *(_DWORD *)*v9;
  v12 = *(_DWORD **)(v10 + 4);
  *(_DWORD *)(v11 + 4) = v12;
  *v12 = v11;
  v13 = *(_DWORD *)(v10 + 8);
  *(_DWORD *)v10 = 0;
  *(_DWORD *)(v10 + 4) = 0;
  if ( v13 == v10 + 8 )
  {
LABEL_10:
    qmemcpy(a3, (const void *)(v10 + 36), 0x8Cu);
    *(_DWORD *)a2 = *(_DWORD *)(v10 + 16);
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(v10 + 20);
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(v10 + 24);
    *(_DWORD *)(a2 + 12) = *(_DWORD *)(v10 + 28);
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(v10 + 32);
    sub_10002590(v10);
    return v7;
  }
  while ( *(_BYTE *)(v13 + 8) != 1 )
  {
LABEL_9:
    v13 = *(_DWORD *)v13;
    if ( v13 == v10 + 8 )
      goto LABEL_10;
  }
  if ( (unsigned int)*(_WORD *)(v13 + 10) + v7 <= a5 )
  {
    memcpy((void *)(a4 + v7), (const void *)(v13 + 14), *(_WORD *)(v13 + 10));
    v7 += *(_WORD *)(v13 + 10);
    goto LABEL_9;
  }
  sub_10042930("..\\lib\\atn\\atn_clnp.c", 1001, 0, 0);
  sub_10002EE0(0, v10, 3, 5);
  return 0;
}

//----- (10003470) --------------------------------------------------------
int __cdecl sub_10003470(unsigned __int8 a1)
{
  int v1; // eax@1
  int result; // eax@3
  int v3; // ecx@4
  int v4; // edx@4
  _DWORD *v5; // eax@4

  v1 = dword_1019FE80;
  if ( (int *)dword_1019FE80 != &dword_1019FE80
    || (sub_10002FB0(a1), v1 = dword_1019FE80, (int *)dword_1019FE80 != &dword_1019FE80) )
  {
    v3 = *(_DWORD *)v1;
    v4 = v1;
    v5 = *(_DWORD **)(v1 + 4);
    *(_DWORD *)(v3 + 4) = v5;
    *v5 = v3;
    result = v4;
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_clnp.c", 1533, 0, 0);
    result = 0;
  }
  return result;
}
// 1019FE80: using guessed type int dword_1019FE80;

//----- (100034C0) --------------------------------------------------------
void __usercall sub_100034C0(int a1@<eax>, unsigned int a2@<ebx>, _DWORD **a3@<esi>)
{
  _DWORD *v3; // ecx@1
  _DWORD *v4; // edx@1
  unsigned int v5; // edi@2
  char v6; // al@4
  bool v7; // zf@7

  v3 = *a3;
  v4 = (_DWORD *)**a3;
  if ( *a3 != a3 )
  {
    v5 = a1 - dword_1019FEA0;
    while ( 1 )
    {
      if ( v5 >= a2 )
      {
        v6 = *((_BYTE *)v3 + 180);
        if ( v6 )
          *((_BYTE *)v3 + 180) = v6 - 1;
      }
      if ( !*((_BYTE *)v3 + 180) )
        break;
      v3 = v4;
      v7 = v4 == a3;
      v4 = (_DWORD *)*v4;
      if ( v7 )
        return;
    }
    sub_10002EE0(0, (int)v3, -95, 3);
  }
}
// 1019FEA0: using guessed type int dword_1019FEA0;

//----- (10003510) --------------------------------------------------------
void sub_10003510()
{
  int v0; // edi@1
  unsigned int v1; // ebp@1
  int *v2; // esi@2

  v0 = sub_1007C040();
  sub_100034C0(v0, 0x1F4u, (_DWORD **)&dword_1017D950);
  v1 = 0;
  if ( dword_1017DC40 )
  {
    v2 = dword_1019FE8C;
    do
    {
      sub_100034C0(v0, 0x1F4u, (_DWORD **)v2);
      ++v1;
      v2 += 3;
    }
    while ( v1 < dword_1017DC40 );
  }
  if ( (unsigned int)(v0 - dword_1019FEA0) >= 0x1F4 )
    dword_1019FEA0 += 500;
}
// 1017D950: using guessed type int dword_1017D950;
// 1017DC40: using guessed type int dword_1017DC40;
// 1019FE8C: using guessed type int dword_1019FE8C[];
// 1019FEA0: using guessed type int dword_1019FEA0;

//----- (10003570) --------------------------------------------------------
int __usercall sub_10003570@<eax>(size_t a1@<ecx>, unsigned __int8 a2@<al>, int *a3@<edi>, char a4, __int16 a5, void *a6)
{
  unsigned int v6; // ebx@1
  int v7; // esi@1
  int result; // eax@2
  int v9; // eax@5

  v6 = a1;
  v7 = sub_10003470(a2);
  if ( v7 )
  {
    if ( v6 > 0x100 )
      v6 = 256;
    *(_BYTE *)(v7 + 8) = a4;
    *(_WORD *)(v7 + 12) = a5;
    *(_WORD *)(v7 + 10) = v6;
    memcpy((void *)(v7 + 14), a6, v6);
    v9 = *a3;
    *(_DWORD *)(v9 + 4) = v7;
    *(_DWORD *)v7 = v9;
    *(_DWORD *)(v7 + 4) = a3;
    *a3 = v7;
    result = v7;
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_clnp.c", 1471, 0, 0);
    result = 0;
  }
  return result;
}

//----- (100035E0) --------------------------------------------------------
void __cdecl sub_100035E0(size_t a1)
{
  int v1; // ebp@1
  int v2; // ecx@1
  int v3; // ebx@1
  char v4; // dl@1
  __int16 v5; // si@1
  __int16 v6; // di@4
  unsigned __int16 v7; // si@4
  __int16 v8; // ax@4
  int v9; // ecx@7
  unsigned __int8 v10; // al@13
  int *v11; // eax@17
  int *v12; // edi@17
  int v13; // eax@18
  int v14; // eax@24
  _DWORD *v15; // ecx@24
  void *v16; // [sp+Ch] [bp-Ch]@1
  int v17; // [sp+10h] [bp-8h]@7
  int *v18; // [sp+14h] [bp-4h]@1
  unsigned int v19; // [sp+1Ch] [bp+4h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 8);
  v3 = *(_DWORD *)a1;
  v4 = *(_BYTE *)(*(_DWORD *)a1 + 29);
  v5 = *(_WORD *)(a1 + 12);
  v19 = *(_WORD *)(a1 + 12);
  v16 = (void *)v2;
  v18 = sub_100025F0(v2, v4);
  if ( v18 && sub_100024B0((_DWORD *)(v3 + 10)) )
  {
    if ( *(_BYTE *)(v3 + 4) & 0x80 )
    {
      v6 = *(_BYTE *)(v3 + 52) + (*(_BYTE *)(v3 + 51) << 8);
      v7 = *(_BYTE *)(v3 + 54) + (*(_BYTE *)(v3 + 53) << 8);
      v8 = *(_BYTE *)(v3 + 56) + (*(_BYTE *)(v3 + 55) << 8) - *(_BYTE *)(v3 + 1);
      if ( (signed int)(v19 + v7) > (unsigned __int16)v8 )
      {
        sub_10002320(v1, 1, 55);
        return;
      }
    }
    else
    {
      v6 = 0;
      v8 = v5;
      v7 = 0;
    }
    v9 = sub_10003060(v3 + 31, v6, v8, *(_BYTE *)(v1 + 16), v1 + 150, v1 + 20, *(_BYTE *)(v1 + 140));
    v17 = v9;
    if ( v9 )
    {
      ++*(_DWORD *)(v9 + 44);
      if ( *(_BYTE *)(v1 + 148) & 4 && *(_BYTE *)(v1 + 17) & 8 )
        ++*(_DWORD *)(v9 + 48);
      v10 = *(_BYTE *)(v3 + 3);
      if ( v10 )
      {
        if ( *(_BYTE *)(v9 + 180) > v10 )
          *(_BYTE *)(v9 + 180) = v10;
        v11 = (int *)sub_10002570(v9, v7);
        v12 = (int *)sub_10003570(*(_BYTE *)(v3 + 1), *(_BYTE *)(v1 + 16), v11, 0, v7, (void *)v3);
        if ( !v12 )
          goto LABEL_28;
        while ( 1 )
        {
          v13 = sub_10003570(v19, *(_BYTE *)(v1 + 16), v12, 1, v7, v16);
          v12 = (int *)v13;
          if ( v19 <= 0x100 )
            break;
          v16 = (char *)v16 + 256;
          v7 += 256;
          v19 -= 256;
          if ( !v13 )
          {
            sub_10002EE0((int *)v1, v17, 3, 51);
            return;
          }
        }
        if ( v13 )
        {
          if ( sub_100026F0(v17) )
          {
            v14 = *(_DWORD *)v17;
            v15 = *(_DWORD **)(v17 + 4);
            *(_DWORD *)(v14 + 4) = v15;
            *v15 = v14;
            sub_10003290((int *)v1, v17, (int)v18);
          }
        }
        else
        {
LABEL_28:
          sub_10002EE0((int *)v1, v17, 3, 51);
        }
      }
      else
      {
        sub_10002EE0((int *)v1, v9, -96, 3);
      }
    }
    else
    {
      sub_10002EE0((int *)v1, 0, 3, 51);
    }
  }
  else
  {
    sub_10002320(v1, -127, 0);
  }
}

//----- (10003820) --------------------------------------------------------
char __cdecl sub_10003820(int a1, int a2, char a3, size_t a4, void *a5)
{
  int v5; // eax@1
  size_t v6; // ebx@1
  char result; // al@3

  v5 = *(_BYTE *)(a1 + 1);
  v6 = a4 + 2;
  if ( a4 + 2 > a2 - v5 || v6 > 255 - v5 )
  {
    sub_10042930("..\\lib\\atn\\atn_clnp_enc.c", 537, 0, 0);
    result = 0;
  }
  else
  {
    *(_BYTE *)(v5 + a1 + 1) = a4;
    *(_BYTE *)(v5 + a1) = a3;
    memcpy((void *)(v5 + a1 + 2), a5, a4);
    *(_BYTE *)(a1 + 1) += v6;
    result = v6;
  }
  return result;
}

//----- (10003890) --------------------------------------------------------
char __cdecl sub_10003890(int a1, char a2, char a3)
{
  int v3; // ecx@1

  *(_WORD *)(a1 + 148) |= 2u;
  *(_BYTE *)(a1 + 142) = a2;
  v3 = *(_DWORD *)(a1 + 4);
  *(_BYTE *)(a1 + 143) = a3;
  return sub_10003820(*(_DWORD *)a1, v3, -63, 2u, (void *)(a1 + 142));
}

//----- (100038D0) --------------------------------------------------------
char __cdecl sub_100038D0(int a1, char a2)
{
  char v2; // cl@1
  int v3; // edx@1

  v2 = a2;
  *(_WORD *)(a1 + 148) |= 0x200u;
  v3 = *(_DWORD *)a1;
  *(_BYTE *)(a1 + 16) = v2;
  return sub_10003820(v3, *(_DWORD *)(a1 + 4), -51, 1u, &a2);
}

//----- (10003900) --------------------------------------------------------
char __cdecl sub_10003900(int a1, char a2, void *a3, char a4)
{
  char v4; // bl@2
  int v5; // eax@4
  char v6; // cl@4
  char v8; // [sp+8h] [bp-D0h]@2
  char v9; // [sp+9h] [bp-CFh]@2

  if ( a3 )
  {
    v4 = a4;
    memcpy(&v8, a3, (unsigned __int8)a4);
  }
  else
  {
    v4 = 21 * a2 + 2;
    memset(&v8, 0, (unsigned __int8)v4);
    v8 = 0;
    v9 = 3;
  }
  v5 = *(_DWORD *)a1;
  v6 = *(_BYTE *)(*(_DWORD *)a1 + 1);
  *(_WORD *)(a1 + 148) |= 0x80u;
  *(_BYTE *)(a1 + 19) = v6;
  return sub_10003820(v5, *(_DWORD *)(a1 + 4), -53, (unsigned __int8)v4, &v8);
}

//----- (100039B0) --------------------------------------------------------
char __cdecl sub_100039B0(int a1, char a2)
{
  char v2; // cl@1
  int v3; // ecx@1
  char v4; // dl@1

  v2 = a2 | 0xC0;
  *(_BYTE *)(a1 + 17) = a2 | 0xC0;
  a2 = v2;
  v3 = *(_DWORD *)a1;
  v4 = *(_BYTE *)(*(_DWORD *)a1 + 1);
  *(_WORD *)(a1 + 148) |= 4u;
  *(_BYTE *)(a1 + 18) = v4;
  return sub_10003820(v3, *(_DWORD *)(a1 + 4), -61, 1u, &a2);
}

//----- (100039F0) --------------------------------------------------------
signed __int16 __cdecl sub_100039F0(int a1)
{
  signed __int16 result; // ax@3

  if ( *(_BYTE *)a1 & 1 && *(_BYTE *)a1 & 2 )
    result = *(_WORD *)(a1 + 2);
  else
    result = -256;
  return result;
}

//----- (10003A10) --------------------------------------------------------
int __cdecl sub_10003A10(void *a1, int a2, int a3, char a4)
{
  int result; // eax@1

  memset(a1, 0, 0xA0u);
  result = a2;
  *(_DWORD *)a1 = a2;
  *((_DWORD *)a1 + 1) = a3;
  *((_BYTE *)a1 + 15) = a4;
  *((_BYTE *)a1 + 14) = 1;
  return result;
}

//----- (10003A40) --------------------------------------------------------
bool __cdecl sub_10003A40(int a1)
{
  bool result; // al@2
  int v2; // eax@3

  if ( *(_BYTE *)(a1 + 148) & 0x80 && (v2 = *(_DWORD *)a1 + *(_BYTE *)(a1 + 19), *(_BYTE *)v2 == -53) )
    result = *(_BYTE *)(v2 + 2) == 0;
  else
    result = 0;
  return result;
}

//----- (10003A70) --------------------------------------------------------
bool __cdecl sub_10003A70(int a1, int a2)
{
  char v2; // al@1

  v2 = *(_BYTE *)a1;
  return *(_BYTE *)a1 == *(_BYTE *)a2
      && (!(v2 & 1)
       || (!(v2 & 2) || *(_WORD *)(a1 + 2) == *(_WORD *)(a2 + 2))
       && (!(v2 & 4) || *(_BYTE *)(a1 + 4) == *(_BYTE *)(a2 + 4)));
}

//----- (10003AB0) --------------------------------------------------------
int __usercall sub_10003AB0@<eax>(int a1@<eax>)
{
  int result; // eax@2

  if ( *(_BYTE *)(a1 + 1) == 1 )
    result = *(_BYTE *)(a1 + 2);
  else
    result = (unsigned __int16)(*(_BYTE *)(a1 + 3) + (*(_BYTE *)(a1 + 2) << 8));
  return result;
}

//----- (10003AD0) --------------------------------------------------------
int __usercall sub_10003AD0@<eax>(int result@<eax>, int a2@<ecx>)
{
  if ( *(_BYTE *)(a2 + 1) == 2 )
  {
    *(_WORD *)(result + 132) |= 2u;
    *(_BYTE *)(result + 126) = *(_BYTE *)(a2 + 2);
    *(_BYTE *)(result + 127) = *(_BYTE *)(a2 + 3);
  }
  else
  {
    *(_WORD *)(result + 132) |= 0x400u;
  }
  return result;
}

//----- (10003B00) --------------------------------------------------------
int __usercall sub_10003B00@<eax>(int result@<eax>, int a2@<esi>, char a3)
{
  char v3; // cl@1

  *(_WORD *)(a2 + 132) |= 1u;
  *(_BYTE *)(a2 + 128) = a3;
  v3 = *(_BYTE *)(result + 1);
  if ( v3 == 1 || v3 == 2 )
  {
    result = sub_10003AB0(result);
    *(_WORD *)(a2 + 130) = result;
  }
  else
  {
    *(_WORD *)(a2 + 130) = 128;
  }
  return result;
}

//----- (10003B40) --------------------------------------------------------
char __usercall sub_10003B40@<al>(int a1@<eax>, int a2@<ecx>)
{
  char result; // al@2
  unsigned __int8 v3; // cl@3

  if ( *(_BYTE *)(a2 + 1) == 1 )
  {
    v3 = *(_BYTE *)(a2 + 2);
    if ( v3 <= 0xEu )
    {
      *(_WORD *)(a1 + 132) |= 0x200u;
      *(_BYTE *)a1 = v3;
      result = 0;
    }
    else
    {
      *(_WORD *)(a1 + 132) |= 0x400u;
      result = 16;
    }
  }
  else
  {
    *(_WORD *)(a1 + 132) |= 0x400u;
    result = -80;
  }
  return result;
}

//----- (10003B80) --------------------------------------------------------
char __usercall sub_10003B80@<al>(int a1@<eax>, int a2@<ecx>, char a3)
{
  char result; // al@2
  char v4; // cl@3

  if ( *(_BYTE *)(a2 + 1) == 1 )
  {
    v4 = *(_BYTE *)(a2 + 2);
    if ( (v4 & 0xC0) == -64 )
    {
      *(_WORD *)(a1 + 132) |= 4u;
      *(_BYTE *)(a1 + 1) = v4;
      *(_BYTE *)(a1 + 2) = a3 + 2;
      result = 0;
    }
    else
    {
      *(_WORD *)(a1 + 132) |= 0x400u;
      result = 0;
    }
  }
  else
  {
    *(_WORD *)(a1 + 132) |= 0x400u;
    result = -75;
  }
  return result;
}

//----- (10003BD0) --------------------------------------------------------
char __usercall sub_10003BD0@<al>(int a1@<edi>, int a2@<esi>, char a3)
{
  unsigned __int8 v3; // al@1
  unsigned __int8 v4; // cl@3
  char v5; // bl@5
  unsigned __int8 v6; // ST12_1@6
  unsigned __int8 v7; // bl@6
  unsigned __int8 v9; // [sp+1h] [bp-3h]@1
  unsigned __int8 v10; // [sp+3h] [bp-1h]@5

  v3 = *(_BYTE *)(a2 + 1);
  v9 = 0;
  if ( v3 < 2u )
  {
    *(_WORD *)(a1 + 132) |= 0x400u;
    return -76;
  }
  if ( *(_BYTE *)(a2 + 2) )
    return -76;
  v4 = *(_BYTE *)(a2 + 3);
  if ( v4 < 3u || v4 - 1 > v3 )
    return -76;
  v5 = 2;
  v10 = v4 - 1;
  if ( (unsigned __int8)(v4 - 1) > 2u )
  {
    do
    {
      v6 = *(_BYTE *)((unsigned __int8)v5 + a2 + 2);
      v7 = v5 + 1;
      memcpy((void *)(a1 + 20 * v9 + 4), (const void *)(v7 + a2 + 2), v6);
      v5 = v6 + v7;
      ++v9;
    }
    while ( (unsigned __int8)v5 < v10 );
  }
  *(_WORD *)(a1 + 132) |= 0x80u;
  *(_BYTE *)(a1 + 124) = v9;
  *(_BYTE *)(a1 + 3) = a3;
  return 0;
}

//----- (10003C80) --------------------------------------------------------
char __usercall sub_10003C80@<al>(int a1@<edi>, int a2)
{
  int v2; // esi@1
  unsigned __int8 v3; // al@1
  int v5; // ebp@3
  unsigned int v6; // eax@5
  int *v7; // ecx@6
  _DWORD *v8; // edx@6
  int v9; // esi@10
  int v10; // eax@11
  _BYTE *v11; // ecx@11
  _BYTE *v12; // edx@11
  int v13; // eax@13
  _BYTE *v14; // ecx@13
  _BYTE *v15; // edx@13
  _BYTE *v16; // ecx@15
  _BYTE *v17; // edx@15
  unsigned int v18; // ecx@17
  bool v19; // zf@17
  bool v20; // sf@17
  signed int v21; // eax@17
  char v22; // al@26
  int v23; // [sp+4h] [bp-4h]@3

  v2 = a2;
  *(_DWORD *)(a1 + 134) = 0;
  *(_WORD *)(a1 + 138) = 0;
  v3 = *(_BYTE *)(a2 + 1);
  if ( v3 < 9u )
  {
    *(_WORD *)(a1 + 132) |= 0x400u;
    return -78;
  }
  v23 = v3 - 9;
  v5 = a2 + 11;
  if ( (*(_BYTE *)(a2 + 2) & 0xC0) != -64 )
  {
    *(_WORD *)(a1 + 132) |= 0x400u;
    return -78;
  }
  v6 = 6;
  if ( *(_BYTE *)(a2 + 3) != 6 )
    goto LABEL_33;
  v7 = &dword_1009452C;
  v8 = (_DWORD *)(a2 + 4);
  do
  {
    if ( *v8 != *v7 )
      goto LABEL_10;
    v6 -= 4;
    ++v7;
    ++v8;
  }
  while ( v6 >= 4 );
  if ( !v6 )
  {
LABEL_20:
    v18 = v23;
    v21 = 0;
    goto LABEL_21;
  }
LABEL_10:
  v9 = *(_BYTE *)v8 - *(_BYTE *)v7;
  if ( *(_BYTE *)v8 == *(_BYTE *)v7 )
  {
    v10 = v6 - 1;
    v11 = (char *)v7 + 1;
    v12 = (char *)v8 + 1;
    if ( !v10
      || (v9 = *v12 - *v11, *v12 == *v11)
      && ((v13 = v10 - 1, v14 = v11 + 1, v15 = v12 + 1, !v13)
       || (v9 = *v15 - *v14, *v15 == *v14)
       && ((v16 = v14 + 1, v17 = v15 + 1, v13 == 1) || (v9 = *v17 - *v16, *v17 == *v16))) )
    {
      v2 = a2;
      goto LABEL_20;
    }
  }
  v18 = v23;
  v19 = v9 == 0;
  v20 = v9 < 0;
  v2 = a2;
  v21 = 1;
  if ( v20 || v19 )
    v21 = -1;
LABEL_21:
  if ( !v21 && *(_BYTE *)(v2 + 10) <= v18 )
  {
    if ( v18 < 4 )
    {
LABEL_31:
      if ( !v18 )
      {
        *(_WORD *)(a1 + 132) |= 0x10u;
        *(_BYTE *)(a1 + 134) |= 1u;
        return 0;
      }
    }
    else
    {
      while ( *(_BYTE *)v5 == 1 && *(_BYTE *)(v5 + 2) == 1 )
      {
        v22 = *(_BYTE *)(v5 + 1);
        if ( v22 == 3 )
        {
          *(_BYTE *)(a1 + 134) |= 4u;
          *(_BYTE *)(a1 + 138) = *(_BYTE *)(v5 + 3);
        }
        else
        {
          if ( v22 != 15 )
            break;
          *(_BYTE *)(a1 + 134) |= 2u;
          *(_WORD *)(a1 + 136) = *(_BYTE *)(v5 + 3);
        }
        v18 -= 4;
        v5 += 4;
        if ( v18 < 4 )
          goto LABEL_31;
      }
    }
  }
LABEL_33:
  *(_WORD *)(a1 + 132) |= 0x400u;
  return -78;
}
// 1009452C: using guessed type int dword_1009452C;

//----- (10003E00) --------------------------------------------------------
char __usercall sub_10003E00@<al>(int a1@<eax>, int a2@<ecx>, char a3)
{
  unsigned __int8 v3; // al@3

  if ( *(_BYTE *)(a2 + 1) < 2u )
  {
    *(_WORD *)(a1 + 132) |= 0x400u;
  }
  else
  {
    *(_WORD *)(a1 + 132) |= 0x40u;
    *(_BYTE *)(a1 + 125) = a3;
    if ( !*(_BYTE *)(a2 + 2) )
    {
      v3 = *(_BYTE *)(a2 + 3);
      if ( v3 >= 3u && v3 - 1 <= *(_BYTE *)(a2 + 1) )
        return 0;
    }
  }
  return -77;
}

//----- (10003E40) --------------------------------------------------------
int __usercall sub_10003E40@<eax>(int a1@<eax>)
{
  int result; // eax@1

  result = a1 + (a1 < 0 ? 0xFF : 0);
  if ( !result )
    result = 255;
  return result;
}

//----- (10003E60) --------------------------------------------------------
int __usercall sub_10003E60@<eax>(int a1@<edi>)
{
  int v1; // eax@1
  int v2; // ecx@1
  int v3; // ebx@1
  unsigned int v4; // esi@1
  int v5; // edx@2
  int v6; // ecx@3
  int result; // eax@3

  v1 = *(_BYTE *)(a1 + 1);
  v2 = 0;
  v3 = 0;
  v4 = 0;
  *(_BYTE *)(a1 + 7) = 0;
  *(_BYTE *)(a1 + 8) = 0;
  if ( v1 )
  {
    do
    {
      v5 = (v2 + *(_BYTE *)(v4++ + a1)) % 255;
      v2 = v5;
      v3 = (v3 + v5) % 255;
    }
    while ( v4 < *(_BYTE *)(a1 + 1) );
  }
  *(_BYTE *)(a1 + 7) = sub_10003E40((v2 * (*(_BYTE *)(a1 + 1) - 8) - v3) % 255);
  result = sub_10003E40((v3 - v6 * (*(_BYTE *)(a1 + 1) - 7)) % 255);
  *(_BYTE *)(a1 + 8) = result;
  return result;
}

//----- (10003F10) --------------------------------------------------------
char __usercall sub_10003F10@<al>(int a1@<eax>)
{
  int v1; // edi@1
  char result; // al@3
  int v3; // esi@6
  unsigned __int8 v4; // bl@6
  int v5; // ecx@7
  unsigned __int8 v6; // dl@8

  v1 = *(_DWORD *)a1;
  if ( *(_BYTE *)(*(_DWORD *)a1 + 7) || *(_BYTE *)(v1 + 8) )
  {
    *(_BYTE *)(a1 + 14) = 1;
    if ( *(_BYTE *)(v1 + 7) && *(_BYTE *)(v1 + 8) )
    {
      v3 = *(_BYTE *)(v1 + 1);
      v4 = 0;
      if ( !*(_BYTE *)(v1 + 1) )
        goto LABEL_16;
      v5 = 0;
      do
      {
        v6 = (v5 + *(_BYTE *)v1) % 255;
        --v3;
        ++v1;
        v5 = v6;
        v4 = (v6 + v4) % 255;
      }
      while ( v3 );
      if ( v6 || v4 )
        result = 0;
      else
LABEL_16:
        result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 14) = 0;
    result = 1;
  }
  return result;
}

//----- (10003FA0) --------------------------------------------------------
int __cdecl sub_10003FA0(int a1, int a2, __int16 a3)
{
  int result; // eax@1
  int v4; // ecx@1
  __int16 v5; // dx@1

  result = a1;
  *(_DWORD *)(a1 + 8) = a2;
  v4 = *(_DWORD *)a1;
  *(_WORD *)(a1 + 12) = a3;
  v5 = a3 + *(_BYTE *)(v4 + 1);
  *(_BYTE *)(v4 + 5) = HIBYTE(v5);
  *(_BYTE *)(v4 + 6) = v5;
  if ( *(_BYTE *)(a1 + 14) )
    result = sub_10003E60(*(_DWORD *)a1);
  return result;
}

//----- (10003FE0) --------------------------------------------------------
char __cdecl sub_10003FE0(int a1, unsigned int a2, int a3, _DWORD *a4)
{
  unsigned int v4; // eax@1
  char result; // al@4

  v4 = *(_BYTE *)(a1 + 1);
  if ( v4 > *(_DWORD *)(a3 + 4) || v4 > a2 )
  {
    *a4 = 1;
    result = 4;
  }
  else if ( sub_10003F10(a3) )
  {
    if ( *(_BYTE *)a1 == -127 )
    {
      if ( *(_BYTE *)(a1 + 2) == 1 )
      {
        if ( *(_BYTE *)(a1 + 9) == 20 )
        {
          if ( *(_BYTE *)(a1 + 30) == 20 )
          {
            if ( sub_100024B0((_DWORD *)(a1 + 10)) )
              *(_BYTE *)(a3 + 15) = 1;
            result = 0;
          }
          else
          {
            *a4 = 30;
            result = 4;
          }
        }
        else
        {
          *a4 = 9;
          result = -127;
        }
      }
      else
      {
        *a4 = 2;
        result = -79;
      }
    }
    else
    {
      *a4 = 0;
      result = -79;
    }
  }
  else
  {
    *a4 = 7;
    result = 2;
  }
  return result;
}

//----- (100040A0) --------------------------------------------------------
int __cdecl sub_100040A0(int a1)
{
  unsigned int v1; // edx@1
  int result; // eax@2
  unsigned int v3; // eax@1

  v3 = (unsigned __int8)((*(_BYTE *)(a1 + 4) & 0x80) != 0 ? 57 : 51);
  v1 = *(_BYTE *)(a1 + 1);
  if ( v3 < v1 )
    result = v1 >= *(_BYTE *)(v3 + a1 + 1) + v3 + 2 ? v3 + a1 : 0;
  else
    result = 0;
  return result;
}

//----- (100040C0) --------------------------------------------------------
void __cdecl sub_100040C0(int a1, int a2)
{
  int v2; // edx@1

  v2 = *(_BYTE *)(a2 + 1);
  JUMPOUT(&loc_10003EF0);
}

//----- (100040E0) --------------------------------------------------------
int __cdecl sub_100040E0(int a1, char a2, int a3, int a4, __int16 a5, __int16 a6)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)(a1 + 4) = a2;
  *(_BYTE *)a1 = -127;
  *(_BYTE *)(a1 + 2) = 1;
  *(_BYTE *)(a1 + 3) = -1;
  *(_BYTE *)(a1 + 1) = (a2 & 0x80) != 0 ? 57 : 51;
  *(_BYTE *)(a1 + 5) = 0;
  *(_BYTE *)(a1 + 6) = 0;
  *(_BYTE *)(a1 + 7) = 0;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 9) = 20;
  *(_DWORD *)(a1 + 10) = *(_DWORD *)a3;
  *(_DWORD *)(a1 + 14) = *(_DWORD *)(a3 + 4);
  *(_DWORD *)(a1 + 18) = *(_DWORD *)(a3 + 8);
  *(_DWORD *)(a1 + 22) = *(_DWORD *)(a3 + 12);
  *(_DWORD *)(a1 + 26) = *(_DWORD *)(a3 + 16);
  *(_BYTE *)(a1 + 30) = 20;
  *(_DWORD *)(a1 + 31) = *(_DWORD *)a4;
  *(_DWORD *)(a1 + 35) = *(_DWORD *)(a4 + 4);
  *(_DWORD *)(a1 + 39) = *(_DWORD *)(a4 + 8);
  *(_DWORD *)(a1 + 43) = *(_DWORD *)(a4 + 12);
  *(_DWORD *)(a1 + 47) = *(_DWORD *)(a4 + 16);
  if ( a2 & 0x80 )
  {
    *(_BYTE *)(a1 + 51) = HIBYTE(a5);
    *(_BYTE *)(a1 + 52) = a5;
    *(_BYTE *)(a1 + 53) = HIBYTE(a6);
    *(_BYTE *)(a1 + 54) = a6;
    *(_BYTE *)(a1 + 55) = 0;
    *(_BYTE *)(a1 + 56) = 0;
  }
  return result;
}

//----- (10004190) --------------------------------------------------------
char __usercall sub_10004190@<al>(int a1@<ecx>, int a2@<esi>)
{
  char v2; // dl@1
  signed int v3; // eax@1
  char v4; // cl@5
  int v5; // ecx@6
  int v6; // ST04_4@6
  char v8; // [sp+4h] [bp-18h]@6
  char v9; // [sp+5h] [bp-17h]@6
  int v10; // [sp+6h] [bp-16h]@6
  __int16 v11; // [sp+Ah] [bp-12h]@6
  char v12; // [sp+Ch] [bp-10h]@6
  char v13; // [sp+Dh] [bp-Fh]@3
  char v14; // [sp+Eh] [bp-Eh]@3
  char v15; // [sp+Fh] [bp-Dh]@3
  char v16[8]; // [sp+10h] [bp-Ch]@3

  v2 = *(_BYTE *)a1;
  v3 = 0;
  if ( *(_BYTE *)a1 & 2 && *(_WORD *)(a1 + 2) <= 0xFFu )
  {
    v16[0] = *(_BYTE *)(a1 + 2);
    v13 = 1;
    v14 = 15;
    v15 = 1;
    v3 = 1;
  }
  if ( v2 & 4 )
  {
    v4 = *(_BYTE *)(a1 + 4);
    *(&v13 + 4 * v3) = 1;
    *(&v14 + 4 * v3) = 3;
    *(&v15 + 4 * v3) = 1;
    v16[4 * v3++] = v4;
  }
  v10 = 455803910;
  v11 = 0;
  v5 = *(_DWORD *)a2;
  v12 = 4 * v3;
  v6 = *(_DWORD *)(a2 + 4);
  v8 = -64;
  v9 = 6;
  return sub_10003820(v5, v6, -59, 4 * v3 + 9, &v8);
}
// 1009452C: using guessed type int dword_1009452C;
// 10004190: using guessed type char var_C[8];

//----- (10004240) --------------------------------------------------------
char __cdecl sub_10004240(int a1, int a2)
{
  int v2; // esi@1

  v2 = a1;
  *(_WORD *)(v2 + 148) |= 0x10u;
  *(_DWORD *)(a1 + 150) = *(_DWORD *)a2;
  *(_WORD *)(a1 + 154) = *(_WORD *)(a2 + 4);
  *(_BYTE *)(v2 + 150) |= 1u;
  return sub_10004190(a2, a1);
}

//----- (10004280) --------------------------------------------------------
char __cdecl sub_10004280(int a1, int *a2)
{
  int v2; // edi@1
  int v3; // esi@1
  _BYTE *v4; // ebp@1
  int v5; // ebx@1
  char result; // al@5
  _BYTE *v7; // eax@7
  int v8; // edi@8
  unsigned __int8 v9; // dl@8
  char v10; // cl@14
  char v11; // [sp+13h] [bp-1h]@1

  v2 = a1 + 16;
  memset((void *)(a1 + 16), 0, 0x8Cu);
  v3 = *(_DWORD *)a1;
  v11 = 0;
  v4 = (_BYTE *)sub_100040A0(*(_DWORD *)a1);
  v5 = 0;
  if ( v4 )
  {
    while ( 1 )
    {
      v5 = (int)&v4[-v3];
      switch ( *v4 )
      {
        case 5:
          sub_10003B00((int)v4, v2, (_BYTE)v4 - v3);
          goto LABEL_7;
        case 0xC1:
          sub_10003AD0(v2, (int)v4);
          goto LABEL_7;
        case 0xC3:
          result = sub_10003B80(v2, (int)v4, (_BYTE)v4 - v3);
          goto LABEL_6;
        case 0xC4:
          *(_WORD *)(a1 + 148) |= 8u;
          goto LABEL_7;
        case 0xC5:
          result = sub_10003C80(v2, (int)v4);
          goto LABEL_6;
        case 0xC6:
          *(_WORD *)(a1 + 148) |= 0x20u;
          goto LABEL_7;
        case 0xC8:
          result = sub_10003E00(v2, (int)v4, (_BYTE)v4 - v3);
          goto LABEL_6;
        case 0xCB:
          result = sub_10003BD0(v2, (int)v4, (_BYTE)v4 - v3);
          goto LABEL_6;
        case 0xCC:
          *(_WORD *)(a1 + 148) |= 0x100u;
          goto LABEL_7;
        case 0xCD:
          result = sub_10003B40(v2, (int)v4);
LABEL_6:
          if ( !result )
            goto LABEL_7;
          v8 = a1;
          *a2 = v5;
          goto LABEL_14;
        default:
          *(_WORD *)(a1 + 148) |= 0x400u;
LABEL_7:
          v3 = *(_DWORD *)a1;
          sub_100040C0(*(_DWORD *)a1, (int)v4);
          v4 = v7;
          if ( !v7 )
            goto LABEL_8;
          break;
      }
    }
  }
LABEL_8:
  v8 = a1;
  v9 = *(_BYTE *)(*(_DWORD *)a1 + 1);
  if ( ((*(_BYTE *)(*(_DWORD *)a1 + 4) & 0x80) != 0 ? 57 : 51) != v9 )
  {
    if ( !v5 )
      v5 = (unsigned __int8)((*(_BYTE *)(*(_DWORD *)a1 + 4) & 0x80) != 0 ? 57 : 51);
    if ( *(_BYTE *)(*(_DWORD *)a1 + v5 + 1) + v5 + 2 != v9 )
    {
      v11 = 4;
      *a2 = v5;
    }
  }
  result = v11;
LABEL_14:
  v10 = *(_BYTE *)(v8 + 150);
  if ( !(v10 & 2) )
    *(_WORD *)(v8 + 152) = -256;
  if ( !(v10 & 1) || !(v10 & 4) )
    *(_BYTE *)(v8 + 154) = 1;
  return result;
}

//----- (10004520) --------------------------------------------------------
char __cdecl sub_10004520(int a1, int a2, void *a3, int a4)
{
  char result; // al@1
  unsigned __int16 v5; // ax@2

  sub_10003A10(a3, a1, a2, 0);
  result = sub_10003FE0(a1, a2, (int)a3, (_DWORD *)a4);
  if ( !result )
  {
    *((_DWORD *)a3 + 2) = a1 + *(_BYTE *)(a1 + 1);
    v5 = a2 - *(_BYTE *)(a1 + 1);
    *((_WORD *)a3 + 6) = v5;
    if ( v5 == (unsigned __int16)(*(_BYTE *)(a1 + 6) + (*(_BYTE *)(a1 + 5) << 8)) - *(_BYTE *)(a1 + 1) )
    {
      result = sub_10004280((int)a3, (int *)a4);
    }
    else
    {
      *(_DWORD *)a4 = 5;
      result = 6;
    }
  }
  return result;
}

//----- (100045B0) --------------------------------------------------------
char __cdecl sub_100045B0(int a1)
{
  char result; // al@2

  if ( !a1 )
    return 0;
  sub_1000B3F0(a1 + 40);
  *(_BYTE *)a1 = -1;
  if ( (_BYTE)dword_101C3A20 )
  {
    result = 1;
    *(_BYTE *)a1 = (byte_101C3A29 == 1) + 3;
    return result;
  }
  result = BYTE1(dword_101C3A20);
  if ( !BYTE1(dword_101C3A20) )
  {
    if ( !*(_BYTE *)(a1 + 48) )
    {
      *(_BYTE *)a1 = 0;
      return 1;
    }
LABEL_11:
    *(_BYTE *)a1 = 2;
    return 1;
  }
  if ( BYTE1(dword_101C3A20) == 1 )
  {
    *(_BYTE *)a1 = 1;
    return result;
  }
  if ( BYTE1(dword_101C3A20) == 3 )
    goto LABEL_11;
  if ( BYTE1(dword_101C3A20) == 2 || BYTE1(dword_101C3A20) == 4 )
    *(_BYTE *)a1 = 4;
  return 1;
}
// 101C3A20: using guessed type int dword_101C3A20;
// 101C3A29: using guessed type char byte_101C3A29;

//----- (10004620) --------------------------------------------------------
int __cdecl sub_10004620(int a1)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)(a1 + 5) = 0;
  *(_DWORD *)a1 = 0;
  *(_BYTE *)(a1 + 4) = 0;
  return result;
}

//----- (10004630) --------------------------------------------------------
signed int __usercall sub_10004630@<eax>(int a1@<eax>)
{
  byte_101C19D0 = 2;
  dword_101C19D4 = a1;
  return sub_10005750((int)&byte_101C19D0);
}
// 101C19D0: using guessed type char byte_101C19D0;
// 101C19D4: using guessed type int dword_101C19D4;

//----- (10004650) --------------------------------------------------------
signed int __usercall sub_10004650@<eax>(int a1@<eax>)
{
  byte_101C19D0 = 3;
  dword_101C19D4 = a1;
  return sub_10005750((int)&byte_101C19D0);
}
// 101C19D0: using guessed type char byte_101C19D0;
// 101C19D4: using guessed type int dword_101C19D4;

//----- (10004670) --------------------------------------------------------
char __usercall sub_10004670@<al>(unsigned int a1@<edi>, int a2@<esi>)
{
  char result; // al@2
  unsigned __int8 v3; // ah@3
  int v4; // ecx@3
  char v5; // al@3
  int v6; // [sp+0h] [bp-8h]@3
  char v7; // [sp+4h] [bp-4h]@3
  char v8; // [sp+6h] [bp-2h]@3

  if ( a1 == -1 )
  {
    result = 0;
    *(_DWORD *)a2 = 0;
    *(_DWORD *)(a2 + 4) = 0;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 12) = 0;
  }
  else
  {
    sub_10042A60((int)&v6, a1);
    sub_10042C40((int)&v7, a1);
    v3 = BYTE1(v6);
    v4 = (unsigned __int8)v6;
    v5 = v7;
    *(_DWORD *)a2 = HIWORD(v6);
    *(_DWORD *)(a2 + 4) = v4;
    LOBYTE(v4) = v8;
    *(_BYTE *)(a2 + 12) = v5;
    *(_DWORD *)(a2 + 8) = v3;
    *(_BYTE *)(a2 + 13) = v4;
    result = 1;
  }
  return result;
}

//----- (100046D0) --------------------------------------------------------
char __usercall sub_100046D0@<al>(char a1@<bl>, int a2@<esi>, int *a3, char a4)
{
  int *v4; // eax@2
  char *v5; // edx@2
  char v6; // cl@3
  char v7; // cl@6
  char result; // al@11
  char v9; // [sp+4h] [bp-64h]@8
  int v10; // [sp+8h] [bp-60h]@1
  char v11; // [sp+Ch] [bp-5Ch]@1
  char v12; // [sp+Dh] [bp-5Bh]@7
  int v13; // [sp+Eh] [bp-5Ah]@2
  int v14; // [sp+12h] [bp-56h]@2
  char v15; // [sp+16h] [bp-52h]@2
  char v16; // [sp+18h] [bp-50h]@1
  int v17; // [sp+19h] [bp-4Fh]@5
  int v18; // [sp+1Dh] [bp-4Bh]@5
  char v19; // [sp+21h] [bp-47h]@5
  int v20; // [sp+22h] [bp-46h]@2
  int v21; // [sp+26h] [bp-42h]@2
  char v22; // [sp+2Ah] [bp-3Eh]@2

  sub_10005A90((int)&v16);
  v11 = a1;
  v10 = 0;
  if ( a3 == &dword_101C3A24 )
  {
    v15 = v22;
    v4 = &v20;
    v14 = v21;
    v13 = v20;
    v5 = (char *)&v20 + 1;
    do
    {
      v6 = *(_BYTE *)v4;
      v4 = (int *)((char *)v4 + 1);
    }
    while ( v6 );
  }
  else
  {
    v15 = v19;
    v4 = &v17;
    v14 = v18;
    v13 = v17;
    v5 = (char *)&v17 + 1;
    do
    {
      v7 = *(_BYTE *)v4;
      v4 = (int *)((char *)v4 + 1);
    }
    while ( v7 );
  }
  v12 = (_BYTE)v4 - (_BYTE)v5;
  if ( (unsigned __int8)a1 < 0x1Bu || (v9 = 3, (unsigned __int8)a1 > 0x1Cu) )
    v9 = 2;
  if ( a2 )
    result = sub_1002F000(2, a4, v9, (int)&v10, *(void **)a2, (unsigned int)(*(_DWORD *)(a2 + 4) + 7) >> 3);
  else
    result = sub_1002F000(0, a4, v9, (int)&v10, 0, 0);
  return result;
}
// 101C3A24: using guessed type int dword_101C3A24;

//----- (100047C0) --------------------------------------------------------
int *__thiscall sub_100047C0(void *this)
{
  unsigned __int8 v1; // al@2
  int *result; // eax@5

  if ( this )
  {
    v1 = 0;
    while ( (void *)dword_101C3A1C[2 * v1] != this )
    {
      if ( ++v1 >= 2u )
        goto LABEL_5;
    }
    result = &dword_101C3A1C[2 * v1];
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}
// 101C3A1C: using guessed type int dword_101C3A1C[];

//----- (100047F0) --------------------------------------------------------
int __usercall sub_100047F0@<eax>(int a1@<eax>, int *a2@<edi>)
{
  int v2; // esi@1
  int result; // eax@2

  v2 = sub_10004650(a1);
  if ( v2 )
  {
    sub_100103C0(dword_101C19A8, *a2, 1, v2);
    *a2 = 0;
    sub_100046D0(28, v2, a2, 1);
    result = v2;
  }
  else
  {
    sub_10042450(13, 12, 0, 0);
    sub_100103C0(dword_101C19A8, *a2, 1, 0);
    result = 0;
  }
  return result;
}
// 101C19A8: using guessed type int dword_101C19A8;

//----- (10004850) --------------------------------------------------------
int __usercall sub_10004850@<eax>(int a1@<esi>)
{
  int result; // eax@1
  char v2; // [sp+0h] [bp-18h]@1

  *(_WORD *)a1 = 1;
  *(_DWORD *)(a1 + 4) = 22;
  *(_DWORD *)(a1 + 8) = 1;
  result = sub_1000A670((int)&v2);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)result;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(result + 4);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(result + 8);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(result + 12);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(result + 16);
  *(_WORD *)(a1 + 32) = *(_WORD *)(result + 20);
  return result;
}

//----- (100048A0) --------------------------------------------------------
int __usercall sub_100048A0@<eax>(int a1@<esi>)
{
  int result; // eax@1

  result = sub_1007C040();
  *(_DWORD *)a1 = result;
  *(_BYTE *)(a1 + 8) = 1;
  return result;
}

//----- (100048B0) --------------------------------------------------------
int __usercall sub_100048B0@<eax>(int result@<eax>)
{
  *(_BYTE *)(result + 8) = 0;
  return result;
}

//----- (100048C0) --------------------------------------------------------
void __cdecl sub_100048C0(int a1)
{
  int v1; // eax@1

  v1 = sub_10004630(a1);
  if ( v1 )
  {
    if ( BYTE1(dword_101C3A20) == 2 )
    {
      byte_101C19A4 = 0;
      sub_100104D0(dword_101C19A8, dword_101C3A1C[0], 2, v1);
      BYTE1(dword_101C3A20) = 0;
    }
    else if ( BYTE1(dword_101C3A20) == 4 )
    {
      sub_100103F0(dword_101C19A8, dword_101C3A1C[0], v1);
      BYTE1(dword_101C3A20) = 3;
    }
  }
  else
  {
    sub_10042450(13, 12, 0, 0);
  }
}
// 101C19A4: using guessed type char byte_101C19A4;
// 101C19A8: using guessed type int dword_101C19A8;
// 101C3A1C: using guessed type int dword_101C3A1C[];
// 101C3A20: using guessed type int dword_101C3A20;

//----- (10004940) --------------------------------------------------------
char sub_10004940()
{
  char result; // al@1
  int *v1; // edi@1
  signed int v2; // ebp@1
  int v3; // eax@3

  result = sub_10042450(13, 1, 0, 0);
  v1 = dword_101C3A1C;
  v2 = 2;
  do
  {
    if ( *((_BYTE *)v1 + 5) == 1 )
    {
      v3 = sub_100047F0(0, v1);
      sub_100046D0(25, v3, v1, 1);
      sub_10005FC0(0, byte_101C19A4);
      result = sub_100048B0((int)&unk_101C19AC);
      *((_BYTE *)v1 + 4) = 1;
      *((_BYTE *)v1 + 5) = 0;
    }
    v1 += 2;
    --v2;
  }
  while ( v2 );
  return result;
}
// 101C19A4: using guessed type char byte_101C19A4;
// 101C3A1C: using guessed type int dword_101C3A1C[];

//----- (100049B0) --------------------------------------------------------
char sub_100049B0()
{
  LOBYTE(dword_101C3A20) = 1;
  return sub_100046D0(25, 0, dword_101C3A1C, 1);
}
// 101C3A1C: using guessed type int dword_101C3A1C[];
// 101C3A20: using guessed type int dword_101C3A20;

//----- (100049D0) --------------------------------------------------------
signed int __usercall sub_100049D0@<eax>(int a1@<eax>)
{
  int v1; // edi@1

  v1 = a1;
  byte_101C19D0 = 1;
  dword_101C19D4 = *(_DWORD *)a1;
  dword_101C19D8 = *(_DWORD *)(a1 + 4);
  byte_101C19DC = *(_BYTE *)(a1 + 8);
  dword_101C19DE = dword_101C19B8;
  dword_101C19E2 = dword_101C19BC;
  dword_101C19E6 = dword_101C19C0;
  dword_101C19EA = dword_101C19C4;
  dword_101C19EE = dword_101C19C8;
  word_101C19F2 = word_101C19CC;
  byte_101C39F8 = 1;
  sub_10004850((int)&unk_101C19F4);
  sub_1002F4D0((int)&unk_101C39FC, v1 + 40);
  sub_1002F4D0((int)&unk_101C3A02, v1 + 45);
  byte_101C3A18 = sub_10004670(*(_DWORD *)(v1 + 52), (int)&unk_101C3A08);
  return sub_10005750((int)&byte_101C19D0);
}
// 101C19B8: using guessed type int dword_101C19B8;
// 101C19BC: using guessed type int dword_101C19BC;
// 101C19C0: using guessed type int dword_101C19C0;
// 101C19C4: using guessed type int dword_101C19C4;
// 101C19C8: using guessed type int dword_101C19C8;
// 101C19CC: using guessed type __int16 word_101C19CC;
// 101C19D0: using guessed type char byte_101C19D0;
// 101C19D4: using guessed type int dword_101C19D4;
// 101C19D8: using guessed type int dword_101C19D8;
// 101C19DC: using guessed type char byte_101C19DC;
// 101C19DE: using guessed type int dword_101C19DE;
// 101C19E2: using guessed type int dword_101C19E2;
// 101C19E6: using guessed type int dword_101C19E6;
// 101C19EA: using guessed type int dword_101C19EA;
// 101C19EE: using guessed type int dword_101C19EE;
// 101C19F2: using guessed type __int16 word_101C19F2;
// 101C39F8: using guessed type char byte_101C39F8;
// 101C3A18: using guessed type char byte_101C3A18;

//----- (10004A90) --------------------------------------------------------
void __usercall sub_10004A90(int a1@<esi>)
{
  if ( *(_BYTE *)(a1 + 8) )
  {
    if ( (unsigned int)(sub_1007C040() - *(_DWORD *)a1) >= *(_DWORD *)(a1 + 4) )
      sub_10004940();
  }
}

//----- (10004AB0) --------------------------------------------------------
char __usercall sub_10004AB0@<al>(char a1@<al>, int a2@<ecx>, int a3@<edi>)
{
  int v3; // esi@1
  char result; // al@1

  v3 = a2;
  sub_100103C0(dword_101C19A8, *(_DWORD *)a3, a1, a2);
  result = sub_100046D0(28, v3, (int *)a3, 1);
  *(_BYTE *)(a3 + 5) = 0;
  return result;
}
// 101C19A8: using guessed type int dword_101C19A8;

//----- (10004BA0) --------------------------------------------------------
int __usercall sub_10004BA0@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  int result; // eax@1

  v1 = a1;
  sub_10042450(13, 6, 0, 0);
  *(_BYTE *)(v1 + 4) = 6;
  sub_100048B0((int)&unk_101C19AC);
  byte_101C19A4 = 0;
  result = sub_100047F0(8, (int *)v1);
  *(_BYTE *)(v1 + 5) = 0;
  return result;
}
// 101C19A4: using guessed type char byte_101C19A4;

//----- (10004BE0) --------------------------------------------------------
void __usercall sub_10004BE0(int a1@<eax>, char a2@<bl>)
{
  int v2; // edi@1

  v2 = a1;
  sub_10042450(13, 3, 0, 0);
  *(_BYTE *)(v2 + 4) = 3;
  if ( !a2 || a2 == 3 )
  {
    byte_101C19A4 = 0;
    sub_100047F0(2, (int *)v2);
    if ( BYTE1(dword_101C3A20) || byte_101C19A4 )
      sub_10005FC0(2, byte_101C19A4);
  }
  if ( a2 == 2 || a2 == 1 )
  {
    sub_100048B0((int)&unk_101C19AC);
    if ( a2 == 1 )
      sub_100047F0(2, (int *)v2);
    if ( BYTE1(dword_101C3A20) || byte_101C19A4 )
      sub_10005FC0(2, byte_101C19A4);
  }
  *(_BYTE *)(v2 + 5) = 0;
}
// 101C19A4: using guessed type char byte_101C19A4;
// 101C3A20: using guessed type int dword_101C3A20;

//----- (10004CA0) --------------------------------------------------------
void __usercall sub_10004CA0(char a1@<al>, int a2@<ecx>)
{
  bool v2; // bl@1
  int v3; // edi@1
  char v4; // al@1
  bool v5; // [sp+8h] [bp-4h]@1
  bool v6; // [sp+9h] [bp-3h]@1
  bool v7; // [sp+Ah] [bp-2h]@1
  bool v8; // [sp+Bh] [bp-1h]@1

  v8 = a1 == 8;
  v2 = a1 == 0;
  v6 = a1 == 1;
  v7 = a1 == 2;
  v3 = a2;
  v5 = a1 == 3;
  sub_10042450(13, 2, 0, 0);
  v4 = *(_BYTE *)(v3 + 5);
  *(_BYTE *)(v3 + 4) = 7;
  if ( v4 == 2 || v4 == 4 )
    byte_101C19A4 = 0;
  else
    sub_100048B0((int)&unk_101C19AC);
  if ( v2 || v5 || v6 )
  {
    sub_100047F0(9, (int *)v3);
    sub_10005FC0(9, byte_101C19A4);
  }
  if ( v7 || v8 )
    sub_10005FC0(9, byte_101C19A4);
  *(_BYTE *)(v3 + 5) = 0;
}
// 101C19A4: using guessed type char byte_101C19A4;

//----- (10004D50) --------------------------------------------------------
void __usercall sub_10004D50(char a1@<al>, int a2@<ecx>)
{
  bool v2; // dl@1
  bool v3; // bl@1
  int v4; // edi@1
  bool v5; // cl@1
  char v6; // al@4
  char v7; // [sp+Bh] [bp-1h]@2

  v2 = a1 == 0;
  v3 = a1 == 1;
  v4 = a2;
  v5 = a1 == 3;
  if ( a1 == 4 || (v7 = 0, a1 == 5) )
    v7 = 1;
  v6 = *(_BYTE *)(v4 + 5);
  *(_BYTE *)(v4 + 4) = 4;
  if ( v6 == 2 || v6 == 4 )
    byte_101C19A4 = 0;
  else
    sub_100048B0((int)&unk_101C19AC);
  if ( v5 || v2 || v3 || v7 )
    sub_100047F0(3, (int *)v4);
  if ( BYTE1(dword_101C3A20) )
    sub_10005FC0(3, byte_101C19A4);
  *(_BYTE *)(v4 + 5) = 0;
}
// 101C19A4: using guessed type char byte_101C19A4;
// 101C3A20: using guessed type int dword_101C3A20;

//----- (10004DE0) --------------------------------------------------------
char __cdecl sub_10004DE0(int a1, char a2)
{
  unsigned __int8 v2; // al@1
  int v3; // eax@2
  int v4; // ecx@2
  int v5; // eax@2
  unsigned int v6; // eax@6
  _DWORD *v7; // ecx@6
  char *v8; // edx@6
  int v9; // esi@10
  int v10; // eax@11
  _BYTE *v11; // ecx@11
  _BYTE *v12; // edx@11
  int v13; // eax@13
  _BYTE *v14; // ecx@13
  _BYTE *v15; // edx@13
  _BYTE *v16; // ecx@15
  _BYTE *v17; // edx@15
  signed int v18; // eax@17
  int *v19; // edi@22
  char result; // al@25
  int v21; // eax@27
  int v22; // esi@27
  int *v23; // eax@29
  unsigned __int8 v24; // [sp+Fh] [bp-95h]@1
  __int16 v25; // [sp+10h] [bp-94h]@29
  __int16 v26; // [sp+12h] [bp-92h]@29
  char v27; // [sp+14h] [bp-90h]@29
  int v28; // [sp+18h] [bp-8Ch]@1
  char v29; // [sp+1Ch] [bp-88h]@1
  char v30; // [sp+54h] [bp-50h]@1

  v28 = a1;
  sub_100045B0((int)&v30);
  sub_10007AC0((int)&v29, a1 + 18);
  v2 = 0;
  v24 = 0;
  do
  {
    v3 = 4 * v2;
    v4 = dword_101C3A1C[2 * v3 / 4u];
    v5 = 2 * v3;
    if ( v4 && v30 && v30 != 3 && *((_BYTE *)&dword_101C3A20 + v5 + 1) )
    {
      v6 = 56;
      v7 = (_DWORD *)(v4 + 16);
      v8 = &v29;
      do
      {
        if ( *(_DWORD *)v8 != *v7 )
          goto LABEL_10;
        v6 -= 4;
        ++v7;
        v8 += 4;
      }
      while ( v6 >= 4 );
      if ( !v6 )
      {
LABEL_19:
        v18 = 0;
        goto LABEL_20;
      }
LABEL_10:
      v9 = (unsigned __int8)*v8 - *(_BYTE *)v7;
      if ( (unsigned __int8)*v8 == *(_BYTE *)v7 )
      {
        v10 = v6 - 1;
        v11 = (char *)v7 + 1;
        v12 = v8 + 1;
        if ( !v10 )
          goto LABEL_19;
        v9 = *v12 - *v11;
        if ( *v12 == *v11 )
        {
          v13 = v10 - 1;
          v14 = v11 + 1;
          v15 = v12 + 1;
          if ( !v13 )
            goto LABEL_19;
          v9 = *v15 - *v14;
          if ( *v15 == *v14 )
          {
            v16 = v14 + 1;
            v17 = v15 + 1;
            if ( v13 == 1 )
              goto LABEL_19;
            v9 = *v17 - *v16;
            if ( *v17 == *v16 )
              goto LABEL_19;
          }
        }
      }
      v18 = 1;
      if ( v9 <= 0 )
        v18 = -1;
LABEL_20:
      if ( !v18 )
        return sub_10042450(13, 19, &v29, 0x38u);
    }
    v2 = v24++ + 1;
  }
  while ( v24 < 2u );
  v19 = &dword_101C3A24;
  if ( !a2 )
    v19 = dword_101C3A1C;
  if ( *((_BYTE *)v19 + 5) )
  {
    result = sub_10042450(13, 17, (char *)v19 + 5, 1u);
  }
  else
  {
    v21 = v28;
    *((_BYTE *)v19 + 4) = 0;
    v22 = sub_100049D0(v21);
    if ( v22 )
    {
      v25 = 6;
      v27 = 0;
      v26 = 1;
      v23 = sub_10010470(dword_101C19A8, &v29, &v25, v22, 1, 1);
      *v19 = (int)v23;
      if ( v23 )
      {
        sub_100046D0(23, v22, v19, 1);
        result = sub_100048A0((int)&unk_101C19AC);
        *((_BYTE *)v19 + 5) = 1;
      }
      else
      {
        result = sub_10042450(13, 15, 0, 0);
      }
    }
    else
    {
      *((_BYTE *)v19 + 4) = 7;
      result = sub_10042450(13, 12, 0, 0);
    }
  }
  return result;
}
// 101C19A8: using guessed type int dword_101C19A8;
// 101C3A1C: using guessed type int dword_101C3A1C[];
// 101C3A20: using guessed type int dword_101C3A20;
// 101C3A24: using guessed type int dword_101C3A24;

//----- (10005000) --------------------------------------------------------
char __cdecl sub_10005000(int a1)
{
  char result; // al@2

  if ( a1 )
  {
    if ( *(_BYTE *)(a1 + 5) )
    {
      sub_100048B0((int)&unk_101C19AC);
      result = sub_10004AB0(0, 0, a1);
      *(_BYTE *)(a1 + 5) = 0;
    }
    else
    {
      result = sub_10042450(13, 17, (void *)(a1 + 5), 1u);
    }
  }
  else
  {
    result = sub_10042450(13, 14, 0, 0);
  }
  return result;
}

//----- (100054B0) --------------------------------------------------------
void __cdecl sub_100054B0(void *a1, int a2, int a3, int a4)
{
  int *v4; // esi@3
  _BYTE *v5; // eax@8
  unsigned __int16 v6; // cx@13
  void *v7; // [sp+8h] [bp-8h]@1
  char v8; // [sp+Ch] [bp-4h]@1
  char v9; // [sp+Dh] [bp-3h]@1

  v8 = 0;
  v7 = a1;
  v9 = 0;
  if ( !a1 )
  {
    sub_10042450(13, 14, 0, 0);
    return;
  }
  v4 = sub_100047C0(a1);
  if ( !v4 )
    v4 = (int *)&v7;
  if ( !a4 || !*(_DWORD *)(a4 + 4) )
  {
    sub_10004CA0(0, (int)v4);
    return;
  }
  v5 = (_BYTE *)sub_10005720(a4);
  if ( !v5 )
  {
    sub_10042450(13, 13, 0, 0);
    sub_10004BE0((int)v4, 0);
    return;
  }
  if ( BYTE1(dword_101C3A20) )
  {
LABEL_19:
    sub_10004D50(0, (int)v4);
    return;
  }
  if ( *(_WORD *)a3 == 6 && !*(_BYTE *)(a3 + 4) )
  {
    v6 = *(_WORD *)(a3 + 2);
    if ( v6 <= 0x17u && v6 >= 1u )
    {
      if ( *v5 == 3 )
      {
        dword_101C3A1C[0] = (int)a1;
        BYTE1(dword_101C3A20) = 2;
        byte_101C19A4 = 1;
        sub_10005E90((int)(v5 + 4));
        return;
      }
      if ( *v5 == 2 )
      {
        sub_10005CB0();
        sub_100104D0(dword_101C19A8, dword_101C3A1C[0], 2, 0);
        BYTE1(dword_101C3A20) = 0;
        return;
      }
      goto LABEL_19;
    }
  }
  sub_10004BA0((int)v4);
}
// 101C19A4: using guessed type char byte_101C19A4;
// 101C19A8: using guessed type int dword_101C19A8;
// 101C3A1C: using guessed type int dword_101C3A1C[];
// 101C3A20: using guessed type int dword_101C3A20;

//----- (100055F0) --------------------------------------------------------
int sub_100055F0()
{
  int *v0; // esi@1
  signed int v1; // edi@1
  int result; // eax@4

  v0 = dword_101C3A1C;
  v1 = 2;
  do
  {
    if ( *((_BYTE *)v0 + 5) )
      sub_10005000((int)v0);
    result = sub_10004620((int)v0);
    v0 += 2;
    --v1;
  }
  while ( v1 );
  byte_101C19A4 = 0;
  return result;
}
// 101C19A4: using guessed type char byte_101C19A4;
// 101C3A1C: using guessed type int dword_101C3A1C[];

//----- (10005630) --------------------------------------------------------
int sub_10005630()
{
  int *v0; // eax@1
  signed int v1; // ecx@1
  int v2; // eax@3
  int v3; // edx@3
  int result; // eax@3
  int (*v5)(); // [sp+0h] [bp-1Ch]@3
  void (__cdecl *v6)(void *, int, int, int); // [sp+4h] [bp-18h]@3
  int (*v7)(); // [sp+8h] [bp-14h]@3
  int (*v8)(); // [sp+Ch] [bp-10h]@3
  int (*v9)(); // [sp+10h] [bp-Ch]@3
  int (*v10)(); // [sp+14h] [bp-8h]@3
  int (*v11)(); // [sp+18h] [bp-4h]@3

  byte_101C19B4 = 0;
  dword_101C19B0 = 240000;
  byte_101C19A4 = 0;
  v0 = dword_101C3A1C;
  v1 = 2;
  do
  {
    *((_BYTE *)v0 + 5) = 0;
    *v0 = 0;
    *((_BYTE *)v0 + 4) = 0;
    v0 += 2;
    --v1;
  }
  while ( v1 );
  v10 = sub_10005070;
  v11 = sub_10004AE0;
  v9 = sub_100051A0;
  v5 = sub_10005330;
  v6 = sub_100054B0;
  v7 = sub_10005260;
  v8 = sub_10005290;
  v2 = sub_10010520(0, (int)&v5, 1, 2u, 8264, (int)&unk_1019FEA8, 137980);
  v3 = *(_DWORD *)(*(_DWORD *)(v2 + 20) + 8);
  dword_101C19A8 = v2;
  result = *(_DWORD *)(v3 + 8);
  dword_101C19B8 = *(_DWORD *)(result + 1076);
  dword_101C19BC = *(_DWORD *)(result + 1080);
  dword_101C19C0 = *(_DWORD *)(result + 1084);
  dword_101C19C4 = *(_DWORD *)(result + 1088);
  dword_101C19C8 = *(_DWORD *)(result + 1092);
  word_101C19CC = *(_WORD *)(result + 1096);
  return result;
}
// 10004AE0: using guessed type int sub_10004AE0();
// 10005070: using guessed type int sub_10005070();
// 100051A0: using guessed type int sub_100051A0();
// 10005260: using guessed type int sub_10005260();
// 10005290: using guessed type int sub_10005290();
// 10005330: using guessed type int sub_10005330();
// 101C19A4: using guessed type char byte_101C19A4;
// 101C19A8: using guessed type int dword_101C19A8;
// 101C19B0: using guessed type int dword_101C19B0;
// 101C19B4: using guessed type char byte_101C19B4;
// 101C19B8: using guessed type int dword_101C19B8;
// 101C19BC: using guessed type int dword_101C19BC;
// 101C19C0: using guessed type int dword_101C19C0;
// 101C19C4: using guessed type int dword_101C19C4;
// 101C19C8: using guessed type int dword_101C19C8;
// 101C19CC: using guessed type __int16 word_101C19CC;
// 101C3A1C: using guessed type int dword_101C3A1C[];

//----- (10005720) --------------------------------------------------------
unsigned int __cdecl sub_10005720(int a1)
{
  return sub_10010A40((int)&off_100958F8, a1, &unk_101C3E40, 0x2814u) == 0 ? (unsigned int)&unk_101C3E40 : 0;
}
// 100958F8: using guessed type char *off_100958F8;

//----- (10005750) --------------------------------------------------------
signed int __cdecl sub_10005750(int a1)
{
  return sub_10010740((int)&off_10095764, a1, 8268, (int)&unk_101C3A3C, 1024, (int)&unk_101C3A30) <= 0 ? 0 : (unsigned int)&unk_101C3A30;
}
// 10095764: using guessed type char *off_10095764;

//----- (10005790) --------------------------------------------------------
int __cdecl sub_10005790(int a1, int a2, int a3, unsigned int a4, int a5, int a6)
{
  char v6; // dl@3
  unsigned int v7; // eax@3
  int result; // eax@5
  int v9; // [sp+10h] [bp-Ch]@3
  char v10; // [sp+14h] [bp-8h]@3

  if ( a4 >= 5 && a6 )
  {
    v6 = *(_BYTE *)(a3 + 4);
    v9 = *(_DWORD *)a3;
    v10 = v6;
    v7 = sub_100422A0(&v9, 5u);
    if ( v7 < 4 )
      memset((char *)&v9 + v7, 32, 4 - v7);
    result = sub_10011830(a1, a2, &v9, 5, a5);
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_cm_per.c", 1536, 0, 0);
    result = -1;
  }
  return result;
}

//----- (10005850) --------------------------------------------------------
signed int __cdecl sub_10005850(int a1, int a2, int a3, unsigned int a4, int a5)
{
  signed int result; // eax@2
  signed int v6; // edi@6

  if ( a4 >= 0x16 )
  {
    sub_10010690(a3);
    if ( sub_100107F0(a5, 1u) == 1 )
    {
      result = sub_10010880(a5, (_BYTE *)(a3 + 8), 0x18u);
      if ( !result )
      {
        result = sub_100107F0(a5, 1u);
        v6 = result;
        if ( result >= 0 )
        {
          result = sub_10010880(a5, (_BYTE *)(a3 + 11), 0x48u);
          if ( !result )
          {
            result = sub_100107F0(a5, 8 * v6 + 8);
            if ( result >= 0 )
            {
              *(_WORD *)(a3 + 20) = result;
              result = 0;
            }
          }
        }
      }
    }
    else
    {
      result = -2;
    }
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_cm_per.c", 1765, 0, 0);
    result = -1;
  }
  return result;
}

//----- (100058F0) --------------------------------------------------------
signed int __cdecl sub_100058F0(int a1, int a2, int a3, unsigned int a4, int a5)
{
  signed int result; // eax@2
  int v6; // esi@3
  unsigned __int16 v7; // ax@3
  signed int v8; // edi@4

  if ( a4 >= 0x16 )
  {
    v6 = a5;
    sub_100108E0(a5, 1, 1u);
    sub_100109B0(v6, a3 + 8, 0x18u);
    v7 = *(_WORD *)(a3 + 20);
    if ( v7 > 0xFFu )
    {
      v8 = 2;
      LOBYTE(a4) = HIBYTE(v7);
      BYTE1(a4) = v7;
    }
    else
    {
      v8 = 1;
      LOBYTE(a4) = *(_BYTE *)(a3 + 20);
    }
    sub_100108E0(v6, v8 - 1, 1u);
    sub_100109B0(v6, a3 + 11, 0x48u);
    sub_100109B0(v6, (int)&a4, 8 * v8);
    result = 0;
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_cm_per.c", 1879, 0, 0);
    result = -1;
  }
  return result;
}

//----- (100059A0) --------------------------------------------------------
signed int __cdecl sub_100059A0(int a1, int a2, int a3, unsigned int a4, int a5)
{
  signed int result; // eax@2

  if ( a4 >= 0x16 )
  {
    result = sub_10010880(a5, (_BYTE *)(a3 + 3), 0x28u);
    if ( !result )
      result = sub_10005850(a1, 0, a3, a4, a5);
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_cm_per.c", 1613, 0, 0);
    result = -1;
  }
  return result;
}

//----- (10005A00) --------------------------------------------------------
signed int __cdecl sub_10005A00(int a1, int a2, int a3, unsigned int a4, int a5)
{
  signed int result; // eax@2

  if ( a4 >= 0x16 )
  {
    sub_100109B0(a5, a3 + 3, 0x28u);
    result = sub_100058F0(a1, 0, a3, a4, a5);
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_cm_per.c", 1690, 0, 0);
    result = -1;
  }
  return result;
}

//----- (10005A60) --------------------------------------------------------
signed int sub_10005A60()
{
  signed int result; // eax@1

  sub_1000D5C0();
  sub_100055F0();
  memset(&dword_101C6658, 0, 0x44u);
  result = 538976288;
  dword_101C6658 = 538976288;
  dword_101C665C = 538976288;
  byte_101C6660 = 32;
  return result;
}
// 101C6658: using guessed type int dword_101C6658;
// 101C665C: using guessed type int dword_101C665C;
// 101C6660: using guessed type char byte_101C6660;

//----- (10005A90) --------------------------------------------------------
char __cdecl sub_10005A90(int a1)
{
  char result; // al@1

  result = sub_100045B0(a1);
  if ( result )
  {
    if ( byte_101C66A8 )
      *(_BYTE *)a1 = 5;
    *(_DWORD *)(a1 + 1) = dword_101C6661;
    *(_DWORD *)(a1 + 5) = dword_101C6665;
    *(_BYTE *)(a1 + 9) = byte_101C6669;
    *(_DWORD *)(a1 + 10) = dword_101C6690;
    *(_DWORD *)(a1 + 14) = dword_101C6694;
    *(_BYTE *)(a1 + 18) = byte_101C6698;
    *(_DWORD *)(a1 + 19) = dword_101C666A;
    *(_DWORD *)(a1 + 23) = dword_101C666E;
    *(_DWORD *)(a1 + 27) = dword_101C6672;
    *(_DWORD *)(a1 + 31) = dword_101C6676;
    *(_DWORD *)(a1 + 35) = dword_101C667A;
    result = 1;
  }
  return result;
}
// 101C6661: using guessed type int dword_101C6661;
// 101C6665: using guessed type int dword_101C6665;
// 101C6669: using guessed type char byte_101C6669;
// 101C666A: using guessed type int dword_101C666A;
// 101C666E: using guessed type int dword_101C666E;
// 101C6672: using guessed type int dword_101C6672;
// 101C6676: using guessed type int dword_101C6676;
// 101C667A: using guessed type int dword_101C667A;
// 101C6690: using guessed type int dword_101C6690;
// 101C6694: using guessed type int dword_101C6694;
// 101C6698: using guessed type char byte_101C6698;
// 101C66A8: using guessed type char byte_101C66A8;

//----- (10005B20) --------------------------------------------------------
char __cdecl sub_10005B20(const void *a1)
{
  bool v1; // cl@8
  char result; // al@14
  char v3; // [sp+4h] [bp-F4h]@1
  char v4; // [sp+34h] [bp-C4h]@5
  char v5; // [sp+50h] [bp-A8h]@1

  memset(&v5, 0, 0xA4u);
  memset(&v3, 0, 0x4Cu);
  if ( !sub_10042630(&v5) )
  {
    v5 = 4;
LABEL_4:
    dword_101C66A0 = sub_1007C040();
    byte_101C66A8 = 1;
    goto LABEL_5;
  }
  if ( v5 != 2 )
    goto LABEL_4;
LABEL_5:
  sub_10005A90((int)&v3);
  v1 = v4 == 1 || v4 == 2 || v4 == 3;
  if ( v3 == 1 || v3 == 4 || v3 == 2 && v1 )
  {
    result = sub_10042450(13, -128, &v3, 1u);
  }
  else
  {
    qmemcpy(&dword_101C6658, a1, 0x38u);
    dword_101C6690 = 0;
    dword_101C6694 = 0;
    byte_101C6698 = 0;
    result = (unsigned int)sub_1000D570();
    if ( !byte_101C66A8 )
      result = sub_10004DE0((int)a1, 0);
  }
  return result;
}
// 101C6658: using guessed type int dword_101C6658;
// 101C6690: using guessed type int dword_101C6690;
// 101C6694: using guessed type int dword_101C6694;
// 101C6698: using guessed type char byte_101C6698;
// 101C66A0: using guessed type int dword_101C66A0;
// 101C66A8: using guessed type char byte_101C66A8;

//----- (10005C40) --------------------------------------------------------
int sub_10005C40()
{
  int result; // eax@3
  char v1; // [sp+0h] [bp-50h]@1

  sub_100045B0((int)&v1);
  if ( !v1 )
    sub_10042450(13, -128, 0, 0);
  sub_1000D570();
  result = sub_100055F0();
  byte_101C66A8 = 0;
  return result;
}
// 101C66A8: using guessed type char byte_101C66A8;

//----- (10005CA0) --------------------------------------------------------
int *sub_10005CA0()
{
  return &dword_101C6658;
}
// 101C6658: using guessed type int dword_101C6658;

//----- (10005CB0) --------------------------------------------------------
char sub_10005CB0()
{
  return sub_10042450(13, 18, 0, 0);
}

//----- (10005CD0) --------------------------------------------------------
void sub_10005CD0()
{
  if ( byte_101C66A8 )
  {
    if ( sub_1007C040() - dword_101C66A0 >= (unsigned int)dword_101C66A4 )
    {
      sub_100049B0();
      byte_101C66A8 = 0;
    }
  }
}
// 101C66A0: using guessed type int dword_101C66A0;
// 101C66A4: using guessed type int dword_101C66A4;
// 101C66A8: using guessed type char byte_101C66A8;

//----- (10005D00) --------------------------------------------------------
char __usercall sub_10005D00@<al>(int a1@<eax>)
{
  char result; // al@2

  if ( a1 )
  {
    dword_101C666A = *(_DWORD *)(a1 + 10);
    dword_101C666E = *(_DWORD *)(a1 + 14);
    dword_101C6672 = *(_DWORD *)(a1 + 18);
    dword_101C6676 = *(_DWORD *)(a1 + 22);
    dword_101C667A = *(_DWORD *)(a1 + 26);
    word_101C667E = *(_WORD *)(a1 + 30);
    dword_101C6690 = *(_DWORD *)a1;
    dword_101C6694 = *(_DWORD *)(a1 + 4);
    byte_101C6698 = *(_BYTE *)(a1 + 8);
    result = 1;
  }
  else
  {
    sub_10042450(13, 16, 0, 0x20u);
    result = 0;
  }
  return result;
}
// 101C666A: using guessed type int dword_101C666A;
// 101C666E: using guessed type int dword_101C666E;
// 101C6672: using guessed type int dword_101C6672;
// 101C6676: using guessed type int dword_101C6676;
// 101C667A: using guessed type int dword_101C667A;
// 101C667E: using guessed type __int16 word_101C667E;
// 101C6690: using guessed type int dword_101C6690;
// 101C6694: using guessed type int dword_101C6694;
// 101C6698: using guessed type char byte_101C6698;

//----- (10005D70) --------------------------------------------------------
void __thiscall sub_10005D70(void *this)
{
  if ( !this )
  {
    dword_101C6661 = dword_101C6690;
    byte_101C6669 = byte_101C6698;
    dword_101C6665 = dword_101C6694;
    dword_101C6690 = 0;
    dword_101C6694 = 0;
    byte_101C6698 = 0;
  }
  sub_100048C0((int)this);
}
// 101C6661: using guessed type int dword_101C6661;
// 101C6665: using guessed type int dword_101C6665;
// 101C6669: using guessed type char byte_101C6669;
// 101C6690: using guessed type int dword_101C6690;
// 101C6694: using guessed type int dword_101C6694;
// 101C6698: using guessed type char byte_101C6698;

//----- (10005E00) --------------------------------------------------------
void sub_10005E00()
{
  char v0; // [sp+0h] [bp-A8h]@2

  sub_10005CD0();
  if ( byte_101C66A8 && sub_10042630(&v0) && v0 == 2 )
  {
    byte_101C66A8 = 0;
    sub_10005B20(&dword_101C6658);
  }
}
// 101C6658: using guessed type int dword_101C6658;
// 101C66A8: using guessed type char byte_101C66A8;

//----- (10005E70) --------------------------------------------------------
int __cdecl sub_10005E70(int a1)
{
  int result; // eax@1
  int v2; // ecx@1

  sub_10005630();
  memset(&dword_101C6658, 0, 0x44u);
  dword_101C6658 = 538976288;
  dword_101C665C = 538976288;
  byte_101C6660 = 32;
  result = a1;
  byte_101C669C = 0;
  byte_101C669D = 1;
  v2 = 60000 * *(_BYTE *)(a1 + 1);
  byte_101C66A8 = 0;
  dword_101C66A4 = v2;
  return result;
}
// 101C6658: using guessed type int dword_101C6658;
// 101C665C: using guessed type int dword_101C665C;
// 101C6660: using guessed type char byte_101C6660;
// 101C669C: using guessed type char byte_101C669C;
// 101C669D: using guessed type char byte_101C669D;
// 101C66A4: using guessed type int dword_101C66A4;
// 101C66A8: using guessed type char byte_101C66A8;

//----- (10005E80) --------------------------------------------------------
_DWORD *sub_10005E80()
{
  sub_10005E00();
  sub_10004A90((int)&unk_101C19AC);
  return sub_1000FDF0(dword_101C19A8);
}
// 101C19A8: using guessed type int dword_101C19A8;

//----- (10005E90) --------------------------------------------------------
char __cdecl sub_10005E90(int a1)
{
  char result; // al@2
  char v2; // [sp+4h] [bp-28h]@1
  char v3; // [sp+Ch] [bp-20h]@1

  sub_1000B3F0((int)&v2);
  if ( v3 )
  {
    result = sub_10005D00(a1);
    if ( result )
    {
      sub_10004DE0((int)&dword_101C6658, 1);
      result = 1;
    }
  }
  else
  {
    sub_10005D70((void *)1);
    result = 1;
  }
  return result;
}
// 101C6658: using guessed type int dword_101C6658;

//----- (10005F10) --------------------------------------------------------
void __cdecl sub_10005F10(int a1, unsigned int a2, char a3)
{
  char v3; // bl@1
  unsigned __int16 v4; // cx@2
  unsigned __int8 v5; // al@2

  v3 = 0;
  if ( *(_BYTE *)(a2 + 10252) )
  {
    v4 = *(_WORD *)(a2 + 8200);
    v5 = 0;
    if ( v4 )
    {
      while ( *(_DWORD *)(a2 + 8 * v5 + 8204) != 22 )
      {
        if ( ++v5 >= v4 )
          goto LABEL_7;
      }
      v3 = 1;
    }
  }
LABEL_7:
  if ( sub_10042650(&a2) )
  {
    if ( v3 )
    {
      sub_1000B530(a2);
      if ( a3 )
        sub_10005D70(0);
    }
    else
    {
      sub_10042450(13, 10, 0, 0);
      *(_BYTE *)(a1 + 4) = 10;
    }
  }
  else
  {
    sub_10042450(13, 11, 0, 0);
    *(_BYTE *)(a1 + 4) = 11;
  }
}

//----- (10005FC0) --------------------------------------------------------
void __cdecl sub_10005FC0(char a1, char a2)
{
  sub_10042450(13, 21, &a1, 4u);
  if ( a2 )
    sub_10005D70((void *)1);
}

//----- (10005FF0) --------------------------------------------------------
void __cdecl sub_10005FF0(char a1)
{
  sub_10042450(13, 20, 0, 0);
  if ( a1 )
    sub_10005D70((void *)1);
}

//----- (10006020) --------------------------------------------------------
char __cdecl sub_10006020(char *a1)
{
  char result; // al@2
  char *v2; // edi@3
  int v3; // ebp@6
  int v4; // esi@7
  unsigned int v5; // eax@15
  int v6; // ecx@15
  unsigned int v7; // eax@16
  bool v8; // cf@16
  bool v9; // zf@16
  int v10; // ST04_4@17
  void *v11; // eax@19
  char *v12; // [sp+4h] [bp+4h]@3
  char *v13; // [sp+4h] [bp+4h]@5

  if ( a1 )
  {
    v12 = (char *)*((_DWORD *)a1 + 2);
    v2 = v12;
    if ( v12 )
    {
      result = sub_1000A250(*((_DWORD *)v12 + 2));
      v13 = 0;
      if ( *((_DWORD *)v2 + 1) )
      {
        v3 = 0;
        do
        {
          v4 = v3 + *(_DWORD *)v2;
          if ( *(_BYTE *)(v4 + 30) == 1 )
          {
            (*(void (__cdecl **)(_DWORD, int))(*(_DWORD *)(v4 + 48) + 32))(
              *(_DWORD *)(*(_DWORD *)(v4 + 48) + 12),
              v3 + *(_DWORD *)v2);
            *(_BYTE *)(v4 + 16) = 0;
            *(_BYTE *)(v4 + 30) = 0;
            *(_BYTE *)(v4 + 31) = 0;
            *(_BYTE *)(v4 + 32) = 0;
            *(_BYTE *)(v4 + 1) = 0;
          }
          if ( *(_BYTE *)(v4 + 31) == 1 )
            sub_10007040(v4);
          if ( *(_BYTE *)(v4 + 1) == 3 || *(_BYTE *)(v4 + 1) == 7 )
          {
            if ( *(_BYTE *)(v4 + 16) == 1 )
            {
              v11 = *(void **)(v4 + 8);
              switch ( *(_BYTE *)v11 & 0xF8 )
              {
                case 224:
                  sub_10009630(*(_DWORD *)(v4 + 4), v11, *(_DWORD *)(v4 + 20));
                  *(_BYTE *)(v4 + 16) = 0;
                  *(_BYTE *)(v4 + 1) = 8;
                  *(_BYTE *)(v4 + 32) = 1;
                  *(_DWORD *)(v4 + 36) = sub_10041EB0();
                  *(_DWORD *)(v4 + 40) = 0;
                  *(_DWORD *)(v4 + 44) = 10000;
                  break;
                case 232:
                  sub_10009630(*(_DWORD *)(v4 + 4), v11, *(_DWORD *)(v4 + 20));
                  *(_BYTE *)(v4 + 1) = 4;
                  *(_BYTE *)(v4 + 16) = 0;
                  break;
                case 240:
                  sub_10009630(*(_DWORD *)(v4 + 4), v11, *(_DWORD *)(v4 + 20));
                  *(_BYTE *)(v4 + 1) = 2;
                  *(_BYTE *)(v4 + 16) = 0;
                  break;
                default:
                  sub_10042930("..\\lib\\atn\\atn_cosp.c", 544, 0, 0);
                  *(_BYTE *)(v4 + 16) = 0;
                  break;
              }
            }
          }
          else if ( *(_BYTE *)(v4 + 1) == 8 && *(_BYTE *)(v4 + 32) == 1 )
          {
            v5 = sub_10041EB0();
            v6 = *(_DWORD *)(v4 + 36);
            if ( v5 > v6 )
            {
              v7 = v5 - v6;
              v8 = v7 < *(_DWORD *)(v4 + 44);
              v9 = v7 == *(_DWORD *)(v4 + 44);
              *(_DWORD *)(v4 + 40) = v7;
              if ( !v8 && !v9 )
              {
                v10 = *(_DWORD *)(v4 + 4);
                *(_BYTE *)(v4 + 32) = 0;
                sub_10009540(v10, 0, 0);
                *(_BYTE *)(v4 + 16) = 0;
                *(_BYTE *)(v4 + 30) = 0;
                *(_BYTE *)(v4 + 31) = 0;
                *(_BYTE *)(v4 + 32) = 0;
                *(_BYTE *)(v4 + 1) = 0;
              }
            }
          }
          result = (_BYTE)v13 + 1;
          v3 += 52;
          ++v13;
        }
        while ( (unsigned int)v13 < *((_DWORD *)v2 + 1) );
      }
    }
    else
    {
      result = sub_10042930("..\\lib\\atn\\atn_cosp.c", 479, 0, 0);
    }
  }
  else
  {
    result = sub_10042930("..\\lib\\atn\\atn_copp.c", 348, 0, 0);
  }
  return result;
}
// 10041EB0: using guessed type int sub_10041EB0(void);

//----- (10006050) --------------------------------------------------------
void __cdecl sub_10006050(int a1, void *a2, size_t a3)
{
  char v3; // al@4
  int v4; // ST14_4@9

  if ( a1 && (!a3 || a2) )
  {
    v3 = *(_BYTE *)a1;
    if ( *(_BYTE *)a1 )
    {
      if ( v3 == 2 || v3 == 3 )
      {
        sub_10042930("..\\lib\\atn\\atn_copp.c", 495, 0, 0);
        (*(void (__cdecl **)(_DWORD, int))(*(_DWORD *)(a1 + 8) + 32))(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 12), a1);
        sub_10006F90(*(_DWORD *)(a1 + 4), 0, 0);
        *(_BYTE *)a1 = 0;
      }
      else if ( v3 == 1 )
      {
        v4 = *(_DWORD *)(a1 + 4);
        *(_BYTE *)a1 = 3;
        sub_10006E80(v4, 2, a2, a3);
      }
    }
    else
    {
      sub_10042930("..\\lib\\atn\\atn_copp.c", 483, 0, 0);
      (*(void (__cdecl **)(_DWORD, int))(*(_DWORD *)(a1 + 8) + 32))(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 12), a1);
    }
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_copp.c", 470, 0, 0);
  }
}

//----- (10006110) --------------------------------------------------------
void __cdecl sub_10006110(int a1, void *a2, size_t a3)
{
  if ( a1 && (!a3 || a2) )
  {
    switch ( *(_BYTE *)a1 )
    {
      case 0:
        sub_10042930("..\\lib\\atn\\atn_copp.c", 557, 0, 0);
        break;
      case 2:
      case 3:
        sub_10042930("..\\lib\\atn\\atn_copp.c", 568, 0, 0);
        sub_10006F90(*(_DWORD *)(a1 + 4), 0, 0);
        *(_BYTE *)a1 = 0;
        break;
      case 1:
        sub_10007980(*(_DWORD *)(a1 + 4), 2, a2, a3);
        *(_BYTE *)a1 = 0;
        break;
      default:
        return;
    }
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_copp.c", 544, 0, 0);
  }
}

//----- (100061C0) --------------------------------------------------------
void __cdecl sub_100061C0(int a1, void *a2, size_t a3)
{
  if ( a1 && (!a3 || a2) )
  {
    switch ( *(_BYTE *)a1 )
    {
      case 0:
        sub_10042930("..\\lib\\atn\\atn_copp.c", 630, 0, 0);
        (*(void (__cdecl **)(_DWORD, int))(*(_DWORD *)(a1 + 8) + 32))(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 12), a1);
        break;
      case 1:
      case 2:
        sub_10042930("..\\lib\\atn\\atn_copp.c", 642, 0, 0);
        (*(void (__cdecl **)(_DWORD, int))(*(_DWORD *)(a1 + 8) + 32))(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 12), a1);
        sub_10006F90(*(_DWORD *)(a1 + 4), 0, 0);
        *(_BYTE *)a1 = 0;
        break;
      case 3:
        sub_10006AE0(*(_DWORD *)(a1 + 4), a2, a3);
        break;
      default:
        return;
    }
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_copp.c", 617, 0, 0);
  }
}

//----- (10006290) --------------------------------------------------------
void __cdecl sub_10006290(int a1, int a2, int a3)
{
  if ( a1 && (!a3 || a2) )
  {
    if ( *(_BYTE *)a1 )
    {
      if ( (unsigned __int8)(*(_BYTE *)a1 - 1) > 2u )
      {
        sub_10042930("..\\lib\\atn\\atn_copp.c", 719, 0, 0);
      }
      else
      {
        sub_10006F90(*(_DWORD *)(a1 + 4), 0, 0);
        *(_BYTE *)a1 = 0;
      }
    }
    else
    {
      sub_10042930("..\\lib\\atn\\atn_copp.c", 714, 0, 0);
    }
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_copp.c", 691, 0, 0);
  }
}

//----- (10006310) --------------------------------------------------------
int __usercall sub_10006310@<eax>(int a1@<esi>)
{
  unsigned int v1; // edx@1
  unsigned int v2; // ecx@1
  int result; // eax@2

  v1 = *(_DWORD *)(a1 + 4);
  v2 = 0;
  if ( v1 )
  {
    result = *(_DWORD *)a1;
    while ( *(_BYTE *)result )
    {
      ++v2;
      result += 12;
      if ( v2 >= v1 )
        goto LABEL_5;
    }
    *(_DWORD *)(result + 8) = a1;
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (10006340) --------------------------------------------------------
int __usercall sub_10006340@<eax>(int a1@<eax>, int a2@<esi>)
{
  unsigned int v2; // edx@1
  unsigned int v3; // ecx@1
  int result; // eax@2

  v2 = *(_DWORD *)(a1 + 4);
  v3 = 0;
  if ( v2 )
  {
    result = *(_DWORD *)a1;
    while ( !*(_BYTE *)result || *(_DWORD *)(result + 4) != a2 )
    {
      ++v3;
      result += 12;
      if ( v3 >= v2 )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    result = 0;
  }
  return result;
}

//----- (10006370) --------------------------------------------------------
int __cdecl sub_10006370(int a1, int a2, int a3, void *a4, size_t a5)
{
  int v5; // edi@6
  int v6; // eax@7
  int result; // eax@8

  if ( a1 && a2 && a3 && (!a5 || a4) )
  {
    v5 = sub_10006310(a1);
    if ( v5 && (v6 = sub_10006DD0(*(_DWORD *)(a1 + 8), a2, a3, 2, a4, a5), (*(_DWORD *)(v5 + 4) = v6) != 0) )
    {
      *(_BYTE *)v5 = 2;
      result = v5;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_copp.c", 399, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10006400) --------------------------------------------------------
void __cdecl sub_10006400(int a1, int a2, int a3, _BYTE *a4, int a5)
{
  int v5; // eax@9
  int v6; // edx@11

  if ( !a1 || !a2 || !a3 )
    goto LABEL_6;
  if ( !a4 )
  {
    if ( a5 )
    {
LABEL_6:
      sub_10042930("..\\lib\\atn\\atn_copp.c", 790, 0, 0);
      return;
    }
    goto LABEL_8;
  }
  if ( !a5 || (v5 = sub_10006310(a1)) == 0 || (*(_DWORD *)(v5 + 4) = a2, *a4 != 2) )
  {
LABEL_8:
    sub_10006F90(a2, 0, 0);
    return;
  }
  *(_BYTE *)v5 = 1;
  v6 = *(_DWORD *)(a1 + 12);
  if ( a5 == 1 )
    (*(void (__cdecl **)(int, int, int, _DWORD, _DWORD))(a1 + 16))(v6, v5, a3, 0, 0);
  else
    (*(void (__cdecl **)(int, int, int, _BYTE *, int))(a1 + 16))(v6, v5, a3, a4 + 1, a5 - 1);
}

//----- (100064B0) --------------------------------------------------------
void __cdecl sub_100064B0(int a1, int a2, int a3, _BYTE *a4, int a5)
{
  _BYTE *v5; // eax@6
  size_t v6; // edi@6
  int v7; // ecx@11
  void (__cdecl *v8)(int, _BYTE *, int, _BYTE *, int); // edx@11

  if ( a1 && a2 && a3 && (a4 || !a5) )
  {
    v5 = (_BYTE *)sub_10006340(a1, a2);
    v6 = (size_t)v5;
    if ( v5 )
    {
      if ( *v5 == 2 && a5 && *a4 == 2 )
      {
        *v5 = 3;
        v7 = *(_DWORD *)(a1 + 12);
        v8 = *(void (__cdecl **)(int, _BYTE *, int, _BYTE *, int))(a1 + 24);
        if ( a5 == 1 )
          v8(v7, v5, a3, 0, 0);
        else
          v8(v7, v5, a3, a4 + 1, a5 - 1);
      }
      else
      {
        (*(void (__cdecl **)(_DWORD, _BYTE *))(a1 + 32))(*(_DWORD *)(a1 + 12), v5);
        sub_10006F90(*(_DWORD *)(v6 + 4), 0, 0);
        *(_BYTE *)v6 = 0;
      }
    }
    else
    {
      sub_10042930("..\\lib\\atn\\atn_copp.c", 902, 0, 0);
      sub_10006F90(a2, (void *)v6, v6);
    }
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_copp.c", 891, 0, 0);
  }
}

//----- (100065B0) --------------------------------------------------------
char __cdecl sub_100065B0(int a1, int a2, int a3, unsigned __int8 *a4, int a5)
{
  int v5; // eax@6
  _BYTE *v6; // esi@6
  char result; // al@7
  unsigned int v8; // eax@13

  if ( a1 && a2 && a3 && (a4 || !a5) )
  {
    v5 = sub_10006340(a1, a2);
    v6 = (_BYTE *)v5;
    if ( !v5 )
      return sub_10042930("..\\lib\\atn\\atn_copp.c", 1006, 0, 0);
    if ( *(_BYTE *)v5 != 2 )
      goto LABEL_9;
    if ( a5 )
    {
      if ( (*a4 & 0x8F) != 2 )
      {
LABEL_9:
        result = (*(int (__cdecl **)(_DWORD, int))(a1 + 32))(*(_DWORD *)(a1 + 12), v5);
        *v6 = 0;
        return result;
      }
      LOBYTE(v5) = *a4 >> 4;
      v8 = v5 & 0xFFFFFF07;
      if ( a5 == 1 )
      {
        result = (*(int (__cdecl **)(_DWORD, _BYTE *, int, unsigned int, _DWORD, _DWORD))(a1 + 28))(
                   *(_DWORD *)(a1 + 12),
                   v6,
                   a3,
                   v8,
                   0,
                   0);
        *v6 = 0;
      }
      else
      {
        result = (*(int (__cdecl **)(_DWORD, _BYTE *, int, unsigned int, unsigned __int8 *, int))(a1 + 28))(
                   *(_DWORD *)(a1 + 12),
                   v6,
                   a3,
                   v8,
                   a4 + 1,
                   a5 - 1);
        *v6 = 0;
      }
    }
    else
    {
      result = (*(int (__cdecl **)(_DWORD, int, int, signed int, _DWORD, _DWORD))(a1 + 28))(
                 *(_DWORD *)(a1 + 12),
                 v5,
                 a3,
                 255,
                 0,
                 0);
      *v6 = 0;
    }
  }
  else
  {
    result = sub_10042930("..\\lib\\atn\\atn_copp.c", 996, 0, 0);
  }
  return result;
}

//----- (100066C0) --------------------------------------------------------
void __cdecl sub_100066C0(char *a1, int a2, int a3, char *a4)
{
  _BYTE *v4; // eax@5
  _BYTE *v5; // esi@5
  unsigned __int8 v6; // al@7

  if ( a1 && a2 && (!a4 || a3) )
  {
    v4 = (_BYTE *)sub_10006340((int)a1, a2);
    v5 = v4;
    if ( !v4 )
    {
      sub_10042930("..\\lib\\atn\\atn_copp.c", 1141, 0, 0);
      return;
    }
    v6 = *v4;
    if ( *v5 )
    {
      if ( v6 <= 2u )
      {
        sub_10042930("..\\lib\\atn\\atn_copp.c", 1156, 0, 0);
        (*((void (__cdecl **)(_DWORD, _DWORD))a1 + 8))(*((_DWORD *)a1 + 3), v5);
        sub_10006F90(*((_DWORD *)v5 + 1), 0, 0);
        *v5 = 0;
        return;
      }
      if ( v6 == 3 )
      {
        (*((void (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))a1 + 5))(*((_DWORD *)a1 + 3), v5, a3, a4);
        return;
      }
    }
    sub_10042930("..\\lib\\atn\\atn_copp.c", 1173, 0, 0);
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_copp.c", 1131, 0, 0);
  }
}

//----- (100067D0) --------------------------------------------------------
char __cdecl sub_100067D0(char *a1, int a2, int a3, char *a4)
{
  _BYTE *v4; // eax@5
  _BYTE *v5; // esi@5
  char result; // al@6

  if ( a1 && a2 && (!a4 || a3) )
  {
    v4 = (_BYTE *)sub_10006340((int)a1, a2);
    v5 = v4;
    if ( v4 )
    {
      if ( (unsigned __int8)(*v4 - 1) > 2u )
      {
        result = sub_10042930("..\\lib\\atn\\atn_copp.c", 1253, 0, 0);
      }
      else if ( a4 )
      {
        result = (*((int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))a1 + 9))(*((_DWORD *)a1 + 3), v4, a3, a4);
        *v5 = 0;
      }
      else
      {
        result = (*((int (__cdecl **)(_DWORD, _DWORD))a1 + 8))(*((_DWORD *)a1 + 3), v4);
        *v5 = 0;
      }
    }
    else
    {
      result = sub_10042930("..\\lib\\atn\\atn_copp.c", 1224, 0, 0);
    }
  }
  else
  {
    result = sub_10042930("..\\lib\\atn\\atn_copp.c", 1214, 0, 0);
  }
  return result;
}

//----- (10006950) --------------------------------------------------------
int __cdecl sub_10006950(int a1, int a2, __int16 a3, unsigned int a4, int a5, int a6, unsigned int a7)
{
  int v8; // edi@12
  int v9; // eax@13
  unsigned int v10; // edx@13
  int v11; // eax@15
  int v12; // [sp-10h] [bp-2Ch]@16
  char v13; // [sp-Ch] [bp-28h]@16
  void (__cdecl *v14)(int, int, int, _BYTE *, int); // [sp+4h] [bp-18h]@15
  void (__cdecl *v15)(char *, int, int, char *); // [sp+8h] [bp-14h]@15
  void (__cdecl *v16)(int, int, int, _BYTE *, int); // [sp+Ch] [bp-10h]@15
  char (__cdecl *v17)(int, int, int, unsigned __int8 *, int); // [sp+10h] [bp-Ch]@15
  int (*v18)(); // [sp+14h] [bp-8h]@15
  char (__cdecl *v19)(char *, int, int, char *); // [sp+18h] [bp-4h]@15

  if ( a7 < 7 * a4 * (a5 + 1246) + 1436 )
  {
    sub_10042930("..\\lib\\atn\\atn_copp.c", 219, 0, 0);
    return 0;
  }
  if ( !a2 || !a6 || !a1 )
  {
    v13 = 0;
    v12 = 231;
    goto LABEL_18;
  }
  if ( !*(_DWORD *)a2
    || !*(_DWORD *)(a2 + 8)
    || !*(_DWORD *)(a2 + 4)
    || !*(_DWORD *)(a2 + 16)
    || !*(_DWORD *)(a2 + 20)
    || !*(_DWORD *)(a2 + 12) )
  {
    v13 = 0;
    v12 = 246;
LABEL_18:
    sub_10042930("..\\lib\\atn\\atn_copp.c", v12, v13, 0);
    return 0;
  }
  *(_DWORD *)(a6 + 12) = a1;
  *(_DWORD *)(a6 + 16) = *(_DWORD *)a2;
  *(_DWORD *)(a6 + 24) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a6 + 28) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a6 + 20) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a6 + 32) = *(_DWORD *)(a2 + 16);
  v8 = 40;
  *(_DWORD *)(a6 + 36) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a6 + 4) = a4;
  *(_DWORD *)a6 = a6 + 40;
  if ( a4 )
  {
    v9 = 0;
    v10 = a4;
    v8 = 12 * a4 + 40;
    do
    {
      *(_BYTE *)(v9 + *(_DWORD *)a6) = 0;
      v9 += 12;
      --v10;
    }
    while ( v10 );
  }
  v14 = sub_10006400;
  v16 = sub_100064B0;
  v17 = sub_100065B0;
  v15 = sub_100066C0;
  v18 = sub_100068C0;
  v19 = sub_100067D0;
  v11 = sub_10007600(a6, (int)&v14, a3, a4, a5 + 1, a6 + v8, a7 - v8);
  *(_DWORD *)(a6 + 8) = v11;
  return v11 != 0 ? a6 : 0;
}
// 100068C0: using guessed type int sub_100068C0();

//----- (10006AE0) --------------------------------------------------------
char __cdecl sub_10006AE0(int a1, void *a2, size_t a3)
{
  char result; // al@4

  if ( a1 && (!a3 || a2) )
  {
    result = *(_BYTE *)(a1 + 1);
    if ( result )
    {
      if ( result == 2 )
        result = sub_10009630(*(_DWORD *)(a1 + 4), a2, a3);
      else
        *(_BYTE *)(a1 + 31) = 1;
    }
    else
    {
      result = sub_10042930("..\\lib\\atn\\atn_cosp.c", 954, 0, 0);
      *(_BYTE *)(a1 + 30) = 1;
    }
  }
  else
  {
    result = sub_10042930("..\\lib\\atn\\atn_cosp.c", 941, 0, 0);
  }
  return result;
}

//----- (10006B50) --------------------------------------------------------
char __cdecl sub_10006B50(int a1)
{
  sub_10042930("..\\lib\\atn\\atn_cosp.c", 1115, 0, 0);
  return sub_10009540(a1, 0, 0);
}

//----- (10006B80) --------------------------------------------------------
int __usercall sub_10006B80@<eax>(int result@<eax>)
{
  *(_BYTE *)(result + 1) = 0;
  return result;
}

//----- (10006B90) --------------------------------------------------------
void *__usercall sub_10006B90@<eax>(size_t a1@<eax>, char a2@<cl>, int a3@<esi>, char a4, void *a5)
{
  size_t v5; // edi@1
  void *result; // eax@1

  v5 = a1;
  **(_BYTE **)(a3 + 8) = a2;
  *(_BYTE *)(*(_DWORD *)(a3 + 8) + 1) = a4;
  result = memcpy((void *)(*(_DWORD *)(a3 + 8) + 2), a5, a1);
  *(_DWORD *)(a3 + 20) = v5 + 2;
  return result;
}

//----- (10006BC0) --------------------------------------------------------
int __usercall sub_10006BC0@<eax>(int a1@<edi>)
{
  unsigned int v1; // ecx@1
  unsigned int v2; // eax@1
  int v3; // esi@2
  int result; // eax@5

  v1 = *(_DWORD *)(a1 + 4);
  v2 = 0;
  if ( v1 )
  {
    v3 = *(_DWORD *)a1;
    while ( *(_BYTE *)(v3 + 1) )
    {
      ++v2;
      v3 += 52;
      if ( v2 >= v1 )
        goto LABEL_5;
    }
    *(_BYTE *)(v3 + 16) = 0;
    *(_DWORD *)(v3 + 4) = 0;
    *(_BYTE *)v3 = 0;
    *(_BYTE *)(v3 + 1) = 0;
    *(_DWORD *)(v3 + 32) = 0;
    *(_DWORD *)(v3 + 36) = 0;
    *(_DWORD *)(v3 + 40) = 0;
    *(_DWORD *)(v3 + 44) = 0;
    memset(*(void **)(v3 + 8), 0, *(_DWORD *)(v3 + 12));
    *(_DWORD *)(v3 + 20) = 0;
    *(_DWORD *)(v3 + 48) = a1;
    result = v3;
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (10006C20) --------------------------------------------------------
char __cdecl sub_10006C20(int a1, int a2, _DWORD *a3, _BYTE *a4, unsigned int a5)
{
  int v5; // edi@1
  int v6; // ebp@2
  int v7; // esi@6
  _DWORD *v8; // eax@7
  unsigned int v9; // eax@8
  _BYTE *v10; // edx@10

  v5 = a1;
  if ( a1 && (v6 = a2) != 0 && a3 && (!a5 || a4) )
  {
    v7 = sub_10006BC0(a1);
    if ( v7 )
    {
      v9 = a5;
      if ( a5 )
      {
        v10 = a4;
        if ( *a4 & 4 || (*a4 & 0xF8) != -24 )
        {
          LOBYTE(v8) = sub_10009540(v6, 0, 0);
          *(_BYTE *)(v7 + 16) = 0;
          *(_BYTE *)(v7 + 30) = 0;
          *(_BYTE *)(v7 + 31) = 0;
          *(_BYTE *)(v7 + 32) = 0;
          *(_BYTE *)(v7 + 1) = 0;
        }
        else
        {
          *(_DWORD *)(v7 + 4) = v6;
          *(_BYTE *)(v7 + 1) = 7;
          if ( v9 >= 2 )
            LOBYTE(v8) = (*(int (__cdecl **)(_DWORD, int, _DWORD *, _BYTE *, unsigned int))(*(_DWORD *)(v7 + 48) + 16))(
                           *(_DWORD *)(v5 + 12),
                           v7,
                           a3,
                           v10 + 1,
                           v9 - 1);
          else
            LOBYTE(v8) = (*(int (__cdecl **)(_DWORD, int, _DWORD *, _DWORD, _DWORD))(*(_DWORD *)(v7 + 48) + 16))(
                           *(_DWORD *)(v5 + 12),
                           v7,
                           a3,
                           0,
                           0);
        }
      }
      else
      {
        *(_BYTE *)(v7 + 1) = 1;
        *(_DWORD *)(v7 + 4) = v6;
        sub_100094E0(v6, 0, 0);
        v8 = a3;
        *(_DWORD *)(v7 + 24) = *a3;
        *(_WORD *)(v7 + 28) = *((_WORD *)v8 + 2);
      }
    }
    else
    {
      LOBYTE(a1) = -29;
      LOBYTE(v8) = sub_100094E0(v6, &a1, 1u);
    }
  }
  else
  {
    LOBYTE(v8) = sub_10042930("..\\lib\\atn\\atn_cosp.c", 1742, 0, 0);
  }
  return (unsigned int)v8;
}

//----- (10006D50) --------------------------------------------------------
int __usercall sub_10006D50@<eax>(int a1@<eax>, int a2@<esi>)
{
  unsigned int v2; // edx@1
  unsigned int v3; // ecx@1
  int result; // eax@2

  v2 = *(_DWORD *)(a1 + 4);
  v3 = 0;
  if ( v2 )
  {
    result = *(_DWORD *)a1;
    while ( !*(_BYTE *)(result + 1) || *(_DWORD *)(result + 4) != a2 )
    {
      ++v3;
      result += 52;
      if ( v3 >= v2 )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    result = 0;
  }
  return result;
}

//----- (10006D80) --------------------------------------------------------
char __usercall sub_10006D80@<al>(int a1@<edx>, int a2@<ecx>, int a3@<edi>, int a4@<esi>)
{
  int v4; // eax@2
  int v6; // eax@4

  if ( *(_DWORD *)(a4 + 20) <= 0x20u )
  {
    v6 = sub_10009400(a3, a1, a2, *(void **)(a4 + 8), *(_DWORD *)(a4 + 20));
    *(_DWORD *)(a4 + 4) = v6;
    if ( v6 )
    {
      *(_BYTE *)(a4 + 1) = 5;
      return 1;
    }
  }
  else
  {
    v4 = sub_10009400(a3, a1, a2, 0, 0);
    *(_DWORD *)(a4 + 4) = v4;
    if ( v4 )
    {
      *(_BYTE *)(a4 + 1) = 3;
      return 1;
    }
  }
  return 0;
}

//----- (10006DD0) --------------------------------------------------------
int __cdecl sub_10006DD0(int a1, int a2, int a3, char a4, void *a5, size_t a6)
{
  int v6; // esi@6
  int result; // eax@9

  if ( a1 && a2 && a3 && (a5 || !a6) )
  {
    v6 = sub_10006BC0(a1);
    if ( !v6 )
      return 0;
    if ( a6 + 2 > *(_DWORD *)(v6 + 12) )
    {
      sub_10042930("..\\lib\\atn\\atn_cosp.c", 645, 0, 0);
      return 0;
    }
    *(_DWORD *)(v6 + 48) = a1;
    sub_10006B90(a6, -24, v6, a4, a5);
    result = sub_10006D80(a2, a3, *(_DWORD *)(a1 + 8), v6) == 1 ? v6 : 0;
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_cosp.c", 624, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10006E80) --------------------------------------------------------
char __cdecl sub_10006E80(int a1, char a2, void *a3, size_t a4)
{
  int v4; // esi@1
  void *v5; // edx@2
  size_t v6; // ecx@2
  size_t v7; // edi@4
  char result; // al@5
  char v9; // bl@10
  bool v10; // zf@10
  int v11; // ST00_4@13

  v4 = a1;
  if ( a1 && ((v5 = a3, v6 = a4, a3) || !a4) && (v7 = a4 + 2, a4 + 2 <= *(_DWORD *)(a1 + 12)) )
  {
    result = *(_BYTE *)(a1 + 1);
    if ( result )
    {
      if ( result == 6 || result == 7 )
      {
        v9 = a2;
        **(_BYTE **)(a1 + 8) = -16;
        *(_BYTE *)(*(_DWORD *)(v4 + 8) + 1) = v9;
        memcpy((void *)(*(_DWORD *)(v4 + 8) + 2), v5, v6);
        v10 = *(_BYTE *)(v4 + 1) == 6;
        *(_DWORD *)(v4 + 20) = v7;
        if ( v10 )
        {
          result = sub_10009630(*(_DWORD *)(v4 + 4), *(void **)(v4 + 8), v7);
          *(_BYTE *)(v4 + 1) = 2;
          *(_BYTE *)(v4 + 16) = 0;
        }
        else if ( v7 <= 0x20 )
        {
          result = sub_100094E0(*(_DWORD *)(v4 + 4), *(void **)(v4 + 8), v7);
          *(_BYTE *)(v4 + 1) = 2;
          *(_BYTE *)(v4 + 16) = 0;
        }
        else
        {
          v11 = *(_DWORD *)(v4 + 4);
          LOBYTE(a1) = -40;
          result = sub_100094E0(v11, &a1, 1u);
          *(_BYTE *)(v4 + 16) = 1;
        }
      }
      else
      {
        *(_BYTE *)(a1 + 31) = 1;
      }
    }
    else
    {
      result = sub_10042930("..\\lib\\atn\\atn_cosp.c", 732, 0, 0);
      *(_BYTE *)(v4 + 30) = 1;
    }
  }
  else
  {
    result = sub_10042930("..\\lib\\atn\\atn_cosp.c", 721, 0, 0);
  }
  return result;
}

//----- (10006F90) --------------------------------------------------------
void __cdecl sub_10006F90(int a1, void *a2, size_t a3)
{
  unsigned int v3; // eax@5
  char v4; // [sp+Ch] [bp-44h]@5
  char v5; // [sp+Dh] [bp-43h]@6

  if ( a1 && (!a3 || a2) )
  {
    if ( *(_BYTE *)(a1 + 1) )
    {
      v3 = 1;
      v4 = 1;
      if ( a3 < 0x40 )
      {
        memcpy(&v5, a2, a3);
        v3 = a3 + 1;
      }
      sub_10009540(*(_DWORD *)(a1 + 4), &v4, v3);
      *(_BYTE *)(a1 + 16) = 0;
      *(_BYTE *)(a1 + 30) = 0;
      *(_BYTE *)(a1 + 31) = 0;
      *(_BYTE *)(a1 + 32) = 0;
      *(_BYTE *)(a1 + 1) = 0;
    }
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_cosp.c", 1012, 0, 0);
  }
}

//----- (10007040) --------------------------------------------------------
char __usercall sub_10007040@<al>(int a1@<esi>)
{
  char result; // al@1

  (*(void (__cdecl **)(_DWORD))(*(_DWORD *)(a1 + 48) + 32))(*(_DWORD *)(*(_DWORD *)(a1 + 48) + 12));
  result = sub_10009540(*(_DWORD *)(a1 + 4), 0, 0);
  *(_BYTE *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 30) = 0;
  *(_BYTE *)(a1 + 31) = 0;
  *(_BYTE *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  return result;
}

//----- (10007070) --------------------------------------------------------
int __usercall sub_10007070@<eax>(int a1@<esi>)
{
  int result; // eax@1

  *(_BYTE *)(a1 + 32) = 1;
  result = sub_10041EB0();
  *(_DWORD *)(a1 + 36) = result;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 44) = 10000;
  return result;
}
// 10041EB0: using guessed type int sub_10041EB0(void);

//----- (10007090) --------------------------------------------------------
char __usercall sub_10007090@<al>(int a1@<esi>)
{
  char result; // al@1

  sub_10042930("..\\lib\\atn\\atn_cosp.c", 1136, 0, 0);
  result = sub_10009540(*(_DWORD *)(a1 + 4), 0, 0);
  *(_BYTE *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 30) = 0;
  *(_BYTE *)(a1 + 31) = 0;
  *(_BYTE *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  return result;
}

//----- (100070D0) --------------------------------------------------------
char __usercall sub_100070D0@<al>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>, int a4)
{
  _BYTE *v4; // edi@1
  char v5; // cl@2
  int v6; // ecx@3
  char result; // al@5
  int v8; // edx@6
  int v9; // ecx@9
  int v10; // edx@9

  v4 = a3;
  if ( !a1 )
    return sub_10007040(a4);
  v5 = *a3;
  if ( *v4 & 4 )
    return sub_10007040(a4);
  v6 = (unsigned __int8)(v5 & 0xF8) - 224;
  if ( v6 )
  {
    if ( v6 != 16 )
      return sub_10007040(a4);
    *(_BYTE *)(a4 + 1) = 2;
    v8 = *(_DWORD *)(a2 + 12);
    if ( a1 == 1 )
      result = (*(int (__cdecl **)(int, int, int, _DWORD, _DWORD))(*(_DWORD *)(a4 + 48) + 24))(v8, a4, a4 + 24, 0, 0);
    else
      result = (*(int (__cdecl **)(int, int, int, _BYTE *, int))(*(_DWORD *)(a4 + 48) + 24))(
                 v8,
                 a4,
                 a4 + 24,
                 v4 + 1,
                 a1 - 1);
  }
  else
  {
    v9 = *(_DWORD *)(a4 + 48);
    *(_BYTE *)(a4 + 16) = 0;
    *(_BYTE *)(a4 + 30) = 0;
    *(_BYTE *)(a4 + 31) = 0;
    *(_BYTE *)(a4 + 32) = 0;
    *(_BYTE *)(a4 + 1) = 0;
    v10 = *(_DWORD *)(a2 + 12);
    if ( a1 == 1 )
      (*(void (__cdecl **)(int, int, int, _DWORD, _DWORD))(v9 + 28))(v10, a4, a4 + 24, 0, 0);
    else
      (*(void (__cdecl **)(int, int, int, _BYTE *, int))(v9 + 28))(v10, a4, a4 + 24, v4 + 1, a1 - 1);
    result = sub_10009540(*(_DWORD *)(a4 + 4), 0, 0);
  }
  return result;
}

//----- (10007190) --------------------------------------------------------
char __usercall sub_10007190@<al>(int a1@<eax>, int a2@<edi>, int a3@<esi>, int a4, _BYTE *a5)
{
  char result; // al@2

  if ( !a1 || (*a5 & 0xF8) != -24 || *a5 & 4 )
  {
    result = sub_10009540(a2, 0, 0);
    *(_BYTE *)(a3 + 16) = 0;
    *(_BYTE *)(a3 + 30) = 0;
    *(_BYTE *)(a3 + 31) = 0;
    *(_BYTE *)(a3 + 32) = 0;
    *(_BYTE *)(a3 + 1) = 0;
  }
  else
  {
    *(_BYTE *)(a3 + 1) = 6;
    if ( a1 == 1 )
      result = (*(int (__cdecl **)(_DWORD, int, int, _DWORD, _DWORD))(*(_DWORD *)(a3 + 48) + 16))(
                 *(_DWORD *)(a4 + 12),
                 a3,
                 a3 + 24,
                 0,
                 0);
    else
      result = (*(int (__cdecl **)(_DWORD, int, int, _BYTE *, int))(*(_DWORD *)(a3 + 48) + 16))(
                 *(_DWORD *)(a4 + 12),
                 a3,
                 a3 + 24,
                 a5 + 1,
                 a1 - 1);
  }
  return result;
}

//----- (10007220) --------------------------------------------------------
char __cdecl sub_10007220(int a1, int a2, int a3, _BYTE *a4, int a5)
{
  int v5; // eax@6
  int v6; // esi@6
  bool v7; // zf@13
  int v8; // edx@22

  if ( !a1 || !a2 || !a3 || a5 && !a4 )
  {
    LOBYTE(v5) = sub_10042930("..\\lib\\atn\\atn_cosp.c", 1559, 0, 0);
    return v5;
  }
  v5 = sub_10006D50(a1, a2);
  v6 = v5;
  if ( !v5 )
  {
    LOBYTE(v5) = sub_10006B50(a2);
    return v5;
  }
  LOBYTE(v5) = *(_BYTE *)(v5 + 1);
  if ( (_BYTE)v5 != 3 && (_BYTE)v5 != 5 || (_BYTE)v5 == 5 && !a5 )
    goto LABEL_14;
  if ( (_BYTE)v5 == 3 )
  {
    v7 = a5 == 0;
    if ( a5 )
    {
LABEL_14:
      if ( (_BYTE)v5 == 1 || (_BYTE)v5 == 8 )
      {
        LOBYTE(v5) = sub_10007090(v6);
        return v5;
      }
LABEL_28:
      LOBYTE(v5) = sub_10007040(v6);
      return v5;
    }
  }
  else
  {
    v7 = a5 == 0;
  }
  if ( v7 )
  {
    *(_BYTE *)(v6 + 16) = 1;
    return v5;
  }
  if ( *a4 & 4 )
    goto LABEL_28;
  v5 = *a4 & 0xF8;
  switch ( v5 )
  {
    case 240:
      v8 = *(_DWORD *)(v6 + 48);
      *(_BYTE *)(v6 + 1) = 2;
      LOBYTE(v5) = (*(int (__cdecl **)(_DWORD, int, int, _BYTE *, int))(v8 + 24))(
                     *(_DWORD *)(a1 + 12),
                     v6,
                     a3,
                     a4 + 1,
                     a5 - 1);
      break;
    case 224:
      *(_BYTE *)(v6 + 1) = 0;
      if ( a5 == 1 )
        (*(void (__cdecl **)(_DWORD, int, int, _DWORD, _DWORD))(*(_DWORD *)(v6 + 48) + 28))(
          *(_DWORD *)(a1 + 12),
          v6,
          a3,
          0,
          0);
      else
        (*(void (__cdecl **)(_DWORD, int, int, _BYTE *, int))(*(_DWORD *)(v6 + 48) + 28))(
          *(_DWORD *)(a1 + 12),
          v6,
          a3,
          a4 + 1,
          a5 - 1);
      LOBYTE(v5) = sub_10009540(*(_DWORD *)(v6 + 4), 0, 0);
      break;
    case 160:
    case 216:
      *(_BYTE *)(v6 + 1) = 4;
      break;
    default:
      goto LABEL_28;
  }
  return v5;
}

//----- (100073F0) --------------------------------------------------------
char __cdecl sub_100073F0(char *a1, int a2, _BYTE *a3, char *a4)
{
  int v4; // eax@5
  char result; // al@6

  if ( a1 && a2 && (!a4 || a3) )
  {
    v4 = sub_10006D50((int)a1, a2);
    if ( v4 )
    {
      switch ( *(_BYTE *)(v4 + 1) )
      {
        case 2:
          result = (*(int (__cdecl **)(_DWORD, int, _BYTE *, char *))(*(_DWORD *)(v4 + 48) + 20))(
                     *((_DWORD *)a1 + 3),
                     v4,
                     a3,
                     a4);
          break;
        case 1:
          result = sub_10007190((int)a4, a2, v4, (int)a1, a3);
          break;
        case 4:
          result = sub_100070D0((int)a4, (int)a1, a3, v4);
          break;
        case 8:
          result = sub_10007090(v4);
          break;
        default:
          result = sub_10007040(v4);
          break;
      }
    }
    else
    {
      result = sub_10006B50(a2);
    }
  }
  else
  {
    result = sub_10042930("..\\lib\\atn\\atn_cosp.c", 1885, 0, 0);
  }
  return result;
}

//----- (100074F0) --------------------------------------------------------
char __cdecl sub_100074F0(int a1, int a2, _BYTE *a3, unsigned int a4)
{
  int v4; // eax@5
  int v5; // esi@5

  if ( !a1 || !a2 || a4 && !a3 )
  {
    LOBYTE(v4) = sub_10042930("..\\lib\\atn\\atn_cosp.c", 1976, 0, 0);
    return v4;
  }
  v4 = sub_10006D50(a1, a2);
  v5 = v4;
  if ( v4 )
  {
    LOBYTE(v4) = *(_BYTE *)(v4 + 1);
    if ( (_BYTE)v4 != 1 && (_BYTE)v4 != 8 )
    {
      if ( a4 <= 0 )
      {
        LOBYTE(v4) = (*(int (__cdecl **)(_DWORD, int))(*(_DWORD *)(v5 + 48) + 32))(*(_DWORD *)(a1 + 12), v5);
      }
      else
      {
        if ( *a3 == 1 )
        {
          if ( a4 == 1 )
          {
            LOBYTE(v4) = (*(int (__cdecl **)(_DWORD, int, _DWORD, _DWORD))(*(_DWORD *)(v5 + 48) + 36))(
                           *(_DWORD *)(a1 + 12),
                           v5,
                           0,
                           0);
            *(_BYTE *)(v5 + 16) = 0;
            *(_BYTE *)(v5 + 30) = 0;
            *(_BYTE *)(v5 + 31) = 0;
            *(_BYTE *)(v5 + 32) = 0;
            *(_BYTE *)(v5 + 1) = 0;
          }
          else
          {
            LOBYTE(v4) = (*(int (__cdecl **)(_DWORD, int, _BYTE *, unsigned int))(*(_DWORD *)(v5 + 48) + 36))(
                           *(_DWORD *)(a1 + 12),
                           v5,
                           a3 + 1,
                           a4 - 1);
            *(_BYTE *)(v5 + 16) = 0;
            *(_BYTE *)(v5 + 30) = 0;
            *(_BYTE *)(v5 + 31) = 0;
            *(_BYTE *)(v5 + 32) = 0;
            *(_BYTE *)(v5 + 1) = 0;
          }
          return v4;
        }
        LOBYTE(v4) = (*(int (__cdecl **)(_DWORD, int))(*(_DWORD *)(v5 + 48) + 32))(*(_DWORD *)(a1 + 12), v5);
      }
    }
    *(_BYTE *)(v5 + 16) = 0;
    *(_BYTE *)(v5 + 30) = 0;
    *(_BYTE *)(v5 + 31) = 0;
    *(_BYTE *)(v5 + 32) = 0;
    *(_BYTE *)(v5 + 1) = 0;
  }
  return v4;
}

//----- (10007600) --------------------------------------------------------
int __cdecl sub_10007600(int a1, int a2, __int16 a3, unsigned int a4, int a5, int a6, unsigned int a7)
{
  unsigned int v7; // ebp@1
  int result; // eax@2
  int v9; // ecx@12
  unsigned int v10; // ebx@12
  int v11; // ebp@13
  int v12; // eax@14
  int v13; // edx@14
  int v14; // ecx@14
  char (__cdecl *v15)(int, int, _DWORD *, _BYTE *, unsigned int); // [sp+8h] [bp-14h]@18
  char (__cdecl *v16)(int, int, int, _BYTE *, int); // [sp+Ch] [bp-10h]@18
  char (__cdecl *v17)(char *, int, _BYTE *, char *); // [sp+10h] [bp-Ch]@18
  char (__cdecl *v18)(int, int, _BYTE *, unsigned int); // [sp+14h] [bp-8h]@18

  v7 = a7;
  if ( a7 >= a4 * (7 * a5 + 8703) + 1396 )
  {
    if ( a2 && a6 && a1 )
    {
      if ( *(_DWORD *)a2
        && *(_DWORD *)(a2 + 8)
        && *(_DWORD *)(a2 + 12)
        && *(_DWORD *)(a2 + 4)
        && *(_DWORD *)(a2 + 16)
        && *(_DWORD *)(a2 + 20) )
      {
        *(_DWORD *)(a6 + 16) = *(_DWORD *)a2;
        *(_DWORD *)(a6 + 24) = *(_DWORD *)(a2 + 8);
        *(_DWORD *)(a6 + 28) = *(_DWORD *)(a2 + 12);
        *(_DWORD *)(a6 + 20) = *(_DWORD *)(a2 + 4);
        *(_DWORD *)(a6 + 32) = *(_DWORD *)(a2 + 16);
        v9 = 40;
        *(_DWORD *)(a6 + 36) = *(_DWORD *)(a2 + 20);
        v10 = 0;
        *(_DWORD *)(a6 + 4) = a4;
        *(_DWORD *)a6 = a6 + 40;
        if ( a4 )
        {
          v11 = a5 + 1;
          do
          {
            v12 = sub_10006B80(v9 + a6);
            *(_DWORD *)(v12 + 12) = v11;
            *(_DWORD *)(v12 + 8) = v13;
            *(_DWORD *)(v12 + 20) = 0;
            *(_BYTE *)(v12 + 16) = 0;
            *(_BYTE *)(v12 + 30) = 0;
            *(_BYTE *)(v12 + 31) = 0;
            v9 = v14 + 52;
            if ( v10 == a4 - 1 )
              v9 += a4 * v11;
            ++v10;
          }
          while ( v10 < a4 );
          v7 = a7;
        }
        *(_DWORD *)(a6 + 12) = a1;
        v15 = sub_10006C20;
        v16 = sub_10007220;
        v17 = sub_100073F0;
        v18 = sub_100074F0;
        result = sub_10008920(a6, a3, (int)&v15, a4, a5 + 1, a6 + v9, v7 - v9);
        *(_DWORD *)(a6 + 8) = result;
        if ( result )
          result = a6;
        else
          *(_DWORD *)(a6 + 12) = 0;
      }
      else
      {
        sub_10042930("..\\lib\\atn\\atn_cosp.c", 341, 0, 0);
        result = 0;
      }
    }
    else
    {
      sub_10042930("..\\lib\\atn\\atn_cosp.c", 326, 0, 0);
      result = 0;
    }
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_cosp.c", 314, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10007980) --------------------------------------------------------
char __cdecl sub_10007980(int a1, char a2, void *a3, size_t a4)
{
  int v4; // esi@1
  void *v5; // edx@2
  size_t v6; // ecx@2
  size_t v7; // edi@4
  char v8; // al@5
  char result; // al@6
  bool v10; // zf@10
  int v11; // ST04_4@13

  v4 = a1;
  if ( a1 && ((v5 = a3, v6 = a4, a3) || !a4) && (v7 = a4 + 2, a4 + 2 <= *(_DWORD *)(a1 + 12)) )
  {
    v8 = *(_BYTE *)(a1 + 1);
    if ( v8 )
    {
      if ( v8 == 6 || v8 == 7 )
      {
        **(_BYTE **)(a1 + 8) = -29;
        *(_BYTE *)(*(_DWORD *)(v4 + 8) + 1) = a2;
        memcpy((void *)(*(_DWORD *)(v4 + 8) + 2), v5, v6);
        v10 = *(_BYTE *)(v4 + 1) == 6;
        *(_DWORD *)(v4 + 20) = v7;
        if ( v10 )
        {
          sub_10009630(*(_DWORD *)(v4 + 4), *(void **)(v4 + 8), v7);
          result = sub_10007070(v4);
          *(_BYTE *)(v4 + 16) = 0;
          *(_BYTE *)(v4 + 1) = 8;
        }
        else if ( v7 <= 0x20 )
        {
          sub_100094E0(*(_DWORD *)(v4 + 4), *(void **)(v4 + 8), v7);
          result = sub_10007070(v4);
          *(_BYTE *)(v4 + 16) = 0;
          *(_BYTE *)(v4 + 1) = 8;
        }
        else
        {
          v11 = *(_DWORD *)(v4 + 4);
          LOBYTE(a1) = -96;
          result = sub_100094E0(v11, &a1, 1u);
          *(_BYTE *)(v4 + 16) = 1;
        }
      }
      else
      {
        result = sub_10009540(*(_DWORD *)(a1 + 4), 0, 0);
        *(_BYTE *)(v4 + 16) = 0;
        *(_BYTE *)(v4 + 30) = 0;
        *(_BYTE *)(v4 + 31) = 0;
        *(_BYTE *)(v4 + 32) = 0;
        *(_BYTE *)(v4 + 1) = 0;
      }
    }
    else
    {
      result = sub_10042930("..\\lib\\atn\\atn_cosp.c", 834, 0, 0);
    }
  }
  else
  {
    result = sub_10042930("..\\lib\\atn\\atn_cosp.c", 823, 0, 0);
  }
  return result;
}

//----- (10007AC0) --------------------------------------------------------
int __cdecl sub_10007AC0(int a1, int a2)
{
  int result; // eax@1
  unsigned __int16 v3; // dx@1

  result = a1;
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  v3 = *(_WORD *)(a2 + 20);
  if ( v3 > 0xFFu )
  {
    *(_BYTE *)(a1 + 20) = HIBYTE(v3);
    *(_BYTE *)(a1 + 21) = v3;
    *(_DWORD *)(a1 + 52) = 2;
  }
  else
  {
    *(_BYTE *)(a1 + 20) = *(_BYTE *)(a2 + 20);
    *(_DWORD *)(a1 + 52) = 1;
  }
  return result;
}

//----- (10007B10) --------------------------------------------------------
_BYTE *__usercall sub_10007B10@<eax>(int a1@<ecx>, int a2@<edx>, char a3@<al>, char a4)
{
  _BYTE *result; // eax@1

  result = sub_1000A370(a2, a1, a3, 1u);
  if ( result )
    *result = a4;
  return result;
}

//----- (10007B30) --------------------------------------------------------
_BYTE *__usercall sub_10007B30@<eax>(int a1@<ecx>, char a2@<al>, __int16 a3@<bx>, int a4)
{
  _BYTE *result; // eax@1

  result = sub_1000A370(a4, a1, a2, 2u);
  if ( result )
  {
    *result = HIBYTE(a3);
    result[1] = a3;
  }
  return result;
}

//----- (10007B50) --------------------------------------------------------
_BYTE *__usercall sub_10007B50@<eax>(int a1@<ecx>, char a2@<al>, unsigned int a3@<ebx>, int a4)
{
  _BYTE *result; // eax@1

  result = sub_1000A370(a4, a1, a2, 4u);
  if ( result )
  {
    *result = BYTE3(a3);
    result[1] = a3 >> 16;
    result[2] = BYTE1(a3);
    result[3] = a3;
  }
  return result;
}

//----- (10007B80) --------------------------------------------------------
int __usercall sub_10007B80@<eax>(int a1@<ecx>, int a2@<edx>, int a3@<eax>)
{
  char *v3; // eax@3

  a3 = (unsigned __int8)a3;
  if ( (_BYTE)a3 )
  {
    if ( a3 != 1 )
      return 0;
    v3 = (char *)sub_1000A370(a2, a1, -61, 2u);
  }
  else
  {
    v3 = (char *)sub_1000A370(a2, a1, 8, 4u);
  }
  if ( v3 )
    return (int)(v3 - 2);
  return 0;
}

//----- (10007BB0) --------------------------------------------------------
int __usercall sub_10007BB0@<eax>(int a1@<eax>, int a2@<ecx>, const void *a3, int a4, const void *a5, __int16 a6)
{
  int v6; // esi@1
  int v7; // edx@1
  unsigned int v8; // ecx@1
  int v9; // edi@1
  int v10; // ebp@2
  char v11; // al@3
  int result; // eax@8
  char v13; // al@12
  char v14; // cl@13

  v6 = a2;
  v7 = 0;
  v8 = 0;
  v9 = a1;
  if ( *(_DWORD *)(v6 + 1036) )
  {
    v10 = *(_DWORD *)(v6 + 1032);
    while ( 1 )
    {
      v11 = *(_BYTE *)(v10 + 13);
      if ( !v11 )
        break;
      if ( v11 == 5 )
        v7 = v10;
      ++v8;
      v10 += 8644;
      if ( v8 >= *(_DWORD *)(v6 + 1036) )
      {
        if ( !v7 )
          goto LABEL_8;
        v10 = v7;
        break;
      }
    }
    if ( !++*(_WORD *)(v6 + 1024) )
      *(_WORD *)(v6 + 1024) = 1;
    sub_100425D0(*(_BYTE *)(v6 + 1095), *(_WORD *)(v6 + 1024));
    *(_BYTE *)v10 = 0;
    *(_BYTE *)(v10 + 1) = 0;
    *(_BYTE *)(v10 + 2) = 0;
    *(_BYTE *)(v10 + 3) = *(_BYTE *)(v6 + 1060);
    *(_BYTE *)(v10 + 4) = *(_BYTE *)(v6 + 1060);
    v13 = *(_BYTE *)(v10 + 3);
    *(_DWORD *)(v10 + 8) = 0;
    *(_BYTE *)(v10 + 13) = 0;
    *(_WORD *)(v10 + 14) = a6;
    *(_BYTE *)(v10 + 20) = 0;
    *(_BYTE *)(v10 + 21) = *(_BYTE *)(v6 + 1060);
    *(_BYTE *)(v10 + 22) = 0;
    *(_BYTE *)(v10 + 23) = 0;
    *(_DWORD *)(v10 + 24) = 0;
    *(_DWORD *)(v10 + 28) = 0;
    *(_BYTE *)(v10 + 90) = 10;
    *(_DWORD *)(v10 + 92) = 1024;
    *(_BYTE *)(v10 + 236) = 0;
    *(_BYTE *)(v10 + 237) = 0;
    *(_BYTE *)(v10 + 238) = 0;
    *(_BYTE *)(v10 + 239) = 0;
    *(_BYTE *)(v10 + 240) = 0;
    *(_BYTE *)(v10 + 241) = v13;
    *(_BYTE *)(v10 + 242) = 0;
    *(_WORD *)(v10 + 244) = *(_WORD *)(v6 + 1024);
    memset((void *)(v10 + 252), 0, 0x1030u);
    memset((void *)(v10 + 4484), 0, 0x1010u);
    *(_DWORD *)(v10 + 8600) = 0;
    *(_BYTE *)(v10 + 8604) = 0;
    *(_DWORD *)(v10 + 8608) = 20000;
    *(_DWORD *)(v10 + 8612) = 1000 * *(_WORD *)(v6 + 1064);
    *(_DWORD *)(v10 + 8616) = 360000;
    *(_DWORD *)(v10 + 8620) = 1000 * *(_WORD *)(v6 + 1066);
    *(_DWORD *)(v10 + 8624) = 1000 * *(_WORD *)(v6 + 1062);
    *(_DWORD *)(v10 + 8628) = 0;
    *(_DWORD *)(v10 + 8632) = 0;
    *(_DWORD *)(v10 + 8636) = *(_DWORD *)(v6 + 1028);
    *(_DWORD *)(v10 + 8640) = *(_DWORD *)(v6 + 1028);
    *(_DWORD *)(v10 + 4476) = v10 + 4476;
    *(_DWORD *)(v10 + 4480) = v10 + 4476;
    *(_DWORD *)(v10 + 4396) = 0;
    *(_DWORD *)(v10 + 4400) = 0;
    *(_DWORD *)(v10 + 4416) = 0;
    *(_DWORD *)(v10 + 4420) = 0;
    *(_DWORD *)(v10 + 4436) = 0;
    *(_DWORD *)(v10 + 4440) = 0;
    *(_DWORD *)(v10 + 4456) = 0;
    *(_DWORD *)(v10 + 4460) = 0;
    if ( v9 )
    {
      *(_WORD *)(v10 + 88) = *(_WORD *)v9;
      v14 = 14 - *(_BYTE *)v9;
      *(_BYTE *)(v10 + 98) = 3;
      *(_BYTE *)(v10 + 96) = v14;
      *(_WORD *)(v10 + 100) = *(_WORD *)(v9 + 2);
      *(_BYTE *)(v10 + 12) = *(_BYTE *)(v9 + 4);
    }
    else
    {
      *(_WORD *)(v10 + 88) = 14;
      qmemcpy((void *)(v10 + 96), a3, 0x8Cu);
      *(_BYTE *)(v10 + 12) = 3;
    }
    if ( a5 )
    {
      qmemcpy((void *)(v10 + 32), a5, 0x38u);
      result = v10;
    }
    else
    {
      *(_DWORD *)(v10 + 32) = *(_DWORD *)a4;
      *(_DWORD *)(v10 + 36) = *(_DWORD *)(a4 + 4);
      *(_DWORD *)(v10 + 40) = *(_DWORD *)(a4 + 8);
      *(_DWORD *)(v10 + 44) = *(_DWORD *)(a4 + 12);
      *(_DWORD *)(v10 + 48) = *(_DWORD *)(a4 + 16);
      *(_DWORD *)(v10 + 84) = 0;
      result = v10;
    }
  }
  else
  {
LABEL_8:
    result = 0;
  }
  return result;
}

//----- (10007E20) --------------------------------------------------------
int __fastcall sub_10007E20(int a1, int a2)
{
  unsigned int v2; // eax@1
  int v3; // ecx@1

  v2 = 0;
  v3 = a2 + 4396;
  while ( *(_DWORD *)(v3 + 4) || *(_DWORD *)v3 )
  {
    ++v2;
    v3 += 20;
    if ( v2 >= 4 )
      return 0;
  }
  return a2 + 20 * v2 + 4396;
}

//----- (10007E50) --------------------------------------------------------
_BYTE *__usercall sub_10007E50@<eax>(int a1@<eax>, char a2@<dl>, int a3)
{
  char v3; // bl@1
  _BYTE *result; // eax@1

  v3 = *(_BYTE *)(*(_DWORD *)(a1 + 16) + 1096);
  result = sub_1000A370(a3 + 12, 1024, a2, 1u);
  if ( result )
    *result = v3;
  return result;
}

//----- (10007E80) --------------------------------------------------------
char __usercall sub_10007E80@<al>(int a1@<eax>, unsigned int a2@<edi>, int a3@<esi>, unsigned int a4)
{
  unsigned int v4; // eax@2

  if ( a1 == *(_BYTE *)(a3 + 238) )
  {
    v4 = *(_DWORD *)(a3 + 8);
    if ( a2 == v4 )
    {
      if ( a4 < *(_BYTE *)(a3 + 239) )
        return 0;
    }
    else if ( a2 <= v4 )
    {
      return 0;
    }
  }
  else if ( (unsigned __int8)((a1 - *(_BYTE *)(a3 + 238)) & 0x7F) > (unsigned __int8)((*(_BYTE *)(a3 + 237)
                                                                                     - *(_BYTE *)(a3 + 238)) & 0x7F) )
  {
    return 0;
  }
  *(_DWORD *)(a3 + 8) = a2;
  return 1;
}

//----- (10007ED0) --------------------------------------------------------
void *__usercall sub_10007ED0@<eax>(char a1@<al>, const void *a2@<edx>, int a3@<ecx>, int a4@<edi>)
{
  int v4; // esi@1
  void *result; // eax@1
  size_t v6; // [sp+0h] [bp-8h]@0

  v4 = 1028 * (a1 & 3) + a3;
  result = memcpy((void *)(v4 + 4488), a2, v6);
  *(_DWORD *)(v4 + 4484) = a4;
  return result;
}

//----- (10007F00) --------------------------------------------------------
int __usercall sub_10007F00@<eax>(int a1@<eax>, int a2, _DWORD *a3, int a4)
{
  int v4; // esi@1
  unsigned int v5; // ebx@1
  int v6; // edi@1
  unsigned int v7; // edx@7
  int result; // eax@8
  __int16 v9; // cx@9
  _DWORD *v10; // edx@14
  unsigned int v11; // ecx@14
  _DWORD *v12; // esi@14
  int v13; // edi@18
  int v14; // ecx@19
  _BYTE *v15; // edx@19
  _BYTE *v16; // esi@19
  int v17; // ecx@21
  _BYTE *v18; // edx@21
  _BYTE *v19; // esi@21
  _BYTE *v20; // edx@23
  _BYTE *v21; // esi@23
  int v22; // edx@24
  signed int v23; // ecx@25
  __int16 v24; // [sp+10h] [bp-Ch]@2
  __int16 v25; // [sp+14h] [bp-8h]@5
  unsigned int v26; // [sp+18h] [bp-4h]@7

  v4 = a2;
  v5 = 0;
  v6 = a4;
  if ( a2 )
    v24 = *(_BYTE *)(a2 + 1) + (*(_BYTE *)a2 << 8);
  else
    v24 = 0;
  if ( a4 )
    v25 = *(_BYTE *)(a4 + 1) + (*(_BYTE *)a4 << 8);
  else
    v25 = 0;
  v7 = *(_DWORD *)(a1 + 1036);
  v26 = *(_DWORD *)(a1 + 1036);
  if ( v7 > 0 )
  {
    result = *(_DWORD *)(a1 + 1032);
    do
    {
      v9 = *(_WORD *)(result + 244);
      if ( v9 && (!v4 || v9 == v24) && (!v6 || *(_WORD *)(result + 14) == v25) )
      {
        v10 = a3;
        v11 = 20;
        v12 = (_DWORD *)(result + 32);
        do
        {
          if ( *v12 != *v10 )
            goto LABEL_18;
          v11 -= 4;
          ++v10;
          ++v12;
        }
        while ( v11 >= 4 );
        if ( !v11 )
        {
LABEL_27:
          v23 = 0;
          goto LABEL_28;
        }
LABEL_18:
        v13 = *(_BYTE *)v12 - *(_BYTE *)v10;
        if ( *(_BYTE *)v12 == *(_BYTE *)v10 )
        {
          v14 = v11 - 1;
          v15 = (char *)v10 + 1;
          v16 = (char *)v12 + 1;
          if ( !v14 )
            goto LABEL_27;
          v13 = *v16 - *v15;
          if ( *v16 == *v15 )
          {
            v17 = v14 - 1;
            v18 = v15 + 1;
            v19 = v16 + 1;
            if ( !v17 )
              goto LABEL_27;
            v13 = *v19 - *v18;
            if ( *v19 == *v18 )
            {
              v20 = v18 + 1;
              v21 = v19 + 1;
              if ( v17 == 1 )
                goto LABEL_27;
              v22 = *v20;
              v13 = *v21 - v22;
              if ( *v21 == v22 )
                goto LABEL_27;
            }
          }
        }
        v23 = 1;
        if ( v13 <= 0 )
          v23 = -1;
LABEL_28:
        if ( !v23 )
          return result;
        v7 = v26;
        v4 = a2;
        v6 = a4;
      }
      ++v5;
      result += 8644;
    }
    while ( v5 < v7 );
  }
  return 0;
}

//----- (10008060) --------------------------------------------------------
signed int __thiscall sub_10008060(int this)
{
  return *(_BYTE *)(this + 12) != 2 ? 0 : 2;
}

//----- (10008070) --------------------------------------------------------
char __usercall sub_10008070@<al>(char *a1@<esi>)
{
  char result; // al@1
  int v2; // [sp+0h] [bp-4h]@0

  sub_10001F90(v2);
  result = *a1;
  if ( (unsigned __int8)*a1 < 1u || (unsigned __int8)result > 4u )
  {
    result = sub_10042930("..\\lib\\atn\\atn_cotp.c", 2475, 0, "invld init cdt cfg");
    *a1 = 4;
  }
  return result;
}

//----- (100080A0) --------------------------------------------------------
int __usercall sub_100080A0@<eax>(_BYTE *a1@<edx>, int a2@<ecx>, unsigned int a3)
{
  unsigned int v3; // eax@1
  int result; // eax@2

  v3 = *(_BYTE *)(a2 + 1);
  if ( v3 <= a3 )
  {
    switch ( v3 )
    {
      case 0u:
        result = 0;
        *a1 = 0;
        break;
      case 1u:
        result = *(_BYTE *)(a2 + 2);
        *a1 = 0;
        break;
      case 2u:
        result = (unsigned __int16)(*(_BYTE *)(a2 + 3) + (*(_BYTE *)(a2 + 2) << 8));
        *a1 = 0;
        break;
      case 3u:
        result = *(_BYTE *)(a2 + 4) + ((*(_BYTE *)(a2 + 3) + (*(_BYTE *)(a2 + 2) << 8)) << 8);
        *a1 = 0;
        break;
      default:
        result = *(_BYTE *)(a2 + 5)
               + ((*(_BYTE *)(a2 + 4) + ((*(_BYTE *)(a2 + 3) + (*(_BYTE *)(a2 + 2) << 8)) << 8)) << 8);
        *a1 = 0;
        break;
    }
  }
  else
  {
    *a1 = -118;
    result = 0;
  }
  return result;
}

//----- (10008140) --------------------------------------------------------
char __usercall sub_10008140@<al>(int a1@<eax>)
{
  char result; // al@2

  if ( *(_DWORD *)(a1 + 36) )
    result = 0;
  else
    result = ((*(_BYTE *)(a1 + 2) & 2) != 0) + 1;
  return result;
}

//----- (10008160) --------------------------------------------------------
signed __int16 __usercall sub_10008160@<ax>(int a1@<edi>, int a2@<esi>)
{
  signed __int16 result; // ax@1

  *(_WORD *)a2 = *(_WORD *)(a1 + 88);
  result = sub_100039F0(a1 + 98);
  *(_WORD *)(a2 + 2) = result;
  *(_BYTE *)(a2 + 4) = *(_BYTE *)(a1 + 12);
  return result;
}

//----- (10008180) --------------------------------------------------------
int __usercall sub_10008180@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<edi>, int a4)
{
  int v4; // esi@1
  int v5; // esi@1
  signed int v6; // ebp@1
  int result; // eax@2
  int v8; // [sp+0h] [bp-10h]@0

  v4 = a2;
  *(_DWORD *)(a2 + 16) = a1;
  *(_BYTE *)(a2 + 13) = 0;
  *(_DWORD *)(a2 + 248) = a3;
  *(_DWORD *)(a2 + 8596) = sub_10042D40(a4, v8);
  *(_DWORD *)(v4 + 8600) = 0;
  *(_DWORD *)(v4 + 4480) = v4 + 4476;
  *(_DWORD *)(v4 + 4476) = v4 + 4476;
  v5 = v4 + 4400;
  v6 = 4;
  do
  {
    *(_DWORD *)(v5 - 4) = 0;
    *(_DWORD *)v5 = 0;
    result = sub_10042D40(a4, a3);
    *(_DWORD *)(v5 + 4) = result;
    *(_DWORD *)(v5 + 8) = 0;
    *(_DWORD *)(v5 + 12) = 0;
    v5 += 20;
    --v6;
  }
  while ( v6 );
  return result;
}

//----- (100081F0) --------------------------------------------------------
bool __fastcall sub_100081F0(int a1, int a2)
{
  unsigned int v2; // eax@1
  _DWORD *v4; // ecx@3
  _DWORD *v5; // edx@3
  int v6; // esi@7
  int v7; // eax@8
  _BYTE *v8; // ecx@8
  _BYTE *v9; // edx@8
  int v10; // eax@10
  _BYTE *v11; // ecx@10
  _BYTE *v12; // edx@10
  _BYTE *v13; // ecx@12
  _BYTE *v14; // edx@12
  signed int v15; // eax@14

  v2 = *(_BYTE *)(a2 + 1);
  if ( v2 != *(_DWORD *)(a1 + 52) )
    return 0;
  v4 = (_DWORD *)(a1 + 20);
  v5 = (_DWORD *)(a2 + 2);
  if ( v2 < 4 )
  {
LABEL_6:
    if ( !v2 )
    {
LABEL_16:
      v15 = 0;
      return v15 == 0;
    }
  }
  else
  {
    while ( *v5 == *v4 )
    {
      v2 -= 4;
      ++v4;
      ++v5;
      if ( v2 < 4 )
        goto LABEL_6;
    }
  }
  v6 = *(_BYTE *)v5 - *(_BYTE *)v4;
  if ( *(_BYTE *)v5 == *(_BYTE *)v4 )
  {
    v7 = v2 - 1;
    v8 = (char *)v4 + 1;
    v9 = (char *)v5 + 1;
    if ( !v7 )
      goto LABEL_16;
    v6 = *v9 - *v8;
    if ( *v9 == *v8 )
    {
      v10 = v7 - 1;
      v11 = v8 + 1;
      v12 = v9 + 1;
      if ( !v10 )
        goto LABEL_16;
      v6 = *v12 - *v11;
      if ( *v12 == *v11 )
      {
        v13 = v11 + 1;
        v14 = v12 + 1;
        if ( v10 == 1 )
          goto LABEL_16;
        v6 = *v14 - *v13;
        if ( *v14 == *v13 )
          goto LABEL_16;
      }
    }
  }
  v15 = 1;
  if ( v6 <= 0 )
    return 0;
  return v15 == 0;
}

//----- (100082A0) --------------------------------------------------------
int __cdecl sub_100082A0(int a1)
{
  int result; // eax@1

  result = a1;
  if ( *(_BYTE *)(a1 + 13) == 5 )
    *(_BYTE *)(a1 + 13) = 0;
  return result;
}

//----- (100082B0) --------------------------------------------------------
int __usercall sub_100082B0@<eax>(int a1@<edi>, int a2@<esi>, char a3)
{
  int result; // eax@2

  sub_100021C0(*(_DWORD *)(a2 + 16) + 1076, a2 + 32, 0, *(_BYTE *)(a2 + 96), a2 + 98, a1 + 12, *(_DWORD *)a1);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a2 + 16) + 1028);
  if ( a3 )
  {
    result = 1;
    *(_DWORD *)(a1 + 4) = 1;
  }
  else
  {
    result = *(_DWORD *)(a1 + 4) + 1;
    *(_DWORD *)(a1 + 4) = result;
  }
  return result;
}

//----- (10008300) --------------------------------------------------------
char __usercall sub_10008300@<al>(_BYTE *a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>, int a4, int a5)
{
  if ( a1 )
  {
    if ( *a1 == -61 )
      LOBYTE(a1) = sub_1000A400(a3, a2, a1 - a3 + 2);
    else
      LOBYTE(a1) = sub_1000A520((int)(a1 + 2), a3, a2, a4, a5);
  }
  return (unsigned int)a1;
}

//----- (10008340) --------------------------------------------------------
signed int __usercall sub_10008340@<eax>(signed int result@<eax>, int a2@<ecx>)
{
  *(_BYTE *)(a2 + 239) = result;
  result = (unsigned __int8)result;
  if ( (unsigned __int8)result > 4u )
    result = 4;
  *(_BYTE *)(a2 + 240) = result;
  return result;
}

//----- (10008360) --------------------------------------------------------
unsigned int __usercall sub_10008360@<eax>(unsigned int result@<eax>, int a2@<ecx>)
{
  if ( result <= 0x493E0 )
  {
    if ( result >= 0x2EE0 )
      *(_DWORD *)(a2 + 8624) = result;
    else
      *(_DWORD *)(a2 + 8624) = 12000;
  }
  else
  {
    *(_DWORD *)(a2 + 8624) = 300000;
  }
  return result;
}

//----- (10008390) --------------------------------------------------------
int __usercall sub_10008390@<eax>(int a1@<ecx>, int a2@<ebx>, char a3)
{
  int v3; // ebp@3
  signed int v4; // esi@3
  int v5; // edi@3
  int v6; // edx@5
  int v7; // eax@5
  int result; // eax@6

  if ( a3 && *(_DWORD *)(a2 + 4) == 1 )
  {
    v3 = *(_DWORD *)(a1 + 8628);
    v4 = *(_DWORD *)(*(_DWORD *)(a1 + 16) + 1028) - *(_DWORD *)(a2 + 8) - v3;
    v5 = v3 + v4 / 8;
    if ( v4 < 0 )
      v4 = -v4;
    v6 = *(_DWORD *)(a1 + 8608);
    v7 = *(_DWORD *)(a1 + 8632) + (v4 - *(_DWORD *)(a1 + 8632)) / 4;
    *(_DWORD *)(a1 + 8632) = v7;
    *(_DWORD *)(a1 + 8628) = v5;
    sub_10008360(v5 + v6 + 4 * v7, a1);
  }
  result = 0;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  return result;
}

//----- (10008410) --------------------------------------------------------
unsigned __int8 __fastcall sub_10008410(int a1, int a2)
{
  unsigned __int8 v2; // al@1
  unsigned __int8 result; // al@2
  int v4; // edx@3
  unsigned __int8 v5; // bl@3
  unsigned int v6; // edx@4
  bool v7; // cf@4
  bool v8; // zf@4
  unsigned __int8 v9; // bl@5
  int v10; // eax@7

  v2 = *(_BYTE *)(a1 + 2);
  if ( v2 < *(_BYTE *)a1 )
  {
    result = v2 + 1;
    *(_BYTE *)(a1 + 2) = result;
    return result;
  }
  *(_DWORD *)(a1 + 4) += *(_DWORD *)(a2 + 8);
  v4 = *(_DWORD *)(a2 + 12);
  result = ++*(_BYTE *)(a1 + 3);
  *(_DWORD *)(a1 + 8) += v4;
  v5 = *(_BYTE *)(a1 + 1);
  if ( result >= v5 )
  {
    v6 = 50 * *(_DWORD *)(a1 + 4) / 0x64u;
    v7 = *(_DWORD *)(a1 + 8) < v6;
    v8 = *(_DWORD *)(a1 + 8) == v6;
    *(_BYTE *)a1 = v5;
    if ( v7 || v8 )
    {
      v9 = v5 + 1;
      *(_BYTE *)(a1 + 1) = v9;
      if ( v9 > 4u )
      {
        result = 0;
        *(_BYTE *)(a1 + 1) = 4;
        *(_BYTE *)(a1 + 2) = 0;
        *(_BYTE *)(a1 + 3) = 0;
        *(_DWORD *)(a1 + 4) = 0;
        *(_DWORD *)(a1 + 8) = 0;
        return result;
      }
    }
    else
    {
      v10 = 95 * v5 / 100;
      *(_BYTE *)(a1 + 1) = v10;
      if ( !(_BYTE)v10 )
        *(_BYTE *)(a1 + 1) = 1;
    }
    result = 0;
    *(_BYTE *)(a1 + 2) = 0;
    *(_BYTE *)(a1 + 3) = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
  }
  return result;
}

//----- (100084B0) --------------------------------------------------------
int __usercall sub_100084B0@<eax>(int a1@<esi>)
{
  unsigned __int8 v1; // cl@1
  char v2; // al@1
  int v3; // edi@1
  int result; // eax@3

  v1 = *(_BYTE *)(a1 + 21);
  v2 = *(_BYTE *)(a1 + 4);
  v3 = *(_BYTE *)(a1 + 8604);
  if ( ((v2 - (unsigned __int8)((v3 + *(_BYTE *)(a1 + 21)) % 128)) & 0x7Fu) <= 0xF )
    v1 = (v2 - *(_BYTE *)(a1 + 8604)) & 0x7F;
  *(_BYTE *)(a1 + 3) = v1;
  result = (v3 + v1) % 128;
  *(_BYTE *)(a1 + 4) = result;
  return result;
}

//----- (10008510) --------------------------------------------------------
char __usercall sub_10008510@<al>(int a1@<esi>, int a2, unsigned int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // edi@1
  unsigned int v7; // eax@1
  unsigned int v8; // ecx@1
  unsigned int v9; // ebx@1
  char result; // al@5
  unsigned int v11; // ecx@6
  unsigned __int8 v12; // al@7
  char *v13; // edi@7
  unsigned int v14; // ebp@7
  int v15; // eax@14
  int v16; // eax@22
  bool v17; // zf@30
  int v18; // eax@34
  char v19; // [sp+Fh] [bp-5h]@6
  unsigned int v20; // [sp+10h] [bp-4h]@6

  v6 = (_BYTE *)a2;
  *(_BYTE *)a1 = 2;
  *(_BYTE *)(a1 + 1) = 7;
  *(_BYTE *)(a1 + 2) = 1;
  *(_BYTE *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 8) = 20000;
  *(_WORD *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  v7 = *(_BYTE *)a2;
  v8 = dword_10095964[2 * a4];
  v9 = v7 + 1;
  if ( v7 < v8 || v9 > a3 )
    return -118;
  if ( a4 == 14 && (*(_BYTE *)(a2 + 6) & 0xF0u) > 0x40 )
    return -123;
  v11 = v8 + 1;
  v19 = 0;
  v20 = v11;
  if ( v11 < v9 )
  {
    while ( 1 )
    {
      v12 = v6[v11 + 1];
      v13 = &v6[v11];
      v14 = v12 + 2;
      if ( v14 > v9 - v20 )
        return -118;
      switch ( *v13 )
      {
        case 8:
          if ( v12 < 4u )
            return -118;
          *(_DWORD *)(a1 + 36) = v13 + 2;
          *(_BYTE *)a1 = 0;
          goto LABEL_13;
        case 0x85:
          *(_DWORD *)(a1 + 8) = sub_100080A0(&v19, (int)v13, 3u);
          goto LABEL_12;
        case 0x86:
        case 0x88:
        case 0x89:
        case 0x8B:
        case 0x8C:
        case 0x8F:
        case 0xC4:
        case 0xC5:
        case 0xC7:
        case 0xE0:
        case 0xF0:
          goto LABEL_13;
        case 0x87:
          *(_BYTE *)(a1 + 20) = 1;
          *(_WORD *)(a1 + 22) = sub_100080A0(&v19, (int)v13, 2u);
          goto LABEL_12;
        case 0x8A:
          *(_WORD *)(a1 + 4) = sub_100080A0(&v19, (int)v13, 2u);
          goto LABEL_12;
        case 0xC0:
          v16 = sub_100080A0(&v19, (int)v13, 1u);
          if ( (unsigned int)(v16 - 7) > 6 )
            return -123;
          *(_BYTE *)(a1 + 1) = v16;
          goto LABEL_12;
        case 0xC1:
          if ( a4 == 7 )
            goto LABEL_13;
          if ( v12 > 0x20u )
            return -118;
          *(_DWORD *)(a1 + 24) = v13;
          goto LABEL_13;
        case 0xC2:
          if ( v12 > 0x20u )
            return -118;
          *(_DWORD *)(a1 + 28) = v13;
          goto LABEL_13;
        case 0xC3:
          if ( !sub_1000A470((_BYTE *)a2, a3) )
            goto LABEL_38;
          v17 = *(_DWORD *)(a1 + 36) == 0;
          *(_DWORD *)(a1 + 32) = v13 + 2;
          if ( v17 )
            *(_BYTE *)a1 = 1;
          goto LABEL_13;
        case 0xC6:
          *(_BYTE *)(a1 + 2) = sub_100080A0(&v19, (int)v13, 1u);
          goto LABEL_12;
        case 0xF2:
          if ( v12 > 4u )
            goto LABEL_13;
          v18 = sub_100080A0(&v19, (int)v13, v12);
          if ( (unsigned int)(v18 - 360000) <= 0x560F40 )
          {
            *(_BYTE *)(a1 + 12) = 1;
            *(_DWORD *)(a1 + 16) = v18;
          }
LABEL_12:
          result = v19;
          if ( !v19 )
            goto LABEL_13;
          return result;
        default:
          if ( a4 != 14 )
            return -123;
          sub_10042450(7, -116, v13, v12 + 2);
LABEL_13:
          v6 = (_BYTE *)a2;
          v11 = v14 + v20;
          v20 += v14;
          if ( v20 >= v9 )
            goto LABEL_14;
          break;
      }
    }
  }
LABEL_14:
  v15 = *(_DWORD *)(a1 + 36);
  if ( v15 && !sub_1000A5B0(v6, a3, *(_DWORD *)(a1 + 32), v15, a5, a6) )
  {
LABEL_38:
    result = -114;
  }
  else
  {
    if ( a4 != 14 && *(_DWORD *)(a1 + 36) && *(_DWORD *)(a1 + 32) )
      return -123;
    result = 0;
  }
  return result;
}
// 10095964: using guessed type int dword_10095964[];

//----- (100088C0) --------------------------------------------------------
int __usercall sub_100088C0@<eax>(int a1@<eax>, int a2@<edx>, __int16 a3@<cx>, int a4@<esi>, char a5, char a6, void *a7, size_t a8, int a9, int a10)
{
  int v10; // edi@1
  _BYTE *v11; // ebx@1
  int v12; // edi@1

  *(_BYTE *)a4 = 6;
  *(_BYTE *)(a4 + 1) = -128;
  *(_BYTE *)(a4 + 2) = HIBYTE(a3);
  *(_BYTE *)(a4 + 3) = a3;
  *(_BYTE *)(a4 + 5) = a1;
  v10 = a2;
  *(_BYTE *)(a4 + 4) = BYTE1(a1);
  *(_BYTE *)(a4 + 6) = a5;
  LOBYTE(a1) = a6;
  v11 = (_BYTE *)sub_10007B80(a2, a4, a1);
  v12 = sub_1000A320(a4, v10, a7, a8);
  sub_10008300(v11, v12, (_BYTE *)a4, a9, a10);
  return v12;
}

//----- (10008920) --------------------------------------------------------
int __cdecl sub_10008920(int a1, __int16 a2, int a3, int a4, int a5, int a6, unsigned int a7)
{
  int v7; // ebp@8
  int v8; // esi@9
  int v9; // ebx@9
  int result; // eax@11
  char v11; // [sp+Ch] [bp-Ch]@8

  if ( a7 < a4 * (6 * a5 + 8644) + 1356 )
    sub_10042930("..\\lib\\atn\\atn_cotp.c", 1218, 1, 0);
  if ( a3 && *(_DWORD *)a3 && *(_DWORD *)(a3 + 4) && *(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 12) )
  {
    sub_10042D90((int)&v11, a6, a7);
    v7 = sub_10042D40((int)&v11, 1356);
    *(_DWORD *)(v7 + 1072) = a1;
    *(_WORD *)(v7 + 1024) = sub_10042400(a2);
    *(_DWORD *)(v7 + 1028) = sub_1007C040();
    *(_DWORD *)(v7 + 1040) = *(_DWORD *)a3;
    *(_DWORD *)(v7 + 1044) = *(_DWORD *)(a3 + 4);
    *(_DWORD *)(v7 + 1048) = *(_DWORD *)(a3 + 8);
    *(_DWORD *)(v7 + 1052) = *(_DWORD *)(a3 + 12);
    *(_DWORD *)(v7 + 1056) = *(_DWORD *)(a3 + 16);
    sub_10008070((char *)(v7 + 1060));
    sub_10002130(a2, v7 + 1076);
    *(_WORD *)(v7 + 1096) = (unsigned __int8)a2;
    *(_DWORD *)(v7 + 1032) = sub_10042D40((int)&v11, 8644 * a4);
    *(_DWORD *)(v7 + 1036) = a4;
    if ( a4 )
    {
      v8 = 0;
      v9 = a4;
      do
      {
        sub_10008180(v7, v8 + *(_DWORD *)(v7 + 1032), a5, (int)&v11);
        v8 += 8644;
        --v9;
      }
      while ( v9 );
    }
    result = v7;
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_cotp.c", 1232, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10008AB0) --------------------------------------------------------
int __usercall sub_10008AB0@<eax>(int a1@<eax>, _DWORD *a2@<ecx>, char a3@<bl>, int a4)
{
  int result; // eax@2

  if ( a3 == 14 )
  {
    result = sub_10007F00(a1, 0, a2, a4 + 4);
    if ( result )
    {
      if ( !*(_BYTE *)(result + 13) )
        result = 0;
    }
  }
  else if ( a3 == 8 || a3 == 12 )
  {
    result = sub_10007F00(a1, a4 + 2, a2, a4 + 4);
  }
  else
  {
    result = sub_10007F00(a1, a4 + 2, a2, 0);
    if ( result
      && *(_BYTE *)(result + 13) == 2
      && a3 == 13
      && *(_WORD *)(result + 14) != *(_BYTE *)(a4 + 5) + (*(_BYTE *)(a4 + 4) << 8) )
    {
      result = 0;
    }
  }
  return result;
}

//----- (10008B30) --------------------------------------------------------
char __usercall sub_10008B30@<al>(int a1@<eax>, int a2@<edi>, int a3@<esi>)
{
  int v3; // ebx@1
  int v4; // ecx@1
  char result; // al@4
  int v6; // edx@5
  char v7; // bl@9
  unsigned __int8 v8; // dl@11
  char v9; // [sp+7h] [bp-1h]@2

  v3 = a1;
  LOWORD(a1) = *(_BYTE *)(a1 + 5) + (*(_BYTE *)(a1 + 4) << 8);
  *(_WORD *)(a2 + 14) = a1;
  v4 = *(_DWORD *)(a3 + 24);
  if ( v4 && ((a1 = sub_100080A0(&v9, v4, 1u), a1 != *(_WORD *)(*(_DWORD *)(a2 + 16) + 1096)) || v9)
    || (v6 = *(_DWORD *)(a3 + 28)) != 0 && !sub_100081F0(a2 + 32, v6) )
  {
    result = -123;
  }
  else
  {
    LOBYTE(a1) = *(_BYTE *)(v3 + 1) & 0xF;
    sub_10008340(a1, a2);
    *(_DWORD *)(a2 + 8608) = *(_DWORD *)(a3 + 8);
    if ( *(_BYTE *)(a3 + 12) )
      *(_DWORD *)(a2 + 8616) = *(_DWORD *)(a3 + 16);
    v7 = *(_BYTE *)(v3 + 6);
    if ( (v7 & 0xF0) != 64
      || v7 & 2
      || (v8 = *(_BYTE *)(a3 + 1), v8 > *(_BYTE *)(a2 + 90))
      || (*(_BYTE *)(a2 + 90) = v8,
          *(_DWORD *)(a2 + 92) = 1 << *(_BYTE *)(a3 + 1),
          *(_BYTE *)(a2 + 12) = sub_10008140(a3),
          *(_BYTE *)(a3 + 2) & 0x71) )
    {
      result = -126;
    }
    else
    {
      if ( *(_BYTE *)(a3 + 20) )
        *(_WORD *)(a2 + 88) = *(_WORD *)(a3 + 22);
      result = 0;
    }
  }
  return result;
}

//----- (10008C10) --------------------------------------------------------
void __cdecl sub_10008C10(int a1, _BYTE *a2, size_t a3, int a4)
{
  int v4; // esi@1
  unsigned __int8 v5; // bl@4
  int v6; // eax@4
  int v7; // edi@7
  unsigned __int8 v8; // [sp+10h] [bp+4h]@4

  v4 = a1;
  if ( *(_BYTE *)(a1 + 13) == 4 )
  {
    sub_10008390(a1, a1 + 252, 1);
    *(_BYTE *)(a1 + 13) = 2;
  }
  if ( *(_BYTE *)(a1 + 13) == 2 )
  {
    v5 = a2[4] & 0x7F;
    v8 = a2[4] & 0x7F;
    if ( sub_10007E80(v5, *(_WORD *)(a4 + 4), v4, a2[1] & 0xF) )
    {
      v7 = *(_BYTE *)(v4 + 238);
      if ( v7 != v5 )
      {
        do
        {
          v6 = sub_10008390(v4, 1036 * (v7 & 3) + v4 + 252, v7 == ((v5 - 1) & 0x7F));
          v7 = ((_BYTE)v7 + 1) & 0x7F;
        }
        while ( v7 != v5 );
        v5 = v8;
      }
      *(_BYTE *)(v4 + 238) = v5;
      LOBYTE(v6) = a2[1] & 0xF;
      sub_10008340(v6, v4);
    }
    else
    {
      sub_10042450(7, 0, a2, a3);
    }
  }
}

//----- (10008CF0) --------------------------------------------------------
char __usercall sub_10008CF0@<al>(signed int a1@<eax>, int a2@<ecx>, int a3, int a4)
{
  int v4; // esi@1
  int v5; // edi@1
  int v6; // edx@1
  unsigned __int8 v8; // al@6
  int v9; // ecx@12
  char v10; // [sp+Fh] [bp-9h]@13
  char v11; // [sp+10h] [bp-8h]@18

  v4 = a1;
  LOBYTE(a1) = *(_BYTE *)(a3 + 1) & 0xF;
  v5 = a2;
  sub_10008340(a1, a2);
  *(_BYTE *)(v5 + 12) = sub_10008140(v4);
  if ( (*(_BYTE *)(v6 + 6) & 0xF0) != 64 )
    return -126;
  *(_DWORD *)(v5 + 8608) = *(_DWORD *)(v4 + 8);
  if ( *(_BYTE *)(v4 + 20) )
    *(_WORD *)(v5 + 88) = *(_WORD *)(v4 + 22);
  else
    *(_WORD *)(v5 + 88) = 14;
  *(_BYTE *)(v5 + 96) = 14 - *(_BYTE *)(v5 + 88);
  v8 = *(_BYTE *)(v4 + 1);
  if ( v8 > 0xAu )
    *(_BYTE *)(v5 + 90) = 10;
  else
    *(_BYTE *)(v5 + 90) = v8;
  *(_DWORD *)(v5 + 92) = 1 << *(_BYTE *)(v5 + 90);
  if ( *(_DWORD *)(v4 + 24) )
  {
    memcpy((void *)(v5 + 52), (const void *)(*(_DWORD *)(v4 + 24) + 2), *(_BYTE *)(*(_DWORD *)(v4 + 24) + 1));
    *(_DWORD *)(v5 + 84) = *(_BYTE *)(*(_DWORD *)(v4 + 24) + 1);
    *(_BYTE *)(v5 + 1) = 1;
  }
  else
  {
    *(_DWORD *)(v5 + 84) = 0;
  }
  v9 = *(_DWORD *)(v4 + 28);
  if ( v9 )
  {
    if ( *(_WORD *)(*(_DWORD *)(v5 + 16) + 1096) != sub_100080A0(&v10, v9, 2u) || v10 )
      return 3;
    *(_BYTE *)v5 = 1;
  }
  if ( *(_BYTE *)(v4 + 12) == 1 )
  {
    *(_DWORD *)(v5 + 8616) = *(_DWORD *)(v4 + 16);
    *(_BYTE *)(v5 + 2) = 1;
  }
  *(_DWORD *)(v5 + 8612) = *(_DWORD *)(v5 + 8616);
  *(_BYTE *)(v5 + 13) = 3;
  sub_10008160(v5, (int)&v11);
  (*(void (__cdecl **)(_DWORD, int, char *, int, int))(*(_DWORD *)(v5 + 16) + 1040))(
    *(_DWORD *)(*(_DWORD *)(v5 + 16) + 1072),
    v5,
    &v11,
    *(_BYTE *)a3 + a3 + 1,
    a4 - *(_BYTE *)a3 - 1);
  return 0;
}

//----- (10008E40) --------------------------------------------------------
int __usercall sub_10008E40@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // edi@1
  _BYTE *v3; // ebx@1
  int v4; // eax@1
  _BYTE *v5; // eax@1
  unsigned int v6; // edi@1
  int result; // eax@1
  char v8; // dl@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 16);
  sub_100084B0(a1);
  *(_BYTE *)(v2 + 1098) = 4;
  v3 = (_BYTE *)(v2 + 1098);
  *(_BYTE *)(v2 + 1099) = (*(_BYTE *)(v1 + 3) & 0xF) + 96;
  v4 = *(_WORD *)(v1 + 14);
  *(_BYTE *)(v2 + 1100) = BYTE1(v4);
  *(_BYTE *)(v2 + 1101) = v4;
  *(_BYTE *)(v2 + 1102) = *(_BYTE *)(v1 + 8604);
  LOBYTE(v4) = *(_BYTE *)(v1 + 12);
  v5 = (_BYTE *)sub_10007B80(255, v2 + 1098, v4);
  v6 = *(_BYTE *)(v2 + 1098) + 1;
  sub_10008300(v5, *v3 + 1, v3, v1 + 32, *(_DWORD *)(v1 + 16) + 1076);
  sub_100021C0(*(_DWORD *)(v1 + 16) + 1076, v1 + 32, 0, *(_BYTE *)(v1 + 96), v1 + 98, (int)v3, v6);
  result = *(_BYTE *)(v1 + 3);
  v8 = *(_BYTE *)(v1 + 8604);
  *(_DWORD *)(v1 + 8640) = *(_DWORD *)(*(_DWORD *)(v1 + 16) + 1028);
  *(_BYTE *)(v1 + 236) = 0;
  *(_BYTE *)(v1 + 242) = v8;
  *(_BYTE *)(v1 + 241) = result;
  return result;
}

//----- (10008F10) --------------------------------------------------------
int __usercall sub_10008F10@<eax>(int a1@<eax>, void *a2, size_t a3)
{
  int v3; // esi@1
  int v4; // edi@1
  _BYTE *v5; // ebp@1
  __int16 v6; // ax@1
  int v7; // eax@1
  int v8; // eax@1
  size_t v9; // ebx@4
  void *v10; // eax@4
  char v11; // al@6
  int v12; // eax@8
  _BYTE *v14; // [sp+10h] [bp-4h]@1

  v3 = a1;
  v4 = a1 + 252;
  *(_BYTE *)(v4 + 12) = 6;
  v5 = (_BYTE *)(a1 + 264);
  *(_BYTE *)(v4 + 13) = (*(_BYTE *)(a1 + 3) & 0xF) - 48;
  v6 = *(_WORD *)(a1 + 14);
  *(_BYTE *)(v4 + 14) = HIBYTE(v6);
  *(_BYTE *)(v4 + 15) = v6;
  v7 = *(_WORD *)(v3 + 244);
  *(_BYTE *)(v4 + 16) = BYTE1(v7);
  *(_BYTE *)(v4 + 17) = v7;
  LOBYTE(v7) = *(_BYTE *)(v3 + 12);
  v8 = sub_10007B80(1024, v4 + 12, v7);
  *(_BYTE *)(v4 + 18) = 64;
  v14 = (_BYTE *)v8;
  if ( *(_BYTE *)v3 )
    sub_10007E50(v3, -62, v4);
  if ( *(_BYTE *)(v3 + 1) )
  {
    v9 = *(_DWORD *)(v3 + 84);
    v10 = sub_1000A370((int)v5, 1024, -63, *(_DWORD *)(v3 + 84));
    if ( v10 )
      memcpy(v10, (const void *)(v3 + 52), v9);
  }
  sub_10007B10(1024, (int)v5, -64, *(_BYTE *)(v3 + 90));
  v11 = sub_10008060(v3);
  sub_10007B10(1024, (int)v5, -58, v11);
  sub_10007B30(1024, -123, 1000, (int)v5);
  sub_10007B30(1024, -121, *(_WORD *)(v3 + 88), (int)v5);
  if ( *(_BYTE *)(v3 + 2) )
    sub_10007B50(1024, -14, *(_DWORD *)(v3 + 8612), (int)v5);
  v12 = sub_1000A320((int)v5, 1024, a2, a3);
  *(_DWORD *)v4 = v12;
  sub_10008300(v14, v12, v5, v3 + 32, *(_DWORD *)(v3 + 16) + 1076);
  return sub_100082B0(v4, v3, 1);
}

//----- (10009050) --------------------------------------------------------
int __usercall sub_10009050@<eax>(int a1@<eax>, void *a2, size_t a3)
{
  int v3; // esi@1
  int v4; // edi@1
  _BYTE *v5; // ebp@1
  __int16 v6; // ax@1
  int v7; // eax@1
  int v8; // edx@1
  bool v9; // zf@2
  int v10; // eax@2
  int v11; // eax@5
  int v12; // ebx@5
  size_t v13; // ebx@6
  void *v14; // eax@6
  int v15; // eax@8
  char v17; // [sp+10h] [bp-Ch]@3
  _BYTE *v18; // [sp+14h] [bp-8h]@3
  _BYTE *v19; // [sp+18h] [bp-4h]@3

  v3 = a1;
  v4 = a1 + 252;
  *(_BYTE *)(v4 + 12) = 6;
  v5 = (_BYTE *)(a1 + 264);
  *(_BYTE *)(v4 + 13) = (*(_BYTE *)(a1 + 3) & 0xF) - 32;
  *(_BYTE *)(v4 + 14) = 0;
  *(_BYTE *)(v4 + 15) = 0;
  v6 = *(_WORD *)(a1 + 244);
  *(_BYTE *)(v4 + 16) = HIBYTE(v6);
  *(_BYTE *)(v4 + 17) = v6;
  v7 = *(_BYTE *)(v3 + 12);
  v8 = v4 + 12;
  if ( *(_BYTE *)(v3 + 12) )
  {
    v10 = v7 - 1;
    v9 = v10 == 0;
    LOBYTE(v10) = 1;
    if ( v9 )
    {
      v19 = (_BYTE *)sub_10007B80(1024, v8, v10);
      v18 = 0;
      v17 = 0;
    }
    else
    {
      v19 = (_BYTE *)sub_10007B80(1024, v8, v10);
      v18 = 0;
      v17 = 2;
    }
  }
  else
  {
    LOBYTE(v7) = 1;
    v11 = sub_10007B80(1024, v8, v7);
    v12 = v11;
    LOBYTE(v11) = 0;
    v19 = (_BYTE *)v12;
    v18 = (_BYTE *)sub_10007B80(1024, (int)v5, v11);
    v17 = 0;
    *(_WORD *)(v12 + 2) = 0;
  }
  *(_BYTE *)(v4 + 18) = 64;
  sub_10007E50(v3, -63, v4);
  v13 = *(_DWORD *)(v3 + 84);
  v14 = sub_1000A370((int)v5, 1024, -62, *(_DWORD *)(v3 + 84));
  if ( v14 )
    memcpy(v14, (const void *)(v3 + 52), v13);
  sub_10007B10(1024, (int)v5, -64, *(_BYTE *)(v3 + 90));
  sub_10007B10(1024, (int)v5, -58, v17);
  sub_10007B30(1024, -123, 1000, (int)v5);
  sub_10007B30(1024, -121, *(_WORD *)(v3 + 88), (int)v5);
  sub_10007B50(1024, -14, *(_DWORD *)(v3 + 8612), (int)v5);
  sub_10007B10(1024, (int)v5, -60, 1);
  v15 = sub_1000A320((int)v5, 1024, a2, a3);
  *(_DWORD *)v4 = v15;
  sub_10008300(v18, v15, v5, v3 + 32, *(_DWORD *)(v3 + 16) + 1076);
  sub_10008300(v19, *(_DWORD *)v4, v5, v3 + 32, *(_DWORD *)(v3 + 16) + 1076);
  return sub_100082B0(v4, v3, 1);
}

//----- (100091F0) --------------------------------------------------------
size_t __usercall sub_100091F0@<eax>(int a1@<eax>, void *a2, size_t a3)
{
  int v3; // esi@1
  size_t v4; // ebp@1
  int v5; // edi@1
  int v6; // eax@1
  int v7; // eax@1
  int v8; // edx@1
  int v9; // eax@4
  _BYTE *v11; // [sp+18h] [bp+8h]@1

  v3 = a1;
  v4 = a3;
  v5 = 1036 * (*(_BYTE *)(a1 + 237) & 3) + a1 + 252;
  *(_BYTE *)(v5 + 12) = 4;
  *(_BYTE *)(v5 + 13) = -16;
  v6 = *(_WORD *)(a1 + 14);
  *(_BYTE *)(v5 + 14) = BYTE1(v6);
  *(_BYTE *)(v5 + 15) = v6;
  *(_BYTE *)(v5 + 16) = *(_BYTE *)(v3 + 237);
  LOBYTE(v6) = *(_BYTE *)(v3 + 12);
  v7 = sub_10007B80(1024, v5 + 12, v6);
  v8 = *(_BYTE *)(v5 + 12);
  v11 = (_BYTE *)v7;
  if ( v4 <= *(_DWORD *)(v3 + 92) - v8 - 1 )
    *(_BYTE *)(v5 + 16) |= 0x80u;
  else
    v4 = *(_DWORD *)(v3 + 92) - v8 - 1;
  v9 = sub_1000A320(v5 + 12, 1024, a2, v4);
  *(_DWORD *)v5 = v9;
  sub_10008300(v11, v9, (_BYTE *)(v5 + 12), v3 + 32, *(_DWORD *)(v3 + 16) + 1076);
  sub_100082B0(v5, v3, 1);
  *(_BYTE *)(v3 + 237) = (*(_BYTE *)(v3 + 237) + 1) % 128;
  return v4;
}

//----- (100092C0) --------------------------------------------------------
unsigned int __usercall sub_100092C0@<eax>(int a1@<eax>, int a2@<edx>, __int16 a3@<cx>, char a4, int a5, char *a6)
{
  int v6; // esi@1
  _BYTE *v7; // edi@1
  _BYTE *v8; // eax@1
  int v9; // ebx@1

  v6 = a2;
  *(_BYTE *)(a2 + 1098) = 5;
  v7 = (_BYTE *)(a2 + 1098);
  *(_BYTE *)(a2 + 1099) = -64;
  *(_BYTE *)(a2 + 1100) = HIBYTE(a3);
  *(_BYTE *)(a2 + 1101) = a3;
  *(_BYTE *)(a2 + 1103) = a1;
  LOBYTE(a1) = a4;
  *(_BYTE *)(a2 + 1102) = BYTE1(a1);
  v8 = (_BYTE *)sub_10007B80(255, a2 + 1098, a1);
  v6 += 1076;
  v9 = *v7 + 1;
  sub_10008300(v8, v9, v7, a5, v6);
  return sub_100021C0(v6, a5, 0, *a6, (int)(a6 + 2), (int)v7, v9);
}

//----- (10009350) --------------------------------------------------------
int __usercall sub_10009350@<eax>(size_t a1@<edx>, int a2@<ebx>, __int16 a3, int a4, char a5, void *a6)
{
  *(_DWORD *)(a2 + 252) = sub_100088C0(
                            a4,
                            1024,
                            a3,
                            a2 + 264,
                            a5,
                            *(_BYTE *)(a2 + 12),
                            a6,
                            a1,
                            a2 + 32,
                            *(_DWORD *)(a2 + 16) + 1076);
  return sub_100082B0(a2 + 252, a2, 1);
}

//----- (100093A0) --------------------------------------------------------
BOOL __usercall sub_100093A0@<eax>(int a1@<edi>, int a2@<esi>)
{
  for ( ;
        *(_DWORD *)(a2 + 12) > *(_DWORD *)(a2 + 16);
        *(_DWORD *)(a2 + 16) += sub_100091F0(
                                  a1,
                                  (void *)(*(_DWORD *)(a2 + 16) + *(_DWORD *)(a2 + 8)),
                                  *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 16)) )
  {
    if ( (unsigned __int8)((*(_BYTE *)(a1 + 237) - *(_BYTE *)(a1 + 238)) & 0x7F) >= *(_BYTE *)(a1 + 240) )
      break;
  }
  return *(_DWORD *)(a2 + 16) >= *(_DWORD *)(a2 + 12);
}

//----- (10009400) --------------------------------------------------------
int __cdecl sub_10009400(int a1, int a2, int a3, void *a4, size_t a5)
{
  int result; // eax@7
  int v6; // eax@10
  int v7; // esi@10

  if ( a1 && a2 && *(_DWORD *)(a2 + 52) <= 0x20u && a3 && *(_BYTE *)(a3 + 4) < 3u )
  {
    if ( *(_WORD *)a3 <= 0xEu )
    {
      if ( a5 <= 0x20 )
      {
        v6 = sub_10007BB0(a3, a1, 0, 0, (const void *)a2, 0);
        v7 = v6;
        if ( v6 )
        {
          sub_10009050(v6, a4, a5);
          *(_BYTE *)(v7 + 13) = 1;
          result = v7;
        }
        else
        {
          sub_10042930("..\\lib\\atn\\atn_cotp.c", 1060, 0, 0);
          result = 0;
        }
      }
      else
      {
        sub_10042930("..\\lib\\atn\\atn_cotp.c", 1049, 0, 0);
        result = 0;
      }
    }
    else
    {
      sub_10042930("..\\lib\\atn\\atn_cotp.c", 1039, 0, 0);
      result = 0;
    }
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_cotp.c", 1029, 0, 0);
    result = 0;
  }
  return result;
}

//----- (100094E0) --------------------------------------------------------
char __cdecl sub_100094E0(int a1, void *a2, size_t a3)
{
  char result; // al@2

  if ( *(_BYTE *)(a1 + 13) == 3 )
  {
    if ( a3 <= 0x20 )
    {
      result = sub_10008F10(a1, a2, a3);
      *(_BYTE *)(a1 + 13) = 4;
    }
    else
    {
      result = sub_10042930("..\\lib\\atn\\atn_cotp.c", 1108, 0, 0);
    }
  }
  else
  {
    result = sub_10042930("..\\lib\\atn\\atn_cotp.c", 1101, 0, 0);
  }
  return result;
}

//----- (10009540) --------------------------------------------------------
char __cdecl sub_10009540(int a1, void *a2, unsigned int a3)
{
  size_t v3; // edx@1
  char result; // al@4

  v3 = a3;
  if ( a3 > 0x40 )
  {
    sub_10042930("..\\lib\\atn\\atn_cotp.c", 1146, 0, 0);
    v3 = 0;
  }
  switch ( *(_BYTE *)(a1 + 13) )
  {
    case 0:
      result = sub_10042930("..\\lib\\atn\\atn_cotp.c", 1154, 0, 0);
      break;
    case 1:
    case 2:
      result = sub_10009350(v3, a1, *(_WORD *)(a1 + 14), *(_WORD *)(a1 + 244), -128, a2);
      *(_BYTE *)(a1 + 13) = 5;
      break;
    case 3:
      result = sub_10009350(v3, a1, *(_WORD *)(a1 + 14), 0, -128, a2);
      *(_BYTE *)(a1 + 13) = 0;
      break;
    case 4:
      result = sub_10009350(v3, a1, *(_WORD *)(a1 + 14), *(_WORD *)(a1 + 244), -128, a2);
      *(_BYTE *)(a1 + 13) = 5;
      break;
    default:
      result = sub_10042930("..\\lib\\atn\\atn_cotp.c", 1176, 0, 0);
      break;
  }
  return result;
}

//----- (10009630) --------------------------------------------------------
char __cdecl sub_10009630(int a1, void *a2, size_t a3)
{
  int v3; // ecx@0
  char result; // al@2
  char v5; // al@3
  int v6; // esi@6
  _DWORD *v7; // ebx@8
  int *v8; // eax@11

  if ( a3 <= *(_DWORD *)(a1 + 248) )
  {
    v5 = *(_BYTE *)(a1 + 13);
    if ( v5 == 2 || v5 == 4 )
    {
      v6 = sub_10007E20(v3, a1);
      if ( v6 )
      {
        memcpy(*(void **)(v6 + 8), a2, a3);
        *(_DWORD *)(v6 + 12) = a3;
        v7 = (_DWORD *)(a1 + 4476);
        *(_DWORD *)(v6 + 16) = 0;
        if ( (_DWORD *)*v7 != v7 || *(_BYTE *)(a1 + 13) != 2 || !(unsigned __int8)sub_100093A0(a1, v6) )
        {
          v8 = *(int **)(a1 + 4480);
          *(_DWORD *)(a1 + 4480) = v6;
          *(_DWORD *)v6 = v7;
          *(_DWORD *)(v6 + 4) = v8;
          *v8 = v6;
        }
        result = 1;
      }
      else
      {
        sub_10042930("..\\lib\\atn\\atn_cotp.c", 1416, 0, 0);
        result = 0;
      }
    }
    else
    {
      sub_10042930("..\\lib\\atn\\atn_cotp.c", 1405, 0, 0);
      result = 0;
    }
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_cotp.c", 1393, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10009740) --------------------------------------------------------
void *__usercall sub_10009740@<eax>(int a1@<eax>, int a2@<ebx>, int a3@<esi>)
{
  int v3; // eax@2
  void *result; // eax@2
  int v5; // ecx@1
  int v6; // edi@1
  int v7; // eax@1
  size_t v8; // edi@1

  v5 = *(_DWORD *)(a3 + 8600);
  v6 = a1;
  v7 = *(_BYTE *)a2 + 1;
  v8 = v6 - v7;
  if ( *(_DWORD *)(a3 + 248) - v5 >= v8 )
  {
    result = memcpy((void *)(v5 + *(_DWORD *)(a3 + 8596)), (const void *)(a2 + v7), v8);
    *(_DWORD *)(a3 + 8600) += v8;
    if ( *(_BYTE *)(a2 + 4) & 0x80 )
    {
      result = (void *)(*(int (__cdecl **)(_DWORD, int, _DWORD, _DWORD))(*(_DWORD *)(a3 + 16) + 1048))(
                         *(_DWORD *)(*(_DWORD *)(a3 + 16) + 1072),
                         a3,
                         *(_DWORD *)(a3 + 8596),
                         *(_DWORD *)(a3 + 8600));
      *(_DWORD *)(a3 + 8600) = 0;
    }
  }
  else
  {
    sub_10009350(0, a3, *(_WORD *)(a3 + 14), *(_WORD *)(a3 + 244), 0, 0);
    v3 = *(_DWORD *)(a3 + 16);
    *(_BYTE *)(a3 + 13) = 5;
    result = (void *)(*(int (__cdecl **)(_DWORD, int, _DWORD, _DWORD))(v3 + 1052))(*(_DWORD *)(v3 + 1072), a3, 0, 0);
  }
  return result;
}

//----- (100097C0) --------------------------------------------------------
char __cdecl sub_100097C0(int a1, void *a2, size_t a3, int a4)
{
  int v4; // edi@1
  char result; // al@1
  int v6; // eax@8
  char v7; // [sp+8h] [bp-8h]@7
  char v8; // [sp+14h] [bp+4h]@6

  v4 = a1;
  result = *(_BYTE *)(a1 + 13);
  if ( result == 1 )
  {
    sub_10008390(a1, a1 + 252, 1);
    v8 = sub_10008B30((int)a2, a1, a4);
    if ( v8 )
    {
      sub_10042450(7, v8, a2, a3);
      sub_10009350(0, v4, *(_WORD *)(v4 + 14), *(_WORD *)(v4 + 244), v8, 0);
      v6 = *(_DWORD *)(v4 + 16);
      *(_BYTE *)(v4 + 13) = 5;
      result = (*(int (__cdecl **)(_DWORD, int, _DWORD, _DWORD))(v6 + 1052))(*(_DWORD *)(v6 + 1072), v4, 0, 0);
    }
    else
    {
      sub_10008E40(v4);
      *(_BYTE *)(v4 + 13) = 2;
      sub_10008160(v4, (int)&v7);
      result = (*(int (__cdecl **)(_DWORD, int, char *, char *, size_t))(*(_DWORD *)(v4 + 16) + 1044))(
                 *(_DWORD *)(*(_DWORD *)(v4 + 16) + 1072),
                 v4,
                 &v7,
                 (char *)a2 + *(_BYTE *)a2 + 1,
                 a3 - *(_BYTE *)a2 - 1);
    }
  }
  else if ( result == 2 )
  {
    result = sub_10008E40(a1);
  }
  else if ( !result )
  {
    result = sub_10009350(0, a1, *(_WORD *)(a1 + 14), *(_WORD *)(a1 + 244), 0, 0);
  }
  return result;
}

//----- (100098D0) --------------------------------------------------------
char __cdecl sub_100098D0(int a1, void *a2, size_t a3, signed int a4)
{
  int v4; // esi@1
  char v5; // al@1
  char result; // al@2
  char v7; // [sp+Ch] [bp+4h]@2

  v4 = a1;
  v5 = *(_BYTE *)(a1 + 13);
  if ( v5 )
  {
    if ( v5 == 4 )
      result = sub_100082B0(a1 + 252, a1, 0);
    else
      result = sub_10042450(7, v5 - 56, a2, a3);
  }
  else
  {
    result = sub_10008CF0(a4, a1, (int)a2, a3);
    v7 = result;
    if ( result )
    {
      sub_10042450(7, result, a2, a3);
      result = sub_10009350(0, v4, *(_WORD *)(v4 + 14), 0, v7, 0);
    }
  }
  return result;
}

//----- (10009960) --------------------------------------------------------
char __cdecl sub_10009960(int a1, int a2, int a3)
{
  char v3; // al@1
  int v4; // eax@3
  char v5; // al@4
  char result; // al@6

  v3 = *(_BYTE *)(a1 + 13);
  if ( v3 != 5 && v3 != 1 )
  {
    v4 = a1 + 96;
    LOWORD(v4) = *(_BYTE *)(a2 + 3) + (*(_BYTE *)(a2 + 2) << 8);
    sub_100092C0(
      v4,
      *(_DWORD *)(a1 + 16),
      *(_BYTE *)(a2 + 5) + (*(_BYTE *)(a2 + 4) << 8),
      *(_BYTE *)(a1 + 12),
      a1 + 32,
      (char *)(a1 + 96));
  }
  v5 = *(_BYTE *)(a1 + 13);
  result = v5 && v5 != 5;
  *(_BYTE *)(a1 + 13) = 0;
  if ( result )
    result = (*(int (__cdecl **)(_DWORD, int, int, int))(*(_DWORD *)(a1 + 16) + 1052))(
               *(_DWORD *)(*(_DWORD *)(a1 + 16) + 1072),
               a1,
               *(_BYTE *)a2 + a2 + 1,
               a3 - *(_BYTE *)a2 - 1);
  return result;
}

//----- (10009A00) --------------------------------------------------------
int __cdecl sub_10009A00(int a1, void *a2, size_t a3)
{
  int result; // eax@1
  int v4; // eax@2
  int v5; // eax@3
  int v6; // eax@4

  sub_10042450(7, -115, a2, a3);
  result = *(_BYTE *)(a1 + 13);
  switch ( result )
  {
    case 1:
      v4 = *(_DWORD *)(a1 + 16);
      *(_BYTE *)(a1 + 13) = 0;
      result = (*(int (__cdecl **)(_DWORD, int, _DWORD, _DWORD))(v4 + 1052))(*(_DWORD *)(v4 + 1072), a1, 0, 0);
      break;
    case 2:
      sub_10009350(0, a1, *(_WORD *)(a1 + 14), *(_WORD *)(a1 + 244), -123, 0);
      v5 = *(_DWORD *)(a1 + 16);
      *(_BYTE *)(a1 + 13) = 5;
      result = (*(int (__cdecl **)(_DWORD, int, _DWORD, _DWORD))(v5 + 1052))(*(_DWORD *)(v5 + 1072), a1, 0, 0);
      break;
    case 4:
      sub_10009350(0, a1, *(_WORD *)(a1 + 14), *(_WORD *)(a1 + 244), -123, 0);
      v6 = *(_DWORD *)(a1 + 16);
      *(_BYTE *)(a1 + 13) = 5;
      result = (*(int (__cdecl **)(_DWORD, int, _DWORD, _DWORD))(v6 + 1052))(*(_DWORD *)(v6 + 1072), a1, 0, 0);
      break;
    case 0:
    case 3:
      return result;
    default:
      *(_BYTE *)(a1 + 13) = 0;
      break;
  }
  return result;
}

//----- (10009AF0) --------------------------------------------------------
int __usercall sub_10009AF0@<eax>(int a1@<eax>)
{
  int v1; // ebx@1
  int result; // eax@1
  int v3; // eax@2

  v1 = a1;
  result = *(_DWORD *)(a1 + 16);
  if ( (unsigned int)(*(_DWORD *)(result + 1028) - *(_DWORD *)(v1 + 8636)) > *(_DWORD *)(v1 + 8612) )
  {
    sub_10009350(0, v1, *(_WORD *)(v1 + 14), *(_WORD *)(v1 + 244), 0, 0);
    v3 = *(_DWORD *)(v1 + 16);
    *(_BYTE *)(v1 + 13) = 5;
    result = (*(int (__cdecl **)(_DWORD, int, _DWORD, _DWORD))(v3 + 1052))(*(_DWORD *)(v3 + 1072), v1, 0, 0);
  }
  return result;
}

//----- (10009BC0) --------------------------------------------------------
unsigned int __usercall sub_10009BC0@<eax>(unsigned int result@<eax>)
{
  int v1; // eax@21
  int v2; // esi@1
  int v3; // edi@3
  int v4; // ebx@5

  v2 = result;
  if ( *(_BYTE *)(result + 13) == 2 )
  {
    if ( !*(_BYTE *)(result + 239) )
      return result;
    v3 = 1036 * (*(_BYTE *)(result + 238) & 3) + result + 252;
  }
  else
  {
    v3 = result + 252;
  }
  result = *(_DWORD *)(result + 16);
  v4 = *(_DWORD *)(result + 1028);
  if ( *(_DWORD *)v3 && (unsigned int)(v4 - *(_DWORD *)(v3 + 8)) > *(_DWORD *)(v2 + 8624) )
  {
    if ( *(_DWORD *)(v3 + 4) >= (unsigned int)*(_BYTE *)(result + 1061) )
    {
      if ( *(_BYTE *)(v2 + 13) == 1 )
      {
        result = (*(int (__cdecl **)(_DWORD, int, _DWORD, _DWORD))(*(_DWORD *)(v2 + 16) + 1052))(
                   *(_DWORD *)(*(_DWORD *)(v2 + 16) + 1072),
                   v2,
                   0,
                   0);
      }
      else if ( *(_BYTE *)(v2 + 13) == 2 || (result = *(_BYTE *)(v2 + 13) - 4, *(_BYTE *)(v2 + 13) == 4) )
      {
        sub_10009350(0, v2, *(_WORD *)(v2 + 14), *(_WORD *)(v2 + 244), 0, 0);
        v1 = *(_DWORD *)(v2 + 16);
        *(_BYTE *)(v2 + 13) = 5;
        return (*(int (__cdecl **)(_DWORD, int, _DWORD, _DWORD))(v1 + 1052))(*(_DWORD *)(v1 + 1072), v2, 0, 0);
      }
      *(_BYTE *)(v2 + 13) = 0;
    }
    else
    {
      sub_100082B0(v3, v2, 0);
      if ( *(_DWORD *)(v2 + 252) )
        *(_DWORD *)(v2 + 260) = v4;
      if ( *(_DWORD *)(v2 + 1288) )
        *(_DWORD *)(v2 + 1296) = v4;
      if ( *(_DWORD *)(v2 + 2324) )
        *(_DWORD *)(v2 + 2332) = v4;
      if ( *(_DWORD *)(v2 + 3360) )
        *(_DWORD *)(v2 + 3368) = v4;
      result = sub_10008360(2 * *(_DWORD *)(v2 + 8624), v2);
    }
  }
  return result;
}

//----- (10009C90) --------------------------------------------------------
char __usercall sub_10009C90@<al>(int a1@<edi>, int a2, _DWORD *a3, size_t a4, char *a5, char *a6)
{
  int v6; // ebx@1
  int v7; // eax@1
  char v8; // cl@2
  char result; // al@3
  char v10; // cl@9
  int v11; // [sp+Ch] [bp-8h]@1
  __int16 v12; // [sp+10h] [bp-4h]@1

  v11 = (unsigned __int16)(*(_BYTE *)(a1 + 3) + (*(_BYTE *)(a1 + 2) << 8));
  v12 = *(_BYTE *)(a1 + 5) + (*(_BYTE *)(a1 + 4) << 8);
  v6 = sub_10007F00(a2, a1 + 2, a3, 0);
  v7 = sub_10007F00(a2, 0, a3, a1 + 4);
  if ( !v6 )
    goto LABEL_17;
  v8 = *(_BYTE *)(v6 + 13);
  if ( v8 == 1 )
    return sub_10009960(v6, a1, a4);
  if ( v8 == 2 && v12 )
  {
    result = sub_100092C0(v11, a2, v12, *a5, (int)a3, a6);
  }
  else
  {
LABEL_17:
    if ( (_WORD)v11 || !v7 || (v10 = *(_BYTE *)(v7 + 13), v10 != 4) && v10 != 3 )
    {
      if ( v6 )
        result = sub_10009960(v6, a1, a4);
      else
        result = sub_10042450(7, -124, (void *)a1, a4);
    }
    else
    {
      result = sub_10009960(v7, a1, a4);
    }
  }
  return result;
}

//----- (10009DC0) --------------------------------------------------------
unsigned int __usercall sub_10009DC0@<eax>(unsigned int a1@<eax>)
{
  unsigned int v1; // edi@1
  int *v2; // ebp@2
  int v3; // esi@4
  int v4; // eax@5
  _DWORD *v5; // ecx@5
  unsigned int result; // eax@6

  v1 = a1;
  if ( *(_BYTE *)(a1 + 13) == 2 )
  {
    v2 = (int *)(a1 + 4476);
    do
    {
      if ( (int *)*v2 == v2 )
        break;
      v3 = *v2;
      if ( !(unsigned __int8)sub_100093A0(v1, *v2) )
        break;
      v4 = *(_DWORD *)v3;
      v5 = *(_DWORD **)(v3 + 4);
      *(_DWORD *)(v4 + 4) = v5;
      *v5 = v4;
      *(_DWORD *)v3 = 0;
      *(_DWORD *)(v3 + 4) = 0;
    }
    while ( *(_BYTE *)(v1 + 13) == 2 );
  }
  result = sub_10009BC0(v1);
  if ( *(_BYTE *)(v1 + 13) == 2 )
  {
    sub_10009AF0(v1);
    if ( *(_BYTE *)(v1 + 236)
      || (result = *(_DWORD *)(v1 + 16),
          (unsigned int)(*(_DWORD *)(result + 1028) - *(_DWORD *)(v1 + 8640)) > *(_DWORD *)(v1 + 8620)) )
    {
      result = sub_10008E40(v1);
    }
  }
  return result;
}

//----- (10009E50) --------------------------------------------------------
int __usercall sub_10009E50@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // al@1
  int result; // eax@1
  int i; // edi@1
  char v5; // al@2

  v1 = a1;
  v2 = (*(_BYTE *)(a1 + 8604) + 1) % 128;
  *(_BYTE *)(v1 + 8604) = v2;
  result = 1028 * (v2 & 3);
  for ( i = result + v1; *(_DWORD *)(result + v1 + 4484); i = result + v1 )
  {
    sub_10009740(*(_DWORD *)(i + 4484), i + 4488, v1);
    *(_DWORD *)(i + 4484) = 0;
    v5 = (*(_BYTE *)(v1 + 8604) + 1) % 128;
    *(_BYTE *)(v1 + 8604) = v5;
    result = 1028 * (v5 & 3);
  }
  return result;
}

//----- (10009EF0) --------------------------------------------------------
char __cdecl sub_10009EF0(int a1, _BYTE *a2, size_t a3, int a4, int a5)
{
  char result; // al@1
  char v6; // cl@4
  char v7; // al@4

  result = sub_10008410(a1 + 20, a5);
  if ( *(_BYTE *)(a1 + 13) == 4 )
  {
    *(_BYTE *)(a1 + 13) = 2;
    result = sub_10008390(a1, a1 + 252, 1);
  }
  if ( *(_BYTE *)(a1 + 13) == 2 )
  {
    v6 = *(_BYTE *)(a1 + 8604);
    v7 = a2[4] & 0x7F;
    if ( v7 == v6 )
    {
      sub_10009740(a3, (int)a2, a1);
      result = sub_10009E50(a1);
      *(_BYTE *)(a1 + 236) = 1;
    }
    else if ( (unsigned __int8)((v7 - v6) & 0x7F) >= *(_BYTE *)(a1 + 3) )
    {
      result = sub_10042450(7, -113, a2, a3);
      *(_BYTE *)(a1 + 236) = 1;
    }
    else
    {
      result = (unsigned int)sub_10007ED0(v7, a2, a1, a3);
    }
  }
  return result;
}

//----- (10009FA0) --------------------------------------------------------
char __usercall sub_10009FA0@<al>(int a1@<eax>, int a2, unsigned int a3, _DWORD *a4, char *a5)
{
  int v5; // edi@1
  char v6; // bl@1
  char result; // al@4
  int v8; // eax@5
  int v9; // eax@15
  int v10; // eax@18
  char v11; // [sp+10h] [bp-30h]@3
  int v12; // [sp+10h] [bp-30h]@5
  int v13; // [sp+14h] [bp-2Ch]@3
  int v14; // [sp+18h] [bp-28h]@3

  v5 = a1;
  v6 = *(_BYTE *)(a1 + 1) >> 4;
  if ( (unsigned __int8)v6 < 0x10u && dword_10095960[2 * (unsigned __int8)v6] )
  {
    v13 = a2 + 1076;
    v11 = sub_10008510((int)&v14, a1, a3, (unsigned __int8)v6, a2 + 1076, (int)a4);
    if ( v11 )
    {
      result = sub_10042450(7, v11, (void *)v5, a3);
    }
    else
    {
      v8 = sub_10008AB0(a2, a4, v6, v5);
      v12 = v8;
      if ( v8 )
      {
        if ( v6 != 15 && v6 != 6 || (_BYTE)v14 == *(_BYTE *)(v8 + 12) )
        {
          result = ((int (__cdecl *)(int, int, unsigned int, int *, char *))dword_10095960[2 * (unsigned __int8)v6])(
                     v8,
                     v5,
                     a3,
                     &v14,
                     a5);
          *(_DWORD *)(v12 + 8636) = *(_DWORD *)(a2 + 1028);
        }
        else
        {
          result = sub_10042450(7, -114, (void *)v5, a3);
        }
      }
      else
      {
        switch ( v6 )
        {
          case 8:
            result = sub_10009C90(v5, a2, a4, a3, (char *)&v14, a5);
            break;
          case 13:
            v10 = sub_100088C0(
                    (unsigned __int16)(*(_BYTE *)(v5 + 3) + (*(_BYTE *)(v5 + 2) << 8)),
                    255,
                    *(_BYTE *)(v5 + 5) + (*(_BYTE *)(v5 + 4) << 8),
                    a2 + 1098,
                    -124,
                    v14,
                    0,
                    0,
                    (int)a4,
                    v13);
            result = sub_100021C0(v13, (int)a4, 0, *a5, (int)(a5 + 2), a2 + 1098, v10);
            break;
          case 14:
            v9 = sub_10007BB0(0, a2, a5, (int)a4, 0, *(_BYTE *)(v5 + 5) + (*(_BYTE *)(v5 + 4) << 8));
            if ( v9 )
              result = sub_100098D0(v9, (void *)v5, a3, (signed int)&v14);
            else
              result = sub_10042450(7, 1, (void *)v5, a3);
            break;
          default:
            result = sub_10042450(7, -124, (void *)v5, a3);
            break;
        }
      }
    }
  }
  else
  {
    result = sub_10042450(7, -123, (void *)a1, a3);
  }
  return result;
}
// 10095960: using guessed type int dword_10095960[];

//----- (1000A1E0) --------------------------------------------------------
char __usercall sub_1000A1E0@<al>(char *a1@<ecx>, size_t a2@<eax>, int a3, _DWORD *a4, char *a5)
{
  size_t v5; // ebx@1
  char *v6; // edi@1
  unsigned int v7; // esi@2
  unsigned int v8; // eax@3

  v5 = a2;
  v6 = a1;
  if ( a2 )
  {
    while ( 1 )
    {
      v7 = (unsigned __int8)*v6 + 1;
      if ( v7 > v5 )
        break;
      v8 = (unsigned int)(unsigned __int8)v6[1] >> 4;
      if ( v8 != 6 && v8 != 2 && v8 != 7 && v8 != 12 )
        v7 = v5;
      LOBYTE(a2) = sub_10009FA0((int)v6, a3, v7, a4, a5);
      v6 += v7;
      v5 -= v7;
      if ( !v5 )
        return a2;
    }
    LOBYTE(a2) = sub_10042450(7, -118, v6, v5);
  }
  return a2;
}

//----- (1000A250) --------------------------------------------------------
size_t __cdecl sub_1000A250(int a1)
{
  size_t result; // eax@1
  unsigned int v2; // ebx@3
  int v3; // edi@4
  char v4; // [sp+Ch] [bp-A4h]@1
  char v5; // [sp+20h] [bp-90h]@1

  *(_DWORD *)(a1 + 1028) = sub_1007C040();
  for ( result = sub_10003380(a1 + 1076, (int)&v4, &v5, a1, 0x400u);
        result;
        result = sub_10003380(a1 + 1076, (int)&v4, &v5, a1, 0x400u) )
  {
    sub_1000A1E0((char *)a1, result, a1, &v4, &v5);
  }
  v2 = 0;
  if ( *(_DWORD *)(a1 + 1036) )
  {
    v3 = 0;
    do
    {
      result = v3 + *(_DWORD *)(a1 + 1032);
      if ( *(_BYTE *)(result + 13) )
        result = sub_10009DC0(result);
      ++v2;
      v3 += 8644;
    }
    while ( v2 < *(_DWORD *)(a1 + 1036) );
  }
  return result;
}

//----- (1000A320) --------------------------------------------------------
size_t __cdecl sub_1000A320(int a1, int a2, void *a3, size_t a4)
{
  int v4; // esi@1
  size_t result; // eax@2

  v4 = *(_BYTE *)a1 + 1;
  if ( v4 + a4 > a2 )
  {
    sub_10042930("..\\lib\\atn\\atn_cotp_frmt.c", 127, 0, 0);
    result = v4;
  }
  else
  {
    memcpy((void *)(a1 + v4), a3, a4);
    result = v4 + a4;
  }
  return result;
}

//----- (1000A370) --------------------------------------------------------
void *__cdecl sub_1000A370(int a1, int a2, char a3, size_t a4)
{
  int v4; // edx@1
  int v5; // ecx@1
  void *result; // eax@2
  size_t v7; // edx@3
  void *v8; // esi@5

  v4 = *(_BYTE *)a1;
  v5 = v4 + 1;
  if ( a4 + 2 + v4 + 1 <= a2 )
  {
    v7 = a4 + 2 + v4;
    if ( v7 <= 0xFE )
    {
      *(_BYTE *)a1 = v7;
      *(_BYTE *)(v5 + a1) = a3;
      v8 = (void *)(v5 + a1 + 2);
      *(_BYTE *)(v5 + a1 + 1) = a4;
      memset(v8, 0, a4);
      result = v8;
    }
    else
    {
      sub_10042930("..\\lib\\atn\\atn_cotp_frmt.c", 187, 0, 0);
      result = 0;
    }
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_cotp_frmt.c", 176, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1000A400) --------------------------------------------------------
char __cdecl sub_1000A400(_BYTE *a1, int a2, int a3)
{
  char *v3; // ebp@1
  char v4; // al@1
  int v5; // esi@1
  char result; // al@1
  int v7; // [sp+10h] [bp-8h]@1
  int v8; // [sp+14h] [bp-4h]@1

  v3 = &a1[a3 + 1];
  v7 = 0;
  v8 = 0;
  a1[a3] = 0;
  *v3 = 0;
  sub_10002040(a1, a2, &v7, &v8);
  v4 = sub_10001FB0(v7 * (a2 - a3 - 1) - v8);
  v5 = v7 * (a2 - a3);
  a1[a3] = v4;
  result = sub_10001FB0(v8 - v5);
  *v3 = result;
  return result;
}

//----- (1000A470) --------------------------------------------------------
bool __cdecl sub_1000A470(_BYTE *a1, int a2)
{
  int v3; // [sp+0h] [bp-8h]@1
  int v4; // [sp+4h] [bp-4h]@1

  sub_10002040(a1, a2, &v3, &v4);
  return !v3 && !v4;
}

//----- (1000A4B0) --------------------------------------------------------
signed int __usercall sub_1000A4B0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<esi>)
{
  signed int result; // eax@2

  *(_BYTE *)a1 = 20;
  *(_DWORD *)(a1 + 1) = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 5) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 9) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 13) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 17) = *(_DWORD *)(a2 + 16);
  *(_BYTE *)(a1 + 21) = 20;
  *(_DWORD *)(a1 + 22) = *(_DWORD *)a3;
  *(_DWORD *)(a1 + 26) = *(_DWORD *)(a3 + 4);
  *(_DWORD *)(a1 + 30) = *(_DWORD *)(a3 + 8);
  *(_DWORD *)(a1 + 34) = *(_DWORD *)(a3 + 12);
  *(_DWORD *)(a1 + 38) = *(_DWORD *)(a3 + 16);
  if ( a4 )
  {
    *(_BYTE *)(a1 + 42) = *(_BYTE *)a4;
    *(_BYTE *)(a1 + 43) = *(_BYTE *)(a4 + 1);
    *(_BYTE *)(a1 + 44) = *(_BYTE *)(a4 + 2);
    *(_BYTE *)(a1 + 45) = *(_BYTE *)(a4 + 3);
    result = 46;
  }
  else
  {
    result = 42;
  }
  return result;
}

//----- (1000A520) --------------------------------------------------------
char __cdecl sub_1000A520(int a1, _BYTE *a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  char v7; // [sp+Ch] [bp-44h]@1
  char v8; // [sp+1Ch] [bp-34h]@1

  *(_BYTE *)a1 = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_BYTE *)(a1 + 2) = 0;
  *(_BYTE *)(a1 + 3) = 0;
  v5 = sub_1000A4B0((int)&v8, a4, a5, 0);
  sub_10002090(a2, a3, 0, (int)&v7);
  sub_10002090(&v8, v5, (int)&v7, (int)&v7);
  return sub_10001FE0((int)&v7, a1);
}

//----- (1000A5B0) --------------------------------------------------------
bool __cdecl sub_1000A5B0(_BYTE *a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [sp+10h] [bp-48h]@1
  int v8; // [sp+14h] [bp-44h]@3
  int v9; // [sp+18h] [bp-40h]@4
  int v10; // [sp+1Ch] [bp-3Ch]@5
  int v11; // [sp+20h] [bp-38h]@6
  char v12; // [sp+24h] [bp-34h]@1

  v7 = sub_1000A4B0((int)&v12, a5, a6, a4);
  *(_BYTE *)a4 = 0;
  *(_BYTE *)(a4 + 1) = 0;
  *(_BYTE *)(a4 + 2) = 0;
  *(_BYTE *)(a4 + 3) = 0;
  if ( a3 )
  {
    *(_BYTE *)a3 = 0;
    *(_BYTE *)(a3 + 1) = 0;
  }
  sub_10002090(a1, a2, 0, (int)&v8);
  sub_10002090(&v12, v7, (int)&v8, (int)&v8);
  return !v8 && !v9 && !v10 && !v11;
}

//----- (1000A670) --------------------------------------------------------
int __cdecl sub_1000A670(int a1)
{
  int result; // eax@1
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // edx@1
  int v5; // ecx@1

  result = a1;
  v2 = dword_101C66C8;
  *(_DWORD *)a1 = dword_101C66C4;
  v3 = dword_101C66CC;
  *(_DWORD *)(a1 + 4) = v2;
  v4 = dword_101C66D0;
  *(_DWORD *)(a1 + 8) = v3;
  v5 = dword_101C66D4;
  *(_DWORD *)(a1 + 12) = v4;
  LOWORD(v4) = word_101C66D8;
  *(_DWORD *)(a1 + 16) = v5;
  *(_WORD *)(a1 + 20) = v4;
  return result;
}
// 101C66C4: using guessed type int dword_101C66C4;
// 101C66C8: using guessed type int dword_101C66C8;
// 101C66CC: using guessed type int dword_101C66CC;
// 101C66D0: using guessed type int dword_101C66D0;
// 101C66D4: using guessed type int dword_101C66D4;
// 101C66D8: using guessed type __int16 word_101C66D8;

//----- (1000A6C0) --------------------------------------------------------
BOOL __usercall sub_1000A6C0@<eax>(int a1@<ecx>, int a2@<eax>)
{
  return sub_10010A40((int)&off_1009E128, a1, (void *)(a2 + 8240), 0x24u) == 0;
}
// 1009E128: using guessed type char *off_1009E128;

//----- (1000A710) --------------------------------------------------------
#error "1000A722: call analysis failed (funcsize=13)"

//----- (1000A740) --------------------------------------------------------
int __cdecl sub_1000A740(int a1)
{
  int result; // eax@1
  int v2; // ecx@1
  _DWORD *v3; // edx@1
  int v4; // ecx@1

  result = a1;
  v2 = *(_DWORD *)a1;
  v3 = *(_DWORD **)(a1 + 4);
  *(_BYTE *)(a1 + 21) = 0;
  *(_DWORD *)(v2 + 4) = v3;
  *v3 = v2;
  v4 = dword_101C66B0;
  *(_DWORD *)(dword_101C66B0 + 4) = a1;
  *(_DWORD *)a1 = v4;
  *(_DWORD *)(a1 + 4) = &dword_101C66B0;
  dword_101C66B0 = a1;
  return result;
}
// 101C66B0: using guessed type int dword_101C66B0;

//----- (1000A770) --------------------------------------------------------
char __usercall sub_1000A770@<al>(int a1@<ecx>, _DWORD *a2@<edi>, int a3@<esi>)
{
  char result; // al@3

  if ( a1 && *(_DWORD *)(a1 + 4) && (result = sub_1000A6C0(a1, a3 + 24)) != 0 && *(_DWORD *)(a3 + 8264) == 2 )
  {
    *a2 = *(_DWORD *)(a3 + 8268);
  }
  else
  {
    *a2 = 1;
    result = 0;
  }
  return result;
}

//----- (1000A7B0) --------------------------------------------------------
char __usercall sub_1000A7B0@<al>(int a1@<ecx>, _DWORD *a2@<edi>, int a3@<esi>)
{
  char result; // al@3

  if ( a1 && *(_DWORD *)(a1 + 4) && (result = sub_1000A6C0(a1, a3 + 24)) != 0 && *(_DWORD *)(a3 + 8264) == 1 )
  {
    *a2 = *(_DWORD *)(a3 + 8268);
  }
  else
  {
    *a2 = 0;
    result = 0;
  }
  return result;
}

//----- (1000A7F0) --------------------------------------------------------
char __cdecl sub_1000A7F0(int a1, char a2, int a3)
{
  void *v3; // edx@1
  int v4; // esi@1
  char result; // al@2
  int v6; // [sp+8h] [bp-20h]@4
  int v7; // [sp+Ch] [bp-1Ch]@4
  int v8; // [sp+10h] [bp-18h]@4
  int v9; // [sp+14h] [bp-14h]@4
  char v10; // [sp+18h] [bp-10h]@4
  char v11; // [sp+19h] [bp-Fh]@4
  int v12; // [sp+1Ah] [bp-Eh]@4
  int v13; // [sp+1Eh] [bp-Ah]@4
  char v14; // [sp+22h] [bp-6h]@4
  char v15; // [sp+23h] [bp-5h]@4

  v4 = sub_1000A710();
  if ( v4 )
  {
    if ( a2 )
    {
      if ( a2 == 1 )
      {
        sub_1000A770(a3, &v6, v4);
        sub_1000D620(v4, v6);
      }
      else
      {
        sub_1000D620(v4, 3);
      }
    }
    else
    {
      sub_1000A7B0(a3, &v6, v4);
      v10 = 16;
      v11 = 9;
      v12 = *(_DWORD *)(v4 + 12);
      v13 = *(_DWORD *)(v4 + 16);
      v14 = *(_BYTE *)(v4 + 20);
      v15 = sub_1000B580();
      v7 = -1;
      v8 = -1;
      v9 = 0;
      sub_1002F090(4, 0, 0, (int)&v7, &v6, 4u);
      sub_1000D740(v4, v6);
    }
    result = sub_1000A740(v4);
  }
  else
  {
    result = sub_10042450(12, 15, v3, 4u);
  }
  return result;
}

//----- (1000A930) --------------------------------------------------------
#error "1000A93C: call analysis failed (funcsize=25)"

//----- (1000A980) --------------------------------------------------------
int __usercall sub_1000A980@<eax>(int a1@<eax>, int a2@<ecx>)
{
  *(_DWORD *)a1 = 2;
  *(_DWORD *)(a1 + 4) = a2;
  return sub_10010740((int)&off_1009E040, a1, 36, a1 + 36, 0x2000, a1 + 8228);
}
// 1009E040: using guessed type char *off_1009E040;

//----- (1000A990) --------------------------------------------------------
void __usercall sub_1000A990(int a1@<eax>, const void *a2@<edx>)
{
  *(_DWORD *)a1 = 4;
  qmemcpy((void *)(a1 + 4), a2, 0x20u);
  JUMPOUT(&loc_1000A6E0);
}

//----- (1000A9B0) --------------------------------------------------------
void __usercall sub_1000A9B0(int a1@<eax>, int a2@<ecx>)
{
  *(_DWORD *)a1 = 1;
  *(_DWORD *)(a1 + 4) = a2;
  JUMPOUT(&loc_1000A6E0);
}

//----- (1000A9C0) --------------------------------------------------------
void __cdecl sub_1000A9C0(int a1, char a2, int a3, char a4)
{
  int v4; // eax@3
  char v5; // dl@3
  int v6; // ecx@3
  int v7; // eax@3
  void *v8; // ST10_4@3
  int v9; // [sp+8h] [bp-1Ch]@3
  int v10; // [sp+Ch] [bp-18h]@3
  int v11; // [sp+10h] [bp-14h]@3
  char v12; // [sp+14h] [bp-10h]@3
  char v13; // [sp+15h] [bp-Fh]@3
  int v14; // [sp+16h] [bp-Eh]@3
  int v15; // [sp+1Ah] [bp-Ah]@3
  char v16; // [sp+1Eh] [bp-6h]@3
  char v17; // [sp+1Fh] [bp-5h]@3

  if ( *(_BYTE *)(a1 + 21) == 4 )
  {
    sub_1000A990(a1 + 24, (const void *)a3);
    sub_10010410(dword_101C66C0, *(_DWORD *)(a1 + 8), a2, a1 + 8252);
    if ( a4 )
    {
      v4 = *(_DWORD *)(a1 + 12);
      v5 = *(_BYTE *)(a1 + 20);
      v15 = *(_DWORD *)(a1 + 16);
      v6 = *(_DWORD *)(a3 + 8);
      v14 = v4;
      v9 = -1;
      v10 = -1;
      v7 = *(_DWORD *)(a3 + 12);
      v16 = v5;
      v8 = *(void **)(a3 + 4);
      v11 = v7;
      v12 = 12;
      v13 = 9;
      v17 = -1;
      sub_1002F090(2, 1, 0, (int)&v9, v8, (unsigned int)(v6 + 7) >> 3);
    }
    if ( a2 )
      *(_BYTE *)(a1 + 21) = 3;
    else
      sub_1000A740(a1);
  }
}
// 101C66C0: using guessed type int dword_101C66C0;

//----- (1000AAA0) --------------------------------------------------------
void __cdecl sub_1000AAA0(int a1, int a2, char a3)
{
  char v3; // al@1
  int v4; // eax@4
  char v5; // dl@4
  int v6; // ecx@4
  int v7; // eax@4
  void *v8; // ST10_4@4
  int v9; // [sp+8h] [bp-1Ch]@4
  int v10; // [sp+Ch] [bp-18h]@4
  int v11; // [sp+10h] [bp-14h]@4
  char v12; // [sp+14h] [bp-10h]@4
  char v13; // [sp+15h] [bp-Fh]@4
  int v14; // [sp+16h] [bp-Eh]@4
  int v15; // [sp+1Ah] [bp-Ah]@4
  char v16; // [sp+1Eh] [bp-6h]@4
  char v17; // [sp+1Fh] [bp-5h]@4

  v3 = *(_BYTE *)(a1 + 21);
  if ( v3 == 3 || v3 == 4 )
  {
    sub_1000A990(a1 + 24, (const void *)a2);
    sub_100103F0(dword_101C66C0, *(_DWORD *)(a1 + 8), a1 + 8252);
    if ( a3 )
    {
      v4 = *(_DWORD *)(a1 + 12);
      v5 = *(_BYTE *)(a1 + 20);
      v15 = *(_DWORD *)(a1 + 16);
      v6 = *(_DWORD *)(a2 + 8);
      v14 = v4;
      v9 = -1;
      v10 = -1;
      v7 = *(_DWORD *)(a2 + 12);
      v16 = v5;
      v8 = *(void **)(a2 + 4);
      v11 = v7;
      v12 = 13;
      v13 = 9;
      v17 = -1;
      sub_1002F090(2, 1, 0, (int)&v9, v8, (unsigned int)(v6 + 7) >> 3);
    }
  }
}
// 101C66C0: using guessed type int dword_101C66C0;

//----- (1000AB60) --------------------------------------------------------
char __cdecl sub_1000AB60(int a1, char a2, int a3)
{
  int v3; // eax@2
  char v4; // dl@2
  int v5; // ecx@2
  int v6; // eax@2
  void *v7; // ST10_4@2
  char result; // al@2
  int v9; // [sp+8h] [bp-1Ch]@2
  int v10; // [sp+Ch] [bp-18h]@2
  int v11; // [sp+10h] [bp-14h]@2
  char v12; // [sp+14h] [bp-10h]@2
  char v13; // [sp+15h] [bp-Fh]@2
  int v14; // [sp+16h] [bp-Eh]@2
  int v15; // [sp+1Ah] [bp-Ah]@2
  char v16; // [sp+1Eh] [bp-6h]@2
  char v17; // [sp+1Fh] [bp-5h]@2

  if ( *(_BYTE *)(a1 + 21) == 1 )
  {
    sub_1000A990(a1 + 24, (const void *)a3);
    sub_100104D0(dword_101C66C0, *(_DWORD *)(a1 + 8), a2, a1 + 8252);
    v3 = *(_DWORD *)(a1 + 12);
    v4 = *(_BYTE *)(a1 + 20);
    v15 = *(_DWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a3 + 8);
    v14 = v3;
    v9 = -1;
    v10 = -1;
    v6 = *(_DWORD *)(a3 + 12);
    v16 = v4;
    v7 = *(void **)(a3 + 4);
    v11 = v6;
    v12 = 14;
    v13 = 9;
    v17 = -1;
    result = sub_1002F090(2, 1, 0, (int)&v9, v7, (unsigned int)(v5 + 7) >> 3);
    if ( a2 )
      result = sub_1000A740(a1);
    else
      *(_BYTE *)(a1 + 21) = 3;
  }
  return result;
}
// 101C66C0: using guessed type int dword_101C66C0;

//----- (1000AC40) --------------------------------------------------------
void __cdecl sub_1000AC40(int a1, int a2)
{
  int v2; // ecx@2
  int v3; // edx@4
  char v4; // al@4
  int v5; // [sp+4h] [bp-1Ch]@4
  int v6; // [sp+8h] [bp-18h]@4
  int v7; // [sp+Ch] [bp-14h]@4
  char v8; // [sp+10h] [bp-10h]@4
  char v9; // [sp+11h] [bp-Fh]@4
  int v10; // [sp+12h] [bp-Eh]@4
  int v11; // [sp+16h] [bp-Ah]@4
  char v12; // [sp+1Ah] [bp-6h]@4
  char v13; // [sp+1Bh] [bp-5h]@4

  if ( *(_BYTE *)(a1 + 21) )
  {
    sub_1000D740(a1, a2);
    v2 = a2;
    if ( a2 >= 13 )
      v2 = 0;
    sub_1000A9B0(a1 + 24, v2);
    sub_100103C0(dword_101C66C0, *(_DWORD *)(a1 + 8), 0, a1 + 8252);
    v3 = *(_DWORD *)(a1 + 16);
    v4 = *(_BYTE *)(a1 + 20);
    v10 = *(_DWORD *)(a1 + 12);
    v11 = v3;
    v12 = v4;
    v8 = 16;
    v9 = 9;
    v13 = -1;
    v5 = -1;
    v6 = -1;
    v7 = 0;
    sub_1002F090(4, 1, 0, (int)&v5, &a2, 4u);
    sub_1000A740(a1);
  }
}
// 101C66C0: using guessed type int dword_101C66C0;

//----- (1000AD00) --------------------------------------------------------
int __usercall sub_1000AD00@<eax>(int a1@<esi>)
{
  sub_1000A980(a1 + 24, 2);
  sub_100103C0(dword_101C66C0, *(_DWORD *)(a1 + 8), 1, a1 + 8252);
  sub_1000D620(a1, 2);
  return sub_1000A740(a1);
}
// 101C66C0: using guessed type int dword_101C66C0;

//----- (1000AD40) --------------------------------------------------------
int __usercall sub_1000AD40@<eax>(int a1@<esi>)
{
  sub_1000A980(a1 + 24, 7);
  sub_100103C0(dword_101C66C0, *(_DWORD *)(a1 + 8), 1, a1 + 8252);
  sub_1000D620(a1, 7);
  return sub_1000A740(a1);
}
// 101C66C0: using guessed type int dword_101C66C0;

//----- (1000AD80) --------------------------------------------------------
void __usercall sub_1000AD80(int a1@<edi>, int a2@<esi>)
{
  char v2; // [sp+0h] [bp-2058h]@1
  char v3; // [sp+2024h] [bp-34h]@1

  sub_1000A980((int)&v2, 3);
  sub_100103C0(dword_101C66C0, a1, 1, (int)&v3);
  if ( a2 )
  {
    sub_1000D620(a2, 3);
    sub_1000A740(a2);
  }
}
// 101C66C0: using guessed type int dword_101C66C0;

//----- (1000ADF0) --------------------------------------------------------
char __usercall sub_1000ADF0@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // esi@1
  char v3; // bl@3
  char result; // al@6

  v2 = a1;
  if ( a2 && *(_DWORD *)(a2 + 4) )
  {
    *(_DWORD *)(a1 + 8264) = 0;
    *(_DWORD *)(a1 + 8268) = 0;
    *(_DWORD *)(a1 + 8272) = 0;
    *(_DWORD *)(a1 + 8276) = 0;
    *(_DWORD *)(a1 + 8280) = 0;
    *(_DWORD *)(a1 + 8284) = 0;
    *(_DWORD *)(a1 + 8288) = 0;
    *(_DWORD *)(a1 + 8292) = 0;
    *(_DWORD *)(a1 + 8296) = 0;
    v3 = sub_1000A6C0(a2, a1 + 24);
    if ( !v3 || *(_DWORD *)(v2 + 8264) != 4 )
    {
      v3 = 0;
      sub_1000AD00(v2);
    }
    result = v3;
  }
  else
  {
    sub_1000AD40(a1);
    result = 0;
  }
  return result;
}

//----- (1000AE70) --------------------------------------------------------
char __usercall sub_1000AE70@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // esi@1
  char v3; // bl@3
  char result; // al@6

  v2 = a1;
  if ( a2 && *(_DWORD *)(a2 + 4) )
  {
    v3 = sub_1000A6C0(a2, a1 + 24);
    if ( !v3 || *(_DWORD *)(v2 + 8264) != 3 )
    {
      v3 = 0;
      sub_1000AD00(v2);
    }
    result = v3;
  }
  else
  {
    sub_1000AD40(a1);
    result = 0;
  }
  return result;
}

//----- (1000AF70) --------------------------------------------------------
void __cdecl sub_1000AF70(char *a1, char *a2, int a3, char *a4)
{
  int v4; // esi@1
  int v5; // eax@2

  v4 = sub_1000A710();
  if ( !v4 )
  {
    v5 = sub_1000A930();
    v4 = v5;
    if ( !v5 )
    {
      sub_10042930("..\\lib\\atn\\atn_cpdlc_ase.c", 963, 0, 0);
      return;
    }
    *(_DWORD *)(v5 + 8) = a1;
    *(_DWORD *)(v5 + 12) = *(_DWORD *)a2;
    *(_DWORD *)(v5 + 16) = *((_DWORD *)a2 + 1);
    *(_BYTE *)(v5 + 20) = a2[8];
  }
  if ( *(_BYTE *)(v4 + 21) )
  {
    sub_1000AD80((int)a1, v4);
  }
  else if ( *(_WORD *)a3 != 3 || *(_WORD *)(a3 + 2) > 0x17u )
  {
    sub_1000A980(v4 + 24, 6);
    sub_100103C0(dword_101C66C0, *(_DWORD *)(v4 + 8), 1, v4 + 8252);
    sub_1000A740(v4);
  }
  else if ( sub_1000AE70(v4, (int)a4) )
  {
    *(_BYTE *)(v4 + 21) = 1;
    sub_1000EF20(v4, a2, *(_WORD *)(a3 + 2), v4 + 8268);
  }
}
// 1000A930: using guessed type int sub_1000A930(void);
// 101C66C0: using guessed type int dword_101C66C0;

//----- (1000B160) --------------------------------------------------------
int __cdecl sub_1000B160(void *a1, int a2)
{
  return sub_10010A40((int)&off_100966BC, a2, a1, 0x3198u);
}
// 100966BC: using guessed type char *off_100966BC;

//----- (1000B180) --------------------------------------------------------
int __cdecl sub_1000B180(int a1, int a2)
{
  int result; // eax@1

  result = sub_10010740((int)&off_1009648C, a2, 1328, (int)&unk_101EBEC8, 1024, a1);
  if ( result > 0 )
    result = 0;
  return result;
}
// 1009648C: using guessed type char *off_1009648C;

//----- (1000B1B0) --------------------------------------------------------
int __cdecl sub_1000B1B0(int a1, int a2)
{
  unsigned int v2; // eax@1
  int result; // eax@4

  v2 = a2 - 1;
  if ( *(_BYTE *)(a1 + 12658) && *(_BYTE *)(a1 + 12656) && *(_WORD *)(a1 + 1292) > v2 )
    result = 5681 * v2 + a1 + 1294;
  else
    result = 0;
  return result;
}

//----- (1000B1F0) --------------------------------------------------------
int __cdecl sub_1000B1F0(_BYTE *a1)
{
  int result; // eax@3

  if ( *a1 == 80 )
  {
    result = (int)(a1 + 23);
  }
  else if ( *a1 == 81 )
  {
    result = (int)(a1 + 1);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000B210) --------------------------------------------------------
bool __cdecl sub_1000B210(char a1, _DWORD *a2, unsigned int a3)
{
  bool result; // al@2

  if ( a3 >= 4 )
  {
    if ( a1 )
    {
      *a2 = 1;
      result = 1;
    }
    else
    {
      result = *a2 == 1;
    }
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_cpdlc_per_atc.c", 727, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1000B250) --------------------------------------------------------
signed int __cdecl sub_1000B250(int a1, int a2, _DWORD *a3, unsigned int a4, int a5, int a6)
{
  signed int result; // eax@4

  if ( a3 && a4 >= 2 && a6 )
  {
    result = sub_100114E0(a1, a2, a3, a4, a5);
    if ( !result )
      result = (signed __int16)(*(_WORD *)a3 - *(_WORD *)(*(_DWORD *)(a1 + 12) + 12)) % 5 != 4 ? 0 : -102;
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_cpdlc_per_elements.c", 7307, 0, 0);
    result = -1;
  }
  return result;
}

//----- (1000B2D0) --------------------------------------------------------
int __thiscall sub_1000B2D0(int this)
{
  __int64 v1; // rax@6
  int v2; // eax@7
  int v3; // eax@10

  if ( !*(_BYTE *)(this + 20) )
    goto LABEL_6;
  if ( *(_BYTE *)this == 1 )
  {
    v2 = 18 * *(_DWORD *)(this + 4);
  }
  else if ( *(_BYTE *)this == 2 )
  {
    v2 = 3 * (*(_DWORD *)(this + 8) + 6000 * *(_DWORD *)(this + 4));
  }
  else
  {
    if ( *(_BYTE *)this != 3 )
    {
      sub_10042930("..\\lib\\atn\\atn_cpdlc_per_elements.c", 7458, 0, 0);
LABEL_6:
      LODWORD(v1) = 2147483648;
      return v1;
    }
    v2 = 5 * (*(_BYTE *)(this + 12) + 60 * (*(_DWORD *)(this + 8) + 60 * *(_DWORD *)(this + 4)));
  }
  v3 = 2 * v2;
  if ( *(_BYTE *)(this + 16) == 1 )
    v3 = -v3;
  return 0x7FFFFFFFi64 * v3 / 6480000;
}

//----- (1000B370) --------------------------------------------------------
int __cdecl sub_1000B370(int a1, int a2, int a3, unsigned int a4, int a5, int a6)
{
  int result; // eax@3
  char v7; // [sp+4h] [bp-30h]@3
  char v8; // [sp+1Ch] [bp-18h]@4

  if ( a3 && a4 >= 8 )
  {
    result = sub_10011E00(a1, a2, (int)&v7, 0x30u, a5, a6);
    if ( !result )
    {
      *(_DWORD *)a3 = sub_1000B2D0((int)&v7);
      *(_DWORD *)(a3 + 4) = sub_1000B2D0((int)&v8);
      result = 0;
    }
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_cpdlc_per_elements.c", 7380, 0, 0);
    result = -1;
  }
  return result;
}

//----- (1000B3F0) --------------------------------------------------------
__int16 __cdecl sub_1000B3F0(int a1)
{
  bool v1; // zf@1
  __int16 result; // ax@17
  int v3; // ecx@17

  v1 = byte_101FBD6B == 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  if ( v1 )
  {
    if ( dword_1022AFF8 )
    {
      switch ( *(_BYTE *)(dword_1022AFF8 + 21) )
      {
        case 1:
        case 2:
          *(_BYTE *)(a1 + 8) = 2;
          break;
        case 3:
        case 4:
          *(_BYTE *)(a1 + 8) = 3;
          break;
        default:
          sub_10042930("..\\lib\\atn\\atn_cpdlc_user.c", 826, 0, 0);
          break;
      }
    }
    else if ( dword_1022B008 != 8 || dword_1022B00C != 13 )
    {
      *(_BYTE *)(a1 + 8) = 4;
    }
    else if ( byte_1022B010 == 1 )
    {
      *(_BYTE *)(a1 + 8) = 5;
    }
    else
    {
      *(_BYTE *)(a1 + 8) = byte_1022B010 != 2 ? 1 : 6;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 8) = 0;
  }
  *(_DWORD *)(a1 + 4) = dword_1022B00C;
  *(_DWORD *)a1 = dword_1022B008;
  *(_DWORD *)(a1 + 11) = dword_1022AFFC;
  *(_DWORD *)(a1 + 15) = dword_1022B000;
  *(_BYTE *)(a1 + 19) = byte_1022B004;
  *(_DWORD *)(a1 + 20) = *(_DWORD *)dword_101FBD8C;
  *(_DWORD *)(a1 + 24) = dword_101FBD90;
  *(_BYTE *)(a1 + 28) = byte_101FBD94;
  if ( dword_101FBD88 )
    *(_BYTE *)(a1 + 29) = *(_BYTE *)(dword_101FBD88 + 21);
  else
    *(_BYTE *)(a1 + 29) = 5;
  v1 = dword_101F8BCC == 0;
  result = dword_101EC2C8;
  *(_BYTE *)(a1 + 9) = byte_1022C228;
  v3 = dword_102289D4;
  *(_BYTE *)(a1 + 10) = v1;
  *(_WORD *)(a1 + 30) = result;
  *(_DWORD *)(a1 + 32) = v3;
  return result;
}
// 101EC2C8: using guessed type int dword_101EC2C8;
// 101F8BCC: using guessed type int dword_101F8BCC;
// 101FBD6B: using guessed type char byte_101FBD6B;
// 101FBD88: using guessed type int dword_101FBD88;
// 101FBD90: using guessed type int dword_101FBD90;
// 101FBD94: using guessed type char byte_101FBD94;
// 102289D4: using guessed type int dword_102289D4;
// 1022AFF8: using guessed type int dword_1022AFF8;
// 1022AFFC: using guessed type int dword_1022AFFC;
// 1022B000: using guessed type int dword_1022B000;
// 1022B004: using guessed type char byte_1022B004;
// 1022B008: using guessed type int dword_1022B008;
// 1022B00C: using guessed type int dword_1022B00C;
// 1022B010: using guessed type char byte_1022B010;
// 1022C228: using guessed type char byte_1022C228;

//----- (1000B530) --------------------------------------------------------
unsigned int __cdecl sub_1000B530(unsigned int a1)
{
  unsigned int result; // eax@1

  byte_101FBD6B = 0;
  byte_1022B010 = 0;
  dword_1022B00C = 13;
  dword_101FBD9C = 13;
  result = a1;
  dword_1022B008 = 8;
  dword_101FBD98 = 8;
  byte_101FBD7C = a1 >> 16;
  byte_101FBD7D = BYTE1(a1);
  byte_101FBD7E = a1;
  return result;
}
// 101FBD6B: using guessed type char byte_101FBD6B;
// 101FBD7C: using guessed type char byte_101FBD7C;
// 101FBD7D: using guessed type char byte_101FBD7D;
// 101FBD7E: using guessed type char byte_101FBD7E;
// 101FBD98: using guessed type int dword_101FBD98;
// 101FBD9C: using guessed type int dword_101FBD9C;
// 1022B008: using guessed type int dword_1022B008;
// 1022B00C: using guessed type int dword_1022B00C;
// 1022B010: using guessed type char byte_1022B010;

//----- (1000B580) --------------------------------------------------------
int sub_1000B580()
{
  return dword_102289D4;
}
// 102289D4: using guessed type int dword_102289D4;

//----- (1000B590) --------------------------------------------------------
char __usercall sub_1000B590@<al>(const char *a1@<eax>, size_t a2@<edx>, char a3)
{
  char result; // al@2

  dword_1022C250 = 1;
  byte_1022C256 = 63;
  byte_1022C257 = a3;
  if ( a1 )
  {
    byte_1022C358 = 99;
    strncpy(byte_1022C359, a1, a2);
    word_1022C254 = 2;
    result = sub_10042450(12, 16, &a3, 1u);
  }
  else
  {
    word_1022C254 = 1;
    result = sub_10042450(12, 16, &a3, 1u);
  }
  return result;
}
// 1022C250: using guessed type int dword_1022C250;
// 1022C254: using guessed type __int16 word_1022C254;
// 1022C256: using guessed type char byte_1022C256;
// 1022C257: using guessed type char byte_1022C257;
// 1022C358: using guessed type char byte_1022C358;

//----- (1000B600) --------------------------------------------------------
char sub_1000B600()
{
  dword_1022C250 = 1;
  byte_1022C256 = 64;
  word_1022C254 = 1;
  return sub_10042450(12, 17, 0, 0);
}
// 1022C250: using guessed type int dword_1022C250;
// 1022C254: using guessed type __int16 word_1022C254;
// 1022C256: using guessed type char byte_1022C256;

//----- (1000B630) --------------------------------------------------------
char sub_1000B630()
{
  char v0; // al@1
  int v2; // [sp+0h] [bp-1Ch]@1
  int v3; // [sp+4h] [bp-18h]@1
  int v4; // [sp+8h] [bp-14h]@1
  char v5; // [sp+Ch] [bp-10h]@1
  char v6; // [sp+Dh] [bp-Fh]@1
  int v7; // [sp+Eh] [bp-Eh]@1
  int v8; // [sp+12h] [bp-Ah]@1
  char v9; // [sp+16h] [bp-6h]@1
  char v10; // [sp+17h] [bp-5h]@1

  dword_1022C250 = 0;
  byte_1022C256 = 100;
  word_1022C254 = 1;
  v5 = 8;
  v6 = 9;
  v7 = *(_DWORD *)(dword_1022AFF8 + 12);
  v8 = *(_DWORD *)(dword_1022AFF8 + 16);
  v0 = *(_BYTE *)(dword_1022AFF8 + 20);
  v10 = -1;
  v4 = 255;
  v9 = v0;
  v2 = -1;
  v3 = -1;
  sub_1002F090(0, 1, 0, (int)&v2, 0, 0);
  return sub_10042450(12, 18, 0, 0);
}
// 1022AFF8: using guessed type int dword_1022AFF8;
// 1022C250: using guessed type int dword_1022C250;
// 1022C254: using guessed type __int16 word_1022C254;
// 1022C256: using guessed type char byte_1022C256;

//----- (1000B6D0) --------------------------------------------------------
signed int sub_1000B6D0()
{
  signed int result; // eax@1

  result = 1;
  dword_1022C250 = 1;
  byte_1022C256 = 101;
  word_1022C254 = 1;
  return result;
}
// 1022C250: using guessed type int dword_1022C250;
// 1022C254: using guessed type __int16 word_1022C254;
// 1022C256: using guessed type char byte_1022C256;

//----- (1000B6F0) --------------------------------------------------------
char sub_1000B6F0()
{
  dword_1022C250 = 1;
  byte_1022C256 = 108;
  word_1022C254 = 1;
  return sub_10042450(12, 19, 0, 0);
}
// 1022C250: using guessed type int dword_1022C250;
// 1022C254: using guessed type __int16 word_1022C254;
// 1022C256: using guessed type char byte_1022C256;

//----- (1000B720) --------------------------------------------------------
int __usercall sub_1000B720@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4)
{
  int *v4; // eax@1
  int v5; // ecx@1
  int v6; // edx@1
  int v7; // edx@1
  int v8; // eax@1
  int v9; // eax@1
  int result; // eax@1
  int v11; // [sp+0h] [bp-3Ch]@1
  int v12; // [sp+4h] [bp-38h]@1
  char v13; // [sp+8h] [bp-34h]@1
  char v14; // [sp+Ch] [bp-30h]@1
  int v15; // [sp+18h] [bp-24h]@1
  int v16; // [sp+1Ch] [bp-20h]@1
  char v17; // [sp+20h] [bp-1Ch]@1
  int v18; // [sp+21h] [bp-1Bh]@1
  char v19; // [sp+25h] [bp-17h]@1
  int v20; // [sp+28h] [bp-14h]@1
  int v21; // [sp+2Ch] [bp-10h]@1
  int v22; // [sp+30h] [bp-Ch]@1
  int v23; // [sp+34h] [bp-8h]@1

  sub_10001F70((int)&v14, (int)&byte_101FBD7C, 3);
  v4 = sub_10005CA0();
  v11 = *v4;
  v5 = *(_DWORD *)a3;
  v12 = v4[1];
  LOBYTE(v4) = *((_BYTE *)v4 + 8);
  v6 = *(_DWORD *)(a3 + 4);
  v20 = v5;
  v23 = *(_DWORD *)(a3 + 12);
  LOBYTE(v5) = *(_BYTE *)(a2 + 8);
  v21 = v6;
  v7 = *(_DWORD *)a2;
  v13 = (char)v4;
  v8 = *(_DWORD *)(a3 + 8);
  v17 = v5;
  v15 = v7;
  v22 = v8;
  v9 = *(_DWORD *)(a2 + 4);
  v18 = 17439531;
  v16 = v9;
  v19 = 1;
  result = sub_10010740((int)&off_1009DF88, (int)&v11, 56, a1, a4, 0);
  if ( result < 0 )
  {
    sub_10042930("..\\lib\\atn\\atn_cpdlc_user.c", 2745, 0, 0);
    result = 0;
  }
  return result;
}
// 1009DF88: using guessed type char *off_1009DF88;
// 101FBD7C: using guessed type char byte_101FBD7C;

//----- (1000B7F0) --------------------------------------------------------
char __usercall sub_1000B7F0@<al>(int a1@<esi>)
{
  unsigned int v1; // ST14_4@1
  unsigned int v2; // ST18_4@1
  int v3; // eax@1
  unsigned int v5; // eax@4
  int v6; // [sp+8h] [bp-Ch]@1
  int v7; // [sp+Ch] [bp-8h]@1
  unsigned int v8; // [sp+10h] [bp-4h]@1

  sub_10042DC0((char *)&v8);
  BYTE1(v1) = *(_BYTE *)(a1 + 8);
  LOBYTE(v1) = *(_BYTE *)(a1 + 4);
  HIWORD(v1) = *(_WORD *)a1;
  LOWORD(v2) = *(_BYTE *)(a1 + 12);
  BYTE2(v2) = *(_BYTE *)(a1 + 13);
  BYTE3(v2) = *(_BYTE *)(a1 + 16);
  sub_10042B50(&v6, v1);
  sub_10042C90(&v7, v2);
  v3 = v7 + v6;
  if ( v8 >= v7 + v6 )
  {
    if ( v8 - v3 <= 0x15180 )
      return v8 - v3 > 0x28 ? 2 : 0;
    return 1;
  }
  v5 = v3 - v8;
  if ( v5 > 0x15180 )
    return 1;
  return v5 > 2 ? 3 : 0;
}

//----- (1000B8A0) --------------------------------------------------------
int __thiscall sub_1000B8A0(void *this)
{
  unsigned int v1; // edi@1
  char v2; // bl@1
  int result; // eax@1
  unsigned int v4; // esi@1
  _BYTE *v5; // edx@1
  char v6; // cl@3

  v1 = *(_WORD *)this;
  v2 = 0;
  LOBYTE(result) = 0;
  v4 = 0;
  v5 = (char *)this + 24;
  do
  {
    if ( v4 >= v1 )
      break;
    v6 = *(v5 - 22);
    if ( v6 == 1 )
    {
      v2 = 1;
    }
    else if ( v6 == 5 )
    {
      if ( v2 )
      {
        if ( v4 == v1 - 1 || *v5 != 1 && *v5 != 5 )
          LOBYTE(result) = 2;
      }
      else
      {
        LOBYTE(result) = 1;
      }
    }
    ++v4;
    v5 += 22;
  }
  while ( !(_BYTE)result );
  return result;
}

//----- (1000B8F0) --------------------------------------------------------
int __usercall sub_1000B8F0@<eax>(int a1@<edi>, int a2)
{
  unsigned __int16 v2; // ax@1
  char v4; // [sp+Ch] [bp-10h]@1

  v2 = sub_1000B720((int)&unk_10228FF8, a1, (int)&dword_1022C764, 0x2000);
  sub_10002090(&unk_10228FF8, v2, 0, (int)&v4);
  sub_10001FE0((int)&v4, a2);
  return sub_10001F70((int)&dword_1022C774, a2, 4);
}
// 1022C764: using guessed type int dword_1022C764;
// 1022C774: using guessed type int dword_1022C774;

//----- (1000B950) --------------------------------------------------------
int __usercall sub_1000B950@<eax>(int result@<eax>)
{
  if ( !*(_BYTE *)(result + 1) && !*(_BYTE *)(result + 11) && *(_BYTE *)(result + 12) && !--dword_101EC2C8 )
    result = sub_10043370(223);
  return result;
}
// 101EC2C8: using guessed type int dword_101EC2C8;

//----- (1000B980) --------------------------------------------------------
int __usercall sub_1000B980@<eax>(unsigned int a1@<edi>, int a2@<esi>)
{
  int v2; // ecx@1
  int result; // eax@1
  int v4; // edx@1
  unsigned int v5; // [sp+0h] [bp-Ch]@0
  char v6; // [sp+4h] [bp-8h]@1
  char v7; // [sp+6h] [bp-6h]@1
  unsigned __int8 v8; // [sp+7h] [bp-5h]@1
  int v9; // [sp+8h] [bp-4h]@1

  sub_10042A60((int)&v9, v5);
  sub_10042C40((int)&v6, a1);
  result = v9;
  *(_DWORD *)a2 = HIWORD(v9);
  v2 = (unsigned __int8)result;
  LOBYTE(result) = v6;
  *(_DWORD *)(a2 + 8) = BYTE1(result);
  v4 = v8;
  *(_DWORD *)(a2 + 4) = v2;
  LOBYTE(v2) = v7;
  *(_BYTE *)(a2 + 12) = result;
  *(_BYTE *)(a2 + 13) = v2;
  *(_DWORD *)(a2 + 16) = v4;
  return result;
}

//----- (1000B9D0) --------------------------------------------------------
int __usercall sub_1000B9D0@<eax>(int a1@<eax>)
{
  char v1; // dl@1
  char v2; // cl@1
  __int16 v3; // dx@1
  char v4; // cl@1
  unsigned int v6; // [sp+0h] [bp-Ch]@1
  unsigned int v7; // [sp+4h] [bp-8h]@1
  int v8; // [sp+8h] [bp-4h]@1

  v1 = *(_BYTE *)(a1 + 4);
  HIWORD(v6) = *(_WORD *)a1;
  v2 = *(_BYTE *)(a1 + 8);
  LOBYTE(v6) = v1;
  v3 = *(_BYTE *)(a1 + 12);
  BYTE1(v6) = v2;
  v4 = *(_BYTE *)(a1 + 13);
  LOWORD(v7) = v3;
  LOBYTE(v3) = *(_BYTE *)(a1 + 16);
  BYTE2(v7) = v4;
  BYTE3(v7) = v3;
  sub_10042B50((int *)&v6, v6);
  sub_10042C90(&v8, v7);
  return v8 + v6;
}

//----- (1000BA30) --------------------------------------------------------
int __usercall sub_1000BA30@<eax>(unsigned int a1@<ecx>, int a2@<esi>)
{
  unsigned int v3; // [sp+0h] [bp-4h]@1

  v3 = a1;
  if ( !sub_10042DC0((char *)&v3) )
    sub_10042450(12, 3, 0, 0);
  return sub_1000B980(v3, a2);
}

//----- (1000BA60) --------------------------------------------------------
void *sub_1000BA60()
{
  int *v0; // ecx@1
  void *result; // eax@1
  signed int v2; // edx@1

  dword_101F8BCC = 0;
  word_1022C254 = 0;
  v0 = &dword_10228FF0;
  dword_101FBD74 = (int)&dword_101FBD74;
  dword_101FBD78 = (int)&dword_101FBD74;
  byte_101FBD6B = 1;
  dword_10228FF4 = (int)&dword_10228FF0;
  result = &unk_102289D8;
  v2 = 130;
  do
  {
    v0[1] = (int)result;
    *(_DWORD *)result = v0;
    *((_DWORD *)result + 1) = &dword_10228FF0;
    v0 = (int *)result;
    *((_DWORD *)result + 2) = -1;
    result = (char *)result + 12;
    --v2;
  }
  while ( v2 );
  dword_10228FF0 = (int)v0;
  dword_101FBD84 = -1;
  return result;
}
// 101F8BCC: using guessed type int dword_101F8BCC;
// 101FBD6B: using guessed type char byte_101FBD6B;
// 101FBD74: using guessed type int dword_101FBD74;
// 101FBD78: using guessed type int dword_101FBD78;
// 101FBD84: using guessed type int dword_101FBD84;
// 10228FF0: using guessed type int dword_10228FF0;
// 10228FF4: using guessed type int dword_10228FF4;
// 1022C254: using guessed type __int16 word_1022C254;

//----- (1000BAD0) --------------------------------------------------------
unsigned int __usercall sub_1000BAD0@<eax>(int a1@<esi>)
{
  unsigned int result; // eax@1
  _DWORD *v2; // ecx@1

  memset((void *)a1, 0, 0x1234u);
  *(_DWORD *)(a1 + 4640) = a1 + 4640;
  *(_DWORD *)(a1 + 4644) = a1 + 4640;
  *(_DWORD *)(a1 + 4648) = a1 + 4648;
  *(_DWORD *)(a1 + 4652) = a1 + 4648;
  result = 0;
  v2 = (_DWORD *)(a1 + 2364);
  do
  {
    *(v2 - 576) = result;
    *v2 = result++;
    v2 += 9;
  }
  while ( result < 0x40 );
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 20) = 13;
  *(_BYTE *)(a1 + 24) = 0;
  return result;
}

//----- (1000BB40) --------------------------------------------------------
int *__usercall sub_1000BB40@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // esi@1
  int *result; // eax@1
  int **v4; // edx@2
  int v5; // ecx@2

  v2 = a2 + 36 * a1;
  result = (int *)(v2 + 2336);
  if ( *(_DWORD *)(v2 + 2336) )
  {
    result = 0;
  }
  else
  {
    v4 = *(int ***)(a2 + 4652);
    v5 = a2 + 4648;
    *(_DWORD *)(v5 + 4) = result;
    *result = v5;
    *(_DWORD *)(v2 + 2340) = v4;
    *v4 = result;
    *(_DWORD *)(v2 + 2356) = -1;
  }
  return result;
}

//----- (1000BB80) --------------------------------------------------------
bool __usercall sub_1000BB80@<al>(_BYTE *a1@<ecx>, int a2@<edi>)
{
  _BYTE *v2; // esi@1
  bool v3; // bl@1
  void *v4; // ebp@2
  int v6; // ecx@18
  int v7; // edx@18
  char v8; // al@18
  char v9; // al@22
  bool v10; // zf@24
  int v11; // eax@27
  int v12; // eax@28
  unsigned int v13; // [sp+8h] [bp-24h]@1
  _BYTE *v14; // [sp+Ch] [bp-20h]@1
  int v15; // [sp+10h] [bp-1Ch]@20
  int v16; // [sp+14h] [bp-18h]@20
  int v17; // [sp+18h] [bp-14h]@20
  char v18; // [sp+1Ch] [bp-10h]@20
  char v19; // [sp+1Dh] [bp-Fh]@20
  int v20; // [sp+1Eh] [bp-Eh]@20
  int v21; // [sp+22h] [bp-Ah]@20
  char v22; // [sp+26h] [bp-6h]@20
  char v23; // [sp+27h] [bp-5h]@20

  v2 = a1;
  v3 = 0;
  *a1 = 0;
  v14 = a1;
  v13 = 0;
  if ( word_101F8BF4 )
  {
    v4 = &unk_101F8BF7;
    do
    {
      switch ( *((char *)v4 - 1) )
      {
        case 2:
          if ( a2 )
            *(_DWORD *)(a2 + 32) = sub_1007C040();
          *v2 = 1;
          goto LABEL_7;
        case 0xA1:
          v3 = a2 && *(_BYTE *)(a2 + 13) == 1;
          if ( dword_101FBD88 )
            sub_1000AC40(dword_101FBD88, 3);
          if ( *(_BYTE *)v4 && *(_BYTE *)v4 != 1 )
          {
            v6 = *(_DWORD *)((char *)v4 + 1);
            v7 = *(_DWORD *)((char *)v4 + 5);
            v8 = *((_BYTE *)v4 + 9);
            dword_101FBD88 = 0;
            *(_DWORD *)dword_101FBD8C = v6;
            dword_101FBD90 = v7;
            byte_101FBD94 = v8;
          }
          else
          {
            sub_1000BAD0((int)&dword_101FBD88);
            v2 = v14;
          }
          v20 = *(_DWORD *)dword_101FBD8C;
          v22 = byte_101FBD94;
          v18 = 9;
          v19 = 9;
          v21 = dword_101FBD90;
          v23 = -1;
          v15 = -1;
          v16 = -1;
          v17 = 255;
          sub_1002F090(0, 0, 0, (int)&v15, 0, 0);
          goto LABEL_8;
        case 0xA0:
        case 0xA3:
          *v2 = 1;
          if ( !a2 )
            goto LABEL_7;
          v9 = *(_BYTE *)(a2 + 13);
          if ( v9 == 1 )
            goto LABEL_36;
          if ( v9 )
            goto LABEL_7;
          v10 = *(_DWORD *)(a2 + 16) == 0;
          goto LABEL_35;
        case 0xE4:
          if ( !a2 || !*(_BYTE *)(a2 + 8) )
            goto LABEL_7;
          v11 = *(_DWORD *)(a2 + 20);
          *(_BYTE *)(a2 + 8) = 0;
          if ( v11 != -1 )
          {
            v12 = sub_1002F710(dword_101FBD80, v11, 0);
            *(_BYTE *)(v12 + 13) = 3;
            *(_BYTE *)(v12 + 1) = v3 == 0;
            sub_1002F6D0(dword_101FBD80, *(_DWORD *)(a2 + 20));
          }
          if ( *(_BYTE *)(a2 + 13) )
            goto LABEL_7;
          v10 = *(_DWORD *)(a2 + 16) == 0;
          goto LABEL_35;
        case 0xEA:
          dword_101F8BCC = 1;
          break;
        default:
          *v2 = 1;
          break;
      }
      if ( !a2 )
        goto LABEL_7;
      v10 = *(_BYTE *)(a2 + 13) == 1;
LABEL_35:
      if ( v10 )
LABEL_36:
        v3 = 1;
      else
LABEL_7:
        v3 = 0;
LABEL_8:
      v4 = (char *)v4 + 258;
      ++v13;
    }
    while ( v13 < (unsigned __int16)word_101F8BF4 );
  }
  return v3;
}
// 101F8BCC: using guessed type int dword_101F8BCC;
// 101F8BF4: using guessed type __int16 word_101F8BF4;
// 101FBD80: using guessed type int dword_101FBD80;
// 101FBD88: using guessed type int dword_101FBD88;
// 101FBD90: using guessed type int dword_101FBD90;
// 101FBD94: using guessed type char byte_101FBD94;

//----- (1000BE80) --------------------------------------------------------
void __usercall sub_1000BE80(int a1@<ebx>)
{
  unsigned int v1; // edi@2
  unsigned int *v2; // esi@3
  unsigned int v3; // eax@5

  if ( !*(_BYTE *)(a1 + 11) )
  {
    v1 = 0;
    if ( *(_WORD *)(a1 + 40) )
    {
      v2 = (unsigned int *)(a1 + 65);
      do
      {
        switch ( *((_BYTE *)v2 - 23) )
        {
          case 0x50:
          case 0x54:
          case 0x57:
            v3 = *v2;
            goto LABEL_7;
          case 0x51:
          case 0x56:
            v3 = *(unsigned int *)((char *)v2 - 22);
LABEL_7:
            if ( v3 >= 0x9858 && v3 <= 0x985F )
              sub_1002F8C0(dword_101EC2CC, v3);
            break;
          default:
            break;
        }
        ++v1;
        v2 = (unsigned int *)((char *)v2 + 258);
      }
      while ( v1 < *(_WORD *)(a1 + 40) );
    }
  }
}
// 101EC2CC: using guessed type int dword_101EC2CC;

//----- (1000BF00) --------------------------------------------------------
char __usercall sub_1000BF00@<al>(int a1@<edi>, int a2@<esi>, char a3)
{
  int v3; // ecx@1
  int v4; // edx@1
  char v5; // al@1
  int v7; // [sp+0h] [bp-1Ch]@4
  int v8; // [sp+4h] [bp-18h]@4
  int v9; // [sp+8h] [bp-14h]@4
  char v10; // [sp+Ch] [bp-10h]@1
  char v11; // [sp+Dh] [bp-Fh]@1
  int v12; // [sp+Eh] [bp-Eh]@1
  int v13; // [sp+12h] [bp-Ah]@1
  char v14; // [sp+16h] [bp-6h]@1
  char v15; // [sp+17h] [bp-5h]@2

  v3 = *(_DWORD *)(a2 + 2);
  v4 = *(_DWORD *)(a2 + 6);
  v10 = a3;
  v14 = *(_BYTE *)(a2 + 10);
  v5 = *(_BYTE *)(a2 + 11);
  v12 = v3;
  v11 = 9;
  v13 = v4;
  if ( v5 )
    v15 = -1;
  else
    v15 = dword_102289D4;
  v8 = *(_DWORD *)(a2 + 36);
  v9 = 255;
  v7 = a1;
  sub_1002F090(0, v5 != 0, 0, (int)&v7, 0, 0);
  *(_DWORD *)(a2 + 28) = -1;
  *(_DWORD *)(a2 + 32) = -1;
  *(_DWORD *)(a2 + 36) = -1;
  return sub_1002F8C0(dword_101FBD80, a1);
}
// 101FBD80: using guessed type int dword_101FBD80;
// 102289D4: using guessed type int dword_102289D4;

//----- (1000BFA0) --------------------------------------------------------
unsigned int __usercall sub_1000BFA0@<eax>(int a1@<eax>, int a2@<ebx>, void *a3@<edi>)
{
  unsigned int result; // eax@1
  unsigned int v4; // esi@1
  void *v5; // [sp+0h] [bp-8h]@0

  result = sub_1002F920(a2, a1, v5);
  v4 = result;
  if ( result == -1 )
  {
    sub_10042450(12, 7, a3, *(_WORD *)(a2 + 8));
    result = v4;
  }
  return result;
}

//----- (1000BFD0) --------------------------------------------------------
char sub_1000BFD0()
{
  char v0; // al@2
  char result; // al@7

  if ( sub_10043620(3u, 0) || (v0 = sub_10043620(3u, 1u)) != 0 )
    v0 = 1;
  if ( !v0 && !sub_10043620(3u, 2u) )
    sub_10043590(0x5Bu);
  result = sub_10043480(0xDFu);
  ++dword_101EC2C8;
  return result;
}
// 101EC2C8: using guessed type int dword_101EC2C8;

//----- (1000C040) --------------------------------------------------------
BOOL __usercall sub_1000C040@<eax>(int a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // ebp@1
  signed int v4; // eax@3
  unsigned int v5; // edi@5
  unsigned __int8 *v6; // ebx@6
  int v7; // eax@7
  __int16 v8; // dx@7

  v3 = a3;
  if ( !a1 || *(_BYTE *)(a1 + 10) || (v4 = 1, byte_1022C256 != 3) )
    v4 = dword_101F8BCC;
  *(_DWORD *)(a3 + 32) = v4;
  *(_WORD *)a2 = 0;
  v5 = 0;
  *(_BYTE *)(a2 + 2) = 0;
  if ( *(_WORD *)(v3 + 36) )
  {
    v6 = (unsigned __int8 *)(v3 + 38);
    do
    {
      v7 = sub_1002F340((int)&a3, *v6);
      v8 = *(_WORD *)v7;
      *(_BYTE *)(a2 + 2) |= *(_BYTE *)(v7 + 2);
      ++v5;
      v6 += 258;
    }
    while ( v5 < *(_WORD *)(v3 + 36) );
  }
  return *(_BYTE *)(a2 + 2) || !*(_DWORD *)(v3 + 32);
}
// 101F8BCC: using guessed type int dword_101F8BCC;
// 1022C256: using guessed type char byte_1022C256;

//----- (1000C0D0) --------------------------------------------------------
BOOL __usercall sub_1000C0D0@<eax>(int a1@<esi>, int a2)
{
  int v2; // ebp@1
  unsigned int v3; // edi@1
  unsigned __int8 *v4; // ebx@2
  int v5; // eax@3
  __int16 v6; // dx@3
  char v7; // al@4
  char v8; // al@5

  v2 = a2;
  *(_WORD *)a1 = 0;
  *(_BYTE *)(a1 + 2) = 0;
  v3 = 0;
  if ( *(_WORD *)(v2 + 36) )
  {
    v4 = (unsigned __int8 *)(v2 + 38);
    do
    {
      v5 = sub_1002F380((int)&a2, *v4);
      v6 = *(_WORD *)v5;
      *(_BYTE *)(a1 + 2) |= *(_BYTE *)(v5 + 2);
      ++v3;
      v4 += 258;
    }
    while ( v3 < *(_WORD *)(v2 + 36) );
  }
  v7 = *(_BYTE *)(a1 + 2);
  if ( v7 & 8 )
  {
    v8 = v7 & 9;
LABEL_8:
    *(_BYTE *)(a1 + 2) = v8;
    return *(_BYTE *)(a1 + 2) || !*(_DWORD *)(v2 + 32);
  }
  if ( v7 & 4 )
  {
    v8 = v7 & 5;
    goto LABEL_8;
  }
  return *(_BYTE *)(a1 + 2) || !*(_DWORD *)(v2 + 32);
}

//----- (1000C150) --------------------------------------------------------
signed int sub_1000C150()
{
  int v0; // esi@1
  int v1; // eax@2
  char v2; // cl@4
  int v4; // [sp+4h] [bp-4h]@1

  sub_10042DC0((char *)&v4);
  v0 = 38000;
  while ( 1 )
  {
    v1 = sub_1002F710(dword_101FBD80, v0, 1);
    if ( v1 && *(_BYTE *)(v1 + 11) == 1 )
    {
      v2 = *(_BYTE *)(v1 + 14);
      if ( v2 == 1 || v2 == 3 )
        return sub_1002F240(dword_101FBD80, v0);
      if ( (*(_BYTE *)(v1 + 12) || *(_BYTE *)(v1 + 13) == 2) && *(_DWORD *)(v1 + 24) <= (unsigned int)(v4 - 420) )
        break;
    }
    if ( (unsigned int)++v0 > 0x94F1 )
      return -1;
  }
  return sub_1002F240(dword_101FBD80, v0);
}
// 101FBD80: using guessed type int dword_101FBD80;

//----- (1000C1F0) --------------------------------------------------------
char __usercall sub_1000C1F0@<al>(int a1@<eax>, int a2)
{
  int v2; // esi@1
  int v3; // ebx@1
  int v4; // eax@3
  char result; // al@4
  signed int v6; // edi@5
  int v7; // eax@10
  int v8; // esi@10
  unsigned int v9; // edi@13
  _BYTE *v10; // ebp@14
  char v11; // [sp+Bh] [bp-1h]@7

  v2 = a2;
  v3 = a1;
  if ( *(_DWORD *)a2 != 38000 || (unsigned int)(a1 - 38000) >= *(_DWORD *)(a2 + 4) )
  {
    sub_10042930("..\\lib\\atn\\atn_cpdlc_user.c", 6815, 0, "tag is out of range");
    result = 0;
  }
  else
  {
    v4 = sub_1002F710(a2, a1, 1);
    if ( v4 )
    {
      v6 = -1;
      if ( *(_DWORD *)(v4 + 32) == -1 )
      {
        v11 = 0;
        if ( v3 != -1 )
        {
          while ( 1 )
          {
            v7 = sub_1002F710(v2, v3, 1);
            v8 = v7;
            if ( !v7 )
            {
              sub_10042930("..\\lib\\atn\\atn_cpdlc_user.c", 6854, 0, "thread has a link to an invalid tag");
              goto LABEL_23;
            }
            if ( *(_DWORD *)(v7 + 32) != v6 )
              break;
            if ( !*(_BYTE *)(v7 + 11) )
            {
              v9 = 0;
              if ( *(_WORD *)(v7 + 40) )
              {
                v10 = (_BYTE *)(v7 + 42);
                while ( !sub_1000B1F0(v10) )
                {
                  ++v9;
                  v10 += 258;
                  if ( v9 >= *(_WORD *)(v8 + 40) )
                    goto LABEL_19;
                }
                v11 = (v3 == dword_101FBD84) + 1;
              }
            }
LABEL_19:
            v6 = v3;
            v3 = *(_DWORD *)(v8 + 28);
            if ( v3 == -1 )
              return v11;
            v2 = a2;
          }
          sub_10042930("..\\lib\\atn\\atn_cpdlc_user.c", 6864, 0, "encountered an invalid thread link");
        }
LABEL_23:
        result = v11;
      }
      else
      {
        sub_10042930("..\\lib\\atn\\atn_cpdlc_user.c", 6830, 0, "tag is not the top of a thread");
        result = 0;
      }
    }
    else
    {
      sub_10042930("..\\lib\\atn\\atn_cpdlc_user.c", 6825, 0, "tag is not valid");
      result = 0;
    }
  }
  return result;
}
// 101FBD84: using guessed type int dword_101FBD84;

//----- (1000C350) --------------------------------------------------------
char __usercall sub_1000C350@<al>(int a1@<eax>, char a2)
{
  int v2; // edi@1
  char result; // al@1
  int v4; // esi@2
  int v5; // ebx@5

  v2 = a1;
  result = sub_1002F710(dword_101FBD80, a1, 1);
  if ( v2 != -1 )
  {
    do
    {
      v4 = sub_1002F710(dword_101FBD80, v2, 0);
      sub_1000BE80(v4);
      if ( !*(_BYTE *)(v4 + 11) && !*(_BYTE *)(v4 + 12) )
      {
        *(_BYTE *)(v4 + 12) = 1;
        sub_1000B950(v4);
      }
      v5 = *(_DWORD *)(v4 + 28);
      result = sub_1000BF00(v2, v4, a2);
      v2 = v5;
    }
    while ( v5 != -1 );
  }
  return result;
}
// 101FBD80: using guessed type int dword_101FBD80;

//----- (1000C3C0) --------------------------------------------------------
char __thiscall sub_1000C3C0(void *this)
{
  unsigned int v1; // edi@1
  unsigned int v2; // esi@1
  char result; // al@1
  _BYTE *v4; // ecx@1

  v1 = *(_WORD *)this;
  v2 = 0;
  result = 1;
  v4 = (char *)this + 2;
  do
  {
    if ( v2 >= v1 )
      break;
    switch ( *v4 )
    {
      case 0x3F:
      case 0x40:
      case 0x64:
      case 0x65:
      case 0x6C:
        result = 0;
        break;
      default:
        break;
    }
    ++v2;
    v4 += 258;
  }
  while ( result );
  return result;
}

//----- (1000C440) --------------------------------------------------------
bool __usercall sub_1000C440@<al>(int a1@<eax>)
{
  char v1; // cl@1
  __int16 v2; // dx@3
  char v3; // cl@5
  char v4; // cl@8
  bool result; // al@12

  v1 = *(_BYTE *)(a1 + 38);
  result = 1;
  if ( v1 == 118 || v1 == 121 )
  {
    v2 = *(_WORD *)(a1 + 36);
    if ( v2 != 1 )
    {
      if ( v2 != 2 || (v3 = *(_BYTE *)(a1 + 296), v3 != -120) && v3 != -72 )
      {
        if ( v2 != 3
          || ((v4 = *(_BYTE *)(a1 + 296), v4 != -120) || *(_BYTE *)(a1 + 554) != -72)
          && (v4 != -72 || *(_BYTE *)(a1 + 554) != -120) )
        {
          result = 0;
        }
      }
    }
  }
  return result;
}

//----- (1000C4A0) --------------------------------------------------------
bool __usercall sub_1000C4A0@<al>(int a1@<eax>)
{
  bool result; // al@2

  if ( *(_BYTE *)(a1 + 1) )
    result = *(_BYTE *)a1 == 0;
  else
    result = 1;
  return result;
}

//----- (1000C4B0) --------------------------------------------------------
char __cdecl sub_1000C4B0(unsigned int a1)
{
  int v1; // eax@2
  int v2; // eax@3
  int v3; // eax@10

  if ( a1 == -1 )
  {
    v1 = 38000;
    a1 = 38000;
    do
    {
      v2 = sub_1002F710(dword_101FBD80, v1, 1);
      if ( v2 && *(_DWORD *)(v2 + 32) == -1 && sub_1002F3C0(dword_101FBD80, a1, 0) )
        sub_1000C350(a1, 4);
      v1 = a1++ + 1;
    }
    while ( a1 <= 0x94F1 );
  }
  else if ( a1 - 38000 > 0x81 )
  {
    LOBYTE(v1) = sub_10042450(12, 5, &a1, 4u);
  }
  else
  {
    v3 = sub_1002F710(dword_101FBD80, a1, 1);
    if ( v3 )
    {
      if ( *(_DWORD *)(v3 + 32) == -1 )
      {
        if ( sub_1002F3C0(dword_101FBD80, a1, 0) )
          LOBYTE(v1) = sub_1000C350(a1, 3);
        else
          LOBYTE(v1) = sub_10042450(12, 10, &a1, 4u);
      }
      else
      {
        LOBYTE(v1) = sub_10042450(12, 20, &a1, 4u);
      }
    }
    else
    {
      LOBYTE(v1) = sub_10042450(12, 5, &a1, 4u);
    }
  }
  return v1;
}
// 101FBD80: using guessed type int dword_101FBD80;

//----- (1000C5C0) --------------------------------------------------------
int __usercall sub_1000C5C0@<eax>(int a1@<eax>, unsigned int a2@<ecx>, char a3)
{
  dword_1022C230 = a1;
  if ( a3 )
  {
    byte_1022C238 = 1;
    dword_1022C234 = a2;
  }
  else
  {
    byte_1022C238 = 0;
  }
  dword_1022C250 = dword_101F8BCC;
  return sub_1000BA30(a2, (int)&unk_1022C23C);
}
// 101F8BCC: using guessed type int dword_101F8BCC;
// 1022C230: using guessed type int dword_1022C230;
// 1022C234: using guessed type int dword_1022C234;
// 1022C238: using guessed type char byte_1022C238;
// 1022C250: using guessed type int dword_1022C250;

//----- (1000C600) --------------------------------------------------------
int *__usercall sub_1000C600@<eax>(int a1@<eax>, int a2@<ecx>, char a3)
{
  int v3; // esi@1
  int v4; // edi@1

  v3 = a1;
  v4 = a2;
  dword_1022C760 = 0;
  dword_1022C764 = 0;
  dword_1022C768 = 0;
  dword_1022C76C = 0;
  dword_1022C770 = 0;
  dword_1022C774 = 0;
  dword_1022C778 = 0;
  dword_1022C77C = 0;
  dword_101FBD70 = 0;
  if ( !a1 )
  {
    LOBYTE(dword_1022C770) = 0;
    goto LABEL_7;
  }
  LOBYTE(dword_1022C770) = 1;
  if ( !sub_1000B180((int)&dword_1022C764, a1) )
  {
LABEL_7:
    sub_1000B8F0(v4 + 12, (int)&dword_101FBD70);
    return &dword_1022C760;
  }
  sub_10042450(12, 1, (void *)(v3 + 38), 1u);
  if ( a3 )
    sub_1000AC40(v4, 0);
  return 0;
}
// 101FBD70: using guessed type int dword_101FBD70;
// 1022C760: using guessed type int dword_1022C760;
// 1022C764: using guessed type int dword_1022C764;
// 1022C768: using guessed type int dword_1022C768;
// 1022C76C: using guessed type int dword_1022C76C;
// 1022C770: using guessed type int dword_1022C770;
// 1022C774: using guessed type int dword_1022C774;
// 1022C778: using guessed type int dword_1022C778;
// 1022C77C: using guessed type int dword_1022C77C;

//----- (1000C6A0) --------------------------------------------------------
char __cdecl sub_1000C6A0(int a1, int a2, char a3)
{
  char result; // al@3
  unsigned __int16 v4; // ax@4
  int v5; // esi@4
  unsigned int v6; // eax@4
  int v7; // [sp+4h] [bp-10h]@4
  int v8; // [sp+8h] [bp-Ch]@5
  int v9; // [sp+Ch] [bp-8h]@6
  int v10; // [sp+10h] [bp-4h]@7

  if ( a3 || sub_1000C4A0(a2) )
  {
    v4 = sub_1000B720((int)byte_10228FF8, a1 + 12, a2 + 4, 0x2000);
    v5 = v4;
    v6 = sub_10001F10(&byte_10228FF8[v4], 0x2000 - v4, a2 + 20);
    sub_10002090(byte_10228FF8, v6 + v5, 0, (int)&v7);
    if ( v7 || v8 || v9 || v10 )
    {
      sub_1000AC40(a1, 9);
      result = 0;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    sub_1000AC40(a1, 8);
    result = 0;
  }
  return result;
}

//----- (1000C760) --------------------------------------------------------
int __usercall sub_1000C760@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // eax@2
  int v3; // edi@2
  int v4; // edx@3
  int v5; // eax@4
  _DWORD *v6; // ecx@4
  int result; // eax@4

  v1 = *(_DWORD *)(a1 + 20);
  if ( v1 != -1 )
  {
    v2 = sub_1002F710(dword_101FBD80, v1, 0);
    v3 = v2;
    if ( *(_BYTE *)(v2 + 1) )
    {
      v4 = dword_101FBD80;
      *(_BYTE *)(v2 + 1) = 0;
      sub_1002F6D0(v4, *(_DWORD *)(a1 + 20));
      sub_1000B950(v3);
    }
  }
  v5 = *(_DWORD *)a1;
  v6 = *(_DWORD **)(a1 + 4);
  *(_DWORD *)(v5 + 4) = v6;
  *v6 = v5;
  result = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}
// 101FBD80: using guessed type int dword_101FBD80;

//----- (1000C7C0) --------------------------------------------------------
char __usercall sub_1000C7C0@<al>(int a1@<eax>, int a2)
{
  int v2; // esi@1
  char v3; // bl@1
  unsigned int v4; // ebp@2
  _BYTE *v5; // edi@2
  unsigned int v6; // ebp@10
  _BYTE *v7; // edi@10
  unsigned int v8; // ebp@18
  _BYTE *v9; // edi@18
  unsigned int v10; // ebp@26
  _BYTE *v11; // edi@26
  unsigned int v12; // edx@34

  v2 = a1;
  LOBYTE(a1) = *(_BYTE *)(a2 + 13);
  v3 = 0;
  if ( a1 & 8 )
  {
    v4 = 0;
    v5 = (_BYTE *)(v2 + 38);
    while ( v4 < *(_WORD *)(v2 + 36) )
    {
      a1 = *v5;
      switch ( a1 )
      {
        case 1:
        case 2:
        case 63:
        case 64:
        case 108:
          v3 = 1;
          break;
        case 3:
          a1 = sub_1007C040();
          *(_DWORD *)(a2 + 32) = a1;
          break;
        default:
          break;
      }
      ++v4;
      v5 += 258;
      if ( v3 )
      {
        LOBYTE(a1) = sub_1000C760(a2);
        return a1;
      }
    }
  }
  else if ( a1 & 4 )
  {
    v6 = 0;
    v7 = (_BYTE *)(v2 + 38);
    while ( v6 < *(_WORD *)(v2 + 36) )
    {
      a1 = *v7;
      switch ( a1 )
      {
        case 5:
        case 6:
        case 63:
        case 64:
        case 108:
          v3 = 1;
          break;
        case 3:
          a1 = sub_1007C040();
          *(_DWORD *)(a2 + 32) = a1;
          break;
        default:
          break;
      }
      ++v6;
      v7 += 258;
      if ( v3 )
      {
        LOBYTE(a1) = sub_1000C760(a2);
        return a1;
      }
    }
  }
  else if ( a1 & 2 )
  {
    v8 = 0;
    v9 = (_BYTE *)(v2 + 38);
    while ( v8 < *(_WORD *)(v2 + 36) )
    {
      a1 = *v9;
      switch ( a1 )
      {
        case 2:
        case 4:
        case 63:
        case 64:
        case 108:
          v3 = 1;
          break;
        case 3:
          a1 = sub_1007C040();
          *(_DWORD *)(a2 + 32) = a1;
          break;
        default:
          break;
      }
      ++v8;
      v9 += 258;
      if ( v3 )
      {
        LOBYTE(a1) = sub_1000C760(a2);
        return a1;
      }
    }
  }
  else if ( a1 & 1 )
  {
    v3 = 1;
    v10 = 0;
    v11 = (_BYTE *)(v2 + 38);
    while ( v10 < *(_WORD *)(v2 + 36) )
    {
      LOBYTE(a1) = *v11;
      if ( *v11 == 3 )
      {
        v3 = 0;
        a1 = sub_1007C040();
        *(_DWORD *)(a2 + 32) = a1;
      }
      else if ( (_BYTE)a1 == 101 )
      {
        v3 = 0;
      }
      ++v10;
      v11 += 258;
      if ( !v3 )
        return a1;
    }
  }
  else
  {
    v12 = 0;
    a1 = v2 + 38;
    while ( v12 < *(_WORD *)(v2 + 36) )
    {
      switch ( *(_BYTE *)a1 )
      {
        case 0x3F:
        case 0x40:
        case 0x65:
        case 0x6C:
          v3 = 1;
          break;
        default:
          break;
      }
      ++v12;
      a1 += 258;
      if ( v3 )
      {
        LOBYTE(a1) = sub_1000C760(a2);
        return a1;
      }
    }
  }
  if ( v3 )
    LOBYTE(a1) = sub_1000C760(a2);
  return a1;
}

//----- (1000CB30) --------------------------------------------------------
unsigned int __cdecl sub_1000CB30(int a1, char a2)
{
  int v2; // ebp@1
  _DWORD **v3; // eax@1
  _DWORD *v4; // edi@1
  int v5; // eax@2
  bool v6; // zf@2
  _DWORD **v7; // eax@3
  _DWORD *v8; // edi@3
  int v9; // eax@4
  int *v10; // edi@6
  int v11; // eax@7
  int v12; // esi@7
  int v13; // eax@7
  int v14; // eax@7
  _DWORD *v15; // ecx@7
  int v16; // eax@7
  unsigned int result; // eax@10
  int v18; // edi@11
  int v19; // ebx@11
  int v20; // [sp+0h] [bp-10h]@0

  v2 = a1;
  v3 = *(_DWORD ***)(a1 + 4640);
  v4 = *v3;
  if ( v3 != (_DWORD **)(a1 + 4640) )
  {
    do
    {
      v5 = nullsub_1(v20);
      sub_1000C760(v5);
      v6 = v4 == (_DWORD *)(a1 + 4640);
      v4 = (_DWORD *)*v4;
    }
    while ( !v6 );
  }
  v7 = *(_DWORD ***)(a1 + 4648);
  v8 = *v7;
  if ( v7 != (_DWORD **)(a1 + 4648) )
  {
    do
    {
      v9 = nullsub_1(v20);
      sub_1000C760(v9);
      v6 = v8 == (_DWORD *)(a1 + 4648);
      v8 = (_DWORD *)*v8;
    }
    while ( !v6 );
  }
  if ( (int *)a1 == &dword_1022AFF8 )
  {
    v10 = *(int **)dword_101FBD74;
    if ( (int *)dword_101FBD74 != &dword_101FBD74 )
    {
      do
      {
        v11 = nullsub_1(v20);
        v12 = v11;
        v13 = sub_1002F710(dword_101FBD80, *(_DWORD *)(v11 + 8), 0);
        *(_BYTE *)(v13 + 1) = 0;
        *(_BYTE *)(v13 + 14) = 1;
        sub_10042DC0((char *)(v13 + 24));
        sub_1002F6D0(dword_101FBD80, *(_DWORD *)(v12 + 8));
        v14 = *(_DWORD *)v12;
        v15 = *(_DWORD **)(v12 + 4);
        *(_DWORD *)(v14 + 4) = v15;
        *v15 = v14;
        *(_DWORD *)v12 = v12;
        *(_DWORD *)(v12 + 4) = v12;
        v16 = dword_10228FF0;
        *(_DWORD *)(dword_10228FF0 + 4) = v12;
        *(_DWORD *)v12 = v16;
        *(_DWORD *)(v12 + 4) = &dword_10228FF0;
        dword_10228FF0 = v12;
        v6 = v10 == &dword_101FBD74;
        *(_DWORD *)(v12 + 8) = -1;
        v10 = (int *)*v10;
      }
      while ( !v6 );
      v2 = a1;
    }
  }
  if ( a2 )
  {
    result = sub_1000BAD0(v2);
  }
  else
  {
    v18 = *(_DWORD *)(v2 + 16);
    v19 = *(_DWORD *)(v2 + 20);
    result = sub_1000BAD0(v2);
    *(_DWORD *)(v2 + 16) = v18;
    *(_DWORD *)(v2 + 20) = v19;
  }
  return result;
}
// 101FBD74: using guessed type int dword_101FBD74;
// 101FBD80: using guessed type int dword_101FBD80;
// 10228FF0: using guessed type int dword_10228FF0;
// 1022AFF8: using guessed type int dword_1022AFF8;

//----- (1000CC50) --------------------------------------------------------
int __usercall sub_1000CC50@<eax>(char a1@<bl>, int a2@<edi>, int a3, char a4, int a5)
{
  int v5; // ecx@1
  int v6; // eax@1
  int result; // eax@6
  _DWORD *v8; // ebp@7
  int v9; // ecx@7
  int v10; // esi@7
  signed int v11; // edx@8

  v5 = *(_DWORD *)(a2 + 28);
  v6 = ((_BYTE)v5 + 1) & 0x3F;
  if ( v6 == v5 )
  {
LABEL_4:
    if ( a4 == 1 )
      sub_1000AC40(*(_DWORD *)a2, 1);
    result = 0;
  }
  else
  {
    while ( *(_DWORD *)(a2 + 36 * v6 + 32) )
    {
      v6 = ((_BYTE)v6 + 1) & 0x3F;
      if ( v6 == *(_DWORD *)(a2 + 28) )
        goto LABEL_4;
    }
    v8 = *(_DWORD **)(a2 + 4644);
    v9 = a2 + 36 * v6;
    v10 = v9 + 32;
    *(_DWORD *)(a2 + 4644) = v9 + 32;
    *(_DWORD *)v10 = a2 + 4640;
    *(_DWORD *)(v10 + 4) = v8;
    *v8 = v9 + 32;
    *(_WORD *)(v9 + 43) = 0;
    *(_BYTE *)(v9 + 45) = 0;
    *(_DWORD *)(v9 + 52) = a3;
    if ( a1 )
      v11 = *(_DWORD *)(a5 + 20);
    else
      v11 = -1;
    *(_DWORD *)(v9 + 56) = v11;
    *(_DWORD *)(v9 + 48) = dword_101F8BCC;
    *(_BYTE *)(v9 + 42) = 4;
    *(_BYTE *)(v9 + 40) = 0;
    *(_BYTE *)(v9 + 41) = 0;
    *(_DWORD *)(a2 + 28) = v6;
    if ( a1 )
    {
      sub_1000C5C0(v6, *(_DWORD *)(a5 + 28), a1);
      result = v10;
    }
    else
    {
      sub_1000C5C0(v6, 0, 0);
      result = v10;
    }
  }
  return result;
}
// 101F8BCC: using guessed type int dword_101F8BCC;

//----- (1000CD70) --------------------------------------------------------
#error "1000CDFF: call analysis failed (funcsize=91)"

//----- (1000CEA0) --------------------------------------------------------
int __cdecl sub_1000CEA0(int a1, char a2)
{
  int result; // eax@1
  int v3; // esi@1
  int *v4; // eax@5

  result = sub_1000CC50(0, (int)&dword_1022AFF8, -1, 1, 0);
  v3 = result;
  if ( result )
  {
    if ( byte_101FBD7F )
    {
      byte_1022C238 = 1;
      dword_1022C234 = a1;
    }
    else
    {
      byte_1022C238 = 0;
    }
    sub_1000B590(0, 0, 2);
    v4 = sub_1000C600((int)&dword_1022C230, dword_1022AFF8, 1);
    if ( v4 )
    {
      if ( a2 == 1 )
      {
        sub_1000AAA0(dword_1022AFF8, (int)v4, 1);
        return sub_1000C760(v3);
      }
      sub_1000A9C0(dword_1022AFF8, 2, (int)v4, 1);
    }
    result = sub_1000C760(v3);
  }
  return result;
}
// 101FBD7F: using guessed type char byte_101FBD7F;
// 1022AFF8: using guessed type int dword_1022AFF8;
// 1022C230: using guessed type int dword_1022C230;
// 1022C234: using guessed type int dword_1022C234;
// 1022C238: using guessed type char byte_1022C238;

//----- (1000CF40) --------------------------------------------------------
signed int __cdecl sub_1000CF40(char a1)
{
  unsigned int v1; // ebp@1
  signed int v2; // ebx@1
  unsigned int v3; // esi@1
  int v4; // eax@2
  int v5; // edi@2
  int v6; // eax@6
  char v7; // al@8
  char v9; // [sp+10h] [bp-4h]@1

  sub_10042DC0(&v9);
  v1 = -1;
  v2 = -1;
  v3 = 38000;
  do
  {
    v4 = sub_1002F710(dword_101FBD80, v3, 1);
    v5 = v4;
    if ( v4 && *(_DWORD *)(v4 + 32) == -1 && *(_DWORD *)(v4 + 24) < v1 && sub_1002F3C0(dword_101FBD80, v3, 1) )
    {
      v6 = (unsigned __int8)sub_1000C1F0(v3, dword_101FBD80) - 1;
      if ( v6 )
      {
        if ( v6 == 1 )
          goto LABEL_12;
        v7 = a1 == 0;
      }
      else
      {
        v7 = a1;
      }
      if ( v7 )
      {
        v1 = *(_DWORD *)(v5 + 24);
        v2 = v3;
      }
    }
LABEL_12:
    ++v3;
  }
  while ( v3 <= 0x94F1 );
  return v2;
}
// 101FBD80: using guessed type int dword_101FBD80;

//----- (1000CFE0) --------------------------------------------------------
char __usercall sub_1000CFE0@<al>(int **a1@<esi>, int a2)
{
  char result; // al@4

  if ( word_101F8BF4 != 1 || byte_101F8BF6 != 118 && byte_101F8BF6 != 121 )
  {
    if ( byte_101FBD7F )
    {
      sub_1000C5C0(a2, dword_101F8BD0, 1);
      sub_1000B590("THIS MESSAGE ELEMENT NOT PERMITTED IN END", 0x2Au, 0);
      *a1 = sub_1000C600((int)&dword_1022C230, dword_1022AFF8, 1);
      result = 0;
    }
    else
    {
      *a1 = sub_1000C600(0, dword_1022AFF8, 1);
      result = 0;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}
// 101F8BD0: using guessed type int dword_101F8BD0;
// 101F8BF4: using guessed type __int16 word_101F8BF4;
// 101F8BF6: using guessed type char byte_101F8BF6;
// 101FBD7F: using guessed type char byte_101FBD7F;
// 1022AFF8: using guessed type int dword_1022AFF8;
// 1022C230: using guessed type int dword_1022C230;

//----- (1000D060) --------------------------------------------------------
void __usercall sub_1000D060(_BYTE *a1@<ebx>, unsigned int *a2@<edi>, int a3, int **a4, int a5)
{
  char v5; // al@1
  size_t v6; // edx@4
  const char *v7; // eax@4
  int *v8; // eax@7

  v5 = sub_1000B7F0((int)(a2 + 3));
  if ( v5 == 1 )
  {
    sub_1000AC40(a3, 7);
    *a1 = 3;
    return;
  }
  if ( v5 == 2 )
  {
    sub_1000C5C0(a5, *a2, byte_101FBD7F);
    v6 = 67;
    v7 = "UPLINK DELAYED IN NETWORK AND REJECTED. RESEND OR CONTACT BY VOICE";
  }
  else
  {
    if ( v5 != 3 )
      return;
    sub_1000C5C0(a5, *a2, byte_101FBD7F);
    v6 = 39;
    v7 = "UPLINK TIMESTAMP INDICATES FUTURE TIME";
  }
  sub_1000B590(v7, v6, 2);
  v8 = sub_1000C600((int)&dword_1022C230, a3, 1);
  *a4 = v8;
  *a1 = (v8 != 0) + 3;
}
// 101FBD7F: using guessed type char byte_101FBD7F;
// 1022C230: using guessed type int dword_1022C230;

//----- (1000D100) --------------------------------------------------------
void __usercall sub_1000D100(int a1@<edi>, int a2@<esi>, int a3, _BYTE *a4, int **a5, int *a6, int a7)
{
  char v7; // bl@1
  char v8; // dl@3
  int v9; // eax@5
  unsigned int v10; // edx@7
  _BYTE *v11; // eax@7
  int *v12; // eax@16
  unsigned __int16 v13; // cx@18
  unsigned int v14; // eax@19
  _BYTE *v15; // edx@20
  int *v16; // eax@25
  int *v17; // eax@28

  v7 = 1;
  if ( dword_1022B918[9 * *(_DWORD *)a2] )
  {
    sub_1000AC40(a3, 2);
    *a4 = 3;
    return;
  }
  v8 = *(_BYTE *)(a2 + 8);
  if ( v8 )
  {
    if ( dword_1022B018[9 * *(_DWORD *)(a2 + 4)] )
    {
      v9 = nullsub_1(a1);
      *a6 = v9;
      if ( !*(_BYTE *)(v9 + 13) && !*(_DWORD *)(v9 + 16) )
      {
        v10 = 0;
        v11 = (_BYTE *)(a2 + 38);
        while ( v10 < *(_WORD *)(a2 + 36) )
        {
          switch ( *v11 )
          {
            case 0xA0:
            case 0xA3:
            case 0xE4:
            case 0xEB:
              v7 = 0;
              break;
            default:
              break;
          }
          ++v10;
          v11 += 258;
          if ( !v7 )
            goto LABEL_17;
        }
        if ( v7 )
        {
          sub_1000AC40(a3, 6);
          *a4 = 3;
          return;
        }
      }
    }
    else if ( v8 )
    {
      sub_1000C5C0(a7, *(_DWORD *)a2, byte_101FBD7F);
      sub_1000B590(0, 0, 0);
      v12 = sub_1000C600((int)&dword_1022C230, a3, 1);
      *a5 = v12;
      *a4 = (v12 != 0) + 3;
    }
  }
LABEL_17:
  if ( *a4 == 6 )
  {
    v13 = *(_WORD *)(a2 + 36);
    if ( v13 > 1u )
    {
      v14 = 0;
      if ( v13 )
      {
        v15 = (_BYTE *)(a2 + 38);
        while ( *v15 != -95 && *v15 != -28 )
        {
          ++v14;
          v15 += 258;
          if ( v14 >= v13 )
            goto LABEL_26;
        }
        sub_1000C5C0(a7, *(_DWORD *)a2, byte_101FBD7F);
        sub_1000B590(0, 0, 3);
        v16 = sub_1000C600((int)&dword_1022C230, a3, 1);
        *a5 = v16;
        *a4 = (v16 != 0) + 3;
      }
    }
LABEL_26:
    if ( *a4 == 6 && !sub_1000C440(a2) )
    {
      sub_1000C5C0(a7, *(_DWORD *)a2, 1);
      sub_1000B590("THIS CONCATENATION NOT SUPPORTED BY THIS AIRCRAFT", 0x32u, 3);
      v17 = sub_1000C600((int)&dword_1022C230, a3, 1);
      *a5 = v17;
      *a4 = (v17 != 0) + 3;
    }
  }
}
// 1000D100: could not find valid save-restore pair for edi
// 101FBD7F: using guessed type char byte_101FBD7F;
// 1022B018: using guessed type int dword_1022B018[];
// 1022B918: using guessed type int dword_1022B918[];
// 1022C230: using guessed type int dword_1022C230;

//----- (1000D330) --------------------------------------------------------
char __usercall sub_1000D330@<al>(int **a1@<ebx>, int a2@<esi>, int a3, _BYTE *a4, int a5)
{
  int *v5; // eax@1
  int *v6; // eax@3
  int v7; // eax@4
  size_t v8; // edx@20
  const char *v9; // eax@20
  char v11; // [sp+Ah] [bp-Eh]@1
  char v12; // [sp+Bh] [bp-Dh]@1
  _BYTE *v13; // [sp+Ch] [bp-Ch]@2
  unsigned int v14; // [sp+10h] [bp-8h]@1
  int v15; // [sp+14h] [bp-4h]@1

  LOBYTE(v5) = 0;
  v11 = 0;
  v12 = 0;
  v14 = 0;
  v15 = 0;
  if ( !*(_WORD *)(a2 + 36) )
    goto LABEL_17;
  v13 = (_BYTE *)(a2 + 38);
  while ( 1 )
  {
    v6 = (int *)sub_1000B1F0(v13);
    if ( !v6 )
      goto LABEL_11;
    ++v14;
    v7 = sub_1000B1B0(a2 + 36, *v6);
    if ( !v7 )
    {
      sub_1000C5C0(a5, *(_DWORD *)a2, byte_101FBD7F);
      sub_1000B590("MESSAGE MISSING ROUTE CLEARANCE DATA", 0x25u, 3);
      v5 = sub_1000C600((int)&dword_1022C230, a3, 1);
      *a1 = v5;
      *a4 = (v5 != 0) + 3;
      return (unsigned int)v5;
    }
    if ( *v13 == 80 && (*(_BYTE *)(v7 + 5) || *(_BYTE *)(v7 + 14) || *(_BYTE *)(v7 + 44)) )
      break;
    if ( *(_BYTE *)(v7 + 2926) )
    {
      v11 = sub_1000B8A0((void *)(v7 + 108));
      if ( v11 )
        goto LABEL_12;
    }
LABEL_11:
    v13 += 258;
    if ( ++v15 >= (unsigned int)*(_WORD *)(a2 + 36) )
      goto LABEL_12;
  }
  v12 = 1;
LABEL_12:
  if ( v14 > 2 )
  {
    sub_1000C5C0(a5, *(_DWORD *)a2, byte_101FBD7F);
    sub_1000B590("MESSAGE CONTAINS TOO MANY ROUTE CLEARANCE ELEMENTS", 0x33u, 3);
    v5 = sub_1000C600((int)&dword_1022C230, a3, 1);
    *a1 = v5;
    *a4 = (v5 != 0) + 3;
    return (unsigned int)v5;
  }
  LOBYTE(v5) = v11;
LABEL_17:
  if ( *(_BYTE *)(a2 + 12694) && *(_BYTE *)(a2 + 12692) && *(_WORD *)(a2 + 1328) != v14 )
  {
    sub_1000C5C0(a5, *(_DWORD *)a2, byte_101FBD7F);
    v8 = 40;
    v9 = "MESSAGE MISSING ROUTE CLEARANCE ELEMENT";
    goto LABEL_27;
  }
  if ( v12 )
  {
    sub_1000C5C0(a5, *(_DWORD *)a2, byte_101FBD7F);
    sub_1000B590("UPLINK MESSAGE CONTAINS INVALID DATA TYPES", 0x2Bu, 0);
    goto LABEL_28;
  }
  if ( (_BYTE)v5 == 1 )
  {
    sub_1000C5C0(a5, *(_DWORD *)a2, byte_101FBD7F);
    sub_1000B590("UNACCEPTABLE DATA COMBINATION IN ROUTE CLEARANCE", 0x31u, 0);
    goto LABEL_28;
  }
  if ( (_BYTE)v5 == 2 )
  {
    sub_1000C5C0(a5, *(_DWORD *)a2, byte_101FBD7F);
    v8 = 49;
    v9 = "UNACCEPTABLE DATA COMBINATION IN ROUTE CLEARANCE";
LABEL_27:
    sub_1000B590(v9, v8, 3);
LABEL_28:
    v5 = sub_1000C600((int)&dword_1022C230, a3, 1);
    *a1 = v5;
    LOBYTE(v5) = (v5 != 0) + 3;
    *a4 = (_BYTE)v5;
  }
  return (unsigned int)v5;
}
// 101FBD7F: using guessed type char byte_101FBD7F;
// 1022C230: using guessed type int dword_1022C230;

//----- (1000D570) --------------------------------------------------------
void *sub_1000D570()
{
  void *result; // eax@3

  if ( !byte_101FBD6B )
  {
    if ( dword_1022AFF8 )
    {
      sub_1000AC40(dword_1022AFF8, 5);
      result = sub_1000BA60();
    }
    else
    {
      sub_1000CB30((int)&dword_1022AFF8, 1);
      sub_1000CB30((int)&dword_101FBD88, 1);
      result = sub_1000BA60();
    }
  }
  return result;
}
// 101FBD6B: using guessed type char byte_101FBD6B;
// 101FBD88: using guessed type int dword_101FBD88;
// 1022AFF8: using guessed type int dword_1022AFF8;

//----- (1000D5C0) --------------------------------------------------------
char sub_1000D5C0()
{
  unsigned int v0; // edi@1
  int v1; // eax@2
  unsigned int v2; // esi@5
  char result; // al@6

  sub_1000D570();
  v0 = 38000;
  do
  {
    v1 = sub_1002F710(dword_101FBD80, v0, 1);
    if ( v1 )
      sub_1000BF00(v0, v1, 21);
    ++v0;
  }
  while ( v0 <= 0x94F1 );
  v2 = 39000;
  do
    result = sub_1002F8C0(dword_101EC2CC, v2++);
  while ( v2 <= 0x985F );
  return result;
}
// 101EC2CC: using guessed type int dword_101EC2CC;
// 101FBD80: using guessed type int dword_101FBD80;

//----- (1000D620) --------------------------------------------------------
unsigned int __cdecl sub_1000D620(int a1, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  unsigned int result; // eax@4
  int v5; // esi@5
  char v6; // bl@5
  int v7; // edi@5
  int v8; // [sp+4h] [bp-1Ch]@1
  int v9; // [sp+8h] [bp-18h]@1
  int v10; // [sp+Ch] [bp-14h]@1
  char v11; // [sp+10h] [bp-10h]@1
  char v12; // [sp+11h] [bp-Fh]@1
  int v13; // [sp+12h] [bp-Eh]@1
  int v14; // [sp+16h] [bp-Ah]@1
  char v15; // [sp+1Ah] [bp-6h]@1
  char v16; // [sp+1Bh] [bp-5h]@1

  sub_10042450(12, 12, &a2, 4u);
  v2 = *(_DWORD *)(a1 + 16);
  v3 = *(_DWORD *)(a1 + 12);
  v15 = *(_BYTE *)(a1 + 20);
  v14 = v2;
  v8 = -1;
  v9 = -1;
  v13 = v3;
  v11 = 15;
  v12 = 9;
  v16 = dword_102289D4;
  v10 = 0;
  sub_1002F090(3, 0, 0, (int)&v8, &a2, 4u);
  if ( a1 == dword_1022AFF8 )
  {
    if ( dword_101FBD88 )
      sub_1000AC40(dword_101FBD88, 4);
    dword_1022B008 = a2;
    sub_1000CB30((int)&dword_1022AFF8, 0);
    result = sub_1000CB30((int)&dword_101FBD88, 0);
  }
  else
  {
    v5 = *(_DWORD *)dword_101FBD8C;
    v6 = byte_101FBD94;
    v7 = dword_101FBD90;
    dword_101FBD98 = a2;
    result = sub_1000CB30((int)&dword_101FBD88, 0);
    dword_101FBD90 = v7;
    byte_101FBD94 = v6;
    *(_DWORD *)dword_101FBD8C = v5;
  }
  return result;
}
// 101FBD88: using guessed type int dword_101FBD88;
// 101FBD90: using guessed type int dword_101FBD90;
// 101FBD94: using guessed type char byte_101FBD94;
// 101FBD98: using guessed type int dword_101FBD98;
// 102289D4: using guessed type int dword_102289D4;
// 1022AFF8: using guessed type int dword_1022AFF8;
// 1022B008: using guessed type int dword_1022B008;

//----- (1000D740) --------------------------------------------------------
unsigned int __cdecl sub_1000D740(int a1, int a2)
{
  unsigned int result; // eax@4
  char v3; // bl@5
  int v4; // esi@5
  int v5; // edi@5

  sub_10042450(12, 11, &a2, 4u);
  if ( a1 == dword_1022AFF8 )
  {
    if ( dword_101FBD88 )
    {
      sub_1000AC40(dword_101FBD88, 4);
      sub_1000CB30((int)&dword_101FBD88, 0);
    }
    dword_1022B00C = a2;
    result = sub_1000CB30((int)&dword_1022AFF8, 0);
  }
  else
  {
    v3 = byte_101FBD94;
    v4 = *(_DWORD *)dword_101FBD8C;
    v5 = dword_101FBD90;
    dword_101FBD9C = a2;
    result = sub_1000CB30((int)&dword_101FBD88, 0);
    dword_101FBD90 = v5;
    *(_DWORD *)dword_101FBD8C = v4;
    byte_101FBD94 = v3;
  }
  return result;
}
// 101FBD88: using guessed type int dword_101FBD88;
// 101FBD90: using guessed type int dword_101FBD90;
// 101FBD94: using guessed type char byte_101FBD94;
// 101FBD9C: using guessed type int dword_101FBD9C;
// 1022AFF8: using guessed type int dword_1022AFF8;
// 1022B00C: using guessed type int dword_1022B00C;

//----- (1000D800) --------------------------------------------------------
void __usercall sub_1000D800(char a1@<al>, int a2@<edx>, int a3@<ecx>)
{
  char v3; // bl@1
  int v4; // esi@2
  int *v5; // edi@3
  int v6; // eax@4
  char v7; // [sp+4h] [bp-4h]@4

  v3 = a1;
  sub_1000A9C0(a2, 0, a3, a1 == 0);
  if ( dword_101FBD88 )
  {
    sub_1000CB30((int)&dword_1022AFF8, 1);
    dword_1022AFF8 = dword_101FBD88;
    dword_1022AFFC = *(_DWORD *)(dword_101FBD88 + 12);
    dword_1022B000 = *(_DWORD *)(dword_101FBD88 + 16);
    byte_1022B004 = *(_BYTE *)(dword_101FBD88 + 20);
    sub_1000CB30((int)&dword_101FBD88, 1);
    v4 = sub_1000CC50(0, (int)&dword_1022AFF8, -1, 1, 0);
    if ( v4 )
    {
      sub_1000B630();
      v5 = sub_1000C600((int)&dword_1022C230, dword_1022AFF8, 1);
      if ( v5 )
      {
        v6 = sub_1002F340((int)&v7, 0x64u);
        *(_WORD *)(v4 + 11) = *(_WORD *)v6;
        *(_BYTE *)(v4 + 13) = *(_BYTE *)(v6 + 2);
        *(_DWORD *)(v4 + 16) = 0;
        *(_BYTE *)(v4 + 8) = 1;
        *(_BYTE *)(v4 + 9) = 0;
        *(_DWORD *)(v4 + 32) = sub_1007C040();
        sub_1000AAA0(dword_1022AFF8, (int)v5, 1);
      }
    }
  }
  else
  {
    sub_1000CB30((int)&dword_1022AFF8, 1);
    sub_1000CB30((int)&dword_101FBD88, 1);
    byte_1022B010 = (v3 == 0) + 1;
  }
}
// 101FBD88: using guessed type int dword_101FBD88;
// 1022AFF8: using guessed type int dword_1022AFF8;
// 1022AFFC: using guessed type int dword_1022AFFC;
// 1022B000: using guessed type int dword_1022B000;
// 1022B004: using guessed type char byte_1022B004;
// 1022B010: using guessed type char byte_1022B010;
// 1022C230: using guessed type int dword_1022C230;

//----- (1000D910) --------------------------------------------------------
void __usercall sub_1000D910(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // esi@1
  int v4; // esi@2
  int *v5; // edi@2
  int v6; // eax@3
  char v7; // [sp+4h] [bp-4h]@3

  v3 = a2;
  *(_DWORD *)a2 = a1;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 16);
  *(_BYTE *)(a2 + 12) = *(_BYTE *)(a1 + 20);
  sub_1000AB60(a1, 0, a3);
  *(_DWORD *)(v3 + 16) = 8;
  *(_DWORD *)(v3 + 20) = 13;
  if ( (int *)v3 == &dword_1022AFF8 )
  {
    dword_101F8BCC = 0;
    v4 = sub_1000CC50(0, (int)&dword_1022AFF8, -1, 1, 0);
    sub_1000B630();
    v5 = sub_1000C600((int)&dword_1022C230, dword_1022AFF8, 1);
    if ( v5 )
    {
      v6 = sub_1002F340((int)&v7, 0x64u);
      *(_WORD *)(v4 + 11) = *(_WORD *)v6;
      *(_BYTE *)(v4 + 13) = *(_BYTE *)(v6 + 2);
      *(_DWORD *)(v4 + 16) = dword_1022C250;
      *(_BYTE *)(v4 + 8) = 1;
      *(_BYTE *)(v4 + 9) = 0;
      *(_DWORD *)(v4 + 32) = sub_1007C040();
      sub_1000AAA0(dword_1022AFF8, (int)v5, 1);
    }
  }
}
// 101F8BCC: using guessed type int dword_101F8BCC;
// 1022AFF8: using guessed type int dword_1022AFF8;
// 1022C230: using guessed type int dword_1022C230;
// 1022C250: using guessed type int dword_1022C250;

//----- (1000D9E0) --------------------------------------------------------
int __usercall sub_1000D9E0@<eax>(int a1@<edx>, int a2@<esi>, int a3)
{
  int v3; // esi@2
  int **v4; // ecx@3
  int v5; // edx@3
  int result; // eax@5
  int v7; // [sp-4h] [bp-4h]@2

  if ( (unsigned int)(a1 - 38000) > 0x81 )
  {
    result = 0;
  }
  else
  {
    v7 = a2;
    v3 = 0;
    if ( (int *)dword_1022C220 != &dword_1022C220 )
    {
      while ( 1 )
      {
        v3 = nullsub_1(v7);
        if ( *(_DWORD *)(v3 + 20) == v5 )
          break;
        if ( *v4 == &dword_1022C220 )
          return 0;
      }
      sub_1000C7C0(a3, v3);
    }
    result = v3;
  }
  return result;
}
// 1000D9E0: could not find valid save-restore pair for esi
// 1022C220: using guessed type int dword_1022C220;

//----- (1000DA40) --------------------------------------------------------
char __cdecl sub_1000DA40(_DWORD *a1)
{
  int v1; // eax@1
  char result; // al@2

  v1 = sub_1000CC50(0, (int)&dword_1022AFF8, -1, 1, 0);
  if ( v1 )
  {
    *a1 = *(_DWORD *)(v1 + 28);
    sub_1000C760(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1022AFF8: using guessed type int dword_1022AFF8;

//----- (1000DA80) --------------------------------------------------------
int __usercall sub_1000DA80@<eax>(int *a1@<edx>, int a2@<ecx>, char a3, int a4, char a5)
{
  int v5; // esi@1
  int *v6; // edi@1
  int v7; // eax@1
  int v8; // ebp@1
  int v10; // eax@3
  int v11; // ST14_4@3
  bool v12; // zf@3
  int *v13; // esi@5
  int v14; // edi@6
  int v15; // ST18_4@7
  const void *v16; // eax@7
  unsigned int v17; // ecx@8
  char v18; // al@9
  unsigned int v19; // ST14_4@9
  void *v20; // ST10_4@9
  int v21; // eax@9
  int v22; // eax@10
  _BYTE *v23; // eax@12
  int v24; // [sp+Ch] [bp-38h]@1
  _BYTE *v25; // [sp+10h] [bp-34h]@4
  int v26; // [sp+14h] [bp-30h]@3
  _BYTE *v27; // [sp+18h] [bp-2Ch]@3
  int v28; // [sp+1Ch] [bp-28h]@6
  int *v29; // [sp+20h] [bp-24h]@1
  int v30; // [sp+24h] [bp-20h]@1
  int v31; // [sp+28h] [bp-1Ch]@9
  int v32; // [sp+2Ch] [bp-18h]@9
  int v33; // [sp+30h] [bp-14h]@9
  char v34; // [sp+34h] [bp-10h]@9
  char v35; // [sp+35h] [bp-Fh]@9
  int v36; // [sp+36h] [bp-Eh]@9
  int v37; // [sp+3Ah] [bp-Ah]@9
  char v38; // [sp+3Eh] [bp-6h]@9
  char v39; // [sp+3Fh] [bp-5h]@9

  v5 = a2;
  v6 = a1;
  v29 = a1;
  v30 = a4;
  v7 = sub_1002F680(dword_101FBD80, &v24);
  v8 = v7;
  if ( !v7 )
  {
    sub_1000CEA0(*v6, a5);
    return -1;
  }
  *(_WORD *)(v7 + 13) = word_101FBD68;
  *(_BYTE *)(v7 + 15) = byte_101FBD6A;
  v10 = dword_1022AFF8 + 12;
  *(_DWORD *)(v8 + 2) = *(_DWORD *)(dword_1022AFF8 + 12);
  *(_DWORD *)(v8 + 6) = *(_DWORD *)(v10 + 4);
  *(_BYTE *)(v8 + 10) = *(_BYTE *)(v10 + 8);
  *(_BYTE *)(v8 + 17) = 0;
  *(_BYTE *)(v8 + 12) = 0;
  *(_BYTE *)(v8 + 16) = 0;
  *(_BYTE *)(v8 + 1) = a3;
  *(_DWORD *)(v8 + 20) = sub_1000B9D0((int)(v6 + 3));
  sub_10042DC0((char *)(v8 + 24));
  v11 = dword_101FBD80;
  *(_DWORD *)(v8 + 36) = v5;
  *(_DWORD *)(v8 + 32) = sub_1002F140(v11, v5);
  *(_DWORD *)(v8 + 28) = -1;
  qmemcpy((void *)(v8 + 40), v6 + 9, 0x50Cu);
  v12 = *(_WORD *)(v8 + 40) == 0;
  *(_BYTE *)(v8 + 11) = 0;
  v27 = 0;
  v26 = 0;
  if ( v12 )
  {
LABEL_9:
    sub_1002F6D0(dword_101FBD80, v24);
    v34 = 11;
    v35 = 9;
    v36 = *(_DWORD *)(dword_1022AFF8 + 12);
    v37 = *(_DWORD *)(dword_1022AFF8 + 16);
    v18 = *(_BYTE *)(dword_1022AFF8 + 20);
    v31 = v24;
    v38 = v18;
    v39 = dword_102289D4;
    v32 = *(_DWORD *)(v8 + 36);
    v19 = (unsigned int)(*(_DWORD *)(v30 + 4) + 7) >> 3;
    v20 = *(void **)v30;
    v33 = *(_DWORD *)(v30 + 8);
    sub_1002F090(2, 0, 0, (int)&v31, v20, v19);
    v21 = *(_DWORD *)(v8 + 32);
    if ( v21 != -1 )
    {
      v22 = sub_1002F710(dword_101FBD80, v21, 0);
      *(_DWORD *)(v22 + 28) = v24;
      sub_1002F6D0(dword_101FBD80, *(_DWORD *)(v8 + 32));
    }
    sub_1000BFD0();
    ++dword_102289D4;
    return v24;
  }
  v25 = (_BYTE *)(v8 + 42);
  while ( 1 )
  {
    v13 = (int *)sub_1000B1F0(v25);
    if ( v13 )
      break;
LABEL_8:
    v17 = *(_WORD *)(v8 + 40);
    v25 += 258;
    if ( ++v26 >= v17 )
      goto LABEL_9;
  }
  v14 = sub_1002F680(dword_101EC2CC, &v28);
  if ( v14 )
  {
    v15 = *v13;
    v27 = (_BYTE *)v14;
    v16 = (const void *)sub_1000B1B0((int)(v29 + 9), v15);
    memcpy((void *)(v14 + 1), v16, 0x1631u);
    sub_1002F6D0(dword_101EC2CC, v28);
    *v13 = v28;
    goto LABEL_8;
  }
  sub_1000CEA0(*v29, a5);
  v23 = v27;
  v12 = v27 == 0;
  *(_BYTE *)v8 = 0;
  if ( !v12 )
    *v23 = 0;
  return -1;
}
// 101EC2CC: using guessed type int dword_101EC2CC;
// 101FBD68: using guessed type __int16 word_101FBD68;
// 101FBD6A: using guessed type char byte_101FBD6A;
// 101FBD80: using guessed type int dword_101FBD80;
// 102289D4: using guessed type int dword_102289D4;
// 1022AFF8: using guessed type int dword_1022AFF8;

//----- (1000E130) --------------------------------------------------------
char __cdecl sub_1000E130(int a1, int a2)
{
  int v2; // ebx@1
  int *v4; // edi@3
  int v5; // eax@3
  int v6; // eax@6
  int v7; // esi@6
  unsigned int v8; // eax@6
  _BYTE *v9; // ecx@7
  int v10; // edi@11
  int *v11; // edi@17
  bool v12; // zf@21
  int v13; // eax@23
  int v14; // ST18_4@35
  int v15; // edx@35
  char v16; // al@35
  int v17; // edx@35
  int v18; // [sp-8h] [bp-44h]@29
  char v19; // [sp-4h] [bp-40h]@29
  char v20; // [sp+13h] [bp-29h]@17
  int *v21; // [sp+14h] [bp-28h]@3
  _BYTE *v22; // [sp+18h] [bp-24h]@12
  int v23; // [sp+1Ch] [bp-20h]@3
  int v24; // [sp+20h] [bp-1Ch]@35
  int v25; // [sp+24h] [bp-18h]@35
  int v26; // [sp+28h] [bp-14h]@35
  char v27; // [sp+2Ch] [bp-10h]@35
  char v28; // [sp+2Dh] [bp-Fh]@35
  int v29; // [sp+2Eh] [bp-Eh]@35
  int v30; // [sp+32h] [bp-Ah]@35
  char v31; // [sp+36h] [bp-6h]@35
  char v32; // [sp+37h] [bp-5h]@35

  qmemcpy(&word_1022C254, (const void *)(a2 + 40), 0x50Cu);
  v2 = sub_1000CC50(0, (int)&dword_1022AFF8, a1, 0, 0);
  if ( !v2 )
    return 0;
  v4 = (int *)(a2 + 36);
  v21 = (int *)(a2 + 36);
  v5 = sub_1000D9E0(*(_DWORD *)(a2 + 36), a2 + 1332, (int)&dword_1022C230);
  v23 = v5;
  if ( *(_DWORD *)(a2 + 36) != -1 )
  {
    if ( !v5 )
    {
      sub_10042450(12, 14, (void *)(a2 + 36), 4u);
      *(_BYTE *)(a2 + 14) = 3;
      *(_BYTE *)(a2 + 1) = 0;
      sub_10042DC0((char *)(a2 + 24));
      sub_1000C760(v2);
      return 1;
    }
    byte_1022C238 = 1;
    dword_1022C234 = *(_DWORD *)(v5 + 28);
    v6 = sub_1002F140(dword_101FBD80, *v4);
    v7 = sub_1002F710(dword_101FBD80, v6, 0);
    v8 = 0;
    *(_DWORD *)(v7 + 28) = a1;
    if ( *(_WORD *)(a2 + 40) )
    {
      v9 = (_BYTE *)(a2 + 42);
      while ( *v9 != 1 )
      {
        ++v8;
        v9 += 258;
        if ( v8 >= *(_WORD *)(a2 + 40) )
          goto LABEL_16;
      }
      v10 = 0;
      if ( *(_WORD *)(v7 + 40) )
      {
        v22 = (_BYTE *)(v7 + 42);
        while ( !sub_1000B1F0(v22) )
        {
          v22 += 258;
          if ( ++v10 >= (unsigned int)*(_WORD *)(v7 + 40) )
            goto LABEL_15;
        }
        dword_101FBD84 = *v21;
        v4 = (int *)(a2 + 36);
      }
      else
      {
LABEL_15:
        v4 = (int *)(a2 + 36);
      }
    }
LABEL_16:
    sub_1002F6D0(dword_101FBD80, *v4);
    v5 = v23;
  }
  v20 = sub_1000C040(v5, v2 + 11, (int)&dword_1022C230);
  sub_1000B980(*(_DWORD *)(a2 + 20), (int)&unk_1022C23C);
  v11 = sub_1000C600((int)&dword_1022C230, dword_1022AFF8, 0);
  if ( !v11 )
  {
    *(_BYTE *)(a2 + 14) = 1;
    sub_10042DC0((char *)(a2 + 24));
    sub_1000C760(v2);
    return 1;
  }
  if ( v20 )
  {
    *(_DWORD *)(v2 + 24) = *v21;
    *(_BYTE *)(v2 + 10) = 1;
    *(_DWORD *)(v2 + 16) = dword_1022C250;
    v12 = dword_1022C250 == 0;
    *(_BYTE *)(v2 + 9) = 1;
    *(_BYTE *)(v2 + 8) = v12;
    *(_DWORD *)(v2 + 32) = sub_1007C040();
    *(_BYTE *)(a2 + 1) = 1;
  }
  else
  {
    sub_1000C760(v2);
    *(_BYTE *)(a2 + 1) = 0;
  }
  v13 = dword_1022AFF8 + 12;
  *(_DWORD *)(a2 + 2) = *(_DWORD *)(dword_1022AFF8 + 12);
  *(_DWORD *)(a2 + 6) = *(_DWORD *)(v13 + 4);
  *(_BYTE *)(a2 + 10) = *(_BYTE *)(v13 + 8);
  if ( !byte_1022C238 )
  {
    v19 = 0;
    v18 = (int)v11;
    goto LABEL_34;
  }
  if ( !v23 || *(_BYTE *)(v23 + 10) )
  {
    sub_1000AAA0(dword_1022AFF8, (int)v11, 0);
    goto LABEL_35;
  }
  if ( byte_1022C256 == 1 || byte_1022C256 == 4 || byte_1022C256 == 5 )
  {
    sub_1000D800(1, dword_1022AFF8, (int)v11);
    goto LABEL_35;
  }
  v19 = 0;
  v18 = (int)v11;
  if ( byte_1022C256 == 3 )
  {
LABEL_34:
    sub_1000AAA0(dword_1022AFF8, v18, v19);
    goto LABEL_35;
  }
  sub_1000A9C0(dword_1022AFF8, 2, (int)v11, 0);
LABEL_35:
  *(_BYTE *)(a2 + 14) = 2;
  sub_10042DC0((char *)(a2 + 24));
  v14 = dword_101FBD80;
  *(_BYTE *)(a2 + 13) = dword_1022C250 == 0;
  sub_1002F6D0(v14, a1);
  v15 = *(_DWORD *)(a2 + 6);
  v16 = *(_BYTE *)(a2 + 10);
  v29 = *(_DWORD *)(a2 + 2);
  v30 = v15;
  v17 = *v21;
  v31 = v16;
  v27 = 10;
  v28 = 9;
  v32 = -1;
  v24 = a1;
  v25 = v17;
  v26 = v11[3];
  sub_1002F090(2, 1, 0, (int)&v24, (void *)v11[1], (unsigned int)(v11[2] + 7) >> 3);
  word_1022C254 = 0;
  return 1;
}
// 101FBD80: using guessed type int dword_101FBD80;
// 101FBD84: using guessed type int dword_101FBD84;
// 1022AFF8: using guessed type int dword_1022AFF8;
// 1022C230: using guessed type int dword_1022C230;
// 1022C234: using guessed type int dword_1022C234;
// 1022C238: using guessed type char byte_1022C238;
// 1022C250: using guessed type int dword_1022C250;
// 1022C254: using guessed type __int16 word_1022C254;
// 1022C256: using guessed type char byte_1022C256;

//----- (1000E490) --------------------------------------------------------
void __usercall sub_1000E490(int a1@<edi>, int a2, int a3)
{
  int *v3; // esi@1
  signed int v4; // eax@2
  int v5; // eax@4
  int v6; // ecx@4
  int v7; // eax@4
  int *v8; // eax@7

  v3 = sub_1000BB40(dword_101F8BD0, (int)&dword_1022AFF8);
  if ( a1 )
    v4 = *(_DWORD *)(a1 + 20);
  else
    v4 = -1;
  v3[6] = v4;
  *(_WORD *)((char *)v3 + 11) = word_101FBD68;
  *((_BYTE *)v3 + 13) = byte_101FBD6A;
  v3[4] = dword_101F8BF0;
  *((_BYTE *)v3 + 10) = 0;
  v5 = sub_1007C040();
  v6 = v3[6];
  v3[8] = v5;
  v7 = sub_1000DA80(&dword_101F8BD0, v6, 1, a3, 0);
  v3[5] = v7;
  if ( v7 == -1 )
  {
    sub_1000C760((int)v3);
  }
  else if ( !dword_101F8BF0 )
  {
    sub_1000C5C0(a2, dword_101F8BD0, 1);
    sub_1000B6D0();
    v8 = sub_1000C600((int)&dword_1022C230, dword_1022AFF8, 1);
    if ( v8 )
      sub_1000AAA0(dword_1022AFF8, (int)v8, 1);
  }
}
// 101F8BD0: using guessed type int dword_101F8BD0;
// 101F8BF0: using guessed type int dword_101F8BF0;
// 101FBD68: using guessed type __int16 word_101FBD68;
// 101FBD6A: using guessed type char byte_101FBD6A;
// 1022AFF8: using guessed type int dword_1022AFF8;
// 1022C230: using guessed type int dword_1022C230;

//----- (1000E550) --------------------------------------------------------
void __usercall sub_1000E550(int a1@<eax>, int a2, int a3)
{
  int v3; // edi@1
  int v4; // eax@2
  int v5; // eax@3
  int v6; // edx@5
  char v7; // bl@7
  int *v8; // esi@8
  int v9; // ecx@9
  char v10; // ST00_1@11
  int v11; // eax@11
  int *v12; // eax@20
  char v13; // [sp+Fh] [bp-5h]@1
  int *v14; // [sp+10h] [bp-4h]@16

  v3 = a1;
  if ( sub_1000BB80(&v13, a1) )
  {
    v4 = *(_DWORD *)(v3 + 20);
    if ( v4 != -1 )
    {
      v5 = sub_1002F710(dword_101FBD80, v4, 1);
      if ( v5 )
      {
        if ( *(_BYTE *)(v5 + 1) )
        {
          v6 = dword_101FBD80;
          *(_BYTE *)(v5 + 1) = 0;
          sub_1002F6D0(v6, *(_DWORD *)(v3 + 20));
        }
      }
    }
    sub_1000C760(v3);
  }
  v7 = v13;
  if ( v13 )
  {
    v8 = sub_1000BB40(dword_101F8BD0, (int)&dword_1022AFF8);
    if ( v3 )
      v9 = *(_DWORD *)(v3 + 20);
    else
      v9 = -1;
    v10 = byte_101FBD7F;
    v8[6] = v9;
    v11 = sub_1000DA80(&dword_101F8BD0, v9, v10, a3, 1);
    v8[5] = v11;
    if ( v11 == -1 )
    {
      sub_1000C760((int)v8);
      return;
    }
    if ( byte_101FBD7F )
    {
      *(_WORD *)((char *)v8 + 11) = word_101FBD68;
      *((_BYTE *)v8 + 13) = byte_101FBD6A;
      v8[4] = dword_101F8BF0;
      *((_BYTE *)v8 + 10) = 1;
      v8[8] = sub_1007C040();
    }
    else
    {
      v8[5] = -1;
      sub_1000C760((int)v8);
    }
  }
  else
  {
    v8 = v14;
  }
  if ( !dword_101F8BF0 )
  {
    sub_1000C5C0(a2, dword_101F8BD0, 1);
    sub_1000B6D0();
    if ( v7 )
      sub_1000C7C0((int)&dword_1022C230, (int)v8);
    v12 = sub_1000C600((int)&dword_1022C230, dword_1022AFF8, 1);
    if ( v12 )
      sub_1000AAA0(dword_1022AFF8, (int)v12, 1);
  }
}
// 101F8BD0: using guessed type int dword_101F8BD0;
// 101F8BF0: using guessed type int dword_101F8BF0;
// 101FBD68: using guessed type __int16 word_101FBD68;
// 101FBD6A: using guessed type char byte_101FBD6A;
// 101FBD7F: using guessed type char byte_101FBD7F;
// 101FBD80: using guessed type int dword_101FBD80;
// 1022AFF8: using guessed type int dword_1022AFF8;
// 1022C230: using guessed type int dword_1022C230;

//----- (1000E6B0) --------------------------------------------------------
char sub_1000E6B0()
{
  int v0; // eax@1
  int v1; // eax@5

  LOBYTE(v0) = dword_101EC2CC;
  if ( *(_DWORD *)(dword_101EC2CC + 24) <= 2u )
  {
    v0 = sub_1000CF40(1);
    if ( v0 != -1 )
      LOBYTE(v0) = sub_1000C350(v0, 20);
  }
  if ( *(_DWORD *)(dword_101FBD80 + 24) <= 2u )
  {
    v1 = sub_1000CF40(0);
    if ( v1 == -1 )
    {
      v0 = sub_1000C150();
      if ( v0 != -1 )
        LOBYTE(v0) = sub_1000C350(v0, 20);
    }
    else
    {
      LOBYTE(v0) = sub_1000C350(v1, 20);
    }
  }
  return v0;
}
// 101EC2CC: using guessed type int dword_101EC2CC;
// 101FBD80: using guessed type int dword_101FBD80;

//----- (1000E710) --------------------------------------------------------
char __usercall sub_1000E710@<al>(int *a1@<eax>, int a2@<ecx>, int a3, int **a4, int a5)
{
  int v5; // esi@1
  char result; // al@1
  unsigned int v7; // edi@4
  _BYTE *v8; // edx@5
  char v9; // [sp+13h] [bp-1h]@1

  *a1 = 0;
  v5 = a2;
  v9 = 6;
  sub_1000D100((int)a4, a2, a3, &v9, a4, a1, a5);
  result = v9;
  if ( v9 == 6 )
  {
    sub_1000D060(&v9, (unsigned int *)v5, a3, a4, a5);
    result = v9;
    if ( v9 == 6 )
    {
      sub_1000D330(a4, v5, a3, &v9, a5);
      result = v9;
    }
  }
  v7 = 0;
  if ( result == 4 )
  {
    v8 = (_BYTE *)(v5 + 38);
    do
    {
      if ( v7 >= *(_WORD *)(v5 + 36) )
        break;
      if ( *v8 == -96 || *v8 == -28 )
        result = 5;
      ++v7;
      v8 += 258;
    }
    while ( result == 4 );
  }
  return result;
}

//----- (1000E7B0) --------------------------------------------------------
void __usercall sub_1000E7B0(int a1@<edi>)
{
  int *i; // ebp@2
  int v2; // eax@3
  int v3; // esi@3
  int v4; // eax@5
  int v5; // edi@7
  int v6; // eax@7
  int v7; // eax@10
  int v8; // edx@10
  int v9; // edi@10
  int v10; // eax@13
  int v11; // ebp@13
  int v12; // esi@14
  int v13; // eax@15
  char v14; // al@15
  _DWORD *v15; // eax@16
  int v16; // esi@17
  int *v17; // eax@18
  bool v18; // zf@23
  int *v19; // edi@26
  int v20; // edx@27
  int v21; // eax@28
  int v22; // esi@28
  int v23; // eax@28
  int v24; // eax@29
  _DWORD *v25; // ecx@29
  int *v26; // eax@29
  int v27; // [sp-10h] [bp-34h]@2
  int v28; // [sp+0h] [bp-24h]@2
  int *v29; // [sp+4h] [bp-20h]@12
  int v30; // [sp+8h] [bp-1Ch]@7
  int v31; // [sp+Ch] [bp-18h]@7
  int v32; // [sp+10h] [bp-14h]@7
  char v33; // [sp+14h] [bp-10h]@7
  char v34; // [sp+15h] [bp-Fh]@7
  int v35; // [sp+16h] [bp-Eh]@7
  int v36; // [sp+1Ah] [bp-Ah]@7
  char v37; // [sp+1Eh] [bp-6h]@7
  char v38; // [sp+1Fh] [bp-5h]@7

  if ( dword_1022AFF8 )
  {
    v27 = a1;
    v28 = sub_1007C040();
    for ( i = (int *)dword_1022C218; i != &dword_1022C218; i = (int *)*i )
    {
      v2 = nullsub_1(v27);
      v3 = v2;
      if ( *(_BYTE *)(v2 + 8) && (unsigned int)(v28 - *(_DWORD *)(v2 + 32)) >= 0x9C40 )
      {
        v4 = *(_DWORD *)(v2 + 20);
        if ( v4 == -1 )
        {
          byte_1022C228 = 1;
          *(_BYTE *)(v3 + 8) = 0;
        }
        else
        {
          v5 = sub_1002F710(dword_101FBD80, v4, 0);
          v6 = dword_101FBD80;
          *(_BYTE *)(v5 + 13) = 2;
          sub_1002F6D0(v6, *(_DWORD *)(v3 + 20));
          v33 = 17;
          v34 = 9;
          v35 = *(_DWORD *)(dword_1022AFF8 + 12);
          v36 = *(_DWORD *)(dword_1022AFF8 + 16);
          v37 = *(_BYTE *)(dword_1022AFF8 + 20);
          v38 = -1;
          v30 = *(_DWORD *)(v3 + 20);
          v31 = *(_DWORD *)(v5 + 36);
          v32 = 255;
          sub_1002F090(0, 1, 0, (int)&v30, 0, 0);
          *(_BYTE *)(v3 + 8) = 0;
        }
      }
      if ( *(_BYTE *)(v3 + 9) && v28 - *(_DWORD *)(v3 + 32) >= (unsigned int)dword_1022C22C )
      {
        v7 = sub_1002F710(dword_101FBD80, *(_DWORD *)(v3 + 20), 0);
        v8 = dword_101FBD80;
        v9 = v7;
        *(_BYTE *)(v7 + 12) = 1;
        sub_1002F6D0(v8, *(_DWORD *)(v3 + 20));
        *(_BYTE *)(v3 + 9) = 0;
        v33 = 19;
        v34 = 9;
        v35 = *(_DWORD *)(dword_1022AFF8 + 12);
        v36 = *(_DWORD *)(dword_1022AFF8 + 16);
        v37 = *(_BYTE *)(dword_1022AFF8 + 20);
        v38 = -1;
        v30 = *(_DWORD *)(v3 + 20);
        v31 = *(_DWORD *)(v9 + 36);
        v32 = 255;
        sub_1002F090(0, 1, 0, (int)&v30, 0, 0);
      }
    }
    v29 = *(int **)dword_1022C220;
    if ( (int *)dword_1022C220 != &dword_1022C220 )
    {
      do
      {
        v10 = nullsub_1(v27);
        v11 = v10;
        if ( v28 - *(_DWORD *)(v10 + 32) >= (unsigned int)dword_101FBD6C )
        {
          v12 = sub_1002F710(dword_101FBD80, *(_DWORD *)(v10 + 20), 0);
          if ( !*(_BYTE *)(v12 + 17) )
          {
            v13 = dword_101FBD80;
            *(_BYTE *)(v12 + 17) = 1;
            sub_1002F6D0(v13, *(_DWORD *)(v11 + 20));
            v33 = 18;
            v34 = 9;
            v35 = *(_DWORD *)(dword_1022AFF8 + 12);
            v36 = *(_DWORD *)(dword_1022AFF8 + 16);
            v14 = *(_BYTE *)(dword_1022AFF8 + 20);
            v38 = dword_102289D4;
            v37 = v14;
            v30 = *(_DWORD *)(v11 + 20);
            v31 = *(_DWORD *)(v12 + 36);
            v32 = 255;
            sub_1002F090(0, 0, 0, (int)&v30, 0, 0);
          }
          v15 = (_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_1022AFF8 + 8) + 12) + 4) + 4)
                                     + 4)
                         + 4476);
          if ( (_DWORD *)*v15 == v15 )
          {
            v16 = sub_1000CC50(1, (int)&dword_1022AFF8, -1, 1, v11);
            if ( !v16 )
              return;
            sub_1000B590("AIR SYSTEM TIMEOUT", 0x13u, 2);
            v17 = sub_1000C600((int)&dword_1022C230, dword_1022AFF8, 1);
            if ( !v17 )
              return;
            if ( *(_BYTE *)(v11 + 10) )
              sub_1000AAA0(dword_1022AFF8, (int)v17, 1);
            else
              sub_1000A9C0(dword_1022AFF8, 2, (int)v17, 1);
            sub_1000C760(v16);
            sub_1000C760(v11);
          }
        }
        v18 = v29 == &dword_1022C220;
        v29 = (int *)*v29;
      }
      while ( !v18 );
    }
    if ( (_BYTE)word_101FCFBC )
      sub_1000E6B0();
    v19 = *(int **)dword_101FBD74;
    if ( (int *)dword_101FBD74 != &dword_101FBD74 )
    {
      do
      {
        v20 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_1022AFF8 + 8) + 12) + 4) + 4);
        if ( *(_DWORD *)(*(_DWORD *)(v20 + 4) + 4476) != *(_DWORD *)(v20 + 4) + 4476 )
          break;
        v21 = nullsub_1(v27);
        v22 = v21;
        v23 = sub_1002F710(dword_101FBD80, *(_DWORD *)(v21 + 8), 0);
        if ( sub_1000E130(*(_DWORD *)(v22 + 8), v23) )
        {
          v24 = *(_DWORD *)v22;
          v25 = *(_DWORD **)(v22 + 4);
          *(_DWORD *)(v24 + 4) = v25;
          *v25 = v24;
          *(_DWORD *)v22 = v22;
          *(_DWORD *)(v22 + 4) = v22;
          v26 = (int *)dword_10228FF4;
          dword_10228FF4 = v22;
          *(_DWORD *)v22 = &dword_10228FF0;
          *(_DWORD *)(v22 + 4) = v26;
          *v26 = v22;
        }
        v18 = v19 == &dword_101FBD74;
        v19 = (int *)*v19;
      }
      while ( !v18 );
    }
  }
}
// 1000E7B0: could not find valid save-restore pair for edi
// 101FBD6C: using guessed type int dword_101FBD6C;
// 101FBD74: using guessed type int dword_101FBD74;
// 101FBD80: using guessed type int dword_101FBD80;
// 101FCFBC: using guessed type __int16 word_101FCFBC;
// 102289D4: using guessed type int dword_102289D4;
// 10228FF0: using guessed type int dword_10228FF0;
// 10228FF4: using guessed type int dword_10228FF4;
// 1022AFF8: using guessed type int dword_1022AFF8;
// 1022C218: using guessed type int dword_1022C218;
// 1022C220: using guessed type int dword_1022C220;
// 1022C228: using guessed type char byte_1022C228;
// 1022C22C: using guessed type int dword_1022C22C;
// 1022C230: using guessed type int dword_1022C230;

//----- (1000EB80) --------------------------------------------------------
char sub_1000EB80()
{
  unsigned int v0; // esi@1
  int v1; // eax@2
  int v2; // ST48_4@4

  memset(&unk_101FCFC0, 0, 0x2BA14u);
  dword_101FBD80 = sub_1002F770((int)&unk_101FCFC0, 178708, 38000, 0x82u, 0, 0, (int)sub_1000DD10);
  memset(&unk_101EC2D0, 0, 0xC8FCu);
  dword_101EC2CC = sub_1002F770((int)&unk_101EC2D0, 51452, 39000, 8u, 0, 0, (int)sub_1000CD20);
  v0 = 38000;
  do
  {
    v1 = sub_1002F710(dword_101FBD80, v0, 1);
    if ( v1 && *(_BYTE *)(v1 + 1) )
    {
      v2 = dword_101FBD80;
      *(_BYTE *)(v1 + 1) = 0;
      LOBYTE(v1) = sub_1002F6D0(v2, v0);
    }
    ++v0;
  }
  while ( v0 <= 0x94F1 );
  return v1;
}
// 1000CD20: using guessed type int sub_1000CD20();
// 1000DD10: using guessed type int sub_1000DD10();
// 101EC2CC: using guessed type int dword_101EC2CC;
// 101FBD80: using guessed type int dword_101FBD80;

//----- (1000EC40) --------------------------------------------------------
char __usercall sub_1000EC40@<al>(char a1@<al>, int a2@<edx>, int a3@<ecx>, int a4@<edi>, int **a5, int *a6, int a7)
{
  int v7; // esi@1
  int v8; // ebx@1
  char result; // al@3
  unsigned int v10; // ecx@9
  int *v11; // eax@12
  size_t v12; // edx@13
  const char *v13; // eax@13
  int *v14; // eax@14
  char v15; // [sp+Fh] [bp-1h]@0

  v7 = a2;
  v8 = a3;
  byte_101FBD7F = 0;
  if ( sub_1000C6A0(a4, a2, a1) )
  {
    if ( *(_BYTE *)(v7 + 16) )
    {
      switch ( sub_1000B160((void *)v8, v7 + 4) + 102 )
      {
        case 102:
          byte_101FBD7F = sub_1000C0D0((int)&word_101FBD68, v8);
          if ( a4 == dword_1022AFF8 )
            result = sub_1000E710(a6, v8, a4, a5, a7);
          else
            result = 6;
          return result;
        case 97:
        case 99:
        case 101:
          sub_1000AC40(a4, 10);
          return 1;
        case 2:
          v10 = *(_DWORD *)v8;
          if ( *(_WORD *)(v8 + 36) <= 1u )
          {
            sub_1000C5C0(a7, v10, 1);
            sub_1000B590("MESSAGE NOT SUPPORTED BY THIS AIRCRAFT", 0x27u, 4);
          }
          else
          {
            sub_1000C5C0(a7, v10, 1);
            sub_1000B590("THIS CONCATENATION NOT SUPPORTED BY THIS AIRCRAFT", 0x32u, 3);
          }
          v11 = sub_1000C600((int)&dword_1022C230, a4, 1);
          *a5 = v11;
          return (v11 != 0) + 3;
        case 100:
          sub_1000C5C0(a7, *(_DWORD *)v8, 1);
          v12 = 44;
          v13 = "TYPE OF DATA NOT SUPPORTED BY THIS AIRCRAFT";
          goto LABEL_14;
        case 1:
          sub_1000C5C0(a7, *(_DWORD *)v8, 1);
          v12 = 43;
          v13 = "UPLINK MESSAGE CONTAINS INVALID DATA TYPES";
          goto LABEL_14;
        case 0:
          sub_1000C5C0(a7, *(_DWORD *)v8, 1);
          v12 = 30;
          v13 = "INVALID VALUE FOR VHF CHANNEL";
          goto LABEL_14;
        case 98:
          sub_1000C5C0(a7, *(_DWORD *)v8, 1);
          v12 = 28;
          v13 = "UNABLE TO DISPLAY CHARACTER";
LABEL_14:
          sub_1000B590(v13, v12, 0);
          v14 = sub_1000C600((int)&dword_1022C230, a4, 1);
          *a5 = v14;
          result = (v14 != 0) + 3;
          break;
        default:
          sub_10042930("..\\lib\\atn\\atn_cpdlc_user.c", 4669, 0, 0);
          result = v15;
          break;
      }
    }
    else
    {
      result = 2;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101FBD68: using guessed type __int16 word_101FBD68;
// 101FBD7F: using guessed type char byte_101FBD7F;
// 1022AFF8: using guessed type int dword_1022AFF8;
// 1022C230: using guessed type int dword_1022C230;

//----- (1000EE90) --------------------------------------------------------
int __cdecl sub_1000EE90(__int16 *a1)
{
  int *v1; // ecx@1
  void *v2; // eax@1
  signed int v3; // edx@1
  int v4; // eax@4
  int v5; // edx@4
  int result; // eax@4
  int (*v7)(); // [sp+0h] [bp-1Ch]@4
  void (__cdecl *v8)(char *, char *, int, char *); // [sp+4h] [bp-18h]@4
  int (*v9)(); // [sp+8h] [bp-14h]@4
  int (*v10)(); // [sp+Ch] [bp-10h]@4
  int (*v11)(); // [sp+10h] [bp-Ch]@4
  char (__cdecl *v12)(int, char, int); // [sp+14h] [bp-8h]@4
  int (*v13)(); // [sp+18h] [bp-4h]@4

  word_101FCFBC = *a1;
  dword_101EC2C8 = 0;
  dword_102289D4 = 0;
  dword_101FBD6C = 100000;
  dword_1022C22C = 270000;
  sub_1000EB80();
  sub_1000BAD0((int)&dword_1022AFF8);
  sub_1000BAD0((int)&dword_101FBD88);
  sub_1000BA60();
  dword_101C66B8 = (int)&dword_101C66B8;
  dword_101C66BC = (int)&dword_101C66B8;
  dword_101C66B0 = (int)&dword_101C66B0;
  v1 = &dword_101C66B0;
  v2 = &unk_101E7DF0;
  v3 = 2;
  while ( 1 )
  {
    *(_DWORD *)v2 = &dword_101C66B0;
    *((_DWORD *)v2 + 1) = v1;
    dword_101C66B4 = (int)v2;
    *v1 = (int)v2;
    *((_BYTE *)v2 + 21) = 0;
    v2 = (char *)v2 + 8300;
    if ( !--v3 )
      break;
    v1 = (int *)dword_101C66B4;
  }
  v12 = sub_1000A7F0;
  v13 = sub_1000A8F0;
  v11 = sub_1000AEB0;
  v7 = sub_1000AF50;
  v8 = sub_1000AF70;
  v9 = sub_1000AF50;
  v10 = sub_1000AF00;
  v4 = sub_10010520(0, (int)&v7, 2, 2u, 0x2000, (int)&unk_101C66E0, 136972);
  v5 = *(_DWORD *)(*(_DWORD *)(v4 + 20) + 8);
  dword_101C66C0 = v4;
  result = *(_DWORD *)(v5 + 8);
  dword_101C66C4 = *(_DWORD *)(result + 1076);
  dword_101C66C8 = *(_DWORD *)(result + 1080);
  dword_101C66CC = *(_DWORD *)(result + 1084);
  dword_101C66D0 = *(_DWORD *)(result + 1088);
  dword_101C66D4 = *(_DWORD *)(result + 1092);
  word_101C66D8 = *(_WORD *)(result + 1096);
  return result;
}
// 1000A8F0: using guessed type int sub_1000A8F0();
// 1000AEB0: using guessed type int sub_1000AEB0();
// 1000AF00: using guessed type int sub_1000AF00();
// 1000AF50: using guessed type int sub_1000AF50();
// 101C66B0: using guessed type int dword_101C66B0;
// 101C66B4: using guessed type int dword_101C66B4;
// 101C66B8: using guessed type int dword_101C66B8;
// 101C66BC: using guessed type int dword_101C66BC;
// 101C66C0: using guessed type int dword_101C66C0;
// 101C66C4: using guessed type int dword_101C66C4;
// 101C66C8: using guessed type int dword_101C66C8;
// 101C66CC: using guessed type int dword_101C66CC;
// 101C66D0: using guessed type int dword_101C66D0;
// 101C66D4: using guessed type int dword_101C66D4;
// 101C66D8: using guessed type __int16 word_101C66D8;
// 101EC2C8: using guessed type int dword_101EC2C8;
// 101FBD6C: using guessed type int dword_101FBD6C;
// 101FBD88: using guessed type int dword_101FBD88;
// 101FCFBC: using guessed type __int16 word_101FCFBC;
// 102289D4: using guessed type int dword_102289D4;
// 1022AFF8: using guessed type int dword_1022AFF8;
// 1022C22C: using guessed type int dword_1022C22C;

//----- (1000EEF0) --------------------------------------------------------
_DWORD *__usercall sub_1000EEF0@<eax>(int a1@<edi>)
{
  sub_1002FB00(dword_101FBD80);
  sub_1002FB00(dword_101EC2CC);
  sub_1000E7B0(a1);
  return sub_1000FDF0(dword_101C66C0);
}
// 101C66C0: using guessed type int dword_101C66C0;
// 101EC2CC: using guessed type int dword_101EC2CC;
// 101FBD80: using guessed type int dword_101FBD80;

//----- (1000EF20) --------------------------------------------------------
void __cdecl sub_1000EF20(int a1, char *a2, int a3, int a4)
{
  int *v4; // eax@2
  int *v5; // eax@5
  int v6; // esi@6
  int v7; // ebx@12
  int *v8; // eax@17
  char v9; // [sp+4h] [bp-8h]@4
  char v10; // [sp+8h] [bp-4h]@4

  if ( byte_101FBD6B )
  {
    sub_1000C5C0(0, 0, 1);
    sub_1000B590("AIRCREW HAS INHIBITED CPDLC", 0x1Cu, 2);
    v4 = sub_1000C600((int)&dword_1022C230, a1, 1);
    if ( v4 )
      sub_1000AB60(a1, 2, (int)v4);
  }
  else
  {
    switch ( sub_1000EC40(0, a4, (int)&dword_101F8BD0, a1, (int **)&v10, (int *)&v9, 0) )
    {
      case 4:
      case 5:
      case 6:
        sub_1000C5C0(0, dword_101F8BD0, 1);
        sub_1000B590("MESSAGE NOT PERMITTED IN A START REQUEST", 0x29u, 0);
        v5 = sub_1000C600((int)&dword_1022C230, a1, 1);
        goto LABEL_6;
      case 2:
        v5 = sub_1000C600(0, a1, 1);
LABEL_6:
        v6 = (int)v5;
        if ( v5 )
        {
          if ( dword_1022AFF8 )
          {
            if ( !strncmp(a2, (const char *)(dword_1022AFF8 + 12), 9u) )
            {
              v7 = dword_101FBD88;
              dword_101FBD88 = 0;
              sub_1000AC40(dword_1022AFF8, 0);
              dword_101FBD88 = v7;
              sub_1000D910(a1, (int)&dword_1022AFF8, v6);
            }
            else if ( !strncmp(a2, dword_101FBD8C, 9u) )
            {
              if ( dword_101FBD88 )
                sub_1000AC40(dword_101FBD88, 0);
              sub_1000D910(a1, (int)&dword_101FBD88, v6);
            }
            else
            {
              sub_1000C5C0(0, 0, 0);
              sub_1000B6F0();
              v8 = sub_1000C600((int)&dword_1022C230, a1, 1);
              if ( v8 )
                sub_1000AB60(a1, 2, (int)v8);
            }
          }
          else
          {
            sub_1000D910(a1, (int)&dword_1022AFF8, (int)v5);
          }
        }
        break;
      case 0:
      case 1:
      case 3:
        return;
      default:
        sub_10042930("..\\lib\\atn\\atn_cpdlc_user.c", 2064, 0, 0);
        break;
    }
  }
}
// 101F8BD0: using guessed type int dword_101F8BD0;
// 101FBD6B: using guessed type char byte_101FBD6B;
// 101FBD88: using guessed type int dword_101FBD88;
// 1022AFF8: using guessed type int dword_1022AFF8;
// 1022C230: using guessed type int dword_1022C230;

//----- (1000F120) --------------------------------------------------------
bool __usercall sub_1000F120@<al>(int a1@<edx>, int **a2@<esi>)
{
  char v2; // al@1
  bool result; // al@4
  int *v4; // eax@5

  v2 = sub_1000EC40(1, a1, (int)&dword_101F8BD0, dword_101FBD88, a2, 0, 0);
  if ( v2 == 2 || (unsigned __int8)v2 > 3u && (unsigned __int8)v2 <= 6u )
  {
    sub_1000C5C0(0, dword_101F8BD0, byte_101FBD7F);
    sub_1000B600();
    v4 = sub_1000C600((int)&dword_1022C230, dword_101FBD88, 1);
    *a2 = v4;
    result = v4 == 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 101F8BD0: using guessed type int dword_101F8BD0;
// 101FBD7F: using guessed type char byte_101FBD7F;
// 101FBD88: using guessed type int dword_101FBD88;
// 1022C230: using guessed type int dword_1022C230;

//----- (1000F190) --------------------------------------------------------
void __cdecl sub_1000F190(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // ebp@5
  int *v4; // eax@6
  int *v5; // eax@8
  int *v6; // eax@10
  int v7; // [sp+8h] [bp-4h]@5

  v2 = a1;
  if ( a1 == dword_101FBD88 )
  {
    if ( !sub_1000F120(a2, (int **)&a1) )
      sub_1000A9C0(v2, 2, a1, 1);
  }
  else if ( sub_1000DA40(&a1) )
  {
    v3 = a1;
    switch ( sub_1000EC40(1, a2, (int)&dword_101F8BD0, dword_1022AFF8, (int **)&a1, &v7, a1) )
    {
      case 2:
        v4 = sub_1000C600(0, dword_1022AFF8, 1);
        sub_1000D800(0, v2, (int)v4);
        break;
      case 4:
        if ( byte_101FBD7F )
        {
          sub_1000A9C0(v2, 2, a1, 1);
        }
        else
        {
          v5 = sub_1000C600(0, dword_1022AFF8, 1);
          sub_1000A9C0(v2, 2, (int)v5, 1);
        }
        break;
      case 5:
        v6 = sub_1000C600(0, dword_1022AFF8, 1);
        sub_1000A9C0(v2, 2, (int)v6, 1);
        break;
      case 6:
        if ( sub_1000CFE0((int **)&a1, v3) )
        {
          sub_1000E490(v7, v3, a2 + 4);
        }
        else if ( a1 )
        {
          sub_1000A9C0(v2, 2, a1, 1);
        }
        break;
      case 0:
      case 1:
      case 3:
        return;
      default:
        sub_10042930("..\\lib\\atn\\atn_cpdlc_user.c", 1340, 0, 0);
        break;
    }
  }
}
// 101F8BD0: using guessed type int dword_101F8BD0;
// 101FBD7F: using guessed type char byte_101FBD7F;
// 101FBD88: using guessed type int dword_101FBD88;
// 1022AFF8: using guessed type int dword_1022AFF8;

//----- (1000F330) --------------------------------------------------------
void __cdecl sub_1000F330(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // esi@5
  int v4; // ebx@5
  int v5; // eax@5
  int v6; // eax@6
  int v7; // [sp+8h] [bp-4h]@5

  v2 = a1;
  if ( a1 == dword_101FBD88 )
  {
    if ( !sub_1000F120(a2, (int **)&a1) )
      sub_1000AAA0(v2, a1, 1);
  }
  else if ( sub_1000DA40(&a1) )
  {
    v3 = a1;
    v4 = a2;
    v5 = (unsigned __int8)sub_1000EC40(1, a2, (int)&dword_101F8BD0, dword_1022AFF8, (int **)&a1, &v7, a1) - 2;
    if ( v5 )
    {
      v6 = v5 - 2;
      if ( v6 )
      {
        if ( v6 == 2 )
          sub_1000E550(v7, v3, v4 + 4);
      }
      else
      {
        sub_1000AAA0(v2, a1, 1);
      }
    }
    else
    {
      sub_1000AC40(v2, 11);
    }
  }
}
// 101F8BD0: using guessed type int dword_101F8BD0;
// 101FBD88: using guessed type int dword_101FBD88;
// 1022AFF8: using guessed type int dword_1022AFF8;

//----- (1000F400) --------------------------------------------------------
_DWORD *__cdecl sub_1000F400(_DWORD *a1, int a2)
{
  _DWORD *v2; // ecx@1
  _DWORD *result; // eax@1

  v2 = (_DWORD *)*a1;
  result = 0;
  if ( (_DWORD *)*a1 != a1 )
  {
    while ( a2 != *(_DWORD *)(v2[3] + 4) )
    {
      v2 = (_DWORD *)*v2;
      if ( v2 == a1 )
        return result;
    }
    result = v2;
  }
  return result;
}

//----- (1000F430) --------------------------------------------------------
int *__cdecl sub_1000F430(int a1, char a2)
{
  int **v2; // edx@1
  int *result; // eax@1
  int v4; // edx@2
  _DWORD *v5; // esi@2
  int **v6; // edx@2
  _BYTE *v7; // ecx@2

  v2 = (int **)(a1 + 8);
  result = 0;
  if ( (int **)*v2 != v2 )
  {
    result = *v2;
    v4 = **v2;
    v5 = (_DWORD *)result[1];
    *(_DWORD *)(v4 + 4) = v5;
    *v5 = v4;
    v6 = *(int ***)(a1 + 4);
    *(_DWORD *)(a1 + 4) = result;
    *result = a1;
    result[1] = (int)v6;
    *v6 = result;
    v7 = (_BYTE *)result[3];
    *((_BYTE *)result + 8) = 0;
    *v7 = 0;
    if ( a2 )
      *(_BYTE *)(result[3] + 2) = 1;
    else
      *(_BYTE *)(result[3] + 2) = 0;
  }
  return result;
}

//----- (1000F480) --------------------------------------------------------
int __cdecl sub_1000F480(int a1, int a2)
{
  int result; // eax@1
  _DWORD *v3; // edx@1
  int v4; // ecx@1
  int v5; // edx@1

  result = a2;
  v3 = *(_DWORD **)(a2 + 4);
  *(_BYTE *)(a2 + 97) = 0;
  *(_BYTE *)(a2 + 98) = 0;
  *(_BYTE *)(a2 + 99) = 0;
  *(_BYTE *)(a2 + 96) = 0;
  *(_BYTE *)(a2 + 80) = 0;
  *(_BYTE *)(a2 + 81) = 0;
  v4 = *(_DWORD *)a2;
  *(_DWORD *)(v4 + 4) = v3;
  *v3 = v4;
  v5 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(v5 + 4) = a2;
  *(_DWORD *)a2 = v5;
  *(_DWORD *)(a2 + 4) = a1 + 8;
  *(_DWORD *)(a1 + 8) = a2;
  return result;
}

//----- (1000F4C0) --------------------------------------------------------
int __usercall sub_1000F4C0@<eax>(int a1@<eax>)
{
  int v1; // esi@1

  v1 = a1;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 9) = 39;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_BYTE *)(a1 + 96) = 0;
  *(_BYTE *)(a1 + 97) = 0;
  *(_BYTE *)(a1 + 98) = 0;
  *(_BYTE *)(a1 + 99) = 0;
  *(_BYTE *)(a1 + 80) = 0;
  *(_BYTE *)(a1 + 81) = 0;
  memset((void *)(a1 + 16), 0, 0x38u);
  return sub_100012D0(v1 + 76, 0);
}

//----- (1000F510) --------------------------------------------------------
int __usercall sub_1000F510@<eax>(int a1@<eax>, unsigned __int8 a2@<dl>, int a3@<ecx>)
{
  *(_DWORD *)a1 = a2;
  if ( a3 )
  {
    *(_DWORD *)(a1 + 4) = *(_DWORD *)a3;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a3 + 4);
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a3 + 8);
  }
  else
  {
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(a1 + 8) = 0;
  }
  return sub_10010740((int)&off_100939E8, a1, 16, (int)&unk_10332F60, 512, 0);
}
// 100939E8: using guessed type char *off_100939E8;

//----- (1000F560) --------------------------------------------------------
int __usercall sub_1000F560@<eax>(int a1@<eax>, int a2@<esi>)
{
  int result; // eax@1

  *(_DWORD *)(a2 + 88) = 1000 * a1;
  result = sub_1007C040();
  *(_DWORD *)(a2 + 84) = result;
  *(_BYTE *)(a2 + 81) = 0;
  *(_BYTE *)(a2 + 80) = 1;
  return result;
}

//----- (1000F580) --------------------------------------------------------
int __cdecl sub_1000F580(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(_BYTE *)(a1 + 80) = 0;
  *(_BYTE *)(a1 + 81) = 0;
  return result;
}

//----- (1000F5A0) --------------------------------------------------------
void __cdecl sub_1000F5A0(int a1, int a2, unsigned __int8 a3, _BYTE *a4, int a5)
{
  int v5; // esi@1
  int v6; // eax@2
  char v7; // dl@2
  int v8; // ecx@2
  char v9; // al@2
  int v10; // ST1C_4@42
  _BYTE *v11; // ST14_4@42
  int v12; // eax@57
  int v13; // eax@61
  int v14; // edx@61
  int v15; // eax@63
  int v16; // edx@63

  v5 = a2;
  if ( a2 )
  {
    v6 = 5 * a3;
    v7 = byte_1009E578[2 * (v6 + *(_BYTE *)(a2 + 8))];
    v8 = *(_BYTE *)(a2 + 8);
    *(_BYTE *)(a2 + 9) = v7;
    v9 = byte_1009E579[2 * (v6 + v8)];
    *(_BYTE *)(v5 + 8) = v9;
    switch ( v7 )
    {
      case 0:
        (*(void (__cdecl **)(int, int, _BYTE *, int))(a1 + 36))(v5, *(_DWORD *)(v5 + 12) + 8, a4, a5);
        return;
      case 1:
        if ( a4 )
          (*(void (__cdecl **)(int, _BYTE *, _DWORD, signed int, int))(a1 + 32))(v5, a4, 0, 2, a5);
        return;
      case 2:
        if ( a4 )
        {
          (*(void (__cdecl **)(int, _BYTE *, signed int, _DWORD, int))(a1 + 32))(v5, a4, 2, 0, a5);
          if ( *(_BYTE *)(v5 + 96) == 1 )
          {
            sub_10006290(*(_DWORD *)(*(_DWORD *)(v5 + 12) + 4), 0, 0);
            *(_BYTE *)(v5 + 96) = 0;
          }
          sub_1000F480(a1, v5);
        }
        return;
      case 3:
        (*(void (__cdecl **)(int, int))(a1 + 48))(v5, a5);
        return;
      case 4:
        (*(void (__cdecl **)(int, int))(a1 + 44))(v5, a5);
        return;
      case 5:
        if ( a4 )
        {
          (*(void (__cdecl **)(int, _DWORD, int))(a1 + 40))(v5, 0, a5);
          sub_10006290(*(_DWORD *)(*(_DWORD *)(v5 + 12) + 4), 0, 0);
          sub_1000F480(a1, v5);
        }
        return;
      case 6:
        if ( a4 )
        {
          (*(void (__cdecl **)(int, _DWORD, int))(a1 + 40))(v5, *a4, a5);
          if ( *(_BYTE *)(v5 + 97) )
          {
            sub_10006290(*(_DWORD *)(*(_DWORD *)(v5 + 12) + 4), 0, 0);
            sub_1000F480(a1, v5);
          }
          else
          {
            byte_10333170 = 0;
            sub_10001EB0(a1, v5, &byte_10333170, 0);
          }
        }
        return;
      case 7:
        if ( a4 )
          (*(void (__cdecl **)(int, signed int, int))(a1 + 40))(v5, 2, a5);
        return;
      case 8:
        if ( *(_DWORD *)a4 )
        {
          (*(void (__cdecl **)(int, signed int, int))(a1 + 52))(v5, 1, a5);
          sub_1000F480(a1, v5);
        }
        else
        {
          (*(void (__cdecl **)(int, _DWORD, int))(a1 + 52))(v5, 0, a5);
          sub_1000F480(a1, v5);
        }
        return;
      case 9:
        (*(void (__cdecl **)(int))(a1 + 56))(v5);
        sub_1000F480(a1, v5);
        return;
      case 0xA:
        sub_10001E70(a1, v5, a4, a5);
        return;
      case 0xB:
        if ( !*(_BYTE *)(v5 + 97) )
          goto LABEL_27;
        sub_10006290(*(_DWORD *)(*(_DWORD *)(v5 + 12) + 4), 0, 0);
        sub_10001D70(a1, v5, 0);
        return;
      case 0xC:
LABEL_27:
        sub_10001E30(a1, v5, a4, a5);
        return;
      case 0xD:
        if ( a4 )
          sub_10001EF0(a1, v5, *(_DWORD *)a4, a5);
        else
          sub_10042930("..\\lib\\atn\\atn_ds.c", 1246, 0, 0);
        return;
      case 0xE:
        if ( v9 == 4 )
        {
          if ( *(_BYTE *)(v5 + 97) )
          {
            byte_10333170 = 0;
            sub_10001EB0(a1, v5, &byte_10333170, a5);
          }
        }
        else
        {
          byte_10333170 = 0;
          sub_10001EB0(a1, v5, &byte_10333170, a5);
        }
        return;
      case 0xF:
        sub_10001EB0(a1, v5, a4, a5);
        return;
      case 0x10:
        sub_10001E90(a1, v5, a4, a5);
        return;
      case 0x11:
        sub_10001D50(a1, v5, a4, a5);
        return;
      case 0x12:
        a2 = 0;
        if ( sub_10001330(a5, &a2) == 1 && *(_DWORD *)a2 == 2 )
        {
          if ( *(_DWORD *)(a2 + 32) )
          {
            v10 = a2 + 176;
            v11 = a4;
            *(_BYTE *)(v5 + 96) = 1;
            sub_10001D10(a1, v5, v11, 0, v10);
          }
          else
          {
            sub_10001D30(a1, v5, a4, a2 + 176);
          }
        }
        return;
      case 0x13:
        a2 = 0;
        if ( sub_10001330(a5, &a2) != 1 || *(_DWORD *)a2 != 2 )
          goto LABEL_47;
        if ( *(_DWORD *)(a2 + 32) )
        {
          sub_10001D10(a1, v5, a4, 0, a2 + 176);
        }
        else
        {
          *(_BYTE *)(v5 + 96) = 1;
LABEL_47:
          sub_10001D70(a1, v5, 0);
        }
        return;
      case 0x14:
        sub_10001DF0(a1, v5, a4, a5);
        return;
      case 0x15:
        sub_10001DD0(a1, v5, a4, a5);
        return;
      case 0x16:
        sub_10001DB0(a1, v5, a4, a5);
        return;
      case 0x17:
        sub_10001D70(a1, v5, a5);
        return;
      case 0x18:
        sub_10001D90(a1, v5);
        return;
      case 0x19:
        *(_DWORD *)(*(_DWORD *)(v5 + 12) + 4) = sub_10006370(
                                                  *(_DWORD *)(a1 + 20),
                                                  v5 + 16,
                                                  (int)a4,
                                                  *(void **)a5,
                                                  (unsigned int)(*(_DWORD *)(a5 + 4) + 7) >> 3);
        return;
      case 0x1A:
        sub_10006050(*(_DWORD *)(*(_DWORD *)(v5 + 12) + 4), *(void **)a5, (unsigned int)(*(_DWORD *)(a5 + 4) + 7) >> 3);
        return;
      case 0x1B:
        sub_10006110(*(_DWORD *)(*(_DWORD *)(v5 + 12) + 4), *(void **)a5, (unsigned int)(*(_DWORD *)(a5 + 4) + 7) >> 3);
        sub_1000F480(a1, v5);
        return;
      case 0x1C:
        v12 = sub_1000F510((int)&unk_10333160, 1u, a5);
        if ( v12 >= 0 )
          goto LABEL_68;
        sub_10006290(*(_DWORD *)(*(_DWORD *)(v5 + 12) + 4), 0, 0);
        sub_10001D90(a1, v5);
        return;
      case 0x1D:
        if ( !v9 )
          sub_1000F560(45, v5);
        v13 = sub_1000F510((int)&unk_10333160, 1u, a5);
        v14 = *(_DWORD *)(v5 + 12);
        if ( v13 < 0 )
          goto LABEL_77;
        goto LABEL_62;
      case 0x1E:
        v15 = sub_1000F510((int)&unk_10333160, 1u, a5);
        v16 = *(_DWORD *)(*(_DWORD *)(v5 + 12) + 4);
        if ( v15 >= 0 )
        {
          sub_100061C0(v16, &unk_10332F60, v15);
        }
        else
        {
          sub_10006290(v16, 0, 0);
          sub_10001D90(a1, v5);
        }
        return;
      case 0x1F:
        v12 = sub_1000F510((int)&unk_10333160, 1u, a5);
        if ( v12 >= 0 )
        {
LABEL_68:
          sub_100061C0(*(_DWORD *)(*(_DWORD *)(v5 + 12) + 4), &unk_10332F60, v12);
        }
        else
        {
          sub_10006290(*(_DWORD *)(*(_DWORD *)(v5 + 12) + 4), 0, 0);
          sub_1000F480(a1, v5);
        }
        return;
      case 0x20:
        v13 = sub_1000F510((int)&unk_10333160, 3u, a5);
        v14 = *(_DWORD *)(v5 + 12);
        if ( v13 >= 0 )
        {
LABEL_62:
          sub_100061C0(*(_DWORD *)(v14 + 4), &unk_10332F60, v13);
        }
        else
        {
          sub_10006290(*(_DWORD *)(v14 + 4), 0, 0);
          sub_10001D90(a1, v5);
        }
        return;
      case 0x22:
        if ( v9 )
        {
          sub_10006290(*(_DWORD *)(*(_DWORD *)(v5 + 12) + 4), 0, 0);
          sub_10001D70(a1, v5, a5);
        }
        else if ( *(_BYTE *)(v5 + 99) == 1 )
        {
LABEL_73:
          sub_10006290(*(_DWORD *)(*(_DWORD *)(v5 + 12) + 4), 0, 0);
          sub_1000F480(a1, v5);
        }
        break;
      case 0x21:
        goto LABEL_73;
      case 0x24:
        sub_10006290(*(_DWORD *)(*(_DWORD *)(v5 + 12) + 4), 0, 0);
        sub_10001D70(a1, v5, 0);
        break;
      case 0x25:
        v14 = *(_DWORD *)(v5 + 12);
LABEL_77:
        sub_10006290(*(_DWORD *)(v14 + 4), 0, 0);
        sub_1000F480(a1, v5);
        break;
      case 0x26:
        (*(void (__cdecl **)(_DWORD, _DWORD, _DWORD))(a1 + 52))(v5, 0, 0);
        sub_1000F480(a1, v5);
        break;
      case 0x23:
        sub_1000F480(a1, v5);
        break;
      default:
        return;
    }
  }
}
// 10333170: using guessed type char byte_10333170;

//----- (1000FD70) --------------------------------------------------------
void __cdecl sub_1000FD70(int a1, int a2, int a3, int a4)
{
  sub_1000F5A0(a1, a2, 0x18u, (_BYTE *)a3, a4);
}

//----- (1000FD90) --------------------------------------------------------
void __cdecl sub_1000FD90(int a1, int a2, int a3, int a4)
{
  sub_1000F5A0(a1, a2, 0x11u, (_BYTE *)a3, a4);
}

//----- (1000FDB0) --------------------------------------------------------
void __cdecl sub_1000FDB0(int a1, int a2, int a3, int a4)
{
  sub_1000F5A0(a1, a2, 0x13u, (_BYTE *)a3, a4);
}

//----- (1000FDD0) --------------------------------------------------------
void __cdecl sub_1000FDD0(int a1, int a2, int a3, int a4)
{
  sub_1000F5A0(a1, a2, 0x12u, (_BYTE *)a3, a4);
}

//----- (1000FDF0) --------------------------------------------------------
_DWORD *__cdecl sub_1000FDF0(int a1)
{
  _DWORD *result; // eax@1
  _DWORD *v2; // edi@1
  bool v3; // zf@5

  sub_10006020(*(char **)(a1 + 20));
  *(_DWORD *)(a1 + 28) = sub_1007C040();
  result = *(_DWORD **)a1;
  v2 = **(_DWORD ***)a1;
  if ( *(_DWORD *)a1 != a1 )
  {
    do
    {
      if ( *((_BYTE *)result + 80) == 1 && (unsigned int)(*(_DWORD *)(a1 + 28) - result[21]) >= result[22] )
        sub_1000FD70(a1, (int)result, 0, 0);
      result = v2;
      v3 = v2 == (_DWORD *)a1;
      v2 = (_DWORD *)*v2;
    }
    while ( !v3 );
  }
  return result;
}

//----- (1000FE40) --------------------------------------------------------
void __cdecl sub_1000FE40(int a1, int a2, int a3, int a4)
{
  sub_1000F5A0(a1, a2, 0x17u, (_BYTE *)a3, a4);
}

//----- (1000FE60) --------------------------------------------------------
void __cdecl sub_1000FE60(int a1, int a2, int a3, int a4)
{
  if ( *(_BYTE *)(a2 + 97) )
    sub_1000F5A0(a1, a2, 0x15u, (_BYTE *)a3, a4);
  else
    sub_1000F5A0(a1, a2, 0x16u, (_BYTE *)a3, a4);
}

//----- (1000FEA0) --------------------------------------------------------
void __cdecl sub_1000FEA0(int a1, int a2, int a3, int a4)
{
  sub_1000F5A0(a1, a2, 0x14u, (_BYTE *)a3, a4);
}

//----- (1000FEC0) --------------------------------------------------------
void __cdecl sub_1000FEC0(int a1, int a2, char a3, int a4, int a5)
{
  __int16 v5; // dx@1
  int v6; // [sp+0h] [bp-8h]@1
  __int16 v7; // [sp+4h] [bp-4h]@1
  char v8; // [sp+6h] [bp-2h]@1

  v5 = *(_WORD *)(a4 + 4);
  v6 = *(_DWORD *)a4;
  v7 = v5;
  v8 = a3;
  if ( a3 )
    sub_1000F5A0(a1, a2, 0xAu, &v6, a5);
  else
    sub_1000F5A0(a1, a2, 9u, &v6, a5);
}

//----- (1000FF30) --------------------------------------------------------
void __cdecl sub_1000FF30(int a1, int a2, int a3, int a4)
{
  sub_1000F5A0(a1, a2, 8u, (_BYTE *)a3, a4);
}

//----- (1000FF50) --------------------------------------------------------
void __cdecl sub_1000FF50(int a1, int a2, int a3, int a4)
{
  sub_1000F5A0(a1, a2, 0xFu, (_BYTE *)a3, a4);
}

//----- (1000FF70) --------------------------------------------------------
void __cdecl sub_1000FF70(int a1, int a2)
{
  sub_1000F5A0(a1, a2, 0x10u, 0, 0);
}

//----- (10010050) --------------------------------------------------------
void __cdecl sub_10010050(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD *v4; // esi@1
  int v5; // ebp@3
  int v6; // [sp-Ch] [bp-24h]@6
  char v7; // [sp-8h] [bp-20h]@6
  _BYTE *v8; // [sp-8h] [bp-20h]@9
  int v9; // [sp-4h] [bp-1Ch]@9
  _DWORD *v10; // [sp+10h] [bp-8h]@2
  int v11; // [sp+14h] [bp-4h]@1

  v11 = 0;
  v4 = sub_1000F400(a1, a2);
  if ( !v4 )
  {
    v7 = 0;
    v6 = 2346;
LABEL_20:
    sub_10042930("..\\lib\\atn\\atn_ds.c", v6, v7, 0);
    return;
  }
  v10 = 0;
  if ( sub_100012F0(a3, a4, &v10) != 1 )
  {
    sub_10042450(10, 0, 0, 0);
    sub_10006290(a2, 0, 0);
    sub_10001480((int)a1, (int)v4, 0x10u, 0, 0);
    return;
  }
  v5 = (int)(v10 + 1);
  if ( *v10 == 1 )
  {
    if ( sub_10001330((int)(v10 + 1), &v11) != 1 )
    {
      sub_10042450(10, 1, 0, 0);
      sub_10006290(a2, 0, 0);
      sub_10001480((int)a1, (int)v4, 0xFu, 0, 0);
      return;
    }
    switch ( *(_DWORD *)v11 )
    {
      case 1:
        v7 = 0;
        v6 = 2207;
        goto LABEL_20;
      case 2:
        v7 = 0;
        v6 = 2217;
        goto LABEL_20;
      case 3:
        sub_1000F5A0((int)a1, (int)v4, 0x1Du, (_BYTE *)(v11 + 4), v11 + 24);
        return;
      case 4:
        v9 = v11 + 24;
        v8 = (_BYTE *)(v11 + 4);
        if ( *(_DWORD *)(v11 + 4) )
          sub_1000F5A0((int)a1, (int)v4, 0x1Fu, v8, v9);
        else
          sub_1000F5A0((int)a1, (int)v4, 0x1Eu, v8, v9);
        return;
      case 5:
        sub_1000F5A0((int)a1, (int)v4, 0x20u, (_BYTE *)(v11 + 8), v5);
        return;
      default:
        v7 = 0;
        v6 = 2289;
        break;
    }
    goto LABEL_20;
  }
  if ( *v10 == 3 )
  {
    sub_1000F5A0((int)a1, (int)v4, 0x21u, 0, (int)(v10 + 1));
  }
  else
  {
    sub_10006290(a2, 0, 0);
    sub_10001480((int)a1, (int)v4, 0xFu, 0, 0);
  }
}

//----- (100102E0) --------------------------------------------------------
void __cdecl sub_100102E0(int a1, int a2, _BYTE *a3, int a4, int a5)
{
  int *v5; // esi@1
  char v6; // [sp+8h] [bp-Ch]@1

  v5 = sub_1000F430(a1, 1);
  *(_DWORD *)(v5[3] + 4) = a2;
  sub_10001F70((int)&v6, a4, 8 * a5);
  sub_1000F5A0(a1, (int)v5, 0x1Au, a3, (int)&v6);
}

//----- (10010340) --------------------------------------------------------
void __cdecl sub_10010340(int a1, int a2, int a3, int a4)
{
  sub_1000F5A0(a1, a2, 0xEu, (_BYTE *)a3, a4);
}

//----- (10010360) --------------------------------------------------------
void __cdecl sub_10010360(int a1, int a2, int a3, int a4)
{
  if ( *(_BYTE *)(a2 + 97) )
    sub_1000F5A0(a1, a2, 0xCu, (_BYTE *)a3, a4);
  else
    sub_1000F5A0(a1, a2, 0xDu, (_BYTE *)a3, a4);
}

//----- (100103A0) --------------------------------------------------------
void __cdecl sub_100103A0(int a1, int a2, int a3)
{
  sub_1000F5A0(a1, a2, 0xBu, 0, a3);
}

//----- (100103C0) --------------------------------------------------------
void __cdecl sub_100103C0(int a1, int a2, char a3, int a4)
{
  int v4; // ST10_4@1

  v4 = a4;
  *(_BYTE *)(a2 + 99) = 1;
  sub_1000F5A0(a1, a2, 7u, &a3, v4);
}

//----- (100103F0) --------------------------------------------------------
void __cdecl sub_100103F0(int a1, int a2, int a3)
{
  sub_1000F5A0(a1, a2, 3u, 0, a3);
}

//----- (10010410) --------------------------------------------------------
void __cdecl sub_10010410(int a1, int a2, char a3, int a4)
{
  if ( *(_BYTE *)(a2 + 98) )
  {
    sub_10006290(*(_DWORD *)(*(_DWORD *)(a2 + 12) + 4), 0, 0);
    sub_10001D70(a1, a2, 0);
  }
  else if ( a3 )
  {
    sub_1000F5A0(a1, a2, 6u, &a3, a4);
  }
  else
  {
    sub_1000F5A0(a1, a2, 5u, &a3, a4);
  }
}

//----- (10010470) --------------------------------------------------------
int *__cdecl sub_10010470(int a1, const void *a2, _BYTE *a3, int a4, int a5, char a6)
{
  int *result; // eax@1
  int v7; // ebx@1

  result = sub_1000F430(a1, 0);
  v7 = (int)result;
  if ( result )
  {
    qmemcpy(result + 4, a2, 0x38u);
    result[18] = a5;
    *((_BYTE *)result + 97) = 1;
    sub_100012D0((int)(result + 19), a6);
    sub_1000F5A0(a1, v7, 0, a3, a4);
    result = (int *)v7;
  }
  return result;
}

//----- (100104D0) --------------------------------------------------------
void __cdecl sub_100104D0(int a1, int a2, char a3, int a4)
{
  if ( a3 )
    sub_1000F5A0(a1, a2, 2u, &a3, a4);
  else
    sub_1000F5A0(a1, a2, 1u, &a3, a4);
}

//----- (10010520) --------------------------------------------------------
int __cdecl sub_10010520(int a1, int a2, __int16 a3, unsigned int a4, int a5, int a6, int a7)
{
  int v7; // esi@1
  _DWORD *v8; // ebp@1
  signed int v9; // edi@1
  int v10; // eax@2
  int v11; // edi@3
  int *v12; // eax@3
  int v13; // ebp@5
  int v14; // eax@6
  signed int v16; // [sp+10h] [bp-4h]@1
  unsigned __int8 v17; // [sp+2Ch] [bp+18h]@1
  unsigned __int8 v18; // [sp+2Ch] [bp+18h]@5

  v7 = a6;
  *(_DWORD *)(a6 + 24) = a1;
  *(_DWORD *)(a6 + 52) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a6 + 48) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a6 + 40) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a6 + 44) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a6 + 56) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a6 + 32) = *(_DWORD *)a2;
  v8 = (_DWORD *)(a6 + 8);
  v9 = 60;
  v16 = 60;
  *(_DWORD *)(a6 + 36) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a6 + 16) = a4;
  *(_DWORD *)v7 = v7;
  *(_DWORD *)(v7 + 4) = v7;
  *v8 = v8;
  *(_DWORD *)(v7 + 12) = v7 + 8;
  v17 = 0;
  if ( a4 )
  {
    v10 = 0;
    do
    {
      v11 = 100 * v10 + v7 + 60;
      sub_1000F4C0(v11);
      v12 = *(int **)(v7 + 12);
      v16 += 100;
      *(_DWORD *)(v7 + 12) = v11;
      *(_DWORD *)(v11 + 4) = v12;
      *(_DWORD *)v11 = v8;
      *v12 = v11;
      v10 = ++v17;
    }
    while ( v17 < a4 );
    v9 = v16;
  }
  v13 = v9 + v7;
  v18 = 0;
  if ( a4 )
  {
    v14 = 0;
    do
    {
      sub_100012A0(v7 + 60 + 100 * v14, v13 + 32 * v14);
      v14 = ++v18;
      v9 += 32;
    }
    while ( v18 < a4 );
  }
  dword_10333180 = (int)sub_100102E0;
  dword_10333184 = (int)sub_10010050;
  dword_10333188 = (int)sub_10010290;
  dword_1033318C = (int)sub_10010240;
  dword_10333190 = (int)sub_1000FF90;
  dword_10333194 = (int)sub_1000FFD0;
  *(_DWORD *)(v7 + 20) = sub_10006950(v7, (int)&dword_10333180, a3, a4, a5 + 220, v7 + v9, a7 - v9);
  return v7;
}
// 1000FF90: using guessed type int sub_1000FF90();
// 1000FFD0: using guessed type int sub_1000FFD0();
// 10010240: using guessed type int sub_10010240();
// 10010290: using guessed type int sub_10010290();
// 10333180: using guessed type int dword_10333180;
// 10333184: using guessed type int dword_10333184;
// 10333188: using guessed type int dword_10333188;
// 1033318C: using guessed type int dword_1033318C;
// 10333190: using guessed type int dword_10333190;
// 10333194: using guessed type int dword_10333194;

//----- (10010690) --------------------------------------------------------
int __cdecl sub_10010690(int a1)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)a1 = 71;
  *(_BYTE *)(a1 + 1) = 0;
  *(_BYTE *)(a1 + 2) = 39;
  return result;
}

//----- (100106A0) --------------------------------------------------------
void *__usercall sub_100106A0@<eax>(_BYTE *a1@<ecx>, int a2@<edi>)
{
  void *result; // eax@1
  int v3; // esi@1

  result = 0;
  v3 = a2 - (_DWORD)a1;
  while ( *a1 )
  {
    a1[v3] = *a1;
    result = (char *)result + 1;
    ++a1;
    if ( (unsigned int)result >= 3 )
      return result;
  }
  if ( (unsigned int)result < 3 )
    result = memset((char *)result + a2, 32, 3 - (_DWORD)result);
  return result;
}

//----- (100106E0) --------------------------------------------------------
unsigned int __cdecl sub_100106E0(int a1, char a2, _BYTE *a3, _BYTE *a4, unsigned int a5)
{
  _BYTE *v5; // ecx@2
  unsigned int result; // eax@4

  sub_10010690(a1);
  if ( a2 )
  {
    v5 = a4;
    *(_BYTE *)(a1 + 3) = 65;
  }
  else
  {
    v5 = a3;
    *(_BYTE *)(a1 + 3) = -63;
  }
  sub_100106A0(v5, a1 + 4);
  result = a5;
  *(_BYTE *)(a1 + 7) = 0;
  *(_BYTE *)(a1 + 8) = a5 >> 16;
  *(_BYTE *)(a1 + 9) = BYTE1(result);
  *(_BYTE *)(a1 + 10) = a5;
  return result;
}

//----- (10010730) --------------------------------------------------------
int sub_10010730()
{
  return 0;
}

//----- (10010740) --------------------------------------------------------
int __cdecl sub_10010740(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int (__cdecl *v6)(int, _DWORD, int, int, int *, signed int); // eax@3
  int result; // eax@4
  int v8; // eax@6
  int v9; // [sp+8h] [bp-10h]@3
  int v10; // [sp+Ch] [bp-Ch]@3
  int v11; // [sp+10h] [bp-8h]@3
  int v12; // [sp+14h] [bp-4h]@3

  if ( a6 )
  {
    *(_DWORD *)a6 = 0;
    *(_DWORD *)(a6 + 4) = 0;
    *(_DWORD *)(a6 + 8) = 0;
  }
  v10 = a5;
  v6 = *(int (__cdecl **)(int, _DWORD, int, int, int *, signed int))(a1 + 8);
  v9 = a4;
  v11 = 0;
  v12 = 0;
  if ( v6 )
  {
    result = v6(a1, 0, a2, a3, &v9, 16);
    if ( result >= 0 )
    {
      v8 = v12 + 8 * v11;
      if ( a6 )
      {
        *(_DWORD *)a6 = a4;
        *(_DWORD *)(a6 + 4) = v8;
        *(_DWORD *)(a6 + 8) = 0;
      }
      result = (v8 + 7) / 8;
    }
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_per_codec.c", 2322, 0, *(char **)a1);
    result = -1;
  }
  return result;
}

//----- (100107F0) --------------------------------------------------------
unsigned int __cdecl sub_100107F0(int a1, unsigned int a2)
{
  unsigned int v2; // ebx@1
  unsigned int result; // eax@2
  int v4; // edx@3
  int v5; // esi@3
  unsigned int v6; // ecx@3

  v2 = *(_DWORD *)(a1 + 4);
  if ( v2 >= a2 )
  {
    v4 = *(_DWORD *)(a1 + 8);
    v5 = *(_DWORD *)a1;
    result = ((*(_BYTE *)(*(_DWORD *)a1 + 3) << v4)
            + (**(_BYTE **)a1 << (v4 + 24))
            + (*(_BYTE *)(*(_DWORD *)a1 + 2) << (v4 + 8))
            + (*(_BYTE *)(*(_DWORD *)a1 + 1) << (v4 + 16))
            + ((unsigned int)*(_BYTE *)(*(_DWORD *)a1 + 4) >> (8 - v4))) >> (32 - a2);
    v6 = v4 + a2;
    *(_DWORD *)(a1 + 4) = v2 - a2;
    *(_DWORD *)(a1 + 8) = v4 + a2;
    if ( v4 + a2 >= 8 )
    {
      *(_DWORD *)a1 = v5 + (v6 >> 3);
      *(_DWORD *)(a1 + 8) = v6 & 7;
    }
  }
  else
  {
    result = -3;
  }
  return result;
}

//----- (10010880) --------------------------------------------------------
signed int __cdecl sub_10010880(int a1, _BYTE *a2, unsigned int a3)
{
  unsigned int v3; // edi@1
  _BYTE *v4; // esi@2
  signed int result; // eax@4

  v3 = a3;
  if ( !a3 )
    return 0;
  v4 = a2;
  while ( v3 >= 8 )
  {
    result = sub_100107F0(a1, 8u);
    if ( result < 0 )
      return result;
    if ( v4 )
      *v4++ = result;
    v3 -= 8;
    if ( !v3 )
      return 0;
  }
  result = sub_100107F0(a1, v3);
  if ( result >= 0 )
  {
    if ( v4 )
      *v4 = (_BYTE)result << (8 - v3);
    return 0;
  }
  return result;
}

//----- (100108E0) --------------------------------------------------------
signed int __cdecl sub_100108E0(int a1, int a2, unsigned int a3)
{
  int v3; // edx@1
  int v4; // ebx@1
  unsigned int v5; // ebp@1
  signed int result; // eax@2
  unsigned int v7; // edi@3
  int v8; // esi@4
  _BYTE *v9; // edx@6
  unsigned int v10; // ebx@6
  unsigned int v11; // ecx@8
  int v12; // esi@9
  int v13; // edx@9

  v3 = *(_DWORD *)(a1 + 12);
  v4 = *(_DWORD *)(a1 + 8);
  v5 = a3;
  if ( a3 + v3 + 8 * v4 <= 8 * *(_DWORD *)(a1 + 4) )
  {
    v7 = a2 << (32 - a3);
    if ( v3 )
    {
      v8 = 8 - v3;
      if ( 8 - v3 > a3 )
        v8 = a3;
      v9 = (_BYTE *)(v4 + *(_DWORD *)a1);
      v10 = v7 >> *(_DWORD *)(a1 + 12);
      v5 = a3 - v8;
      v7 <<= v8;
      *v9 += BYTE3(v10);
      *(_DWORD *)(a1 + 12) += v8;
      if ( *(_DWORD *)(a1 + 12) >= 8u )
      {
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 12) = 0;
      }
    }
    v11 = 0;
    if ( (v5 + 7) >> 3 )
    {
      do
      {
        v12 = v11++ + *(_DWORD *)a1;
        v13 = (unsigned __int64)v7 >> 24;
        v7 <<= 8;
        *(_BYTE *)(v12 + *(_DWORD *)(a1 + 8)) = v13;
      }
      while ( v11 < (v5 + 7) >> 3 );
    }
    *(_DWORD *)(a1 + 12) += v5 & 7;
    *(_DWORD *)(a1 + 8) += v5 >> 3;
    result = 0;
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_per_codec.c", 2534, 0, 0);
    result = -1;
  }
  return result;
}

//----- (100109B0) --------------------------------------------------------
signed int __cdecl sub_100109B0(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // edi@1
  signed int result; // eax@1
  int v5; // esi@2
  int v6; // ecx@5
  unsigned int v7; // eax@7

  v3 = a3;
  result = 0;
  if ( a3 )
  {
    v5 = a2;
    while ( !result )
    {
      if ( v3 < 0x18 )
      {
        v7 = *(_BYTE *)v5;
        if ( v3 > 8 )
          v7 = *(_BYTE *)(v5 + 1) | (v7 << 8);
        if ( v3 > 0x10 )
          v7 = *(_BYTE *)(v5 + 2) | (v7 << 8);
        if ( v3 & 7 )
          v7 >>= 8 - (v3 & 7);
        return sub_100108E0(a1, v7, v3);
      }
      BYTE1(result) = *(_BYTE *)v5;
      v6 = *(_BYTE *)(v5 + 2);
      v5 += 3;
      v3 -= 24;
      LOBYTE(result) = *(_BYTE *)(v5 - 2);
      result = sub_100108E0(a1, v6 | (result << 8), 0x18u);
      if ( !v3 )
        return result;
    }
  }
  return result;
}

//----- (10010A40) --------------------------------------------------------
int __cdecl sub_10010A40(int a1, int a2, void *a3, size_t a4)
{
  int v4; // edx@1
  int v5; // eax@1
  int (__cdecl *v6)(int, _DWORD, void *, size_t, int *, signed int); // eax@1
  int result; // eax@2
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v4 = *(_DWORD *)(a2 + 4);
  v5 = *(_DWORD *)(a2 + 8);
  v8 = *(_DWORD *)a2;
  v9 = v4;
  v10 = v5;
  memset(a3, 0, a4);
  v6 = *(int (__cdecl **)(int, _DWORD, void *, size_t, int *, signed int))(a1 + 4);
  if ( v6 )
  {
    result = v6(a1, 0, a3, a4, &v8, 16);
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_per_codec.c", 2703, 0, *(char **)a1);
    result = -1;
  }
  return result;
}

//----- (10010AC0) --------------------------------------------------------
char __cdecl sub_10010AC0(int a1, int a2)
{
  int v2; // ecx@1
  unsigned __int8 v3; // al@2
  char result; // al@5

  v2 = a2;
  if ( a2 )
  {
    while ( 1 )
    {
      v3 = *(_BYTE *)(a1 + v2-- - 1);
      if ( v3 < 0x20u || v3 > 0x7Eu )
        break;
      if ( !v2 )
        goto LABEL_5;
    }
    result = 0;
  }
  else
  {
LABEL_5:
    result = 1;
  }
  return result;
}

//----- (10010AF0) --------------------------------------------------------
signed int __usercall sub_10010AF0@<eax>(_BYTE *a1@<eax>, int a2)
{
  signed int result; // eax@3

  if ( a1 && *a1 & 4 )
  {
    result = sub_100107F0(a2, 1u);
    if ( result >= 0 )
      result = result != 0 ? 0xFFFFFFFB : 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10010B20) --------------------------------------------------------
int __usercall sub_10010B20@<eax>(int result@<eax>, char **a2@<edx>, int a3@<ecx>, int a4@<esi>, unsigned int a5, int (__cdecl *a6)(char **))
{
  if ( result >= 0 )
  {
    if ( result + a4 <= a5 )
    {
      switch ( a4 )
      {
        case 0:
          result = a6(a2);
          break;
        case 1:
          result = *(_BYTE *)(a3 + result);
          break;
        case 2:
          result = *(_WORD *)(a3 + result);
          break;
        case 4:
          result = *(_DWORD *)(a3 + result);
          break;
        default:
          sub_10042930("..\\lib\\atn\\atn_per_codec.c", 2997, 0, *a2);
          result = -1;
          break;
      }
    }
    else
    {
      sub_10042930("..\\lib\\atn\\atn_per_codec.c", 2968, 0, *a2);
      result = -1;
    }
  }
  return result;
}

//----- (10010BA0) --------------------------------------------------------
signed int __usercall sub_10010BA0@<eax>(unsigned int a1@<eax>, signed int *a2@<ebx>, int a3@<edi>)
{
  signed int result; // eax@2
  signed int v4; // eax@7
  signed int v5; // esi@7
  signed int v6; // eax@9

  if ( a1 <= 0x20 )
  {
    if ( a1 >= 0x20 )
    {
      v4 = sub_100107F0(a3, 0x10u);
      v5 = v4;
      if ( v4 >= 0 )
      {
        v6 = sub_100107F0(a3, 0x10u);
        if ( v6 >= 0 )
        {
          *a2 = 0;
          result = v6 + (v5 << 16);
        }
        else
        {
          *a2 = v6;
          result = 0;
        }
      }
      else
      {
        *a2 = v4;
        result = 0;
      }
    }
    else
    {
      result = sub_100107F0(a3, a1);
      if ( result >= 0 )
      {
        *a2 = 0;
      }
      else
      {
        *a2 = result;
        result = 0;
      }
    }
  }
  else
  {
    *a2 = -2;
    result = 0;
  }
  return result;
}

//----- (10010C10) --------------------------------------------------------
int __cdecl sub_10010C10(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 24) + 8);
}

//----- (10010C20) --------------------------------------------------------
signed int __usercall sub_10010C20@<eax>(_WORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, unsigned int a4)
{
  unsigned int v4; // eax@1
  signed int result; // eax@2
  int v6; // eax@3
  int v7; // eax@4

  v4 = *a1;
  if ( v4 <= a4 )
  {
    v6 = v4 - 1;
    if ( v6 )
    {
      v7 = v6 - 1;
      if ( v7 )
      {
        if ( v7 == 2 )
        {
          *a2 = *a3;
          result = 0;
        }
        else
        {
          sub_10042930("..\\lib\\atn\\atn_per_codec.c", 3147, 0, 0);
          result = -1;
        }
      }
      else
      {
        *a2 = *(_WORD *)a3;
        result = 0;
      }
    }
    else
    {
      *a2 = *(_BYTE *)a3;
      result = 0;
    }
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_per_codec.c", 3127, 0, 0);
    result = -1;
  }
  return result;
}

//----- (10010C90) --------------------------------------------------------
_WORD *__usercall sub_10010C90@<eax>(int a1@<eax>, _WORD *a2@<ecx>)
{
  _WORD *result; // eax@1

  result = *(_WORD **)(a1 + 24);
  if ( result )
    *a2 = *result;
  else
    *a2 = 4;
  return result;
}

//----- (10010CB0) --------------------------------------------------------
signed int __thiscall sub_10010CB0(void *this)
{
  signed int result; // eax@2

  if ( *(_DWORD *)this < 0x10000u )
  {
    result = *(_DWORD *)this >> 14;
    *(_DWORD *)this = result << 14;
  }
  else
  {
    result = 4;
    *(_DWORD *)this = 0x10000;
  }
  return result;
}

//----- (10010CD0) --------------------------------------------------------
int __thiscall sub_10010CD0(int this)
{
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@2

  v1 = *(_WORD *)(this + 20);
  result = 0;
  if ( *(_WORD *)(this + 20) )
  {
    v3 = *(_DWORD *)(this + 16);
    do
    {
      if ( *(_DWORD *)v3 || *(_DWORD *)(v3 + 16) )
        ++result;
      v3 += 24;
      --v1;
    }
    while ( v1 );
  }
  return result;
}

//----- (10010D00) --------------------------------------------------------
void *__usercall sub_10010D00@<eax>(int a1@<eax>, void *a2@<esi>, void *a3, int a4)
{
  signed int v4; // ebx@1
  char v5; // ST10_1@1
  void *result; // eax@1

  v4 = 255 << (8 - a1);
  v5 = v4 & *(_BYTE *)a2;
  result = memcpy_0(a2, a3, (unsigned int)(a1 + a4 + 7) >> 3);
  *(_BYTE *)a2 = v5 + (*(_BYTE *)a2 & ~(_BYTE)v4);
  return result;
}

//----- (10010D40) --------------------------------------------------------
signed int __usercall sub_10010D40@<eax>(_WORD *a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>, unsigned int a4)
{
  unsigned int v4; // eax@1
  signed int result; // eax@2
  int v6; // eax@3
  int v7; // eax@4

  v4 = *a1;
  if ( v4 <= a4 )
  {
    v6 = v4 - 1;
    if ( v6 )
    {
      v7 = v6 - 1;
      if ( v7 )
      {
        if ( v7 == 2 )
        {
          *a2 = a3;
          result = 0;
        }
        else
        {
          sub_10042930("..\\lib\\atn\\atn_per_codec.c", 3377, 0, 0);
          result = -1;
        }
      }
      else
      {
        *(_WORD *)a2 = a3;
        result = 0;
      }
    }
    else
    {
      *(_BYTE *)a2 = a3;
      result = 0;
    }
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_per_codec.c", 3354, 0, 0);
    result = -1;
  }
  return result;
}

//----- (10010DA0) --------------------------------------------------------
signed int __usercall sub_10010DA0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<esi>, unsigned int a5)
{
  signed int result; // eax@2

  if ( a3 >= 0 )
  {
    if ( a3 + a4 <= a5 )
    {
      switch ( a4 )
      {
        case 1:
          *(_BYTE *)(a2 + a3) = a1;
          result = 0;
          break;
        case 2:
          *(_WORD *)(a2 + a3) = a1;
          result = 0;
          break;
        case 4:
          *(_DWORD *)(a2 + a3) = a1;
          goto LABEL_9;
        case 0:
LABEL_9:
          result = 0;
          break;
        default:
          sub_10042930("..\\lib\\atn\\atn_per_codec.c", 3509, 0, 0);
          result = -1;
          break;
      }
    }
    else
    {
      sub_10042930("..\\lib\\atn\\atn_per_codec.c", 3477, 0, 0);
      result = -1;
    }
  }
  else
  {
    result = a1 != 0 ? a3 : 0;
  }
  return result;
}

//----- (10010E20) --------------------------------------------------------
signed int __usercall sub_10010E20@<eax>(int a1@<eax>, unsigned int a2@<edx>)
{
  unsigned int v2; // ecx@1
  signed int result; // eax@2
  unsigned int v4; // ecx@3

  v2 = *(_DWORD *)(a1 + 4);
  if ( v2 >= a2 )
  {
    *(_DWORD *)(a1 + 8) += a2;
    *(_DWORD *)(a1 + 4) = v2 - a2;
    v4 = *(_DWORD *)(a1 + 8);
    if ( v4 >= 8 )
    {
      *(_DWORD *)a1 += v4 >> 3;
      *(_DWORD *)(a1 + 8) = v4 & 7;
    }
    result = 0;
  }
  else
  {
    result = -3;
  }
  return result;
}

//----- (10010E50) --------------------------------------------------------
int __usercall sub_10010E50@<eax>(int a1@<edx>, int a2@<ecx>, unsigned int a3@<esi>, _DWORD *a4)
{
  unsigned int v4; // eax@1
  int result; // eax@4

  v4 = *(_DWORD *)(a1 + 4);
  if ( (v4 & 0x80000000) == 0 && v4 <= a3 && a2 )
  {
    result = a2 + v4;
    *a4 = a3 + a2 - result;
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_per_codec.c", 3583, 0, *(char **)(a1 + 20));
    result = 0;
  }
  return result;
}

//----- (10010E90) --------------------------------------------------------
signed int __usercall sub_10010E90@<eax>(int a1@<eax>)
{
  signed int result; // eax@3

  if ( !a1 || !(*(_BYTE *)a1 & 2) || (result = *(_DWORD *)(a1 + 4), result < 0) )
    result = 8;
  return result;
}

//----- (10010EB0) --------------------------------------------------------
int __usercall sub_10010EB0@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, int a4)
{
  if ( result || (result = *(_DWORD *)(a4 + 12)) != 0 )
  {
    *a2 = result + 20;
    *a3 = result;
  }
  else
  {
    *a2 = 0;
    *a3 = 0;
  }
  return result;
}

//----- (10010ED0) --------------------------------------------------------
unsigned int __cdecl sub_10010ED0(int a1)
{
  unsigned int result; // eax@1
  _DWORD *v2; // ecx@2

  result = 0;
  if ( *(_WORD *)(a1 + 20) )
  {
    v2 = (_DWORD *)(*(_DWORD *)(a1 + 16) + 4);
    while ( 1 )
    {
      ++result;
      if ( *v2 >= 0 )
        break;
      v2 += 6;
      if ( result >= *(_WORD *)(a1 + 20) )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    sub_10042930("..\\lib\\atn\\atn_per_codec.c", 3720, 0, *(char **)a1);
    result = 0;
  }
  return result;
}

//----- (10010F10) --------------------------------------------------------
unsigned int __fastcall sub_10010F10(int a1, int a2)
{
  unsigned int result; // eax@1

  result = 4;
  do
  {
    if ( (a2 & 0xFF800000) != -8388608 && a2 & 0xFF800000 )
      break;
    --result;
    a2 <<= 8;
  }
  while ( result > 1 );
  return result;
}

//----- (10010F40) --------------------------------------------------------
int __usercall sub_10010F40@<eax>(int result@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>)
{
  if ( result && *(_BYTE *)result & 2 )
  {
    *a2 = *(_DWORD *)(result + 12);
    result = *(_DWORD *)(result + 16);
    *a3 = result;
  }
  else
  {
    *a2 = 0;
    *a3 = 255;
  }
  return result;
}

//----- (10010F70) --------------------------------------------------------
int __usercall sub_10010F70@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 + 24);
  if ( result )
  {
    *(_DWORD *)a3 = *(_DWORD *)result;
    result = *(_DWORD *)(result + 4);
    *(_DWORD *)(a3 + 4) = result;
  }
  else if ( a2 && *(_BYTE *)a2 & 2 )
  {
    *(_DWORD *)a3 = *(_DWORD *)(a2 + 16) + 1;
    *(_DWORD *)(a3 + 4) = 1;
  }
  else
  {
    *(_DWORD *)a3 = 12;
    *(_DWORD *)(a3 + 4) = 0;
  }
  return result;
}

//----- (10010FB0) --------------------------------------------------------
int __usercall sub_10010FB0@<eax>(int result@<eax>, int a2)
{
  if ( !result )
    result = *(_DWORD *)(a2 + 12);
  return result;
}

//----- (10010FC0) --------------------------------------------------------
signed int __usercall sub_10010FC0@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>, int a4, unsigned int a5)
{
  unsigned int v5; // ebp@1
  int v6; // edi@1
  _BYTE *v7; // esi@1
  char v8; // bl@1
  signed int result; // eax@4
  int v10; // [sp+10h] [bp-4h]@1

  v5 = a5;
  v6 = a3;
  v7 = a2;
  sub_10010F40(a1, &a5, &v10);
  v8 = a5;
  if ( v5 != 8 || a5 || v10 != 255 )
  {
    if ( v6 )
    {
      while ( 1 )
      {
        result = sub_100107F0(a4, v5);
        if ( result < 0 )
          break;
        *v7++ = result + v8;
        if ( !--v6 )
          goto LABEL_8;
      }
    }
    else
    {
LABEL_8:
      result = 0;
    }
  }
  else
  {
    result = sub_10010880(a4, v7, 8 * v6);
  }
  return result;
}

//----- (10011040) --------------------------------------------------------
signed int __usercall sub_10011040@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>, int a4)
{
  int v4; // ebx@1
  _BYTE *v5; // esi@1
  int v6; // edi@1
  signed int v7; // eax@1
  int v8; // ebp@1
  unsigned int v9; // edi@1
  signed int result; // eax@4
  unsigned int v11; // eax@6
  unsigned int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v4 = a3;
  v5 = a2;
  v6 = a1;
  sub_10010F40(a1, &v13, &v12);
  v7 = sub_10010E90(v6);
  v8 = v13;
  v9 = v7;
  if ( v7 != 8 || v13 || v12 != 255 )
  {
    if ( v4 )
    {
      while ( 1 )
      {
        v11 = v8 + *v5;
        --v4;
        ++v5;
        if ( v11 > v12 )
          break;
        result = sub_100108E0(a4, v11, v9);
        if ( result < 0 )
          return result;
        if ( !v4 )
          goto LABEL_9;
      }
      result = -1;
    }
    else
    {
LABEL_9:
      result = 0;
    }
  }
  else
  {
    result = sub_100109B0(a4, (int)v5, 8 * v4);
  }
  return result;
}

//----- (100110E0) --------------------------------------------------------
signed int __usercall sub_100110E0@<eax>(_BYTE *a1@<ebx>, int a2@<edi>, int a3@<esi>)
{
  signed int result; // eax@5

  if ( a1 )
    *a1 = 0;
  if ( a3 && *(_BYTE *)a3 & 2 && (result = *(_DWORD *)(a3 + 16), result < 0x10000) )
  {
    if ( *(_DWORD *)(a3 + 12) != result )
    {
      result = sub_100107F0(a2, *(_DWORD *)(a3 + 8));
      if ( result >= 0 )
      {
        result += *(_DWORD *)(a3 + 12);
        if ( result > *(_DWORD *)(a3 + 16) )
          result = -1;
      }
    }
  }
  else
  {
    result = sub_100107F0(a2, 1u);
    if ( result >= 0 )
    {
      if ( result )
      {
        result = sub_100107F0(a2, 1u);
        if ( result >= 0 )
        {
          if ( result )
          {
            if ( a1 )
            {
              *a1 = 1;
              result = sub_100107F0(a2, 6u);
              if ( result >= 0 )
                result <<= 14;
            }
            else
            {
              result = -2;
            }
          }
          else
          {
            result = sub_100107F0(a2, 0xEu);
          }
        }
      }
      else
      {
        result = sub_100107F0(a2, 7u);
      }
    }
  }
  return result;
}

//----- (10011180) --------------------------------------------------------
signed int __usercall sub_10011180@<eax>(int a1@<eax>, int a2@<ebx>, _BYTE *a3@<edi>, unsigned int a4)
{
  unsigned int v4; // esi@1
  unsigned int v5; // ecx@5
  signed int v6; // edx@6
  signed int v8; // eax@10
  signed int v9; // eax@19

  v4 = a4;
  if ( a3 )
    *a3 = 0;
  if ( a1 && *(_BYTE *)a1 & 2 )
  {
    v5 = *(_DWORD *)(a1 + 12);
    if ( v4 < v5 )
      return -1;
    v6 = *(_DWORD *)(a1 + 16);
    if ( v4 > v6 )
      return -1;
    if ( v5 == v6 )
      return v4;
    if ( v6 < 0x10000 )
    {
      v8 = sub_100108E0(a2, v4 - v5, *(_DWORD *)(a1 + 8));
      goto LABEL_11;
    }
  }
  if ( v4 <= 0x7F )
  {
    v8 = sub_100108E0(a2, v4, 8u);
    goto LABEL_11;
  }
  if ( v4 < 0x4000 )
  {
    v8 = sub_100108E0(a2, v4 | 0x8000, 0x10u);
LABEL_11:
    if ( !v8 )
      return v4;
    return -1;
  }
  if ( !a3 )
  {
    sub_10042930("..\\lib\\atn\\atn_per_codec.c", 4435, 0, 0);
    return -2;
  }
  *a3 = 1;
  v9 = sub_10010CB0(&a4);
  if ( sub_100108E0(a2, v9 | 0xC0, 8u) )
    return -1;
  return a4;
}

//----- (10011230) --------------------------------------------------------
int __fastcall sub_10011230(int a1, int a2)
{
  int result; // eax@1
  int v3; // ecx@3

  result = *(_DWORD *)(a2 + 24);
  if ( result )
  {
    v3 = *(_DWORD *)(result + 4);
    if ( v3 && v3 != 2 )
    {
      sub_10042930("..\\lib\\atn\\atn_per_codec.c", 4491, 0, *(char **)a2);
      result = 0;
    }
    else if ( *(_DWORD *)(result + 12) > 4u )
    {
      sub_10042930("..\\lib\\atn\\atn_per_codec.c", 4505, 0, *(char **)a2);
      result = 0;
    }
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_per_codec.c", 4479, 0, *(char **)a2);
    result = 0;
  }
  return result;
}

//----- (100112A0) --------------------------------------------------------
signed int __cdecl sub_100112A0(char **a1, int a2, int a3, unsigned int a4, int a5)
{
  _BYTE *v5; // ecx@0
  signed int result; // eax@2
  int v7; // edi@3
  _BYTE *v8; // esi@3
  void *v9; // ecx@5
  unsigned int v10; // ebx@7
  _BYTE *v11; // [sp+0h] [bp-4h]@1

  v11 = v5;
  if ( a4 >= 0xC )
  {
    sub_10010EB0(a2, &v11, &a4, (int)a1);
    v7 = a5;
    v8 = v11;
    result = sub_10010AF0(v11, a5);
    if ( result >= 0 )
    {
      result = sub_100110E0(&a4, v7, (int)v8);
      if ( result >= 0 )
      {
        v9 = *(void **)v7;
        *(_DWORD *)(a3 + 4) = result;
        *(_DWORD *)a3 = v9;
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(v7 + 8);
        result = sub_10010E20(v7, result);
        if ( !result )
        {
          if ( (_BYTE)a4 )
          {
            while ( 1 )
            {
              result = sub_100110E0(&a4, v7, (int)v11);
              v10 = result;
              if ( result < 0 )
                break;
              if ( (unsigned int)result > *(_DWORD *)(v7 + 4) )
                return -3;
              sub_10010D00(
                (*(_BYTE *)(a3 + 4) + *(_BYTE *)(a3 + 8)) & 7,
                (void *)(*(_DWORD *)a3 + ((unsigned int)(*(_DWORD *)(a3 + 4) + *(_DWORD *)(a3 + 8)) >> 3)),
                *(void **)v7,
                result);
              *(_DWORD *)(a3 + 4) += v10;
              sub_10010E20(v7, v10);
              if ( !(_BYTE)a4 )
                goto LABEL_10;
            }
          }
          else
          {
LABEL_10:
            result = 0;
          }
        }
      }
    }
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_per_codec.c", 633, 0, *a1);
    result = -1;
  }
  return result;
}

//----- (100113A0) --------------------------------------------------------
signed int __cdecl sub_100113A0(char **a1, int a2, int a3, unsigned int a4, int a5)
{
  signed int result; // eax@2
  unsigned int v6; // edx@3
  _BYTE *v7; // ebp@3
  int v8; // esi@3
  int v9; // ebx@3
  signed int v10; // edi@7
  unsigned int v11; // eax@9
  unsigned int v12; // esi@9
  int v13; // ecx@12
  _BYTE *v14; // [sp+0h] [bp-10h]@3
  unsigned int v15; // [sp+8h] [bp-8h]@3
  int v16; // [sp+Ch] [bp-4h]@3

  if ( a4 >= 0xC )
  {
    v6 = *(_DWORD *)(a3 + 4);
    v7 = *(_BYTE **)a3;
    v16 = *(_DWORD *)(a3 + 8);
    v15 = v6;
    sub_10010EB0(a2, &v14, &a4, (int)a1);
    v8 = (int)v14;
    v9 = a5;
    if ( v14 && *v14 & 4 && sub_100108E0(a5, 0, 1u) )
    {
      result = -1;
    }
    else
    {
      while ( 1 )
      {
        result = sub_10011180(v8, v9, &a4, v15);
        v10 = result;
        if ( result < 0 )
          break;
        if ( v16 )
        {
          v11 = *v7;
          v12 = 8 - v16;
          if ( 8 - v16 > v10 )
          {
            v12 = v15;
            v11 >>= 8 - v16 - v15;
          }
          if ( sub_100108E0(v9, v11, v12) )
            return -1;
          result = v10 - v12;
          v8 = (int)v14;
          v13 = (int)(v7 + 1);
        }
        else
        {
          v13 = (int)v7;
        }
        if ( sub_100109B0(v9, v13, result) )
          return -1;
        if ( !(_BYTE)a4 )
          return 0;
        v7 += v10 / 8;
        v15 -= v10;
      }
    }
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_per_codec.c", 767, 0, *a1);
    result = -1;
  }
  return result;
}

//----- (100114E0) --------------------------------------------------------
signed int __cdecl sub_100114E0(int a1, int a2, _DWORD *a3, unsigned int a4, int a5)
{
  _BYTE *v5; // esi@1
  signed int result; // eax@1
  signed int v7; // eax@4
  signed int v8; // ecx@5
  int v9; // ecx@6
  char v10; // si@7
  signed int v11; // eax@8
  char v12; // [sp+8h] [bp-Ch]@1
  _BYTE *v13; // [sp+Ch] [bp-8h]@1
  char v14; // [sp+10h] [bp-4h]@1

  sub_10010C90(a1, &v12);
  sub_10010EB0(a2, &v14, &v13, a1);
  v5 = v13;
  result = sub_10010AF0(v13, a5);
  if ( result >= 0 )
  {
    if ( v5 && *v5 & 2 && (v7 = *((_DWORD *)v5 + 1), v7 >= 0) )
    {
      v8 = sub_10010BA0(v7, (signed int *)&v13, a5);
      result = (signed int)v13;
      if ( v13 )
        return result;
      v9 = *((_DWORD *)v5 + 3) + v8;
    }
    else
    {
      result = sub_100110E0(0, a5, 0);
      v10 = result;
      if ( result < 0 )
        return result;
      v11 = sub_10010BA0(8 * result, (signed int *)&v13, a5);
      if ( v13 )
        return (signed int)v13;
      v9 = v11 << 8 * (4 - v10) >> 8 * (4 - v10);
    }
    result = sub_10010D40(&v12, a3, v9, a4);
  }
  return result;
}

//----- (100115B0) --------------------------------------------------------
signed int __cdecl sub_100115B0(int a1, int a2, _DWORD *a3, unsigned int a4, int a5)
{
  int v5; // esi@1
  _WORD *v6; // ecx@1
  signed int result; // eax@1
  unsigned int v8; // ebx@2
  int v9; // eax@9
  unsigned int v10; // esi@12
  char v11; // [sp+4h] [bp-8h]@1
  char v12; // [sp+5h] [bp-7h]@12
  char v13; // [sp+6h] [bp-6h]@12
  char v14; // [sp+7h] [bp-5h]@12
  int v15; // [sp+8h] [bp-4h]@1

  sub_10010C90(a1, &v11);
  v5 = sub_10010FB0(a2, a1);
  result = sub_10010C20(v6, &v15, a3, a4);
  if ( !result )
  {
    v8 = v15;
    if ( v5 )
    {
      if ( *(_DWORD *)v5 & 2 && (v15 < *(_DWORD *)(v5 + 12) || v15 > *(_DWORD *)(v5 + 16))
        || *(_DWORD *)v5 & 4 && sub_100108E0(a5, 0, 1u) )
      {
        return -1;
      }
      if ( *(_BYTE *)v5 & 2 )
      {
        v9 = *(_DWORD *)(v5 + 12);
        if ( v9 == *(_DWORD *)(v5 + 16) || !sub_100108E0(a5, v8 - v9, *(_DWORD *)(v5 + 4)) )
          return 0;
        return -1;
      }
    }
    v11 = BYTE3(v8);
    v12 = v8 >> 16;
    v13 = BYTE1(v8);
    v14 = v8;
    v10 = sub_10010F10(v8 >> 8, v8);
    if ( sub_10011180(0, a5, 0, v10) < 0 )
      return -1;
    result = sub_100109B0(a5, (int)&v15 - v10, 8 * v10);
  }
  return result;
}

//----- (100116C0) --------------------------------------------------------
int __cdecl sub_100116C0(char **a1, int a2, int a3, unsigned int a4, int a5)
{
  int v5; // eax@1
  int v6; // ebp@1
  signed int v7; // eax@1
  _BYTE *v8; // esi@1
  int result; // eax@2
  int v10; // esi@4
  unsigned int v11; // ebx@5
  unsigned int v12; // edx@8
  unsigned int v13; // [sp+Ch] [bp-Ch]@1
  _BYTE *v14; // [sp+10h] [bp-8h]@1
  unsigned int v15; // [sp+14h] [bp-4h]@5

  v5 = sub_10010EB0(a2, &v14, &v13, (int)a1);
  v6 = v5;
  v7 = sub_10010E90(v5);
  v8 = v14;
  v13 = v7;
  sub_10010F70((int)a1, (int)v14, (int)&v14);
  if ( (unsigned int)v14 > a4 )
  {
    sub_10042930("..\\lib\\atn\\atn_per_codec.c", 1481, 0, *a1);
    return -1;
  }
  result = sub_10010AF0(v8, a5);
  if ( result < 0 )
    return result;
  result = sub_100110E0(0, a5, (int)v8);
  v10 = result;
  if ( result < 0 )
    return result;
  v11 = v15;
  if ( !v15 )
  {
    if ( a4 >= 0xC && v14 == (_BYTE *)12 )
    {
      *(_DWORD *)a3 = *(_DWORD *)a5;
      v12 = v13 * result;
      *(_DWORD *)(a3 + 8) = *(_DWORD *)(a5 + 8);
      *(_DWORD *)(a3 + 4) = v12;
      return sub_10010E20(a5, v12);
    }
    sub_10042930("..\\lib\\atn\\atn_per_codec.c", 1514, 0, *a1);
    return -1;
  }
  if ( v15 != 1 )
  {
    if ( v15 == 2 )
    {
      if ( (_BYTE *)result == v14 )
        goto LABEL_12;
    }
    else if ( v15 <= 2 )
    {
      goto LABEL_12;
    }
LABEL_20:
    sub_10042930("..\\lib\\atn\\atn_per_codec.c", 1535, 0, *a1);
    return -1;
  }
  if ( result >= (unsigned int)v14 )
    goto LABEL_20;
LABEL_12:
  result = sub_10010FC0(v6, (_BYTE *)a3, result, a5, v13);
  if ( result )
    return result;
  if ( v11 == 1 )
  {
    if ( !sub_10010AC0(a3, v10) )
      return -4;
    *(_BYTE *)(v10 + a3) = 0;
  }
  return 0;
}

//----- (10011830) --------------------------------------------------------
int __cdecl sub_10011830(int a1, int a2, void *a3, int a4, int a5)
{
  int v5; // eax@1
  int v6; // ebx@1
  int result; // eax@4
  int v8; // esi@9
  _BYTE *v9; // ebp@9
  _BYTE *v10; // [sp+8h] [bp-Ch]@1
  size_t v11; // [sp+Ch] [bp-8h]@1
  int v12; // [sp+10h] [bp-4h]@5
  int v13; // [sp+1Ch] [bp+8h]@1

  v5 = sub_10010EB0(a2, &v10, &v11, a1);
  v6 = (int)v10;
  v13 = v5;
  if ( v10 && *v10 & 4 && sub_100108E0(a5, 0, 1u) )
    return -1;
  sub_10010F70(a1, v6, (int)&v11);
  if ( v12 )
  {
    if ( v12 == 1 )
    {
      if ( v11 > a4 )
      {
        sub_10042930("..\\lib\\atn\\atn_per_codec.c", 1662, 0, *(char **)a1);
        return -1;
      }
      v9 = a3;
      v8 = sub_100422A0(a3, v11);
    }
    else
    {
      if ( v12 != 2 )
      {
        sub_10042930("..\\lib\\atn\\atn_per_codec.c", 1677, 0, *(char **)a1);
        return -1;
      }
      v8 = v11;
      v9 = a3;
    }
  }
  else
  {
    if ( v11 != 12 )
    {
      sub_10042930("..\\lib\\atn\\atn_per_codec.c", 1647, 0, *(char **)a1);
      return -1;
    }
    v9 = *(_BYTE **)a3;
    v8 = *((_DWORD *)a3 + 1) / 8;
  }
  result = sub_10011180(v6, a5, 0, v8);
  if ( result >= 0 )
    result = sub_10011040(v13, v9, v8, a5);
  return result;
}

//----- (10011950) --------------------------------------------------------
int __cdecl sub_10011950(int a1, int a2, int a3, void *a4, size_t a5)
{
  int v6; // [sp+0h] [bp-Ch]@1
  int v7; // [sp+4h] [bp-8h]@1
  int v8; // [sp+8h] [bp-4h]@1

  v6 = a2;
  v7 = 8 * a3;
  v8 = 0;
  return sub_10010A40(a1, (int)&v6, a4, a5);
}

//----- (10011990) --------------------------------------------------------
int __usercall sub_10011990@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<edi>, unsigned int a4, int a5)
{
  int v5; // ebx@1
  int result; // eax@1
  int v7; // eax@2
  int v8; // ecx@3

  v5 = a1;
  result = *(_DWORD *)(a3 + 4);
  if ( result >= 0 )
  {
    v7 = sub_10010E50(a3, a2, a4, &a4);
    if ( v7 )
    {
      v8 = *(_DWORD *)(a3 + 8);
      if ( v8 && *(_DWORD *)(v8 + 4) && v5 )
        return (*(int (__cdecl **)(int, _DWORD, int, unsigned int, int, int))(v8 + 4))(
                 v8,
                 *(_DWORD *)(a3 + 12),
                 v7,
                 a4,
                 a5,
                 v5 - 1);
      sub_10042930("..\\lib\\atn\\atn_per_codec.c", 2852, 0, 0);
    }
    result = -1;
  }
  return result;
}

//----- (10011A00) --------------------------------------------------------
int __usercall sub_10011A00@<eax>(int a1@<ecx>, int a2@<edi>, int a3, unsigned int a4, int a5)
{
  int v5; // eax@1
  int v6; // ebp@1
  int v7; // esi@3
  int result; // eax@4
  int (__cdecl *v9)(_DWORD, int, unsigned int); // eax@5
  unsigned int v10; // ebx@5

  v5 = *(_DWORD *)(a2 + 8);
  v6 = a5;
  if ( v5 && *(_DWORD *)(v5 + 8) )
  {
    v7 = sub_10010E50(a2, a1, a4, &a4);
    if ( v7 )
    {
      v9 = *(int (__cdecl **)(_DWORD, int, unsigned int))(a2 + 16);
      v10 = a4;
      if ( v9 && (unsigned __int8)v9(0, v7, a4) == 1 )
      {
        result = 0;
      }
      else if ( v6 <= 0 )
      {
        sub_10042930("..\\lib\\atn\\atn_per_codec.c", 2917, 0, *(char **)(a2 + 20));
        result = -1;
      }
      else
      {
        result = (*(int (__cdecl **)(_DWORD, _DWORD, int, unsigned int, int, int))(*(_DWORD *)(a2 + 8) + 8))(
                   *(_DWORD *)(a2 + 8),
                   *(_DWORD *)(a2 + 12),
                   v7,
                   v10,
                   a3,
                   v6 - 1);
      }
    }
    else
    {
      result = -1;
    }
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10011AB0) --------------------------------------------------------
signed int __usercall sub_10011AB0@<eax>(int a1@<eax>, int a2@<ecx>, int a3, unsigned int a4)
{
  int v4; // esi@1
  signed int result; // eax@3

  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 )
  {
    result = sub_10010DA0(a1, a3, *(_DWORD *)a2, v4, a4);
  }
  else if ( a1 == *(_DWORD *)(a2 + 8) )
  {
    result = 0;
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_per_codec.c", 3416, 0, 0);
    result = -1;
  }
  return result;
}

//----- (10011B00) --------------------------------------------------------
signed int __usercall sub_10011B00@<eax>(_BYTE *a1@<eax>, int a2@<ecx>)
{
  int v2; // esi@1
  int v3; // edi@1
  signed int result; // eax@2

  v2 = (int)a1;
  v3 = a2;
  if ( !a1
    || (result = sub_10010AF0(a1, a2), result >= 0)
    && (!(*(_BYTE *)v2 & 2) || (result = *(_DWORD *)(v2 + 12), result != *(_DWORD *)(v2 + 16))) )
  {
    result = sub_100110E0(0, v3, v2);
  }
  return result;
}

//----- (10011B30) --------------------------------------------------------
signed int __usercall sub_10011B30@<eax>(int a1@<eax>, int a2@<esi>, unsigned int a3)
{
  int v3; // ebx@1
  signed int result; // eax@4
  signed int v5; // eax@8

  v3 = a1;
  if ( !a2 )
    goto LABEL_11;
  if ( *(_BYTE *)a2 & 4 && sub_100108E0(a1, 0, 1u) )
    return -1;
  if ( *(_BYTE *)a2 & 2 && *(_DWORD *)(a2 + 12) == *(_DWORD *)(a2 + 16) )
  {
    result = 0;
  }
  else
  {
LABEL_11:
    v5 = sub_10011180(a2, v3, 0, a3);
    result = v5 >= 0 ? 0 : v5;
  }
  return result;
}

//----- (10011B90) --------------------------------------------------------
signed int __cdecl sub_10011B90(int a1, int a2, int a3, unsigned int a4, int a5, int a6)
{
  int v6; // ebx@1
  int v7; // esi@3
  signed int result; // eax@7
  signed int v9; // eax@8
  signed int v10; // edi@8
  int v11; // eax@11
  int v12; // [sp+8h] [bp-8h]@3
  char v13; // [sp+Ch] [bp-4h]@3

  v6 = *(_DWORD *)(a1 + 24);
  if ( !v6 || !*(_DWORD *)(a1 + 16) )
  {
    sub_10042930("..\\lib\\atn\\atn_per_codec.c", 904, 0, *(char **)a1);
    return -1;
  }
  sub_10010EB0(a2, &v13, &v12, a1);
  v7 = v12;
  if ( !v12
    || *(_DWORD *)(v12 + 4) < 0
    || *(_DWORD *)(v12 + 12)
    || *(_DWORD *)(v12 + 16) > (signed int)*(_WORD *)(a1 + 20) )
  {
    sub_10042930("..\\lib\\atn\\atn_per_codec.c", 920, 0, *(char **)a1);
    return -1;
  }
  result = sub_10010AF0((_BYTE *)v12, a5);
  if ( result < 0 )
    return result;
  v9 = sub_100107F0(a5, *(_DWORD *)(v7 + 4));
  v10 = v9;
  if ( v9 < 0 )
    return -3;
  if ( v9 > *(_DWORD *)(v7 + 16) )
    return -1;
  v11 = *(_DWORD *)(v6 + 8);
  if ( v11 )
    v10 = *(_WORD *)(v11 + 2 * v10);
  result = sub_10010DA0(v10 + 1, a3, *(_WORD *)(v6 + 2), *(_WORD *)(v6 + 4), a4);
  if ( !result )
    result = sub_10011990(a6, a3, *(_DWORD *)(a1 + 16) + 24 * v10, a4, a5);
  return result;
}

//----- (10011CC0) --------------------------------------------------------
int __cdecl sub_10011CC0(int a1, int a2, int a3, unsigned int a4, int a5, int a6)
{
  int v6; // edi@1
  int v7; // ebx@1
  int v8; // eax@3
  _BYTE *v9; // ebp@3
  int v10; // esi@5
  int v11; // ebx@9
  int v12; // eax@10
  int result; // eax@13
  int v14; // [sp+Ch] [bp+4h]@3

  v6 = a1;
  v7 = *(_DWORD *)(a1 + 24);
  if ( v7 && *(_DWORD *)(a1 + 16) )
  {
    v8 = sub_10010FB0(a2, a1);
    v9 = (_BYTE *)v8;
    v14 = v8;
    if ( v8 && *(_DWORD *)(v8 + 4) >= 0 )
    {
      v10 = sub_10010B20(
              *(_WORD *)(v7 + 2),
              (char **)v6,
              a3,
              *(_WORD *)(v7 + 4),
              a4,
              (int (__cdecl *)(char **))sub_10010ED0)
          - 1;
      if ( v10 < 0
        || v10 >= *(_WORD *)(v6 + 20)
        || *v9 & 4 && sub_100108E0(a5, 0, 1u)
        || ((v11 = *(_DWORD *)(v7 + 8)) == 0 ? (v12 = v10) : (v12 = *(_WORD *)(v11 + 2 * v10)),
            sub_100108E0(a5, v12, *(_DWORD *)(v14 + 4))) )
      {
        result = -1;
      }
      else
      {
        result = sub_10011A00(a3, *(_DWORD *)(v6 + 16) + 24 * v10, a5, a4, a6);
      }
    }
    else
    {
      sub_10042930("..\\lib\\atn\\atn_per_codec.c", 1025, 0, *(char **)v6);
      result = -1;
    }
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_per_codec.c", 1009, 0, *(char **)a1);
    result = -1;
  }
  return result;
}

//----- (10011E00) --------------------------------------------------------
int __cdecl sub_10011E00(int a1, int a2, int a3, unsigned int a4, int a5, int a6)
{
  int v6; // esi@1
  int v7; // eax@1
  int result; // eax@3
  unsigned int v9; // eax@6
  int v10; // edi@10
  int v11; // ebx@10
  int v12; // ebp@12
  int v13; // eax@18
  int v14; // [sp+8h] [bp-18h]@9
  signed int v15; // [sp+Ch] [bp-14h]@8
  int v16; // [sp+10h] [bp-10h]@18
  int v17; // [sp+14h] [bp-Ch]@7
  int v18; // [sp+18h] [bp-8h]@7
  int v19; // [sp+1Ch] [bp-4h]@7

  v6 = a1;
  v7 = *(_DWORD *)(a1 + 24);
  if ( *(_DWORD *)(v7 + 16) >= 0 || *(_DWORD *)(v7 + 12) >= 0 )
  {
    result = sub_100107F0(a5, 1u);
    if ( result < 0 )
      return result;
    if ( result )
      return -5;
  }
  v9 = sub_10010CD0(a1);
  if ( v9 > 0 )
  {
    v17 = *(_DWORD *)a5;
    v18 = *(_DWORD *)(a5 + 4);
    v19 = *(_DWORD *)(a5 + 8);
    sub_10010880(a5, 0, v9);
  }
  v15 = 0;
  if ( *(_WORD *)(a1 + 20) )
  {
    v14 = 0;
    do
    {
      v10 = v14 + *(_DWORD *)(v6 + 16);
      v11 = *(_DWORD *)v10;
      if ( !*(_DWORD *)v10 && !*(_DWORD *)(v10 + 16) )
        goto LABEL_28;
      result = sub_100107F0((int)&v17, 1u);
      v12 = result;
      if ( result < 0 )
        return result;
      if ( v11 )
      {
        result = sub_10010DA0(result, a3, v11, 1, a4);
        if ( result )
          return result;
        v6 = a1;
      }
      if ( !v12 )
      {
        if ( *(_DWORD *)(v10 + 16) )
        {
          v13 = sub_10010E50(v10, a3, a4, &v16);
          if ( !(unsigned __int8)(*(int (__cdecl **)(signed int, int, int))(v10 + 16))(1, v13, v16) )
            return -1;
          v6 = a1;
        }
      }
      else
      {
LABEL_28:
        result = sub_10011990(a6, a3, v10, a4, a5);
        if ( result )
          return result;
      }
      v14 += 24;
      ++v15;
    }
    while ( v15 < *(_WORD *)(v6 + 20) );
  }
  return 0;
}

//----- (10011F60) --------------------------------------------------------
int __cdecl sub_10011F60(int a1, int a2, int a3, unsigned int a4, int a5, int a6)
{
  int v6; // ebx@1
  int v7; // eax@1
  int v8; // ebp@1
  int v9; // esi@3
  int result; // eax@4
  int v11; // ecx@6
  bool v12; // zf@6
  int v13; // edi@8
  int v14; // ebp@8
  int v15; // eax@12
  signed int v16; // esi@18
  _DWORD *v17; // edi@19
  int v18; // [sp+Ch] [bp-14h]@6
  int v19; // [sp+10h] [bp-10h]@12
  int v20; // [sp+14h] [bp-Ch]@6
  int v21; // [sp+18h] [bp-8h]@6
  int v22; // [sp+1Ch] [bp-4h]@6
  int v23; // [sp+24h] [bp+4h]@7

  v6 = a1;
  v7 = *(_DWORD *)(a1 + 24);
  v8 = 0;
  if ( *(_DWORD *)(v7 + 16) < 0 && *(_DWORD *)(v7 + 12) < 0 )
  {
    v9 = a5;
  }
  else
  {
    v9 = a5;
    if ( sub_100108E0(a5, 0, 1u) )
      return -1;
  }
  v11 = *(_DWORD *)v9 + *(_DWORD *)(v9 + 8);
  v12 = *(_WORD *)(a1 + 20) == 0;
  v22 = *(_DWORD *)(v9 + 12);
  v20 = v11;
  v21 = 0;
  v18 = 0;
  if ( !v12 )
  {
    v23 = 0;
    while ( 1 )
    {
      v13 = v23 + *(_DWORD *)(v6 + 16);
      v14 = 0;
      if ( *(_DWORD *)v13 )
      {
        if ( sub_10010B20(*(_DWORD *)v13, (char **)v6, a3, 1, a4, 0) == 1 )
          v14 = 1;
      }
      else
      {
        if ( !*(_DWORD *)(v13 + 16) )
          goto LABEL_16;
        v15 = sub_10010E50(v13, a3, a4, &v19);
        if ( v15 && !(unsigned __int8)(*(int (__cdecl **)(_DWORD, int, int))(v13 + 16))(0, v15, v19) )
          v14 = 1;
      }
      ++v21;
      if ( sub_100108E0(a5, v14, 1u) )
        return -1;
LABEL_16:
      v23 += 24;
      if ( ++v18 >= *(_WORD *)(v6 + 20) )
      {
        v8 = 0;
        break;
      }
    }
  }
  v16 = 0;
  if ( *(_WORD *)(v6 + 20) <= (unsigned __int16)v8 )
  {
LABEL_23:
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      v17 = (_DWORD *)(v8 + *(_DWORD *)(v6 + 16));
      if ( !*v17 || sub_100107F0((int)&v20, 1u) == 1 )
      {
        result = sub_10011A00(a3, (int)v17, a5, a4, a6);
        if ( result )
          break;
      }
      ++v16;
      v8 += 24;
      if ( v16 >= *(_WORD *)(v6 + 20) )
        goto LABEL_23;
    }
  }
  return result;
}

//----- (100120D0) --------------------------------------------------------
int __cdecl sub_100120D0(_BYTE *a1, int a2, int a3, unsigned int a4, int a5, int a6)
{
  _BYTE *v6; // edi@1
  int v7; // eax@1
  int v8; // esi@1
  int v9; // edx@4
  int v10; // ecx@4
  int v11; // edx@4
  int v12; // ecx@4
  int v13; // edx@4
  int result; // eax@4
  int v15; // ebp@4
  unsigned int v16; // ebx@5
  int v17; // ebx@8
  unsigned int v18; // ecx@9
  char v19; // [sp+8h] [bp-1Ch]@1
  int v20; // [sp+Ch] [bp-18h]@4
  int v21; // [sp+10h] [bp-14h]@4
  int v22; // [sp+14h] [bp-10h]@4
  int v23; // [sp+18h] [bp-Ch]@4
  int v24; // [sp+1Ch] [bp-8h]@4
  int v25; // [sp+20h] [bp-4h]@4

  v6 = a1;
  sub_10010EB0(a2, &a1, &v19, (int)a1);
  v7 = *((_DWORD *)v6 + 4);
  v8 = *((_DWORD *)v6 + 6);
  if ( v7 && *((_WORD *)v6 + 10) == 1 && v8 )
  {
    v9 = *(_DWORD *)(v7 + 4);
    v20 = *(_DWORD *)v7;
    v10 = *(_DWORD *)(v7 + 8);
    v21 = v9;
    v11 = *(_DWORD *)(v7 + 12);
    v22 = v10;
    v12 = *(_DWORD *)(v7 + 16);
    v23 = v11;
    v13 = *(_DWORD *)(v7 + 20);
    v24 = v12;
    v25 = v13;
    result = sub_10011B00(a1, a5);
    v15 = result;
    if ( result >= 0 )
    {
      v16 = a4;
      result = sub_10011AB0(result, v8, a3, a4);
      if ( !result )
      {
        if ( *(_DWORD *)(v8 + 12) + v15 * *(_DWORD *)(v8 + 16) > v16 || (unsigned int)v15 > *(_DWORD *)(v8 + 8) )
        {
          sub_10042930("..\\lib\\atn\\atn_per_codec.c", 2081, 0, *(char **)v6);
          result = -1;
        }
        else
        {
          v17 = 0;
          if ( v15 <= 0 )
          {
LABEL_11:
            result = 0;
          }
          else
          {
            while ( 1 )
            {
              v18 = *(_DWORD *)(v8 + 12) + v17 * *(_DWORD *)(v8 + 16) + *(_DWORD *)(v8 + 16);
              v21 = *(_DWORD *)(v8 + 12) + v17 * *(_DWORD *)(v8 + 16);
              result = sub_10011990(a6, a3, (int)&v20, v18, a5);
              if ( result )
                break;
              if ( ++v17 >= v15 )
                goto LABEL_11;
            }
          }
        }
      }
    }
  }
  else
  {
    sub_10042930("..\\lib\\atn\\atn_per_codec.c", 2053, 0, *(char **)v6);
    result = -1;
  }
  return result;
}

//----- (10012210) --------------------------------------------------------
int __cdecl sub_10012210(int a1, int a2, int a3, unsigned int a4, int a5, int a6)
{
  int v6; // ecx@1
  int v7; // eax@1
  int v8; // ebx@1
  int result; // eax@2
  unsigned int v10; // ebp@3
  int v11; // eax@5
  int v12; // edx@7
  int v13; // ecx@7
  int v14; // edx@7
  int v15; // ecx@7
  int v16; // edx@7
  unsigned int v17; // eax@7
  int v18; // esi@9
  unsigned int v19; // ecx@10
  int v20; // [sp+8h] [bp-20h]@1
  char v21; // [sp+Ch] [bp-1Ch]@1
  int v22; // [sp+10h] [bp-18h]@7
  int v23; // [sp+14h] [bp-14h]@7
  int v24; // [sp+18h] [bp-10h]@7
  int v25; // [sp+1Ch] [bp-Ch]@7
  int v26; // [sp+20h] [bp-8h]@7
  int v27; // [sp+24h] [bp-4h]@7

  sub_10010EB0(a2, &v20, &v21, a1);
  v7 = sub_10011230(v6, a1);
  v8 = v7;
  if ( !v7 )
    return -1;
  result = sub_10010B20(*(_DWORD *)v7, (char **)a1, a3, *(_DWORD *)(v7 + 4), a4, (int (__cdecl *)(char **))sub_10010C10);
  v10 = result;
  if ( result >= 0 )
  {
    if ( sub_10011B30(a5, v20, result) )
      return -1;
    v11 = *(_DWORD *)(a1 + 16);
    if ( !v11 || *(_WORD *)(a1 + 20) != 1 )
    {
      sub_10042930("..\\lib\\atn\\atn_per_codec.c", 2191, 0, *(char **)a1);
      return -1;
    }
    v12 = *(_DWORD *)(v11 + 4);
    v22 = *(_DWORD *)v11;
    v13 = *(_DWORD *)(v11 + 8);
    v23 = v12;
    v14 = *(_DWORD *)(v11 + 12);
    v24 = v13;
    v15 = *(_DWORD *)(v11 + 16);
    v25 = v14;
    v16 = *(_DWORD *)(v11 + 20);
    v17 = *(_DWORD *)(v8 + 12) + v10 * *(_DWORD *)(v8 + 16);
    v26 = v15;
    v27 = v16;
    if ( v17 > a4 )
    {
      sub_10042930("..\\lib\\atn\\atn_per_codec.c", 2200, 0, *(char **)a1);
      return -1;
    }
    v18 = 0;
    if ( v10 )
    {
      while ( 1 )
      {
        v19 = *(_DWORD *)(v8 + 12) + v18 * *(_DWORD *)(v8 + 16) + *(_DWORD *)(v8 + 16);
        v23 = *(_DWORD *)(v8 + 12) + v18 * *(_DWORD *)(v8 + 16);
        result = sub_10011A00(a3, (int)&v22, a5, v19, a6);
        if ( result )
          break;
        if ( ++v18 >= v10 )
          goto LABEL_12;
      }
    }
    else
    {
LABEL_12:
      result = 0;
    }
  }
  return result;
}

//----- (10012350) --------------------------------------------------------
void __cdecl sub_10012350(int a1, int a2)
{
  char v2; // [sp+0h] [bp-ACh]@1
  int v3; // [sp+4h] [bp-A8h]@1
  size_t v4; // [sp+8h] [bp-A4h]@1

  v2 = sub_10004520(a1, a2, &v4, (int)&v3);
  if ( v2 )
    sub_10002320((int)&v4, v2, v3);
  else
    sub_100035E0((size_t)&v4);
}

//----- (100123E0) --------------------------------------------------------
char __cdecl sub_100123E0(int a1)
{
  return sub_10042530(*(void **)a1, *(_BYTE *)(*(_DWORD *)a1 + 1), *(void **)(a1 + 8), *(_WORD *)(a1 + 12));
}

//----- (10012400) --------------------------------------------------------
char *__usercall sub_10012400@<eax>(int a1@<eax>, int a2)
{
  char *result; // eax@1
  unsigned int v3; // edx@2
  int v4; // edi@2
  char v5; // cl@3
  char *v6; // ecx@4
  char v7; // dl@5
  char *v8; // esi@6
  char *v9; // edi@6
  char v10; // cl@7

  result = (char *)(a1 + 4);
  if ( *result != 32 )
  {
    v3 = strlen(" ") + 1;
    v4 = a2 - 1;
    do
      v5 = *(_BYTE *)(v4++ + 1);
    while ( v5 );
    qmemcpy((void *)v4, " ", v3);
    v6 = result;
    do
      v7 = *result++;
    while ( v7 );
    result -= (signed int)v6;
    v8 = v6;
    v9 = (char *)(a2 - 1);
    do
      v10 = (v9++)[1];
    while ( v10 );
    qmemcpy(v9, v8, (unsigned int)result);
  }
  return result;
}

//----- (10012480) --------------------------------------------------------
int __cdecl sub_10012480(int a1, int a2, int a3, float a4)
{
  signed int v4; // kr00_4@1
  int v5; // eax@5
  signed int v6; // ecx@8
  int v7; // eax@12
  signed int v8; // ecx@15
  int v9; // eax@22
  signed int v10; // ecx@25
  int v11; // eax@29
  signed int v12; // ecx@32
  char *v13; // esi@38
  char *v14; // ebx@39
  unsigned int v15; // eax@39
  char *v16; // edi@39
  char v17; // cl@40
  int result; // eax@47
  char *v19; // esi@47
  char *v20; // edi@47
  char v21; // cl@48
  char *v22; // ebx@49
  unsigned int v23; // eax@50
  char *v24; // edi@50
  char v25; // cl@51
  char v26; // cl@53
  unsigned int v27; // eax@56
  char *v28; // edi@56
  char v29; // cl@57
  int v30; // eax@58
  char v31; // cl@59
  unsigned int v32; // eax@60
  char *v33; // edi@60
  char v34; // cl@61
  char v35; // cl@63
  unsigned int v36; // eax@65
  char *v37; // edi@65
  char v38; // cl@66
  int v39; // eax@67
  char v40; // cl@68
  char v41; // cl@73
  char *v42; // edi@79
  char v43; // al@80
  char *v44; // edi@81
  char v45; // al@82
  char *v46; // edi@85
  char v47; // al@86
  char *v48; // esi@87
  char *v49; // edi@87
  char v50; // cl@88
  unsigned int v51; // eax@91
  int v52; // ecx@91
  int v53; // eax@92
  char *v54; // edi@95
  char v55; // al@96
  char v56; // cl@98
  unsigned int v57; // eax@104
  int v58; // ecx@104
  int v59; // eax@105
  char *v60; // edi@108
  char v61; // al@109
  char v62; // cl@111
  char *v63; // edi@114
  char v64; // al@115
  char v65; // cl@117
  char v66; // [sp+1Bh] [bp-75h]@38
  char *v67; // [sp+1Ch] [bp-74h]@1
  char v68; // [sp+22h] [bp-6Eh]@38
  char v69; // [sp+23h] [bp-6Dh]@38
  char v70; // [sp+24h] [bp-6Ch]@38
  unsigned __int8 v71; // [sp+28h] [bp-68h]@1
  unsigned __int8 v72; // [sp+29h] [bp-67h]@6
  unsigned __int8 v73; // [sp+2Ah] [bp-66h]@7
  unsigned __int8 v74; // [sp+2Bh] [bp-65h]@14
  char v75; // [sp+2Ch] [bp-64h]@52
  char v76; // [sp+2Dh] [bp-63h]@2
  char v77; // [sp+2Eh] [bp-62h]@3
  char v78; // [sp+2Fh] [bp-61h]@4
  char v79; // [sp+31h] [bp-5Fh]@42
  char v80; // [sp+35h] [bp-5Bh]@75
  char v81[31]; // [sp+39h] [bp-57h]@77
  float v82; // [sp+58h] [bp-38h]@78
  char v83[4]; // [sp+5Ch] [bp-34h]@19
  char v84; // [sp+60h] [bp-30h]@60
  char v85; // [sp+63h] [bp-2Dh]@81
  char v86[4]; // [sp+64h] [bp-2Ch]@77
  char v87; // [sp+68h] [bp-28h]@103
  char v88; // [sp+73h] [bp-1Dh]@79
  char v89[4]; // [sp+74h] [bp-1Ch]@77
  int v90; // [sp+78h] [bp-18h]@102
  char v91; // [sp+84h] [bp-Ch]@41

  v67 = (char *)a3;
  sub_10034710(a1, a2, (int)&v71);
  v4 = strlen((const char *)&v71);
  if ( v4 < 5 )
  {
    memset(&v71 + v4, 32, 5 - v4);
    v76 = 0;
  }
  if ( v77 == 9 )
  {
    if ( v78 )
    {
      v5 = v71 - 86;
      if ( v71 == 86 && (v5 = v72 - 68, v72 == 68) && (v5 = v73 - 77, v73 == 77) )
      {
        v6 = 0;
      }
      else
      {
        v6 = 1;
        if ( v5 <= 0 )
          v6 = -1;
      }
      if ( !v6 )
        goto LABEL_121;
      v7 = v72 - 86;
      if ( v72 == 86 && (v7 = v73 - 68, v73 == 68) && (v7 = v74 - 77, v74 == 77) )
      {
        v8 = 0;
      }
      else
      {
        v8 = 1;
        if ( v7 <= 0 )
          v8 = -1;
      }
      if ( !v8 )
      {
LABEL_121:
        v83[0] = 8;
        goto LABEL_38;
      }
    }
  }
  else if ( v77 == 13 && v78 )
  {
    v9 = v71 - 78;
    if ( v71 == 78 && (v9 = v72 - 68, v72 == 68) && (v9 = v73 - 77, v73 == 77) )
    {
      v10 = 0;
    }
    else
    {
      v10 = 1;
      if ( v9 <= 0 )
        v10 = -1;
    }
    if ( !v10 )
      goto LABEL_122;
    v11 = v72 - 78;
    if ( v72 == 78 && (v11 = v73 - 68, v73 == 68) && (v11 = v74 - 77, v74 == 77) )
    {
      v12 = 0;
    }
    else
    {
      v12 = 1;
      if ( v11 <= 0 )
        v12 = -1;
    }
    if ( !v12 )
    {
LABEL_122:
      v83[0] = 12;
      goto LABEL_38;
    }
  }
  v83[0] = v77;
LABEL_38:
  v13 = v67;
  sub_10030640(v83[0], v67);
  sub_10034E40(a1, a2, &v68, &v66, (int)&v70, (bool *)&v69);
  if ( sub_100438F0((int)&v71, 0) == 4 )
  {
    v15 = strlen(" ") + 1;
    v14 = v67;
    v16 = v67 - 1;
    do
      v17 = (v16++)[1];
    while ( v17 );
    qmemcpy(v16, " ", v15);
    sub_10044450(a4, &v91);
    v13 = strcat(v14, &v91);
  }
  else if ( v79 && strncmp(v13, "GPS", 3u) )
  {
    v13 = strcat(v67, "");
  }
  if ( v78 )
  {
    if ( v71 == 67 )
    {
      sub_10012400((int)&v71, (int)v13);
      result = strlen(" C-T-L") + 1;
      v19 = " C-T-L";
      v20 = v67 - 1;
      do
        v21 = (v20++)[1];
      while ( v21 );
      v22 = v67;
    }
    else
    {
      v23 = strlen("-") + 1;
      v22 = v67;
      v24 = v67 - 1;
      do
        v25 = (v24++)[1];
      while ( v25 );
      qmemcpy(v24, "-", v23);
      v75 = 0;
      result = strlen((const char *)&v74) + 1;
      v19 = (char *)&v74;
      v20 = v22 - 1;
      do
        v26 = (v20++)[1];
      while ( v26 );
    }
  }
  else if ( (unsigned __int8)(v74 - 48) > 9u )
  {
    sub_10012400((int)&v71, (int)v13);
    v36 = strlen(" ") + 1;
    v22 = v67;
    v37 = v67 - 1;
    do
      v38 = (v37++)[1];
    while ( v38 );
    qmemcpy(v37, " ", v36);
    v39 = 0;
    do
    {
      v40 = *(&v71 + v39);
      v83[v39++] = v40;
    }
    while ( v40 );
    if ( v74 == 32 )
      v83[3] = 0;
    else
      v84 = 0;
    result = strlen(&v83[1]) + 1;
    v19 = &v83[1];
    v20 = v22 - 1;
    do
      v41 = (v20++)[1];
    while ( v41 );
  }
  else
  {
    sub_10012400((int)&v71, (int)v13);
    v27 = strlen(" ") + 1;
    v22 = v67;
    v28 = v67 - 1;
    do
      v29 = (v28++)[1];
    while ( v29 );
    qmemcpy(v28, " ", v27);
    v30 = 0;
    do
    {
      v31 = *(&v71 + v30);
      v83[v30++] = v31;
    }
    while ( v31 );
    v84 = 0;
    v32 = strlen(&v83[1]) + 1;
    v33 = v22 - 1;
    do
      v34 = (v33++)[1];
    while ( v34 );
    qmemcpy(v33, &v83[1], v32);
    result = strlen("") + 1;
    v19 = "";
    v20 = v22 - 1;
    do
      v35 = (v20++)[1];
    while ( v35 );
  }
  qmemcpy(v20, v19, result);
  if ( v66 == 15 )
  {
    if ( !v79 )
      return result;
    v90 = 7104865;
    *(_DWORD *)v89 = 1986096725;
    if ( (signed int)(strlen(v89) + strlen(v22) + 1) <= 25 )
    {
      v63 = v22 - 1;
      do
        v64 = (v63++)[1];
      while ( v64 );
      *(_WORD *)v63 = 32;
      result = strlen(v89) + 1;
      v48 = v89;
      v49 = v22 - 1;
      do
        v65 = (v49++)[1];
      while ( v65 );
    }
    else
    {
      v87 = 0;
      *(_DWORD *)v86 = 1886350921;
      if ( (signed int)(strlen(v86) + strlen(v22) + 2) > 25 )
      {
        v57 = strlen(v22);
        v58 = 23 - v57;
        if ( (signed int)(23 - v57) <= 0 )
        {
          v59 = 0;
        }
        else
        {
          v59 = 23 - v57;
          if ( v58 >= 15 )
            v59 = 15;
        }
        v86[v59] = 0;
      }
      v60 = v22 - 1;
      do
        v61 = (v60++)[1];
      while ( v61 );
      *(_WORD *)v60 = 32;
      result = strlen(v86) + 1;
      v48 = v86;
      v49 = v22 - 1;
      do
        v62 = (v49++)[1];
      while ( v62 );
    }
    goto LABEL_118;
  }
  result = sub_10043FF0(&v66, 1u, (int)&v80, 1, 4, -1);
  if ( result >= 0 && v66 != 4 )
  {
    sub_10043BE0(v81[result], v89, v86);
    if ( !memcmp(v86, &unk_1009F0A4, 3u) && 0.0 != v82 )
    {
      v42 = &v88;
      do
        v43 = (v42++)[1];
      while ( v43 );
      *(_DWORD *)v42 = 5647136;
      v44 = &v85;
      do
        v45 = (v44++)[1];
      while ( v45 );
      *(_DWORD *)v44 = 5647136;
    }
    if ( (signed int)(strlen(v89) + strlen(v22) + 2) > 25 )
    {
      if ( (signed int)(strlen(v86) + strlen(v22) + 2) > 25 )
      {
        v51 = strlen(v22);
        v52 = 23 - v51;
        if ( (signed int)(23 - v51) <= 0 )
        {
          v53 = 0;
        }
        else
        {
          v53 = 23 - v51;
          if ( v52 >= 15 )
            v53 = 15;
        }
        v86[v53] = 0;
      }
      v54 = v22 - 1;
      do
        v55 = (v54++)[1];
      while ( v55 );
      *(_WORD *)v54 = 32;
      result = strlen(v86) + 1;
      v48 = v86;
      v49 = v22 - 1;
      do
        v56 = (v49++)[1];
      while ( v56 );
    }
    else
    {
      v46 = v22 - 1;
      do
        v47 = (v46++)[1];
      while ( v47 );
      *(_WORD *)v46 = 32;
      result = strlen(v89) + 1;
      v48 = v89;
      v49 = v22 - 1;
      do
        v50 = (v49++)[1];
      while ( v50 );
    }
LABEL_118:
    qmemcpy(v49, v48, result);
  }
  return result;
}
// 10012480: using guessed type char var_57[31];

//----- (10012C90) --------------------------------------------------------
int __cdecl sub_10012C90(int a1, int a2, int a3)
{
  return sub_10012480(a1, a2, a3, 0.0);
}

//----- (10012CB0) --------------------------------------------------------
char __cdecl sub_10012CB0(char a1, _BYTE *a2)
{
  char (__cdecl *v2)(int, void *); // esi@2
  float *v3; // edi@2
  float *v4; // ebp@2
  char v5; // bl@4
  double v6; // st7@7
  double v7; // st6@7
  char result; // al@9
  double v9; // st7@12
  int v10; // eax@12
  float v11; // [sp+20h] [bp-64h]@11
  _BYTE *v12; // [sp+24h] [bp-60h]@1
  float v13; // [sp+28h] [bp-5Ch]@5
  int v14; // [sp+2Ch] [bp-58h]@6
  float v15; // [sp+30h] [bp-54h]@12
  float v16; // [sp+34h] [bp-50h]@4
  char v17; // [sp+38h] [bp-4Ch]@1
  float v18; // [sp+54h] [bp-30h]@12
  float v19; // [sp+5Ch] [bp-28h]@6

  v12 = a2;
  sub_1003F840(512, &v17);
  if ( a1 )
  {
    v2 = sub_10045590;
    v3 = (float *)&unk_1022C798;
    v4 = (float *)&unk_1022C79C;
  }
  else
  {
    v2 = sub_100455E0;
    v3 = (float *)&unk_1022C7A0;
    v4 = (float *)&unk_1022C7A4;
  }
  v5 = v2(1, &v16);
  if ( v5
    && (*v3 = sub_100454B0(v16, *v3, 40, 0.001), (v5 = v2(7, &v13)) != 0)
    && (sub_10045440(*(float *)(dword_10337080 + 23308), v13, (int)&v14), v5 = 0, v19 > (double)*(float *)&v14) )
  {
    v6 = *v3;
    v7 = *(float *)(dword_10337080 + 23316) + *(float *)(dword_10337080 + 23308);
  }
  else
  {
    if ( !v2(0, &v11) )
      return v5;
    v11 = v11 * 1.943844437599182;
    v15 = sub_100454B0(v11, *v4, 40, 1.0);
    v9 = v15;
    v10 = dword_10337080;
    *v4 = v15;
    v6 = v9 * 0.5144444444444445;
    v7 = *(float *)(v10 + 23320) + v18;
  }
  if ( v7 > v6 )
  {
    result = 1;
    *v12 = 0;
  }
  else
  {
    result = 1;
    *v12 = 1;
  }
  return result;
}
// 10337080: using guessed type int dword_10337080;

//----- (10012E60) --------------------------------------------------------
char __cdecl sub_10012E60(int a1, int a2)
{
  char v2; // bl@12
  char v3; // al@13
  int v4; // eax@23
  char v6; // [sp+9h] [bp-5Fh]@1
  char v7; // [sp+Ah] [bp-5Eh]@1
  char v8; // [sp+Bh] [bp-5Dh]@8
  int v9; // [sp+Ch] [bp-5Ch]@1
  float v10; // [sp+10h] [bp-58h]@5
  float v11; // [sp+14h] [bp-54h]@5
  float v12; // [sp+18h] [bp-50h]@1
  char v13; // [sp+1Ch] [bp-4Ch]@7

  v12 = 0.0;
  v7 = 0;
  v6 = 0;
  LOBYTE(v9) = sub_10045A40(&v12);
  if ( (_BYTE)v9 == 1 )
  {
    if ( (unsigned __int16)a1 == 119 )
    {
      sub_1007C430(6205, (int)&v10, 4);
      sub_1007C430(6206, (int)&v11, 4);
      goto LABEL_19;
    }
    if ( (unsigned __int16)a1 == 125 )
    {
      if ( 9.8999998e24 != *(float *)(dword_10337080 + 23308) && sub_1003F840(512, &v13) )
      {
        if ( sub_100457A0(140, &v8) && v8 )
        {
          LOBYTE(v9) = 1;
LABEL_11:
          v6 = 1;
          goto LABEL_23;
        }
        v2 = sub_10012CB0(0, &v6);
        LOBYTE(v9) = v2;
        if ( v6 )
          goto LABEL_23;
        v3 = sub_10012CB0(1, &v6);
        if ( v2 || v3 )
        {
          LOBYTE(v9) = 1;
          goto LABEL_23;
        }
      }
      else
      {
        sub_10042930("..\\lib\\adl\\iop_air_data.c", 249, 0, 0);
      }
      LOBYTE(v9) = 0;
      goto LABEL_23;
    }
    if ( (unsigned __int16)a1 == 126 )
    {
      v10 = 66.877785;
      v11 = 69.450005;
LABEL_19:
      if ( sub_10023DA0(a1, a2, &v7) != 1 )
        v7 = 0;
      if ( v10 > (double)v12 )
      {
        v6 = 1;
        goto LABEL_23;
      }
      if ( v7 != 1 )
        goto LABEL_23;
      if ( v11 < (double)v12 )
      {
        v6 = 0;
        goto LABEL_23;
      }
      goto LABEL_11;
    }
  }
LABEL_23:
  v4 = sub_1007C040();
  return sub_10023190(a1, v9, a2, &v6, v4);
}
// 10337080: using guessed type int dword_10337080;

//----- (10013030) --------------------------------------------------------
void sub_10013030()
{
  byte_1022C7A8 = 0;
}
// 1022C7A8: using guessed type char byte_1022C7A8;

//----- (10013040) --------------------------------------------------------
char __thiscall sub_10013040(void *this)
{
  int v1; // eax@1
  void *v2; // ecx@1
  int v3; // ecx@2
  char v5; // [sp+3h] [bp-5h]@1
  char v6; // [sp+4h] [bp-4h]@6

  v5 = 0;
  byte_1022C7A9 = 0;
  byte_1022C7A8 = 0;
  byte_1022C7AA = 0;
  v1 = sub_100429D0(this);
  if ( v1 == 4 && (LOBYTE(v1) = sub_100460C0(v2), (_BYTE)v1 != 2) && (LOBYTE(v1) = sub_100426B0(v3), (_BYTE)v1) )
  {
    byte_1022C7A8 = 1;
    sub_1007C4E0(6786, (int)&byte_1022CD48, 64);
    sub_1007C3B0(6795, (int)&v5, 1);
    sub_1007C4E0(6794, (int)&unk_1022CD88, 64);
    if ( !v5 )
      sub_100106E0((int)&unk_1022CD94, byte_1022CD48, &unk_1022CD4C, &unk_1022CD50, dword_1022CD5C);
    sub_1007C4E0(6790, (int)&v6, 2);
    sub_1002ED60();
    sub_10010670(&unk_1022CD94);
    sub_10005E70((int)&v6);
    LOBYTE(v1) = sub_1000EE90((__int16 *)&v6);
    byte_1022C7AA = 1;
  }
  else
  {
    byte_1022C7A8 = 0;
  }
  return v1;
}
// 10010670: using guessed type _DWORD __cdecl sub_10010670(_DWORD);
// 1022C7A8: using guessed type char byte_1022C7A8;
// 1022C7A9: using guessed type char byte_1022C7A9;
// 1022C7AA: using guessed type char byte_1022C7AA;
// 1022CD48: using guessed type char byte_1022CD48;
// 1022CD5C: using guessed type int dword_1022CD5C;

//----- (10013140) --------------------------------------------------------
int __cdecl sub_10013140(int a1, int a2)
{
  void *v2; // ecx@0
  int result; // eax@1
  unsigned int v4; // esi@2
  unsigned __int16 v5; // [sp+0h] [bp-Ch]@3
  void *v6; // [sp+4h] [bp-8h]@3
  char v7; // [sp+8h] [bp-4h]@3

  result = sub_100429D0(v2);
  if ( result == 4 )
  {
    v4 = *(_DWORD *)dword_10333D68 % 0xAu;
    result = sub_1007C110(80, 1000);
    if ( !result )
    {
      sub_100223D0(&v6, &v5, &v7, a1, a2);
      memcpy((void *)(258 * v4 + dword_10333D68 + 4), v6, v5);
      *(_WORD *)(dword_10333D68 + 2 * v4 + 2584) = v5;
      ++*(_DWORD *)dword_10333D68;
      result = sub_1007C0F0(80);
    }
  }
  return result;
}
// 10333D68: using guessed type int dword_10333D68;

//----- (100131F0) --------------------------------------------------------
void __usercall sub_100131F0(int a1@<edi>)
{
  char v1; // [sp+3h] [bp-51h]@1
  char v2; // [sp+4h] [bp-50h]@1

  memset(&v2, 0, 0x4Cu);
  v1 = 0;
  if ( byte_1022C7A8 )
  {
    sub_10010680();
    sub_10005E80();
    sub_1000EEF0(a1);
    if ( !sub_1007C3B0(41116, (int)&v1, 1) && v1 && sub_10042610(&v2) && v2 != 1 && v2 != 2 && v2 != 4 )
    {
      v1 = 0;
      sub_1007C500(41116, (int)&v1, 1);
      sub_10046330(0);
    }
  }
}
// 10010680: using guessed type int sub_10010680(void);
// 1022C7A8: using guessed type char byte_1022C7A8;

//----- (100132A0) --------------------------------------------------------
void sub_100132A0()
{
  char v0; // [sp+0h] [bp-50h]@2
  char v1; // [sp+30h] [bp-20h]@3

  if ( byte_1022C7A8 )
  {
    if ( sub_10042610(&v0) )
    {
      if ( v1 == 4 || v1 == 6 )
        sub_10043480(0xE0u);
      else
        sub_10043370(224);
      if ( v0 == 3 )
        sub_10043480(0xE1u);
      else
        sub_10043370(225);
    }
    else
    {
      sub_10043370(224);
      sub_10043370(225);
    }
  }
}
// 1022C7A8: using guessed type char byte_1022C7A8;

//----- (10013350) --------------------------------------------------------
char __cdecl sub_10013350(int a1, int a2)
{
  char result; // al@2
  char v3; // [sp+0h] [bp-40h]@1
  unsigned int v4; // [sp+4h] [bp-3Ch]@7

  if ( sub_10022450(a1, a2, &v3, 0x3Cu) )
  {
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        result = sub_10005C40();
      }
      else if ( v3 == 2 )
      {
        result = sub_1000C4B0(v4);
      }
      else
      {
        result = sub_10042930("..\\lib\\adl\\iop_atn.c", 439, 0, 0);
      }
    }
    else
    {
      result = sub_10005B20(&v4);
    }
  }
  else
  {
    result = sub_10042930("..\\lib\\adl\\iop_atn.c", 416, 0, 0);
  }
  return result;
}

//----- (10013430) --------------------------------------------------------
void sub_10013430()
{
  if ( byte_1022C7A8 )
  {
    if ( !byte_1022C7A9 && sub_10043620(3u, 1u) )
    {
      byte_1022C7A9 = 1;
      sub_10005A60();
    }
    if ( byte_1022C7A9 )
    {
      if ( sub_10043620(3u, 0) )
        byte_1022C7A9 = 0;
    }
  }
}
// 1022C7A8: using guessed type char byte_1022C7A8;
// 1022C7A9: using guessed type char byte_1022C7A9;

//----- (10013490) --------------------------------------------------------
void __cdecl sub_10013490(int a1, int a2)
{
  int v2; // ecx@0
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v2;
  if ( sub_10022690(a1, a2, &unk_1022C7B0, (unsigned __int16 *)&v3, 0x594u) )
    sub_10012350((int)&unk_1022C7B0, (unsigned __int16)v3);
  else
    sub_10042930("..\\lib\\adl\\iop_atn.c", 541, 0, 0);
}

//----- (10013500) --------------------------------------------------------
char __cdecl sub_10013500(int a1, int a2)
{
  char v2; // ST1C_1@1
  int v3; // eax@1
  char v5; // [sp+8h] [bp-50h]@1

  v2 = sub_10005A90((int)&v5);
  v3 = sub_1007C040();
  return sub_10023190(a1, v2, a2, &v5, v3);
}

//----- (10013550) --------------------------------------------------------
char __cdecl sub_10013550(int a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1007C040();
  return sub_10023190(a1, byte_1022C7AA, a2, &unk_1022CD88, v2);
}
// 1022C7AA: using guessed type char byte_1022C7AA;

//----- (10013580) --------------------------------------------------------
char __cdecl sub_10013580(int a1, int a2)
{
  int v2; // eax@1
  int v4; // [sp+0h] [bp-28h]@1
  int v5; // [sp+4h] [bp-24h]@1
  int v6; // [sp+8h] [bp-20h]@1
  int v7; // [sp+Ch] [bp-1Ch]@1
  int v8; // [sp+10h] [bp-18h]@1
  int v9; // [sp+14h] [bp-14h]@1
  int v10; // [sp+18h] [bp-10h]@1
  int v11; // [sp+1Ch] [bp-Ch]@1
  int v12; // [sp+20h] [bp-8h]@1
  int v13; // [sp+24h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  BYTE1(v4) = 2;
  v6 = 0x200000;
  v7 = 15728640;
  v8 = 0x100000;
  v9 = 15728640;
  v2 = sub_1007C040();
  return sub_10023190(a1, 1, a2, &v4, v2);
}

//----- (100135F0) --------------------------------------------------------
char __cdecl sub_100135F0(int a1, int a2)
{
  int v2; // esi@1
  int v3; // eax@2
  signed __int16 v4; // di@3
  char v5; // bl@3
  int v6; // eax@6
  bool v7; // zf@6
  int v9; // [sp+Ch] [bp-4h]@3
  char v10; // [sp+14h] [bp+4h]@3

  v2 = a1;
  if ( (unsigned __int16)a1 == 554 )
  {
    v4 = 105;
    v5 = 0;
    v10 = 1;
    sub_10043370(107);
    LOBYTE(v3) = sub_10023DA0(v2, a2, &v9);
  }
  else
  {
    LOBYTE(v3) = a1 - 47;
    if ( (unsigned __int16)a1 != 559 )
      return v3;
    v4 = 106;
    v5 = 1;
    v10 = 0;
    sub_10043370(108);
    LOBYTE(v3) = sub_10023DA0(v2, a2, &v9);
  }
  if ( (_BYTE)v3 )
  {
    v6 = (unsigned __int8)v5;
    v7 = (v9 & 0x2603) == 0;
    LOWORD(dword_1022CDD0[v6]) = v9;
    BYTE2(dword_1022CDD0[v6]) = 0;
    if ( v7 )
      sub_10043370(v4);
    else
      sub_10043480(v4);
    if ( !(v9 & 4) || BYTE2(dword_1022CDD0[(unsigned __int8)v10]) )
    {
      v3 = 4 * (unsigned __int8)v10;
      if ( !(*((_BYTE *)dword_1022CDD0 + v3) & 4) || *((_BYTE *)&dword_1022CDD0[0] + v3 + 2) )
        LOBYTE(v3) = sub_10043370(109);
    }
    else
    {
      LOBYTE(v3) = sub_10043480(0x6Du);
    }
  }
  return v3;
}
// 1022CDD0: using guessed type int dword_1022CDD0[];

//----- (100136E0) --------------------------------------------------------
int sub_100136E0()
{
  int result; // eax@1

  result = 0;
  byte_1022CDE0 = 0;
  dword_1022CDD0[0] = 0;
  dword_1022CDD4 = 0;
  dword_1022CDD8[0] = 0;
  dword_1022CDDC = 0;
  dword_1022CDC8[0] = 0;
  dword_1022CDCC = 0;
  return result;
}
// 1022CDC8: using guessed type int dword_1022CDC8[];
// 1022CDCC: using guessed type int dword_1022CDCC;
// 1022CDD0: using guessed type int dword_1022CDD0[];
// 1022CDD4: using guessed type int dword_1022CDD4;
// 1022CDD8: using guessed type int dword_1022CDD8[];
// 1022CDDC: using guessed type int dword_1022CDDC;
// 1022CDE0: using guessed type char byte_1022CDE0;

//----- (10013710) --------------------------------------------------------
char __cdecl sub_10013710(__int16 a1)
{
  char result; // al@2

  if ( a1 == 554 )
  {
    BYTE2(dword_1022CDD0[0]) = 1;
    sub_10043370(105);
    sub_10043370(109);
    result = sub_100432C0(103);
    if ( !result )
      result = sub_10043480(0x6Bu);
  }
  else
  {
    result = a1 - 47;
    if ( a1 == 559 )
    {
      BYTE2(dword_1022CDD4) = 1;
      sub_10043370(106);
      sub_10043370(109);
      result = sub_100432C0(104);
      if ( !result )
        result = sub_10043480(0x6Cu);
    }
  }
  return result;
}
// 1022CDD0: using guessed type int dword_1022CDD0[];
// 1022CDD4: using guessed type int dword_1022CDD4;

//----- (10013780) --------------------------------------------------------
char __cdecl sub_10013780(int a1, int a2)
{
  int v2; // esi@1
  int v3; // eax@6
  int v5; // [sp+4h] [bp-8h]@1
  __int16 v6; // [sp+8h] [bp-4h]@1
  char v7; // [sp+10h] [bp+4h]@3
  char v8; // [sp+10h] [bp+4h]@6

  v2 = a1;
  v5 = 0;
  v6 = 0;
  if ( (unsigned __int16)a1 == 553 )
  {
    v7 = 0;
  }
  else if ( (unsigned __int16)a1 == 558 )
  {
    v7 = 1;
  }
  else
  {
    v7 = 2;
  }
  v8 = sub_1002D3A0(v7, (signed __int16 *)&v5);
  v3 = sub_1007C040();
  return sub_10023190(v2, v8, a2, &v5, v3);
}

//----- (100137F0) --------------------------------------------------------
char sub_100137F0()
{
  unsigned int v0; // edi@1
  int v1; // ebp@1
  char *v2; // esi@1
  char result; // al@2
  char v4; // bl@3
  char v5; // [sp+13h] [bp-59h]@12
  int v6; // [sp+14h] [bp-58h]@1
  int v7; // [sp+18h] [bp-54h]@3
  char v8; // [sp+1Ch] [bp-50h]@1
  char v9; // [sp+1Dh] [bp-4Fh]@1
  char v10; // [sp+1Eh] [bp-4Eh]@1
  __int16 v11; // [sp+20h] [bp-4Ch]@1
  char v12; // [sp+22h] [bp-4Ah]@1
  char v13; // [sp+23h] [bp-49h]@1
  char v14; // [sp+24h] [bp-48h]@1
  __int16 v15; // [sp+26h] [bp-46h]@1
  int v16; // [sp+28h] [bp-44h]@1

  v0 = 0;
  v8 = 0;
  v9 = 8;
  v10 = 8;
  v11 = 103;
  v12 = 1;
  v13 = 9;
  v14 = 15;
  v15 = 104;
  v6 = 0;
  memset(&v16, 0, 0x44u);
  v1 = sub_1007C040();
  v2 = &v8;
  do
  {
    result = sub_100471C0(v2[2]);
    if ( !result )
      goto LABEL_6;
    v4 = *v2;
    result = sub_10046780((unsigned __int8)*v2, &v7);
    if ( result )
    {
      result = sub_10046560(v4, (int)&v16);
      if ( v16 != v7 )
      {
        sub_10043480(*((_WORD *)v2 + 2));
        result = sub_1003DF00(v2[1], 0);
      }
LABEL_6:
      ++v6;
      goto LABEL_7;
    }
    if ( (unsigned int)(v1 - dword_1022CDD8[v0]) > 0x64 )
    {
      dword_1022CDD8[v0] = v1;
      result = sub_1003DE70(&v5);
      if ( !result || !v5 )
        result = sub_1003DED0(v2[1], 17, 0);
    }
LABEL_7:
    ++v0;
    v2 += 6;
  }
  while ( v0 < 2 );
  if ( v6 == 2 )
    byte_1022CDE0 = 1;
  return result;
}
// 1022CDD8: using guessed type int dword_1022CDD8[];
// 1022CDE0: using guessed type char byte_1022CDE0;

//----- (10013900) --------------------------------------------------------
char __cdecl sub_10013900(int a1, int a2)
{
  bool v2; // bl@1
  void *v3; // ecx@1
  char result; // al@5
  void *v5; // [sp+4h] [bp-4h]@1

  v5 = 0;
  v2 = (_WORD)a1 == 557;
  if ( sub_10023DA0(a1, a2, &v5) )
  {
    if ( (_BYTE)v5 != LOBYTE(dword_1022CDC8[v2]) )
      sub_10025570(1);
    v3 = v5;
    dword_1022CDC8[v2] = (int)v5;
  }
  result = sub_100474F0(v3);
  if ( result )
  {
    if ( !byte_1022CDE0 )
      result = sub_100137F0();
  }
  return result;
}
// 1022CDC8: using guessed type int dword_1022CDC8[];
// 1022CDE0: using guessed type char byte_1022CDE0;

//----- (10013970) --------------------------------------------------------
char __cdecl sub_10013970(int a1, int a2)
{
  char result; // al@5
  char v3; // al@6
  int v4; // [sp+8h] [bp-18h]@17
  char v5; // [sp+Ch] [bp-14h]@17
  char v6; // [sp+10h] [bp-10h]@17
  __int16 v7; // [sp+14h] [bp-Ch]@1
  char v8; // [sp+18h] [bp-8h]@16

  LOBYTE(v7) = 0;
  if ( (signed int)(unsigned __int16)a1 > 1732 )
  {
    if ( (unsigned __int16)a1 == 1733 )
    {
      v3 = 4;
    }
    else if ( (unsigned __int16)a1 == 2279 )
    {
      v3 = 5;
    }
    else
    {
      result = a1 + 24;
      if ( (unsigned __int16)a1 != 2280 )
        return result;
      v3 = 6;
    }
  }
  else
  {
    switch ( (unsigned __int16)a1 )
    {
      case 0x6C4u:
        v3 = 3;
        break;
      case 0xF6u:
        v3 = 1;
        break;
      case 0xF7u:
        v3 = 0;
        break;
      default:
        result = a1 + 8;
        if ( (unsigned __int16)a1 != 248 )
          return result;
        v3 = 2;
        break;
    }
  }
  v8 = v3;
  v7 = -32744;
  result = sub_100477A0((int)&v7);
  if ( !dword_1022CE04 )
  {
    result = sub_100223D0(&v4, &v5, &v6, a1, a2);
    if ( result )
    {
      result = v4;
      if ( !*(_BYTE *)(v4 + 722) )
      {
        sub_10042B50(&dword_1022CE04, *(_DWORD *)(v4 + 908));
        result = sub_1007C500(9191, (int)&dword_1022CE04, 4);
      }
    }
  }
  return result;
}
// 1022CE04: using guessed type int dword_1022CE04;

//----- (10013A60) --------------------------------------------------------
void __cdecl sub_10013A60(int a1, int a2)
{
  float v2; // ecx@0
  int v3; // ecx@2
  float v4; // [sp+0h] [bp-4h]@1

  v4 = v2;
  if ( sub_10023DA0(a1, a2, &v4) )
  {
    v3 = sub_1007C040();
    if ( byte_1022CDFA )
    {
      if ( byte_1022CDFA != 1 )
        return;
      if ( v4 < 11.0 )
      {
        byte_1022CDFA = 0;
        return;
      }
    }
    else
    {
      if ( v4 <= 13.0 )
        return;
      byte_1022CDFA = 1;
    }
    if ( (unsigned int)(v3 - dword_1022CE34) > 0xBB8 )
    {
      dword_1022CE34 = v3;
      sub_10043590(6u);
    }
  }
}
// 1022CDFA: using guessed type char byte_1022CDFA;
// 1022CE34: using guessed type int dword_1022CE34;

//----- (10013AE0) --------------------------------------------------------
char __cdecl sub_10013AE0(int a1, int a2)
{
  char result; // al@2
  char *v3; // esi@3

  if ( (unsigned __int16)a1 == 311 )
  {
    v3 = &byte_1022CE2A;
  }
  else
  {
    result = a1 - 56;
    if ( (unsigned __int16)a1 != 312 )
      return result;
    v3 = &byte_1022CE11;
  }
  result = sub_10023DA0(a1, a2, &a1);
  if ( result )
  {
    if ( *v3 == 1 && (_BYTE)a1 == 1 && sub_1002BE00(1) )
    {
      sub_1002C5C0();
      if ( !sub_1002A930() )
        sub_1003F600(0, 0);
    }
    result = (_BYTE)a1 == 0;
    *v3 = (_BYTE)a1 == 0;
  }
  else
  {
    *v3 = 0;
  }
  return result;
}
// 1022CE11: using guessed type char byte_1022CE11;
// 1022CE2A: using guessed type char byte_1022CE2A;

//----- (10013B60) --------------------------------------------------------
char __cdecl sub_10013B60(int a1, int a2)
{
  char result; // al@1
  signed int v3; // edi@2
  unsigned int v4; // esi@2
  int v5; // edi@7
  int v6; // ebx@7
  int v7; // edi@14
  int v8; // ebx@14
  char v9; // [sp+0h] [bp-100h]@0
  char v10; // [sp+0h] [bp-100h]@7
  char v11; // [sp+4h] [bp-FCh]@0
  char v12; // [sp+8h] [bp-F8h]@14
  char v13; // [sp+Ch] [bp-F4h]@0
  char v14; // [sp+10h] [bp-F0h]@2
  unsigned int v15; // [sp+14h] [bp-ECh]@2
  char v16; // [sp+90h] [bp-70h]@3
  unsigned __int8 v17; // [sp+97h] [bp-69h]@6
  char v18; // [sp+98h] [bp-68h]@19
  unsigned __int8 v19; // [sp+99h] [bp-67h]@13
  char v20; // [sp+9Ch] [bp-64h]@8
  char v21; // [sp+A8h] [bp-58h]@1
  char v22; // [sp+AFh] [bp-51h]@3
  char v23; // [sp+C8h] [bp-38h]@15
  char v24; // [sp+E1h] [bp-1Fh]@8

  result = sub_10023DA0(a1, a2, &v21);
  if ( !result )
    return result;
  sub_1002E680(0, &v21, (int)&v15, (signed int *)&v14);
  v3 = (unsigned __int8)sub_100313B0(v15);
  v4 = 0;
  if ( v3 <= 0 )
  {
LABEL_5:
    LOBYTE(v4) = v9;
  }
  else
  {
    while ( 1 )
    {
      sub_10031240(v15, v4, (int)&v16);
      if ( !strncmp(&v22, &v16, 0x19u) )
        break;
      if ( (signed int)++v4 >= v3 )
        goto LABEL_5;
    }
  }
  if ( v17 )
  {
    v5 = v17;
    v6 = 0;
    v10 = 0;
    if ( (signed int)v17 > 0 )
    {
      while ( 1 )
      {
        sub_100312A0(v15, v4, 0, v6, (int)&v20);
        if ( !strncmp(&v24, &v20, 0x19u) )
          break;
        if ( ++v6 >= v5 )
          goto LABEL_13;
      }
      v13 = v6;
    }
  }
  else
  {
    v10 = 1;
    v13 = 0;
  }
LABEL_13:
  if ( !v19 )
  {
    if ( v18 )
      return sub_10030260(0, v15, v4, 1, 0, v10, v13);
    v12 = 0;
    v11 = v13;
    return sub_10030260(0, v15, v4, v12, v11, v10, v13);
  }
  v7 = v19;
  v8 = 0;
  v12 = 2;
  if ( (signed int)v19 <= 0 )
    return sub_10030260(0, v15, v4, v12, v11, v10, v13);
  while ( 1 )
  {
    sub_100312A0(v15, v4, 2, v8, (int)&v20);
    if ( !strncmp(&v23, &v20, 0x19u) )
      break;
    if ( ++v8 >= v7 )
      return sub_10030260(0, v15, v4, v12, v11, v10, v13);
  }
  return sub_10030260(0, v15, v4, 2, v8, v10, v13);
}

//----- (10013D50) --------------------------------------------------------
char __cdecl sub_10013D50(int a1, int a2)
{
  char result; // al@1
  int v3; // eax@2
  int v4; // [sp+10h] [bp-90h]@2
  int v5[31]; // [sp+14h] [bp-8Ch]@2
  char v6; // [sp+90h] [bp-10h]@1
  int v7; // [sp+98h] [bp-8h]@2

  result = sub_10023DA0(a1, a2, &v6);
  if ( result )
  {
    sub_1002E590(&v6, (int)v5, &v4);
    sub_10037E30(v4, (char *)v5);
    v3 = v4 - 1;
    if ( v7 < v4 - 1 )
      v3 = v7;
    v7 = v3 <= 0 ? 0 : v3;
    result = sub_10037A50(v5[v7], 255, 0.0, 0, 0, 0.0);
  }
  return result;
}
// 10013D50: using guessed type int var_8C[31];

//----- (10013E10) --------------------------------------------------------
char __cdecl sub_10013E10(int a1, int a2)
{
  char result; // al@1
  signed int v3; // edi@2
  unsigned int v4; // esi@2
  char v5; // bp@5
  int v6; // esi@7
  int v7; // ebx@7
  signed int v8; // edi@10
  int v9; // esi@12
  int v10; // ebx@12
  int v11; // ebp@17
  int v12; // esi@18
  bool v13; // cf@23
  bool v14; // zf@23
  char v15; // [sp+0h] [bp-108h]@12
  char v16; // [sp+0h] [bp-108h]@17
  char v17; // [sp+4h] [bp-104h]@0
  signed int v18; // [sp+8h] [bp-100h]@0
  char v19; // [sp+Ch] [bp-FCh]@7
  char v20; // [sp+10h] [bp-F8h]@2
  unsigned int v21; // [sp+14h] [bp-F4h]@2
  char v22; // [sp+90h] [bp-78h]@3
  unsigned __int8 v23; // [sp+97h] [bp-71h]@6
  char v24; // [sp+98h] [bp-70h]@27
  unsigned __int8 v25; // [sp+99h] [bp-6Fh]@11
  char v26; // [sp+9Ch] [bp-6Ch]@8
  char v27; // [sp+A8h] [bp-60h]@1
  char v28; // [sp+AFh] [bp-59h]@3
  char v29; // [sp+C8h] [bp-40h]@8
  char v30; // [sp+E1h] [bp-27h]@13
  char v31; // [sp+FCh] [bp-Ch]@19

  result = sub_10023DA0(a1, a2, &v27);
  if ( !result )
    return result;
  sub_1002E680(0, &v27, (int)&v21, (signed int *)&v20);
  v3 = (unsigned __int8)sub_10031310(v21);
  v4 = 0;
  if ( v3 <= 0 )
  {
LABEL_5:
    v5 = v17;
  }
  else
  {
    while ( 1 )
    {
      sub_10032620(v21, v4, (int)&v22);
      if ( !strncmp(&v28, &v22, 0x19u) )
        break;
      if ( (signed int)++v4 >= v3 )
        goto LABEL_5;
    }
    v5 = v4;
    v17 = v4;
  }
  sub_10032620(v21, v5, (int)&v22);
  if ( v23 )
  {
    v6 = v23;
    v7 = 0;
    v19 = 0;
    if ( (signed int)v23 <= 0 )
    {
LABEL_10:
      v8 = v18;
    }
    else
    {
      while ( 1 )
      {
        sub_10032680(v21, v5, 0, v7, (int)&v26);
        if ( !strncmp(&v29, &v26, 0x19u) )
          break;
        if ( ++v7 >= v6 )
          goto LABEL_10;
      }
      LOBYTE(v18) = v7;
      v8 = v18;
      v11 = sub_100370D0(v21);
      v16 = 0;
      do
      {
        v12 = 0;
        if ( v11 > 0 )
        {
          while ( 1 )
          {
            v8 = sub_10036B20(v21, v12, v16);
            sub_1002E890(v8, (int)&v31);
            if ( !strncmp(&v31, &v26, 0x19u) )
              break;
            if ( ++v12 >= v11 )
              goto LABEL_23;
          }
          v16 = 2;
        }
LABEL_23:
        v13 = (unsigned __int8)v16 >= 0xFFu;
        v14 = v16++ == 0;
      }
      while ( v13 || v14 );
      v5 = v17;
    }
  }
  else
  {
    v19 = 1;
    LOBYTE(v18) = 0;
    v8 = 0x3FFFF;
  }
  if ( !v25 )
  {
    if ( v24 )
      return sub_10030060(0, v21, v5, v19, v18, v8, 1, 0);
    v15 = 0;
    v17 = v18;
    return sub_10030060(0, v21, v5, v19, v18, v8, v15, v17);
  }
  v9 = v25;
  v10 = 0;
  v15 = 2;
  if ( (signed int)v25 <= 0 )
    return sub_10030060(0, v21, v5, v19, v18, v8, v15, v17);
  while ( 1 )
  {
    sub_10032680(v21, v5, 2, v10, (int)&v26);
    if ( !strncmp(&v30, &v26, 0x19u) )
      break;
    if ( ++v10 >= v9 )
      return sub_10030060(0, v21, v5, v19, v18, v8, v15, v17);
  }
  return sub_10030060(0, v21, v5, v19, v18, v8, 2, v10);
}

//----- (100140B0) --------------------------------------------------------
char __cdecl sub_100140B0(int a1, int a2)
{
  char result; // al@1
  int v3; // eax@3
  int v4; // eax@5
  char v5; // al@11
  char v6; // [sp+3h] [bp-9Dh]@8
  _BYTE v7[5]; // [sp+7h] [bp-99h]@2
  int v8; // [sp+Ch] [bp-94h]@2
  int v9[31]; // [sp+10h] [bp-90h]@2
  int v10; // [sp+8Ch] [bp-14h]@1
  int v11; // [sp+94h] [bp-Ch]@5
  int v12; // [sp+98h] [bp-8h]@3

  result = sub_10023DA0(a1, a2, &v10);
  if ( result )
  {
    sub_10037E70((int)&v10, (int)&v8, (int)v7, v9, (int)&v7[1]);
    result = v7[1];
    if ( *(_DWORD *)&v7[1] )
    {
      sub_10037E30(*(signed int *)&v7[1], (char *)v9);
      v3 = *(_DWORD *)&v7[1] - 1;
      if ( v12 < *(_DWORD *)&v7[1] - 1 )
        v3 = v12;
      v12 = v3 <= 0 ? 0 : v3;
      v4 = (unsigned __int8)sub_10035530(0);
      if ( v11 < (unsigned __int8)v4 )
        v4 = v11;
      v11 = v4 <= 0 ? 0 : v4;
      if ( v11 >= (unsigned __int8)sub_10035530(0) )
      {
        if ( v11 > 0 )
        {
          v5 = sub_10035530(0);
          v6 = sub_10034A30(0, v5 - 1);
          if ( v6 != 2 )
            return sub_1002FF60(0, v11, v9[v12], v6);
        }
      }
      else
      {
        v6 = sub_10034A30(0, v11);
        if ( sub_10034990(0, v11) == 0x3FFFF )
          return sub_1002FF60(0, v11, v9[v12], v6);
      }
      v6 = 0;
      return sub_1002FF60(0, v11, v9[v12], v6);
    }
  }
  return result;
}
// 100140B0: using guessed type int var_90[31];

//----- (10014220) --------------------------------------------------------
char __cdecl sub_10014220(int a1, int a2)
{
  char result; // al@1
  char v3; // [sp+3h] [bp-65h]@2
  char v4; // [sp+4h] [bp-64h]@2
  char v5; // [sp+8h] [bp-60h]@1
  int v6; // [sp+10h] [bp-58h]@2
  int v7; // [sp+14h] [bp-54h]@2
  int v8; // [sp+18h] [bp-50h]@2
  int v9; // [sp+1Ch] [bp-4Ch]@2
  __int16 v10; // [sp+20h] [bp-48h]@2
  int v11; // [sp+24h] [bp-44h]@2
  int v12; // [sp+28h] [bp-40h]@2
  int v13; // [sp+2Ch] [bp-3Ch]@2
  int v14; // [sp+30h] [bp-38h]@2
  char v15; // [sp+34h] [bp-34h]@2
  char v16; // [sp+3Bh] [bp-2Dh]@2
  int v17; // [sp+58h] [bp-10h]@2
  int v18; // [sp+5Ch] [bp-Ch]@2
  char v19; // [sp+60h] [bp-8h]@2

  result = sub_10023DA0(a1, a2, &v5);
  if ( result )
  {
    strncpy(&v15, &v5, 7u);
    v12 = v7;
    v11 = v6;
    v13 = v8;
    v14 = v9;
    v10 = -1;
    strncpy(&v16, &byte_100930C0, 6u);
    v17 = 0x3FFFF;
    v18 = 0x3FFFF;
    v19 = 6;
    result = sub_10038020(&v10, &v4, &v3);
  }
  return result;
}

//----- (100142D0) --------------------------------------------------------
void __cdecl sub_100142D0(int a1, int a2)
{
  float v2; // ecx@0
  int v3; // ecx@2
  float v4; // [sp+0h] [bp-4h]@1

  v4 = v2;
  if ( sub_10023DA0(a1, a2, &v4) )
  {
    v3 = sub_1007C040();
    if ( byte_1022CE13 )
    {
      if ( byte_1022CE13 != 1 )
        return;
      if ( v4 < 11.0 )
      {
        byte_1022CE13 = 0;
        return;
      }
    }
    else
    {
      if ( v4 <= 13.0 )
        return;
      byte_1022CE13 = 1;
    }
    if ( (unsigned int)(v3 - dword_1022CE14) > 0xBB8 )
    {
      dword_1022CE14 = v3;
      sub_10043590(7u);
    }
  }
}
// 1022CE13: using guessed type char byte_1022CE13;
// 1022CE14: using guessed type int dword_1022CE14;

//----- (10014350) --------------------------------------------------------
char __cdecl sub_10014350(int a1, int a2)
{
  void *v2; // ecx@0
  unsigned __int8 v3; // al@1
  int v4; // eax@1
  void *v6; // [sp+0h] [bp-4h]@1

  v6 = v2;
  BYTE2(v6) = sub_1003EB30(v2);
  BYTE1(v6) = 0;
  v3 = sub_10043FF0((void **)((char *)&v6 + 2), 1u, (int)&unk_100A031C, 4, 3, 0);
  sub_100253C0(6, (unsigned __int16)word_100A031E[2 * v3], (char *)&v6 + 1);
  BYTE3(v6) = BYTE1(v6) == 1;
  v4 = sub_1007C040();
  return sub_10023190(a1, 1, a2, (char *)&v6 + 3, v4);
}
// 100A031E: using guessed type __int16 word_100A031E[];

//----- (100143C0) --------------------------------------------------------
char __cdecl sub_100143C0(__int16 a1)
{
  char result; // al@1
  int *v2; // eax@4
  int v3; // edx@7
  int v4; // ecx@7
  char v5; // [sp-14h] [bp-24h]@4
  int v6; // [sp-10h] [bp-20h]@4
  int v7; // [sp-Ch] [bp-1Ch]@7
  int v8; // [sp-8h] [bp-18h]@7
  int v9; // [sp-4h] [bp-14h]@4
  int v10; // [sp+0h] [bp-10h]@4
  int v11; // [sp+4h] [bp-Ch]@7
  int v12; // [sp+8h] [bp-8h]@7

  result = a1 + 21;
  if ( a1 == 235 )
  {
    if ( !byte_1022CE2C )
      return result;
    sub_10047860(0, &v10);
    v9 = 0;
    v2 = &v6;
    v5 = 0;
    goto LABEL_7;
  }
  result = a1 + 12;
  if ( a1 == 244 && byte_1022CE2D )
  {
    sub_10047860(1, &v10);
    v9 = 0;
    v2 = &v6;
    v5 = 1;
LABEL_7:
    v3 = v11;
    *v2 = v10;
    v4 = v12;
    v2[1] = v3;
    v2[2] = v4;
    result = sub_10047990(v5, v6, v7, v8, v9);
  }
  return result;
}
// 1022CE2C: using guessed type char byte_1022CE2C;
// 1022CE2D: using guessed type char byte_1022CE2D;

//----- (10014450) --------------------------------------------------------
char __cdecl sub_10014450(int a1, int a2)
{
  int v2; // ecx@0
  int v3; // eax@1
  int v4; // eax@2
  int v6; // [sp-2h] [bp-4h]@1

  v6 = v2;
  v3 = sub_1007C3B0(9172, (int)&v6 + 3, 1);
  if ( !v3 )
  {
    v4 = sub_1007C040();
    LOBYTE(v3) = sub_10023190(a1, 1, a2, (char *)&v6 + 3, v4);
  }
  return v3;
}

//----- (10014490) --------------------------------------------------------
char __cdecl sub_10014490(int a1, int a2)
{
  int v2; // eax@1
  bool v4; // [sp+3h] [bp-5h]@1
  int v5; // [sp+4h] [bp-4h]@1

  LOBYTE(v5) = sub_100473B0(&v4);
  v4 = v4 == 0;
  v2 = sub_1007C040();
  return sub_10023190(a1, v5, a2, &v4, v2);
}

//----- (100144D0) --------------------------------------------------------
char __cdecl sub_100144D0(float a1, int a2)
{
  int v2; // esi@1
  int v3; // eax@13
  char v5; // [sp+7h] [bp-5h]@1
  float v6; // [sp+8h] [bp-4h]@5

  v2 = LODWORD(a1);
  v5 = 0;
  if ( LOWORD(a1) == 423 )
  {
    if ( !sub_100455E0(0, &a1) )
      a1 = 0.0;
    if ( !sub_10045590(0, &v6) )
      v6 = 0.0;
    sub_100457D0(46, &v5);
    if ( a1 > 69.45 || v6 > 69.45 )
    {
      v5 = 1;
    }
    else if ( a1 < 66.87777777777778 && v6 < 66.87777777777778 )
    {
      v5 = 0;
    }
  }
  else
  {
    v5 = sub_10047520();
  }
  v3 = sub_1007C040();
  return sub_10023190(v2, 1, a2, &v5, v3);
}

//----- (100145B0) --------------------------------------------------------
char __cdecl sub_100145B0(int a1, int a2)
{
  int v2; // eax@12
  float v4; // [sp+0h] [bp-Ch]@1
  float v5; // [sp+4h] [bp-8h]@2
  int v6; // [sp+8h] [bp-4h]@3

  if ( !sub_1003D430(2u, &v4) || !sub_1003D430(0x1Eu, &v5) )
  {
    LOBYTE(v6) = 0;
    goto LABEL_11;
  }
  LOBYTE(v6) = 1;
  if ( byte_1022CE29 )
  {
    if ( byte_1022CE29 != 1 || v4 >= 2.0 && v5 >= 1800.0 )
      goto LABEL_12;
LABEL_11:
    byte_1022CE29 = 0;
    goto LABEL_12;
  }
  if ( v4 >= 2.8 && v5 >= 2000.0 )
    byte_1022CE29 = 1;
LABEL_12:
  v2 = sub_1007C040();
  return sub_10023190(a1, v6, a2, &byte_1022CE29, v2);
}
// 1022CE29: using guessed type char byte_1022CE29;

//----- (10014670) --------------------------------------------------------
char __cdecl sub_10014670(int a1, int a2)
{
  int v2; // eax@1
  char v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  LOBYTE(v5) = sub_10044BE0((float *)&v4);
  v2 = sub_1007C040();
  return sub_10023190(a1, v5, a2, &v4, v2);
}

//----- (100146B0) --------------------------------------------------------
char __cdecl sub_100146B0(int a1, int a2)
{
  int v2; // eax@1
  char v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  LOBYTE(v5) = sub_10044F60((float *)&v4);
  v2 = sub_1007C040();
  return sub_10023190(a1, v5, a2, &v4, v2);
}

//----- (100146F0) --------------------------------------------------------
char __cdecl sub_100146F0(int a1, int a2)
{
  int v2; // eax@1
  char v4; // [sp+4h] [bp-CD0h]@1

  memset(&v4, 0, 0xCCCu);
  sub_10017B20((int)&v4);
  v2 = sub_1007C040();
  return sub_10023190(a1, 1, a2, &v4, v2);
}

//----- (10014760) --------------------------------------------------------
char __cdecl sub_10014760(int a1, int a2)
{
  int v2; // ecx@0
  char v3; // al@1
  char result; // al@4
  int v5; // eax@8
  int v6; // [sp+0h] [bp-4h]@1

  v6 = v2;
  BYTE3(v6) = 0;
  v3 = sub_100473B0((bool *)&v6 + 1);
  if ( !BYTE1(v6) || (BYTE1(v6) = 1, !v3) )
    BYTE1(v6) = 0;
  result = sub_1007C470(9159, (char *)&v6 + 2, 1, (char *)&v6 + 3) == 0;
  if ( BYTE1(v6) && BYTE2(v6) )
  {
    BYTE2(v6) = 0;
    result = sub_1007C500(9159, (int)&v6 + 2, 1) == 0;
  }
  if ( result )
  {
    v5 = sub_1007C040();
    result = sub_10023190(a1, 1, a2, (char *)&v6 + 2, v5);
  }
  return result;
}

//----- (10014800) --------------------------------------------------------
char __cdecl sub_10014800(int a1, int a2)
{
  char v2; // bl@1
  char v3; // al@1
  int v4; // eax@13
  char v6; // [sp+7h] [bp-Dh]@1
  int v7; // [sp+8h] [bp-Ch]@1
  float v8; // [sp+Ch] [bp-8h]@1
  float v9; // [sp+10h] [bp-4h]@1

  v6 = 0;
  LOBYTE(v7) = 0;
  v2 = sub_1003D430(0x18u, &v8);
  v3 = sub_1003D430(0x1Eu, &v9);
  if ( v2 || v3 )
  {
    LOBYTE(v7) = 1;
    if ( v2 && v8 >= 81273.281 || v3 && v9 < 500.0 )
    {
      if ( dword_1022CE30 )
      {
        if ( dword_1022CE30 && (unsigned int)(sub_1007C040() - dword_1022CE30) >= 0xBB8 )
          v6 = 1;
      }
      else
      {
        dword_1022CE30 = sub_1007C040();
      }
    }
    else
    {
      dword_1022CE30 = 0;
    }
  }
  v4 = sub_1007C040();
  return sub_10023190(a1, v7, a2, &v6, v4);
}
// 1022CE2C: using guessed type char byte_1022CE2C;
// 1022CE30: using guessed type int dword_1022CE30;

//----- (100148D0) --------------------------------------------------------
char __cdecl sub_100148D0(int a1, int a2)
{
  int v2; // ecx@0
  int v3; // eax@7
  int v5; // [sp-2h] [bp-4h]@1

  v5 = v2;
  BYTE3(v5) = 0;
  if ( sub_10047AE0((int)"_engage_edm_1") )
  {
    BYTE3(v5) = 2;
  }
  else if ( sub_10047AE0((int)"_engage_edm_2") )
  {
    BYTE3(v5) = 3;
  }
  else if ( sub_10047AE0((int)"_engage_edm") )
  {
    BYTE3(v5) = 1;
  }
  v3 = sub_1007C040();
  return sub_10023190(a1, 1, a2, (char *)&v5 + 3, v3);
}

//----- (10014940) --------------------------------------------------------
char __cdecl sub_10014940(int a1, int a2)
{
  int v2; // eax@7
  int v3; // eax@10
  unsigned int v4; // eax@10
  int v5; // eax@11
  char v7; // [sp+Ch] [bp-4h]@1
  char v8; // [sp+Dh] [bp-3h]@1
  char v9; // [sp+Eh] [bp-2h]@1
  char v10; // [sp+Fh] [bp-1h]@1

  v7 = 0;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  if ( sub_1007C3B0(9151, (int)&v8, 1) )
    v8 = 0;
  if ( !sub_10023DA0(a1, a2, &v9) )
    v9 = 0;
  if ( v8 || v9 )
  {
    if ( (unsigned int)dword_1022CE0C <= 0 )
    {
      v3 = *(_DWORD *)(a2 + 40);
      v7 = 0;
      v4 = 0x1388u / *(_DWORD *)(52 * *(_WORD *)(v3 + 2 * (unsigned __int16)a1) + *(_DWORD *)(a2 + 32) + 12);
      v10 = 0;
      dword_1022CE0C = v4;
      sub_1007C500(9151, (int)&v10, 1);
    }
    else
    {
      --dword_1022CE0C;
      v7 = 1;
    }
  }
  else
  {
    v2 = *(_DWORD *)(a2 + 40);
    v7 = 0;
    dword_1022CE0C = 0x1388u / *(_DWORD *)(52 * *(_WORD *)(v2 + 2 * (unsigned __int16)a1) + *(_DWORD *)(a2 + 32) + 12);
  }
  v5 = sub_1007C040();
  return sub_10023190(a1, 1, a2, &v7, v5);
}
// 1022CE0C: using guessed type int dword_1022CE0C;

//----- (10014A40) --------------------------------------------------------
char __cdecl sub_10014A40(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@2
  int v5; // [sp+0h] [bp-4h]@1

  v5 = 0;
  v2 = sub_1007C3B0(9150, (int)&v5, 4);
  if ( !v2 )
  {
    v3 = sub_1007C040();
    LOBYTE(v2) = sub_10023190(a1, 1, a2, &v5, v3);
  }
  return v2;
}

//----- (10014A90) --------------------------------------------------------
char __cdecl sub_10014A90(int a1, int a2)
{
  void *v2; // ecx@1
  unsigned int v3; // eax@1
  char v4; // al@2
  __int64 v5; // ST08_8@6
  char v6; // al@6
  bool v7; // zf@6
  int v8; // eax@12
  char v10; // [sp+10h] [bp-70h]@1
  int v11; // [sp+14h] [bp-6Ch]@0
  int v12; // [sp+18h] [bp-68h]@1
  int v13; // [sp+1Ch] [bp-64h]@1
  float v14; // [sp+20h] [bp-60h]@1
  float v15; // [sp+24h] [bp-5Ch]@1
  int v16; // [sp+28h] [bp-58h]@11
  char v17; // [sp+2Ch] [bp-54h]@1
  char v18; // [sp+2Dh] [bp-53h]@9
  float v19; // [sp+40h] [bp-40h]@9
  float v20; // [sp+44h] [bp-3Ch]@10
  float v21; // [sp+4Ch] [bp-34h]@11
  float v22; // [sp+58h] [bp-28h]@11
  int v23; // [sp+68h] [bp-18h]@6

  memset(&v17, 0, 0x50u);
  v12 = 0;
  v13 = 0;
  v14 = 0.0;
  v15 = 0.0;
  v3 = (unsigned __int16)a1 - 20;
  v10 = 0;
  if ( v3 <= 1 )
  {
    v4 = sub_10048230(v2);
    if ( v4 == 1 )
    {
      LOBYTE(v11) = 3;
    }
    else
    {
      if ( v4 != 2 )
        goto LABEL_12;
      LOBYTE(v11) = 4;
    }
    sub_10047C60(v11, (int)&v17);
    LODWORD(v5) = v23;
    v6 = sub_10037F00(v5);
    v7 = v6 == 3;
    if ( v6 == 3 )
    {
LABEL_9:
      LOBYTE(v12) = v7;
      v14 = v19;
      BYTE1(v12) = v18;
      if ( v18 )
        sub_10048200((int)&v13, v20);
      v15 = v22;
      sub_10048200((int)&v16, v21);
      HIWORD(v12) = HIWORD(v16);
      v10 = sub_10047B50(3, v11, (int)&v17);
      goto LABEL_12;
    }
    if ( v6 == 8 )
    {
      v7 = 0;
      goto LABEL_9;
    }
LABEL_12:
    v8 = sub_1007C040();
    LOBYTE(v3) = sub_10023190(a1, v10, a2, &v12, v8);
  }
  return v3;
}

//----- (10014BC0) --------------------------------------------------------
char __cdecl sub_10014BC0(int a1, int a2)
{
  int v2; // ecx@0
  char v3; // bl@1
  char result; // al@3
  char v5; // al@4
  int v6; // eax@4
  int v7; // ST18_4@5
  int v8; // ecx@7
  int v9; // ecx@13
  int v10; // ecx@20
  int v11; // eax@27
  int v12; // ST18_4@31
  char v13; // [sp+Fh] [bp-2Dh]@1
  int v14; // [sp+10h] [bp-2Ch]@1
  char v15; // [sp+14h] [bp-28h]@10
  char v16; // [sp+18h] [bp-24h]@10
  char v17; // [sp+1Ch] [bp-20h]@10
  char v18; // [sp+20h] [bp-1Ch]@10
  int v19; // [sp+24h] [bp-18h]@1
  unsigned int v20; // [sp+28h] [bp-14h]@1
  int v21; // [sp+2Ch] [bp-10h]@1
  int v22; // [sp+30h] [bp-Ch]@1
  int v23; // [sp+34h] [bp-8h]@1

  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v3 = 0;
  v13 = 0;
  v14 = 0;
  if ( (unsigned __int16)a1 == 203 )
  {
    v13 = !sub_1003F480(v2) && !sub_1003EAE0()
       || (v13 = 0, sub_1003F450() == 1)
       && (unsigned __int8)sub_1003E9D0() == 1
       && sub_1002BB90((float *)&v17, (float *)&v16, (float *)&v15, (float *)&v18) == 1;
    if ( sub_1003F480(v8) == 1 && sub_10048480(3, &v19) == 1 && sub_10048450(v20) == 1
      || sub_1003F480(v9) == 2 && sub_10048480(4, &v19) == 1 && sub_10048450(v20) == 1 )
    {
      v3 = 1;
    }
    if ( !sub_1003EAE0() || sub_1003F480(v10) && !v3 )
      goto LABEL_31;
    v13 = 1;
    if ( (dword_1022CDE4 || !v3) && (sub_1003F480(v10) || !byte_1022CE12) )
    {
      if ( (unsigned int)(sub_1007C040() - dword_1022CDF0) <= 0x1388 )
      {
LABEL_31:
        byte_1022CE12 = v3;
        dword_1022CDE4 = (unsigned __int8)sub_1003F480(v10);
        v12 = sub_1007C040();
        return sub_10023190(a1, 1, a2, &v13, v12);
      }
      v13 = 0;
      v11 = sub_1007C040() - 10000;
    }
    else
    {
      v11 = sub_1007C040();
    }
    dword_1022CDF0 = v11;
    goto LABEL_31;
  }
  if ( (unsigned __int16)a1 == 204 )
  {
    v13 = sub_1002B9F0();
    v7 = sub_1007C040();
    result = sub_10023190(a1, 1, a2, &v13, v7);
  }
  else
  {
    result = a1 + 13;
    if ( (unsigned __int16)a1 == 243 )
    {
      v5 = sub_1002AD10();
      v13 = sub_100489B0(v5, &v14);
      v6 = sub_1007C040();
      result = sub_10023190(a1, 1, a2, &v13, v6);
    }
  }
  return result;
}
// 1022CDE4: using guessed type int dword_1022CDE4;
// 1022CDF0: using guessed type int dword_1022CDF0;
// 1022CE12: using guessed type char byte_1022CE12;

//----- (10014DC0) --------------------------------------------------------
char __cdecl sub_10014DC0(int a1, int a2)
{
  __int16 v2; // si@1
  int v3; // eax@3
  char v5; // [sp+7h] [bp-1h]@1

  v5 = 0;
  v2 = sub_1007C040();
  sub_100457A0(206, &v5);
  if ( !(v2 & 0x200) )
    v5 = 0;
  v3 = sub_1007C040();
  return sub_10023190(496, 1, a2, &v5, v3);
}

//----- (10014E10) --------------------------------------------------------
char __cdecl sub_10014E10(int a1, int a2)
{
  int v2; // eax@1
  float v4; // [sp+0h] [bp-4h]@1

  v4 = sub_10044500();
  v2 = sub_1007C040();
  return sub_10023190(a1, 1, a2, &v4, v2);
}

//----- (10014E40) --------------------------------------------------------
char __cdecl sub_10014E40(int a1, int a2)
{
  int v2; // eax@6
  char v4; // [sp+7h] [bp-45h]@1
  int v5; // [sp+8h] [bp-44h]@3
  char v6; // [sp+Ch] [bp-40h]@1
  char v7; // [sp+13h] [bp-39h]@4
  char v8; // [sp+17h] [bp-35h]@3

  v4 = 0;
  if ( !sub_1003F260(&v6) || (unsigned __int8)sub_1003E9D0() )
  {
    LOBYTE(v5) = 0;
  }
  else
  {
    LOBYTE(v5) = 1;
    if ( v8 == 11 || v7 == 8 )
      v4 = 1;
  }
  v2 = sub_1007C040();
  return sub_10023190(a1, v5, a2, &v4, v2);
}

//----- (10014EC0) --------------------------------------------------------
char __cdecl sub_10014EC0(int a1, int a2)
{
  int v2; // eax@4
  float v4; // [sp+0h] [bp-40h]@1
  int v5; // [sp+4h] [bp-3Ch]@1
  float v6; // [sp+8h] [bp-38h]@2
  float v7; // [sp+Ch] [bp-34h]@1
  float v8; // [sp+10h] [bp-30h]@1
  int v9; // [sp+14h] [bp-2Ch]@1
  int v10; // [sp+18h] [bp-28h]@1
  char v11; // [sp+1Ch] [bp-24h]@1
  __int16 v12; // [sp+2Ch] [bp-14h]@1

  v4 = 9.8999998e24;
  LOBYTE(v5) = 0;
  sub_100419B0(0, (int)&v11);
  sub_1007BCF0((int)&v11, (int)&v7);
  sub_10048AE0((int)&v9, v7, v8);
  sub_10079A10(v9, v10, (int)&v12);
  if ( v12 != -32767 && sub_10041BD0(&v6) )
  {
    LOBYTE(v5) = 1;
    v4 = v6 - (double)v12;
  }
  v2 = sub_1007C040();
  return sub_10023190(a1, v5, a2, &v4, v2);
}

//----- (10014F70) --------------------------------------------------------
char __cdecl sub_10014F70(int a1, int a2)
{
  int v2; // ecx@0
  int v3; // eax@1
  int v4; // eax@2
  int v6; // [sp-2h] [bp-4h]@1

  v6 = v2;
  BYTE3(v6) = 0;
  v3 = sub_1007C3B0(9884, (int)&v6 + 3, 1);
  if ( !v3 )
  {
    v4 = sub_1007C040();
    LOBYTE(v3) = sub_10023190(a1, 1, a2, (char *)&v6 + 3, v4);
  }
  return v3;
}

//----- (10014FB0) --------------------------------------------------------
char __cdecl sub_10014FB0(int a1, int a2)
{
  char result; // al@1
  int v3; // ST10_4@2
  int v4; // ecx@3
  void *v5; // ecx@3
  char v6; // al@8
  double v7; // st7@8
  int v8; // ST10_4@8
  int v9; // ST10_4@9
  int v10; // ST10_4@11
  int v11; // ST10_4@16
  int v12; // ST10_4@17
  float v13; // [sp+Ch] [bp-48h]@1
  int v14; // [sp+10h] [bp-44h]@1
  float v15; // [sp+14h] [bp-40h]@7
  double v16; // [sp+18h] [bp-3Ch]@8
  char v17; // [sp+20h] [bp-34h]@7
  char v18; // [sp+24h] [bp-30h]@7
  char v19; // [sp+28h] [bp-2Ch]@7
  char v20; // [sp+2Ch] [bp-28h]@3
  char v21; // [sp+34h] [bp-20h]@4
  char v22; // [sp+35h] [bp-1Fh]@5

  v13 = 0.0;
  result = a1;
  v14 = 0;
  switch ( (unsigned __int16)a1 )
  {
    case 0xAu:
    case 0xBu:
      v13 = sub_1003F440();
      v3 = sub_1007C040();
      result = sub_10023190(a1, 1, a2, &v13, v3);
      break;
    case 0xCu:
    case 0xDu:
      sub_1002A470((int)&v20);
      if ( sub_1003F480(v4)
        || v21 == 1
        || v22 != 3 && v22 != 2
        || !sub_1002BB90((float *)&v18, (float *)&v17, &v15, (float *)&v19) )
      {
        v14 = sub_1003F570(v5);
        v9 = sub_1007C040();
        result = sub_10023190(a1, 1, a2, &v14, v9);
      }
      else
      {
        v16 = v15;
        v6 = sub_1002AD10();
        v7 = sub_1002A710(v6);
        *(float *)&v16 = v16 - v7;
        v15 = sub_1007BCB0(*(float *)&v16);
        sub_10048200((int)&v14, v15);
        v8 = sub_1007C040();
        result = sub_10023190(a1, 1, a2, &v14, v8);
      }
      break;
    case 8u:
    case 9u:
      v13 = sub_1003F3E0();
      if ( (unsigned __int8)sub_1003E9D0() )
      {
        if ( v13 != flt_1022CE18 )
          dword_1022CDEC = sub_1007C040();
        if ( (unsigned int)(sub_1007C040() - dword_1022CDEC) > 0xBB8 )
          flt_1022CDF4 = v13;
        flt_1022CE18 = v13;
        v11 = sub_1007C040();
        result = sub_10023190(a1, 1, a2, &flt_1022CDF4, v11);
      }
      else
      {
        flt_1022CDF4 = v13;
        v10 = sub_1007C040();
        result = sub_10023190(a1, 1, a2, &flt_1022CDF4, v10);
      }
      break;
    case 0x12u:
    case 0x13u:
      v14 = sub_1003EAB0();
      v12 = sub_1007C040();
      result = sub_10023190(a1, 1, a2, &v14, v12);
      break;
    default:
      return result;
  }
  return result;
}
// 1003F440: using guessed type double sub_1003F440(void);
// 1022CDEC: using guessed type int dword_1022CDEC;
// 1022CDF4: using guessed type float flt_1022CDF4;
// 1022CE18: using guessed type float flt_1022CE18;

//----- (10015190) --------------------------------------------------------
char __cdecl sub_10015190(int a1, int a2)
{
  int v2; // eax@6
  char v4; // [sp+1h] [bp-7h]@1
  char v5; // [sp+2h] [bp-6h]@1
  char v6; // [sp+3h] [bp-5h]@2
  int v7; // [sp+4h] [bp-4h]@3

  v4 = 0;
  if ( sub_100457A0(421, &v5) && sub_100457A0(422, &v6) )
  {
    LOBYTE(v7) = 1;
    if ( v5 == 1 || v6 == 1 )
      v4 = 1;
  }
  else
  {
    LOBYTE(v7) = 0;
  }
  v2 = sub_1007C040();
  return sub_10023190(a1, v7, a2, &v4, v2);
}

//----- (10015210) --------------------------------------------------------
char __cdecl sub_10015210(int a1, int a2)
{
  int v2; // eax@4
  int v4; // [sp+4h] [bp-Ch]@2
  int v5; // [sp+8h] [bp-8h]@2
  float v6; // [sp+Ch] [bp-4h]@1

  if ( sub_10048C90(&v6) )
  {
    LOBYTE(v5) = 1;
    sub_10048200((int)&v4, v6);
  }
  else
  {
    v4 = 0;
    LOBYTE(v5) = 0;
  }
  v2 = sub_1007C040();
  return sub_10023190(a1, v5, a2, &v4, v2);
}

//----- (10015270) --------------------------------------------------------
char __cdecl sub_10015270(float a1, int a2)
{
  int v2; // edi@1
  char v3; // al@2
  char *v4; // esi@2
  double v5; // st7@5
  int v6; // eax@8
  char v8; // [sp+8h] [bp-4h]@4

  v2 = LODWORD(a1);
  if ( LOWORD(a1) == 275 )
  {
    v3 = sub_10044BE0(&a1);
    v4 = &byte_1022CDFB;
  }
  else
  {
    v3 = sub_10044F60(&a1);
    v4 = &byte_1022CE28;
  }
  v8 = v3;
  if ( !v3 )
    goto LABEL_14;
  v5 = a1;
  if ( !*v4 && v5 < 26.49788284301758 )
  {
    *v4 = 1;
    goto LABEL_8;
  }
  if ( *v4 == 1 && v5 > 30.28329467773438 )
LABEL_14:
    *v4 = 0;
LABEL_8:
  v6 = sub_1007C040();
  return sub_10023190(v2, v8, a2, v4, v6);
}
// 1022CDFB: using guessed type char byte_1022CDFB;
// 1022CE28: using guessed type char byte_1022CE28;

//----- (10015300) --------------------------------------------------------
char __cdecl sub_10015300(int a1, int a2)
{
  int v2; // eax@9
  char v4; // [sp+3h] [bp-9h]@1
  float v5; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v4 = 0;
  LOBYTE(v6) = sub_1003D430(0x1Cu, &v5);
  if ( (_BYTE)v6 == 1 )
  {
    if ( v5 >= 68947.594 )
      goto LABEL_12;
    if ( !dword_1022CE20 )
    {
      dword_1022CE20 = sub_1007C040();
      goto LABEL_9;
    }
    if ( !dword_1022CE20 )
    {
LABEL_12:
      dword_1022CE20 = 0;
      goto LABEL_9;
    }
    if ( (unsigned int)(sub_1007C040() - dword_1022CE20) >= 0x1388 )
      v4 = 1;
  }
LABEL_9:
  v2 = sub_1007C040();
  return sub_10023190(a1, v6, a2, &v4, v2);
}
// 1022CE20: using guessed type int dword_1022CE20;

//----- (10015390) --------------------------------------------------------
char __cdecl sub_10015390(int a1, int a2)
{
  int v2; // eax@1
  float v4; // [sp+0h] [bp-4h]@1

  v4 = sub_1002A710(0);
  v2 = sub_1007C040();
  return sub_10023190(a1, 1, a2, &v4, v2);
}

//----- (100153D0) --------------------------------------------------------
char __cdecl sub_100153D0(int a1, int a2)
{
  int v2; // ecx@0
  int v3; // eax@1
  int v5; // [sp-2h] [bp-4h]@1

  v5 = v2;
  BYTE2(v5) = 0;
  sub_1007C650(9184, (char *)&v5 + 3, 1, (char *)&v5 + 2);
  v3 = sub_1007C040();
  return sub_10023190(a1, 1, a2, (char *)&v5 + 3, v3);
}

//----- (10015410) --------------------------------------------------------
char __cdecl sub_10015410(int a1, int a2)
{
  int v2; // ecx@0
  int v3; // eax@1
  int v4; // eax@2
  int v6; // [sp-2h] [bp-4h]@1

  v6 = v2;
  v3 = sub_1007C3B0(10008, (int)&v6 + 3, 1);
  if ( !v3 )
  {
    v4 = sub_1007C040();
    LOBYTE(v3) = sub_10023190(a1, 1, a2, (char *)&v6 + 3, v4);
  }
  return v3;
}

//----- (10015450) --------------------------------------------------------
char __cdecl sub_10015450(int a1, int a2)
{
  int v2; // ecx@0
  int v3; // eax@1
  int v4; // eax@2
  int v6; // [sp-2h] [bp-4h]@1

  v6 = v2;
  v3 = sub_1007C3B0(10007, (int)&v6 + 3, 1);
  if ( !v3 )
  {
    v4 = sub_1007C040();
    LOBYTE(v3) = sub_10023190(a1, 1, a2, (char *)&v6 + 3, v4);
  }
  return v3;
}

//----- (10015490) --------------------------------------------------------
char __cdecl sub_10015490(int a1, int a2)
{
  int v2; // eax@1
  char v4; // [sp+1h] [bp-1h]@1

  v4 = 0;
  v2 = sub_1007C040();
  return sub_10023190(a1, 1, a2, &v4, v2);
}

//----- (100154C0) --------------------------------------------------------
char __cdecl sub_100154C0(int a1, int a2)
{
  char v2; // al@7
  int v3; // eax@25
  int v4; // eax@25
  char v6; // [sp+8h] [bp-10h]@1
  char v7; // [sp+9h] [bp-Fh]@1
  bool v8; // [sp+Ah] [bp-Eh]@1
  char v9; // [sp+Bh] [bp-Dh]@1
  float v10; // [sp+Ch] [bp-Ch]@2
  float v11; // [sp+10h] [bp-8h]@3
  char v12; // [sp+14h] [bp-4h]@18

  v9 = 0;
  v8 = 0;
  v7 = 0;
  sub_1007C470(10016, &v6, 1, &v9);
  if ( v6 && sub_10045980(&v10) && sub_1003D430(0xA8u, &v11) && v10 > 3657.60009765625 && v11 < 113763.53125 )
  {
    if ( byte_1022CDEB )
    {
      v2 = 0;
      byte_1022CDEB = 0;
      byte_1022CDEA = 0;
      goto LABEL_10;
    }
  }
  else
  {
    byte_1022CDEB = 1;
  }
  v2 = byte_1022CDEA;
LABEL_10:
  if ( byte_1022CDF8 )
  {
    --byte_1022CDF8;
    v7 = v2;
    v8 = v2 == 0;
    goto LABEL_25;
  }
  if ( v2 )
  {
    if ( !v6 )
    {
      v8 = 1;
LABEL_16:
      byte_1022CDF8 = 1;
      goto LABEL_17;
    }
  }
  else if ( v6 )
  {
    v7 = 1;
    goto LABEL_16;
  }
LABEL_17:
  if ( !byte_1022CDF9 || !sub_1003DB10(0, &v12) )
  {
LABEL_23:
    byte_1022CDEA = v6;
    goto LABEL_25;
  }
  if ( dword_1022CE24 )
  {
    if ( (unsigned int)(sub_1007C040() - dword_1022CE24) > 0x2710 )
    {
      v7 = v6;
      v8 = v6 == 0;
      byte_1022CDF9 = 0;
      byte_1022CDF8 = 1;
    }
    goto LABEL_23;
  }
  dword_1022CE24 = sub_1007C040();
  byte_1022CDEA = v6;
LABEL_25:
  v3 = sub_1007C040();
  sub_10023190(520, 1, a2, &v7, v3);
  v4 = sub_1007C040();
  return sub_10023190(521, 1, a2, &v8, v4);
}
// 1022CDEA: using guessed type char byte_1022CDEA;
// 1022CDEB: using guessed type char byte_1022CDEB;
// 1022CDF8: using guessed type char byte_1022CDF8;
// 1022CDF9: using guessed type char byte_1022CDF9;
// 1022CE24: using guessed type int dword_1022CE24;

//----- (10015650) --------------------------------------------------------
char __cdecl sub_10015650(int a1, int a2)
{
  int v2; // ecx@0
  int v3; // eax@1
  int v4; // eax@2
  int v6; // [sp-2h] [bp-4h]@1

  v6 = v2;
  BYTE2(v6) = 1;
  v3 = sub_1007C650(9200, (char *)&v6 + 3, 1, (char *)&v6 + 2);
  if ( !v3 )
  {
    v4 = sub_1007C040();
    LOBYTE(v3) = sub_10023190(a1, 1, a2, (char *)&v6 + 3, v4);
  }
  return v3;
}

//----- (100156A0) --------------------------------------------------------
char __cdecl sub_100156A0(int a1, int a2)
{
  int v2; // eax@4
  float v4; // [sp+0h] [bp-10h]@1
  int v5; // [sp+4h] [bp-Ch]@1
  float v6; // [sp+8h] [bp-8h]@2
  float v7; // [sp+Ch] [bp-4h]@1

  v4 = 0.0;
  LOBYTE(v5) = 0;
  if ( sub_10045A40(&v7) && sub_100459E0(&v6) )
  {
    LOBYTE(v5) = 1;
    v4 = v6 * 6.0 + v7;
  }
  v2 = sub_1007C040();
  return sub_10023190(a1, v5, a2, &v4, v2);
}

//----- (10015710) --------------------------------------------------------
char __cdecl sub_10015710(int a1, int a2)
{
  int v2; // ecx@0
  int v3; // eax@1
  int v5; // [sp-2h] [bp-4h]@1

  v5 = v2;
  BYTE2(v5) = 1;
  sub_1007C650(9185, (char *)&v5 + 3, 1, (char *)&v5 + 2);
  v3 = sub_1007C040();
  return sub_10023190(a1, 1, a2, (char *)&v5 + 3, v3);
}

//----- (10015750) --------------------------------------------------------
char __cdecl sub_10015750(int a1, int a2)
{
  char v2; // bl@1
  char v3; // al@9
  int v4; // eax@12
  int v6; // [sp+8h] [bp-40h]@1
  int v7; // [sp+Ch] [bp-3Ch]@10
  int v8; // [sp+10h] [bp-38h]@1
  unsigned int v9; // [sp+14h] [bp-34h]@1
  double v10; // [sp+18h] [bp-30h]@1
  double v11; // [sp+20h] [bp-28h]@1
  int v12; // [sp+28h] [bp-20h]@1
  float v13; // [sp+2Ch] [bp-1Ch]@1
  int v14; // [sp+30h] [bp-18h]@1
  int v15; // [sp+34h] [bp-14h]@1
  unsigned int v16; // [sp+38h] [bp-10h]@1
  int v17; // [sp+3Ch] [bp-Ch]@1
  float v18; // [sp+40h] [bp-8h]@1
  int v19; // [sp+44h] [bp-4h]@1

  v12 = 0;
  *(float *)&v6 = 0.0;
  v13 = 0.0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0.0;
  v19 = 0;
  v10 = 0.0;
  v11 = 0.0;
  v8 = 2147483648;
  v9 = 2147483648;
  v2 = 0;
  if ( sub_10041BD0((float *)&v6) == 1 )
    v13 = *(float *)&v6;
  if ( sub_100419B0(0, (int)&v10) == 1 )
  {
    sub_10048A00((int)&v8, v10, v11);
    v2 = 1;
  }
  v15 = v8;
  v16 = v9;
  if ( sub_10041DA0((float *)&v6) == 1 )
    sub_10048200((int)&v19, *(float *)&v6);
  if ( sub_10041E50((float *)&v6) == 1 )
    v18 = *(float *)&v6;
  LOBYTE(v12) = sub_10041D00();
  BYTE1(v12) = sub_10041D20();
  BYTE2(v12) = sub_10041C30();
  sub_10042E40((int)&v14);
  sub_10042DF0((int)&v17);
  v3 = sub_10041980();
  if ( !v2 || (LOBYTE(v7) = 1, (unsigned __int8)(v3 - 2) > 3u) )
    LOBYTE(v7) = 0;
  v4 = sub_1007C040();
  return sub_10023190(a1, v7, a2, &v12, v4);
}

//----- (100158C0) --------------------------------------------------------
char __cdecl sub_100158C0(int a1, int a2)
{
  int v2; // eax@8
  float v4; // [sp+0h] [bp-10h]@1
  int v5; // [sp+4h] [bp-Ch]@4
  float v6; // [sp+8h] [bp-8h]@2
  float v7; // [sp+Ch] [bp-4h]@3

  if ( !sub_1003D430(0x18u, &v4) || sub_1007C3B0(6237, (int)&v6, 4) || sub_1007C3B0(6236, (int)&v7, 4) )
  {
    LOBYTE(v5) = 0;
    byte_1022CDE8 = 0;
  }
  else
  {
    LOBYTE(v5) = 1;
    if ( byte_1022CDE8 == 1 )
    {
      if ( v6 < (double)v4 )
        byte_1022CDE8 = 0;
    }
    else if ( !byte_1022CDE8 && v7 > (double)v4 )
    {
      byte_1022CDE8 = 1;
    }
  }
  v2 = sub_1007C040();
  return sub_10023190(a1, v5, a2, &byte_1022CDE8, v2);
}
// 1022CDE8: using guessed type char byte_1022CDE8;

//----- (10015980) --------------------------------------------------------
char __cdecl sub_10015980(int a1, int a2)
{
  int v2; // ecx@0
  char result; // al@2
  void *v4; // ecx@6
  int v5; // eax@8
  int v6; // [sp+0h] [bp-4h]@1

  v6 = v2;
  *(_WORD *)((char *)&v6 + 1) = 257;
  if ( !sub_10047290(2, (_BYTE *)&v6 + 3) )
  {
LABEL_8:
    v5 = sub_1007C040();
    return sub_10023190(a1, 1, a2, (char *)&v6 + 1, v5);
  }
  result = BYTE3(v6);
  if ( BYTE3(v6) != 3 && BYTE3(v6) != 5 )
  {
    result = sub_1002D4F0((void *)0x10, (char *)&v6 + 2);
    if ( BYTE2(v6) == 2 )
    {
      if ( BYTE3(v6) == 17 )
      {
        sub_1003ED90();
        BYTE1(v6) = sub_1003EB30(v4);
        if ( !BYTE1(v6) )
          BYTE1(v6) = 1;
      }
      goto LABEL_8;
    }
  }
  return result;
}

//----- (10015A00) --------------------------------------------------------
char __cdecl sub_10015A00(int a1, int a2)
{
  int v2; // ecx@0
  int v3; // eax@1
  int v4; // eax@2
  int v6; // [sp+0h] [bp-4h]@1

  v6 = v2;
  v3 = sub_1007C3B0(9153, (int)&v6, 4);
  if ( !v3 )
  {
    v4 = sub_1007C040();
    LOBYTE(v3) = sub_10023190(a1, 1, a2, &v6, v4);
  }
  return v3;
}

//----- (10015A40) --------------------------------------------------------
char __cdecl sub_10015A40(int a1, int a2)
{
  void *v2; // ecx@0
  char v3; // al@11
  double v4; // st7@21
  float v5; // ST18_4@24
  char result; // al@25
  bool v7; // zf@29
  bool v8; // zf@30
  int v9; // eax@35
  char v10; // [sp+14h] [bp-54h]@13
  char v11; // [sp+15h] [bp-53h]@6
  char v12; // [sp+16h] [bp-52h]@1
  char v13; // [sp+17h] [bp-51h]@11
  char v14; // [sp+18h] [bp-50h]@1
  char v15; // [sp+19h] [bp-4Fh]@31
  char v16; // [sp+1Ah] [bp-4Eh]@1
  char v17; // [sp+1Bh] [bp-4Dh]@3
  float v18; // [sp+1Ch] [bp-4Ch]@20
  float v19; // [sp+20h] [bp-48h]@4
  int v20; // [sp+24h] [bp-44h]@19
  char v21; // [sp+28h] [bp-40h]@10

  v14 = 0;
  v12 = 0;
  v16 = 0;
  if ( (unsigned __int16)a1 == 2115 )
  {
    sub_1003EB70(&v19);
    v15 = 0;
    sub_1007C470(6667, &v15, 1, &v14);
    v8 = v15 == 0;
    goto LABEL_32;
  }
  if ( (unsigned __int16)a1 == 2116 )
  {
    sub_100491F0();
    sub_1003EC70(&v19);
    v10 = 0;
    sub_1007C470(6666, &v10, 1, &v14);
    v8 = v10 == 0;
LABEL_32:
    result = !v8;
    v7 = !v8 == 0;
LABEL_33:
    if ( v7 )
      return result;
    goto LABEL_34;
  }
  v17 = sub_1003EC40(v2);
  if ( v17 == 1 )
    sub_1003EB70(&v19);
  else
    sub_1003EC70(&v19);
  sub_1007C470(41117, &v11, 1, &v16);
  if ( v11 )
  {
    if ( (unsigned int)dword_1022CDFC < 2 )
    {
      ++dword_1022CDFC;
    }
    else
    {
      dword_1022CDFC = 0;
      v11 = 0;
      sub_1007C500(41117, (int)&v11, 1);
    }
  }
  if ( !sub_1003F260(&v21) || (v3 = sub_1003ED00((int)&v21), v13 = 1, !v3) )
    v13 = 0;
  v10 = 0;
  sub_1007C470(6666, &v10, 1, &v14);
  if ( sub_10023DA0(1639, a2, &v12) )
  {
    if ( v12 && !byte_1022CE10 && *(_BYTE *)(dword_10337080 + 31728) & 0x80 && !v13 )
    {
      sub_1003EC70(&v19);
      if ( (_BYTE)v20 )
      {
        if ( !sub_10045B40(&v18) )
          goto LABEL_25;
        v4 = 0.0099999998;
      }
      else
      {
        if ( !sub_10045A40(&v18) )
          goto LABEL_25;
        v4 = 0.51444447;
      }
      v5 = v4;
      v19 = sub_1007BD40(v18, v5);
      sub_1003EEB0(v19, v20, 0);
      goto LABEL_25;
    }
  }
  else
  {
    v12 = 0;
  }
LABEL_25:
  result = v12;
  byte_1022CE10 = v12;
  if ( !v10 && v17 != 1 && !v11 && !v12 )
  {
    v7 = v13 == 0;
    goto LABEL_33;
  }
LABEL_34:
  result = sub_10048E10();
  if ( result )
  {
    v9 = sub_1007C040();
    result = sub_10023190(a1, 1, a2, &v19, v9);
  }
  return result;
}
// 1022CDFC: using guessed type int dword_1022CDFC;
// 1022CE10: using guessed type char byte_1022CE10;
// 10337080: using guessed type int dword_10337080;

//----- (10015CB0) --------------------------------------------------------
char __cdecl sub_10015CB0(int a1, int a2)
{
  void *v2; // ecx@0
  int v3; // eax@1
  char v5; // [sp+1h] [bp-1h]@1

  v5 = sub_1003EBC0(v2);
  v3 = sub_1007C040();
  return sub_10023190(a1, 1, a2, &v5, v3);
}

//----- (10015CE0) --------------------------------------------------------
char __cdecl sub_10015CE0(int a1, int a2)
{
  char result; // al@1
  int v3; // eax@2
  char v4; // [sp+0h] [bp-10h]@1

  sub_1003EBF0(&v4);
  result = sub_10048E10();
  if ( result )
  {
    v3 = sub_1007C040();
    result = sub_10023190(a1, 1, a2, &v4, v3);
  }
  return result;
}

//----- (10015D20) --------------------------------------------------------
char __cdecl sub_10015D20(int a1, int a2)
{
  void *v2; // ecx@0
  int v3; // eax@1
  char v5; // [sp+1h] [bp-1h]@1

  v5 = sub_1003EC40(v2);
  v3 = sub_1007C040();
  return sub_10023190(a1, 1, a2, &v5, v3);
}

//----- (10015D50) --------------------------------------------------------
char __cdecl sub_10015D50(int a1, int a2)
{
  int v2; // eax@1
  float v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = 0.0;
  LOBYTE(v5) = sub_10045C60(&v4);
  v2 = sub_1007C040();
  return sub_10023190(a1, v5, a2, &v4, v2);
}

//----- (10015D90) --------------------------------------------------------
char __cdecl sub_10015D90(int a1, int a2)
{
  char v2; // ST1C_1@1
  int v3; // eax@1
  char v5; // [sp+8h] [bp-44h]@1
  char v6; // [sp+1Ch] [bp-30h]@1

  v2 = sub_10049580(&v5);
  v3 = sub_1007C040();
  return sub_10023190(a1, v2, a2, &v6, v3);
}

//----- (10015DE0) --------------------------------------------------------
void __cdecl sub_10015DE0(int a1, int a2)
{
  void *v2; // ecx@5
  char v3; // al@5
  bool v4; // sf@7
  int v5; // eax@16
  int v6; // eax@27
  int v7; // [sp+4h] [bp-534h]@5
  char v8; // [sp+8h] [bp-530h]@14
  char v9; // [sp+9h] [bp-52Fh]@5
  char v10; // [sp+Ah] [bp-52Eh]@5
  char v11; // [sp+Bh] [bp-52Dh]@5
  __int16 v12; // [sp+Ch] [bp-52Ch]@5
  char v13; // [sp+10h] [bp-528h]@18
  char v14; // [sp+11h] [bp-527h]@30
  char v15; // [sp+12h] [bp-526h]@9
  char v16; // [sp+13h] [bp-525h]@23
  char v17; // [sp+14h] [bp-524h]@9
  int v18; // [sp+18h] [bp-520h]@30

  if ( !byte_1022CDE9 || (_WORD)a1 != 42 && (_WORD)a1 != 6 && (_WORD)a1 != 7 )
    return;
  memset(&v12, 0, 0x528u);
  sub_10023DA0(a1, a2, &v7);
  v3 = v9 + v10 + v11;
  if ( v7 )
  {
    v4 = v3 < 0;
    if ( !v3 )
    {
      v15 = 1;
LABEL_13:
      v17 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( !v3 )
      return;
    v4 = v3 < 0;
  }
  if ( !v4 )
  {
    v15 = v9 + v10 + v11;
    goto LABEL_13;
  }
  v15 = -v3;
  v17 = 1;
LABEL_14:
  if ( v8 == 1 )
  {
    v13 = 8;
  }
  else if ( v8 == 2 )
  {
    v13 = 7;
  }
  else
  {
    v5 = sub_100429D0(v2) - 2;
    if ( v5 )
    {
      if ( v5 == 2 )
        v13 = 2;
      else
        v13 = 0;
    }
    else
    {
      v13 = 1;
    }
  }
  v16 = -1;
  if ( v9 )
  {
    v16 = 68;
  }
  else if ( v11 )
  {
    v16 = 90;
  }
  v6 = sub_10043FF0(&v7, 4u, (int)&unk_100A0328, 8, 21, -1);
  if ( v6 != -1 )
    v16 = byte_100A032C[8 * v6];
  if ( v16 != -1 )
  {
    v12 = -32708;
    v18 = -1;
    v14 = -1;
    sub_100477E0((int)&v12);
  }
}
// 1022CDE9: using guessed type char byte_1022CDE9;

//----- (10015F50) --------------------------------------------------------
int __cdecl sub_10015F50(int a1, unsigned int a2)
{
  int result; // eax@3
  int v3; // esi@8
  signed int v4; // edi@8
  int v5; // esi@15
  signed int v6; // edi@15
  char v7; // [sp+Ch] [bp-84h]@9
  char v8; // [sp+12h] [bp-7Eh]@11
  char v9; // [sp+48h] [bp-48h]@8
  char v10; // [sp+4Eh] [bp-42h]@8
  char v11; // [sp+50h] [bp-40h]@9
  char v12; // [sp+54h] [bp-3Ch]@22
  char v13; // [sp+70h] [bp-20h]@15

  if ( !strstr((const char *)(a1 + 16), " iaf") || strstr((const char *)(a2 + 16), " iaf") )
  {
    if ( !strstr((const char *)(a2 + 16), " iaf") || strstr((const char *)(a1 + 16), " iaf") )
    {
      result = strcmp((const char *)(a1 + 16), (const char *)(a2 + 16));
      if ( !result )
      {
        sub_100311B0(*(_DWORD *)a1, *(_BYTE *)(a1 + 4), *(_BYTE *)(a1 + 41), &v9);
        v3 = 0;
        v4 = 0x3FFFF;
        if ( v10 > 0 )
        {
          while ( 1 )
          {
            sub_10032570(a2, *(_DWORD *)a1, (int *)&v11, (int)&v7);
            if ( v3 == 1 )
              v4 = sub_100439B0((int)&v7);
            if ( v8 == 1 )
              break;
            if ( ++v3 >= v10 )
              goto LABEL_15;
          }
          v4 = sub_100439B0((int)&v7);
        }
LABEL_15:
        sub_1002E110(v4, (int)&v13);
        sub_100311B0(*(_DWORD *)a2, *(_BYTE *)(a2 + 4), *(_BYTE *)(a2 + 41), &v9);
        v5 = 0;
        v6 = 0x3FFFF;
        if ( v10 > 0 )
        {
          while ( 1 )
          {
            sub_10032570(a2, *(_DWORD *)a2, (int *)&v11, (int)&v7);
            if ( v5 == 1 )
              v6 = sub_100439B0((int)&v7);
            if ( v8 == 1 )
              break;
            if ( ++v5 >= v10 )
              goto LABEL_22;
          }
          v6 = sub_100439B0((int)&v7);
        }
LABEL_22:
        sub_1002E110(v6, (int)&v12);
        result = strcmp(&v13, &v12);
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10016170) --------------------------------------------------------
unsigned __int16 __usercall sub_10016170@<ax>(unsigned __int8 a1@<dl>, char a2@<cl>, unsigned __int16 *a3@<edi>, unsigned int a4, unsigned __int8 a5)
{
  int v5; // esi@1
  unsigned __int16 v6; // bp@1
  char v7; // al@1
  int v8; // esi@2
  unsigned __int16 v9; // cx@14
  char v11; // [sp+Fh] [bp-4Dh]@5
  char v12; // [sp+10h] [bp-4Ch]@3
  char v13; // [sp+11h] [bp-4Bh]@17
  char v14; // [sp+14h] [bp-48h]@17
  char v15; // [sp+15h] [bp-47h]@17
  char v16; // [sp+17h] [bp-45h]@14
  char v17; // [sp+18h] [bp-44h]@14
  char v18; // [sp+19h] [bp-43h]@14
  char v19; // [sp+1Ah] [bp-42h]@14
  float v20; // [sp+1Ch] [bp-40h]@14
  float v21; // [sp+20h] [bp-3Ch]@14
  float v22; // [sp+24h] [bp-38h]@14
  int v23; // [sp+38h] [bp-24h]@11
  int v24; // [sp+3Ch] [bp-20h]@11
  int v25; // [sp+40h] [bp-1Ch]@11
  int v26; // [sp+44h] [bp-18h]@11
  int v27; // [sp+48h] [bp-14h]@11
  char v28; // [sp+4Ch] [bp-10h]@1
  char v29; // [sp+52h] [bp-Ah]@5
  char v30; // [sp+54h] [bp-8h]@3

  v5 = a4;
  v6 = 0;
  *a3 = 0;
  sub_100311B0(a4, a1, a2, &v28);
  v7 = a5;
  if ( (char)a5 > 0 )
  {
    v8 = a5;
    do
    {
      sub_10032570(0, a4, (int *)&v30, (int)&v12);
      --v8;
    }
    while ( v8 );
    v7 = a5;
    v5 = a4;
  }
  v11 = v7;
  if ( v7 < v29 )
  {
    while ( 1 )
    {
      memset(&v12, 0, 0x3Cu);
      sub_10032570(0, v5, (int *)&v30, (int)&v12);
      if ( v11 == a5 )
      {
        if ( !v12 || v12 == 3 || v12 == 6 || v12 == 16 )
          goto LABEL_11;
        if ( v12 == 12 || v12 == 15 )
          break;
      }
      if ( v12 == 14 )
        goto LABEL_16;
LABEL_17:
      v20 = 0.0;
      v21 = 0.0;
      v22 = 0.0;
      v15 = 0;
      v13 = 0;
      v14 = 0;
      v16 = 4;
      v17 = 0;
      v18 = 0;
      v19 = 0;
      v6 = sub_1007B820(&v12, 60, v6, 2);
      if ( ++v11 >= v29 )
        return v6;
    }
    v9 = *a3;
    v20 = 0.0;
    v21 = 0.0;
    v22 = 0.0;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    *a3 = sub_1007B820(&v12, 60, v9, 2);
LABEL_11:
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
LABEL_16:
    v12 = 17;
    goto LABEL_17;
  }
  return v6;
}

//----- (100162F0) --------------------------------------------------------
char __usercall sub_100162F0@<al>(int a1@<esi>)
{
  char v1; // bl@1
  double v2; // st7@5
  float v4; // [sp+Ch] [bp-8h]@1
  float v5; // [sp+10h] [bp-4h]@2

  v1 = sub_1002BB90((float *)a1, &v4, (float *)(a1 + 8), (float *)(a1 + 12));
  *(float *)(a1 + 4) = 0.0;
  if ( v1 )
  {
    v5 = 61.733334;
    if ( sub_10041E50(&v4) )
    {
      sub_10045800(308.66666, 30.866667);
      v5 = v4;
    }
    if ( sub_10045C00(&v4) )
    {
      v2 = v4;
      if ( (LODWORD(v4) & 0x7F800000) == 2139095040 || v2 > 308.66666 || v2 < 30.86666679382324 )
      {
        v4 = v5;
        v2 = v5;
      }
      v5 = v2;
    }
    *(float *)(a1 + 4) = *(float *)a1 * 1.052000045776367 * 9.806650161743164 / v5;
  }
  return v1;
}

//----- (100163E0) --------------------------------------------------------
unsigned int __usercall sub_100163E0@<eax>(_DWORD *a1@<ecx>, unsigned int a2@<ebx>, unsigned int a3, unsigned __int8 a4, int a5)
{
  unsigned __int8 v5; // si@1
  _WORD *v6; // edi@1
  signed int i; // esi@4
  signed int v8; // esi@6
  int v9; // esi@16
  int v10; // eax@16
  int v11; // ecx@17
  __int16 v12; // dx@31
  int v13; // eax@31
  unsigned int v14; // ecx@31
  __int16 v15; // dx@31
  char v17; // [sp+Dh] [bp-147h]@1
  char v18; // [sp+Eh] [bp-146h]@16
  char v19; // [sp+Fh] [bp-145h]@4
  __int16 v20; // [sp+10h] [bp-144h]@6
  int v21; // [sp+14h] [bp-140h]@4
  int v22; // [sp+18h] [bp-13Ch]@1
  int v23; // [sp+1Ch] [bp-138h]@1
  _DWORD *v24; // [sp+20h] [bp-134h]@1
  unsigned int v25; // [sp+24h] [bp-130h]@6
  int v26; // [sp+28h] [bp-12Ch]@4
  int v27; // [sp+2Ch] [bp-128h]@1
  int v28; // [sp+30h] [bp-124h]@6
  char v29; // [sp+34h] [bp-120h]@6
  char v30; // [sp+70h] [bp-E4h]@1
  char v31; // [sp+76h] [bp-DEh]@8
  char v32; // [sp+ACh] [bp-A8h]@5
  char v33; // [sp+E8h] [bp-6Ch]@4
  char v34; // [sp+EEh] [bp-66h]@7
  char v35; // [sp+F0h] [bp-64h]@5
  char v36; // [sp+F4h] [bp-60h]@1
  char v37; // [sp+FCh] [bp-58h]@1
  char v38; // [sp+100h] [bp-54h]@1
  int v39; // [sp+10Bh] [bp-49h]@1
  char v40; // [sp+134h] [bp-20h]@29
  char v41; // [sp+14Ch] [bp-8h]@31

  v5 = a4;
  v6 = a1;
  v23 = a5;
  v24 = a1;
  *a1 = 0;
  v17 = -1;
  v27 = 0x3FFFF;
  sub_10034710(a3, a4, (int)&v38);
  sub_100311B0(a3, a4, v39, &v36);
  sub_10032570(a2, a3, (int *)&v37, (int)&v30);
  v22 = 0;
  if ( SBYTE1(v39) > 0 )
  {
    while ( 1 )
    {
      sub_10031130(a3, v5, v22, &v19, &v26, &v21);
      sub_100311B0(a3, v5, v26, &v33);
      for ( i = 0; i < (char)v21; ++i )
        sub_10032570(a2, a3, (int *)&v35, (int)&v32);
      sub_10032570(a2, a3, (int *)&v35, (int)&v29);
      v8 = sub_100439B0((int)&v29);
      v25 = v8;
      LOBYTE(a2) = 0;
      v28 = sub_10016170(a4, v26, (unsigned __int16 *)&v20, a3, v21);
      if ( v8 == sub_100439B0((int)&v30) && (char)v21 == v34 - 1 && v31 == 2 && (v29 == 3 || v29 == 14 || v29 == 17) )
        LOBYTE(a2) = 1;
      if ( (_BYTE)v26 == v17 && v8 == v27 )
        LOBYTE(a2) = 1;
      v27 = v8;
      v9 = *v24;
      v17 = v26;
      v10 = 0;
      v18 = 0;
      if ( *v24 > 0 )
      {
        v11 = v23 + 12;
        do
        {
          if ( *(_DWORD *)(v11 - 4) == v25 && *(_WORD *)(v11 - 6) == (_WORD)v28 )
          {
            if ( v29 == 12 || v29 == 15 )
            {
              if ( *(_BYTE *)v11 == 12 || *(_BYTE *)v11 == 15 )
              {
                LOBYTE(a2) = v20 == *(_WORD *)(v11 + 2);
              }
              else
              {
                v18 = 1;
                LOBYTE(a2) = 0;
                v9 = v10;
              }
            }
            else
            {
              LOBYTE(a2) = 1;
            }
          }
          ++v10;
          v11 += 44;
        }
        while ( v10 < *v24 );
      }
      if ( !(_BYTE)a2 )
      {
        sub_1002E110(v25, (int)&v40);
        if ( v19 == 1 )
          strncat(&v40, " iaf", 0x19u);
        v12 = v28;
        v13 = 44 * v9 + v23;
        qmemcpy((void *)(v13 + 16), &v40, 0x18u);
        *(_BYTE *)(v13 + 4) = a4;
        v14 = v25;
        *(_WORD *)(v13 + 6) = v12;
        v15 = v20;
        *(_DWORD *)(v13 + 8) = v14;
        LOBYTE(v14) = v29;
        *(_WORD *)(v13 + 14) = v15;
        LOBYTE(v15) = v22;
        *(_BYTE *)(v13 + 40) = v41;
        *(_DWORD *)v13 = a3;
        *(_BYTE *)(v13 + 12) = v14;
        *(_BYTE *)(v13 + 41) = v15;
        if ( !v18 )
          ++*v24;
      }
      if ( ++v22 >= SBYTE1(v39) )
        break;
      v5 = a4;
    }
    v6 = v24;
  }
  return sub_10044420(v23, *v6, 0x2Cu, (int)sub_10015F50);
}

//----- (100166F0) --------------------------------------------------------
bool __cdecl sub_100166F0(__int16 a1)
{
  void *v1; // ecx@0
  int v2; // eax@2
  bool result; // al@5

  result = 1;
  if ( a1 == 14 )
  {
    v2 = sub_100429D0(v1);
    if ( v2 != 1 && (v2 != 4 || !sub_100429F0(1)) )
      result = 0;
  }
  return result;
}

//----- (10016720) --------------------------------------------------------
char __usercall sub_10016720@<al>(unsigned int *a1@<edi>, int a2@<esi>, int a3, int a4)
{
  unsigned int v4; // eax@5
  int v5; // eax@8
  char v7; // [sp+Bh] [bp-1h]@1

  v7 = 0;
  if ( sub_10023DA0(a3, a2, &v7) != 1 || v7 != 1 )
  {
    if ( sub_1007C3B0(a4, (int)&v7, 1) )
      v7 = 0;
  }
  else if ( *a1 <= 0 )
  {
    v4 = 0x1388u
       / *(_DWORD *)(52 * *(_WORD *)(*(_DWORD *)(a2 + 40) + 2 * (unsigned __int16)a3) + *(_DWORD *)(a2 + 32) + 12);
    v7 = 0;
    *a1 = v4;
    sub_1007C500(a4, (int)&v7, 1);
  }
  else
  {
    --*a1;
  }
  v5 = sub_1007C040();
  return sub_10023190(a3, 1, a2, &v7, v5);
}

//----- (100167D0) --------------------------------------------------------
char sub_100167D0()
{
  unsigned int v0; // edi@1
  unsigned int v1; // eax@1
  int v2; // edi@1
  unsigned int v3; // eax@1
  void *v4; // ecx@1
  int v5; // eax@4
  char v7; // [sp+Fh] [bp-105h]@1
  char v8; // [sp+10h] [bp-104h]@1

  byte_1022CE2C = sub_100477F0(0);
  byte_1022CE2D = sub_100477F0(1);
  byte_1022CE29 = 0;
  byte_1022CDFB = 0;
  byte_1022CE28 = 0;
  byte_1022CE2A = 0;
  byte_1022CE11 = 0;
  byte_1022CDE8 = 0;
  v0 = *(_DWORD *)(52 * *(_WORD *)(dword_10332F28 + 2678) + dword_10332F20 + 12);
  byte_1022CDFA = 0;
  byte_1022CE13 = 0;
  dword_1022CE34 = 0;
  dword_1022CE14 = 0;
  dword_1022CE20 = 0;
  byte_1022CDF8 = 0;
  byte_1022CDEB = 1;
  byte_1022CDF9 = 1;
  dword_1022CE24 = 0;
  byte_1022CDEA = 0;
  dword_1022CDFC = 0;
  byte_1022CE10 = 0;
  dword_1022CE0C = 0x1388 / v0;
  v1 = 0x7D0 / v0;
  v2 = 52 * *(_WORD *)(dword_10332F28 + 2018);
  dword_1022CE1C = v1;
  dword_1022CE00 = 0x1388u / *(_DWORD *)(v2 + dword_10332F20 + 12);
  v3 = 0x1388u / *(_DWORD *)(52 * *(_WORD *)(dword_10332F28 + 2020) + dword_10332F20 + 12);
  v7 = 0;
  dword_1022CE08 = v3;
  sub_1007C500(41117, (int)&v7, 1);
  dword_1022CE30 = 0;
  sub_10017250();
  dword_1022CE04 = 0;
  flt_1022CDF4 = sub_1003F3E0();
  dword_1022CDEC = 0;
  flt_1022CE18 = flt_1022CDF4;
  dword_1022CDF0 = sub_1007C040() - 10000;
  dword_1022CDE4 = 0;
  byte_1022CE12 = 0;
  byte_1022CDE9 = 0;
  sub_1007C4B0(6463, (int)&v8, 256);
  if ( (unsigned __int8)sub_1003F8A0(&v8, "KEY_PRESS") )
    byte_1022CDE9 = 1;
  switch ( sub_100429D0(v4) )
  {
    case 4:
      v5 = 247;
      break;
    case 2:
      v5 = 248;
      break;
    case 64:
      v5 = 1732;
      break;
    case 128:
      v5 = 1733;
      break;
    case 16:
      v5 = 2279;
      break;
    case 32:
      v5 = 2280;
      break;
    default:
      v5 = 246;
      break;
  }
  return sub_100146F0(v5, (int)&byte_10332F00);
}
// 1022CDE4: using guessed type int dword_1022CDE4;
// 1022CDE8: using guessed type char byte_1022CDE8;
// 1022CDE9: using guessed type char byte_1022CDE9;
// 1022CDEA: using guessed type char byte_1022CDEA;
// 1022CDEB: using guessed type char byte_1022CDEB;
// 1022CDEC: using guessed type int dword_1022CDEC;
// 1022CDF0: using guessed type int dword_1022CDF0;
// 1022CDF4: using guessed type float flt_1022CDF4;
// 1022CDF8: using guessed type char byte_1022CDF8;
// 1022CDF9: using guessed type char byte_1022CDF9;
// 1022CDFA: using guessed type char byte_1022CDFA;
// 1022CDFB: using guessed type char byte_1022CDFB;
// 1022CDFC: using guessed type int dword_1022CDFC;
// 1022CE00: using guessed type int dword_1022CE00;
// 1022CE04: using guessed type int dword_1022CE04;
// 1022CE08: using guessed type int dword_1022CE08;
// 1022CE0C: using guessed type int dword_1022CE0C;
// 1022CE10: using guessed type char byte_1022CE10;
// 1022CE11: using guessed type char byte_1022CE11;
// 1022CE12: using guessed type char byte_1022CE12;
// 1022CE13: using guessed type char byte_1022CE13;
// 1022CE14: using guessed type int dword_1022CE14;
// 1022CE18: using guessed type float flt_1022CE18;
// 1022CE1C: using guessed type int dword_1022CE1C;
// 1022CE20: using guessed type int dword_1022CE20;
// 1022CE24: using guessed type int dword_1022CE24;
// 1022CE28: using guessed type char byte_1022CE28;
// 1022CE29: using guessed type char byte_1022CE29;
// 1022CE2A: using guessed type char byte_1022CE2A;
// 1022CE2C: using guessed type char byte_1022CE2C;
// 1022CE2D: using guessed type char byte_1022CE2D;
// 1022CE30: using guessed type int dword_1022CE30;
// 1022CE34: using guessed type int dword_1022CE34;
// 10332F00: using guessed type char byte_10332F00;
// 10332F20: using guessed type int dword_10332F20;
// 10332F28: using guessed type int dword_10332F28;

//----- (10016A80) --------------------------------------------------------
char __usercall sub_10016A80@<al>(unsigned int a1@<ebx>, int a2, int a3)
{
  char result; // al@1
  int v4; // edi@2
  int v5; // esi@2
  char v6; // bl@9
  int v7; // ebp@9
  char *v8; // edi@10
  int v9; // [sp+Ch] [bp-7C4h]@8
  int v10; // [sp+10h] [bp-7C0h]@6
  char v11; // [sp+14h] [bp-7BCh]@2
  int v12; // [sp+18h] [bp-7B8h]@2
  char v13[4]; // [sp+94h] [bp-73Ch]@1
  char v14; // [sp+9Ch] [bp-734h]@3
  char v15; // [sp+B5h] [bp-71Bh]@7
  char v16; // [sp+CEh] [bp-702h]@12
  char v17; // [sp+D0h] [bp-700h]@9
  char v18; // [sp+F9h] [bp-6D7h]@10
  char v19; // [sp+7B0h] [bp-20h]@3

  result = sub_10023DA0(a2, a3, v13);
  if ( result )
  {
    sub_1002E680(0, &v13[1], (int)&v12, (signed int *)&v11);
    v4 = (unsigned __int8)sub_10031080(v12);
    v5 = 0;
    if ( v4 > 0 )
    {
      while ( 1 )
      {
        sub_10012C90(v12, v5, (int)&v19);
        if ( !strncmp(&v14, &v19, 0x19u) )
          break;
        if ( ++v5 >= v4 )
          goto LABEL_7;
      }
      v10 = v5;
    }
LABEL_7:
    if ( !strncmp(&v15, "VECTORS", 7u) )
    {
      v9 = -1;
    }
    else
    {
      sub_100163E0(&v9, a1, v12, v10, (int)&v17);
      v5 = v9;
      v6 = 0;
      v7 = 0;
      if ( v9 > 0 )
      {
        v8 = &v18;
        do
        {
          if ( !strncmp(&v15, v8 - 25, 0x19u) )
          {
            v9 = *v8;
            if ( v6 == v16 )
              break;
            ++v6;
          }
          ++v7;
          v8 += 44;
        }
        while ( v7 < v5 );
      }
    }
    result = sub_10030450(v5, 0, v12, v10, v9, v13[0], 0, -1.0);
  }
  return result;
}

//----- (10016C10) --------------------------------------------------------
char __cdecl sub_10016C10(int a1, int a2)
{
  return sub_10016720((unsigned int *)&dword_1022CE00, a2, a1, 9398);
}
// 1022CE00: using guessed type int dword_1022CE00;

//----- (10016C30) --------------------------------------------------------
char __cdecl sub_10016C30(int a1, int a2)
{
  return sub_10016720((unsigned int *)&dword_1022CE08, a2, a1, 9399);
}
// 1022CE08: using guessed type int dword_1022CE08;

//----- (10016C50) --------------------------------------------------------
char __cdecl sub_10016C50(int a1, int a2)
{
  void *v2; // ecx@1
  char result; // al@1
  void *v4; // ecx@12
  int v5; // eax@22
  char v6; // al@23
  int v7; // eax@33
  int v8; // eax@34
  int v9; // eax@38
  int v10; // ecx@39
  signed int v11; // eax@39
  int v12; // eax@39
  char v13; // [sp+14h] [bp-170h]@1
  char v14; // [sp+15h] [bp-16Fh]@1
  int v15; // [sp+1Ah] [bp-16Ah]@1
  char v16; // [sp+1Eh] [bp-166h]@23
  char v17; // [sp+1Fh] [bp-165h]@1
  float v18; // [sp+20h] [bp-164h]@1
  int v19; // [sp+26h] [bp-15Eh]@10
  char v20; // [sp+2Ah] [bp-15Ah]@12
  char v21; // [sp+2Bh] [bp-159h]@19
  int v22; // [sp+2Ch] [bp-158h]@1
  float v23; // [sp+30h] [bp-154h]@1
  int v24; // [sp+34h] [bp-150h]@1
  int v25; // [sp+38h] [bp-14Ch]@1
  int v26; // [sp+3Ch] [bp-148h]@1
  float v27; // [sp+40h] [bp-144h]@1
  float v28; // [sp+44h] [bp-140h]@1
  int v29; // [sp+48h] [bp-13Ch]@1
  int v30; // [sp+4Ch] [bp-138h]@1
  float v31; // [sp+50h] [bp-134h]@1
  float v32; // [sp+54h] [bp-130h]@1
  int v33; // [sp+58h] [bp-12Ch]@1
  float v34; // [sp+5Ch] [bp-128h]@1
  float v35; // [sp+60h] [bp-124h]@1
  int v36; // [sp+64h] [bp-120h]@1
  int v37; // [sp+68h] [bp-11Ch]@1
  int v38; // [sp+6Ch] [bp-118h]@1
  int v39; // [sp+70h] [bp-114h]@1
  int v40; // [sp+74h] [bp-110h]@1
  int v41; // [sp+78h] [bp-10Ch]@1
  int v42; // [sp+7Ch] [bp-108h]@1
  int v43; // [sp+80h] [bp-104h]@1
  int v44; // [sp+84h] [bp-100h]@1
  int v45; // [sp+88h] [bp-FCh]@1
  int v46; // [sp+8Ch] [bp-F8h]@1
  int v47; // [sp+90h] [bp-F4h]@1
  int v48; // [sp+94h] [bp-F0h]@1
  float v49; // [sp+98h] [bp-ECh]@1
  char v50; // [sp+9Ch] [bp-E8h]@6
  char v51; // [sp+9Dh] [bp-E7h]@6
  char v52; // [sp+9Eh] [bp-E6h]@10
  char v53; // [sp+9Fh] [bp-E5h]@6
  char v54; // [sp+A0h] [bp-E4h]@12
  char v55; // [sp+A1h] [bp-E3h]@19
  char v56; // [sp+A2h] [bp-E2h]@10
  char v57; // [sp+A3h] [bp-E1h]@6
  char v58; // [sp+A4h] [bp-E0h]@19
  char v59; // [sp+A5h] [bp-DFh]@19
  char v60; // [sp+A6h] [bp-DEh]@12
  bool v61; // [sp+A7h] [bp-DDh]@6
  int v62; // [sp+A8h] [bp-DCh]@8
  int v63; // [sp+ACh] [bp-D8h]@10
  int v64; // [sp+B0h] [bp-D4h]@19
  int v65; // [sp+B4h] [bp-D0h]@19
  char v66; // [sp+B8h] [bp-CCh]@19
  float v67; // [sp+BCh] [bp-C8h]@12
  float v68; // [sp+C4h] [bp-C0h]@12
  int v69; // [sp+CCh] [bp-B8h]@19
  int v70; // [sp+D0h] [bp-B4h]@19
  float v71; // [sp+D4h] [bp-B0h]@12
  char v72; // [sp+DCh] [bp-A8h]@19
  char v73; // [sp+E0h] [bp-A4h]@19
  char v74; // [sp+E4h] [bp-A0h]@19
  char v75; // [sp+E8h] [bp-9Ch]@19
  char v76; // [sp+F4h] [bp-90h]@1
  float v77; // [sp+100h] [bp-84h]@32
  float v78; // [sp+104h] [bp-80h]@32
  int v79; // [sp+130h] [bp-54h]@28
  char v80; // [sp+144h] [bp-40h]@1
  char v81; // [sp+148h] [bp-3Ch]@17

  v18 = 0.0;
  memset(&v80, 0, 0x3Cu);
  memset(&v49, 0, 0x5Cu);
  v14 = 5;
  v13 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0.0;
  v28 = 0.0;
  v29 = 0;
  v30 = 0;
  v31 = 0.0;
  v32 = 0.0;
  memset(&v76, 0, 0x50u);
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  v22 = 0;
  v23 = 0.0;
  v24 = 0;
  v33 = 0;
  v34 = 0.0;
  v35 = 0.0;
  result = a1 - 14;
  v17 = 6;
  LOBYTE(v15) = 0;
  switch ( (unsigned __int16)a1 )
  {
    case 0xEu:
    case 0xFu:
      if ( (!sub_1003F480((int)v2) || sub_1003F450()) && sub_100166F0(a1) )
      {
        sub_1002A470((int)&v40);
        LOBYTE(v15) = sub_10023DA0(a1, a2, &v49);
        if ( BYTE2(v43) )
        {
          if ( BYTE2(v43) == 1 )
            LOBYTE(v15) = 0;
        }
        else
        {
          LOBYTE(v49) = v40;
          LOBYTE(v15) = 1;
          v57 = 0;
          v53 = BYTE1(v40);
          v50 = BYTE1(v42);
          v51 = v42;
          BYTE3(v49) = BYTE3(v41);
          v61 = BYTE1(v40) >= 3u;
          if ( BYTE1(v42) == 3 || BYTE1(v42) == 2 )
            v62 = 0;
          else
            v62 = v44;
          v63 = v45;
          BYTE1(v49) = BYTE3(v40);
          v56 = sub_1002AD10();
          v52 = 0;
          BYTE2(v49) = sub_10035150(0);
          LOBYTE(v19) = 0;
          if ( v56 != 1 )
            LOBYTE(v19) = v56;
          v71 = sub_1002A710(v19);
          v54 = v41;
          sub_1002A950(&v17, &v20, &v68);
          v68 = v68 * 1852.0;
          v60 = sub_1002A7C0(&v67);
          if ( sub_1002AA10(0) )
          {
            v67 = 0.0;
            if ( sub_1003EB10(v4) == 1 )
              v60 = 0;
            if ( (unsigned __int8)sub_1003E9D0() == 1 && (!sub_1003F260(&v80) || !(v81 & 2)) )
              v60 = 0;
          }
          sub_1002AA80(0, 1, (float *)&v72);
          sub_1002AA80(1, 1, (float *)&v73);
          sub_1002BAA0(&v18, (float *)&v66);
          sub_1002BD60((float *)&v74);
          sub_1002C7A0(v49, (int)&v65, (int)&v64);
          sub_1002ABC0(1, (float *)&v65);
          sub_1002C7A0(COERCE_FLOAT(v43 - 1), (int)&v70, (int)&v69);
          v58 = sub_1002BA50(&v18);
          v59 = sub_1002BCE0(&v18, &v18, &v21);
          v55 = BYTE2(v41);
          sub_100421E0((int)&v75, &v46, 12);
        }
      }
      v5 = sub_1007C040();
      result = sub_10023190(a1, v15, a2, &v49, v5);
      break;
    case 0x26u:
    case 0x27u:
      v6 = sub_10048230(v2);
      v16 = v6;
      if ( v6 == 1 || v6 == 2 )
      {
        LOBYTE(v15) = 1;
        sub_10048430((int)&v22);
        v27 = v23;
        v29 = v24;
        LOBYTE(v25) = BYTE1(v22) == 0;
        BYTE1(v25) = BYTE2(v22) == 0;
        HIWORD(v25) = BYTE3(v22);
        if ( !BYTE3(v22) )
          LOBYTE(v26) = sub_10048260();
        if ( (unsigned __int8)sub_10041980() != 1 )
        {
          LOBYTE(v19) = (v16 == 2) + 3;
          sub_10047C60(v19, (int)&v76);
          if ( v79 != 0x3FFFF )
          {
            if ( !sub_1002A930() && sub_10047B50(3, v19, (int)&v76) )
              BYTE3(v25) = 1;
            v28 = v78;
            sub_10048200((int)&v30, v77);
          }
        }
      }
      v7 = sub_1007C040();
      result = sub_10023190(a1, v15, a2, &v25, v7);
      break;
    case 0x20u:
    case 0x21u:
      LOBYTE(v15) = sub_100162F0((int)&v36);
      v8 = sub_1007C040();
      result = sub_10023190(a1, v15, a2, &v36, v8);
      break;
    case 0x30u:
    case 0x31u:
      if ( !sub_1002A9C0((int)&v33) || (LOBYTE(v15) = 1, sub_10041CE0()) )
        LOBYTE(v15) = 0;
      v32 = v34;
      v31 = v35;
      v9 = sub_1007C040();
      result = sub_10023190(a1, v15, a2, &v31, v9);
      break;
    case 0x1Au:
    case 0x1Bu:
      v13 = sub_1003F450();
      LOBYTE(v11) = sub_1003F480(v10);
      v14 = sub_1003F0C0(v11, 0);
      v12 = sub_1007C040();
      result = sub_10023190(a1, 1, a2, &v13, v12);
      break;
    default:
      return result;
  }
  return result;
}

//----- (10017250) --------------------------------------------------------
void *sub_10017250()
{
  void *result; // eax@1

  result = memset(&unk_1022CE40, 0, 0xCB0u);
  byte_1022CE38 = 0;
  byte_1022CE39 = 0;
  dword_10332F58 = 0;
  dword_10332F5C = 0;
  return result;
}
// 1022CE38: using guessed type char byte_1022CE38;
// 1022CE39: using guessed type char byte_1022CE39;
// 10332F58: using guessed type int dword_10332F58;
// 10332F5C: using guessed type int dword_10332F5C;

//----- (10017280) --------------------------------------------------------
char __cdecl sub_10017280(int a1, int a2)
{
  void *v2; // ecx@0
  char v3; // bl@1
  void *v4; // ecx@1
  char result; // al@2
  char *v6; // esi@6
  void *v7; // [sp-2h] [bp-4h]@1

  v7 = v2;
  v3 = sub_10045280(v2);
  if ( sub_100429D0(v4) != 4 || (result = sub_100429F0(1)) != 0 )
  {
    result = a1 + 68;
    if ( (unsigned __int16)a1 == 700 )
    {
      if ( v3 == 1 )
        return result;
      v6 = &byte_1022CE38;
    }
    else
    {
      result = a1 + 67;
      if ( (unsigned __int16)a1 != 701 || !v3 )
        return result;
      v6 = &byte_1022CE39;
    }
    result = sub_10023DA0(a1, a2, (char *)&v7 + 3);
    if ( result )
    {
      if ( !*v6 && BYTE3(v7) == 1 )
        sub_1007C140(1, 0x4000000);
      result = BYTE3(v7);
      *v6 = BYTE3(v7);
    }
    else
    {
      *v6 = 0;
    }
  }
  return result;
}
// 1022CE38: using guessed type char byte_1022CE38;
// 1022CE39: using guessed type char byte_1022CE39;

//----- (10017310) --------------------------------------------------------
char __cdecl sub_10017310(void *a1)
{
  int v1; // eax@1
  void *v2; // ecx@1
  char v3; // al@2
  void *v4; // ecx@2
  char v5; // al@4
  char v7; // [sp+3h] [bp-5h]@1
  int v8; // [sp+4h] [bp-4h]@1

  v7 = 1;
  LOBYTE(v8) = (_WORD)a1 != 540;
  v1 = sub_1007C0D0(17);
  if ( v1 == 5 )
  {
    v3 = sub_1004A0B0(v2);
    if ( sub_100470F0(v3, 12) )
    {
      LOBYTE(a1) = 15;
    }
    else
    {
      v5 = sub_1004A0B0(v4);
      LOBYTE(v1) = sub_100470F0(v5, 16);
      if ( !(_BYTE)v1 )
        return v1;
      LOBYTE(a1) = 127;
    }
    LOBYTE(v1) = sub_1002D4F0(a1, &v7);
    if ( (_BYTE)v1 && v7 == 2 )
      LOBYTE(v1) = sub_10049B30(v8, 1);
  }
  return v1;
}

//----- (100173A0) --------------------------------------------------------
char __cdecl sub_100173A0(int a1, int a2)
{
  int v2; // ecx@0
  char result; // al@1
  int v4; // eax@2
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v2;
  result = sub_10038DD0((float *)&v5);
  if ( result )
  {
    v4 = sub_1007C040();
    result = sub_10023190(a1, 1, a2, &v5, v4);
  }
  return result;
}

//----- (100173E0) --------------------------------------------------------
char __cdecl sub_100173E0(int a1, int a2)
{
  int v2; // ecx@0
  char result; // al@1
  int v4; // eax@2
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v2;
  result = sub_10038EA0((float *)&v5);
  if ( result )
  {
    v4 = sub_1007C040();
    result = sub_10023190(a1, 1, a2, &v5, v4);
  }
  return result;
}

//----- (10017420) --------------------------------------------------------
char __cdecl sub_10017420(int a1, int a2)
{
  int v2; // eax@1
  char v4; // [sp+7h] [bp-5h]@1
  int v5; // [sp+8h] [bp-4h]@1

  LOBYTE(v5) = sub_1002D570(a1, (bool *)&v4);
  v2 = sub_1007C040();
  return sub_10023190(a1, v5, a2, &v4, v2);
}

//----- (10017460) --------------------------------------------------------
char __cdecl sub_10017460(int a1, int a2)
{
  int v2; // eax@1
  char v4; // [sp+7h] [bp-5h]@1
  int v5; // [sp+8h] [bp-4h]@1

  LOBYTE(v5) = sub_1002D5F0(a1, (bool *)&v4);
  v2 = sub_1007C040();
  return sub_10023190(a1, v5, a2, &v4, v2);
}

//----- (100174A0) --------------------------------------------------------
char sub_100174A0()
{
  char v0; // di@1
  void *v1; // esi@1
  int v2; // eax@2
  void *v3; // ecx@2
  int v4; // eax@3
  int v5; // eax@4
  char v6; // al@6
  char *v7; // esi@9
  bool v8; // cf@12
  int v9; // eax@14
  int v10; // eax@14
  signed int v11; // edi@16
  char *v12; // ebx@17
  __int16 v13; // ax@19
  unsigned int v14; // kr00_4@20
  int v15; // eax@21
  int v16; // eax@22
  int v17; // eax@22
  void *v18; // ecx@27
  int v19; // eax@36
  int v20; // eax@36
  int v21; // eax@46
  int v22; // eax@46
  int v24; // [sp+38h] [bp-250h]@3
  signed int v25; // [sp+38h] [bp-250h]@16
  char v26; // [sp+3Ch] [bp-24Ch]@9
  char v27; // [sp+3Ch] [bp-24Ch]@17
  char v28; // [sp+40h] [bp-248h]@3
  int v29; // [sp+44h] [bp-244h]@19
  int v30; // [sp+48h] [bp-240h]@11
  int v31; // [sp+4Ch] [bp-23Ch]@11
  int v32; // [sp+50h] [bp-238h]@21
  int v33; // [sp+54h] [bp-234h]@21
  char v34; // [sp+58h] [bp-230h]@29
  char v35; // [sp+59h] [bp-22Fh]@32
  char v36; // [sp+78h] [bp-210h]@32
  char v37; // [sp+97h] [bp-1F1h]@32
  char v38; // [sp+B0h] [bp-1D8h]@32
  __int16 v39; // [sp+E2h] [bp-1A6h]@32
  int v40; // [sp+E4h] [bp-1A4h]@32
  int v41; // [sp+E8h] [bp-1A0h]@36
  int v42; // [sp+ECh] [bp-19Ch]@34
  char v43; // [sp+F0h] [bp-198h]@39
  char v44; // [sp+F4h] [bp-194h]@40
  int v45; // [sp+FAh] [bp-18Eh]@41
  unsigned __int16 v46; // [sp+FCh] [bp-18Ch]@40
  int v47; // [sp+FEh] [bp-18Ah]@44
  unsigned __int16 v48; // [sp+100h] [bp-188h]@43
  unsigned __int16 v49; // [sp+10Eh] [bp-17Ah]@40
  char v50; // [sp+112h] [bp-176h]@40
  char v51; // [sp+11Fh] [bp-169h]@40
  char v52; // [sp+13Eh] [bp-14Ah]@40
  char v53; // [sp+158h] [bp-130h]@40
  int v54; // [sp+1CCh] [bp-BCh]@11
  int v55; // [sp+1D4h] [bp-B4h]@11
  char v56[31]; // [sp+1DCh] [bp-ACh]@11
  char v57; // [sp+1FBh] [bp-8Dh]@20
  char v58; // [sp+20Eh] [bp-7Ah]@20
  char v59; // [sp+210h] [bp-78h]@12
  char v60; // [sp+220h] [bp-68h]@19
  char v61; // [sp+244h] [bp-44h]@11
  int v62; // [sp+264h] [bp-24h]@11

  memset(&unk_1022CE40, 0, 0xCB0u);
  v0 = 0;
  v1 = &unk_1022CE40;
  do
  {
    v2 = sub_1007C6E0(v0);
    j_HWM_pvg_rgn_get_info(v2, v1);
    v1 = (char *)v1 + 232;
    ++v0;
  }
  while ( (signed int)v1 < (signed int)&dword_1022DAF0 );
  v4 = 0;
  v28 = 0;
  v24 = 0;
  do
  {
    v5 = v4 - 1;
    if ( v5 )
    {
      if ( v5 == 1 )
        v6 = 8;
      else
        v6 = 6;
    }
    else
    {
      v6 = 7;
    }
    v7 = (char *)&unk_1022CE40 + 232 * (unsigned __int8)v6;
    v26 = v6;
    if ( !v7[2]
      && !v7[44]
      && !sub_1007A1F0(
            v28,
            &v61,
            0x20u,
            (int)&v55,
            8u,
            (int)v56,
            0x33u,
            (int)&v62,
            0x20u,
            (int)&v31,
            (int)&v30,
            (int)&v54,
            5u) )
    {
      sub_1007A150(v28, &v59, 16);
      sub_100421E0((int)(v7 + 28), &v59, 16);
      sub_100421E0((int)(v7 + 44), &v55, 8);
      sub_100421E0((int)(v7 + 64), &v61, 28);
      sub_100421E0((int)(v7 + 92), v56, 32);
      sub_100421E0((int)(v7 + 156), &v62, 32);
      sub_100421E0((int)(v7 + 148), &v54, 8);
      v8 = HIWORD(v30) < 0x7C6u;
      *((_DWORD *)v7 + 47) = v31;
      if ( !v8 )
        *((_DWORD *)v7 + 48) = v30;
      v9 = sub_1007C6E0(v26);
      j_HWM_pvg_rgn_set_info(v9, 0, v7);
      v10 = sub_1007C6E0(v26);
      j_HWM_pvg_rgn_get_info(v10, v7);
    }
    LOBYTE(v3) = v28 + 1;
    v4 = v24 + 1;
    v8 = (unsigned __int8)(v28++ + 1) < 3u;
    ++v24;
  }
  while ( v8 );
  v11 = 0;
  v25 = 0;
  do
  {
    LOBYTE(v4) = v11 != 0;
    v4 = 4 * v4 + 5;
    v12 = (char *)&unk_1022CE40 + 232 * (unsigned __int8)v4;
    v27 = v4;
    if ( !v12[2] && !v12[44] )
    {
      v13 = sub_1007C6E0(v4);
      LOBYTE(v4) = sub_1002D8A0(v13, &v60, 33, (int)&v29);
      if ( (_BYTE)v4 )
      {
        sub_1002D9D0(v56, 7);
        sub_10042370(v12 + 44, 8u, "%.2f", (double)(signed __int16)v29 / 100.0);
        sub_100421E0((int)(v12 + 64), &v60, 28);
        v58 = 0;
        v14 = strlen(v56);
        memset(&v56[v14], 0, 51 - v14);
        qmemcpy(v12 + 92, v56, 0x20u);
        v12[123] = 0;
        sub_100421E0((int)(v12 + 156), &v57, 32);
        if ( v27 == 9 )
        {
          sub_1002DBF0(&v60, (int)&v54);
          sub_100421E0((int)(v12 + 148), &v54, 8);
          sub_1002DAB0((char *)&v33, (char *)&v32);
          v15 = v32;
          *((_DWORD *)v12 + 47) = v33;
          *((_DWORD *)v12 + 48) = v15;
        }
        v16 = sub_1007C6E0(v27);
        j_HWM_pvg_rgn_set_info(v16, 0, v12);
        v17 = sub_1007C6E0(v27);
        v4 = j_HWM_pvg_rgn_get_info(v17, v12);
        v11 = v25;
      }
      else
      {
        v12[2] = 12;
      }
    }
    v25 = ++v11;
  }
  while ( v11 < 2 );
  if ( !byte_1022D752 && !byte_1022D7E4 )
  {
    if ( sub_100429D0(v3) & 0xC || (LOBYTE(v4) = sub_100429D0(v18), v4 & 3) )
    {
      LOBYTE(v4) = sub_1002D750(&v34);
      if ( !(_BYTE)v4 || (_BYTE)v4 == 3 && (LOBYTE(v4) = sub_1002D670(), (_BYTE)v4 == 7) )
      {
        sub_100421E0((int)&unk_1022D784, &v36, 12);
        sub_100421E0((int)&unk_1022D790, &v35, 28);
        sub_100421E0((int)&unk_1022D7AC, &v37, 32);
        sub_100421E0((int)&unk_1022D7EC, &v38, 32);
        sub_10042370(&byte_1022D7E4, 8u, "%04d", v39);
        if ( (unsigned __int8)v40 > 0xCu )
          v40 = -57588;
        if ( (unsigned __int8)v42 > 0xCu )
          v42 = -57588;
        dword_1022D80C = v40;
        dword_1022D810 = v41;
        dword_1022D814 = v42;
        v19 = sub_1007C6E0(10);
        j_HWM_pvg_rgn_set_info(v19, 0, &unk_1022D750);
        v20 = sub_1007C6E0(10);
        LOBYTE(v4) = j_HWM_pvg_rgn_get_info(v20, &unk_1022D750);
      }
    }
  }
  if ( !byte_1022D83A && !byte_1022D864 )
  {
    LOBYTE(v4) = sub_100010B0(&v43);
    if ( (_BYTE)v4 )
    {
      sub_100421E0((int)&unk_1022D854, &v50, 16);
      sub_10042370(&byte_1022D864, 8u, "%.2f", (double)v49 / 100.0);
      sub_100421E0((int)&unk_1022D878, &v51, 28);
      sub_100421E0((int)&unk_1022D894, &v52, 32);
      sub_100421E0((int)&unk_1022D8D4, &v53, 32);
      sub_100421E0((int)&unk_1022D8CC, &v44, 8);
      if ( v46 < 0x7C6u )
        dword_1022D8F4 = 130416897;
      else
        dword_1022D8F4 = v45;
      if ( v48 < 0x7C6u )
        dword_1022D8F8 = 130416897;
      else
        dword_1022D8F8 = v47;
      byte_1022D8FD = 1;
      byte_1022D8FC = 1;
      word_1022D8FE = 1990;
      v21 = sub_1007C6E0(11);
      j_HWM_pvg_rgn_set_info(v21, 0, &unk_1022D838);
      v22 = sub_1007C6E0(11);
      LOBYTE(v4) = j_HWM_pvg_rgn_get_info(v22, &unk_1022D838);
    }
  }
  return v4;
}
// 1007C740: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);
// 1007C750: using guessed type int __cdecl j_HWM_pvg_rgn_set_info(_DWORD, _DWORD, _DWORD);
// 1022D752: using guessed type char byte_1022D752;
// 1022D80C: using guessed type int dword_1022D80C;
// 1022D810: using guessed type int dword_1022D810;
// 1022D814: using guessed type int dword_1022D814;
// 1022D83A: using guessed type char byte_1022D83A;
// 1022D8F4: using guessed type int dword_1022D8F4;
// 1022D8F8: using guessed type int dword_1022D8F8;
// 1022D8FC: using guessed type char byte_1022D8FC;
// 1022D8FD: using guessed type char byte_1022D8FD;
// 1022D8FE: using guessed type __int16 word_1022D8FE;
// 1022DAF0: using guessed type int dword_1022DAF0;

//----- (10017B20) --------------------------------------------------------
char __cdecl sub_10017B20(int a1)
{
  char result; // al@1
  void *v2; // ecx@2
  int v3; // edx@3
  void *v4; // ecx@4
  void *v5; // ecx@4
  void *v6; // ecx@4
  void *v7; // [sp+4h] [bp-8h]@1
  int v8; // [sp+8h] [bp-4h]@1

  result = 0;
  v7 = 0;
  v8 = 0;
  if ( a1 )
  {
    *(_DWORD *)a1 = 0;
    if ( !sub_1007C3B0(2, (int)&v7, 8) )
    {
      v2 = v7;
      v3 = v8;
      *(_DWORD *)(a1 + 4) = v7;
      *(_DWORD *)(a1 + 8) = v3;
    }
    *(_BYTE *)(a1 + 12) = sub_100460C0(v2);
    *(_BYTE *)(a1 + 13) = sub_10046100(v4);
    *(_BYTE *)(a1 + 14) = sub_100460E0(v5);
    *(_BYTE *)(a1 + 15) = sub_10045EA0(v6);
    *(_WORD *)(a1 + 16) = j_HWM_pvg_get_frmt_adc(2);
    *(_WORD *)(a1 + 18) = j_HWM_pvg_get_frmt_adc(15);
    *(_WORD *)(a1 + 20) = j_HWM_pvg_get_frmt_adc(16);
    *(_WORD *)(a1 + 3272) = sub_1007C870();
    *(_WORD *)(a1 + 3274) = j_HWM_pvg_get_anlg_outp(3);
    result = sub_100174A0();
    qmemcpy((void *)(a1 + 24), &unk_1022CE40, 0xCB0u);
  }
  return result;
}
// 1007C7E0: using guessed type int __cdecl j_HWM_pvg_get_anlg_outp(_DWORD);
// 1007C7F0: using guessed type int __cdecl j_HWM_pvg_get_frmt_adc(_DWORD);

//----- (10017BE0) --------------------------------------------------------
char __cdecl sub_10017BE0(float a1, int a2)
{
  int v2; // edi@1
  char result; // al@2
  int v4; // esi@3
  char v5; // al@3
  bool v6; // zf@3
  unsigned int v7; // ecx@8
  int v8; // ebx@8
  int v9; // eax@13
  char v10; // [sp+13h] [bp-5h]@1
  int v11; // [sp+14h] [bp-4h]@3

  v2 = LODWORD(a1);
  v10 = 0;
  if ( LOWORD(a1) == 1011 )
  {
    v4 = a2;
    LOBYTE(v11) = sub_10023DA0(949, a2, &a1);
    if ( *(_BYTE *)dword_10337080 == 38 )
    {
      if ( a1 >= 5.8400002 && a1 <= 10.84 )
        goto LABEL_11;
    }
    else if ( a1 >= 370.0 )
    {
LABEL_11:
      dword_10332F58 = 0;
      goto LABEL_12;
    }
    v7 = dword_10332F58++ + 1;
    v8 = *(_WORD *)(*(_DWORD *)(v4 + 40) + 2022);
LABEL_18:
    if ( v7 >= 0x1388u / *(_DWORD *)(52 * v8 + *(_DWORD *)(v4 + 32) + 12) )
      v10 = 1;
    goto LABEL_13;
  }
  result = LOBYTE(a1) + 12;
  if ( LOWORD(a1) != 1012 )
    return result;
  v4 = a2;
  v5 = sub_10023DA0(950, a2, &a1);
  v6 = *(_BYTE *)dword_10337080 == 38;
  LOBYTE(v11) = v5;
  if ( v6 )
  {
    if ( a1 >= 5.8400002 && a1 <= 10.84 )
      goto LABEL_5;
    goto LABEL_8;
  }
  if ( a1 < 370.0 )
  {
LABEL_8:
    v7 = dword_10332F5C++ + 1;
    v8 = *(_WORD *)(*(_DWORD *)(v4 + 40) + 2024);
    goto LABEL_18;
  }
LABEL_5:
  dword_10332F5C = 0;
LABEL_12:
  v10 = 0;
LABEL_13:
  v9 = sub_1007C040();
  return sub_10023190(v2, v11, v4, &v10, v9);
}
// 10332F58: using guessed type int dword_10332F58;
// 10332F5C: using guessed type int dword_10332F5C;
// 10337080: using guessed type int dword_10337080;

//----- (10017DB0) --------------------------------------------------------
char sub_10017DB0()
{
  void *v0; // ecx@1
  void *v1; // ecx@1

  sub_10024570();
  sub_10018D00();
  sub_1004A190(v0);
  sub_1004A120();
  sub_1004A100();
  sub_10041810();
  sub_1004A0F0();
  sub_100437B0();
  sub_10027840();
  sub_100424C0();
  sub_1007CD60((LONG)&off_100A1308);
  *(_DWORD *)dword_10333D68 = 0;
  memset((void *)(dword_10333D68 + 4), 0, 0xA14u);
  sub_1007C8F0((int)&off_100A1308);
  return sub_10013040(v1);
}
// 100A1308: using guessed type char *off_100A1308;
// 10333D68: using guessed type int dword_10333D68;

//----- (10017E20) --------------------------------------------------------
unsigned int __usercall sub_10017E20@<eax>(int a1@<eax>)
{
  unsigned int result; // eax@1
  char v2; // bl@2
  int v3; // esi@2
  char v4; // [sp+0h] [bp-4h]@2

  result = *(_DWORD *)(a1 + 4) - 10014;
  if ( result <= 1 )
  {
    v2 = 0;
    v4 = 0;
    v3 = 0;
    do
    {
      result = sub_1004DCB0();
      if ( (_BYTE)result )
      {
        sub_1004DCF0(v4, (void *)(v3 + dword_103334F4 + 4));
        result = sub_1004DCA0();
      }
      ++v2;
      v3 += 36;
      v4 = v2;
    }
    while ( (unsigned __int8)v2 < 6u );
  }
  return result;
}
// 103334F4: using guessed type int dword_103334F4;

//----- (10017E40) --------------------------------------------------------
int sub_10017E40()
{
  int result; // eax@1
  signed int v1; // edi@9
  char *v2; // esi@9
  int v3; // edx@15
  unsigned int v4; // eax@19
  int v5; // [sp-Ch] [bp-548h]@25
  char v6; // [sp-8h] [bp-544h]@25
  char v7; // [sp+Ch] [bp-530h]@1
  unsigned __int16 v8; // [sp+10h] [bp-52Ch]@1
  char v9[4]; // [sp+14h] [bp-528h]@6
  int v10; // [sp+18h] [bp-524h]@6
  int v11; // [sp+1Ch] [bp-520h]@34
  int v12; // [sp+20h] [bp-51Ch]@34
  int v13; // [sp+24h] [bp-518h]@37
  int v14; // [sp+28h] [bp-514h]@37
  unsigned __int16 v15; // [sp+2Ch] [bp-510h]@37
  int v16; // [sp+2Eh] [bp-50Eh]@37
  int v17; // [sp+A0h] [bp-49Ch]@34
  int v18; // [sp+A4h] [bp-498h]@34
  int v19; // [sp+A8h] [bp-494h]@34
  int v20; // [sp+ACh] [bp-490h]@34
  size_t v21; // [sp+530h] [bp-Ch]@24

  for ( result = sub_1007BFF0((int)&v8, (int)&v7); result != 1; result = sub_1007BFF0((int)&v8, (int)&v7) )
  {
    if ( (signed int)v8 > 32769 )
    {
      switch ( v8 )
      {
        case 0x8013u:
          switch ( v9[1] )
          {
            case 8:
            case 9:
            case 0xA:
            case 0xB:
            case 0x13:
            case 0x20:
            case 0x22:
            case 0x23:
            case 0x24:
            case 0x25:
            case 0x32:
              sub_10018B60(v9[0], v9[1], v9[2], v9[3], (int)&v10, (char *)&v10 + 3, v21);
              break;
            default:
              v6 = 0;
              v5 = 716;
              goto LABEL_39;
          }
          break;
        case 0x8002u:
          sub_10023790(*(int *)v9, v10, (int)&byte_10332F00);
          break;
        case 0x800Bu:
          sub_10024550();
          break;
        case 0x8011u:
          sub_10025450(v9[0], (int)&byte_10332F00);
          break;
        case 0x8015u:
          sub_10028D50(v9[0], v9[1], &v9[2]);
          break;
        case 0x8029u:
          sub_10020190((int)v9);
          break;
        case 0x8037u:
          sub_1001EC50(v9[0]);
          break;
        case 0x8038u:
          sub_1001EC90(*(int *)v9);
          break;
        case 0x804Cu:
          sub_1001AAB0(v9[0], (int)&v10);
          break;
        case 0x8006u:
          sub_10026940(v20, v10, v9[0], v11, (const char *)&v12, v17, v18, *(__int16 *)&v9[2], v19);
          break;
        case 0x8007u:
          sub_100269B0(1);
          break;
        case 0x803Fu:
          sub_10023FE0(*(int *)v9, (int)&v10 + 2, v10, 1, 1);
          break;
        case 0x8048u:
          sub_10018590(*(int *)v9, v10, v11, v12, v13, v14, v15, v16);
          break;
        default:
          goto LABEL_38;
      }
    }
    else
    {
      if ( (signed int)v8 >= 0x8000 )
      {
        if ( v8 == -32767 )
        {
          v1 = *(_DWORD *)v9;
          v2 = (char *)&v10;
        }
        else
        {
          v2 = v9;
          v1 = (HIWORD(v10) + 15) & 0xFFFFFFFC;
        }
        while ( 1 )
        {
          if ( v2[4] )
            sub_100234A0(
              *((_WORD *)v2 + 1),
              *((_WORD *)v2 + 3),
              v2[1],
              (int)&byte_10332F00,
              v2 + 12,
              *((_DWORD *)v2 + 2));
          else
            sub_10023190(*((_WORD *)v2 + 1), v2[1], (int)&byte_10332F00, v2 + 12, *((_DWORD *)v2 + 2));
          if ( *v2 == 1 )
          {
            v3 = *((_WORD *)v2 + 1);
            if ( v3 > dword_10332F04 || *(_WORD *)(dword_10332F28 + 2 * *((_WORD *)v2 + 1)) > *((_WORD *)v2 + 1) )
              goto LABEL_40;
            if ( *(_DWORD *)(52 * *(_WORD *)(dword_10332F28 + 2 * v3) + dword_10332F20 + 36) )
              (*(void (__cdecl **)(_DWORD, char *))(52 * *(_WORD *)(dword_10332F28 + 2 * *((_WORD *)v2 + 1))
                                                  + dword_10332F20
                                                  + 36))(
                *((_WORD *)v2 + 1),
                &byte_10332F00);
          }
          v4 = (*((_WORD *)v2 + 3) + 15) & 0xFFFFFFFC;
          v2 += v4;
          v1 -= v4;
          if ( !*((_WORD *)v2 + 3) || v1 <= 0 )
            goto LABEL_40;
        }
      }
      if ( v8 == 1 )
      {
        sub_10017E20((int)&v8);
      }
      else if ( v8 == 2 )
      {
        sub_10027CE0(*(int *)v9, v10, 0xFFFFFFF);
      }
      else
      {
LABEL_38:
        v6 = 0;
        v5 = 937;
LABEL_39:
        sub_10042930("..\\lib\\adl\\iop_c_main.c", v5, v6, 0);
      }
    }
LABEL_40:
    ;
  }
  return result;
}
// 10332F00: using guessed type char byte_10332F00;
// 10332F04: using guessed type int dword_10332F04;
// 10332F20: using guessed type int dword_10332F20;
// 10332F28: using guessed type int dword_10332F28;

//----- (10018290) --------------------------------------------------------
void __usercall __noreturn sub_10018290(int a1@<edi>)
{
  char v1; // bl@1
  signed int v2; // esi@11
  void *v3; // ecx@19
  int *v4; // ecx@20
  char v5; // [sp+Ch] [bp-ECh]@1
  char v6; // [sp+Dh] [bp-EBh]@1
  char v7; // [sp+Eh] [bp-EAh]@1
  char v8; // [sp+Fh] [bp-E9h]@1
  int v9; // [sp+10h] [bp-E8h]@1
  char v10; // [sp+14h] [bp-E4h]@3

  v6 = 1;
  v9 = 0;
  v1 = 4;
  v8 = 20;
  v7 = 40;
  v5 = 100;
  if ( !sub_1007C210(33, 10000) )
    sub_10042930("..\\lib\\adl\\iop_c_main.c", 383, 1, 0);
  sub_1004AEA0();
  sub_1004AAA0(&v10);
  sub_1007C280(&v9);
  while ( 1 )
  {
    sub_1007C280(&v9);
    if ( v9 & 1 )
    {
      sub_10022A00((int)&byte_10332F00);
      sub_10022E00((int)&byte_10332F00);
      if ( --v8 <= 0 )
      {
        sub_10023CE0((int)&byte_10332F00);
        sub_100132A0();
        sub_10013430();
        v8 = 20;
      }
      if ( --v7 <= 0 )
      {
        sub_1004A990((int *)&v10);
        v7 = 40;
      }
      if ( --v1 <= 0 )
      {
        if ( --v5 <= 0 )
        {
          v2 = 0;
          do
          {
            a1 = (unsigned __int16)v2;
            sub_10020680(v2);
            sub_10020680(v2++);
          }
          while ( v2 < 4 );
          v5 = 100;
          if ( v6 )
          {
            if ( byte_10333D54 != 1 || (unsigned int)sub_1007C040() >= 0x493E0 )
            {
              v6 = 0;
            }
            else
            {
              v6 = sub_1003BCE0(0);
              if ( !v6 )
                sub_1003C070();
            }
          }
        }
        sub_1001CF40();
        sub_10025B50(v3);
        sub_10027DE0();
        sub_100131F0(a1);
        v1 = 4;
      }
      sub_10019100();
      sub_100277B0(v4);
    }
    if ( v9 & 2 )
      sub_10017E40();
  }
}
// 1004AEA0: using guessed type int sub_1004AEA0(void);
// 10332F00: using guessed type char byte_10332F00;
// 10333D54: using guessed type char byte_10333D54;

//----- (10018440) --------------------------------------------------------
signed int __cdecl sub_10018440(int a1)
{
  signed int result; // eax@1

  result = 4;
  if ( a1 == 16 )
  {
    sub_10013030();
    result = 0;
  }
  return result;
}

//----- (10018460) --------------------------------------------------------
signed int __cdecl sub_10018460(int a1)
{
  signed int result; // eax@1
  unsigned __int8 v2; // bl@1

  result = 4;
  v2 = 0;
  do
  {
    if ( result != 4 )
      break;
    result = (*(&off_100A142C + v2++))(a1);
  }
  while ( v2 < 1u );
  return result;
}
// 100A142C: using guessed type int (__cdecl *off_100A142C)(int);

//----- (100184A0) --------------------------------------------------------
char **sub_100184A0()
{
  return off_100A1418;
}
// 100A1418: using guessed type char *off_100A1418[3];

//----- (100184B0) --------------------------------------------------------
char __usercall sub_100184B0@<al>(char a1@<dl>, int a2@<ecx>, int a3)
{
  __int16 v4; // [sp+0h] [bp-52Ch]@1
  int v5; // [sp+4h] [bp-528h]@1
  int v6; // [sp+8h] [bp-524h]@1
  char v7; // [sp+Ch] [bp-520h]@1

  v5 = a3;
  v4 = -32697;
  v6 = a2;
  v7 = a1;
  return sub_100477A0((int)&v4);
}

//----- (10018500) --------------------------------------------------------
char __cdecl sub_10018500(int a1, int a2, char a3)
{
  return sub_100184B0(a3, a2, a1);
}

//----- (10018520) --------------------------------------------------------
char __cdecl sub_10018520(int a1, int a2)
{
  char result; // al@1
  int v3; // eax@2
  char v4; // [sp+8h] [bp-14h]@2
  char v5; // [sp+Ch] [bp-10h]@1
  int v6; // [sp+10h] [bp-Ch]@1
  char v7; // [sp+14h] [bp-8h]@2

  result = sub_10023DC0(a1, a2, &v6, (unsigned __int16 *)&v5);
  if ( result )
  {
    v3 = sub_10022640(a1, a2);
    v4 = 2;
    if ( !v7 )
      v4 = 3;
    result = sub_10018500(v3, v6, v4);
  }
  return result;
}

//----- (10018590) --------------------------------------------------------
char __cdecl sub_10018590(int a1, int a2, int a3, int a4, int a5, int a6, unsigned __int16 a7, char a8)
{
  int v8; // eax@1
  char result; // al@1
  int v10; // [sp+4h] [bp-18h]@1
  int v11; // [sp+8h] [bp-14h]@1
  int v12; // [sp+Ch] [bp-10h]@1
  int v13; // [sp+10h] [bp-Ch]@1
  int v14; // [sp+14h] [bp-8h]@1

  v10 = a2;
  v11 = a3;
  v12 = a4;
  v13 = a5;
  v14 = a6;
  v8 = sub_1007C040();
  sub_100234A0(2625, a7, 1, (int)&byte_10332F00, &v10, v8);
  result = sub_10023790(2625, a1, (int)&byte_10332F00);
  if ( a8 )
    result = sub_10018500(a1, v10, 1);
  return result;
}
// 10332F00: using guessed type char byte_10332F00;

//----- (10018630) --------------------------------------------------------
int __cdecl sub_10018630(char a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@1

  v2 = sub_10046400(a1, 11, 1);
  sub_1007C580(v2, a2, 36);
  v3 = sub_10046400(a1, 11, 0);
  return sub_1007C580(v3, a2 + 36, 32);
}

//----- (10018680) --------------------------------------------------------
char __cdecl sub_10018680(int a1, int a2)
{
  return sub_1007C5E0(a1, a2, 10384);
}

//----- (100186A0) --------------------------------------------------------
int __cdecl sub_100186A0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100464B0(a1);
  return sub_1007C580(v2, a2, 60);
}

//----- (100186C0) --------------------------------------------------------
int __cdecl sub_100186C0(int a1)
{
  return sub_1007C580(6453, a1, 5);
}

//----- (100186E0) --------------------------------------------------------
int sub_100186E0()
{
  int result; // eax@1

  result = 0;
  dword_102332FC = 0;
  dword_1022DAF4 = 0;
  return result;
}
// 1022DAF4: using guessed type int dword_1022DAF4;
// 102332FC: using guessed type int dword_102332FC;

//----- (100186F0) --------------------------------------------------------
char sub_100186F0()
{
  return *(_BYTE *)(dword_102332F8 + 3);
}
// 102332F8: using guessed type int dword_102332F8;

//----- (10018700) --------------------------------------------------------
int sub_10018700()
{
  return dword_1022DAF4;
}
// 1022DAF4: using guessed type int dword_1022DAF4;

//----- (10018710) --------------------------------------------------------
char sub_10018710()
{
  return *(_BYTE *)(dword_102332F8 + 1);
}
// 102332F8: using guessed type int dword_102332F8;

//----- (10018720) --------------------------------------------------------
void sub_10018720()
{
  ++dword_1022DAF4;
}
// 1022DAF4: using guessed type int dword_1022DAF4;

//----- (10018730) --------------------------------------------------------
int (__cdecl *sub_10018730())(_DWORD)
{
  unsigned int v0; // esi@1
  int (__cdecl *result)(_DWORD); // eax@2

  v0 = 0;
  do
  {
    result = *(int (__cdecl **)(_DWORD))((char *)&off_100A3E28 + v0);
    if ( result )
      result = (int (__cdecl *)(_DWORD))result((unsigned __int8)byte_100A3E00[v0]);
    v0 += 44;
  }
  while ( v0 < 0x1E4 );
  return result;
}
// 100A3E28: using guessed type int (*off_100A3E28)();

//----- (10018760) --------------------------------------------------------
int __cdecl sub_10018760(char a1, char a2, char a3, char a4, int a5, void *a6, size_t a7)
{
  int v7; // eax@2
  int result; // eax@6

  *(_BYTE *)(dword_102332F8 + 3) = a3;
  if ( a5 )
  {
    v7 = dword_102332F8 + 5;
    *(_WORD *)v7 = *(_WORD *)a5;
    *(_BYTE *)(v7 + 2) = *(_BYTE *)(a5 + 2);
  }
  if ( a7 > 0x27100 )
  {
    *(_DWORD *)(dword_102332F8 + 160008) = 0;
    sub_10042930("..\\lib\\adl\\iop_cnfg_mngr.c", 1412, 0, 0);
  }
  else
  {
    memcpy((void *)(dword_102332F8 + 8), a6, a7);
    *(_DWORD *)(dword_102332F8 + 160008) = a7;
  }
  result = dword_102332F8;
  *(_BYTE *)(dword_102332F8 + 4) = a4;
  LOBYTE(result) = a2;
  *(_BYTE *)(dword_102332F8 + 2) = a2;
  *(_BYTE *)(dword_102332F8 + 1) = a1;
  return result;
}
// 102332F8: using guessed type int dword_102332F8;

//----- (10018810) --------------------------------------------------------
void *__cdecl sub_10018810(int a1)
{
  int v1; // eax@7
  int (__cdecl *v2)(_DWORD, _DWORD, _DWORD, int, int, int); // ecx@8
  void *result; // eax@9

  *(_BYTE *)dword_102332F8 = a1;
  switch ( (unsigned __int8)a1 )
  {
    case 7u:
      dword_1022DAF0 = sub_1007C040();
      break;
    case 8u:
      dword_10233304 = sub_1007C040();
      break;
    case 9u:
      dword_10233308 = sub_1007C040();
      break;
  }
  v1 = sub_10043FF0((_DWORD *)(dword_102332F8 + 2), 1u, (int)byte_100A3E00, 44, 11, 57);
  if ( v1 >= 57
    || (v2 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, int, int, int))*(&off_100A3E20 + 11 * v1)) == 0
    || (result = (void *)v2(
                           *(_BYTE *)(dword_102332F8 + 2),
                           *(_BYTE *)(dword_102332F8 + 3),
                           *(_BYTE *)(dword_102332F8 + 4),
                           dword_102332F8 + 5,
                           a1,
                           dword_102332F8 + 160012),
        !(_BYTE)result) )
  {
    result = memset((void *)(dword_102332F8 + 160012), 0, 0x64u);
  }
  return result;
}
// 100A3E20: using guessed type int (__cdecl *off_100A3E20)(char, int, int, int, char, char *);
// 1022DAF0: using guessed type int dword_1022DAF0;
// 102332F8: using guessed type int dword_102332F8;
// 10233304: using guessed type int dword_10233304;
// 10233308: using guessed type int dword_10233308;

//----- (100188D0) --------------------------------------------------------
signed int __usercall sub_100188D0@<eax>(unsigned int a1@<eax>, int a2, char *a3, unsigned __int16 a4)
{
  __int16 v4; // bx@1
  unsigned int v5; // edx@1
  unsigned int v6; // esi@1
  signed int result; // eax@2
  void *v8; // eax@3
  unsigned int v9; // ecx@5
  int v10; // edx@13
  signed int v11; // ebx@13
  char *v12; // ecx@14
  int v13; // esi@14
  int v14; // eax@18
  unsigned int v15; // edi@18
  int v16; // eax@19
  unsigned int v17; // edx@19
  int v18; // eax@20
  int v19; // ecx@23
  bool v20; // cf@34
  char v21; // [sp+Ah] [bp-96h]@17
  char v22; // [sp+Bh] [bp-95h]@17
  int v23; // [sp+Ch] [bp-94h]@1
  int v24; // [sp+10h] [bp-90h]@18
  char *v25; // [sp+14h] [bp-8Ch]@14
  int v26; // [sp+18h] [bp-88h]@13
  int v27[32]; // [sp+20h] [bp-80h]@7

  v4 = word_10332EE0;
  v5 = 0;
  v6 = a1;
  v23 = 0;
  if ( word_10332EE0 == 1491 )
  {
    result = 0;
  }
  else
  {
    v8 = &unk_10332CE0;
    do
    {
      if ( *((_WORD *)v8 + 2) == v4 )
      {
        v9 = *(_WORD *)v8;
        if ( v6 >= v9 && v6 < v9 + *((_WORD *)v8 + 1) )
        {
          v27[v23++] = (int)v8;
          if ( *((_DWORD *)v8 + 2) == -1 && *((_DWORD *)v8 + 3) == -1 )
            return 0;
        }
      }
      v5 += 16;
      v8 = (char *)v8 + 16;
    }
    while ( v5 < 0x200 );
    if ( v23 )
    {
      v10 = 0;
      v11 = 0;
      v26 = 0;
      if ( a4 )
      {
        v12 = a3;
        v13 = a2 - (_DWORD)a3;
        v25 = a3;
        while ( !v11 )
        {
          v22 = v12[v13];
          v21 = *v12;
          if ( v22 != *v12 )
          {
            v14 = 0;
            v15 = 8 * v10;
            v11 = -34;
            v24 = 0;
            if ( v23 > 0 )
            {
              while ( 1 )
              {
                v16 = v27[v14];
                v17 = *(_DWORD *)(v16 + 8);
                if ( v15 + 7 >= v17 )
                {
                  v18 = *(_DWORD *)(v16 + 12);
                  if ( v15 < v18 + v17 )
                    break;
                }
LABEL_31:
                v14 = v24++ + 1;
                if ( v24 >= v23 )
                  goto LABEL_34;
              }
              if ( v17 & 7 || v18 & 7 )
              {
                v19 = 0;
                while ( 1 )
                {
                  if ( (1 << v19) & (unsigned __int8)(v21 ^ v22) )
                  {
                    if ( v19 + v15 < v17 || v19 + v15 >= v18 + v17 )
                    {
                      v11 = -34;
                      goto LABEL_31;
                    }
                    v11 = 0;
                  }
                  if ( (unsigned int)++v19 >= 8 )
                    goto LABEL_31;
                }
              }
              v11 = 0;
            }
          }
LABEL_34:
          v10 = v26 + 1;
          v12 = v25 + 1;
          v20 = v26++ + 1 < (unsigned int)a4;
          ++v25;
          if ( !v20 )
          {
            if ( !v11 )
              goto LABEL_37;
            break;
          }
          v13 = a2 - (_DWORD)a3;
        }
        sub_10042930("..\\lib\\adl\\iop_cnfg_mngr.c", 2449, 0, "no perm for reg_tag bits\n");
      }
LABEL_37:
      result = v11;
    }
    else
    {
      sub_10042930("..\\lib\\adl\\iop_cnfg_mngr.c", 2367, 0, "no perm for reg_tag\n");
      result = -34;
    }
  }
  return result;
}
// 10332EE0: using guessed type __int16 word_10332EE0;
// 100188D0: using guessed type int var_80[32];

//----- (10018AB0) --------------------------------------------------------
signed int sub_10018AB0()
{
  signed int result; // eax@2

  if ( sub_1007CD60((LONG)&off_100A3FE4) )
  {
    *(_BYTE *)dword_102332F8 = 0;
    *(_BYTE *)(dword_102332F8 + 2) = 67;
    result = sub_1007C8F0((int)&off_100A3FE4);
  }
  else
  {
    sub_10042930("..\\lib\\adl\\iop_cnfg_mngr.c", 2504, 1, 0);
    result = sub_1007C8F0((int)&off_100A3FE4);
  }
  return result;
}
// 100A3FE4: using guessed type char *off_100A3FE4;
// 102332F8: using guessed type int dword_102332F8;

//----- (10018B00) --------------------------------------------------------
void *sub_10018B00()
{
  void *result; // eax@1

  result = (void *)(sub_1007C040() - dword_10233308);
  if ( (unsigned int)result >= 0x2710 )
    result = sub_10018810(0);
  return result;
}
// 10233308: using guessed type int dword_10233308;

//----- (10018B20) --------------------------------------------------------
void *sub_10018B20()
{
  void *result; // eax@1

  result = (void *)(sub_1007C040() - dword_1022DAF0);
  if ( (unsigned int)result >= 0x2710 )
    result = sub_10018810(0);
  return result;
}
// 1022DAF0: using guessed type int dword_1022DAF0;

//----- (10018B40) --------------------------------------------------------
void *sub_10018B40()
{
  void *result; // eax@1

  result = (void *)(sub_1007C040() - dword_10233304);
  if ( (unsigned int)result >= 0x2710 )
    result = sub_10018810(0);
  return result;
}
// 10233304: using guessed type int dword_10233304;

//----- (10018B60) --------------------------------------------------------
char __cdecl sub_10018B60(char a1, char a2, char a3, char a4, int a5, void *a6, size_t a7)
{
  int v7; // eax@5
  char result; // al@9

  if ( *(_BYTE *)dword_102332F8 == 11 )
    sub_1004AED0();
  if ( *(_BYTE *)dword_102332F8 )
    sub_10018810(0);
  *(_BYTE *)(dword_102332F8 + 3) = a3;
  v7 = dword_102332F8 + 5;
  *(_WORD *)v7 = *(_WORD *)a5;
  *(_BYTE *)(v7 + 2) = *(_BYTE *)(a5 + 2);
  if ( a7 >= 0x27100 )
  {
    *(_DWORD *)(dword_102332F8 + 160008) = 0;
    sub_10042930("..\\lib\\adl\\iop_cnfg_mngr.c", 1198, 0, 0);
  }
  else
  {
    memcpy((void *)(dword_102332F8 + 8), a6, a7);
    *(_DWORD *)(dword_102332F8 + 160008) = a7;
    *(_BYTE *)(dword_102332F8 + a7 + 8) = 0;
  }
  *(_BYTE *)(dword_102332F8 + 4) = a4;
  *(_BYTE *)(dword_102332F8 + 2) = a2;
  *(_BYTE *)(dword_102332F8 + 1) = a1;
  dword_102332FC = 0;
  dword_1022DAF4 = 0;
  byte_10233300 = 0;
  switch ( a1 )
  {
    case 0:
      result = (unsigned int)sub_10018810(9);
      break;
    case 1:
      result = (unsigned int)sub_10018810(5);
      byte_10233300 = 1;
      break;
    case 2:
      result = (unsigned int)sub_10018810(2);
      break;
    case 3:
      result = (unsigned int)sub_10018810(1);
      break;
    case 4:
    case 6:
      result = (unsigned int)sub_10018810(6);
      break;
    case 5:
      if ( a3 )
        goto LABEL_16;
      result = (unsigned int)sub_10018810(6);
      goto LABEL_17;
    case 7:
LABEL_16:
      result = (unsigned int)sub_10018810(2);
LABEL_17:
      if ( a4 == 11 )
        byte_10233300 = 1;
      break;
    default:
      result = sub_10042930("..\\lib\\adl\\iop_cnfg_mngr.c", 1301, 0, 0);
      break;
  }
  return result;
}
// 1022DAF4: using guessed type int dword_1022DAF4;
// 102332F8: using guessed type int dword_102332F8;
// 102332FC: using guessed type int dword_102332FC;
// 10233300: using guessed type char byte_10233300;

//----- (10018D00) --------------------------------------------------------
void *sub_10018D00()
{
  void *result; // eax@1

  dword_102332F8 = -15;
  sub_10018AB0();
  result = memset(&unk_10332CE0, 0, 0x200u);
  word_10332EE0 = 0;
  dword_10233308 = 0;
  dword_1022DAF0 = 0;
  dword_10233304 = 0;
  dword_1023330C = 0;
  return result;
}
// 1022DAF0: using guessed type int dword_1022DAF0;
// 102332F8: using guessed type int dword_102332F8;
// 10233304: using guessed type int dword_10233304;
// 10233308: using guessed type int dword_10233308;
// 1023330C: using guessed type int dword_1023330C;
// 10332EE0: using guessed type __int16 word_10332EE0;

//----- (10018D50) --------------------------------------------------------
char __usercall sub_10018D50@<al>(char *a1@<eax>, int a2@<ebx>, unsigned __int16 a3@<di>, unsigned int a4)
{
  char *v4; // esi@1
  signed int v5; // eax@1
  unsigned int v6; // eax@2
  _DWORD *v7; // ecx@2
  char *v8; // edx@2
  int v9; // esi@6
  int v10; // eax@7
  _BYTE *v11; // ecx@7
  _BYTE *v12; // edx@7
  int v13; // eax@9
  _BYTE *v14; // ecx@9
  _BYTE *v15; // edx@9
  _BYTE *v16; // ecx@11
  _BYTE *v17; // edx@11
  signed int v18; // eax@13
  unsigned __int16 v20; // [sp+0h] [bp-8h]@0

  v4 = a1;
  v5 = sub_100188D0(a4, a2, a1, v20);
  if ( !v5 )
  {
    v6 = a3;
    v7 = (_DWORD *)a2;
    v8 = v4;
    if ( a3 < 4u )
    {
LABEL_5:
      if ( !v6 )
        goto LABEL_15;
    }
    else
    {
      while ( *(_DWORD *)v8 == *v7 )
      {
        v6 -= 4;
        ++v7;
        v8 += 4;
        if ( v6 < 4 )
          goto LABEL_5;
      }
    }
    v9 = (unsigned __int8)*v8 - *(_BYTE *)v7;
    if ( (unsigned __int8)*v8 != *(_BYTE *)v7
      || (v10 = v6 - 1, v11 = (char *)v7 + 1, v12 = v8 + 1, v10)
      && ((v9 = *v12 - *v11, *v12 != *v11)
       || (v13 = v10 - 1, v14 = v11 + 1, v15 = v12 + 1, v13)
       && ((v9 = *v15 - *v14, *v15 != *v14)
        || (v16 = v14 + 1, v17 = v15 + 1, v13 != 1) && (v9 = *v17 - *v16, *v17 != *v16))) )
    {
      v18 = 1;
      if ( v9 <= 0 )
        v18 = -1;
      goto LABEL_16;
    }
LABEL_15:
    v18 = 0;
LABEL_16:
    if ( v18 )
    {
      if ( a4 > 0x1B31 )
        LOBYTE(v5) = sub_1007C500(a4, a2, a3);
      else
        LOBYTE(v5) = sub_1007C520(a4, a2, a3);
    }
    else
    {
      LOBYTE(v5) = 0;
    }
  }
  return v5;
}

//----- (10018E20) --------------------------------------------------------
char __cdecl sub_10018E20(char *a1)
{
  int v1; // ecx@0
  char v2; // al@1
  int v3; // esi@1
  _WORD *v4; // esi@2
  int v5; // ebp@3
  int v6; // esi@4
  int v7; // ST20_4@4
  int v8; // edi@4
  char v9; // bl@4
  int v10; // eax@4
  __int16 v11; // di@4
  int v12; // eax@6
  int v13; // eax@11
  bool v14; // sf@17
  unsigned __int8 v15; // of@17
  char result; // al@20
  char v17; // ST18_1@23
  char v18; // al@23
  char v19; // [sp+Bh] [bp-99h]@1
  unsigned __int16 v20; // [sp+Ch] [bp-98h]@1
  _WORD *v21; // [sp+10h] [bp-94h]@2
  int v22; // [sp+14h] [bp-90h]@1
  int v23; // [sp+18h] [bp-8Ch]@1
  char v24[4]; // [sp+1Ch] [bp-88h]@1
  int v25; // [sp+20h] [bp-84h]@4
  int v26; // [sp+24h] [bp-80h]@4
  unsigned int v27; // [sp+28h] [bp-7Ch]@4
  char *v28; // [sp+30h] [bp-74h]@1
  char v29; // [sp+34h] [bp-70h]@6
  char v30; // [sp+3Ch] [bp-68h]@8

  v28 = a1;
  v2 = *a1;
  v22 = v1;
  v19 = 0;
  v24[0] = v2;
  v3 = sub_1003DC40(v2, &v20);
  sub_1007C3B0(9171, (int)&word_10332EE0, 2);
  sub_1007C3B0(6451, (int)&unk_10332CE0, 512);
  v23 = 0;
  if ( !v20 )
    goto LABEL_18;
  v4 = (_WORD *)(v3 + 2);
  v21 = v4;
  do
  {
    v5 = 0;
    if ( !*v4 )
      goto LABEL_16;
    while ( 1 )
    {
      v6 = v5 + *(v21 - 1);
      v7 = v5 + *(v21 - 1);
      v25 = 0;
      v26 = 0;
      v27 = 0;
      j_reg_get_tag_hdr(&v25, v7, v6);
      v8 = *(unsigned int *)((char *)&v27 + 2);
      memset(&dword_10233310, 0, HIWORD(v27));
      v9 = 0;
      v10 = sub_1007C3B0(v6, (int)&dword_10233310, v8);
      v11 = HIWORD(v27);
      if ( v10 )
      {
        v9 = 1;
        memset(&dword_10233310, 0, HIWORD(v27));
      }
      memcpy(&dword_1022DAF8, &dword_10233310, (unsigned __int16)v11);
      v12 = sub_1007C3D0(v6, (int)&dword_10233310, v11, v22, (int)&v29);
      if ( !v12 )
        break;
      if ( v12 != -24 )
      {
        sub_10042370(&v30, 0x64u, "error %i reading reg %i from xml\n", v12, v6);
        sub_10042930("..\\lib\\adl\\iop_cnfg_mngr.c", 1946, 0, &v30);
        goto LABEL_15;
      }
LABEL_12:
      if ( ++v5 >= *v21 )
        goto LABEL_16;
    }
    v19 = 1;
    if ( v9 )
      dword_1022DAF8 = ~dword_10233310;
    v13 = (unsigned __int8)sub_10018D50((char *)&dword_1022DAF8, (int)&dword_10233310, HIWORD(v27), v6);
    if ( !(_BYTE)v13 )
      goto LABEL_12;
    sub_10042370(&v30, 0x64u, "error %i writing reg %i oem_id %i\n", v13, v6, (unsigned __int16)word_10332EE0);
    sub_10042930("..\\lib\\adl\\iop_cnfg_mngr.c", 1967, 0, &v30);
LABEL_15:
    v19 = 0;
LABEL_16:
    if ( v5 != *v21 )
      break;
    v4 = v21 + 2;
    v15 = __OFSUB__(v23 + 1, v20);
    v14 = v23++ + 1 - v20 < 0;
    v21 += 2;
  }
  while ( v14 ^ v15 );
LABEL_18:
  if ( !sub_1007D070(v22) )
  {
    v19 = 0;
    sub_10042930(
      "..\\lib\\adl\\iop_cnfg_mngr.c",
      1996,
      0,
      "The file being loaded was deleted during the upload process.");
    goto LABEL_20;
  }
  if ( v19 == 1 )
  {
    if ( *((_DWORD *)v28 + 2) )
    {
      sub_10018810(1);
      v17 = v24[0];
      v18 = sub_10018710();
      sub_10018760(v18, v17, 0, 11, 0, 0, 0);
      sub_10023FC0();
      result = v19;
    }
    else
    {
      sub_10018810(7);
      sub_10023FC0();
      result = v19;
    }
  }
  else
  {
LABEL_20:
    sub_10018810(8);
    result = v19;
  }
  return result;
}
// 1007C390: using guessed type int __cdecl j_reg_get_tag_hdr(_DWORD, _DWORD, _DWORD);
// 1022DAF8: using guessed type int dword_1022DAF8;
// 10233310: using guessed type int dword_10233310;
// 10332EE0: using guessed type __int16 word_10332EE0;

//----- (10019100) --------------------------------------------------------
int sub_10019100()
{
  char v0; // bl@1
  int v1; // esi@1
  int v2; // ecx@2
  int (__cdecl *v3)(_DWORD, _DWORD, _DWORD, int, int, _DWORD); // esi@3
  char v4; // al@5
  void (__cdecl *v5)(_DWORD); // ecx@12
  int result; // eax@14
  int (*v7)(); // esi@17
  int (__cdecl *v8)(_DWORD, _DWORD, _DWORD, int); // esi@21
  int v9; // edi@23
  char *v10; // eax@23
  int v11; // edx@23
  char v12; // cl@24
  int v13; // ebp@25
  int (__cdecl *v14)(_DWORD, _DWORD, _DWORD, int, int, _DWORD); // esi@29
  char v15; // [sp+8h] [bp-68h]@11

  v0 = 0;
  v1 = sub_10043FF0((_DWORD *)(dword_102332F8 + 2), 1u, (int)byte_100A3E00, 44, 11, 57);
  if ( v1 < 57 )
  {
    v2 = dword_102332F8;
    switch ( *(_BYTE *)dword_102332F8 )
    {
      case 1:
        v3 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, int, int, _DWORD))*(&off_100A3E08 + 11 * v1);
        goto LABEL_4;
      case 0:
        break;
      case 2:
        v7 = (int (*)())*(&off_100A3E04 + 11 * v1);
        goto LABEL_18;
      case 3:
        v7 = off_100A3E14[11 * v1];
LABEL_18:
        if ( !v7 )
          goto LABEL_9;
        v4 = ((int (__cdecl *)(_DWORD, _DWORD, int))v7)(
               *(_BYTE *)(dword_102332F8 + 2),
               *(_BYTE *)(dword_102332F8 + 4),
               dword_102332F8 + 5);
        goto LABEL_6;
      case 4:
        v8 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, int))*(&off_100A3E18 + 11 * v1);
        if ( !v8 )
          goto LABEL_9;
        v4 = v8(
               *(_BYTE *)(dword_102332F8 + 2),
               *(_BYTE *)(dword_102332F8 + 3),
               *(_BYTE *)(dword_102332F8 + 4),
               dword_102332F8 + 5);
        goto LABEL_6;
      case 5:
        v9 = dword_102332F8 + 8;
        v10 = (char *)(dword_102332F8 + 8);
        v11 = dword_102332F8 + 9;
        do
          v12 = *v10++;
        while ( v12 );
        v13 = (int)&v10[-v11];
        if ( sub_10042230(&v10[v9 - 4] - v11, ".ini", 5) && !sub_10042230((_BYTE *)(v9 + v13 - 5), ".greg", 6) )
          v0 = sub_10018E20(&byte_100A3E00[44 * v1]);
        j_FIL_vfs_sync_all();
        goto LABEL_7;
      case 6:
        v14 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, int, int, _DWORD))*(&off_100A3E0C + 11 * v1);
        if ( !v14 )
          goto LABEL_9;
        v4 = v14(
               *(_BYTE *)(dword_102332F8 + 2),
               *(_BYTE *)(dword_102332F8 + 3),
               *(_BYTE *)(dword_102332F8 + 4),
               dword_102332F8 + 5,
               dword_102332F8 + 8,
               *(_DWORD *)(dword_102332F8 + 160008));
        goto LABEL_6;
      case 0xB:
        v3 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, int, int, _DWORD))dword_100A3E10[11 * v1];
        goto LABEL_4;
      case 7:
        sub_10018B20();
        break;
      case 8:
        sub_10018B40();
        break;
      case 0xA:
        v3 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, int, int, _DWORD))*(&off_100A3E1C + 11 * v1);
LABEL_4:
        if ( !v3 )
          goto LABEL_9;
        v4 = v3(
               *(_BYTE *)(dword_102332F8 + 2),
               *(_BYTE *)(dword_102332F8 + 3),
               *(_BYTE *)(dword_102332F8 + 4),
               dword_102332F8 + 5,
               dword_102332F8 + 8,
               *(_DWORD *)(dword_102332F8 + 160008));
LABEL_6:
        v0 = v4;
LABEL_7:
        if ( v0 != 1 )
          goto LABEL_8;
        break;
      case 9:
        sub_10018B00();
        break;
      default:
        sub_10042930("..\\lib\\adl\\iop_cnfg_mngr.c", 972, 0, 0);
LABEL_8:
        v2 = dword_102332F8;
LABEL_9:
        if ( (unsigned int)++dword_102332FC > 0x32 || (unsigned int)sub_10018700() > 0x32 )
        {
          sprintf(&v15, "EXCEEDED RETRIES CNFG_PROD %d STATE %d\n", *(_BYTE *)(v2 + 2), *(_BYTE *)v2);
          sub_10042930("..\\lib\\adl\\iop_cnfg_mngr.c", 1009, 0, &v15);
          sub_10018810(8);
        }
        break;
    }
  }
  v5 = (void (__cdecl *)(_DWORD))dword_100A3E24[11 * dword_1023330C];
  if ( v5 )
    v5((unsigned __int8)byte_100A3E00[44 * dword_1023330C]);
  result = dword_1023330C++ + 1;
  if ( (unsigned int)dword_1023330C >= 0xB )
    dword_1023330C = 0;
  return result;
}
// 1007D010: using guessed type int j_FIL_vfs_sync_all(void);
// 100A3E04: using guessed type int (__cdecl *off_100A3E04)(char, int, int);
// 100A3E08: using guessed type int (__cdecl *off_100A3E08)(char, int, int, int, int, int);
// 100A3E0C: using guessed type int (*off_100A3E0C)();
// 100A3E10: using guessed type int dword_100A3E10[];
// 100A3E14: using guessed type int (*off_100A3E14[2])();
// 100A3E18: using guessed type int (*off_100A3E18)();
// 100A3E1C: using guessed type int (__cdecl *off_100A3E1C)(char, char, char, int, int);
// 100A3E24: using guessed type int dword_100A3E24[];
// 102332F8: using guessed type int dword_102332F8;
// 102332FC: using guessed type int dword_102332FC;
// 1023330C: using guessed type int dword_1023330C;

//----- (100193C0) --------------------------------------------------------
char __cdecl sub_100193C0(int a1)
{
  char result; // al@1
  char v2; // [sp+7h] [bp-9h]@1
  int v3; // [sp+8h] [bp-8h]@6
  char v4; // [sp+Ch] [bp-4h]@6

  v2 = 0;
  result = sub_10023DA0(a1, (int)&byte_10332F00, &v2);
  if ( result == 1 )
  {
    if ( (unsigned __int16)a1 == 536 )
    {
      result = v2;
      switch ( v2 )
      {
        case 0x23:
          sub_1007C3B0(10022, (int)&v3, 4);
          sub_1007C3B0(10018, (int)&v4, 4);
          sub_1007C500(10018, (int)&v3, 4);
          result = sub_1007C500(10022, (int)&v4, 4);
          break;
        case 0x24:
          result = sub_10043480(0x19u);
          break;
        case 0x28:
          result = sub_10043370(27);
          break;
        case 0x29:
          result = sub_10043480(0x1Bu);
          break;
        case 0x2A:
          v3 = 121500;
          result = sub_1007C500(10018, (int)&v3, 4);
          break;
        case 0x2B:
          result = sub_10043370(25);
          break;
        default:
          return result;
      }
    }
    else if ( (unsigned __int16)a1 == 544 )
    {
      result = v2;
      switch ( v2 )
      {
        case 0x23:
          sub_1007C3B0(10023, (int)&v3, 4);
          sub_1007C3B0(10019, (int)&v4, 4);
          sub_1007C500(10019, (int)&v3, 4);
          result = sub_1007C500(10023, (int)&v4, 4);
          break;
        case 0x24:
          result = sub_10043480(0x1Au);
          break;
        case 0x28:
          result = sub_10043370(28);
          break;
        case 0x29:
          result = sub_10043480(0x1Cu);
          break;
        case 0x2A:
          v3 = 121500;
          result = sub_1007C500(10019, (int)&v3, 4);
          break;
        case 0x2B:
          result = sub_10043370(26);
          break;
        default:
          return result;
      }
    }
    else
    {
      result = sub_10042930("..\\lib\\acl\\iop\\iop_com.c", 261, 1, 0);
    }
  }
  return result;
}
// 10332F00: using guessed type char byte_10332F00;

//----- (100195E0) --------------------------------------------------------
unsigned __int8 __cdecl sub_100195E0(unsigned __int8 a1)
{
  bool v1; // bl@6
  unsigned __int8 v2; // bl@8
  unsigned __int8 result; // al@8
  signed int v4; // ecx@8
  int v5; // ecx@8
  char v6; // cl@12
  char v7; // cl@15
  unsigned __int8 v8; // [sp+3h] [bp-Dh]@4
  unsigned __int8 v9; // [sp+4h] [bp-Ch]@4
  char v10; // [sp+5h] [bp-Bh]@4
  char v11; // [sp+6h] [bp-Ah]@2
  char v12; // [sp+7h] [bp-9h]@2
  int v13; // [sp+8h] [bp-8h]@6
  int v14; // [sp+Ch] [bp-4h]@6

  if ( sub_1004A130(552) )
  {
    sub_1004A2C0(&v12, 552);
    sub_1004A290(&v11, 552);
  }
  else
  {
    sub_1004A2C0(&v12, 557);
    sub_1004A290(&v11, 557);
  }
  v10 = 53;
  sub_1007C650(2010, &v8, 1, &v10);
  sub_1007C650(2011, &v9, 1, &v10);
  if ( (sub_1004A130(552) || sub_1004A130(557))
    && (v1 = sub_1007C3B0(10018, (int)&v13, 4) == 0, (v1 & (sub_1007C3B0(10019, (int)&v14, 4) == 0)) == 1)
    && v13 == v14 )
  {
    v2 = v9;
    result = v8;
    v4 = v8 - v9 - ((v8 - (unsigned int)v9) >> 31);
    v5 = v4 ^ (v4 >> 31);
    if ( v5 < 6 )
    {
      if ( v11 & 1 )
      {
        if ( v8 >= v9 )
        {
          v6 = v5 - 6;
          v2 = v6 + v9;
          v9 += v6;
        }
        else
        {
          v2 = 6 - v5 + v9;
          v9 += 6 - v5;
        }
      }
      else if ( v9 >= v8 )
      {
        v7 = v5 - 6;
        result = v7 + v8;
        v8 += v7;
      }
      else
      {
        result = 6 - v5 + v8;
        v8 += 6 - v5;
      }
    }
  }
  else
  {
    result = v8;
    v2 = v9;
  }
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = v2;
    }
    else
    {
      sub_10042930("..\\lib\\acl\\iop\\iop_com.c", 635, 1, 0);
      result = a1;
    }
  }
  return result;
}

//----- (10019770) --------------------------------------------------------
int __cdecl sub_10019770(unsigned __int8 a1)
{
  int result; // eax@2
  int v2; // eax@3
  int v3; // eax@4
  int v4; // [sp+0h] [bp-Ch]@1
  int v5; // [sp+4h] [bp-8h]@1

  v4 = 0;
  v5 = 0;
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 == 1 )
    {
      sub_10023DA0(546, (int)&byte_10332F00, &v4);
      LOWORD(v4) = v4 & 0xFFE7;
      v2 = sub_1007C040();
      sub_10023190(546, 0, (int)&byte_10332F00, &v4, v2);
      result = sub_10043370(24);
    }
  }
  else
  {
    sub_10023DA0(538, (int)&byte_10332F00, &v4);
    LOWORD(v4) = v4 & 0xFFE7;
    v3 = sub_1007C040();
    sub_10023190(538, 0, (int)&byte_10332F00, &v4, v3);
    result = sub_10043370(23);
  }
  return result;
}
// 10332F00: using guessed type char byte_10332F00;

//----- (10019820) --------------------------------------------------------
char __cdecl sub_10019820(signed int a1)
{
  int v1; // edi@1
  int v2; // esi@1
  int v3; // eax@1
  unsigned __int8 v5; // [sp+Bh] [bp-5h]@9
  int v6; // [sp+Ch] [bp-4h]@6

  v1 = a1;
  v2 = sub_1007C040();
  v3 = (unsigned __int16)a1;
  switch ( (unsigned __int16)a1 )
  {
    case 0x21Bu:
    case 0x21Du:
      LOBYTE(a1) = 0;
      goto LABEL_4;
    case 0x223u:
    case 0x225u:
      LOBYTE(a1) = 1;
      goto LABEL_4;
    case 0x21Cu:
    case 0x21Eu:
    case 0x21Fu:
    case 0x220u:
    case 0x221u:
    case 0x222u:
    case 0x224u:
LABEL_4:
      switch ( v3 )
      {
        case 0:
        case 8:
          if ( sub_100498F0(a1) )
            v6 = 121500;
          else
            v6 = sub_1004AEF0(a1, 1);
          LOBYTE(v3) = sub_10023190(v1, 1, (int)&byte_10332F00, &v6, v2);
          break;
        case 2:
        case 10:
          v5 = sub_100195E0(a1);
          LOBYTE(v3) = sub_10023190(v1, 1, (int)&byte_10332F00, &v5, v2);
          break;
        default:
          return v3;
      }
      break;
    default:
      return v3;
  }
  return v3;
}
// 10332F00: using guessed type char byte_10332F00;

//----- (10019910) --------------------------------------------------------
char __usercall sub_10019910@<al>(unsigned __int8 a1@<bl>, __int16 *a2@<esi>)
{
  __int16 v2; // ax@1

  v2 = *a2;
  if ( *a2 & 1 )
  {
    if ( !(v2 & 4) || !(v2 & 2) )
    {
      if ( a1 )
      {
        if ( a1 == 1 )
          LOBYTE(v2) = sub_10043480(0x18u);
      }
      else
      {
        LOBYTE(v2) = sub_10043480(0x17u);
      }
    }
  }
  else
  {
    LOBYTE(v2) = sub_10019770(a1);
  }
  if ( *a2 & 0x100 )
  {
    if ( a1 )
    {
      if ( a1 == 1 )
        LOBYTE(v2) = sub_10043480(0x1Eu);
    }
    else
    {
      LOBYTE(v2) = sub_10043480(0x1Du);
    }
  }
  else if ( a1 )
  {
    if ( a1 == 1 )
      LOBYTE(v2) = sub_10043370(30);
  }
  else
  {
    LOBYTE(v2) = sub_10043370(29);
  }
  return v2;
}

//----- (10019990) --------------------------------------------------------
char __cdecl sub_10019990(int a1)
{
  char result; // al@1
  unsigned __int8 v2; // bl@5
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  result = sub_10023DA0(a1, (int)&byte_10332F00, &v3);
  if ( result == 1 )
  {
    if ( (unsigned __int16)a1 == 538 )
    {
      v2 = 0;
    }
    else
    {
      if ( (unsigned __int16)a1 != 546 )
        return sub_10042930("..\\lib\\acl\\iop\\iop_com.c", 327, 1, 0);
      v2 = 1;
    }
    result = sub_10019910(v2, (__int16 *)&v3);
  }
  return result;
}
// 10332F00: using guessed type char byte_10332F00;

//----- (10019A20) --------------------------------------------------------
char __cdecl sub_10019A20(int a1, int a2, int a3, int a4, char a5, char *a6)
{
  char result; // al@1

  result = 0;
  switch ( a5 )
  {
    case 0:
    case 7:
      strncpy(a6, &byte_100930C0, 0x64u);
      result = 1;
      break;
    case 5:
      strncpy(a6, "LOADING", 0x64u);
      result = 1;
      break;
    case 1:
    case 2:
    case 3:
    case 4:
    case 6:
    case 8:
    case 9:
    case 0xA:
      strncpy(a6, byte_10238B38, 0x64u);
      result = 1;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10019AA0) --------------------------------------------------------
char sub_10019AA0()
{
  if ( j_HWM_pvg_read_reg(1) || (unsigned int)(sub_1007C040() - dword_10238B34) > 0x7D0 )
    sub_10018810((unsigned __int8)byte_10238B12);
  return 1;
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10238B12: using guessed type char byte_10238B12;
// 10238B34: using guessed type int dword_10238B34;

//----- (10019AE0) --------------------------------------------------------
void *sub_10019AE0()
{
  byte_10238B12 = 0;
  dword_10238B34 = 0;
  word_10238B10 = 0;
  dword_10238B14 = 0;
  dword_10238B18[0] = 0;
  dword_10238B1C = 0;
  dword_10238B20 = 0;
  dword_10238B24 = 0;
  dword_10238B28 = 0;
  dword_10238B2C = 0;
  dword_10238B30 = 0;
  dword_10238B9C[0] = 0;
  dword_10238BA0 = 0;
  return memset(byte_10238B38, 0, 0x64u);
}
// 10238B10: using guessed type __int16 word_10238B10;
// 10238B12: using guessed type char byte_10238B12;
// 10238B14: using guessed type int dword_10238B14;
// 10238B18: using guessed type int dword_10238B18[];
// 10238B1C: using guessed type int dword_10238B1C;
// 10238B20: using guessed type int dword_10238B20;
// 10238B24: using guessed type int dword_10238B24;
// 10238B28: using guessed type int dword_10238B28;
// 10238B2C: using guessed type int dword_10238B2C;
// 10238B30: using guessed type int dword_10238B30;
// 10238B34: using guessed type int dword_10238B34;
// 10238B9C: using guessed type int dword_10238B9C[];
// 10238BA0: using guessed type int dword_10238BA0;

//----- (10019B40) --------------------------------------------------------
char __usercall sub_10019B40@<al>(int a1@<ecx>, unsigned __int8 a2@<bl>, char a3)
{
  int v3; // eax@1
  int v4; // esi@2
  int v5; // edi@3
  int v7; // [sp-2h] [bp-4h]@1

  v7 = a1;
  LOBYTE(v3) = sub_1004B270(a2);
  if ( (_BYTE)v3 )
  {
    v4 = 10 * a2;
    LOBYTE(v3) = sub_1003D360((unsigned __int8)byte_100A54C8[20 * a2], (bool *)&v7 + 3);
    if ( (_BYTE)v3 )
    {
      v5 = (unsigned __int16)word_100A54C0[v4];
      if ( BYTE3(v7) )
      {
        if ( a3 )
          v5 = (unsigned __int16)word_100A54BE[v4];
      }
      else
      {
        v5 = (unsigned __int16)word_100A54C4[v4];
      }
      v3 = j_HWM_pvg_read_reg(1);
      if ( !v3 )
        LOBYTE(v3) = sub_10022340(v5, (int)&byte_10332F00);
    }
  }
  return v3;
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 100A54BE: using guessed type __int16 word_100A54BE[];
// 100A54C0: using guessed type __int16 word_100A54C0[];
// 100A54C4: using guessed type __int16 word_100A54C4[];
// 10332F00: using guessed type char byte_10332F00;

//----- (10019BC0) --------------------------------------------------------
char __usercall sub_10019BC0@<al>(unsigned __int8 a1@<bl>, void *a2)
{
  char result; // al@2
  unsigned __int8 v3; // [sp+0h] [bp-4h]@0

  if ( (unsigned __int8)sub_1004B270(v3) )
    result = sub_10023DA0((unsigned __int16)word_100A54BE[10 * a1], (int)&byte_10332F00, a2);
  else
    result = 0;
  return result;
}
// 100A54BE: using guessed type __int16 word_100A54BE[];
// 10332F00: using guessed type char byte_10332F00;

//----- (10019C00) --------------------------------------------------------
char __usercall sub_10019C00@<al>(unsigned __int8 a1@<cl>, _DWORD *a2@<esi>)
{
  char result; // al@2
  int v3; // [sp+4h] [bp-24h]@1

  if ( sub_1004B460(a1, (int)&v3) )
  {
    *a2 = v3;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10019C50) --------------------------------------------------------
char __cdecl sub_10019C50(unsigned __int8 a1, int a2, unsigned __int8 a3)
{
  char result; // al@1
  char v4; // [sp+6h] [bp-6h]@2
  bool v5; // [sp+7h] [bp-5h]@1
  int v6; // [sp+8h] [bp-4h]@6
  char v7; // [sp+18h] [bp+Ch]@4

  v5 = a3 < 3u;
  result = sub_1004B270(a1);
  if ( result )
  {
    result = sub_1003D360((unsigned __int8)byte_100A54C8[20 * a1], (bool *)&v4);
    if ( result )
    {
      if ( v4 )
      {
        v7 = (_BYTE)a2 != 0 ? 60 : 51;
LABEL_9:
        sub_10019B40(a2, a1, a2);
        return sub_1004B4A0(a1, v7);
      }
      if ( v5 )
      {
        result = sub_10049990(a1, &v6);
        if ( result )
        {
          result = v6;
          if ( v6 == dword_100A54E0[2 * a3] )
          {
            v7 = 33;
            goto LABEL_9;
          }
        }
      }
    }
  }
  return result;
}
// 100A54E0: using guessed type int dword_100A54E0[];

//----- (10019D00) --------------------------------------------------------
char __usercall sub_10019D00@<al>(int a1@<edx>, unsigned __int8 a2@<cl>, unsigned __int8 a3, char a4)
{
  unsigned __int8 v4; // bl@1
  char result; // al@1
  int v6; // esi@1
  int v7; // ebp@3
  struct tm *v8; // edi@6
  bool v9; // al@6
  int v10; // esi@8
  time_t v11; // eax@9
  int v12; // ecx@12
  bool v13; // al@14
  char v14; // cl@16
  char v15; // dl@16
  char v16; // cl@16
  int v17; // eax@19
  int v18; // ecx@19
  char v19; // [sp+Bh] [bp-29h]@3
  int v20; // [sp+Ch] [bp-28h]@10
  struct tm Tm; // [sp+10h] [bp-24h]@7

  v4 = a2;
  result = 0;
  v6 = a1;
  if ( a2 < 3u )
  {
    if ( !(unsigned __int8)sub_1004B270(a3) )
      return 0;
    v7 = 10 * a3;
    if ( !sub_1003D360((unsigned __int8)byte_100A54C8[20 * a3], (bool *)&v19) )
      return 0;
    if ( v19 )
    {
      if ( a4 == 11 )
      {
        v8 = (struct tm *)v6;
        v9 = 1;
      }
      else
      {
        v8 = (struct tm *)((char *)&Tm + 16);
        v9 = sub_1004B2B0(a3, 11, 0, (int)&Tm.tm_mon);
        *(&Tm.tm_mon + v4) = *(_DWORD *)v6;
      }
      v10 = (unsigned __int16)word_100A54C2[v7];
      if ( v9 )
      {
        v11 = sub_1004D4B0((int)v8, 0);
        goto LABEL_18;
      }
    }
    else if ( (unsigned __int8)sub_10049990(a3, &v20) && v20 == dword_100A54E0[2 * v4] )
    {
      v12 = (unsigned __int16)word_100A54C4[v7];
      v8 = &Tm;
      Tm.tm_sec = 0;
      Tm.tm_min = 0;
      Tm.tm_hour = 0;
      LOBYTE(Tm.tm_mday) = 0;
      v13 = sub_10023DA0(v12, (int)&byte_10332F00, &Tm) && !_mkgmtime(&Tm);
      v14 = *(_BYTE *)(v6 + 2);
      LOBYTE(Tm.tm_min) = *(_BYTE *)v6;
      v15 = *(_BYTE *)(v6 + 1);
      BYTE1(Tm.tm_hour) = v14;
      v16 = *(_BYTE *)(v6 + 3);
      v10 = (unsigned __int16)word_100A54C6[v7];
      BYTE2(Tm.tm_min) = v15;
      BYTE2(Tm.tm_hour) = v16;
      if ( v13 )
      {
        v11 = _mkgmtime(&Tm);
LABEL_18:
        if ( !v11 )
        {
          v17 = sub_1007C040();
          sub_10023190(v10, 1, (int)&byte_10332F00, v8, v17);
          sub_10023790(v10, 0xFFFFFFF, (int)&byte_10332F00);
          sub_10019B40(v18, a3, 0);
          return 1;
        }
        goto LABEL_22;
      }
    }
LABEL_22:
    result = 0;
  }
  return result;
}
// 100A54C2: using guessed type __int16 word_100A54C2[];
// 100A54C4: using guessed type __int16 word_100A54C4[];
// 100A54C6: using guessed type __int16 word_100A54C6[];
// 100A54E0: using guessed type int dword_100A54E0[];
// 10332F00: using guessed type char byte_10332F00;

//----- (10019F00) --------------------------------------------------------
char __cdecl sub_10019F00(unsigned __int8 a1, char a2, unsigned __int8 a3)
{
  int v3; // ecx@0
  int v4; // esi@1
  char v5; // bl@1
  int v6; // eax@1
  int v7; // ebp@4
  int v8; // ecx@7
  int v9; // edx@7
  int v10; // esi@11
  struct tm *v11; // edi@11
  char v12; // cl@16
  char v13; // dl@16
  char v14; // bl@16
  unsigned int v15; // eax@16
  char v16; // al@18
  char v17; // al@20
  char v18; // al@22
  int v19; // eax@25
  char v21; // [sp+Bh] [bp-39h]@4
  int v22; // [sp+Ch] [bp-38h]@14
  struct tm Tm; // [sp+10h] [bp-34h]@6
  int v24; // [sp+34h] [bp-10h]@6
  int v25; // [sp+38h] [bp-Ch]@6
  int v26; // [sp+3Ch] [bp-8h]@6

  v4 = v3;
  v5 = 0;
  v6 = j_HWM_pvg_read_reg(1);
  if ( !v6 )
    return v6;
  if ( a3 >= 3u )
    return v6;
  LOBYTE(v6) = sub_1004B270(a1);
  if ( !(_BYTE)v6 )
    return v6;
  v7 = 10 * a1;
  LOBYTE(v6) = sub_1003D360((unsigned __int8)byte_100A54C8[20 * a1], (bool *)&v21);
  if ( !(_BYTE)v6 )
    return v6;
  if ( !v21 )
  {
    LOBYTE(v6) = sub_10049990(a1, &v22);
    if ( (_BYTE)v6 )
    {
      LOBYTE(v6) = v22;
      if ( v22 == dword_100A54E0[2 * a3] )
      {
        v12 = *(_BYTE *)(v4 + 2);
        v13 = *(_BYTE *)(v4 + 1);
        v14 = *(_BYTE *)(v4 + 3);
        Tm.tm_sec = 0;
        Tm.tm_min = 0;
        Tm.tm_hour = 0;
        LOBYTE(Tm.tm_mday) = 0;
        v15 = *(_BYTE *)v4;
        v11 = &Tm;
        if ( v15 > 0x3F )
          LOBYTE(v15) = 63;
        LOBYTE(Tm.tm_min) = v15;
        v16 = v12;
        if ( (unsigned __int8)v12 > 0x3Fu )
          v16 = 63;
        BYTE1(Tm.tm_hour) = v16;
        v17 = v13;
        if ( (unsigned __int8)v13 > 0x3Fu )
          v17 = 63;
        BYTE2(Tm.tm_min) = v17;
        v18 = v14;
        if ( (unsigned __int8)v14 > 0x3Fu )
          v18 = 63;
        v10 = (unsigned __int16)word_100A54C4[v7];
        BYTE2(Tm.tm_hour) = v18;
        LOBYTE(v6) = _mkgmtime(&Tm) == 0;
        if ( (_BYTE)v6 )
          goto LABEL_25;
      }
    }
    return v6;
  }
  Tm.tm_mon = 0;
  Tm.tm_year = 0;
  Tm.tm_wday = 0;
  Tm.tm_yday = 0;
  Tm.tm_isdst = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  if ( a2 == 11 )
  {
    v8 = *(_DWORD *)(v4 + 4);
    v9 = *(_DWORD *)(v4 + 8);
    Tm.tm_year = *(_DWORD *)v4;
    v6 = *(_DWORD *)(v4 + 12);
    Tm.tm_wday = v8;
    Tm.tm_yday = v9;
    Tm.tm_isdst = v6;
LABEL_10:
    v5 = 1;
    goto LABEL_11;
  }
  LOBYTE(v6) = sub_1004B460(a1, (int)&Tm.tm_mon);
  if ( (_BYTE)v6 )
  {
    LOBYTE(v6) = a3;
    *(&Tm.tm_year + a3) = *(_DWORD *)v4;
    goto LABEL_10;
  }
LABEL_11:
  v10 = (unsigned __int16)word_100A54C0[v7];
  v11 = (struct tm *)((char *)&Tm + 20);
  if ( v5 )
  {
    v6 = sub_1004D4B0((int)&Tm.tm_year, 0);
    if ( !v6 )
    {
LABEL_25:
      v19 = sub_1007C040();
      sub_10023190(v10, 1, (int)&byte_10332F00, v11, v19);
      LOBYTE(v6) = sub_10023790(v10, 0xFFFFFFF, (int)&byte_10332F00);
      return v6;
    }
  }
  return v6;
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 100A54C0: using guessed type __int16 word_100A54C0[];
// 100A54C4: using guessed type __int16 word_100A54C4[];
// 100A54E0: using guessed type int dword_100A54E0[];
// 10332F00: using guessed type char byte_10332F00;

//----- (1001A100) --------------------------------------------------------
char __usercall sub_1001A100@<al>(int a1@<ecx>, unsigned __int8 a2@<bl>)
{
  int v2; // eax@1
  int v3; // eax@4
  int v5; // [sp+0h] [bp-4h]@1

  v5 = a1;
  v2 = j_HWM_pvg_read_reg(1);
  if ( v2 )
  {
    LOBYTE(v2) = sub_1004B270(a2);
    if ( (_BYTE)v2 )
    {
      LOBYTE(v2) = sub_10019C00(a2, &v5);
      if ( (_BYTE)v2 )
      {
        v3 = sub_1007C040();
        LOBYTE(v2) = sub_10023190((unsigned __int16)word_100A54BE[10 * a2], 1, (int)&byte_10332F00, &v5, v3);
      }
    }
  }
  return v2;
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 100A54BE: using guessed type __int16 word_100A54BE[];
// 10332F00: using guessed type char byte_10332F00;

//----- (1001A160) --------------------------------------------------------
int __usercall sub_1001A160@<eax>(unsigned __int8 a1@<bl>, int a2)
{
  int result; // eax@1
  unsigned __int8 v3; // [sp+0h] [bp-4h]@0

  result = sub_1004B270(v3);
  if ( (_BYTE)result )
    result = sub_1007C580((unsigned __int16)word_100A54CA[10 * a1], a2, 32);
  return result;
}
// 100A54CA: using guessed type __int16 word_100A54CA[];

//----- (1001A190) --------------------------------------------------------
BOOL __usercall sub_1001A190@<eax>(unsigned __int8 a1@<al>, char a2@<bl>, _BYTE *a3)
{
  return (unsigned __int8)sub_1004B270(a1) && *a3 < 3u && (a2 == 11 || a2 == 24 || a2 == 17);
}

//----- (1001A1D0) --------------------------------------------------------
char __cdecl sub_1001A1D0(char a1)
{
  char v1; // al@1
  unsigned __int8 v2; // bl@1
  void *v3; // ecx@1
  unsigned int v4; // eax@1
  int v5; // esi@7
  bool v6; // zf@10
  unsigned __int8 v7; // ST00_1@16
  char v9; // [sp+5h] [bp-13h]@2
  char v10; // [sp+6h] [bp-12h]@6
  char v11; // [sp+7h] [bp-11h]@14
  int v12; // [sp+8h] [bp-10h]@1
  int v13; // [sp+Ch] [bp-Ch]@8
  int v14; // [sp+10h] [bp-8h]@9
  int v15; // [sp+14h] [bp-4h]@7

  v1 = sub_10049840(a1);
  v2 = v1;
  LOBYTE(v12) = v1;
  LOBYTE(v4) = sub_100460C0(v3);
  if ( (_BYTE)v4 != 1 )
    return v4;
  LOBYTE(v4) = sub_100473B0((bool *)&v9);
  if ( !(_BYTE)v4 )
    return v4;
  if ( !v9 )
    return v4;
  LOBYTE(v4) = sub_1004B270(v12);
  if ( !(_BYTE)v4 )
    return v4;
  if ( *((_BYTE *)&word_10238B10 + v2) )
    return v4;
  LOBYTE(v4) = sub_1003D360((unsigned __int8)byte_100A54C8[20 * v2], (bool *)&v10);
  if ( !(_BYTE)v4 )
    return v4;
  v4 = sub_1007C040();
  v5 = v4;
  v15 = v4;
  if ( !v10 )
  {
    *((_BYTE *)&word_10238B10 + v2) = 1;
    return v4;
  }
  if ( sub_10019BC0(v2, &v13) )
  {
    if ( sub_10019C00(v2, &v14) )
    {
      LOBYTE(v4) = v13;
      v6 = v13 == v14;
      *((_BYTE *)&word_10238B10 + v2) = 1;
      if ( !v6 )
      {
        sub_10043480(word_100A54B8[10 * v2]);
        LOBYTE(v4) = sub_1003DF00(a1, 0);
      }
      return v4;
    }
    v5 = v15;
  }
  v4 = v5 - dword_10238B9C[v2];
  if ( v4 > 0x3E8 )
  {
    LOBYTE(v4) = sub_1003DE70(&v11);
    if ( !(_BYTE)v4 || !v11 )
    {
      v7 = v12;
      dword_10238B9C[v2] = v5;
      LOBYTE(v4) = sub_10019C50(v7, 1, 0);
    }
  }
  return v4;
}
// 100A54B8: using guessed type __int16 word_100A54B8[];
// 10238B10: using guessed type __int16 word_10238B10;
// 10238B9C: using guessed type int dword_10238B9C[];

//----- (1001A330) --------------------------------------------------------
bool __cdecl sub_1001A330(char a1, char a2, unsigned __int8 *a3)
{
  int v3; // ecx@2
  char v4; // bl@2
  bool result; // al@12
  char v6; // al@14
  bool v7; // bl@16
  unsigned int v8; // eax@21
  int v9; // [sp+Ch] [bp-1Ch]@0
  char v10; // [sp+10h] [bp-18h]@1
  int v11; // [sp+14h] [bp-14h]@6
  int v12; // [sp+18h] [bp-10h]@20
  int v13; // [sp+1Ch] [bp-Ch]@20
  int v14; // [sp+20h] [bp-8h]@20

  v10 = sub_10049840(a1);
  if ( (unsigned __int8)sub_1001A190(v10, a2, a3) )
  {
    v4 = a2;
    if ( j_HWM_pvg_read_reg(1) && *a3 < 3u )
    {
      if ( a2 == 17 )
      {
        sub_1001A100(v3, v10);
        v4 = 17;
      }
      else
      {
        if ( !sub_1004B2B0(v10, a2, *a3, (int)&v11) )
          sub_1004B460(v10, (int)&dword_10238B14);
        if ( a2 == 11 )
          sub_10019F00(v10, 11, *a3);
        else
          sub_10019F00(v10, a2, *a3);
      }
    }
    if ( sub_10018710() == 2 )
    {
      sub_10019C50(v10, 0, *a3);
      LOBYTE(v9) = 7;
      sub_10018810(v9);
      return v4 != 11;
    }
    if ( v4 == 17 )
    {
      v6 = sub_10019BC0(v10, &dword_10238B14);
      LOBYTE(v9) = 10;
    }
    else
    {
      v6 = sub_1004B2B0(v10, v4, *a3, (int)&v11);
      LOBYTE(v9) = 3;
    }
    v7 = v6;
    if ( v6 )
    {
      if ( sub_10018710() == 5 && sub_100186F0() == 1 )
      {
        v7 = a2 == 11;
        if ( a2 == 11 )
        {
          dword_10238B1C = v12;
          LOBYTE(v9) = 10;
          dword_10238B18[0] = v11;
          dword_10238B20 = v13;
          dword_10238B24 = v14;
          sub_10018810(v9);
          return a2 == 11;
        }
      }
    }
    else
    {
      sub_10018720();
      v8 = sub_10018700();
      if ( v8 > 0xF )
      {
        sub_10042370(byte_10238B38, 0x64u, "FAILED: UNABLE TO REQUEST COM %d", (unsigned __int8)v10 + 1);
        LOBYTE(v9) = 8;
        sub_10018810(v9);
        return v7;
      }
      LOBYTE(v8) = a2 == 17;
      sub_10019C50(v10, v8, *a3);
      v7 = 1;
      LOBYTE(v9) = 4;
      byte_10238B12 = 2;
      dword_10238B34 = sub_1007C040();
    }
    sub_10018810(v9);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10238B12: using guessed type char byte_10238B12;
// 10238B14: using guessed type int dword_10238B14;
// 10238B18: using guessed type int dword_10238B18[];
// 10238B1C: using guessed type int dword_10238B1C;
// 10238B20: using guessed type int dword_10238B20;
// 10238B24: using guessed type int dword_10238B24;
// 10238B34: using guessed type int dword_10238B34;

//----- (1001A5A0) --------------------------------------------------------
char __cdecl sub_1001A5A0(char a1, int a2, char a3, unsigned __int8 *a4, const void *a5, int a6)
{
  unsigned __int8 v6; // bl@2
  int v7; // esi@10
  char v9; // [sp+Ah] [bp-Ah]@1
  char v10; // [sp+Bh] [bp-9h]@12
  int v11; // [sp+Ch] [bp-8h]@1
  int v12; // [sp+10h] [bp-4h]@1

  LOBYTE(v11) = sub_10049840(a1);
  LOBYTE(v12) = 8;
  v9 = 0;
  if ( !(unsigned __int8)sub_1001A190(v11, a3, a4) )
    goto LABEL_14;
  v6 = v11;
  if ( a3 == 11 )
  {
    if ( a6 )
    {
      if ( a6 == 32 )
      {
        qmemcpy(&dword_10238B14, a5, 0x20u);
LABEL_5:
        if ( sub_10019D00((int)dword_10238B18, *a4, v11, 11) )
        {
          v9 = 1;
LABEL_18:
          LOBYTE(v12) = 4;
          byte_10238B12 = 2;
          v7 = (unsigned __int8)v11;
          dword_10238B34 = sub_1007C040();
          sub_10042370(byte_10238B38, 0x64u, "CONFIGURING COM %d", (unsigned __int8)v11 + 1);
          goto LABEL_11;
        }
        goto LABEL_9;
      }
    }
    else if ( sub_1004B460(v11, (int)&dword_10238B14) )
    {
      goto LABEL_5;
    }
LABEL_9:
    v9 = 0;
    goto LABEL_10;
  }
  if ( a6 == 4 )
  {
    v9 = sub_10019D00((int)a5, *a4, v11, a3);
    if ( v9 )
    {
      dword_10238B18[*a4] = *(_DWORD *)a5;
      goto LABEL_18;
    }
  }
LABEL_10:
  v7 = (unsigned __int8)v11;
  sub_10042370(byte_10238B38, 0x64u, "FAILED: UNABLE TO SEND TO COM %d", (unsigned __int8)v11 + 1);
LABEL_11:
  if ( j_HWM_pvg_read_reg(1) && !sub_1003D360((unsigned __int8)byte_100A54C8[20 * v7], (bool *)&v10) )
  {
    sub_100499E0(v6, 1, 121500);
    LOBYTE(v12) = 4;
    byte_10238B12 = 1;
    dword_10238B34 = sub_1007C040();
  }
LABEL_14:
  sub_10018810(v12);
  return v9;
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10238B12: using guessed type char byte_10238B12;
// 10238B14: using guessed type int dword_10238B14;
// 10238B18: using guessed type int dword_10238B18[];
// 10238B34: using guessed type int dword_10238B34;

//----- (1001A730) --------------------------------------------------------
char __cdecl sub_1001A730(char a1, char a2, char a3, _BYTE *a4)
{
  int v4; // edi@4
  bool v5; // bl@4
  int v6; // ecx@5
  char v8; // [sp+Fh] [bp-5h]@4
  unsigned __int8 v9; // [sp+10h] [bp-4h]@1

  v9 = sub_10049840(a1);
  if ( (unsigned __int8)sub_1001A190(v9, a3, a4) )
  {
    if ( a3 == 11 )
    {
      v8 = 1;
      goto LABEL_5;
    }
    if ( a3 == 17 )
    {
      sub_1001A160(v9, (int)&dword_10238B14);
      sub_10018810(7);
      return 1;
    }
    v4 = dword_10238B18[*a4];
    v5 = sub_1004B460(v9, (int)&dword_10238B14);
    dword_10238B18[*a4] = v4;
    v8 = v5;
    if ( v5 )
    {
LABEL_5:
      sub_10018810(2);
      sub_10018760(7, a1, a2, 17, 0, 0, 0);
      sub_10019B40(v6, v9, 1);
      sub_100186E0();
      return v8;
    }
  }
  else
  {
    v5 = 0;
  }
  sub_10018810(8);
  sub_10042370(byte_10238B38, 0x64u, "UNABLE TO STORE COM %d CONFIGURATION", v9 + 1);
  return v5;
}
// 10238B14: using guessed type int dword_10238B14;
// 10238B18: using guessed type int dword_10238B18[];

//----- (1001A840) --------------------------------------------------------
bool __cdecl sub_1001A840(char a1, char a2, unsigned __int8 *a3)
{
  char *v3; // edx@3
  unsigned int v4; // eax@4
  int *v5; // ecx@4
  int v6; // esi@8
  int v7; // eax@9
  _BYTE *v8; // ecx@9
  _BYTE *v9; // edx@9
  int v10; // eax@11
  _BYTE *v11; // ecx@11
  _BYTE *v12; // edx@11
  _BYTE *v13; // ecx@13
  _BYTE *v14; // edx@13
  signed int v15; // eax@15
  bool v16; // bl@16
  unsigned int v17; // eax@19
  int *v18; // ecx@19
  int v19; // esi@23
  int v20; // eax@24
  _BYTE *v21; // ecx@24
  _BYTE *v22; // edx@24
  int v23; // eax@26
  _BYTE *v24; // ecx@26
  _BYTE *v25; // edx@26
  _BYTE *v26; // ecx@28
  _BYTE *v27; // edx@28
  signed int v28; // eax@30
  int v29; // esi@35
  char v31; // [sp+Bh] [bp-19h]@35
  unsigned int v32; // [sp+Ch] [bp-18h]@1
  char v33; // [sp+10h] [bp-14h]@2

  LOBYTE(v32) = sub_10049840(a1);
  if ( !(unsigned __int8)sub_1001A190(v32, a2, a3) || !sub_1004B2B0(v32, a2, *a3, (int)&v33) )
  {
    v16 = 0;
LABEL_40:
    sub_10018720();
    if ( (unsigned int)sub_10018700() <= 0xF )
    {
      sub_10042370(byte_10238B38, 0x64u, "RESENDING COM %d", (unsigned __int8)v32 + 1);
      sub_10018810(1);
    }
    else
    {
      sub_10042370(byte_10238B38, 0x64u, "FAILED: UNABLE TO VERIFY COM %d", (unsigned __int8)v32 + 1);
      sub_10018810(8);
    }
    return v16;
  }
  v3 = &v33;
  if ( a2 == 11 )
  {
    v4 = 16;
    v5 = dword_10238B18;
    do
    {
      if ( *(_DWORD *)v3 != *v5 )
        goto LABEL_8;
      v4 -= 4;
      ++v5;
      v3 += 4;
    }
    while ( v4 >= 4 );
    if ( v4 )
    {
LABEL_8:
      v6 = (unsigned __int8)*v3 - *(_BYTE *)v5;
      if ( (unsigned __int8)*v3 != *(_BYTE *)v5
        || (v7 = v4 - 1, v8 = (char *)v5 + 1, v9 = v3 + 1, v7)
        && ((v6 = *v9 - *v8, *v9 != *v8)
         || (v10 = v7 - 1, v11 = v8 + 1, v12 = v9 + 1, v10)
         && ((v6 = *v12 - *v11, *v12 != *v11)
          || (v13 = v11 + 1, v14 = v12 + 1, v10 != 1) && (v6 = *v14 - *v13, *v14 != *v13))) )
      {
        v15 = 1;
        if ( v6 <= 0 )
        {
          v16 = 0;
          goto LABEL_34;
        }
LABEL_18:
        v16 = v15 == 0;
        goto LABEL_34;
      }
    }
    v15 = 0;
    goto LABEL_18;
  }
  v17 = 4;
  v18 = &dword_10238B18[*a3];
  do
  {
    if ( *(_DWORD *)v3 != *v18 )
      goto LABEL_23;
    v17 -= 4;
    ++v18;
    v3 += 4;
  }
  while ( v17 >= 4 );
  if ( !v17 )
  {
LABEL_32:
    v28 = 0;
    goto LABEL_33;
  }
LABEL_23:
  v19 = (unsigned __int8)*v3 - *(_BYTE *)v18;
  if ( (unsigned __int8)*v3 == *(_BYTE *)v18 )
  {
    v20 = v17 - 1;
    v21 = (char *)v18 + 1;
    v22 = v3 + 1;
    if ( !v20 )
      goto LABEL_32;
    v19 = *v22 - *v21;
    if ( *v22 == *v21 )
    {
      v23 = v20 - 1;
      v24 = v21 + 1;
      v25 = v22 + 1;
      if ( !v23 )
        goto LABEL_32;
      v19 = *v25 - *v24;
      if ( *v25 == *v24 )
      {
        v26 = v24 + 1;
        v27 = v25 + 1;
        if ( v23 == 1 )
          goto LABEL_32;
        v19 = *v27 - *v26;
        if ( *v27 == *v26 )
          goto LABEL_32;
      }
    }
  }
  v28 = 1;
  if ( v19 <= 0 )
    v28 = -1;
LABEL_33:
  v16 = v28 == 0;
LABEL_34:
  if ( !v16 )
    goto LABEL_40;
  v29 = (unsigned __int8)v32;
  if ( !sub_1003D360((unsigned __int8)byte_100A54C8[20 * (unsigned __int8)v32], (bool *)&v31) )
    goto LABEL_40;
  if ( !v31 )
  {
    sub_10018810(7);
    return v16;
  }
  sub_10018810(10);
  sub_10042370(byte_10238B38, 0x64u, "STORING COM %d CONFIGURATION", v29 + 1);
  return v16;
}
// 10238B18: using guessed type int dword_10238B18[];

//----- (1001AAB0) --------------------------------------------------------
void __cdecl sub_1001AAB0(char a1, int a2)
{
  int v2; // ecx@3
  int v3; // esi@3
  int v4; // ecx@4
  unsigned __int8 v5; // al@4

  if ( (unsigned __int8)a1 < 6u && (unsigned __int8)sub_1004DCB0() )
  {
    sub_1004DD90(a1, a2);
    v2 = dword_103334F4;
    v3 = 36 * (unsigned __int8)a1;
    if ( *(_DWORD *)a2 != *(_DWORD *)(v3 + dword_103334F4 + 4) )
    {
      v4 = v3 + dword_103334F4 + 12;
      *(_DWORD *)v4 = 0;
      *(_DWORD *)(v4 + 4) = 0;
      *(_DWORD *)(v4 + 8) = 0;
      *(_DWORD *)(v4 + 12) = 0;
      *(_DWORD *)(v4 + 16) = 0;
      v2 = dword_103334F4;
      v5 = *(_BYTE *)(v3 + dword_103334F4 + 37);
      if ( v5 < 6u && byte_10238BB1[28 * v5] == a1 )
      {
        dword_10238BB8[7 * (unsigned __int8)a1] = sub_10041EB0();
        v2 = dword_103334F4;
      }
    }
    *(_DWORD *)(v3 + v2 + 4) = *(_DWORD *)a2;
    *(_DWORD *)(v3 + dword_103334F4 + 8) = *(_DWORD *)(a2 + 4);
    sub_1004DCA0();
  }
}
// 10041EB0: using guessed type int sub_10041EB0(void);
// 10238BB8: using guessed type int dword_10238BB8[];
// 103334F4: using guessed type int dword_103334F4;

//----- (1001ABC0) --------------------------------------------------------
int __fastcall sub_1001ABC0(unsigned __int8 a1)
{
  int result; // eax@1

  result = 7 * a1;
  byte_10238BC8[result * 4] = 0;
  dword_10238BBC[result] = 0;
  dword_10238BC0[result] = 0;
  dword_10238BC4[result] = 0;
  return result * 4;
}
// 10238BBC: using guessed type int dword_10238BBC[];
// 10238BC0: using guessed type int dword_10238BC0[];
// 10238BC4: using guessed type int dword_10238BC4[];

//----- (1001ABF0) --------------------------------------------------------
char __usercall sub_1001ABF0@<al>(unsigned __int8 a1@<al>, unsigned __int8 a2@<bl>)
{
  unsigned int v2; // esi@1
  int v3; // eax@1
  int v4; // ecx@1
  char result; // al@1

  v2 = 28 * a1;
  byte_10238BB0[v2] = 6;
  v3 = sub_10041EB0();
  v4 = dword_103334F4;
  dword_10238BB8[v2 / 4] = v3;
  result = *(_BYTE *)(v4 + 36 * a2 + 38);
  if ( result != 6 && byte_10238BB1[v2] == a2 )
    byte_10238BB1[v2] = result;
  return result;
}
// 10041EB0: using guessed type int sub_10041EB0(void);
// 10238BB8: using guessed type int dword_10238BB8[];
// 103334F4: using guessed type int dword_103334F4;

//----- (1001AC40) --------------------------------------------------------
char __usercall sub_1001AC40@<al>(int a1@<edi>, unsigned __int8 a2)
{
  char result; // al@1
  unsigned __int8 v3; // bl@1
  char v4; // cl@1
  _BYTE *v5; // edx@1
  char v6; // cl@9
  char v7; // [sp+Bh] [bp-1h]@1

  result = 6;
  v3 = 0;
  v7 = 6;
  v4 = 0;
  v5 = (_BYTE *)(dword_103334F4 + 37);
  do
  {
    if ( *(_DWORD *)(v5 - 33) == a1 )
    {
      if ( a2 != 6 && *v5 != a2 )
      {
        result = v7;
      }
      else
      {
        result = v4;
        v7 = v4;
        ++v3;
      }
    }
    ++v4;
    v5 += 36;
  }
  while ( (unsigned __int8)v4 < 6u );
  if ( v3 > 1u )
  {
    v6 = byte_10238BB1[28 * a2];
    if ( v6 != 6 && *(_DWORD *)(dword_103334F4 + 36 * (unsigned __int8)v6 + 4) == a1 )
      result = byte_10238BB1[28 * a2];
  }
  return result;
}
// 103334F4: using guessed type int dword_103334F4;

//----- (1001ACC0) --------------------------------------------------------
char __usercall sub_1001ACC0@<al>(signed int a1@<eax>)
{
  char result; // al@4

  a1 = (unsigned __int16)a1;
  if ( (signed int)(unsigned __int16)a1 > 2592 )
  {
    switch ( a1 )
    {
      case 2599:
      case 2600:
        result = 3;
        break;
      case 2607:
      case 2608:
        result = 4;
        break;
      case 2615:
      case 2616:
        result = 5;
        break;
      default:
LABEL_11:
        result = 6;
        break;
    }
  }
  else if ( a1 >= 2591 )
  {
    result = 2;
  }
  else
  {
    switch ( a1 )
    {
      case 213:
      case 226:
        result = 0;
        break;
      case 218:
      case 227:
        result = 1;
        break;
      default:
        goto LABEL_11;
    }
  }
  return result;
}

//----- (1001AD60) --------------------------------------------------------
char sub_1001AD60()
{
  int v0; // esi@1
  signed int v1; // edi@1
  char result; // al@2
  unsigned __int8 v3; // bl@7
  char v4; // cl@17
  int v5; // edx@17
  int v6; // ebx@18
  char v7; // [sp+Eh] [bp-6h]@9
  char v8; // [sp+Fh] [bp-5h]@1
  int v9; // [sp+10h] [bp-4h]@7

  sub_1004DCD0((int)&v8);
  v0 = 0;
  v1 = 8;
  do
  {
    result = 0;
    if ( !byte_100A562C[v0] )
    {
      v3 = 0;
      LOBYTE(v9) = 0;
      while ( !result )
      {
        sub_1004E150(v9, 1, &v7);
        result = v7 == byte_100A562D[v0];
        LOBYTE(v9) = ++v3;
        if ( v3 >= 2u )
          goto LABEL_10;
      }
LABEL_11:
      if ( (unsigned __int8)sub_1004DCB0() )
      {
        *(_BYTE *)((unsigned __int8)byte_100A562F[v0] + dword_103334F4) = 1;
        if ( v8 == 1 && (unsigned __int8)byte_100A562E[v0] > 1u )
          *(_BYTE *)(((unsigned __int8)byte_100A562F[v0] + 1) % 2 + dword_103334F4) = 1;
        sub_1004DCA0();
      }
      result = byte_100A562E[v0];
      if ( result )
      {
        v4 = byte_100A5630[v0];
        v5 = (unsigned __int8)result;
        do
        {
          result = v4;
          v6 = 7 * (unsigned __int8)v4;
          v4 += 2;
          --v5;
          byte_10238BB2[4 * v6] = 1;
        }
        while ( v5 );
      }
      goto LABEL_19;
    }
    if ( byte_100A562C[v0] == 1 )
    {
      result = sub_100471F0(byte_100A562D[v0]);
    }
    else
    {
      if ( byte_100A562C[v0] != 2 )
        goto LABEL_19;
      result = sub_10047320(byte_100A562D[v0]);
    }
LABEL_10:
    if ( result )
      goto LABEL_11;
LABEL_19:
    v0 += 5;
    --v1;
  }
  while ( v1 );
  return result;
}
// 103334F4: using guessed type int dword_103334F4;

//----- (1001AE90) --------------------------------------------------------
int sub_1001AE90()
{
  int *v0; // esi@1
  signed int v1; // edi@1
  int result; // eax@3
  signed int v3; // ecx@3
  int v4; // ebp@5
  char v5; // bl@5
  int v6; // edi@5
  int v7; // esi@5
  unsigned __int8 v8; // cl@7
  unsigned __int8 v9; // dl@14
  int *v10; // edi@24
  char v11; // bl@25
  char v12; // dl@25
  int v13; // ecx@25
  int v14; // esi@25
  bool v15; // zf@33
  int v16; // esi@34
  int v17; // edx@34
  signed int v18; // edi@34
  char v19; // [sp+8h] [bp-Ch]@23
  unsigned __int8 v20; // [sp+8h] [bp-Ch]@25
  char v21; // [sp+9h] [bp-Bh]@1
  char v22; // [sp+9h] [bp-Bh]@25
  char v23; // [sp+Ah] [bp-Ah]@23
  char v24; // [sp+Bh] [bp-9h]@1
  int v25; // [sp+Ch] [bp-8h]@1
  int v26; // [sp+10h] [bp-4h]@24

  v21 = 0;
  v24 = 2;
  v25 = 101058054;
  byte_10238BA8 = 6;
  v0 = dword_10238BB8;
  v1 = 6;
  do
  {
    *((_BYTE *)v0 - 7) = 6;
    *v0 = sub_10041EB0();
    v0 += 7;
    --v1;
  }
  while ( v1 );
  result = 0;
  v3 = 6;
  do
  {
    *(_BYTE *)(result + dword_103334F4 + 37) = 6;
    *(_BYTE *)(result + dword_103334F4 + 38) = 6;
    result += 36;
    --v3;
  }
  while ( v3 );
  v4 = dword_103334F4;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  do
  {
    if ( *(_BYTE *)(v6 + v4) )
    {
      v8 = 0;
      while ( 1 )
      {
        result = 28 * v8;
        if ( byte_10238BB2[result] )
        {
          if ( byte_10238BB1[result] == 6 )
            break;
        }
        if ( ++v8 >= 6u )
          goto LABEL_13;
      }
      result = v8;
      byte_10238BB1[28 * v8] = v5;
      *(_BYTE *)(v7 + v4 + 37) = v8;
      v4 = dword_103334F4;
    }
LABEL_13:
    ++v5;
    ++v6;
    v7 += 36;
  }
  while ( (unsigned __int8)v5 < 2u );
  v9 = 0;
  do
  {
    if ( v9 >= 6u )
      break;
    result = 28 * v9;
    if ( byte_10238BB2[result] && !byte_10238BB3[result] && !byte_10238BB4[result] && byte_10238BB1[result] == 6 )
      *((_BYTE *)&v25 + (unsigned __int8)v21++) = v9;
    ++v9;
  }
  while ( (unsigned __int8)v21 < 4u );
  *(_BYTE *)(v4 + 2) = v21;
  if ( v21 )
  {
    result = 4 / (unsigned __int8)v21;
    v23 = 4 % (unsigned __int8)v21;
    v19 = 4 / (unsigned __int8)v21;
    if ( v21 )
    {
      v10 = &v25;
      v26 = (unsigned __int8)v21;
      do
      {
        v20 = v23 + v19;
        v11 = *(_BYTE *)v10;
        v12 = v24;
        result = v20;
        byte_10238BB1[28 * *(_BYTE *)v10] = v24;
        v13 = (unsigned __int8)v24;
        v14 = v20 + (unsigned __int8)v24;
        v22 = v11;
        if ( (unsigned __int8)v24 < v14 )
        {
          while ( 1 )
          {
            result = 36 * v13;
            *(_BYTE *)(36 * v13 + dword_103334F4 + 37) = v11;
            if ( v20 > 1u )
            {
              if ( v13 == v14 - 1 )
                *(_BYTE *)(result + dword_103334F4 + 38) = v24;
              else
                *(_BYTE *)(result + dword_103334F4 + 38) = v12 + 1;
            }
            v13 = (unsigned __int8)++v12;
            if ( (unsigned __int8)v12 >= v14 )
              break;
            v11 = v22;
          }
        }
        v19 = v20 - v23;
        v10 = (int *)((char *)v10 + 1);
        v15 = v26-- == 1;
        v23 = 0;
        v24 = v12;
      }
      while ( !v15 );
    }
  }
  v16 = dword_103334F4;
  v17 = 0;
  v18 = 6;
  do
  {
    LOBYTE(result) = *(_BYTE *)(v17 + v16 + 37);
    if ( (_BYTE)result == 6 || (result = 28 * (unsigned __int8)result, byte_10238BB3[result]) || byte_10238BB4[result] )
    {
      *(_BYTE *)(v17 + v16 + 36) = 0;
      v16 = dword_103334F4;
    }
    v17 += 36;
    --v18;
  }
  while ( v18 );
  return result;
}
// 10041EB0: using guessed type int sub_10041EB0(void);
// 10238BA8: using guessed type char byte_10238BA8;
// 10238BB8: using guessed type int dword_10238BB8[];
// 103334F4: using guessed type int dword_103334F4;

//----- (1001B110) --------------------------------------------------------
char __usercall sub_1001B110@<al>(int a1@<eax>, unsigned __int8 a2@<dl>)
{
  char result; // al@2

  if ( *(_BYTE *)(a1 + 5) >= 6u )
  {
    byte_10238BB3[28 * a2] = 1;
    byte_10238BA8 = sub_1001AC40(*(_DWORD *)a1, 6u);
    result = sub_1001AE90();
  }
  else
  {
    *(_BYTE *)(dword_103334F4 + 36 * *(_BYTE *)(a1 + 5) + 37) = a2;
    result = *(_BYTE *)(a1 + 5);
    byte_10238BB1[28 * a2] = result;
  }
  return result;
}
// 10238BA8: using guessed type char byte_10238BA8;
// 103334F4: using guessed type int dword_103334F4;

//----- (1001B170) --------------------------------------------------------
int __cdecl sub_1001B170(signed int a1)
{
  int result; // eax@1
  char v2; // al@2
  int v3; // eax@3

  result = sub_1004DCB0();
  if ( (_BYTE)result )
  {
    v2 = sub_1001ACC0(a1);
    if ( (unsigned __int8)v2 < 6u )
    {
      v3 = 28 * (unsigned __int8)v2;
      if ( byte_10238BB2[v3] )
      {
        byte_10238BB4[v3] = 1;
        sub_1001AE90();
      }
    }
    result = sub_1004DCA0();
  }
  return result;
}

//----- (1001B1C0) --------------------------------------------------------
unsigned __int8 __cdecl sub_1001B1C0(signed int a1, int a2)
{
  unsigned __int8 result; // al@1
  int v3; // edi@2
  char v4; // bl@4
  int v5; // esi@8
  int v6; // eax@11

  result = sub_1001ACC0(a1);
  if ( result < 6u )
  {
    v3 = 28 * result;
    if ( !byte_10238BB3[v3] || byte_10238BB1[v3] != 6 || (v4 = byte_10238BA8, (unsigned __int8)byte_10238BA8 >= 6u) )
      v4 = byte_10238BB1[v3];
    if ( (unsigned __int8)v4 < 6u )
    {
      result = sub_1004DCB0();
      if ( result )
      {
        v5 = 36 * (unsigned __int8)v4;
        sub_1004DCF0(v4, (void *)(v5 + dword_103334F4 + 4));
        if ( byte_10238BB3[v3] )
          *(_BYTE *)(v5 + dword_103334F4 + 9) = 6;
        else
          *(_BYTE *)(v5 + dword_103334F4 + 9) = v4;
        v6 = sub_10041EB0();
        sub_10023190(a1, 1, a2, (const void *)(v5 + dword_103334F4 + 4), v6);
        result = sub_1004DCA0();
      }
    }
  }
  return result;
}
// 10041EB0: using guessed type int sub_10041EB0(void);
// 10238BA8: using guessed type char byte_10238BA8;
// 103334F4: using guessed type int dword_103334F4;

//----- (1001B290) --------------------------------------------------------
int sub_1001B290()
{
  unsigned __int8 v0; // bl@1
  char *v1; // esi@1
  int result; // eax@3
  char v3; // bl@4
  int v4; // esi@4
  char v5; // [sp+8h] [bp-4h]@4

  v0 = 0;
  v1 = byte_10238BB2;
  do
  {
    *(v1 - 2) = 6;
    *v1 = 0;
    v1[1] = 0;
    v1[2] = 0;
    *(_DWORD *)(v1 + 6) = sub_10041EB0();
    sub_1001ABC0(v0++);
    v1 += 28;
  }
  while ( v0 < 6u );
  sub_1004DC20();
  sub_1001AD60();
  result = sub_1004DCB0();
  if ( (_BYTE)result )
  {
    v3 = 0;
    v5 = 0;
    v4 = 0;
    do
    {
      if ( !sub_1004DCF0(v5, (void *)(v4 + dword_103334F4 + 4)) )
      {
        *(_DWORD *)(v4 + dword_103334F4 + 4) = 109000;
        *(_BYTE *)(v4 + dword_103334F4 + 8) = 2;
      }
      ++v3;
      v4 += 36;
      v5 = v3;
    }
    while ( (unsigned __int8)v3 < 6u );
    sub_1001AE90();
    result = sub_1004DCA0();
  }
  return result;
}
// 10041EB0: using guessed type int sub_10041EB0(void);
// 103334F4: using guessed type int dword_103334F4;

//----- (1001B350) --------------------------------------------------------
char __cdecl sub_1001B350(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // ecx@0
  int v3; // eax@1
  char v4; // bl@3
  unsigned __int8 v5; // dl@3
  bool v6; // bl@4
  int v8; // [sp+0h] [bp-4h]@1

  v8 = v2;
  BYTE2(v8) = 0;
  LOBYTE(v3) = sub_100473B0((bool *)&v8 + 1);
  if ( (_BYTE)v3 && !BYTE1(v8) )
  {
    v4 = byte_10238BC8[28 * a1];
    v3 = 28 * a1;
    v5 = 0;
    if ( v4 )
    {
      v6 = BYTE2(v8);
      while ( !v6 )
      {
        v6 = dword_10238BBC[v5++ + 7 * a1] == *(_DWORD *)(dword_103334F4 + 36 * a2 + 4);
        if ( v5 >= (unsigned __int8)byte_10238BC8[v3] )
        {
          if ( v6 )
            return v3;
          v4 = byte_10238BC8[v3];
          goto LABEL_9;
        }
      }
    }
    else
    {
LABEL_9:
      dword_10238BBC[(unsigned __int8)v4 + 7 * a1] = *(_DWORD *)(dword_103334F4 + 36 * a2 + 4);
      if ( (unsigned __int8)++byte_10238BC8[v3] >= 3u )
      {
        byte_10238BB3[v3] = 1;
        LOBYTE(v3) = sub_1001AE90();
      }
    }
  }
  return v3;
}
// 10238BBC: using guessed type int dword_10238BBC[];
// 103334F4: using guessed type int dword_103334F4;

//----- (1001B430) --------------------------------------------------------
char __usercall sub_1001B430@<al>(unsigned __int8 a1@<cl>, int a2@<edi>)
{
  unsigned int v2; // esi@1
  char result; // al@4
  char v4; // al@6

  v2 = 28 * a1;
  if ( !byte_10238BB2[v2] )
    return 1;
  if ( byte_10238BB4[v2] )
  {
    byte_10238BB4[v2] = 0;
    sub_1001AE90();
    return 1;
  }
  if ( byte_10238BB3[v2] )
  {
    v4 = byte_10238BA8;
    if ( (unsigned __int8)byte_10238BB1[v2] < 6u )
      v4 = byte_10238BB1[v2];
    if ( (unsigned __int8)v4 >= 6u
      || !*(_BYTE *)(a2 + 12)
      || *(_DWORD *)(dword_103334F4 + 36 * (unsigned __int8)v4 + 4) != *(_DWORD *)(a2 + 16) )
    {
      return 1;
    }
    byte_10238BB3[v2] = 0;
    sub_1001ABC0(a1);
    sub_1001AE90();
    result = 1;
  }
  else if ( (unsigned int)(sub_10041EB0() - dword_10238BB8[v2 / 4]) < 0x2710 )
  {
    result = 0;
  }
  else
  {
    byte_10238BB3[v2] = 1;
    sub_1001AE90();
    result = 1;
  }
  return result;
}
// 10041EB0: using guessed type int sub_10041EB0(void);
// 10238BA8: using guessed type char byte_10238BA8;
// 10238BB8: using guessed type int dword_10238BB8[];
// 103334F4: using guessed type int dword_103334F4;

//----- (1001B4E0) --------------------------------------------------------
char __usercall sub_1001B4E0@<al>(int a1@<eax>, unsigned __int8 a2@<cl>, int a3, char a4)
{
  int v4; // esi@1
  unsigned __int8 v5; // bl@1
  int v6; // edi@1
  unsigned int v7; // eax@1
  unsigned __int8 v8; // cl@2
  char v9; // al@3
  int v10; // ebp@3
  int v11; // eax@7
  int v12; // edx@8
  int v13; // edi@8
  int v14; // eax@10
  int v15; // eax@10
  int v16; // eax@10
  int v17; // esi@10
  int v18; // eax@10
  bool v19; // zf@10
  int v20; // eax@16
  int v21; // eax@16
  int v22; // eax@18
  int v23; // eax@18
  unsigned __int8 v25; // [sp+Ch] [bp-4h]@1

  v4 = a1;
  v5 = a2;
  v6 = a1;
  v25 = sub_1001AC40(*(_DWORD *)(a1 + 16), a2);
  LOBYTE(v7) = sub_1001B430(v5, v6);
  if ( !(_BYTE)v7 )
  {
    v8 = v25;
    if ( v25 < 6u )
    {
      v9 = byte_10238BB0[28 * v5];
      v10 = 7 * v5;
      if ( (unsigned __int8)v9 < 6u && v9 != v25 )
      {
        if ( (unsigned int)(sub_10041EB0() - dword_10238BB8[v10]) >= 0x12C0 )
        {
          *(_BYTE *)(dword_103334F4 + 36 * (unsigned __int8)byte_10238BB0[v10 * 4] + 24) = 0;
          sub_1001B350(v5, byte_10238BB0[v10 * 4]);
        }
        v11 = sub_10041EB0();
        v8 = v25;
        dword_10238BB8[v10] = v11;
      }
      LOBYTE(v7) = a4;
      v12 = dword_103334F4;
      v13 = 36 * v8;
      byte_10238BB0[v10 * 4] = v8;
      *(_BYTE *)(v13 + v12 + 36) = a4;
      if ( a4 )
      {
        if ( *(_BYTE *)(v4 + 12) )
        {
          v14 = dword_103334F4;
          *(_DWORD *)(v13 + dword_103334F4 + 12) = *(_DWORD *)v4;
          v15 = v13 + v14 + 12;
          *(_DWORD *)(v15 + 4) = *(_DWORD *)(v4 + 4);
          *(_DWORD *)(v15 + 8) = *(_DWORD *)(v4 + 8);
          *(_DWORD *)(v15 + 12) = *(_DWORD *)(v4 + 12);
          *(_DWORD *)(v15 + 16) = *(_DWORD *)(v4 + 16);
          v16 = sub_1004DDD0();
          v17 = sub_1007D0E0(a3, v16);
          v18 = sub_10041EB0();
          v19 = byte_10238BA8 == 6;
          *(_DWORD *)(v13 + dword_103334F4 + 32) = v18 - v17;
          if ( v19 )
            byte_10238BA8 = v25;
          sub_1001ABC0(v5);
          LOBYTE(v7) = sub_1001ABF0(v5, v25);
        }
        else
        {
          if ( byte_10238BA8 == v8 )
            byte_10238BA8 = 6;
          if ( v8 >= 2u )
          {
            v7 = sub_10041EB0() - dword_10238BB8[v10];
            if ( v7 >= 0x1388 )
            {
              v22 = dword_103334F4;
              *(_DWORD *)(v13 + dword_103334F4 + 12) = *(_DWORD *)v4;
              v23 = v13 + v22 + 12;
              *(_DWORD *)(v23 + 4) = *(_DWORD *)(v4 + 4);
              *(_DWORD *)(v23 + 8) = *(_DWORD *)(v4 + 8);
              *(_DWORD *)(v23 + 12) = *(_DWORD *)(v4 + 12);
              *(_DWORD *)(v23 + 16) = *(_DWORD *)(v4 + 16);
              sub_1001B350(v5, v25);
              LOBYTE(v7) = sub_1001ABF0(v5, v25);
            }
          }
          else
          {
            v20 = dword_103334F4;
            *(_DWORD *)(v13 + dword_103334F4 + 12) = *(_DWORD *)v4;
            v21 = v13 + v20 + 12;
            *(_DWORD *)(v21 + 4) = *(_DWORD *)(v4 + 4);
            *(_DWORD *)(v21 + 8) = *(_DWORD *)(v4 + 8);
            *(_DWORD *)(v21 + 12) = *(_DWORD *)(v4 + 12);
            *(_DWORD *)(v21 + 16) = *(_DWORD *)(v4 + 16);
            LOBYTE(v7) = sub_1001ABF0(v5, v8);
          }
        }
      }
    }
  }
  return v7;
}
// 10041EB0: using guessed type int sub_10041EB0(void);
// 10238BA8: using guessed type char byte_10238BA8;
// 10238BB8: using guessed type int dword_10238BB8[];
// 103334F4: using guessed type int dword_103334F4;

//----- (1001B6D0) --------------------------------------------------------
BOOL __cdecl sub_1001B6D0(int a1, int a2)
{
  char v2; // al@1
  char v3; // bl@1
  int v4; // edi@1
  BOOL result; // eax@1
  unsigned __int8 v6; // [sp+Fh] [bp-1Dh]@1
  char v7; // [sp+10h] [bp-1Ch]@1
  int v8; // [sp+14h] [bp-18h]@1
  int v9; // [sp+18h] [bp-14h]@1
  int v10; // [sp+1Ch] [bp-10h]@1
  int v11; // [sp+20h] [bp-Ch]@1
  int v12; // [sp+24h] [bp-8h]@1

  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v2 = sub_10023DA0(a1, a2, &v8);
  v3 = v2;
  v7 = v2;
  v4 = sub_10022640(a1, a2);
  v6 = sub_1001ACC0(a1);
  result = sub_1004DCB0();
  if ( (_BYTE)result )
  {
    if ( (signed int)(unsigned __int16)a1 > 2599 )
    {
      switch ( (unsigned __int16)a1 )
      {
        case 0xA28u:
        case 0xA30u:
        case 0xA38u:
          goto LABEL_8;
        default:
          return sub_1004DCA0();
        case 0xA2Fu:
        case 0xA37u:
          break;
      }
    }
    else if ( (unsigned __int16)a1 != 2599 )
    {
      if ( (signed int)(unsigned __int16)a1 > 227 )
      {
        if ( (unsigned __int16)a1 != 2591 )
        {
          if ( (unsigned __int16)a1 != 2592 )
            return sub_1004DCA0();
          goto LABEL_8;
        }
      }
      else if ( (signed int)(unsigned __int16)a1 < 226 )
      {
        if ( (unsigned __int16)a1 != 213 && (unsigned __int16)a1 != 218 )
          return sub_1004DCA0();
LABEL_8:
        sub_1001B4E0((int)&v8, v6, v4, v7);
        return sub_1004DCA0();
      }
    }
    if ( v3 )
      sub_1001B110((int)&v8, v6);
    return sub_1004DCA0();
  }
  return result;
}

//----- (1001B7E0) --------------------------------------------------------
int sub_1001B7E0()
{
  int result; // eax@1

  result = 0;
  dword_10238C58 = 0;
  word_10238C5C = 0;
  return result;
}
// 10238C58: using guessed type int dword_10238C58;
// 10238C5C: using guessed type __int16 word_10238C5C;

//----- (1001B7F0) --------------------------------------------------------
char __usercall sub_1001B7F0@<al>(char result@<al>)
{
  int v1; // esi@2
  int v2; // eax@2

  switch ( result )
  {
    case 0:
      v1 = sub_10046210(1);
      v2 = sub_10046210(0);
      sub_100462F0(1, v2);
      result = sub_100462F0(0, v1);
      break;
    case 5:
      result = sub_100462F0(1, 121500);
      break;
    case 1:
      result = sub_10043480(0x22u);
      break;
    case 3:
      result = sub_10043370(35);
      break;
    case 4:
      result = sub_10043480(0x23u);
      break;
    case 6:
      result = sub_10043370(34);
      break;
    default:
      return result;
  }
  return result;
}

//----- (1001B880) --------------------------------------------------------
char __usercall sub_1001B880@<al>(int a1@<esi>)
{
  unsigned int v1; // eax@1
  void *v2; // ecx@1
  bool v3; // bl@2
  int v4; // ecx@5

  v1 = sub_1007C040();
  if ( v1 > dword_10238C58 )
  {
    v3 = (*(_WORD *)a1 & 0x1000) == 4096;
    LOBYTE(v1) = sub_10046190(v2);
    if ( v3 != (_BYTE)v1 )
      LOBYTE(v1) = sub_100462C0(v1);
    if ( !v3 )
    {
      v4 = sub_10046210(1);
      v1 = 274877907 * *(_DWORD *)(a1 + 4);
      if ( *(_DWORD *)(a1 + 4) / 0x3E8u != v4 )
        LOBYTE(v1) = sub_10046260(v4);
    }
  }
  return v1;
}
// 10238C58: using guessed type int dword_10238C58;

//----- (1001B8F0) --------------------------------------------------------
char __cdecl sub_1001B8F0(unsigned __int8 a1, int a2)
{
  char v2; // bl@1
  __int16 *v3; // eax@1
  bool v4; // zf@2
  signed int v5; // ecx@5

  v2 = 0;
  LOBYTE(v3) = sub_10043FF0(&a1, 1u, (int)&unk_100A5B80, 8, 2, 2);
  if ( (unsigned __int8)v3 < 2u )
  {
    v4 = (a2 & dword_100A5B84[2 * (unsigned __int8)v3]) == 0;
    LOBYTE(v3) = a1;
    if ( v4 )
    {
      if ( *((_BYTE *)&word_10238C5C + a1) == 1 )
      {
        *((_BYTE *)&word_10238C5C + a1) = 0;
        v3 = &word_10238C5C;
        v5 = 2;
        do
        {
          if ( v2 || *(_BYTE *)v3 )
            v2 = 1;
          v3 = (__int16 *)((char *)v3 + 1);
          --v5;
        }
        while ( v5 );
        if ( !v2 )
          LOBYTE(v3) = sub_10043370(33);
      }
    }
    else
    {
      *((_BYTE *)&word_10238C5C + a1) = 1;
      LOBYTE(v3) = sub_10043480(0x21u);
    }
  }
  if ( !a1 )
  {
    if ( a2 & 0x10 )
      sub_10043480(0x27u);
    else
      sub_10043370(39);
    if ( a2 & 0x40 )
      LOBYTE(v3) = sub_10043480(0x26u);
    else
      LOBYTE(v3) = sub_10043370(38);
  }
  return (unsigned int)v3;
}
// 100A5B84: using guessed type int dword_100A5B84[];
// 10238C5C: using guessed type __int16 word_10238C5C;

//----- (1001B9B0) --------------------------------------------------------
char __cdecl sub_1001B9B0(int a1, int a2)
{
  int v2; // eax@1
  char v4; // [sp+4h] [bp-58h]@1
  int v5; // [sp+3Ch] [bp-20h]@8
  int v6; // [sp+40h] [bp-1Ch]@13

  memset(&v4, 0, 0x54u);
  LOBYTE(v2) = sub_10023DA0(a1, a2, &v4);
  if ( (_BYTE)v2 )
  {
    if ( (signed int)(unsigned __int16)a1 > 1671 )
    {
      if ( (unsigned __int16)a1 == 1940 )
      {
        LOBYTE(v2) = sub_1001B8F0(1u, v6);
      }
      else
      {
        LOBYTE(v2) = a1 + 102;
        if ( (unsigned __int16)a1 == 1946 )
          LOBYTE(v2) = sub_1001B880((int)&v4);
      }
    }
    else
    {
      if ( (unsigned __int16)a1 == 1671 )
        goto LABEL_17;
      if ( (unsigned __int16)a1 == 1653 )
      {
        LOBYTE(v2) = sub_1001B8F0(0, v5);
        return v2;
      }
      if ( (unsigned __int16)a1 == 1657 )
      {
LABEL_17:
        v2 = sub_1007C040() + 2000;
        dword_10238C58 = v2;
        return v2;
      }
      LOBYTE(v2) = a1 + 123;
      if ( (unsigned __int16)a1 == 1669 )
        LOBYTE(v2) = sub_1001B7F0(v4);
    }
  }
  return v2;
}
// 10238C58: using guessed type int dword_10238C58;

//----- (1001BA90) --------------------------------------------------------
char __cdecl sub_1001BA90(int a1, int a2, int a3, int a4, char a5, int a6)
{
  int v6; // eax@1
  char result; // al@2

  v6 = sub_10043FF0(&a5, 1u, (int)&unk_100A60B8, 101, 10, 10);
  if ( v6 >= 10 )
  {
    result = 0;
  }
  else
  {
    sub_100421E0(a6, &byte_100A60B9[101 * v6], 100);
    result = 1;
  }
  return result;
}

//----- (1001BAE0) --------------------------------------------------------
char sub_1001BAE0()
{
  char v0; // bl@1
  char result; // al@3

  v0 = 1;
  if ( sub_10018710() != 5 || (v0 = sub_1004E910(&unk_10238D88)) != 0 )
  {
    sub_1004E950((int)&unk_10238D88);
    sub_10018810(7);
    result = v0;
  }
  else
  {
    sub_10018720();
    if ( (unsigned int)sub_10018700() <= 0x14 )
    {
      sub_10018810(2);
      result = 0;
    }
    else
    {
      sub_10018810(8);
      result = 0;
    }
  }
  return result;
}

//----- (1001BB50) --------------------------------------------------------
char sub_1001BB50()
{
  char v0; // bl@1
  unsigned int v1; // eax@2
  _DWORD *v2; // ecx@2
  _DWORD *v3; // edx@2
  int v4; // esi@6
  int v5; // eax@7
  _BYTE *v6; // ecx@7
  _BYTE *v7; // edx@7
  int v8; // eax@9
  _BYTE *v9; // ecx@9
  _BYTE *v10; // edx@9
  _BYTE *v11; // ecx@11
  _BYTE *v12; // edx@11
  signed int v13; // eax@13
  char result; // al@19
  int v15; // [sp+8h] [bp-4h]@0

  v0 = sub_10018710();
  if ( !sub_1004E910(&unk_10238D88) )
  {
    LOBYTE(v15) = 2;
    goto LABEL_23;
  }
  v1 = 284;
  v2 = &unk_10238C68;
  v3 = &unk_10238D88;
  do
  {
    if ( *v3 != *v2 )
      goto LABEL_6;
    v1 -= 4;
    ++v2;
    ++v3;
  }
  while ( v1 >= 4 );
  if ( !v1 )
  {
LABEL_15:
    v13 = 0;
    goto LABEL_16;
  }
LABEL_6:
  v4 = *(_BYTE *)v3 - *(_BYTE *)v2;
  if ( *(_BYTE *)v3 == *(_BYTE *)v2 )
  {
    v5 = v1 - 1;
    v6 = (char *)v2 + 1;
    v7 = (char *)v3 + 1;
    if ( !v5 )
      goto LABEL_15;
    v4 = *v7 - *v6;
    if ( *v7 == *v6 )
    {
      v8 = v5 - 1;
      v9 = v6 + 1;
      v10 = v7 + 1;
      if ( !v8 )
        goto LABEL_15;
      v4 = *v10 - *v9;
      if ( *v10 == *v9 )
      {
        v11 = v9 + 1;
        v12 = v10 + 1;
        if ( v8 == 1 )
          goto LABEL_15;
        v4 = *v12 - *v11;
        if ( *v12 == *v11 )
          goto LABEL_15;
      }
    }
  }
  v13 = 1;
  if ( v4 <= 0 )
    v13 = -1;
LABEL_16:
  if ( !v13 )
  {
    if ( v0 == 1 || v0 == 5 )
    {
      LOBYTE(v15) = 7;
      sub_10018810(v15);
      result = 1;
    }
    else
    {
      LOBYTE(v15) = 10;
      sub_10018810(v15);
      result = 1;
    }
    return result;
  }
  LOBYTE(v15) = 1;
LABEL_23:
  sub_10018720();
  if ( (unsigned int)sub_10018700() > 0x14 )
    LOBYTE(v15) = 8;
  sub_10018810(v15);
  return 0;
}

//----- (1001BC80) --------------------------------------------------------
char sub_1001BC80()
{
  if ( j_HWM_pvg_read_reg(1) || (unsigned int)(sub_1007C040() - dword_10238D84) > 0x1F4 )
    sub_10018810((unsigned __int8)byte_10238C60);
  return 1;
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10238C60: using guessed type char byte_10238C60;
// 10238D84: using guessed type int dword_10238D84;

//----- (1001BCC0) --------------------------------------------------------
char __cdecl sub_1001BCC0(char a1, _BYTE *a2)
{
  int v2; // ecx@0
  char result; // al@1
  int v4; // [sp-2h] [bp-4h]@1

  v4 = v2;
  result = 0;
  BYTE3(v4) = 0;
  if ( a1 )
  {
    if ( a1 != 1 )
      goto LABEL_7;
    result = sub_100253C0(1, 1945, (char *)&v4 + 3);
  }
  else
  {
    result = sub_100253C0(1, 1944, (char *)&v4 + 3);
  }
  if ( result == 1 )
  {
    *a2 = BYTE3(v4);
    return result;
  }
LABEL_7:
  *a2 = 0;
  return result;
}

//----- (1001BD10) --------------------------------------------------------
char __cdecl sub_1001BD10(unsigned __int8 a1, char a2)
{
  char result; // al@1

  result = a2;
  if ( a2 == 4 )
    result = 1;
  if ( a1 < 2u )
    byte_10238EA4[a1] = result;
  return result;
}

//----- (1001BD30) --------------------------------------------------------
char __usercall sub_1001BD30@<al>(unsigned int *a1@<esi>)
{
  char v1; // bl@1
  char v3; // [sp+4h] [bp-120h]@1

  v1 = sub_1004E930((int)&v3);
  if ( v1 )
    *a1 = sub_1007B8C0((unsigned int *)&v3, 284, 0xFFFFFFFF);
  return v1;
}

//----- (1001BD90) --------------------------------------------------------
char sub_1001BD90()
{
  char result; // al@1
  char v1; // bl@1

  result = sub_10045FC0(50331648);
  v1 = result;
  if ( byte_10238C62 != result )
  {
    if ( result )
    {
      result = sub_10043370(37);
      byte_10238C62 = v1;
    }
    else
    {
      result = sub_100432C0(36);
      if ( !result )
      {
        result = sub_100432C0(278);
        if ( !result )
        {
          result = sub_100432C0(279);
          if ( !result )
          {
            result = sub_100432C0(33);
            if ( !result )
              result = sub_10043480(0x25u);
          }
        }
      }
      byte_10238C62 = 0;
    }
  }
  return result;
}
// 10238C62: using guessed type char byte_10238C62;

//----- (1001BE10) --------------------------------------------------------
char __cdecl sub_1001BE10(char a1)
{
  char result; // al@1

  sub_10018810(4);
  dword_10238D84 = sub_1007C040();
  result = a1;
  byte_10238C60 = a1;
  return result;
}
// 10238C60: using guessed type char byte_10238C60;
// 10238D84: using guessed type int dword_10238D84;

//----- (1001BE30) --------------------------------------------------------
char sub_1001BE30()
{
  unsigned __int8 v0; // bl@1
  void *v1; // ecx@1
  char v2; // al@2
  char result; // al@2
  unsigned __int8 v4; // [sp+4h] [bp-4h]@1

  v0 = 0;
  byte_10238C61 = 0;
  dword_10238EA8 = sub_1007C040();
  byte_10238C62 = 1;
  v4 = 0;
  do
  {
    v2 = sub_100460C0(v1);
    result = sub_1001BD10(v4, v2);
    v4 = ++v0;
  }
  while ( v0 < 2u );
  return result;
}
// 10238C61: using guessed type char byte_10238C61;
// 10238C62: using guessed type char byte_10238C62;
// 10238EA8: using guessed type int dword_10238EA8;

//----- (1001BE80) --------------------------------------------------------
char __cdecl sub_1001BE80(int a1, char a2)
{
  void *v2; // ecx@0
  char v3; // bl@1
  int v4; // eax@1
  __int64 v6; // [sp+8h] [bp-Ch]@1

  v3 = 0;
  HIDWORD(v6) = sub_100429D0(v2);
  LODWORD(v6) = (unsigned __int16)((a2 == 17) + 1947);
  sub_10022340(v6, (int)&byte_10332F00);
  LOBYTE(v4) = 1;
  sub_1001D5C0(8, 0, v4, 0, &v6, 0x1000000);
  switch ( sub_10018710() )
  {
    case 1:
    case 4:
      sub_1001BE10(3);
      v3 = 1;
      break;
    case 5:
      if ( sub_100186F0() )
      {
        sub_1001BE10(10);
        v3 = 1;
      }
      else
      {
        sub_1001BE10(3);
        v3 = 1;
      }
      break;
    case 2:
      sub_10018810(0);
      v3 = 1;
      break;
    default:
      sub_10018810(8);
      break;
  }
  if ( a2 == 11 && j_HWM_pvg_read_reg(1) == 1 )
    sub_10024E60(1, 1947, &unk_10238C68, 1, 284, 1);
  return v3;
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10332F00: using guessed type char byte_10332F00;

//----- (1001BFA0) --------------------------------------------------------
char __cdecl sub_1001BFA0(int a1, int a2, int a3, int a4, void *a5, size_t a6)
{
  void *v6; // eax@2
  char v7; // bl@2

  if ( a6 )
  {
    v6 = memcpy(&unk_10238D88, a5, a6);
    v7 = 1;
    goto LABEL_3;
  }
  v6 = (void *)sub_1004E930((int)&unk_10238D88);
  v7 = (char)v6;
  if ( (_BYTE)v6 )
  {
LABEL_3:
    LOBYTE(v6) = 1;
    sub_1001D5C0(284, 1, (int)v6, 1947, &unk_10238D88, 0x1000000);
    qmemcpy(&unk_10238C68, &unk_10238D88, 0x11Cu);
    sub_1001BE10(2);
    return v7;
  }
  sub_10018810(8);
  return v7;
}

//----- (1001C030) --------------------------------------------------------
char __cdecl sub_1001C030(unsigned __int8 a1, signed int a2)
{
  void *v2; // ecx@0
  char result; // al@1
  void *v4; // ecx@6
  int v5; // eax@8

  result = a2;
  switch ( (unsigned __int8)a2 )
  {
    case 1u:
      a2 = 2;
      goto LABEL_6;
    case 2u:
      a2 = 3;
      goto LABEL_6;
    case 8u:
      a2 = 4;
      goto LABEL_6;
    case 0x10u:
      a2 = 5;
LABEL_6:
      if ( sub_100429D0(v2) == 1 || (result = sub_100460A0(v4), !(result & 1)) )
      {
        v5 = a1;
        if ( a1 )
        {
          result = a1 - 1;
          if ( a1 == 1 )
            result = sub_1001D5C0(4, 0, 1, 1943, &a2, 0x2000000);
        }
        else
        {
          LOBYTE(v5) = 1;
          result = sub_1001D5C0(4, 0, v5, 1674, &a2, 0x1000000);
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

//----- (1001C100) --------------------------------------------------------
char __cdecl sub_1001C100(void *a1)
{
  void *v1; // ecx@1
  char v2; // bl@1
  __int16 *v3; // eax@2
  __int16 v5; // [sp+4h] [bp-Ch]@2
  int v6; // [sp+8h] [bp-8h]@2

  v2 = sub_100253C0(1, 1948, a1);
  if ( !v2 )
  {
    v6 = sub_100429D0(v1);
    v3 = &v5;
    LOBYTE(v3) = 1;
    v5 = 1948;
    sub_1001D5C0(8, 0, (int)v3, 0, &v5, 0x1000000);
  }
  return v2;
}

//----- (1001C170) --------------------------------------------------------
char __usercall sub_1001C170@<al>(char a1@<bl>)
{
  int v1; // eax@1
  int v2; // edi@1
  char v4; // [sp+7h] [bp-Dh]@8
  int v5; // [sp+8h] [bp-Ch]@2
  int v6; // [sp+Ch] [bp-8h]@3

  v1 = sub_1007C040();
  v2 = v1;
  if ( !byte_10238C61 )
  {
    LOBYTE(v1) = sub_1001C100(&v5);
    if ( (_BYTE)v1 && (LOBYTE(v1) = sub_1001BD30((unsigned int *)&v6), (_BYTE)v1) )
    {
      if ( v5 != v6 )
      {
        sub_10043480(0x24u);
        sub_1003DF00(a1, 0);
        sub_10043370(37);
        LOBYTE(v1) = sub_10043370(33);
      }
      byte_10238C61 = 1;
    }
    else if ( (unsigned int)(v2 - dword_10238EA8) > 0x3E8 )
    {
      dword_10238EA8 = v2;
      LOBYTE(v1) = sub_1003DE70(&v4);
      if ( !(_BYTE)v1 || !v4 )
        LOBYTE(v1) = sub_1003DED0(a1, 17, 0);
    }
  }
  return v1;
}
// 10238C61: using guessed type char byte_10238C61;
// 10238EA8: using guessed type int dword_10238EA8;

//----- (1001C240) --------------------------------------------------------
char sub_1001C240()
{
  unsigned __int8 v0; // bl@1
  char *v1; // esi@1
  unsigned __int8 v2; // di@2
  char result; // al@2
  char v4; // [sp+Fh] [bp-5h]@1
  unsigned int v5; // [sp+10h] [bp-4h]@1

  v0 = 0;
  v4 = 0;
  LOBYTE(v5) = 0;
  v1 = byte_10238EA4;
  do
  {
    v2 = v5;
    result = sub_1001BCC0(v5, &v4);
    if ( result )
    {
      result = *v1;
      if ( *v1 != v4 )
        result = sub_1001C030(v2, (unsigned __int8)*v1);
    }
    ++v0;
    ++v1;
    LOBYTE(v5) = v0;
  }
  while ( v0 < 2u );
  return result;
}

//----- (1001C2A0) --------------------------------------------------------
char __cdecl sub_1001C2A0(char a1)
{
  void *v1; // ecx@0
  char result; // al@1
  void *v3; // ecx@2

  result = sub_100461B0(v1);
  if ( result )
  {
    sub_1001C240();
    sub_1001BD90();
    result = sub_100474F0(v3);
    if ( result )
      result = sub_1001C170(a1);
  }
  return result;
}

//----- (1001C2D0) --------------------------------------------------------
char __usercall sub_1001C2D0@<al>(int a1@<eax>, char a2)
{
  int v2; // esi@1
  char result; // al@3
  char v4; // [sp+Bh] [bp-5h]@1
  unsigned int v5; // [sp+Ch] [bp-4h]@2

  v2 = a1;
  v4 = 0;
  if ( !sub_10045FC0(a1)
    || (LOBYTE(v5) = sub_10046170(v2), sub_1001BD10(v5, a2), !sub_1001BCC0(v5, &v4))
    || (result = 1, a2 != v4) )
  {
    result = 0;
  }
  return result;
}

//----- (1001C330) --------------------------------------------------------
char __cdecl sub_1001C330(int a1)
{
  void *v1; // ecx@0
  char v2; // al@1

  v2 = sub_100460C0(v1);
  return sub_1001C2D0(a1, v2);
}

//----- (1001C350) --------------------------------------------------------
char __cdecl sub_1001C350(int a1)
{
  return sub_1001C2D0(a1, 16);
}

//----- (1001C360) --------------------------------------------------------
char sub_1001C360()
{
  unsigned int v0; // eax@2
  _DWORD *v1; // ecx@2
  char *v2; // edx@2
  int v3; // esi@6
  int v4; // eax@7
  _BYTE *v5; // ecx@7
  _BYTE *v6; // edx@7
  int v7; // eax@9
  _BYTE *v8; // ecx@9
  _BYTE *v9; // edx@9
  _BYTE *v10; // ecx@11
  _BYTE *v11; // edx@11
  signed int v12; // eax@13
  char result; // al@17
  char v14; // [sp+4h] [bp-40h]@1

  if ( !sub_10046920(&v14) )
    goto LABEL_18;
  v0 = 64;
  v1 = &unk_10238EB8;
  v2 = &v14;
  do
  {
    if ( *(_DWORD *)v2 != *v1 )
      goto LABEL_6;
    v0 -= 4;
    ++v1;
    v2 += 4;
  }
  while ( v0 >= 4 );
  if ( !v0 )
  {
LABEL_15:
    v12 = 0;
    goto LABEL_16;
  }
LABEL_6:
  v3 = (unsigned __int8)*v2 - *(_BYTE *)v1;
  if ( (unsigned __int8)*v2 == *(_BYTE *)v1 )
  {
    v4 = v0 - 1;
    v5 = (char *)v1 + 1;
    v6 = v2 + 1;
    if ( !v4 )
      goto LABEL_15;
    v3 = *v6 - *v5;
    if ( *v6 == *v5 )
    {
      v7 = v4 - 1;
      v8 = v5 + 1;
      v9 = v6 + 1;
      if ( !v7 )
        goto LABEL_15;
      v3 = *v9 - *v8;
      if ( *v9 == *v8 )
      {
        v10 = v8 + 1;
        v11 = v9 + 1;
        if ( v7 == 1 )
          goto LABEL_15;
        v3 = *v11 - *v10;
        if ( *v11 == *v10 )
          goto LABEL_15;
      }
    }
  }
  v12 = 1;
  if ( v3 <= 0 )
    v12 = -1;
LABEL_16:
  if ( !v12 )
  {
    sub_10018810(10);
    return 1;
  }
LABEL_18:
  sub_10018720();
  if ( (unsigned int)sub_10018700() <= 0x19 )
  {
    sub_10018810(1);
    result = 0;
  }
  else
  {
    sub_10018810(8);
    result = 0;
  }
  return result;
}

//----- (1001C460) --------------------------------------------------------
char sub_1001C460()
{
  if ( (unsigned int)(sub_1007C040() - dword_10238EB4) > 0x1F4 )
    sub_10018810((unsigned __int8)byte_10238EB0);
  return 1;
}
// 10238EB0: using guessed type char byte_10238EB0;
// 10238EB4: using guessed type int dword_10238EB4;

//----- (1001C490) --------------------------------------------------------
void *sub_1001C490()
{
  byte_10238EB0 = 0;
  memset(&unk_10238EB8, 0, 0x40u);
  dword_10238EB4 = 0;
  return sub_10046970();
}
// 10238EB0: using guessed type char byte_10238EB0;
// 10238EB4: using guessed type int dword_10238EB4;

//----- (1001C4C0) --------------------------------------------------------
char __usercall sub_1001C4C0@<al>(unsigned __int8 a1@<al>)
{
  int v1; // eax@1
  char result; // al@3

  v1 = a1 - 8;
  if ( v1 )
  {
    if ( v1 == 1 )
      result = 1;
    else
      result = 2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001C4E0) --------------------------------------------------------
char __usercall sub_1001C4E0@<al>(unsigned __int8 a1@<bl>, signed int a2)
{
  signed int v2; // ebp@1
  int v4; // [sp+Ch] [bp-24h]@1
  int v5; // [sp+10h] [bp-20h]@1
  int v6; // [sp+14h] [bp-1Ch]@1
  int v7; // [sp+18h] [bp-18h]@1
  int v8; // [sp+1Ch] [bp-14h]@1
  int v9; // [sp+20h] [bp-10h]@1
  int v10; // [sp+24h] [bp-Ch]@1
  int v11; // [sp+28h] [bp-8h]@1
  int v12; // [sp+2Ch] [bp-4h]@1

  v2 = a2;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  a2 = 0;
  if ( a1 >= 2u )
    sub_10042930("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg.c", 877, 1, 0);
  qmemcpy(&unk_10238EB8, (const void *)v2, 0x40u);
  LOBYTE(v4) = 32;
  BYTE1(v12) = 1;
  qmemcpy((char *)&v4 + 1, (const void *)v2, 0x20u);
  a2 = 2234124;
  sub_10046A90(a1, &a2, &v4);
  BYTE1(a2) = 9;
  qmemcpy((char *)&v4 + 1, (const void *)(v2 + 32), 0x20u);
  HIWORD(a2) = 34;
  return sub_10046A90(a1, &a2, &v4);
}

//----- (1001C5B0) --------------------------------------------------------
int __usercall sub_1001C5B0@<eax>(char a1@<bl>, int a2)
{
  char v3; // [sp+Ch] [bp-44h]@1
  char v4; // [sp+10h] [bp-40h]@3
  char v5; // [sp+30h] [bp-20h]@3

  memset(&v3, 0, 0x44u);
  if ( (unsigned __int8)a1 >= 2u )
    sub_10042930("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg.c", 938, 1, 0);
  sub_10046560(a1, (int)&v3);
  qmemcpy(&v4, (const void *)a2, 0x20u);
  qmemcpy(&v5, (const void *)(a2 + 32), 0x20u);
  return sub_10018630(a1, (int)&v3);
}

//----- (1001C630) --------------------------------------------------------
int __usercall sub_1001C630@<eax>(char a1@<bl>, int a2)
{
  int v3; // [sp+0h] [bp-44h]@1

  memset(&v3, 0, 0x44u);
  if ( (unsigned __int8)a1 >= 2u )
    sub_10042930("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg.c", 988, 1, 0);
  sub_10046560(a1, (int)&v3);
  v3 = a2;
  return sub_10018630(a1, (int)&v3);
}

//----- (1001C680) --------------------------------------------------------
char __cdecl sub_1001C680(char a1, int a2, int a3, int a4, char a5, char *a6)
{
  char v6; // al@2
  int v7; // ecx@2
  char result; // al@2

  if ( sub_10043FF0(&a5, 1u, (int)&unk_100A6AB8, 201, 10, 10) == 10 )
  {
    result = 0;
  }
  else
  {
    v6 = sub_1001C4C0(a1);
    strncpy(a6, &byte_100A6AB9[201 * v7] + 100 * (unsigned __int8)v6, 0x64u);
    result = 1;
  }
  return result;
}

//----- (1001C6F0) --------------------------------------------------------
char __cdecl sub_1001C6F0(char a1, char a2, int a3)
{
  unsigned __int8 v3; // al@1
  char result; // al@1
  char v5; // al@7
  char v6; // bl@9
  char v7; // ST0C_1@19
  char v8; // al@19
  int v9; // [sp+8h] [bp-44h]@1
  char v10; // [sp+Ch] [bp-40h]@4
  char v11; // [sp+2Ch] [bp-20h]@12

  v3 = sub_1001C4C0(a1);
  LOBYTE(v9) = v3;
  result = sub_10046B20(v3, a2);
  if ( !result )
    return result;
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    if ( sub_10018710() == 5 )
    {
      sub_100468A0(v9, (int)&v10);
      sub_100469A0(v9, (int)&v10);
    }
    else
    {
      sub_100469A0(v9, (int)&unk_10238EB8);
    }
  }
  if ( a2 == 17 )
  {
    v5 = sub_10046780(v9, &v9);
  }
  else
  {
    if ( sub_10046640() )
    {
      v6 = 0;
      sub_10046650(v9, &v10, 1);
      goto LABEL_10;
    }
    v5 = sub_10046650(v9, &v11, 0);
  }
  v6 = v5;
  if ( !v5 )
  {
LABEL_10:
    sub_10018720();
    if ( (unsigned int)sub_10018700() <= 0x19 )
    {
      sub_10018810(4);
      byte_10238EB0 = 2;
      dword_10238EB4 = sub_1007C040();
      result = v6;
    }
    else
    {
      sub_10046970();
      sub_10018810(8);
      result = v6;
    }
    return result;
  }
  if ( sub_10018710() != 5 || sub_100186F0() != 1 )
  {
    if ( sub_10018710() != 7 || a2 != 17 )
    {
      sub_10018810(3);
      result = v6;
    }
    else
    {
      v7 = sub_100186F0();
      v8 = sub_10018710();
      sub_10018760(v8, a1, v7, 17, a3, &v9, 4u);
      sub_10018810(10);
      result = v6;
    }
  }
  else
  {
    sub_10018810(10);
    result = v6;
  }
  return result;
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10238EB0: using guessed type char byte_10238EB0;
// 10238EB4: using guessed type int dword_10238EB4;

//----- (1001C870) --------------------------------------------------------
char __cdecl sub_1001C870(unsigned __int8 a1, int a2, int a3, int a4, signed int a5, int a6)
{
  char v6; // bl@1
  char result; // al@2
  char v8; // [sp+8h] [bp-40h]@1

  memset(&v8, 0, 0x40u);
  v6 = sub_1001C4C0(a1);
  if ( v6 == 2 )
  {
    sub_10042930("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg.c", 451, 0, 0);
    sub_10046970();
    sub_10018810(8);
    result = 0;
  }
  else
  {
    if ( a6 )
    {
      sub_1001C4E0(v6, a5);
    }
    else
    {
      sub_100468A0(v6, (int)&v8);
      sub_1001C4E0(v6, (signed int)&v8);
    }
    sub_10018810(4);
    byte_10238EB0 = 2;
    dword_10238EB4 = sub_1007C040();
    result = 1;
  }
  return result;
}
// 10238EB0: using guessed type char byte_10238EB0;
// 10238EB4: using guessed type int dword_10238EB4;

//----- (1001C920) --------------------------------------------------------
char __cdecl sub_1001C920(unsigned __int8 a1, int a2, int a3, int a4, signed int a5, int a6)
{
  sub_10046970();
  return sub_1001C870(a1, a2, a3, a4, a5, a6);
}

//----- (1001C930) --------------------------------------------------------
char __cdecl sub_1001C930(char a1, char a2, char a3, int a4, int *a5)
{
  char v5; // bl@1
  char v6; // al@3
  char result; // al@7
  char v8; // [sp+8h] [bp-40h]@8

  v5 = sub_1001C4C0(a1);
  if ( !a2 )
  {
    if ( a3 == 17 )
    {
      sub_1001C630(v5, *a5);
      v6 = 0;
    }
    else
    {
      sub_1001C5B0(v5, (int)&unk_10238EB8);
      v6 = 1;
    }
    if ( !v6 )
    {
LABEL_10:
      sub_10018810(7);
      return 1;
    }
LABEL_6:
    if ( j_HWM_pvg_read_reg(1) != 1 )
    {
      sub_10018760(7, a1, 0, 17, 0, 0, 0);
      sub_10018810(2);
      return 1;
    }
    goto LABEL_10;
  }
  if ( sub_10046920(&v8) )
  {
    sub_1001C5B0(v5, (int)&v8);
    sub_10046970();
    goto LABEL_6;
  }
  sub_10018720();
  if ( (unsigned int)sub_10018700() <= 0x19 )
  {
    sub_10018810(2);
    result = 0;
  }
  else
  {
    sub_10046970();
    sub_10018810(8);
    result = 0;
  }
  return result;
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1001CA20) --------------------------------------------------------
void __cdecl sub_1001CA20(__int16 a1)
{
  int v1; // [sp+0h] [bp-Ch]@2
  unsigned int v2; // [sp+4h] [bp-8h]@5
  char v3; // [sp+8h] [bp-4h]@5

  if ( a1 == 1679 && sub_100253C0(1, 1679, &v1) && !sub_1007C110(98, 500) )
  {
    if ( v1 == 16842752 )
      *((_BYTE *)dword_10332CD8
      + 20 * (43 * ((unsigned __int8)(v2 >> 16) + 10 * (v2 >> 24)) + BYTE1(v2) + 4004)
      + (unsigned __int8)v2) = v3 & 3;
    sub_1007C0F0(98);
  }
}

//----- (1001CAC0) --------------------------------------------------------
char __cdecl sub_1001CAC0(int a1)
{
  int v1; // eax@1
  void *v2; // ecx@2
  int v4; // [sp+0h] [bp-550h]@1
  unsigned int v5; // [sp+4h] [bp-54Ch]@4
  float v6; // [sp+8h] [bp-548h]@4
  char v7; // [sp+Ch] [bp-544h]@9
  int v8; // [sp+20h] [bp-530h]@9
  __int16 v9; // [sp+24h] [bp-52Ch]@9
  int v10; // [sp+28h] [bp-528h]@9
  unsigned int v11; // [sp+2Ch] [bp-524h]@9
  float v12; // [sp+30h] [bp-520h]@9
  int v13; // [sp+34h] [bp-51Ch]@9

  LOBYTE(v1) = sub_100253C0(1, a1, &v4);
  if ( (_BYTE)v1 )
  {
    v1 = sub_1007C110(98, 500);
    if ( !v1 )
    {
      if ( v4 == 16908288 )
      {
        *((float *)dword_10332CD8
        + (unsigned __int8)v5
        + 20 * (BYTE1(v5) + 20 * ((unsigned __int8)(v5 >> 16) + 10 * (v5 >> 24)))) = v6;
      }
      else if ( v4 == 16973824 )
      {
        *((float *)dword_10332CD8 + (unsigned __int8)(v5 >> 16) + 10 * ((v5 >> 24) + 2000)) = v6;
      }
      else if ( sub_100460C0(v2) == 4 && !sub_1004E9A0(196608) )
      {
        sub_10024D10(1, 0x68Eu, (int)&v7);
        v11 = v5;
        v10 = v4;
        v9 = -32702;
        v12 = v6;
        v13 = v8;
        sub_10047790((int)&v9);
      }
      LOBYTE(v1) = sub_1007C0F0(98);
    }
  }
  return v1;
}

//----- (1001CC00) --------------------------------------------------------
char __cdecl sub_1001CC00(__int16 a1)
{
  int v1; // eax@1

  LOBYTE(v1) = a1;
  switch ( a1 )
  {
    case 0x697:
      LOBYTE(v1) = sub_1003DF80(0x100000);
      if ( (_BYTE)v1 )
        byte_10238F13 = 1;
      break;
    case 0x696:
      LOBYTE(v1) = sub_1003DF80(0x10000);
      if ( (_BYTE)v1 )
      {
        byte_10238F12 = 1;
        v1 = sub_1007C040();
        dword_10238EF8 = v1;
        LOBYTE(dword_10238EFC) = 1;
      }
      break;
    case 0x699:
      LOBYTE(v1) = sub_1003DF80(0x200000);
      if ( (_BYTE)v1 )
        byte_10238F10 = 1;
      break;
    case 0x698:
      LOBYTE(v1) = sub_1003DF80(0x20000);
      if ( (_BYTE)v1 )
      {
        byte_10238F0B = 1;
        v1 = sub_1007C040();
        dword_10238F00 = v1;
        LOBYTE(dword_10238F04) = 1;
      }
      break;
    default:
      return v1;
  }
  return v1;
}
// 10238EF8: using guessed type int dword_10238EF8;
// 10238EFC: using guessed type int dword_10238EFC;
// 10238F00: using guessed type int dword_10238F00;
// 10238F04: using guessed type int dword_10238F04;
// 10238F0B: using guessed type char byte_10238F0B;
// 10238F10: using guessed type char byte_10238F10;
// 10238F12: using guessed type char byte_10238F12;
// 10238F13: using guessed type char byte_10238F13;

//----- (1001CCB0) --------------------------------------------------------
char __usercall sub_1001CCB0@<al>(char result@<al>, char a2)
{
  switch ( result )
  {
    case 0:
      if ( a2 & 0x3C )
      {
        LOBYTE(dword_10238F0C) = 1;
        result = sub_10043480(0x69u);
      }
      else
      {
        LOBYTE(dword_10238F0C) = 0;
        if ( !BYTE2(dword_10238F0C) )
          result = sub_10043370(105);
      }
      break;
    case 2:
      if ( a2 & 6 )
      {
        BYTE2(dword_10238F0C) = 1;
        result = sub_10043480(0x69u);
      }
      else
      {
        BYTE2(dword_10238F0C) = 0;
        if ( !(_BYTE)dword_10238F0C )
          result = sub_10043370(105);
      }
      break;
    case 1:
      if ( a2 & 0x3C )
      {
        BYTE1(dword_10238F0C) = 1;
        result = sub_10043480(0x6Au);
      }
      else
      {
        BYTE1(dword_10238F0C) = 0;
        if ( !BYTE3(dword_10238F0C) )
          result = sub_10043370(106);
      }
      break;
    case 3:
      if ( a2 & 6 )
      {
        BYTE3(dword_10238F0C) = 1;
        result = sub_10043480(0x6Au);
      }
      else
      {
        BYTE3(dword_10238F0C) = 0;
        if ( !BYTE1(dword_10238F0C) )
          result = sub_10043370(106);
      }
      break;
    default:
      result = sub_10042930("..\\lib\\acl\\iop\\gma\\iop_gma_dig.c", 936, 1, 0);
      break;
  }
  return result;
}
// 10238F0C: using guessed type int dword_10238F0C;

//----- (1001CE30) --------------------------------------------------------
int __cdecl sub_1001CE30(char a1, char a2)
{
  int result; // eax@1
  void *v3; // ecx@1
  int v4; // eax@2
  void *v5; // ecx@2
  int v6; // eax@3
  bool v7; // al@5

  result = sub_1007C110(98, 500);
  if ( !result )
  {
    v4 = sub_100429D0(v3) - 2;
    v7 = 1;
    if ( v4 )
    {
      v6 = v4 - 30;
      if ( v6 )
      {
        if ( v6 != 96 )
          v7 = 0;
      }
    }
    if ( v7 == a1 )
    {
      if ( a2 )
      {
        memset((char *)dword_10332CD8 + 80080, 0, 0x8660u);
        memset((char *)dword_10332CD8 + 114528, 0, 0x320u);
        *((_BYTE *)dword_10332CD8 + 115328) = 0;
        memset(dword_10332CD8, 0, 0x13880u);
      }
      sub_1003E830(v5);
    }
    result = sub_1007C0F0(98);
  }
  return result;
}

//----- (1001CED0) --------------------------------------------------------
char __usercall sub_1001CED0@<al>(int a1@<eax>, void *a2@<ecx>, __int16 a3@<bx>)
{
  int v3; // edi@1
  _DWORD *v4; // eax@1
  unsigned int v5; // esi@2

  v3 = a1;
  LOBYTE(v4) = sub_100460C0(a2);
  if ( (_BYTE)v4 == 2 )
  {
    v5 = 0;
    v4 = &unk_100A781C;
    while ( *((_WORD *)v4 - 2) != a3 || *v4 != *(_DWORD *)v3 )
    {
      ++v5;
      v4 += 4;
      if ( v5 >= 0x16 )
        return (unsigned int)v4;
    }
    v4 = (_DWORD *)sub_1007C110(98, 500);
    if ( !v4 )
    {
      memcpy((char *)dword_10332CD8 + dword_100A7820[4 * v5], (const void *)(v3 + 8), dword_100A7824[4 * v5]);
      LOBYTE(v4) = sub_1007C0F0(98);
    }
  }
  return (unsigned int)v4;
}
// 100A7820: using guessed type int dword_100A7820[];
// 100A7824: using guessed type int dword_100A7824[];

//----- (1001CF40) --------------------------------------------------------
void sub_1001CF40()
{
  unsigned int v0; // edx@1
  char *v1; // eax@1
  int *v2; // ecx@1
  int v3; // esi@5
  int v4; // edx@6
  _BYTE *v5; // eax@6
  _BYTE *v6; // ecx@6
  int v7; // edx@8
  _BYTE *v8; // eax@8
  _BYTE *v9; // ecx@8
  _BYTE *v10; // eax@10
  _BYTE *v11; // ecx@10
  signed int v12; // eax@12

  byte_10238F14 = *((_BYTE *)dword_10332CD8 + 89561);
  unk_10238F15 = *((_BYTE *)dword_10332CD8 + 89562);
  byte_10238F16 = *((_BYTE *)dword_10332CD8 + 90421);
  byte_10238F17 = *((_BYTE *)dword_10332CD8 + 90422);
  v0 = 4;
  v1 = &byte_10238F14;
  v2 = &dword_10238F18;
  do
  {
    if ( *v2 != *(_DWORD *)v1 )
      goto LABEL_5;
    v0 -= 4;
    v1 += 4;
    ++v2;
  }
  while ( v0 >= 4 );
  if ( !v0 )
  {
LABEL_14:
    v12 = 0;
    goto LABEL_15;
  }
LABEL_5:
  v3 = *(_BYTE *)v2 - (unsigned __int8)*v1;
  if ( *(_BYTE *)v2 == (unsigned __int8)*v1 )
  {
    v4 = v0 - 1;
    v5 = v1 + 1;
    v6 = (char *)v2 + 1;
    if ( !v4 )
      goto LABEL_14;
    v3 = *v6 - *v5;
    if ( *v6 == *v5 )
    {
      v7 = v4 - 1;
      v8 = v5 + 1;
      v9 = v6 + 1;
      if ( !v7 )
        goto LABEL_14;
      v3 = *v9 - *v8;
      if ( *v9 == *v8 )
      {
        v10 = v8 + 1;
        v11 = v9 + 1;
        if ( v7 == 1 )
          goto LABEL_14;
        v3 = *v11 - *v10;
        if ( *v11 == *v10 )
          goto LABEL_14;
      }
    }
  }
  v12 = 1;
  if ( v3 <= 0 )
    v12 = -1;
LABEL_15:
  if ( v12 )
    sub_10025570(1);
  dword_10238F18 = *(_DWORD *)&byte_10238F14;
  if ( dword_10238EF8 && sub_1007C040() > (unsigned int)(dword_10238EF8 + 1000) )
  {
    sub_1001CE30(0, dword_10238EFC);
    dword_10238EF8 = 0;
  }
  if ( dword_10238F00 && sub_1007C040() > (unsigned int)(dword_10238F00 + 1000) )
  {
    sub_1001CE30(1, dword_10238F04);
    dword_10238F00 = 0;
  }
  if ( byte_10238F0A )
    goto LABEL_31;
  if ( sub_1004E9E0() )
  {
    sub_1003E420();
    byte_10238F0A = 1;
    return;
  }
  if ( byte_10238F0A )
  {
LABEL_31:
    if ( !sub_1004E9E0() )
      byte_10238F0A = 0;
  }
}
// 10238EF8: using guessed type int dword_10238EF8;
// 10238EFC: using guessed type int dword_10238EFC;
// 10238F00: using guessed type int dword_10238F00;
// 10238F04: using guessed type int dword_10238F04;
// 10238F0A: using guessed type char byte_10238F0A;
// 10238F14: using guessed type char byte_10238F14;
// 10238F16: using guessed type char byte_10238F16;
// 10238F17: using guessed type char byte_10238F17;
// 10238F18: using guessed type int dword_10238F18;

//----- (1001D0D0) --------------------------------------------------------
char __cdecl sub_1001D0D0(int a1, int a2)
{
  void *v2; // ecx@0
  char result; // al@1
  void *v4; // ecx@2
  void *v5; // ecx@5
  void *v6; // ecx@14
  void *v7; // ecx@17
  void *v8; // ecx@26
  char v9; // [sp+8h] [bp-764h]@26
  int v10; // [sp+Ch] [bp-760h]@10
  char v11; // [sp+1Ch] [bp-750h]@2
  int v12; // [sp+20h] [bp-74Ch]@9
  int v13; // [sp+2Ch] [bp-740h]@9
  char v14; // [sp+38h] [bp-734h]@26

  sub_100460A0(v2);
  result = a1;
  switch ( (unsigned __int16)a1 )
  {
    case 0x696u:
      result = sub_10023DA0(a1, a2, &v11);
      if ( result )
      {
        if ( byte_10238F12 == 1 )
        {
          sub_1001DF80(0);
          dword_10238EF8 = sub_1007C040();
          LOBYTE(dword_10238EFC) = 0;
          byte_10238F12 = 0;
        }
        if ( sub_100460C0(v4) == 4 && !byte_10238F08 )
        {
          if ( v11 )
          {
            byte_10238F08 = 1;
            sub_1003E830(v5);
          }
        }
        sub_1001CCB0(0, v12);
        result = sub_1003E660(v13);
      }
      break;
    case 0x697u:
      result = sub_10023DA0(a1, a2, &v10);
      if ( result )
      {
        if ( byte_10238F13 == 1 )
        {
          sub_1001DF80(2);
          byte_10238F13 = 0;
        }
        result = sub_1001CCB0(2, v10);
      }
      break;
    case 0x698u:
      result = sub_10023DA0(a1, a2, &v11);
      if ( result )
      {
        if ( byte_10238F0B == 1 )
        {
          sub_1001DF80(1);
          dword_10238F00 = sub_1007C040();
          LOBYTE(dword_10238F04) = 0;
          byte_10238F0B = 0;
        }
        if ( sub_100460C0(v6) == 4 && !byte_10238F09 && v11 )
        {
          byte_10238F09 = 1;
          sub_1003E830(v7);
        }
        sub_1001CCB0(1, v12);
        result = sub_1003E660(v13);
      }
      break;
    case 0x699u:
      result = sub_10023DA0(a1, a2, &v10);
      if ( result )
      {
        if ( byte_10238F10 == 1 )
        {
          sub_1001DF80(3);
          byte_10238F10 = 0;
        }
        result = sub_1001CCB0(3, v10);
      }
      break;
    case 0x69Eu:
    case 0x69Fu:
      result = sub_10023DC0(a1, a2, &v14, (unsigned __int16 *)&v9);
      if ( result )
        result = sub_1001CED0((int)&v14, v8, a1);
      break;
    default:
      return result;
  }
  return result;
}
// 10238EF8: using guessed type int dword_10238EF8;
// 10238EFC: using guessed type int dword_10238EFC;
// 10238F00: using guessed type int dword_10238F00;
// 10238F04: using guessed type int dword_10238F04;
// 10238F08: using guessed type char byte_10238F08;
// 10238F09: using guessed type char byte_10238F09;
// 10238F0B: using guessed type char byte_10238F0B;
// 10238F10: using guessed type char byte_10238F10;
// 10238F12: using guessed type char byte_10238F12;
// 10238F13: using guessed type char byte_10238F13;

//----- (1001D350) --------------------------------------------------------
signed int sub_1001D350()
{
  byte_10238F13 = 1;
  byte_10238F12 = 1;
  byte_10238F10 = 1;
  byte_10238F0B = 1;
  dword_10332CD8 = (void *)-15;
  dword_10238EF8 = 0;
  dword_10238EFC = 0;
  dword_10238F00 = 0;
  dword_10238F04 = 0;
  byte_10238F08 = 0;
  byte_10238F09 = 0;
  byte_10238F11 = 0;
  byte_10238F0A = 0;
  dword_10238F0C = 0;
  sub_1001DE20();
  sub_1007C110(98, 500);
  if ( !sub_1007CD60((LONG)&off_100A7800) )
    sub_10042930("..\\lib\\acl\\iop\\gma\\iop_gma_dig.c", 1015, 1, 0);
  memset(dword_10332CD8, 0, 0x1C384u);
  sub_1007C0F0(98);
  return sub_1007C8F0((int)&off_100A7800);
}
// 100A7800: using guessed type char *off_100A7800;
// 10238EF8: using guessed type int dword_10238EF8;
// 10238EFC: using guessed type int dword_10238EFC;
// 10238F00: using guessed type int dword_10238F00;
// 10238F04: using guessed type int dword_10238F04;
// 10238F08: using guessed type char byte_10238F08;
// 10238F09: using guessed type char byte_10238F09;
// 10238F0A: using guessed type char byte_10238F0A;
// 10238F0B: using guessed type char byte_10238F0B;
// 10238F0C: using guessed type int dword_10238F0C;
// 10238F10: using guessed type char byte_10238F10;
// 10238F11: using guessed type char byte_10238F11;
// 10238F12: using guessed type char byte_10238F12;
// 10238F13: using guessed type char byte_10238F13;

//----- (1001D3B0) --------------------------------------------------------
char __cdecl sub_1001D3B0(char a1, _BYTE *a2)
{
  int v2; // ecx@0
  char result; // al@1
  int v4; // [sp-2h] [bp-4h]@1

  v4 = v2;
  result = 0;
  BYTE3(v4) = 0;
  switch ( a1 )
  {
    case 0:
      result = sub_100253C0(1, 1714, (char *)&v4 + 3);
      goto LABEL_6;
    case 1:
      result = sub_100253C0(1, 1715, (char *)&v4 + 3);
      goto LABEL_6;
    case 2:
      result = sub_100253C0(1, 1716, (char *)&v4 + 3);
      goto LABEL_6;
    case 3:
      result = sub_100253C0(1, 1717, (char *)&v4 + 3);
LABEL_6:
      if ( result != 1 )
        goto LABEL_8;
      *a2 = BYTE3(v4);
      break;
    default:
LABEL_8:
      *a2 = 0;
      break;
  }
  return result;
}

//----- (1001D430) --------------------------------------------------------
char sub_1001D430()
{
  return byte_10238F22;
}
// 10238F22: using guessed type char byte_10238F22;

//----- (1001D440) --------------------------------------------------------
char sub_1001D440()
{
  if ( (unsigned int)(sub_1007C040() - dword_1023E04C) > 0x1388 )
    sub_10018810((unsigned __int8)byte_10238F21);
  return 1;
}
// 10238F21: using guessed type char byte_10238F21;
// 1023E04C: using guessed type int dword_1023E04C;

//----- (1001D470) --------------------------------------------------------
char __cdecl sub_1001D470(char a1)
{
  char result; // al@1

  result = a1;
  if ( a1 == 4 )
    result = 1;
  byte_10238F22 = result;
  return result;
}
// 10238F22: using guessed type char byte_10238F22;

//----- (1001D480) --------------------------------------------------------
signed int __usercall sub_1001D480@<eax>(char a1@<al>)
{
  return a1 != 36 ? 0x20000 : 0x10000;
}

//----- (1001D4A0) --------------------------------------------------------
bool __cdecl sub_1001D4A0(char a1)
{
  return a1 != 36;
}

//----- (1001D4B0) --------------------------------------------------------
char __cdecl sub_1001D4B0(char a1, char a2)
{
  int v2; // esi@1
  void *v3; // ecx@1
  __int64 v5; // [sp+4h] [bp-Ch]@1

  v2 = sub_1001D480(a1);
  HIDWORD(v5) = sub_100429D0(v3);
  LODWORD(v5) = (unsigned __int16)((a2 != 11) + 1708);
  sub_10024E60(1, 0, &v5, 0, 8, 1);
  sub_10025010(1, 0, v2);
  return 1;
}

//----- (1001D530) --------------------------------------------------------
char __usercall sub_1001D530@<al>(void *a1@<esi>, int a2)
{
  int v2; // eax@1

  sub_10024E60(1, 1708, a1, 1, 10384, 1);
  sub_10025010(1, 1708, a2);
  memcpy(&unk_1023B7B8, a1, 0x2890u);
  v2 = j_HWM_pvg_read_reg(1);
  if ( !v2 )
    LOBYTE(v2) = sub_10022340(1708, (int)&byte_10332F00);
  return v2;
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10332F00: using guessed type char byte_10332F00;

//----- (1001D590) --------------------------------------------------------
char __usercall sub_1001D590@<al>(void *a1@<esi>, char a2)
{
  sub_10024E60(1, 1708, a1, 1, 10384, 1);
  return sub_10018680((a2 != 36) + 6534, (int)a1);
}

//----- (1001D5C0) --------------------------------------------------------
char __usercall sub_1001D5C0@<al>(int a1@<ecx>, char a2@<dl>, int a3@<eax>, int a4@<esi>, void *a5, int a6)
{
  sub_10024E60(1, a4, a5, a2, a1, a3);
  return sub_10025010(1, a4, a6);
}

//----- (1001D5F0) --------------------------------------------------------
char __cdecl sub_1001D5F0(char a1)
{
  char v1; // bl@1
  char result; // al@2

  v1 = sub_1001D4B0(a1, 11);
  if ( sub_10018710() == 5 )
  {
    sub_10018810(4);
    byte_10238F21 = 10;
    dword_1023E04C = sub_1007C040();
    result = v1;
  }
  else
  {
    sub_10018810(0);
    result = v1;
  }
  return result;
}
// 10238F21: using guessed type char byte_10238F21;
// 1023E04C: using guessed type int dword_1023E04C;

//----- (1001D640) --------------------------------------------------------
char __cdecl sub_1001D640(char a1, int a2, char a3, int a4, char *a5)
{
  bool v5; // bl@1
  unsigned int v6; // ecx@11
  signed int v7; // esi@11
  char *v8; // edx@11
  char v9; // cl@14
  unsigned int v10; // eax@14
  int v11; // eax@18
  char result; // al@18

  v5 = 0;
  switch ( a3 )
  {
    case 0xB:
      v5 = sub_1004EA10(a1, &unk_10238F28);
      goto LABEL_17;
    case 0x22:
      v5 = sub_1004EA10(a1, &unk_10238F28);
      *(&byte_10239174[48 * *(_BYTE *)a4] + *(_BYTE *)(a4 + 1)) = *a5;
      goto LABEL_17;
    case 0x23:
      v5 = sub_1004EA10(a1, &unk_10238F28);
      *(&byte_1023A374[48 * *(_BYTE *)a4] + *(_BYTE *)(a4 + 1)) = *a5;
      goto LABEL_17;
    case 0x24:
      v5 = sub_1004EA10(a1, &unk_10238F28);
      byte_1023B574[*(_BYTE *)a4] = *a5;
      goto LABEL_17;
    case 0x25:
      v5 = sub_1004EA10(a1, &unk_10238F28);
      word_1023B5D4[*(_BYTE *)a4] = *(_WORD *)a5;
      goto LABEL_17;
    case 0x26:
      v5 = sub_1004EA10(a1, &unk_10238F28);
      byte_10238F2C = *a5;
      goto LABEL_17;
    case 0x27:
      v5 = sub_1004EA10(a1, &unk_10238F28);
      byte_10238F2D = *a5;
      goto LABEL_17;
    case 0x28:
      v5 = sub_1004EA10(a1, &unk_10238F28);
      word_10238F2E = *(_WORD *)a5;
      goto LABEL_17;
    case 0x29:
      v5 = sub_1004EA10(a1, &unk_10238F28);
      byte_10238F30[*(_BYTE *)a4] = *a5;
      goto LABEL_17;
    case 0x2A:
      v5 = sub_1004EA10(a1, &unk_10238F28);
      v6 = *(_BYTE *)(a4 + 2);
      v7 = 1 << (v6 & 0x1F);
      v8 = (char *)&unk_1023B6B4 + 4 * (v6 >> 5);
      if ( *(_BYTE *)a4 == 1 )
        *(_DWORD *)v8 |= v7;
      else
        *(_DWORD *)v8 &= ~v7;
      v9 = *(_BYTE *)(a4 + 2);
      v10 = *(_BYTE *)(a4 + 2);
      if ( *(_BYTE *)(a4 + 1) == 1 )
        dword_1023B694[v10 >> 5] |= 1 << (v9 & 0x1F);
      else
        dword_1023B694[v10 >> 5] &= ~(1 << (v9 & 0x1F));
LABEL_17:
      if ( v5 != 1 )
        goto LABEL_19;
      v11 = sub_1001D480(a1);
      sub_1001D530(&unk_10238F28, v11);
      sub_10018810(4);
      byte_10238F21 = 3;
      dword_1023E04C = sub_1007C040();
      result = 1;
      break;
    default:
LABEL_19:
      sub_10018810(8);
      result = v5;
      break;
  }
  return result;
}
// 10238F21: using guessed type char byte_10238F21;
// 10238F2C: using guessed type char byte_10238F2C;
// 10238F2D: using guessed type char byte_10238F2D;
// 10238F2E: using guessed type __int16 word_10238F2E;
// 1023B5D4: using guessed type __int16 word_1023B5D4[];
// 1023E04C: using guessed type int dword_1023E04C;

//----- (1001D8F0) --------------------------------------------------------
char __cdecl sub_1001D8F0(char a1, int a2, int a3, int a4, char a5, int a6)
{
  bool v6; // al@2
  int v7; // ecx@2
  char result; // al@2

  if ( sub_10043FF0(&a5, 1u, (int)&unk_100A7EC8, 201, 10, 10) == 10 )
  {
    result = 0;
  }
  else
  {
    v6 = sub_1001D4A0(a1);
    sub_100421E0(a6, &byte_100A7EC9[201 * v7] + 100 * v6, 100);
    result = 1;
  }
  return result;
}

//----- (1001D950) --------------------------------------------------------
char __cdecl sub_1001D950(char a1, char a2)
{
  char result; // al@2
  bool v3; // bl@3

  if ( a2 )
  {
    v3 = sub_1004EB50(a1, &unk_10238F28);
    if ( v3 )
      sub_1001D590(&unk_10238F28, a1);
    if ( v3 == 1 )
    {
      sub_10018810(7);
      result = 1;
    }
    else
    {
      sub_10018810(8);
      result = v3;
    }
  }
  else
  {
    sub_1001D590(&unk_1023B7B8, a1);
    sub_10018810(7);
    result = 1;
  }
  return result;
}

//----- (1001D9D0) --------------------------------------------------------
char __cdecl sub_1001D9D0(char a1, char a2, int a3)
{
  bool v3; // bl@3
  char result; // al@7
  unsigned int v5; // eax@9
  _DWORD *v6; // ecx@9
  _DWORD *v7; // edx@9
  int v8; // esi@13
  int v9; // eax@14
  _BYTE *v10; // ecx@14
  _BYTE *v11; // edx@14
  int v12; // eax@16
  _BYTE *v13; // ecx@16
  _BYTE *v14; // edx@16
  _BYTE *v15; // ecx@18
  _BYTE *v16; // edx@18
  signed int v17; // eax@20
  bool v18; // zf@23
  int v19; // ecx@29
  int v20; // eax@29
  int v21; // ecx@29
  bool v22; // zf@30
  int v23; // eax@30
  signed int v24; // ecx@32
  int v25; // eax@37
  int v26; // edx@37
  int v27; // ecx@39
  int v28; // eax@41
  char *v29; // ecx@41
  __int16 *v30; // edx@41
  bool v31; // zf@44
  int v32; // ecx@44
  bool v33; // zf@46
  bool v34; // sf@46
  int v35; // eax@55
  unsigned int v36; // eax@57
  _DWORD *v37; // ecx@57
  _DWORD *v38; // edx@57
  int v39; // esi@61
  int v40; // eax@62
  _BYTE *v41; // ecx@62
  _BYTE *v42; // edx@62
  int v43; // eax@64
  _BYTE *v44; // ecx@64
  _BYTE *v45; // edx@64
  _BYTE *v46; // ecx@66
  _BYTE *v47; // edx@66
  signed int v48; // eax@68
  unsigned int v49; // eax@72
  _DWORD *v50; // ecx@72
  _DWORD *v51; // edx@72
  int v52; // esi@76
  int v53; // eax@77
  _BYTE *v54; // ecx@77
  _BYTE *v55; // edx@77
  int v56; // eax@79
  _BYTE *v57; // ecx@79
  _BYTE *v58; // edx@79
  _BYTE *v59; // ecx@81
  _BYTE *v60; // edx@81

  if ( j_HWM_pvg_read_reg(1) == 1 )
    sub_1001D590(&unk_1023B7B8, a1);
  v3 = sub_1004EB50(a1, &unk_10238F28);
  if ( !v3 )
  {
    sub_10018720();
    if ( (unsigned int)sub_10018700() <= 0x18 )
    {
      sub_10018810(4);
      byte_10238F21 = 3;
      dword_1023E04C = sub_1007C040();
      return 0;
    }
    sub_10018810(8);
  }
  switch ( a2 )
  {
    case 0xB:
      if ( !v3 )
        goto LABEL_26;
      v5 = 10384;
      v6 = &unk_1023B7B8;
      v7 = &unk_10238F28;
      do
      {
        if ( *v7 != *v6 )
          goto LABEL_13;
        v5 -= 4;
        ++v6;
        ++v7;
      }
      while ( v5 >= 4 );
      if ( !v5 )
        goto LABEL_22;
LABEL_13:
      v8 = *(_BYTE *)v7 - *(_BYTE *)v6;
      if ( *(_BYTE *)v7 == *(_BYTE *)v6 )
      {
        v9 = v5 - 1;
        v10 = (char *)v6 + 1;
        v11 = (char *)v7 + 1;
        if ( !v9 )
          goto LABEL_22;
        v8 = *v11 - *v10;
        if ( *v11 == *v10 )
        {
          v12 = v9 - 1;
          v13 = v10 + 1;
          v14 = v11 + 1;
          if ( !v12 )
            goto LABEL_22;
          v8 = *v14 - *v13;
          if ( *v14 == *v13 )
          {
            v15 = v13 + 1;
            v16 = v14 + 1;
            if ( v12 == 1 )
              goto LABEL_22;
            v8 = *v16 - *v15;
            if ( *v16 == *v15 )
              goto LABEL_22;
          }
        }
      }
      v17 = 1;
      if ( v8 <= 0 )
        v17 = -1;
      goto LABEL_23;
    default:
      goto LABEL_26;
    case 0x22:
      if ( !v3 )
        goto LABEL_26;
      v19 = 48 * *(_BYTE *)a3 + *(_BYTE *)(a3 + 1);
      v20 = (unsigned __int8)byte_10239174[v19];
      v21 = (unsigned __int8)byte_1023BA04[v19];
      goto LABEL_30;
    case 0x23:
      if ( !v3 )
        goto LABEL_26;
      v25 = *(_BYTE *)(a3 + 1);
      v26 = 48 * *(_BYTE *)a3;
      v21 = (unsigned __int8)*(&byte_1023CC04[v25] + v26);
      v20 = (unsigned __int8)*(&byte_1023A374[v26] + v25);
      goto LABEL_30;
    case 0x24:
      if ( !v3 )
        goto LABEL_26;
      v27 = *(_BYTE *)a3;
      v20 = (unsigned __int8)byte_1023B574[v27];
      v21 = (unsigned __int8)byte_1023DE04[v27];
      goto LABEL_30;
    case 0x25:
      if ( !v3 )
        goto LABEL_26;
      v28 = 2 * *(_BYTE *)a3;
      v29 = &byte_1023DE64[v28];
      v30 = (__int16 *)&word_1023B5D4[v28];
      v23 = word_1023B5D4[v28] - (unsigned __int8)byte_1023DE64[v28];
      if ( v23 )
        goto LABEL_32;
      v20 = *((_BYTE *)v30 + 1);
      v21 = (unsigned __int8)v29[1];
      goto LABEL_30;
    case 0x26:
      if ( !v3 )
        goto LABEL_26;
      v32 = (unsigned __int8)byte_10238F2C - (unsigned __int8)byte_1023B7BC;
      v31 = (unsigned __int8)byte_10238F2C == (unsigned __int8)byte_1023B7BC;
      goto LABEL_45;
    case 0x27:
      if ( !v3 )
        goto LABEL_26;
      v32 = (unsigned __int8)byte_10238F2D - (unsigned __int8)byte_1023B7BD;
      v31 = (unsigned __int8)byte_10238F2D == (unsigned __int8)byte_1023B7BD;
LABEL_45:
      if ( v31 )
        goto LABEL_22;
      v33 = v32 == 0;
      v34 = v32 < 0;
      goto LABEL_47;
    case 0x28:
      if ( !v3 )
        goto LABEL_26;
      v23 = (unsigned __int8)word_10238F2E - (unsigned __int8)byte_1023B7BE;
      if ( (unsigned __int8)word_10238F2E != (unsigned __int8)byte_1023B7BE )
        goto LABEL_32;
      v23 = HIBYTE(word_10238F2E) - (unsigned __int8)byte_1023B7BF;
      v22 = HIBYTE(word_10238F2E) == (unsigned __int8)byte_1023B7BF;
      goto LABEL_31;
    case 0x29:
      if ( !v3 )
        goto LABEL_26;
      v35 = *(_BYTE *)a3;
      v21 = (unsigned __int8)byte_1023B7C0[v35];
      v20 = (unsigned __int8)byte_10238F30[v35];
LABEL_30:
      v23 = v20 - v21;
      v22 = v23 == 0;
LABEL_31:
      if ( v22 )
      {
        v24 = 0;
      }
      else
      {
LABEL_32:
        v24 = 1;
        if ( v23 <= 0 )
        {
          v18 = 0;
          goto LABEL_24;
        }
      }
      v18 = v24 == 0;
      goto LABEL_24;
    case 0x2A:
      if ( !v3 )
        goto LABEL_26;
      v36 = 32;
      v37 = &unk_1023DF44;
      v38 = &unk_1023B6B4;
      break;
  }
  do
  {
    if ( *v38 != *v37 )
      goto LABEL_61;
    v36 -= 4;
    ++v37;
    ++v38;
  }
  while ( v36 >= 4 );
  if ( !v36 )
  {
LABEL_70:
    v48 = 0;
    goto LABEL_71;
  }
LABEL_61:
  v39 = *(_BYTE *)v38 - *(_BYTE *)v37;
  if ( *(_BYTE *)v38 == *(_BYTE *)v37 )
  {
    v40 = v36 - 1;
    v41 = (char *)v37 + 1;
    v42 = (char *)v38 + 1;
    if ( !v40 )
      goto LABEL_70;
    v39 = *v42 - *v41;
    if ( *v42 == *v41 )
    {
      v43 = v40 - 1;
      v44 = v41 + 1;
      v45 = v42 + 1;
      if ( !v43 )
        goto LABEL_70;
      v39 = *v45 - *v44;
      if ( *v45 == *v44 )
      {
        v46 = v44 + 1;
        v47 = v45 + 1;
        if ( v43 == 1 )
          goto LABEL_70;
        v39 = *v47 - *v46;
        if ( *v47 == *v46 )
          goto LABEL_70;
      }
    }
  }
  v48 = 1;
  if ( v39 <= 0 )
    v48 = -1;
LABEL_71:
  if ( v48 )
    goto LABEL_26;
  v49 = 32;
  v50 = &unk_1023DF24;
  v51 = dword_1023B694;
  do
  {
    if ( *v51 != *v50 )
      goto LABEL_76;
    v49 -= 4;
    ++v50;
    ++v51;
  }
  while ( v49 >= 4 );
  if ( !v49 )
  {
LABEL_22:
    v17 = 0;
    goto LABEL_23;
  }
LABEL_76:
  v52 = *(_BYTE *)v51 - *(_BYTE *)v50;
  if ( *(_BYTE *)v51 == *(_BYTE *)v50 )
  {
    v53 = v49 - 1;
    v54 = (char *)v50 + 1;
    v55 = (char *)v51 + 1;
    if ( !v53 )
      goto LABEL_22;
    v52 = *v55 - *v54;
    if ( *v55 == *v54 )
    {
      v56 = v53 - 1;
      v57 = v54 + 1;
      v58 = v55 + 1;
      if ( !v56 )
        goto LABEL_22;
      v52 = *v58 - *v57;
      if ( *v58 == *v57 )
      {
        v59 = v57 + 1;
        v60 = v58 + 1;
        if ( v56 == 1 )
          goto LABEL_22;
        v52 = *v60 - *v59;
        if ( *v60 == *v59 )
          goto LABEL_22;
      }
    }
  }
  v33 = v52 == 0;
  v34 = v52 < 0;
LABEL_47:
  v17 = 1;
  if ( v34 || v33 )
    v17 = -1;
LABEL_23:
  v18 = v17 == 0;
LABEL_24:
  if ( v18 )
  {
    sub_10018810(10);
    return 1;
  }
LABEL_26:
  sub_10018720();
  if ( (unsigned int)sub_10018700() <= 0x18 )
  {
    sub_10018810(1);
    result = 0;
  }
  else
  {
    sub_10018810(8);
    result = 0;
  }
  return result;
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10238F21: using guessed type char byte_10238F21;
// 10238F2C: using guessed type char byte_10238F2C;
// 10238F2D: using guessed type char byte_10238F2D;
// 10238F2E: using guessed type __int16 word_10238F2E;
// 1023B7BC: using guessed type char byte_1023B7BC;
// 1023B7BD: using guessed type char byte_1023B7BD;
// 1023B7BE: using guessed type char byte_1023B7BE;
// 1023B7BF: using guessed type char byte_1023B7BF;
// 1023E04C: using guessed type int dword_1023E04C;

//----- (1001DE20) --------------------------------------------------------
char sub_1001DE20()
{
  void *v0; // ecx@1
  char v1; // al@1

  byte_10238F20 = 0;
  dword_1023E050 = sub_1007C040();
  dword_1023E048 = 0;
  v1 = sub_100460C0(v0);
  return sub_1001D470(v1);
}
// 10238F20: using guessed type char byte_10238F20;
// 1023E048: using guessed type int dword_1023E048;
// 1023E050: using guessed type int dword_1023E050;

//----- (1001DE50) --------------------------------------------------------
char __cdecl sub_1001DE50(unsigned __int8 a1, signed int a2)
{
  void *v2; // ecx@0
  int v3; // eax@1
  void *v4; // ecx@6
  int v5; // esi@9
  signed int *v6; // eax@11
  int v8; // [sp-8h] [bp-8h]@9

  LOBYTE(v3) = a2;
  switch ( (unsigned __int8)a2 )
  {
    case 1u:
      a2 = 2;
      goto LABEL_6;
    case 2u:
      a2 = 3;
      goto LABEL_6;
    case 8u:
      a2 = 4;
      goto LABEL_6;
    case 0x10u:
      a2 = 5;
LABEL_6:
      if ( sub_100429D0(v2) == 1 || (LOBYTE(v3) = sub_100460A0(v4), !(v3 & 1)) )
      {
        v3 = a1;
        switch ( a1 )
        {
          case 0u:
            v8 = 0x10000;
            v5 = 1690;
            goto LABEL_13;
          case 1u:
            LOBYTE(v3) = 1;
            LOBYTE(v3) = sub_1001D5C0(4, 0, v3, 1692, &a2, 0x20000);
            break;
          case 2u:
            v6 = &a2;
            LOBYTE(v6) = 1;
            LOBYTE(v3) = sub_1001D5C0(4, 0, (int)v6, 1691, &a2, 0x100000);
            break;
          case 3u:
            v8 = 0x200000;
            v5 = 1693;
LABEL_13:
            LOBYTE(v3) = 1;
            LOBYTE(v3) = sub_1001D5C0(4, 0, v3, v5, &a2, v8);
            break;
          default:
            return v3;
        }
      }
      break;
    default:
      return v3;
  }
  return v3;
}

//----- (1001DF80) --------------------------------------------------------
char __cdecl sub_1001DF80(char a1)
{
  bool v1; // zf@1
  signed int v2; // eax@1
  char v3; // cl@2
  char v5; // [sp+7h] [bp-1h]@1

  v5 = 0;
  v1 = sub_1001D3B0(a1, &v5) == 1;
  LOBYTE(v2) = byte_10238F22;
  if ( v1 )
    v3 = v5;
  else
    v3 = byte_10238F22 == 0;
  if ( byte_10238F22 != v3 )
    LOBYTE(v2) = sub_1001DE50(a1, v2);
  return v2;
}
// 10238F22: using guessed type char byte_10238F22;

//----- (1001DFC0) --------------------------------------------------------
char __cdecl sub_1001DFC0(char a1)
{
  int v1; // esi@1
  int v2; // edi@1
  void *v3; // ecx@1
  char v4; // bl@1
  signed int v5; // eax@1
  int v6; // ecx@1
  void *v7; // ecx@2
  bool v8; // al@5
  int v9; // esi@11
  char v11; // [sp+Fh] [bp-1Dh]@14
  char v12; // [sp+10h] [bp-1Ch]@1
  __int16 v13; // [sp+12h] [bp-1Ah]@1
  __int16 v14; // [sp+14h] [bp-18h]@1
  __int16 v15; // [sp+16h] [bp-16h]@1
  char v16; // [sp+18h] [bp-14h]@1
  __int16 v17; // [sp+1Ah] [bp-12h]@1
  __int16 v18; // [sp+1Ch] [bp-10h]@1
  __int16 v19; // [sp+1Eh] [bp-Eh]@1
  int v20; // [sp+20h] [bp-Ch]@8
  int v21; // [sp+24h] [bp-8h]@9

  v12 = 36;
  v13 = 103;
  v14 = 105;
  v15 = 107;
  v16 = 37;
  v17 = 104;
  v18 = 106;
  v19 = 108;
  v1 = sub_1007C040();
  v2 = j_HWM_pvg_hsdb_get_lrus_online();
  sub_100460A0(v3);
  v4 = a1;
  v5 = sub_1001D480(a1);
  if ( (v6 & v5) == v5 )
  {
    v7 = (void *)(v2 & v5);
    if ( (v2 & v5) == v5 )
    {
      if ( (v5 & dword_1023E048) != v5 && (v5 & (unsigned int)dword_1023E048) < (unsigned int)v7 )
      {
        v8 = sub_1001D4A0(v4);
        sub_1001DF80(v8);
      }
      LOBYTE(v5) = sub_100474F0(v7);
      if ( (_BYTE)v5 && byte_10238F20 != 1 )
      {
        LOBYTE(v5) = sub_1004EA90(a1, &v20);
        if ( (_BYTE)v5 && (LOBYTE(v5) = sub_1004EA50(a1, (unsigned int *)&v21), (_BYTE)v5) )
        {
          if ( v20 != v21 )
          {
            v9 = sub_10043FF0(&a1, 1u, (int)&v12, 8, 2, 0);
            sub_10043480(*(&v13 + 4 * v9));
            sub_1003DF00(a1, 0);
            sub_10043370(*(&v15 + 4 * v9));
            LOBYTE(v5) = sub_10043370(*(&v14 + 4 * v9));
          }
          byte_10238F20 = 1;
        }
        else if ( (unsigned int)(v1 - dword_1023E050) > 0x3E8 )
        {
          dword_1023E050 = v1;
          LOBYTE(v5) = sub_1003DE70(&v11);
          if ( !(_BYTE)v5 || !v11 )
            LOBYTE(v5) = sub_1001D4B0(a1, 17);
        }
      }
    }
  }
  dword_1023E048 = v2;
  return v5;
}
// 1007C810: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 10238F20: using guessed type char byte_10238F20;
// 1023E048: using guessed type int dword_1023E048;
// 1023E050: using guessed type int dword_1023E050;

//----- (1001E160) --------------------------------------------------------
char __fastcall sub_1001E160(unsigned int a1)
{
  char result; // al@1

  result = 4;
  if ( a1 > 0x100000 )
  {
    if ( a1 == 0x200000 )
      result = 3;
  }
  else
  {
    switch ( a1 )
    {
      case 0x100000u:
        result = 2;
        break;
      case 0x10000u:
        result = 0;
        break;
      case 0x20000u:
        result = 1;
        break;
    }
  }
  return result;
}

//----- (1001E190) --------------------------------------------------------
char __cdecl sub_1001E190(signed int a1)
{
  void *v1; // ecx@0
  char v2; // al@1
  unsigned int v3; // esi@1
  unsigned __int8 v4; // si@2
  char v6; // [sp+Bh] [bp-5h]@1
  unsigned int v7; // [sp+Ch] [bp-4h]@2

  v6 = 0;
  v2 = sub_100460C0(v1);
  sub_1001D470(v2);
  v3 = a1;
  if ( (a1 & j_HWM_pvg_hsdb_get_lrus_online()) != a1 )
    return 0;
  LOBYTE(a1) = sub_1001D430();
  LOBYTE(v7) = sub_1001E160(v3);
  v4 = v7;
  if ( sub_1001D3B0(v7, &v6) != 1 )
    return 0;
  if ( v6 != (_BYTE)a1 )
  {
    sub_1001D470(a1);
    sub_1001DE50(v4, a1);
    return 0;
  }
  return 1;
}
// 1007C810: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (1001E220) --------------------------------------------------------
char __cdecl sub_1001E220(signed int a1, int a2, int a3, __int16 a4)
{
  int v4; // eax@1
  unsigned int v5; // ecx@1
  unsigned __int8 v6; // di@2
  char result; // al@2
  char v8; // [sp+6h] [bp-6h]@1
  char v9; // [sp+7h] [bp-5h]@1
  unsigned int v10; // [sp+8h] [bp-4h]@2

  v8 = 0;
  v9 = 0;
  v4 = j_HWM_pvg_hsdb_get_lrus_online();
  v5 = a1;
  if ( (a1 & v4) == a1 )
  {
    LOBYTE(a1) = a4 != 5 ? 16 : 2;
    LOBYTE(v10) = sub_1001E160(v5);
    sub_1001D470(a1);
    v6 = v10;
    result = sub_1001D3B0(v10, &v8);
    if ( result == 1 )
    {
      if ( v8 == (a4 != 5 ? 16 : 2) )
        return result;
      sub_1001DE50(v6, a1);
    }
    result = v9;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1007C810: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (1001E2B0) --------------------------------------------------------
BOOL __cdecl sub_1001E2B0(float a1)
{
  return (LODWORD(a1) & 0x7F800000) != 2139095040;
}

//----- (1001E2D0) --------------------------------------------------------
int __cdecl sub_1001E2D0(double a1, double a2)
{
  double *v2; // ecx@0
  double v3; // ST00_8@1
  double v4; // st7@1
  int result; // eax@4

  v3 = *v2;
  v4 = a1;
  if ( (HIDWORD(v3) & 0x7FF00000) == 2146435072 || a1 < *v2 || (v4 = a2, a2 > *v2) )
  {
    *v2 = v4;
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1001E320) --------------------------------------------------------
int sub_1001E320()
{
  dword_10332CD4 = sub_1007C040();
  sub_10043370(52);
  return sub_10043370(54);
}
// 10332CD4: using guessed type int dword_10332CD4;

//----- (1001E340) --------------------------------------------------------
__int16 __usercall sub_1001E340@<ax>(int a1@<esi>, unsigned __int8 a2)
{
  __int16 v2; // di@1
  unsigned __int16 v3; // ax@1
  __int16 v4; // di@1
  __int16 v5; // dx@3
  int v7; // [sp+4h] [bp-Ch]@3
  int v8; // [sp+8h] [bp-8h]@3
  int v9; // [sp+Ch] [bp-4h]@3

  v2 = (*(_BYTE *)(a1 + 4) == 1) | (unsigned __int16)(2 * (*(_BYTE *)(a1 + 3) == 0));
  v3 = sub_10043FF0((_DWORD *)(a1 + 32), 2u, (int)&unk_100A8CB8, 2, 6, 8);
  v4 = 16 * v2;
  if ( v3 < 8u )
    v4 |= v3;
  v5 = *(_WORD *)(a1 + 34);
  v7 = 0;
  v8 = 0;
  v9 = 0;
  LOWORD(v7) = v5;
  return 2 * v4 | (sub_100395C0(a2, (int)&v7) == 1);
}

//----- (1001E3D0) --------------------------------------------------------
char __usercall sub_1001E3D0@<al>(__int16 a1@<ax>)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xD6:
    case 0xDB:
    case 0xDC:
      result = 0;
      break;
    case 0xE7:
    case 0xEC:
    case 0xED:
      result = 1;
      break;
    default:
      sub_10042930("..\\lib\\acl\\iop\\iop_gps.c", 524, 0, 0);
      result = 2;
      break;
  }
  return result;
}

//----- (1001E440) --------------------------------------------------------
bool __cdecl sub_1001E440(char a1, __int16 a2)
{
  void *v2; // ecx@0
  char v3; // al@1
  char v4; // bl@1

  v3 = sub_10045280(v2);
  v4 = sub_10045200(v3, 3);
  return sub_1004ECB0(a1, 1, a2) == v4;
}

//----- (1001E470) --------------------------------------------------------
unsigned __int8 __usercall sub_1001E470@<al>(__int16 a1@<di>)
{
  unsigned __int8 result; // al@1
  int v2; // esi@6
  void *v3; // ecx@6
  int v4; // [sp+0h] [bp-4h]@1

  v4 = 0;
  result = sub_10023DA0(a1, (int)&byte_10332F00, &v4);
  if ( result == 1 )
  {
    result = sub_1001E3D0(a1);
    if ( result < 2u )
    {
      if ( v4 & 0x19 )
      {
        v2 = result;
        sub_10043480(word_100A8CB0[result]);
        sub_10043370(word_100A8CB4[v2]);
        result = sub_10046080(v3);
        if ( result )
        {
          result = sub_1001E440(49, a1);
          if ( result )
            result = sub_10041D90();
        }
      }
      else if ( v4 & 4 )
      {
        result = sub_10043480(word_100A8CB4[result]);
      }
    }
  }
  return result;
}
// 100A8CB0: using guessed type __int16 word_100A8CB0[];
// 100A8CB4: using guessed type __int16 word_100A8CB4[];
// 10332F00: using guessed type char byte_10332F00;

//----- (1001E510) --------------------------------------------------------
char __usercall sub_1001E510@<al>(__int16 a1@<si>)
{
  char result; // al@1
  int v2; // [sp+0h] [bp-Ch]@1
  int v3; // [sp+4h] [bp-8h]@1

  v2 = 0;
  v3 = 0;
  result = sub_10023DA0(a1, (int)&byte_10332F00, &v2);
  if ( result )
  {
    result = sub_1001E3D0(a1);
    if ( BYTE3(v2) )
    {
      if ( (unsigned __int8)result < 2u )
        result = sub_10043480(word_100A8CB4[(unsigned __int8)result]);
    }
  }
  return result;
}
// 100A8CB4: using guessed type __int16 word_100A8CB4[];
// 10332F00: using guessed type char byte_10332F00;

//----- (1001E580) --------------------------------------------------------
void __usercall sub_1001E580(__int16 a1@<si>)
{
  char v1; // bl@1
  unsigned __int8 v2; // al@1
  double v3; // ST5C_8@6
  int v4; // [sp+5Ch] [bp-B4h]@1
  int v5; // [sp+60h] [bp-B0h]@1
  int v6; // [sp+64h] [bp-ACh]@1
  char v7; // [sp+68h] [bp-A8h]@1
  __int16 v8; // [sp+8Ah] [bp-86h]@1
  float v9; // [sp+8Ch] [bp-84h]@12
  float v10; // [sp+90h] [bp-80h]@13
  float v11; // [sp+94h] [bp-7Ch]@14
  float v12; // [sp+A0h] [bp-70h]@15
  float v13; // [sp+A4h] [bp-6Ch]@16
  float v14; // [sp+A8h] [bp-68h]@17
  float v15; // [sp+ACh] [bp-64h]@18
  float v16; // [sp+B0h] [bp-60h]@19
  double v17; // [sp+D4h] [bp-3Ch]@6

  memset(&v7, 0, 0x9Cu);
  v1 = sub_10023DA0(a1, (int)&byte_10332F00, &v7);
  v4 = 0;
  v5 = 0;
  v6 = 0;
  LOWORD(v4) = v8;
  v2 = sub_1001E3D0(a1);
  if ( v1 && v2 < 2u && !sub_100395C0(v2, (int)&v4) )
    sub_10039890();
  if ( sub_1001E440(48, a1) == 1 )
  {
    v3 = v17;
    if ( (HIDWORD(v3) & 0x7FF00000) != 2146435072
      && v17 <= 6.2831853071796
      && v17 >= -6.2831853071796
      && sub_1001E2D0(6.2831853071796, -6.2831853071796)
      && sub_1001E2D0(6.2831853071796, -6.2831853071796)
      && sub_1001E2D0(6.2831853071796, -6.2831853071796)
      && sub_1001E2B0(v9)
      && sub_1001E2B0(v10)
      && sub_1001E2B0(v11)
      && sub_1001E2B0(v12)
      && sub_1001E2B0(v13)
      && sub_1001E2B0(v14)
      && sub_1001E2B0(v15)
      && sub_1001E2B0(v16)
      && v1 == 1 )
    {
      sub_10039840();
    }
  }
}
// 10332F00: using guessed type char byte_10332F00;

//----- (1001E7F0) --------------------------------------------------------
char __usercall sub_1001E7F0@<al>(int a1@<esi>)
{
  char result; // al@1
  __int16 v2; // [sp+0h] [bp-8h]@0
  int v3; // [sp+4h] [bp-4h]@1

  v3 = 0;
  result = sub_1001E440(47, v2);
  if ( result == 1 )
  {
    result = sub_10023DA0(a1, (int)&byte_10332F00, &v3);
    if ( result )
      result = sub_10039850(&v3);
  }
  return result;
}
// 10332F00: using guessed type char byte_10332F00;

//----- (1001E830) --------------------------------------------------------
char __usercall sub_1001E830@<al>(char a1@<al>)
{
  return sub_10045220(3, a1);
}

//----- (1001E840) --------------------------------------------------------
char __usercall sub_1001E840@<al>(__int16 a1@<cx>, int a2@<edi>, char a3)
{
  __int16 v3; // bx@1
  int v4; // ecx@5
  unsigned int v5; // ebp@7
  int v6; // esi@8
  int v7; // ecx@8
  int v8; // ecx@9
  unsigned __int8 v9; // al@10
  int v10; // esi@12
  int v11; // ecx@12
  int v12; // ecx@13
  unsigned __int8 v13; // al@14
  char v14; // bl@15
  char result; // al@19
  char v16; // al@20
  int v17; // [sp+8h] [bp-150h]@1
  int v18; // [sp+Ch] [bp-14Ch]@1
  char v19; // [sp+12h] [bp-146h]@1
  char v20; // [sp+13h] [bp-145h]@1
  void *v21; // [sp+14h] [bp-144h]@7
  int v22; // [sp+18h] [bp-140h]@7
  char v23; // [sp+1Ch] [bp-13Ch]@1
  char v24; // [sp+B8h] [bp-A0h]@1

  v3 = a1;
  memset(&v24, 0, 0x9Cu);
  memset(&v23, 0, 0x9Cu);
  sub_1004ECF0(a3, 0, &v20, &v18);
  sub_1004ECF0(a3, 1u, &v19, &v17);
  if ( v3 != (_WORD)v18 && v3 != (_WORD)v17
    || (unsigned __int16)v18 >= 0xBCCu
    || (unsigned __int16)v17 >= 0xBCCu
    || (v4 = *(_DWORD *)(a2 + 40), *(_WORD *)(v4 + 2 * (unsigned __int16)v18) == -1)
    || *(_WORD *)(v4 + 2 * (unsigned __int16)v17) == -1 )
  {
    result = sub_10042930("..\\lib\\acl\\iop\\iop_gps.c", 427, 0, 0);
  }
  else
  {
    v5 = sub_1007C040();
    v21 = 0;
    v22 = 0;
    if ( sub_10023DA0(v18, a2, &v23) )
    {
      v6 = *(_DWORD *)(a2 + 64);
      v7 = 2 * (unsigned __int16)v18;
      if ( *(_DWORD *)(v6 + 24 * *(_WORD *)(*(_DWORD *)(a2 + 40) + v7) + 16) )
      {
        v8 = *(_WORD *)(*(_DWORD *)(a2 + 40) + v7);
        if ( v5 <= *(_DWORD *)(a2 + 36)
                 + *(_DWORD *)(v6 + 24 * v8 + 16)
                 + (*(_DWORD *)(52 * v8 + *(_DWORD *)(a2 + 32) + 16) >> 1) )
        {
          v9 = sub_1001E3D0(v18);
          v21 = (void *)(unsigned __int16)sub_1001E340((int)&v23, v9);
        }
      }
    }
    if ( sub_10023DA0(v17, a2, &v24) )
    {
      v10 = *(_DWORD *)(a2 + 64);
      v11 = 2 * (unsigned __int16)v17;
      if ( *(_DWORD *)(v10 + 24 * *(_WORD *)(*(_DWORD *)(a2 + 40) + v11) + 16) )
      {
        v12 = *(_WORD *)(*(_DWORD *)(a2 + 40) + v11);
        if ( v5 <= *(_DWORD *)(a2 + 36)
                 + *(_DWORD *)(v10 + 24 * v12 + 16)
                 + (*(_DWORD *)(52 * v12 + *(_DWORD *)(a2 + 32) + 16) >> 1) )
        {
          v13 = sub_1001E3D0(v17);
          v22 = (unsigned __int16)sub_1001E340((int)&v24, v13);
        }
      }
    }
    v14 = sub_10045290();
    if ( (unsigned __int16)v22 >= (unsigned __int16)v21 )
    {
      if ( (unsigned __int16)v22 > (unsigned __int16)v21 )
        v14 = 1;
    }
    else
    {
      v14 = 0;
    }
    result = v5 - dword_10332CD4;
    if ( v5 - dword_10332CD4 > 0x5DC )
    {
      v16 = sub_10045280(v21);
      result = sub_10045200(v16, 3);
      if ( v14 != result )
      {
        dword_10332CD4 = v5;
        result = sub_1001E830(v14);
      }
    }
  }
  return result;
}
// 10332CD4: using guessed type int dword_10332CD4;

//----- (1001EA80) --------------------------------------------------------
void __cdecl sub_1001EA80(int a1, int a2)
{
  switch ( (unsigned __int16)a1 )
  {
    case 0xD6u:
    case 0xE7u:
      sub_1001E510(a1);
      break;
    case 0xDBu:
    case 0xECu:
      sub_1001E840(a1, a2, 48);
      sub_1001E580(a1);
      break;
    case 0xD8u:
    case 0xE9u:
      sub_1001E7F0(a1);
      break;
    case 0xDCu:
    case 0xEDu:
      sub_1001E470(a1);
      break;
    default:
      sub_10042930("..\\lib\\acl\\iop\\iop_gps.c", 276, 0, 0);
      break;
  }
}

//----- (1001EB20) --------------------------------------------------------
int sub_1001EB20()
{
  int result; // eax@1

  result = 0;
  byte_1023E054 = 0;
  dword_1023E060 = 0;
  byte_1023E055 = 1;
  dword_1023E058 = 0;
  byte_1023E05C = 3;
  return result;
}
// 1023E054: using guessed type char byte_1023E054;
// 1023E055: using guessed type char byte_1023E055;
// 1023E058: using guessed type int dword_1023E058;
// 1023E05C: using guessed type char byte_1023E05C;
// 1023E060: using guessed type int dword_1023E060;

//----- (1001EB40) --------------------------------------------------------
char __cdecl sub_1001EB40(int a1, int a2)
{
  void *v2; // ecx@0
  int v3; // esi@1
  void *v4; // ecx@1
  char result; // al@1
  bool v6; // zf@2
  int v7; // eax@4

  v3 = sub_100429D0(v2);
  result = sub_100460C0(v4);
  switch ( v3 )
  {
    case 4:
      result = result != 2;
      v6 = result == 0;
      goto LABEL_3;
    default:
      goto LABEL_5;
    case 1:
      if ( result == 2 )
        goto LABEL_4;
      v6 = dword_1023E058 == 0;
LABEL_3:
      if ( !v6 )
        goto LABEL_4;
      goto LABEL_5;
    case 16:
    case 32:
    case 64:
    case 128:
      if ( result == 2 )
        goto LABEL_5;
      if ( dword_1023E058 )
      {
LABEL_4:
        v7 = sub_1007C040();
        result = sub_10023190(a1, 1, a2, &dword_1023E058, v7);
LABEL_5:
        dword_1023E058 = 0;
      }
      else
      {
        dword_1023E058 = 0;
      }
      return result;
  }
}
// 1023E058: using guessed type int dword_1023E058;

//----- (1001EC50) --------------------------------------------------------
char __cdecl sub_1001EC50(char a1)
{
  char result; // al@1

  result = a1;
  byte_1023E05C = a1;
  dword_1023E058 = 2;
  return result;
}
// 1023E058: using guessed type int dword_1023E058;
// 1023E05C: using guessed type char byte_1023E05C;

//----- (1001EC70) --------------------------------------------------------
void __cdecl sub_1001EC70(__int16 a1)
{
  void *v1; // ecx@0

  if ( a1 == 1314 && sub_1004ED50(v1) )
    byte_1023E055 = 1;
}
// 1023E055: using guessed type char byte_1023E055;

//----- (1001EC90) --------------------------------------------------------
int __cdecl sub_1001EC90(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1023E058 = a1;
  return result;
}
// 1023E058: using guessed type int dword_1023E058;

//----- (1001ECA0) --------------------------------------------------------
char sub_1001ECA0()
{
  int v0; // esi@1
  void *v1; // ecx@1
  char result; // al@1
  void *v3; // ecx@1
  char v4; // [sp+7h] [bp-9h]@10
  int v5; // [sp+8h] [bp-8h]@3
  int v6; // [sp+Ch] [bp-4h]@4

  v0 = sub_1007C040();
  result = sub_1004ED50(v1);
  if ( result )
  {
    result = sub_100474F0(v3);
    if ( result )
    {
      if ( sub_1004EEF0(32, (unsigned int *)&v5) && sub_1004EE30(32, (unsigned int *)&v6) )
      {
        if ( v5 != v6 || (result = sub_10049600((void *)0x20)) == 0 )
        {
          sub_10043480(0xD7u);
          result = sub_1003DF00(0x20u, 0);
          byte_1023E055 = 1;
        }
        byte_1023E054 = 1;
      }
      else
      {
        result = v0 - dword_1023E060;
        if ( (unsigned int)(v0 - dword_1023E060) > 0x64 )
        {
          result = sub_1003DE70(&v4);
          if ( !result || !v4 )
          {
            dword_1023E060 = v0;
            result = sub_1003DED0(32, 17, 0);
          }
        }
      }
    }
  }
  return result;
}
// 1023E054: using guessed type char byte_1023E054;
// 1023E055: using guessed type char byte_1023E055;
// 1023E060: using guessed type int dword_1023E060;

//----- (1001ED70) --------------------------------------------------------
void __cdecl sub_1001ED70(int a1, int a2)
{
  void *v2; // ecx@2
  char v3; // [sp+0h] [bp-18h]@2

  if ( (_WORD)a1 == 1314 && sub_10023DA0(a1, a2, &v3) )
  {
    if ( byte_1023E055 == 1 )
    {
      sub_1001F610(v2);
      LOBYTE(a1) = 4;
      sub_1007D180(115, &a1);
      byte_1023E05C = a1;
      dword_1023E058 = 8;
    }
    byte_1023E055 = 0;
  }
  if ( !byte_1023E054 )
    sub_1001ECA0();
}
// 1023E054: using guessed type char byte_1023E054;
// 1023E055: using guessed type char byte_1023E055;
// 1023E058: using guessed type int dword_1023E058;
// 1023E05C: using guessed type char byte_1023E05C;

//----- (1001EDF0) --------------------------------------------------------
char __cdecl sub_1001EDF0(_BYTE *a1)
{
  char result; // al@3
  char v2; // [sp+0h] [bp-18h]@1

  if ( !sub_100253C0(1, 1314, &v2) || sub_1004C510((int)&v2) )
  {
    result = 0;
  }
  else
  {
    result = 1;
    *a1 = v2;
  }
  return result;
}

//----- (1001EE30) --------------------------------------------------------
char __cdecl sub_1001EE30(int a1, int a2, int a3, int a4, char a5, int a6)
{
  int v6; // eax@1
  char result; // al@2

  v6 = sub_10043FF0(&a5, 1u, (int)&unk_100AA080, 101, 10, 10);
  if ( v6 == 10 )
  {
    result = 0;
  }
  else
  {
    sub_100421E0(a6, &byte_100AA081[101 * v6], 100);
    result = 1;
  }
  return result;
}

//----- (1001EE80) --------------------------------------------------------
char sub_1001EE80()
{
  return byte_1023E069;
}
// 1023E069: using guessed type char byte_1023E069;

//----- (1001EE90) --------------------------------------------------------
char sub_1001EE90()
{
  char v0; // bl@1
  unsigned int v1; // eax@2
  _DWORD *v2; // ecx@2
  char *v3; // edx@2
  int v4; // esi@6
  int v5; // eax@7
  _BYTE *v6; // ecx@7
  _BYTE *v7; // edx@7
  int v8; // eax@9
  _BYTE *v9; // ecx@9
  _BYTE *v10; // edx@9
  _BYTE *v11; // ecx@11
  _BYTE *v12; // edx@11
  signed int v13; // eax@13
  char v15; // [sp+4h] [bp-100h]@1

  memset(&v15, 0, 0xFCu);
  v0 = sub_1004ED70();
  if ( v0 != 1 )
    goto LABEL_18;
  v1 = 252;
  v2 = &unk_1023E070;
  v3 = &v15;
  do
  {
    if ( *(_DWORD *)v3 != *v2 )
      goto LABEL_6;
    v1 -= 4;
    ++v2;
    v3 += 4;
  }
  while ( v1 >= 4 );
  if ( !v1 )
  {
LABEL_15:
    v13 = 0;
    goto LABEL_16;
  }
LABEL_6:
  v4 = (unsigned __int8)*v3 - *(_BYTE *)v2;
  if ( (unsigned __int8)*v3 == *(_BYTE *)v2 )
  {
    v5 = v1 - 1;
    v6 = (char *)v2 + 1;
    v7 = v3 + 1;
    if ( !v5 )
      goto LABEL_15;
    v4 = *v7 - *v6;
    if ( *v7 == *v6 )
    {
      v8 = v5 - 1;
      v9 = v6 + 1;
      v10 = v7 + 1;
      if ( !v8 )
        goto LABEL_15;
      v4 = *v10 - *v9;
      if ( *v10 == *v9 )
      {
        v11 = v9 + 1;
        v12 = v10 + 1;
        if ( v8 == 1 )
          goto LABEL_15;
        v4 = *v12 - *v11;
        if ( *v12 == *v11 )
          goto LABEL_15;
      }
    }
  }
  v13 = 1;
  if ( v4 <= 0 )
    v13 = -1;
LABEL_16:
  if ( !v13 )
  {
    sub_10018810(10);
    return v0;
  }
  v0 = 0;
LABEL_18:
  sub_10018720();
  if ( (unsigned int)sub_10018700() <= 0xA )
    sub_10018810(1);
  else
    sub_10018810(8);
  return v0;
}

//----- (1001EFA0) --------------------------------------------------------
char sub_1001EFA0()
{
  if ( (unsigned int)(sub_1007C040() - dword_1023E16C) > 0x1F4 )
    sub_10018810((unsigned __int8)byte_1023E068);
  return 1;
}
// 1023E068: using guessed type char byte_1023E068;
// 1023E16C: using guessed type int dword_1023E16C;

//----- (1001EFD0) --------------------------------------------------------
char __cdecl sub_1001EFD0(char a1)
{
  char result; // al@1

  result = a1;
  if ( a1 == 4 )
    result = 1;
  byte_1023E069 = result;
  return result;
}
// 1023E069: using guessed type char byte_1023E069;

//----- (1001EFE0) --------------------------------------------------------
BOOL sub_1001EFE0()
{
  return j_HWM_pvg_read_reg(1) == 1 && !(j_HWM_pvg_hsdb_get_lrus_online() & 0x4000);
}
// 1007C810: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1001F010) --------------------------------------------------------
char __cdecl sub_1001F010(void *a1, int a2)
{
  void *v2; // ecx@0
  int v3; // eax@1

  LOWORD(v3) = sub_100460A0(v2);
  if ( v3 & 0x4000 )
    LOBYTE(v3) = sub_10024E60(1, 1309, a1, 0, 252, a2);
  return v3;
}

//----- (1001F040) --------------------------------------------------------
int __usercall sub_1001F040@<eax>(int result@<eax>, char a2)
{
  if ( a2 == 32 )
    result = sub_1007C580(6455, result, 252);
  return result;
}

//----- (1001F060) --------------------------------------------------------
char __usercall sub_1001F060@<al>(int a1@<ecx>, char a2@<dl>, int a3@<eax>, int a4@<esi>, void *a5)
{
  sub_10024E60(1, a4, a5, a2, a1, a3);
  return sub_10025010(1, a4, 0x4000);
}

//----- (1001F090) --------------------------------------------------------
char sub_1001F090()
{
  void *v0; // ecx@1
  char v1; // al@1

  byte_1023E068 = 0;
  dword_1023E16C = 0;
  memset(&unk_1023E070, 0, 0xFCu);
  v1 = sub_100460C0(v0);
  return sub_1001EFD0(v1);
}
// 1023E068: using guessed type char byte_1023E068;
// 1023E16C: using guessed type int dword_1023E16C;

//----- (1001F0C0) --------------------------------------------------------
char __cdecl sub_1001F0C0(signed int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  void *v3; // ecx@6

  LOBYTE(v2) = a1;
  switch ( (unsigned __int8)a1 )
  {
    case 1u:
      a1 = 2;
      goto LABEL_6;
    case 2u:
      a1 = 3;
      goto LABEL_6;
    case 8u:
      a1 = 4;
      goto LABEL_6;
    case 0x10u:
      a1 = 5;
LABEL_6:
      v2 = sub_100429D0(v1);
      if ( v2 == 1 || (v2 = sub_100460A0(v3), !(v2 & 1)) )
      {
        LOBYTE(v2) = 1;
        LOBYTE(v2) = sub_1001F060(4, 0, v2, 1313, &a1);
      }
      break;
    default:
      return v2;
  }
  return v2;
}

//----- (1001F160) --------------------------------------------------------
char __cdecl sub_1001F160(char a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  int *v3; // eax@5
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1

  v2 = 0;
  v5 = 0;
  v6 = sub_100429D0(v1);
  if ( a1 == 11 )
    goto LABEL_10;
  if ( a1 == 17 )
  {
    LOWORD(v5) = 1310;
    goto LABEL_5;
  }
  if ( a1 == 19 )
  {
LABEL_10:
    LOWORD(v5) = 1309;
LABEL_5:
    v3 = &v5;
    v2 = 1;
    LOBYTE(v3) = 1;
    sub_1001F060(8, 0, (int)v3, 0, &v5);
  }
  return v2;
}

//----- (1001F1E0) --------------------------------------------------------
char __usercall sub_1001F1E0@<al>(const void *a1@<ebx>)
{
  int v1; // eax@1
  char v3; // [sp+8h] [bp-108h]@1

  memset(&v3, 0, 0xFCu);
  sub_1001F010(&v3, 0);
  qmemcpy(&unk_1023E070, a1, 0xFCu);
  qmemcpy(&v3, a1, 0xFCu);
  LOBYTE(v1) = 1;
  return sub_1001F060(252, 0, v1, 1311, &v3);
}

//----- (1001F280) --------------------------------------------------------
char __cdecl sub_1001F280(int a1, char a2)
{
  char result; // al@4
  char v3; // bl@7
  char v4; // [sp+0h] [bp-100h]@1

  memset(&v4, 0, 0xFCu);
  sub_1001F160(a2);
  if ( sub_10018710() == 2 )
  {
    if ( (unsigned __int8)sub_1001EFE0() )
    {
      sub_1004EE10(a1, (int)&v4);
      sub_1001F010(&v4, 1);
    }
    sub_10018810(7);
    result = 1;
  }
  else
  {
    if ( (unsigned __int8)sub_1001EFE0() )
      sub_1001F010(&unk_1023E070, 1);
    v3 = sub_1004ED70();
    if ( v3 == 1 )
    {
      if ( sub_10018710() != 5 || sub_100186F0() != 1 )
      {
        sub_10018810(3);
        result = 1;
      }
      else
      {
        sub_10018810(10);
        result = 1;
      }
    }
    else
    {
      sub_10018720();
      if ( (unsigned int)sub_10018700() <= 0xA )
      {
        sub_10018810(4);
        byte_1023E068 = 2;
        dword_1023E16C = sub_1007C040();
        result = v3;
      }
      else
      {
        sub_10018810(8);
        result = v3;
      }
    }
  }
  return result;
}
// 1023E068: using guessed type char byte_1023E068;
// 1023E16C: using guessed type int dword_1023E16C;

//----- (1001F400) --------------------------------------------------------
char __cdecl sub_1001F400(char a1, int a2, char a3, int a4, int *a5, int a6)
{
  char v6; // bl@1
  char *v7; // ebx@4
  char v9; // [sp+8h] [bp-118h]@6
  char v10; // [sp+Ch] [bp-114h]@7
  char v11; // [sp+20h] [bp-100h]@1
  int v12; // [sp+FCh] [bp-24h]@10

  memset(&v11, 0, 0xFCu);
  v6 = 0;
  if ( a1 == 32 )
  {
    if ( a6 )
    {
      if ( a3 != 19 )
      {
        v7 = (char *)a5;
        goto LABEL_12;
      }
      if ( (sub_1004ED30(&v9) && !(v10 & 2) || (unsigned __int8)sub_1001EFE0())
        && (unsigned __int8)sub_1004EE10(32, (int)&v11) )
      {
        v12 = *a5;
        v7 = &v11;
        goto LABEL_12;
      }
    }
    else if ( (unsigned __int8)sub_1004EE10(32, (int)&v11) )
    {
      v7 = &v11;
LABEL_12:
      sub_1001F1E0(v7);
      v6 = 1;
      sub_10018810(4);
      byte_1023E068 = 2;
LABEL_16:
      dword_1023E16C = sub_1007C040();
      return v6;
    }
  }
  sub_10018720();
  if ( (unsigned int)sub_10018700() <= 0xA )
  {
    sub_10018810(4);
    byte_1023E068 = 6;
    goto LABEL_16;
  }
  sub_10018810(8);
  return v6;
}
// 1023E068: using guessed type char byte_1023E068;
// 1023E16C: using guessed type int dword_1023E16C;

//----- (1001F520) --------------------------------------------------------
char __cdecl sub_1001F520(int a1, char a2)
{
  char v2; // bl@2
  void *v3; // ecx@6
  char v4; // al@6
  char v6; // [sp+8h] [bp-100h]@1

  memset(&v6, 0, 0xFCu);
  if ( a2 )
  {
    if ( !(unsigned __int8)sub_1004EE10(a1, (int)&v6) || !sub_1004ED70() )
    {
      v2 = 0;
      sub_10018810(8);
      return v2;
    }
    v2 = 1;
    qmemcpy(&unk_1023E070, &v6, 0xFCu);
    sub_1001F040((int)&v6, a1);
  }
  else
  {
    sub_1001F040((int)&unk_1023E070, a1);
    v2 = 1;
  }
  sub_10018810(7);
  v4 = sub_100460C0(v3);
  sub_1001EFD0(v4);
  sub_1001F0C0((unsigned __int8)byte_1023E069);
  return v2;
}
// 1023E069: using guessed type char byte_1023E069;

//----- (1001F610) --------------------------------------------------------
char __thiscall sub_1001F610(void *this)
{
  bool v1; // zf@1
  signed int v2; // eax@1
  bool v3; // cl@2
  void *v5; // [sp-2h] [bp-4h]@1

  v5 = this;
  v1 = sub_1001EDF0((_BYTE *)&v5 + 3) == 1;
  LOBYTE(v2) = byte_1023E069;
  if ( v1 )
    v3 = BYTE3(v5);
  else
    v3 = byte_1023E069 == 0;
  if ( byte_1023E069 != v3 )
    sub_1001F0C0(v2);
  sub_1001F160(17);
  return sub_1001F160(11);
}
// 1023E069: using guessed type char byte_1023E069;

//----- (1001F660) --------------------------------------------------------
char __cdecl sub_1001F660(signed int a1)
{
  void *v1; // ecx@0
  char v2; // al@1
  char v4; // [sp+7h] [bp-1h]@1

  v4 = 0;
  v2 = sub_100460C0(v1);
  sub_1001EFD0(v2);
  if ( (a1 & j_HWM_pvg_hsdb_get_lrus_online()) != a1 )
    return 0;
  LOBYTE(a1) = sub_1001EE80();
  if ( sub_1001EDF0(&v4) != 1 )
    return 0;
  if ( v4 != (_BYTE)a1 )
  {
    sub_1001EFD0(a1);
    sub_1001F0C0(a1);
    return 0;
  }
  return 1;
}
// 1007C810: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (1001F6D0) --------------------------------------------------------
char __cdecl sub_1001F6D0(int a1)
{
  char result; // al@2
  char v2; // [sp+7h] [bp-1h]@1

  v2 = 0;
  if ( (a1 & j_HWM_pvg_hsdb_get_lrus_online()) == a1 )
  {
    sub_1001EFD0(16);
    result = sub_1001EDF0(&v2);
    if ( result == 1 )
    {
      if ( v2 == 16 )
        return result;
      sub_1001F0C0(16);
    }
  }
  return 0;
}
// 1007C810: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (1001F720) --------------------------------------------------------
char __cdecl sub_1001F720(unsigned __int16 a1)
{
  void *v1; // ecx@0
  char result; // al@1
  char *v3; // eax@8

  result = a1;
  if ( (signed int)a1 >= 206 && ((signed int)a1 <= 207 || a1 == 1145) )
  {
    result = sub_1004EFE0(v1);
    if ( result )
    {
      sub_1007C110(89, 300);
      if ( !sub_100432C0(178) && !sub_100432C0(253) )
        sub_10043480(0xB3u);
      *(_BYTE *)dword_1023E274 = 1;
      byte_1023E26D = 1;
      v3 = byte_1023E1A2;
      do
      {
        *(v3 - 9) = 4;
        *v3 = 4;
        *(_DWORD *)(v3 - 22) = 0;
        v3[13] = 0;
        v3[6] = 9;
        *(_DWORD *)(v3 - 18) = 16;
        v3 += 56;
      }
      while ( (signed int)v3 < (signed int)&unk_1023E282 );
      sub_1007C0F0(89);
      result = sub_1007C500(9362, (int)&word_1023E188[28 * (unsigned __int8)byte_1023E172], 56);
    }
  }
  return result;
}
// 1023E172: using guessed type char byte_1023E172;
// 1023E188: using guessed type __int16 word_1023E188[];
// 1023E26D: using guessed type char byte_1023E26D;
// 1023E274: using guessed type int dword_1023E274;

//----- (1001F7F0) --------------------------------------------------------
char sub_1001F7F0()
{
  int v0; // esi@1
  void *v1; // ecx@1
  char result; // al@1
  char v3; // [sp+7h] [bp-49h]@10
  int v4; // [sp+8h] [bp-48h]@2
  int v5; // [sp+Ch] [bp-44h]@3
  char v6; // [sp+10h] [bp-40h]@4
  unsigned __int16 v7; // [sp+12h] [bp-3Eh]@5

  v0 = sub_1007C040();
  result = sub_1004EFE0(v1);
  if ( result )
  {
    result = sub_1004F240(19, (unsigned int *)&v4);
    if ( result && (result = sub_1004F160(19, (unsigned int *)&v5)) != 0 )
    {
      sub_1004F0F0(19, (int)&v6);
      if ( v4 != v5 || (result = v7, v7 > 0x800u) || v7 < 0x1F4u )
      {
        sub_10043480(0xB2u);
        sub_1003DF00(0x13u, 0);
        sub_1007C110(89, 300);
        byte_1023E26D = 1;
        *(_BYTE *)dword_1023E274 = 1;
        result = sub_1007C0F0(89);
      }
      byte_1023E26F = 1;
    }
    else if ( (unsigned int)(v0 - dword_1023E278) > 0x64 )
    {
      dword_1023E278 = v0;
      result = sub_1003DE70(&v3);
      if ( !result || !v3 )
        result = sub_1003DED0(19, 17, 0);
    }
  }
  return result;
}
// 1023E26D: using guessed type char byte_1023E26D;
// 1023E26F: using guessed type char byte_1023E26F;
// 1023E274: using guessed type int dword_1023E274;
// 1023E278: using guessed type int dword_1023E278;

//----- (1001F900) --------------------------------------------------------
unsigned __int8 __usercall sub_1001F900@<al>(__int16 a1@<si>, int a2)
{
  unsigned __int8 result; // al@1
  __int16 v3; // dx@3

  result = 0;
  if ( a2 )
  {
    if ( byte_1023E185 )
    {
      do
      {
        v3 = word_1023E188[28 * result];
        if ( v3 == a1 || !dword_1023E18C[14 * result] && v3 == 4 )
          break;
        ++result;
      }
      while ( result < (unsigned __int8)byte_1023E185 );
    }
    if ( result == byte_1023E185 && (unsigned __int8)byte_1023E185 < 4u )
      ++byte_1023E185;
  }
  return result;
}
// 1023E185: using guessed type char byte_1023E185;
// 1023E188: using guessed type __int16 word_1023E188[];
// 1023E18C: using guessed type int dword_1023E18C[];

//----- (1001F960) --------------------------------------------------------
__int16 __usercall sub_1001F960@<ax>(__int16 a1@<ax>, char a2)
{
  __int16 result; // ax@3

  if ( a2 )
  {
    result = (signed int)((double)(a1 + 5461) / 10923.0 * 166.0 + 0.5);
  }
  else if ( byte_1023E184 )
  {
    result = (signed int)(((double)a1 + 10922.666015625) / 21845.33203125 * 256.0 + 0.5);
  }
  else
  {
    result = (signed int)(((double)a1 + 8192.0) * 0.00006103515625 * 256.0 + 0.5);
  }
  return result;
}
// 1023E184: using guessed type char byte_1023E184;

//----- (1001FA50) --------------------------------------------------------
char __thiscall sub_1001FA50(void *this)
{
  unsigned int v1; // eax@1

  LOBYTE(v1) = sub_100460C0(this);
  if ( (_BYTE)v1 == 1 )
  {
    v1 = j_FIL_vfs_open("/mnt/card0/gwx_data/gwx_data.bin", 2, 0);
    dword_1023E270 = v1;
    if ( v1 >= 0xFFFFFFC2 || !v1 )
      dword_1023E270 = 0;
  }
  return v1;
}
// 1007CEC0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1023E270: using guessed type int dword_1023E270;

//----- (1001FA90) --------------------------------------------------------
signed int sub_1001FA90()
{
  int v0; // ecx@3
  signed int v1; // eax@3
  char v2; // dl@5

  sub_1007C110(89, 300);
  if ( !sub_1007CD60((LONG)&off_100AAEE8) )
    sub_10042930("..\\lib\\acl\\iop\\gwx\\iop_gwx.c", 2057, 1, 0);
  *(_DWORD *)dword_1023E274 = 0;
  v0 = 0;
  v1 = 0;
  do
  {
    *(_DWORD *)(v1 + dword_1023E274 + 8) = 0;
    *(_WORD *)(v1 + dword_1023E274 + 4) = v0;
    v1 += 80;
    ++v0;
  }
  while ( v1 < 320 );
  v2 = byte_1023E26D;
  *(_BYTE *)(dword_1023E274 + 1) = 0;
  *(_BYTE *)dword_1023E274 = v2;
  sub_1007C0F0(89);
  return sub_1007C8F0((int)&off_100AAEE8);
}
// 100AAEE8: using guessed type char *off_100AAEE8;
// 1023E26D: using guessed type char byte_1023E26D;
// 1023E274: using guessed type int dword_1023E274;

//----- (1001FB40) --------------------------------------------------------
int __usercall sub_1001FB40@<eax>(int a1@<eax>, int a2@<ecx>, unsigned __int16 a3)
{
  char v3; // dl@2
  int result; // eax@6
  int v5; // ecx@9
  __int16 v6; // [sp+0h] [bp-2h]@1

  v6 = HIWORD(a2);
  if ( a1 )
  {
    v3 = *(_BYTE *)(a1 + 10);
    LOBYTE(v6) = *(_BYTE *)(a1 + 11);
    HIBYTE(v6) = *(_BYTE *)(a1 + 13);
  }
  else if ( a2 )
  {
    v3 = *(_BYTE *)(a2 + 21);
    LOBYTE(v6) = *(_BYTE *)(a2 + 20);
    HIBYTE(v6) = *(_BYTE *)(a2 + 6);
  }
  else
  {
    v3 = a3;
  }
  result = 80 * a3;
  if ( *(_BYTE *)(result + dword_1023E274 + 33) != v3
    || *(_BYTE *)(result + dword_1023E274 + 32) != (_BYTE)v6
    || *(_BYTE *)(result + dword_1023E274 + 18) != HIBYTE(v6) )
  {
    v5 = 270364 * a3;
    *(_BYTE *)(result + dword_1023E274 + 33) = v3;
    *(_BYTE *)(result + dword_1023E274 + 32) = v6;
    *(_BYTE *)(result + dword_1023E274 + 18) = HIBYTE(v6);
    result = 257;
    do
    {
      *(_BYTE *)(v5 + dword_1023E274 + 324) = 0;
      v5 += 1052;
      --result;
    }
    while ( result );
  }
  return result;
}
// 1023E274: using guessed type int dword_1023E274;

//----- (1001FC00) --------------------------------------------------------
signed int __usercall sub_1001FC00@<eax>(int a1@<edi>, int a2, unsigned __int16 a3, unsigned __int16 a4)
{
  unsigned __int16 v4; // bp@1
  signed int result; // eax@1
  unsigned __int16 i; // si@3
  unsigned __int8 v7; // al@5
  unsigned __int8 v8; // bl@5
  unsigned __int8 v9; // al@5
  unsigned __int8 v10; // bl@5
  unsigned int v11; // eax@8
  unsigned __int8 v12; // [sp+7h] [bp-5h]@5
  int v13; // [sp+8h] [bp-4h]@1

  v4 = 0;
  result = -1;
  v13 = 0;
  if ( a1 && a2 )
  {
    for ( i = 0; i < a3; ++v4 )
    {
      if ( v4 >= a4 )
        break;
      v7 = *(_BYTE *)(v4 + a2);
      v8 = v7;
      v9 = (v7 >> 3) + 1;
      v10 = v8 & 7;
      v12 = v9;
      if ( v13 & 1 )
      {
        *(_BYTE *)(((unsigned int)i >> 1) + a1) |= v10;
        --v9;
        i = ++v13;
        v12 = v9;
      }
      memset((void *)(a1 + ((unsigned int)i >> 1)), v10 | 16 * v10, (unsigned int)v9 >> 1);
      i += 2 * (v12 >> 1);
      LOWORD(v13) = i;
      if ( v12 & 1 )
      {
        v11 = (unsigned int)i >> 1;
        i = ++v13;
        *(_BYTE *)(v11 + a1) = 16 * v10;
      }
    }
    if ( i == a3 )
      result = 0;
    else
      result = -1;
  }
  return result;
}

//----- (1001FCF0) --------------------------------------------------------
char __usercall sub_1001FCF0@<al>(char a1@<bl>)
{
  char result; // al@1

  result = sub_100432C0(181);
  if ( a1 )
  {
    if ( !result )
    {
      result = sub_10043480(0xB5u);
      byte_1023E186 = a1;
      return result;
    }
  }
  else if ( result )
  {
    result = sub_10043370(181);
  }
  byte_1023E186 = a1;
  return result;
}
// 1023E186: using guessed type char byte_1023E186;

//----- (1001FD40) --------------------------------------------------------
int *__cdecl sub_1001FD40(char a1, char a2)
{
  char v2; // bl@1
  int *result; // eax@7
  char v4; // dl@7
  int v5; // edx@11
  int v6; // ebp@11

  v2 = *(_BYTE *)(dword_1023E274 + 2);
  sub_1007C110(89, 300);
  if ( v2 == 2 && a1 && !a2 )
  {
    a1 = 0;
    sub_1007C500(9363, (int)&a1, 1);
  }
  if ( a1 != v2 )
    *(_BYTE *)(dword_1023E274 + 2) = a1;
  result = (int *)sub_1007C0F0(89);
  v4 = a1;
  if ( a1 )
  {
    if ( a1 != v2 )
    {
      result = &dword_1023E190[14 * (unsigned __int8)byte_1023E172];
      *result = *result & 0xFFFFEFFF | 0x10;
    }
    if ( byte_1023E185 )
    {
      v5 = 14 * (unsigned __int8)byte_1023E172;
      result = (int *)byte_1023E1AC;
      v6 = (unsigned __int8)byte_1023E185;
      do
      {
        qmemcpy(result - 7, &dword_1023E190[v5], 0x1Cu);
        *result = *(_DWORD *)&byte_1023E1AC[v5 * 4];
        result[1] = dword_1023E1B0[v5];
        result[2] = dword_1023E1B4[v5];
        result[3] = dword_1023E1B8[v5];
        result[4] = dword_1023E1BC[v5];
        result += 14;
        --v6;
      }
      while ( v6 );
      v4 = a1;
    }
    if ( v4 == 2 )
      result = (int *)sub_1007C500(9362, (int)&word_1023E188[28 * (unsigned __int8)byte_1023E172], 56);
  }
  return result;
}
// 1023E172: using guessed type char byte_1023E172;
// 1023E185: using guessed type char byte_1023E185;
// 1023E188: using guessed type __int16 word_1023E188[];
// 1023E190: using guessed type int dword_1023E190[];
// 1023E1B0: using guessed type int dword_1023E1B0[];
// 1023E1B4: using guessed type int dword_1023E1B4[];
// 1023E1B8: using guessed type int dword_1023E1B8[];
// 1023E1BC: using guessed type int dword_1023E1BC[];
// 1023E274: using guessed type int dword_1023E274;

//----- (1001FE80) --------------------------------------------------------
char __usercall sub_1001FE80@<al>(unsigned __int16 a1@<si>)
{
  char v1; // cl@1
  int v2; // eax@1
  char v3; // dl@3
  char v5; // [sp+6h] [bp-6h]@1
  char v6; // [sp+7h] [bp-5h]@1
  int v7; // [sp+8h] [bp-4h]@1

  v5 = 1;
  sub_1007C650(3161, &v6, 1, &v5);
  v1 = sub_10048640(&v7);
  v2 = v7;
  if ( v1 )
  {
    v2 = abs(v7);
    v7 = v2;
  }
  v3 = v6;
  if ( v6 != byte_1023E173
    || v1
    && v2 >= 23860929
    && !byte_1023E26D
    && (v2 = dword_1023E274 + 80 * a1, *(_BYTE *)(v2 + 32) == 8)
    && !*(_BYTE *)(v2 + 18) )
  {
    v2 = a1;
    byte_1023E290[v2] = 0;
    byte_1023E27C[v2] = 0;
    byte_1023E280[v2] = 6;
    byte_1023E173 = v3;
    if ( !v3 && byte_1023E186 )
      LOBYTE(v2) = sub_1001FCF0(0);
  }
  return v2;
}
// 1023E173: using guessed type char byte_1023E173;
// 1023E186: using guessed type char byte_1023E186;
// 1023E26D: using guessed type char byte_1023E26D;
// 1023E274: using guessed type int dword_1023E274;

//----- (1001FF30) --------------------------------------------------------
int __usercall sub_1001FF30@<eax>(unsigned __int16 a1@<ax>, int a2)
{
  int v3; // [sp+0h] [bp-4h]@1

  v3 = a1;
  j_FIL_vfs_write(dword_1023E270, &v3, 4);
  return j_FIL_vfs_write(dword_1023E270, a2, v3);
}
// 1023E270: using guessed type int dword_1023E270;

//----- (1001FF70) --------------------------------------------------------
char __cdecl sub_1001FF70(__int16 a1, int a2)
{
  char v2; // bl@1
  char result; // al@1
  int v4; // eax@8
  int v5; // eax@13
  bool v6; // zf@15
  int v7; // eax@22
  int v8; // [sp+8h] [bp-8h]@18
  int v9; // [sp+Ch] [bp-4h]@18

  v2 = sub_1004EF40(&byte_1023E187);
  result = byte_1023E170;
  if ( (unsigned __int8)byte_1023E170 >= (unsigned __int8)byte_1023E185 )
  {
    result = 0;
    byte_1023E170 = 0;
  }
  if ( a1 == 1145 )
  {
    result = sub_10045FC0(dword_1023E18C[14 * (unsigned __int8)result]);
    if ( !result )
    {
      result = byte_1023E170;
      dword_1023E18C[14 * (unsigned __int8)byte_1023E170] = 0;
    }
  }
  if ( !v2 || byte_1023E187 == 1 )
  {
    sub_1007C110(89, 300);
    v4 = 14 * (unsigned __int8)byte_1023E170;
    if ( *(_BYTE *)(80 * (unsigned __int16)word_1023E188[28 * (unsigned __int8)byte_1023E170] + dword_1023E274 + 32) != 9 )
    {
      byte_1023E1A8[v4 * 4] = 9;
      dword_1023E190[v4] = 16;
    }
    result = sub_1007C0F0(89);
  }
  if ( a1 == 207 )
  {
    result = dword_1023E274;
    if ( !*(_BYTE *)(dword_1023E274 + 1) )
    {
      v5 = sub_1007C040();
      result = sub_10023190(207, 1, a2, &dword_1023E190[14 * (unsigned __int8)byte_1023E172], v5);
    }
  }
  else if ( a1 == 1145 )
  {
    v6 = (unsigned __int8)sub_1004EF80() == 0;
    result = byte_1023E170;
    if ( v6 || !dword_1023E18C[14 * (unsigned __int8)byte_1023E170] )
    {
      if ( !dword_1023E18C[14 * (unsigned __int8)byte_1023E170] )
        result = byte_1023E170++ + 1;
    }
    else
    {
      if ( byte_1023E170 == byte_1023E172 )
      {
        sub_1007C3B0(9363, (int)&v8, 1);
        sub_1007C3B0(9364, (int)&v9, 1);
        if ( (_BYTE)v8 != *(_BYTE *)(dword_1023E274 + 2) || (_BYTE)v8 == 2 && !(_BYTE)v9 )
          sub_1001FD40(v8, v9);
      }
      v7 = sub_1007C040();
      result = sub_10023190(1145, 1, a2, &word_1023E188[28 * (unsigned __int8)byte_1023E170], v7);
      ++byte_1023E170;
    }
  }
  return result;
}
// 1023E170: using guessed type char byte_1023E170;
// 1023E172: using guessed type char byte_1023E172;
// 1023E185: using guessed type char byte_1023E185;
// 1023E187: using guessed type char byte_1023E187;
// 1023E188: using guessed type __int16 word_1023E188[];
// 1023E18C: using guessed type int dword_1023E18C[];
// 1023E190: using guessed type int dword_1023E190[];
// 1023E274: using guessed type int dword_1023E274;

//----- (10020190) --------------------------------------------------------
char __cdecl sub_10020190(int a1)
{
  int v1; // edi@1
  unsigned int v2; // eax@1
  unsigned int v3; // eax@4
  unsigned __int8 v4; // al@20
  unsigned int v5; // eax@20
  int v6; // eax@20
  void *v7; // ecx@26
  int v9; // [sp+4h] [bp-4h]@26

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 8);
  if ( v2 > 0x80 )
  {
    if ( v2 > 0x400 )
    {
      if ( v2 == 2048 )
      {
        v3 = 56 * (unsigned __int8)byte_1023E172;
        byte_1023E1AE[v3] = *(_BYTE *)(a1 + 38);
        goto LABEL_23;
      }
      if ( v2 == 4096 )
      {
        v3 = 56 * (unsigned __int8)byte_1023E172;
        byte_1023E1AF[v3] = *(_BYTE *)(a1 + 39);
        goto LABEL_23;
      }
    }
    else
    {
      if ( v2 == 1024 )
      {
        v3 = 56 * (unsigned __int8)byte_1023E172;
        byte_1023E1AD[v3] = *(_BYTE *)(a1 + 37);
        goto LABEL_23;
      }
      if ( v2 == 256 )
      {
        v3 = 56 * (unsigned __int8)byte_1023E172;
        word_1023E1AA[v3 / 2] = *(_WORD *)(a1 + 34);
        goto LABEL_23;
      }
      if ( v2 == 512 )
      {
        v3 = 56 * (unsigned __int8)byte_1023E172;
        byte_1023E1AC[v3] = *(_BYTE *)(a1 + 36);
        goto LABEL_23;
      }
    }
LABEL_20:
    sub_1007C110(89, 300);
    *(_DWORD *)(80 * *(_WORD *)v1 + dword_1023E274 + 8) = *(_DWORD *)(v1 + 4);
    *(_WORD *)(80 * *(_WORD *)v1 + dword_1023E274 + 4) = *(_WORD *)v1;
    v4 = sub_1001F900(*(_WORD *)v1, *(_DWORD *)(v1 + 4));
    byte_1023E172 = v4;
    v5 = 28 * v4;
    dword_1023E18C[v5 / 2] = *(_DWORD *)(v1 + 4);
    word_1023E188[v5] = *(_WORD *)v1;
    sub_1007C0F0(89);
    LOBYTE(v6) = sub_1007C500(9386, v1, 2);
    return v6;
  }
  if ( v2 != 128 )
  {
    switch ( v2 )
    {
      case 2u:
        v3 = 56 * (unsigned __int8)byte_1023E172;
        word_1023E1A4[v3 / 2] = *(_WORD *)(a1 + 28);
        goto LABEL_23;
      case 4u:
        v3 = 56 * (unsigned __int8)byte_1023E172;
        byte_1023E199[v3] = *(_BYTE *)(a1 + 17);
        goto LABEL_23;
      case 8u:
        v3 = 56 * (unsigned __int8)byte_1023E172;
        word_1023E19C[v3 / 2] = *(_WORD *)(a1 + 20);
        goto LABEL_23;
      case 0x10u:
        v3 = 56 * (unsigned __int8)byte_1023E172;
        byte_1023E1A8[v3] = *(_BYTE *)(a1 + 32);
        goto LABEL_23;
      case 0x20u:
        v3 = 56 * (unsigned __int8)byte_1023E172;
        byte_1023E19A[v3] = *(_BYTE *)(a1 + 18);
        goto LABEL_23;
      case 0x40u:
        v3 = 56 * (unsigned __int8)byte_1023E172;
        byte_1023E1A0[v3] = *(_BYTE *)(a1 + 24);
        goto LABEL_23;
      default:
        goto LABEL_20;
    }
    goto LABEL_20;
  }
  v3 = 56 * (unsigned __int8)byte_1023E172;
  byte_1023E1A9[v3] = *(_BYTE *)(a1 + 33);
LABEL_23:
  dword_1023E190[v3 / 4] |= *(_DWORD *)(v1 + 8);
  if ( *(_DWORD *)(v1 + 8) == 4096 && !*(_BYTE *)(v1 + 39) )
    dword_1023E190[v3 / 4] = dword_1023E190[v3 / 4] & 0xFFFFEFFF | 0xFFF;
  sub_1007C3B0(9363, (int)&v9, 1);
  sub_1007C3B0(9364, (int)&a1, 1);
  sub_1001FD40(v9, a1);
  LOBYTE(v6) = sub_100460C0(v7);
  if ( (_BYTE)v6 == 4 )
  {
    LOWORD(v6) = j_HWM_pvg_hsdb_get_lrus_online();
    if ( !(v6 & 0x400) )
    {
      if ( (unsigned __int8)sub_1004EF80() )
        LOBYTE(v6) = sub_1001FF70(1145, (int)&byte_10332F00);
      else
        LOBYTE(v6) = sub_1001FF70(207, (int)&byte_10332F00);
    }
  }
  return v6;
}
// 1007C810: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 1023E172: using guessed type char byte_1023E172;
// 1023E188: using guessed type __int16 word_1023E188[];
// 1023E18C: using guessed type int dword_1023E18C[];
// 1023E190: using guessed type int dword_1023E190[];
// 1023E19C: using guessed type __int16 word_1023E19C[];
// 1023E1A4: using guessed type __int16 word_1023E1A4[];
// 1023E1AA: using guessed type __int16 word_1023E1AA[];
// 1023E274: using guessed type int dword_1023E274;
// 10332F00: using guessed type char byte_10332F00;

//----- (10020540) --------------------------------------------------------
signed int sub_10020540()
{
  char v0; // al@1
  char *v1; // eax@3
  signed int v2; // esi@5
  void *v3; // ecx@7
  char v5; // [sp+Bh] [bp-1h]@1

  byte_1023E172 = 0;
  byte_1023E185 = 0;
  byte_1023E170 = 0;
  dword_1023E274 = -15;
  dword_1023E270 = 0;
  byte_1023E187 = 2;
  byte_1023E26D = 1;
  dword_1023E288 = 0;
  v0 = sub_100473B0((bool *)&v5);
  byte_1023E26E = v5 == 0;
  if ( !v0 )
    byte_1023E26E = 0;
  memset(word_1023E188, 0, 0xE0u);
  v1 = byte_1023E199;
  do
  {
    *(_DWORD *)(v1 - 9) = 0;
    *v1 = 4;
    v1[9] = 4;
    *(_WORD *)(v1 - 17) = 4;
    *(_DWORD *)(v1 - 13) = 0;
    v1[22] = 0;
    v1 += 56;
  }
  while ( (signed int)v1 < (signed int)&dword_1023E278 + 1 );
  word_1023E28C = sub_1004F110();
  byte_1023E26F = 0;
  byte_1023E184 = sub_1004F1C0();
  dword_1023E278 = 0;
  dword_1023E294 = 0;
  byte_1023E26C = 0;
  byte_1023E186 = 0;
  byte_1023E171 = 0;
  byte_1023E173 = 0;
  word_1023E284 = 4;
  dword_1023E268 = 0;
  v2 = 0;
  do
  {
    dword_1023E174[v2] = 0;
    byte_1023E280[v2] = 6;
    byte_1023E27C[v2] = 0;
    byte_1023E290[v2] = 0;
    sub_1001FE80(v2++);
  }
  while ( v2 < 4 );
  sub_1007C3B0(6578, (int)&byte_1023E171, 1);
  sub_1001FCF0(0);
  sub_1001FA50(v3);
  return sub_1001FA90();
}
// 1023E170: using guessed type char byte_1023E170;
// 1023E171: using guessed type char byte_1023E171;
// 1023E172: using guessed type char byte_1023E172;
// 1023E173: using guessed type char byte_1023E173;
// 1023E174: using guessed type int dword_1023E174[];
// 1023E184: using guessed type char byte_1023E184;
// 1023E185: using guessed type char byte_1023E185;
// 1023E186: using guessed type char byte_1023E186;
// 1023E187: using guessed type char byte_1023E187;
// 1023E188: using guessed type __int16 word_1023E188[];
// 1023E268: using guessed type int dword_1023E268;
// 1023E26C: using guessed type char byte_1023E26C;
// 1023E26D: using guessed type char byte_1023E26D;
// 1023E26E: using guessed type char byte_1023E26E;
// 1023E26F: using guessed type char byte_1023E26F;
// 1023E270: using guessed type int dword_1023E270;
// 1023E274: using guessed type int dword_1023E274;
// 1023E278: using guessed type int dword_1023E278;
// 1023E284: using guessed type __int16 word_1023E284;
// 1023E288: using guessed type int dword_1023E288;
// 1023E28C: using guessed type __int16 word_1023E28C;
// 1023E294: using guessed type int dword_1023E294;

//----- (10020680) --------------------------------------------------------
char __cdecl sub_10020680(unsigned __int16 a1)
{
  char result; // al@1
  char v2; // bl@1
  int v3; // ebp@3
  char v4; // cl@6
  int v5; // edx@8
  char v6; // cl@11
  int v7; // edi@17
  int v8; // ecx@17
  char v9; // cl@20
  int v10; // edx@21
  int v11; // eax@26
  char v12; // cl@29

  result = sub_1001FE80(a1);
  v2 = byte_1023E186;
  if ( !byte_1023E171 || !byte_1023E26F )
    return result;
  v3 = dword_1023E274;
  if ( !byte_1023E173 )
  {
    v2 = 0;
    goto LABEL_15;
  }
  if ( byte_1023E186 )
  {
    v4 = byte_1023E280[a1];
    if ( v4 )
    {
      if ( byte_1023E26D || (v5 = dword_1023E274 + 80 * a1, *(_BYTE *)(v5 + 32) != 8) || *(_BYTE *)(v5 + 18) )
      {
        byte_1023E280[a1] = v4 - 1;
        goto LABEL_15;
      }
    }
  }
  v6 = byte_1023E290[a1];
  if ( (unsigned __int8)v6 >= 2u && v6 == byte_1023E27C[a1] )
  {
    v2 = 1;
LABEL_14:
    byte_1023E280[a1] = 6;
    goto LABEL_15;
  }
  if ( (unsigned __int8)byte_1023E27C[a1] < 2u )
    goto LABEL_14;
  if ( v6 )
    goto LABEL_14;
  v9 = byte_1023E280[a1];
  if ( !v9 )
    goto LABEL_14;
  v10 = dword_1023E274 + 80 * a1;
  if ( word_1023E284 != *(_WORD *)(v10 + 4) || dword_1023E268 != *(_DWORD *)(v10 + 8) )
    goto LABEL_14;
  byte_1023E280[a1] = v9 - 1;
LABEL_15:
  if ( byte_1023E186 )
  {
    if ( v2 )
    {
      v7 = a1;
      if ( byte_1023E280[a1] )
        goto LABEL_29;
    }
LABEL_26:
    v7 = a1;
    v11 = 80 * a1 + v3;
    if ( word_1023E284 == *(_WORD *)(v11 + 4) && dword_1023E268 == *(_DWORD *)(v11 + 8) )
    {
      word_1023E284 = 4;
      dword_1023E268 = 0;
      sub_1001FCF0(0);
      byte_1023E280[a1] = 6;
    }
    goto LABEL_29;
  }
  if ( !v2 )
    goto LABEL_26;
  v7 = a1;
  v8 = *(_DWORD *)(80 * a1 + v3 + 8);
  word_1023E284 = a1;
  dword_1023E268 = v8;
  sub_1001FCF0(1);
LABEL_29:
  result = byte_1023E290[v7];
  v12 = byte_1023E27C[v7];
  if ( result != v12 && result || v12 != 1 )
  {
    byte_1023E290[v7] = 0;
    byte_1023E27C[v7] = 0;
  }
  return result;
}
// 1023E171: using guessed type char byte_1023E171;
// 1023E173: using guessed type char byte_1023E173;
// 1023E186: using guessed type char byte_1023E186;
// 1023E268: using guessed type int dword_1023E268;
// 1023E26D: using guessed type char byte_1023E26D;
// 1023E26F: using guessed type char byte_1023E26F;
// 1023E274: using guessed type int dword_1023E274;
// 1023E284: using guessed type __int16 word_1023E284;

//----- (10020810) --------------------------------------------------------
unsigned int __usercall sub_10020810@<eax>(int a1@<edi>)
{
  int v1; // eax@1
  int v2; // ecx@1
  unsigned int result; // eax@1
  int v4; // ecx@10
  int v5; // ecx@14
  int v6; // ecx@18
  int v7; // ecx@22
  int v8; // ecx@25
  int v9; // ecx@31
  int v10; // ecx@35
  int v11; // ecx@39
  int v12; // ecx@43
  int v13; // ecx@47
  int v14; // ecx@51
  int v15; // ecx@55

  v1 = 28 * sub_1001F900(*(_WORD *)a1, *(_DWORD *)(a1 + 4));
  v2 = dword_1023E190[2 * v1 / 4u];
  result = 2 * v1;
  if ( *(_BYTE *)(a1 + 65) == 1 )
  {
    if ( v2 & 0x1000 && !(*(_DWORD *)(a1 + 40) & 0x1000) && byte_1023E1AF[result] == 1 )
      *(int *)((char *)dword_1023E190 + result) = v2 & 0xFFFFEFFF;
    return result;
  }
  if ( v2 & 1 && !(*(_BYTE *)(a1 + 40) & 1) && *(_BYTE *)(a1 + 22) == byte_1023E1A2[result] )
    *(int *)((char *)dword_1023E190 + result) = v2 & 0xFFFFFFFE;
  v4 = *(int *)((char *)dword_1023E190 + result);
  if ( v4 & 2 && !(*(_BYTE *)(a1 + 40) & 2) && *(_WORD *)(a1 + 24) == word_1023E1A4[result / 2] )
    *(int *)((char *)dword_1023E190 + result) = v4 & 0xFFFFFFFD;
  v5 = *(int *)((char *)dword_1023E190 + result);
  if ( v5 & 4 && !(*(_BYTE *)(a1 + 40) & 4) && *(_BYTE *)(a1 + 13) == byte_1023E199[result] )
    *(int *)((char *)dword_1023E190 + result) = v5 & 0xFFFFFFFB;
  v6 = *(int *)((char *)dword_1023E190 + result);
  if ( v6 & 8 && !(*(_BYTE *)(a1 + 40) & 8) && *(_WORD *)(a1 + 16) == word_1023E19C[result / 2] )
    *(int *)((char *)dword_1023E190 + result) = v6 & 0xFFFFFFF7;
  v7 = *(int *)((char *)dword_1023E190 + result);
  if ( !(*(int *)((char *)dword_1023E190 + result) & 0x10)
    || *(_BYTE *)(a1 + 40) & 0x10
    || *(_BYTE *)(a1 + 28) != byte_1023E1A8[result] )
  {
    if ( *(_BYTE *)(a1 + 65) == 1
      || *(int *)((char *)dword_1023E190 + result) & 0x10
      || *(_BYTE *)(a1 + 28) == byte_1023E1A8[result] )
    {
      goto LABEL_31;
    }
    v8 = v7 | 0x10;
  }
  else
  {
    v8 = v7 & 0xFFFFFFEF;
  }
  *(int *)((char *)dword_1023E190 + result) = v8;
LABEL_31:
  v9 = *(int *)((char *)dword_1023E190 + result);
  if ( v9 & 0x20 && !(*(_BYTE *)(a1 + 40) & 0x20) && *(_BYTE *)(a1 + 14) == byte_1023E19A[result] )
    *(int *)((char *)dword_1023E190 + result) = v9 & 0xFFFFFFDF;
  v10 = *(int *)((char *)dword_1023E190 + result);
  if ( v10 & 0x40 && !(*(_BYTE *)(a1 + 40) & 0x40) && *(_BYTE *)(a1 + 20) == byte_1023E1A0[result] )
    *(int *)((char *)dword_1023E190 + result) = v10 & 0xFFFFFFBF;
  v11 = *(int *)((char *)dword_1023E190 + result);
  if ( (char)v11 < 0 && !(*(_BYTE *)(a1 + 40) & 0x80) && *(_BYTE *)(a1 + 29) == byte_1023E1A9[result] )
    *(int *)((char *)dword_1023E190 + result) = v11 & 0xFFFFFF7F;
  v12 = *(int *)((char *)dword_1023E190 + result);
  if ( v12 & 0x100 && !(*(_DWORD *)(a1 + 40) & 0x100) && *(_WORD *)(a1 + 30) == word_1023E1AA[result / 2] )
    *(int *)((char *)dword_1023E190 + result) = v12 & 0xFFFFFEFF;
  v13 = *(int *)((char *)dword_1023E190 + result);
  if ( v13 & 0x200 && !(*(_DWORD *)(a1 + 40) & 0x200) && *(_BYTE *)(a1 + 60) == byte_1023E1AC[result] )
    *(int *)((char *)dword_1023E190 + result) = v13 & 0xFFFFFDFF;
  v14 = *(int *)((char *)dword_1023E190 + result);
  if ( v14 & 0x400 && !(*(_DWORD *)(a1 + 40) & 0x400) && *(_BYTE *)(a1 + 61) == byte_1023E1AD[result] )
    *(int *)((char *)dword_1023E190 + result) = v14 & 0xFFFFFBFF;
  v15 = *(int *)((char *)dword_1023E190 + result);
  if ( v15 & 0x800 && !(*(_DWORD *)(a1 + 40) & 0x800) && *(_BYTE *)(a1 + 63) == byte_1023E1AE[result] )
    *(int *)((char *)dword_1023E190 + result) = v15 & 0xFFFFF7FF;
  return result;
}
// 1023E190: using guessed type int dword_1023E190[];
// 1023E19C: using guessed type __int16 word_1023E19C[];
// 1023E1A4: using guessed type __int16 word_1023E1A4[];
// 1023E1AA: using guessed type __int16 word_1023E1AA[];

//----- (10020A80) --------------------------------------------------------
char __usercall sub_10020A80@<al>(unsigned __int16 a1@<ax>)
{
  int v1; // ebp@1
  unsigned __int16 v2; // si@1
  signed __int16 v3; // di@1
  int v4; // ebx@5
  int v5; // eax@5
  signed __int16 v6; // dx@7
  int v7; // ecx@19
  signed __int16 v9; // [sp+10h] [bp-4h]@1

  v1 = 0;
  v2 = a1;
  v9 = 157;
  v3 = 99;
  if ( byte_1023E184 )
  {
    v9 = 149;
    v3 = 107;
  }
  sub_1001FE80(a1);
  if ( !byte_1023E171
    || !byte_1023E173
    || (v4 = dword_1023E274, v5 = dword_1023E274 + 80 * v2, *(_BYTE *)(v5 + 32) != 8)
    || *(_BYTE *)(v5 + 18) )
  {
    v7 = dword_1023E294;
    v5 = v2;
    byte_1023E290[v5] = 0;
    byte_1023E27C[v5] = 0;
    dword_1023E174[v5] = v7;
    return v5;
  }
  ++byte_1023E27C[v2];
  v6 = v3;
  if ( (unsigned __int16)v3 > (unsigned __int16)v9 )
  {
LABEL_18:
    dword_1023E174[v2] = dword_1023E294;
    return v5;
  }
  while ( 1 )
  {
    v5 = v4 + 1052 * (257 * v2 + (unsigned __int16)v6);
    if ( !*(_BYTE *)(v5 + 324)
      || *(_DWORD *)(v5 + 328) < (unsigned int)dword_1023E174[v2]
      || *(_BYTE *)(v5 + 343) != 8
      || *(_BYTE *)(v5 + 345)
      || (LOBYTE(v5) = *(_BYTE *)(v5 + 333), (_BYTE)v5 != 3) && (_BYTE)v5 != 4 )
    {
      v1 = 0;
      goto LABEL_17;
    }
    if ( (unsigned __int16)++v1 >= 2u )
      break;
LABEL_17:
    if ( (unsigned __int16)++v6 > (unsigned __int16)v9 )
      goto LABEL_18;
  }
  v5 = dword_1023E294;
  ++byte_1023E290[v2];
  dword_1023E174[v2] = v5;
  return v5;
}
// 1023E171: using guessed type char byte_1023E171;
// 1023E173: using guessed type char byte_1023E173;
// 1023E174: using guessed type int dword_1023E174[];
// 1023E184: using guessed type char byte_1023E184;
// 1023E274: using guessed type int dword_1023E274;
// 1023E294: using guessed type int dword_1023E294;

//----- (10020BB0) --------------------------------------------------------
char __cdecl sub_10020BB0(int a1, int a2)
{
  void *v2; // ecx@0
  void *v3; // ecx@1
  __int16 v4; // ax@1
  int v5; // esi@24
  int v6; // edx@24
  int v7; // eax@24
  int v8; // ebx@28
  __int16 v9; // si@28
  int v10; // edi@28
  char v11; // al@33
  char v12; // cl@34
  char v13; // dl@36
  int *v14; // eax@39
  void *v15; // ecx@53
  signed __int16 v16; // si@60
  __int16 v17; // di@65
  int v18; // eax@70
  int v19; // esi@70
  int v20; // ecx@70
  int v21; // edi@70
  int v22; // ebx@70
  unsigned int v23; // eax@74
  __int64 v24; // rax@77
  __int16 v25; // di@78
  char v27; // [sp+Fh] [bp-901h]@33
  int v28; // [sp+10h] [bp-900h]@1
  int v29; // [sp+14h] [bp-8FCh]@1
  char v30; // [sp+18h] [bp-8F8h]@60
  char v31; // [sp+1Ch] [bp-8F4h]@70
  int v32; // [sp+20h] [bp-8F0h]@70
  unsigned int v33; // [sp+2Ch] [bp-8E4h]@74
  void *v34; // [sp+34h] [bp-8DCh]@5
  int v35; // [sp+38h] [bp-8D8h]@5
  int v36; // [sp+3Ch] [bp-8D4h]@5
  int v37; // [sp+40h] [bp-8D0h]@5
  int v38; // [sp+44h] [bp-8CCh]@5
  int v39; // [sp+48h] [bp-8C8h]@5
  int v40; // [sp+4Ch] [bp-8C4h]@5
  unsigned int v41; // [sp+50h] [bp-8C0h]@1
  int v42; // [sp+54h] [bp-8BCh]@28
  char v43; // [sp+58h] [bp-8B8h]@12
  char v44; // [sp+5Eh] [bp-8B2h]@26
  char v45; // [sp+6Ch] [bp-8A4h]@25
  char v46; // [sp+6Dh] [bp-8A3h]@24
  __int16 v47; // [sp+A0h] [bp-870h]@5
  int v48; // [sp+A4h] [bp-86Ch]@5
  void *v49; // [sp+A8h] [bp-868h]@5
  char v50; // [sp+C0h] [bp-850h]@52
  char v51; // [sp+D8h] [bp-838h]@58
  char v52; // [sp+D9h] [bp-837h]@70
  __int16 v53; // [sp+DAh] [bp-836h]@69
  __int16 v54; // [sp+DCh] [bp-834h]@70
  int v55; // [sp+E0h] [bp-830h]@70
  char v56; // [sp+E3h] [bp-82Dh]@68
  int v57; // [sp+E4h] [bp-82Ch]@65
  int v58; // [sp+E8h] [bp-828h]@70
  char v59; // [sp+ECh] [bp-824h]@77
  unsigned __int16 v60; // [sp+4F0h] [bp-420h]@58
  char v61; // [sp+4F4h] [bp-41Ch]@63

  v28 = a2;
  v29 = sub_100460A0(v2);
  memset(&v41, 0, 0x50u);
  LOBYTE(v4) = a1;
  if ( (signed int)(unsigned __int16)a1 > 209 )
  {
    if ( (unsigned __int16)a1 != 1001 )
    {
      if ( (unsigned __int16)a1 != 1291 )
        goto LABEL_83;
      goto LABEL_11;
    }
  }
  else if ( (unsigned __int16)a1 != 209 )
  {
    if ( (unsigned __int16)a1 != 206 )
    {
      LOBYTE(v4) = a1 + 49;
      if ( (unsigned __int16)a1 == 207 )
      {
        v34 = 0;
        v35 = 0;
        v36 = 0;
        v37 = 0;
        v38 = 0;
        v39 = 0;
        v40 = 0;
        memset(&v47, 0, 0x38u);
        LOBYTE(v4) = sub_10023DA0(a1, a2, &v34);
        qmemcpy(&v49, &v34, 0x1Cu);
        v3 = (void *)dword_1023E274;
        v47 = 0;
        v48 = *(_DWORD *)(dword_1023E274 + 8);
        if ( (_BYTE)v4 )
        {
          v3 = v34;
          if ( v34 )
          {
            LOBYTE(v4) = byte_1023E172;
            if ( !((unsigned int)v34 & dword_1023E190[14 * (unsigned __int8)byte_1023E172]) )
              LOBYTE(v4) = sub_10020190((int)&v47);
          }
        }
      }
      goto LABEL_83;
    }
LABEL_11:
    if ( (_WORD)a1 == 206 )
      LOBYTE(v4) = sub_10023DA0(206, a2, &v43);
    else
      LOBYTE(v4) = sub_10023DA0(a1, a2, &v41);
    if ( (_BYTE)v4 )
    {
      if ( byte_1023E26D == 1 )
        sub_1001FB30();
      sub_1007C110(89, 300);
      if ( (_WORD)a1 == 206 )
      {
        if ( *(_BYTE *)(dword_1023E274 + 1) == 1 )
        {
          if ( (unsigned int)(sub_1007C040() - dword_1023E288) > 0x7D0 )
            *(_BYTE *)(dword_1023E274 + 1) = 0;
          LOBYTE(v4) = sub_1007C0F0(89);
          return v4;
        }
      }
      else if ( (_WORD)a1 == 1291 )
      {
        dword_1023E288 = sub_1007C040();
        *(_BYTE *)(dword_1023E274 + 1) = 1;
      }
      sub_10043370(179);
      *(_BYTE *)dword_1023E274 = 0;
      v5 = (unsigned __int16)v41;
      v6 = 80 * (unsigned __int16)v41;
      v7 = v6 + dword_1023E274;
      LOBYTE(v6) = *(_BYTE *)(v6 + dword_1023E274 + 33);
      byte_1023E26D = 0;
      if ( (_BYTE)v6 != v46 || *(_BYTE *)(v7 + 32) != v45 || *(_BYTE *)(v7 + 18) != v44 )
        sub_1001FB40(0, (int)&v43, v41);
      v8 = 80 * v5;
      qmemcpy((void *)(80 * v5 + dword_1023E274 + 4), &v41, 0x50u);
      v9 = v41;
      v10 = dword_1023E274;
      if ( *(_DWORD *)(v8 + v10 + 8) != dword_1023E18C[14 * sub_1001F900(v41, v42)] )
        *(_DWORD *)(v8 + v10 + 8) = dword_1023E18C[14 * sub_1001F900(v9, v42)];
      sub_1007C0F0(89);
      if ( byte_1023E187 == 1 )
        sub_10043480(0xB4u);
      else
        sub_10043370(180);
      v11 = sub_100473B0((bool *)&v27);
      if ( v11 )
      {
        v12 = v27;
      }
      else
      {
        v12 = 1;
        v27 = 1;
      }
      v13 = v45;
      if ( v45 != 9 && byte_1023E26E )
      {
        if ( v12 )
        {
          v14 = dword_1023E190;
          do
          {
            *v14 |= 0x10u;
            *((_BYTE *)v14 + 24) = 6;
            v14 += 14;
          }
          while ( (signed int)v14 < (signed int)&dword_1023E270 );
          byte_1023E26E = 0;
          goto LABEL_46;
        }
      }
      else if ( v12 )
      {
        byte_1023E26E = 0;
LABEL_46:
        if ( v13 != 9 && v13 != 6 && v13 != 7 && sub_100429F0(3) && v29 & 1 && v29 & 4 )
        {
          v50 = 6;
          v49 = (void *)16;
          v48 = *(_DWORD *)(v8 + dword_1023E274 + 8);
          v47 = *(_WORD *)(v8 + dword_1023E274 + 4);
          sub_10020190((int)&v47);
        }
        sub_10020810((int)&v41);
        LOBYTE(v4) = sub_100460C0(v15);
        if ( (_BYTE)v4 == 4 )
        {
          v4 = j_HWM_pvg_hsdb_get_lrus_online();
          if ( !(v4 & 0x400) )
          {
            if ( (unsigned __int8)sub_1004EF80() )
              LOBYTE(v4) = sub_1001FF70(1145, v28);
            else
              LOBYTE(v4) = sub_1001FF70(207, v28);
          }
        }
        goto LABEL_83;
      }
      if ( v11 )
        byte_1023E26E = 1;
      goto LABEL_46;
    }
LABEL_83:
    if ( !byte_1023E26F )
    {
      LOBYTE(v4) = sub_100474F0(v3);
      if ( (_BYTE)v4 )
        LOBYTE(v4) = sub_1001F7F0();
    }
    return v4;
  }
  memset(&v51, 0, 0x414u);
  LOBYTE(v4) = (unsigned int)memset(&v60, 0, 0x414u);
  if ( (_WORD)a1 == 209 )
  {
    if ( *(_BYTE *)(dword_1023E274 + 1) )
      goto LABEL_83;
    LOBYTE(v4) = sub_10023DC0(209, a2, &v51, (unsigned __int16 *)&v30);
    v28 = 0;
    v16 = 20;
  }
  else
  {
    if ( (_WORD)a1 != 1001 || *(_BYTE *)(dword_1023E274 + 1) != 1 )
      goto LABEL_83;
    LOBYTE(v4) = sub_10023DC0(1001, a2, &v60, (unsigned __int16 *)&v30);
    qmemcpy(&v51, &v61, 0x414u);
    v3 = 0;
    v28 = v60;
    v16 = 24;
  }
  if ( !(_BYTE)v4 )
    goto LABEL_83;
  v4 = sub_1001F960(SHIWORD(v57), SBYTE1(v57));
  v17 = v4;
  if ( (BYTE1(v57) != 1 || (unsigned __int16)v4 < 0xA7u) && (unsigned __int16)v4 < 0x101u )
  {
    if ( v56 == 4 || (LOBYTE(v4) = v53, v53 == word_1023E28C) )
    {
      sub_10024D10(1, a1, (int)&v31);
      v29 = (unsigned __int16)(v32 - v16);
      sub_1007C110(89, 300);
      v18 = (unsigned __int16)v28;
      v19 = 1052 * ((unsigned __int16)v17 + 257 * (unsigned __int16)v28);
      *(_BYTE *)(v19 + dword_1023E274 + 333) = v52;
      *(_WORD *)(v19 + dword_1023E274 + 334) = v53;
      *(_WORD *)(v19 + dword_1023E274 + 336) = v54;
      v20 = v19 + dword_1023E274 + 340;
      *(_DWORD *)v20 = v55;
      *(_DWORD *)(v20 + 4) = v57;
      *(_DWORD *)(v20 + 8) = v58;
      v21 = 80 * v18;
      *(_BYTE *)(v21 + dword_1023E274 + 16) = v57;
      *(_BYTE *)(v21 + dword_1023E274 + 25) = v57;
      v22 = dword_1023E274;
      if ( *(_BYTE *)(80 * v18 + dword_1023E274 + 33) != BYTE2(v55)
        || *(_BYTE *)(v21 + dword_1023E274 + 32) != v56
        || *(_BYTE *)(v21 + dword_1023E274 + 18) != BYTE1(v57) )
      {
        sub_1001FB40((int)&v51, 0, v28);
        v22 = dword_1023E274;
        sub_10020810(v21 + dword_1023E274 + 4);
      }
      v23 = dword_1023E294;
      *(_DWORD *)(v19 + v22 + 328) = v33;
      if ( v33 <= v23 )
        *(_DWORD *)(v19 + dword_1023E274 + 328) = v23 + 1;
      dword_1023E294 = *(_DWORD *)(v19 + dword_1023E274 + 328);
      if ( v51 == 2 )
      {
        *(_BYTE *)(v19 + dword_1023E274 + 324) = sub_1001FC00(
                                                   v19 + dword_1023E274 + 352,
                                                   (int)&v59,
                                                   *(_WORD *)(v19 + dword_1023E274 + 334),
                                                   v29) == 0;
        *(_BYTE *)(v19 + dword_1023E274 + 332) = 0;
        v24 = *(_WORD *)(v19 + dword_1023E274 + 334) + 1;
        *(_WORD *)(v19 + dword_1023E274 + 326) = ((signed int)v24 - HIDWORD(v24)) >> 1;
      }
      else
      {
        v25 = v29;
        memcpy((void *)(v19 + dword_1023E274 + 352), &v59, (unsigned __int16)v29);
        *(_BYTE *)(v19 + dword_1023E274 + 324) = 1;
        *(_BYTE *)(v19 + dword_1023E274 + 332) = v51;
        *(_WORD *)(v19 + dword_1023E274 + 326) = v25;
      }
      if ( (_BYTE)v57 != byte_1023E26C )
      {
        sub_10020A80(v28);
        byte_1023E26C = v57;
      }
      LOBYTE(v4) = sub_1007C0F0(89);
      if ( dword_1023E270 )
        LOBYTE(v4) = sub_1001FF30(v32, (int)&v51);
      goto LABEL_83;
    }
  }
  return v4;
}
// 1001FB30: using guessed type int sub_1001FB30(void);
// 1007C810: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 1023E172: using guessed type char byte_1023E172;
// 1023E187: using guessed type char byte_1023E187;
// 1023E18C: using guessed type int dword_1023E18C[];
// 1023E190: using guessed type int dword_1023E190[];
// 1023E26C: using guessed type char byte_1023E26C;
// 1023E26D: using guessed type char byte_1023E26D;
// 1023E26E: using guessed type char byte_1023E26E;
// 1023E26F: using guessed type char byte_1023E26F;
// 1023E270: using guessed type int dword_1023E270;
// 1023E274: using guessed type int dword_1023E274;
// 1023E288: using guessed type int dword_1023E288;
// 1023E28C: using guessed type __int16 word_1023E28C;
// 1023E294: using guessed type int dword_1023E294;

//----- (10021370) --------------------------------------------------------
char __cdecl sub_10021370(_BYTE *a1)
{
  char result; // al@3
  char v2; // [sp+4h] [bp-38h]@1
  char v3; // [sp+28h] [bp-14h]@3

  if ( !sub_100253C0(1, 206, &v2) || sub_1004D880((int)&v2) )
  {
    result = 0;
  }
  else
  {
    *a1 = v3;
    result = 1;
  }
  return result;
}

//----- (100213E0) --------------------------------------------------------
char __cdecl sub_100213E0(int a1, int a2, int a3, int a4, char a5, char *a6)
{
  int v6; // eax@1
  char result; // al@2

  v6 = sub_10043FF0(&a5, 1u, (int)&unk_100ABDF0, 101, 10, 10);
  if ( v6 == 10 )
  {
    result = 0;
  }
  else
  {
    strncpy(a6, &byte_100ABDF1[101 * v6], 0x64u);
    result = 1;
  }
  return result;
}

//----- (10021430) --------------------------------------------------------
char sub_10021430()
{
  return byte_1023E299;
}
// 1023E299: using guessed type char byte_1023E299;

//----- (10021440) --------------------------------------------------------
char sub_10021440()
{
  if ( (unsigned int)(sub_1007C040() - dword_1023E29C) > 0x1F4 )
    sub_10018810((unsigned __int8)byte_1023E298);
  return 1;
}
// 1023E298: using guessed type char byte_1023E298;
// 1023E29C: using guessed type int dword_1023E29C;

//----- (10021470) --------------------------------------------------------
char __cdecl sub_10021470(char a1)
{
  char result; // al@1

  result = a1;
  if ( a1 == 4 )
    result = 1;
  byte_1023E299 = result;
  return result;
}
// 1023E299: using guessed type char byte_1023E299;

//----- (10021480) --------------------------------------------------------
int __thiscall sub_10021480(int this)
{
  signed int v1; // eax@1
  signed int v2; // eax@5
  signed int v3; // eax@11
  signed int v4; // eax@15
  signed int v5; // eax@19
  signed int v6; // eax@23
  signed int v7; // eax@27
  signed int v8; // eax@31
  signed int v9; // eax@33
  signed int v10; // eax@35
  signed int v11; // esi@37
  _BYTE *v12; // ecx@37
  signed int v13; // eax@38
  int v14; // edx@40
  bool v15; // zf@40
  int v16; // eax@40
  int result; // eax@40

  v1 = *(_BYTE *)(this + 1);
  if ( v1 >= 3 )
    LOBYTE(v1) = 3;
  *(_BYTE *)(this + 1) = v1;
  if ( (signed int)(unsigned __int8)v1 <= 1 )
    LOBYTE(v1) = 1;
  *(_BYTE *)(this + 1) = v1;
  v2 = *(_BYTE *)(this + 50);
  if ( v2 >= 2 )
    LOBYTE(v2) = 2;
  *(_BYTE *)(this + 50) = (signed int)(unsigned __int8)v2 <= 0 ? 0 : v2;
  if ( (COERCE_UNSIGNED_INT(*(float *)(this + 52)) & 0x7F800000) == 2139095040
    || *(float *)(this + 52) > 9.9999996e24
    || *(float *)(this + 52) < 0.0 )
  {
    *(float *)(this + 52) = 9.9999996e24;
  }
  v3 = *(_DWORD *)(this + 36);
  if ( v3 >= 5 )
    v3 = 5;
  *(_DWORD *)(this + 36) = v3;
  if ( v3 <= -1 )
    v3 = -1;
  *(_DWORD *)(this + 36) = v3;
  v4 = *(_DWORD *)(this + 40);
  if ( v4 >= 5 )
    v4 = 5;
  *(_DWORD *)(this + 40) = v4;
  if ( v4 <= -1 )
    v4 = -1;
  *(_DWORD *)(this + 40) = v4;
  v5 = *(_DWORD *)(this + 28);
  if ( v5 >= 5 )
    v5 = 5;
  *(_DWORD *)(this + 28) = v5;
  if ( v5 <= -1 )
    v5 = -1;
  *(_DWORD *)(this + 28) = v5;
  v6 = *(_DWORD *)(this + 32);
  if ( v6 >= 5 )
    v6 = 5;
  *(_DWORD *)(this + 32) = v6;
  if ( v6 <= -1 )
    v6 = -1;
  *(_DWORD *)(this + 32) = v6;
  v7 = *(_BYTE *)this;
  if ( v7 >= 127 )
    LOBYTE(v7) = 127;
  *(_BYTE *)this = v7;
  if ( (char)v7 <= -128 )
    LOBYTE(v7) = -128;
  *(_BYTE *)this = v7;
  v8 = *(_BYTE *)(this + 56);
  if ( v8 >= 1 )
    LOBYTE(v8) = 1;
  *(_BYTE *)(this + 56) = (signed int)(unsigned __int8)v8 <= 0 ? 0 : v8;
  v9 = *(_BYTE *)(this + 57);
  if ( v9 >= 120 )
    LOBYTE(v9) = 120;
  *(_BYTE *)(this + 57) = (signed int)(unsigned __int8)v9 <= 0 ? 0 : v9;
  v10 = *(_BYTE *)(this + 58);
  if ( v10 >= 120 )
    LOBYTE(v10) = 120;
  v11 = 6;
  *(_BYTE *)(this + 58) = (signed int)(unsigned __int8)v10 <= 0 ? 0 : v10;
  v12 = (_BYTE *)(this + 44);
  do
  {
    v13 = *v12;
    if ( v13 >= 1 )
      LOBYTE(v13) = 1;
    v14 = (unsigned __int8)v13;
    v15 = (unsigned __int8)v13 == 0;
    v16 = (signed int)(unsigned __int8)v13 < 0;
    LOBYTE(v16) = v16 | v15;
    ++v12;
    result = v14 & (v16 - 1);
    --v11;
    *(v12 - 1) = result;
  }
  while ( v11 );
  return result;
}

//----- (10021620) --------------------------------------------------------
char __cdecl sub_10021620(void *a1, int a2)
{
  void *v2; // ecx@0
  int v3; // eax@1

  LOWORD(v3) = sub_100460A0(v2);
  if ( v3 & 0x400 )
    LOBYTE(v3) = sub_10024E60(1, 292, a1, 0, 4, a2);
  return v3;
}

//----- (10021650) --------------------------------------------------------
int __usercall sub_10021650@<eax>(int result@<eax>, char a2)
{
  if ( a2 == 19 )
    result = sub_1007C580(6200, result, 60);
  return result;
}

//----- (10021670) --------------------------------------------------------
char __usercall sub_10021670@<al>(int a1@<ecx>, char a2@<dl>, int a3@<eax>, int a4@<esi>, void *a5)
{
  sub_10024E60(1, a4, a5, a2, a1, a3);
  return sub_10025010(1, a4, 1024);
}

//----- (100216A0) --------------------------------------------------------
char __cdecl sub_100216A0(int a1)
{
  char v1; // bl@1
  unsigned int v2; // eax@5
  char *v3; // ecx@5
  char *v4; // edx@5
  int v5; // esi@9
  int v6; // eax@10
  _BYTE *v7; // ecx@10
  _BYTE *v8; // edx@10
  int v9; // eax@12
  _BYTE *v10; // ecx@12
  _BYTE *v11; // edx@12
  _BYTE *v12; // ecx@14
  _BYTE *v13; // edx@14
  signed int v14; // eax@16
  char v16; // [sp+4h] [bp-40h]@1
  char v17; // [sp+5h] [bp-3Fh]@4
  int v18; // [sp+Ch] [bp-38h]@2
  int v19; // [sp+10h] [bp-34h]@2
  int v20; // [sp+14h] [bp-30h]@2
  int v21; // [sp+18h] [bp-2Ch]@2
  int v22; // [sp+1Ch] [bp-28h]@2
  int v23; // [sp+20h] [bp-24h]@4
  int v24; // [sp+24h] [bp-20h]@4
  int v25; // [sp+28h] [bp-1Ch]@4
  int v26; // [sp+2Ch] [bp-18h]@4
  int v27; // [sp+30h] [bp-14h]@4
  __int16 v28; // [sp+34h] [bp-10h]@4
  char v29; // [sp+36h] [bp-Eh]@4
  char v30; // [sp+37h] [bp-Dh]@4
  float v31; // [sp+38h] [bp-Ch]@4
  char v32; // [sp+3Ch] [bp-8h]@4
  __int16 v33; // [sp+3Dh] [bp-7h]@4
  char v34; // [sp+3Fh] [bp-5h]@4

  memset(&v16, 0, 0x3Cu);
  v1 = sub_1004F000(a1, &v16);
  if ( v1 != 1 )
    goto LABEL_21;
  dword_1023E2A8 = v18;
  dword_1023E2AC = v19;
  dword_1023E2B0 = v20;
  dword_1023E2B4 = v21;
  dword_1023E2B8 = v22;
  if ( (unsigned __int8)sub_1004EF80() )
  {
    sub_10021480((int)&byte_1023E2A0);
  }
  else
  {
    flt_1023E2D4 = v31;
    dword_1023E2C8 = v26;
    dword_1023E2C4 = v25;
    byte_1023E2A1 = v17;
    dword_1023E2BC = v23;
    dword_1023E2C0 = v24;
    byte_1023E2A0 = v16;
    byte_1023E2D2 = v29;
    byte_1023E2D3 = v30;
    byte_1023E2D8 = v32;
    word_1023E2D9 = v33;
    dword_1023E2CC = v27;
    word_1023E2D0 = v28;
    byte_1023E2DB = v34;
  }
  v2 = 60;
  v3 = &byte_1023E2A0;
  v4 = &v16;
  do
  {
    if ( *(_DWORD *)v4 != *(_DWORD *)v3 )
      goto LABEL_9;
    v2 -= 4;
    v3 += 4;
    v4 += 4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_18:
    v14 = 0;
    goto LABEL_19;
  }
LABEL_9:
  v5 = (unsigned __int8)*v4 - (unsigned __int8)*v3;
  if ( (unsigned __int8)*v4 == (unsigned __int8)*v3 )
  {
    v6 = v2 - 1;
    v7 = v3 + 1;
    v8 = v4 + 1;
    if ( !v6 )
      goto LABEL_18;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_18;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_18;
        v5 = *v13 - *v12;
        if ( *v13 == *v12 )
          goto LABEL_18;
      }
    }
  }
  v14 = 1;
  if ( v5 <= 0 )
    v14 = -1;
LABEL_19:
  if ( !v14 )
  {
    sub_10018810(10);
    return v1;
  }
  v1 = 0;
LABEL_21:
  sub_10018720();
  if ( (unsigned int)sub_10018700() <= 0xA )
    sub_10018810(1);
  else
    sub_10018810(8);
  return v1;
}
// 1023E2A0: using guessed type char byte_1023E2A0;
// 1023E2A1: using guessed type char byte_1023E2A1;
// 1023E2A8: using guessed type int dword_1023E2A8;
// 1023E2AC: using guessed type int dword_1023E2AC;
// 1023E2B0: using guessed type int dword_1023E2B0;
// 1023E2B4: using guessed type int dword_1023E2B4;
// 1023E2B8: using guessed type int dword_1023E2B8;
// 1023E2BC: using guessed type int dword_1023E2BC;
// 1023E2C0: using guessed type int dword_1023E2C0;
// 1023E2C4: using guessed type int dword_1023E2C4;
// 1023E2C8: using guessed type int dword_1023E2C8;
// 1023E2CC: using guessed type int dword_1023E2CC;
// 1023E2D0: using guessed type __int16 word_1023E2D0;
// 1023E2D2: using guessed type char byte_1023E2D2;
// 1023E2D3: using guessed type char byte_1023E2D3;
// 1023E2D4: using guessed type float flt_1023E2D4;
// 1023E2D8: using guessed type char byte_1023E2D8;
// 1023E2D9: using guessed type __int16 word_1023E2D9;
// 1023E2DB: using guessed type char byte_1023E2DB;

//----- (10021890) --------------------------------------------------------
char sub_10021890()
{
  void *v0; // ecx@1
  char v1; // al@1

  byte_1023E298 = 0;
  dword_1023E29C = 0;
  memset(&byte_1023E2A0, 0, 0x3Cu);
  v1 = sub_100460C0(v0);
  return sub_10021470(v1);
}
// 1023E298: using guessed type char byte_1023E298;
// 1023E29C: using guessed type int dword_1023E29C;
// 1023E2A0: using guessed type char byte_1023E2A0;

//----- (100218C0) --------------------------------------------------------
char __cdecl sub_100218C0(signed int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  void *v3; // ecx@6

  LOBYTE(v2) = a1;
  switch ( (unsigned __int8)a1 )
  {
    case 1u:
      a1 = 2;
      goto LABEL_6;
    case 2u:
      a1 = 3;
      goto LABEL_6;
    case 8u:
      a1 = 4;
      goto LABEL_6;
    case 0x10u:
      a1 = 5;
LABEL_6:
      v2 = sub_100429D0(v1);
      if ( v2 == 1 || (v2 = sub_100460A0(v3), !(v2 & 1)) )
      {
        LOBYTE(v2) = 1;
        LOBYTE(v2) = sub_10021670(4, 0, v2, 208, &a1);
      }
      break;
    default:
      return v2;
  }
  return v2;
}

//----- (10021960) --------------------------------------------------------
char __thiscall sub_10021960(void *this)
{
  char v1; // bl@1
  int *v2; // eax@5
  int v4; // [sp+4h] [bp-Ch]@1
  int v5; // [sp+8h] [bp-8h]@1

  v1 = (char)this;
  v4 = 0;
  v5 = sub_100429D0(this);
  if ( v1 == 11 )
  {
    LOWORD(v4) = 292;
    goto LABEL_5;
  }
  if ( v1 == 17 )
  {
    LOWORD(v4) = 293;
LABEL_5:
    v2 = &v4;
    LOBYTE(v2) = 1;
    sub_10021670(8, 0, (int)v2, 0, &v4);
    return 1;
  }
  return 0;
}

//----- (100219E0) --------------------------------------------------------
char __usercall sub_100219E0@<al>(int a1@<ebx>)
{
  int v1; // eax@1
  char v3; // [sp+8h] [bp-44h]@1
  char v4; // [sp+Ch] [bp-40h]@1

  memset(&v3, 0, 0x40u);
  sub_10021620(&v4, 0);
  qmemcpy(&byte_1023E2A0, (const void *)(a1 + 4), 0x3Cu);
  qmemcpy(&v3, (const void *)a1, 0x40u);
  LOBYTE(v1) = 1;
  return sub_10021670(64, 0, v1, 294, &v3);
}
// 1023E2A0: using guessed type char byte_1023E2A0;

//----- (10021A70) --------------------------------------------------------
char __cdecl sub_10021A70(int a1, char a2)
{
  void *v2; // ecx@1
  char result; // al@5
  char v4; // bl@9
  char v5; // [sp+0h] [bp-40h]@1

  memset(&v5, 0, 0x3Cu);
  LOBYTE(v2) = a2;
  sub_10021960(v2);
  if ( sub_10018710() == 2 )
  {
    if ( j_HWM_pvg_read_reg(1) == 1 && !(j_HWM_pvg_hsdb_get_lrus_online() & 0x400) )
    {
      sub_1004F0F0(a1, (int)&v5);
      sub_10021620(&v5, 1);
    }
    sub_10018810(7);
    result = 1;
  }
  else
  {
    if ( j_HWM_pvg_read_reg(1) == 1 && !(j_HWM_pvg_hsdb_get_lrus_online() & 0x400) )
      sub_10021620(&byte_1023E2A0, 1);
    v4 = sub_1004F000(a1, &v5);
    if ( v4 == 1 )
    {
      if ( sub_10018710() != 5 || sub_100186F0() != 1 )
      {
        sub_10018810(3);
        result = 1;
      }
      else
      {
        sub_10018810(10);
        result = 1;
      }
    }
    else
    {
      sub_10018720();
      if ( (unsigned int)sub_10018700() <= 0xA )
      {
        sub_10018810(4);
        byte_1023E298 = 2;
        dword_1023E29C = sub_1007C040();
        result = v4;
      }
      else
      {
        sub_10018810(8);
        result = v4;
      }
    }
  }
  return result;
}
// 1007C810: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1023E298: using guessed type char byte_1023E298;
// 1023E29C: using guessed type int dword_1023E29C;
// 1023E2A0: using guessed type char byte_1023E2A0;

//----- (10021BE0) --------------------------------------------------------
char __cdecl sub_10021BE0(char a1, int a2, int a3, int a4, int a5, int a6)
{
  char v6; // bl@1
  char *v7; // ebx@6
  char v9; // [sp+8h] [bp-80h]@1
  char v10; // [sp+Ch] [bp-7Ch]@3
  char v11; // [sp+Dh] [bp-7Bh]@7
  int v12; // [sp+14h] [bp-74h]@5
  int v13; // [sp+18h] [bp-70h]@5
  int v14; // [sp+1Ch] [bp-6Ch]@5
  int v15; // [sp+20h] [bp-68h]@5
  int v16; // [sp+24h] [bp-64h]@5
  int v17; // [sp+28h] [bp-60h]@5
  int v18; // [sp+2Ch] [bp-5Ch]@5
  int v19; // [sp+30h] [bp-58h]@5
  int v20; // [sp+34h] [bp-54h]@5
  int v21; // [sp+38h] [bp-50h]@5
  __int16 v22; // [sp+3Ch] [bp-4Ch]@5
  char v23; // [sp+3Eh] [bp-4Ah]@7
  char v24; // [sp+3Fh] [bp-49h]@7
  float v25; // [sp+40h] [bp-48h]@7
  char v26; // [sp+44h] [bp-44h]@7
  char v27; // [sp+45h] [bp-43h]@7
  char v28; // [sp+46h] [bp-42h]@7
  char v29; // [sp+47h] [bp-41h]@5
  char v30; // [sp+48h] [bp-40h]@4
  char v31; // [sp+49h] [bp-3Fh]@7
  int v32; // [sp+50h] [bp-38h]@5
  int v33; // [sp+54h] [bp-34h]@5
  int v34; // [sp+58h] [bp-30h]@5
  int v35; // [sp+5Ch] [bp-2Ch]@5
  int v36; // [sp+60h] [bp-28h]@5
  int v37; // [sp+64h] [bp-24h]@5
  int v38; // [sp+68h] [bp-20h]@5
  int v39; // [sp+6Ch] [bp-1Ch]@5
  int v40; // [sp+70h] [bp-18h]@5
  int v41; // [sp+74h] [bp-14h]@5
  __int16 v42; // [sp+78h] [bp-10h]@5
  char v43; // [sp+7Ah] [bp-Eh]@7
  char v44; // [sp+7Bh] [bp-Dh]@7
  float v45; // [sp+7Ch] [bp-Ch]@7
  char v46; // [sp+80h] [bp-8h]@7
  char v47; // [sp+81h] [bp-7h]@7
  char v48; // [sp+82h] [bp-6h]@7
  char v49; // [sp+83h] [bp-5h]@5

  memset(&v9, 0, 0x40u);
  v6 = 0;
  if ( a1 != 19 )
    goto LABEL_19;
  if ( a6 )
  {
    if ( (unsigned __int8)sub_1004EF80() )
      sub_10021480(a5 + 4);
    qmemcpy(&byte_1023E2A0, (const void *)(a5 + 4), 0x3Cu);
    if ( *(_BYTE *)a5 )
    {
      sub_10021470(2);
      sub_100218C0(2);
    }
    v7 = (char *)a5;
    goto LABEL_14;
  }
  if ( !(unsigned __int8)sub_1004F0F0(19, (int)&v10) )
  {
LABEL_19:
    sub_10018810(8);
    return v6;
  }
  v9 = 1;
  if ( !sub_1004F000(19, &v30) )
    goto LABEL_8;
  v12 = v32;
  v13 = v33;
  v14 = v34;
  v15 = v35;
  v16 = v36;
  v19 = v39;
  v20 = v40;
  v17 = v37;
  v18 = v38;
  v21 = v41;
  v22 = v42;
  v29 = v49;
  if ( !(unsigned __int8)sub_1004EF80() )
  {
    v25 = v45;
    v11 = v31;
    v23 = v43;
    v24 = v44;
    v10 = v30;
    v26 = v46;
    v27 = v47;
    v28 = v48;
LABEL_8:
    v7 = &v9;
    goto LABEL_14;
  }
  sub_10021480((int)&v10);
  v7 = &v9;
LABEL_14:
  sub_100219E0((int)v7);
  v6 = 1;
  sub_10018810(4);
  byte_1023E298 = 2;
  dword_1023E29C = sub_1007C040();
  return v6;
}
// 1023E298: using guessed type char byte_1023E298;
// 1023E29C: using guessed type int dword_1023E29C;
// 1023E2A0: using guessed type char byte_1023E2A0;

//----- (10021DC0) --------------------------------------------------------
char __cdecl sub_10021DC0(int a1, char a2)
{
  void *v2; // ecx@6
  void *v3; // ecx@6
  char v4; // al@6
  char v6; // [sp+8h] [bp-40h]@1

  memset(&v6, 0, 0x3Cu);
  if ( !a2 )
  {
    sub_10021650((int)&byte_1023E2A0, a1);
LABEL_6:
    sub_10018810(7);
    LOBYTE(v2) = 17;
    sub_10021960(v2);
    v4 = sub_100460C0(v3);
    sub_10021470(v4);
    sub_100218C0((unsigned __int8)byte_1023E299);
    return 1;
  }
  if ( (unsigned __int8)sub_1004F0F0(a1, (int)&v6) && sub_1004F000(a1, &v6) )
  {
    qmemcpy(&byte_1023E2A0, &v6, 0x3Cu);
    sub_10021650((int)&v6, a1);
    goto LABEL_6;
  }
  sub_10018810(8);
  return 0;
}
// 1023E299: using guessed type char byte_1023E299;
// 1023E2A0: using guessed type char byte_1023E2A0;

//----- (10021EB0) --------------------------------------------------------
char sub_10021EB0()
{
  bool v0; // zf@1
  void *v1; // ecx@1
  signed int v2; // eax@1
  char v3; // bl@2
  char v4; // al@5
  void *v5; // ecx@8
  char v7; // [sp+7h] [bp-1h]@1

  v0 = sub_10021370(&v7) == 1;
  LOBYTE(v2) = byte_1023E299;
  if ( v0 )
    v3 = v7;
  else
    v3 = byte_1023E299 == 0;
  if ( !byte_1023E299 )
  {
    v4 = sub_100460C0(v1);
    sub_10021470(v4);
    v2 = (unsigned __int8)byte_1023E299;
  }
  if ( (_BYTE)v2 != v3 )
    sub_100218C0(v2);
  LOBYTE(v1) = 17;
  sub_10021960(v1);
  LOBYTE(v5) = 11;
  return sub_10021960(v5);
}
// 1023E299: using guessed type char byte_1023E299;

//----- (10021F10) --------------------------------------------------------
char __cdecl sub_10021F10(signed int a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  char v3; // al@1
  int v4; // esi@1
  char v6; // [sp+Bh] [bp-1h]@1

  v2 = 0;
  v6 = 0;
  v3 = sub_100460C0(v1);
  sub_10021470(v3);
  v4 = a1;
  if ( (a1 & j_HWM_pvg_hsdb_get_lrus_online()) == a1 )
  {
    LOBYTE(a1) = sub_10021430();
    if ( sub_10021370(&v6) == 1 )
    {
      if ( v6 != (_BYTE)a1 )
      {
        sub_10021470(a1);
        sub_100218C0(a1);
        sub_10024090(v4);
        return 0;
      }
      v2 = 1;
    }
  }
  sub_10024090(v4);
  return v2;
}
// 1007C810: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (10021F90) --------------------------------------------------------
char __cdecl sub_10021F90(int a1)
{
  char result; // al@4
  char v2; // [sp+Bh] [bp-1h]@1

  v2 = 0;
  sub_10023FD0(a1);
  if ( (a1 & j_HWM_pvg_hsdb_get_lrus_online()) == a1 )
  {
    if ( (unsigned __int8)sub_1004EF80() )
      sub_10026240(0x1F0u);
    sub_10021470(16);
    result = sub_10021370(&v2);
    if ( result == 1 )
    {
      if ( v2 == 16 )
        return result;
      sub_100218C0(16);
    }
  }
  return 0;
}
// 1007C810: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (10022000) --------------------------------------------------------
signed __int16 __usercall sub_10022000@<ax>(int a1@<eax>, int a2@<ecx>)
{
  signed __int16 result; // ax@2

  a1 = (unsigned __int16)a1;
  if ( (signed int)(unsigned __int16)a1 >= *(_DWORD *)(a2 + 4) )
    result = -1;
  else
    result = *(_WORD *)(*(_DWORD *)(a2 + 40) + 2 * a1);
  return result;
}

//----- (10022020) --------------------------------------------------------
int __usercall sub_10022020@<eax>(int a1@<esi>, signed int a2)
{
  int v2; // edx@1
  char v3; // cl@1
  int v4; // ebp@1
  signed int v5; // edx@1
  int v6; // eax@1
  int v7; // edi@2
  int v8; // ecx@3
  bool v9; // zf@3
  int v10; // edi@5
  signed int v11; // ebx@5
  int v12; // ebp@8
  int v13; // edx@9
  int v14; // eax@11
  __int16 v15; // cx@11
  char v16; // dl@11
  int v17; // edx@11
  int v18; // eax@11
  int v19; // ecx@11
  unsigned int v20; // eax@15
  int v21; // ecx@15
  char v23; // [sp+7h] [bp-29h]@5
  int v24; // [sp+8h] [bp-28h]@1
  int v25; // [sp+Ch] [bp-24h]@1
  int v26; // [sp+10h] [bp-20h]@8
  int v27; // [sp+14h] [bp-1Ch]@3
  int v28; // [sp+18h] [bp-18h]@3
  int v29; // [sp+1Ch] [bp-14h]@1
  char v30; // [sp+20h] [bp-10h]@1
  char v31; // [sp+21h] [bp-Fh]@1
  __int16 v32; // [sp+22h] [bp-Eh]@16
  int v33; // [sp+24h] [bp-Ch]@11
  int v34; // [sp+28h] [bp-8h]@11

  v2 = *(_DWORD *)(a1 + 60);
  v3 = *(_BYTE *)(a1 + 1);
  v4 = ~*(_DWORD *)(a1 + 72);
  v29 = *(_DWORD *)(a1 + 16);
  v30 = v3;
  v31 = 1;
  v25 = v4;
  sub_1007C110(v2, -1);
  v5 = a2;
  v6 = 0;
  v24 = 0;
  if ( a2 > 0 )
  {
    do
    {
      v7 = *(_DWORD *)(a1 + 48);
      if ( *(_BYTE *)(v7 + 20 * v6) != 1 )
      {
        v8 = v4 & (*(_DWORD *)(v7 + 20 * v6 + 12) | 0xC00000);
        v9 = *(_BYTE *)(a1 + 1) == 6;
        v27 = v4 & (*(_DWORD *)(v7 + 20 * v6 + 12) | 0xC00000);
        v28 = v4 & (*(_DWORD *)(v7 + 20 * v6 + 12) | 0xC00000);
        if ( v9 || !(v8 & *(_DWORD *)(a1 + 84)) )
        {
          v23 = 1;
          v10 = *(_DWORD *)(a1 + 16) + 12;
          v11 = 12;
        }
        else
        {
          v10 = *(_DWORD *)(a1 + 16);
          v23 = 0;
          v11 = 0;
        }
        if ( v6 < v5 )
        {
          v12 = 20 * v6;
          v26 = v5 - v6;
          do
          {
            v13 = *(_DWORD *)(a1 + 48);
            if ( !*(_BYTE *)(v13 + v12) && v8 == (v25 & (*(_DWORD *)(v13 + v12 + 12) | 0xC00000)) )
            {
              v14 = v13 + v12;
              v15 = *(_WORD *)(v13 + v12 + 6);
              LOWORD(v33) = *(_WORD *)(v13 + v12 + 4);
              v16 = *(_BYTE *)(v13 + v12 + 1);
              BYTE1(v34) = *(_BYTE *)(v14 + 2);
              HIWORD(v33) = v15;
              LOBYTE(v34) = v16;
              v17 = v34;
              *(_DWORD *)v10 = v33;
              *(_DWORD *)(v10 + 4) = v17;
              memcpy(
                (void *)(v10 + 8),
                *(const void **)(*(_DWORD *)(a1 + 48) + v12 + 8),
                *(_WORD *)(*(_DWORD *)(a1 + 48) + v12 + 6));
              v18 = *(_DWORD *)(a1 + 48) + v12;
              v19 = *(_WORD *)(v18 + 6);
              v10 += v19 + 8;
              v11 += v19 + 8;
              v8 = v27;
              *(_BYTE *)v18 = 1;
            }
            v12 += 20;
            --v26;
          }
          while ( v26 );
          v4 = v25;
        }
        if ( v23 )
        {
          v20 = sub_1007B8C0((unsigned int *)(*(_DWORD *)(a1 + 16) + 12), v11 - 12, 0xFFFFFFFF);
          v21 = *(_DWORD *)(a1 + 16);
          v33 = 327678;
          LOWORD(v34) = 1;
          *(_DWORD *)v21 = 327678;
          *(_DWORD *)(v21 + 4) = v34;
          *(_DWORD *)(v21 + 8) = v20;
        }
        v32 = v11;
        if ( j_HWM_pvg_hsdb_put(&v28) == -100 )
          sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 4355, 0, 0);
        v5 = a2;
      }
      v6 = v24 + 1;
      v24 = v6;
      v6 = (unsigned __int16)v6;
    }
    while ( (unsigned __int16)v6 < v5 );
  }
  return sub_1007C0F0(*(_DWORD *)(a1 + 60));
}
// 1007C830: using guessed type int __cdecl j_HWM_pvg_hsdb_put(_DWORD);

//----- (10022220) --------------------------------------------------------
int __usercall sub_10022220@<eax>(int a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // ebx@1
  int v4; // edi@2
  signed __int16 v5; // ax@3
  int v6; // ebx@3
  int v7; // ebp@3
  int v8; // eax@3
  int v9; // ecx@3
  int v11; // [sp+4h] [bp-8h]@2
  int v12; // [sp+8h] [bp-4h]@3

  v3 = a1;
  sub_1007C110(*(_DWORD *)(a2 + 60), -1);
  if ( v3 )
  {
    v4 = 0;
    v11 = v3;
    do
    {
      v12 = *(_WORD *)(v4 + *(_DWORD *)(a2 + 48) + 4);
      v5 = sub_10022000(v12, a2);
      v6 = (unsigned __int16)v5;
      v7 = 52 * (unsigned __int16)v5;
      memcpy(
        (void *)(*(_DWORD *)(a2 + 28) + *(_DWORD *)(*(_DWORD *)(a2 + 32) + v7 + 4)),
        *(const void **)(v4 + *(_DWORD *)(a2 + 48) + 8),
        *(_WORD *)(v4 + *(_DWORD *)(a2 + 48) + 6));
      v8 = 24 * v6;
      *(_WORD *)(v8 + *(_DWORD *)(a2 + 64) + 4) = *(_WORD *)(v4 + *(_DWORD *)(a2 + 48) + 6);
      *(_BYTE *)(v8 + *(_DWORD *)(a2 + 64) + 1) = *(_BYTE *)(v4 + *(_DWORD *)(a2 + 48) + 1);
      *(_DWORD *)(v8 + *(_DWORD *)(a2 + 64) + 20) = *(_DWORD *)(v4 + *(_DWORD *)(a2 + 48) + 16);
      *(_BYTE *)(v8 + *(_DWORD *)(a2 + 64) + 2) = *(_BYTE *)(v4 + *(_DWORD *)(a2 + 48) + 2);
      *(_DWORD *)(v8 + *(_DWORD *)(a2 + 64) + 16) = a3;
      *(_BYTE *)(v8 + *(_DWORD *)(a2 + 64)) = 0;
      v9 = v7 + *(_DWORD *)(a2 + 32);
      if ( *(_DWORD *)(v9 + 36) && !*(_DWORD *)(v9 + 12) && !(*(_BYTE *)(v8 + *(_DWORD *)(a2 + 64) + 6) & 1) )
      {
        sub_1007C0F0(*(_DWORD *)(a2 + 60));
        (*(void (__cdecl **)(int, int))(*(_DWORD *)(a2 + 32) + v7 + 36))(v12, a2);
        sub_1007C110(*(_DWORD *)(a2 + 60), -1);
      }
      v4 += 20;
      --v11;
    }
    while ( v11 );
  }
  return sub_1007C0F0(*(_DWORD *)(a2 + 60));
}

//----- (10022340) --------------------------------------------------------
char __cdecl sub_10022340(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@2
  char result; // al@2

  LOWORD(v2) = sub_10022000(a1, a2);
  if ( (_WORD)v2 == -1 )
  {
    result = sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 670, 0, 0);
  }
  else
  {
    sub_1007C110(*(_DWORD *)(a2 + 60), -1);
    v2 = (unsigned __int16)v2;
    v3 = 52 * (unsigned __int16)v2 + *(_DWORD *)(a2 + 32);
    memset((void *)(*(_DWORD *)(a2 + 28) + *(_DWORD *)(v3 + 4)), 0, *(_WORD *)v3);
    result = sub_1007C0F0(*(_DWORD *)(a2 + 60));
    *(_BYTE *)(*(_DWORD *)(a2 + 64) + 24 * v2 + 1) = 0;
  }
  return result;
}

//----- (100223C0) --------------------------------------------------------
signed __int16 __cdecl sub_100223C0(int a1, int a2)
{
  return sub_10022000(a2, a1);
}

//----- (100223D0) --------------------------------------------------------
char __cdecl sub_100223D0(_DWORD *a1, _WORD *a2, _DWORD *a3, int a4, int a5)
{
  int v5; // eax@1
  int v6; // edx@1
  char result; // al@2
  int v8; // ecx@3

  LOWORD(v5) = sub_10022000(a4, a5);
  if ( (unsigned __int16)v5 < 0xFFFFu )
  {
    v5 = (unsigned __int16)v5;
    v8 = *(_DWORD *)(v6 + 64) + 24 * (unsigned __int16)v5;
    if ( *(_BYTE *)(v8 + 1) )
    {
      *a1 = *(_DWORD *)(v6 + 28) + *(_DWORD *)(52 * v5 + *(_DWORD *)(v6 + 32) + 4);
      *a2 = *(_WORD *)(v8 + 4);
      *a3 = *(_DWORD *)(v8 + 16);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 791, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10022450) --------------------------------------------------------
char __cdecl sub_10022450(int a1, int a2, void *a3, unsigned __int16 a4)
{
  signed __int16 v4; // di@1
  int v5; // ebp@2
  int v6; // eax@2
  int v7; // ST30_4@3
  const char *v8; // eax@3
  int v10; // edx@4
  int v11; // ecx@4
  unsigned __int16 v12; // di@4
  int v13; // ecx@6
  int v14; // ST2C_4@16
  int v15; // ST28_4@16
  const char *v16; // eax@16
  char v17; // [sp+13h] [bp-75h]@4
  unsigned __int16 v18; // [sp+18h] [bp-70h]@1
  unsigned int v19; // [sp+1Ch] [bp-6Ch]@1
  char v20; // [sp+20h] [bp-68h]@3

  v4 = sub_10022000(a1, a2);
  v18 = v4;
  v19 = sub_1007C040();
  if ( v4 == -1 )
  {
    v17 = 0;
    sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 943, 0, 0);
  }
  else
  {
    v5 = 52 * (unsigned __int16)v4;
    v6 = *(_DWORD *)(a2 + 32) + v5;
    if ( *(_BYTE *)(v6 + 8) )
    {
      v7 = *(_BYTE *)(a2 + 1);
      v8 = sub_10025420(a2, v4);
      _snprintf(&v20, 0x64u, "%d-%s is var pipe=%d", (unsigned __int16)a1, v8, v7);
      sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 874, 0, &v20);
      return 0;
    }
    v10 = *(_DWORD *)(a2 + 64);
    v11 = 24 * (unsigned __int16)v4;
    v12 = *(_WORD *)(v10 + v11 + 4);
    v17 = *(_BYTE *)(v10 + v11 + 1);
    if ( *(_BYTE *)(v11 + v10)
      || *(_DWORD *)(v6 + 12)
      && ((v13 = *(_DWORD *)(v11 + *(_DWORD *)(a2 + 64) + 16)) == 0
       || v19 > v13 + *(_DWORD *)(a2 + 36) + *(_DWORD *)(v6 + 16)) )
    {
      v17 = 0;
    }
    if ( v12 && v12 <= a4 && v12 == *(_WORD *)v6 )
    {
      sub_1007C110(*(_DWORD *)(a2 + 60), -1);
      memcpy(a3, (const void *)(*(_DWORD *)(a2 + 28) + *(_DWORD *)(*(_DWORD *)(a2 + 32) + v5 + 4)), v12);
      sub_1007C0F0(*(_DWORD *)(a2 + 60));
    }
    else
    {
      v17 = 0;
    }
    if ( v12 > a4 || v12 != *(_WORD *)(*(_DWORD *)(a2 + 32) + v5) )
    {
      v14 = *(_BYTE *)(a2 + 1);
      v15 = *(_WORD *)(*(_DWORD *)(a2 + 32) + v5);
      v16 = sub_10025420(a2, v18);
      _snprintf(&v20, 0x64u, "%d-%s by=%d sz=%d pi=%d bsz=%d", (unsigned __int16)a1, v16, v12, v15, v14, a4);
      sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 936, 0, &v20);
    }
  }
  return v17;
}

//----- (10022640) --------------------------------------------------------
int __cdecl sub_10022640(int a1, int a2)
{
  signed __int16 v2; // ax@1
  int v3; // edx@1
  int result; // eax@2

  v2 = sub_10022000(a1, a2);
  if ( v2 == -1 )
  {
    sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 992, 0, 0);
    result = 0;
  }
  else
  {
    result = *(_DWORD *)(*(_DWORD *)(v3 + 64) + 24 * (unsigned __int16)v2 + 20);
  }
  return result;
}

//----- (10022690) --------------------------------------------------------
char __cdecl sub_10022690(int a1, int a2, void *a3, unsigned __int16 *a4, unsigned __int16 a5)
{
  signed __int16 v5; // bp@1
  int v6; // edi@2
  int v7; // ST30_4@3
  const char *v8; // eax@3
  int v10; // ecx@4
  unsigned __int16 v11; // bp@4
  int v12; // eax@4
  int v13; // eax@5
  int v14; // ecx@6
  unsigned __int16 v15; // ax@14
  unsigned __int16 v16; // cx@14
  int v17; // ST2C_4@16
  int v18; // ST28_4@16
  int v19; // ST24_4@16
  const char *v20; // eax@16
  char v21; // [sp+13h] [bp-75h]@4
  unsigned __int16 v22; // [sp+18h] [bp-70h]@1
  unsigned int v23; // [sp+1Ch] [bp-6Ch]@1
  char v24; // [sp+20h] [bp-68h]@3

  v5 = sub_10022000(a1, a2);
  v22 = v5;
  v23 = sub_1007C040();
  if ( v5 == -1 )
  {
    v21 = 0;
    *a4 = 0;
    sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1267, 0, 0);
  }
  else
  {
    v6 = 52 * (unsigned __int16)v5;
    if ( *(_BYTE *)(*(_DWORD *)(a2 + 32) + v6 + 8) != 1 )
    {
      v7 = *(_BYTE *)(a2 + 1);
      v8 = sub_10025420(a2, v5);
      _snprintf(&v24, 0x64u, "%d-%s !var pipe=%d", (unsigned __int16)a1, v8, v7);
      sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1189, 0, &v24);
      return 0;
    }
    v10 = 24 * (unsigned __int16)v5;
    v11 = *(_WORD *)(v10 + *(_DWORD *)(a2 + 64) + 4);
    *a4 = v11;
    v12 = *(_DWORD *)(a2 + 64);
    v21 = *(_BYTE *)(v10 + v12 + 1);
    if ( *(_BYTE *)(v10 + v12)
      || (v13 = *(_DWORD *)(a2 + 32) + v6, *(_DWORD *)(v13 + 12))
      && ((v14 = *(_DWORD *)(v10 + *(_DWORD *)(a2 + 64) + 16)) == 0
       || v23 > v14 + *(_DWORD *)(a2 + 36) + *(_DWORD *)(v13 + 16)) )
    {
      v21 = 0;
    }
    if ( v11 && v11 <= *(_WORD *)(v6 + *(_DWORD *)(a2 + 32)) && v11 <= a5 )
    {
      sub_1007C110(*(_DWORD *)(a2 + 60), -1);
      memcpy(a3, (const void *)(*(_DWORD *)(a2 + 28) + *(_DWORD *)(*(_DWORD *)(a2 + 32) + v6 + 4)), *a4);
      sub_1007C0F0(*(_DWORD *)(a2 + 60));
    }
    else
    {
      v21 = 0;
    }
    v15 = *a4;
    v16 = *(_WORD *)(v6 + *(_DWORD *)(a2 + 32));
    if ( *a4 > v16 || v15 > a5 )
    {
      v17 = *(_BYTE *)(a2 + 1);
      v18 = v16;
      v19 = v15;
      v20 = sub_10025420(a2, v22);
      _snprintf(&v24, 0x64u, "%d-%s by=%d sz=%d pipe=%d bsz=%d", (unsigned __int16)a1, v20, v19, v18, v17, a5);
      sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1260, 0, &v24);
    }
  }
  return v21;
}

//----- (100228A0) --------------------------------------------------------
int __cdecl sub_100228A0(int a1)
{
  int v1; // ebp@1
  int v2; // edi@1
  int v3; // eax@2
  int v4; // ecx@3
  signed int v5; // ebx@7
  unsigned __int16 v6; // cx@7
  int v7; // eax@8
  int v8; // ecx@14

  v1 = *(_DWORD *)(a1 + 8);
  sub_1007C110(*(_DWORD *)(a1 + 60), -1);
  v2 = 0;
  if ( *(_DWORD *)(a1 + 4) > 0 )
  {
    do
    {
      LOWORD(v3) = sub_10022000(v2, a1);
      if ( (_WORD)v3 != -1 )
      {
        v3 = (unsigned __int16)v3;
        v4 = *(_DWORD *)(a1 + 32) + 52 * (unsigned __int16)v3;
        if ( *(_BYTE *)(v4 + 28) & *(_BYTE *)a1 )
        {
          if ( *(_BYTE *)(v3 + *(_DWORD *)(a1 + 24)) == 1
            && *(_DWORD *)(v4 + 12)
            && *(_DWORD *)(v4 + 24) & *(_DWORD *)(a1 + 72) )
          {
            v5 = *(_DWORD *)(a1 + 8);
            v6 = 0;
            if ( v5 > 0 )
            {
              v7 = 0;
              do
              {
                if ( *(_WORD *)(*(_DWORD *)(a1 + 68) + 2 * v7) == (_WORD)v2 )
                  break;
                v7 = ++v6;
              }
              while ( v6 < v5 );
            }
            if ( v6 == v5 )
              *(_WORD *)(*(_DWORD *)(a1 + 68) + 2 * v1++) = v2;
          }
        }
      }
      ++v2;
    }
    while ( (signed int)(unsigned __int16)v2 < *(_DWORD *)(a1 + 4) );
  }
  v8 = *(_DWORD *)(a1 + 60);
  *(_DWORD *)(a1 + 8) = v1;
  return sub_1007C0F0(v8);
}

//----- (10022950) --------------------------------------------------------
int __cdecl sub_10022950(int a1)
{
  int v1; // ebp@1
  int v2; // edi@1
  signed __int16 v3; // ax@2
  int v4; // ecx@3
  int v5; // eax@3
  int v6; // edx@12

  v1 = 0;
  sub_1007C110(*(_DWORD *)(a1 + 60), -1);
  v2 = 0;
  if ( *(_DWORD *)(a1 + 4) > 0 )
  {
    do
    {
      v3 = sub_10022000(v2, a1);
      if ( v3 != -1 )
      {
        v4 = (unsigned __int16)v3;
        v5 = 52 * (unsigned __int16)v3 + *(_DWORD *)(a1 + 32);
        if ( *(_BYTE *)(v5 + 28) & *(_BYTE *)a1 )
        {
          if ( *(_BYTE *)(v4 + *(_DWORD *)(a1 + 24)) == 1
            && *(_DWORD *)(v5 + 12)
            && *(_DWORD *)(v5 + 20) & *(_DWORD *)(a1 + 72)
            && *(_DWORD *)(v5 + 24) )
          {
            if ( (unsigned int)*(_WORD *)v5 + 20 > *(_DWORD *)(a1 + 20) )
              sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1622, 0, 0);
            else
              *(_WORD *)(*(_DWORD *)(a1 + 76) + 2 * v1++) = v2;
          }
        }
      }
      ++v2;
    }
    while ( (signed int)(unsigned __int16)v2 < *(_DWORD *)(a1 + 4) );
  }
  v6 = *(_DWORD *)(a1 + 60);
  *(_DWORD *)(a1 + 12) = v1;
  return sub_1007C0F0(v6);
}

//----- (10022A00) --------------------------------------------------------
char __cdecl sub_10022A00(int a1)
{
  char v1; // cl@1
  int v2; // eax@2
  int v3; // ebx@3
  signed int v4; // ebp@3
  unsigned int v5; // eax@3
  unsigned int v6; // edi@3
  bool v7; // zf@3
  unsigned int v8; // eax@4
  unsigned int v9; // eax@6
  int v10; // edx@15
  int v11; // eax@15
  int v12; // edi@15
  int v13; // edx@15
  int v14; // ebp@15
  int v15; // ebx@15
  int v16; // eax@15
  int v17; // eax@19
  char v18; // cl@19
  int v19; // ecx@24
  int v20; // edi@25
  int v21; // ecx@30
  int v22; // edx@30
  unsigned int v23; // edi@38
  int v24; // ebp@44
  int v25; // eax@45
  int v26; // edx@45
  int v27; // ecx@45
  void (__cdecl *v28)(int, int); // edi@45
  unsigned int v30; // [sp+10h] [bp-90h]@3
  int v31; // [sp+14h] [bp-8Ch]@3
  int v32; // [sp+18h] [bp-88h]@20
  unsigned int v33; // [sp+18h] [bp-88h]@44
  int v34; // [sp+1Ch] [bp-84h]@1
  int v35; // [sp+20h] [bp-80h]@2
  int v36; // [sp+24h] [bp-7Ch]@1
  char v37; // [sp+28h] [bp-78h]@1
  unsigned __int16 v38; // [sp+2Ah] [bp-76h]@3
  unsigned int v39; // [sp+2Ch] [bp-74h]@1
  int v40; // [sp+30h] [bp-70h]@15
  int v41; // [sp+34h] [bp-6Ch]@3
  char v42; // [sp+38h] [bp-68h]@9

  v1 = *(_BYTE *)(a1 + 1);
  v36 = *(_DWORD *)(a1 + 16);
  v37 = v1;
  v39 = sub_1007C040();
  v34 = 0;
LABEL_2:
  while ( 1 )
  {
    v2 = j_HWM_pvg_hsdb_get(&v35, *(_DWORD *)(a1 + 20));
    if ( v2 <= 0 )
      break;
    v3 = *(_DWORD *)(a1 + 16);
    v4 = v38;
    v5 = *(_DWORD *)v3;
    v6 = 0;
    v7 = (unsigned __int16)*(_DWORD *)v3 == -2;
    v31 = v38;
    v30 = 0;
    v41 = *(_DWORD *)(v3 + 4);
    if ( v7 )
    {
      v8 = v5 >> 16;
      v4 = -8 - (unsigned __int16)v8 + v38;
      v31 = -8 - (unsigned __int16)v8 + v38;
      v3 += (unsigned __int16)v8 + 8;
      if ( (unsigned __int16)v8 < 4u || v4 <= 0 )
      {
        v31 = 0;
        v4 = 0;
        v9 = ~v34;
      }
      else
      {
        v34 = *(_DWORD *)(v3 - 4);
        v9 = sub_1007B8C0((unsigned int *)v3, v4, 0xFFFFFFFF);
      }
      if ( v34 != v9 )
      {
        _snprintf(&v42, 0x64u, "crc error rxsz=%d pipe=%d addr=0x%lx", v38, v37, v35);
        sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1796, 0, &v42);
        continue;
      }
    }
    else if ( *(_BYTE *)(a1 + 1) == 6 )
    {
      _snprintf(&v42, 0x64u, "crc error rxsz=%d pipe=%d addr=0x%lx", v38, v37, v35);
      sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1817, 0, &v42);
      continue;
    }
    if ( v4 > 0 )
    {
      while ( 1 )
      {
        v10 = *(_DWORD *)v3;
        v11 = *(_DWORD *)(v3 + 4);
        v12 = 20 * v6;
        *(_WORD *)(v12 + *(_DWORD *)(a1 + 48) + 4) = *(_DWORD *)v3;
        *(_WORD *)(v12 + *(_DWORD *)(a1 + 48) + 6) = HIWORD(v10);
        *(_BYTE *)(v12 + *(_DWORD *)(a1 + 48) + 1) = v11;
        *(_BYTE *)(v12 + *(_DWORD *)(a1 + 48) + 2) = BYTE1(v11);
        v40 = v10;
        LOWORD(v14) = sub_10022000(v10, a1);
        *(_DWORD *)(v12 + *(_DWORD *)(a1 + 48) + 16) = v35;
        v15 = v3 + 8;
        *(_DWORD *)(v12 + *(_DWORD *)(a1 + 48) + 8) = v15;
        v16 = *(_WORD *)(v12 + *(_DWORD *)(a1 + 48) + 6);
        v3 = v16 + v15;
        v31 += -8 - v16;
        if ( v31 < 0 )
        {
          _snprintf(
            &v42,
            0x64u,
            "error with pkt id %d rxsz=%d pipe=%d",
            (unsigned __int16)v13,
            HIWORD(v40),
            *(_BYTE *)(a1 + 1));
          sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1877, 0, &v42);
          goto LABEL_2;
        }
        if ( *(_DWORD *)(a1 + 80) )
          (*(void (__cdecl **)(int, int, _DWORD, _DWORD))(a1 + 80))(
            a1,
            v13,
            *(_WORD *)(v12 + *(_DWORD *)(a1 + 48) + 6),
            *(_DWORD *)(*(_DWORD *)(a1 + 48) + v12 + 8));
        if ( (_WORD)v14 == -1 )
        {
LABEL_39:
          v23 = v30;
          goto LABEL_40;
        }
        v14 = (unsigned __int16)v14;
        v17 = 52 * (unsigned __int16)v14 + *(_DWORD *)(a1 + 32);
        v18 = *(_BYTE *)(v17 + 8);
        if ( v18 )
        {
          v32 = v12 + *(_DWORD *)(a1 + 48);
          if ( *(_WORD *)(v32 + 6) <= *(_WORD *)v17 )
            goto LABEL_23;
          if ( v18 )
            goto LABEL_39;
        }
        v32 = v12 + *(_DWORD *)(a1 + 48);
        if ( *(_WORD *)(v32 + 6) != *(_WORD *)v17 )
          goto LABEL_39;
LABEL_23:
        if ( *(_BYTE *)(*(_DWORD *)(a1 + 24) + v14) != 1 )
          goto LABEL_39;
        v19 = *(_DWORD *)(v12 + *(_DWORD *)(a1 + 48) + 16);
        if ( (v19 & *(_DWORD *)(v17 + 20)) != v19 )
        {
          v20 = *(_DWORD *)(v12 + *(_DWORD *)(a1 + 48) + 16);
          if ( (v20 & 0xC00000) != v20 && !(*(_BYTE *)a1 & 4) )
            goto LABEL_39;
        }
        if ( !(*(_DWORD *)(v17 + 24) & *(_DWORD *)(a1 + 72)) || !(*(_BYTE *)(v17 + 28) & *(_BYTE *)a1) )
          goto LABEL_39;
        if ( *(_DWORD *)(v17 + 12) )
        {
          v21 = *(_DWORD *)(a1 + 64) + 24 * v14;
          v22 = *(_DWORD *)(v21 + 16);
          if ( v22 )
          {
            if ( v39 <= v22 + *(_DWORD *)(a1 + 36) + (*(_DWORD *)(v17 + 16) >> 1)
              && (*(_BYTE *)(v32 + 1) != 1 || *(_BYTE *)(v21 + 1) == 1 && *(_BYTE *)(v32 + 2) > *(_BYTE *)(v21 + 2))
              && (*(_BYTE *)(v21 + 1) == 1 || *(_BYTE *)(v32 + 2) > *(_BYTE *)(v21 + 2))
              && *(_BYTE *)(v32 + 2) != *(_BYTE *)(v21 + 2) )
            {
              goto LABEL_39;
            }
          }
        }
        v23 = v30++ + 1;
LABEL_40:
        if ( !v31 || v23 >= *(_DWORD *)(a1 + 52) )
        {
          if ( v23 )
          {
            sub_10022220(v23, a1, v39);
            if ( v23 )
            {
              v24 = 0;
              v33 = v23;
              do
              {
                v25 = (unsigned __int16)sub_10022000(*(_WORD *)(*(_DWORD *)(a1 + 48) + v24 + 4), a1);
                v27 = *(_DWORD *)(a1 + 32) + 52 * (unsigned __int16)v25;
                v28 = *(void (__cdecl **)(int, int))(v27 + 36);
                if ( v28 && *(_DWORD *)(v27 + 12) && !(*(_BYTE *)(*(_DWORD *)(a1 + 64) + 24 * v25 + 6) & 1) )
                  v28(v26, a1);
                v24 += 20;
                --v33;
              }
              while ( v33 );
            }
          }
          v30 = 0;
        }
        if ( v31 <= 0 )
          goto LABEL_2;
        v6 = v30;
      }
    }
  }
  if ( v2 == -95 )
    LOBYTE(v2) = sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2094, 0, 0);
  return v2;
}
// 1007C800: using guessed type int __cdecl j_HWM_pvg_hsdb_get(_DWORD, _DWORD);

//----- (10022E00) --------------------------------------------------------
int __cdecl sub_10022E00(int a1)
{
  int result; // eax@1
  signed __int16 v2; // ax@2
  int v3; // ebx@2
  int v4; // edi@2
  unsigned int *v5; // edx@2
  int v6; // ebp@3
  unsigned int v7; // ecx@3
  unsigned int v8; // ebx@4
  unsigned int v9; // eax@4
  int v10; // ecx@5
  int v11; // eax@5
  int v12; // edx@8
  int v13; // ecx@8
  int v14; // edx@8
  unsigned int v15; // eax@12
  int v16; // edx@16
  int v17; // ST24_4@19
  const char *v18; // eax@19
  int v19; // eax@20
  int v20; // ecx@21
  int v21; // ebx@24
  int v22; // edx@26
  int v23; // eax@27
  int v24; // eax@29
  int v25; // eax@31
  int v26; // edx@31
  int v27; // eax@32
  int v28; // ecx@32
  int v29; // ebp@32
  void (__cdecl *v30)(int, int); // ebp@33
  unsigned int v31; // [sp+8h] [bp-8Ch]@1
  signed int v32; // [sp+Ch] [bp-88h]@1
  unsigned int v33; // [sp+10h] [bp-84h]@1
  int v34; // [sp+14h] [bp-80h]@1
  int v35; // [sp+18h] [bp-7Ch]@2
  int v36; // [sp+1Ch] [bp-78h]@1
  unsigned __int16 v37; // [sp+24h] [bp-70h]@2
  int v38; // [sp+28h] [bp-6Ch]@2
  char v39; // [sp+2Ch] [bp-68h]@19

  v33 = 12;
  v36 = j_HWM_pvg_hsdb_get_lrus_online();
  v32 = 0;
  result = sub_1007C040();
  v31 = result;
  v34 = 0;
  if ( *(_DWORD *)(a1 + 12) > 0 )
  {
    do
    {
      v35 = *(_WORD *)(*(_DWORD *)(a1 + 76) + 2 * v34);
      v2 = sub_10022000(v35, a1);
      v3 = (unsigned __int16)v2;
      v4 = 24 * (unsigned __int16)v2;
      v5 = (unsigned int *)(v4 + *(_DWORD *)(a1 + 64) + 8);
      v37 = v2;
      v38 = (unsigned __int16)v2;
      if ( v31 >= *v5 - *(_DWORD *)(a1 + 36) )
      {
        v6 = 52 * (unsigned __int16)v2;
        v7 = *v5 + *(_DWORD *)(*(_DWORD *)(a1 + 32) + 52 * (unsigned __int16)v2 + 12);
        if ( v31 >= v7 )
        {
          v8 = *(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 12);
          v5 = (unsigned int *)(v4 + *(_DWORD *)(a1 + 64) + 8);
          v9 = v8 * ((*(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 12) - v7 + v31 - 1) / v8);
          v3 = v38;
          v7 += v9;
        }
        *v5 = v7;
        v10 = v36;
        v11 = v6 + *(_DWORD *)(a1 + 32);
        if ( v36 & *(_DWORD *)(v11 + 24) || v10 & 0xC00000 || (*(_DWORD *)(v11 + 32) >> 3) & 1 )
        {
          v15 = *(_WORD *)v11 + v33 + 8;
          if ( v32 > 0 && (v15 > *(_DWORD *)(a1 + 20) || v15 > 0x5B0) )
          {
            sub_10022020(a1, v32);
            v32 = 0;
            v33 = 12;
          }
          v16 = *(_DWORD *)(a1 + 32);
          if ( !*(_DWORD *)(v16 + v6 + 44) || *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 6) & 4 )
            goto LABEL_42;
          if ( (*(_DWORD *)(v16 + v6 + 32) >> 1) & 1 )
          {
            v17 = *(_BYTE *)(a1 + 1);
            v18 = sub_10025420(a1, v37);
            _snprintf(&v39, 0x64u, "%d-%s is TX_ON_PUT, pipe=%d", (unsigned __int16)v35, v18, v17);
            sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2279, 0, &v39);
          }
          v19 = v4 + *(_DWORD *)(a1 + 64);
          if ( *(_BYTE *)(*(_BYTE *)(a1 + 3) + v3 * *(_BYTE *)(a1 + 2) + *(_DWORD *)(a1 + 56)) > *(_BYTE *)(v19 + 2)
            && (v20 = *(_DWORD *)(v19 + 16)) != 0
            && v31 <= *(_DWORD *)(a1 + 36) + v20 + (*(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 16) >> 1)
            && *(_BYTE *)(v19 + 1) == 1 )
          {
LABEL_42:
            v21 = v35;
          }
          else
          {
            v21 = v35;
            (*(void (__cdecl **)(int, int))(*(_DWORD *)(a1 + 32) + v6 + 44))(v35, a1);
          }
          v22 = *(_DWORD *)(a1 + 64);
          if ( *(_BYTE *)(v4 + v22 + 3) == 1 )
          {
            v23 = *(_DWORD *)(v4 + v22 + 16);
            if ( v23 )
            {
              if ( v31 <= *(_DWORD *)(a1 + 36) + v23 + *(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 12) )
              {
                *(_DWORD *)(v4 + *(_DWORD *)(a1 + 64) + 12) = v31;
                *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 3) = 0;
                v24 = *(_DWORD *)(a1 + 64);
                if ( *(_DWORD *)(v4 + v24 + 20) & *(_DWORD *)(a1 + 72) )
                {
                  if ( *(_WORD *)(v4 + v24 + 4) )
                  {
                    v25 = 20 * v32;
                    *(_DWORD *)(v25 + *(_DWORD *)(a1 + 48) + 8) = *(_DWORD *)(a1 + 28)
                                                                + *(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 4);
                    *(_DWORD *)(v25 + *(_DWORD *)(a1 + 48) + 12) = v36 & *(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 24);
                    *(_WORD *)(v25 + *(_DWORD *)(a1 + 48) + 4) = v21;
                    *(_WORD *)(v25 + *(_DWORD *)(a1 + 48) + 6) = *(_WORD *)(v4 + *(_DWORD *)(a1 + 64) + 4);
                    *(_BYTE *)(v25 + *(_DWORD *)(a1 + 48)) = 0;
                    ++v32;
                    *(_BYTE *)(v25 + *(_DWORD *)(a1 + 48) + 1) = *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 1);
                    *(_BYTE *)(v25 + *(_DWORD *)(a1 + 48) + 2) = *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 2);
                    v26 = *(_DWORD *)(a1 + 32);
                    v33 += *(_WORD *)(v26 + v6) + 8;
                    if ( (*(_DWORD *)(v26 + v6 + 32) >> 2) & 1 )
                    {
                      v27 = *(_DWORD *)(a1 + 32);
                      v28 = *(_DWORD *)(v6 + v27 + 24);
                      v29 = v27 + v6;
                      if ( v28 & *(_DWORD *)(a1 + 72) )
                      {
                        v30 = *(void (__cdecl **)(int, int))(v29 + 36);
                        if ( v30 )
                        {
                          if ( !(*(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 6) & 1) )
                            v30(v21, a1);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        else
        {
          v12 = *(_DWORD *)(a1 + 64);
          v13 = *(_DWORD *)(v12 + v4 + 16);
          v14 = v4 + v12;
          if ( (!v13 || v31 > *(_DWORD *)(a1 + 36) + v13 + *(_DWORD *)(v11 + 16)) && *(_BYTE *)(v14 + 1) == 1 )
          {
            *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 1) = 0;
            *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 3) = 0;
          }
        }
      }
      ++v34;
    }
    while ( v34 < *(_DWORD *)(a1 + 12) );
    result = v32;
    if ( v32 > 0 && v33 <= *(_DWORD *)(a1 + 20) )
      result = sub_10022020(a1, v32);
  }
  return result;
}
// 1007C810: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (10023190) --------------------------------------------------------
char __cdecl sub_10023190(int a1, char a2, int a3, const void *a4, int a5)
{
  signed __int16 v5; // ax@1
  int v6; // ebx@2
  int v7; // ebp@2
  int v8; // edi@2
  int v9; // ecx@2
  int v10; // ST2C_4@4
  const char *v11; // eax@4
  int v12; // eax@5
  int v13; // edx@5
  int v14; // ecx@7
  int v15; // edx@7
  int v16; // ecx@7
  int v17; // eax@15
  unsigned int v18; // ecx@15
  int v19; // eax@15
  int v20; // edx@16
  int (__cdecl *v21)(int, int); // ebp@18
  int v22; // ST2C_4@23
  int v23; // ST28_4@23
  int v24; // ST24_4@23
  const char *v25; // eax@23
  unsigned int v26; // eax@4
  unsigned int v28; // [sp+10h] [bp-70h]@5
  char v29; // [sp+18h] [bp-68h]@4

  v5 = sub_10022000(a1, a3);
  if ( v5 == -1
    || (v6 = (unsigned __int16)v5,
        v7 = 52 * (unsigned __int16)v5,
        v8 = 24 * (unsigned __int16)v5,
        v9 = v7 + *(_DWORD *)(a3 + 32),
        *(_WORD *)(*(_DWORD *)(a3 + 64) + v8 + 4) != *(_WORD *)v9) )
  {
    if ( (signed int)(unsigned __int16)a1 >= *(_DWORD *)(a3 + 4) || v5 == -1 )
    {
      _snprintf(&v29, 0x64u, "pkt:%d lut_id:%d pipe:%d", (unsigned __int16)a1, (unsigned __int16)v5, *(_BYTE *)(a3 + 1));
      LOBYTE(v26) = sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2645, 0, &v29);
    }
    else
    {
      v22 = *(_BYTE *)(a3 + 1);
      v23 = *(_WORD *)(52 * (unsigned __int16)v5 + *(_DWORD *)(a3 + 32));
      v24 = *(_WORD *)(*(_DWORD *)(a3 + 64) + 24 * (unsigned __int16)v5 + 4);
      v25 = sub_10025420(a3, v5);
      _snprintf(&v29, 0x64u, "%d-%s stssz=%d infsz=%d pipe=%d", (unsigned __int16)a1, v25, v24, v23, v22);
      LOBYTE(v26) = sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2660, 0, &v29);
    }
  }
  else if ( *(_BYTE *)(v9 + 8) )
  {
    v10 = *(_BYTE *)(a3 + 1);
    v11 = sub_10025420(a3, v5);
    _snprintf(&v29, 0x64u, "%d-%s is var pipe=%d", (unsigned __int16)a1, v11, v10);
    LOBYTE(v26) = sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2511, 0, &v29);
  }
  else
  {
    v12 = sub_1007C040();
    v13 = *(_DWORD *)(a3 + 32);
    v28 = v12;
    if ( !*(_DWORD *)(v13 + v7 + 12)
      || (v26 = *(_DWORD *)(v13 + v7 + 16), v28 <= a5 + v26 + *(_DWORD *)(a3 + 36))
      && ((v14 = *(_DWORD *)(a3 + 64), v15 = *(_DWORD *)(v14 + v8 + 16), v16 = v8 + v14, !v15)
       || v28 > *(_DWORD *)(a3 + 36) + v15 + (v26 >> 1)
       || a2
       && (*(_BYTE *)(v16 + 1) != 1
        || *(_BYTE *)(*(_BYTE *)(a3 + 3) + v6 * *(_BYTE *)(a3 + 2) + *(_DWORD *)(a3 + 56)) <= *(_BYTE *)(v16 + 2))
       || *(_BYTE *)(v16 + 1) != 1
       && *(_BYTE *)(*(_BYTE *)(a3 + 3) + v6 * *(_BYTE *)(a3 + 2) + *(_DWORD *)(a3 + 56)) <= *(_BYTE *)(v16 + 2)
       || (v26 = *(_DWORD *)(a3 + 56),
           *(_BYTE *)(*(_BYTE *)(a3 + 3) + v6 * *(_BYTE *)(a3 + 2) + v26) == *(_BYTE *)(v16 + 2))) )
    {
      sub_1007C110(*(_DWORD *)(a3 + 60), -1);
      *(_BYTE *)(*(_DWORD *)(a3 + 64) + v8 + 1) = a2;
      *(_DWORD *)(*(_DWORD *)(a3 + 64) + v8 + 16) = a5;
      *(_BYTE *)(*(_DWORD *)(a3 + 64) + v8 + 2) = *(_BYTE *)(*(_BYTE *)(a3 + 3)
                                                           + v6 * *(_BYTE *)(a3 + 2)
                                                           + *(_DWORD *)(a3 + 56));
      *(_BYTE *)(v8 + *(_DWORD *)(a3 + 64)) = 0;
      *(_BYTE *)(*(_DWORD *)(a3 + 64) + v8 + 3) = 1;
      *(_DWORD *)(*(_DWORD *)(a3 + 64) + v8 + 20) = *(_DWORD *)(a3 + 72);
      v17 = *(_DWORD *)(a3 + 32);
      v18 = *(_DWORD *)(v17 + v7 + 32);
      v19 = v7 + v17;
      if ( (v18 >> 1) & 1 )
      {
        v20 = *(_DWORD *)(a3 + 64);
        if ( v28 < *(_DWORD *)(v20 + v8 + 8) )
          *(_DWORD *)(v20 + v8 + 8) -= *(_DWORD *)(v19 + 12);
      }
      memcpy(
        (void *)(*(_DWORD *)(a3 + 28) + *(_DWORD *)(*(_DWORD *)(a3 + 32) + v7 + 4)),
        a4,
        *(_WORD *)(*(_DWORD *)(a3 + 64) + v8 + 4));
      LOBYTE(v26) = sub_1007C0F0(*(_DWORD *)(a3 + 60));
      v21 = *(int (__cdecl **)(int, int))(*(_DWORD *)(a3 + 32) + v7 + 48);
      if ( v21 && !(*(_BYTE *)(*(_DWORD *)(a3 + 64) + v8 + 6) & 8) )
        LOBYTE(v26) = v21(a1, a3);
    }
  }
  return v26;
}

//----- (100234A0) --------------------------------------------------------
char __cdecl sub_100234A0(int a1, unsigned __int16 a2, char a3, int a4, const void *a5, int a6)
{
  signed __int16 v6; // ax@1
  int v7; // ebp@2
  int v8; // ebx@2
  int v9; // ecx@2
  int v10; // ST28_4@4
  const char *v11; // eax@4
  unsigned int v12; // edx@5
  int v13; // ecx@5
  unsigned int v14; // ecx@6
  int v15; // edx@7
  int v16; // edi@7
  int v17; // edi@14
  int v18; // eax@14
  int v19; // ecx@15
  int (__cdecl *v20)(int, int); // ebx@17
  int v21; // ST28_4@22
  const char *v22; // eax@22
  int v23; // eax@4
  unsigned int v25; // [sp+10h] [bp-70h]@5
  char v26; // [sp+18h] [bp-68h]@4

  v6 = sub_10022000(a1, a4);
  if ( v6 == -1
    || (v7 = (unsigned __int16)v6, v8 = 52 * (unsigned __int16)v6, v9 = v8 + *(_DWORD *)(a4 + 32), a2 > *(_WORD *)v9) )
  {
    if ( (signed int)(unsigned __int16)a1 >= *(_DWORD *)(a4 + 4) || v6 == -1 )
    {
      _snprintf(&v26, 0x64u, "pkt:%d lut_id:%d pipe:%d", (unsigned __int16)a1, (unsigned __int16)v6, *(_BYTE *)(a4 + 1));
      LOBYTE(v23) = sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2939, 0, &v26);
    }
    else
    {
      v21 = *(_BYTE *)(a4 + 1);
      v22 = sub_10025420(a4, v6);
      _snprintf(&v26, 0x64u, "%d-%s >max sz sz=%d pipe=%d", (unsigned __int16)a1, v22, a2, v21);
      LOBYTE(v23) = sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2953, 0, &v26);
    }
  }
  else if ( *(_BYTE *)(v9 + 8) == 1 )
  {
    v12 = sub_1007C040();
    v13 = *(_DWORD *)(a4 + 32) + v8;
    v25 = v12;
    if ( !*(_DWORD *)(v13 + 12)
      || (v14 = *(_DWORD *)(v13 + 16), v23 = *(_DWORD *)(a4 + 36), v12 <= a6 + v23 + v14)
      && ((v15 = *(_DWORD *)(a4 + 64) + 24 * v7, (v16 = *(_DWORD *)(v15 + 16)) == 0)
       || v25 > v23 + v16 + (v14 >> 1)
       || a3
       && (*(_BYTE *)(v15 + 1) != 1
        || (LOBYTE(v23) = *(_BYTE *)(*(_BYTE *)(a4 + 3) + v7 * *(_BYTE *)(a4 + 2) + *(_DWORD *)(a4 + 56)),
            (unsigned __int8)v23 <= *(_BYTE *)(v15 + 2)))
       || *(_BYTE *)(v15 + 1) != 1
       && (v23 = *(_DWORD *)(a4 + 56),
           *(_BYTE *)(*(_BYTE *)(a4 + 3) + v7 * *(_BYTE *)(a4 + 2) + v23) <= *(_BYTE *)(v15 + 2))) )
    {
      sub_1007C110(*(_DWORD *)(a4 + 60), -1);
      v17 = 24 * v7;
      *(_WORD *)(v17 + *(_DWORD *)(a4 + 64) + 4) = a2;
      *(_BYTE *)(v17 + *(_DWORD *)(a4 + 64) + 1) = a3;
      *(_DWORD *)(v17 + *(_DWORD *)(a4 + 64) + 16) = a6;
      *(_BYTE *)(v17 + *(_DWORD *)(a4 + 64) + 2) = *(_BYTE *)(*(_BYTE *)(a4 + 3)
                                                            + v7 * *(_BYTE *)(a4 + 2)
                                                            + *(_DWORD *)(a4 + 56));
      *(_BYTE *)(v17 + *(_DWORD *)(a4 + 64)) = 0;
      *(_BYTE *)(v17 + *(_DWORD *)(a4 + 64) + 3) = 1;
      *(_DWORD *)(v17 + *(_DWORD *)(a4 + 64) + 20) = *(_DWORD *)(a4 + 72);
      v18 = *(_DWORD *)(a4 + 32) + v8;
      if ( (*(_DWORD *)(v18 + 32) >> 1) & 1 )
      {
        v19 = *(_DWORD *)(a4 + 64);
        if ( v25 < *(_DWORD *)(v17 + v19 + 8) )
          *(_DWORD *)(v17 + v19 + 8) -= *(_DWORD *)(v18 + 12);
      }
      memcpy(
        (void *)(*(_DWORD *)(a4 + 28) + *(_DWORD *)(*(_DWORD *)(a4 + 32) + v8 + 4)),
        a5,
        *(_WORD *)(v17 + *(_DWORD *)(a4 + 64) + 4));
      sub_1007C0F0(*(_DWORD *)(a4 + 60));
      v23 = *(_DWORD *)(a4 + 32);
      v20 = *(int (__cdecl **)(int, int))(v23 + v8 + 48);
      if ( v20 && !(*(_BYTE *)(v17 + *(_DWORD *)(a4 + 64) + 6) & 8) )
        LOBYTE(v23) = v20(a1, a4);
    }
  }
  else
  {
    v10 = *(_BYTE *)(a4 + 1);
    v11 = sub_10025420(a4, v6);
    _snprintf(&v26, 0x64u, "%d-%s !var pipe=%d", (unsigned __int16)a1, v11, v10);
    LOBYTE(v23) = sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2802, 0, &v26);
  }
  return v23;
}

//----- (10023790) --------------------------------------------------------
char __cdecl sub_10023790(int a1, int a2, int a3)
{
  signed __int16 v3; // ax@1
  char result; // al@2
  int v5; // ecx@3
  int v6; // ebp@3
  int v7; // eax@3
  int v8; // edi@3
  int v9; // ebx@3
  int v10; // ST24_4@5
  const char *v11; // eax@5
  int v12; // eax@7
  int v13; // ebp@10
  void (__cdecl *v14)(int, int); // eax@10
  char v15; // cl@13
  int v16; // edx@13
  __int16 v17; // ax@13
  bool v18; // cf@13
  bool v19; // zf@13
  int v20; // ebx@17
  int v21; // eax@19
  char v22; // dl@19
  __int16 v23; // cx@19
  unsigned int v24; // eax@20
  int v25; // ecx@20
  int v26; // edi@21
  char v27; // [sp+6h] [bp-7Eh]@3
  char v28; // [sp+7h] [bp-7Dh]@17
  int v29; // [sp+8h] [bp-7Ch]@13
  int v30; // [sp+Ch] [bp-78h]@13
  char v31; // [sp+10h] [bp-74h]@13
  char v32; // [sp+11h] [bp-73h]@15
  __int16 v33; // [sp+12h] [bp-72h]@13
  int v34; // [sp+14h] [bp-70h]@1
  int v35; // [sp+18h] [bp-6Ch]@19
  char v36; // [sp+1Ch] [bp-68h]@5

  v3 = sub_10022000(a1, a3);
  v34 = (unsigned __int16)v3;
  if ( v3 == -1 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD *)(a3 + 72);
    v6 = (unsigned __int16)v3;
    v7 = *(_DWORD *)(a3 + 32);
    v8 = 52 * v6;
    v9 = a2 & ~v5 & (*(_DWORD *)(v7 + 52 * v6 + 24) | 0xC00000);
    v27 = 1;
    if ( !*(_DWORD *)(52 * v6 + v7 + 12) || (*(_DWORD *)(*(_DWORD *)(a3 + 32) + v8 + 32) >> 6) & 1 )
    {
      if ( *(_BYTE *)(*(_DWORD *)(a3 + 24) + v6) != 1 )
        goto LABEL_26;
      v12 = v8 + *(_DWORD *)(a3 + 32);
      if ( !(v5 & *(_DWORD *)(v12 + 20)) || !(*(_BYTE *)(v12 + 28) & *(_BYTE *)a3) || !v9 )
        goto LABEL_26;
      v13 = 24 * v6;
      *(_DWORD *)(*(_DWORD *)(a3 + 64) + v13 + 12) = sub_1007C040();
      v14 = *(void (__cdecl **)(int, int))(*(_DWORD *)(a3 + 32) + v8 + 44);
      if ( v14 && !(*(_BYTE *)(*(_DWORD *)(a3 + 64) + v13 + 6) & 4) )
        v14(a1, a3);
      v15 = *(_BYTE *)(a3 + 1);
      v16 = *(_DWORD *)(a3 + 64);
      v30 = *(_DWORD *)(a3 + 16);
      v31 = v15;
      v29 = v9;
      v17 = *(_WORD *)(v16 + v13 + 4) + 20;
      v18 = (unsigned int)(unsigned __int16)v17 < *(_DWORD *)(a3 + 20);
      v19 = (unsigned __int16)v17 == *(_DWORD *)(a3 + 20);
      v33 = *(_WORD *)(v16 + v13 + 4) + 20;
      if ( !v18 && !v19 )
      {
        sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3198, 1, 0);
        v17 = v33;
      }
      v19 = *(_BYTE *)(a3 + 1) == 6;
      v32 = *(_BYTE *)(*(_DWORD *)(a3 + 32) + v8 + 32) & 1;
      if ( v19 || !(a2 & *(_DWORD *)(a3 + 84)) )
      {
        v28 = 1;
        v20 = *(_DWORD *)(a3 + 16) + 12;
      }
      else
      {
        v20 = *(_DWORD *)(a3 + 16);
        v28 = 0;
        v33 = v17 - 12;
      }
      sub_1007C110(*(_DWORD *)(a3 + 60), -1);
      v21 = *(_DWORD *)(a3 + 64) + v13;
      v22 = *(_BYTE *)(v21 + 1);
      LOWORD(v34) = a1;
      v23 = *(_WORD *)(v21 + 4);
      BYTE1(v35) = *(_BYTE *)(v21 + 2);
      HIWORD(v34) = v23;
      *(_DWORD *)v20 = v34;
      LOBYTE(v35) = v22;
      *(_DWORD *)(v20 + 4) = v35;
      memcpy(
        (void *)(v20 + 8),
        (const void *)(*(_DWORD *)(a3 + 28) + *(_DWORD *)(*(_DWORD *)(a3 + 32) + v8 + 4)),
        *(_WORD *)(*(_DWORD *)(a3 + 64) + v13 + 4));
      if ( v28 )
      {
        v24 = sub_1007B8C0(
                (unsigned int *)(*(_DWORD *)(a3 + 16) + 12),
                *(_WORD *)(*(_DWORD *)(a3 + 64) + v13 + 4) + 8,
                0xFFFFFFFF);
        v25 = *(_DWORD *)(a3 + 16);
        v34 = 327678;
        LOWORD(v35) = 1;
        *(_DWORD *)v25 = 327678;
        *(_DWORD *)(v25 + 4) = v35;
        *(_DWORD *)(v25 + 8) = v24;
      }
      v26 = j_HWM_pvg_hsdb_put(&v29);
      sub_1007C0F0(*(_DWORD *)(a3 + 60));
      if ( v26 < 0 )
LABEL_26:
        v27 = 0;
      result = v27;
    }
    else
    {
      v10 = *(_BYTE *)(a3 + 1);
      v11 = sub_10025420(a3, v34);
      _snprintf(&v36, 0x64u, "%d-%s is prdc pipe=%d", (unsigned __int16)a1, v11, v10);
      sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3123, 0, &v36);
      result = 0;
    }
  }
  return result;
}
// 1007C830: using guessed type int __cdecl j_HWM_pvg_hsdb_put(_DWORD);

//----- (10023A50) --------------------------------------------------------
char __cdecl sub_10023A50(int a1, int a2, void *a3, char a4, int a5)
{
  signed __int16 v5; // ax@1
  char result; // al@2
  int v7; // ebp@3
  int v8; // ebx@3
  int v9; // eax@3
  int v10; // ecx@3
  int v11; // edi@3
  int v12; // ST24_4@4
  const char *v13; // eax@4
  int v14; // eax@6
  int v15; // ebp@9
  char v16; // cl@9
  int v17; // edx@9
  __int16 v18; // ax@9
  bool v19; // cf@9
  bool v20; // zf@9
  int v21; // edi@13
  char v22; // bl@13
  int v23; // eax@15
  __int16 v24; // cx@15
  int v25; // ecx@15
  void *v26; // edx@15
  unsigned int v27; // eax@16
  int v28; // ecx@16
  int v29; // edi@17
  char v30; // [sp+7h] [bp-81h]@3
  int v31; // [sp+8h] [bp-80h]@9
  int v32; // [sp+Ch] [bp-7Ch]@9
  char v33; // [sp+10h] [bp-78h]@9
  char v34; // [sp+11h] [bp-77h]@11
  __int16 v35; // [sp+12h] [bp-76h]@9
  void *v36; // [sp+14h] [bp-74h]@1
  int v37; // [sp+18h] [bp-70h]@1
  int v38; // [sp+1Ch] [bp-6Ch]@15
  char v39; // [sp+20h] [bp-68h]@4

  v36 = a3;
  v5 = sub_10022000(a1, a5);
  v37 = (unsigned __int16)v5;
  if ( v5 == -1 )
  {
    result = 0;
  }
  else
  {
    v7 = (unsigned __int16)v5;
    v8 = 52 * (unsigned __int16)v5;
    v9 = *(_DWORD *)(a5 + 32) + v8;
    v10 = *(_DWORD *)(a5 + 72);
    v11 = a2 & ~v10 & (*(_DWORD *)(v9 + 24) | 0xC00000);
    v30 = 0;
    if ( *(_DWORD *)(v9 + 12) )
    {
      v12 = *(_BYTE *)(a5 + 1);
      v13 = sub_10025420(a5, v37);
      _snprintf(&v39, 0x64u, "%d-%s is prdc pipe=%d", (unsigned __int16)a1, v13, v12);
      sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3486, 0, &v39);
      result = 0;
    }
    else
    {
      if ( *(_BYTE *)(*(_DWORD *)(a5 + 24) + v7) == 1
        && (v14 = v8 + *(_DWORD *)(a5 + 32), v10 & *(_DWORD *)(v14 + 20))
        && *(_BYTE *)(v14 + 28) & *(_BYTE *)a5
        && v11 )
      {
        v15 = 24 * v7;
        *(_DWORD *)(*(_DWORD *)(a5 + 64) + v15 + 12) = sub_1007C040();
        v16 = *(_BYTE *)(a5 + 1);
        v17 = *(_DWORD *)(a5 + 64);
        v32 = *(_DWORD *)(a5 + 16);
        v33 = v16;
        v31 = v11;
        v18 = *(_WORD *)(v17 + v15 + 4) + 20;
        v19 = (unsigned int)(unsigned __int16)v18 < *(_DWORD *)(a5 + 20);
        v20 = (unsigned __int16)v18 == *(_DWORD *)(a5 + 20);
        v35 = *(_WORD *)(v17 + v15 + 4) + 20;
        if ( !v19 && !v20 )
        {
          sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3535, 1, 0);
          v18 = v35;
        }
        v20 = *(_BYTE *)(a5 + 1) == 6;
        v34 = *(_BYTE *)(*(_DWORD *)(a5 + 32) + v8 + 32) & 1;
        if ( v20 || !(a2 & *(_DWORD *)(a5 + 84)) )
        {
          v22 = 1;
          v21 = *(_DWORD *)(a5 + 16) + 12;
        }
        else
        {
          v21 = *(_DWORD *)(a5 + 16);
          v22 = 0;
          v35 = v18 - 12;
        }
        sub_1007C110(*(_DWORD *)(a5 + 60), -1);
        v23 = *(_DWORD *)(a5 + 64) + v15;
        LOWORD(v37) = a1;
        v24 = *(_WORD *)(v23 + 4);
        LOBYTE(v23) = *(_BYTE *)(v23 + 2);
        HIWORD(v37) = v24;
        v25 = v37;
        LOBYTE(v38) = a4;
        BYTE1(v38) = v23;
        *(_DWORD *)(v21 + 4) = v38;
        v26 = v36;
        *(_DWORD *)v21 = v25;
        memcpy((void *)(v21 + 8), v26, *(_WORD *)(*(_DWORD *)(a5 + 64) + v15 + 4));
        if ( v22 )
        {
          v27 = sub_1007B8C0(
                  (unsigned int *)(*(_DWORD *)(a5 + 16) + 12),
                  *(_WORD *)(*(_DWORD *)(a5 + 64) + v15 + 4) + 8,
                  0xFFFFFFFF);
          v28 = *(_DWORD *)(a5 + 16);
          v37 = 327678;
          LOWORD(v38) = 1;
          *(_DWORD *)v28 = 327678;
          *(_DWORD *)(v28 + 4) = v38;
          *(_DWORD *)(v28 + 8) = v27;
        }
        v29 = j_HWM_pvg_hsdb_put(&v31);
        sub_1007C0F0(*(_DWORD *)(a5 + 60));
        if ( v29 >= 0 )
          v30 = 1;
      }
      else
      {
        v30 = 0;
      }
      result = v30;
    }
  }
  return result;
}
// 1007C830: using guessed type int __cdecl j_HWM_pvg_hsdb_put(_DWORD);

//----- (10023CE0) --------------------------------------------------------
int __cdecl sub_10023CE0(int a1)
{
  int result; // eax@1
  int v2; // edi@2
  int v3; // eax@2
  int v4; // ecx@2
  int v5; // edx@2
  int v6; // edx@3
  void (__cdecl *v7)(int, int); // eax@5
  int i; // [sp+4h] [bp-8h]@1
  unsigned int v9; // [sp+8h] [bp-4h]@1

  v9 = sub_1007C040();
  result = 0;
  for ( i = 0; i < *(_DWORD *)(a1 + 8); ++i )
  {
    v2 = *(_WORD *)(*(_DWORD *)(a1 + 68) + 2 * result);
    v3 = (unsigned __int16)sub_10022000(v2, a1);
    v4 = 24 * (unsigned __int16)v3;
    v5 = v4 + *(_DWORD *)(a1 + 64);
    if ( !*(_BYTE *)v5 )
    {
      v6 = *(_DWORD *)(v5 + 16);
      if ( !v6 || v9 > v6 + *(_DWORD *)(a1 + 36) + *(_DWORD *)(52 * v3 + *(_DWORD *)(a1 + 32) + 16) )
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 64) + v4 + 1) = 0;
        *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64)) = 1;
        v7 = *(void (__cdecl **)(int, int))(52 * v3 + *(_DWORD *)(a1 + 32) + 40);
        if ( v7 )
        {
          if ( !(*(_BYTE *)(*(_DWORD *)(a1 + 64) + v4 + 6) & 2) )
            v7(v2, a1);
        }
      }
    }
    result = i + 1;
  }
  return result;
}

//----- (10023DA0) --------------------------------------------------------
char __cdecl sub_10023DA0(int a1, int a2, void *a3)
{
  return sub_10022450(a1, a2, a3, 0xFFFFu);
}

//----- (10023DC0) --------------------------------------------------------
char __cdecl sub_10023DC0(int a1, int a2, void *a3, unsigned __int16 *a4)
{
  return sub_10022690(a1, a2, a3, a4, 0xFFFFu);
}

//----- (10023DF0) --------------------------------------------------------
int __cdecl sub_10023DF0(int a1)
{
  int v1; // esi@1
  int v2; // ecx@3
  signed __int16 v3; // ax@5
  int v4; // ebp@6
  int v5; // edi@6
  int v6; // ecx@6
  unsigned int v7; // edi@6
  int v8; // ST10_4@10
  int v10; // [sp+8h] [bp-8h]@1
  unsigned int v11; // [sp+Ch] [bp-4h]@4
  int v12; // [sp+14h] [bp+4h]@3

  v1 = a1;
  v10 = sub_1007C040();
  if ( *(_BYTE *)(a1 + 3) >= 4u )
    sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1321, 1, 0);
  sub_1007C110(*(_DWORD *)(a1 + 60), -1);
  v2 = 0;
  v12 = 0;
  if ( *(_DWORD *)(v1 + 4) > 0 )
  {
    v11 = 0;
    do
    {
      v3 = sub_10022000(v2, v1);
      if ( v3 != -1 )
      {
        v4 = (unsigned __int16)v3;
        v5 = 52 * (unsigned __int16)v3;
        memset(
          (void *)(*(_DWORD *)(v1 + 28) + *(_DWORD *)(*(_DWORD *)(v1 + 32) + v5 + 4)),
          0,
          *(_WORD *)(*(_DWORD *)(v1 + 32) + v5));
        v6 = 24 * v4;
        *(_BYTE *)(v6 + *(_DWORD *)(v1 + 64)) = 0;
        *(_BYTE *)(*(_DWORD *)(v1 + 64) + v6 + 1) = 0;
        *(_BYTE *)(*(_DWORD *)(v1 + 64) + v6 + 2) = -1;
        *(_WORD *)(*(_DWORD *)(v1 + 64) + v6 + 4) = *(_WORD *)(v5 + *(_DWORD *)(v1 + 32));
        *(_DWORD *)(*(_DWORD *)(v1 + 64) + v6 + 16) = 0;
        *(_DWORD *)(*(_DWORD *)(v1 + 64) + v6 + 12) = 0;
        *(_BYTE *)(*(_DWORD *)(v1 + 64) + v6 + 3) = 0;
        *(_BYTE *)(*(_DWORD *)(v1 + 64) + v6 + 6) = 0;
        v7 = *(_DWORD *)(*(_DWORD *)(v1 + 32) + v5 + 12);
        if ( v7 )
          *(_DWORD *)(*(_DWORD *)(v1 + 64) + v6 + 8) = v10 + 25 * (v11 % (v7 / 0x19));
        else
          *(_DWORD *)(*(_DWORD *)(v1 + 64) + v6 + 8) = v10;
      }
      v2 = v12++ + 1;
      v11 = (unsigned __int16)v12;
    }
    while ( (signed int)(unsigned __int16)v12 < *(_DWORD *)(v1 + 4) );
  }
  v8 = *(_DWORD *)(v1 + 60);
  *(_DWORD *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 12) = 0;
  sub_1007C0F0(v8);
  sub_100228A0(v1);
  return sub_10022950(v1);
}

//----- (10023F40) --------------------------------------------------------
char __cdecl sub_10023F40(int a1, int a2)
{
  signed __int16 v2; // ax@1
  int v3; // edx@1
  int v4; // esi@2
  int v5; // edi@2
  int v6; // eax@2
  int v7; // edx@2

  v2 = sub_10022000(a1, a2);
  if ( v2 == -1 )
  {
    LOBYTE(v6) = sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3035, 0, 0);
  }
  else
  {
    v4 = *(_DWORD *)(v3 + 28) + *(_DWORD *)(52 * (unsigned __int16)v2 + *(_DWORD *)(v3 + 32) + 4);
    v5 = *(_WORD *)v4;
    LOWORD(v6) = sub_10022000(v5, v3);
    if ( (_WORD)v6 != -1 )
    {
      v6 = 3 * (unsigned __int16)v6;
      if ( *(_BYTE *)(*(_DWORD *)(v7 + 64) + 8 * v6 + 1) == 1 )
        LOBYTE(v6) = sub_10023790(v5, *(_DWORD *)(v4 + 4), v7);
    }
  }
  return v6;
}

//----- (10023FC0) --------------------------------------------------------
char sub_10023FC0()
{
  return sub_10025570(0);
}

//----- (10023FD0) --------------------------------------------------------
int __cdecl sub_10023FD0(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10332F54 |= a1;
  return result;
}
// 10332F54: using guessed type int dword_10332F54;

//----- (10023FE0) --------------------------------------------------------
int __cdecl sub_10023FE0(int a1, int a2, unsigned __int16 a3, char a4, char a5)
{
  unsigned __int16 v5; // di@1
  _WORD *v6; // edx@2
  int v7; // esi@2
  unsigned __int16 v8; // ax@3
  int v9; // eax@4

  v5 = 0;
  if ( a3 )
  {
    v6 = dword_1023E2E0;
    v7 = a1;
    do
    {
      v8 = *(_WORD *)(a2 + 2 * v5);
      if ( v8 >= 0xBCCu )
        break;
      LOWORD(v9) = v6[v8 + 223904];
      if ( (unsigned __int16)v9 < 0x979u )
      {
        v9 = (unsigned __int16)v9;
        if ( (a1 & (*(_DWORD *)&v6[26 * (unsigned __int16)v9 + 160866] | *(_DWORD *)&v6[26 * (unsigned __int16)v9
                                                                                      + 160864])) == a1
          || v7 & 0xC00000 )
        {
          sub_1004F290(a4, (_BYTE *)v6 + v9, &byte_1023E2E8[v9], a5);
          v6 = dword_1023E2E0;
        }
      }
      ++v5;
    }
    while ( v5 < a3 );
  }
  sub_100228A0((int)&byte_10332F00);
  return sub_10022950((int)&byte_10332F00);
}
// 10332F00: using guessed type char byte_10332F00;

//----- (10024090) --------------------------------------------------------
int __cdecl sub_10024090(int a1)
{
  int result; // eax@1

  result = ~a1;
  dword_10332F54 &= ~a1;
  return result;
}
// 10332F54: using guessed type int dword_10332F54;

//----- (100240A0) --------------------------------------------------------
char __cdecl sub_100240A0(int a1, int a2)
{
  int v2; // eax@1
  int v3; // esi@2
  int v4; // ebp@2
  unsigned __int16 v5; // di@2
  unsigned __int16 v6; // cx@3
  int v7; // edi@8
  unsigned __int16 v8; // di@9
  int v9; // eax@10
  int v11; // [sp+4h] [bp-530h]@2
  __int16 v12; // [sp+8h] [bp-52Ch]@9
  int v13; // [sp+Ch] [bp-528h]@10
  int v14; // [sp+10h] [bp-524h]@12

  LOWORD(v2) = sub_100223C0(a2, a1);
  if ( (_WORD)v2 != -1 )
  {
    v3 = *(_DWORD *)(a2 + 28) + *(_DWORD *)(52 * (unsigned __int16)v2 + *(_DWORD *)(a2 + 32) + 4);
    v4 = 24 * (unsigned __int16)v2;
    v5 = *(_WORD *)(*(_DWORD *)(a2 + 64) + v4 + 4);
    v2 = sub_1007D150(*(_BYTE *)v3);
    v11 = v2;
    if ( v5 > 4u )
    {
      v6 = *(_WORD *)(v3 + 2);
      if ( v6 <= 0x1F4u && 2 * (unsigned int)v6 <= (unsigned int)v5 - 4 && v2 != -1 )
      {
        if ( *(_BYTE *)v3 == 1 )
        {
          LOBYTE(v2) = sub_10023FE0(*(_DWORD *)(*(_DWORD *)(a2 + 64) + v4 + 20), v3 + 4, v6, 1, 1);
        }
        else
        {
          v7 = sub_10043FF0((_DWORD *)(a2 + 1), 1u, (int)&unk_100D8B84, 1, 4, -1);
          v2 = sub_10043FF0((_DWORD *)v3, 1u, (int)&unk_100D8B84, 1, 4, 4);
          if ( v2 >= v7 )
          {
            LOBYTE(v2) = sub_10042930("..\\lib\\adl\\iop_hsdb_pkt.c", 787, 0, 0);
          }
          else
          {
            v8 = 0;
            v12 = -32705;
            if ( *(_WORD *)(v3 + 2) )
            {
              do
              {
                v13 = *(_DWORD *)(*(_DWORD *)(a2 + 64) + v4 + 20);
                v9 = *(_WORD *)(v3 + 2) - v8;
                if ( v9 >= 100 )
                  LOWORD(v9) = 100;
                LOWORD(v14) = v9;
                memcpy((char *)&v14 + 2, (const void *)(v3 + 2 * v8 + 4), 2 * (unsigned __int16)v9);
                LOBYTE(v2) = sub_1007C170(v11, (int)&v12, 50000, 0);
                v8 += v14;
              }
              while ( v8 < *(_WORD *)(v3 + 2) );
            }
          }
        }
      }
    }
  }
  return v2;
}

//----- (10024240) --------------------------------------------------------
char sub_10024240()
{
  memset(byte_1023E2E8, 0, 0xBCCu);
  memset(dword_1023E2E0, 0, 0x979u);
  sub_1004F470(1, 0xBCCu, (int)dword_1023E2E0, (int)byte_1023E2E8, (int)dword_1023E2E0 + 447808);
  sub_10050650(1, 0xBCCu, (int)dword_1023E2E0, (int)byte_1023E2E8, (int)dword_1023E2E0 + 447808);
  sub_1004FB20(1, 0xBCCu, (int)dword_1023E2E0, (int)byte_1023E2E8, (int)dword_1023E2E0 + 447808);
  sub_10050440(1, 0xBCCu, (int)dword_1023E2E0, (int)byte_1023E2E8, (int)dword_1023E2E0 + 447808);
  sub_1004F9F0(1, 0xBCCu, (int)dword_1023E2E0, (int)byte_1023E2E8, (int)dword_1023E2E0 + 447808);
  sub_1004FA50(1, 0xBCCu, (int)dword_1023E2E0, (int)byte_1023E2E8, (int)dword_1023E2E0 + 447808);
  sub_10050870(1, 0xBCCu, (int)dword_1023E2E0, (int)byte_1023E2E8, (int)dword_1023E2E0 + 447808);
  sub_100508D0(1, 0xBCCu, (int)dword_1023E2E0, (int)byte_1023E2E8, (int)dword_1023E2E0 + 447808);
  sub_100502D0(1, 0xBCCu, (int)dword_1023E2E0, (int)byte_1023E2E8, (int)dword_1023E2E0 + 447808);
  sub_1004FAA0(1, 0xBCCu, (int)dword_1023E2E0, (int)byte_1023E2E8, (int)dword_1023E2E0 + 447808);
  return sub_100503B0(1, 0xBCCu, (int)dword_1023E2E0, (int)byte_1023E2E8, (int)dword_1023E2E0 + 447808);
}

//----- (100243C0) --------------------------------------------------------
signed int sub_100243C0()
{
  void *v0; // ecx@4
  char *v1; // ecx@6
  unsigned int v2; // eax@6
  int v3; // edx@9
  int v4; // edx@11
  int v5; // edx@13
  int v6; // edx@15
  signed int result; // eax@19
  int v8; // edi@20
  void **v9; // esi@20
  size_t v10; // eax@21

  if ( sub_1007CD60((LONG)&off_100DC904) )
  {
    memcpy((char *)dword_1023E2E0 + 321708, &unk_100B9EF0, 0x1EC94u);
    memcpy((char *)dword_1023E2E0 + 447808, &unk_100D8B88, 0x1798u);
  }
  else
  {
    sub_10042930("..\\lib\\adl\\iop_hsdb_pkt.c", 1037, 1, 0);
  }
  if ( sub_100509C0() == 1 && sub_100460C0(v0) == 4 )
  {
    v1 = (char *)dword_1023E2E0;
    v2 = 321776;
    do
    {
      if ( *(_DWORD *)&v1[v2 - 52] )
      {
        *(_DWORD *)&v1[v2 - 52] += 1500;
        v1 = (char *)dword_1023E2E0;
      }
      v3 = *(_DWORD *)&v1[v2];
      if ( v3 )
      {
        *(_DWORD *)&v1[v2] = v3 + 1500;
        v1 = (char *)dword_1023E2E0;
      }
      v4 = *(_DWORD *)&v1[v2 + 52];
      if ( v4 )
      {
        *(_DWORD *)&v1[v2 + 52] = v4 + 1500;
        v1 = (char *)dword_1023E2E0;
      }
      v5 = *(_DWORD *)&v1[v2 + 104];
      if ( v5 )
      {
        *(_DWORD *)&v1[v2 + 104] = v5 + 1500;
        v1 = (char *)dword_1023E2E0;
      }
      v6 = *(_DWORD *)&v1[v2 + 156];
      if ( v6 )
      {
        *(_DWORD *)&v1[v2 + 156] = v6 + 1500;
        v1 = (char *)dword_1023E2E0;
      }
      v2 += 260;
    }
    while ( v2 < 0x6D584 );
  }
  sub_1007C8F0((int)&off_100DC904);
  if ( sub_1007CD60((LONG)&off_100DE584) )
  {
    v8 = 0;
    v9 = (void **)off_100DA320;
    do
    {
      v10 = sub_100422A0(*v9, 0x27u);
      memcpy((void *)(v8 + dword_1023E2E4), *v9, v10);
      ++v9;
      v8 += 39;
    }
    while ( (signed int)v9 < (signed int)&off_100DC904 );
    result = sub_1007C8F0((int)&off_100DE584);
  }
  else
  {
    sub_10042930("..\\lib\\adl\\iop_hsdb_pkt.c", 1087, 1, 0);
    result = sub_1007C8F0((int)&off_100DE584);
  }
  return result;
}
// 100DA320: using guessed type char *off_100DA320[2426];
// 100DC904: using guessed type char *off_100DC904;
// 100DE584: using guessed type char *off_100DE584;
// 1023E2E4: using guessed type int dword_1023E2E4;

//----- (10024550) --------------------------------------------------------
int sub_10024550()
{
  sub_10024240();
  sub_100228A0((int)&byte_10332F00);
  return sub_10022950((int)&byte_10332F00);
}
// 10332F00: using guessed type char byte_10332F00;

//----- (10024570) --------------------------------------------------------
int sub_10024570()
{
  void *v0; // ecx@1
  void *v1; // ecx@1
  char v2; // al@4
  void *v3; // ecx@4
  int result; // eax@8

  dword_1023E2E0 = (void *)-15;
  dword_1023E2E4 = -15;
  sub_100243C0();
  dword_10332F18 = (int)dword_1023E2E0;
  dword_10332F10 = (int)&unk_10320420;
  dword_10332F14 = 22568;
  dword_10332F1C = (int)dword_1023E2E0 + 60628;
  dword_10332F20 = (int)&unk_100B9EF0;
  dword_10332F24 = 12;
  dword_10332F28 = (int)&unk_100D8B88;
  byte_10332F01 = 1;
  dword_10332F04 = 3020;
  dword_10332F2C = (int)off_100DA320;
  dword_10332F30 = (int)&unk_10325C60;
  dword_10332F34 = 2425;
  dword_10332F38 = (int)&unk_100DC918;
  byte_10332F02 = 3;
  byte_10332F03 = sub_1004F2D0(v0);
  dword_10332F50 = 0;
  dword_10332F3C = 90;
  dword_10332F40 = (int)dword_1023E2E0 + 2428;
  dword_10332F44 = (int)&unk_103319E0;
  dword_10332F54 = 0;
  if ( sub_100509C0() == 1 && sub_100460C0(v1) == 4 )
    dword_10332F20 = (int)dword_1023E2E0 + 321708;
  v2 = sub_100460C0(v1);
  byte_10332F00 = v2;
  if ( v2 == 8 )
  {
    byte_10332F00 = 11;
  }
  else if ( v2 == 4 )
  {
    byte_10332F00 = 5;
  }
  dword_10332F48 = sub_100429D0(v3);
  dword_10332F4C = (int)dword_1023E2E0 + 453848;
  sub_10024240();
  result = sub_10023DF0((int)&byte_10332F00);
  *((_DWORD *)dword_1023E2E0 + 114675) = dword_10332F0C;
  return result;
}
// 100DA320: using guessed type char *off_100DA320[2426];
// 1023E2E4: using guessed type int dword_1023E2E4;
// 10332F00: using guessed type char byte_10332F00;
// 10332F01: using guessed type char byte_10332F01;
// 10332F02: using guessed type char byte_10332F02;
// 10332F03: using guessed type char byte_10332F03;
// 10332F04: using guessed type int dword_10332F04;
// 10332F0C: using guessed type int dword_10332F0C;
// 10332F10: using guessed type int dword_10332F10;
// 10332F14: using guessed type int dword_10332F14;
// 10332F18: using guessed type int dword_10332F18;
// 10332F1C: using guessed type int dword_10332F1C;
// 10332F20: using guessed type int dword_10332F20;
// 10332F24: using guessed type int dword_10332F24;
// 10332F28: using guessed type int dword_10332F28;
// 10332F2C: using guessed type int dword_10332F2C;
// 10332F30: using guessed type int dword_10332F30;
// 10332F34: using guessed type int dword_10332F34;
// 10332F38: using guessed type int dword_10332F38;
// 10332F3C: using guessed type int dword_10332F3C;
// 10332F40: using guessed type int dword_10332F40;
// 10332F44: using guessed type int dword_10332F44;
// 10332F48: using guessed type int dword_10332F48;
// 10332F4C: using guessed type int dword_10332F4C;
// 10332F50: using guessed type int dword_10332F50;
// 10332F54: using guessed type int dword_10332F54;

//----- (100246D0) --------------------------------------------------------
int __cdecl sub_100246D0(char a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 7 )
    result = (unsigned __int16)word_100DF3EC[a1];
  return result;
}
// 100DF3EC: using guessed type __int16 word_100DF3EC[];

//----- (100246F0) --------------------------------------------------------
signed int sub_100246F0()
{
  signed int result; // eax@1

  result = -15;
  dword_1023EED0 = -15;
  dword_1023EEDC = -15;
  dword_1023EEB8 = -15;
  dword_1023EEE0 = -15;
  dword_1023EECC = -15;
  dword_1023EEBC = -15;
  dword_1023EEB4 = -15;
  dword_1023EEC8 = -15;
  dword_1023EED8 = -15;
  dword_1023EED4 = -15;
  dword_1023EEC4 = -15;
  dword_1023EEC0 = -15;
  return result;
}
// 1023EEB4: using guessed type int dword_1023EEB4;
// 1023EEB8: using guessed type int dword_1023EEB8;
// 1023EEBC: using guessed type int dword_1023EEBC;
// 1023EEC0: using guessed type int dword_1023EEC0;
// 1023EEC4: using guessed type int dword_1023EEC4;
// 1023EEC8: using guessed type int dword_1023EEC8;
// 1023EECC: using guessed type int dword_1023EECC;
// 1023EED0: using guessed type int dword_1023EED0;
// 1023EED4: using guessed type int dword_1023EED4;
// 1023EED8: using guessed type int dword_1023EED8;
// 1023EEDC: using guessed type int dword_1023EEDC;
// 1023EEE0: using guessed type int dword_1023EEE0;

//----- (10024740) --------------------------------------------------------
signed int __usercall sub_10024740@<eax>(char a1@<al>, int a2@<ecx>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = sub_1007CC90((int)&off_100DF40C);
      break;
    case 0:
      result = sub_1007CC90((int)&off_100DF420);
      break;
    case 1:
      result = sub_1007CC90((int)&off_100DF434);
      break;
    case 2:
      result = sub_1007CC90((int)&off_100DF45C);
      break;
    case 3:
      result = sub_1007CC90((int)&off_100DF448);
      break;
    case 5:
      result = sub_1007CC90((int)&off_100DF470);
      break;
    default:
      result = sub_1007CC90(a2);
      break;
  }
  return result;
}
// 100DF40C: using guessed type char *off_100DF40C;
// 100DF420: using guessed type char *off_100DF420;
// 100DF434: using guessed type char *off_100DF434;
// 100DF448: using guessed type char *off_100DF448;
// 100DF45C: using guessed type char *off_100DF45C;
// 100DF470: using guessed type char *off_100DF470;

//----- (100247E0) --------------------------------------------------------
int __usercall sub_100247E0@<eax>(char a1@<al>)
{
  return sub_1007C0F0(dword_100DEF3C[a1]);
}
// 100DEF3C: using guessed type int dword_100DEF3C[];

//----- (10024800) --------------------------------------------------------
int __usercall sub_10024800@<eax>(char a1@<al>)
{
  return sub_1007C110(dword_100DEF3C[a1], 10);
}
// 100DEF3C: using guessed type int dword_100DEF3C[];

//----- (10024820) --------------------------------------------------------
signed __int16 __usercall sub_10024820@<ax>(char a1@<al>, unsigned __int16 a2@<si>)
{
  signed __int16 result; // ax@3
  bool v3; // cf@8

  switch ( a1 )
  {
    case 6:
      if ( a2 < 0x2E5u )
      {
        if ( !(unsigned __int8)sub_10024740(a1, a1) )
        {
          sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3201, 0, 0);
          goto LABEL_6;
        }
        result = *(_WORD *)(dword_1023EED0 + 2 * a2 + 241212);
        v3 = (unsigned __int16)result < 0x256u;
        goto LABEL_31;
      }
      sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3186, 0, 0);
      return -1;
    default:
      goto LABEL_6;
    case 0:
      if ( a2 >= 0x344u )
      {
        sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3224, 0, 0);
        return -1;
      }
      if ( (unsigned __int8)sub_10024740(a1, a1) )
      {
        result = *(_WORD *)(dword_1023EEDC + 2 * a2 + 284664);
        v3 = (unsigned __int16)result < 0x211u;
        goto LABEL_31;
      }
      if ( sub_10045F70(15000) )
        goto LABEL_6;
      sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3242, 0, 0);
      return 0;
    case 1:
      if ( a2 >= 0xBCCu )
      {
        sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3265, 0, 0);
        return -1;
      }
      result = *(_WORD *)(dword_10332F28 + 2 * a2);
      v3 = (unsigned __int16)result < 0x979u;
      goto LABEL_31;
    case 2:
      if ( a2 >= 0x388u )
      {
        sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3302, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10024740(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_1023EEE0 + 2 * a2 + 356016);
      v3 = (unsigned __int16)result < 0x23Du;
      goto LABEL_31;
    case 3:
      if ( a2 >= 0xBEu )
      {
        sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3339, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10024740(a1, a1) )
      {
        sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3354, 0, 0);
        return 0;
      }
      result = *(_WORD *)(dword_1023EECC + 2 * a2 + 23096);
      v3 = (unsigned __int16)result < 0x52u;
      goto LABEL_31;
    case 5:
      if ( a2 < 4u )
      {
        if ( (unsigned __int8)sub_10024740(a1, a1) )
        {
          result = *(_WORD *)(dword_1023EEBC + 2 * a2 + 1804);
          v3 = (unsigned __int16)result < 4u;
LABEL_31:
          if ( !v3 )
            result = -1;
        }
        else
        {
LABEL_6:
          result = 0;
        }
      }
      else
      {
        sub_10042930("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3377, 0, 0);
        result = -1;
      }
      return result;
  }
}
// 1023EEBC: using guessed type int dword_1023EEBC;
// 1023EECC: using guessed type int dword_1023EECC;
// 1023EED0: using guessed type int dword_1023EED0;
// 1023EEDC: using guessed type int dword_1023EEDC;
// 1023EEE0: using guessed type int dword_1023EEE0;
// 10332F28: using guessed type int dword_10332F28;

//----- (10024A50) --------------------------------------------------------
char __cdecl sub_10024A50(char a1, unsigned __int16 a2, _BYTE *a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v6; // eax@8

  v3 = sub_10024820(a1, a2);
  if ( v3 != -1 && !sub_10024800(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10024740(a1, v4) != 1 )
          goto LABEL_16;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_1023EED0);
        sub_100247E0(a1);
        return 1;
      case 0:
        if ( (unsigned __int8)sub_10024740(a1, v4) != 1 )
          goto LABEL_16;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_1023EEDC);
        sub_100247E0(a1);
        return 1;
      case 1:
        v6 = dword_10332F18;
        goto LABEL_15;
      case 2:
        if ( (unsigned __int8)sub_10024740(a1, v4) != 1 )
          goto LABEL_16;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_1023EEE0);
        sub_100247E0(a1);
        return 1;
      case 3:
        if ( (unsigned __int8)sub_10024740(a1, v4) != 1 )
          goto LABEL_16;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_1023EECC);
        sub_100247E0(a1);
        return 1;
      case 5:
        if ( (unsigned __int8)sub_10024740(a1, v4) != 1 )
          goto LABEL_16;
        v6 = dword_1023EEBC;
LABEL_15:
        *a3 = *(_BYTE *)((unsigned __int16)v3 + v6);
        sub_100247E0(a1);
        return 1;
      default:
LABEL_16:
        sub_100247E0(a1);
        break;
    }
  }
  return 0;
}
// 1023EEBC: using guessed type int dword_1023EEBC;
// 1023EECC: using guessed type int dword_1023EECC;
// 1023EED0: using guessed type int dword_1023EED0;
// 1023EEDC: using guessed type int dword_1023EEDC;
// 1023EEE0: using guessed type int dword_1023EEE0;
// 10332F18: using guessed type int dword_10332F18;

//----- (10024BA0) --------------------------------------------------------
char __cdecl sub_10024BA0(char a1, unsigned __int16 a2, void *a3)
{
  int v3; // ecx@1
  signed __int16 v4; // si@1
  char result; // al@2

  v4 = sub_10024820(a1, a2);
  if ( v4 == -1 )
  {
    result = 0;
  }
  else
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10024740(a1, v3) != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1023EED0 + 210116), 0x34u);
        result = 1;
        break;
      case 0:
        if ( (unsigned __int8)sub_10024740(a1, v3) != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1023EEDC + 257156), 0x34u);
        result = 1;
        break;
      case 1:
        qmemcpy(a3, (const void *)(dword_10332F20 + 52 * (unsigned __int16)v4), 0x34u);
        result = 1;
        break;
      case 2:
        result = sub_10024740(a1, v3);
        if ( result != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1023EEE0 + 326220), 0x34u);
        break;
      case 3:
        if ( (unsigned __int8)sub_10024740(a1, v3) != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1023EECC + 18832), 0x34u);
        result = 1;
        break;
      case 5:
        if ( (unsigned __int8)sub_10024740(a1, v3) != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1023EEBC + 1596), 0x34u);
        result = 1;
        break;
      default:
LABEL_15:
        result = 0;
        break;
    }
  }
  return result;
}
// 1023EEBC: using guessed type int dword_1023EEBC;
// 1023EECC: using guessed type int dword_1023EECC;
// 1023EED0: using guessed type int dword_1023EED0;
// 1023EEDC: using guessed type int dword_1023EEDC;
// 1023EEE0: using guessed type int dword_1023EEE0;
// 10332F20: using guessed type int dword_10332F20;

//----- (10024D10) --------------------------------------------------------
char __cdecl sub_10024D10(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v5; // eax@5

  v3 = sub_10024820(a1, a2);
  if ( v3 != -1 && !sub_10024800(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10024740(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_1023EED0 + 24 * ((unsigned __int16)v3 + 25);
        goto LABEL_15;
      case 0:
        if ( (unsigned __int8)sub_10024740(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_1023EEDC + 24 * (unsigned __int16)v3 + 532;
        goto LABEL_15;
      case 1:
        v5 = dword_10332F40 + 24 * (unsigned __int16)v3;
        goto LABEL_15;
      case 2:
        if ( (unsigned __int8)sub_10024740(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_1023EEE0 + 24 * ((unsigned __int16)v3 + 24);
        goto LABEL_15;
      case 3:
        if ( (unsigned __int8)sub_10024740(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_1023EECC + 24 * (unsigned __int16)v3 + 84;
        goto LABEL_15;
      case 5:
        if ( (unsigned __int8)sub_10024740(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_1023EEBC + 24 * (unsigned __int16)v3 + 4;
LABEL_15:
        *(_DWORD *)a3 = *(_DWORD *)v5;
        *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(a3 + 12) = *(_DWORD *)(v5 + 12);
        *(_DWORD *)(a3 + 16) = *(_DWORD *)(v5 + 16);
        *(_DWORD *)(a3 + 20) = *(_DWORD *)(v5 + 20);
        sub_100247E0(a1);
        return 1;
      default:
LABEL_16:
        sub_100247E0(a1);
        break;
    }
  }
  return 0;
}
// 1023EEBC: using guessed type int dword_1023EEBC;
// 1023EECC: using guessed type int dword_1023EECC;
// 1023EED0: using guessed type int dword_1023EED0;
// 1023EEDC: using guessed type int dword_1023EEDC;
// 1023EEE0: using guessed type int dword_1023EEE0;
// 10332F40: using guessed type int dword_10332F40;

//----- (10024E60) --------------------------------------------------------
char __cdecl sub_10024E60(int a1, int a2, void *a3, char a4, int a5, int a6)
{
  int v6; // ecx@0
  signed __int16 v7; // ax@1
  int v8; // ebp@2
  __int16 v9; // si@10
  int v11; // [sp-8h] [bp-570h]@16
  __int16 v12; // [sp+8h] [bp-560h]@12
  __int16 v13; // [sp+3Ch] [bp-52Ch]@9
  char v14; // [sp+40h] [bp-528h]@15
  char v15; // [sp+41h] [bp-527h]@9
  __int16 v16; // [sp+42h] [bp-526h]@9
  char v17; // [sp+44h] [bp-524h]@9
  __int16 v18; // [sp+46h] [bp-522h]@14
  int v19; // [sp+48h] [bp-520h]@15
  char v20; // [sp+4Ch] [bp-51Ch]@14

  LOBYTE(v7) = a1;
  switch ( (char)a1 )
  {
    case 6:
      v8 = 28;
      goto LABEL_7;
    case 0:
      v8 = 29;
      goto LABEL_7;
    case 2:
      v8 = 31;
      goto LABEL_7;
    case 3:
      v8 = 32;
      goto LABEL_7;
    case 5:
      v8 = 33;
LABEL_7:
      LOBYTE(v7) = sub_10024740(a1, v6);
      if ( !(_BYTE)v7 )
        return v7;
      v7 = sub_10024820(a1, a2);
      if ( v7 == -1 )
        return v7;
      v15 = a6;
      LOBYTE(v7) = a4;
      v13 = -32768;
      v16 = a2;
      v17 = a4;
      if ( a4 == 1 )
      {
        v9 = a5;
        if ( (unsigned __int16)a5 > 0x514u )
          return v7;
      }
      else
      {
        if ( sub_10024BA0(a1, a2, &v12) != 1 )
          goto LABEL_15;
        v9 = v12;
      }
      memcpy(&v20, a3, (unsigned __int16)v9);
      v18 = v9;
LABEL_15:
      v19 = sub_1007C040();
      v14 = 0;
      LOBYTE(v7) = sub_10047670(v8, (int)&v13);
      return v7;
    default:
      return v7;
    case 1:
      v11 = sub_1007C040();
      if ( a4 == 1 )
        LOBYTE(v7) = sub_100234A0(a2, a5, a6, (int)&byte_10332F00, a3, v11);
      else
        LOBYTE(v7) = sub_10023190(a2, a6, (int)&byte_10332F00, a3, v11);
      return v7;
  }
}
// 10332F00: using guessed type char byte_10332F00;

//----- (10025010) --------------------------------------------------------
char __cdecl sub_10025010(char a1, int a2, int a3)
{
  signed __int16 v3; // ax@1
  int v4; // edi@2
  __int16 v6; // [sp+4h] [bp-52Ch]@8
  __int16 v7; // [sp+8h] [bp-528h]@9
  int v8; // [sp+Ch] [bp-524h]@9

  LOBYTE(v3) = a1;
  switch ( a1 )
  {
    case 6:
      v4 = 28;
      goto LABEL_8;
    case 0:
      v4 = 29;
      goto LABEL_8;
    case 1:
      LOBYTE(v3) = sub_10023790(a2, a3, (int)&byte_10332F00);
      return v3;
    case 2:
      v4 = 31;
      goto LABEL_8;
    case 3:
      v4 = 32;
      goto LABEL_8;
    case 5:
      v4 = 33;
LABEL_8:
      memset(&v6, 0, 0x528u);
      v3 = sub_10024820(a1, a2);
      if ( v3 != -1 )
      {
        v6 = -32766;
        v7 = a2;
        v8 = a3;
        LOBYTE(v3) = sub_10047670(v4, (int)&v6);
      }
      break;
    default:
      return v3;
  }
  return v3;
}
// 10332F00: using guessed type char byte_10332F00;

//----- (10025120) --------------------------------------------------------
char __cdecl sub_10025120(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6)
{
  char result; // al@2
  int v7; // ecx@3
  signed __int16 v8; // si@3
  int v9; // eax@7
  int v10; // ebp@7
  int v11; // esi@7
  int v12; // edi@7
  unsigned int v13; // ebx@7
  int v14; // eax@9
  int v15; // eax@10
  int v16; // eax@12
  int v17; // eax@14
  int v18; // eax@16
  int v19; // eax@24
  char v20; // [sp+7h] [bp-9h]@18
  __int16 v21; // [sp+8h] [bp-8h]@1
  unsigned int v22; // [sp+Ch] [bp-4h]@1

  v22 = sub_1007C040();
  v21 = 0;
  if ( a1 < 7 )
  {
    v8 = sub_10024820(a1, a2);
    if ( v8 == -1 )
    {
      result = 0;
    }
    else
    {
      switch ( a1 )
      {
        case 6:
          if ( !(unsigned __int8)sub_10024740(a1, v7) )
            goto LABEL_29;
          v9 = 3 * (unsigned __int16)v8 + 75;
          v10 = dword_1023EED0 + 14952;
          v11 = 52 * (unsigned __int16)v8 + dword_1023EED0 + 210116;
          v12 = dword_1023EED0 + 8 * v9;
          v13 = 195164;
          goto LABEL_17;
        case 0:
          if ( !(unsigned __int8)sub_10024740(a1, v7) )
            goto LABEL_29;
          v14 = 3 * (unsigned __int16)v8;
          v10 = dword_1023EEDC + 13228;
          v11 = 52 * (unsigned __int16)v8 + dword_1023EEDC + 257156;
          v12 = dword_1023EEDC + 8 * v14 + 532;
          v13 = 243928;
          goto LABEL_17;
        case 1:
          v10 = dword_10332F1C;
          v15 = (unsigned __int16)v8;
          v11 = dword_10332F20 + 52 * (unsigned __int16)v8;
          v12 = dword_10332F40 + 24 * v15;
          v13 = 261080;
          goto LABEL_17;
        case 2:
          if ( !(unsigned __int8)sub_10024740(a1, v7) )
            goto LABEL_29;
          v16 = 3 * (unsigned __int16)v8 + 72;
          v10 = dword_1023EEE0 + 14328;
          v11 = 52 * (unsigned __int16)v8 + dword_1023EEE0 + 326220;
          v12 = dword_1023EEE0 + 8 * v16;
          v13 = 311892;
          goto LABEL_17;
        case 3:
          if ( !(unsigned __int8)sub_10024740(a1, v7) )
            goto LABEL_29;
          v17 = 3 * (unsigned __int16)v8;
          v10 = dword_1023EECC + 2052;
          v11 = 52 * (unsigned __int16)v8 + dword_1023EECC + 18832;
          v12 = dword_1023EECC + 8 * v17 + 84;
          v13 = 16780;
          goto LABEL_17;
        case 5:
          if ( !(unsigned __int8)sub_10024740(a1, v7) )
            goto LABEL_29;
          v18 = 3 * (unsigned __int16)v8;
          v10 = dword_1023EEBC + 100;
          v11 = 52 * (unsigned __int16)v8 + dword_1023EEBC + 1596;
          v12 = dword_1023EEBC + 8 * v18 + 4;
          v13 = 1496;
LABEL_17:
          if ( sub_10024800(a1) )
            goto LABEL_29;
          v20 = *(_BYTE *)(v12 + 1);
          if ( *(_BYTE *)(v12 + 1) == 1 && v10 )
          {
            if ( *(_DWORD *)(v11 + 12) && v22 > *(_DWORD *)(v11 + 16) + *(_DWORD *)(v12 + 16) )
              goto LABEL_32;
            v21 = a4;
            if ( !a4 )
              v21 = *(_WORD *)(v12 + 4) - a3;
            v19 = *(_DWORD *)(v11 + 4) + (unsigned __int16)a3;
            if ( !v21 || (unsigned int)(unsigned __int16)v21 + v19 > v13 )
LABEL_32:
              v20 = 0;
            else
              memcpy(a5, (const void *)(v10 + v19), (unsigned __int16)v21);
          }
          *(_WORD *)a6 = v21;
          sub_100247E0(a1);
          result = v20;
          break;
        default:
LABEL_29:
          result = 0;
          break;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1023EEB8: using guessed type int dword_1023EEB8;
// 1023EEBC: using guessed type int dword_1023EEBC;
// 1023EEC8: using guessed type int dword_1023EEC8;
// 1023EECC: using guessed type int dword_1023EECC;
// 1023EED0: using guessed type int dword_1023EED0;
// 1023EED8: using guessed type int dword_1023EED8;
// 1023EEDC: using guessed type int dword_1023EEDC;
// 1023EEE0: using guessed type int dword_1023EEE0;
// 10332F1C: using guessed type int dword_10332F1C;
// 10332F20: using guessed type int dword_10332F20;
// 10332F40: using guessed type int dword_10332F40;

//----- (10025390) --------------------------------------------------------
char __cdecl sub_10025390(char a1, int a2, __int16 a3, __int16 a4, void *a5)
{
  int v5; // ecx@0
  int v7; // [sp+0h] [bp-4h]@1

  v7 = v5;
  return sub_10025120(a1, a2, a3, a4, a5, (int)&v7);
}

//----- (100253C0) --------------------------------------------------------
char __cdecl sub_100253C0(char a1, int a2, void *a3)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v3;
  return sub_10025120(a1, a2, 0, 0, a3, (int)&v5);
}

//----- (100253F0) --------------------------------------------------------
char __cdecl sub_100253F0(char a1, int a2, void *a3, int a4)
{
  return sub_10025120(a1, a2, 0, 0, a3, a4);
}

//----- (10025420) --------------------------------------------------------
const char *__cdecl sub_10025420(int a1, unsigned __int16 a2)
{
  int v2; // ecx@1
  const char *result; // eax@1

  v2 = *(_DWORD *)(a1 + 44);
  result = "UNKNOWN";
  if ( v2 )
  {
    if ( a2 <= *(_WORD *)(*(_DWORD *)(a1 + 40) + 2 * *(_DWORD *)(a1 + 4)) )
      result = *(const char **)(v2 + 4 * a2);
  }
  return result;
}

//----- (10025450) --------------------------------------------------------
int __cdecl sub_10025450(char a1, int a2)
{
  void *v2; // ecx@1
  void *v3; // ecx@1
  void *v4; // ecx@2
  int v5; // eax@3
  int v6; // ecx@16

  sub_1007C110(*(_DWORD *)(a2 + 60), -1);
  *(_BYTE *)a2 = sub_100460C0(v2) | 1;
  if ( a1 == 1 )
  {
    if ( sub_1004E9A0(2048) )
      v5 = sub_100429D0(v4) | 0x300;
    else
      v5 = sub_100429D0(v4) | 0x83B00;
    *(_DWORD *)(a2 + 72) = v5;
    if ( !sub_1004E9A0(0x10000) )
      *(_DWORD *)(a2 + 72) |= 0x110000u;
    if ( !sub_1004E9A0(0x20000) )
      *(_DWORD *)(a2 + 72) |= 0x220000u;
    if ( !sub_1004E9A0(1024) )
      *(_DWORD *)(a2 + 72) |= 0x400u;
    if ( !sub_1004E9A0(0x1000000) )
      *(_DWORD *)(a2 + 72) |= 0x3000000u;
    if ( !sub_1004E9A0(0x4000000) )
      *(_DWORD *)(a2 + 72) |= 0x4000000u;
    if ( !sub_1004E9A0(0x8000000) )
    {
      v6 = *(_DWORD *)(a2 + 60);
      *(_DWORD *)(a2 + 72) |= 0x8000000u;
      sub_1007C0F0(v6);
      return sub_10023DF0(a2);
    }
  }
  else
  {
    *(_DWORD *)(a2 + 72) = sub_100429D0(v3);
  }
  sub_1007C0F0(*(_DWORD *)(a2 + 60));
  return sub_10023DF0(a2);
}

//----- (10025570) --------------------------------------------------------
char __cdecl sub_10025570(char a1)
{
  char result; // al@2
  int v2; // [sp+0h] [bp-4h]@1

  v2 = 0;
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 == 1 )
      result = sub_100255E0();
  }
  else
  {
    LOWORD(v2) = -32757;
    sub_100477A0((int)&v2);
    sub_100477B0((int)&v2);
    sub_100477C0((int)&v2);
    sub_100477E0((int)&v2);
    sub_100477D0((int)&v2);
    result = sub_10047790((int)&v2);
  }
  return result;
}

//----- (100255E0) --------------------------------------------------------
int sub_100255E0()
{
  return sub_1007C140(2, 0x80000);
}

//----- (100255F0) --------------------------------------------------------
char __cdecl sub_100255F0(int a1, int a2)
{
  int v2; // esi@1
  char v3; // al@1
  int v4; // edi@1
  char result; // al@3
  unsigned int v6; // ST40_4@9
  unsigned int v7; // ST44_4@9
  char v8; // [sp+Eh] [bp-22h]@1
  char v9; // [sp+Fh] [bp-21h]@1
  int v10; // [sp+18h] [bp-18h]@1
  int v11; // [sp+1Ch] [bp-14h]@1
  unsigned __int64 v12; // [sp+20h] [bp-10h]@1
  char v13; // [sp+28h] [bp-8h]@6

  v10 = 0;
  v12 = 0i64;
  v2 = sub_10043FF0(&a1, 2u, (int)&unk_100E00B0, 4, 2, 0);
  v3 = sub_1004ECB0(43, 1, a1);
  v4 = a2;
  v9 = v3;
  v11 = 0;
  v8 = sub_10023DA0(a1, a2, &v12);
  if ( v9 == sub_10045290() && !v8 )
  {
    result = sub_10023DA0((unsigned __int16)word_100E00B2[2 * v2], v4, &v12);
    goto LABEL_8;
  }
  if ( v9 == sub_10045290() || !v8 || (result = sub_10023DA0((unsigned __int16)word_100E00B2[2 * v2], v4, &v13)) == 0 )
  {
    result = v8;
LABEL_8:
    if ( result == 1 )
    {
      HIWORD(v6) = (HIDWORD(v12) >> 20) & 0xFFF;
      LOBYTE(v6) = (HIDWORD(v12) >> 16) & 0xF;
      BYTE1(v6) = (HIDWORD(v12) >> 11) & 0x1F;
      LOWORD(v7) = (HIDWORD(v12) >> 6) & 0x1F;
      BYTE2(v7) = BYTE4(v12) & 0x3F;
      BYTE3(v7) = (v12 >> 26) & 0x3F;
      sub_10042B50(&v10, v6);
      sub_10042C90(&v11, v7);
      v10 += v11;
      result = sub_10046130(v10, 1);
    }
  }
  return result;
}
// 100E00B2: using guessed type __int16 word_100E00B2[];

//----- (10025750) --------------------------------------------------------
unsigned __int8 __cdecl sub_10025750(int a1, int a2)
{
  char v2; // bl@1
  unsigned __int8 result; // al@1
  int v4; // [sp+Ch] [bp-8h]@1
  int v5; // [sp+10h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v2 = sub_10023DA0(1, a2, &v4);
  result = sub_10023DA0(2, a2, &v4);
  if ( (result | (unsigned __int8)v2) != 1 )
    result = sub_10046130(0, result | v2);
  return result;
}

//----- (100257B0) --------------------------------------------------------
int __cdecl sub_100257B0(int a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  int v3; // esi@1
  int v4; // eax@1
  char *v5; // edx@1
  int v6; // ebp@1
  double v7; // st6@3
  float v8; // ST28_4@4
  double v9; // st6@4
  float v10; // ST28_4@4
  float v11; // ST28_4@4
  double v12; // st7@8
  double v13; // st6@8
  int v14; // eax@13
  int v15; // ecx@20
  int result; // eax@21
  float v17; // [sp+10h] [bp-ACh]@5
  float v18; // [sp+14h] [bp-A8h]@1
  float v19; // [sp+18h] [bp-A4h]@6
  __int16 v20; // [sp+1Ch] [bp-A0h]@1

  v2 = sub_10046040(v1);
  v3 = 4 * a1;
  v4 = sub_1007C3B0(dword_100E0610[4 * a1], (int)&v18, 4);
  v5 = (char *)off_100E061C[4 * a1];
  flt_1023EF00[a1] = v18;
  v6 = v4;
  v20 = -1;
  sub_10047A30((int)&v20, (int)v5, 1);
  word_1023EEF8[a1] = v20;
  if ( *(float *)(dword_10337080 + 308) > 0.0 || *(float *)(dword_10337080 + 312) > 0.0 )
  {
    v8 = *(float *)(dword_10337080 + 936) + *(float *)(dword_10337080 + 932) + *(float *)(dword_10337080 + 940);
    v9 = v8;
    v10 = (*(float *)(dword_10337080 + 312) + *(float *)(dword_10337080 + 308)) * 0.5;
    v11 = v10 * (double)*(_BYTE *)(dword_10337080 + 24);
    v7 = v9 / v11 + v9 / v11;
  }
  else
  {
    v7 = 43200.0;
  }
  v17 = v7;
  if ( !v2 )
  {
    v19 = 0.0;
    if ( v6 )
    {
      v14 = dword_100E0610[v3];
      v18 = 0.0;
      flt_1023EF00[a1] = 0.0;
      sub_1007C500(v14, (int)&v18, 4);
    }
    goto LABEL_21;
  }
  if ( sub_1007C3B0(dword_100E0614[v3], (int)&v19, 4) )
  {
    if ( v6 )
    {
      v15 = dword_100E0610[v3];
      v18 = 0.0;
      flt_1023EF00[a1] = 0.0;
      sub_1007C520(v15, (int)&v18, 4);
      goto LABEL_21;
    }
    goto LABEL_19;
  }
  if ( v6 || (v12 = v18, v13 = v19, v19 > (double)v18) || v13 < v12 && v12 - v13 > v17 )
  {
    sub_1007C500(dword_100E0610[v3], (int)&v19, 4);
    flt_1023EF00[a1] = v19;
    goto LABEL_21;
  }
  if ( v19 < v12 && v17 > v12 - v19 )
LABEL_19:
    sub_1007C500(dword_100E0614[v3], (int)&v18, 4);
LABEL_21:
  flt_1023EEEC[a1] = 0.0;
  result = 0;
  dword_1023EEE4 = 0;
  dword_1023EEE8 = 0;
  return result;
}
// 100E0610: using guessed type int dword_100E0610[];
// 100E0614: using guessed type int dword_100E0614[];
// 100E0640: using guessed type float flt_100E0640;
// 1023EEE4: using guessed type int dword_1023EEE4;
// 1023EEE8: using guessed type int dword_1023EEE8;
// 1023EEEC: using guessed type float flt_1023EEEC[];
// 1023EEF8: using guessed type __int16 word_1023EEF8[];
// 1023EF00: using guessed type float flt_1023EF00[];
// 10337080: using guessed type int dword_10337080;

//----- (100259E0) --------------------------------------------------------
int __thiscall sub_100259E0(void *this)
{
  int result; // eax@1
  int v2; // esi@2

  result = sub_100429D0(this);
  if ( result == 1 )
  {
    v2 = 0;
    do
      result = sub_100257B0(v2++);
    while ( v2 < 3 );
  }
  return result;
}

//----- (10025A10) --------------------------------------------------------
char __cdecl sub_10025A10(int a1, float a2, float a3, int a4)
{
  char result; // al@3
  double v5; // st7@4
  float v6; // [sp+0h] [bp-8h]@1
  float v7; // [sp+4h] [bp-4h]@1

  v6 = *(float *)(dword_10337080 + 1364);
  v7 = *(float *)(dword_10337080 + 1368) - v6;
  if ( LOBYTE(a2) == 1 )
  {
    result = sub_10047520();
    if ( !result )
      return result;
    goto LABEL_12;
  }
  if ( !(_WORD)a4 )
  {
LABEL_12:
    result = a1;
    flt_1023EEEC[a1] = flt_1023EEEC[a1] + a3;
    return result;
  }
  result = sub_1003D430(a4, &a2);
  if ( result )
  {
    v5 = 0.0;
    if ( v7 != 0.0 )
    {
      if ( 0.0 == *(float *)(dword_10337080 + 1368) )
      {
        v5 = 1.0;
      }
      else
      {
        a2 = a2 - v6;
        if ( a2 > 0.0 )
          v5 = a2;
        a2 = v5;
        v5 = a2 / v7;
      }
    }
    result = a1;
    a2 = v5;
    flt_1023EEEC[a1] = a2 * a3 + flt_1023EEEC[a1];
  }
  return result;
}
// 1023EEEC: using guessed type float flt_1023EEEC[];
// 10337080: using guessed type int dword_10337080;

//----- (10025B00) --------------------------------------------------------
char __cdecl sub_10025B00(int a1, float a2, float a3)
{
  char result; // al@2

  if ( word_1023EEF8[a1] == -1 || (result = sub_10047A60(word_1023EEF8[a1])) != 0 )
    result = sub_10025A10(a1, a2, a3, (unsigned __int16)word_100E0618[8 * a1]);
  return result;
}
// 100E0618: using guessed type __int16 word_100E0618[];
// 1023EEF8: using guessed type __int16 word_1023EEF8[];

//----- (10025B50) --------------------------------------------------------
void __thiscall sub_10025B50(void *this)
{
  int v1; // esi@1
  int v2; // eax@2
  int v3; // edi@4
  int *v4; // esi@4
  int v5; // ST0C_4@5
  int v6; // eax@6
  int v7; // edx@6
  float v8; // [sp+10h] [bp-10h]@4
  float v9; // [sp+14h] [bp-Ch]@1
  float v10; // [sp+18h] [bp-8h]@4
  float v11; // [sp+1Ch] [bp-4h]@6

  v1 = sub_100429D0(this);
  sub_1007D180(26, &v9);
  if ( v1 == 1 )
  {
    v2 = dword_1023EEE4;
    if ( !dword_1023EEE4 )
    {
      v2 = sub_1007C040();
      dword_1023EEE4 = v2;
    }
    v8 = sub_100509F0(v2);
    v10 = sub_100509F0(dword_1023EEE8);
    dword_1023EEE4 = sub_1007C040();
    v3 = 0;
    v4 = dword_100E0610;
    do
    {
      v5 = *((_WORD *)v4 + 4);
      sub_10025B00(v3, v9, v8);
      if ( v10 > 10.0 )
      {
        v6 = sub_1007C040();
        v7 = *v4;
        v11 = flt_1023EEEC[v3] + flt_1023EF00[v3];
        dword_1023EEE8 = v6;
        sub_1007C500(v7, (int)&v11, 4);
      }
      v4 += 4;
      ++v3;
    }
    while ( (signed int)v4 < (signed int)&flt_100E0640 );
  }
}
// 100E0610: using guessed type int dword_100E0610[];
// 100E0640: using guessed type float flt_100E0640;
// 1023EEE4: using guessed type int dword_1023EEE4;
// 1023EEE8: using guessed type int dword_1023EEE8;
// 1023EEEC: using guessed type float flt_1023EEEC[];
// 1023EF00: using guessed type float flt_1023EF00[];

//----- (10025C30) --------------------------------------------------------
int __thiscall sub_10025C30(void *this)
{
  double v1; // st7@3
  int v2; // eax@10
  int result; // eax@14
  char v4; // [sp+2h] [bp-12h]@1
  char v5; // [sp+3h] [bp-11h]@1
  float v6; // [sp+4h] [bp-10h]@1
  float v7; // [sp+8h] [bp-Ch]@2
  float v8; // [sp+Ch] [bp-8h]@1
  char v9; // [sp+10h] [bp-4h]@1

  v4 = 0;
  v6 = 0.0;
  v5 = 0;
  dword_1023EF1C = sub_100429D0(this);
  sub_1007C650(10002, &v8, 4, &v6);
  sub_1007C650(10009, &v9, 4, &v6);
  if ( sub_10045F90() && !sub_1007C650(10009, &v7, 4, &v6) )
  {
    v7 = v7 - v8;
    v1 = 0.0;
    if ( v7 > 0.0 )
      v1 = v7;
    v7 = v1;
    sub_1007C500(10009, (int)&v7, 4);
  }
  if ( sub_10045F90() )
  {
    sub_1007C500(10002, (int)&v6, 4);
    sub_1007C500(10003, (int)&v6, 4);
    sub_1007C500(10004, (int)&v6, 4);
    sub_1007C500(10005, (int)&v6, 4);
  }
  if ( dword_1023EF1C == 1 )
  {
    dword_1023EF10 = 2;
    byte_1023EF29 = 2;
    byte_1023EF2A = 1;
    v2 = 10004;
    dword_1023EF24 = 10045;
    goto LABEL_13;
  }
  if ( dword_1023EF1C != 4 )
  {
    byte_1023EF2A = 2;
    dword_1023EF10 = 1;
    byte_1023EF29 = 1;
    v2 = 10005;
    dword_1023EF24 = 10046;
LABEL_13:
    byte_1023EF28[0] = 0;
    dword_1023EF0C[0] = 4;
    goto LABEL_14;
  }
  dword_1023EF10 = 2;
  byte_1023EF29 = 2;
  byte_1023EF2A = 0;
  dword_1023EF0C[0] = 1;
  byte_1023EF28[0] = 1;
  v2 = 10003;
  dword_1023EF24 = 10044;
LABEL_14:
  dword_1023EF18 = v2;
  sub_1007C650(v2, &v8, 4, &v6);
  result = sub_1007C650(10006, &v5, 1, &v4);
  flt_1023EF14 = 0.0;
  flt_1023EF20 = 0.0;
  dword_1023EF2C = 0;
  return result;
}
// 1023EF0C: using guessed type int dword_1023EF0C[];
// 1023EF10: using guessed type int dword_1023EF10;
// 1023EF14: using guessed type float flt_1023EF14;
// 1023EF18: using guessed type int dword_1023EF18;
// 1023EF1C: using guessed type int dword_1023EF1C;
// 1023EF20: using guessed type float flt_1023EF20;
// 1023EF24: using guessed type int dword_1023EF24;
// 1023EF29: using guessed type char byte_1023EF29;
// 1023EF2A: using guessed type char byte_1023EF2A;
// 1023EF2C: using guessed type int dword_1023EF2C;

//----- (10025E20) --------------------------------------------------------
bool __usercall sub_10025E20@<al>(void *a1@<ecx>, int a2@<esi>)
{
  int v2; // edi@1
  void *v3; // ecx@1
  int v4; // eax@1

  v2 = sub_100460A0(a1);
  v4 = sub_10046CE0(v3);
  return a2 == dword_1023EF1C || (a2 & v2 & ~v4) == a2;
}
// 1023EF1C: using guessed type int dword_1023EF1C;

//----- (10025E50) --------------------------------------------------------
void sub_10025E50()
{
  int v0; // eax@1
  char v1; // bl@3
  char v2; // al@3
  char v3; // bl@8
  double v4; // st7@8
  int v5; // ecx@8
  double v6; // st6@8
  double v7; // st7@10
  float *v8; // ecx@10
  int v9; // edi@12
  int v10; // ecx@13
  double v11; // st6@13
  float *v12; // ecx@13
  bool v13; // al@15
  char v14; // bl@19
  int v15; // edi@19
  int v16; // ecx@20
  double v17; // st6@20
  float *v18; // ecx@20
  bool v19; // al@22
  char v20; // [sp+9h] [bp-37h]@7
  char v21; // [sp+Ah] [bp-36h]@1
  char v22; // [sp+Bh] [bp-35h]@1
  float v23; // [sp+Ch] [bp-34h]@1
  float v24; // [sp+10h] [bp-30h]@19
  float v25; // [sp+14h] [bp-2Ch]@3
  float v26; // [sp+18h] [bp-28h]@1
  float v27; // [sp+1Ch] [bp-24h]@1
  float v28; // [sp+20h] [bp-20h]@3
  float v29; // [sp+24h] [bp-1Ch]@3
  float v30; // [sp+28h] [bp-18h]@7
  char v31; // [sp+2Ch] [bp-14h]@7
  char v32; // [sp+30h] [bp-10h]@7
  float v33; // [sp+34h] [bp-Ch]@7
  char v34; // [sp+38h] [bp-8h]@7
  char v35; // [sp+3Ch] [bp-4h]@7

  v26 = *(float *)(dword_10337080 + 936) + *(float *)(dword_10337080 + 932) + *(float *)(dword_10337080 + 940);
  sub_1007C650(10009, &v27, 4, &v26);
  v26 = v27;
  v23 = 0.0;
  v21 = 0;
  sub_1007D180(11, &v22);
  v0 = dword_1023EF2C;
  if ( !dword_1023EF2C )
  {
    v0 = sub_1007C040();
    dword_1023EF2C = v0;
  }
  v25 = sub_100509F0(v0);
  dword_1023EF2C = sub_1007C040();
  flt_1023EF20 = flt_1023EF20 + v25;
  v1 = sub_10044B10(&v28);
  v2 = sub_10044B30(&v29);
  if ( v1 )
    flt_1023EF14 = v28 * v25 + flt_1023EF14;
  if ( v2 )
    flt_1023EF14 = v29 * v25 + flt_1023EF14;
  sub_1007C470(10006, &v20, 1, &v21);
  sub_1007C470(10003, &v30, 4, &v23);
  sub_1007C470(10004, &v31, 4, &v23);
  sub_1007C470(10005, &v32, 4, &v23);
  sub_1007C470(10044, &v33, 4, &v23);
  sub_1007C470(10045, &v34, 4, &v23);
  sub_1007C470(10046, &v35, 4, &v23);
  if ( flt_1023EF20 >= 10.0 )
  {
    v3 = byte_1023EF2A;
    v4 = flt_1023EF14;
    v5 = 4 * (unsigned __int8)byte_1023EF2A;
    v6 = flt_1023EF14 + *(&v30 + (unsigned __int8)byte_1023EF2A);
    if ( v6 <= 9.999999562023526e24 )
      *(float *)((char *)&v30 + v5) = v6;
    v7 = v4 + *(float *)((char *)&v33 + v5);
    v8 = (float *)((char *)&v33 + v5);
    if ( v7 <= 100000000.0 )
      *v8 = v7;
    v9 = 0;
    while ( 1 )
    {
      v10 = (unsigned __int8)byte_1023EF28[v9];
      v11 = *(&v30 + v10);
      v12 = &v30 + v10;
      if ( v11 > *(&v30 + (unsigned __int8)v3) && *v12 * 0.009999999776482582 < *v12 - *(&v30 + (unsigned __int8)v3) )
      {
        v13 = sub_10025E20(v12, dword_1023EF0C[v9]);
        v3 = byte_1023EF2A;
        if ( v13 )
          break;
      }
      if ( ++v9 >= 2 )
        goto LABEL_19;
    }
    *(&v30 + (unsigned __int8)byte_1023EF2A) = *(&v30 + (unsigned __int8)byte_1023EF28[v9]);
LABEL_19:
    sub_1007C500(dword_1023EF18, (int)(&v30 + (unsigned __int8)v3), 4);
    v14 = byte_1023EF2A;
    v15 = 0;
    v24 = *(&v30 + (unsigned __int8)byte_1023EF2A);
    while ( 1 )
    {
      v16 = (unsigned __int8)byte_1023EF28[v15];
      v17 = *(&v33 + v16);
      v18 = &v33 + v16;
      if ( v17 > *(&v33 + (unsigned __int8)v14) && *v18 * 0.009999999776482582 < *v18 - *(&v33 + (unsigned __int8)v14) )
      {
        v19 = sub_10025E20(v18, dword_1023EF0C[v15]);
        v14 = byte_1023EF2A;
        if ( v19 )
          break;
      }
      if ( ++v15 >= 2 )
        goto LABEL_26;
    }
    *(&v33 + (unsigned __int8)byte_1023EF2A) = *(&v33 + (unsigned __int8)byte_1023EF28[v15]);
LABEL_26:
    sub_1007C500(dword_1023EF24, (int)(&v33 + (unsigned __int8)v14), 4);
    v25 = *(&v33 + (unsigned __int8)byte_1023EF2A);
    if ( v24 >= 0.0 )
    {
      if ( v22 == 1 && v26 < (double)v24 )
        v24 = v26;
    }
    else
    {
      v24 = 0.0;
    }
    sub_1007C500(10002, (int)&v24, 4);
    flt_1023EF14 = 0.0;
    flt_1023EF20 = 0.0;
    if ( v25 < 0.0 )
      v25 = 0.0;
    sub_10044530(v25);
  }
  if ( v20 )
  {
    flt_1023EF14 = 0.0;
    v20 = 0;
    sub_1007C5C0(10006, (int)&v20, 1, 0);
    sub_1007C500(10002, (int)&flt_1023EF14, 4);
    sub_1007C500(dword_1023EF18, (int)&flt_1023EF14, 4);
  }
}
// 1023EF0C: using guessed type int dword_1023EF0C[];
// 1023EF14: using guessed type float flt_1023EF14;
// 1023EF18: using guessed type int dword_1023EF18;
// 1023EF20: using guessed type float flt_1023EF20;
// 1023EF24: using guessed type int dword_1023EF24;
// 1023EF2A: using guessed type char byte_1023EF2A;
// 1023EF2C: using guessed type int dword_1023EF2C;
// 10337080: using guessed type int dword_10337080;

//----- (10026240) --------------------------------------------------------
signed int __cdecl sub_10026240(unsigned int a1)
{
  signed int result; // eax@1

  result = a1;
  if ( a1 >= 0x3E8 )
  {
    result = 1000;
    *(_DWORD *)(dword_1023EF44 + 164) = 1000;
  }
  else
  {
    *(_DWORD *)(dword_1023EF44 + 164) = a1;
  }
  return result;
}
// 1023EF44: using guessed type int dword_1023EF44;

//----- (10026270) --------------------------------------------------------
_BYTE *__usercall sub_10026270@<eax>(char a1@<bl>, int a2@<esi>)
{
  signed int v2; // ecx@4
  int v3; // eax@5
  _BYTE *result; // eax@9
  unsigned int v5; // eax@11
  unsigned int v6; // eax@14

  if ( !*(_WORD *)(a2 + 10) && a1 == 3 )
    *(_DWORD *)(a2 + 16) = sub_1007C040();
  v2 = 0;
  if ( *(_BYTE *)(a2 + 184) )
  {
    v3 = a2 + 29;
    do
    {
      *(_BYTE *)(v3 + 7) = a1;
      if ( **(_BYTE **)(a2 + 12) != 3 )
        *(_BYTE *)v3 = 0;
      ++v2;
      v3 += 32;
    }
    while ( v2 < *(_BYTE *)(a2 + 184) );
  }
  result = *(_BYTE **)(a2 + 12);
  if ( *result != a1 )
  {
    if ( !a1 )
    {
      v5 = *(_DWORD *)(a2 + 188);
      if ( v5 < 0xFFFFFFC2 && v5 )
      {
        sub_1007CE00(*(_DWORD *)(a2 + 188));
        *(_DWORD *)(a2 + 188) = -15;
      }
      v6 = *(_DWORD *)(a2 + 49276);
      if ( v6 < 0xFFFFFFC2 )
      {
        if ( v6 )
        {
          sub_10051640((void *)(a2 + 49160));
          *(_DWORD *)(a2 + 49276) = -15;
        }
      }
    }
    result = *(_BYTE **)(a2 + 12);
    *(_BYTE *)(a2 + 8) = *result;
    *result = a1;
  }
  return result;
}

//----- (10026310) --------------------------------------------------------
_DWORD *__usercall sub_10026310@<eax>(int a1@<ecx>, int a2@<esi>)
{
  int v2; // edx@1
  _DWORD *result; // eax@1
  _DWORD *v4; // ecx@2

  v2 = *(_BYTE *)(a1 + 184);
  result = 0;
  if ( v2 > 0 )
  {
    v4 = (_DWORD *)(a1 + 24);
    do
    {
      if ( *v4 == a2 )
        result = v4;
      v4 += 8;
      --v2;
    }
    while ( v2 );
  }
  return result;
}

//----- (10026330) --------------------------------------------------------
signed int __usercall sub_10026330@<eax>(int a1@<eax>, int a2@<edx>, void *a3@<ecx>)
{
  return sub_1007CED0(*(_DWORD *)(a2 + 188), a3, a1);
}

//----- (10026350) --------------------------------------------------------
signed int sub_10026350()
{
  if ( !sub_1007CD60((LONG)&off_100E1980) )
    sub_10042930("..\\lib\\adl\\iop_upld_mngr.c", 1938, 1, 0);
  *(_BYTE *)dword_10250BB0 = 0;
  byte_1023EF30 = 0;
  return sub_1007C8F0((int)&off_100E1980);
}
// 100E1980: using guessed type char *off_100E1980;
// 1023EF30: using guessed type char byte_1023EF30;
// 10250BB0: using guessed type int dword_10250BB0;

//----- (100263D0) --------------------------------------------------------
char __usercall sub_100263D0@<al>(int a1@<esi>, char a2, int a3, char a4, int a5, int a6, int a7, int a8, __int16 a9, int a10)
{
  int v10; // edi@1
  unsigned int v11; // eax@1
  _DWORD *v12; // edx@5
  unsigned int v13; // eax@5
  const char *v14; // ecx@5
  int v15; // edi@9
  int v16; // eax@10
  _BYTE *v17; // ecx@10
  _BYTE *v18; // edx@10
  int v19; // eax@12
  _BYTE *v20; // ecx@12
  _BYTE *v21; // edx@12
  _BYTE *v22; // ecx@14
  _BYTE *v23; // edx@14
  signed int v24; // eax@17
  unsigned int v25; // eax@20
  char *v26; // ecx@22
  _BYTE *v27; // eax@22
  char v28; // dl@23
  signed int v29; // edx@24
  bool v30; // zf@35
  bool v31; // sf@35

  v10 = a3;
  *(_DWORD *)(a1 + 188) = -15;
  *(_DWORD *)(a1 + 49276) = -15;
  memset((void *)(a1 + 50024), 0, 0x34u);
  v11 = j_FIL_vfs_open(a6, 4, 1792);
  *(_DWORD *)(a1 + 188) = v11;
  if ( (v11 >= 0xFFFFFFC2 || !v11)
    && sub_1007D070((int)"/mnt/card0/avtn_rgn.gca")
    && !sub_100516A0(
          (int)"/mnt/card0/avtn_rgn.gca",
          4,
          (void *)(a1 + 49160),
          (int)"Garmin Dont Give Out sYsTem lOader 1543krats&$*%(dh)#2654/*-") )
  {
    v12 = (_DWORD *)a6;
    v13 = 10;
    v14 = "/mnt/card0";
    do
    {
      if ( *v12 != *(_DWORD *)v14 )
        goto LABEL_9;
      v13 -= 4;
      v14 += 4;
      ++v12;
    }
    while ( v13 >= 4 );
    if ( !v13 )
    {
LABEL_17:
      v24 = 0;
      goto LABEL_18;
    }
LABEL_9:
    v15 = *(_BYTE *)v12 - *v14;
    if ( *(_BYTE *)v12 == *v14 )
    {
      v16 = v13 - 1;
      v17 = v14 + 1;
      v18 = (char *)v12 + 1;
      if ( !v16
        || (v15 = *v18 - *v17, *v18 == *v17)
        && ((v19 = v16 - 1, v20 = v17 + 1, v21 = v18 + 1, !v19)
         || (v15 = *v21 - *v20, *v21 == *v20)
         && ((v22 = v20 + 1, v23 = v21 + 1, v19 == 1) || (v15 = *v23 - *v22, *v23 == *v22))) )
      {
        v10 = a3;
        goto LABEL_17;
      }
    }
    v30 = v15 == 0;
    v31 = v15 < 0;
    v10 = a3;
    v24 = 1;
    if ( v31 || v30 )
      v24 = -1;
LABEL_18:
    if ( !v24 )
    {
      *(_DWORD *)(a1 + 50048) = a1 + 192;
      *(_DWORD *)(a1 + 50056) = a1 + 2240;
      *(_DWORD *)(a1 + 50024) = 0;
      *(_DWORD *)(a1 + 50028) = 0;
      *(_WORD *)(a1 + 50032) = 0;
      *(_DWORD *)(a1 + 50040) = 0;
      *(_WORD *)(a1 + 50044) = 0;
      *(_DWORD *)(a1 + 50052) = 2048;
      *(_DWORD *)(a1 + 50060) = 46920;
      *(_DWORD *)(a1 + 50064) = 15;
      *(_BYTE *)(a1 + 50068) = -2;
      *(_DWORD *)(a1 + 50072) = 0xFFFF;
      *(_DWORD *)(a1 + 188) = sub_10052640(a1 + 49160, (char *)(a6 + 11), 4, (void *)(a1 + 49288), a1 + 50024);
    }
  }
  v25 = *(_DWORD *)(a1 + 188);
  if ( v25 < 0xFFFFFFC2 && v25 )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 12) + 4) = a2;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 144) = v10;
    *(_BYTE *)(*(_DWORD *)(a1 + 12) + 5) = a4;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 140) = a5;
    *(_WORD *)(*(_DWORD *)(a1 + 12) + 136) = a9;
    *(_WORD *)(*(_DWORD *)(a1 + 12) + 138) = -1;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 168) = 0;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 152) = a7;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 148) = a8;
    v26 = (char *)a6;
    v27 = (_BYTE *)(*(_DWORD *)(a1 + 12) + 7);
    do
    {
      v28 = *v26;
      *v27++ = *v26++;
    }
    while ( v28 );
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 156) = a10;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 160) = 0;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 164) = 1000;
    sub_1007D0A0(
      *(_DWORD *)(a1 + 188),
      *(_DWORD *)(*(_DWORD *)(a1 + 12) + 152) + *(_DWORD *)(*(_DWORD *)(a1 + 12) + 168),
      0);
    *(_WORD *)(a1 + 10) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    dword_1024B2D4 = sub_1007C040();
    **(_BYTE **)(a1 + 12) = 1;
    memset((void *)(a1 + 24), 0, 0xA0u);
    *(_BYTE *)(a1 + 184) = 0;
    v29 = 2;
    do
    {
      v25 = 1 << (v29 - 2);
      if ( v25 & v10 )
      {
        *(_DWORD *)(32 * *(_BYTE *)(a1 + 184) + a1 + 24) = v25;
        LOBYTE(v25) = **(_BYTE **)(a1 + 12);
        *(_BYTE *)(32 * *(_BYTE *)(a1 + 184) + a1 + 36) = v25;
        *(_DWORD *)(32 * ((*(_BYTE *)(a1 + 184))++ + 1) + a1) = 0;
        if ( *(_BYTE *)(a1 + 184) >= 5u )
          break;
      }
      v25 = 1 << (v29 - 1);
      if ( v25 & v10 )
      {
        *(_DWORD *)(32 * *(_BYTE *)(a1 + 184) + a1 + 24) = v25;
        LOBYTE(v25) = **(_BYTE **)(a1 + 12);
        *(_BYTE *)(32 * *(_BYTE *)(a1 + 184) + a1 + 36) = v25;
        *(_DWORD *)(32 * ((*(_BYTE *)(a1 + 184))++ + 1) + a1) = 0;
        if ( *(_BYTE *)(a1 + 184) >= 5u )
          break;
      }
      if ( (1 << v29) & v10 )
      {
        *(_DWORD *)(32 * *(_BYTE *)(a1 + 184) + a1 + 24) = 1 << v29;
        LOBYTE(v25) = **(_BYTE **)(a1 + 12);
        *(_BYTE *)(32 * *(_BYTE *)(a1 + 184) + a1 + 36) = v25;
        *(_DWORD *)(32 * ((*(_BYTE *)(a1 + 184))++ + 1) + a1) = 0;
        if ( *(_BYTE *)(a1 + 184) >= 5u )
          break;
      }
      v25 = 1 << (v29 + 1);
      if ( v25 & v10 )
      {
        *(_DWORD *)(32 * *(_BYTE *)(a1 + 184) + a1 + 24) = v25;
        LOBYTE(v25) = **(_BYTE **)(a1 + 12);
        *(_BYTE *)(32 * *(_BYTE *)(a1 + 184) + a1 + 36) = v25;
        *(_DWORD *)(32 * ((*(_BYTE *)(a1 + 184))++ + 1) + a1) = 0;
        if ( *(_BYTE *)(a1 + 184) >= 5u )
          break;
      }
      v29 += 4;
      LOBYTE(v25) = v29 - 2;
    }
    while ( (unsigned int)(v29 - 2) < 0x20 );
  }
  return v25;
}
// 1007CEC0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1024B2D4: using guessed type int dword_1024B2D4;

//----- (10026810) --------------------------------------------------------
char __usercall sub_10026810@<al>(const void *a1@<eax>, int a2@<ebx>, char a3, unsigned __int16 a4)
{
  const void *v4; // edi@1
  int v5; // esi@3
  int v6; // eax@4
  int v7; // ecx@5
  int v8; // edi@5
  char result; // al@6
  int v10; // eax@8

  v4 = a1;
  *(_DWORD *)(a2 + 20) = sub_1007C040();
  if ( a3 == 1 )
  {
    v5 = 224;
  }
  else
  {
    if ( a3 == 2 )
    {
      v5 = 2746;
      v10 = sub_1007C040();
      sub_100234A0(2746, a4, 1, (int)&byte_10332F00, v4, v10);
      goto LABEL_5;
    }
    v5 = 223;
  }
  v6 = sub_1007C040();
  sub_10023190(v5, 1, (int)&byte_10332F00, v4, v6);
LABEL_5:
  v7 = *(_DWORD *)(a2 + 12);
  v8 = *(_DWORD *)(v7 + 144);
  if ( v8 == sub_100429D0((void *)v7) || (result = sub_10023790(v5, v8, (int)&byte_10332F00)) != 0 )
    result = 1;
  return result;
}
// 10332F00: using guessed type char byte_10332F00;

//----- (100268A0) --------------------------------------------------------
int sub_100268A0()
{
  unsigned int v0; // esi@1
  void (__cdecl *v1)(int); // eax@2
  int result; // eax@5

  dword_10250BB0 = -15;
  sub_10026350();
  memset(&dword_1023EF38, 0, 0xC39Cu);
  dword_10250BA8 = 0;
  dword_10250BAC = 0;
  v0 = 0;
  do
  {
    v1 = (void (__cdecl *)(int))dword_100E1904[v0];
    if ( v1 )
      v1(dword_100E1900[v0]);
    v0 += 4;
  }
  while ( v0 < 32 );
  result = sub_1007C040();
  dword_10250BA8 = result;
  LOBYTE(dword_10250BAC) = 0;
  dword_1023EF44 = dword_10250BB0;
  dword_1023EFF4 = -15;
  dword_1024AFB4 = -15;
  byte_1023EF32 = 0;
  byte_1023EF31 = 0;
  return result;
}
// 100E1900: using guessed type int dword_100E1900[];
// 100E1904: using guessed type int dword_100E1904[];
// 1023EF31: using guessed type char byte_1023EF31;
// 1023EF32: using guessed type char byte_1023EF32;
// 1023EF38: using guessed type int dword_1023EF38;
// 1023EF44: using guessed type int dword_1023EF44;
// 1023EFF4: using guessed type int dword_1023EFF4;
// 1024AFB4: using guessed type int dword_1024AFB4;
// 10250BA8: using guessed type int dword_10250BA8;
// 10250BAC: using guessed type int dword_10250BAC;
// 10250BB0: using guessed type int dword_10250BB0;

//----- (10026940) --------------------------------------------------------
char __cdecl sub_10026940(char a1, int a2, char a3, int a4, const char *a5, int a6, int a7, __int16 a8, int a9)
{
  if ( strlen(a5) >= 0x80 )
    sub_10042930("..\\lib\\adl\\iop_upld_mngr.c", 1375, 1, 0);
  return sub_100263D0((int)&dword_1023EF38, a1, a2, a3, a4, (int)a5, a6, a7, a8, a9);
}
// 1023EF38: using guessed type int dword_1023EF38;

//----- (100269B0) --------------------------------------------------------
_BYTE *__cdecl sub_100269B0(char a1)
{
  void *v1; // ecx@4
  char v2; // bl@5
  int v4; // [sp+8h] [bp-18h]@1
  int v5; // [sp+Ch] [bp-14h]@1
  int v6; // [sp+10h] [bp-10h]@1
  int v7; // [sp+14h] [bp-Ch]@1
  int v8; // [sp+18h] [bp-8h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  if ( (unsigned __int8)byte_1023EF40 >= 2u && *(_BYTE *)dword_1023EF44 == 5 || *(_BYTE *)dword_1023EF44 >= 2u )
  {
    LOBYTE(v4) = 2;
    v1 = *(void **)(dword_1023EF44 + 140);
    v6 = *(_DWORD *)(dword_1023EF44 + 140);
    v7 = *(_DWORD *)(dword_1023EF44 + 148);
    LOWORD(v5) = *(_WORD *)(dword_1023EF44 + 136);
    LOWORD(v1) = v5;
    BYTE1(v4) = *(_BYTE *)(dword_1023EF44 + 5);
    v8 = sub_100429D0(v1);
    sub_10026810(&v4, (int)&dword_1023EF38, 0, 0x14u);
  }
  dword_1023EF38 = sub_1007C040();
  v2 = 5;
  if ( !a1 )
    v2 = 7;
  return sub_10026270(v2, (int)&dword_1023EF38);
}
// 1023EF38: using guessed type int dword_1023EF38;
// 1023EF40: using guessed type char byte_1023EF40;
// 1023EF44: using guessed type int dword_1023EF44;

//----- (10026A70) --------------------------------------------------------
_BYTE *__usercall sub_10026A70@<eax>(_BYTE *result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // esi@1
  char v4; // bl@1
  int v5; // ecx@3
  signed int v6; // eax@3
  int v7; // edi@4
  _BYTE *v8; // ecx@9

  v3 = a3;
  v4 = (char)result;
  if ( *(_BYTE *)(a2 + 12) != (_BYTE)result )
  {
    *(_BYTE *)(a2 + 12) = (_BYTE)result;
    if ( (_BYTE)result == 7 )
    {
      *(_DWORD *)(*(_DWORD *)(a3 + 12) + 144) &= ~*(_DWORD *)a2;
      v5 = *(_BYTE *)(a3 + 184);
      v6 = 0;
      if ( v5 > 0 )
      {
        v7 = v3 + 24;
        do
        {
          ++v6;
          if ( v7 == a2 )
            break;
          v7 += 32;
        }
        while ( v6 < *(_BYTE *)(v3 + 184) );
      }
      memcpy_0((void *)a2, (const void *)(a2 + 32), 32 * (v5 - v6));
      v4 = *(_BYTE *)(v3 + 36);
      --*(_BYTE *)(v3 + 184);
    }
    result = 0;
    if ( *(_BYTE *)(v3 + 184) )
    {
      v8 = (_BYTE *)(v3 + 36);
      while ( *v8 == v4 )
      {
        ++result;
        v8 += 32;
        if ( (signed int)result >= *(_BYTE *)(v3 + 184) )
          goto LABEL_12;
      }
    }
    else
    {
LABEL_12:
      if ( v4 == 7 )
        result = sub_100269B0(0);
      else
        result = sub_10026270(v4, v3);
    }
  }
  return result;
}

//----- (10026D90) --------------------------------------------------------
__int16 __usercall sub_10026D90@<ax>(unsigned __int64 a1@<edx:eax>)
{
  int v1; // ebx@1
  int v2; // edi@1
  int v3; // esi@2
  int v4; // edx@12
  unsigned int v5; // ecx@18
  unsigned int v6; // ebp@18
  unsigned int v7; // edi@27
  int v8; // ecx@27

  v1 = dword_1023EF44;
  v2 = a1;
  LOWORD(a1) = *(_WORD *)(a1 + 2);
  if ( (_WORD)a1 == *(_WORD *)(dword_1023EF44 + 136) )
  {
    LODWORD(a1) = sub_10026310((int)&dword_1023EF38, *(_DWORD *)(v2 + 28));
    v3 = a1;
    if ( (_DWORD)a1 )
    {
      if ( *(_BYTE *)v2 != 1 )
      {
        HIDWORD(a1) = a1;
        LOBYTE(a1) = 7;
        LOWORD(a1) = (unsigned int)sub_10026A70((_BYTE *)a1, SHIDWORD(a1), (int)&dword_1023EF38);
        return a1;
      }
      if ( *(_BYTE *)v1 != 3
        || (LODWORD(a1) = *(_DWORD *)(v1 + 168), *(_DWORD *)(v2 + 4) != (_DWORD)a1)
        || (LODWORD(a1) = *(_DWORD *)(v2 + 8), (_DWORD)a1) )
      {
        if ( *(_BYTE *)(v2 + 1) < 2u )
          return a1;
        LODWORD(a1) = *(_DWORD *)(v2 + 8);
        v5 = *(_DWORD *)(v3 + 20);
        HIDWORD(a1) = *(_DWORD *)(v2 + 4);
        v6 = *(_DWORD *)(v3 + 16);
        if ( (unsigned int)a1 <= v5 && ((unsigned int)a1 < v5 || HIDWORD(a1) <= v6) )
        {
          if ( (unsigned int)a1 < v5 || (unsigned int)a1 <= v5 && HIDWORD(a1) < v6 )
            return a1;
          *(_DWORD *)(v1 + 168) = HIDWORD(a1);
          sub_1007D0A0(dword_1023EFF4, *(_DWORD *)(dword_1023EF44 + 152) + *(_DWORD *)(dword_1023EF44 + 168), 0);
          if ( (unsigned __int8)++byte_1023EFF2 > 5u )
            byte_1023EFF2 = 5;
        }
        *(_DWORD *)(v3 + 16) = *(_DWORD *)(v2 + 4);
        *(_DWORD *)(v3 + 20) = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v3 + 28) = sub_1007C040();
        LOWORD(a1) = *(_WORD *)(v2 + 24);
        *(_WORD *)(v3 + 24) = a1;
        if ( *(_BYTE *)dword_1023EF44 == 3 )
        {
          v7 = *(_DWORD *)(dword_1023EF44 + 168);
          v8 = *(_DWORD *)(dword_1023EF44 + 148);
          if ( v7 != v8 || *(_DWORD *)(v3 + 16) == v8 && !*(_DWORD *)(v3 + 20) )
          {
            a1 = *(_QWORD *)(v3 + 16) + (unsigned __int16)a1;
            if ( v7 < a1 )
            {
              LOBYTE(a1) = byte_1023EF40;
              LOWORD(a1) = (unsigned int)sub_10026A70((_BYTE *)a1, v3, (int)&dword_1023EF38);
            }
          }
        }
      }
      else
      {
        *(_BYTE *)(v3 + 5) = 1;
        word_1023EF42 = 0;
        dword_1023EF4C = 0;
        if ( *(_BYTE *)(v2 + 1) >= 1u && byte_1023EF40 == 4 )
        {
          *(_WORD *)(dword_1023EF44 + 138) = *(_WORD *)(v2 + 16);
          LODWORD(a1) = *(_DWORD *)(v2 + 12);
          *(_DWORD *)(dword_1023EF44 + 160) = a1;
        }
        if ( *(_BYTE *)(v2 + 1) < 2u )
        {
          byte_1023EFF3 = 1;
          byte_1023EFF1 = 1;
          byte_1023EFF2 = 0;
          *(_WORD *)(v3 + 24) = 1000;
        }
        else
        {
          v4 = *(_DWORD *)(v2 + 8) | *(_DWORD *)(v2 + 4);
          if ( !*(_QWORD *)(v2 + 4) )
          {
            byte_1023EFF3 = *(_BYTE *)(v2 + 8) | *(_BYTE *)(v2 + 4);
            byte_1023EFF1 = 25;
            byte_1023EFF2 = v4;
          }
          LODWORD(a1) = sub_1007C040();
          *(_DWORD *)(v3 + 28) = a1;
          LOWORD(a1) = *(_WORD *)(v2 + 24);
          *(_WORD *)(v3 + 24) = a1;
        }
        *(_DWORD *)(v3 + 16) = *(_DWORD *)(v2 + 4);
        *(_DWORD *)(v3 + 20) = *(_DWORD *)(v2 + 8);
        LOBYTE(a1) = byte_1023EF40;
        LOWORD(a1) = (unsigned int)sub_10026A70((_BYTE *)a1, v3, (int)&dword_1023EF38);
      }
    }
  }
  return a1;
}
// 1023EF38: using guessed type int dword_1023EF38;
// 1023EF40: using guessed type char byte_1023EF40;
// 1023EF42: using guessed type __int16 word_1023EF42;
// 1023EF44: using guessed type int dword_1023EF44;
// 1023EF4C: using guessed type int dword_1023EF4C;
// 1023EFF1: using guessed type char byte_1023EFF1;
// 1023EFF2: using guessed type char byte_1023EFF2;
// 1023EFF3: using guessed type char byte_1023EFF3;
// 1023EFF4: using guessed type int dword_1023EFF4;

//----- (10026FA0) --------------------------------------------------------
char __thiscall sub_10026FA0(void *this)
{
  int v1; // esi@1
  signed int v2; // eax@1
  int v3; // edi@1
  int v4; // ecx@2
  int v5; // eax@8
  int v6; // ecx@10
  char result; // al@11
  int v8; // eax@13
  unsigned int v9; // ebp@13
  int v10; // eax@13
  unsigned int v11; // ebx@14
  int v12; // eax@16
  int v13; // ecx@18
  int v14; // [sp+10h] [bp-7FCh]@2
  int v15; // [sp+14h] [bp-7F8h]@1
  __int16 v16; // [sp+18h] [bp-7F4h]@1
  char v17; // [sp+1Ah] [bp-7F2h]@25
  int v18; // [sp+1Ch] [bp-7F0h]@18
  char v19; // [sp+20h] [bp-7ECh]@16
  size_t v20; // [sp+408h] [bp-404h]@16
  int v21; // [sp+40Ch] [bp-400h]@12
  __int16 v22; // [sp+410h] [bp-3FCh]@1
  char v23; // [sp+412h] [bp-3FAh]@25
  int v24; // [sp+414h] [bp-3F8h]@25
  size_t v25; // [sp+418h] [bp-3F4h]@25
  int v26; // [sp+41Ch] [bp-3F0h]@25
  char v27; // [sp+420h] [bp-3ECh]@25

  v1 = (int)this;
  memset(&v16, 0, 0x3F8u);
  memset(&v22, 0, 0x3F8u);
  v15 = sub_1007C040();
  v2 = *(_BYTE *)(v1 + 184);
  byte_1023EF30 = 0;
  v3 = v1 + 24;
  if ( v2 > 1 )
  {
    v4 = v1 + 72;
    v14 = v2 - 1;
    do
    {
      if ( *(_QWORD *)v4 + (unsigned __int64)*(_WORD *)(v4 + 8) < *(_QWORD *)(v3 + 16)
                                                                + (unsigned __int64)*(_WORD *)(v3 + 24) )
        v3 = v4 - 16;
      v4 += 32;
      --v14;
    }
    while ( v14 );
  }
  if ( *(_WORD *)(v1 + 10) )
  {
    *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168) = *(_DWORD *)(v3 + 16);
    sub_1007D0A0(
      *(_DWORD *)(v1 + 188),
      *(_DWORD *)(*(_DWORD *)(v1 + 12) + 152) + *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168),
      0);
    if ( *(_WORD *)(v1 + 10) > 1u )
    {
      v5 = *(_DWORD *)(v1 + 12);
      if ( *(_DWORD *)(v5 + 164) < 0x3E8u )
        *(_DWORD *)(v5 + 164) = 1000;
    }
  }
  v6 = *(_DWORD *)(v1 + 12);
  if ( *(_DWORD *)(v6 + 168) >= *(_QWORD *)(v3 + 16) + (unsigned __int64)*(_WORD *)(v3 + 24) )
    return (unsigned int)sub_10026270(3, v1);
  v16 = *(_WORD *)(v6 + 136);
  v21 = sub_100429D0((void *)v6);
  while ( 1 )
  {
    v8 = sub_1007C040();
    dword_1023EF34 = v8;
    v9 = v8 - v15;
    v10 = *(_DWORD *)(v1 + 12);
    if ( *(_DWORD *)(v10 + 168) < *(_DWORD *)(v10 + 148) )
      break;
    result = (unsigned int)sub_10026270(4, v1);
LABEL_31:
    if ( **(_BYTE **)(v1 + 12) != 2 || v9 >= 0x23 )
      return result;
  }
  v11 = *(_DWORD *)(v10 + 148) - *(_DWORD *)(v10 + 168);
  if ( v11 > *(_DWORD *)(v10 + 164) )
    v11 = *(_DWORD *)(v10 + 164);
  v12 = sub_10026330(v11, v1, &v19);
  v20 = v12;
  if ( v12 != v11 )
  {
    v20 = 0;
    sub_100269B0(1);
    v12 = v20;
  }
  v13 = *(_DWORD *)(v1 + 12);
  v18 = *(_DWORD *)(v13 + 168);
  if ( (unsigned int)(v18 + v12) > *(_DWORD *)(v13 + 148) )
  {
    v12 = *(_DWORD *)(v13 + 148) - v18;
    v20 = *(_DWORD *)(v13 + 148) - v18;
  }
  *(_DWORD *)(v13 + 168) += v12;
  if ( *(_BYTE *)(v1 + 187)
    || *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168) >= *(_DWORD *)(*(_DWORD *)(v1 + 12) + 148)
    || *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168) >= *(_QWORD *)(v3 + 16) + (unsigned __int64)*(_WORD *)(v3 + 24) )
  {
    sub_10026270(3, v1);
  }
  if ( *(_DWORD *)(*(_DWORD *)(v1 + 12) + 164) >= 0x3E8u )
  {
    result = sub_10026810(&v16, v1, 1, 0x3F8u);
  }
  else
  {
    v22 = v16;
    v24 = v18;
    v25 = v20;
    v23 = v17;
    v26 = v21;
    memcpy(&v27, &v19, v20);
    result = sub_10026810(&v22, v1, 2, v25 + 16);
  }
  if ( result )
    goto LABEL_31;
  *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168) -= v20;
  return sub_1007D0A0(
           *(_DWORD *)(v1 + 188),
           *(_DWORD *)(*(_DWORD *)(v1 + 12) + 152) + *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168),
           0);
}
// 1023EF30: using guessed type char byte_1023EF30;
// 1023EF34: using guessed type int dword_1023EF34;

//----- (100272C0) --------------------------------------------------------
_BYTE *__usercall sub_100272C0@<eax>(int a1@<esi>)
{
  _BYTE *result; // eax@1
  bool v2; // zf@1
  int v3; // edi@4
  int v4; // eax@8
  int v5; // eax@8
  void *v6; // ecx@8
  _BYTE *v7; // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int (__cdecl *v10)(int); // edx@10
  signed int v11; // [sp+0h] [bp-20h]@3
  int v12; // [sp+8h] [bp-18h]@1
  int v13; // [sp+Ch] [bp-14h]@1
  int v14; // [sp+10h] [bp-10h]@1
  int v15; // [sp+14h] [bp-Ch]@1
  _BYTE *v16; // [sp+18h] [bp-8h]@1

  result = 0;
  v2 = *(_BYTE *)(a1 + 184) == 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( v2 )
    result = sub_100269B0(0);
  v11 = 0;
  if ( *(_BYTE *)(a1 + 184) )
  {
    v3 = a1 + 24;
    do
    {
      if ( *(_BYTE *)(v3 + 4) == 1 )
      {
        if ( *(_BYTE *)(v3 + 5) == 1 )
        {
          LOBYTE(result) = 2;
          sub_10026A70(result, v3, a1);
        }
        else
        {
          byte_1023EF30 = 1;
          v4 = sub_1007C040();
          LOBYTE(v12) = 0;
          dword_1023EF34 = v4;
          v5 = *(_DWORD *)(a1 + 12);
          v6 = *(void **)(v5 + 140);
          v14 = *(_DWORD *)(v5 + 140);
          v15 = *(_DWORD *)(v5 + 148);
          LOWORD(v13) = *(_WORD *)(v5 + 136);
          LOWORD(v6) = v13;
          BYTE1(v12) = *(_BYTE *)(v5 + 5);
          v7 = (_BYTE *)sub_100429D0(v6);
          v16 = v7;
          LOBYTE(v7) = 3;
          sub_10026A70(v7, v3, a1);
          sub_10026810(&v12, a1, 0, 0x14u);
        }
      }
      else
      {
        v8 = sub_10043FF0((_DWORD *)v3, 4u, (int)dword_100E1900, 16, 8, 9);
        if ( v8 < 9 )
        {
          v9 = 4 * v8;
          v10 = off_100E1908[v9];
          if ( v10 )
            *(_BYTE *)(v3 + 4) = ((int (__cdecl *)(int, _DWORD, _DWORD, _DWORD))v10)(
                                   dword_100E1900[v9],
                                   *(_BYTE *)(*(_DWORD *)(a1 + 12) + 5),
                                   *(_DWORD *)(*(_DWORD *)(a1 + 12) + 140),
                                   *(_WORD *)(*(_DWORD *)(a1 + 12) + 136));
        }
      }
      if ( (double)(unsigned int)(sub_1007C040() - dword_1024B2D4) > 600000.0 )
        sub_100269B0(0);
      result = (_BYTE *)(v11 + 1);
      v3 += 32;
      ++v11;
    }
    while ( v11 < *(_BYTE *)(a1 + 184) );
  }
  return result;
}
// 100E1900: using guessed type int dword_100E1900[];
// 100E1908: using guessed type int (__cdecl *off_100E1908[2])(int);
// 1023EF30: using guessed type char byte_1023EF30;
// 1023EF34: using guessed type int dword_1023EF34;
// 1024B2D4: using guessed type int dword_1024B2D4;

//----- (10027540) --------------------------------------------------------
char __thiscall sub_10027540(int this)
{
  int v1; // esi@1
  unsigned __int8 v2; // cl@1
  char v3; // dl@1
  _BYTE *v4; // eax@2
  int v5; // edi@2
  int v6; // eax@6
  void *v7; // ecx@7
  __int16 v9; // cx@9
  signed int v10; // eax@11
  _DWORD *v11; // ecx@12
  int v12; // [sp+8h] [bp-18h]@1
  int v13; // [sp+Ch] [bp-14h]@1
  int v14; // [sp+10h] [bp-10h]@1
  int v15; // [sp+14h] [bp-Ch]@1
  int v16; // [sp+18h] [bp-8h]@1

  v1 = this;
  v2 = *(_BYTE *)(this + 184);
  v3 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( v2 )
  {
    v4 = (_BYTE *)(v1 + 29);
    v5 = v2;
    do
    {
      if ( *v4 == 1 )
        ++v3;
      v4 += 32;
      --v5;
    }
    while ( v5 );
  }
  v6 = *(_DWORD *)(v1 + 12);
  if ( v2 != v3 )
  {
    LOBYTE(v12) = 1;
    v7 = *(void **)(v6 + 140);
    v14 = *(_DWORD *)(v6 + 140);
    v15 = *(_DWORD *)(v6 + 148);
    LOWORD(v13) = *(_WORD *)(v6 + 136);
    LOWORD(v7) = v13;
    BYTE1(v12) = *(_BYTE *)(v6 + 5);
    v16 = sub_100429D0(v7);
    sub_10026270(3, v1);
    return sub_10026810(&v12, v1, 0, 0x14u);
  }
  if ( *(_WORD *)(v6 + 136) == 74 )
  {
    v9 = *(_WORD *)(v6 + 138);
    if ( v9 == -1 )
    {
      sub_100269B0(0);
      return sub_10042930("..\\lib\\adl\\iop_upld_mngr.c", 2939, 0, 0);
    }
    sub_10052830(*(_BYTE *)(v6 + 4), v9, *(_DWORD *)(v6 + 160));
  }
  v10 = 0;
  if ( *(_BYTE *)(v1 + 184) )
  {
    v11 = (_DWORD *)(v1 + 32);
    do
    {
      *v11 = 0;
      ++v10;
      v11 += 8;
    }
    while ( v10 < *(_BYTE *)(v1 + 184) );
  }
  *(_DWORD *)(v1 + 4) = sub_1007C040();
  return (unsigned int)sub_10026270(6, v1);
}

//----- (100276B0) --------------------------------------------------------
char __cdecl sub_100276B0(int a1, int a2)
{
  char result; // al@2
  unsigned __int64 v3; // rax@6
  void *v4; // ecx@6
  void *v5; // ecx@8
  int v6; // [sp+8h] [bp-28h]@1
  int v7; // [sp+Ch] [bp-24h]@1
  int v8; // [sp+10h] [bp-20h]@1
  int v9; // [sp+14h] [bp-1Ch]@1
  int v10; // [sp+18h] [bp-18h]@1
  int v11; // [sp+1Ch] [bp-14h]@1
  int v12; // [sp+20h] [bp-10h]@1
  int v13; // [sp+24h] [bp-Ch]@1
  int v14; // [sp+28h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v6 = 0;
  if ( (_WORD)a1 == 225 )
  {
    result = sub_10023DA0(225, a2, &v7);
    if ( !result )
      return result;
    BYTE2(v11) = BYTE1(v7);
    BYTE1(v7) = 0;
  }
  else
  {
    result = sub_10023DC0(a1, a2, &v7, (unsigned __int16 *)&v6);
  }
  if ( result )
  {
    LODWORD(v3) = sub_10022640(a1, a2);
    LOBYTE(v4) = BYTE1(v7);
    if ( BYTE1(v7) <= 1u )
      goto LABEL_10;
    if ( BYTE1(v7) == 2 )
    {
      v14 = v3;
      LODWORD(v3) = sub_100429D0(v4);
      if ( !((unsigned int)v3 & v14) )
      {
LABEL_11:
        LODWORD(v3) = &v7;
        return sub_10026D90(v3);
      }
      LODWORD(v3) = sub_100429D0(v5);
LABEL_10:
      v14 = v3;
      goto LABEL_11;
    }
    result = sub_10042930("..\\lib\\adl\\iop_upld_mngr.c", 1177, 0, 0);
  }
  return result;
}

//----- (100277B0) --------------------------------------------------------
void __thiscall sub_100277B0(int *this)
{
  char v1; // bl@9
  signed int v2; // ebp@9
  int *v3; // edi@10
  unsigned int v4; // eax@11
  bool v5; // zf@19
  int v6; // eax@35
  int v7; // eax@36
  int (__cdecl *v8)(int, _DWORD, _DWORD, _DWORD); // edx@36
  int v9; // eax@47
  int v10; // edi@47
  int *v11; // [sp+0h] [bp-4h]@9

  switch ( *(_BYTE *)dword_1023EF44 )
  {
    case 1:
      sub_100272C0((int)&dword_1023EF38);
      return;
    case 2:
      sub_10026FA0(&dword_1023EF38);
      return;
    case 3:
      v9 = sub_1007C040();
      v10 = v9;
      if ( byte_1023EF30 == 1 )
      {
        if ( (double)(unsigned int)(v9 - dword_1023EF34) <= 12000.0 )
        {
          if ( (double)(unsigned int)(v9 - *(&dword_1023EF38 + 4)) > 360000.0 )
            sub_100269B0(0);
        }
        else
        {
          sub_10026270(1, (int)&dword_1023EF38);
        }
      }
      if ( (double)(unsigned int)(v10 - dword_1023EF34) <= 360000.0 )
      {
        if ( *((_BYTE *)&dword_1023EF38 + 8) == 2
          && *(_DWORD *)(*(&dword_1023EF38 + 3) + 164) < 0x3E8u
          && (unsigned int)(v10 - *(&dword_1023EF38 + 5)) >= 0x3E8 )
        {
          sub_10026270(2, (int)&dword_1023EF38);
          ++*((_WORD *)&dword_1023EF38 + 5);
        }
      }
      else
      {
        sub_100269B0(0);
      }
      return;
    case 4:
      sub_10027540((int)&dword_1023EF38);
      return;
    case 6:
      v11 = this;
      v1 = 0;
      v2 = 0;
      if ( *((_BYTE *)&dword_1023EF38 + 184) )
      {
        v3 = &dword_1023EF38 + 6;
        while ( 1 )
        {
          v4 = *v3;
          v11 = v3;
          if ( (unsigned int)*v3 > 0x4000 )
            break;
          if ( *v3 == 0x4000 )
            goto LABEL_35;
          if ( v4 > 0x200 )
          {
            if ( v4 > 0x1000 )
            {
              v5 = v4 == 0x2000;
            }
            else
            {
              if ( v4 == 4096 || v4 == 1024 )
                goto LABEL_35;
              v5 = v4 == 2048;
            }
LABEL_34:
            if ( !v5 )
              goto LABEL_39;
            goto LABEL_35;
          }
          if ( v4 != 512 )
          {
            switch ( v4 )
            {
              case 0x10u:
              case 0x20u:
              case 0x40u:
              case 0x80u:
              case 0x100u:
                goto LABEL_35;
              default:
                break;
            }
LABEL_39:
            v1 = 1;
            goto LABEL_40;
          }
LABEL_35:
          v6 = sub_10043FF0(v3, 4u, (int)dword_100E1900, 16, 8, 9);
          if ( v6 < 9 )
          {
            v7 = 4 * v6;
            v8 = *(int (__cdecl **)(int, _DWORD, _DWORD, _DWORD))((char *)&off_100E190C + v7 * 4);
            if ( v8 )
            {
              v1 = v8(
                     dword_100E1900[v7],
                     *(_BYTE *)(*(&dword_1023EF38 + 3) + 5),
                     *(_DWORD *)(*(&dword_1023EF38 + 3) + 140),
                     *(_WORD *)(*(&dword_1023EF38 + 3) + 136));
              if ( v1 != 1 )
                ++v3[2];
              goto LABEL_40;
            }
            goto LABEL_39;
          }
LABEL_40:
          ++v2;
          v3 += 8;
          if ( v2 >= *((_BYTE *)&dword_1023EF38 + 184) )
            goto LABEL_41;
        }
        if ( v4 > 0x200000 )
        {
          if ( v4 > 0x4000000 )
          {
            v5 = v4 == 0x8000000;
          }
          else
          {
            if ( v4 == 0x4000000 || v4 == 0x1000000 )
              goto LABEL_35;
            v5 = v4 == 0x2000000;
          }
        }
        else
        {
          if ( v4 == 0x200000 )
            goto LABEL_35;
          if ( v4 > 0x20000 )
          {
            if ( v4 == 0x80000 )
              goto LABEL_35;
            v5 = v4 == 0x100000;
          }
          else
          {
            if ( v4 == 0x20000 || v4 == 0x8000 )
              goto LABEL_35;
            v5 = v4 == 0x10000;
          }
        }
        goto LABEL_34;
      }
LABEL_41:
      if ( v11[2] > 500 )
        sub_100269B0(0);
      if ( v1 == 1
        && (unsigned int)(sub_1007C040() - *(&dword_1023EF38 + 1)) >= *(_DWORD *)(*(&dword_1023EF38 + 3) + 156) )
      {
        sub_10026270(0, (int)&dword_1023EF38);
      }
      return;
    case 5:
    case 7:
      if ( (unsigned int)(sub_1007C040() - dword_1023EF38) >= 0x1388 )
      {
        byte_1023EF30 = 0;
        dword_1024B2D4 = 0;
        sub_10026270(0, (int)&dword_1023EF38);
      }
      return;
    case 0:
      return;
    default:
      sub_10042930("..\\lib\\adl\\iop_upld_mngr.c", 1268, 1, 0);
      return;
  }
}
// 100E1900: using guessed type int dword_100E1900[];
// 100E190C: using guessed type int (__cdecl *off_100E190C)(int);
// 1023EF30: using guessed type char byte_1023EF30;
// 1023EF34: using guessed type int dword_1023EF34;
// 1023EF38: using guessed type int dword_1023EF38;
// 1023EF44: using guessed type int dword_1023EF44;
// 1024B2D4: using guessed type int dword_1024B2D4;

//----- (10027840) --------------------------------------------------------
char sub_10027840()
{
  char *v0; // eax@1
  char *v1; // ecx@1
  signed int v2; // edx@1
  void *v3; // ecx@3
  char result; // al@3
  char v5; // [sp+4h] [bp-28h]@1
  char v6; // [sp+Ch] [bp-20h]@1

  v0 = &v5;
  v1 = &v6;
  v2 = 7;
  do
  {
    *v0 = 0;
    *(_DWORD *)v1 = 42066;
    ++v0;
    v1 += 4;
    --v2;
  }
  while ( v2 );
  sub_1007C500(41103, (int)&v5, 36);
  dword_10256460 = 0;
  dword_10256468 = 0;
  dword_10256464 = 0;
  byte_10250C41 = 0;
  dword_10250C44 = 0;
  dword_1025645C = 0;
  result = sub_100460C0(v3);
  byte_10250C40 = result;
  return result;
}
// 10250C40: using guessed type char byte_10250C40;
// 10250C41: using guessed type char byte_10250C41;
// 10250C44: using guessed type int dword_10250C44;
// 1025645C: using guessed type int dword_1025645C;
// 10256460: using guessed type int dword_10256460;
// 10256464: using guessed type int dword_10256464;
// 10256468: using guessed type int dword_10256468;

//----- (100278D0) --------------------------------------------------------
char __cdecl sub_100278D0(int a1, int a2)
{
  int v2; // ecx@0
  int v3; // eax@1
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v2;
  LOBYTE(v3) = sub_10023DC0(a1, a2, &dword_10250C48, (unsigned __int16 *)&v5);
  if ( (_BYTE)v3 == 1 )
  {
    v3 = j_REG_pvg_xfil_write_data(&dword_10250C48, (unsigned __int16)v5);
    if ( v3 != (unsigned __int16)v5 )
      LOBYTE(v3) = sub_10042930("..\\lib\\adl\\iop_xfil_reg_frmt.c", 345, 0, 0);
  }
  return v3;
}
// 1007C640: using guessed type int __cdecl j_REG_pvg_xfil_write_data(_DWORD, _DWORD);
// 10250C48: using guessed type int dword_10250C48;

//----- (10027930) --------------------------------------------------------
char __cdecl sub_10027930(int a1, int a2, __int16 a3)
{
  int v4; // [sp+0h] [bp-Ch]@1
  int v5; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v6 = 0;
  v4 = a2;
  LOWORD(v6) = a3;
  v5 = sub_100429D0((void *)a3);
  return sub_10023A50(266, a1, &v4, 1, (int)&byte_10332F00);
}
// 10332F00: using guessed type char byte_10332F00;

//----- (10027980) --------------------------------------------------------
int __cdecl sub_10027980(int a1, int a2)
{
  int v2; // ebx@1
  void *v3; // ecx@1
  int result; // eax@1

  v2 = sub_10022640(a1, a2);
  result = sub_100460A0(v3);
  if ( v2 & result )
  {
    sub_10043480(0x3Fu);
    result = *(_DWORD *)(a2 + 32);
    dword_10256460 |= *(_DWORD *)(52 * *(_WORD *)(*(_DWORD *)(a2 + 40) + 2 * (unsigned __int16)a1) + result + 20);
  }
  return result;
}
// 1025645C: using guessed type int dword_1025645C;
// 10256460: using guessed type int dword_10256460;

//----- (100279D0) --------------------------------------------------------
char __cdecl sub_100279D0(int a1)
{
  unsigned int v1; // eax@2
  char v2; // dl@3
  int v3; // ecx@5
  int v4; // eax@5
  __int16 v5; // si@8
  int v6; // eax@8
  char v8; // [sp+0h] [bp-3A8h]@8

  if ( !dword_10250C44 || (v1 = sub_1007C040(), dword_10250C44 <= v1) )
  {
    v2 = byte_10250C41;
    if ( (unsigned __int8)byte_10250C41 >= 0x32u )
    {
      v2 = 0;
      byte_10250C41 = 0;
    }
    v3 = 78 * (unsigned __int8)v2;
    v4 = 78;
    if ( v3 + 78 > 3873 )
    {
      v4 = 3873 - v3;
      if ( 3873 - v3 <= 0 )
      {
        v2 = 0;
        v4 = 78;
        byte_10250C41 = 0;
      }
    }
    v5 = j_reg_get_xfil_tag_data(&v8, 78 * (unsigned __int8)v2, v4);
    v6 = sub_1007C040();
    LOBYTE(v1) = sub_100234A0(a1, 12 * v5, 1, (int)&byte_10332F00, &v8, v6);
    ++byte_10250C41;
  }
  return v1;
}
// 1007C3A0: using guessed type int __cdecl j_reg_get_xfil_tag_data(_DWORD, _DWORD, _DWORD);
// 10250C41: using guessed type char byte_10250C41;
// 10250C44: using guessed type int dword_10250C44;
// 10332F00: using guessed type char byte_10332F00;

//----- (10027A80) --------------------------------------------------------
__int16 __thiscall sub_10027A80(void *this)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = sub_100429D0(this);
  return word_100E1F54[4 * sub_10043FF0(&v2, 4u, (int)&unk_100E1F50, 8, 7, 0)];
}
// 100E1F54: using guessed type __int16 word_100E1F54[];

//----- (10027AB0) --------------------------------------------------------
char __cdecl sub_10027AB0(int a1, int a2, unsigned __int16 a3)
{
  signed int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned __int8 v5; // bl@1
  int v6; // esi@8
  unsigned int v7; // ebp@8
  unsigned int v8; // edi@9
  int v9; // edi@15
  int v10; // ecx@20
  char v12; // [sp+13h] [bp-29h]@1
  char v13[8]; // [sp+14h] [bp-28h]@2
  int v14[7]; // [sp+1Ch] [bp-20h]@15

  v3 = a3 / 0xCu;
  LOBYTE(v4) = sub_10049E50(a1);
  v5 = v4;
  v12 = 0;
  if ( byte_10250C40 == 2 )
    LOBYTE(v4) = sub_1007C3B0(41103, (int)v13, 36);
  if ( (unsigned int)(v3 - 1) <= 0x4D && !(a3 % 0xCu) )
  {
    if ( !dword_10250C44 || (v4 = sub_1007C040(), dword_10250C44 <= v4) )
    {
      if ( v3 > 0 )
      {
        v6 = a2 + 2;
        v7 = a3 / 0xCu;
        while ( 1 )
        {
          v4 = j_REG_pvg_xfil_shld_rqst_tag(v6 - 2);
          v8 = v4;
          if ( v4 == 2 )
            LOBYTE(v4) = sub_10027930(a1, *(_WORD *)v6, *(_WORD *)(v6 + 8));
          if ( byte_10250C40 != 2 )
            goto LABEL_22;
          if ( v5 == 7 )
            goto LABEL_22;
          LOBYTE(v4) = sub_1003DC80(*(_WORD *)v6);
          if ( !(_BYTE)v4 )
            goto LABEL_22;
          if ( v8 != 1 )
          {
            v10 = *(_WORD *)v6;
            v4 = v5;
            v13[v4] = 0;
            v14[v4] = v10;
            goto LABEL_21;
          }
          v4 = *(_WORD *)v6;
          v9 = v14[v5];
          if ( v4 == v9 )
          {
            v4 = (unsigned int)&v13[v5];
            if ( v13[v5] != 1 )
            {
              *(_BYTE *)v4 = 1;
LABEL_21:
              v12 = 1;
              goto LABEL_22;
            }
          }
          else if ( v9 == 42066 )
          {
            v14[v5] = v4;
            goto LABEL_21;
          }
LABEL_22:
          v6 += 12;
          if ( !--v7 )
          {
            if ( v12 )
              LOBYTE(v4) = sub_1007C500(41103, (int)v13, 36);
            return v4;
          }
        }
      }
    }
  }
  return v4;
}
// 1007C630: using guessed type int __cdecl j_REG_pvg_xfil_shld_rqst_tag(_DWORD);
// 10250C40: using guessed type char byte_10250C40;
// 10250C44: using guessed type int dword_10250C44;
// 10027AB0: using guessed type char var_28[8];
// 10027AB0: using guessed type int var_20[7];

//----- (10027C10) --------------------------------------------------------
char __cdecl sub_10027C10(const void *a1, unsigned __int16 a2, int a3)
{
  void *v3; // ecx@0
  int v4; // esi@1
  int v5; // eax@1

  v4 = (unsigned __int16)sub_10027A80(v3);
  v5 = sub_1007C040();
  sub_100234A0(v4, a2, 1, (int)&byte_10332F00, a1, v5);
  return sub_10023790(v4, a3, (int)&byte_10332F00);
}
// 10332F00: using guessed type char byte_10332F00;

//----- (10027C50) --------------------------------------------------------
char __cdecl sub_10027C50(int a1, int a2)
{
  int v2; // eax@2
  int v3; // eax@4
  int v5; // [sp+8h] [bp-4h]@1

  memset(&unk_10256470, 0, 0x3A8u);
  if ( sub_10023DC0(a1, a2, &unk_10256470, (unsigned __int16 *)&v5) == 1 )
  {
    v2 = sub_10027E30(a1);
    sub_10027AB0(v2, (int)&unk_10256470, v5);
  }
  if ( dword_10256460 || (LOBYTE(v3) = sub_100432C0(63), (_BYTE)v3) )
  {
    v3 = ~*(_DWORD *)(52 * *(_WORD *)(*(_DWORD *)(a2 + 40) + 2 * (unsigned __int16)a1) + *(_DWORD *)(a2 + 32) + 20);
    dword_10256460 &= v3;
    if ( !dword_10256460 )
      LOBYTE(v3) = sub_10043370(63);
  }
  return v3;
}
// 10256460: using guessed type int dword_10256460;

//----- (10027CE0) --------------------------------------------------------
int __cdecl sub_10027CE0(int a1, __int16 a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  int v5; // eax@5
  bool v6; // zf@6

  dword_10250C48 = 0;
  dword_10250C4C = 0;
  dword_10250C50 = 0;
  dword_10250C54 = 0;
  byte_10250C58 = 0;
  result = j_REG_pvg_xfil_read_data(a1, &dword_10250C48, 22545, 1436);
  v4 = result;
  if ( result >= 0 && result )
  {
    if ( a1 == -1 || a2 == (_WORD)dword_10250C4C )
    {
      sub_10027C10(&dword_10250C48, result, a3);
      v5 = 0;
      while ( 1 )
      {
        v6 = *(int *)((char *)&dword_10250C50 + v5) == 3134;
        v5 += *(_WORD *)((char *)&dword_10250C4C + v5) + 17;
        if ( v6 )
          break;
        if ( v5 >= v4 )
          return v4;
      }
      dword_10250C44 = sub_1007C040() + 7000;
    }
    result = v4;
  }
  return result;
}
// 1007C620: using guessed type int __cdecl j_REG_pvg_xfil_read_data(_DWORD, _DWORD, _DWORD, _DWORD);
// 10250C44: using guessed type int dword_10250C44;
// 10250C48: using guessed type int dword_10250C48;
// 10250C4C: using guessed type int dword_10250C4C;
// 10250C50: using guessed type int dword_10250C50;
// 10250C54: using guessed type int dword_10250C54;
// 10250C58: using guessed type char byte_10250C58;

//----- (10027D90) --------------------------------------------------------
char __cdecl sub_10027D90(int a1, int a2)
{
  char result; // al@1
  int v3; // [sp+0h] [bp-Ch]@1
  int v4; // [sp+4h] [bp-8h]@1
  int v5; // [sp+8h] [bp-4h]@1

  v3 = 0;
  v4 = 0;
  v5 = 0;
  result = sub_10023DA0(a1, a2, &v3);
  if ( result == 1 )
    result = sub_10027CE0(v3, v5, v4);
  return result;
}

//----- (10027DE0) --------------------------------------------------------
int sub_10027DE0()
{
  signed int v0; // esi@1
  int result; // eax@2

  v0 = 0;
  do
  {
    result = sub_10027CE0(-1, 0, 0xFFFFFFF);
    if ( result <= 0 )
      break;
    ++v0;
  }
  while ( v0 < 10 );
  if ( v0 <= 0 || dword_1025645C > 50 )
  {
    result = j_REG_pvg_flush_que(2, 1, 12);
    dword_1025645C = 0;
  }
  else
  {
    ++dword_1025645C;
  }
  return result;
}
// 1007C350: using guessed type int __cdecl j_REG_pvg_flush_que(_DWORD, _DWORD, _DWORD);
// 1025645C: using guessed type int dword_1025645C;

//----- (10027E30) --------------------------------------------------------
int __cdecl sub_10027E30(char a1)
{
  return dword_100E250C[2 * sub_10043FF0(&a1, 2u, (int)&unk_100E2508, 8, 7, 0)];
}
// 100E250C: using guessed type int dword_100E250C[];

//----- (10027E60) --------------------------------------------------------
char __cdecl sub_10027E60(int a1, int a2, int a3, int a4, char a5, char *a6)
{
  int v6; // esi@1
  char v7; // al@2
  char result; // al@2

  v6 = sub_10043FF0(&a5, 1u, (int)&unk_100E2620, 201, 10, 10);
  if ( v6 == 10 )
  {
    result = 0;
  }
  else
  {
    v7 = sub_100528A0(a1);
    strncpy(a6, &byte_100E2621[201 * v6] + 100 * (unsigned __int8)v7, 0x64u);
    result = 1;
  }
  return result;
}

//----- (10027EC0) --------------------------------------------------------
void *sub_10027EC0()
{
  byte_10256819 = 0;
  byte_10256818 = 1;
  dword_10256864 = 0;
  return memset(&word_10256820, 0, 0x44u);
}
// 10256818: using guessed type char byte_10256818;
// 10256819: using guessed type char byte_10256819;
// 10256820: using guessed type __int16 word_10256820;
// 10256864: using guessed type int dword_10256864;

//----- (10027EF0) --------------------------------------------------------
char __cdecl sub_10027EF0(char a1, int a2)
{
  int v2; // eax@1
  char v3; // cl@3
  __int16 v4; // ax@3
  int v5; // edx@3
  int v6; // eax@3
  int v7; // ecx@3
  int v8; // eax@3
  int v9; // ecx@3
  int v10; // eax@3
  int v11; // ecx@3
  int v12; // edx@3
  int v13; // eax@3
  int v14; // ecx@3
  int v15; // eax@3
  int v16; // ecx@3
  char v17; // dl@3
  bool v18; // zf@3
  __int16 v19; // ax@10
  int v20; // edx@10
  int v22; // [sp+8h] [bp-58h]@1
  char v23; // [sp+Ch] [bp-54h]@1
  int v24; // [sp+10h] [bp-50h]@1
  int v25; // [sp+14h] [bp-4Ch]@1
  int v26; // [sp+18h] [bp-48h]@1
  int v27; // [sp+1Ch] [bp-44h]@1
  char v28; // [sp+20h] [bp-40h]@1
  __int16 v29; // [sp+22h] [bp-3Eh]@3
  int v30; // [sp+24h] [bp-3Ch]@3
  int v31; // [sp+28h] [bp-38h]@3
  char v32; // [sp+2Ch] [bp-34h]@3
  char v33; // [sp+2Eh] [bp-32h]@3
  char v34; // [sp+2Fh] [bp-31h]@3
  int v35; // [sp+30h] [bp-30h]@3
  int v36; // [sp+34h] [bp-2Ch]@3
  int v37; // [sp+38h] [bp-28h]@3
  int v38; // [sp+3Ch] [bp-24h]@3
  int v39; // [sp+40h] [bp-20h]@3
  int v40; // [sp+44h] [bp-1Ch]@3
  int v41; // [sp+48h] [bp-18h]@3
  int v42; // [sp+4Ch] [bp-14h]@3
  int v43; // [sp+50h] [bp-10h]@3
  int v44; // [sp+54h] [bp-Ch]@3
  int v45; // [sp+58h] [bp-8h]@3

  memset(&v28, 0, 0x3Cu);
  LOBYTE(v2) = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v22 = 0;
  v23 = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    LOBYTE(v2) = sub_1003C270(*(_WORD *)a2);
    if ( (_BYTE)v2 )
    {
      sub_10046600(a1, (int)&v28);
      v3 = *(_BYTE *)(a2 + 12);
      v4 = *(_WORD *)a2;
      v34 = *(_BYTE *)(a2 + 13);
      v40 = *(_DWORD *)(a2 + 36);
      v5 = *(_DWORD *)(a2 + 48);
      v29 = v4;
      v6 = *(_DWORD *)(a2 + 28);
      v33 = v3;
      v7 = *(_DWORD *)(a2 + 32);
      v43 = v5;
      LOBYTE(v5) = *(_BYTE *)(a2 + 10);
      v38 = v6;
      v8 = *(_DWORD *)(a2 + 40);
      v39 = v7;
      v9 = *(_DWORD *)(a2 + 44);
      v41 = v8;
      v10 = *(_DWORD *)(a2 + 2);
      v42 = v9;
      v11 = *(_DWORD *)(a2 + 6);
      v32 = v5;
      v12 = *(_DWORD *)(a2 + 24);
      v30 = v10;
      v13 = *(_DWORD *)(a2 + 16);
      v31 = v11;
      v14 = *(_DWORD *)(a2 + 20);
      v37 = v12;
      v35 = v13;
      v15 = *(_DWORD *)(a2 + 52);
      v36 = v14;
      v16 = *(_DWORD *)(a2 + 56);
      v44 = v15;
      v45 = v16;
      sub_100186A0(a1, (int)&v28);
      sub_10046620((int)&v22);
      v17 = *(_BYTE *)(a2 + 60);
      v18 = *(_BYTE *)(a2 + 64) == 1;
      BYTE3(v22) = *(_BYTE *)(a2 + 63);
      LOBYTE(v22) = v17;
      v23 = 0;
      if ( v18 )
        v23 = 1;
      if ( *(_BYTE *)(a2 + 65) )
        v23 |= 4u;
      if ( *(_BYTE *)(a2 + 66) )
        v23 |= 2u;
      *(_WORD *)((char *)&v22 + 1) = *(_WORD *)(a2 + 61);
      sub_100186C0((int)&v22);
      v2 = sub_1007C3B0(2105, (int)&v24, 16);
      if ( !v2 )
      {
        v19 = *(_WORD *)a2;
        v20 = *(_DWORD *)(a2 + 6);
        *(int *)((char *)&v24 + 2) = *(_DWORD *)(a2 + 2);
        HIWORD(v27) = v19;
        LOBYTE(v19) = *(_BYTE *)(a2 + 10);
        *(int *)((char *)&v25 + 2) = v20;
        BYTE2(v26) = v19;
        LOBYTE(v2) = sub_1007C500(2105, (int)&v24, 16);
      }
    }
  }
  return v2;
}

//----- (100280A0) --------------------------------------------------------
int __cdecl sub_100280A0(char a1, __int16 a2)
{
  __int16 v3; // [sp+4h] [bp-40h]@1

  memset(&v3, 0, 0x3Cu);
  sub_10046600(a1, (int)&v3);
  v3 = a2;
  return sub_100186A0(a1, (int)&v3);
}

//----- (10028110) --------------------------------------------------------
char __cdecl sub_10028110(char a1, char a2, _BYTE *a3)
{
  bool v3; // bl@1
  int v4; // esi@1
  char result; // al@4
  char v6; // al@26
  char v7; // ST0C_1@36
  char v8; // al@36
  __int16 v9; // [sp+10h] [bp-54h]@1
  char v10; // [sp+14h] [bp-50h]@26
  int v11; // [sp+18h] [bp-4Ch]@1
  char v12; // [sp+1Ch] [bp-48h]@1
  char v13; // [sp+2Fh] [bp-35h]@8

  memset(&v12, 0, 0x44u);
  v3 = 0;
  LOBYTE(v11) = sub_100528A0(a1);
  v9 = 9;
  v4 = v11;
  switch ( a2 )
  {
    case 2:
      HIBYTE(v9) = *a3 + 69;
      if ( (unsigned __int8)(HIBYTE(v9) - 69) <= 5u )
        break;
      goto LABEL_3;
    default:
      goto LABEL_3;
    case 0:
    case 0xC:
      HIBYTE(v9) = *a3 + 67;
      if ( (unsigned __int8)(HIBYTE(v9) - 67) <= 1u )
        break;
      goto LABEL_3;
    case 0x11:
      sub_10052DE0(v11, (int)&v12);
      if ( sub_1003C380(v11) || v13 != 1 )
        HIBYTE(v9) = 81;
      else
        HIBYTE(v9) = 102;
      break;
    case 0x13:
      HIBYTE(v9) = 50;
      break;
    case 0xB:
    case 0x12:
    case 0x1C:
      break;
  }
  v3 = 1;
  if ( sub_10018710() == 2 )
  {
    if ( j_HWM_pvg_read_reg(1) == 1 )
    {
      sub_10052DE0(v11, (int)&word_10256820);
      sub_10028F90(v11, &word_10256820, 0);
    }
    if ( HIBYTE(v9) )
    {
      sub_1003CAA0(v11, &v9);
      sub_10018810(7);
    }
    else
    {
      sub_10053680(v11);
      sub_10018810(7);
    }
    return v3;
  }
  if ( j_HWM_pvg_read_reg(1) == 1 )
    sub_10028F90(v11, &word_10256820, byte_10256818 == 0);
  if ( a2 != 17 )
  {
    v3 = sub_10053680(v11) == 0;
    goto LABEL_22;
  }
  v6 = sub_100535B0(v11, HIBYTE(v9) == 81, &v10);
  v3 = v6;
  if ( byte_10256818 )
  {
    if ( v6 )
    {
      sub_10028CF0(v4);
      goto LABEL_29;
    }
LABEL_28:
    byte_10256818 = 0;
    sub_1003CAA0(v4, &v9);
LABEL_29:
    v3 = 0;
    goto LABEL_30;
  }
  if ( !v6 )
    goto LABEL_28;
LABEL_22:
  if ( v3 == 1 )
  {
    if ( sub_10018710() == 5 && sub_100186F0() == 1 )
    {
      sub_10018810(10);
      return v3;
    }
    if ( sub_10018710() != 7 || a2 != 17 )
    {
      if ( sub_10018710() == 4 )
      {
        sub_100186E0();
        sub_10018810(1);
        return v3;
      }
      sub_10018810(4);
      byte_10256819 = 3;
      dword_10256864 = sub_1007C040();
      result = 1;
    }
    else
    {
      v7 = sub_100186F0();
      v8 = sub_10018710();
      sub_10018760(v8, a1, v7, 17, (int)a3, &v10, 2u);
      sub_10018810(10);
      result = 1;
    }
    return result;
  }
LABEL_30:
  sub_10018720();
  if ( (unsigned int)sub_10018700() > 0xA )
  {
LABEL_3:
    sub_10018810(8);
    return v3;
  }
  sub_10018810(4);
  byte_10256819 = 2;
  dword_10256864 = sub_1007C040();
  return v3;
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10256818: using guessed type char byte_10256818;
// 10256819: using guessed type char byte_10256819;
// 10256820: using guessed type __int16 word_10256820;
// 10256864: using guessed type int dword_10256864;

//----- (10028400) --------------------------------------------------------
char __cdecl sub_10028400(char a1, int a2, char a3, int a4, int a5, size_t a6)
{
  char v6; // bl@1
  bool v7; // zf@9
  char *v8; // esi@16
  char v9; // al@28
  char result; // al@28
  unsigned int v11; // [sp+14h] [bp-4Ch]@0
  char v12; // [sp+18h] [bp-48h]@1

  memset(&v12, 0, 0x44u);
  v6 = 0;
  LOBYTE(v11) = sub_100528A0(a1);
  switch ( a3 )
  {
    case 2:
      sub_10028D50(v11, a3, (_BYTE *)a4);
      v6 = sub_10052F50(v11, *(_BYTE *)a4, a5);
      if ( v6 )
      {
        sub_10052DE0(v11, (int)&v12);
        qmemcpy(&word_10256820, &v12, 0x44u);
        dword_1025683C[*(_BYTE *)a4] = *(_DWORD *)a5;
      }
      goto LABEL_27;
    case 0xC:
      sub_10028D50(v11, a3, (_BYTE *)a4);
      v6 = sub_100538F0(v11, *(_BYTE *)a4, a5);
      if ( !v6 )
        goto LABEL_27;
      sub_10052DE0(v11, (int)&v12);
      qmemcpy(&word_10256820, &v12, 0x44u);
      if ( !*(_BYTE *)a5 )
      {
        byte_10256854[4 * *(_BYTE *)a4] = *(_BYTE *)(a5 + 1);
        if ( *(_BYTE *)a4 )
          goto LABEL_14;
        v7 = byte_10256854[0] == 7;
        goto LABEL_13;
      }
      if ( *(_BYTE *)a5 == 1 )
      {
        *((_BYTE *)&unk_10256855 + 4 * *(_BYTE *)a4) = *(_BYTE *)(a5 + 1);
        if ( !*(_BYTE *)a4 )
        {
          if ( sub_1003C450(v11) )
            v7 = *((_BYTE *)&unk_10256855 + 4 * *(_BYTE *)a4) == 4;
          else
            v7 = *((_BYTE *)&unk_10256855 + 4 * *(_BYTE *)a4) == 3;
LABEL_13:
          v6 = v7;
          goto LABEL_14;
        }
      }
LABEL_14:
      byte_10256856[4 * *(_BYTE *)a4] = sub_100542C0(*(_BYTE *)(a5 + 1), *(_BYTE *)a5);
      byte_10256857[4 * *(_BYTE *)a4] = sub_10054360(*(_BYTE *)(a5 + 1), *(_BYTE *)a5);
LABEL_27:
      if ( v6 == 1 )
      {
        v9 = sub_100186F0();
        sub_10018760(7, a1, v9, a3, 0, (void *)a5, a6);
        sub_10018810(4);
        byte_10256819 = 2;
        dword_10256864 = sub_1007C040();
        result = 1;
      }
      else
      {
LABEL_29:
        sub_10018810(8);
        result = v6;
      }
      return result;
    case 0xB:
    case 0x12:
    case 0x1C:
      if ( a6 )
      {
        v8 = (char *)a5;
        v6 = a6 == 68;
        if ( a6 != 68 )
          goto LABEL_27;
      }
      else
      {
        v6 = 1;
        sub_10052DE0(v11, (int)&v12);
        v8 = &v12;
      }
      if ( a3 != 28 && a3 != 11 || (sub_10052D70((int)v8, v11), a3 == 11) )
        sub_10052C60((int)v8, v11);
      sub_10053D00(v11, (int)v8, a3);
      sub_10028D50(v11, a3, 0);
      sub_10052DE0(v11, (int)&word_10256820);
      if ( a3 == 18 )
      {
        *((_DWORD *)v8 + 7) = dword_1025683C[0];
        *((_DWORD *)v8 + 8) = dword_10256840;
        *((_DWORD *)v8 + 9) = dword_10256844;
        *((_DWORD *)v8 + 10) = dword_10256848;
        *((_DWORD *)v8 + 11) = dword_1025684C;
        *((_DWORD *)v8 + 12) = dword_10256850;
        *((_DWORD *)v8 + 13) = *(_DWORD *)byte_10256854;
        *((_DWORD *)v8 + 14) = dword_10256858;
      }
      else if ( a3 == 28 )
      {
        dword_1025683C[0] = *((_DWORD *)v8 + 7);
        dword_10256840 = *((_DWORD *)v8 + 8);
        dword_10256844 = *((_DWORD *)v8 + 9);
        dword_10256848 = *((_DWORD *)v8 + 10);
        dword_1025684C = *((_DWORD *)v8 + 11);
        dword_10256850 = *((_DWORD *)v8 + 12);
        *(_DWORD *)byte_10256854 = *((_DWORD *)v8 + 13);
        dword_10256858 = *((_DWORD *)v8 + 14);
        goto LABEL_27;
      }
      qmemcpy(&word_10256820, v8, 0x44u);
      goto LABEL_27;
    default:
      goto LABEL_29;
  }
}
// 10256819: using guessed type char byte_10256819;
// 10256820: using guessed type __int16 word_10256820;
// 1025683C: using guessed type int dword_1025683C[];
// 10256840: using guessed type int dword_10256840;
// 10256844: using guessed type int dword_10256844;
// 10256848: using guessed type int dword_10256848;
// 1025684C: using guessed type int dword_1025684C;
// 10256850: using guessed type int dword_10256850;
// 10256858: using guessed type int dword_10256858;
// 10256864: using guessed type int dword_10256864;

//----- (10028780) --------------------------------------------------------
char __cdecl sub_10028780(char a1, char a2, char a3, int a4, __int16 *a5)
{
  char v5; // bl@3
  char v7; // [sp+8h] [bp-90h]@1
  char v8; // [sp+Ch] [bp-8Ch]@8
  int v9; // [sp+28h] [bp-70h]@8
  int v10; // [sp+2Ch] [bp-6Ch]@8
  int v11; // [sp+30h] [bp-68h]@8
  int v12; // [sp+34h] [bp-64h]@8
  int v13; // [sp+38h] [bp-60h]@8
  int v14; // [sp+3Ch] [bp-5Ch]@8
  int v15; // [sp+40h] [bp-58h]@8
  int v16; // [sp+44h] [bp-54h]@8
  char v17; // [sp+50h] [bp-48h]@5
  int v18; // [sp+6Ch] [bp-2Ch]@8
  int v19; // [sp+70h] [bp-28h]@8
  int v20; // [sp+74h] [bp-24h]@8
  int v21; // [sp+78h] [bp-20h]@8
  int v22; // [sp+7Ch] [bp-1Ch]@8
  int v23; // [sp+80h] [bp-18h]@8
  int v24; // [sp+84h] [bp-14h]@8
  int v25; // [sp+88h] [bp-10h]@8

  v7 = sub_100528A0(a1);
  if ( a2 )
  {
    v5 = sub_10053490(v7, &v17);
    if ( v5 )
    {
      if ( a3 == 18 )
      {
        sub_10052DE0(v7, (int)&v8);
        v24 = v15;
        v25 = v16;
        v18 = v9;
        v19 = v10;
        v20 = v11;
        v21 = v12;
        v22 = v13;
        v23 = v14;
      }
      else if ( a3 == 28 )
      {
        sub_10052DE0(v7, (int)&v8);
        v15 = v24;
        v16 = v25;
        v9 = v18;
        v10 = v19;
        v11 = v20;
        v12 = v21;
        v13 = v22;
        v14 = v23;
        qmemcpy(&v17, &v8, 0x44u);
      }
      sub_10027EF0(v7, (int)&v17);
      byte_10256818 = 1;
    }
    if ( v5 != 1 )
    {
      sub_10018810(8);
      return v5;
    }
  }
  else if ( a3 == 17 )
  {
    sub_100280A0(v7, *a5);
    v5 = 1;
  }
  else
  {
    sub_10027EF0(v7, (int)&word_10256820);
    byte_10256818 = 1;
    v5 = 1;
  }
  if ( byte_10256818 )
  {
    sub_10018760(7, a1, 0, 17, 0, 0, 0);
    sub_10028CF0(v7);
    sub_10018810(2);
    sub_100186E0();
  }
  else
  {
    sub_10018810(7);
  }
  return v5;
}
// 10256818: using guessed type char byte_10256818;
// 10256820: using guessed type __int16 word_10256820;

//----- (10028980) --------------------------------------------------------
char __cdecl sub_10028980(char a1, char a2)
{
  char v2; // si@1
  int v3; // eax@3
  int v4; // edx@3
  char v5; // bl@3
  __int16 v6; // bp@3
  unsigned int v7; // eax@6
  __int16 *v8; // ecx@6
  int *v9; // edx@6
  unsigned int v10; // eax@10
  char *v11; // ecx@10
  int *v12; // edx@10
  int v13; // esi@14
  int v14; // eax@15
  _BYTE *v15; // ecx@15
  _BYTE *v16; // edx@15
  int v17; // eax@17
  _BYTE *v18; // ecx@17
  _BYTE *v19; // edx@17
  _BYTE *v20; // ecx@19
  _BYTE *v21; // edx@19
  signed int v22; // eax@21
  int v23; // esi@33
  int v24; // eax@34
  _BYTE *v25; // ecx@34
  _BYTE *v26; // edx@34
  int v27; // eax@36
  _BYTE *v28; // ecx@36
  _BYTE *v29; // edx@36
  _BYTE *v30; // ecx@38
  _BYTE *v31; // edx@38
  signed int v32; // eax@40
  char v34; // [sp+10h] [bp-48h]@1
  char v35; // [sp+21h] [bp-37h]@2
  int v36; // [sp+2Ch] [bp-2Ch]@25
  int v37; // [sp+30h] [bp-28h]@29
  int v38; // [sp+34h] [bp-24h]@29
  int v39; // [sp+38h] [bp-20h]@29
  int v40; // [sp+3Ch] [bp-1Ch]@29
  int v41; // [sp+40h] [bp-18h]@29
  int v42; // [sp+44h] [bp-14h]@10
  int v43; // [sp+48h] [bp-10h]@29

  memset(&v34, 0, 0x44u);
  v2 = sub_100528A0(a1);
  if ( !sub_10053490(v2, &v34) )
    goto LABEL_45;
  byte_10256831 = v35;
  if ( sub_1003C380(v2) )
  {
    v3 = *(_DWORD *)byte_10256854;
    v4 = dword_10256858;
    v5 = byte_10256830;
    v6 = word_10256820;
    qmemcpy(&word_10256820, &v34, 0x44u);
    word_10256820 = v6;
    *(_DWORD *)byte_10256854 = v3;
    dword_10256858 = v4;
    byte_10256830 = v5;
  }
  if ( a2 == 18 )
  {
    *(_DWORD *)byte_10256854 = v42;
    dword_10256858 = v43;
    dword_1025683C[0] = v36;
    dword_10256840 = v37;
    dword_10256844 = v38;
    dword_10256848 = v39;
    dword_1025684C = v40;
    dword_10256850 = v41;
    v7 = 68;
    v8 = &word_10256820;
    v9 = (int *)&v34;
    while ( *v9 == *(_DWORD *)v8 )
    {
      v7 -= 4;
      v8 += 2;
      ++v9;
      if ( v7 < 4 )
      {
LABEL_32:
        if ( !v7 )
          goto LABEL_42;
        break;
      }
    }
  }
  else
  {
    if ( a2 == 28 )
    {
      v10 = 8;
      v11 = byte_10256854;
      v12 = &v42;
      do
      {
        if ( *v12 != *(_DWORD *)v11 )
          goto LABEL_14;
        v10 -= 4;
        v11 += 4;
        ++v12;
      }
      while ( v10 >= 4 );
      if ( v10 )
      {
LABEL_14:
        v13 = *(_BYTE *)v12 - (unsigned __int8)*v11;
        if ( *(_BYTE *)v12 != (unsigned __int8)*v11
          || (v14 = v10 - 1, v15 = v11 + 1, v16 = (char *)v12 + 1, v14)
          && ((v13 = *v16 - *v15, *v16 != *v15)
           || (v17 = v14 - 1, v18 = v15 + 1, v19 = v16 + 1, v17)
           && ((v13 = *v19 - *v18, *v19 != *v18)
            || (v20 = v18 + 1, v21 = v19 + 1, v17 != 1) && (v13 = *v21 - *v20, *v21 != *v20))) )
        {
          v22 = 1;
          if ( v13 <= 0 )
            v22 = -1;
LABEL_24:
          if ( v22 )
            goto LABEL_45;
          v7 = 24;
          v8 = (__int16 *)dword_1025683C;
          v9 = &v36;
          while ( *v9 == *(_DWORD *)v8 )
          {
            v7 -= 4;
            v8 += 2;
            ++v9;
            if ( v7 < 4 )
              goto LABEL_32;
          }
          goto LABEL_33;
        }
      }
      v22 = 0;
      goto LABEL_24;
    }
    v7 = 68;
    v8 = &word_10256820;
    v9 = (int *)&v34;
    while ( *v9 == *(_DWORD *)v8 )
    {
      v7 -= 4;
      v8 += 2;
      ++v9;
      if ( v7 < 4 )
        goto LABEL_32;
    }
  }
LABEL_33:
  v23 = *(_BYTE *)v9 - *(_BYTE *)v8;
  if ( *(_BYTE *)v9 != *(_BYTE *)v8
    || (v24 = v7 - 1, v25 = (char *)v8 + 1, v26 = (char *)v9 + 1, v24)
    && ((v23 = *v26 - *v25, *v26 != *v25)
     || (v27 = v24 - 1, v28 = v25 + 1, v29 = v26 + 1, v27)
     && ((v23 = *v29 - *v28, *v29 != *v28)
      || (v30 = v28 + 1, v31 = v29 + 1, v27 != 1) && (v23 = *v31 - *v30, *v31 != *v30))) )
  {
    v32 = 1;
    if ( v23 <= 0 )
      v32 = -1;
  }
  else
  {
LABEL_42:
    v32 = 0;
  }
  if ( !v32 )
  {
    sub_10018810(10);
    return 1;
  }
LABEL_45:
  sub_10018720();
  if ( (unsigned int)sub_10018700() <= 0xA )
    sub_10018810(1);
  else
    sub_10018810(8);
  return 0;
}
// 10256820: using guessed type __int16 word_10256820;
// 10256830: using guessed type char byte_10256830;
// 10256831: using guessed type char byte_10256831;
// 1025683C: using guessed type int dword_1025683C[];
// 10256840: using guessed type int dword_10256840;
// 10256844: using guessed type int dword_10256844;
// 10256848: using guessed type int dword_10256848;
// 1025684C: using guessed type int dword_1025684C;
// 10256850: using guessed type int dword_10256850;
// 10256858: using guessed type int dword_10256858;

//----- (10028C50) --------------------------------------------------------
char sub_10028C50()
{
  if ( (unsigned int)(sub_1007C040() - dword_10256864) > 0x3E8 )
    sub_10018810((unsigned __int8)byte_10256819);
  return 1;
}
// 10256819: using guessed type char byte_10256819;
// 10256864: using guessed type int dword_10256864;

//----- (10028C80) --------------------------------------------------------
void __cdecl sub_10028C80(__int16 a1)
{
  if ( !byte_1025686A )
  {
    switch ( a1 )
    {
      case 0x4B8:
      case 0x4B9:
        LOBYTE(word_10256874) = 1;
        sub_100399E0(0);
        break;
      case 0x4C4:
      case 0x4C5:
        HIBYTE(word_10256874) = 1;
        sub_100399E0(1u);
        break;
      default:
        return;
    }
  }
}
// 1025686A: using guessed type char byte_1025686A;
// 10256874: using guessed type __int16 word_10256874;

//----- (10028CF0) --------------------------------------------------------
int __cdecl sub_10028CF0(unsigned __int8 a1)
{
  int result; // eax@1
  int v2; // ecx@1

  result = sub_1007C110(39, 200);
  v2 = a1;
  *(_WORD *)(dword_10256870 + 2 * v2 + 136) = 0;
  *(_BYTE *)(v2 + dword_10256870 + 140) = 0;
  *(_BYTE *)(v2 + dword_10256870 + 164) = 0;
  if ( !result )
    result = sub_1007C0F0(39);
  return result;
}
// 10256870: using guessed type int dword_10256870;

//----- (10028D50) --------------------------------------------------------
int __cdecl sub_10028D50(unsigned __int8 a1, unsigned __int8 a2, _BYTE *a3)
{
  int v3; // edi@1
  int result; // eax@1
  int v5; // edx@6
  int v6; // esi@7
  int v7; // ecx@7

  v3 = sub_1007C110(39, 200);
  result = a2 - 2;
  switch ( a2 )
  {
    case 0xCu:
      result = dword_10256870 + *a3;
      *(_BYTE *)(result + 2 * a1 + 158) = 0;
      break;
    case 2u:
      result = dword_10256870 + *a3;
      *(_BYTE *)(result + 6 * (a1 + 24)) = 0;
      break;
    case 0x13u:
      *(_BYTE *)(a1 + dword_10256870 + 162) = 0;
      break;
    case 0x12u:
      result = a1;
      *(_BYTE *)(result + dword_10256870 + 156) = 0;
      *(_BYTE *)(result + dword_10256870 + 162) = 0;
      *(_BYTE *)(result + dword_10256870 + 142) = 0;
      *(_BYTE *)(result + dword_10256870 + 168) = 0;
      *(_BYTE *)(result + dword_10256870 + 166) = 0;
      *(_BYTE *)(result + dword_10256870 + 170) = 0;
      *(_BYTE *)(result + dword_10256870 + 174) = 0;
      *(_BYTE *)(result + dword_10256870 + 176) = 0;
      *(_BYTE *)(result + dword_10256870 + 172) = 0;
      break;
    case 0x1Cu:
      result = a1;
      v5 = dword_10256870 + 2 * (3 * a1 + 72);
      *(_DWORD *)v5 = 0;
      *(_WORD *)(v5 + 4) = 0;
      *(_WORD *)(dword_10256870 + 2 * a1 + 158) = 0;
      break;
    case 0xBu:
      v6 = a1;
      memset((void *)(dword_10256870 + 68 * a1), 0, 0x44u);
      v7 = dword_10256870 + 2 * (3 * a1 + 72);
      *(_DWORD *)v7 = 0;
      *(_WORD *)(v7 + 4) = 0;
      *(_WORD *)(dword_10256870 + 2 * v6 + 158) = 0;
      *(_BYTE *)(v6 + dword_10256870 + 156) = 0;
      *(_BYTE *)(v6 + dword_10256870 + 162) = 0;
      *(_BYTE *)(v6 + dword_10256870 + 142) = 0;
      *(_BYTE *)(v6 + dword_10256870 + 168) = 0;
      *(_BYTE *)(v6 + dword_10256870 + 166) = 0;
      *(_BYTE *)(v6 + dword_10256870 + 170) = 0;
      result = dword_10256870;
      *(_BYTE *)(v6 + dword_10256870 + 174) = 0;
      *(_BYTE *)(v6 + dword_10256870 + 176) = 0;
      *(_BYTE *)(v6 + dword_10256870 + 172) = 0;
      break;
    default:
      break;
  }
  if ( !v3 )
    result = sub_1007C0F0(39);
  return result;
}
// 10256870: using guessed type int dword_10256870;

//----- (10028F90) --------------------------------------------------------
char __cdecl sub_10028F90(char a1, _BYTE *a2, char a3)
{
  int v3; // eax@1
  void *v4; // ecx@2
  int v5; // ecx@5
  bool v6; // zf@7
  int v8; // [sp-8h] [bp-68h]@11
  int v9; // [sp+8h] [bp-58h]@1
  _BYTE *v10; // [sp+Ch] [bp-54h]@1
  int v11; // [sp+10h] [bp-50h]@1
  int v12; // [sp+14h] [bp-4Ch]@1
  int v13; // [sp+18h] [bp-48h]@1
  int v14; // [sp+1Ch] [bp-44h]@1
  __int16 v15; // [sp+20h] [bp-40h]@4
  char v16; // [sp+33h] [bp-2Dh]@5

  v10 = a2;
  LOWORD(v9) = 6167;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v3 = j_HWM_pvg_read_reg(1);
  if ( v3 == 1 )
  {
    if ( sub_10050960(*((_BYTE *)&v9 + (unsigned __int8)a1)) || (LOBYTE(v3) = sub_100460C0(v4), (_BYTE)v3 == 2) )
    {
      v9 = sub_1007C110(39, 200);
      qmemcpy((void *)(dword_10256870 + 68 * (unsigned __int8)a1), a2, 0x44u);
      sub_10046600(a1, (int)&v15);
      *(_WORD *)(dword_10256870 + 2 * (unsigned __int8)a1 + 136) = v15;
      if ( sub_1003C380(a1) )
      {
        *(_BYTE *)(dword_10256870 + (unsigned __int8)a1 + 140) = 1;
      }
      else
      {
        v5 = dword_10256870 + 2 * (3 * (unsigned __int8)a1 + 72);
        *(_DWORD *)v5 = 16843009;
        *(_WORD *)(v5 + 4) = 257;
        *(_BYTE *)(dword_10256870 + (unsigned __int8)a1 + 140) = v16 != 1;
      }
      v6 = v9 == 0;
      *(_WORD *)(dword_10256870 + 2 * (unsigned __int8)a1 + 158) = 257;
      *(_BYTE *)(dword_10256870 + (unsigned __int8)a1 + 142) = 1;
      *(_BYTE *)(dword_10256870 + (unsigned __int8)a1 + 156) = 1;
      *(_BYTE *)(dword_10256870 + (unsigned __int8)a1 + 162) = 1;
      *(_BYTE *)(dword_10256870 + (unsigned __int8)a1 + 164) = a3;
      *(_BYTE *)(dword_10256870 + (unsigned __int8)a1 + 170) = 1;
      *(_BYTE *)(dword_10256870 + (unsigned __int8)a1 + 168) = 1;
      *(_BYTE *)(dword_10256870 + (unsigned __int8)a1 + 166) = 1;
      *(_BYTE *)(dword_10256870 + (unsigned __int8)a1 + 172) = 1;
      *(_BYTE *)(dword_10256870 + (unsigned __int8)a1 + 174) = 1;
      *(_BYTE *)(dword_10256870 + (unsigned __int8)a1 + 176) = 1;
      if ( v6 )
        sub_1007C0F0(39);
      if ( !sub_1007C3B0(2105, (int)&v11, 16) )
      {
        HIWORD(v14) = *(_WORD *)v10;
        sub_100421E0((int)&v11 + 2, v10 + 2, 9);
        sub_1007C500(2105, (int)&v11, 16);
      }
      v8 = sub_1007C040();
      if ( a1 )
        LOBYTE(v3) = sub_10023190(1215, 1, (int)&byte_10332F00, &v11, v8);
      else
        LOBYTE(v3) = sub_10023190(1203, 1, (int)&byte_10332F00, &v11, v8);
    }
  }
  return v3;
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10256870: using guessed type int dword_10256870;
// 10332F00: using guessed type char byte_10332F00;

//----- (100291D0) --------------------------------------------------------
char sub_100291D0()
{
  char result; // al@1
  int v1; // ecx@2
  char v2; // al@3
  __int16 v3; // ax@3

  result = sub_10047380();
  if ( !result )
  {
    result = sub_10047140();
    if ( result )
    {
      v2 = sub_1003C120(v1);
      v3 = sub_1003C8C0(v2);
      result = sub_1003D0E0(v3);
    }
  }
  return result;
}

//----- (10029200) --------------------------------------------------------
char __cdecl sub_10029200(char a1)
{
  int v1; // edi@1
  unsigned int v2; // eax@1
  char v3; // bl@2
  void *v4; // ecx@2
  unsigned __int8 v5; // di@8
  char v6; // ST04_1@15
  char v8; // [sp+7h] [bp-49h]@13
  char v9; // [sp+8h] [bp-48h]@1
  char v10; // [sp+9h] [bp-47h]@1
  char v11; // [sp+Ah] [bp-46h]@1
  char v12; // [sp+Bh] [bp-45h]@1
  void *v13; // [sp+Ch] [bp-44h]@4
  __int16 v14; // [sp+10h] [bp-40h]@1
  char v15; // [sp+23h] [bp-2Dh]@7

  v9 = 0;
  v10 = 1;
  v11 = 1;
  v12 = 0;
  memset(&v14, 0, 0x3Cu);
  v1 = sub_1007C040();
  LOBYTE(v2) = a1;
  if ( (unsigned __int8)a1 < 2u )
  {
    v3 = *(&v9 + 2 * (unsigned __int8)a1);
    LOBYTE(v2) = sub_1003C170(*(&v9 + 2 * (unsigned __int8)a1));
    if ( (_BYTE)v2 )
    {
      LOBYTE(v2) = sub_100474F0(v4);
      if ( (_BYTE)v2 )
      {
        LOBYTE(v13) = sub_10052A00(v3);
        sub_10046600(v3, (int)&v14);
        if ( *(_BYTE *)((unsigned __int8)a1 + dword_10256870 + 164) == 1
          && (sub_1003C380(a1) && *(_BYTE *)((unsigned __int8)a1 + dword_10256870 + 140)
           || *(_BYTE *)((unsigned __int8)a1 + dword_10256870 + 140) == (v15 != 1)) )
        {
          v5 = (unsigned __int8)v13;
          if ( v14 != *(_WORD *)(dword_10256870 + 2 * (unsigned __int8)a1 + 136)
            || (LOBYTE(v2) = sub_10049600(v13), !(_BYTE)v2) )
          {
            sub_1003CF20((unsigned __int8)*(&v10 + 2 * (unsigned __int8)a1));
            sub_1003DF00(v5, 0);
            LOBYTE(v2) = sub_100398B0(a1);
          }
          *((_BYTE *)&word_10256868 + (unsigned __int8)a1) = 1;
        }
        else
        {
          v2 = v1 - dword_10256878[(unsigned __int8)a1];
          if ( v2 > 0x64 )
          {
            LOBYTE(v2) = sub_1003DE70(&v8);
            if ( (_BYTE)v2 != 1 || !v8 )
            {
              v6 = (char)v13;
              dword_10256878[(unsigned __int8)a1] = v1;
              LOBYTE(v2) = sub_1003DED0(v6, 17, 0);
            }
          }
        }
      }
    }
  }
  return v2;
}
// 10256868: using guessed type __int16 word_10256868;
// 10256870: using guessed type int dword_10256870;
// 10256878: using guessed type int dword_10256878[];

//----- (10029380) --------------------------------------------------------
char sub_10029380()
{
  char result; // al@2
  const char *v1; // [sp+0h] [bp-14h]@1
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+8h] [bp-Ch]@1
  int v4; // [sp+Ch] [bp-8h]@1
  int *v5; // [sp+10h] [bp-4h]@1

  v1 = "/shr_mem/iop_gtx_intf.shr";
  v2 = 5;
  v3 = 180;
  v4 = 0;
  v5 = &dword_10256870;
  dword_10256870 = -15;
  if ( sub_1007CD60((LONG)&v1) )
  {
    sub_1007C8F0((int)&v1);
    result = dword_10256870;
    dword_10337088 = dword_10256870;
  }
  else
  {
    result = sub_10042930("..\\lib\\acl\\iop\\iop_xpdr_frmt.c", 1197, 1, 0);
    dword_10337088 = dword_10256870;
  }
  return result;
}
// 10256870: using guessed type int dword_10256870;
// 10337088: using guessed type int dword_10337088;

//----- (10029410) --------------------------------------------------------
bool __thiscall sub_10029410(void *this)
{
  int v1; // esi@1
  void *v2; // ecx@1
  int v3; // edi@1
  void *v4; // ecx@1
  int v5; // eax@1
  int v6; // ecx@1
  int v7; // esi@1

  v1 = sub_10046CE0(this);
  v3 = sub_100460A0(v2);
  v5 = sub_100429D0(v4);
  v6 = 0;
  v7 = v5 | ~v1;
  while ( !(v7 & dword_100E3C68[v6] & v3) )
  {
    if ( ++v6 >= 3 )
      return 1;
  }
  return v5 == dword_100E3C68[v6];
}
// 100E3C68: using guessed type int dword_100E3C68[];

//----- (10029460) --------------------------------------------------------
char sub_10029460()
{
  unsigned __int8 v0; // bl@1
  void *v1; // ecx@6
  char result; // al@8
  int v3; // [sp+0h] [bp-4Ch]@0
  char v4; // [sp+4h] [bp-48h]@1

  memset(&v4, 0, 0x44u);
  sub_10029380();
  dword_10256878[0] = 0;
  dword_1025687C = 0;
  word_10256868 = 0;
  word_10256874 = 257;
  v0 = 0;
  byte_1025686A = sub_100472E0();
  byte_1025686B = 0;
  LOBYTE(v3) = 0;
  do
  {
    if ( (unsigned __int8)sub_1003C170(v3) )
    {
      sub_1003CB30(v3);
      sub_1003CB00(v3);
      if ( j_HWM_pvg_read_reg(1) == 1 )
      {
        sub_10052DE0(v3, (int)&v4);
        sub_10028F90(v3, &v4, 0);
      }
    }
    LOBYTE(v3) = ++v0;
  }
  while ( v0 < 2u );
  word_1025686C = 0;
  if ( sub_10047160() )
    word_1025686C = 257;
  result = sub_100460C0(v1);
  if ( result == 4 )
  {
    result = sub_100291D0();
    byte_1025686B = 2;
  }
  return result;
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10256868: using guessed type __int16 word_10256868;
// 1025686A: using guessed type char byte_1025686A;
// 1025686B: using guessed type char byte_1025686B;
// 1025686C: using guessed type __int16 word_1025686C;
// 10256874: using guessed type __int16 word_10256874;
// 10256878: using guessed type int dword_10256878[];
// 1025687C: using guessed type int dword_1025687C;

//----- (10029560) --------------------------------------------------------
void __cdecl sub_10029560(int a1, int a2)
{
  char v2; // bl@7
  int v3; // edi@10
  int v4; // eax@17
  int v5; // esi@20
  int v6; // eax@24
  int v7; // ecx@25
  char v8; // al@25
  void *v9; // ecx@32
  void *v10; // ecx@33
  void *v11; // ecx@37
  int v12; // eax@47
  int v13; // ecx@61
  int v14; // eax@72
  char v15; // al@77
  unsigned __int8 v16; // [sp-Ch] [bp-58h]@7
  char v17; // [sp+3h] [bp-49h]@2
  char v18; // [sp+3h] [bp-49h]@11
  bool v19; // [sp+3h] [bp-49h]@25
  int v20; // [sp+4h] [bp-48h]@0
  __int16 v21; // [sp+8h] [bp-44h]@78
  int v22; // [sp+Ch] [bp-40h]@10
  int v23; // [sp+10h] [bp-3Ch]@11
  unsigned int v24; // [sp+14h] [bp-38h]@2
  int v25; // [sp+18h] [bp-34h]@2
  int v26; // [sp+1Ch] [bp-30h]@2
  int v27; // [sp+20h] [bp-2Ch]@2
  int v28; // [sp+24h] [bp-28h]@2
  __int16 v29; // [sp+28h] [bp-24h]@25
  unsigned __int16 v30; // [sp+34h] [bp-18h]@28
  char v31; // [sp+38h] [bp-14h]@37

  if ( !byte_1025686A )
  {
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v17 = 0;
    if ( (signed int)(unsigned __int16)a1 > 2560 )
    {
      switch ( (unsigned __int16)a1 )
      {
        case 0xA02u:
        case 0xA04u:
          goto LABEL_6;
        case 0xA01u:
        case 0xA03u:
        case 0xA05u:
LABEL_8:
          v17 = sub_10023DA0(a1, a2, &v24);
LABEL_9:
          v2 = 1;
          LOBYTE(v20) = 0;
          v16 = 1;
          goto LABEL_10;
        default:
          return;
      }
    }
    else if ( (unsigned __int16)a1 == 2560 )
    {
LABEL_6:
      v17 = sub_10023DA0(a1, a2, &v24);
LABEL_7:
      v2 = 0;
      LOBYTE(v20) = 1;
      v16 = 0;
LABEL_10:
      LOBYTE(v22) = v2;
      sub_100399E0(v16);
      v3 = v22;
      if ( v17 )
      {
        v18 = sub_1003C380(v22);
        v23 = sub_1007C110(39, 200);
        if ( (signed int)(unsigned __int16)a1 > 2561 )
        {
          switch ( (unsigned __int16)a1 )
          {
            case 0xA02u:
            case 0xA03u:
              *(_BYTE *)((unsigned __int8)v2 + dword_10256870 + 176) = 0;
              if ( !sub_100543D0(&v24, 0, 0) )
              {
                *(_BYTE *)(dword_10256870 + 68 * (unsigned __int8)v2 + 66) = v24;
                *(_BYTE *)((unsigned __int8)v2 + dword_10256870 + 176) = 1;
              }
              break;
            case 0xA04u:
            case 0xA05u:
              *(_BYTE *)((unsigned __int8)v2 + dword_10256870 + 142) = 0;
              if ( !sub_1004D120((unsigned __int8 *)&v24) && !sub_1004D100((char *)&v24 + 1) )
              {
                v14 = 68 * (unsigned __int8)v2;
                *(_BYTE *)(v14 + dword_10256870 + 12) = v24;
                *(_BYTE *)(v14 + dword_10256870 + 13) = BYTE1(v24);
                *(_BYTE *)((unsigned __int8)v2 + dword_10256870 + 142) = 1;
              }
              break;
            default:
              break;
          }
        }
        else if ( (signed int)(unsigned __int16)a1 >= 2560 )
        {
          *(_BYTE *)((unsigned __int8)v2 + dword_10256870 + 174) = 0;
          if ( !sub_100543D0(&v24, 0, 0) )
          {
            *(_BYTE *)(dword_10256870 + 68 * (unsigned __int8)v2 + 65) = v24;
            *(_BYTE *)((unsigned __int8)v2 + dword_10256870 + 174) = 1;
          }
        }
        else
        {
          switch ( (unsigned __int16)a1 )
          {
            case 0x4AEu:
            case 0x4BAu:
              if ( (unsigned __int16)(v24 - 63) <= 5u )
              {
                *(_BYTE *)(dword_10256870 + 4 * (17 * (unsigned __int8)v2 + (unsigned __int16)v24) - 223) = BYTE2(v24);
                *(_BYTE *)(dword_10256870 + 4 * (17 * (unsigned __int8)v2 + (unsigned __int16)v24) - 224) = v25;
                *(_BYTE *)(dword_10256870 + (unsigned __int16)v24 + 6 * (unsigned __int8)v2 + 81) = 1;
              }
              break;
            case 0x4B3u:
            case 0x4BFu:
              if ( sub_1003CCA0(v22, &v24) )
              {
                v4 = 68 * (unsigned __int8)v2;
                *(_WORD *)(v4 + dword_10256870) = HIWORD(v27);
                sub_100421E0(v4 + dword_10256870 + 2, (_BYTE *)&v24 + 2, 9);
                *(_BYTE *)((unsigned __int8)v2 + dword_10256870 + 162) = 1;
              }
              break;
            case 0x4B4u:
            case 0x4C0u:
              if ( !v18 || BYTE1(v24) < 8u )
              {
                v5 = dword_10256870 + 68 * (unsigned __int8)v2 + 16;
                *(_DWORD *)v5 = v24;
                *(_DWORD *)(v5 + 4) = v25;
                *(_DWORD *)(v5 + 8) = v26;
                *(_BYTE *)((unsigned __int8)v2 + dword_10256870 + 156) = 1;
              }
              break;
            case 0x4B6u:
            case 0x4C2u:
              if ( (unsigned __int8)v24 < 2u && HIWORD(v25) <= 6u && (unsigned __int16)v26 <= 3u )
              {
                v6 = 17 * (unsigned __int8)v2;
                *(_BYTE *)(dword_10256870 + 4 * (v6 + (unsigned __int8)v24) + 54) = BYTE2(v25);
                *(_BYTE *)(dword_10256870 + 4 * (v6 + (unsigned __int8)v24) + 52) = BYTE2(v24);
                *(_BYTE *)(dword_10256870 + 4 * (v6 + (unsigned __int8)v24) + 53) = v25;
                *(_BYTE *)(dword_10256870 + 4 * (v6 + (unsigned __int8)v24) + 55) = v26;
                *(_BYTE *)(dword_10256870 + (unsigned __int8)v24 + 2 * (unsigned __int8)v2 + 158) = 1;
              }
              break;
            case 0x4B9u:
            case 0x4C5u:
              v19 = sub_1007C3B0(2105, (int)&v29, 16) == 0;
              v8 = sub_1003C120(v7);
              LOBYTE(v22) = v8;
              if ( !v19
                || v8 != v2
                || (_BYTE)v29 == BYTE1(v24) && v30 == v27 && HIBYTE(v29) == BYTE2(v24)
                || *((_BYTE *)&word_10256874 + (unsigned __int8)v2) )
              {
                if ( *((_BYTE *)&word_10256874 + (unsigned __int8)v2) && sub_1003CCA0(v3, &v31) && sub_10029410(v11) )
                {
                  *((_BYTE *)&word_10256874 + (unsigned __int8)v2) = 0;
                  if ( sub_1003C380(v3) )
                    sub_1003CF20(v22);
                  else
                    sub_1003CB60(v3);
                  if ( v19 && (_BYTE)v22 != v2 )
                    sub_1003CDD0(v3, (int)&v29);
                  if ( byte_1025686B != 2 )
                    byte_1025686B = 1;
                }
              }
              else
              {
                v29 = *(_WORD *)((char *)&v24 + 1);
                v30 = v27;
                sub_1007C500(2105, (int)&v29, 16);
                if ( (unsigned __int8)v20 < 2u
                  && (unsigned __int8)sub_1003C170(v20)
                  && sub_10029410(v9)
                  && sub_100460C0(v10) != 4 )
                {
                  sub_1003CDD0(v20, (int)&v29);
                }
              }
              break;
            case 0x4B1u:
            case 0x4BDu:
              v12 = (unsigned __int8)v2;
              *(_BYTE *)((unsigned __int8)v2 + dword_10256870 + 140) = 1;
              goto LABEL_49;
            case 0x582u:
            case 0x583u:
              v12 = (unsigned __int8)v2;
              *(_BYTE *)((unsigned __int8)v2 + dword_10256870 + 140) = 0;
LABEL_49:
              *(_WORD *)(dword_10256870 + 2 * v12 + 136) = v24;
              *(_BYTE *)(v12 + dword_10256870 + 164) = 1;
              break;
            case 0x56Cu:
            case 0x56Du:
              if ( sub_1004D0B0((unsigned __int8 *)&v24) )
                sub_1003CB00(v22);
              break;
            case 0x56Eu:
            case 0x570u:
              *(_BYTE *)((unsigned __int8)v2 + dword_10256870 + 166) = 0;
              if ( !sub_1004D090((unsigned __int8 *)&v24 + 1) && !sub_1004C4F0((unsigned __int8 *)&v24) )
              {
                *(_WORD *)(dword_10256870 + 68 * (unsigned __int8)v2 + 61) = v24;
                *(_BYTE *)((unsigned __int8)v2 + dword_10256870 + 166) = 1;
              }
              break;
            case 0x572u:
            case 0x574u:
              *(_BYTE *)((unsigned __int8)v2 + dword_10256870 + 168) = 0;
              if ( !sub_100689B0((unsigned __int8 *)&v24) )
              {
                *(_BYTE *)(dword_10256870 + 68 * (unsigned __int8)v2 + 63) = v24;
                *(_BYTE *)((unsigned __int8)v2 + dword_10256870 + 168) = 1;
              }
              break;
            case 0x576u:
            case 0x578u:
              *(_BYTE *)((unsigned __int8)v2 + dword_10256870 + 170) = 0;
              if ( !sub_1004C6C0((unsigned __int8 *)&v24) )
              {
                *(_BYTE *)(dword_10256870 + 68 * (unsigned __int8)v2 + 64) = v24;
                *(_BYTE *)((unsigned __int8)v2 + dword_10256870 + 170) = 1;
              }
              break;
            case 0x57Au:
            case 0x57Cu:
              *(_BYTE *)((unsigned __int8)v2 + dword_10256870 + 172) = 0;
              if ( !sub_1004C480((unsigned __int8 *)&v24) )
              {
                *(_BYTE *)(dword_10256870 + 68 * (unsigned __int8)v2 + 60) = v24;
                *(_BYTE *)((unsigned __int8)v2 + dword_10256870 + 172) = 1;
              }
              break;
            case 0x584u:
            case 0x585u:
              if ( sub_100543D0(&v24, 0, 0) )
              {
                sub_1003CB60(v22);
              }
              else
              {
                LOBYTE(v22) = sub_1003C120(v13);
                if ( (unsigned __int8)v24 == ((_BYTE)v22 == v2) )
                  sub_1003CF20(v22);
              }
              break;
            default:
              break;
          }
        }
        if ( !v23 )
          sub_1007C0F0(39);
        if ( byte_1025686B == 1 )
        {
          sub_100291D0();
          byte_1025686B = 2;
        }
      }
      v15 = sub_1002D2A0();
      if ( *((_BYTE *)&word_1025686C + (unsigned __int8)v2) != v15 )
      {
        *((_BYTE *)&word_1025686C + (unsigned __int8)v2) = v15;
        v21 = 24329;
        if ( !v15 )
          HIBYTE(v21) = 96;
        sub_1003CAA0(v3, &v21);
      }
      if ( *((_BYTE *)&word_10256868 + (unsigned __int8)v2) != 1 )
        sub_10029200(v3);
    }
    else
    {
      switch ( (unsigned __int16)a1 )
      {
        case 0x4AEu:
        case 0x4B1u:
        case 0x4B3u:
        case 0x4B4u:
        case 0x4B6u:
        case 0x4B9u:
        case 0x56Cu:
        case 0x56Eu:
        case 0x572u:
        case 0x576u:
        case 0x57Au:
        case 0x582u:
        case 0x584u:
          goto LABEL_6;
        case 0x4B8u:
          goto LABEL_7;
        case 0x4BAu:
        case 0x4BDu:
        case 0x4BFu:
        case 0x4C0u:
        case 0x4C2u:
        case 0x4C5u:
        case 0x56Du:
        case 0x570u:
        case 0x574u:
        case 0x578u:
        case 0x57Cu:
        case 0x583u:
        case 0x585u:
          goto LABEL_8;
        case 0x4C4u:
          goto LABEL_9;
        default:
          return;
      }
    }
  }
}
// 10256868: using guessed type __int16 word_10256868;
// 1025686A: using guessed type char byte_1025686A;
// 1025686B: using guessed type char byte_1025686B;
// 1025686C: using guessed type __int16 word_1025686C;
// 10256870: using guessed type int dword_10256870;
// 10256874: using guessed type __int16 word_10256874;

//----- (10029FB0) --------------------------------------------------------
int __cdecl sub_10029FB0(char a1, void *a2, size_t a3, int a4)
{
  int v4; // eax@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v4 = 21;
    }
    else
    {
      if ( a1 != 2 )
        goto LABEL_9;
      v4 = 23;
    }
  }
  else
  {
    v4 = 10;
  }
  if ( !sub_1007C6B0(v4, a4, a3, (int)a2) )
    return 0;
LABEL_9:
  memset(a2, 0, a3);
  return 1;
}

//----- (1002A020) --------------------------------------------------------
char **sub_1002A020()
{
  return off_100E3D80;
}
// 100E3D80: using guessed type char *off_100E3D80[3];

//----- (1002A030) --------------------------------------------------------
char **sub_1002A030()
{
  return &off_100E3ED8;
}
// 100E3ED8: using guessed type char *off_100E3ED8;

//----- (1002A040) --------------------------------------------------------
char sub_1002A040()
{
  unsigned __int8 v0; // ST54_1@1
  void *v1; // ecx@1
  const char *v3; // [sp-3Ch] [bp-44h]@2
  const char *v4; // [sp-38h] [bp-40h]@2
  unsigned __int8 v5; // [sp-34h] [bp-3Ch]@2
  unsigned __int8 v6; // [sp-30h] [bp-38h]@2
  char v7; // [sp+4h] [bp-4h]@1

  sub_10042920(1);
  sub_10059BE0(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_com.c",
    (int)"336",
    (int)"Try to set demo data with an invalid COM channel");
  sub_10022340(538, (int)&byte_10332F00);
  sub_100499E0(3u, 1, 118000);
  v0 = sub_10049990(0, &v7);
  sub_10054EC0(1, 0, (int)".\\test\\tst_iop_com.c", (int)"340", (int)"The data simulated is invalid", v0, 0, 0);
  if ( !j_HWM_pvg_read_reg(1) )
  {
    sub_10059BE0(
      3,
      (int)"**MSG**",
      (int)".\\test\\tst_iop_com.c",
      (int)"344",
      (int)"Try to set demo data with the demo pin not set");
    sub_100499E0(0, 1, 118000);
    v6 = 0;
    v5 = sub_10049990(0, &v7);
    v4 = "The data simulated is invalid";
    v3 = "347";
LABEL_5:
    sub_10054EC0(1, 0, (int)".\\test\\tst_iop_com.c", (int)v3, (int)v4, v5, v6, 0);
    return sub_10042920(-1);
  }
  if ( sub_100460C0(v1) != 2 )
  {
    sub_10059BE0(
      3,
      (int)"**MSG**",
      (int)".\\test\\tst_iop_com.c",
      (int)&unk_100E4014,
      (int)"Try to set demo data when not in configuration mode");
    sub_100499E0(0, 1, 118000);
    v6 = 0;
    v5 = sub_10049990(0, &v7);
    v4 = "The data simulated is invalid";
    v3 = (const char *)&unk_100E4010;
    goto LABEL_5;
  }
  return sub_10042920(-1);
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10332F00: using guessed type char byte_10332F00;

//----- (1002A190) --------------------------------------------------------
char sub_1002A190()
{
  sub_10042920(1);
  sub_1001D0D0(0, 0);
  sub_10042920(-1);
  sub_10042920(1);
  sub_1001CC00(0);
  return sub_10042920(-1);
}

//----- (1002A1D0) --------------------------------------------------------
bool __thiscall sub_1002A1D0(void *this)
{
  unsigned __int8 v1; // al@1
  unsigned __int8 v2; // al@1
  unsigned __int8 v3; // al@1
  unsigned __int8 v4; // al@3
  int v6; // [sp+0h] [bp-4h]@1

  v6 = (int)this;
  sub_10059BE0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gma_dig.c", (int)"157", (int)"R00450004");
  LOWORD(v6) = 0;
  BYTE2(v6) = 0;
  sub_10018760(2, 36, 0, 19, (int)&v6, &v6, 3u);
  sub_100186E0();
  v1 = sub_1001D5F0(36);
  sub_10054EC0(
    1,
    0,
    (int)".\\test\\tst_iop_gma_dig.c",
    (int)"184",
    (int)"Verify that the GMA digital configuration request returns valid.",
    v1,
    1u,
    0);
  v2 = sub_1001D640(36, 0, 19, (int)&v6, (char *)&v6);
  sub_10054EC0(
    1,
    0,
    (int)".\\test\\tst_iop_gma_dig.c",
    (int)"194",
    (int)"Verify that a GMA digital configuration send with an invalid configuration type returns FALSE.",
    v2,
    0,
    0);
  v3 = sub_1001D9D0(36, 19, (int)&v6);
  sub_10054EC0(
    1,
    0,
    (int)".\\test\\tst_iop_gma_dig.c",
    (int)"204",
    (int)"Verify that a call to verify GMA digital configuration with an invalid configuration type and invalid active co"
         "nfiguration returns FALSE.",
    v3,
    0,
    0);
  do
    sub_10018720();
  while ( (unsigned int)sub_10018700() < 0x18 );
  v4 = sub_1001D9D0(36, 19, (int)&v6);
  return sub_10054EC0(
           1,
           0,
           (int)".\\test\\tst_iop_gma_dig.c",
           (int)&unk_100E4628,
           (int)"Verify that a subsequent call to verify GMA digital configuration with an invalid configuration type and"
                " invalid active configuration also returns FALSE.",
           v4,
           0,
           0);
}

//----- (1002A300) --------------------------------------------------------
char sub_1002A300()
{
  int v1; // [sp+0h] [bp-8h]@1
  int v2; // [sp+4h] [bp-4h]@1

  sub_10059BE0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gma_dig.c", (int)"246", (int)"R00425102");
  sub_10059BE0(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gma_dig.c", (int)"247", (int)"R00425229");
  sub_1001D3B0(0, &v1);
  sub_100421E0((int)&unk_10320340, "Verify getting the system mode from the digital GMA.", 200);
  sub_10058640(0, 0, (int)".\\test\\tst_iop_gma_dig.c", (int)"261", (int)&unk_10320340, v1, 1u, 0, 0);
  sub_10042920(1);
  LOBYTE(v2) = sub_1001D3B0(4, &v1);
  sub_10042920(-1);
  sub_10058640(0, 0, (int)".\\test\\tst_iop_gma_dig.c", (int)"272", (int)&unk_10320340, v2, 0, 0, 0);
  sub_1001DE50(0, 8);
  sub_10042920(1);
  sub_1001DE50(0, 64);
  sub_10042920(-1);
  sub_10042920(1);
  sub_1001DE50(4u, 8);
  sub_10042920(-1);
  return sub_1001D470(4);
}

//----- (1002A410) --------------------------------------------------------
bool sub_1002A410()
{
  unsigned __int8 v0; // ST3C_1@1

  v0 = sub_1001E220(0x10000, 0, 0x10000, 5);
  sub_100421E0((int)&unk_10320340, "Verify uploading configuration region to digital GMA.", 200);
  return sub_10054EC0(0, 0, (int)".\\test\\tst_iop_gma_dig.c", (int)"357", (int)&unk_10320340, v0, 0, 0);
}

//----- (1002A460) --------------------------------------------------------
int (**sub_1002A460())()
{
  return off_100E48E8;
}
// 100E48E8: using guessed type int (*off_100E48E8[3])();

//----- (1002A470) --------------------------------------------------------
char __cdecl sub_1002A470(int a1)
{
  char result; // al@1
  int v2; // ecx@2
  char v3; // al@4
  unsigned __int8 v4; // al@16

  *(_DWORD *)(a1 + 16) = 0x3FFFF;
  *(_BYTE *)a1 = -1;
  *(_DWORD *)(a1 + 20) = 0x3FFFF;
  *(_BYTE *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_BYTE *)(a1 + 2) = 1;
  *(_BYTE *)(a1 + 3) = 1;
  *(_BYTE *)(a1 + 4) = 6;
  *(_BYTE *)(a1 + 5) = -1;
  *(_BYTE *)(a1 + 6) = 0;
  *(_BYTE *)(a1 + 7) = -1;
  *(_BYTE *)(a1 + 9) = 0;
  *(_BYTE *)(a1 + 13) = 0;
  *(_BYTE *)(a1 + 10) = -1;
  *(_BYTE *)(a1 + 11) = 0;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 12) = 0;
  *(_BYTE *)(a1 + 14) = 1;
  *(_BYTE *)(a1 + 15) = 0;
  result = sub_10041770();
  if ( result )
  {
    sub_10061E50();
    *(_BYTE *)(a1 + 8) = *(_BYTE *)(dword_1033707C + 815);
    *(_BYTE *)(a1 + 4) = *(_BYTE *)(dword_1033707C + 94);
    *(_BYTE *)(a1 + 11) = *(_BYTE *)(dword_1033707C + 97);
    *(_BYTE *)(a1 + 1) = *(_BYTE *)(dword_10337070 + 239);
    *(_BYTE *)(a1 + 15) = *(_BYTE *)(dword_1033707C + 826);
    strncpy((char *)(a1 + 24), (const char *)(dword_1033707C + 872), 0xCu);
    *(_BYTE *)(a1 + 35) = 0;
    *(_BYTE *)(a1 + 6) = *(_BYTE *)(dword_1033707C + 784);
    *(_BYTE *)(a1 + 14) = 0;
    v2 = dword_1033707C;
    if ( *(_BYTE *)(dword_1033707C + 669) && !*(_BYTE *)(dword_1033707C + 667)
      || (v3 = *(_BYTE *)(dword_1033707C + 159)) != 0
      && *(_BYTE *)(dword_1033707C + 667)
      && !*(_BYTE *)(dword_1033707C + 661)
      && (v3 != 2 || -1.0 == *(float *)(dword_1033707C + 116))
      || !*(_BYTE *)(dword_1033707C + 672) )
    {
      *(_BYTE *)(a1 + 14) = 1;
      v2 = dword_1033707C;
    }
    else if ( *(_BYTE *)(dword_1033707C + 101) == 4
           && *(_BYTE *)(dword_1033707C + 812) >= *(_BYTE *)(dword_10337070 + 241)
           && !*(_BYTE *)(dword_1033707C + 89)
           && -1.0 == *(float *)(dword_1033707C + 116) )
    {
      *(_BYTE *)(a1 + 14) = 1;
      v2 = dword_1033707C;
    }
    *(_BYTE *)(a1 + 9) = *(_BYTE *)(v2 + 816);
    *(_BYTE *)(a1 + 5) = *(_BYTE *)(dword_10337070 + 241);
    v4 = *(_BYTE *)(a1 + 9) - 1;
    *(_BYTE *)(a1 + 10) = *(_BYTE *)(dword_10337070 + 244);
    if ( v4 > 2u )
    {
      *(_BYTE *)(a1 + 9) = 0;
      *(_DWORD *)(a1 + 16) = 0x3FFFF;
      *(_DWORD *)(a1 + 20) = 0x3FFFF;
      *(_BYTE *)(a1 + 12) = 0;
      *(_BYTE *)a1 = -1;
      *(_BYTE *)(a1 + 2) = 1;
      *(_BYTE *)(a1 + 3) = 1;
      *(_BYTE *)(a1 + 7) = -1;
      *(_BYTE *)(a1 + 14) = 1;
      result = sub_10061E40();
    }
    else
    {
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(dword_1033707C + 836);
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(dword_1033707C + 840);
      *(_BYTE *)a1 = *(_BYTE *)(dword_1033707C + 812);
      *(_BYTE *)(a1 + 13) = *(_BYTE *)(dword_1033707C + 825);
      if ( *(_DWORD *)(dword_1033707C + 892) )
        *(_BYTE *)(a1 + 3) = 0;
      else
        *(_BYTE *)(a1 + 3) = *(_BYTE *)(dword_1033707C + 288);
      *(_BYTE *)(a1 + 2) = *(_BYTE *)(dword_1033707C + 288);
      *(_BYTE *)(a1 + 7) = *(_BYTE *)(dword_1033707C + 813);
      *(_BYTE *)(a1 + 12) = *(_BYTE *)(dword_10337070 + 4);
      result = sub_10061E40();
    }
  }
  return result;
}
// 10337070: using guessed type int dword_10337070;
// 1033707C: using guessed type int dword_1033707C;

//----- (1002A6C0) --------------------------------------------------------
int __cdecl sub_1002A6C0(float a1, float a2, float a3)
{
  float *v3; // ecx@0
  int result; // eax@4

  if ( (COERCE_UNSIGNED_INT(*v3) & 0x7F800000) == 2139095040 || a1 < (double)*v3 || a2 > (double)*v3 )
  {
    result = 0;
    *v3 = a3;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1002A710) --------------------------------------------------------
double __cdecl sub_1002A710(char a1)
{
  double v1; // st7@5
  double result; // st7@9
  float v3; // [sp+0h] [bp-4h]@1

  v3 = 0.0;
  if ( !sub_10041770() )
    goto LABEL_13;
  if ( !a1 )
  {
    v1 = *(float *)(dword_1033707C + 124);
    goto LABEL_8;
  }
  if ( a1 == 2 )
  {
    v1 = *(float *)(dword_1033707C + 860);
    goto LABEL_8;
  }
  if ( a1 == 3 )
  {
    v1 = *(float *)(dword_1033707C + 1204);
LABEL_8:
    v3 = v1;
  }
  result = v3;
  if ( (LODWORD(v3) & 0x7F800000) == 2139095040 || result > 3.141592502593994 || result < -3.141592502593994 )
  {
    v3 = 0.0;
LABEL_13:
    result = v3;
  }
  return result;
}
// 1033707C: using guessed type int dword_1033707C;

//----- (1002A7A0) --------------------------------------------------------
signed int __cdecl sub_1002A7A0(char a1)
{
  return (signed int)(sub_1002A710(a1) * 683565248.0);
}

//----- (1002A7C0) --------------------------------------------------------
char __cdecl sub_1002A7C0(float *a1)
{
  float v1; // ST18_4@6
  char result; // al@6
  float v3; // ST18_4@6
  char v4; // [sp+1Bh] [bp-2Dh]@6
  float v5; // [sp+1Ch] [bp-2Ch]@6
  char v6; // [sp+20h] [bp-28h]@2
  char v7; // [sp+2Eh] [bp-1Ah]@2

  *a1 = 0.0;
  if ( !sub_10041770()
    || (sub_1002A470((int)&v6), v7)
    || *(_BYTE *)(dword_1033707C + 661)
    && (!*(_BYTE *)(dword_1033707C + 64)
     || (unsigned int)(*(_DWORD *)(dword_1033707C + 36) - *(_DWORD *)(dword_1033707C + 740)) >= 0x124F80) )
  {
    result = 0;
  }
  else
  {
    sub_10061E50();
    sub_1002B600(*(_BYTE *)(dword_1033707C + 1201), &v4, &v5);
    *a1 = *(float *)(dword_1033707C + 340);
    v1 = *(float *)(dword_1033707C + 336);
    sub_10045800(12756274.0, -12756274.0);
    sub_1002A6C0(514.44446, -514.44446, 0.0);
    sub_10061E30(*(_DWORD *)(dword_1033707C + 296));
    *a1 = 514.44446 * v1 + *a1;
    sub_10061E40();
    sub_10045800(10.0, 0.043196544);
    result = 1;
    v3 = *a1 * 0.0005399567889980972;
    *a1 = v3 / v5;
  }
  return result;
}
// 10061E30: using guessed type _DWORD __cdecl sub_10061E30(_DWORD);
// 1033707C: using guessed type int dword_1033707C;

//----- (1002A930) --------------------------------------------------------
char sub_1002A930()
{
  char result; // al@2

  if ( sub_10041770() )
    result = *(_BYTE *)(dword_1033707C + 661);
  else
    result = 0;
  return result;
}
// 1033707C: using guessed type int dword_1033707C;

//----- (1002A950) --------------------------------------------------------
bool __cdecl sub_1002A950(_BYTE *a1, _BYTE *a2, float *a3)
{
  unsigned int v3; // eax@2
  bool result; // al@4

  if ( sub_10041770() )
  {
    sub_10061E50();
    v3 = *(_BYTE *)(dword_1033707C + 1201);
    if ( v3 >= 6 )
      LOBYTE(v3) = 1;
    *a1 = v3;
    sub_1002B600(*(_BYTE *)(dword_1033707C + 1201), a2, a3);
    result = sub_10061E40();
  }
  else
  {
    result = (char)a1;
    *a1 = 6;
    *a2 = 6;
    *a3 = 0.0;
  }
  return result;
}
// 1033707C: using guessed type int dword_1033707C;

//----- (1002A9C0) --------------------------------------------------------
char __cdecl sub_1002A9C0(int a1)
{
  int v1; // eax@2
  char result; // al@2

  if ( sub_10041770() )
  {
    sub_10061E50();
    v1 = dword_1033707C + 1504;
    *(_DWORD *)a1 = *(_DWORD *)(dword_1033707C + 1504);
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(v1 + 4);
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(v1 + 8);
    sub_10061E40();
    result = *(_BYTE *)a1;
  }
  else
  {
    *(float *)(a1 + 4) = 0.0;
    *(_BYTE *)a1 = 0;
    *(float *)(a1 + 8) = 0.0;
    result = *(_BYTE *)a1;
  }
  return result;
}
// 1033707C: using guessed type int dword_1033707C;

//----- (1002AA10) --------------------------------------------------------
char __cdecl sub_1002AA10(char a1)
{
  char v1; // bl@1
  unsigned __int8 v2; // al@2
  char v3; // al@3

  v1 = 0;
  if ( sub_10041770() )
  {
    sub_10061E50();
    v2 = *(_BYTE *)(dword_1033707C + 812);
    if ( v2 != -1 )
    {
      v3 = *(_BYTE *)(180 * v2 + dword_10337070 + 671);
      if ( (v3 == 18 || v3 == 19 || v3 == 20 || v3 == 21 || v3 == 22) && (!a1 || v3 == 21) )
        v1 = 1;
    }
    sub_10061E40();
  }
  return v1;
}
// 10337070: using guessed type int dword_10337070;
// 1033707C: using guessed type int dword_1033707C;

//----- (1002AA80) --------------------------------------------------------
char __cdecl sub_1002AA80(char a1, char a2, float *a3)
{
  char v3; // bl@1
  double v4; // st7@3
  int v5; // edi@3
  int *v6; // eax@3
  char v8; // [sp+Fh] [bp-31h]@1
  float v9; // [sp+10h] [bp-30h]@3
  float v10; // [sp+10h] [bp-30h]@11
  char v11; // [sp+18h] [bp-28h]@2
  char v12; // [sp+26h] [bp-1Ah]@2

  *a3 = 0.0;
  v3 = 0;
  v8 = sub_1002AA10(0);
  if ( !sub_10041770() )
    return v3;
  sub_1002A470((int)&v11);
  if ( v12 )
    return v3;
  sub_10061E50();
  v4 = 0.0;
  v9 = 0.0;
  v5 = *(_DWORD *)(dword_1033707C + 296);
  v6 = (int *)(dword_1033707C + 296);
  if ( a1 )
  {
    if ( a1 != 1 )
    {
      if ( a1 == 2 )
      {
        v4 = *(float *)(dword_1033707C + 560) - *(float *)(dword_1033707C + 720);
        *a3 = v4;
        v3 = *(_BYTE *)(dword_1033707C + 673);
      }
      goto LABEL_11;
    }
    *a3 = *(float *)(dword_1033707C + 312);
    v4 = *(float *)(dword_1033707C + 328);
    goto LABEL_10;
  }
  if ( !v8 )
  {
    *a3 = *(float *)(dword_1033707C + 308);
    v4 = *(float *)(dword_1033707C + 324);
LABEL_10:
    v5 = *v6;
    v9 = v4;
    v3 = 1;
  }
LABEL_11:
  sub_10061E40();
  sub_10061E30(v5);
  v10 = v4 * v9 + *a3;
  *a3 = v10;
  if ( a1 != 2 )
    *a3 = v10 - sub_1002A710(a2);
  *a3 = sub_1007BCB0(*a3);
  return v3;
}
// 10061E30: using guessed type _DWORD __cdecl sub_10061E30(_DWORD);
// 1033707C: using guessed type int dword_1033707C;

//----- (1002ABC0) --------------------------------------------------------
char __cdecl sub_1002ABC0(char a1, float *a2)
{
  double v2; // st7@1
  char v3; // bl@1
  char result; // al@13
  float v5; // [sp+8h] [bp-2Ch]@1
  char v6; // [sp+Ch] [bp-28h]@2
  char v7; // [sp+1Ah] [bp-1Ah]@2

  v2 = 0.0;
  *a2 = 0.0;
  v3 = 0;
  v5 = 0.0;
  if ( !sub_10041770() )
    return v3;
  sub_1002A470((int)&v6);
  if ( v7 || sub_1002AA10(1) )
    return v3;
  sub_10061E50();
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      *a2 = *(float *)(dword_1033707C + 316);
      v2 = *(float *)(dword_1033707C + 332);
    }
    else
    {
      if ( a1 != 2 )
        goto LABEL_11;
      *a2 = *(float *)(dword_1033707C + 340);
      v2 = *(float *)(dword_1033707C + 336);
    }
  }
  else
  {
    *a2 = *(float *)(dword_1033707C + 304);
    v2 = *(float *)(dword_1033707C + 320);
  }
  v5 = v2;
  v3 = 1;
LABEL_11:
  sub_10061E30(*(_DWORD *)(dword_1033707C + 296));
  *a2 = v2 * v5 + *a2;
  sub_10061E40();
  if ( a1 == 1 )
  {
    *(_DWORD *)a2 = COERCE_UNSIGNED_INT(*a2) & 0x7FFFFFFF;
    return v3;
  }
  if ( a1 || !*(_BYTE *)(dword_1033707C + 288) )
    return v3;
  result = v3;
  if ( (*(_DWORD *)a2 >> 31) & 1 )
    *a2 = 0.0;
  return result;
}
// 10061E30: using guessed type _DWORD __cdecl sub_10061E30(_DWORD);
// 1033707C: using guessed type int dword_1033707C;

//----- (1002AD10) --------------------------------------------------------
char sub_1002AD10()
{
  unsigned __int8 v0; // cl@2
  signed int v1; // eax@4

  if ( !sub_10041770() )
  {
    LOBYTE(v1) = 0;
    return v1;
  }
  v0 = *(_BYTE *)(dword_1033707C + 1200);
  if ( v0 || (v0 = *(_BYTE *)(dword_1033707C + 814)) != 0 )
  {
    LOBYTE(v1) = v0;
    if ( v0 < 4u )
      return v1;
    v1 = 4;
  }
  else
  {
    v1 = *(_BYTE *)(dword_1033707C + 122) == 0;
  }
  if ( v1 == 4 )
    LOBYTE(v1) = 0;
  return v1;
}
// 1033707C: using guessed type int dword_1033707C;

//----- (1002AD60) --------------------------------------------------------
double __cdecl sub_1002AD60(_BYTE *a1)
{
  _BYTE *v1; // esi@1
  bool v2; // al@1
  int v3; // edx@1
  double v4; // st7@5
  double v5; // st7@8
  float v6; // ST00_4@11
  double result; // st7@13
  double v8; // st7@14
  float v9; // [sp+4h] [bp-10h]@5
  float v10; // [sp+Ch] [bp-8h]@1
  float v11; // [sp+10h] [bp-4h]@5
  float v12; // [sp+18h] [bp+4h]@2
  float v13; // [sp+18h] [bp+4h]@4
  float v14; // [sp+18h] [bp+4h]@10
  float v15; // [sp+18h] [bp+4h]@14

  v1 = a1;
  *a1 = 0;
  v2 = sub_1002B8D0(*(_BYTE *)(dword_10337070 + 244), &v10);
  v3 = dword_1033707C;
  if ( !v2 )
  {
    v12 = 0.30000001;
    goto LABEL_13;
  }
  if ( *(_BYTE *)(dword_1033707C + 929) )
  {
    v13 = *(float *)(dword_1033707C + 948) + v10;
    if ( *(float *)(dword_1033707C + 964) + 305.0 >= v13 )
    {
      v12 = 0.30000001;
      goto LABEL_13;
    }
    v12 = v13 * 0.0005399567889980972 * *(float *)(dword_1033707C + 976);
    v11 = 0.0005399567889980972 * *(float *)(dword_1033707C + 944);
    v9 = v11;
    v4 = 1.0;
  }
  else
  {
    if ( *(_BYTE *)(dword_10337070 + 237) )
      v5 = 1.0;
    else
      v5 = 0.30000001;
    v11 = v5;
    v14 = v10 + 3048.0;
    v12 = v14 * 0.0005399567889980972 * 0.03492077067494392;
    v9 = 0.057602592;
    v4 = v11;
  }
  v6 = v4;
  if ( sub_10045800(v6, v9) )
  {
    *v1 = 1;
    v3 = dword_1033707C;
  }
LABEL_13:
  result = v12;
  if ( *(float *)(v3 + 84) < (double)v12 )
  {
    v8 = *(float *)(v3 + 84);
    *v1 = 0;
    v15 = v8;
    result = v15;
  }
  return result;
}
// 10337070: using guessed type int dword_10337070;
// 1033707C: using guessed type int dword_1033707C;

//----- (1002AEA0) --------------------------------------------------------
char __cdecl sub_1002AEA0(float *a1)
{
  int v1; // ST10_4@1
  double v2; // st7@1
  int v3; // ST14_4@1
  int v4; // ST1C_4@1
  int v5; // ST24_4@1
  double v6; // st7@6
  double v7; // st7@10
  double v8; // st7@15
  float v9; // ST04_4@26
  char v10; // dl@28
  char result; // al@31
  float v12; // [sp+0h] [bp-24h]@1
  float v13; // [sp+4h] [bp-20h]@1
  float v14; // [sp+14h] [bp-10h]@1
  float v15; // [sp+1Ch] [bp-8h]@1

  v12 = *(float *)(dword_1033707C + 304);
  v1 = *(_DWORD *)(dword_1033707C + 64);
  v13 = *(float *)(dword_1033707C + 320);
  v2 = v12;
  v14 = *(float *)(dword_1033707C + 72);
  v3 = *(_DWORD *)(dword_1033707C + 68);
  v15 = *(float *)(dword_1033707C + 80);
  v4 = *(_DWORD *)(dword_1033707C + 76);
  v5 = *(_DWORD *)(dword_1033707C + 84);
  if ( (LODWORD(v12) & 0x7F800000) == 2139095040 || v2 > 25512548.0 )
  {
    v12 = 25512548.0;
  }
  else if ( v2 < -25512548.0 )
  {
    v12 = -25512548.0;
  }
  v6 = v13;
  if ( (LODWORD(v13) & 0x7F800000) == 2139095040 || v6 > 1028.8889 || v6 < -1028.8889 )
    v13 = 0.0;
  v7 = v15;
  if ( (LODWORD(v15) & 0x7F800000) == 2139095040 || v7 > 2.0 )
  {
    v15 = 2.0;
  }
  else if ( v7 < -2.0 )
  {
    v15 = -2.0;
  }
  v8 = 1.0;
  if ( *(_BYTE *)(dword_1033707C + 929) )
  {
    if ( (LODWORD(v14) & 0x7F800000) == 2139095040 || v14 > 1.0 )
      goto LABEL_25;
    v8 = v14;
  }
  else
  {
    v8 = v14;
    if ( (LODWORD(v14) & 0x7F800000) == 2139095040 || v8 > 0.30000001 )
    {
      v8 = 0.30000001;
      goto LABEL_25;
    }
  }
  if ( v8 >= 0.05760259181261063 )
    goto LABEL_26;
  v8 = 0.057602592;
LABEL_25:
  v14 = v8;
LABEL_26:
  sub_10061E30(*(_DWORD *)(dword_1033707C + 296));
  v9 = v8 * v13 + v12;
  *a1 = v14 - v15 * v9;
  if ( v9 > 3704.0 )
    *a1 = 1.0;
  v10 = 0;
  if ( v14 + 0.009999999776482582 >= *a1 || *(_BYTE *)(dword_1033707C + 812) > *(_BYTE *)(dword_10337070 + 241) )
  {
    *a1 = v14;
    v10 = 1;
  }
  result = 1;
  if ( !*(_BYTE *)(dword_10337070 + 237) )
    result = v10;
  return result;
}
// 10061E30: using guessed type _DWORD __cdecl sub_10061E30(_DWORD);
// 10337070: using guessed type int dword_10337070;
// 1033707C: using guessed type int dword_1033707C;

//----- (1002B0D0) --------------------------------------------------------
char __cdecl sub_1002B0D0(float *a1)
{
  float v1; // ST00_4@1
  double v2; // st7@1
  int v3; // ST04_4@1
  int v4; // ST0C_4@1
  int v5; // ST08_4@1
  int v6; // ST18_4@1
  double v7; // st5@7
  double v8; // st6@7
  double v9; // st4@11
  float v10; // ST14_4@15
  float v11; // ST00_4@16
  float v12; // ST00_4@16
  char result; // al@17
  float v14; // [sp+10h] [bp-Ch]@1
  float v15; // [sp+10h] [bp-Ch]@8
  float v16; // [sp+14h] [bp-8h]@1

  v1 = *(float *)(dword_1033707C + 688);
  v2 = v1;
  v3 = *(_DWORD *)(dword_1033707C + 64);
  v4 = *(_DWORD *)(dword_1033707C + 72);
  v5 = *(_DWORD *)(dword_1033707C + 68);
  v16 = *(float *)(dword_1033707C + 80);
  v14 = *(float *)(dword_1033707C + 76);
  v6 = *(_DWORD *)(dword_1033707C + 84);
  if ( (LODWORD(v1) & 0x7F800000) == 2139095040 || v2 > 1028.8889 || v2 < 0.0 )
    v2 = (float)0.0;
  if ( (LODWORD(v14) & 0x7F800000) == 2139095040 || v14 > 2.0 )
  {
    v8 = 2.0;
    v15 = 2.0;
    goto LABEL_10;
  }
  v7 = v14;
  v8 = 2.0;
  if ( v14 < 0.05760259181261063 )
  {
    v15 = 0.057602592;
LABEL_10:
    v7 = v15;
  }
  v9 = v16;
  if ( (LODWORD(v16) & 0x7F800000) == 2139095040 || v9 > v8 )
  {
    v10 = v8;
    v9 = v10;
  }
  else if ( v9 < -2.0 )
  {
    v9 = (float)-2.0;
  }
  v11 = v2
      * v9
      * ((double)(unsigned int)(*(_DWORD *)(dword_1033707C + 36) - *(_DWORD *)(dword_1033707C + 68))
       / (double)1000);
  v12 = v7 + v11;
  *a1 = v12;
  if ( v12 < 1.990000009536743 )
  {
    result = 0;
  }
  else
  {
    *a1 = v8;
    result = 1;
  }
  return result;
}
// 1033707C: using guessed type int dword_1033707C;

//----- (1002B240) --------------------------------------------------------
double __cdecl sub_1002B240(float a1)
{
  double v1; // st7@1
  double result; // st7@4
  float v3; // [sp+4h] [bp-4h]@1

  v1 = a1;
  v3 = *(float *)(dword_1033707C + 48);
  if ( (LODWORD(a1) & 0x7F800000) == 2139095040 || v1 > 10.0 )
  {
    result = (float)10.0;
  }
  else if ( v3 <= v1 )
  {
    result = a1;
  }
  else
  {
    result = v3;
  }
  return result;
}
// 1033707C: using guessed type int dword_1033707C;

//----- (1002B2B0) --------------------------------------------------------
char __cdecl sub_1002B2B0(float *a1)
{
  float v1; // ST08_4@1
  double v2; // st7@1
  int v3; // ST10_4@1
  int v4; // ST18_4@1
  int v5; // ST14_4@1
  int v6; // ST24_4@1
  double v7; // st6@5
  double v8; // st5@5
  float v9; // ST1C_4@8
  double v10; // st5@9
  double v11; // st4@9
  float v12; // ST20_4@12
  float v13; // ST0C_4@13
  double v14; // st7@13
  char result; // al@17
  float v16; // [sp+0h] [bp-20h]@13
  float v17; // [sp+4h] [bp-1Ch]@5
  float v18; // [sp+14h] [bp-Ch]@1
  float v19; // [sp+18h] [bp-8h]@1

  v1 = *(float *)(dword_1033707C + 688);
  v2 = v1;
  v3 = *(_DWORD *)(dword_1033707C + 64);
  v4 = *(_DWORD *)(dword_1033707C + 72);
  v5 = *(_DWORD *)(dword_1033707C + 68);
  v19 = *(float *)(dword_1033707C + 80);
  v18 = *(float *)(dword_1033707C + 76);
  v6 = *(_DWORD *)(dword_1033707C + 84);
  if ( (LODWORD(v1) & 0x7F800000) == 2139095040 || v2 > 1028.8889 || v2 < 0.0 )
    v2 = (float)0.0;
  v17 = *(float *)(dword_1033707C + 48);
  v7 = v18;
  v8 = 10.0;
  if ( (LODWORD(v18) & 0x7F800000) == 2139095040 || v7 > 10.0 || (v8 = v17, v17 > v7) )
  {
    v9 = v8;
    v7 = v9;
  }
  v10 = v19;
  v11 = 2.0;
  if ( (LODWORD(v19) & 0x7F800000) == 2139095040 || v10 > 2.0 || (v11 = -2.0, v10 < -2.0) )
  {
    v12 = v11;
    v10 = v12;
  }
  v16 = v2
      * v10
      * ((double)(unsigned int)(*(_DWORD *)(dword_1033707C + 36) - *(_DWORD *)(dword_1033707C + 68))
       / (double)1000);
  v13 = v7 + v16;
  v14 = v13;
  *a1 = v13;
  if ( (LODWORD(v16) >> 31) & 1 && *(float *)(dword_1033707C + 72) >= v14 )
  {
    result = 1;
    *a1 = *(float *)(dword_1033707C + 72);
  }
  else if ( (LODWORD(v16) >> 31) & 1 || *(float *)(dword_1033707C + 72) > v14 )
  {
    result = 0;
  }
  else
  {
    *a1 = *(float *)(dword_1033707C + 72);
    result = 1;
  }
  return result;
}
// 1033707C: using guessed type int dword_1033707C;

//----- (1002B450) --------------------------------------------------------
char __cdecl sub_1002B450(float *a1)
{
  float v1; // ST04_4@1
  double v2; // st7@1
  int v3; // ST0C_4@1
  int v4; // ST14_4@1
  int v5; // ST10_4@1
  int v6; // ST20_4@1
  double v7; // st5@7
  double v8; // st6@7
  double v9; // st6@13
  float v10; // ST1C_4@15
  float v11; // ST08_4@16
  double v12; // st7@16
  char result; // al@20
  float v14; // [sp+0h] [bp-20h]@16
  float v15; // [sp+14h] [bp-Ch]@1
  float v16; // [sp+14h] [bp-Ch]@8
  float v17; // [sp+18h] [bp-8h]@1

  v1 = *(float *)(dword_1033707C + 688);
  v2 = v1;
  v3 = *(_DWORD *)(dword_1033707C + 64);
  v4 = *(_DWORD *)(dword_1033707C + 72);
  v5 = *(_DWORD *)(dword_1033707C + 68);
  v17 = *(float *)(dword_1033707C + 80);
  v15 = *(float *)(dword_1033707C + 76);
  v6 = *(_DWORD *)(dword_1033707C + 84);
  if ( (LODWORD(v1) & 0x7F800000) == 2139095040 || v2 > 1028.8889 || v2 < 0.0 )
    v2 = (float)0.0;
  if ( (LODWORD(v15) & 0x7F800000) == 2139095040 || v15 > 2.0 )
  {
    v8 = 2.0;
    v16 = 2.0;
    goto LABEL_10;
  }
  v7 = v15;
  v8 = 2.0;
  if ( v15 < 0.05760259181261063 )
  {
    v16 = 0.057602592;
LABEL_10:
    v7 = v16;
  }
  if ( (LODWORD(v17) & 0x7F800000) != 2139095040 && v17 <= v8 )
  {
    v9 = v17;
    if ( v17 >= -2.0 )
      goto LABEL_16;
    v8 = -2.0;
  }
  v10 = v8;
  v9 = v10;
LABEL_16:
  v14 = v2
      * v9
      * ((double)(unsigned int)(*(_DWORD *)(dword_1033707C + 36) - *(_DWORD *)(dword_1033707C + 68))
       / (double)1000);
  v11 = v7 + v14;
  v12 = v11;
  *a1 = v11;
  if ( (LODWORD(v14) >> 31) & 1 && v12 <= 1.01 )
  {
    result = 1;
    *a1 = 1.0;
  }
  else if ( (LODWORD(v14) >> 31) & 1 || v12 < 0.9900000095367432 )
  {
    result = 0;
  }
  else
  {
    result = 1;
    *a1 = 1.0;
  }
  return result;
}
// 1033707C: using guessed type int dword_1033707C;

//----- (1002B600) --------------------------------------------------------
unsigned int __cdecl sub_1002B600(char a1, _BYTE *a2, float *a3)
{
  _BYTE *v3; // esi@1
  float *v4; // edi@1
  int v5; // edx@1
  int v6; // ST14_4@1
  int v7; // ST18_4@1
  int v8; // ST1C_4@1
  int v9; // ST20_4@1
  double v10; // st7@3
  char v11; // bl@6
  unsigned int result; // eax@33
  float v13; // [sp+24h] [bp-4h]@1

  v3 = a2;
  *a2 = 1;
  v4 = a3;
  *a3 = 2.0;
  v5 = *(_DWORD *)(dword_1033707C + 64);
  v6 = *(_DWORD *)(dword_1033707C + 68);
  v7 = *(_DWORD *)(dword_1033707C + 72);
  v8 = *(_DWORD *)(dword_1033707C + 76);
  v9 = *(_DWORD *)(dword_1033707C + 80);
  v13 = *(float *)(dword_1033707C + 84);
  *(float *)&a2 = v13;
  if ( (LODWORD(v13) & 0x7F800000) == 2139095040 || v13 > 4.0 )
  {
    v13 = 4.0;
    v10 = 4.0;
  }
  else
  {
    v10 = 4.0;
    if ( v13 < 0.30000001 )
      v13 = 0.30000001;
  }
  v11 = a1;
  if ( !a1 && *(_BYTE *)(dword_1033707C + 99) == a1 )
    v11 = 1;
  if ( BYTE3(v5) == 6 )
  {
    if ( (unsigned __int8)v11 < *(_BYTE *)(dword_1033707C + 94) && *(_BYTE *)(dword_1033707C + 816) )
      v11 = *(_BYTE *)(dword_1033707C + 94);
    if ( -1.0 != *(float *)(dword_1033707C + 116) )
      v11 = 5;
    switch ( v11 )
    {
      case 4:
        *v4 = sub_1002AD60(&a1);
        *v3 = 4;
        break;
      case 3:
        *v4 = 0.30000001;
        *v3 = 3;
        break;
      case 2:
        *v4 = 1.0;
        *v3 = 2;
        break;
      case 0:
        *v4 = v10;
        *v3 = 0;
        break;
      case 5:
        *v4 = sub_1002B240(*(float *)(dword_1033707C + 116));
        *v3 = 5;
        break;
      default:
        break;
    }
LABEL_30:
    if ( v11 == 5 )
      goto LABEL_33;
    goto LABEL_31;
  }
  if ( BYTE3(v5) == 2 )
  {
    sub_1002B450(v4);
    *v3 = 2;
    goto LABEL_30;
  }
  if ( BYTE3(v5) == 4 )
  {
    sub_1002AEA0(v4);
    *v3 = 4;
    goto LABEL_30;
  }
  if ( BYTE3(v5) == 5 )
  {
    sub_1002B2B0(v4);
    *v3 = 5;
    goto LABEL_30;
  }
  sub_1002B0D0(v4);
  if ( v11 )
  {
    *v3 = 1;
    goto LABEL_30;
  }
  *v3 = 0;
LABEL_31:
  if ( v13 + 0.009999999776482582 < *v4 )
  {
    *v4 = v13;
    *v3 = *(_BYTE *)(dword_1033707C + 1201);
  }
LABEL_33:
  result = *v3;
  if ( result >= 6 )
    result = 1;
  *v3 = result;
  return result;
}
// 1033707C: using guessed type int dword_1033707C;

//----- (1002B7F0) --------------------------------------------------------
void __cdecl sub_1002B7F0(float *a1, float *a2, int a3)
{
  float *v3; // esi@1
  float *v4; // edi@1
  int v5; // [sp+18h] [bp-8h]@1
  int v6; // [sp+1Ch] [bp-4h]@1
  float v7; // [sp+24h] [bp+4h]@1
  float v8; // [sp+24h] [bp+4h]@1
  float v9; // [sp+24h] [bp+4h]@1
  float v10; // [sp+24h] [bp+4h]@1
  float v11; // [sp+28h] [bp+8h]@1
  float v12; // [sp+28h] [bp+8h]@1

  v3 = a1;
  v4 = a2;
  v7 = (*a1 + *a2) * 0.5;
  sub_1007BDB0(v7, (int)&v5, (int)&v6);
  v8 = 1.0 / (1.0 - *(float *)&v5 * (0.00669437999013 * *(float *)&v5));
  v11 = sqrt(v8) * 6378137.0;
  v9 = 0.99330562000987 * v11 * v8;
  v12 = v11 * *(float *)&v6;
  *(float *)(a3 + 4) = (*v4 - *v3) * v9;
  v10 = v4[1] - v3[1];
  *(float *)a3 = v10;
  *(float *)a3 = sub_1007BCB0(v10) * v12;
}

//----- (1002B8B0) --------------------------------------------------------
double __cdecl sub_1002B8B0(int a1, int a2)
{
  return (float)(*(float *)(a1 + 4) * *(float *)(a2 + 4) + *(float *)a1 * *(float *)a2);
}

//----- (1002B8D0) --------------------------------------------------------
bool __cdecl sub_1002B8D0(unsigned __int8 a1, float *a2)
{
  unsigned __int16 v2; // di@1
  double v3; // st7@5
  int v4; // ecx@5
  __int16 i; // ax@5
  int v6; // eax@6
  bool v7; // cf@7
  bool result; // al@10

  *a2 = 0.0;
  v2 = 0;
  if ( *(_BYTE *)(dword_1033707C + 812) == -1
    || *(_WORD *)(dword_1033707C + 828) == -1
    || 9.9999996e24 == *(float *)(dword_1033707C + 552)
    || 9.9999996e24 == *(float *)(dword_1033707C + 568) )
  {
    result = 0;
  }
  else
  {
    v3 = *(float *)(dword_1033707C + 552);
    *a2 = *(float *)(dword_1033707C + 552);
    sub_10061E30(*(_DWORD *)(dword_1033707C + 544));
    *a2 = v3 * *(float *)(dword_1033707C + 568) + *a2;
    v4 = dword_10337074;
    for ( i = *(_WORD *)(44 * *(_WORD *)(dword_1033707C + 828) + dword_10337074 + 332);
          i != -1;
          i = *(_WORD *)(v6 + dword_10337074 + 332) )
    {
      v6 = 44 * i;
      if ( *(_BYTE *)(v6 + v4 + 324) > a1 )
        break;
      v7 = v2 < 0x1F4u;
      if ( v2 >= 0x1F4u )
        goto LABEL_10;
      ++v2;
      *a2 = *(float *)(v6 + v4 + 336) + *a2;
      v4 = dword_10337074;
    }
    v7 = v2 < 0x1F4u;
LABEL_10:
    result = v7;
  }
  return result;
}
// 10061E30: using guessed type _DWORD __cdecl sub_10061E30(_DWORD);
// 10337074: using guessed type int dword_10337074;
// 1033707C: using guessed type int dword_1033707C;

//----- (1002B9D0) --------------------------------------------------------
signed __int16 sub_1002B9D0()
{
  signed __int16 result; // ax@2

  if ( sub_10041770() )
    result = *(_WORD *)(dword_1033707C + 16);
  else
    result = 1;
  return result;
}
// 1033707C: using guessed type int dword_1033707C;

//----- (1002B9F0) --------------------------------------------------------
char sub_1002B9F0()
{
  char v0; // bl@1
  unsigned __int8 v1; // al@2
  char v2; // al@3
  char result; // al@6

  v0 = 0;
  if ( !sub_10041770() )
    return v0;
  sub_10061E50();
  v1 = *(_BYTE *)(dword_1033707C + 204);
  if ( v1 )
  {
    if ( v1 < 3u )
      v0 = *(_BYTE *)(dword_1033707C + 8 * v1 + 1224);
    sub_10061E40();
    return v0;
  }
  v2 = *(_BYTE *)(dword_1033707C + 94);
  if ( v2 != 3 && v2 != 4 && *(_BYTE *)(dword_1033707C + 1211) )
  {
    sub_10061E40();
    result = 0;
  }
  else
  {
    sub_10061E40();
    result = 1;
  }
  return result;
}
// 1033707C: using guessed type int dword_1033707C;

//----- (1002BA50) --------------------------------------------------------
char __cdecl sub_1002BA50(float *a1)
{
  char v1; // bl@2
  char result; // al@5

  if ( sub_10041770() )
  {
    sub_10061E50();
    *a1 = *(float *)(dword_1033707C + 920);
    v1 = 1;
    if ( *(_BYTE *)(dword_1033707C + 815) != 1 || !*(_DWORD *)(dword_1033707C + 916) )
      v1 = 0;
    sub_10061E40();
    result = v1;
  }
  else
  {
    *a1 = 0.0;
    result = 0;
  }
  return result;
}
// 1033707C: using guessed type int dword_1033707C;

//----- (1002BAA0) --------------------------------------------------------
char __cdecl sub_1002BAA0(float *a1, float *a2)
{
  double v2; // st7@4
  char v3; // ST10_1@4
  double v4; // ST14_8@4
  float v5; // ST10_4@4
  char result; // al@4
  char v7; // [sp+18h] [bp-28h]@2
  char v8; // [sp+26h] [bp-1Ah]@2

  if ( !sub_10041770() || (sub_1002A470((int)&v7), v8) || sub_1002AA10(0) )
  {
    *a1 = 0.0;
    result = 0;
    *a2 = 0.0;
  }
  else
  {
    sub_10061E50();
    *a1 = *(float *)(dword_1033707C + 308);
    v2 = *(float *)(dword_1033707C + 324);
    *a2 = *(float *)(dword_1033707C + 324);
    sub_10061E30(*(_DWORD *)(dword_1033707C + 296));
    *a1 = v2 * *a2 + *a1;
    v3 = sub_1002AD10();
    sub_10061E40();
    v4 = *a1;
    v5 = v4 - sub_1002A710(v3);
    *a1 = v5;
    *a1 = sub_1007BCB0(v5);
    result = 1;
  }
  return result;
}
// 10061E30: using guessed type _DWORD __cdecl sub_10061E30(_DWORD);
// 1033707C: using guessed type int dword_1033707C;

//----- (1002BB90) --------------------------------------------------------
char __cdecl sub_1002BB90(float *a1, float *a2, float *a3, float *a4)
{
  float *v4; // edi@6
  char v5; // bl@6
  char result; // al@6
  char v7; // [sp+20h] [bp-28h]@2
  char v8; // [sp+2Eh] [bp-1Ah]@2

  *a1 = 0.0;
  *a2 = 0.0;
  *a3 = 0.0;
  *a4 = 0.0;
  if ( sub_10041770() )
  {
    sub_1002A470((int)&v7);
    sub_10061E50();
    if ( v8
      || *(_BYTE *)(dword_1033707C + 661)
      && (!*(_BYTE *)(dword_1033707C + 64)
       || (unsigned int)(*(_DWORD *)(dword_1033707C + 36) - *(_DWORD *)(dword_1033707C + 740)) >= 0x124F80) )
    {
      sub_10061E40();
      result = 0;
    }
    else
    {
      v4 = (float *)(dword_1033707C + 804);
      sub_10061E30(*(_DWORD *)(dword_1033707C + 808));
      *a1 = 0.0 * *v4 + *(float *)(dword_1033707C + 796);
      sub_10045800(0.52359879, -0.52359879);
      *a2 = *v4;
      *a3 = *(float *)(dword_1033707C + 560);
      *a4 = *(float *)(dword_1033707C + 588);
      v5 = *(_BYTE *)(dword_1033707C + 785);
      sub_10061E40();
      result = v5;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10061E30: using guessed type _DWORD __cdecl sub_10061E30(_DWORD);
// 1033707C: using guessed type int dword_1033707C;

//----- (1002BCE0) --------------------------------------------------------
char __cdecl sub_1002BCE0(float *a1, float *a2, _BYTE *a3)
{
  char result; // al@2
  char v4; // bl@3

  if ( sub_10041770() )
  {
    sub_10061E50();
    *a1 = *(float *)(dword_1033707C + 276);
    *a2 = *(float *)(dword_1033707C + 280);
    *a3 = *(_BYTE *)(dword_1033707C + 274);
    v4 = *(_BYTE *)(dword_1033707C + 272);
    sub_10061E40();
    result = v4;
  }
  else
  {
    *a1 = 9.9999996e24;
    *a2 = 9.9999996e24;
    *a3 = 0;
    result = 6;
  }
  return result;
}
// 1033707C: using guessed type int dword_1033707C;

//----- (1002BD60) --------------------------------------------------------
char __cdecl sub_1002BD60(float *a1)
{
  double v1; // st7@3
  char result; // al@3
  char v3; // [sp+8h] [bp-28h]@2
  char v4; // [sp+16h] [bp-1Ah]@2

  *a1 = 9.9999996e24;
  if ( !sub_10041770() || (sub_1002A470((int)&v3), v4) )
  {
    result = 0;
  }
  else
  {
    sub_10061E50();
    v1 = *(float *)(dword_1033707C + 340);
    *a1 = *(float *)(dword_1033707C + 340);
    sub_10061E30(*(_DWORD *)(dword_1033707C + 296));
    *a1 = v1 * *(float *)(dword_1033707C + 336) + *a1;
    sub_10061E40();
    result = 1;
  }
  return result;
}
// 10061E30: using guessed type _DWORD __cdecl sub_10061E30(_DWORD);
// 1033707C: using guessed type int dword_1033707C;

//----- (1002BE00) --------------------------------------------------------
char __cdecl sub_1002BE00(char a1)
{
  char v1; // bl@1
  unsigned __int8 v2; // al@3

  v1 = 0;
  if ( sub_10041770() )
  {
    sub_10061E50();
    if ( *(_BYTE *)(dword_1033707C + 95) == 3 )
    {
      v2 = *(_BYTE *)(dword_1033707C + 204);
      if ( !v2 || a1 && *(_DWORD *)(dword_1033707C + 8 * v2 + 1228) == *(_DWORD *)(dword_10337070 + 260) )
        v1 = 1;
    }
    sub_10061E40();
  }
  return v1;
}
// 10337070: using guessed type int dword_10337070;
// 1033707C: using guessed type int dword_1033707C;

//----- (1002BE50) --------------------------------------------------------
void __cdecl sub_1002BE50(int a1, int a2, int a3, float *a4, int a5)
{
  int v5; // edi@1
  int v6; // esi@3
  int v7; // ebx@5
  float *v8; // eax@9
  char v9; // [sp+10h] [bp-8h]@5

  v5 = a1;
  *(float *)&a1 = *(double *)a1;
  *(float *)&a1 = *(float *)&a1 - 6.283185005187988;
  a1 &= 0x7FFFFFFFu;
  if ( *(float *)&a1 < 0.1
    || (*(float *)&a1 = *(double *)(v5 + 8),
        *(float *)&a1 = *(float *)&a1 - 6.283185005187988,
        a1 &= 0x7FFFFFFFu,
        *(float *)&a1 < 0.1)
    || (v6 = a2,
        *(float *)&a1 = *(double *)a2,
        *(float *)&a1 = *(float *)&a1 - 6.283185005187988,
        a1 &= 0x7FFFFFFFu,
        *(float *)&a1 < 0.1)
    || (*(float *)&a1 = *(double *)(a2 + 8),
        *(float *)&a1 = *(float *)&a1 - 6.283185005187988,
        a1 &= 0x7FFFFFFFu,
        *(float *)&a1 < 0.1) )
  {
    v8 = (float *)a5;
    *a4 = 9.9999996e24;
    *v8 = 9.9999996e24;
  }
  else
  {
    sub_1007BCF0(v5, (int)&v9);
    v7 = a3;
    if ( (_BYTE)a3 )
      *(float *)&a1 = sub_1002A710(a3);
    else
      sub_10039B60(&v9, &a1);
    sub_1002CAD0(v5, v6, v7, (int)a4, a5, *(float *)&a1);
  }
}
// 10039B60: using guessed type _DWORD __cdecl sub_10039B60(_DWORD, _DWORD);

//----- (1002BF80) --------------------------------------------------------
char sub_1002BF80()
{
  char result; // al@2

  if ( sub_10041770() )
    result = *(_BYTE *)(dword_1033707C + 2);
  else
    result = 0;
  return result;
}
// 1033707C: using guessed type int dword_1033707C;

//----- (1002BFA0) --------------------------------------------------------
char sub_1002BFA0()
{
  char result; // al@2

  if ( sub_10041770() )
    result = *(_BYTE *)(dword_1033707C + 14);
  else
    result = 0;
  return result;
}
// 1033707C: using guessed type int dword_1033707C;

//----- (1002BFC0) --------------------------------------------------------
char __cdecl sub_1002BFC0(_BYTE *a1, int a2)
{
  _BYTE *v2; // edx@1
  unsigned __int8 v3; // bl@1
  char result; // al@1
  float *v5; // ecx@4
  int v6; // edi@4
  unsigned __int8 v7; // [sp+8h] [bp+4h]@2

  v2 = a1;
  v3 = *a1;
  result = 0;
  if ( *a1 < 0x82u )
  {
    v7 = 0;
    if ( 0.0 == *(float *)(a2 + 48) || !v3 )
      goto LABEL_14;
    v5 = (float *)(v2 + 52);
    v6 = v3;
    do
    {
      if ( 0.0 != *v5 )
        ++v7;
      v5 += 13;
      --v6;
    }
    while ( v6 );
    if ( v7 >= 0x1Eu )
    {
      result = 0;
    }
    else
    {
LABEL_14:
      qmemcpy(&v2[52 * v3 + 4], (const void *)a2, 0x34u);
      ++*v2;
      result = 1;
    }
  }
  return result;
}

//----- (1002C040) --------------------------------------------------------
int __cdecl sub_1002C040(_BYTE *a1, int a2)
{
  unsigned __int8 v2; // bl@1
  int result; // eax@4

  v2 = 0;
  if ( *a1 )
  {
    while ( a2 != sub_1002C480(a1[52 * v2 + 5], *(float *)&a1[52 * v2 + 52]) )
    {
      if ( ++v2 >= *a1 )
        goto LABEL_4;
    }
    result = (int)&a1[52 * v2 + 4];
  }
  else
  {
LABEL_4:
    result = 0;
  }
  return result;
}

//----- (1002C090) --------------------------------------------------------
int __cdecl sub_1002C090(_BYTE *a1, unsigned int a2)
{
  int result; // eax@1
  int v3; // ebp@1
  char v4; // al@4
  char v5; // [sp+10h] [bp-34h]@4
  char v6; // [sp+11h] [bp-33h]@4
  char v7; // [sp+12h] [bp-32h]@4
  char v8; // [sp+13h] [bp-31h]@4
  char v9; // [sp+14h] [bp-30h]@4
  char v10; // [sp+15h] [bp-2Fh]@4
  float v11; // [sp+18h] [bp-2Ch]@4
  float v12; // [sp+1Ch] [bp-28h]@4
  float v13; // [sp+20h] [bp-24h]@4
  float v14; // [sp+24h] [bp-20h]@4
  float v15; // [sp+28h] [bp-1Ch]@4
  float v16; // [sp+2Ch] [bp-18h]@4
  float v17; // [sp+30h] [bp-14h]@4
  float v18; // [sp+34h] [bp-10h]@4
  float v19; // [sp+38h] [bp-Ch]@4
  float v20; // [sp+3Ch] [bp-8h]@4
  float v21; // [sp+40h] [bp-4h]@4

  result = sub_1002C040(a1, a2);
  v3 = result;
  if ( !result )
  {
    if ( sub_1002C450(a2) || (unsigned __int8)sub_1002C550(a2) )
    {
      result = v3;
    }
    else
    {
      v15 = 9.9999996e24;
      v7 = 0;
      v8 = 0;
      v16 = 6.283185;
      v9 = 0;
      v18 = 6.283185;
      v10 = 0;
      v17 = 9.9999996e24;
      v19 = 9.9999996e24;
      v20 = 9.9999996e24;
      v4 = sub_1002C520(a2);
      v6 = v4;
      v11 = 9.9999996e24;
      v5 = v4;
      v13 = 9.9999996e24;
      v12 = 9.9999996e24;
      v14 = 9.9999996e24;
      v21 = 0.0;
      sub_1002BFC0(a1, (int)&v5);
      result = sub_1002C040(a1, a2);
    }
  }
  return result;
}

//----- (1002C160) --------------------------------------------------------
signed int __cdecl sub_1002C160(_BYTE *a1, int a2)
{
  int v2; // ebx@1
  signed int result; // eax@3
  void *v4; // eax@4

  v2 = sub_1002C480(*(_BYTE *)(a2 + 1), *(float *)(a2 + 48));
  if ( 0.0 == *(float *)(a2 + 48) || sub_1002C450(v2) )
  {
    v4 = (void *)sub_1002C040(a1, v2);
    if ( v4 )
    {
      qmemcpy(v4, (const void *)a2, 0x34u);
      result = v2;
    }
    else
    {
      if ( !sub_1002BFC0(a1, a2) )
        v2 = 16744448;
      result = v2;
    }
  }
  else
  {
    result = 16744448;
  }
  return result;
}

//----- (1002C1E0) --------------------------------------------------------
void *__cdecl sub_1002C1E0(void *a1)
{
  return memset(a1, 0, 0x1A6Cu);
}

//----- (1002C200) --------------------------------------------------------
void __cdecl sub_1002C200(int a1)
{
  unsigned __int8 v1; // bl@1
  int v2; // esi@1
  int v3; // edi@1
  int v4; // eax@1
  char v5; // cl@1
  int v6; // edx@6
  int v7; // eax@6
  bool v8; // c3@9
  double v9; // st6@9
  double v10; // st6@19
  float v11; // [sp+10h] [bp-4h]@2
  float v12; // [sp+18h] [bp+4h]@2
  float v13; // [sp+18h] [bp+4h]@11
  float v14; // [sp+18h] [bp+4h]@21

  v1 = 0;
  v2 = a1;
  v3 = sub_1002C580(0);
  v4 = sub_1002C480(*(_BYTE *)(a1 + 1), 0.0);
  v5 = sub_1002C400(0, v4);
  if ( 9.9999996e24 == *(float *)(a1 + 16) )
  {
    if ( 0.0 == *(float *)(a1 + 48)
      && v5 != -1
      && (v6 = 180 * (unsigned __int8)v5, v7 = v6 + v3, *(_BYTE *)(v6 + v3 + 772)) )
    {
      v1 = *(_BYTE *)(v6 + v3 + 772);
      v12 = *(float *)(v7 + 776);
      v11 = *(float *)(v7 + 780);
    }
    else
    {
      v12 = 9.9999996e24;
      v11 = 9.9999996e24;
    }
  }
  else
  {
    v12 = *(float *)(a1 + 16);
    v11 = *(float *)(v2 + 20);
    if ( v5 != -1 )
      v1 = *(_BYTE *)(180 * (unsigned __int8)v5 + v3 + 772);
  }
  v8 = 9.9999996e24 == *(float *)(v2 + 8);
  *(_BYTE *)(v2 + 2) &= 0xE7u;
  v9 = v12;
  if ( !v8 && 9.9999996e24 != v9 && (v13 = *(float *)(v2 + 8) - v9, COERCE_FLOAT(LODWORD(v13) & 0x7FFFFFFF) > 0.1524)
    || 9.9999996e24 == *(float *)(v2 + 8) && 9.9999996e24 != v9
    || 9.9999996e24 != *(float *)(v2 + 8) && v9 == 9.9999996e24
    || sub_1002BFA0() == 1 && (v1 ^ *(_BYTE *)(v2 + 2)) & 7 )
  {
    *(_BYTE *)(v2 + 2) = *(_BYTE *)(v2 + 2) & 0xF7 | 0x10;
  }
  else if ( (v1 & 7) == 5
         && ((v10 = v11, 9.9999996e24 != *(float *)(v2 + 12))
          && 9.9999996e24 != v10
          && (v14 = *(float *)(v2 + 12) - v10, COERCE_FLOAT(LODWORD(v14) & 0x7FFFFFFF) > 0.1524)
          || 9.9999996e24 == *(float *)(v2 + 12) && 9.9999996e24 != v10
          || 9.9999996e24 != *(float *)(v2 + 12) && 9.9999996e24 == v10
          || (*(_BYTE *)(v2 + 2) & 7) != 5) )
  {
    *(_BYTE *)(v2 + 2) = *(_BYTE *)(v2 + 2) & 0xF7 | 0x10;
  }
  else if ( 9.9999996e24 != *(float *)(v2 + 8) )
  {
    *(_BYTE *)(v2 + 2) |= 0x18u;
  }
}

//----- (1002C400) --------------------------------------------------------
char __cdecl sub_1002C400(unsigned __int8 a1, int a2)
{
  int v2; // eax@2
  int v3; // esi@2
  char v4; // al@2
  char result; // al@3

  if ( a2 == 16744448 )
  {
    result = -1;
  }
  else
  {
    v2 = sub_1002C5A0(a1);
    v3 = v2;
    v4 = sub_1002CB40(v2, a2);
    if ( v4 == -1 )
      result = -1;
    else
      result = *(_BYTE *)(((unsigned __int8)v4 << 6) + v3 + 22324);
  }
  return result;
}

//----- (1002C450) --------------------------------------------------------
bool __cdecl sub_1002C450(int a1)
{
  bool result; // al@5

  if ( a1 == 16744704 || a1 == 16745216 || a1 == 16744448 )
  {
    result = 0;
  }
  else if ( a1 == 16744960 )
  {
    result = 1;
  }
  else
  {
    result = (unsigned __int16)a1 != 0;
  }
  return result;
}

//----- (1002C480) --------------------------------------------------------
int __cdecl sub_1002C480(char a1, float a2)
{
  double v2; // st7@1
  int result; // eax@6
  float v4; // [sp+10h] [bp+8h]@4

  v2 = a2;
  if ( (LODWORD(a2) & 0x7F800000) == 2139095040 || v2 > 1851074.0 || v2 < -1851074.0 )
  {
    result = 16744448;
  }
  else
  {
    v4 = v2 * 0.0005399567889980972;
    if ( (unsigned __int8)a1 == 254 )
    {
      if ( sub_1007BD10(v4) )
        result = 16744960;
      else
        result = 16744704;
    }
    else if ( (unsigned __int8)a1 == 255 )
    {
      result = 16745216;
    }
    else
    {
      result = ((unsigned __int8)a1 << 16) | (unsigned __int16)sub_1007BD10(v4);
    }
  }
  return result;
}

//----- (1002C520) --------------------------------------------------------
char __cdecl sub_1002C520(unsigned int a1)
{
  int v1; // eax@5

  if ( a1 > 0xFF8200 )
  {
    if ( a1 == 16745216 )
    {
      LOBYTE(v1) = -1;
      return v1;
    }
    goto LABEL_8;
  }
  if ( a1 != 16744960 )
  {
    if ( a1 == 16744448 )
    {
      LOBYTE(v1) = 0;
      return v1;
    }
    if ( a1 != 16744704 )
LABEL_8:
      return a1 >> 16;
  }
  LOBYTE(v1) = -2;
  return v1;
}

//----- (1002C550) --------------------------------------------------------
BOOL __cdecl sub_1002C550(int a1)
{
  return a1 == 16744704 || a1 == 16744960 || a1 == 16745216;
}

//----- (1002C580) --------------------------------------------------------
int __cdecl sub_1002C580(unsigned __int8 a1)
{
  int result; // eax@2

  if ( a1 < 1u )
  {
    if ( !sub_10041770() || a1 )
      result = 0;
    else
      result = dword_10337070;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10337070: using guessed type int dword_10337070;

//----- (1002C5A0) --------------------------------------------------------
int __cdecl sub_1002C5A0(unsigned __int8 a1)
{
  int result; // eax@2

  if ( a1 < 1u )
  {
    if ( !sub_10041770() || a1 )
      result = 0;
    else
      result = dword_10337074;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10337074: using guessed type int dword_10337074;

//----- (1002C5C0) --------------------------------------------------------
char sub_1002C5C0()
{
  return sub_10061E70(-32763, 0);
}

//----- (1002C5D0) --------------------------------------------------------
char __cdecl sub_1002C5D0(int a1, unsigned __int8 a2)
{
  char result; // al@2

  if ( *(_BYTE *)(a1 + 7280) )
    result = sub_1002CE60(a1, 0, a2, 0);
  *(_BYTE *)(a1 + 7280) = 0;
  *(float *)(a1 + 7288) = 0.0;
  return result;
}

//----- (1002C610) --------------------------------------------------------
char __cdecl sub_1002C610(int a1, char a2, float a3, int a4, char a5, char a6, float a7, float a8, int a9, int a10)
{
  char v10; // al@1
  char v11; // cl@1
  char v12; // al@1
  int v13; // edx@4
  int v14; // eax@4

  v10 = *(_BYTE *)(a10 + 4);
  *(_BYTE *)(a10 + 3) &= 0xF7u;
  v11 = *(_BYTE *)(a10 + 3);
  v12 = v10 & 0xD7 | 0x10;
  *(_BYTE *)(a10 + 4) = v12;
  if ( (byte_10333D83 & 0x30) == 48 && a2 != -1 )
    *(_BYTE *)(a10 + 4) = v12 & 0xFD;
  *(_WORD *)(a10 + 232) |= 0x10u;
  *(_BYTE *)(a10 + 3) = v11 | 0x80;
  sub_1002C5D0(a10, 0xFFu);
  *(_DWORD *)(a10 + 7480) = a1;
  *(_BYTE *)(a10 + 7435) = 6;
  *(_BYTE *)(a10 + 7436) = 0;
  *(_DWORD *)(a10 + 7492) = *(_DWORD *)a4;
  v13 = *(_DWORD *)(a4 + 4);
  *(float *)(a10 + 7484) = 6.283185;
  *(float *)(a10 + 7488) = 6.283185;
  *(float *)(a10 + 7456) = a7;
  *(_DWORD *)(a10 + 7496) = v13;
  *(_BYTE *)(a10 + 7431) = a5;
  *(float *)(a10 + 7468) = a8;
  *(float *)(a10 + 7476) = a8;
  *(_BYTE *)(a10 + 7428) = a6;
  *(_BYTE *)(a10 + 7434) = 2;
  *(_BYTE *)(a10 + 7433) = 1;
  *(_DWORD *)(a10 + 7442) = *(_DWORD *)a9;
  *(_DWORD *)(a10 + 7446) = *(_DWORD *)(a9 + 4);
  v14 = *(_DWORD *)(a9 + 8);
  *(_DWORD *)(a10 + 7450) = v14;
  *(float *)(a10 + 8) = a3;
  *(_BYTE *)a10 = a2;
  if ( a2 == -1 )
  {
    *(_BYTE *)(a10 + 3) |= 0x30u;
    ++*(_BYTE *)(a10 + 5);
  }
  else
  {
    qmemcpy((void *)(52 * (unsigned __int8)a2 + a10 + 7732), (const void *)(a10 + 232), 0x34u);
    LOBYTE(v14) = *(_BYTE *)(a10 + 3) & 0xEF | 0x20;
    ++*(_BYTE *)(a10 + 5);
    *(_BYTE *)(a10 + 3) = v14;
  }
  return v14;
}
// 10333D83: using guessed type char byte_10333D83;

//----- (1002C750) --------------------------------------------------------
char __cdecl sub_1002C750(int a1, char a2, int a3, char a4, char a5, float a6, float a7, int a8, int a9)
{
  return sub_1002C610(a1, a2, 6.283185, a3, a4, a5, a6, a7, a8, a9);
}

//----- (1002C7A0) --------------------------------------------------------
char __cdecl sub_1002C7A0(float a1, int a2, int a3)
{
  char v3; // bl@8
  char result; // al@8
  unsigned __int8 v5; // [sp+Ch] [bp-28h]@1
  unsigned __int8 v6; // [sp+18h] [bp-1Ch]@2
  char v7; // [sp+1Ah] [bp-1Ah]@6

  sub_1002A470((int)&v5);
  if ( LOBYTE(a1) < v5
    || LOBYTE(a1) >= v6 && ((unsigned __int8)(LOBYTE(a1) - 100) > 1u || *(_BYTE *)(dword_1033707C + 816) != 3)
    || LOBYTE(a1) >= 0x66u
    || v7
    || sub_1002AA10(1) )
  {
    result = 0;
  }
  else
  {
    sub_10061E50();
    v3 = sub_1002C850(a1, a2, a3);
    sub_10061E40();
    result = v3;
  }
  return result;
}
// 1033707C: using guessed type int dword_1033707C;

//----- (1002C850) --------------------------------------------------------
char __cdecl sub_1002C850(float a1, int a2, int a3)
{
  double v3; // st7@1
  unsigned __int8 v4; // bl@1
  float *v5; // esi@1
  int v6; // ebp@1
  unsigned __int8 v7; // cl@1
  char result; // al@1
  int v9; // edx@5
  int v10; // eax@6
  unsigned int v11; // ecx@6
  double v12; // st6@7
  int v13; // eax@10
  int v14; // edi@10
  double v15; // st6@11
  double v16; // st6@13
  double v17; // st7@16
  double v18; // st6@16
  double v19; // rt1@18
  char v20; // bl@22
  double v21; // st6@25
  float v22; // [sp+10h] [bp+4h]@7
  float v23; // [sp+10h] [bp+4h]@7
  float v24; // [sp+10h] [bp+4h]@7
  float v25; // [sp+10h] [bp+4h]@25
  _BYTE *v26; // [sp+14h] [bp+8h]@1

  v3 = 0.0;
  v4 = LOBYTE(a1);
  v5 = (float *)a2;
  *(float *)a2 = 0.0;
  *(_DWORD *)a3 = 0x7FFFFFFF;
  v6 = dword_1033707C;
  v26 = (_BYTE *)(dword_1033707C + 812);
  v7 = *(_BYTE *)(dword_1033707C + 812);
  result = 0;
  if ( LOBYTE(a1) < v7
    || LOBYTE(a1) >= *(_BYTE *)(dword_10337070 + 4)
    && ((unsigned __int8)(LOBYTE(a1) - 100) > 1u || *(_BYTE *)(dword_1033707C + 816) != 3) )
  {
    return result;
  }
  v9 = v7 + 1;
  if ( LOBYTE(a1) - v9 + 1 >= 4 )
  {
    v10 = 180 * v9;
    v11 = (((unsigned int)LOBYTE(a1) - v9 - 3) >> 2) + 1;
    v9 += 4 * v11;
    do
    {
      v12 = *(float *)(v10 + dword_10337070 + 696);
      v10 += 720;
      --v11;
      v22 = v12 + *v5;
      *v5 = v22;
      v23 = v22 + *(float *)(v10 + dword_10337070 + 156);
      *v5 = v23;
      v24 = v23 + *(float *)(v10 + dword_10337070 + 336);
      *v5 = v24;
      *v5 = v24 + *(float *)(v10 + dword_10337070 + 516);
    }
    while ( v11 );
    v6 = dword_1033707C;
  }
  if ( v9 <= v4 )
  {
    v13 = 180 * v9;
    v14 = v4 - v9 + 1;
    do
    {
      v15 = *(float *)(v13 + dword_10337070 + 696);
      v13 += 180;
      --v14;
      *v5 = v15 + *v5;
    }
    while ( v14 );
    v6 = dword_1033707C;
  }
  v16 = 9.9999996e24;
  if ( 9.9999996e24 == *(float *)(v6 + 316) || 9.9999996e24 == *(float *)(v6 + 332) )
  {
    v18 = 0.0;
    v17 = 9.9999996e24;
    *v5 = 0.0;
  }
  else
  {
    if ( *(_BYTE *)(180 * *v26 + dword_10337070 + 671) == 21 )
      goto LABEL_19;
    sub_10061E30(*(_DWORD *)(v6 + 296));
    *v5 = 0.0 * *(float *)(dword_1033707C + 332) + *(float *)(dword_1033707C + 316) + *v5;
    v17 = 9.9999996e24;
    v18 = 0.0;
  }
  v19 = v18;
  v16 = v17;
  v3 = v19;
LABEL_19:
  *(_DWORD *)v5 = COERCE_UNSIGNED_INT(*v5) & 0x7FFFFFFF;
  if ( (COERCE_UNSIGNED_INT(*v5) & 0x7F800000) == 2139095040 || v16 < *v5 || v3 > *v5 )
  {
    *v5 = v3;
    v20 = 0;
  }
  else
  {
    v20 = 1;
  }
  if ( *(_BYTE *)(dword_1033707C + 660) )
  {
    v25 = *v5 / *(float *)(dword_1033707C + 688) + 0.5;
    v21 = v25;
    if ( (LODWORD(v25) & 0x7F800000) == 2139095040 || v21 > 2147418112.0 || v21 < v3 )
    {
      *(_DWORD *)a3 = 0x7FFFFFFF;
      result = 0;
    }
    else
    {
      *(_DWORD *)a3 = (signed int)v21;
      result = v20;
    }
  }
  else
  {
    result = v20;
  }
  return result;
}
// 10061E30: using guessed type _DWORD __cdecl sub_10061E30(_DWORD);
// 10337070: using guessed type int dword_10337070;
// 1033707C: using guessed type int dword_1033707C;

//----- (1002CAB0) --------------------------------------------------------
int __cdecl sub_1002CAB0(int a1, float a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(float *)a3 = *(float *)a1 * a2;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  return result;
}

//----- (1002CAD0) --------------------------------------------------------
void __cdecl sub_1002CAD0(int a1, int a2, int a3, int a4, int a5, float a6)
{
  double v6; // st7@4
  int v7; // [sp+18h] [bp+Ch]@6
  float v8; // [sp+18h] [bp+Ch]@6

  sub_10091760(a1, a2, (float *)a4, (float *)a5);
  if ( (_BYTE)a3 != 1 && *(float *)a4 > 25.0 )
  {
    if ( (_BYTE)a3 )
      v6 = sub_1002A710(a3);
    else
      v6 = a6;
    *(float *)&v7 = v6;
    v8 = *(float *)a5 - *(float *)&v7;
    *(float *)a5 = v8;
    *(float *)a5 = sub_1007BCB0(v8);
  }
}

//----- (1002CB40) --------------------------------------------------------
char __cdecl sub_1002CB40(int a1, int a2)
{
  unsigned __int8 v2; // cl@3
  char result; // al@3

  if ( a1 && a2 != 16744448 && (v2 = *(_BYTE *)(a1 + 10), result = 0, v2) )
  {
    while ( *(_DWORD *)(((unsigned __int8)result << 6) + a1 + 22332) != a2 )
    {
      if ( (unsigned __int8)++result >= v2 )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    result = -1;
  }
  return result;
}

//----- (1002CB80) --------------------------------------------------------
bool __cdecl sub_1002CB80(int a1)
{
  double v1; // st7@2
  char v2; // al@8
  float v3; // ST04_4@9
  int v4; // eax@11
  bool result; // al@16

  if ( sub_10041770() )
  {
    sub_10061E50();
    v1 = 9.9999996e24;
    if ( *(_BYTE *)(dword_1033707C + 190) )
      *(float *)(a1 + 4) = *(float *)(dword_1033707C + 212);
    else
      *(float *)(a1 + 4) = 9.9999996e24;
    if ( *(_BYTE *)(dword_1033707C + 662) )
      *(float *)(a1 + 8) = *(float *)(dword_1033707C + 692);
    else
      *(float *)(a1 + 8) = 9.9999996e24;
    v2 = *(_BYTE *)(dword_1033707C + 1504);
    *(_BYTE *)(a1 + 40) = v2;
    if ( v2 )
    {
      sub_1007BDB0(*(float *)(dword_1033707C + 1508), a1 + 44, a1 + 48);
      v3 = -*(float *)(dword_1033707C + 1512);
      sub_1002CAB0(a1 + 44, v3, a1 + 44);
      v1 = 9.9999996e24;
    }
    else
    {
      *(float *)(a1 + 44) = 0.0;
      *(float *)(a1 + 48) = 0.0;
    }
    *(_BYTE *)a1 = *(_BYTE *)(dword_1033707C + 672);
    v4 = dword_1033707C;
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(dword_1033707C + 776);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(v4 + 780);
    if ( *(_BYTE *)(dword_1033707C + 201) )
      *(float *)(a1 + 20) = *(float *)(dword_1033707C + 256);
    else
      *(float *)(a1 + 20) = v1;
    if ( *(_BYTE *)(dword_1033707C + 195) )
      v1 = *(float *)(dword_1033707C + 224);
    *(float *)(a1 + 28) = v1;
    *(float *)(a1 + 16) = *(float *)(dword_1033707C + 240);
    *(float *)(a1 + 24) = *(float *)(dword_1033707C + 720);
    *(float *)(a1 + 12) = *(float *)(dword_1033707C + 852);
    result = sub_10061E40();
  }
  else
  {
    result = a1;
    *(float *)(a1 + 4) = 9.9999996e24;
    *(_BYTE *)a1 = 0;
    *(float *)(a1 + 8) = 9.9999996e24;
    *(_BYTE *)(a1 + 40) = 0;
    *(float *)(a1 + 16) = 4.5698152;
    *(float *)(a1 + 12) = 9.9999996e24;
    *(float *)(a1 + 32) = 6.283185;
    *(float *)(a1 + 36) = 6.283185;
    *(float *)(a1 + 24) = 6.283185;
    *(float *)(a1 + 20) = 9.9999996e24;
    *(float *)(a1 + 28) = 9.9999996e24;
    *(float *)(a1 + 48) = 0.0;
    *(float *)(a1 + 44) = 0.0;
  }
  return result;
}
// 1033707C: using guessed type int dword_1033707C;

//----- (1002CD10) --------------------------------------------------------
void __cdecl sub_1002CD10(void *a1)
{
  int v1; // ecx@1
  int v2; // eax@1
  int v3; // edx@1
  double v4; // st7@1
  double v5; // st7@1
  int v6; // ecx@1
  double v7; // st6@1
  int v8; // eax@1
  char v9; // [sp+4h] [bp-34h]@1
  float v10; // [sp+8h] [bp-30h]@1
  float v11; // [sp+14h] [bp-24h]@1
  float v12; // [sp+18h] [bp-20h]@1
  float v13; // [sp+1Ch] [bp-1Ch]@1
  float v14; // [sp+20h] [bp-18h]@1
  int v15; // [sp+24h] [bp-14h]@1
  int v16; // [sp+28h] [bp-10h]@1
  int v17; // [sp+2Ch] [bp-Ch]@1
  int v18; // [sp+30h] [bp-8h]@1
  int v19; // [sp+34h] [bp-4h]@1

  sub_1002CB80((int)&v9);
  memset(a1, 0, 0x34u);
  v1 = v16;
  *((float *)a1 + 1) = v10;
  v2 = v15;
  v3 = v18;
  *((float *)a1 + 2) = v13;
  v4 = v11;
  *(_WORD *)a1 |= 0x400u;
  *((float *)a1 + 3) = v4;
  *((_DWORD *)a1 + 7) = v1;
  v5 = v12;
  *((_DWORD *)a1 + 9) = v1;
  v6 = v17;
  *((float *)a1 + 4) = v5;
  v7 = v14;
  *((_DWORD *)a1 + 6) = v2;
  *((float *)a1 + 5) = v7;
  *((_DWORD *)a1 + 8) = v2;
  v8 = v19;
  *((_DWORD *)a1 + 10) = v6;
  *((_DWORD *)a1 + 11) = v3;
  *((_DWORD *)a1 + 12) = v8;
  if ( v5 < 30.86666679382324 )
  {
    *((float *)a1 + 4) = 30.866667;
  }
  else if ( 9.9999996e24 == v5 )
  {
    *((float *)a1 + 4) = 30.866667;
  }
}

//----- (1002CDC0) --------------------------------------------------------
int __cdecl sub_1002CDC0(int a1)
{
  int result; // eax@1
  __int16 v2; // cx@1

  result = a1;
  v2 = *(_WORD *)a1;
  *(float *)(a1 + 4) = 9.9999996e24;
  *(float *)(a1 + 8) = 6.283185;
  *(_WORD *)a1 = v2 & 0xF806 | 6;
  *(float *)(a1 + 12) = 4.5698152;
  *(_BYTE *)(a1 + 40) = 0;
  *(float *)(a1 + 16) = 9.9999996e24;
  *(float *)(a1 + 20) = 9.9999996e24;
  *(float *)(a1 + 24) = 6.283185;
  *(float *)(a1 + 28) = 6.283185;
  *(float *)(a1 + 32) = 6.283185;
  *(float *)(a1 + 36) = 6.283185;
  *(float *)(a1 + 48) = 0.0;
  *(float *)(a1 + 44) = 0.0;
  return result;
}

//----- (1002CE10) --------------------------------------------------------
BOOL __cdecl sub_1002CE10(char a1)
{
  return a1 != 23
      && a1 != 1
      && a1 != 7
      && a1 != 10
      && a1 != 11
      && a1 != 12
      && a1 != 13
      && a1 != 14
      && a1 != 18
      && a1 != 19
      && a1 != 20
      && a1 != 21
      && a1 != 22;
}

//----- (1002CE60) --------------------------------------------------------
char __cdecl sub_1002CE60(int a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  char v4; // bl@3
  int v5; // edi@4
  int v6; // esi@4
  int v7; // eax@7
  __int16 v8; // cx@8
  int v9; // eax@8
  __int16 v10; // bx@14
  int v11; // eax@14
  int v12; // ecx@17
  void *v13; // edi@17
  int v14; // ecx@19
  int v15; // edx@24
  int v16; // ebx@24
  const void *v17; // esi@25
  void *v18; // edi@25
  __int16 v19; // cx@27
  int v20; // ecx@28
  signed int v21; // ecx@31

  if ( a3 == -1 )
  {
    memset((void *)(a1 + 44), 0, 0x44u);
    memset((void *)(a1 + 112), 0, 0x78u);
  }
  v4 = a4;
  if ( (unsigned __int8)(a4 + 99) > 0xC6u || (v5 = a4, v6 = a4 + a3, v6 < 0) || a3 < 0x64u && v6 >= 100 )
  {
    v7 = a1 + 7732;
    v21 = 100;
    do
    {
      *(_WORD *)v7 &= 0xFBFFu;
      v7 += 52;
      --v21;
    }
    while ( v21 );
  }
  else
  {
    LOBYTE(v7) = a2;
    if ( a2 != -1 )
    {
      v8 = a2;
      v9 = a2;
      if ( a2 < (signed int)a3 )
      {
        do
        {
          if ( v8 >= 100 )
            break;
          *(_WORD *)(52 * v9 + a1 + 7732) &= 0xFBFFu;
          v9 = ++v8;
        }
        while ( v8 < (signed int)a3 );
      }
      LOBYTE(v7) = a3;
      if ( a3 < 0x64u || !a4 )
      {
        if ( a4 <= 0 )
        {
          if ( a4 < 0 )
          {
            LOBYTE(v7) = a3;
            if ( (signed __int16)a3 < 100 )
            {
              v7 = 52 * a3 + a1 + 7732;
              v15 = 52 * (a4 + a3) + a1 + 7732;
              v16 = (unsigned __int16)(100 - a3);
              do
              {
                v17 = (const void *)v7;
                v18 = (void *)v15;
                v7 += 52;
                v15 += 52;
                --v16;
                qmemcpy(v18, v17, 0x34u);
              }
              while ( v16 );
              v4 = a4;
            }
            v19 = v4 + 100;
            if ( v19 < 100 )
            {
              v7 = 52 * v19 + a1 + 7732;
              v20 = (unsigned __int16)-v4;
              do
              {
                *(_WORD *)v7 &= 0xFBFFu;
                v7 += 52;
                --v20;
              }
              while ( v20 );
            }
          }
        }
        else
        {
          v10 = 99 - a4;
          v11 = v10;
          if ( v10 >= (signed int)a3 )
          {
            while ( 1 )
            {
              v12 = v11;
              --v10;
              v13 = (void *)(52 * (v5 + v11) + a1 + 7732);
              v11 = v10;
              qmemcpy(v13, (const void *)(52 * v12 + a1 + 7732), 0x34u);
              if ( v10 < (signed int)a3 )
                break;
              v5 = a4;
            }
            v6 = a4 + a3;
          }
          v14 = a3;
          v7 = a3;
          if ( a3 < v6 )
          {
            do
            {
              *(_WORD *)(52 * v7 + a1 + 7732) &= 0xFBFFu;
              v7 = (signed __int16)++v14;
            }
            while ( (signed __int16)v14 < v6 );
          }
        }
      }
    }
  }
  return v7;
}

//----- (1002D210) --------------------------------------------------------
char __cdecl sub_1002D210(void *a1)
{
  void *v1; // ebx@3
  char *v2; // ebp@3
  char *v3; // edi@4
  bool v4; // zf@4
  int v5; // eax@5
  signed int v6; // edx@5
  char *v7; // edi@6
  char result; // al@2
  char *v9; // [sp+4h] [bp+4h]@3

  if ( sub_10041770() )
  {
    sub_10061E50();
    memcpy(a1, dword_10337078, 0x32ECu);
    result = sub_10061E40();
  }
  else
  {
    v1 = a1;
    *((float *)a1 + 2) = 6.283185;
    *((float *)a1 + 1822) = 0.0;
    *((float *)a1 + 1823) = 0.0;
    *((_DWORD *)a1 + 1821) = 16744448;
    *((_DWORD *)a1 + 1827) = 16744448;
    *((float *)a1 + 1824) = 6.283185;
    *((_DWORD *)a1 + 1828) = 16744448;
    *((float *)a1 + 1825) = 6.283185;
    *((float *)a1 + 1829) = 9.9999996e24;
    *((float *)a1 + 1830) = 9.9999996e24;
    *(_BYTE *)a1 = -1;
    *((_BYTE *)a1 + 1) = 0;
    *((_WORD *)a1 + 3) = -1;
    *((_BYTE *)a1 + 2) = -1;
    *((_BYTE *)a1 + 5) = 0;
    *((_BYTE *)a1 + 3) = 0;
    *((_BYTE *)a1 + 4) = 16;
    *((_BYTE *)a1 + 7280) = 0;
    *((_BYTE *)a1 + 7304) = -1;
    *((_BYTE *)a1 + 7305) = 0;
    *((_BYTE *)a1 + 7306) = 0;
    sub_1002CDC0((int)a1 + 232);
    *((_DWORD *)a1 + 3) = 0;
    *((_DWORD *)a1 + 4) = 0;
    *((_DWORD *)a1 + 5) = 0;
    *((_DWORD *)a1 + 6) = 0;
    *((_DWORD *)a1 + 7) = 0;
    *((_DWORD *)a1 + 8) = 0;
    *((_DWORD *)a1 + 9) = 0;
    *((_DWORD *)a1 + 10) = 0;
    memset((char *)a1 + 44, 0, 0x44u);
    memset((char *)a1 + 112, 0, 0x78u);
    memset((char *)a1 + 7048, 0, 0xE8u);
    v2 = (char *)a1 + 7480;
    v9 = (char *)2;
    do
    {
      memset(v2 - 108, 0, 0xB4u);
      *((float *)v2 - 3) = 0.0;
      *(v2 - 45) = 23;
      *(_DWORD *)v2 = 0x3FFFF;
      *((float *)v2 - 6) = 9.9999996e24;
      *(v2 - 46) = 1;
      *(v2 - 49) = 1;
      *((float *)v2 + 1) = 6.283185;
      *(v2 - 52) = 0;
      *((float *)v2 + 2) = 6.283185;
      *(v2 - 44) = 0;
      *((float *)v2 + 3) = 6.283185;
      *(v2 - 38) = 0;
      *((float *)v2 + 4) = 6.283185;
      v3 = v2 - 104;
      v2 += 180;
      v4 = v9-- == (char *)1;
      qmemcpy(v3, (char *)v1 + 232, 0x34u);
    }
    while ( !v4 );
    v5 = (int)v1 + 7732;
    v6 = 102;
    do
    {
      v7 = (char *)v5;
      v5 += 52;
      --v6;
      qmemcpy(v7, (char *)v1 + 232, 0x34u);
    }
    while ( v6 );
    memset((char *)v1 + 7324, 0, 0x30u);
    result = (unsigned int)sub_1002C1E0((char *)v1 + 284);
  }
  return result;
}

//----- (1002D280) --------------------------------------------------------
void sub_1002D280()
{
  dword_102569B8 = -15;
}
// 102569B8: using guessed type int dword_102569B8;

//----- (1002D290) --------------------------------------------------------
signed int sub_1002D290()
{
  return sub_1007CC90((int)&off_100E4BF0);
}
// 100E4BF0: using guessed type char *off_100E4BF0;

//----- (1002D2A0) --------------------------------------------------------
char sub_1002D2A0()
{
  char result; // al@2

  if ( (unsigned __int8)sub_1002D290() == 1 )
    result = *(_BYTE *)(dword_102569B8 + 1);
  else
    result = 1;
  return result;
}
// 102569B8: using guessed type int dword_102569B8;

//----- (1002D2C0) --------------------------------------------------------
__int16 __cdecl sub_1002D2C0(char a1, char a2)
{
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1
  int v5; // [sp+Ch] [bp-4h]@1

  v3 = 0;
  v4 = 0;
  v5 = 0;
  if ( sub_10046840(a2, (int)&v3) )
  {
    if ( a1 == 1 )
      return HIWORD(v4);
    if ( a1 == 2 )
      return v5;
    if ( a1 == 3 )
      return HIWORD(v5);
  }
  return 0;
}

//----- (1002D330) --------------------------------------------------------
__int16 __cdecl sub_1002D330(char a1, char a2)
{
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1
  int v5; // [sp+Ch] [bp-4h]@1

  v3 = 0;
  v4 = 0;
  v5 = 0;
  if ( sub_10046840(a2, (int)&v3) )
  {
    if ( a1 == 1 )
      return v3;
    if ( a1 == 2 )
      return HIWORD(v3);
    if ( a1 == 3 )
      return v4;
  }
  return 0;
}

//----- (1002D3A0) --------------------------------------------------------
char __cdecl sub_1002D3A0(char a1, signed __int16 *a2)
{
  int v2; // esi@1
  void *v3; // ecx@1
  int v4; // eax@1
  int v5; // esi@3
  unsigned int v6; // edx@3
  int v7; // esi@3
  __int16 v8; // ax@3
  signed __int16 *v9; // edi@3
  int v10; // esi@3
  unsigned int v11; // edx@3
  int v12; // esi@3
  __int16 v13; // ax@3
  signed __int16 v14; // cx@3
  signed __int16 v15; // ax@3
  bool v16; // sf@3
  unsigned __int8 v17; // of@3
  char result; // al@10

  v2 = sub_10043FF0(&a1, 1u, (int)&unk_100E513C, 12, 3, 2);
  v4 = sub_100429D0(v3);
  if ( v4 != dword_100E5140[3 * v2] && v4 != dword_100E5144[3 * v2] )
  {
    result = 0;
  }
  else
  {
    v5 = (unsigned __int16)sub_1002D330(1, a1);
    v6 = (signed int)((unsigned __int64)(1374389535i64 * v5 * (unsigned __int16)j_HWM_pvg_get_anlg_outp(0)) >> 32) >> 5;
    v7 = v6 + (v6 >> 31);
    v8 = sub_1002D2C0(1, a1);
    v9 = a2;
    *a2 = v7 + v8;
    v10 = (unsigned __int16)sub_1002D330(2, a1);
    v11 = (signed int)((unsigned __int64)(1374389535i64 * v10 * (unsigned __int16)j_HWM_pvg_get_anlg_outp(3)) >> 32) >> 5;
    v12 = v11 + (v11 >> 31);
    v13 = sub_1002D2C0(2, a1);
    v14 = *v9;
    v15 = v12 + v13;
    v17 = __OFSUB__(*v9, 10000);
    v16 = (signed __int16)(*v9 - 10000) < 0;
    v9[1] = v15;
    v9[2] = 0;
    if ( !(v16 ^ v17) )
      v14 = 10000;
    *v9 = v14;
    if ( v14 <= 0 )
      v14 = 0;
    *v9 = v14;
    if ( v15 >= 10000 )
      v15 = 10000;
    v9[1] = v15;
    if ( v15 <= 0 )
    {
      v9[1] = 0;
      result = 1;
    }
    else
    {
      v9[1] = v15;
      result = 1;
    }
  }
  return result;
}
// 1007C7E0: using guessed type int __cdecl j_HWM_pvg_get_anlg_outp(_DWORD);
// 100E5140: using guessed type int dword_100E5140[];
// 100E5144: using guessed type int dword_100E5144[];

//----- (1002D4D0) --------------------------------------------------------
char __thiscall sub_1002D4D0(void *this)
{
  int v1; // eax@1
  bool v2; // zf@1
  char result; // al@1

  v1 = sub_100429D0(this);
  v2 = sub_10043350(28, v1) == 1;
  result = 1;
  if ( !v2 )
    result = 2;
  return result;
}

//----- (1002D4F0) --------------------------------------------------------
char __cdecl sub_1002D4F0(void *a1, char *a2)
{
  void *v2; // ecx@0
  char v3; // al@1
  char result; // al@2
  int v5; // eax@3
  char v6; // [sp+7h] [bp-1h]@1

  v6 = 3;
  v3 = sub_1004A0B0(v2);
  if ( (_BYTE)a1 == sub_10049D30(v3) )
  {
    *a2 = sub_1002D4D0(a1);
    result = 1;
  }
  else
  {
    v5 = (unsigned __int16)sub_10061F60((unsigned __int8)a1);
    if ( (_WORD)v5 == 904 || sub_100253C0(2, v5, &v6) != 1 || sub_100689B0((unsigned __int8 *)&v6) )
    {
      result = 0;
    }
    else
    {
      *a2 = v6;
      result = 1;
    }
  }
  return result;
}

//----- (1002D570) --------------------------------------------------------
bool __cdecl sub_1002D570(char a1, bool *a2)
{
  bool *v2; // esi@1
  __int16 v3; // ax@1
  bool v4; // cl@3
  char v6; // [sp+4h] [bp-14h]@1
  char v7[6]; // [sp+Eh] [bp-Ah]@2

  v2 = a2;
  sub_1007C3B0(9183, (int)&v6, 16);
  v3 = sub_10043FF0(&a1, 2u, (int)&v6, 2, 5, -1);
  v4 = v3 > -1 && v7[v3];
  *v2 = v4;
  return v3 > -1;
}
// 1002D570: using guessed type char var_A[6];

//----- (1002D5F0) --------------------------------------------------------
bool __cdecl sub_1002D5F0(char a1, bool *a2)
{
  bool *v2; // esi@1
  __int16 v3; // ax@1
  bool v4; // cl@3
  char v6; // [sp+4h] [bp-1Ch]@1
  char v7[10]; // [sp+12h] [bp-Eh]@2

  v2 = a2;
  sub_1007C3B0(9182, (int)&v6, 22);
  v3 = sub_10043FF0(&a1, 2u, (int)&v6, 2, 7, -1);
  v4 = v3 > -1 && v7[v3];
  *v2 = v4;
  return v3 > -1;
}
// 1002D5F0: using guessed type char var_E[10];

//----- (1002D670) --------------------------------------------------------
char sub_1002D670()
{
  int v0; // eax@1
  char result; // al@5
  char v2; // [sp+3h] [bp-59h]@1
  char *v3; // [sp+4h] [bp-58h]@1
  int v4; // [sp+8h] [bp-54h]@1
  int v5; // [sp+Ch] [bp-50h]@1
  __int16 *v6; // [sp+10h] [bp-4Ch]@1
  int v7; // [sp+14h] [bp-48h]@1
  int *v8; // [sp+18h] [bp-44h]@1
  int v9; // [sp+1Ch] [bp-40h]@1
  int v10; // [sp+20h] [bp-3Ch]@1
  __int16 v11; // [sp+24h] [bp-38h]@1
  char v12; // [sp+26h] [bp-36h]@1
  char v13; // [sp+28h] [bp-34h]@1

  v5 = 0;
  v13 = 0;
  v6 = &v11;
  v2 = 10;
  v11 = -32754;
  v12 = 1;
  v10 = 4;
  v7 = 5;
  v8 = (int *)&v3;
  v9 = 1000;
  v3 = &v2;
  v4 = 1;
  v0 = sub_1007C1A0(18, (int)&v6);
  if ( v0 || v5 || v4 != 1 )
  {
    if ( v0 == 3 )
      result = 13;
    else
      result = 10;
  }
  else
  {
    result = v2;
  }
  return result;
}

//----- (1002D750) --------------------------------------------------------
char __cdecl sub_1002D750(void *a1)
{
  int v1; // esi@1
  char *v3; // [sp+Ch] [bp-F0h]@1
  int v4; // [sp+10h] [bp-ECh]@1
  int v5; // [sp+14h] [bp-E8h]@1
  __int16 *v6; // [sp+18h] [bp-E4h]@1
  int v7; // [sp+1Ch] [bp-E0h]@1
  int *v8; // [sp+20h] [bp-DCh]@1
  int v9; // [sp+24h] [bp-D8h]@1
  int v10; // [sp+28h] [bp-D4h]@1
  __int16 v11; // [sp+2Ch] [bp-D0h]@1
  char v12; // [sp+2Eh] [bp-CEh]@1
  char v13; // [sp+30h] [bp-CCh]@1
  char v14; // [sp+60h] [bp-9Ch]@1

  memset(&v14, 0, 0x98u);
  v6 = &v11;
  v5 = 0;
  v13 = 0;
  v11 = -32748;
  v12 = 1;
  v10 = 4;
  v7 = 5;
  v8 = (int *)&v3;
  v9 = 1000;
  v3 = &v14;
  v4 = 152;
  v1 = sub_1007C1A0(18, (int)&v6);
  if ( v5 != 3 || sub_1002D670() != 7 )
  {
    if ( !v1 && !v5 && v4 == 152 )
    {
      qmemcpy(a1, &v14, 0x98u);
      return 0;
    }
    memset(a1, 0, 0x98u);
    *(_BYTE *)a1 = 0;
    *((_WORD *)a1 + 69) = 0x7FFF;
    *((_DWORD *)a1 + 35) = -1;
    *((_DWORD *)a1 + 36) = -1;
  }
  else
  {
    qmemcpy(a1, &v14, 0x98u);
  }
  return 3;
}

//----- (1002D8A0) --------------------------------------------------------
char __cdecl sub_1002D8A0(__int16 a1, char *a2, __int16 a3, int a4)
{
  __int16 v4; // ax@4
  char result; // al@4
  char *v6; // [sp+Ch] [bp-F0h]@1
  int v7; // [sp+10h] [bp-ECh]@1
  int v8; // [sp+14h] [bp-E8h]@1
  __int16 *v9; // [sp+18h] [bp-E4h]@1
  int v10; // [sp+1Ch] [bp-E0h]@1
  int *v11; // [sp+20h] [bp-DCh]@1
  int v12; // [sp+24h] [bp-D8h]@1
  int v13; // [sp+28h] [bp-D4h]@1
  char v14; // [sp+2Ch] [bp-D0h]@1
  __int16 v15; // [sp+2Eh] [bp-CEh]@4
  char v16; // [sp+30h] [bp-CCh]@4
  __int16 v17; // [sp+64h] [bp-98h]@1
  __int16 v18; // [sp+68h] [bp-94h]@1
  __int16 v19; // [sp+6Ah] [bp-92h]@1

  v8 = 0;
  v9 = &v17;
  v19 = a1;
  v17 = -32754;
  v18 = a3;
  v13 = 4;
  v10 = 8;
  v11 = (int *)&v6;
  v12 = 200;
  v6 = &v14;
  v7 = 56;
  if ( sub_1007C1A0(38, (int)&v9) || v8 || v7 != 56 )
  {
    sub_100421E0((int)a2, "None", (unsigned __int16)a3);
    *(_WORD *)a4 = -1;
    result = 0;
  }
  else
  {
    strncpy(a2, &v16, (unsigned __int16)a3);
    v4 = v15;
    a2[(unsigned __int16)a3 - 1] = 0;
    *(_WORD *)a4 = v4;
    result = v14;
  }
  return result;
}

//----- (1002D9D0) --------------------------------------------------------
int __cdecl sub_1002D9D0(char *a1, __int16 a2)
{
  bool v2; // zf@3
  int result; // eax@3
  char *v4; // [sp+4h] [bp-B8h]@3
  int v5; // [sp+8h] [bp-B4h]@3
  int v6; // [sp+Ch] [bp-B0h]@3
  __int16 *v7; // [sp+10h] [bp-ACh]@3
  int v8; // [sp+14h] [bp-A8h]@3
  int *v9; // [sp+18h] [bp-A4h]@3
  int v10; // [sp+1Ch] [bp-A0h]@3
  int v11; // [sp+20h] [bp-9Ch]@3
  __int16 v12; // [sp+24h] [bp-98h]@3
  __int16 v13; // [sp+2Ah] [bp-92h]@3

  if ( !a1 )
    sub_10042930(".\\mdb\\mdb_intf_map.c", 330, 1, 0);
  v6 = 0;
  v13 = a2;
  v12 = -32756;
  v11 = 4;
  v7 = &v12;
  v8 = 8;
  v9 = (int *)&v4;
  v10 = 300;
  v4 = a1;
  v5 = 51;
  v2 = sub_1007C1A0(38, (int)&v7) == 0;
  result = v6;
  if ( !v2 || v6 || v5 != 51 )
    *a1 = 0;
  a1[50] = 0;
  return result;
}

//----- (1002DAB0) --------------------------------------------------------
signed int __cdecl sub_1002DAB0(char *a1, char *a2)
{
  int v2; // ecx@5
  int v3; // eax@5
  signed int result; // eax@8
  int v5; // ecx@8
  int *v6; // [sp+8h] [bp-C0h]@5
  int v7; // [sp+Ch] [bp-BCh]@5
  int v8; // [sp+10h] [bp-B8h]@5
  __int16 *v9; // [sp+14h] [bp-B4h]@5
  int v10; // [sp+18h] [bp-B0h]@5
  int *v11; // [sp+1Ch] [bp-ACh]@5
  int v12; // [sp+20h] [bp-A8h]@5
  int v13; // [sp+24h] [bp-A4h]@5
  int v14; // [sp+28h] [bp-A0h]@5
  int v15; // [sp+2Ch] [bp-9Ch]@8
  __int16 v16; // [sp+30h] [bp-98h]@5
  int v17; // [sp+34h] [bp-94h]@5
  int v18; // [sp+38h] [bp-90h]@5

  if ( !a1 )
    sub_10042930(".\\mdb\\mdb_intf_map.c", 561, 1, 0);
  if ( !a2 )
    sub_10042930(".\\mdb\\mdb_intf_map.c", 562, 1, 0);
  v2 = *(_DWORD *)a2;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v3 = *(_DWORD *)a1;
  v9 = &v16;
  v17 = v3;
  v18 = v2;
  v16 = -32751;
  v13 = 4;
  v10 = 2;
  v11 = (int *)&v6;
  v12 = 100;
  v6 = &v14;
  v7 = 8;
  if ( sub_1007C1A0(38, (int)&v9) || v8 || v7 != 8 )
  {
    a1[1] = 0;
    *a1 = 0;
    result = 0xFFFF;
    *((_WORD *)a1 + 1) = -1;
    a2[1] = 0;
    *a2 = 0;
    *((_WORD *)a2 + 1) = -1;
  }
  else
  {
    result = v14;
    v5 = v15;
    *(_DWORD *)a1 = v14;
    *(_DWORD *)a2 = v5;
  }
  return result;
}

//----- (1002DBF0) --------------------------------------------------------
const char *__cdecl sub_1002DBF0(const char *a1, int a2)
{
  signed int v2; // eax@1
  const char *result; // eax@6
  int v4; // edx@10
  char v5; // cl@11

  *(_DWORD *)a2 = 757935405;
  *(_BYTE *)(a2 + 4) = 0;
  v2 = strlen(a1) - 1;
  if ( v2 >= 0 )
  {
    while ( a1[v2] != 32 )
    {
      if ( --v2 < 0 )
        goto LABEL_6;
    }
    a1[v2] = 0;
  }
LABEL_6:
  result = (const char *)(strlen(a1) - 1);
  if ( (signed int)result >= 0 )
  {
    while ( a1[(_DWORD)result] != 32 )
    {
      if ( (signed int)--result < 0 )
        return result;
    }
    a1[(_DWORD)result] = 0;
    result = &a1[(_DWORD)result + 1];
    v4 = a2 - (_DWORD)result;
    do
    {
      v5 = *result;
      result[v4] = *result;
      ++result;
    }
    while ( v5 );
  }
  return result;
}

//----- (1002DC70) --------------------------------------------------------
void sub_1002DC70()
{
  dword_103334E4 = -15;
}
// 103334E4: using guessed type int dword_103334E4;

//----- (1002DC80) --------------------------------------------------------
signed int sub_1002DC80()
{
  return sub_1007CC90((int)&off_100E70B4);
}
// 100E70B4: using guessed type char *off_100E70B4;

//----- (1002DC90) --------------------------------------------------------
char __cdecl sub_1002DC90(unsigned int a1)
{
  unsigned __int8 v1; // bl@2
  int v2; // eax@2
  char result; // al@5
  int v4; // eax@8
  int v5; // eax@8
  __int64 v6; // [sp-4h] [bp-2Ch]@0
  char v7; // [sp+8h] [bp-20h]@2
  unsigned int v8; // [sp+Ch] [bp-1Ch]@9
  unsigned __int8 v9; // [sp+10h] [bp-18h]@7
  unsigned int v10; // [sp+12h] [bp-16h]@5
  unsigned int v11; // [sp+18h] [bp-10h]@6

  LODWORD(v6) = a1;
  switch ( sub_1002EC50(v6) )
  {
    case 0:
    case 1:
    case 2:
    case 3:
      v1 = sub_1002EB70(a1);
      v2 = sub_1002EBA0(a1, v1, 1);
      (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(v2, 29, &v7);
      if ( !v1 )
        goto LABEL_9;
      if ( v1 == 1 )
      {
        result = (v9 >> 1) & 1;
      }
      else if ( v1 == 2 )
      {
        result = (v11 >> 14) & 1;
      }
      else
      {
        result = (v10 >> 23) & 1;
      }
      break;
    case 5:
    case 6:
    case 7:
    case 8:
      v4 = sub_10036180(a1);
      v5 = sub_1002EBA0(v4, 0, 1);
      (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(v5, 29, &v7);
LABEL_9:
      result = (v8 >> 29) & 1;
      break;
    case 0xC:
      result = 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;

//----- (1002DD90) --------------------------------------------------------
int __cdecl sub_1002DD90(unsigned __int8 a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 4u )
    result = sub_10043F80((unsigned __int8)byte_100E7120[12 * a1]);
  return result;
}

//----- (1002DDC0) --------------------------------------------------------
char __cdecl sub_1002DDC0(unsigned __int8 a1, int a2, char a3, int a4)
{
  char result; // al@2

  if ( (unsigned __int8)(*(int (__cdecl **)(int, signed int, int))dword_103334D8)(
                          a2 + dword_100E7124[3 * a1] - 3,
                          4,
                          a4) )
  {
    *(_BYTE *)(a4 + 4) = a3;
    *(_BYTE *)a4 &= byte_100E70C8[5 * a1];
    *(_BYTE *)(a4 + 1) &= byte_100E70C9[5 * a1];
    *(_BYTE *)(a4 + 2) &= byte_100E70CA[5 * a1];
    *(_BYTE *)(a4 + 3) &= byte_100E70CB[5 * a1];
    *(_BYTE *)(a4 + 4) &= byte_100E70CC[5 * a1];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100E7124: using guessed type int dword_100E7124[];
// 103334D8: using guessed type int dword_103334D8;

//----- (1002DE40) --------------------------------------------------------
signed int __usercall sub_1002DE40@<eax>(signed int result@<eax>, int a2@<ecx>)
{
  void *v2; // edi@2
  unsigned int v3; // ecx@2

  if ( result < 31 )
  {
    v2 = (void *)(a2 + 4 * result);
    v3 = 31 - result;
    result = 0x3FFFF;
    memset32(v2, 0x3FFFF, v3);
  }
  return result;
}

//----- (1002DE60) --------------------------------------------------------
char __usercall sub_1002DE60@<al>(int a1@<eax>, unsigned __int8 a2)
{
  int v2; // edi@1
  unsigned int v3; // edi@2
  char v4; // dl@2
  signed int v5; // eax@2
  char result; // al@6
  __int16 v7; // [sp+Ch] [bp-1ECh]@1
  char v8[490]; // [sp+Eh] [bp-1EAh]@3

  v2 = a1;
  if ( (unsigned __int8)(*(int (__cdecl **)(int, signed int, __int16 *))dword_103334D8)(
                          dword_10333500[3 * (unsigned __int8)byte_100E711C[12 * a2]],
                          492,
                          &v7) )
  {
    v3 = v2 - *(_DWORD *)(dword_10333D50 + 4 * a2 + 20812);
    v4 = 0;
    v5 = 163;
    do
    {
      if ( *(unsigned __int16 *)((char *)&v7 + 3 * v5) + ((v8[3 * v5] & 3u) << 16) <= v3 )
      {
        v4 = v5;
        v5 = 0;
      }
      --v5;
    }
    while ( v5 >= 0 );
    result = v4 + 4;
  }
  else
  {
    result = -92;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333500: using guessed type int dword_10333500[];
// 10333D50: using guessed type int dword_10333D50;
// 1002DE60: using guessed type char var_1EA[490];

//----- (1002DF00) --------------------------------------------------------
int __cdecl sub_1002DF00(int a1)
{
  unsigned __int8 v1; // cl@0
  int result; // eax@1
  int v3; // ecx@2

  result = 0x3FFFF;
  if ( v1 < 4u )
  {
    v3 = 6 * (unsigned __int8)byte_100E711C[12 * v1];
    result = dword_10333500[2 * v3 / 4u] + a1 * (unsigned __int16)word_10333504[v3];
  }
  return result;
}
// 10333500: using guessed type int dword_10333500[];
// 10333504: using guessed type __int16 word_10333504[];

//----- (1002DF40) --------------------------------------------------------
signed int __usercall sub_1002DF40@<eax>(unsigned __int8 a1@<bl>, int a2)
{
  char *v2; // ebp@1
  int v3; // esi@1
  int v4; // eax@1
  int v5; // edi@1
  int v6; // eax@3
  int v7; // esi@4
  int v8; // eax@5
  unsigned int v9; // edi@7
  unsigned int v10; // esi@9
  int v11; // eax@9
  signed int result; // eax@15
  unsigned __int8 v13; // [sp+0h] [bp-24h]@0
  unsigned __int16 v14; // [sp+10h] [bp-14h]@3
  char v15; // [sp+12h] [bp-12h]@3
  unsigned int v16; // [sp+14h] [bp-10h]@3
  char v17; // [sp+18h] [bp-Ch]@9
  char v18; // [sp+1Ch] [bp-8h]@9

  v2 = (char *)(a2 + 4);
  v3 = *(_BYTE *)(a2 + 4) - 4;
  v4 = sub_1002DD90(v13);
  v5 = v4;
  if ( v3 >= 0
    && v4
    && (v6 = sub_1002DF00(v3),
        (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_103334D8)(v6, 3, &v14),
        v16 = v14 + ((v15 & 3) << 16),
        v16 != 0x3FFFF) )
  {
    v7 = v3 + 1;
    if ( v7 >= 164 )
      goto LABEL_7;
    while ( 1 )
    {
      v8 = sub_1002DF00(v7);
      (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_103334D8)(v8, 3, &v14);
      if ( v14 + ((v15 & 3) << 16) != 0x3FFFF )
        break;
      if ( ++v7 >= 164 )
        goto LABEL_7;
    }
    if ( v7 >= 164 )
LABEL_7:
      v9 = v5 - 1;
    else
      v9 = v14 + ((v15 & 3) << 16);
    while ( v9 > v16 )
    {
      v10 = (v16 + v9) >> 1;
      v11 = sub_1002EBA0(v10, a1, 0);
      sub_1002DDC0(a1, v11, *v2, (int)&v17);
      if ( sub_10043970(v2, &v18, 5) <= 0 )
        v9 = v10;
      else
        v16 = v10 + 1;
    }
    result = v9;
  }
  else
  {
    result = 0x3FFFF;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;

//----- (1002E0B0) --------------------------------------------------------
char __usercall sub_1002E0B0@<al>(char a1@<al>)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 0;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 3;
      break;
    default:
      result = 4;
      break;
  }
  return result;
}

//----- (1002E0E0) --------------------------------------------------------
int __fastcall sub_1002E0E0(int a1, int a2)
{
  int result; // eax@1

  result = ((*(_WORD *)a1 << 9) + (*(_WORD *)(a1 + 5) & 0x1FF)) << 7;
  *(_DWORD *)a2 = (*(_BYTE *)(a1 + 4) + (*(_WORD *)(a1 + 2) << 8)) << 7;
  *(_DWORD *)(a2 + 4) = result;
  return result;
}

//----- (1002E110) --------------------------------------------------------
void __cdecl sub_1002E110(unsigned int a1, int a2)
{
  unsigned __int8 v2; // bl@4
  int v3; // ebp@4
  char v4; // ST34_1@4
  char v5; // [sp+Ch] [bp-Ch]@4
  char v6; // [sp+10h] [bp-8h]@5

  if ( a1 >= 0x3E8 )
  {
    if ( a1 >= *(_DWORD *)(dword_10333D50 + 20828) )
    {
      if ( ((a1 >> 16) & 0xFC00) == 12288 )
        sub_1003A3C0(a1, a2);
      else
        sub_10037360(a1, a2);
    }
    else
    {
      v2 = sub_1002EB70(a1);
      v3 = sub_1002EBA0(a1, v2, 1);
      v4 = sub_1002DE60(a1, v2);
      if ( sub_1002DDC0(v2, v3, v4, (int)&v5) )
      {
        sub_1003A7A0(&v6, 6, a2);
        sub_100423E0(a2, 6);
      }
      else
      {
        *(_DWORD *)a2 = 1600085855;
        *(_WORD *)(a2 + 4) = 24415;
        *(_BYTE *)(a2 + 6) = 0;
      }
    }
  }
  else
  {
    *(_DWORD *)a2 = 1600085855;
    *(_WORD *)(a2 + 4) = 24415;
    *(_BYTE *)(a2 + 6) = 0;
  }
}
// 100EBB80: using guessed type int dword_100EBB80;
// 10333D50: using guessed type int dword_10333D50;

//----- (1002E250) --------------------------------------------------------
char __cdecl sub_1002E250(int a1, int a2)
{
  char result; // al@2
  unsigned __int8 v3; // al@4
  int v4; // eax@4
  char v5; // [sp+4h] [bp-8h]@4

  if ( (unsigned int)a1 >= 0x3E8 )
  {
    if ( (unsigned int)a1 >= *(_DWORD *)(dword_10333D50 + 20828) )
    {
      if ( (((unsigned int)a1 >> 16) & 0xFC00) == 12288 )
        result = sub_1003A5A0(a1, a2);
      else
        result = sub_10037560(a1, a2);
    }
    else
    {
      v3 = sub_1002EB70(a1);
      v4 = sub_1002EBA0(a1, v3, 1);
      (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(v4, 7, &v5);
      result = sub_1002E0E0((int)&v5, a2);
    }
  }
  else
  {
    result = a2;
    *(_DWORD *)a2 = 2147483648;
    *(_DWORD *)(a2 + 4) = 2147483648;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333D50: using guessed type int dword_10333D50;

//----- (1002E300) --------------------------------------------------------
int __cdecl sub_1002E300(char a1, int a2)
{
  char v2; // al@1
  int v3; // ecx@1
  int result; // eax@2

  v2 = sub_1002E0B0(a1);
  if ( (unsigned __int8)v2 >= 4u )
    result = v3;
  else
    result = a2 + *(_DWORD *)(dword_10333D50 + 4 * (unsigned __int8)v2 + 20812);
  return result;
}
// 10333D50: using guessed type int dword_10333D50;

//----- (1002E330) --------------------------------------------------------
signed int __cdecl sub_1002E330(unsigned __int8 a1)
{
  int v1; // ecx@0
  _DWORD *v2; // esi@1
  signed int result; // eax@1
  signed int v4; // ebp@1
  int v5; // edi@2
  char v6; // ST30_1@2
  unsigned int v7; // eax@2
  char *v8; // ecx@2
  _DWORD *v9; // edx@2
  int v10; // esi@6
  int v11; // eax@7
  _BYTE *v12; // ecx@7
  _BYTE *v13; // edx@7
  int v14; // eax@9
  _BYTE *v15; // ecx@9
  _BYTE *v16; // edx@9
  _BYTE *v17; // ecx@11
  _BYTE *v18; // edx@11
  signed int v19; // eax@13
  bool v20; // zf@16
  char v21; // [sp+10h] [bp-Ch]@2

  v2 = (_DWORD *)v1;
  result = sub_1002DF40(a1, v1);
  v4 = result;
  if ( result == 0x3FFFF )
    return result;
  v5 = sub_1002EBA0(result, a1, 0);
  v6 = sub_1002DE60(v4 + *(_DWORD *)(dword_10333D50 + 4 * a1 + 20812), a1);
  sub_1002DDC0(a1, v5, v6, (int)&v21);
  v7 = 5;
  v8 = &v21;
  v9 = v2;
  do
  {
    if ( *v9 != *(_DWORD *)v8 )
      goto LABEL_6;
    v7 -= 4;
    v8 += 4;
    ++v9;
  }
  while ( v7 >= 4 );
  if ( !v7 )
  {
LABEL_15:
    v19 = 0;
    goto LABEL_16;
  }
LABEL_6:
  v10 = *(_BYTE *)v9 - (unsigned __int8)*v8;
  if ( *(_BYTE *)v9 == (unsigned __int8)*v8 )
  {
    v11 = v7 - 1;
    v12 = v8 + 1;
    v13 = (char *)v9 + 1;
    if ( !v11 )
      goto LABEL_15;
    v10 = *v13 - *v12;
    if ( *v13 == *v12 )
    {
      v14 = v11 - 1;
      v15 = v12 + 1;
      v16 = v13 + 1;
      if ( !v14 )
        goto LABEL_15;
      v10 = *v16 - *v15;
      if ( *v16 == *v15 )
      {
        v17 = v15 + 1;
        v18 = v16 + 1;
        if ( v14 == 1 )
          goto LABEL_15;
        v10 = *v18 - *v17;
        if ( *v18 == *v17 )
          goto LABEL_15;
      }
    }
  }
  v19 = 1;
  if ( v10 <= 0 )
    v19 = -1;
LABEL_16:
  v20 = v19 == 0;
  result = 0x3FFFF;
  if ( v20 )
    result = v4;
  return result;
}
// 10333D50: using guessed type int dword_10333D50;

//----- (1002E450) --------------------------------------------------------
signed int __usercall sub_1002E450@<eax>(unsigned __int8 a1@<dl>, int a2@<ecx>, _DWORD *a3)
{
  unsigned __int8 v3; // bl@1
  unsigned int v4; // edi@1
  int v5; // esi@2
  char v6; // ST30_1@2
  _DWORD *v7; // edx@2
  unsigned int v8; // eax@2
  char *v9; // ecx@2
  int v10; // esi@6
  int v11; // eax@7
  _BYTE *v12; // ecx@7
  _BYTE *v13; // edx@7
  int v14; // eax@9
  _BYTE *v15; // ecx@9
  _BYTE *v16; // edx@9
  _BYTE *v17; // ecx@11
  _BYTE *v18; // edx@11
  signed int v19; // eax@13
  bool v20; // zf@16
  signed int result; // eax@16
  char v22; // [sp+10h] [bp-Ch]@2

  v3 = a1;
  v4 = a2 + 1;
  if ( a2 + 1 >= (unsigned int)sub_1002DD90(a1) )
    return 0x3FFFF;
  v5 = sub_1002EBA0(v4, v3, 0);
  v6 = sub_1002DE60(v4 + *(_DWORD *)(dword_10333D50 + 4 * v3 + 20812), v3);
  sub_1002DDC0(v3, v5, v6, (int)&v22);
  v7 = a3;
  v8 = 5;
  v9 = &v22;
  do
  {
    if ( *v7 != *(_DWORD *)v9 )
      goto LABEL_6;
    v8 -= 4;
    v9 += 4;
    ++v7;
  }
  while ( v8 >= 4 );
  if ( !v8 )
  {
LABEL_15:
    v19 = 0;
    goto LABEL_16;
  }
LABEL_6:
  v10 = *(_BYTE *)v7 - (unsigned __int8)*v9;
  if ( *(_BYTE *)v7 == (unsigned __int8)*v9 )
  {
    v11 = v8 - 1;
    v12 = v9 + 1;
    v13 = (char *)v7 + 1;
    if ( !v11 )
      goto LABEL_15;
    v10 = *v13 - *v12;
    if ( *v13 == *v12 )
    {
      v14 = v11 - 1;
      v15 = v12 + 1;
      v16 = v13 + 1;
      if ( !v14 )
        goto LABEL_15;
      v10 = *v16 - *v15;
      if ( *v16 == *v15 )
      {
        v17 = v15 + 1;
        v18 = v16 + 1;
        if ( v14 == 1 )
          goto LABEL_15;
        v10 = *v18 - *v17;
        if ( *v18 == *v17 )
          goto LABEL_15;
      }
    }
  }
  v19 = 1;
  if ( v10 <= 0 )
    v19 = -1;
LABEL_16:
  v20 = v19 == 0;
  result = v4;
  if ( !v20 )
    return 0x3FFFF;
  return result;
}
// 10333D50: using guessed type int dword_10333D50;

//----- (1002E560) --------------------------------------------------------
void __usercall sub_1002E560(int a1@<ecx>, int a2@<esi>)
{
  int v2; // [sp+0h] [bp-8h]@1
  int v3; // [sp+4h] [bp-4h]@1

  sub_1002E0E0(a1, (int)&v2);
  *(double *)a2 = sub_10043B40(v2, 24);
  *(double *)(a2 + 8) = sub_10043B40(v3, 24);
}

//----- (1002E590) --------------------------------------------------------
signed int __cdecl sub_1002E590(const char *a1, int a2, signed int *a3)
{
  int v3; // edi@1
  unsigned __int8 v4; // bl@2
  signed int v5; // edi@2
  int i; // eax@3
  int v7; // eax@9
  unsigned __int8 v9; // [sp+Ch] [bp-14h]@2
  char v10; // [sp+14h] [bp-Ch]@1
  char v11; // [sp+18h] [bp-8h]@1

  v3 = (int)a1;
  *a3 = 0;
  sub_10043A00(a1, (int)&v10);
  if ( v11 )
  {
    v4 = 0;
    v9 = 0;
    v5 = 20812;
    do
    {
      for ( i = sub_1002E330(v9); i != 0x3FFFF; i = sub_1002E450(v4, i, &v10) )
      {
        if ( *a3 >= 31 )
          break;
        *(_DWORD *)(a2 + 4 * (*a3)++) = i + *(_DWORD *)(v5 + dword_10333D50);
      }
      ++v4;
      v5 += 4;
      v9 = v4;
    }
    while ( v4 < 4u );
    v3 = (int)a1;
  }
  if ( *a3 < 31 )
  {
    v7 = sub_1003A190(v3);
    if ( v7 != 0x3FFFF )
      *(_DWORD *)(a2 + 4 * (*a3)++) = v7;
  }
  return sub_1002DE40(*a3, a2);
}
// 10333D50: using guessed type int dword_10333D50;

//----- (1002E680) --------------------------------------------------------
signed int __cdecl sub_1002E680(char a1, const char *a2, int a3, signed int *a4)
{
  const char *v4; // ecx@1
  unsigned __int8 v5; // bl@1
  int i; // eax@3
  int v7; // eax@9
  char v9; // [sp+14h] [bp-Ch]@2
  char v10; // [sp+18h] [bp-8h]@2

  v5 = sub_1002E0B0(a1);
  *a4 = 0;
  if ( v5 < 4u )
  {
    sub_10043A00(v4, (int)&v9);
    if ( v10 )
    {
      for ( i = sub_1002E330(v5); i != 0x3FFFF; i = sub_1002E450(v5, i, &v9) )
      {
        if ( *a4 >= 31 )
          break;
        *(_DWORD *)(a3 + 4 * (*a4)++) = i + *(_DWORD *)(dword_10333D50 + 4 * v5 + 20812);
      }
    }
    v4 = a2;
  }
  if ( a1 == 1 && *a4 < 31 )
  {
    v7 = sub_1003A190((int)v4);
    if ( v7 != 0x3FFFF )
      *(_DWORD *)(a3 + 4 * (*a4)++) = v7;
  }
  return sub_1002DE40(*a4, a3);
}
// 10333D50: using guessed type int dword_10333D50;

//----- (1002E770) --------------------------------------------------------
char __cdecl sub_1002E770(unsigned int a1, int a2)
{
  char result; // al@2
  unsigned __int8 v3; // bl@4
  int v4; // eax@4
  unsigned int v5; // ebx@7
  char v6; // bl@13
  int v7; // [sp+4h] [bp-20h]@4
  int v8; // [sp+8h] [bp-1Ch]@10
  unsigned __int8 v9; // [sp+Ch] [bp-18h]@9
  unsigned int v10; // [sp+Eh] [bp-16h]@7
  unsigned int v11; // [sp+14h] [bp-10h]@8

  if ( a1 >= 0x3E8 )
  {
    if ( a1 >= *(_DWORD *)(dword_10333D50 + 20828) )
    {
      if ( ((a1 >> 16) & 0xFC00) == 12288 )
      {
        v6 = sub_1003A5A0(a1, (int)&v7);
        if ( v6 )
        {
          sub_100489E0(a2, v7, v8);
          result = v6;
        }
        else
        {
          *(double *)a2 = 6.2831853071796;
          *(double *)(a2 + 8) = 6.2831853071796;
          result = 0;
        }
      }
      else
      {
        result = sub_100374F0(a1, a2);
      }
    }
    else
    {
      v3 = sub_1002EB70(a1);
      v4 = sub_1002EBA0(a1, v3, 1);
      (*(void (__cdecl **)(int, signed int, int *))dword_103334D8)(v4, 32, &v7);
      if ( v3 )
      {
        if ( v3 == 1 )
        {
          LOBYTE(v5) = v9 >> 1;
        }
        else if ( v3 == 2 )
        {
          v5 = v11 >> 14;
        }
        else
        {
          v5 = v10 >> 23;
        }
      }
      else
      {
        v5 = (unsigned int)v8 >> 29;
      }
      sub_1002E560((int)&v7, a2);
      result = v5 & 1;
    }
  }
  else
  {
    *(double *)a2 = 6.2831853071796;
    *(double *)(a2 + 8) = 6.2831853071796;
    result = 0;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333D50: using guessed type int dword_10333D50;

//----- (1002E890) --------------------------------------------------------
void __cdecl sub_1002E890(unsigned int a1, int a2)
{
  __int64 v2; // [sp-4h] [bp-24h]@0
  int v3; // [sp+8h] [bp-18h]@10
  char v4[4]; // [sp+Ch] [bp-14h]@10
  char v5; // [sp+10h] [bp-10h]@10

  if ( a1 >= 0x3E8 )
  {
    switch ( a1 )
    {
      case 0x3FFFFu:
        *(_DWORD *)a2 = 1600085855;
        *(_WORD *)(a2 + 4) = 24415;
        *(_BYTE *)(a2 + 6) = 0;
        break;
      case 0x3FFFEu:
        *(_DWORD *)a2 = 1801678668;
        *(_WORD *)(a2 + 4) = 25701;
        *(_BYTE *)(a2 + 6) = 0;
        break;
      case 0x3FFFDu:
        *(_DWORD *)a2 = 1330654800;
        *(_WORD *)(a2 + 4) = 83;
        *(_BYTE *)(a2 + 6) = 0;
        break;
      default:
        LODWORD(v2) = a1;
        if ( sub_10037F00(v2) == 11 )
        {
          sub_1003A840(a1, &v3, v4);
          sub_100351D0(v3, v4[0], &v5);
          sub_100421E0(a2, &v5, 7);
        }
        else
        {
          sub_1002E110(a1, a2);
        }
        break;
    }
  }
  else
  {
    sub_1003A9E0(a1, a2);
  }
}

//----- (1002E9E0) --------------------------------------------------------
double *__cdecl sub_1002E9E0(char a1, char a2, double *a3)
{
  unsigned int v3; // esi@1
  double *result; // eax@10
  __int64 v5; // [sp-4h] [bp-60h]@0
  int v6; // [sp+4h] [bp-58h]@7
  char v7; // [sp+8h] [bp-54h]@10
  double v8; // [sp+10h] [bp-4Ch]@3
  double v9; // [sp+18h] [bp-44h]@10
  char v10; // [sp+20h] [bp-3Ch]@10

  v3 = a2;
  if ( a2 == 0x3FFFF )
    goto LABEL_11;
  if ( (unsigned int)a2 >= 0x3E8 )
  {
    if ( a2 == 262141 )
    {
      sub_100419B0(a1, (int)&v8);
      goto LABEL_13;
    }
    LODWORD(v5) = a2;
    if ( sub_10037F00(v5) != 11 )
    {
      sub_1002E770(v3, (int)&v8);
      goto LABEL_13;
    }
    sub_1003A840(v3, &v6, &a2);
    if ( (_BYTE)v6 != -1 && a2 != -1 && sub_10035570(v6, a2) == v3 )
    {
      sub_10034BD0(v6, a2, &v10);
      sub_10034A90((int)&v10, (int)&v7);
      sub_1007BDD0((int)&v7, (int)&v8);
      result = a3;
      *a3 = v8;
      result[1] = v9;
      return result;
    }
LABEL_11:
    result = a3;
    v8 = 6.2831853071796;
    v9 = 6.2831853071796;
    *a3 = 6.2831853071796;
    result[1] = v9;
    return result;
  }
  sub_1003AA70(a2, (int)&v8);
LABEL_13:
  result = a3;
  *a3 = v8;
  result[1] = v9;
  return result;
}

//----- (1002EB10) --------------------------------------------------------
void __cdecl sub_1002EB10(unsigned int a1, char *a2)
{
  __int64 v2; // [sp-4h] [bp-10h]@0
  char v3[4]; // [sp+4h] [bp-8h]@2
  int v4; // [sp+8h] [bp-4h]@2

  LODWORD(v2) = a1;
  if ( sub_10037F00(v2) == 11 )
  {
    sub_1003A840(a1, &v4, v3);
    sub_100351D0(v4, v3[0], a2);
  }
  else
  {
    sub_1002E890(a1, (int)a2);
  }
}

//----- (1002EB70) --------------------------------------------------------
unsigned __int8 __cdecl sub_1002EB70(unsigned int a1)
{
  unsigned __int8 result; // al@1

  result = 0;
  do
  {
    if ( a1 < *(_DWORD *)(dword_10333D50 + 4 * result + 20816) )
      break;
    ++result;
  }
  while ( result < 4u );
  return result;
}
// 10333D50: using guessed type int dword_10333D50;

//----- (1002EBA0) --------------------------------------------------------
int __cdecl sub_1002EBA0(unsigned int a1, unsigned __int8 a2, char a3)
{
  unsigned int v3; // esi@2
  char v4; // bl@4
  int result; // eax@5

  if ( a2 >= 4u )
  {
    result = 0xFFFFFF;
  }
  else
  {
    v3 = a1;
    if ( a3 )
      v3 = a1 - *(_DWORD *)(dword_10333D50 + 4 * a2 + 20812);
    v4 = byte_100E7120[12 * a2];
    if ( sub_10043B80(v3, (unsigned __int8)byte_100E7120[12 * a2]) )
      result = dword_10333500[3 * (unsigned __int8)v4] + v3 * (unsigned __int16)word_10333504[6 * (unsigned __int8)v4];
    else
      result = 0xFFFFFF;
  }
  return result;
}
// 10333500: using guessed type int dword_10333500[];
// 10333504: using guessed type __int16 word_10333504[];
// 10333D50: using guessed type int dword_10333D50;

//----- (1002EC20) --------------------------------------------------------
int __cdecl sub_1002EC20(unsigned int a1)
{
  unsigned __int8 v1; // ST14_1@1

  v1 = sub_1002EB70(a1);
  return sub_1002EBA0(a1, v1, 1);
}

//----- (1002EC50) --------------------------------------------------------
char __cdecl sub_1002EC50(__int64 a1)
{
  char v1; // bl@1
  char result; // al@3
  unsigned __int16 v3; // ax@7

  v1 = 9;
  if ( (unsigned int)a1 < 0x3E8 )
  {
LABEL_13:
    result = v1;
  }
  else
  {
    switch ( sub_1002EB70(a1) )
    {
      case 0u:
        result = 0;
        break;
      case 1u:
        result = 1;
        break;
      case 2u:
        result = 2;
        break;
      case 3u:
        result = 3;
        break;
      default:
        v3 = WORD1(a1) >> 10;
        if ( (unsigned __int16)(WORD1(a1) >> 10) >= 0xBu && v3 < 0xDu
          || v3 >= 5u && v3 <= 8u && (unsigned __int16)(a1 - 1000) < (unsigned int)sub_10043F80(8u) )
        {
          v1 = (*(_DWORD *)((char *)&a1 + 2) >> 10) & 0x3F;
        }
        goto LABEL_13;
    }
  }
  return result;
}

//----- (1002ECF0) --------------------------------------------------------
double __cdecl sub_1002ECF0(unsigned int a1)
{
  int v1; // eax@2
  __int64 v3; // [sp-4h] [bp-28h]@0
  float v4; // [sp+4h] [bp-20h]@1
  char v5; // [sp+8h] [bp-1Ch]@2
  int v6; // [sp+12h] [bp-12h]@2

  v4 = 9.9999996e24;
  LODWORD(v3) = a1;
  if ( !sub_1002EC50(v3) )
  {
    v1 = sub_1002EC20(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(v1, 28, &v5);
    v4 = (double)((v6 & 0x7FFF) - 5000) * 0.3048000037670135;
  }
  return v4;
}
// 103334D8: using guessed type int dword_103334D8;

//----- (1002ED60) --------------------------------------------------------
char sub_1002ED60()
{
  char result; // al@1

  result = 0;
  byte_102573B5 = 0;
  byte_102573B6 = 0;
  byte_102573B4 = 0;
  return result;
}
// 102573B4: using guessed type char byte_102573B4;
// 102573B5: using guessed type char byte_102573B5;
// 102573B6: using guessed type char byte_102573B6;

//----- (1002ED80) --------------------------------------------------------
int __usercall sub_1002ED80@<eax>(int result@<eax>, char a2@<dl>, char a3@<cl>, char a4, char a5, char a6, char a7)
{
  *(_BYTE *)result = 2;
  *(_BYTE *)(result + 1) = a3;
  if ( a7 == 1 )
    *(_BYTE *)(result + 1) = a3 | 2;
  *(_BYTE *)(result + 2) = a5;
  *(_BYTE *)(result + 7) = a2;
  *(_BYTE *)(result + 8) = a6;
  *(_BYTE *)(result + 9) = a4;
  return result;
}

//----- (1002EDB0) --------------------------------------------------------
int sub_1002EDB0()
{
  int result; // eax@3
  unsigned int v1; // [sp+0h] [bp-4h]@1

  v1 = -1;
  if ( sub_10042DC0((char *)&v1) && v1 >= 0x12CFF780 )
    result = v1 - 315619200;
  else
    result = -1;
  return result;
}

//----- (1002EDE0) --------------------------------------------------------
char __usercall sub_1002EDE0@<al>(char a1@<bl>, char *a2@<edi>, int a3@<esi>, int a4, int a5, char a6, void *a7, size_t a8)
{
  unsigned int v8; // ebp@1
  unsigned int v9; // eax@1
  size_t v10; // eax@2
  size_t v11; // edx@2
  unsigned __int64 v12; // rtt@2
  size_t v14; // [sp+4h] [bp-Ch]@2
  char *v15; // [sp+8h] [bp-8h]@4
  char *v16; // [sp+8h] [bp-8h]@12
  int v17; // [sp+Ch] [bp-4h]@2
  size_t v18; // [sp+24h] [bp+14h]@2

  v8 = 2546 - a3;
  v9 = sub_1002EDB0();
  byte_102569C3 = BYTE3(v9);
  byte_102569C6 = v9;
  byte_102569C4 = v9 >> 16;
  byte_102569C5 = BYTE1(v9);
  if ( a8 <= 2546 - a3 )
  {
    *(__int16 *)((char *)&word_102569C0 + a3) = a8;
    sub_1002ED80((int)&word_102569C0, *a2, a6, a4, a5, a1, 0);
    memcpy((char *)&unk_102569C2 + a3, a7, a8);
    LOBYTE(v10) = sub_100424D0(&word_102569C0, *(unsigned __int16 *)((char *)&word_102569C0 + a3) + a3 + 2);
    ++*a2;
  }
  else
  {
    v12 = a8;
    v10 = a8 / v8;
    v11 = a8 % v8;
    v18 = 0;
    v17 = v12 % v8;
    v14 = v10;
    if ( v11 )
    {
      if ( v10 != -1 )
      {
        v16 = (char *)a7;
        while ( 1 )
        {
          if ( v18 == v10 )
          {
            *(__int16 *)((char *)&word_102569C0 + a3) = v11;
            sub_1002ED80((int)&word_102569C0, *a2, a6, a4, a5, a1, 0);
          }
          else
          {
            *(__int16 *)((char *)&word_102569C0 + a3) = v8;
            sub_1002ED80((int)&word_102569C0, *a2, a6, a4, a5, a1, 1);
          }
          memcpy((char *)&unk_102569C2 + a3, v16, *(unsigned __int16 *)((char *)&word_102569C0 + a3));
          sub_100424D0(&word_102569C0, *(unsigned __int16 *)((char *)&word_102569C0 + a3) + a3 + 2);
          ++*a2;
          v16 += v8;
          v10 = v18 + 1;
          v18 = v10;
          if ( v10 >= v14 + 1 )
            break;
          LOWORD(v11) = v17;
          v10 = v14;
        }
      }
    }
    else if ( v10 )
    {
      v15 = (char *)a7;
      while ( 1 )
      {
        *(__int16 *)((char *)&word_102569C0 + a3) = v8;
        if ( v18 == v10 - 1 )
          sub_1002ED80((int)&word_102569C0, *a2, a6, a4, a5, a1, 0);
        else
          sub_1002ED80((int)&word_102569C0, *a2, a6, a4, a5, a1, 1);
        memcpy((char *)&unk_102569C2 + a3, v15, *(unsigned __int16 *)((char *)&word_102569C0 + a3));
        sub_100424D0(&word_102569C0, *(unsigned __int16 *)((char *)&word_102569C0 + a3) + a3 + 2);
        ++*a2;
        v15 += v8;
        v10 = v18 + 1;
        v18 = v10;
        if ( v10 >= v14 )
          break;
        v10 = v14;
      }
    }
  }
  return v10;
}
// 102569C0: using guessed type __int16 word_102569C0;
// 102569C3: using guessed type char byte_102569C3;
// 102569C4: using guessed type char byte_102569C4;
// 102569C5: using guessed type char byte_102569C5;
// 102569C6: using guessed type char byte_102569C6;

//----- (1002F000) --------------------------------------------------------
char __cdecl sub_1002F000(int a1, char a2, char a3, int a4, void *a5, size_t a6)
{
  char result; // al@4

  if ( (a5 || !a6) && a4 )
  {
    memset(&word_102569C0, 0, 0x9F4u);
    dword_102569CA = *(_DWORD *)a4;
    dword_102569CE = *(_DWORD *)(a4 + 4);
    dword_102569D2 = *(_DWORD *)(a4 + 8);
    dword_102569D6 = *(_DWORD *)(a4 + 12);
    result = sub_1002EDE0(a3, &byte_102573B6, 26, a1, 2, a2, a5, a6);
  }
  else
  {
    result = sub_10042930("..\\lib\\atn\\atn_dlr.c", 187, 0, 0);
  }
  return result;
}
// 102569C0: using guessed type __int16 word_102569C0;
// 102569CA: using guessed type int dword_102569CA;
// 102569CE: using guessed type int dword_102569CE;
// 102569D2: using guessed type int dword_102569D2;
// 102569D6: using guessed type int dword_102569D6;
// 102573B6: using guessed type char byte_102573B6;

//----- (1002F090) --------------------------------------------------------
char __cdecl sub_1002F090(int a1, char a2, char a3, int a4, void *a5, size_t a6)
{
  char result; // al@4

  if ( (a5 || !a6) && a4 )
  {
    memset(&word_102569C0, 0, 0x9F4u);
    dword_102569CA = *(_DWORD *)a4;
    dword_102569CE = *(_DWORD *)(a4 + 4);
    dword_102569D2 = *(_DWORD *)(a4 + 8);
    dword_102569D6 = *(_DWORD *)(a4 + 12);
    dword_102569DA = *(_DWORD *)(a4 + 16);
    dword_102569DE = *(_DWORD *)(a4 + 20);
    result = sub_1002EDE0(a3, &byte_102573B5, 34, a1, 1, a2, a5, a6);
  }
  else
  {
    result = sub_10042930("..\\lib\\atn\\atn_dlr.c", 254, 0, 0);
  }
  return result;
}
// 102569C0: using guessed type __int16 word_102569C0;
// 102569CA: using guessed type int dword_102569CA;
// 102569CE: using guessed type int dword_102569CE;
// 102569D2: using guessed type int dword_102569D2;
// 102569D6: using guessed type int dword_102569D6;
// 102569DA: using guessed type int dword_102569DA;
// 102569DE: using guessed type int dword_102569DE;
// 102573B5: using guessed type char byte_102573B5;

//----- (1002F140) --------------------------------------------------------
signed int __cdecl sub_1002F140(int a1, int a2)
{
  signed int v2; // esi@3
  int v3; // eax@3
  int v4; // ecx@5
  signed int v5; // edi@5
  signed int result; // eax@10

  if ( *(_DWORD *)a1 != 38000 || (unsigned int)(a2 - 38000) >= *(_DWORD *)(a1 + 4) )
  {
    if ( a2 != -1 )
      sub_10042930("..\\lib\\atn\\atn_cpdlc_util.c", 471, 0, "tag is out of range");
    result = -1;
  }
  else
  {
    v2 = a2;
    v3 = sub_1002F710(a1, a2, 1);
    if ( v3 && *(_BYTE *)v3 )
    {
      v4 = *(_DWORD *)(v3 + 28);
      v5 = *(_DWORD *)(v3 + 32);
      if ( v4 != -1 )
      {
        while ( 1 )
        {
          if ( *(_DWORD *)(v3 + 32) != v5 )
          {
            sub_10042930("..\\lib\\atn\\atn_cpdlc_util.c", 497, 0, "encountered an invalid thread link");
            goto LABEL_14;
          }
          if ( v4 == a2 )
          {
            sub_10042930("..\\lib\\atn\\atn_cpdlc_util.c", 507, 0, "encountered a circular thread");
            goto LABEL_14;
          }
          v5 = v2;
          v2 = v4;
          v3 = sub_1002F710(a1, v4, 1);
          if ( !v3 )
            break;
          v4 = *(_DWORD *)(v3 + 28);
          if ( v4 == -1 )
            return v2;
        }
        sub_10042930("..\\lib\\atn\\atn_cpdlc_util.c", 521, 0, "thread has a link to an invalid tag");
LABEL_14:
        v2 = -1;
      }
      result = v2;
    }
    else
    {
      sub_10042930("..\\lib\\atn\\atn_cpdlc_util.c", 485, 0, "tag is not valid");
      result = -1;
    }
  }
  return result;
}

//----- (1002F240) --------------------------------------------------------
signed int __cdecl sub_1002F240(int a1, int a2)
{
  signed int v2; // esi@3
  int v3; // eax@3
  int v4; // ecx@5
  signed int v5; // edi@5
  signed int result; // eax@10

  if ( *(_DWORD *)a1 != 38000 || (unsigned int)(a2 - 38000) >= *(_DWORD *)(a1 + 4) )
  {
    sub_10042930("..\\lib\\atn\\atn_cpdlc_util.c", 566, 0, "tag is out of range");
    result = -1;
  }
  else
  {
    v2 = a2;
    v3 = sub_1002F710(a1, a2, 1);
    if ( v3 && *(_BYTE *)v3 )
    {
      v4 = *(_DWORD *)(v3 + 32);
      v5 = *(_DWORD *)(v3 + 28);
      if ( v4 != -1 )
      {
        while ( 1 )
        {
          if ( *(_DWORD *)(v3 + 28) != v5 )
          {
            sub_10042930("..\\lib\\atn\\atn_cpdlc_util.c", 592, 0, "encountered an invalid thread link");
            goto LABEL_14;
          }
          if ( v4 == a2 )
          {
            sub_10042930("..\\lib\\atn\\atn_cpdlc_util.c", 602, 0, "encountered a circular thread");
            goto LABEL_14;
          }
          v5 = v2;
          v2 = v4;
          v3 = sub_1002F710(a1, v4, 1);
          if ( !v3 )
            break;
          v4 = *(_DWORD *)(v3 + 32);
          if ( v4 == -1 )
            return v2;
        }
        sub_10042930("..\\lib\\atn\\atn_cpdlc_util.c", 616, 0, "thread has a link to an invalid tag");
LABEL_14:
        v2 = -1;
      }
      result = v2;
    }
    else
    {
      sub_10042930("..\\lib\\atn\\atn_cpdlc_util.c", 580, 0, "tag is not valid");
      result = -1;
    }
  }
  return result;
}

//----- (1002F340) --------------------------------------------------------
int __cdecl sub_1002F340(int a1, unsigned __int8 a2)
{
  unsigned __int8 v2; // al@1
  int v3; // ecx@3
  __int16 v4; // dx@3
  int result; // eax@3

  v2 = a2;
  if ( a2 >= 0x73u )
  {
    sub_10042930("..\\lib\\atn\\atn_cpdlc_util.c", 649, 0, "array index out of bounds");
    v2 = 0;
  }
  v3 = v2;
  v4 = *(__int16 *)((char *)&word_100E7440 + 3 * v2);
  result = a1;
  LOBYTE(v3) = byte_100E7442[3 * v3];
  *(_WORD *)a1 = v4;
  *(_BYTE *)(a1 + 2) = v3;
  return result;
}
// 100E7440: using guessed type __int16 word_100E7440;

//----- (1002F380) --------------------------------------------------------
int __cdecl sub_1002F380(int a1, unsigned __int8 a2)
{
  unsigned __int8 v2; // al@1
  int v3; // ecx@3
  __int16 v4; // dx@3
  int result; // eax@3

  v2 = a2;
  if ( a2 >= 0xEFu )
  {
    sub_10042930("..\\lib\\atn\\atn_cpdlc_util.c", 709, 0, "array index out of bounds");
    v2 = 0;
  }
  v3 = v2;
  v4 = *(__int16 *)((char *)&word_100E7170 + 3 * v2);
  result = a1;
  LOBYTE(v3) = byte_100E7172[3 * v3];
  *(_WORD *)a1 = v4;
  *(_BYTE *)(a1 + 2) = v3;
  return result;
}
// 100E7170: using guessed type __int16 word_100E7170;

//----- (1002F3C0) --------------------------------------------------------
char __cdecl sub_1002F3C0(int a1, int a2, char a3)
{
  int v3; // esi@2
  int v4; // eax@3
  char result; // al@4
  signed int v6; // edi@5
  char v7; // bl@7
  int v8; // eax@9

  if ( *(_DWORD *)a1 != 38000 || (v3 = a2, (unsigned int)(a2 - 38000) >= *(_DWORD *)(a1 + 4)) )
  {
    sub_10042930("..\\lib\\atn\\atn_cpdlc_util.c", 781, 0, "tag is out of range");
    result = 0;
  }
  else
  {
    v4 = sub_1002F710(a1, a2, 1);
    if ( v4 )
    {
      v6 = -1;
      if ( *(_DWORD *)(v4 + 32) == -1 )
      {
        v7 = 1;
        while ( v3 != -1 )
        {
          v8 = sub_1002F710(a1, v3, 1);
          if ( !v8 )
          {
            sub_10042930("..\\lib\\atn\\atn_cpdlc_util.c", 817, 0, "thread has a link to an invalid tag");
LABEL_18:
            v7 = 0;
            break;
          }
          if ( *(_DWORD *)(v8 + 32) != v6 )
          {
            sub_10042930("..\\lib\\atn\\atn_cpdlc_util.c", 826, 0, "encountered an invalid thread link");
            goto LABEL_18;
          }
          if ( *(_BYTE *)(v8 + 1) || a3 && !*(_BYTE *)(v8 + 11) && !*(_BYTE *)(v8 + 12) )
            goto LABEL_18;
          v6 = v3;
          v3 = *(_DWORD *)(v8 + 28);
        }
        result = v7;
      }
      else
      {
        sub_10042930("..\\lib\\atn\\atn_cpdlc_util.c", 796, 0, "tag is not the top of a thread");
        result = 0;
      }
    }
    else
    {
      sub_10042930("..\\lib\\atn\\atn_cpdlc_util.c", 791, 0, "tag is not valid");
      result = 0;
    }
  }
  return result;
}

//----- (1002F4D0) --------------------------------------------------------
int __cdecl sub_1002F4D0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( *(_BYTE *)a2 )
  {
    *(_BYTE *)(a1 + 5) = 1;
    *(_DWORD *)a1 = *(_DWORD *)a2;
    *(_BYTE *)(a1 + 4) = *(_BYTE *)(a2 + 4);
  }
  else
  {
    *(_BYTE *)(a1 + 5) = 0;
  }
  return result;
}

//----- (1002F500) --------------------------------------------------------
int __thiscall sub_1002F500(int this)
{
  int **v1; // eax@1
  int result; // eax@2
  int *v3; // eax@3
  int v4; // edx@3
  _DWORD *v5; // esi@3

  v1 = (int **)(this + 16);
  if ( (int **)*v1 == v1 )
  {
    result = -1;
  }
  else
  {
    v3 = *v1;
    --*(_DWORD *)(this + 24);
    v4 = *v3;
    v5 = (_DWORD *)v3[1];
    *(_DWORD *)(v4 + 4) = v5;
    *v5 = v4;
    *v3 = 0;
    v3[1] = 0;
    result = ((signed int)v3 - *(_DWORD *)(this + 52)) >> 3;
  }
  return result;
}

//----- (1002F540) --------------------------------------------------------
int __usercall sub_1002F540@<eax>(int a1@<edx>, int a2@<edi>, int a3@<esi>)
{
  int result; // eax@3

  if ( sub_1007C500(a2 + *(_DWORD *)a3, a1, *(_WORD *)(a3 + 8)) )
    sub_10042930("..\\lib\\acl\\kernel\\reg_usr_cache.c", 722, 0, 0);
  result = 12 * a2;
  *(_DWORD *)(*(_DWORD *)(a3 + 40) + result + 4) = 0;
  *(_WORD *)(*(_DWORD *)(a3 + 40) + result + 8) = 0;
  *(_BYTE *)(result + *(_DWORD *)(a3 + 40)) = 1;
  return result;
}

//----- (1002F5A0) --------------------------------------------------------
int __cdecl sub_1002F5A0(int a1)
{
  int v1; // ecx@0

  return *(_DWORD *)(v1 + 44) + a1 * *(_WORD *)(v1 + 8);
}

//----- (1002F5B0) --------------------------------------------------------
char __fastcall sub_1002F5B0(int a1, int a2)
{
  unsigned int v2; // eax@1
  char result; // al@2

  v2 = *(_DWORD *)(a1 + 12);
  if ( v2 < *(_WORD *)(a1 + 8) )
    result = *(_BYTE *)(v2 + a2);
  else
    result = 1;
  return result;
}

//----- (1002F5D0) --------------------------------------------------------
char __usercall sub_1002F5D0@<al>(int a1@<eax>, int a2@<ecx>, int a3)
{
  char result; // al@2

  if ( *(_BYTE *)(*(_DWORD *)(a2 + 40) + 12 * a1) )
    result = sub_1002F5B0(a2, a3);
  else
    result = 0;
  return result;
}

//----- (1002F5F0) --------------------------------------------------------
unsigned int __usercall sub_1002F5F0@<eax>(char a1@<dl>, int a2@<ecx>, int a3)
{
  unsigned int result; // eax@1

  result = *(_DWORD *)(a2 + 12);
  if ( result < *(_WORD *)(a2 + 8) )
    *(_BYTE *)(result + a3) = a1;
  return result;
}

//----- (1002F610) --------------------------------------------------------
int __usercall sub_1002F610@<eax>(int a1@<eax>, int a2@<edi>, int a3@<esi>)
{
  int result; // eax@2
  int *v4; // edx@4
  int v5; // ecx@7
  _DWORD *v6; // edx@7

  if ( sub_1002F5D0(a2, a3, a1) )
  {
    result = *(_DWORD *)(a3 + 52) + 8 * a2;
    if ( *(_DWORD *)(result + 4) || *(_DWORD *)result )
    {
      --*(_DWORD *)(a3 + 24);
      v5 = *(_DWORD *)result;
      v6 = *(_DWORD **)(result + 4);
      *(_DWORD *)(v5 + 4) = v6;
      *v6 = v5;
      *(_DWORD *)result = 0;
      *(_DWORD *)(result + 4) = 0;
    }
  }
  else
  {
    result = *(_DWORD *)(a3 + 52) + 8 * a2;
    if ( !*(_DWORD *)(result + 4) && !*(_DWORD *)result )
    {
      ++*(_DWORD *)(a3 + 24);
      v4 = *(int **)(a3 + 20);
      *(_DWORD *)(a3 + 20) = result;
      *(_DWORD *)result = a3 + 16;
      *(_DWORD *)(result + 4) = v4;
      *v4 = result;
    }
  }
  return result;
}

//----- (1002F680) --------------------------------------------------------
int __cdecl sub_1002F680(int a1, _DWORD *a2)
{
  unsigned int v2; // eax@3
  int v3; // ecx@3
  int result; // eax@4
  int v5; // esi@7
  int v6; // ecx@7

  if ( a2 )
    *a2 = -1;
  v2 = sub_1002F500(a1);
  if ( v2 < *(_DWORD *)(v3 + 4) )
  {
    if ( a2 )
      *a2 = v2 + *(_DWORD *)v3;
    v5 = sub_1002F5A0(v2);
    sub_1002F5F0(1, v6, v5);
    result = v5;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002F6D0) --------------------------------------------------------
char __cdecl sub_1002F6D0(int a1, int a2)
{
  unsigned int v2; // edi@1
  char result; // al@2
  int v4; // eax@3
  int v5; // ecx@3

  v2 = a2 - *(_DWORD *)a1;
  if ( v2 < *(_DWORD *)(a1 + 4) )
  {
    v4 = sub_1002F5A0(v2);
    result = sub_1002F540(v4, v2, v5);
  }
  else
  {
    result = sub_10042930("..\\lib\\acl\\kernel\\reg_usr_cache.c", 230, 0, 0);
  }
  return result;
}

//----- (1002F710) --------------------------------------------------------
int __cdecl sub_1002F710(int a1, int a2, char a3)
{
  unsigned int v3; // edx@1
  int result; // eax@2
  int v5; // eax@3
  int v6; // edx@3
  int v7; // ecx@3
  int v8; // esi@3

  v3 = a2 - *(_DWORD *)a1;
  if ( v3 < *(_DWORD *)(a1 + 4) )
  {
    v5 = sub_1002F5A0(v3);
    v8 = v5;
    if ( !a3 || sub_1002F5D0(v6, v7, v5) )
      result = v8;
    else
      result = 0;
  }
  else
  {
    sub_10042930("..\\lib\\acl\\kernel\\reg_usr_cache.c", 289, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1002F770) --------------------------------------------------------
int __cdecl sub_1002F770(int a1, int a2, int a3, unsigned int a4, int a5, int a6, int a7)
{
  _DWORD *v7; // eax@1
  unsigned int v8; // ebx@1
  int v9; // esi@1
  int v10; // eax@1
  unsigned __int16 v11; // ax@1
  int v12; // eax@1
  int v13; // edx@1
  unsigned int v14; // edi@1
  void *v15; // ebp@3
  char v17; // [sp+10h] [bp-Ch]@1
  int v18; // [sp+2Ch] [bp+10h]@2

  sub_10042D90((int)&v17, a1, a2);
  v7 = (_DWORD *)sub_10042D40((int)&v17, 56);
  v8 = a4;
  v9 = (int)v7;
  v7 += 4;
  *(_DWORD *)(v9 + 12) = a5;
  *v7 = v7;
  *(_DWORD *)(v9 + 20) = v7;
  *(_DWORD *)v9 = a3;
  *(_DWORD *)(v9 + 4) = a4;
  *(_DWORD *)(v9 + 24) = 0;
  *(_DWORD *)(v9 + 28) = a6;
  *(_DWORD *)(v9 + 32) = a7;
  *(_DWORD *)(v9 + 36) = sub_10042D40((int)&v17, 12 * a4);
  v10 = sub_10042D40((int)&v17, 12 * a4);
  *(_DWORD *)(v9 + 40) = v10;
  j_reg_get_tag_hdr(v10, a3, a4 + a3 - 1);
  v11 = *(_WORD *)(*(_DWORD *)(v9 + 40) + 10);
  *(_WORD *)(v9 + 8) = v11;
  v12 = sub_10042D40((int)&v17, a4 * v11);
  v13 = *(_WORD *)(v9 + 8);
  *(_DWORD *)(v9 + 44) = v12;
  *(_DWORD *)(v9 + 48) = sub_10042D40((int)&v17, v13);
  v14 = 0;
  *(_DWORD *)(v9 + 52) = sub_10042D40((int)&v17, 8 * a4);
  if ( a4 )
  {
    v18 = 0;
    do
    {
      v15 = (void *)sub_1002F5A0(v14);
      if ( sub_1007C3B0(v14 + a3, (int)v15, *(_WORD *)(v9 + 8)) )
      {
        *(_WORD *)(*(_DWORD *)(v9 + 40) + v18 + 8) = 0;
        *(_DWORD *)(*(_DWORD *)(v9 + 40) + v18 + 4) = 0;
        memset(v15, 0, *(_WORD *)(v9 + 8));
      }
      sub_1002F610((int)v15, v14, v9);
      v18 += 12;
      ++v14;
    }
    while ( v14 < v8 );
  }
  return v9;
}
// 1007C390: using guessed type int __cdecl j_reg_get_tag_hdr(_DWORD, _DWORD, _DWORD);

//----- (1002F8C0) --------------------------------------------------------
char __cdecl sub_1002F8C0(int a1, int a2)
{
  unsigned int v2; // edi@1
  int v3; // ebx@3
  int v4; // ecx@3
  char result; // al@3

  v2 = a2 - *(_DWORD *)a1;
  if ( v2 >= *(_DWORD *)(a1 + 4) || *(_DWORD *)(a1 + 12) >= (unsigned int)*(_WORD *)(a1 + 8) )
  {
    result = sub_10042930("..\\lib\\acl\\kernel\\reg_usr_cache.c", 463, 0, 0);
  }
  else
  {
    v3 = sub_1002F5A0(v2);
    sub_1002F5F0(0, v4, v3);
    sub_1002F540(v3, v2, a1);
    result = sub_1002F610(v3, v2, a1);
  }
  return result;
}

//----- (1002F920) --------------------------------------------------------
unsigned int __cdecl sub_1002F920(int a1, int a2, void *a3)
{
  unsigned int v3; // edi@2
  void *v5; // ebx@6

  if ( a2 == -1 )
  {
    v3 = sub_1002F500(a1);
    if ( v3 >= *(_DWORD *)(a1 + 4) )
      return -1;
  }
  else
  {
    v3 = a2 - *(_DWORD *)a1;
    if ( v3 >= *(_DWORD *)(a1 + 4) )
    {
      sub_10042930("..\\lib\\acl\\kernel\\reg_usr_cache.c", 614, 0, 0);
      return -1;
    }
  }
  v5 = (void *)sub_1002F5A0(v3);
  memcpy_0(v5, a3, *(_WORD *)(a1 + 8));
  sub_1002F5F0(1, a1, (int)v5);
  sub_1002F540((int)v5, v3, a1);
  return v3 + *(_DWORD *)a1;
}

//----- (1002F9A0) --------------------------------------------------------
char __usercall sub_1002F9A0@<al>(int a1@<eax>, int a2@<ebx>, int a3, int a4)
{
  int v4; // esi@1
  char result; // al@2
  unsigned int v6; // eax@3
  _DWORD *v7; // ecx@3
  _DWORD *v8; // edx@3
  int v9; // ebp@7
  int v10; // eax@8
  _BYTE *v11; // ecx@8
  _BYTE *v12; // edx@8
  int v13; // eax@10
  _BYTE *v14; // ecx@10
  _BYTE *v15; // edx@10
  _BYTE *v16; // ecx@12
  _BYTE *v17; // edx@12
  signed int v18; // eax@14
  int (__cdecl *v19)(_DWORD, int); // ebp@18
  int v20; // [sp+8h] [bp-4h]@1

  v4 = a1;
  v20 = a3 + *(_DWORD *)a1;
  if ( sub_1007C3B0(v20, a2, *(_WORD *)(a1 + 8)) )
  {
    sub_10042930("..\\lib\\acl\\kernel\\reg_usr_cache.c", 886, 0, "REG_cache_sync: REG_read fail");
    return 0;
  }
  v6 = *(_WORD *)(v4 + 8);
  v7 = *(_DWORD **)(v4 + 48);
  v8 = (_DWORD *)a2;
  if ( v6 < 4 )
  {
LABEL_6:
    if ( !v6 )
      goto LABEL_16;
  }
  else
  {
    while ( *v8 == *v7 )
    {
      v6 -= 4;
      ++v7;
      ++v8;
      if ( v6 < 4 )
        goto LABEL_6;
    }
  }
  v9 = *(_BYTE *)v8 - *(_BYTE *)v7;
  if ( *(_BYTE *)v8 != *(_BYTE *)v7
    || (v10 = v6 - 1, v11 = (char *)v7 + 1, v12 = (char *)v8 + 1, v10)
    && ((v9 = *v12 - *v11, *v12 != *v11)
     || (v13 = v10 - 1, v14 = v11 + 1, v15 = v12 + 1, v13)
     && ((v9 = *v15 - *v14, *v15 != *v14) || (v16 = v14 + 1, v17 = v15 + 1, v13 != 1)
                                          && (v9 = *v17 - *v16, *v17 != *v16))) )
  {
    v18 = 1;
    if ( v9 <= 0 )
      v18 = -1;
    goto LABEL_17;
  }
LABEL_16:
  v18 = 0;
LABEL_17:
  if ( v18 && (sub_1002F610(a2, a3, v4), (v19 = *(int (__cdecl **)(_DWORD, int))(v4 + 32)) != 0) )
  {
    if ( *(_BYTE *)(12 * a3 + *(_DWORD *)(v4 + 40)) )
      sub_1002F5B0(v4, a2);
    if ( *(_BYTE *)(12 * a3 + *(_DWORD *)(v4 + 36)) )
      sub_1002F5B0(v4, a4);
    result = v19(*(_DWORD *)(v4 + 28), v20);
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1002FB00) --------------------------------------------------------
char __cdecl sub_1002FB00(int a1)
{
  int v1; // eax@1
  int v2; // ecx@1
  unsigned int v3; // edi@3
  int v4; // ebp@4
  int v5; // ecx@5
  const void *v6; // ebx@7
  int v7; // eax@8
  int v8; // edx@8
  int v9; // eax@8
  int v10; // ecx@8

  memcpy(*(void **)(a1 + 36), *(const void **)(a1 + 40), 12 * *(_DWORD *)(a1 + 4));
  v1 = j_reg_get_tag_hdr(*(_DWORD *)(a1 + 40), *(_DWORD *)a1, *(_DWORD *)a1 + *(_DWORD *)(a1 + 4) - 1);
  v2 = *(_DWORD *)(a1 + 4);
  if ( v2 == v1 )
  {
    v3 = 0;
    if ( v2 )
    {
      v4 = 0;
      do
      {
        v1 = *(_DWORD *)(a1 + 40) + v4;
        v5 = *(_DWORD *)(a1 + 36) + v4;
        if ( *(_DWORD *)(v5 + 4) != *(_DWORD *)(v1 + 4) || *(_WORD *)(v5 + 8) != *(_WORD *)(v1 + 8) )
        {
          v6 = (const void *)sub_1002F5A0(v3);
          memcpy(*(void **)(a1 + 48), v6, *(_WORD *)(a1 + 8));
          LOBYTE(v1) = sub_1002F9A0(a1, (int)v6, v3, *(_DWORD *)(a1 + 48));
          if ( !(_BYTE)v1 )
          {
            v7 = *(_DWORD *)(a1 + 36);
            v8 = *(_DWORD *)(v7 + v4);
            v9 = v4 + v7;
            v10 = v4 + *(_DWORD *)(a1 + 40);
            *(_DWORD *)v10 = v8;
            *(_DWORD *)(v10 + 4) = *(_DWORD *)(v9 + 4);
            *(_DWORD *)(v10 + 8) = *(_DWORD *)(v9 + 8);
            memcpy((void *)v6, *(const void **)(a1 + 48), *(_WORD *)(a1 + 8));
            LOBYTE(v1) = sub_1002F610((int)v6, v3, a1);
          }
        }
        ++v3;
        v4 += 12;
      }
      while ( v3 < *(_DWORD *)(a1 + 4) );
    }
  }
  else
  {
    sub_10042930("..\\lib\\acl\\kernel\\reg_usr_cache.c", 522, 0, 0);
    LOBYTE(v1) = (unsigned int)memcpy(*(void **)(a1 + 40), *(const void **)(a1 + 36), 12 * *(_DWORD *)(a1 + 4));
  }
  return v1;
}
// 1007C390: using guessed type int __cdecl j_reg_get_tag_hdr(_DWORD, _DWORD, _DWORD);

//----- (1002FC20) --------------------------------------------------------
BOOL __cdecl sub_1002FC20(signed int a1)
{
  return (unsigned __int8)sub_10039A80(a1) != 0;
}

//----- (1002FC40) --------------------------------------------------------
char __usercall sub_1002FC40@<al>(int a1@<edi>, unsigned int a2@<esi>, char a3)
{
  __int64 v3; // ST14_8@1
  char v4; // ST30_1@1
  bool v5; // ST38_1@1
  float v6; // ST34_4@1
  float v7; // ST3C_4@1
  int v9; // [sp+20h] [bp-28h]@1
  char v10; // [sp+28h] [bp-20h]@1
  int v11; // [sp+38h] [bp-10h]@1

  sub_1002E9E0(0, a2, (double *)&v10);
  sub_1007BCF0((int)&v10, (int)&v9);
  LODWORD(v3) = a2;
  v4 = sub_10037F30(a2);
  v5 = sub_10037F00(v3) == 0;
  v6 = sub_10037F60(*(float *)&a2);
  sub_1002EB10(a2, (char *)&v11);
  v7 = sub_1002ECF0(a2);
  sub_1002CD10((void *)(a1 + 232));
  return sub_1002C750(a2, a3, (int)&v9, v4, v5, v7, v6, (int)&v11, a1);
}

//----- (1002FD00) --------------------------------------------------------
char __usercall sub_1002FD00@<al>(char a1@<bl>, int a2@<edi>)
{
  signed int v2; // esi@1
  signed int v3; // eax@1
  unsigned __int8 v5; // [sp+0h] [bp-10h]@0
  char v6; // [sp+Bh] [bp-5h]@1
  char v7; // [sp+Ch] [bp-4h]@2

  v6 = sub_10035530(v5);
  v2 = sub_100355D0(a1);
  LOBYTE(v3) = v6;
  if ( v6 )
  {
    v7 = v6 - 1;
    LOBYTE(v3) = sub_10034A30(a1, v6 - 1);
    if ( v3 & 4 )
    {
      v3 = sub_10035570(a1, v7);
      if ( v3 == v2 )
      {
        if ( a1
          || (LOBYTE(v3) = (*(_BYTE *)(a2 + 3) >> 4) & 3, !(_BYTE)v3)
          || (_BYTE)v3 == 3
          || *(_DWORD *)(a2 + 7480) != v2 )
        {
          LOBYTE(v3) = sub_1003AB90(a1, v7);
        }
      }
    }
  }
  return v3;
}

//----- (1002FD80) --------------------------------------------------------
char sub_1002FD80()
{
  int v0; // esi@1
  int v1; // ecx@1
  char v2; // bl@1
  void *v3; // ecx@1
  int v4; // ecx@1
  char result; // al@3
  char *v6; // esi@4
  int v7; // edi@5
  char v8; // cl@6
  char v9; // [sp+Bh] [bp-9h]@1
  unsigned __int8 v10; // [sp+Ch] [bp-8h]@1
  int v11; // [sp+10h] [bp-4h]@3

  v0 = sub_100354F0(0);
  v10 = sub_10034B00(0);
  v2 = sub_1003F480(v1);
  v9 = 3;
  if ( sub_100460A0(v3) & 2 )
    v9 = sub_1003F4C0(v4);
  result = sub_100347C0(v0, v10, &v11);
  if ( !result )
  {
    v6 = (char *)&unk_100E7B61;
    do
    {
      v7 = sub_1004AEF0((unsigned __int8)*v6, 1);
      result = v11;
      if ( v7 != v11 )
      {
        v8 = *(v6 - 1);
        if ( v2 == v8 || v9 == v8 )
        {
          result = sub_1004B0B0(*v6, 0, v11);
        }
        else
        {
          sub_1004B0B0(*v6, 1, v11);
          result = sub_1004B0B0(*v6, 0, v7);
        }
      }
      v6 += 2;
    }
    while ( (signed int)v6 < (signed int)&flt_100E7B64 + 1 );
  }
  return result;
}
// 100E7B64: using guessed type float flt_100E7B64;

//----- (1002FE40) --------------------------------------------------------
char __usercall sub_1002FE40@<al>(int a1@<eax>)
{
  char v1; // cl@1
  char v2; // dl@1

  v1 = *(_BYTE *)(a1 + 3) & 0xD7 | 0x10;
  v2 = *(_BYTE *)(a1 + 4) & 0xD7 | 0x10;
  *(_BYTE *)a1 = -1;
  *(_BYTE *)(a1 + 1) = 0;
  *(_BYTE *)(a1 + 3) = v1;
  *(_BYTE *)(a1 + 4) = v2;
  return sub_1002C5D0(a1, 0xFFu);
}

//----- (1002FE70) --------------------------------------------------------
char __usercall sub_1002FE70@<al>(int a1@<esi>, char *a2)
{
  char v2; // cl@1
  char result; // al@1
  char v4; // dl@4
  char v5; // [sp+7h] [bp-1h]@1

  sub_1007C4B0(6947, (int)&v5, 1);
  v2 = *(_BYTE *)(a1 + 3);
  result = (*(_BYTE *)(a1 + 3) >> 4) & 3;
  if ( result == 2 )
    goto LABEL_12;
  if ( !v5 )
    goto LABEL_13;
  if ( result != 1 )
    return result;
  v4 = *a2;
  if ( *a2 == 3 || v4 == 6 || v4 == 17 )
  {
LABEL_12:
    *(_WORD *)(a1 + 232) |= 0x10u;
    *(_BYTE *)(a1 + 4) &= 0xFDu;
    *(float *)(a1 + 240) = 6.283185;
    *(float *)(a1 + 7356) = 9.9999996e24;
    *(float *)(a1 + 7364) = 0.0;
    *(_BYTE *)(a1 + 3) = v2 | 0x30;
    *(_BYTE *)a1 = -1;
    *(float *)(a1 + 7360) = 6.283185;
    *(_BYTE *)(a1 + 1) = 0;
    *(_BYTE *)(a1 + 7433) = 1;
    *(_BYTE *)(a1 + 7352) = 0;
    *(float *)(a1 + 7368) = 9.9999996e24;
    *(_BYTE *)(a1 + 7353) = 0;
    *(_BYTE *)(a1 + 7354) = 0;
    *(_BYTE *)(a1 + 7306) = 1;
    result = sub_1002C5D0(a1, 0xFFu);
  }
  else
  {
LABEL_13:
    if ( result == 1 )
      result = sub_1002FE40(a1);
  }
  return result;
}

//----- (1002FF40) --------------------------------------------------------
char __cdecl sub_1002FF40(char a1)
{
  int v1; // ecx@0
  char result; // al@1

  result = *(_BYTE *)(v1 + 2);
  *(_BYTE *)v1 += a1;
  if ( result != -1 )
  {
    result += a1;
    *(_BYTE *)(v1 + 2) = result;
  }
  return result;
}

//----- (1002FF60) --------------------------------------------------------
char __cdecl sub_1002FF60(char a1, unsigned __int8 a2, int a3, char a4)
{
  char v4; // al@3
  char v6; // [sp+7h] [bp-3Dh]@1
  char v7; // [sp+8h] [bp-3Ch]@1

  sub_10039B40();
  sub_1002D210(&byte_10333D80);
  sub_10034BD0(0, byte_10333D80, &v7);
  v6 = sub_1003ADC0(a1, a2, a3, a4);
  if ( !v6 && !a1 )
  {
    v4 = ((unsigned __int8)byte_10333D83 >> 4) & 3;
    if ( (v4 == 2 || v4 == 1) && (unsigned __int8)byte_10333D80 >= a2 )
    {
      if ( v4 != 1 || byte_10333D80 != a2 || byte_10333D82 == -1 )
      {
        sub_1002CE60((int)&byte_10333D80, a2, byte_10333D80, 1);
        sub_1002FF40(1);
      }
      else
      {
        sub_1002CE60((int)&byte_10333D80, a2, 0xFFu, 0);
        sub_1002FE70((int)&byte_10333D80, &v7);
      }
    }
    sub_100360B0((int)&byte_10333D80);
    ++byte_10333D85;
    sub_10039B70(&byte_10333D80);
  }
  sub_10039B30();
  return v6;
}
// 10333D80: using guessed type char byte_10333D80;
// 10333D82: using guessed type char byte_10333D82;
// 10333D83: using guessed type char byte_10333D83;
// 10333D85: using guessed type char byte_10333D85;

//----- (10030060) --------------------------------------------------------
char __cdecl sub_10030060(char a1, int a2, char a3, char a4, char a5, int a6, char a7, char a8)
{
  char v8; // bl@1
  char v9; // al@14
  char v10; // si@17
  char v12; // [sp+Bh] [bp-41h]@3
  char v13; // [sp+Ch] [bp-40h]@1
  char v14; // [sp+Dh] [bp-3Fh]@1
  unsigned __int8 v15; // [sp+Eh] [bp-3Eh]@1
  char v16; // [sp+Fh] [bp-3Dh]@8
  char v17; // [sp+10h] [bp-3Ch]@1
  char v18; // [sp+50h] [bp+4h]@6

  v13 = 0;
  sub_10039B40();
  sub_1002D210(&byte_10333D80);
  sub_10034BD0(0, byte_10333D80, &v17);
  v8 = a1;
  v14 = sub_10035530(a1);
  v15 = 0;
  sub_1003ABD0(a1);
  if ( !a1 )
    v15 = v14 - sub_10035530(0);
  v12 = 0;
  if ( sub_10035530(a1) == 1 && sub_10034B50(a1) == a2 || a2 == sub_10034C50(a1) )
  {
    v18 = 0;
  }
  else
  {
    v18 = 1;
    v12 = sub_1003AC10(v8, 0, a2, 0);
  }
  v16 = sub_1003ACC0(v8, a2, a3, a4, a5, a6, a7, a8);
  if ( !v16 && v12 )
    v16 = v12;
  if ( !v8 )
  {
    sub_10039B20(&v13);
    if ( v18 || v13 )
    {
      sub_1002CE60((int)&byte_10333D80, 0, 0xFFu, 0);
      sub_1002FE40((int)&byte_10333D80);
    }
    else
    {
      v9 = ((unsigned __int8)byte_10333D83 >> 4) & 3;
      if ( v9 == 2 || v9 == 1 )
      {
        v10 = sub_10035530(0) - v14;
        if ( (unsigned __int8)byte_10333D80 <= v15 || (unsigned __int8)byte_10333D82 <= v15 )
        {
          sub_1002CE60((int)&byte_10333D80, 0, 0xFFu, 0);
          sub_1002FE70((int)&byte_10333D80, &v17);
        }
        else
        {
          sub_1002CE60((int)&byte_10333D80, 0, byte_10333D80, v10);
          sub_1002FF40(v10);
        }
      }
      else
      {
        sub_1002CE60((int)&byte_10333D80, 0, 0xFFu, 0);
      }
    }
    sub_100360B0((int)&byte_10333D80);
    ++byte_10333D85;
    sub_10039B70(&byte_10333D80);
  }
  sub_10039B30();
  return v16;
}
// 10039B20: using guessed type _DWORD __cdecl sub_10039B20(_DWORD);
// 10333D80: using guessed type char byte_10333D80;
// 10333D82: using guessed type char byte_10333D82;
// 10333D83: using guessed type char byte_10333D83;
// 10333D85: using guessed type char byte_10333D85;

//----- (10030260) --------------------------------------------------------
char __cdecl sub_10030260(unsigned __int8 a1, int a2, char a3, char a4, char a5, char a6, char a7)
{
  unsigned __int8 v7; // bl@1
  char v8; // al@2
  char v9; // si@5
  char v11; // [sp+3h] [bp-45h]@1
  unsigned __int8 v12; // [sp+4h] [bp-44h]@1
  unsigned __int8 v13; // [sp+8h] [bp-40h]@1
  char v14; // [sp+Ch] [bp-3Ch]@1
  char v15; // [sp+4Ch] [bp+4h]@1

  sub_10039B40();
  sub_1002D210(&byte_10333D80);
  sub_10034BD0(0, byte_10333D80, &v14);
  v7 = a1;
  v15 = sub_10035530(a1);
  v13 = sub_100356D0(v7);
  sub_1003ABF0(v7);
  v11 = sub_1003AD40(v7, a2, a3, a4, a5, a6, a7);
  v12 = sub_10035710(v7);
  if ( !v7 )
  {
    v8 = ((unsigned __int8)byte_10333D83 >> 4) & 3;
    if ( v8 == 2 || v8 == 1 )
    {
      v9 = sub_10035530(0) - v15;
      if ( (unsigned __int8)byte_10333D80 <= v13 )
      {
        if ( (unsigned __int8)byte_10333D80 >= v12 )
        {
          sub_1002CE60((int)&byte_10333D80, v12, 0xFFu, 0);
          sub_1002FE70((int)&byte_10333D80, &v14);
        }
      }
      else
      {
        sub_1002CE60((int)&byte_10333D80, v13, byte_10333D80, v9);
        sub_1002FF40(v9);
      }
    }
    else
    {
      sub_1002CE60((int)&byte_10333D80, v12, 0xFFu, 0);
    }
    sub_100360B0((int)&byte_10333D80);
    ++byte_10333D85;
    sub_10039B70(&byte_10333D80);
  }
  sub_10039B30();
  return v11;
}
// 10333D80: using guessed type char byte_10333D80;
// 10333D83: using guessed type char byte_10333D83;
// 10333D85: using guessed type char byte_10333D85;

//----- (100303B0) --------------------------------------------------------
void __usercall sub_100303B0(int a1@<eax>, int a2@<esi>, char a3)
{
  int v3; // edi@1
  unsigned __int8 v4; // al@2
  char v5; // cl@2
  unsigned __int8 v6; // al@3
  signed int v7; // eax@3
  unsigned int v8; // esi@3
  __int64 v9; // [sp-8h] [bp-Ch]@3

  v3 = a1;
  sub_1002FE40((int)&byte_10333D80);
  *(_BYTE *)(v3 + 4) = *(_BYTE *)(v3 + 4) & 0xFD | 4;
  if ( a3 == -1 )
  {
    v4 = sub_10035150(0);
    v5 = *(_BYTE *)(v3 + 3) & 0xDF | 0x90;
    *(_BYTE *)v3 = v4;
    *(_BYTE *)(v3 + 3) = v5;
    sub_10035890((_BYTE *)(v3 + 284), v4);
  }
  else
  {
    HIDWORD(v9) = a2;
    v6 = sub_100356D0(0);
    *(_BYTE *)v3 = v6;
    sub_10035890((_BYTE *)(v3 + 284), v6);
    v7 = sub_10035570(0, *(_BYTE *)v3);
    v8 = v7;
    if ( v7 == 0x3FFFF || (LODWORD(v9) = v7, sub_10037F00(v9) == 11) )
      *(_BYTE *)(v3 + 3) = *(_BYTE *)(v3 + 3) & 0xDF | 0x10;
    else
      sub_1002FC40(v3, v8, *(_BYTE *)v3);
  }
}
// 100303B0: could not find valid save-restore pair for esi
// 10333D80: using guessed type char byte_10333D80;

//----- (10030450) --------------------------------------------------------
char __usercall sub_10030450@<al>(int a1@<esi>, int a2, int a3, int a4, int a5, char a6, char a7, float a8)
{
  char v8; // al@1
  unsigned __int8 v9; // bl@6
  char v10; // al@8
  char v11; // al@8
  int v12; // ebx@8
  unsigned __int8 v13; // al@11
  float v14; // ST1C_4@14
  char v15; // si@14
  char v17; // [sp+Fh] [bp-45h]@1
  char i; // [sp+10h] [bp-44h]@6
  unsigned __int8 v19; // [sp+14h] [bp-40h]@1
  char v20; // [sp+18h] [bp-3Ch]@14
  char v21; // [sp+1Fh] [bp-35h]@14
  float v22; // [sp+24h] [bp-30h]@14
  float v23; // [sp+28h] [bp-2Ch]@14
  char v24; // [sp+58h] [bp+4h]@12

  sub_10039B40();
  sub_1002D210(&byte_10333D80);
  v19 = sub_100356D0(a2);
  v17 = sub_10035530(a2);
  v8 = sub_10035750(a2);
  if ( a6
    || (_BYTE)a2
    || (byte_10333D83 & 0x30) == 48
    || (unsigned __int8)byte_10333D80 < (unsigned __int8)v8
    || byte_10333D80 == -1 )
  {
    sub_1003ABB0(a2);
    sub_1002FD00(a2, (int)&byte_10333D80);
    v12 = a2;
    if ( !(_BYTE)a2 && (unsigned __int8)byte_10333D80 >= v19 )
    {
      v13 = sub_10035530(0);
      sub_1002CE60((int)&byte_10333D80, v13, 0xFFu, 0);
    }
  }
  else
  {
    v9 = v8;
    for ( i = v8; v9 < (unsigned __int8)v17; i = v9 )
    {
      sub_1003AE10(0, i);
      ++v9;
    }
    sub_1003ABB0(0);
    sub_1002FD00(0, (int)&byte_10333D80);
    v10 = sub_10035530(0);
    sub_1002CE60((int)&byte_10333D80, v19, byte_10333D80, v10 - v17);
    v11 = sub_10035530(0);
    sub_1002FF40(v11 - v17);
    v12 = a2;
  }
  v24 = sub_1003AC60(v12, a3, a4, a5, a8);
  if ( !(_BYTE)v12 )
  {
    if ( a7 )
    {
      v14 = *(float *)&a1;
      v15 = sub_100356D0(0);
      sub_10034BD0(0, v15, &v20);
      v22 = 9.9999996e24;
      v23 = 9.9999996e24;
      v21 = 4;
      sub_1003AE50(0, v15, &v20);
      a1 = LODWORD(v14);
    }
    sub_1002FD80();
    sub_100360B0((int)&byte_10333D80);
    if ( a6 )
      sub_100303B0((int)&byte_10333D80, a1, a5);
    ++byte_10333D85;
    sub_10039B70(&byte_10333D80);
  }
  sub_10039B30();
  return v24;
}
// 10333D80: using guessed type char byte_10333D80;
// 10333D83: using guessed type char byte_10333D83;
// 10333D85: using guessed type char byte_10333D85;

//----- (10030640) --------------------------------------------------------
char *__cdecl sub_10030640(char a1, char *a2)
{
  char *result; // eax@3

  if ( a1 == -1 || a1 >= (unsigned int)sub_10043F80(0x40u) )
  {
    result = a2;
    *(_DWORD *)a2 = 1313558101;
    *((_DWORD *)a2 + 1) = 5134159;
  }
  else
  {
    strncpy(a2, (const char *)(dword_10333D50 + 25 * a1), 8u);
    a2[8] = 0;
    result = (char *)sub_100423E0((int)a2, 0);
  }
  return result;
}
// 10333D50: using guessed type int dword_10333D50;

//----- (100306A0) --------------------------------------------------------
char __usercall sub_100306A0@<al>(_BYTE *a1@<edi>, _BYTE *a2@<esi>, int a3, char a4, _BYTE *a5)
{
  _BYTE *v5; // ebp@1
  char v6; // bl@2
  char v7; // al@3
  char result; // al@12
  char v9; // [sp+8h] [bp-40h]@2
  char v10; // [sp+Ch] [bp-3Ch]@3

  v5 = a5;
  *a5 = -1;
  LOBYTE(a5) = -1;
  do
  {
    (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(a3, 3, &v9);
    a3 += (unsigned __int16)word_10333C4C;
    ++*v5;
    *a2 = -1;
    v6 = 1;
    while ( 1 )
    {
      ++*a2;
      v7 = sub_10032B70((int)&a3, (int)a1, &v10);
      if ( *a1 == 1 || v9 & 1 && v6 )
        LOBYTE(a5) = (_BYTE)a5 + 1;
      v6 = 0;
      if ( !v7 )
        break;
      if ( (char)a5 >= a4 )
        goto LABEL_12;
    }
  }
  while ( (char)a5 < a4 && v9 & 1 );
LABEL_12:
  result = a4;
  if ( (_BYTE)a5 != a4 )
  {
    *v5 = -1;
    *a2 = -1;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C4C: using guessed type __int16 word_10333C4C;

//----- (10030750) --------------------------------------------------------
signed int __cdecl sub_10030750(signed int a1, char a2)
{
  char v2; // bl@1
  signed int result; // eax@4
  char v4; // [sp+Bh] [bp-5h]@3
  char v5; // [sp+Ch] [bp-4h]@2

  v2 = 0;
  if ( a2 <= 0 )
  {
LABEL_4:
    result = a1;
    if ( a1 != 0xFFFFFF )
      return result;
  }
  else
  {
    while ( 1 )
    {
      (*(void (__cdecl **)(signed int, signed int, char *))dword_103334D8)(a1, 3, &v5);
      if ( !(v5 & 1) )
        break;
      a1 += (unsigned __int16)word_10333C4C;
      ++v2;
      sub_100332D0((int)&a1, &v4);
      if ( v2 >= a2 )
        goto LABEL_4;
    }
  }
  return 0xFFFFFF;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C4C: using guessed type __int16 word_10333C4C;

//----- (100307C0) --------------------------------------------------------
int __usercall sub_100307C0@<eax>(unsigned __int16 a1@<di>, signed int a2, signed int a3, unsigned __int8 a4)
{
  int v4; // esi@2
  unsigned __int8 v5; // dl@4
  int v6; // eax@5
  char v7; // bl@7
  bool v8; // zf@16
  int v10; // eax@47
  unsigned __int8 v11; // [sp+Fh] [bp-2Dh]@1
  char v12; // [sp+10h] [bp-2Ch]@1
  char v13; // [sp+11h] [bp-2Bh]@1
  int v14; // [sp+14h] [bp-28h]@2
  char v15; // [sp+18h] [bp-24h]@1
  char v16; // [sp+19h] [bp-23h]@1
  char v17; // [sp+1Dh] [bp-1Fh]@7
  char v18; // [sp+20h] [bp-1Ch]@13
  char v19; // [sp+24h] [bp-18h]@13
  int v20; // [sp+28h] [bp-14h]@1
  int v21; // [sp+2Ch] [bp-10h]@1
  int v22; // [sp+30h] [bp-Ch]@1
  char v23; // [sp+35h] [bp-7h]@1

  v21 = 1600085855;
  v11 = -1;
  v15 = 1;
  v16 = 1;
  v12 = 1;
  v13 = 1;
  v20 = 1600085855;
  v22 = 1600085855;
  BYTE2(v21) = 0;
  v23 = 0;
  if ( a2 == 0xFFFFFF )
  {
    v4 = a3;
    v14 = a3;
  }
  else
  {
    v4 = a2;
    v14 = a2;
  }
  sub_10032A50(&v14, a4, &v11);
  v5 = a4;
  if ( v11 == a4 )
    goto LABEL_39;
  v6 = a2;
  if ( a2 != 0xFFFFFF && a3 != 0xFFFFFF )
  {
    v7 = 0;
    v11 = 0;
    v17 = 0;
    while ( 1 )
    {
      if ( !v12 && !v13 )
      {
LABEL_37:
        if ( v11 - 1 != v5 )
        {
          v14 = 0xFFFFFF;
          v4 = 0xFFFFFF;
        }
        goto LABEL_39;
      }
      v14 = 0xFFFFFF;
      if ( v12 && !v7 )
      {
        (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(v6, 5, &v18);
        sub_1003A7A0(&v19, 6, (int)&v20);
        sub_100423E0((int)&v20, 6);
        v15 = v18 & 1;
      }
      if ( v13 && !v17 )
      {
        while ( 1 )
        {
          (*(void (__cdecl **)(signed int, signed int, char *))dword_103334D8)(a3, 5, &v18);
          v8 = *(_BYTE *)(dword_10333D50 + 20833) == 0;
          v16 = v18 & 1;
          if ( (!v8 || !(v18 & 8)) && !(v18 & 6) )
          {
            sub_1003A7A0(&v19, 6, (int)&v21 + 3);
            sub_100423E0((int)&v21 + 3, 6);
            goto LABEL_23;
          }
          if ( !(v18 & 1) )
            break;
          a3 += a1;
          sub_10033300(&a3);
        }
        v13 = 0;
      }
LABEL_23:
      if ( v12 )
      {
        if ( !v13 )
          goto LABEL_28;
      }
      else if ( v13 )
      {
        goto LABEL_31;
      }
      if ( strcmp((const char *)&v20, (const char *)&v21 + 3) <= 0 )
      {
LABEL_28:
        v7 = 0;
        v4 = a2;
        v14 = a2;
        v17 = 1;
        if ( v15 )
        {
          a2 += a1;
          sub_10033300(&a2);
        }
        else
        {
          v12 = 0;
          a2 = 0xFFFFFF;
        }
        goto LABEL_34;
      }
LABEL_31:
      v4 = a3;
      v14 = a3;
      v7 = 1;
      v17 = 0;
      if ( v16 )
      {
        a3 += a1;
        sub_10033300(&a3);
      }
      else
      {
        v13 = 0;
        a3 = 0xFFFFFF;
      }
LABEL_34:
      v5 = a4;
      if ( ++v11 > a4 )
      {
        if ( v12 || v13 )
          goto LABEL_39;
        goto LABEL_37;
      }
      v6 = a2;
    }
  }
  if ( v11 == -1 )
  {
    v11 = 0;
    if ( a2 == 0xFFFFFF )
      v6 = a3;
    v14 = v6;
  }
  v10 = v14;
  do
  {
    (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(v10, 5, &v18);
    if ( (*(_BYTE *)(dword_10333D50 + 20833) || !(v18 & 8)) && !(v18 & 6) )
      ++v11;
    if ( v18 & 1 || v11 - 1 >= a4 )
    {
      if ( v11 - 1 < a4 )
      {
        v14 += a1;
        sub_10033300(&v14);
      }
    }
    else
    {
      a4 = -1;
      v14 = 0xFFFFFF;
      v4 = 0xFFFFFF;
    }
    if ( v11 - 1 >= a4 )
      break;
    if ( a4 == -1 )
      break;
    v10 = v14;
  }
  while ( v14 != 0xFFFFFF );
LABEL_39:
  if ( v11 - 1 == a4 && v4 != 0xFFFFFF )
    sub_10033350(v4, a4, v14);
  return v14;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333D50: using guessed type int dword_10333D50;

//----- (10030B70) --------------------------------------------------------
signed int __cdecl sub_10030B70(int a1, char a2, char a3)
{
  char v3; // bl@1
  char v5; // [sp+7h] [bp-5h]@6
  unsigned __int8 v6; // [sp+8h] [bp-4h]@2

  v3 = -1;
  while ( 1 )
  {
    (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_103334D8)(a1, 3, &v6);
    if ( ((v6 >> 1) & 3) == a2 )
      ++v3;
    if ( v3 >= a3 )
      break;
    if ( !(v6 & 1) )
      return 0xFFFFFF;
    a1 += (unsigned __int16)word_10333C54;
    sub_100332D0((int)&a1, &v5);
  }
  return a1;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C54: using guessed type __int16 word_10333C54;

//----- (10030BF0) --------------------------------------------------------
int __usercall sub_10030BF0@<eax>(int a1@<eax>, unsigned __int8 a2)
{
  int v2; // edi@1
  signed int v3; // esi@1
  signed int v4; // eax@1
  int result; // eax@3

  v2 = a1;
  v3 = sub_10034180(a1);
  v4 = sub_10034010(v2);
  if ( v3 != 0xFFFFFF || v4 != 0xFFFFFF )
  {
    result = sub_100307C0(word_10333C4E, v3, v4, a2);
  }
  else
  {
    sub_10042930("..\\lib\\acl\\adb\\adb_appr.c", 3324, 0, 0);
    result = 0xFFFFFF;
  }
  return result;
}
// 10333C4E: using guessed type __int16 word_10333C4E;

//----- (10030C50) --------------------------------------------------------
int __usercall sub_10030C50@<eax>(unsigned __int8 a1@<al>, int a2, char a3, char a4)
{
  int result; // eax@1

  result = sub_10030BF0(a2, a1);
  if ( result != 0xFFFFFF )
    result = sub_10030B70((unsigned __int16)word_10333C4E + result, a3, a4);
  return result;
}
// 10333C4E: using guessed type __int16 word_10333C4E;

//----- (10030C80) --------------------------------------------------------
char __usercall sub_10030C80@<al>(int a1@<eax>, int a2)
{
  int v2; // esi@1
  int v3; // eax@1
  char v5; // [sp+4h] [bp-8h]@1
  int v6; // [sp+5h] [bp-7h]@1

  v2 = a1;
  (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(a2, 3, &v5);
  sub_10032A90(v6, v2);
  v3 = (unsigned __int16)word_10333C4C + a2;
  *(_DWORD *)(v2 + 8) = v3;
  a2 = v3;
  return sub_100332D0((int)&a2, (_BYTE *)(v2 + 6));
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C4C: using guessed type __int16 word_10333C4C;

//----- (10030CE0) --------------------------------------------------------
char __usercall sub_10030CE0@<al>(int a1@<esi>, int a2, unsigned __int16 a3)
{
  char result; // al@2
  unsigned __int8 v4; // [sp+0h] [bp-14h]@2
  char v5; // [sp+7h] [bp-Dh]@2
  char v6; // [sp+8h] [bp-Ch]@1
  char v7; // [sp+Ch] [bp-8h]@1

  (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(a2, 5, &v6);
  sub_1003A7A0(&v7, 6, a1);
  sub_100423E0(a1, 6);
  a2 += a3;
  do
  {
    (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_103334D8)(a2, 3, &v4);
    ++*(_BYTE *)((((unsigned int)v4 >> 1) & 3) + a1 + 7);
    a2 += (unsigned __int16)word_10333C54;
    result = sub_100332D0((int)&a2, &v5);
  }
  while ( v4 & 1 );
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C54: using guessed type __int16 word_10333C54;

//----- (10030D80) --------------------------------------------------------
char __usercall sub_10030D80@<al>(int a1@<eax>, int a2)
{
  int v2; // esi@1
  int v3; // eax@1
  char v5; // [sp+4h] [bp-8h]@1
  int v6; // [sp+5h] [bp-7h]@1

  v2 = a1;
  (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(a2, 3, &v5);
  sub_10032A90(v6, v2);
  v3 = (unsigned __int16)word_10333C54 + a2;
  *(_DWORD *)(v2 + 8) = v3;
  a2 = v3;
  return sub_100332D0((int)&a2, (_BYTE *)(v2 + 6));
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C54: using guessed type __int16 word_10333C54;

//----- (10030DE0) --------------------------------------------------------
signed int __thiscall sub_10030DE0(int this)
{
  int v1; // edi@1
  signed int result; // eax@1
  int v3; // ebx@2
  int v4; // esi@2
  __int16 v5; // dx@2
  char *v6; // eax@2
  unsigned __int16 v7; // [sp+4h] [bp-A4h]@2

  v1 = this;
  result = 0xFFFFFF;
  if ( *(_WORD *)(this + 4) & 0x200 )
  {
    v3 = *(_DWORD *)this;
    v4 = v3 + sub_100361F0(this);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_103334D8)(v3, 160, &v7);
    v5 = *(_WORD *)(v1 + 4);
    v6 = (char *)&v7;
    if ( v5 & 1 )
    {
      v4 += v7;
      v6 = (char *)&v7 + (unsigned __int16)word_10333C22;
    }
    if ( v5 & 2 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_10333C22;
    }
    if ( v5 & 4 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_10333C22;
    }
    if ( v5 & 8 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_10333C22;
    }
    if ( v5 & 0x10 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_10333C22;
    }
    if ( v5 & 0x40 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_10333C22;
    }
    if ( (char)v5 < 0 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_10333C22;
    }
    if ( *(_WORD *)(v1 + 4) & 0x100 )
      v4 += *(_WORD *)v6;
    result = v4;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C22: using guessed type __int16 word_10333C22;

//----- (10030ED0) --------------------------------------------------------
int __usercall sub_10030ED0@<eax>(char a1@<al>, char a2@<dl>, int a3@<ecx>, _DWORD *a4@<edi>, unsigned __int8 a5, char a6, _BYTE *a7, int *a8)
{
  int v8; // eax@1
  _BYTE *v9; // esi@1
  unsigned __int16 v10; // cx@3
  int v11; // eax@3
  int v12; // ecx@3
  int v13; // esi@5
  int result; // eax@5
  __int16 v15; // ax@6
  int v16; // [sp+18h] [bp+Ch]@6

  v8 = (unsigned __int16)((unsigned __int16)a7 & 0xFF00) | a5 | ((a1 & 3) << 16);
  v9 = a7;
  if ( (unsigned __int8)a2 > 3u )
  {
    HIBYTE(v15) = a2;
    v16 = a3;
    LOBYTE(v15) = a5;
    HIWORD(v16) = BYTE2(a3) & 3 | 4 * v15;
    result = (int)v9;
    *a8 = v16;
  }
  else
  {
    if ( a6 )
    {
      LOBYTE(v10) = 0;
      HIBYTE(v10) = *a7;
      v11 = v10 | v8 & 0xFFFF00FF;
      *a4 += (unsigned __int16)word_10333C8C;
      v12 = (unsigned __int16)word_10333C8C;
    }
    else
    {
      v11 = (v8 ^ (*(_WORD *)a7 << 8)) & 0x3FF00 ^ v8;
      *a4 += (unsigned __int16)word_10333C88;
      v12 = (unsigned __int16)word_10333C88;
    }
    v13 = (int)&a7[v12];
    *a8 = sub_1002E300(a2, v11);
    result = v13;
  }
  return result;
}
// 10333C88: using guessed type __int16 word_10333C88;
// 10333C8C: using guessed type __int16 word_10333C8C;

//----- (10030F80) --------------------------------------------------------
int __usercall sub_10030F80@<eax>(int result@<eax>)
{
  *(float *)(result + 12) = 0.0;
  *(_BYTE *)(result + 8) = 0;
  *(float *)(result + 16) = 0.0;
  *(_BYTE *)(result + 9) = 0;
  *(float *)(result + 20) = 0.0;
  *(_BYTE *)(result + 7) = 4;
  *(float *)(result + 24) = 0.0;
  *(_BYTE *)(result + 10) = 0;
  *(float *)(result + 28) = 0.0;
  *(_BYTE *)(result + 3) = 0;
  *(float *)(result + 32) = 0.0;
  *(_BYTE *)(result + 6) = 0;
  *(_BYTE *)(result + 4) = 0;
  *(_BYTE *)(result + 5) = 0;
  *(_DWORD *)(result + 36) = 0x3FFFF;
  *(_BYTE *)(result + 1) = 0;
  *(_BYTE *)result = 24;
  *(_BYTE *)(result + 2) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 52) = 0;
  *(_DWORD *)(result + 56) = 0;
  return result;
}

//----- (10030FD0) --------------------------------------------------------
char __usercall sub_10030FD0@<al>(_BYTE *a1@<edi>, int *a2@<esi>)
{
  char result; // al@2
  char v3; // [sp+0h] [bp-10h]@2

  *a1 = 0;
  do
  {
    ++*a1;
    (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(*a2, 14, &v3);
    sub_10032B20(a2);
    result = sub_10034280(a2);
  }
  while ( v3 & 1 );
  return result;
}
// 103334D8: using guessed type int dword_103334D8;

//----- (10031010) --------------------------------------------------------
char __usercall sub_10031010@<al>(_BYTE *a1@<edi>, _DWORD *a2@<esi>, unsigned __int16 a3)
{
  char v3; // bl@1
  char result; // al@8
  char v5; // [sp+8h] [bp-8h]@2

  *a1 = 0;
  v3 = 0;
  do
  {
    (*(void (__cdecl **)(_DWORD, signed int, char *))dword_103334D8)(*a2, 5, &v5);
    if ( !*(_BYTE *)(dword_10333D50 + 20833) && v5 & 8 || v5 & 6 )
    {
      v3 = 1;
    }
    else if ( !v3 )
    {
      ++*a1;
    }
    *a2 += a3;
    result = sub_10033300(a2);
  }
  while ( v5 & 1 );
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333D50: using guessed type int dword_10333D50;

//----- (10031080) --------------------------------------------------------
char __cdecl sub_10031080(unsigned int a1)
{
  char v1; // bl@1
  signed int v2; // eax@3
  char v4; // [sp+7h] [bp-1Dh]@1
  int v5; // [sp+8h] [bp-1Ch]@1
  char v6; // [sp+Ch] [bp-18h]@1
  char v7; // [sp+14h] [bp-10h]@6

  v1 = 0;
  v4 = 0;
  sub_10036830(a1, &v6);
  v5 = sub_10033C70((int)&v6);
  if ( v5 != 0xFFFFFF )
  {
    sub_10030FD0(&v4, &v5);
    v1 = v4;
  }
  v2 = sub_10033B10((int)&v6);
  v5 = v2;
  if ( v2 != 0xFFFFFF )
  {
    while ( 1 )
    {
      (*(void (__cdecl **)(signed int, signed int, char *))dword_103334D8)(v2, 14, &v7);
      sub_10032B20(&v5);
      sub_10034280(&v5);
      ++v1;
      if ( !sub_10032860((int)&v7) )
        --v1;
      if ( !(v7 & 1) )
        break;
      v2 = v5;
    }
  }
  return v1;
}
// 103334D8: using guessed type int dword_103334D8;

//----- (10031130) --------------------------------------------------------
char __cdecl sub_10031130(unsigned int a1, unsigned __int8 a2, char a3, _BYTE *a4, _BYTE *a5, _BYTE *a6)
{
  _BYTE *v6; // ebx@1
  _BYTE *v7; // esi@1
  _BYTE *v8; // edi@1
  signed int v9; // eax@1
  char v11; // [sp+Fh] [bp-9h]@1
  char v12; // [sp+10h] [bp-8h]@1

  v6 = a5;
  v7 = a6;
  v8 = a4;
  *a4 = 0;
  *v6 = -2;
  v11 = 0;
  *v7 = -2;
  sub_10036830(a1, &v12);
  v9 = sub_10034570((int)&v12, a2, &v11);
  a4 = (_BYTE *)v9;
  if ( v9 != 0xFFFFFF )
  {
    sub_10032B20((int *)&a4);
    LOBYTE(v9) = sub_100306A0(v8, v7, (int)a4, (char)(2 * a3) >> 1, v6);
  }
  return v9;
}

//----- (100311B0) --------------------------------------------------------
char __cdecl sub_100311B0(unsigned int a1, unsigned __int8 a2, char a3, _DWORD *a4)
{
  int v4; // esi@1
  int v5; // eax@1
  char v7; // [sp+7h] [bp-9h]@1
  char v8; // [sp+8h] [bp-8h]@1

  v4 = (int)a4;
  *a4 = 1600085855;
  *(_BYTE *)(v4 + 4) = 95;
  v7 = 0;
  *(_BYTE *)(v4 + 5) = 0;
  *(_BYTE *)(v4 + 6) = 0;
  *(_DWORD *)(v4 + 8) = 0xFFFFFF;
  sub_10036830(a1, &v8);
  v5 = sub_10034570((int)&v8, a2, &v7);
  a4 = (_DWORD *)v5;
  if ( v5 != 0xFFFFFF )
  {
    sub_10032B20((int *)&a4);
    v5 = sub_10030750((signed int)a4, a3);
    a4 = (_DWORD *)v5;
    if ( v5 != 0xFFFFFF )
      LOBYTE(v5) = sub_10030C80(v4, v5);
  }
  return v5;
}

//----- (10031240) --------------------------------------------------------
char __cdecl sub_10031240(unsigned int a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@1
  char v5; // [sp+4h] [bp-8h]@1

  *(_DWORD *)a3 = 1600085855;
  *(_WORD *)(a3 + 4) = 24415;
  *(_BYTE *)(a3 + 6) = 0;
  *(_WORD *)(a3 + 7) = 0;
  *(_BYTE *)(a3 + 9) = 0;
  sub_10036830(a1, &v5);
  v3 = sub_10030BF0((int)&v5, a2);
  if ( v3 != 0xFFFFFF )
    LOBYTE(v3) = sub_10030CE0(a3, v3, word_10333C4E);
  return v3;
}
// 10333C4E: using guessed type __int16 word_10333C4E;

//----- (100312A0) --------------------------------------------------------
char __cdecl sub_100312A0(unsigned int a1, unsigned __int8 a2, char a3, char a4, int a5)
{
  int v5; // eax@1
  char v7; // [sp+4h] [bp-8h]@1

  *(_DWORD *)a5 = 1600085855;
  *(_BYTE *)(a5 + 4) = 95;
  *(_BYTE *)(a5 + 5) = 0;
  *(_BYTE *)(a5 + 6) = 0;
  *(_DWORD *)(a5 + 8) = 0xFFFFFF;
  sub_10036830(a1, &v7);
  v5 = sub_10030C50(a2, (int)&v7, a3, a4);
  if ( v5 != 0xFFFFFF )
    LOBYTE(v5) = sub_10030D80(a5, v5);
  return v5;
}

//----- (10031310) --------------------------------------------------------
char __cdecl sub_10031310(unsigned int a1)
{
  char v1; // bl@1
  char result; // al@4
  char v3; // [sp+Fh] [bp-Dh]@1
  int v4; // [sp+10h] [bp-Ch]@1
  char v5; // [sp+14h] [bp-8h]@1

  v1 = 0;
  v3 = 0;
  sub_10036830(a1, &v5);
  v4 = sub_10033EF0((int)&v5);
  if ( v4 != 0xFFFFFF )
  {
    sub_10031010(&v3, &v4, word_10333C52);
    v1 = v3;
  }
  v4 = sub_10033D60((int)&v5);
  if ( v4 == 0xFFFFFF )
  {
    result = v1;
  }
  else
  {
    sub_10031010(&v3, &v4, word_10333C52);
    result = v1 + v3;
  }
  return result;
}
// 10333C52: using guessed type __int16 word_10333C52;

//----- (100313B0) --------------------------------------------------------
char __cdecl sub_100313B0(unsigned int a1)
{
  char v1; // bl@1
  char result; // al@4
  char v3; // [sp+Fh] [bp-Dh]@1
  int v4; // [sp+10h] [bp-Ch]@1
  char v5; // [sp+14h] [bp-8h]@1

  v1 = 0;
  v3 = 0;
  sub_10036830(a1, &v5);
  v4 = sub_10034180((int)&v5);
  if ( v4 != 0xFFFFFF )
  {
    sub_10031010(&v3, &v4, word_10333C4E);
    v1 = v3;
  }
  v4 = sub_10034010((int)&v5);
  if ( v4 == 0xFFFFFF )
  {
    result = v1;
  }
  else
  {
    sub_10031010(&v3, &v4, word_10333C52);
    result = v1 + v3;
  }
  return result;
}
// 10333C4E: using guessed type __int16 word_10333C4E;
// 10333C52: using guessed type __int16 word_10333C52;

//----- (10031450) --------------------------------------------------------
int __usercall sub_10031450@<eax>(int a1@<eax>, unsigned __int8 a2)
{
  int v2; // edi@1
  signed int v3; // esi@1
  signed int v4; // eax@1
  int result; // eax@3

  v2 = a1;
  v3 = sub_10033EF0(a1);
  v4 = sub_10033D60(v2);
  if ( v3 != 0xFFFFFF || v4 != 0xFFFFFF )
  {
    result = sub_100307C0(word_10333C52, v3, v4, a2);
  }
  else
  {
    sub_10042930("..\\lib\\acl\\adb\\adb_appr.c", 2874, 0, 0);
    result = 0xFFFFFF;
  }
  return result;
}
// 10333C52: using guessed type __int16 word_10333C52;

//----- (100314B0) --------------------------------------------------------
int __usercall sub_100314B0@<eax>(unsigned __int8 a1@<al>, int a2, char a3, char a4)
{
  int result; // eax@1

  result = sub_10031450(a2, a1);
  if ( result != 0xFFFFFF )
    result = sub_10030B70((unsigned __int16)word_10333C52 + result, a3, a4);
  return result;
}
// 10333C52: using guessed type __int16 word_10333C52;

//----- (100314E0) --------------------------------------------------------
signed int __cdecl sub_100314E0(unsigned __int8 a1)
{
  int v1; // ecx@0
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-2Ch]@3
  char v6; // [sp+2Eh] [bp-2h]@3

  result = sub_10030DE0(v1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a1 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_103334D8)(v3, 43, &v5);
        if ( !(v6 & 2) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_10333CB0;
        if ( v4 >= a1 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333CB0: using guessed type __int16 word_10333CB0;

//----- (10031550) --------------------------------------------------------
void __usercall sub_10031550(int *a1@<ecx>, int a2@<esi>, int a3)
{
  int *v3; // edi@1
  unsigned __int8 v4; // dl@1
  int v5; // eax@1
  char *v6; // ebp@1
  _BYTE *v7; // eax@2
  int v8; // eax@2
  unsigned __int16 v9; // dx@2
  char v10; // al@2
  int v11; // eax@3
  char *v12; // ST50_4@5
  char *v13; // eax@5
  double v14; // st7@5
  double v15; // st7@6
  char *v16; // ST50_4@8
  unsigned __int16 *v17; // ebp@8
  unsigned __int16 *v18; // eax@9
  char *v19; // ST50_4@10
  unsigned __int16 *v20; // ebp@10
  char *v21; // ST50_4@11
  char *v22; // ebp@11
  unsigned __int16 *v23; // eax@11
  int v24; // eax@12
  unsigned __int16 *v25; // eax@13
  int v26; // eax@13
  char *v27; // ST50_4@15
  char *v28; // eax@15
  signed int v29; // ST50_4@15
  unsigned __int16 *v30; // eax@16
  _BYTE *v31; // eax@17
  unsigned __int16 *v32; // eax@17
  unsigned __int16 *v33; // eax@18
  int v34; // edx@19
  double v35; // st7@20
  unsigned __int16 *v36; // eax@23
  char *v37; // ecx@23
  int v38; // edx@23
  double v39; // st7@24
  double v40; // st7@25
  int v41; // edx@28
  unsigned __int16 *v42; // eax@32
  _BYTE *v43; // eax@33
  unsigned __int16 *v44; // eax@33
  int v45; // ecx@33
  float v46; // ST50_4@34
  double v47; // st7@34
  char *v48; // ST50_4@38
  char *v49; // ST50_4@39
  char *v50; // ebp@39
  int v51; // eax@39
  char *v52; // ST50_4@40
  unsigned __int16 *v53; // ebp@40
  char *v54; // ST50_4@41
  unsigned __int16 *v55; // ebp@41
  char *v56; // ST50_4@42
  char *v57; // ebp@42
  unsigned __int16 *v58; // eax@42
  double v59; // st7@46
  char v60; // al@46
  double v61; // st7@47
  float v62; // ST50_4@51
  unsigned __int8 v63; // al@52
  unsigned __int16 *v64; // [sp-38h] [bp-80h]@2
  float *v65; // [sp-34h] [bp-7Ch]@2
  float *v66; // [sp-30h] [bp-78h]@2
  _BYTE *v67; // [sp-2Ch] [bp-74h]@2
  _BYTE *v68; // [sp-28h] [bp-70h]@2
  _BYTE *v69; // [sp-24h] [bp-6Ch]@2
  char *v70; // [sp+Ch] [bp-3Ch]@19
  char v71[52]; // [sp+10h] [bp-38h]@1

  v3 = a1;
  (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(*a1, 50, v71);
  v4 = v71[0];
  *(float *)(a2 + 20) = 0.0;
  *(float *)(a2 + 24) = 0.0;
  *(_BYTE *)a2 = v4 & 0x1F;
  *(_BYTE *)(a2 + 3) = (v4 >> 5) & 1;
  *(_BYTE *)(a2 + 5) = v4 >> 7;
  *(_BYTE *)(a2 + 6) = 0;
  *(_BYTE *)(a2 + 7) = 4;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 9) = 0;
  *(_BYTE *)(a2 + 10) = 0;
  *(_BYTE *)(a2 + 2) = 0;
  *v3 += (unsigned __int16)word_10333C56;
  v5 = *v3;
  v6 = &v71[(unsigned __int16)word_10333C56];
  switch ( *(_BYTE *)a2 )
  {
    case 0:
      *v3 = v5 + (unsigned __int16)word_10333C5A;
      v7 = (_BYTE *)sub_10030ED0(
                      0,
                      (unsigned __int8)*v6 >> 4,
                      a3,
                      v3,
                      v6[1],
                      0,
                      &v6[(unsigned __int16)word_10333C5A],
                      (int *)(a2 + 36));
      v8 = sub_10030ED0(0, ((unsigned __int8)v6[2] >> 4) & 0xF, a3, v3, v6[3], 0, v7, (int *)(a2 + 40));
      *(_BYTE *)(a2 + 6) = ((unsigned __int8)*v6 >> 1) & 7;
      *(float *)(a2 + 48) = (double)*((_WORD *)v6 + 3) * 0.0001745329209370539;
      *(float *)(a2 + 52) = 0.0001745329209370539 * (double)*((_WORD *)v6 + 4);
      v69 = (_BYTE *)(a2 + 9);
      v68 = (_BYTE *)(a2 + 8);
      v67 = (_BYTE *)(a2 + 7);
      v66 = (float *)(a2 + 16);
      *(float *)(a2 + 44) = (double)(*((_WORD *)v6 + 2) & 0x3FFF) * 185.1999969482422;
      v9 = *((_WORD *)v6 + 2);
      v65 = (float *)(a2 + 12);
      v64 = (unsigned __int16 *)v8;
      v10 = *v6;
      goto LABEL_3;
    case 1:
      *v3 = v5 + (unsigned __int16)word_10333C5C;
      v12 = v6;
      v6 += (unsigned __int16)word_10333C5C;
      sub_10030ED0(0, 11, a3, v3, 1u, 0, v6, (int *)(a2 + 36));
      v13 = v12;
      *(_WORD *)(a2 + 36) = -1;
      v14 = (double)*(_WORD *)v12;
      goto LABEL_6;
    case 2:
      *v3 = v5 + (unsigned __int16)word_10333C5E;
      v16 = v6;
      v17 = (unsigned __int16 *)sub_10030ED0(
                                  0,
                                  (unsigned __int8)*v6 >> 4,
                                  a3,
                                  v3,
                                  v6[1],
                                  0,
                                  &v6[(unsigned __int16)word_10333C5E],
                                  (int *)(a2 + 44));
      sub_10030ED0(0, 11, a3, v3, 1u, 0, v17, (int *)(a2 + 36));
      *(_WORD *)(a2 + 36) = -1;
      *(_BYTE *)(a2 + 6) = ((unsigned __int8)*v16 >> 1) & 7;
      *(float *)(a2 + 40) = (double)*((_WORD *)v16 + 1) * 0.0001745329209370539;
      *(float *)(a2 + 48) = (double)(*((_WORD *)v16 + 2) & 0x3FFF) * 185.1999969482422;
      v6 = (char *)sub_10032750(
                     *v16 & 1,
                     (*((_WORD *)v16 + 2) >> 14) & 3,
                     v3,
                     v17,
                     (float *)(a2 + 12),
                     (float *)(a2 + 16),
                     (_BYTE *)(a2 + 7),
                     (_BYTE *)(a2 + 8),
                     (_BYTE *)(a2 + 9));
      goto LABEL_44;
    case 3:
      *v3 = v5 + (unsigned __int16)word_10333C60;
      v18 = (unsigned __int16 *)sub_10030ED0(
                                  0,
                                  (unsigned __int8)*v6 >> 4,
                                  a3,
                                  v3,
                                  v6[1],
                                  0,
                                  &v6[(unsigned __int16)word_10333C60],
                                  (int *)(a2 + 36));
      *(_BYTE *)(a2 + 6) = ((unsigned __int8)*v6 >> 1) & 7;
      *(float *)(a2 + 40) = (double)*((_WORD *)v6 + 1) * 0.0001745329209370539;
      *(float *)(a2 + 44) = (double)(*((_WORD *)v6 + 2) & 0x3FFF) * 185.1999969482422;
      v6 = (char *)sub_10032750(
                     *v6 & 1,
                     (*((_WORD *)v6 + 2) >> 14) & 3,
                     v3,
                     v18,
                     (float *)(a2 + 12),
                     (float *)(a2 + 16),
                     (_BYTE *)(a2 + 7),
                     (_BYTE *)(a2 + 8),
                     (_BYTE *)(a2 + 9));
      goto LABEL_44;
    case 4:
      *v3 = v5 + (unsigned __int16)word_10333C62;
      v19 = v6;
      v20 = (unsigned __int16 *)&v6[(unsigned __int16)word_10333C62];
      sub_10030ED0(0, 11, a3, v3, 1u, 0, v20, (int *)(a2 + 36));
      *(_WORD *)(a2 + 36) = -1;
      *(float *)(a2 + 40) = (double)*(_WORD *)v19 * 0.0001745329209370539;
      v6 = (char *)sub_10032750(
                     ((unsigned __int8)v19[2] >> 2) & 1,
                     v19[2] & 3,
                     v3,
                     v20,
                     (float *)(a2 + 12),
                     (float *)(a2 + 16),
                     (_BYTE *)(a2 + 7),
                     (_BYTE *)(a2 + 8),
                     (_BYTE *)(a2 + 9));
      goto LABEL_44;
    case 5:
      *v3 = v5 + (unsigned __int16)word_10333C64;
      v21 = v6;
      v22 = &v6[(unsigned __int16)word_10333C64];
      sub_10030ED0(0, 11, a3, v3, 1u, 0, v22, (int *)(a2 + 36));
      *(_WORD *)(a2 + 36) = -1;
      v23 = (unsigned __int16 *)sub_10030ED0(
                                  ((unsigned __int8)v21[6] >> 2) & 3,
                                  ((unsigned __int8)*v21 >> 4) & 0xF,
                                  a3,
                                  v3,
                                  v21[1],
                                  1,
                                  v22,
                                  (int *)(a2 + 44));
      *(_BYTE *)(a2 + 6) = ((unsigned __int8)*v21 >> 1) & 7;
      *(float *)(a2 + 40) = (double)*((_WORD *)v21 + 1) * 0.0001745329209370539;
      *(float *)(a2 + 48) = 0.0001745329209370539 * (double)*((_WORD *)v21 + 2);
      v11 = sub_10032750(
              *v21 & 1,
              v21[6] & 3,
              v3,
              v23,
              (float *)(a2 + 12),
              (float *)(a2 + 16),
              (_BYTE *)(a2 + 7),
              (_BYTE *)(a2 + 8),
              (_BYTE *)(a2 + 9));
      goto LABEL_4;
    case 6:
      *v3 = v5 + (unsigned __int16)word_10333C66;
      v24 = (unsigned __int16)word_10333C66;
      goto LABEL_13;
    case 7:
      *v3 = v5 + (unsigned __int16)word_10333C68;
      v27 = v6;
      v6 = (char *)sub_10030ED0(
                     0,
                     (unsigned __int8)*v6 >> 4,
                     a3,
                     v3,
                     v6[1],
                     0,
                     &v6[(unsigned __int16)word_10333C68],
                     (int *)(a2 + 36));
      v28 = v27;
      *(_BYTE *)(a2 + 6) = ((unsigned __int8)*v27 >> 1) & 7;
      v29 = *((_WORD *)v27 + 1);
      *(_BYTE *)(a2 + 7) = 1;
      *(float *)(a2 + 40) = (double)v29 * 0.0001745329209370539;
      v15 = sub_100326F0(
              *((_WORD *)v28 + 2) & 0x7FFF,
              COERCE_FLOAT(((unsigned int)*((_WORD *)v28 + 2) >> 15) & 0xFFFFFF01));
      goto LABEL_7;
    case 8:
      *v3 = v5 + (unsigned __int16)word_10333C6A;
      v30 = (unsigned __int16 *)sub_10030ED0(
                                  0,
                                  (unsigned __int8)*v6 >> 4,
                                  a3,
                                  v3,
                                  v6[1],
                                  0,
                                  &v6[(unsigned __int16)word_10333C6A],
                                  (int *)(a2 + 36));
      *(_BYTE *)(a2 + 6) = ((unsigned __int8)*v6 >> 1) & 7;
      *(float *)(a2 + 40) = (double)*((_WORD *)v6 + 1) * 0.0001745329209370539;
      *(float *)(a2 + 44) = (double)(*((_WORD *)v6 + 2) & 0x3FFF) * 185.1999969482422;
      v26 = sub_10032750(
              *v6 & 1,
              (*((_WORD *)v6 + 2) >> 14) & 3,
              v3,
              v30,
              (float *)(a2 + 12),
              (float *)(a2 + 16),
              (_BYTE *)(a2 + 7),
              (_BYTE *)(a2 + 8),
              (_BYTE *)(a2 + 9));
      goto LABEL_14;
    case 9:
      *v3 = v5 + (unsigned __int16)word_10333C6C;
      v31 = (_BYTE *)sub_10030ED0(
                       0,
                       (unsigned __int8)*v6 >> 4,
                       a3,
                       v3,
                       v6[1],
                       0,
                       &v6[(unsigned __int16)word_10333C6C],
                       (int *)(a2 + 36));
      v32 = (unsigned __int16 *)sub_10030ED0(
                                  0,
                                  ((unsigned __int8)v6[2] >> 4) & 0xF,
                                  a3,
                                  v3,
                                  v6[3],
                                  0,
                                  v31,
                                  (int *)(a2 + 44));
      *(_BYTE *)(a2 + 6) = ((unsigned __int8)*v6 >> 1) & 7;
      *(float *)(a2 + 48) = (double)(*((_WORD *)v6 + 2) & 0x3FFF) * 185.1999969482422;
      *(float *)(a2 + 40) = (double)*((_WORD *)v6 + 3) * 0.0001745329209370539;
      v6 = (char *)sub_10032750(
                     *v6 & 1,
                     (*((_WORD *)v6 + 2) >> 14) & 3,
                     v3,
                     v32,
                     (float *)(a2 + 12),
                     (float *)(a2 + 16),
                     (_BYTE *)(a2 + 7),
                     (_BYTE *)(a2 + 8),
                     (_BYTE *)(a2 + 9));
      goto LABEL_44;
    case 0xA:
      *v3 = v5 + (unsigned __int16)word_10333C6E;
      v33 = (unsigned __int16 *)sub_10030ED0(
                                  ((unsigned __int8)v6[4] >> 2) & 3,
                                  ((unsigned __int8)*v6 >> 4) & 0xF,
                                  a3,
                                  v3,
                                  v6[1],
                                  1,
                                  &v6[(unsigned __int16)word_10333C6E],
                                  (int *)(a2 + 36));
      *(_BYTE *)(a2 + 6) = ((unsigned __int8)*v6 >> 1) & 7;
      *(float *)(a2 + 40) = (double)*((_WORD *)v6 + 1) * 0.0001745329209370539;
      v26 = sub_10032750(
              *v6 & 1,
              v6[4] & 3,
              v3,
              v33,
              (float *)(a2 + 12),
              (float *)(a2 + 16),
              (_BYTE *)(a2 + 7),
              (_BYTE *)(a2 + 8),
              (_BYTE *)(a2 + 9));
      goto LABEL_14;
    case 0xB:
      *v3 = v5 + (unsigned __int16)word_10333C70;
      v70 = v6;
      v6 = (char *)sub_10030ED0(
                     *((_WORD *)v6 + 3) >> 14,
                     ((unsigned __int8)*v6 >> 4) & 0xF,
                     a3,
                     v3,
                     v6[1],
                     1,
                     &v6[(unsigned __int16)word_10333C70],
                     (int *)(a2 + 36));
      *(_BYTE *)(a2 + 6) = ((unsigned __int8)*v70 >> 1) & 7;
      *(float *)(a2 + 40) = (double)*((_WORD *)v70 + 1) * 0.0001745329209370539;
      v34 = *((_WORD *)v70 + 3) & 0x3FFF;
      if ( *v70 & 1 )
        v35 = (double)v34;
      else
        v35 = (double)v34 * 185.1999969482422;
      *(float *)(a2 + 48) = v35;
      *(_BYTE *)(a2 + 44) = *v70 & 1;
      *(_BYTE *)(a2 + 7) = 1;
      *(float *)(a2 + 12) = sub_100326F0(
                              *((_WORD *)v70 + 2) & 0x7FFF,
                              COERCE_FLOAT(((unsigned int)*((_WORD *)v70 + 2) >> 15) & 0xFFFFFF01));
      goto LABEL_44;
    case 0xC:
      *v3 = v5 + (unsigned __int16)word_10333C72;
      v36 = (unsigned __int16 *)sub_10030ED0(
                                  ((unsigned __int8)v6[6] >> 1) & 3,
                                  ((unsigned __int8)*v6 >> 4) & 0xF,
                                  a3,
                                  v3,
                                  v6[1],
                                  1,
                                  &v6[(unsigned __int16)word_10333C72],
                                  (int *)(a2 + 36));
      v37 = v6;
      *(_BYTE *)(a2 + 6) = ((unsigned __int8)*v6 >> 1) & 7;
      *(float *)(a2 + 40) = (double)*((_WORD *)v6 + 1) * 0.0001745329209370539;
      v38 = *((_WORD *)v6 + 2) & 0x3FFF;
      if ( v6[6] & 1 )
      {
        v39 = (double)v38;
        goto LABEL_27;
      }
      v40 = (double)v38;
      goto LABEL_26;
    case 0xD:
      *v3 = v5 + (unsigned __int16)word_10333C74;
      v36 = (unsigned __int16 *)sub_10030ED0(
                                  ((unsigned __int8)v6[6] >> 1) & 3,
                                  ((unsigned __int8)*v6 >> 4) & 0xF,
                                  a3,
                                  v3,
                                  v6[1],
                                  1,
                                  &v6[(unsigned __int16)word_10333C74],
                                  (int *)(a2 + 36));
      v37 = v6;
      *(_BYTE *)(a2 + 6) = ((unsigned __int8)*v6 >> 1) & 7;
      *(float *)(a2 + 40) = (double)*((_WORD *)v6 + 1) * 0.0001745329209370539;
      v41 = *((_WORD *)v6 + 2) & 0x3FFF;
      if ( v6[6] & 1 )
      {
        v39 = (double)v41;
      }
      else
      {
        v40 = (double)v41;
LABEL_26:
        v39 = v40 * 185.1999969482422;
      }
LABEL_27:
      *(float *)(a2 + 48) = v39;
      *(_BYTE *)(a2 + 44) = v37[6] & 1;
      v6 = (char *)sub_10032750(
                     *v37 & 1,
                     (*((_WORD *)v37 + 2) >> 14) & 3,
                     v3,
                     v36,
                     (float *)(a2 + 12),
                     (float *)(a2 + 16),
                     (_BYTE *)(a2 + 7),
                     (_BYTE *)(a2 + 8),
                     (_BYTE *)(a2 + 9));
LABEL_44:
      if ( v71[0] & 0x40 )
      {
        *(_BYTE *)(a2 + 1) = ((unsigned __int8)*v6 >> 1) & 3;
        *(_BYTE *)(a2 + 4) = *v6 & 1;
        if ( *v6 & 8 )
        {
          *(float *)(a2 + 20) = (double)(*(_WORD *)(v6 + 1) & 0x7FFF);
          v59 = *(float *)(a2 + 20);
          v60 = (*(_WORD *)(v6 + 1) >> 15) & 1;
          *(_BYTE *)(a2 + 10) = v60;
          if ( v60 )
            v61 = v59 * 100.0;
          else
            v61 = v59 - 1000.0;
          *(float *)(a2 + 20) = v61;
          *(float *)(a2 + 20) = *(float *)(a2 + 20) * 0.3048000037670135;
        }
        if ( (unsigned __int16)word_10333C58 >= 6u )
        {
          v62 = (double)(v6[3] & 0x7F);
          *(float *)(a2 + 24) = v62;
          if ( 0.0 != v62 )
          {
            v63 = 0;
            if ( *v6 & 0x30 )
            {
              do
              {
                ++v63;
                *(float *)(a2 + 24) = *(float *)(a2 + 24) * 0.1000000014901161;
              }
              while ( v63 < (unsigned __int8)(((unsigned __int8)*v6 >> 4) & 3) );
            }
          }
          if ( *((_WORD *)v6 + 2) & 0x3FF )
          {
            *(float *)(a2 + 28) = (double)(*((_WORD *)v6 + 2) & 0x3FF) * 0.5144444704055786;
            *(_BYTE *)(a2 + 2) = (*((_WORD *)v6 + 2) >> 10) & 3;
          }
        }
        *v3 += (unsigned __int16)word_10333C58;
      }
      return;
    case 0xE:
      *v3 = v5 + (unsigned __int16)word_10333C76;
      v24 = (unsigned __int16)word_10333C76;
      goto LABEL_13;
    case 0xF:
      *v3 = v5 + (unsigned __int16)word_10333C78;
      v42 = (unsigned __int16 *)sub_10030ED0(
                                  0,
                                  (unsigned __int8)*v6 >> 4,
                                  a3,
                                  v3,
                                  v6[1],
                                  0,
                                  &v6[(unsigned __int16)word_10333C78],
                                  (int *)(a2 + 36));
      *(_BYTE *)(a2 + 6) = ((unsigned __int8)*v6 >> 1) & 7;
      *(float *)(a2 + 40) = (double)*((_WORD *)v6 + 1) * 0.0001745329209370539;
      *(float *)(a2 + 44) = (double)(*((_WORD *)v6 + 2) & 0x3FFF) * 185.1999969482422;
      v26 = sub_10032750(
              *v6 & 1,
              (*((_WORD *)v6 + 2) >> 14) & 3,
              v3,
              v42,
              (float *)(a2 + 12),
              (float *)(a2 + 16),
              (_BYTE *)(a2 + 7),
              (_BYTE *)(a2 + 8),
              (_BYTE *)(a2 + 9));
      goto LABEL_14;
    case 0x10:
      *v3 = v5 + (unsigned __int16)word_10333C7A;
      v43 = (_BYTE *)sub_10030ED0(
                       0,
                       (unsigned __int8)*v6 >> 4,
                       a3,
                       v3,
                       v6[1],
                       0,
                       &v6[(unsigned __int16)word_10333C7A],
                       (int *)(a2 + 36));
      v44 = (unsigned __int16 *)sub_10030ED0(
                                  0,
                                  ((unsigned __int8)v6[2] >> 4) & 0xF,
                                  a3,
                                  v3,
                                  v6[3],
                                  0,
                                  v43,
                                  (int *)(a2 + 40));
      *(_BYTE *)(a2 + 6) = ((unsigned __int8)*v6 >> 1) & 7;
      *(float *)(a2 + 48) = (double)*((_WORD *)v6 + 3) * 0.0001745329209370539;
      *(float *)(a2 + 52) = 0.0001745329209370539 * (double)*((_WORD *)v6 + 4);
      v45 = *((_WORD *)v6 + 2) & 0x3FFF;
      if ( (unsigned __int16)word_10333C7A <= 0xAu )
      {
        v47 = (double)v45 * 185.1999969482422;
      }
      else
      {
        v46 = ((double)v45 * 100.0 + (double)(v6[10] & 0x7F)) * 0.001000000047497451;
        v47 = v46 * 1852.0;
      }
      *(float *)(a2 + 44) = v47;
      v6 = (char *)sub_10032750(
                     *v6 & 1,
                     (*((_WORD *)v6 + 2) >> 14) & 3,
                     v3,
                     v44,
                     (float *)(a2 + 12),
                     (float *)(a2 + 16),
                     (_BYTE *)(a2 + 7),
                     (_BYTE *)(a2 + 8),
                     (_BYTE *)(a2 + 9));
      goto LABEL_44;
    case 0x11:
      *v3 = v5 + (unsigned __int16)word_10333C7C;
      v24 = (unsigned __int16)word_10333C7C;
LABEL_13:
      v25 = (unsigned __int16 *)sub_10030ED0(
                                  ((unsigned __int8)v6[2] >> 2) & 3,
                                  ((unsigned __int8)*v6 >> 4) & 0xF,
                                  a3,
                                  v3,
                                  v6[1],
                                  1,
                                  &v6[v24],
                                  (int *)(a2 + 36));
      *(_BYTE *)(a2 + 6) = ((unsigned __int8)*v6 >> 1) & 7;
      v26 = sub_10032750(
              *v6 & 1,
              v6[2] & 3,
              v3,
              v25,
              (float *)(a2 + 12),
              (float *)(a2 + 16),
              (_BYTE *)(a2 + 7),
              (_BYTE *)(a2 + 8),
              (_BYTE *)(a2 + 9));
LABEL_14:
      v6 = (char *)v26;
      goto LABEL_44;
    case 0x12:
      *v3 = v5 + (unsigned __int16)word_10333C7E;
      v48 = v6;
      v6 += (unsigned __int16)word_10333C7E;
      sub_10030ED0(0, 11, a3, v3, 1u, 0, v6, (int *)(a2 + 36));
      v13 = v48;
      *(_WORD *)(a2 + 36) = -1;
      v14 = (double)*(_WORD *)v48;
LABEL_6:
      *(_BYTE *)(a2 + 7) = 1;
      *(float *)(a2 + 40) = v14 * 0.0001745329209370539;
      v15 = sub_100326F0(
              *((_WORD *)v13 + 1) & 0x7FFF,
              COERCE_FLOAT(((unsigned int)*((_WORD *)v13 + 1) >> 15) & 0xFFFFFF01));
LABEL_7:
      *(float *)(a2 + 12) = v15;
      goto LABEL_44;
    case 0x13:
      *v3 = v5 + (unsigned __int16)word_10333C80;
      v49 = v6;
      v50 = &v6[(unsigned __int16)word_10333C80];
      sub_10030ED0(0, 11, a3, v3, 1u, 0, v50, (int *)(a2 + 36));
      *(_WORD *)(a2 + 36) = -1;
      v51 = sub_10030ED0(0, (unsigned __int8)*v49 >> 4, a3, v3, v49[1], 0, v50, (int *)(a2 + 44));
      *(_BYTE *)(a2 + 6) = ((unsigned __int8)*v49 >> 1) & 7;
      *(float *)(a2 + 40) = (double)*((_WORD *)v49 + 1) * 0.0001745329209370539;
      v69 = (_BYTE *)(a2 + 9);
      v68 = (_BYTE *)(a2 + 8);
      v67 = (_BYTE *)(a2 + 7);
      v66 = (float *)(a2 + 16);
      *(float *)(a2 + 48) = (double)(*((_WORD *)v49 + 2) & 0x3FFF) * 185.1999969482422;
      v9 = *((_WORD *)v49 + 2);
      v65 = (float *)(a2 + 12);
      v64 = (unsigned __int16 *)v51;
      v10 = *v49;
LABEL_3:
      v11 = sub_10032750(v10 & 1, (v9 >> 14) & 3, v3, v64, v65, v66, v67, v68, v69);
      goto LABEL_4;
    case 0x14:
      *v3 = v5 + (unsigned __int16)word_10333C82;
      v52 = v6;
      v53 = (unsigned __int16 *)&v6[(unsigned __int16)word_10333C82];
      sub_10030ED0(0, 11, a3, v3, 1u, 0, v53, (int *)(a2 + 36));
      *(_WORD *)(a2 + 36) = -1;
      *(float *)(a2 + 40) = (double)*(_WORD *)v52 * 0.0001745329209370539;
      v6 = (char *)sub_10032750(
                     ((unsigned __int8)v52[2] >> 2) & 1,
                     v52[2] & 3,
                     v3,
                     v53,
                     (float *)(a2 + 12),
                     (float *)(a2 + 16),
                     (_BYTE *)(a2 + 7),
                     (_BYTE *)(a2 + 8),
                     (_BYTE *)(a2 + 9));
      goto LABEL_44;
    case 0x15:
      *v3 = v5 + (unsigned __int16)word_10333C84;
      v54 = v6;
      v55 = (unsigned __int16 *)&v6[(unsigned __int16)word_10333C84];
      sub_10030ED0(0, 11, a3, v3, 1u, 0, v55, (int *)(a2 + 36));
      *(_WORD *)(a2 + 36) = -1;
      *(float *)(a2 + 40) = (double)*(_WORD *)v54 * 0.0001745329209370539;
      v6 = (char *)sub_10032750(
                     ((unsigned __int8)v54[2] >> 2) & 1,
                     v54[2] & 3,
                     v3,
                     v55,
                     (float *)(a2 + 12),
                     (float *)(a2 + 16),
                     (_BYTE *)(a2 + 7),
                     (_BYTE *)(a2 + 8),
                     (_BYTE *)(a2 + 9));
      goto LABEL_44;
    case 0x16:
      *v3 = v5 + (unsigned __int16)word_10333C86;
      v56 = v6;
      v57 = &v6[(unsigned __int16)word_10333C86];
      sub_10030ED0(0, 11, a3, v3, 1u, 0, v57, (int *)(a2 + 36));
      *(_WORD *)(a2 + 36) = -1;
      v58 = (unsigned __int16 *)sub_10030ED0(
                                  ((unsigned __int8)v56[6] >> 2) & 3,
                                  ((unsigned __int8)*v56 >> 4) & 0xF,
                                  a3,
                                  v3,
                                  v56[1],
                                  1,
                                  v57,
                                  (int *)(a2 + 44));
      *(_BYTE *)(a2 + 6) = ((unsigned __int8)*v56 >> 1) & 7;
      *(float *)(a2 + 40) = (double)*((_WORD *)v56 + 1) * 0.0001745329209370539;
      *(float *)(a2 + 48) = 0.0001745329209370539 * (double)*((_WORD *)v56 + 2);
      v11 = sub_10032750(
              *v56 & 1,
              v56[6] & 3,
              v3,
              v58,
              (float *)(a2 + 12),
              (float *)(a2 + 16),
              (_BYTE *)(a2 + 7),
              (_BYTE *)(a2 + 8),
              (_BYTE *)(a2 + 9));
LABEL_4:
      v6 = (char *)v11;
      goto LABEL_44;
    default:
      *(_BYTE *)a2 = 24;
      v71[0] = v4 & 0xBF;
      *v3 = 0xFFFFFF;
      goto LABEL_44;
  }
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C56: using guessed type __int16 word_10333C56;
// 10333C58: using guessed type __int16 word_10333C58;
// 10333C5A: using guessed type __int16 word_10333C5A;
// 10333C5C: using guessed type __int16 word_10333C5C;
// 10333C5E: using guessed type __int16 word_10333C5E;
// 10333C60: using guessed type __int16 word_10333C60;
// 10333C62: using guessed type __int16 word_10333C62;
// 10333C64: using guessed type __int16 word_10333C64;
// 10333C66: using guessed type __int16 word_10333C66;
// 10333C68: using guessed type __int16 word_10333C68;
// 10333C6A: using guessed type __int16 word_10333C6A;
// 10333C6C: using guessed type __int16 word_10333C6C;
// 10333C6E: using guessed type __int16 word_10333C6E;
// 10333C70: using guessed type __int16 word_10333C70;
// 10333C72: using guessed type __int16 word_10333C72;
// 10333C74: using guessed type __int16 word_10333C74;
// 10333C76: using guessed type __int16 word_10333C76;
// 10333C78: using guessed type __int16 word_10333C78;
// 10333C7A: using guessed type __int16 word_10333C7A;
// 10333C7C: using guessed type __int16 word_10333C7C;
// 10333C7E: using guessed type __int16 word_10333C7E;
// 10333C80: using guessed type __int16 word_10333C80;
// 10333C82: using guessed type __int16 word_10333C82;
// 10333C84: using guessed type __int16 word_10333C84;
// 10333C86: using guessed type __int16 word_10333C86;
// 10031550: using guessed type char var_38[52];

//----- (10032570) --------------------------------------------------------
void __usercall sub_10032570(unsigned int a1@<ebx>, int a2, int *a3, int a4)
{
  sub_10030F80(a4);
  if ( sub_10033390(*a3) && !sub_1002EC50(__PAIR__(a1, a2)) )
    sub_10031550(a3, a4, a2);
}
// 10032570: could not find valid save-restore pair for ebx

//----- (100325C0) --------------------------------------------------------
char __cdecl sub_100325C0(int a1, int a2, void *a3)
{
  signed int v3; // eax@1
  char result; // al@2
  char v5; // [sp+8h] [bp-8h]@1

  memset(a3, 0, 0x30u);
  sub_10036830(a1, &v5);
  v3 = sub_100314E0(a2);
  if ( v3 == 0xFFFFFF )
  {
    result = 0;
  }
  else
  {
    (*(void (__cdecl **)(signed int, signed int, void *))dword_103334D8)(v3, 43, a3);
    result = 1;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;

//----- (10032620) --------------------------------------------------------
char __cdecl sub_10032620(unsigned int a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@1
  char v5; // [sp+4h] [bp-8h]@1

  *(_DWORD *)a3 = 1600085855;
  *(_WORD *)(a3 + 4) = 24415;
  *(_BYTE *)(a3 + 6) = 0;
  *(_WORD *)(a3 + 7) = 0;
  *(_BYTE *)(a3 + 9) = 0;
  sub_10036830(a1, &v5);
  v3 = sub_10031450((int)&v5, a2);
  if ( v3 != 0xFFFFFF )
    LOBYTE(v3) = sub_10030CE0(a3, v3, word_10333C52);
  return v3;
}
// 10333C52: using guessed type __int16 word_10333C52;

//----- (10032680) --------------------------------------------------------
char __cdecl sub_10032680(unsigned int a1, unsigned __int8 a2, char a3, char a4, int a5)
{
  int v5; // eax@1
  char v7; // [sp+4h] [bp-8h]@1

  *(_DWORD *)a5 = 1600085855;
  *(_BYTE *)(a5 + 4) = 95;
  *(_BYTE *)(a5 + 5) = 0;
  *(_BYTE *)(a5 + 6) = 0;
  *(_DWORD *)(a5 + 8) = 0xFFFFFF;
  sub_10036830(a1, &v7);
  v5 = sub_100314B0(a2, (int)&v7, a3, a4);
  if ( v5 != 0xFFFFFF )
    LOBYTE(v5) = sub_10030D80(a5, v5);
  return v5;
}

//----- (100326F0) --------------------------------------------------------
double __cdecl sub_100326F0(int a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  int v4; // [sp+4h] [bp+4h]@1
  int v5; // [sp+4h] [bp+4h]@2
  int v6; // [sp+4h] [bp+4h]@3
  float v7; // [sp+8h] [bp+8h]@2
  float v8; // [sp+8h] [bp+8h]@3

  *(float *)&v4 = (double)(unsigned __int16)a1;
  v2 = *(float *)&v4;
  if ( LOBYTE(a2) )
  {
    *(float *)&v5 = v2 * 100.0;
    v7 = *(float *)&v5 * 0.3048000037670135;
    result = v7;
  }
  else
  {
    *(float *)&v6 = v2 - 1000.0;
    v8 = *(float *)&v6 * 0.3048000037670135;
    result = v8;
  }
  return result;
}

//----- (10032750) --------------------------------------------------------
int __cdecl sub_10032750(char a1, char a2, _DWORD *a3, unsigned __int16 *a4, float *a5, float *a6, _BYTE *a7, _BYTE *a8, _BYTE *a9)
{
  int v9; // ecx@2
  unsigned __int16 *v10; // ecx@2
  char v11; // dl@2
  int v12; // ecx@3
  int result; // eax@3

  *a5 = 0.0;
  *a6 = 0.0;
  *a7 = 4;
  *a8 = 0;
  *a9 = 0;
  if ( a1 )
  {
    *a5 = (double)(*a4 & 0x7FFF);
    *a7 = a2;
    *a8 = (*a4 >> 15) & 1;
    *a5 = sub_100326F0(*a4 & 0x7FFF, COERCE_FLOAT(((unsigned int)*a4 >> 15) & 0xFFFFFF01));
    *a3 += (unsigned __int16)word_10333C8A;
    v10 = (unsigned __int16 *)((unsigned __int16)word_10333C8A + v9);
    if ( v11 == 3 )
    {
      *a6 = (double)(*v10 & 0x7FFF);
      *a9 = (*v10 >> 15) & 1;
      *a6 = sub_100326F0(*v10 & 0x7FFF, COERCE_FLOAT(((unsigned int)*v10 >> 15) & 0xFFFFFF01));
      *a3 += (unsigned __int16)word_10333C8A;
      result = (unsigned __int16)word_10333C8A + v12;
    }
    else
    {
      result = (int)v10;
      *a6 = 0.0;
    }
  }
  else
  {
    result = (int)a4;
  }
  return result;
}
// 10333C8A: using guessed type __int16 word_10333C8A;

//----- (10032860) --------------------------------------------------------
bool __cdecl sub_10032860(int a1)
{
  int v1; // ebp@1
  int v2; // edi@1
  char v3; // bl@1
  char v4; // cl@1
  unsigned int v5; // eax@5
  unsigned int v6; // edx@5
  unsigned int v7; // ecx@5
  unsigned int v8; // eax@5
  signed int v9; // esi@5
  signed int v10; // ecx@7
  int v11; // edx@7
  unsigned int v12; // eax@8
  float v13; // ST18_4@9
  float v14; // ST18_4@9
  float v15; // ST18_4@9
  int v16; // ecx@11
  char v18; // [sp+Bh] [bp-29h]@1
  float v19; // [sp+Ch] [bp-28h]@1
  float v20; // [sp+14h] [bp-20h]@5
  float v21; // [sp+18h] [bp-1Ch]@5
  float v22; // [sp+1Ch] [bp-18h]@5
  float v23; // [sp+20h] [bp-14h]@5
  int v24; // [sp+24h] [bp-10h]@5
  unsigned int v25; // [sp+28h] [bp-Ch]@5
  unsigned int v26; // [sp+2Ch] [bp-8h]@5
  unsigned int v27; // [sp+30h] [bp-4h]@5
  char v28; // [sp+38h] [bp+4h]@1

  v19 = 0.0;
  v1 = dword_10333D50;
  v2 = a1;
  v3 = ((unsigned int)*(_WORD *)(a1 + 5) >> 15) & 1;
  v4 = ((unsigned int)*(_WORD *)(a1 + 5) >> 14) & 1;
  v18 = 0;
  v28 = ((unsigned int)*(_WORD *)(a1 + 5) >> 14) & 1;
  if ( v3 )
  {
    if ( *(float *)(dword_10333D50 + 20836) >= 0.30000001 && (*(_DWORD *)(v2 + 9) >> 28) & 1 )
      v18 = 1;
    v5 = *(_BYTE *)(v2 + 8);
    v24 = *(_BYTE *)(v2 + 8) & 3;
    v6 = v5 >> 2;
    v7 = v5;
    v27 = v5 >> 6;
    v8 = *(_DWORD *)(v2 + 9);
    v25 = v6 & 3;
    v26 = (v7 >> 4) & 3;
    v20 = (double)(v8 & 0x7F);
    v21 = (double)((v8 >> 7) & 0x7F);
    v22 = (double)((v8 >> 14) & 0x7F);
    v23 = (double)((v8 >> 21) & 0x7F);
    v9 = 0;
    do
    {
      if ( 0.0 != *(float *)((char *)&v20 + v9) )
      {
        v10 = *(int *)((char *)&v24 + v9);
        v11 = 0;
        if ( v10 >= 4 )
        {
          v12 = ((unsigned int)(v10 - 4) >> 2) + 1;
          v11 = 4 * v12;
          do
          {
            --v12;
            v13 = *(float *)((char *)&v20 + v9) * 0.1000000014901161;
            v14 = v13 * 0.1000000014901161;
            v15 = v14 * 0.1000000014901161;
            *(float *)((char *)&v20 + v9) = v15;
          }
          while ( v12 );
        }
        if ( v11 < v10 )
        {
          v16 = v10 - v11;
          do
          {
            --v16;
            *(float *)((char *)&v20 + v9) = *(float *)((char *)&v20 + v9) * 0.1000000014901161;
          }
          while ( v16 );
        }
      }
      if ( *(float *)(v1 + 20836) <= (double)*(float *)((char *)&v20 + v9) )
        v19 = *(float *)((char *)&v20 + v9);
      v9 += 4;
    }
    while ( v9 < 16 );
    v4 = v28;
  }
  return !(*(_WORD *)(v2 + 5) & 0x2000)
      && (!v3 || *(_BYTE *)(v1 + 20832) && 0.0 != v19)
      && (!v4 || *(_BYTE *)(v1 + 20833))
      && !v18;
}
// 10333D50: using guessed type int dword_10333D50;

//----- (10032A50) --------------------------------------------------------
char __cdecl sub_10032A50(_DWORD *a1, unsigned __int8 a2, _BYTE *a3)
{
  char result; // al@2

  if ( !byte_103334DC )
  {
    result = dword_103334D0;
    if ( dword_103334D0 == *a1 )
    {
      result = byte_103334CC;
      if ( (unsigned __int8)byte_103334CC <= a2 && a2 != -1 )
      {
        *a3 = byte_103334CC;
        result = dword_103334E0;
        *a1 = dword_103334E0;
        byte_103334DC = 0;
      }
    }
  }
  return result;
}
// 103334CC: using guessed type char byte_103334CC;
// 103334D0: using guessed type int dword_103334D0;
// 103334DC: using guessed type char byte_103334DC;
// 103334E0: using guessed type int dword_103334E0;

//----- (10032A90) --------------------------------------------------------
int __cdecl sub_10032A90(unsigned __int16 a1, int a2)
{
  char v3; // [sp+4h] [bp-Ch]@3
  char v4; // [sp+7h] [bp-9h]@3

  if ( a1 == -1 )
  {
    *(_DWORD *)a2 = 538976288;
    *(_WORD *)(a2 + 4) = 32;
  }
  else
  {
    (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(
      dword_10333590 + a1 * (unsigned __int16)word_10333594,
      5,
      &v3);
    sub_1003A7A0(&v4, 5, a2);
  }
  return sub_100423E0(a2, 5);
}
// 103334D8: using guessed type int dword_103334D8;
// 10333590: using guessed type int dword_10333590;
// 10333594: using guessed type __int16 word_10333594;

//----- (10032B20) --------------------------------------------------------
int __cdecl sub_10032B20(int *a1)
{
  char v1; // dl@1
  int result; // eax@1
  char v3; // [sp+4h] [bp-10h]@1
  char v4; // [sp+7h] [bp-Dh]@1

  (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(*a1, 14, &v3);
  v1 = v4;
  *a1 += (unsigned __int16)word_10333C48;
  result = *a1;
  if ( (v1 & 0xFu) <= 3 )
    *a1 = result + (unsigned __int16)word_10333C4A;
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C48: using guessed type __int16 word_10333C48;
// 10333C4A: using guessed type __int16 word_10333C4A;

//----- (10032B70) --------------------------------------------------------
char __cdecl sub_10032B70(int a1, int a2, void *a3)
{
  float *v3; // ebp@1
  char *v4; // ebx@1
  int v5; // eax@1
  char v6; // dl@1
  char *v7; // eax@1
  int v8; // edx@2
  char *v9; // ecx@3
  int v10; // eax@3
  int v11; // edx@7
  double v12; // st7@12
  char *v13; // ecx@14
  unsigned __int16 *v14; // eax@14
  char *v15; // ecx@17
  unsigned __int16 *v16; // eax@17
  int v17; // edx@21
  int v18; // edx@32
  int v19; // edx@42
  int v20; // edx@56
  char v21; // al@60
  unsigned __int8 v22; // al@61
  unsigned __int16 *v24; // [sp-18h] [bp-68h]@9
  float *v25; // [sp-14h] [bp-64h]@9
  float *v26; // [sp-10h] [bp-60h]@9
  float *v27; // [sp-10h] [bp-60h]@56
  char *v28; // [sp-Ch] [bp-5Ch]@9
  char *v29; // [sp-Ch] [bp-5Ch]@56
  char *v30; // [sp-8h] [bp-58h]@9
  char *v31; // [sp-8h] [bp-58h]@56
  char *v32; // [sp-4h] [bp-54h]@9
  char *v33; // [sp-4h] [bp-54h]@56
  char *v34; // [sp+10h] [bp-40h]@3
  char *v35; // [sp+10h] [bp-40h]@14
  char *v36; // [sp+10h] [bp-40h]@17
  char *v37; // [sp+10h] [bp-40h]@22
  char *v38; // [sp+10h] [bp-40h]@25
  char *v39; // [sp+10h] [bp-40h]@33
  char *v40; // [sp+10h] [bp-40h]@36
  char *v41; // [sp+10h] [bp-40h]@43
  char *v42; // [sp+10h] [bp-40h]@46
  char *v43; // [sp+10h] [bp-40h]@51
  float *v44; // [sp+14h] [bp-3Ch]@1
  int v45; // [sp+18h] [bp-38h]@1

  memset(a3, 0, 0x3Cu);
  *((float *)a3 + 3) = 9.9999996e24;
  *((float *)a3 + 4) = 9.9999996e24;
  *((_BYTE *)a3 + 7) = 4;
  v3 = (float *)((char *)a3 + 12);
  v4 = (char *)a3 + 7;
  v44 = (float *)((char *)a3 + 16);
  (*(void (__cdecl **)(_DWORD, signed int, int *))dword_103334D8)(*(_DWORD *)a1, 50, &v45);
  *(_DWORD *)a1 += (unsigned __int16)word_10333C56;
  v5 = (unsigned __int16)word_10333C56;
  v6 = v45 & 0x1F;
  *(_BYTE *)a2 = 0;
  *(_BYTE *)a3 = v6;
  v7 = (char *)&v45 + v5;
  switch ( v45 & 0x1F )
  {
    case 0:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_10333C5A;
      v8 = (unsigned __int16)word_10333C5A;
      goto LABEL_3;
    case 1:
      *(_DWORD *)a1 += (unsigned __int16)word_10333C5C;
      *v4 = 1;
      v12 = sub_100326F0(
              *((_WORD *)v7 + 1) & 0x7FFF,
              COERCE_FLOAT(((unsigned int)*((_WORD *)v7 + 1) >> 15) & 0xFFFFFF01));
      goto LABEL_13;
    case 2:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_10333C5E;
      v35 = v7;
      v13 = v7;
      v14 = (unsigned __int16 *)&v7[(unsigned __int16)word_10333C5E];
      if ( (*v13 & 0xF0u) <= 0x30 )
      {
        *(_DWORD *)a1 += (unsigned __int16)word_10333C88;
        v13 = v35;
        v14 = (unsigned __int16 *)((char *)v14 + (unsigned __int16)word_10333C88);
      }
      sub_10032750(
        *v13 & 1,
        (*((_WORD *)v13 + 2) >> 14) & 3,
        (_DWORD *)a1,
        v14,
        v3,
        v44,
        v4,
        (_BYTE *)a3 + 8,
        (_BYTE *)a3 + 9);
      break;
    case 3:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_10333C60;
      v36 = v7;
      v15 = v7;
      v16 = (unsigned __int16 *)&v7[(unsigned __int16)word_10333C60];
      if ( (*v15 & 0xF0u) <= 0x30 )
      {
        *(_DWORD *)a1 += (unsigned __int16)word_10333C88;
        v15 = v36;
        v16 = (unsigned __int16 *)((char *)v16 + (unsigned __int16)word_10333C88);
      }
      sub_10032750(
        *v15 & 1,
        (*((_WORD *)v15 + 2) >> 14) & 3,
        (_DWORD *)a1,
        v16,
        v3,
        v44,
        v4,
        (_BYTE *)a3 + 8,
        (_BYTE *)a3 + 9);
      break;
    case 4:
      *(_DWORD *)a1 += (unsigned __int16)word_10333C62;
      sub_10032750(
        ((unsigned __int8)v7[2] >> 2) & 1,
        v7[2] & 3,
        (_DWORD *)a1,
        (unsigned __int16 *)&v7[(unsigned __int16)word_10333C62],
        v3,
        v44,
        v4,
        (_BYTE *)a3 + 8,
        (_BYTE *)a3 + 9);
      break;
    case 5:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_10333C64;
      v17 = (unsigned __int16)word_10333C64;
      goto LABEL_22;
    case 6:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      v38 = v7;
      if ( (*v7 & 0xF0u) <= 0x30 )
      {
        *(_DWORD *)a1 += (unsigned __int16)word_10333C8C;
        v7 += (unsigned __int16)word_10333C8C;
      }
      *(_DWORD *)a1 += (unsigned __int16)word_10333C66;
      sub_10032750(
        *v38 & 1,
        v38[2] & 3,
        (_DWORD *)a1,
        (unsigned __int16 *)&v7[(unsigned __int16)word_10333C66],
        v3,
        v44,
        v4,
        (_BYTE *)a3 + 8,
        (_BYTE *)a3 + 9);
      break;
    case 7:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      if ( (*v7 & 0xF0u) <= 0x30 )
        *(_DWORD *)a1 += (unsigned __int16)word_10333C88;
      *(_DWORD *)a1 += (unsigned __int16)word_10333C68;
      *v4 = 1;
      v12 = sub_100326F0(
              *((_WORD *)v7 + 2) & 0x7FFF,
              COERCE_FLOAT(((unsigned int)*((_WORD *)v7 + 2) >> 15) & 0xFFFFFF01));
      goto LABEL_13;
    case 8:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_10333C6A;
      v18 = (unsigned __int16)word_10333C6A;
      goto LABEL_33;
    case 9:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_10333C6C;
      v8 = (unsigned __int16)word_10333C6C;
      goto LABEL_3;
    case 0xA:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_10333C6E;
      v40 = v7;
      v9 = v7;
      v10 = (int)&v7[(unsigned __int16)word_10333C6E];
      if ( (*v9 & 0xF0u) <= 0x30 )
      {
        *(_DWORD *)a1 += (unsigned __int16)word_10333C8C;
        v9 = v40;
        v10 += (unsigned __int16)word_10333C8C;
      }
      v32 = (char *)a3 + 9;
      v30 = (char *)a3 + 8;
      v28 = (char *)a3 + 7;
      v26 = (float *)((char *)a3 + 16);
      v25 = (float *)((char *)a3 + 12);
      v24 = (unsigned __int16 *)v10;
      LOBYTE(v10) = v9[4];
      goto LABEL_10;
    case 0xB:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      if ( (*v7 & 0xF0u) <= 0x30 )
        *(_DWORD *)a1 += (unsigned __int16)word_10333C8C;
      *(_DWORD *)a1 += (unsigned __int16)word_10333C70;
      *v4 = 1;
      v12 = sub_100326F0(
              *((_WORD *)v7 + 2) & 0x7FFF,
              COERCE_FLOAT(((unsigned int)*((_WORD *)v7 + 2) >> 15) & 0xFFFFFF01));
      goto LABEL_13;
    case 0xC:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_10333C72;
      v19 = (unsigned __int16)word_10333C72;
      goto LABEL_43;
    case 0xD:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_10333C74;
      v19 = (unsigned __int16)word_10333C74;
LABEL_43:
      v41 = v7;
      v9 = v7;
      v10 = (int)&v7[v19];
      if ( (*v9 & 0xF0u) > 0x30 )
        goto LABEL_9;
      *(_DWORD *)a1 += (unsigned __int16)word_10333C8C;
      v11 = (unsigned __int16)word_10333C8C;
      v9 = v41;
      goto LABEL_8;
    case 0xE:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      v42 = v7;
      if ( (*v7 & 0xF0u) <= 0x30 )
      {
        *(_DWORD *)a1 += (unsigned __int16)word_10333C8C;
        v7 += (unsigned __int16)word_10333C8C;
      }
      *(_DWORD *)a1 += (unsigned __int16)word_10333C76;
      sub_10032750(
        *v42 & 1,
        v42[2] & 3,
        (_DWORD *)a1,
        (unsigned __int16 *)&v7[(unsigned __int16)word_10333C76],
        v3,
        v44,
        v4,
        (_BYTE *)a3 + 8,
        (_BYTE *)a3 + 9);
      break;
    case 0xF:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_10333C78;
      v18 = (unsigned __int16)word_10333C78;
      goto LABEL_33;
    case 0x10:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_10333C7A;
      v8 = (unsigned __int16)word_10333C7A;
LABEL_3:
      v34 = v7;
      v9 = v7;
      v10 = (int)&v7[v8];
      if ( (*v9 & 0xF0u) <= 0x30 )
      {
        *(_DWORD *)a1 += (unsigned __int16)word_10333C88;
        v9 = v34;
        v10 += (unsigned __int16)word_10333C88;
      }
      if ( (v9[2] & 0xF0u) > 0x30 )
        goto LABEL_9;
      *(_DWORD *)a1 += (unsigned __int16)word_10333C88;
      goto LABEL_7;
    case 0x11:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      v43 = v7;
      if ( (*v7 & 0xF0u) <= 0x30 )
      {
        *(_DWORD *)a1 += (unsigned __int16)word_10333C8C;
        v7 += (unsigned __int16)word_10333C8C;
      }
      *(_DWORD *)a1 += (unsigned __int16)word_10333C7C;
      sub_10032750(
        *v43 & 1,
        v43[2] & 3,
        (_DWORD *)a1,
        (unsigned __int16 *)&v7[(unsigned __int16)word_10333C7C],
        v3,
        v44,
        v4,
        (_BYTE *)a3 + 8,
        (_BYTE *)a3 + 9);
      break;
    case 0x12:
      *(_DWORD *)a1 += (unsigned __int16)word_10333C7E;
      *v4 = 1;
      v12 = sub_100326F0(
              *((_WORD *)v7 + 1) & 0x7FFF,
              COERCE_FLOAT(((unsigned int)*((_WORD *)v7 + 1) >> 15) & 0xFFFFFF01));
LABEL_13:
      *v3 = v12;
      break;
    case 0x13:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_10333C80;
      v18 = (unsigned __int16)word_10333C80;
LABEL_33:
      v39 = v7;
      v9 = v7;
      v10 = (int)&v7[v18];
      if ( (*v9 & 0xF0u) <= 0x30 )
      {
        *(_DWORD *)a1 += (unsigned __int16)word_10333C88;
        v9 = v39;
LABEL_7:
        v11 = (unsigned __int16)word_10333C88;
LABEL_8:
        v10 += v11;
      }
LABEL_9:
      v32 = (char *)a3 + 9;
      v30 = (char *)a3 + 8;
      v28 = (char *)a3 + 7;
      v26 = (float *)((char *)a3 + 16);
      v25 = (float *)((char *)a3 + 12);
      v24 = (unsigned __int16 *)v10;
      LOWORD(v10) = *((_WORD *)v9 + 2) >> 14;
      goto LABEL_10;
    case 0x14:
      *(_DWORD *)a1 += (unsigned __int16)word_10333C82;
      v33 = (char *)a3 + 9;
      v31 = (char *)a3 + 8;
      v29 = (char *)a3 + 7;
      v27 = (float *)((char *)a3 + 16);
      v20 = (unsigned __int16)word_10333C82;
      goto LABEL_57;
    case 0x15:
      *(_DWORD *)a1 += (unsigned __int16)word_10333C84;
      v33 = (char *)a3 + 9;
      v31 = (char *)a3 + 8;
      v29 = (char *)a3 + 7;
      v27 = (float *)((char *)a3 + 16);
      v20 = (unsigned __int16)word_10333C84;
LABEL_57:
      sub_10032750(
        ((unsigned __int8)v7[2] >> 2) & 1,
        v7[2] & 3,
        (_DWORD *)a1,
        (unsigned __int16 *)&v7[v20],
        v3,
        v27,
        v29,
        v31,
        v33);
      break;
    case 0x16:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_10333C86;
      v17 = (unsigned __int16)word_10333C86;
LABEL_22:
      v37 = v7;
      v9 = v7;
      v10 = (int)&v7[v17];
      if ( (*v9 & 0xF0u) <= 0x30 )
      {
        *(_DWORD *)a1 += (unsigned __int16)word_10333C8C;
        v9 = v37;
        v10 += (unsigned __int16)word_10333C8C;
      }
      v32 = (char *)a3 + 9;
      v30 = (char *)a3 + 8;
      v28 = (char *)a3 + 7;
      v26 = (float *)((char *)a3 + 16);
      v25 = (float *)((char *)a3 + 12);
      v24 = (unsigned __int16 *)v10;
      LOBYTE(v10) = v9[6];
LABEL_10:
      sub_10032750(*v9 & 1, v10 & 3, (_DWORD *)a1, v24, v25, v26, v28, v30, v32);
      break;
    default:
      v21 = v45 & 0x3F;
      *(_BYTE *)a3 = 24;
      LOBYTE(v45) = v21;
      *(_DWORD *)a1 = 0xFFFFFF;
      break;
  }
  v22 = v45;
  if ( v45 & 0x40 )
    *(_DWORD *)a1 += (unsigned __int16)word_10333C58;
  return v22 >> 7;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C56: using guessed type __int16 word_10333C56;
// 10333C58: using guessed type __int16 word_10333C58;
// 10333C5A: using guessed type __int16 word_10333C5A;
// 10333C5C: using guessed type __int16 word_10333C5C;
// 10333C5E: using guessed type __int16 word_10333C5E;
// 10333C60: using guessed type __int16 word_10333C60;
// 10333C62: using guessed type __int16 word_10333C62;
// 10333C64: using guessed type __int16 word_10333C64;
// 10333C66: using guessed type __int16 word_10333C66;
// 10333C68: using guessed type __int16 word_10333C68;
// 10333C6A: using guessed type __int16 word_10333C6A;
// 10333C6C: using guessed type __int16 word_10333C6C;
// 10333C6E: using guessed type __int16 word_10333C6E;
// 10333C70: using guessed type __int16 word_10333C70;
// 10333C72: using guessed type __int16 word_10333C72;
// 10333C74: using guessed type __int16 word_10333C74;
// 10333C76: using guessed type __int16 word_10333C76;
// 10333C78: using guessed type __int16 word_10333C78;
// 10333C7A: using guessed type __int16 word_10333C7A;
// 10333C7C: using guessed type __int16 word_10333C7C;
// 10333C7E: using guessed type __int16 word_10333C7E;
// 10333C80: using guessed type __int16 word_10333C80;
// 10333C82: using guessed type __int16 word_10333C82;
// 10333C84: using guessed type __int16 word_10333C84;
// 10333C86: using guessed type __int16 word_10333C86;
// 10333C88: using guessed type __int16 word_10333C88;
// 10333C8C: using guessed type __int16 word_10333C8C;

//----- (100332D0) --------------------------------------------------------
char __cdecl sub_100332D0(int a1, _BYTE *a2)
{
  _BYTE *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-3Ch]@2

  v2 = a2;
  *a2 = 0;
  do
  {
    ++*v2;
    result = sub_10032B70(a1, (int)&a2, &v4);
  }
  while ( result );
  return result;
}

//----- (10033300) --------------------------------------------------------
char __cdecl sub_10033300(_DWORD *a1)
{
  _DWORD *v1; // esi@1
  char result; // al@2
  char v3; // [sp+4h] [bp-4h]@2

  v1 = a1;
  do
  {
    (*(void (__cdecl **)(_DWORD, signed int, char *))dword_103334D8)(*v1, 3, &v3);
    *v1 += (unsigned __int16)word_10333C54;
    result = sub_100332D0((int)v1, &a1);
  }
  while ( v3 & 1 );
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C54: using guessed type __int16 word_10333C54;

//----- (10033350) --------------------------------------------------------
int __cdecl sub_10033350(int a1, char a2, int a3)
{
  int result; // eax@3

  if ( !byte_103334DC && a1 != 0xFFFFFF )
  {
    result = a3;
    if ( a3 != 0xFFFFFF )
    {
      byte_103334CC = a2;
      dword_103334E0 = a3;
      dword_103334D0 = a1;
      byte_103334DC = 0;
    }
  }
  return result;
}
// 103334CC: using guessed type char byte_103334CC;
// 103334D0: using guessed type int dword_103334D0;
// 103334DC: using guessed type char byte_103334DC;
// 103334E0: using guessed type int dword_103334E0;

//----- (10033390) --------------------------------------------------------
bool __cdecl sub_10033390(unsigned int a1)
{
  return sub_10043FB0(a1, 0xBu);
}

//----- (100333A0) --------------------------------------------------------
signed int __cdecl sub_100333A0(unsigned int a1, int a2)
{
  signed int v2; // esi@1
  char v3; // dl@2
  char v4; // al@3
  char v5; // bl@3
  signed int result; // eax@7
  char v7; // [sp+8h] [bp-18h]@3
  char v8; // [sp+Ch] [bp-14h]@3
  char v9; // [sp+Dh] [bp-13h]@3
  char v10; // [sp+Eh] [bp-12h]@3
  char v11; // [sp+Fh] [bp-11h]@3
  char v12; // [sp+10h] [bp-10h]@3
  char v13; // [sp+11h] [bp-Fh]@3
  char v14; // [sp+14h] [bp-Ch]@4

  v2 = 0x3FFFF;
  if ( ((unsigned __int8)byte_10127BB0[2 * *(_BYTE *)(a2 + 1)] >> 4) & 1 )
  {
    v3 = *(_BYTE *)(a2 + 2);
    if ( ((unsigned __int8)byte_10127BB0[2 * (unsigned __int8)v3] >> 4) & 1 )
    {
      v4 = *(_BYTE *)(a2 + 3);
      v10 = *(_BYTE *)(a2 + 1);
      v8 = 82;
      v9 = 87;
      v11 = v3;
      v12 = v4;
      v13 = 0;
      sub_100423E0((int)&v8, 6);
      v5 = sub_100370D0(a1);
      v7 = 0;
      if ( v5 > 0 )
      {
        while ( 1 )
        {
          v2 = sub_10036B20(a1, v7, 0);
          sub_1002E110(v2, (int)&v14);
          if ( !strcmp(&v8, &v14) )
            break;
          v2 = sub_10036B20(a1, v7, 1);
          sub_1002E110(v2, (int)&v14);
          if ( !strcmp(&v8, &v14) )
            break;
          if ( ++v7 >= v5 )
            return 0x3FFFF;
        }
      }
    }
    result = v2;
  }
  else
  {
    result = 0x3FFFF;
  }
  return result;
}

//----- (10033530) --------------------------------------------------------
void __usercall sub_10033530(int a1@<esi>, int a2, unsigned int a3, _BYTE *a4)
{
  int v4; // ebx@1
  _BYTE *v5; // ebp@1
  float v6; // edi@1
  unsigned __int8 v7; // cl@1
  int v8; // ebx@1
  unsigned __int16 v9; // ax@1
  int v10; // eax@4
  unsigned __int8 v11; // al@7
  unsigned int v12; // ecx@7
  unsigned __int16 v13; // ax@7
  float *v14; // ecx@9
  _BYTE *v15; // eax@9
  float *v16; // edx@9
  signed int v17; // edi@9
  __int16 v18; // di@12
  unsigned __int8 v19; // dl@13
  unsigned int v20; // eax@13
  char v21; // cl@13
  int v22; // eax@13
  int v23; // eax@20
  int v24; // eax@27
  unsigned int v25; // eax@32
  _BYTE *v26; // ebx@32
  int *v27; // ebp@32
  int v28; // edx@34
  int v29; // edi@34
  bool v30; // sf@34
  unsigned __int8 v31; // of@34
  unsigned int v32; // eax@35
  int v33; // edx@38
  int v34; // edi@48
  char v35; // bl@49
  char v36; // al@51
  char v37; // cl@51
  double v38; // st7@60
  signed int v39; // edi@60
  char v40; // cl@61
  signed int v41; // ebp@68
  int v42; // [sp+Eh] [bp-72h]@4
  float v43; // [sp+14h] [bp-6Ch]@5
  float v44; // [sp+18h] [bp-68h]@7
  float v45; // [sp+1Ch] [bp-64h]@68
  float v46; // [sp+20h] [bp-60h]@32
  unsigned __int8 v47; // [sp+24h] [bp-5Ch]@1
  unsigned __int16 v48; // [sp+25h] [bp-5Bh]@7
  unsigned int v49; // [sp+27h] [bp-59h]@1
  char v50; // [sp+2Bh] [bp-55h]@8
  unsigned __int8 v51; // [sp+2Ch] [bp-54h]@13
  unsigned int v52; // [sp+2Dh] [bp-53h]@13
  int v53; // [sp+34h] [bp-4Ch]@32
  unsigned int v54; // [sp+38h] [bp-48h]@32
  unsigned int v55; // [sp+3Ch] [bp-44h]@32
  unsigned int v56; // [sp+40h] [bp-40h]@32
  char v57; // [sp+44h] [bp-3Ch]@51
  float v58; // [sp+50h] [bp-30h]@55

  v4 = a2;
  v5 = a4;
  v6 = *(float *)&a3;
  (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_103334D8)(a2, 14, &v47);
  v7 = v49;
  v8 = (unsigned __int16)word_10333C48 + v4;
  v9 = v49 & 0xF;
  a2 = v8;
  if ( v9 == 9 )
  {
    *(_DWORD *)(a1 + 24) = 0x3FFFF;
  }
  else
  {
    if ( v9 > 3u )
    {
      v43 = v6;
      HIWORD(v43) = (v9 << 10) | (v49 >> 6) & 0x3FC | BYTE2(v6) & 3;
      v10 = LODWORD(v43);
    }
    else
    {
      (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(v8, 1, (char *)&v42 + 1);
      a2 = (unsigned __int16)word_10333C4A + v8;
      v10 = sub_1002E300(
              v49 & 0xF,
              ((unsigned int)(unsigned __int16)v49 >> 8) & 0xFC00FF | ((4 * BYTE1(v42) | HIWORD(v49) & 0xC00) << 6));
      v7 = v49;
    }
    *(_DWORD *)(a1 + 24) = v10;
  }
  v11 = v47;
  *(_BYTE *)(a1 + 8) = (v7 >> 7) & 1;
  *(_BYTE *)(a1 + 9) = (v11 >> 6) & 1;
  v12 = *(unsigned int *)((char *)&v49 + 2);
  *(_BYTE *)(a1 + 7) = v11 >> 7;
  LODWORD(v44) = v12 & 0x3FF;
  *(_BYTE *)(a1 + 6) = (v11 >> 1) & 0x1F;
  v13 = v48;
  *(float *)(a1 + 48) = (double)(v12 & 0x3FF) * 0.0001745329209370539;
  *(_BYTE *)(a1 + 10) = (v12 >> 12) & 1;
  sub_10032A90(v13, a1);
  *(_BYTE *)(a1 + 21) = -1;
  if ( (unsigned __int16)word_10333C48 >= 8u )
    *(_BYTE *)(a1 + 21) = v50;
  v14 = (float *)(a1 + 32);
  v15 = (_BYTE *)(a1 + 17);
  v16 = (float *)(a1 + 32);
  v17 = 4;
  do
  {
    *(v15 - 4) = 15;
    *v15 = 63;
    *v16 = 0.0;
    ++v16;
    ++v15;
    --v17;
  }
  while ( v17 );
  if ( (unsigned __int16)word_10333C48 < 0xDu )
  {
    if ( *(_BYTE *)(a1 + 9) )
      *(_BYTE *)(a1 + 13) = 0;
    goto LABEL_47;
  }
  v18 = HIWORD(v49);
  if ( HIWORD(v49) & 0x8000 )
  {
    v53 = v51 & 3;
    v54 = ((unsigned int)v51 >> 2) & 3;
    v56 = (unsigned int)v51 >> 6;
    v25 = v52;
    v55 = ((unsigned int)v51 >> 4) & 3;
    LODWORD(v46) = v52 & 0x7F;
    *v14 = (double)LODWORD(v46);
    LODWORD(v46) = (v25 >> 7) & 0x7F;
    *(float *)(a1 + 36) = (double)LODWORD(v46);
    LODWORD(v46) = (v25 >> 14) & 0x7F;
    *(float *)(a1 + 40) = (double)LODWORD(v46);
    LODWORD(v46) = (v25 >> 21) & 0x7F;
    *(float *)(a1 + 44) = (double)LODWORD(v46);
    v26 = (_BYTE *)(a1 + 13);
    v27 = &v53;
    LODWORD(v43) = 4;
    while ( 1 )
    {
      if ( 0.0 != *v14 )
      {
        v28 = *v27;
        v29 = 0;
        v31 = __OFSUB__(*v27, 4);
        v30 = *v27 - 4 < 0;
        *v26 = 4;
        if ( !(v30 ^ v31) )
        {
          v32 = ((unsigned int)(v28 - 4) >> 2) + 1;
          v29 = 4 * v32;
          do
          {
            --v32;
            v44 = *v14 * 0.1000000014901161;
            v44 = v44 * 0.1000000014901161;
            v44 = v44 * 0.1000000014901161;
            *v14 = v44;
          }
          while ( v32 );
        }
        if ( v29 < v28 )
        {
          v33 = v28 - v29;
          do
          {
            --v33;
            *v14 = *v14 * 0.1000000014901161;
          }
          while ( v33 );
        }
        if ( *(float *)(dword_10333D50 + 20836) <= (double)*v14 )
          goto LABEL_43;
        *v14 = 0.0;
      }
      *v26 = 15;
LABEL_43:
      ++v27;
      ++v14;
      ++v26;
      --LODWORD(v43);
      if ( v43 == 0.0 )
        goto LABEL_47;
    }
  }
  v19 = v51;
  *(_BYTE *)(a1 + 14) = v51 >> 4;
  v20 = v52;
  v21 = v52 & 0xF;
  *(_BYTE *)(a1 + 13) = v19 & 0xF;
  *(_BYTE *)(a1 + 15) = v21;
  *(_BYTE *)(a1 + 16) = (v20 >> 4) & 0xF;
  *(_BYTE *)(a1 + 17) = BYTE1(v20) & 0x3F;
  *(_BYTE *)(a1 + 20) = (v20 >> 26) & 0x3F;
  *(_BYTE *)(a1 + 18) = (v20 >> 14) & 0x3F;
  *(_BYTE *)(a1 + 19) = (v20 >> 20) & 0x3F;
  v22 = 0;
  while ( *(_BYTE *)(a1 + v22 + 13) != 3 )
  {
    if ( ++v22 >= 4 )
      goto LABEL_18;
  }
  *(_BYTE *)(a1 + 9) = 1;
LABEL_18:
  if ( !*v5 )
  {
    if ( v18 & 0x4000 )
    {
      v23 = 0;
      while ( *(_BYTE *)(a1 + v23 + 13) != 15 )
      {
        if ( ++v23 >= 4 )
          goto LABEL_25;
      }
      *(_BYTE *)(v23 + a1 + 13) = 2;
    }
LABEL_25:
    if ( !*v5 && v18 & 0x2000 )
    {
      v24 = 0;
      while ( *(_BYTE *)(a1 + v24 + 13) != 15 )
      {
        if ( ++v24 >= 4 )
          goto LABEL_47;
      }
      *(_BYTE *)(v24 + a1 + 13) = 1;
    }
  }
LABEL_47:
  *(_BYTE *)(a1 + 11) = 0;
  v43 = 9.9999996e24;
  *(_BYTE *)(a1 + 12) = 0;
  v44 = 9.9999996e24;
  do
  {
    v34 = a2;
    (*(void (__cdecl **)(_DWORD, signed int, char *))dword_103334D8)(a2, 3, (char *)&v42 + 2);
    a2 = (unsigned __int16)word_10333C4C + v34;
    if ( BYTE2(v42) & 1 )
    {
      ++*(_BYTE *)(a1 + 11);
      v35 = 1;
    }
    else
    {
      v35 = 0;
    }
    do
    {
      v36 = sub_10032B70((int)&a2, (int)&v42, &v57);
      v37 = v42;
      if ( (_BYTE)v42 == 1 || v35 )
        ++*(_BYTE *)(a1 + 12);
      if ( v37 == 2 )
      {
        v43 = v58;
      }
      else if ( v37 == 3 )
      {
        v44 = v58;
      }
      v35 = 0;
    }
    while ( v36 );
  }
  while ( BYTE2(v42) & 1 );
  v38 = v43;
  v39 = 3;
  do
  {
    v40 = *(_BYTE *)(a1 + v39 + 13);
    LOBYTE(v42) = 1;
    if ( v40 == 3 && (v38 < -304.8 || v38 > 7620.0) )
      LOBYTE(v42) = 0;
    if ( (v40 == 2 || v40 == 1 || v40 == 4)
      && ((v41 = sub_100333A0(a3, a1), v45 = sub_100371F0(v41), v46 = sub_10037270(v41), v38 = v43, v43 > 7620.0)
       || v44 > v38
       || v45 > (double)v44
       || v45 < -304.8
       || *(float *)(a1 + 48) <= 0.0
       || *(float *)(a1 + 48) >= 0.1745329251994333
       || v46 < -150.0
       || v46 > 150.0)
      || !(_BYTE)v42 )
    {
      if ( v39 < 3 )
      {
        memcpy_0((void *)(a1 + v39 + 13), (const void *)(v39 + a1 + 14), 3 - v39);
        memcpy_0((void *)(a1 + v39 + 17), (const void *)(v39 + a1 + 18), 3 - v39);
        v38 = v43;
      }
      *(_BYTE *)(a1 + 16) = 15;
      *(_BYTE *)(a1 + 20) = 63;
    }
    --v39;
  }
  while ( v39 >= 0 );
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C48: using guessed type __int16 word_10333C48;
// 10333C4A: using guessed type __int16 word_10333C4A;
// 10333C4C: using guessed type __int16 word_10333C4C;
// 10333D50: using guessed type int dword_10333D50;

//----- (10033AF0) --------------------------------------------------------
int __cdecl sub_10033AF0(__int16 a1, unsigned __int16 a2)
{
  _DWORD *v2; // ecx@0
  int result; // eax@1

  result = 0;
  if ( a1 )
  {
    *v2 += a2;
    result = (unsigned __int16)word_10333C22;
  }
  return result;
}
// 10333C22: using guessed type __int16 word_10333C22;

//----- (10033B10) --------------------------------------------------------
signed int __cdecl sub_10033B10(int a1)
{
  signed int result; // eax@1
  int v2; // edi@2
  int v3; // ST4C_4@2
  unsigned int v4; // ebx@2
  int v5; // eax@2
  int v6; // eax@2
  int v7; // edx@2
  int v8; // eax@2
  int v9; // edx@2
  int v10; // eax@2
  int v11; // edx@2
  int v12; // eax@2
  int v13; // edx@2
  int v14; // eax@2
  int v15; // edx@2
  int v16; // eax@2
  int v17; // edx@2
  int v18; // eax@2
  int v19; // edx@2
  int v20; // [sp+8h] [bp-A4h]@2

  result = 0xFFFFFF;
  if ( *(_WORD *)(a1 + 4) & 0x400 )
  {
    v2 = *(_DWORD *)a1;
    v3 = v2 + sub_100361F0(a1);
    (*(void (__cdecl **)(int, signed int, int *))dword_103334D8)(v2, 160, &v20);
    v4 = *(_WORD *)(a1 + 4);
    v5 = sub_10033AF0(*(_WORD *)(a1 + 4) & 1, v20);
    v6 = sub_10033AF0(((unsigned __int8)v4 >> 1) & 1, *(_WORD *)((char *)&v20 + v5));
    v8 = sub_10033AF0(((unsigned __int8)v4 >> 2) & 1, *(_WORD *)(v6 + v7));
    v10 = sub_10033AF0(((unsigned __int8)v4 >> 3) & 1, *(_WORD *)(v8 + v9));
    v12 = sub_10033AF0(((unsigned __int8)v4 >> 4) & 1, *(_WORD *)(v10 + v11));
    v14 = sub_10033AF0(((unsigned __int8)v4 >> 6) & 1, *(_WORD *)(v12 + v13));
    v16 = sub_10033AF0(((unsigned __int8)v4 >> 7) & 1, *(_WORD *)(v14 + v15));
    v18 = sub_10033AF0(BYTE1(v4) & 1, *(_WORD *)(v16 + v17));
    sub_10033AF0((v4 >> 9) & 1, *(_WORD *)(v19 + v18));
    result = v3;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;

//----- (10033C70) --------------------------------------------------------
signed int __cdecl sub_10033C70(int a1)
{
  signed int result; // eax@1
  int v2; // edi@2
  int v3; // ST40_4@2
  int v4; // eax@2
  unsigned __int8 v5; // dl@2
  unsigned __int8 v6; // dl@2
  unsigned __int16 *v7; // esi@2
  unsigned __int8 v8; // dl@2
  unsigned __int16 *v9; // esi@2
  int v10; // eax@2
  unsigned __int8 v11; // dl@2
  int v12; // [sp+8h] [bp-A4h]@2

  result = 0xFFFFFF;
  if ( *(_BYTE *)(a1 + 4) & 0x40 )
  {
    v2 = *(_DWORD *)a1;
    v3 = v2 + sub_100361F0(a1);
    (*(void (__cdecl **)(int, signed int, int *))dword_103334D8)(v2, 160, &v12);
    v4 = sub_10033AF0(*(_WORD *)(a1 + 4) & 1, v12);
    v7 = (unsigned __int16 *)((char *)&v12 + v4 + sub_10033AF0((v5 >> 1) & 1, *(_WORD *)((char *)&v12 + v4)));
    v9 = (unsigned __int16 *)((char *)v7 + sub_10033AF0((v6 >> 2) & 1, *v7));
    v10 = sub_10033AF0((v8 >> 3) & 1, *v9);
    sub_10033AF0((v11 >> 4) & 1, *(unsigned __int16 *)((char *)v9 + v10));
    result = v3;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;

//----- (10033D60) --------------------------------------------------------
signed int __cdecl sub_10033D60(int a1)
{
  signed int result; // eax@1
  int v2; // edi@2
  int v3; // ST4C_4@2
  unsigned int v4; // ebx@2
  int v5; // eax@2
  int v6; // eax@2
  int v7; // edx@2
  int v8; // eax@2
  int v9; // edx@2
  int v10; // eax@2
  int v11; // edx@2
  int v12; // eax@2
  int v13; // edx@2
  int v14; // eax@2
  int v15; // edx@2
  int v16; // eax@2
  int v17; // edx@2
  int v18; // eax@2
  int v19; // edx@2
  int v20; // eax@2
  int v21; // edx@2
  int v22; // eax@2
  int v23; // edx@2
  int v24; // [sp+8h] [bp-A4h]@2

  result = 0xFFFFFF;
  if ( *(_WORD *)(a1 + 4) & 0x1000 )
  {
    v2 = *(_DWORD *)a1;
    v3 = v2 + sub_100361F0(a1);
    (*(void (__cdecl **)(int, signed int, int *))dword_103334D8)(v2, 160, &v24);
    v4 = *(_WORD *)(a1 + 4);
    v5 = sub_10033AF0(*(_WORD *)(a1 + 4) & 1, v24);
    v6 = sub_10033AF0(((unsigned __int8)v4 >> 1) & 1, *(_WORD *)((char *)&v24 + v5));
    v8 = sub_10033AF0(((unsigned __int8)v4 >> 2) & 1, *(_WORD *)(v6 + v7));
    v10 = sub_10033AF0(((unsigned __int8)v4 >> 3) & 1, *(_WORD *)(v8 + v9));
    v12 = sub_10033AF0(((unsigned __int8)v4 >> 4) & 1, *(_WORD *)(v10 + v11));
    v14 = sub_10033AF0(((unsigned __int8)v4 >> 6) & 1, *(_WORD *)(v12 + v13));
    v16 = sub_10033AF0(((unsigned __int8)v4 >> 7) & 1, *(_WORD *)(v14 + v15));
    v18 = sub_10033AF0(BYTE1(v4) & 1, *(_WORD *)(v16 + v17));
    v20 = sub_10033AF0((v4 >> 9) & 1, *(_WORD *)(v19 + v18));
    v22 = sub_10033AF0((v4 >> 10) & 1, *(_WORD *)(v21 + v20));
    sub_10033AF0((v4 >> 11) & 1, *(_WORD *)(v23 + v22));
    result = v3;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;

//----- (10033EF0) --------------------------------------------------------
signed int __cdecl sub_10033EF0(int a1)
{
  signed int result; // eax@1
  int v2; // edi@2
  int v3; // ST4C_4@2
  __int16 v4; // bx@2
  int v5; // eax@2
  int v6; // eax@2
  int v7; // edx@2
  int v8; // eax@2
  int v9; // edx@2
  int v10; // eax@2
  int v11; // edx@2
  int v12; // eax@2
  int v13; // edx@2
  int v14; // eax@2
  int v15; // edx@2
  int v16; // [sp+8h] [bp-A4h]@2

  result = 0xFFFFFF;
  if ( *(_BYTE *)(a1 + 5) & 1 )
  {
    v2 = *(_DWORD *)a1;
    v3 = v2 + sub_100361F0(a1);
    (*(void (__cdecl **)(int, signed int, int *))dword_103334D8)(v2, 160, &v16);
    v4 = *(_WORD *)(a1 + 4);
    v5 = sub_10033AF0(*(_WORD *)(a1 + 4) & 1, v16);
    v6 = sub_10033AF0(((unsigned __int8)v4 >> 1) & 1, *(_WORD *)((char *)&v16 + v5));
    v8 = sub_10033AF0(((unsigned __int8)v4 >> 2) & 1, *(_WORD *)(v6 + v7));
    v10 = sub_10033AF0(((unsigned __int8)v4 >> 3) & 1, *(_WORD *)(v8 + v9));
    v12 = sub_10033AF0(((unsigned __int8)v4 >> 4) & 1, *(_WORD *)(v10 + v11));
    v14 = sub_10033AF0(((unsigned __int8)v4 >> 6) & 1, *(_WORD *)(v12 + v13));
    sub_10033AF0(((unsigned __int8)v4 >> 7) & 1, *(_WORD *)(v14 + v15));
    result = v3;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;

//----- (10034010) --------------------------------------------------------
signed int __cdecl sub_10034010(int a1)
{
  signed int result; // eax@1
  int v2; // edi@2
  int v3; // ST4C_4@2
  unsigned int v4; // ebx@2
  int v5; // eax@2
  int v6; // eax@2
  int v7; // edx@2
  int v8; // eax@2
  int v9; // edx@2
  int v10; // eax@2
  int v11; // edx@2
  int v12; // eax@2
  int v13; // edx@2
  int v14; // eax@2
  int v15; // edx@2
  int v16; // eax@2
  int v17; // edx@2
  int v18; // eax@2
  int v19; // edx@2
  int v20; // eax@2
  int v21; // edx@2
  int v22; // [sp+8h] [bp-A4h]@2

  result = 0xFFFFFF;
  if ( *(_WORD *)(a1 + 4) & 0x800 )
  {
    v2 = *(_DWORD *)a1;
    v3 = v2 + sub_100361F0(a1);
    (*(void (__cdecl **)(int, signed int, int *))dword_103334D8)(v2, 160, &v22);
    v4 = *(_WORD *)(a1 + 4);
    v5 = sub_10033AF0(*(_WORD *)(a1 + 4) & 1, v22);
    v6 = sub_10033AF0(((unsigned __int8)v4 >> 1) & 1, *(_WORD *)((char *)&v22 + v5));
    v8 = sub_10033AF0(((unsigned __int8)v4 >> 2) & 1, *(_WORD *)(v6 + v7));
    v10 = sub_10033AF0(((unsigned __int8)v4 >> 3) & 1, *(_WORD *)(v8 + v9));
    v12 = sub_10033AF0(((unsigned __int8)v4 >> 4) & 1, *(_WORD *)(v10 + v11));
    v14 = sub_10033AF0(((unsigned __int8)v4 >> 6) & 1, *(_WORD *)(v12 + v13));
    v16 = sub_10033AF0(((unsigned __int8)v4 >> 7) & 1, *(_WORD *)(v14 + v15));
    v18 = sub_10033AF0(BYTE1(v4) & 1, *(_WORD *)(v16 + v17));
    v20 = sub_10033AF0((v4 >> 9) & 1, *(_WORD *)(v19 + v18));
    sub_10033AF0((v4 >> 10) & 1, *(_WORD *)(v21 + v20));
    result = v3;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;

//----- (10034180) --------------------------------------------------------
signed int __cdecl sub_10034180(int a1)
{
  signed int result; // eax@1
  int v2; // edi@2
  int v3; // ST48_4@2
  int v4; // eax@2
  unsigned __int8 v5; // dl@2
  unsigned __int8 v6; // dl@2
  unsigned __int16 *v7; // esi@2
  unsigned __int8 v8; // dl@2
  unsigned __int16 *v9; // esi@2
  unsigned __int8 v10; // dl@2
  unsigned __int16 *v11; // esi@2
  int v12; // eax@2
  unsigned __int8 v13; // dl@2
  int v14; // [sp+8h] [bp-A4h]@2

  result = 0xFFFFFF;
  if ( *(_BYTE *)(a1 + 4) & 0x80 )
  {
    v2 = *(_DWORD *)a1;
    v3 = v2 + sub_100361F0(a1);
    (*(void (__cdecl **)(int, signed int, int *))dword_103334D8)(v2, 160, &v14);
    v4 = sub_10033AF0(*(_WORD *)(a1 + 4) & 1, v14);
    v7 = (unsigned __int16 *)((char *)&v14 + v4 + sub_10033AF0((v5 >> 1) & 1, *(_WORD *)((char *)&v14 + v4)));
    v9 = (unsigned __int16 *)((char *)v7 + sub_10033AF0((v6 >> 2) & 1, *v7));
    v11 = (unsigned __int16 *)((char *)v9 + sub_10033AF0((v8 >> 3) & 1, *v9));
    v12 = sub_10033AF0((v10 >> 4) & 1, *v11);
    sub_10033AF0((v13 >> 6) & 1, *(unsigned __int16 *)((char *)v11 + v12));
    result = v3;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;

//----- (10034280) --------------------------------------------------------
char __cdecl sub_10034280(_DWORD *a1)
{
  _DWORD *v1; // esi@1
  char result; // al@2
  char v3; // [sp+4h] [bp-4h]@2

  v1 = a1;
  do
  {
    (*(void (__cdecl **)(_DWORD, signed int, char *))dword_103334D8)(*v1, 3, &v3);
    *v1 += (unsigned __int16)word_10333C4C;
    result = sub_100332D0((int)v1, &a1);
  }
  while ( v3 & 1 );
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C4C: using guessed type __int16 word_10333C4C;

//----- (100342D0) --------------------------------------------------------
char __usercall sub_100342D0@<al>(signed int *a1@<edi>, signed int a2, signed int a3, unsigned __int8 a4, _BYTE *a5)
{
  unsigned __int8 v5; // al@1
  _BYTE *v6; // ebp@1
  signed int v7; // esi@1
  char v8; // bl@1
  signed int v9; // ecx@2
  char result; // al@6
  bool v11; // zf@21
  signed int v12; // ecx@31
  unsigned __int8 v13; // [sp+Fh] [bp-3Dh]@1
  char v14; // [sp+10h] [bp-3Ch]@1
  char v15; // [sp+11h] [bp-3Bh]@1
  char v16; // [sp+14h] [bp-38h]@1
  char v17; // [sp+15h] [bp-37h]@1
  bool v18; // [sp+1Bh] [bp-31h]@4
  char v19; // [sp+1Dh] [bp-2Fh]@1
  unsigned __int8 v20; // [sp+20h] [bp-2Ch]@8
  int v21; // [sp+21h] [bp-2Bh]@30
  unsigned __int8 v22; // [sp+2Eh] [bp-1Eh]@12
  int v23; // [sp+2Fh] [bp-1Dh]@30
  char v24; // [sp+3Ch] [bp-10h]@30
  char v25; // [sp+42h] [bp-Ah]@30

  v5 = 0;
  v6 = a5;
  v7 = a3;
  v13 = 0;
  v14 = 1;
  v15 = 1;
  *a5 = 0;
  v8 = 0;
  v19 = 0;
  v16 = -1;
  v17 = -1;
  do
  {
    v9 = a2;
    if ( a2 == 0xFFFFFF && v7 == a2 )
      break;
    *a1 = 0xFFFFFF;
    v18 = 1;
    if ( !v14 )
    {
      if ( !v15 )
      {
        *a1 = 0xFFFFFF;
        return -1;
      }
LABEL_10:
      if ( !v19 )
      {
        v17 = -1;
        do
        {
          (*(void (__cdecl **)(signed int, signed int, unsigned __int8 *))dword_103334D8)(v7, 14, &v22);
          v18 = sub_10032860((int)&v22);
          if ( v18 )
          {
            v17 = (v22 >> 1) & 0x1F;
          }
          else if ( v22 & 1 )
          {
            sub_10032B20(&a3);
            sub_10034280(&a3);
            v7 = a3;
          }
          else
          {
            v7 = 0xFFFFFF;
            a3 = 0xFFFFFF;
            v15 = 0;
          }
        }
        while ( v22 & 1 && v17 == -1 );
      }
      goto LABEL_19;
    }
    if ( !v8 )
    {
      (*(void (__cdecl **)(signed int, signed int, unsigned __int8 *))dword_103334D8)(v9, 14, &v20);
      v16 = (v20 >> 1) & 0x1F;
    }
    if ( v15 )
      goto LABEL_10;
LABEL_19:
    if ( v14 )
    {
      if ( !v15 )
        goto LABEL_31;
    }
    else if ( v15 )
    {
      goto LABEL_21;
    }
    if ( (unsigned __int8)(v16 - 7) > 2u || v17 != 10 )
    {
      if ( (unsigned __int8)(v17 - 7) <= 2u && v16 == 10
        || v16 < v17
        || v16 <= v17 && (sub_10032A90(v21, (int)&v24), sub_10032A90(v23, (int)&v25), strcmp(&v24, &v25) <= 0) )
      {
LABEL_31:
        v12 = a2;
        ++v13;
        v8 = 0;
        *v6 = 0;
        *a1 = v12;
        if ( v18 )
          v19 = 1;
        if ( v20 & 1 )
        {
          sub_10032B20(&a2);
          sub_10034280(&a2);
        }
        else
        {
          v14 = 0;
        }
        goto LABEL_37;
      }
    }
LABEL_21:
    ++v13;
    v8 = 1;
    v11 = (v22 & 1) == 0;
    *v6 = 1;
    *a1 = v7;
    v19 = 0;
    if ( v11 )
    {
      v15 = 0;
    }
    else
    {
      sub_10032B20(&a3);
      sub_10034280(&a3);
      v7 = a3;
    }
LABEL_37:
    v5 = v13;
  }
  while ( v13 <= a4 );
  if ( *a1 == 0xFFFFFF )
    result = -1;
  else
    result = v5 - 1;
  return result;
}
// 103334D8: using guessed type int dword_103334D8;

//----- (10034570) --------------------------------------------------------
signed int __cdecl sub_10034570(int a1, unsigned __int8 a2, _BYTE *a3)
{
  int v3; // esi@1
  signed int v4; // eax@1
  signed int v5; // edi@1
  char v7; // al@6
  char v8; // al@9
  int v9; // ebp@9
  bool v10; // bl@13
  int v11; // esi@17
  unsigned __int8 v12; // [sp+13h] [bp-25h]@1
  int v13; // [sp+14h] [bp-24h]@4
  int v14; // [sp+18h] [bp-20h]@4
  char v15; // [sp+1Ch] [bp-1Ch]@13

  v12 = -1;
  *a3 = 0;
  v3 = sub_10033C70(a1);
  v4 = sub_10033B10(a1);
  v5 = v4;
  if ( v3 == 0xFFFFFF )
  {
    if ( v4 == 0xFFFFFF )
      return 0xFFFFFF;
  }
  else
  {
    v14 = v3;
    v13 = v3;
    if ( v4 == 0xFFFFFF )
      goto LABEL_6;
  }
  *a3 = 1;
  v14 = v4;
  v13 = v4;
LABEL_6:
  sub_10032A50(&v13, a2, &v12);
  v7 = a2;
  if ( v12 == a2 )
  {
    v9 = v13;
    goto LABEL_26;
  }
  if ( *(_WORD *)(a1 + 4) & 0x40 && *(_WORD *)(a1 + 4) & 0x400 )
  {
    v8 = sub_100342D0(&v13, v3, v5, a2, a3);
    v9 = v13;
  }
  else
  {
    if ( v12 == -1 )
      v12 = 0;
    v9 = v13;
    while ( 1 )
    {
      v10 = 1;
      (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(v9, 14, &v15);
      if ( !*a3 || (v10 = sub_10032860((int)&v15)) != 0 )
        ++v12;
      if ( !(v15 & 1) )
        break;
      v11 = v12 - 1;
      if ( v11 < a2 )
      {
        sub_10032B20(&v13);
        sub_10034280(&v13);
        v9 = v13;
        if ( v11 < a2 && v13 != 0xFFFFFF )
          continue;
      }
      goto LABEL_23;
    }
    if ( !v10 )
      v12 = -1;
LABEL_23:
    v8 = --v12;
  }
  if ( v8 == a2 )
  {
    v7 = a2;
LABEL_26:
    sub_10033350(v14, v7, v9);
    return v9;
  }
  sub_10042930("..\\lib\\acl\\adb\\adb_appr_utl.c", 809, 0, 0);
  return 0xFFFFFF;
}
// 103334D8: using guessed type int dword_103334D8;

//----- (10034710) --------------------------------------------------------
void __cdecl sub_10034710(unsigned int a1, unsigned __int8 a2, int a3)
{
  _BYTE *v3; // eax@1
  float *v4; // ecx@1
  signed int v5; // edx@1
  int v6; // eax@3
  char v7; // [sp+Bh] [bp-9h]@1
  char v8; // [sp+Ch] [bp-8h]@3

  *(_DWORD *)a3 = 1600085855;
  *(_BYTE *)(a3 + 4) = 95;
  *(float *)(a3 + 48) = 6.2831855;
  v7 = 0;
  *(_BYTE *)(a3 + 5) = 0;
  *(_BYTE *)(a3 + 6) = -1;
  *(_BYTE *)(a3 + 7) = 0;
  *(_BYTE *)(a3 + 9) = 0;
  *(_BYTE *)(a3 + 11) = -1;
  *(_BYTE *)(a3 + 12) = 0;
  *(_BYTE *)(a3 + 8) = 0;
  *(_BYTE *)(a3 + 10) = 1;
  *(_DWORD *)(a3 + 24) = 0x3FFFF;
  *(_BYTE *)(a3 + 21) = -1;
  v3 = (_BYTE *)(a3 + 17);
  v4 = (float *)(a3 + 32);
  v5 = 4;
  do
  {
    *(v3 - 4) = 15;
    *v3 = 63;
    *v4 = 0.0;
    ++v4;
    ++v3;
    --v5;
  }
  while ( v5 );
  sub_10036830(a1, &v8);
  v6 = sub_10034570((int)&v8, a2, &v7);
  if ( v6 != 0xFFFFFF )
    sub_10033530(a3, v6, a1, &v7);
}

//----- (100347C0) --------------------------------------------------------
char __cdecl sub_100347C0(int a1, unsigned __int8 a2, _DWORD *a3)
{
  char result; // al@11
  bool v4; // zf@13
  unsigned __int8 v5; // bl@14
  signed int v6; // eax@16
  char v7; // [sp+Eh] [bp-8Ah]@1
  char v8; // [sp+Fh] [bp-89h]@14
  unsigned __int8 v9; // [sp+10h] [bp-88h]@14
  char v10; // [sp+14h] [bp-84h]@1
  char v11; // [sp+1Ah] [bp-7Eh]@1
  int v12; // [sp+2Ch] [bp-6Ch]@11
  char v13; // [sp+48h] [bp-50h]@11
  int v14; // [sp+50h] [bp-48h]@19
  unsigned __int16 v15; // [sp+60h] [bp-38h]@11
  int v16; // [sp+70h] [bp-28h]@12

  *a3 = 0xFFFF;
  v7 = 0;
  sub_10034710(a1, a2, (int)&v10);
  if ( v11 != 3 && v11 && v11 != 2 && v11 != 4 && v11 != 5 && v11 != 6 )
  {
    if ( v11 == 8 || v11 == 9 || v11 == 10 )
    {
      sub_1003B060(v12, (int)&v13);
      if ( (unsigned int)(v16 - 108000) <= 0x26DE )
      {
        v4 = v11 == 10;
        *a3 = v16;
        return v4;
      }
    }
    else if ( v11 == 13 )
    {
      sub_1003AEA0(v12, &v13);
      *a3 = v15;
      return 2;
    }
    result = 3;
  }
  else
  {
    v5 = 0;
    v8 = sub_10037080(a1);
    v9 = 0;
    if ( v8 )
    {
      do
      {
        if ( v7 )
          break;
        v6 = sub_10036AB0(a1, v9);
        if ( v6 == v12 )
          v7 = 1;
        v9 = ++v5;
      }
      while ( v5 < (unsigned __int8)v8 );
    }
    sub_100375A0(a1, v5 - 1, &v13);
    if ( (unsigned int)(v14 - 108000) > 0x26DE )
    {
      result = 3;
    }
    else
    {
      *a3 = v14;
      result = 0;
    }
  }
  return result;
}

//----- (10034990) --------------------------------------------------------
signed int __cdecl sub_10034990(unsigned __int8 a1, unsigned __int8 a2)
{
  signed int v2; // esi@1
  int v3; // eax@1

  v2 = 0x3FFFF;
  sub_1007C110(54, 60000);
  v3 = sub_10039C50(a1);
  if ( v3 && a2 < *(_BYTE *)(v3 + 1) )
    v2 = *(_DWORD *)(84 * a2 + v3 + 136);
  sub_1007C0F0(54);
  return v2;
}

//----- (100349E0) --------------------------------------------------------
char __cdecl sub_100349E0(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // eax@1
  char v3; // bl@1

  sub_1007C110(54, 60000);
  v2 = sub_10039C50(a1);
  v3 = 0;
  if ( v2 && a2 < *(_BYTE *)(v2 + 1) )
    v3 = *(_BYTE *)(84 * a2 + v2 + 127);
  sub_1007C0F0(54);
  return v3;
}

//----- (10034A30) --------------------------------------------------------
int __cdecl sub_10034A30(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // eax@1
  char v3; // bl@2
  int result; // eax@2

  sub_1007C110(54, 60000);
  v2 = sub_10039C50(a1);
  if ( v2 )
  {
    v3 = *(_BYTE *)(84 * a2 + v2 + 125);
    sub_1007C0F0(54);
    result = v3 & 0xC7;
  }
  else
  {
    sub_1007C0F0(54);
    result = 0;
  }
  return result;
}

//----- (10034A90) --------------------------------------------------------
int __cdecl sub_10034A90(int a1, int a2)
{
  int result; // eax@1

  result = a2;
  *(float *)a2 = 6.2831855;
  *(float *)(a2 + 4) = 6.2831855;
  switch ( *(_BYTE *)a1 )
  {
    case 1:
    case 4:
    case 0x12:
    case 0x14:
    case 0x15:
      *(_DWORD *)a2 = *(_DWORD *)(a1 + 44);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 48);
      break;
    case 2:
    case 5:
    case 0x13:
    case 0x16:
      *(_DWORD *)a2 = *(_DWORD *)(a1 + 52);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 56);
      break;
    default:
      return result;
  }
  return result;
}

//----- (10034B00) --------------------------------------------------------
char __cdecl sub_10034B00(unsigned __int8 a1)
{
  int v1; // eax@1
  char v2; // bl@3
  char result; // al@3

  sub_1007C110(54, 60000);
  v1 = sub_10039C50(a1);
  if ( v1 && *(_DWORD *)(v1 + 104) != 0x3FFFF )
  {
    v2 = *(_BYTE *)(v1 + 88);
    sub_1007C0F0(54);
    result = v2;
  }
  else
  {
    sub_1007C0F0(54);
    result = -1;
  }
  return result;
}

//----- (10034B50) --------------------------------------------------------
signed int __cdecl sub_10034B50(unsigned __int8 a1)
{
  signed int v1; // esi@1
  int v2; // eax@1
  char v3; // cl@2

  v1 = 0x3FFFF;
  sub_1007C110(54, 60000);
  v2 = sub_10039C50(a1);
  if ( v2 )
  {
    v3 = *(_BYTE *)(v2 + 1);
    if ( v3 )
    {
      if ( *(_BYTE *)(v2 + 90) == -1 || (v1 = *(_DWORD *)(v2 + 104), v1 == 0x3FFFF) )
      {
        if ( *(_BYTE *)(v2 + 60) == 3 || *(_BYTE *)(v2 + 61) == 3 || (v1 = *(_DWORD *)(v2 + 64), v1 == 0x3FFFF) )
          v1 = sub_100439B0(84 * (unsigned __int8)(v3 - 1) + v2 + 148);
      }
    }
  }
  sub_1007C0F0(54);
  return v1;
}

//----- (10034BD0) --------------------------------------------------------
int __cdecl sub_10034BD0(int a1, char a2, void *a3)
{
  int v3; // eax@1
  int result; // eax@3

  sub_1007C110(54, 60000);
  v3 = sub_10039C50(a1);
  if ( v3 && (unsigned __int8)a2 < *(_BYTE *)(v3 + 1) )
  {
    qmemcpy(a3, (const void *)(84 * (unsigned __int8)a2 + v3 + 148), 0x3Cu);
    result = sub_1007C0F0(54);
  }
  else
  {
    memset(a3, 0, 0x3Cu);
    *(_BYTE *)a3 = 24;
    *((_BYTE *)a3 + 1) = 0;
    *((_BYTE *)a3 + 4) = 0;
    *((_BYTE *)a3 + 6) = 0;
    *((_BYTE *)a3 + 7) = 4;
    result = sub_1007C0F0(54);
  }
  return result;
}

//----- (10034C50) --------------------------------------------------------
signed int __cdecl sub_10034C50(unsigned __int8 a1)
{
  signed int v1; // esi@1
  int v2; // eax@1

  v1 = 0x3FFFF;
  sub_1007C110(54, 60000);
  v2 = sub_10039C50(a1);
  if ( v2 )
  {
    if ( *(_BYTE *)(v2 + 1) > 1u )
    {
      if ( *(_BYTE *)(v2 + 20) == 3 || *(_BYTE *)(v2 + 21) == 3 || (v1 = *(_DWORD *)(v2 + 24), v1 == 0x3FFFF) )
        v1 = sub_100439B0(v2 + 148);
    }
  }
  sub_1007C0F0(54);
  return v1;
}

//----- (10034CB0) --------------------------------------------------------
char __cdecl sub_10034CB0(int a1)
{
  unsigned __int8 v1; // bl@1
  char result; // al@1
  char v3; // cl@1
  char v4; // dl@2

  v1 = *(_BYTE *)(a1 + 1);
  result = -1;
  v3 = 0;
  if ( v1 )
  {
    while ( 1 )
    {
      v4 = *(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 154);
      if ( v4 == 2 || v4 == 8 )
        break;
      if ( (unsigned __int8)++v3 >= v1 )
        return result;
    }
    result = v3;
  }
  return result;
}

//----- (10034CF0) --------------------------------------------------------
char __cdecl sub_10034CF0(int a1)
{
  unsigned __int8 v1; // dl@1
  char result; // al@1
  char v3; // cl@1

  v1 = *(_BYTE *)(a1 + 1);
  result = -1;
  v3 = 0;
  if ( v1 )
  {
    while ( !(*(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 125) & 2) )
    {
      if ( (unsigned __int8)++v3 >= v1 )
        return result;
    }
    result = v3;
  }
  return result;
}

//----- (10034D20) --------------------------------------------------------
char __cdecl sub_10034D20(int a1)
{
  char result; // al@1
  int v2; // ecx@2
  _BYTE *v3; // edx@3

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1) - 1;
    if ( v2 >= 0 )
    {
      v3 = (_BYTE *)(84 * v2 + a1 + 125);
      while ( !(*v3 & 2) )
      {
        --v2;
        v3 -= 84;
        if ( v2 < 0 )
          return result;
      }
      result = v2;
    }
  }
  return result;
}

//----- (10034D60) --------------------------------------------------------
char __usercall sub_10034D60@<al>(int a1@<edi>, int a2@<esi>, unsigned int a3)
{
  signed int v3; // ebp@1
  char v4; // dl@3
  bool v5; // zf@4
  char result; // al@4
  char v7; // [sp+8h] [bp-10h]@3
  char v8; // [sp+9h] [bp-Fh]@3
  char v9; // [sp+Ah] [bp-Eh]@3
  char v10; // [sp+Ch] [bp-Ch]@3

  v3 = 3;
  if ( isdigit(*(_BYTE *)(a1 + 3)) )
    v3 = 4;
  v4 = *(_BYTE *)(a2 + 11);
  v7 = *(_BYTE *)(a2 + 12);
  v8 = v4;
  v9 = 0;
  sub_100423E0((int)&v7, 0);
  sub_1002E110(a3, (int)&v10);
  if ( strcmp((const char *)(a2 + 1), &v10) || (v5 = strcmp((const char *)(a1 + v3), &v7) == 0, result = 1, !v5) )
    result = 0;
  return result;
}

//----- (10034E40) --------------------------------------------------------
void __cdecl sub_10034E40(int a1, unsigned __int8 a2, char *a3, char *a4, int a5, bool *a6)
{
  char *v6; // edi@1
  bool v7; // zf@1
  unsigned int v8; // esi@2
  bool v9; // bl@4
  char v10; // al@17
  char v11; // al@30
  char v12; // dl@30
  char v13; // cl@45
  bool v14; // al@57
  char v15; // [sp+1Bh] [bp-EDh]@9
  char v16; // [sp+1Ch] [bp-ECh]@4
  char v17; // [sp+1Eh] [bp-EAh]@1
  char v18; // [sp+1Fh] [bp-E9h]@1
  unsigned int v19; // [sp+20h] [bp-E8h]@2
  char *v20; // [sp+24h] [bp-E4h]@1
  bool *v21; // [sp+28h] [bp-E0h]@1
  char *v22; // [sp+2Ch] [bp-DCh]@1
  char v23; // [sp+30h] [bp-D8h]@1
  char v24; // [sp+39h] [bp-CFh]@1
  char v25; // [sp+3Ah] [bp-CEh]@19
  char v26[8]; // [sp+3Dh] [bp-CBh]@3
  int v27; // [sp+45h] [bp-C3h]@5
  char v28; // [sp+64h] [bp-A4h]@6
  int v29; // [sp+8Ch] [bp-7Ch]@8
  char v30; // [sp+D4h] [bp-34h]@5

  v6 = a4;
  v22 = a3;
  v20 = a4;
  v21 = a6;
  sub_10034710(a1, a2, (int)&v23);
  sub_1007C470(6751, &v18, 1, &unk_100E7C4E);
  sub_1007D180(123, &v17);
  *a3 = 15;
  *a4 = 15;
  v7 = v24 == 0;
  *(_BYTE *)a5 = 0;
  *(_BYTE *)(a5 + 1) = 0;
  *(_BYTE *)(a5 + 2) = 0;
  *a6 = 0;
  if ( !v7 )
  {
    v8 = 0;
    v19 = 0;
    while ( 2 )
    {
      switch ( v26[v8] )
      {
        case 3:
          v16 = 1;
          v9 = 0;
          if ( sub_10041CA0() && sub_100325C0(a1, v27, &v30) )
          {
            sub_10043C80((int)&v30, (int)&v28);
            if ( v28 )
            {
              if ( sub_10034D60((int)&v23, (int)&v28, a1) && (unsigned __int8)sub_1002FC20(v29) )
              {
                v8 = v19;
                v6 = v20;
                v9 = 1;
                v15 = 1;
                goto LABEL_40;
              }
              v8 = v19;
              v6 = v20;
            }
            v9 = 0;
          }
          v15 = 0;
          goto LABEL_40;
        case 1:
        case 2:
        case 4:
          v16 = 1;
          v9 = sub_10041CA0() && (unsigned __int8)sub_1002FC20(15);
          v10 = v26[v8];
          if ( v10 != 1 )
            v9 = v9 && !v25;
          if ( v10 == 4 )
          {
            if ( !v9 || !v17 )
            {
              v9 = 0;
              goto LABEL_29;
            }
            v9 = 1;
          }
          else if ( !v9 )
          {
            goto LABEL_29;
          }
          v15 = 1;
          if ( sub_10039530(556.0, 100.0) )
            goto LABEL_30;
LABEL_29:
          v15 = 0;
LABEL_30:
          v11 = v18;
          v12 = v18;
          if ( v18 )
          {
            if ( v26[v8] == 1 )
            {
              *(_BYTE *)(a5 + 1) = 1;
            }
            else if ( v26[v8] == 2 || v26[v8] == 4 )
            {
              *(_BYTE *)(a5 + 2) = 1;
            }
            else
            {
              v26[v8] = 15;
            }
          }
LABEL_41:
          if ( v26[v8] != 15 )
          {
            if ( !v16 || v9 || v11 )
            {
              v13 = v26[v8];
              if ( *v22 == 15 || (unsigned __int8)*v22 < (unsigned __int8)v13 )
                *v22 = v13;
            }
            else
            {
              v13 = v26[v8];
            }
            if ( v13 != 15 && (!v16 || v15 || v12) && (*v6 == 15 || (unsigned __int8)*v6 < (unsigned __int8)v13) )
            {
              *v6 = v13;
              v14 = v16 && v15;
              *v21 = v14;
            }
          }
          v19 = ++v8;
          if ( v8 < 4 )
            continue;
          if ( !*v6 )
            *(_BYTE *)a5 = 0;
          if ( !*v21 )
          {
            if ( *v6 == 1 )
              *(_BYTE *)(a5 + 1) = 0;
            if ( *v6 == 2 || *v6 == 4 )
              *(_BYTE *)(a5 + 2) = 0;
          }
          break;
        case 0:
          *(_BYTE *)a5 = 1;
          goto LABEL_39;
        default:
          v26[v8] = 15;
LABEL_39:
          v9 = 0;
          v15 = 0;
          v16 = 0;
LABEL_40:
          v11 = 0;
          v12 = 0;
          goto LABEL_41;
      }
      break;
    }
  }
}
// 10034E40: using guessed type char var_CB[8];

//----- (10035150) --------------------------------------------------------
char __cdecl sub_10035150(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_1007C110(54, 60000);
  v1 = -1;
  v2 = sub_10039C50(a1);
  if ( v2 )
    v1 = sub_10034CB0(v2);
  sub_1007C0F0(54);
  return v1;
}

//----- (10035190) --------------------------------------------------------
char __cdecl sub_10035190(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_1007C110(54, 60000);
  v1 = -1;
  v2 = sub_10039C50(a1);
  if ( v2 )
    v1 = sub_10034CF0(v2);
  sub_1007C0F0(54);
  return v1;
}

//----- (100351D0) --------------------------------------------------------
char __cdecl sub_100351D0(int a1, char a2, char *a3)
{
  char result; // al@2
  int v4; // ebx@6
  unsigned int v5; // esi@8
  float v6; // edi@10
  unsigned int v7; // esi@10
  double v8; // ST28_8@10
  int v9; // eax@10
  int v10; // edi@13
  float v11; // [sp+1Ch] [bp-44h]@6
  float v12; // [sp+1Ch] [bp-44h]@13
  char v13; // [sp+24h] [bp-3Ch]@1
  float v14; // [sp+30h] [bp-30h]@5
  int v15; // [sp+48h] [bp-18h]@1
  float v16; // [sp+50h] [bp-10h]@6
  float v17; // [sp+54h] [bp-Ch]@6

  sub_10034BD0(a1, a2, &v13);
  if ( v15 == 262142 )
  {
    result = sub_100421E0((int)a3, "Locked", 12);
  }
  else
  {
    switch ( v13 )
    {
      case 0:
        result = sub_100421E0((int)a3, "DME ARC", 12);
        break;
      case 1:
      case 7:
      case 0x12:
        sub_10042370(a3, 0xCu, "%d", (signed int)(v14 * 3.280839895013123 + 0.5));
        result = sub_100423A0(a3, "", 12);
        break;
      case 2:
      case 9:
      case 0x13:
        v11 = v17 * 0.0005399568034557236;
        sub_1002E890(LODWORD(v16), (int)a3);
        v4 = 3;
        if ( v11 >= 9.9499998 )
          v4 = 4;
        v5 = strlen(a3);
        result = sub_10041FB0(v11, v4, 1, (int)&a3[v5]);
        *(&a3[v4] + v5) = 0;
        break;
      case 4:
      case 0x14:
        result = sub_100421E0((int)a3, "INTRCPT ", 12);
        break;
      case 5:
      case 0x16:
        v6 = v16;
        sub_1002E890(LODWORD(v16), (int)a3);
        v7 = strlen(a3);
        v8 = v17;
        *(float *)&v8 = v8 - sub_10037F60(v6);
        *(float *)&v8 = sub_1007BCB0(*(float *)&v8);
        v9 = sub_1007BDF0(*(float *)&v8);
        if ( !v9 )
          v9 = 360;
        result = sub_10042370(&a3[v7], 12 - v7, "%03i", v9);
        break;
      case 8:
        v10 = 3;
        v12 = v16 * 0.0005399568034557236;
        if ( v12 >= 9.9499998 )
          v10 = 4;
        *a3 = 68;
        result = sub_10041FB0(v12, v10, 1, (int)(a3 + 1));
        a3[v10 + 1] = 0;
        break;
      case 0xA:
      case 0x15:
        result = sub_100421E0((int)a3, "MANSEQ", 12);
        break;
      case 0xF:
        result = sub_100421E0((int)a3, "PROC. TURN", 12);
        break;
      case 0xB:
      case 0xC:
      case 0xD:
        result = sub_100421E0((int)a3, "HOLD", 12);
        break;
      case 0x10:
        result = sub_100421E0((int)a3, &unk_100E8154, 12);
        break;
      default:
        result = (char)a3;
        *a3 = 0;
        break;
    }
  }
  return result;
}

//----- (100354B0) --------------------------------------------------------
char __cdecl sub_100354B0(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_1007C110(54, 60000);
  v1 = -1;
  v2 = sub_10039C50(a1);
  if ( v2 )
    v1 = sub_10034D20(v2);
  sub_1007C0F0(54);
  return v1;
}

//----- (100354F0) --------------------------------------------------------
signed int __cdecl sub_100354F0(unsigned __int8 a1)
{
  signed int v1; // esi@1
  int v2; // eax@1

  v1 = 0x3FFFF;
  sub_1007C110(54, 60000);
  v2 = sub_10039C50(a1);
  if ( v2 && *(_BYTE *)(v2 + 90) != -1 )
    v1 = *(_DWORD *)(v2 + 104);
  sub_1007C0F0(54);
  return v1;
}

//----- (10035530) --------------------------------------------------------
char __cdecl sub_10035530(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_1007C110(54, 60000);
  v1 = 0;
  v2 = sub_10039C50(a1);
  if ( v2 )
    v1 = *(_BYTE *)(v2 + 1);
  sub_1007C0F0(54);
  return v1;
}

//----- (10035570) --------------------------------------------------------
signed int __cdecl sub_10035570(unsigned __int8 a1, unsigned __int8 a2)
{
  signed int v2; // esi@1
  int v3; // eax@1

  sub_1007C110(54, 60000);
  v2 = 0x3FFFF;
  v3 = sub_10039C50(a1);
  if ( v3 && a2 < *(_BYTE *)(v3 + 1) )
    v2 = sub_100439B0(84 * a2 + v3 + 148);
  sub_1007C0F0(54);
  return v2;
}

//----- (100355D0) --------------------------------------------------------
signed int __cdecl sub_100355D0(unsigned __int8 a1)
{
  signed int v1; // esi@1
  int v2; // eax@1

  sub_1007C110(54, 60000);
  v1 = 0x3FFFF;
  v2 = sub_10039C50(a1);
  if ( v2 && *(_BYTE *)(v2 + 60) != 3 && *(_BYTE *)(v2 + 61) != 3 )
    v1 = *(_DWORD *)(v2 + 64);
  sub_1007C0F0(54);
  return v1;
}

//----- (10035610) --------------------------------------------------------
char __cdecl sub_10035610(int a1)
{
  char result; // al@1
  unsigned __int8 v2; // dl@2
  char v3; // cl@2

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1);
    v3 = 0;
    if ( v2 )
    {
      while ( !(*(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 125) & 1) )
      {
        if ( (unsigned __int8)++v3 >= v2 )
          return result;
      }
      result = v3;
    }
  }
  return result;
}

//----- (10035650) --------------------------------------------------------
char __cdecl sub_10035650(int a1)
{
  char result; // al@1
  unsigned __int8 v2; // dl@2
  char v3; // cl@2

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1);
    v3 = 0;
    if ( v2 )
    {
      while ( !(*(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 125) & 4) )
      {
        if ( (unsigned __int8)++v3 >= v2 )
          return result;
      }
      result = v3;
    }
  }
  return result;
}

//----- (10035690) --------------------------------------------------------
char __cdecl sub_10035690(int a1)
{
  char result; // al@1
  unsigned __int8 v2; // dl@2
  char v3; // cl@2

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1);
    v3 = 0;
    if ( v2 )
    {
      while ( *(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 154) != 3 )
      {
        if ( (unsigned __int8)++v3 >= v2 )
          return result;
      }
      result = v3;
    }
  }
  return result;
}

//----- (100356D0) --------------------------------------------------------
char __cdecl sub_100356D0(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_1007C110(54, 60000);
  v1 = -1;
  v2 = sub_10039C50(a1);
  if ( v2 )
    v1 = sub_10035610(v2);
  sub_1007C0F0(54);
  return v1;
}

//----- (10035710) --------------------------------------------------------
char __cdecl sub_10035710(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_1007C110(54, 60000);
  v1 = -1;
  v2 = sub_10039C50(a1);
  if ( v2 )
    v1 = sub_10035650(v2);
  sub_1007C0F0(54);
  return v1;
}

//----- (10035750) --------------------------------------------------------
char __cdecl sub_10035750(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_1007C110(54, 60000);
  v1 = -1;
  v2 = sub_10039C50(a1);
  if ( v2 )
    v1 = sub_10035690(v2);
  sub_1007C0F0(54);
  return v1;
}

//----- (10035790) --------------------------------------------------------
double __cdecl sub_10035790(float a1)
{
  double result; // st7@4
  float v2; // [sp+0h] [bp-8h]@1
  int v3; // [sp+4h] [bp-4h]@3

  v2 = a1;
  if ( LODWORD(a1) == 0x3FFFF )
    sub_1007C470(9125, &v2, 4, &unk_100E86D8);
  sub_1007C470(9124, &v3, 4, &unk_100E86D8);
  if ( LODWORD(v2) == v3 )
  {
    sub_1007C470(9123, &a1, 4, &unk_100E86DC);
    result = a1;
  }
  else
  {
    result = (float)9.9999996e24;
  }
  return result;
}

//----- (10035810) --------------------------------------------------------
char __usercall sub_10035810@<al>(unsigned __int8 a1@<al>)
{
  return byte_102573B8[a1];
}

//----- (10035820) --------------------------------------------------------
char sub_10035820()
{
  char result; // al@1
  char v1; // bl@1
  char v2; // [sp+7h] [bp-5h]@1
  unsigned __int8 v3; // [sp+8h] [bp-4h]@1

  memset(byte_102573B8, 255, 0x100u);
  result = sub_10035530(0);
  v1 = 0;
  v2 = result;
  v3 = 0;
  if ( result )
  {
    do
    {
      result = sub_100349E0(0, v3);
      byte_102573B8[(unsigned __int8)result] = v1++;
      v3 = v1;
    }
    while ( (unsigned __int8)v1 < (unsigned __int8)v2 );
  }
  return result;
}

//----- (10035880) --------------------------------------------------------
char __usercall sub_10035880@<al>(char a1@<al>)
{
  char result; // al@3

  if ( a1 != -1 && a1 )
    result = a1 - 1;
  else
    result = -1;
  return result;
}

//----- (10035890) --------------------------------------------------------
void __cdecl sub_10035890(_BYTE *a1, unsigned __int8 a2)
{
  int v2; // edi@1
  double v3; // st7@2
  double v4; // st6@2
  int v5; // esi@2
  char v6; // cl@3
  unsigned __int8 v7; // al@3
  unsigned __int8 v8; // al@6
  char v9; // al@8

  sub_10035820();
  v2 = *a1 - 1;
  if ( v2 >= 0 )
  {
    v3 = 9.9999996e24;
    v4 = 0.0;
    v5 = (int)&a1[52 * v2 + 12];
    do
    {
      v6 = *(_BYTE *)(v5 - 7);
      sub_10035810();
      if ( v7 < a2 )
      {
        *(_BYTE *)(v5 - 6) = 16;
        *(float *)v5 = v3;
        *(_BYTE *)(v5 - 4) = 0;
        *(float *)(v5 + 4) = v3;
        *(_BYTE *)(v5 - 3) = 0;
      }
      if ( a2 && (sub_10035810(), v8 == a2 - 1) && v4 < *(float *)(v5 + 40)
        || (sub_10035810(), v9 == a2) && v4 > *(float *)(v5 + 40) )
      {
        memcpy_0((void *)(v5 - 8), (const void *)(v5 + 44), 52 * (--*a1 - v2));
        v3 = 9.9999996e24;
        v4 = 0.0;
      }
      --v2;
      v5 -= 52;
    }
    while ( v2 >= 0 );
  }
}
// 10035810: using guessed type double sub_10035810(void);

//----- (10035960) --------------------------------------------------------
unsigned __int8 __cdecl sub_10035960(int a1)
{
  signed int v1; // eax@1
  unsigned __int8 v2; // di@1
  int v3; // esi@1
  char v4; // al@4
  unsigned __int8 result; // al@11
  char v6; // bl@11
  unsigned __int8 v7; // si@25
  char v8; // al@27
  unsigned int v9; // eax@27
  int v10; // eax@27
  char v11; // bl@27
  int v12; // esi@27
  unsigned __int8 v13; // al@29
  char v14; // dl@31
  bool v15; // bl@45
  float v16; // ST4C_4@51
  float v17; // ST48_4@51
  float v18; // ST44_4@51
  double v19; // st7@51
  float v20; // ST4C_4@55
  float v21; // ST48_4@55
  float v22; // ST44_4@55
  double v23; // st6@62
  double v24; // st7@65
  char v25; // al@77
  char v26; // al@78
  char v27; // [sp+22h] [bp-14Ah]@1
  bool v28; // [sp+22h] [bp-14Ah]@38
  unsigned __int8 v29; // [sp+23h] [bp-149h]@17
  char v30; // [sp+24h] [bp-148h]@6
  char v31; // [sp+24h] [bp-148h]@24
  char v32; // [sp+25h] [bp-147h]@1
  bool v33; // [sp+26h] [bp-146h]@6
  unsigned __int8 v34; // [sp+27h] [bp-145h]@1
  char v35; // [sp+28h] [bp-144h]@1
  char v36; // [sp+29h] [bp-143h]@24
  char v37; // [sp+2Ah] [bp-142h]@6
  char v38; // [sp+2Bh] [bp-141h]@24
  char v39[4]; // [sp+2Ch] [bp-140h]@24
  float v40; // [sp+30h] [bp-13Ch]@1
  char v41; // [sp+34h] [bp-138h]@25
  char v42; // [sp+35h] [bp-137h]@26
  char v43; // [sp+36h] [bp-136h]@48
  char v44; // [sp+37h] [bp-135h]@48
  float v45; // [sp+38h] [bp-134h]@51
  float v46; // [sp+3Ch] [bp-130h]@55
  float v47; // [sp+40h] [bp-12Ch]@77
  char v48; // [sp+46h] [bp-126h]@1
  char v49; // [sp+47h] [bp-125h]@1
  char v50[4]; // [sp+48h] [bp-124h]@1
  float v51; // [sp+4Ch] [bp-120h]@6
  float v52; // [sp+50h] [bp-11Ch]@6
  char v53; // [sp+54h] [bp-118h]@1
  int v54; // [sp+58h] [bp-114h]@25
  char v55; // [sp+94h] [bp-D8h]@1
  char v56[4]; // [sp+9Ah] [bp-D2h]@4
  int v57; // [sp+A9h] [bp-C3h]@2
  float v58; // [sp+C4h] [bp-A8h]@5
  char v59; // [sp+C8h] [bp-A4h]@1
  float v60; // [sp+100h] [bp-6Ch]@4
  float v61; // [sp+10Ch] [bp-60h]@2
  char v62; // [sp+138h] [bp-34h]@1

  v27 = sub_1002BF80();
  v32 = sub_1002BFA0();
  memset(&v62, 0, 0x30u);
  memset(&v59, 0, 0x70u);
  sub_1007C4B0(6751, (int)&v35, 1);
  LOBYTE(v40) = sub_10034B00(0);
  v1 = sub_100354F0(0);
  v2 = LOBYTE(v40);
  v3 = v1;
  sub_10034710(v1, LOBYTE(v40), (int)&v55);
  sub_10034E40(v3, v2, v50, &v48, (int)&v53, (bool *)&v49);
  v34 = sub_100356D0(0);
  v50[0] = sub_100438F0((int)&v55, v35 == 0);
  if ( v50[0] == 3 )
  {
    sub_100325C0(v3, v57, &v62);
    sub_10043C80((int)&v62, (int)&v59);
    if ( 0.0 == v61 )
      v61 = 32767.0;
    v4 = sub_1003B810(v56[0], v50[0], v61, v60);
  }
  else
  {
    v4 = sub_1003B810(v56[0], v50[0], 32767.0, v58);
  }
  v30 = v4;
  v37 = 0;
  sub_1007C470(9126, &v33, 1, &v37);
  v52 = 9.9999996e24;
  v40 = sub_10035790(COERCE_FLOAT(0x3FFFF));
  sub_1007C470(9122, &v51, 4, &v52);
  v33 = v33 && 9.9999996e24 != v51 && 9.9999996e24 != v40;
  result = sub_10035190(0);
  v6 = result;
  if ( result == -1 || !v32 )
  {
    result = sub_10035710(0);
    v6 = result;
  }
  if ( v6 == -1 || v27 == 1 )
    v6 = v34;
  v29 = -1;
  if ( v27 )
  {
    if ( v32 || (result = sub_10035150(0), v29 = result, result == -1) )
    {
      result = sub_10035530(0);
LABEL_22:
      result = sub_10035880(result);
      v29 = result;
      goto LABEL_23;
    }
    if ( !v30 )
      goto LABEL_22;
  }
LABEL_23:
  if ( v6 != -1 )
  {
    v38 = sub_10035150(0);
    v31 = sub_10035750(0);
    v36 = sub_100354B0(0);
    v39[0] = v6;
    result = sub_10035530(0);
    if ( (unsigned __int8)v6 < result )
    {
      while ( 1 )
      {
        v7 = v39[0];
        sub_10034BD0(0, v39[0], &v54);
        sub_1003B650(v7, 0, (int)&v55, (int)&v54, (int)&v41);
        if ( v41 || v42 )
          break;
LABEL_81:
        ++v39[0];
        result = sub_10035530(0);
        if ( v39[0] >= result )
          return result;
      }
      v8 = sub_100349E0(0, v7);
      v9 = sub_1002C480(v8, 0.0);
      v10 = sub_1002C090((_BYTE *)(a1 + 284), v9);
      v11 = v39[0];
      v12 = v10;
      if ( v38 == -1 || v39[0] <= (unsigned __int8)v38 )
      {
        v13 = v31;
      }
      else
      {
        v13 = v31;
        if ( v31 != -1 && v39[0] <= (unsigned __int8)v31 )
        {
          v14 = 1;
          goto LABEL_34;
        }
      }
      v14 = 0;
LABEL_34:
      v28 = v36 != -1 && v39[0] <= (unsigned __int8)v36 || v13 != -1 && v39[0] > v13;
      v15 = v29 != -1
         && v39[0] <= v29
         && !v14
         && ((unsigned __int8)sub_1002CE10(v54) || *(_BYTE *)(52 * (unsigned __int8)v11 + a1 + 7732) & 0x10);
      if ( !v41 )
        goto LABEL_73;
      *(_BYTE *)(v12 + 4) = v43;
      *(_BYTE *)(v12 + 5) = v44;
      if ( v33 && v39[0] >= v34 )
      {
        if ( v43 )
        {
          v19 = 9.9999996e24;
          *(float *)(v12 + 16) = 9.9999996e24;
        }
        else
        {
          v16 = v40;
          v17 = v51;
          v18 = sub_10045E10();
          *(float *)(v12 + 16) = sub_100919F0(v45, v18, v17, v16);
          v19 = 9.9999996e24;
        }
        if ( v41 == 13 && !v44 )
        {
          v20 = v40;
          v21 = v51;
          v22 = sub_10045E10();
          *(float *)(v12 + 20) = sub_100919F0(v46, v22, v21, v20);
          v19 = 9.9999996e24;
          goto LABEL_58;
        }
      }
      else
      {
        v19 = 9.9999996e24;
        *(float *)(v12 + 16) = 9.9999996e24;
      }
      *(float *)(v12 + 20) = v19;
LABEL_58:
      if ( v15 && (*(_BYTE *)(v12 + 2) & 0x18) != 16 || (*(_BYTE *)(v12 + 2) & 0x18) == 24 )
      {
        if ( v19 == *(float *)(v12 + 16) )
          v23 = v45;
        else
          v23 = *(float *)(v12 + 16);
        *(float *)(v12 + 8) = v23;
        if ( v19 == *(float *)(v12 + 20) )
          v24 = v46;
        else
          v24 = *(float *)(v12 + 20);
        *(float *)(v12 + 12) = v24;
        if ( v32 )
          *(_BYTE *)(v12 + 2) = v41 & 7 | 0x18;
        else
          *(_BYTE *)(v12 + 2) = 26;
        if ( v28 )
          *(_BYTE *)(v12 + 2) |= 0x40u;
        else
          *(_BYTE *)(v12 + 2) &= 0xBFu;
      }
LABEL_73:
      if ( v32 == 1 && v42 && v15 && (*(_BYTE *)(v12 + 3) & 0x18) != 16 )
      {
        *(float *)(v12 + 24) = v47;
        v25 = v42 | 0x18;
        *(_BYTE *)(v12 + 3) = v42 | 0x18;
        if ( v28 )
          v26 = v25 | 0x40;
        else
          v26 = v25 & 0xBF;
        *(_BYTE *)(v12 + 3) = v26;
      }
      goto LABEL_81;
    }
  }
  return result;
}
// 10045E10: using guessed type double sub_10045E10(void);

//----- (10035EB0) --------------------------------------------------------
int __cdecl sub_10035EB0(int a1, float a2, char a3, char a4, char a5, float a6, int a7, int a8, int a9)
{
  char v9; // al@2
  int v10; // eax@2
  const void *v11; // eax@2
  char v12; // cl@4
  double v13; // st7@5
  int result; // eax@15
  char v15; // [sp+Ch] [bp-34h]@3
  char v16; // [sp+Dh] [bp-33h]@4
  char v17; // [sp+Eh] [bp-32h]@2
  char v18; // [sp+Fh] [bp-31h]@2
  char v19; // [sp+10h] [bp-30h]@2
  char v20; // [sp+11h] [bp-2Fh]@2
  float v21; // [sp+14h] [bp-2Ch]@2
  float v22; // [sp+18h] [bp-28h]@2
  float v23; // [sp+1Ch] [bp-24h]@2
  float v24; // [sp+20h] [bp-20h]@2
  float v25; // [sp+24h] [bp-1Ch]@2
  float v26; // [sp+28h] [bp-18h]@4
  float v27; // [sp+2Ch] [bp-14h]@4
  float v28; // [sp+30h] [bp-10h]@4
  float v29; // [sp+34h] [bp-Ch]@4
  float v30; // [sp+38h] [bp-8h]@4
  float v31; // [sp+3Ch] [bp-4h]@2

  if ( (_BYTE)a1 != -1 )
  {
    v25 = 9.9999996e24;
    v21 = 9.9999996e24;
    v17 = 0;
    v23 = 9.9999996e24;
    v18 = 0;
    v22 = 9.9999996e24;
    v19 = 0;
    v24 = 9.9999996e24;
    v20 = 0;
    v31 = a6;
    v9 = sub_100349E0(0, a1);
    v10 = sub_1002C480(v9, a6);
    v11 = (const void *)sub_1002C040((_BYTE *)a7, v10);
    if ( v11 )
      qmemcpy(&v15, v11, 0x34u);
    v26 = 6.283185;
    v27 = 9.9999996e24;
    v29 = 9.9999996e24;
    v30 = 9.9999996e24;
    v28 = 6.283185;
    v12 = sub_100349E0(0, a1);
    v16 = v12;
    if ( a4 )
    {
      v17 = a4;
      v21 = a2;
      v13 = 9.9999996e24;
      v19 = a3;
      v22 = 9.9999996e24;
      v20 = 0;
    }
    else
    {
      v13 = 9.9999996e24;
    }
    if ( a5 )
    {
      v21 = v13;
      v17 = 0;
      v22 = v13;
      v19 = 0;
      v20 = 0;
    }
    if ( a6 != 0.0 )
    {
      if ( a6 >= 0.0 )
      {
        v15 = sub_100349E0(0, a1 + 1);
        goto LABEL_15;
      }
      if ( (_BYTE)a1 )
      {
        v15 = sub_100349E0(0, a1 - 1);
LABEL_15:
        sub_1002C200((int)&v15);
        sub_10035890((_BYTE *)a7, a1);
        sub_1002C160((_BYTE *)a7, (int)&v15);
        result = a9;
        *(float *)(a9 + 32) = 9.9999996e24;
        *(float *)(a9 + 40) = 0.0;
        *(_BYTE *)(a9 + 28) = 0;
        *(float *)(a9 + 36) = 6.283185;
        *(_BYTE *)(a9 + 29) = 0;
        *(_BYTE *)(a9 + 30) = 0;
        *(float *)(a9 + 44) = 9.9999996e24;
        *(_BYTE *)(a8 + 2) = 1;
        return result;
      }
    }
    v15 = v12;
    goto LABEL_15;
  }
  *(float *)(a9 + 32) = a2;
  *(float *)(a9 + 40) = a6;
  *(_BYTE *)(a9 + 28) = a3;
  *(_BYTE *)(a9 + 29) = a4;
  *(float *)(a9 + 36) = 6.283185;
  *(_BYTE *)(a9 + 30) = 0;
  *(float *)(a9 + 44) = 9.9999996e24;
  result = a8;
  *(_BYTE *)(a8 + 2) = 1;
  return result;
}

//----- (100360B0) --------------------------------------------------------
unsigned __int8 __cdecl sub_100360B0(int a1)
{
  int v1; // edi@1
  double v2; // st7@2
  int v3; // esi@2
  char v4; // al@3
  char v5; // al@3
  char v6; // al@4
  unsigned __int8 v7; // al@4
  unsigned __int8 v8; // cl@4

  sub_10035820();
  v1 = *(_BYTE *)(a1 + 284) - 1;
  if ( v1 >= 0 )
  {
    v2 = 0.0;
    v3 = 52 * v1 + a1 + 289;
    do
    {
      v4 = *(_BYTE *)v3;
      sub_10035810();
      if ( v5 == -1
        || (v6 = *(_BYTE *)(v3 - 1), sub_10035810(), v7 == -1) && v2 != *(float *)(v3 + 47)
        || v2 < *(float *)(v3 + 47) && v7 != v8 + 1
        || v2 > *(float *)(v3 + 47) && v8 && v7 != v8 - 1 )
      {
        memcpy_0((void *)(v3 - 1), (const void *)(v3 + 51), 52 * (--*(_BYTE *)(a1 + 284) - v1));
        v2 = 0.0;
      }
      --v1;
      v3 -= 52;
    }
    while ( v1 >= 0 );
  }
  return sub_10035960(a1);
}
// 10035810: using guessed type double sub_10035810(void);

//----- (10036180) --------------------------------------------------------
int __cdecl sub_10036180(int a1)
{
  unsigned __int16 v1; // ax@2
  bool v2; // cf@3
  bool v3; // zf@3
  int result; // eax@3
  __int64 v5; // [sp-4h] [bp-Ch]@0

  LODWORD(v5) = a1 & 0x3FFFF;
  if ( sub_1002EC50(v5)
    || (v1 = HIWORD(a1) >> 10, (unsigned __int16)(HIWORD(a1) >> 10) < 5u)
    || (v2 = v1 < 8u, v3 = v1 == 8, result = a1 & 0x3FFFF, !v2 && !v3) )
  {
    result = 0x3FFFF;
  }
  return result;
}

//----- (100361C0) --------------------------------------------------------
char __cdecl sub_100361C0(unsigned int a1, unsigned int *a2, _BYTE *a3, _BYTE *a4)
{
  char result; // al@1

  *a2 = a1 & 0x3FFFF;
  *a3 = (a1 >> 18) & 0x7F;
  result = (a1 >> 25) & 1;
  *a4 = result;
  return result;
}

//----- (100361F0) --------------------------------------------------------
int __cdecl sub_100361F0(int a1)
{
  int result; // eax@1
  signed int v2; // ecx@1
  unsigned __int16 v3; // [sp+Ch] [bp+4h]@1

  result = 0;
  v3 = *(_WORD *)(a1 + 4);
  v2 = 0;
  do
  {
    if ( v3 & (unsigned __int16)(1 << v2) )
      result += (unsigned __int16)word_10333C22;
    ++v2;
  }
  while ( v2 < 16 );
  return result;
}
// 10333C22: using guessed type __int16 word_10333C22;

//----- (10036230) --------------------------------------------------------
signed int __usercall sub_10036230@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v4; // eax@4

  if ( !a3 )
    return 1000;
  if ( a1 != 1000 )
  {
    v4 = 5 * a1;
    goto LABEL_7;
  }
  if ( a2 != 1000 )
  {
    v4 = 5 * a2 - 90;
LABEL_7:
    if ( abs(2 * v4 - a3) > 90 )
      a3 += 180;
  }
  return a3;
}

//----- (10036270) --------------------------------------------------------
signed int __thiscall sub_10036270(int this)
{
  int v1; // edi@1
  signed int result; // eax@1
  int v3; // ebx@2
  int v4; // esi@2
  __int16 v5; // cx@2
  char *v6; // eax@2
  unsigned __int16 v7; // [sp+4h] [bp-A4h]@2

  v1 = this;
  result = 0xFFFFFF;
  if ( *(_BYTE *)(this + 4) & 0x10 )
  {
    v3 = *(_DWORD *)this;
    v4 = v3 + sub_100361F0(this);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_103334D8)(v3, 160, &v7);
    v5 = *(_WORD *)(v1 + 4);
    v6 = (char *)&v7;
    if ( v5 & 1 )
    {
      v4 += v7;
      v6 = (char *)&v7 + (unsigned __int16)word_10333C22;
    }
    if ( v5 & 2 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_10333C22;
    }
    if ( v5 & 4 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_10333C22;
    }
    if ( v5 & 8 )
      v4 += *(_WORD *)v6;
    result = v4;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C22: using guessed type __int16 word_10333C22;

//----- (10036320) --------------------------------------------------------
signed int __usercall sub_10036320@<eax>(int a1@<edi>)
{
  signed int result; // eax@1
  int v2; // ebx@2
  int v3; // esi@2
  __int16 v4; // ax@2
  char *v5; // ecx@2
  unsigned __int16 v6; // [sp+0h] [bp-A4h]@2

  result = 0xFFFFFF;
  if ( *(_BYTE *)(a1 + 4) & 4 )
  {
    v2 = *(_DWORD *)a1;
    v3 = v2 + sub_100361F0(a1);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_103334D8)(v2, 160, &v6);
    v4 = *(_WORD *)(a1 + 4);
    v5 = (char *)&v6;
    if ( v4 & 1 )
    {
      v3 += v6;
      v5 = (char *)&v6 + (unsigned __int16)word_10333C22;
    }
    if ( v4 & 2 )
      v3 += *(_WORD *)v5;
    result = v3;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C22: using guessed type __int16 word_10333C22;

//----- (100363B0) --------------------------------------------------------
signed int __thiscall sub_100363B0(int this)
{
  int v1; // edi@1
  signed int result; // eax@1
  int v3; // ebx@2
  int v4; // esi@2
  __int16 v5; // cx@2
  char *v6; // eax@2
  unsigned __int16 v7; // [sp+4h] [bp-A4h]@2

  v1 = this;
  result = 0xFFFFFF;
  if ( *(_BYTE *)(this + 4) & 8 )
  {
    v3 = *(_DWORD *)this;
    v4 = v3 + sub_100361F0(this);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_103334D8)(v3, 160, &v7);
    v5 = *(_WORD *)(v1 + 4);
    v6 = (char *)&v7;
    if ( v5 & 1 )
    {
      v4 += v7;
      v6 = (char *)&v7 + (unsigned __int16)word_10333C22;
    }
    if ( v5 & 2 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_10333C22;
    }
    if ( v5 & 4 )
      v4 += *(_WORD *)v6;
    result = v4;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C22: using guessed type __int16 word_10333C22;

//----- (10036450) --------------------------------------------------------
int __usercall sub_10036450@<eax>(int a1@<esi>)
{
  int result; // eax@1

  result = 0xFFFFFF;
  if ( *(_BYTE *)(a1 + 4) & 1 )
    result = *(_DWORD *)a1 + sub_100361F0(a1);
  return result;
}

//----- (10036470) --------------------------------------------------------
char __usercall sub_10036470@<al>(unsigned int a1@<eax>, unsigned int *a2@<ebx>, _BYTE *a3@<edi>, int a4@<esi>, _DWORD *a5, int *a6)
{
  int *v6; // ebp@1

  v6 = a6;
  *a6 = 1000;
  *(_BYTE *)a1 = 95;
  *a2 = 1000;
  *a3 = 95;
  if ( *(_BYTE *)(a4 + 3) & 0x1F )
  {
    *v6 = *(_BYTE *)(a4 + 3) & 0x1F;
    *(_BYTE *)a1 = byte_100E86F0[((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7];
    *a2 = (*(_BYTE *)(a4 + 3) & 0x1F) + 18;
    a1 = ((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7;
    *a3 = byte_100E86E8[a1];
  }
  if ( *(_BYTE *)(a4 + 5) & 4 )
  {
    (*(void (__cdecl **)(_DWORD, signed int, int **))dword_103334D8)(*a5, 1, &a6);
    *a5 += (unsigned __int16)word_10333C26;
    LOBYTE(a1) = (_BYTE)a6;
    if ( (unsigned __int8)a6 & 0x1F )
    {
      a1 = ((unsigned __int8)a6 & 0x1F) + 18;
      *a2 = a1;
      *a3 = byte_100E86E8[((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7];
    }
    else
    {
      *a2 = 1000;
      *a3 = 95;
    }
  }
  return a1;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C26: using guessed type __int16 word_10333C26;

//----- (10036530) --------------------------------------------------------
void *__usercall sub_10036530@<eax>(int a1@<eax>, char *a2@<esi>)
{
  int v2; // ST0C_4@2
  int v3; // eax@2
  void *result; // eax@2

  if ( *(_WORD *)(a1 + 10) & 0x8000 )
  {
    LOWORD(v2) = *(_WORD *)(a1 + 22);
    HIWORD(v2) = (*(_DWORD *)(a1 + 16) >> 25) & 0x7F;
    v3 = v2 + dword_10333584;
    *(_DWORD *)a2 = v2 + dword_10333584;
    result = (void *)(*(int (__cdecl **)(int, signed int, char *, int))dword_103334D8)(v3, 2, a2 + 4, v2);
    *(_DWORD *)a2 += (unsigned __int16)word_10333588;
  }
  else
  {
    result = memcpy_0(a2, &unk_100E86F8, 6u);
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333584: using guessed type int dword_10333584;
// 10333588: using guessed type __int16 word_10333588;

//----- (10036590) --------------------------------------------------------
char __usercall sub_10036590@<al>(int a1@<ecx>, _BYTE *a2@<edi>)
{
  int v2; // ebx@1
  char *v3; // esi@1
  int v4; // edx@4
  char result; // al@4
  char v6; // [sp+8h] [bp-34h]@3
  char v7; // [sp+26h] [bp-16h]@2
  char v8; // [sp+35h] [bp-7h]@1

  v2 = a1;
  *a2 = 0;
  v3 = &v8;
  do
  {
    if ( v3 > &v7 )
    {
      (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(v2, 45, &v6);
      v3 = &v6;
    }
    ++*a2;
    v4 = (unsigned __int16)word_10333C2C;
    result = ((unsigned int)*((_WORD *)v3 + 5) >> 10) & 1;
    v2 += (unsigned __int16)word_10333C2C;
    if ( *((_WORD *)v3 + 5) & 0x200 )
    {
      v2 += (unsigned __int16)word_10333C2E;
      v4 = (unsigned __int16)word_10333C2E + (unsigned __int16)word_10333C2C;
    }
    v3 += v4;
  }
  while ( result );
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C2C: using guessed type __int16 word_10333C2C;
// 10333C2E: using guessed type __int16 word_10333C2E;

//----- (10036620) --------------------------------------------------------
int __usercall sub_10036620@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>)
{
  int v2; // edi@1
  int *v3; // edx@1
  int v4; // esi@4
  int result; // eax@4
  char v6; // cl@4
  char v7; // [sp+Ch] [bp-34h]@3
  char v8; // [sp+30h] [bp-10h]@2
  int v9; // [sp+3Ch] [bp-4h]@1

  v2 = a1;
  *a2 = 0;
  v3 = &v9;
  do
  {
    if ( v3 > (int *)&v8 )
    {
      (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(v2, 48, &v7);
      v3 = (int *)&v7;
    }
    ++*a2;
    v2 += (unsigned __int16)word_10333C24;
    v4 = (unsigned __int16)word_10333C24;
    result = *(_WORD *)((char *)v3 + 5);
    v6 = *((_BYTE *)v3 + 2) >> 7;
    if ( result & 4 )
    {
      v2 += (unsigned __int16)word_10333C26;
      v4 = (unsigned __int16)word_10333C26 + (unsigned __int16)word_10333C24;
    }
    if ( result & 8 )
    {
      v2 += (unsigned __int16)word_10333C28;
      v4 += (unsigned __int16)word_10333C28;
    }
    if ( result & 0x10 )
    {
      result = (unsigned __int16)word_10333C2A;
      v2 += (unsigned __int16)word_10333C2A;
      v4 += (unsigned __int16)word_10333C2A;
    }
    v3 = (int *)((char *)v3 + v4);
  }
  while ( v6 );
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C24: using guessed type __int16 word_10333C24;
// 10333C26: using guessed type __int16 word_10333C26;
// 10333C28: using guessed type __int16 word_10333C28;
// 10333C2A: using guessed type __int16 word_10333C2A;

//----- (100366C0) --------------------------------------------------------
__int16 __usercall sub_100366C0@<ax>(int a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // edi@1
  int v4; // eax@1
  int v5; // edi@2
  int v6; // ecx@6
  int v7; // edx@10
  char v8; // cl@10
  unsigned int v9; // eax@10
  int v10; // edx@16
  int v12; // [sp+0h] [bp-20h]@0
  __int16 v13; // [sp+Ch] [bp-14h]@2
  __int16 v14; // [sp+Eh] [bp-12h]@6
  int v15; // [sp+10h] [bp-10h]@2

  v3 = a1;
  sub_1002E250(a3 & 0x3FFFF, v12);
  *(_DWORD *)a2 >>= 7;
  *(_DWORD *)(a2 + 4) >>= 7;
  LOWORD(v4) = HIWORD(a3) >> 10;
  if ( HIWORD(a3) >> 10 != 5 )
  {
    if ( (_WORD)v4 == 6 )
    {
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_103334D8)(v3, 9, &v13);
      v7 = *(_DWORD *)a2 - 16 * v14;
      v8 = v15;
      v9 = (unsigned int)(unsigned __int8)v15 >> 4;
    }
    else
    {
      if ( (_WORD)v4 == 7 )
      {
        (*(void (__cdecl **)(int, signed int, __int16 *))dword_103334D8)(v3, 11, &v13);
      }
      else
      {
        if ( (_WORD)v4 != 8 )
          return v4;
        (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_103334D8)(v3, 15, &v13);
      }
      v7 = *(_DWORD *)a2 - 16 * v14;
      v8 = v15;
      v9 = (unsigned __int8)v15 >> 4;
    }
    *(_DWORD *)a2 = (v7 - (v8 & 0xF)) << 7;
    v10 = *(_DWORD *)(a2 + 4) - v9;
    v4 = 16 * v13;
    *(_DWORD *)(a2 + 4) = (v10 - v4) << 7;
    return v4;
  }
  (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_103334D8)(v3, 7, &v13);
  LOWORD(v4) = v15;
  v5 = (unsigned __int16)word_10333C24 + v3;
  if ( BYTE1(v15) & 8 )
  {
    if ( BYTE1(v15) & 4 )
      v5 += (unsigned __int16)word_10333C26;
    (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_103334D8)(v5, 19, &v13);
    if ( (HIWORD(a3) & 0x3FCu) > 0x1FC )
    {
      v4 = (signed __int16)v15;
      *(_DWORD *)a2 -= SHIWORD(v15);
      *(_DWORD *)(a2 + 4) -= v4;
      *(_DWORD *)a2 <<= 7;
      *(_DWORD *)(a2 + 4) <<= 7;
    }
    else
    {
      LOWORD(v4) = v14;
      v6 = v13;
      *(_DWORD *)a2 -= v14;
      *(_DWORD *)(a2 + 4) -= v6;
      *(_DWORD *)a2 <<= 7;
      *(_DWORD *)(a2 + 4) <<= 7;
    }
  }
  else
  {
    *(_DWORD *)a2 = 0x7FFFFFFF;
    *(_DWORD *)(a2 + 4) = 0x7FFFFFFF;
  }
  return v4;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C24: using guessed type __int16 word_10333C24;
// 10333C26: using guessed type __int16 word_10333C26;

//----- (10036830) --------------------------------------------------------
void *__cdecl sub_10036830(unsigned int a1, char *a2)
{
  int v2; // eax@2
  __int64 v4; // [sp-4h] [bp-24h]@0
  char v5; // [sp+4h] [bp-1Ch]@2
  __int16 v6; // [sp+Eh] [bp-12h]@1

  v6 &= 0x7FFFu;
  LODWORD(v4) = a1;
  if ( !sub_1002EC50(v4) )
  {
    v2 = sub_1002EC20(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(v2, 28, &v5);
  }
  return sub_10036530((int)&v5, a2);
}
// 103334D8: using guessed type int dword_103334D8;

//----- (10036880) --------------------------------------------------------
signed int __cdecl sub_10036880(unsigned __int8 a1)
{
  int v1; // ecx@0
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-10h]@3
  int v6; // [sp+Eh] [bp-6h]@3

  result = sub_10036270(v1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a1 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_103334D8)(v3, 15, &v5);
        if ( !(v6 & 0x400) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_10333C2C;
        if ( v6 & 0x200 )
          v3 += (unsigned __int16)word_10333C2E;
        if ( v4 >= a1 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C2C: using guessed type __int16 word_10333C2C;
// 10333C2E: using guessed type __int16 word_10333C2E;

//----- (10036900) --------------------------------------------------------
signed int __usercall sub_10036900@<eax>(int a1@<edi>, unsigned __int8 a2)
{
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-Ch]@3
  char v6; // [sp+9h] [bp-7h]@3

  result = sub_10036320(a1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a2 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_103334D8)(v3, 9, &v5);
        if ( !(v6 & 1) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_10333C44;
        if ( v4 >= a2 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C44: using guessed type __int16 word_10333C44;

//----- (10036970) --------------------------------------------------------
signed int __cdecl sub_10036970(unsigned __int8 a1)
{
  int v1; // ecx@0
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-Ch]@3
  int v6; // [sp+Ch] [bp-4h]@3

  result = sub_100363B0(v1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a1 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_103334D8)(v3, 11, &v5);
        if ( !(v6 & 0x8000) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_10333C46;
        if ( v4 >= a1 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C46: using guessed type __int16 word_10333C46;

//----- (100369E0) --------------------------------------------------------
int __usercall sub_100369E0@<eax>(int a1@<eax>, char a2)
{
  int result; // eax@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // [sp+4h] [bp-8h]@3
  char v6; // [sp+6h] [bp-6h]@3
  char v7; // [sp+9h] [bp-3h]@4

  result = sub_10036450(a1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a2 > 0 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(v3, 7, &v5);
        if ( !(v6 & 0x80) )
          break;
        v3 += (unsigned __int16)word_10333C24;
        ++v4;
        if ( v7 & 4 )
          v3 += (unsigned __int16)word_10333C26;
        if ( v7 & 8 )
          v3 += (unsigned __int16)word_10333C28;
        if ( v7 & 0x10 )
          v3 += (unsigned __int16)word_10333C2A;
        if ( v4 >= a2 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C24: using guessed type __int16 word_10333C24;
// 10333C26: using guessed type __int16 word_10333C26;
// 10333C28: using guessed type __int16 word_10333C28;
// 10333C2A: using guessed type __int16 word_10333C2A;

//----- (10036A70) --------------------------------------------------------
void __usercall sub_10036A70(int a1@<edi>, int a2, int a3)
{
  int v3; // [sp+4h] [bp-8h]@1
  int v4; // [sp+8h] [bp-4h]@1

  sub_100366C0(a3, (int)&v3, a2);
  *(double *)a1 = sub_10043B40(v3, 24);
  *(double *)(a1 + 8) = sub_10043B40(v4, 24);
}

//----- (10036AB0) --------------------------------------------------------
signed int __cdecl sub_10036AB0(unsigned int a1, unsigned __int8 a2)
{
  signed int result; // eax@2
  int v3; // [sp+Ch] [bp-8h]@1

  sub_10036830(a1, (char *)&v3);
  if ( sub_10036880(a2) == 0xFFFFFF )
  {
    result = 0x3FFFF;
  }
  else
  {
    v3 = a1;
    HIWORD(v3) = BYTE2(a1) & 3 | 4 * (a2 | 0x800);
    result = v3;
  }
  return result;
}

//----- (10036B20) --------------------------------------------------------
signed int __cdecl sub_10036B20(unsigned int a1, char a2, char a3)
{
  int v3; // esi@2
  signed int result; // eax@4
  int v5; // [sp+Ch] [bp-8h]@1

  sub_10036830(a1, (char *)&v5);
  if ( sub_100369E0((int)&v5, a2) == 0xFFFFFF )
  {
    result = 0x3FFFF;
  }
  else
  {
    v5 = a1;
    v3 = (a1 >> 16) & 3;
    HIWORD(v5) = v3 | 4 * ((unsigned __int8)a2 | 0x500);
    if ( a3 )
      HIWORD(v5) = v3 | 4 * ((unsigned __int8)a2 | 0x500) | 0x200;
    result = v5;
  }
  return result;
}

//----- (10036BA0) --------------------------------------------------------
__int16 __cdecl sub_10036BA0(unsigned int a1, char a2, int a3)
{
  int v3; // ebp@1
  __int16 v4; // bx@1
  unsigned int v5; // eax@1
  double v6; // st7@1
  unsigned int v7; // esi@1
  signed int v8; // eax@3
  unsigned __int16 v9; // dx@3
  int v10; // edx@3
  int v11; // eax@3
  int v12; // edx@3
  int v13; // ecx@3
  int v14; // edi@3
  int v15; // ecx@3
  double v16; // st7@3
  unsigned __int16 v17; // cx@3
  __int16 v18; // ax@3
  __int16 v19; // dx@3
  __int16 v20; // ax@3
  unsigned int v21; // edx@6
  __int16 v22; // cx@7
  double v23; // st5@8
  char v24; // al@12
  char v25; // cl@12
  unsigned int v26; // ecx@25
  unsigned int v27; // ecx@25
  unsigned __int16 v28; // dx@25
  float v30; // [sp+Ch] [bp-3Ch]@3
  char v31; // [sp+10h] [bp-38h]@1
  int v32; // [sp+18h] [bp-30h]@3
  int v33; // [sp+1Ch] [bp-2Ch]@3
  unsigned int v34; // [sp+20h] [bp-28h]@25
  unsigned int v35; // [sp+24h] [bp-24h]@25
  unsigned __int16 v36; // [sp+28h] [bp-20h]@2
  char v37; // [sp+2Ah] [bp-1Eh]@3
  unsigned __int16 v38; // [sp+2Bh] [bp-1Dh]@3
  unsigned __int16 v39; // [sp+2Dh] [bp-1Bh]@2
  __int16 v40; // [sp+34h] [bp-14h]@3
  __int16 v41; // [sp+36h] [bp-12h]@3
  __int16 v42; // [sp+38h] [bp-10h]@3
  __int16 v43; // [sp+3Ah] [bp-Eh]@3
  unsigned __int16 v44; // [sp+3Ch] [bp-Ch]@3
  unsigned __int8 v45; // [sp+3Eh] [bp-Ah]@3
  __int16 v46; // [sp+3Fh] [bp-9h]@7
  unsigned int v47; // [sp+41h] [bp-7h]@6
  unsigned __int16 v48; // [sp+45h] [bp-3h]@24

  v3 = a3;
  v4 = 0;
  *(_BYTE *)(a3 + 2) = 0;
  sub_10036830(a1, &v31);
  v5 = sub_100369E0((int)&v31, a2);
  v6 = 9.9999996e24;
  v7 = v5;
  if ( v5 != 0xFFFFFF )
  {
    (*(void (__cdecl **)(unsigned int, signed int, unsigned __int16 *))dword_103334D8)(v5, 12, &v36);
    LOWORD(v5) = word_10333C24;
    a3 = (unsigned __int16)word_10333C24 + v7;
    if ( v39 & 8 )
    {
      *(_BYTE *)(v3 + 2) = 1;
      sub_10036470(v3 + 7, (unsigned int *)(v3 + 16), (_BYTE *)(v3 + 8), (int)&v36, &a3, (int *)(v3 + 12));
      v8 = sub_10036230(*(_DWORD *)(v3 + 12), *(_DWORD *)(v3 + 16), (unsigned int)v38 >> 8);
      v9 = v39;
      *(_DWORD *)(v3 + 20) = v8;
      LOBYTE(v8) = v37 & 0xF;
      *(_WORD *)(v3 + 10) = v9 >> 5;
      v10 = a3;
      *(_BYTE *)(v3 + 9) = v8;
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_103334D8)(v10, 19, &v40);
      sub_1002E250(a1, (int)&v32);
      v11 = v32 >> 7;
      v12 = v40;
      v13 = v33 >> 7;
      *(_DWORD *)(v3 + 24) = ((v32 >> 7) - v41) << 7;
      v14 = v13 - v12;
      v32 = v11;
      *(_DWORD *)(v3 + 32) = (v11 - v43) << 7;
      v33 = v13;
      v15 = (v13 - v42) << 7;
      *(_DWORD *)(v3 + 28) = v14 << 7;
      *(_DWORD *)(v3 + 36) = v15;
      v16 = sub_1002ECF0(a1);
      v17 = v44;
      v30 = v16;
      a3 = (signed __int16)((signed __int16)(16 * v44) >> 4);
      v18 = 16 * v45;
      v19 = ((signed __int16)(16 * v44) >> 4) & 0xF00F;
      *(float *)(v3 + 40) = (double)a3 * 0.3048000037670135 + v30;
      v20 = (v17 >> 12) | (v19 | v18) & 0xFFF0;
      LOWORD(a3) = v20;
      if ( v20 & 0x800 )
        LOWORD(v5) = v5 | 0xF000;
      else
        LOWORD(v5) = v5 & 0xFFF;
      a3 = (signed __int16)v5;
      v21 = v47;
      *(_BYTE *)(v3 + 3) = 0;
      *(_BYTE *)(v3 + 4) = 0;
      *(_BYTE *)(v3 + 5) = 0;
      *(_BYTE *)(v3 + 6) = 0;
      *(float *)(v3 + 56) = v30 + 0.3048000037670135 * (double)(signed __int16)v5;
      v6 = 9.9999996e24;
      *(float *)(v3 + 44) = 9.9999996e24;
      *(float *)(v3 + 60) = 9.9999996e24;
      *(float *)(v3 + 52) = 9.9999996e24;
      *(float *)(v3 + 68) = 9.9999996e24;
      *(float *)(v3 + 76) = 9.9999996e24;
      *(float *)(v3 + 72) = 9.9999996e24;
      if ( (unsigned __int16)word_10333C28 >= 0xBu )
      {
        v22 = v46;
        LOWORD(v5) = v46 & 0x3FFF;
        if ( (v46 & 0x3FFF) != 0x3FFF )
        {
          a3 = (unsigned __int16)v5;
          LOWORD(v5) = (unsigned __int8)v21;
          *(float *)&a3 = (double)a3 / 10.0 - 350.0;
          v23 = *(float *)&a3;
          a3 = (unsigned __int8)v21;
          *(float *)(v3 + 44) = v23;
          *(float *)&a3 = (double)a3 / 10.0;
          if ( v22 & 0x8000 )
            *(float *)&a3 = -*(float *)&a3;
          *(float *)(v3 + 60) = v23 + *(float *)&a3;
        }
      }
      if ( (unsigned __int16)word_10333C28 < 0x13u )
      {
        *(float *)(v3 + 48) = 9.9999996e24;
        *(_BYTE *)v3 = 0;
        *(float *)(v3 + 64) = 9.9999996e24;
        *(_BYTE *)(v3 + 1) = 0;
        goto LABEL_33;
      }
      v24 = (v21 >> 18) & 1;
      v25 = (v21 >> 20) & 1;
      *(_BYTE *)v3 = v24;
      *(_BYTE *)(v3 + 1) = v25;
      if ( v24 )
      {
        a3 = (v21 >> 8) & 0x3FF;
        *(float *)(v3 + 48) = (double)(unsigned int)a3 / 100.0;
      }
      else
      {
        *(float *)(v3 + 48) = 9.9999996e24;
      }
      if ( v25 )
      {
        a3 = v21 >> 22;
        *(float *)(v3 + 64) = (double)(v21 >> 22) / 100.0;
      }
      else
      {
        *(float *)(v3 + 64) = 9.9999996e24;
      }
      if ( v24 && !(v21 & 0x80000) )
        *(float *)(v3 + 48) = *(float *)(v3 + 48) * -1.0;
      if ( v25 && !(v21 & 0x200000) )
        *(float *)(v3 + 64) = -1.0 * *(float *)(v3 + 64);
      LOWORD(v5) = v48;
      if ( v48 == -1 )
        goto LABEL_33;
      (*(void (__cdecl **)(int, signed int, unsigned int *))dword_103334D8)(
        dword_10333944 + (unsigned __int16)word_10333948 * v48,
        8,
        &v34);
      v5 = v34;
      v26 = v34 >> 31;
      *(_BYTE *)(v3 + 3) = (v34 >> 15) & 1;
      *(_BYTE *)(v3 + 4) = v26 & 1;
      v27 = v35;
      *(_BYTE *)(v3 + 5) = (v35 >> 15) & 1;
      *(_BYTE *)(v3 + 6) = (v27 >> 31) & 1;
      v28 = v36;
      if ( v5 & 0x4000 )
      {
        a3 = v36 - (v5 & 0x3FFF);
        *(float *)(v3 + 52) = (double)(unsigned int)a3 * 0.3048;
      }
      if ( v5 & 0x40000000 )
      {
        v5 = (v5 >> 16) & 0x3FFF;
        a3 = v28 - v5;
        *(float *)(v3 + 68) = (double)(unsigned int)a3 * 0.3048;
      }
      if ( v27 & 0x4000 )
      {
        v5 = v27 & 0x3FFF;
        a3 = v28 - v5;
        *(float *)(v3 + 76) = (double)(unsigned int)a3 * 0.3048;
      }
      if ( v27 & 0x40000000 )
      {
        a3 = v28 - ((v27 >> 16) & 0x3FFF);
        *(float *)(v3 + 72) = 0.3048 * (double)(unsigned int)a3;
        v6 = 9.9999996e24;
LABEL_33:
        v4 = 0;
        goto LABEL_34;
      }
      v4 = 0;
    }
    v6 = 9.9999996e24;
  }
LABEL_34:
  if ( *(_BYTE *)(v3 + 2) == (_BYTE)v4 )
  {
    *(_BYTE *)v3 = v4;
    *(_BYTE *)(v3 + 1) = v4;
    *(_DWORD *)(v3 + 12) = 1000;
    *(_DWORD *)(v3 + 16) = 1000;
    *(_DWORD *)(v3 + 20) = 1000;
    *(_WORD *)(v3 + 10) = v4;
    *(_BYTE *)(v3 + 7) = 95;
    *(_BYTE *)(v3 + 8) = 95;
    LOBYTE(v5) = byte_10333D4C;
    *(float *)(v3 + 40) = v6;
    *(float *)(v3 + 44) = v6;
    *(_BYTE *)(v3 + 9) = v5;
    *(float *)(v3 + 56) = v6;
    LOWORD(v5) = -1;
    *(float *)(v3 + 60) = v6;
    *(float *)(v3 + 48) = v6;
    *(_BYTE *)(v3 + 3) = v4;
    *(float *)(v3 + 64) = v6;
    *(_BYTE *)(v3 + 4) = v4;
    *(float *)(v3 + 52) = v6;
    *(_BYTE *)(v3 + 5) = v4;
    *(float *)(v3 + 68) = v6;
    *(_BYTE *)(v3 + 6) = v4;
    *(float *)(v3 + 76) = v6;
    *(_DWORD *)(v3 + 24) = 0x7FFFFFFF;
    *(float *)(v3 + 72) = v6;
    *(_DWORD *)(v3 + 28) = 0x7FFFFFFF;
    *(_DWORD *)(v3 + 32) = 0x7FFFFFFF;
    *(_DWORD *)(v3 + 36) = 0x7FFFFFFF;
  }
  return v5;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333944: using guessed type int dword_10333944;
// 10333948: using guessed type __int16 word_10333948;
// 10333C24: using guessed type __int16 word_10333C24;
// 10333C28: using guessed type __int16 word_10333C28;
// 10333D4C: using guessed type char byte_10333D4C;

//----- (10037080) --------------------------------------------------------
char __cdecl sub_10037080(unsigned int a1)
{
  int v1; // eax@1
  char result; // al@2
  char v3; // [sp+7h] [bp-9h]@1
  char v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  sub_10036830(a1, &v4);
  v1 = sub_10036270((int)&v4);
  if ( v1 == 0xFFFFFF )
  {
    result = 0;
  }
  else
  {
    sub_10036590(v1, &v3);
    result = v3;
  }
  return result;
}

//----- (100370D0) --------------------------------------------------------
char __cdecl sub_100370D0(unsigned int a1)
{
  __int64 v1; // ST00_8@1
  int v2; // esi@1
  char result; // al@3
  char v4; // [sp+Fh] [bp-9h]@1
  char v5; // [sp+10h] [bp-8h]@1

  v4 = 0;
  sub_10036830(a1, &v5);
  LODWORD(v1) = a1;
  v2 = sub_10036450((int)&v5);
  if ( sub_1002EC50(v1) )
  {
    result = 0;
  }
  else if ( v2 == 0xFFFFFF )
  {
    result = 0;
  }
  else
  {
    sub_10036620(v2, &v4);
    result = v4;
  }
  return result;
}

//----- (10037140) --------------------------------------------------------
int __cdecl sub_10037140(__int64 a1)
{
  int result; // eax@2
  char v2; // [sp+0h] [bp-8h]@1

  sub_10036830(a1 & 0x3FFFF, &v2);
  switch ( (unsigned int)WORD1(a1) >> 10 )
  {
    case 5u:
      result = sub_100369E0((int)&v2, (*(_DWORD *)((char *)&a1 + 2) >> 2) & 0x7F);
      break;
    case 6u:
      result = sub_10036900((int)&v2, *(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    case 7u:
      result = sub_10036970(*(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    case 8u:
      result = sub_10036880(*(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    default:
      result = 0xFFFFFF;
      break;
  }
  return result;
}

//----- (100371F0) --------------------------------------------------------
double __cdecl sub_100371F0(unsigned int a1)
{
  __int64 v2; // [sp-4h] [bp-64h]@0
  char v3; // [sp+7h] [bp-59h]@2
  float v4; // [sp+8h] [bp-58h]@1
  unsigned int v5; // [sp+Ch] [bp-54h]@2
  char v6; // [sp+10h] [bp-50h]@2
  float v7; // [sp+38h] [bp-28h]@4
  float v8; // [sp+48h] [bp-18h]@3

  v4 = 9.9999996e24;
  LODWORD(v2) = a1;
  if ( sub_1002EC50(v2) == 5 )
  {
    sub_100361C0(a1, &v5, &v4, &v3);
    sub_10036BA0(v5, SLOBYTE(v4), (int)&v6);
    if ( v3 )
    {
      v4 = v8;
      return v8;
    }
    v4 = v7;
  }
  return v4;
}

//----- (10037270) --------------------------------------------------------
double __cdecl sub_10037270(unsigned int a1)
{
  __int64 v2; // [sp-4h] [bp-64h]@0
  char v3; // [sp+7h] [bp-59h]@2
  float v4; // [sp+8h] [bp-58h]@1
  unsigned int v5; // [sp+Ch] [bp-54h]@2
  char v6; // [sp+10h] [bp-50h]@2
  float v7; // [sp+3Ch] [bp-24h]@4
  float v8; // [sp+4Ch] [bp-14h]@3

  v4 = 9.9999996e24;
  LODWORD(v2) = a1;
  if ( sub_1002EC50(v2) == 5 )
  {
    sub_100361C0(a1, &v5, &v4, &v3);
    sub_10036BA0(v5, SLOBYTE(v4), (int)&v6);
    if ( v3 )
    {
      v4 = v8;
      return v8;
    }
    v4 = v7;
  }
  return v4;
}

//----- (100372F0) --------------------------------------------------------
double __cdecl sub_100372F0(int a1)
{
  __int64 v1; // ST08_8@1
  int v2; // eax@1
  float v4; // [sp+0h] [bp-14h]@1
  char v5; // [sp+4h] [bp-10h]@2
  __int16 v6; // [sp+Eh] [bp-6h]@2

  LODWORD(v1) = a1;
  *((float *)&v1 + 1) = 6.2831855;
  v2 = sub_10037140(v1);
  if ( v2 != 0xFFFFFF )
  {
    (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(v2, 15, &v5);
    v4 = (double)(signed __int16)((signed __int16)(v6 << 7) >> 7) * 0.01745329238474369 * 0.5;
  }
  return v4;
}
// 103334D8: using guessed type int dword_103334D8;

//----- (10037360) --------------------------------------------------------
int __cdecl sub_10037360(int a1, int a2)
{
  int result; // eax@1
  int v3; // esi@1
  __int16 v4; // ax@2
  signed int v5; // eax@4
  char v6; // bl@4
  __int64 v7; // [sp-4h] [bp-58h]@0
  char v8; // [sp+Eh] [bp-46h]@3
  char v9; // [sp+Fh] [bp-45h]@3
  int v10; // [sp+10h] [bp-44h]@3
  int v11; // [sp+14h] [bp-40h]@3
  int v12; // [sp+18h] [bp-3Ch]@3
  char v13; // [sp+1Ch] [bp-38h]@3
  char v14; // [sp+23h] [bp-31h]@12
  char v15; // [sp+24h] [bp-30h]@10

  *(_DWORD *)a2 = 1600085855;
  *(_WORD *)(a2 + 4) = 24415;
  LODWORD(v7) = a1;
  *(_BYTE *)(a2 + 6) = 0;
  result = sub_10037140(v7);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = HIWORD(a1) >> 10;
    if ( HIWORD(a1) >> 10 == 5 )
    {
      (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(v3, 12, &v13);
      v10 = (unsigned __int16)word_10333C24 + v3;
      sub_10036470((unsigned int)&v9, (unsigned int *)&v12, &v8, (int)&v13, &v10, &v11);
      if ( (HIWORD(a1) & 0x3FCu) <= 0x1FC )
      {
        v6 = v9;
        v5 = v11;
      }
      else
      {
        v5 = v12;
        v6 = v8;
      }
      *(_BYTE *)a2 = 82;
      *(_BYTE *)(a2 + 1) = 87;
      if ( sub_10042120(v5, 2, (_BYTE *)(a2 + 2)) )
      {
        *(_BYTE *)(a2 + 4) = v6;
        *(_BYTE *)(a2 + 6) = 0;
      }
      else
      {
        *(_DWORD *)(a2 + 2) = 1600085855;
        *(_BYTE *)(a2 + 6) = 0;
      }
    }
    else if ( v4 == 6 )
    {
      (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(v3, 9, &v13);
      sub_1003A7A0(&v15, 5, a2);
      *(_BYTE *)(a2 + 5) = 0;
    }
    else if ( v4 == 7 )
    {
      (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_103334D8)(v3, 11, &v13);
      sub_1003A7A0(&v14, 3, a2);
      *(_BYTE *)(a2 + 3) = 0;
    }
    else
    {
      (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_103334D8)(v3, 15, &v13);
      sub_1003A7A0(&v14, 4, a2);
      *(_BYTE *)(a2 + 4) = 0;
    }
    result = sub_100423E0(a2, 0);
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333C24: using guessed type __int16 word_10333C24;

//----- (100374F0) --------------------------------------------------------
char __cdecl sub_100374F0(int a1, int a2)
{
  char v2; // bl@1
  int v3; // ebp@1
  int v4; // eax@2
  __int64 v6; // [sp-4h] [bp-30h]@0
  char v7; // [sp+10h] [bp-1Ch]@2
  unsigned int v8; // [sp+14h] [bp-18h]@2

  *(double *)a2 = 6.2831853071796;
  LODWORD(v6) = a1;
  *(double *)(a2 + 8) = 6.2831853071796;
  v2 = 0;
  v3 = sub_10037140(v6);
  if ( v3 != 0xFFFFFF )
  {
    v4 = sub_1002EC20(a1 & 0x3FFFF);
    (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(v4, 28, &v7);
    v2 = (v8 >> 29) & 1;
    sub_10036A70(a2, a1, v3);
  }
  return v2;
}
// 103334D8: using guessed type int dword_103334D8;

//----- (10037560) --------------------------------------------------------
__int16 __cdecl sub_10037560(int a1, int a2)
{
  int v2; // eax@1
  __int64 v4; // [sp-4h] [bp-Ch]@0

  LODWORD(v4) = a1;
  *(_DWORD *)a2 = 2147483648;
  *(_DWORD *)(a2 + 4) = 2147483648;
  v2 = sub_10037140(v4);
  if ( v2 != 0xFFFFFF )
    LOWORD(v2) = sub_100366C0(v2, a2, a1);
  return v2;
}

//----- (100375A0) --------------------------------------------------------
void __cdecl sub_100375A0(int a1, int a2, void *a3)
{
  signed int v3; // edi@1
  int v4; // edi@2
  char v5; // dh@2
  unsigned int v6; // eax@2
  unsigned __int16 v7; // cx@2
  char v8; // bl@2
  bool v9; // zf@2
  signed int v10; // ST34_4@2
  float v11; // ST34_4@2
  float v12; // ST34_4@3
  int v13; // eax@4
  unsigned int v14; // edi@5
  signed int v15; // ST08_4@5
  double v16; // st7@5
  signed int v17; // edx@5
  double v18; // st7@5
  __int16 v19; // [sp+18h] [bp-2Ch]@5
  __int16 v20; // [sp+1Ah] [bp-2Ah]@5
  unsigned __int8 v21; // [sp+1Ch] [bp-28h]@5
  unsigned __int16 v22; // [sp+1Dh] [bp-27h]@5
  int v23; // [sp+20h] [bp-24h]@5
  int v24; // [sp+24h] [bp-20h]@5
  char v25; // [sp+28h] [bp-1Ch]@1
  char v26; // [sp+30h] [bp-14h]@2
  char v27; // [sp+37h] [bp-Dh]@2
  unsigned __int16 v28; // [sp+38h] [bp-Ch]@2
  unsigned int v29; // [sp+3Ah] [bp-Ah]@2
  unsigned __int8 v30; // [sp+3Eh] [bp-6h]@3

  memcpy_0(a3, &dword_100EBB80, 7u);
  *((double *)a3 + 2) = 6.2831853071796;
  *((double *)a3 + 3) = 6.2831853071796;
  *((double *)a3 + 4) = 6.2831853071796;
  *((_BYTE *)a3 + 12) = 0;
  *((double *)a3 + 5) = 6.2831853071796;
  *((_BYTE *)a3 + 14) = 0;
  *((float *)a3 + 12) = 6.2831855;
  *((float *)a3 + 13) = 9.9999996e24;
  *((_DWORD *)a3 + 2) = 0xFFFF;
  *((_BYTE *)a3 + 13) = 127;
  *((float *)a3 + 14) = 6.2831855;
  *((float *)a3 + 15) = 6.2831855;
  sub_10036830(a1, &v25);
  v3 = sub_10036880(a2);
  if ( v3 != 0xFFFFFF )
  {
    (*(void (__cdecl **)(signed int, signed int, char *))dword_103334D8)(v3, 15, &v26);
    v4 = (unsigned __int16)word_10333C2C + v3;
    sub_1003A7A0(&v27, 4, (int)a3);
    sub_100423E0((int)a3, 4);
    v5 = HIBYTE(v28);
    v6 = v28;
    *((_DWORD *)a3 + 2) = 50 * ((unsigned __int8)v28 + 2160);
    v7 = v29;
    v8 = (v29 >> 9) & 1;
    v9 = ((v6 >> 8) & 0xFFFFFF80) == 0;
    LOWORD(v6) = v29;
    *((_BYTE *)a3 + 13) = v5 & 0x7F;
    *((_BYTE *)a3 + 14) = !v9;
    v10 = (unsigned __int16)((v7 >> 12) + 16 * BYTE2(v29));
    *((float *)a3 + 12) = (double)(signed __int16)((signed __int16)((_WORD)v6 << 7) >> 7) * 0.01745329238474369 * 0.5;
    *((_BYTE *)a3 + 12) = v8;
    v11 = 0.01745329238474369 * ((double)v10 / 10.0);
    *((float *)a3 + 14) = sub_1007BCB0(v11);
    if ( (unsigned __int16)word_10333C2C > 0xDu )
    {
      v12 = (double)(unsigned __int16)(8 * v30 + (unsigned __int8)(BYTE3(v29) >> 5)) / 100.0 * 0.01745329238474369;
      *((float *)a3 + 15) = sub_1007BCB0(v12);
    }
    v13 = sub_10036AB0(a1, a2);
    sub_100374F0(v13, (int)a3 + 16);
    if ( v29 & 0x200 )
    {
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_103334D8)(v4, 7, &v19);
      sub_1002E250(a1, (int)&v23);
      v14 = (v24 >> 7) + -16 * v19 - ((unsigned int)v21 >> 4);
      v15 = ((v23 >> 7) + -16 * v20 - (v21 & 0xF)) << 7;
      v23 >>= 7;
      v24 >>= 7;
      *((double *)a3 + 4) = sub_10043B40(v15, 24);
      v16 = sub_10043B40(v14 << 7, 24);
      v17 = v22;
      *((double *)a3 + 5) = v16;
      v18 = (double)v17 / 100.0 * 0.01745329238474369;
    }
    else
    {
      *((double *)a3 + 4) = 6.2831853071796;
      *((double *)a3 + 5) = 6.2831853071796;
      v18 = 9.9999996e24;
    }
    *((float *)a3 + 13) = v18;
  }
}
// 100EBB80: using guessed type int dword_100EBB80;
// 103334D8: using guessed type int dword_103334D8;
// 10333C2C: using guessed type __int16 word_10333C2C;

//----- (10037840) --------------------------------------------------------
int __cdecl sub_10037840(int a1, void *a2)
{
  __int64 v2; // ST0C_8@1
  int result; // eax@1
  int v4; // ebx@1
  __int16 v5; // dx@2
  char v6; // [sp+10h] [bp-Ch]@2
  int v7; // [sp+18h] [bp-4h]@2

  memcpy_0(a2, &dword_100EBB80, 7u);
  *((double *)a2 + 1) = 6.2831853071796;
  *((double *)a2 + 2) = 6.2831853071796;
  LODWORD(v2) = a1;
  *((_WORD *)a2 + 12) = -1;
  *((_BYTE *)a2 + 26) = 0;
  *((_BYTE *)a2 + 30) = 0;
  result = sub_10037140(v2);
  v4 = result;
  if ( result != 0xFFFFFF )
  {
    sub_10037360(a1, (int)a2);
    sub_100374F0(a1, (int)a2 + 8);
    (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(v4, 11, &v6);
    result = v7 & 0x7FFF;
    v5 = BYTE2(v7) & 3;
    *((_WORD *)a2 + 12) = result;
    *((_BYTE *)a2 + 30) = 0;
    *((_WORD *)a2 + 14) = v5;
    *((_BYTE *)a2 + 26) = 1;
  }
  return result;
}
// 100EBB80: using guessed type int dword_100EBB80;
// 103334D8: using guessed type int dword_103334D8;

//----- (100378E0) --------------------------------------------------------
bool __usercall sub_100378E0@<al>(unsigned int a1@<esi>, int a2, float a3, char a4, char a5, char a6, float a7, char a8)
{
  __int64 v8; // ST1C_8@3
  char v9; // ST3C_1@3
  bool v10; // ST44_1@3
  float v11; // ST40_4@3
  float v12; // ST48_4@3
  int v14; // [sp+34h] [bp-28h]@3
  char v15; // [sp+3Ch] [bp-20h]@3
  int v16; // [sp+4Ch] [bp-10h]@3

  sub_10039B40();
  sub_1002D210(&byte_10333D80);
  if ( (byte_10333D83 & 0x30) == 32 )
    sub_1002CE60((int)&byte_10333D80, byte_10333D80, 0xFFu, 0);
  sub_1002E9E0(0, a1, (double *)&v15);
  sub_1007BCF0((int)&v15, (int)&v14);
  LODWORD(v8) = a1;
  v9 = sub_10037F30(a1);
  v10 = sub_10037F00(v8) == 0;
  v11 = sub_10037F60(*(float *)&a1);
  sub_1002EB10(a1, (char *)&v16);
  v12 = sub_1002ECF0(a1);
  sub_1002CD10(&unk_10333E68);
  byte_10333D84 &= 0xFDu;
  sub_1002C750(a1, a2, (int)&v14, v9, v10, v12, v11, (int)&v16, (int)&byte_10333D80);
  flt_10335AF4 = a3;
  byte_10335A8C = a8;
  byte_10335AF0 = 0;
  sub_10035EB0(a2, a3, a4, a5, a6, a7, (int)&unk_10333E9C, (int)&unk_10335A08, (int)&unk_10335A1C);
  sub_1002CE60((int)&byte_10333D80, a2, 0xFFu, 0);
  byte_10333DAC = 0;
  sub_10039B70(&byte_10333D80);
  return sub_10039B30();
}
// 10333D80: using guessed type char byte_10333D80;
// 10333D83: using guessed type char byte_10333D83;
// 10333D84: using guessed type char byte_10333D84;
// 10333DAC: using guessed type char byte_10333DAC;
// 10335A8C: using guessed type char byte_10335A8C;
// 10335AF0: using guessed type char byte_10335AF0;
// 10335AF4: using guessed type float flt_10335AF4;

//----- (10037A50) --------------------------------------------------------
bool __cdecl sub_10037A50(int a1, int a2, float a3, int a4, int a5, float a6)
{
  return sub_100378E0(a1, a2, a3, a4, a5, 0, a6, 0);
}

//----- (10037A90) --------------------------------------------------------
float sub_10037A90()
{
  float v0; // esi@2
  int v1; // edi@2
  float result; // eax@2

  if ( (unsigned __int8)sub_1004A110() )
  {
    sub_1007C110(100, 60000);
    v0 = *(float *)(dword_10333D60 + 1144);
    v1 = *(_DWORD *)(dword_10333D60 + 1148);
    sub_1007C0F0(100);
    result = v0;
  }
  else
  {
    result = 6.283185;
  }
  return result;
}
// 10333D60: using guessed type int dword_10333D60;

//----- (10037AF0) --------------------------------------------------------
void __cdecl sub_10037AF0(unsigned int a1, char *a2, float *a3, int a4, char a5)
{
  int v5; // eax@1
  int v6; // edx@1
  unsigned int v7; // eax@2
  float *v8; // edi@2
  int v9; // ebp@2
  int v10; // ecx@3
  int v11; // ebx@3
  float *v12; // esi@3
  int v13; // ebx@6
  char v14; // bl@10
  unsigned int v15; // eax@10
  int v16; // eax@11
  float *v17; // ecx@11
  int v18; // edx@11
  int v19; // edi@11
  int v20; // esi@11
  unsigned int v21; // ebp@11
  int v22; // ST30_4@13
  float v23; // ST30_4@13
  float v24; // ST30_4@13
  int v25; // ST30_4@15
  float v26; // ST30_4@15
  float v27; // ST30_4@15
  int v28; // ST30_4@17
  float v29; // ST30_4@17
  float v30; // ST30_4@17
  int v31; // ST30_4@19
  float v32; // ST30_4@19
  float v33; // ST30_4@19
  float *v34; // edx@23
  int v35; // ecx@23
  int v36; // ST30_4@25
  float v37; // ST30_4@25
  float v38; // ST30_4@25
  unsigned int v39; // [sp+8h] [bp-38h]@9
  int v40; // [sp+Ch] [bp-34h]@23
  unsigned int v41; // [sp+10h] [bp-30h]@11
  int v42; // [sp+10h] [bp-30h]@23
  unsigned int v43; // [sp+14h] [bp-2Ch]@3
  int v44; // [sp+14h] [bp-2Ch]@11
  int v45; // [sp+14h] [bp-2Ch]@23
  int v46; // [sp+18h] [bp-28h]@1
  int v47; // [sp+1Ch] [bp-24h]@1
  char v48; // [sp+20h] [bp-20h]@6
  char v49; // [sp+30h] [bp-10h]@2

  sub_10037A90();
  v46 = v5;
  v47 = v6;
  if ( sub_10062080((int)&v46, (int)&unk_100E8CE8) )
  {
    sub_1007BDD0((int)&v46, (int)&v49);
    v7 = a1;
    v8 = a3;
    v9 = a4;
    if ( a1 )
    {
      v10 = (int)&a2[-a4];
      v11 = a4 - (_DWORD)a3;
      v12 = a3;
      v43 = a1;
      do
      {
        if ( !a5 || *v12 >= 9.8999998e24 )
        {
          v13 = (int)v12 + v11;
          sub_1002E9E0(0, *(_DWORD *)(v13 + v10), (double *)&v48);
          sub_1002BE50((int)&v49, (int)&v48, 1, v12, v13);
          v10 = (int)&a2[-a4];
          v11 = a4 - (_DWORD)a3;
        }
        ++v12;
        --v43;
      }
      while ( v43 );
      v7 = a1;
    }
    v39 = v7;
    do
    {
      v14 = 0;
      v15 = 1;
      if ( (signed int)(v39 - 1) >= 4 )
      {
        v44 = a2 - (char *)v8;
        v16 = v9 - (_DWORD)v8;
        v17 = v8;
        v18 = v9 + 8;
        v19 = (int)&a2[-v9];
        v20 = (int)(a2 + 12);
        v21 = ((v39 - 5) >> 2) + 1;
        v41 = v21;
        v46 = 4 * v21 + 1;
        do
        {
          if ( *v17 > (double)v17[1] )
          {
            v22 = *(_DWORD *)((char *)v17 + v44);
            *(float *)((char *)v17 + v44) = *(float *)(v20 - 8);
            v21 = v41;
            *(_DWORD *)(v20 - 8) = v22;
            v23 = *v17;
            v14 = 1;
            *v17 = v17[1];
            v17[1] = v23;
            v24 = *(float *)((char *)v17 + v16);
            *(float *)((char *)v17 + v16) = *(float *)(v18 - 4);
            *(float *)(v18 - 4) = v24;
          }
          if ( v17[1] > (double)v17[2] )
          {
            v25 = *(_DWORD *)(v20 - 8);
            *(_DWORD *)(v20 - 8) = *(_DWORD *)(v18 + v19);
            *(_DWORD *)(v18 + v19) = v25;
            v26 = v17[1];
            v14 = 1;
            v17[1] = v17[2];
            v17[2] = v26;
            v27 = *(float *)(v18 - 4);
            *(float *)(v18 - 4) = *(float *)v18;
            *(float *)v18 = v27;
          }
          if ( v17[2] > (double)v17[3] )
          {
            v28 = *(_DWORD *)(v18 + v19);
            *(_DWORD *)(v18 + v19) = *(_DWORD *)v20;
            *(_DWORD *)v20 = v28;
            v29 = v17[2];
            v14 = 1;
            v17[2] = v17[3];
            v17[3] = v29;
            v30 = *(float *)v18;
            *(float *)v18 = *(float *)(v18 + 4);
            *(float *)(v18 + 4) = v30;
          }
          if ( v17[3] > (double)v17[4] )
          {
            v31 = *(_DWORD *)v20;
            *(_DWORD *)v20 = *(_DWORD *)(v20 + 4);
            *(_DWORD *)(v20 + 4) = v31;
            v32 = v17[3];
            v14 = 1;
            v17[3] = v17[4];
            v17[4] = v32;
            v33 = *(float *)(v18 + 4);
            *(float *)(v18 + 4) = *(float *)(v18 + 8);
            *(float *)(v18 + 8) = v33;
          }
          v17 += 4;
          v18 += 16;
          v20 += 16;
          v41 = --v21;
        }
        while ( v21 );
        v9 = a4;
        v8 = a3;
        v15 = v46;
      }
      if ( v15 < v39 )
      {
        v45 = a2 - (char *)v8;
        v40 = v9 - (_DWORD)v8;
        v42 = (int)&a2[-v9];
        v34 = (float *)(v9 + 4 * v15);
        v35 = (int)&v8[v15 - 1];
        v46 = v39 - v15;
        do
        {
          if ( *(float *)v35 > (double)*(float *)(v35 + 4) )
          {
            v36 = *(_DWORD *)(v45 + v35);
            *(float *)(v45 + v35) = *(float *)((char *)v34 + v42);
            *(_DWORD *)((char *)v34 + v42) = v36;
            v37 = *(float *)v35;
            v14 = 1;
            *(float *)v35 = *(float *)(v35 + 4);
            *(float *)(v35 + 4) = v37;
            v38 = *(float *)(v40 + v35);
            *(float *)(v40 + v35) = *v34;
            *v34 = v38;
          }
          v35 += 4;
          ++v34;
          --v46;
        }
        while ( v46 );
      }
      --v39;
    }
    while ( v14 );
  }
  else if ( a1 )
  {
    memset32(a2, 0x3FFFF, a1);
  }
}

//----- (10037E30) --------------------------------------------------------
void __cdecl sub_10037E30(signed int a1, char *a2)
{
  unsigned int v2; // eax@1
  char v3; // [sp+0h] [bp-F8h]@5
  char v4; // [sp+7Ch] [bp-7Ch]@5

  v2 = a1;
  if ( a1 <= 31 )
  {
    if ( a1 < 0 )
      v2 = 0;
  }
  else
  {
    v2 = 31;
  }
  sub_10037AF0(v2, a2, (float *)&v4, (int)&v3, 0);
}

//----- (10037E70) --------------------------------------------------------
int __cdecl sub_10037E70(int a1, int a2, int a3, void *a4, int a5)
{
  signed int v5; // ebx@1
  int v6; // eax@2
  int result; // eax@6

  *(_DWORD *)a5 = 0;
  sub_1002E590((const char *)a1, (int)a4, (signed int *)a5);
  v5 = sub_1003AB30(a1);
  if ( v5 != 0x3FFFF )
  {
    memcpy_0((char *)a4 + 4, a4, 0x78u);
    *(_DWORD *)a4 = v5;
    v6 = *(_DWORD *)a5 + 1;
    if ( v6 >= 31 )
      v6 = 31;
    *(_DWORD *)a5 = v6;
  }
  if ( *(_DWORD *)a5 <= 0 )
  {
    result = a3;
    *(_DWORD *)a2 = 0x3FFFF;
    *(_BYTE *)a3 = 29;
  }
  else
  {
    *(_DWORD *)a2 = *(_DWORD *)a4;
    result = *(_DWORD *)a5 <= 1 ? 0 : 8;
    *(_BYTE *)a3 = result;
  }
  return result;
}

//----- (10037F00) --------------------------------------------------------
char __cdecl sub_10037F00(__int64 a1)
{
  char result; // al@5

  if ( (unsigned int)a1 < 0x3E8 || (_DWORD)a1 == 262141 )
  {
    result = 4;
  }
  else if ( (_DWORD)a1 == 0x3FFFF || (_DWORD)a1 == 262142 )
  {
    result = 9;
  }
  else
  {
    result = sub_1002EC50(a1);
  }
  return result;
}

//----- (10037F30) --------------------------------------------------------
char __cdecl sub_10037F30(unsigned int a1)
{
  char result; // al@5

  if ( a1 < 0x3E8 || a1 == 262141 )
  {
    result = 1;
  }
  else if ( a1 == 0x3FFFF || a1 == 262142 )
  {
    result = 0;
  }
  else
  {
    result = sub_1002DC90(a1);
  }
  return result;
}

//----- (10037F60) --------------------------------------------------------
double __cdecl sub_10037F60(float a1)
{
  unsigned int v1; // esi@1
  char v2; // al@1
  char v3; // al@2
  double result; // st7@2
  __int64 v5; // [sp-4h] [bp-20h]@0
  char v6; // [sp+4h] [bp-18h]@9
  char v7; // [sp+Ch] [bp-10h]@9

  v1 = LODWORD(a1);
  *(float *)&v5 = a1;
  v2 = sub_10037F00(v5);
  if ( v1 == 262141 )
  {
    v3 = sub_1002AD10();
    a1 = sub_1002A710(v3);
    result = a1;
  }
  else
  {
    switch ( v2 )
    {
      case 9:
        a1 = 6.2831855;
        result = (float)6.2831855;
        break;
      case 8:
        a1 = sub_100372F0(v1);
        result = a1;
        break;
      case 3:
        a1 = sub_1003AFB0(v1);
        result = a1;
        break;
      default:
        sub_1002E9E0(0, v1, (double *)&v7);
        sub_1007BCF0((int)&v7, (int)&v6);
        sub_1003B630((int)&v6, &a1);
        result = a1;
        break;
    }
  }
  return result;
}

//----- (10038020) --------------------------------------------------------
signed int __cdecl sub_10038020(const void *a1, _DWORD *a2, _BYTE *a3)
{
  signed int result; // eax@2
  _DWORD *v4; // [sp+10h] [bp-A4h]@1
  int v5; // [sp+14h] [bp-A0h]@1
  int v6; // [sp+18h] [bp-9Ch]@1
  __int16 *v7; // [sp+1Ch] [bp-98h]@1
  int v8; // [sp+20h] [bp-94h]@1
  int *v9; // [sp+24h] [bp-90h]@1
  int v10; // [sp+28h] [bp-8Ch]@1
  int v11; // [sp+2Ch] [bp-88h]@1
  __int16 v12; // [sp+30h] [bp-84h]@1
  char v13; // [sp+34h] [bp-80h]@1

  *a2 = 0x3FFFF;
  v12 = -32758;
  qmemcpy(&v13, a1, 0x44u);
  v6 = 0;
  v11 = 4;
  v7 = &v12;
  v8 = 128;
  v9 = (int *)&v4;
  v10 = 400;
  v4 = a2;
  v5 = 4;
  if ( sub_1007C1A0(21, (int)&v7) )
  {
    sub_10042930("..\\lib\\adl\\udb_intf_wpt.c", 156, 0, 0);
    result = v6;
  }
  else
  {
    result = v6;
    if ( !v6 && v5 == 4 )
      goto LABEL_7;
  }
  *a2 = 0x3FFFF;
  if ( !result )
    result = 29;
LABEL_7:
  *a3 = result;
  return result;
}

//----- (10038280) --------------------------------------------------------
double __cdecl sub_10038280(float a1, float a2, float a3, float a4, float a5)
{
  float v6; // [sp+14h] [bp+14h]@1
  float v7; // [sp+14h] [bp+14h]@1

  v6 = 15000.0 - a5;
  v7 = sqrt(519.0 / (a4 + 459.0))
     * ((1.039999961853027 - COERCE_FLOAT(LODWORD(v6) & 0x7FFFFFFF) / 15000.0 * 0.03999999910593033)
      * a3);
  return (float)(v7 / 28.03000068664551 * (a2 / 2700.0) * 1761.0 / (a1 * 5.849999904632568));
}

//----- (10038300) --------------------------------------------------------
double __cdecl sub_10038300(float a1, float a2, float a3, float a4)
{
  float v5; // [sp+10h] [bp+10h]@1

  v5 = 15000.0 - a4;
  return (float)((1.039999961853027 - COERCE_FLOAT(LODWORD(v5) & 0x7FFFFFFF) / 15000.0 * 0.03999999910593033)
               * a3
               / 28.03000068664551
               * (a2
                / 2700.0)
               * 1761.0
               / (a1
                * 5.849999904632568));
}

//----- (10038360) --------------------------------------------------------
char __cdecl sub_10038360(float a1, float a2, float a3, int a4)
{
  unsigned __int8 v4; // dl@2
  double v5; // st6@2
  char v6; // cl@6
  int v7; // ecx@9
  double v8; // st7@9
  char result; // al@10
  float v10; // [sp+8h] [bp+8h]@2
  float v11; // [sp+8h] [bp+8h]@4
  float v12; // [sp+8h] [bp+8h]@9
  float v13; // [sp+8h] [bp+8h]@10
  float v14; // [sp+8h] [bp+8h]@10
  float v15; // [sp+8h] [bp+8h]@10
  float v16; // [sp+8h] [bp+8h]@10
  float v17; // [sp+8h] [bp+8h]@10

  if ( COERCE_FLOAT(LODWORD(a2) & 0x7FFFFFFF) <= 1.0e-18 )
  {
    result = 0;
  }
  else
  {
    v4 = byte_102574CC - 1;
    v10 = a1 / a2;
    v5 = v10;
    if ( flt_102574D4[0] >= (double)v10 )
      v5 = flt_102574D4[0];
    v11 = flt_102574D4[v4];
    if ( v11 <= v5 )
      v5 = v11;
    v6 = 1;
    if ( v4 > 1u )
    {
      do
      {
        if ( flt_102574D4[(unsigned __int8)v6] >= v5 )
          break;
        ++v6;
      }
      while ( (unsigned __int8)v6 < v4 );
    }
    v7 = (unsigned __int8)v6;
    v12 = flt_102574D4[v7] - flt_102574D0[v7];
    v8 = v12;
    if ( COERCE_FLOAT(LODWORD(v12) & 0x7FFFFFFF) <= 1.0e-18 )
    {
      result = 0;
    }
    else
    {
      v13 = flt_1025754C[v7] - flt_10257548[v7];
      v14 = (v5 - flt_102574D0[v7]) * v13;
      v15 = v14 / v8;
      v16 = v15 + flt_10257548[v7];
      v17 = v16 * a3;
      *(float *)a4 = flt_100E8DF8[3
                                * (unsigned __int8)sub_10043FF0(
                                                     &byte_102574C1,
                                                     1u,
                                                     (int)&unk_100E8DF0,
                                                     12,
                                                     4,
                                                     (unsigned __int8)byte_102574C0)]
                   * v17;
      result = 1;
    }
  }
  return result;
}
// 100E8DF8: using guessed type float flt_100E8DF8[];
// 102574C0: using guessed type char byte_102574C0;
// 102574C1: using guessed type char byte_102574C1;
// 102574CC: using guessed type char byte_102574CC;
// 102574D0: using guessed type float flt_102574D0[];
// 102574D4: using guessed type float flt_102574D4[];
// 10257548: using guessed type float flt_10257548[];
// 1025754C: using guessed type float flt_1025754C[];

//----- (100384D0) --------------------------------------------------------
char __cdecl sub_100384D0(float a1, float a2, float a3, float a4, int a5)
{
  float v5; // ST1C_4@2
  unsigned __int8 v6; // al@4
  unsigned __int8 v7; // cl@4
  float v8; // ST1C_4@4
  double v9; // st7@4
  double v10; // st6@4
  char v11; // dl@8
  int v12; // ecx@11
  double v13; // st5@11
  char result; // al@13
  double v15; // [sp+4h] [bp-8h]@2
  float v16; // [sp+10h] [bp+4h]@4
  float v17; // [sp+10h] [bp+4h]@4
  float v18; // [sp+10h] [bp+4h]@6
  float v19; // [sp+10h] [bp+4h]@11
  float v20; // [sp+10h] [bp+4h]@12
  float v21; // [sp+10h] [bp+4h]@12
  float v22; // [sp+10h] [bp+4h]@12
  float v23; // [sp+10h] [bp+4h]@12
  float v24; // [sp+10h] [bp+4h]@12
  float v25; // [sp+10h] [bp+4h]@12

  if ( COERCE_FLOAT(LODWORD(a1) & 0x7FFFFFFF) <= 1.0e-18 )
    goto LABEL_17;
  v15 = a4 + 273.0;
  v5 = v15;
  if ( COERCE_FLOAT(LODWORD(v5) & 0x7FFFFFFF) <= 1.0e-18 || flt_102574B8 >= (double)a2 )
    goto LABEL_17;
  v6 = sub_10043FF0(&byte_102574C1, 1u, (int)&unk_100E8DF0, 12, 4, 0);
  v7 = byte_102575C8 - 1;
  v16 = flt_100E8DF4[3 * v6] * a1;
  v8 = flt_102575CC[0] * a2 * a3;
  v9 = v16;
  v17 = v8 / (v15 * v16);
  v10 = v17;
  if ( flt_102575D0[0] >= (double)v17 )
    v10 = flt_102575D0[0];
  v18 = flt_102575D0[v7];
  if ( v18 <= v10 )
    v10 = v18;
  v11 = 1;
  if ( v7 > 1u )
  {
    do
    {
      if ( flt_102575D0[(unsigned __int8)v11] >= v10 )
        break;
      ++v11;
    }
    while ( (unsigned __int8)v11 < v7 );
  }
  v12 = (unsigned __int8)v11;
  v19 = flt_102575D0[v12] - flt_102575CC[v12];
  v13 = v19;
  if ( COERCE_FLOAT(LODWORD(v19) & 0x7FFFFFFF) <= 1.0e-18
    || (v20 = flt_10257648[v12] - flt_10257644[v12],
        v21 = (v10 - flt_102575CC[v12]) * v20,
        v22 = v21 / v13,
        v23 = v22 + flt_10257644[v12],
        v24 = v9 * v23,
        v25 = v24 * 100.0 / 169.3000030517578,
        *(float *)a5 = v25,
        flt_102574BC < (double)v25) )
  {
LABEL_17:
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 100E8DF4: using guessed type float flt_100E8DF4[];
// 102574B8: using guessed type float flt_102574B8;
// 102574BC: using guessed type float flt_102574BC;
// 102574C1: using guessed type char byte_102574C1;
// 102575C8: using guessed type char byte_102575C8;
// 102575CC: using guessed type float flt_102575CC[];
// 102575D0: using guessed type float flt_102575D0[];
// 10257644: using guessed type float flt_10257644[];
// 10257648: using guessed type float flt_10257648[];

//----- (100386C0) --------------------------------------------------------
void __usercall sub_100386C0(float *a1@<esi>, float a2, float a3, float a4, float a5, float a6)
{
  double v6; // st7@1
  double v7; // ST10_8@1
  double v8; // ST18_8@1
  long double v9; // st7@1
  double v10; // st7@1
  double v11; // st7@1
  double v12; // ST18_8@4
  float v13; // [sp+0h] [bp-20h]@1
  float v14; // [sp+4h] [bp-1Ch]@1
  double v15; // [sp+8h] [bp-18h]@1
  double v16; // [sp+10h] [bp-10h]@1
  float v17; // [sp+24h] [bp+4h]@1
  float v18; // [sp+24h] [bp+4h]@1
  float v19; // [sp+24h] [bp+4h]@3
  float v20; // [sp+24h] [bp+4h]@3
  float v21; // [sp+24h] [bp+4h]@4
  float v22; // [sp+28h] [bp+8h]@4
  float v23; // [sp+30h] [bp+10h]@1
  float v24; // [sp+34h] [bp+14h]@3

  v14 = a2 * 5.849999904632568 / 0.3899999856948853;
  v6 = 518.6699829101562 - a6 / 1000.0 * 3.566159963607788;
  v7 = v6;
  v8 = v6;
  v9 = pow(a3, 2.0);
  v15 = v9;
  v13 = a3 * 0.04358959943056107 + v9 * 0.00001140669974120101 - 0.07565069943666458;
  v17 = sqrt(v8 / (a5 + 459.6700134277344 - v7 + v8));
  v10 = v17 * v13;
  v16 = v10;
  v23 = v10;
  v18 = a3 * 0.0001736819976940751 + v15 * -0.0000001116950016921692 + 29.92009925842285;
  v11 = v18;
  if ( v18 >= 29.92000007629395 )
    v11 = 29.92;
  v19 = v11;
  v20 = a4 / v19;
  v24 = pow(1.0 - a6 * 0.000006875300186948152, 4.256100177764893);
  if ( v20 != 1.0 )
  {
    v12 = v20;
    v21 = pow(v20, 0.8100000023841858);
    v22 = a3 * 0.03343930095434189 + v15 * -0.000004087230081495363 + 0.02512010000646114;
    v23 = ((v24 - v21) * (v12 - (1.0 - v12) * (v22 / v13))
         + (1.0 - v24) / 0.8830000162124634 * (v21 - 0.1169999986886978))
        * v16
        / (1.0 - v21);
  }
  if ( v14 >= (double)v23 )
    *a1 = v23 / 200.0;
  else
    *a1 = v14 / 200.0;
}

//----- (10038890) --------------------------------------------------------
void __usercall sub_10038890(float *a1@<esi>, float a2, float a3, float a4, float a5, float a6)
{
  double v6; // st7@1
  double v7; // ST18_8@1
  double v8; // ST20_8@1
  long double v9; // ST08_8@1
  long double v10; // st7@1
  double v11; // st7@1
  double v12; // st7@1
  double v13; // ST20_8@4
  float v14; // [sp+0h] [bp-28h]@1
  float v15; // [sp+4h] [bp-24h]@1
  double v16; // [sp+10h] [bp-18h]@1
  double v17; // [sp+18h] [bp-10h]@1
  float v18; // [sp+2Ch] [bp+4h]@1
  float v19; // [sp+2Ch] [bp+4h]@1
  float v20; // [sp+2Ch] [bp+4h]@3
  float v21; // [sp+2Ch] [bp+4h]@3
  float v22; // [sp+2Ch] [bp+4h]@4
  float v23; // [sp+30h] [bp+8h]@4
  float v24; // [sp+38h] [bp+10h]@1
  float v25; // [sp+3Ch] [bp+14h]@3

  v15 = a2 * 5.849999904632568 / 0.3899999856948853;
  v6 = 518.6699829101562 - a6 / 1000.0 * 3.566159963607788;
  v7 = v6;
  v8 = v6;
  v9 = pow(a3, 3.0);
  v10 = pow(a3, 2.0);
  v16 = v10;
  v14 = v10 * 0.001687870011664927 + v9 * -0.0000002418020130789955 - a3 * 3.727519989013672 + 2829.919921875;
  v18 = sqrt(v8 / (a5 + 459.6700134277344 - v7 + v8));
  v11 = v18 * v14;
  v17 = v11;
  v24 = v11;
  v19 = v9 * 0.00000000144032996640675 - v16 * 0.00001011320000543492 + a3 * 0.02237300015985966 + 13.47220039367676;
  v12 = v19;
  if ( v19 >= 29.92000007629395 )
    v12 = 29.92;
  v20 = v12;
  v21 = a4 / v20;
  v25 = pow(1.0 - a6 * 0.000006875300186948152, 4.256100177764893);
  if ( v21 != 1.0 )
  {
    v13 = v21;
    v22 = pow(v21, 0.8100000023841858);
    v23 = a3 * 0.1195837631821632 + v16 * -0.00000989379987004213 - 154.6049957275391;
    v24 = ((v25 - v22) * (v13 - (1.0 - v13) * (v23 / v14))
         + (1.0 - v25) / 0.8830000162124634 * (v22 - 0.1169999986886978))
        * v17
        / (1.0 - v22);
  }
  if ( v15 >= (double)v24 )
    *a1 = v24 / 310.0;
  else
    *a1 = v15 / 310.0;
}

//----- (10038A90) --------------------------------------------------------
void __usercall sub_10038A90(float *a1@<esi>, float a2, float a3, float a4, float a5)
{
  long double v5; // ST00_8@1
  double v6; // st3@1
  double v7; // st4@4
  double v8; // st6@5
  double v9; // [sp+0h] [bp-8h]@1
  float v10; // [sp+14h] [bp+Ch]@1
  float v11; // [sp+14h] [bp+Ch]@1
  float v12; // [sp+18h] [bp+10h]@1
  float v13; // [sp+18h] [bp+10h]@1
  float v14; // [sp+18h] [bp+10h]@5
  float v15; // [sp+18h] [bp+10h]@6

  v5 = 519.0
     / (a5 + 460.0)
     * (a4
      / 29.92000007629395
      * 0.002376999938860536)
     * 32.20000076293945
     * (a3
      * 9.548610687255859);
  v12 = pow(v5, 2.0) * -0.00000004864919844749238 + 0.0002410169981885701 * v5 + 0.6883400082588196;
  v9 = v5 * v12;
  v13 = 0.1780000030994415 * v9 - 19.77400016784668;
  v10 = pow(v9, 2.0) * 0.0000000392129990700596 - 0.0001625500008231029 * v9 + 0.5654000043869019;
  v11 = 5.869999885559082 / v10 * a2;
  v6 = v13;
  if ( v13 <= 0.0 )
    v6 = (float)0.0;
  if ( v11 > 0.0 )
    v7 = v11;
  else
    v7 = (float)0.0;
  v8 = v6;
  v14 = 5.869999885559082 * a2 / v9;
  if ( v14 > 0.079999998 )
  {
    v15 = v6 * (1.0 - (v14 - 0.07999999821186066) / 0.007000000216066837 * 0.009999999776482582);
    v8 = v15;
  }
  if ( v8 <= v7 )
    *a1 = v8 / 315.0;
  else
    *a1 = v7 / 315.0;
}

//----- (10038C00) --------------------------------------------------------
void __usercall sub_10038C00(float *a1@<esi>, float a2, float a3, float a4, float a5)
{
  double v5; // ST18_8@1
  float v6; // ST14_4@1
  float v7; // ST14_4@2
  float v8; // [sp+10h] [bp-10h]@1
  float v9; // [sp+18h] [bp-8h]@1
  float v10; // [sp+24h] [bp+4h]@1

  v8 = sub_10038300(a2, a3, a4, a5);
  v5 = a2 * 5.849999904632568;
  v10 = v5 / 0.3899999856948853;
  v6 = pow(v8, -1.938099980354309);
  v9 = v5 / (v6 * 30.0 + 0.2249999940395355);
  if ( v8 > 19.0 )
  {
    v7 = pow(19.0 / v8, 1.5);
    v10 = v7 * v10;
  }
  if ( v10 >= (double)v9 )
    *a1 = v9 / 310.0;
  else
    *a1 = v10 / 310.0;
}

//----- (10038CE0) --------------------------------------------------------
void __usercall sub_10038CE0(float *a1@<esi>, float a2, float a3, float a4, float a5, float a6)
{
  double v6; // ST1C_8@1
  float v7; // ST18_4@1
  float v8; // ST18_4@2
  float v9; // [sp+14h] [bp-10h]@1
  float v10; // [sp+1Ch] [bp-8h]@1
  float v11; // [sp+28h] [bp+4h]@1

  v9 = sub_10038280(a2, a3, a4, a5, a6);
  v6 = a2 * 5.849999904632568;
  v11 = v6 / 0.3899999856948853;
  v7 = pow(v9, -1.938099980354309);
  v10 = v6 / (v7 * 30.0 + 0.2249999940395355);
  if ( v9 > 19.0 )
  {
    v8 = pow(19.0 / v9, 1.5);
    v11 = v8 * v11;
  }
  if ( v11 >= (double)v10 )
    *a1 = v10 / 310.0;
  else
    *a1 = v11 / 310.0;
}

//----- (10038DD0) --------------------------------------------------------
char __cdecl sub_10038DD0(float *a1)
{
  char result; // al@1
  float v2; // [sp+10h] [bp-10h]@8
  float v3; // [sp+14h] [bp-Ch]@7
  float v4; // [sp+18h] [bp-8h]@6
  int v5; // [sp+1Ch] [bp-4h]@9

  result = 0;
  if ( *(_BYTE *)dword_10337080 == 58 && byte_102574C8 == 1 )
  {
    if ( (unsigned __int8)sub_100625F0(0x35u)
      && (unsigned __int8)sub_100625F0(0x36u)
      && (unsigned __int8)sub_100625F0(0x25u)
      && sub_10062520(0x35u, &v4)
      && sub_10062520(0x36u, &v3)
      && sub_10062520(0x25u, &v2)
      && sub_10038360(v4, v3, v2, (int)&v5) )
    {
      *a1 = *(float *)&v5;
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}
// 102574C8: using guessed type char byte_102574C8;
// 10337080: using guessed type int dword_10337080;

//----- (10038EA0) --------------------------------------------------------
char __cdecl sub_10038EA0(float *a1)
{
  char v1; // al@1
  char v2; // al@9
  double v3; // st7@15
  double v4; // st6@15
  double v5; // st5@15
  double v6; // st4@15
  double v7; // st3@15
  double v8; // st2@15
  char result; // al@26
  bool v10; // c3@29
  double v11; // st6@29
  bool v12; // c3@30
  double v13; // st5@30
  __int16 v14; // fps@31
  bool v15; // c0@31
  char v16; // c2@31
  bool v17; // c3@31
  char v18; // ah@31
  double v19; // st6@46
  double v20; // st5@46
  double v21; // st4@46
  double v22; // st3@46
  bool v23; // c3@55
  __int16 v24; // fps@56
  bool v25; // c0@56
  char v26; // c2@56
  bool v27; // c3@56
  char v28; // [sp+1Fh] [bp-1Dh]@1
  float v29; // [sp+20h] [bp-1Ch]@2
  float v30; // [sp+24h] [bp-18h]@1
  float v31; // [sp+28h] [bp-14h]@1
  float v32; // [sp+2Ch] [bp-10h]@1
  float v33; // [sp+30h] [bp-Ch]@1
  int v34; // [sp+34h] [bp-8h]@1
  float v35; // [sp+38h] [bp-4h]@1

  v1 = *(_BYTE *)dword_10337080;
  v32 = 9.8999998e24;
  v30 = 9.8999998e24;
  v28 = v1;
  v31 = 9.8999998e24;
  v33 = 9.8999998e24;
  v35 = 9.8999998e24;
  *(float *)&v34 = 0.0;
  switch ( v1 )
  {
    case 3:
    case 0x23:
    case 0x25:
      if ( sub_10044B10(&v29) )
        v32 = v29 * 951.0193481445312;
      if ( sub_1003D430(0x18u, &v29) )
        v30 = v29 * 0.000295300007564947;
      if ( sub_1003D430(0x1Eu, &v29) )
        v31 = v29;
      if ( v28 == 35 )
        v2 = sub_1003D430(0x130u, &v29);
      else
        v2 = sub_10045BA0(&v29);
      if ( v2 )
        v33 = v29 * 1.799999952316284 + 32.0;
      if ( sub_10045980(&v29) )
        v35 = v29 * 3.280839920043945;
      v3 = 9.8999998e24;
      v4 = v32;
      v5 = v30;
      v6 = v31;
      v7 = v33;
      v8 = v35;
      if ( v32 != 9.8999998e24
        && v4 > 0.5
        && 9.8999998e24 != v5
        && v5 > 0.001
        && 9.8999998e24 != v6
        && v6 > 0.001
        && 9.8999998e24 != v7 )
      {
        if ( v33 > -459.0 && 9.8999998e24 != v35 )
        {
          if ( v28 == 3 )
          {
            sub_10038890((float *)&v34, v32, v31, v30, v33, v35);
            *a1 = *(float *)&v34;
            result = 1;
          }
          else if ( v28 == 37 )
          {
            sub_100386C0((float *)&v34, v32, v31, v30, v33, v35);
            *a1 = *(float *)&v34;
            result = 1;
          }
          else
          {
            sub_10038CE0((float *)&v34, v32, v31, v30, v33, v35);
            *a1 = *(float *)&v34;
            result = 1;
          }
          return result;
        }
        v8 = v35;
        v7 = v33;
      }
      v10 = 9.8999998e24 == v4;
      v11 = v8;
      if ( !v10 )
      {
        v12 = 9.8999998e24 == v5;
        v13 = v7;
        if ( v12 )
          goto LABEL_85;
        v15 = 9.8999998e24 < v6;
        v16 = 0;
        v17 = 9.8999998e24 == v6;
        v18 = HIBYTE(v14);
        goto LABEL_32;
      }
      result = 0;
      break;
    case 0x28:
      if ( sub_10044B10(&v29) )
        v32 = v29 * 951.0193481445312;
      if ( sub_1003D430(0x18u, &v29) )
        v30 = v29 * 0.000295300007564947;
      if ( sub_1003D430(0x1Eu, &v29) )
        v31 = v29;
      if ( sub_1003D430(0x130u, &v29) )
        v33 = v29 * 1.799999952316284 + 32.0;
      v3 = 9.8999998e24;
      v19 = v32;
      v20 = v30;
      v21 = v31;
      v22 = v33;
      if ( v32 == 9.8999998e24
        || v19 <= 0.5
        || 9.8999998e24 == v20
        || v20 <= 0.001
        || 9.8999998e24 == v21
        || v21 <= 0.001
        || 9.8999998e24 == v22
        || v22 <= -460.0 )
      {
        goto LABEL_55;
      }
      sub_10038A90((float *)&v34, v32, v31, v30, v33);
      *a1 = *(float *)&v34;
      result = 1;
      break;
    case 0x2F:
      if ( sub_10044B10(&v29) )
        v32 = v29 * 951.0193481445312;
      if ( sub_1003D430(0x18u, &v29) )
        v30 = v29 * 0.000295300007564947;
      if ( sub_1003D430(0x1Eu, &v29) )
        v31 = v29;
      if ( sub_10045980(&v29) )
        v35 = v29 * 3.280839920043945;
      v3 = 9.8999998e24;
      v19 = v32;
      v20 = v30;
      v21 = v31;
      v22 = v35;
      if ( v32 == 9.8999998e24
        || v19 <= 0.5
        || 9.8999998e24 == v20
        || v20 <= 0.001
        || 9.8999998e24 == v21
        || v21 <= 0.001
        || 9.8999998e24 == v22 )
      {
LABEL_55:
        v23 = v3 == v19;
        v11 = v22;
        if ( !v23 )
        {
          v25 = v3 < v20;
          v26 = 0;
          v27 = v3 == v20;
          v18 = HIBYTE(v24);
          v13 = v21;
LABEL_32:
          if ( !__SETP__(v18 & 0x44, 0) || v3 == v13 || v11 == v3 )
            goto LABEL_85;
          goto LABEL_35;
        }
        result = 0;
      }
      else
      {
        sub_10038C00((float *)&v34, v32, v31, v30, v35);
        *a1 = *(float *)&v34;
        result = 1;
      }
      break;
    case 0x3A:
      if ( byte_102575C4 != 1 )
        goto LABEL_85;
      if ( !(unsigned __int8)sub_100625F0(0x2Bu)
        || !(unsigned __int8)sub_100625F0(0x25u)
        || !(unsigned __int8)sub_100625F0(0x1Fu)
        || !(unsigned __int8)sub_100625F0(0x74u)
        || !sub_10062520(0x2Bu, &v32)
        || !sub_10062520(0x25u, &v31)
        || !sub_10062520(0x1Fu, &v30)
        || !sub_10062520(0x74u, &v33)
        || !sub_100384D0(v32, v31, v30, v33, (int)&v34) )
      {
        goto LABEL_83;
      }
LABEL_35:
      *a1 = *(float *)&v34;
      result = 1;
      break;
    case 0x1B:
    case 0x3B:
LABEL_83:
      result = 0;
      break;
    default:
LABEL_85:
      result = 0;
      break;
  }
  return result;
}
// 102575C4: using guessed type char byte_102575C4;
// 10337080: using guessed type int dword_10337080;

//----- (10039530) --------------------------------------------------------
bool __cdecl sub_10039530(float a1, float a2)
{
  bool v2; // bl@1
  signed int v3; // ecx@2
  float *v4; // edx@2

  v2 = sub_10041CA0();
  if ( (unsigned __int8)sub_10041820() )
  {
    sub_1007C110(101, 60000);
    v3 = 0;
    v4 = (float *)(dword_10333D6C + 620);
    while ( *(v4 - 150) <= (double)a1 && *v4 <= (double)a2 )
    {
      ++v3;
      ++v4;
      if ( v3 >= 150 )
      {
        sub_1007C0F0(101);
        return v2;
      }
    }
    v2 = 0;
    sub_1007C0F0(101);
  }
  return v2;
}
// 10333D6C: using guessed type int dword_10333D6C;

//----- (100395C0) --------------------------------------------------------
bool __cdecl sub_100395C0(unsigned __int8 a1, int a2)
{
  bool v2; // bl@1
  int v3; // eax@2
  float v4; // ST24_4@5
  float v5; // ST24_4@6
  unsigned int v6; // ebp@7

  v2 = 0;
  if ( (unsigned __int8)sub_10041820() )
  {
    sub_1007C110(101, 60000);
    v3 = sub_10043FF0((_DWORD *)(dword_10333D6C + 1220), 1u, (int)&unk_100E9598, 8, 7, -1);
    if ( v3 >= 0 )
    {
      if ( *(_BYTE *)(dword_10333D6C + 1454) == 1 )
      {
        if ( *(_BYTE *)a2 != byte_100E959A[8 * v3]
          || (v4 = *(float *)(dword_10333D6C + 1224) - *(float *)(a2 + 4), COERCE_FLOAT(LODWORD(v4) & 0x7FFFFFFF) > 0.5)
          || (v5 = *(float *)(dword_10333D6C + 1228) - *(float *)(a2 + 8), COERCE_FLOAT(LODWORD(v5) & 0x7FFFFFFF) > 0.5) )
        {
          v2 = 0;
          v6 = 1000;
        }
        else
        {
          v2 = 1;
          v6 = 1000;
        }
      }
      else
      {
        v6 = 1500;
        v2 = *(_WORD *)a2 == (unsigned __int8)byte_100E9599[8 * v3];
      }
      if ( a1 < 2u && *(_BYTE *)(a1 + dword_10333D6C) )
      {
        if ( !v2 && sub_1007C040() - *(_DWORD *)(dword_10333D6C + 4 * a1 + 4) >= v6 )
        {
          sub_1007C0F0(101);
          return 0;
        }
        v2 = 1;
      }
    }
    sub_1007C0F0(101);
  }
  return v2;
}
// 10333D6C: using guessed type int dword_10333D6C;

//----- (100396E0) --------------------------------------------------------
char __cdecl sub_100396E0(__int16 a1)
{
  void *v1; // ecx@0
  size_t v2; // esi@1
  int v3; // eax@4
  __int16 *v5; // [sp+4h] [bp-BCh]@4
  size_t v6; // [sp+8h] [bp-B8h]@4
  int v7; // [sp+Ch] [bp-B4h]@4
  int v8; // [sp+10h] [bp-B0h]@4
  int v9; // [sp+14h] [bp-ACh]@4
  __int16 v10; // [sp+18h] [bp-A8h]@1
  __int16 v11; // [sp+1Ch] [bp-A4h]@1
  char v12; // [sp+20h] [bp-A0h]@3

  v10 = a1;
  v11 = a1;
  v2 = 0;
  switch ( a1 )
  {
    case 0x8001:
      v2 = 156;
      goto LABEL_3;
    case 0x8002:
      v2 = 32;
      goto LABEL_3;
    case 0x8003:
      v2 = 56;
      goto LABEL_3;
    case 0x8004:
      v2 = 1;
      goto LABEL_3;
    case 0x8006:
      v2 = 16;
      goto LABEL_3;
    case 0x8009:
      v2 = 40;
      goto LABEL_3;
    case 0x800A:
      v2 = 60;
      goto LABEL_3;
    case 0x800B:
      v2 = 2;
LABEL_3:
      memcpy_0(&v12, v1, v2);
      break;
    default:
      sub_10042930("..\\lib\\adl\\pvt_io_prj.c", 2075, 0, 0);
      break;
  }
  v9 = 1;
  v5 = &v10;
  v6 = v2 + 8;
  v7 = 0;
  v8 = 200;
  v3 = sub_1007C1A0(44, (int)&v5);
  if ( v3 )
    LOBYTE(v3) = sub_10042930("..\\lib\\adl\\pvt_io_prj.c", 2102, 0, 0);
  return v3;
}

//----- (10039840) --------------------------------------------------------
char __cdecl sub_10039840()
{
  return sub_100396E0(-32767);
}

//----- (10039850) --------------------------------------------------------
char __cdecl sub_10039850(int *a1)
{
  int v1; // ST08_4@1

  v1 = *a1;
  return sub_100396E0(-32765);
}

//----- (10039890) --------------------------------------------------------
char sub_10039890()
{
  return sub_100396E0(-32764);
}

//----- (100398B0) --------------------------------------------------------
char __cdecl sub_100398B0(char a1)
{
  char result; // al@1

  result = a1;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10043480(word_100EA488[(unsigned __int8)a1]);
  return result;
}
// 100EA488: using guessed type __int16 word_100EA488[];

//----- (100398D0) --------------------------------------------------------
void __usercall sub_100398D0(unsigned __int8 a1@<bl>, char a2, char a3, char a4)
{
  int v4; // esi@3
  int v5; // esi@6

  if ( a1 < 2u )
  {
    if ( !sub_1003CA50(a1) || (v4 = 5 * a1, sub_100432C0(word_100EA490[5 * a1])) )
    {
      v5 = 5 * a1;
      sub_10043370(word_100EA48E[5 * a1]);
      if ( a2 )
      {
        if ( a3 )
          sub_10043480(word_100EA48C[v5]);
        else
          sub_10043370(word_100EA48C[v5]);
        if ( a4 )
          sub_10043480(word_100EA494[v5]);
        else
          sub_10043370(word_100EA494[v5]);
      }
      else
      {
        sub_10043370(word_100EA48C[v5]);
        sub_10043370(word_100EA494[v5]);
      }
    }
    else if ( !sub_100432C0(word_100EA492[v4]) )
    {
      sub_10043370(word_100EA48C[v4]);
      sub_10043370(word_100EA494[v4]);
      sub_10043480(word_100EA48E[v4]);
    }
  }
}
// 100EA48C: using guessed type __int16 word_100EA48C[];
// 100EA48E: using guessed type __int16 word_100EA48E[];
// 100EA490: using guessed type __int16 word_100EA490[];
// 100EA492: using guessed type __int16 word_100EA492[];
// 100EA494: using guessed type __int16 word_100EA494[];

//----- (100399E0) --------------------------------------------------------
void __cdecl sub_100399E0(unsigned __int8 a1)
{
  unsigned __int8 v1; // bl@1
  __int16 v2; // ax@1
  char v3; // al@3
  char v4; // [sp+4h] [bp-14h]@7
  int v5; // [sp+8h] [bp-10h]@1
  int v6; // [sp+Ch] [bp-Ch]@1
  int v7; // [sp+10h] [bp-8h]@1
  int v8; // [sp+14h] [bp-4h]@1
  char v9; // [sp+1Ch] [bp+4h]@10

  v1 = a1;
  v2 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  if ( a1 )
  {
    if ( a1 != 1 )
      goto LABEL_9;
    v3 = sub_100253C0(1, 1221, &v5);
  }
  else
  {
    v3 = sub_100253C0(1, 1209, &v5);
  }
  if ( v3 && !sub_1004DC00((unsigned __int8 *)&v5) )
  {
    v2 = v6;
    v4 = 1;
    goto LABEL_10;
  }
  v2 = v6;
LABEL_9:
  v4 = 0;
LABEL_10:
  v9 = 0;
  if ( v2 & 0x7E )
    v9 = 1;
  sub_100398D0(v1, v4, v9, HIBYTE(v2) & 1);
}

//----- (10039A80) --------------------------------------------------------
int __cdecl sub_10039A80(signed int a1)
{
  int v1; // esi@1
  int v2; // eax@1
  int v4; // [sp+4h] [bp-8h]@1
  int v5; // [sp+8h] [bp-4h]@1

  v1 = (unsigned __int16)sub_100439D0(a1);
  v4 = 0;
  sub_1007C650(3173, &v5, 2, &v4);
  LOWORD(v2) = sub_1002B9D0();
  return v1 & ~v5 & v2;
}

//----- (10039AD0) --------------------------------------------------------
bool __cdecl sub_10039AD0(char a1, char a2, int a3, float a4)
{
  if ( a2 == 6 )
  {
    if ( (unsigned __int8)a1 >= 5u && 0.0 != a4 )
      return 1;
    return 0;
  }
  if ( a1 != 4 && a1 != 5 && a1 != 2 && a1 != 7 )
    return 0;
  return 0.0 != a4;
}

//----- (10039B30) --------------------------------------------------------
bool sub_10039B30()
{
  return sub_1007C0F0(47) == 0;
}

//----- (10039B40) --------------------------------------------------------
bool sub_10039B40()
{
  return sub_1007C110(47, 5000) == 0;
}

//----- (10039B70) --------------------------------------------------------
char __cdecl sub_10039B70(void *a1)
{
  void *v1; // ecx@1
  int v3; // [sp+4h] [bp-8h]@1
  int v4; // [sp+8h] [bp-4h]@1

  sub_10061E50();
  sub_1004A2F0(&unk_1025774C);
  sub_1004A5B0((int)&unk_10257758);
  sub_10039E00(0, 8524, &unk_1025AA58);
  *((_BYTE *)a1 + 7327) = -1;
  memcpy(&unk_1025776C, a1, 0x32ECu);
  dword_10257750 = sub_100429D0(v1);
  dword_10257754 = sub_1007C040();
  byte_10257748 = 1;
  sub_1007C500(9030, (int)&byte_10257748, 21596);
  sub_10061E40();
  v4 = 0;
  sub_1007C650(2016, &v3, 4, &v4);
  if ( !(*((_BYTE *)a1 + 3) & 8) && v3 & 1 )
  {
    v3 &= 0xFFFFFFFE;
    sub_1007C500(2016, (int)&v3, 4);
  }
  return sub_10061E70(-32760, 0);
}
// 10257748: using guessed type char byte_10257748;
// 10257750: using guessed type int dword_10257750;
// 10257754: using guessed type int dword_10257754;

//----- (10039C50) --------------------------------------------------------
int __cdecl sub_10039C50(unsigned __int8 a1)
{
  int v1; // eax@3
  bool v2; // zf@3
  int result; // eax@3

  if ( a1 >= 0x67u
    || !(unsigned __int8)sub_1002DC80()
    || (v1 = 8524 * a1, v2 = a1 == *(_BYTE *)(v1 + dword_103334E4 + 2004), result = v1 + dword_103334E4 + 2004, !v2) )
  {
    result = 0;
  }
  return result;
}
// 103334E4: using guessed type int dword_103334E4;

//----- (10039C90) --------------------------------------------------------
signed int __cdecl sub_10039C90(__int16 a1, char a2, char a3, const void *a4, int a5, int a6)
{
  int v6; // eax@5
  signed int result; // eax@11
  int v8; // [sp+8h] [bp-A4h]@1
  int v9; // [sp+Ch] [bp-A0h]@1
  int v10; // [sp+10h] [bp-9Ch]@1
  __int16 *v11; // [sp+14h] [bp-98h]@1
  int v12; // [sp+18h] [bp-94h]@1
  int *v13; // [sp+1Ch] [bp-90h]@1
  int v14; // [sp+20h] [bp-8Ch]@1
  int v15; // [sp+24h] [bp-88h]@1
  __int16 v16; // [sp+28h] [bp-84h]@1
  char v17; // [sp+2Ch] [bp-80h]@1
  char v18; // [sp+2Dh] [bp-7Fh]@1
  char v19; // [sp+30h] [bp-7Ch]@2

  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v16 = a1;
  v17 = a2;
  v18 = a3;
  if ( a4 )
    qmemcpy(&v19, a4, 0x40u);
  v15 = 4;
  v11 = &v16;
  v12 = 128;
  v13 = &v8;
  v14 = 400;
  v8 = a5;
  v9 = a6;
  if ( sub_10045F70(15000) )
  {
    v14 = 10000;
  }
  else
  {
    v6 = 0;
    while ( a1 != word_100EBB48[4 * v6] )
    {
      if ( (unsigned int)++v6 >= 3 )
        goto LABEL_10;
    }
    v14 = dword_100EBB4C[2 * v6];
  }
LABEL_10:
  if ( sub_1007C1A0(21, (int)&v11) )
  {
    sub_10042930("..\\lib\\adl\\udb_intf_rte_mem.c", 424, 0, 0);
    result = v10;
    if ( v10 )
      return result;
    goto LABEL_12;
  }
  result = v10;
  if ( !v10 && v9 != a6 )
LABEL_12:
    result = 11;
  return result;
}
// 100EBB48: using guessed type __int16 word_100EBB48[];
// 100EBB4C: using guessed type int dword_100EBB4C[];

//----- (10039E00) --------------------------------------------------------
int __cdecl sub_10039E00(int a1, int a2, void *a3)
{
  const void *v3; // eax@1
  int result; // eax@2

  sub_1007C110(54, 60000);
  v3 = (const void *)sub_10039C50(a1);
  if ( v3 )
  {
    memcpy(a3, v3, 0x214Cu);
    result = sub_1007C0F0(54);
  }
  else
  {
    memset(a3, 0, 0x214Cu);
    *(_BYTE *)a3 = -1;
    result = sub_1007C0F0(54);
  }
  return result;
}

//----- (10039E60) --------------------------------------------------------
char *__cdecl sub_10039E60(unsigned __int8 a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *result; // eax@1
  signed int v4; // ebp@1
  int v5; // esi@1
  int v6; // edi@1
  int v7; // esi@2
  char v8; // cl@4
  int v9; // ecx@8
  int v10; // [sp+10h] [bp-28h]@2
  int v11; // [sp+14h] [bp-24h]@1
  char v12[28]; // [sp+18h] [bp-20h]@2

  v2 = dword_10333500[3 * a1];
  result = (char *)(12 * a1);
  v4 = *(_DWORD *)&result[(_DWORD)dword_10333508];
  v5 = v1;
  v6 = *(_WORD *)&result[(_DWORD)word_10333504];
  v11 = v1;
  if ( v4 > 0 )
  {
    v7 = v1 - (_DWORD)v12;
    v10 = *(_DWORD *)&result[(_DWORD)dword_10333508];
    do
    {
      (*(void (__cdecl **)(int, int, char *))dword_103334D8)(v2, v6, v12);
      v12[v6] = 0;
      result = v12;
      do
      {
        v8 = *result;
        result[v7] = *result;
        ++result;
      }
      while ( v8 );
      v2 += v6;
      v7 += 25;
      --v10;
    }
    while ( v10 );
    v5 = v11;
  }
  if ( v4 < 64 )
  {
    result = (char *)(v5 + 25 * v4);
    v9 = 64 - v4;
    do
    {
      *result = 0;
      result += 25;
      --v9;
    }
    while ( v9 );
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333500: using guessed type int dword_10333500[];
// 10333504: using guessed type __int16 word_10333504[];
// 10333508: using guessed type int dword_10333508[];
// 10039E60: using guessed type char var_20[28];

//----- (10039F20) --------------------------------------------------------
signed int sub_10039F20()
{
  signed int result; // eax@1

  result = 0xFFFFFF;
  byte_103334DC = 0;
  dword_103334E0 = 0xFFFFFF;
  byte_103334CC = 0;
  dword_103334D0 = 0xFFFFFF;
  return result;
}
// 103334CC: using guessed type char byte_103334CC;
// 103334D0: using guessed type int dword_103334D0;
// 103334DC: using guessed type char byte_103334DC;
// 103334E0: using guessed type int dword_103334E0;

//----- (10039F40) --------------------------------------------------------
int sub_10039F40()
{
  int result; // eax@1

  result = (*(int (**)(void))(dword_103334D8 + 16))();
  byte_103334D4 = (_BYTE)result == 0;
  return result;
}
// 103334D4: using guessed type char byte_103334D4;
// 103334D8: using guessed type int dword_103334D8;

//----- (10039FA0) --------------------------------------------------------
int sub_10039FA0()
{
  int result; // eax@1

  *(_DWORD *)(dword_10333D50 + 20812) = 1000;
  *(_DWORD *)(dword_10333D50 + 20816) = dword_10333568 + *(_DWORD *)(dword_10333D50 + 20812);
  *(_DWORD *)(dword_10333D50 + 20820) = dword_103335C8 + *(_DWORD *)(dword_10333D50 + 20816);
  *(_DWORD *)(dword_10333D50 + 20824) = dword_103335F8 + *(_DWORD *)(dword_10333D50 + 20820);
  result = dword_10333D50;
  *(_DWORD *)(dword_10333D50 + 20828) = dword_10333640 + *(_DWORD *)(dword_10333D50 + 20824);
  return result;
}
// 10333568: using guessed type int dword_10333568;
// 103335C8: using guessed type int dword_103335C8;
// 103335F8: using guessed type int dword_103335F8;
// 10333640: using guessed type int dword_10333640;
// 10333D50: using guessed type int dword_10333D50;

//----- (1003A010) --------------------------------------------------------
char *sub_1003A010()
{
  sub_10039E60(0x40u);
  sub_10039E60(0x39u);
  sub_10039E60(0x33u);
  sub_10039E60(0x31u);
  sub_10039E60(0x32u);
  sub_10039E60(0x4Eu);
  sub_10039E60(0x4Fu);
  sub_10039E60(0x3Du);
  sub_10039E60(0x3Eu);
  sub_10039E60(0x45u);
  return sub_10039E60(0x38u);
}
// 10333D50: using guessed type int dword_10333D50;

//----- (1003A0E0) --------------------------------------------------------
int __cdecl sub_1003A0E0(const void *a1)
{
  int result; // eax@1

  qmemcpy(dword_1025CBA8, a1, 0x1Cu);
  dword_103334D8 = (int)dword_1025CBA8;
  dword_10333D50 = (int)&unk_1025CBC8;
  memset(&unk_1025CBC8, 0, 0x516Cu);
  dword_1025CBA8[5](dword_10333D50 + 20832, dword_10333D50 + 20833, dword_10333D50 + 20836);
  (*(void (__cdecl **)(int))(dword_103334D8 + 24))(dword_10333D50 + 20840);
  sub_1004A860();
  sub_1004A400();
  sub_1004A6A0();
  sub_1004A4D0();
  sub_1003A010();
  sub_10039F20();
  sub_1003BB70();
  sub_1003B2D0();
  sub_10039F40();
  sub_10039FA0();
  *(_DWORD *)(dword_10333D50 + 20800) = 0;
  *(_DWORD *)(dword_10333D50 + 20804) = dword_103336E8;
  result = dword_10333D50;
  *(_DWORD *)(dword_10333D50 + 20808) = dword_103336F4 + *(_DWORD *)(dword_10333D50 + 20804);
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 103336E8: using guessed type int dword_103336E8;
// 103336F4: using guessed type int dword_103336F4;
// 10333D50: using guessed type int dword_10333D50;

//----- (1003A190) --------------------------------------------------------
int __cdecl sub_1003A190(int a1)
{
  int result; // eax@1
  char v2; // al@2
  signed int v3; // ebp@2
  signed int v4; // edi@2
  unsigned __int8 v5; // cl@4
  char v6; // cl@16
  signed int v7; // edi@18
  char v8; // al@19
  char v9; // cl@27
  char v10; // dl@27
  char v11; // al@27
  char v12; // dl@28
  char v13; // cl@28
  char v14; // al@29
  char v15; // cl@29
  char v16; // dl@29
  __int32 v17; // esi@33
  int v18; // esi@33
  char v19; // [sp+8h] [bp-10h]@20
  char v20; // [sp+9h] [bp-Fh]@27
  char v21; // [sp+Ah] [bp-Eh]@28
  char v22; // [sp+Bh] [bp-Dh]@24
  char v23; // [sp+Ch] [bp-Ch]@20
  char v24; // [sp+Dh] [bp-Bh]@28
  char v25; // [sp+Eh] [bp-Ah]@29
  char v26; // [sp+Fh] [bp-9h]@28
  char v27; // [sp+10h] [bp-8h]@28

  result = 0x3FFFF;
  if ( *(_BYTE *)(dword_10333D50 + 20840) )
  {
    v2 = 1;
    v3 = 5;
    v4 = 0;
    while ( v2 )
    {
      v5 = *(_BYTE *)(a1 + v4);
      switch ( *(_BYTE *)(a1 + v4) )
      {
        case 0x45:
        case 0x4E:
        case 0x53:
        case 0x57:
          if ( v4 == 3 || v3 != 5 )
            goto LABEL_11;
          v3 = v4;
          break;
        default:
          if ( v5 < 0x30u || v5 > 0x39u )
LABEL_11:
            v2 = 0;
          else
            v2 = 1;
          break;
      }
      if ( ++v4 >= 5 )
      {
        if ( !v2 || v3 == 5 || *(_BYTE *)(a1 + v4) )
          break;
        v6 = *(_BYTE *)(a1 + v3);
        if ( v6 == 69 )
        {
          v8 = 43;
          v7 = 1;
LABEL_23:
          v23 = v8;
          v19 = v8;
        }
        else if ( v6 == 78 )
        {
          v19 = 43;
          v23 = 45;
          v7 = 1;
        }
        else
        {
          v7 = -1;
          if ( v6 != 83 )
          {
            v8 = 45;
            goto LABEL_23;
          }
          v19 = 45;
          v23 = 43;
        }
        v22 = 0;
        if ( v3 )
        {
          if ( v3 == 1 )
          {
            v14 = *(_BYTE *)(a1 + 2);
            v15 = *(_BYTE *)(a1 + 3);
            v20 = *(_BYTE *)a1;
            v16 = *(_BYTE *)(a1 + 4);
            v21 = v14;
            v24 = 49;
            v25 = v15;
            v26 = v16;
            v27 = 0;
          }
          else
          {
            v7 = 0;
            if ( v3 != 2 )
            {
              v9 = *(_BYTE *)(a1 + 1);
              v10 = *(_BYTE *)(a1 + 2);
              v20 = *(_BYTE *)a1;
              v11 = *(_BYTE *)(a1 + 3);
              goto LABEL_31;
            }
            v12 = *(_BYTE *)(a1 + 1);
            v11 = *(_BYTE *)(a1 + 3);
            v20 = *(_BYTE *)a1;
            v13 = *(_BYTE *)(a1 + 4);
            v21 = v12;
            v24 = 49;
            v26 = v13;
            v27 = 0;
LABEL_32:
            v25 = v11;
          }
          v17 = (v7 + 2 * j_j__atol(&v19) + 180) & 0x1FF | 0x3FE00;
          v18 = (v17 ^ ((unsigned __int16)(j_j__atol(&v23) + 180) << 9)) & 0x3FE00 ^ v17;
          if ( (v18 & 0x1FFu) <= 0x168 && (v18 & 0x3FE00u) <= 0x2D000 )
            return v18 & 0x3FFFFFF | 0x30000000;
          break;
        }
        v9 = *(_BYTE *)(a1 + 2);
        v10 = *(_BYTE *)(a1 + 3);
        v20 = *(_BYTE *)(a1 + 1);
        v11 = *(_BYTE *)(a1 + 4);
LABEL_31:
        v26 = 0;
        v24 = v10;
        v21 = v9;
        goto LABEL_32;
      }
    }
    result = 0x3FFFF;
  }
  return result;
}
// 10333D50: using guessed type int dword_10333D50;

//----- (1003A3C0) --------------------------------------------------------
void __cdecl sub_1003A3C0(unsigned int a1, int a2)
{
  unsigned int v2; // ebx@3
  unsigned int v3; // ebp@4
  unsigned int v4; // eax@5
  int v5; // ecx@5
  int v6; // eax@6
  char v7; // dl@10
  char v8; // cl@10
  char v9; // al@10
  char v10; // cl@11
  char v11; // dl@11
  char v12; // dl@13
  char v13; // cl@13
  char v14; // al@13
  char v15; // cl@14
  char v16; // dl@14
  char v17; // cl@14
  char v18; // [sp+4h] [bp-10h]@5
  char v19; // [sp+5h] [bp-Fh]@10
  char v20; // [sp+6h] [bp-Eh]@10
  char v21; // [sp+8h] [bp-Ch]@5
  char v22; // [sp+Ah] [bp-Ah]@10
  char v23; // [sp+Bh] [bp-9h]@10

  if ( a2 )
  {
    if ( (a1 & 0xFC000000) != 805306368 || (v2 = a1 & 0x1FF, v2 > 0x168) || (v3 = (a1 >> 9) & 0x1FF, v3 > 0x168) )
    {
      *(_DWORD *)a2 = 1600085855;
      *(_WORD *)(a2 + 4) = 24415;
      *(_BYTE *)(a2 + 6) = 0;
    }
    else
    {
      sub_10042370(&v18, 4u, "%+03d", (signed int)(v2 - 180) / 2);
      sub_10042370(&v21, 5u, "%+04d", v3 - 180);
      v4 = (v3 - 180) >> 31;
      v5 = (v3 - 180 - v4) ^ ((signed int)(v3 - 180 - v4) >> 31);
      if ( v2 < 0xB4 )
      {
        LOBYTE(v4) = v3 < 0xB4;
        v6 = 4 * v4 + 83;
      }
      else
      {
        LOBYTE(v6) = v3 < 0xB4 ? 78 : 69;
      }
      *(_BYTE *)(a2 + 5) = 0;
      if ( a1 & 1 )
      {
        if ( v5 >= 100 )
        {
          v10 = v22;
          *(_BYTE *)a2 = v19;
          v11 = v23;
          *(_BYTE *)(a2 + 1) = v6;
          *(_BYTE *)(a2 + 2) = v20;
          *(_BYTE *)(a2 + 3) = v10;
          *(_BYTE *)(a2 + 4) = v11;
        }
        else
        {
          v7 = v20;
          *(_BYTE *)(a2 + 1) = v19;
          v8 = v23;
          *(_BYTE *)a2 = v6;
          v9 = v22;
          *(_BYTE *)(a2 + 2) = v7;
          *(_BYTE *)(a2 + 3) = v9;
          *(_BYTE *)(a2 + 4) = v8;
        }
      }
      else if ( v5 < 100 )
      {
        v15 = v20;
        *(_BYTE *)a2 = v19;
        v16 = v22;
        *(_BYTE *)(a2 + 1) = v15;
        v17 = v23;
        *(_BYTE *)(a2 + 2) = v16;
        *(_BYTE *)(a2 + 3) = v17;
        *(_BYTE *)(a2 + 4) = v6;
      }
      else
      {
        v12 = v20;
        *(_BYTE *)a2 = v19;
        v13 = v23;
        *(_BYTE *)(a2 + 2) = v6;
        v14 = v22;
        *(_BYTE *)(a2 + 1) = v12;
        *(_BYTE *)(a2 + 3) = v14;
        *(_BYTE *)(a2 + 4) = v13;
      }
    }
  }
}
// 100EBB80: using guessed type int dword_100EBB80;

//----- (1003A5A0) --------------------------------------------------------
char __cdecl sub_1003A5A0(unsigned int a1, int a2)
{
  char result; // al@1
  unsigned int v3; // edx@3
  unsigned int v4; // ecx@4

  result = 0;
  if ( a2 )
  {
    if ( (a1 & 0xFC000000) == 805306368 )
    {
      v3 = a1 & 0x1FF;
      if ( v3 <= 0x168 )
      {
        v4 = (a1 >> 9) & 0x1FF;
        if ( v4 <= 0x168 )
        {
          *(_DWORD *)a2 = (signed int)(11930464 * (v3 - 180)) / 2;
          *(_DWORD *)(a2 + 4) = 11930464 * (v4 - 180);
          result = 1;
        }
      }
    }
  }
  return result;
}

//----- (1003A610) --------------------------------------------------------
int __cdecl sub_1003A610(_BYTE *a1, _BYTE *a2, int a3)
{
  _BYTE *v3; // edx@1
  _BYTE *v4; // ecx@1
  int v5; // esi@1
  int result; // eax@1

  v3 = a2;
  v4 = a1;
  v5 = a3;
  result = 0;
  do
  {
    if ( v5 <= 0 )
      break;
    result = *v4-- - *v3--;
    --v5;
  }
  while ( !result );
  return result;
}

//----- (1003A640) --------------------------------------------------------
int __cdecl sub_1003A640(int a1, int a2)
{
  unsigned int v2; // edx@1
  int v3; // ebx@1
  int v4; // ecx@1
  signed int v5; // esi@1
  unsigned int v6; // eax@2
  unsigned int v7; // eax@12
  unsigned int v8; // eax@15
  int v9; // ecx@15
  unsigned int v10; // eax@25
  unsigned int v11; // eax@28
  int v12; // ecx@28
  unsigned int v13; // eax@38
  int result; // eax@47

  v2 = 0;
  v3 = 0;
  v4 = 34;
  v5 = 0;
  while ( 1 )
  {
    v6 = *(_BYTE *)(v5 + a1);
    if ( v6 - 65 > 0x19 )
    {
      if ( v6 - 48 > 9 )
      {
        if ( v6 == 32 )
        {
          v6 = 0;
        }
        else if ( !*(_BYTE *)(v5 + a1) )
        {
          goto LABEL_45;
        }
      }
      else
      {
        v6 -= 16;
      }
    }
    else
    {
      v6 -= 64;
    }
    if ( v4 == 34 )
    {
      v3 |= 4 * v6;
    }
    else
    {
      if ( v4 == 28 )
      {
        v3 |= v6 >> 4;
        v7 = v6 << 28;
      }
      else
      {
        v7 = v6 << v4;
      }
      v2 |= v7;
    }
    v8 = *(_BYTE *)(v5 + a1 + 1);
    v9 = v4 - 6;
    if ( v8 - 65 > 0x19 )
    {
      if ( v8 - 48 > 9 )
      {
        if ( v8 == 32 )
        {
          v8 = 0;
        }
        else if ( !*(_BYTE *)(v5 + a1 + 1) )
        {
          ++v5;
          goto LABEL_45;
        }
      }
      else
      {
        v8 -= 16;
      }
    }
    else
    {
      v8 -= 64;
    }
    if ( v9 == 34 )
    {
      v3 |= 4 * v8;
    }
    else
    {
      if ( v9 == 28 )
      {
        v3 |= v8 >> 4;
        v10 = v8 << 28;
      }
      else
      {
        v10 = v8 << v9;
      }
      v2 |= v10;
    }
    v11 = *(_BYTE *)(v5 + a1 + 2);
    v12 = v9 - 6;
    if ( v11 - 65 > 0x19 )
      break;
    v11 -= 64;
LABEL_35:
    if ( v12 == 34 )
    {
      v3 |= 4 * v11;
    }
    else
    {
      if ( v12 == 28 )
      {
        v3 |= v11 >> 4;
        v13 = v11 << 28;
      }
      else
      {
        v13 = v11 << v12;
      }
      v2 |= v13;
    }
    v5 += 3;
    v4 = v12 - 6;
    if ( v5 >= 6 )
      goto LABEL_45;
  }
  if ( v11 - 48 <= 9 )
  {
    v11 -= 16;
    goto LABEL_35;
  }
  if ( v11 == 32 )
  {
    v11 = 0;
    goto LABEL_35;
  }
  if ( *(_BYTE *)(v5 + a1 + 2) )
    goto LABEL_35;
  v5 += 2;
LABEL_45:
  if ( *(_BYTE *)(v5 + a1) )
  {
    v2 = -136348176;
    LOBYTE(v3) = 125;
  }
  result = a2;
  *(_BYTE *)(a2 + 1) = BYTE1(v2);
  *(_BYTE *)a2 = v2;
  *(_BYTE *)(a2 + 4) = v3;
  *(_BYTE *)(a2 + 2) = v2 >> 16;
  *(_BYTE *)(a2 + 3) = BYTE3(v2);
  return result;
}

//----- (1003A7A0) --------------------------------------------------------
void __cdecl sub_1003A7A0(_BYTE *a1, signed int a2, int a3)
{
  signed int v3; // esi@1
  _BYTE *v4; // ecx@2
  unsigned int v5; // edx@2
  unsigned int v6; // eax@6
  unsigned __int16 v7; // ax@7
  char v8; // al@10

  v3 = 0;
  if ( a2 > 0 )
  {
    v4 = a1;
    v5 = a2;
    do
    {
      if ( v3 & 3 )
      {
        if ( (v3 & 3) == 1 )
        {
          v6 = v5 >> 4;
        }
        else
        {
          --v4;
          if ( (v3 & 3) == 2 )
          {
            HIBYTE(v7) = v4[1];
            LOBYTE(v7) = *v4;
            v5 = v7;
            v6 = (unsigned int)v7 >> 6;
          }
          else
          {
            LOBYTE(v6) = v5;
          }
        }
      }
      else
      {
        BYTE1(v5) = *v4--;
        LOBYTE(v5) = *v4;
        v5 = (unsigned __int16)v5;
        LOWORD(v6) = (unsigned __int16)v5 >> 10;
      }
      v8 = v6 & 0x3F;
      if ( v8 )
      {
        if ( (unsigned __int8)(v8 - 1) > 0x19u )
        {
          if ( (unsigned __int8)(v8 - 32) <= 9u )
            v8 += 16;
        }
        else
        {
          v8 += 64;
        }
        *(_BYTE *)(v3 + a3) = v8;
      }
      else
      {
        *(_BYTE *)(v3 + a3) = 32;
      }
      ++v3;
    }
    while ( v3 < a2 );
  }
}

//----- (1003A840) --------------------------------------------------------
unsigned int __cdecl sub_1003A840(unsigned int a1, _BYTE *a2, _BYTE *a3)
{
  unsigned int result; // eax@1

  *a2 = a1;
  result = a1 >> 8;
  *a3 = BYTE1(a1);
  return result;
}

//----- (1003A860) --------------------------------------------------------
signed int __cdecl sub_1003A860(int a1, _WORD *a2, _BYTE *a3)
{
  signed int result; // eax@1
  int v4; // ecx@2
  int v5; // edi@3
  int i; // ebx@3
  int v7; // esi@4

  result = sub_1002DC80();
  if ( (_BYTE)result && (v4 = dword_103334E4, result = *(_WORD *)(dword_103334E4 + 2), (signed __int16)result > 0) )
  {
    v5 = (signed __int16)result - 1;
    for ( i = 0; v5 > i; v4 = dword_103334E4 )
    {
      v7 = (v5 + i) / 2;
      if ( sub_1003A610((_BYTE *)(a1 + 4), (_BYTE *)(v4 + 56 * (*(_WORD *)(v4 + 2 * v7 + 4) + 15721) + 4), 5) <= 0 )
        v5 = (v5 + i) / 2;
      else
        i = v7 + 1;
    }
    result = sub_1003A610((_BYTE *)(a1 + 4), (_BYTE *)(v4 + 56 * (*(_WORD *)(v4 + 2 * v5 + 4) + 15721) + 4), 5);
    if ( result <= 0 )
    {
      if ( result >= 0 )
      {
        result = (signed int)a3;
        *a2 = v5;
        *a3 = 1;
      }
      else
      {
        result = (signed int)a2;
        *a2 = v5;
        *a3 = 0;
      }
    }
    else
    {
      *a2 = v5 + 1;
      *a3 = 0;
    }
  }
  else
  {
    *a2 = 0;
    *a3 = 0;
  }
  return result;
}
// 103334E4: using guessed type int dword_103334E4;

//----- (1003A960) --------------------------------------------------------
char __usercall sub_1003A960@<al>(unsigned __int16 a1@<ax>, void *a2)
{
  unsigned __int16 v2; // si@1
  char result; // al@4

  v2 = a1;
  if ( (unsigned __int8)sub_1002DC80() && v2 < 0x3E8u && *(_WORD *)(dword_103334E4 + 56 * v2 + 880428) == v2 )
  {
    qmemcpy(a2, (const void *)(dword_103334E4 + 56 * (v2 + 15721)), 0x38u);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 103334E4: using guessed type int dword_103334E4;

//----- (1003A9C0) --------------------------------------------------------
int __usercall sub_1003A9C0@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(double *)result = (double)*(signed int *)a2 * 0.000000001462918079267163;
  *(double *)(result + 8) = 0.000000001462918079267163 * (double)*(signed int *)(a2 + 4);
  return result;
}

//----- (1003A9E0) --------------------------------------------------------
int __cdecl sub_1003A9E0(unsigned __int16 a1, int a2)
{
  char v3; // [sp+4h] [bp-3Ch]@1
  char v4; // [sp+8h] [bp-38h]@3

  sub_1007C110(58, 60000);
  if ( sub_1003A960(a1, &v3) )
  {
    sub_1003A7A0(&v4, 6, a2);
    sub_100423E0(a2, 6);
  }
  else
  {
    *(_DWORD *)a2 = 1600085855;
    *(_WORD *)(a2 + 4) = 24415;
    *(_BYTE *)(a2 + 6) = 0;
  }
  return sub_1007C0F0(58);
}

//----- (1003AA70) --------------------------------------------------------
int __cdecl sub_1003AA70(unsigned __int16 a1, int a2)
{
  char v3; // [sp+4h] [bp-3Ch]@1
  char v4; // [sp+Ch] [bp-34h]@3

  sub_1007C110(58, 60000);
  if ( sub_1003A960(a1, &v3) )
  {
    sub_1003A9C0(a2, (int)&v4);
  }
  else
  {
    *(double *)a2 = 6.2831853071796;
    *(double *)(a2 + 8) = 6.2831853071796;
  }
  return sub_1007C0F0(58);
}

//----- (1003AAE0) --------------------------------------------------------
signed int __cdecl sub_1003AAE0(int a1, _WORD *a2, _BYTE *a3)
{
  char v4; // [sp+8h] [bp-Ch]@1

  sub_1003A640(a1, (int)&v4);
  return sub_1003A860((int)&v4, a2, a3);
}

//----- (1003AB30) --------------------------------------------------------
signed int __cdecl sub_1003AB30(int a1)
{
  signed int v1; // esi@1
  char v3; // [sp+7h] [bp-5h]@1
  __int16 v4; // [sp+8h] [bp-4h]@1

  v1 = 0x3FFFF;
  sub_1007C110(58, 60000);
  sub_1003AAE0(a1, &v4, &v3);
  if ( v3 )
    v1 = *(_WORD *)(dword_103334E4 + 2 * v4 + 4);
  sub_1007C0F0(58);
  return v1;
}
// 103334E4: using guessed type int dword_103334E4;

//----- (1003AB90) --------------------------------------------------------
signed int __cdecl sub_1003AB90(char a1, char a2)
{
  return sub_10039C90(-32756, a1, a2, 0, 0, 0);
}

//----- (1003ABB0) --------------------------------------------------------
signed int __cdecl sub_1003ABB0(char a1)
{
  return sub_10039C90(-32754, a1, -1, 0, 0, 0);
}

//----- (1003ABD0) --------------------------------------------------------
signed int __cdecl sub_1003ABD0(char a1)
{
  return sub_10039C90(-32752, a1, -1, 0, 0, 0);
}

//----- (1003ABF0) --------------------------------------------------------
signed int __cdecl sub_1003ABF0(char a1)
{
  return sub_10039C90(-32751, a1, -1, 0, 0, 0);
}

//----- (1003AC10) --------------------------------------------------------
signed int __cdecl sub_1003AC10(char a1, char a2, int a3, char a4)
{
  int v5; // [sp+0h] [bp-44h]@1
  char v6; // [sp+4h] [bp-40h]@1

  v5 = a3;
  v6 = a4;
  return sub_10039C90(-32735, a1, a2, &v5, 0, 0);
}

//----- (1003AC60) --------------------------------------------------------
int __cdecl sub_1003AC60(int a1, int a2, char a3, char a4, float a5)
{
  int v6; // [sp+0h] [bp-44h]@1
  char v7; // [sp+4h] [bp-40h]@1
  char v8; // [sp+5h] [bp-3Fh]@1
  float v9; // [sp+8h] [bp-3Ch]@1

  v9 = a5;
  v6 = a2;
  v7 = a3;
  v8 = a4;
  return sub_10039C90(-32734, a1, -1, &v6, 0, 0);
}

//----- (1003ACC0) --------------------------------------------------------
signed int __cdecl sub_1003ACC0(char a1, int a2, char a3, char a4, char a5, int a6, char a7, char a8)
{
  int v9; // [sp+0h] [bp-44h]@1
  char v10; // [sp+4h] [bp-40h]@1
  char v11; // [sp+5h] [bp-3Fh]@1
  char v12; // [sp+6h] [bp-3Eh]@1
  char v13; // [sp+7h] [bp-3Dh]@1
  char v14; // [sp+8h] [bp-3Ch]@1
  int v15; // [sp+Ch] [bp-38h]@1

  v10 = a3;
  v11 = a4;
  v15 = a6;
  v9 = a2;
  v13 = a7;
  v12 = a5;
  v14 = a8;
  return sub_10039C90(-32730, a1, -1, &v9, 0, 0);
}

//----- (1003AD40) --------------------------------------------------------
signed int __cdecl sub_1003AD40(char a1, int a2, char a3, char a4, char a5, char a6, char a7)
{
  int v8; // [sp+0h] [bp-44h]@1
  char v9; // [sp+4h] [bp-40h]@1
  char v10; // [sp+5h] [bp-3Fh]@1
  char v11; // [sp+6h] [bp-3Eh]@1
  char v12; // [sp+7h] [bp-3Dh]@1
  char v13; // [sp+8h] [bp-3Ch]@1
  int v14; // [sp+Ch] [bp-38h]@1

  v8 = a2;
  v9 = a3;
  v11 = a5;
  v12 = a6;
  v10 = a4;
  v13 = a7;
  v14 = 0x3FFFF;
  return sub_10039C90(-32729, a1, -1, &v8, 0, 0);
}

//----- (1003ADC0) --------------------------------------------------------
signed int __cdecl sub_1003ADC0(char a1, char a2, int a3, char a4)
{
  int v5; // [sp+0h] [bp-44h]@1
  char v6; // [sp+4h] [bp-40h]@1

  v5 = a3;
  v6 = a4;
  return sub_10039C90(-32728, a1, a2, &v5, 0, 0);
}

//----- (1003AE10) --------------------------------------------------------
signed int __cdecl sub_1003AE10(char a1, char a2)
{
  char v3; // [sp+0h] [bp-44h]@1

  return sub_10039C90(-32718, a1, a2, &v3, 0, 0);
}

//----- (1003AE50) --------------------------------------------------------
signed int __cdecl sub_1003AE50(char a1, char a2, const void *a3)
{
  char v4; // [sp+8h] [bp-44h]@1

  qmemcpy(&v4, a3, 0x3Cu);
  return sub_10039C90(-32706, a1, a2, &v4, 0, 0);
}

//----- (1003AEA0) --------------------------------------------------------
char __cdecl sub_1003AEA0(int a1, void *a2)
{
  int v2; // eax@1
  int v3; // eax@2
  unsigned int v4; // edx@2
  __int64 v6; // [sp-4h] [bp-24h]@0
  char v7; // [sp+Ch] [bp-14h]@2
  unsigned int v8; // [sp+10h] [bp-10h]@3
  char v9[6]; // [sp+16h] [bp-Ah]@2
  unsigned int v10; // [sp+1Ch] [bp-4h]@2

  *(_DWORD *)a2 = 1600085855;
  *((_WORD *)a2 + 2) = 24415;
  *((double *)a2 + 1) = 6.2831853071796;
  *((double *)a2 + 2) = 6.2831853071796;
  LODWORD(v6) = a1;
  *((_BYTE *)a2 + 6) = 0;
  *((_WORD *)a2 + 12) = -1;
  *((_BYTE *)a2 + 26) = 0;
  *((_BYTE *)a2 + 30) = 0;
  *((_DWORD *)a2 + 8) = 0x3FFFF;
  *((_WORD *)a2 + 14) = 0;
  LOBYTE(v2) = sub_1002EC50(v6);
  if ( (_BYTE)v2 == 2 )
  {
    sub_1002E110(a1, (int)a2);
    sub_1002E770(a1, (int)a2 + 8);
    v3 = sub_1002EC20(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(v3, 20, &v7);
    v4 = v10;
    v2 = *(_DWORD *)&v9[2] >> 22;
    *((_WORD *)a2 + 12) = *(_WORD *)v9 & 0x7FFF;
    *((_BYTE *)a2 + 30) = (v4 >> 15) & 1;
    *((_WORD *)a2 + 14) = v2 & 3;
    *((_BYTE *)a2 + 26) = (v2 & 3) != 0;
    if ( (unsigned __int16)word_103335F4 >= 0x14u )
    {
      v2 = (v8 >> 26) & 3;
      *((_DWORD *)a2 + 8) = __PAIR__(v8 >> 26, HIWORD(v10)) & 0x3FFFF;
    }
  }
  else if ( (_BYTE)v2 == 7 )
  {
    LOBYTE(v2) = sub_10037840(a1, a2);
  }
  return v2;
}
// 100EBB80: using guessed type int dword_100EBB80;
// 103334D8: using guessed type int dword_103334D8;
// 103335F4: using guessed type __int16 word_103335F4;

//----- (1003AFB0) --------------------------------------------------------
double __cdecl sub_1003AFB0(unsigned int a1)
{
  int v1; // eax@2
  __int64 v3; // [sp-4h] [bp-44h]@0
  float v4; // [sp+4h] [bp-3Ch]@1
  char v5; // [sp+8h] [bp-38h]@5
  char v6; // [sp+10h] [bp-30h]@5
  char v7; // [sp+20h] [bp-20h]@2
  unsigned int v8; // [sp+24h] [bp-1Ch]@2
  int v9; // [sp+2Eh] [bp-12h]@4

  v4 = 6.2831855;
  LODWORD(v3) = a1;
  if ( sub_1002EC50(v3) == 3 )
  {
    v1 = sub_1002EC20(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(v1, 29, &v7);
    if ( v8 >> 29 != 2 && v8 >> 29 != 6 )
      return (float)((double)(v9 >> 23) * 0.01745329238474369 * 0.5);
    sub_1002E770(a1, (int)&v6);
    sub_1007BCF0((int)&v6, (int)&v5);
    sub_1003B630((int)&v5, &v4);
  }
  return v4;
}
// 103334D8: using guessed type int dword_103334D8;

//----- (1003B060) --------------------------------------------------------
void __cdecl sub_1003B060(unsigned int a1, int a2)
{
  int v2; // esi@1
  int v3; // edi@1
  int v4; // eax@2
  unsigned int v5; // ecx@4
  double v6; // st7@4
  unsigned int v7; // ecx@4
  unsigned __int8 v8; // al@4
  char v9; // cl@6
  unsigned __int8 v10; // al@9
  unsigned int v11; // eax@11
  unsigned int v12; // edi@14
  double v13; // st7@14
  int v14; // edx@14
  __int64 v15; // [sp-4h] [bp-34h]@0
  __int16 v16; // [sp+10h] [bp-20h]@2
  __int16 v17; // [sp+12h] [bp-1Eh]@14
  unsigned int v18; // [sp+14h] [bp-1Ch]@4
  unsigned int v19; // [sp+1Ah] [bp-16h]@2
  unsigned int v20; // [sp+1Eh] [bp-12h]@4
  unsigned int v21; // [sp+22h] [bp-Eh]@4
  unsigned __int8 v22; // [sp+26h] [bp-Ah]@4
  __int16 v23; // [sp+27h] [bp-9h]@13
  __int16 v24; // [sp+29h] [bp-7h]@12
  unsigned int v25; // [sp+2Bh] [bp-5h]@11
  int v26; // [sp+38h] [bp+8h]@5

  v2 = a2;
  v3 = a2 + 17;
  *(_DWORD *)v3 = 1600085855;
  *(_WORD *)(v3 + 4) = 24415;
  *(double *)(a2 + 60) = 6.2831853071796;
  *(double *)(a2 + 68) = 6.2831853071796;
  LODWORD(v15) = a1;
  *(float *)(a2 + 32) = 6.2831855;
  *(_BYTE *)(v3 + 6) = 0;
  *(_DWORD *)(a2 + 40) = 0xFFFF;
  *(float *)(a2 + 36) = 9.9999996e24;
  *(_BYTE *)(a2 + 1) = 3;
  *(_BYTE *)a2 = 8;
  *(float *)(a2 + 28) = 9.8999998e24;
  *(_BYTE *)(a2 + 4) = 0;
  *(_BYTE *)(a2 + 5) = 0;
  *(double *)(a2 + 44) = 6.2831853071796;
  *(_BYTE *)(a2 + 3) = 0;
  *(double *)(a2 + 52) = 6.2831853071796;
  *(_DWORD *)(a2 + 24) = 0x3FFFF;
  *(_BYTE *)(a2 + 2) = 7;
  *(_WORD *)(a2 + 6) = 0;
  *(_WORD *)(a2 + 8) = 32;
  if ( sub_1002EC50(v15) == 3 )
  {
    sub_1002E110(a1, v3);
    sub_1002E770(a1, a2 + 60);
    v4 = sub_1002EC20(a1);
    (*(void (__cdecl **)(int, signed int, __int16 *))dword_103334D8)(v4, 29, &v16);
    if ( v19 >> 24 != 255 )
      *(_DWORD *)(a2 + 40) = 50 * ((v19 >> 24) + 2160);
    v5 = v18;
    *(_BYTE *)(a2 + 1) = (v18 >> 27) & 3;
    *(_BYTE *)a2 = (v5 >> 29) & 7;
    *(_BYTE *)(a2 + 4) = (v20 >> 22) & 1;
    *(_BYTE *)(a2 + 5) = (v5 >> 26) & 1;
    strncpy((char *)(a2 + 8), (const char *)(dword_10333D50 + 25 * ((v5 >> 29) + 768)), 8u);
    *(_BYTE *)(a2 + 16) = 0;
    v6 = sub_1003AFB0(a1);
    v7 = v21;
    *(float *)(a2 + 32) = v6;
    v8 = v22;
    *(float *)(a2 + 36) = (double)(signed int)((v7 & 0x7FFF) - 5000) * 0.3048000037670135;
    if ( (unsigned __int16)word_1033363C >= 0x17u )
    {
      HIWORD(v26) = v8 & 3;
      LOWORD(v26) = HIWORD(v21);
      *(_DWORD *)(v2 + 24) = v26;
    }
    v9 = (v7 >> 15) & 1;
    *(_BYTE *)(v2 + 3) = v9;
    if ( v9 )
    {
      *(_DWORD *)(v2 + 44) = *(_DWORD *)(v2 + 60);
      *(_DWORD *)(v2 + 48) = *(_DWORD *)(v2 + 64);
      *(_DWORD *)(v2 + 52) = *(_DWORD *)(v2 + 68);
      *(_DWORD *)(v2 + 56) = *(_DWORD *)(v2 + 72);
    }
    if ( (unsigned __int16)word_1033363C >= 0x1Du )
    {
      v10 = v8 >> 2;
      if ( v10 < 0x3Fu )
        *(float *)(v2 + 28) = (double)v10 * 0.1 * 1852.0;
      v11 = (v25 >> 3) & 0x3FF;
      *(_BYTE *)(v2 + 2) = v25 & 7;
      *(_WORD *)(v2 + 6) = v11;
      if ( v9 && (v24 || v23) )
      {
        v12 = (((v18 >> 8) & 0x1FF) + (v16 << 9)) << 7;
        v13 = sub_10043B40((((unsigned int)(unsigned __int8)v18 + (v17 << 8)) << 7) - (v24 << 7), 24);
        v14 = v23;
        *(double *)(v2 + 44) = v13;
        *(double *)(v2 + 52) = sub_10043B40(v12 - (v14 << 7), 24);
      }
    }
  }
}
// 100EBB80: using guessed type int dword_100EBB80;
// 103334D8: using guessed type int dword_103334D8;
// 1033363C: using guessed type __int16 word_1033363C;
// 10333D50: using guessed type int dword_10333D50;

//----- (1003B2D0) --------------------------------------------------------
int sub_1003B2D0()
{
  int result; // eax@2
  unsigned __int8 v1; // [sp+0h] [bp-Ch]@4
  int v2; // [sp+2h] [bp-Ah]@4
  int v3; // [sp+6h] [bp-6h]@4

  if ( sub_10043B80(0x4Du, 1u) )
  {
    result = dword_1033389C;
    dword_10261D40 = dword_1033389C;
    if ( dword_1033389C )
    {
      (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_103334D8)(dword_1033389C, 8, &v1);
      word_10261D38 = v1;
      result = v3 & 0x1FF;
      dword_10261D40 += (unsigned __int16)word_103338A0;
      word_10261D3C = v2 & 0x1FF;
      word_10261D34 = v3 & 0x1FF;
    }
  }
  else
  {
    word_10261D38 = 6;
    word_10261D3C = 6;
    result = dword_1033371C;
    word_10261D34 = 60;
    dword_10261D40 = dword_1033371C;
  }
  return result;
}
// 10261D34: using guessed type __int16 word_10261D34;
// 10261D38: using guessed type __int16 word_10261D38;
// 10261D3C: using guessed type __int16 word_10261D3C;
// 10261D40: using guessed type int dword_10261D40;
// 103334D8: using guessed type int dword_103334D8;
// 1033371C: using guessed type int dword_1033371C;
// 1033389C: using guessed type int dword_1033389C;
// 103338A0: using guessed type __int16 word_103338A0;

//----- (1003B370) --------------------------------------------------------
char __cdecl sub_1003B370(float *a1)
{
  int v1; // ecx@0
  int v2; // esi@1
  char v3; // bl@1
  char v4; // al@1
  float v5; // ST44_4@4
  double v6; // st6@4
  signed __int16 v7; // si@4
  signed int v8; // eax@4
  signed __int16 v9; // di@4
  float v10; // ST44_4@7
  __int16 v11; // cx@8
  __int16 v12; // ax@8
  signed int v13; // edi@8
  __int16 v14; // bp@8
  int v15; // esi@8
  __int16 v16; // bx@8
  signed int v17; // esi@8
  int *v18; // edi@8
  signed int v19; // ecx@10
  __int64 v20; // rax@11
  __int16 v21; // si@16
  float v23; // [sp+Ch] [bp-1Ch]@8
  float v24; // [sp+10h] [bp-18h]@4
  float v25; // [sp+10h] [bp-18h]@8
  int v26; // [sp+18h] [bp-10h]@8
  int v27; // [sp+1Ch] [bp-Ch]@8

  *a1 = 0.0;
  v2 = v1;
  v3 = 0;
  v4 = sub_10062080(v1, 0);
  if ( dword_10261D40 && v4 && sub_10043B80(0, 0x2Du) )
  {
    v24 = (*(float *)v2 + 1.570796370506287) * 57.29578018188477;
    v5 = 57.29578018188477 * (*(float *)(v2 + 4) + 3.141592741012573);
    v6 = v5;
    v7 = (signed int)v24;
    v8 = (signed int)v5;
    v9 = v8;
    if ( v7 > 179 )
      v7 = 179;
    if ( v9 >= 360 )
    {
      v9 = v8 - 360;
      v10 = v6 - 360.0;
      v6 = v10;
    }
    v11 = v7 / word_10261D38;
    v12 = v9 / word_10261D3C;
    v13 = (signed __int16)(v7 / word_10261D38);
    v14 = v7 / word_10261D38 + 1;
    v23 = v24 / (double)word_10261D38 - (double)v13;
    v15 = v12;
    v25 = v6 / (double)word_10261D3C - (double)v12;
    v16 = (v12 + 1) % word_10261D34;
    (*(void (__cdecl **)(int, signed int, int *))dword_103334D8)(
      dword_10261D40 + (unsigned __int16)word_10333720 * (v12 + v11 * word_10261D34),
      2,
      &v26);
    (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(
      dword_10261D40 + (unsigned __int16)word_10333720 * (v16 + v13 * word_10261D34),
      2,
      (char *)&v26 + 2);
    (*(void (__cdecl **)(int, signed int, int *))dword_103334D8)(
      dword_10261D40 + (unsigned __int16)word_10333720 * (v15 + v14 * word_10261D34),
      2,
      &v27);
    (*(void (__cdecl **)(int, _DWORD, char *))dword_103334D8)(
      dword_10261D40 + (unsigned __int16)word_10333720 * (v16 + v14 * word_10261D34),
      2,
      (char *)&v27 + 2);
    v3 = 1;
    v17 = 1;
    v18 = &v26;
    do
    {
      if ( !v3 )
        break;
      v19 = v17;
      if ( v17 < 4 )
      {
        while ( 1 )
        {
          v20 = (signed __int16)(*(_WORD *)v18 - *((_WORD *)&v26 + v19));
          if ( (signed int)((HIDWORD(v20) ^ v20) - HIDWORD(v20)) > 1820 )
            break;
          if ( ++v19 >= 4 )
            goto LABEL_15;
        }
        v3 = 0;
      }
LABEL_15:
      ++v17;
      v18 = (int *)((char *)v18 + 2);
    }
    while ( v17 - 1 < 3 );
    v21 = v26 + (signed int)((double)(signed __int16)(v27 - v26) * v23);
    *a1 = (double)(signed __int16)(v21
                                 + (signed int)((double)(signed __int16)(HIWORD(v26)
                                                                       + (signed int)(v23
                                                                                    * (double)(signed __int16)(HIWORD(v27) - HIWORD(v26)))
                                                                       - v21)
                                              * v25))
        * 0.0000958738019107841;
  }
  return v3;
}
// 10261D34: using guessed type __int16 word_10261D34;
// 10261D38: using guessed type __int16 word_10261D38;
// 10261D3C: using guessed type __int16 word_10261D3C;
// 10261D40: using guessed type int dword_10261D40;
// 103334D8: using guessed type int dword_103334D8;
// 10333720: using guessed type __int16 word_10333720;

//----- (1003B630) --------------------------------------------------------
char __cdecl sub_1003B630(int a1, float *a2)
{
  return sub_1003B370(a2);
}

//----- (1003B650) --------------------------------------------------------
unsigned __int8 __cdecl sub_1003B650(unsigned __int8 a1, unsigned __int8 a2, int a3, int a4, int a5)
{
  char v5; // bl@1
  double v6; // st7@1
  char v7; // al@3
  int v8; // esi@6
  unsigned __int8 result; // al@26
  char v10; // [sp+Fh] [bp-1h]@1

  v5 = sub_100354B0(a2);
  v6 = 9.9999996e24;
  v10 = sub_10035750(a2);
  if ( !*(_BYTE *)(a3 + 6) )
  {
    if ( *(_BYTE *)(a4 + 7) == 3 )
      goto LABEL_9;
    v7 = *(_BYTE *)(a4 + 6);
    if ( v7 == 2 || v7 == 8 || *(_BYTE *)(a4 + 3) )
    {
      v8 = a5;
      *(_BYTE *)(a5 + 2) = *(_BYTE *)(a4 + 10);
      *(float *)(a5 + 4) = *(float *)(a4 + 20);
      *(_BYTE *)(a5 + 3) = 0;
      *(float *)(a5 + 8) = 9.9999996e24;
      goto LABEL_10;
    }
  }
  if ( *(_BYTE *)(a4 + 7) != 3 )
  {
    v8 = a5;
    *(_BYTE *)(a5 + 2) = *(_BYTE *)(a4 + 8);
    *(float *)(a5 + 4) = *(float *)(a4 + 12);
    *(_BYTE *)(a5 + 3) = 0;
    *(float *)(a5 + 8) = 9.9999996e24;
    goto LABEL_10;
  }
LABEL_9:
  v8 = a5;
  *(_BYTE *)(a5 + 2) = *(_BYTE *)(a4 + 9);
  *(float *)(a5 + 4) = *(float *)(a4 + 16);
  *(_BYTE *)(a5 + 3) = *(_BYTE *)(a4 + 8);
  *(float *)(a5 + 8) = *(float *)(a4 + 12);
LABEL_10:
  switch ( *(_BYTE *)(a4 + 7) )
  {
    case 0:
      *(_BYTE *)v8 = 10;
      break;
    case 1:
      *(_BYTE *)v8 = 11;
      break;
    case 3:
      v6 = 9.9999996e24;
      if ( sub_1002BFA0() == 1 )
      {
        *(_BYTE *)v8 = 13;
      }
      else
      {
        *(float *)(v8 + 8) = 9.9999996e24;
        *(_BYTE *)v8 = 11;
        *(_BYTE *)(v8 + 3) = 0;
      }
      break;
    case 2:
      *(_BYTE *)v8 = 12;
      break;
    default:
      *(_BYTE *)v8 = 0;
      break;
  }
  if ( *(_BYTE *)(a4 + 2) == 1 )
  {
    *(_BYTE *)(v8 + 1) = 10;
  }
  else if ( *(_BYTE *)(a4 + 2) == 2 )
  {
    *(_BYTE *)(v8 + 1) = 12;
  }
  else
  {
    if ( *(_BYTE *)(a4 + 2) != 3 )
    {
      *(_BYTE *)(v8 + 1) = 0;
      goto LABEL_26;
    }
    *(_BYTE *)(v8 + 1) = 11;
  }
  v6 = *(float *)(a4 + 28);
LABEL_26:
  *(float *)(v8 + 12) = v6;
  result = a1;
  if ( v5 != -1 && a1 <= (unsigned __int8)v5 || v10 != -1 && a1 >= (unsigned __int8)v10 )
  {
    if ( *(_BYTE *)v8 )
      *(_BYTE *)v8 |= 0x40u;
    result = *(_BYTE *)(v8 + 1);
    if ( result )
    {
      result |= 0x40u;
      *(_BYTE *)(v8 + 1) = result;
    }
  }
  return result;
}

//----- (1003B7B0) --------------------------------------------------------
char __usercall sub_1003B7B0@<al>(char a1@<al>, char a2@<cl>, char a3)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 3;
      break;
    case 1:
      result = 4;
      break;
    case 2:
      result = 5;
      break;
    case 3:
      result = 6;
      break;
    case 4:
      result = 7;
      break;
    default:
      if ( a3 )
      {
        result = 0;
      }
      else if ( !a2 || a2 == 2 || a2 == 5 || (result = 1, a2 == 6) )
      {
        result = 2;
      }
      break;
  }
  return result;
}

//----- (1003B810) --------------------------------------------------------
BOOL __cdecl sub_1003B810(char a1, char a2, float a3, float a4)
{
  char v5; // [sp+8h] [bp-4h]@1

  v5 = sub_1003B7B0(a2, a1, 0);
  return v5 != 2 && !sub_10039AD0(v5, v5, SLODWORD(a3), a4);
}

//----- (1003B860) --------------------------------------------------------
int __cdecl sub_1003B860(_BYTE *a1, _BYTE *a2)
{
  int result; // eax@1

  result = sub_10043F80(0x2Bu);
  *a1 = result;
  if ( (_BYTE)result )
  {
    result = (int)a2;
    *a2 = 1;
  }
  else
  {
    *a2 = 0;
    *a1 = 1;
  }
  return result;
}

//----- (1003B890) --------------------------------------------------------
int sub_1003B890()
{
  return (*(int (**)(void))(dword_103334D8 + 8))();
}
// 103334D8: using guessed type int dword_103334D8;

//----- (1003B8A0) --------------------------------------------------------
int __fastcall sub_1003B8A0(unsigned __int8 a1)
{
  return dword_10333704 + a1 * (unsigned __int16)word_10333708;
}
// 10333704: using guessed type int dword_10333704;
// 10333708: using guessed type __int16 word_10333708;

//----- (1003B8C0) --------------------------------------------------------
int __fastcall sub_1003B8C0(unsigned __int8 a1)
{
  return dword_10333710 + a1 * (unsigned __int16)word_10333714;
}
// 10333710: using guessed type int dword_10333710;
// 10333714: using guessed type __int16 word_10333714;

//----- (1003B8E0) --------------------------------------------------------
void *__cdecl sub_1003B8E0(char a1, void *a2)
{
  void *result; // eax@2
  int v3; // eax@4
  int v4; // eax@4
  char v5; // [sp+6h] [bp-1Eh]@1
  unsigned __int8 v6; // [sp+7h] [bp-1Dh]@1
  char v7; // [sp+8h] [bp-1Ch]@4
  char v8; // [sp+16h] [bp-Eh]@4

  sub_1003B860(&v6, &v5);
  if ( (unsigned __int8)a1 < v6 )
  {
    if ( v5 )
    {
      v3 = sub_1003B8A0(a1);
      v4 = (*(int (__cdecl **)(int, signed int, char *))dword_103334D8)(v3, 22, &v7);
      result = (void *)sub_1004A530(v4, &v8, 20, (int)a2);
      *((_BYTE *)a2 + 20) = 0;
    }
    else
    {
      result = memcpy_0(a2, &aWgs84[21 * (unsigned __int8)a1], 0x14u);
      *((_BYTE *)a2 + 20) = 0;
    }
  }
  else
  {
    result = (void *)1600085855;
    *(_DWORD *)a2 = 1600085855;
    *((_DWORD *)a2 + 1) = 1600085855;
    *((_DWORD *)a2 + 2) = 1600085855;
    *((_DWORD *)a2 + 3) = 1600085855;
    *((_DWORD *)a2 + 4) = 1600085855;
    *((_BYTE *)a2 + 20) = 0;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;

//----- (1003B9B0) --------------------------------------------------------
int __cdecl sub_1003B9B0(int a1)
{
  bool v1; // zf@1
  int v2; // eax@2
  signed int v3; // eax@2
  float v4; // ST24_4@2
  unsigned __int8 v5; // cl@2
  int v6; // eax@2
  char v7; // al@2
  char v8; // cl@2
  float v9; // ST24_4@3
  double v10; // st6@3
  float v11; // ST24_4@3
  float v12; // ST24_4@3
  double v13; // st7@3
  float v14; // ST24_4@3
  float v16; // [sp+10h] [bp-34h]@2
  char v17; // [sp+14h] [bp-30h]@2
  char v18; // [sp+15h] [bp-2Fh]@2
  char v19; // [sp+16h] [bp-2Eh]@2
  char v20; // [sp+17h] [bp-2Dh]@2
  char v21; // [sp+26h] [bp-1Eh]@2
  char v22; // [sp+28h] [bp-1Ch]@2
  char v23; // [sp+36h] [bp-Eh]@2
  unsigned __int8 v24; // [sp+37h] [bp-Dh]@2
  __int16 v25; // [sp+38h] [bp-Ch]@2
  __int16 v26; // [sp+3Ah] [bp-Ah]@2
  __int16 v27; // [sp+3Ch] [bp-8h]@2

  *(float *)(a1 + 24) = 0.0;
  *(float *)(a1 + 28) = 0.0;
  *(float *)(a1 + 32) = 0.0;
  *(float *)(a1 + 36) = 6378137.0;
  *(float *)(a1 + 40) = 0.0033528106;
  *(_BYTE *)(a1 + 56) = 0;
  memcpy_0((void *)(a1 + 1), "WGS 84              ", 0x15u);
  v1 = *(_BYTE *)(a1 + 81) == 0;
  *(_BYTE *)(a1 + 80) = 1;
  if ( !v1 )
  {
    v2 = sub_1003B8A0(*(_BYTE *)a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(v2, 22, &v22);
    sub_1004A530((int)&v23, &v23, 20, a1 + 1);
    v3 = v27;
    LODWORD(v4) = v26;
    v5 = v24;
    *(float *)(a1 + 24) = (double)v25;
    *(_BYTE *)(a1 + 21) = 0;
    *(float *)(a1 + 28) = (double)SLODWORD(v4);
    *(float *)(a1 + 32) = (double)v3;
    v6 = sub_1003B8C0(v5);
    (*(void (__cdecl **)(int, signed int, float *))dword_103334D8)(v6, 23, &v16);
    v7 = v18;
    v8 = v19;
    LOBYTE(v4) = v17;
    *(float *)(a1 + 36) = v16;
    BYTE1(v4) = v7;
    BYTE2(v4) = v8;
    BYTE3(v4) = v20;
    *(float *)(a1 + 40) = v4;
    sub_1004A530((int)&v21, &v21, 20, a1 + 56);
    *(_BYTE *)(a1 + 76) = 0;
  }
  *(float *)(a1 + 44) = *(float *)(a1 + 40) + *(float *)(a1 + 40) - *(float *)(a1 + 40) * *(float *)(a1 + 40);
  v9 = *(float *)(a1 + 36) - 6378137.0;
  v10 = v9;
  *(float *)(a1 + 48) = v9;
  v11 = *(float *)(a1 + 40) - 0.003352810628712177;
  v12 = 6378137.0 * v11;
  v13 = v12;
  v14 = v10 * 0.00335281066474748;
  *(float *)(a1 + 52) = v13 + v14;
  return (*(int (__cdecl **)(int))(dword_103334D8 + 12))(a1);
}
// 103334D8: using guessed type int dword_103334D8;

//----- (1003BB70) --------------------------------------------------------
char sub_1003BB70()
{
  int v0; // eax@1
  unsigned __int8 v1; // bl@1
  char v2; // al@7
  unsigned __int8 v3; // bl@10
  unsigned __int8 v5; // [sp+6h] [bp-76h]@1
  unsigned __int8 v6; // [sp+7h] [bp-75h]@1
  char v7[4]; // [sp+8h] [bp-74h]@1
  char v8; // [sp+Ch] [bp-70h]@10
  unsigned __int8 v9; // [sp+5Ch] [bp-20h]@5
  char v10; // [sp+5Dh] [bp-1Fh]@8
  char v11; // [sp+5Eh] [bp-1Eh]@6
  char v12; // [sp+60h] [bp-1Ch]@2

  sub_1003B890();
  sub_1003B860(&v6, &v5);
  LOBYTE(v0) = v6;
  v1 = 0;
  v5 = v6;
  v7[0] = 0;
  if ( v6 )
  {
    do
    {
      sub_1003B8E0(v7[0], &v12);
      v0 = strcmp(&v12, "WGS 84              ");
      if ( !v0 )
        v5 = v1;
      v7[0] = ++v1;
    }
    while ( v1 < v6 );
  }
  if ( !v9 || v5 != v11 )
  {
    v2 = sub_10043F80(0x2Bu);
    v9 = v2;
    if ( v2 )
    {
      v10 = 1;
    }
    else
    {
      v2 = 1;
      v10 = 0;
      v9 = 1;
    }
    v3 = 0;
    v8 = v2;
    v11 = v2;
    v7[0] = 0;
    if ( v2 )
    {
      do
      {
        sub_1003B8E0(v7[0], &v12);
        if ( !strcmp(&v12, "WGS 84              ") )
        {
          v11 = v3;
          v8 = v3;
        }
        v7[0] = ++v3;
      }
      while ( v3 < v9 );
    }
    LOBYTE(v0) = sub_1003B9B0((int)&v8);
  }
  return v0;
}

//----- (1003BCE0) --------------------------------------------------------
BOOL __cdecl sub_1003BCE0(unsigned int a1)
{
  int v1; // edi@1
  __int16 i; // si@1
  char v4; // [sp+Bh] [bp-1h]@1

  v1 = sub_1007C040();
  for ( i = sub_1007C6B0(6, 0, 1, (int)&v4); i == 12; i = sub_1007C6B0(6, 0, 1, (int)&v4) )
  {
    if ( sub_1007C040() - v1 >= a1 )
      break;
    sub_1007C1F0(100);
  }
  return i == 12;
}

//----- (1003BD50) --------------------------------------------------------
char __thiscall sub_1003BD50(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1007D180(81, (_BYTE *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1003BD70) --------------------------------------------------------
void __cdecl sub_1003BD70(_BYTE *a1, _BYTE *a2, _BYTE *a3)
{
  sub_1007D180(120, a1);
  sub_1007D180(124, a2);
  sub_1007D180(121, a3);
}

//----- (1003BDA0) --------------------------------------------------------
int __cdecl sub_1003BDA0(int a1)
{
  return sub_1007C3B0(3025, a1, 84);
}

//----- (1003BDC0) --------------------------------------------------------
signed int sub_1003BDC0()
{
  bool v0; // zf@1
  signed int result; // eax@1
  char v2; // [sp+3h] [bp-5h]@1
  int v3; // [sp+4h] [bp-4h]@1

  v0 = sub_1007C760(6, &v3, &v2) == 0;
  result = -4;
  if ( v0 )
    result = v3;
  return result;
}

//----- (1003BDF0) --------------------------------------------------------
void __cdecl sub_1003BDF0(_BYTE *a1)
{
  sub_1007D180(129, a1);
}

//----- (1003BE10) --------------------------------------------------------
char __cdecl sub_1003BE10(int a1, size_t a2, void *a3)
{
  char result; // al@2

  if ( sub_1007C6B0(6, a1, a2, (int)a3) )
  {
    memset(a3, 0, a2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1003BE50) --------------------------------------------------------
int __cdecl sub_1003BE50(int a1)
{
  return sub_1007C500(3025, a1, 84);
}

//----- (1003BE70) --------------------------------------------------------
char __fastcall sub_1003BE70(int *a1)
{
  char v1; // bl@1
  unsigned int v2; // eax@7
  int *v3; // edx@7
  int v4; // esi@11
  int v5; // eax@12
  _BYTE *v6; // edx@12
  int v7; // eax@14
  _BYTE *v8; // edx@14
  _BYTE *v9; // edx@16
  signed int v10; // eax@18
  char result; // al@25
  char v12; // [sp+4h] [bp-68h]@1
  int v13; // [sp+8h] [bp-64h]@2
  int v14; // [sp+Ch] [bp-60h]@29
  int v15; // [sp+10h] [bp-5Ch]@29
  char v16; // [sp+12h] [bp-5Ah]@3
  char v17; // [sp+13h] [bp-59h]@4
  int v18; // [sp+14h] [bp-58h]@5
  char v19; // [sp+18h] [bp-54h]@6
  int v20; // [sp+1Ch] [bp-50h]@2
  int v21; // [sp+20h] [bp-4Ch]@29
  int v22; // [sp+24h] [bp-48h]@29
  char v23; // [sp+26h] [bp-46h]@3
  char v24; // [sp+27h] [bp-45h]@4
  int v25; // [sp+28h] [bp-44h]@5
  char v26; // [sp+2Ch] [bp-40h]@6
  int v27; // [sp+2Dh] [bp-3Fh]@7
  int v28; // [sp+31h] [bp-3Bh]@29
  int v29; // [sp+35h] [bp-37h]@29
  int v30; // [sp+3Ch] [bp-30h]@2
  int v31; // [sp+40h] [bp-2Ch]@2
  int v32; // [sp+44h] [bp-28h]@2
  int v33; // [sp+48h] [bp-24h]@2
  int v34; // [sp+4Ch] [bp-20h]@2
  int v35; // [sp+50h] [bp-1Ch]@2
  int v36; // [sp+54h] [bp-18h]@2
  char v37; // [sp+58h] [bp-14h]@2
  int v38; // [sp+5Ch] [bp-10h]@2
  int v39; // [sp+60h] [bp-Ch]@29
  int v40; // [sp+64h] [bp-8h]@29

  v1 = 1;
  v12 = 1;
  if ( byte_10333D54 )
  {
    v1 = 3;
    goto LABEL_24;
  }
  sub_1003BE10(147, 0xCu, &v38);
  sub_1003BE10(129, 0x11u, &v13);
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  sub_1007C470(2000, &v20, 29, &v30);
  LOWORD(a1) = v20;
  if ( (_WORD)v20 != (_WORD)v13
    || v23 != v16
    || v24 != v17
    || (LOWORD(a1) = v25, v25 != v18)
    || (LOBYTE(a1) = v26, v26 != v19) )
  {
LABEL_22:
    v1 = 2;
LABEL_24:
    v12 = v1;
    goto LABEL_25;
  }
  v2 = 12;
  a1 = &v38;
  v3 = &v27;
  do
  {
    if ( *v3 != *a1 )
      goto LABEL_11;
    v2 -= 4;
    ++a1;
    ++v3;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_20:
    v10 = 0;
    goto LABEL_21;
  }
LABEL_11:
  v4 = *(_BYTE *)v3 - *(_BYTE *)a1;
  if ( *(_BYTE *)v3 == *(_BYTE *)a1 )
  {
    v5 = v2 - 1;
    a1 = (int *)((char *)a1 + 1);
    v6 = (char *)v3 + 1;
    if ( !v5 )
      goto LABEL_20;
    v4 = *v6 - *(_BYTE *)a1;
    if ( *v6 == *(_BYTE *)a1 )
    {
      v7 = v5 - 1;
      a1 = (int *)((char *)a1 + 1);
      v8 = v6 + 1;
      if ( !v7 )
        goto LABEL_20;
      v4 = *v8 - *(_BYTE *)a1;
      if ( *v8 == *(_BYTE *)a1 )
      {
        a1 = (int *)((char *)a1 + 1);
        v9 = v8 + 1;
        if ( v7 == 1 )
          goto LABEL_20;
        v4 = *v9 - *(_BYTE *)a1;
        if ( *v9 == *(_BYTE *)a1 )
          goto LABEL_20;
      }
    }
  }
  v10 = 1;
  if ( v4 <= 0 )
    v10 = -1;
LABEL_21:
  if ( v10 )
    goto LABEL_22;
LABEL_25:
  result = sub_100429A0(a1);
  if ( !result || result == 3 )
    result = sub_10046120(v12);
  if ( v1 == 2 )
  {
    v22 = v15;
    v20 = v13;
    v21 = v14;
    v27 = v38;
    v25 = v18;
    v26 = v19;
    v28 = v39;
    v29 = v40;
    result = sub_1007C500(2000, (int)&v20, 29);
  }
  return result;
}
// 10333D54: using guessed type char byte_10333D54;

//----- (1003C070) --------------------------------------------------------
char sub_1003C070()
{
  int *v0; // ecx@1

  sub_1003A0E0(&off_100ED590);
  return sub_1003BE70(v0);
}
// 100ED590: using guessed type int (__cdecl *off_100ED590)(int, size_t, void *);

//----- (1003C090) --------------------------------------------------------
char sub_1003C090()
{
  sub_1003BCE0(0x9C40u);
  return sub_1003C070();
}

//----- (1003C0B0) --------------------------------------------------------
void sub_1003C0B0()
{
  dword_10261D4C = -15;
}
// 10261D4C: using guessed type int dword_10261D4C;

//----- (1003C0D0) --------------------------------------------------------
signed int sub_1003C0D0()
{
  return sub_1007CC90((int)&off_100ED608);
}
// 100ED608: using guessed type char *off_100ED608;

//----- (1003C0E0) --------------------------------------------------------
int sub_1003C0E0()
{
  return (unsigned __int8)sub_1003C0D0() != 0 ? dword_10261D4C : 0;
}
// 10261D4C: using guessed type int dword_10261D4C;

//----- (1003C0F0) --------------------------------------------------------
int sub_1003C0F0()
{
  int result; // eax@2

  if ( (unsigned __int8)sub_1003C0D0() )
    result = dword_10261D4C + 55656;
  else
    result = 0;
  return result;
}
// 10261D4C: using guessed type int dword_10261D4C;

//----- (1003C120) --------------------------------------------------------
char __fastcall sub_1003C120(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  BYTE3(v2) = 0;
  if ( sub_1007C3B0(2018, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 2u) )
  {
    BYTE3(v2) = 0;
    sub_1007C500(2018, (int)&v2 + 3, 1);
    result = BYTE3(v2);
  }
  return result;
}

//----- (1003C170) --------------------------------------------------------
BOOL __cdecl sub_1003C170(char a1)
{
  int v1; // esi@1
  int v2; // esi@3
  int v3; // esi@3
  int v4; // esi@3
  int v5; // esi@3
  int v6; // esi@3
  int v7; // esi@3
  int v8; // esi@3
  int v10; // esi@4
  int v11; // esi@4
  int v12; // esi@4
  int v13; // esi@4
  int v14; // esi@4
  int v15; // esi@4
  int v16; // esi@4

  v1 = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v2 = (unsigned __int8)sub_100471C0(11);
      v3 = (unsigned __int8)sub_100471C0(12) + v2;
      v4 = (unsigned __int8)sub_100471C0(13) + v3;
      v5 = (unsigned __int8)sub_100471C0(28) + v4;
      v6 = (unsigned __int8)sub_100471C0(29) + v5;
      v7 = (unsigned __int8)sub_100471C0(34) + v6;
      v8 = (unsigned __int8)sub_10045730(0x1EDu) + v7;
      return (unsigned __int8)sub_100471F0(19) + v8 == 1;
    }
  }
  else
  {
    v10 = (unsigned __int8)sub_100471C0(5);
    v11 = (unsigned __int8)sub_100471C0(6) + v10;
    v12 = (unsigned __int8)sub_100471C0(7) + v11;
    v13 = (unsigned __int8)sub_100471C0(26) + v12;
    v14 = (unsigned __int8)sub_100471C0(27) + v13;
    v15 = (unsigned __int8)sub_100471C0(33) + v14;
    v16 = (unsigned __int8)sub_10045730(0x1ECu) + v15;
    v1 = (unsigned __int8)sub_100471F0(17) + v16;
  }
  return v1 == 1;
}

//----- (1003C270) --------------------------------------------------------
char __cdecl sub_1003C270(unsigned int a1)
{
  unsigned int v1; // ecx@1
  unsigned int v2; // ebx@1
  unsigned int v3; // ebx@1
  unsigned int v4; // eax@1
  unsigned __int8 v5; // bl@4
  char result; // al@4
  unsigned __int8 v7; // [sp+8h] [bp+4h]@1

  v1 = a1 / 0x3E8;
  v2 = a1 % 0x3E8;
  v7 = a1 % 0x3E8 / 0x64;
  v3 = -100 * v7 + v2;
  v4 = v3 / 0xA;
  if ( (unsigned __int8)v1 >= 8u || v7 >= 8u || (unsigned __int8)v4 >= 8u || (v5 = v3 - 10 * v4, result = 1, v5 >= 8u) )
    result = 0;
  return result;
}

//----- (1003C2E0) --------------------------------------------------------
char __cdecl sub_1003C2E0(char a1)
{
  char v1; // al@4

  if ( a1 )
  {
    if ( a1 != 1 )
      return 0;
    if ( sub_100471C0(28) )
      return 1;
    v1 = sub_100471C0(29);
  }
  else
  {
    if ( sub_100471C0(26) )
      return 1;
    v1 = sub_100471C0(27);
  }
  if ( v1 )
    return 1;
  return 0;
}

//----- (1003C330) --------------------------------------------------------
char __cdecl sub_1003C330(char a1)
{
  char result; // al@1

  result = 0;
  if ( !a1 )
  {
    if ( sub_100471C0(33) || sub_100471F0(17) )
      return 1;
    return 0;
  }
  if ( a1 != 1 )
    return result;
  if ( !sub_100471C0(34) && !sub_100471F0(19) )
    return 0;
  return 1;
}

//----- (1003C380) --------------------------------------------------------
char __cdecl sub_1003C380(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_100471C0(11);
  }
  else
  {
    result = sub_100471C0(5);
  }
  return result;
}

//----- (1003C3B0) --------------------------------------------------------
BOOL __cdecl sub_1003C3B0(char a1)
{
  int v1; // esi@1
  int v2; // esi@3
  int v3; // esi@3
  char v4; // al@3
  int v5; // esi@4
  char v7; // [sp-10h] [bp-14h]@3

  v1 = 0;
  if ( !a1 )
  {
    v5 = (unsigned __int8)sub_100471C0(6);
    v3 = (unsigned __int8)sub_100471C0(7) + v5;
    v4 = sub_100471C0(26);
    v7 = 27;
    goto LABEL_5;
  }
  if ( a1 == 1 )
  {
    v2 = (unsigned __int8)sub_100471C0(12);
    v3 = (unsigned __int8)sub_100471C0(13) + v2;
    v4 = sub_100471C0(28);
    v7 = 29;
LABEL_5:
    v1 = (unsigned __int8)sub_100471C0(v7) + (unsigned __int8)v4 + v3;
  }
  return v1 == 1;
}

//----- (1003C420) --------------------------------------------------------
char __cdecl sub_1003C420(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_10045730(0x1EDu);
  }
  else
  {
    result = sub_10045730(0x1ECu);
  }
  return result;
}

//----- (1003C450) --------------------------------------------------------
char __cdecl sub_1003C450(char a1)
{
  char v1; // al@4

  if ( a1 )
  {
    if ( a1 != 1 )
      return 0;
    if ( sub_100471C0(13) )
      return 1;
    v1 = sub_100471C0(29);
  }
  else
  {
    if ( sub_100471C0(7) )
      return 1;
    v1 = sub_100471C0(27);
  }
  if ( v1 )
    return 1;
  return 0;
}

//----- (1003C4A0) --------------------------------------------------------
void sub_1003C4A0()
{
  dword_10337088 = -15;
}
// 10337088: using guessed type int dword_10337088;

//----- (1003C4B0) --------------------------------------------------------
char __cdecl sub_1003C4B0(char a1, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // edx@1
  int v5; // eax@1
  int v7; // [sp+0h] [bp-20h]@1
  int v8; // [sp+4h] [bp-1Ch]@1
  int v9; // [sp+8h] [bp-18h]@1
  int v10; // [sp+Ch] [bp-14h]@1
  int v11; // [sp+10h] [bp-10h]@1
  int v12; // [sp+14h] [bp-Ch]@1
  int v13; // [sp+18h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  LOBYTE(v8) = a1;
  v2 = *(_DWORD *)(a2 + 4);
  v9 = *(_DWORD *)a2;
  v3 = *(_DWORD *)(a2 + 8);
  v10 = v2;
  v4 = *(_DWORD *)(a2 + 12);
  v5 = *(_DWORD *)(a2 + 16);
  v11 = v3;
  LOWORD(v7) = -32759;
  v12 = v4;
  v13 = v5;
  return sub_10047790((int)&v7);
}

//----- (1003C530) --------------------------------------------------------
char __usercall sub_1003C530@<al>(unsigned __int8 a1@<al>, _BYTE *a2)
{
  int v2; // ecx@1

  v2 = 0;
  while ( (a1 & (unsigned __int8)byte_100EF300[2 * v2]) != byte_100EF300[2 * v2] )
  {
    if ( ++v2 >= 5 )
      return 0;
  }
  *a2 = byte_100EF301[2 * v2];
  return 1;
}

//----- (1003C560) --------------------------------------------------------
char __usercall sub_1003C560@<al>(bool *a1@<esi>)
{
  bool v1; // bl@1
  char result; // al@2

  v1 = *a1 == 0;
  if ( (unsigned __int8)sub_1003C170(v1) )
  {
    *a1 = v1;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003C590) --------------------------------------------------------
signed int sub_1003C590()
{
  return sub_1007CC90((int)&off_100EF30C);
}
// 100EF30C: using guessed type char *off_100EF30C;

//----- (1003C5A0) --------------------------------------------------------
char __cdecl sub_1003C5A0(char a1)
{
  int v1; // ecx@0
  int v2; // edx@1
  __int64 v3; // rax@1
  int v5; // [sp+0h] [bp-1Ch]@1
  int v6; // [sp+4h] [bp-18h]@1
  __int64 v7; // [sp+8h] [bp-14h]@1
  int v8; // [sp+10h] [bp-Ch]@1
  __int16 v9; // [sp+14h] [bp-8h]@1

  v2 = *(_DWORD *)v1;
  v6 = 0;
  v7 = 0i64;
  v8 = 0;
  v5 = 0;
  v9 = 0;
  LOBYTE(v6) = a1;
  LODWORD(v3) = *(_DWORD *)(v1 + 4);
  *(int *)((char *)&v6 + 2) = v2;
  HIDWORD(v3) = *(_DWORD *)(v1 + 8);
  *(__int64 *)((char *)&v7 + 2) = v3;
  LODWORD(v3) = *(_DWORD *)(v1 + 12);
  LOWORD(v5) = -32758;
  *(int *)((char *)&v8 + 2) = v3;
  return sub_10047790((int)&v5);
}

//----- (1003C610) --------------------------------------------------------
char __cdecl sub_1003C610(void *a1, int a2)
{
  unsigned __int8 v2; // al@3
  char v3; // al@6
  bool v4; // al@8
  bool v5; // zf@8
  char v6; // cl@8
  int v7; // eax@8
  unsigned __int8 v8; // al@18
  int v9; // ecx@18
  int v10; // edx@18
  char v11; // al@22
  char result; // al@32
  char v13; // [sp+Ah] [bp-4Eh]@1
  bool v14; // [sp+Bh] [bp-4Dh]@1
  int v15; // [sp+Ch] [bp-4Ch]@1
  int v16; // [sp+10h] [bp-48h]@1
  unsigned __int8 v17; // [sp+14h] [bp-44h]@13
  int v18; // [sp+18h] [bp-40h]@14
  char v19; // [sp+20h] [bp-38h]@5
  char v20; // [sp+23h] [bp-35h]@10
  char v21; // [sp+26h] [bp-32h]@8
  int v22; // [sp+4Ah] [bp-Eh]@6
  char v23; // [sp+52h] [bp-6h]@8

  *(_DWORD *)a1 = 0;
  *((_DWORD *)a1 + 1) = 0;
  *((_DWORD *)a1 + 2) = 0;
  *((_DWORD *)a1 + 3) = 0;
  v14 = 0;
  v13 = 0;
  v15 = 0;
  v16 = 0;
  if ( (unsigned __int8)a2 >= 2u )
    goto LABEL_25;
  if ( !sub_1003C420(a2) )
  {
    if ( !sub_1003C330(a2) )
    {
      if ( (unsigned __int8)a2 == 1 )
        v11 = sub_100253C0(1, 1221, a1);
      else
        v11 = sub_100253C0(1, 1209, a1);
      v13 = v11;
      goto LABEL_25;
    }
    if ( sub_100629F0(a2, 1, &v17)
      && sub_100529A0(v18, &v15)
      && sub_100529A0(HIWORD(v18), &v16)
      && sub_1003C530(v17, (_BYTE *)a1 + 3)
      && sub_100629F0(a2, 2, &v17) )
    {
      v8 = v17;
      v5 = (v17 & 0x80) == -128;
      v9 = (unsigned __int16)v15;
      *(_BYTE *)a1 = (v17 & 0x10) == 16;
      *((_BYTE *)a1 + 2) = v5;
      v10 = (unsigned __int16)v16;
      v13 = 1;
      *((_DWORD *)a1 + 3) = v9;
      *((_DWORD *)a1 + 2) = v10;
      if ( v8 & 2 )
        *((_BYTE *)a1 + 1) = 2;
      else
        *((_BYTE *)a1 + 1) = (v8 & 8) == 8;
      goto LABEL_25;
    }
LABEL_11:
    v13 = 0;
    goto LABEL_25;
  }
  v2 = sub_10043FF0(&a2, 1u, (int)&unk_100EF2F0, 4, 2, 0);
  if ( !sub_100457A0((unsigned __int16)word_100EF2F2[2 * v2], &v13) || !v13 )
    goto LABEL_11;
  if ( !sub_1003E940(&v19) || (v3 = sub_100529A0(v22, &v15), v13 = 1, !v3) )
    v13 = 0;
  v4 = sub_1003E990();
  v5 = v23 == 1;
  v6 = v21;
  *(_BYTE *)a1 = v4;
  v7 = (unsigned __int16)v15;
  *((_BYTE *)a1 + 3) = 0;
  *((_BYTE *)a1 + 2) = v6;
  *((_DWORD *)a1 + 3) = v7;
  *((_DWORD *)a1 + 2) = v7;
  if ( v5 )
    *((_BYTE *)a1 + 1) = 2;
  else
    *((_BYTE *)a1 + 1) = v20 == 0;
LABEL_25:
  if ( sub_1004DC00((unsigned __int8 *)a1)
    || !sub_1003C270(*((_DWORD *)a1 + 2))
    || !sub_1003C270(*((_DWORD *)a1 + 3))
    || sub_1003C380(a2) && *((_BYTE *)a1 + 1) == 3 )
  {
    result = 0;
  }
  else
  {
    sub_1007C3B0(9241, (int)&v14, 1);
    if ( v14 != (*(_BYTE *)a1 == 1) )
    {
      v14 = *(_BYTE *)a1 == 1;
      sub_1007C500(9241, (int)&v14, 1);
    }
    result = v13;
  }
  return result;
}
// 100EF2F2: using guessed type __int16 word_100EF2F2[];

//----- (1003C8C0) --------------------------------------------------------
__int16 __cdecl sub_1003C8C0(char a1)
{
  int v1; // eax@13
  int v3; // [sp+4h] [bp-10Ch]@1
  int v4; // [sp+8h] [bp-108h]@6
  int v5; // [sp+Ch] [bp-104h]@6
  int v6; // [sp+10h] [bp-100h]@6
  char v7; // [sp+14h] [bp-FCh]@6
  int v8; // [sp+2Ch] [bp-E4h]@10
  char v9; // [sp+94h] [bp-7Ch]@3
  int v10; // [sp+BEh] [bp-52h]@4
  unsigned __int16 v11; // [sp+C8h] [bp-48h]@13

  v3 = 1200;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( sub_1003C420(a1) )
    {
      if ( sub_1003E940(&v9) )
        sub_100529A0(v10, &v3);
    }
    else if ( sub_1003C330(a1) )
    {
      memset(&v7, 0, 0x80u);
      v4 = 0;
      v5 = 0;
      v6 = 0;
      if ( sub_100629F0(a1, 1, &v4) && sub_100529A0(HIWORD(v5), (_WORD *)&v5 + 1) )
      {
        v3 = HIWORD(v5);
      }
      else if ( sub_10062960(a1, 65, (unsigned int)&v7) && sub_100529A0(v8, &v8) )
      {
        v3 = (unsigned __int16)v8;
      }
    }
    else if ( (unsigned __int8)sub_1003C590() )
    {
      sub_10052DE0(a1, (int)&v11);
      v3 = v11;
      v1 = sub_1007C110(39, 200);
      if ( *(_BYTE *)((unsigned __int8)a1 + dword_10337088 + 162) == 1 )
        v3 = *(_WORD *)(dword_10337088 + 68 * (unsigned __int8)a1);
      if ( !v1 )
        sub_1007C0F0(39);
    }
  }
  return v3;
}
// 10337088: using guessed type int dword_10337088;

//----- (1003CA50) --------------------------------------------------------
bool __cdecl sub_1003CA50(int a1)
{
  char v1; // al@1
  bool v2; // bl@1
  int v3; // ecx@3
  bool result; // al@5
  char v5; // [sp+8h] [bp-10h]@1
  char v6; // [sp+Bh] [bp-Dh]@2

  v1 = sub_1003C610(&v5, a1);
  v2 = v1 == 0;
  if ( v1 )
    v2 = v6 == 4;
  if ( sub_1003C420(a1) && sub_1003E890(v3) )
    result = 0;
  else
    result = v2;
  return result;
}

//----- (1003CAA0) --------------------------------------------------------
char __cdecl sub_1003CAA0(int a1, void *a2)
{
  char result; // al@2
  int v3; // esi@3
  void *v4; // ecx@5

  if ( (_BYTE)a1 )
  {
    result = a1 - 1;
    if ( (unsigned __int8)a1 != 1 )
      return result;
    v3 = 1212;
  }
  else
  {
    v3 = 1200;
  }
  sub_10024E60(1, v3, a2, 0, 2, 1);
  sub_10025010(1, v3, 0xFFFFFFF);
  result = sub_100460C0(v4);
  if ( result == 4 )
    result = sub_1003C4B0(a1, (int)a2);
  return result;
}

//----- (1003CB00) --------------------------------------------------------
char __cdecl sub_1003CB00(int a1)
{
  int v1; // ecx@0
  char result; // al@1
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  result = a1;
  LOWORD(v3) = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    LOWORD(v3) = 27401;
    result = sub_1003CAA0(a1, &v3);
  }
  return result;
}

//----- (1003CB30) --------------------------------------------------------
char __cdecl sub_1003CB30(int a1)
{
  int v1; // ecx@0
  char result; // al@1
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  result = a1;
  LOWORD(v3) = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    LOWORD(v3) = 12809;
    result = sub_1003CAA0(a1, &v3);
  }
  return result;
}

//----- (1003CB60) --------------------------------------------------------
char __cdecl sub_1003CB60(int a1)
{
  int v1; // ecx@0
  char result; // al@1
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  result = a1;
  LOWORD(v3) = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    LOWORD(v3) = 27145;
    result = sub_1003CAA0(a1, &v3);
  }
  return result;
}

//----- (1003CB90) --------------------------------------------------------
char __usercall sub_1003CB90@<al>(void *a1@<esi>, int a2)
{
  char v2; // al@4

  *(_BYTE *)a1 = 0;
  if ( sub_1003C2E0(a2) )
  {
    if ( (_BYTE)a2 )
    {
      if ( (unsigned __int8)a2 != 1 )
      {
LABEL_9:
        *(_BYTE *)a1 = 0;
        sub_1003CB00(a2);
        return 0;
      }
      v2 = sub_100253C0(1, 1389, a1);
    }
    else
    {
      v2 = sub_100253C0(1, 1388, a1);
    }
    if ( v2 && !sub_1004D0B0((unsigned __int8 *)a1) )
      return 1;
    goto LABEL_9;
  }
  return 0;
}

//----- (1003CC00) --------------------------------------------------------
bool __cdecl sub_1003CC00(int a1)
{
  bool result; // al@4
  unsigned __int8 v2; // [sp+Bh] [bp-49h]@1
  char v3; // [sp+Ch] [bp-48h]@6
  char v4; // [sp+4Bh] [bp-9h]@6

  v2 = 0;
  if ( !sub_1003C2E0(a1) )
    goto LABEL_10;
  if ( sub_1003CB90(&v2, a1) && v2 > 0u )
    return 1;
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    sub_10052DE0(a1, (int)&v3);
    result = v4 != 0;
  }
  else
  {
LABEL_10:
    result = 0;
  }
  return result;
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1003CCA0) --------------------------------------------------------
char __cdecl sub_1003CCA0(int a1, void *a2)
{
  char v2; // bl@1
  char v3; // al@3
  bool v4; // al@16
  char result; // al@19
  __int16 v6; // kr00_2@21
  char v7; // [sp+Ah] [bp-12h]@1
  char v8; // [sp+Bh] [bp-11h]@6
  int v9; // [sp+Ch] [bp-10h]@1
  int v10; // [sp+10h] [bp-Ch]@1
  int v11; // [sp+14h] [bp-8h]@1
  int v12; // [sp+18h] [bp-4h]@1

  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v2 = 0;
  v7 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
      goto LABEL_6;
    v2 = sub_100253C0(1, 1215, a2);
    v3 = sub_100253C0(1, 1221, &v9);
  }
  else
  {
    v2 = sub_100253C0(1, 1203, a2);
    v3 = sub_100253C0(1, 1209, &v9);
  }
  v7 = v3;
LABEL_6:
  v8 = sub_1003C380(a1);
  if ( sub_1004D950((int)a2)
    || !sub_1003C270(*((_WORD *)a2 + 6))
    || !sub_1003C270(*((_WORD *)a2 + 7))
    || *((_BYTE *)a2 + 11) >= 8u && !v8
    || *(_BYTE *)a2 == 3 && v8 )
  {
    v2 = 0;
  }
  v4 = v7 && !sub_1004DC00((unsigned __int8 *)&v9);
  if ( v2 )
  {
    if ( v4 )
    {
      v6 = *(_WORD *)((char *)&v9 + 1);
      *((_WORD *)a2 + 6) = v12;
      *(_BYTE *)a2 = v6;
      *((_BYTE *)a2 + 1) = HIBYTE(v6);
    }
    result = v2;
  }
  else
  {
    sub_1003CB30(a1);
    result = 0;
  }
  return result;
}

//----- (1003CDD0) --------------------------------------------------------
bool __cdecl sub_1003CDD0(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // edx@1
  int v4; // eax@1
  bool v5; // bl@1
  int v7; // esi@15
  void *v8; // ecx@18
  int v9; // [sp+8h] [bp-24h]@1
  int v10; // [sp+Ch] [bp-20h]@1
  int v11; // [sp+10h] [bp-1Ch]@1
  int v12; // [sp+14h] [bp-18h]@1
  int v13; // [sp+18h] [bp-14h]@1
  int v14; // [sp+1Ch] [bp-10h]@1
  int v15; // [sp+20h] [bp-Ch]@1
  int v16; // [sp+24h] [bp-8h]@1

  v2 = *(_DWORD *)(a2 + 4);
  v3 = *(_DWORD *)(a2 + 8);
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v4 = *(_DWORD *)a2;
  v10 = v2;
  v11 = v3;
  v9 = v4;
  v5 = 0;
  v12 = *(_DWORD *)(a2 + 12);
  if ( sub_1003CCA0(a1, &v13) )
    BYTE3(v11) = BYTE3(v15);
  if ( sub_1003C270(*(_WORD *)(a2 + 12)) && sub_1003C270(*(_WORD *)(a2 + 14)) && (unsigned __int8)a1 < 2u )
  {
    if ( sub_1003C380(a1) )
      v5 = (unsigned __int8)v9 < 6u && (_BYTE)v9 != 3;
    else
      v5 = (unsigned __int8)v9 < 4u;
  }
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
      return 0;
    v7 = 1214;
  }
  else
  {
    v7 = 1202;
  }
  if ( v5 == 1 )
  {
    sub_10024E60(1, v7, &v9, 0, 16, 1);
    sub_10025010(1, v7, 0xFFFFFFF);
    if ( sub_100460C0(v8) == 4 )
      sub_1003C5A0(a1);
    sub_1003CB30(a1);
  }
  return v5;
}

//----- (1003CF20) --------------------------------------------------------
char __cdecl sub_1003CF20(int a1)
{
  char result; // al@1
  int v2; // esi@4
  char v3; // [sp+3h] [bp-1Dh]@5
  __int16 v4; // [sp+4h] [bp-1Ch]@1
  int v5; // [sp+8h] [bp-18h]@3
  int v6; // [sp+Ch] [bp-14h]@1
  int v7; // [sp+10h] [bp-10h]@1
  int v8; // [sp+14h] [bp-Ch]@1
  int v9; // [sp+18h] [bp-8h]@1

  result = 0;
  v4 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  LOBYTE(v4) = 9;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1007C500(2018, (int)&a1, 1);
    result = sub_1003C420(a1);
    if ( !result )
    {
      LOBYTE(v5) = a1;
      if ( sub_1003C560((bool *)&v5) )
      {
        v2 = v5;
        if ( sub_1003C330(v5) )
        {
          v3 = 0;
          sub_10062B40(v2, 6, &v3);
        }
        else if ( (unsigned __int8)sub_1003C3B0(v2) )
        {
          HIBYTE(v4) = 104;
          sub_1003CAA0(v2, &v4);
          sub_1003CB60(v2);
        }
        else if ( sub_1003CCA0(v2, &v6) )
        {
          LOBYTE(v6) = 4;
          sub_1003CDD0(v2, (int)&v6);
        }
      }
      if ( sub_1003C330(a1) )
      {
        v3 = 1;
        result = sub_10062B40(a1, 6, &v3);
      }
      else if ( (unsigned __int8)sub_1003C3B0(a1) )
      {
        HIBYTE(v4) = 105;
        sub_1003CAA0(a1, &v4);
        sub_1003CB60(a1);
        result = sub_1003CC00(a1);
        if ( result )
          result = sub_1003CB00(a1);
      }
      else
      {
        result = sub_1003CCA0(a1, &v6);
        if ( result )
        {
          LOBYTE(v6) = 5;
          result = sub_1003CDD0(a1, (int)&v6);
        }
      }
    }
  }
  return result;
}

//----- (1003D0E0) --------------------------------------------------------
char __cdecl sub_1003D0E0(unsigned __int16 a1)
{
  char v1; // bl@1
  int v2; // ecx@1
  int v3; // esi@3
  __int16 v5; // [sp+4h] [bp-50h]@2
  int v6; // [sp+8h] [bp-4Ch]@1
  int v7; // [sp+Ch] [bp-48h]@1
  int v8; // [sp+10h] [bp-44h]@1
  int v9; // [sp+14h] [bp-40h]@1
  int v10; // [sp+18h] [bp-3Ch]@1
  char v11; // [sp+1Ch] [bp-38h]@1
  __int16 v12; // [sp+46h] [bp-Eh]@5

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v1 = 0;
  memset(&v11, 0, 0x34u);
  LOBYTE(v6) = sub_1003C120(v2);
  if ( (unsigned __int8)v6 < 2u && sub_10052920(a1, &v5) )
  {
    v3 = v6;
    if ( sub_1003C420(v6) )
    {
      if ( sub_1003E940(&v11) )
      {
        v12 = v5;
        sub_1003E8E0(&v11);
        return 1;
      }
    }
    else if ( sub_1003C330(v3) )
    {
      v1 = 1;
      sub_10062B40(2, 3, &v5);
    }
    else if ( sub_1003CCA0(v3, &v7) )
    {
      v1 = 1;
      LOWORD(v10) = a1;
      BYTE1(v7) = 0;
      sub_1003CDD0(v3, (int)&v7);
      if ( sub_1003C560((bool *)&v6) )
        sub_1003CDD0(v6, (int)&v7);
      sub_1007C500(2105, (int)&v7, 16);
    }
  }
  return v1;
}

//----- (1003D230) --------------------------------------------------------
int __cdecl sub_1003D230(char *a1, char a2)
{
  signed int v2; // eax@2
  int result; // eax@4
  int v4; // [sp+8h] [bp-ECh]@1
  char v5; // [sp+24h] [bp-D0h]@4

  v4 = 0;
  if ( a2 == 1 )
    v2 = 2;
  else
    v2 = a2 == 2;
  result = j_HWM_pvg_rgn_get_info(v2, &v4);
  qmemcpy(a1, &v5, 0x74u);
  return result;
}
// 1007C740: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (1003D2A0) --------------------------------------------------------
bool __cdecl sub_1003D2A0(int a1, void *a2)
{
  void *v2; // ecx@0
  char v3; // si@1
  char v4; // bl@1
  int v5; // esi@4
  bool result; // al@7

  v3 = sub_1004A0B0(v2);
  v4 = 0;
  do
  {
    if ( (_BYTE)a1 == (char)off_100EF870[(unsigned __int8)v4](v3) )
    {
      sub_1003D230((char *)a2, v4);
      return 1;
    }
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  v5 = (unsigned __int16)sub_10061F40(a1);
  if ( (unsigned __int16)v5 >= (unsigned __int16)sub_100246D0(2) )
    result = 0;
  else
    result = sub_100253C0(2, v5, a2) == 1 && !sub_10062E70(a2);
  return result;
}
// 100EF870: using guessed type int (__cdecl *off_100EF870[3])(char);

//----- (1003D360) --------------------------------------------------------
char __cdecl sub_1003D360(int a1, bool *a2)
{
  char result; // al@3
  char v3; // [sp+8h] [bp-78h]@2
  int v4; // [sp+78h] [bp-8h]@3

  switch ( (unsigned __int8)a1 )
  {
    case 1u:
    case 4u:
    case 7u:
    case 0xAu:
      if ( sub_1003D2A0(a1, &v3) )
      {
        *a2 = (v4 & 1) == 1;
        result = 1;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      *a2 = sub_10061F20(a1) != 67;
      result = 1;
      break;
  }
  return result;
}

//----- (1003D420) --------------------------------------------------------
void sub_1003D420()
{
  dword_10261D50 = -15;
}
// 10261D50: using guessed type int dword_10261D50;

//----- (1003D430) --------------------------------------------------------
char __cdecl sub_1003D430(unsigned __int16 a1, float *a2)
{
  unsigned __int16 v2; // ax@2
  char result; // al@5
  char v4[4]; // [sp+1Ch] [bp-74h]@1
  int v5; // [sp+20h] [bp-70h]@3
  int v6; // [sp+24h] [bp-6Ch]@1
  char v7; // [sp+28h] [bp-68h]@1

  memset(&v7, 0, 0x64u);
  v6 = 0;
  if ( sub_10062ED0(a1, v4, &v6) == 1 )
  {
    v2 = sub_100246D0(v4[0]);
    if ( (unsigned __int16)v6 >= v2 )
    {
      if ( a1 )
      {
        sprintf(&v7, "NO PKT FOR TYPE %d\n", a1);
        sub_10042930("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 593, 0, &v7);
      }
    }
    else if ( sub_100253C0(v4[0], v6, &v5) && !sub_10054420((int)&v5, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0) )
    {
      result = 1;
      *a2 = *(float *)&v5;
      return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003D550) --------------------------------------------------------
void sub_1003D550()
{
  dword_10261D54 = -15;
}
// 10261D54: using guessed type int dword_10261D54;

//----- (1003D560) --------------------------------------------------------
double __cdecl sub_1003D560(float a1)
{
  int v1; // ecx@0
  double result; // st7@1
  float v3; // [sp+0h] [bp-4h]@1
  float v4; // [sp+8h] [bp+4h]@1
  float v5; // [sp+8h] [bp+4h]@3

  v4 = *(float *)v1 * a1 + *(float *)(v1 + 4);
  v3 = *(float *)(v1 + 8);
  result = v4;
  if ( v3 >= (double)v4 )
    result = v3;
  v5 = *(float *)(v1 + 12);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (1003D5C0) --------------------------------------------------------
signed int sub_1003D5C0()
{
  return sub_1007CC90((int)&off_100F00B8);
}
// 100F00B8: using guessed type char *off_100F00B8;

//----- (1003D5D0) --------------------------------------------------------
char __usercall sub_1003D5D0@<al>(int a1@<esi>, unsigned __int16 a2, float *a3)
{
  char v3; // dl@39
  char result; // al@39
  float v5; // [sp+0h] [bp-280h]@11
  float v6[19]; // [sp+4h] [bp-27Ch]@11
  float v7; // [sp+50h] [bp-230h]@11
  float v8[76]; // [sp+54h] [bp-22Ch]@11
  int v9; // [sp+17Ch] [bp-104h]@29
  int v10; // [sp+180h] [bp-100h]@29
  float v11; // [sp+184h] [bp-FCh]@29
  char v12; // [sp+197h] [bp-E9h]@1
  float v13; // [sp+198h] [bp-E8h]@1
  float v14; // [sp+19Ch] [bp-E4h]@1
  float v15; // [sp+1A0h] [bp-E0h]@1
  float v16; // [sp+1A4h] [bp-DCh]@1
  float v17; // [sp+1A8h] [bp-D8h]@1
  float v18; // [sp+1ACh] [bp-D4h]@1
  float v19; // [sp+1B0h] [bp-D0h]@17
  float v20; // [sp+1B4h] [bp-CCh]@37
  float v21; // [sp+1B8h] [bp-C8h]@22
  float v22; // [sp+1BCh] [bp-C4h]@17
  int v23; // [sp+1C0h] [bp-C0h]@1
  int v24[3]; // [sp+1C4h] [bp-BCh]@1
  int v25; // [sp+1D0h] [bp-B0h]@1
  int v26[3]; // [sp+1D4h] [bp-ACh]@1
  int v27; // [sp+1E0h] [bp-A0h]@1
  int v28; // [sp+1E4h] [bp-9Ch]@1
  int v29; // [sp+208h] [bp-78h]@1
  int v30; // [sp+20Ch] [bp-74h]@1
  int v31; // [sp+230h] [bp-50h]@1
  int v32; // [sp+234h] [bp-4Ch]@1
  int v33; // [sp+258h] [bp-28h]@1
  int v34; // [sp+25Ch] [bp-24h]@1

  v12 = 0;
  v25 = 0;
  v26[0] = 0;
  v23 = 0;
  v24[0] = 0;
  v27 = 0;
  v28 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v29 = 0;
  v30 = 0;
  v13 = 0.0;
  v14 = 0.0;
  v15 = 0.0;
  v16 = 0.0;
  v17 = 0.0;
  v18 = 0.0;
  switch ( a2 )
  {
    case 0x3Au:
    case 0x3Bu:
      if ( sub_1007C3B0(6091, (int)&v23, 16) )
        sub_10042930("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 192, 0, 0);
      if ( sub_1007C3B0(6115, (int)&v25, 16) )
        sub_10042930("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 193, 0, 0);
      v16 = *((float *)&v23 + 2 * a1);
      v15 = *(float *)&v24[2 * a1];
      v13 = *((float *)&v25 + 2 * a1);
      v14 = *(float *)&v26[2 * a1];
      goto LABEL_37;
    case 0x3Cu:
    case 0x3Du:
    case 0x3Eu:
    case 0x3Fu:
    case 0x40u:
      if ( sub_1007C3B0(6090, (int)&v31, 40) )
        sub_10042930("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 205, 0, 0);
      if ( sub_1007C3B0(6114, (int)&v27, 40) )
        sub_10042930("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 206, 0, 0);
      v16 = *(&v7 + 2 * a2);
      v15 = v8[2 * a2];
      v13 = *(&v5 + 2 * a2);
      v14 = v6[2 * a2];
      goto LABEL_37;
    case 0x41u:
    case 0x42u:
    case 0x43u:
    case 0x44u:
    case 0x45u:
      if ( sub_1007C3B0(6092, (int)&v29, 40) )
        sub_10042930("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 218, 0, 0);
      if ( sub_1007C3B0(6116, (int)&v33, 40) )
        sub_10042930("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 219, 0, 0);
      v16 = *(&v5 + 2 * a2);
      v15 = v6[2 * a2];
      v13 = *(&v7 + 2 * a2);
      v14 = v8[2 * a2];
      goto LABEL_37;
    case 0x4Eu:
      v19 = 9.8999998e24;
      if ( sub_1007C470(6355, &v22, 4, &v19) )
        sub_10042930("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 228, 0, 0);
      sub_1007D180(14, &v12);
      if ( v12 == 10 )
        v22 = v22 * 0.5555555820465088;
      v16 = 9.9999996e24;
      v15 = -9.9999996e24;
      v17 = -9.9999996e24;
      v18 = 9.9999996e24;
      v14 = v22;
      v13 = 1.0;
      goto LABEL_37;
    case 0x4Fu:
      v19 = 9.8999998e24;
      if ( sub_1007C470(6356, &v21, 4, &v19) )
        sub_10042930("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 250, 0, 0);
      sub_1007D180(14, &v12);
      if ( v12 == 10 )
        v21 = v21 * 0.5555555820465088;
      v16 = 9.9999996e24;
      v15 = -9.9999996e24;
      v17 = -9.9999996e24;
      v18 = 9.9999996e24;
      v14 = v21;
      v13 = 1.0;
      goto LABEL_37;
    case 0x98u:
    case 0x99u:
      v16 = 9.9999996e24;
      v15 = -9.9999996e24;
      v13 = 1.0;
      v14 = 0.0;
      goto LABEL_37;
    case 0x67u:
      if ( !sub_1007C3B0(6162, (int)&v13, 24) )
        goto LABEL_37;
      v11 = 0.0;
      v10 = 0;
      v9 = 282;
      goto LABEL_36;
    case 0x68u:
    case 0xC0u:
      if ( !sub_1007C3B0(6161, (int)&v13, 24) )
        goto LABEL_37;
      v11 = 0.0;
      v10 = 0;
      v9 = 287;
      goto LABEL_36;
    case 0x69u:
      if ( !sub_1007C3B0(6160, (int)&v13, 24) )
        goto LABEL_37;
      v11 = 0.0;
      v10 = 0;
      v9 = 291;
      goto LABEL_36;
    case 0x70u:
      if ( sub_1007C3B0(6235, (int)&v13, 24) )
      {
        v11 = 0.0;
        v10 = 0;
        v9 = 295;
LABEL_36:
        sub_10042930("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", v9, v10, (char *)LODWORD(v11));
      }
LABEL_37:
      if ( sub_1003D430(a2, &v20) && (LODWORD(v20) & 0x7F800000) != 2139095040 )
      {
        *a3 = sub_1003D560(v20);
        result = v3;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 1003D5D0: using guessed type int var_AC[3];
// 1003D5D0: using guessed type int var_BC[3];
// 1003D5D0: using guessed type float var_22C[76];
// 1003D5D0: using guessed type float var_27C[19];

//----- (1003DB10) --------------------------------------------------------
char __cdecl sub_1003DB10(unsigned __int8 a1, _DWORD *a2)
{
  char result; // al@3

  if ( a1 >= 4u )
  {
    sub_10042930("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 795, 0, 0);
    return 0;
  }
  if ( (unsigned __int8)sub_1003D5C0() != 1 )
    return 0;
  if ( *(_DWORD *)(dword_10261D54 + 4 * a1 + 696) + 4000 <= (unsigned int)sub_1007C040() )
  {
    result = 0;
  }
  else
  {
    *a2 = *(_DWORD *)(dword_10261D54 + 4 * a1 + 228);
    result = 1;
  }
  return result;
}
// 10261D54: using guessed type int dword_10261D54;

//----- (1003DB80) --------------------------------------------------------
int __cdecl sub_1003DB80(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10043FF0(&a1, 1u, (int)&unk_100F1B78, 8, 67, 0);
  if ( v1 )
  {
    result = dword_100F1B7C[2 * v1];
  }
  else
  {
    sub_10042930("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 1932, 0, 0);
    result = 0;
  }
  return result;
}
// 100F1B7C: using guessed type int dword_100F1B7C[];

//----- (1003DBD0) --------------------------------------------------------
char __cdecl sub_1003DBD0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int (__cdecl *v7)(int, int, int, int, int, int); // eax@2

  v6 = sub_10043FF0(&a1, 1u, (int)&unk_100F17D8, 16, 58, 57);
  if ( v6 == 57 )
  {
    sub_10042930("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 2231, 0, 0);
  }
  else
  {
    v7 = (int (__cdecl *)(int, int, int, int, int, int))dword_100F17DC[4 * v6];
    if ( v7 )
      return v7(a1, a2, a3, a4, a5, a6);
  }
  return 0;
}
// 100F17DC: using guessed type int dword_100F17DC[];

//----- (1003DC40) --------------------------------------------------------
int __cdecl sub_1003DC40(char a1, _WORD *a2)
{
  int v2; // eax@1
  int v3; // ecx@1

  v2 = 8 * sub_10043FF0(&a1, 1u, (int)&unk_100F17D8, 16, 58, 67);
  v3 = *(int *)((char *)&off_100F17E0 + v2 * 2);
  *a2 = word_100F17E4[v2];
  return v3;
}
// 100F17E0: using guessed type void *off_100F17E0;
// 100F17E4: using guessed type __int16 word_100F17E4[];

//----- (1003DC80) --------------------------------------------------------
char __cdecl sub_1003DC80(unsigned int a1)
{
  bool v1; // zf@2
  char result; // al@2
  unsigned int v3; // [sp+4h] [bp-4h]@1

  v3 = sub_1007C360(a1);
  if ( sub_10043FF0(&v3, 4u, (int)&unk_100F1D90, 4, 16, -1) == -1
    || (v1 = sub_10043FF0(&a1, 4u, (int)&unk_100F17CC, 4, 3, -1) == -1, result = 1, !v1) )
  {
    result = 0;
  }
  return result;
}

//----- (1003DCE0) --------------------------------------------------------
signed int sub_1003DCE0()
{
  signed int result; // eax@1

  result = -15;
  dword_10261D58 = -15;
  dword_10261D5C = -15;
  return result;
}
// 10261D58: using guessed type int dword_10261D58;
// 10261D5C: using guessed type int dword_10261D5C;

//----- (1003DCF0) --------------------------------------------------------
signed int sub_1003DCF0()
{
  return sub_1007CC90((int)&off_100F1DD0);
}
// 100F1DD0: using guessed type char *off_100F1DD0;

//----- (1003DD00) --------------------------------------------------------
signed int sub_1003DD00()
{
  return sub_1007CC90((int)&off_100F1DE4);
}
// 100F1DE4: using guessed type char *off_100F1DE4;

//----- (1003DD10) --------------------------------------------------------
char __usercall sub_1003DD10@<al>(char a1@<bl>, int a2@<edi>, const void *a3@<esi>, char a4, char a5, char a6, unsigned int a7)
{
  char v7; // dl@12
  __int16 v9; // [sp+4h] [bp-528h]@1
  char v10; // [sp+8h] [bp-524h]@11
  char v11; // [sp+9h] [bp-523h]@11
  char v12; // [sp+Ah] [bp-522h]@11
  char v13; // [sp+Bh] [bp-521h]@11
  __int16 v14; // [sp+Ch] [bp-520h]@12
  char v15; // [sp+Eh] [bp-51Eh]@12
  char v16; // [sp+Fh] [bp-51Dh]@15
  unsigned int v17; // [sp+524h] [bp-8h]@15

  memset(&v9, 0, 0x524u);
  if ( (unsigned __int8)a1 >= 8u )
    sub_10042930("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3425, 0, 0);
  if ( (unsigned __int8)a4 >= 0x39u )
    sub_10042930("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3426, 0, 0);
  if ( (unsigned __int8)a5 >= 2u )
    sub_10042930("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3427, 0, 0);
  if ( (unsigned __int8)a6 >= 0x2Cu )
    sub_10042930("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3428, 0, 0);
  if ( a7 >= 0x514 )
    sub_10042930("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3429, 0, 0);
  v13 = a6;
  v9 = -32749;
  v10 = a1;
  v11 = a4;
  v12 = a5;
  if ( a2 )
  {
    v7 = *(_BYTE *)(a2 + 2);
    v14 = *(_WORD *)a2;
    v15 = v7;
  }
  else
  {
    v14 = 0;
    v15 = 0;
  }
  if ( a3 )
  {
    memcpy(&v16, a3, a7);
    v17 = a7;
  }
  else
  {
    v17 = 0;
  }
  return sub_100477A0((int)&v9);
}

//----- (1003DE70) --------------------------------------------------------
char __cdecl sub_1003DE70(_BYTE *a1)
{
  char result; // al@2

  if ( (unsigned __int8)sub_1003DCF0() == 1 )
  {
    *a1 = *(_BYTE *)dword_10261D58;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10261D58: using guessed type int dword_10261D58;

//----- (1003DEA0) --------------------------------------------------------
char __cdecl sub_1003DEA0(unsigned __int8 a1, _BYTE *a2)
{
  char result; // al@3

  if ( (unsigned __int8)sub_1003DD00() != 1 || a1 >= 0x43u )
  {
    result = 0;
  }
  else
  {
    *a2 = *(_BYTE *)(a1 + dword_10261D5C);
    result = 1;
  }
  return result;
}
// 10261D5C: using guessed type int dword_10261D5C;

//----- (1003DED0) --------------------------------------------------------
char __cdecl sub_1003DED0(char a1, char a2, int a3)
{
  return sub_1003DD10(2, a3, 0, a1, 0, a2, 0);
}

//----- (1003DF00) --------------------------------------------------------
char __cdecl sub_1003DF00(unsigned __int8 a1, char a2)
{
  char result; // al@3
  char v3; // [sp+7h] [bp-Dh]@3
  int v4; // [sp+8h] [bp-Ch]@1
  __int16 v5; // [sp+Ch] [bp-8h]@1

  v4 = 0;
  v5 = 0;
  if ( a1 >= 0x43u )
    sub_10042930("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 2085, 0, 0);
  result = sub_1003DEA0(a1, &v3);
  if ( result == 1 )
  {
    result = a2;
    if ( v3 != a2 )
    {
      LOWORD(v4) = -32748;
      LOBYTE(v5) = a1;
      HIBYTE(v5) = a2;
      result = sub_100477A0((int)&v4);
    }
  }
  return result;
}

//----- (1003DF80) --------------------------------------------------------
bool __cdecl sub_1003DF80(int a1)
{
  void *v1; // ecx@0

  return (a1 & sub_100460A0(v1) & 0x330000) == a1;
}

//----- (1003DFA0) --------------------------------------------------------
void __usercall sub_1003DFA0(void *a1@<ecx>, bool *a2@<esi>)
{
  void *v2; // ecx@2

  if ( *a2 == 6 )
  {
    if ( sub_100429D0(a1) == 4 )
      *a2 = sub_10045280(v2) == 1;
    else
      *a2 = byte_10261D68;
  }
}
// 10261D68: using guessed type char byte_10261D68;

//----- (1003DFD0) --------------------------------------------------------
void __usercall sub_1003DFD0(_BYTE *a1@<esi>, unsigned __int16 a2)
{
  char v2; // al@6
  __int16 *v3; // [sp-18h] [bp-18h]@4
  void *v4; // [sp-10h] [bp-10h]@4

  if ( *a1 == -1 && byte_10261D65 )
  {
    if ( a2 > 4u )
    {
      v4 = &unk_10261DD2;
      v3 = (__int16 *)&a2;
    }
    else
    {
      v4 = &unk_10261DAA;
      v3 = (__int16 *)&a2;
    }
    v2 = sub_10043FF0(v3, 2u, (int)v4, 2, 20, 255);
    if ( v2 != -1 )
      ++v2;
    *a1 = v2;
  }
}
// 10261D65: using guessed type char byte_10261D65;

//----- (1003E020) --------------------------------------------------------
_BYTE *__usercall sub_1003E020@<eax>(_BYTE *result@<eax>, __int16 a2@<dx>, _BYTE *a3@<ecx>, char a4)
{
  switch ( a2 )
  {
    case 18:
      *a3 = 2;
      if ( byte_10261D8A == 1 )
        *result = (a4 == 1) + 1;
      else
LABEL_8:
        *result = 0;
      break;
    case 19:
LABEL_9:
      *a3 = 3;
      *result = 0;
      break;
    case 17:
      switch ( byte_10261D89 )
      {
        case 0:
          *a3 = 2;
          goto LABEL_8;
        case 1:
          goto LABEL_9;
        case 2:
          *a3 = 1;
          *result = 0;
          break;
        case 3:
          *a3 = 4;
          *result = 0;
          break;
        default:
          *a3 = -1;
          *result = -1;
          break;
      }
      break;
  }
  return result;
}
// 10261D89: using guessed type char byte_10261D89;
// 10261D8A: using guessed type char byte_10261D8A;

//----- (1003E0A0) --------------------------------------------------------
char __thiscall sub_1003E0A0(void *this)
{
  bool v1; // zf@3
  char result; // al@3

  if ( sub_100460C0(this) != 4 || sub_1004E9A0(0x10000) || (v1 = sub_1004E9A0(0x20000) == 0, result = 1, !v1) )
    result = 0;
  return result;
}

//----- (1003E0E0) --------------------------------------------------------
int __thiscall sub_1003E0E0(void *this)
{
  char v1; // si@1
  void *v2; // ecx@1
  int v3; // edi@1
  void *v4; // ecx@1
  int v5; // ebp@1
  int v6; // ecx@1
  int result; // eax@1

  v1 = sub_100460A0(this) & 0xF0;
  v3 = sub_100460A0(v2) & 0x30000;
  v5 = sub_100429D0(v4);
  v6 = ((v1 & 0x10) == 16) + ((v1 & 0x20) == 32) + ((v1 & 0x40) == 64) + ((v1 & 0x80) == -128);
  result = ((v3 & 0x10000) == 0x10000) + ((v3 & 0x20000) == 0x20000);
  if ( (v6 == 2 || v6 == 4) && result == 2 )
  {
    if ( v5 == 128 || v5 == 32 || v5 == 2 )
    {
      dword_10261D6C = 0x20000;
      word_10261D70 = 1699;
      word_10261D72 = 1688;
      word_10261D74 = 1703;
      word_10261D78 = 1707;
      word_10261D76 = 1705;
      byte_10261D68 = 1;
      return result;
    }
    goto LABEL_15;
  }
  if ( v6 != 2 && v6 != 4 || result != 1 )
  {
LABEL_15:
    word_10261D76 = 1704;
    word_10261D78 = 1706;
    word_10261D74 = 1702;
    word_10261D72 = 1686;
    word_10261D70 = 1698;
    dword_10261D6C = 0x10000;
    goto LABEL_16;
  }
  dword_10261D6C = 0x10000;
  word_10261D70 = 1698;
  word_10261D72 = 1686;
  word_10261D74 = 1702;
  word_10261D78 = 1706;
  word_10261D76 = 1704;
  if ( v5 == 128 || v5 == 32 || v5 == 2 )
  {
    byte_10261D68 = 1;
    return result;
  }
LABEL_16:
  byte_10261D68 = 0;
  return result;
}
// 10261D68: using guessed type char byte_10261D68;
// 10261D6C: using guessed type int dword_10261D6C;
// 10261D70: using guessed type __int16 word_10261D70;
// 10261D72: using guessed type __int16 word_10261D72;
// 10261D74: using guessed type __int16 word_10261D74;
// 10261D76: using guessed type __int16 word_10261D76;
// 10261D78: using guessed type __int16 word_10261D78;

//----- (1003E270) --------------------------------------------------------
char __usercall sub_1003E270@<al>(char result@<al>, unsigned __int8 a2@<dl>, unsigned __int8 a3@<cl>, unsigned __int8 a4)
{
  signed int v4; // esi@1
  unsigned __int16 v5; // bx@5
  int v6; // [sp+4h] [bp-8h]@5
  int v7; // [sp+8h] [bp-4h]@5

  v4 = 0;
  if ( (unsigned __int8)result < 0xEu && a4 < 0xAu && a2 < 0x2Fu && a3 < 0x14u )
  {
    HIBYTE(v5) = result;
    LOBYTE(v5) = a4;
    v6 = 0x1000000;
    v7 = a3 | ((a2 | (v5 << 8)) << 8);
    if ( sub_1003E0A0((void *)a3) )
    {
      sub_1007C1F0(20);
      v4 = 255;
    }
    sub_10024E60(1, 1675, &v6, 0, 8, 1);
    result = sub_10025010(1, 1675, v4 | 0xB3000);
  }
  return result;
}

//----- (1003E300) --------------------------------------------------------
void __cdecl sub_1003E300(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  void *v4; // ecx@0
  int v5; // ecx@2
  char v6; // al@4

  if ( a1 <= 6u )
  {
    sub_1003DFA0(v4, (bool *)&a1);
    v5 = 13 * a1;
    if ( a4 )
    {
      if ( a4 == 1 )
        v6 = byte_100F2344[v5];
      else
        v6 = byte_100F2343[v5];
    }
    else
    {
      v6 = byte_100F2345[v5];
    }
    sub_1003E270(v6, a2, a3, byte_100F2346[v5]);
  }
}

//----- (1003E360) --------------------------------------------------------
char __cdecl sub_1003E360(void *a1)
{
  void *v1; // ecx@0
  signed int v2; // esi@1

  v2 = 0;
  if ( sub_1003E0A0(v1) )
  {
    sub_1007C1F0(20);
    v2 = 255;
  }
  sub_10024E60(1, 1678, a1, 0, 12, 1);
  return sub_10025010(1, 1678, v2 | 0x30000);
}

//----- (1003E3B0) --------------------------------------------------------
char __usercall sub_1003E3B0@<al>(char a1@<al>, char a2@<dl>, int a3@<ecx>, int a4)
{
  int v4; // ecx@1
  signed int v5; // esi@1

  v4 = 16 * a3;
  v5 = 0;
  a4 = a4 & 0xF | (unsigned __int16)(16 * (a2 & 0xF | 16 * (v4 | a1 & 0xF)));
  if ( sub_1003E0A0((void *)v4) )
  {
    sub_1007C1F0(20);
    v5 = 255;
  }
  sub_10024E60(1, 2362, &a4, 0, 2, 1);
  return sub_10025010(1, 2362, v5 | 0x30000);
}

//----- (1003E420) --------------------------------------------------------
void sub_1003E420()
{
  sub_1003E300(0, 0x21u, 1u, 0);
  sub_1003E300(1u, 0x21u, 1u, 0);
}

//----- (1003E440) --------------------------------------------------------
char __cdecl sub_1003E440(int a1)
{
  int v1; // edi@1
  char v2; // bl@1
  char v3; // bp@1
  unsigned __int16 v4; // ax@1

  v1 = (unsigned __int16)sub_10043FF0((_DWORD *)(a1 + 3), 1u, (int)"ABCDEFGHJKLMPQRS", 1, 16, 16);
  v2 = sub_10043FF0((_DWORD *)(a1 + 2), 1u, (int)"ABCDEFGHJKLMPQRS", 1, 16, 16);
  v3 = sub_10043FF0((_DWORD *)(a1 + 1), 1u, (int)"ABCDEFGHJKLMPQRS", 1, 16, 16);
  v4 = sub_10043FF0((_DWORD *)a1, 1u, (int)"ABCDEFGHJKLMPQRS", 1, 16, 16);
  return sub_1003E3B0(v3, v2, v4, v1);
}

//----- (1003E4C0) --------------------------------------------------------
bool __thiscall sub_1003E4C0(void *this)
{
  bool result; // al@1

  dword_10261D60 = -15;
  byte_10261D64 = 0;
  sub_1003E0E0(this);
  result = sub_1007C3B0(6650, (int)&unk_10261D80, 7508) == 0;
  byte_10261D65 = result;
  dword_10261D7C = 0;
  return result;
}
// 10261D60: using guessed type int dword_10261D60;
// 10261D64: using guessed type char byte_10261D64;
// 10261D65: using guessed type char byte_10261D65;
// 10261D7C: using guessed type int dword_10261D7C;

//----- (1003E520) --------------------------------------------------------
char __cdecl sub_1003E520(unsigned __int8 a1)
{
  void *v1; // ecx@0
  int v2; // eax@2
  unsigned __int16 v3; // cx@2
  char result; // al@2
  int v5; // [sp+0h] [bp-Ch]@2
  int v6; // [sp+4h] [bp-8h]@2
  float v7; // [sp+8h] [bp-4h]@2

  if ( a1 <= 6u )
  {
    sub_1003DFA0(v1, (bool *)&a1);
    v7 = 0.0;
    v2 = 13 * a1;
    HIBYTE(v3) = byte_100F2347[v2];
    v5 = 16973825;
    LOBYTE(v3) = byte_100F2348[v2];
    v6 = v3 << 16;
    result = sub_1003E360(&v5);
  }
  return result;
}

//----- (1003E580) --------------------------------------------------------
void __cdecl sub_1003E580(char a1, __int16 a2)
{
  void *v2; // ecx@0
  int v3; // eax@2
  char v4; // dl@2
  char v5; // al@2
  int v6; // eax@3
  char v7; // bl@3
  unsigned __int16 v8; // cx@4
  char v9; // [sp+2h] [bp-Eh]@2
  char v10; // [sp+3h] [bp-Dh]@2
  int v11; // [sp+4h] [bp-Ch]@4
  int v12; // [sp+8h] [bp-8h]@4
  float v13; // [sp+Ch] [bp-4h]@4

  if ( (unsigned __int8)a1 <= 6u )
  {
    sub_1003DFA0(v2, (bool *)&a1);
    v3 = 13 * (unsigned __int8)a1;
    v4 = byte_100F2349[v3];
    LOBYTE(v3) = byte_100F234A[v3];
    v9 = v4;
    v10 = v3;
    sub_1003E020(&v10, a2, &v9, a1);
    v5 = sub_10043FF0(&a2, 2u, (int)&unk_100F2438, 4, 24, -1);
    if ( v5 >= 0 )
    {
      v6 = 2 * v5;
      v7 = byte_100F243A[2 * v6];
      a1 = byte_100F243B[2 * v6];
      sub_1003DFD0(&a1, a2);
      if ( a1 != -1 )
      {
        HIBYTE(v8) = v9;
        v13 = 0.0;
        LOBYTE(v8) = v10;
        v11 = 16908289;
        v12 = (unsigned __int8)a1 | (((unsigned __int8)v7 | (v8 << 8)) << 8);
        sub_1003E360(&v11);
      }
    }
  }
}

//----- (1003E660) --------------------------------------------------------
char __cdecl sub_1003E660(__int16 a1)
{
  char v1; // bl@1
  __int16 v2; // ST44_2@1
  __int16 v3; // ST48_2@1
  unsigned int v4; // eax@4
  int v6; // [sp+8h] [bp-Ch]@1
  char v7; // [sp+Ch] [bp-8h]@1

  v6 = 0;
  v7 = 0;
  sub_1007C650(3543, &v6, 5, "AAAA");
  v1 = sub_10043FF0((int *)((char *)&v6 + 3), 1u, (int)"ABCDEFGHJKLMPQRS", 1, 16, 16);
  v2 = sub_10043FF0((int *)((char *)&v6 + 2), 1u, (int)"ABCDEFGHJKLMPQRS", 1, 16, 16);
  v3 = sub_10043FF0((int *)((char *)&v6 + 1), 1u, (int)"ABCDEFGHJKLMPQRS", 1, 16, 16);
  if ( (v1 & 0xF | (unsigned __int16)(16
                                    * (v2 & 0xF | 16
                                                * (v3 & 0xF | 16
                                                            * sub_10043FF0(&v6, 1u, (int)"ABCDEFGHJKLMPQRS", 1, 16, 16))))) == a1 )
  {
    dword_10261D7C = 0;
    LOBYTE(v4) = sub_1004E9F0();
  }
  else
  {
    sub_1003E440((int)&v6);
    if ( !dword_10261D7C )
      dword_10261D7C = sub_10041EB0() + 3000;
    v4 = sub_10041EB0();
    if ( v4 > dword_10261D7C )
      LOBYTE(v4) = sub_1004EA00();
  }
  return v4;
}
// 10041EB0: using guessed type int sub_10041EB0(void);
// 10261D7C: using guessed type int dword_10261D7C;

//----- (1003E790) --------------------------------------------------------
void __fastcall sub_1003E790(int a1, char a2)
{
  char v2; // cl@2
  int v3; // eax@3
  int v4; // esi@8
  unsigned __int8 v5; // bl@8

  if ( byte_10261D65 )
  {
    v2 = 3;
    while ( 1 )
    {
      v3 = 1846 * v2;
      if ( byte_10261DFA[v3] )
      {
        if ( a2 == byte_10261DFB[v3] )
          break;
      }
      if ( --v2 < 0 )
        return;
    }
    if ( v2 >= 0 )
    {
      v4 = 1846 * v2;
      v5 = 0;
      if ( byte_10261E07[v4] )
      {
        do
          sub_1003E580(byte_10261DFB[v4], *(__int16 *)((char *)&word_10261E46[18 * v5++] + v4));
        while ( v5 < (unsigned __int8)byte_10261E07[v4] );
      }
      sub_1003E580(byte_10261DFB[v4], 23);
      sub_1003E520(byte_10261DFB[v4]);
    }
  }
}
// 10261D65: using guessed type char byte_10261D65;
// 10261E46: using guessed type __int16 word_10261E46[];

//----- (1003E830) --------------------------------------------------------
char __thiscall sub_1003E830(void *this)
{
  char result; // al@7
  char *v2; // esi@2
  signed int v3; // edi@2

  if ( byte_10261D65 )
  {
    v2 = byte_10261DFB;
    v3 = 4;
    do
    {
      if ( *(v2 - 1) )
      {
        sub_1003E790((int)this, *v2);
        if ( !v2[11] )
          sub_1003E270(byte_100F2344[13 * (unsigned __int8)*v2], 0x25u, 0, byte_100F2346[13 * (unsigned __int8)*v2]);
      }
      v2 += 1846;
      --v3;
    }
    while ( v3 );
    result = sub_1003E270(0, 2u, 0, 0);
  }
  return result;
}
// 10261D65: using guessed type char byte_10261D65;

//----- (1003E890) --------------------------------------------------------
bool __fastcall sub_1003E890(int a1)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = a1;
  return sub_100253C0(0, 317, &v2) && !(v2 & 0x20000000) && v2 & 0x40000000;
}

//----- (1003E8D0) --------------------------------------------------------
void sub_1003E8D0()
{
  dword_10263AD4 = -15;
}
// 10263AD4: using guessed type int dword_10263AD4;

//----- (1003E8E0) --------------------------------------------------------
char __cdecl sub_1003E8E0(const void *a1)
{
  char result; // al@2
  __int16 v2; // [sp+4h] [bp-3Ch]@1
  char v3; // [sp+8h] [bp-38h]@2

  LOBYTE(v2) = 0;
  if ( a1 )
  {
    v2 = -32714;
    qmemcpy(&v3, a1, 0x34u);
    result = sub_100477B0((int)&v2);
  }
  return result;
}

//----- (1003E930) --------------------------------------------------------
signed int sub_1003E930()
{
  return sub_1007CC90((int)&off_100F25D0);
}
// 100F25D0: using guessed type char *off_100F25D0;

//----- (1003E940) --------------------------------------------------------
char __cdecl sub_1003E940(void *a1)
{
  char v1; // bl@1

  v1 = 0;
  if ( a1 && (unsigned __int8)sub_1003E930() == 1 && !sub_1007C110(37, 100) )
  {
    qmemcpy(a1, (const void *)(dword_10263AD4 + 8), 0x34u);
    v1 = 1;
    sub_1007C0F0(37);
  }
  return v1;
}
// 10263AD4: using guessed type int dword_10263AD4;

//----- (1003E990) --------------------------------------------------------
bool sub_1003E990()
{
  char v0; // bl@1
  unsigned int v2; // [sp+4h] [bp-4h]@1

  v0 = sub_10042DC0((char *)&v2);
  return (unsigned __int8)sub_1003E930() && v0 && v2 < *(_DWORD *)(dword_10263AD4 + 60) + 18;
}
// 10263AD4: using guessed type int dword_10263AD4;

//----- (1003E9D0) --------------------------------------------------------
signed int sub_1003E9D0()
{
  signed int result; // eax@3

  if ( (unsigned __int8)byte_10263AD8 > 2u )
    sub_10042930("..\\lib\\adl\\iop_ap_intf.c", 958, 0, 0);
  result = (unsigned __int8)byte_10263AD8;
  if ( (unsigned __int8)byte_10263AD8 >= 2u )
    result = 2;
  byte_10263AD8 = result;
  return result;
}
// 10263AD8: using guessed type char byte_10263AD8;

//----- (1003EA10) --------------------------------------------------------
char __thiscall sub_1003EA10(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1007C4B0(3190, (int)&v2 + 3, 1);
  return BYTE3(v2);
}

//----- (1003EA30) --------------------------------------------------------
char __thiscall sub_1003EA30(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_1007C650(3189, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1003EA60) --------------------------------------------------------
char __cdecl sub_1003EA60(char a1)
{
  char result; // al@2
  char v2; // [sp+2h] [bp-2h]@1
  char v3; // [sp+3h] [bp-1h]@1

  v3 = 1;
  v2 = 1;
  if ( a1 )
  {
    sub_1007C470(9420, &v2, 1, &v3);
    result = v2;
  }
  else
  {
    sub_1007C470(9419, &v2, 1, &v3);
    result = v2;
  }
  return result;
}

//----- (1003EAB0) --------------------------------------------------------
int sub_1003EAB0()
{
  int v1; // [sp+0h] [bp-8h]@1
  int v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  v1 = 0;
  sub_1007C650(2017, &v1, 4, &v2);
  return v1;
}

//----- (1003EAE0) --------------------------------------------------------
char sub_1003EAE0()
{
  char v1; // [sp+2h] [bp-2h]@1
  char v2; // [sp+3h] [bp-1h]@1

  v2 = 0;
  v1 = 0;
  sub_1007C470(9155, &v1, 1, &v2);
  return v1;
}

//----- (1003EB10) --------------------------------------------------------
char __thiscall sub_1003EB10(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1007D180(78, (_BYTE *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1003EB30) --------------------------------------------------------
char __thiscall sub_1003EB30(void *this)
{
  char result; // al@3
  unsigned int v2; // [sp-2h] [bp-4h]@1

  v2 = (unsigned int)this;
  if ( sub_100253C0(1, 43, (char *)&v2 + 3) && !sub_1004B820((unsigned __int8 *)&v2 + 3) )
    result = BYTE3(v2);
  else
    result = 0;
  return result;
}

//----- (1003EB70) --------------------------------------------------------
BOOL __cdecl sub_1003EB70(void *a1)
{
  float v2; // [sp+0h] [bp-Ch]@1
  int v3; // [sp+4h] [bp-8h]@1

  v2 = 9.8999998e24;
  v3 = 0;
  return sub_1007C650(9174, a1, 8, &v2) == 0;
}

//----- (1003EBC0) --------------------------------------------------------
char __thiscall sub_1003EBC0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_1007C650(9862, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1003EBF0) --------------------------------------------------------
BOOL __cdecl sub_1003EBF0(void *a1)
{
  float v2; // [sp+0h] [bp-10h]@1
  float v3; // [sp+4h] [bp-Ch]@1
  float v4; // [sp+8h] [bp-8h]@1
  float v5; // [sp+Ch] [bp-4h]@1

  v4 = *(float *)(dword_10337080 + 30396);
  v5 = *(float *)(dword_10337080 + 30400);
  v2 = *(float *)(dword_10337080 + 30404);
  v3 = *(float *)(dword_10337080 + 30408);
  return sub_1007C650(9864, a1, 16, &v2) == 0;
}
// 10337080: using guessed type int dword_10337080;

//----- (1003EC40) --------------------------------------------------------
char __thiscall sub_1003EC40(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 2;
  sub_1007C650(9860, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1003EC70) --------------------------------------------------------
BOOL __cdecl sub_1003EC70(void *a1)
{
  float v2; // [sp+0h] [bp-Ch]@1
  int v3; // [sp+4h] [bp-8h]@1

  v2 = 0.0;
  v3 = 0;
  v2 = *(float *)(dword_10337080 + 30400);
  return sub_1007C650(2157, a1, 8, &v2) == 0;
}
// 10337080: using guessed type int dword_10337080;

//----- (1003ECD0) --------------------------------------------------------
char sub_1003ECD0()
{
  char v1; // [sp+2h] [bp-2h]@1
  char v2; // [sp+3h] [bp-1h]@1

  v1 = 0;
  v2 = 0;
  sub_1007C470(6888, &v1, 1, &v2);
  return v1;
}

//----- (1003ED00) --------------------------------------------------------
int __cdecl sub_1003ED00(int a1)
{
  char v1; // cl@3
  char v2; // al@6
  int result; // eax@12

  result = 0;
  if ( !*(_BYTE *)a1 )
  {
    if ( *(_BYTE *)(a1 + 34) )
    {
      v1 = *(_BYTE *)(a1 + 7);
      if ( v1 == 3 || v1 == 4 || v1 == 13 )
      {
        v2 = *(_BYTE *)(a1 + 8);
        if ( !v2 || v2 == 1 || v2 == 7 || v2 == 8 || v2 == 9 || v2 == 10 )
          result = 1;
      }
    }
  }
  return result;
}

//----- (1003ED50) --------------------------------------------------------
char sub_1003ED50()
{
  char result; // al@1

  byte_10263AD8 = 2;
  result = sub_100471F0(4);
  if ( result )
  {
    byte_10263AD8 = 0;
  }
  else
  {
    result = sub_100471F0(7);
    if ( result )
      byte_10263AD8 = 1;
  }
  return result;
}
// 10263AD8: using guessed type char byte_10263AD8;

//----- (1003ED90) --------------------------------------------------------
char sub_1003ED90()
{
  char result; // al@1
  void *v1; // ecx@1

  result = sub_1003ECD0();
  if ( result )
  {
    result = sub_1003EB30(v1);
    if ( result == 1 )
    {
      if ( !sub_10045FC0(1) && !sub_10045FC0(4) && sub_10045FC0(2) )
        sub_10064260(2);
      result = sub_10045FC0(1);
      if ( !result )
      {
        result = sub_10045FC0(4);
        if ( result )
        {
          result = sub_10045250(4);
          if ( result )
          {
            result = sub_10045FC0(2);
            if ( result )
              result = sub_10064260(2);
          }
        }
      }
    }
    else if ( result == 2 )
    {
      if ( !sub_10045FC0(2) && !sub_10045FC0(4) && sub_10045FC0(1) )
        sub_10064260(1);
      result = sub_10045FC0(2);
      if ( !result )
      {
        result = sub_10045FC0(4);
        if ( result )
        {
          result = sub_10045250(4);
          if ( result != 1 )
          {
            result = sub_10045FC0(1);
            if ( result )
              result = sub_10064260(1);
          }
        }
      }
    }
  }
  return result;
}

//----- (1003EEB0) --------------------------------------------------------
int __cdecl sub_1003EEB0(float a1, int a2, char a3)
{
  double v3; // st7@2
  double v4; // st7@4
  float v5; // ST28_4@6
  double v6; // st7@6
  float v7; // ST24_4@8
  unsigned int v8; // eax@10
  int *v9; // ecx@10
  char *v10; // edx@10
  int v11; // esi@14
  int v12; // eax@15
  _BYTE *v13; // ecx@15
  _BYTE *v14; // edx@15
  int v15; // eax@17
  _BYTE *v16; // ecx@17
  _BYTE *v17; // edx@17
  _BYTE *v18; // ecx@19
  _BYTE *v19; // edx@19
  int result; // eax@21
  float v21; // [sp+0h] [bp-2Ch]@2
  float v22; // [sp+4h] [bp-28h]@4
  float v23; // [sp+8h] [bp-24h]@1
  float v24; // [sp+Ch] [bp-20h]@1
  float v25; // [sp+10h] [bp-1Ch]@1
  float v26; // [sp+14h] [bp-18h]@1
  float v27; // [sp+18h] [bp-14h]@1
  int v28; // [sp+1Ch] [bp-10h]@1
  char v29; // [sp+20h] [bp-Ch]@1

  v27 = a1;
  v28 = a2;
  sub_1003EC70(&v29);
  v23 = 0.0;
  v24 = 0.0;
  v25 = 0.0;
  v26 = 0.0;
  sub_1003EBF0(&v23);
  if ( (_BYTE)v28 )
  {
    v21 = v23;
    v3 = v24;
  }
  else
  {
    v21 = v25;
    v3 = v26;
  }
  v22 = v3;
  v4 = v27;
  if ( v22 >= (double)v27 )
    v4 = v22;
  v5 = v4;
  v6 = v5;
  if ( v21 <= (double)v5 )
    v6 = v21;
  v7 = v6;
  v27 = v7;
  if ( a3 )
  {
    sub_10024E60(1, 1414, &v27, 0, 8, 1);
    sub_10025010(1, 1414, 0xFFFFFFF);
  }
  v8 = 8;
  v9 = (int *)&v27;
  v10 = &v29;
  do
  {
    if ( *(_DWORD *)v10 != *v9 )
      goto LABEL_14;
    v8 -= 4;
    ++v9;
    v10 += 4;
  }
  while ( v8 >= 4 );
  if ( !v8 )
  {
LABEL_23:
    result = 0;
    goto LABEL_24;
  }
LABEL_14:
  v11 = (unsigned __int8)*v10 - *(_BYTE *)v9;
  if ( (unsigned __int8)*v10 == *(_BYTE *)v9 )
  {
    v12 = v8 - 1;
    v13 = (char *)v9 + 1;
    v14 = v10 + 1;
    if ( !v12 )
      goto LABEL_23;
    v11 = *v14 - *v13;
    if ( *v14 == *v13 )
    {
      v15 = v12 - 1;
      v16 = v13 + 1;
      v17 = v14 + 1;
      if ( !v15 )
        goto LABEL_23;
      v11 = *v17 - *v16;
      if ( *v17 == *v16 )
      {
        v18 = v16 + 1;
        v19 = v17 + 1;
        if ( v15 == 1 )
          goto LABEL_23;
        v11 = *v19 - *v18;
        if ( *v19 == *v18 )
          goto LABEL_23;
      }
    }
  }
  result = 1;
  if ( v11 <= 0 )
    result = -1;
LABEL_24:
  if ( result )
    result = sub_1007C500(2157, (int)&v27, 8);
  return result;
}

//----- (1003F040) --------------------------------------------------------
double __cdecl sub_1003F040(char a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  void *v3; // ecx@1
  char v5; // [sp+4h] [bp-Ch]@2
  float v6; // [sp+8h] [bp-8h]@2

  v2 = sub_10045280(v1);
  if ( sub_1003EA10(v3) )
    goto LABEL_2;
  if ( a1 )
  {
    if ( v2 )
    {
      sub_1007C4B0(2015, (int)&v5, 12);
      return v6;
    }
    sub_1007C4B0(2101, (int)&v5, 12);
  }
  else
  {
    if ( !v2 )
    {
LABEL_2:
      sub_1007C4B0(2015, (int)&v5, 12);
      return v6;
    }
    sub_1007C4B0(2101, (int)&v5, 12);
  }
  return v6;
}

//----- (1003F0C0) --------------------------------------------------------
char __cdecl sub_1003F0C0(signed int a1, char a2)
{
  void *v2; // ecx@0
  char result; // al@1
  char v4; // bl@2
  int v5; // eax@2
  int v6; // esi@6
  void *v7; // [sp-2h] [bp-4h]@1

  v7 = v2;
  result = a1;
  BYTE3(v7) = 5;
  if ( (_BYTE)a1 )
  {
    v4 = ((_BYTE)a1 == 2) + 3;
    LOBYTE(a1) = ((_BYTE)a1 == 2) + 3;
    v5 = sub_1004AEF0(a1, 1);
    if ( sub_10048450(v5) == 1 )
      result = (v4 != 3) + 3;
    else
      result = (v4 != 3) + 1;
  }
  BYTE3(v7) = result;
  if ( a2 )
  {
    v6 = 27 - (sub_100429D0(v2) != 2);
    sub_10024E60(1, v6, (char *)&v7 + 3, 0, 1, 1);
    sub_10025010(1, v6, 0xFFFFFFF);
    result = BYTE3(v7);
  }
  return result;
}

//----- (1003F150) --------------------------------------------------------
int __cdecl sub_1003F150(unsigned __int8 a1)
{
  void *v1; // ecx@0

  return dword_100F3458[(unsigned __int8)sub_10045280(v1) + 2 * a1];
}
// 100F3458: using guessed type int dword_100F3458[];

//----- (1003F170) --------------------------------------------------------
int __cdecl sub_1003F170(unsigned __int8 a1)
{
  void *v1; // ecx@0

  return dword_100F3458[(sub_10045280(v1) != 1) + 2 * a1];
}
// 100F3458: using guessed type int dword_100F3458[];

//----- (1003F190) --------------------------------------------------------
double __cdecl sub_1003F190(float a1)
{
  double result; // st7@1
  double v2; // st6@3
  float v3; // [sp+4h] [bp+4h]@4

  result = a1;
  if ( (LODWORD(a1) & 0x7F800000) == 2139095040 )
  {
    result = (float)0.0;
  }
  else
  {
    v2 = -304.79999;
    if ( result <= -304.79999 || (v2 = 45720.0, result >= 45720.0) )
    {
      v3 = v2;
      result = v3;
    }
  }
  return result;
}

//----- (1003F1F0) --------------------------------------------------------
bool __usercall sub_1003F1F0@<al>(int a1@<eax>)
{
  signed int v1; // eax@17
  bool result; // al@19

  result = 0;
  if ( *(_BYTE *)(a1 + 2) < 3u
    && *(_BYTE *)(a1 + 10) < 3u
    && *(_BYTE *)a1 < 8u
    && *(_BYTE *)(a1 + 1) < 0xBu
    && *(_BYTE *)(a1 + 3) < 0xFu
    && *(_BYTE *)(a1 + 4) < 0xDu
    && *(_BYTE *)(a1 + 5) < 6u
    && *(_BYTE *)(a1 + 24) < 0xDu
    && *(_BYTE *)(a1 + 6) < 7u
    && *(_BYTE *)(a1 + 25) < 0xDu
    && *(_BYTE *)(a1 + 7) < 0xEu
    && *(_BYTE *)(a1 + 8) < 0xDu
    && *(_BYTE *)(a1 + 9) < 8u
    && *(_BYTE *)(a1 + 26) < 0xDu
    && *(_BYTE *)(a1 + 11) < 0x13u
    && *(_BYTE *)(a1 + 12) < 0xDu )
  {
    v1 = *(_DWORD *)(a1 + 20);
    if ( v1 >= 0 && v1 <= 357913941 )
      result = 1;
  }
  return result;
}

//----- (1003F260) --------------------------------------------------------
char __cdecl sub_1003F260(char *a1)
{
  char *v1; // edi@1
  char v2; // bl@1
  signed int v3; // ebp@1
  char *v4; // esi@1
  char v5; // al@2
  bool v6; // al@4
  char result; // al@13
  char v8; // dh@15
  bool v9; // al@16
  bool v10; // bl@20
  void *v11; // ecx@22
  char v12; // al@23
  int v13; // eax@23
  __int16 v14; // [sp+10h] [bp-88h]@1
  int v15; // [sp+14h] [bp-84h]@1
  char *v16; // [sp+18h] [bp-80h]@1
  char v17; // [sp+1Ch] [bp-7Ch]@27
  char v18; // [sp+20h] [bp-78h]@16
  char v19; // [sp+3Eh] [bp-5Ah]@29
  char v20; // [sp+58h] [bp-40h]@1
  char v21; // [sp+5Ch] [bp-3Ch]@19
  char v22; // [sp+7Ah] [bp-1Eh]@31

  v16 = a1;
  v15 = 3342386;
  v1 = 0;
  v2 = sub_1003E9D0();
  v14 = 0;
  v3 = 1;
  v4 = &v20;
  do
  {
    v5 = sub_100253C0(1, *((_WORD *)&v15 + v3), v4);
    *((_BYTE *)&v14 + v3) = v5;
    v6 = v5 && !sub_1004DBF0((unsigned __int8 *)v4);
    *((_BYTE *)&v14 + v3) = v6;
    if ( v6 && *v4 == v2 )
      v1 = v4;
    --v3;
    v4 -= 60;
  }
  while ( v3 >= 0 );
  if ( !v1 )
    return 0;
  if ( v2 )
  {
    if ( v2 != 1 )
      return 0;
    goto LABEL_34;
  }
  v8 = HIBYTE(v14);
  if ( !(_BYTE)v14 || (v9 = sub_1003F1F0((int)&v18), LOBYTE(v14) = 1, !v9) )
    LOBYTE(v14) = 0;
  v10 = v8 && sub_1003F1F0((int)&v21);
  if ( sub_1003ECD0() )
  {
    v12 = sub_10045280(v11);
    LOBYTE(v15) = v12;
    v13 = (unsigned __int8)sub_1003EA60(v12) - 1;
    if ( v13 )
    {
      if ( v13 != 1 )
        return 0;
      goto LABEL_32;
    }
    if ( !(_BYTE)v14 )
      return 0;
LABEL_27:
    result = 1;
    qmemcpy(v16, &v17, 0x3Cu);
    return result;
  }
  if ( (_BYTE)v14 && (v19 || !v10 || !v22) )
    goto LABEL_27;
LABEL_32:
  if ( !v10 )
    return 0;
  v1 = &v20;
LABEL_34:
  result = 1;
  qmemcpy(v16, v1, 0x3Cu);
  return result;
}

//----- (1003F3E0) --------------------------------------------------------
double sub_1003F3E0()
{
  double result; // st7@1
  float v1; // [sp+4h] [bp-8h]@1
  float v2; // [sp+8h] [bp-4h]@1

  v2 = 9.8999998e24;
  sub_1007C470(9154, &v1, 4, &v2);
  result = v1;
  if ( v1 != 9.8999998e24 )
  {
    v1 = sub_1003F190(v1);
    result = v1;
  }
  return result;
}

//----- (1003F440) --------------------------------------------------------
void sub_1003F440()
{
  sub_1003F040(0);
}

//----- (1003F450) --------------------------------------------------------
char sub_1003F450()
{
  int v0; // eax@1
  char v2; // [sp+2h] [bp-2h]@1
  char v3; // [sp+3h] [bp-1h]@1

  v2 = 0;
  v3 = 0;
  v0 = sub_1003F150(1u);
  sub_1007C470(v0, &v2, 1, &v3);
  return v2;
}

//----- (1003F480) --------------------------------------------------------
char __fastcall sub_1003F480(int a1)
{
  int v1; // eax@1
  char result; // al@1
  int v3; // [sp-2h] [bp-4h]@1

  v3 = a1;
  HIWORD(v3) = 0;
  v1 = sub_1003F150(0);
  sub_1007C470(v1, (char *)&v3 + 2, 1, (char *)&v3 + 3);
  result = BYTE2(v3);
  if ( BYTE2(v3) >= 3u )
    result = 0;
  return result;
}

//----- (1003F4C0) --------------------------------------------------------
char __fastcall sub_1003F4C0(int a1)
{
  int v1; // eax@1
  char result; // al@1
  int v3; // [sp-2h] [bp-4h]@1

  v3 = a1;
  HIWORD(v3) = 0;
  v1 = sub_1003F170(0);
  sub_1007C470(v1, (char *)&v3 + 2, 1, (char *)&v3 + 3);
  result = BYTE2(v3);
  if ( BYTE2(v3) >= 3u )
    result = 0;
  return result;
}

//----- (1003F500) --------------------------------------------------------
int __cdecl sub_1003F500(int a1)
{
  int v1; // edx@1
  char v2; // al@2
  int result; // eax@5

  result = 0;
  if ( (unsigned __int8)sub_1003ED00(a1) )
  {
    v2 = *(_BYTE *)(v1 + 15);
    if ( v2 == 7 || v2 == 17 || v2 == 18 )
      result = 1;
  }
  return result;
}

//----- (1003F530) --------------------------------------------------------
int __usercall sub_1003F530@<eax>(void *a1@<ecx>, int a2@<edi>, int a3@<esi>, unsigned __int8 a4)
{
  char v4; // bl@1
  int v5; // eax@1
  int result; // eax@1
  int v7; // eax@2

  v4 = sub_1003EA30(a1);
  v5 = sub_1003F150(a4);
  result = sub_1007C500(v5, a2, a3);
  if ( v4 )
  {
    v7 = sub_1003F170(a4);
    result = sub_1007C500(v7, a2, a3);
  }
  return result;
}

//----- (1003F570) --------------------------------------------------------
int __thiscall sub_1003F570(void *this)
{
  int v1; // eax@1
  int v2; // eax@2
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v1 = (unsigned __int8)sub_1003F480((int)this);
  if ( (_BYTE)v1 )
  {
    v2 = v1 - 1;
    if ( !v2 )
    {
      sub_1007C650(2064, &v4, 4, &v5);
      return v4;
    }
    if ( v2 == 1 )
    {
      sub_1007C650(2065, &v4, 4, &v5);
      return v4;
    }
  }
  else
  {
    sub_1007C650(2016, &v4, 4, &v5);
  }
  return v4;
}

//----- (1003F600) --------------------------------------------------------
char __cdecl sub_1003F600(signed int a1, char a2)
{
  void *v2; // ecx@0
  char result; // al@1
  void *v4; // ecx@3

  result = a1;
  if ( (unsigned __int8)a1 < 3u || !(_BYTE)a1 )
  {
    sub_1003F530(v2, (int)&a1, 1, 0);
    sub_1003F530(v4, (int)&a2, 1, 1u);
    result = sub_1003F0C0(a1, 1);
  }
  return result;
}

//----- (1003F640) --------------------------------------------------------
void sub_1003F640()
{
  dword_10337084 = -15;
}
// 10337084: using guessed type int dword_10337084;

//----- (1003F650) --------------------------------------------------------
char __cdecl sub_1003F650(unsigned __int8 a1)
{
  void *v1; // ecx@0
  char v2; // al@1
  int v3; // eax@1
  char result; // al@2
  char v5[68]; // [sp+0h] [bp-48h]@1

  v2 = sub_10045280(v1);
  v3 = sub_100450D0(v2);
  if ( sub_1007C3B0(v3, (int)v5, 67) )
    result = 0;
  else
    result = v5[a1];
  return result;
}
// 1003F650: using guessed type char var_48[68];

//----- (1003F6B0) --------------------------------------------------------
signed int sub_1003F6B0()
{
  return sub_1007CC90((int)&off_100F34C4);
}
// 100F34C4: using guessed type char *off_100F34C4;

//----- (1003F6C0) --------------------------------------------------------
char __usercall sub_1003F6C0@<al>(unsigned __int8 a1@<al>, char a2, void *a3)
{
  unsigned __int8 v3; // bl@1
  char result; // al@7

  v3 = a1;
  if ( (unsigned __int8)(a1 - 53) > 0xDu
    || (unsigned __int8)a2 >= 3u
    || !(unsigned __int8)sub_1003F6B0()
    || sub_1007C110(33, 10) )
  {
    sub_10042930("..\\lib\\adl\\iop_data.c", 366, 0, 0);
    result = 0;
  }
  else if ( (unsigned int)(sub_1007C040()
                         - *(_DWORD *)(dword_10337084 + 4 * (v3 - 33 + (unsigned __int8)a2 + 2 * (v3 - 33)))) <= 0x258
         && *(_BYTE *)(v3 + (unsigned __int8)a2 + 2 * v3 + dword_10337084 + 37) )
  {
    memcpy(
      a3,
      (const void *)(dword_10337084 + 4 * (v3 - 53 + (unsigned __int8)a2 + 2 * (v3 - 53))),
      *(_WORD *)(dword_10337084 + 2 * v3 + 62));
    sub_1007C0F0(33);
    result = 1;
  }
  else
  {
    sub_1007C0F0(33);
    result = 0;
  }
  return result;
}
// 10337084: using guessed type int dword_10337084;

//----- (1003F7A0) --------------------------------------------------------
char __cdecl sub_1003F7A0(int a1, char a2, void *a3)
{
  char result; // al@1
  int v4; // eax@4
  int v5; // esi@6
  int v6; // edi@7

  result = 0;
  if ( (unsigned __int8)a1 < 0x43u && (unsigned __int8)a2 < 3u )
  {
    if ( (unsigned __int8)a1 > 0x34u )
    {
      result = sub_1003F6C0(a1, a2, a3);
    }
    else
    {
      v4 = sub_1004ECA0(a1);
      if ( v4
        && (v5 = v4 + 4 * (unsigned __int8)a2, *(_BYTE *)v5 < 7)
        && (v6 = *(_WORD *)(v5 + 2), (unsigned __int16)v6 < (unsigned __int16)sub_100246D0(*(_BYTE *)v5)) )
      {
        result = sub_100253C0(*(_BYTE *)v5, v6, a3);
      }
      else
      {
        result = 0;
      }
    }
  }
  return result;
}
// 1004ECA0: using guessed type _DWORD __cdecl sub_1004ECA0(char);

//----- (1003F820) --------------------------------------------------------
char __cdecl sub_1003F820(int a1, void *a2)
{
  char v2; // al@1

  v2 = sub_1003F650(a1);
  return sub_1003F7A0(a1, v2, a2);
}

//----- (1003F840) --------------------------------------------------------
char __cdecl sub_1003F840(int a1, void *a2)
{
  char result; // al@1
  unsigned __int8 v3; // dl@1

  memset(a2, 0, 0x48u);
  result = 0;
  v3 = 0;
  do
  {
    if ( result )
      break;
    if ( a1 & *(_DWORD *)(dword_10337080 + 72 * v3 + 1704) )
    {
      qmemcpy(a2, (const void *)(dword_10337080 + 72 * v3 + 1660), 0x48u);
      result = 1;
    }
    ++v3;
  }
  while ( v3 < 0x1Eu );
  return result;
}
// 10337080: using guessed type int dword_10337080;

//----- (1003F8A0) --------------------------------------------------------
int __cdecl sub_1003F8A0(char *a1, char *a2)
{
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  char v4; // al@2
  int result; // eax@4

  v2 = strstr(a1, a2);
  v3 = strlen(a2);
  result = 0;
  if ( v2 )
  {
    v4 = v2[v3];
    if ( !v4 || v4 == 44 )
      result = 1;
  }
  return result;
}

//----- (1003F8E0) --------------------------------------------------------
void *__usercall sub_1003F8E0@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>)
{
  void *result; // eax@1
  int v4; // [sp+0h] [bp-Ch]@0
  int v5; // [sp+4h] [bp-8h]@0
  int v6; // [sp+8h] [bp-4h]@0

  result = (void *)sub_1007C3B0(v4, v5, v6);
  if ( a2 == 6011 )
  {
    if ( result || *(_BYTE *)a3 > 0x3Fu )
    {
      *(_BYTE *)a3 = 63;
      result = (void *)sub_1007C580(6011, (int)a3, a1);
    }
  }
  else if ( result )
  {
    result = memset(a3, 204, a1);
  }
  return result;
}

//----- (1003F930) --------------------------------------------------------
signed int sub_1003F930()
{
  int v0; // edi@5
  void *v1; // esi@5
  signed int v2; // ebp@5
  signed int result; // eax@7
  char v4; // [sp+13h] [bp-1h]@1

  dword_10337080 = 0;
  v4 = 0;
  sub_1007D180(94, &v4);
  if ( v4 == 3 )
  {
    v4 = 1;
    sub_1007C500(3201, (int)&v4, 1);
    sub_1007D1B0(94, (int)&v4);
  }
  else if ( v4 == 2 )
  {
    v4 = 0;
    sub_1007C500(3201, (int)&v4, 1);
    sub_1007D1B0(94, (int)&v4);
  }
  sub_1003F8E0(1u, 6011, &unk_10263AE0);
  sub_1003F8E0(0x16u, 6194, &unk_10263AE1);
  sub_1003F8E0(1u, 6012, &unk_10263AF7);
  sub_1003F8E0(1u, 6013, &unk_10263AF8);
  sub_1003F8E0(1u, 6014, &unk_10263AF9);
  sub_1003F8E0(1u, 6015, &unk_10263AFA);
  sub_1003F8E0(4u, 6078, &unk_10263AFC);
  sub_1003F8E0(4u, 6104, &unk_10263B00);
  sub_1003F8E0(0x20u, 6016, &unk_10263B04);
  sub_1003F8E0(0x20u, 6017, &unk_10263B24);
  sub_1003F8E0(0x20u, 6018, &unk_10263B44);
  sub_1003F8E0(0x20u, 6019, &unk_10263B64);
  sub_1003F8E0(0x20u, 6020, &unk_10263B84);
  sub_1003F8E0(0x20u, 6021, &unk_10263BA4);
  sub_1003F8E0(0x20u, 6022, &unk_10263BC4);
  sub_1003F8E0(0x20u, 6023, &unk_10263BE4);
  sub_1003F8E0(0x20u, 6024, &unk_10263C04);
  sub_1003F8E0(0x20u, 6025, &unk_10263C24);
  sub_1003F8E0(0x20u, 6026, &unk_10263C44);
  sub_1003F8E0(0x20u, 6027, &unk_10263C64);
  sub_1003F8E0(0x20u, 6028, &unk_10263C84);
  sub_1003F8E0(0x20u, 6029, &unk_10263CA4);
  sub_1003F8E0(0x20u, 6030, &unk_10263CC4);
  sub_1003F8E0(0x20u, 6031, &unk_10263CE4);
  sub_1003F8E0(0x20u, 6032, &unk_10263D04);
  sub_1003F8E0(0x20u, 6033, &unk_10263D24);
  sub_1003F8E0(0x20u, 6034, &unk_10263D44);
  sub_1003F8E0(0x20u, 6035, &unk_10263D64);
  sub_1003F8E0(0x20u, 6036, &unk_10263D84);
  sub_1003F8E0(0x20u, 6037, &unk_10263DA4);
  sub_1003F8E0(0x20u, 6038, &unk_10263DC4);
  sub_1003F8E0(0x20u, 6039, &unk_10263DE4);
  sub_1003F8E0(0x20u, 6040, &unk_10263E04);
  sub_1003F8E0(0x20u, 6041, &unk_10263E24);
  sub_1003F8E0(0x20u, 6042, &unk_10263E44);
  sub_1003F8E0(0x20u, 6043, &unk_10263E64);
  sub_1003F8E0(4u, 6044, &unk_10263E84);
  sub_1003F8E0(4u, 6045, &unk_10263E88);
  sub_1003F8E0(4u, 6046, &unk_10263E8C);
  sub_1003F8E0(4u, 6357, &unk_10263E90);
  sub_1003F8E0(4u, 6358, &unk_10263E94);
  sub_1003F8E0(4u, 6359, &unk_10263E98);
  sub_1003F8E0(0x20u, 6047, &unk_10263E9C);
  sub_1003F8E0(0x20u, 6048, &unk_10263EBC);
  sub_1003F8E0(0x20u, 6049, &unk_10263EDC);
  sub_1003F8E0(0x20u, 6050, &unk_10263EFC);
  sub_1003F8E0(0x20u, 6051, &unk_10263F1C);
  sub_1003F8E0(0x20u, 6052, &unk_10263F3C);
  sub_1003F8E0(0x20u, 6053, &unk_10263F5C);
  sub_1003F8E0(0x20u, 6054, &unk_10263F7C);
  sub_1003F8E0(1u, 6511, &unk_10263F9C);
  sub_1003F8E0(1u, 6522, &unk_10263F9D);
  sub_1003F8E0(1u, 6057, &unk_10263F9E);
  sub_1003F8E0(0x20u, 6075, &unk_10263FF0);
  sub_1003F8E0(0x20u, 6076, &unk_10264010);
  sub_1003F8E0(1u, 6077, &unk_10264030);
  sub_1003F8E0(4u, 6079, &unk_10264034);
  sub_1003F8E0(4u, 6080, &unk_10264038);
  sub_1003F8E0(0x20u, 6082, &unk_1026403C);
  sub_1003F8E0(0x20u, 6083, &unk_1026405C);
  sub_1003F8E0(0x20u, 6084, &unk_1026407C);
  sub_1003F8E0(0x20u, 6085, &unk_1026409C);
  sub_1003F8E0(0x20u, 6086, &unk_102640BC);
  sub_1003F8E0(0x20u, 6087, &unk_102640DC);
  sub_1003F8E0(0x20u, 6088, &unk_102640FC);
  sub_1003F8E0(0x20u, 6089, &unk_1026411C);
  sub_1003F8E0(0x20u, 6123, &unk_1026413C);
  sub_1003F8E0(0x48u, 6906, &unk_1026415C);
  sub_1003F8E0(0x48u, 6907, &unk_102641A4);
  sub_1003F8E0(0x48u, 6908, &unk_102641EC);
  sub_1003F8E0(0x48u, 6909, &unk_10264234);
  sub_1003F8E0(0x48u, 6910, &unk_1026427C);
  sub_1003F8E0(0x48u, 6911, &unk_102642C4);
  sub_1003F8E0(0x48u, 6912, &unk_1026430C);
  sub_1003F8E0(0x48u, 6913, &unk_10264354);
  sub_1003F8E0(0x48u, 6914, &unk_1026439C);
  sub_1003F8E0(0x48u, 6915, &unk_102643E4);
  sub_1003F8E0(0x48u, 6916, &unk_1026442C);
  sub_1003F8E0(0x48u, 6917, &unk_10264474);
  sub_1003F8E0(0x48u, 6918, &unk_102644BC);
  sub_1003F8E0(0x48u, 6919, &unk_10264504);
  sub_1003F8E0(0x48u, 6920, &unk_1026454C);
  sub_1003F8E0(0x48u, 6921, &unk_10264594);
  sub_1003F8E0(0x48u, 6922, &unk_102645DC);
  sub_1003F8E0(0x48u, 6923, &unk_10264624);
  sub_1003F8E0(0x48u, 6924, &unk_1026466C);
  sub_1003F8E0(0x48u, 6925, &unk_102646B4);
  sub_1003F8E0(0x48u, 6926, &unk_102646FC);
  sub_1003F8E0(0x48u, 6927, &unk_10264744);
  sub_1003F8E0(0x48u, 6928, &unk_1026478C);
  sub_1003F8E0(0x48u, 6929, &unk_102647D4);
  sub_1003F8E0(0x48u, 6930, &unk_1026481C);
  sub_1003F8E0(0x48u, 6931, &unk_10264864);
  sub_1003F8E0(0x48u, 6932, &unk_102648AC);
  sub_1003F8E0(0x48u, 6933, &unk_102648F4);
  sub_1003F8E0(0x48u, 6934, &unk_1026493C);
  sub_1003F8E0(0x48u, 6935, &unk_10264984);
  sub_1003F8E0(0x18u, 6163, &unk_102649CC);
  sub_1003F8E0(0x20u, 6164, &unk_102649E4);
  sub_1003F8E0(0x20u, 6165, &unk_10264A04);
  sub_1003F8E0(2u, 6166, &unk_10264A24);
  sub_1003F8E0(0xA4u, 40100, &unk_10264A28);
  sub_1003F8E0(0xA4u, 40101, &unk_10264ACC);
  sub_1003F8E0(0xA4u, 40102, &unk_10264B70);
  sub_1003F8E0(0xA4u, 40103, &unk_10264C14);
  sub_1003F8E0(0xA4u, 40104, &unk_10264CB8);
  sub_1003F8E0(0xA4u, 40105, &unk_10264D5C);
  sub_1003F8E0(0xA4u, 40106, &unk_10264E00);
  sub_1003F8E0(0xA4u, 40107, &unk_10264EA4);
  sub_1003F8E0(0xA4u, 40108, &unk_10264F48);
  sub_1003F8E0(0xA4u, 40109, &unk_10264FEC);
  sub_1003F8E0(0xA4u, 40110, &unk_10265090);
  sub_1003F8E0(0xA4u, 40111, &unk_10265134);
  sub_1003F8E0(0xA4u, 40112, &unk_102651D8);
  sub_1003F8E0(0xA4u, 40113, &unk_1026527C);
  sub_1003F8E0(0xA4u, 40114, &unk_10265320);
  sub_1003F8E0(0xA4u, 40115, &unk_102653C4);
  sub_1003F8E0(0xA4u, 40116, &unk_10265468);
  sub_1003F8E0(0xA4u, 40117, &unk_1026550C);
  sub_1003F8E0(0xA4u, 40118, &unk_102655B0);
  sub_1003F8E0(0xA4u, 40119, &unk_10265654);
  sub_1003F8E0(0xA4u, 40120, &unk_102656F8);
  sub_1003F8E0(0xA4u, 40121, &unk_1026579C);
  sub_1003F8E0(0xA4u, 40122, &unk_10265840);
  sub_1003F8E0(0xA4u, 40123, &unk_102658E4);
  sub_1003F8E0(0xA4u, 40124, &unk_10265988);
  sub_1003F8E0(0xA4u, 40125, &unk_10265A2C);
  sub_1003F8E0(0xA4u, 40126, &unk_10265AD0);
  sub_1003F8E0(0xA4u, 40127, &unk_10265B74);
  sub_1003F8E0(0xA4u, 40128, &unk_10265C18);
  sub_1003F8E0(0xA4u, 40129, &unk_10265CBC);
  sub_1003F8E0(0xA4u, 40130, &unk_10265D60);
  sub_1003F8E0(0xA4u, 40131, &unk_10265E04);
  sub_1003F8E0(0xA4u, 40132, &unk_10265EA8);
  sub_1003F8E0(0xA4u, 40133, &unk_10265F4C);
  sub_1003F8E0(0xA4u, 40134, &unk_10265FF0);
  sub_1003F8E0(0xA4u, 40135, &unk_10266094);
  sub_1003F8E0(0xA4u, 40136, &unk_10266138);
  sub_1003F8E0(0xA4u, 40137, &unk_102661DC);
  sub_1003F8E0(0xA4u, 40138, &unk_10266280);
  sub_1003F8E0(0xA4u, 40139, &unk_10266324);
  sub_1003F8E0(0xA4u, 40140, &unk_102663C8);
  sub_1003F8E0(0xA4u, 40141, &unk_1026646C);
  sub_1003F8E0(0xA4u, 40142, &unk_10266510);
  sub_1003F8E0(0xA4u, 40143, &unk_102665B4);
  sub_1003F8E0(0xA4u, 40144, &unk_10266658);
  sub_1003F8E0(0xA4u, 40145, &unk_102666FC);
  sub_1003F8E0(0xA4u, 40146, &unk_102667A0);
  sub_1003F8E0(0xA4u, 40147, &unk_10266844);
  sub_1003F8E0(0xA4u, 40148, &unk_102668E8);
  sub_1003F8E0(0xA4u, 40149, &unk_1026698C);
  sub_1003F8E0(0xA4u, 40150, &unk_10266A30);
  sub_1003F8E0(0xA4u, 40151, &unk_10266AD4);
  sub_1003F8E0(0xA4u, 40152, &unk_10266B78);
  sub_1003F8E0(0xA4u, 40153, &unk_10266C1C);
  sub_1003F8E0(0xA4u, 40154, &unk_10266CC0);
  sub_1003F8E0(0xA4u, 40155, &unk_10266D64);
  sub_1003F8E0(0xA4u, 40156, &unk_10266E08);
  sub_1003F8E0(0xA4u, 40157, &unk_10266EAC);
  sub_1003F8E0(0xA4u, 40158, &unk_10266F50);
  sub_1003F8E0(0xA4u, 40159, &unk_10266FF4);
  sub_1003F8E0(0xA4u, 40160, &unk_10267098);
  sub_1003F8E0(0xA4u, 40161, &unk_1026713C);
  sub_1003F8E0(0xA4u, 40162, &unk_102671E0);
  sub_1003F8E0(0xA4u, 40163, &unk_10267284);
  sub_1003F8E0(0xA4u, 40164, &unk_10267328);
  sub_1003F8E0(0xA4u, 40165, &unk_102673CC);
  sub_1003F8E0(0xA4u, 40166, &unk_10267470);
  sub_1003F8E0(0xA4u, 40167, &unk_10267514);
  sub_1003F8E0(0xA4u, 40168, &unk_102675B8);
  sub_1003F8E0(0xA4u, 40169, &unk_1026765C);
  sub_1003F8E0(0xA4u, 40170, &unk_10267700);
  sub_1003F8E0(0xA4u, 40171, &unk_102677A4);
  sub_1003F8E0(0xA4u, 40172, &unk_10267848);
  sub_1003F8E0(0xA4u, 40173, &unk_102678EC);
  sub_1003F8E0(0xA4u, 40174, &unk_10267990);
  sub_1003F8E0(0xA4u, 40175, &unk_10267A34);
  sub_1003F8E0(0xA4u, 40176, &unk_10267AD8);
  sub_1003F8E0(0xA4u, 40177, &unk_10267B7C);
  sub_1003F8E0(0xA4u, 40178, &unk_10267C20);
  sub_1003F8E0(0xA4u, 40179, &unk_10267CC4);
  sub_1003F8E0(0xA4u, 40180, &unk_10267D68);
  sub_1003F8E0(0xA4u, 40181, &unk_10267E0C);
  sub_1003F8E0(0xA4u, 40182, &unk_10267EB0);
  sub_1003F8E0(0xA4u, 40183, &unk_10267F54);
  sub_1003F8E0(0xA4u, 40184, &unk_10267FF8);
  sub_1003F8E0(0xA4u, 40185, &unk_1026809C);
  sub_1003F8E0(0xA4u, 40186, &unk_10268140);
  sub_1003F8E0(0xA4u, 40187, &unk_102681E4);
  sub_1003F8E0(0xA4u, 40188, &unk_10268288);
  sub_1003F8E0(0xA4u, 40189, &unk_1026832C);
  sub_1003F8E0(0xA4u, 40190, &unk_102683D0);
  sub_1003F8E0(0xA4u, 40191, &unk_10268474);
  sub_1003F8E0(0xA4u, 40192, &unk_10268518);
  sub_1003F8E0(0xA4u, 40193, &unk_102685BC);
  sub_1003F8E0(0xA4u, 40194, &unk_10268660);
  sub_1003F8E0(0xA4u, 40195, &unk_10268704);
  sub_1003F8E0(0xA4u, 40196, &unk_102687A8);
  sub_1003F8E0(0xA4u, 40197, &unk_1026884C);
  sub_1003F8E0(0xA4u, 40198, &unk_102688F0);
  sub_1003F8E0(0xA4u, 40199, &unk_10268994);
  sub_1003F8E0(0x20u, 6190, &unk_10268A38);
  sub_1003F8E0(0x20u, 6191, &unk_10268A58);
  sub_1003F8E0(0x20u, 6192, &unk_10268A78);
  sub_1003F8E0(0x20u, 6199, &unk_10268A98);
  sub_1003F8E0(0x28u, 6207, &unk_10268AB8);
  sub_1003F8E0(4u, 6231, &unk_102695D0);
  sub_1003F8E0(4u, 6232, &unk_102695D4);
  sub_1003F8E0(4u, 6233, &unk_102695D8);
  sub_1003F8E0(4u, 6234, &unk_102695DC);
  sub_1003F8E0(0x1Cu, 40000, &unk_10268AE0);
  sub_1003F8E0(0x1Cu, 40001, &unk_10268AFC);
  sub_1003F8E0(0x1Cu, 40002, &unk_10268B18);
  sub_1003F8E0(0x1Cu, 40003, &unk_10268B34);
  sub_1003F8E0(0x1Cu, 40004, &unk_10268B50);
  sub_1003F8E0(0x1Cu, 40005, &unk_10268B6C);
  sub_1003F8E0(0x1Cu, 40006, &unk_10268B88);
  sub_1003F8E0(0x1Cu, 40007, &unk_10268BA4);
  sub_1003F8E0(0x1Cu, 40008, &unk_10268BC0);
  sub_1003F8E0(0x1Cu, 40009, &unk_10268BDC);
  sub_1003F8E0(0x1Cu, 40010, &unk_10268BF8);
  sub_1003F8E0(0x1Cu, 40011, &unk_10268C14);
  sub_1003F8E0(0x1Cu, 40012, &unk_10268C30);
  sub_1003F8E0(0x1Cu, 40013, &unk_10268C4C);
  sub_1003F8E0(0x1Cu, 40014, &unk_10268C68);
  sub_1003F8E0(0x1Cu, 40015, &unk_10268C84);
  sub_1003F8E0(0x1Cu, 40016, &unk_10268CA0);
  sub_1003F8E0(0x1Cu, 40017, &unk_10268CBC);
  sub_1003F8E0(0x1Cu, 40018, &unk_10268CD8);
  sub_1003F8E0(0x1Cu, 40019, &unk_10268CF4);
  sub_1003F8E0(0x1Cu, 40020, &unk_10268D10);
  sub_1003F8E0(0x1Cu, 40021, &unk_10268D2C);
  sub_1003F8E0(0x1Cu, 40022, &unk_10268D48);
  sub_1003F8E0(0x1Cu, 40023, &unk_10268D64);
  sub_1003F8E0(0x1Cu, 40024, &unk_10268D80);
  sub_1003F8E0(0x1Cu, 40025, &unk_10268D9C);
  sub_1003F8E0(0x1Cu, 40026, &unk_10268DB8);
  sub_1003F8E0(0x1Cu, 40027, &unk_10268DD4);
  sub_1003F8E0(0x1Cu, 40028, &unk_10268DF0);
  sub_1003F8E0(0x1Cu, 40029, &unk_10268E0C);
  sub_1003F8E0(0x1Cu, 40030, &unk_10268E28);
  sub_1003F8E0(0x1Cu, 40031, &unk_10268E44);
  sub_1003F8E0(0x1Cu, 40032, &unk_10268E60);
  sub_1003F8E0(0x1Cu, 40033, &unk_10268E7C);
  sub_1003F8E0(0x1Cu, 40034, &unk_10268E98);
  sub_1003F8E0(0x1Cu, 40035, &unk_10268EB4);
  sub_1003F8E0(0x1Cu, 40036, &unk_10268ED0);
  sub_1003F8E0(0x1Cu, 40037, &unk_10268EEC);
  sub_1003F8E0(0x1Cu, 40038, &unk_10268F08);
  sub_1003F8E0(0x1Cu, 40039, &unk_10268F24);
  sub_1003F8E0(0x1Cu, 40040, &unk_10268F40);
  sub_1003F8E0(0x1Cu, 40041, &unk_10268F5C);
  sub_1003F8E0(0x1Cu, 40042, &unk_10268F78);
  sub_1003F8E0(0x1Cu, 40043, &unk_10268F94);
  sub_1003F8E0(0x1Cu, 40044, &unk_10268FB0);
  sub_1003F8E0(0x1Cu, 40045, &unk_10268FCC);
  sub_1003F8E0(0x1Cu, 40046, &unk_10268FE8);
  sub_1003F8E0(0x1Cu, 40047, &unk_10269004);
  sub_1003F8E0(0x1Cu, 40048, &unk_10269020);
  sub_1003F8E0(0x1Cu, 40049, &unk_1026903C);
  sub_1003F8E0(0x1Cu, 40050, &unk_10269058);
  sub_1003F8E0(0x1Cu, 40051, &unk_10269074);
  sub_1003F8E0(0x1Cu, 40052, &unk_10269090);
  sub_1003F8E0(0x1Cu, 40053, &unk_102690AC);
  sub_1003F8E0(0x1Cu, 40054, &unk_102690C8);
  sub_1003F8E0(0x1Cu, 40055, &unk_102690E4);
  sub_1003F8E0(0x1Cu, 40056, &unk_10269100);
  sub_1003F8E0(0x1Cu, 40057, &unk_1026911C);
  sub_1003F8E0(0x1Cu, 40058, &unk_10269138);
  sub_1003F8E0(0x1Cu, 40059, &unk_10269154);
  sub_1003F8E0(0x1Cu, 40060, &unk_10269170);
  sub_1003F8E0(0x1Cu, 40061, &unk_1026918C);
  sub_1003F8E0(0x1Cu, 40062, &unk_102691A8);
  sub_1003F8E0(0x1Cu, 40063, &unk_102691C4);
  sub_1003F8E0(0x1Cu, 40064, &unk_102691E0);
  sub_1003F8E0(0x1Cu, 40065, &unk_102691FC);
  sub_1003F8E0(0x1Cu, 40066, &unk_10269218);
  sub_1003F8E0(0x1Cu, 40067, &unk_10269234);
  sub_1003F8E0(0x1Cu, 40068, &unk_10269250);
  sub_1003F8E0(0x1Cu, 40069, &unk_1026926C);
  sub_1003F8E0(0x1Cu, 40070, &unk_10269288);
  sub_1003F8E0(0x1Cu, 40071, &unk_102692A4);
  sub_1003F8E0(0x1Cu, 40072, &unk_102692C0);
  sub_1003F8E0(0x1Cu, 40073, &unk_102692DC);
  sub_1003F8E0(0x1Cu, 40074, &unk_102692F8);
  sub_1003F8E0(0x1Cu, 40075, &unk_10269314);
  sub_1003F8E0(0x1Cu, 40076, &unk_10269330);
  sub_1003F8E0(0x1Cu, 40077, &unk_1026934C);
  sub_1003F8E0(0x1Cu, 40078, &unk_10269368);
  sub_1003F8E0(0x1Cu, 40079, &unk_10269384);
  sub_1003F8E0(0x1Cu, 40080, &unk_102693A0);
  sub_1003F8E0(0x1Cu, 40081, &unk_102693BC);
  sub_1003F8E0(0x1Cu, 40082, &unk_102693D8);
  sub_1003F8E0(0x1Cu, 40083, &unk_102693F4);
  sub_1003F8E0(0x1Cu, 40084, &unk_10269410);
  sub_1003F8E0(0x1Cu, 40085, &unk_1026942C);
  sub_1003F8E0(0x1Cu, 40086, &unk_10269448);
  sub_1003F8E0(0x1Cu, 40087, &unk_10269464);
  sub_1003F8E0(0x1Cu, 40088, &unk_10269480);
  sub_1003F8E0(0x1Cu, 40089, &unk_1026949C);
  sub_1003F8E0(0x1Cu, 40090, &unk_102694B8);
  sub_1003F8E0(0x1Cu, 40091, &unk_102694D4);
  sub_1003F8E0(0x1Cu, 40092, &unk_102694F0);
  sub_1003F8E0(0x1Cu, 40093, &unk_1026950C);
  sub_1003F8E0(0x1Cu, 40094, &unk_10269528);
  sub_1003F8E0(0x1Cu, 40095, &unk_10269544);
  sub_1003F8E0(0x1Cu, 40096, &unk_10269560);
  sub_1003F8E0(0x1Cu, 40097, &unk_1026957C);
  sub_1003F8E0(0x1Cu, 40098, &unk_10269598);
  sub_1003F8E0(0x1Cu, 40099, &unk_102695B4);
  sub_1003F8E0(4u, 6238, &unk_102695E0);
  sub_1003F8E0(4u, 6239, &unk_102695E4);
  sub_1003F8E0(4u, 6240, &unk_102695E8);
  sub_1003F8E0(4u, 6242, &unk_102695EC);
  sub_1003F8E0(4u, 6244, &unk_102695F0);
  sub_1003F8E0(4u, 6245, &unk_102695F4);
  sub_1003F8E0(4u, 6246, &unk_102695F8);
  sub_1003F8E0(4u, 6251, &unk_102695FC);
  sub_1003F8E0(4u, 6252, &unk_10269600);
  sub_1003F8E0(4u, 6253, &unk_10269604);
  sub_1003F8E0(4u, 6254, &unk_10269608);
  sub_1003F8E0(1u, 6255, &unk_1026960C);
  sub_1003F8E0(4u, 6256, &unk_10269610);
  sub_1003F8E0(4u, 6257, &unk_10269614);
  sub_1003F8E0(0xE2u, 6286, &unk_10269618);
  v0 = 18000;
  v1 = &unk_102696FC;
  v2 = 16;
  do
  {
    sub_1003F8E0(0x11Cu, v0, v1);
    v1 = (char *)v1 + 284;
    ++v0;
    --v2;
  }
  while ( v2 );
  sub_1003F8E0(4u, 6262, &unk_1026A8BC);
  sub_1003F8E0(0x28u, 6263, &unk_1026A8C0);
  sub_1003F8E0(0x28u, 6264, &unk_1026A8E8);
  sub_1003F8E0(0x40u, 6268, &unk_1026A910);
  sub_1003F8E0(4u, 6272, &unk_1026A9D0);
  sub_1003F8E0(4u, 6273, &unk_1026A9D4);
  sub_1003F8E0(1u, 6274, &unk_1026A9D8);
  sub_1003F8E0(2u, 6275, &unk_1026A9DA);
  sub_1003F8E0(1u, 6276, &unk_1026A9DC);
  sub_1003F8E0(1u, 6277, &unk_1026A9DD);
  sub_1003F8E0(1u, 6278, &unk_1026A9DE);
  sub_1003F8E0(0x40u, 6279, &unk_1026A9E0);
  sub_1003F8E0(0x28u, 6753, &unk_1026B895);
  sub_1003F8E0(0x30u, 6754, &unk_1026B8C0);
  sub_1003F8E0(0x28u, 6958, &unk_1026B8F0);
  sub_1003F8E0(0x80u, 6802, &unk_1026A950);
  sub_1003F8E0(1u, 6760, &unk_1026B918);
  sub_1003F8E0(0x10u, 6312, &unk_1026AD64);
  sub_1003F8E0(0x10u, 6313, &unk_1026AD74);
  sub_1003F8E0(0x10u, 6314, &unk_1026AD84);
  sub_1003F8E0(1u, 6307, &unk_1026AD94);
  sub_1003F8E0(1u, 6308, &unk_1026AD95);
  sub_1003F8E0(1u, 6309, &unk_1026AD96);
  sub_1003F8E0(4u, 6285, &unk_1026AD98);
  sub_1003F8E0(0xA8u, 6318, &unk_1026AD9C);
  sub_1003F8E0(4u, 6319, &unk_1026AE44);
  sub_1003F8E0(1u, 6350, &unk_1026AE48);
  sub_1003F8E0(0x50u, 6351, &unk_1026AE4C);
  sub_1003F8E0(4u, 6352, &unk_1026AE9C);
  sub_1003F8E0(4u, 6353, &unk_1026AEA0);
  sub_1003F8E0(0x54u, 6448, &unk_1026B0EC);
  sub_1003F8E0(0x54u, 6449, &unk_1026B140);
  sub_1003F8E0(8u, 6287, &unk_1026AA44);
  sub_1003F8E0(8u, 6288, &unk_1026AA4C);
  sub_1003F8E0(8u, 6289, &unk_1026AA54);
  sub_1003F8E0(8u, 6290, &unk_1026AA5C);
  sub_1003F8E0(8u, 6291, &unk_1026AA64);
  sub_1003F8E0(8u, 6292, &unk_1026AA6C);
  sub_1003F8E0(8u, 6293, &unk_1026AA74);
  sub_1003F8E0(8u, 6294, &unk_1026AA7C);
  sub_1003F8E0(8u, 6295, &unk_1026AA84);
  sub_1003F8E0(8u, 6296, &unk_1026AA8C);
  sub_1003F8E0(8u, 6297, &unk_1026AA94);
  sub_1003F8E0(8u, 6298, &unk_1026AA9C);
  sub_1003F8E0(8u, 6299, &unk_1026AAA4);
  sub_1003F8E0(8u, 6300, &unk_1026AAAC);
  sub_1003F8E0(8u, 6301, &unk_1026AAB4);
  sub_1003F8E0(8u, 6302, &unk_1026AABC);
  sub_1003F8E0(8u, 6303, &unk_1026AAC4);
  sub_1003F8E0(8u, 6304, &unk_1026AACC);
  sub_1003F8E0(8u, 6305, &unk_1026AAD4);
  sub_1003F8E0(8u, 6306, &unk_1026AADC);
  sub_1003F8E0(8u, 6409, &unk_1026AAE4);
  sub_1003F8E0(8u, 6410, &unk_1026AAEC);
  sub_1003F8E0(8u, 6411, &unk_1026AAF4);
  sub_1003F8E0(8u, 6412, &unk_1026AAFC);
  sub_1003F8E0(8u, 6413, &unk_1026AB04);
  sub_1003F8E0(8u, 6414, &unk_1026AB0C);
  sub_1003F8E0(8u, 6415, &unk_1026AB14);
  sub_1003F8E0(8u, 6416, &unk_1026AB1C);
  sub_1003F8E0(8u, 6417, &unk_1026AB24);
  sub_1003F8E0(8u, 6418, &unk_1026AB2C);
  sub_1003F8E0(8u, 6419, &unk_1026AB34);
  sub_1003F8E0(8u, 6420, &unk_1026AB3C);
  sub_1003F8E0(8u, 6421, &unk_1026AB44);
  sub_1003F8E0(8u, 6422, &unk_1026AB4C);
  sub_1003F8E0(8u, 6423, &unk_1026AB54);
  sub_1003F8E0(8u, 6424, &unk_1026AB5C);
  sub_1003F8E0(8u, 6425, &unk_1026AB64);
  sub_1003F8E0(8u, 6426, &unk_1026AB6C);
  sub_1003F8E0(8u, 6427, &unk_1026AB74);
  sub_1003F8E0(8u, 6428, &unk_1026AB7C);
  sub_1003F8E0(4u, 6429, &unk_1026B084);
  sub_1003F8E0(8u, 6430, &unk_1026B088);
  sub_1003F8E0(8u, 6431, &unk_1026B090);
  sub_1003F8E0(8u, 6432, &unk_1026B098);
  sub_1003F8E0(8u, 6433, &unk_1026B0A0);
  sub_1003F8E0(8u, 6434, &unk_1026B0A8);
  sub_1003F8E0(8u, 6435, &unk_1026B0B0);
  sub_1003F8E0(8u, 6436, &unk_1026B0B8);
  sub_1003F8E0(8u, 6437, &unk_1026B0C0);
  sub_1003F8E0(8u, 6438, &unk_1026B0C8);
  sub_1003F8E0(8u, 6439, &unk_1026B0D0);
  sub_1003F8E0(8u, 6440, &unk_1026B0D8);
  sub_1003F8E0(0xAu, 6519, &unk_1026B544);
  sub_1003F8E0(4u, 6442, &unk_1026B0E0);
  sub_1003F8E0(4u, 6443, &unk_1026B0E4);
  sub_1003F8E0(0xF0u, 6367, &unk_1026AEA4);
  sub_1003F8E0(0xF0u, 6368, &unk_1026AF94);
  sub_1003F8E0(1u, 6446, &unk_1026B0E8);
  sub_1003F8E0(6u, 6452, &unk_1026B194);
  sub_1003F8E0(4u, 6457, &unk_1026B19C);
  sub_1003F8E0(4u, 6458, &unk_1026B1A0);
  sub_1003F8E0(4u, 6459, &unk_1026B1A4);
  sub_1003F8E0(4u, 6460, &unk_1026B1A8);
  sub_1003F8E0(0x208u, 6515, &unk_1026B1AC);
  sub_1003F8E0(0x160u, 6516, &unk_1026B3B4);
  sub_1003F8E0(0x18u, 6517, &unk_1026B514);
  sub_1003F8E0(0x18u, 6518, &unk_1026B52C);
  sub_1003F8E0(1u, 6520, &unk_1026B54E);
  sub_1003F8E0(0x10u, 6521, &unk_1026B550);
  sub_1003F8E0(4u, 6523, &unk_1026B560);
  sub_1003F8E0(4u, 6524, &unk_1026B564);
  sub_1003F8E0(4u, 6525, &unk_1026B568);
  sub_1003F8E0(1u, 6526, &unk_1026B56C);
  sub_1003F8E0(1u, 6527, &unk_1026B56D);
  sub_1003F8E0(0x50u, 6528, &unk_1026B570);
  sub_1003F8E0(4u, 6529, &unk_1026B5C0);
  sub_1003F8E0(1u, 6530, &unk_1026B5C4);
  sub_1003F8E0(1u, 6531, &unk_1026B5C5);
  sub_1003F8E0(1u, 6532, &unk_1026B5C6);
  sub_1003F8E0(0x14u, 6533, &unk_1026B5C7);
  sub_1003F8E0(0xAu, 6883, &unk_1026BCE0);
  sub_1003F8E0(0xAu, 6884, &unk_1026BCEA);
  sub_1003F8E0(0xAu, 6885, &unk_1026BCF4);
  sub_1003F8E0(1u, 6664, &unk_1026B5DB);
  sub_1003F8E0(1u, 6666, &unk_1026B5DC);
  sub_1003F8E0(1u, 6667, &unk_1026B5DD);
  sub_1003F8E0(1u, 6668, &unk_1026B5DE);
  sub_1003F8E0(0xA0u, 6669, &unk_1026B5E0);
  sub_1003F8E0(2u, 6670, &unk_1026B6D0);
  sub_1003F8E0(4u, 6671, &unk_1026B6D4);
  sub_1003F8E0(4u, 6672, &unk_1026B6D8);
  sub_1003F8E0(4u, 6673, &unk_1026B6DC);
  sub_1003F8E0(4u, 6674, &unk_1026B6E0);
  sub_1003F8E0(4u, 6675, &unk_1026B6E4);
  sub_1003F8E0(4u, 6676, &unk_1026B6EC);
  sub_1003F8E0(4u, 6677, &unk_1026B6F4);
  sub_1003F8E0(4u, 6678, &unk_1026B6F8);
  sub_1003F8E0(1u, 6679, &unk_1026B6FC);
  sub_1003F8E0(0x140u, 6680, &unk_1026B700);
  sub_1003F8E0(4u, 6882, &unk_1026BCDC);
  sub_1003F8E0(0xCu, 6652, &unk_1026B840);
  sub_1003F8E0(0x48u, 6653, &unk_1026B84C);
  sub_1003F8E0(1u, 6688, &unk_1026B894);
  sub_1003F8E0(4u, 6771, &unk_1026B91C);
  sub_1003F8E0(4u, 6772, &unk_1026B920);
  sub_1003F8E0(8u, 6787, &unk_1026B924);
  sub_1003F8E0(1u, 6832, &unk_1026B954);
  sub_1003F8E0(1u, 6833, &unk_1026B955);
  sub_1003F8E0(1u, 6834, &unk_1026B956);
  sub_1003F8E0(4u, 6835, &unk_1026B958);
  sub_1003F8E0(4u, 6836, &unk_1026B95C);
  sub_1003F8E0(4u, 6837, &unk_1026B960);
  sub_1003F8E0(4u, 6838, &unk_1026B964);
  sub_1003F8E0(1u, 6839, &unk_1026B968);
  sub_1003F8E0(0x50u, 6840, &unk_1026B680);
  sub_1003F8E0(4u, 6841, &unk_1026B96C);
  sub_1003F8E0(4u, 6842, &unk_1026B970);
  sub_1003F8E0(4u, 6843, &unk_1026B974);
  sub_1003F8E0(1u, 6844, &unk_1026B978);
  sub_1003F8E0(0x360u, 6845, &unk_1026B97C);
  sub_1003F8E0(4u, 6846, &unk_1026B6E8);
  sub_1003F8E0(4u, 6847, &unk_1026B6F0);
  result = 1;
  dword_10337080 = (int)&unk_10263AE0;
  return result;
}
// 10337080: using guessed type int dword_10337080;

//----- (10041730) --------------------------------------------------------
int __cdecl sub_10041730(int a1)
{
  byte_103334EC = 0;
  return nullsub_1(a1);
}
// 103334EC: using guessed type char byte_103334EC;

//----- (10041740) --------------------------------------------------------
int sub_10041740()
{
  int result; // eax@1

  result = 0;
  dword_1026D4B0 = -15;
  dword_1033707C = 0;
  dword_10337070 = 0;
  dword_10337074 = 0;
  dword_10337078 = 0;
  return result;
}
// 1026D4B0: using guessed type int dword_1026D4B0;
// 10337070: using guessed type int dword_10337070;
// 10337074: using guessed type int dword_10337074;
// 1033707C: using guessed type int dword_1033707C;

//----- (10041770) --------------------------------------------------------
char sub_10041770()
{
  char v0; // bl@1
  signed int v1; // esi@2
  char result; // al@4

  v0 = sub_1007CC90((int)&off_100F6DC0);
  if ( v0 )
  {
    dword_1033707C = dword_1026D4B0;
    v1 = *(_BYTE *)(dword_1026D4B0 + 667) != 0 ? 1100 : 2000;
    if ( v1 + *(_DWORD *)(dword_1033707C + 36) < (unsigned int)sub_1007C040() )
      v0 = 0;
    dword_10337078 = (void *)(dword_1026D4B0 + 56116);
    result = v0;
    dword_10337070 = dword_1026D4B0 + 1516;
    dword_10337074 = dword_1026D4B0 + 20484;
  }
  else
  {
    dword_1033707C = 0;
    dword_10337070 = 0;
    dword_10337074 = 0;
    dword_10337078 = 0;
    result = 0;
  }
  return result;
}
// 100F6DC0: using guessed type char *off_100F6DC0;
// 1026D4B0: using guessed type int dword_1026D4B0;
// 10337070: using guessed type int dword_10337070;
// 10337074: using guessed type int dword_10337074;
// 1033707C: using guessed type int dword_1033707C;

//----- (10041810) --------------------------------------------------------
void sub_10041810()
{
  dword_10333D6C = -15;
}
// 10333D6C: using guessed type int dword_10333D6C;

//----- (10041820) --------------------------------------------------------
signed int sub_10041820()
{
  return sub_1007CC90((int)&off_100F6DEC);
}
// 100F6DEC: using guessed type char *off_100F6DEC;

//----- (10041830) --------------------------------------------------------
char __usercall sub_10041830@<al>(float *a1@<esi>)
{
  char result; // al@1
  int v2; // ecx@1
  __int16 v3; // dx@1
  double v4; // st7@4
  float v5; // ST08_4@6

  result = 0;
  *a1 = 9.9999996e24;
  v2 = dword_10333D6C;
  v3 = *(_WORD *)(dword_10333D6C + 1456);
  if ( v3 == 3 || v3 == 5 )
  {
    if ( *(_BYTE *)(dword_10333D6C + 1296) )
    {
      v4 = sub_100509F0(*(_DWORD *)(dword_10333D6C + 1292));
      v2 = dword_10333D6C;
    }
    else
    {
      v4 = 0.0;
    }
    v5 = v4;
    result = 1;
    *a1 = *(float *)(v2 + 1520) * v5 + *(float *)(v2 + 1468);
  }
  return result;
}
// 10333D6C: using guessed type int dword_10333D6C;

//----- (100418A0) --------------------------------------------------------
char __cdecl sub_100418A0(__int16 a1)
{
  void *v1; // ecx@0
  signed int v2; // esi@1
  int v3; // eax@6
  __int16 *v5; // [sp+4h] [bp-BCh]@6
  int v6; // [sp+8h] [bp-B8h]@6
  int v7; // [sp+Ch] [bp-B4h]@6
  int v8; // [sp+10h] [bp-B0h]@6
  int v9; // [sp+14h] [bp-ACh]@6
  __int16 v10; // [sp+18h] [bp-A8h]@1
  char v11; // [sp+1Ch] [bp-A4h]@5

  v10 = a1;
  v2 = 0;
  if ( (unsigned __int16)a1 != 32773 && (unsigned __int16)a1 != 32775 )
  {
    if ( (unsigned __int16)a1 == 32776 )
    {
      v2 = 16;
      memcpy_0(&v11, v1, 0x10u);
    }
    else
    {
      sub_10042930("..\\lib\\adl\\pvt_intf.c", 1894, 1, 0);
    }
  }
  v9 = 1;
  v5 = &v10;
  v6 = v2 + 4;
  v7 = 0;
  v8 = 200;
  v3 = sub_1007C1A0(44, (int)&v5);
  if ( v3 )
    LOBYTE(v3) = sub_10042930("..\\lib\\adl\\pvt_intf.c", 1927, 0, 0);
  return v3;
}

//----- (10041980) --------------------------------------------------------
signed int sub_10041980()
{
  char v0; // bl@1
  signed int result; // eax@3

  v0 = 1;
  if ( (unsigned __int8)sub_10041820() )
    v0 = *(_BYTE *)(dword_10333D6C + 1456);
  result = (unsigned __int8)v0;
  if ( (unsigned __int8)v0 >= 8u )
    result = 1;
  return result;
}
// 10333D6C: using guessed type int dword_10333D6C;

//----- (100419B0) --------------------------------------------------------
bool __cdecl sub_100419B0(char a1, int a2)
{
  bool v2; // bl@1
  double v3; // st7@4
  int v4; // eax@4
  int v5; // ecx@8
  int v6; // eax@8
  double v7; // st5@14
  double v8; // st6@14
  float v9; // ST40_4@15
  double v10; // st5@16
  double v11; // st7@19
  float v13; // ST40_4@23
  float v14; // [sp+40h] [bp-10h]@5
  float v15; // [sp+40h] [bp-10h]@12
  float v16; // [sp+40h] [bp-10h]@16
  int v17; // [sp+44h] [bp-Ch]@8
  float v18; // [sp+48h] [bp-8h]@9
  float v19; // [sp+4Ch] [bp-4h]@9

  v2 = 0;
  if ( sub_1007C3B0(2047, a2, 16) )
  {
    *(double *)a2 = 0.68067840827779;
    *(double *)(a2 + 8) = -1.658062789394617;
  }
  if ( (unsigned __int8)sub_10041820() )
  {
    sub_1007C110(101, 10000);
    v3 = 0.0;
    v4 = dword_10333D6C;
    v2 = *(_WORD *)(dword_10333D6C + 1456) > 1u;
    if ( *(_BYTE *)(dword_10333D6C + 1296) )
    {
      v14 = sub_100509F0(*(_DWORD *)(dword_10333D6C + 1292));
      v4 = dword_10333D6C;
      v3 = 0.0;
    }
    else
    {
      v14 = 0.0;
    }
    if ( v2 )
    {
      v5 = *(_DWORD *)(v4 + 1524);
      v6 = v4 + 1524;
      *(_DWORD *)a2 = v5;
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(v6 + 4);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v6 + 8);
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(v6 + 12);
      sub_1001E2D0(6.2831853071796, -6.2831853071796);
      sub_1001E2D0(6.2831853071796, -6.2831853071796);
      sub_1007BF80(v14, dword_10333D6C + 1512, (int)&v17);
      v4 = dword_10333D6C;
      v3 = 0.0;
    }
    else
    {
      *(float *)&v17 = v3;
      v18 = v3;
      v19 = v3;
    }
    if ( a1 == 1 )
    {
      sub_1007BF50((int)&v17, v4 + 1432, (int)&v17);
      v3 = 0.0;
      v4 = dword_10333D6C;
    }
    v15 = *(float *)(v4 + 1280);
    if ( (LODWORD(v15) & 0x7F800000) == 2139095040 || v15 > 0.0053898906 )
    {
      v8 = 0.0053898906;
    }
    else
    {
      v7 = v15;
      v8 = 0.0053898906;
      if ( v15 >= v3 )
        goto LABEL_16;
    }
    v9 = v3;
    v7 = v9;
LABEL_16:
    *(double *)a2 = v7 * v18 + *(double *)a2;
    v16 = *(float *)(dword_10333D6C + 1284);
    v10 = v16;
    if ( (LODWORD(v16) & 0x7F800000) == 2139095040 || v10 > v8 || v10 < v3 )
    {
      v13 = v3;
      v11 = v13;
    }
    else
    {
      v11 = v16;
    }
    *(double *)(a2 + 8) = v11 * *(float *)&v17 + *(double *)(a2 + 8);
    sub_1007C0F0(101);
    sub_10061F80(a2);
  }
  return v2;
}
// 10333D6C: using guessed type int dword_10333D6C;

//----- (10041BD0) --------------------------------------------------------
char __cdecl sub_10041BD0(float *a1)
{
  char v1; // bl@1

  *a1 = 9.9999996e24;
  v1 = 0;
  if ( (unsigned __int8)sub_10041820() )
  {
    sub_1007C110(101, 60000);
    v1 = sub_10041830(a1);
    if ( v1 )
      *a1 = *(float *)(dword_10333D6C + 1440) + *a1;
    sub_1007C0F0(101);
  }
  return v1;
}
// 10333D6C: using guessed type int dword_10333D6C;

//----- (10041C30) --------------------------------------------------------
char sub_10041C30()
{
  char v0; // bl@1

  v0 = 0;
  if ( (unsigned __int8)sub_10041820() )
  {
    sub_1007C110(101, 10000);
    if ( !*(_BYTE *)(dword_10333D6C + 1444)
      || !*(_BYTE *)(dword_10333D6C + 1451)
      || (v0 = 1, *(_WORD *)(dword_10333D6C + 1456) <= 1u)
      || *(float *)(dword_10333D6C + 1480) <= 15.433242 )
    {
      v0 = 0;
    }
    sub_1007C0F0(101);
  }
  return v0;
}
// 10333D6C: using guessed type int dword_10333D6C;

//----- (10041CA0) --------------------------------------------------------
bool sub_10041CA0()
{
  bool v0; // bl@1

  v0 = 0;
  if ( (unsigned __int8)sub_10041820() )
  {
    sub_1007C110(101, 60000);
    v0 = *(_BYTE *)(dword_10333D6C + 1454) == 1;
    sub_1007C0F0(101);
  }
  return v0;
}
// 10333D6C: using guessed type int dword_10333D6C;

//----- (10041CE0) --------------------------------------------------------
char sub_10041CE0()
{
  char result; // al@2

  if ( (unsigned __int8)sub_10041820() )
    result = *(_BYTE *)(dword_10333D6C + 1447);
  else
    result = 0;
  return result;
}
// 10333D6C: using guessed type int dword_10333D6C;

//----- (10041D00) --------------------------------------------------------
char sub_10041D00()
{
  char result; // al@2

  if ( (unsigned __int8)sub_10041820() )
    result = *(_BYTE *)(dword_10333D6C + 1449);
  else
    result = 0;
  return result;
}
// 10333D6C: using guessed type int dword_10333D6C;

//----- (10041D20) --------------------------------------------------------
char sub_10041D20()
{
  char v0; // bl@4

  if ( (unsigned __int8)sub_10041820() )
  {
    sub_1007C110(101, 60000);
    if ( 0.0 != *(float *)(dword_10333D6C + 1492) && 0.0 != *(float *)(dword_10333D6C + 1504) )
    {
      v0 = *(_BYTE *)(dword_10333D6C + 1450);
      sub_1007C0F0(101);
      return v0;
    }
    sub_1007C0F0(101);
  }
  return 1;
}
// 10333D6C: using guessed type int dword_10333D6C;

//----- (10041D90) --------------------------------------------------------
char sub_10041D90()
{
  return sub_100418A0(-32761);
}

//----- (10041DA0) --------------------------------------------------------
bool __cdecl sub_10041DA0(float *a1)
{
  bool v1; // bl@1
  double v2; // st7@3

  *a1 = 9.9999996e24;
  v1 = 0;
  if ( (unsigned __int8)sub_10041820() )
  {
    sub_1007C110(101, 10000);
    if ( *(_BYTE *)(dword_10333D6C + 1444) )
      v2 = (double)(unsigned int)(sub_1007C040() - *(_DWORD *)(dword_10333D6C + 1292))
         / 1000.0
         * *(float *)(dword_10333D6C + 1488)
         + *(float *)(dword_10333D6C + 1484);
    else
      v2 = *(float *)(dword_10333D6C + 1484);
    *a1 = v2;
    *a1 = sub_1007BCB0(*a1);
    v1 = *(_WORD *)(dword_10333D6C + 1456) > 1u;
    sub_1007C0F0(101);
  }
  return v1;
}
// 10333D6C: using guessed type int dword_10333D6C;

//----- (10041E50) --------------------------------------------------------
bool __cdecl sub_10041E50(float *a1)
{
  bool v1; // bl@1
  int v2; // eax@2

  *a1 = 0.0;
  v1 = 0;
  if ( (unsigned __int8)sub_10041820() )
  {
    sub_1007C110(101, 60000);
    v2 = dword_10333D6C;
    if ( *(_BYTE *)(dword_10333D6C + 1451) )
    {
      *a1 = *(float *)(dword_10333D6C + 1480);
      v2 = dword_10333D6C;
    }
    v1 = *(_WORD *)(v2 + 1456) > 1u;
    sub_1007C0F0(101);
  }
  return v1;
}
// 10333D6C: using guessed type int dword_10333D6C;

//----- (10041EC0) --------------------------------------------------------
signed int sub_10041EC0()
{
  return 1000;
}

//----- (10041EE0) --------------------------------------------------------
int sub_10041EE0()
{
  return sub_10064280((int)off_100F7358);
}
// 100F7358: using guessed type int (*off_100F7358[4])();

//----- (10041EF0) --------------------------------------------------------
signed int __cdecl sub_10041EF0(unsigned int a1)
{
  int v1; // eax@1

  v1 = sub_10050A40(a1);
  return sub_10051FD0(v1);
}

//----- (10041F30) --------------------------------------------------------
signed int __cdecl sub_10041F30(unsigned int a1, int a2, int a3, int a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  signed int result; // eax@3

  v4 = sub_10050A40(a1);
  v5 = v4;
  if ( v4 < 0xFFFFFFC2 && v4 )
  {
    if ( sub_100524B0(v4, a4, 0) == a4 )
      result = sub_10052450(v5, a2, a3);
    else
      result = -15;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10041F90) --------------------------------------------------------
signed int __cdecl sub_10041F90(unsigned int a1, int a2, int a3)
{
  unsigned int v3; // eax@1

  v3 = sub_10050A40(a1);
  return sub_100524B0(v3, a2, a3);
}

//----- (10041FB0) --------------------------------------------------------
bool __cdecl sub_10041FB0(float a1, int a2, int a3, int a4)
{
  int v4; // edi@2
  int v5; // esi@3
  int v6; // ecx@8
  unsigned int v7; // eax@9
  float v8; // ST14_4@10
  float v9; // ST14_4@10
  float v10; // ST14_4@10
  float v11; // ST14_4@10
  float v12; // ST14_4@10
  float v13; // ST14_4@10
  float v14; // ST14_4@10
  int v15; // eax@12
  float v16; // ST14_4@14
  signed int v17; // ebx@14
  bool result; // al@19
  int v19; // [sp+8h] [bp-8h]@5

  if ( a4 && (v4 = a3, a3 <= 9) && (v5 = a2, a2 > 0) && a3 <= a2 - 2 )
  {
    v19 = 0;
    if ( a1 < 0.0 )
    {
      v4 = a3 - 1;
      a1 = fabs(a1);
      *(_BYTE *)a4 = 45;
      v19 = 1;
      if ( a3 == 1 )
        v4 = -1;
    }
    v6 = 0;
    if ( v4 >= 8 )
    {
      v7 = ((unsigned int)(v4 - 8) >> 3) + 1;
      v6 = 8 * v7;
      do
      {
        --v7;
        v8 = a1 * 10.0;
        v9 = v8 * 10.0;
        v10 = v9 * 10.0;
        v11 = v10 * 10.0;
        v12 = v11 * 10.0;
        v13 = v12 * 10.0;
        v14 = v13 * 10.0;
        a1 = v14 * 10.0;
      }
      while ( v7 );
    }
    if ( v6 < v4 )
    {
      v15 = v4 - v6;
      do
      {
        --v15;
        a1 = a1 * 10.0;
      }
      while ( v15 );
    }
    v16 = a1 + 0.5;
    v17 = (signed int)v16;
    if ( a2 > v19 )
    {
      do
      {
        if ( --v5 == a2 - v4 - 1 )
        {
          *(_BYTE *)(v5 + a4) = 46;
        }
        else
        {
          *(_BYTE *)(v5 + a4) = v17 % 10 + 48;
          v17 /= 10;
        }
      }
      while ( v5 > v19 );
    }
    result = v17 == 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10042120) --------------------------------------------------------
bool __cdecl sub_10042120(signed int a1, signed int a2, _BYTE *a3)
{
  bool result; // al@2
  signed int v4; // ebx@3
  signed int v5; // edi@3
  signed int i; // esi@5

  if ( a3 )
  {
    v4 = a1;
    v5 = 0;
    if ( a1 < 0 )
    {
      v4 = -a1;
      *a3 = 45;
      v5 = 1;
    }
    for ( i = a2; i > v5; v4 /= 10 )
      a3[--i] = v4 % 10 + 48;
    result = v4 == 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10042190) --------------------------------------------------------
void __cdecl sub_10042190(const char *a1, unsigned int a2, int a3)
{
  unsigned int v3; // eax@2

  if ( a1 )
  {
    v3 = strlen(a1);
    if ( v3 < a2 )
      memset((void *)&a1[v3], a3, a2 - v3);
    a1[a2] = 0;
  }
}

//----- (100421E0) --------------------------------------------------------
int __cdecl sub_100421E0(int a1, _BYTE *a2, int a3)
{
  int v3; // esi@2
  int v4; // eax@2
  _BYTE *v5; // ecx@3
  int result; // eax@7

  if ( a3 <= 0 )
    goto LABEL_11;
  v3 = a3 - 1;
  v4 = 0;
  if ( a3 - 1 > 0 )
  {
    v5 = a2;
    do
    {
      if ( !*v5 )
        break;
      v5[a1 - (_DWORD)a2] = *v5;
      ++v4;
      ++v5;
    }
    while ( v4 < v3 );
  }
  *(_BYTE *)(v4 + a1) = 0;
  *(_BYTE *)(v3 + a1) = 0;
  if ( a2[v4] )
LABEL_11:
    result = -1;
  else
    result = v4 + 1;
  return result;
}

//----- (10042230) --------------------------------------------------------
signed int __cdecl sub_10042230(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // ebp@1
  _BYTE *v4; // ebx@2
  _BYTE *v5; // edi@2
  int v6; // esi@3
  int v7; // eax@3
  signed int result; // eax@7

  v3 = a3;
  if ( a3 <= 0 )
  {
LABEL_7:
    result = -2;
  }
  else
  {
    v4 = a2;
    v5 = a1;
    while ( 1 )
    {
      v6 = tolower(*v5++);
      v7 = tolower(*v4++);
      if ( v6 > v7 )
        return 1;
      if ( v6 < v7 )
        return -1;
      if ( !v6 )
        break;
      if ( --v3 <= 0 )
        goto LABEL_7;
    }
    result = 0;
  }
  return result;
}

//----- (100422A0) --------------------------------------------------------
int __cdecl sub_100422A0(void *a1, size_t a2)
{
  _BYTE *v2; // eax@1
  int result; // eax@2

  v2 = memchr(a1, 0, a2);
  if ( v2 )
    result = v2 - (_BYTE *)a1;
  else
    result = -2;
  return result;
}

//----- (100422D0) --------------------------------------------------------
int __cdecl sub_100422D0(int a1, char *a2, int a3)
{
  int v3; // eax@3
  int i; // esi@5
  int v5; // esi@8
  int result; // eax@8

  if ( a1 && a2 )
  {
    v3 = a3;
    if ( !a3 )
      v3 = strlen((const char *)a1);
    for ( i = v3 - 1; i >= 0; --i )
    {
      if ( !strchr(a2, *(_BYTE *)(i + a1)) )
        break;
    }
    v5 = i + 1;
    *(_BYTE *)(v5 + a1) = 0;
    result = v5;
  }
  else
  {
    result = a3;
  }
  return result;
}

//----- (10042330) --------------------------------------------------------
int __cdecl sub_10042330(char *a1, size_t a2, char *a3, va_list a4)
{
  int result; // eax@2

  if ( (signed int)a2 > 0 )
  {
    result = _vsnprintf(a1, a2, a3, a4);
    if ( result < 0 )
      result = -1;
    a1[a2 - 1] = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10042370) --------------------------------------------------------
int sub_10042370(char *a1, size_t a2, char *a3, ...)
{
  int result; // eax@1
  va_list va; // [sp+10h] [bp+10h]@1

  va_start(va, a3);
  result = sub_10042330(a1, a2, a3, va);
  if ( result < 0 )
    result = -1;
  return result;
}

//----- (100423A0) --------------------------------------------------------
int __cdecl sub_100423A0(const char *a1, _BYTE *a2, int a3)
{
  unsigned int v3; // kr00_4@1

  v3 = strlen(a1);
  return sub_100421E0((int)&a1[v3], a2, a3 - v3);
}

//----- (100423E0) --------------------------------------------------------
int __cdecl sub_100423E0(int a1, int a2)
{
  return sub_100422D0(a1, "_ ", a2);
}

//----- (10042400) --------------------------------------------------------
__int16 __cdecl sub_10042400(__int16 a1)
{
  __int16 result; // ax@3

  if ( (unsigned __int8)a1 >= 3u || sub_1007C3B0(dword_100F73EC[(unsigned __int8)a1], (int)&a1, 2) )
  {
    sub_10042930("..\\lib\\adl\\iop_atn_intf.c", 289, 0, "transport reference reset");
    result = 0;
  }
  else
  {
    result = a1;
  }
  return result;
}
// 100F73EC: using guessed type int dword_100F73EC[];

//----- (10042450) --------------------------------------------------------
char __cdecl sub_10042450(char a1, char a2, void *a3, size_t a4)
{
  signed int v4; // esi@1

  v4 = a4;
  byte_1027B198 = a1;
  byte_1027B199 = a2;
  if ( a4 )
  {
    if ( a4 > 0x100 )
      v4 = 256;
    memcpy(&unk_1027B19A, a3, v4);
  }
  sub_10024E60(1, 111, &byte_1027B198, 1, v4 + 2, 1);
  return sub_10025010(1, 111, 0xFFFFFFF);
}
// 1027B198: using guessed type char byte_1027B198;
// 1027B199: using guessed type char byte_1027B199;

//----- (100424C0) --------------------------------------------------------
void sub_100424C0()
{
  dword_10333D68 = -15;
}
// 10333D68: using guessed type int dword_10333D68;

//----- (100424D0) --------------------------------------------------------
char __cdecl sub_100424D0(void *a1, int a2)
{
  char result; // al@4

  if ( a1 && a2 && (unsigned int)a2 <= 0x9F4 )
  {
    sub_10024E60(1, 1300, a1, 1, a2, 1);
    result = sub_10025010(1, 1300, 536576);
  }
  else
  {
    result = sub_10042930("..\\lib\\adl\\iop_atn_intf.c", 420, 0, 0);
  }
  return result;
}

//----- (10042530) --------------------------------------------------------
char __cdecl sub_10042530(void *a1, size_t a2, void *a3, size_t a4)
{
  unsigned int v4; // edi@1
  char result; // al@3

  v4 = a2 + a4;
  if ( ((a2 + a4) & 0x80000000) != 0 || v4 > 0x594 )
  {
    result = sub_10042930("..\\lib\\adl\\iop_atn_intf.c", 488, 0, 0);
  }
  else
  {
    memcpy(&unk_1027AC00, a1, a2);
    memcpy((char *)&unk_1027AC00 + a2, a3, a4);
    sub_10024E60(1, 992, &unk_1027AC00, 1, v4, 1);
    result = sub_10025010(1, 992, 768);
  }
  return result;
}

//----- (100425D0) --------------------------------------------------------
char __cdecl sub_100425D0(unsigned __int8 a1, char a2)
{
  char result; // al@2

  if ( a1 >= 3u )
    result = sub_10042930("..\\lib\\adl\\iop_atn_intf.c", 546, 0, 0);
  else
    result = sub_1007C500(dword_100F73EC[a1], (int)&a2, 2);
  return result;
}
// 100F73EC: using guessed type int dword_100F73EC[];

//----- (10042610) --------------------------------------------------------
char __cdecl sub_10042610(void *a1)
{
  return sub_100253C0(1, 1294, a1);
}

//----- (10042630) --------------------------------------------------------
char __cdecl sub_10042630(void *a1)
{
  return sub_100253C0(1, 1000, a1);
}

//----- (10042650) --------------------------------------------------------
char __cdecl sub_10042650(_DWORD *a1)
{
  char result; // al@2
  char v2; // [sp+4h] [bp-44h]@1
  int v3; // [sp+18h] [bp-30h]@2

  if ( sub_1007C3B0(6786, (int)&v2, 64) )
  {
    result = 0;
  }
  else
  {
    *a1 = v3;
    result = 1;
  }
  return result;
}

//----- (100426B0) --------------------------------------------------------
BOOL __fastcall sub_100426B0(int a1)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = a1;
  return sub_1003DBD0(6, 1, 27, 0, (int)&v2, 4) && v2 & 1;
}

//----- (100426E0) --------------------------------------------------------
char *__cdecl sub_100426E0(int a1, char *a2, int a3, char *a4, int a5)
{
  char *v5; // edi@1
  char *result; // eax@4
  char v7[4]; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v5 = a2;
  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  *(_DWORD *)(a5 + 16) = sub_1007BFD0();
  *(_DWORD *)(a5 + 596) = sub_1007C040();
  sub_1007C060((int)v7, 1, *(_DWORD *)(a5 + 16), 40);
  *(_WORD *)(a5 + 594) = 0x7FFF;
  sub_100421E0(a5 + 585, "14.01", 8);
  *(_DWORD *)a5 = a1;
  sub_10042DC0((char *)(a5 + 4));
  *(_DWORD *)(a5 + 460) = a3;
  if ( strrchr(a2, 92) )
    v5 = strrchr(a2, 92) + 1;
  strncpy((char *)(a5 + 464), v5, 0x14u);
  *(_BYTE *)(a5 + 484) = 0;
  if ( a4 )
  {
    result = strncpy((char *)(a5 + 485), a4, 0x63u);
    *(_BYTE *)(a5 + 584) = 0;
  }
  else
  {
    result = strncpy((char *)(a5 + 485), v7, 0x64u);
  }
  return result;
}

//----- (10042810) --------------------------------------------------------
char sub_10042810()
{
  char result; // al@1

  result = 0;
  byte_1027B29A = 0;
  byte_1027B29B = 0;
  return result;
}
// 1027B29A: using guessed type char byte_1027B29A;
// 1027B29B: using guessed type char byte_1027B29B;

//----- (10042820) --------------------------------------------------------
char __cdecl sub_10042820(char *a1, int a2, char a3, char *a4, int a5)
{
  char result; // al@7
  char v6; // [sp+Bh] [bp-2Dh]@4
  int v7; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( a3 & 3 )
    sub_100426E0(-5, a1, a2, a4, a5);
  else
    sub_100426E0(-44, a1, a2, a4, a5);
  v6 = a3 & 8;
  if ( a3 & 8 )
    sub_100423A0((const char *)(a5 + 485), " DBGA", 100);
  sub_1007C060((int)&v7, 0, 0, 40);
  if ( a3 & 3 )
  {
    result = a3 & 8;
    if ( v6 )
    {
      if ( byte_1027B29A )
        return result;
      if ( v6 )
        goto LABEL_15;
    }
    if ( !byte_1027B29B )
LABEL_15:
      result = sub_1007C0A0(36, 1, *(_DWORD *)a5, a5);
  }
  else
  {
    result = j_HWM_pvg_log_err(a5);
  }
  return result;
}
// 1007C850: using guessed type int __cdecl j_HWM_pvg_log_err(_DWORD);
// 1027B29A: using guessed type char byte_1027B29A;
// 1027B29B: using guessed type char byte_1027B29B;

//----- (10042920) --------------------------------------------------------
char __cdecl sub_10042920(char a1)
{
  char result; // al@1

  result = a1 + byte_1027B29A;
  byte_1027B29A += a1;
  return result;
}
// 1027B29A: using guessed type char byte_1027B29A;

//----- (10042930) --------------------------------------------------------
char __cdecl sub_10042930(char *a1, int a2, char a3, char *a4)
{
  int v5; // [sp+8h] [bp-284h]@1

  memset(&v5, 0, 0x280u);
  return sub_10042820(a1, a2, a3, a4, (int)&v5);
}

//----- (100429A0) --------------------------------------------------------
char __thiscall sub_100429A0(void *this)
{
  char result; // al@1
  bool v2; // zf@2
  void *v3; // [sp-2h] [bp-4h]@1

  v3 = this;
  sub_10045FE0(4, (char *)&v3 + 3);
  result = BYTE3(v3);
  if ( BYTE3(v3) == 1 )
  {
    v2 = SIM_proc_rqst(50) == 0;
    result = 2;
    if ( v2 )
      result = BYTE3(v3);
  }
  return result;
}
// 1007DA32: using guessed type int __cdecl SIM_proc_rqst(_DWORD);

//----- (100429D0) --------------------------------------------------------
int __thiscall sub_100429D0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10045FE0(46, (char *)&v2);
  return (int)v2;
}

//----- (100429F0) --------------------------------------------------------
bool __cdecl sub_100429F0(char a1)
{
  void *v1; // ecx@0
  bool result; // al@2
  void *v3; // ecx@4

  switch ( a1 )
  {
    case 5:
      result = sub_100626C0(0) == 1;
      break;
    case 6:
      goto LABEL_3;
    case 9:
      if ( sub_100429D0(v1) & 3 || sub_10046100(v3) == 1 )
        result = 1;
      else
LABEL_3:
        result = 0;
      break;
    case 8:
      result = sub_10046100(v1) != 1;
      break;
    default:
      result = sub_10046100(v1) == 1;
      break;
  }
  return result;
}

//----- (10042A60) --------------------------------------------------------
int __cdecl sub_10042A60(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int result; // eax@1
  unsigned int v4; // edx@1
  char v5; // bl@8
  char v6; // dl@13
  char v7; // cl@13

  v2 = a2 / 0x15180 % 0x5B5;
  result = a1;
  v4 = 4 * (a2 / 0x15180 / 0x5B5) + 1990;
  *(_WORD *)(a1 + 2) = v4;
  if ( v2 > 0x16D )
  {
    do
    {
      v2 -= 365;
      if ( !((unsigned __int16)v4 % 4) )
        --v2;
      LOWORD(v4) = v4 + 1;
    }
    while ( v2 > 0x16D );
    *(_WORD *)(a1 + 2) = v4;
  }
  if ( v2 >= 1 )
  {
    v5 = 0;
    if ( v2 > 0x3B && !(*(_WORD *)(a1 + 2) % 4) )
    {
      --v2;
      v5 = 1;
    }
    *(_BYTE *)a1 = 12;
    if ( v2 <= 0x14E )
    {
      do
        --*(_BYTE *)a1;
      while ( v2 <= *(_WORD *)&word_100F798E[2 * *(_BYTE *)a1] );
    }
    v6 = *(_BYTE *)a1;
    v7 = v2 - word_100F798E[2 * *(_BYTE *)a1];
    *(_BYTE *)(a1 + 1) = v7;
    if ( v5 == 1 && v6 == 2 )
      *(_BYTE *)(a1 + 1) = v7 + 1;
  }
  else
  {
    --*(_WORD *)(a1 + 2);
    *(_BYTE *)a1 = 12;
    *(_BYTE *)(a1 + 1) = 31;
  }
  return result;
}

//----- (10042B50) --------------------------------------------------------
int __cdecl sub_10042B50(int *a1, unsigned int a2)
{
  int result; // eax@1
  int v3; // eax@9
  int v4; // ecx@9
  signed int v5; // eax@9
  int i; // ecx@9
  int v7; // ecx@13

  result = a2 >> 16;
  if ( HIWORD(a2) > 0x7C5u )
  {
    if ( HIWORD(a2) > 0x84Eu
      || HIWORD(a2) == 2126 && (unsigned __int8)a2 > 2u
      || HIWORD(a2) == 2126 && (_BYTE)a2 == 2 && BYTE1(a2) > 5u )
    {
      *a1 = -23296;
    }
    else
    {
      v3 = (HIWORD(a2) - 1990) / 4;
      v4 = v3;
      v5 = 4 * v3 + 1990;
      for ( i = 1461 * v4; v5 < HIWORD(a2); ++v5 )
      {
        i += 365;
        if ( !(v5 % 4) )
          ++i;
      }
      v7 = *(_WORD *)&word_100F798E[2 * (unsigned __int8)a2] + i;
      if ( (unsigned __int8)a2 > 2u && !(HIWORD(a2) % 4) )
        ++v7;
      result = 86400 * (v7 + BYTE1(a2));
      *a1 = result;
    }
  }
  else
  {
    result = (int)a1;
    *a1 = 0;
  }
  return result;
}

//----- (10042C40) --------------------------------------------------------
__int16 __cdecl sub_10042C40(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  __int16 result; // ax@1

  v2 = a2 % 0x15180 % 0xE10;
  *(_WORD *)a1 = a2 % 0x15180 / 0xE10;
  *(_BYTE *)(a1 + 2) = v2 / 0x3C;
  result = 60 * (char)(v2 / 0x3C);
  *(_BYTE *)(a1 + 3) = v2 % 0x3C;
  return result;
}

//----- (10042C90) --------------------------------------------------------
int __cdecl sub_10042C90(int *a1, unsigned int a2)
{
  int result; // eax@1

  result = (a2 >> 24) + 60 * ((unsigned __int8)(a2 >> 16) + 60 * (unsigned __int16)a2);
  *a1 = result;
  return result;
}

//----- (10042CC0) --------------------------------------------------------
__int16 __cdecl sub_10042CC0(unsigned int *a1, _WORD *a2, _WORD *a3)
{
  unsigned int v3; // esi@1
  __int16 result; // ax@1
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1

  v3 = *a1;
  sub_10042C40((int)&v5, *a1);
  sub_10042A60((int)&v6, v3);
  *a3 = (unsigned __int8)(BYTE3(v5) >> 1) | (unsigned __int16)(32 * (BYTE2(v5) | (unsigned __int16)((_WORD)v5 << 6)));
  result = BYTE1(v6);
  *a2 = BYTE1(v6) | (unsigned __int16)(32 * ((unsigned __int8)v6 | (unsigned __int16)(16 * (HIWORD(v6) - 60))));
  return result;
}

//----- (10042D40) --------------------------------------------------------
int __cdecl sub_10042D40(int a1, int a2)
{
  int v2; // eax@1
  unsigned int v3; // esi@1
  int result; // eax@2
  int v5; // edi@3

  v2 = *(_DWORD *)(a1 + 8);
  v3 = (a2 + 3) & 0xFFFFFFFC;
  if ( v3 <= *(_DWORD *)(a1 + 4) - v2 )
  {
    v5 = v2 + *(_DWORD *)a1;
    memset((void *)(v2 + *(_DWORD *)a1), 0, (a2 + 3) & 0xFFFFFFFC);
    *(_DWORD *)(a1 + 8) += v3;
    result = v5;
  }
  else
  {
    sub_10042930("..\\lib\\acl\\utl\\utl_owheap.c", 108, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10042D90) --------------------------------------------------------
int __cdecl sub_10042D90(int a1, int a2, int a3)
{
  unsigned int v3; // ecx@1
  int result; // eax@1

  v3 = (a2 + 3) & 0xFFFFFFFC;
  result = a3 + a2 - v3;
  *(_DWORD *)a1 = v3;
  *(_DWORD *)(a1 + 4) = result;
  *(_DWORD *)(a1 + 8) = 0;
  return result;
}

//----- (10042DC0) --------------------------------------------------------
char __cdecl sub_10042DC0(char *a1)
{
  int v1; // ecx@0
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  sub_10045FE0(13, (char *)&v3 + 3);
  sub_10045FE0(12, a1);
  return BYTE3(v3);
}

//----- (10042DF0) --------------------------------------------------------
char __cdecl sub_10042DF0(int a1)
{
  void *v1; // ecx@1
  char v2; // bl@1
  unsigned int v4; // [sp+4h] [bp-4h]@1

  v2 = sub_10042DC0((char *)&v4);
  if ( v2 )
  {
    if ( sub_10045EC0(v1) == 1 )
      sub_100642C0((int *)&v4, v4);
    sub_10042C40(a1, v4);
  }
  return v2;
}

//----- (10042E40) --------------------------------------------------------
char __cdecl sub_10042E40(int a1)
{
  void *v1; // ecx@1
  char v2; // bl@1
  unsigned int v4; // [sp+4h] [bp-4h]@1

  v2 = sub_10042DC0((char *)&v4);
  if ( v2 )
  {
    if ( sub_10045EC0(v1) == 1 )
      sub_100642C0((int *)&v4, v4);
    sub_10042A60(a1, v4);
  }
  return v2;
}

//----- (10042E90) --------------------------------------------------------
char __cdecl sub_10042E90(char a1, _DWORD *a2)
{
  int v2; // eax@1
  char result; // al@2

  v2 = sub_10043FF0(&a1, 2u, (int)&unk_1013A01A, 8, 415, -1);
  if ( v2 == -1 )
  {
    result = 0;
  }
  else
  {
    *a2 = *(&dword_1013A01C + 2 * v2);
    result = 1;
  }
  return result;
}

//----- (10042ED0) --------------------------------------------------------
__int16 __usercall sub_10042ED0@<ax>(int a1@<edi>, char a2)
{
  __int16 v2; // ax@1
  __int16 result; // ax@3

  v2 = sub_10043FF0(&a2, 2u, (int)&unk_1013AE90, 16, 18, -1);
  if ( v2 == -1 )
  {
LABEL_11:
    result = -1;
  }
  else
  {
    switch ( a1 )
    {
      case 1:
        result = word_1013AE92[8 * v2];
        break;
      case 2:
        result = word_1013AE96[8 * v2];
        break;
      case 4:
        result = word_1013AE94[8 * v2];
        break;
      case 64:
        result = word_1013AE98[8 * v2];
        break;
      case 128:
        result = word_1013AE9A[8 * v2];
        break;
      case 16:
        result = word_1013AE9C[8 * v2];
        break;
      case 32:
        result = word_1013AE9E[8 * v2];
        break;
      default:
        sub_10042370(byte_1027B2A0, 0x64u, "Unrecognized LRU (%u) passed into alert processing.", a1);
        sub_10042930("..\\lib\\adl\\sys_updt_alrt_data.c", 1037, 0, byte_1027B2A0);
        goto LABEL_11;
    }
  }
  return result;
}
// 1013AE92: using guessed type __int16 word_1013AE92[];
// 1013AE94: using guessed type __int16 word_1013AE94[];
// 1013AE96: using guessed type __int16 word_1013AE96[];
// 1013AE98: using guessed type __int16 word_1013AE98[];
// 1013AE9A: using guessed type __int16 word_1013AE9A[];
// 1013AE9C: using guessed type __int16 word_1013AE9C[];
// 1013AE9E: using guessed type __int16 word_1013AE9E[];

//----- (10043070) --------------------------------------------------------
signed __int16 __usercall sub_10043070@<ax>(void *a1@<ecx>, signed __int16 a2@<bx>, const char *a3@<esi>)
{
  signed __int16 v3; // di@1
  void *v4; // ecx@4
  int v5; // eax@19
  char v7; // [sp+4h] [bp-38h]@2

  v3 = a2;
  if ( a3 )
    memset(&v7, 0, 0x33u);
  if ( a2 == 300 )
  {
    switch ( sub_100429D0(a1) )
    {
      case 1:
        v3 = 380;
        if ( !a3 )
          return v3;
        sub_100423A0(&v7, "PFD1", 51);
        break;
      case 4:
        v3 = 381;
        if ( !a3 )
          return v3;
        sub_100423A0(&v7, "MFD1", 51);
        break;
      case 2:
        v3 = 382;
        if ( !a3 )
          return v3;
        sub_100423A0(&v7, "PFD2", 51);
        break;
      case 64:
        v3 = 383;
        if ( !a3 )
          return v3;
        sub_100423A0(&v7, "GTC1", 51);
        break;
      case 128:
        v3 = 384;
        if ( !a3 )
          return v3;
        sub_100423A0(&v7, "GTC2", 51);
        break;
      case 16:
        v3 = 385;
        if ( !a3 )
          return v3;
        sub_100423A0(&v7, "GTC3", 51);
        break;
      case 32:
        v3 = 386;
        if ( !a3 )
          return v3;
        sub_100423A0(&v7, "GTC4", 51);
        break;
      default:
        v3 = -1;
        v5 = sub_100429D0(v4);
        sub_10042370(byte_1027B2A0, 0x64u, "Unrecognized LRU (%u) passed into DB error alert processing.", v5);
        sub_10042930("..\\lib\\adl\\sys_updt_alrt_data.c", 1286, 0, byte_1027B2A0);
        break;
    }
  }
  if ( a3 )
    sub_100423A0(a3, &v7, 51);
  return v3;
}

//----- (100432C0) --------------------------------------------------------
char __cdecl sub_100432C0(signed __int16 a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  char result; // al@2
  char v4; // [sp+Ah] [bp-6h]@1
  char v5; // [sp+Bh] [bp-5h]@1
  int v6; // [sp+Ch] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = (unsigned __int16)sub_10043070(v1, a1, 0);
  v2 = sub_10043FF0(&v6, 2u, (int)&unk_1013A01A, 8, 415, -1);
  if ( v2 < 0 )
  {
    sub_10042930("..\\lib\\adl\\sys_updt_alrt_data.c", 152, 0, 0);
    result = 0;
  }
  else
  {
    sub_1007C650(*(&dword_1013A01C + 2 * v2), &v4, 1, &v5);
    result = v4;
  }
  return result;
}

//----- (10043350) --------------------------------------------------------
char __cdecl sub_10043350(char a1, int a2)
{
  __int16 v2; // ax@1

  v2 = sub_10042ED0(a2, a1);
  return sub_100432C0(v2);
}

//----- (10043370) --------------------------------------------------------
int __cdecl sub_10043370(signed __int16 a1)
{
  void *v1; // ecx@1
  signed __int16 v2; // ax@1
  int v3; // esi@2
  int result; // eax@6
  char v5; // [sp+Ah] [bp-42h]@1
  char v6; // [sp+Bh] [bp-41h]@1
  int v7; // [sp+Ch] [bp-40h]@1
  int v8; // [sp+10h] [bp-3Ch]@1
  char v9; // [sp+14h] [bp-38h]@1

  memset(&v9, 0, 0x33u);
  v5 = 0;
  v6 = 0;
  v2 = sub_10043070(v1, a1, 0);
  v8 = (unsigned __int16)v2;
  if ( sub_10042E90(v2, &v7) )
  {
    v3 = v7;
    if ( !sub_1007C650(v7, &v5, 1, &v6) && v5 )
    {
      v5 = 0;
      sub_1007C500(v3, (int)&v5, 1);
    }
  }
  else
  {
    sub_10042370(
      byte_1027B2A0,
      0x64u,
      "An attempt to clear a system trigger was performed with an invalid trigger id (%u)",
      (unsigned __int16)a1);
    sub_10042930("..\\lib\\adl\\sys_updt_alrt_data.c", 522, 0, byte_1027B2A0);
  }
  result = (unsigned __int16)sub_10043FF0(&v8, 2u, (int)&unk_1013AD18, 12, 32, -1);
  if ( (_WORD)result != -1 )
    result = sub_1007C500(dword_1013AD14[3 * (signed __int16)result], (int)&v9, 51);
  return result;
}
// 1013AD14: using guessed type int dword_1013AD14[];

//----- (10043480) --------------------------------------------------------
char __cdecl sub_10043480(unsigned __int16 a1)
{
  int v1; // esi@2
  int v2; // eax@2
  char v4; // [sp+6h] [bp-6h]@1
  char v5; // [sp+7h] [bp-5h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v4 = 0;
  v5 = 1;
  if ( sub_10042E90(a1, &v6) )
  {
    v1 = v6;
    v2 = sub_1007C650(v6, &v4, 1, &v5);
    if ( !v2 && !v4 )
    {
      v4 = 1;
      LOBYTE(v2) = sub_1007C500(v1, (int)&v4, 1);
    }
  }
  else
  {
    sub_10042370(
      byte_1027B2A0,
      0x64u,
      "An attempt to set a system trigger was performed with an invalid trigger id (%u)",
      a1);
    LOBYTE(v2) = sub_10042930("..\\lib\\adl\\sys_updt_alrt_data.c", 666, 0, byte_1027B2A0);
  }
  return v2;
}

//----- (10043520) --------------------------------------------------------
char __cdecl sub_10043520(const void *a1)
{
  __int16 v2; // [sp+8h] [bp-530h]@1
  char v3; // [sp+Ch] [bp-52Ch]@1

  memset(&v2, 0, 0x528u);
  v2 = -32746;
  qmemcpy(&v3, a1, 0x11Cu);
  return sub_100477B0((int)&v2);
}

//----- (10043590) --------------------------------------------------------
int __cdecl sub_10043590(unsigned __int8 a1)
{
  void *v1; // ecx@1
  char v2; // bl@1
  char v4; // [sp+8h] [bp-120h]@1
  char v5; // [sp+27h] [bp-101h]@1

  memset(&v4, 0, 0x11Cu);
  sub_100464F0(a1, (int)&v4);
  v5 = 0;
  sub_10043520(&v4);
  v2 = sub_10045E30(v1);
  sub_100642E0(a1, SIM_intf + 24);
  *(_BYTE *)(SIM_intf + 320) = v2;
  return SIM_proc_rqst(49);
}
// 100642E0: using guessed type _DWORD __cdecl sub_100642E0(_DWORD, _DWORD);
// 1007DA32: using guessed type int __cdecl SIM_proc_rqst(_DWORD);

//----- (10043620) --------------------------------------------------------
char __cdecl sub_10043620(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // edx@1
  unsigned int v3; // eax@2
  int v4; // eax@3

  v2 = 0xFFFF;
  if ( a1 < 5u )
  {
    v3 = 4 * a1;
    if ( a2 < (unsigned __int16)word_1027BA50[v3] )
    {
      v4 = dword_1027BA4C[v3 / 2];
      if ( v4 )
        v2 = *(_WORD *)(v4 + 2 * a2);
    }
  }
  return sub_10047AC0(v2);
}
// 1027BA4C: using guessed type int dword_1027BA4C[];
// 1027BA50: using guessed type __int16 word_1027BA50[];

//----- (10043670) --------------------------------------------------------
char sub_10043670()
{
  char result; // al@1
  unsigned int v1; // ecx@1
  signed int v2; // edx@1
  unsigned int v3; // esi@3
  signed int v4; // edi@3

  result = 1;
  v1 = 0;
  v2 = 5;
  do
  {
    dword_1027BAF0[v1 / 4] = 0;
    word_1027BAF4[v1 / 2] = 0;
    dword_1027BA4C[v1 / 4] = 0;
    word_1027BA50[v1 / 2] = 0;
    v1 += 8;
    --v2;
  }
  while ( v2 );
  word_1027BAF4[0] = 23;
  word_1027BA50[0] = 23;
  word_1027BAFC = 21;
  word_1027BA58 = 21;
  word_1027BB04 = 3;
  word_1027BA60 = 3;
  word_1027BB0C = 3;
  word_1027BA68 = 3;
  dword_1027BAF0[0] = (int)&unk_1027B308;
  dword_1027BA4C[0] = (int)&unk_1027BA78;
  dword_1027BAF8 = (int)&unk_1027B5D1;
  dword_1027BA54 = (int)&unk_1027BAA6;
  dword_1027BB00 = (int)&unk_1027B85C;
  dword_1027BA5C = (int)&unk_1027BAD0;
  dword_1027BB08 = (int)&unk_1027B8B9;
  dword_1027BA64 = (int)&unk_1027BAD6;
  dword_1027BB10 = (int)&unk_1027B916;
  word_1027BB14 = 10;
  dword_1027BA6C = (int)&unk_1027BADC;
  word_1027BA70 = 10;
  v3 = 0;
  v4 = 5;
  do
  {
    if ( !dword_1027BAF0[v3 / 4] || !word_1027BAF4[v3 / 2] || !dword_1027BA4C[v3 / 4] || !word_1027BA50[v3 / 2] )
    {
      sub_10042930("..\\lib\\adl\\app_pof_intf.c", 679, 0, 0);
      result = 0;
    }
    v3 += 8;
    --v4;
  }
  while ( v4 );
  return result;
}
// 1027BA4C: using guessed type int dword_1027BA4C[];
// 1027BA50: using guessed type __int16 word_1027BA50[];
// 1027BA54: using guessed type int dword_1027BA54;
// 1027BA58: using guessed type __int16 word_1027BA58;
// 1027BA5C: using guessed type int dword_1027BA5C;
// 1027BA60: using guessed type __int16 word_1027BA60;
// 1027BA64: using guessed type int dword_1027BA64;
// 1027BA68: using guessed type __int16 word_1027BA68;
// 1027BA6C: using guessed type int dword_1027BA6C;
// 1027BA70: using guessed type __int16 word_1027BA70;
// 1027BAF0: using guessed type int dword_1027BAF0[];
// 1027BAF4: using guessed type __int16 word_1027BAF4[];
// 1027BAF8: using guessed type int dword_1027BAF8;
// 1027BAFC: using guessed type __int16 word_1027BAFC;
// 1027BB00: using guessed type int dword_1027BB00;
// 1027BB04: using guessed type __int16 word_1027BB04;
// 1027BB08: using guessed type int dword_1027BB08;
// 1027BB0C: using guessed type __int16 word_1027BB0C;
// 1027BB10: using guessed type int dword_1027BB10;
// 1027BB14: using guessed type __int16 word_1027BB14;

//----- (100437B0) --------------------------------------------------------
char sub_100437B0()
{
  unsigned __int8 v0; // al@2
  unsigned int v1; // esi@3
  unsigned __int8 v2; // bl@5
  char result; // al@13
  unsigned __int8 v4; // [sp+6h] [bp-A6h]@2
  char v5; // [sp+7h] [bp-A5h]@2
  int v6; // [sp+8h] [bp-A4h]@0
  __int16 v7; // [sp+Ch] [bp-A0h]@6

  if ( sub_1007C3B0(6799, (int)&unk_1027B308, 1860) )
  {
    sub_10042930("..\\lib\\adl\\app_pof_intf.c", 434, 0, 0);
    result = 0;
  }
  else
  {
    v5 = sub_10043670() & 1;
    v0 = 0;
    v4 = 0;
    do
    {
      v1 = 8 * v0;
      if ( dword_1027BAF0[v1 / 4] && dword_1027BA4C[v1 / 4] )
      {
        v2 = 0;
        if ( word_1027BAF4[v1 / 2] )
        {
          do
          {
            LOBYTE(v6) = v0 != 1;
            if ( sub_10047A30((int)&v7, dword_1027BAF0[v1 / 4] + 31 * v2, v6) )
              *(_WORD *)(dword_1027BA4C[v1 / 4] + 2 * v2) = v7;
            else
              *(_WORD *)(dword_1027BA4C[v1 / 4] + 2 * v2) = -1;
            v0 = v4;
            ++v2;
          }
          while ( v2 < (unsigned __int16)word_1027BAF4[v1 / 2] );
        }
      }
      else
      {
        v5 = 0;
      }
      v4 = ++v0;
    }
    while ( v0 < 5u );
    result = v5;
  }
  return result;
}
// 1027BA4C: using guessed type int dword_1027BA4C[];
// 1027BAF0: using guessed type int dword_1027BAF0[];
// 1027BAF4: using guessed type __int16 word_1027BAF4[];

//----- (100438F0) --------------------------------------------------------
char __cdecl sub_100438F0(int a1, char a2)
{
  char v2; // dl@1
  char result; // al@3
  unsigned __int8 v4; // cl@4
  unsigned __int8 v5; // cl@8
  unsigned __int8 v6; // cl@14
  unsigned __int8 v7; // cl@20

  v2 = 0;
  if ( a2 )
    v2 = *(_BYTE *)(a1 + 10);
  result = 15;
  if ( *(_BYTE *)(a1 + 9) )
  {
    v4 = *(_BYTE *)(a1 + 13);
    if ( v4 != 15 && (!v2 || v4 <= 1u) )
      result = *(_BYTE *)(a1 + 13);
    v5 = *(_BYTE *)(a1 + 14);
    if ( v5 != 15 && (!v2 || v5 <= 1u) && (result == 15 || (unsigned __int8)result < v5) )
      result = *(_BYTE *)(a1 + 14);
    v6 = *(_BYTE *)(a1 + 15);
    if ( v6 != 15 && (!v2 || v6 <= 1u) && (result == 15 || (unsigned __int8)result < v6) )
      result = *(_BYTE *)(a1 + 15);
    v7 = *(_BYTE *)(a1 + 16);
    if ( v7 != 15 && (!v2 || v7 <= 1u) && (result == 15 || (unsigned __int8)result < v7) )
      result = *(_BYTE *)(a1 + 16);
  }
  return result;
}

//----- (10043970) --------------------------------------------------------
signed int __cdecl sub_10043970(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // ebx@1
  signed int result; // eax@1
  _BYTE *v5; // esi@2
  _BYTE *v6; // edi@2

  v3 = a3;
  result = 0;
  if ( a3 > 0 )
  {
    v5 = a1;
    v6 = a2;
    while ( 1 )
    {
      if ( *v5 < *v6 )
        return -1;
      if ( *v5 > *v6 )
        break;
      --v3;
      --v5;
      --v6;
      if ( v3 <= 0 )
        return result;
    }
    result = 1;
  }
  return result;
}

//----- (100439B0) --------------------------------------------------------
signed int __cdecl sub_100439B0(int a1)
{
  signed int result; // eax@1

  result = 0x3FFFF;
  if ( a1 )
  {
    if ( *(_BYTE *)a1 < 0x17u )
      result = *(_DWORD *)(a1 + 36);
  }
  return result;
}

//----- (100439D0) --------------------------------------------------------
signed int __cdecl sub_100439D0(signed int a1)
{
  signed int result; // eax@2

  if ( a1 == 15 )
  {
    result = 0x3FFF;
  }
  else if ( a1 >= 14 )
  {
    result = 0;
  }
  else
  {
    result = (unsigned __int16)(1 << a1);
  }
  return result;
}

//----- (10043A00) --------------------------------------------------------
unsigned __int8 __cdecl sub_10043A00(const char *a1, int a2)
{
  int v2; // eax@3
  char v3; // cl@4
  _BYTE *v4; // esi@5
  signed int v5; // edi@5
  char v6; // cl@6
  unsigned __int8 result; // al@8
  char v8; // dl@17
  char v9; // dl@17
  char v10; // cl@18
  char v11[8]; // [sp+8h] [bp-Ch]@2

  if ( strlen(a1) > 6 )
  {
    v2 = 0;
    do
    {
      v3 = *((_BYTE *)&dword_100EBB80 + v2);
      v11[v2++] = v3;
    }
    while ( v3 );
  }
  else
  {
    strcpy(v11, a1);
    sub_10042190(v11, 6u, 32);
  }
  *(_DWORD *)a2 = 0;
  v4 = (_BYTE *)(a2 + 4);
  *(_BYTE *)(a2 + 4) = 0;
  v5 = 0;
  do
  {
    v6 = v11[v5];
    if ( (unsigned __int8)v6 < 0x41u || (unsigned __int8)v6 > 0x5Au )
    {
      if ( (unsigned __int8)v6 < 0x30u || (unsigned __int8)v6 > 0x39u )
        result = v6 == 32 ? 0 : v6;
      else
        result = v6 - 16;
    }
    else
    {
      result = v6 - 64;
    }
    if ( v5 & 3 )
    {
      if ( (v5 & 3) == 1 )
      {
        *v4 = (result >> 4) | *v4 & 0xFC;
        v10 = *(v4-- - 1);
        result *= 16;
        *v4 = result | v10 & 0xF;
        goto LABEL_21;
      }
      if ( (v5 & 3) != 2 )
      {
        *v4 = result | *v4 & 0xC0;
        --v4;
        goto LABEL_21;
      }
      *v4 = (result >> 2) | *v4 & 0xF0;
      v8 = *(v4-- - 1);
      v9 = v8 & 0x3F;
      result <<= 6;
    }
    else
    {
      v9 = *v4 & 3;
      result *= 4;
    }
    *v4 = result | v9;
LABEL_21:
    ++v5;
  }
  while ( v5 < 6 );
  return result;
}
// 100EBB80: using guessed type int dword_100EBB80;
// 10043A00: using guessed type char var_C[8];

//----- (10043B40) --------------------------------------------------------
double __cdecl sub_10043B40(signed int a1, char a2)
{
  return (double)(a1 >> (31 - a2)) / (double)(1 << a2) * 3.1415926535898;
}

//----- (10043B80) --------------------------------------------------------
bool __cdecl sub_10043B80(unsigned int a1, unsigned __int16 a2)
{
  unsigned int v2; // eax@2
  bool result; // al@5

  result = 0;
  if ( a2 < 0x96u )
  {
    v2 = 12 * a2;
    if ( a1 < dword_10333508[v2 / 4] && word_10333504[v2 / 2] && dword_10333500[v2 / 4] )
      result = 1;
  }
  return result;
}
// 10333500: using guessed type int dword_10333500[];
// 10333504: using guessed type __int16 word_10333504[];
// 10333508: using guessed type int dword_10333508[];

//----- (10043BC0) --------------------------------------------------------
char __usercall sub_10043BC0@<al>(unsigned int a1@<eax>)
{
  if ( a1 )
  {
    if ( a1 <= 0x1A )
      LOBYTE(a1) = a1 + 64;
  }
  else
  {
    LOBYTE(a1) = 32;
  }
  return a1;
}

//----- (10043BE0) --------------------------------------------------------
char __cdecl sub_10043BE0(char a1, char *a2, char *a3)
{
  char result; // al@1

  result = a1;
  if ( a1 != 63
    && (result = sub_10043B80((unsigned __int8)a1, 0x4Eu)) != 0
    && (result = sub_10043B80((unsigned __int8)a1, 0x4Fu)) != 0 )
  {
    strncpy(a2, (const char *)(dword_10333D50 + 25 * ((unsigned __int8)a1 + 448)), 0xFu);
    a2[15] = 0;
    sub_100423E0((int)a2, 0);
    strncpy(a3, (const char *)(dword_10333D50 + 25 * ((unsigned __int8)a1 + 512)), 7u);
    a3[7] = 0;
    result = sub_100423E0((int)a3, 0);
  }
  else
  {
    *a2 = 0;
    *a3 = 0;
  }
  return result;
}
// 10333D50: using guessed type int dword_10333D50;

//----- (10043C80) --------------------------------------------------------
char __cdecl sub_10043C80(int a1, int a2)
{
  int v2; // esi@1
  char *v3; // ebp@1
  unsigned int v4; // eax@1
  unsigned int v5; // eax@2
  int v6; // eax@3
  int v7; // eax@9
  __int16 v8; // ax@9
  double v9; // st7@10
  double v10; // st7@13
  unsigned __int8 v11; // al@15
  float v13; // [sp+18h] [bp+8h]@9
  float v14; // [sp+18h] [bp+8h]@11
  float v15; // [sp+18h] [bp+8h]@14

  v2 = a2;
  *(double *)(a2 + 96) = 6.2831853071796;
  *(double *)(a2 + 104) = 6.2831853071796;
  *(float *)(a2 + 64) = 9999.9004;
  *(double *)(a2 + 80) = 6.2831853071796;
  v3 = (char *)(a2 + 1);
  *(double *)(a2 + 88) = 6.2831853071796;
  *(_DWORD *)(a2 + 32) = 0;
  *(float *)(a2 + 48) = 0.0;
  *(_DWORD *)(a2 + 40) = 0;
  *(float *)(a2 + 56) = 0.0;
  *(_DWORD *)(a2 + 36) = 1000;
  *(_BYTE *)(a2 + 12) = 95;
  *(float *)(a2 + 52) = 80.0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)(a2 + 11) = 32;
  *(_DWORD *)(a2 + 44) = 0;
  *(float *)(a2 + 60) = 0.0;
  *(_DWORD *)(a2 + 20) = 0;
  *(float *)(a2 + 68) = 0.0;
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 76) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(_BYTE *)a2 = 0;
  *(_DWORD *)(a2 + 72) = 0;
  *(_WORD *)(a2 + 1) = 32;
  *(_WORD *)(a2 + 6) = 32;
  v4 = sub_1007B9F0((_BYTE *)a1, 36, 0);
  *(_DWORD *)(a2 + 72) = v4;
  *(_DWORD *)(a2 + 76) = *(_DWORD *)(a1 + 36);
  if ( v4 == *(_DWORD *)(a1 + 36) )
  {
    *(_BYTE *)a2 = 1;
    v5 = ((unsigned int)*(_BYTE *)(a1 + 5) >> 6) & 3;
    if ( v5 )
    {
      v6 = v5 - 1;
      if ( v6 )
      {
        if ( v6 == 1 )
          *(_BYTE *)(a2 + 12) = 67;
        else
          *(_BYTE *)(a2 + 12) = 76;
      }
      else
      {
        *(_BYTE *)(a2 + 12) = 82;
      }
    }
    else
    {
      *(_BYTE *)(a2 + 12) = 32;
    }
    *(_DWORD *)(a2 + 32) = *(_BYTE *)a1 & 0xF;
    *(_DWORD *)(a2 + 40) = (unsigned int)*(_BYTE *)a1 >> 4;
    *(_DWORD *)(a2 + 36) = *(_BYTE *)(a1 + 5) & 0x3F;
    *(_DWORD *)(a2 + 16) = *(_BYTE *)(a1 + 6) & 7;
    *(_DWORD *)(a2 + 44) = *(_BYTE *)(a1 + 7);
    *(double *)(a2 + 96) = (double)*(signed int *)(a1 + 12) * 0.0005 / 3600.0 * 0.01745329251994333;
    *(double *)(a2 + 104) = (double)*(signed int *)(a1 + 16) * 0.0005 / 3600.0 * 0.01745329251994333;
    v13 = (double)*(_WORD *)(a1 + 20) * 0.1;
    *(float *)(v2 + 64) = v13 - 512.0;
    v7 = *(_BYTE *)(a1 + 25) + (*(_WORD *)(a1 + 26) << 8);
    *(double *)(v2 + 80) = (double)(*(_DWORD *)(a1 + 12) + *(_BYTE *)(a1 + 22) + ((signed int)*(_WORD *)(a1 + 23) << 8))
                         * 0.0005
                         / 3600.0
                         * 0.01745329251994333;
    *(double *)(v2 + 88) = 0.01745329251994333 * (0.0005 * (double)(v7 + *(_DWORD *)(a1 + 16)) / 3600.0);
    v8 = *(_WORD *)(a1 + 28);
    if ( *(_WORD *)(a1 + 28) & 0x8000 )
    {
      v9 = (double)(v8 & 0x7FFF) * 0.05;
    }
    else
    {
      v14 = 0.1 * (double)(v8 & 0x7FFF);
      v9 = v14 * 0.3048000037670135;
    }
    *(float *)(v2 + 48) = v9;
    *(float *)(v2 + 56) = (double)*(_WORD *)(a1 + 30) * 0.009999999776482582 * 0.01745329238474369;
    if ( *(_BYTE *)(a1 + 5) & 0x3F )
    {
      v15 = (double)*(_BYTE *)(a1 + 32) * 0.25;
      v10 = v15 + 80.0;
    }
    else
    {
      v10 = 38.0;
    }
    *(float *)(v2 + 52) = v10;
    v11 = *(_BYTE *)(a1 + 33);
    if ( v11 == -1 )
      *(_DWORD *)(v2 + 28) = 0;
    else
      *(_DWORD *)(v2 + 28) = 8 * v11;
    *(float *)(v2 + 60) = (double)*(_BYTE *)(a1 + 34) * 0.2;
    *(float *)(v2 + 68) = 0.2 * (double)*(_BYTE *)(a1 + 35);
    *(_DWORD *)(v2 + 24) = *(_WORD *)(a1 + 40) + ((*(_BYTE *)(a1 + 42) & 1) << 16);
    *(_BYTE *)(v2 + 6) = sub_10043BC0(*(_BYTE *)(a1 + 11));
    *(_BYTE *)(v2 + 7) = sub_10043BC0(*(_BYTE *)(a1 + 10));
    *(_BYTE *)(v2 + 8) = sub_10043BC0(*(_BYTE *)(a1 + 9));
    *(_BYTE *)(v2 + 9) = sub_10043BC0(*(_BYTE *)(a1 + 8));
    *(_BYTE *)(v2 + 10) = 0;
    *v3 = sub_10043BC0(*(_BYTE *)(a1 + 4));
    *(_BYTE *)(v2 + 2) = sub_10043BC0(*(_BYTE *)(a1 + 3));
    *(_BYTE *)(v2 + 3) = sub_10043BC0(*(_BYTE *)(a1 + 2));
    *(_BYTE *)(v2 + 4) = sub_10043BC0(*(_BYTE *)(a1 + 1));
    *(_BYTE *)(v2 + 5) = 0;
    sub_100423E0(v2 + 1, 0);
    LOBYTE(v4) = sub_10043BC0((unsigned int)*(_WORD *)(a1 + 5) >> 11);
    *(_BYTE *)(v2 + 11) = v4;
  }
  return v4;
}

//----- (10043F80) --------------------------------------------------------
int __cdecl sub_10043F80(unsigned __int16 a1)
{
  unsigned __int16 v1; // dx@1
  int result; // eax@2

  if ( sub_10043B80(0, a1) )
    result = dword_10333508[3 * v1];
  else
    result = 0;
  return result;
}
// 10333508: using guessed type int dword_10333508[];

//----- (10043FB0) --------------------------------------------------------
bool __cdecl sub_10043FB0(unsigned int a1, unsigned __int16 a2)
{
  unsigned __int16 v2; // dx@1

  return sub_10043B80(0, a2) && a1 < 0xFFFFFF && a1 >= dword_10333500[3 * v2];
}
// 10333500: using guessed type int dword_10333500[];

//----- (10043FF0) --------------------------------------------------------
int __cdecl sub_10043FF0(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@6
  int v7; // ebx@6
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  _DWORD *v21; // esi@23
  unsigned int v22; // ecx@23
  _DWORD *v23; // edx@23
  int v24; // edi@27
  int v25; // ecx@28
  _BYTE *v26; // edx@28
  _BYTE *v27; // esi@28
  int v28; // ecx@30
  _BYTE *v29; // edx@30
  _BYTE *v30; // esi@30
  _BYTE *v31; // edx@32
  _BYTE *v32; // esi@32
  int v33; // edx@33
  signed int v34; // ecx@34
  int v35; // [sp+4h] [bp-4h]@6

  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && a5 > 0 )
  {
    result = a5 - 1;
    v7 = a3 + a4 * (a5 - 1);
    v35 = a5 - 1;
    if ( a5 - 1 > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v35;
        if ( v20 )
        {
          v7 -= a4;
          result = v35 - 1;
          v35 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a1;
    v22 = a2;
    v23 = (_DWORD *)v7;
    if ( a2 < 4 )
    {
LABEL_26:
      if ( !v22 )
        goto LABEL_36;
    }
    else
    {
      while ( *v21 == *v23 )
      {
        v22 -= 4;
        ++v23;
        ++v21;
        if ( v22 < 4 )
          goto LABEL_26;
      }
    }
    v24 = *(_BYTE *)v21 - *(_BYTE *)v23;
    if ( *(_BYTE *)v21 != *(_BYTE *)v23
      || (v25 = v22 - 1, v26 = (char *)v23 + 1, v27 = (char *)v21 + 1, v25)
      && ((v24 = *v27 - *v26, *v27 != *v26)
       || (v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, v28)
       && ((v24 = *v30 - *v29, *v30 != *v29)
        || (v31 = v29 + 1, v32 = v30 + 1, v28 != 1) && (v33 = *v31, v24 = *v32 - v33, *v32 != v33))) )
    {
      v34 = 1;
      if ( v24 <= 0 )
        v34 = -1;
LABEL_37:
      if ( !v34 )
        return result;
      return a6;
    }
LABEL_36:
    v34 = 0;
    goto LABEL_37;
  }
  return a6;
}

//----- (10044180) --------------------------------------------------------
int __cdecl sub_10044180(_DWORD *a1, unsigned int a2, int a3, int a4, int a5)
{
  int v5; // edx@1
  int result; // eax@1
  int v7; // ebx@1
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  unsigned int v21; // edx@23
  char *i; // ecx@23
  int v23; // [sp+20h] [bp+14h]@1

  v5 = a5;
  result = a5 - 1;
  v7 = a3 + a4 * (a5 - 1);
  v23 = a5 - 1;
  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && v5 > 0 )
  {
    if ( result > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v23;
        if ( v20 )
        {
          v7 -= a4;
          result = v23 - 1;
          v23 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a2;
    for ( i = (char *)v7; v21 >= 4; i += 4 )
    {
      if ( *(_DWORD *)&i[(_DWORD)a1 - v7] != *(_DWORD *)i )
        break;
      v21 -= 4;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100442A0) --------------------------------------------------------
unsigned int __cdecl sub_100442A0(int a1, int a2, size_t a3, int a4, int a5)
{
  int v5; // ecx@1
  unsigned int result; // eax@1
  int v7; // ebp@4
  int v8; // ebx@4
  int v9; // esi@6
  char *v10; // ebx@7
  char *v11; // [sp+0h] [bp-190h]@5
  char *v12; // [sp+4h] [bp-18Ch]@7
  char *v13; // [sp+8h] [bp-188h]@5
  int v14; // [sp+10h] [bp-180h]@4
  int v15; // [sp+14h] [bp-17Ch]@3
  size_t v16; // [sp+1Ch] [bp-174h]@5
  char v17; // [sp+24h] [bp-16Ch]@6

  v5 = a1;
  result = a4;
  if ( a1 && (signed int)a3 <= 360 )
  {
    result = 0;
    v15 = 0;
    do
    {
      v7 = *(int *)((char *)&dword_100F8F18 + result);
      v8 = *(int *)((char *)&dword_100F8F18 + result);
      v14 = *(int *)((char *)&dword_100F8F18 + result);
      if ( v7 < a2 )
      {
        v16 = a3 * v7;
        v11 = (char *)(v5 + a3 * v7);
        v13 = (char *)v5;
        do
        {
          memcpy(&v17, v11, a3);
          v9 = v8;
          if ( v8 >= v7 )
          {
            v10 = v13;
            v12 = v11;
            do
            {
              if ( ((int (__cdecl *)(char *, char *, int))a4)(&v17, v10, a5) >= 0 )
                break;
              memcpy(v12, v10, a3);
              v12 -= v16;
              v9 -= v7;
              v10 -= v16;
            }
            while ( v9 >= v7 );
            v8 = v14;
          }
          memcpy((void *)(a1 + a3 * v9), &v17, a3);
          v11 += a3;
          v13 += a3;
          v14 = ++v8;
        }
        while ( v8 < a2 );
        result = v15;
        v5 = a1;
      }
      result += 4;
      v15 = result;
    }
    while ( result < 0x40 );
  }
  return result;
}
// 100F8F18: using guessed type int dword_100F8F18;

//----- (10044420) --------------------------------------------------------
unsigned int __cdecl sub_10044420(int a1, int a2, size_t a3, int a4)
{
  return sub_100442A0(a1, a2, a3, (int)sub_10044400, a4);
}
// 10044400: using guessed type int sub_10044400();

//----- (10044450) --------------------------------------------------------
int __cdecl sub_10044450(float a1, char *a2)
{
  double v2; // st7@1
  int result; // eax@5

  v2 = a1;
  if ( (LODWORD(a1) & 0x7F800000) == 2139095040 || v2 > 10.01 || v2 < 0.0099999998 || -1.0 == v2 )
    result = sub_100421E0((int)a2, &unk_100F9480, 8);
  else
    result = sub_10042370(a2, 8u, "RNP%0.*f", 2, a1);
  return result;
}

//----- (100444D0) --------------------------------------------------------
double sub_100444D0()
{
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v1 = 9.8999998e24;
  sub_1007C470(10043, &v2, 4, &v1);
  return v2;
}

//----- (10044500) --------------------------------------------------------
double sub_10044500()
{
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v1 = 9.8999998e24;
  sub_1007C470(10002, &v2, 4, &v1);
  return v2;
}

//----- (10044530) --------------------------------------------------------
int __cdecl sub_10044530(float a1)
{
  int result; // eax@2

  if ( a1 >= 0.0 )
  {
    result = sub_1007C500(10043, (int)&a1, 4);
  }
  else
  {
    a1 = 0.0;
    result = sub_1007C500(10043, (int)&a1, 4);
  }
  return result;
}

//----- (10044570) --------------------------------------------------------
void __usercall sub_10044570(int a1@<esi>, int a2, float a3)
{
  signed int v3; // ebx@1
  int v4; // ecx@1
  int v5; // edx@1
  double v6; // st7@3
  double v7; // st6@4
  double v8; // st6@5
  double v9; // st7@5
  double v10; // st6@8
  double v11; // st7@8
  int v12; // edi@10
  signed int v13; // ecx@10
  int v14; // ebx@11
  signed int v15; // edx@11
  int v16; // ebp@13
  float *v17; // eax@19
  int v18; // [sp+4h] [bp-4h]@13
  float *v19; // [sp+10h] [bp+8h]@11
  float v20; // [sp+10h] [bp+8h]@19

  v3 = *(_BYTE *)(a1 + 320);
  v4 = v3 - 1;
  v5 = 0;
  if ( *(float *)(a1 + 8 * v3 - 4) < (double)*(float *)(a1 + 4) )
  {
    v5 = v3 - 1;
    v4 = 0;
  }
  v6 = a3;
  if ( *(float *)(a1 + 8 * v4 + 4) < (double)a3 )
  {
    v7 = 0.0;
    if ( 0.0 != v6 )
    {
      v8 = *(float *)(a1 + 8 * v4) / v6;
      v9 = 0.0;
      *(float *)a2 = v8;
      *(float *)(a2 + 4) = *(float *)&v9;
      return;
    }
LABEL_9:
    *(float *)a2 = v7;
    *(float *)(a2 + 4) = v7;
    return;
  }
  if ( *(float *)(a1 + 8 * v5 + 4) > v6 )
  {
    v7 = 0.0;
    if ( 0.0 != v6 )
    {
      v10 = *(float *)(a1 + 8 * v5) / v6;
      v11 = 0.0;
      *(float *)a2 = v10;
      *(float *)(a2 + 4) = *(float *)&v11;
      return;
    }
    goto LABEL_9;
  }
  v12 = 0;
  v13 = 1;
  if ( v3 <= 1 )
  {
LABEL_18:
    *(float *)a2 = 0.0;
    *(float *)(a2 + 4) = *(float *)(a1 + 8 * v12);
  }
  else
  {
    v14 = 0;
    v15 = 8;
    v19 = (float *)(a1 + 12);
    while ( 1 )
    {
      if ( *(float *)(v14 + a1 + 4) >= (double)*v19 )
      {
        v12 = v13 - 1;
        v14 = v15 - 8;
        v16 = v13;
        v18 = v15;
      }
      else
      {
        v12 = v13;
        v14 = v15;
        v16 = v13 - 1;
        v18 = v15 - 8;
      }
      if ( *(float *)(v14 + a1 + 4) > v6 && *(float *)(v18 + a1 + 4) <= v6 )
        break;
      v19 += 2;
      ++v13;
      v15 += 8;
      if ( v13 >= *(_BYTE *)(a1 + 320) )
        goto LABEL_18;
    }
    v17 = (float *)(a1 + 8 * v12 + 4);
    v20 = (*(float *)(a1 + 8 * v12) - *(float *)(a1 + 8 * v16)) / (*v17 - *(float *)(a1 + 8 * v16 + 4));
    *(float *)a2 = v20;
    *(float *)(a2 + 4) = *(float *)(a1 + 8 * v12) - v20 * *v17;
  }
}

//----- (100446D0) --------------------------------------------------------
char __usercall sub_100446D0@<al>(float *a1@<edi>, unsigned __int16 a2@<si>, unsigned __int8 a3)
{
  double v3; // st7@8
  char result; // al@10
  char v5; // [sp+7h] [bp-29h]@3
  float v6; // [sp+8h] [bp-28h]@1
  float v7; // [sp+Ch] [bp-24h]@3
  int v8; // [sp+10h] [bp-20h]@1
  int v9; // [sp+14h] [bp-1Ch]@1
  int v10; // [sp+18h] [bp-18h]@1
  int v11; // [sp+1Ch] [bp-14h]@1
  float v12[4]; // [sp+20h] [bp-10h]@1

  v6 = 0.0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  if ( sub_1007C470(6117, v12, 16, &v8) )
    sub_10042930("..\\lib\\adl\\iop_eis_intf.c", 2716, 0, 0);
  sub_10024A50(1, 0x50u, &v5);
  if ( sub_1007C4B0(6354, (int)&v7, 4) )
    sub_10042930("..\\lib\\adl\\iop_eis_intf.c", 2735, 0, 0);
  if ( (sub_10063C40(a2) || v5) && sub_1003D430(a2, &v6) )
  {
    v6 = v12[2 * a3] * v6;
    v3 = v6;
    *a1 = v6;
    if ( v7 > v3 )
      *a1 = 0.0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100446D0: using guessed type float var_10[4];

//----- (100447C0) --------------------------------------------------------
char __usercall sub_100447C0@<al>(unsigned __int16 *a1@<eax>, int a2, float *a3, unsigned __int8 a4)
{
  int v4; // ecx@1
  unsigned __int16 *v5; // esi@1
  char v6; // al@1
  double v7; // st7@1
  int v8; // ebp@1
  unsigned __int8 v9; // bl@4
  char result; // al@7
  int v11; // eax@9
  unsigned __int16 *v12; // edi@9
  int v13; // eax@11
  int v14; // eax@14
  int v15; // eax@17
  double v16; // st7@22
  double v17; // st7@24
  int v18; // edi@31
  int v19; // [sp-8h] [bp-A0h]@12
  int v20; // [sp-4h] [bp-9Ch]@12
  float v21; // [sp+0h] [bp-98h]@12
  float v22; // [sp+14h] [bp-84h]@1
  float v23; // [sp+18h] [bp-80h]@1
  int v24; // [sp+1Ch] [bp-7Ch]@1
  int v25; // [sp+20h] [bp-78h]@5
  float v26; // [sp+24h] [bp-74h]@6
  float v27; // [sp+28h] [bp-70h]@9
  float v28; // [sp+2Ch] [bp-6Ch]@9
  float v29; // [sp+38h] [bp-60h]@10
  float v30; // [sp+3Ch] [bp-5Ch]@11
  float v31; // [sp+48h] [bp-50h]@13
  float v32; // [sp+4Ch] [bp-4Ch]@14
  float v33; // [sp+70h] [bp-28h]@16
  float v34; // [sp+74h] [bp-24h]@17

  v4 = a2;
  v5 = a1;
  *a3 = -1.0;
  v6 = *(_BYTE *)(a2 + 320);
  v7 = 0.0;
  v8 = 0;
  v22 = 0.0;
  v23 = 0.0;
  v24 = 0;
  if ( !v6 || v6 == 1 && 0.0 == *(float *)a2 )
  {
    if ( a4 )
    {
      v18 = a4;
      do
      {
        if ( sub_10063C40(*v5) )
        {
          ++v8;
          if ( sub_1003D5D0((int)v5, *v5, &v22) )
          {
            ++v24;
            v23 = v23 + v22;
          }
        }
        ++v5;
        --v18;
      }
      while ( v18 );
      if ( v8 != v24 )
        goto LABEL_42;
    }
    *a3 = v23;
    if ( v8 <= 0 )
LABEL_42:
      result = 0;
    else
      result = 1;
    return result;
  }
  v9 = 0;
  if ( !a4 )
    goto LABEL_5;
  while ( 2 )
  {
    v28 = v7;
    v11 = v5[v9];
    v27 = v7;
    v12 = &v5[v9];
    switch ( v11 )
    {
      case 58:
      case 59:
        if ( !sub_1007C3B0(6091, (int)&v29, 16) )
        {
          v13 = 8 * *v12 - 464;
          v28 = *(float *)((char *)&v29 + v13);
          v27 = *(float *)((char *)&v30 + v13);
          goto LABEL_20;
        }
        v21 = 0.0;
        v20 = 0;
        v19 = 2889;
        goto LABEL_19;
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
        if ( !sub_1007C3B0(6090, (int)&v31, 40) )
        {
          v14 = 8 * *v12 - 480;
          v28 = *(float *)((char *)&v31 + v14);
          v27 = *(float *)((char *)&v32 + v14);
          goto LABEL_20;
        }
        v21 = 0.0;
        v20 = 0;
        v19 = 2921;
        goto LABEL_19;
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
        if ( sub_1007C3B0(6092, (int)&v33, 40) )
        {
          v21 = 0.0;
          v20 = 0;
          v19 = 2953;
LABEL_19:
          sub_10042930("..\\lib\\adl\\iop_eis_intf.c", v19, v20, (char *)LODWORD(v21));
        }
        else
        {
          v15 = 8 * *v12 - 520;
          v28 = *(float *)((char *)&v33 + v15);
          v27 = *(float *)((char *)&v34 + v15);
        }
LABEL_20:
        if ( sub_10063C40(*v12) )
        {
          ++v8;
          if ( sub_1003D430(*v12, &v22) )
          {
            v16 = v22;
            if ( v27 >= (double)v22 )
              v16 = v27;
            v22 = v16;
            v17 = v22;
            if ( v28 <= (double)v22 )
              v17 = v28;
            ++v24;
            v22 = v17;
            v23 = v22 + v23;
          }
        }
        if ( ++v9 < a4 )
        {
          v7 = 0.0;
          continue;
        }
        v4 = a2;
LABEL_5:
        sub_10044570(v4, (int)&v25, v23);
        if ( v8 != v24 || (*a3 = *(float *)&v25 * v23 + v26, v8 <= 0) )
LABEL_29:
          result = 0;
        else
          result = 1;
        return result;
      default:
        goto LABEL_29;
    }
  }
}

//----- (10044AA0) --------------------------------------------------------
char __cdecl sub_10044AA0(float *a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-144h]@1

  if ( sub_1007C3B0(6266, (int)&v2, 324) )
  {
    sub_10042930("..\\lib\\adl\\iop_eis_intf.c", 590, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_100447C0((unsigned __int16 *)&unk_100FA304, (int)&v2, a1, 2u);
  }
  return result;
}

//----- (10044B10) --------------------------------------------------------
char __cdecl sub_10044B10(float *a1)
{
  return sub_100446D0(a1, 0x14u, 0);
}

//----- (10044B30) --------------------------------------------------------
char __cdecl sub_10044B30(float *a1)
{
  return sub_100446D0(a1, 0x2Du, 1u);
}

//----- (10044B50) --------------------------------------------------------
char __cdecl sub_10044B50(float *a1)
{
  char v1; // bl@1
  char result; // al@4
  float v3; // [sp+4h] [bp-8h]@1
  float v4; // [sp+8h] [bp-4h]@1

  v3 = 0.0;
  v4 = 0.0;
  v1 = 0;
  if ( sub_10044B10(&v3) )
  {
    v1 = 1;
    v4 = v3 + 0.0;
  }
  if ( sub_10044B30(&v3) )
  {
    result = 1;
    v4 = v4 + v3;
    *a1 = v4;
  }
  else if ( v1 )
  {
    result = v1;
    *a1 = v4;
  }
  else
  {
    *a1 = 9.8999998e24;
    result = 0;
  }
  return result;
}

//----- (10044BE0) --------------------------------------------------------
char __cdecl sub_10044BE0(float *a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-144h]@1

  if ( sub_1007C3B0(6265, (int)&v2, 324) )
  {
    sub_10042930("..\\lib\\adl\\iop_eis_intf.c", 1606, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_100447C0(L"<=>?@", (int)&v2, a1, 5u);
  }
  return result;
}
// 100FA310: using guessed type wchar_t a__[6];

//----- (10044C50) --------------------------------------------------------
char __cdecl sub_10044C50(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  const wchar_t *v3; // esi@3
  int v4; // [sp+4h] [bp-154h]@5
  char v5[4]; // [sp+8h] [bp-150h]@5
  int v6; // [sp+Ch] [bp-14Ch]@5
  char v7; // [sp+10h] [bp-148h]@6
  char v8; // [sp+14h] [bp-144h]@1

  v1 = 0;
  if ( sub_1007C3B0(6266, (int)&v8, 324) )
  {
    sub_10042930("..\\lib\\adl\\iop_eis_intf.c", 1847, 0, "Center cal points undefined");
    result = 0;
  }
  else
  {
    v3 = L":;<=>?@";
    while ( !v1 )
    {
      LOWORD(v4) = *v3;
      v1 = sub_10062ED0(v4, v5, &v6);
      if ( v1 )
        v1 = sub_100253C0(v5[0], v6, &v7);
      ++v3;
      if ( (signed int)v3 >= (signed int)L"\u3b00\u3c00\u3d00\u3e00\u3f00\u4000" )
      {
        if ( !v1 )
          goto LABEL_10;
        break;
      }
    }
    v1 = sub_100447C0((unsigned __int16 *)&v4, (int)&v8, a1, 1u);
LABEL_10:
    result = v1;
  }
  return result;
}
// 100FA31C: using guessed type wchar_t a___0[8];

//----- (10044D20) --------------------------------------------------------
char __cdecl sub_10044D20(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  wchar_t *v3; // esi@3
  int v4; // [sp+4h] [bp-154h]@5
  char v5[4]; // [sp+8h] [bp-150h]@5
  int v6; // [sp+Ch] [bp-14Ch]@5
  char v7; // [sp+10h] [bp-148h]@6
  char v8; // [sp+14h] [bp-144h]@1

  v1 = 0;
  if ( sub_1007C3B0(6265, (int)&v8, 324) )
  {
    sub_10042930("..\\lib\\adl\\iop_eis_intf.c", 1946, 0, "Left cal points undefined");
    result = 0;
  }
  else
  {
    v3 = L"\u3b00\u3c00\u3d00\u3e00\u3f00\u4000";
    while ( !v1 )
    {
      LOWORD(v4) = *v3;
      v1 = sub_10062ED0(v4, v5, &v6);
      if ( v1 )
        v1 = sub_100253C0(v5[0], v6, &v7);
      ++v3;
      if ( (signed int)v3 >= (signed int)&a___0[7] )
      {
        if ( !v1 )
          goto LABEL_10;
        break;
      }
    }
    v1 = sub_100447C0((unsigned __int16 *)&v4, (int)&v8, a1, 1u);
LABEL_10:
    result = v1;
  }
  return result;
}
// 100FA31C: using guessed type wchar_t a___0[8];

//----- (10044DF0) --------------------------------------------------------
char __cdecl sub_10044DF0(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  const wchar_t *v3; // esi@3
  int v4; // [sp+4h] [bp-154h]@5
  char v5[4]; // [sp+8h] [bp-150h]@5
  int v6; // [sp+Ch] [bp-14Ch]@5
  char v7; // [sp+10h] [bp-148h]@6
  char v8; // [sp+14h] [bp-144h]@1

  v1 = 0;
  if ( sub_1007C3B0(6267, (int)&v8, 324) )
  {
    sub_10042930("..\\lib\\adl\\iop_eis_intf.c", 2045, 0, "Right cal points undefined");
    result = 0;
  }
  else
  {
    v3 = L"ABCDE";
    while ( !v1 )
    {
      LOWORD(v4) = *v3;
      v1 = sub_10062ED0(v4, v5, &v6);
      if ( v1 )
        v1 = sub_100253C0(v5[0], v6, &v7);
      ++v3;
      if ( (signed int)v3 >= (signed int)&aAbcde_0[5] )
      {
        if ( !v1 )
          goto LABEL_10;
        break;
      }
    }
    v1 = sub_100447C0((unsigned __int16 *)&v4, (int)&v8, a1, 1u);
LABEL_10:
    result = v1;
  }
  return result;
}
// 100FA32C: using guessed type wchar_t aAbcde_0[6];

//----- (10044EC0) --------------------------------------------------------
char __cdecl sub_10044EC0(float *a1)
{
  char v1; // bl@1
  char result; // al@6
  float v3; // [sp+4h] [bp-8h]@1
  float v4; // [sp+8h] [bp-4h]@1

  v3 = 0.0;
  v4 = 0.0;
  v1 = 0;
  if ( sub_10044C50(&v3) )
  {
    v1 = 1;
    v4 = v3 + 0.0;
  }
  if ( sub_10044D20(&v3) )
  {
    v1 = 1;
    v4 = v4 + v3;
  }
  if ( sub_10044DF0(&v3) )
  {
    v4 = v4 + v3;
    *a1 = v4;
    result = 1;
  }
  else
  {
    if ( v1 )
      *a1 = v4;
    result = v1;
  }
  return result;
}

//----- (10044F60) --------------------------------------------------------
char __cdecl sub_10044F60(float *a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-144h]@1

  if ( sub_1007C3B0(6267, (int)&v2, 324) )
  {
    sub_10042930("..\\lib\\adl\\iop_eis_intf.c", 2199, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_100447C0(L"ABCDE", (int)&v2, a1, 5u);
  }
  return result;
}
// 100FA338: using guessed type wchar_t aAbcde[6];

//----- (10044FD0) --------------------------------------------------------
double sub_10044FD0()
{
  int v0; // eax@1
  double result; // st7@1
  float v2; // [sp+0h] [bp-10h]@1
  float v3; // [sp+4h] [bp-Ch]@1
  double v4; // [sp+8h] [bp-8h]@2

  v3 = 9.8999998e24;
  v0 = sub_1007C470(10009, &v2, 4, &v3);
  result = v2;
  if ( !v0 )
  {
    v4 = v2;
    v2 = v4 - sub_10044500();
    if ( v2 >= 0.0 )
    {
      result = v2;
    }
    else
    {
      v2 = 0.0;
      result = (float)0.0;
    }
  }
  return result;
}

//----- (10045030) --------------------------------------------------------
char __cdecl sub_10045030(float *a1)
{
  char v1; // bl@1
  char result; // al@6
  float v3; // [sp+4h] [bp-8h]@1
  float v4; // [sp+8h] [bp-4h]@1

  v3 = 0.0;
  v4 = 0.0;
  v1 = 0;
  if ( sub_10044BE0(&v3) )
  {
    v1 = 1;
    v4 = v3 + 0.0;
  }
  if ( sub_10044AA0(&v3) )
  {
    v1 = 1;
    v4 = v4 + v3;
  }
  if ( sub_10044F60(&v3) )
  {
    v4 = v4 + v3;
    *a1 = v4;
    result = 1;
  }
  else
  {
    if ( v1 )
      *a1 = v4;
    result = v1;
  }
  return result;
}

//----- (100450D0) --------------------------------------------------------
int __cdecl sub_100450D0(char a1)
{
  return 9190 - (a1 != 1);
}

//----- (100450E0) --------------------------------------------------------
int __usercall sub_100450E0@<eax>(char *a1@<eax>, char a2@<cl>)
{
  return sub_100642F0(a2, a1);
}

//----- (100450F0) --------------------------------------------------------
char __usercall sub_100450F0@<al>(char a1@<bl>, char a2)
{
  int v2; // eax@1
  char result; // al@2
  char *v4; // ecx@3
  unsigned __int8 v5; // [sp+4h] [bp-8Ch]@1
  char v6; // [sp+5h] [bp-8Bh]@2
  char v7[68]; // [sp+48h] [bp-48h]@1

  memset(&v5, 0, 0x43u);
  memset(v7, 0, 0x43u);
  sub_100450E0((char *)&v5, a2);
  v2 = sub_100450D0(a1);
  if ( sub_1007C3B0(v2, (int)v7, 67) )
  {
    result = a1 == 1;
  }
  else
  {
    result = v7[v5];
    if ( v6 != 67 )
    {
      v4 = &v6;
      do
        ++v4;
      while ( *v4 != 67 );
    }
  }
  return result;
}
// 100450F0: using guessed type char var_48[68];

//----- (100451B0) --------------------------------------------------------
char __usercall sub_100451B0@<al>(char a1@<dl>, char a2@<cl>, char a3)
{
  int v4; // [sp+0h] [bp-Ch]@1
  __int16 v5; // [sp+4h] [bp-8h]@1
  char v6; // [sp+6h] [bp-6h]@1

  v4 = 0;
  LOBYTE(v5) = a3;
  LOWORD(v4) = -32706;
  HIBYTE(v5) = a2;
  v6 = a1;
  return sub_100477A0((int)&v4);
}

//----- (10045200) --------------------------------------------------------
char __cdecl sub_10045200(char a1, char a2)
{
  return sub_100450F0(a1, a2);
}

//----- (10045220) --------------------------------------------------------
char __cdecl sub_10045220(char a1, char a2)
{
  void *v2; // ecx@1
  char v3; // al@1

  sub_100451B0(0, a2, a1);
  v3 = sub_10045280(v2);
  return sub_10045200(v3, a1);
}

//----- (10045250) --------------------------------------------------------
char __cdecl sub_10045250(char a1)
{
  char result; // al@1

  result = sub_10064340();
  if ( result == 2 )
    result = byte_100FB3FC[8 * sub_10043FF0(&a1, 4u, (int)&unk_100FB3F8, 8, 7, 7)];
  return result;
}

//----- (10045280) --------------------------------------------------------
char __thiscall sub_10045280(void *this)
{
  char v1; // al@1

  v1 = sub_100429D0(this);
  return sub_10045250(v1);
}

//----- (10045290) --------------------------------------------------------
char sub_10045290()
{
  char result; // al@1
  void *v1; // ecx@1
  int v2; // [sp+0h] [bp-4h]@1

  v2 = 0;
  result = sub_10064350();
  if ( result == 3 )
  {
    v2 = sub_100429D0(v1);
    result = byte_100FB3C4[8 * sub_10043FF0(&v2, 4u, (int)&unk_100FB3C0, 8, 7, 7)];
  }
  return result;
}

//----- (100452D0) --------------------------------------------------------
void __cdecl sub_100452D0(float a1, int a2)
{
  double v2; // st7@1

  v2 = a1;
  if ( a1 < 11000.232 )
    *(float *)a2 = pow(v2 * -0.0065 / 288.1499938964844 + 1.0, 5.255880147586614) * 101325.0;
  else
    *(float *)a2 = exp((v2 - 11000.232421875) * -0.0001576885406393558) * 22631.953125;
}

//----- (10045330) --------------------------------------------------------
char __cdecl sub_10045330(float a1, int a2)
{
  double v2; // st7@1
  long double v3; // st7@1
  char result; // al@2
  float v5; // [sp+4h] [bp+4h]@1
  float v6; // [sp+4h] [bp+4h]@4
  float v7; // [sp+4h] [bp+4h]@5

  v2 = a1;
  v5 = a1 / 101325.0;
  v3 = v2 / 22631.953125;
  if ( v3 > 0.0 )
  {
    if ( v5 <= 0.223360002040863 )
    {
      v7 = log(v3);
      result = 1;
      *(float *)a2 = 11000.232421875 - v7 * 6341.615234375;
    }
    else
    {
      v6 = pow(v5, 0.1902630904662425);
      result = 1;
      *(float *)a2 = (v6 - 1.0) * -44330.76953125;
    }
  }
  else
  {
    *(float *)a2 = 9.8999998e24;
    result = 0;
  }
  return result;
}

//----- (100453D0) --------------------------------------------------------
void __cdecl sub_100453D0(float a1, float a2, int a3)
{
  float v3; // ecx@0
  float v4; // [sp+8h] [bp-4h]@1

  v4 = v3;
  sub_100452D0(a2, (int)&v4);
  *(float *)a3 = sqrt((pow(
                         (pow(a1 * a1 * 0.000001727115545691049 + 1.0, 3.500000238418579) - 1.0) * (101325.0 / v4) + 1.0,
                         0.2857142686843872)
                     - 1.0) * 5.000000476837158);
}

//----- (10045440) --------------------------------------------------------
void __cdecl sub_10045440(float a1, float a2, int a3)
{
  float v3; // ecx@0
  float v4; // [sp+8h] [bp-4h]@1

  v4 = v3;
  sub_100452D0(a2, (int)&v4);
  *(float *)a3 = sqrt((pow(
                         (pow(a1 * a1 * 0.199999988079071 + 1.0, 3.500000238418579) - 1.0) * (v4 / 101325.0) + 1.0,
                         0.2857142686843872)
                     - 1.0) * 579000.0625);
}

//----- (100454B0) --------------------------------------------------------
double __cdecl sub_100454B0(float a1, float a2, int a3, float a4)
{
  double v4; // st7@2
  double v5; // st7@4
  bool v6; // c0@5
  double v7; // st7@5
  double v9; // st5@7
  bool v10; // c0@7
  bool v11; // c3@7
  float v12; // [sp+8h] [bp-8h]@4
  float v13; // [sp+Ch] [bp-4h]@4
  int v14; // [sp+1Ch] [bp+Ch]@4
  int v15; // [sp+1Ch] [bp+Ch]@4
  int v16; // [sp+1Ch] [bp+Ch]@4
  int v17; // [sp+1Ch] [bp+Ch]@9

  if ( (unsigned __int8)a3 <= 0x64u )
    v4 = (double)(unsigned __int8)a3;
  else
    v4 = 100.0;
  *(float *)&v14 = v4;
  *(float *)&v15 = *(float *)&v14 / 100.0 * a4;
  v12 = (*(float *)&v15 + a4) * 0.5;
  v13 = sub_1007BB10(a1, a4);
  *(float *)&v16 = sub_1007BA30(a1, a4);
  v5 = a1;
  if ( a1 < (double)a2 )
  {
    v9 = *(float *)&v16 - v12;
    v10 = v9 < v5;
    v11 = v9 == v5;
    v7 = *(float *)&v16;
    if ( !v10 && !v11 )
      v7 = v13;
  }
  else
  {
    v6 = v13 + v12 < v5;
    v7 = v13;
    if ( v6 )
      return *(float *)&v16;
  }
  *(float *)&v17 = v7;
  return *(float *)&v17;
}

//----- (10045590) --------------------------------------------------------
char __cdecl sub_10045590(int a1, void *a2)
{
  char v3[68]; // [sp+4h] [bp-48h]@1

  sub_1007C3B0(9190, (int)v3, 67);
  return sub_1003F7A0(a1, v3[(unsigned __int8)a1], a2);
}
// 10045590: using guessed type char var_48[68];

//----- (100455E0) --------------------------------------------------------
char __cdecl sub_100455E0(int a1, void *a2)
{
  char v3[68]; // [sp+4h] [bp-48h]@1

  sub_1007C3B0(9189, (int)v3, 67);
  return sub_1003F7A0(a1, v3[(unsigned __int8)a1], a2);
}
// 100455E0: using guessed type char var_48[68];

//----- (10045630) --------------------------------------------------------
bool __cdecl sub_10045630(int a1, void *a2, int a3)
{
  unsigned __int16 v3; // ax@2
  bool result; // al@5
  char v5[4]; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v5[0] = -1;
  v6 = 0;
  result = 0;
  if ( sub_10064360(a1, a3, v5, &v6) == 1 )
  {
    v3 = sub_100246D0(v5[0]);
    if ( (unsigned __int16)v6 < v3 && sub_100253C0(v5[0], v6, a2) && !sub_100543D0(a2, 0, 0) )
      result = 1;
  }
  return result;
}

//----- (100456B0) --------------------------------------------------------
bool __cdecl sub_100456B0(int a1, void *a2, int a3)
{
  unsigned __int16 v3; // ax@2
  bool result; // al@5
  char v5[4]; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v5[0] = -1;
  v6 = 0;
  result = 0;
  if ( sub_100643C0(a1, a3, v5, &v6) == 1 )
  {
    v3 = sub_100246D0(v5[0]);
    if ( (unsigned __int16)v6 < v3 && sub_100253C0(v5[0], v6, a2) && !sub_100543D0(a2, 0, 0) )
      result = 1;
  }
  return result;
}

//----- (10045730) --------------------------------------------------------
char __cdecl sub_10045730(unsigned __int16 a1)
{
  char result; // al@3
  char v2; // [sp+Bh] [bp-9h]@3
  int v3; // [sp+Ch] [bp-8h]@1
  int v4; // [sp+10h] [bp-4h]@1

  LOBYTE(v4) = 7;
  v3 = 0;
  if ( sub_10064360(a1, 0, &v4, &v3) != 1 && sub_10064360(a1, 1u, &v4, &v3) != 1
    || (result = sub_10024A50(v4, v3, &v2), result != 1)
    || v2 != 1 )
  {
    result = 0;
  }
  return result;
}

//----- (100457A0) --------------------------------------------------------
bool __cdecl sub_100457A0(int a1, void *a2)
{
  void *v2; // ecx@0
  int v3; // ST0C_4@1

  v3 = (int)v2;
  LOBYTE(v3) = sub_10045280(v2) != 0;
  return sub_10045630(a1, a2, v3);
}

//----- (100457D0) --------------------------------------------------------
bool __cdecl sub_100457D0(int a1, void *a2)
{
  void *v2; // ecx@0
  int v3; // ST0C_4@1

  v3 = (int)v2;
  LOBYTE(v3) = sub_10045280(v2) != 0;
  return sub_100456B0(a1, a2, v3);
}

//----- (10045800) --------------------------------------------------------
int __cdecl sub_10045800(float a1, float a2)
{
  float *v2; // ecx@0
  double v3; // st7@1
  double v4; // st7@3
  bool v5; // c0@3
  bool v6; // c3@3
  int result; // eax@4

  v3 = a1;
  if ( (COERCE_UNSIGNED_INT(*v2) & 0x7F800000) != 2139095040
    && *v2 <= v3
    && (v4 = *v2, v5 = a2 < v4, v6 = a2 == v4, v3 = a2, v5 || v6) )
  {
    result = 1;
  }
  else
  {
    *v2 = v3;
    result = 0;
  }
  return result;
}

//----- (10045850) --------------------------------------------------------
bool __cdecl sub_10045850(float *a1)
{
  void *v1; // ecx@0
  float *v2; // edi@1
  unsigned int v3; // ebp@1
  char v4; // bl@1
  _DWORD *v5; // esi@1
  char v6; // al@3
  bool result; // al@6
  int v8; // [sp+10h] [bp-8h]@1
  float v9; // [sp+14h] [bp-4h]@3
  char v10; // [sp+1Ch] [bp+4h]@1

  v2 = a1;
  *a1 = 0.0;
  v3 = 0;
  v4 = 0;
  v8 = sub_100460A0(v1);
  v10 = 0;
  v5 = &unk_100FBB40;
  do
  {
    if ( v8 & *v5 )
    {
      v6 = sub_10045200(v10, 0);
      if ( sub_1003F7A0(3, v6, &v9) )
      {
        ++v3;
        *v2 = *v2 + v9;
      }
    }
    ++v4;
    ++v5;
    v10 = v4;
  }
  while ( (unsigned __int8)v4 < 2u );
  result = v3 != 0;
  if ( v3 )
    *v2 = *v2 / (double)v3;
  return result;
}

//----- (100458F0) --------------------------------------------------------
int sub_100458F0()
{
  int result; // eax@1

  sub_1007C4B0(6361, (int)&flt_1027BB18, 4);
  result = sub_1007C4B0(6362, (int)&flt_1027BB1C, 4);
  dword_1027BB20 = 1379255385;
  return result;
}
// 1027BB18: using guessed type float flt_1027BB18;
// 1027BB1C: using guessed type float flt_1027BB1C;
// 1027BB20: using guessed type int dword_1027BB20;

//----- (10045920) --------------------------------------------------------
char __usercall sub_10045920@<al>(int a1@<eax>, float *a2@<esi>, float a3, float a4)
{
  char v4; // cl@1
  char result; // al@5
  void *v6; // [sp+0h] [bp-8h]@0

  v4 = sub_1003F820(a1, v6);
  if ( v4 && ((COERCE_UNSIGNED_INT(*a2) & 0x7F800000) == 2139095040 || a3 < (double)*a2 || a4 > (double)*a2) )
  {
    result = 0;
    *a2 = 0.0;
  }
  else
  {
    result = v4;
  }
  return result;
}

//----- (10045980) --------------------------------------------------------
char __cdecl sub_10045980(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_1003F820(7, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
     || *(float *)a1 > 39950.746
     || *(float *)a1 < -39950.746) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (100459E0) --------------------------------------------------------
char __cdecl sub_100459E0(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_1003F820(54, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
     || *(float *)a1 > 526.79114
     || *(float *)a1 < -526.79114) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10045A40) --------------------------------------------------------
char __cdecl sub_10045A40(float *a1)
{
  char v1; // bl@1
  double v2; // st7@2
  double v3; // st7@6
  char result; // al@9
  float v5; // [sp+Ch] [bp-Ch]@1
  float v6; // [sp+10h] [bp-8h]@5
  float v7; // [sp+14h] [bp-4h]@2

  v1 = sub_1003F820(53, &v5);
  if ( v1 )
  {
    v2 = v5;
    v7 = v5;
    if ( (LODWORD(v5) & 0x7F800000) == 2139095040 || v2 > 526.79114 || v2 < -526.79114 )
      return 0;
    if ( sub_1003F820(59, &v6) )
    {
      v3 = v6;
      v7 = v6;
      if ( (LODWORD(v6) & 0x7F800000) != 2139095040 && v3 <= 526.79114 && v3 >= -526.79114 )
      {
        sub_10045800(flt_1027BB18, 0.0);
        result = v1;
        v5 = flt_1027BB1C * v6 + v5;
        *a1 = v5;
        return result;
      }
    }
    *a1 = v5;
  }
  return v1;
}
// 1027BB18: using guessed type float flt_1027BB18;
// 1027BB1C: using guessed type float flt_1027BB1C;

//----- (10045B40) --------------------------------------------------------
char __cdecl sub_10045B40(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_1003F820(55, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040 || *(float *)a1 > 4.0960002 || *(float *)a1 < 0.0) )
  {
    *(float *)a1 = 0.0;
    result = 0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10045BA0) --------------------------------------------------------
char __cdecl sub_10045BA0(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_1003F820(2, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040 || *(float *)a1 > 512.0 || *(float *)a1 < -512.0) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10045C00) --------------------------------------------------------
char __cdecl sub_10045C00(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_1003F820(56, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
     || *(float *)a1 > 1053.5823
     || *(float *)a1 < -1053.5823) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10045C60) --------------------------------------------------------
char __cdecl sub_10045C60(void *a1)
{
  char v1; // bl@1
  int v2; // eax@7
  char result; // al@9
  float v4; // [sp+14h] [bp-10h]@1
  float v5; // [sp+18h] [bp-Ch]@1
  float v6; // [sp+1Ch] [bp-8h]@1
  float v7; // [sp+20h] [bp-4h]@2

  v5 = 0.0;
  v4 = 0.0;
  v6 = 0.0;
  v1 = sub_1003F820(57, a1);
  if ( v1 )
  {
    v7 = *(float *)a1;
    if ( (LODWORD(v7) & 0x7F800000) == 2139095040 || *(float *)a1 > 166.46144 || *(float *)a1 < -166.46144 )
    {
      v1 = 0;
      *(float *)a1 = 0.0;
    }
  }
  sub_1007C4B0(6950, (int)&v4, 4);
  if ( 0.0 != v4 && sub_1003F820(66, &v5) && (LOBYTE(v2) = 58, sub_10045920(v2, &v6, 166.46144, -166.46144)) )
  {
    result = 1;
    *(float *)a1 = v4 * v5 + v6;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10045D40) --------------------------------------------------------
char __cdecl sub_10045D40(float *a1)
{
  float *v1; // esi@1
  char v2; // bl@1

  v1 = a1;
  *a1 = 0.0;
  v2 = sub_10045980(&a1);
  if ( v2 )
    *v1 = sub_10045E10() + *(float *)&a1;
  return v2;
}
// 10045E10: using guessed type double sub_10045E10(void);

//----- (10045D70) --------------------------------------------------------
char __cdecl sub_10045D70(float *a1)
{
  float *v1; // esi@1
  char result; // al@4
  float v3; // [sp+8h] [bp-4h]@1

  v1 = a1;
  *a1 = 9.8999998e24;
  if ( sub_10045BA0(&v3) && sub_10045D40((float *)&a1) )
  {
    *(float *)&a1 = *(float *)&a1 * 3.280839920043945;
    if ( *(float *)&a1 < 36089.0 )
    {
      result = 1;
      *v1 = v3 - (15.0 - *(float *)&a1 / 1000.0 * 1.981199979782104);
    }
    else
    {
      result = 1;
      *v1 = v3 - -56.5;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10045E10) --------------------------------------------------------
void sub_10045E10()
{
  float v0; // ST00_4@1

  v0 = sub_1003F440();
  sub_10091840(v0);
}
// 1003F440: using guessed type double sub_1003F440(void);

//----- (10045E30) --------------------------------------------------------
char __thiscall sub_10045E30(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  if ( sub_1007C3B0(3137, (int)&v2 + 3, 1) )
  {
    sub_1007D180(86, (_BYTE *)&v2 + 3);
    sub_1007C500(3137, (int)&v2 + 3, 1);
  }
  return BYTE3(v2);
}

//----- (10045E70) --------------------------------------------------------
char __thiscall sub_10045E70(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_1007C650(6077, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10045EA0) --------------------------------------------------------
char __thiscall sub_10045EA0(void *this)
{
  char v1; // bl@1

  sub_100429D0(this);
  v1 = 2 * j_HWM_pvg_read_reg(13);
  return v1 | j_HWM_pvg_read_reg(12);
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10045EC0) --------------------------------------------------------
char __thiscall sub_10045EC0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 1;
  sub_1007C650(3008, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10045EF0) --------------------------------------------------------
int sub_10045EF0()
{
  int v1; // [sp+0h] [bp-8h]@1
  int v2; // [sp+4h] [bp-4h]@1

  v1 = 0;
  sub_1007C650(3012, &v2, 4, &v1);
  return v2;
}

//----- (10045F20) --------------------------------------------------------
char __fastcall sub_10045F20(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_1007D180(42, (_BYTE *)&v2 + 2);
  if ( sub_1007C3B0(3162, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_1007C5E0(3162, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10045F70) --------------------------------------------------------
char __cdecl sub_10045F70(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_is_booting(a1);
  SYS_exit_krnl();
  return v1;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA3E: using guessed type int __cdecl SYS_pvg_is_booting(_DWORD);
// 1007DA44: using guessed type int SYS_enter_krnl(void);

//----- (10045F90) --------------------------------------------------------
char sub_10045F90()
{
  char v0; // cl@1
  char result; // al@1

  v0 = *(_BYTE *)dword_10337080;
  result = 0;
  if ( *(_BYTE *)dword_10337080 == 37 || v0 == 3 || v0 == 35 || v0 == 36 || v0 == 40 || v0 == 47 )
    result = 1;
  return result;
}
// 10337080: using guessed type int dword_10337080;

//----- (10045FC0) --------------------------------------------------------
bool __cdecl sub_10045FC0(int a1)
{
  int v1; // esi@1
  void *v2; // ecx@1

  v1 = j_HWM_pvg_hsdb_get_lrus_online();
  return (a1 & (sub_100429D0(v2) | v1)) == a1;
}
// 1007C810: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (10045FE0) --------------------------------------------------------
int __cdecl sub_10045FE0(int a1, char *a2)
{
  if ( (unsigned __int8)a1 >= 0x5Fu )
    sub_10042930("..\\lib\\adl\\sys_usr.c", 5389, 1, 0);
  if ( !a2 )
    sub_10042930("..\\lib\\adl\\sys_usr.c", 5390, 1, 0);
  SYS_enter_krnl();
  SYS_pvg_var_ctrl(a1, a2);
  return SYS_exit_krnl();
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DA4A: using guessed type int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD);

//----- (10046040) --------------------------------------------------------
char __thiscall sub_10046040(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10045FE0(18, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10046060) --------------------------------------------------------
char __thiscall sub_10046060(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10045FE0(17, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10046080) --------------------------------------------------------
char __thiscall sub_10046080(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10045FE0(26, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (100460A0) --------------------------------------------------------
int __thiscall sub_100460A0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10045FE0(29, (char *)&v2);
  return (int)v2;
}

//----- (100460C0) --------------------------------------------------------
char __thiscall sub_100460C0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10045FE0(34, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (100460E0) --------------------------------------------------------
char __thiscall sub_100460E0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10045FE0(37, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10046100) --------------------------------------------------------
char __thiscall sub_10046100(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10045FE0(44, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10046120) --------------------------------------------------------
int __cdecl sub_10046120(char a1)
{
  return sub_10045FE0(56, &a1);
}

//----- (10046130) --------------------------------------------------------
int __cdecl sub_10046130(char a1, char a2)
{
  int result; // eax@2

  if ( a2 )
  {
    sub_10045FE0(61, &a1);
    result = sub_10045FE0(62, &a2);
  }
  else
  {
    sub_10045FE0(62, &a2);
    result = sub_10045FE0(61, &a1);
  }
  return result;
}

//----- (10046170) --------------------------------------------------------
char __cdecl sub_10046170(int a1)
{
  char result; // al@1

  result = 2;
  if ( a1 == 0x1000000 )
  {
    result = 0;
  }
  else if ( a1 == 0x2000000 )
  {
    result = 1;
  }
  return result;
}

//----- (10046190) --------------------------------------------------------
char __thiscall sub_10046190(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1007C4B0(10029, (int)&v2 + 3, 1);
  return BYTE3(v2);
}

//----- (100461B0) --------------------------------------------------------
bool __thiscall sub_100461B0(void *this)
{
  return (sub_100460A0(this) & 0x3000000) == 50331648;
}

//----- (100461D0) --------------------------------------------------------
bool __cdecl sub_100461D0(void *a1)
{
  char v1; // cl@1

  v1 = sub_100253C0(1, 1946, a1);
  *((_DWORD *)a1 + 1) /= 0x3E8u;
  return v1 && !sub_1004D540((int)a1);
}

//----- (10046210) --------------------------------------------------------
int __cdecl sub_10046210(char a1)
{
  int result; // eax@2
  int v2; // [sp+0h] [bp-4h]@1

  v2 = 0;
  if ( a1 == 1 )
  {
    sub_1007C4B0(10026, (int)&v2, 4);
    result = v2;
  }
  else
  {
    sub_1007C4B0(10027, (int)&v2, 4);
    result = v2;
  }
  return result;
}

//----- (10046260) --------------------------------------------------------
char __cdecl sub_10046260(int a1)
{
  int v2; // [sp+0h] [bp-Ch]@1
  char v3; // [sp+4h] [bp-8h]@1

  v2 = 1000 * a1;
  v3 = 2;
  sub_10024E60(1, 1671, &v2, 0, 8, 1);
  return sub_10025010(1, 1671, 0xFFFFFFF);
}

//----- (100462C0) --------------------------------------------------------
char __cdecl sub_100462C0(char a1)
{
  sub_10024E60(1, 1657, &a1, 0, 1, 1);
  return sub_10025010(1, 1657, 0xFFFFFFF);
}

//----- (100462F0) --------------------------------------------------------
char __cdecl sub_100462F0(char a1, int a2)
{
  int v2; // eax@2

  if ( a1 == 1 )
  {
    v2 = sub_1007C500(10026, (int)&a2, 4);
    if ( !v2 )
      LOBYTE(v2) = sub_10046260(a2);
  }
  else
  {
    LOBYTE(v2) = sub_1007C500(10027, (int)&a2, 4);
  }
  return v2;
}

//----- (10046330) --------------------------------------------------------
void __cdecl sub_10046330(char a1)
{
  if ( (unsigned __int8)a1 <= 1u && !sub_1007C500(10029, (int)&a1, 1) )
    sub_100462C0(a1);
}

//----- (10046360) --------------------------------------------------------
signed int __cdecl sub_10046360(char a1, char a2)
{
  _DWORD *v2; // esi@3
  int v3; // eax@5
  char *v5; // [sp-18h] [bp-20h]@3
  void *v6; // [sp-10h] [bp-18h]@3
  int v7; // [sp-8h] [bp-10h]@3

  if ( a2 == 11 )
  {
    v7 = 3;
    v2 = &unk_100FD228;
    v6 = &unk_100FD228;
    v5 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v7 = 7;
    v2 = &unk_100FD240;
    v6 = &unk_100FD240;
    v5 = &a1;
  }
  v3 = sub_10043FF0(v5, 1u, (int)v6, 8, v7, 7);
  if ( v3 < 7 )
    return v2[2 * v3 + 1];
  return 42066;
}

//----- (100463C0) --------------------------------------------------------
int __cdecl sub_100463C0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10043FF0(&a1, 1u, (int)&unk_100FD288, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_100FD28C[2 * v1];
  return result;
}
// 100FD28C: using guessed type int dword_100FD28C[];

//----- (10046400) --------------------------------------------------------
signed int __cdecl sub_10046400(char a1, char a2, char a3)
{
  _DWORD *v3; // esi@3
  int v4; // eax@5
  signed int result; // eax@7
  char *v6; // [sp-18h] [bp-20h]@3
  void *v7; // [sp-10h] [bp-18h]@3

  if ( a2 == 11 )
  {
    v3 = &unk_100FD298;
    v7 = &unk_100FD298;
    v6 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v3 = &unk_100FD2B0;
    v7 = &unk_100FD2B0;
    v6 = &a1;
  }
  v4 = sub_10043FF0(v6, 1u, (int)v7, 12, 2, 2);
  if ( v4 == 2 )
    return 42066;
  if ( a3 )
    result = v3[3 * v4 + 1];
  else
    result = v3[3 * v4 + 2];
  return result;
}

//----- (10046470) --------------------------------------------------------
int __cdecl sub_10046470(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10043FF0(&a1, 1u, (int)&unk_100FD2C8, 8, 3, 3);
  if ( v1 == 3 )
    result = 42066;
  else
    result = dword_100FD2CC[2 * v1];
  return result;
}
// 100FD2CC: using guessed type int dword_100FD2CC[];

//----- (100464B0) --------------------------------------------------------
int __cdecl sub_100464B0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10043FF0(&a1, 1u, (int)&unk_100FD2E0, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_100FD2E4[2 * v1];
  return result;
}
// 100FD2E4: using guessed type int dword_100FD2E4[];

//----- (100464F0) --------------------------------------------------------
char __cdecl sub_100464F0(int a1, int a2)
{
  return sub_1007C430(a1 + 37000, a2, 284);
}

//----- (10046510) --------------------------------------------------------
char __cdecl sub_10046510(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10046360(a1, 11);
  return sub_1007C430(v2, a2, 24);
}

//----- (10046530) --------------------------------------------------------
char __cdecl sub_10046530(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100463C0(a1);
  return sub_1007C430(v2, a2, 2720);
}

//----- (10046560) --------------------------------------------------------
char __cdecl sub_10046560(char a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@1

  v2 = sub_10046400(a1, 11, 1);
  sub_1007C430(v2, a2, 36);
  v3 = sub_10046400(a1, 11, 0);
  return sub_1007C430(v3, a2 + 36, 32);
}

//----- (100465B0) --------------------------------------------------------
char __cdecl sub_100465B0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10046470(a1);
  return sub_1007C430(v2, a2, 2192);
}

//----- (100465E0) --------------------------------------------------------
char __cdecl sub_100465E0(int a1)
{
  return sub_1007C430(6005, a1, 4);
}

//----- (10046600) --------------------------------------------------------
char __cdecl sub_10046600(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100464B0(a1);
  return sub_1007C430(v2, a2, 60);
}

//----- (10046620) --------------------------------------------------------
char __cdecl sub_10046620(int a1)
{
  return sub_1007C430(6453, a1, 5);
}

//----- (10046640) --------------------------------------------------------
char sub_10046640()
{
  return byte_1027BB29;
}
// 1027BB29: using guessed type char byte_1027BB29;

//----- (10046650) --------------------------------------------------------
char __cdecl sub_10046650(unsigned __int16 a1, char *a2, char a3)
{
  char result; // al@4
  char v4; // al@5
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
    {
      sub_10042930("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 188, 0, 0);
      return 0;
    }
    v4 = sub_100253F0(1, 555, &v5, (int)&a1);
  }
  else
  {
    v4 = sub_100253F0(1, 550, &v5, (int)&a1);
  }
  if ( !v4 )
    return 0;
  if ( sub_1004DC10((int)&v5) )
    return 0;
  result = 1;
  if ( !BYTE1(v14) || (unsigned int)a1 - 4 < 0x20 )
    return 0;
  if ( a3 )
  {
    if ( BYTE1(v5) == 26 )
    {
      qmemcpy(a2, (char *)&v6 + 1, 0x20u);
      qmemcpy(&unk_1027BB30, (char *)&v6 + 1, 0x20u);
      byte_1027BB28 = 1;
      byte_1027BB29 = 0;
      return result;
    }
  }
  else if ( BYTE1(v5) == 12 )
  {
    qmemcpy(a2, (char *)&v6 + 1, 0x20u);
    qmemcpy(&unk_1027BB50, (char *)&v6 + 1, 0x20u);
    byte_1027BB29 = 1;
    byte_1027BB2A = 1;
    return result;
  }
  return 0;
}
// 1027BB28: using guessed type char byte_1027BB28;
// 1027BB29: using guessed type char byte_1027BB29;
// 1027BB2A: using guessed type char byte_1027BB2A;

//----- (10046780) --------------------------------------------------------
char __cdecl sub_10046780(__int16 a1, _DWORD *a2)
{
  char result; // al@4
  char v3; // al@5
  int v4; // [sp+0h] [bp-28h]@1
  int v5; // [sp+4h] [bp-24h]@1
  int v6; // [sp+8h] [bp-20h]@1
  int v7; // [sp+Ch] [bp-1Ch]@1
  int v8; // [sp+10h] [bp-18h]@1
  int v9; // [sp+14h] [bp-14h]@1
  int v10; // [sp+18h] [bp-10h]@1
  int v11; // [sp+1Ch] [bp-Ch]@1
  int v12; // [sp+20h] [bp-8h]@1
  int v13; // [sp+24h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
    {
      sub_10042930("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 301, 0, 0);
      return 0;
    }
    v3 = sub_100253F0(1, 555, &v4, (int)&a1);
  }
  else
  {
    v3 = sub_100253F0(1, 550, &v4, (int)&a1);
  }
  if ( !v3 )
    return 0;
  if ( sub_1004DC10((int)&v4) )
    return 0;
  result = 1;
  if ( (_BYTE)v4 != 58 || BYTE1(v4) != 40 || a1 != 8 )
    return 0;
  *a2 = v5;
  return result;
}

//----- (10046840) --------------------------------------------------------
char __cdecl sub_10046840(char a1, int a2)
{
  char v2; // bl@1
  int v4; // eax@5

  v2 = 0;
  if ( a1 )
  {
    if ( a1 != 1 )
    {
      sub_10042930("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 497, 0, 0);
      return v2;
    }
    v4 = 6110;
  }
  else
  {
    v4 = 6099;
  }
  v2 = 1;
  if ( !sub_1007C3B0(v4, a2, 12) )
    return v2;
  return 0;
}

//----- (100468A0) --------------------------------------------------------
char __cdecl sub_100468A0(char a1, int a2)
{
  char result; // al@3
  char v3; // [sp+4h] [bp-44h]@1
  char v4; // [sp+8h] [bp-40h]@3
  char v5; // [sp+28h] [bp-20h]@3

  memset(&v3, 0, 0x44u);
  if ( (unsigned __int8)a1 < 2u && a2 )
  {
    result = sub_10046560(a1, (int)&v3);
    qmemcpy((void *)a2, &v4, 0x20u);
    qmemcpy((void *)(a2 + 32), &v5, 0x20u);
  }
  else
  {
    result = sub_10042930("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 570, 0, 0);
  }
  return result;
}

//----- (10046920) --------------------------------------------------------
bool __cdecl sub_10046920(void *a1)
{
  bool v1; // zf@2
  bool result; // al@4

  if ( a1 )
  {
    v1 = byte_1027BB28 == 0;
    qmemcpy(a1, &unk_1027BB30, 0x40u);
    result = !v1 && byte_1027BB2A;
  }
  else
  {
    sub_10042930("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 617, 0, 0);
    result = 0;
  }
  return result;
}
// 1027BB28: using guessed type char byte_1027BB28;
// 1027BB2A: using guessed type char byte_1027BB2A;

//----- (10046970) --------------------------------------------------------
void *sub_10046970()
{
  void *result; // eax@1

  result = memset(&unk_1027BB30, 0, 0x40u);
  byte_1027BB28 = 0;
  byte_1027BB29 = 1;
  byte_1027BB2B = 0;
  byte_1027BB2A = 0;
  return result;
}
// 1027BB28: using guessed type char byte_1027BB28;
// 1027BB29: using guessed type char byte_1027BB29;
// 1027BB2A: using guessed type char byte_1027BB2A;
// 1027BB2B: using guessed type char byte_1027BB2B;

//----- (100469A0) --------------------------------------------------------
char __cdecl sub_100469A0(char a1, int a2)
{
  char result; // al@4
  int v3; // edx@5
  const void *v4; // esi@8
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( j_HWM_pvg_read_reg(1) != 1 )
    sub_10042930("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 857, 1, 0);
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 != 1 )
      return result;
    result = sub_100471C0(15);
    v3 = 555;
  }
  else
  {
    result = sub_100471C0(8);
    v3 = 550;
  }
  if ( result )
  {
    v4 = (const void *)a2;
    LOBYTE(v5) = 12;
    BYTE1(v14) = 1;
    LOBYTE(v6) = 32;
    HIWORD(v5) = 34;
    if ( byte_1027BB29 )
    {
      BYTE1(v5) = 26;
    }
    else
    {
      BYTE1(v5) = 12;
      v4 = (const void *)(a2 + 32);
    }
    qmemcpy((char *)&v6 + 1, v4, 0x20u);
    result = sub_10024E60(1, v3, &v5, 1, 38, 1);
  }
  return result;
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1027BB29: using guessed type char byte_1027BB29;

//----- (10046A80) --------------------------------------------------------
__int16 __usercall sub_10046A80@<ax>(unsigned __int8 a1@<al>)
{
  return word_100FD3D0[a1];
}
// 100FD3D0: using guessed type __int16 word_100FD3D0[];

//----- (10046A90) --------------------------------------------------------
char __cdecl sub_10046A90(unsigned __int8 a1, int *a2, const void *a3)
{
  int v3; // ebx@1
  unsigned int v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int v7; // [sp+14h] [bp-20h]@1
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+28h] [bp-Ch]@1
  int v13; // [sp+2Ch] [bp-8h]@1
  int v14; // [sp+30h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v3 = (unsigned __int16)sub_10046A80(a1);
  v5 = *a2;
  qmemcpy(&v6, a3, 0x24u);
  sub_10024E60(1, v3, &v5, 1, (v5 >> 16) + 4, 1);
  return sub_10025010(1, v3, 0xFFFFFFF);
}

//----- (10046B20) --------------------------------------------------------
char __cdecl sub_10046B20(unsigned __int8 a1, char a2)
{
  int v3; // [sp+4h] [bp-28h]@1
  int v4; // [sp+8h] [bp-24h]@1
  int v5; // [sp+Ch] [bp-20h]@1
  int v6; // [sp+10h] [bp-1Ch]@1
  int v7; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@1
  int v9; // [sp+1Ch] [bp-10h]@1
  int v10; // [sp+20h] [bp-Ch]@1
  int v11; // [sp+24h] [bp-8h]@1
  int v12; // [sp+28h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v3 = 0;
  if ( a1 >= 2u )
  {
    sub_10042930("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 736, 0, 0);
  }
  else
  {
    HIWORD(v3) = 0;
    LOBYTE(v3) = 12;
    if ( a2 == 11 )
    {
      BYTE1(v3) = byte_1027BB29 != 0 ? 25 : 11;
      sub_10046A90(a1, &v3, &v4);
      return 1;
    }
    if ( a2 == 17 )
    {
      LOWORD(v3) = 10042;
      sub_10046A90(a1, &v3, &v4);
      return 1;
    }
  }
  return 0;
}
// 1027BB29: using guessed type char byte_1027BB29;

//----- (10046BE0) --------------------------------------------------------
bool __cdecl sub_10046BE0(__int16 a1, char a2, int a3, int a4, void *a5)
{
  char v6; // [sp+4h] [bp-40h]@8
  char v7; // [sp+24h] [bp-20h]@11

  if ( (unsigned __int8)a1 == 8 )
  {
    LOBYTE(a1) = 0;
  }
  else
  {
    if ( (unsigned __int8)a1 != 9 )
      return 0;
    LOBYTE(a1) = 1;
  }
  if ( a2 == 1 )
  {
    sub_100468A0(a1, (int)a5);
    return 1;
  }
  if ( byte_1027BB29 )
  {
    if ( sub_10046650(a1, &v6, 1) )
    {
LABEL_14:
      byte_1027BB2B = 0;
      goto LABEL_15;
    }
    if ( (unsigned __int8)++byte_1027BB2B >= 5u )
    {
      byte_1027BB28 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( sub_10046650(a1, &v7, 0) )
      goto LABEL_14;
    if ( (unsigned __int8)++byte_1027BB2B >= 5u )
    {
      byte_1027BB2A = 0;
      goto LABEL_14;
    }
  }
LABEL_15:
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    sub_100468A0(a1, (int)&v6);
    sub_100469A0(a1, (int)&v6);
  }
  sub_10046B20(a1, 11);
  return sub_10046920(a5);
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1027BB28: using guessed type char byte_1027BB28;
// 1027BB29: using guessed type char byte_1027BB29;
// 1027BB2A: using guessed type char byte_1027BB2A;
// 1027BB2B: using guessed type char byte_1027BB2B;

//----- (10046CE0) --------------------------------------------------------
int __thiscall sub_10046CE0(void *this)
{
  int v1; // esi@1

  v1 = sub_100460A0(this);
  return v1 & ~j_HWM_pvg_hsdb_get_lrus_online();
}
// 1007C810: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (10046D00) --------------------------------------------------------
char __thiscall sub_10046D00(void *this)
{
  char v1; // di@1
  void *v2; // esi@1
  char v3; // di@3
  void *v4; // esi@3
  char result; // al@4

  dword_1027BB70 = sub_100460C0(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_1027BB78, 0, 0x1540u);
  memset(&unk_1027D0B8, 0, 0x19B0u);
  v1 = 0;
  v2 = &unk_1027BB78;
  do
  {
    sub_10046530(v1, (int)v2);
    v2 = (char *)v2 + 2720;
    ++v1;
  }
  while ( (signed int)v2 < (signed int)&unk_1027D0B8 );
  v3 = 0;
  v4 = &unk_1027D0B8;
  do
  {
    result = sub_100465B0(v3, (int)v4);
    v4 = (char *)v4 + 2192;
    ++v3;
  }
  while ( (signed int)v4 < (signed int)&dword_1027EA68 );
  return result;
}
// 1027BB70: using guessed type int dword_1027BB70;
// 1027EA68: using guessed type int dword_1027EA68;

//----- (10046D90) --------------------------------------------------------
char __cdecl sub_10046D90(char a1)
{
  char v1; // bl@1
  unsigned __int8 v2; // al@3
  char v4; // [sp+4h] [bp-20h]@1
  char v5; // [sp+8h] [bp-1Ch]@3
  char v6[19]; // [sp+Dh] [bp-17h]@5

  v1 = 0;
  v4 = 0;
  do
  {
    if ( v1 )
      break;
    sub_10046510(v4, (int)&v5);
    v2 = 0;
    do
    {
      if ( v1 )
        break;
      if ( v6[4 * v2] == a1 )
        v1 = 1;
      ++v2;
    }
    while ( v2 <= 1u );
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  return v1;
}
// 10046D90: using guessed type char var_17[19];

//----- (10046E00) --------------------------------------------------------
char __cdecl sub_10046E00(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // al@6
  char v6; // [sp+6h] [bp-2h]@1
  bool v7; // [sp+7h] [bp-1h]@1

  v2 = dword_1027BB70 != 1379255385;
  v6 = 0;
  v7 = dword_1027BB70 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_1007C2F0(86, 10);
      memset((char *)&unk_1027BB78 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_10046530(a1, (int)&unk_1027BB78 + 2720 * (unsigned __int8)a1);
      v2 = v7;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( byte_1027BB91[4 * (680 * (unsigned __int8)a1 + v5)] != a2 )
    {
      if ( ++v5 >= 0xBu )
        goto LABEL_11;
    }
    v6 = 1;
LABEL_11:
    if ( v2 )
      sub_1007C2C0(v4, 86);
    result = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1027BB70: using guessed type int dword_1027BB70;

//----- (10046EC0) --------------------------------------------------------
char __cdecl sub_10046EC0(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_1027BB70 != 1379255385;
  v7 = 0;
  v8 = dword_1027BB70 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_1007C2F0(86, 10);
      memset((char *)&unk_1027BB78 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_10046530(a1, (int)&unk_1027BB78 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 4 * (680 * (unsigned __int8)a1 + v5);
      if ( byte_1027BE50[v6] == a2 || byte_1027BE51[v6] == a2 )
        break;
      if ( ++v5 >= 8u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_1007C2C0(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1027BB70: using guessed type int dword_1027BB70;

//----- (10046F80) --------------------------------------------------------
char __cdecl sub_10046F80(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_1027BB70 != 1379255385;
  v7 = 0;
  v8 = dword_1027BB70 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_1007C2F0(86, 10);
      memset((char *)&unk_1027BB78 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_10046530(a1, (int)&unk_1027BB78 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 8 * (340 * (unsigned __int8)a1 + v5);
      if ( byte_1027BE70[v6] == a2 || byte_1027BE71[v6] == a2 )
        break;
      if ( ++v5 >= 5u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_1007C2C0(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1027BB70: using guessed type int dword_1027BB70;

//----- (10047040) --------------------------------------------------------
char __cdecl sub_10047040(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  signed int v5; // ecx@6
  char *v6; // eax@6
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_1027BB70 != 1379255385;
  v7 = 0;
  v8 = dword_1027BB70 != 1379255385;
  if ( (unsigned __int8)a1 < 3u )
  {
    if ( v2 )
    {
      v4 = sub_1007C2F0(86, 10);
      memset((char *)&unk_1027D0B8 + 2192 * (unsigned __int8)a1, 0, 0x890u);
      sub_100465B0(a1, (int)&unk_1027D0B8 + 2192 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    v6 = (char *)&unk_1027D0B9 + 2192 * (unsigned __int8)a1;
    while ( *v6 != a2 )
    {
      ++v5;
      v6 += 4;
      if ( v5 >= 40 )
        goto LABEL_11;
    }
    v7 = 1;
LABEL_11:
    if ( v2 )
      sub_1007C2C0(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1027BB70: using guessed type int dword_1027BB70;

//----- (100470F0) --------------------------------------------------------
char __cdecl sub_100470F0(char a1, char a2)
{
  unsigned __int8 v2; // bl@1
  unsigned __int8 v4; // [sp+8h] [bp-8h]@1
  char v5; // [sp+Ch] [bp-4h]@2

  v2 = 0;
  v4 = 0;
  while ( 1 )
  {
    sub_10063F10(a1, v4, (int)&v5);
    if ( v5 == a2 )
      break;
    v4 = ++v2;
    if ( v2 >= 2u )
      return 0;
  }
  return 1;
}

//----- (10047140) --------------------------------------------------------
char sub_10047140()
{
  char v1; // [sp+1h] [bp-1h]@1

  v1 = 0;
  sub_1007D180(134, &v1);
  return v1;
}

//----- (10047160) --------------------------------------------------------
char sub_10047160()
{
  int v0; // esi@1

  v0 = 0;
  while ( !sub_1003C450(v0) )
  {
    if ( ++v0 >= 2 )
      return 0;
  }
  return 1;
}

//----- (10047190) --------------------------------------------------------
char __cdecl sub_10047190(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_10046E00(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (100471C0) --------------------------------------------------------
char __cdecl sub_100471C0(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_10046EC0(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (100471F0) --------------------------------------------------------
char __cdecl sub_100471F0(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_10046F80(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (10047220) --------------------------------------------------------
char __cdecl sub_10047220(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_10047040(v2++, a1);
  }
  while ( v2 < 3 );
  return result;
}

//----- (10047250) --------------------------------------------------------
char __cdecl sub_10047250(char a1)
{
  char result; // al@1
  unsigned __int8 v2; // bl@1
  char v3; // [sp+8h] [bp-4h]@1

  result = 0;
  v2 = 0;
  v3 = 0;
  do
  {
    if ( result )
      break;
    result = sub_100470F0(v3, a1);
    v3 = ++v2;
  }
  while ( v2 < 3u );
  return result;
}

//----- (10047290) --------------------------------------------------------
char __cdecl sub_10047290(char a1, _BYTE *a2)
{
  int v2; // esi@1

  *a2 = 19;
  v2 = 0;
  while ( a1 != 3 && a1 != byte_100FD94D[2 * v2] || !sub_10047250(byte_100FD94C[2 * v2]) )
  {
    if ( (unsigned int)++v2 >= 0xF )
      return 0;
  }
  *a2 = byte_100FD94C[2 * v2];
  return 1;
}

//----- (100472E0) --------------------------------------------------------
bool sub_100472E0()
{
  char v1; // [sp+7h] [bp-1h]@1

  v1 = 4;
  sub_1007D180(115, &v1);
  return v1 == 2 || sub_10047190(37);
}

//----- (10047320) --------------------------------------------------------
char __cdecl sub_10047320(char a1)
{
  unsigned __int8 v1; // al@1
  int v2; // esi@2
  char result; // al@3

  v1 = sub_10043FF0(&a1, 1u, (int)&unk_100FD928, 3, 6, 6);
  if ( v1 >= 6u )
  {
    result = 0;
  }
  else
  {
    v2 = v1;
    if ( sub_10047190(byte_100FD929[3 * v1]) || (result = sub_10047220(byte_100FD92A[3 * v2])) != 0 )
      result = 1;
  }
  return result;
}

//----- (10047380) --------------------------------------------------------
BOOL sub_10047380()
{
  char v1; // [sp+2h] [bp-2h]@1
  char v2; // [sp+3h] [bp-1h]@1

  v2 = 1;
  v1 = 1;
  sub_1007C650(9192, &v1, 1, &v2);
  return v1 == 0;
}

//----- (100473B0) --------------------------------------------------------
char __cdecl sub_100473B0(bool *a1)
{
  unsigned __int8 v1; // bl@1
  unsigned __int16 *v2; // esi@1
  signed int v3; // edi@4
  void *v4; // ecx@5
  char v5; // al@9
  void *v6; // ecx@13
  char v8; // [sp+1h] [bp-Bh]@1
  char v9; // [sp+2h] [bp-Ah]@1
  unsigned __int8 v10; // [sp+3h] [bp-9h]@1
  unsigned __int8 v11; // [sp+4h] [bp-8h]@1
  bool v12; // [sp+5h] [bp-7h]@1
  char v13; // [sp+6h] [bp-6h]@6
  bool v14; // [sp+7h] [bp-5h]@1
  float v15; // [sp+8h] [bp-4h]@1

  v14 = (unsigned __int8)sub_10041980() > 1u;
  v1 = 0;
  v12 = sub_10045850(&v15);
  v8 = 1;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v2 = (unsigned __int16 *)&unk_100FDF38;
  if ( sub_10045730(0x2E6u) || sub_10045730(0x2E7u) )
    v2 = (unsigned __int16 *)&unk_100FDF30;
  v3 = 4;
  do
  {
    if ( sub_10045730(*v2) && sub_100457A0(*v2, &v13) )
    {
      v10 += v13;
      ++v1;
      LOBYTE(v4) = v13 == 0;
      v11 += v13 == 0;
    }
    ++v2;
    --v3;
  }
  while ( v3 );
  v5 = byte_100FDF40[v1];
  if ( v10 >= (unsigned __int8)v5 )
    goto LABEL_20;
  if ( v11 >= (unsigned __int8)v5 )
    goto LABEL_19;
  if ( v14 )
  {
    if ( !sub_10041C30() )
    {
      if ( !v12 )
        goto LABEL_20;
      goto LABEL_18;
    }
LABEL_19:
    v8 = 1;
LABEL_21:
    v9 = 1;
    goto LABEL_22;
  }
  if ( v12 )
  {
LABEL_18:
    if ( v15 > 25.72207 )
      goto LABEL_19;
LABEL_20:
    v8 = 0;
    goto LABEL_21;
  }
  if ( sub_100460C0(v4) == 2 || sub_100460C0(v6) == 8 )
  {
    *a1 = 1;
    return 0;
  }
LABEL_22:
  *a1 = v8 == 0;
  return v9;
}

//----- (100474F0) --------------------------------------------------------
bool __thiscall sub_100474F0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  return sub_100460C0(this) == 1 && sub_100473B0((bool *)&v2 + 3) && BYTE3(v2);
}

//----- (10047520) --------------------------------------------------------
char sub_10047520()
{
  char v0; // bl@1
  char result; // al@9
  char v2; // [sp+6h] [bp-Ah]@1
  bool v3; // [sp+7h] [bp-9h]@1
  float v4; // [sp+8h] [bp-8h]@3
  float v5; // [sp+Ch] [bp-4h]@5

  sub_100473B0(&v3);
  v0 = v3;
  v3 = v3 == 0;
  v2 = 0;
  sub_1007C3B0(6012, (int)&v2, 1);
  if ( v0 )
  {
LABEL_20:
    result = v3;
  }
  else
  {
    switch ( v2 )
    {
      case 0:
        if ( !sub_1003D430(0x1Eu, &v4) )
          v4 = 0.0;
        if ( !sub_1003D430(0x37u, &v5) )
          v5 = 0.0;
        if ( v4 > 100.0 || v5 > 100.0 )
          goto LABEL_10;
        result = 0;
        break;
      case 1:
        if ( !sub_1003D430(0x19u, &v4) )
          v4 = 0.0;
        if ( !sub_1003D430(0x32u, &v5) )
          v5 = 0.0;
        if ( v4 > 0.05000000074505806 || v5 > 0.05000000074505806 )
LABEL_10:
          result = 1;
        else
          result = 0;
        break;
      case 2:
      case 3:
        result = sub_10047AE0((int)"_flt_timer");
        break;
      default:
        sub_10042930("..\\lib\\adl\\iop_utl.c", 262, 0, 0);
        goto LABEL_20;
    }
  }
  return result;
}

//----- (10047670) --------------------------------------------------------
char __cdecl sub_10047670(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@11
  int v4; // eax@16
  int v6; // [sp+8h] [bp-54h]@1
  int v7; // [sp+Ch] [bp-50h]@1
  int v8; // [sp+10h] [bp-4Ch]@1
  int v9; // [sp+14h] [bp-48h]@1
  int v10; // [sp+18h] [bp-44h]@1
  char v11; // [sp+1Ch] [bp-40h]@16

  LOBYTE(v2) = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( a1 == 28 || a1 == 29 || a1 == 30 || a1 == 31 || a1 == 32 || a1 == 48 || a1 == 33 || a1 == 34 )
  {
    v2 = sub_10043FF0((_DWORD *)a2, 2u, (int)&unk_100FDFE0, 8, 77, 77);
    if ( v2 != 77 )
    {
      if ( *(_WORD *)a2 == -32768 )
      {
        v3 = *(_WORD *)(a2 + 10) + 16;
      }
      else if ( *(_WORD *)a2 == -32767 )
      {
        v3 = *(_DWORD *)(a2 + 4) + 8;
      }
      else
      {
        v3 = dword_100FDFE4[2 * v2] + 4;
      }
      v7 = v3;
      v10 = 65;
      v6 = a2;
      v9 = 10;
      v2 = sub_1007C1A0(a1, (int)&v6);
      if ( v2 == 16 )
      {
        v4 = sub_1007BFD0();
        sub_10042370(&v11, 0x3Cu, "message queue timed out sending from: %d to %d", v4, a1);
        LOBYTE(v2) = sub_10042930("..\\lib\\adl\\iop_msg_intf.c", 433, 0, &v11);
      }
    }
  }
  return v2;
}
// 100FDFE4: using guessed type int dword_100FDFE4[];

//----- (10047790) --------------------------------------------------------
char __cdecl sub_10047790(int a1)
{
  return sub_10047670(34, a1);
}

//----- (100477A0) --------------------------------------------------------
char __cdecl sub_100477A0(int a1)
{
  return sub_10047670(28, a1);
}

//----- (100477B0) --------------------------------------------------------
char __cdecl sub_100477B0(int a1)
{
  return sub_10047670(29, a1);
}

//----- (100477C0) --------------------------------------------------------
char __cdecl sub_100477C0(int a1)
{
  return sub_10047670(30, a1);
}

//----- (100477D0) --------------------------------------------------------
char __cdecl sub_100477D0(int a1)
{
  return sub_10047670(32, a1);
}

//----- (100477E0) --------------------------------------------------------
char __cdecl sub_100477E0(int a1)
{
  return sub_10047670(31, a1);
}

//----- (100477F0) --------------------------------------------------------
char __cdecl sub_100477F0(char a1)
{
  char result; // al@4

  if ( a1 )
  {
    if ( !sub_100471F0(6) && !sub_100471F0(11) )
    {
      result = sub_10047320(3);
      goto LABEL_9;
    }
  }
  else if ( !sub_100471F0(5) && !sub_100471F0(10) && !sub_10047220(27) )
  {
    result = sub_10047320(2);
LABEL_9:
    if ( !result )
      return result;
    return 1;
  }
  return 1;
}

//----- (10047860) --------------------------------------------------------
char __cdecl sub_10047860(char a1, void *a2)
{
  unsigned int v2; // eax@4
  signed int v3; // eax@13
  signed int v4; // eax@17
  int v6; // [sp-10h] [bp-24h]@2
  void *v7; // [sp-Ch] [bp-20h]@2
  int *v8; // [sp-4h] [bp-18h]@2
  int v9; // [sp+4h] [bp-10h]@1
  int v10; // [sp+8h] [bp-Ch]@1
  char v11; // [sp+Ch] [bp-8h]@1
  char v12; // [sp+Dh] [bp-7h]@1

  v9 = 1799500;
  v10 = 190000;
  v11 = 1;
  v12 = 50;
  if ( a1 )
  {
    v8 = &v9;
    v7 = a2;
    v6 = 10013;
  }
  else
  {
    v8 = &v9;
    v7 = a2;
    v6 = 10012;
  }
  LOBYTE(v2) = sub_1007C650(v6, v7, 12, v8);
  if ( *(_DWORD *)a2 > 0x1AB1FCu || *((_DWORD *)a2 + 1) > 0x1AB1FCu )
  {
    if ( sub_100471F0(10) || (LOBYTE(v2) = sub_100471F0(11), (_BYTE)v2) )
    {
      v4 = *(_DWORD *)a2;
      if ( *(_DWORD *)a2 >= 0x1AB1FCu )
        v4 = 1749500;
      *(_DWORD *)a2 = v4;
      v2 = *((_DWORD *)a2 + 1);
      if ( v2 >= 0x1AB1FC )
        v2 = 1749500;
      goto LABEL_21;
    }
  }
  if ( *(_DWORD *)a2 > 0x1B7358u || *((_DWORD *)a2 + 1) > 0x1B7358u )
  {
    if ( sub_10047220(27) || sub_10047320(2) || (LOBYTE(v2) = sub_10047320(3), (_BYTE)v2) )
    {
      v3 = *(_DWORD *)a2;
      if ( *(_DWORD *)a2 >= 0x1B7358u )
        v3 = 1799000;
      *(_DWORD *)a2 = v3;
      v2 = *((_DWORD *)a2 + 1);
      if ( v2 >= 0x1B7358 )
      {
        LOBYTE(v2) = 88;
        *((_DWORD *)a2 + 1) = 1799000;
        return v2;
      }
LABEL_21:
      *((_DWORD *)a2 + 1) = v2;
      return v2;
    }
  }
  return v2;
}

//----- (10047990) --------------------------------------------------------
char __cdecl sub_10047990(char a1, int a2, int a3, int a4, char a5)
{
  int v6; // [sp-14h] [bp-24h]@4
  int *v7; // [sp-10h] [bp-20h]@4
  char v8; // [sp-Ch] [bp-1Ch]@4
  int v9; // [sp+0h] [bp-10h]@1
  int v10; // [sp+4h] [bp-Ch]@1
  int v11; // [sp+8h] [bp-8h]@1

  v9 = a2;
  v10 = a3;
  v11 = a4;
  if ( a1 )
  {
    if ( a5 )
      sub_1007C500(10013, (int)&v9, 12);
    v8 = 0;
    v7 = &v9;
    v6 = 244;
  }
  else
  {
    if ( a5 )
      sub_1007C500(10012, (int)&v9, 12);
    v8 = 0;
    v7 = &v9;
    v6 = 235;
  }
  return sub_10024E60(1, v6, v7, v8, 12, 1);
}

//----- (10047A30) --------------------------------------------------------
char __cdecl sub_10047A30(int a1, int a2, int a3)
{
  char v3; // bl@1

  SYS_enter_krnl();
  v3 = SYS_pvg_alrt_get_hdr_text(a1, a2, a3);
  SYS_exit_krnl();
  return v3;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DA50: using guessed type int __cdecl SYS_pvg_alrt_get_hdr_text(_DWORD, _DWORD, _DWORD);

//----- (10047A60) --------------------------------------------------------
char __cdecl sub_10047A60(__int16 a1)
{
  char v1; // bl@1
  __int16 v3; // [sp+4h] [bp-A0h]@1

  v3 = a1;
  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_id_is_set(&v3, 0);
  SYS_exit_krnl();
  return v1;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DA56: using guessed type int __cdecl SYS_pvg_alrt_id_is_set(_DWORD, _DWORD);

//----- (10047AC0) --------------------------------------------------------
char __cdecl sub_10047AC0(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_is_set_queued(a1);
  SYS_exit_krnl();
  return v1;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DA5C: using guessed type int __cdecl SYS_pvg_alrt_is_set_queued(_DWORD);

//----- (10047AE0) --------------------------------------------------------
char __cdecl sub_10047AE0(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_is_set_text(a1, 1);
  SYS_exit_krnl();
  return v1;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DA62: using guessed type int __cdecl SYS_pvg_alrt_is_set_text(_DWORD, _DWORD);

//----- (10047B50) --------------------------------------------------------
char __cdecl sub_10047B50(char a1, int a2, int a3)
{
  int v3; // esi@1
  unsigned __int8 v4; // bl@2
  bool v5; // zf@3
  char v6; // dl@7
  int v8; // [sp+Ch] [bp-4h]@4

  v3 = a3;
  if ( *(_DWORD *)(a3 + 60) == 0x3FFFF )
    return 0;
  v4 = a2;
  if ( *(_DWORD *)(v3 + 8) != sub_1004AEF0(a2, 1) )
    return 0;
  v5 = *(_BYTE *)(v3 + 2) == -1;
  LOBYTE(a3) = 1;
  if ( v5 )
  {
    if ( !(a1 & 2) || *(float *)(v3 + 16) <= 370400.0 )
      return 1;
    return 0;
  }
  sub_10048200((int)&v8, *(float *)(v3 + 32));
  sub_10048200((int)&a2, *(float *)(v3 + 40));
  a2 = v8 - a2;
  sub_1007C470(v4 + 2061, &v8, 4, &a2);
  if ( a1 & 1
    && (signed int)((a2 - v8 - ((unsigned int)(a2 - v8) >> 31)) ^ ((signed int)(a2 - v8 - ((unsigned int)(a2 - v8) >> 31)) >> 31)) > 119304647
    && *(float *)(v3 + 16) <= 92600.0 )
  {
    v6 = 0;
  }
  else
  {
    v6 = a3;
  }
  if ( a1 & 2 && *(float *)(v3 + 16) > 92600.0 )
    return 0;
  return v6;
}

//----- (10047C60) --------------------------------------------------------
void __cdecl sub_10047C60(char a1, int a2)
{
  int v2; // edi@4
  int v3; // eax@4
  int v4; // ecx@4
  int v5; // ecx@4
  char v6; // al@4
  signed int v7; // ST2C_4@5
  double v8; // st4@22
  double v9; // st6@22
  double v10; // st3@22
  double v11; // st2@27
  bool v12; // c0@27
  bool v13; // c3@27
  double v14; // st6@27
  float v15; // ST2C_4@48
  double v16; // st7@48
  bool v17; // zf@50
  bool v18; // [sp+1Fh] [bp-55h]@4
  float v19; // [sp+20h] [bp-54h]@48
  int v20; // [sp+24h] [bp-50h]@4
  int v21; // [sp+28h] [bp-4Ch]@4
  int v22; // [sp+2Ch] [bp-48h]@4
  int v23; // [sp+30h] [bp-44h]@4
  int v24; // [sp+34h] [bp-40h]@4
  char v25; // [sp+38h] [bp-3Ch]@4
  char v26; // [sp+48h] [bp-2Ch]@51
  char v27; // [sp+58h] [bp-1Ch]@47
  char v28; // [sp+68h] [bp-Ch]@6

  if ( !(unsigned __int8)sub_1004A110() || a1 != 3 && a1 != 4 )
  {
    *(float *)(a2 + 16) = 9.9999996e24;
    *(_DWORD *)(a2 + 60) = 0x3FFFF;
    *(_BYTE *)(a2 + 64) = 0;
    *(float *)(a2 + 12) = 6.2831855;
    *(_BYTE *)(a2 + 71) = 0;
    *(float *)(a2 + 32) = 6.2831855;
    *(_BYTE *)(a2 + 2) = -1;
    *(float *)(a2 + 36) = 6.2831855;
    *(_BYTE *)a2 = -1;
    *(float *)(a2 + 24) = 6.2831855;
    *(_BYTE *)(a2 + 1) = 0;
    *(_BYTE *)(a2 + 3) = 0;
    *(float *)(a2 + 28) = 9.9999996e24;
    *(_BYTE *)(a2 + 4) = 0;
    *(float *)(a2 + 40) = 0.0;
    *(float *)(a2 + 20) = 9.9999996e24;
    *(float *)(a2 + 44) = 9.9999996e24;
    *(float *)(a2 + 48) = 9.9999996e24;
    *(float *)(a2 + 52) = 9.9999996e24;
    *(float *)(a2 + 56) = 6.2831855;
    return;
  }
  v18 = sub_100419B0(0, (int)&v25);
  sub_1007C110(100, 10000);
  v2 = a2 + 71;
  v3 = 88 * (a1 == 4);
  *(_BYTE *)a2 = *(_BYTE *)(v3 + dword_10333D60 + 68);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + dword_10333D60 + 84);
  *(float *)(a2 + 20) = *(float *)(v3 + dword_10333D60 + 92);
  *(float *)(a2 + 24) = *(float *)(v3 + dword_10333D60 + 96);
  *(_BYTE *)(a2 + 1) = *(_BYTE *)(v3 + dword_10333D60 + 69);
  *(_BYTE *)(a2 + 2) = *(_BYTE *)(v3 + dword_10333D60 + 70);
  *(float *)(a2 + 32) = *(float *)(v3 + dword_10333D60 + 100);
  *(float *)(a2 + 36) = *(float *)(v3 + dword_10333D60 + 104);
  *(float *)(a2 + 40) = *(float *)(v3 + dword_10333D60 + 108);
  *(float *)(a2 + 44) = *(float *)(v3 + dword_10333D60 + 112);
  *(float *)(a2 + 48) = *(float *)(v3 + dword_10333D60 + 116);
  *(float *)(a2 + 52) = *(float *)(v3 + dword_10333D60 + 120);
  *(_BYTE *)(a2 + 3) = *(_BYTE *)(v3 + dword_10333D60 + 74);
  *(_DWORD *)(a2 + 60) = *(_DWORD *)(v3 + dword_10333D60 + 88);
  v4 = dword_10333D60;
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(v3 + dword_10333D60 + 147);
  *(_WORD *)(a2 + 68) = *(_WORD *)(v3 + v4 + 151);
  *(_BYTE *)(a2 + 70) = *(_BYTE *)(v3 + v4 + 153);
  v5 = v3 + dword_10333D60 + 147;
  *(_DWORD *)v2 = *(_DWORD *)v5;
  *(_WORD *)(v2 + 4) = *(_WORD *)(v5 + 4);
  *(_BYTE *)(v2 + 6) = *(_BYTE *)(v5 + 6);
  v21 = *(_DWORD *)(v3 + dword_10333D60 + 132);
  v22 = *(_DWORD *)(v3 + dword_10333D60 + 136);
  v23 = *(_DWORD *)(v3 + dword_10333D60 + 124);
  v24 = *(_DWORD *)(v3 + dword_10333D60 + 128);
  sub_1007C0F0(100);
  *(float *)(a2 + 56) = 6.2831855;
  v6 = sub_10048590(a1, &v20);
  *(_BYTE *)(a2 + 4) = v6;
  if ( v6 )
  {
    v7 = (signed __int16)(v20 + -32768);
    v20 -= 0x8000;
    *(float *)(a2 + 56) = (double)v7 * 0.00009587379924285279;
  }
  if ( !sub_100484D0(a1, &v28) )
    v28 = 0;
  if ( strcmp(&v28, (const char *)(a2 + 71)) || *(_BYTE *)v2 == 95 )
    *(_BYTE *)v2 = 0;
  *(_BYTE *)(a2 + 75) = 0;
  if ( !v18 && !*(_BYTE *)v2 )
    *(_DWORD *)(a2 + 60) = 0x3FFFF;
  if ( (COERCE_UNSIGNED_INT(*(float *)(a2 + 20)) & 0x7F800000) == 2139095040 || *(float *)(a2 + 20) > 9.9999996e24 )
  {
    *(float *)(a2 + 20) = 9.9999996e24;
  }
  else if ( *(float *)(a2 + 20) < -1000.0 )
  {
    *(float *)(a2 + 20) = -1000.0;
  }
  if ( (COERCE_UNSIGNED_INT(*(float *)(a2 + 32)) & 0x7F800000) == 2139095040 || *(float *)(a2 + 32) > 6.283185482025146 )
  {
    v10 = 6.2831855;
    *(float *)(a2 + 32) = 6.2831855;
  }
  else
  {
    if ( *(float *)(a2 + 32) < -6.283185482025146 )
    {
      v8 = -6.2831855;
      v9 = 6.283185482025146;
      *(float *)(a2 + 32) = -6.2831855;
      v10 = 6.2831855;
      goto LABEL_26;
    }
    v10 = 6.2831855;
  }
  v9 = 6.283185482025146;
  v8 = -6.2831855;
LABEL_26:
  if ( (COERCE_UNSIGNED_INT(*(float *)(a2 + 40)) & 0x7F800000) == 2139095040 )
  {
    v14 = v10;
  }
  else
  {
    v11 = *(float *)(a2 + 40);
    v12 = v11 < v9;
    v13 = v11 == v9;
    v14 = v10;
    if ( v12 || v13 )
    {
      if ( *(float *)(a2 + 40) < -6.283185482025146 )
        *(float *)(a2 + 40) = v8;
      goto LABEL_32;
    }
  }
  *(float *)(a2 + 40) = v14;
LABEL_32:
  if ( (COERCE_UNSIGNED_INT(*(float *)(a2 + 44)) & 0x7F800000) == 2139095040 || *(float *)(a2 + 44) > 9.9999996e24 )
  {
    *(float *)(a2 + 44) = 9.9999996e24;
  }
  else if ( *(float *)(a2 + 44) < 0.0 )
  {
    *(float *)(a2 + 44) = 0.0;
  }
  if ( (COERCE_UNSIGNED_INT(*(float *)(a2 + 48)) & 0x7F800000) == 2139095040 || *(float *)(a2 + 48) > 9.9999996e24 )
  {
    *(float *)(a2 + 48) = 9.9999996e24;
  }
  else if ( *(float *)(a2 + 48) < 0.0 )
  {
    *(float *)(a2 + 48) = 0.0;
  }
  if ( (COERCE_UNSIGNED_INT(*(float *)(a2 + 36)) & 0x7F800000) == 2139095040
    || *(float *)(a2 + 36) > 0.17453292
    || *(float *)(a2 + 36) < 0.0 )
  {
    *(float *)(a2 + 36) = 0.0;
  }
  if ( *(_DWORD *)(a2 + 60) == 0x3FFFF )
  {
    *(float *)(a2 + 32) = v14;
    *(float *)(a2 + 36) = v14;
    *(_BYTE *)(a2 + 2) = -1;
    *(_BYTE *)a2 = -1;
    *(float *)(a2 + 20) = 9.9999996e24;
    *(_BYTE *)(a2 + 1) = 0;
    *(float *)(a2 + 16) = 9.9999996e24;
    *(float *)(a2 + 28) = 9.9999996e24;
    *(float *)(a2 + 44) = 9.9999996e24;
    *(float *)(a2 + 12) = v14;
    *(float *)(a2 + 24) = v14;
  }
  else
  {
    sub_10062080((int)&v21, (int)&unk_100FF628);
    sub_1007BDD0((int)&v21, (int)&v27);
    if ( v18 )
    {
      sub_10091760((int)&v27, (int)&v25, (float *)(a2 + 16), &v19);
      v15 = v19 + 3.141592741012573;
      v16 = sub_1007BCB0(v15);
    }
    else
    {
      *(float *)(a2 + 16) = 9.9999996e24;
      v16 = 6.2831855;
    }
    v17 = *(_BYTE *)(a2 + 1) == 0;
    *(float *)(a2 + 12) = v16;
    if ( v17
      || (sub_10045800(6.2831855, -6.2831855),
          sub_10062080((int)&v23, (int)&unk_100FF628),
          sub_1007BDD0((int)&v23, (int)&v26),
          !v18) )
    {
      *(float *)(a2 + 28) = 9.9999996e24;
    }
    else
    {
      sub_10091760((int)&v25, (int)&v26, (float *)(a2 + 28), &v19);
    }
  }
}
// 10333D60: using guessed type int dword_10333D60;

//----- (10048200) --------------------------------------------------------
int __cdecl sub_10048200(int a1, float a2)
{
  int result; // eax@1

  result = (signed int)(sub_1007BCB0(a2) * 683565248.0);
  *(_DWORD *)a1 = result;
  return result;
}

//----- (10048230) --------------------------------------------------------
char __thiscall sub_10048230(void *this)
{
  char v1; // bl@1
  char result; // al@3

  v1 = sub_1003F480((int)this);
  if ( !sub_10041770() || v1 )
    result = v1;
  else
    result = *(_BYTE *)(dword_1033707C + 141);
  return result;
}
// 1033707C: using guessed type int dword_1033707C;

//----- (10048260) --------------------------------------------------------
char sub_10048260()
{
  char v0; // bl@1
  char v1; // al@3

  v0 = 0;
  if ( sub_10041770() )
  {
    sub_10061E50();
    if ( *(_BYTE *)(dword_10337070 + 235) )
    {
      v1 = *(_BYTE *)(dword_1033707C + 141);
      if ( (v1 == 1 || v1 == 2)
        && *(_DWORD *)(dword_1033707C + 8 * *(_BYTE *)(dword_1033707C + 204) + 1228) == *(_DWORD *)(dword_10337070 + 260) )
      {
        v0 = 1;
      }
    }
    sub_10061E40();
  }
  return v0;
}
// 10337070: using guessed type int dword_10337070;
// 1033707C: using guessed type int dword_1033707C;

//----- (100482C0) --------------------------------------------------------
int __cdecl sub_100482C0(char a1, int a2, int *a3)
{
  char v3; // bl@1
  void *v4; // ecx@1
  int result; // eax@1
  bool v6; // cl@1
  double v7; // st7@4
  int v8; // ecx@6
  int v9; // ecx@6
  int v10; // [sp+14h] [bp-18h]@1
  __int16 v11; // [sp+1Eh] [bp-Eh]@6

  v3 = sub_10048480(a1 + 3, &v10);
  result = sub_1003F570(v4);
  v6 = (v10 & 0x200) == 512;
  *(_BYTE *)(a2 + 1) = (v10 & 0x100) == 256;
  *(_BYTE *)(a2 + 3) = v6;
  if ( !v3 )
    *(_BYTE *)(a2 + 1) = 1;
  if ( *(_BYTE *)(a2 + 1) )
  {
    v7 = 0.0;
    *(_DWORD *)(a2 + 8) = 0;
LABEL_11:
    *(float *)(a2 + 4) = v7;
    *(_BYTE *)(a2 + 2) = 2;
    *a3 = 0;
    return result;
  }
  if ( !v6 )
  {
    result = v11 << 16;
    v7 = (double)((signed int)v11 << 16) * 0.000000001201706512077294;
    goto LABEL_11;
  }
  v8 = (v11 - 0x8000) << 16;
  *(_DWORD *)(a2 + 8) = v8;
  v9 = v8 - result;
  result = v9 ^ 2 * v9;
  if ( (v9 ^ 2 * v9) >= 0 )
  {
    *(_BYTE *)(a2 + 2) = 0;
  }
  else
  {
    *(_BYTE *)(a2 + 2) = 1;
    v9 = -v9;
  }
  *(float *)(a2 + 4) = (double)(2 * v9) * 0.000000004190951585769653;
  *a3 = v9;
  return result;
}

//----- (100483C0) --------------------------------------------------------
int __cdecl sub_100483C0(char a1, int a2)
{
  int v2; // ecx@0
  int result; // eax@4
  int v4; // [sp+0h] [bp-4h]@1

  v4 = v2;
  if ( sub_10041770() && (a1 == 1 || a1 == 2) )
  {
    sub_100482C0(a1 - 1, a2, &v4);
    result = dword_1033707C;
    *(_BYTE *)(a2 + 2) = *(_BYTE *)(dword_1033707C + 1229);
    *(_BYTE *)a2 = 1;
  }
  else
  {
    result = a2;
    *(float *)(a2 + 4) = 0.0;
    *(_BYTE *)(a2 + 1) = 1;
    *(_BYTE *)(a2 + 2) = 2;
    *(_BYTE *)(a2 + 3) = 1;
    *(_DWORD *)(a2 + 8) = 0;
    *(_BYTE *)a2 = 0;
  }
  return result;
}
// 1033707C: using guessed type int dword_1033707C;

//----- (10048430) --------------------------------------------------------
int __cdecl sub_10048430(int a1)
{
  void *v1; // ecx@0
  char v2; // al@1

  v2 = sub_10048230(v1);
  return sub_100483C0(v2, a1);
}

//----- (10048450) --------------------------------------------------------
bool __cdecl sub_10048450(unsigned int a1)
{
  return a1 - 108100 <= 0xF0A && a1 / 0x64 & 1;
}

//----- (10048480) --------------------------------------------------------
char __cdecl sub_10048480(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  *(_DWORD *)a2 = 0;
  *((_DWORD *)a2 + 1) = 0;
  *((_DWORD *)a2 + 2) = 0;
  *((_DWORD *)a2 + 3) = 0;
  *((_DWORD *)a2 + 4) = 0;
  if ( a1 == 3 )
  {
    result = sub_100253C0(0, 176, a2);
  }
  else if ( a1 == 4 )
  {
    result = sub_100253C0(0, 183, a2);
  }
  return result;
}

//----- (100484D0) --------------------------------------------------------
char __cdecl sub_100484D0(char a1, char *a2)
{
  char result; // al@4
  int v3; // [sp+4h] [bp-18h]@1
  char v4; // [sp+10h] [bp-Ch]@2

  if ( sub_10048480(a1, &v3) != 1 || !v4 || v3 & 0x100 )
  {
    result = 0;
    if ( v3 & 0x200 )
      strcpy(a2, "___");
    else
      strcpy(a2, "____");
  }
  else
  {
    sub_100421E0((int)a2, &v4, 7);
    result = 1;
  }
  return result;
}

//----- (10048590) --------------------------------------------------------
char __cdecl sub_10048590(char a1, _WORD *a2)
{
  char result; // al@4
  int v3; // [sp+4h] [bp-18h]@1
  __int16 v4; // [sp+Eh] [bp-Eh]@4

  if ( sub_10048480(a1, &v3) && !(v3 & 0x100) && v3 & 0x200 )
  {
    *a2 = v4;
    result = 1;
  }
  else
  {
    *a2 = v4;
    result = 0;
  }
  return result;
}

//----- (10048600) --------------------------------------------------------
int __cdecl sub_10048600(char a1, _DWORD *a2)
{
  int result; // eax@1
  char v3; // [sp+4h] [bp-18h]@1
  int v4; // [sp+8h] [bp-14h]@1

  LOBYTE(result) = sub_10048480(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (10048640) --------------------------------------------------------
char __cdecl sub_10048640(void *a1)
{
  return sub_1003F820(25, a1);
}

//----- (10048650) --------------------------------------------------------
char __cdecl sub_10048650(void *a1)
{
  return sub_1003F820(31, a1);
}

//----- (10048660) --------------------------------------------------------
BOOL sub_10048660()
{
  return sub_10046D90(9) || sub_10046D90(10);
}

//----- (10048690) --------------------------------------------------------
int __usercall sub_10048690@<eax>(char a1@<al>, int a2@<ecx>)
{
  int v2; // esi@3
  int result; // eax@3

  if ( a1 && a1 != 2 )
  {
    v2 = a2 - sub_1002A7A0(a1);
    result = v2 + sub_1002A7A0(0);
  }
  else
  {
    result = a2;
  }
  return result;
}

//----- (100486C0) --------------------------------------------------------
char __thiscall sub_100486C0(void *this)
{
  char v1; // al@1
  char result; // al@2
  char v3; // [sp+4h] [bp-8h]@1
  int v4; // [sp+8h] [bp-4h]@2

  v1 = sub_10045280(this);
  v3 = sub_10045200(v1, 1);
  if ( (unsigned __int8)sub_10048660() )
  {
    result = sub_1003F7A0(28, v3, &v4);
    if ( result != 1 || !(v4 & 0x800) )
      result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10048720) --------------------------------------------------------
char __thiscall sub_10048720(void *this)
{
  char v1; // al@1
  char v3; // [sp+0h] [bp-Ch]@1
  int v4; // [sp+4h] [bp-8h]@2
  int v5; // [sp+8h] [bp-4h]@5

  v1 = sub_10045280(this);
  v3 = sub_10045200(v1, 1);
  if ( (unsigned __int8)sub_10048660() )
  {
    if ( sub_1003F7A0(28, v3, &v4) != 1 || v4 & 0x2000 )
      return 0;
  }
  else if ( sub_100644A0(&v5) != 1 || !(v5 & 0x10000) )
  {
    return 0;
  }
  return 1;
}

//----- (10048790) --------------------------------------------------------
char __cdecl sub_10048790(char a1, char a2, int *a3)
{
  char v3; // bl@1
  void *v4; // ecx@1
  void *v5; // ecx@2
  char result; // al@4
  int v7; // esi@9
  void *v8; // ecx@12
  int v9; // esi@14
  char v10; // [sp+8h] [bp-14h]@1
  char v11; // [sp+9h] [bp-13h]@1
  char v12; // [sp+Ah] [bp-12h]@1
  char v13; // [sp+Bh] [bp-11h]@1
  int v14; // [sp+Ch] [bp-10h]@1
  int v15; // [sp+10h] [bp-Ch]@1
  int v16; // [sp+14h] [bp-8h]@1
  int v17; // [sp+18h] [bp-4h]@1

  v3 = sub_1003F7A0(16, a2, &v14);
  v12 = sub_1003F7A0(17, a2, &v16);
  v10 = sub_1002AD10();
  v11 = sub_1003F7A0(51, a2, &v15);
  v13 = sub_1003F7A0(52, a2, &v17);
  switch ( a1 )
  {
    case 0:
    case 2:
    case 3:
      if ( sub_10048720(v4) )
      {
        if ( !v3 )
          return 0;
        v7 = v14;
        if ( v10 == 1 )
          v7 -= sub_1002A7A0(0);
        *a3 = sub_10048690(a1, v7);
        result = 1;
      }
      else if ( v3 )
      {
        *a3 = sub_10048690(a1, v14);
        result = 1;
      }
      else
      {
        if ( !v11 || !sub_100486C0(v5) )
          return 0;
        *a3 = sub_10048690(a1, v15);
        result = 1;
      }
      return result;
    case 1:
      if ( sub_10048720(v4) )
      {
        if ( !v3 )
          return 0;
        v9 = v14;
        if ( v10 == 1 )
          goto LABEL_15;
        *a3 = sub_1002A7A0(0) + v9;
        result = 1;
      }
      else
      {
        if ( v12 )
        {
          v9 = v16;
LABEL_15:
          *a3 = v9;
          return 1;
        }
        if ( !v13 || !sub_100486C0(v8) )
          return 0;
        *a3 = v17;
        result = 1;
      }
      return result;
    default:
      sub_10042930("..\\lib\\acl\\iop\\iop_ahrs_data_intf.c", 1859, 1, 0);
      return 0;
  }
}

//----- (10048940) --------------------------------------------------------
char __cdecl sub_10048940(char a1, int *a2, char a3)
{
  char result; // al@3
  char v4; // bl@4
  int v5; // [sp+4h] [bp-4h]@1

  v5 = 0;
  if ( a3 != 2 && sub_10046D90(a3 + 9) )
  {
    result = sub_10048790(a1, a3, a2);
  }
  else
  {
    v4 = sub_1003F7A0(16, a3, &v5);
    if ( v4 )
      *a2 = sub_10048690(a1, v5);
    result = v4;
  }
  return result;
}

//----- (100489B0) --------------------------------------------------------
char __cdecl sub_100489B0(char a1, int *a2)
{
  void *v2; // ecx@0
  char v3; // al@1
  char v4; // al@1

  v3 = sub_10045280(v2);
  v4 = sub_10045200(v3, 1);
  return sub_10048940(a1, a2, v4);
}

//----- (100489E0) --------------------------------------------------------
int __cdecl sub_100489E0(int a1, signed int a2, signed int a3)
{
  int result; // eax@1

  result = a1;
  *(double *)(a1 + 8) = (double)a3 * 0.000000001462918079267163;
  *(double *)a1 = 0.000000001462918079267163 * (double)a2;
  return result;
}

//----- (10048A00) --------------------------------------------------------
int __cdecl sub_10048A00(int a1, double a2, double a3)
{
  long double v3; // st6@1
  long double v4; // st4@1
  int result; // eax@3
  double v6; // st7@6
  double v7; // [sp+0h] [bp-10h]@6
  double v8; // [sp+8h] [bp-8h]@6

  v3 = fabs(a2);
  v4 = fabs(a3);
  if ( v3 > 1.5707963267949 || v4 >= 3.1415926535898 )
  {
    if ( v3 > 4.7123889803847 || v4 > 12.5663706143592 )
    {
      result = a1;
      *(_DWORD *)a1 = 2147483648;
      *(_DWORD *)(a1 + 4) = 2147483648;
    }
    else
    {
      v7 = a2;
      v8 = a3;
      sub_10061F80((int)&v7);
      v6 = 683565275.5764301 * v8;
      *(_DWORD *)a1 = (signed int)(v7 * 683565275.5764301);
      result = (signed int)v6;
      *(_DWORD *)(a1 + 4) = (signed int)v6;
    }
  }
  else
  {
    *(_DWORD *)a1 = (signed int)(a2 * 683565275.5764301);
    result = (signed int)(683565275.5764301 * a3);
    *(_DWORD *)(a1 + 4) = result;
  }
  return result;
}

//----- (10048AE0) --------------------------------------------------------
int __cdecl sub_10048AE0(int a1, float a2, float a3)
{
  double v3; // st7@1
  int result; // eax@3
  double v5; // st7@6
  float v6; // [sp+0h] [bp-14h]@1
  double v7; // [sp+4h] [bp-10h]@6
  double v8; // [sp+Ch] [bp-8h]@6
  float v9; // [sp+1Ch] [bp+8h]@1

  v3 = a2;
  v6 = fabs(a2);
  v9 = fabs(a3);
  if ( v6 > 1.570796370506287 || v9 >= 3.141592741012573 )
  {
    if ( v6 > 4.7123889803847 || v9 > 12.5663706143592 )
    {
      result = a1;
      *(_DWORD *)a1 = 2147483648;
      *(_DWORD *)(a1 + 4) = 2147483648;
    }
    else
    {
      v7 = v3;
      v8 = a3;
      sub_10061F80((int)&v7);
      v5 = 683565275.5764301 * v8;
      *(_DWORD *)a1 = (signed int)(v7 * 683565275.5764301);
      result = (signed int)v5;
      *(_DWORD *)(a1 + 4) = (signed int)v5;
    }
  }
  else
  {
    *(_DWORD *)a1 = (signed int)(v3 * 683565248.0);
    result = (signed int)(683565248.0 * a3);
    *(_DWORD *)(a1 + 4) = result;
  }
  return result;
}

//----- (10048BD0) --------------------------------------------------------
char __cdecl sub_10048BD0(float a1, float a2, int a3)
{
  int v3; // ecx@0
  char result; // al@3
  int v5; // [sp+10h] [bp-4h]@1

  v5 = v3;
  if ( !sub_10025390(6, v3, 0, 4, &v5) || sub_10054420((int)&v5, a1, a2, COERCE_INT(0.0), 0) )
  {
    result = 0;
  }
  else
  {
    *(float *)a3 = *(float *)&v5;
    result = 1;
  }
  return result;
}

//----- (10048C30) --------------------------------------------------------
char __thiscall sub_10048C30(void *this)
{
  void *v1; // ecx@1
  char v2; // al@2
  int v3; // eax@2
  void *v4; // ecx@2
  char result; // al@4
  void *v6; // [sp-2h] [bp-4h]@1

  v6 = this;
  sub_1007C3B0(6612, (int)&v6 + 3, 1);
  if ( BYTE3(v6) == 5 )
  {
    v2 = sub_10045280(v1);
    v3 = (unsigned __int8)sub_10045200(v2, 0);
    if ( (_BYTE)v3 )
    {
      if ( v3 == 1 )
        result = 1;
      else
        result = sub_10045280(v4);
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = sub_100429D0(v1) == 2;
  }
  return result;
}

//----- (10048C90) --------------------------------------------------------
char __cdecl sub_10048C90(float *a1)
{
  void *v1; // ecx@0
  __int16 v2; // cx@1

  *a1 = 0.0;
  v2 = word_100FFC8C[11 * (unsigned __int8)sub_10048C30(v1)];
  return sub_10048BD0(-3.1415927, 3.1415927, (int)a1);
}
// 100FFC8C: using guessed type __int16 word_100FFC8C[];

//----- (10048CD0) --------------------------------------------------------
bool __cdecl sub_10048CD0(char a1)
{
  char v1; // bl@1
  char v2; // cl@1
  char v4; // [sp+5h] [bp-1Bh]@1
  char v5; // [sp+6h] [bp-1Ah]@1
  char v6; // [sp+7h] [bp-19h]@1
  float v7; // [sp+8h] [bp-18h]@1
  char v8; // [sp+Ch] [bp-14h]@1
  char v9; // [sp+10h] [bp-10h]@1
  char v10; // [sp+14h] [bp-Ch]@1
  char v11; // [sp+18h] [bp-8h]@1
  char v12; // [sp+1Ch] [bp-4h]@1

  v4 = sub_10045980(&v8);
  v7 = sub_1003F3E0();
  v5 = sub_10045A40((float *)&v9);
  v1 = sub_10045B40(&v10);
  v6 = sub_10048650(&v11);
  v2 = sub_10045C60(&v12);
  if ( !a1 )
    v1 = 1;
  return v4 && 9.8999998e24 != v7 && v5 && v1 && v6 && v2;
}

//----- (10048D70) --------------------------------------------------------
int sub_10048D70()
{
  double v0; // st7@2
  char v2; // [sp+2h] [bp-16h]@1
  char v3; // [sp+3h] [bp-15h]@1
  float v4; // [sp+4h] [bp-14h]@2
  float v5; // [sp+8h] [bp-10h]@2
  float v6; // [sp+Ch] [bp-Ch]@1
  int v7; // [sp+10h] [bp-8h]@2

  v2 = 2;
  byte_1027EA9C = 1;
  sub_1003EC70(&v6);
  sub_1007C470(2120, &v3, 1, &v2);
  if ( v3 )
  {
    LOBYTE(v7) = 0;
    v4 = *(float *)(dword_10337080 + 30400);
    v5 = *(float *)(dword_10337080 + 33276);
    v0 = v4;
    if ( v5 >= (double)v4 )
      v0 = v5;
    v6 = v0;
  }
  return sub_1003EEB0(v6, v7, 0);
}
// 1027EA9C: using guessed type char byte_1027EA9C;
// 10337080: using guessed type int dword_10337080;

//----- (10048E10) --------------------------------------------------------
char sub_10048E10()
{
  int v0; // ebx@1
  void *v1; // ecx@1
  int v2; // eax@3
  int v3; // eax@4
  char result; // al@6
  signed int v5; // esi@7
  void *v6; // ecx@7
  signed int v7; // esi@8
  void *v8; // ecx@8
  char v9; // [sp+4h] [bp-8h]@1
  int v10; // [sp+8h] [bp-4h]@1

  v0 = j_HWM_pvg_hsdb_get_lrus_online();
  v9 = 0;
  if ( sub_10047290(2, &v10) )
    v9 = sub_100470F0(2, v10) != 0 ? 2 : 0;
  v2 = (unsigned __int8)sub_1004A0B0(v1);
  if ( (_BYTE)v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        v5 = sub_10049CB0(1);
        result = ((v5 & v0) == 0) | (sub_1003EB30(v6) == 2);
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      v7 = sub_10049CB0(v9);
      result = ((v7 & v0) == 0) | (sub_1003EB30(v8) != 2);
    }
  }
  else
  {
    result = (v0 & 3) == 0;
  }
  return result;
}
// 1007C810: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (10048ED0) --------------------------------------------------------
char sub_10048ED0()
{
  char v0; // bl@1
  double v1; // st7@2
  float v2; // ST08_4@2
  char result; // al@4
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v0 = sub_10045D40(&v5);
  v4 = sub_1003F3E0();
  if ( v0 && (v1 = v4, v2 = v4 - v5, COERCE_FLOAT(LODWORD(v2) & 0x7FFFFFFF) >= 22.86) )
  {
    if ( v5 >= v1 )
    {
      result = 0;
      byte_1027EA9C = 0;
    }
    else
    {
      result = 1;
      byte_1027EA9C = 1;
    }
  }
  else
  {
    result = byte_1027EA9C;
  }
  return result;
}
// 1027EA9C: using guessed type char byte_1027EA9C;

//----- (10048F50) --------------------------------------------------------
char sub_10048F50()
{
  char v0; // bl@1
  char result; // al@1
  int v2; // edx@5
  char v3; // al@6
  __int16 v4; // cx@6
  double v5; // st7@13
  double v6; // st7@23
  char v7; // [sp+Dh] [bp-33h]@1
  char v8; // [sp+Eh] [bp-32h]@1
  char v9; // [sp+Fh] [bp-31h]@1
  char v10; // [sp+10h] [bp-30h]@1
  char v11; // [sp+11h] [bp-2Fh]@1
  char v12; // [sp+12h] [bp-2Eh]@1
  char v13; // [sp+13h] [bp-2Dh]@1
  float v14; // [sp+14h] [bp-2Ch]@15
  int v15; // [sp+18h] [bp-28h]@3
  int v16; // [sp+1Ch] [bp-24h]@3
  float v17; // [sp+20h] [bp-20h]@12
  float v18; // [sp+24h] [bp-1Ch]@1
  float v19; // [sp+28h] [bp-18h]@1
  float v20; // [sp+2Ch] [bp-14h]@1
  float v21; // [sp+30h] [bp-10h]@1
  float v22; // [sp+34h] [bp-Ch]@1
  char v23; // [sp+38h] [bp-8h]@1

  v11 = 0;
  sub_1007C470(9863, &v8, 1, &v11);
  v10 = 1;
  sub_10045D40(&v20);
  v0 = sub_10045980(&v18);
  v12 = sub_10045A40(&v21);
  v9 = sub_10045B40(&v19);
  sub_1003EC70(&v22);
  result = v23;
  v13 = v23;
  v7 = v23;
  if ( v0 )
  {
    if ( v23 )
    {
      *(float *)&v16 = v22;
      sub_10045440(v22, v18, (int)&v15);
      *(float *)&v15 = sub_1007BD40(*(float *)&v15, 0.51444447);
    }
    else
    {
      *(float *)&v15 = v22;
      sub_100453D0(v22, v18, (int)&v16);
      *(float *)&v16 = sub_1007BD40(*(float *)&v16, 0.0099999998);
    }
    v2 = dword_10337080;
    if ( !(*(_BYTE *)(dword_10337080 + 31728) & 1) )
    {
      v3 = sub_10048ED0();
      v2 = dword_10337080;
      v4 = *(_WORD *)(dword_10337080 + 31728);
      if ( v3 )
      {
        if ( v4 & 2 && *(float *)(dword_10337080 + 31736) < (double)v20 )
          v7 = 1;
        if ( v4 & 4 && v9 )
        {
          v17 = *(float *)(dword_10337080 + 31732);
          v5 = v4 & 8 ? *(float *)&v16 : v19;
          v14 = v5;
          if ( v17 < (double)v14 )
            v7 = 1;
        }
      }
      else
      {
        if ( v4 & 2 && *(float *)(dword_10337080 + 31744) > (double)v20 )
          v7 = 0;
        if ( v4 & 4 && v12 )
        {
          v17 = *(float *)(dword_10337080 + 31740);
          v6 = v4 & 8 ? *(float *)&v15 : v21;
          v14 = v6;
          if ( v17 < (double)v14 )
            v7 = 0;
        }
      }
    }
    if ( v13 == v7 )
    {
      if ( v8 )
      {
        v8 = 0;
        sub_1007C500(9863, (int)&v8, 1);
        v2 = dword_10337080;
      }
    }
    else if ( v8 )
    {
      v7 = v13;
    }
    if ( *(_WORD *)(v2 + 31728) & 0x100
      && (sub_100473B0((bool *)&v10) && v10 || v9 && *(float *)(dword_10337080 + 31364) > (double)v19) )
    {
      result = 0;
    }
    else
    {
      result = v7;
    }
  }
  return result;
}
// 10337080: using guessed type int dword_10337080;

//----- (100491F0) --------------------------------------------------------
char sub_100491F0()
{
  char v0; // bl@1
  char v1; // bl@6
  double v2; // st7@8
  float v3; // ST08_4@10
  char result; // al@11
  void *v5; // ecx@11
  char v6; // al@13
  double v7; // st7@22
  char v8; // [sp+11h] [bp-6Fh]@1
  char v9; // [sp+12h] [bp-6Eh]@1
  char v10; // [sp+13h] [bp-6Dh]@1
  int v11; // [sp+14h] [bp-6Ch]@8
  float v12; // [sp+18h] [bp-68h]@1
  int v13; // [sp+1Ch] [bp-64h]@13
  float v14; // [sp+20h] [bp-60h]@21
  float v15; // [sp+28h] [bp-58h]@23
  int v16; // [sp+30h] [bp-50h]@6
  int v17; // [sp+34h] [bp-4Ch]@6
  char v18; // [sp+38h] [bp-48h]@29
  char v19; // [sp+3Ch] [bp-44h]@29
  char v20; // [sp+40h] [bp-40h]@1
  char v21; // [sp+44h] [bp-3Ch]@2

  v0 = sub_1003F260(&v20);
  v9 = sub_10045980(&v12);
  v8 = 0;
  v10 = 0;
  if ( v0 )
  {
    if ( v21 == 6 || (v8 = 0, v21 == 7) )
      v8 = 1;
    v10 = sub_1003ED00((int)&v20);
  }
  sub_1003EC70(&v16);
  v1 = v17;
  if ( v9 )
  {
    if ( (_BYTE)v17 )
    {
      sub_10045440(*(float *)&v16, v12, (int)&v11);
      v2 = 0.51444447;
    }
    else
    {
      sub_100453D0(*(float *)&v16, v12, (int)&v11);
      v2 = 0.0099999998;
    }
    v3 = v2;
    *(float *)&v11 = sub_1007BD40(*(float *)&v11, v3);
  }
  result = sub_10048E10();
  if ( result )
  {
    if ( sub_1003EC40(v5) == 1 )
    {
      sub_1003EB70(&v18);
      if ( v19 == (_BYTE)v17 || !v9 )
        return sub_1003EEB0(*(float *)&v16, v17, 0);
      v7 = *(float *)&v11;
      LOBYTE(v17) = v19;
      goto LABEL_32;
    }
    v6 = sub_10048F50();
    LOBYTE(v13) = v6;
    if ( v1 != v6 && v9 )
    {
      if ( !v10 )
      {
LABEL_18:
        LOBYTE(v17) = v6;
        v16 = v11;
        goto LABEL_19;
      }
      if ( sub_10048CD0(v13) )
      {
        v6 = v13;
        goto LABEL_18;
      }
    }
LABEL_19:
    if ( !v10 )
      return sub_1003EEB0(*(float *)&v16, v17, 0);
    if ( !(unsigned __int8)sub_1003F500((int)&v20) )
    {
      if ( *(_BYTE *)(dword_10337080 + 31728) & 0x40 && v8 )
      {
        if ( (_BYTE)v17 )
          sub_10045B40(&v16);
        else
          sub_10045A40((float *)&v16);
      }
      return sub_1003EEB0(*(float *)&v16, v17, 0);
    }
    sub_1003EBF0(&v14);
    if ( (_BYTE)v17 )
      v7 = v14;
    else
      v7 = v15;
LABEL_32:
    *(float *)&v16 = v7;
    return sub_1003EEB0(*(float *)&v16, v17, 0);
  }
  return result;
}
// 10337080: using guessed type int dword_10337080;

//----- (100493F0) --------------------------------------------------------
char __cdecl sub_100493F0(_BYTE *a1, unsigned __int8 a2)
{
  _BYTE *v2; // esi@1
  char v3; // bl@3
  unsigned __int8 v4; // bl@6
  unsigned __int8 v5; // dl@6
  int v6; // edi@7
  char v7; // al@7
  unsigned __int8 v8; // al@9
  char v9; // cl@10
  size_t v10; // esi@14
  char result; // al@20
  unsigned __int8 v12; // [sp+Ah] [bp-1Ah]@6
  int v13; // [sp+10h] [bp-14h]@6
  int v14; // [sp+14h] [bp-10h]@1
  int v15; // [sp+18h] [bp-Ch]@1
  int v16; // [sp+1Ch] [bp-8h]@1

  v2 = a1;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( (unsigned int)a1 < 0xFFFFFFC2 && a1 && (v3 = a2) != 0 )
  {
    if ( a2 > 0xCu )
    {
      sub_10042930("..\\lib\\acl\\iop\\iop_acft_data_intf.c", 260, 0, 0);
      v3 = 12;
    }
    v13 = (unsigned __int8)v3;
    sub_100421E0((int)&v14, a1, (unsigned __int8)v3);
    v4 = v3 - 1;
    v5 = 0;
    v12 = 0;
    if ( v4 )
    {
      while ( 1 )
      {
        v6 = v5;
        v7 = *((_BYTE *)&v14 + v5);
        if ( !v7 )
          break;
        if ( v7 == 32 )
        {
          v8 = v5 + 1;
          if ( (unsigned __int8)(v5 + 1) < v4 )
          {
            while ( 1 )
            {
              v9 = *((_BYTE *)&v14 + v8);
              if ( v9 != 32 )
              {
                if ( v9 )
                  break;
              }
              if ( ++v8 >= v4 )
                goto LABEL_15;
            }
            v10 = (unsigned __int8)(v4 - v8);
            memcpy_0((char *)&v14 + v5, (char *)&v14 + v8, v10);
            v5 = v12;
            *((_BYTE *)&v14 + v6 + v10) = 0;
            v2 = a1;
          }
        }
LABEL_15:
        v12 = ++v5;
        if ( v5 >= v4 )
          goto LABEL_19;
      }
      if ( v5 < v4 )
        memset((char *)&v14 + v5, 32, (unsigned __int8)(v4 - v5));
    }
LABEL_19:
    *((_BYTE *)&v14 + v4) = 0;
    if ( sub_10042230(&v14, v2, v13) )
    {
      sub_100421E0((int)v2, &v14, v13);
      result = 0;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10049580) --------------------------------------------------------
char __cdecl sub_10049580(char *a1)
{
  char result; // al@4
  char v2; // [sp+8h] [bp-44h]@1

  memset(&v2, 0, 0x40u);
  if ( (unsigned int)a1 >= 0xFFFFFFC2 || !a1 || sub_1007C3B0(6786, (int)&v2, 64) )
  {
    result = 0;
  }
  else
  {
    qmemcpy(a1, &v2, 0x40u);
    result = 1;
  }
  return result;
}

//----- (10049600) --------------------------------------------------------
bool __cdecl sub_10049600(void *a1)
{
  bool v1; // bl@1
  char v2; // si@4
  char v3; // si@10
  __int16 v5; // [sp+8h] [bp-144h]@5
  char v6; // [sp+Ch] [bp-140h]@1
  int v7; // [sp+Eh] [bp-13Eh]@5
  char v8; // [sp+14h] [bp-138h]@15
  char v9; // [sp+18h] [bp-134h]@14
  int v10; // [sp+20h] [bp-12Ch]@2
  char v11; // [sp+4Ch] [bp-100h]@6
  __int16 v12; // [sp+4Eh] [bp-FEh]@6
  int v13; // [sp+54h] [bp-F8h]@12
  char v14; // [sp+58h] [bp-F4h]@14
  char v15; // [sp+60h] [bp-ECh]@15
  int v16; // [sp+64h] [bp-E8h]@8
  int v17; // [sp+128h] [bp-24h]@19

  v1 = 0;
  if ( sub_10049580(&v6) && v10 != 10485760 )
  {
    switch ( (unsigned __int8)a1 )
    {
      case 0xAu:
      case 0xBu:
        v2 = sub_100528A0((char)a1);
        if ( (unsigned __int8)sub_1003C170(v2) )
        {
          if ( sub_100529A0(v7, &v5) )
          {
            memset(&v11, 0, 0x3Cu);
            sub_10046600(v2, (int)&v11);
            v1 = v12 == v5;
            if ( (unsigned __int8)sub_1003C3B0(v2) )
            {
              if ( !v1 || v16 != v10 )
                goto LABEL_21;
              v1 = 1;
            }
          }
        }
        break;
      case 0x30u:
      case 0x31u:
        v3 = sub_100528A0((char)a1);
        if ( (unsigned __int8)sub_1003C170(v3) )
        {
          memset(&v11, 0, 0x80u);
          if ( !sub_10062960(v3, 65, (unsigned int)&v11)
            || v13 != v10
            || (_WORD)v16 != (_WORD)v7
            || strncmp(&v14, &v9, 7u)
            || strncmp(&v15, &v8, 2u) )
          {
            goto LABEL_21;
          }
          v1 = 1;
        }
        break;
      case 0x20u:
        if ( sub_1004ED50(a1) )
        {
          memset(&v11, 0, 0xFCu);
          if ( (unsigned __int8)sub_1004EE10((int)a1, (int)&v11) && v17 == v10 )
            v1 = 1;
          else
LABEL_21:
            v1 = 0;
        }
        break;
      default:
        sub_10042930("..\\lib\\acl\\iop\\iop_acft_data_intf.c", 194, 0, 0);
        break;
    }
  }
  return v1;
}

//----- (10049840) --------------------------------------------------------
char __cdecl sub_10049840(char a1)
{
  return byte_101011E1[2 * (unsigned __int8)sub_10043FF0(&a1, 1u, (int)&unk_101011E0, 2, 4, 3)];
}

//----- (10049870) --------------------------------------------------------
char __cdecl sub_10049870(char a1, void *a2)
{
  void *v3; // esi@6
  char v4; // al@6

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v3 = a2;
      v4 = sub_100253C0(1, 546, a2);
    }
    else
    {
      if ( a1 != 2 )
      {
        sub_10042930("..\\lib\\acl\\iop\\iop_com_intf.c", 187, 0, 0);
        return 0;
      }
      v3 = a2;
      v4 = sub_100461D0(a2);
    }
  }
  else
  {
    v3 = a2;
    v4 = sub_100253C0(1, 538, a2);
  }
  if ( !v4 || sub_1004D540((int)v3) )
    return 0;
  return 1;
}

//----- (100498F0) --------------------------------------------------------
bool __cdecl sub_100498F0(char a1)
{
  char v2; // [sp+2h] [bp-Eh]@1
  char v3; // [sp+3h] [bp-Dh]@1
  int v4; // [sp+4h] [bp-Ch]@1
  int v5; // [sp+8h] [bp-8h]@1

  v4 = 0;
  v5 = 0;
  v2 = 0;
  sub_1007C4B0(6889, (int)&v3, 1);
  if ( v3 && !a1 )
  {
    sub_1007C4B0(41067, (int)&v2, 1);
    return v2;
  }
  if ( sub_10049870(a1, &v4) != 1 )
    return v2;
  return (v4 & 0x2000) == 0x2000;
}

//----- (10049990) --------------------------------------------------------
int __cdecl sub_10049990(char a1, _DWORD *a2)
{
  int result; // eax@1
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  LOBYTE(result) = sub_10049870(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (100499E0) --------------------------------------------------------
char __cdecl sub_100499E0(unsigned __int8 a1, char a2, int a3)
{
  int v3; // eax@1
  void *v4; // ecx@2
  int v5; // edx@4
  int v6; // eax@6
  int v8; // [sp+4h] [bp-80h]@4
  int v9; // [sp+8h] [bp-7Ch]@4
  char v10; // [sp+Ch] [bp-78h]@4
  char v11; // [sp+1Ch] [bp-68h]@4
  char v12; // [sp+24h] [bp-60h]@4
  char v13; // [sp+30h] [bp-54h]@4
  char v14; // [sp+4Ch] [bp-38h]@4
  int v15; // [sp+78h] [bp-Ch]@4
  int v16; // [sp+7Ch] [bp-8h]@5

  LOBYTE(v3) = sub_1004B270(a1);
  if ( (_BYTE)v3 )
  {
    v3 = j_HWM_pvg_read_reg(1);
    if ( v3 )
    {
      LOBYTE(v3) = sub_100460C0(v4);
      if ( (_BYTE)v3 == 2 )
      {
        v5 = (unsigned __int16)word_101011A4[10 * a1];
        v8 = 0;
        LOWORD(v8) = 7;
        v9 = a3;
        sub_10024E60(1, v5, &v8, 0, 8, 1);
        memset(&v10, 0, 0x74u);
        sub_100421E0((int)&v14, "(c) 2002-13 Garmin Ltd or subs", 32);
        sub_100421E0((int)&v13, "COM DEMO CNFG v0.50", 28);
        sub_100421E0((int)&v10, "CFG-XXXXX-XX", 16);
        sub_100421E0((int)&v11, "0.50", 8);
        sub_100421E0((int)&v12, "COM", 12);
        v15 = a1;
        if ( a2 )
          v16 = 1;
        LOWORD(v6) = sub_10061F40(byte_101011B0[20 * a1]);
        LOBYTE(v3) = sub_10024E60(2, v6, &v10, 0, 116, 1);
      }
    }
  }
  return v3;
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 101011A4: using guessed type __int16 word_101011A4[];

//----- (10049B30) --------------------------------------------------------
char __cdecl sub_10049B30(char a1, char a2)
{
  char result; // al@3

  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_10024E60(1, 548, &a2, 0, 1, 1);
    else
      result = sub_10042930("..\\lib\\acl\\iop\\iop_com_intf.c", 594, 0, 0);
  }
  else
  {
    result = sub_10024E60(1, 540, &a2, 0, 1, 1);
  }
  return result;
}

//----- (10049B90) --------------------------------------------------------
char __cdecl sub_10049B90(char a1)
{
  char result; // al@1

  result = -80;
  switch ( a1 )
  {
    case 3:
      result = -126;
      break;
    case 4:
      result = -123;
      break;
    case 5:
      result = -108;
      break;
    case 6:
      result = -105;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10049BD0) --------------------------------------------------------
char __cdecl sub_10049BD0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 3;
      break;
    case 1:
      result = 4;
      break;
    case 2:
      result = 5;
      break;
    case 3:
      result = 40;
      break;
    case 4:
      result = 41;
      break;
    case 5:
      result = 51;
      break;
    case 6:
      result = 52;
      break;
    default:
      sub_10042930("..\\lib\\adl\\iop_cdu_unit_intf.c", 490, 0, 0);
      result = 67;
      break;
  }
  return result;
}

//----- (10049C40) --------------------------------------------------------
char __cdecl sub_10049C40(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 74;
      break;
    case 1:
      result = 73;
      break;
    case 2:
      result = 75;
      break;
    case 3:
      result = -127;
      break;
    case 4:
      result = -124;
      break;
    case 5:
      result = -109;
      break;
    case 6:
      result = -106;
      break;
    default:
      sub_10042930("..\\lib\\adl\\iop_cdu_unit_intf.c", 564, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (10049CB0) --------------------------------------------------------
signed int __cdecl sub_10049CB0(char a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = 4;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 64;
      break;
    case 4:
      result = 128;
      break;
    case 5:
      result = 16;
      break;
    case 6:
      result = 32;
      break;
    default:
      sub_10042930("..\\lib\\adl\\iop_cdu_unit_intf.c", 638, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10049D30) --------------------------------------------------------
char __cdecl sub_10049D30(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 13;
      break;
    case 1:
      result = 12;
      break;
    case 2:
      result = 14;
      break;
    case 3:
      result = -128;
      break;
    case 4:
      result = -125;
      break;
    case 5:
      result = -110;
      break;
    case 6:
      result = -107;
      break;
    default:
      sub_10042930("..\\lib\\adl\\iop_cdu_unit_intf.c", 712, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (10049DA0) --------------------------------------------------------
char __cdecl sub_10049DA0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 3:
      result = 0;
      break;
    case 4:
      result = 1;
      break;
    case 5:
      result = 2;
      break;
    case 0x28:
      result = 3;
      break;
    case 0x29:
      result = 4;
      break;
    case 0x33:
      result = 5;
      break;
    case 0x34:
      result = 6;
      break;
    default:
      sub_10042930("..\\lib\\adl\\iop_cdu_unit_intf.c", 786, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10049E50) --------------------------------------------------------
char __cdecl sub_10049E50(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 4:
      result = 0;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      if ( !(_BYTE)a1 )
        sub_10042930("..\\lib\\adl\\iop_cdu_unit_intf.c", 859, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10049F60) --------------------------------------------------------
char __cdecl sub_10049F60(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 4:
      result = 0;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      sub_10042930("..\\lib\\adl\\iop_cdu_unit_intf.c", 1096, 1, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (1004A060) --------------------------------------------------------
char __usercall sub_1004A060@<al>(int a1@<edi>, char a2, unsigned __int8 a3)
{
  int v3; // esi@1
  int v4; // eax@1
  char result; // al@2

  v3 = a3;
  v4 = sub_10043FF0(&a2, 1u, a1, 2, a3, a3);
  if ( v4 >= v3 )
    result = -80;
  else
    result = *(_BYTE *)(a1 + 2 * v4 + 1);
  return result;
}

//----- (1004A090) --------------------------------------------------------
char __cdecl sub_1004A090(char a1)
{
  return sub_1004A060((int)&unk_10101760, a1, 0xBu);
}

//----- (1004A0B0) --------------------------------------------------------
char __thiscall sub_1004A0B0(void *this)
{
  int v1; // eax@1

  v1 = sub_100429D0(this);
  return sub_10049F60(v1);
}

//----- (1004A0C0) --------------------------------------------------------
char __cdecl sub_1004A0C0(char a1)
{
  char result; // al@2
  unsigned __int8 v2; // [sp+4h] [bp-4h]@1

  v2 = sub_1004A090(a1);
  if ( v2 == -80 )
    result = 67;
  else
    result = sub_10061F20(v2);
  return result;
}

//----- (1004A0F0) --------------------------------------------------------
void sub_1004A0F0()
{
  dword_1027EAA0 = -15;
}
// 1027EAA0: using guessed type int dword_1027EAA0;

//----- (1004A100) --------------------------------------------------------
void sub_1004A100()
{
  dword_10333D60 = -15;
}
// 10333D60: using guessed type int dword_10333D60;

//----- (1004A110) --------------------------------------------------------
signed int sub_1004A110()
{
  return sub_1007CC90((int)&off_1010189C);
}
// 1010189C: using guessed type char *off_1010189C;

//----- (1004A120) --------------------------------------------------------
signed int sub_1004A120()
{
  signed int result; // eax@1

  result = -15;
  dword_10333D5C = -15;
  dword_10333D58 = -15;
  return result;
}
// 10333D58: using guessed type int dword_10333D58;
// 10333D5C: using guessed type int dword_10333D5C;

//----- (1004A130) --------------------------------------------------------
char __cdecl sub_1004A130(int a1)
{
  char result; // al@7

  if ( (_WORD)a1 != 552 && (_WORD)a1 != 557
    || !sub_100253C0(1, a1, &a1)
    || sub_1004C1E0((int)&a1)
    || !(BYTE2(a1) & 1)
    || !(BYTE2(a1) & 2)
    || (result = 1, (_BYTE)a1 == 4) )
  {
    result = 0;
  }
  return result;
}

//----- (1004A190) --------------------------------------------------------
int __thiscall sub_1004A190(void *this)
{
  char v1; // si@1
  void *v2; // ecx@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // ebx@1
  char v6; // al@1
  int result; // eax@1

  v1 = sub_100460A0(this) & 7;
  v3 = sub_100429D0(v2);
  v4 = ((v1 & 1) == 1) + ((v1 & 2) == 2) + ((v1 & 4) == 4);
  v5 = sub_100471C0(15) == 1;
  v6 = sub_100471C0(8);
  word_1027EAA4 = 552;
  result = v5 + (v6 == 1);
  if ( v4 != 2 )
  {
    if ( v4 != 3 )
      return result;
    if ( result == 2 )
    {
      if ( v3 == 2 )
      {
        word_1027EAA4 = 557;
        return result;
      }
    }
    else if ( result != 1 )
    {
      return result;
    }
    goto LABEL_10;
  }
  if ( result == 1 )
  {
LABEL_10:
    word_1027EAA4 = 552;
    return result;
  }
  if ( result == 2 )
    word_1027EAA4 = v3 != 4 ? 552 : 557;
  return result;
}
// 1027EAA4: using guessed type __int16 word_1027EAA4;

//----- (1004A260) --------------------------------------------------------
bool __usercall sub_1004A260@<al>(int a1@<eax>, int a2@<esi>)
{
  void *v3; // [sp+0h] [bp-4h]@0

  return sub_100253C0(1, a1, v3) && !sub_1004C1E0(a2);
}

//----- (1004A290) --------------------------------------------------------
bool __cdecl sub_1004A290(_BYTE *a1, int a2)
{
  bool result; // al@3

  if ( (_WORD)a2 != 552 && (_WORD)a2 != 557 )
  {
    result = 0;
  }
  else
  {
    result = sub_1004A260(a2, (int)&a2);
    if ( result )
      *a1 = a2;
  }
  return result;
}

//----- (1004A2C0) --------------------------------------------------------
bool __cdecl sub_1004A2C0(_BYTE *a1, int a2)
{
  bool result; // al@3

  if ( (_WORD)a2 != 552 && (_WORD)a2 != 557 )
  {
    result = 0;
  }
  else
  {
    result = sub_1004A260(a2, (int)&a2);
    if ( result )
      *a1 = BYTE2(a2);
  }
  return result;
}

//----- (1004A2F0) --------------------------------------------------------
char __cdecl sub_1004A2F0(_DWORD *a1)
{
  char result; // al@2
  int v2; // eax@3

  *a1 = -1;
  if ( byte_10333D54 )
  {
    result = 0;
  }
  else
  {
    v2 = (*(int (**)(void))(dword_103334D8 + 4))();
    result = (*(int (__cdecl **)(int, signed int, _DWORD *))dword_103334D8)(v2 - 4, 4, a1);
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333D54: using guessed type char byte_10333D54;

//----- (1004A330) --------------------------------------------------------
int __cdecl sub_1004A330(_BYTE *a1)
{
  int result; // eax@1

  result = (int)a1;
  *a1 = 0;
  if ( !byte_10333D54 )
    result = (*(int (__cdecl **)(signed int, signed int, _BYTE *))dword_103334D8)(146, 1, a1);
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333D54: using guessed type char byte_10333D54;

//----- (1004A360) --------------------------------------------------------
char __cdecl sub_1004A360(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  char v3; // [sp+8h] [bp-14h]@2
  unsigned __int8 v4; // [sp+9h] [bp-13h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_10333D54 )
  {
    (*(void (__cdecl **)(int, signed int, char *))dword_103334D8)(dword_10333824, 18, &v3);
    result = v4 & 0xF;
    *a2 = v4 >> 4;
    *a1 = result;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333824: using guessed type int dword_10333824;
// 10333D54: using guessed type char byte_10333D54;

//----- (1004A3B0) --------------------------------------------------------
char __cdecl sub_1004A3B0(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  unsigned __int8 v3; // [sp+8h] [bp-14h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_10333D54 )
  {
    (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_103334D8)(dword_10333824, 18, &v3);
    result = v3 & 0xF;
    *a2 = v3 >> 4;
    *a1 = result;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333824: using guessed type int dword_10333824;
// 10333D54: using guessed type char byte_10333D54;

//----- (1004A400) --------------------------------------------------------
int sub_1004A400()
{
  int result; // eax@1
  unsigned int v1; // ecx@1
  int v2; // edi@4
  int *v3; // esi@5
  int v4; // ebx@5
  int v5; // edx@6
  int v6; // [sp+4h] [bp-Ch]@1
  int v7; // [sp+8h] [bp-8h]@4
  unsigned int v8; // [sp+Ch] [bp-4h]@4

  memset(dword_10333500, 0, 0x708u);
  result = (*(int (__cdecl **)(signed int, int *))dword_103334C8)(512, &v6);
  v1 = 0;
  do
  {
    word_10333504[v1 / 2] = 0;
    dword_10333508[v1 / 4] = 0;
    dword_10333500[v1 / 4] = 0;
    v1 += 12;
  }
  while ( v1 < 0x708 );
  if ( (_BYTE)result )
  {
    dword_1033350C = v6;
    result = v8;
    v2 = (unsigned __int16)v7 + 512;
    dword_10333510 = v7;
    dword_10333514 = v8;
    if ( v8 >= 2 )
    {
      v3 = &dword_10333518;
      v4 = v8 - 1;
      do
      {
        (*(void (__cdecl **)(int, int *))dword_103334C8)(v2, &v6);
        v5 = v7;
        result = v8;
        *v3 = v6;
        v3[1] = v5;
        v3[2] = result;
        v2 += (unsigned __int16)dword_10333510;
        v3 += 3;
        --v4;
      }
      while ( v4 );
    }
  }
  return result;
}
// 103334C8: using guessed type int dword_103334C8;
// 10333500: using guessed type int dword_10333500[];
// 10333504: using guessed type __int16 word_10333504[];
// 10333508: using guessed type int dword_10333508[];
// 1033350C: using guessed type int dword_1033350C;
// 10333510: using guessed type int dword_10333510;
// 10333514: using guessed type int dword_10333514;
// 10333518: using guessed type int dword_10333518;

//----- (1004A4D0) --------------------------------------------------------
__int16 sub_1004A4D0()
{
  __int16 result; // ax@1
  unsigned int v1; // ebx@1
  unsigned int v2; // esi@1
  int v3; // edi@1
  int v4; // ebp@2
  __int16 v5; // [sp+Ch] [bp-4h]@3

  result = word_1033351C;
  v1 = dword_10333520;
  v2 = 1;
  v3 = dword_10333518;
  if ( (unsigned int)dword_10333520 >= 1 )
  {
    v4 = (unsigned __int16)word_1033351C;
    do
    {
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_103334D8)(v3, 2, &v5);
      result = v5;
      word_10333C20[v2++] = v5;
      v3 += v4;
    }
    while ( v2 <= v1 );
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;
// 10333518: using guessed type int dword_10333518;
// 1033351C: using guessed type __int16 word_1033351C;
// 10333520: using guessed type int dword_10333520;
// 10333C20: using guessed type __int16 word_10333C20[];

//----- (1004A530) --------------------------------------------------------
int __usercall sub_1004A530@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4)
{
  signed int v4; // edx@1
  _BYTE *v5; // ecx@2
  unsigned int v6; // ebx@2
  unsigned __int16 v7; // ax@7

  v4 = 0;
  if ( a3 > 0 )
  {
    v5 = a2;
    v6 = a3;
    do
    {
      if ( v4 & 3 )
      {
        if ( (v4 & 3) == 1 )
        {
          result = v6 >> 4;
        }
        else
        {
          --v5;
          result = (v4 & 3) - 2;
          if ( (v4 & 3) == 2 )
          {
            HIBYTE(v7) = v5[1];
            LOBYTE(v7) = *v5;
            v6 = v7;
            result = (unsigned int)v7 >> 6;
          }
          else
          {
            LOBYTE(result) = v6;
          }
        }
      }
      else
      {
        HIWORD(result) = 0;
        BYTE1(result) = *v5--;
        LOBYTE(result) = *v5;
        v6 = (unsigned __int16)result;
        LOWORD(result) = (unsigned __int16)result >> 10;
      }
      LOBYTE(result) = (result & 0x3F) + 32;
      *(_BYTE *)(v4++ + a4) = result;
    }
    while ( v4 < a3 );
  }
  return result;
}

//----- (1004A5B0) --------------------------------------------------------
signed int __cdecl sub_1004A5B0(int a1)
{
  signed int result; // eax@1
  char v2; // [sp+8h] [bp-10h]@3
  char v3; // [sp+13h] [bp-5h]@3

  result = 538976288;
  *(_DWORD *)a1 = 538976288;
  *(_DWORD *)(a1 + 4) = 538976288;
  *(_DWORD *)(a1 + 8) = 538976288;
  *(_DWORD *)(a1 + 12) = 538976288;
  if ( byte_10333D54 )
  {
    LOBYTE(dword_1027EAA8) = 0;
    *(_BYTE *)(a1 + 16) = 0;
  }
  else if ( (_BYTE)dword_1027EAA8 )
  {
    *(_DWORD *)a1 = dword_1027EAA8;
    *(_DWORD *)(a1 + 4) = dword_1027EAAC;
    *(_DWORD *)(a1 + 8) = dword_1027EAB0;
    result = dword_1027EAB4;
    *(_DWORD *)(a1 + 12) = dword_1027EAB4;
    *(_BYTE *)(a1 + 16) = 0;
  }
  else
  {
    (*(void (__cdecl **)(signed int, signed int, char *))dword_103334D8)(147, 12, &v2);
    sub_1004A530((int)&v3, &v3, 16, a1);
    dword_1027EAA8 = *(_DWORD *)a1;
    dword_1027EAAC = *(_DWORD *)(a1 + 4);
    result = *(_DWORD *)(a1 + 8);
    dword_1027EAB0 = *(_DWORD *)(a1 + 8);
    dword_1027EAB4 = *(_DWORD *)(a1 + 12);
    byte_1027EAB8 = *(_BYTE *)(a1 + 16);
    *(_BYTE *)(a1 + 16) = 0;
  }
  return result;
}
// 1027EAA8: using guessed type int dword_1027EAA8;
// 1027EAAC: using guessed type int dword_1027EAAC;
// 1027EAB0: using guessed type int dword_1027EAB0;
// 1027EAB4: using guessed type int dword_1027EAB4;
// 1027EAB8: using guessed type char byte_1027EAB8;
// 103334D8: using guessed type int dword_103334D8;
// 10333D54: using guessed type char byte_10333D54;

//----- (1004A6A0) --------------------------------------------------------
char sub_1004A6A0()
{
  char v0; // al@1
  unsigned __int8 v1; // bl@2
  unsigned int v2; // ecx@3
  char *v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // ecx@8
  _BYTE *v7; // eax@8
  _BYTE *v8; // edx@8
  int v9; // ecx@10
  _BYTE *v10; // eax@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // eax@12
  _BYTE *v13; // edx@12
  signed int v14; // eax@14
  char result; // al@24
  char v16; // [sp+Fh] [bp-25h]@20
  char v17; // [sp+10h] [bp-24h]@1
  char v18; // [sp+1Bh] [bp-19h]@2
  char v19; // [sp+1Ch] [bp-18h]@2

  byte_10333D54 = 1;
  v0 = (*(int (__cdecl **)(signed int, signed int, char *))dword_103334D8)(147, 12, &v17);
  byte_10333D54 = 1;
  dword_1027EAA8 = 0;
  dword_1027EAAC = 0;
  dword_1027EAB0 = 0;
  dword_1027EAB4 = 0;
  byte_1027EAB8 = 0;
  if ( !v0 )
    return (unsigned int)memset(dword_10333500, 0, 0x708u);
  sub_1004A530((int)&v19, &v18, 16, (int)&v19);
  v1 = 0;
  while ( 1 )
  {
    v2 = 10;
    v3 = &a006D0170[11 * v1];
    v4 = &v19;
    do
    {
      if ( *(_DWORD *)v4 != *(_DWORD *)v3 )
        goto LABEL_7;
      v2 -= 4;
      v3 += 4;
      v4 += 4;
    }
    while ( v2 >= 4 );
    if ( !v2 )
    {
LABEL_16:
      v14 = 0;
      goto LABEL_17;
    }
LABEL_7:
    v5 = (unsigned __int8)*v4 - (unsigned __int8)*v3;
    if ( (unsigned __int8)*v4 == (unsigned __int8)*v3 )
    {
      v6 = v2 - 1;
      v7 = v3 + 1;
      v8 = v4 + 1;
      if ( !v6 )
        goto LABEL_16;
      v5 = *v8 - *v7;
      if ( *v8 == *v7 )
      {
        v9 = v6 - 1;
        v10 = v7 + 1;
        v11 = v8 + 1;
        if ( !v9 )
          goto LABEL_16;
        v5 = *v11 - *v10;
        if ( *v11 == *v10 )
        {
          v12 = v10 + 1;
          v13 = v11 + 1;
          if ( v9 == 1 )
            goto LABEL_16;
          v5 = *v13 - *v12;
          if ( *v13 == *v12 )
            goto LABEL_16;
        }
      }
    }
    v14 = 1;
    if ( v5 <= 0 )
      v14 = -1;
LABEL_17:
    if ( !v14 )
      break;
    if ( ++v1 >= 3u )
      return (unsigned int)memset(dword_10333500, 0, 0x708u);
  }
  byte_10333D54 = 0;
  sub_1004A330(&v16);
  if ( v16 != 101 )
  {
    byte_10333D54 = 2;
    return (unsigned int)memset(dword_10333500, 0, 0x708u);
  }
  if ( byte_10333D54 )
    return (unsigned int)memset(dword_10333500, 0, 0x708u);
  sub_1004A3B0(&unk_10333C08, &byte_10333D4D);
  byte_10333D4C = byte_10333D4D - 1;
  if ( byte_10333D54 )
    return (unsigned int)memset(dword_10333500, 0, 0x708u);
  result = sub_1004A360(&unk_10333C09, &unk_10333C0A);
  byte_103334F8 = 0;
  if ( byte_10333D54 )
    return (unsigned int)memset(dword_10333500, 0, 0x708u);
  return result;
}
// 1027EAA8: using guessed type int dword_1027EAA8;
// 1027EAAC: using guessed type int dword_1027EAAC;
// 1027EAB0: using guessed type int dword_1027EAB0;
// 1027EAB4: using guessed type int dword_1027EAB4;
// 1027EAB8: using guessed type char byte_1027EAB8;
// 103334D8: using guessed type int dword_103334D8;
// 103334F8: using guessed type char byte_103334F8;
// 10333500: using guessed type int dword_10333500[];
// 10333D4C: using guessed type char byte_10333D4C;
// 10333D4D: using guessed type char byte_10333D4D;
// 10333D54: using guessed type char byte_10333D54;

//----- (1004A860) --------------------------------------------------------
int (__cdecl *(*sub_1004A860())[2])(int, int)
{
  int (__cdecl *(*result)[2])(int, int); // eax@1
  unsigned int v1; // edi@2
  char *v2; // ecx@3
  unsigned int v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // eax@8
  _BYTE *v7; // ecx@8
  _BYTE *v8; // edx@8
  int v9; // eax@10
  _BYTE *v10; // ecx@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // ecx@12
  _BYTE *v13; // edx@12
  char v14; // [sp+0h] [bp-24h]@1
  char v15; // [sp+Bh] [bp-19h]@2
  char v16; // [sp+Ch] [bp-18h]@2

  dword_103334C8 = (int)off_101446C8;
  result = (int (__cdecl *(*)[2])(int, int))(*(int (__cdecl **)(signed int, signed int, char *))dword_103334D8)(
                                              147,
                                              12,
                                              &v14);
  if ( (_BYTE)result )
  {
    sub_1004A530((int)&v16, &v15, 16, (int)&v16);
    v1 = 0;
    do
    {
      v2 = (&off_10102FD0)[8 * v1];
      v3 = strlen((&off_10102FD0)[8 * v1]);
      v4 = &v16;
      if ( v3 < 4 )
      {
LABEL_6:
        if ( !v3 )
          goto LABEL_16;
      }
      else
      {
        while ( *(_DWORD *)v4 == *(_DWORD *)v2 )
        {
          v3 -= 4;
          v2 += 4;
          v4 += 4;
          if ( v3 < 4 )
            goto LABEL_6;
        }
      }
      v5 = (unsigned __int8)*v4 - (unsigned __int8)*v2;
      if ( (unsigned __int8)*v4 == (unsigned __int8)*v2 )
      {
        v6 = v3 - 1;
        v7 = v2 + 1;
        v8 = v4 + 1;
        if ( !v6
          || (v5 = *v8 - *v7, *v8 == *v7)
          && ((v9 = v6 - 1, v10 = v7 + 1, v11 = v8 + 1, !v9)
           || (v5 = *v11 - *v10, *v11 == *v10)
           && ((v12 = v10 + 1, v13 = v11 + 1, v9 == 1) || (v5 = *v13 - *v12, *v13 == *v12))) )
        {
LABEL_16:
          result = 0;
          goto LABEL_17;
        }
      }
      result = (int (__cdecl *(*)[2])(int, int))1;
      if ( v5 <= 0 )
        result = (int (__cdecl *(*)[2])(int, int))-1;
LABEL_17:
      if ( !result )
      {
        result = (&off_10102FD4)[v1];
        dword_103334C8 = (int)(&off_10102FD4)[v1];
        return result;
      }
      ++v1;
    }
    while ( v1 < 3 );
  }
  return result;
}
// 10102FD0: using guessed type char *off_10102FD0;
// 10102FD4: using guessed type int (__cdecl *(*off_10102FD4)[2])(int, int);
// 101446C8: using guessed type int (__cdecl *off_101446C8[2])(int, int);
// 103334C8: using guessed type int dword_103334C8;
// 103334D8: using guessed type int dword_103334D8;

//----- (1004A990) --------------------------------------------------------
int __cdecl sub_1004A990(int *a1)
{
  int result; // eax@1

  result = sub_1005A430((int)(a1 + 1), 0);
  if ( result )
  {
    *a1 = sub_1007C040();
    result = sub_10066580();
  }
  return result;
}

//----- (1004A9C0) --------------------------------------------------------
char __usercall sub_1004A9C0@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@2
  char *v3; // eax@2
  char result; // al@2
  int v5; // eax@4
  char *v6; // eax@4

  if ( a2 == 13 )
  {
    v2 = sub_1007C110(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 88));
    v3 = sub_10054B60("%i %i\r\n", 13, v2);
    sub_10059BE0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)&unk_101033B0, (int)v3);
    result = 1;
  }
  else if ( a2 == 14 )
  {
    v5 = sub_1007C0F0(*(_DWORD *)(a1 + 4));
    v6 = sub_10054B60("%i %i\r\n", 14, v5);
    sub_10059BE0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)&unk_101033AC, (int)v6);
    result = 1;
  }
  else
  {
    sub_10042930(".\\test\\tst_tsk_common.c", 405, 1, 0);
    result = 0;
  }
  return result;
}

//----- (1004AA60) --------------------------------------------------------
int __cdecl sub_1004AA60(const char *a1)
{
  int result; // eax@1

  result = sub_100648A0();
  if ( a1 )
    result = sub_1005A460(dword_1027EABC[result] + 4, (int)a1, strlen(a1));
  return result;
}
// 1027EABC: using guessed type int dword_1027EABC[];

//----- (1004AAA0) --------------------------------------------------------
char __cdecl sub_1004AAA0(void *a1)
{
  int (**v1)(); // eax@1
  char **v2; // eax@1

  memset(a1, 0, 0xE0u);
  sub_1005A3B0((char *)a1 + 4);
  v1 = sub_1002A460();
  sub_10066660((int)v1, 0, 0);
  dword_1027EABC[sub_100648A0()] = (int)a1;
  v2 = sub_10067520((int)sub_1004AA60);
  return sub_100595D0(v2);
}
// 1027EABC: using guessed type int dword_1027EABC[];

//----- (1004AAF0) --------------------------------------------------------
signed int __cdecl sub_1004AAF0(unsigned int a1, int a2)
{
  signed int v2; // edi@1
  int v3; // eax@1
  unsigned int v4; // ebx@1
  int v5; // ebp@1
  signed int result; // eax@3
  char *v7; // eax@10
  __int16 v8; // ax@11
  char *v9; // eax@13
  char *v10; // eax@14
  char *v11; // eax@16
  int v12; // ebx@17
  char *v13; // eax@18
  char *v14; // eax@19
  char **v15; // eax@23
  char **v16; // eax@23
  char **v17; // eax@23
  char **v18; // eax@24
  char **v19; // eax@24
  char **v20; // eax@24
  int v21; // [sp-4h] [bp-30h]@9
  int v22; // [sp-4h] [bp-30h]@17
  char v23; // [sp+10h] [bp-1Ch]@6
  char v24; // [sp+14h] [bp-18h]@14

  v2 = 4;
  v3 = sub_1007C040();
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3;
  if ( a1 < 8 )
  {
LABEL_28:
    result = v2;
  }
  else
  {
    switch ( a1 )
    {
      case 0xBu:
        sub_1007C1F0(*(_DWORD *)(a2 + 4));
        result = 0;
        break;
      case 0xCu:
        if ( sub_1007C040() - v3 < v4 )
        {
          do
          {
            if ( *(_BYTE *)(a2 + 88) )
              sub_1007C280(&v23);
          }
          while ( sub_1007C040() - v5 < v4 );
        }
        result = 0;
        break;
      case 8u:
        v21 = *(_DWORD *)(a2 + 4);
        if ( v4 < 0x40 )
        {
          v8 = sub_1007C020(v21);
          if ( v8 & 0xF32 || v8 & 0xC4 )
          {
            sub_1007C060((int)&v24, 1, *(_DWORD *)(a2 + 4), 20);
            v10 = sub_10054B60("The %s task is loaded.", &v24);
            sub_10059BE0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"512", (int)v10);
            result = 0;
          }
          else
          {
            v9 = sub_10054B60("Task #%d is not loaded.", *(_DWORD *)(a2 + 4));
            sub_10059BE0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"520", (int)v9);
            result = 12;
          }
        }
        else
        {
          v7 = sub_10054B60("Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.", v21);
          sub_10059BE0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"489", (int)v7);
          result = 9;
        }
        break;
      case 9u:
        if ( v4 >= 0x40 )
        {
          v11 = sub_10054B60(
                  "Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.",
                  *(_DWORD *)(a2 + 4));
          sub_10059BE0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"543", (int)v11);
        }
        v12 = sub_1007BFB0(*(_DWORD *)(a2 + 4));
        v22 = *(_DWORD *)(a2 + 88);
        if ( v12 == *(_DWORD *)(a2 + 88) )
        {
          v13 = sub_10054B60("The %d task's level is equal to %d.", *(_DWORD *)(a2 + 4), v22);
          sub_10059BE0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"557", (int)v13);
          v2 = 0;
        }
        else
        {
          v14 = sub_10054B60("The %d task's level is equal to %d, not %d.", *(_DWORD *)(a2 + 4), v12, v22);
          sub_10059BE0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"562", (int)v14);
          v2 = 12;
        }
        if ( v12 )
          goto LABEL_28;
        sub_10059BE0(
          3,
          (int)"**MSG**",
          (int)".\\test\\tst_tsk_common.c",
          (int)"572",
          (int)"The task's criticality level is zero, make sure the task is running.");
        result = v2;
        break;
      case 0xAu:
        sub_1007C0A0(v4, *(_DWORD *)(a2 + 88), 0, 0);
        result = 4;
        break;
      case 0x12u:
        v15 = sub_10067520((int)sub_1004AA60);
        sub_10059CB0((int)v15);
        v16 = sub_100688F0((int)sub_1004AA60);
        sub_10059CB0((int)v16);
        v17 = sub_100688F0((int)sub_1004AA60);
        sub_100595D0(v17);
        result = 4;
        break;
      case 0x13u:
        v18 = sub_10067520((int)sub_1004AA60);
        sub_10059CB0((int)v18);
        v19 = sub_100688F0((int)sub_1004AA60);
        sub_10059CB0((int)v19);
        v20 = sub_10067520((int)sub_1004AA60);
        sub_100595D0(v20);
        result = 4;
        break;
      default:
        if ( a1 - 13 > 4 )
        {
          v2 = 11;
          goto LABEL_28;
        }
        result = sub_1004A9C0(a2, a1) != 0 ? 0 : 12;
        break;
    }
  }
  return result;
}

//----- (1004AE90) --------------------------------------------------------
char **sub_1004AE90()
{
  return off_10103398;
}
// 10103398: using guessed type char *off_10103398[3];

//----- (1004AEA0) --------------------------------------------------------
#error "1004AEA5: call analysis failed (funcsize=28)"

//----- (1004AED0) --------------------------------------------------------
char sub_1004AED0()
{
  int v1; // [sp+0h] [bp-4h]@1

  v1 = 0;
  LOWORD(v1) = -32761;
  return sub_100477A0((int)&v1);
}

//----- (1004AEF0) --------------------------------------------------------
int __cdecl sub_1004AEF0(signed int a1, char a2)
{
  int result; // eax@3
  int v3; // [sp+0h] [bp-4h]@1

  v3 = 0;
  switch ( (unsigned __int8)a1 )
  {
    case 0u:
      if ( a2 == 1 )
      {
        a1 = 136975;
        sub_1007C470(10018, &v3, 4, &a1);
        result = v3;
      }
      else
      {
        a1 = 118000;
        sub_1007C470(10022, &v3, 4, &a1);
        result = v3;
      }
      break;
    case 1u:
      if ( a2 == 1 )
      {
        a1 = 136975;
        sub_1007C470(10019, &v3, 4, &a1);
        result = v3;
      }
      else
      {
        a1 = 118000;
        sub_1007C470(10023, &v3, 4, &a1);
        result = v3;
      }
      break;
    case 3u:
      if ( a2 == 1 )
      {
        a1 = 117950;
        sub_1007C470(10020, &v3, 4, &a1);
        result = v3;
      }
      else
      {
        a1 = 108000;
        sub_1007C470(10024, &v3, 4, &a1);
        result = v3;
      }
      break;
    case 4u:
      if ( a2 == 1 )
      {
        a1 = 117950;
        sub_1007C470(10021, &v3, 4, &a1);
        result = v3;
      }
      else
      {
        a1 = 108000;
        sub_1007C470(10025, &v3, 4, &a1);
        result = v3;
      }
      break;
    case 2u:
      result = sub_10046210(a2);
      v3 = result;
      break;
    default:
      sub_10042930("..\\lib\\adl\\iop_freq_intf.c", 180, 1, 0);
      result = v3;
      break;
  }
  return result;
}

//----- (1004B0B0) --------------------------------------------------------
char __cdecl sub_1004B0B0(char a1, char a2, int a3)
{
  char result; // al@1
  int v4; // ecx@17
  signed int v5; // eax@17
  int v6; // [sp-Ch] [bp-Ch]@16
  int *v7; // [sp-8h] [bp-8h]@16

  result = a1;
  switch ( a1 )
  {
    case 0:
      result = sub_10049990(a1, &a1);
      if ( result && (unsigned int)(a3 - 118000) <= 0x4A2E )
      {
        if ( a2 == 1 )
          result = sub_1007C500(10018, (int)&a3, 4);
        else
          result = sub_1007C500(10022, (int)&a3, 4);
      }
      break;
    case 1:
      result = sub_10049990(a1, &a1);
      if ( result )
      {
        result = a3 + 16;
        if ( (unsigned int)(a3 - 118000) <= 0x4A2E )
        {
          if ( a2 == 1 )
            result = sub_1007C500(10019, (int)&a3, 4);
          else
            result = sub_1007C500(10023, (int)&a3, 4);
        }
      }
      break;
    case 3:
      result = sub_10048600(a1, &a1);
      if ( result && (unsigned int)(a3 - 108000) <= 0x26DE )
      {
        if ( a2 == 1 )
        {
          v7 = &a3;
          v6 = 10020;
          goto LABEL_17;
        }
        result = sub_1007C500(10024, (int)&a3, 4);
      }
      break;
    case 4:
      result = sub_10048600(a1, &a1);
      if ( result )
      {
        result = a3 + 32;
        if ( (unsigned int)(a3 - 108000) <= 0x26DE )
        {
          if ( a2 == 1 )
          {
            v7 = &a3;
            v6 = 10021;
LABEL_17:
            sub_1007C500(v6, (int)v7, 4);
            LOBYTE(v5) = sub_1003F480(v4);
            result = sub_1003F0C0(v5, 1);
          }
          else
          {
            result = sub_1007C500(10025, (int)&a3, 4);
          }
        }
      }
      break;
    case 2:
      result = sub_10049990(a1, &a1);
      if ( result )
        result = sub_100462F0(a2, a3);
      break;
    default:
      return result;
  }
  return result;
}

//----- (1004B270) --------------------------------------------------------
BOOL __cdecl sub_1004B270(unsigned __int8 a1)
{
  return a1 <= 1u;
}

//----- (1004B280) --------------------------------------------------------
BOOL __usercall sub_1004B280@<eax>(unsigned __int8 a1@<al>, char a2)
{
  _BYTE *v2; // ecx@1

  return (unsigned __int8)sub_1004B270(a1) && *v2 < 3u && a2 == 24;
}

//----- (1004B2B0) --------------------------------------------------------
bool __cdecl sub_1004B2B0(char a1, char a2, unsigned __int8 a3, int a4)
{
  bool v4; // bl@1
  unsigned __int8 v5; // cl@2
  int v6; // esi@3
  char v8; // al@16
  char v9; // cl@16
  char v10; // dl@16
  int v11; // ecx@18
  int v12; // edx@18
  int v13; // eax@18
  char v14; // [sp+Bh] [bp-29h]@3
  int v15; // [sp+Ch] [bp-28h]@9
  struct tm Tm; // [sp+10h] [bp-24h]@5

  v4 = 0;
  if ( a3 < 3u )
  {
    if ( (unsigned __int8)sub_1004B270(a1) )
    {
      v6 = 10 * v5;
      if ( sub_1003D360((unsigned __int8)byte_101049C0[20 * v5], (bool *)&v14) )
      {
        if ( v14 )
        {
          if ( !sub_100253C0(1, (unsigned __int16)word_101049B8[v6], &Tm.tm_mon) || sub_1004D460((int)&Tm.tm_mon) )
            return 0;
          v4 = 1;
        }
        else
        {
          if ( !(unsigned __int8)sub_10049990(a1, &v15) || v15 != dword_101049D8[2 * a3] || a2 == 11 )
            return v4;
          Tm.tm_sec = 0;
          Tm.tm_min = 0;
          Tm.tm_hour = 0;
          LOBYTE(Tm.tm_mday) = 0;
          v4 = sub_100253C0(1, (unsigned __int16)word_101049BC[v6], &Tm) && !_mkgmtime(&Tm);
          v8 = BYTE1(Tm.tm_hour);
          v9 = BYTE2(Tm.tm_min);
          *((_BYTE *)&Tm.tm_mon + 4 * a3) = Tm.tm_min;
          v10 = BYTE2(Tm.tm_hour);
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 2) = v8;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 1) = v9;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 3) = v10;
          if ( !v4 )
            return v4;
        }
        if ( a2 == 11 )
        {
          v11 = Tm.tm_year;
          v12 = Tm.tm_wday;
          *(_DWORD *)a4 = Tm.tm_mon;
          v13 = Tm.tm_yday;
          *(_DWORD *)(a4 + 4) = v11;
          *(_DWORD *)(a4 + 8) = v12;
          *(_DWORD *)(a4 + 12) = v13;
          return v4;
        }
        *(_DWORD *)a4 = *(&Tm.tm_mon + a3);
      }
    }
  }
  return v4;
}
// 101049B8: using guessed type __int16 word_101049B8[];
// 101049BC: using guessed type __int16 word_101049BC[];
// 101049D8: using guessed type int dword_101049D8[];

//----- (1004B460) --------------------------------------------------------
bool __cdecl sub_1004B460(unsigned __int8 a1, int a2)
{
  bool v2; // dl@1
  unsigned __int8 v3; // cl@1
  bool result; // al@2

  if ( (unsigned __int8)sub_1004B270(a1) )
    result = sub_1007C3B0((unsigned __int16)word_101049C2[10 * v3], a2, 32) == 0;
  else
    result = v2;
  return result;
}
// 101049C2: using guessed type __int16 word_101049C2[];

//----- (1004B4A0) --------------------------------------------------------
char __cdecl sub_1004B4A0(unsigned __int8 a1, char a2)
{
  char result; // al@1
  unsigned __int8 v3; // cl@1
  int v4; // esi@2

  result = sub_1004B270(a1);
  if ( result )
  {
    v4 = 5 * v3;
    sub_10024E60(1, (unsigned __int16)word_101049B2[10 * v3], &a2, 0, 1, 1);
    result = sub_10025010(1, (unsigned __int16)word_101049B2[2 * v4], 0xFFFFFFF);
  }
  return result;
}
// 101049B2: using guessed type __int16 word_101049B2[];

//----- (1004B4F0) --------------------------------------------------------
bool __cdecl sub_1004B4F0(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6)
{
  unsigned __int8 v6; // dl@1
  bool result; // al@4
  char v8; // [sp+13h] [bp-29h]@5
  unsigned int v9; // [sp+14h] [bp-28h]@1
  char v10; // [sp+18h] [bp-24h]@7
  int v11[7]; // [sp+1Ch] [bp-20h]@8

  LOBYTE(v9) = sub_10049840(a1);
  if ( !(unsigned __int8)sub_1004B280(v9, a3) || a6 != 4 )
    goto LABEL_12;
  if ( !a2 )
    return sub_1004B2B0(v9, a3, *a4, (int)a5);
  if ( sub_1003D360((unsigned __int8)byte_101049C0[20 * v6], (bool *)&v8) && v8 && sub_1004B460(v9, (int)&v10) )
  {
    *a5 = v11[*a4];
    result = 1;
  }
  else
  {
LABEL_12:
    result = 0;
  }
  return result;
}
// 1004B4F0: using guessed type int var_20[7];

//----- (1004B5E0) --------------------------------------------------------
int __cdecl sub_1004B5E0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10054720(a1, 0, 0xDu, 0xDu, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004B610) --------------------------------------------------------
int __cdecl sub_1004B610(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10054720(a1, 0, 9u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004B640) --------------------------------------------------------
int __cdecl sub_1004B640(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10054720(a1, 0, 5u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004B670) --------------------------------------------------------
int __cdecl sub_1004B670(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10054720(a1, 0, 8u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004B6A0) --------------------------------------------------------
int __cdecl sub_1004B6A0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10054720(a1, 0, 0x14u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004B6D0) --------------------------------------------------------
signed int __cdecl sub_1004B6D0(unsigned __int8 *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10054720(a1, 0, 0xFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (1004B700) --------------------------------------------------------
int __cdecl sub_1004B700(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10054720(a1, 0, 0xBu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004B730) --------------------------------------------------------
int __cdecl sub_1004B730(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10054720(a1, 0, 6u, 6u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004B760) --------------------------------------------------------
int __cdecl sub_1004B760(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10054720(a1, 0, 7u, 7u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004B790) --------------------------------------------------------
int __cdecl sub_1004B790(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10054720(a1, 0, 0xFu, 0xFu, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004B7C0) --------------------------------------------------------
int __cdecl sub_1004B7C0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10054720(a1, 0, 8u, 8u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004B7F0) --------------------------------------------------------
int __cdecl sub_1004B7F0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10054720(a1, 0, 0xEu, 0xEu, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004B820) --------------------------------------------------------
int __cdecl sub_1004B820(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 3u, 3u, 0);
}

//----- (1004B840) --------------------------------------------------------
int __cdecl sub_1004B840(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10054720(a1, 0, 0x13u, 0x13u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004B870) --------------------------------------------------------
int __cdecl sub_1004B870(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10054720(a1, 0, 2u, 2u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004B8A0) --------------------------------------------------------
int __cdecl sub_1004B8A0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10054720(a1, 0, 3u, 3u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004B8D0) --------------------------------------------------------
unsigned int __cdecl sub_1004B8D0(char *a1)
{
  return sub_10054510(a1, -1, 1, 1, 0);
}

//----- (1004B8F0) --------------------------------------------------------
unsigned int __cdecl sub_1004B8F0(_BYTE *a1)
{
  return sub_10054560(a1, -200, 200, 0, 0);
}

//----- (1004B910) --------------------------------------------------------
unsigned int __cdecl sub_1004B910(char *a1)
{
  return sub_10054510(a1, -100, 100, 0, 0);
}

//----- (1004B930) --------------------------------------------------------
unsigned int __cdecl sub_1004B930(char *a1, int a2)
{
  unsigned int result; // eax@1

  result = sub_10054510(a1, -100, 100, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004B960) --------------------------------------------------------
int __cdecl sub_1004B960(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10054720(a1, 0, 2u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004B990) --------------------------------------------------------
int __cdecl sub_1004B990(_BYTE *a1)
{
  return sub_10054810(a1, 0x1CCF0u, 0x2171Eu, 0x2171Eu, 0);
}

//----- (1004B9B0) --------------------------------------------------------
int __cdecl sub_1004B9B0(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 1u, 1u, 0);
}

//----- (1004B9D0) --------------------------------------------------------
int __cdecl sub_1004B9D0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10054720(a1, 0, 1u, 1u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004BA00) --------------------------------------------------------
int __cdecl sub_1004BA00(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10054720(a1, 0, 3u, 2u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004BA30) --------------------------------------------------------
unsigned int __cdecl sub_1004BA30(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_100543D0((_BYTE *)(a1 + 6), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_10054720((unsigned __int8 *)(a1 + 12), 0, 0xFFu, 0, a2) == 1 )
    v2 = 1;
  result = sub_100543D0((_BYTE *)a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 2), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 9), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 3), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10054510((char *)(a1 + 14), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10054720((unsigned __int8 *)(a1 + 7), 0, 0x40u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 10), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 5), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 11), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10054720((unsigned __int8 *)(a1 + 4), 0, 0x40u, 0x30u, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 1), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10054510((char *)(a1 + 17), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 24), 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (1004BD60) --------------------------------------------------------
unsigned int __cdecl sub_1004BD60(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_100543D0((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 24), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 26), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10054510((char *)(a1 + 10), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 31), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 28), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 17), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10054510((char *)(a1 + 13), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10054510((char *)(a1 + 5), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10054510((char *)a1, -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10054510((char *)(a1 + 1), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10054510((char *)(a1 + 2), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10054510((char *)(a1 + 3), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10054510((char *)(a1 + 4), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10054510((char *)(a1 + 12), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10054510((char *)(a1 + 11), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10054510((char *)(a1 + 7), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10054510((char *)(a1 + 9), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 25), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10054510((char *)(a1 + 6), -31, 31, 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (1004C1A0) --------------------------------------------------------
int __cdecl sub_1004C1A0(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 7u, 7u, 0);
}

//----- (1004C1C0) --------------------------------------------------------
int __cdecl sub_1004C1C0(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 0x7Fu, 0x7Fu, 0);
}

//----- (1004C1E0) --------------------------------------------------------
int __cdecl sub_1004C1E0(int a1)
{
  int result; // eax@1

  result = sub_1004C1A0((unsigned __int8 *)a1);
  if ( !result )
  {
    result = sub_1004C1A0((unsigned __int8 *)(a1 + 1));
    if ( !result )
      result = sub_1004C1C0((unsigned __int8 *)(a1 + 2));
  }
  return result;
}

//----- (1004C210) --------------------------------------------------------
unsigned int __cdecl sub_1004C210(_BYTE *a1)
{
  return sub_10054600(a1, -1, 5, -1, 0);
}

//----- (1004C230) --------------------------------------------------------
int __cdecl sub_1004C230(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 4u, 2u, 0);
}

//----- (1004C250) --------------------------------------------------------
int __cdecl sub_1004C250(_BYTE *a1)
{
  return sub_10054810(a1, 0, 2u, 0, 0);
}

//----- (1004C270) --------------------------------------------------------
int __cdecl sub_1004C270(int a1)
{
  return sub_10054420(a1, 0.1, 4.0, COERCE_INT(1.5), 0);
}

//----- (1004C2C0) --------------------------------------------------------
int __cdecl sub_1004C2C0(unsigned __int8 *a1)
{
  int result; // eax@1

  result = sub_1004C270((int)(a1 + 4));
  if ( !result )
    result = sub_1004C230(a1);
  return result;
}

//----- (1004C2E0) --------------------------------------------------------
int __cdecl sub_1004C2E0(int a1)
{
  int result; // eax@1

  result = sub_1004D0B0((unsigned __int8 *)(a1 + 1));
  if ( !result )
  {
    result = sub_1004D0B0((unsigned __int8 *)(a1 + 2));
    if ( !result )
    {
      result = sub_1004D0B0((unsigned __int8 *)(a1 + 3));
      if ( !result )
      {
        result = sub_10062C60((unsigned __int8 *)(a1 + 7));
        if ( !result )
        {
          result = sub_100543D0((_BYTE *)(a1 + 5), 0, 0);
          if ( !result )
          {
            result = sub_100543D0((_BYTE *)a1, 0, 0);
            if ( !result )
            {
              result = sub_100543D0((_BYTE *)(a1 + 4), 0, 0);
              if ( !result )
                result = sub_100543D0((_BYTE *)(a1 + 6), 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (1004C370) --------------------------------------------------------
unsigned int __cdecl sub_1004C370(int a1)
{
  unsigned int result; // eax@1

  result = sub_1004C210((_BYTE *)a1);
  if ( !result )
    result = sub_1004C210((_BYTE *)(a1 + 4));
  return result;
}

//----- (1004C390) --------------------------------------------------------
signed int __cdecl sub_1004C390(int a1)
{
  int v1; // esi@1
  signed int result; // eax@2
  signed int v3; // esi@4

  v1 = 0;
  while ( 1 )
  {
    result = sub_100543D0((_BYTE *)(v1 + a1), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      v3 = 0;
      do
      {
        result = sub_100543D0((_BYTE *)(a1 + v3 + 6), 0, 0);
        if ( result )
          break;
        ++v3;
      }
      while ( v3 < 6 );
      return result;
    }
  }
  return result;
}

//----- (1004C3E0) --------------------------------------------------------
unsigned int __cdecl sub_1004C3E0(int a1)
{
  unsigned int result; // eax@1

  result = sub_1004C210((_BYTE *)a1);
  if ( !result )
  {
    result = sub_1004C210((_BYTE *)(a1 + 4));
    if ( !result )
    {
      result = sub_1004C210((_BYTE *)(a1 + 8));
      if ( !result )
      {
        result = sub_1004C210((_BYTE *)(a1 + 12));
        if ( !result )
          result = sub_100543D0((_BYTE *)(a1 + 16), 1, 0);
      }
    }
  }
  return result;
}

//----- (1004C440) --------------------------------------------------------
int __cdecl sub_1004C440(_BYTE *a1)
{
  return sub_10054810(a1, 0, 0x20u, 2u, 0);
}

//----- (1004C460) --------------------------------------------------------
unsigned int __cdecl sub_1004C460(_BYTE *a1)
{
  return sub_10054600(a1, -1, 4, -1, 0);
}

//----- (1004C480) --------------------------------------------------------
int __cdecl sub_1004C480(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 4u, 0, 0);
}

//----- (1004C4A0) --------------------------------------------------------
int __cdecl sub_1004C4A0(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 5u, 4u, 0);
}

//----- (1004C4C0) --------------------------------------------------------
int __cdecl sub_1004C4C0(int a1)
{
  return sub_10054420(a1 + 4, 0.0, 9.9999996e24, COERCE_INT(0.0), 0);
}

//----- (1004C4F0) --------------------------------------------------------
int __cdecl sub_1004C4F0(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 9u, 0, 0);
}

//----- (1004C510) --------------------------------------------------------
int __cdecl sub_1004C510(int a1)
{
  int result; // eax@1

  result = sub_1004C480((unsigned __int8 *)(a1 + 2));
  if ( !result )
  {
    result = sub_10068960((unsigned __int8 *)a1);
    if ( !result )
    {
      result = sub_1004C4A0((unsigned __int8 *)(a1 + 1));
      if ( !result )
      {
        result = sub_1004C4C0(a1 + 8);
        if ( !result )
          result = sub_10054420(a1 + 20, -100.0, 100.0, COERCE_INT(0.0), 0);
      }
    }
  }
  return result;
}

//----- (1004C580) --------------------------------------------------------
int __cdecl sub_1004C580(_BYTE *a1)
{
  return sub_10054810(a1, 0x81u, 0xFFu, 0xC0u, 0);
}

//----- (1004C5A0) --------------------------------------------------------
signed int __cdecl sub_1004C5A0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10054810(a1, 0, 0xFFFFFFFF, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (1004C5D0) --------------------------------------------------------
int __cdecl sub_1004C5D0(_BYTE *a1)
{
  return sub_10054770(a1, 0, 0xFFFu, 640, 0);
}

//----- (1004C5F0) --------------------------------------------------------
int __cdecl sub_1004C5F0(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_10054770(a1, 0, 0xFFFu, 640, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004C630) --------------------------------------------------------
int __cdecl sub_1004C630(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@3

  v2 = 0;
  if ( sub_1004C5A0((_BYTE *)(a1 + 8), a2) == 1 )
    v2 = 1;
  result = sub_1004C5F0((_BYTE *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004C5F0((_BYTE *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10068980((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004C5F0((_BYTE *)(a1 + 6), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (1004C6C0) --------------------------------------------------------
int __cdecl sub_1004C6C0(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 2u, 0, 0);
}

//----- (1004C6E0) --------------------------------------------------------
int __cdecl sub_1004C6E0(int a1)
{
  int result; // eax@1

  result = sub_10054720((unsigned __int8 *)a1, 0, 0x78u, 0, 0);
  if ( !result )
    result = sub_10054720((unsigned __int8 *)(a1 + 1), 0, 0x78u, 0, 0);
  return result;
}

//----- (1004C710) --------------------------------------------------------
int __cdecl sub_1004C710(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 3u, 1u, 0);
}

//----- (1004C730) --------------------------------------------------------
unsigned int __cdecl sub_1004C730(int a1)
{
  unsigned int result; // eax@1

  result = sub_10054600((_BYTE *)a1, -1, 5, -1, 0);
  if ( !result )
    result = sub_10054600((_BYTE *)(a1 + 4), -1, 5, -1, 0);
  return result;
}

//----- (1004C760) --------------------------------------------------------
int __cdecl sub_1004C760(int a1)
{
  int result; // eax@1

  result = sub_10054420(a1, 0.0, 5.0, COERCE_INT(0.23), 0);
  if ( !result )
  {
    result = sub_10054420(a1 + 4, -10.0, 10.0, COERCE_INT(0.0), 0);
    if ( !result )
    {
      result = sub_10054420(a1 + 8, 0.0, 12.9, COERCE_INT(0.86000001), 0);
      if ( !result )
      {
        result = sub_10054420(a1 + 12, 0.0, 5.0, COERCE_INT(0.23), 0);
        if ( !result )
          result = sub_10054420(a1 + 16, -10.0, 10.0, COERCE_INT(0.0), 0);
      }
    }
  }
  return result;
}

//----- (1004C850) --------------------------------------------------------
int __cdecl sub_1004C850(int a1)
{
  int v1; // edi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_100543D0((_BYTE *)(a1 + v1 + 44), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      result = sub_10054720((unsigned __int8 *)(a1 + 1), 0, 3u, 1u, 0);
      if ( !result )
      {
        result = sub_1004C730(a1 + 36);
        if ( !result )
        {
          result = sub_10054420(a1 + 52, -9.9999996e24, 9.9999996e24, COERCE_INT(77.166664), 0);
          if ( !result )
          {
            result = sub_1004C760(a1 + 8);
            if ( !result )
            {
              result = sub_1004C730(a1 + 28);
              if ( !result )
              {
                result = sub_10054770((_BYTE *)(a1 + 2), 0x1F4u, 0x800u, 600, 0);
                if ( !result )
                {
                  result = sub_1004C6C0((unsigned __int8 *)(a1 + 50));
                  if ( !result )
                  {
                    result = sub_1004C6E0(a1 + 57);
                    if ( !result )
                    {
                      result = sub_100543D0((_BYTE *)(a1 + 56), 0, 0);
                      if ( !result )
                        result = sub_1004C710((unsigned __int8 *)(a1 + 51));
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
  }
  return result;
}

//----- (1004C960) --------------------------------------------------------
int __cdecl sub_1004C960(_BYTE *a1)
{
  return sub_10054810(a1, 0, 0x1FFFu, 0, 0);
}

//----- (1004C980) --------------------------------------------------------
signed int __cdecl sub_1004C980(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10054770(a1, 0, 0xFFFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (1004C9B0) --------------------------------------------------------
int __cdecl sub_1004C9B0(int a1)
{
  int v1; // edi@1
  signed int v2; // esi@1
  int result; // eax@2

  v1 = a1;
  v2 = 0;
  do
  {
    result = sub_10064600(v1);
    if ( result )
      break;
    ++v2;
    v1 += 232;
  }
  while ( v2 < 14 );
  return result;
}

//----- (1004C9E0) --------------------------------------------------------
int __cdecl sub_1004C9E0(int a1)
{
  return sub_10054420(a1 + 4, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0);
}

//----- (1004CA10) --------------------------------------------------------
int __cdecl sub_1004CA10(_BYTE *a1)
{
  return sub_10054810(a1, 0, 0x7FFFFFFFu, 0, 0);
}

//----- (1004CA30) --------------------------------------------------------
int __cdecl sub_1004CA30(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 0xCu, 0, 0);
}

//----- (1004CA50) --------------------------------------------------------
int __cdecl sub_1004CA50(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 0x80u, 1u, 0);
}

//----- (1004CA70) --------------------------------------------------------
signed int __cdecl sub_1004CA70(int a1, int a2)
{
  signed int v2; // ebx@1
  signed int result; // eax@9

  v2 = 0;
  if ( sub_1004B6D0((unsigned __int8 *)(a1 + 15), a2) == 1 )
    v2 = 1;
  if ( sub_1004B6D0((unsigned __int8 *)(a1 + 34), a2) == 1 )
    v2 = 1;
  if ( sub_1004B6D0((unsigned __int8 *)(a1 + 38), a2) == 1 )
    v2 = 1;
  if ( sub_1004B6D0((unsigned __int8 *)(a1 + 36), a2) == 1 )
    v2 = 1;
  result = sub_100543D0((_BYTE *)(a1 + 33), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B7C0((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B5E0((unsigned __int8 *)(a1 + 48), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B670((unsigned __int8 *)(a1 + 46), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B5E0((unsigned __int8 *)(a1 + 47), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B6A0((unsigned __int8 *)(a1 + 45), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B610((unsigned __int8 *)(a1 + 44), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B5E0((unsigned __int8 *)(a1 + 28), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004BA00((unsigned __int8 *)(a1 + 51), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B700((unsigned __int8 *)(a1 + 31), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_10062D70((_BYTE *)(a1 + 20), a2) == 1 )
    v2 = 1;
  result = sub_1004B640((unsigned __int8 *)(a1 + 50), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B5E0((unsigned __int8 *)(a1 + 24), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B730((unsigned __int8 *)(a1 + 5), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B5E0((unsigned __int8 *)(a1 + 25), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B760((unsigned __int8 *)(a1 + 6), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B5E0((unsigned __int8 *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B790((unsigned __int8 *)(a1 + 3), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10054420(a1 + 40, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B5E0((unsigned __int8 *)(a1 + 26), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B7C0((unsigned __int8 *)(a1 + 9), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B5E0((unsigned __int8 *)(a1 + 8), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B7F0((unsigned __int8 *)(a1 + 7), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B700((unsigned __int8 *)(a1 + 1), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B8A0((unsigned __int8 *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B8A0((unsigned __int8 *)(a1 + 10), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 37), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B840((unsigned __int8 *)(a1 + 11), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B5E0((unsigned __int8 *)(a1 + 12), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0((_BYTE *)(a1 + 32), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B640((unsigned __int8 *)(a1 + 49), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10054420(a1 + 16, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B8A0((unsigned __int8 *)(a1 + 35), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (1004CF80) --------------------------------------------------------
int __cdecl sub_1004CF80(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_10054810(a1, 0, 0x3FFFFu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004CFB0) --------------------------------------------------------
signed int __cdecl sub_1004CFB0(_BYTE *a1, int a2)
{
  signed int v2; // ebx@1
  signed int result; // eax@1

  v2 = 0;
  result = sub_100543D0(a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10054420((int)(a1 + 4), -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (1004D020) --------------------------------------------------------
int __cdecl sub_1004D020(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 0x64u, 0x64u, 0);
}

//----- (1004D080) --------------------------------------------------------
int __cdecl sub_1004D080(int a1)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_100543D0((_BYTE *)(v1 + a1 + 4), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 3 )
      return sub_1004D020((unsigned __int8 *)(a1 + 10));
  }
  return result;
}

//----- (1004D090) --------------------------------------------------------
int __cdecl sub_1004D090(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 0xEu, 0, 0);
}

//----- (1004D0B0) --------------------------------------------------------
int __cdecl sub_1004D0B0(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 5u, 0, 0);
}

//----- (1004D0D0) --------------------------------------------------------
int __cdecl sub_1004D0D0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10054720(a1, 0, 3u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004D100) --------------------------------------------------------
unsigned int __cdecl sub_1004D100(char *a1)
{
  return sub_10054510(a1, -6, 7, 7, 0);
}

//----- (1004D120) --------------------------------------------------------
int __cdecl sub_1004D120(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 0x3Cu, 0, 0);
}

//----- (1004D140) --------------------------------------------------------
int __cdecl sub_1004D140(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 6u, 2u, 0);
}

//----- (1004D160) --------------------------------------------------------
int __cdecl sub_1004D160(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10054720(a1, 0, 6u, 2u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004D190) --------------------------------------------------------
int __cdecl sub_1004D190(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 8u, 0, 0);
}

//----- (1004D1B0) --------------------------------------------------------
signed int __cdecl sub_1004D1B0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10054810(a1, 0, 0xFFFFFFFF, 0xFFFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (1004D1E0) --------------------------------------------------------
int __cdecl sub_1004D1E0(int a1, int a2)
{
  signed int v2; // ebp@1
  unsigned __int8 v3; // bl@1
  int result; // eax@3

  v2 = 0;
  v3 = 0;
  do
  {
    switch ( v3 )
    {
      case 4u:
      case 5u:
      case 6u:
      case 9u:
      case 0xAu:
        result = sub_10054720((unsigned __int8 *)(a1 + v3), 0, 0x3Fu, 0, a2);
        break;
      default:
        result = sub_10054720((unsigned __int8 *)(a1 + v3), 0, 0xFFu, 0xFFu, a2);
        break;
    }
    if ( result == 1 )
    {
      v2 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v3;
  }
  while ( v3 < 0xDu );
  return v2;
}

//----- (1004D280) --------------------------------------------------------
unsigned int __cdecl sub_1004D280(int a1)
{
  unsigned int result; // eax@1

  result = sub_1004B8D0((char *)a1);
  if ( !result )
  {
    result = sub_1004D0B0((unsigned __int8 *)(a1 + 1));
    if ( !result )
    {
      result = sub_1004C6C0((unsigned __int8 *)(a1 + 2));
      if ( !result )
        result = sub_1004B8F0((_BYTE *)(a1 + 6));
    }
  }
  return result;
}

//----- (1004D2C0) --------------------------------------------------------
unsigned int __cdecl sub_1004D2C0(int a1)
{
  unsigned int result; // eax@1

  result = sub_1004B8D0((char *)(a1 + 1));
  if ( !result )
  {
    result = sub_1004D0B0((unsigned __int8 *)(a1 + 2));
    if ( !result )
    {
      result = sub_1004B8F0((_BYTE *)(a1 + 6));
      if ( !result )
        result = sub_100543D0((_BYTE *)a1, 0, 0);
    }
  }
  return result;
}

//----- (1004D320) --------------------------------------------------------
int __cdecl sub_1004D320(int a1)
{
  int result; // eax@1

  result = sub_10064510((_BYTE *)(a1 + 3272));
  if ( !result )
  {
    result = sub_10064510((_BYTE *)(a1 + 3274));
    if ( !result )
    {
      result = sub_100689B0((unsigned __int8 *)(a1 + 14));
      if ( !result )
      {
        result = sub_1004D310(a1 + 24);
        if ( !result )
        {
          result = sub_100689B0((unsigned __int8 *)(a1 + 15));
          if ( !result )
          {
            result = sub_10068960((unsigned __int8 *)(a1 + 12));
            if ( !result )
              result = sub_100689B0((unsigned __int8 *)(a1 + 13));
          }
        }
      }
    }
  }
  return result;
}
// 1004D310: using guessed type _DWORD __cdecl sub_1004D310(_DWORD);

//----- (1004D3A0) --------------------------------------------------------
unsigned int __cdecl sub_1004D3A0(int a1)
{
  unsigned int result; // eax@1

  result = sub_1004B910((char *)(a1 + 3));
  if ( !result )
  {
    result = sub_1004B910((char *)(a1 + 2));
    if ( !result )
    {
      result = sub_1004B910((char *)a1);
      if ( !result )
        result = sub_1004B910((char *)(a1 + 1));
    }
  }
  return result;
}

//----- (1004D3E0) --------------------------------------------------------
unsigned int __cdecl sub_1004D3E0(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_1004B930((char *)(a1 + 3), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B930((char *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B930((char *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B930((char *)(a1 + 1), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (1004D460) --------------------------------------------------------
unsigned int __cdecl sub_1004D460(int a1)
{
  signed int v1; // esi@1
  int v2; // edi@1
  unsigned int result; // eax@2

  v1 = 0;
  v2 = a1;
  while ( 1 )
  {
    result = sub_1004D3A0(v2);
    if ( result )
      break;
    ++v1;
    v2 += 4;
    if ( v1 >= 3 )
    {
      result = sub_1004C6C0((unsigned __int8 *)(a1 + 12));
      if ( !result )
        result = sub_1004B9B0((unsigned __int8 *)(a1 + 13));
      return result;
    }
  }
  return result;
}

//----- (1004D4B0) --------------------------------------------------------
signed int __cdecl sub_1004D4B0(int a1, int a2)
{
  signed int v2; // edi@1
  int v3; // esi@1
  signed int result; // eax@2
  signed int v5; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v5 = 0;
  v3 = a1;
  do
  {
    result = sub_1004D3E0(v3, a2);
    if ( result == 1 )
    {
      v5 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v2;
    v3 += 4;
  }
  while ( v2 < 3 );
  result = sub_1004B960((unsigned __int8 *)(a1 + 12), a2);
  if ( result == 1 )
  {
    v5 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B9D0((unsigned __int8 *)(a1 + 13), a2);
  if ( result == 1 )
  {
    result = 1;
  }
  else if ( !result )
  {
    result = v5;
  }
  return result;
}

//----- (1004D540) --------------------------------------------------------
int __cdecl sub_1004D540(int a1)
{
  int result; // eax@1

  result = sub_1004B990((_BYTE *)(a1 + 4));
  if ( !result )
    result = sub_10054770((_BYTE *)a1, 0, 0x3FFFu, 0x3FFF, 0);
  return result;
}

//----- (1004D570) --------------------------------------------------------
int __cdecl sub_1004D570(int a1)
{
  int result; // eax@1

  result = sub_1004C250((_BYTE *)a1);
  if ( !result )
    result = sub_1004C580((_BYTE *)(a1 + 4));
  return result;
}

//----- (1004D5A0) --------------------------------------------------------
unsigned int __cdecl sub_1004D5A0(int a1)
{
  unsigned int result; // eax@1

  result = sub_1004C210((_BYTE *)a1);
  if ( !result )
  {
    result = sub_1004C210((_BYTE *)(a1 + 4));
    if ( !result )
      result = sub_1004C460((_BYTE *)(a1 + 8));
  }
  return result;
}

//----- (1004D5D0) --------------------------------------------------------
unsigned int __cdecl sub_1004D5D0(int a1)
{
  unsigned int result; // eax@1

  result = sub_1004C210((_BYTE *)a1);
  if ( !result )
    result = sub_1004C4F0((unsigned __int8 *)(a1 + 4));
  return result;
}

//----- (1004D5F0) --------------------------------------------------------
unsigned int __cdecl sub_1004D5F0(int a1)
{
  unsigned int result; // eax@1

  result = sub_1004C210((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10054720((unsigned __int8 *)(a1 + 8), 0, 0x1Eu, 0x1Eu, 0);
    if ( !result )
      result = sub_1004C460((_BYTE *)(a1 + 4));
  }
  return result;
}

//----- (1004D630) --------------------------------------------------------
void __cdecl __noreturn sub_1004D630(int a1)
{
  exit(a1 + 4);
}

//----- (1004D7A0) --------------------------------------------------------
unsigned int __cdecl sub_1004D7A0(_BYTE *a1)
{
  unsigned int result; // eax@1

  result = sub_1004D280((int)(a1 + 4));
  if ( !result )
  {
    result = sub_1004D2C0((int)(a1 + 12));
    if ( !result )
      result = sub_100543D0(a1, 0, 0);
  }
  return result;
}

//----- (1004D7E0) --------------------------------------------------------
unsigned int __cdecl sub_1004D7E0(int a1)
{
  unsigned int result; // eax@1

  result = sub_1004CA10((_BYTE *)(a1 + 8));
  if ( !result )
  {
    result = sub_10054810((_BYTE *)(a1 + 4), 0, 0x258u, 0, 0);
    if ( !result )
    {
      result = sub_10054560((_BYTE *)(a1 + 2), -1024, 192, 0, 0);
      if ( !result )
      {
        result = sub_1004CA30((unsigned __int8 *)a1);
        if ( !result )
        {
          result = sub_1004C960((_BYTE *)(a1 + 12));
          if ( !result )
            result = sub_1004CA50((unsigned __int8 *)(a1 + 1));
        }
      }
    }
  }
  return result;
}

//----- (1004D860) --------------------------------------------------------
int __cdecl sub_1004D860(unsigned __int8 *a1)
{
  int result; // eax@1

  result = sub_10068960(a1);
  if ( !result )
    result = sub_1004C9E0((int)(a1 + 4));
  return result;
}

//----- (1004D880) --------------------------------------------------------
unsigned int __cdecl sub_1004D880(int a1)
{
  unsigned int result; // eax@1

  result = sub_1004D7A0((_BYTE *)a1);
  if ( !result )
  {
    result = sub_1004D7E0(a1 + 20);
    if ( !result )
      result = sub_1004D860((unsigned __int8 *)(a1 + 36));
  }
  return result;
}

//----- (1004D8B0) --------------------------------------------------------
signed int __cdecl sub_1004D8B0(int a1, int a2)
{
  signed int v2; // ebx@1
  bool v3; // zf@5
  signed int result; // eax@5

  v2 = 0;
  if ( sub_1004B6D0((unsigned __int8 *)a1, a2) == 1 )
    v2 = 1;
  if ( sub_1004C980((_BYTE *)(a1 + 2), a2) == 1 )
    v2 = 1;
  v3 = sub_1004B6D0((unsigned __int8 *)(a1 + 1), a2) == 1;
  result = 1;
  if ( !v3 )
    result = v2;
  return result;
}

//----- (1004D900) --------------------------------------------------------
int __cdecl sub_1004D900(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@1

  v2 = 0;
  result = sub_1004CF80((_BYTE *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004CFB0((_BYTE *)(a1 + 4), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (1004D950) --------------------------------------------------------
int __cdecl sub_1004D950(int a1)
{
  int result; // eax@1

  result = sub_10054770((_BYTE *)(a1 + 12), 0, 0x1E61u, 1200, 0);
  if ( !result )
  {
    result = sub_1004D140((unsigned __int8 *)a1);
    if ( !result )
    {
      result = sub_1004D190((unsigned __int8 *)(a1 + 11));
      if ( !result )
      {
        result = sub_100543D0((_BYTE *)(a1 + 1), 0, 0);
        if ( !result )
          result = sub_10054770((_BYTE *)(a1 + 14), 0, 0x1E61u, 1200, 0);
      }
    }
  }
  return result;
}

//----- (1004D9C0) --------------------------------------------------------
int __cdecl sub_1004D9C0(_BYTE *a1, int a2)
{
  return sub_10054810(a1, 0, 0x1FEu, 0, a2);
}

//----- (1004D9E0) --------------------------------------------------------
int __usercall sub_1004D9E0@<eax>(unsigned __int8 *a1@<eax>, int a2@<edi>)
{
  unsigned __int8 *v2; // esi@1
  signed int v3; // ebx@1
  int result; // eax@1
  int v5; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  result = sub_1004B870(a1, v5);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( *v2 == 1 )
    result = sub_1004D900((int)(v2 + 4), a2);
  else
    result = sub_1004CA70((int)(v2 + 4), a2);
  if ( result != 1 && !result )
    result = v3;
  return result;
}

//----- (1004DA30) --------------------------------------------------------
signed int __usercall sub_1004DA30@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  signed int v3; // ebx@1
  char v4; // al@5
  signed int result; // eax@8
  int v6; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  if ( sub_1004D8B0(a1, v6) == 1 )
    v3 = 1;
  if ( a2 == 2 )
  {
    *(_BYTE *)(v2 + 1) = 40;
    v3 = 1;
  }
  v4 = *(_BYTE *)(v2 + 1);
  if ( v4 == 26 || v4 == 12 )
  {
    result = sub_10054720((unsigned __int8 *)(v2 + 4), 0x20u, 0x20u, 0x20u, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    result = sub_100543D0((_BYTE *)(v2 + 37), 0, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    if ( *(_BYTE *)(v2 + 1) == 26 )
      result = sub_1004BD60(v2 + 5, a2);
    else
      result = sub_1004BA30(v2 + 5, a2);
    if ( result != 1 )
    {
      if ( result )
        return result;
      goto LABEL_25;
    }
    return 1;
  }
  if ( v4 != 40 )
  {
    if ( a2 != 1 )
      return -4;
    *(_BYTE *)(v2 + 1) = 40;
    return 1;
  }
  result = sub_1004D1B0((_BYTE *)(v2 + 4), a2);
  if ( result != 1 )
LABEL_25:
    result = v3;
  return result;
}

//----- (1004DB00) --------------------------------------------------------
int __usercall sub_1004DB00@<eax>(unsigned __int8 *a1@<eax>, int a2@<esi>)
{
  unsigned __int8 *v2; // edi@1
  signed int v3; // ebx@1
  int result; // eax@1
  int v5; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  result = sub_1004D0D0(a1, v5);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004D160(v2 + 1, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100543D0(v2 + 2, 0, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004B640(v2 + 3, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10054810(v2 + 8, 0, 0x1E61u, 0x4B0u, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10054810(v2 + 12, 0, 0x1E61u, 0x4B0u, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1004D9C0(v2 + 4, a2);
  if ( result != 1 && !result )
    result = v3;
  return result;
}

//----- (1004DBF0) --------------------------------------------------------
int __cdecl sub_1004DBF0(unsigned __int8 *a1)
{
  return sub_1004D9E0(a1, 0);
}

//----- (1004DC00) --------------------------------------------------------
int __cdecl sub_1004DC00(unsigned __int8 *a1)
{
  return sub_1004DB00(a1, 0);
}

//----- (1004DC10) --------------------------------------------------------
signed int __cdecl sub_1004DC10(int a1)
{
  return sub_1004DA30(a1, 0);
}

//----- (1004DC20) --------------------------------------------------------
signed int sub_1004DC20()
{
  const char *v1; // [sp+0h] [bp-14h]@1
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+8h] [bp-Ch]@1
  int v4; // [sp+Ch] [bp-8h]@1
  int *v5; // [sp+10h] [bp-4h]@1

  v1 = "/shr_mem/iop_dme_intf.shr";
  v2 = 5;
  v3 = 220;
  v4 = 0;
  v5 = &dword_103334F4;
  dword_103334F4 = -15;
  if ( !sub_1007CD60((LONG)&v1) )
    sub_10042930("..\\lib\\adl\\iop_dme_intf_prj.c", 129, 1, 0);
  return sub_1007C8F0((int)&v1);
}
// 103334F4: using guessed type int dword_103334F4;

//----- (1004DC90) --------------------------------------------------------
void sub_1004DC90()
{
  dword_103334F4 = -15;
}
// 103334F4: using guessed type int dword_103334F4;

//----- (1004DCA0) --------------------------------------------------------
int sub_1004DCA0()
{
  return sub_1007C0F0(9);
}

//----- (1004DCB0) --------------------------------------------------------
BOOL sub_1004DCB0()
{
  return sub_1007C110(9, 200) == 0;
}

//----- (1004DCD0) --------------------------------------------------------
BOOL __cdecl sub_1004DCD0(int a1)
{
  return sub_1007C3B0(6953, a1, 1) == 0;
}

//----- (1004DCF0) --------------------------------------------------------
char __cdecl sub_1004DCF0(char a1, void *a2)
{
  void *v2; // esi@1
  unsigned __int8 v3; // al@1
  int v4; // eax@2
  int v5; // ST08_4@2
  char result; // al@2
  int v7; // [sp+8h] [bp-Ch]@1
  int v8; // [sp+Ch] [bp-8h]@1

  v2 = a2;
  v8 = 0;
  v7 = 109000;
  v3 = sub_10043FF0(&a1, 1u, (int)&unk_101058F8, 6, 2, 2);
  if ( v3 >= 2u )
  {
    result = 0;
  }
  else
  {
    v4 = 3 * v3;
    v5 = (unsigned __int16)word_101058FA[v4];
    LOBYTE(v8) = byte_101058FC[2 * v4];
    sub_1007C650(v5, v2, 8, &v7);
    result = 1;
  }
  return result;
}
// 101058FA: using guessed type __int16 word_101058FA[];

//----- (1004DD90) --------------------------------------------------------
int __cdecl sub_1004DD90(char a1, int a2)
{
  int result; // eax@1

  result = sub_10043FF0(&a1, 1u, (int)&unk_101058F8, 6, 2, 2);
  if ( (unsigned __int8)result < 2u )
    result = sub_1007C500((unsigned __int16)word_101058FA[3 * (unsigned __int8)result], a2, 8);
  return result;
}
// 101058FA: using guessed type __int16 word_101058FA[];

//----- (1004DDD0) --------------------------------------------------------
signed int sub_1004DDD0()
{
  return 25;
}

//----- (1004DDE0) --------------------------------------------------------
char __thiscall sub_1004DDE0(void *this)
{
  char v1; // bl@1
  void *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_1027EAD8 = sub_100460C0(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_1027EAE0, 0, 0xAA0u);
  v1 = 0;
  v4 = 0;
  v2 = &unk_1027EAE0;
  do
  {
    result = sub_10046530(v4, (int)v2);
    ++v1;
    v2 = (char *)v2 + 2720;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 2u );
  return result;
}
// 1027EAD8: using guessed type int dword_1027EAD8;

//----- (1004DE50) --------------------------------------------------------
char __usercall sub_1004DE50@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4)
{
  char result; // al@1

  memset(a3, 0, (unsigned __int16)a2);
  result = 0;
  if ( a4 )
  {
    if ( a4 == 1 )
      result = sub_10025390(6, 8, a1, a2, a3);
  }
  else
  {
    result = sub_10025390(6, 5, a1, a2, a3);
  }
  return result;
}

//----- (1004DE90) --------------------------------------------------------
void *__usercall sub_1004DE90@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4)
{
  int v4; // edi@1
  void *result; // eax@4

  v4 = 0;
  if ( dword_1027EAD8 == 1379255385 )
    goto LABEL_4;
  v4 = sub_1007C2F0(86, 10);
  if ( !v4 )
  {
    memset((char *)&unk_1027EAE0 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
    sub_10046530(a1, (int)&unk_1027EAE0 + 2720 * (unsigned __int8)a1);
LABEL_4:
    result = memcpy(a4, (char *)&unk_1027EAE0 + 2720 * (unsigned __int8)a1 + (unsigned __int16)a2, (unsigned __int16)a3);
    goto LABEL_6;
  }
  result = memset(a4, 0, (unsigned __int16)a3);
LABEL_6:
  if ( dword_1027EAD8 != 1379255385 )
    result = (void *)sub_1007C2C0(v4, 86);
  return result;
}
// 1027EAD8: using guessed type int dword_1027EAD8;

//----- (1004DF30) --------------------------------------------------------
char __cdecl sub_1004DF30(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 <= 0xAu )
    result = sub_1004DE50(4 * (a2 + 6), 4, a3, a1);
  return result;
}

//----- (1004DF70) --------------------------------------------------------
bool __cdecl sub_1004DF70(char a1, char a2, void *a3)
{
  bool result; // al@1
  unsigned __int8 v4; // al@3

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 <= 0xAu )
  {
    sub_1004DE90(a1, 4 * ((unsigned __int8)a2 + 6), 4, a3);
    v4 = *((_BYTE *)a3 + 1);
    result = v4 < 0x33u || v4 >= 0x64u && v4 <= 0x81u || v4 >= 0x96u && v4 <= 0x9Eu;
  }
  return result;
}

//----- (1004DFD0) --------------------------------------------------------
char __cdecl sub_1004DFD0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xAu )
    result = sub_1004DE50(a2, 1, a3, a1);
  return result;
}

//----- (1004E010) --------------------------------------------------------
char __cdecl sub_1004E010(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xAu )
  {
    sub_1004DE90(a1, (unsigned __int8)a2, 1, a3);
    result = 1;
  }
  return result;
}

//----- (1004E040) --------------------------------------------------------
char __cdecl sub_1004E040(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xBu )
    result = sub_1004DE50(a2 + 10, 1, a3, a1);
  return result;
}

//----- (1004E080) --------------------------------------------------------
char __cdecl sub_1004E080(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xBu )
  {
    sub_1004DE90(a1, (unsigned __int8)a2 + 10, 1, a3);
    result = 1;
  }
  return result;
}

//----- (1004E0C0) --------------------------------------------------------
char __cdecl sub_1004E0C0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 2u )
    result = sub_1004DE50(16 * (a2 + 50), 16, a3, a1);
  return result;
}

//----- (1004E100) --------------------------------------------------------
bool __cdecl sub_1004E100(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 2u )
  {
    sub_1004DE90(a1, 16 * ((unsigned __int8)a2 + 50), 16, a3);
    result = *(_BYTE *)a3 < 8u && *((_BYTE *)a3 + 1) < 8u;
  }
  return result;
}

//----- (1004E150) --------------------------------------------------------
char __cdecl sub_1004E150(int a1, char a2, void *a3)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    if ( a2 == 1 )
    {
      sub_1004DE90(a1, 1228, 1, a3);
      result = 1;
    }
    else
    {
      result = sub_1004DE50(1228, 1, a3, a1);
    }
  }
  else
  {
    sub_10042930("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 665, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1004E1C0) --------------------------------------------------------
char __cdecl sub_1004E1C0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x29u )
    result = sub_1004DE50(12 * a2 + 68, 12, a3, a1);
  return result;
}

//----- (1004E200) --------------------------------------------------------
bool __cdecl sub_1004E200(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x29u )
  {
    sub_1004DE90(a1, 12 * (unsigned __int8)a2 + 68, 12, a3);
    result = *((_WORD *)a3 + 1) < 0x319u;
  }
  return result;
}

//----- (1004E240) --------------------------------------------------------
char __cdecl sub_1004E240(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x2Au )
    result = sub_1004DE50(4 * (a2 + 140), 4, a3, a1);
  return result;
}

//----- (1004E280) --------------------------------------------------------
bool __cdecl sub_1004E280(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x2Au )
  {
    sub_1004DE90(a1, 4 * ((unsigned __int8)a2 + 140), 4, a3);
    result = *((_WORD *)a3 + 1) < 0x145u;
  }
  return result;
}

//----- (1004E2C0) --------------------------------------------------------
char __cdecl sub_1004E2C0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1004DE50(1229, 1, a2, a1);
  return result;
}

//----- (1004E2F0) --------------------------------------------------------
char __cdecl sub_1004E2F0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1004DE90(a1, 1229, 1, a2);
    result = 1;
  }
  return result;
}

//----- (1004E320) --------------------------------------------------------
char __cdecl sub_1004E320(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1004DE50(1212, 16, a2, a1);
  return result;
}

//----- (1004E350) --------------------------------------------------------
char __cdecl sub_1004E350(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1004DE90(a1, 1212, 16, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004E380) --------------------------------------------------------
char __cdecl sub_1004E380(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1004DE50(2400, 65, a2, a1);
  return result;
}

//----- (1004E3B0) --------------------------------------------------------
char __cdecl sub_1004E3B0(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1004DE90(a1, 2400, 65, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004E3E0) --------------------------------------------------------
char __cdecl sub_1004E3E0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 < 8u && (unsigned __int8)a1 < 2u )
    result = sub_1004DE50(4 * (a2 + 182), 4, a3, a1);
  return result;
}

//----- (1004E420) --------------------------------------------------------
char __cdecl sub_1004E420(char a1, char a2, void *a3)
{
  char result; // al@2

  if ( (unsigned __int8)a2 > 7u )
    result = sub_10042930("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 1428, 0, 0);
  else
    result = (unsigned int)sub_1004DE90(a1, 4 * ((unsigned __int8)a2 + 182), 4, a3);
  return result;
}

//----- (1004E470) --------------------------------------------------------
char __cdecl sub_1004E470(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 <= 4u )
    result = sub_1004DE50(8 * (a2 + 95), 8, a3, a1);
  return result;
}

//----- (1004E4B0) --------------------------------------------------------
char __cdecl sub_1004E4B0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = a2;
  if ( (unsigned __int8)a2 <= 4u )
    result = (unsigned int)sub_1004DE90(a1, 8 * ((unsigned __int8)a2 + 95), 8, a3);
  return result;
}

//----- (1004E4E0) --------------------------------------------------------
char __cdecl sub_1004E4E0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1004DE50(22, 1, a2, a1);
  return result;
}

//----- (1004E510) --------------------------------------------------------
char __cdecl sub_1004E510(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1004DE50(832, 4, a2, a1);
  return result;
}

//----- (1004E540) --------------------------------------------------------
char __cdecl sub_1004E540(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1004DE90(a1, 832, 4, a2);
    result = 1;
  }
  return result;
}

//----- (1004E570) --------------------------------------------------------
char __cdecl sub_1004E570(int a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@4
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10062720(a1);
  if ( v6 == 2 )
  {
LABEL_44:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 0:
        if ( a2 )
        {
          sub_1004E420(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_1004E3E0(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 1:
        if ( a2 )
        {
          sub_1004E4B0(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_1004E470(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 2:
        if ( a2 )
          result = sub_1004DF70(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1004DF30(v6, *(_BYTE *)a4, a5);
        break;
      case 3:
        if ( a2 )
          result = sub_1004E200(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1004E1C0(v6, *(_BYTE *)a4, a5);
        break;
      case 4:
        if ( a2 )
          result = sub_1004E280(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1004E240(v6, *(_BYTE *)a4, a5);
        break;
      case 5:
        if ( a2 )
          result = sub_1004E010(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1004DFD0(v6, *(_BYTE *)a4, a5);
        break;
      case 6:
        if ( a2 )
          result = sub_1004E080(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1004E040(v6, *(_BYTE *)a4, a5);
        break;
      case 7:
        result = sub_1004E4E0(v6, a5);
        break;
      case 8:
        if ( a2 )
          result = sub_1004E350(v6, a5);
        else
          result = sub_1004E320(v6, a5);
        break;
      case 9:
        if ( a2 )
          result = sub_1004E100(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1004E0C0(v6, *(_BYTE *)a4, a5);
        break;
      case 0x1D:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_1004E3B0(v6, a5);
        else
          result = sub_1004E380(v6, a5);
        break;
      case 0x21:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_1004E2F0(v6, a5);
        else
          result = sub_1004E2C0(v6, a5);
        break;
      case 0x1B:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_1004E540(v6, a5);
        else
          result = sub_1004E510(v6, a5);
        break;
      default:
        sub_10042930("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 2329, 0, 0);
        goto LABEL_44;
    }
  }
  return result;
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1004E910) --------------------------------------------------------
char __cdecl sub_1004E910(void *a1)
{
  int v1; // ecx@0
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  return sub_100253F0(1, 1947, a1, (int)&v3);
}

//----- (1004E930) --------------------------------------------------------
BOOL __cdecl sub_1004E930(int a1)
{
  return sub_1007C3B0(6792, a1, 284) == 0;
}

//----- (1004E950) --------------------------------------------------------
char __cdecl sub_1004E950(int a1)
{
  return sub_1007C5E0(6792, a1, 284);
}

//----- (1004E970) --------------------------------------------------------
char __cdecl sub_1004E970(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2

  if ( a2 )
    result = sub_1004E930((int)a5);
  else
    result = sub_1004E910(a5);
  return result;
}

//----- (1004E9A0) --------------------------------------------------------
char __cdecl sub_1004E9A0(int a1)
{
  char v1; // bl@1
  int v2; // esi@1
  int v3; // eax@1

  v1 = 0;
  v2 = j_HWM_pvg_hsdb_get_lrus_online();
  j_HWM_pvg_hsdb_set_sim_lrus_online(0);
  v3 = j_HWM_pvg_hsdb_get_lrus_online();
  if ( (a1 & v3) == a1 )
    v1 = 1;
  j_HWM_pvg_hsdb_set_sim_lrus_online(v2 - v3);
  return v1;
}
// 1007C810: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 1007C840: using guessed type int __cdecl j_HWM_pvg_hsdb_set_sim_lrus_online(_DWORD);

//----- (1004E9E0) --------------------------------------------------------
char sub_1004E9E0()
{
  return sub_10047AE0((int)"_xm_mute_output");
}

//----- (1004E9F0) --------------------------------------------------------
int sub_1004E9F0()
{
  return sub_10043370(414);
}

//----- (1004EA00) --------------------------------------------------------
char sub_1004EA00()
{
  return sub_10043480(0x19Eu);
}

//----- (1004EA10) --------------------------------------------------------
bool __cdecl sub_1004EA10(char a1, void *a2)
{
  memset(a2, 0, 0x2890u);
  return sub_1007C3B0((a1 != 36) + 6534, (int)a2, 10384) == 0;
}

//----- (1004EA50) --------------------------------------------------------
bool __cdecl sub_1004EA50(char a1, unsigned int *a2)
{
  bool v2; // bl@1

  v2 = sub_1004EA10(a1, &unk_10280020);
  if ( v2 )
    *a2 = sub_1007B8C0((unsigned int *)&unk_10280020, 10384, 0xFFFFFFFF);
  return v2;
}

//----- (1004EA90) --------------------------------------------------------
char __cdecl sub_1004EA90(char a1, void *a2)
{
  int v2; // esi@1
  void *v3; // ecx@1
  char result; // al@4
  char v5; // [sp+Ch] [bp-24h]@1
  int v6; // [sp+20h] [bp-10h]@2
  __int16 v7; // [sp+24h] [bp-Ch]@5
  int v8; // [sp+28h] [bp-8h]@5

  v2 = sub_1001D480(a1);
  j_HWM_pvg_hsdb_get_lrus_online();
  if ( sub_10024D10(1, 0x6ADu, (int)&v5) && v6 == v2 && sub_100253C0(1, 1709, a2) )
  {
    result = 1;
  }
  else
  {
    v8 = sub_100429D0(v3);
    v7 = 1709;
    sub_10024E60(1, 0, &v7, 0, 8, 1);
    sub_10025010(1, 0, v2);
    result = 0;
  }
  return result;
}
// 1007C810: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (1004EB50) --------------------------------------------------------
bool __cdecl sub_1004EB50(char a1, void *a2)
{
  int v2; // esi@1
  bool result; // al@5
  void *v4; // ecx@6
  int v5; // [sp+Ch] [bp-28h]@4
  char v6; // [sp+10h] [bp-24h]@2
  int v7; // [sp+24h] [bp-10h]@3
  __int16 v8; // [sp+28h] [bp-Ch]@8
  int v9; // [sp+2Ch] [bp-8h]@8

  v2 = sub_1001D480(a1);
  if ( (v2 & j_HWM_pvg_hsdb_get_lrus_online()) == v2
    && sub_10024D10(1, 0x6ACu, (int)&v6)
    && v7 == v2
    && sub_100253F0(1, 1708, a2, (int)&v5) )
  {
    result = 1;
  }
  else if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    result = sub_1004EA10(a1, a2);
  }
  else
  {
    v9 = sub_100429D0(v4);
    v8 = 1708;
    sub_10024E60(1, 0, &v8, 0, 8, 1);
    sub_10025010(1, 0, v2);
    result = 0;
  }
  return result;
}
// 1007C810: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1004EC40) --------------------------------------------------------
bool __cdecl sub_1004EC40(char a1, char a2, int a3, int a4, void *a5)
{
  bool result; // al@2

  if ( a2 )
    result = sub_1004EA10(a1, a5);
  else
    result = sub_1004EB50(a1, a5);
  return result;
}

//----- (1004EC70) --------------------------------------------------------
int __cdecl sub_1004EC70(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10043FF0(&a1, 1u, (int)&unk_101066D0, 8, 53, 67);
  if ( v1 == 67 )
    result = 0;
  else
    result = (int)*(&off_101066D4 + 2 * v1);
  return result;
}
// 101066D4: using guessed type void *off_101066D4;

//----- (1004ECB0) --------------------------------------------------------
char __cdecl sub_1004ECB0(char a1, char a2, __int16 a3)
{
  char v3; // bl@1
  int v4; // eax@1
  char result; // al@2
  char v6; // cl@3

  v3 = 3;
  v4 = sub_1004ECA0(a1);
  if ( v4 )
  {
    v6 = 0;
    do
    {
      if ( *(_BYTE *)v4 == a2 && *(_WORD *)(v4 + 2) == a3 )
        v3 = v6;
      ++v6;
      v4 += 4;
    }
    while ( (unsigned __int8)v6 < 3u );
    result = v3;
  }
  else
  {
    result = 3;
  }
  return result;
}
// 1004ECA0: using guessed type _DWORD __cdecl sub_1004ECA0(char);

//----- (1004ECF0) --------------------------------------------------------
char __cdecl sub_1004ECF0(char a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  int v4; // eax@1

  v4 = sub_1004ECA0(a1);
  if ( v4 && a2 < 3u )
  {
    *a3 = *(_BYTE *)(v4 + 4 * a2);
    *a4 = *(_WORD *)(v4 + 4 * a2 + 2);
  }
  return 0;
}
// 1004ECA0: using guessed type _DWORD __cdecl sub_1004ECA0(char);

//----- (1004ED30) --------------------------------------------------------
char __cdecl sub_1004ED30(void *a1)
{
  return sub_100253C0(1, 1314, a1);
}

//----- (1004ED50) --------------------------------------------------------
bool __thiscall sub_1004ED50(void *this)
{
  return (sub_100460A0(this) & 0x4000) == 0x4000;
}

//----- (1004ED70) --------------------------------------------------------
char sub_1004ED70()
{
  char v1; // [sp+4h] [bp-100h]@1

  memset(&v1, 0, 0xFCu);
  if ( sub_100253C0(1, 1309, &v1) )
    sub_1004D630((int)&v1);
  return 0;
}

//----- (1004EE10) --------------------------------------------------------
BOOL __cdecl sub_1004EE10(int a1, int a2)
{
  return sub_1007C3B0(6455, a2, 252) == 0;
}

//----- (1004EE30) --------------------------------------------------------
char __cdecl sub_1004EE30(int a1, unsigned int *a2)
{
  char v2; // bl@1
  char v4; // [sp+8h] [bp-100h]@1

  memset(&v4, 0, 0xFCu);
  v2 = sub_1004EE10(32, (int)&v4);
  if ( v2 )
    *a2 = sub_1007B8C0((unsigned int *)&v4, 252, 0xFFFFFFFF);
  return v2;
}

//----- (1004EEB0) --------------------------------------------------------
char __cdecl sub_1004EEB0(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1004EE10(a1, a5);
  }
  else
  {
    result = sub_1004ED70();
  }
  return result;
}

//----- (1004EEF0) --------------------------------------------------------
char __cdecl sub_1004EEF0(int a1, unsigned int *a2)
{
  int v2; // ecx@0
  char result; // al@3
  int v4; // [sp+0h] [bp-4h]@1

  v4 = v2;
  if ( j_HWM_pvg_read_reg(1) != 1 || j_HWM_pvg_hsdb_get_lrus_online() & 0x4000 )
  {
    result = sub_100253C0(1, 1310, &v4);
    if ( result )
      *a2 = v4;
  }
  else
  {
    result = sub_1004EE30(32, a2);
  }
  return result;
}
// 1007C810: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1004EF40) --------------------------------------------------------
char __cdecl sub_1004EF40(_BYTE *a1)
{
  unsigned int v1; // ecx@0
  char result; // al@3
  unsigned int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  if ( !sub_100253C0(2, 191, (char *)&v3 + 3) || sub_100689B0((unsigned __int8 *)&v3 + 3) )
  {
    result = 0;
  }
  else
  {
    result = 1;
    *a1 = BYTE3(v3);
  }
  return result;
}

//----- (1004EF80) --------------------------------------------------------
BOOL sub_1004EF80()
{
  char v1; // [sp+0h] [bp-78h]@1

  return sub_1003D2A0(69, &v1) && !strncmp(&v1, "006-B0756-", 0xAu);
}

//----- (1004EFE0) --------------------------------------------------------
bool __thiscall sub_1004EFE0(void *this)
{
  return (sub_100460A0(this) & 0x400) == 1024;
}

//----- (1004F000) --------------------------------------------------------
char __cdecl sub_1004F000(int a1, char *a2)
{
  char result; // al@5
  char v3; // [sp+13h] [bp-7Dh]@1
  char v4; // [sp+14h] [bp-7Ch]@1
  char v5; // [sp+15h] [bp-7Bh]@2
  int v6; // [sp+30h] [bp-60h]@2
  int v7; // [sp+34h] [bp-5Ch]@2
  int v8; // [sp+38h] [bp-58h]@2
  int v9; // [sp+3Ch] [bp-54h]@2
  int v10; // [sp+40h] [bp-50h]@2
  __int16 v11; // [sp+44h] [bp-4Ch]@2
  char v12; // [sp+46h] [bp-4Ah]@2
  char v13; // [sp+47h] [bp-49h]@2
  float v14; // [sp+48h] [bp-48h]@2
  char v15; // [sp+4Ch] [bp-44h]@2
  char v16; // [sp+4Dh] [bp-43h]@2
  char v17; // [sp+4Eh] [bp-42h]@2
  char v18; // [sp+50h] [bp-40h]@1

  memset(&v18, 0, 0x3Cu);
  v3 = sub_100253C0(1, 292, &v18);
  qmemcpy(&v4, &v18, 0x3Cu);
  if ( !(unsigned __int8)sub_1004EF80() )
  {
    v6 = -1;
    v14 = 77.166664;
    v7 = -1;
    v8 = -1;
    v9 = -1;
    v5 = 1;
    v12 = 0;
    v13 = 1;
    v4 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v10 = 0;
    v11 = 0;
  }
  if ( !v3 || sub_1004C850((int)&v4) )
  {
    result = 0;
  }
  else
  {
    result = 1;
    qmemcpy(a2, &v18, 0x3Cu);
  }
  return result;
}

//----- (1004F0F0) --------------------------------------------------------
BOOL __cdecl sub_1004F0F0(int a1, int a2)
{
  return sub_1007C3B0(6200, a2, 60) == 0;
}

//----- (1004F110) --------------------------------------------------------
__int16 sub_1004F110()
{
  __int16 result; // ax@2
  char v1; // [sp+4h] [bp-40h]@1
  __int16 v2; // [sp+6h] [bp-3Eh]@2

  if ( (unsigned __int8)sub_1004F0F0(19, (int)&v1) )
    result = v2;
  else
    result = 0;
  return result;
}

//----- (1004F160) --------------------------------------------------------
char __cdecl sub_1004F160(int a1, unsigned int *a2)
{
  char v2; // bl@1
  char v4; // [sp+8h] [bp-40h]@1

  memset(&v4, 0, 0x3Cu);
  v2 = sub_1004F0F0(19, (int)&v4);
  if ( v2 )
    *a2 = sub_1007B8C0((unsigned int *)&v4, 60, 0xFFFFFFFF);
  return v2;
}

//----- (1004F1C0) --------------------------------------------------------
BOOL sub_1004F1C0()
{
  char v0; // bl@1
  char v2; // [sp+4h] [bp-40h]@1
  char v3; // [sp+36h] [bp-Eh]@2

  v0 = 0;
  if ( (unsigned __int8)sub_1004F0F0(19, (int)&v2) )
    v0 = v3;
  return v0 == 1;
}

//----- (1004F200) --------------------------------------------------------
char __cdecl sub_1004F200(int a1, char a2, int a3, int a4, char *a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1004F0F0(a1, (int)a5);
  }
  else
  {
    result = sub_1004F000(a1, a5);
  }
  return result;
}

//----- (1004F240) --------------------------------------------------------
char __cdecl sub_1004F240(int a1, unsigned int *a2)
{
  int v2; // ecx@0
  char result; // al@3
  int v4; // [sp+0h] [bp-4h]@1

  v4 = v2;
  if ( j_HWM_pvg_read_reg(1) != 1 || j_HWM_pvg_hsdb_get_lrus_online() & 0x400 )
  {
    result = sub_100253C0(1, 293, &v4);
    if ( result )
      *a2 = v4;
  }
  else
  {
    result = sub_1004F160(19, a2);
  }
  return result;
}
// 1007C810: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1004F290) --------------------------------------------------------
char __cdecl sub_1004F290(char a1, _BYTE *a2, _BYTE *a3, char a4)
{
  _BYTE *v4; // eax@2

  if ( a1 == 1 )
  {
    v4 = a2;
    *v4 |= a4;
  }
  else
  {
    LOBYTE(v4) = a1 - 2;
    if ( a1 == 2 )
    {
      *a2 = a4;
      if ( a4 )
      {
        LOBYTE(v4) = *a3 == 0;
        *a2 = (_BYTE)v4;
      }
      else
      {
        LOBYTE(v4) = (_BYTE)a3;
        *a3 = 1;
      }
    }
  }
  return (unsigned int)v4;
}

//----- (1004F2D0) --------------------------------------------------------
char __thiscall sub_1004F2D0(void *this)
{
  char result; // al@2

  switch ( sub_100429D0(this) )
  {
    case 4:
    case 128:
      result = 1;
      break;
    case 2:
    case 16:
      result = 2;
      break;
    case 32:
      result = 3;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (1004F390) --------------------------------------------------------
void __usercall sub_1004F390(unsigned __int16 a1@<bx>, unsigned __int16 *a2@<edi>, int a3, int a4, char a5, int a6)
{
  int v6; // esi@2
  int v7; // eax@3

  if ( a2 )
  {
    v6 = 0;
    if ( *a2 < a1 )
    {
      v7 = (int)a2;
      do
      {
        if ( *(_WORD *)(a6 + 2 * *(_WORD *)v7) < a1 )
          sub_1004F290(
            *(_BYTE *)(v7 + 2),
            (_BYTE *)(a3 + *(_WORD *)(a6 + 2 * *(_WORD *)v7)),
            (_BYTE *)(*(_WORD *)v7 + a4),
            a5);
        v7 = (int)&a2[2 * ++v6];
      }
      while ( a2[2 * v6] < a1 );
    }
  }
}

//----- (1004F3F0) --------------------------------------------------------
char __cdecl sub_1004F3F0(unsigned __int8 a1)
{
  void *v1; // ecx@0
  char result; // al@2
  bool v3; // zf@3
  void *v4; // [sp-2h] [bp-4h]@1

  v4 = v1;
  BYTE3(v4) = 1;
  if ( sub_100460C0(v1) == 2 )
  {
    result = 1;
  }
  else
  {
    v3 = sub_1003DEA0(a1, (_BYTE *)&v4 + 3) == 1;
    result = 1;
    if ( v3 )
      result = BYTE3(v4);
  }
  return result;
}

//----- (1004F430) --------------------------------------------------------
char __usercall sub_1004F430@<al>(void *a1@<ecx>, int a2@<esi>)
{
  char v2; // bl@1
  char v3; // al@1

  v2 = 0;
  v3 = sub_100460C0(a1);
  if ( v3 == 2 || v3 == 4 )
  {
    if ( j_HWM_pvg_read_reg(1) )
    {
      v2 = 1;
      memset((void *)a2, 0, 0x74u);
      *(_DWORD *)(a2 + 108) = 5;
      *(_DWORD *)(a2 + 112) = 15;
    }
  }
  return v2;
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1004F470) --------------------------------------------------------
char __cdecl sub_1004F470(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // ebp@1
  int v6; // esi@1
  signed int v7; // edi@1
  void *v8; // eax@3
  __int16 v9; // cx@8
  __int16 v10; // cx@11
  __int16 v11; // cx@14
  __int16 v12; // cx@17
  int v13; // esi@23
  signed int v14; // edi@23
  void *v15; // eax@25
  __int16 v16; // cx@30
  __int16 v17; // cx@33
  __int16 v18; // cx@36
  __int16 v19; // cx@39
  void *v20; // ecx@45
  int v21; // eax@45
  char v22; // si@46
  signed int v23; // eax@46
  void *v24; // ecx@46
  int v25; // ST18_4@48
  int v26; // ST10_4@48
  unsigned __int16 *v27; // eax@48
  int v28; // ST18_4@48
  int v29; // ST10_4@48
  unsigned __int16 *v30; // eax@48
  int v31; // ecx@48
  int v32; // ST18_4@49
  int v33; // ST10_4@49
  unsigned __int16 *v34; // eax@49
  int v35; // ST18_4@51
  int v36; // ST10_4@51
  unsigned __int16 *v37; // eax@51
  unsigned __int8 v38; // al@52
  char v39; // bp@52
  signed int v40; // ecx@52
  char v41; // al@53
  int v42; // ST18_4@54
  int v43; // ST10_4@54
  int v44; // ST0C_4@54
  unsigned __int16 *v45; // eax@54
  char v46; // al@55
  int v47; // ST18_4@56
  int v48; // ST10_4@56
  int v49; // ST0C_4@56
  unsigned __int16 *v50; // eax@56
  signed int v51; // ebp@58
  char v52; // di@60
  unsigned __int8 v53; // al@60
  int v54; // ST18_4@60
  char v55; // ST14_1@60
  int v56; // ST10_4@60
  int v57; // ST0C_4@60
  unsigned __int16 *v58; // eax@60
  signed int v59; // edi@66
  void *v60; // ecx@66
  int i; // edi@67
  unsigned __int16 v62; // ax@68
  unsigned __int8 v63; // al@75
  char v64; // al@75
  int v65; // ST18_4@75
  char v66; // ST14_1@75
  int v67; // ST10_4@75
  unsigned __int16 *v68; // eax@75
  char result; // al@75
  char v70; // [sp+13h] [bp-49h]@62
  int v71; // [sp+14h] [bp-48h]@1
  int v72; // [sp+18h] [bp-44h]@1
  int v73; // [sp+1Ch] [bp-40h]@1
  int v74; // [sp+20h] [bp-3Ch]@1
  int v75; // [sp+24h] [bp-38h]@52
  unsigned __int16 v76; // [sp+28h] [bp-34h]@62
  int v77; // [sp+2Ch] [bp-30h]@1
  int v78; // [sp+30h] [bp-2Ch]@52
  int v79; // [sp+34h] [bp-28h]@45
  int v80; // [sp+38h] [bp-24h]@60
  int v81; // [sp+3Ch] [bp-20h]@1
  int v82; // [sp+40h] [bp-1Ch]@1
  int v83; // [sp+44h] [bp-18h]@1
  int v84; // [sp+48h] [bp-14h]@1
  int v85; // [sp+4Ch] [bp-10h]@1
  int v86; // [sp+50h] [bp-Ch]@1

  v5 = a3;
  v73 = a4;
  v74 = a3;
  v72 = a5;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v84 = 0;
  v85 = 0;
  v86 = 0;
  memset(word_10283350, 0, 0xFA0u);
  v6 = 0;
  v71 = -1;
  v77 = 0;
  v7 = 0;
  do
  {
    if ( sub_1007C3B0(v7 + 12000, (int)&unk_102842F0, 16004) )
    {
      v6 += 100;
    }
    else
    {
      v8 = &unk_1028437A;
      do
      {
        if ( *((char *)v8 - 136) && *(_WORD *)v8 )
        {
          word_10283350[v6] = *(_WORD *)v8;
          v71 = v6;
        }
        if ( *((_BYTE *)v8 + 24) )
        {
          v9 = *((_WORD *)v8 + 80);
          if ( v9 )
          {
            word_10283352[v6] = v9;
            v71 = v6 + 1;
          }
        }
        if ( *((_BYTE *)v8 + 184) )
        {
          v10 = *((_WORD *)v8 + 160);
          if ( v10 )
          {
            word_10283354[v6] = v10;
            v71 = v6 + 2;
          }
        }
        if ( *((_BYTE *)v8 + 344) )
        {
          v11 = *((_WORD *)v8 + 240);
          if ( v11 )
          {
            word_10283356[v6] = v11;
            v71 = v6 + 3;
          }
        }
        if ( *((_BYTE *)v8 + 504) )
        {
          v12 = *((_WORD *)v8 + 320);
          if ( v12 )
          {
            word_10283358[v6] = v12;
            v71 = v6 + 4;
          }
        }
        v8 = (char *)v8 + 800;
        v6 += 5;
      }
      while ( (signed int)v8 < (signed int)&unk_102881FA );
    }
    ++v7;
  }
  while ( v7 < 10 );
  v13 = 0;
  v14 = 0;
  do
  {
    if ( sub_1007C3B0(v14 + 14000, (int)&unk_102842F0, 16004) )
    {
      v13 += 100;
    }
    else
    {
      v15 = &unk_1028437A;
      do
      {
        if ( *((char *)v15 - 136) && *(_WORD *)v15 )
        {
          word_10283B20[v13] = *(_WORD *)v15;
          v71 = v13 + 1000;
        }
        if ( *((_BYTE *)v15 + 24) )
        {
          v16 = *((_WORD *)v15 + 80);
          if ( v16 )
          {
            word_10283B22[v13] = v16;
            v71 = v13 + 1001;
          }
        }
        if ( *((_BYTE *)v15 + 184) )
        {
          v17 = *((_WORD *)v15 + 160);
          if ( v17 )
          {
            word_10283B24[v13] = v17;
            v71 = v13 + 1002;
          }
        }
        if ( *((_BYTE *)v15 + 344) )
        {
          v18 = *((_WORD *)v15 + 240);
          if ( v18 )
          {
            word_10283B26[v13] = v18;
            v71 = v13 + 1003;
          }
        }
        if ( *((_BYTE *)v15 + 504) )
        {
          v19 = *((_WORD *)v15 + 320);
          if ( v19 )
          {
            word_10283B28[v13] = v19;
            v71 = v13 + 1004;
          }
        }
        v15 = (char *)v15 + 800;
        v13 += 5;
      }
      while ( (signed int)v15 < (signed int)&unk_102881FA );
    }
    ++v14;
  }
  while ( v14 < 10 );
  sub_100465E0((int)&v77);
  v21 = sub_100429D0(v20);
  v77 |= v21;
  LOBYTE(v79) = 0;
  do
  {
    v22 = v79;
    v23 = sub_10049CB0(v79);
    if ( v23 & v77 || sub_100460C0(v24) == 4 )
    {
      v25 = v72;
      v26 = v73;
      v27 = (unsigned __int16 *)sub_10068CC0(v22, a1);
      sub_1004F390(a2, v27, v5, v26, 1, v25);
      v28 = v72;
      v29 = v73;
      v30 = (unsigned __int16 *)sub_10068EA0(*(_BYTE *)dword_10337080, v22, a1);
      sub_1004F390(a2, v30, v5, v29, 1, v28);
      if ( (unsigned __int8)sub_100426B0(v31) )
      {
        v32 = v72;
        v33 = v73;
        v34 = (unsigned __int16 *)sub_10068C40(v22, a1);
        sub_1004F390(a2, v34, v5, v33, 1, v32);
      }
      if ( sub_100690D0() )
      {
        v35 = v72;
        v36 = v73;
        v37 = (unsigned __int16 *)sub_10068D40(v22, a1);
        sub_1004F390(a2, v37, v5, v36, 1, v35);
      }
      v38 = sub_10049BD0(v22);
      LOBYTE(v75) = sub_1004F3F0(v38);
      sub_10046510(v22, (int)&v81);
      v39 = v75;
      v40 = 0;
      v78 = 0;
      do
      {
        v41 = *((_BYTE *)&v84 + 4 * v40);
        if ( v41 )
        {
          v42 = v72;
          v43 = v73;
          v44 = v74;
          v45 = (unsigned __int16 *)sub_10069000(v22, v41, a1);
          sub_1004F390(a2, v45, v44, v43, v39, v42);
          v40 = v78;
        }
        v46 = *((_BYTE *)&v84 + 4 * v40 + 1);
        if ( v46 )
        {
          v47 = v72;
          v48 = v73;
          v49 = v74;
          v50 = (unsigned __int16 *)sub_10069000(v22, v46, a1);
          sub_1004F390(a2, v50, v49, v48, v39, v47);
          v40 = v78;
        }
        v78 = ++v40;
      }
      while ( v40 <= 1 );
      v51 = 0;
      do
      {
        if ( *((_BYTE *)&v82 + 4 * v51 + 1) )
        {
          LOBYTE(v80) = *((_BYTE *)&v82 + 4 * v51 + 1);
          v52 = v80;
          v53 = sub_1004A0C0(v80);
          LOBYTE(v75) = sub_1004F3F0(v53);
          v54 = v72;
          v55 = v75;
          v56 = v73;
          v57 = v74;
          v58 = (unsigned __int16 *)sub_10068F60(v22, v52, a1);
          sub_1004F390(a2, v58, v57, v56, v55, v54);
        }
        ++v51;
      }
      while ( v51 < 2 );
      if ( sub_10064360(HIWORD(v86), 0, &v70, &v76) == 1 && v70 == a1 && v76 < a2 )
        *(_BYTE *)(*(_WORD *)(v72 + 2 * v76) + v74) = v75;
      v59 = sub_10049CB0(v22);
      if ( sub_100429D0(v60) == v59 )
      {
        for ( i = 0; i <= v71; ++i )
        {
          v62 = word_10283350[i];
          if ( v62 && sub_100643C0(v62, 0, &v70, &v76) == 1 && v70 == a1 && v76 < a2 )
            *(_BYTE *)(*(_WORD *)(v72 + 2 * v76) + v74) = v75;
        }
      }
      v5 = v74;
    }
    v63 = sub_10049BD0(v22);
    v64 = sub_1004F3F0(v63);
    v65 = v72;
    LOBYTE(v75) = v64;
    v66 = v64;
    v67 = v73;
    v68 = (unsigned __int16 *)sub_10068DC0(v22, a1);
    sub_1004F390(a2, v68, v5, v67, v66, v65);
    result = v79 + 1;
    LOBYTE(v79) = v79 + 1;
  }
  while ( (unsigned __int8)v79 < 3u );
  return result;
}
// 10283350: using guessed type __int16 word_10283350[];
// 10283352: using guessed type __int16 word_10283352[];
// 10283354: using guessed type __int16 word_10283354[];
// 10283356: using guessed type __int16 word_10283356[];
// 10283358: using guessed type __int16 word_10283358[];
// 10283B20: using guessed type __int16 word_10283B20[];
// 10283B22: using guessed type __int16 word_10283B22[];
// 10283B24: using guessed type __int16 word_10283B24[];
// 10283B26: using guessed type __int16 word_10283B26[];
// 10283B28: using guessed type __int16 word_10283B28[];
// 10337080: using guessed type int dword_10337080;

//----- (1004F9F0) --------------------------------------------------------
void __cdecl sub_1004F9F0(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  char v5; // ST0C_1@2
  int *v6; // eax@2
  int v7; // [sp+0h] [bp-8h]@1
  int v8; // [sp+4h] [bp-4h]@1

  LOBYTE(v8) = sub_1004F3F0(0x1Fu);
  sub_100465E0((int)&v7);
  if ( v7 & 0x8000 )
  {
    v5 = v8;
    v6 = sub_100693C0(a1);
    sub_1004F390(a2, (unsigned __int16 *)v6, a3, a4, v5, a5);
  }
}

//----- (1004FA50) --------------------------------------------------------
void __cdecl sub_1004FA50(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  void *v5; // ecx@0
  char v6; // ST0C_1@2
  unsigned __int16 *v7; // eax@2

  if ( sub_10069420(v5) )
  {
    v6 = sub_1004F3F0(0x11u);
    v7 = (unsigned __int16 *)sub_100690E0(a1);
    sub_1004F390(a2, v7, a3, a4, v6, a5);
  }
}

//----- (1004FAA0) --------------------------------------------------------
void __cdecl sub_1004FAA0(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // ecx@0
  void *v6; // ecx@1
  bool v7; // al@5
  char v8; // ST0C_1@7
  unsigned __int16 *v9; // eax@7
  int v10; // [sp+0h] [bp-4h]@1

  v10 = v5;
  sub_100465E0((int)&v10);
  if ( v10 & 0x1000000 || sub_100460C0(v6) == 4 )
  {
    v7 = sub_1004F3F0(0x32u) && sub_1004F3F0(0x3Eu);
    v8 = v7;
    v9 = (unsigned __int16 *)sub_10069440(a1);
    sub_1004F390(a2, v9, a3, a4, v8, a5);
  }
}

//----- (1004FB20) --------------------------------------------------------
char __cdecl sub_1004FB20(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  char v6; // bp@3
  signed int v7; // eax@3
  void *v8; // ecx@3
  unsigned __int8 v9; // al@6
  char v10; // ST18_1@6
  int v11; // ST14_4@6
  unsigned __int16 *v12; // eax@6
  int v13; // ecx@6
  char v14; // ST18_1@7
  int v15; // ST14_4@7
  unsigned __int16 *v16; // eax@7
  char v17; // ST18_1@7
  int v18; // ST14_4@7
  unsigned __int16 *v19; // eax@7
  int v20; // eax@8
  void *v21; // ecx@8
  char v22; // al@9
  char v23; // al@12
  char v24; // ST18_1@14
  int v25; // ST14_4@14
  unsigned __int16 *v26; // eax@14
  unsigned __int16 *v27; // eax@17
  char v28; // al@22
  char v29; // ST18_1@24
  int v30; // ST14_4@24
  unsigned __int16 *v31; // eax@24
  char v32; // ST18_1@25
  int v33; // ST14_4@25
  unsigned __int16 *v34; // eax@25
  signed int v35; // ecx@25
  unsigned __int8 v36; // al@26
  char v37; // ST18_1@27
  int v38; // ST14_4@27
  unsigned __int16 *v39; // eax@27
  signed int v40; // eax@29
  char v41; // ST18_1@31
  int v42; // ST14_4@31
  unsigned __int16 *v43; // eax@31
  unsigned __int16 *v44; // edi@33
  unsigned __int16 *v45; // edi@39
  __int16 *v46; // ecx@45
  char v47; // ST18_1@48
  int v48; // ST14_4@48
  unsigned __int16 *v49; // eax@48
  unsigned __int8 v50; // al@49
  char v51; // ST18_1@52
  int v52; // ST14_4@52
  unsigned __int16 *v53; // eax@52
  __int16 *v54; // eax@55
  int v55; // edi@55
  bool v56; // cf@55
  int v57; // eax@57
  _BYTE *v58; // esi@61
  unsigned __int8 v59; // di@62
  unsigned __int8 v60; // al@62
  char v61; // ST18_1@62
  int v62; // ST14_4@62
  int v63; // ST10_4@62
  unsigned __int16 *v64; // eax@62
  _BYTE *v65; // esi@63
  unsigned __int8 v66; // di@64
  unsigned __int8 v67; // al@64
  char v68; // ST18_1@64
  int v69; // ST14_4@64
  int v70; // ST10_4@64
  unsigned __int16 *v71; // eax@64
  unsigned __int8 v72; // di@65
  unsigned __int8 v73; // al@65
  char v74; // ST18_1@65
  int v75; // ST14_4@65
  int v76; // ST10_4@65
  unsigned __int16 *v77; // eax@65
  char *v78; // eax@67
  unsigned __int8 v79; // di@68
  unsigned __int8 v80; // al@68
  char v81; // al@68
  int v82; // esi@72
  char v83; // ST18_1@72
  int v84; // ST14_4@72
  int v85; // ST10_4@72
  unsigned __int16 *v86; // eax@72
  unsigned __int8 v87; // di@73
  unsigned __int8 v88; // al@73
  char v89; // al@73
  char v90; // ST18_1@77
  int v91; // ST14_4@77
  unsigned __int16 *v92; // eax@77
  char result; // al@79
  int v94; // [sp-10h] [bp-D8h]@17
  int v95; // [sp-Ch] [bp-D4h]@17
  char v96; // [sp-8h] [bp-D0h]@17
  int v97; // [sp-4h] [bp-CCh]@17
  char v98; // [sp+17h] [bp-B1h]@1
  int v99; // [sp+18h] [bp-B0h]@12
  int v100; // [sp+1Ch] [bp-ACh]@6
  int v101; // [sp+20h] [bp-A8h]@1
  int v102; // [sp+24h] [bp-A4h]@25
  __int16 *v103; // [sp+28h] [bp-A0h]@45
  int v104; // [sp+2Ch] [bp-9Ch]@1
  int v105; // [sp+30h] [bp-98h]@1
  unsigned int v106; // [sp+34h] [bp-94h]@68
  unsigned int v107; // [sp+38h] [bp-90h]@64
  unsigned __int8 *v108; // [sp+3Ch] [bp-8Ch]@1
  unsigned __int16 v109[2]; // [sp+40h] [bp-88h]@56
  int v110; // [sp+44h] [bp-84h]@1
  int v111; // [sp+48h] [bp-80h]@1
  unsigned int v112; // [sp+4Ch] [bp-7Ch]@62
  char v113; // [sp+50h] [bp-78h]@1
  unsigned int v114; // [sp+BCh] [bp-Ch]@16
  char v115; // [sp+C0h] [bp-8h]@10

  v5 = a3;
  v101 = a4;
  v104 = a3;
  v98 = 0;
  v111 = 0;
  v105 = 0;
  memset(&v113, 0, 0x74u);
  sub_100465E0((int)&v111);
  LOBYTE(v110) = 0;
  v108 = (unsigned __int8 *)":#;<";
  while ( 1 )
  {
    v6 = v110;
    v7 = sub_100627A0(v110);
    if ( !(v7 & v111) )
    {
      if ( sub_100460C0(v8) != 4 )
        goto LABEL_79;
      v5 = v104;
    }
    v9 = sub_10062760(v6);
    LOBYTE(v100) = sub_1004F3F0(v9);
    memset(byte_102828B0, 0, 0xAA0u);
    sub_10046530(v6, (int)byte_102828B0);
    v10 = v100;
    v11 = v101;
    v12 = (unsigned __int16 *)sub_10069BA0(v6, a1);
    sub_1004F390(a2, v12, v5, v11, v10, a5);
    if ( (unsigned __int8)sub_100426B0(v13) )
    {
      v14 = v100;
      v15 = v101;
      v16 = (unsigned __int16 *)sub_10069FB0(v6, a1);
      sub_1004F390(a2, v16, v5, v15, v14, a5);
      v17 = v100;
      v18 = v101;
      v19 = (unsigned __int16 *)sub_10069F90(v6, a1);
      sub_1004F390(a2, v19, v5, v18, v17, a5);
    }
    LOBYTE(v20) = sub_100627E0(v6);
    if ( sub_1003D2A0(v20, &v113) || (v22 = sub_1004F430(v21, (int)&v113), v5 = v104, v22) )
    {
      if ( v115 & 1 )
      {
        if ( !(_BYTE)v100 || (v23 = sub_1004F3F0(*(v108 - 1)), LOBYTE(v99) = 1, !v23) )
          LOBYTE(v99) = 0;
        v24 = v99;
        v25 = v101;
        v26 = (unsigned __int16 *)sub_10069A80(v6, a1);
        sub_1004F390(a2, v26, v5, v25, v24, a5);
      }
      if ( v115 & 2 )
      {
        if ( v114 >= 3 )
        {
          v97 = a5;
          v96 = v100;
          v95 = v101;
          v94 = v5;
          v27 = (unsigned __int16 *)sub_10069E60(v6, a1);
        }
        else
        {
          v97 = a5;
          v96 = v100;
          v95 = v101;
          v94 = v5;
          v27 = (unsigned __int16 *)sub_10069B10(v6, a1);
        }
        sub_1004F390(a2, v27, v94, v95, v96, v97);
      }
      if ( v115 & 8 )
      {
        if ( !(_BYTE)v100 || (v28 = sub_1004F3F0(*v108), LOBYTE(v99) = 1, !v28) )
          LOBYTE(v99) = 0;
        v29 = v99;
        v30 = v101;
        v31 = (unsigned __int16 *)sub_10069DD0(v6, a1);
        sub_1004F390(a2, v31, v5, v30, v29, a5);
      }
    }
    v32 = v100;
    v33 = v101;
    v34 = (unsigned __int16 *)sub_100699B0(v6, byte_10282D7C, a1);
    sub_1004F390(a2, v34, v5, v33, v32, a5);
    v102 = 0;
    v35 = 0;
    do
    {
      v36 = byte_102828B0[v35];
      if ( v36 )
      {
        v37 = v100;
        v38 = v101;
        v39 = (unsigned __int16 *)sub_10069570(v6, v102, v36, a1);
        sub_1004F390(a2, v39, v5, v38, v37, a5);
        v35 = v102;
      }
      v102 = ++v35;
    }
    while ( v35 < 10 );
    v40 = 0;
    v102 = 0;
    do
    {
      if ( byte_102828BA[v40] == 1 )
      {
        v41 = v100;
        v42 = v101;
        v43 = (unsigned __int16 *)sub_10069810(v6, v102, a1);
        sub_1004F390(a2, v43, v5, v42, v41, a5);
        v40 = v102;
      }
      v102 = ++v40;
    }
    while ( v40 < 11 );
    v44 = (unsigned __int16 *)&unk_102828F6;
    do
    {
      if ( sub_10064360(*v44, v6, &v98, &v105) == 1 && v98 == a1 && (unsigned __int16)v105 < a2 )
        *(_BYTE *)(*(_WORD *)(a5 + 2 * (unsigned __int16)v105) + v5) = v100;
      v44 += 6;
    }
    while ( (signed int)v44 < (signed int)&unk_10282AE2 );
    v45 = (unsigned __int16 *)&unk_10282AE2;
    do
    {
      if ( sub_100643C0(*v45, v6, &v98, &v105) == 1 && v98 == a1 && (unsigned __int16)v105 < a2 )
        *(_BYTE *)(*(_WORD *)(a5 + 2 * (unsigned __int16)v105) + v5) = v100;
      v45 += 2;
    }
    while ( (signed int)v45 < (signed int)&unk_10282B8A );
    v46 = (__int16 *)&unk_10282BD0;
    v102 = 0;
    v103 = (__int16 *)&unk_10282BD0;
    do
    {
      if ( *(_BYTE *)v46 == 3 )
      {
        LOWORD(v102) = v46[1] | v102;
      }
      else
      {
        v47 = v100;
        v48 = v101;
        v49 = (unsigned __int16 *)sub_100698E0(v6, *(_BYTE *)v46, a1);
        sub_1004F390(a2, v49, v5, v48, v47, a5);
        v46 = v103;
      }
      v50 = *((_BYTE *)v46 + 1);
      if ( v50 != *(_BYTE *)v46 )
      {
        if ( v50 == 3 )
        {
          LOWORD(v102) = v46[1] | v102;
        }
        else
        {
          v51 = v100;
          v52 = v101;
          v53 = (unsigned __int16 *)sub_100698E0(v6, v50, a1);
          sub_1004F390(a2, v53, v5, v52, v51, a5);
          v46 = v103;
        }
      }
      v46 += 8;
      v103 = v46;
    }
    while ( (signed int)v46 < (signed int)&unk_10282BF0 );
    if ( (_WORD)v102 )
    {
      v54 = (__int16 *)sub_100698E0(v6, 3u, a1);
      v55 = 0;
      v56 = (unsigned __int16)*v54 < a2;
      v103 = v54;
      if ( v56 )
      {
        do
        {
          v105 = (unsigned __int16)*v54;
          if ( !sub_10062F30(a1, *v54, v109)
            || (v57 = sub_10043FF0((_DWORD *)v109, 2u, (int)"<", 4, 12, 12), v57 >= 12)
            || ((unsigned __int16)v102 & (unsigned __int16)word_10108A86[2 * v57]) != 0 )
          {
            *(_BYTE *)(*(_WORD *)(a5 + 2 * (unsigned __int16)v105) + v5) = v100;
          }
          v54 = &v103[2 * ++v55];
        }
        while ( (unsigned __int16)v103[2 * v55] < a2 );
      }
    }
    v58 = &unk_102828C9;
    do
    {
      LOBYTE(v112) = *v58;
      v59 = v112;
      v60 = sub_100628C0(v112);
      LOBYTE(v99) = sub_1004F3F0(v60);
      v61 = v99;
      v62 = v101;
      v63 = v104;
      v64 = (unsigned __int16 *)sub_100694A0(v6, v59, a1);
      sub_1004F390(a2, v64, v63, v62, v61, a5);
      v58 += 4;
    }
    while ( (signed int)v58 <= (signed int)&unk_102828F1 );
    v65 = &unk_10282B89;
    do
    {
      LOBYTE(v107) = *(v65 - 1);
      v66 = v107;
      v67 = sub_100628F0(v107);
      LOBYTE(v99) = sub_1004F3F0(v67);
      v68 = v99;
      v69 = v101;
      v70 = v104;
      v71 = (unsigned __int16 *)sub_10069C30(v6, v66, a1);
      sub_1004F390(a2, v71, v70, v69, v68, a5);
      if ( (_BYTE)v107 != *v65 )
      {
        LOBYTE(v107) = *v65;
        v72 = v107;
        v73 = sub_100628F0(v107);
        LOBYTE(v99) = sub_1004F3F0(v73);
        v74 = v99;
        v75 = v101;
        v76 = v104;
        v77 = (unsigned __int16 *)sub_10069C30(v6, v72, a1);
        sub_1004F390(a2, v77, v76, v75, v74, a5);
      }
      v65 += 4;
    }
    while ( (signed int)v65 < (signed int)&unk_10282BA9 );
    v78 = (char *)&unk_10282BA9;
    v103 = (__int16 *)&unk_10282BA9;
    do
    {
      LOBYTE(v106) = *(v78 - 1);
      v79 = v106;
      v80 = sub_10062920(v106);
      v81 = sub_1004F3F0(v80);
      LOBYTE(v99) = v81;
      if ( (_BYTE)v106 == 4 )
      {
        if ( !(_BYTE)v100 || (LOBYTE(v99) = 1, !v81) )
          LOBYTE(v99) = 0;
      }
      v82 = v104;
      v83 = v99;
      v84 = v101;
      v85 = v104;
      v86 = (unsigned __int16 *)sub_10069D00(v6, v79, a1);
      sub_1004F390(a2, v86, v85, v84, v83, a5);
      if ( (_BYTE)v106 != *(_BYTE *)v103 )
      {
        LOBYTE(v106) = *(_BYTE *)v103;
        v87 = v106;
        v88 = sub_10062920(v106);
        v89 = sub_1004F3F0(v88);
        LOBYTE(v99) = v89;
        if ( (_BYTE)v106 == 4 )
        {
          if ( !(_BYTE)v100 || (LOBYTE(v99) = 1, !v89) )
            LOBYTE(v99) = 0;
        }
        v90 = v99;
        v91 = v101;
        v92 = (unsigned __int16 *)sub_10069D00(v6, v87, a1);
        sub_1004F390(a2, v92, v82, v91, v90, a5);
      }
      v78 = (char *)(v103 + 4);
      v103 += 4;
    }
    while ( (signed int)v103 < (signed int)&unk_10282BD1 );
LABEL_79:
    v108 += 2;
    result = v110 + 1;
    LOBYTE(v110) = v110 + 1;
    if ( (unsigned __int8)v110 >= 2u )
      return result;
    v5 = v104;
  }
}
// 10108A86: using guessed type __int16 word_10108A86[];
// 10282D7C: using guessed type char byte_10282D7C;

//----- (100502D0) --------------------------------------------------------
void __cdecl sub_100502D0(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  void *v5; // ecx@1
  void *v6; // ecx@2
  bool v7; // al@5
  char v8; // ST0C_1@7
  unsigned __int16 *v9; // eax@7
  bool v10; // al@12
  char v11; // ST0C_1@14
  unsigned __int16 *v12; // eax@14
  int v13; // [sp+10h] [bp-4h]@1

  sub_100465E0((int)&v13);
  if ( v13 & 0x10000 || sub_100460C0(v5) == 4 )
  {
    v7 = sub_1004F3F0(0x24u) && sub_1004F3F0(0x3Cu);
    v8 = v7;
    v9 = (unsigned __int16 *)sub_10069FD0(a1);
    sub_1004F390(a2, v9, a3, a4, v8, a5);
  }
  if ( v13 & 0x20000 || sub_100460C0(v6) == 4 )
  {
    v10 = sub_1004F3F0(0x25u) && sub_1004F3F0(0x3Du);
    v11 = v10;
    v12 = (unsigned __int16 *)sub_10069FD0(a1);
    sub_1004F390(a2, v12, a3, a4, v11, a5);
  }
}

//----- (100503B0) --------------------------------------------------------
char __cdecl sub_100503B0(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // eax@2
  void *v6; // ecx@2
  unsigned __int8 v7; // al@4
  char v8; // ST10_1@4
  unsigned __int16 *v9; // eax@4
  char result; // al@5
  unsigned __int8 v11; // [sp+10h] [bp-8h]@1
  int v12; // [sp+14h] [bp-4h]@1

  sub_100465E0((int)&v12);
  v11 = 0;
  do
  {
    v5 = sub_1006A0B0(v11);
    if ( v5 & v12 || sub_100460C0(v6) == 4 )
    {
      v7 = sub_10062FB0(v11);
      v8 = sub_1004F3F0(v7);
      v9 = (unsigned __int16 *)sub_1006A030(v11, a1);
      sub_1004F390(a2, v9, a3, a4, v8, a5);
    }
    result = v11++ + 1;
  }
  while ( v11 < 2u );
  return result;
}

//----- (10050440) --------------------------------------------------------
char __cdecl sub_10050440(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  char v5; // si@2
  signed int v6; // eax@2
  unsigned __int8 v7; // al@3
  char v8; // ST14_1@3
  unsigned __int16 *v9; // eax@3
  int v10; // ecx@3
  char v11; // ST14_1@4
  unsigned __int16 *v12; // eax@4
  unsigned __int16 *v13; // edi@5
  unsigned __int16 *v14; // eax@12
  unsigned __int16 *v15; // eax@14
  unsigned __int8 v16; // al@14
  unsigned __int16 *v17; // eax@15
  char result; // al@17
  char v19; // [sp+13h] [bp-1Dh]@6
  unsigned __int16 v20; // [sp+14h] [bp-1Ch]@6
  int v21; // [sp+18h] [bp-18h]@14
  unsigned __int8 *v22; // [sp+1Ch] [bp-14h]@11
  int v23; // [sp+20h] [bp-10h]@3
  int v24; // [sp+24h] [bp-Ch]@1
  int v25; // [sp+28h] [bp-8h]@1
  int v26; // [sp+2Ch] [bp-4h]@12

  sub_100465E0((int)&v25);
  LOBYTE(v24) = 0;
  do
  {
    v5 = v24;
    v6 = sub_1006A440(v24);
    if ( v6 & v25 )
    {
      memset(&unk_10288178, 0, 0x890u);
      sub_100465B0(v5, (int)&unk_10288178);
      v7 = sub_1006A400(v5);
      LOBYTE(v23) = sub_1004F3F0(v7);
      v8 = v23;
      v9 = (unsigned __int16 *)sub_1006A1A0(v5, a1);
      sub_1004F390(a2, v9, a3, a4, v8, a5);
      if ( (unsigned __int8)sub_100426B0(v10) )
      {
        v11 = v23;
        v12 = (unsigned __int16 *)sub_1006A3A0(v5, a1);
        sub_1004F390(a2, v12, a3, a4, v11, a5);
      }
      v13 = (unsigned __int16 *)&unk_1028821A;
      do
      {
        if ( sub_10064360(*v13, v5, &v19, &v20) == 1 && v19 == a1 && v20 < a2 )
          *(_BYTE *)(*(_WORD *)(a5 + 2 * v20) + a3) = v23;
        v13 += 8;
      }
      while ( (signed int)v13 < (signed int)&unk_102884EA );
      v22 = (unsigned __int8 *)&unk_10288179;
      do
      {
        LOBYTE(v26) = *v22;
        v14 = (unsigned __int16 *)sub_1006A0D0(v5, v26, a1);
        sub_1004F390(a2, v14, a3, a4, 1, a5);
        v22 += 4;
      }
      while ( (signed int)v22 <= (signed int)&unk_10288215 );
      v22 = (unsigned __int8 *)&unk_102884E9;
      do
      {
        LOBYTE(v21) = *(v22 - 1);
        v15 = (unsigned __int16 *)sub_1006A230(v5, v21, a1);
        sub_1004F390(a2, v15, a3, a4, 1, a5);
        v16 = *v22;
        if ( (_BYTE)v21 != *v22 )
        {
          LOBYTE(v21) = *v22;
          v17 = (unsigned __int16 *)sub_1006A230(v5, v16, a1);
          sub_1004F390(a2, v17, a3, a4, 1, a5);
        }
        v22 += 8;
      }
      while ( (signed int)v22 < (signed int)&unk_10288569 );
    }
    result = v24 + 1;
    LOBYTE(v24) = v24 + 1;
  }
  while ( (unsigned __int8)v24 < 3u );
  return result;
}

//----- (10050650) --------------------------------------------------------
char __cdecl sub_10050650(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  void *v5; // ecx@1
  int v6; // eax@1
  void *v7; // ecx@1
  signed int v8; // eax@2
  void *v9; // ecx@2
  void *v10; // ecx@3
  unsigned __int8 v11; // al@4
  unsigned __int16 *v12; // eax@4
  char v13; // ST10_1@4
  unsigned __int16 *v14; // eax@4
  __int16 *v15; // eax@4
  int v16; // ecx@4
  unsigned __int16 *v17; // eax@5
  unsigned __int16 *v18; // eax@7
  int v19; // eax@9
  char v21; // [sp+13h] [bp-Dh]@1
  char v22; // [sp+14h] [bp-Ch]@1
  int v23; // [sp+18h] [bp-8h]@1
  int v24; // [sp+1Ch] [bp-4h]@4

  sub_100465E0((int)&v23);
  v6 = sub_100429D0(v5);
  v23 |= v6;
  v21 = sub_100460C0(v7);
  v22 = 3;
  do
  {
    v8 = sub_10049CB0(v22);
    if ( v8 & v23 || sub_100460C0(v9) == 4 )
    {
      v11 = sub_10049BD0(v22);
      LOBYTE(v24) = sub_1004F3F0(v11);
      v12 = (unsigned __int16 *)sub_1006A4F0(a1);
      sub_1004F390(a2, v12, a3, a4, 1, a5);
      v13 = v24;
      v14 = (unsigned __int16 *)sub_1006A5B0(v22, a1);
      sub_1004F390(a2, v14, a3, a4, v13, a5);
      v15 = sub_100689D0(a1, a2);
      sub_1004F390(a2, (unsigned __int16 *)v15, a3, a4, 1, a5);
      if ( (unsigned __int8)sub_100426B0(v16) )
      {
        v17 = (unsigned __int16 *)sub_1006A490(a1);
        sub_1004F390(a2, v17, a3, a4, 1, a5);
      }
      if ( sub_100690D0() )
      {
        v18 = (unsigned __int16 *)sub_1006A550(a1);
        sub_1004F390(a2, v18, a3, a4, 1, a5);
      }
    }
    ++v22;
  }
  while ( (unsigned __int8)v22 < 7u );
  LOBYTE(v19) = v21;
  if ( v21 == 2 || v21 == 8 )
  {
    LOBYTE(v19) = a1;
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        LOBYTE(v19) = sub_100429D0(v10);
        if ( v19 & 0xF0 )
        {
          *(_BYTE *)(*(_WORD *)(a5 + 492) + a3) = 1;
          *(_BYTE *)(*(_WORD *)(a5 + 496) + a3) = 1;
          v19 = *(_WORD *)(a5 + 494);
          *(_BYTE *)(v19 + a3) = 1;
        }
      }
    }
    else
    {
      *(_BYTE *)(*(_WORD *)(a5 + 980) + a3) = 1;
      *(_BYTE *)(*(_WORD *)(a5 + 982) + a3) = 1;
      *(_BYTE *)(*(_WORD *)(a5 + 1178) + a3) = 1;
      v19 = *(_WORD *)(a5 + 1180);
      *(_BYTE *)(v19 + a3) = 1;
    }
  }
  else if ( !a1 )
  {
    *(_BYTE *)(*(_WORD *)(a5 + 980) + a3) = sub_1004F3F0(0x28u);
    *(_BYTE *)(*(_WORD *)(a5 + 982) + a3) = sub_1004F3F0(0x29u);
    *(_BYTE *)(*(_WORD *)(a5 + 1178) + a3) = sub_1004F3F0(0x33u);
    LOBYTE(v19) = sub_1004F3F0(0x34u);
    *(_BYTE *)(*(_WORD *)(a5 + 1180) + a3) = v19;
  }
  return v19;
}

//----- (10050870) --------------------------------------------------------
void __cdecl sub_10050870(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // ecx@0
  void *v6; // ecx@1
  char v7; // ST0C_1@3
  unsigned __int16 *v8; // eax@3
  int v9; // [sp+0h] [bp-4h]@1

  v9 = v5;
  sub_100465E0((int)&v9);
  if ( v9 & 0x4000 || sub_100460C0(v6) == 4 )
  {
    v7 = sub_1004F3F0(0x20u);
    v8 = (unsigned __int16 *)sub_1006A650(a1);
    sub_1004F390(a2, v8, a3, a4, v7, a5);
  }
}

//----- (100508D0) --------------------------------------------------------
void __cdecl sub_100508D0(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // ecx@0
  void *v6; // ecx@1
  char v7; // ST0C_1@3
  unsigned __int16 *v8; // eax@3
  int v9; // [sp+0h] [bp-4h]@1

  v9 = v5;
  sub_100465E0((int)&v9);
  if ( v9 & 0x400 || sub_100460C0(v6) == 4 )
  {
    v7 = sub_1004F3F0(0x13u);
    v8 = (unsigned __int16 *)sub_1006A6B0(a1);
    sub_1004F390(a2, v8, a3, a4, v7, a5);
  }
}

//----- (10050930) --------------------------------------------------------
void *__usercall sub_10050930@<eax>(void *a1@<ebx>, const void *a2@<edi>, int a3@<esi>, int a4)
{
  void *result; // eax@1
  int v5; // [sp+0h] [bp-Ch]@0
  int v6; // [sp+4h] [bp-8h]@0

  result = (void *)sub_1007C3B0(a4, v5, v6);
  if ( result )
  {
    sub_1007C500(a4, (int)a2, a3);
    result = memcpy(a1, a2, (unsigned __int16)a3);
  }
  return result;
}

//----- (10050960) --------------------------------------------------------
char __cdecl sub_10050960(unsigned __int8 a1)
{
  char result; // al@2
  char v2[60]; // [sp+0h] [bp-40h]@3

  if ( a1 < 0x3Cu )
  {
    sub_10050930(v2, &unk_10108B10, 60, 2116);
    result = v2[a1];
  }
  else
  {
    result = 1;
  }
  return result;
}
// 10050960: using guessed type char var_40[60];

//----- (100509C0) --------------------------------------------------------
char sub_100509C0()
{
  char v1; // [sp+Fh] [bp-1h]@1

  sub_10050930(&v1, &unk_10108AE2, 1, 2119);
  return v1;
}

//----- (100509F0) --------------------------------------------------------
double __cdecl sub_100509F0(int a1)
{
  double v1; // st6@1

  v1 = (double)(unsigned int)((*(int (**)(void))(dword_103334E8 + 8))() - a1);
  return (float)(1.0 / (double)(*(int (**)(void))(dword_103334E8 + 12))() * v1);
}
// 103334E8: using guessed type int dword_103334E8;

//----- (10050A40) --------------------------------------------------------
unsigned int __cdecl sub_10050A40(unsigned int a1)
{
  unsigned int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = a1 & 0xFFFFFFFC;
  else
    result = 0;
  return result;
}

//----- (10050A60) --------------------------------------------------------
int __cdecl sub_10050A60(int a1)
{
  return a1 | 1;
}

//----- (10050A70) --------------------------------------------------------
bool __cdecl sub_10050A70(int a1)
{
  bool result; // al@1
  unsigned int v2; // eax@4
  _DWORD *v3; // edx@4
  _DWORD *v4; // esi@4
  int v5; // ecx@8
  int v6; // eax@9
  _BYTE *v7; // edx@9
  _BYTE *v8; // esi@9
  int v9; // eax@11
  _BYTE *v10; // edx@11
  _BYTE *v11; // esi@11
  _BYTE *v12; // edx@13
  _BYTE *v13; // esi@13
  int v14; // edx@14
  signed int v15; // eax@15

  result = *(_DWORD *)(a1 + 88) == ~*(_DWORD *)(a1 + 36);
  if ( *(_WORD *)(a1 + 30) != 99 || !result && *(_WORD *)(a1 + 684) != 2 )
    return result;
  v2 = 10;
  v3 = (_DWORD *)(a1 + 693);
  v4 = (_DWORD *)(a1 + 721);
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_8;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_17:
    v15 = 0;
    return v15 == 0;
  }
LABEL_8:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_17;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_17;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_17;
        v14 = *v12;
        v5 = *v13 - v14;
        if ( *v13 == v14 )
          goto LABEL_17;
      }
    }
  }
  v15 = 1;
  if ( v5 <= 0 )
    return 0;
  return v15 == 0;
}

//----- (10050B40) --------------------------------------------------------
int __cdecl sub_10050B40(int a1)
{
  return *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 32) + *(_WORD *)(a1 + 28) + 46;
}

//----- (10050B60) --------------------------------------------------------
int __cdecl sub_10050B60(int a1, int a2)
{
  int result; // eax@2

  if ( a2 )
    result = *(_WORD *)(a2 + 28) + *(_WORD *)(a2 + 26) + 30;
  else
    result = -16 - *(_WORD *)(a1 + 52) + sub_10050B40(a1 + 20);
  return result;
}

//----- (10050BA0) --------------------------------------------------------
bool __cdecl sub_10050BA0(int a1)
{
  unsigned int v1; // esi@2
  unsigned int v2; // ecx@5
  bool result; // al@11

  result = a1
        && (v1 = *(_DWORD *)(a1 + 116), v1 < 0xFFFFFFC2)
        && v1
        && *(_DWORD *)a1 != -1
        && ((v2 = *(_DWORD *)(a1 + 120), *(_DWORD *)a1 + 22 <= v2)
         && *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 20) + 22 <= v2
         || !v2
         || *(_DWORD *)(a1 + 4) != v1)
        && *(_DWORD *)(a1 + 8) == 101010256
        && *(_WORD *)(a1 + 14) == *(_WORD *)(a1 + 12);
  return result;
}

//----- (10050C00) --------------------------------------------------------
signed int __cdecl sub_10050C00(int a1, void *a2, unsigned __int16 a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // ebp@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 732);
  v6 = 0;
  result = -15;
  v8 = *(_WORD *)(a1 + 48) + *(_DWORD *)(a1 + 16) + 46;
  if ( *(_WORD *)(a1 + 50) >= 4u )
  {
    while ( (unsigned int)(v6 + v8) < *(_DWORD *)(v5 + 120) )
    {
      if ( sub_1007CF10(*(_DWORD *)(v5 + 4), &a1, 4, v6 + v8, 0) != 4 )
        return -15;
      if ( (_WORD)a1 == a4 && (unsigned int)HIWORD(a1) + 4 <= a3 )
        return sub_1007CF10(*(_DWORD *)(v5 + 4), a2, HIWORD(a1) + 4, v6 + v8, 0);
      v6 += HIWORD(a1) + 4;
      result = -15;
      if ( v6 + 4 > (unsigned int)*(_WORD *)(v4 + 50) )
        return result;
    }
  }
  return result;
}

//----- (10050CC0) --------------------------------------------------------
signed int __cdecl sub_10050CC0(int a1, int a2, int a3)
{
  int v3; // esi@3
  signed int result; // eax@9

  if ( sub_1007CF10(*(_DWORD *)(a1 + 116), (void *)a3, 30, *(_DWORD *)(a2 + 42), 0) != 30 )
    goto LABEL_13;
  if ( *(_BYTE *)(a2 + 8) & 8 )
  {
    v3 = *(_DWORD *)(a2 + 42) + *(_DWORD *)(a2 + 20) + sub_10050B60(0, a3);
    sub_1007CF10(*(_DWORD *)(a1 + 116), (void *)(a3 + 14), 12, v3, 0);
    if ( *(_DWORD *)(a3 + 14) != *(_DWORD *)(a2 + 16) )
      sub_1007CF10(*(_DWORD *)(a1 + 116), (void *)(a3 + 14), 12, v3 + 4, 0);
  }
  if ( *(_DWORD *)a3 != 67324752
    || *(_DWORD *)(a3 + 18) != *(_DWORD *)(a2 + 20)
    || *(_DWORD *)(a3 + 14) != *(_DWORD *)(a2 + 16)
    || *(_WORD *)(a3 + 26) != *(_WORD *)(a2 + 28) )
  {
LABEL_13:
    result = -15;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10050D70) --------------------------------------------------------
int __cdecl sub_10050D70(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (10050D90) --------------------------------------------------------
signed int __cdecl sub_10050D90(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // ebp@1
  _BYTE *v4; // edi@2
  _BYTE *v5; // ebx@2
  int v6; // esi@3
  signed int result; // eax@5
  int v8; // [sp+1Ch] [bp+Ch]@3

  v3 = a3;
  if ( a3 )
  {
    v4 = a2;
    v5 = a1;
    while ( 1 )
    {
      v6 = *v5;
      --v3;
      v8 = tolower(*v4++);
      ++v5;
      if ( tolower(v6) != v8 )
        break;
      if ( !v3 )
        goto LABEL_5;
    }
    result = 1;
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (10050DF0) --------------------------------------------------------
int __usercall sub_10050DF0@<eax>(int a1@<esi>, int a2, char a3)
{
  int v3; // ebp@1
  int v4; // edi@2
  int v5; // ebx@2
  int v6; // ebp@5
  int v7; // eax@5
  int v8; // ST04_4@5
  int v10; // [sp+Ch] [bp-4h]@4
  int v11; // [sp+18h] [bp+8h]@4

  v3 = a2;
  if ( a3 )
  {
    v4 = a2;
    v3 = *(_DWORD *)(a1 + 116);
    v5 = 0;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 116);
    v5 = *(_DWORD *)(a1 + 120);
  }
  v11 = *(_DWORD *)(a1 + 24);
  sub_1007CFF0(v3);
  v10 = sub_1007CE60(v4, v5, v3, v11, *(_DWORD *)(a1 + 20));
  if ( !v10 )
  {
    *(_DWORD *)(a1 + 24) = v5;
    *(_DWORD *)(a1 + 4) = v4;
    *(_DWORD *)(a1 + 120) = v11;
    v6 = sub_1007D020(v3, v11, 0);
    v7 = *(_DWORD *)(a1 + 24);
    v8 = v5 + *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 36) = v7;
    v10 = sub_1007D020(v4, v8, 0) | v6;
  }
  *(_DWORD *)(a1 + 120) = sub_1007CFF0(*(_DWORD *)(a1 + 116));
  return v10;
}

//----- (10050F00) --------------------------------------------------------
int __usercall sub_10050F00@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // eax@2
  int result; // eax@2
  int v4; // eax@3
  __int16 v5; // cx@3
  int v6; // edx@3

  sub_1006E2E0(a2 + 721, a1 + 64);
  if ( *(_DWORD *)(a2 + 44) )
  {
    v4 = *(_DWORD *)(a2 + 725);
    v5 = *(_WORD *)(a2 + 729);
    *(_DWORD *)(a2 + 693) = *(_DWORD *)(a2 + 721);
    v6 = *(_DWORD *)(a2 + 732);
    *(_DWORD *)(a2 + 697) = v4;
    *(_WORD *)(a2 + 701) = v5;
    result = j_FIL_vfs_write(*(_DWORD *)(v6 + 116), a2 + 721, 10);
    *(_DWORD *)(a2 + 136) += 10;
    *(_DWORD *)(a2 + 40) += 10;
  }
  else
  {
    v2 = sub_1007CFF0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116));
    result = sub_1007D020(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), v2 - *(_WORD *)(a2 + 50) - *(_DWORD *)(a2 + 40), 0);
    *(_DWORD *)(a2 + 84) -= *(_WORD *)(a2 + 50);
    *(_DWORD *)(a2 + 136) = 0;
    *(_WORD *)(a2 + 28) &= 0xFFFEu;
    *(_DWORD *)(a2 + 40) = 0;
    *(_WORD *)(a2 + 50) = 0;
    *(_WORD *)(a2 + 30) = 0;
    *(_WORD *)(a2 + 80) = 0;
  }
  return result;
}

//----- (10050FB0) --------------------------------------------------------
signed int __usercall sub_10050FB0@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  char v3; // ST30_1@2
  int v4; // ST28_4@2
  int v5; // eax@2
  __int64 v6; // rax@2
  int v7; // ebx@2
  char *v8; // ebp@2
  __int64 v9; // rax@3
  signed int result; // eax@4
  _WORD *v11; // edi@5
  _WORD *v12; // [sp+Ch] [bp-4h]@4

  v2 = a1;
  if ( *(_BYTE *)(a2 + 8) )
  {
    *(_WORD *)(a1 + 532) = -26367;
    *(_WORD *)(a1 + 534) = 7;
    *(_WORD *)(a1 + 536) = 1;
    *(_BYTE *)(a1 + 538) = 65;
    *(_BYTE *)(a1 + 539) = 69;
    v3 = *(_DWORD *)(a2 + 84);
    *(_DWORD *)(a2 + 76) = a1 + 532;
    v4 = a1 + 532;
    v5 = *(_DWORD *)(a2 + 732);
    *(_WORD *)(a2 + 50) = 11;
    *(_WORD *)(a2 + 80) = 11;
    sub_1007D050(*(_DWORD *)(v5 + 116), v4, 11, v3);
    *(_DWORD *)(a2 + 84) += *(_WORD *)(a2 + 80);
    *(_BYTE *)(v2 + 540) = *(_BYTE *)(*(_DWORD *)(a2 + 732) + 112);
    v6 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v6) & 7) + (signed int)v6) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_1006E730((void *)(v2 + 555), v7);
  }
  else
  {
    sub_10050C00(a2, (void *)(a1 + 532), 0xBu, -26367);
    v9 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v9) & 7) + (signed int)v9) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_1007CF10(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 555), v7, *(_DWORD *)(a2 + 84), 0);
    sub_1007CF10(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 571), 2, v7 + *(_DWORD *)(a2 + 84), 0);
  }
  v12 = (_WORD *)(v2 + 543);
  result = sub_1006E600(*(_BYTE *)(v2 + 540), (void *)v2, strlen((const char *)v2), v8, (_WORD *)(v2 + 543), v2 + 64);
  if ( *(_BYTE *)(a2 + 8) )
  {
    sub_1007D050(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v8, v7, *(_DWORD *)(a2 + 84));
    v11 = (_WORD *)(v2 + 571);
    *v11 = *v12;
    sub_1007D050(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v11, 2, v7 + *(_DWORD *)(a2 + 84));
    result = v7 + 2;
    *(_DWORD *)(a2 + 136) += v7 + 2;
    *(_DWORD *)(a2 + 40) += v7 + 2;
  }
  else
  {
    *(_DWORD *)(a2 + 92) += -12 - v7;
    *(_DWORD *)(a2 + 124) += v7 + 2;
  }
  return result;
}

//----- (10051180) --------------------------------------------------------
char __usercall sub_10051180@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  return sub_1006E290(a2, a3, a1 + 212);
}

//----- (10051190) --------------------------------------------------------
int __usercall sub_10051190@<eax>(int result@<eax>)
{
  if ( *(_WORD *)(result + 30) == 99 )
    result = sub_10050F00(result + 148, result);
  return result;
}

//----- (100511B0) --------------------------------------------------------
char __usercall sub_100511B0@<al>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = (*(_DWORD *)(a1 + 72) & 0xFFFD | 2) * ((*(_DWORD *)(a1 + 72) & 0xFFFD | 2) ^ 1);
  return BYTE1(v1);
}

//----- (100511D0) --------------------------------------------------------
int __usercall sub_100511D0@<eax>(int a1@<esi>, unsigned __int8 a2)
{
  int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@1
  int result; // eax@1

  v2 = sub_1007B8A0(a2, *(_DWORD *)(a1 + 64));
  v3 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 64) = v2;
  v4 = 134775813 * (*(_DWORD *)(a1 + 68) + (unsigned __int8)v2) + 1;
  *(_DWORD *)(a1 + 68) = v4;
  result = sub_1007B8A0(BYTE3(v4), v3);
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

//----- (10051210) --------------------------------------------------------
int __cdecl sub_10051210(unsigned int a1)
{
  int i; // ebx@1
  int v2; // edi@1
  signed int v3; // eax@1
  signed int v4; // ebp@1
  int result; // eax@2
  int v6; // esi@7
  int v7; // ebx@9
  int v8; // eax@10
  unsigned int v9; // ecx@11
  int *v10; // edx@11
  char *v11; // esi@11
  int v12; // edi@15
  int v13; // ecx@16
  _BYTE *v14; // edx@16
  _BYTE *v15; // esi@16
  int v16; // ecx@18
  _BYTE *v17; // edx@18
  _BYTE *v18; // esi@18
  _BYTE *v19; // edx@20
  _BYTE *v20; // esi@20
  signed int v21; // ecx@22
  signed int v22; // [sp+Ch] [bp-9Ch]@1
  int v23; // [sp+10h] [bp-98h]@7
  signed int v24; // [sp+14h] [bp-94h]@1
  int v25; // [sp+18h] [bp-90h]@1
  int v26; // [sp+20h] [bp-88h]@1
  char v27[128]; // [sp+24h] [bp-84h]@9

  i = 65557;
  v2 = 0;
  v22 = 65557;
  v25 = 0;
  v26 = 101010256;
  v3 = sub_1007CFF0(a1);
  v4 = v3;
  v24 = v3;
  if ( v3 >= 0 )
  {
    if ( (unsigned int)v3 >= 0x10015 )
      goto LABEL_7;
    v22 = v3;
    if ( v3 > 0 )
    {
      for ( i = v3; ; i = v22 )
      {
LABEL_7:
        v6 = v2 + 128;
        v23 = v2 + 128;
        if ( v2 + 128 > i )
        {
          v6 = i;
          v23 = i;
        }
        v7 = v6 - v2;
        if ( sub_1007CF10(a1, v27, v6 - v2, v4 - v6, 0) != v6 - v2 )
          break;
        v8 = v7 - 4;
        if ( v7 - 4 >= 0 )
        {
          while ( 1 )
          {
            v9 = 4;
            v10 = &v26;
            v11 = &v27[v8];
            do
            {
              if ( *(_DWORD *)v11 != *v10 )
                goto LABEL_15;
              v9 -= 4;
              ++v10;
              v11 += 4;
            }
            while ( v9 >= 4 );
            if ( !v9 )
            {
LABEL_24:
              v21 = 0;
              goto LABEL_25;
            }
LABEL_15:
            v12 = (unsigned __int8)*v11 - *(_BYTE *)v10;
            if ( (unsigned __int8)*v11 == *(_BYTE *)v10 )
            {
              v13 = v9 - 1;
              v14 = (char *)v10 + 1;
              v15 = v11 + 1;
              if ( !v13 )
                goto LABEL_24;
              v12 = *v15 - *v14;
              if ( *v15 == *v14 )
              {
                v16 = v13 - 1;
                v17 = v14 + 1;
                v18 = v15 + 1;
                if ( !v16 )
                  goto LABEL_24;
                v12 = *v18 - *v17;
                if ( *v18 == *v17 )
                {
                  v19 = v17 + 1;
                  v20 = v18 + 1;
                  if ( v16 == 1 )
                    goto LABEL_24;
                  v12 = *v20 - *v19;
                  if ( *v20 == *v19 )
                    goto LABEL_24;
                }
              }
            }
            v21 = 1;
            if ( v12 <= 0 )
              v21 = -1;
LABEL_25:
            if ( !v21 )
              return v24 + v8 - v23;
            if ( --v8 < 0 )
            {
              v4 = v24;
              v2 = v25;
              v6 = v23;
              break;
            }
          }
        }
        v2 = v2 + v7 - 3;
        v25 = v2;
        if ( v6 >= v22 )
          break;
      }
    }
    result = -1;
  }
  else
  {
    result = -1;
  }
  return result;
}
// 10051210: using guessed type char var_84[128];

//----- (100513C0) --------------------------------------------------------
int __fastcall sub_100513C0(int a1, int a2)
{
  int result; // eax@1

  result = *(_WORD *)(a2 + 30);
  if ( *(_WORD *)(a2 + 30) == 99 )
    result = *(_WORD *)(a2 + 689);
  return result;
}

//----- (100513E0) --------------------------------------------------------
int __usercall sub_100513E0@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_DWORD *)(a2 + 732) = result;
  ++*(_DWORD *)(result + 124);
  return result;
}

//----- (100513F0) --------------------------------------------------------
int __usercall sub_100513F0@<eax>(int a1@<esi>)
{
  int v1; // ST1C_4@1
  unsigned int v2; // ST18_4@1
  int v3; // eax@1
  int v4; // ST00_4@1

  v1 = *(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 24);
  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = v1;
  sub_1007D0A0(v2, v1, 0);
  j_FIL_vfs_write(*(_DWORD *)(a1 + 4), a1 + 8, 22);
  v3 = *(_DWORD *)a1 + 22;
  v4 = *(_DWORD *)(a1 + 116);
  *(_DWORD *)(a1 + 120) = v3;
  return sub_1007D020(v4, v3, 0);
}

//----- (10051430) --------------------------------------------------------
signed int __usercall sub_10051430@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6)
{
  __int16 v6; // ax@1
  unsigned int *v7; // ecx@1
  int v8; // esi@1
  signed int v9; // eax@1
  unsigned int v10; // eax@1
  int v11; // ebx@1
  int v12; // ebx@1
  int v13; // eax@4
  int v14; // ecx@6
  int v15; // ebp@8
  unsigned int v16; // ebx@11
  __int64 v17; // rax@14
  unsigned int v18; // ecx@15
  unsigned int v19; // ebp@15
  int v21; // ebx@20
  signed int v22; // eax@23
  size_t v23; // ebp@29
  int v24; // ebx@33
  int v25; // [sp+Ch] [bp-8h]@1
  __int16 v26; // [sp+10h] [bp-4h]@1

  v6 = sub_100513C0(a1, a3);
  v7 = *(unsigned int **)(a2 + 16);
  v8 = a2 + 28;
  v26 = v6;
  *(_DWORD *)v8 = v7;
  v9 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v8 + 4) = v9;
  v25 = 0;
  v10 = sub_1007B8C0(v7, v9, *(_DWORD *)a2);
  v11 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)a2 = v10;
  v12 = v11 + 0xFFFFF;
  while ( 1 )
  {
    if ( !*(_DWORD *)(a2 + 32) )
    {
      if ( !a6 )
        goto LABEL_37;
      v13 = *(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(a2 + 44) == v13 && v12 != v13 + 0xFFFFF )
        break;
    }
    v14 = *(_DWORD *)(a2 + 12);
    if ( !v14 )
      break;
    if ( !--v12 )
      break;
    v15 = *(_DWORD *)(a2 + 44);
    if ( !v15 || a6 && v15 != v14 )
    {
      v16 = *(_DWORD *)(a2 + 48);
      if ( v16
        && (v16 >= 0x28
         || *(_WORD *)(a3 + 30) != 99
         || (v17 = ((*(_BYTE *)(a3 + 688) & 3) + 1) << 6, v16 != (((BYTE4(v17) & 7) + (signed int)v17) >> 3) / 2 + 2)) )
      {
        v18 = v14 - v15;
        v19 = v18;
        if ( *(_BYTE *)(a3 + 28) & 1 )
          sub_10051180(a3, *(char **)(a2 + 8), v18);
        if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v19) != v19 )
          return -16;
      }
      else
      {
        v19 = 0;
      }
      v21 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
      v12 = v21 + 0xFFFFF;
      v25 += v19;
      *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    }
    if ( v26 == 8 )
    {
      if ( a6 )
        v22 = sub_10070690(a2 + 28, 4);
      else
        v22 = sub_10070690(a2 + 28, 0);
      if ( v22 && v22 != 1 )
        return -15;
    }
    else
    {
      if ( v26 )
        return -15;
      v23 = *(_DWORD *)(a2 + 44);
      if ( *(_DWORD *)(a2 + 32) < v23 )
        v23 = *(_DWORD *)(a2 + 32);
      memcpy(*(void **)(a2 + 40), *(const void **)v8, v23);
      *(_DWORD *)(a2 + 32) -= v23;
      *(_DWORD *)(a2 + 44) -= v23;
      *(_DWORD *)v8 += v23;
      *(_DWORD *)(a2 + 40) += v23;
      *(_DWORD *)(a2 + 36) += v23;
      *(_DWORD *)(a2 + 48) += v23;
    }
  }
  if ( a6 )
  {
    v24 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44);
    if ( *(_BYTE *)(a3 + 28) & 1 )
      sub_10051180(a3, *(char **)(a2 + 8), *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44));
    if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v24) != v24 )
      return -16;
    v25 += v24;
    *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
  }
LABEL_37:
  *(_DWORD *)(a5 + 24) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a5 + 20) = *(_DWORD *)(a2 + 48);
  return v25;
}

//----- (10051640) --------------------------------------------------------
int __cdecl sub_10051640(void *a1)
{
  unsigned int v1; // ecx@2
  unsigned int v2; // eax@4
  int v3; // edi@4
  int v4; // edi@7
  int result; // eax@8

  if ( a1 && (v1 = *((_DWORD *)a1 + 29), v1 < 0xFFFFFFC2) && v1 )
  {
    v2 = *((_DWORD *)a1 + 1);
    v3 = 0;
    if ( v1 != v2 && v2 < 0xFFFFFFC2 )
    {
      if ( v2 )
      {
        v4 = sub_10050DF0((int)a1, v2, 0);
        v3 = sub_100513F0((int)a1) | v4;
      }
    }
    sub_1007CE00(*((_DWORD *)a1 + 29));
    memset(a1, 0, 0x80u);
    result = v3;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (100516A0) --------------------------------------------------------
int __cdecl sub_100516A0(int a1, int a2, void *a3, int a4)
{
  unsigned int v4; // eax@3
  signed int v5; // edi@5
  unsigned int v6; // eax@6
  int v8; // eax@11
  int v9; // eax@17

  memset(a3, 0, 0x80u);
  *((_DWORD *)a3 + 8) = -1;
  *((_DWORD *)a3 + 9) = -1;
  *((_BYTE *)a3 + 48) = 0;
  if ( a4 )
    sub_100421E0((int)a3 + 48, (_BYTE *)a4, 64);
  *((_BYTE *)a3 + 112) = 3;
  v4 = j_FIL_vfs_open(a1, a2, 0);
  *((_DWORD *)a3 + 29) = v4;
  if ( v4 >= 0xFFFFFFC2 || !v4 )
  {
    v5 = v4;
    if ( !v4 )
      return v5;
LABEL_6:
    v6 = *((_DWORD *)a3 + 29);
    if ( v6 < 0xFFFFFFC2 )
    {
      if ( v6 )
        sub_1007CE00(*((_DWORD *)a3 + 29));
    }
    memset(a3, 0, 0x80u);
    return v5;
  }
  *((_DWORD *)a3 + 1) = v4;
  v8 = sub_1007CFF0(v4);
  *((_DWORD *)a3 + 30) = v8;
  if ( v8 < 0 )
  {
LABEL_12:
    v5 = -15;
    goto LABEL_6;
  }
  if ( v8 || !(a2 & 2) )
  {
    v9 = sub_10051210(*((_DWORD *)a3 + 29));
    *(_DWORD *)a3 = v9;
    if ( v9 == -1 || (unsigned int)(v9 + 22) > *((_DWORD *)a3 + 30) )
      goto LABEL_12;
    sub_1007CF10(*((_DWORD *)a3 + 1), (char *)a3 + 8, 22, v9, 0);
    if ( !sub_10050BA0((int)a3) )
    {
      v5 = -15;
      goto LABEL_6;
    }
  }
  else
  {
    *((_DWORD *)a3 + 2) = 101010256;
  }
  return 0;
}
// 1007CEC0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (100517A0) --------------------------------------------------------
signed int __cdecl sub_100517A0(int a1, unsigned __int64 a2)
{
  unsigned int v2; // eax@3
  signed int v3; // esi@3
  unsigned int v4; // ebp@4
  int v5; // edx@8
  void *v6; // eax@9
  unsigned __int16 v7; // si@10
  unsigned __int16 v8; // cx@10
  void *v9; // ecx@17
  unsigned __int16 v10; // ax@19
  signed int result; // eax@24
  int v12; // ecx@25
  int v13; // [sp+8h] [bp-4h]@4

  if ( sub_10050BA0(a1) && a2 < *(_WORD *)(a1 + 16) )
  {
    v2 = *(_DWORD *)(a1 + 32);
    v3 = -15;
    if ( (unsigned int)a2 < v2 )
    {
      v4 = *(_DWORD *)(a1 + 24);
      v13 = 0;
LABEL_5:
      while ( v4 < *(_DWORD *)(a1 + 120) )
      {
        v3 = sub_1007CF10(*(_DWORD *)(a1 + 4), (void *)(HIDWORD(a2) + 4), 46, v4, 0);
        if ( v3 != 46 || *(_DWORD *)(HIDWORD(a2) + 4) != 33639248 )
        {
          v12 = *(_DWORD *)(a1 + 24);
          *(_DWORD *)(a1 + 32) = 0;
          *(_DWORD *)(a1 + 36) = v12;
          v3 = -15;
          break;
        }
        v5 = a1;
        *(_DWORD *)(a1 + 32) = v13;
        *(_DWORD *)(a1 + 36) = v4;
        if ( v13 == (_DWORD)a2 )
        {
          v6 = *(void **)(HIDWORD(a2) + 52);
          v3 = 0;
          *(_DWORD *)HIDWORD(a2) = v4;
          *(_WORD *)(HIDWORD(a2) + 58) = -1;
          if ( v6 )
          {
            v7 = *(_WORD *)(HIDWORD(a2) + 56);
            v8 = *(_WORD *)(HIDWORD(a2) + 32);
            if ( v7 <= v8 )
            {
              sub_100421E0((int)v6, &byte_100930C0, v7);
              v5 = a1;
              v3 = -15;
            }
            else if ( sub_1007CF10(*(_DWORD *)(a1 + 4), v6, v8, v4 + 46, 0) == *(_WORD *)(HIDWORD(a2) + 32) )
            {
              v5 = a1;
              *(_WORD *)(HIDWORD(a2) + 58) = *(_WORD *)(HIDWORD(a2) + 32);
              v3 = 0;
              *(_BYTE *)(*(_WORD *)(HIDWORD(a2) + 32) + *(_DWORD *)(HIDWORD(a2) + 52)) = 0;
            }
            else
            {
              v5 = a1;
              v3 = -15;
              *(_BYTE *)(*(_WORD *)(HIDWORD(a2) + 32) + *(_DWORD *)(HIDWORD(a2) + 52)) = 0;
            }
          }
          else
          {
            *(_WORD *)(HIDWORD(a2) + 58) = -1;
          }
          v9 = *(void **)(HIDWORD(a2) + 60);
          *(_WORD *)(HIDWORD(a2) + 66) = -1;
          if ( v9 )
          {
            if ( !v3 )
            {
              v10 = *(_WORD *)(HIDWORD(a2) + 34);
              if ( *(_WORD *)(HIDWORD(a2) + 64) < v10
                || sub_1007CF10(*(_DWORD *)(v5 + 4), v9, v10, *(_WORD *)(HIDWORD(a2) + 32) + v4 + 46, 0) != *(_WORD *)(HIDWORD(a2) + 34) )
              {
                v3 = -15;
              }
              else
              {
                v3 = 0;
                *(_WORD *)(HIDWORD(a2) + 66) = *(_WORD *)(HIDWORD(a2) + 34);
              }
            }
          }
        }
        v4 += sub_10050B40(HIDWORD(a2) + 4);
        if ( ++v13 > (unsigned int)a2 )
          return v3;
      }
    }
    else
    {
      v4 = *(_DWORD *)(a1 + 36);
      v13 = *(_DWORD *)(a1 + 32);
      if ( v2 <= (unsigned int)a2 )
        goto LABEL_5;
    }
    result = v3;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (100519A0) --------------------------------------------------------
signed int __cdecl sub_100519A0(int a1, int a2)
{
  return sub_10050CC0(*(_DWORD *)(a1 + 732), a1 + 20, a2);
}

//----- (100519C0) --------------------------------------------------------
int __cdecl sub_100519C0(int a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  unsigned int v3; // ebp@1
  bool v4; // zf@1
  int v5; // ecx@1
  __int16 v6; // cx@4
  __int16 v7; // ax@4
  __int16 v8; // dx@4
  __int16 v9; // cx@4
  unsigned int v10; // edx@4
  int v11; // eax@4
  unsigned int v12; // ecx@4
  int v13; // eax@4
  int result; // eax@5
  int v15; // eax@6
  unsigned __int16 v16; // ax@7
  int v17; // eax@11
  int v18; // edx@13
  int v19; // edi@13
  int v20; // eax@13
  unsigned __int16 v21; // cx@14
  int v22; // [sp+10h] [bp-28h]@4
  char v23; // [sp+14h] [bp-24h]@3
  int v24; // [sp+18h] [bp-20h]@1
  int v25; // [sp+1Ch] [bp-1Ch]@1
  int v26; // [sp+20h] [bp-18h]@1
  int v27; // [sp+24h] [bp-14h]@1
  __int64 v28; // [sp+28h] [bp-10h]@1
  int v29; // [sp+30h] [bp-8h]@1
  __int16 v30; // [sp+34h] [bp-4h]@1
  int v31; // [sp+3Ch] [bp+4h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 732);
  v31 = *(_DWORD *)(v2 + 116);
  sub_10051190(v1);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_WORD *)(v1 + 32) == 0;
  v5 = ~*(_DWORD *)(v1 + 88);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0i64;
  v29 = 0;
  v30 = 0;
  *(_DWORD *)(v1 + 36) = v5;
  if ( v4 || !*(_WORD *)(v1 + 34) )
  {
    sub_10042DC0(&v23);
    sub_10042CC0((unsigned int *)&v23, (_WORD *)(v1 + 34), (_WORD *)(v1 + 32));
  }
  v6 = *(_WORD *)(v1 + 24);
  v7 = *(_WORD *)(v1 + 30);
  HIWORD(v25) = *(_WORD *)(v1 + 28);
  v8 = *(_WORD *)(v1 + 34);
  LOWORD(v25) = v6;
  v9 = *(_WORD *)(v1 + 32);
  LOWORD(v27) = v8;
  v10 = *(_DWORD *)(v1 + 44);
  LOWORD(v26) = v7;
  v11 = *(_DWORD *)(v1 + 36);
  HIWORD(v26) = v9;
  v12 = *(_DWORD *)(v1 + 40);
  *(int *)((char *)&v27 + 2) = v11;
  LOWORD(v11) = *(_WORD *)(v1 + 48);
  *(__int64 *)((char *)&v28 + 2) = __PAIR__(v10, v12);
  LOWORD(v12) = *(_WORD *)(v1 + 50);
  v24 = 67324752;
  HIWORD(v29) = v11;
  v30 = v12;
  v22 = sub_10050B60(v1, (int)&v24);
  v13 = sub_1007CFF0(v31);
  if ( v3 == v31 )
  {
    result = sub_1007CE60(v31, v13, v31, *(_DWORD *)(v2 + 24), *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v15 = *(_DWORD *)(v2 + 24);
    *(_DWORD *)(v1 + 62) = v15;
    *(_DWORD *)(v1 + 84) = v22 + v15;
  }
  sub_1007D0A0(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 62), 0);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), &v24, 30);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72));
  v16 = *(_WORD *)(v1 + 80);
  if ( v16 )
    j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 76), v16);
  if ( v3 == v31 )
  {
    result = sub_1007CE60(
               v31,
               *(_DWORD *)(v1 + 84),
               v31,
               v22 + *(_DWORD *)(v2 + 120),
               *(_DWORD *)(v1 + 40) + *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v17 = *(_DWORD *)((char *)&v28 + 2) + v22 + *(_DWORD *)(v2 + 24);
  }
  else
  {
    v17 = 0;
  }
  v18 = v17 + *(_DWORD *)(v2 + 20);
  ++*(_WORD *)(v2 + 16);
  ++*(_WORD *)(v2 + 18);
  *(_DWORD *)(v2 + 8) = 101010256;
  *(_DWORD *)(v2 + 24) = v17;
  *(_WORD *)(v2 + 28) = 0;
  sub_1007D0A0(v3, v18, 0);
  *(_DWORD *)(v2 + 20) += sub_10050B40(v1 + 20);
  j_FIL_vfs_write(v3, v1 + 20, 46);
  v19 = j_FIL_vfs_write(v3, *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72)) != *(_WORD *)(v1 + 72) ? 0xFFFFFFF1 : 0;
  v20 = *(_DWORD *)(v1 + 76);
  if ( v20 )
  {
    v21 = *(_WORD *)(v1 + 80);
    if ( v21 )
    {
      v19 |= j_FIL_vfs_write(v3, v20, v21);
      if ( v19 >= 0 )
        v19 = 0;
    }
  }
  *(_DWORD *)v2 = *(_DWORD *)(v2 + 20) + *(_DWORD *)(v2 + 24);
  if ( v3 == v31 )
    sub_100513F0(v2);
  else
    *(_DWORD *)(v2 + 120) = sub_1007CFF0(v31);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(v2 + 24);
  *(_DWORD *)(v2 + 32) = 0;
  return v19;
}

//----- (10051C30) --------------------------------------------------------
int __cdecl sub_10051C30(void *a1, int a2, char a3)
{
  _BYTE *v3; // eax@1
  char *v4; // edi@3
  int result; // eax@4

  memset(a1, 0, 0x2E0u);
  *((_DWORD *)a1 + 17) = *(_DWORD *)(a2 + 4);
  *((_WORD *)a1 + 36) = *(_WORD *)(a2 + 8);
  *((_DWORD *)a1 + 19) = *(_DWORD *)(a2 + 16);
  *((_WORD *)a1 + 40) = *(_WORD *)(a2 + 20);
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *((_DWORD *)a1 + 24) = *(_DWORD *)(a2 + 24);
  *((_DWORD *)a1 + 25) = *(_DWORD *)(a2 + 28);
  *((_DWORD *)a1 + 26) = 0;
  *((_DWORD *)a1 + 27) = 0;
  sub_10050D70((int)a1 + 116);
  v3 = *(_BYTE **)(a2 + 12);
  if ( v3 )
    sub_100421E0((int)a1 + 148, v3, 64);
  v4 = (char *)a1 + 116;
  if ( a3 )
    result = sub_10070950(
               (int)v4,
               *(_BYTE *)(a2 + 44),
               8,
               -*(_DWORD *)(a2 + 40),
               *(_DWORD *)(a2 + 48),
               0,
               *(_DWORD *)(a2 + 32),
               *(_DWORD *)(a2 + 36));
  else
    result = sub_100722B0((int)v4, -*(_DWORD *)(a2 + 40), *(_DWORD *)(a2 + 32), *(_DWORD *)(a2 + 36));
  return result;
}

//----- (10051D00) --------------------------------------------------------
signed int __cdecl sub_10051D00(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ecx@7
  int v5; // eax@10

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    if ( *(_DWORD *)(a1 + 112) == *(_DWORD *)(a1 + 44) && !*(_DWORD *)(a1 + 124) )
      sub_1007D0A0(*(_DWORD *)(*(_DWORD *)(a1 + 732) + 116), *(_DWORD *)(a1 + 136) + *(_DWORD *)(a1 + 84), 0);
    v4 = *(_DWORD *)(a1 + 112) - a3;
    *(_DWORD *)(a1 + 104) = a2;
    *(_DWORD *)(a1 + 108) = a3;
    v5 = !v4 && *(_DWORD *)(a1 + 136) || !a2;
    result = sub_10051430(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 88,
               a1,
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 20,
               v5);
    if ( result >= 0 )
    {
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 136);
      *(_DWORD *)(a1 + 112) -= a3;
    }
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10051DA0) --------------------------------------------------------
int __usercall sub_10051DA0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // al@1
  unsigned __int8 *v3; // edx@1

  v1 = a1;
  v2 = sub_100511B0(a1);
  *v3 ^= v2;
  return sub_100511D0(v1, *v3);
}

//----- (10051DC0) --------------------------------------------------------
int __usercall sub_10051DC0@<eax>(int a1@<edi>, int a2)
{
  int i; // esi@1
  int result; // eax@2

  for ( i = 0; i < a1; ++i )
    result = sub_10051DA0(a2);
  return result;
}

//----- (10051DF0) --------------------------------------------------------
signed int __usercall sub_10051DF0@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // esi@1
  signed int v3; // edi@1
  signed int result; // eax@4

  v2 = a1;
  *(_DWORD *)(a1 + 64) = 305419896;
  *(_DWORD *)(a1 + 68) = 591751049;
  *(_DWORD *)(a1 + 72) = 878082192;
  v3 = 0;
  do
  {
    if ( !*(_BYTE *)(v3 + v2) )
      break;
    sub_100511D0(v2, *(_BYTE *)(v3++ + v2));
  }
  while ( v3 < 64 );
  result = sub_1007CF10(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 76), 12, *(_DWORD *)(a2 + 84), 0);
  *(_DWORD *)(a2 + 92) -= 12;
  *(_DWORD *)(a2 + 124) += 12;
  return result;
}

//----- (10051E60) --------------------------------------------------------
int __cdecl sub_10051E60(int a1, char *a2, int a3)
{
  char *v3; // edi@1
  int v4; // ebx@4
  int v5; // esi@6
  int result; // eax@11
  signed int v7; // [sp+8h] [bp-F4h]@6
  char v8; // [sp+Ch] [bp-F0h]@4
  char *v9; // [sp+40h] [bp-BCh]@4
  __int16 v10; // [sp+44h] [bp-B8h]@4
  unsigned __int16 v11; // [sp+46h] [bp-B6h]@8
  char v12; // [sp+50h] [bp-ACh]@4

  v3 = a2;
  if ( sub_10050BA0(a1) && a2 && *a2 )
  {
    memset(&v8, 0, 0x44u);
    v9 = &v12;
    v10 = 168;
    v4 = strlen(a2);
    strchr(a2, 92);
    if ( *a2 == 47 )
    {
      v3 = a2 + 1;
      --v4;
    }
    v5 = a3;
    v7 = -24;
    if ( a3 < (unsigned int)*(_WORD *)(a1 + 16) )
    {
      while ( sub_100517A0(a1, __PAIR__(&v8, v5)) || v4 != v11 || sub_10050D90(v3, &v12, v4) )
      {
        if ( ++v5 >= (unsigned int)*(_WORD *)(a1 + 16) )
          return -24;
      }
      v7 = v5;
    }
    result = v7;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10051FD0) --------------------------------------------------------
signed int __cdecl sub_10051FD0(int a1)
{
  signed int result; // eax@5

  if ( a1 && *(_DWORD *)(a1 + 732) )
  {
    --*(_DWORD *)(*(_DWORD *)(a1 + 732) + 124);
    if ( *(_BYTE *)(a1 + 8) )
      exit_0(a1);
    sub_10071780(a1 + 116);
    result = 0;
    *(_DWORD *)a1 = -858993460;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10052030) --------------------------------------------------------
char __usercall sub_10052030@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>)
{
  char result; // al@2

  if ( *(_WORD *)(a3 + 30) == 99 )
    result = sub_1006E240(a1, a2, a3 + 212);
  else
    result = sub_10051DC0(a2, a3 + 148);
  return result;
}

//----- (10052060) --------------------------------------------------------
signed int __usercall sub_10052060@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@1
  int v3; // eax@1
  signed int result; // eax@2

  v1 = a1;
  v2 = *(_WORD *)(a1 + 30) == 99;
  v3 = a1 + 148;
  if ( v2 )
    result = sub_10050FB0(v3, v1);
  else
    result = sub_10051DF0(v3, v1);
  return result;
}

//----- (10052090) --------------------------------------------------------
BOOL __usercall sub_10052090@<eax>(int a1@<ebx>, int a2)
{
  int v2; // ebp@1
  unsigned int v3; // esi@1
  int v4; // edi@1
  char v6; // [sp+10h] [bp+4h]@2

  v2 = a2;
  v3 = 0;
  v4 = a2 + 148;
  do
  {
    v6 = *(_BYTE *)(a1 + v3 + 76);
    sub_10051DA0(v4);
    ++v3;
  }
  while ( v3 < 0xC );
  return *(_BYTE *)(v2 + 39) == v6;
}

//----- (100520D0) --------------------------------------------------------
signed int __cdecl sub_100520D0(unsigned int a1)
{
  signed int result; // eax@3
  int v2; // eax@4
  int v3; // ecx@4
  int v4; // edx@4

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    sub_10050D70(a1 + 116);
    v2 = *(_DWORD *)(a1 + 40);
    v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 88) = -1;
    *(_DWORD *)(a1 + 92) = v2;
    *(_DWORD *)(a1 + 112) = v3;
    sub_100723A0(v4);
    if ( *(_BYTE *)(a1 + 28) & 1 )
      sub_10052060(a1);
    result = 0;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10052120) --------------------------------------------------------
signed int __cdecl sub_10052120(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned int v5; // ecx@1
  signed int v6; // eax@4
  size_t v8; // eax@9
  size_t v9; // ebx@10
  int v10; // esi@13
  int v11; // edx@18
  __int16 v12; // ax@20
  size_t v13; // esi@21
  int v14; // ST30_4@25
  unsigned int *v15; // ST34_4@25
  int v16; // ebx@25
  int v17; // [sp+10h] [bp-Ch]@1
  int v18; // [sp+24h] [bp+8h]@7

  v2 = a2;
  v3 = a2 + 28;
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 20);
  v5 = *(_DWORD *)(a2 + 24);
  v17 = 0;
  if ( v4 <= v5 )
    *(_DWORD *)(a2 + 44) = v4;
  else
    *(_DWORD *)(a2 + 44) = v5;
  v6 = 0xFFFFF;
  if ( *(_DWORD *)(a2 + 44) )
  {
    while ( 1 )
    {
      v18 = v6 - 1;
      if ( v6 - 1 <= 0 )
        break;
      if ( *(_DWORD *)(v3 + 4) || (v8 = *(_DWORD *)(v2 + 4)) == 0 )
      {
        v10 = a1;
      }
      else
      {
        v9 = *(_DWORD *)(v2 + 12);
        if ( v8 < v9 )
          v9 = *(_DWORD *)(v2 + 4);
        if ( !v9 )
          return v17;
        v10 = a1;
        if ( sub_1007CF10(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               *(void **)(v2 + 8),
               v9,
               *(_DWORD *)(a1 + 84) + *(_DWORD *)(v3 + 8),
               0) != v9 )
          return -15;
        if ( *(_BYTE *)(a1 + 28) & 1 )
        {
          sub_10052030(*(char **)(v2 + 8), v9, a1);
          if ( *(_DWORD *)(v2 + 4) == v9 && *(_WORD *)(a1 + 30) == 99 )
          {
            sub_1007CF10(
              *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
              (void *)(a1 + 721),
              10,
              *(_DWORD *)(a1 + 84) + v9 + *(_DWORD *)(v3 + 4) + *(_DWORD *)(v3 + 8),
              0);
            sub_1006E2E0(a1 + 693, a1 + 212);
            v10 = a1;
          }
        }
        v11 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 4) -= v9;
        v18 = 0xFFFFF;
        *(_DWORD *)v3 = v11;
        *(_DWORD *)(v3 + 4) = v9;
      }
      v12 = sub_100513C0(v5, v10);
      if ( v12 )
      {
        if ( v12 != 8 )
          return -15;
        v14 = *(_DWORD *)(v3 + 20);
        v15 = *(unsigned int **)(v3 + 12);
        v16 = (char)sub_10073760(v3, 2);
        v17 += *(_DWORD *)(v3 + 20) - v14;
        *(_DWORD *)v2 = sub_1007B8C0(v15, *(_DWORD *)(v3 + 20) - v14, *(_DWORD *)v2);
        if ( v16 == 1 )
          return v17;
        if ( v16 < 0 )
          return -14;
      }
      else
      {
        v13 = *(_DWORD *)(v3 + 4);
        if ( *(_DWORD *)(v3 + 16) < v13 )
          v13 = *(_DWORD *)(v3 + 16);
        memcpy(*(void **)(v3 + 12), *(const void **)v3, v13);
        *(_DWORD *)v2 = sub_1007B8C0(*(unsigned int **)(v3 + 12), v13, *(_DWORD *)v2);
        *(_DWORD *)(v3 + 4) -= v13;
        *(_DWORD *)(v3 + 16) -= v13;
        *(_DWORD *)(v3 + 12) += v13;
        *(_DWORD *)v3 += v13;
        *(_DWORD *)(v3 + 20) += v13;
        *(_DWORD *)(v3 + 8) += v13;
        v17 += v13;
      }
      if ( !*(_DWORD *)(v3 + 16) )
        return v17;
      v6 = v18;
    }
  }
  return v17;
}

//----- (10052310) --------------------------------------------------------
bool __usercall sub_10052310@<al>(int a1@<eax>)
{
  int v1; // ecx@4
  int v2; // edx@4
  int v3; // eax@4
  signed int v4; // ecx@6
  int v5; // eax@2

  if ( *(_WORD *)(a1 + 30) != 99 )
    return sub_10052090(a1 + 148, a1);
  v5 = a1 + 148;
  v1 = v5 + 543;
  v2 = v5 + 571;
  v3 = *(_BYTE *)(v5 + 571) - *(_BYTE *)(v5 + 543);
  if ( v3 || (v3 = *(_BYTE *)(v2 + 1) - *(_BYTE *)(v1 + 1), *(_BYTE *)(v2 + 1) != *(_BYTE *)(v1 + 1)) )
  {
    v4 = 1;
    if ( v3 <= 0 )
      return 0;
  }
  else
  {
    v4 = 0;
  }
  return v4 == 0;
}

//----- (10052340) --------------------------------------------------------
int __cdecl sub_10052340(int a1, int a2, char a3, void *a4, int a5)
{
  int result; // eax@6
  unsigned __int64 v6; // ST04_8@7
  char v7; // [sp+8h] [bp-54h]@8
  int v8; // [sp+28h] [bp-34h]@4
  int v9; // [sp+34h] [bp-28h]@4

  if ( !sub_10050BA0(a1) || !a4 || a3 & 2 )
    return -15;
  qmemcpy(&v8, (const void *)a5, 0x34u);
  if ( !v9 )
    v9 = a1 + 48;
  result = sub_10051C30(a4, (int)&v8, 0);
  if ( !result )
  {
    HIDWORD(v6) = (char *)a4 + 16;
    LODWORD(v6) = a2;
    if ( sub_100517A0(a1, v6) )
      return -15;
    sub_100513E0(a1, (int)a4);
    if ( sub_100519A0((int)a4, (int)&v7) )
    {
      sub_10041EF0((unsigned int)a4);
      return -15;
    }
    *((_DWORD *)a4 + 21) = *(_DWORD *)((char *)a4 + 62) + sub_10050B60((int)a4, (int)&v7);
    *((_DWORD *)a4 + 3) = a2;
    sub_100520D0((unsigned int)a4);
    if ( !(*((_BYTE *)a4 + 28) & 1) || sub_10052310((int)a4) )
    {
      result = sub_10050A60((int)a4);
    }
    else
    {
      sub_10051FD0((int)a4);
      result = -34;
    }
  }
  return result;
}

//----- (10052450) --------------------------------------------------------
signed int __cdecl sub_10052450(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ST04_4@4
  signed int v5; // eax@4
  signed int v6; // ebx@4
  bool v7; // zf@5

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    v4 = a1 + 88;
    *(_DWORD *)(v4 + 16) = a2;
    *(_DWORD *)(v4 + 20) = a3;
    v5 = sub_10052120(a1, a1 + 88);
    v6 = v5;
    if ( v5 > 0 )
    {
      v7 = *(_DWORD *)(a1 + 112) == v5;
      *(_DWORD *)(a1 + 112) -= v5;
      if ( v7 && !(*(_BYTE *)a1 & 1) && !sub_10050A70(a1) )
        v6 = -14;
    }
    result = v6;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (100524B0) --------------------------------------------------------
signed int __cdecl sub_100524B0(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  unsigned int v4; // edx@4
  int v5; // ebx@4
  int v6; // esi@16
  int v7; // eax@17
  char v8; // [sp+4h] [bp-204h]@19

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return -6;
  v4 = *(_DWORD *)(a1 + 44);
  result = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 112);
  v5 = a2;
  if ( a3 == 1 )
  {
    v5 = result + a2;
  }
  else if ( a3 == 2 )
  {
    v5 = v4 + a2;
  }
  if ( v5 > v4 || v5 < 0 )
    return -15;
  if ( result == v5 )
    return result;
  if ( !v5 )
  {
    sub_100520D0(a1);
    return 0;
  }
  if ( !*(_WORD *)(a1 + 30) && *(_BYTE *)a1 & 3 )
  {
    sub_10050D70(a1 + 116);
    *(_DWORD *)(a1 + 124) = v5;
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 44) - v5;
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 40) - v5;
    return v5;
  }
  if ( result > v5 )
  {
    sub_100520D0(a1);
    result = 0;
  }
  v6 = v5 - result;
  if ( v5 - result <= 0 )
    return v5;
  while ( 1 )
  {
    v7 = 512;
    if ( (unsigned int)v6 < 0x200 )
      v7 = v6;
    result = sub_10052450(a1, (int)&v8, v7);
    if ( result <= 0 )
      break;
    v6 -= result;
    if ( v6 <= 0 )
      return v5;
  }
  return result;
}

//----- (10052640) --------------------------------------------------------
int __cdecl sub_10052640(int a1, char *a2, int a3, void *a4, int a5)
{
  int result; // eax@10
  bool v6; // zf@11
  int v7; // ST0C_4@16
  int v8; // eax@16
  int v9; // [sp+Ch] [bp-34h]@5
  int v10; // [sp+18h] [bp-28h]@5
  char v11; // [sp+38h] [bp-8h]@11

  if ( sub_10050BA0(a1) && a2 && a4 && a5 )
  {
    qmemcpy(&v9, (const void *)a5, 0x34u);
    if ( !v10 )
      v10 = a1 + 48;
    *((_DWORD *)a4 + 1) = a3;
    if ( a3 & 8 )
    {
      if ( *(_WORD *)(a1 + 16) >= 0xFFFFu || *(_WORD *)(a1 + 18) >= 0xFFFFu )
      {
        result = -22;
      }
      else
      {
        result = sub_10051C30(a4, (int)&v9, 1);
        if ( !result )
        {
          *((_DWORD *)a4 + 1) = a3;
          *((_BYTE *)a4 + 8) = 1;
          *((_DWORD *)a4 + 183) = a1;
          *((_DWORD *)a4 + 3) = *(_WORD *)(a1 + 16);
          *((_DWORD *)a4 + 22) = -1;
          *((_WORD *)a4 + 12) = 20;
          *((_WORD *)a4 + 13) = 20;
          *((_DWORD *)a4 + 5) = 33639248;
          *((_WORD *)a4 + 14) = 0;
          *((_WORD *)a4 + 16) = 0;
          *((_WORD *)a4 + 17) = 0;
          *((_DWORD *)a4 + 9) = 0;
          *((_DWORD *)a4 + 10) = 0;
          *((_DWORD *)a4 + 11) = 0;
          v6 = v11 == 0;
          *((_WORD *)a4 + 24) = strlen(a2);
          *((_WORD *)a4 + 25) = 0;
          *((_WORD *)a4 + 26) = 0;
          *((_WORD *)a4 + 27) = 0;
          *((_WORD *)a4 + 28) = 0;
          *(_DWORD *)((char *)a4 + 58) = 0;
          if ( v6 )
            *((_WORD *)a4 + 15) = 0;
          else
            *((_WORD *)a4 + 15) = 8;
          if ( *(_BYTE *)a4 & 4 )
          {
            *(_WORD *)((char *)a4 + 689) = *((_WORD *)a4 + 15);
            *((_WORD *)a4 + 15) = 99;
            *((_WORD *)a4 + 14) = 1;
          }
          *(_DWORD *)((char *)a4 + 62) = *(_DWORD *)(a1 + 120);
          *((_DWORD *)a4 + 21) = *(_DWORD *)((char *)a4 + 62) + sub_10050B60((int)a4, 0);
          sub_100513E0(a1, (int)a4);
          v7 = *(_DWORD *)((char *)a4 + 62);
          v8 = sub_10050B60((int)a4, 0);
          sub_1007D050(*(_DWORD *)(a1 + 116), *((_DWORD *)a4 + 24), v8, v7);
          if ( *((_BYTE *)a4 + 28) & 1 )
            sub_10052060((int)a4);
          result = sub_10050A60((int)a4);
        }
      }
    }
    else
    {
      *((_BYTE *)a4 + 8) = 0;
      result = sub_10051E60(a1, a2, 0);
      if ( result >= 0 )
        result = sub_10052340(a1, result, a3, a4, (int)&v9);
    }
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10052830) --------------------------------------------------------
int __cdecl sub_10052830(char a1, __int16 a2, int a3)
{
  __int16 v4; // [sp+0h] [bp-52Ch]@1
  char v5; // [sp+4h] [bp-528h]@1
  __int16 v6; // [sp+6h] [bp-526h]@1
  int v7; // [sp+8h] [bp-524h]@1

  v5 = a1;
  v4 = -32710;
  v6 = a2;
  v7 = a3;
  return sub_1007C170(28, (int)&v4, 50000, 0);
}

//----- (100528A0) --------------------------------------------------------
char __cdecl sub_100528A0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xA:
    case 0x30:
      result = 0;
      break;
    case 0xB:
    case 0x31:
      result = 1;
      break;
    default:
      sub_10042930("..\\lib\\acl\\iop\\iop_xpdr_cnfg_utl.c", 155, 0, 0);
      result = 2;
      break;
  }
  return result;
}

//----- (10052920) --------------------------------------------------------
char __cdecl sub_10052920(unsigned __int16 a1, _WORD *a2)
{
  unsigned int v2; // edi@1
  char v3; // bl@1
  signed __int16 v4; // ax@2
  __int16 v5; // si@2
  signed int v6; // ecx@3
  unsigned __int8 v7; // al@3

  v2 = a1;
  v3 = 0;
  if ( sub_1003C270(a1) )
  {
    v3 = 1;
    *a2 = 0;
    v4 = 1000;
    v5 = 0;
    do
    {
      v6 = (unsigned __int16)v4;
      v7 = v2 / (unsigned __int16)v4;
      v2 -= v6 * v7;
      v5 = v7 | (unsigned __int16)(8 * v5);
      v4 = v6 / 10;
    }
    while ( (unsigned __int16)v4 >= 1u );
    *a2 = v5;
  }
  return v3;
}

//----- (100529A0) --------------------------------------------------------
char __cdecl sub_100529A0(unsigned __int16 a1, _WORD *a2)
{
  unsigned int v2; // ebx@2
  _WORD *v3; // edi@2
  char result; // al@2
  signed __int16 v5; // cx@2
  __int16 v6; // si@2
  __int16 v7; // dx@3

  if ( sub_1004C5D0(&a1) )
  {
    result = 0;
  }
  else
  {
    v2 = a1;
    v3 = a2;
    result = 1;
    *a2 = 0;
    v5 = 1;
    v6 = 0;
    do
    {
      v7 = v5 * (v2 & 7);
      v5 *= 10;
      v2 >>= 3;
      v6 += v7;
    }
    while ( (unsigned __int16)v5 <= 0x3E8u );
    *v3 = v6;
  }
  return result;
}

//----- (10052A00) --------------------------------------------------------
char __cdecl sub_10052A00(char a1)
{
  char result; // al@1
  bool v2; // zf@2
  char v3; // al@2

  result = 67;
  if ( (unsigned __int8)a1 < 2u )
  {
    v2 = sub_1003C330(a1) == 0;
    v3 = 1;
    if ( v2 )
      v3 = 0;
    result = *(&byte_1010A2F4[2 * (unsigned __int8)a1] + v3);
  }
  return result;
}

//----- (10052A40) --------------------------------------------------------
signed int __cdecl sub_10052A40(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@4
  int v4; // ecx@4
  char v5; // bl@4
  int v6; // eax@5
  int v7; // eax@6
  int v8; // eax@7
  int v9; // ecx@7
  signed int result; // eax@9
  int v11; // edi@12
  int v12; // edx@12
  int v13; // ecx@12

  v2 = a1;
  *(_BYTE *)a2 = 78;
  if ( a1 == -1 || a1 == 10485760 || (v2 & 0xF00000) != 10485760 )
    return 0;
  v3 = (a1 - 10485761) / 101711;
  v4 = -1 - 101711 * v3 + a1 - 10485760;
  *(_BYTE *)(a2 + 1) = v3 + 49;
  v5 = 1;
  if ( v4 < 601
    || (v6 = (v4 - 601) / 10111, v4 += -601 - 10111 * v6, *(_BYTE *)(a2 + 2) = v6 + 48, v5 = 2, v4 < 601)
    || (v7 = (v4 - 601) / 951, v4 += -601 - 951 * v7, *(_BYTE *)(a2 + 3) = v7 + 48, v5 = 3, v4 < 601) )
  {
    if ( v4 > 0 )
    {
      v11 = (v4 - 1) / 25;
      v12 = (unsigned __int8)v5;
      v13 = -1 - 25 * v11 + v4;
      ++v5;
      *(_BYTE *)(v12 + a2 + 1) = byte_1010A440[v11];
      if ( v13 > 0 )
        *(_BYTE *)((unsigned __int8)v5++ + a2 + 1) = (&off_1010A43C)[v13 + 3];
    }
    goto LABEL_14;
  }
  v8 = (v4 - 601) / 35;
  v9 = -601 - 35 * v8 + v4;
  *(_BYTE *)(a2 + 4) = v8 + 48;
  v5 = 4;
  if ( v9 <= 0 )
  {
LABEL_14:
    result = (unsigned __int8)v5;
    *(_BYTE *)((unsigned __int8)v5 + a2 + 1) = 0;
    return result;
  }
  if ( v9 < 25 )
  {
    *(_BYTE *)(a2 + 5) = (&off_1010A43C)[v9 + 3];
    result = 5;
    *(_BYTE *)(a2 + 6) = 0;
  }
  else
  {
    *(_BYTE *)(a2 + 5) = v9 + 23;
    result = 5;
    *(_BYTE *)(a2 + 6) = 0;
  }
  return result;
}
// 1010A43C: using guessed type char *;

//----- (10052BF0) --------------------------------------------------------
char __cdecl sub_10052BF0(char *a1)
{
  char result; // al@1
  char v2; // [sp+4h] [bp-44h]@4
  char v3; // [sp+10h] [bp-38h]@5

  result = 0;
  if ( (unsigned int)a1 < 0xFFFFFFC2 )
  {
    if ( a1 )
    {
      result = sub_100493F0(a1, 9u);
      if ( *a1 == 32 )
      {
        *a1 = 78;
        if ( sub_10049580(&v2) )
          strncpy(a1, &v3, 7u);
        result = 0;
      }
    }
  }
  return result;
}

//----- (10052C60) --------------------------------------------------------
char __cdecl sub_10052C60(int a1, char a2)
{
  char v2; // bl@1
  int v3; // eax@5
  int v4; // eax@9
  int v6; // [sp+8h] [bp-10h]@1
  int v7; // [sp+Ch] [bp-Ch]@1
  char v8; // [sp+10h] [bp-8h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v2 = 1;
  if ( sub_1003C380(a2) )
    return v2;
  if ( *(_BYTE *)(a1 + 20) == 1 && *(_BYTE *)(a1 + 19) == 2 )
  {
    *(_BYTE *)(a1 + 19) = 0;
    v2 = 0;
  }
  v3 = *(_DWORD *)(a1 + 24);
  if ( !v3 || v3 == 0xFFFFFF )
  {
    *(_DWORD *)(a1 + 24) = 10485760;
    v2 = 0;
  }
  if ( *(_BYTE *)(a1 + 19) == 2 )
  {
    v4 = sub_10052A40(*(_DWORD *)(a1 + 24), (int)&v6) + 1;
    if ( v4 < 8 )
      memset((char *)&v6 + v4, 32, 8 - v4);
    v8 = 0;
    if ( sub_10042230(&v6, (_BYTE *)(a1 + 2), 9) )
    {
      sub_100421E0(a1 + 2, &v6, 9);
      return 0;
    }
    return v2;
  }
  if ( !sub_10052BF0((char *)(a1 + 2)) || !v2 )
    return 0;
  return 1;
}

//----- (10052D70) --------------------------------------------------------
char __cdecl sub_10052D70(int a1, char a2)
{
  char v2; // bl@1
  _BYTE *v3; // eax@2
  signed int v4; // ecx@2
  char v5; // al@6
  char result; // al@8

  v2 = 1;
  if ( !sub_1003C380(a2) )
  {
    v3 = (_BYTE *)(a1 + 40);
    v4 = 3;
    do
    {
      if ( *v3 != 1 )
      {
        *v3 = 1;
        v2 = 0;
      }
      v3 += 4;
      --v4;
    }
    while ( v4 );
  }
  v5 = (sub_1003C450(a2) != 0) + 3;
  if ( *(_BYTE *)(a1 + 53) == v5 && *(_BYTE *)(a1 + 52) == 7 )
  {
    result = v2;
  }
  else
  {
    *(_BYTE *)(a1 + 53) = v5;
    *(_BYTE *)(a1 + 52) = 7;
    result = 0;
  }
  return result;
}

//----- (10052DE0) --------------------------------------------------------
char __cdecl sub_10052DE0(char a1, int a2)
{
  char v2; // cl@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // eax@1
  int v10; // ecx@1
  bool v11; // zf@1
  int v12; // eax@3
  int v13; // ecx@3
  char v14; // dl@3
  __int16 v15; // ax@5
  char v16; // dl@5
  int v18; // [sp+4h] [bp-58h]@1
  char v19; // [sp+8h] [bp-54h]@1
  __int64 v20; // [sp+Ch] [bp-50h]@1
  int v21; // [sp+14h] [bp-48h]@1
  int v22; // [sp+18h] [bp-44h]@1
  char v23; // [sp+1Ch] [bp-40h]@1
  __int16 v24; // [sp+1Eh] [bp-3Eh]@1
  int v25; // [sp+20h] [bp-3Ch]@4
  int v26; // [sp+24h] [bp-38h]@4
  char v27; // [sp+28h] [bp-34h]@4
  char v28; // [sp+2Ah] [bp-32h]@1
  char v29; // [sp+2Bh] [bp-31h]@1
  int v30; // [sp+2Ch] [bp-30h]@1
  int v31; // [sp+30h] [bp-2Ch]@1
  int v32; // [sp+34h] [bp-28h]@1
  int v33; // [sp+38h] [bp-24h]@1
  int v34; // [sp+3Ch] [bp-20h]@1
  int v35; // [sp+40h] [bp-1Ch]@1
  int v36; // [sp+44h] [bp-18h]@1
  int v37; // [sp+48h] [bp-14h]@1
  int v38; // [sp+4Ch] [bp-10h]@1
  int v39; // [sp+50h] [bp-Ch]@1
  int v40; // [sp+54h] [bp-8h]@1

  memset(&v23, 0, 0x3Cu);
  v20 = 0i64;
  v21 = 0;
  v22 = 0;
  v18 = 0;
  v19 = 0;
  sub_10046600(a1, (int)&v23);
  v2 = v28;
  v3 = v29;
  *(_WORD *)a2 = v24;
  *(_DWORD *)(a2 + 28) = v33;
  v4 = v36;
  *(_BYTE *)(a2 + 12) = v2;
  *(_DWORD *)(a2 + 32) = v34;
  v5 = v37;
  *(_BYTE *)(a2 + 13) = v3;
  *(_DWORD *)(a2 + 36) = v35;
  v6 = v38;
  *(_DWORD *)(a2 + 40) = v4;
  v7 = v30;
  *(_DWORD *)(a2 + 44) = v5;
  v8 = v31;
  *(_DWORD *)(a2 + 16) = v7;
  v9 = v39;
  *(_DWORD *)(a2 + 20) = v8;
  v10 = v40;
  *(_DWORD *)(a2 + 48) = v6;
  v11 = BYTE3(v30) == 1;
  *(_DWORD *)(a2 + 24) = v32;
  *(_DWORD *)(a2 + 52) = v9;
  *(_DWORD *)(a2 + 56) = v10;
  if ( !v11 || sub_1007C3B0(2105, (int)&v20, 16) )
  {
    v12 = v25;
    v13 = v26;
    v14 = v27;
  }
  else
  {
    v13 = *(_DWORD *)((char *)&v20 + 6);
    v12 = *(_DWORD *)((char *)&v20 + 2);
    v14 = BYTE2(v21);
  }
  *(_DWORD *)(a2 + 2) = v12;
  *(_DWORD *)(a2 + 6) = v13;
  *(_BYTE *)(a2 + 10) = v14;
  sub_10046620((int)&v18);
  LOBYTE(v15) = v19;
  v16 = v18;
  v11 = (v19 & 1) == 0;
  *(_BYTE *)(a2 + 63) = BYTE3(v18);
  *(_BYTE *)(a2 + 60) = v16;
  *(_BYTE *)(a2 + 64) = 0;
  if ( !v11 )
    *(_BYTE *)(a2 + 64) = 1;
  *(_BYTE *)(a2 + 65) = 0;
  if ( v15 & 4 )
    *(_BYTE *)(a2 + 65) = 1;
  *(_BYTE *)(a2 + 66) = 0;
  if ( v15 & 2 )
  {
    v15 = *(_WORD *)((char *)&v18 + 1);
    *(_BYTE *)(a2 + 66) = 1;
    *(_WORD *)(a2 + 61) = v15;
  }
  else
  {
    *(_WORD *)(a2 + 61) = *(_WORD *)((char *)&v18 + 1);
  }
  return v15;
}

//----- (10052F50) --------------------------------------------------------
char __cdecl sub_10052F50(unsigned __int8 a1, char a2, int a3)
{
  char v3; // bl@1
  __int16 v4; // ax@1
  __int16 v5; // di@1
  unsigned __int8 v6; // al@7
  int v8; // [sp+Ch] [bp-Ch]@1
  int v9; // [sp+10h] [bp-8h]@1

  v8 = 0;
  v9 = 0;
  v3 = 0;
  v4 = sub_10054290(a2);
  v5 = v4;
  LOWORD(v8) = v4;
  if ( a1 >= 2u || (unsigned __int16)(v8 - 63) > 5u )
    return v3;
  v3 = 1;
  if ( (unsigned __int16)v4 < 0x42u || *(_BYTE *)a3 == 1 )
    LOBYTE(v9) = *(_BYTE *)a3;
  else
    v3 = 0;
  v6 = *(_BYTE *)(a3 + 1);
  if ( (unsigned __int16)v5 < 0x43u )
  {
    if ( v6 <= 0xCu )
    {
      HIWORD(v8) = v6;
      goto LABEL_13;
    }
    return 0;
  }
  if ( v6 > 5u )
    return 0;
  HIWORD(v8) = v6;
LABEL_13:
  if ( v3 )
  {
    sub_10024E60(1, a1 != 0 ? 1211 : 1199, &v8, 0, 8, 1);
    sub_10025010(1, a1 != 0 ? 1211 : 1199, 0xFFFFFFF);
  }
  return v3;
}

//----- (10053040) --------------------------------------------------------
int __usercall sub_10053040@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@1
  int v5[10]; // [sp+1Ch] [bp-2Ch]@1

  sub_10052DE0(a1, (int)&v4);
  result = v5[a3];
  *a2 = result;
  return result;
}
// 10053040: using guessed type int var_2C[10];

//----- (10053080) --------------------------------------------------------
int __usercall sub_10053080@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@3
  int v5[4]; // [sp+34h] [bp-14h]@3

  result = a3;
  if ( (unsigned __int8)a3 < 2u && a1 < 2u )
  {
    sub_10052DE0(a3, (int)&v4);
    result = v5[a1];
    *a2 = result;
  }
  return result;
}
// 10053080: using guessed type int var_14[4];

//----- (100530C0) --------------------------------------------------------
signed int sub_100530C0()
{
  return sub_1007CC90((int)&off_1010B360);
}
// 1010B360: using guessed type char *off_1010B360;

//----- (100530D0) --------------------------------------------------------
char __usercall sub_100530D0@<al>(int a1@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  char result; // al@7

  a1 = (unsigned __int8)a1;
  v2 = 0;
  if ( (_BYTE)a1 )
  {
    if ( a1 == 1 )
      v2 = 1393;
  }
  else
  {
    v2 = 1391;
  }
  if ( sub_1004D090((unsigned __int8 *)(a2 + 1)) && sub_1004C4F0((unsigned __int8 *)a2) )
  {
    result = 0;
  }
  else
  {
    sub_10024E60(1, v2, (void *)a2, 0, 2, 1);
    sub_10025010(1, v2, 0xFFFFFFF);
    result = 1;
  }
  return result;
}

//----- (10053140) --------------------------------------------------------
bool __usercall sub_10053140@<al>(char a1@<al>, char a2)
{
  int v2; // esi@1
  int v3; // eax@5
  bool v4; // bl@5
  char v6; // [sp+Bh] [bp-1h]@1

  v6 = a1;
  v2 = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      v2 = 1397;
  }
  else
  {
    v2 = 1395;
  }
  v3 = sub_100689B0((unsigned __int8 *)&v6);
  v4 = v3 == 0;
  if ( !v3 )
  {
    sub_10024E60(1, v2, &v6, 0, 1, 1);
    sub_10025010(1, v2, 0xFFFFFFF);
  }
  return v4;
}

//----- (100531B0) --------------------------------------------------------
bool __usercall sub_100531B0@<al>(char a1@<al>, char a2)
{
  int v2; // esi@1
  int v3; // eax@5
  bool v4; // bl@5
  char v6; // [sp+Bh] [bp-1h]@1

  v6 = a1;
  v2 = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      v2 = 1401;
  }
  else
  {
    v2 = 1399;
  }
  v3 = sub_1004C6C0((unsigned __int8 *)&v6);
  v4 = v3 == 0;
  if ( !v3 )
  {
    sub_10024E60(1, v2, &v6, 0, 1, 1);
    sub_10025010(1, v2, 0xFFFFFFF);
  }
  return v4;
}

//----- (10053220) --------------------------------------------------------
char __cdecl sub_10053220(char a1, char a2)
{
  char v2; // cl@0
  int v3; // esi@1
  int v5; // [sp+4h] [bp-18h]@1
  int v6; // [sp+8h] [bp-14h]@1
  int v7; // [sp+Ch] [bp-10h]@1
  int v8; // [sp+10h] [bp-Ch]@1
  __int16 v9; // [sp+14h] [bp-8h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  LOBYTE(v5) = a2;
  v3 = 3020;
  BYTE1(v5) = v2;
  if ( a1 )
  {
    if ( a1 == 1 )
      v3 = 2574;
  }
  else
  {
    v3 = 2573;
  }
  sub_10024E60(1, v3, &v5, 0, 18, 1);
  return sub_10025010(1, v3, 0xFFFFFFF);
}

//----- (100532B0) --------------------------------------------------------
char __usercall sub_100532B0@<al>(unsigned __int8 a1@<al>, unsigned __int8 a2@<cl>, char a3)
{
  int v3; // eax@1
  int v4; // esi@1

  v3 = a1 - 2;
  v4 = 3020;
  if ( v3 )
  {
    if ( v3 == 2 )
      v4 = (unsigned __int16)word_1010B374[2 * a2];
  }
  else
  {
    v4 = (unsigned __int16)word_1010B376[2 * a2];
  }
  sub_10024E60(1, v4, &a3, 0, 1, 1);
  return sub_10025010(1, v4, 0xFFFFFFF);
}
// 1010B374: using guessed type __int16 word_1010B374[];
// 1010B376: using guessed type __int16 word_1010B376[];

//----- (10053300) --------------------------------------------------------
char __usercall sub_10053300@<al>(signed int a1@<edx>, unsigned __int8 a2@<cl>, int a3@<esi>)
{
  unsigned __int8 v3; // bl@1
  char result; // al@1
  char v5; // al@7
  __int16 v6; // cx@7
  __int16 v7; // dx@7
  __int16 v8; // ax@7
  __int16 v9; // ax@7
  int v10; // ebx@7
  int v11; // [sp+4h] [bp-10h]@1
  int v12; // [sp+8h] [bp-Ch]@1
  int v13; // [sp+Ch] [bp-8h]@1

  v3 = a2;
  result = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  if ( a2 < 2u
    && a1 < 2
    && *(_BYTE *)(a3 + 2) <= 6u
    && *(_BYTE *)(a3 + 3) <= 3u
    && *(_BYTE *)a3 <= 8u
    && *(_BYTE *)(a3 + 1) <= 5u )
  {
    v5 = sub_10054330(a1);
    v6 = *(_BYTE *)a3;
    v7 = *(_BYTE *)(a3 + 1);
    LOBYTE(v11) = v5;
    v8 = *(_BYTE *)(a3 + 2);
    HIWORD(v11) = v6;
    HIWORD(v12) = v8;
    v9 = *(_BYTE *)(a3 + 3);
    v10 = v3 != 0 ? 1219 : 1207;
    LOWORD(v12) = v7;
    LOWORD(v13) = v9;
    sub_10024E60(1, v10, &v11, 0, 12, 1);
    sub_10025010(1, v10, 0xFFFFFFF);
    result = 1;
  }
  return result;
}

//----- (100533C0) --------------------------------------------------------
bool __usercall sub_100533C0@<al>(char a1@<al>, char a2)
{
  int v2; // esi@1
  int v3; // eax@5
  bool v4; // bl@5
  char v6; // [sp+Bh] [bp-1h]@1

  v6 = a1;
  v2 = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      v2 = 1405;
  }
  else
  {
    v2 = 1403;
  }
  v3 = sub_1004C480((unsigned __int8 *)&v6);
  v4 = v3 == 0;
  if ( !v3 )
  {
    sub_10024E60(1, v2, &v6, 0, 1, 1);
    sub_10025010(1, v2, 0xFFFFFFF);
  }
  return v4;
}

//----- (10053430) --------------------------------------------------------
char __cdecl sub_10053430(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  int v3; // esi@2
  char result; // al@2

  if ( (unsigned __int8)sub_100530C0() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_10337088 + 4 * v3 + 29);
    *(_BYTE *)a3 = *(_BYTE *)(dword_10337088 + 4 * v3 + 28);
    result = *(_BYTE *)(a2 + 2 * (3 * a1 + 72) + dword_10337088);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10337088: using guessed type int dword_10337088;

//----- (10053490) --------------------------------------------------------
char __cdecl sub_10053490(char a1, void *a2)
{
  int v2; // edx@4
  char result; // al@20

  if ( (unsigned __int8)sub_100530C0() )
  {
    if ( (sub_1003C380(a1)
       || *(_BYTE *)(dword_10337088 + 2 * (3 * (unsigned __int8)a1 + 72))
       && (v2 = dword_10337088 + 6 * (unsigned __int8)a1, *(_BYTE *)(dword_10337088 + 6 * (unsigned __int8)a1 + 145))
       && *(_BYTE *)(v2 + 146)
       && *(_BYTE *)(v2 + 147)
       && *(_BYTE *)(v2 + 148)
       && *(_BYTE *)(v2 + 149)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10337088 + 142)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10337088 + 170)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10337088 + 168)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10337088 + 166)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10337088 + 172)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10337088 + 174)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10337088 + 176))
      && *(_BYTE *)(dword_10337088 + 2 * (unsigned __int8)a1 + 158)
      && *(_BYTE *)(dword_10337088 + 2 * (unsigned __int8)a1 + 159)
      && *(_BYTE *)((unsigned __int8)a1 + dword_10337088 + 156)
      && *(_BYTE *)((unsigned __int8)a1 + dword_10337088 + 162) )
    {
      qmemcpy(a2, (const void *)(dword_10337088 + 68 * (unsigned __int8)a1), 0x44u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10337088: using guessed type int dword_10337088;

//----- (100535B0) --------------------------------------------------------
char __cdecl sub_100535B0(unsigned __int8 a1, char a2, _WORD *a3)
{
  char result; // al@4

  if ( (unsigned __int8)sub_100530C0()
    && a2 == *(_BYTE *)(a1 + dword_10337088 + 140)
    && *(_BYTE *)(a1 + dword_10337088 + 164) )
  {
    result = 1;
    *a3 = *(_WORD *)(dword_10337088 + 2 * a1 + 136);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10337088: using guessed type int dword_10337088;

//----- (10053600) --------------------------------------------------------
char __cdecl sub_10053600(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@2
  char result; // al@2

  if ( (unsigned __int8)sub_100530C0() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 2) = *(_BYTE *)(dword_10337088 + 4 * v3 + 54);
    *(_BYTE *)a3 = *(_BYTE *)(dword_10337088 + 4 * v3 + 52);
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_10337088 + 4 * v3 + 53);
    *(_BYTE *)(a3 + 3) = *(_BYTE *)(dword_10337088 + 4 * v3 + 55);
    result = *(_BYTE *)(a2 + 2 * a1 + 158 + dword_10337088);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10337088: using guessed type int dword_10337088;

//----- (10053680) --------------------------------------------------------
char __cdecl sub_10053680(int a1)
{
  void *v1; // ecx@1
  signed int v2; // eax@4
  signed int v3; // eax@22
  char result; // al@29
  char v5; // [sp+7h] [bp-9h]@1
  __int16 v6; // [sp+8h] [bp-8h]@1
  int v7; // [sp+Ch] [bp-4h]@4

  v6 = 0;
  LOBYTE(v6) = 9;
  v5 = 0;
  if ( (unsigned __int8)sub_100530C0() )
  {
    if ( sub_100460C0(v1) == 2 )
    {
      if ( !sub_1003C380(a1) )
      {
        v2 = 0;
        v7 = 0;
        do
        {
          if ( !*(_BYTE *)(2 * (3 * (unsigned __int8)a1 + 72) + dword_10337088 + v2) )
          {
            HIBYTE(v6) = v2 + 69;
            v5 = 1;
            sub_1003CAA0(a1, &v6);
            v2 = v7;
          }
          v7 = ++v2;
        }
        while ( v2 < 6 );
        if ( !*(_BYTE *)((unsigned __int8)a1 + dword_10337088 + 142) )
        {
          v5 = 1;
          HIBYTE(v6) = 99;
          sub_1003CAA0(a1, &v6);
        }
        if ( !*(_BYTE *)((unsigned __int8)a1 + dword_10337088 + 170) )
        {
          v5 = 1;
          HIBYTE(v6) = 92;
          sub_1003CAA0(a1, &v6);
        }
        if ( !*(_BYTE *)((unsigned __int8)a1 + dword_10337088 + 174) )
        {
          v5 = 1;
          HIBYTE(v6) = 108;
          sub_1003CAA0(a1, &v6);
        }
        if ( !*(_BYTE *)((unsigned __int8)a1 + dword_10337088 + 176) )
        {
          v5 = 1;
          HIBYTE(v6) = 109;
          sub_1003CAA0(a1, &v6);
        }
        if ( !*(_BYTE *)((unsigned __int8)a1 + dword_10337088 + 168) )
        {
          v5 = 1;
          HIBYTE(v6) = 91;
          sub_1003CAA0(a1, &v6);
        }
        if ( !*(_BYTE *)((unsigned __int8)a1 + dword_10337088 + 166) )
        {
          v5 = 1;
          HIBYTE(v6) = 83;
          sub_1003CAA0(a1, &v6);
        }
        if ( !*(_BYTE *)((unsigned __int8)a1 + dword_10337088 + 172) )
        {
          v5 = 1;
          HIBYTE(v6) = 103;
          sub_1003CAA0(a1, &v6);
        }
      }
      v3 = 0;
      v7 = 0;
      do
      {
        if ( !*(_BYTE *)(dword_10337088 + 2 * (unsigned __int8)a1 + 158 + v3) )
        {
          HIBYTE(v6) = v3 + 67;
          v5 = 1;
          sub_1003CAA0(a1, &v6);
          v3 = v7;
        }
        v7 = ++v3;
      }
      while ( v3 < 2 );
      if ( !*(_BYTE *)((unsigned __int8)a1 + dword_10337088 + 156) )
      {
        v5 = 1;
        HIBYTE(v6) = 64;
        sub_1003CAA0(a1, &v6);
      }
    }
    if ( *(_BYTE *)((unsigned __int8)a1 + dword_10337088 + 162) )
    {
      result = v5;
    }
    else
    {
      HIBYTE(v6) = 50;
      sub_1003CAA0(a1, &v6);
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10337088: using guessed type int dword_10337088;

//----- (100538F0) --------------------------------------------------------
char __cdecl sub_100538F0(int a1, signed int a2, int a3)
{
  char v3; // bl@1
  char result; // al@1
  __int16 v5; // ax@6
  char v6; // cl@6
  __int16 v7; // ax@6
  int v8; // eax@8
  int v9; // ebx@12
  int v10; // [sp+Ch] [bp-14h]@4
  int v11; // [sp+10h] [bp-10h]@1
  int v12; // [sp+14h] [bp-Ch]@1
  int v13; // [sp+18h] [bp-8h]@1

  v3 = a1;
  result = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 2 && *(_BYTE *)a3 < 2u )
  {
    if ( !sub_10053600(a1, a2, (int)&v10) )
    {
      sub_10053080(a2, &v10, a1);
      v3 = a1;
    }
    v5 = sub_100542C0(*(_BYTE *)(a3 + 1), *(_BYTE *)a3);
    v6 = *(_BYTE *)(a3 + 1);
    HIWORD(v12) = v5;
    v7 = sub_10054360(v6, *(_BYTE *)a3);
    LOWORD(v13) = v7;
    if ( HIWORD(v12) >= 6u || (unsigned __int16)v7 >= 3u )
    {
      result = 0;
    }
    else
    {
      LOBYTE(v11) = sub_10054330(a2);
      v8 = *(_BYTE *)a3;
      HIWORD(v11) = (unsigned __int8)v10;
      LOWORD(v12) = BYTE1(v10);
      if ( v8 )
      {
        if ( v8 == 1 )
          LOWORD(v12) = *(_BYTE *)(a3 + 1);
      }
      else
      {
        HIWORD(v11) = *(_BYTE *)(a3 + 1);
      }
      v9 = v3 != 0 ? 1219 : 1207;
      sub_10024E60(1, v9, &v11, 0, 12, 1);
      sub_10025010(1, v9, 0xFFFFFFF);
      result = 1;
    }
  }
  return result;
}

//----- (10053A50) --------------------------------------------------------
char __usercall sub_10053A50@<al>(unsigned __int8 a1@<bl>, int a2@<esi>)
{
  char result; // al@1
  int v3; // ecx@4

  result = 0;
  if ( a1 < 2u )
  {
    if ( (unsigned __int8)sub_100530C0() && *(_BYTE *)(a1 + dword_10337088 + 156) )
    {
      v3 = dword_10337088 + 68 * a1 + 16;
      *(_DWORD *)a2 = *(_DWORD *)v3;
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(v3 + 4);
      result = 1;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 8);
    }
    else
    {
      result = 0;
    }
  }
  return result;
}
// 10337088: using guessed type int dword_10337088;

//----- (10053AA0) --------------------------------------------------------
char __usercall sub_10053AA0@<al>(unsigned __int8 a1@<cl>, int a2@<edi>)
{
  int v2; // ebp@1
  char v3; // bl@5
  int v4; // eax@6
  int v5; // edx@6
  int v7; // [sp+8h] [bp-1Ch]@1
  int v8; // [sp+Ch] [bp-18h]@1
  int v9; // [sp+10h] [bp-14h]@1
  int v10; // [sp+14h] [bp-10h]@1
  int v11; // [sp+18h] [bp-Ch]@1
  int v12; // [sp+1Ch] [bp-8h]@1

  v10 = 0;
  v11 = 0;
  v12 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v2 = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      v2 = 1217;
  }
  else
  {
    v2 = 1205;
  }
  v3 = sub_10053A50(a1, (int)&v10);
  if ( v3 )
  {
    v4 = *(_DWORD *)a2;
    v5 = *(_DWORD *)(a2 + 8);
    v8 = *(_DWORD *)(a2 + 4);
    v7 = v4;
    v9 = v5;
    BYTE1(v7) = BYTE1(v10);
    sub_10024E60(1, v2, &v7, 0, 12, 1);
    sub_10025010(1, v2, 0xFFFFFFF);
  }
  return v3;
}

//----- (10053B50) --------------------------------------------------------
char __cdecl sub_10053B50(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6)
{
  char v6; // cl@2
  char result; // al@7
  unsigned __int16 v8; // ax@13

  if ( (_BYTE)a1 == 10 )
  {
    v6 = 0;
  }
  else
  {
    if ( (_BYTE)a1 != 11 )
    {
      sub_10042930("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 703, 0, 0);
      return 0;
    }
    v6 = 1;
  }
  LOBYTE(a1) = v6;
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        if ( a2 )
        {
          sub_10053080(*a4, a5, a1);
          result = 1;
        }
        else
        {
          result = sub_10053600(v6, *a4, (int)a5);
        }
      }
      else
      {
        sub_10042930("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 718, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        v8 = *a4;
        if ( a2 )
        {
          sub_10053040(v6, a5, v8);
          result = 1;
        }
        else
        {
          result = sub_10053430(v6, v8, (int)a5);
        }
      }
      else
      {
        sub_10042930("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 750, 0, 0);
        result = 0;
      }
      break;
    case 0xB:
    case 0x12:
    case 0x1C:
      if ( a6 >= 0x44 )
      {
        if ( a2 )
        {
          sub_10052DE0(v6, (int)a5);
          result = 1;
        }
        else
        {
          result = sub_10053490(v6, a5);
        }
      }
      else
      {
        sub_10042930("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 784, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10042930("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 809, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10053D00) --------------------------------------------------------
char __cdecl sub_10053D00(int a1, int a2, char a3)
{
  unsigned __int8 v3; // bl@3
  char result; // al@3
  char v5; // al@5
  int v6; // eax@8
  int v7; // edi@14
  signed int v8; // ebp@14
  int v9; // esi@14
  _DWORD *v10; // ecx@16
  unsigned int v11; // eax@16
  _DWORD *v12; // edx@16
  int v13; // edi@20
  int v14; // eax@21
  _BYTE *v15; // ecx@21
  _BYTE *v16; // edx@21
  int v17; // eax@23
  _BYTE *v18; // ecx@23
  _BYTE *v19; // edx@23
  _BYTE *v20; // ecx@25
  _BYTE *v21; // edx@25
  bool v22; // zf@27
  bool v23; // sf@27
  signed int v24; // eax@27
  int v25; // eax@35
  signed int v26; // ebp@35
  _DWORD *v27; // edx@35
  unsigned int v28; // eax@38
  _DWORD *v29; // ecx@38
  int v30; // esi@42
  int v31; // eax@43
  _BYTE *v32; // ecx@43
  _BYTE *v33; // edx@43
  int v34; // eax@45
  _BYTE *v35; // ecx@45
  _BYTE *v36; // edx@45
  _BYTE *v37; // ecx@47
  _BYTE *v38; // edx@47
  signed int v39; // eax@49
  int v40; // edi@59
  _DWORD *v41; // ecx@60
  unsigned int v42; // eax@60
  _DWORD *v43; // edx@60
  int v44; // edi@64
  int v45; // eax@65
  _BYTE *v46; // ecx@65
  _BYTE *v47; // edx@65
  int v48; // eax@67
  _BYTE *v49; // ecx@67
  _BYTE *v50; // edx@67
  _BYTE *v51; // ecx@69
  _BYTE *v52; // edx@69
  signed int v53; // eax@71
  int v54; // eax@78
  char v55; // cl@84
  int v56; // ecx@95
  int v57; // edi@95
  int v58; // ecx@95
  signed int v59; // edx@97
  char v60; // [sp+Bh] [bp-21h]@3
  int v61; // [sp+10h] [bp-1Ch]@35
  char v62[4]; // [sp+18h] [bp-14h]@1
  int v63; // [sp+1Ch] [bp-10h]@1
  int v64; // [sp+20h] [bp-Ch]@1
  int v65; // [sp+24h] [bp-8h]@1

  *(_DWORD *)v62 = 0;
  v63 = 0;
  v64 = 0;
  v65 = 0;
  if ( (unsigned __int8)a1 >= 2u || !sub_1003C270(*(_WORD *)a2) )
    return 0;
  v3 = a1;
  v60 = sub_1003CCA0(a1, v62);
  HIWORD(v65) = *(_WORD *)a2;
  sub_100421E0((int)&v62[2], (_BYTE *)(a2 + 2), 9);
  result = v60;
  if ( v60 )
  {
    if ( !(unsigned __int8)sub_100530C0() )
      return v60;
    v5 = a3;
    if ( a3 == 11 || a3 == 18 )
    {
      if ( !*(_BYTE *)((unsigned __int8)a1 + dword_10337088 + 162)
        || (v6 = dword_10337088 + 68 * (unsigned __int8)a1, HIWORD(v65) != *(_WORD *)v6)
        || strncmp(&v62[2], (const char *)(v6 + 2), 8u) )
      {
        v60 = sub_1003CDD0(a1, (int)v62);
      }
      v5 = a3;
    }
    if ( v5 == 11 || v5 == 28 )
    {
      v7 = (unsigned __int8)a1;
      v8 = 0;
      v9 = a2 + 52;
      do
      {
        if ( !*(_BYTE *)(dword_10337088 + 2 * v7 + 158 + v8) )
          goto LABEL_112;
        v10 = (_DWORD *)(dword_10337088 + 4 * (v7 + v8 + 16 * v7) + 52);
        v11 = 4;
        v12 = (_DWORD *)v9;
        do
        {
          if ( *v12 != *v10 )
            goto LABEL_20;
          v11 -= 4;
          ++v10;
          ++v12;
        }
        while ( v11 >= 4 );
        if ( !v11 )
          goto LABEL_30;
LABEL_20:
        v13 = *(_BYTE *)v12 - *(_BYTE *)v10;
        if ( *(_BYTE *)v12 == *(_BYTE *)v10 )
        {
          v14 = v11 - 1;
          v15 = (char *)v10 + 1;
          v16 = (char *)v12 + 1;
          if ( !v14
            || (v13 = *v16 - *v15, *v16 == *v15)
            && ((v17 = v14 - 1, v18 = v15 + 1, v19 = v16 + 1, !v17)
             || (v13 = *v19 - *v18, *v19 == *v18)
             && ((v20 = v18 + 1, v21 = v19 + 1, v17 == 1) || (v13 = *v21 - *v20, *v21 == *v20))) )
          {
            v7 = (unsigned __int8)a1;
LABEL_30:
            v3 = a1;
            v24 = 0;
            goto LABEL_31;
          }
        }
        v3 = a1;
        v22 = v13 == 0;
        v23 = v13 < 0;
        v7 = (unsigned __int8)a1;
        v24 = 1;
        if ( v23 || v22 )
          v24 = -1;
LABEL_31:
        if ( v24 )
LABEL_112:
          sub_10053300(v8, v3, v9);
        ++v8;
        v9 += 4;
      }
      while ( v8 < 2 );
      if ( !sub_1003C380(v3) )
      {
        v25 = 2 * (3 * v7 + 72);
        v26 = 0;
        v27 = (_DWORD *)(a2 + 28);
        v61 = a2 + 28;
        while ( 1 )
        {
          if ( !*(_BYTE *)(dword_10337088 + v25 + v26) )
            goto LABEL_113;
          v28 = 4;
          v29 = (_DWORD *)(dword_10337088 + 4 * (v7 + v26 + 16 * v7) + 28);
          do
          {
            if ( *v27 != *v29 )
              goto LABEL_42;
            v28 -= 4;
            ++v29;
            ++v27;
          }
          while ( v28 >= 4 );
          if ( !v28 )
            goto LABEL_52;
LABEL_42:
          v30 = *(_BYTE *)v27 - *(_BYTE *)v29;
          if ( *(_BYTE *)v27 == *(_BYTE *)v29 )
          {
            v31 = v28 - 1;
            v32 = (char *)v29 + 1;
            v33 = (char *)v27 + 1;
            if ( !v31
              || (v30 = *v33 - *v32, *v33 == *v32)
              && ((v34 = v31 - 1, v35 = v32 + 1, v36 = v33 + 1, !v34)
               || (v30 = *v36 - *v35, *v36 == *v35)
               && ((v37 = v35 + 1, v38 = v36 + 1, v34 == 1) || (v30 = *v38 - *v37, *v38 == *v37))) )
            {
              v3 = a1;
LABEL_52:
              v39 = 0;
              goto LABEL_53;
            }
          }
          v3 = a1;
          v39 = 1;
          if ( v30 <= 0 )
            v39 = -1;
LABEL_53:
          if ( v39 )
LABEL_113:
            sub_10052F50(v3, v26, v61);
          ++v26;
          v27 = (_DWORD *)(v61 + 4);
          v61 += 4;
          if ( v26 >= 6 )
            break;
          v25 = 2 * (3 * v7 + 72);
        }
      }
      v5 = a3;
    }
    if ( v5 != 11 && v5 != 18 )
      return v60;
    v40 = a2;
    if ( !*(_BYTE *)(v3 + dword_10337088 + 156) )
      goto LABEL_76;
    v41 = (_DWORD *)(dword_10337088 + 68 * v3 + 16);
    v42 = 12;
    v43 = (_DWORD *)(a2 + 16);
    do
    {
      if ( *v43 != *v41 )
        goto LABEL_64;
      v42 -= 4;
      ++v41;
      ++v43;
    }
    while ( v42 >= 4 );
    if ( v42 )
    {
LABEL_64:
      v44 = *(_BYTE *)v43 - *(_BYTE *)v41;
      if ( *(_BYTE *)v43 != *(_BYTE *)v41
        || (v45 = v42 - 1, v46 = (char *)v41 + 1, v47 = (char *)v43 + 1, v45)
        && ((v44 = *v47 - *v46, *v47 != *v46)
         || (v48 = v45 - 1, v49 = v46 + 1, v50 = v47 + 1, v48)
         && ((v44 = *v50 - *v49, *v50 != *v49)
          || (v51 = v49 + 1, v52 = v50 + 1, v48 != 1) && (v44 = *v52 - *v51, *v52 != *v51))) )
      {
        v22 = v44 == 0;
        v23 = v44 < 0;
        v40 = a2;
        v53 = 1;
        if ( v23 || v22 )
          v53 = -1;
LABEL_75:
        if ( !v53 )
        {
LABEL_77:
          if ( sub_1003C380(v3) )
            return v60;
          v54 = dword_10337088;
          if ( !*(_BYTE *)(v3 + dword_10337088 + 170)
            || *(_BYTE *)(v40 + 64) != *(_BYTE *)(dword_10337088 + 68 * v3 + 64) )
          {
            sub_100531B0(*(_BYTE *)(v40 + 64), v3);
            v54 = dword_10337088;
          }
          if ( !*(_BYTE *)(v3 + v54 + 142)
            || *(_BYTE *)(v40 + 12) != *(_BYTE *)(v54 + 68 * v3 + 12)
            || *(_BYTE *)(v40 + 13) != *(_BYTE *)(v54 + 68 * v3 + 13) )
          {
            v55 = *(_BYTE *)(v40 + 13);
            sub_10053220(v3, *(_BYTE *)(v40 + 12));
            v54 = dword_10337088;
          }
          if ( !*(_BYTE *)(v3 + v54 + 174) || *(_BYTE *)(v40 + 65) != *(_BYTE *)(v54 + 68 * v3 + 65) )
          {
            sub_100532B0(4u, v3, *(_BYTE *)(v40 + 65));
            v54 = dword_10337088;
          }
          if ( !*(_BYTE *)(v3 + v54 + 176) || *(_BYTE *)(v40 + 66) != *(_BYTE *)(v54 + 68 * v3 + 66) )
          {
            sub_100532B0(2u, v3, *(_BYTE *)(v40 + 66));
            v54 = dword_10337088;
          }
          if ( !*(_BYTE *)(v3 + v54 + 168) || *(_BYTE *)(v40 + 63) != *(_BYTE *)(v54 + 68 * v3 + 63) )
          {
            sub_10053140(*(_BYTE *)(v40 + 63), v3);
            v54 = dword_10337088;
          }
          if ( *(_BYTE *)(v3 + v54 + 166) )
          {
            v56 = *(_BYTE *)(v40 + 61);
            v57 = v40 + 61;
            v58 = v56 - *(_BYTE *)(v54 + 68 * v3 + 61);
            if ( v58
              || (v58 = *(_BYTE *)(v57 + 1) - *(_BYTE *)(v54 + 68 * v3 + 62),
                  *(_BYTE *)(v57 + 1) != *(_BYTE *)(v54 + 68 * v3 + 62)) )
            {
              v59 = 1;
              if ( v58 <= 0 )
                v59 = -1;
            }
            else
            {
              v59 = 0;
            }
            if ( !v59 )
              goto LABEL_103;
            v40 = a2;
          }
          LOBYTE(v54) = v3;
          sub_100530D0(v54, v40 + 61);
          v54 = dword_10337088;
LABEL_103:
          if ( !*(_BYTE *)(v3 + v54 + 172) || *(_BYTE *)(a2 + 60) != *(_BYTE *)(v54 + 68 * v3 + 60) )
            sub_100533C0(*(_BYTE *)(a2 + 60), v3);
          return v60;
        }
LABEL_76:
        sub_10053AA0(v3, v40 + 16);
        v40 = a2;
        goto LABEL_77;
      }
      v40 = a2;
    }
    v53 = 0;
    goto LABEL_75;
  }
  return result;
}
// 10337088: using guessed type int dword_10337088;

//----- (10054290) --------------------------------------------------------
__int16 __cdecl sub_10054290(char a1)
{
  return word_1010B3A4[4 * sub_10043FF0(&a1, 4u, (int)&unk_1010B3A0, 8, 6, 6)];
}
// 1010B3A4: using guessed type __int16 word_1010B3A4[];

//----- (100542C0) --------------------------------------------------------
__int16 __cdecl sub_100542C0(char a1, char a2)
{
  int v2; // eax@3
  int v4; // eax@5

  if ( a2 )
  {
    if ( a2 == 1 )
    {
      v2 = sub_10043FF0(&a1, 2u, (int)&unk_1010B418, 8, 4, -1);
      if ( v2 > -1 )
        return word_1010B41C[4 * v2];
    }
  }
  else
  {
    v4 = sub_10043FF0(&a1, 2u, (int)&unk_1010B3E0, 8, 7, -1);
    if ( v4 > -1 )
      return word_1010B3E4[4 * v4];
  }
  return 6;
}
// 1010B3E4: using guessed type __int16 word_1010B3E4[];
// 1010B41C: using guessed type __int16 word_1010B41C[];

//----- (10054330) --------------------------------------------------------
char __cdecl sub_10054330(char a1)
{
  return byte_1010B3D4[8 * sub_10043FF0(&a1, 4u, (int)&unk_1010B3D0, 8, 2, 2)];
}

//----- (10054360) --------------------------------------------------------
__int16 __cdecl sub_10054360(char a1, char a2)
{
  int v2; // eax@3
  int v4; // eax@5

  if ( a2 )
  {
    if ( a2 == 1 )
    {
      v2 = sub_10043FF0(&a1, 2u, (int)&unk_1010B418, 8, 4, -1);
      if ( v2 > -1 )
        return word_1010B41E[4 * v2];
    }
  }
  else
  {
    v4 = sub_10043FF0(&a1, 2u, (int)&unk_1010B3E0, 8, 7, -1);
    if ( v4 > -1 )
      return word_1010B3E6[4 * v4];
  }
  return 3;
}
// 1010B3E6: using guessed type __int16 word_1010B3E6[];
// 1010B41E: using guessed type __int16 word_1010B41E[];

//----- (100543D0) --------------------------------------------------------
signed int __cdecl sub_100543D0(_BYTE *a1, char a2, int a3)
{
  signed int result; // eax@1

  result = -4;
  if ( a3 && a3 != 1 || (!*a1 || *a1 == 1 ? (result = 0) : (result = -2), a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_11;
  }
  if ( result )
  {
LABEL_11:
    *a1 = a2;
    result = 1;
  }
  return result;
}

//----- (10054420) --------------------------------------------------------
int __cdecl sub_10054420(int a1, float a2, float a3, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  char v7; // dl@4
  char v8; // al@4
  char v9; // dl@4
  int result; // eax@5
  double v11; // st7@7
  unsigned int v12; // eax@21

  v5 = a1;
  v6 = a1 & 3;
  if ( a1 & 3 || (unsigned int)&a1 & 3 )
  {
    v7 = *(_BYTE *)(a1 + 1);
    LOBYTE(a1) = *(_BYTE *)a1;
    v8 = *(_BYTE *)(v5 + 2);
    BYTE1(a1) = v7;
    v9 = *(_BYTE *)(v5 + 3);
    BYTE2(a1) = v8;
    BYTE3(a1) = v9;
  }
  else
  {
    a1 = *(int *)a1;
  }
  result = -4;
  if ( a5 && a5 != 1
    || ((v11 = *(float *)&a1, (a1 & 0x7F800000) != 2139095040) ? (a2 <= v11 ? (a3 >= v11 ? (result = 0) : (result = -2)) : (result = -1)) : (result = -3),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v12 = a4;
    *(_BYTE *)(v5 + 1) = BYTE1(a4);
    *(_BYTE *)v5 = v12;
    *(_BYTE *)(v5 + 3) = BYTE3(v12);
    *(_BYTE *)(v5 + 2) = v12 >> 16;
    result = 1;
  }
  else
  {
    *(_DWORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10054510) --------------------------------------------------------
unsigned int __cdecl sub_10054510(char *a1, char a2, char a3, char a4, int a5)
{
  char v5; // dl@1
  unsigned int result; // eax@1
  int v7; // eax@5

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1
    || (v5 >= a2 ? (v7 = v5 < a3, LOBYTE(v7) = v5 <= a3, result = (v7 - 1) & 0xFFFFFFFE) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (10054560) --------------------------------------------------------
unsigned int __cdecl sub_10054560(_BYTE *a1, __int16 a2, __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  int v8; // eax@9
  char v9; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((signed __int16)a1 >= a2 ? (v8 = (signed __int16)a1 < a3,
                                    LOBYTE(v8) = (signed __int16)a1 <= a3,
                                    result = (v8 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v9 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v9;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10054600) --------------------------------------------------------
unsigned int __cdecl sub_10054600(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  _BYTE *v8; // esi@3
  int v9; // eax@9
  signed int v10; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((signed int)v8 >= a2 ? (v9 = (signed int)v8 < a3,
                                LOBYTE(v9) = (signed int)v8 <= a3,
                                result = (v9 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v10 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v10;
    v5[3] = BYTE3(v10);
    v5[2] = v10 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (100546C0) --------------------------------------------------------
unsigned int __cdecl sub_100546C0(void *a1, size_t a2, int a3)
{
  unsigned int result; // eax@1
  int v4; // eax@3
  int v5; // ecx@3
  unsigned int v6; // ecx@3

  result = -4;
  if ( a3 && a3 != 1
    || (v4 = sub_100422A0(a1, a2), v5 = v4 < 0, LOBYTE(v5) = v4 >= 0, v6 = (v5 - 1) & 0xFFFFFFFC, result = v6, a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_7;
  }
  if ( v6 )
  {
LABEL_7:
    memset(a1, 0, a2);
    result = 1;
  }
  return result;
}

//----- (10054720) --------------------------------------------------------
int __cdecl sub_10054720(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
  unsigned __int8 v5; // dl@1
  int result; // eax@1

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1 || (v5 >= a2 ? (result = a3 < v5 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (10054770) --------------------------------------------------------
int __cdecl sub_10054770(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // esi@1
  int result; // eax@1
  char v8; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned __int16)a1 >= a2 ? (result = a3 < (unsigned __int16)a1 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v8 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v8;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10054810) --------------------------------------------------------
int __cdecl sub_10054810(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  int result; // eax@1
  _BYTE *v8; // esi@3
  unsigned int v9; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned int)v8 >= a2 ? (result = a3 < (unsigned int)v8 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v9 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v9;
    v5[3] = BYTE3(v9);
    v5[2] = v9 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (100548C0) --------------------------------------------------------
char *__cdecl sub_100548C0(int a1, int a2, int a3, size_t a4, char *a5)
{
  char v5; // cl@1
  int v6; // eax@1
  int v7; // esi@1
  int v8; // edi@2
  char *v9; // eax@14
  char *v10; // eax@14
  char *v11; // eax@15
  unsigned int v12; // ecx@19
  char v13; // cl@20
  bool v14; // zf@21
  char *v15; // ecx@21
  char v17[256]; // [sp+Ch] [bp-104h]@8

  v5 = *(_BYTE *)a1;
  v6 = 0;
  v7 = 0;
  if ( !*(_BYTE *)a1 )
    goto LABEL_12;
  v8 = a1;
  do
  {
    if ( v5 == 46 )
    {
      v7 = v6;
    }
    else if ( v5 == 47 || v5 == 92 )
    {
      v6 = 0;
      v7 = 0;
      goto LABEL_9;
    }
    v17[v6++] = v5;
LABEL_9:
    v5 = *(_BYTE *)(v8++ + 1);
  }
  while ( v5 );
  if ( v7 )
  {
    v17[v7] = 0;
    goto LABEL_13;
  }
LABEL_12:
  v17[v6] = 0;
LABEL_13:
  switch ( a2 )
  {
    case 1:
      v9 = sub_100737C0("CFG_ActDir", (int)&byte_100930C0);
      v10 = sub_100737C0("CFG_ActDirRuntime", (int)v9);
      break;
    case 2:
      v11 = sub_100737C0("CFG_ExpDir", (int)&byte_100930C0);
      v10 = sub_100737C0("CFG_ExpDirRuntime", (int)v11);
      break;
    case 3:
      v10 = sub_100737C0("CFG_ActDir", (int)&byte_100930C0);
      break;
    case 4:
      v10 = sub_100737C0("CFG_ExpDir", (int)&byte_100930C0);
      break;
    default:
      v10 = &byte_100930C0;
      break;
  }
  v12 = strlen(v10);
  if ( !v12 || (v13 = v10[v12 - 1], v13 == 47) || (v14 = v13 == 92, v15 = "/", v14) )
    v15 = &byte_100930C0;
  _snprintf(a5, a4, "%s%s%s_%s.bmp", v10, v15, v17, a3);
  a5[a4 - 1] = 0;
  return a5;
}
// 100548C0: using guessed type char var_104[256];

//----- (10054A40) --------------------------------------------------------
int sub_10054A40()
{
  return dword_1028D600[sub_100648A0()];
}
// 1028D600: using guessed type int dword_1028D600[];

//----- (10054A50) --------------------------------------------------------
const char *__cdecl sub_10054A50(unsigned int a1)
{
  const char *result; // eax@2

  if ( a1 >= 3 )
    result = "Unknown Type Of Testing";
  else
    result = off_1010B524[a1];
  return result;
}
// 1010B524: using guessed type char *off_1010B524[7];

//----- (10054A70) --------------------------------------------------------
int __cdecl sub_10054A70(int a1, int a2, int a3, int a4)
{
  char v5; // [sp+8h] [bp-204h]@1
  char v6; // [sp+107h] [bp-105h]@1
  char v7; // [sp+108h] [bp-104h]@1
  char v8; // [sp+207h] [bp-5h]@1

  _snprintf(&v5, 0x100u, "%d", a3);
  v6 = 0;
  _snprintf(&v7, 0x100u, "%d", a4);
  v8 = 0;
  return sub_10059C20(3, (int)"**SUBGROUP**", a1, a2, (int)&v5, (int)&v7);
}

//----- (10054B20) --------------------------------------------------------
int __cdecl sub_10054B20(int a1)
{
  int result; // eax@1

  result = sub_100648A0();
  dword_1028F70C[result] = a1;
  return result;
}
// 1028F70C: using guessed type int dword_1028F70C[];

//----- (10054B40) --------------------------------------------------------
int __cdecl sub_10054B40(int a1)
{
  int result; // eax@1

  result = sub_100648A0();
  dword_1028D600[result] = a1;
  return result;
}
// 1028D600: using guessed type int dword_1028D600[];

//----- (10054B60) --------------------------------------------------------
char *sub_10054B60(char *a1, ...)
{
  int v1; // esi@1
  char *result; // eax@1
  va_list va; // [sp+10h] [bp+8h]@1

  va_start(va, a1);
  v1 = sub_100648A0() << 8;
  _vsnprintf(&byte_10288A10[v1], 0x100u, a1, va);
  result = &byte_10288A10[v1];
  byte_10288B0E[v1] = 42;
  byte_10288B0F[v1] = 0;
  return result;
}

//----- (10054BA0) --------------------------------------------------------
char *__usercall sub_10054BA0@<eax>(char a1@<al>, unsigned __int8 a2@<cl>)
{
  char *result; // eax@3

  if ( a2 && a2 != 1 )
    result = off_1010B538[a1 & 1];
  else
    result = off_1010B530[a2];
  return result;
}
// 1010B530: using guessed type char *off_1010B530[4];
// 1010B538: using guessed type char *off_1010B538[2];

//----- (10054BC0) --------------------------------------------------------
char __usercall sub_10054BC0@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5)
{
  const char *v5; // ebp@1
  int v6; // edi@1
  char v7; // cl@1
  char result; // al@5
  long double v9; // st7@6
  signed int v10; // eax@7
  int v11; // ecx@10
  int v12; // ebp@10
  int v13; // edx@10
  int v14; // edi@10
  int v15; // edi@16
  int v16; // eax@30
  char v17; // [sp+18h] [bp+4h]@1

  v5 = a2;
  v6 = sub_100648A0();
  v17 = a2[a3 - 2];
  v7 = v17;
  if ( v17 == 100 || v17 == 117 )
  {
    v16 = sub_10054A40() - 1;
    if ( v16 )
    {
      if ( v16 == 1 )
      {
        strncpy((char *)(a1 + 1), v5, a4 - 1);
        *(_BYTE *)(a1 + 1) = 35;
        *(_BYTE *)a1 = 37;
        result = 0;
        *(_BYTE *)(a3 + a1 - 1) = 111;
      }
      else
      {
        strncpy((char *)a1, v5, a4);
        result = 0;
      }
    }
    else
    {
      strncpy((char *)(a1 + 1), v5, a4 - 1);
      *(_BYTE *)(a1 + 1) = 35;
      *(_BYTE *)a1 = 37;
      result = 0;
      *(_BYTE *)(a3 + a1 - 1) = 120;
    }
  }
  else if ( v17 == 102 || v17 == 103 )
  {
    v9 = fabs(a5);
    if ( 0.0 == v9 )
    {
      v10 = 0;
    }
    else
    {
      v10 = (signed int)floor(log10(v9));
      v7 = v17;
    }
    if ( v7 == 102 )
    {
      v11 = dword_10290D00[v6];
      v12 = dword_10290D14[v6];
      v13 = v11 + v10;
      v14 = v11 + v10;
      if ( v11 + v10 >= 9 )
        v14 = 9;
      if ( v11 <= v14 )
      {
        if ( v13 >= 9 )
          v13 = 9;
      }
      else
      {
        v13 = v11;
      }
    }
    else
    {
      v11 = dword_1028D614[v6];
      v12 = dword_1028F6F8[v6];
      v13 = v11 + v10;
      v15 = v11 + v10;
      if ( v11 + v10 >= 14 )
        v15 = 14;
      if ( v11 <= v15 )
      {
        if ( v13 >= 14 )
          v13 = 14;
      }
      else
      {
        v13 = v11;
      }
    }
    if ( v12 )
    {
      if ( v12 == 1 )
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
      else if ( v11 <= v10 || v10 < -4 )
      {
        _snprintf((char *)a1, a4, "%%.%de", v13);
        result = 1;
      }
      else
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
    }
    else
    {
      _snprintf((char *)a1, a4, "%%.%de", v13);
      result = 1;
    }
  }
  else
  {
    strncpy((char *)a1, v5, a4);
    result = 0;
  }
  return result;
}
// 1028D614: using guessed type int dword_1028D614[];
// 1028F6F8: using guessed type int dword_1028F6F8[];
// 10290D00: using guessed type int dword_10290D00[];
// 10290D14: using guessed type int dword_10290D14[];

//----- (10054DA0) --------------------------------------------------------
int sub_10054DA0()
{
  nullsub_1("..\\lib\\utf\\utf_verify.c");
  return 0;
}

//----- (10054DC0) --------------------------------------------------------
int sub_10054DC0()
{
  return nullsub_1("..\\lib\\utf\\utf_verify.c");
}

//----- (10054DE0) --------------------------------------------------------
int __cdecl sub_10054DE0(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_100648A0();
  dword_1028F6F8[result] = a1;
  if ( a2 >= 0 )
  {
    dword_1028D614[result] = a2;
    if ( a2 > 14 )
    {
      v3 = sub_10054B60(
             "Floating point (double) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             14);
      result = sub_10059BE0(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"909", (int)v3);
    }
  }
  else
  {
    dword_1028D614[result] = 8;
  }
  return result;
}
// 1028D614: using guessed type int dword_1028D614[];
// 1028F6F8: using guessed type int dword_1028F6F8[];

//----- (10054E40) --------------------------------------------------------
int __cdecl sub_10054E40(int a1)
{
  return sub_10054DE0(0, a1);
}

//----- (10054E50) --------------------------------------------------------
int __cdecl sub_10054E50(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_100648A0();
  dword_10290D14[result] = a1;
  if ( a2 >= 0 )
  {
    dword_10290D00[result] = a2;
    if ( a2 > 9 )
    {
      v3 = sub_10054B60(
             "Floating point (float) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             9);
      result = sub_10059BE0(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"977", (int)v3);
    }
  }
  else
  {
    dword_10290D00[result] = 8;
  }
  return result;
}
// 10290D00: using guessed type int dword_10290D00[];
// 10290D14: using guessed type int dword_10290D14[];

//----- (10054EB0) --------------------------------------------------------
int __cdecl sub_10054EB0(int a1)
{
  return sub_10054E50(0, a1);
}

//----- (10054EC0) --------------------------------------------------------
bool __cdecl sub_10054EC0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  bool v8; // bl@4
  char *v9; // eax@7
  char *v10; // edx@7
  int v11; // esi@8
  int v12; // edi@19
  char *v14; // [sp+Ch] [bp-2Ch]@7
  int v15; // [sp+10h] [bp-28h]@7
  int v16; // [sp+14h] [bp-24h]@7
  int v17; // [sp+18h] [bp-20h]@7
  char *v18; // [sp+1Ch] [bp-1Ch]@7
  char *v19; // [sp+20h] [bp-18h]@7
  const char *v20; // [sp+24h] [bp-14h]@7
  char *v21; // [sp+28h] [bp-10h]@7
  char *v22; // [sp+2Ch] [bp-Ch]@7
  int v23; // [sp+30h] [bp-8h]@8
  int v24; // [sp+34h] [bp-4h]@8

  if ( a2 )
  {
    if ( a6 == 1 )
    {
      if ( a7 )
        goto LABEL_4;
    }
    else if ( a6 || a7 != 1 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
  else
  {
    if ( a6 == 1 )
    {
      if ( a7 != 1 )
      {
LABEL_4:
        v8 = 0;
        goto LABEL_5;
      }
    }
    else if ( a6 || a7 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
LABEL_5:
  if ( sub_10065800() )
    v8 = v8 == 0;
  v9 = (&off_1010B508)[4 * a2];
  v15 = a3;
  v14 = v9;
  v17 = a5;
  v16 = a4;
  v20 = "bool";
  v10 = off_1010B4F8[v8 != 0];
  v19 = off_1010B500[a1];
  v18 = v10;
  v21 = sub_10054BA0(0, a6);
  v22 = sub_10054BA0(1, a7);
  if ( a8 )
  {
    v23 = 0;
    v24 = a8;
    v11 = 11;
  }
  else
  {
    v11 = 9;
  }
  v12 = sub_10010730();
  sub_10059AF0(7, (int)&v14, v11);
  sub_10073B10(v12);
  return v8;
}
// 1010B4F8: using guessed type char *off_1010B4F8[5];
// 1010B500: using guessed type char *off_1010B500[3];
// 1010B508: using guessed type char *off_1010B508;

//----- (10055000) --------------------------------------------------------
bool __cdecl sub_10055000(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  int v8; // edi@1
  unsigned __int8 v9; // al@14
  unsigned __int8 v10; // al@17
  int v11; // edi@25
  char *v12; // esi@26
  char *v13; // edx@28
  int v14; // ebx@30
  bool v16; // [sp+1Bh] [bp-5Dh]@2
  char v17; // [sp+1Fh] [bp-59h]@25
  unsigned int v18; // [sp+20h] [bp-58h]@1
  char *v19; // [sp+3Ch] [bp-3Ch]@28
  int v20; // [sp+40h] [bp-38h]@28
  int v21; // [sp+44h] [bp-34h]@28
  int v22; // [sp+48h] [bp-30h]@28
  char *v23; // [sp+4Ch] [bp-2Ch]@28
  char *v24; // [sp+50h] [bp-28h]@28
  const char *v25; // [sp+54h] [bp-24h]@28
  const char *v26; // [sp+58h] [bp-20h]@28
  const char *v27; // [sp+5Ch] [bp-1Ch]@28
  char *v28; // [sp+60h] [bp-18h]@28
  int v29; // [sp+64h] [bp-14h]@29
  char v30; // [sp+68h] [bp-10h]@25

  v8 = sub_100648A0();
  v18 = 9;
  switch ( a2 )
  {
    case 0:
      v16 = a6 == a7;
      break;
    case 1:
      v16 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 4:
      v16 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 6:
      if ( a7 )
        v9 = a7;
      else
        v9 = 0;
      if ( a6 < v9 )
        goto LABEL_38;
      v10 = a7;
      if ( (signed int)a7 >= 255 )
        v10 = -1;
      v16 = 1;
      if ( a6 > v10 )
LABEL_38:
        v16 = 0;
      v18 = 10;
      break;
    default:
LABEL_22:
      v16 = 0;
      break;
  }
  if ( sub_10065800() )
    v16 = v16 == 0;
  sub_10054BC0((int)&v30, "%c", 3, 0xCu, (double)a6);
  v11 = 3072 * v8;
  _snprintf(&byte_10289A00[v11], 0x400u, &v30, a6);
  byte_10289DFE[v11] = 42;
  byte_10289DFF[v11] = 0;
  v17 = sub_10054BC0((int)&v30, "%c", 3, 0xCu, (double)a7);
  _snprintf(&byte_10289E00[v11], 0x400u, &v30, a7);
  byte_1028A1FE[v11] = 42;
  byte_1028A1FF[v11] = 0;
  if ( v18 <= 9 )
  {
    v12 = &byte_1028A200[v11];
    byte_1028A200[v11] = 0;
  }
  else
  {
    v17 = sub_10054BC0((int)&v30, "%c", 3, 0xCu, 0.0);
    v12 = &byte_1028A200[v11];
    _snprintf(&byte_1028A200[v11], 0x400u, &v30, 0);
    byte_1028A5FE[v11] = 42;
    byte_1028A5FF[v11] = 0;
  }
  v19 = (&off_1010B508)[4 * a2];
  v21 = a4;
  v22 = a5;
  v20 = a3;
  v25 = "char";
  v26 = &byte_10289A00[v11];
  v27 = &byte_10289E00[v11];
  v13 = off_1010B500[a1];
  v23 = off_1010B4F8[v16 != 0];
  v24 = v13;
  v28 = v12;
  if ( a8 )
  {
    v29 = a8;
    v18 = 11;
  }
  v14 = sub_10010730();
  sub_10059AF0(7, (int)&v19, v18);
  if ( v17 && a6 != a7 && fabs((double)(a6 - a7)) > 0.0 && !strcmp(v26, v27) )
  {
    nullsub_1(a3);
    sub_10059BE0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10073B10(v14);
  return v16;
}
// 1010B4F8: using guessed type char *off_1010B4F8[5];
// 1010B500: using guessed type char *off_1010B500[3];
// 1010B508: using guessed type char *off_1010B508;

//----- (100553B0) --------------------------------------------------------
bool __cdecl sub_100553B0(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9)
{
  double v9; // st6@1
  long double v10; // st7@4
  int v11; // edi@8
  int v12; // edi@21
  char *v13; // esi@22
  double v14; // st5@28
  double v15; // st3@30
  double v16; // st5@30
  char *v17; // ecx@37
  int v18; // ebx@39
  bool v20; // [sp+27h] [bp-61h]@10
  char v21; // [sp+2Bh] [bp-5Dh]@21
  unsigned int v22; // [sp+2Ch] [bp-5Ch]@8
  char *v23; // [sp+4Ch] [bp-3Ch]@37
  int v24; // [sp+50h] [bp-38h]@37
  int v25; // [sp+54h] [bp-34h]@37
  int v26; // [sp+58h] [bp-30h]@37
  char *v27; // [sp+5Ch] [bp-2Ch]@37
  char *v28; // [sp+60h] [bp-28h]@37
  const char *v29; // [sp+64h] [bp-24h]@37
  const char *v30; // [sp+68h] [bp-20h]@37
  const char *v31; // [sp+6Ch] [bp-1Ch]@37
  char *v32; // [sp+70h] [bp-18h]@37
  int v33; // [sp+74h] [bp-14h]@38
  char v34; // [sp+78h] [bp-10h]@21

  v9 = a8;
  if ( a2 != 6
    || -0.000001 != a8
    || (a7 >= 0.0 ? (v9 = a7 * 0.000001, v10 = 0.000001) : (v10 = 0.000001, v9 = -0.000001 * a7), v9 >= v10) )
  {
    v10 = v9;
  }
  v11 = sub_100648A0();
  v22 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 1:
      v20 = a7 != a6;
      break;
    case 2:
      if ( a7 != a6 && a7 < a6 )
        goto LABEL_18;
      goto LABEL_14;
    case 3:
      if ( a7 == a6 || a7 < a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 5:
      if ( a7 != a6 && a7 >= a6 )
        goto LABEL_18;
LABEL_14:
      v20 = 1;
      break;
    case 6:
      v14 = v10 - 1.797693134862316e308;
      if ( a7 > v10 - 1.797693134862316e308 )
        v14 = a7;
      v15 = v14;
      v16 = a7;
      if ( v15 - v10 > a6 )
        goto LABEL_47;
      if ( 1.797693134862316e308 - v10 <= a7 )
        v16 = 1.797693134862316e308 - v10;
      if ( v10 + v16 < a6 )
      {
LABEL_47:
        v20 = 0;
        v22 = 10;
      }
      else
      {
        v20 = 1;
        v22 = 10;
      }
      break;
    default:
LABEL_18:
      v20 = 0;
      break;
  }
  if ( sub_10065800() )
    v20 = v20 == 0;
  sub_10054BC0((int)&v34, (char *)&unk_1010B810, 3, 0xCu, a6);
  v12 = 3072 * v11;
  _snprintf(&byte_10289A00[v12], 0x400u, &v34);
  byte_10289DFE[v12] = 42;
  byte_10289DFF[v12] = 0;
  v21 = sub_10054BC0((int)&v34, (char *)&unk_1010B810, 3, 0xCu, a7);
  _snprintf(&byte_10289E00[v12], 0x400u, &v34, a7);
  byte_1028A1FE[v12] = 42;
  byte_1028A1FF[v12] = 0;
  if ( v22 <= 9 )
  {
    v13 = &byte_1028A200[v12];
    byte_1028A200[v12] = 0;
  }
  else
  {
    v13 = &byte_1028A200[v12];
    v21 = sub_10054BC0((int)&v34, (char *)&unk_1010B810, 3, 0xCu, v10);
    _snprintf(&byte_1028A200[v12], 0x400u, &v34, LODWORD(v10), (_DWORD)(*(unsigned __int64 *)&v10 >> 32));
    byte_1028A5FE[v12] = 42;
    byte_1028A5FF[v12] = 0;
  }
  v23 = (&off_1010B508)[4 * a2];
  v26 = a5;
  v25 = a4;
  v24 = a3;
  v29 = "double";
  v30 = &byte_10289A00[v12];
  v32 = v13;
  v17 = off_1010B500[a1];
  v27 = off_1010B4F8[v20 != 0];
  v28 = v17;
  v31 = &byte_10289E00[v12];
  if ( a9 )
  {
    v33 = a9;
    v22 = 11;
  }
  v18 = sub_10010730();
  sub_10059AF0(7, (int)&v23, v22);
  if ( v21 && a6 != a7 && fabs(a6 - a7) > v10 && !strcmp(v30, v31) )
  {
    nullsub_1(a3);
    sub_10059BE0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10073B10(v18);
  return v20;
}
// 1010B4F8: using guessed type char *off_1010B4F8[5];
// 1010B500: using guessed type char *off_1010B500[3];
// 1010B508: using guessed type char *off_1010B508;

//----- (10055800) --------------------------------------------------------
bool __cdecl sub_10055800(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9)
{
  double v9; // st7@1
  double v10; // st6@1
  double v11; // st7@4
  float v12; // ST38_4@6
  double v13; // st7@6
  double v14; // st7@8
  double v15; // st6@8
  int v16; // edi@8
  double v17; // st5@24
  double v18; // st3@26
  double v19; // st5@26
  int v20; // edi@35
  char *v21; // esi@36
  char *v22; // ecx@38
  int v23; // ebx@40
  bool v25; // [sp+1Bh] [bp-59h]@10
  char v26; // [sp+1Fh] [bp-55h]@35
  unsigned int v27; // [sp+20h] [bp-54h]@8
  float v28; // [sp+24h] [bp-50h]@8
  char *v29; // [sp+38h] [bp-3Ch]@38
  int v30; // [sp+3Ch] [bp-38h]@38
  int v31; // [sp+40h] [bp-34h]@38
  int v32; // [sp+44h] [bp-30h]@38
  char *v33; // [sp+48h] [bp-2Ch]@38
  char *v34; // [sp+4Ch] [bp-28h]@38
  const char *v35; // [sp+50h] [bp-24h]@38
  const char *v36; // [sp+54h] [bp-20h]@38
  const char *v37; // [sp+58h] [bp-1Ch]@38
  char *v38; // [sp+5Ch] [bp-18h]@38
  int v39; // [sp+60h] [bp-14h]@39
  char v40; // [sp+64h] [bp-10h]@35

  v9 = a7;
  v10 = a8;
  if ( a2 != 6
    || -0.0000099999997 != v10
    || (v9 >= 0.0 ? (v11 = v9 * 0.000009999999747378752) : (v11 = v9 * -0.000009999999747378752),
        v12 = v11,
        v13 = 0.0000099999997,
        v10 = v12,
        v12 >= 0.0000099999997) )
  {
    v13 = v10;
  }
  v28 = v13;
  v14 = v28;
  v15 = a6;
  v16 = sub_100648A0();
  v27 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 1:
      v25 = a7 != a6;
      break;
    case 2:
      if ( a7 != v15 && a7 < (double)a6 )
        goto LABEL_32;
      goto LABEL_14;
    case 3:
      if ( a7 == v15 || a7 < (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 4:
      if ( a7 >= (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 5:
      if ( a7 != v15 && a7 >= (double)a6 )
        goto LABEL_32;
LABEL_14:
      v25 = 1;
      break;
    case 6:
      v17 = v14 - 3.402823466385289e38;
      if ( a7 > v14 - 3.402823466385289e38 )
        v17 = a7;
      v18 = v17 - v14;
      v19 = a7;
      if ( v18 > v15 )
        goto LABEL_48;
      if ( 3.402823466385289e38 - v14 <= v19 )
        v19 = 3.402823466385289e38 - v14;
      if ( v15 > v14 + v19 )
      {
LABEL_48:
        v25 = 0;
        v27 = 10;
      }
      else
      {
        v25 = 1;
        v27 = 10;
      }
      break;
    default:
LABEL_32:
      v25 = 0;
      break;
  }
  if ( sub_10065800() )
    v25 = v25 == 0;
  sub_10054BC0((int)&v40, "%f", 3, 0xCu, a6);
  v20 = 3072 * v16;
  _snprintf(&byte_10289A00[v20], 0x400u, &v40);
  byte_10289DFE[v20] = 42;
  byte_10289DFF[v20] = 0;
  v26 = sub_10054BC0((int)&v40, "%f", 3, 0xCu, a7);
  _snprintf(&byte_10289E00[v20], 0x400u, &v40, a7);
  byte_1028A1FE[v20] = 42;
  byte_1028A1FF[v20] = 0;
  if ( v27 <= 9 )
  {
    v21 = &byte_1028A200[v20];
    byte_1028A200[v20] = 0;
  }
  else
  {
    v21 = &byte_1028A200[v20];
    v26 = sub_10054BC0((int)&v40, "%f", 3, 0xCu, v28);
    _snprintf(&byte_1028A200[v20], 0x400u, &v40, v28);
    byte_1028A5FE[v20] = 42;
    byte_1028A5FF[v20] = 0;
  }
  v29 = (&off_1010B508)[4 * a2];
  v32 = a5;
  v31 = a4;
  v30 = a3;
  v35 = "float";
  v36 = &byte_10289A00[v20];
  v37 = &byte_10289E00[v20];
  v38 = v21;
  v22 = off_1010B4F8[v25 != 0];
  v34 = off_1010B500[a1];
  v33 = v22;
  if ( a9 )
  {
    v39 = a9;
    v27 = 11;
  }
  v23 = sub_10010730();
  sub_10059AF0(7, (int)&v29, v27);
  if ( v26 && a7 != a6 && v28 < fabs(a6 - a7) && !strcmp(v36, v37) )
  {
    nullsub_1(a3);
    sub_10059BE0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10073B10(v23);
  return v25;
}
// 1010B4F8: using guessed type char *off_1010B4F8[5];
// 1010B500: using guessed type char *off_1010B500[3];
// 1010B508: using guessed type char *off_1010B508;

//----- (10055CC0) --------------------------------------------------------
bool __cdecl sub_10055CC0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  void *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_100648A0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10065800() )
    v17 = v17 == 0;
  sub_10054BC0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10289A00[v12], 0x400u, &v31, a6);
  byte_10289DFE[v12] = 42;
  byte_10289DFF[v12] = 0;
  v18 = sub_10054BC0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_10289E00[v12], 0x400u, &v31, a7);
  byte_1028A1FE[v12] = 42;
  byte_1028A1FF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_1028A200[v12];
    byte_1028A200[v12] = 0;
  }
  else
  {
    v18 = sub_10054BC0((int)&v31, "%d", 3, 0xCu, (double)a8);
    v13 = &byte_1028A200[v12];
    _snprintf(&byte_1028A200[v12], 0x400u, &v31, a8);
    byte_1028A5FE[v12] = 42;
    byte_1028A5FF[v12] = 0;
  }
  v20 = (&off_1010B508)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = &unk_1010B84C;
  v27 = &byte_10289A00[v12];
  v28 = &byte_10289E00[v12];
  v29 = v13;
  v14 = off_1010B4F8[v17 != 0];
  v25 = off_1010B500[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10010730();
  sub_10059AF0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3);
    sub_10059BE0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10073B10(v15);
  return v17;
}
// 1010B4F8: using guessed type char *off_1010B4F8[5];
// 1010B500: using guessed type char *off_1010B500[3];
// 1010B508: using guessed type char *off_1010B508;

//----- (10056080) --------------------------------------------------------
bool __cdecl sub_10056080(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9)
{
  int v9; // edi@1
  __int16 v10; // ax@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100648A0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 0x8000;
      if ( v11 < a7 )
        LOWORD(v11) = a7;
      if ( a6 < (signed __int16)(v11 - a8) )
        goto LABEL_37;
      if ( 0x7FFF - a8 <= a7 )
        v10 = 0x7FFF - a8;
      v17 = 1;
      if ( a6 > (signed __int16)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10065800() )
    v17 = v17 == 0;
  sub_10054BC0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10289A00[v12], 0x400u, &v31, a6);
  byte_10289DFE[v12] = 42;
  byte_10289DFF[v12] = 0;
  v18 = sub_10054BC0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_10289E00[v12], 0x400u, &v31, a7);
  byte_1028A1FE[v12] = 42;
  byte_1028A1FF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_1028A200[v12];
    byte_1028A200[v12] = 0;
  }
  else
  {
    v13 = &byte_1028A200[v12];
    v18 = sub_10054BC0((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_1028A200[v12], 0x400u, &v31, a8);
    byte_1028A5FE[v12] = 42;
    byte_1028A5FF[v12] = 0;
  }
  v20 = (&off_1010B508)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_10289A00[v12];
  v21 = a3;
  v26 = "sint16";
  v28 = &byte_10289E00[v12];
  v29 = v13;
  v14 = off_1010B500[a1];
  v24 = off_1010B4F8[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10010730();
  sub_10059AF0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3);
    sub_10059BE0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10073B10(v15);
  return v17;
}
// 1010B4F8: using guessed type char *off_1010B4F8[5];
// 1010B500: using guessed type char *off_1010B500[3];
// 1010B508: using guessed type char *off_1010B508;

//----- (10056480) --------------------------------------------------------
bool __cdecl sub_10056480(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_100648A0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10065800() )
    v17 = v17 == 0;
  sub_10054BC0((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10289A00[v12], 0x400u, &v31, a6);
  byte_10289DFE[v12] = 42;
  byte_10289DFF[v12] = 0;
  v18 = sub_10054BC0((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_10289E00[v12], 0x400u, &v31, a7);
  byte_1028A1FE[v12] = 42;
  byte_1028A1FF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_1028A200[v12];
    byte_1028A200[v12] = 0;
  }
  else
  {
    v18 = sub_10054BC0((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_1028A200[v12];
    _snprintf(&byte_1028A200[v12], 0x400u, &v31, a8);
    byte_1028A5FE[v12] = 42;
    byte_1028A5FF[v12] = 0;
  }
  v20 = (&off_1010B508)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "sint32";
  v27 = &byte_10289A00[v12];
  v28 = &byte_10289E00[v12];
  v29 = v13;
  v14 = off_1010B4F8[v17 != 0];
  v25 = off_1010B500[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10010730();
  sub_10059AF0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3);
    sub_10059BE0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10073B10(v15);
  return v17;
}
// 1010B4F8: using guessed type char *off_1010B4F8[5];
// 1010B500: using guessed type char *off_1010B500[3];
// 1010B508: using guessed type char *off_1010B508;

//----- (10056840) --------------------------------------------------------
bool __cdecl sub_10056840(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9)
{
  unsigned int v9; // edx@22
  unsigned int v10; // esi@22
  unsigned int v11; // eax@27
  int v12; // ecx@27
  int v13; // edi@37
  char *v14; // esi@38
  char *v15; // edx@40
  int v16; // ebx@42
  bool v18; // [sp+1Bh] [bp-5Dh]@3
  char v19; // [sp+1Fh] [bp-59h]@37
  unsigned int v20; // [sp+20h] [bp-58h]@1
  int v21; // [sp+30h] [bp-48h]@1
  char *v22; // [sp+3Ch] [bp-3Ch]@40
  int v23; // [sp+40h] [bp-38h]@40
  int v24; // [sp+44h] [bp-34h]@40
  int v25; // [sp+48h] [bp-30h]@40
  char *v26; // [sp+4Ch] [bp-2Ch]@40
  char *v27; // [sp+50h] [bp-28h]@40
  const char *v28; // [sp+54h] [bp-24h]@40
  const char *v29; // [sp+58h] [bp-20h]@40
  const char *v30; // [sp+5Ch] [bp-1Ch]@40
  char *v31; // [sp+60h] [bp-18h]@40
  int v32; // [sp+64h] [bp-14h]@41
  char v33; // [sp+68h] [bp-10h]@37

  v21 = sub_100648A0();
  v20 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 1:
      v18 = a6 != a7;
      goto LABEL_35;
    case 2:
      if ( a6 != a7
        && SHIDWORD(a6) >= SHIDWORD(a7)
        && (SHIDWORD(a6) > SHIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || SHIDWORD(a6) > SHIDWORD(a7) )
        goto LABEL_34;
      if ( SHIDWORD(a6) < SHIDWORD(a7) )
      {
LABEL_9:
        v18 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_34:
        v18 = 0;
      }
      else
      {
        v18 = 1;
      }
LABEL_35:
      if ( sub_10065800() )
        v18 = v18 == 0;
      sub_10054BC0((int)&v33, "%I64d", 6, 0xCu, (double)a6);
      v13 = 3072 * v21;
      _snprintf(&byte_10289A00[3072 * v21], 0x400u, &v33, a6);
      byte_10289DFE[v13] = 42;
      byte_10289DFF[v13] = 0;
      v19 = sub_10054BC0((int)&v33, "%I64d", 6, 0xCu, (double)a7);
      _snprintf(&byte_10289E00[3072 * v21], 0x400u, &v33, a7);
      byte_1028A1FE[v13] = 42;
      byte_1028A1FF[v13] = 0;
      if ( v20 <= 9 )
      {
        v14 = &byte_1028A200[v13];
        byte_1028A200[v13] = 0;
      }
      else
      {
        v19 = sub_10054BC0((int)&v33, "%I64d", 6, 0xCu, (double)a8);
        v14 = &byte_1028A200[v13];
        _snprintf(&byte_1028A200[v13], 0x400u, &v33, a8);
        byte_1028A5FE[v13] = 42;
        byte_1028A5FF[v13] = 0;
      }
      v22 = (&off_1010B508)[4 * a2];
      v24 = a4;
      v25 = a5;
      v23 = a3;
      v28 = "sint64";
      v29 = &byte_10289A00[3072 * v21];
      v30 = &byte_10289E00[3072 * v21];
      v15 = off_1010B500[a1];
      v26 = off_1010B4F8[v18 != 0];
      v27 = v15;
      v31 = v14;
      if ( a9 )
      {
        v32 = a9;
        v20 = 11;
      }
      v16 = sub_10010730();
      sub_10059AF0(7, (int)&v22, v20);
      if ( v19 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v29, v30) )
      {
        nullsub_1(a3);
        sub_10059BE0(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_10073B10(v16);
      return v18;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 5:
      if ( a6 != a7
        && SHIDWORD(a6) <= SHIDWORD(a7)
        && (SHIDWORD(a6) < SHIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      v18 = 1;
      goto LABEL_35;
    case 6:
      v9 = a8;
      v10 = HIDWORD(a8) + 2147483648;
      if ( (signed int)(HIDWORD(a8) + 2147483648) < SHIDWORD(a7)
        || (signed int)(HIDWORD(a8) + 2147483648) <= SHIDWORD(a7) && (unsigned int)a8 < (unsigned int)a7 )
      {
        v10 = HIDWORD(a7);
        v9 = a7;
      }
      if ( a6 < (signed __int64)(__PAIR__(v10, v9) - a8) )
        goto LABEL_50;
      v11 = -1 - a8;
      v12 = 0x7FFFFFFF - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > SHIDWORD(a7) || v12 >= SHIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_50:
        v18 = 0;
        v20 = 10;
      }
      else
      {
        v18 = 1;
        v20 = 10;
      }
      goto LABEL_35;
    default:
      goto LABEL_34;
  }
}
// 1010B4F8: using guessed type char *off_1010B4F8[5];
// 1010B500: using guessed type char *off_1010B500[3];
// 1010B508: using guessed type char *off_1010B508;

//----- (10056D80) --------------------------------------------------------
bool __cdecl sub_10056D80(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9)
{
  int v9; // edi@1
  char v10; // al@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100648A0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 128;
      if ( v11 < a7 )
        LOBYTE(v11) = a7;
      if ( a6 < (char)(v11 - a8) )
        goto LABEL_37;
      if ( 127 - a8 <= a7 )
        v10 = 127 - a8;
      v17 = 1;
      if ( a6 > (char)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10065800() )
    v17 = v17 == 0;
  sub_10054BC0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10289A00[v12], 0x400u, &v31, a6);
  byte_10289DFE[v12] = 42;
  byte_10289DFF[v12] = 0;
  v18 = sub_10054BC0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_10289E00[v12], 0x400u, &v31, a7);
  byte_1028A1FE[v12] = 42;
  byte_1028A1FF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_1028A200[v12];
    byte_1028A200[v12] = 0;
  }
  else
  {
    v13 = &byte_1028A200[v12];
    v18 = sub_10054BC0((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_1028A200[v12], 0x400u, &v31, a8);
    byte_1028A5FE[v12] = 42;
    byte_1028A5FF[v12] = 0;
  }
  v20 = (&off_1010B508)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_10289A00[v12];
  v21 = a3;
  v26 = "sint8";
  v28 = &byte_10289E00[v12];
  v29 = v13;
  v14 = off_1010B500[a1];
  v24 = off_1010B4F8[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10010730();
  sub_10059AF0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3);
    sub_10059BE0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10073B10(v15);
  return v17;
}
// 1010B4F8: using guessed type char *off_1010B4F8[5];
// 1010B500: using guessed type char *off_1010B500[3];
// 1010B508: using guessed type char *off_1010B508;

//----- (10057160) --------------------------------------------------------
bool __cdecl sub_10057160(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_100648A0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10065800() )
    v17 = v17 == 0;
  sub_10054BC0((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10289A00[v12], 0x400u, &v31, a6);
  byte_10289DFE[v12] = 42;
  byte_10289DFF[v12] = 0;
  v18 = sub_10054BC0((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_10289E00[v12], 0x400u, &v31, a7);
  byte_1028A1FE[v12] = 42;
  byte_1028A1FF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_1028A200[v12];
    byte_1028A200[v12] = 0;
  }
  else
  {
    v18 = sub_10054BC0((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_1028A200[v12];
    _snprintf(&byte_1028A200[v12], 0x400u, &v31, a8);
    byte_1028A5FE[v12] = 42;
    byte_1028A5FF[v12] = 0;
  }
  v20 = (&off_1010B508)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "long int";
  v27 = &byte_10289A00[v12];
  v28 = &byte_10289E00[v12];
  v29 = v13;
  v14 = off_1010B4F8[v17 != 0];
  v25 = off_1010B500[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10010730();
  sub_10059AF0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3);
    sub_10059BE0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10073B10(v15);
  return v17;
}
// 1010B4F8: using guessed type char *off_1010B4F8[5];
// 1010B500: using guessed type char *off_1010B500[3];
// 1010B508: using guessed type char *off_1010B508;

//----- (10057520) --------------------------------------------------------
bool __cdecl sub_10057520(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100648A0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10065800() )
    v17 = v17 == 0;
  sub_10054BC0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10289A00[v12], 0x400u, &v31, a6);
  byte_10289DFE[v12] = 42;
  byte_10289DFF[v12] = 0;
  v18 = sub_10054BC0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_10289E00[v12], 0x400u, &v31, a7);
  byte_1028A1FE[v12] = 42;
  byte_1028A1FF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_1028A200[v12];
    byte_1028A200[v12] = 0;
  }
  else
  {
    v18 = sub_10054BC0((int)&v31, "%u", 3, 0xCu, (double)a8);
    v13 = &byte_1028A200[v12];
    _snprintf(&byte_1028A200[v12], 0x400u, &v31, a8);
    byte_1028A5FE[v12] = 42;
    byte_1028A5FF[v12] = 0;
  }
  v20 = (&off_1010B508)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned int";
  v29 = v13;
  v14 = off_1010B4F8[v17 != 0];
  v25 = off_1010B500[a1];
  v24 = v14;
  v27 = &byte_10289A00[v12];
  v28 = &byte_10289E00[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10010730();
  sub_10059AF0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3);
    sub_10059BE0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10073B10(v15);
  return v17;
}
// 1010B4F8: using guessed type char *off_1010B4F8[5];
// 1010B500: using guessed type char *off_1010B500[3];
// 1010B508: using guessed type char *off_1010B508;

//----- (100578C0) --------------------------------------------------------
bool __cdecl sub_100578C0(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9)
{
  int v9; // edi@1
  unsigned __int16 v10; // ax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100648A0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int16)(v10 - a8) )
        goto LABEL_37;
      v11 = 0xFFFF - a8;
      if ( v11 > a7 )
        LOWORD(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int16)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10065800() )
    v17 = v17 == 0;
  sub_10054BC0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10289A00[v12], 0x400u, &v31, a6);
  byte_10289DFE[v12] = 42;
  byte_10289DFF[v12] = 0;
  v18 = sub_10054BC0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_10289E00[v12], 0x400u, &v31, a7);
  byte_1028A1FE[v12] = 42;
  byte_1028A1FF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_1028A200[v12];
    byte_1028A200[v12] = 0;
  }
  else
  {
    v13 = &byte_1028A200[v12];
    v18 = sub_10054BC0((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_1028A200[v12], 0x400u, &v31, a8);
    byte_1028A5FE[v12] = 42;
    byte_1028A5FF[v12] = 0;
  }
  v20 = (&off_1010B508)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_10289A00[v12];
  v21 = a3;
  v26 = "uint16";
  v28 = &byte_10289E00[v12];
  v29 = v13;
  v14 = off_1010B500[a1];
  v24 = off_1010B4F8[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10010730();
  sub_10059AF0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3);
    sub_10059BE0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10073B10(v15);
  return v17;
}
// 1010B4F8: using guessed type char *off_1010B4F8[5];
// 1010B500: using guessed type char *off_1010B500[3];
// 1010B508: using guessed type char *off_1010B508;

//----- (10057CC0) --------------------------------------------------------
bool __cdecl sub_10057CC0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100648A0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10065800() )
    v17 = v17 == 0;
  sub_10054BC0((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10289A00[v12], 0x400u, &v31, a6);
  byte_10289DFE[v12] = 42;
  byte_10289DFF[v12] = 0;
  v18 = sub_10054BC0((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_10289E00[v12], 0x400u, &v31, a7);
  byte_1028A1FE[v12] = 42;
  byte_1028A1FF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_1028A200[v12];
    byte_1028A200[v12] = 0;
  }
  else
  {
    v18 = sub_10054BC0((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_1028A200[v12];
    _snprintf(&byte_1028A200[v12], 0x400u, &v31, a8);
    byte_1028A5FE[v12] = 42;
    byte_1028A5FF[v12] = 0;
  }
  v20 = (&off_1010B508)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "uint32";
  v29 = v13;
  v14 = off_1010B4F8[v17 != 0];
  v25 = off_1010B500[a1];
  v24 = v14;
  v27 = &byte_10289A00[v12];
  v28 = &byte_10289E00[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10010730();
  sub_10059AF0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3);
    sub_10059BE0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10073B10(v15);
  return v17;
}
// 1010B4F8: using guessed type char *off_1010B4F8[5];
// 1010B500: using guessed type char *off_1010B500[3];
// 1010B508: using guessed type char *off_1010B508;

//----- (10058060) --------------------------------------------------------
bool __cdecl sub_10058060(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9)
{
  unsigned int v9; // esi@22
  unsigned int v10; // edx@23
  unsigned int v11; // eax@26
  unsigned int v12; // ecx@26
  int v13; // edi@36
  char *v14; // ebx@36
  char *v15; // esi@37
  char *v16; // ecx@39
  int v17; // ebx@41
  bool v19; // [sp+18h] [bp-64h]@3
  char v20; // [sp+27h] [bp-55h]@36
  unsigned int v21; // [sp+28h] [bp-54h]@1
  int v22; // [sp+2Ch] [bp-50h]@1
  char *v23; // [sp+2Ch] [bp-50h]@36
  char *v24; // [sp+40h] [bp-3Ch]@39
  int v25; // [sp+44h] [bp-38h]@39
  int v26; // [sp+48h] [bp-34h]@39
  int v27; // [sp+4Ch] [bp-30h]@39
  char *v28; // [sp+50h] [bp-2Ch]@39
  char *v29; // [sp+54h] [bp-28h]@39
  const char *v30; // [sp+58h] [bp-24h]@39
  const char *v31; // [sp+5Ch] [bp-20h]@39
  const char *v32; // [sp+60h] [bp-1Ch]@39
  char *v33; // [sp+64h] [bp-18h]@39
  int v34; // [sp+68h] [bp-14h]@40
  char v35; // [sp+6Ch] [bp-10h]@36

  v22 = sub_100648A0();
  v21 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 1:
      v19 = a6 != a7;
      goto LABEL_34;
    case 2:
      if ( a6 != a7 && HIDWORD(a6) >= HIDWORD(a7) && (HIDWORD(a6) > HIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
        goto LABEL_33;
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || HIDWORD(a6) > HIDWORD(a7) )
        goto LABEL_33;
      if ( HIDWORD(a6) < HIDWORD(a7) )
      {
LABEL_9:
        v19 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_33:
        v19 = 0;
      }
      else
      {
        v19 = 1;
      }
LABEL_34:
      if ( sub_10065800() )
        v19 = v19 == 0;
      sub_10054BC0((int)&v35, "%I64u", 6, 0xCu, (double)a6);
      v13 = 3072 * v22;
      v14 = &byte_10289A00[3072 * v22];
      _snprintf(&byte_10289A00[3072 * v22], 0x400u, &v35, a6);
      byte_10289DFE[v13] = 42;
      byte_10289DFF[v13] = 0;
      v20 = sub_10054BC0((int)&v35, "%I64u", 6, 0xCu, (double)a7);
      v23 = &byte_10289E00[3072 * v22];
      _snprintf(&byte_10289E00[v13], 0x400u, &v35, a7);
      byte_1028A1FE[v13] = 42;
      byte_1028A1FF[v13] = 0;
      if ( v21 <= 9 )
      {
        v15 = &byte_1028A200[v13];
        byte_1028A200[v13] = 0;
      }
      else
      {
        v20 = sub_10054BC0((int)&v35, "%I64u", 6, 0xCu, (double)a8);
        v15 = &byte_1028A200[v13];
        _snprintf(&byte_1028A200[v13], 0x400u, &v35, a8);
        byte_1028A5FE[v13] = 42;
        byte_1028A5FF[v13] = 0;
      }
      v24 = (&off_1010B508)[4 * a2];
      v27 = a5;
      v26 = a4;
      v33 = v15;
      v25 = a3;
      v30 = "uint64";
      v31 = v14;
      v16 = off_1010B500[a1];
      v28 = off_1010B4F8[v19 != 0];
      v29 = v16;
      v32 = v23;
      if ( a9 )
      {
        v34 = a9;
        v21 = 11;
      }
      v17 = sub_10010730();
      sub_10059AF0(7, (int)&v24, v21);
      if ( v20 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v31, v32) )
      {
        nullsub_1(a3);
        sub_10059BE0(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_10073B10(v17);
      return v19;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 5:
      if ( a6 != a7 && HIDWORD(a6) <= HIDWORD(a7) && (HIDWORD(a6) < HIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 6:
      v9 = HIDWORD(a7);
      if ( a8 < a7 )
      {
        v10 = a7;
      }
      else
      {
        v9 = HIDWORD(a8);
        v10 = a8;
      }
      if ( a6 < __PAIR__(v9, v10) - a8 )
        goto LABEL_49;
      v11 = -1 - a8;
      v12 = -1 - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > HIDWORD(a7) || v12 >= HIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_49:
        v19 = 0;
        v21 = 10;
      }
      else
      {
        v19 = 1;
        v21 = 10;
      }
      goto LABEL_34;
    default:
      goto LABEL_33;
  }
}
// 1010B4F8: using guessed type char *off_1010B4F8[5];
// 1010B500: using guessed type char *off_1010B500[3];
// 1010B508: using guessed type char *off_1010B508;

//----- (10058640) --------------------------------------------------------
bool __cdecl sub_10058640(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9)
{
  int v9; // edi@1
  unsigned __int8 v10; // al@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100648A0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int8)(v10 - a8) )
        goto LABEL_37;
      v11 = 255 - a8;
      if ( v11 > a7 )
        LOBYTE(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int8)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10065800() )
    v17 = v17 == 0;
  sub_10054BC0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10289A00[v12], 0x400u, &v31, a6);
  byte_10289DFE[v12] = 42;
  byte_10289DFF[v12] = 0;
  v18 = sub_10054BC0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_10289E00[v12], 0x400u, &v31, a7);
  byte_1028A1FE[v12] = 42;
  byte_1028A1FF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_1028A200[v12];
    byte_1028A200[v12] = 0;
  }
  else
  {
    v13 = &byte_1028A200[v12];
    v18 = sub_10054BC0((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_1028A200[v12], 0x400u, &v31, a8);
    byte_1028A5FE[v12] = 42;
    byte_1028A5FF[v12] = 0;
  }
  v20 = (&off_1010B508)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_10289A00[v12];
  v21 = a3;
  v26 = "uint8";
  v28 = &byte_10289E00[v12];
  v29 = v13;
  v14 = off_1010B500[a1];
  v24 = off_1010B4F8[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10010730();
  sub_10059AF0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3);
    sub_10059BE0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10073B10(v15);
  return v17;
}
// 1010B4F8: using guessed type char *off_1010B4F8[5];
// 1010B500: using guessed type char *off_1010B500[3];
// 1010B508: using guessed type char *off_1010B508;

//----- (10058A30) --------------------------------------------------------
bool __cdecl sub_10058A30(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100648A0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10065800() )
    v17 = v17 == 0;
  sub_10054BC0((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10289A00[v12], 0x400u, &v31, a6);
  byte_10289DFE[v12] = 42;
  byte_10289DFF[v12] = 0;
  v18 = sub_10054BC0((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_10289E00[v12], 0x400u, &v31, a7);
  byte_1028A1FE[v12] = 42;
  byte_1028A1FF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_1028A200[v12];
    byte_1028A200[v12] = 0;
  }
  else
  {
    v18 = sub_10054BC0((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_1028A200[v12];
    _snprintf(&byte_1028A200[v12], 0x400u, &v31, a8);
    byte_1028A5FE[v12] = 42;
    byte_1028A5FF[v12] = 0;
  }
  v20 = (&off_1010B508)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned long int";
  v29 = v13;
  v14 = off_1010B4F8[v17 != 0];
  v25 = off_1010B500[a1];
  v24 = v14;
  v27 = &byte_10289A00[v12];
  v28 = &byte_10289E00[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10010730();
  sub_10059AF0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3);
    sub_10059BE0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10073B10(v15);
  return v17;
}
// 1010B4F8: using guessed type char *off_1010B4F8[5];
// 1010B500: using guessed type char *off_1010B500[3];
// 1010B508: using guessed type char *off_1010B508;

//----- (10058DD0) --------------------------------------------------------
int sub_10058DD0()
{
  int v0; // esi@1
  int result; // eax@1

  v0 = sub_100648A0();
  sub_10054B20(1);
  sub_10054EB0(-1);
  result = sub_10054E40(-1);
  dword_1028D600[v0] = 0;
  return result;
}
// 1028D600: using guessed type int dword_1028D600[];

//----- (10058E00) --------------------------------------------------------
BOOL __usercall sub_10058E00@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6)
{
  const char **v6; // ebp@1
  _BYTE *v7; // esi@1
  int v8; // edi@1
  int v9; // esi@6
  const char *v11; // [sp+Ch] [bp-34h]@6
  char v12; // [sp+10h] [bp-30h]@1
  char v13; // [sp+20h] [bp-20h]@1
  char v14; // [sp+30h] [bp-10h]@1

  v6 = a6;
  v7 = a1;
  LOBYTE(a6) = 0;
  v8 = sub_100648A0();
  sub_10073B40((int)&v13);
  sub_10073B40((int)&v14);
  sub_10073B40((int)&v12);
  if ( !v7 || !*v7 )
  {
    v11 = "Actual file not supplied";
    goto LABEL_13;
  }
  if ( !a2 || !*a2 )
  {
    v11 = "Expected file not supplied";
LABEL_13:
    v9 = 1;
    goto LABEL_14;
  }
  if ( sub_10074790((int (__cdecl *)(unsigned int))sub_10054DA0, v7, (int)&v13) )
  {
    if ( sub_10074790((int (__cdecl *)(unsigned int))sub_10054DA0, a2, (int)&v14) )
    {
      v9 = sub_10074600(
             dword_1028F70C[v8],
             (int)&v13,
             (int)&v14,
             a3,
             a4,
             (int (__cdecl *)(unsigned int))sub_10054DA0,
             (void (__cdecl *)(_DWORD))sub_10054DC0,
             (int)&v12,
             (char *)&a6,
             &v11);
      if ( (_BYTE)a6 )
        sub_10074A30((int)&v12, a5);
    }
    else
    {
      v11 = "Expected bitmap file read failed";
      v9 = 2;
    }
  }
  else
  {
    v11 = "Actual bitmap file read failed";
    v9 = 2;
  }
LABEL_14:
  sub_10073C10((void (__cdecl *)(_DWORD))sub_10054DC0, (int)&v12);
  sub_10073C10((void (__cdecl *)(_DWORD))sub_10054DC0, (int)&v13);
  sub_10073C10((void (__cdecl *)(_DWORD))sub_10054DC0, (int)&v14);
  if ( v6 )
    *v6 = v11;
  return v9 == 0;
}
// 1028F70C: using guessed type int dword_1028F70C[];

//----- (10058F70) --------------------------------------------------------
bool __usercall sub_10058F70@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9)
{
  const char *v9; // ebp@1
  const char *v10; // esi@1
  unsigned int v11; // ebx@8
  unsigned int v12; // edi@8
  bool v13; // zf@11
  bool v14; // bl@13
  int v15; // esi@15
  char *v16; // eax@15
  char *v17; // edx@15
  char *v18; // ecx@15
  int v19; // esi@16
  int v20; // edi@18
  const char *v22; // [sp+14h] [bp-148h]@1
  int v23; // [sp+18h] [bp-144h]@1
  int v24; // [sp+24h] [bp-138h]@1
  int v25; // [sp+28h] [bp-134h]@1
  char *v26; // [sp+2Ch] [bp-130h]@15
  int v27; // [sp+30h] [bp-12Ch]@15
  int v28; // [sp+34h] [bp-128h]@15
  int v29; // [sp+38h] [bp-124h]@15
  char *v30; // [sp+3Ch] [bp-120h]@15
  char *v31; // [sp+40h] [bp-11Ch]@15
  const char *v32; // [sp+44h] [bp-118h]@15
  char *v33; // [sp+48h] [bp-114h]@15
  char *v34; // [sp+4Ch] [bp-110h]@15
  int v35; // [sp+50h] [bp-10Ch]@16
  int v36; // [sp+54h] [bp-108h]@16
  char v37; // [sp+58h] [bp-104h]@9
  char v38; // [sp+156h] [bp-6h]@9
  char v39; // [sp+157h] [bp-5h]@9

  v9 = a6;
  v10 = a7;
  v25 = a2;
  v23 = a1;
  v22 = a7;
  v24 = sub_100648A0();
  if ( !a6 )
    v9 = "(NULL)";
  if ( !a7 )
  {
    v22 = "(NULL)";
    v10 = "(NULL)";
  }
  if ( a8 )
  {
    if ( !a4 && !sub_10065800() )
    {
      v11 = strlen(v9);
      v12 = strlen(v10);
      if ( v11 != v12 )
      {
        _snprintf(&v37, 0x100u, "%s - strlen()", v23);
        v38 = 42;
        v39 = 0;
        sub_10057520(0, 0, (int)"..\\lib\\utf\\utf_verify.c", (int)"2499", (int)&v37, v11, v12, 0, 0);
      }
    }
  }
  if ( !strcmp(v9, v10) )
    v13 = a4 == 0;
  else
    v13 = a4 == 1;
  v14 = v13;
  if ( sub_10065800() )
    v14 = v14 == 0;
  v15 = 3072 * v24;
  _snprintf(&byte_10289A00[3072 * v24], 0x400u, "%s", v9);
  byte_10289DFE[v15] = 42;
  byte_10289DFF[v15] = 0;
  _snprintf(&byte_10289E00[3072 * v24], 0x400u, "%s", v22);
  v16 = (&off_1010B508)[4 * a4];
  v27 = a5;
  v26 = v16;
  v29 = v23;
  v28 = v25;
  byte_1028A1FE[v15] = 42;
  v17 = off_1010B4F8[v14 != 0];
  v18 = off_1010B500[a3];
  byte_1028A1FF[v15] = 0;
  v30 = v17;
  v31 = v18;
  v32 = "string";
  v33 = &byte_10289A00[3072 * v24];
  v34 = &byte_10289E00[3072 * v24];
  if ( a9 )
  {
    v35 = 0;
    v36 = a9;
    v19 = 11;
  }
  else
  {
    v19 = 9;
  }
  v20 = sub_10010730();
  sub_10059AF0(7, (int)&v26, v19);
  sub_10073B10(v20);
  return v14;
}
// 1010B4F8: using guessed type char *off_1010B4F8[5];
// 1010B500: using guessed type char *off_1010B500[3];
// 1010B508: using guessed type char *off_1010B508;

//----- (100591E0) --------------------------------------------------------
char __cdecl sub_100591E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  int v9; // esi@1
  int v10; // esi@4
  char *v11; // eax@4
  char v12; // cl@5
  char *v13; // eax@6
  char v14; // cl@7
  char v15; // bl@8
  char *v16; // edx@10
  bool v17; // zf@10
  int v18; // esi@12
  int v19; // edi@17
  unsigned int v21; // [sp+10h] [bp-258h]@2
  char *v22; // [sp+14h] [bp-254h]@4
  int v23; // [sp+18h] [bp-250h]@1
  char *v24; // [sp+1Ch] [bp-24Ch]@4
  int v25; // [sp+20h] [bp-248h]@1
  char *v26; // [sp+24h] [bp-244h]@4
  char *v27; // [sp+28h] [bp-240h]@4
  int v28; // [sp+2Ch] [bp-23Ch]@1
  int v29; // [sp+30h] [bp-238h]@1
  char *v30; // [sp+34h] [bp-234h]@10
  int v31; // [sp+38h] [bp-230h]@10
  int v32; // [sp+3Ch] [bp-22Ch]@10
  int v33; // [sp+40h] [bp-228h]@10
  char *v34; // [sp+44h] [bp-224h]@10
  char *v35; // [sp+48h] [bp-220h]@10
  const char *v36; // [sp+4Ch] [bp-21Ch]@10
  char *v37; // [sp+50h] [bp-218h]@12
  char *v38; // [sp+54h] [bp-214h]@12
  char *v39; // [sp+58h] [bp-210h]@12
  char *v40; // [sp+5Ch] [bp-20Ch]@14
  char v41[2]; // [sp+64h] [bp-204h]@2
  char v42; // [sp+163h] [bp-105h]@3
  char v43; // [sp+164h] [bp-104h]@14
  char v44; // [sp+263h] [bp-5h]@14

  v28 = a4;
  v23 = a5;
  v25 = a7;
  v9 = sub_100648A0();
  v29 = v9;
  if ( a8 == 65278 )
  {
    v21 = dword_1028F70C[v9] != 0 ? 0x32 : 0;
    strcpy(v41, "0");
  }
  else
  {
    v21 = a8;
    _snprintf(v41, 0x100u, "%u", a8);
    v42 = 0;
  }
  v10 = 560 * v9;
  v22 = &byte_10290D28[v10];
  sub_100548C0(a3, 1, a6, 0x230u, &byte_10290D28[v10]);
  v27 = &byte_1028D628[v10];
  sub_100548C0(a3, 2, a7, 0x230u, &byte_1028D628[v10]);
  v24 = &byte_1028EC08[v10];
  sub_100548C0(a3, 3, a6, 0x230u, &byte_1028EC08[v10]);
  v26 = &byte_1028F720[v10];
  sub_100548C0(a3, 4, a7, 0x230u, &byte_1028F720[v10]);
  _snprintf(&byte_10290210[v10], 0x230u, "%s_Diff_", a6);
  v11 = &byte_10290210[v10];
  byte_1029043F[v10] = 0;
  do
    v12 = *v11++;
  while ( v12 );
  sub_100548C0(a3, 0, v25, 560 - (v11 - &byte_10290210[v10 + 1]), &byte_10290210[v10] + v11 - &byte_10290210[v10 + 1]);
  v13 = &byte_10290210[v10];
  byte_1029043F[v10] = 0;
  do
    v14 = *v13++;
  while ( v14 );
  *(&byte_1029020C[v10] + v13 - &byte_10290210[v10 + 1]) = 0;
  sub_100548C0(a3, 1, (int)&byte_10290210[v10], 0x230u, &byte_10288F10[v10]);
  sub_100548C0(a3, 1, (int)&byte_10290210[v10], 0x230u, &byte_1028E118[v10]);
  v15 = sub_10058E00(v22, v27, v21, a2 == 1, (int)&byte_10288F10[v10], (const char **)&v22);
  if ( sub_10065800() )
    v15 = v15 == 0;
  v30 = (&off_1010B508)[4 * a2];
  v32 = v28;
  v33 = v23;
  v31 = a3;
  v36 = "bitmap-strict";
  v16 = off_1010B500[a1];
  v34 = off_1010B4F8[v15 != 0];
  v17 = dword_1028F70C[v29] == 0;
  v35 = v16;
  if ( !v17 )
    v36 = "bitmap-lenient";
  v37 = v24;
  v38 = v26;
  v39 = v41;
  v18 = 10;
  if ( !v15 && v22 )
  {
    _snprintf(&v43, 0x100u, "Info: %s", v22);
    v44 = 0;
    v40 = &v43;
    v18 = 11;
  }
  if ( a9 )
    (&v30)[4 * v18++] = (char *)a9;
  v19 = sub_10010730();
  sub_10059AF0(7, (int)&v30, v18);
  sub_10073B10(v19);
  return v15;
}
// 1010B4F8: using guessed type char *off_1010B4F8[5];
// 1010B500: using guessed type char *off_1010B500[3];
// 1010B508: using guessed type char *off_1010B508;
// 1028F70C: using guessed type int dword_1028F70C[];

//----- (100594E0) --------------------------------------------------------
bool __cdecl sub_100594E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v9; // [sp+Ch] [bp-104h]@1
  char v10; // [sp+10Ah] [bp-6h]@1
  char v11; // [sp+10Bh] [bp-5h]@1

  _snprintf(&v9, 0x100u, "%s (ptr diff)", a5);
  v10 = 42;
  v11 = 0;
  return sub_10055CC0(a1, a2, a3, a4, (int)&v9, a6 - a7, 0, 0, a8);
}

//----- (10059590) --------------------------------------------------------
bool __cdecl sub_10059590(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8)
{
  return sub_10058F70(a5, a4, a1, a2, a3, a6, a7, 1, a8);
}

//----- (100595D0) --------------------------------------------------------
char __cdecl sub_100595D0(_DWORD *a1)
{
  char v1; // bl@1
  unsigned int v2; // ebp@1
  char *v3; // edi@1
  char *v4; // eax@4
  char *v5; // eax@7
  char v7; // [sp+13h] [bp-105h]@1
  char v8; // [sp+14h] [bp-104h]@5
  char v9; // [sp+113h] [bp-5h]@5

  v1 = 0;
  v7 = 0;
  v2 = 0;
  v3 = sub_100657E0() + 36;
  do
  {
    if ( v2 >= 5 )
      break;
    if ( !*(_DWORD *)v3 )
    {
      v1 = 1;
      v7 = 1;
      *(_DWORD *)v3 = a1;
      v4 = sub_100737C0("CFG_OutputFile", 0);
      if ( v4 )
      {
        _snprintf(&v8, 0x100u, "'%s' file '%s'", *a1, v4);
        v9 = 0;
        if ( sub_10066580() )
          v7 = 0;
      }
      v5 = sub_100737C0("CFG_OutputPath", 0);
      if ( v5 )
      {
        _snprintf(&v8, 0x100u, "'%s' path '%s'", *a1, v5);
        v9 = 0;
        if ( sub_10066580() )
          v7 = 0;
      }
    }
    ++v2;
    v3 += 4;
  }
  while ( !v1 );
  return v7;
}

//----- (100596E0) --------------------------------------------------------
char __cdecl sub_100596E0(int a1, unsigned int a2)
{
  char result; // al@1

  result = 1;
  if ( a2 > 4 && !memcmp(*(const void **)(a1 + 16), "PASS", 5u) )
    result = 0;
  return result;
}

//----- (10059710) --------------------------------------------------------
bool __cdecl sub_10059710(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "begin", 6u);
}

//----- (10059740) --------------------------------------------------------
bool __cdecl sub_10059740(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "case", 5u);
}

//----- (10059770) --------------------------------------------------------
bool __cdecl sub_10059770(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "command", 8u);
}

//----- (100597A0) --------------------------------------------------------
bool __cdecl sub_100597A0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "end", 4u);
}

//----- (100597D0) --------------------------------------------------------
bool __cdecl sub_100597D0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "group", 6u);
}

//----- (10059800) --------------------------------------------------------
bool __cdecl sub_10059800(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-begin", 0xCu);
}

//----- (10059840) --------------------------------------------------------
bool __cdecl sub_10059840(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-end", 0xAu);
}

//----- (10059880) --------------------------------------------------------
bool __cdecl sub_10059880(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "listener", 9u);
}

//----- (100598B0) --------------------------------------------------------
bool __cdecl sub_100598B0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "suite", 6u);
}

//----- (100598E0) --------------------------------------------------------
char __cdecl sub_100598E0(int a1, unsigned int a2)
{
  char result; // al@1

  result = 0;
  if ( a2 > 5 && !memcmp(*(const void **)(a1 + 20), "robust", 7u) )
    result = 1;
  return result;
}

//----- (10059910) --------------------------------------------------------
bool __cdecl sub_10059910(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Error**", 0xAu);
}

//----- (10059940) --------------------------------------------------------
bool __cdecl sub_10059940(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**MSG**", 8u);
}

//----- (10059970) --------------------------------------------------------
bool __cdecl sub_10059970(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**METHOD**", 0xBu);
}

//----- (100599A0) --------------------------------------------------------
bool __cdecl sub_100599A0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**RESULT**", 0xBu);
}

//----- (100599D0) --------------------------------------------------------
bool __cdecl sub_100599D0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, &unk_1010BA88, 9u);
}

//----- (10059A00) --------------------------------------------------------
bool __cdecl sub_10059A00(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**SUBGROUP**", 0xDu);
}

//----- (10059A30) --------------------------------------------------------
bool __cdecl sub_10059A30(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TITLE**", 0xAu);
}

//----- (10059A60) --------------------------------------------------------
bool __cdecl sub_10059A60(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "Tested Requirement:", 0x14u);
}

//----- (10059A90) --------------------------------------------------------
bool __cdecl sub_10059A90(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TYPE**", 9u);
}

//----- (10059AC0) --------------------------------------------------------
bool __cdecl sub_10059AC0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Warning**", 0xCu);
}

//----- (10059AF0) --------------------------------------------------------
int __cdecl sub_10059AF0(int a1, int a2, int a3)
{
  int *v3; // esi@1
  signed int v4; // edi@1
  int result; // eax@2

  v3 = (int *)(sub_100657E0() + 36);
  v4 = 5;
  do
  {
    result = *v3;
    if ( *v3 )
    {
      result = *(_DWORD *)(result + 4);
      if ( result )
        result = ((int (__cdecl *)(int, int, int))result)(a1, a2, a3);
    }
    ++v3;
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (10059B60) --------------------------------------------------------
int __cdecl sub_10059B60(int a1, char a2)
{
  return sub_10059AF0(a1, (int)&a2, 1);
}

//----- (10059B80) --------------------------------------------------------
int __cdecl sub_10059B80(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = a2;
  v5 = a3;
  return sub_10059AF0(a1, (int)&v4, 2);
}

//----- (10059BB0) --------------------------------------------------------
int __cdecl sub_10059BB0(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-Ch]@1
  int v6; // [sp+4h] [bp-8h]@1
  int v7; // [sp+8h] [bp-4h]@1

  v5 = a2;
  v6 = a3;
  v7 = a4;
  return sub_10059AF0(a1, (int)&v5, 3);
}

//----- (10059BE0) --------------------------------------------------------
int __cdecl sub_10059BE0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+4h] [bp-Ch]@1
  int v8; // [sp+8h] [bp-8h]@1
  int v9; // [sp+Ch] [bp-4h]@1

  v7 = a3;
  v8 = a4;
  v6 = a2;
  v9 = a5;
  return sub_10059AF0(a1, (int)&v6, 4);
}

//----- (10059C20) --------------------------------------------------------
int __cdecl sub_10059C20(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [sp+0h] [bp-14h]@1
  int v8; // [sp+4h] [bp-10h]@1
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1
  int v11; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v9 = a4;
  v10 = a5;
  v8 = a3;
  v11 = a6;
  return sub_10059AF0(a1, (int)&v7, 5);
}

//----- (10059C60) --------------------------------------------------------
int __cdecl sub_10059C60(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-18h]@1
  int v9; // [sp+4h] [bp-14h]@1
  int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v8 = a2;
  v9 = a3;
  v11 = a5;
  v12 = a6;
  v10 = a4;
  v13 = a7;
  return sub_10059AF0(a1, (int)&v8, 6);
}

//----- (10059CB0) --------------------------------------------------------
char __cdecl sub_10059CB0(int a1)
{
  char v1; // bl@1
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  _DWORD *v4; // eax@1

  v1 = 0;
  v2 = sub_100657E0();
  v3 = 0;
  v4 = v2 + 36;
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 == a1 )
    {
      v1 = 1;
      *v4 = 0;
    }
    ++v3;
    ++v4;
  }
  while ( !v1 );
  return v1;
}

//----- (10059CE0) --------------------------------------------------------
char __cdecl sub_10059CE0(int a1)
{
  ++*(_DWORD *)(a1 + 328);
  return *(_BYTE *)(a1 + 52);
}

//----- (10059CF0) --------------------------------------------------------
char __cdecl sub_10059CF0(int a1, int a2)
{
  int v2; // esi@1
  bool v3; // zf@1
  int v4; // ebp@1
  char *v5; // eax@1
  int v6; // edi@1
  int v7; // ecx@2
  char *v8; // ecx@7
  char v9; // dl@8
  char v10; // cl@9
  char *v11; // ecx@10
  char *v12; // edx@13
  char v13; // cl@14
  int v14; // eax@17
  char v16[255]; // [sp+10h] [bp-104h]@12
  char v17; // [sp+10Fh] [bp-5h]@12

  v2 = a1;
  ++*(_DWORD *)(v2 + 324);
  ++*(_DWORD *)(v2 + 328);
  v3 = *(_BYTE *)(a1 + 53) == 0;
  v4 = *(_DWORD *)(a1 + 324);
  v5 = (char *)(a1 + 53);
  v6 = *(_DWORD *)(a1 + 328);
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  if ( !v3 )
  {
    v7 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
    if ( !v7 )
    {
LABEL_6:
      if ( *(_BYTE *)(a1 + 52) )
      {
        v8 = (char *)(a1 + 53);
        do
          v9 = *v8++;
        while ( v9 );
        v10 = *(&v8[a1 - 2] - a1);
        if ( v10 == 92 || (v3 = v10 == 47, v11 = "/", v3) )
          v11 = &byte_100930C0;
        _snprintf(v16, 0x100u, "%s%s%s%s", a1 + 53, v11, a2, *(_DWORD *)(a1 + 48));
        v17 = 0;
      }
      else
      {
        v12 = (char *)(v16 - v5);
        do
        {
          v13 = *v5;
          v5[(_DWORD)v12] = *v5;
          ++v5;
        }
        while ( v13 );
      }
      if ( (unsigned __int8)sub_10074AB0(v16) )
        sub_10074A90((int)v16);
      *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = sub_10074AC0((int)v16, 1);
      v14 = *(_DWORD *)a1;
      if ( !*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) && v14 > 0 )
        *(_DWORD *)a1 = v14 - 1;
      return 1;
    }
    if ( *(_BYTE *)(a1 + 52) )
    {
      if ( v7 )
        ++*(_DWORD *)a1;
      goto LABEL_6;
    }
  }
  if ( v6 == 1 && v4 == 1 )
    return 1;
  return 0;
}
// 10074AB0: using guessed type _DWORD __cdecl sub_10074AB0(_DWORD);
// 10059CF0: using guessed type char var_104[255];

//----- (10059E70) --------------------------------------------------------
signed int __cdecl sub_10059E70(int a1)
{
  signed int result; // eax@1
  int v2; // edx@1
  int v3; // edx@1

  result = 1;
  v2 = 16 * *(_DWORD *)a1;
  *(_DWORD *)(v2 + a1 + 4) = 0;
  v3 = v2 + a1 + 4;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 312) = 5;
  return result;
}

//----- (10059EB0) --------------------------------------------------------
signed int __cdecl sub_10059EB0(int a1, int a2, int a3)
{
  char *v3; // eax@3
  char v4; // cl@4
  signed int result; // eax@5

  switch ( a1 )
  {
    case 8:
    case 9:
      if ( *(_DWORD *)a2 != 5 )
        goto LABEL_6;
      v3 = (char *)(a2 + 4);
      do
      {
        v4 = *v3;
        v3[a3 + 53 - (a2 + 4)] = *v3;
        ++v3;
      }
      while ( v4 );
      *(_BYTE *)(a3 + 52) = a1 != 8;
      result = 0;
      break;
    case 10:
      if ( *(_DWORD *)a2 )
        goto LABEL_6;
      *(_BYTE *)(a3 + 53) = 0;
      *(_BYTE *)(a3 + 52) = 0;
      result = 0;
      break;
    case 11:
      if ( *(_DWORD *)a2 == 1 )
      {
        *(_BYTE *)(a3 + 309) = *(_BYTE *)(a2 + 4);
        result = 0;
      }
      else
      {
LABEL_6:
        result = 9;
      }
      break;
    default:
      result = 4;
      break;
  }
  return result;
}

//----- (10059F50) --------------------------------------------------------
char __cdecl sub_10059F50(int a1)
{
  int v1; // edx@3

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( *(_DWORD *)(a1 + 328) == 1 )
    {
      v1 = 16 * *(_DWORD *)a1 + a1 + 4;
      *(_DWORD *)v1 = 0;
      *(_DWORD *)(v1 + 4) = 0;
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 12) = 0;
      if ( *(_DWORD *)a1 > 0 )
        --*(_DWORD *)a1;
    }
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return *(_BYTE *)(a1 + 52);
}

//----- (10059FB0) --------------------------------------------------------
char __cdecl sub_10059FB0(int a1, void (__cdecl *a2)(int))
{
  char result; // al@6

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( a2 )
      a2(a1);
    sub_10074A70(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    result = 1;
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return result;
}

//----- (1005A020) --------------------------------------------------------
char *__cdecl sub_1005A020(char *a1)
{
  char *v1; // esi@1
  size_t v2; // edi@1
  char *v3; // eax@1
  char *v4; // eax@2
  unsigned int v5; // eax@3
  char *v6; // eax@5
  char *v7; // eax@7

  v1 = a1;
  v2 = 255;
  v3 = strstr(a1, "$Id: ");
  if ( v3 )
  {
    v1 = v3 + 5;
    v4 = strchr(v3 + 5, 44);
    if ( v4 )
    {
      v5 = v4 - v1;
      if ( v5 < 0x100 )
        goto LABEL_9;
    }
  }
  else
  {
    v6 = strrchr(a1, 47);
    if ( v6 )
    {
      v1 = v6 + 1;
      v2 = strlen(v6 + 1);
    }
    v7 = strrchr(v1, 92);
    if ( v7 )
    {
      v1 = v7 + 1;
      v5 = strlen(v7 + 1);
LABEL_9:
      v2 = v5;
      goto LABEL_10;
    }
  }
LABEL_10:
  strncpy(&byte_10291818, v1, v2);
  *(&byte_10291818 + v2) = 0;
  return &byte_10291818;
}

//----- (1005A0C0) --------------------------------------------------------
int __cdecl sub_1005A0C0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 44) = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 48) = a3;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 53) = 0;
  *(_BYTE *)(a1 + 309) = 1;
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1005A130) --------------------------------------------------------
bool __cdecl sub_1005A130(int a1, unsigned int a2, int a3)
{
  bool result; // al@9
  int v4; // ecx@11
  int v5; // edx@11
  int v6; // [sp+4h] [bp-4h]@3

  if ( a2 <= 4
    || sub_10080408(*(_DWORD *)(a1 + 12), (int)"%d", (unsigned int)&a2) != 1
    || sub_10080408(*(_DWORD *)(a1 + 16), (int)"%d", (unsigned int)&v6) != 1 )
  {
    result = 0;
    *(_BYTE *)(a3 + 316) = 0;
  }
  else
  {
    result = a2 == 4 || !a2 || a2 == 1 || a2 == 2 || a2 == 3;
    v4 = a3;
    *(_DWORD *)(a3 + 312) = a2;
    v5 = v6;
    *(_BYTE *)(v4 + 316) = result;
    *(_DWORD *)(v4 + 320) = v5;
  }
  return result;
}

//----- (1005A1C0) --------------------------------------------------------
char __cdecl sub_1005A1C0(int a1, int a2, char a3, char a4)
{
  int v4; // ecx@2
  int v5; // eax@3
  bool v6; // zf@3
  signed int v7; // eax@6
  char result; // al@14

  switch ( a2 )
  {
    case 3:
      v4 = a1;
      if ( a3 )
        goto LABEL_11;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 1;
      goto LABEL_4;
    case 7:
      v4 = a1;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 2;
LABEL_4:
      if ( !v6 && v5 != 3 )
        goto LABEL_12;
      v7 = *(_DWORD *)(v4 + 320);
      if ( v7 <= 1 )
      {
        *(_DWORD *)(v4 + 320) = 0;
LABEL_11:
        *(_DWORD *)(v4 + 312) = 5;
      }
      else
      {
        *(_DWORD *)(v4 + 320) = v7 - 1;
      }
LABEL_12:
      if ( *(_BYTE *)(v4 + 316) )
      {
        if ( *(_DWORD *)(v4 + 312) == 5 )
        {
          result = 1;
          *(_BYTE *)(v4 + 316) = 0;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = a4;
      }
      return result;
    default:
      v4 = a1;
      goto LABEL_11;
  }
}

//----- (1005A270) --------------------------------------------------------
char __cdecl sub_1005A270(int a1)
{
  return *(_BYTE *)(a1 + 316);
}

//----- (1005A280) --------------------------------------------------------
char __cdecl sub_1005A280(int a1, void (__cdecl *a2)(int))
{
  char v2; // bl@1

  v2 = 0;
  if ( !*(_BYTE *)(a1 + 52) && *(_DWORD *)(a1 + 324) > 0 || *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    v2 = 1;
    if ( a2 )
      a2(a1);
  }
  if ( *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    sub_10074A70(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    v2 = 1;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return v2;
}

//----- (1005A300) --------------------------------------------------------
int (__cdecl *__cdecl sub_1005A300(int a1, const char *a2))(const char *)
{
  int v2; // edx@1
  int (__cdecl *result)(const char *); // eax@2

  v2 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
  if ( v2 )
  {
    result = (int (__cdecl *)(const char *))sub_10074B40(a2, strlen(a2), v2);
  }
  else
  {
    result = *(int (__cdecl **)(const char *))(a1 + 44);
    if ( result )
      result = (int (__cdecl *)(const char *))result(a2);
  }
  return result;
}
// 10074B40: using guessed type _DWORD __cdecl sub_10074B40(_DWORD, _DWORD, _DWORD);

//----- (1005A350) --------------------------------------------------------
signed int __cdecl sub_1005A350(int a1, void (__cdecl *a2)(int))
{
  signed int result; // eax@1

  sub_1005A280(a1, a2);
  result = 1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1005A3A0) --------------------------------------------------------
int __cdecl sub_1005A3A0(int a1)
{
  return a1 + 9;
}

//----- (1005A3B0) --------------------------------------------------------
int __cdecl sub_1005A3B0(void *a1)
{
  int v1; // edi@1
  __int16 v2; // ax@1
  _WORD *v3; // ecx@1

  v1 = sub_1007BFD0();
  memset(a1, 0, 0xDCu);
  sub_10042370((char *)a1 + 204, 0xFu, "test sk %i", v1);
  v2 = sub_1005A3A0(v1);
  *v3 = v2;
  *((_DWORD *)a1 + 10) = (char *)a1 + 204;
  *((_DWORD *)a1 + 11) = (char *)a1 + 76;
  *((_WORD *)a1 + 24) = 128;
  *((_BYTE *)a1 + 50) = 22;
  *((_DWORD *)a1 + 13) = 0;
  *((_DWORD *)a1 + 14) = 300;
  *((_DWORD *)a1 + 15) = 0;
  *((_DWORD *)a1 + 16) = 500;
  *((_DWORD *)a1 + 17) = 0;
  return sub_10074D20((int)a1, (int)v3);
}

//----- (1005A430) --------------------------------------------------------
int __cdecl sub_1005A430(int a1, int a2)
{
  int v2; // esi@1
  _DWORD *v3; // ST00_4@1
  int result; // eax@2

  v2 = a1;
  v3 = (_DWORD *)a1;
  *(_DWORD *)(a1 + 60) = a2;
  sub_10074F30(v3, (char *)&a1);
  if ( (_BYTE)a1 )
    result = v2 + 76;
  else
    result = 0;
  return result;
}

//----- (1005A460) --------------------------------------------------------
signed int __cdecl sub_1005A460(int a1, int a2, int a3)
{
  signed int result; // eax@1
  int v4; // esi@2
  __int16 v5; // ax@4
  int v6; // eax@6
  int v7; // ebx@6

  result = 0;
  if ( a3 )
  {
    v4 = *(_DWORD *)a1;
    if ( !*(_DWORD *)a1 )
      return -59;
    v5 = 0;
    if ( *(_BYTE *)(v4 + 14) & 0x10 )
      v5 = 2;
    v6 = sub_1007D260(*(_DWORD *)(a1 + 4), a2, a3, v5, *(_DWORD *)(v4 + 28));
    v7 = v6;
    if ( v6 >= 0 )
    {
      *(_DWORD *)(a1 + 32) = sub_1007C040();
    }
    else if ( v6 != -57 || (unsigned int)(sub_1007C040() - *(_DWORD *)(a1 + 32)) >= *(_DWORD *)(v4 + 32) )
    {
      sub_10074D20(a1, v4);
      return v7;
    }
    result = v7;
  }
  return result;
}

//----- (1005A480) --------------------------------------------------------
signed int __cdecl sub_1005A480(int a1, int a2)
{
  signed int result; // eax@1

  result = 4;
  if ( a1 == 2 )
  {
    byte_10291919 = 1;
    byte_10291918 = 0;
  }
  else
  {
    if ( a1 == 8 )
    {
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_10291918 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    else
    {
      if ( a1 != 9 )
        return result;
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_10291919 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    result = 9;
  }
  return result;
}
// 10291918: using guessed type char byte_10291918;
// 10291919: using guessed type char byte_10291919;

//----- (1005A4E0) --------------------------------------------------------
bool __cdecl sub_1005A4E0(signed int a1)
{
  if ( a1 > 1 )
  {
    sub_10059BB0(13, (int)"..\\lib\\utf\\utf_validate.c", (int)&unk_101236E0, (int)"failing_subroutine( depth-1 )");
    sub_1005A4E0(a1 - 1);
    exit_1(14);
  }
  return sub_10059590(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"583",
           (int)"Check FAIL macro",
           "UTF_verify_fail: forced fail",
           "UTF_verify_fail: fail forced",
           (int)"This test is expected to fail");
}

//----- (1005A550) --------------------------------------------------------
int sub_1005A550()
{
  const char *v0; // eax@1

  sub_10059BE0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"All Fail Miscellaneous Test Group");
  v0 = sub_10054A50(0);
  sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"610", (int)v0);
  sub_10059BE0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"Verify miscellaneous macros");
  if ( byte_10291918 )
  {
    sub_10059590(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"620",
      (int)"Check FAIL macro",
      "UTF_verify_fail: forced fail",
      "UTF_verify_fail: fail forced",
      (int)"This test is expected to fail");
    sub_10059BB0(13, (int)"..\\lib\\utf\\utf_validate.c", (int)"621", (int)"failing_subroutine( 1 )");
    sub_1005A4E0(1);
    exit_1(14);
  }
  return sub_10059BE0(
           3,
           (int)"**MSG**",
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"616",
           (int)"Failing tests currently disabled. Use FAIL ON command to enable");
}
// 10291918: using guessed type char byte_10291918;

//----- (1005A870) --------------------------------------------------------
char sub_1005A870()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_10059BE0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"All Fail Test Group For Type 'bitmap'");
  v0 = sub_10054A50(0);
  sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"700", (int)v0);
  sub_10059BE0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10291918 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_1010C754 + v2) )
      {
        sub_100548C0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_1010C75C[v2], 0x100u, &v11);
        sub_100548C0((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_1010C754 + v2), 0x100u, &v12);
        sub_10074B60(&v12, &v11);
      }
      if ( byte_1010C750[v2] )
      {
        sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"725", 2, 2);
        v3 = off_1010C758[v2 / 4];
        v4 = *(char **)&off_1010C75C[v2];
        v5 = sub_10054B60(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1010C75C[v2],
               off_1010C758[v2 / 4]);
        v6 = sub_100591E0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"730",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_10054EC0(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"731",
                   (int)"Return value from previous UTF_verify_eq_bitmap() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"735", 2, 2);
        v7 = off_1010C758[v2 / 4];
        v8 = *(char **)&off_1010C75C[v2];
        v9 = sub_10054B60(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1010C75C[v2],
               off_1010C758[v2 / 4]);
        v10 = sub_100591E0(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"740",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_10054EC0(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"741",
                   (int)"Return value from previous UTF_verify_ne_bitmap() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x90 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"704",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1010C754: using guessed type void *off_1010C754;
// 1010C758: using guessed type char *off_1010C758[2];
// 10291918: using guessed type char byte_10291918;

//----- (1005AA90) --------------------------------------------------------
char sub_1005AA90()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10059BE0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_10054A50(0);
  sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"768", (int)v0);
  sub_10059BE0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10291918 )
  {
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"776", 2, 2);
    v2 = sub_10054EC0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"777",
           (int)"UTF_verify_eq_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_10054EC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"778",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"780", 2, 2);
    v3 = sub_10054EC0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"781",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_10054EC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"782",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"784", 2, 2);
    v4 = sub_10054EC0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"785",
           (int)"UTF_verify_ne_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_10054EC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"786",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"788", 2, 2);
    v5 = sub_10054EC0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"789",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_10054EC0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"790",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"772",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10291918: using guessed type char byte_10291918;

//----- (1005AC90) --------------------------------------------------------
char sub_1005AC90()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"830", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_1010C7E4[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"830", 2, 2);
        v3 = byte_1010C7E1[v2 * 4];
        v4 = byte_1010C7E0[v2 * 4];
        v5 = sub_10054B60(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + dword_1010C7E4[v2])],
               (&off_1010C7E8)[v2 * 4]);
        v6 = sub_10055000(
               0,
               *(&dword_1010C734 + dword_1010C7E4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"830",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_10054B60(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_1010C7E4[v2]],
               (&off_1010C7E8)[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"830",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"830",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010C7E4: using guessed type int dword_1010C7E4[];
// 1010C7E8: using guessed type char *off_1010C7E8;
// 10291918: using guessed type char byte_10291918;

//----- (1005AE10) --------------------------------------------------------
char sub_1005AE10()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"864", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_1010CA68[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_1010CA60[v2 / 8];
        v4 = dbl_1010CA58[v2 / 8];
        v5 = dbl_1010CA50[v2 / 8];
        v6 = sub_10054B60(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               *(_DWORD *)&off_1010CA6C[v2]);
        v7 = sub_100553B0(
               0,
               *(&dword_1010C734 + dword_1010CA68[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"864",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_1010CA68[v2 / 4]],
               *(_DWORD *)&off_1010CA6C[v2]);
        LOBYTE(v0) = sub_10054EC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"864",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"864",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010CA50: using guessed type double dbl_1010CA50[];
// 1010CA58: using guessed type double dbl_1010CA58[];
// 1010CA60: using guessed type double dbl_1010CA60[];
// 1010CA68: using guessed type int dword_1010CA68[];
// 10291918: using guessed type char byte_10291918;

//----- (1005AF90) --------------------------------------------------------
char sub_1005AF90()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"900", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_1010D67C[v2];
      if ( v0 != 6 )
      {
        v3 = flt_1010D678[v2];
        v4 = flt_1010D674[v2];
        v5 = flt_1010D670[v2];
        v6 = sub_10054B60(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               (&off_1010D680)[v2 * 4]);
        v7 = sub_10055800(
               0,
               *(&dword_1010C734 + dword_1010D67C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"900",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_1010D67C[v2]],
               (&off_1010D680)[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"900",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"900",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010D670: using guessed type float flt_1010D670[];
// 1010D674: using guessed type float flt_1010D674[];
// 1010D678: using guessed type float flt_1010D678[];
// 1010D67C: using guessed type int dword_1010D67C[];
// 1010D680: using guessed type char *off_1010D680;
// 10291918: using guessed type char byte_10291918;

//----- (1005B100) --------------------------------------------------------
char sub_1005B100()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10059BE0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10054A50(0);
  sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"922", (int)v0);
  sub_10059BE0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10291918 )
  {
    sub_100594E0(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"930",
      (int)"Check ptr for equality",
      (int)sub_1005B100,
      (int)sub_1005B100,
      (int)"This test is expected to fail");
    sub_100594E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"931",
      (int)"Check ptr for inequality",
      (int)sub_1005B100,
      0,
      (int)"This test is expected to fail");
    result = sub_100594E0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"932",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1005B100,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"926",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10291918: using guessed type char byte_10291918;

//----- (1005B200) --------------------------------------------------------
char sub_1005B200()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"959", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_1010DE24[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1010DE20[v2];
        v4 = dword_1010DE1C[v2];
        v5 = dword_1010DE18[v2];
        v6 = sub_10054B60(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               *(_DWORD *)&off_1010DE28[v2 * 4]);
        v7 = sub_10055CC0(
               0,
               *(&dword_1010C734 + dword_1010DE24[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"959",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_1010DE24[v2]],
               *(_DWORD *)&off_1010DE28[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"959",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"959",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010DE18: using guessed type int dword_1010DE18[];
// 1010DE1C: using guessed type int dword_1010DE1C[];
// 1010DE20: using guessed type int dword_1010DE20[];
// 1010DE24: using guessed type int dword_1010DE24[];
// 10291918: using guessed type char byte_10291918;

//----- (1005B360) --------------------------------------------------------
char sub_1005B360()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"985", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_1010E5B8[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_1010E5B4[v2 / 2];
        v4 = word_1010E5B2[v2 / 2];
        v5 = word_1010E5B0[v2 / 2];
        v6 = sub_10054B60(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               *(_DWORD *)&off_1010E5BC[v2]);
        v7 = sub_10056080(
               0,
               *(&dword_1010C734 + dword_1010E5B8[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"985",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_1010E5B8[v2 / 4]],
               *(_DWORD *)&off_1010E5BC[v2]);
        LOBYTE(v0) = sub_10054EC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"985",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"985",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010E5B0: using guessed type __int16 word_1010E5B0[];
// 1010E5B2: using guessed type __int16 word_1010E5B2[];
// 1010E5B4: using guessed type __int16 word_1010E5B4[];
// 1010E5B8: using guessed type int dword_1010E5B8[];
// 10291918: using guessed type char byte_10291918;

//----- (1005B4C0) --------------------------------------------------------
char sub_1005B4C0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1011", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_1010EBCC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1010EBC8[v2];
        v4 = dword_1010EBC4[v2];
        v5 = dword_1010EBC0[v2];
        v6 = sub_10054B60(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               (&off_1010EBD0)[v2 * 4]);
        v7 = sub_10056480(
               0,
               *(&dword_1010C734 + dword_1010EBCC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1011",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_1010EBCC[v2]],
               (&off_1010EBD0)[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1011",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1011",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010EBC0: using guessed type int dword_1010EBC0[];
// 1010EBC4: using guessed type int dword_1010EBC4[];
// 1010EBC8: using guessed type int dword_1010EBC8[];
// 1010EBCC: using guessed type int dword_1010EBCC[];
// 1010EBD0: using guessed type char *off_1010EBD0;
// 10291918: using guessed type char byte_10291918;

//----- (1005B620) --------------------------------------------------------
char sub_1005B620()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1037", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_1010F370[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1010F36C[v2];
        LODWORD(v3) = dword_1010F368[v2];
        HIDWORD(v4) = dword_1010F364[v2];
        LODWORD(v4) = dword_1010F360[v2];
        HIDWORD(v5) = dword_1010F35C[v2];
        LODWORD(v5) = dword_1010F358[v2];
        v6 = sub_10054B60(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               *(_DWORD *)&off_1010F374[v2 * 4]);
        v7 = sub_10056840(
               0,
               *(&dword_1010C734 + dword_1010F370[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1037",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_1010F370[v2]],
               *(_DWORD *)&off_1010F374[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1037",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1037",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010F358: using guessed type int dword_1010F358[];
// 1010F35C: using guessed type int dword_1010F35C[];
// 1010F360: using guessed type int dword_1010F360[];
// 1010F364: using guessed type int dword_1010F364[];
// 1010F368: using guessed type int dword_1010F368[];
// 1010F36C: using guessed type int dword_1010F36C[];
// 1010F370: using guessed type int dword_1010F370[];
// 10291918: using guessed type char byte_10291918;

//----- (1005B790) --------------------------------------------------------
char sub_1005B790()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1063", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_1010FF7C[v2];
      if ( v0 != 6 )
      {
        v3 = byte_1010FF7A[v2 * 4];
        v4 = byte_1010FF79[v2 * 4];
        v5 = byte_1010FF78[v2 * 4];
        v6 = sub_10054B60(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               (&off_1010FF80)[v2 * 4]);
        v7 = sub_10056D80(
               0,
               *(&dword_1010C734 + dword_1010FF7C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1063",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_1010FF7C[v2]],
               (&off_1010FF80)[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1063",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1063",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010FF7C: using guessed type int dword_1010FF7C[];
// 1010FF80: using guessed type char *off_1010FF80;
// 10291918: using guessed type char byte_10291918;

//----- (1005B8F0) --------------------------------------------------------
char sub_1005B8F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1089", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_10110414[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10110410[v2];
        v4 = dword_1011040C[v2];
        v5 = dword_10110408[v2];
        v6 = sub_10054B60(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               *(_DWORD *)&off_10110418[v2 * 4]);
        v7 = sub_10057160(
               0,
               *(&dword_1010C734 + dword_10110414[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1089",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_10110414[v2]],
               *(_DWORD *)&off_10110418[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1089",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1089",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10110408: using guessed type int dword_10110408[];
// 1011040C: using guessed type int dword_1011040C[];
// 10110410: using guessed type int dword_10110410[];
// 10110414: using guessed type int dword_10110414[];
// 10291918: using guessed type char byte_10291918;

//----- (1005BA50) --------------------------------------------------------
char sub_1005BA50()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10059BE0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_10054A50(0);
  sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1113", (int)v0);
  sub_10059BE0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10291918 )
  {
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"1121", 2, 2);
    v2 = sub_10059590(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1122",
           (int)"UTF_verify_eq_str( *, \"a\", \"\" ) data comparison",
           "a",
           &byte_100930C0,
           (int)"This test is expected to fail");
    sub_10054EC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1123",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"1125", 2, 2);
    v3 = sub_10059590(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1126",
           (int)"UTF_verify_eq_str( *, \"\", \"a\" ) data comparison",
           &byte_100930C0,
           "a",
           (int)"This test is expected to fail");
    sub_10054EC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1127",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"1129", 2, 2);
    v4 = sub_10059590(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1130",
           (int)"UTF_verify_ne_str( *, \"\", \"\" ) data comparison",
           &byte_100930C0,
           &byte_100930C0,
           (int)"This test is expected to fail");
    sub_10054EC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1131",
      (int)"Return value from previous UTF_verify_ne_str() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"1133", 2, 2);
    v5 = sub_10059590(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1134",
           (int)"UTF_verify_ne_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           (int)"This test is expected to fail");
    result = sub_10054EC0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1135",
               (int)"Return value from previous UTF_verify_ne_str() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1117",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10291918: using guessed type char byte_10291918;

//----- (1005BC70) --------------------------------------------------------
char sub_1005BC70()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1162", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_10110BAC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10110BA8[v2];
        v4 = dword_10110BA4[v2];
        v5 = dword_10110BA0[v2];
        v6 = sub_10054B60(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               (&off_10110BB0)[v2 * 4]);
        v7 = sub_10057520(
               0,
               *(&dword_1010C734 + dword_10110BAC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1162",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_10110BAC[v2]],
               (&off_10110BB0)[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1162",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1162",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10110BA0: using guessed type int dword_10110BA0[];
// 10110BA4: using guessed type int dword_10110BA4[];
// 10110BA8: using guessed type int dword_10110BA8[];
// 10110BAC: using guessed type int dword_10110BAC[];
// 10110BB0: using guessed type char *off_10110BB0;
// 10291918: using guessed type char byte_10291918;

//----- (1005BDD0) --------------------------------------------------------
char sub_1005BDD0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1188", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_10110F18[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_10110F14[v2 / 2];
        v4 = word_10110F12[v2 / 2];
        v5 = word_10110F10[v2 / 2];
        v6 = sub_10054B60(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               *(_DWORD *)&off_10110F1C[v2]);
        v7 = sub_100578C0(
               0,
               *(&dword_1010C734 + dword_10110F18[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1188",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_10110F18[v2 / 4]],
               *(_DWORD *)&off_10110F1C[v2]);
        LOBYTE(v0) = sub_10054EC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1188",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1188",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10110F10: using guessed type __int16 word_10110F10[];
// 10110F12: using guessed type __int16 word_10110F12[];
// 10110F14: using guessed type __int16 word_10110F14[];
// 10110F18: using guessed type int dword_10110F18[];
// 10291918: using guessed type char byte_10291918;

//----- (1005BF30) --------------------------------------------------------
char sub_1005BF30()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1214", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_101111DC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_101111D8[v2];
        v4 = dword_101111D4[v2];
        v5 = dword_101111D0[v2];
        v6 = sub_10054B60(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               (&off_101111E0)[v2 * 4]);
        v7 = sub_10057CC0(
               0,
               *(&dword_1010C734 + dword_101111DC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1214",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_101111DC[v2]],
               (&off_101111E0)[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1214",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1214",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 101111D0: using guessed type int dword_101111D0[];
// 101111D4: using guessed type int dword_101111D4[];
// 101111D8: using guessed type int dword_101111D8[];
// 101111DC: using guessed type int dword_101111DC[];
// 101111E0: using guessed type char *off_101111E0;
// 10291918: using guessed type char byte_10291918;

//----- (1005C090) --------------------------------------------------------
char sub_1005C090()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1240", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_10111558[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_10111554[v2];
        LODWORD(v3) = dword_10111550[v2];
        HIDWORD(v4) = dword_1011154C[v2];
        LODWORD(v4) = dword_10111548[v2];
        HIDWORD(v5) = dword_10111544[v2];
        LODWORD(v5) = dword_10111540[v2];
        v6 = sub_10054B60(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               *(_DWORD *)&off_1011155C[v2 * 4]);
        v7 = sub_10058060(
               0,
               *(&dword_1010C734 + dword_10111558[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1240",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_10111558[v2]],
               *(_DWORD *)&off_1011155C[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1240",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1240",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10111540: using guessed type int dword_10111540[];
// 10111544: using guessed type int dword_10111544[];
// 10111548: using guessed type int dword_10111548[];
// 1011154C: using guessed type int dword_1011154C[];
// 10111550: using guessed type int dword_10111550[];
// 10111554: using guessed type int dword_10111554[];
// 10111558: using guessed type int dword_10111558[];
// 10291918: using guessed type char byte_10291918;

//----- (1005C200) --------------------------------------------------------
char sub_1005C200()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1266", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_10111AC4[v2];
      if ( v0 != 6 )
      {
        v3 = byte_10111AC2[v2 * 4];
        v4 = byte_10111AC1[v2 * 4];
        v5 = byte_10111AC0[v2 * 4];
        v6 = sub_10054B60(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               (&off_10111AC8)[v2 * 4]);
        v7 = sub_10058640(
               0,
               *(&dword_1010C734 + dword_10111AC4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1266",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_10111AC4[v2]],
               (&off_10111AC8)[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1266",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1266",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10111AC4: using guessed type int dword_10111AC4[];
// 10111AC8: using guessed type char *off_10111AC8;
// 10291918: using guessed type char byte_10291918;

//----- (1005C360) --------------------------------------------------------
char sub_1005C360()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1292", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_10111CDC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10111CD8[v2];
        v4 = dword_10111CD4[v2];
        v5 = dword_10111CD0[v2];
        v6 = sub_10054B60(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               (&off_10111CE0)[v2 * 4]);
        v7 = sub_10058A30(
               0,
               *(&dword_1010C734 + dword_10111CDC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1292",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_10111CDC[v2]],
               (&off_10111CE0)[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1292",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1292",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10111CD0: using guessed type int dword_10111CD0[];
// 10111CD4: using guessed type int dword_10111CD4[];
// 10111CD8: using guessed type int dword_10111CD8[];
// 10111CDC: using guessed type int dword_10111CDC[];
// 10111CE0: using guessed type char *off_10111CE0;
// 10291918: using guessed type char byte_10291918;

//----- (1005C4C0) --------------------------------------------------------
char sub_1005C4C0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_10059BE0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"All Fail Robustness Test Group For Type 'bitmap'");
  v0 = sub_10054A50(0);
  sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1337", (int)v0);
  sub_10059BE0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10291918 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_10112044 + v2) )
      {
        sub_100548C0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_1011204C[v2], 0x100u, &v11);
        sub_100548C0((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_10112044 + v2), 0x100u, &v12);
        sub_10074B60(&v12, &v11);
      }
      if ( byte_10112040[v2] )
      {
        sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"1362", 2, 2);
        v3 = off_10112048[v2 / 4];
        v4 = *(char **)&off_1011204C[v2];
        v5 = sub_10054B60(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1011204C[v2],
               off_10112048[v2 / 4]);
        v6 = sub_100591E0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1367",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_10054EC0(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1369",
                   (int)"Return value from previous UTF_verify_eq_bitmap_rt() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"1373", 2, 2);
        v7 = off_10112048[v2 / 4];
        v8 = *(char **)&off_1011204C[v2];
        v9 = sub_10054B60(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1011204C[v2],
               off_10112048[v2 / 4]);
        v10 = sub_100591E0(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"1378",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_10054EC0(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1380",
                   (int)"Return value from previous UTF_verify_ne_bitmap_rt() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x90 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1341",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10112044: using guessed type void *off_10112044;
// 10112048: using guessed type char *off_10112048[2];
// 10291918: using guessed type char byte_10291918;

//----- (1005C6E0) --------------------------------------------------------
char sub_1005C6E0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10059BE0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_10054A50(0);
  sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1407", (int)v0);
  sub_10059BE0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"Verify relationship between boolean values using the UTF_verify_bool_rt() function");
  if ( byte_10291918 )
  {
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"1415", 2, 2);
    v2 = sub_10054EC0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1416",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_10054EC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1417",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"1419", 2, 2);
    v3 = sub_10054EC0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1420",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_10054EC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1421",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"1423", 2, 2);
    v4 = sub_10054EC0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1424",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_10054EC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1425",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"1427", 2, 2);
    v5 = sub_10054EC0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1428",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_10054EC0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1429",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1411",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10291918: using guessed type char byte_10291918;

//----- (1005C8E0) --------------------------------------------------------
char sub_1005C8E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1469", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_101120D4[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"1469", 2, 2);
        v3 = byte_101120D1[v2 * 4];
        v4 = byte_101120D0[v2 * 4];
        v5 = sub_10054B60(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + dword_101120D4[v2])],
               (&off_101120D8)[v2 * 4]);
        v6 = sub_10055000(
               1,
               *(&dword_1010C734 + dword_101120D4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1469",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_10054B60(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_101120D4[v2]],
               (&off_101120D8)[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1469",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1469",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 101120D4: using guessed type int dword_101120D4[];
// 101120D8: using guessed type char *off_101120D8;
// 10291918: using guessed type char byte_10291918;

//----- (1005CA60) --------------------------------------------------------
char sub_1005CA60()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1503", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_10112358[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_10112350[v2 / 8];
        v4 = dbl_10112348[v2 / 8];
        v5 = dbl_10112340[v2 / 8];
        v6 = sub_10054B60(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               *(_DWORD *)&off_1011235C[v2]);
        v7 = sub_100553B0(
               1,
               *(&dword_1010C734 + dword_10112358[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1503",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_10112358[v2 / 4]],
               *(_DWORD *)&off_1011235C[v2]);
        LOBYTE(v0) = sub_10054EC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1503",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1503",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10112340: using guessed type double dbl_10112340[];
// 10112348: using guessed type double dbl_10112348[];
// 10112350: using guessed type double dbl_10112350[];
// 10112358: using guessed type int dword_10112358[];
// 10291918: using guessed type char byte_10291918;

//----- (1005CBE0) --------------------------------------------------------
char sub_1005CBE0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1539", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_10112F6C[v2];
      if ( v0 != 6 )
      {
        v3 = flt_10112F68[v2];
        v4 = flt_10112F64[v2];
        v5 = flt_10112F60[v2];
        v6 = sub_10054B60(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               (&off_10112F70)[v2 * 4]);
        v7 = sub_10055800(
               1,
               *(&dword_1010C734 + dword_10112F6C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1539",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_10112F6C[v2]],
               (&off_10112F70)[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1539",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1539",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10112F60: using guessed type float flt_10112F60[];
// 10112F64: using guessed type float flt_10112F64[];
// 10112F68: using guessed type float flt_10112F68[];
// 10112F6C: using guessed type int dword_10112F6C[];
// 10112F70: using guessed type char *off_10112F70;
// 10291918: using guessed type char byte_10291918;

//----- (1005CD50) --------------------------------------------------------
char sub_1005CD50()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10059BE0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10054A50(0);
  sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1561", (int)v0);
  sub_10059BE0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10291918 )
  {
    sub_100594E0(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1569",
      (int)"Check ptr for equality",
      (int)sub_1005CD50,
      (int)sub_1005CD50,
      0);
    sub_100594E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1570",
      (int)"Check ptr for inequality",
      (int)sub_1005CD50,
      0,
      0);
    result = sub_100594E0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1571",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1005CD50,
               0);
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1565",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10291918: using guessed type char byte_10291918;

//----- (1005CE40) --------------------------------------------------------
char sub_1005CE40()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1598", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_10113704[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10113700[v2];
        v4 = dword_101136FC[v2];
        v5 = dword_101136F8[v2];
        v6 = sub_10054B60(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               *(_DWORD *)&off_10113708[v2 * 4]);
        v7 = sub_10055CC0(
               1,
               *(&dword_1010C734 + dword_10113704[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1598",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_10113704[v2]],
               *(_DWORD *)&off_10113708[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1598",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1598",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 101136F8: using guessed type int dword_101136F8[];
// 101136FC: using guessed type int dword_101136FC[];
// 10113700: using guessed type int dword_10113700[];
// 10113704: using guessed type int dword_10113704[];
// 10291918: using guessed type char byte_10291918;

//----- (1005CFA0) --------------------------------------------------------
char sub_1005CFA0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1624", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_10113E98[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_10113E94[v2 / 2];
        v4 = word_10113E92[v2 / 2];
        v5 = word_10113E90[v2 / 2];
        v6 = sub_10054B60(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               *(_DWORD *)&off_10113E9C[v2]);
        v7 = sub_10056080(
               1,
               *(&dword_1010C734 + dword_10113E98[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1624",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_10113E98[v2 / 4]],
               *(_DWORD *)&off_10113E9C[v2]);
        LOBYTE(v0) = sub_10054EC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1624",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1624",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10113E90: using guessed type __int16 word_10113E90[];
// 10113E92: using guessed type __int16 word_10113E92[];
// 10113E94: using guessed type __int16 word_10113E94[];
// 10113E98: using guessed type int dword_10113E98[];
// 10291918: using guessed type char byte_10291918;

//----- (1005D100) --------------------------------------------------------
char sub_1005D100()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1650", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_101144AC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_101144A8[v2];
        v4 = dword_101144A4[v2];
        v5 = dword_101144A0[v2];
        v6 = sub_10054B60(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               (&off_101144B0)[v2 * 4]);
        v7 = sub_10056480(
               1,
               *(&dword_1010C734 + dword_101144AC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1650",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_101144AC[v2]],
               (&off_101144B0)[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1650",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1650",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 101144A0: using guessed type int dword_101144A0[];
// 101144A4: using guessed type int dword_101144A4[];
// 101144A8: using guessed type int dword_101144A8[];
// 101144AC: using guessed type int dword_101144AC[];
// 101144B0: using guessed type char *off_101144B0;
// 10291918: using guessed type char byte_10291918;

//----- (1005D260) --------------------------------------------------------
char sub_1005D260()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1676", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_10114C50[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_10114C4C[v2];
        LODWORD(v3) = dword_10114C48[v2];
        HIDWORD(v4) = dword_10114C44[v2];
        LODWORD(v4) = dword_10114C40[v2];
        HIDWORD(v5) = dword_10114C3C[v2];
        LODWORD(v5) = dword_10114C38[v2];
        v6 = sub_10054B60(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               *(_DWORD *)&off_10114C54[v2 * 4]);
        v7 = sub_10056840(
               1,
               *(&dword_1010C734 + dword_10114C50[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1676",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_10114C50[v2]],
               *(_DWORD *)&off_10114C54[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1676",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1676",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10114C38: using guessed type int dword_10114C38[];
// 10114C3C: using guessed type int dword_10114C3C[];
// 10114C40: using guessed type int dword_10114C40[];
// 10114C44: using guessed type int dword_10114C44[];
// 10114C48: using guessed type int dword_10114C48[];
// 10114C4C: using guessed type int dword_10114C4C[];
// 10114C50: using guessed type int dword_10114C50[];
// 10291918: using guessed type char byte_10291918;

//----- (1005D3D0) --------------------------------------------------------
char sub_1005D3D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1702", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_1011585C[v2];
      if ( v0 != 6 )
      {
        v3 = byte_1011585A[v2 * 4];
        v4 = byte_10115859[v2 * 4];
        v5 = byte_10115858[v2 * 4];
        v6 = sub_10054B60(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               (&off_10115860)[v2 * 4]);
        v7 = sub_10056D80(
               1,
               *(&dword_1010C734 + dword_1011585C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1702",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_1011585C[v2]],
               (&off_10115860)[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1702",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1702",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1011585C: using guessed type int dword_1011585C[];
// 10115860: using guessed type char *off_10115860;
// 10291918: using guessed type char byte_10291918;

//----- (1005D530) --------------------------------------------------------
char sub_1005D530()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1728", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_10115CF4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10115CF0[v2];
        v4 = dword_10115CEC[v2];
        v5 = dword_10115CE8[v2];
        v6 = sub_10054B60(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               *(_DWORD *)&off_10115CF8[v2 * 4]);
        v7 = sub_10057160(
               1,
               *(&dword_1010C734 + dword_10115CF4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1728",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_10115CF4[v2]],
               *(_DWORD *)&off_10115CF8[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1728",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1728",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10115CE8: using guessed type int dword_10115CE8[];
// 10115CEC: using guessed type int dword_10115CEC[];
// 10115CF0: using guessed type int dword_10115CF0[];
// 10115CF4: using guessed type int dword_10115CF4[];
// 10291918: using guessed type char byte_10291918;

//----- (1005D690) --------------------------------------------------------
char sub_1005D690()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10059BE0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_10054A50(0);
  sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1752", (int)v0);
  sub_10059BE0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10291918 )
  {
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"1760", 2, 2);
    v2 = sub_10059590(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1761",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           &byte_100930C0,
           0);
    sub_10054EC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1762",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"1764", 2, 2);
    v3 = sub_10059590(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1765",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"a\" ) data comparison",
           &byte_100930C0,
           "a",
           0);
    sub_10054EC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1766",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"1768", 2, 2);
    v4 = sub_10059590(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1769",
           (int)"UTF_verify_ne_str_rt( *, \"\", \"\" ) data comparison",
           &byte_100930C0,
           &byte_100930C0,
           0);
    sub_10054EC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1770",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"1772", 2, 2);
    v5 = sub_10059590(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1773",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    result = sub_10054EC0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1774",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1756",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10291918: using guessed type char byte_10291918;

//----- (1005D890) --------------------------------------------------------
char sub_1005D890()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1801", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_1011648C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10116488[v2];
        v4 = dword_10116484[v2];
        v5 = dword_10116480[v2];
        v6 = sub_10054B60(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               (&off_10116490)[v2 * 4]);
        v7 = sub_10057520(
               1,
               *(&dword_1010C734 + dword_1011648C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1801",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_1011648C[v2]],
               (&off_10116490)[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1801",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1801",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10116480: using guessed type int dword_10116480[];
// 10116484: using guessed type int dword_10116484[];
// 10116488: using guessed type int dword_10116488[];
// 1011648C: using guessed type int dword_1011648C[];
// 10116490: using guessed type char *off_10116490;
// 10291918: using guessed type char byte_10291918;

//----- (1005D9F0) --------------------------------------------------------
char sub_1005D9F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1827", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_101167F8[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_101167F4[v2 / 2];
        v4 = word_101167F2[v2 / 2];
        v5 = word_101167F0[v2 / 2];
        v6 = sub_10054B60(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               *(_DWORD *)&off_101167FC[v2]);
        v7 = sub_100578C0(
               1,
               *(&dword_1010C734 + dword_101167F8[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1827",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_101167F8[v2 / 4]],
               *(_DWORD *)&off_101167FC[v2]);
        LOBYTE(v0) = sub_10054EC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1827",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1827",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 101167F0: using guessed type __int16 word_101167F0[];
// 101167F2: using guessed type __int16 word_101167F2[];
// 101167F4: using guessed type __int16 word_101167F4[];
// 101167F8: using guessed type int dword_101167F8[];
// 10291918: using guessed type char byte_10291918;

//----- (1005DB50) --------------------------------------------------------
char sub_1005DB50()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1853", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_10116ABC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10116AB8[v2];
        v4 = dword_10116AB4[v2];
        v5 = dword_10116AB0[v2];
        v6 = sub_10054B60(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               (&off_10116AC0)[v2 * 4]);
        v7 = sub_10057CC0(
               1,
               *(&dword_1010C734 + dword_10116ABC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1853",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_10116ABC[v2]],
               (&off_10116AC0)[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1853",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1853",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10116AB0: using guessed type int dword_10116AB0[];
// 10116AB4: using guessed type int dword_10116AB4[];
// 10116AB8: using guessed type int dword_10116AB8[];
// 10116ABC: using guessed type int dword_10116ABC[];
// 10116AC0: using guessed type char *off_10116AC0;
// 10291918: using guessed type char byte_10291918;

//----- (1005DCB0) --------------------------------------------------------
char sub_1005DCB0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1879", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_10116E38[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_10116E34[v2];
        LODWORD(v3) = dword_10116E30[v2];
        HIDWORD(v4) = dword_10116E2C[v2];
        LODWORD(v4) = dword_10116E28[v2];
        HIDWORD(v5) = dword_10116E24[v2];
        LODWORD(v5) = dword_10116E20[v2];
        v6 = sub_10054B60(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               *(_DWORD *)&off_10116E3C[v2 * 4]);
        v7 = sub_10058060(
               1,
               *(&dword_1010C734 + dword_10116E38[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1879",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_10116E38[v2]],
               *(_DWORD *)&off_10116E3C[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1879",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1879",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10116E20: using guessed type int dword_10116E20[];
// 10116E24: using guessed type int dword_10116E24[];
// 10116E28: using guessed type int dword_10116E28[];
// 10116E2C: using guessed type int dword_10116E2C[];
// 10116E30: using guessed type int dword_10116E30[];
// 10116E34: using guessed type int dword_10116E34[];
// 10116E38: using guessed type int dword_10116E38[];
// 10291918: using guessed type char byte_10291918;

//----- (1005DE20) --------------------------------------------------------
char sub_1005DE20()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1905", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_101173A4[v2];
      if ( v0 != 6 )
      {
        v3 = byte_101173A2[v2 * 4];
        v4 = byte_101173A1[v2 * 4];
        v5 = byte_101173A0[v2 * 4];
        v6 = sub_10054B60(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               (&off_101173A8)[v2 * 4]);
        v7 = sub_10058640(
               1,
               *(&dword_1010C734 + dword_101173A4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1905",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_101173A4[v2]],
               (&off_101173A8)[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1905",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1905",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 101173A4: using guessed type int dword_101173A4[];
// 101173A8: using guessed type char *off_101173A8;
// 10291918: using guessed type char byte_10291918;

//----- (1005DF80) --------------------------------------------------------
char sub_1005DF80()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10291918 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1931", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_101175BC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_101175B8[v2];
        v4 = dword_101175B4[v2];
        v5 = dword_101175B0[v2];
        v6 = sub_10054B60(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * *(&dword_1010C734 + v0)],
               (&off_101175C0)[v2 * 4]);
        v7 = sub_10058A30(
               1,
               *(&dword_1010C734 + dword_101175BC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1931",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10054B60(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_101175BC[v2]],
               (&off_101175C0)[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1931",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1931",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 101175B0: using guessed type int dword_101175B0[];
// 101175B4: using guessed type int dword_101175B4[];
// 101175B8: using guessed type int dword_101175B8[];
// 101175BC: using guessed type int dword_101175BC[];
// 101175C0: using guessed type char *off_101175C0;
// 10291918: using guessed type char byte_10291918;

//----- (1005E0E0) --------------------------------------------------------
char sub_1005E0E0()
{
  const char *v0; // eax@1
  int v1; // esi@1
  char result; // al@2
  char v3; // al@5

  sub_10059BE0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"All Pass Miscellaneous Test Group");
  v0 = sub_10054A50(0);
  sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1968", (int)v0);
  sub_10059BE0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"Verify miscellaneous macros");
  v1 = 5;
  if ( byte_10291919 )
  {
    sub_10059590(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1978",
      (int)"Check PASS macro",
      "UTF_verify_pass unconditional pass",
      "UTF_verify_pass unconditional pass",
      0);
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"1987", 0, 0);
    sub_10059BE0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1988", (int)"Sub-group A, msg 1");
    sub_10059BE0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1989", (int)"Sub-group A, msg 2");
    sub_10059BE0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1990", (int)"Sub-group A, msg 3");
    sub_10059BE0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1991", (int)"Sub-group A, msg 4");
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"1993", 0, 0);
    sub_10059BE0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1994", (int)"Sub-group B, msg 1");
    sub_10059BE0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1995", (int)"Sub-group B, msg 2");
    sub_10059BE0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1996", (int)"Sub-group B, msg 3");
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"1998", 1, 2);
    sub_10055CC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"1999", (int)"Sub-group C verify 1", 1, 1, 0, 0);
    sub_10059BE0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2000", (int)"Sub-group C, msg 1");
    sub_10059BE0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2001", (int)"Sub-group C, msg 2");
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2003", 2, 2);
    sub_10059BE0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2004", (int)"Sub-group D, msg 1");
    sub_10055CC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2005", (int)"Sub-group D verify 1", 1, 1, 0, 0);
    sub_10059BE0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2006", (int)"Sub-group D, msg 2");
    sub_10055CC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2007", (int)"Sub-group D verify 2", 2, 2, 0, 0);
    sub_10059BE0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2009", (int)"non sub-group msg 1");
    sub_10059BE0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2010", (int)"non sub-group msg 2");
    sub_10055CC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2011", (int)"non sub-group verify 1", 1, 1, 0, 0);
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2013", 3, 4);
    sub_10059BE0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2014", (int)"Sub-group E, msg 1");
    sub_10055CC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2015", (int)"Sub-group E verify 1", 1, 1, 0, 0);
    sub_10059BE0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2016", (int)"Sub-group E, msg 2");
    sub_10055CC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2017", (int)"Sub-group E verify 2", 2, 2, 0, 0);
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2019", 3, 4);
    sub_10055CC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2020", (int)"Sub-group F verify 1", 1, 1, 0, 0);
    sub_10059BE0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2021", (int)"Sub-group F, msg 1");
    sub_10055CC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2022", (int)"Sub-group F verify 2", 2, 2, 0, 0);
    sub_10059BE0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2023", (int)"Sub-group F, msg 2");
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2025", 4, 0);
    sub_10055CC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2026", (int)"Sub-group G verify 1", 1, 1, 0, 0);
    sub_10059BE0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2027", (int)"Sub-group G, msg 1");
    sub_10059BE0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2028", (int)"Sub-group G, msg 2");
    sub_10055CC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2029", (int)"Sub-group G verify 2", 2, 2, 0, 0);
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2030", 5, 0);
    sub_10059BE0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2032", (int)"non sub-group msg 3");
    sub_10059BE0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2033", (int)"non sub-group msg 4");
    sub_10055CC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2034", (int)"non sub-group verify 2", 2, 2, 0, 0);
    if ( !sub_10065800() )
      v1 = 3;
    sub_10055CC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2037",
      (int)"Verify x is 3 using UTF_CALL_UNIT",
      v1,
      3,
      0,
      0);
    v3 = sub_10065800();
    sub_10055CC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2040",
      (int)"Verify x is 4 using UTF_CALL_UNIT2",
      v3 != 0 ? 6 : 4,
      4,
      0,
      0);
    sub_10059BE0(
      3,
      (int)"**MSG**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2042",
      (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceeds the int"
           "ernal UTF buffer size, can be written to the output without the system crashing or otherwise demonstrating ha"
           "rmful side-effects. If the system does crash while writing this message, it is a sign that possibly the UTF h"
           "as some buffer overlow issues that should be examined and corrected. If the system runs successfully, it does"
           " not prove the UTF is defect free in this regard, only that this particular scenario is succesfully handled u"
           "nder the current conditions. Other invocations of UTF interfaces with large messages may be problematic, but "
           "at least on the surface, things seem to be OK for now.");
    result = sub_10055CC0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2043",
               (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceed"
                    "s the internal UTF buffer size, can be written to the output without the system crashing or otherwis"
                    "e demonstrating harmful side-effects. If the system does crash while writing this message, it is a s"
                    "ign that possibly the UTF has some buffer overlow issues that should be examined and corrected. If t"
                    "he system runs successfully, it does not prove the UTF is defect free in this regard, only that this"
                    " particular scenario is succesfully handled under the current conditions. Other invocations of UTF i"
                    "nterfaces with large messages may be problematic, but at least on the surface, things seem to be OK for now.",
               4,
               4,
               0,
               0);
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1974",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10291919: using guessed type char byte_10291919;

//----- (1005E680) --------------------------------------------------------
char sub_1005E680()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  int v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  int v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_10059BE0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"All Pass Test Group For Type 'bitmap'");
  v0 = sub_10054A50(0);
  sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2085", (int)v0);
  sub_10059BE0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10291919 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_10117924 + v2) )
      {
        sub_100548C0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_1011792C[v2], 0x100u, &v13);
        sub_100548C0((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_10117924 + v2), 0x100u, &v14);
        sub_10074B60(&v14, &v13);
      }
      if ( byte_10117920[v2] )
      {
        sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2110", 2, 2);
        v3 = *(int *)((char *)&off_10117928 + v2);
        v4 = *(char **)&off_1011792C[v2];
        v5 = sub_10054B60(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1011792C[v2],
               *(void **)((char *)&off_10117928 + v2));
        v12 = 1;
        v11 = sub_100591E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2114", (int)v5, (int)v4, v3, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_eq_bitmap() call";
        v9 = "2115";
      }
      else
      {
        sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2119", 2, 2);
        v6 = *(int *)((char *)&off_10117928 + v2);
        v7 = *(char **)&off_1011792C[v2];
        v8 = sub_10054B60(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1011792C[v2],
               *(void **)((char *)&off_10117928 + v2));
        v12 = 1;
        v11 = sub_100591E0(0, 1, (int)"..\\lib\\utf\\utf_validate.c", (int)"2123", (int)v8, (int)v7, v6, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_ne_bitmap() call";
        v9 = "2124";
      }
      result = sub_10054EC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 16;
    }
    while ( v2 < 0x50 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2089",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10117924: using guessed type void *off_10117924;
// 10117928: using guessed type void *off_10117928;
// 10291919: using guessed type char byte_10291919;

//----- (1005E890) --------------------------------------------------------
char sub_1005E890()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10059BE0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_10054A50(0);
  sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2151", (int)v0);
  sub_10059BE0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10291919 )
  {
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2159", 2, 2);
    v2 = sub_10054EC0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2160",
           (int)"UTF_verify_eq_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_10054EC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2161",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      0);
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2163", 2, 2);
    v3 = sub_10054EC0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2164",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_10054EC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2165",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      0);
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2167", 2, 2);
    v4 = sub_10054EC0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2168",
           (int)"UTF_verify_ne_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_10054EC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2169",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      0);
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2171", 2, 2);
    v5 = sub_10054EC0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2172",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_10054EC0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2173",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2155",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10291919: using guessed type char byte_10291919;

//----- (1005EA80) --------------------------------------------------------
char sub_1005EA80()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_10117974[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2213", 2, 2);
        v3 = byte_10117971[v2 * 4];
        v4 = byte_10117970[v2 * 4];
        v5 = sub_10054B60(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * dword_10117974[v2]],
               (&off_10117978)[v2 * 4]);
        v6 = sub_10055000(0, dword_10117974[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v5, v4, v3, 0);
        v7 = sub_10054B60(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_10117974[v2]],
               (&off_10117978)[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2213",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 10117974: using guessed type int dword_10117974[];
// 10117978: using guessed type char *off_10117978;
// 10291919: using guessed type char byte_10291919;

//----- (1005EBF0) --------------------------------------------------------
char sub_1005EBF0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2247", 2, 2);
      v3 = dbl_10117BF0[v2 / 2];
      v4 = dbl_10117BE8[v2 / 2];
      v5 = dbl_10117BE0[v2 / 2];
      v6 = sub_10054B60(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_10117BF8[v2]],
             *(_DWORD *)&off_10117BFC[v2 * 4]);
      v7 = sub_100553B0(0, dword_10117BF8[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_10117BF8[v2]],
             *(_DWORD *)&off_10117BFC[v2 * 4]);
      result = sub_10054EC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2247",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10117BE0: using guessed type double dbl_10117BE0[];
// 10117BE8: using guessed type double dbl_10117BE8[];
// 10117BF0: using guessed type double dbl_10117BF0[];
// 10117BF8: using guessed type int dword_10117BF8[];
// 10291919: using guessed type char byte_10291919;

//----- (1005ED60) --------------------------------------------------------
char sub_1005ED60()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2283", 2, 2);
      v3 = flt_10118808[v2];
      v4 = flt_10118804[v2];
      v5 = flt_10118800[v2];
      v6 = sub_10054B60(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_1011880C[v2]],
             (&off_10118810)[v2 * 4]);
      v7 = sub_10055800(0, dword_1011880C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_1011880C[v2]],
             (&off_10118810)[v2 * 4]);
      result = sub_10054EC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2283",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10118800: using guessed type float flt_10118800[];
// 10118804: using guessed type float flt_10118804[];
// 10118808: using guessed type float flt_10118808[];
// 1011880C: using guessed type int dword_1011880C[];
// 10118810: using guessed type char *off_10118810;
// 10291919: using guessed type char byte_10291919;

//----- (1005EEC0) --------------------------------------------------------
char sub_1005EEC0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10059BE0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10054A50(0);
  sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2305", (int)v0);
  sub_10059BE0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10291919 )
  {
    sub_100594E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2313",
      (int)"Check ptr for equality",
      (int)sub_1005EEC0,
      (int)sub_1005EEC0,
      0);
    sub_100594E0(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2314",
      (int)"Check ptr for inequality",
      (int)sub_1005EEC0,
      0,
      0);
    result = sub_100594E0(
               0,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2315",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1005EEC0,
               0);
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2309",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10291919: using guessed type char byte_10291919;

//----- (1005EFB0) --------------------------------------------------------
char sub_1005EFB0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2342", 2, 2);
      v3 = dword_10118FA0[v2];
      v4 = dword_10118F9C[v2];
      v5 = dword_10118F98[v2];
      v6 = sub_10054B60(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_10118FA4[v2]],
             *(_DWORD *)&off_10118FA8[v2 * 4]);
      v7 = sub_10055CC0(0, dword_10118FA4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_10118FA4[v2]],
             *(_DWORD *)&off_10118FA8[v2 * 4]);
      result = sub_10054EC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2342",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10118F98: using guessed type int dword_10118F98[];
// 10118F9C: using guessed type int dword_10118F9C[];
// 10118FA0: using guessed type int dword_10118FA0[];
// 10118FA4: using guessed type int dword_10118FA4[];
// 10291919: using guessed type char byte_10291919;

//----- (1005F110) --------------------------------------------------------
char sub_1005F110()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2368", 2, 2);
      v3 = word_10119734[v2 / 2];
      v4 = word_10119732[v2 / 2];
      v5 = word_10119730[v2 / 2];
      v6 = sub_10054B60(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_10119738[v2 / 4]],
             *(_DWORD *)&off_1011973C[v2]);
      v7 = sub_10056080(
             0,
             dword_10119738[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2368",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_10119738[v2 / 4]],
             *(_DWORD *)&off_1011973C[v2]);
      result = sub_10054EC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2368",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10119730: using guessed type __int16 word_10119730[];
// 10119732: using guessed type __int16 word_10119732[];
// 10119734: using guessed type __int16 word_10119734[];
// 10119738: using guessed type int dword_10119738[];
// 10291919: using guessed type char byte_10291919;

//----- (1005F270) --------------------------------------------------------
char sub_1005F270()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2394", 2, 2);
      v3 = dword_10119D48[v2];
      v4 = dword_10119D44[v2];
      v5 = dword_10119D40[v2];
      v6 = sub_10054B60(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_10119D4C[v2]],
             (&off_10119D50)[v2 * 4]);
      v7 = sub_10056480(0, dword_10119D4C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_10119D4C[v2]],
             (&off_10119D50)[v2 * 4]);
      result = sub_10054EC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2394",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10119D40: using guessed type int dword_10119D40[];
// 10119D44: using guessed type int dword_10119D44[];
// 10119D48: using guessed type int dword_10119D48[];
// 10119D4C: using guessed type int dword_10119D4C[];
// 10119D50: using guessed type char *off_10119D50;
// 10291919: using guessed type char byte_10291919;

//----- (1005F3D0) --------------------------------------------------------
char sub_1005F3D0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2420", 2, 2);
      HIDWORD(v3) = dword_1011A4EC[v2];
      LODWORD(v3) = dword_1011A4E8[v2];
      HIDWORD(v4) = dword_1011A4E4[v2];
      LODWORD(v4) = dword_1011A4E0[v2];
      HIDWORD(v5) = dword_1011A4DC[v2];
      LODWORD(v5) = dword_1011A4D8[v2];
      v6 = sub_10054B60(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_1011A4F0[v2]],
             *(_DWORD *)&off_1011A4F4[v2 * 4]);
      v7 = sub_10056840(0, dword_1011A4F0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_1011A4F0[v2]],
             *(_DWORD *)&off_1011A4F4[v2 * 4]);
      result = sub_10054EC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2420",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011A4D8: using guessed type int dword_1011A4D8[];
// 1011A4DC: using guessed type int dword_1011A4DC[];
// 1011A4E0: using guessed type int dword_1011A4E0[];
// 1011A4E4: using guessed type int dword_1011A4E4[];
// 1011A4E8: using guessed type int dword_1011A4E8[];
// 1011A4EC: using guessed type int dword_1011A4EC[];
// 1011A4F0: using guessed type int dword_1011A4F0[];
// 10291919: using guessed type char byte_10291919;

//----- (1005F540) --------------------------------------------------------
char sub_1005F540()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2446", 2, 2);
      v3 = byte_1011B0FA[v2 * 4];
      v4 = byte_1011B0F9[v2 * 4];
      v5 = byte_1011B0F8[v2 * 4];
      v6 = sub_10054B60(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_1011B0FC[v2]],
             (&off_1011B100)[v2 * 4]);
      v7 = sub_10056D80(0, dword_1011B0FC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_1011B0FC[v2]],
             (&off_1011B100)[v2 * 4]);
      result = sub_10054EC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2446",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011B0FC: using guessed type int dword_1011B0FC[];
// 1011B100: using guessed type char *off_1011B100;
// 10291919: using guessed type char byte_10291919;

//----- (1005F6A0) --------------------------------------------------------
char sub_1005F6A0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2472", 2, 2);
      v3 = dword_1011B590[v2];
      v4 = dword_1011B58C[v2];
      v5 = dword_1011B588[v2];
      v6 = sub_10054B60(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_1011B594[v2]],
             *(_DWORD *)&off_1011B598[v2 * 4]);
      v7 = sub_10057160(0, dword_1011B594[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_1011B594[v2]],
             *(_DWORD *)&off_1011B598[v2 * 4]);
      result = sub_10054EC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2472",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011B588: using guessed type int dword_1011B588[];
// 1011B58C: using guessed type int dword_1011B58C[];
// 1011B590: using guessed type int dword_1011B590[];
// 1011B594: using guessed type int dword_1011B594[];
// 10291919: using guessed type char byte_10291919;

//----- (1005F800) --------------------------------------------------------
char sub_1005F800()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10059BE0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_10054A50(0);
  sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2496", (int)v0);
  sub_10059BE0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10291919 )
  {
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2504", 2, 2);
    v2 = sub_10059590(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2505",
           (int)"UTF_verify_eq_str( *, \"\", \"\" ) data comparison",
           &byte_100930C0,
           &byte_100930C0,
           0);
    sub_10054EC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2506",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      0);
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2508", 2, 2);
    v3 = sub_10059590(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2509",
           (int)"UTF_verify_eq_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_10054EC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2510",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      0);
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2512", 2, 2);
    v4 = sub_10059590(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2513",
           (int)"UTF_verify_ne_str( *, \"a\", \"\" ) data comparison",
           "a",
           &byte_100930C0,
           0);
    sub_10054EC0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2514",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v4,
      1u,
      0);
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2516", 2, 2);
    v5 = sub_10059590(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2517",
           (int)"UTF_verify_ne_str( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_10054EC0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2518",
               (int)"Return value from previous UTF_verify_eq_str() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2500",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10291919: using guessed type char byte_10291919;

//----- (1005FA00) --------------------------------------------------------
char sub_1005FA00()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2545", 2, 2);
      v3 = dword_1011BD28[v2];
      v4 = dword_1011BD24[v2];
      v5 = dword_1011BD20[v2];
      v6 = sub_10054B60(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_1011BD2C[v2]],
             (&off_1011BD30)[v2 * 4]);
      v7 = sub_10057520(0, dword_1011BD2C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_1011BD2C[v2]],
             (&off_1011BD30)[v2 * 4]);
      result = sub_10054EC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2545",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011BD20: using guessed type int dword_1011BD20[];
// 1011BD24: using guessed type int dword_1011BD24[];
// 1011BD28: using guessed type int dword_1011BD28[];
// 1011BD2C: using guessed type int dword_1011BD2C[];
// 1011BD30: using guessed type char *off_1011BD30;
// 10291919: using guessed type char byte_10291919;

//----- (1005FB60) --------------------------------------------------------
char sub_1005FB60()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2571", 2, 2);
      v3 = word_1011C094[v2 / 2];
      v4 = word_1011C092[v2 / 2];
      v5 = word_1011C090[v2 / 2];
      v6 = sub_10054B60(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_1011C098[v2 / 4]],
             *(_DWORD *)&off_1011C09C[v2]);
      v7 = sub_100578C0(
             0,
             dword_1011C098[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2571",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_1011C098[v2 / 4]],
             *(_DWORD *)&off_1011C09C[v2]);
      result = sub_10054EC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2571",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011C090: using guessed type __int16 word_1011C090[];
// 1011C092: using guessed type __int16 word_1011C092[];
// 1011C094: using guessed type __int16 word_1011C094[];
// 1011C098: using guessed type int dword_1011C098[];
// 10291919: using guessed type char byte_10291919;

//----- (1005FCC0) --------------------------------------------------------
char sub_1005FCC0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2597", 2, 2);
      v3 = dword_1011C358[v2];
      v4 = dword_1011C354[v2];
      v5 = dword_1011C350[v2];
      v6 = sub_10054B60(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_1011C35C[v2]],
             (&off_1011C360)[v2 * 4]);
      v7 = sub_10057CC0(0, dword_1011C35C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_1011C35C[v2]],
             (&off_1011C360)[v2 * 4]);
      result = sub_10054EC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2597",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011C350: using guessed type int dword_1011C350[];
// 1011C354: using guessed type int dword_1011C354[];
// 1011C358: using guessed type int dword_1011C358[];
// 1011C35C: using guessed type int dword_1011C35C[];
// 1011C360: using guessed type char *off_1011C360;
// 10291919: using guessed type char byte_10291919;

//----- (1005FE20) --------------------------------------------------------
char sub_1005FE20()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2623", 2, 2);
      HIDWORD(v3) = dword_1011C6D4[v2];
      LODWORD(v3) = dword_1011C6D0[v2];
      HIDWORD(v4) = dword_1011C6CC[v2];
      LODWORD(v4) = dword_1011C6C8[v2];
      HIDWORD(v5) = dword_1011C6C4[v2];
      LODWORD(v5) = dword_1011C6C0[v2];
      v6 = sub_10054B60(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_1011C6D8[v2]],
             *(_DWORD *)&off_1011C6DC[v2 * 4]);
      v7 = sub_10058060(0, dword_1011C6D8[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_1011C6D8[v2]],
             *(_DWORD *)&off_1011C6DC[v2 * 4]);
      result = sub_10054EC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2623",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011C6C0: using guessed type int dword_1011C6C0[];
// 1011C6C4: using guessed type int dword_1011C6C4[];
// 1011C6C8: using guessed type int dword_1011C6C8[];
// 1011C6CC: using guessed type int dword_1011C6CC[];
// 1011C6D0: using guessed type int dword_1011C6D0[];
// 1011C6D4: using guessed type int dword_1011C6D4[];
// 1011C6D8: using guessed type int dword_1011C6D8[];
// 10291919: using guessed type char byte_10291919;

//----- (1005FF90) --------------------------------------------------------
char sub_1005FF90()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2649", 2, 2);
      v3 = byte_1011CC42[v2 * 4];
      v4 = byte_1011CC41[v2 * 4];
      v5 = byte_1011CC40[v2 * 4];
      v6 = sub_10054B60(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_1011CC44[v2]],
             (&off_1011CC48)[v2 * 4]);
      v7 = sub_10058640(0, dword_1011CC44[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_1011CC44[v2]],
             (&off_1011CC48)[v2 * 4]);
      result = sub_10054EC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2649",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011CC44: using guessed type int dword_1011CC44[];
// 1011CC48: using guessed type char *off_1011CC48;
// 10291919: using guessed type char byte_10291919;

//----- (100600F0) --------------------------------------------------------
char sub_100600F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2675", 2, 2);
      v3 = dword_1011CE58[v2];
      v4 = dword_1011CE54[v2];
      v5 = dword_1011CE50[v2];
      v6 = sub_10054B60(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_1011CE5C[v2]],
             (&off_1011CE60)[v2 * 4]);
      v7 = sub_10058A30(0, dword_1011CE5C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_1011CE5C[v2]],
             (&off_1011CE60)[v2 * 4]);
      result = sub_10054EC0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2675",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011CE50: using guessed type int dword_1011CE50[];
// 1011CE54: using guessed type int dword_1011CE54[];
// 1011CE58: using guessed type int dword_1011CE58[];
// 1011CE5C: using guessed type int dword_1011CE5C[];
// 1011CE60: using guessed type char *off_1011CE60;
// 10291919: using guessed type char byte_10291919;

//----- (10060250) --------------------------------------------------------
char sub_10060250()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  int v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  int v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_10059BE0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"All Pass Robustness Test Group For Type 'bitmap'");
  v0 = sub_10054A50(0);
  sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2716", (int)v0);
  sub_10059BE0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10291919 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_1011D1C4 + v2) )
      {
        sub_100548C0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_1011D1CC[v2], 0x100u, &v13);
        sub_100548C0((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_1011D1C4 + v2), 0x100u, &v14);
        sub_10074B60(&v14, &v13);
      }
      if ( byte_1011D1C0[v2] )
      {
        sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2741", 2, 2);
        v3 = *(int *)((char *)&off_1011D1C8 + v2);
        v4 = *(char **)&off_1011D1CC[v2];
        v5 = sub_10054B60(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1011D1CC[v2],
               *(void **)((char *)&off_1011D1C8 + v2));
        v12 = 1;
        v11 = sub_100591E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2745", (int)v5, (int)v4, v3, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_eq_bitmap_rt() call";
        v9 = "2746";
      }
      else
      {
        sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2750", 2, 2);
        v6 = *(int *)((char *)&off_1011D1C8 + v2);
        v7 = *(char **)&off_1011D1CC[v2];
        v8 = sub_10054B60(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1011D1CC[v2],
               *(void **)((char *)&off_1011D1C8 + v2));
        v12 = 1;
        v11 = sub_100591E0(1, 1, (int)"..\\lib\\utf\\utf_validate.c", (int)"2754", (int)v8, (int)v7, v6, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_ne_bitmap_rt() call";
        v9 = "2755";
      }
      result = sub_10054EC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 16;
    }
    while ( v2 < 0x50 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2720",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011D1C4: using guessed type void *off_1011D1C4;
// 1011D1C8: using guessed type void *off_1011D1C8;
// 10291919: using guessed type char byte_10291919;

//----- (10060460) --------------------------------------------------------
char sub_10060460()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10059BE0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_10054A50(0);
  sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2782", (int)v0);
  sub_10059BE0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10291919 )
  {
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2790", 2, 2);
    v2 = sub_10054EC0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2791",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_10054EC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2792",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      0);
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2794", 2, 2);
    v3 = sub_10054EC0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2795",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_10054EC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2796",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      0);
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2798", 2, 2);
    v4 = sub_10054EC0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2799",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_10054EC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2800",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      0);
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2802", 2, 2);
    v5 = sub_10054EC0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2803",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_10054EC0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2804",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2786",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10291919: using guessed type char byte_10291919;

//----- (10060650) --------------------------------------------------------
char sub_10060650()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      v0 = dword_1011D214[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2844", 2, 2);
        v3 = byte_1011D211[v2 * 4];
        v4 = byte_1011D210[v2 * 4];
        v5 = sub_10054B60(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1010C718[4 * dword_1011D214[v2]],
               (&off_1011D218)[v2 * 4]);
        v6 = sub_10055000(1, dword_1011D214[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v5, v4, v3, 0);
        v7 = sub_10054B60(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1010C718[4 * dword_1011D214[v2]],
               (&off_1011D218)[v2 * 4]);
        LOBYTE(v0) = sub_10054EC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10059BE0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2844",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 1011D214: using guessed type int dword_1011D214[];
// 1011D218: using guessed type char *off_1011D218;
// 10291919: using guessed type char byte_10291919;

//----- (100607C0) --------------------------------------------------------
char sub_100607C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2878", 2, 2);
      v3 = dbl_1011D490[v2 / 2];
      v4 = dbl_1011D488[v2 / 2];
      v5 = dbl_1011D480[v2 / 2];
      v6 = sub_10054B60(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_1011D498[v2]],
             *(_DWORD *)&off_1011D49C[v2 * 4]);
      v7 = sub_100553B0(1, dword_1011D498[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_1011D498[v2]],
             *(_DWORD *)&off_1011D49C[v2 * 4]);
      result = sub_10054EC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2878",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011D480: using guessed type double dbl_1011D480[];
// 1011D488: using guessed type double dbl_1011D488[];
// 1011D490: using guessed type double dbl_1011D490[];
// 1011D498: using guessed type int dword_1011D498[];
// 10291919: using guessed type char byte_10291919;

//----- (10060930) --------------------------------------------------------
char sub_10060930()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2914", 2, 2);
      v3 = flt_1011E0A8[v2];
      v4 = flt_1011E0A4[v2];
      v5 = flt_1011E0A0[v2];
      v6 = sub_10054B60(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_1011E0AC[v2]],
             (&off_1011E0B0)[v2 * 4]);
      v7 = sub_10055800(1, dword_1011E0AC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_1011E0AC[v2]],
             (&off_1011E0B0)[v2 * 4]);
      result = sub_10054EC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2914",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011E0A0: using guessed type float flt_1011E0A0[];
// 1011E0A4: using guessed type float flt_1011E0A4[];
// 1011E0A8: using guessed type float flt_1011E0A8[];
// 1011E0AC: using guessed type int dword_1011E0AC[];
// 1011E0B0: using guessed type char *off_1011E0B0;
// 10291919: using guessed type char byte_10291919;

//----- (10060A90) --------------------------------------------------------
char sub_10060A90()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10059BE0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10054A50(0);
  sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2936", (int)v0);
  sub_10059BE0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10291919 )
  {
    sub_100594E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2944",
      (int)"Check ptr for equality",
      (int)sub_10060A90,
      (int)sub_10060A90,
      0);
    sub_100594E0(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2945",
      (int)"Check ptr for inequality",
      (int)sub_10060A90,
      0,
      0);
    result = sub_100594E0(
               1,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2946",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10060A90,
               0);
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2940",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10291919: using guessed type char byte_10291919;

//----- (10060B80) --------------------------------------------------------
char sub_10060B80()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2973", 2, 2);
      v3 = dword_1011E840[v2];
      v4 = dword_1011E83C[v2];
      v5 = dword_1011E838[v2];
      v6 = sub_10054B60(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_1011E844[v2]],
             *(_DWORD *)&off_1011E848[v2 * 4]);
      v7 = sub_10055CC0(1, dword_1011E844[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_1011E844[v2]],
             *(_DWORD *)&off_1011E848[v2 * 4]);
      result = sub_10054EC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2973",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011E838: using guessed type int dword_1011E838[];
// 1011E83C: using guessed type int dword_1011E83C[];
// 1011E840: using guessed type int dword_1011E840[];
// 1011E844: using guessed type int dword_1011E844[];
// 10291919: using guessed type char byte_10291919;

//----- (10060CE0) --------------------------------------------------------
char sub_10060CE0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"2999", 2, 2);
      v3 = word_1011EFD4[v2 / 2];
      v4 = word_1011EFD2[v2 / 2];
      v5 = word_1011EFD0[v2 / 2];
      v6 = sub_10054B60(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_1011EFD8[v2 / 4]],
             *(_DWORD *)&off_1011EFDC[v2]);
      v7 = sub_10056080(
             1,
             dword_1011EFD8[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2999",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_1011EFD8[v2 / 4]],
             *(_DWORD *)&off_1011EFDC[v2]);
      result = sub_10054EC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2999",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011EFD0: using guessed type __int16 word_1011EFD0[];
// 1011EFD2: using guessed type __int16 word_1011EFD2[];
// 1011EFD4: using guessed type __int16 word_1011EFD4[];
// 1011EFD8: using guessed type int dword_1011EFD8[];
// 10291919: using guessed type char byte_10291919;

//----- (10060E40) --------------------------------------------------------
char sub_10060E40()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"3025", 2, 2);
      v3 = dword_1011F5E8[v2];
      v4 = dword_1011F5E4[v2];
      v5 = dword_1011F5E0[v2];
      v6 = sub_10054B60(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_1011F5EC[v2]],
             (&off_1011F5F0)[v2 * 4]);
      v7 = sub_10056480(1, dword_1011F5EC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_1011F5EC[v2]],
             (&off_1011F5F0)[v2 * 4]);
      result = sub_10054EC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3025",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011F5E0: using guessed type int dword_1011F5E0[];
// 1011F5E4: using guessed type int dword_1011F5E4[];
// 1011F5E8: using guessed type int dword_1011F5E8[];
// 1011F5EC: using guessed type int dword_1011F5EC[];
// 1011F5F0: using guessed type char *off_1011F5F0;
// 10291919: using guessed type char byte_10291919;

//----- (10060FA0) --------------------------------------------------------
char sub_10060FA0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"3051", 2, 2);
      HIDWORD(v3) = dword_1011FD8C[v2];
      LODWORD(v3) = dword_1011FD88[v2];
      HIDWORD(v4) = dword_1011FD84[v2];
      LODWORD(v4) = dword_1011FD80[v2];
      HIDWORD(v5) = dword_1011FD7C[v2];
      LODWORD(v5) = dword_1011FD78[v2];
      v6 = sub_10054B60(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_1011FD90[v2]],
             *(_DWORD *)&off_1011FD94[v2 * 4]);
      v7 = sub_10056840(1, dword_1011FD90[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_1011FD90[v2]],
             *(_DWORD *)&off_1011FD94[v2 * 4]);
      result = sub_10054EC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3051",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011FD78: using guessed type int dword_1011FD78[];
// 1011FD7C: using guessed type int dword_1011FD7C[];
// 1011FD80: using guessed type int dword_1011FD80[];
// 1011FD84: using guessed type int dword_1011FD84[];
// 1011FD88: using guessed type int dword_1011FD88[];
// 1011FD8C: using guessed type int dword_1011FD8C[];
// 1011FD90: using guessed type int dword_1011FD90[];
// 10291919: using guessed type char byte_10291919;

//----- (10061110) --------------------------------------------------------
char sub_10061110()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"3077", 2, 2);
      v3 = byte_1012099A[v2 * 4];
      v4 = byte_10120999[v2 * 4];
      v5 = byte_10120998[v2 * 4];
      v6 = sub_10054B60(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_1012099C[v2]],
             (&off_101209A0)[v2 * 4]);
      v7 = sub_10056D80(1, dword_1012099C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_1012099C[v2]],
             (&off_101209A0)[v2 * 4]);
      result = sub_10054EC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3077",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1012099C: using guessed type int dword_1012099C[];
// 101209A0: using guessed type char *off_101209A0;
// 10291919: using guessed type char byte_10291919;

//----- (10061270) --------------------------------------------------------
char sub_10061270()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"3103", 2, 2);
      v3 = dword_10120E30[v2];
      v4 = dword_10120E2C[v2];
      v5 = dword_10120E28[v2];
      v6 = sub_10054B60(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_10120E34[v2]],
             *(_DWORD *)&off_10120E38[v2 * 4]);
      v7 = sub_10057160(1, dword_10120E34[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_10120E34[v2]],
             *(_DWORD *)&off_10120E38[v2 * 4]);
      result = sub_10054EC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3103",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10120E28: using guessed type int dword_10120E28[];
// 10120E2C: using guessed type int dword_10120E2C[];
// 10120E30: using guessed type int dword_10120E30[];
// 10120E34: using guessed type int dword_10120E34[];
// 10291919: using guessed type char byte_10291919;

//----- (100613D0) --------------------------------------------------------
char sub_100613D0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10059BE0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_10054A50(0);
  sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3127", (int)v0);
  sub_10059BE0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10291919 )
  {
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"3135", 2, 2);
    v2 = sub_10059590(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3136",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"\" ) data comparison",
           &byte_100930C0,
           &byte_100930C0,
           0);
    sub_10054EC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3137",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"3139", 2, 2);
    v3 = sub_10059590(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3140",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_10054EC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3141",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"3143", 2, 2);
    v4 = sub_10059590(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3144",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           &byte_100930C0,
           0);
    sub_10054EC0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3145",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"3147", 2, 2);
    v5 = sub_10059590(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3148",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_10054EC0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3149",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3131",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10291919: using guessed type char byte_10291919;

//----- (100615D0) --------------------------------------------------------
char sub_100615D0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"3176", 2, 2);
      v3 = dword_101215C8[v2];
      v4 = dword_101215C4[v2];
      v5 = dword_101215C0[v2];
      v6 = sub_10054B60(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_101215CC[v2]],
             (&off_101215D0)[v2 * 4]);
      v7 = sub_10057520(1, dword_101215CC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_101215CC[v2]],
             (&off_101215D0)[v2 * 4]);
      result = sub_10054EC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3176",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101215C0: using guessed type int dword_101215C0[];
// 101215C4: using guessed type int dword_101215C4[];
// 101215C8: using guessed type int dword_101215C8[];
// 101215CC: using guessed type int dword_101215CC[];
// 101215D0: using guessed type char *off_101215D0;
// 10291919: using guessed type char byte_10291919;

//----- (10061730) --------------------------------------------------------
char sub_10061730()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"3202", 2, 2);
      v3 = word_10121934[v2 / 2];
      v4 = word_10121932[v2 / 2];
      v5 = word_10121930[v2 / 2];
      v6 = sub_10054B60(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_10121938[v2 / 4]],
             *(_DWORD *)&off_1012193C[v2]);
      v7 = sub_100578C0(
             1,
             dword_10121938[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"3202",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_10121938[v2 / 4]],
             *(_DWORD *)&off_1012193C[v2]);
      result = sub_10054EC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3202",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10121930: using guessed type __int16 word_10121930[];
// 10121932: using guessed type __int16 word_10121932[];
// 10121934: using guessed type __int16 word_10121934[];
// 10121938: using guessed type int dword_10121938[];
// 10291919: using guessed type char byte_10291919;

//----- (10061890) --------------------------------------------------------
char sub_10061890()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"3228", 2, 2);
      v3 = dword_10121BF8[v2];
      v4 = dword_10121BF4[v2];
      v5 = dword_10121BF0[v2];
      v6 = sub_10054B60(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_10121BFC[v2]],
             (&off_10121C00)[v2 * 4]);
      v7 = sub_10057CC0(1, dword_10121BFC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_10121BFC[v2]],
             (&off_10121C00)[v2 * 4]);
      result = sub_10054EC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3228",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10121BF0: using guessed type int dword_10121BF0[];
// 10121BF4: using guessed type int dword_10121BF4[];
// 10121BF8: using guessed type int dword_10121BF8[];
// 10121BFC: using guessed type int dword_10121BFC[];
// 10121C00: using guessed type char *off_10121C00;
// 10291919: using guessed type char byte_10291919;

//----- (100619F0) --------------------------------------------------------
char sub_100619F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"3254", 2, 2);
      HIDWORD(v3) = dword_10121F74[v2];
      LODWORD(v3) = dword_10121F70[v2];
      HIDWORD(v4) = dword_10121F6C[v2];
      LODWORD(v4) = dword_10121F68[v2];
      HIDWORD(v5) = dword_10121F64[v2];
      LODWORD(v5) = dword_10121F60[v2];
      v6 = sub_10054B60(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_10121F78[v2]],
             *(_DWORD *)&off_10121F7C[v2 * 4]);
      v7 = sub_10058060(1, dword_10121F78[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_10121F78[v2]],
             *(_DWORD *)&off_10121F7C[v2 * 4]);
      result = sub_10054EC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3254",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10121F60: using guessed type int dword_10121F60[];
// 10121F64: using guessed type int dword_10121F64[];
// 10121F68: using guessed type int dword_10121F68[];
// 10121F6C: using guessed type int dword_10121F6C[];
// 10121F70: using guessed type int dword_10121F70[];
// 10121F74: using guessed type int dword_10121F74[];
// 10121F78: using guessed type int dword_10121F78[];
// 10291919: using guessed type char byte_10291919;

//----- (10061B60) --------------------------------------------------------
char sub_10061B60()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"3280", 2, 2);
      v3 = byte_101224E2[v2 * 4];
      v4 = byte_101224E1[v2 * 4];
      v5 = byte_101224E0[v2 * 4];
      v6 = sub_10054B60(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_101224E4[v2]],
             (&off_101224E8)[v2 * 4]);
      v7 = sub_10058640(1, dword_101224E4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_101224E4[v2]],
             (&off_101224E8)[v2 * 4]);
      result = sub_10054EC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3280",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101224E4: using guessed type int dword_101224E4[];
// 101224E8: using guessed type char *off_101224E8;
// 10291919: using guessed type char byte_10291919;

//----- (10061CC0) --------------------------------------------------------
char sub_10061CC0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10291919 )
  {
    sub_10059BE0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_10054A50(0);
    sub_10059BE0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v1);
    sub_10059BE0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_10054B40(0);
    v2 = 0;
    do
    {
      sub_10054A70((int)"..\\lib\\utf\\utf_validate.c", (int)"3306", 2, 2);
      v3 = dword_101226F8[v2];
      v4 = dword_101226F4[v2];
      v5 = dword_101226F0[v2];
      v6 = sub_10054B60(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1010C718[4 * dword_101226FC[v2]],
             (&off_10122700)[v2 * 4]);
      v7 = sub_10058A30(1, dword_101226FC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v6, v5, v4, v3, 0);
      v8 = sub_10054B60(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1010C718[4 * dword_101226FC[v2]],
             (&off_10122700)[v2 * 4]);
      result = sub_10054EC0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10059BE0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3306",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101226F0: using guessed type int dword_101226F0[];
// 101226F4: using guessed type int dword_101226F4[];
// 101226F8: using guessed type int dword_101226F8[];
// 101226FC: using guessed type int dword_101226FC[];
// 10122700: using guessed type char *off_10122700;
// 10291919: using guessed type char byte_10291919;

//----- (10061E20) --------------------------------------------------------
char **sub_10061E20()
{
  return off_1010DE04;
}
// 1010DE04: using guessed type char *off_1010DE04[3];

//----- (10061E40) --------------------------------------------------------
bool sub_10061E40()
{
  return sub_1007C0F0(99) == 0;
}

//----- (10061E50) --------------------------------------------------------
bool sub_10061E50()
{
  return sub_1007C110(99, 10000) == 0;
}

//----- (10061E70) --------------------------------------------------------
char __cdecl sub_10061E70(__int16 a1, void *a2)
{
  size_t v2; // eax@2
  char result; // al@6
  __int16 v4; // [sp+0h] [bp-Ch]@1
  char v5; // [sp+4h] [bp-8h]@5

  v4 = a1;
  switch ( a1 )
  {
    case 0x8003:
    case 0x8004:
      v2 = 8;
      goto LABEL_5;
    case 0x8006:
      v2 = 4;
      goto LABEL_5;
    case 0x8001:
    case 0x8007:
      v2 = 1;
LABEL_5:
      memcpy_0(&v5, a2, v2);
      goto LABEL_6;
    case 0x8005:
    case 0x8008:
    case 0x8009:
LABEL_6:
      result = sub_1007C170(40, (int)&v4, 200, 1);
      break;
    default:
      result = sub_10042930("..\\lib\\adl\\nav_intf_send.c", 162, 0, 0);
      break;
  }
  return result;
}

//----- (10061F10) --------------------------------------------------------
signed int __fastcall sub_10061F10(unsigned __int8 a1)
{
  signed int result; // eax@1

  result = 176;
  if ( a1 < 0xB0u )
    result = a1;
  return result;
}

//----- (10061F20) --------------------------------------------------------
char __cdecl sub_10061F20(unsigned __int8 a1)
{
  return byte_10126744[6 * sub_10061F10(a1)];
}

//----- (10061F40) --------------------------------------------------------
__int16 __cdecl sub_10061F40(unsigned __int8 a1)
{
  return word_10126740[3 * sub_10061F10(a1)];
}
// 10126740: using guessed type __int16 word_10126740[];

//----- (10061F60) --------------------------------------------------------
__int16 __cdecl sub_10061F60(unsigned __int8 a1)
{
  return word_10126742[3 * sub_10061F10(a1)];
}
// 10126742: using guessed type __int16 word_10126742[];

//----- (10061F80) --------------------------------------------------------
int __cdecl sub_10061F80(int a1)
{
  double v1; // ST0C_8@2
  double v2; // st6@4
  double v3; // st7@4
  double v4; // ST0C_8@7
  double v5; // rt2@8
  double v6; // st6@8
  double v7; // st7@8
  double v8; // st7@14
  double v9; // st7@18
  int result; // eax@18

  if ( a1 )
  {
    v1 = *(double *)a1;
    if ( (HIDWORD(v1) & 0x7FF00000) == 2146435072 || *(double *)a1 > 6.2831853071796 )
    {
      *(double *)a1 = 6.2831853071796;
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
    }
    else
    {
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
      if ( *(double *)a1 < -6.2831853071796 )
        *(double *)a1 = -6.2831853071796;
    }
    v4 = *(double *)(a1 + 8);
    if ( (HIDWORD(v4) & 0x7FF00000) == 2146435072 )
    {
      *(double *)(a1 + 8) = v3;
    }
    else
    {
      v5 = v2;
      v6 = v3;
      v7 = v5;
      if ( v6 < *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v6;
      }
      else if ( v7 > *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v7;
      }
    }
    if ( *(double *)a1 <= 1.5707963267949 )
    {
      if ( *(double *)a1 >= -1.5707963267949 )
      {
LABEL_18:
        v9 = *(double *)(a1 + 8);
        result = sub_1007BC90(v9);
        *(double *)(a1 + 8) = v9;
        return result;
      }
      *(double *)a1 = -3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    else
    {
      *(double *)a1 = 3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    *(double *)(a1 + 8) = v8;
    goto LABEL_18;
  }
  return result;
}

//----- (10062080) --------------------------------------------------------
signed int __cdecl sub_10062080(int a1, int a2)
{
  signed int result; // eax@2

  if ( a1 )
  {
    if ( (COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
      || (COERCE_UNSIGNED_INT(*(float *)(a1 + 4)) & 0x7F800000) == 2139095040
      || *(float *)a1 >= 1.570796370506287
      || *(float *)a1 < -1.570796370506287
      || *(float *)(a1 + 4) >= 3.141592741012573
      || *(float *)(a1 + 4) < -3.141592741012573 )
    {
      if ( a2 )
      {
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
      }
      result = 0;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10062120) --------------------------------------------------------
char __cdecl sub_10062120(int a1, float *a2)
{
  char v2; // bl@1
  char result; // al@8

  v2 = 1;
  if ( *(float *)(a1 + 4) > (double)*a2 )
  {
    if ( *(_BYTE *)(a1 + 19) )
    {
      if ( *(_BYTE *)(a1 + 19) == 1 )
        *a2 = *(float *)(a1 + 4);
    }
    else
    {
      v2 = 0;
    }
  }
  if ( *(float *)a1 >= (double)*a2 )
  {
    result = v2;
  }
  else if ( *(_BYTE *)(a1 + 20) )
  {
    result = v2;
    if ( *(_BYTE *)(a1 + 20) == 1 )
      *a2 = *(float *)a1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10062180) --------------------------------------------------------
char __usercall sub_10062180@<al>(unsigned __int16 a1@<ax>, int a2@<esi>, float a3, char a4, char a5)
{
  unsigned __int8 v5; // cl@1
  char v6; // dl@2
  char v7; // bl@4
  double v8; // st7@6
  int v9; // edi@6
  int v10; // ecx@6
  bool v11; // zf@10
  unsigned int v12; // eax@18
  char v14; // [sp+3h] [bp-5h]@1
  char v15; // [sp+4h] [bp-4h]@2
  char v16; // [sp+10h] [bp+8h]@10
  char v17; // [sp+14h] [bp+Ch]@10

  v5 = *(_BYTE *)(a2 + 10 * a1 + 22535);
  v14 = 10;
  if ( (unsigned __int8)a4 >= 9u )
  {
    v15 = 9;
    v6 = 9;
  }
  else
  {
    v6 = a4;
    v15 = a4;
  }
  v7 = a5;
  if ( (unsigned __int8)a5 >= 9u )
    v7 = 9;
  v8 = a3;
  v9 = v5;
  v10 = 10 * v5;
  if ( *(float *)(a2 + 4 * (v10 + (unsigned __int8)v6) + 53416) >= (double)a3 )
  {
    if ( *(float *)(a2 + 4 * (v10 + (unsigned __int8)v7) + 53416) <= v8 )
    {
      v11 = v7 == v6;
      v16 = 1;
      v17 = 0;
      if ( (unsigned __int8)v7 > (unsigned __int8)v6 )
      {
        v16 = -1;
        v17 = -1;
        v11 = v7 == v6;
      }
      if ( !v11 )
      {
        while ( *(float *)(a2 + 4 * ((unsigned __int8)v7 + v10) + 53416) > v8
             || *(float *)(a2 + 4 * (v10 + (unsigned __int8)v7 + v16) + 53416) < v8 )
        {
          v7 += v16;
          if ( v7 == v15 )
            goto LABEL_18;
        }
        v14 = v7 + v17;
      }
    }
    else
    {
      v14 = v7;
    }
  }
  else
  {
    v14 = v6;
  }
LABEL_18:
  v12 = *(_BYTE *)(44 * v9 + a2 + 52576) - 2;
  if ( (unsigned __int8)v14 < v12 )
    LOBYTE(v12) = v14;
  return v12;
}

//----- (10062290) --------------------------------------------------------
double __usercall sub_10062290@<st0>(int a1@<eax>, _BYTE *a2@<ebx>, int a3, float a4)
{
  int v4; // esi@1
  unsigned __int8 v5; // al@1
  int v6; // edi@2
  unsigned __int8 v7; // al@2
  char v8; // al@6
  double v9; // st7@7
  double result; // st7@7
  char v11; // [sp+14h] [bp-8h]@4
  char v12; // [sp+18h] [bp-4h]@4
  float v13; // [sp+24h] [bp+8h]@7

  v4 = a1;
  v5 = *(_BYTE *)(a1 + 10 * (unsigned __int16)a3 + 22535);
  if ( v5 >= 0x14u )
  {
    *a2 = 1;
    result = a4;
  }
  else
  {
    v6 = v5;
    v7 = *(_BYTE *)(44 * v5 + v4 + 52576);
    if ( v7 <= 1u || v7 > 0xAu )
      goto LABEL_12;
    v11 = 0;
    v12 = v7 - 1;
    if ( *(float *)(v4 + 4 * (10 * v6 + (unsigned __int8)(v7 - 1)) + 53416) < (double)*(float *)(v4 + 40 * v6 + 53416) )
    {
      v11 = v7 - 1;
      v12 = 0;
    }
    v8 = sub_10062180(a3, v4, a4, v12, v11);
    if ( (unsigned __int8)v8 >= 9u )
    {
LABEL_12:
      *a2 = 1;
      result = a4;
    }
    else
    {
      v9 = *(float *)(v4 + 4 * ((unsigned __int8)v8 + 2 * (9 * v6 + 6777))) * a4
         + *(float *)(v4 + 4 * ((unsigned __int8)v8 + 18 * v6) + 54252);
      *a2 = 1;
      v13 = v9;
      result = v13;
    }
  }
  return result;
}

//----- (10062390) --------------------------------------------------------
unsigned __int8 __cdecl sub_10062390(int a1, int a2, char a3, void *a4)
{
  int v4; // esi@1
  int v5; // ecx@1
  unsigned __int8 result; // al@1
  int v7; // edi@1
  int v8; // esi@4
  char v9; // bl@7
  int v10; // edi@7
  char v11; // al@7
  int v12; // edx@7
  char v13; // al@8
  char v14; // dl@8
  unsigned __int8 v15; // [sp+16h] [bp-156h]@1
  char v16; // [sp+17h] [bp-155h]@7
  int v17; // [sp+18h] [bp-154h]@1
  int v18; // [sp+1Ch] [bp-150h]@1
  int v19; // [sp+20h] [bp-14Ch]@1
  char v20[12]; // [sp+24h] [bp-148h]@7
  float v21[78]; // [sp+30h] [bp-13Ch]@8

  *(float *)a4 = 9.8999998e24;
  v4 = a2;
  v5 = *(_WORD *)(a2 + 16);
  result = 0;
  v7 = a1;
  v17 = a1;
  v19 = a2;
  v15 = 0;
  v18 = v5;
  while ( v15 < *(_BYTE *)(v4 + 18) )
  {
    v5 = (unsigned __int16)v5;
    v8 = v7 + 10 * (unsigned __int16)v5 + 22534;
    switch ( *(_BYTE *)v8 )
    {
      case 1:
        result = sub_1003C0C0(
                   *(_BYTE *)(v7 + 10 * (unsigned __int16)v5 + 22538),
                   *(_WORD *)(v7 + 2 * (5 * v5 + 11270)),
                   *(_WORD *)(v7 + 10 * (unsigned __int16)v5 + 22542),
                   4,
                   a4);
        break;
      case 3:
        result = sub_100773A0(COERCE_FLOAT(*(_WORD *)(v7 + 10 * (unsigned __int16)v5 + 22538)), a4);
        break;
      case 4:
        v9 = *(_BYTE *)(v7 + 10 * (unsigned __int16)v5 + 22539);
        v10 = *(_BYTE *)(v7 + 10 * (unsigned __int16)v5 + 22539);
        v11 = sub_1007BAD0((unsigned int)*(_BYTE *)(v8 + 5) >> 3, 1);
        v12 = *(_BYTE *)(v8 + 4);
        v16 = v11;
        result = sub_1003C0C0(6, (unsigned __int16)word_101283AC[v12], 0, 324, v20);
        if ( result )
        {
          v13 = v16;
          v14 = v16;
          *(float *)a4 = v21[v10];
          result = ((unsigned __int8)v20[(unsigned __int8)v13] >> (v9 - 8 * v14)) & 1;
        }
        v7 = v17;
        break;
    }
    ++v15;
    v5 = v18++ + 1;
    if ( result )
    {
      v15 = result;
      goto LABEL_15;
    }
    v4 = v19;
  }
  v15 = result;
  if ( !result )
    return result;
LABEL_15:
  if ( a3 )
  {
    *(float *)a4 = sub_10062290(v7, &v15, v5 - 1, *(float *)a4);
    result = v15;
  }
  return result;
}
// 101283AC: using guessed type __int16 word_101283AC[];
// 10062390: using guessed type char var_148[12];
// 10062390: using guessed type float var_13C[78];

//----- (10062520) --------------------------------------------------------
char __cdecl sub_10062520(unsigned __int16 a1, void *a2)
{
  int v2; // esi@1
  int v3; // eax@1
  char result; // al@4

  *(float *)a2 = 9.8999998e24;
  v2 = sub_100625C0(a1);
  v3 = sub_1003C0E0();
  if ( v2 && v3 && *(_WORD *)(v2 + 12) == 6 )
  {
    result = sub_10062390(v3, v2, 1, a2);
    if ( result )
      result = sub_10062120(v2, (float *)a2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10062580) --------------------------------------------------------
int __usercall sub_10062580@<eax>(unsigned __int16 a1@<di>)
{
  int v1; // eax@1
  unsigned __int16 v2; // cx@3
  int result; // eax@4

  v1 = sub_1003C0E0();
  if ( v1 && a1 < 0xFE3u && (v2 = *(_WORD *)(v1 + 2 * a1 + 14400), v2 < 0x3840u) )
    result = v1 + 24 * v2;
  else
    result = 0;
  return result;
}

//----- (100625C0) --------------------------------------------------------
int __cdecl sub_100625C0(unsigned __int16 a1)
{
  int result; // eax@1
  int v2; // esi@1

  result = sub_10062580(a1);
  v2 = result;
  if ( !result )
  {
    sub_10042930("..\\lib\\acl\\dat\\dat_intf.c", 100, 0, 0);
    result = v2;
  }
  return result;
}

//----- (100625F0) --------------------------------------------------------
BOOL __cdecl sub_100625F0(unsigned __int16 a1)
{
  return sub_10062580(a1) != 0;
}

//----- (10062610) --------------------------------------------------------
char __cdecl sub_10062610(char a1, void *a2)
{
  int v2; // eax@2
  char result; // al@11
  char *v4; // eax@12
  signed int v5; // ecx@12

  switch ( a1 )
  {
    case 0:
      v2 = 247;
      break;
    case 2:
      v2 = 248;
      break;
    case 3:
      v2 = 1732;
      break;
    case 4:
      v2 = 1733;
      break;
    case 5:
      v2 = 2279;
      break;
    case 6:
      v2 = 2280;
      break;
    default:
      v2 = 246;
      break;
  }
  if ( !sub_100253C0(1, v2, a2) || sub_1004D320((int)a2) )
  {
    memset(a2, 0, 0xCCCu);
    v4 = (char *)a2 + 26;
    v5 = 14;
    do
    {
      *v4 = 15;
      v4 += 232;
      --v5;
    }
    while ( v5 );
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (100626C0) --------------------------------------------------------
char __cdecl sub_100626C0(char a1)
{
  bool v1; // zf@1
  char result; // al@1
  char v3; // [sp+4h] [bp-CD0h]@1
  char v4; // [sp+11h] [bp-CC3h]@1

  memset(&v3, 0, 0xCCCu);
  v1 = sub_10062610(a1, &v3) == 0;
  result = v4;
  if ( v1 )
    result = 3;
  return result;
}

//----- (10062720) --------------------------------------------------------
char __cdecl sub_10062720(char a1)
{
  char result; // al@3

  if ( a1 == 6 )
  {
    result = 0;
  }
  else if ( a1 == 7 )
  {
    result = 1;
  }
  else
  {
    sub_10042930("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 294, 0, 0);
    result = 2;
  }
  return result;
}

//----- (10062760) --------------------------------------------------------
char __cdecl sub_10062760(char a1)
{
  char result; // al@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 7;
    }
    else
    {
      sub_10042930("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 648, 0, 0);
      result = 67;
    }
  }
  else
  {
    result = 6;
  }
  return result;
}

//----- (100627A0) --------------------------------------------------------
signed int __cdecl sub_100627A0(char a1)
{
  signed int result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 512;
    }
    else
    {
      sub_10042930("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 699, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = 256;
  }
  return result;
}

//----- (100627E0) --------------------------------------------------------
char __cdecl sub_100627E0(char a1)
{
  char result; // al@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 6;
    }
    else
    {
      sub_10042930("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 750, 0, 0);
      result = -80;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10062820) --------------------------------------------------------
char __cdecl sub_10062820(int a1)
{
  char result; // al@3

  if ( a1 == 256 )
  {
    result = 0;
  }
  else if ( a1 == 512 )
  {
    result = 1;
  }
  else
  {
    sub_10042930("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 800, 0, 0);
    result = 2;
  }
  return result;
}

//----- (10062860) --------------------------------------------------------
char __cdecl sub_10062860(char a1)
{
  return sub_1004A060((int)&unk_1013D410, a1, 0x33u);
}

//----- (10062880) --------------------------------------------------------
char __cdecl sub_10062880(char a1)
{
  return sub_1004A060((int)&unk_1013D478, a1, 0x31u);
}

//----- (100628A0) --------------------------------------------------------
char __cdecl sub_100628A0(char a1)
{
  return sub_1004A060((int)&unk_1013D4DC, a1, 0x1Du);
}

//----- (100628C0) --------------------------------------------------------
char __cdecl sub_100628C0(char a1)
{
  char result; // al@2
  unsigned __int8 v2; // [sp+4h] [bp-4h]@1

  v2 = sub_10062860(a1);
  if ( v2 == -80 )
    result = 67;
  else
    result = sub_10061F20(v2);
  return result;
}

//----- (100628F0) --------------------------------------------------------
char __cdecl sub_100628F0(char a1)
{
  char result; // al@2
  unsigned __int8 v2; // [sp+4h] [bp-4h]@1

  v2 = sub_10062880(a1);
  if ( v2 == -80 )
    result = 67;
  else
    result = sub_10061F20(v2);
  return result;
}

//----- (10062920) --------------------------------------------------------
char __cdecl sub_10062920(char a1)
{
  char result; // al@2
  unsigned __int8 v2; // [sp+4h] [bp-4h]@1

  v2 = sub_100628A0(a1);
  if ( v2 == -80 )
  {
    result = 57;
    if ( a1 != 4 )
      result = 67;
  }
  else
  {
    result = sub_10061F20(v2);
  }
  return result;
}

//----- (10062960) --------------------------------------------------------
bool __cdecl sub_10062960(unsigned __int8 a1, char a2, unsigned int a3)
{
  int v3; // eax@1
  bool result; // al@5

  v3 = sub_10043FF0(&a2, 4u, (int)&dword_1013E3A8, 12, 3, 3);
  if ( a3 < 0xFFFFFFC2 && a3 && v3 < 3 && a1 < 2u )
  {
    result = sub_1007C3B0((unsigned __int16)word_1013E3AC[a1 + 6 * v3], a3, (unsigned __int16)word_1013E3B0[6 * v3]) == 0;
  }
  else
  {
    sub_10042930("..\\lib\\acl\\iop\\gtx\\iop_gtx_intf.c", 254, 0, 0);
    result = 0;
  }
  return result;
}
// 1013E3A8: using guessed type int dword_1013E3A8;
// 1013E3AC: using guessed type __int16 word_1013E3AC[];
// 1013E3B0: using guessed type __int16 word_1013E3B0[];

//----- (100629F0) --------------------------------------------------------
bool __cdecl sub_100629F0(char a1, char a2, void *a3)
{
  int v3; // eax@1
  int v4; // esi@3
  void *v5; // edi@3
  int (__cdecl *v6)(void *, _DWORD); // esi@4
  bool result; // al@6

  v3 = sub_10043FF0(&a1, 1u, (int)&unk_1013E3E4, 8, 2, 2);
  if ( v3 >= 2 || (unsigned __int8)a2 >= 3u )
  {
    result = 0;
  }
  else
  {
    v4 = (unsigned __int8)a2;
    v5 = a3;
    result = 0;
    if ( sub_100253C0(0, (unsigned __int16)word_1013E3E6[(unsigned __int8)a2 + 4 * v3], a3) )
    {
      v6 = (int (__cdecl *)(void *, _DWORD))dword_1013E3F4[v4];
      if ( !v6 || !v6(v5, 0) )
        result = 1;
    }
  }
  return result;
}
// 1013E3E6: using guessed type __int16 word_1013E3E6[];
// 1013E3F4: using guessed type int dword_1013E3F4[];

//----- (10062A70) --------------------------------------------------------
char __usercall sub_10062A70@<al>(void *a1@<eax>, int a2)
{
  sub_10024E60(0, 417, a1, 0, 20, 1);
  return sub_10025010(0, 417, a2);
}

//----- (10062AA0) --------------------------------------------------------
bool __cdecl sub_10062AA0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6)
{
  int v6; // eax@1
  int v7; // eax@7
  unsigned int v8; // edx@7
  int v9; // eax@7
  bool result; // al@9
  unsigned __int8 v11; // [sp+4h] [bp-4h]@1

  v11 = sub_100528A0(a1);
  v6 = sub_10043FF0(&a3, 1u, (int)&unk_1013E3CC, 8, 3, 3);
  if ( v6 < 3 )
    v6 = sub_10043FF0(&dword_1013E3D0[2 * v6], 4u, (int)&dword_1013E3A8, 12, 3, 3);
  if ( a5 < 0xFFFFFFC2
    && a5
    && v6 < 3
    && v11 < 2u
    && (v7 = 6 * v6, v8 = (unsigned __int16)word_1013E3B0[v7], v9 = 2 * v7, a6 >= v8)
    && a2 == 1 )
  {
    result = sub_10062960(v11, *(int *)((char *)&dword_1013E3A8 + v9), a5);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1013E3A8: using guessed type int dword_1013E3A8;
// 1013E3B0: using guessed type __int16 word_1013E3B0[];

//----- (10062B40) --------------------------------------------------------
char __cdecl sub_10062B40(int a1, char a2, void *a3)
{
  void *v3; // esi@1
  int v4; // eax@1
  __int16 v5; // cx@3
  void *v6; // ecx@7
  signed int v7; // esi@9
  int v9; // [sp+4h] [bp-18h]@5
  int v10; // [sp+8h] [bp-14h]@5
  int v11; // [sp+Ch] [bp-10h]@5
  int v12; // [sp+10h] [bp-Ch]@5
  int v13; // [sp+14h] [bp-8h]@5

  v3 = a3;
  v4 = sub_10043FF0(&a2, 1u, (int)&unk_1013E400, 4, 9, -1);
  if ( v4 >= 0 && (unsigned __int8)a1 <= 2u )
  {
    v5 = word_1013E402[2 * v4];
    if ( !v5 || v3 )
    {
      v9 = 0;
      v10 = 0;
      v11 = 0;
      v12 = 0;
      v13 = 0;
      BYTE1(v9) = 45;
      BYTE2(v9) = a2;
      LOBYTE(v9) = a1;
      LOWORD(v10) = v5;
      if ( v5 )
        memcpy(&v11, v3, (unsigned __int16)v5);
      sub_10062A70(&v9, 0xFFFFFFF);
      LOBYTE(v4) = sub_100460C0(v6);
      if ( (_BYTE)v4 == 4 )
      {
        if ( (unsigned __int8)a1 < 2u )
        {
          LOBYTE(v4) = sub_1003C4B0(a1, (int)&v9);
        }
        else
        {
          v7 = 0;
          do
          {
            LOBYTE(v4) = sub_1003C330(v7);
            if ( (_BYTE)v4 )
              LOBYTE(v4) = sub_1003C4B0(v7, (int)&v9);
            ++v7;
          }
          while ( v7 < 2 );
        }
      }
    }
  }
  return v4;
}
// 1013E402: using guessed type __int16 word_1013E402[];

//----- (10062C60) --------------------------------------------------------
int __cdecl sub_10062C60(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 0, 0, 0);
}

//----- (10062C80) --------------------------------------------------------
unsigned int __cdecl sub_10062C80(void *a1)
{
  return sub_100546C0(a1, 0x20u, 0);
}

//----- (10062CA0) --------------------------------------------------------
unsigned int __cdecl sub_10062CA0(void *a1)
{
  return sub_100546C0(a1, 0x1Cu, 0);
}

//----- (10062CC0) --------------------------------------------------------
unsigned int __cdecl sub_10062CC0(void *a1)
{
  return sub_100546C0(a1, 0x10u, 0);
}

//----- (10062CE0) --------------------------------------------------------
unsigned int __cdecl sub_10062CE0(void *a1)
{
  return sub_100546C0(a1, 0xCu, 0);
}

//----- (10062D00) --------------------------------------------------------
unsigned int __cdecl sub_10062D00(void *a1)
{
  return sub_100546C0(a1, 8u, 0);
}

//----- (10062D20) --------------------------------------------------------
int __cdecl sub_10062D20(int a1)
{
  int result; // eax@1

  result = sub_10054720((unsigned __int8 *)(a1 + 1), 1u, 0x1Fu, 1u, 0);
  if ( !result )
  {
    result = sub_10054720((unsigned __int8 *)a1, 1u, 0xCu, 1u, 0);
    if ( !result )
      result = sub_10054770((_BYTE *)(a1 + 2), 0x7C6u, 0xFFFFu, 1990, 0);
  }
  return result;
}

//----- (10062D70) --------------------------------------------------------
signed int __cdecl sub_10062D70(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10054600(a1, 2147483648, 0x7FFFFFFF, 0x7FFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10062DA0) --------------------------------------------------------
int __cdecl sub_10062DA0(void *a1)
{
  int result; // eax@1

  result = sub_10062C80((char *)a1 + 64);
  if ( !result )
  {
    result = sub_10062C80((char *)a1 + 128);
    if ( !result )
    {
      result = sub_10062D00((char *)a1 + 120);
      if ( !result )
      {
        result = sub_10062CA0((char *)a1 + 36);
        if ( !result )
        {
          result = sub_10062D20((int)a1 + 168);
          if ( !result )
          {
            result = sub_10062D20((int)a1 + 160);
            if ( !result )
            {
              result = sub_10062D20((int)a1 + 164);
              if ( !result )
              {
                result = sub_10062CC0(a1);
                if ( !result )
                {
                  result = sub_10062CE0((char *)a1 + 96);
                  if ( !result )
                  {
                    result = sub_10062CE0((char *)a1 + 24);
                    if ( !result )
                      result = sub_10062D00((char *)a1 + 16);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (10062E70) --------------------------------------------------------
unsigned int __cdecl sub_10062E70(void *a1)
{
  unsigned int result; // eax@1

  result = sub_10062C80((char *)a1 + 64);
  if ( !result )
  {
    result = sub_10062CA0((char *)a1 + 36);
    if ( !result )
    {
      result = sub_10062CC0(a1);
      if ( !result )
      {
        result = sub_10062CE0((char *)a1 + 96);
        if ( !result )
        {
          result = sub_10062CE0((char *)a1 + 24);
          if ( !result )
            result = sub_10062D00((char *)a1 + 16);
        }
      }
    }
  }
  return result;
}

//----- (10062ED0) --------------------------------------------------------
char __cdecl sub_10062ED0(unsigned __int16 a1, _BYTE *a2, _WORD *a3)
{
  char result; // al@4

  if ( a1 < 0x1D8u && a2 && a3 )
  {
    *a2 = byte_1013E448[4 * a1];
    *a3 = word_1013E44A[2 * a1];
    result = 1;
  }
  else
  {
    sub_10042930("..\\lib\\adl\\iop_eau_data_tbl.c", 614, 0, 0);
    result = 0;
  }
  return result;
}
// 1013E44A: using guessed type __int16 word_1013E44A[];

//----- (10062F30) --------------------------------------------------------
char __cdecl sub_10062F30(char a1, __int16 a2, unsigned __int16 *a3)
{
  char result; // al@1
  int v4; // ecx@3
  unsigned __int16 v5; // si@5

  result = 0;
  if ( a3 )
  {
    *a3 = 0;
    while ( 1 )
    {
      v4 = 2 * *a3;
      if ( word_1013E44A[v4] == a2 && byte_1013E448[v4 * 2] == a1 )
        break;
      v5 = *a3 + 1;
      *a3 = v5;
      if ( v5 >= 0x1D8u )
        return result;
    }
    result = 1;
  }
  return result;
}
// 1013E44A: using guessed type __int16 word_1013E44A[];

//----- (10062F90) --------------------------------------------------------
int __cdecl sub_10062F90(char a1)
{
  return sub_10043FF0(&a1, 1u, (int)byte_1013EBC8, 8, 2, 2);
}

//----- (10062FB0) --------------------------------------------------------
char __cdecl sub_10062FB0(unsigned __int8 a1)
{
  char result; // al@1

  result = 67;
  if ( a1 < 2u )
    result = byte_1013EBC8[8 * a1];
  return result;
}

//----- (10062FD0) --------------------------------------------------------
BOOL __cdecl sub_10062FD0(int a1, void *a2)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-18h]@2
  int v5; // [sp+18h] [bp-4h]@3

  v2 = sub_1003DB80(a1);
  return sub_100253C0(0, 604, a2) && sub_10024D10(0, 0x25Cu, (int)&v4) && (v2 & v5) == v2;
}

//----- (10063030) --------------------------------------------------------
int __usercall sub_10063030@<eax>(char a1@<al>)
{
  unsigned __int8 v1; // al@1
  int result; // eax@2

  v1 = sub_10062F90(a1);
  if ( v1 >= 2u )
    result = 42066;
  else
    result = dword_1013EBCC[2 * v1];
  return result;
}
// 1013EBCC: using guessed type int dword_1013EBCC[];

//----- (10063060) --------------------------------------------------------
BOOL __cdecl sub_10063060(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10063030(a1);
  return sub_1007C3B0(v2, a2, 16) == 0;
}

//----- (10063090) --------------------------------------------------------
int __cdecl sub_10063090(int a1, char a2, int a3, int a4, void *a5)
{
  int result; // eax@2

  if ( a2 )
    result = sub_10063060(a1, (int)a5);
  else
    result = sub_10062FD0(a1, a5);
  return result;
}

//----- (100630C0) --------------------------------------------------------
char __cdecl sub_100630C0(char a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@3
  char v4; // dl@3

  memset(byte_10291C70, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10042930("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 215, 0, 0);
  }
  else
  {
    sub_100465B0(a1, (int)byte_10291C70);
    v3 = 4 * a2 - 64;
    v4 = byte_10291C71[v3];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_10291C70[v3];
    if ( (unsigned __int8)v4 < 0x23u
      || (unsigned __int8)v4 >= 0x64u && (unsigned __int8)v4 <= 0x81u
      || (unsigned __int8)v4 >= 0x96u && (unsigned __int8)v4 <= 0x9Bu )
    {
      return 1;
    }
  }
  return 0;
}

//----- (10063160) --------------------------------------------------------
bool __cdecl sub_10063160(char a1, unsigned __int8 a2, int a3)
{
  char *v3; // eax@3
  bool result; // al@3

  memset(byte_10291C70, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10042930("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 340, 0, 0);
    result = 0;
  }
  else
  {
    sub_100465B0(a1, (int)byte_10291C70);
    v3 = (char *)&unk_10291D10 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v3;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v3 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v3 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v3 + 3);
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  return result;
}

//----- (100631E0) --------------------------------------------------------
char __cdecl sub_100631E0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_10291C70, 0, 0x890u);
  sub_100465B0(a1, (int)byte_10291C70);
  if ( a2 > 0x10u )
  {
    sub_10042930("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 512, 0, 0);
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = dword_10291FE0[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_10291FE4[2 * a2];
    result = 1;
  }
  return result;
}
// 10291FE0: using guessed type int dword_10291FE0[];
// 10291FE4: using guessed type int dword_10291FE4[];

//----- (10063250) --------------------------------------------------------
char __cdecl sub_10063250(char a1, void *a2)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = sub_100253C0(0, 227, a2);
    }
    else if ( a1 == 2 )
    {
      result = sub_100253C0(0, 572, a2);
    }
    else
    {
      sub_10042930("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 991, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_100253C0(0, 226, a2);
  }
  return result;
}

//----- (100632D0) --------------------------------------------------------
char __cdecl sub_100632D0(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  int v4; // ecx@3

  memset(byte_10291C70, 0, 0x890u);
  if ( a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10042930("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 153, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10063250(a1, byte_10291C70);
    v4 = 4 * a2 - 64;
    *(_BYTE *)(a3 + 1) = byte_10291C71[v4];
    *(_BYTE *)a3 = byte_10291C70[v4];
  }
  return result;
}

//----- (10063350) --------------------------------------------------------
char __cdecl sub_10063350(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  char *v4; // ecx@3

  memset(byte_10291C70, 0, 0x890u);
  if ( a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10042930("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 280, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10063250(a1, byte_10291C70);
    v4 = (char *)&unk_10291D10 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v4;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v4 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v4 + 3);
  }
  return result;
}

//----- (100633D0) --------------------------------------------------------
char __cdecl sub_100633D0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_10291C70, 0, 0x890u);
  if ( a2 <= 0x10u )
  {
    result = sub_10063250(a1, byte_10291C70);
    *(_DWORD *)a3 = dword_10291FE0[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_10291FE4[2 * a2];
  }
  else
  {
    sub_10042930("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 445, 0, 0);
    result = 0;
  }
  return result;
}
// 10291FE0: using guessed type int dword_10291FE0[];
// 10291FE4: using guessed type int dword_10291FE4[];

//----- (10063440) --------------------------------------------------------
char __cdecl sub_10063440(char a1, char a2, char a3, unsigned __int8 *a4, int a5)
{
  char result; // al@6
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1006A3C0(a1);
  if ( v6 == 3 )
    return 0;
  if ( a3 == 1 )
  {
    if ( a2 )
      result = sub_100631E0(v6, *a4, a5);
    else
      result = sub_100633D0(v6, *a4, a5);
  }
  else if ( a3 == 2 )
  {
    if ( a2 )
      result = sub_100630C0(v6, *a4, a5);
    else
      result = sub_100632D0(v6, *a4, a5);
  }
  else
  {
    if ( a3 != 3 )
    {
      sub_10042930("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 915, 0, 0);
      return 0;
    }
    if ( a2 )
      result = sub_10063160(v6, *a4, a5);
    else
      result = sub_10063350(v6, *a4, a5);
  }
  return result;
}

//----- (10063550) --------------------------------------------------------
char __cdecl sub_10063550(char a1, void *a2)
{
  return sub_100253C0(6, (unsigned __int16)word_1013F6DA[8 * (unsigned __int8)a1], a2);
}
// 1013F6DA: using guessed type __int16 word_1013F6DA[];

//----- (10063570) --------------------------------------------------------
bool __cdecl sub_10063570(unsigned __int8 a1, char *a2)
{
  int v2; // eax@1
  char v4; // [sp+8h] [bp-30h]@1

  v2 = sub_1007C3B0(dword_1013F6E0[4 * a1], (int)&v4, 48);
  qmemcpy(a2, &v4, 0x2Cu);
  return v2 == 0;
}
// 1013F6E0: using guessed type int dword_1013F6E0[];

//----- (100635B0) --------------------------------------------------------
char __cdecl sub_100635B0(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10077C50(a1);
  if ( a2 )
    result = sub_10063570(v6, (char *)a5);
  else
    result = sub_10063550(v6, a5);
  return result;
}

//----- (100635F0) --------------------------------------------------------
char __cdecl sub_100635F0(int a1, int a2)
{
  int v2; // ecx@3
  int v3; // edx@3
  int v4; // ecx@3
  char result; // al@3
  int v6; // [sp+4h] [bp-1Ch]@1
  int v7; // [sp+8h] [bp-18h]@1
  int v8; // [sp+Ch] [bp-14h]@1
  int v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+14h] [bp-Ch]@1
  __int16 v11; // [sp+18h] [bp-8h]@1
  char v12; // [sp+1Ah] [bp-6h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if ( !sub_100253C0(2, 284, &v6) || sub_1004D080((int)&v6) )
  {
    result = 0;
  }
  else
  {
    v2 = v8;
    *(_DWORD *)a2 = v7;
    v3 = v9;
    *(_DWORD *)(a2 + 4) = v2;
    v4 = v10;
    *(_DWORD *)(a2 + 8) = v3;
    LOWORD(v3) = v11;
    *(_DWORD *)(a2 + 12) = v4;
    LOBYTE(v4) = v12;
    *(_WORD *)(a2 + 16) = v3;
    *(_BYTE *)(a2 + 18) = v4;
    result = 1;
  }
  return result;
}

//----- (100636A0) --------------------------------------------------------
BOOL __cdecl sub_100636A0(int a1, int a2)
{
  return sub_1007C3B0(6169, a2, 40) == 0;
}

//----- (100636C0) --------------------------------------------------------
char __cdecl sub_100636C0(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_100636A0(a1, a5);
  }
  else
  {
    result = sub_100635F0(a1, a5);
  }
  return result;
}

//----- (10063700) --------------------------------------------------------
char __cdecl sub_10063700(void *a1)
{
  *(_DWORD *)a1 = 0;
  return sub_100253C0(2, 363, a1);
}

//----- (10063720) --------------------------------------------------------
char __cdecl sub_10063720(void *a1)
{
  int v1; // edx@2
  int v2; // eax@2
  int v3; // ecx@2
  int v4; // eax@2
  int v5; // ecx@2
  void *v6; // esi@2
  signed int v7; // edi@2
  char *v8; // eax@4
  signed int v9; // edx@4
  char result; // al@6
  char v11; // [sp+8h] [bp-208h]@1
  int v12; // [sp+47h] [bp-1C9h]@2
  int v13; // [sp+4Bh] [bp-1C5h]@2
  int v14; // [sp+4Fh] [bp-1C1h]@2
  int v15; // [sp+53h] [bp-1BDh]@2
  int v16; // [sp+58h] [bp-1B8h]@2
  int v17; // [sp+5Ch] [bp-1B4h]@2
  __int16 v18; // [sp+60h] [bp-1B0h]@2
  char v19; // [sp+62h] [bp-1AEh]@2
  char v20; // [sp+B6h] [bp-15Ah]@2
  char v21; // [sp+F6h] [bp-11Ah]@2

  *(_DWORD *)a1 = 0;
  if ( sub_1007C3B0(6444, (int)&v11, 514) )
  {
    result = 0;
  }
  else
  {
    v1 = v13;
    v2 = v14;
    *((_DWORD *)a1 + 3330) = v12;
    v3 = v15;
    *((_DWORD *)a1 + 3331) = v1;
    LOWORD(v1) = v18;
    *((_DWORD *)a1 + 3332) = v2;
    v4 = v16;
    *((_DWORD *)a1 + 3333) = v3;
    qmemcpy((char *)a1 + 13340, &v19, 0x54u);
    v5 = v17;
    *((_WORD *)a1 + 6668) = v1;
    LOBYTE(v1) = v21;
    *((_DWORD *)a1 + 3009) = v5;
    qmemcpy((char *)a1 + 13424, &v20, 0x40u);
    *((_DWORD *)a1 + 3008) = v4;
    *((_BYTE *)a1 + 13488) = v1 & 2;
    v6 = a1;
    v7 = 32;
    do
    {
      memset(v6, 0, 0x38u);
      *((_DWORD *)v6 + 9) = 2048;
      v6 = (char *)v6 + 56;
      --v7;
    }
    while ( v7 );
    v8 = (char *)a1 + 1799;
    v9 = 512;
    do
    {
      *(_DWORD *)(v8 - 7) = 0;
      *(_DWORD *)(v8 - 3) = 0;
      *(_DWORD *)(v8 + 1) = 0;
      *(_DWORD *)(v8 + 5) = 0;
      *(_DWORD *)(v8 + 9) = 0;
      *v8 = -1;
      v8 += 20;
      --v9;
    }
    while ( v9 );
    result = 1;
  }
  return result;
}

//----- (10063870) --------------------------------------------------------
bool __thiscall sub_10063870(void *this)
{
  return (sub_100460A0(this) & 0x8000) == 0x8000;
}

//----- (10063890) --------------------------------------------------------
char __cdecl sub_10063890(unsigned __int8 a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-208h]@1
  char v3[453]; // [sp+3Fh] [bp-1C9h]@2

  if ( sub_1007C3B0(6444, (int)&v2, 514) == 0 )
    result = v3[a1];
  else
    result = 0;
  return result;
}
// 10063890: using guessed type char var_1C9[453];

//----- (10063900) --------------------------------------------------------
char __cdecl sub_10063900(int a1, char a2, char a3, int a4, void *a5, size_t a6)
{
  char result; // al@3
  char v7; // al@6
  char v8; // bl@8
  char v9; // al@10
  char v10; // bl@12
  char v11; // al@14
  char v12; // bl@16
  char v13; // al@18
  char v14; // bl@20

  switch ( a3 )
  {
    case 0x18:
      if ( a2 )
        result = sub_10063720(a5);
      else
        result = sub_10063700(a5);
      break;
    case 0x19:
      if ( a2 )
        v7 = sub_10063720(&unk_10292500);
      else
        v7 = sub_10063700(&unk_10292500);
      v8 = v7;
      memcpy(a5, (char *)&unk_10292500 + 56 * *(_BYTE *)a4, a6);
      result = v8;
      break;
    case 0x1A:
      if ( a2 )
        v9 = sub_10063720(&unk_10292500);
      else
        v9 = sub_10063700(&unk_10292500);
      v10 = v9;
      memcpy(a5, (char *)&unk_10295408 + 40 * *(_BYTE *)a4, a6);
      result = v10;
      break;
    case 0x1B:
      if ( a2 )
        v11 = sub_10063720(&unk_10292500);
      else
        v11 = sub_10063700(&unk_10292500);
      v12 = v11;
      memcpy(a5, (char *)&unk_10295908 + *(_BYTE *)a4, a6);
      result = v12;
      break;
    case 0x2B:
      if ( a2 )
        v13 = sub_10063720(&unk_10292500);
      else
        v13 = sub_10063700(&unk_10292500);
      v14 = v13;
      memcpy(a5, &unk_102959B0, a6);
      result = v14;
      break;
    default:
      sub_10042930("..\\lib\\acl\\iop\\gdl59\\iop_gdl59_cnfg_intf.c", 709, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10063AA0) --------------------------------------------------------
char __cdecl sub_10063AA0(char a1)
{
  char result; // al@3

  if ( a1 == 15 )
  {
    result = 0;
  }
  else if ( a1 == 16 )
  {
    result = 1;
  }
  else
  {
    sub_10042930("..\\lib\\acl\\iop\\iop_adc_intf.c", 178, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10063AE0) --------------------------------------------------------
__int16 __usercall sub_10063AE0@<ax>(unsigned __int8 a1@<al>)
{
  return word_10141418[a1];
}
// 10141418: using guessed type __int16 word_10141418[];

//----- (10063AF0) --------------------------------------------------------
char __cdecl sub_10063AF0(unsigned __int8 a1, char *a2)
{
  int v2; // eax@2
  char result; // al@5
  int v4; // [sp+4h] [bp-150h]@2
  char v5; // [sp+8h] [bp-14Ch]@1
  char v6; // [sp+9h] [bp-14Bh]@3
  char v7; // [sp+Ch] [bp-148h]@5

  memset(&v5, 0, 0x148u);
  if ( a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    LOWORD(v2) = sub_10063AE0(a1);
    if ( sub_100253F0(0, v2, &v5, (int)&v4) && v6 == 3 && (unsigned int)(unsigned __int16)v4 - 4 >= 0xA0 )
    {
      qmemcpy(a2, &v7, 0xA0u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (10063BC0) --------------------------------------------------------
char __cdecl sub_10063BC0(char a1, char a2, char a3, int a4, char *a5, unsigned int a6)
{
  char result; // al@3
  unsigned __int8 v7; // [sp+4h] [bp-4h]@1

  v7 = sub_10063AA0(a1);
  if ( a3 != 11 )
  {
    sub_10042930("..\\lib\\acl\\iop\\iop_adc_intf.c", 564, 0, 0);
    return 0;
  }
  if ( a6 >= 0xA0 )
  {
    if ( a2 )
      return 0;
    result = sub_10063AF0(v7, a5);
  }
  else
  {
    sub_10042930("..\\lib\\acl\\iop\\iop_adc_intf.c", 551, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10063C40) --------------------------------------------------------
char __cdecl sub_10063C40(unsigned __int16 a1)
{
  char v1; // bl@1
  char result; // al@5
  char v3; // [sp+Bh] [bp-411h]@2
  int v4; // [sp+Ch] [bp-410h]@1
  int v5; // [sp+10h] [bp-40Ch]@1
  char v6[1028]; // [sp+14h] [bp-408h]@5

  v1 = 0;
  if ( sub_10062ED0(a1, &v5, &v4) && sub_10024A50(v5, v4, &v3) && (v1 = v3) != 0
    || a1 >= 0x1D8u
    || (sub_1007C4B0(6943, (int)v6, 1028), result = 1, !v6[a1]) )
  {
    result = v1;
  }
  return result;
}
// 10063C40: using guessed type char var_408[1028];

//----- (10063CE0) --------------------------------------------------------
char __cdecl sub_10063CE0(char a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@3
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10078250(a1);
  switch ( a3 )
  {
    case 5:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10078050(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 4:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_100780D0(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 0xA:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10078150(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 3:
      if ( a2 != 1 )
        goto LABEL_10;
      result = sub_100781D0(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      break;
    default:
LABEL_10:
      result = 0;
      break;
  }
  return result;
}

//----- (10063DF0) --------------------------------------------------------
int __cdecl sub_10063DF0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10043FF0(&a1, 1u, (int)&unk_10141C50, 8, 4, 4);
  if ( v1 == 4 )
  {
    sub_10042930("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_intf.c", 437, 0, 0);
    result = 42066;
  }
  else
  {
    result = dword_10141C54[2 * v1];
  }
  return result;
}
// 10141C54: using guessed type int dword_10141C54[];

//----- (10063E40) --------------------------------------------------------
bool __cdecl sub_10063E40(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  char v4; // dl@5
  bool result; // al@5

  v3 = a2;
  if ( a2 >= 0xFFu || a2 > 1u )
  {
    result = 0;
  }
  else
  {
    if ( dword_102959D0 != 1379255385 )
    {
      sub_10046510(a1, (int)&byte_102959D8[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v4 = byte_102959DD[4 * (v3 + 6 * (unsigned __int8)a1)];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_102959DC[4 * (v3 + 6 * (unsigned __int8)a1)];
    result = (unsigned __int8)v4 < 0xBu;
  }
  return result;
}
// 102959D0: using guessed type int dword_102959D0;

//----- (10063EB0) --------------------------------------------------------
bool __cdecl sub_10063EB0(char a1, unsigned __int8 a2, int a3)
{
  bool result; // al@2

  if ( a2 < 1u )
  {
    if ( dword_102959D0 != 1379255385 )
      sub_10046510(a1, (int)&byte_102959D8[24 * (unsigned __int8)a1]);
    *(_DWORD *)a3 = dword_102959EC[a2 + 6 * (unsigned __int8)a1];
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 102959D0: using guessed type int dword_102959D0;
// 102959EC: using guessed type int dword_102959EC[];

//----- (10063F10) --------------------------------------------------------
bool __cdecl sub_10063F10(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  bool result; // al@1
  int v5; // edx@5

  v3 = a2;
  result = 0;
  if ( (a2 & 0x80u) == 0 && a2 <= 1u )
  {
    if ( dword_102959D0 != 1379255385 )
    {
      sub_10046510(a1, (int)&byte_102959D8[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v5 = dword_102959E4[v3 + 6 * (unsigned __int8)a1];
    *(_DWORD *)a3 = v5;
    result = (unsigned __int8)v5 < 0x13u && *(_BYTE *)(a3 + 1) < 0x13u;
  }
  return result;
}
// 102959D0: using guessed type int dword_102959D0;
// 102959E4: using guessed type int dword_102959E4[];

//----- (10063F80) --------------------------------------------------------
char __cdecl sub_10063F80(char a1, _BYTE *a2)
{
  if ( dword_102959D0 != 1379255385 )
    sub_10046510(a1, (int)&byte_102959D8[24 * (unsigned __int8)a1]);
  *a2 = byte_102959D8[24 * (unsigned __int8)a1];
  return 1;
}
// 102959D0: using guessed type int dword_102959D0;

//----- (10063FC0) --------------------------------------------------------
char __thiscall sub_10063FC0(void *this)
{
  char v1; // bl@1
  char *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_102959D0 = sub_100460C0(this) != 2 ? 1379255385 : 1916032632;
  memset(byte_102959D8, 0, 0x48u);
  v1 = 0;
  v4 = 0;
  v2 = byte_102959D8;
  do
  {
    result = sub_10046510(v4, (int)v2);
    ++v1;
    v2 += 24;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 3u );
  return result;
}
// 102959D0: using guessed type int dword_102959D0;

//----- (10064030) --------------------------------------------------------
char __cdecl sub_10064030(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_10049CB0(a1);
  v3 = sub_1007D3D0(a2, 0, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (10064060) --------------------------------------------------------
char __cdecl sub_10064060(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_10049CB0(a1);
  v3 = sub_1007D440(a2, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (10064090) --------------------------------------------------------
char __cdecl sub_10064090(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6)
{
  char result; // al@3
  char v7; // [sp+0h] [bp-4h]@1

  v7 = sub_10049DA0(a1);
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        result = sub_10063F10(v7, *a4, (int)a5);
      }
      else
      {
        sub_10042930("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 531, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        result = sub_10063E40(v7, *a4, (int)a5);
      }
      else
      {
        sub_10042930("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 548, 0, 0);
        result = 0;
      }
      break;
    case 3:
      if ( a6 >= 4 )
      {
        result = sub_10063EB0(v7, *a4, (int)a5);
      }
      else
      {
        sub_10042930("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 565, 0, 0);
        result = 0;
      }
      break;
    case 7:
      if ( a6 >= 1 )
      {
        result = sub_10063F80(v7, a5);
      }
      else
      {
        sub_10042930("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 582, 0, 0);
        result = 0;
      }
      break;
    case 0x10:
      if ( a6 >= 0x40 )
      {
        result = sub_10064060(v7, (int)a5);
      }
      else
      {
        sub_10042930("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 598, 0, 0);
        result = 0;
      }
      break;
    case 0xF:
      if ( a6 >= 0x68 )
      {
        result = sub_10064030(v7, (int)a5);
      }
      else
      {
        sub_10042930("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 616, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10042930("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 633, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10064260) --------------------------------------------------------
char __cdecl sub_10064260(char a1)
{
  return sub_10024E60(1, 43, &a1, 0, 1, 1);
}

//----- (10064280) --------------------------------------------------------
int __cdecl sub_10064280(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10295A20 = *(_DWORD *)a1;
  dword_10295A24 = *(_DWORD *)(a1 + 4);
  dword_10295A28 = *(_DWORD *)(a1 + 8);
  dword_10295A2C = *(_DWORD *)(a1 + 12);
  dword_103334E8 = (int)&dword_10295A20;
  return result;
}
// 10295A20: using guessed type int dword_10295A20;
// 10295A24: using guessed type int dword_10295A24;
// 10295A28: using guessed type int dword_10295A28;
// 10295A2C: using guessed type int dword_10295A2C;
// 103334E8: using guessed type int dword_103334E8;

//----- (100642C0) --------------------------------------------------------
int __cdecl sub_100642C0(int *a1, int a2)
{
  int result; // eax@1

  result = a2 + (*(int (**)(void))dword_103334E8)();
  *a1 = result;
  return result;
}
// 103334E8: using guessed type int dword_103334E8;

//----- (100642F0) --------------------------------------------------------
int __cdecl sub_100642F0(char a1, char *a2)
{
  int result; // eax@1
  char *v3; // edi@2
  char *v4; // esi@3
  int v5; // edi@3

  result = sub_10043FF0(&a1, 1u, (int)&unk_101437E0, 68, 4, 4);
  if ( result < 4 )
  {
    v3 = a2;
    if ( a2 )
    {
      v4 = (char *)&unk_101437E1 + 68 * result;
      qmemcpy(a2, v4, 0x40u);
      v4 += 64;
      v5 = (int)(v3 + 64);
      *(_WORD *)v5 = *(_WORD *)v4;
      *(_BYTE *)(v5 + 2) = v4[2];
    }
  }
  return result;
}

//----- (10064340) --------------------------------------------------------
char sub_10064340()
{
  return 2;
}

//----- (10064350) --------------------------------------------------------
char sub_10064350()
{
  return 3;
}

//----- (10064360) --------------------------------------------------------
char __cdecl sub_10064360(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  if ( a1 >= 0x319u )
  {
    sub_10042930("..\\lib\\acl\\iop\\dscrt\\iop_dscrt_data_tbl_utl.c", 115, 0, 0);
    return 0;
  }
  if ( a2 >= 3u )
    return 0;
  *a3 = byte_1015A370[8 * a1];
  *a4 = word_1015A372[a2 + 4 * a1];
  return 1;
}
// 1015A372: using guessed type __int16 word_1015A372[];

//----- (100643C0) --------------------------------------------------------
char __cdecl sub_100643C0(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  if ( a1 >= 0x145u )
  {
    sub_10042930("..\\lib\\acl\\iop\\dscrt\\iop_dscrt_data_tbl_utl.c", 320, 0, 0);
    return 0;
  }
  if ( a2 >= 3u )
    return 0;
  *a3 = byte_1015BC38[16 * a1];
  *a4 = word_1015BC40[a2 + 8 * a1];
  return 1;
}
// 1015BC40: using guessed type __int16 word_1015BC40[];

//----- (10064420) --------------------------------------------------------
char sub_10064420()
{
  unsigned __int16 v0; // dx@1
  int v1; // ecx@2
  unsigned __int16 v2; // ax@9
  int v4[7]; // [sp+8h] [bp-1Ch]@1

  sub_1007C4B0(6465, (int)v4, 28);
  v0 = 0;
LABEL_2:
  v1 = v4[v0];
  if ( v1 == 1 || v1 == 2 || v1 == 4 || v1 == 64 || v1 == 128 || v1 == 16 || v1 == 32 )
  {
    v2 = 0;
    while ( v2 == v0 || v4[v2] != v1 )
    {
      if ( ++v2 >= 7u )
      {
        if ( ++v0 < 7u )
          goto LABEL_2;
        return 1;
      }
    }
  }
  return 0;
}
// 10064420: using guessed type int var_1C[7];

//----- (100644A0) --------------------------------------------------------
char __cdecl sub_100644A0(_DWORD *a1)
{
  void *v1; // ecx@0
  char v2; // al@1
  char v3; // al@1
  char result; // al@3
  char v5; // [sp+7h] [bp-5h]@1
  int v6; // [sp+8h] [bp-4h]@2

  v2 = sub_10045280(v1);
  v5 = sub_10045200(v2, 1);
  v3 = sub_10043FF0(&v5, 1u, (int)&unk_10144648, 4, 3, 2);
  v5 = v3;
  if ( v3 != 2 && sub_100253C0(6, (unsigned __int16)word_1014464A[2 * (unsigned __int8)v3], &v6) )
  {
    result = 1;
    *a1 = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1014464A: using guessed type __int16 word_1014464A[];

//----- (10064510) --------------------------------------------------------
int __cdecl sub_10064510(_BYTE *a1)
{
  return sub_10054770(a1, 0, 0x2710u, 5000, 0);
}

//----- (10064530) --------------------------------------------------------
int __cdecl sub_10064530(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 5u, 5u, 0);
}

//----- (10064550) --------------------------------------------------------
int __cdecl sub_10064550(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 6u, 0, 0);
}

//----- (10064570) --------------------------------------------------------
int __cdecl sub_10064570(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 0xEu, 1u, 0);
}

//----- (10064590) --------------------------------------------------------
int __cdecl sub_10064590(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 1u, 0, 0);
}

//----- (100645C0) --------------------------------------------------------
int __cdecl sub_100645C0(int a1)
{
  int result; // eax@1

  result = sub_10064530((unsigned __int8 *)a1);
  if ( !result )
  {
    result = sub_100645B0(a1 + 12);
    if ( !result )
    {
      result = sub_10064590((unsigned __int8 *)(a1 + 1));
      if ( !result )
        result = sub_10064570((unsigned __int8 *)(a1 + 2));
    }
  }
  return result;
}
// 100645B0: using guessed type _DWORD __cdecl sub_100645B0(_DWORD);

//----- (10064600) --------------------------------------------------------
int __cdecl sub_10064600(int a1)
{
  int result; // eax@1

  result = sub_10062DA0((void *)(a1 + 28));
  if ( !result )
    result = sub_100645C0(a1);
  return result;
}

//----- (10064620) --------------------------------------------------------
char __cdecl sub_10064620(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // ecx@2
  int v5; // [sp+0h] [bp-Ch]@1
  __int16 v6; // [sp+4h] [bp-8h]@2
  int v7; // [sp+8h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_103334D8)(a1, 12, &v5);
  if ( result )
  {
    v3 = v6;
    *(_DWORD *)a2 = v5;
    v4 = v7 & 0xFFFFFF;
    *(_WORD *)(a2 + 4) = v3;
    *(_DWORD *)(a2 + 8) = v4;
    result = 1;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;

//----- (10064670) --------------------------------------------------------
char __cdecl sub_10064670(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  __int16 v4; // cx@2
  __int16 v5; // dx@2
  __int16 v6; // cx@2
  int v7; // edx@2
  __int16 v8; // cx@2
  unsigned int v9; // ecx@2
  int v10; // edx@2
  __int16 v11; // [sp+0h] [bp-1Ch]@1
  __int16 v12; // [sp+2h] [bp-1Ah]@2
  __int16 v13; // [sp+4h] [bp-18h]@2
  __int16 v14; // [sp+6h] [bp-16h]@2
  __int16 v15; // [sp+8h] [bp-14h]@2
  int v16; // [sp+Ah] [bp-12h]@2
  __int16 v17; // [sp+Eh] [bp-Eh]@2
  int v18; // [sp+12h] [bp-Ah]@2
  unsigned int v19; // [sp+16h] [bp-6h]@2
  char v20; // [sp+1Ah] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_103334D8)(a1, 27, &v11);
  if ( result )
  {
    v3 = v12;
    *(_WORD *)a2 = v11;
    v4 = v13;
    *(_WORD *)(a2 + 2) = v3;
    v5 = v14;
    *(_WORD *)(a2 + 4) = v4;
    v6 = v15;
    *(_WORD *)(a2 + 6) = v5;
    *(_DWORD *)(a2 + 12) = v16;
    v7 = v18;
    *(_WORD *)(a2 + 8) = v6;
    v8 = v17;
    *(_DWORD *)(a2 + 20) = v7;
    *(_WORD *)(a2 + 16) = v8;
    v9 = v19;
    *(_DWORD *)(a2 + 24) = v19 & 3;
    *(_DWORD *)(a2 + 28) = (v9 >> 2) & 1;
    v10 = (v9 >> 3) & 3;
    *(_DWORD *)(a2 + 36) = (v9 >> 5) & 1;
    LOBYTE(v9) = v20;
    *(_DWORD *)(a2 + 32) = v10;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v9 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v9 >> 6;
    result = 1;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;

//----- (10064720) --------------------------------------------------------
char __cdecl sub_10064720(int a1, int a2)
{
  char result; // al@1
  char v3; // ah^2@2
  __int16 v4; // dx@2
  __int16 v5; // dx@2
  int v6; // [sp+0h] [bp-8h]@1
  unsigned int v7; // [sp+4h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_103334D8)(a1, 8, &v6);
  if ( result )
  {
    v3 = BYTE3(v6);
    *(_DWORD *)a2 = v6 & 0xFFFFFF;
    LOBYTE(v4) = 0;
    HIBYTE(v4) = v3;
    v5 = (unsigned __int8)v7 ^ v4;
    *(_DWORD *)(a2 + 8) = v7 >> 8;
    *(_WORD *)(a2 + 4) = v5;
    result = 1;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;

//----- (10064780) --------------------------------------------------------
char __cdecl sub_10064780(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // esi@2
  unsigned int v5; // ecx@2
  __int16 v6; // [sp+0h] [bp-14h]@1
  __int16 v7; // [sp+2h] [bp-12h]@2
  __int16 v8; // [sp+4h] [bp-10h]@2
  __int16 v9; // [sp+6h] [bp-Eh]@2
  __int16 v10; // [sp+8h] [bp-Ch]@2
  unsigned __int16 v11; // [sp+Ah] [bp-Ah]@2
  int v12; // [sp+Ch] [bp-8h]@2
  char v13; // [sp+12h] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_103334D8)(a1, 19, &v6);
  if ( result )
  {
    v3 = v7;
    *(_WORD *)a2 = v6;
    *(_WORD *)(a2 + 4) = v8;
    *(_WORD *)(a2 + 8) = v10;
    *(_WORD *)(a2 + 2) = v3;
    v4 = v11;
    *(_WORD *)(a2 + 6) = v9;
    LOBYTE(v3) = v13;
    *(_DWORD *)(a2 + 12) = v4 + ((v13 & 7) << 16);
    *(_WORD *)(a2 + 16) = v12 & 0x3FFF;
    v5 = *(int *)((char *)&v12 + 2);
    *(_DWORD *)(a2 + 20) = *(int *)((char *)&v12 + 2) & 0xFFFFFF;
    *(_DWORD *)(a2 + 24) = (v5 >> 24) & 3;
    *(_DWORD *)(a2 + 28) = (v5 >> 26) & 1;
    *(_DWORD *)(a2 + 36) = (v5 >> 29) & 1;
    *(_DWORD *)(a2 + 32) = (v5 >> 27) & 3;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v3 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v3 >> 6;
    result = 1;
  }
  return result;
}
// 103334D8: using guessed type int dword_103334D8;

//----- (10064850) --------------------------------------------------------
char *__cdecl sub_10064850(char **a1)
{
  char *v1; // edx@1
  int v2; // edi@1
  char *result; // eax@1
  char *v4; // eax@3
  char v5; // cl@4
  int v6; // eax@5
  char v7; // cl@7

  v1 = *a1;
  v2 = 0;
  result = &byte_100930C0;
  if ( *a1 && *v1 )
  {
    v4 = *a1;
    do
      v5 = *v4++;
    while ( v5 );
    v6 = v4 - (v1 + 1) - 1;
    do
    {
      if ( v6 < 0 )
        break;
      v7 = v1[v6];
      if ( v7 == 47 || v7 == 92 )
        v2 = v6 + 1;
      --v6;
    }
    while ( !v2 );
    result = &v1[v2];
  }
  return result;
}

//----- (100648A0) --------------------------------------------------------
int sub_100648A0()
{
  int v0; // esi@1
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@2

  v0 = 0;
  v1 = sub_1007BFD0();
  result = 0;
  while ( 1 )
  {
    v3 = dword_102F578C[result];
    if ( v3 == v1 )
      break;
    if ( !v0 && v3 == -1 )
      v0 = result;
    if ( (unsigned int)++result >= 5 )
    {
      dword_102F578C[v0] = v1;
      return v0;
    }
  }
  return result;
}
// 102F578C: using guessed type int dword_102F578C[];

//----- (100648E0) --------------------------------------------------------
int __cdecl sub_100648E0(_BYTE *a1, int a2)
{
  int result; // eax@3
  int v3; // esi@3
  _BYTE *v4; // ecx@4
  char v5; // dl@5

  if ( a1 )
  {
    if ( a2 )
    {
      result = 0;
      v3 = 0;
      if ( *a1 )
      {
        v4 = a1;
        do
        {
          v5 = v4[a2 - (_DWORD)a1];
          if ( !v5 )
            break;
          if ( *v4 != v5 )
          {
            result = a1[v3] - *(_BYTE *)(v3 + a2);
            if ( a1[v3] != *(_BYTE *)(v3 + a2) )
              return result;
            break;
          }
          ++v4;
          ++v3;
        }
        while ( *v4 );
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(v3 + a2) )
      {
        result = -1;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10064950) --------------------------------------------------------
signed int __cdecl sub_10064950(_BYTE *a1, int a2)
{
  _BYTE *v2; // esi@1
  int v3; // ebp@1
  int v4; // ebx@4
  int v5; // edi@6
  int v6; // eax@6
  signed int result; // eax@11
  int v8; // [sp+8h] [bp-4h]@3

  v2 = a1;
  v3 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v8 = 0;
      if ( *a1 )
      {
        v4 = a2 - (_DWORD)a1;
        while ( v2[v4] )
        {
          v5 = tolower(*v2);
          v6 = tolower(v2[v4]);
          if ( v5 != v6 )
          {
            v8 = v5 - v6;
            if ( v5 != v6 )
              goto LABEL_16;
            break;
          }
          ++v2;
          ++v3;
          if ( !*v2 )
            break;
        }
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(a2 + v3) )
      {
        result = -1;
      }
      else
      {
LABEL_16:
        result = v8;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (100649F0) --------------------------------------------------------
int __usercall sub_100649F0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>)
{
  int result; // eax@5

  if ( a1 && *a1 )
  {
    if ( a2 && *a2 )
      result = 3 - (sub_10064950(a2, (int)a1) != 0);
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10064A20) --------------------------------------------------------
signed int __usercall sub_10064A20@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5)
{
  int v5; // ebp@1
  int v6; // edi@1
  signed int result; // eax@2
  const char *v8; // [sp-8h] [bp-18h]@11
  int v9; // [sp-4h] [bp-14h]@11
  int v10; // [sp+8h] [bp-8h]@14
  int v11; // [sp+Ch] [bp-4h]@17
  signed int v12; // [sp+14h] [bp+4h]@3

  v5 = a4;
  v6 = 0;
  *(_DWORD *)a4 = a1;
  switch ( a1 )
  {
    case 0:
      sprintf(a5, "Too many arguments for command");
      result = 8;
      break;
    case 1:
      v12 = 9;
      while ( sub_10064950((_BYTE *)a3, (int)(&off_10144BE0)[8 * v6]) )
      {
        if ( (unsigned int)++v6 >= 0xD )
        {
          sprintf(a5, "Error converting '%s' to a boolean", a3);
          goto LABEL_25;
        }
      }
      ++*a2;
      result = 0;
      *(_BYTE *)(v5 + 4) = byte_10144BE4[8 * v6];
      break;
    case 2:
      if ( !*(_BYTE *)a3 || *(_BYTE *)(a3 + 1) )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a char";
        goto LABEL_12;
      }
      *(_BYTE *)(a4 + 4) = *(_BYTE *)a3;
      result = 0;
      break;
    case 3:
      if ( sub_10080408(a3, (int)"%ld", (unsigned int)&v10) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a sint32";
        goto LABEL_12;
      }
      *(_DWORD *)(a4 + 4) = v10;
      ++*a2;
      result = 0;
      break;
    case 4:
      if ( sub_10080408(a3, (int)"%lu", (unsigned int)&v11) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a uint32";
LABEL_12:
        sprintf(a5, v8, v9);
        goto LABEL_13;
      }
      *(_DWORD *)(a4 + 4) = v11;
      ++*a2;
      result = 0;
      break;
    case 6:
      if ( sub_10080408(a3, (int)"%f", a4 + 4) == 1 )
        goto LABEL_23;
      sprintf(a5, "Error converting '%s' to a float", a3);
LABEL_13:
      result = 9;
      break;
    case 5:
      strncpy((char *)(a4 + 4), (const char *)a3, 0x50u);
LABEL_23:
      ++*a2;
      result = 0;
      break;
    default:
      v12 = 9;
      *(_DWORD *)v5 = 0;
      sprintf(a5, "Command definition error: Unsupported argument type (%d)", a1);
LABEL_25:
      result = v12;
      break;
  }
  return result;
}
// 10144BE0: using guessed type char *off_10144BE0;

//----- (10064BF0) --------------------------------------------------------
char *__usercall sub_10064BF0@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>)
{
  if ( a2 )
  {
    if ( (_BYTE)result && *(_BYTE *)a3 )
    {
      if ( *a2 )
      {
        strncat((char *)a3, word_1009F07C, 0x100u);
        result = strncat((char *)a3, a2, 0x100u);
        *(_BYTE *)(a3 + 255) = 0;
        return result;
      }
    }
    else
    {
      result = strncpy((char *)a3, a2, 0x100u);
    }
    *(_BYTE *)(a3 + 255) = 0;
  }
  else if ( !(_BYTE)result )
  {
    *(_BYTE *)a3 = 0;
  }
  return result;
}

//----- (10064C50) --------------------------------------------------------
int __usercall sub_10064C50@<eax>(int a1@<esi>, int a2, _DWORD *a3)
{
  unsigned int v3; // edi@4
  int v4; // ebx@5
  int v5; // eax@6
  int result; // eax@9
  int v7; // ecx@10

  if ( a1 && *(_DWORD *)(a1 + 8) && *(_BYTE *)(80 * *a3 + a2) )
  {
    v3 = 0;
    if ( *(_DWORD *)(a1 + 12) <= 0u )
    {
      result = 0;
    }
    else
    {
      v4 = 0;
      while ( 1 )
      {
        v5 = v4 + *(_DWORD *)(a1 + 8);
        if ( *(_DWORD *)(v5 + 12) < 2u && !sub_10064950((_BYTE *)(a2 + 80 * *a3), *(_DWORD *)v5) )
          break;
        ++v3;
        v4 += 40;
        if ( v3 >= *(_DWORD *)(a1 + 12) )
          return 0;
      }
      v7 = *(_DWORD *)(a1 + 8);
      ++*a3;
      result = v7 + 40 * v3;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10064CE0) --------------------------------------------------------
int __usercall sub_10064CE0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4)
{
  int v4; // edi@1
  unsigned int v5; // ebp@1
  int v6; // esi@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  do
  {
    if ( v5 >= a3 )
      break;
    if ( *(_DWORD *)(v6 + 12) >= 2u && sub_100649F0(*(_BYTE **)v6, (_BYTE *)(a4 + 80 * *a2)) == 3 )
    {
      ++*a2;
      v4 = v6;
    }
    ++v5;
    v6 += 40;
  }
  while ( !v4 );
  return v4;
}

//----- (10064D30) --------------------------------------------------------
char **__usercall sub_10064D30@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3)
{
  char **result; // eax@1
  int v4; // edi@1
  int (**v5)(void); // eax@2
  char **v6; // eax@3
  char **v7; // esi@3
  char *v8; // eax@3

  result = 0;
  v4 = 0;
  if ( *a1 )
  {
    v5 = a1;
    while ( 1 )
    {
      v6 = (char **)(*v5)();
      v7 = v6;
      v8 = sub_10064850(v6);
      if ( !sub_10064950((_BYTE *)(a2 + 80 * *a3), (int)v8) )
        break;
      v5 = &a1[++v4];
      if ( !a1[v4] )
        return 0;
    }
    ++*a3;
    result = v7;
  }
  return result;
}

//----- (10064D90) --------------------------------------------------------
const char *__usercall sub_10064D90@<eax>(int a1@<eax>)
{
  const char *result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
      result = "Group";
    else
      result = "Command";
  }
  else
  {
    result = "Case";
  }
  return result;
}

//----- (10064DB0) --------------------------------------------------------
int __usercall sub_10064DB0@<eax>(unsigned int a1@<ebx>)
{
  int (**v1)(void); // esi@1
  unsigned int v2; // edi@1
  int result; // eax@4

  v1 = (int (**)(void))dword_102F5778[sub_100648A0()];
  v2 = 0;
  if ( a1 )
  {
    while ( v1 && *v1 )
    {
      result = (*v1)();
      ++v2;
      ++v1;
      if ( v2 >= a1 )
        return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 102F5778: using guessed type int dword_102F5778[];

//----- (10064DF0) --------------------------------------------------------
int __usercall sub_10064DF0@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5)
{
  signed int *v5; // ebx@1
  int result; // eax@1
  _DWORD *v7; // edi@2
  int *v8; // ebp@2
  _BYTE *v9; // esi@4
  signed int v10; // ebx@9
  signed int v11; // [sp+8h] [bp-4h]@2

  v5 = a1;
  result = 0;
  if ( a3 )
  {
    v7 = a2;
    v8 = (int *)(a3 + 16);
    v11 = 5;
    do
    {
      if ( result || (v9 = (_BYTE *)(80 * *v5 + a4), !*v9) )
        *v7 = 0;
      else
        result = sub_10064A20(*v8, v5, (int)v9, (int)v7, a5);
      ++v8;
      v7 += 21;
      --v11;
    }
    while ( v11 );
    if ( !result )
    {
      v10 = *v5;
      if ( v10 < 5 )
      {
        if ( *(_DWORD *)(a3 + 4 * v10 + 16) )
        {
          sprintf(a5, "Missing required command argument");
          result = 7;
        }
      }
    }
  }
  return result;
}

//----- (10064E80) --------------------------------------------------------
int __usercall sub_10064E80@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4)
{
  int v4; // ebx@1
  signed int v5; // edx@1
  _BYTE *v6; // edi@1
  signed int v7; // ebp@1
  signed int v8; // ecx@1
  int v9; // ecx@3
  char v10; // al@4
  signed int v11; // edi@21
  int result; // eax@27
  char v13; // [sp+Fh] [bp-9h]@1
  signed int v14; // [sp+10h] [bp-8h]@1
  int v15; // [sp+14h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  v14 = 3;
  v15 = 0;
  v7 = 0;
  v13 = 0;
  *a2 = 0;
  v8 = 9;
  do
  {
    *a1 = 0;
    a1 += 80;
    --v8;
  }
  while ( v8 );
  v9 = a3;
  if ( !*(_BYTE *)a3 )
    return 3;
  while ( 1 )
  {
    v10 = *(_BYTE *)(v4 + v9);
    if ( v13 )
    {
      if ( v13 != v10 )
        goto LABEL_15;
      v13 = 0;
LABEL_18:
      v9 = a3;
      goto LABEL_19;
    }
    if ( v10 != 34 && v10 != 39 )
      break;
    v13 = *(_BYTE *)(v4 + v9);
LABEL_19:
    if ( !*(_BYTE *)(++v4 + v9) )
      goto LABEL_23;
  }
  if ( v10 == 32 || v10 == 9 )
  {
    if ( v7 )
    {
      ++*a2;
      v7 = 0;
      v5 = 0;
    }
    v15 = v4;
    goto LABEL_19;
  }
LABEL_15:
  if ( *a2 >= 8 )
  {
    v11 = 5;
    sprintf(a4, "Too many parameters. Maximum of %d parameters supported.", 8);
    goto LABEL_24;
  }
  if ( v5 < 80 )
  {
    *(&v6[80 * *a2] + v5) = v10;
    v7 = 1;
    ++v5;
    v14 = 0;
    *(&v6[80 * *a2] + v5) = 0;
    goto LABEL_18;
  }
  v14 = 6;
  sprintf(a4, "Parameter too long (starting at %s). Maximum parameter length supported is %d.", v15 + a3 + 1, 80);
LABEL_23:
  v11 = v14;
LABEL_24:
  if ( v7 )
  {
    if ( !v13 )
    {
      ++*a2;
      goto LABEL_27;
    }
    sprintf(a4, "Parameter %d missing closing quote", *a2);
    result = 6;
  }
  else
  {
LABEL_27:
    result = v11;
  }
  return result;
}

//----- (10064FD0) --------------------------------------------------------
int __usercall sub_10064FD0@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>)
{
  _DWORD *v3; // edi@1
  int result; // eax@1
  int v5; // ecx@2
  int v6; // eax@4
  int v7; // edi@4
  int v8; // edi@7

  v3 = a1;
  result = 0;
  if ( a3 )
  {
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        sub_10059B60(5, *(_DWORD *)a3);
        v6 = (*(int (**)(void))(a3 + 8))();
        sub_100658B0(v3, v6, 0);
        v7 = -*v3;
        sub_10059B60(9, *(_DWORD *)a3);
        result = v7;
      }
    }
    else
    {
      sub_10059B60(6, *(_DWORD *)a3);
      if ( a2 )
        a2(5, &unk_10144898);
      sub_100782F0(a3);
      v8 = -*v3;
      if ( a2 )
        a2(6, &unk_10144898);
      sub_10059B60(8, *(_DWORD *)a3);
      result = v8;
    }
  }
  return result;
}

//----- (10065070) --------------------------------------------------------
int __usercall sub_10065070@<eax>(int result@<eax>)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_BYTE *)(result + 33) = 0;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 24) = 1;
  *(_BYTE *)(result + 32) = 1;
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 52) = 0;
  return result;
}

//----- (100650B0) --------------------------------------------------------
char *__cdecl sub_100650B0(int a1, char *a2, int a3, const char *a4)
{
  const char *v4; // ecx@0
  const char *v5; // ebx@1
  char *v6; // eax@1
  char *v7; // ecx@1
  char *result; // eax@3
  char *v9; // eax@5
  const char *v10; // edi@5
  const char **v11; // ebx@8
  char *v12; // eax@10
  const char *v13; // edi@10
  char **v14; // ebp@10
  const char *v15; // edi@12
  char *v16; // [sp+10h] [bp-624h]@8
  signed int v17; // [sp+14h] [bp-620h]@10
  int v18[6]; // [sp+18h] [bp-61Ch]@2
  char v19; // [sp+30h] [bp-604h]@1
  char v20; // [sp+130h] [bp-504h]@5
  char v21; // [sp+230h] [bp-404h]@7
  char v22; // [sp+330h] [bp-304h]@10
  char v23; // [sp+430h] [bp-204h]@10
  char v24; // [sp+530h] [bp-104h]@10

  v5 = v4;
  v6 = 0;
  v7 = &v19;
  do
  {
    v18[(signed int)v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( (unsigned int)v6 < 6 );
  LOBYTE(v6) = 0;
  result = sub_10064BF0(v6, "command", (int)&v19);
  if ( a3 )
  {
    LOBYTE(result) = 0;
    if ( a4 )
    {
      v9 = sub_10064BF0(result, a4, (int)&v20);
      v10 = v5;
    }
    else
    {
      v9 = sub_10064BF0(result, v5, (int)&v20);
      v10 = &byte_100930C0;
    }
    LOBYTE(v9) = 0;
    sub_10064BF0(v9, v10, (int)&v21);
    result = a2;
    if ( a2 )
    {
      v11 = (const char **)(a1 + 36);
      v16 = a2;
      do
      {
        if ( (unsigned int)*(v11 - 6) >= 2 )
        {
          LOBYTE(result) = 0;
          v12 = sub_10064BF0(result, *v11, (int)&v24);
          v13 = *(v11 - 9);
          LOBYTE(v12) = 1;
          v22 = 0;
          sub_10064BF0(v12, v13, (int)&v22);
          v23 = 0;
          v14 = (char **)(v11 - 5);
          v17 = 5;
          do
          {
            switch ( *v14 )
            {
              case 1u:
                v15 = "<bool>";
                goto LABEL_19;
              case 2u:
                v15 = "<char>";
                goto LABEL_19;
              case 3u:
                v15 = "<sint32>";
                goto LABEL_19;
              case 4u:
                v15 = "<uint32>";
                goto LABEL_19;
              case 6u:
                v15 = "<float>";
                goto LABEL_19;
              case 5u:
                v15 = "<str>";
                goto LABEL_19;
              case 0u:
                break;
              default:
                v15 = "<*?*>";
LABEL_19:
                sub_10064BF0(*v14, v15, (int)&v23);
                break;
            }
            ++v14;
            --v17;
          }
          while ( v17 );
          result = (char *)sub_10059AF0(2, (int)v18, 6);
        }
        v11 += 10;
        --v16;
      }
      while ( v16 );
    }
  }
  return result;
}
// 100650B0: using guessed type int var_61C[6];

//----- (10065260) --------------------------------------------------------
int __usercall sub_10065260@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ST08_4@1
  char *v3; // eax@1
  int result; // eax@1
  int (__cdecl *v5)(signed int, void *); // esi@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = sub_10064850((char **)a1);
  result = sub_10059B80(4, (int)v3, v2);
  v5 = *(int (__cdecl **)(signed int, void *))(v1 + 16);
  if ( v5 )
    result = v5(4, &unk_10144898);
  return result;
}

//----- (10065290) --------------------------------------------------------
int __usercall sub_10065290@<eax>(int a1@<esi>)
{
  void (__cdecl *v1)(signed int, void *); // eax@1
  char v2; // al@3

  v1 = *(void (__cdecl **)(signed int, void *))(a1 + 16);
  if ( v1 )
    v1(7, &unk_10144898);
  v2 = (unsigned int)sub_10064850((char **)a1);
  return sub_10059B60(10, v2);
}

//----- (100652C0) --------------------------------------------------------
void __cdecl sub_100652C0(int (**a1)(void), char **a2, _DWORD *a3)
{
  int v3; // esi@3
  int (**v4)(void); // ebx@4
  char **v5; // eax@6
  char *v6; // ST1C_4@6
  char *v7; // eax@6
  char *v8; // eax@7
  char *v9; // eax@9
  char *v10; // eax@10
  int v11; // ebp@12
  signed int v12; // ebx@12
  const char *v13; // eax@14
  char *v14; // ST18_4@14
  int v15; // ST14_4@14
  char *v16; // eax@14
  int v17; // ecx@18
  unsigned int v18; // eax@18
  int v19; // eax@20
  int v20; // ecx@20
  char v21; // dl@20
  int v22; // ST14_4@30
  char *v23; // ST10_4@30
  const char *v24; // eax@31
  char *v25; // ST18_4@31
  int v26; // ST14_4@31
  char *v27; // ST10_4@31
  int v28; // edx@34
  int v29; // ecx@34
  int v30; // eax@34
  int v31; // ST14_4@37
  char *v32; // eax@37
  int v33; // eax@38
  int v34; // ST14_4@39
  char *v35; // ST10_4@39
  int v36; // ST14_4@41
  char *v37; // eax@41
  int v38; // eax@42
  int v39; // ST14_4@43
  char *v40; // eax@43
  int v41; // ST14_4@45
  char *v42; // eax@45
  int v43; // ST14_4@48
  char *v44; // eax@48
  int v45; // edx@49
  int v46; // ST14_4@50
  char *v47; // ST10_4@50
  char *v48; // eax@54
  unsigned int v49; // [sp+4h] [bp-8h]@12
  unsigned int v50; // [sp+8h] [bp-4h]@15
  int v51; // [sp+10h] [bp+4h]@16

  if ( a1 )
  {
    if ( *a1 )
    {
      v3 = (*a1)();
      if ( !a2 )
      {
        v4 = a1 + 1;
        if ( a1 != (int (**)(void))-4 )
        {
          do
          {
            if ( !*v4 )
              break;
            v5 = (char **)(*v4)();
            v6 = sub_10064850(v5);
            v7 = sub_10064850((char **)v3);
            if ( !sub_100648E0(v7, (int)v6) )
            {
              v8 = sub_10064850((char **)v3);
              sub_10059C20(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"2872",
                (int)v8,
                (int)"Suite name has been used more than once");
              *a3 = 12;
            }
            ++v4;
          }
          while ( v4 );
        }
      }
      v9 = sub_10064850((char **)v3);
      if ( strchr(v9, 32) )
      {
        v10 = sub_10064850((char **)v3);
        sub_10059C20(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"2903",
          (int)v10,
          (int)"Suite name includes spaces so it must be quoted");
        *a3 = 10;
      }
      if ( *(_DWORD *)(v3 + 12) )
      {
        v11 = 0;
        v49 = 1;
        v12 = 20;
        while ( 1 )
        {
          if ( strchr(*(const char **)(*(_DWORD *)(v3 + 8) + v11), 32) )
          {
            v13 = sub_10064D90(*(_DWORD *)(*(_DWORD *)(v3 + 8) + v11 + 12));
            v14 = sub_10054B60("%s name includes spaces so it must be quoted", v13);
            v15 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
            v16 = sub_10064850((char **)v3);
            sub_10059C60(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_runner.c", (int)"2915", (int)v16, v15, (int)v14);
            *a3 = 10;
          }
          v50 = v49;
          if ( v49 < *(_DWORD *)(v3 + 12) )
          {
            v51 = v11 + 40;
            do
            {
              if ( !sub_100648E0(*(_BYTE **)(*(_DWORD *)(v3 + 8) + v11), *(_DWORD *)(v51 + *(_DWORD *)(v3 + 8))) )
              {
                v17 = *(_DWORD *)(v3 + 8);
                v18 = *(_DWORD *)(v17 + v11 + 12);
                if ( v18 < 2 || *(_DWORD *)(v51 + v17 + 12) < 2u )
                {
                  v24 = sub_10064D90(v18);
                  v25 = sub_10054B60("%s name has been used more than once", v24);
                  v26 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
                  v27 = sub_10064850((char **)v3);
                  sub_10059C60(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2958",
                    (int)v27,
                    v26,
                    (int)v25);
                }
                else
                {
                  v19 = *(_DWORD *)(v3 + 8);
                  v20 = *(_DWORD *)(v51 + v17 + 16);
                  v21 = 0;
                  if ( *(_DWORD *)(v12 + v19 - 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 8) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 12) != v20 || v21 )
                    goto LABEL_33;
                  v22 = *(_DWORD *)(v19 + v11);
                  v23 = sub_10064850((char **)v3);
                  sub_10059C60(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2946",
                    (int)v23,
                    v22,
                    (int)"Command name has been used more than once");
                }
                *a3 = 12;
              }
LABEL_33:
              v51 += 40;
              ++v50;
            }
            while ( v50 < *(_DWORD *)(v3 + 12) );
          }
          v28 = *(_DWORD *)(v3 + 8);
          v29 = *(_DWORD *)(v28 + v11 + 12);
          v30 = v28 + v11;
          if ( !v29 )
            break;
          if ( v29 == 1 )
          {
            if ( !*(_DWORD *)(v30 + 8) )
            {
              v36 = *(_DWORD *)v30;
              v37 = sub_10064850((char **)v3);
              sub_10059C60(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3047",
                (int)v37,
                v36,
                (int)"Test group has a NULL function pointer or a command uses a reserved ID");
              *a3 = 12;
            }
            v38 = *(_DWORD *)(v3 + 8) + v11;
            if ( *(_DWORD *)(v38 + 4) )
            {
              v39 = *(_DWORD *)v38;
              v40 = sub_10064850((char **)v3);
              sub_10059C60(
                3,
                (int)"**Warning**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3058",
                (int)v40,
                v39,
                (int)"Test group has a non-NULL test case function pointer");
              *a3 = 10;
            }
            if ( a2 )
            {
              v41 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
              v42 = sub_10064850((char **)v3);
              sub_10059C60(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3070",
                (int)v42,
                v41,
                (int)"Test group contains a test group");
              *a3 = 12;
            }
            else
            {
              sub_100652C0(*(_DWORD *)(v3 + 8) + v11 + 8, v3, a3);
            }
            goto LABEL_52;
          }
          if ( *(_DWORD *)(v30 + 4) )
          {
            v31 = *(_DWORD *)v30;
            v32 = sub_10064850((char **)v3);
            sub_10059C60(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3088",
              (int)v32,
              v31,
              (int)"Command include a non-NULL test case function pointer");
            *a3 = 10;
          }
          v33 = *(_DWORD *)(v3 + 8) + v11;
          if ( *(_DWORD *)(v33 + 8) )
          {
            v34 = *(_DWORD *)v33;
            v35 = sub_10064850((char **)v3);
            sub_10059C60(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3099",
              (int)v35,
              v34,
              (int)"Command include a non-NULL test group function pointer");
LABEL_51:
            *a3 = 10;
          }
LABEL_52:
          ++v49;
          v12 += 40;
          v11 += 40;
          if ( v49 - 1 >= *(_DWORD *)(v3 + 12) )
            return;
        }
        if ( !*(_DWORD *)(v30 + 4) )
        {
          v43 = *(_DWORD *)v30;
          v44 = sub_10064850((char **)v3);
          sub_10059C60(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"3022",
            (int)v44,
            v43,
            (int)"Test case has a NULL function pointer or a command uses a reserved ID");
          *a3 = 12;
        }
        v45 = *(_DWORD *)(v3 + 8);
        if ( !*(_DWORD *)(v45 + v11 + 8) )
          goto LABEL_52;
        v46 = *(_DWORD *)(v45 + v11);
        v47 = sub_10064850((char **)v3);
        sub_10059C60(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"3033",
          (int)v47,
          v46,
          (int)"Test case has a non-NULL group function pointer");
        goto LABEL_51;
      }
    }
    else
    {
      v48 = sub_10064850(a2);
      sub_10059C20(
        3,
        (int)"**Error**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"3114",
        (int)v48,
        (int)"Test suite has a NULL function pointer or a command uses a reserved ID");
      *a3 = 12;
    }
  }
}

//----- (10065730) --------------------------------------------------------
int sub_10065730()
{
  int (**i)(void); // esi@1
  int v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  for ( i = (int (**)(void))dword_102F5778[sub_100648A0()]; i; ++i )
  {
    if ( !*i )
      break;
    sub_100652C0(i, 0, &v2);
  }
  return v2;
}
// 102F5778: using guessed type int dword_102F5778[];

//----- (10065780) --------------------------------------------------------
void *sub_10065780()
{
  void *result; // eax@1
  signed int v1; // esi@1

  dword_102F5778[0] = 0;
  dword_102F577C = 0;
  dword_102F5780 = 0;
  dword_102F5784 = 0;
  dword_102F5788 = 0;
  result = &unk_102F57A0;
  dword_102F578C[0] = -1;
  dword_102F5790 = -1;
  dword_102F5794 = -1;
  dword_102F5798 = -1;
  dword_102F579C = -1;
  v1 = 5;
  do
  {
    result = (void *)(sub_10065070((int)result) + 56);
    --v1;
  }
  while ( v1 );
  return result;
}
// 102F5778: using guessed type int dword_102F5778[];
// 102F577C: using guessed type int dword_102F577C;
// 102F5780: using guessed type int dword_102F5780;
// 102F5784: using guessed type int dword_102F5784;
// 102F5788: using guessed type int dword_102F5788;
// 102F578C: using guessed type int dword_102F578C[];
// 102F5790: using guessed type int dword_102F5790;
// 102F5794: using guessed type int dword_102F5794;
// 102F5798: using guessed type int dword_102F5798;
// 102F579C: using guessed type int dword_102F579C;

//----- (100657E0) --------------------------------------------------------
char *sub_100657E0()
{
  return (char *)&unk_102F57A0 + 56 * sub_100648A0();
}

//----- (10065800) --------------------------------------------------------
char sub_10065800()
{
  return sub_100657E0()[33];
}

//----- (10065810) --------------------------------------------------------
char __cdecl sub_10065810(int a1, int a2, unsigned int a3)
{
  char *v3; // esi@1
  char result; // al@1

  v3 = sub_100657E0();
  result = a1 - 6;
  if ( a1 == 6 )
  {
    *(_DWORD *)v3 = 0;
  }
  else
  {
    result = a1 - 7;
    if ( a1 == 7 )
    {
      result = sub_100596E0(a2, a3);
      if ( result )
        ++*(_DWORD *)v3;
    }
  }
  return result;
}

//----- (10065850) --------------------------------------------------------
int *__usercall sub_10065850@<eax>(_DWORD *a1@<ebx>, int a2)
{
  int *v2; // edi@1
  unsigned int v3; // ebp@1
  int **v4; // esi@1

  v2 = 0;
  v3 = 0;
  v4 = (int **)(sub_100657E0() + 36);
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 && !sub_10064950((_BYTE *)(a2 + 80 * *a1), **v4) )
    {
      v2 = *v4;
      ++*a1;
    }
    ++v3;
    ++v4;
  }
  while ( !v2 );
  return v2;
}

//----- (100658A0) --------------------------------------------------------
char **sub_100658A0()
{
  return &off_10144C48;
}
// 10144C48: using guessed type char *off_10144C48;

//----- (100658B0) --------------------------------------------------------
int __cdecl sub_100658B0(_DWORD *a1, int a2, int a3)
{
  char *v3; // esi@1
  int result; // eax@2
  unsigned int v5; // ebp@7
  int v6; // [sp+8h] [bp-8h]@0
  int v7; // [sp+8h] [bp-8h]@7
  int v8; // [sp+Ch] [bp-4h]@8

  sub_10058DD0();
  v3 = sub_100657E0();
  if ( v3[34] )
  {
    result = v6;
  }
  else
  {
    result = sub_10065730();
    if ( result != 12 )
      v3[34] = 1;
  }
  if ( v3[34] )
  {
    sub_10065260(a2);
    if ( a3 )
    {
      v7 = sub_10064FD0(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), a3);
    }
    else
    {
      v5 = 0;
      v7 = 0;
      if ( *(_DWORD *)(a2 + 12) )
      {
        v8 = 0;
        do
        {
          v7 += sub_10064FD0(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), v8 + *(_DWORD *)(a2 + 8));
          v8 += 40;
          ++v5;
        }
        while ( v5 < *(_DWORD *)(a2 + 12) );
        sub_10065290(a2);
        return v7;
      }
    }
    sub_10065290(a2);
    result = v7;
  }
  return result;
}

//----- (10065960) --------------------------------------------------------
int __cdecl sub_10065960(int a1, int a2, int a3, const char *a4, const char *a5)
{
  int v5; // ebp@1
  unsigned int v6; // eax@1
  char *v7; // ecx@1
  int result; // eax@3
  int v9; // eax@5
  char *v10; // eax@7
  char *v11; // eax@7
  char *v12; // eax@7
  char *v13; // eax@7
  char *v14; // eax@7
  char **v15; // eax@7
  char **v16; // esi@7
  char *v17; // eax@7
  char *v18; // eax@7
  char *v19; // eax@7
  char *v20; // eax@7
  char *v21; // eax@8
  char *v22; // eax@9
  const char *v23; // edi@9
  char *v24; // eax@11
  int v25; // [sp+8h] [bp-41Ch]@4
  int v26[4]; // [sp+10h] [bp-414h]@2
  char v27; // [sp+20h] [bp-404h]@1
  char v28; // [sp+120h] [bp-304h]@7
  char v29; // [sp+220h] [bp-204h]@7
  char v30; // [sp+320h] [bp-104h]@11

  v5 = a1;
  v6 = 0;
  v7 = &v27;
  do
  {
    v26[v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( v6 < 4 );
  result = a2;
  if ( a2 )
  {
    v25 = a2;
    do
    {
      v9 = *(_DWORD *)(v5 + 12);
      if ( v9 )
      {
        result = v9 - 1;
        if ( !result )
        {
          v10 = sub_10064BF0(0, "group", (int)&v27);
          LOBYTE(v10) = 0;
          v11 = sub_10064BF0(v10, a4, (int)&v28);
          LOBYTE(v11) = 0;
          sub_10064BF0(v11, *(const char **)v5, (int)&v29);
          v12 = (char *)sub_10059AF0(2, (int)v26, 3);
          LOBYTE(v12) = 0;
          v13 = sub_10064BF0(v12, "group", (int)&v27);
          LOBYTE(v13) = 0;
          v14 = sub_10064BF0(v13, a4, (int)&v28);
          LOBYTE(v14) = 0;
          sub_10064BF0(v14, "group-begin", (int)&v29);
          sub_10059AF0(2, (int)v26, 3);
          v15 = (char **)(*(int (**)(void))(v5 + 8))();
          v16 = v15;
          v17 = sub_10064850(v15);
          sub_10065960(v16[2], v16[3], v16[4], v17, a4);
          sub_10064850(v16);
          v18 = sub_100650B0((int)v16[2], v16[3], (int)v16[4], a4);
          LOBYTE(v18) = 0;
          v19 = sub_10064BF0(v18, "group", (int)&v27);
          LOBYTE(v19) = 0;
          v20 = sub_10064BF0(v19, a4, (int)&v28);
          LOBYTE(v20) = 0;
          sub_10064BF0(v20, "group-end", (int)&v29);
          result = sub_10059AF0(2, (int)v26, 3);
        }
      }
      else
      {
        v21 = sub_10064BF0(0, "case", (int)&v27);
        LOBYTE(v21) = 0;
        if ( a5 )
        {
          v22 = sub_10064BF0(v21, a5, (int)&v28);
          v23 = a4;
        }
        else
        {
          v22 = sub_10064BF0(v21, a4, (int)&v28);
          v23 = &byte_100930C0;
        }
        LOBYTE(v22) = 0;
        v24 = sub_10064BF0(v22, v23, (int)&v29);
        LOBYTE(v24) = 0;
        sub_10064BF0(v24, *(const char **)v5, (int)&v30);
        result = sub_10059AF0(2, (int)v26, 4);
      }
      v5 += 40;
      --v25;
    }
    while ( v25 );
  }
  return result;
}
// 10065960: using guessed type int var_414[4];

//----- (10065B70) --------------------------------------------------------
char *__usercall sub_10065B70@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6)
{
  const char *v6; // edi@1
  char *v7; // eax@1
  char *v8; // ecx@1
  char *v9; // eax@3
  char *result; // eax@3
  int v11[2]; // [sp+Ch] [bp-20Ch]@2
  char v12; // [sp+14h] [bp-204h]@1
  char v13; // [sp+114h] [bp-104h]@3

  v6 = a1;
  v7 = 0;
  v8 = &v12;
  do
  {
    v11[(signed int)v7] = (int)v8;
    *v8 = 0;
    ++v7;
    v8 += 256;
  }
  while ( (unsigned int)v7 < 2 );
  LOBYTE(v7) = 0;
  v9 = sub_10064BF0(v7, v6, (int)&v12);
  LOBYTE(v9) = 0;
  result = sub_10064BF0(v9, a2, (int)&v13);
  if ( v13 )
    result = (char *)sub_10059AF0(2, (int)v11, 2);
  if ( a6 )
  {
    sub_10065960(a3, (int)a4, a5, a2, 0);
    result = sub_100650B0(a3, a4, a5, 0);
  }
  return result;
}
// 10065B70: using guessed type int var_20C[2];

//----- (10065C30) --------------------------------------------------------
char *__cdecl sub_10065C30(char a1)
{
  int (**i)(void); // edi@1
  int v2; // esi@3
  char *v3; // ebx@3
  char **v4; // esi@4
  signed int v5; // edi@4
  char *result; // eax@5

  for ( i = (int (**)(void))dword_102F5778[sub_100648A0()]; i; ++i )
  {
    if ( !*i )
      break;
    v2 = (*i)();
    v3 = sub_10064850((char **)v2);
    sub_10065B70("suite", v3, *(_DWORD *)(v2 + 8), *(char **)(v2 + 12), *(_DWORD *)(v2 + 16), a1);
  }
  v4 = (char **)(sub_100657E0() + 36);
  v5 = 5;
  do
  {
    result = *v4;
    if ( *v4 )
    {
      if ( *((_DWORD *)result + 2) )
        result = sub_10065B70(
                   "listener",
                   *(const char **)result,
                   *((_DWORD *)result + 3),
                   *((char **)result + 4),
                   *((_DWORD *)result + 2),
                   a1);
    }
    ++v4;
    --v5;
  }
  while ( v5 );
  return result;
}
// 102F5778: using guessed type int dword_102F5778[];

//----- (10065CD0) --------------------------------------------------------
int *__cdecl sub_10065CD0(_BYTE *a1)
{
  int (**v1)(void); // edi@1
  char **v2; // eax@3
  char **v3; // esi@3
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // ebx@7
  unsigned int v7; // esi@7
  int **v8; // edi@7
  int *result; // eax@8

  v1 = (int (**)(void))dword_102F5778[sub_100648A0()];
  if ( v1 )
  {
    while ( *v1 )
    {
      v2 = (char **)(*v1)();
      v3 = v2;
      v4 = sub_10064850(v2);
      if ( !sub_10064950(a1, (int)v4) )
      {
        v5 = sub_10064850(v3);
        sub_10065B70("suite", v5, (int)v3[2], v3[3], (int)v3[4], 1);
        break;
      }
      ++v1;
      if ( !v1 )
        break;
    }
  }
  v6 = sub_100657E0();
  v7 = 0;
  v8 = (int **)(v6 + 36);
  while ( 1 )
  {
    result = *v8;
    if ( *v8 )
    {
      result = (int *)sub_10064950(a1, *result);
      if ( !result )
        break;
    }
    ++v7;
    ++v8;
    if ( v7 >= 5 )
      return result;
  }
  return (int *)sub_10065B70(
                  "listener",
                  **(const char ***)&v6[4 * v7 + 36],
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 12),
                  *(char **)(*(_DWORD *)&v6[4 * v7 + 36] + 16),
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 8),
                  1);
}
// 102F5778: using guessed type int dword_102F5778[];

//----- (10065D90) --------------------------------------------------------
int __usercall sub_10065D90@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  bool v2; // zf@1
  int result; // eax@1
  signed int v4; // ebp@3
  int v5; // eax@5
  int v6; // eax@8
  int v7; // ecx@14
  int v8; // esi@18
  unsigned int v9; // eax@18
  int v10; // eax@19
  int v11; // edi@25

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 20) == 0;
  result = 12;
  if ( !v2 && !*(_BYTE *)(v1 + 24) )
  {
    v4 = 2;
    if ( !*(_DWORD *)(v1 + 16) )
    {
      *(_DWORD *)(v1 + 16) = sub_10064DB0(++*(_DWORD *)(v1 + 12));
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 4) = 0;
    }
    v5 = *(_DWORD *)(v1 + 16);
    if ( v5 )
    {
      if ( *(_DWORD *)(v1 + 20) == 1 )
      {
        sub_100658B0((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        v6 = sub_10064DB0(++*(_DWORD *)(v1 + 12));
        v2 = *(_DWORD *)(v1 + 28) == 0;
        *(_DWORD *)(v1 + 16) = v6;
        *(_DWORD *)(v1 + 8) = 0;
        if ( !v2 || !v6 )
          *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 28) == 2 )
      {
        sub_100658B0((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 8)
             || (*(_DWORD *)(v1 + 4) = 0, v7 = *(_DWORD *)(v5 + 8), (*(_DWORD *)(v1 + 8) = v7) != 0) )
      {
        if ( !*(_DWORD *)(v1 + 4) )
          sub_10065260(v5);
        sub_10064FD0(
          (_DWORD *)v1,
          *(void (__cdecl **)(signed int, void *))(*(_DWORD *)(v1 + 16) + 16),
          *(_DWORD *)(v1 + 8));
        v8 = *(_DWORD *)(v1 + 16);
        v9 = ++*(_DWORD *)(v1 + 4);
        if ( *(_DWORD *)(v8 + 12) > v9 )
        {
          *(_DWORD *)(v1 + 8) = *(_DWORD *)(v8 + 8) + 40 * v9;
        }
        else
        {
          sub_10065290(v8);
          v10 = sub_10064DB0(++*(_DWORD *)(v1 + 12));
          *(_DWORD *)(v1 + 16) = v10;
          *(_DWORD *)(v1 + 4) = 0;
          *(_DWORD *)(v1 + 8) = 0;
          if ( !v10 || *(_DWORD *)(v1 + 28) )
            *(_BYTE *)(v1 + 24) = 1;
        }
      }
      else
      {
        *(_BYTE *)(v1 + 24) = 1;
        v4 = 12;
      }
    }
    else
    {
      *(_BYTE *)(v1 + 24) = 1;
      v4 = 12;
    }
    if ( *(_BYTE *)(v1 + 24) && v4 == 2 )
    {
      v11 = *(_DWORD *)v1;
      if ( v11 )
        result = v11 + 12;
      else
        result = 0;
    }
    else
    {
      result = v4;
    }
  }
  return result;
}

//----- (10065EF0) --------------------------------------------------------
signed int __usercall sub_10065EF0@<eax>(int a1@<esi>)
{
  signed int v1; // ebp@1
  int (**i)(void); // edi@2
  int v3; // eax@4
  signed int result; // eax@5

  v1 = 0;
  if ( *(_DWORD *)(a1 + 20) )
  {
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(_BYTE *)(a1 + 24) = 0;
      result = 1;
    }
    else
    {
      result = 12;
    }
  }
  else
  {
    for ( i = (int (**)(void))dword_102F5778[sub_100648A0()]; i; ++i )
    {
      if ( !*i )
        break;
      v3 = (*i)();
      v1 += sub_100658B0((_DWORD *)a1, v3, 0);
    }
    result = v1;
  }
  return result;
}
// 102F5778: using guessed type int dword_102F5778[];

//----- (10065F60) --------------------------------------------------------
int __cdecl sub_10065F60(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  int v4; // ebx@3
  int result; // eax@3
  _BYTE *v6; // esi@5
  int v7; // ebx@6
  int v8; // ebx@8
  int v9; // ebx@9
  int (**i)(void); // edi@11
  int v11; // eax@13
  int (__cdecl *v12)(int, int); // eax@14
  int (**v13)(void); // esi@19
  int v14; // eax@21
  int (__cdecl *v15)(int, int); // eax@22

  v2 = 0;
  v3 = sub_100657E0();
  switch ( a1 )
  {
    case 9:
      sub_10059B60(2, (unsigned int)"begin");
      if ( *(_DWORD *)a2 )
      {
        if ( *(_DWORD *)a2 == 5 )
        {
          v6 = (_BYTE *)(a2 + 4);
          if ( sub_10064950((_BYTE *)(a2 + 4), (int)"-v") )
          {
            if ( sub_10064950(v6, (int)"-q") )
            {
              sub_10065CD0(v6);
              v9 = sub_10065730();
              sub_10059B60(2, (unsigned int)"end");
              result = v9;
            }
            else
            {
              sub_10065C30(0);
              v8 = sub_10065730();
              sub_10059B60(2, (unsigned int)"end");
              result = v8;
            }
          }
          else
          {
            sub_10065C30(1);
            v7 = sub_10065730();
            sub_10059B60(2, (unsigned int)"end");
            result = v7;
          }
        }
        else
        {
          sub_10059BE0(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"1719",
            (int)"Unsupported argument type for help command (internal error)");
          sub_10059B60(2, (unsigned int)"end");
          result = 4;
        }
      }
      else
      {
        sub_10065C30(0);
        v4 = sub_10065730();
        sub_10059B60(2, (unsigned int)"end");
        result = v4;
      }
      return result;
    case 2:
      sub_10059B60(0, (unsigned int)"Global reset command");
      for ( i = (int (**)(void))dword_102F5778[sub_100648A0()]; i; ++i )
      {
        if ( !*i )
          break;
        v11 = (*i)();
        if ( v11 )
        {
          v12 = *(int (__cdecl **)(int, int))(v11 + 16);
          if ( v12 )
          {
            if ( v12 != sub_10065F60 )
              v12(2, (int)&unk_10144898);
          }
        }
      }
      sub_10058DD0();
      v3[34] = 0;
      return 0;
    case 3:
      sub_10059B60(1, (unsigned int)"Global clear command");
      v13 = (int (**)(void))dword_102F5778[sub_100648A0()];
      if ( !v13 )
        return v2;
      break;
    case 10:
      if ( !*((_DWORD *)v3 + 5) )
      {
        sub_10059BE0(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1764", (int)"Step mode not enabled");
        goto LABEL_29;
      }
      return sub_10065D90((int)v3);
    case 11:
      if ( v3[24] )
      {
        *((_DWORD *)v3 + 5) = 0;
        v3[24] = 0;
        result = 0;
      }
      else
      {
        sub_10059BE0(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1783", (int)"Step mode is busy");
LABEL_29:
        result = 12;
      }
      return result;
    case 12:
      *((_DWORD *)v3 + 5) = 1;
      return 0;
    case 13:
      *((_DWORD *)v3 + 5) = 2;
      return 0;
    case 8:
      return sub_10065EF0((int)v3);
    case 14:
      exit_1(12);
      return result;
    case 4:
    case 5:
    case 6:
    case 7:
      return v2;
    default:
      sub_10059BE0(
        3,
        (int)"**Warning**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"1820",
        (int)"Unknown/unsupported command (internal error)");
      return 4;
  }
  while ( *v13 )
  {
    v14 = (*v13)();
    if ( v14 )
    {
      v15 = *(int (__cdecl **)(int, int))(v14 + 16);
      if ( v15 )
      {
        if ( v15 != sub_10065F60 )
          v15(3, (int)&unk_10144898);
      }
    }
    ++v13;
    if ( !v13 )
      return 0;
  }
  return v2;
}
// 10065F60: using guessed type int __cdecl sub_10065F60(int, int);
// 102F5778: using guessed type int dword_102F5778[];

//----- (10066240) --------------------------------------------------------
char **sub_10066240()
{
  return off_10144A3C;
}
// 10144A3C: using guessed type char *off_10144A3C[3];

//----- (10066250) --------------------------------------------------------
int __usercall sub_10066250@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int result; // eax@2
  char **v9; // eax@6
  signed int v10; // ebx@6
  int v11; // [sp+0h] [bp-1C0h]@0
  int (__cdecl *v12)(_DWORD, char *); // [sp+14h] [bp-1ACh]@1
  char v13; // [sp+18h] [bp-1A8h]@2

  v12 = a2;
  v6 = sub_10064CE0(a4, a5, a1, v11);
  v7 = v6;
  if ( v6 )
  {
    result = sub_10064DF0(a5, &v13, v6, a3, a6);
    if ( !result )
    {
      if ( v12 )
      {
        result = v12(*(_DWORD *)(v7 + 12), &v13);
      }
      else
      {
        sprintf(a6, "'%s' does not support commands", a3);
        result = 11;
      }
    }
  }
  else
  {
    v9 = sub_10066240();
    v10 = *a5;
    if ( (char *)a4 == v9[2] )
      sprintf(a6, "Invalid or missing test suite, listener, or command: '%s'", a3 + 80 * v10);
    else
      sprintf(a6, "Invalid or mising test case or command: '%s'", a3 + 80 * v10);
    result = 10;
  }
  return result;
}

//----- (10066340) --------------------------------------------------------
int __cdecl sub_10066340(char *a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *v3; // edi@1
  char *v4; // eax@1
  int result; // eax@1
  int v6; // eax@4
  char **v7; // ebx@4
  int v8; // eax@5
  int *v9; // eax@20
  char **v10; // eax@22
  int v11; // [sp+10h] [bp-2DCh]@4
  int v12; // [sp+14h] [bp-2D8h]@1
  char v13[720]; // [sp+18h] [bp-2D4h]@1

  v2 = v1;
  v3 = sub_100657E0();
  *a1 = 0;
  v4 = sub_10054B60("Processing command '%s'", v2);
  sub_10059BE0(3, (int)&unk_1010BA88, (int)"..\\lib\\utf\\utf_runner.c", (int)"1215", (int)v4);
  result = sub_10064E80(v13, &v12, v2, a1);
  if ( result )
  {
    if ( result == 3 )
    {
      if ( *((_DWORD *)v3 + 5) && !v3[24] )
        result = sub_10065D90((int)v3);
    }
    else
    {
      sprintf(a1, "Invalid command: '%s'", v2);
      result = 10;
    }
  }
  else
  {
    if ( !v12 )
      return sub_10065EF0((int)v3);
    v11 = 0;
    v6 = sub_100648A0();
    v7 = sub_10064D30((int (**)(void))dword_102F5778[v6], (int)v13, &v11);
    if ( v7 )
    {
      v8 = sub_10064C50((int)v7, (int)v13, &v11);
      if ( !v8 )
        goto LABEL_30;
      if ( *(_DWORD *)(v8 + 12) == 1 )
      {
        v7 = (char **)(*(int (**)(void))(v8 + 8))();
        v8 = sub_10064C50((int)v7, (int)v13, &v11);
      }
      if ( v8 )
      {
        if ( v11 >= v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_100658B0(v3, (int)v7, v8);
          *((_DWORD *)v3 + 2) = v8;
          *((_DWORD *)v3 + 4) = v7;
          *((_DWORD *)v3 + 3) = 0;
          *((_DWORD *)v3 + 1) = 0;
          *((_DWORD *)v3 + 7) = 2;
          v3[24] = 0;
          result = 1;
        }
        else
        {
          sprintf(a1, "Unsupported argument to test case: '%s'", &v13[80 * v11]);
          result = 9;
        }
      }
      else
      {
LABEL_30:
        if ( v11 == v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_100658B0(v3, (int)v7, v8);
          if ( v3[24] )
          {
            *((_DWORD *)v3 + 2) = v8;
            result = 1;
            *((_DWORD *)v3 + 4) = v7;
            *((_DWORD *)v3 + 3) = 0;
            *((_DWORD *)v3 + 1) = 0;
            *((_DWORD *)v3 + 7) = 1;
            v3[24] = 0;
          }
          else
          {
            result = 12;
          }
        }
        else
        {
          result = sub_10066250(
                     (unsigned int)v7[3],
                     (int (__cdecl *)(_DWORD, char *))v7[4],
                     (int)v13,
                     (int)v7[2],
                     &v11,
                     a1);
        }
      }
    }
    else
    {
      v9 = sub_10065850(&v11, (int)v13);
      if ( v9 )
      {
        result = sub_10066250(v9[4], (int (__cdecl *)(_DWORD, char *))v9[2], (int)v13, v9[3], &v11, a1);
      }
      else
      {
        v10 = sub_10066240();
        result = sub_10066250(
                   (unsigned int)v10[3],
                   (int (__cdecl *)(_DWORD, char *))v10[4],
                   (int)v13,
                   (int)v10[2],
                   &v11,
                   a1);
      }
    }
  }
  return result;
}
// 102F5778: using guessed type int dword_102F5778[];
// 10066340: using guessed type char var_2D4[720];

//----- (10066580) --------------------------------------------------------
int sub_10066580()
{
  int v0; // esi@1
  char *v1; // eax@4
  int result; // eax@4
  char *v3; // eax@5
  char v4; // [sp+4h] [bp-104h]@1

  v4 = 0;
  v0 = sub_10066340(&v4);
  if ( !sub_100657E0()[32] )
    sub_10059B60(11, (unsigned int)"Non-interactive command complete");
  if ( v4 )
  {
    v3 = sub_10054B60("%s %i, %s", "Command status:", v0, &v4);
    sub_10059BE0(3, (int)&unk_1010BA88, (int)"..\\lib\\utf\\utf_runner.c", (int)"773", (int)v3);
    result = v0;
  }
  else
  {
    v1 = sub_10054B60("%s %i", "Command status:", v0);
    sub_10059BE0(3, (int)&unk_1010BA88, (int)"..\\lib\\utf\\utf_runner.c", (int)"767", (int)v1);
    result = v0;
  }
  return result;
}

//----- (10066660) --------------------------------------------------------
int __cdecl sub_10066660(int a1, int a2, char a3)
{
  char **v3; // eax@1

  dword_102F5778[sub_100648A0()] = a1;
  sub_100657E0()[32] = a3;
  sub_10058DD0();
  sub_10073980(a2);
  v3 = sub_100658A0();
  sub_100595D0(v3);
  return sub_10066580();
}
// 102F5778: using guessed type int dword_102F5778[];

//----- (100666B0) --------------------------------------------------------
const char *__cdecl sub_100666B0(int a1, int a2)
{
  const char *result; // eax@3

  if ( a2 <= 0 )
  {
    result = "\x1B[32;40mPASS\x1B[0m";
    if ( !*(_BYTE *)(a1 + 576) )
      result = "PASS";
  }
  else if ( *(_BYTE *)(a1 + 576) )
  {
    result = "\x1B[31;40mFAILED\x1B[0m";
  }
  else
  {
    result = "FAIL";
  }
  return result;
}

//----- (100666F0) --------------------------------------------------------
char __cdecl sub_100666F0(int a1, int *a2, unsigned int a3)
{
  int *v3; // ebx@1
  int v4; // ebp@1
  int v5; // eax@1
  char *v6; // ebp@1
  char *v7; // eax@11
  int v8; // ecx@12
  int v9; // ST44_4@13
  bool v10; // zf@18
  signed int v11; // edx@24
  const char *v12; // eax@32
  _BYTE *v13; // eax@39
  int v14; // eax@44
  bool v15; // sf@44
  char v16; // cl@45
  char *v17; // eax@50
  int v18; // edx@52
  int v19; // edi@53
  unsigned int v20; // eax@53
  const char *v21; // ecx@53
  _DWORD *v22; // edx@53
  int v23; // esi@57
  int v24; // eax@58
  _BYTE *v25; // ecx@58
  _BYTE *v26; // edx@58
  int v27; // eax@60
  _BYTE *v28; // ecx@60
  _BYTE *v29; // edx@60
  _BYTE *v30; // ecx@62
  _BYTE *v31; // edx@62
  signed int v32; // eax@64
  signed int v33; // edi@73
  int v34; // esi@74
  int v35; // ecx@76
  int v36; // edx@82
  int v37; // eax@83
  int *v38; // eax@106
  char *v39; // ebx@106
  char *v40; // edi@109
  char *v41; // esi@112
  char *v42; // eax@114
  int v43; // ST30_4@123
  const char *v44; // eax@142
  const char *v45; // eax@148
  char *v47; // [sp-14h] [bp-340h]@69
  char v48; // [sp+12h] [bp-31Ah]@24
  char v49; // [sp+13h] [bp-319h]@21
  signed int v50; // [sp+18h] [bp-314h]@52
  char *v51; // [sp+18h] [bp-314h]@94
  char *v52; // [sp+1Ch] [bp-310h]@97
  char *v53; // [sp+20h] [bp-30Ch]@103
  char *v54; // [sp+24h] [bp-308h]@45
  char v55[508]; // [sp+28h] [bp-304h]@11
  char v56; // [sp+224h] [bp-108h]@44
  char v57; // [sp+227h] [bp-105h]@11
  char v58; // [sp+228h] [bp-104h]@123
  char v59; // [sp+327h] [bp-5h]@123

  v3 = a2;
  v4 = sub_100648A0();
  LOBYTE(v5) = a1;
  v6 = (char *)&unk_102F58C0 + 580 * v4;
  switch ( a1 )
  {
    case 0:
      LOBYTE(v5) = sub_1005A350((int)v6, 0);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1005A300((int)v6, "Resetting test status\r\n");
      return v5;
    case 1:
      LOBYTE(v5) = sub_10059E70((int)v6);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1005A300((int)v6, "Clearing test status\r\n");
      return v5;
    case 11:
      LOBYTE(v5) = sub_1005A350((int)v6, 0);
      return v5;
    case 4:
      sub_10059CF0((int)v6, *a2);
      if ( v6[577] && !v6[578] )
      {
        v7 = sub_1005A020((char *)a2[1]);
        _snprintf(v55, 0x200u, "Test Suite: %s (%s)\r\n", *a2, v7);
        v57 = 0;
        sub_1005A300((int)v6, v55);
      }
      LOBYTE(v5) = 0;
      v8 = (int)&v6[16 * *(_DWORD *)v6 + 4];
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      *(_DWORD *)(v8 + 8) = 0;
      *(_DWORD *)(v8 + 12) = 0;
      return v5;
    case 5:
      v9 = *a2;
      LOBYTE(v5) = sub_10059CE0((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Group: %s - Begin\r\n\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 6:
      LOBYTE(v5) = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8] = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4] = 0;
      v10 = v6[577] == 0;
      *((_DWORD *)v6 + 143) = 0;
      if ( !v10 && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Case: %s\r\n\r\n", *a2);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1005A300((int)v6, v55);
      }
      return v5;
    case 7:
      v49 = sub_100596E0((int)a2, a3);
      if ( !v49 && !v6[577] )
        goto LABEL_83;
      if ( v6[578] )
        goto LABEL_81;
      v11 = 0;
      v48 = 0;
      if ( a3 > 7 )
        v11 = strlen((const char *)a2[7]);
      if ( a3 > 8 )
        v11 += strlen((const char *)a2[8]);
      if ( a3 > 3 )
        v11 += strlen((const char *)a2[3]);
      if ( v11 > 100 )
        v48 = 1;
      v12 = sub_100666B0((int)v6, (unsigned __int8)v49);
      _snprintf(v55, 0x200u, "%s ", v12);
      v57 = 0;
      sub_1005A300((int)v6, v55);
      if ( a3 > 7 )
      {
        _snprintf(v55, 0x200u, " ACT: %-17s", a2[7]);
        v57 = 0;
        sub_1005A300((int)v6, v55);
        if ( v48 )
          sub_1005A300((int)v6, "\r\n     ");
      }
      if ( a3 > 8 )
      {
        _snprintf(v55, 0x200u, " EXP: %-17s", a2[8]);
        v57 = 0;
        sub_1005A300((int)v6, v55);
        if ( v48 )
          sub_1005A300((int)v6, "\r\n     ");
      }
      if ( a3 > 9 )
      {
        v13 = (_BYTE *)a2[9];
        if ( v13 )
        {
          if ( *v13 )
          {
            if ( memcmp((const void *)a2[9], "0", 2u) )
            {
              _snprintf(v55, 0x200u, " TOL: %-17s", a2[9]);
              v57 = 0;
              sub_1005A300((int)v6, v55);
              if ( v48 )
                sub_1005A300((int)v6, "\r\n     ");
            }
          }
        }
      }
      v14 = _snprintf(v55, 0x1FCu, " %s", a2[3]);
      v15 = v14 < 0;
      v56 = 0;
      if ( v14 > 0 )
      {
        do
        {
          v16 = (char)(&v54)[v14 + 3];
          if ( v16 != 10 && v16 != 13 )
            break;
          LOBYTE((&v54)[4 * --v14 + 13]) = 0;
        }
        while ( v14 > 0 );
        v15 = v14 < 0;
      }
      if ( !v15 )
      {
        v17 = &v55[v14];
        *(_WORD *)v17 = 2573;
        v17[2] = 0;
      }
      sub_1005A300((int)v6, v55);
      if ( a3 <= 0xA )
        goto LABEL_72;
      v18 = 10;
      v50 = 10;
      if ( (signed int)a3 <= 10 )
        goto LABEL_72;
      do
      {
        v19 = v3[v18];
        v20 = 6;
        v21 = "Info: ";
        v22 = (_DWORD *)v3[v18];
        do
        {
          if ( *v22 != *(_DWORD *)v21 )
            goto LABEL_57;
          v20 -= 4;
          v21 += 4;
          ++v22;
        }
        while ( v20 >= 4 );
        if ( !v20 )
          goto LABEL_67;
LABEL_57:
        v23 = *(_BYTE *)v22 - *v21;
        if ( *(_BYTE *)v22 == *v21 )
        {
          v24 = v20 - 1;
          v25 = v21 + 1;
          v26 = (char *)v22 + 1;
          if ( !v24
            || (v23 = *v26 - *v25, *v26 == *v25)
            && ((v27 = v24 - 1, v28 = v25 + 1, v29 = v26 + 1, !v27)
             || (v23 = *v29 - *v28, *v29 == *v28)
             && ((v30 = v28 + 1, v31 = v29 + 1, v27 == 1) || (v23 = *v31 - *v30, *v31 == *v30))) )
          {
            v3 = a2;
LABEL_67:
            v32 = 0;
            goto LABEL_68;
          }
        }
        v3 = a2;
        v32 = 1;
        if ( v23 <= 0 )
          v32 = -1;
LABEL_68:
        if ( v32 )
        {
          _snprintf(v55, 0x200u, "      Post Analysis: %s\r\n", v19);
          v47 = v55;
        }
        else
        {
          _snprintf(v55, 0x200u, "      Compare Info: %s\r\n", v19 + 6);
          v47 = v55;
        }
        v57 = 0;
        sub_1005A300((int)v6, v47);
        v18 = v50++ + 1;
      }
      while ( v50 < (signed int)a3 );
LABEL_72:
      if ( v6[309] )
      {
        v33 = 0;
        if ( *((_DWORD *)v6 + 143) > 0 )
        {
          v34 = (int)(v6 + 336);
          do
          {
            if ( v33 >= 20 )
              break;
            v35 = *(_DWORD *)(v34 - 4);
            if ( *(_DWORD *)(v34 + 4) )
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s - %s\r\n", v33, v35, *(_DWORD *)v34, *(_DWORD *)(v34 + 4));
            else
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s\r\n", v33, v35, *(_DWORD *)v34);
            v57 = 0;
            sub_1005A300((int)v6, v55);
            ++v33;
            v34 += 12;
          }
          while ( v33 < *((_DWORD *)v6 + 143) );
        }
        _snprintf(v55, 0x200u, "      Location: %s:%s\r\n", v3[1], v3[2]);
        v57 = 0;
        sub_1005A300((int)v6, v55);
      }
LABEL_81:
      if ( v49 )
      {
        v36 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v36 + 4];
        v5 = (int)&v6[v36 + 4];
      }
      else
      {
LABEL_83:
        v37 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v37 + 8];
        v5 = (int)&v6[v37 + 8];
      }
      return v5;
    case 9:
      LOBYTE(v5) = sub_10059F50((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "Test Group: %s - End\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 3:
      LOBYTE(v5) = sub_10059A00((const void **)a2, a3);
      if ( !(_BYTE)v5 && !v6[578] )
      {
        if ( v6[577]
          || sub_10059AC0((const void **)a2, a3)
          || (LOBYTE(v5) = sub_10059910((const void **)a2, a3), (_BYTE)v5) )
        {
          if ( a3 <= 8 )
            v51 = &byte_100930C0;
          else
            v51 = (char *)a2[8];
          if ( a3 <= 7 )
            v52 = &byte_100930C0;
          else
            v52 = (char *)a2[7];
          if ( a3 <= 6 )
            v54 = &byte_100930C0;
          else
            v54 = (char *)a2[6];
          if ( a3 <= 5 )
            v53 = &byte_100930C0;
          else
            v53 = (char *)a2[5];
          if ( a3 <= 4 )
          {
            v38 = a2;
            v39 = &byte_100930C0;
          }
          else
          {
            v38 = a2;
            v39 = (char *)a2[4];
          }
          if ( a3 <= 3 )
            v40 = &byte_100930C0;
          else
            v40 = (char *)v38[3];
          if ( a3 )
            v41 = (char *)*v38;
          else
            v41 = &byte_100930C0;
          v10 = sub_100599D0((const void **)a2, a3) == 0;
          v42 = &byte_100930C0;
          if ( v10 )
            v42 = "   ";
          _snprintf(v55, 0x200u, "%s%s %s %s %s %s %s %s\r\n", v42, v41, v40, v39, v53, v54, v52, v51);
          v57 = 0;
          LOBYTE(v5) = (unsigned int)sub_1005A300((int)v6, v55);
        }
      }
      return v5;
    case 2:
      if ( v6[578] )
        return v5;
      if ( sub_10059710((const void **)a2, a3) )
      {
        dword_102F58B8 = 2;
        sub_1005A300((int)v6, (const char *)&word_10146234);
        sub_1005A300((int)v6, "   Command Format:\r\n");
        sub_1005A300(
          (int)v6,
          "       <global-command> [<arguments>]  : Runs the global command with the optional arguments\r\n");
        sub_1005A300(
          (int)v6,
          "                                         Commands may consist of multiple words. Arguments may\r\n");
        sub_1005A300(
          (int)v6,
          "                                         or may not be required and will be either booleans,\r\n");
        sub_1005A300(
          (int)v6,
          "                                         integers (32-bit signed or unsigned), floats, or\r\n");
        sub_1005A300((int)v6, "                                         strings depending upon the command\r\n");
        sub_1005A300((int)v6, "       <suite>                         : Runs all the test cases of the test suite\r\n");
        sub_1005A300(
          (int)v6,
          "       <suite> <case>                  : Runs the specific test case of the test suite\r\n");
        sub_1005A300(
          (int)v6,
          "       <suite> <command> [<arguments>] : Runs the test suite specific command with optional arguments\r\n");
        sub_1005A300((int)v6, (const char *)&word_10146234);
        sub_1005A300((int)v6, "   Notes:\r\n");
        sub_1005A300((int)v6, "       Commands, suite names and test case names are case-insensitive.\r\n");
        sub_1005A300((int)v6, (const char *)&word_10146234);
        sub_1005A300(
          (int)v6,
          "       In the command table below, indentation indicates the command is a sub-command of the unindented\r\n");
        sub_1005A300(
          (int)v6,
          "       command. Each test case and test suite command is shown indented below the test suite. To run\r\n");
        sub_1005A300(
          (int)v6,
          "       a test case or test suite command, you must enter the full command which consists of the both\r\n");
        sub_1005A300((int)v6, "       the suite name and the test case or test suite command.\r\n");
        sub_1005A300((int)v6, (const char *)&word_10146234);
        sub_1005A300(
          (int)v6,
          "       In the command table below, ***global-commands*** is a place-holder to identify the set of\r\n");
        sub_1005A300(
          (int)v6,
          "       global commands and is not a real test suite name. The global commands should be entered\r\n");
        sub_1005A300((int)v6, "       without a test suite name.\r\n");
        sub_1005A300((int)v6, (const char *)&word_10146234);
        sub_1005A300((int)v6, "   Examples:\r\n");
        sub_1005A300(
          (int)v6,
          "       help                            : Displays a brief help message showing all the test suites\r\n");
        sub_1005A300((int)v6, "       help -q                         : Quite help; Equivalent to help\r\n");
        sub_1005A300(
          (int)v6,
          "       help -v                         : Verbose help; Displays all available help information\r\n");
        sub_1005A300(
          (int)v6,
          "       help utf_validate.c             : Displays verbose help for the utf_validate.c test suite\r\n");
        sub_1005A300(
          (int)v6,
          "       all                             : Will run all the test cases of the test suites\r\n");
        sub_1005A300(
          (int)v6,
          "       utf_validate.c                  : Runs all the test cases of the utf_validate.c suite\r\n");
        sub_1005A300(
          (int)v6,
          "       utf_validate.c FAIL ON          : Enables the failing test cases of the utf_validate.c test suite\r\n");
        sub_1005A300(
          (int)v6,
          "       utf_validate.c Failing_Cases    : Runs the failing test case of the utf_validate.c test suite\r\n");
        sub_1005A300((int)v6, (const char *)&word_10146234);
        sub_1005A300((int)v6, "   Command                                 Description\r\n");
        LOBYTE(v5) = (unsigned int)sub_1005A300(
                                     (int)v6,
                                     "   --------------------------------        --------------------------------\r\n");
        return v5;
      }
      if ( sub_100597A0((const void **)a2, a3) )
      {
        LOBYTE(v5) = (unsigned int)sub_1005A300((int)v6, (const char *)&word_10146234);
        return v5;
      }
      if ( sub_10059770((const void **)a2, a3) )
      {
        _snprintf(&v58, 0x100u, "%s %s", a2[3], a2[4]);
        v43 = a2[5];
        v59 = 0;
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s %s\r\n",
          dword_102F58B8,
          &byte_100930C0,
          &v58,
          6 - dword_102F58B8,
          word_1009F07C,
          v43);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1005A300((int)v6, v55);
        return v5;
      }
      if ( sub_100597D0((const void **)a2, a3) )
      {
        LOBYTE(v5) = sub_10059800((int)a2, a3);
        if ( (_BYTE)v5 )
        {
          dword_102F58B8 += 2;
          return v5;
        }
        if ( sub_10059840((int)a2, a3) )
        {
          LOBYTE(v5) = 2;
          if ( dword_102F58B8 < 2 )
            dword_102F58B8 = 0;
          else
            dword_102F58B8 -= 2;
          return v5;
        }
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s group\r\n",
          dword_102F58B8,
          &byte_100930C0,
          a2[2],
          6 - dword_102F58B8,
          word_1009F07C,
          a2[2]);
LABEL_134:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1005A300((int)v6, v55);
        return v5;
      }
      if ( sub_10059740((const void **)a2, a3) )
      {
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s case\r\n",
          dword_102F58B8,
          &byte_100930C0,
          a2[3],
          6 - dword_102F58B8,
          word_1009F07C,
          a2[3]);
        goto LABEL_134;
      }
      if ( sub_100598B0((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s Runs the %s suite\r\n", a2[1], a2[1]);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1005A300((int)v6, v55);
      }
      else if ( sub_10059880((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s A test results listener\r\n", a2[1]);
LABEL_17:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1005A300((int)v6, v55);
      }
      else
      {
        LOBYTE(v5) = (unsigned int)sub_1005A300((int)v6, "Unknown test help event\r\n");
      }
      return v5;
    case 8:
      if ( v6[577] && !v6[578] )
      {
        v44 = sub_100666B0((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        _snprintf(v55, 0x200u, "\r\n   Test Case Results: %s\r\n", v44);
        v57 = 0;
        sub_1005A300((int)v6, v55);
        _snprintf(v55, 0x200u, "      Passed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8]);
        v57 = 0;
        sub_1005A300((int)v6, v55);
        _snprintf(v55, 0x200u, "      Failed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        v57 = 0;
        sub_1005A300((int)v6, v55);
      }
      v5 = (int)&v6[16 * *(_DWORD *)v6];
      if ( *(_DWORD *)(v5 + 4) )
        ++*(_DWORD *)(v5 + 12);
      else
        ++*(_DWORD *)(v5 + 16);
      return v5;
    case 10:
      if ( v6[577] && !v6[578] )
      {
        v45 = sub_100666B0((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        _snprintf(v55, 0x200u, "\r\nTest Suite Results: %s\r\n", v45);
        v57 = 0;
        sub_1005A300((int)v6, v55);
        _snprintf(v55, 0x200u, "   Passed Cases: %4d\r\n", *(_DWORD *)&v6[16 * (*(_DWORD *)v6 + 1)]);
        v57 = 0;
        sub_1005A300((int)v6, v55);
        _snprintf(v55, 0x200u, "   Failed Cases: %4d\r\n\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        v57 = 0;
        sub_1005A300((int)v6, v55);
      }
      LOBYTE(v5) = sub_10059FB0((int)v6, 0);
      return v5;
    case 12:
      LOBYTE(v5) = sub_1005A280((int)v6, 0);
      return v5;
    case 13:
      if ( a3 >= 2 )
      {
        v5 = *((_DWORD *)v6 + 143);
        if ( v5 < 20 )
        {
          *(_DWORD *)&v6[12 * v5 + 332] = *a2;
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143) + 28)] = a2[1];
          v5 = 3 * *((_DWORD *)v6 + 143);
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143))++ + 340] = a2[2];
        }
      }
      return v5;
    case 14:
      --*((_DWORD *)v6 + 143);
      return v5;
    default:
      if ( !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1005A300((int)v6, "Unknown test event\r\n");
      return v5;
  }
}
// 10146234: using guessed type __int16 word_10146234;
// 102F58B8: using guessed type int dword_102F58B8;
// 100666F0: using guessed type char var_304[508];

//----- (100674A0) --------------------------------------------------------
signed int __cdecl sub_100674A0(int a1, int a2)
{
  char *v2; // eax@1

  v2 = (char *)&unk_102F58C0 + 580 * sub_100648A0();
  if ( a1 == 12 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[576] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else if ( a1 == 13 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[577] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else
  {
    if ( a1 != 14 )
      return sub_10059EB0(a1, a2, (int)v2);
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[578] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  return 9;
}

//----- (10067520) --------------------------------------------------------
char **__cdecl sub_10067520(int a1)
{
  char *v1; // eax@1

  v1 = (char *)&unk_102F58C0 + 580 * sub_100648A0();
  v1[576] = 1;
  v1[577] = 1;
  v1[578] = 0;
  sub_1005A0C0((int)v1, a1, (int)".txt");
  return &off_10145600;
}
// 10145600: using guessed type char *off_10145600;

//----- (10067560) --------------------------------------------------------
int (__cdecl *__cdecl sub_10067560(const char *a1))(const char *)
{
  int v1; // eax@1

  v1 = sub_100648A0();
  return sub_1005A300((int)&unk_102F6418 + 1812 * v1, a1);
}

//----- (10067580) --------------------------------------------------------
const char *sub_10067580()
{
  return "See version control for test execution date";
}

//----- (10067590) --------------------------------------------------------
__int64 sub_10067590()
{
  return 0i64;
}

//----- (100675A0) --------------------------------------------------------
const char *sub_100675A0()
{
  return "Not Available";
}

//----- (100675B0) --------------------------------------------------------
int __usercall sub_100675B0@<eax>(_BYTE *a1@<edi>, int a2)
{
  char v2; // al@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // cl@3
  _BYTE *v6; // edx@4

  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    v4 = *(_BYTE *)(v3 + a2);
    if ( !v4 )
      break;
    v5 = *a1;
    if ( *a1 )
    {
      v6 = a1;
      while ( v5 != v4 )
      {
        v5 = (v6++)[1];
        if ( !v5 )
          goto LABEL_9;
      }
      v2 = 1;
    }
LABEL_9:
    ++v3;
    if ( v2 )
      return v3 - 1;
  }
  if ( v2 )
    --v3;
  return v3;
}

//----- (10067600) --------------------------------------------------------
signed int __cdecl sub_10067600(int a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100648A0();
  return sub_10059EB0(a1, a2, (int)&unk_102F6418 + 1812 * v2);
}

//----- (10067750) --------------------------------------------------------
int __usercall sub_10067750@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3)
{
  char *v3; // edi@1
  char *v4; // eax@1
  unsigned int v5; // kr00_4@1
  char v6; // cl@1
  char *v7; // eax@4
  char *v8; // eax@4
  char *v9; // eax@5
  unsigned __int8 *v10; // eax@6
  unsigned __int8 *v11; // eax@9
  signed int i; // edi@9
  int result; // eax@11
  int v14; // ecx@11
  unsigned __int8 *v15; // [sp+8h] [bp-10Ch]@9
  unsigned __int8 *v16; // [sp+Ch] [bp-108h]@1
  char v17; // [sp+10h] [bp-104h]@1
  char v18[253]; // [sp+11h] [bp-103h]@3
  char v19; // [sp+10Eh] [bp-6h]@1

  v3 = a1;
  sub_10078300((int)&a2[151 * (*a2 + 1)], (int)sub_10067560, 0);
  *(_QWORD *)&a2[2 * *a2 + 147] = sub_10067590();
  v4 = sub_100737C0("CFG_StyleSheetDir", (int)"/Starteam/GDU1XXX/Verification/Automated_Test_Scripts/Stylesheets/");
  _snprintf(&v17, 0xFFu, v4);
  v19 = 0;
  v5 = strlen(&v17);
  v6 = (char)(&v16)[v5 + 3];
  if ( v6 != 92 && v6 != 47 )
  {
    *(&v17 + v5) = 47;
    v18[v5] = 0;
  }
  sub_10078750((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<?xml version=\"1.0\" encoding=\"Windows-1252\"?>", 0);
  v7 = sub_100737C0("CFG_StyleSheet", (int)"std_output_frmt.xsl");
  _snprintf((char *)&a2[151 * *a2 + 174], 0x200u, "<?xml-stylesheet type=\"text/xsl\" href=\"%s%s\"?>", &v17, v7);
  BYTE3(a2[151 * *a2 + 301]) = 0;
  sub_10078750((int)&a2[151 * *a2 + 151], (unsigned __int8 *)&a2[151 * *a2 + 174], 0);
  sub_10078750((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<!-- saved from url=(0021)http://www.garmin.com -->", 0);
  sub_100786D0((int)&a2[151 * (*a2 + 1)], (int)"TestResults");
  sub_10078560((int)&a2[151 * (*a2 + 1)], (int)"xmlns", (unsigned __int8 *)"http://www.garmin.com/GATE");
  v8 = sub_100737C0("CFG_OutputTestRevision", (int)"False");
  if ( !sub_10064950(v8, (int)"True") )
  {
    v9 = strstr(v3, "$Id: ");
    if ( v9 )
      v10 = (unsigned __int8 *)(v9 + 5);
    else
      v10 = (unsigned __int8 *)v3;
    sub_100787A0((int)&a2[151 * (*a2 + 1)], (int)"Version", v10);
    sub_100787A0((int)&a2[151 * (*a2 + 1)], (int)"ResultVersion", (unsigned __int8 *)"$Id$");
  }
  sub_100786D0((int)&a2[151 * (*a2 + 1)], (int)"Config");
  sub_100786D0((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
  sub_100787A0((int)&a2[151 * (*a2 + 1)], (int)"Name", (unsigned __int8 *)"CFG_TestFile");
  v11 = (unsigned __int8 *)sub_1005A020(v3);
  sub_100787A0((int)&a2[151 * (*a2 + 1)], (int)"Value", v11);
  sub_10078650((int)&a2[151 * (*a2 + 1)]);
  for ( i = 0; sub_10073780(i, &v15, &v16); ++i )
  {
    sub_100786D0((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
    sub_100787A0((int)&a2[151 * (*a2 + 1)], (int)"Name", v15);
    sub_100787A0((int)&a2[151 * (*a2 + 1)], (int)"Value", v16);
    sub_10078650((int)&a2[151 * (*a2 + 1)]);
  }
  sub_10078650((int)&a2[151 * (*a2 + 1)]);
  sub_100786D0((int)&a2[151 * (*a2 + 1)], (int)"TestProcedure");
  sub_10078560((int)&a2[151 * (*a2 + 1)], (int)"name", (unsigned __int8 *)a3);
  result = 0;
  v14 = (int)&a2[4 * *a2 + 1];
  *(_DWORD *)v14 = 0;
  *(_DWORD *)(v14 + 4) = 0;
  *(_DWORD *)(v14 + 8) = 0;
  *(_DWORD *)(v14 + 12) = 0;
  return result;
}
// 10067750: using guessed type char var_103[253];

//----- (10067AD0) --------------------------------------------------------
char __cdecl sub_10067AD0(int a1, const void **a2, unsigned int a3)
{
  int v3; // ebp@1
  int v4; // eax@1
  char *v5; // ebp@1
  const char *v6; // ebx@3
  int v7; // esi@4
  int v8; // ST14_4@5
  int v9; // eax@12
  const char *v10; // eax@13
  const char *v11; // eax@15
  int v12; // ST14_4@17
  int v13; // ecx@29
  const void *v14; // ST24_4@43
  int v15; // ST04_4@44
  _BYTE *v16; // eax@87
  _BYTE *v17; // eax@94
  _BYTE *v18; // eax@100
  int v19; // ST20_4@104
  unsigned int v20; // esi@105
  _DWORD *v21; // edx@106
  unsigned int v22; // eax@106
  const char *v23; // ecx@106
  int v24; // esi@110
  int v25; // eax@111
  _BYTE *v26; // ecx@111
  _BYTE *v27; // edx@111
  int v28; // eax@113
  _BYTE *v29; // ecx@113
  _BYTE *v30; // edx@113
  _BYTE *v31; // ecx@115
  _BYTE *v32; // edx@115
  bool v33; // zf@117
  bool v34; // sf@117
  signed int v35; // eax@117
  const char *v36; // eax@129
  const char *v37; // eax@131
  const char *v39; // [sp-10h] [bp-124h]@73
  unsigned __int8 *v40; // [sp-Ch] [bp-120h]@73
  char v41; // [sp+9h] [bp-10Bh]@46
  char v42; // [sp+Ah] [bp-10Ah]@46
  char v43; // [sp+Bh] [bp-109h]@46
  char *v44; // [sp+Ch] [bp-108h]@91
  signed int v45; // [sp+Ch] [bp-108h]@105
  char v46[255]; // [sp+10h] [bp-104h]@5
  char v47; // [sp+10Fh] [bp-5h]@44

  v3 = sub_100648A0();
  LOBYTE(v4) = a1;
  v5 = (char *)&unk_102F6418 + 1812 * v3;
  switch ( a1 )
  {
    case 3:
      if ( sub_10059A60(a2, a3) )
      {
        v6 = (const char *)a2[3];
        do
        {
          v4 = sub_100675B0(", \t", (int)v6);
          v7 = v4;
          if ( v4 )
          {
            strncpy(v46, v6, v4);
            v8 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
            v46[v7] = 0;
            sub_100786D0(v8, (int)"Req");
            sub_10078560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"id", (unsigned __int8 *)v46);
            LOBYTE(v4) = (unsigned int)sub_10078650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
            v6 += v7;
          }
          else
          {
            ++v6;
          }
        }
        while ( *v6 );
      }
      else if ( sub_10059A30(a2, a3) )
      {
        if ( sub_1005A1C0((int)v5, 3, 1, 0) )
          sub_10078650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        v9 = *((_DWORD *)v5 + 146);
        if ( v9 > 0 )
        {
          *((_DWORD *)v5 + 146) = v9 - 1;
          sub_100786D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
          v10 = "true";
          if ( *((_DWORD *)v5 + 144) <= 0 )
            v10 = "false";
          sub_10078560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v10);
          v11 = "true";
          if ( *((_DWORD *)v5 + 145) <= 0 )
            v11 = "false";
          sub_10078560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v11);
          sub_10078650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          v12 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          *((_DWORD *)v5 + 144) = 0;
          *((_DWORD *)v5 + 145) = 0;
          sub_10078650(v12);
          sub_100786D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        }
        LOBYTE(v4) = (unsigned int)sub_10078560(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"title",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_10059970(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_100787A0(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"Method",
                                     (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 146);
      }
      else if ( sub_10059A90(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_100787A0(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"TestType",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_10059A00(a2, a3) )
      {
        if ( sub_1005A1C0((int)v5, 3, 1, 0) )
          sub_10078650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_1005A130((int)a2, a3, (int)v5);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = sub_100786D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      }
      else if ( sub_100599A0(a2, a3) )
      {
        sub_100786D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Results");
        v13 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        if ( *(_BYTE *)a2[3] == 48 )
        {
          sub_10078560(v13, (int)"success", (unsigned __int8 *)"0");
          sub_10078560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"error_msg", (unsigned __int8 *)a2[3] + 1);
        }
        else
        {
          sub_10078560(v13, (int)"success", (unsigned __int8 *)&unk_100ED048);
        }
        if ( v5[309] )
        {
          sub_10078560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
          sub_10078560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
        }
        sub_10078650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_1005A1C0((int)v5, 3, 0, 0);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = (unsigned int)sub_10078650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      else
      {
        LOBYTE(v4) = sub_10059940(a2, a3);
        if ( (_BYTE)v4 )
        {
          if ( !sub_1005A270((int)v5) )
            sub_100786D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
          sub_100787A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
          LOBYTE(v4) = sub_1005A1C0((int)v5, 3, 0, 1);
          if ( (_BYTE)v4 )
            LOBYTE(v4) = (unsigned int)sub_10078650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      return v4;
    case 4:
      LOBYTE(v4) = sub_10059CF0((int)v5, (int)*a2);
      if ( (_BYTE)v4 )
        LOBYTE(v4) = sub_10067750((char *)a2[1], v5, (int)*a2);
      return v4;
    case 5:
      v14 = *a2;
      LOBYTE(v4) = sub_10059CE0((int)v5);
      if ( !(_BYTE)v4 )
      {
        sub_100786D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        _snprintf(v46, 0x100u, "Test Group: %s", *a2);
        v15 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        v47 = 0;
        sub_100787A0(v15, (int)"Method", (unsigned __int8 *)v46);
        LOBYTE(v4) = (unsigned int)sub_10078650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      return v4;
    case 6:
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      LOBYTE(v4) = sub_100786D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
      return v4;
    case 7:
      v41 = 0;
      v42 = 0;
      v43 = 0;
      if ( a3 <= 6 )
        goto LABEL_56;
      if ( !memcmp(a2[6], "bool", 5u) || !memcmp(a2[6], "char", 5u) || !memcmp(a2[6], "string", 7u) )
      {
        v42 = 1;
        goto LABEL_56;
      }
      if ( !memcmp(a2[6], "bitmap", 7u) || !memcmp(a2[6], "bitmap-lenient", 0xFu) )
        goto LABEL_55;
      if ( !memcmp(a2[6], "bitmap-strict", 0xEu) )
      {
        v43 = 1;
LABEL_55:
        v41 = 1;
      }
LABEL_56:
      if ( !*((_DWORD *)v5 + 146) )
      {
        sub_100787A0(
          (int)&v5[604 * (*(_DWORD *)v5 + 1)],
          (int)"Method",
          (unsigned __int8 *)"Method Placeholder -- Add UTF_grp to test case");
        sub_100787A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestType", (unsigned __int8 *)"Low Level Testing");
        ++*((_DWORD *)v5 + 146);
      }
      if ( !sub_1005A270((int)v5) )
        sub_100786D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      if ( sub_100598E0((int)a2, a3) )
      {
        if ( *(_BYTE *)a2[3] )
        {
          sub_100786D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction");
          sub_10078600((int)&v5[604 * (*(_DWORD *)v5 + 1)], (unsigned __int8 *)a2[3]);
          sub_10078650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
        ++*((_DWORD *)v5 + 145);
      }
      else
      {
        if ( *(_BYTE *)a2[3] )
          sub_100787A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 144);
      }
      sub_100786D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Compare");
      if ( sub_100596E0((int)a2, a3) )
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 4];
        sub_10078560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Fail");
      }
      else
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 8];
        sub_10078560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Pass");
      }
      sub_10078560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"type", (unsigned __int8 *)*a2);
      sub_10078560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"class", (unsigned __int8 *)a2[5]);
      if ( a3 <= 6 )
        goto LABEL_77;
      if ( v41 )
      {
        sub_10078560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"datatype", (unsigned __int8 *)"bitmap");
        if ( !v43 )
        {
          sub_10078560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"strict", (unsigned __int8 *)"false");
          goto LABEL_77;
        }
        v40 = (unsigned __int8 *)"true";
        v39 = "strict";
      }
      else
      {
        v40 = (unsigned __int8 *)a2[6];
        v39 = "datatype";
      }
      sub_10078560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)v39, v40);
LABEL_77:
      if ( v5[309] )
      {
        sub_10078560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
        sub_10078560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
      }
      if ( a3 > 7 )
      {
        sub_100786D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Actual");
        if ( v42 )
          sub_100785B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        else
          sub_10078560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        sub_10078650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      if ( a3 > 8 )
      {
        if ( v42 )
        {
          sub_100786D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Expected");
          sub_100785B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)a2[8]);
          sub_10078650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          if ( a3 > 9 )
          {
            v16 = a2[9];
            if ( v16 )
            {
              if ( *v16 )
              {
                sub_100786D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Tolerance");
                sub_100785B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"tolerance", (unsigned __int8 *)a2[9]);
                sub_10078650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
              }
            }
          }
        }
        else
        {
          if ( v41 )
          {
            v44 = "!";
            if ( memcmp(*a2, &unk_100FF668, 3u) )
              v44 = &byte_100930C0;
            if ( a3 > 9 && (v17 = a2[9]) != 0 && *v17 && memcmp(a2[9], "0", 2u) )
              _snprintf(v46, 0x100u, "%s%s+/-%s", v44, a2[8], a2[9]);
            else
              _snprintf(v46, 0x100u, "%s%s", v44, a2[8]);
          }
          else if ( a3 > 9 && (v18 = a2[9]) != 0 && *v18 )
          {
            _snprintf(v46, 0x100u, "N EQ %s(+/-)%s", a2[8], a2[9]);
          }
          else
          {
            _snprintf(v46, 0x100u, "N %s %s", *a2, a2[8]);
          }
          v19 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          v47 = 0;
          sub_100786D0(v19, (int)"Expected");
          sub_10078560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)v46);
          sub_10078650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      v20 = 10;
      v45 = 10;
      if ( a3 <= 0xA )
        goto LABEL_125;
      break;
    case 8:
      if ( sub_1005A1C0((int)v5, 8, 1, 0) )
        sub_10078650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      sub_100786D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
      v36 = "true";
      if ( *((_DWORD *)v5 + 144) <= 0 )
        v36 = "false";
      sub_10078560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v36);
      v37 = "true";
      if ( *((_DWORD *)v5 + 145) <= 0 )
        v37 = "false";
      sub_10078560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v37);
      sub_10078650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      LOBYTE(v4) = (unsigned int)sub_10078650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      return v4;
    case 9:
      LOBYTE(v4) = sub_10059F50((int)v5);
      return v4;
    case 10:
      LOBYTE(v4) = sub_10059FB0((int)v5, (void (__cdecl *)(int))sub_10067630);
      return v4;
    case 0:
    case 11:
      sub_1005A350((int)v5, (void (__cdecl *)(int))sub_10067630);
      goto LABEL_139;
    case 1:
      sub_10059E70((int)v5);
      goto LABEL_139;
    case 12:
      sub_1005A280((int)v5, (void (__cdecl *)(int))sub_10067630);
LABEL_139:
      LOBYTE(v4) = 0;
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      return v4;
    default:
      return v4;
  }
  do
  {
    v21 = a2[v20];
    v22 = 6;
    v23 = "Info: ";
    do
    {
      if ( *v21 != *(_DWORD *)v23 )
        goto LABEL_110;
      v22 -= 4;
      v23 += 4;
      ++v21;
    }
    while ( v22 >= 4 );
    if ( !v22 )
      goto LABEL_120;
LABEL_110:
    v24 = *(_BYTE *)v21 - *v23;
    if ( *(_BYTE *)v21 == *v23 )
    {
      v25 = v22 - 1;
      v26 = v23 + 1;
      v27 = (char *)v21 + 1;
      if ( !v25
        || (v24 = *v27 - *v26, *v27 == *v26)
        && ((v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, !v28)
         || (v24 = *v30 - *v29, *v30 == *v29)
         && ((v31 = v29 + 1, v32 = v30 + 1, v28 == 1) || (v24 = *v32 - *v31, *v32 == *v31))) )
      {
        v20 = v45;
LABEL_120:
        v35 = 0;
        goto LABEL_121;
      }
    }
    v33 = v24 == 0;
    v34 = v24 < 0;
    v20 = v45;
    v35 = 1;
    if ( v34 || v33 )
      v35 = -1;
LABEL_121:
    if ( v35 )
    {
      sub_100786D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"PostAnalysis");
      sub_10078560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"note", (unsigned __int8 *)a2[v20]);
      sub_10078650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    else
    {
      sub_100786D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"CompareInfo");
      sub_10078560((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"comp_info", (unsigned __int8 *)a2[v20] + 6);
      sub_10078650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    v45 = ++v20;
  }
  while ( v20 < a3 );
LABEL_125:
  sub_10078650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  LOBYTE(v4) = sub_1005A1C0((int)v5, 7, 0, 1);
  if ( (_BYTE)v4 )
    LOBYTE(v4) = (unsigned int)sub_10078650((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  return v4;
}
// 10067630: using guessed type int sub_10067630();
// 10067AD0: using guessed type char var_104[255];

//----- (100688F0) --------------------------------------------------------
char **__cdecl sub_100688F0(int a1)
{
  char *v1; // esi@1
  int v2; // esi@1
  signed int v3; // edi@1

  v1 = (char *)&unk_102F6418 + 1812 * sub_100648A0();
  *((_DWORD *)v1 + 146) = 0;
  sub_1005A0C0((int)v1, a1, (int)".xml");
  v2 = (int)(v1 + 604);
  v3 = 2;
  do
  {
    sub_10078300(v2, (int)sub_10067560, 0);
    v2 += 604;
    --v3;
  }
  while ( v3 );
  return &off_10146390;
}
// 10146390: using guessed type char *off_10146390;

//----- (10068960) --------------------------------------------------------
int __cdecl sub_10068960(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 0x7Fu, 0, 0);
}

//----- (10068980) --------------------------------------------------------
int __cdecl sub_10068980(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10054720(a1, 0, 0x7Fu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100689B0) --------------------------------------------------------
int __cdecl sub_100689B0(unsigned __int8 *a1)
{
  return sub_10054720(a1, 0, 3u, 0, 0);
}

//----- (100689D0) --------------------------------------------------------
__int16 *__cdecl sub_100689D0(char a1, unsigned __int16 a2)
{
  char *v2; // eax@1
  signed int v3; // ecx@1
  unsigned __int8 v4; // bl@3
  char v5; // cl@6
  int v6; // eax@6
  unsigned __int16 *v7; // esi@25
  int v8; // edi@25
  int v9; // eax@29
  unsigned __int16 *v10; // esi@32
  int v11; // edi@32
  int v12; // eax@36
  char v14; // [sp+8h] [bp-224h]@3
  char v15; // [sp+9h] [bp-223h]@3
  unsigned __int8 v16; // [sp+Ah] [bp-222h]@3
  char v17; // [sp+Bh] [bp-221h]@26
  unsigned __int16 v18; // [sp+Ch] [bp-220h]@26
  char v19[4]; // [sp+10h] [bp-21Ch]@3
  char v20; // [sp+14h] [bp-218h]@4
  char v21[20]; // [sp+15h] [bp-217h]@8
  char v22; // [sp+29h] [bp-203h]@9
  __int16 v23; // [sp+2Ch] [bp-200h]@13
  __int16 v24; // [sp+2Eh] [bp-1FEh]@15
  __int16 v25[100]; // [sp+98h] [bp-194h]@3
  __int16 v26[100]; // [sp+160h] [bp-CCh]@3

  v2 = byte_102F8782;
  v3 = 203;
  do
  {
    *((_WORD *)v2 - 1) = a2;
    *v2 = 3;
    v2 += 4;
    --v3;
  }
  while ( v3 );
  v4 = 0;
  v14 = 0;
  v16 = 0;
  v15 = 0;
  memset(v26, 0, 0xC8u);
  memset(v25, 0, 0xC8u);
  v19[0] = 0;
  do
  {
    if ( !sub_10078880(v19[0], &v20) )
      goto LABEL_20;
    if ( v20 )
    {
LABEL_9:
      ++v15;
      if ( v22 )
      {
        if ( v22 == 1 )
        {
          if ( !v23 )
            goto LABEL_20;
          v25[v4] = v23;
LABEL_19:
          ++v4;
          goto LABEL_20;
        }
        if ( v22 != 2 )
          goto LABEL_20;
      }
      else if ( v24 )
      {
        v26[v16++] = v24;
      }
      if ( !v23 )
        goto LABEL_20;
      v25[v4] = v23;
      goto LABEL_19;
    }
    v5 = 0;
    v6 = 0;
    while ( v5 )
    {
      v5 = v21[v6++];
      if ( v5 != *(&byte_100930C0 + v6) )
        goto LABEL_9;
    }
LABEL_20:
    ++v19[0];
  }
  while ( v19[0] < 0x64u );
  if ( v15 )
  {
    if ( !a1 )
    {
      word_102F8780[0] = 6;
      byte_102F8782[0] = 1;
      word_102F8784 = 10;
      byte_102F8786 = 1;
      v14 = 2;
    }
    if ( v4 )
    {
      v7 = (unsigned __int16 *)v25;
      v8 = v4;
      do
      {
        if ( sub_100643C0(*v7, 0, &v17, &v18) == 1 && v17 == a1 && v18 < a2 )
        {
          v9 = 2 * (unsigned __int8)v14;
          word_102F8780[v9] = v18;
          byte_102F8782[v9 * 2] = 1;
          ++v14;
        }
        ++v7;
        --v8;
      }
      while ( v8 );
    }
    if ( v16 )
    {
      v10 = (unsigned __int16 *)v26;
      v11 = v16;
      do
      {
        if ( sub_10064360(*v10, 0, &v17, &v18) == 1 && v17 == a1 && v18 < a2 )
        {
          v12 = 2 * (unsigned __int8)v14;
          word_102F8780[v12] = v18;
          byte_102F8782[v12 * 2] = 1;
          ++v14;
        }
        ++v10;
        --v11;
      }
      while ( v11 );
    }
  }
  return word_102F8780;
}
// 102F8780: using guessed type __int16 word_102F8780[];
// 102F8784: using guessed type __int16 word_102F8784;
// 102F8786: using guessed type char byte_102F8786;
// 100689D0: using guessed type __int16 var_CC[100];
// 100689D0: using guessed type __int16 var_194[100];
// 100689D0: using guessed type char var_217[20];

//----- (10068C40) --------------------------------------------------------
int __cdecl sub_10068C40(unsigned __int8 a1, char a2)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 3u )
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_1014A2B8 + a1);
        break;
      case 0:
        result = (int)*(&off_1014A2C4 + a1);
        break;
      case 1:
        result = (int)*(&off_1014A2D0 + a1);
        break;
      case 2:
        result = (int)*(&off_1014A2DC + a1);
        break;
      case 3:
        result = (int)*(&off_1014A2E8 + a1);
        break;
      case 5:
        result = (int)*(&off_1014A2F4 + a1);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 1014A2B8: using guessed type void *off_1014A2B8;
// 1014A2C4: using guessed type void *off_1014A2C4;
// 1014A2D0: using guessed type void *off_1014A2D0;
// 1014A2DC: using guessed type void *off_1014A2DC;
// 1014A2E8: using guessed type void *off_1014A2E8;
// 1014A2F4: using guessed type void *off_1014A2F4;

//----- (10068CC0) --------------------------------------------------------
int __cdecl sub_10068CC0(unsigned __int8 a1, char a2)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 3u )
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_1014A228 + a1);
        break;
      case 0:
        result = (int)*(&off_1014A234 + a1);
        break;
      case 1:
        result = (int)*(&off_1014A240 + a1);
        break;
      case 2:
        result = (int)*(&off_1014A24C + a1);
        break;
      case 3:
        result = (int)*(&off_1014A258 + a1);
        break;
      case 5:
        result = (int)*(&off_1014A264 + a1);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 1014A228: using guessed type void *off_1014A228;
// 1014A234: using guessed type void *off_1014A234;
// 1014A240: using guessed type void *off_1014A240;
// 1014A24C: using guessed type void *off_1014A24C;
// 1014A258: using guessed type void *off_1014A258;
// 1014A264: using guessed type void *off_1014A264;

//----- (10068D40) --------------------------------------------------------
int __cdecl sub_10068D40(unsigned __int8 a1, char a2)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 3u )
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_1014A300 + a1);
        break;
      case 0:
        result = (int)*(&off_1014A30C + a1);
        break;
      case 1:
        result = (int)*(&off_1014A318 + a1);
        break;
      case 2:
        result = (int)*(&off_1014A324 + a1);
        break;
      case 3:
        result = (int)*(&off_1014A330 + a1);
        break;
      case 5:
        result = (int)*(&off_1014A33C + a1);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 1014A300: using guessed type void *off_1014A300;
// 1014A30C: using guessed type void *off_1014A30C;
// 1014A318: using guessed type void *off_1014A318;
// 1014A324: using guessed type void *off_1014A324;
// 1014A330: using guessed type void *off_1014A330;
// 1014A33C: using guessed type void *off_1014A33C;

//----- (10068DC0) --------------------------------------------------------
void *__cdecl sub_10068DC0(unsigned __int8 a1, char a2)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 3u )
  {
    switch ( a2 )
    {
      case 6:
        result = *(&off_1014A270 + a1);
        break;
      case 0:
        result = *(&off_1014A27C + a1);
        break;
      case 1:
        result = *(&off_1014A288 + a1);
        break;
      case 2:
        result = *(&off_1014A294 + a1);
        break;
      case 3:
        result = *(&off_1014A2A0 + a1);
        break;
      case 5:
        result = &unk_10149604;
        break;
      default:
        return result;
    }
  }
  return result;
}
// 1014A270: using guessed type void *off_1014A270;
// 1014A27C: using guessed type void *off_1014A27C;
// 1014A288: using guessed type void *off_1014A288;
// 1014A294: using guessed type void *off_1014A294;
// 1014A2A0: using guessed type void *off_1014A2A0;

//----- (10068E40) --------------------------------------------------------
int __cdecl sub_10068E40(char a1)
{
  return sub_10043FF0(&a1, 1u, (int)&unk_1014A348, 28, 12, 11);
}

//----- (10068E60) --------------------------------------------------------
int __cdecl sub_10068E60(char a1)
{
  return sub_10043FF0(&a1, 1u, (int)&unk_10149CB8, 16, 11, 11);
}

//----- (10068E80) --------------------------------------------------------
int __cdecl sub_10068E80(char a1)
{
  return sub_10043FF0(&a1, 1u, (int)&unk_10149D68, 64, 19, 19);
}

//----- (10068EA0) --------------------------------------------------------
void *__cdecl sub_10068EA0(char a1, unsigned __int8 a2, char a3)
{
  void *v3; // esi@1
  unsigned __int8 v4; // al@3
  void *result; // eax@4

  v3 = 0;
  if ( a2 >= 3u || (unsigned __int8)a1 > 0x3Fu )
  {
    result = 0;
  }
  else
  {
    v4 = sub_10068E40(a1);
    switch ( a3 )
    {
      case 6:
        result = &unk_101495F0;
        break;
      case 0:
        result = *(&off_1014A34C + a2 + 7 * v4);
        break;
      case 1:
        result = *(&off_1014A358 + a2 + 7 * v4);
        break;
      case 2:
        result = &unk_101495FC;
        break;
      case 3:
        result = &unk_10149600;
        break;
      case 5:
        v3 = &unk_10149604;
        goto LABEL_10;
      default:
LABEL_10:
        result = v3;
        break;
    }
  }
  return result;
}
// 1014A34C: using guessed type void *off_1014A34C;
// 1014A358: using guessed type void *off_1014A358;

//----- (10068F60) --------------------------------------------------------
void *__cdecl sub_10068F60(unsigned __int8 a1, char a2, char a3)
{
  void *v3; // esi@1
  int v4; // eax@3
  void *result; // eax@4

  v3 = 0;
  if ( a1 >= 3u || (unsigned __int8)a2 >= 0xBu )
  {
    result = 0;
  }
  else
  {
    v4 = sub_10068E60(a2);
    switch ( a3 )
    {
      case 6:
        result = *(&off_10149CBC + a1 + 4 * v4);
        break;
      case 0:
        result = &unk_101495F4;
        break;
      case 1:
        result = &unk_101495F8;
        break;
      case 2:
        result = &unk_101495FC;
        break;
      case 3:
        result = &unk_10149600;
        break;
      case 5:
        v3 = &unk_10149604;
        goto LABEL_10;
      default:
LABEL_10:
        result = v3;
        break;
    }
  }
  return result;
}
// 10149CBC: using guessed type void *off_10149CBC;

//----- (10069000) --------------------------------------------------------
void *__cdecl sub_10069000(unsigned __int8 a1, char a2, char a3)
{
  void *v3; // esi@1
  int v4; // eax@3
  void *result; // eax@4

  v3 = 0;
  if ( a1 >= 3u || (unsigned __int8)a2 >= 0x13u )
  {
    result = 0;
  }
  else
  {
    v4 = sub_10068E80(a2);
    switch ( a3 )
    {
      case 6:
        result = *(&off_10149D6C + a1 + 16 * v4);
        break;
      case 0:
        result = *(&off_10149D78 + a1 + 16 * v4);
        break;
      case 1:
        result = *(&off_10149D84 + a1 + 16 * v4);
        break;
      case 2:
        result = *(&off_10149D90 + a1 + 16 * v4);
        break;
      case 3:
        result = *(&off_10149D9C + a1 + 16 * v4);
        break;
      case 5:
        v3 = &unk_10149604;
        goto LABEL_10;
      default:
LABEL_10:
        result = v3;
        break;
    }
  }
  return result;
}
// 10149D6C: using guessed type void *off_10149D6C;
// 10149D78: using guessed type void *off_10149D78;
// 10149D84: using guessed type void *off_10149D84;
// 10149D90: using guessed type void *off_10149D90;
// 10149D9C: using guessed type void *off_10149D9C;

//----- (100690D0) --------------------------------------------------------
char sub_100690D0()
{
  return *(_BYTE *)(dword_10337080 + 33316);
}
// 10337080: using guessed type int dword_10337080;

//----- (100690E0) --------------------------------------------------------
void *__cdecl sub_100690E0(char a1)
{
  void *result; // eax@1

  result = 0;
  switch ( a1 )
  {
    case 6:
      result = &unk_1014A5CC;
      break;
    case 0:
      result = &unk_1014A5D0;
      break;
    case 1:
      result = &unk_1014A5D4;
      break;
    case 2:
      result = &unk_1014A5E0;
      break;
    case 3:
      result = &unk_1014A5DC;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10069130) --------------------------------------------------------
char sub_10069130()
{
  signed int v0; // esi@1
  char result; // al@11

  qmemcpy(dword_102F8AB0, &unk_1014A698, 0x5Cu);
  v0 = 23;
  if ( sub_10063890(0) == 1 )
  {
    dword_102F8B0C = 65569;
    dword_102F8B10 = 65910;
    dword_102F8B14 = 65909;
    dword_102F8B18 = 65912;
    dword_102F8B1C = 65914;
    dword_102F8B20 = 65913;
    dword_102F8B24 = 65578;
    dword_102F8B28 = 65852;
    dword_102F8B2C = 65908;
    dword_102F8B30 = 65898;
    v0 = 33;
  }
  if ( sub_10063890(7u) == 1 || sub_10063890(8u) == 1 )
    dword_102F8AB0[v0++] = 65635;
  if ( sub_10077DA0(0, 4u) || sub_10077DA0(1u, 4u) )
  {
    dword_102F8AB0[v0] = 65951;
    dword_102F8AB4[v0] = 65952;
    dword_102F8AB8[v0] = 65950;
    dword_102F8ABC[v0] = 65949;
    dword_102F8AC0[v0] = 65953;
    v0 += 5;
  }
  if ( sub_10063890(2u) == 1 )
  {
    dword_102F8AB0[v0] = 65906;
    dword_102F8AB4[v0] = 65905;
    dword_102F8AB8[v0] = 65907;
    dword_102F8ABC[v0] = 65912;
    dword_102F8AC0[v0] = 65914;
    dword_102F8AC4[v0] = 65913;
    dword_102F8AC8[v0] = 65578;
    dword_102F8ACC[v0] = 65569;
    dword_102F8AD0[v0] = 65944;
    dword_102F8AD4[v0] = 65945;
    dword_102F8AD8[v0] = 65946;
    dword_102F8ADC[v0] = 65947;
    dword_102F8AE0[v0] = 65954;
    v0 += 13;
  }
  result = sub_10078930(1);
  if ( result )
  {
    dword_102F8AB0[v0] = 65569;
    dword_102F8AB4[v0] = 65944;
    dword_102F8AB8[v0] = 65945;
    dword_102F8ABC[v0] = 65946;
    dword_102F8AC0[v0] = 65947;
    result = 122;
    dword_102F8AC4[v0] = 65954;
    dword_102F8AC8[v0] = 65912;
    dword_102F8ACC[v0] = 65914;
    dword_102F8AD0[v0] = 65913;
    dword_102F8AD4[v0] = 65578;
    v0 += 10;
  }
  LOWORD(dword_102F8AB0[v0]) = 904;
  BYTE2(dword_102F8AB0[v0]) = 3;
  return result;
}
// 102F8AB0: using guessed type int dword_102F8AB0[];
// 102F8AB4: using guessed type int dword_102F8AB4[];
// 102F8AB8: using guessed type int dword_102F8AB8[];
// 102F8ABC: using guessed type int dword_102F8ABC[];
// 102F8AC0: using guessed type int dword_102F8AC0[];
// 102F8AC4: using guessed type int dword_102F8AC4[];
// 102F8AC8: using guessed type int dword_102F8AC8[];
// 102F8ACC: using guessed type int dword_102F8ACC[];
// 102F8AD0: using guessed type int dword_102F8AD0[];
// 102F8AD4: using guessed type int dword_102F8AD4[];
// 102F8AD8: using guessed type int dword_102F8AD8[];
// 102F8ADC: using guessed type int dword_102F8ADC[];
// 102F8AE0: using guessed type int dword_102F8AE0[];
// 102F8B0C: using guessed type int dword_102F8B0C;
// 102F8B10: using guessed type int dword_102F8B10;
// 102F8B14: using guessed type int dword_102F8B14;
// 102F8B18: using guessed type int dword_102F8B18;
// 102F8B1C: using guessed type int dword_102F8B1C;
// 102F8B20: using guessed type int dword_102F8B20;
// 102F8B24: using guessed type int dword_102F8B24;
// 102F8B28: using guessed type int dword_102F8B28;
// 102F8B2C: using guessed type int dword_102F8B2C;
// 102F8B30: using guessed type int dword_102F8B30;

//----- (100693C0) --------------------------------------------------------
int *__cdecl sub_100693C0(char a1)
{
  int *result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = (int *)&unk_1014A5CC;
      break;
    case 0:
      result = (int *)&unk_1014A688;
      break;
    case 1:
      result = (int *)&unk_1014A5D4;
      break;
    case 2:
      sub_10069130();
      result = dword_102F8AB0;
      break;
    case 3:
      result = (int *)&unk_1014A78C;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 102F8AB0: using guessed type int dword_102F8AB0[];

//----- (10069420) --------------------------------------------------------
bool __thiscall sub_10069420(void *this)
{
  return (sub_100460A0(this) & 0x800) == 2048;
}

//----- (10069440) --------------------------------------------------------
void *__cdecl sub_10069440(char a1)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 7 )
  {
    switch ( a1 )
    {
      case 6:
        result = &unk_1014A818;
        break;
      case 0:
        result = &unk_1014A81C;
        break;
      case 1:
        result = &unk_1014A820;
        break;
      case 2:
        result = &unk_1014A874;
        break;
      case 3:
        result = &unk_1014A898;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (100694A0) --------------------------------------------------------
int __cdecl sub_100694A0(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 0x33u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_1014EA7C + a1 + 11 * a2);
        break;
      case 0:
        result = (int)*(&off_1014EA84 + a1 + 11 * a2);
        break;
      case 1:
        result = (int)*(&off_1014EA8C + a1 + 11 * a2);
        break;
      case 2:
        result = (int)*(&off_1014EA94 + a1 + 11 * a2);
        break;
      case 3:
        result = (int)*(&off_1014EA9C + a1 + 11 * a2);
        break;
      default:
        sub_10042930("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 189, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 1014EA7C: using guessed type void *off_1014EA7C;
// 1014EA84: using guessed type void *off_1014EA84;
// 1014EA8C: using guessed type void *off_1014EA8C;
// 1014EA94: using guessed type void *off_1014EA94;
// 1014EA9C: using guessed type void *off_1014EA9C;

//----- (10069570) --------------------------------------------------------
int __cdecl sub_10069570(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  unsigned __int8 v4; // cl@2
  int result; // eax@8
  int v6; // [sp-Ch] [bp-7Ch]@13
  char v7; // [sp-8h] [bp-78h]@13
  char v8; // [sp+8h] [bp-68h]@6

  if ( a1 >= 2u || (v4 = a2, a2 >= 0xAu) || a3 >= 4u )
  {
LABEL_22:
    result = 0;
  }
  else if ( a3 == 1 )
  {
    if ( !a2 )
    {
      _snprintf(&v8, 0x64u, "INVALID CONFIG: anlg_in chnl %d - format %d", 0, 1);
      sub_10042930("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 265, 0, &v8);
      v4 = 0;
    }
    switch ( a4 )
    {
      case 6:
        result = (int)*(&off_1014F340 + a1 + 10 * v4);
        break;
      case 0:
        result = (int)*(&off_1014F348 + a1 + 10 * v4);
        break;
      case 1:
        result = (int)*(&off_1014F350 + a1 + 10 * v4);
        break;
      case 2:
        result = (int)*(&off_1014F358 + a1 + 10 * v4);
        break;
      case 3:
        result = (int)*(&off_1014F360 + a1 + 10 * v4);
        break;
      default:
        v7 = 0;
        v6 = 292;
        goto LABEL_21;
    }
  }
  else
  {
    switch ( a4 )
    {
      case 6:
        result = (int)*(&off_1014F4D0 + a1 + 10 * a3);
        break;
      case 0:
        result = (int)*(&off_1014F4D8 + a1 + 10 * a3);
        break;
      case 1:
        result = (int)*(&off_1014F4E0 + a1 + 10 * a3);
        break;
      case 2:
        result = (int)*(&off_1014F4E8 + a1 + 10 * a3);
        break;
      case 3:
        result = (int)*(&off_1014F4F0 + a1 + 10 * a3);
        break;
      default:
        v7 = 0;
        v6 = 322;
LABEL_21:
        sub_10042930("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", v6, v7, 0);
        goto LABEL_22;
    }
  }
  return result;
}
// 1014F340: using guessed type void *off_1014F340;
// 1014F348: using guessed type void *off_1014F348;
// 1014F350: using guessed type void *off_1014F350;
// 1014F358: using guessed type void *off_1014F358;
// 1014F360: using guessed type void *off_1014F360;
// 1014F4D0: using guessed type void *off_1014F4D0;
// 1014F4D8: using guessed type void *off_1014F4D8;
// 1014F4E0: using guessed type void *off_1014F4E0;
// 1014F4E8: using guessed type void *off_1014F4E8;
// 1014F4F0: using guessed type void *off_1014F4F0;

//----- (10069810) --------------------------------------------------------
int __cdecl sub_10069810(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 0xBu )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_1014F570 + a1 + 10 * a2);
        break;
      case 0:
        result = (int)*(&off_1014F578 + a1 + 10 * a2);
        break;
      case 1:
        result = (int)*(&off_1014F580 + a1 + 10 * a2);
        break;
      case 2:
        result = (int)*(&off_1014F588 + a1 + 10 * a2);
        break;
      case 3:
        result = (int)*(&off_1014F590 + a1 + 10 * a2);
        break;
      default:
        sub_10042930("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 407, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 1014F570: using guessed type void *off_1014F570;
// 1014F578: using guessed type void *off_1014F578;
// 1014F580: using guessed type void *off_1014F580;
// 1014F588: using guessed type void *off_1014F588;
// 1014F590: using guessed type void *off_1014F590;

//----- (100698E0) --------------------------------------------------------
int __cdecl sub_100698E0(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 8u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_1014F72C + a1 + 11 * a2);
        break;
      case 0:
        result = (int)*(&off_1014F734 + a1 + 11 * a2);
        break;
      case 1:
        result = (int)*(&off_1014F73C + a1 + 11 * a2);
        break;
      case 2:
        result = (int)*(&off_1014F744 + a1 + 11 * a2);
        break;
      case 3:
        result = (int)*(&off_1014F74C + a1 + 11 * a2);
        break;
      default:
        sub_10042930("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 606, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 1014F72C: using guessed type void *off_1014F72C;
// 1014F734: using guessed type void *off_1014F734;
// 1014F73C: using guessed type void *off_1014F73C;
// 1014F744: using guessed type void *off_1014F744;
// 1014F74C: using guessed type void *off_1014F74C;

//----- (100699B0) --------------------------------------------------------
int __cdecl sub_100699B0(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 3u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_1014F888 + a1 + 10 * a2);
        break;
      case 0:
        result = (int)*(&off_1014F890 + a1 + 10 * a2);
        break;
      case 1:
        result = (int)*(&off_1014F898 + a1 + 10 * a2);
        break;
      case 2:
        result = (int)*(&off_1014F8A0 + a1 + 10 * a2);
        break;
      case 3:
        result = (int)*(&off_1014F8A8 + a1 + 10 * a2);
        break;
      default:
        sub_10042930("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 689, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 1014F888: using guessed type void *off_1014F888;
// 1014F890: using guessed type void *off_1014F890;
// 1014F898: using guessed type void *off_1014F898;
// 1014F8A0: using guessed type void *off_1014F8A0;
// 1014F8A8: using guessed type void *off_1014F8A8;

//----- (10069A80) --------------------------------------------------------
int __cdecl sub_10069A80(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_1014F900 + a1);
        break;
      case 0:
        result = (int)*(&off_1014F908 + a1);
        break;
      case 1:
        result = (int)*(&off_1014F910 + a1);
        break;
      case 2:
        result = (int)*(&off_1014F918 + a1);
        break;
      case 3:
        result = (int)*(&off_1014F920 + a1);
        break;
      default:
        sub_10042930("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 768, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 1014F900: using guessed type void *off_1014F900;
// 1014F908: using guessed type void *off_1014F908;
// 1014F910: using guessed type void *off_1014F910;
// 1014F918: using guessed type void *off_1014F918;
// 1014F920: using guessed type void *off_1014F920;

//----- (10069B10) --------------------------------------------------------
int __cdecl sub_10069B10(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_1014F928 + a1);
        break;
      case 0:
        result = (int)*(&off_1014F930 + a1);
        break;
      case 1:
        result = (int)*(&off_1014F938 + a1);
        break;
      case 2:
        result = (int)*(&off_1014F940 + a1);
        break;
      case 3:
        result = (int)*(&off_1014F948 + a1);
        break;
      default:
        sub_10042930("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 847, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 1014F928: using guessed type void *off_1014F928;
// 1014F930: using guessed type void *off_1014F930;
// 1014F938: using guessed type void *off_1014F938;
// 1014F940: using guessed type void *off_1014F940;
// 1014F948: using guessed type void *off_1014F948;

//----- (10069BA0) --------------------------------------------------------
int __cdecl sub_10069BA0(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_1014F950 + a1);
        break;
      case 0:
        result = (int)*(&off_1014F958 + a1);
        break;
      case 1:
        result = (int)*(&off_1014F960 + a1);
        break;
      case 2:
        result = (int)*(&off_1014F968 + a1);
        break;
      case 3:
        result = (int)*(&off_1014F970 + a1);
        break;
      default:
        sub_10042930("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 927, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 1014F950: using guessed type void *off_1014F950;
// 1014F958: using guessed type void *off_1014F958;
// 1014F960: using guessed type void *off_1014F960;
// 1014F968: using guessed type void *off_1014F968;
// 1014F970: using guessed type void *off_1014F970;

//----- (10069C30) --------------------------------------------------------
int __cdecl sub_10069C30(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 0x31u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_1014F97C + a1 + 11 * a2);
        break;
      case 0:
        result = (int)*(&off_1014F984 + a1 + 11 * a2);
        break;
      case 1:
        result = (int)*(&off_1014F98C + a1 + 11 * a2);
        break;
      case 2:
        result = (int)*(&off_1014F994 + a1 + 11 * a2);
        break;
      case 3:
        result = (int)*(&off_1014F99C + a1 + 11 * a2);
        break;
      default:
        sub_10042930("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1118, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 1014F97C: using guessed type void *off_1014F97C;
// 1014F984: using guessed type void *off_1014F984;
// 1014F98C: using guessed type void *off_1014F98C;
// 1014F994: using guessed type void *off_1014F994;
// 1014F99C: using guessed type void *off_1014F99C;

//----- (10069D00) --------------------------------------------------------
int __cdecl sub_10069D00(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 0x1Du )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_101501EC + a1 + 11 * a2);
        break;
      case 0:
        result = (int)*(&off_101501F4 + a1 + 11 * a2);
        break;
      case 1:
        result = (int)*(&off_101501FC + a1 + 11 * a2);
        break;
      case 2:
        result = (int)*(&off_10150204 + a1 + 11 * a2);
        break;
      case 3:
        result = (int)*(&off_1015020C + a1 + 11 * a2);
        break;
      default:
        sub_10042930("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1308, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 101501EC: using guessed type void *off_101501EC;
// 101501F4: using guessed type void *off_101501F4;
// 101501FC: using guessed type void *off_101501FC;
// 10150204: using guessed type void *off_10150204;
// 1015020C: using guessed type void *off_1015020C;

//----- (10069DD0) --------------------------------------------------------
int __cdecl sub_10069DD0(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_1015070C + a1);
        break;
      case 0:
        result = (int)*(&off_10150714 + a1);
        break;
      case 1:
        result = (int)*(&off_1015071C + a1);
        break;
      case 2:
        result = (int)*(&off_10150724 + a1);
        break;
      case 3:
        result = (int)*(&off_1015072C + a1);
        break;
      default:
        sub_10042930("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1466, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 1015070C: using guessed type void *off_1015070C;
// 10150714: using guessed type void *off_10150714;
// 1015071C: using guessed type void *off_1015071C;
// 10150724: using guessed type void *off_10150724;
// 1015072C: using guessed type void *off_1015072C;

//----- (10069E60) --------------------------------------------------------
int __cdecl sub_10069E60(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_10150734 + a1);
        break;
      case 0:
        result = (int)*(&off_1015073C + a1);
        break;
      case 1:
        result = (int)*(&off_10150744 + a1);
        break;
      case 2:
        result = (int)*(&off_1015074C + a1);
        break;
      case 3:
        result = (int)*(&off_10150754 + a1);
        break;
      default:
        sub_10042930("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1545, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 10150734: using guessed type void *off_10150734;
// 1015073C: using guessed type void *off_1015073C;
// 10150744: using guessed type void *off_10150744;
// 1015074C: using guessed type void *off_1015074C;
// 10150754: using guessed type void *off_10150754;

//----- (10069EF0) --------------------------------------------------------
int __cdecl sub_10069EF0(int a1, unsigned __int8 a2, char a3)
{
  int result; // eax@3

  if ( a2 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = *(_DWORD *)(a1 + 4 * a2);
        break;
      case 0:
        result = *(_DWORD *)(a1 + 4 * a2 + 8);
        break;
      case 1:
        result = *(_DWORD *)(a1 + 4 * a2 + 16);
        break;
      case 2:
        result = *(_DWORD *)(a1 + 4 * a2 + 24);
        break;
      case 3:
        result = *(_DWORD *)(a1 + 4 * a2 + 32);
        break;
      default:
        sub_10042930("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1627, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}

//----- (10069F90) --------------------------------------------------------
int __cdecl sub_10069F90(unsigned __int8 a1, char a2)
{
  return sub_10069EF0((int)&off_10150784, a1, a2);
}
// 10150784: using guessed type void *off_10150784;

//----- (10069FB0) --------------------------------------------------------
int __cdecl sub_10069FB0(unsigned __int8 a1, char a2)
{
  return sub_10069EF0((int)&off_1015075C, a1, a2);
}
// 1015075C: using guessed type void *off_1015075C;

//----- (10069FD0) --------------------------------------------------------
void *__cdecl sub_10069FD0(char a1)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 7 )
  {
    switch ( a1 )
    {
      case 6:
        result = &unk_10150830;
        break;
      case 0:
        result = &unk_10150834;
        break;
      case 1:
        result = &unk_10150838;
        break;
      case 2:
        result = &unk_101508C0;
        break;
      case 3:
        result = &unk_10150934;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (1006A030) --------------------------------------------------------
int __cdecl sub_1006A030(unsigned __int8 a1, char a2)
{
  int result; // eax@1

  result = 0;
  if ( a2 >= 7 || a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_10150A14 + a1);
        break;
      case 0:
        result = (int)*(&off_10150A1C + a1);
        break;
      case 1:
        result = (int)*(&off_10150A24 + a1);
        break;
      case 2:
        result = (int)*(&off_10150A2C + a1);
        break;
      case 3:
        result = (int)*(&off_10150A34 + a1);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 10150A14: using guessed type void *off_10150A14;
// 10150A1C: using guessed type void *off_10150A1C;
// 10150A24: using guessed type void *off_10150A24;
// 10150A2C: using guessed type void *off_10150A2C;
// 10150A34: using guessed type void *off_10150A34;

//----- (1006A0B0) --------------------------------------------------------
int __cdecl sub_1006A0B0(unsigned __int8 a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 2u )
    result = dword_10150A3C[a1];
  return result;
}
// 10150A3C: using guessed type int dword_10150A3C[];

//----- (1006A0D0) --------------------------------------------------------
int __cdecl sub_1006A0D0(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 3u || a2 >= 0x23u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_10152EC4 + a1 + 16 * a2);
        break;
      case 0:
        result = (int)*(&off_10152ED0 + a1 + 16 * a2);
        break;
      case 1:
        result = (int)*(&off_10152EDC + a1 + 16 * a2);
        break;
      case 2:
        result = (int)*(&off_10152EE8 + a1 + 16 * a2);
        break;
      case 3:
        result = (int)*(&off_10152EF4 + a1 + 16 * a2);
        break;
      default:
        sub_10042930("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 209, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 10152EC4: using guessed type void *off_10152EC4;
// 10152ED0: using guessed type void *off_10152ED0;
// 10152EDC: using guessed type void *off_10152EDC;
// 10152EE8: using guessed type void *off_10152EE8;
// 10152EF4: using guessed type void *off_10152EF4;

//----- (1006A1A0) --------------------------------------------------------
int __cdecl sub_1006A1A0(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 3u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_10152E48 + a1);
        break;
      case 0:
        result = (int)*(&off_10152E54 + a1);
        break;
      case 1:
        result = (int)*(&off_10152E60 + a1);
        break;
      case 2:
        result = (int)*(&off_10152E6C + a1);
        break;
      case 3:
        result = (int)*(&off_10152E78 + a1);
        break;
      default:
        sub_10042930("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 313, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 10152E48: using guessed type void *off_10152E48;
// 10152E54: using guessed type void *off_10152E54;
// 10152E60: using guessed type void *off_10152E60;
// 10152E6C: using guessed type void *off_10152E6C;
// 10152E78: using guessed type void *off_10152E78;

//----- (1006A230) --------------------------------------------------------
int __cdecl sub_1006A230(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 3u || a2 >= 0x21u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_10153784 + a1 + 16 * a2);
        break;
      case 0:
        result = (int)*(&off_10153790 + a1 + 16 * a2);
        break;
      case 1:
        result = (int)*(&off_1015379C + a1 + 16 * a2);
        break;
      case 2:
        result = (int)*(&off_101537A8 + a1 + 16 * a2);
        break;
      case 3:
        result = (int)*(&off_101537B4 + a1 + 16 * a2);
        break;
      default:
        sub_10042930("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 504, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 10153784: using guessed type void *off_10153784;
// 10153790: using guessed type void *off_10153790;
// 1015379C: using guessed type void *off_1015379C;
// 101537A8: using guessed type void *off_101537A8;
// 101537B4: using guessed type void *off_101537B4;

//----- (1006A300) --------------------------------------------------------
int __cdecl sub_1006A300(int a1, unsigned __int8 a2, char a3)
{
  int result; // eax@3

  if ( a2 >= 3u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = *(_DWORD *)(a1 + 4 * a2);
        break;
      case 0:
        result = *(_DWORD *)(a1 + 4 * a2 + 12);
        break;
      case 1:
        result = *(_DWORD *)(a1 + 4 * a2 + 24);
        break;
      case 2:
        result = *(_DWORD *)(a1 + 4 * a2 + 36);
        break;
      case 3:
        result = *(_DWORD *)(a1 + 4 * a2 + 48);
        break;
      default:
        sub_10042930("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 583, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}

//----- (1006A3A0) --------------------------------------------------------
int __cdecl sub_1006A3A0(unsigned __int8 a1, char a2)
{
  return sub_1006A300((int)&off_10152E84, a1, a2);
}
// 10152E84: using guessed type void *off_10152E84;

//----- (1006A3C0) --------------------------------------------------------
char __cdecl sub_1006A3C0(char a1)
{
  char result; // al@4

  switch ( a1 )
  {
    case 25:
      result = 0;
      break;
    case 26:
      result = 1;
      break;
    case 43:
      result = 2;
      break;
    default:
      sub_10042930("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 169, 0, 0);
      result = 3;
      break;
  }
  return result;
}

//----- (1006A400) --------------------------------------------------------
char __cdecl sub_1006A400(char a1)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 26;
    }
    else if ( a1 == 2 )
    {
      result = 43;
    }
    else
    {
      sub_10042930("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 259, 0, 0);
      result = 67;
    }
  }
  else
  {
    result = 25;
  }
  return result;
}

//----- (1006A440) --------------------------------------------------------
signed int __cdecl sub_1006A440(char a1)
{
  signed int result; // eax@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 0x2000;
    }
    else if ( a1 == 2 )
    {
      result = 0x80000;
    }
    else
    {
      sub_10042930("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 317, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = 4096;
  }
  return result;
}

//----- (1006A490) --------------------------------------------------------
void *__cdecl sub_1006A490(char a1)
{
  void *result; // eax@1

  result = 0;
  switch ( a1 )
  {
    case 6:
      result = &unk_101540A8;
      break;
    case 0:
      result = &unk_101540AC;
      break;
    case 1:
      result = &unk_101542B0;
      break;
    case 2:
      result = &unk_101540B4;
      break;
    case 3:
      result = &unk_101540B8;
      break;
    case 5:
      result = &unk_101540BC;
      break;
    default:
      return result;
  }
  return result;
}

//----- (1006A4F0) --------------------------------------------------------
void *__cdecl sub_1006A4F0(char a1)
{
  void *result; // eax@1

  result = 0;
  switch ( a1 )
  {
    case 6:
      result = &unk_101540C0;
      break;
    case 0:
      result = &unk_101540EC;
      break;
    case 1:
      result = &unk_10154110;
      break;
    case 2:
      result = &unk_10154140;
      break;
    case 3:
      result = &unk_101541B8;
      break;
    case 5:
      result = &unk_101540BC;
      break;
    default:
      return result;
  }
  return result;
}

//----- (1006A550) --------------------------------------------------------
void *__cdecl sub_1006A550(char a1)
{
  void *result; // eax@1

  result = 0;
  switch ( a1 )
  {
    case 6:
      result = &unk_101540A8;
      break;
    case 0:
      result = &unk_101542BC;
      break;
    case 1:
      result = &unk_101540B0;
      break;
    case 2:
      result = &unk_101542D0;
      break;
    case 3:
      result = &unk_101540B8;
      break;
    case 5:
      result = &unk_101540BC;
      break;
    default:
      return result;
  }
  return result;
}

//----- (1006A5B0) --------------------------------------------------------
int __cdecl sub_1006A5B0(char a1, char a2)
{
  int result; // eax@1
  char v3; // cl@2

  result = 0;
  switch ( a1 )
  {
    case 3:
      v3 = 0;
      break;
    case 4:
      v3 = 1;
      break;
    case 5:
      v3 = 2;
      break;
    default:
      if ( a1 != 6 )
        return 0;
      v3 = 3;
      break;
  }
  switch ( a2 )
  {
    case 6:
      result = (int)*(&off_101542E0 + (unsigned __int8)v3);
      break;
    case 0:
      result = (int)*(&off_101542F0 + (unsigned __int8)v3);
      break;
    case 1:
      result = (int)*(&off_10154300 + (unsigned __int8)v3);
      break;
    case 2:
      result = (int)*(&off_10154310 + (unsigned __int8)v3);
      break;
    case 3:
      result = (int)*(&off_10154320 + (unsigned __int8)v3);
      break;
    case 5:
      result = (int)*(&off_10154330 + (unsigned __int8)v3);
      break;
    default:
      return result;
  }
  return result;
}
// 101542E0: using guessed type void *off_101542E0;
// 101542F0: using guessed type void *off_101542F0;
// 10154300: using guessed type void *off_10154300;
// 10154310: using guessed type void *off_10154310;
// 10154320: using guessed type void *off_10154320;
// 10154330: using guessed type void *off_10154330;

//----- (1006A650) --------------------------------------------------------
void *__cdecl sub_1006A650(char a1)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 7 )
  {
    switch ( a1 )
    {
      case 6:
        result = &unk_10154340;
        break;
      case 0:
        result = &unk_10154344;
        break;
      case 1:
        result = &unk_10154378;
        break;
      case 2:
        result = &unk_101543A8;
        break;
      case 3:
        result = &unk_101543E8;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (1006A6B0) --------------------------------------------------------
void *__cdecl sub_1006A6B0(char a1)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 7 )
  {
    switch ( a1 )
    {
      case 6:
        result = &unk_10154410;
        break;
      case 0:
        result = &unk_10154414;
        break;
      case 1:
        result = &unk_10154430;
        break;
      case 2:
        result = &unk_10154474;
        break;
      case 3:
        result = &unk_10154488;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (1006A710) --------------------------------------------------------
signed int __usercall sub_1006A710@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // edi@1
  signed int result; // eax@1
  int v5; // esi@1
  unsigned __int16 v6; // bx@2
  unsigned __int16 v7; // ax@2
  unsigned int v8; // ebx@2
  unsigned __int16 v9; // dx@2
  int v10; // edx@2
  int v11; // eax@2
  int v12; // esi@2
  unsigned int v13; // edx@2
  int v14; // eax@2
  int v15; // esi@2
  unsigned int v16; // ST2C_4@4
  unsigned int v17; // ST30_4@4
  unsigned int v18; // ST34_4@4
  unsigned int v19; // esi@4
  unsigned int v20; // ST2C_4@5
  unsigned int v21; // ST30_4@5
  unsigned int v22; // ST34_4@5
  unsigned int v23; // esi@5
  unsigned int v24; // ST30_4@6
  unsigned int v25; // ST34_4@6
  unsigned int v26; // edx@6
  unsigned int v27; // esi@6
  __int16 v28; // ST38_2@6
  unsigned int v29; // ST1C_4@6
  unsigned int v30; // ST20_4@6
  unsigned int v31; // ST24_4@6
  unsigned int v32; // esi@6
  unsigned int v33; // edx@6
  unsigned int v34; // ST30_4@6
  unsigned int v35; // ST34_4@6
  unsigned int v36; // esi@6
  unsigned int v37; // ST1C_4@6
  unsigned int v38; // ST20_4@6
  unsigned int v39; // ST24_4@6
  unsigned int v40; // esi@6
  unsigned int v41; // ST30_4@6
  unsigned int v42; // edx@6
  unsigned int v43; // ST34_4@6
  unsigned int v44; // esi@6
  unsigned int v45; // ST1C_4@6
  unsigned int v46; // ST20_4@6
  unsigned int v47; // ST24_4@6
  unsigned int v48; // esi@6
  unsigned int v49; // edx@6
  unsigned int v50; // ST30_4@6
  unsigned int v51; // ST34_4@6
  unsigned int v52; // esi@6
  unsigned int v53; // ST1C_4@6
  unsigned int v54; // ST20_4@6
  unsigned int v55; // ST24_4@6
  unsigned int v56; // ST28_4@6
  unsigned int v57; // ST30_4@6
  unsigned int v58; // edx@6
  unsigned int v59; // ST34_4@6
  unsigned int v60; // ST38_4@6
  unsigned int v61; // ST20_4@6
  unsigned int v62; // ST24_4@6
  unsigned int v63; // ebx@6
  unsigned int v64; // eax@6
  unsigned int v65; // [sp+14h] [bp-20h]@2
  unsigned int v66; // [sp+18h] [bp-1Ch]@2
  unsigned int v67; // [sp+1Ch] [bp-18h]@2
  unsigned int v68; // [sp+20h] [bp-14h]@2

  v3 = a1;
  result = 0;
  v5 = a2;
  if ( *(_BYTE *)(v3 + 260) & 1 )
  {
    BYTE1(result) = *(_BYTE *)(a2 + 3);
    HIBYTE(v6) = *(_BYTE *)(a2 + 7);
    LOBYTE(result) = *(_BYTE *)(a2 + 2);
    LOBYTE(v6) = *(_BYTE *)(a2 + 6);
    v65 = *(_DWORD *)v3 ^ (*(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (result << 8)) << 8));
    HIBYTE(v7) = *(_BYTE *)(a2 + 11);
    v8 = *(_DWORD *)(v3 + 4) ^ (*(_BYTE *)(a2 + 4) | ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8));
    LOBYTE(v7) = *(_BYTE *)(a2 + 10);
    v66 = v8;
    HIBYTE(v9) = *(_BYTE *)(a2 + 15);
    v67 = *(_DWORD *)(v3 + 8) ^ (*(_BYTE *)(v5 + 8) | ((*(_BYTE *)(v5 + 9) | (v7 << 8)) << 8));
    LOBYTE(v9) = *(_BYTE *)(v5 + 14);
    v10 = *(_BYTE *)(v5 + 13) | (v9 << 8);
    v11 = *(_BYTE *)(v5 + 12);
    v12 = *(_DWORD *)(v3 + 256);
    v13 = *(_DWORD *)(v3 + 12) ^ (v11 | (v10 << 8));
    v14 = v3 + 16 * (v12 - 9);
    v15 = v12 - 12;
    v68 = v13;
    if ( v15 )
    {
      if ( v15 != 2 )
      {
LABEL_6:
        v24 = *(_DWORD *)(v14 + 4) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v66] ^ *(_DWORD *)&dword_101550B0[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v68 >> 16)];
        v25 = *(_DWORD *)(v14 + 8) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v66 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v68)];
        v26 = *(_DWORD *)v14 ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v13 >> 24)];
        v27 = *(_DWORD *)(v14 + 12) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v66 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v67 >> 24)];
        v28 = *(_WORD *)(v14 + 12) ^ dword_101544B0[2 * (unsigned __int8)v68] ^ dword_101548B0[2 * BYTE1(v65)] ^ dword_10154CB0[2 * (unsigned __int8)(v66 >> 16)] ^ dword_101550B0[2 * (v67 >> 24)];
        v29 = *(_DWORD *)(v14 + 16) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v26] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v24)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v25 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v27 >> 24)];
        v30 = *(_DWORD *)(v14 + 20) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v24] ^ *(_DWORD *)&dword_101550B0[2 * (v26 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v25)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v27 >> 16)];
        v31 = *(_DWORD *)(v14 + 24) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v25] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v26 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v24 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * HIBYTE(v28)];
        v32 = *(_DWORD *)(v14 + 28) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v28] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v26)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v24 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v25 >> 24)];
        v33 = *(_DWORD *)(v14 + 32) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v29] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v30)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v31 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v32 >> 24)];
        v34 = *(_DWORD *)(v14 + 36) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v30] ^ *(_DWORD *)&dword_101550B0[2 * (v29 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v31)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v32 >> 16)];
        v35 = *(_DWORD *)(v14 + 40) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v31] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v29 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v30 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v32)];
        v36 = *(_DWORD *)(v14 + 44) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v32] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v29)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v30 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v31 >> 24)];
        v37 = *(_DWORD *)(v14 + 48) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v33] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v34)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v35 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v36 >> 24)];
        v38 = *(_DWORD *)(v14 + 52) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v34] ^ *(_DWORD *)&dword_101550B0[2 * (v33 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v35)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v36 >> 16)];
        v39 = *(_DWORD *)(v14 + 56) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v35] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v33 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v34 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v36)];
        v40 = *(_DWORD *)(v14 + 60) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v36] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v33)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v34 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v35 >> 24)];
        v41 = *(_DWORD *)(v14 + 68) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v38] ^ *(_DWORD *)&dword_101550B0[2 * (v37 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v39)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v40 >> 16)];
        v42 = *(_DWORD *)(v14 + 64) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v37] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v38)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v39 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v40 >> 24)];
        v43 = *(_DWORD *)(v14 + 72) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v39] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v37 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v38 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v40)];
        v44 = *(_DWORD *)(v14 + 76) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v40] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v37)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v38 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v39 >> 24)];
        v45 = *(_DWORD *)(v14 + 80) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v42] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v41)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v43 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v44 >> 24)];
        v46 = *(_DWORD *)(v14 + 84) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v41] ^ *(_DWORD *)&dword_101550B0[2 * (v42 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v43)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v44 >> 16)];
        v47 = *(_DWORD *)(v14 + 88) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v43] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v42 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v41 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v44)];
        v48 = *(_DWORD *)(v14 + 92) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v44] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v42)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v41 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v43 >> 24)];
        v49 = *(_DWORD *)(v14 + 96) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v45] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v46)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v47 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v48 >> 24)];
        v50 = *(_DWORD *)(v14 + 100) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v46] ^ *(_DWORD *)&dword_101550B0[2 * (v45 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v47)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v48 >> 16)];
        v51 = *(_DWORD *)(v14 + 104) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v47] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v45 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v46 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v48)];
        v52 = *(_DWORD *)(v14 + 108) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v48] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v45)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v46 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v47 >> 24)];
        v53 = *(_DWORD *)(v14 + 112) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v49] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v50)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v51 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v52 >> 24)];
        v54 = *(_DWORD *)(v14 + 116) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v50] ^ *(_DWORD *)&dword_101550B0[2 * (v49 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v51)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v52 >> 16)];
        v55 = *(_DWORD *)(v14 + 120) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v51] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v49 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v50 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v52)];
        v56 = *(_DWORD *)(v14 + 124) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v52] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v49)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v50 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v51 >> 24)];
        v57 = *(_DWORD *)(v14 + 132) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v54] ^ *(_DWORD *)&dword_101550B0[2 * (v53 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v55)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v56 >> 16)];
        v58 = *(_DWORD *)(v14 + 128) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v53] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v54)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v55 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v56 >> 24)];
        v59 = *(_DWORD *)(v14 + 136) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v55] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v53 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v54 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v56)];
        v60 = *(_DWORD *)(v14 + 140) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v56] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v53)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v54 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v55 >> 24)];
        v61 = *(_DWORD *)(v14 + 148) ^ dword_101554B0[(unsigned __int8)v57] ^ dword_101560B0[v58 >> 24] ^ dword_101558B0[BYTE1(v59)] ^ dword_10155CB0[(unsigned __int8)(v60 >> 16)];
        v62 = *(_DWORD *)(v14 + 152) ^ dword_101554B0[(unsigned __int8)v59] ^ dword_10155CB0[(unsigned __int8)(v58 >> 16)] ^ dword_101560B0[v57 >> 24] ^ dword_101558B0[BYTE1(v60)];
        v63 = *(_DWORD *)(v14 + 156) ^ dword_101554B0[(unsigned __int8)v60] ^ dword_101558B0[BYTE1(v58)] ^ dword_10155CB0[(unsigned __int8)(v57 >> 16)] ^ dword_101560B0[v59 >> 24];
        v64 = *(_DWORD *)(v14 + 144) ^ dword_101554B0[(unsigned __int8)v58] ^ dword_101558B0[BYTE1(v57)] ^ dword_10155CB0[(unsigned __int8)(v59 >> 16)] ^ dword_101560B0[v60 >> 24];
        *(_BYTE *)(a3 + 1) = BYTE1(v64);
        *(_BYTE *)a3 = v64;
        *(_BYTE *)(a3 + 2) = v64 >> 16;
        *(_BYTE *)(a3 + 3) = BYTE3(v64);
        *(_BYTE *)(a3 + 5) = BYTE1(v61);
        *(_BYTE *)(a3 + 4) = v61;
        *(_BYTE *)(a3 + 7) = BYTE3(v61);
        *(_BYTE *)(a3 + 6) = v61 >> 16;
        *(_BYTE *)(a3 + 9) = BYTE1(v62);
        *(_BYTE *)(a3 + 8) = v62;
        *(_BYTE *)(a3 + 11) = BYTE3(v62);
        *(_BYTE *)(a3 + 10) = v62 >> 16;
        *(_BYTE *)(a3 + 12) = v63;
        *(_BYTE *)(a3 + 13) = BYTE1(v63);
        *(_BYTE *)(a3 + 15) = BYTE3(v63);
        *(_BYTE *)(a3 + 14) = v63 >> 16;
        return 1;
      }
      v16 = *(_DWORD *)(v14 - 64) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v13 >> 24)];
      v17 = *(_DWORD *)(v14 - 60) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_101550B0[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v13 >> 16)];
      v18 = *(_DWORD *)(v14 - 56) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v68)];
      v19 = *(_DWORD *)(v14 - 52) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v13] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v67 >> 24)];
      v8 = *(_DWORD *)(v14 - 44) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v17] ^ *(_DWORD *)&dword_101550B0[2 * (v16 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v18)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v19 >> 16)];
      v67 = *(_DWORD *)(v14 - 40) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v18] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v16 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v17 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v19)];
      v65 = *(_DWORD *)(v14 - 48) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v16] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v17)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v18 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v19 >> 24)];
      v13 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v18 >> 24)];
      v68 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v18 >> 24)];
    }
    v20 = *(_DWORD *)(v14 - 32) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v13 >> 24)];
    v21 = *(_DWORD *)(v14 - 28) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_101550B0[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v68 >> 16)];
    v22 = *(_DWORD *)(v14 - 24) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v68)];
    v23 = *(_DWORD *)(v14 - 20) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v67 >> 24)];
    v8 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_101550B0[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v23 >> 16)];
    v67 = *(_DWORD *)(v14 - 8) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v22] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v20 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v21 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v23)];
    v65 = *(_DWORD *)(v14 - 16) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v20] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v21)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v22 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v23 >> 24)];
    v66 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_101550B0[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v23 >> 16)];
    v13 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v22 >> 24)];
    v68 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_101544B0[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_101548B0[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_10154CB0[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_101550B0[2 * (v22 >> 24)];
    goto LABEL_6;
  }
  return result;
}
// 101554B0: using guessed type int dword_101554B0[];
// 101558B0: using guessed type int dword_101558B0[];
// 10155CB0: using guessed type int dword_10155CB0[];
// 101560B0: using guessed type int dword_101560B0[];

//----- (1006B7C0) --------------------------------------------------------
int __usercall sub_1006B7C0@<eax>(int a1@<esi>, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@3
  bool v6; // zf@4

  result = *(_DWORD *)(a1 + 456);
  v4 = 0;
  if ( a3 )
  {
    do
    {
      if ( result == 16 )
      {
        v5 = 0;
        do
        {
          v6 = (*(_BYTE *)(v5 + a1))++ == -1;
          if ( !v6 )
            break;
          ++v5;
        }
        while ( v5 < 8 );
        sub_1006A710(a1 + 32, a1, a1 + 16);
        result = 0;
      }
      *(_BYTE *)(v4++ + a2) ^= *(_BYTE *)(a1 + 16 + result++);
    }
    while ( v4 < a3 );
  }
  *(_DWORD *)(a1 + 456) = result;
  return result;
}

//----- (1006B820) --------------------------------------------------------
signed int __usercall sub_1006B820@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned __int16 v4; // dx@1
  int v5; // edx@1
  unsigned __int16 v6; // cx@1
  int v7; // esi@1
  int v8; // edi@1
  unsigned int v9; // ecx@1
  unsigned __int16 v10; // dx@2
  int v11; // edx@2
  int v12; // ebx@2
  int v13; // edx@3
  int v14; // ST20_4@3
  int v15; // edx@3
  int v16; // ST24_4@3
  int v17; // edx@3
  int v18; // ST28_4@3
  unsigned int v19; // edx@3
  int v20; // ebp@3
  int v21; // esi@3
  int v22; // edi@3
  unsigned int v23; // ecx@3
  int v24; // ST20_4@3
  int v25; // ebx@3
  unsigned int v26; // edx@3
  int v27; // ST28_4@3
  int v28; // ebp@3
  int v29; // esi@3
  int v30; // edi@3
  unsigned int v31; // ecx@3
  int v32; // ST10_4@3
  int v33; // ebx@3
  int v34; // ebp@3
  unsigned int v35; // edx@3
  int v36; // ST28_4@3
  int v37; // ST24_4@3
  int v38; // ebp@3
  int v39; // esi@3
  int v40; // edi@3
  unsigned int v41; // ecx@3
  int v42; // ebx@3
  unsigned int v43; // edx@3
  int v44; // ebp@3
  int v45; // esi@3
  int v46; // edi@3
  unsigned int v47; // ecx@3
  int v48; // ST10_4@3
  int v49; // ST20_4@3
  int v50; // ebp@3
  int v51; // ebx@3
  unsigned int v52; // edx@3
  int v53; // ST28_4@3
  int v54; // ST24_4@3
  int v55; // ebp@3
  int v56; // esi@3
  int v57; // edi@3
  unsigned int v58; // ecx@3
  int v59; // ebx@3
  unsigned int v60; // edx@3
  int v61; // ST28_4@3
  int v62; // ST24_4@3
  int v63; // ebp@3
  int v64; // esi@3
  int v65; // edi@3
  unsigned int v66; // ecx@3
  int v67; // ST10_4@3
  int v68; // ebx@3
  unsigned int v69; // edx@3
  int v70; // ebp@3
  int v71; // ebp@3
  int v72; // esi@3
  int v73; // edi@3
  signed int result; // eax@3
  int v75; // edx@4
  int v76; // ST20_4@4
  unsigned int v77; // edx@4
  int v78; // ebp@4
  int v79; // esi@4
  int v80; // edi@4
  int v81; // ecx@4
  unsigned int v82; // edx@4
  int v83; // ST20_4@4
  int v84; // ebp@4
  int v85; // esi@4
  int v86; // edi@4
  int v87; // ecx@4
  int v88; // ebx@4
  unsigned int v89; // edx@4
  int v90; // ebp@4
  int v91; // esi@4
  int v92; // edi@4
  int v93; // ecx@4
  unsigned int v94; // edx@4
  int v95; // ST20_4@4
  int v96; // ebp@4
  int v97; // esi@4
  int v98; // edi@4
  int v99; // ecx@4
  unsigned int v100; // edx@4
  int v101; // ST20_4@4
  int v102; // ST10_4@4
  int v103; // ebp@4
  int v104; // esi@4
  int v105; // edi@4
  int v106; // ST10_4@4
  int v107; // ecx@4
  unsigned int v108; // edx@4
  int v109; // ST20_4@4
  int v110; // ebp@4
  int v111; // esi@4
  int v112; // edi@4
  int v113; // ecx@4
  unsigned int v114; // edx@4
  int v115; // ST20_4@4
  int v116; // ebp@4
  int v117; // esi@4
  int v118; // edi@4
  int v119; // ecx@4
  unsigned int v120; // edx@4
  int v121; // ST10_4@4
  int v122; // ebp@4
  int v123; // ebp@4
  int v124; // esi@4
  int v125; // edi@4
  int v126; // ebp@5
  int v127; // esi@5
  int v128; // edi@5
  unsigned int v129; // ecx@5
  int v130; // edx@5
  int v131; // esi@5
  int v132; // edi@5
  unsigned int v133; // ecx@5
  int v134; // ebp@5
  int v135; // esi@5
  int v136; // edi@5
  unsigned int v137; // ecx@5
  int v138; // edx@5
  int v139; // esi@5
  int v140; // edi@5
  unsigned int v141; // ecx@5
  int v142; // ebp@5
  int v143; // esi@5
  int v144; // edi@5
  unsigned int v145; // ecx@5
  int v146; // edx@5
  int v147; // esi@5
  int v148; // edi@5
  unsigned int v149; // ecx@5
  int v150; // ebp@5
  int v151; // esi@5
  int v152; // edi@5
  unsigned int v153; // ecx@5
  int v154; // edx@5
  int v155; // esi@5
  int v156; // edi@5
  unsigned int v157; // ecx@5
  int v158; // ebp@5
  int v159; // esi@5
  int v160; // edi@5
  unsigned int v161; // ecx@5
  int v162; // edx@5
  int v163; // edx@5
  int v164; // esi@5
  int v165; // edi@5
  int v166; // [sp+10h] [bp-20h]@1

  *(_DWORD *)(a1 + 260) = 17;
  v3 = a2;
  HIBYTE(v4) = *(_BYTE *)(a2 + 3);
  LOBYTE(v4) = *(_BYTE *)(a2 + 2);
  v5 = *(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (v4 << 8)) << 8);
  *(_DWORD *)a1 = v5;
  HIBYTE(v6) = *(_BYTE *)(a2 + 7);
  v166 = v5;
  LOBYTE(v6) = *(_BYTE *)(a2 + 6);
  v7 = ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8) | *(_BYTE *)(a2 + 4);
  *(_DWORD *)(a1 + 4) = v7;
  HIBYTE(v6) = *(_BYTE *)(a2 + 11);
  LOBYTE(v6) = *(_BYTE *)(a2 + 10);
  v8 = ((*(_BYTE *)(v3 + 9) | (v6 << 8)) << 8) | *(_BYTE *)(v3 + 8);
  *(_DWORD *)(a1 + 8) = v8;
  HIBYTE(v6) = *(_BYTE *)(a2 + 15);
  LOBYTE(v6) = *(_BYTE *)(a2 + 14);
  v9 = *(_BYTE *)(v3 + 12) | ((*(_BYTE *)(v3 + 13) | (v6 << 8)) << 8);
  *(_DWORD *)(a1 + 12) = v9;
  if ( a3 == 16 )
  {
    v126 = v5 ^ dword_101560B0[(unsigned __int8)v9] ^ dword_101554B0[BYTE1(v9)] ^ dword_101558B0[(unsigned __int8)(v9 >> 16)] ^ dword_10155CB0[v9 >> 24] ^ 1;
    v127 = v126 ^ v7;
    *(_DWORD *)(a1 + 16) = v126;
    *(_DWORD *)(a1 + 20) = v127;
    v128 = v127 ^ v8;
    *(_DWORD *)(a1 + 24) = v128;
    v129 = v128 ^ v9;
    *(_DWORD *)(a1 + 28) = v129;
    v130 = v126 ^ dword_101560B0[(unsigned __int8)v129] ^ dword_101554B0[BYTE1(v129)] ^ dword_101558B0[(unsigned __int8)(v129 >> 16)] ^ dword_10155CB0[v129 >> 24] ^ 2;
    v131 = v130 ^ v127;
    *(_DWORD *)(a1 + 32) = v130;
    *(_DWORD *)(a1 + 36) = v131;
    v132 = v131 ^ v128;
    *(_DWORD *)(a1 + 40) = v132;
    v133 = v132 ^ v129;
    *(_DWORD *)(a1 + 44) = v133;
    v134 = v130 ^ dword_101560B0[(unsigned __int8)v133] ^ dword_101554B0[BYTE1(v133)] ^ dword_101558B0[(unsigned __int8)(v133 >> 16)] ^ dword_10155CB0[v133 >> 24] ^ 4;
    v135 = v134 ^ v131;
    v136 = v135 ^ v132;
    v137 = v136 ^ v133;
    *(_DWORD *)(a1 + 48) = v134;
    *(_DWORD *)(a1 + 52) = v135;
    *(_DWORD *)(a1 + 56) = v136;
    *(_DWORD *)(a1 + 60) = v137;
    v138 = v134 ^ dword_101560B0[(unsigned __int8)v137] ^ dword_101554B0[BYTE1(v137)] ^ dword_101558B0[(unsigned __int8)(v137 >> 16)] ^ dword_10155CB0[v137 >> 24] ^ 8;
    *(_DWORD *)(a1 + 64) = v138;
    v139 = v138 ^ v135;
    *(_DWORD *)(a1 + 68) = v139;
    v140 = v139 ^ v136;
    *(_DWORD *)(a1 + 72) = v140;
    v141 = v140 ^ v137;
    *(_DWORD *)(a1 + 76) = v141;
    v142 = v138 ^ dword_101560B0[(unsigned __int8)v141] ^ dword_101554B0[BYTE1(v141)] ^ dword_101558B0[(unsigned __int8)(v141 >> 16)] ^ dword_10155CB0[v141 >> 24] ^ 0x10;
    v143 = v142 ^ v139;
    v144 = v143 ^ v140;
    v145 = v144 ^ v141;
    *(_DWORD *)(a1 + 80) = v142;
    *(_DWORD *)(a1 + 84) = v143;
    *(_DWORD *)(a1 + 88) = v144;
    *(_DWORD *)(a1 + 92) = v145;
    v146 = v142 ^ dword_101560B0[(unsigned __int8)v145] ^ dword_101554B0[BYTE1(v145)] ^ dword_101558B0[(unsigned __int8)(v145 >> 16)] ^ dword_10155CB0[v145 >> 24] ^ 0x20;
    v147 = v146 ^ v143;
    v148 = v147 ^ v144;
    v149 = v148 ^ v145;
    *(_DWORD *)(a1 + 100) = v147;
    *(_DWORD *)(a1 + 104) = v148;
    *(_DWORD *)(a1 + 108) = v149;
    *(_DWORD *)(a1 + 96) = v146;
    v150 = v146 ^ dword_101560B0[(unsigned __int8)v149] ^ dword_101554B0[BYTE1(v149)] ^ dword_101558B0[(unsigned __int8)(v149 >> 16)] ^ dword_10155CB0[v149 >> 24] ^ 0x40;
    v151 = v150 ^ v147;
    v152 = v151 ^ v148;
    v153 = v152 ^ v149;
    *(_DWORD *)(a1 + 112) = v150;
    *(_DWORD *)(a1 + 116) = v151;
    *(_DWORD *)(a1 + 120) = v152;
    *(_DWORD *)(a1 + 124) = v153;
    v154 = v150 ^ dword_101560B0[(unsigned __int8)v153] ^ dword_101554B0[BYTE1(v153)] ^ dword_101558B0[(unsigned __int8)(v153 >> 16)] ^ dword_10155CB0[v153 >> 24] ^ 0x80;
    v155 = v154 ^ v151;
    *(_DWORD *)(a1 + 128) = v154;
    *(_DWORD *)(a1 + 132) = v155;
    v156 = v155 ^ v152;
    *(_DWORD *)(a1 + 136) = v156;
    v157 = v156 ^ v153;
    *(_DWORD *)(a1 + 140) = v157;
    v158 = v154 ^ dword_101560B0[(unsigned __int8)v157] ^ dword_101554B0[BYTE1(v157)] ^ dword_101558B0[(unsigned __int8)(v157 >> 16)] ^ dword_10155CB0[v157 >> 24] ^ 0x1B;
    v159 = v158 ^ v155;
    v160 = v159 ^ v156;
    v161 = v160 ^ v157;
    *(_DWORD *)(a1 + 148) = v159;
    *(_DWORD *)(a1 + 152) = v160;
    *(_DWORD *)(a1 + 144) = v158;
    *(_DWORD *)(a1 + 156) = v161;
    v162 = dword_101560B0[(unsigned __int8)v161] ^ dword_101554B0[BYTE1(v161)] ^ dword_101558B0[(unsigned __int8)(v161 >> 16)] ^ dword_10155CB0[v161 >> 24];
    *(_DWORD *)(a1 + 256) = 10;
    v163 = v158 ^ v162 ^ 0x36;
    v164 = v163 ^ v159;
    v165 = v164 ^ v160;
    *(_DWORD *)(a1 + 168) = v165;
    *(_DWORD *)(a1 + 164) = v164;
    *(_DWORD *)(a1 + 160) = v163;
    *(_DWORD *)(a1 + 172) = v165 ^ v161;
    result = 1;
  }
  else
  {
    HIBYTE(v10) = *(_BYTE *)(a2 + 19);
    LOBYTE(v10) = *(_BYTE *)(a2 + 18);
    v11 = v10 << 8;
    v12 = *(_BYTE *)(a2 + 17);
    if ( a3 == 24 )
    {
      v75 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v75;
      v76 = v75;
      BYTE1(v75) = *(_BYTE *)(a2 + 23);
      LOBYTE(v75) = *(_BYTE *)(a2 + 22);
      v77 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v75 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v77;
      v78 = v166 ^ dword_101560B0[(unsigned __int8)v77] ^ dword_101554B0[BYTE1(v77)] ^ dword_101558B0[(unsigned __int8)(v77 >> 16)] ^ dword_10155CB0[v77 >> 24] ^ 1;
      v79 = v78 ^ v7;
      v80 = v79 ^ v8;
      v81 = v80 ^ v9;
      *(_DWORD *)(a1 + 40) = v81 ^ v76;
      v82 = v81 ^ v76 ^ v77;
      v83 = v81 ^ v76;
      *(_DWORD *)(a1 + 36) = v81;
      *(_DWORD *)(a1 + 24) = v78;
      *(_DWORD *)(a1 + 28) = v79;
      *(_DWORD *)(a1 + 32) = v80;
      *(_DWORD *)(a1 + 44) = v82;
      v84 = v78 ^ dword_101560B0[(unsigned __int8)v82] ^ dword_101554B0[BYTE1(v82)] ^ dword_101558B0[(unsigned __int8)(v82 >> 16)] ^ dword_10155CB0[v82 >> 24] ^ 2;
      v85 = v84 ^ v79;
      v86 = v85 ^ v80;
      v87 = v86 ^ v81;
      v89 = v87 ^ v83 ^ v82;
      v88 = v87 ^ v83;
      *(_DWORD *)(a1 + 64) = v87 ^ v83;
      *(_DWORD *)(a1 + 48) = v84;
      *(_DWORD *)(a1 + 52) = v85;
      *(_DWORD *)(a1 + 56) = v86;
      *(_DWORD *)(a1 + 60) = v87;
      *(_DWORD *)(a1 + 68) = v89;
      v90 = v84 ^ dword_101560B0[(unsigned __int8)v89] ^ dword_101554B0[BYTE1(v89)] ^ dword_101558B0[(unsigned __int8)(v89 >> 16)] ^ dword_10155CB0[v89 >> 24] ^ 4;
      v91 = v90 ^ v85;
      v92 = v91 ^ v86;
      v93 = v92 ^ v87;
      *(_DWORD *)(a1 + 88) = v93 ^ v88;
      v94 = v93 ^ v88 ^ v89;
      v95 = v93 ^ v88;
      *(_DWORD *)(a1 + 84) = v93;
      *(_DWORD *)(a1 + 72) = v90;
      *(_DWORD *)(a1 + 76) = v91;
      *(_DWORD *)(a1 + 80) = v92;
      *(_DWORD *)(a1 + 92) = v94;
      v96 = v90 ^ dword_101560B0[(unsigned __int8)v94] ^ dword_101554B0[BYTE1(v94)] ^ dword_101558B0[(unsigned __int8)(v94 >> 16)] ^ dword_10155CB0[v94 >> 24] ^ 8;
      v97 = v96 ^ v91;
      v98 = v97 ^ v92;
      v99 = v98 ^ v93;
      *(_DWORD *)(a1 + 112) = v99 ^ v95;
      v100 = v99 ^ v95 ^ v94;
      v101 = v99 ^ v95;
      *(_DWORD *)(a1 + 108) = v99;
      v102 = v96;
      *(_DWORD *)(a1 + 96) = v96;
      *(_DWORD *)(a1 + 100) = v97;
      *(_DWORD *)(a1 + 104) = v98;
      *(_DWORD *)(a1 + 116) = v100;
      v103 = v96 ^ dword_101560B0[(unsigned __int8)v100] ^ dword_101554B0[BYTE1(v100)] ^ dword_101558B0[(unsigned __int8)(v100 >> 16)] ^ dword_10155CB0[v100 >> 24] ^ 0x10;
      v104 = v103 ^ v97;
      v105 = v104 ^ v98;
      v106 = v102 ^ dword_101560B0[(unsigned __int8)v100] ^ dword_101554B0[BYTE1(v100)] ^ dword_101558B0[(unsigned __int8)(v100 >> 16)] ^ dword_10155CB0[v100 >> 24] ^ 0x10;
      *(_DWORD *)(a1 + 120) = v103;
      *(_DWORD *)(a1 + 124) = v104;
      *(_DWORD *)(a1 + 128) = v105;
      v107 = v105 ^ v99;
      *(_DWORD *)(a1 + 136) = v107 ^ v101;
      v108 = v107 ^ v101 ^ v100;
      v109 = v107 ^ v101;
      *(_DWORD *)(a1 + 132) = v107;
      *(_DWORD *)(a1 + 140) = v108;
      v110 = v106 ^ dword_101560B0[(unsigned __int8)v108] ^ dword_101554B0[BYTE1(v108)] ^ dword_101558B0[(unsigned __int8)(v108 >> 16)] ^ dword_10155CB0[v108 >> 24] ^ 0x20;
      v111 = v110 ^ v104;
      v112 = v111 ^ v105;
      v113 = v112 ^ v107;
      *(_DWORD *)(a1 + 160) = v113 ^ v109;
      v114 = v113 ^ v109 ^ v108;
      v115 = v113 ^ v109;
      *(_DWORD *)(a1 + 156) = v113;
      *(_DWORD *)(a1 + 144) = v110;
      *(_DWORD *)(a1 + 148) = v111;
      *(_DWORD *)(a1 + 152) = v112;
      *(_DWORD *)(a1 + 164) = v114;
      v116 = v110 ^ dword_101560B0[(unsigned __int8)v114] ^ dword_101554B0[BYTE1(v114)] ^ dword_101558B0[(unsigned __int8)(v114 >> 16)] ^ dword_10155CB0[v114 >> 24] ^ 0x40;
      v117 = v116 ^ v111;
      v118 = v117 ^ v112;
      v119 = v118 ^ v113;
      v120 = v119 ^ v115 ^ v114;
      *(_DWORD *)(a1 + 180) = v119;
      *(_DWORD *)(a1 + 184) = v119 ^ v115;
      v121 = v116;
      *(_DWORD *)(a1 + 168) = v116;
      *(_DWORD *)(a1 + 172) = v117;
      *(_DWORD *)(a1 + 176) = v118;
      *(_DWORD *)(a1 + 188) = v120;
      v122 = dword_101560B0[(unsigned __int8)v120] ^ dword_101554B0[BYTE1(v120)] ^ dword_101558B0[(unsigned __int8)(v120 >> 16)] ^ dword_10155CB0[v120 >> 24];
      *(_DWORD *)(a1 + 256) = 12;
      v123 = v121 ^ v122 ^ 0x80;
      v124 = v123 ^ v117;
      v125 = v124 ^ v118;
      *(_DWORD *)(a1 + 200) = v125;
      *(_DWORD *)(a1 + 196) = v124;
      *(_DWORD *)(a1 + 192) = v123;
      *(_DWORD *)(a1 + 204) = v125 ^ v119;
      result = 1;
    }
    else
    {
      v13 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v13;
      v14 = v13;
      BYTE1(v13) = *(_BYTE *)(a2 + 23);
      LOBYTE(v13) = *(_BYTE *)(a2 + 22);
      v15 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v13 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v15;
      v16 = v15;
      BYTE1(v15) = *(_BYTE *)(a2 + 27);
      LOBYTE(v15) = *(_BYTE *)(a2 + 26);
      v17 = *(_BYTE *)(a2 + 24) | ((*(_BYTE *)(a2 + 25) | ((unsigned __int16)v15 << 8)) << 8);
      *(_DWORD *)(a1 + 24) = v17;
      v18 = v17;
      BYTE1(v17) = *(_BYTE *)(a2 + 31);
      LOBYTE(v17) = *(_BYTE *)(a2 + 30);
      v19 = *(_BYTE *)(a2 + 28) | ((*(_BYTE *)(a2 + 29) | ((unsigned __int16)v17 << 8)) << 8);
      *(_DWORD *)(a1 + 28) = v19;
      v20 = v166 ^ dword_101560B0[(unsigned __int8)v19] ^ dword_101554B0[BYTE1(v19)] ^ dword_101558B0[(unsigned __int8)(v19 >> 16)] ^ dword_10155CB0[v19 >> 24] ^ 1;
      v21 = v20 ^ v7;
      v22 = v21 ^ v8;
      v23 = v22 ^ v9;
      *(_DWORD *)(a1 + 32) = v20;
      *(_DWORD *)(a1 + 36) = v21;
      *(_DWORD *)(a1 + 40) = v22;
      *(_DWORD *)(a1 + 44) = v23;
      v24 = dword_101554B0[(unsigned __int8)v23] ^ dword_101558B0[BYTE1(v23)] ^ dword_10155CB0[(unsigned __int8)(v23 >> 16)] ^ dword_101560B0[v23 >> 24] ^ v14;
      *(_DWORD *)(a1 + 48) = v24;
      v25 = v24 ^ v16 ^ v18;
      v26 = v25 ^ v19;
      *(_DWORD *)(a1 + 56) = v25;
      v27 = v24 ^ v16 ^ v18;
      *(_DWORD *)(a1 + 52) = v24 ^ v16;
      *(_DWORD *)(a1 + 60) = v26;
      v28 = v20 ^ dword_101560B0[(unsigned __int8)v26] ^ dword_101554B0[BYTE1(v26)] ^ dword_101558B0[(unsigned __int8)(v26 >> 16)] ^ dword_10155CB0[v26 >> 24] ^ 2;
      v29 = v28 ^ v21;
      *(_DWORD *)(a1 + 64) = v28;
      v30 = v29 ^ v22;
      v31 = v30 ^ v23;
      *(_DWORD *)(a1 + 76) = v31;
      v32 = v28;
      *(_DWORD *)(a1 + 68) = v29;
      *(_DWORD *)(a1 + 72) = v30;
      v33 = dword_101554B0[(unsigned __int8)v31] ^ dword_101558B0[BYTE1(v31)] ^ dword_10155CB0[(unsigned __int8)(v31 >> 16)] ^ dword_101560B0[v31 >> 24] ^ v24;
      v34 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 80) = v33;
      *(_DWORD *)(a1 + 88) = v34 ^ v27;
      v35 = v34 ^ v27 ^ v26;
      v36 = v34 ^ v27;
      v37 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 84) = v34;
      *(_DWORD *)(a1 + 92) = v35;
      v38 = v32 ^ dword_101560B0[(unsigned __int8)v35] ^ dword_101554B0[BYTE1(v35)] ^ dword_101558B0[(unsigned __int8)(v35 >> 16)] ^ dword_10155CB0[v35 >> 24] ^ 4;
      v39 = v38 ^ v29;
      *(_DWORD *)(a1 + 96) = v38;
      *(_DWORD *)(a1 + 100) = v39;
      v40 = v39 ^ v30;
      v41 = v40 ^ v31;
      *(_DWORD *)(a1 + 108) = v41;
      *(_DWORD *)(a1 + 104) = v40;
      v42 = dword_101554B0[(unsigned __int8)v41] ^ dword_101558B0[BYTE1(v41)] ^ dword_10155CB0[(unsigned __int8)(v41 >> 16)] ^ dword_101560B0[v41 >> 24] ^ v33;
      *(_DWORD *)(a1 + 112) = v42;
      v43 = v42 ^ v37 ^ v36 ^ v35;
      *(_DWORD *)(a1 + 120) = v42 ^ v37 ^ v36;
      *(_DWORD *)(a1 + 116) = v42 ^ v37;
      *(_DWORD *)(a1 + 124) = v43;
      v44 = v38 ^ dword_101560B0[(unsigned __int8)v43] ^ dword_101554B0[BYTE1(v43)] ^ dword_101558B0[(unsigned __int8)(v43 >> 16)] ^ dword_10155CB0[v43 >> 24] ^ 8;
      v45 = v44 ^ v39;
      v46 = v45 ^ v40;
      v47 = v46 ^ v41;
      *(_DWORD *)(a1 + 128) = v44;
      *(_DWORD *)(a1 + 132) = v45;
      *(_DWORD *)(a1 + 136) = v46;
      *(_DWORD *)(a1 + 140) = v47;
      v48 = v44;
      v49 = dword_101554B0[(unsigned __int8)v47] ^ dword_101558B0[BYTE1(v47)] ^ dword_10155CB0[(unsigned __int8)(v47 >> 16)] ^ dword_101560B0[v47 >> 24] ^ v42;
      *(_DWORD *)(a1 + 144) = v49;
      v50 = v49 ^ v42 ^ v37;
      v51 = v50 ^ v42 ^ v37 ^ v36;
      v52 = v51 ^ v43;
      *(_DWORD *)(a1 + 152) = v51;
      v53 = v51;
      *(_DWORD *)(a1 + 148) = v50;
      v54 = v50;
      *(_DWORD *)(a1 + 156) = v52;
      v55 = v48 ^ dword_101560B0[(unsigned __int8)v52] ^ dword_101554B0[BYTE1(v52)] ^ dword_101558B0[(unsigned __int8)(v52 >> 16)] ^ dword_10155CB0[v52 >> 24] ^ 0x10;
      v56 = v55 ^ v45;
      *(_DWORD *)(a1 + 160) = v55;
      v57 = v56 ^ v46;
      v58 = v57 ^ v47;
      *(_DWORD *)(a1 + 172) = v58;
      *(_DWORD *)(a1 + 164) = v56;
      *(_DWORD *)(a1 + 168) = v57;
      v59 = dword_101554B0[(unsigned __int8)v58] ^ dword_101558B0[BYTE1(v58)] ^ dword_10155CB0[(unsigned __int8)(v58 >> 16)] ^ dword_101560B0[v58 >> 24] ^ v49;
      *(_DWORD *)(a1 + 176) = v59;
      *(_DWORD *)(a1 + 184) = v59 ^ v54 ^ v53;
      v60 = v59 ^ v54 ^ v53 ^ v52;
      v61 = v59 ^ v54 ^ v53;
      v62 = v59 ^ v54;
      *(_DWORD *)(a1 + 180) = v62;
      *(_DWORD *)(a1 + 188) = v60;
      v63 = v55 ^ dword_101560B0[(unsigned __int8)v60] ^ dword_101554B0[BYTE1(v60)] ^ dword_101558B0[(unsigned __int8)(v60 >> 16)] ^ dword_10155CB0[v60 >> 24] ^ 0x20;
      v64 = v63 ^ v56;
      *(_DWORD *)(a1 + 192) = v63;
      v65 = v64 ^ v57;
      v66 = v65 ^ v58;
      *(_DWORD *)(a1 + 204) = v66;
      v67 = v63;
      *(_DWORD *)(a1 + 196) = v64;
      *(_DWORD *)(a1 + 200) = v65;
      v68 = dword_101554B0[(unsigned __int8)v66] ^ dword_101558B0[BYTE1(v66)] ^ dword_10155CB0[(unsigned __int8)(v66 >> 16)] ^ dword_101560B0[v66 >> 24] ^ v59;
      *(_DWORD *)(a1 + 208) = v68;
      *(_DWORD *)(a1 + 216) = v68 ^ v62 ^ v61;
      v69 = v68 ^ v62 ^ v61 ^ v60;
      *(_DWORD *)(a1 + 212) = v68 ^ v62;
      *(_DWORD *)(a1 + 220) = v69;
      v70 = dword_101560B0[(unsigned __int8)v69] ^ dword_101554B0[BYTE1(v69)] ^ dword_101558B0[(unsigned __int8)(v69 >> 16)] ^ dword_10155CB0[v69 >> 24];
      *(_DWORD *)(a1 + 256) = 14;
      v71 = v67 ^ v70 ^ 0x40;
      v72 = v71 ^ v64;
      v73 = v72 ^ v65;
      *(_DWORD *)(a1 + 232) = v73;
      *(_DWORD *)(a1 + 228) = v72;
      *(_DWORD *)(a1 + 224) = v71;
      *(_DWORD *)(a1 + 236) = v73 ^ v66;
      result = 1;
    }
  }
  return result;
}
// 101554B0: using guessed type int dword_101554B0[];
// 101558B0: using guessed type int dword_101558B0[];
// 10155CB0: using guessed type int dword_10155CB0[];
// 101560B0: using guessed type int dword_101560B0[];

//----- (1006C5A0) --------------------------------------------------------
void *__usercall sub_1006C5A0@<eax>(void *a1@<eax>)
{
  return memset(a1, 0, 0xA0u);
}

//----- (1006C5C0) --------------------------------------------------------
unsigned int __cdecl sub_1006C5C0(int a1, unsigned int a2)
{
  int v2; // eax@1
  unsigned int result; // eax@1
  _BYTE *v4; // ecx@3
  char v5; // dl@3
  unsigned __int64 v6; // [sp+Ch] [bp-8h]@1

  v2 = sub_1007C040();
  v6 = ((unsigned __int64)(unsigned int)v2 << 32) + (unsigned int)j_TSK_pvg_get_us_timer();
  result = 0;
  do
  {
    if ( result >= a2 )
      break;
    v4 = (_BYTE *)(result + a1);
    v5 = *((_BYTE *)&v6 + result++ + a1 - a1);
    *v4 = v5;
  }
  while ( result < 8 );
  return result;
}
// 1007C090: using guessed type int j_TSK_pvg_get_us_timer(void);

//----- (1006C620) --------------------------------------------------------
int __usercall sub_1006C620@<eax>(int result@<eax>)
{
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 8) = 1732584193;
  *(_DWORD *)(result + 12) = -271733879;
  *(_DWORD *)(result + 16) = -1732584194;
  *(_DWORD *)(result + 20) = &unk_10325476;
  *(_DWORD *)(result + 24) = -1009589776;
  return result;
}

//----- (1006C660) --------------------------------------------------------
int __usercall sub_1006C660@<eax>(int result@<eax>)
{
  int v1; // ebx@1
  int v2; // esi@1
  int v3; // edx@1
  unsigned int v4; // ST28_4@1
  int v5; // edx@1
  int v6; // ST18_4@1
  unsigned int v7; // ST2C_4@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // ST14_4@1
  int v12; // ST20_4@1
  unsigned int v13; // ST30_4@1
  int v14; // esi@1
  unsigned int v15; // ST34_4@1
  int v16; // edi@1
  int v17; // edi@1
  int v18; // ecx@1
  int v19; // ST1C_4@1
  int v20; // ebx@1
  unsigned int v21; // ebp@1
  unsigned int v22; // ST38_4@1
  int v23; // edx@1
  int v24; // ST10_4@1
  unsigned int v25; // ST3C_4@1
  int v26; // esi@1
  int v27; // esi@1
  int v28; // ST18_4@1
  int v29; // ebp@1
  unsigned int v30; // ST40_4@1
  int v31; // edi@1
  int v32; // ebx@1
  int v33; // ST14_4@1
  unsigned int v34; // ST44_4@1
  int v35; // edi@1
  int v36; // ST20_4@1
  int v37; // ST1C_4@1
  unsigned int v38; // ST48_4@1
  int v39; // ebx@1
  int v40; // ebx@1
  int v41; // ecx@1
  int v42; // ebp@1
  unsigned int v43; // ST4C_4@1
  int v44; // edx@1
  int v45; // edx@1
  int v46; // ST10_4@1
  int v47; // esi@1
  unsigned int v48; // ST50_4@1
  int v49; // esi@1
  int v50; // ST18_4@1
  unsigned int v51; // ST54_4@1
  int v52; // edi@1
  int v53; // ebx@1
  int v54; // ST14_4@1
  unsigned int v55; // ST58_4@1
  int v56; // edi@1
  int v57; // ST20_4@1
  int v58; // ebx@1
  unsigned int v59; // ST5C_4@1
  int v60; // ebx@1
  int v61; // ecx@1
  int v62; // ST14_4@1
  int v63; // ST1C_4@1
  unsigned int v64; // ST60_4@1
  int v65; // edx@1
  int v66; // edx@1
  int v67; // ST10_4@1
  unsigned int v68; // ST64_4@1
  int v69; // esi@1
  int v70; // esi@1
  int v71; // ST18_4@1
  int v72; // ebp@1
  int v73; // ecx@1
  int v74; // ebx@1
  int v75; // ST68_4@1
  int v76; // edi@1
  int v77; // edi@1
  int v78; // ST14_4@1
  int v79; // ST20_4@1
  int v80; // ecx@1
  int v81; // ST6C_4@1
  int v82; // edi@1
  int v83; // ecx@1
  int v84; // ST70_4@1
  int v85; // ebx@1
  int v86; // ST1C_4@1
  int v87; // ebx@1
  int v88; // ecx@1
  int v89; // ST14_4@1
  int v90; // ecx@1
  int v91; // ST74_4@1
  int v92; // edx@1
  int v93; // edx@1
  int v94; // ST10_4@1
  int v95; // ecx@1
  int v96; // ST78_4@1
  int v97; // esi@1
  int v98; // esi@1
  int v99; // ST18_4@1
  int v100; // ebx@1
  int v101; // ecx@1
  int v102; // edi@1
  int v103; // ST7C_4@1
  int v104; // edi@1
  int v105; // ST20_4@1
  int v106; // ecx@1
  int v107; // ST80_4@1
  int v108; // edx@1
  int v109; // edx@1
  int v110; // ecx@1
  int v111; // ST84_4@1
  int v112; // ebx@1
  int v113; // ebx@1
  int v114; // ST14_4@1
  int v115; // ecx@1
  int v116; // ebp@1
  int v117; // ST88_4@1
  int v118; // edi@1
  int v119; // edi@1
  int v120; // ST10_4@1
  int v121; // ebp@1
  int v122; // ecx@1
  int v123; // ST8C_4@1
  int v124; // edx@1
  int v125; // ebp@1
  int v126; // edx@1
  int v127; // ecx@1
  int v128; // ST18_4@1
  int v129; // ST90_4@1
  int v130; // esi@1
  int v131; // esi@1
  int v132; // ST20_4@1
  int v133; // ecx@1
  int v134; // ST94_4@1
  int v135; // edi@1
  int v136; // edi@1
  int v137; // ecx@1
  int v138; // ST98_4@1
  int v139; // ebx@1
  int v140; // ebx@1
  int v141; // ST14_4@1
  int v142; // ecx@1
  int v143; // ebp@1
  int v144; // ST9C_4@1
  int v145; // esi@1
  int v146; // esi@1
  int v147; // ST10_4@1
  int v148; // ebp@1
  int v149; // ecx@1
  int v150; // STA0_4@1
  int v151; // edi@1
  int v152; // ebp@1
  int v153; // edx@1
  int v154; // ecx@1
  int v155; // ST18_4@1
  int v156; // STA4_4@1
  int v157; // edi@1
  int v158; // edi@1
  int v159; // ST20_4@1
  int v160; // ecx@1
  int v161; // STA8_4@1
  int v162; // esi@1
  int v163; // esi@1
  int v164; // ecx@1
  int v165; // STAC_4@1
  int v166; // ebx@1
  int v167; // ebx@1
  int v168; // ST14_4@1
  int v169; // ecx@1
  int v170; // ebp@1
  int v171; // STB0_4@1
  int v172; // edi@1
  int v173; // edi@1
  int v174; // ST10_4@1
  int v175; // ebp@1
  int v176; // ecx@1
  int v177; // STB4_4@1
  int v178; // esi@1
  int v179; // ebp@1
  int v180; // edx@1
  int v181; // ST18_4@1
  int v182; // ecx@1
  int v183; // STB8_4@1
  int v184; // esi@1
  int v185; // ebx@1
  int v186; // ST20_4@1
  int v187; // esi@1
  int v188; // ecx@1
  int v189; // STBC_4@1
  int v190; // edi@1
  int v191; // edi@1
  int v192; // ST1C_4@1
  int v193; // ecx@1
  int v194; // ebp@1
  int v195; // STC0_4@1
  int v196; // edx@1
  int v197; // ecx@1
  int v198; // esi@1
  int v199; // STC4_4@1
  int v200; // ebp@1
  int v201; // esi@1
  int v202; // ST10_4@1
  int v203; // ecx@1
  int v204; // ebp@1
  int v205; // edi@1
  int v206; // STC8_4@1
  int v207; // ST1C_4@1
  int v208; // ecx@1
  int v209; // STCC_4@1
  int v210; // ebx@1
  int v211; // ST18_4@1
  int v212; // ecx@1
  int v213; // STD0_4@1
  int v214; // edx@1
  int v215; // edi@1
  int v216; // ebx@1
  int v217; // ecx@1
  int v218; // edx@1
  int v219; // ebx@1
  int v220; // ecx@1
  int v221; // ST1C_4@1
  int v222; // ebp@1
  int v223; // STD4_4@1
  int v224; // ST10_4@1
  int v225; // edx@1
  int v226; // ecx@1
  int v227; // ST14_4@1
  int v228; // STD8_4@1
  int v229; // ebp@1
  int v230; // ebx@1
  int v231; // ecx@1
  int v232; // esi@1
  int v233; // ST10_4@1
  int v234; // ecx@1
  int v235; // STDC_4@1
  int v236; // edi@1
  int v237; // ebx@1
  int v238; // ecx@1
  int v239; // edi@1
  int v240; // STE0_4@1
  int v241; // ebx@1
  int v242; // ST18_4@1
  int v243; // ST1C_4@1
  int v244; // ecx@1
  int v245; // edx@1
  int v246; // STE4_4@1
  int v247; // edi@1
  int v248; // ebx@1
  int v249; // ecx@1
  int v250; // edx@1
  int v251; // ebx@1
  int v252; // ecx@1
  int v253; // ST1C_4@1
  int v254; // ebp@1
  int v255; // STE8_4@1
  int v256; // ST10_4@1
  int v257; // edx@1
  int v258; // ecx@1
  int v259; // ebx@1
  int v260; // ST14_4@1
  int v261; // STEC_4@1
  int v262; // ebp@1
  int v263; // ecx@1
  int v264; // esi@1
  int v265; // ST10_4@1
  int v266; // ecx@1
  int v267; // edi@1
  int v268; // STF0_4@1
  int v269; // ebx@1
  int v270; // edi@1
  int v271; // ecx@1
  int v272; // ebx@1
  int v273; // STF4_4@1
  int v274; // ST1C_4@1
  int v275; // ST18_4@1
  int v276; // ecx@1
  int v277; // edx@1
  int v278; // edi@1
  int v279; // STF8_4@1
  int v280; // ebx@1
  int v281; // ecx@1
  int v282; // edx@1
  int v283; // ST1C_4@1
  int v284; // ecx@1
  int v285; // ST10_4@1
  int v286; // STFC_4@1
  int v287; // ebp@1
  int v288; // edx@1
  int v289; // ecx@1
  int v290; // ST100_4@1
  int v291; // ST14_4@1
  int v292; // ebp@1
  int v293; // ebx@1
  int v294; // ecx@1
  int v295; // esi@1
  int v296; // ST10_4@1
  int v297; // ecx@1
  int v298; // edi@1
  int v299; // ST104_4@1
  int v300; // ebx@1
  int v301; // edi@1
  int v302; // ecx@1
  int v303; // ebx@1
  int v304; // ST108_4@1
  int v305; // ST1C_4@1
  int v306; // ST18_4@1
  int v307; // ecx@1
  int v308; // edi@1
  int v309; // ST10C_4@1
  int v310; // ebx@1
  int v311; // edx@1
  int v312; // ecx@1
  int v313; // ST1C_4@1
  int v314; // ecx@1
  int v315; // ST110_4@1
  int v316; // ebp@1
  int v317; // ebx@1
  int v318; // edx@1
  int v319; // ecx@1
  int v320; // ST114_4@1
  int v321; // ST14_4@1
  int v322; // ebp@1
  int v323; // edi@1
  int v324; // ecx@1
  int v325; // edx@1
  int v326; // ebp@1
  int v327; // ST118_4@1
  int v328; // esi@1
  int v329; // ST10_4@1
  int v330; // ecx@1
  int v331; // ST18_4@1
  int v332; // ST11C_4@1
  int v333; // ebx@1
  int v334; // esi@1
  int v335; // edi@1
  int v336; // edi@1
  int v337; // ST20_4@1
  int v338; // ebx@1
  int v339; // ecx@1
  int v340; // edx@1
  int v341; // ST120_4@1
  int v342; // edx@1
  int v343; // ecx@1
  int v344; // ST124_4@1
  int v345; // ebx@1
  int v346; // ebx@1
  int v347; // ecx@1
  int v348; // ST14_4@1
  int v349; // ST128_4@1
  int v350; // ebp@1
  int v351; // edi@1
  int v352; // edi@1
  int v353; // ecx@1
  int v354; // ST10_4@1
  int v355; // ST12C_4@1
  int v356; // ebp@1
  int v357; // edx@1
  int v358; // ST18_4@1
  int v359; // ecx@1
  int v360; // ST130_4@1
  int v361; // edx@1
  int v362; // esi@1
  int v363; // esi@1
  int v364; // ST20_4@1
  int v365; // ecx@1
  int v366; // ebx@1
  int v367; // edi@1
  int v368; // ST134_4@1
  int v369; // edi@1
  int v370; // ecx@1
  int v371; // ebp@1
  int v372; // ST138_4@1
  int v373; // ebx@1
  int v374; // ebx@1
  int v375; // ecx@1
  int v376; // ST14_4@1
  int v377; // ST13C_4@1
  int v378; // ebp@1
  int v379; // esi@1
  int v380; // esi@1
  int v381; // ecx@1
  int v382; // ST10_4@1
  int v383; // ST140_4@1
  int v384; // ebp@1
  int v385; // edi@1
  int v386; // edi@1
  int v387; // ecx@1
  int v388; // ebp@1
  int v389; // edx@1
  int v390; // ST18_4@1
  int v391; // ebx@1
  int v392; // ST20_4@1
  int v393; // edx@1
  int v394; // ST14_4@1
  int v395; // esi@1
  int v396; // ST148_4@1
  int v397; // ST10_4@1
  int v398; // ST1C_4@1
  int v399; // edx@1
  int v400; // ebx@1
  int v401; // ST14C_4@1
  int v402; // esi@1
  int v403; // ebx@1
  int v404; // ST18_4@1
  int v405; // ST14_4@1
  int v406; // edx@1
  int v407; // edi@1
  int v408; // esi@1
  int v409; // ebx@1
  int v410; // ST20_4@1
  int v411; // esi@1
  int v412; // ST10_4@1
  int v413; // ebx@1
  int v414; // edi@1
  int v415; // ebp@1
  int v416; // edi@1
  int v417; // ST24_4@1
  int v418; // ST1C_4@1
  int v419; // edi@1
  int v420; // ebx@1
  int v421; // ST20_4@1
  int v422; // edx@1
  int v423; // ebx@1
  int v424; // edx@1
  int v425; // ebx@1
  int v426; // ST1C_4@1
  int v427; // esi@1
  int v428; // ebx@1
  int v429; // esi@1
  int v430; // ecx@1
  int v431; // ebx@1
  int v432; // ebx@1
  int v433; // edx@1
  int v434; // ecx@1

  v1 = *(_DWORD *)(result + 8);
  v2 = *(_DWORD *)(result + 12);
  v3 = __ROL4__(*(_DWORD *)(result + 8), 5);
  v4 = ((*(_DWORD *)(result + 28) & 0xFF00 | (*(_DWORD *)(result + 28) << 16)) << 8) | (((*(_DWORD *)(result + 28) >> 16) | *(_DWORD *)(result + 28) & 0xFF0000u) >> 8);
  v5 = v4
     + *(_DWORD *)(result + 24)
     + v3
     + (v2 & *(_DWORD *)(result + 16) ^ *(_DWORD *)(result + 20) & ~*(_DWORD *)(result + 12))
     + 1518500249;
  v2 = __ROR4__(v2, 2);
  v6 = v2;
  v7 = ((*(_DWORD *)(result + 32) & 0xFF00 | (*(_DWORD *)(result + 32) << 16)) << 8) | (((*(_DWORD *)(result + 32) >> 16) | *(_DWORD *)(result + 32) & 0xFF0000u) >> 8);
  v8 = v1 & v2 ^ *(_DWORD *)(result + 16) & ~v1;
  v9 = __ROL4__(v5, 5);
  v10 = *(_DWORD *)(result + 20) + v7 + v9 + v8 + 1518500249;
  v1 = __ROR4__(v1, 2);
  v11 = v10;
  v10 = __ROL4__(v10, 5);
  v12 = v1;
  v13 = ((*(_DWORD *)(result + 36) & 0xFF00 | (*(_DWORD *)(result + 36) << 16)) << 8) | (((*(_DWORD *)(result + 36) >> 16) | *(_DWORD *)(result + 36) & 0xFF0000u) >> 8);
  v14 = *(_DWORD *)(result + 16) + v13 + v10 + (v1 & v5 ^ v6 & ~v5) + 1518500249;
  v5 = __ROR4__(v5, 2);
  v15 = ((*(_DWORD *)(result + 40) & 0xFF00 | (*(_DWORD *)(result + 40) << 16)) << 8) | (((*(_DWORD *)(result + 40) >> 16) | *(_DWORD *)(result + 40) & 0xFF0000u) >> 8);
  v16 = __ROL4__(v14, 5);
  v17 = v6 + v15 + v16 + (v11 & v5 ^ v1 & ~v11) + 1518500249;
  v18 = __ROR4__(v11, 2);
  v19 = v5;
  v20 = __ROL4__(v17, 5);
  v21 = (((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8))
      + v20
      + (v14 & v18 ^ v5 & ~v14);
  v22 = ((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8);
  v14 = __ROR4__(v14, 2);
  v23 = v12 + v21 + 1518500249;
  v24 = v14;
  v25 = ((*(_DWORD *)(result + 48) & 0xFF00 | (*(_DWORD *)(result + 48) << 16)) << 8) | (((*(_DWORD *)(result + 48) >> 16) | *(_DWORD *)(result + 48) & 0xFF0000u) >> 8);
  v26 = __ROL4__(v23, 5);
  v27 = v19 + v25 + v26 + (v17 & v24 ^ v18 & ~v17) + 1518500249;
  v17 = __ROR4__(v17, 2);
  v28 = v17;
  v29 = v23 & v17;
  v30 = ((*(_DWORD *)(result + 52) & 0xFF00 | (*(_DWORD *)(result + 52) << 16)) << 8) | (((*(_DWORD *)(result + 52) >> 16) | *(_DWORD *)(result + 52) & 0xFF0000u) >> 8);
  v31 = __ROL4__(v27, 5);
  v32 = v18 + v30 + v31 + (v29 ^ v24 & ~v23) + 1518500249;
  v23 = __ROR4__(v23, 2);
  v33 = v32;
  v32 = __ROL4__(v32, 5);
  v34 = ((*(_DWORD *)(result + 56) & 0xFF00 | (*(_DWORD *)(result + 56) << 16)) << 8) | (((*(_DWORD *)(result + 56) >> 16) | *(_DWORD *)(result + 56) & 0xFF0000u) >> 8);
  v35 = v24 + v34 + v32 + (v23 & v27 ^ v28 & ~v27) + 1518500249;
  v27 = __ROR4__(v27, 2);
  v36 = v23;
  v37 = v27;
  v38 = ((*(_DWORD *)(result + 60) & 0xFF00 | (*(_DWORD *)(result + 60) << 16)) << 8) | (((*(_DWORD *)(result + 60) >> 16) | *(_DWORD *)(result + 60) & 0xFF0000u) >> 8);
  v39 = __ROL4__(v35, 5);
  v40 = v28 + v38 + v39 + (v33 & v27 ^ v23 & ~v33) + 1518500249;
  v41 = __ROR4__(v33, 2);
  v42 = v35 & v41 ^ v27 & ~v35;
  v43 = ((*(_DWORD *)(result + 64) & 0xFF00 | (*(_DWORD *)(result + 64) << 16)) << 8) | (((*(_DWORD *)(result + 64) >> 16) | *(_DWORD *)(result + 64) & 0xFF0000u) >> 8);
  v44 = __ROL4__(v40, 5);
  v35 = __ROR4__(v35, 2);
  v45 = v36 + v43 + v44 + v42 + 1518500249;
  v46 = v35;
  v47 = __ROL4__(v45, 5);
  v48 = ((*(_DWORD *)(result + 68) & 0xFF00 | (*(_DWORD *)(result + 68) << 16)) << 8) | (((*(_DWORD *)(result + 68) >> 16) | *(_DWORD *)(result + 68) & 0xFF0000u) >> 8);
  v49 = v37 + v48 + v47 + (v40 & v35 ^ v41 & ~v40) + 1518500249;
  v40 = __ROR4__(v40, 2);
  v50 = v40;
  v51 = ((*(_DWORD *)(result + 72) & 0xFF00 | (*(_DWORD *)(result + 72) << 16)) << 8) | (((*(_DWORD *)(result + 72) >> 16) | *(_DWORD *)(result + 72) & 0xFF0000u) >> 8);
  v52 = __ROL4__(v49, 5);
  v53 = v41 + v51 + v52 + (v45 & v40 ^ v46 & ~v45) + 1518500249;
  v54 = v53;
  v45 = __ROR4__(v45, 2);
  v53 = __ROL4__(v53, 5);
  v55 = ((*(_DWORD *)(result + 76) & 0xFF00 | (*(_DWORD *)(result + 76) << 16)) << 8) | (((*(_DWORD *)(result + 76) >> 16) | *(_DWORD *)(result + 76) & 0xFF0000u) >> 8);
  v56 = v46 + v55 + v53 + (v45 & v49 ^ v50 & ~v49) + 1518500249;
  v49 = __ROR4__(v49, 2);
  v57 = v45;
  v58 = __ROL4__(v56, 5);
  v59 = ((*(_DWORD *)(result + 80) & 0xFF00 | (*(_DWORD *)(result + 80) << 16)) << 8) | (((*(_DWORD *)(result + 80) >> 16) | *(_DWORD *)(result + 80) & 0xFF0000u) >> 8);
  v60 = v50 + v59 + v58 + (v54 & v49 ^ v45 & ~v54) + 1518500249;
  v61 = __ROR4__(v54, 2);
  v62 = v61;
  v63 = v49;
  v64 = ((*(_DWORD *)(result + 84) & 0xFF00 | (*(_DWORD *)(result + 84) << 16)) << 8) | (((*(_DWORD *)(result + 84) >> 16) | *(_DWORD *)(result + 84) & 0xFF0000u) >> 8);
  v65 = __ROL4__(v60, 5);
  v66 = v57 + v64 + v65 + (v56 & v61 ^ v49 & ~v56) + 1518500249;
  v56 = __ROR4__(v56, 2);
  v67 = v56;
  v68 = ((*(_DWORD *)(result + 88) & 0xFF00 | (*(_DWORD *)(result + 88) << 16)) << 8) | (((*(_DWORD *)(result + 88) >> 16) | *(_DWORD *)(result + 88) & 0xFF0000u) >> 8);
  v69 = __ROL4__(v66, 5);
  v70 = v63 + v68 + v69 + (v60 & v56 ^ v61 & ~v60) + 1518500249;
  v60 = __ROR4__(v60, 2);
  v71 = v60;
  v72 = v60;
  v73 = __ROL4__(v4 ^ v13 ^ v38 ^ v59, 1);
  v74 = v56 & ~v66;
  v75 = v73;
  v76 = __ROL4__(v70, 5);
  v77 = v62 + v73 + v76 + (v66 & v72 ^ v74) + 1518500249;
  v66 = __ROR4__(v66, 2);
  v78 = v77;
  v79 = v66;
  v80 = __ROL4__(v7 ^ v15 ^ v43 ^ v64, 1);
  v81 = v80;
  v77 = __ROL4__(v77, 5);
  v82 = v67 + v80 + v77 + (v66 & v70 ^ v71 & ~v70) + 1518500249;
  v70 = __ROR4__(v70, 2);
  v83 = __ROL4__(v13 ^ v22 ^ v48 ^ v68, 1);
  v84 = v83;
  v85 = __ROL4__(v82, 5);
  v86 = v70;
  v87 = v71 + v83 + v85 + (v78 & v70 ^ v66 & ~v78) + 1518500249;
  v88 = __ROR4__(v78, 2);
  v89 = v88;
  v90 = __ROL4__(v15 ^ v25 ^ v51 ^ v75, 1);
  v91 = v90;
  v92 = __ROL4__(v87, 5);
  v93 = v79 + v90 + v92 + (v82 & v89 ^ v70 & ~v82) + 1518500249;
  v82 = __ROR4__(v82, 2);
  v94 = v82;
  v95 = __ROL4__(v22 ^ v30 ^ v55 ^ v81, 1);
  v96 = v95;
  v97 = __ROL4__(v93, 5);
  v98 = v86 + v95 + v97 + (v87 ^ v82 ^ v89) + 1859775393;
  v87 = __ROR4__(v87, 2);
  v99 = v87;
  v100 = v87 ^ v82;
  v101 = __ROL4__(v25 ^ v34 ^ v59 ^ v84, 1);
  v102 = __ROL4__(v98, 5);
  v103 = v101;
  v104 = v89 + v101 + v102 + (v93 ^ v100) + 1859775393;
  v93 = __ROR4__(v93, 2);
  v105 = v93;
  v106 = __ROL4__(v30 ^ v38 ^ v64 ^ v91, 1);
  v107 = v106;
  v108 = __ROL4__(v104, 5);
  v109 = v94 + v106 + v108 + (v105 ^ v99 ^ v98) + 1859775393;
  v98 = __ROR4__(v98, 2);
  v110 = __ROL4__(v34 ^ v43 ^ v68 ^ v96, 1);
  v111 = v110;
  v112 = __ROL4__(v109, 5);
  v113 = v99 + v110 + v112 + (v105 ^ v104 ^ v98) + 1859775393;
  v104 = __ROR4__(v104, 2);
  v114 = v104;
  v115 = __ROL4__(v38 ^ v48 ^ v75 ^ v103, 1);
  v116 = v109 ^ v104 ^ v98;
  v117 = v115;
  v118 = __ROL4__(v113, 5);
  v119 = v105 + v115 + v118 + v116 + 1859775393;
  v109 = __ROR4__(v109, 2);
  v120 = v109;
  v121 = v109 ^ v114;
  v122 = __ROL4__(v43 ^ v51 ^ v81 ^ v107, 1);
  v123 = v122;
  v124 = __ROL4__(v119, 5);
  v125 = v122 + v124 + (v113 ^ v121);
  v113 = __ROR4__(v113, 2);
  v126 = v98 + v125 + 1859775393;
  v127 = __ROL4__(v48 ^ v55 ^ v84 ^ v111, 1);
  v128 = v113;
  v129 = v127;
  v130 = __ROL4__(v126, 5);
  v131 = v114 + v127 + v130 + (v119 ^ v113 ^ v120) + 1859775393;
  v119 = __ROR4__(v119, 2);
  v132 = v119;
  v133 = __ROL4__(v51 ^ v59 ^ v91 ^ v117, 1);
  v134 = v133;
  v135 = __ROL4__(v131, 5);
  v136 = v120 + v133 + v135 + (v132 ^ v113 ^ v126) + 1859775393;
  v126 = __ROR4__(v126, 2);
  v137 = __ROL4__(v55 ^ v64 ^ v96 ^ v123, 1);
  v138 = v137;
  v139 = __ROL4__(v136, 5);
  v140 = v128 + v137 + v139 + (v132 ^ v131 ^ v126) + 1859775393;
  v131 = __ROR4__(v131, 2);
  v141 = v131;
  v142 = __ROL4__(v59 ^ v68 ^ v103 ^ v129, 1);
  v143 = v136 ^ v131 ^ v126;
  v144 = v142;
  v145 = __ROL4__(v140, 5);
  v146 = v132 + v142 + v145 + v143 + 1859775393;
  v136 = __ROR4__(v136, 2);
  v147 = v136;
  v148 = v136 ^ v141;
  v149 = __ROL4__(v64 ^ v75 ^ v107 ^ v134, 1);
  v150 = v149;
  v151 = __ROL4__(v146, 5);
  v152 = v149 + v151 + (v140 ^ v148);
  v140 = __ROR4__(v140, 2);
  v153 = v126 + v152 + 1859775393;
  v154 = __ROL4__(v68 ^ v81 ^ v111 ^ v138, 1);
  v155 = v140;
  v156 = v154;
  v157 = __ROL4__(v153, 5);
  v158 = v141 + v154 + v157 + (v146 ^ v140 ^ v147) + 1859775393;
  v146 = __ROR4__(v146, 2);
  v159 = v146;
  v160 = __ROL4__(v75 ^ v84 ^ v117 ^ v144, 1);
  v161 = v160;
  v162 = __ROL4__(v158, 5);
  v163 = v147 + v160 + v162 + (v159 ^ v140 ^ v153) + 1859775393;
  v153 = __ROR4__(v153, 2);
  v164 = __ROL4__(v81 ^ v91 ^ v123 ^ v150, 1);
  v165 = v164;
  v166 = __ROL4__(v163, 5);
  v167 = v155 + v164 + v166 + (v159 ^ v158 ^ v153) + 1859775393;
  v158 = __ROR4__(v158, 2);
  v168 = v158;
  v169 = __ROL4__(v84 ^ v96 ^ v129 ^ v156, 1);
  v170 = v163 ^ v158 ^ v153;
  v171 = v169;
  v172 = __ROL4__(v167, 5);
  v173 = v159 + v169 + v172 + v170 + 1859775393;
  v163 = __ROR4__(v163, 2);
  v174 = v163;
  v175 = v163 ^ v168;
  v176 = __ROL4__(v91 ^ v103 ^ v134 ^ v161, 1);
  v177 = v176;
  v178 = __ROL4__(v173, 5);
  v179 = v176 + v178 + (v167 ^ v175);
  v167 = __ROR4__(v167, 2);
  v180 = v153 + v179 + 1859775393;
  v181 = v167;
  v182 = __ROL4__(v96 ^ v107 ^ v138 ^ v165, 1);
  v183 = v182;
  v184 = __ROL4__(v180, 5);
  v185 = v168 + v182 + v184 + (v173 ^ v167 ^ v174) + 1859775393;
  v173 = __ROR4__(v173, 2);
  v186 = v173;
  v187 = v173;
  v188 = __ROL4__(v103 ^ v111 ^ v144 ^ v171, 1);
  v189 = v188;
  v190 = __ROL4__(v185, 5);
  v191 = v174 + v188 + v190 + (v187 ^ v181 ^ v180) + 1859775393;
  v180 = __ROR4__(v180, 2);
  v192 = v180;
  v193 = __ROL4__(v107 ^ v117 ^ v150 ^ v177, 1);
  v194 = __ROL4__(v191, 5);
  v195 = v193;
  v196 = v181 + v193 + v194 + (v187 ^ v185 ^ v180) + 1859775393;
  v185 = __ROR4__(v185, 2);
  v197 = __ROL4__(v111 ^ v123 ^ v156 ^ v183, 1);
  v198 = __ROL4__(v196, 5);
  v199 = v197;
  v200 = v197 + v198 + (v191 ^ v185 ^ v192);
  v191 = __ROR4__(v191, 2);
  v201 = v186 + v200 + 1859775393;
  v202 = v191;
  v203 = __ROL4__(v117 ^ v129 ^ v161 ^ v189, 1);
  v204 = __ROL4__(v201, 5);
  v205 = v192 + v203 + (v196 & v191 ^ v185 & (v196 ^ v191)) + v204 - 1894007588;
  v206 = v203;
  v207 = v205;
  v196 = __ROR4__(v196, 2);
  v208 = __ROL4__(v123 ^ v134 ^ v165 ^ v195, 1);
  v209 = v208;
  v210 = v185 + v208 + (v201 & v196 ^ v202 & (v201 ^ v196));
  v205 = __ROL4__(v205, 5);
  v201 = __ROR4__(v201, 2);
  v211 = v196;
  v212 = __ROL4__(v129 ^ v138 ^ v171 ^ v199, 1);
  v213 = v212;
  v214 = v202 + v212 + (v201 & v196 ^ v207 & (v201 ^ v196));
  v215 = v210 + v205 - 1894007588;
  v216 = __ROL4__(v215, 5);
  v217 = __ROR4__(v207, 2);
  v218 = v214 + v216 - 1894007588;
  v219 = v217;
  v220 = __ROL4__(v134 ^ v144 ^ v177 ^ v206, 1);
  v221 = v219;
  v222 = v211 + v220 + (v201 & v215 ^ v219 & (v201 ^ v215));
  v223 = v220;
  v224 = v218;
  v218 = __ROL4__(v218, 5);
  v215 = __ROR4__(v215, 2);
  v225 = v218 + v222 - 1894007588;
  v226 = __ROL4__(v138 ^ v150 ^ v183 ^ v209, 1);
  v227 = v215;
  v228 = v226;
  v229 = v226 + (v224 & v215 ^ v219 & (v224 ^ v215));
  v230 = __ROL4__(v225, 5);
  v231 = __ROR4__(v224, 2);
  v232 = v230 + v201 + v229 - 1894007588;
  v233 = v231;
  v234 = __ROL4__(v144 ^ v156 ^ v189 ^ v213, 1);
  v235 = v234;
  v236 = v221 + v234 + (v225 & v233 ^ v215 & (v225 ^ v233));
  v237 = __ROL4__(v232, 5);
  v225 = __ROR4__(v225, 2);
  v238 = __ROL4__(v150 ^ v161 ^ v195 ^ v223, 1);
  v239 = v236 + v237 - 1894007588;
  v240 = v238;
  v241 = v227 + v238 + (v232 & v225 ^ v233 & (v232 ^ v225));
  v242 = v225;
  v243 = v239;
  v239 = __ROL4__(v239, 5);
  v232 = __ROR4__(v232, 2);
  v244 = __ROL4__(v156 ^ v165 ^ v199 ^ v228, 1);
  v245 = v233 + v244 + (v232 & v225 ^ v243 & (v232 ^ v225));
  v246 = v244;
  v247 = v241 + v239 - 1894007588;
  v248 = __ROL4__(v247, 5);
  v249 = __ROR4__(v243, 2);
  v250 = v245 + v248 - 1894007588;
  v251 = v249;
  v252 = __ROL4__(v161 ^ v171 ^ v206 ^ v235, 1);
  v253 = v251;
  v254 = v242 + v252 + (v232 & v247 ^ v251 & (v232 ^ v247));
  v255 = v252;
  v256 = v250;
  v250 = __ROL4__(v250, 5);
  v247 = __ROR4__(v247, 2);
  v257 = v250 + v254 - 1894007588;
  v258 = __ROL4__(v165 ^ v177 ^ v209 ^ v240, 1);
  v259 = __ROL4__(v257, 5);
  v260 = v247;
  v261 = v258;
  v262 = v258 + (v256 & v247 ^ v253 & (v256 ^ v247));
  v263 = __ROR4__(v256, 2);
  v264 = v259 + v232 + v262 - 1894007588;
  v265 = v263;
  v266 = __ROL4__(v171 ^ v183 ^ v213 ^ v246, 1);
  v267 = v253 + v266 + (v257 & v265 ^ v247 & (v257 ^ v265));
  v268 = v266;
  v269 = __ROL4__(v264, 5);
  v257 = __ROR4__(v257, 2);
  v270 = v267 + v269 - 1894007588;
  v271 = __ROL4__(v177 ^ v189 ^ v223 ^ v255, 1);
  v272 = v260 + v271 + (v264 & v257 ^ v265 & (v264 ^ v257));
  v273 = v271;
  v274 = v270;
  v270 = __ROL4__(v270, 5);
  v264 = __ROR4__(v264, 2);
  v275 = v257;
  v276 = __ROL4__(v183 ^ v195 ^ v228 ^ v261, 1);
  v277 = v265 + v276 + (v264 & v257 ^ v274 & (v264 ^ v257));
  v278 = v272 + v270 - 1894007588;
  v279 = v276;
  v280 = __ROL4__(v278, 5);
  v281 = __ROR4__(v274, 2);
  v282 = v277 + v280 - 1894007588;
  v283 = v281;
  v284 = __ROL4__(v189 ^ v199 ^ v235 ^ v268, 1);
  v285 = v282;
  v282 = __ROL4__(v282, 5);
  v286 = v284;
  v287 = v275 + v284 + (v264 & v278 ^ v283 & (v264 ^ v278));
  v278 = __ROR4__(v278, 2);
  v288 = v282 + v287 - 1894007588;
  v289 = __ROL4__(v195 ^ v206 ^ v240 ^ v273, 1);
  v290 = v289;
  v291 = v278;
  v292 = v289 + (v285 & v278 ^ v283 & (v285 ^ v278));
  v293 = __ROL4__(v288, 5);
  v294 = __ROR4__(v285, 2);
  v295 = v293 + v264 + v292 - 1894007588;
  v296 = v294;
  v297 = __ROL4__(v199 ^ v209 ^ v246 ^ v279, 1);
  v298 = v283 + v297 + (v288 & v296 ^ v278 & (v288 ^ v296));
  v299 = v297;
  v300 = __ROL4__(v295, 5);
  v288 = __ROR4__(v288, 2);
  v301 = v298 + v300 - 1894007588;
  v302 = __ROL4__(v206 ^ v213 ^ v255 ^ v286, 1);
  v303 = v291 + v302 + (v295 & v288 ^ v296 & (v295 ^ v288));
  v304 = v302;
  v305 = v301;
  v306 = v288;
  v301 = __ROL4__(v301, 5);
  v295 = __ROR4__(v295, 2);
  v307 = __ROL4__(v209 ^ v223 ^ v261 ^ v290, 1);
  v308 = v303 + v301 - 1894007588;
  v309 = v307;
  v310 = __ROL4__(v308, 5);
  v311 = v296 + v307 + (v295 & v288 ^ v305 & (v295 ^ v288)) + v310 - 1894007588;
  v312 = __ROR4__(v305, 2);
  v313 = v312;
  v314 = __ROL4__(v213 ^ v228 ^ v268 ^ v299, 1);
  v315 = v314;
  v316 = v306 + v314 + (v295 & v308 ^ v313 & (v295 ^ v308));
  v317 = v311;
  v311 = __ROL4__(v311, 5);
  v308 = __ROR4__(v308, 2);
  v318 = v311 + v316 - 1894007588;
  v319 = __ROL4__(v223 ^ v235 ^ v273 ^ v304, 1);
  v320 = v319;
  v321 = v308;
  v322 = v319 + (v317 & v308 ^ v313 & (v317 ^ v308));
  v323 = v318;
  v318 = __ROL4__(v318, 5);
  v317 = __ROR4__(v317, 2);
  v324 = __ROL4__(v228 ^ v240 ^ v279 ^ v309, 1);
  v325 = v318 + v295 + v322 - 1894007588;
  v326 = v313 + v324 + (v323 ^ v317 ^ v321);
  v327 = v324;
  v328 = __ROL4__(v325, 5);
  v323 = __ROR4__(v323, 2);
  v329 = v317;
  v330 = __ROL4__(v235 ^ v246 ^ v286 ^ v315, 1);
  v331 = v323;
  v332 = v330;
  v333 = v321 + v330 + (v325 ^ v323 ^ v317);
  v334 = v328 + v326 - 899497514;
  v335 = __ROL4__(v334, 5);
  v336 = v333 + v335 - 899497514;
  v325 = __ROR4__(v325, 2);
  v337 = v325;
  v338 = v325 ^ v331 ^ v334;
  v339 = __ROL4__(v240 ^ v255 ^ v290 ^ v320, 1);
  v340 = __ROL4__(v336, 5);
  v341 = v339;
  v334 = __ROR4__(v334, 2);
  v342 = v329 + v339 + v338 + v340 - 899497514;
  v343 = __ROL4__(v246 ^ v261 ^ v299 ^ v327, 1);
  v344 = v343;
  v345 = __ROL4__(v342, 5);
  v346 = v345 + v331 + v343 + (v337 ^ v336 ^ v334) - 899497514;
  v336 = __ROR4__(v336, 2);
  v347 = __ROL4__(v255 ^ v268 ^ v304 ^ v332, 1);
  v348 = v336;
  v349 = v347;
  v350 = v337 + v347 + (v342 ^ v336 ^ v334);
  v351 = __ROL4__(v346, 5);
  v342 = __ROR4__(v342, 2);
  v352 = v351 + v350 - 899497514;
  v353 = __ROL4__(v261 ^ v273 ^ v309 ^ v341, 1);
  v354 = v342;
  v355 = v353;
  v356 = v353 + (v346 ^ v342 ^ v348);
  v357 = __ROL4__(v352, 5);
  v346 = __ROR4__(v346, 2);
  v358 = v346;
  v359 = __ROL4__(v268 ^ v279 ^ v315 ^ v344, 1);
  v360 = v359;
  v361 = v357 + v334 + v356 - 899497514;
  v362 = __ROL4__(v361, 5);
  v363 = v348 + v359 + (v352 ^ v346 ^ v354) + v362 - 899497514;
  v352 = __ROR4__(v352, 2);
  v364 = v352;
  v365 = __ROL4__(v273 ^ v286 ^ v320 ^ v349, 1);
  v366 = v352 ^ v346 ^ v361;
  v367 = __ROL4__(v363, 5);
  v368 = v365;
  v369 = v354 + v365 + v366 + v367 - 899497514;
  v361 = __ROR4__(v361, 2);
  v370 = __ROL4__(v279 ^ v290 ^ v327 ^ v355, 1);
  v371 = v358 + v370 + (v364 ^ v363 ^ v361);
  v372 = v370;
  v373 = __ROL4__(v369, 5);
  v363 = __ROR4__(v363, 2);
  v374 = v373 + v371 - 899497514;
  v375 = __ROL4__(v286 ^ v299 ^ v332 ^ v360, 1);
  v376 = v363;
  v377 = v375;
  v378 = v364 + v375 + (v369 ^ v363 ^ v361);
  v379 = __ROL4__(v374, 5);
  v380 = v379 + v378 - 899497514;
  v369 = __ROR4__(v369, 2);
  v381 = __ROL4__(v290 ^ v304 ^ v341 ^ v368, 1);
  v382 = v369;
  v383 = v381;
  v384 = v381 + (v374 ^ v369 ^ v376);
  v385 = __ROL4__(v380, 5);
  v386 = v385 + v361 + v384 - 899497514;
  v374 = __ROR4__(v374, 2);
  v387 = __ROL4__(v299 ^ v309 ^ v344 ^ v372, 1);
  v388 = v376 + v387 + (v380 ^ v374 ^ v382);
  v389 = __ROL4__(v386, 5);
  v380 = __ROR4__(v380, 2);
  v390 = v374;
  v391 = v389 + v388 - 899497514;
  v392 = v380;
  v393 = __ROL4__(v304 ^ v315 ^ v349 ^ v377, 1);
  v394 = v391;
  v391 = __ROL4__(v391, 5);
  v395 = v382 + v393 + (v380 ^ v390 ^ v386) + v391 - 899497514;
  v386 = __ROR4__(v386, 2);
  v396 = v393;
  v397 = v395;
  v398 = v386;
  v399 = __ROL4__(v309 ^ v320 ^ v355 ^ v383, 1);
  v400 = __ROL4__(v395, 5);
  v401 = v399;
  v402 = __ROR4__(v394, 2);
  v403 = v400 + v390 + v399 + (v392 ^ v394 ^ v386) - 899497514;
  v404 = v403;
  v405 = v402;
  v406 = __ROL4__(v315 ^ v327 ^ v360 ^ v387, 1);
  v403 = __ROL4__(v403, 5);
  v407 = v392 + v406 + (v397 ^ v402 ^ v386) + v403 - 899497514;
  v408 = __ROR4__(v397, 2);
  v409 = v408;
  v410 = v407;
  v411 = __ROL4__(v320 ^ v332 ^ v368 ^ v396, 1);
  v407 = __ROL4__(v407, 5);
  v412 = v409;
  v413 = v407 + v398 + v411 + (v404 ^ v409 ^ v405) - 899497514;
  v414 = __ROR4__(v404, 2);
  v415 = v414;
  v416 = __ROL4__(v327 ^ v341 ^ v372 ^ v401, 1);
  v417 = v416;
  v418 = v413;
  v413 = __ROL4__(v413, 5);
  v419 = v405 + v416 + (v410 ^ v415 ^ v412) + v413 - 899497514;
  v420 = __ROR4__(v410, 2);
  v421 = v420;
  v422 = __ROL4__(v332 ^ v344 ^ v377 ^ v406, 1);
  v423 = __ROL4__(v419, 5);
  v424 = v412 + (v421 ^ v415 ^ v418) + v423 + v422 - 899497514;
  v425 = __ROR4__(v418, 2);
  v426 = v425;
  v427 = __ROL4__(v341 ^ v349 ^ v383 ^ v411, 1);
  v428 = __ROL4__(v424, 5);
  v429 = v415 + (v421 ^ v419 ^ v426) + v428 + v427 - 899497514;
  v419 = __ROR4__(v419, 2);
  v430 = __ROL4__(v417 ^ v344 ^ v355 ^ v387, 1);
  v431 = __ROL4__(v429, 5);
  v432 = v421 + (v424 ^ v419 ^ v426) + v431 + v430 - 899497514 + *(_DWORD *)(result + 8);
  *(_DWORD *)(result + 12) += v429;
  v424 = __ROR4__(v424, 2);
  v433 = *(_DWORD *)(result + 16) + v424;
  *(_DWORD *)(result + 20) += v419;
  v434 = *(_DWORD *)(result + 24);
  *(_DWORD *)(result + 8) = v432;
  *(_DWORD *)(result + 16) = v433;
  *(_DWORD *)(result + 24) = v426 + v434;
  return result;
}

//----- (1006DD80) --------------------------------------------------------
unsigned int __usercall sub_1006DD80@<eax>(int a1@<esi>, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@4
  unsigned int v5; // eax@7
  unsigned int result; // eax@7
  int v7; // edx@8

  v2 = *(_DWORD *)a1 & 0x3F;
  v3 = v2 >> 2;
  *(_DWORD *)(a1 + 4 * v3 + 28) = dword_101564D8[*(_BYTE *)a1 & 3] | *(_DWORD *)(a1 + 4 * v3 + 28) & dword_101564E8[*(_BYTE *)a1 & 3];
  if ( v2 > 0x37 )
  {
    if ( v2 < 0x3C )
      *(_DWORD *)(a1 + 88) = 0;
    sub_1006C660(a1);
    v4 = 0;
    goto LABEL_6;
  }
  v4 = v3 + 1;
  if ( v3 + 1 < 0xE )
LABEL_6:
    memset((void *)(a1 + 4 * v4 + 28), 0, 4 * (14 - v4));
  v5 = 8 * *(_DWORD *)a1;
  *(_DWORD *)(a1 + 84) = ((((unsigned int)(*(_QWORD *)a1 >> 29) << 16) | (*(_QWORD *)a1 >> 29) & 0xFF00) << 8) | ((((unsigned int)(*(_QWORD *)a1 >> 29) >> 16) | (*(_QWORD *)a1 >> 29) & 0xFF0000) >> 8);
  *(_DWORD *)(a1 + 88) = (((v5 << 16) | v5 & 0xFF00) << 8) | (((v5 >> 16) | v5 & 0xFF0000) >> 8);
  sub_1006C660(a1);
  result = 0;
  do
  {
    v7 = *(_DWORD *)(a1 + 4 * (result >> 2) + 8) >> 8 * (~(_BYTE)result & 3);
    *(_BYTE *)(++result + a2 - 1) = v7;
  }
  while ( result < 0x14 );
  return result;
}
// 101564D8: using guessed type int dword_101564D8[];
// 101564E8: using guessed type int dword_101564E8[];

//----- (1006DE80) --------------------------------------------------------
void *__usercall sub_1006DE80@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3)
{
  int v3; // ebp@1
  size_t v4; // ebx@1
  int v5; // edi@1
  unsigned int v6; // eax@1
  size_t v7; // esi@1
  char *v9; // [sp+14h] [bp+4h]@1

  v3 = (int)a3;
  v4 = a1;
  v5 = *a3 & 0x3F;
  v6 = a1 + *a3;
  v7 = 64 - v5;
  v9 = a2;
  *(_DWORD *)v3 = v6;
  if ( v6 < v4 )
    ++*(_DWORD *)(v3 + 4);
  if ( v4 >= v7 )
  {
    do
    {
      memcpy((void *)(v5 + v3 + 28), v9, v7);
      v9 += v7;
      v4 -= v7;
      v7 = 64;
      v5 = 0;
      sub_1006C660(v3);
    }
    while ( v4 >= 0x40 );
  }
  return memcpy((void *)(v5 + v3 + 28), v9, v4);
}

//----- (1006DF00) --------------------------------------------------------
void *__usercall sub_1006DF00@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3)
{
  int v3; // edi@1
  void *result; // eax@1
  unsigned int v5; // eax@4
  _DWORD *v6; // eax@6

  v3 = a1;
  result = *(void **)(a1 + 156);
  if ( result != (void *)-1 )
  {
    if ( (unsigned int)result > 0x40 )
    {
      sub_1006DD80(v3 + 64, v3);
      *(_DWORD *)(v3 + 156) = 20;
    }
    memset((void *)(v3 + *(_DWORD *)(v3 + 156)), 0, 64 - *(_DWORD *)(v3 + 156));
    v5 = 0;
    do
      *(_DWORD *)(v3 + 4 * v5++) ^= 0x36363636u;
    while ( v5 < 0x10 );
    v6 = (_DWORD *)sub_1006C620(v3 + 64);
    result = sub_1006DE80(0x40u, (char *)v3, v6);
    *(_DWORD *)(v3 + 156) = -1;
  }
  if ( a2 )
    result = sub_1006DE80(a2, a3, (_DWORD *)(v3 + 64));
  return result;
}

//----- (1006DFA0) --------------------------------------------------------
int __usercall sub_1006DFA0@<eax>(int a1@<edi>, int a2, size_t a3)
{
  unsigned int v3; // eax@3
  int result; // eax@5
  char v5; // [sp+8h] [bp-18h]@3

  if ( *(_DWORD *)(a1 + 156) != -1 )
    sub_1006DF00(a1, 0, 0);
  sub_1006DD80(a1 + 64, (int)&v5);
  v3 = 0;
  do
    *(_DWORD *)(a1 + 4 * v3++) ^= 0x6A6A6A6Au;
  while ( v3 < 0x10 );
  sub_1006C620(a1 + 64);
  sub_1006DE80(0x40u, (char *)a1, (_DWORD *)(a1 + 64));
  sub_1006DE80(0x14u, &v5, (_DWORD *)(a1 + 64));
  result = sub_1006DD80(a1 + 64, (int)&v5);
  if ( a3 )
    result = (int)memcpy((void *)a2, &v5, a3);
  return result;
}

//----- (1006E060) --------------------------------------------------------
int __usercall sub_1006E060@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3)
{
  int v3; // eax@1
  int result; // eax@2

  v3 = *(_DWORD *)(a2 + 156);
  if ( v3 + a1 <= 0x40 )
  {
    memcpy((void *)(a2 + v3), a3, a1);
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  else
  {
    sub_1006C620(a2 + 64);
    sub_1006DE80(*(_DWORD *)(a2 + 156), (char *)a2, (_DWORD *)(a2 + 64));
    sub_1006DE80(a1, (char *)a3, (_DWORD *)(a2 + 64));
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  return result;
}

//----- (1006E0C0) --------------------------------------------------------
int __usercall sub_1006E0C0@<eax>(char *a1@<edi>)
{
  unsigned int v1; // ebp@1
  signed int v2; // eax@2
  int v3; // edx@4
  int v4; // ecx@4
  int v5; // edx@4
  unsigned int v6; // esi@4
  size_t v7; // eax@4
  int v8; // ebx@6
  int v9; // edx@8
  int result; // eax@8
  int v11; // ecx@8
  int v12; // edx@8
  char v13; // [sp+Ch] [bp-5Ch]@8
  int v14; // [sp+14h] [bp-54h]@4
  int v15; // [sp+18h] [bp-50h]@4
  int v16; // [sp+1Ch] [bp-4Ch]@4
  int v17; // [sp+20h] [bp-48h]@4
  int v18; // [sp+24h] [bp-44h]@4
  char v19[64]; // [sp+28h] [bp-40h]@6

  v1 = 0;
  do
  {
    v2 = v1;
    if ( !v1 )
      v2 = 260;
    v3 = *(_DWORD *)&a1[v2 - 16];
    v14 = *(_DWORD *)&a1[v2 - 20];
    v4 = *(_DWORD *)&a1[v2 - 12];
    v15 = v3;
    v5 = *(_DWORD *)&a1[v2 - 8];
    v6 = 260 - v1;
    v18 = *(_DWORD *)&a1[v2 - 4];
    v16 = v4;
    v17 = v5;
    v7 = 64;
    if ( 260 - v1 <= 0x40 )
      v7 = 260 - v1;
    v8 = (int)&a1[v1];
    memcpy(v19, &a1[v1], v7);
    if ( v6 < 0x40 )
      memcpy(&v19[v6], a1, 64 - v6);
    sub_1006C660((int)&v13);
    v9 = v15;
    result = v16;
    *(_DWORD *)v8 = v14;
    v11 = v17;
    *(_DWORD *)(v8 + 4) = v9;
    v12 = v18;
    *(_DWORD *)(v8 + 8) = result;
    v1 += 20;
    *(_DWORD *)(v8 + 12) = v11;
    *(_DWORD *)(v8 + 16) = v12;
  }
  while ( v1 < 0x104 );
  return result;
}
// 1006E0C0: using guessed type char var_40[64];

//----- (1006E180) --------------------------------------------------------
int __usercall sub_1006E180@<eax>(int a1@<ebx>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // eax@3
  char v3; // cl@4
  char v4; // dl@4
  char v5; // cl@4
  char v6; // dl@4
  char *v8; // [sp+Ch] [bp-4h]@1

  v8 = (char *)(a1 + 260);
  v1 = 0;
  qmemcpy((void *)(a1 + 260), (const void *)a1, 0x104u);
  do
    v1 += (*(int (__cdecl **)(unsigned int, unsigned int))(a1 + 524))(a1 + v1, 260 - v1);
  while ( v1 < 0x104 );
  v2 = 0;
  do
  {
    v3 = *(_BYTE *)(v2 + a1 + 261);
    *(_BYTE *)(v2 + a1) ^= ~v8[v2];
    v4 = *(_BYTE *)(v2 + a1 + 262);
    *(_BYTE *)(v2 + a1 + 1) ^= ~v3;
    v5 = *(_BYTE *)(v2 + a1 + 263);
    *(_BYTE *)(v2 + a1 + 2) ^= ~v4;
    v6 = *(_BYTE *)(v2 + a1 + 264);
    *(_BYTE *)(v2 + a1 + 3) ^= ~v5;
    *(_BYTE *)(v2 + a1 + 4) ^= ~v6;
    v2 += 5;
  }
  while ( v2 < 0x104 );
  sub_1006E0C0((char *)a1);
  return sub_1006E0C0(v8);
}

//----- (1006E240) --------------------------------------------------------
char __cdecl sub_1006E240(char *a1, size_t a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_1006DF00(a3 + 296, a2, a1);
    sub_1006B7C0(a3, (int)a1, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1006E290) --------------------------------------------------------
char __cdecl sub_1006E290(char *a1, unsigned int a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_1006B7C0(a3, (int)a1, a2);
    sub_1006DF00(a3 + 296, a2, a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1006E2E0) --------------------------------------------------------
bool __cdecl sub_1006E2E0(int a1, int a2)
{
  if ( a2 )
    sub_1006DFA0(a2 + 296, a1, 0xAu);
  return a2 != 0;
}

//----- (1006E310) --------------------------------------------------------
int __usercall sub_1006E310@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7)
{
  void *v7; // esi@1
  char *v8; // ebx@1
  int result; // eax@1
  unsigned int v10; // edx@1
  unsigned int v11; // ebx@2
  size_t v12; // edx@3
  char v13; // al@6
  char v14; // al@6
  bool v15; // zf@7
  unsigned int v16; // eax@9
  unsigned int v17; // ecx@9
  int *v18; // [sp+10h] [bp-228h]@2
  unsigned int v19; // [sp+14h] [bp-224h]@2
  int v20; // [sp+18h] [bp-220h]@4
  signed int v21; // [sp+1Ch] [bp-21Ch]@2
  unsigned int v22; // [sp+20h] [bp-218h]@1
  char v23; // [sp+28h] [bp-210h]@3
  char v24; // [sp+C8h] [bp-170h]@1
  char v25; // [sp+168h] [bp-D0h]@1
  int v26; // [sp+20Ch] [bp-2Ch]@2
  int v27; // [sp+210h] [bp-28h]@3
  int v28; // [sp+214h] [bp-24h]@3
  int v29; // [sp+218h] [bp-20h]@3
  int v30; // [sp+21Ch] [bp-1Ch]@3
  int v31; // [sp+220h] [bp-18h]@3
  char v32[16]; // [sp+224h] [bp-14h]@6

  v7 = a2;
  v8 = a1;
  sub_1006C5A0(&v24);
  sub_1006E060(a3, (int)&v24, v7);
  qmemcpy(&v25, &v24, 0xA0u);
  sub_1006DF00((int)&v25, a4, v8);
  result = -858993459 * (a7 - 1);
  v10 = (a7 - 1) / 0x14;
  v22 = v10 + 1;
  if ( v10 != -1 )
  {
    v11 = 1;
    v19 = 0;
    v21 = 1;
    v18 = &v26;
    do
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      qmemcpy(&v23, &v25, 0xA0u);
      LOBYTE(v31) = BYTE3(v11);
      BYTE2(v31) = BYTE1(v11);
      BYTE1(v31) = v11 >> 16;
      BYTE3(v31) = v11;
      v12 = 4;
      if ( a5 )
      {
        v20 = a5;
        do
        {
          sub_1006DF00((int)&v23, v12, (char *)&v31);
          sub_1006DFA0((int)&v23, (int)&v31, 0x14u);
          v12 = 0;
          do
          {
            *((_BYTE *)&v26 + v12) ^= *((_BYTE *)&v31 + v12);
            v13 = *((_BYTE *)&v31 + v12 + 2);
            *((_BYTE *)&v26 + v12 + 1) ^= *((_BYTE *)&v31 + v12 + 1);
            *((_BYTE *)&v26 + v12 + 2) ^= v13;
            v14 = v32[v12];
            *((_BYTE *)&v26 + v12 + 3) ^= *((_BYTE *)&v31 + v12 + 3);
            *((_BYTE *)&v27 + v12) ^= v14;
            v12 += 5;
          }
          while ( v12 < 0x14 );
          v15 = v20-- == 1;
          qmemcpy(&v23, &v24, 0xA0u);
        }
        while ( !v15 );
        v11 = v21;
      }
      v16 = v19;
      v17 = 0;
      do
      {
        if ( v16 >= a7 )
          break;
        *(_BYTE *)(v16 + a6) = *((_BYTE *)v18 + v16);
        ++v17;
        ++v16;
      }
      while ( v17 < 0x14 );
      v19 += 20;
      v18 -= 5;
      result = ++v11 - 1;
      v21 = v11;
    }
    while ( v11 - 1 < v22 );
  }
  return result;
}
// 1006E310: using guessed type char var_14[16];

//----- (1006E520) --------------------------------------------------------
int __usercall sub_1006E520@<eax>(void *a1@<eax>, int a2)
{
  int v2; // ebx@1
  signed int v3; // esi@1

  v2 = (int)a1;
  memset(a1, 0, 0x210u);
  *(_DWORD *)(v2 + 524) = a2;
  sub_1006E180(v2);
  v3 = 20;
  do
  {
    sub_1006E0C0((char *)v2);
    --v3;
  }
  while ( v3 );
  return sub_1006E180(v2);
}

//----- (1006E570) --------------------------------------------------------
char *__cdecl sub_1006E570(int a1, int a2)
{
  void *v2; // ecx@0
  char *result; // eax@1
  unsigned int v4; // ebp@1
  int v5; // edi@1
  char *v6; // ebx@1
  size_t v7; // esi@4

  result = (char *)a2;
  v4 = a1;
  v5 = *(_DWORD *)(a2 + 520);
  v6 = (char *)v2;
  if ( a1 )
  {
    while ( 1 )
    {
      v7 = 260 - v5;
      if ( v4 < 260 - v5 )
        v7 = v4;
      result = (char *)memcpy(v6, &result[v5 + 260], v7);
      v6 += v7;
      v5 += v7;
      v4 -= v7;
      if ( v5 == 260 )
      {
        result = (char *)sub_1006E180(a2);
        v5 = 0;
      }
      if ( !v4 )
        break;
      result = (char *)a2;
    }
    *(_DWORD *)(a2 + 520) = v5;
  }
  else
  {
    *(_DWORD *)(a2 + 520) = v5;
  }
  return result;
}

//----- (1006E600) --------------------------------------------------------
signed int __cdecl sub_1006E600(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6)
{
  signed int result; // eax@2
  int v7; // ebx@6
  char v8; // [sp+Ch] [bp-48h]@6
  char v9[8]; // [sp+14h] [bp-40h]@6
  __int16 v10[26]; // [sp+1Ch] [bp-38h]@6

  if ( a3 <= 0x80 )
  {
    if ( (unsigned __int8)(a1 - 1) > 2u )
    {
      result = -101;
    }
    else if ( a6 )
    {
      *(_BYTE *)(a6 + 464) = a1;
      v7 = a1 & 3;
      *(_DWORD *)(a6 + 460) = a3;
      sub_1006E310(a4, a2, a3, 4 * v7 + 4, 1000, (int)&v8, 16 * v7 + 18);
      *(_DWORD *)(a6 + 456) = 16;
      *(_DWORD *)a6 = 0;
      *(_DWORD *)(a6 + 4) = 0;
      *(_DWORD *)(a6 + 8) = 0;
      *(_DWORD *)(a6 + 12) = 0;
      sub_1006B820(a6 + 32, (int)&v8, 8 * v7 + 8);
      sub_1006C5A0((void *)(a6 + 296));
      sub_1006E060(8 * v7 + 8, a6 + 296, &v9[8 * v7]);
      *a5 = v10[8 * v7];
      result = 0;
    }
    else
    {
      result = -102;
    }
  }
  else
  {
    result = -100;
  }
  return result;
}
// 1006E600: using guessed type char var_40[8];
// 1006E600: using guessed type __int16 var_38[26];

//----- (1006E730) --------------------------------------------------------
bool __cdecl sub_1006E730(void *a1, int a2)
{
  bool v2; // bl@3
  int v4; // [sp+Ch] [bp-214h]@5

  v2 = a1 && a2;
  sub_1006E520(&v4, (int)sub_1006C5C0);
  if ( v2 )
    sub_1006E570(a2, (int)&v4);
  return v2;
}

//----- (1006E7B0) --------------------------------------------------------
BOOL __usercall sub_1006E7B0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // ecx@3
  int v4; // ecx@4

  *(_WORD *)(*(_DWORD *)(a1 + 5712) + 2 * *(_DWORD *)(a1 + 5728)) = a3;
  *(_BYTE *)(*(_DWORD *)(a1 + 5716) + (*(_DWORD *)(a1 + 5728))++) = a2;
  if ( a3 )
  {
    ++*(_DWORD *)(a1 + 2920);
    ++*(_WORD *)(a1 + 4 * (unsigned __int8)byte_10156CF0[a2] + 3964);
    v3 = a3 - 1;
    if ( v3 >= 0x100 )
      v4 = (unsigned __int8)byte_10156BF0[v3 >> 7];
    else
      v4 = (unsigned __int8)byte_10156AF0[v3];
    ++*(_WORD *)(a1 + 4 * v4 + 5228);
  }
  else
  {
    ++*(_WORD *)(a1 + 4 * a2 + 2936);
  }
  return *(_DWORD *)(a1 + 5728) == *(_DWORD *)(a1 + 5724) - 1;
}

//----- (1006E850) --------------------------------------------------------
int __usercall sub_1006E850@<eax>(int result@<eax>)
{
  signed int v1; // ecx@1
  __int16 v2; // cx@4

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)((*(_DWORD *)(result + 5812))++ + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
    *(_DWORD *)(result + 2932) = 0;
    *(_WORD *)(result + 2924) = 0;
  }
  else if ( v1 >= 8 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) -= 8;
    *(_WORD *)(result + 2924) = v2;
  }
  return result;
}

//----- (1006E8E0) --------------------------------------------------------
unsigned int __fastcall sub_1006E8E0(unsigned int a1, int a2)
{
  unsigned int v2; // eax@1
  int v3; // esi@2

  v2 = 0;
  do
  {
    v3 = a1 & 1;
    --a2;
    a1 >>= 1;
    v2 = 2 * (v3 | v2);
  }
  while ( a2 > 0 );
  return v2 >> 1;
}

//----- (1006E900) --------------------------------------------------------
int __usercall sub_1006E900@<eax>(int result@<eax>)
{
  signed int v1; // edx@1
  char v2; // bl@2
  int v3; // edx@2

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 <= 8 )
  {
    if ( v1 > 0 )
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    v3 = *(_DWORD *)(result + 5800);
    *(_BYTE *)(++*(_DWORD *)(result + 5812) + v3) = v2;
    ++*(_DWORD *)(result + 5812);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  return result;
}

//----- (1006E990) --------------------------------------------------------
int __usercall sub_1006E990@<eax>(int result@<eax>, int a2, int a3)
{
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // ebp@2
  int v6; // esi@2
  int v7; // ecx@2
  int v8; // edi@3
  int v9; // esi@4
  int v10; // edx@4
  int v11; // ecx@4
  int v12; // edx@4
  int v13; // ecx@4
  int v14; // edx@6
  int v15; // edi@7
  int v16; // edx@7
  int v17; // ecx@7
  int v18; // edx@7
  int v19; // edi@9
  int v20; // esi@10
  int v21; // ecx@10
  int v22; // edx@11
  int v23; // ecx@11
  int v24; // edx@11
  int v25; // ecx@11
  unsigned int v26; // ebp@14
  int v27; // edi@15
  int v28; // edx@17
  int v29; // ecx@17
  unsigned __int16 v30; // si@18
  int v31; // edx@18
  int v32; // ecx@18
  int v33; // edx@18
  int v34; // esi@20
  int v35; // ecx@21
  int v36; // ebp@21
  int v37; // edx@22
  int v38; // ecx@22
  int v39; // edx@22
  int v40; // edi@26
  int v41; // ecx@26
  unsigned __int16 v42; // si@27
  int v43; // edx@27
  int v44; // ecx@27
  int v45; // edx@27
  int v46; // [sp+10h] [bp-Ch]@6
  int v47; // [sp+14h] [bp-8h]@6
  int v48; // [sp+14h] [bp-8h]@17
  unsigned int v49; // [sp+18h] [bp-4h]@2

  v3 = a2;
  v4 = 0;
  if ( *(_DWORD *)(result + 5728) )
  {
    do
    {
      v5 = *(_WORD *)(*(_DWORD *)(result + 5712) + 2 * v4);
      v6 = *(_BYTE *)(v4 + *(_DWORD *)(result + 5716));
      v49 = v4 + 1;
      v7 = *(_DWORD *)(result + 2932);
      if ( v5 )
      {
        v14 = (unsigned __int8)byte_10156CF0[v6];
        v46 = *(_WORD *)(v3 + 4 * v14 + 1030);
        v47 = (unsigned __int8)byte_10156CF0[v6];
        if ( v7 <= 16 - v46 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a2 + 4 * v14 + 1028) << v7;
          *(_DWORD *)(result + 2932) = v46 + v7;
        }
        else
        {
          v15 = *(_WORD *)(a2 + 4 * v14 + 1028);
          v16 = v15 << v7;
          v17 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v16;
          *(_BYTE *)(v17 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v18 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          LOWORD(v15) = (unsigned __int16)v15 >> (16 - v18);
          *(_DWORD *)(result + 2932) = v18 + v46 - 16;
          v14 = v47;
          *(_WORD *)(result + 2924) = v15;
        }
        v19 = dword_101564F8[v14];
        v3 = a2;
        if ( v19 )
        {
          v20 = v6 - dword_10156DF0[v14];
          v21 = *(_DWORD *)(result + 2932);
          if ( v21 <= 16 - v19 )
          {
            *(_WORD *)(result + 2924) |= v20 << v21;
            v25 = v19 + v21;
          }
          else
          {
            v22 = v20 << v21;
            v23 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v22;
            *(_BYTE *)(v23 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v24 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v3 = a2;
            v25 = v24 + v19 - 16;
            *(_WORD *)(result + 2924) = (unsigned __int16)v20 >> (16 - v24);
          }
          *(_DWORD *)(result + 2932) = v25;
        }
        v26 = v5 - 1;
        if ( v26 >= 0x100 )
          v27 = (unsigned __int8)byte_10156BF0[v26 >> 7];
        else
          v27 = (unsigned __int8)byte_10156AF0[v26];
        v28 = *(_WORD *)(a3 + 4 * v27 + 2);
        v29 = *(_DWORD *)(result + 2932);
        v48 = *(_WORD *)(a3 + 4 * v27 + 2);
        if ( v29 <= 16 - v28 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a3 + 4 * v27) << v29;
          *(_DWORD *)(result + 2932) = v28 + v29;
        }
        else
        {
          v30 = *(_WORD *)(a3 + 4 * v27);
          v31 = *(_WORD *)(a3 + 4 * v27) << v29;
          v32 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v31;
          *(_BYTE *)(v32 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v33 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v3 = a2;
          *(_DWORD *)(result + 2932) = v33 + v48 - 16;
          *(_WORD *)(result + 2924) = v30 >> (16 - v33);
        }
        v34 = dword_10156580[v27];
        if ( !v34 )
          goto LABEL_25;
        v35 = *(_DWORD *)(result + 2932);
        v36 = v26 - dword_10156E68[v27];
        if ( v35 <= 16 - v34 )
        {
          *(_WORD *)(result + 2924) |= v36 << v35;
          v13 = v34 + v35;
        }
        else
        {
          v37 = v36 << v35;
          v38 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v37;
          *(_BYTE *)(v38 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v39 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v39 + v34 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v36 >> (16 - v39);
        }
      }
      else
      {
        v8 = *(_WORD *)(v3 + 4 * v6 + 2);
        if ( v7 <= 16 - v8 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 4 * v6) << v7;
          v13 = v8 + v7;
        }
        else
        {
          v9 = *(_WORD *)(v3 + 4 * v6);
          v10 = v9 << v7;
          v11 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v10;
          *(_BYTE *)(v11 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v12 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v12 + v8 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v9 >> (16 - v12);
        }
      }
      *(_DWORD *)(result + 2932) = v13;
LABEL_25:
      v4 = v49;
    }
    while ( v49 < *(_DWORD *)(result + 5728) );
  }
  v40 = *(_WORD *)(v3 + 1026);
  v41 = *(_DWORD *)(result + 2932);
  if ( v41 <= 16 - v40 )
  {
    *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 1024) << v41;
    *(_DWORD *)(result + 2932) = v40 + v41;
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  else
  {
    v42 = *(_WORD *)(v3 + 1024);
    v43 = *(_WORD *)(v3 + 1024) << v41;
    v44 = *(_DWORD *)(result + 5800);
    *(_WORD *)(result + 2924) |= v43;
    *(_BYTE *)(v44 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2925);
    v45 = *(_DWORD *)(result + 2932);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) = v45 + v40 - 16;
    *(_WORD *)(result + 2924) = v42 >> (16 - v45);
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  return result;
}
// 101564F8: using guessed type int dword_101564F8[];
// 10156580: using guessed type int dword_10156580[];
// 10156DF0: using guessed type int dword_10156DF0[];
// 10156E68: using guessed type int dword_10156E68[];

//----- (1006EE10) --------------------------------------------------------
int __usercall sub_1006EE10@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  _BYTE *v4; // edi@1
  int result; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // edx@1
  int i; // esi@1

  v3 = a3;
  v4 = a2;
  result = sub_1006E900(a1);
  v6 = *(_DWORD *)(result + 5812);
  v7 = *(_DWORD *)(result + 5800);
  *(_DWORD *)(result + 2928) = 8;
  *(_BYTE *)(v6 + v7) = v3;
  v8 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v8) = BYTE1(v3);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~(_BYTE)v3;
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~BYTE1(v3);
  for ( i = ++*(_DWORD *)(result + 5812); v3; ++v4 )
  {
    *(_BYTE *)(i + *(_DWORD *)(result + 5800)) = *v4;
    i = ++*(_DWORD *)(result + 5812);
    --v3;
  }
  return result;
}

//----- (1006EEC0) --------------------------------------------------------
void *__usercall sub_1006EEC0@<eax>(int a1@<edi>)
{
  void *result; // eax@1
  int v2; // ebx@1
  size_t v3; // esi@1
  bool v4; // zf@4

  result = *(void **)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(v2 + 5812);
  if ( v3 > (unsigned int)result )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    result = memcpy(*(void **)(a1 + 12), *(const void **)(v2 + 5808), v3);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v2 + 5808) += v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) -= v3;
    v4 = *(_DWORD *)(v2 + 5812) == v3;
    *(_DWORD *)(v2 + 5812) -= v3;
    if ( v4 )
      *(_DWORD *)(v2 + 5808) = *(_DWORD *)(v2 + 5800);
  }
  return result;
}

//----- (1006EF20) --------------------------------------------------------
int __usercall sub_1006EF20@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx@1
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@3
  int v9; // ecx@3
  int v10; // esi@6
  int v11; // ebx@8
  int i; // ecx@13
  int v13; // edx@17
  int v14; // ebx@18
  int v15; // ecx@19
  int v16; // esi@20
  int v17; // [sp+Ch] [bp-20h]@1
  int *v18; // [sp+10h] [bp-1Ch]@2
  int v19; // [sp+10h] [bp-1Ch]@17
  signed int v20; // [sp+14h] [bp-18h]@2
  int v21; // [sp+18h] [bp-14h]@1
  int v22; // [sp+1Ch] [bp-10h]@2
  int v23; // [sp+20h] [bp-Ch]@1
  int v24; // [sp+24h] [bp-8h]@1
  int v25; // [sp+28h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)a2;
  v24 = *(_DWORD *)(v2 + 8);
  v4 = *(_DWORD *)(v2 + 16);
  v21 = *(_DWORD *)v2;
  v25 = *(_DWORD *)(v2 + 4);
  v5 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  v23 = v5;
  v6 = 0;
  *(_WORD *)(v3 + 4 * *(_DWORD *)(result + 4 * *(_DWORD *)(result + 2328) + 32) + 2) = 0;
  v7 = *(_DWORD *)(result + 2328) + 1;
  v17 = 0;
  if ( v7 < 573 )
  {
    v18 = (int *)(result + 4 * v7 + 32);
    v22 = 573 - v7;
    v20 = 573;
    do
    {
      v8 = *v18;
      v9 = *(_WORD *)(v3 + 4 * *(_WORD *)(v3 + 4 * *v18 + 2) + 2) + 1;
      if ( v9 > v4 )
      {
        ++v6;
        v9 = v4;
        v17 = v6;
      }
      *(_WORD *)(v3 + 4 * v8 + 2) = v9;
      if ( v8 <= v23 )
      {
        ++*(_WORD *)(result + 2 * v9);
        v10 = 0;
        if ( v8 >= v24 )
          v10 = *(_DWORD *)(v25 + 4 * (v8 - v24));
        v11 = *(_WORD *)(v3 + 4 * v8);
        *(_DWORD *)(result + 2912) += v11 * (v10 + v9);
        if ( v21 )
          *(_DWORD *)(result + 2916) += v11 * (v10 + *(_WORD *)(v21 + 4 * v8 + 2));
        v6 = v17;
      }
      ++v18;
      --v22;
    }
    while ( v22 );
    if ( v6 )
    {
      do
      {
        for ( i = v4 - 1; !*(_WORD *)(result + 2 * i); --i )
          ;
        --*(_WORD *)(result + 2 * i);
        *(_WORD *)(result + 2 * i + 2) += 2;
        --*(_WORD *)(result + 2 * v4);
        v6 -= 2;
      }
      while ( v6 > 0 );
      for ( ; v4; --v4 )
      {
        v13 = *(_WORD *)(result + 2 * v4);
        v19 = *(_WORD *)(result + 2 * v4);
        if ( *(_WORD *)(result + 2 * v4) )
        {
          v14 = result + 4 * v20 + 32;
          do
          {
            v15 = *(_DWORD *)(v14 - 4);
            --v20;
            v14 -= 4;
            if ( v15 <= v23 )
            {
              v16 = *(_WORD *)(v3 + 4 * v15 + 2);
              if ( v16 != v4 )
              {
                *(_DWORD *)(result + 2912) += *(_WORD *)(v3 + 4 * v15) * (v4 - v16);
                *(_WORD *)(v3 + 4 * v15 + 2) = v4;
              }
              v13 = --v19;
            }
          }
          while ( v13 );
        }
      }
    }
  }
  return result;
}

//----- (1006F0F0) --------------------------------------------------------
signed int __usercall sub_1006F0F0@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // cx@1
  signed int result; // eax@1
  int v5; // edx@1
  int i; // esi@3
  int v7; // edx@4
  unsigned int v8; // ecx@5
  __int16 v9; // [sp+4h] [bp-24h]@2
  char v10; // [sp+6h] [bp-22h]@1

  v3 = 0;
  result = 1;
  v5 = a1 - (_DWORD)&v10;
  do
  {
    v3 = 2 * (v3 + *(__int16 *)((char *)&v9 + 2 * result + v5));
    *(&v9 + result++) = v3;
  }
  while ( result <= 15 );
  for ( i = 0; i <= a2; ++i )
  {
    v7 = *(_WORD *)(a3 + 4 * i + 2);
    if ( *(_WORD *)(a3 + 4 * i + 2) )
    {
      v8 = (unsigned __int16)(*(&v9 + v7))++;
      result = sub_1006E8E0(v8, v7);
      *(_WORD *)(a3 + 4 * i) = result;
    }
  }
  return result;
}

//----- (1006F170) --------------------------------------------------------
_WORD *__fastcall sub_1006F170(int a1, int a2)
{
  _WORD *v2; // eax@1
  signed int v3; // ecx@1
  _WORD *v4; // eax@3
  signed int v5; // ecx@3
  _WORD *result; // eax@5
  signed int v7; // ecx@5

  v2 = (_WORD *)(a2 + 2936);
  v3 = 286;
  do
  {
    *v2 = 0;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  v4 = (_WORD *)(a2 + 5228);
  v5 = 30;
  do
  {
    *v4 = 0;
    v4 += 2;
    --v5;
  }
  while ( v5 );
  result = (_WORD *)(a2 + 5472);
  v7 = 19;
  do
  {
    *result = 0;
    result += 2;
    --v7;
  }
  while ( v7 );
  *(_DWORD *)(a2 + 2916) = 0;
  *(_DWORD *)(a2 + 2912) = 0;
  *(_DWORD *)(a2 + 2920) = 0;
  *(_DWORD *)(a2 + 5728) = 0;
  *(_WORD *)(a2 + 3960) = 1;
  return result;
}

//----- (1006F1E0) --------------------------------------------------------
signed int __usercall sub_1006F1E0@<eax>(int a1@<esi>)
{
  int v1; // ecx@1
  int v2; // edx@1
  int v3; // eax@1
  int v4; // edx@1
  signed int result; // eax@1

  v1 = *(_DWORD *)(a1 + 5764);
  v2 = *(_DWORD *)(a1 + 5736);
  *(_DWORD *)(a1 + 5744) = 2 * *(_DWORD *)(a1 + 5748);
  *(_WORD *)(v2 + 2 * v1 - 2) = 0;
  memset(*(void **)(a1 + 5736), 0, 2 * *(_DWORD *)(a1 + 5764) - 2);
  v3 = 6 * *(_BYTE *)(a1 + 5784);
  *(_DWORD *)(a1 + 5700) = (unsigned __int16)word_10156EE2[6 * *(_BYTE *)(a1 + 5784)];
  *(_DWORD *)(a1 + 5704) = (unsigned __int16)word_10156EE0[v3];
  *(_DWORD *)(a1 + 5708) = (unsigned __int16)word_10156EE4[v3];
  v4 = (unsigned __int16)word_10156EE6[v3];
  result = 2;
  *(_DWORD *)(a1 + 5680) = 0;
  *(_DWORD *)(a1 + 5664) = 0;
  *(_DWORD *)(a1 + 5688) = 0;
  *(_DWORD *)(a1 + 5676) = 0;
  *(_DWORD *)(a1 + 5760) = 0;
  *(_DWORD *)(a1 + 5696) = v4;
  *(_DWORD *)(a1 + 5692) = 2;
  *(_DWORD *)(a1 + 5668) = 2;
  return result;
}
// 10156EE0: using guessed type __int16 word_10156EE0[];
// 10156EE2: using guessed type __int16 word_10156EE2[];
// 10156EE4: using guessed type __int16 word_10156EE4[];
// 10156EE6: using guessed type __int16 word_10156EE6[];

//----- (1006F2A0) --------------------------------------------------------
unsigned int __usercall sub_1006F2A0@<eax>(int a1@<esi>, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // edi@1
  int v6; // ecx@4
  unsigned int v7; // ebx@4
  int v8; // edx@8
  char v9; // al@11
  int v10; // edx@11
  unsigned int v11; // ecx@12
  _BYTE *v12; // edx@12
  char v13; // al@13
  _BYTE *v14; // edx@13
  char v15; // al@14
  _BYTE *v16; // edx@14
  char v17; // al@15
  _BYTE *v18; // edx@15
  char v19; // al@16
  _BYTE *v20; // edx@16
  char v21; // al@17
  _BYTE *v22; // edx@17
  char v23; // al@18
  _BYTE *v24; // edx@18
  char v25; // al@19
  _BYTE *v26; // edx@19
  char v27; // al@20
  int v28; // edx@22
  unsigned int result; // eax@27
  char v30; // [sp+Fh] [bp-11h]@4
  unsigned int v31; // [sp+10h] [bp-10h]@1
  int v32; // [sp+14h] [bp-Ch]@4
  unsigned int v33; // [sp+18h] [bp-8h]@2
  char v34; // [sp+24h] [bp+4h]@4

  v2 = *(_DWORD *)(a1 + 5748);
  v3 = *(_DWORD *)(a1 + 5680);
  v4 = a2;
  v31 = *(_DWORD *)(a1 + 5696);
  v5 = *(_DWORD *)(a1 + 5692);
  if ( v3 <= v2 - 262 )
    v33 = 0;
  else
    v33 = v3 - v2 + 262;
  v6 = *(_DWORD *)(a1 + 5740) + v3;
  v34 = *(_BYTE *)(v6 + v5 - 1);
  v32 = *(_DWORD *)(a1 + 5708);
  v7 = v6 + 258;
  v30 = *(_BYTE *)(v6 + v5);
  if ( v5 >= *(_DWORD *)(a1 + 5704) )
    v31 >>= 2;
  if ( *(_DWORD *)(a1 + 5708) > *(_DWORD *)(a1 + 5688) )
    v32 = *(_DWORD *)(a1 + 5688);
  do
  {
    v8 = v4 + *(_DWORD *)(a1 + 5740);
    if ( *(_BYTE *)(v8 + v5) == v30 && *(_BYTE *)(v8 + v5 - 1) == v34 && *(_BYTE *)v8 == *(_BYTE *)v6 )
    {
      v9 = *(_BYTE *)(v8 + 1);
      v10 = v8 + 1;
      if ( v9 == *(_BYTE *)(v6 + 1) )
      {
        v11 = v6 + 2;
        v12 = (_BYTE *)(v10 + 1);
        do
        {
          v13 = *(_BYTE *)(v11++ + 1);
          v14 = v12 + 1;
          if ( v13 != *v14 )
            break;
          v15 = *(_BYTE *)(v11++ + 1);
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *(_BYTE *)(v11++ + 1);
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *(_BYTE *)(v11++ + 1);
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *(_BYTE *)(v11++ + 1);
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *(_BYTE *)(v11++ + 1);
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *(_BYTE *)(v11++ + 1);
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *(_BYTE *)(v11++ + 1);
          v12 = v26 + 1;
          if ( v27 != *v12 )
            break;
        }
        while ( v11 < v7 );
        v28 = v11 - v7 + 258;
        v6 = v7 - 258;
        if ( v28 > (signed int)v5 )
        {
          *(_DWORD *)(a1 + 5684) = v4;
          v5 = v28;
          if ( v28 >= v32 )
            break;
          v34 = *(_BYTE *)(v28 + v6 - 1);
          v30 = *(_BYTE *)(v28 + v6);
        }
      }
    }
    v4 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & *(_DWORD *)(a1 + 5756)));
    if ( v4 <= v33 )
      break;
    --v31;
  }
  while ( v31 );
  result = *(_DWORD *)(a1 + 5688);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (1006F450) --------------------------------------------------------
unsigned int __usercall sub_1006F450@<eax>(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  unsigned int v6; // edi@1
  unsigned int v7; // eax@3
  _BYTE *v8; // ecx@3
  char v9; // dl@4
  _BYTE *v10; // ecx@4
  char v11; // dl@5
  _BYTE *v12; // ecx@5
  char v13; // dl@6
  _BYTE *v14; // ecx@6
  char v15; // dl@7
  _BYTE *v16; // ecx@7
  char v17; // dl@8
  _BYTE *v18; // ecx@8
  char v19; // dl@9
  _BYTE *v20; // ecx@9
  char v21; // dl@10
  _BYTE *v22; // ecx@10
  char v23; // dl@11
  unsigned int v24; // ecx@13
  unsigned int result; // eax@13

  v2 = *(_DWORD *)(a1 + 5740);
  v3 = *(_BYTE *)(v2 + a2);
  v4 = v2 + *(_DWORD *)(a1 + 5680);
  v5 = a2 + v2;
  v6 = v4 + 258;
  if ( v3 != *(_BYTE *)v4 || *(_BYTE *)(v5 + 1) != *(_BYTE *)(v4 + 1) )
  {
    result = 2;
  }
  else
  {
    v7 = v4 + 2;
    v8 = (_BYTE *)(v5 + 2);
    do
    {
      v9 = *(_BYTE *)(v7++ + 1);
      v10 = v8 + 1;
      if ( v9 != *v10 )
        break;
      v11 = *(_BYTE *)(v7++ + 1);
      v12 = v10 + 1;
      if ( v11 != *v12 )
        break;
      v13 = *(_BYTE *)(v7++ + 1);
      v14 = v12 + 1;
      if ( v13 != *v14 )
        break;
      v15 = *(_BYTE *)(v7++ + 1);
      v16 = v14 + 1;
      if ( v15 != *v16 )
        break;
      v17 = *(_BYTE *)(v7++ + 1);
      v18 = v16 + 1;
      if ( v17 != *v18 )
        break;
      v19 = *(_BYTE *)(v7++ + 1);
      v20 = v18 + 1;
      if ( v19 != *v20 )
        break;
      v21 = *(_BYTE *)(v7++ + 1);
      v22 = v20 + 1;
      if ( v21 != *v22 )
        break;
      v23 = *(_BYTE *)(v7++ + 1);
      v8 = v22 + 1;
      if ( v23 != *v8 )
        break;
    }
    while ( v7 < v6 );
    v24 = *(_DWORD *)(a1 + 5688);
    result = v7 - v6 + 258;
    *(_DWORD *)(a1 + 5684) = a2;
    if ( result > v24 )
      result = v24;
  }
  return result;
}

//----- (1006F520) --------------------------------------------------------
int __usercall sub_1006F520@<eax>(int result@<eax>, int a2@<edi>, int a3)
{
  int v3; // edx@1
  int v4; // ebp@1
  int v5; // ecx@1
  bool v6; // sf@1
  unsigned __int8 v7; // of@1
  int v8; // esi@3
  int v9; // ebp@3
  unsigned __int16 v10; // dx@3
  unsigned __int16 v11; // bx@3
  int v12; // esi@8
  unsigned __int16 v13; // dx@8
  unsigned __int16 v14; // bx@8
  int v15; // edx@11
  int v16; // [sp+8h] [bp-4h]@1

  v3 = *(_DWORD *)(result + 2324);
  v4 = *(_DWORD *)(result + 4 * a3 + 32);
  v5 = 2 * a3;
  v7 = __OFSUB__(2 * a3, v3);
  v6 = 2 * a3 - v3 < 0;
  v16 = *(_DWORD *)(result + 4 * a3 + 32);
  if ( 2 * a3 > v3 )
  {
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  else
  {
    while ( 1 )
    {
      if ( v6 ^ v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v5 + 36);
        v9 = *(_DWORD *)(result + 4 * v5 + 32);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 2332) <= *(_BYTE *)(result + v9 + 2332) )
          ++v5;
        v4 = v16;
      }
      v12 = *(_DWORD *)(result + 4 * v5 + 32);
      v13 = *(_WORD *)(a2 + 4 * v4);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 32) = v4;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v4 + 2332) <= *(_BYTE *)(v12 + result + 2332) )
        break;
      *(_DWORD *)(result + 4 * a3 + 32) = v12;
      v15 = *(_DWORD *)(result + 2324);
      a3 = v5;
      v5 *= 2;
      v7 = __OFSUB__(v5, v15);
      v6 = v5 - v15 < 0;
      if ( v5 > v15 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  return result;
}

//----- (1006F5D0) --------------------------------------------------------
int __usercall sub_1006F5D0@<eax>(int result@<eax>, __int16 a2@<cx>)
{
  int v2; // edi@1

  *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = HIBYTE(a2);
  v2 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v2) = a2;
  ++*(_DWORD *)(result + 5812);
  return result;
}

//----- (1006F610) --------------------------------------------------------
unsigned int __usercall sub_1006F610@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3)
{
  int v3; // ecx@1
  unsigned int v4; // edi@1
  unsigned int result; // eax@4

  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 > a1 )
    v4 = a1;
  if ( v4 )
  {
    *(_DWORD *)(a2 + 4) -= v4;
    if ( *(_DWORD *)(v3 + 5780) == 1 )
      *(_DWORD *)(a2 + 28) = sub_10071680(*(_DWORD *)(a2 + 28), *(_BYTE **)a2, v4);
    memcpy(a3, *(const void **)a2, v4);
    *(_DWORD *)a2 += v4;
    *(_DWORD *)(a2 + 8) += v4;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1006F670) --------------------------------------------------------
signed int __usercall sub_1006F670@<eax>(signed int result@<eax>, int a2@<ecx>, int a3)
{
  signed int v3; // edi@1
  signed int v4; // edx@1
  signed int v5; // ebp@1
  int v6; // ebx@1
  signed int v7; // ecx@1
  signed int v8; // esi@1
  _WORD *v9; // [sp+10h] [bp-8h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v3 = *(_WORD *)(result + 2);
  v4 = 0;
  v5 = -1;
  v6 = a2;
  v7 = 7;
  v8 = 4;
  if ( !*(_WORD *)(result + 2) )
  {
    v7 = 138;
    v8 = 3;
  }
  *(_WORD *)(result + 4 * v6 + 6) = -1;
  if ( v6 >= 0 )
  {
    v10 = v6 + 1;
    v9 = (_WORD *)(result + 6);
    do
    {
      result = v3;
      v3 = *v9;
      if ( ++v4 >= v7 || result != v3 )
      {
        if ( v4 >= v8 )
        {
          if ( result )
          {
            if ( result != v5 )
              ++*(_WORD *)(a3 + 4 * result + 5472);
            ++*(_WORD *)(a3 + 5536);
          }
          else if ( v4 > 10 )
          {
            ++*(_WORD *)(a3 + 5544);
          }
          else
          {
            ++*(_WORD *)(a3 + 5540);
          }
        }
        else
        {
          *(_WORD *)(a3 + 4 * result + 5472) += v4;
        }
        v4 = 0;
        v5 = result;
        if ( v3 )
        {
          if ( result == v3 )
          {
            v7 = 6;
            v8 = 3;
          }
          else
          {
            v7 = 7;
            v8 = 4;
          }
        }
        else
        {
          v7 = 138;
          v8 = 3;
        }
      }
      v9 += 2;
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (1006F750) --------------------------------------------------------
int __usercall sub_1006F750@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  signed int v3; // esi@1
  int v4; // ebx@1
  signed int v5; // ecx@1
  signed int v6; // edi@1
  signed int v7; // edx@5
  int v8; // edi@8
  int v9; // ecx@8
  unsigned __int16 v10; // si@9
  int v11; // edx@9
  int v12; // ecx@9
  int v13; // edx@9
  __int16 v14; // si@9
  int v15; // ecx@9
  int v16; // ecx@15
  unsigned __int16 v17; // si@16
  int v18; // edi@16
  int v19; // ecx@16
  int v20; // ebx@16
  int v21; // ecx@16
  int v22; // ecx@19
  unsigned __int16 v23; // si@20
  int v24; // edi@20
  int v25; // ecx@20
  int v26; // ebx@20
  int v27; // ecx@20
  int v28; // esi@22
  int v29; // edi@23
  int v30; // ecx@23
  int v31; // ebx@23
  int v32; // ecx@24
  int v33; // ecx@25
  unsigned __int16 v34; // si@27
  int v35; // edi@27
  int v36; // ecx@27
  int v37; // ebx@27
  int v38; // ecx@27
  int v39; // esi@29
  int v40; // edi@30
  int v41; // ecx@30
  int v42; // ebx@30
  unsigned __int16 v43; // si@33
  int v44; // edi@33
  int v45; // ecx@33
  int v46; // ebx@33
  int v47; // ecx@33
  int v48; // esi@35
  int v49; // edi@36
  int v50; // ecx@36
  int v51; // ebx@36
  signed int v52; // [sp+10h] [bp-18h]@5
  signed int v53; // [sp+14h] [bp-14h]@1
  _WORD *v54; // [sp+18h] [bp-10h]@4
  signed int v55; // [sp+1Ch] [bp-Ch]@1
  int v56; // [sp+1Ch] [bp-Ch]@15
  int v57; // [sp+1Ch] [bp-Ch]@19
  int v58; // [sp+1Ch] [bp-Ch]@26
  int v59; // [sp+1Ch] [bp-Ch]@32
  int v60; // [sp+20h] [bp-8h]@4
  signed int v61; // [sp+24h] [bp-4h]@5

  v3 = 0;
  v4 = a3;
  v5 = 7;
  v6 = 4;
  v53 = *(_WORD *)(a2 + 2);
  v55 = -1;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( v4 >= 0 )
  {
    v54 = (_WORD *)(a2 + 6);
    v60 = v4 + 1;
    do
    {
      v7 = v53;
      ++v3;
      v61 = v53;
      v53 = *v54;
      v52 = v3;
      if ( v3 < v5 && v7 == *v54 )
        goto LABEL_44;
      if ( v3 < v6 )
      {
        do
        {
          v8 = *(_WORD *)(result + 4 * v7 + 5474);
          v9 = *(_DWORD *)(result + 2932);
          if ( v9 <= 16 - v8 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v15 = v8 + v9;
          }
          else
          {
            v10 = *(_WORD *)(result + 4 * v7 + 5472);
            v11 = *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v12 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v11;
            *(_BYTE *)(v12 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v13 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v14 = v10 >> (16 - v13);
            v15 = v13 + v8 - 16;
            v7 = v61;
            *(_WORD *)(result + 2924) = v14;
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v15;
          v52 = v3;
        }
        while ( v3 );
        goto LABEL_39;
      }
      if ( v7 )
      {
        if ( v7 != v55 )
        {
          v16 = *(_DWORD *)(result + 2932);
          v56 = *(_WORD *)(result + 4 * v7 + 5474);
          if ( v16 <= 16 - v56 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v21 = v56 + v16;
          }
          else
          {
            v17 = *(_WORD *)(result + 4 * v7 + 5472);
            v18 = *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v19 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v18;
            *(_BYTE *)(v19 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v20 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v21 = v20 + v56 - 16;
            *(_WORD *)(result + 2924) = v17 >> (16 - v20);
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v21;
          v52 = v3;
        }
        v22 = *(_DWORD *)(result + 2932);
        v57 = *(_WORD *)(result + 5538);
        if ( v22 <= 16 - v57 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5536) << v22;
          v27 = v57 + v22;
        }
        else
        {
          v23 = *(_WORD *)(result + 5536);
          v24 = *(_WORD *)(result + 5536) << v22;
          v25 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v24;
          *(_BYTE *)(v25 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v26 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v27 = v26 + v57 - 16;
          *(_WORD *)(result + 2924) = v23 >> (16 - v26);
          v3 = v52;
        }
        v28 = v3 - 3;
        *(_DWORD *)(result + 2932) = v27;
        if ( v27 > 14 )
        {
          v29 = v28 << v27;
          v30 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v29;
          *(_BYTE *)(v30 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v31 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          *(_DWORD *)(result + 2932) = v31 - 14;
          *(_WORD *)(result + 2924) = (unsigned __int16)v28 >> (16 - v31);
          goto LABEL_39;
        }
        *(_WORD *)(result + 2924) |= v28 << v27;
        v32 = v27 + 2;
      }
      else
      {
        v33 = *(_DWORD *)(result + 2932);
        if ( v3 > 10 )
        {
          v59 = *(_WORD *)(result + 5546);
          if ( v33 <= 16 - v59 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5544) << v33;
            v47 = v59 + v33;
          }
          else
          {
            v43 = *(_WORD *)(result + 5544);
            v44 = *(_WORD *)(result + 5544) << v33;
            v45 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v44;
            *(_BYTE *)(v45 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v46 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v47 = v46 + v59 - 16;
            *(_WORD *)(result + 2924) = v43 >> (16 - v46);
            v3 = v52;
          }
          v48 = v3 - 11;
          *(_DWORD *)(result + 2932) = v47;
          if ( v47 > 9 )
          {
            v49 = v48 << v47;
            v50 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v49;
            *(_BYTE *)(v50 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v51 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v51 - 9;
            *(_WORD *)(result + 2924) = (unsigned __int16)v48 >> (16 - v51);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v48 << v47;
          v32 = v47 + 7;
        }
        else
        {
          v58 = *(_WORD *)(result + 5542);
          if ( v33 <= 16 - v58 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5540) << v33;
            v38 = v58 + v33;
          }
          else
          {
            v34 = *(_WORD *)(result + 5540);
            v35 = *(_WORD *)(result + 5540) << v33;
            v36 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v35;
            *(_BYTE *)(v36 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v37 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v38 = v37 + v58 - 16;
            *(_WORD *)(result + 2924) = v34 >> (16 - v37);
            v3 = v52;
          }
          v39 = v3 - 3;
          *(_DWORD *)(result + 2932) = v38;
          if ( v38 > 13 )
          {
            v40 = v39 << v38;
            v41 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v40;
            *(_BYTE *)(v41 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v42 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v42 - 13;
            *(_WORD *)(result + 2924) = (unsigned __int16)v39 >> (16 - v42);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v39 << v38;
          v32 = v38 + 3;
        }
      }
      *(_DWORD *)(result + 2932) = v32;
LABEL_39:
      v3 = 0;
      v55 = v7;
      if ( v53 )
      {
        if ( v7 == v53 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v54 += 2;
      --v60;
    }
    while ( v60 );
  }
  return result;
}

//----- (1006FCF0) --------------------------------------------------------
_WORD *__fastcall sub_1006FCF0(int a1, int a2)
{
  *(_DWORD *)(a2 + 5628) = a2 + 2936;
  *(_DWORD *)(a2 + 5652) = a2 + 5472;
  *(_DWORD *)(a2 + 5636) = &off_10157094;
  *(_DWORD *)(a2 + 5640) = a2 + 5228;
  *(_DWORD *)(a2 + 5648) = &off_101570A8;
  *(_DWORD *)(a2 + 5660) = &unk_101570BC;
  *(_WORD *)(a2 + 2924) = 0;
  *(_DWORD *)(a2 + 2932) = 0;
  *(_DWORD *)(a2 + 2928) = 8;
  return sub_1006F170(a2 + 5228, a2);
}
// 10157094: using guessed type void *off_10157094;
// 101570A8: using guessed type void *off_101570A8;

//----- (1006FD50) --------------------------------------------------------
signed int __cdecl sub_1006FD50(int a1)
{
  int v1; // esi@2
  int v2; // eax@3
  int v3; // ecx@5
  signed int result; // eax@5

  if ( a1 && (v1 = *(_DWORD *)(a1 + 24)) != 0 )
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(v1 + 5808) = *(_DWORD *)(v1 + 5800);
    v2 = *(_DWORD *)(v1 + 5780);
    *(_DWORD *)(v1 + 5812) = 0;
    if ( v2 < 0 )
      *(_DWORD *)(v1 + 5780) = -v2;
    *(_DWORD *)(v1 + 5788) = *(_DWORD *)(v1 + 5780) != 0 ? 42 : 113;
    *(_DWORD *)(a1 + 28) = sub_10071680(0, 0, 0);
    *(_DWORD *)(v1 + 5792) = 0;
    sub_1006FCF0(v3, v1);
    sub_1006F1E0(v1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (1006FDE0) --------------------------------------------------------
int __usercall sub_1006FDE0@<eax>(int a1@<eax>)
{
  signed int v1; // ecx@1
  int v2; // edx@2
  signed int v3; // ecx@4
  int v4; // edx@5
  int result; // eax@7
  signed int v6; // ecx@7
  int v7; // edx@9
  signed int v8; // ecx@11
  int v9; // edx@12

  v1 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) |= 2 << v1;
  if ( v1 <= 13 )
  {
    *(_DWORD *)(a1 + 2932) = v1 + 3;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v2 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v2 - 13;
    *(_WORD *)(a1 + 2924) = 2u >> (16 - v2);
  }
  v3 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) = *(_WORD *)(a1 + 2924);
  if ( v3 <= 9 )
  {
    *(_DWORD *)(a1 + 2932) = v3 + 7;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v4 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v4 - 9;
    *(_WORD *)(a1 + 2924) = 0;
  }
  result = sub_1006E850(a1);
  v6 = *(_DWORD *)(result + 2932);
  if ( *(_DWORD *)(result + 2928) - v6 + 11 < 9 )
  {
    *(_WORD *)(result + 2924) |= 2 << v6;
    if ( v6 <= 13 )
    {
      *(_DWORD *)(result + 2932) = v6 + 3;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v7 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v7 - 13;
      *(_WORD *)(result + 2924) = 2u >> (16 - v7);
    }
    v8 = *(_DWORD *)(result + 2932);
    *(_WORD *)(result + 2924) = *(_WORD *)(result + 2924);
    if ( v8 > 9 )
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v9 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v9 - 9;
      *(_WORD *)(result + 2924) = 0;
      result = sub_1006E850(result);
      *(_DWORD *)(result + 2928) = 7;
      return result;
    }
    *(_DWORD *)(result + 2932) = v8 + 7;
    result = sub_1006E850(result);
  }
  *(_DWORD *)(result + 2928) = 7;
  return result;
}

//----- (10070020) --------------------------------------------------------
int __usercall sub_10070020@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4)
{
  int v4; // esi@1
  signed int v5; // ecx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  int result; // eax@2

  v4 = a2;
  v5 = *(_DWORD *)(a1 + 2932);
  if ( v5 <= 13 )
  {
    *(_WORD *)(a1 + 2924) |= v4 << v5;
    *(_DWORD *)(a1 + 2932) = v5 + 3;
    result = sub_1006EE10(a1, a3, a4);
  }
  else
  {
    v6 = v4 << v5;
    v7 = *(_DWORD *)(a1 + 5800);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) = (unsigned __int16)v4 >> (16 - v8);
    *(_DWORD *)(a1 + 2932) = v8 - 13;
    result = sub_1006EE10(a1, a3, a4);
  }
  return result;
}

//----- (100700C0) --------------------------------------------------------
signed int __usercall sub_100700C0@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax@1
  int v3; // ebp@1
  signed int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@1
  signed int v7; // eax@8
  signed int i; // ebp@14
  int v9; // ebx@16
  int v10; // eax@17
  int v11; // edx@17
  int v12; // ebp@17
  int v13; // eax@17
  unsigned __int8 v14; // cl@17
  int v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)v2;
  v17 = *(_DWORD *)(v2 + 12);
  v4 = -1;
  v5 = *(_DWORD *)a2;
  v6 = 0;
  v16 = -1;
  *(_DWORD *)(a1 + 2324) = 0;
  for ( *(_DWORD *)(a1 + 2328) = 573; v6 < v17; ++v6 )
  {
    if ( *(_WORD *)(v5 + 4 * v6) )
    {
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v6;
      v16 = v6;
      *(_BYTE *)(v6 + a1 + 2332) = 0;
      v4 = v6;
    }
    else
    {
      *(_WORD *)(v5 + 4 * v6 + 2) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 2324) < 2 )
  {
    do
    {
      if ( v4 >= 2 )
        v7 = 0;
      else
        v7 = ++v4;
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v7;
      *(_WORD *)(v5 + 4 * v7) = 1;
      *(_BYTE *)(a1 + v7 + 2332) = 0;
      --*(_DWORD *)(a1 + 2912);
      if ( v3 )
        *(_DWORD *)(a1 + 2916) -= *(_WORD *)(v3 + 4 * v7 + 2);
    }
    while ( *(_DWORD *)(a1 + 2324) < 2 );
    v16 = v4;
  }
  *(_DWORD *)(a2 + 4) = v4;
  for ( i = *(_DWORD *)(a1 + 2324) / 2; i >= 1; --i )
    sub_1006F520(a1, v5, i);
  v9 = v17;
  do
  {
    v10 = *(_DWORD *)(a1 + 2324);
    v11 = *(_DWORD *)(a1 + 4 * v10 + 32);
    v12 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 2324) = v10 - 1;
    *(_DWORD *)(a1 + 36) = v11;
    sub_1006F520(a1, v5, 1);
    v13 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v12;
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v13;
    *(_WORD *)(v5 + 4 * v9) = *(_WORD *)(v5 + 4 * v12) + *(_WORD *)(v5 + 4 * v13);
    v14 = *(_BYTE *)(a1 + v13 + 2332);
    if ( *(_BYTE *)(a1 + v12 + 2332) >= v14 )
      v14 = *(_BYTE *)(a1 + v12 + 2332);
    *(_BYTE *)(a1 + v9 + 2332) = v14 + 1;
    *(_WORD *)(v5 + 4 * v13 + 2) = v9;
    *(_WORD *)(v5 + 4 * v12 + 2) = v9;
    *(_DWORD *)(a1 + 36) = v9++;
    sub_1006F520(a1, v5, 1);
  }
  while ( *(_DWORD *)(a1 + 2324) >= 2 );
  *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = *(_DWORD *)(a1 + 36);
  sub_1006EF20(a1, a2);
  return sub_1006F0F0(a1, v16, v5);
}

//----- (100702A0) --------------------------------------------------------
unsigned int __usercall sub_100702A0@<eax>(int a1@<edi>)
{
  size_t v1; // ebx@1
  unsigned int result; // eax@2
  unsigned int v3; // ebp@2
  int v4; // edx@3
  int v5; // eax@3
  _WORD *v6; // ecx@3
  int v7; // eax@4
  __int16 v8; // ax@5
  size_t v9; // edx@8
  _WORD *v10; // ecx@8
  int v11; // eax@9
  int v12; // esi@14
  unsigned int v13; // edx@15
  int v14; // esi@16
  int v15; // eax@16
  int v16; // ecx@16

  v1 = *(_DWORD *)(a1 + 5748);
  do
  {
    result = *(_DWORD *)(a1 + 5680);
    v3 = *(_DWORD *)(a1 + 5744) - result - *(_DWORD *)(a1 + 5688);
    if ( result >= v1 + *(_DWORD *)(a1 + 5748) - 262 )
    {
      memcpy(*(void **)(a1 + 5740), (const void *)(*(_DWORD *)(a1 + 5740) + v1), v1);
      v4 = *(_DWORD *)(a1 + 5764);
      v5 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5684) -= v1;
      *(_DWORD *)(a1 + 5680) -= v1;
      *(_DWORD *)(a1 + 5664) -= v1;
      v6 = (_WORD *)(v5 + 2 * v4);
      do
      {
        v7 = *(v6 - 1);
        --v6;
        if ( v7 < v1 )
          v8 = 0;
        else
          v8 = v7 - v1;
        --v4;
        *v6 = v8;
      }
      while ( v4 );
      v9 = v1;
      v10 = (_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * v1);
      do
      {
        v11 = *(v10 - 1);
        --v10;
        if ( v11 < v1 )
          result = 0;
        else
          result = v11 - v1;
        --v9;
        *v10 = result;
      }
      while ( v9 );
      v3 += v1;
    }
    v12 = *(_DWORD *)(a1 + 2908);
    if ( !*(_DWORD *)(v12 + 4) )
      break;
    result = sub_1006F610(v3, v12, (void *)(*(_DWORD *)(a1 + 5688) + *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)));
    *(_DWORD *)(a1 + 5688) += result;
    v13 = *(_DWORD *)(a1 + 5688);
    if ( v13 >= 3 )
    {
      v14 = *(_DWORD *)(a1 + 5680) + *(_DWORD *)(a1 + 5740);
      v15 = *(_BYTE *)v14;
      v16 = *(_DWORD *)(a1 + 5776);
      *(_DWORD *)(a1 + 5760) = v15;
      result = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v14 + 1) ^ (v15 << v16));
      *(_DWORD *)(a1 + 5760) = result;
    }
  }
  while ( v13 < 0x106 && *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 4) );
  return result;
}

//----- (100703E0) --------------------------------------------------------
int __usercall sub_100703E0@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  signed int v9; // ecx@4
  int v10; // edx@5
  int v11; // ecx@5
  int v12; // edx@5
  signed int v13; // ecx@7
  int v14; // edx@8
  int v15; // ecx@8
  int v16; // edx@8
  int i; // edi@10
  signed int v18; // ecx@11
  int v19; // edx@11
  unsigned __int16 v20; // si@12
  int v21; // edx@12
  int v22; // ecx@12
  int v23; // edx@12
  int v24; // eax@15

  v4 = *(_DWORD *)(a1 + 2932);
  v5 = a4;
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 2932) = v4 + 5;
  }
  else
  {
    v6 = (a2 - 257) << v4;
    v7 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    v5 = a4;
    *(_DWORD *)(a1 + 2932) = v8 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a2 - 257) >> (16 - v8);
  }
  v9 = *(_DWORD *)(a1 + 2932);
  if ( v9 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a3 - 1) << v9;
    *(_DWORD *)(a1 + 2932) = v9 + 5;
  }
  else
  {
    v10 = (a3 - 1) << v9;
    v11 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v10;
    *(_BYTE *)(v11 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v12 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v12 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a3 - 1) >> (16 - v12);
  }
  v13 = *(_DWORD *)(a1 + 2932);
  if ( v13 <= 12 )
  {
    *(_WORD *)(a1 + 2924) |= (v5 - 4) << v13;
    *(_DWORD *)(a1 + 2932) = v13 + 4;
  }
  else
  {
    v14 = (v5 - 4) << v13;
    v15 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v14;
    *(_BYTE *)(v15 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v16 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v16 - 12;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(v5 - 4) >> (16 - v16);
  }
  for ( i = 0; i < v5; ++i )
  {
    v18 = *(_DWORD *)(a1 + 2932);
    v19 = (unsigned __int8)byte_1015656C[i];
    if ( v18 <= 13 )
    {
      *(_WORD *)(a1 + 2924) |= *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      *(_DWORD *)(a1 + 2932) = v18 + 3;
    }
    else
    {
      v20 = *(_WORD *)(a1 + 4 * v19 + 5474);
      v21 = *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      v22 = *(_DWORD *)(a1 + 5812);
      *(_WORD *)(a1 + 2924) |= v21;
      *(_BYTE *)(v22 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
      *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
      v23 = *(_DWORD *)(a1 + 2932);
      ++*(_DWORD *)(a1 + 5812);
      v5 = a4;
      *(_DWORD *)(a1 + 2932) = v23 - 13;
      *(_WORD *)(a1 + 2924) = v20 >> (16 - v23);
    }
  }
  v24 = sub_1006F750(a1, a1 + 2936, a2 - 1);
  return sub_1006F750(v24, v24 + 5228, a3 - 1);
}

//----- (10070690) --------------------------------------------------------
signed int __cdecl sub_10070690(int a1, int a2)
{
  int v2; // esi@3
  int v3; // eax@6
  signed int result; // eax@9
  int v5; // ebx@10
  char v6; // al@12
  int v7; // eax@14
  unsigned int v8; // ecx@17
  int v9; // eax@19
  int v10; // eax@20
  int v11; // eax@29
  signed int v12; // eax@36
  int v13; // eax@50
  bool v14; // zf@50

  if ( !a1 || (unsigned int)a2 > 4 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  if ( !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) )
    return -2;
  v3 = *(_DWORD *)(v2 + 5788);
  if ( v3 == 666 && a2 != 4 )
    return -2;
  if ( !*(_DWORD *)(a1 + 16) )
    return -5;
  v5 = *(_DWORD *)(v2 + 5792);
  *(_DWORD *)(v2 + 2908) = a1;
  *(_DWORD *)(v2 + 5792) = a2;
  if ( v3 == 42 )
  {
    if ( *(_BYTE *)(v2 + 5796) >= 2 || (v6 = *(_BYTE *)(v2 + 5784), v6 < 2) )
    {
      v7 = 0;
    }
    else if ( v6 >= 6 )
    {
      v7 = (v6 != 6) + 2;
    }
    else
    {
      v7 = 1;
    }
    v8 = (v7 << 6) | (((*(_DWORD *)(v2 + 5752) - 8) << 12) + 2048);
    if ( *(_DWORD *)(v2 + 5680) )
      v8 |= 0x20u;
    *(_DWORD *)(v2 + 5788) = 113;
    v9 = sub_1006F5D0(v2, 31 * (v8 / 0x1F + 1));
    if ( *(_DWORD *)(v2 + 5680) )
    {
      v10 = sub_1006F5D0(v9, *(_WORD *)(a1 + 30));
      sub_1006F5D0(v10, *(_WORD *)(a1 + 28));
    }
    *(_DWORD *)(a1 + 28) = sub_10071680(0, 0, 0);
  }
  if ( *(_DWORD *)(v2 + 5812) )
  {
    sub_1006EEC0(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
LABEL_24:
      *(_DWORD *)(v2 + 5792) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v5 && a2 != 4 )
  {
    return -5;
  }
  v11 = *(_DWORD *)(v2 + 5788);
  if ( v11 == 666 )
  {
    if ( *(_DWORD *)(a1 + 4) )
      return -5;
LABEL_33:
    if ( !*(_DWORD *)(v2 + 5688) && (!a2 || v11 == 666) )
      goto LABEL_47;
    goto LABEL_36;
  }
  if ( !*(_DWORD *)(a1 + 4) )
    goto LABEL_33;
LABEL_36:
  v12 = (*(&off_10156EE8 + 3 * *(_BYTE *)(v2 + 5784)))(v2, a2);
  if ( v12 == 2 || v12 == 3 )
    *(_DWORD *)(v2 + 5788) = 666;
  if ( !v12 || v12 == 2 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      return 0;
    *(_DWORD *)(v2 + 5792) = -1;
    return 0;
  }
  if ( v12 == 1 )
  {
    if ( a2 == 1 )
    {
      sub_1006FDE0(v2);
    }
    else
    {
      sub_10070020(v2, 0, 0, 0);
      if ( a2 == 3 )
      {
        *(_WORD *)(*(_DWORD *)(v2 + 5736) + 2 * *(_DWORD *)(v2 + 5764) - 2) = 0;
        memset(*(void **)(v2 + 5736), 0, 2 * *(_DWORD *)(v2 + 5764) - 2);
      }
    }
    sub_1006EEC0(a1);
    if ( !*(_DWORD *)(a1 + 16) )
      goto LABEL_24;
  }
LABEL_47:
  if ( a2 != 4 )
    return 0;
  if ( *(_DWORD *)(v2 + 5780) > 0 )
  {
    v13 = sub_1006F5D0(v2, *(_WORD *)(a1 + 30));
    sub_1006F5D0(v13, *(_WORD *)(a1 + 28));
    sub_1006EEC0(a1);
    v14 = *(_DWORD *)(v2 + 5812) == 0;
    *(_DWORD *)(v2 + 5780) = -*(_DWORD *)(v2 + 5780);
    result = v14;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 10156EE8: using guessed type int (__cdecl *off_10156EE8)(int, int);

//----- (10070950) --------------------------------------------------------
signed int __cdecl sub_10070950(int a1, unsigned __int8 a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8)
{
  signed int v8; // edx@1
  int v9; // eax@5
  unsigned int v10; // edi@12
  signed int v11; // ebp@12
  signed int v12; // eax@12
  int v13; // ebp@14
  int v14; // esi@14
  int v15; // esi@14
  int v16; // esi@14
  signed int result; // eax@14

  v8 = 1;
  if ( a1 && a7 )
  {
    if ( a2 == -1 )
      a2 = 6;
    v9 = a4;
    if ( a4 < 0 )
    {
      v8 = 0;
      v9 = -a4;
      a4 = -a4;
    }
    if ( (unsigned int)(a5 - 1) > 7 || a3 != 8 || (unsigned int)(v9 - 9) > 6 || a2 > 9u || a6 > 3u )
    {
      result = -2;
    }
    else
    {
      v10 = 1 << (a5 + 6);
      v11 = 1 << v9;
      v12 = 1 << (a5 + 7);
      if ( (signed int)(2 * (v12 + 2 * (v10 + v11) + 2908)) > a8 || a7 & 3 )
      {
        result = -4;
      }
      else
      {
        *(_DWORD *)(a1 + 24) = a7;
        *(_DWORD *)(a7 + 5780) = v8;
        *(_DWORD *)(a7 + 5764) = v12;
        *(_DWORD *)(a7 + 5752) = a4;
        *(_DWORD *)(a7 + 5768) = a5 + 7;
        *(_DWORD *)(a7 + 5772) = v12 - 1;
        *(_DWORD *)(a7 + 5756) = v11 - 1;
        *(_DWORD *)(a7 + 5748) = v11;
        *(_DWORD *)(a7 + 5740) = a7 + 5816;
        v13 = 2 * v11;
        v14 = v13 + a7 + 5816;
        *(_DWORD *)(a7 + 5732) = v14;
        v15 = v13 + v14;
        *(_DWORD *)(a7 + 5776) = (a5 + 9) / 3u;
        *(_DWORD *)(a7 + 5736) = v15;
        v16 = v15 + 2 * (1 << (a5 + 7));
        *(_DWORD *)(a7 + 5804) = 4 * v10;
        *(_DWORD *)(a7 + 5716) = v10 + v16 + 2 * v10;
        *(_DWORD *)(a7 + 5712) = v16 + 2 * (v10 >> 1);
        *(_DWORD *)(a7 + 5724) = v10;
        *(_DWORD *)(a7 + 5800) = v16;
        *(_BYTE *)(a7 + 5784) = a2;
        *(_BYTE *)(a7 + 5796) = a6;
        *(_BYTE *)(a7 + 5720) = 8;
        result = sub_1006FD50(a1);
      }
    }
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10070B00) --------------------------------------------------------
signed int __usercall sub_10070B00@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  signed int result; // eax@1

  v1 = a1;
  sub_1006F670(a1 + 2936, *(_DWORD *)(a1 + 5632), a1);
  sub_1006F670(v1 + 5228, *(_DWORD *)(v1 + 5644), v1);
  sub_100700C0(v1, v1 + 5652);
  result = 18;
  while ( !*(_WORD *)(v1 + 4 * (unsigned __int8)byte_1015656C[result] + 5474) )
  {
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_1015656B[result] + 5474) )
    {
      *(_DWORD *)(v1 + 2912) += 3 * --result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_1015656A[result] + 5474) )
    {
      result -= 2;
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_10156569[result] + 5474) )
    {
      result -= 3;
      break;
    }
    result -= 4;
    if ( result < 3 )
    {
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
  }
  *(_DWORD *)(v1 + 2912) += 3 * result + 17;
  return result;
}

//----- (10070BD0) --------------------------------------------------------
_WORD *__usercall sub_10070BD0@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // eax@1
  _BYTE *v7; // edi@2
  signed int v8; // eax@5
  unsigned int v9; // edx@5
  unsigned int v10; // ecx@5
  int v11; // ecx@11
  bool v12; // zf@12
  signed int v13; // ecx@12
  int v14; // eax@13
  int v15; // edx@14
  int v16; // ecx@14
  int v17; // edx@14
  int v18; // edx@17
  int v19; // eax@18
  int v20; // ecx@18
  int v21; // ebx@18
  _WORD *result; // eax@21
  signed int v23; // [sp+14h] [bp+4h]@4

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(_DWORD *)(a2 + 5664);
  if ( v6 < 0 )
    v7 = 0;
  else
    v7 = (_BYTE *)(v6 + *(_DWORD *)(a2 + 5740));
  v23 = 0;
  if ( *(_BYTE *)(a2 + 5784) <= 0 )
  {
    v10 = v5 + 5;
LABEL_8:
    v9 = v10;
    goto LABEL_9;
  }
  sub_100700C0(a2, a2 + 5628);
  sub_100700C0(v4, v4 + 5640);
  v8 = sub_10070B00(v4);
  v9 = (unsigned int)(*(_DWORD *)(v4 + 2912) + 10) >> 3;
  v10 = (unsigned int)(*(_DWORD *)(v4 + 2916) + 10) >> 3;
  v23 = v8;
  if ( v10 <= v9 )
    goto LABEL_8;
LABEL_9:
  if ( v5 + 4 <= v9 && v7 )
  {
    sub_10070020(v4, v3, v7, v5);
  }
  else
  {
    v12 = v10 == v9;
    v13 = *(_DWORD *)(v4 + 2932);
    if ( v12 )
    {
      v14 = v3 + 2;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v14 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v15 = v14 << v13;
        v16 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v15;
        *(_BYTE *)(v16 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v17 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v17 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v14 >> (16 - v17);
      }
      sub_1006E990(v4, (int)&unk_101565F8, (int)&unk_10156A78);
    }
    else
    {
      v18 = v3 + 4;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v18 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v19 = v18 << v13;
        v20 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v19;
        *(_BYTE *)(v20 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v21 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v21 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v18 >> (16 - v21);
      }
      sub_100703E0(v4, *(_DWORD *)(v4 + 5632) + 1, *(_DWORD *)(v4 + 5644) + 1, v23 + 1);
      sub_1006E990(v4, v4 + 2936, v4 + 5228);
    }
  }
  result = sub_1006F170(v11, v4);
  if ( v3 )
    result = (_WORD *)sub_1006E900(v4);
  return result;
}

//----- (10070DF0) --------------------------------------------------------
signed int __cdecl sub_10070DF0(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  int v4; // edx@7
  int v5; // edi@7
  int v6; // eax@7
  int v7; // ecx@7
  unsigned int v8; // eax@9
  char v9; // cl@10
  unsigned int v10; // eax@11
  unsigned int v11; // eax@16
  BOOL v12; // eax@17
  unsigned int v13; // ecx@17
  int v14; // edi@20
  int v15; // ecx@20
  int v16; // edx@20
  int v17; // ebx@20
  int v19; // edi@22
  int v20; // ecx@22
  int v21; // edx@22
  int v22; // edi@26
  signed int result; // eax@27
  int v24; // edi@28
  int v25; // eax@28

  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_100702A0(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    if ( v2 )
    {
      v8 = *(_DWORD *)(a1 + 5680) - v2;
      if ( v8 <= *(_DWORD *)(a1 + 5748) - 262 )
      {
        v9 = *(_BYTE *)(a1 + 5796);
        if ( v9 < 2 )
        {
          v10 = sub_1006F2A0(a1, v2);
LABEL_15:
          *(_DWORD *)(a1 + 5668) = v10;
          goto LABEL_16;
        }
        if ( v9 == 3 && v8 == 1 )
        {
          v10 = sub_1006F450(a1, v2);
          goto LABEL_15;
        }
      }
    }
LABEL_16:
    v11 = *(_DWORD *)(a1 + 5668);
    if ( v11 < 3 )
    {
      v12 = sub_1006E7B0(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)), 0);
      --*(_DWORD *)(a1 + 5688);
    }
    else
    {
      v12 = sub_1006E7B0(a1, v11 - 3, *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684));
      v13 = *(_DWORD *)(a1 + 5668);
      *(_DWORD *)(a1 + 5688) -= v13;
      if ( v13 > *(_DWORD *)(a1 + 5700) || *(_DWORD *)(a1 + 5688) < 3u )
      {
        *(_DWORD *)(a1 + 5680) += v13;
        v19 = *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680);
        v20 = *(_DWORD *)(a1 + 5776);
        *(_DWORD *)(a1 + 5668) = 0;
        v21 = *(_BYTE *)v19;
        *(_DWORD *)(a1 + 5760) = v21;
        *(_DWORD *)(a1 + 5760) = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v19 + 1) ^ (v21 << v20));
        goto LABEL_25;
      }
      *(_DWORD *)(a1 + 5668) = v13 - 1;
      do
      {
        v14 = ++*(_DWORD *)(a1 + 5680);
        v15 = *(_DWORD *)(a1 + 5736);
        v16 = *(_DWORD *)(a1 + 5772) & ((*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)) ^ *(_BYTE *)(*(_DWORD *)(a1 + 5740) + v14 + 2));
        v17 = *(_DWORD *)(a1 + 5756);
        *(_DWORD *)(a1 + 5760) = v16;
        *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v14 & v17)) = *(_WORD *)(v15 + 2 * v16);
        v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
        *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
      }
      while ( (*(_DWORD *)(a1 + 5668))-- != 1 );
    }
    ++*(_DWORD *)(a1 + 5680);
LABEL_25:
    if ( v12 )
    {
      sub_10070BD0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
      v22 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_1006EEC0(v22);
      if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        return 0;
    }
  }
  sub_10070BD0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v24 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_1006EEC0(v24);
  v25 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v25) = a2 == 4;
    result = 2 * v25 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (10071100) --------------------------------------------------------
signed int __cdecl sub_10071100(int a1, int a2)
{
  unsigned int v2; // ebp@1
  unsigned int v3; // eax@3
  int v4; // edx@8
  int v5; // edi@8
  int v6; // eax@8
  int v7; // ecx@8
  unsigned int v8; // ecx@9
  int v9; // edx@9
  unsigned int v10; // eax@11
  char v11; // cl@12
  unsigned int v12; // eax@13
  unsigned int v13; // eax@18
  unsigned int v14; // eax@23
  int v15; // ecx@25
  unsigned int v16; // ebp@25
  BOOL v17; // eax@25
  int v18; // ecx@25
  BOOL v19; // ebx@25
  unsigned int v20; // edi@26
  int v21; // ecx@27
  int v22; // edx@27
  int v23; // eax@27
  int v25; // eax@29
  int v26; // edi@30
  signed int result; // eax@31
  int v28; // edi@34
  int v29; // ecx@35
  int v30; // edi@40
  unsigned int v31; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v31 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_100702A0(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    v8 = *(_DWORD *)(a1 + 5668);
    v9 = *(_DWORD *)(a1 + 5684);
    *(_DWORD *)(a1 + 5692) = v8;
    *(_DWORD *)(a1 + 5672) = v9;
    *(_DWORD *)(a1 + 5668) = 2;
    if ( !v2 )
      goto LABEL_23;
    if ( v8 >= *(_DWORD *)(a1 + 5700) )
      goto LABEL_23;
    v10 = *(_DWORD *)(a1 + 5680) - v2;
    if ( v10 > *(_DWORD *)(a1 + 5748) - 262 )
      goto LABEL_23;
    v11 = *(_BYTE *)(a1 + 5796);
    if ( v11 < 2 )
    {
      v12 = sub_1006F2A0(a1, v2);
LABEL_17:
      *(_DWORD *)(a1 + 5668) = v12;
      goto LABEL_18;
    }
    if ( v11 == 3 && v10 == 1 )
    {
      v12 = sub_1006F450(a1, v2);
      goto LABEL_17;
    }
LABEL_18:
    v13 = *(_DWORD *)(a1 + 5668);
    if ( v13 <= 5
      && (*(_BYTE *)(a1 + 5796) == 1
       || v13 == 3 && (unsigned int)(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684)) > 0x1000) )
    {
      *(_DWORD *)(a1 + 5668) = 2;
    }
LABEL_23:
    v14 = *(_DWORD *)(a1 + 5692);
    if ( v14 < 3 || *(_DWORD *)(a1 + 5668) > v14 )
    {
      if ( *(_DWORD *)(a1 + 5676) )
      {
        if ( sub_1006E7B0(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0) )
        {
          sub_10070BD0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
          v28 = *(_DWORD *)(a1 + 2908);
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
          sub_1006EEC0(v28);
        }
        v29 = *(_DWORD *)(a1 + 2908);
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        if ( !*(_DWORD *)(v29 + 16) )
          return 0;
      }
      else
      {
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        *(_DWORD *)(a1 + 5676) = 1;
      }
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 5680);
      v16 = v15 + *(_DWORD *)(a1 + 5688) - 3;
      v17 = sub_1006E7B0(a1, v14 - 3, v15 - *(_DWORD *)(a1 + 5672) - 1);
      v18 = *(_DWORD *)(a1 + 5692);
      v19 = v17;
      *(_DWORD *)(a1 + 5688) += 1 - v18;
      *(_DWORD *)(a1 + 5692) = v18 - 2;
      do
      {
        v20 = ++*(_DWORD *)(a1 + 5680);
        if ( v20 <= v16 )
        {
          v21 = *(_DWORD *)(a1 + 5736);
          v22 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v20 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
          v23 = *(_DWORD *)(a1 + 5756);
          *(_DWORD *)(a1 + 5760) = v22;
          *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v20 & v23)) = *(_WORD *)(v21 + 2 * v22);
          v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
          *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
        }
      }
      while ( (*(_DWORD *)(a1 + 5692))-- != 1 );
      v25 = ++*(_DWORD *)(a1 + 5680);
      *(_DWORD *)(a1 + 5676) = 0;
      *(_DWORD *)(a1 + 5668) = 2;
      if ( v19 )
      {
        sub_10070BD0(v25 - *(_DWORD *)(a1 + 5664), a1, 0);
        v26 = *(_DWORD *)(a1 + 2908);
        *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
        sub_1006EEC0(v26);
        if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
          return 0;
      }
      v2 = v31;
    }
  }
  if ( *(_DWORD *)(a1 + 5676) )
  {
    sub_1006E7B0(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0);
    *(_DWORD *)(a1 + 5676) = 0;
  }
  sub_10070BD0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v30 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_1006EEC0(v30);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
    result = 2 * (a2 == 4) + 1;
  else
    result = a2 != 4 ? 0 : 2;
  return result;
}

//----- (10071510) --------------------------------------------------------
signed int __cdecl sub_10071510(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // eax@3
  bool v4; // zf@5
  int v5; // edx@5
  unsigned int v6; // ecx@5
  unsigned int v7; // eax@5
  int v8; // edi@7
  unsigned int v9; // eax@8
  int v10; // edi@9
  signed int result; // eax@10
  int v12; // edi@12
  int v13; // eax@12

  v2 = 0xFFFF;
  if ( (unsigned int)(*(_DWORD *)(a1 + 5804) - 5) <= 0xFFFF )
    v2 = *(_DWORD *)(a1 + 5804) - 5;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 <= 1 )
    {
      sub_100702A0(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( !v3 )
        break;
    }
    v4 = v3 + *(_DWORD *)(a1 + 5680) == 0;
    *(_DWORD *)(a1 + 5680) += v3;
    v5 = *(_DWORD *)(a1 + 5664);
    v6 = *(_DWORD *)(a1 + 5680);
    *(_DWORD *)(a1 + 5688) = 0;
    v7 = v5 + v2;
    if ( !v4 && v6 < v7
      || (*(_DWORD *)(a1 + 5688) = v6 - v7,
          *(_DWORD *)(a1 + 5680) = v7,
          sub_10070BD0(v2, a1, 0),
          v8 = *(_DWORD *)(a1 + 2908),
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680),
          sub_1006EEC0(v8),
          *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16)) )
    {
      v9 = *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664);
      if ( v9 < *(_DWORD *)(a1 + 5748) - 262 )
        continue;
      sub_10070BD0(v9, a1, 0);
      v10 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_1006EEC0(v10);
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  sub_10070BD0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v12 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_1006EEC0(v12);
  v13 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v13) = a2 == 4;
    result = 2 * v13 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (10071680) --------------------------------------------------------
int __cdecl sub_10071680(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edi@1
  unsigned int v4; // ecx@1
  unsigned int v5; // esi@1
  int result; // eax@2
  unsigned int i; // ebp@3
  unsigned int v8; // ebx@4
  int v9; // eax@8
  signed int v10; // edx@8
  int v11; // ecx@9
  int v12; // esi@9
  int v13; // ecx@9
  int v14; // esi@9
  int v15; // ecx@9
  int v16; // esi@9
  unsigned int v17; // [sp+Ch] [bp+4h]@7

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = a1 >> 16;
  if ( a2 )
  {
    for ( i = a3; i; v5 %= 0xFFF1u )
    {
      v8 = i;
      if ( i >= 0x15B0 )
        v8 = 5552;
      i -= v8;
      if ( (signed int)v8 >= 16 )
      {
        v17 = v8 >> 4;
        v8 += -16 * (v8 >> 4);
        do
        {
          v9 = (int)(v3 + 1);
          v10 = 4;
          do
          {
            v11 = *(_BYTE *)(v9 - 1) + v4;
            v12 = v11 + v5;
            v13 = *(_BYTE *)v9 + v11;
            v14 = v13 + v12;
            v15 = *(_BYTE *)(v9 + 1) + v13;
            v16 = v15 + v14;
            v4 = *(_BYTE *)(v9 + 2) + v15;
            v5 = v4 + v16;
            v9 += 4;
            --v10;
          }
          while ( v10 );
          v3 += 16;
          --v17;
        }
        while ( v17 );
      }
      for ( ; v8; --v8 )
      {
        v4 += *v3++;
        v5 += v4;
      }
      v4 %= 0xFFF1u;
    }
    result = v4 | (v5 << 16);
  }
  else
  {
    result = (int)(a2 + 1);
  }
  return result;
}

//----- (10071780) --------------------------------------------------------
signed int __cdecl sub_10071780(int a1)
{
  signed int result; // eax@3

  if ( a1 && *(_DWORD *)(a1 + 24) )
  {
    *(_DWORD *)(a1 + 24) = 0;
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (100717A0) --------------------------------------------------------
signed int __usercall sub_100717A0@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10)
{
  unsigned int v10; // ebp@1
  unsigned int *v11; // edi@1
  _DWORD *v12; // eax@1
  unsigned int v13; // edx@1
  signed int result; // eax@4
  unsigned int v15; // eax@5
  int v16; // ecx@7
  signed int v17; // edx@9
  signed int v18; // esi@13
  int i; // edi@13
  int v20; // esi@14
  int v21; // edi@16
  int v22; // esi@16
  int v23; // edi@17
  int v24; // ebx@17
  int v25; // esi@17
  int v26; // edi@18
  _DWORD *v27; // edi@20
  unsigned int v28; // ebx@20
  int v29; // esi@21
  int v30; // edi@22
  signed int v31; // edi@24
  int v32; // ebx@24
  unsigned int v33; // esi@25
  int v34; // edx@27
  int l; // ebp@28
  unsigned int v36; // edx@31
  unsigned int v37; // ecx@33
  int *v38; // ebp@34
  int v39; // eax@34
  unsigned int v40; // edi@36
  unsigned int v41; // eax@36
  unsigned int v42; // edx@39
  int v43; // eax@40
  unsigned int v44; // eax@41
  int v45; // ecx@41
  int v46; // esi@48
  signed int v47; // edx@50
  unsigned int v48; // eax@50
  int v49; // ecx@51
  unsigned int j; // eax@54
  int v51; // [sp+Ch] [bp-F4h]@7
  unsigned int v52; // [sp+Ch] [bp-F4h]@24
  signed int v53; // [sp+Ch] [bp-F4h]@31
  unsigned int v54; // [sp+10h] [bp-F0h]@9
  int v55; // [sp+14h] [bp-ECh]@24
  int v56; // [sp+18h] [bp-E8h]@26
  _DWORD *v57; // [sp+1Ch] [bp-E4h]@21
  int v58; // [sp+1Ch] [bp-E4h]@31
  unsigned int k; // [sp+20h] [bp-E0h]@24
  int *v60; // [sp+24h] [bp-DCh]@25
  int v61; // [sp+28h] [bp-D8h]@0
  unsigned int v62; // [sp+2Ch] [bp-D4h]@0
  int v63; // [sp+30h] [bp-D0h]@24
  unsigned int *v64; // [sp+34h] [bp-CCh]@24
  int v65; // [sp+38h] [bp-C8h]@11
  int v66; // [sp+3Ch] [bp-C4h]@31
  int v67; // [sp+40h] [bp-C0h]@16
  int v68; // [sp+44h] [bp-BCh]@1
  int v69; // [sp+48h] [bp-B8h]@1
  int v70; // [sp+4Ch] [bp-B4h]@1
  int v71; // [sp+50h] [bp-B0h]@1
  int v72; // [sp+54h] [bp-ACh]@1
  int v73; // [sp+58h] [bp-A8h]@1
  int v74; // [sp+5Ch] [bp-A4h]@1
  int v75; // [sp+60h] [bp-A0h]@1
  int v76; // [sp+64h] [bp-9Ch]@1
  int v77; // [sp+68h] [bp-98h]@1
  int v78; // [sp+6Ch] [bp-94h]@1
  int v79; // [sp+70h] [bp-90h]@1
  int v80; // [sp+74h] [bp-8Ch]@1
  int v81; // [sp+78h] [bp-88h]@1
  int v82; // [sp+7Ch] [bp-84h]@1
  int v83; // [sp+80h] [bp-80h]@1
  int v84; // [sp+84h] [bp-7Ch]@22
  int v85[14]; // [sp+88h] [bp-78h]@17
  int v86; // [sp+C0h] [bp-40h]@41
  int v87[15]; // [sp+C4h] [bp-3Ch]@24
  int v88; // [sp+108h] [bp+8h]@24

  v10 = 0;
  v11 = a1;
  v12 = a2;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v13 = a3;
  do
  {
    ++*(&v68 + *v12);
    ++v12;
    --v13;
  }
  while ( v13 );
  if ( v68 == a3 )
  {
    *a7 = 0;
    *v11 = 0;
    return 0;
  }
  v15 = 1;
  if ( !v69 )
  {
    do
      ++v15;
    while ( !*(&v68 + v15) );
  }
  v16 = v15;
  v51 = v15;
  if ( *v11 > v15 )
    v15 = *v11;
  v54 = v15;
  v17 = 15;
  if ( !v83 )
  {
    do
      --v17;
    while ( !*(&v68 + v17) );
  }
  v65 = v17;
  if ( (signed int)v15 > v17 )
  {
    v54 = v17;
    v15 = v17;
  }
  v18 = 1 << v16;
  *v11 = v15;
  for ( i = v16; i < v17; v18 = 2 * v20 )
  {
    v20 = v18 - *(&v68 + i);
    if ( v20 < 0 )
      return -3;
    ++i;
  }
  v21 = *(&v68 + v17);
  v22 = v18 - v21;
  v67 = v22;
  if ( v22 < 0 )
    return -3;
  v23 = v22 + v21;
  v24 = v17 - 1;
  v25 = 0;
  *(&v68 + v17) = v23;
  v85[0] = 0;
  if ( v17 != 1 )
  {
    v26 = 0;
    do
    {
      v25 += *(int *)((char *)&v69 + v26 * 4);
      ++v26;
      --v24;
      v85[v26] = v25;
    }
    while ( v24 );
  }
  v27 = a2;
  v28 = 0;
  do
  {
    v29 = *v27;
    ++v27;
    v57 = v27;
    if ( v29 )
    {
      v30 = *(&v84 + v29);
      a10[v30] = v28;
      v16 = v51;
      *(&v84 + v29) = v30 + 1;
      v27 = v57;
    }
    ++v28;
  }
  while ( v28 < a3 );
  v88 = *(&v84 + v17);
  v31 = -1;
  v32 = -v15;
  v84 = 0;
  k = 0;
  v64 = a10;
  v87[0] = 0;
  v63 = 0;
  v52 = 0;
  v55 = v16;
  if ( v16 > v17 )
  {
LABEL_60:
    if ( v67 && v17 != 1 )
      result = -5;
    else
      result = 0;
  }
  else
  {
    v33 = v62;
    v60 = &v68 + v16;
    while ( 1 )
    {
      v56 = *v60;
      if ( *v60 )
        break;
LABEL_59:
      v17 = v65;
      ++v60;
      v55 = ++v16;
      if ( v16 > v65 )
        goto LABEL_60;
    }
    while ( 1 )
    {
      --v56;
      v34 = v32 + v15;
      if ( (signed int)(v32 + v15) < v16 )
        break;
LABEL_44:
      BYTE1(v61) = v16 - v32;
      if ( v64 < &a10[v88] )
      {
        v33 = *v64;
        if ( *v64 >= a4 )
        {
          v46 = 4 * (v33 - a4);
          LOBYTE(v61) = *(_BYTE *)(v46 + a6) + 80;
          v33 = *(_DWORD *)(v46 + a5);
        }
        else
        {
          LOBYTE(v61) = v33 < 0x100 ? 0 : 96;
        }
        ++v64;
      }
      else
      {
        LOBYTE(v61) = -64;
      }
      v47 = 1 << (v16 - v32);
      v48 = v10 >> v32;
      if ( v10 >> v32 < v52 )
      {
        v49 = v63 + 8 * v48;
        do
        {
          *(_DWORD *)v49 = v61;
          *(_DWORD *)(v49 + 4) = v33;
          v48 += v47;
          v49 += 8 * v47;
        }
        while ( v48 < v52 );
        v10 = k;
      }
      for ( j = 1 << (v55 - 1); v10 & j; j >>= 1 )
        v10 ^= j;
      v10 ^= j;
      for ( k = v10; (v10 & ((1 << v32) - 1)) != *(&v84 + v31); --v31 )
        v32 -= v54;
      v15 = v54;
      v16 = v55;
      if ( !v56 )
        goto LABEL_59;
    }
    for ( l = v32 - v15; ; l = v58 )
    {
      v66 = v15 + v34;
      v32 += v15;
      ++v31;
      v36 = v65 - v32;
      v53 = v31;
      v58 = v15 + l;
      if ( v65 - v32 > v15 )
        v36 = v15;
      v37 = v16 - v32;
      if ( 1 << v37 > (unsigned int)(v56 + 1) )
      {
        v38 = v60;
        v39 = -1 - v56 + (1 << v37);
        if ( v37 < v36 )
        {
          while ( ++v37 < v36 )
          {
            v40 = v38[1];
            ++v38;
            v41 = 2 * v39;
            if ( v41 <= v40 )
              break;
            v39 = v41 - v40;
          }
        }
        v31 = v53;
      }
      v52 = 1 << v37;
      v42 = *a9 + (1 << v37);
      if ( v42 > 0x5A0 )
        break;
      v43 = a8 + 8 * *a9;
      *a9 = v42;
      v10 = k;
      v87[v31] = v43;
      v63 = v43;
      if ( v31 )
      {
        LOBYTE(v61) = v37;
        v44 = k >> v58;
        v45 = *(&v86 + v31);
        BYTE1(v61) = v54;
        v33 = ((v63 - v45) >> 3) - (k >> v58);
        *(_DWORD *)(v45 + 8 * v44) = v61;
        *(&v84 + v31) = k;
        *(_DWORD *)(v45 + 8 * v44 + 4) = v33;
      }
      else
      {
        *a7 = v43;
      }
      v34 = v66;
      v16 = v55;
      if ( v66 >= v55 )
        goto LABEL_44;
      v15 = v54;
    }
    result = -3;
  }
  return result;
}
// 100717A0: using guessed type int var_78[14];
// 100717A0: using guessed type int var_3C[15];

//----- (10071C40) --------------------------------------------------------
int (__cdecl *__usercall sub_10071C40@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax@3
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax@3

  if ( a1 )
    *a1 = *(_DWORD *)(a2 + 14124);
  v3 = *(_DWORD *)(a2 + 14104);
  *(_DWORD *)(a2 + 14112) = v3;
  *(_DWORD *)(a2 + 14116) = v3;
  result = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a2 + 14120);
  *(_BYTE *)a2 = 0;
  *(_DWORD *)(a2 + 1424) = 0;
  *(_DWORD *)(a2 + 1428) = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    *(_DWORD *)(a2 + 14124) = result;
    *(_DWORD *)(a3 + 28) = result;
  }
  return result;
}

//----- (10071C90) --------------------------------------------------------
int __usercall sub_10071C90@<eax>(int result@<eax>, char a2, char a3, int a4, int a5)
{
  *(_BYTE *)(result + 16) = a2;
  *(_BYTE *)(result + 17) = a3;
  *(_BYTE *)result = 0;
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(result + 24) = a5;
  return result;
}

//----- (10071CB0) --------------------------------------------------------
signed int __cdecl sub_10071CB0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // ebp@1
  unsigned int v7; // ecx@1
  unsigned int v8; // edx@1
  _BYTE *v9; // edi@1
  unsigned int v10; // eax@1
  int v11; // esi@6
  int v12; // ebx@8
  int v13; // esi@8
  int v14; // ecx@8
  int v15; // ecx@11
  int v16; // ebx@13
  unsigned int v17; // eax@13
  unsigned int v18; // edx@13
  int v19; // esi@14
  int v20; // ebx@16
  int v21; // esi@16
  unsigned int v22; // edx@16
  unsigned int v23; // eax@16
  int v24; // ecx@18
  int v25; // ecx@18
  int i; // ebx@19
  char v27; // cl@21
  int v28; // ebx@21
  int v29; // ecx@21
  int v30; // esi@22
  _BYTE *v31; // edi@22
  _BYTE *v32; // esi@22
  unsigned int v33; // ecx@23
  unsigned int v34; // ecx@32
  int v35; // ebp@34
  int v36; // ebx@34
  unsigned int v38; // ecx@35
  int v39; // ebp@37
  int v40; // ebx@37
  int v41; // esi@37
  int v42; // eax@37
  unsigned int v43; // ecx@38
  int v44; // ebp@41
  int v45; // ebx@41
  int v46; // ebp@44
  unsigned int v47; // [sp+10h] [bp-14h]@1
  unsigned int v48; // [sp+14h] [bp-10h]@2
  _BYTE *v49; // [sp+18h] [bp-Ch]@1
  int v50; // [sp+1Ch] [bp-8h]@4
  int v51; // [sp+20h] [bp-4h]@4
  unsigned int v52; // [sp+28h] [bp+4h]@21
  unsigned int v53; // [sp+2Ch] [bp+8h]@13
  int v54; // [sp+2Ch] [bp+8h]@24

  v6 = *(_BYTE **)a6;
  v7 = *(_DWORD *)(a5 + 14112);
  v8 = *(_DWORD *)(a5 + 1428);
  v9 = *(_BYTE **)(a5 + 14116);
  v47 = *(_DWORD *)(a6 + 4);
  v10 = *(_DWORD *)(a5 + 1424);
  v49 = *(_BYTE **)a6;
  if ( (unsigned int)v9 >= v7 )
    v48 = *(_DWORD *)(a5 + 14108) - (_DWORD)v9;
  else
    v48 = v7 - (_DWORD)v9 - 1;
  v50 = dword_101570D0[a1];
  v51 = dword_101570D0[a2];
  while ( 1 )
  {
    if ( v10 < 0x14 )
    {
      do
      {
        --v47;
        v11 = *v6 << v10;
        v10 += 8;
        ++v6;
        v8 |= v11;
      }
      while ( v10 < 0x14 );
      v49 = v6;
    }
    v12 = *(_BYTE *)(a3 + 8 * (v8 & v50));
    v13 = a3 + 8 * (v8 & v50);
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( v12 )
      break;
LABEL_29:
    v10 -= v14;
    *v9++ = *(_BYTE *)(v13 + 4);
    --v48;
LABEL_30:
    if ( v48 < 0x102 || v47 < 0xA )
    {
      v34 = *(_DWORD *)(a6 + 4) - v47;
      if ( v10 >> 3 < v34 )
        v34 = v10 >> 3;
      v35 = (int)&v6[-v34];
      *(_DWORD *)(a6 + 4) = v34 + v47;
      v36 = v35 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v35;
      *(_DWORD *)(a6 + 8) += v36;
      *(_DWORD *)(a5 + 14116) = v9;
      *(_DWORD *)(a5 + 1424) = v10 - 8 * v34;
      *(_DWORD *)(a5 + 1428) = v8;
      return 0;
    }
  }
  v10 -= *(_BYTE *)(v13 + 1);
  if ( v12 & 0x10 )
  {
LABEL_13:
    v16 = v12 & 0xF;
    v17 = v10 - v16;
    v53 = *(_DWORD *)(v13 + 4) + (v8 & dword_101570D0[v16]);
    v18 = v8 >> v16;
    if ( v17 < 0xF )
    {
      do
      {
        --v47;
        v19 = *v6 << v17;
        v17 += 8;
        ++v6;
        v18 |= v19;
      }
      while ( v17 < 0xF );
      v49 = v6;
    }
    v20 = *(_BYTE *)(a4 + 8 * (v18 & v51));
    v21 = a4 + 8 * (v18 & v51);
    v22 = v18 >> *(_BYTE *)(v21 + 1);
    v23 = v17 - *(_BYTE *)(v21 + 1);
    if ( !(v20 & 0x10) )
    {
      while ( !(v20 & 0x40) )
      {
        v24 = *(_DWORD *)(v21 + 4) + (v22 & dword_101570D0[v20]);
        v20 = *(_BYTE *)(v21 + 8 * v24);
        v21 += 8 * v24;
        v25 = *(_BYTE *)(v21 + 1);
        v22 >>= v25;
        v23 -= v25;
        if ( v20 & 0x10 )
          goto LABEL_19;
      }
      v38 = *(_DWORD *)(a6 + 4) - v47;
      if ( v23 >> 3 < v38 )
        v38 = v23 >> 3;
      v39 = (int)&v6[-v38];
      *(_DWORD *)(a6 + 4) = v38 + v47;
      v40 = v39 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v39;
      *(_DWORD *)(a6 + 8) += v40;
      v41 = a5;
      *(_DWORD *)(a5 + 1428) = v22;
      v42 = v23 - 8 * v38;
      goto LABEL_45;
    }
LABEL_19:
    for ( i = v20 & 0xF; v23 < (unsigned __int16)i; ++v49 )
    {
      --v47;
      v22 |= *v6 << v23;
      v6 = v49 + 1;
      v23 += 8;
    }
    v10 = v23 - i;
    v52 = *(_DWORD *)(v21 + 4) + (v22 & dword_101570D0[i]);
    v27 = i;
    v28 = v53;
    v48 -= v53;
    v8 = v22 >> v27;
    v29 = *(_DWORD *)(a5 + 14104);
    if ( (unsigned int)&v9[-v29] < v52 )
    {
      v33 = v52 + v29 - (_DWORD)v9;
      v32 = (_BYTE *)(*(_DWORD *)(a5 + 14108) - v33);
      if ( v53 > v33 )
      {
        v54 = v53 - v33;
        do
        {
          *v9++ = *v32++;
          --v33;
        }
        while ( v33 );
        v32 = *(_BYTE **)(a5 + 14104);
        v28 = v54;
      }
    }
    else
    {
      v30 = (int)&v9[-v52];
      v31 = v9 + 1;
      *(v31 - 1) = *(_BYTE *)v30;
      *v31 = *(_BYTE *)(v30 + 1);
      v9 = v31 + 1;
      v32 = (_BYTE *)(v30 + 2);
      v28 = v53 - 2;
    }
    do
    {
      *v9++ = *v32++;
      --v28;
    }
    while ( v28 );
    goto LABEL_30;
  }
  while ( !(v12 & 0x40) )
  {
    v15 = *(_DWORD *)(v13 + 4) + (v8 & dword_101570D0[v12]);
    v12 = *(_BYTE *)(v13 + 8 * v15);
    v13 += 8 * v15;
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( !v12 )
      goto LABEL_29;
    v10 -= *(_BYTE *)(v13 + 1);
    if ( v12 & 0x10 )
      goto LABEL_13;
  }
  v43 = *(_DWORD *)(a6 + 4) - v47;
  if ( !(v12 & 0x20) )
  {
    if ( v10 >> 3 < v43 )
      v43 = v10 >> 3;
    v46 = (int)&v6[-v43];
    *(_DWORD *)(a6 + 4) = v43 + v47;
    *(_DWORD *)(a6 + 8) += v46 - *(_DWORD *)a6;
    *(_DWORD *)a6 = v46;
    v41 = a5;
    *(_DWORD *)(a5 + 1428) = v8;
    v42 = v10 - 8 * v43;
LABEL_45:
    *(_DWORD *)(v41 + 14116) = v9;
    *(_DWORD *)(v41 + 1424) = v42;
    return -3;
  }
  if ( v10 >> 3 < v43 )
    v43 = v10 >> 3;
  *(_DWORD *)(a6 + 4) = v43 + v47;
  v44 = (int)&v6[-v43];
  v45 = v44 - *(_DWORD *)a6;
  *(_DWORD *)a6 = v44;
  *(_DWORD *)(a6 + 8) += v45;
  *(_DWORD *)(a5 + 1428) = v8;
  *(_DWORD *)(a5 + 14116) = v9;
  *(_DWORD *)(a5 + 1424) = v10 - 8 * v43;
  return 1;
}
// 101570D0: using guessed type int dword_101570D0[];

//----- (10072060) --------------------------------------------------------
int __usercall sub_10072060@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  const void *v3; // ebx@1
  unsigned int v4; // ebp@1
  size_t v5; // eax@3
  size_t v6; // ebp@3
  int (__cdecl *v7)(_DWORD, const void *, size_t); // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int v10; // ebx@10
  const void *v11; // ebx@11
  size_t v12; // eax@13
  size_t v13; // ebp@13
  int (__cdecl *v14)(_DWORD, const void *, size_t); // eax@15
  int v15; // eax@16
  int result; // eax@18
  void *v17; // [sp+8h] [bp-4h]@1
  char *v18; // [sp+8h] [bp-4h]@10

  v3 = *(const void **)(a2 + 14112);
  v4 = *(_DWORD *)(a2 + 14116);
  v17 = *(void **)(a1 + 12);
  if ( (unsigned int)v3 > v4 )
    v4 = *(_DWORD *)(a2 + 14108);
  v5 = *(_DWORD *)(a1 + 16);
  v6 = v4 - (_DWORD)v3;
  if ( v6 > v5 )
    v6 = *(_DWORD *)(a1 + 16);
  if ( v6 && a3 == -5 )
    a3 = 0;
  *(_DWORD *)(a1 + 20) += v6;
  *(_DWORD *)(a1 + 16) = v5 - v6;
  v7 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
  if ( v7 )
  {
    v8 = v7(*(_DWORD *)(a2 + 14124), v3, v6);
    *(_DWORD *)(a2 + 14124) = v8;
    *(_DWORD *)(a1 + 28) = v8;
  }
  memcpy(v17, v3, v6);
  v9 = *(_DWORD *)(a2 + 14108);
  v18 = (char *)v17 + v6;
  v10 = (int)v3 + v6;
  if ( v10 == v9 )
  {
    v11 = *(const void **)(a2 + 14104);
    if ( *(_DWORD *)(a2 + 14116) == v9 )
      *(_DWORD *)(a2 + 14116) = v11;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a2 + 14116) - (_DWORD)v11;
    if ( v13 > v12 )
      v13 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) += v13;
    *(_DWORD *)(a1 + 16) = v12 - v13;
    v14 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
    if ( v14 )
    {
      v15 = v14(*(_DWORD *)(a2 + 14124), v11, v13);
      *(_DWORD *)(a2 + 14124) = v15;
      *(_DWORD *)(a1 + 28) = v15;
    }
    memcpy(v18, v11, v13);
    v18 += v13;
    v10 = (int)v11 + v13;
  }
  *(_DWORD *)(a1 + 12) = v18;
  result = a3;
  *(_DWORD *)(a2 + 14112) = v10;
  return result;
}

//----- (100721A0) --------------------------------------------------------
signed int __usercall sub_100721A0@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4)
{
  signed int result; // eax@1
  int v5; // [sp+0h] [bp-50h]@1
  char v6; // [sp+4h] [bp-4Ch]@1

  v5 = 0;
  result = sub_100717A0(a2, a3, 0x13u, 19, 0, 0, a4, a1, (unsigned int *)&v5, (unsigned int *)&v6);
  if ( result == -5 || !*a2 )
    result = -3;
  return result;
}

//----- (100721F0) --------------------------------------------------------
signed int __usercall sub_100721F0@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9)
{
  unsigned int *v9; // edi@1
  signed int result; // eax@6
  int v11; // [sp+8h] [bp-4h]@1

  v9 = a1;
  v11 = 0;
  if ( sub_100717A0(a7, a6, a4, 257, (int)&unk_10157168, (int)&unk_101571E8, a2, a3, (unsigned int *)&v11, a1)
    || !*a7
    || sub_100717A0(a8, &a6[a4], a5, 0, (int)&unk_10157268, (int)&unk_101572E0, a9, a3, (unsigned int *)&v11, v9)
    || !*a8 && a4 > 0x101 )
  {
    result = -3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10072290) --------------------------------------------------------
int __usercall sub_10072290@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4)
{
  *a1 = 9;
  *a3 = 5;
  *a2 = &unk_10157358;
  *a4 = &unk_10158358;
  return 0;
}

//----- (100722B0) --------------------------------------------------------
signed int __cdecl sub_100722B0(int a1, int a2, int a3, int a4)
{
  int v4; // ecx@1
  signed int v5; // ebx@1

  v4 = a2;
  v5 = 0;
  if ( a2 < 0 )
  {
    v5 = 1;
    v4 = -a2;
  }
  if ( (1 << v4) + 14152 <= a4 && !(a3 & 3) )
  {
    *(_DWORD *)(a1 + 24) = a3;
    *(_DWORD *)(a3 + 16) = v4;
    *(_DWORD *)(a3 + 12) = v5;
    *(_DWORD *)(a3 + 4) = 0;
    *(_DWORD *)(a3 + 20) = a3 + 24;
    *(_DWORD *)(a3 + 14128) = a3 + 14152;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14108) = (1 << v4) + *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14104);
    **(_BYTE **)(a3 + 20) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1428) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1424) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14124) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1420) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14112) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14116) = 0;
    if ( *(_DWORD *)(a3 + 12) )
      *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14120) = 0;
    else
      *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14120) = sub_10071680;
    sub_10071C40(0, *(_DWORD *)(a3 + 20), a1);
    JUMPOUT(&loc_10072160);
  }
  return -4;
}

//----- (100723A0) --------------------------------------------------------
signed int __cdecl sub_100723A0(int a1)
{
  signed int result; // eax@2
  int v2; // ecx@3
  int v3; // esi@3

  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    v3 = *(_DWORD *)(v2 + 20);
    *(_BYTE *)v2 = *(_DWORD *)(v2 + 12) != 0 ? 7 : 0;
    sub_10071C40(0, v3, a1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (100723B0) --------------------------------------------------------
int __usercall sub_100723B0@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // edi@1
  _BYTE *v4; // ebx@1
  int v5; // esi@1
  _BYTE *v6; // edx@1
  unsigned int v7; // ebp@1
  unsigned int v8; // eax@1
  unsigned int v9; // eax@2
  unsigned int v10; // ecx@4
  int v11; // ecx@8
  signed int v12; // eax@8
  int v13; // ecx@8
  unsigned int v14; // eax@8
  int v15; // ecx@13
  int v16; // eax@16
  int v17; // eax@17
  int v18; // ecx@17
  int v19; // eax@17
  int v20; // eax@27
  int v21; // eax@28
  int v22; // ecx@28
  int v23; // ecx@28
  int v24; // eax@31
  int v25; // eax@32
  int v26; // ecx@32
  int v27; // eax@32
  int v28; // eax@38
  int v29; // eax@39
  int v30; // ecx@39
  int v31; // ecx@40
  int v32; // eax@41
  unsigned int v33; // eax@46
  unsigned int v34; // ecx@46
  int v35; // eax@51
  unsigned int v36; // eax@51
  unsigned int v37; // ecx@55
  unsigned int v38; // eax@55
  bool v39; // zf@61
  unsigned int v40; // eax@67
  unsigned int v41; // ecx@67
  int v42; // eax@72
  unsigned int v43; // eax@72
  unsigned int v44; // ecx@76
  unsigned int v45; // eax@76
  int v47; // eax@91
  int v48; // ecx@93
  int v49; // eax@97
  int v50; // ecx@98
  int v51; // eax@101
  int v52; // [sp-4h] [bp-2Ch]@85
  unsigned int v53; // [sp+10h] [bp-18h]@1
  unsigned int v54; // [sp+14h] [bp-14h]@1
  unsigned int v55; // [sp+18h] [bp-10h]@4
  unsigned int v56; // [sp+18h] [bp-10h]@54
  unsigned int v57; // [sp+18h] [bp-10h]@75
  _BYTE *v58; // [sp+20h] [bp-8h]@43
  int v59; // [sp+2Ch] [bp+4h]@51

  v3 = a1;
  v4 = *(_BYTE **)a1;
  v5 = a2;
  v6 = *(_BYTE **)(a2 + 14116);
  v7 = *(_DWORD *)(a2 + 1424);
  v54 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)(a2 + 14112);
  v53 = *(_DWORD *)(a2 + 1428);
  if ( (unsigned int)v6 >= v8 )
    v9 = *(_DWORD *)(a2 + 14108) - (_DWORD)v6;
  else
    v9 = v8 - (_DWORD)v6 - 1;
  v10 = *(_BYTE *)(a2 + 4);
  v55 = v9;
  while ( 2 )
  {
    switch ( v10 )
    {
      case 0u:
        if ( v9 >= 0x102 && v54 >= 0xA )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v11 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v11;
          *(_DWORD *)(v5 + 1428) = v53;
          *(_DWORD *)(v5 + 1424) = v7;
          *(_DWORD *)(v5 + 14116) = v6;
          v12 = sub_10071CB0(
                  *(_BYTE *)(v5 + 20),
                  *(_BYTE *)(v5 + 21),
                  *(_DWORD *)(v5 + 24),
                  *(_DWORD *)(v5 + 28),
                  v5,
                  v3);
          v4 = *(_BYTE **)v3;
          v7 = *(_DWORD *)(v5 + 1424);
          v13 = v12;
          v54 = *(_DWORD *)(v3 + 4);
          v6 = *(_BYTE **)(v5 + 14116);
          v53 = *(_DWORD *)(v5 + 1428);
          v14 = *(_DWORD *)(v5 + 14112);
          a3 = v13;
          v9 = (unsigned int)v6 >= v14 ? *(_DWORD *)(v5 + 14108) - (_DWORD)v6 : v14 - (_DWORD)v6 - 1;
          v55 = v9;
          if ( v13 )
          {
            *(_BYTE *)(v5 + 4) = 2 * (v13 != 1) + 7;
            goto LABEL_84;
          }
        }
        v15 = *(_DWORD *)(v5 + 24);
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 20);
        *(_DWORD *)(v5 + 12) = v15;
        *(_BYTE *)(v5 + 4) = 1;
        goto LABEL_14;
      case 1u:
LABEL_14:
        if ( v7 >= *(_WORD *)(v5 + 16) )
          goto LABEL_17;
        do
        {
          if ( !v54 )
            goto LABEL_91;
          --v54;
          v16 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v16;
        }
        while ( v7 < *(_WORD *)(v5 + 16) );
LABEL_17:
        v17 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_101570D0[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v17 + 1);
        v18 = v17;
        v7 -= *(_BYTE *)(v17 + 1);
        v19 = *(_BYTE *)v17;
        if ( v19 )
        {
          if ( v19 & 0x10 )
          {
            *(_DWORD *)(v5 + 12) = v19 & 0xF;
            *(_DWORD *)(v5 + 8) = *(_DWORD *)(v18 + 4);
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 2;
          }
          else if ( v19 & 0x40 )
          {
            if ( !(v19 & 0x20) )
              goto LABEL_92;
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 7;
          }
          else
          {
            *(_DWORD *)(v5 + 16) = v19;
            v9 = v55;
            *(_DWORD *)(v5 + 12) = v18 + 8 * *(_DWORD *)(v18 + 4);
          }
        }
        else
        {
          v9 = v55;
          *(_DWORD *)(v5 + 12) = *(_DWORD *)(v18 + 4);
          *(_BYTE *)(v5 + 4) = 6;
        }
        goto LABEL_84;
      case 2u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_28;
        do
        {
          if ( !v54 )
            goto LABEL_93;
          --v54;
          v20 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v20;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_28:
        v21 = *(_DWORD *)(v5 + 12);
        v22 = v53 & dword_101570D0[v21];
        *(_BYTE *)(v5 + 4) = 3;
        *(_DWORD *)(v5 + 8) += v22;
        v53 >>= v21;
        v23 = *(_DWORD *)(v5 + 28);
        v7 -= v21;
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 21);
        *(_DWORD *)(v5 + 12) = v23;
LABEL_29:
        if ( v7 < *(_WORD *)(v5 + 16) )
        {
          while ( v54 )
          {
            --v54;
            v24 = *v4 << v7;
            v7 += 8;
            ++v4;
            a3 = 0;
            v53 |= v24;
            if ( v7 >= *(_WORD *)(v5 + 16) )
              goto LABEL_32;
          }
LABEL_91:
          v47 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)(v3 + 4) = 0;
          *(_DWORD *)(v3 + 8) += v47;
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v5 + 14116) = v6;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = a3;
          goto LABEL_90;
        }
LABEL_32:
        v25 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_101570D0[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v25 + 1);
        v26 = v25;
        v7 -= *(_BYTE *)(v25 + 1);
        v27 = *(_BYTE *)v25;
        if ( v27 & 0x10 )
        {
          *(_DWORD *)(v5 + 12) = v27 & 0xF;
          v9 = v55;
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(v26 + 4);
          *(_BYTE *)(v5 + 4) = 4;
        }
        else
        {
          if ( v27 & 0x40 )
          {
LABEL_92:
            *(_BYTE *)(v5 + 4) = 9;
            v52 = -3;
            goto LABEL_86;
          }
          *(_DWORD *)(v5 + 16) = v27;
          v9 = v55;
          *(_DWORD *)(v5 + 12) = v26 + 8 * *(_DWORD *)(v26 + 4);
        }
        goto LABEL_84;
      case 3u:
        goto LABEL_29;
      case 4u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_39;
        do
        {
          if ( !v54 )
          {
LABEL_93:
            v48 = (int)&v4[-*(_DWORD *)v3];
            *(_DWORD *)(v3 + 4) = 0;
            *(_DWORD *)(v3 + 8) += v48;
            v52 = a3;
            goto LABEL_88;
          }
          --v54;
          v28 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v28;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_39:
        v29 = *(_DWORD *)(v5 + 12);
        v30 = v53 & dword_101570D0[v29];
        *(_BYTE *)(v5 + 4) = 5;
        *(_DWORD *)(v5 + 16) += v30;
        v53 >>= v29;
        v7 -= v29;
LABEL_40:
        v31 = *(_DWORD *)(v5 + 16);
        if ( (signed int)&v6[-*(_DWORD *)(v5 + 14104)] >= v31 )
          v32 = (int)&v6[-v31];
        else
          v32 = (int)&v6[*(_DWORD *)(v5 + 14108) - v31 - *(_DWORD *)(v5 + 14104)];
        v58 = (_BYTE *)v32;
        v9 = v55;
        if ( !*(_DWORD *)(v5 + 8) )
        {
LABEL_83:
          *(_BYTE *)(v5 + 4) = 0;
LABEL_84:
          v10 = *(_BYTE *)(v5 + 4);
          if ( v10 > 9 )
          {
LABEL_85:
            v52 = -2;
LABEL_86:
            *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
            goto LABEL_87;
          }
          continue;
        }
        while ( 1 )
        {
          if ( !v9 )
          {
            if ( v6 != *(_BYTE **)(v5 + 14108)
              || (v33 = *(_DWORD *)(v5 + 14112), v34 = *(_DWORD *)(v5 + 14104), v33 == v34)
              || ((v6 = *(_BYTE **)(v5 + 14104), v34 >= v33) ? (v9 = *(_DWORD *)(v5 + 14108) - v34) : (v9 = v33 - v34 - 1),
                  !v9) )
            {
              *(_DWORD *)(v5 + 14116) = v6;
              v35 = sub_10072060(v3, v5, a3);
              v6 = *(_BYTE **)(v5 + 14116);
              v59 = v35;
              v36 = *(_DWORD *)(v5 + 14112);
              if ( (unsigned int)v6 >= v36 )
                v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
              else
                v9 = v36 - (_DWORD)v6 - 1;
              v56 = v9;
              if ( v6 == *(_BYTE **)(v5 + 14108) )
              {
                v37 = *(_DWORD *)(v5 + 14104);
                v38 = *(_DWORD *)(v5 + 14112);
                if ( v38 == v37 )
                {
                  v9 = v56;
                }
                else
                {
                  v6 = *(_BYTE **)(v5 + 14104);
                  if ( v37 >= v38 )
                    v9 = *(_DWORD *)(v5 + 14108) - v37;
                  else
                    v9 = v38 - v37 - 1;
                }
              }
              if ( !v9 )
                break;
            }
          }
          *v6 = *v58;
          --v9;
          ++v6;
          v39 = v58 + 1 == *(_BYTE **)(v5 + 14108);
          a3 = 0;
          v55 = v9;
          ++v58;
          if ( v39 )
            v58 = *(_BYTE **)(v5 + 14104);
          if ( !--*(_DWORD *)(v5 + 8) )
            goto LABEL_83;
        }
LABEL_94:
        *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
        v52 = v59;
LABEL_87:
        *(_DWORD *)(v3 + 4) = v54;
LABEL_88:
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
LABEL_89:
        *(_DWORD *)(v5 + 14116) = v6;
LABEL_90:
        *(_DWORD *)(v5 + 1424) = v7;
        return sub_10072060(v3, v5, v52);
      case 5u:
        goto LABEL_40;
      case 6u:
        if ( !v9 )
        {
          if ( v6 != *(_BYTE **)(v5 + 14108)
            || (v40 = *(_DWORD *)(v5 + 14112), v41 = *(_DWORD *)(v5 + 14104), v40 == v41)
            || ((v6 = *(_BYTE **)(v5 + 14104), v41 >= v40) ? (v9 = *(_DWORD *)(v5 + 14108) - v41) : (v9 = v40 - v41 - 1),
                !v9) )
          {
            *(_DWORD *)(v5 + 14116) = v6;
            v42 = sub_10072060(v3, v5, a3);
            v6 = *(_BYTE **)(v5 + 14116);
            v59 = v42;
            v43 = *(_DWORD *)(v5 + 14112);
            if ( (unsigned int)v6 >= v43 )
              v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
            else
              v9 = v43 - (_DWORD)v6 - 1;
            v57 = v9;
            if ( v6 == *(_BYTE **)(v5 + 14108) )
            {
              v44 = *(_DWORD *)(v5 + 14104);
              v45 = *(_DWORD *)(v5 + 14112);
              if ( v45 == v44 )
              {
                v9 = v57;
              }
              else
              {
                v6 = *(_BYTE **)(v5 + 14104);
                if ( v44 >= v45 )
                  v9 = *(_DWORD *)(v5 + 14108) - v44;
                else
                  v9 = v45 - v44 - 1;
              }
            }
            if ( !v9 )
              goto LABEL_94;
          }
        }
        *v6++ = *(_BYTE *)(v5 + 12);
        --v9;
        a3 = 0;
        v55 = v9;
        goto LABEL_83;
      case 7u:
        if ( v7 > 7 )
        {
          ++v54;
          v7 -= 8;
          --v4;
        }
        *(_DWORD *)(v5 + 14116) = v6;
        v49 = sub_10072060(v3, v5, a3);
        v6 = *(_BYTE **)(v5 + 14116);
        if ( *(_BYTE **)(v5 + 14112) != v6 )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v50 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v50;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = v49;
          goto LABEL_89;
        }
        *(_BYTE *)(v5 + 4) = 8;
LABEL_100:
        v52 = 1;
        goto LABEL_86;
      case 8u:
        goto LABEL_100;
      case 9u:
        v51 = (int)&v4[-*(_DWORD *)v3];
        *(_DWORD *)(v3 + 4) = v54;
        *(_DWORD *)(v3 + 8) += v51;
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
        v52 = -3;
        goto LABEL_89;
      default:
        goto LABEL_85;
    }
  }
}
// 101570D0: using guessed type int dword_101570D0[];

//----- (10072A50) --------------------------------------------------------
int __usercall sub_10072A50@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // edx@1
  unsigned int v5; // ebx@1
  unsigned int v6; // esi@1
  int v7; // edi@1
  size_t v8; // ecx@1
  char *v9; // eax@1
  char *v10; // ecx@1
  int v11; // edx@2
  unsigned int v12; // edx@4
  int v13; // edx@8
  unsigned int v14; // eax@9
  int v15; // eax@10
  int v16; // ebx@14
  int v17; // ecx@14
  int v18; // edx@17
  char *v19; // edx@24
  unsigned int v20; // eax@25
  unsigned int v21; // ecx@25
  int v22; // eax@27
  int v23; // eax@30
  unsigned int v24; // ecx@30
  int v25; // edx@31
  char *v26; // esi@33
  unsigned int v27; // edx@34
  size_t v28; // esi@39
  bool v29; // zf@43
  int v30; // edx@47
  int v31; // ecx@48
  int v32; // edx@54
  unsigned int v33; // ecx@61
  int v34; // edx@63
  int v35; // edx@64
  int v36; // ecx@64
  unsigned int v37; // edx@64
  int v38; // edx@71
  unsigned int v39; // esi@72
  unsigned int v40; // ecx@72
  unsigned int *v41; // eax@77
  unsigned int v42; // esi@81
  int v43; // eax@81
  int v44; // edx@83
  char *v45; // ecx@84
  unsigned int v46; // eax@84
  int v47; // eax@85
  char *v48; // eax@91
  int v49; // ecx@92
  int v50; // ecx@94
  int v51; // edx@96
  int v52; // edx@97
  int v53; // edx@99
  int v55; // eax@102
  int v56; // edx@103
  int v57; // edx@106
  int v58; // [sp-4h] [bp-3Ch]@91
  size_t v59; // [sp+10h] [bp-28h]@1
  char *v60; // [sp+14h] [bp-24h]@1
  char *v61; // [sp+18h] [bp-20h]@1
  unsigned int v62; // [sp+1Ch] [bp-1Ch]@4
  int v63; // [sp+1Ch] [bp-1Ch]@69
  int v64; // [sp+1Ch] [bp-1Ch]@72
  unsigned int v65; // [sp+20h] [bp-18h]@1
  unsigned int v66; // [sp+24h] [bp-14h]@13
  unsigned int v67; // [sp+28h] [bp-10h]@13
  int v68; // [sp+2Ch] [bp-Ch]@13
  int v69; // [sp+30h] [bp-8h]@13
  unsigned int v70; // [sp+34h] [bp-4h]@69
  unsigned int v71; // [sp+3Ch] [bp+4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 14112);
  v5 = *(_DWORD *)(a2 + 1424);
  v6 = *(_DWORD *)(a2 + 1428);
  v7 = a1;
  v8 = *(_DWORD *)(a1 + 4);
  v9 = *(char **)a1;
  v59 = v8;
  v10 = *(char **)(a2 + 14116);
  v61 = v9;
  v71 = *(_DWORD *)(a2 + 1428);
  v65 = v5;
  v60 = v10;
  if ( (unsigned int)v10 >= v4 )
    v11 = *(_DWORD *)(v3 + 14108) - (_DWORD)v10;
  else
    v11 = v4 - (_DWORD)v10 - 1;
  v62 = v11;
  v12 = *(_BYTE *)v3;
  while ( 2 )
  {
    switch ( v12 )
    {
      case 0u:
        for ( ; v5 < 3; v71 = v6 )
        {
          if ( !v59 )
            goto LABEL_91;
          --v59;
          a3 = 0;
          v13 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v13;
        }
        v14 = (v6 & 7) >> 1;
        *(_DWORD *)(v3 + 1420) = v6 & 1;
        if ( !v14 )
        {
          v16 = v5 - 3;
          v17 = v16 & 7;
          v5 = v16 - v17;
          v65 = v5;
          *(_BYTE *)v3 = 1;
          v71 = v6 >> 3 >> v17;
          goto LABEL_89;
        }
        v15 = v14 - 1;
        if ( !v15 )
        {
          sub_10072290(&v67, &v69, &v66, &v68);
          sub_10071C90(v3 + 4, v67, v66, v69, v68);
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 6;
          goto LABEL_89;
        }
        if ( v15 == 1 )
        {
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 3;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 9;
        v49 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v49;
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v3 + 1428) = v71 >> 3;
        v5 -= 3;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      case 1u:
        if ( v5 >= 0x20 )
          goto LABEL_18;
        do
        {
          if ( !v59 )
          {
LABEL_91:
            v48 = v61;
            *(_DWORD *)(v7 + 4) = 0;
            *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
            v58 = a3;
            goto LABEL_110;
          }
          --v59;
          a3 = 0;
          v18 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v18;
          v71 = v6;
        }
        while ( v5 < 0x20 );
LABEL_18:
        if ( ~v6 >> 16 != (unsigned __int16)v6 )
          goto LABEL_93;
        v5 = 0;
        *(_DWORD *)(v3 + 4) = (unsigned __int16)v6;
        v65 = 0;
        v71 = 0;
        if ( (_WORD)v6 )
          *(_BYTE *)v3 = 2;
        else
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
LABEL_89:
        v12 = *(_BYTE *)v3;
        if ( v12 <= 9 )
        {
          v10 = v60;
          v9 = v61;
          v6 = v71;
          continue;
        }
LABEL_107:
        v58 = -2;
        goto LABEL_108;
      case 2u:
        if ( !v59 )
          goto LABEL_94;
        if ( !v62 )
        {
          if ( (v19 = *(char **)(v3 + 14108), v60 != v19)
            || (v20 = *(_DWORD *)(v3 + 14112), v21 = *(_DWORD *)(v3 + 14104), v21 == v20)
            || ((v60 = *(char **)(v3 + 14104), v21 >= v20) ? (v22 = (int)&v19[-v21], v62 = (unsigned int)&v19[-v21]) : (v22 = v20 - v21 - 1, v62 = v22),
                !v22) )
          {
            *(_DWORD *)(v3 + 14116) = v60;
            v23 = sub_10072060(v7, v3, a3);
            v24 = *(_DWORD *)(v3 + 14112);
            v60 = *(char **)(v3 + 14116);
            if ( *(_DWORD *)(v3 + 14116) >= v24 )
              v25 = *(_DWORD *)(v3 + 14108) - (_DWORD)v60;
            else
              v25 = v24 - (_DWORD)v60 - 1;
            v26 = *(char **)(v3 + 14108);
            v62 = v25;
            if ( v60 == v26 )
            {
              v27 = *(_DWORD *)(v3 + 14104);
              if ( v27 != v24 )
              {
                v60 = *(char **)(v3 + 14104);
                if ( v27 >= v24 )
                  v62 = (unsigned int)&v26[-v27];
                else
                  v62 = v24 - v27 - 1;
              }
            }
            if ( !v62 )
              goto LABEL_96;
          }
        }
        v28 = *(_DWORD *)(v3 + 4);
        a3 = 0;
        if ( v28 > v59 )
          v28 = v59;
        if ( v28 > v62 )
          v28 = v62;
        memcpy(v60, v61, v28);
        v61 += v28;
        v59 -= v28;
        v60 += v28;
        v62 -= v28;
        v29 = *(_DWORD *)(v3 + 4) == v28;
        *(_DWORD *)(v3 + 4) -= v28;
        if ( v29 )
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
        goto LABEL_89;
      case 3u:
        if ( v5 >= 0xE )
          goto LABEL_48;
        break;
      case 4u:
        goto LABEL_51;
      case 5u:
        goto LABEL_60;
      case 6u:
        goto LABEL_83;
      case 7u:
        goto LABEL_102;
      case 8u:
        goto LABEL_105;
      case 9u:
        v57 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v7 + 8) += v57;
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      default:
        goto LABEL_107;
    }
    break;
  }
  do
  {
    if ( !v59 )
      goto LABEL_94;
    --v59;
    v30 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v30;
    v71 = v6;
    v61 = v9;
  }
  while ( v5 < 0xE );
LABEL_48:
  v31 = v6 & 0x3FFF;
  *(_DWORD *)(v3 + 4) = v31;
  if ( (v6 & 0x1F) > 0x1D || (v6 & 0x3E0) > 0x3A0 )
  {
LABEL_93:
    *(_BYTE *)v3 = 9;
    v58 = -3;
LABEL_108:
    *(_DWORD *)(v7 + 4) = v59;
LABEL_109:
    v48 = v61;
    *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
    goto LABEL_110;
  }
  v6 >>= 14;
  v5 -= 14;
  v71 = v6;
  v65 = v5;
  *(_DWORD *)(v3 + 8) = 0;
  *(_BYTE *)v3 = 4;
LABEL_51:
  if ( *(_DWORD *)(v3 + 8) < (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
  {
    while ( v5 >= 3 )
    {
LABEL_55:
      *(_DWORD *)(v3 + 4 * dword_10157118[(*(_DWORD *)(v3 + 8))++] + 12) = v6 & 7;
      v6 >>= 3;
      v5 -= 3;
      v71 = v6;
      v65 = v5;
      if ( *(_DWORD *)(v3 + 8) >= (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
        goto LABEL_56;
    }
    while ( v59 )
    {
      --v59;
      v32 = (unsigned __int8)*v9++ << v5;
      v5 += 8;
      a3 = 0;
      v6 |= v32;
      v71 = v6;
      v61 = v9;
      if ( v5 >= 3 )
        goto LABEL_55;
    }
    goto LABEL_94;
  }
LABEL_56:
  while ( *(_DWORD *)(v3 + 8) < 0x13u )
    *(_DWORD *)(v3 + 4 * dword_10157118[(*(_DWORD *)(v3 + 8))++] + 12) = 0;
  *(_DWORD *)(v3 + 1412) = 7;
  v23 = sub_100721A0(v3 + 1432, (unsigned int *)(v3 + 1412), (_DWORD *)(v3 + 12), (int *)(v3 + 1416));
  if ( v23 )
  {
    *(_BYTE *)v3 = 9;
LABEL_96:
    *(_DWORD *)(v7 + 4) = v59;
    v51 = (int)&v61[-*(_DWORD *)v7];
    *(_DWORD *)v7 = v61;
    *(_DWORD *)(v7 + 8) += v51;
    *(_DWORD *)(v3 + 1428) = v71;
    *(_DWORD *)(v3 + 14116) = v60;
    v58 = v23;
    goto LABEL_111;
  }
  v6 = v71;
  *(_DWORD *)(v3 + 8) = 0;
  v9 = v61;
  *(_BYTE *)v3 = 5;
LABEL_60:
  if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
  {
LABEL_81:
    v42 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 1416) = 0;
    v67 = 9;
    v66 = 6;
    v43 = sub_100721F0(
            (unsigned int *)(v3 + 12952),
            &v69,
            v3 + 1432,
            (v42 & 0x1F) + 257,
            ((v42 >> 5) & 0x1F) + 1,
            (_DWORD *)(v3 + 12),
            &v67,
            &v66,
            &v68);
    if ( v43 )
    {
      *(_BYTE *)v3 = 9;
      *(_DWORD *)(v7 + 4) = v59;
      v53 = (int)&v61[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v61;
      *(_DWORD *)(v7 + 8) += v53;
      *(_DWORD *)(v3 + 1428) = v71;
      *(_DWORD *)(v3 + 1424) = v65;
      *(_DWORD *)(v3 + 14116) = v60;
    }
    else
    {
      sub_10071C90(v3 + 4, v67, v66, v69, v68);
      v5 = v65;
      v10 = v60;
      v9 = v61;
      v6 = v71;
      *(_BYTE *)v3 = 6;
LABEL_83:
      *(_DWORD *)(v7 + 4) = v59;
      v44 = (int)&v9[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 8) += v44;
      *(_DWORD *)(v3 + 14116) = v10;
      *(_DWORD *)(v3 + 1428) = v6;
      *(_DWORD *)(v3 + 1424) = v5;
      v43 = sub_100723B0(v7, v3, a3);
      if ( v43 == 1 )
      {
        v5 = *(_DWORD *)(v3 + 1424);
        v61 = *(char **)v7;
        v45 = *(char **)(v3 + 14116);
        v71 = *(_DWORD *)(v3 + 1428);
        v46 = *(_DWORD *)(v3 + 14112);
        a3 = 0;
        v59 = *(_DWORD *)(v7 + 4);
        v65 = *(_DWORD *)(v3 + 1424);
        v60 = v45;
        if ( (unsigned int)v45 >= v46 )
          v47 = *(_DWORD *)(v3 + 14108) - (_DWORD)v45;
        else
          v47 = v46 - (_DWORD)v45 - 1;
        v62 = v47;
        if ( !*(_DWORD *)(v3 + 1420) )
        {
          *(_BYTE *)v3 = 0;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 7;
LABEL_102:
        *(_DWORD *)(v3 + 14116) = v60;
        v55 = sub_10072060(v7, v3, a3);
        v60 = *(char **)(v3 + 14116);
        if ( *(_DWORD *)(v3 + 14112) != *(_DWORD *)(v3 + 14116) )
        {
          *(_DWORD *)(v7 + 4) = v59;
          v56 = (int)&v61[-*(_DWORD *)v7];
          *(_DWORD *)v7 = v61;
          *(_DWORD *)(v7 + 8) += v56;
          *(_DWORD *)(v3 + 1428) = v71;
          *(_DWORD *)(v3 + 1424) = v5;
          *(_DWORD *)(v3 + 14116) = v60;
          return sub_10072060(v7, v3, v55);
        }
        *(_BYTE *)v3 = 8;
LABEL_105:
        *(_DWORD *)(v7 + 4) = v59;
        v58 = 1;
        goto LABEL_109;
      }
    }
    return sub_10072060(v7, v3, v43);
  }
  while ( 1 )
  {
    v33 = *(_WORD *)(v3 + 1412);
    v67 = *(_WORD *)(v3 + 1412);
    if ( v5 < v33 )
      break;
LABEL_64:
    v35 = *(_DWORD *)(v3 + 1416) + 8 * (v6 & dword_101570D0[*(_DWORD *)(v3 + 1412)]);
    v36 = *(_BYTE *)(v35 + 1);
    v37 = *(_DWORD *)(v35 + 4);
    v66 = v37;
    if ( v37 >= 0x10 )
    {
      if ( v37 == 18 )
        v67 = 7;
      else
        v67 = v37 - 14;
      v63 = 8 * (v37 == 18) + 3;
      v70 = (unsigned __int16)(v36 + v67);
      if ( v5 < v70 )
      {
        while ( v59 )
        {
          --v59;
          v38 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          a3 = 0;
          v6 |= v38;
          v71 = v6;
          v61 = v9;
          if ( v5 >= v70 )
            goto LABEL_72;
        }
        v52 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v52;
        *(_DWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = a3;
        goto LABEL_111;
      }
LABEL_72:
      v39 = v6 >> v36;
      v64 = (v39 & dword_101570D0[v67]) + v63;
      v6 = v39 >> v67;
      v5 -= v36 + v67;
      v40 = *(_DWORD *)(v3 + 8);
      v71 = v6;
      v65 = v5;
      if ( v40 + v64 > ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
        goto LABEL_98;
      if ( v66 == 16 )
      {
        if ( v40 < 1 )
        {
LABEL_98:
          *(_BYTE *)v3 = 9;
          *(_DWORD *)(v7 + 4) = v59;
          v58 = -3;
          goto LABEL_109;
        }
        v66 = *(_DWORD *)(v3 + 4 * v40 + 8);
      }
      else
      {
        v66 = 0;
      }
      v41 = (unsigned int *)(v3 + 4 * v40 + 12);
      do
      {
        *v41 = v66;
        ++v40;
        ++v41;
        --v64;
      }
      while ( v64 );
      v9 = v61;
      *(_DWORD *)(v3 + 8) = v40;
    }
    else
    {
      v6 >>= v36;
      v5 -= v36;
      *(_DWORD *)(v3 + 4 * (*(_DWORD *)(v3 + 8))++ + 12) = v37;
      v71 = v6;
      v65 = v5;
    }
    if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
      goto LABEL_81;
  }
  while ( v59 )
  {
    --v59;
    v34 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v34;
    v71 = v6;
    v61 = v9;
    if ( v5 >= v67 )
      goto LABEL_64;
  }
LABEL_94:
  v48 = v61;
  v50 = (int)&v61[-*(_DWORD *)v7];
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) += v50;
  v58 = a3;
LABEL_110:
  *(_DWORD *)v7 = v48;
  *(_DWORD *)(v3 + 14116) = v60;
  *(_DWORD *)(v3 + 1428) = v71;
LABEL_111:
  *(_DWORD *)(v3 + 1424) = v5;
  return sub_10072060(v7, v3, v58);
}
// 101570D0: using guessed type int dword_101570D0[];
// 10157118: using guessed type int dword_10157118[];

//----- (10073430) --------------------------------------------------------
signed int __usercall sub_10073430@<eax>(int a1@<edi>, int a2)
{
  int v2; // ebp@3
  int v3; // ebx@3
  signed int v4; // esi@3
  unsigned int v5; // eax@3
  int v6; // eax@5
  _BYTE *v7; // ecx@6
  int v8; // eax@9
  int v9; // ecx@10
  int v10; // eax@13
  int v11; // eax@21
  int v12; // eax@23
  _BYTE *v13; // edx@24
  int v14; // eax@25
  _BYTE *v15; // ecx@26
  int v16; // eax@27
  signed int result; // eax@32
  int v18; // eax@34
  int v19; // eax@36
  _BYTE *v20; // edx@37
  int v21; // eax@38
  _BYTE *v22; // ecx@39
  int v23; // eax@40
  signed int v24; // [sp+8h] [bp+4h]@3

  if ( !a1 || !*(_DWORD *)a1 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  v3 = -5;
  v4 = a2 != 4 ? 0 : 0xFFFFFFFB;
  v5 = *(_BYTE *)v2;
  v24 = a2 != 4 ? 0 : 0xFFFFFFFB;
  while ( 2 )
  {
    switch ( v5 )
    {
      case 0u:
        v6 = *(_DWORD *)(a1 + 4);
        if ( !v6 )
          goto LABEL_44;
        v7 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v6 - 1;
        *(_DWORD *)(v2 + 4) = *v7;
        ++*(_DWORD *)a1;
        v3 = v4;
        if ( (*(_DWORD *)(v2 + 4) & 0xF) != 8 || (unsigned int)((*(_DWORD *)(v2 + 4) >> 4) + 8) > *(_DWORD *)(v2 + 16) )
          goto LABEL_29;
        *(_BYTE *)v2 = 1;
        goto LABEL_9;
      case 1u:
LABEL_9:
        v8 = *(_DWORD *)(a1 + 4);
        if ( !v8 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v8 - 1;
        v9 = *(_BYTE *)(*(_DWORD *)a1)++;
        v3 = v4;
        if ( (v9 + (*(_DWORD *)(v2 + 4) << 8)) % 0x1Fu )
          goto LABEL_29;
        if ( !(v9 & 0x20) )
        {
          *(_BYTE *)v2 = 7;
LABEL_31:
          v5 = *(_BYTE *)v2;
          if ( v5 > 0xD )
            return -2;
          continue;
        }
        *(_BYTE *)v2 = 2;
LABEL_34:
        v18 = *(_DWORD *)(a1 + 4);
        if ( !v18 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v18 - 1;
        *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
        v3 = v4;
        *(_BYTE *)v2 = 3;
LABEL_36:
        v19 = *(_DWORD *)(a1 + 4);
        if ( !v19 )
          goto LABEL_44;
        v20 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v19 - 1;
        *(_DWORD *)(v2 + 8) += *v20 << 16;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 4;
LABEL_38:
        v21 = *(_DWORD *)(a1 + 4);
        if ( !v21 )
          goto LABEL_44;
        v22 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v21 - 1;
        *(_DWORD *)(v2 + 8) += *v22 << 8;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 5;
LABEL_40:
        v23 = *(_DWORD *)(a1 + 4);
        if ( v23 )
        {
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v23 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(v2 + 8);
          *(_BYTE *)v2 = 6;
          result = 2;
        }
        else
        {
LABEL_44:
          result = v3;
        }
        return result;
      case 7u:
        v10 = sub_10072A50(a1, *(_DWORD *)(v2 + 20), v3);
        v3 = v10;
        if ( v10 == -3 )
        {
          *(_DWORD *)(v2 + 4) = 0;
        }
        else
        {
          if ( !v10 )
            v3 = v4;
          if ( v3 != 1 )
            goto LABEL_44;
          v3 = v4;
          sub_10071C40((_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 20), a1);
          v4 = v24;
          if ( *(_DWORD *)(v2 + 12) )
          {
            *(_BYTE *)v2 = 12;
            goto LABEL_31;
          }
          *(_BYTE *)v2 = 8;
LABEL_21:
          v11 = *(_DWORD *)(a1 + 4);
          if ( !v11 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v11 - 1;
          *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
          v3 = v4;
          *(_BYTE *)v2 = 9;
LABEL_23:
          v12 = *(_DWORD *)(a1 + 4);
          if ( !v12 )
            goto LABEL_44;
          v13 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v12 - 1;
          *(_DWORD *)(v2 + 8) += *v13 << 16;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 10;
LABEL_25:
          v14 = *(_DWORD *)(a1 + 4);
          if ( !v14 )
            goto LABEL_44;
          v15 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v14 - 1;
          *(_DWORD *)(v2 + 8) += *v15 << 8;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 11;
LABEL_27:
          v16 = *(_DWORD *)(a1 + 4);
          if ( !v16 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v16 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          v3 = v4;
          if ( *(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
          {
            *(_BYTE *)v2 = 12;
            return 1;
          }
LABEL_29:
          *(_DWORD *)(v2 + 4) = 5;
        }
        *(_BYTE *)v2 = 13;
        goto LABEL_31;
      case 8u:
        goto LABEL_21;
      case 9u:
        goto LABEL_23;
      case 0xAu:
        goto LABEL_25;
      case 0xBu:
        goto LABEL_27;
      case 2u:
        goto LABEL_34;
      case 3u:
        goto LABEL_36;
      case 4u:
        goto LABEL_38;
      case 5u:
        goto LABEL_40;
      case 6u:
        *(_BYTE *)v2 = 13;
        *(_DWORD *)(v2 + 4) = 0;
        return -2;
      case 0xCu:
        return 1;
      case 0xDu:
        return -3;
      default:
        return -2;
    }
  }
}

//----- (10073760) --------------------------------------------------------
signed int __cdecl sub_10073760(int a1, int a2)
{
  return sub_10073430(a1, a2);
}

//----- (10073780) --------------------------------------------------------
char __cdecl sub_10073780(signed int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax@2
  char result; // al@4

  if ( a1 < 50 && ((v3 = 592 * a1, byte_102F8BB8[592 * a1]) || byte_102F8C08[v3]) )
  {
    *a2 = &byte_102F8BB8[v3];
    *a3 = &byte_102F8C08[v3];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100737C0) --------------------------------------------------------
char *__cdecl sub_100737C0(const char *a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edi@1
  unsigned int v4; // esi@1

  v2 = 0;
  v3 = byte_102F8BB8;
  v4 = 0;
  while ( strcmp(v3, a1) )
  {
    v4 += 592;
    ++v2;
    v3 += 592;
    if ( v4 >= 0x73A0 )
      return (char *)a2;
  }
  return &byte_102F8C08[592 * v2];
}

//----- (10073830) --------------------------------------------------------
char *__usercall sub_10073830@<eax>(char *result@<eax>)
{
  char v1; // cl@2

  for ( ; *result; ++result )
  {
    v1 = *result;
    if ( *result == 10 || v1 == 35 )
    {
      *result = 0;
    }
    else if ( v1 == 92 )
    {
      *result = 47;
    }
  }
  return result;
}

//----- (10073860) --------------------------------------------------------
void __cdecl sub_10073860(char *a1)
{
  char *v1; // eax@3
  char *v2; // edi@3
  char *v3; // eax@4
  int v4; // ST14_4@5
  char *v5; // eax@5
  char v6; // [sp+4h] [bp-204h]@1

  v6 = 0;
  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = strstr(a1, "$$(");
      v2 = v1;
      if ( v1 )
      {
        v3 = strchr(v1 + 3, 41);
        if ( v3 )
        {
          *v2 = 0;
          *v3 = 0;
          v4 = (int)(v3 + 1);
          v5 = sub_100737C0(v2 + 3, (int)&byte_100930C0);
          sprintf(&v6, "%s%s%s", a1, v5, v4);
          sub_10073860(&v6);
          strcpy(a1, &v6);
        }
      }
    }
  }
}

//----- (10073920) --------------------------------------------------------
void __cdecl sub_10073920(char *a1, char *a2)
{
  char *v2; // eax@2
  int v3; // edx@2
  char *v4; // esi@2
  char v5; // cl@3
  char *v6; // eax@4
  char *v7; // esi@4
  char *v8; // edx@4
  char v9; // cl@5

  if ( dword_102F8BB0 < 50 )
  {
    v2 = a1;
    v3 = 592 * dword_102F8BB0;
    v4 = (char *)(&byte_102F8BB8[592 * dword_102F8BB0] - a1);
    do
    {
      v5 = *v2;
      v2[(_DWORD)v4] = *v2;
      ++v2;
    }
    while ( v5 );
    v6 = a2;
    v7 = &byte_102F8C08[v3];
    v8 = (char *)(&byte_102F8C08[v3] - a2);
    do
    {
      v9 = *v6;
      v6[(_DWORD)v8] = *v6;
      ++v6;
    }
    while ( v9 );
    sub_10073860(v7);
    ++dword_102F8BB0;
  }
}
// 102F8BB0: using guessed type int dword_102F8BB0;

//----- (10073980) --------------------------------------------------------
void *__cdecl sub_10073980(int a1)
{
  void *result; // eax@1
  unsigned int v2; // eax@2
  unsigned int v3; // ebp@2
  char *v4; // edi@4
  char *v5; // esi@4
  char *v6; // eax@4
  const char *v7; // esi@6
  const char *v8; // ebx@6
  char *v9; // edi@6
  char *v10; // eax@6
  char v11; // [sp+4h] [bp-204h]@3

  result = memset(byte_102F8BB8, 0, 0x73A0u);
  dword_102F8BB0 = 0;
  if ( a1 )
  {
    v2 = sub_10074AC0(a1, 0);
    v3 = v2;
    if ( v2 )
    {
      if ( sub_10074CA0((int)&v11, 512, v2) )
      {
        do
        {
          sub_10073830(&v11);
          v4 = strstr(&v11, "=");
          v5 = strstr(&v11, "<Var name=\"");
          v6 = strstr(&v11, " value=\"");
          if ( v5 && v6 )
          {
            v7 = v5 + 11;
            v8 = v6 + 8;
            v9 = strchr(v7, 34);
            v10 = strchr(v8, 34);
            if ( v9 )
            {
              if ( v10 )
              {
                *v9 = 0;
                *v10 = 0;
                sub_10073920((char *)v7, (char *)v8);
              }
            }
          }
          else if ( v4 && !strpbrk(&v11, "<>") )
          {
            *v4 = 0;
            sub_10073920(&v11, v4 + 1);
          }
        }
        while ( sub_10074CA0((int)&v11, 512, v3) );
      }
      result = (void *)sub_10074A70(v3);
    }
    else
    {
      result = (void *)sub_10059C60(
                         3,
                         (int)"**Warning**",
                         (int)"..\\lib\\utf\\utf_cnfg.c",
                         (int)"269",
                         (int)"Configuration File",
                         a1,
                         (int)"Unable to open configuration file");
    }
  }
  return result;
}
// 102F8BB0: using guessed type int dword_102F8BB0;

//----- (10073B10) --------------------------------------------------------
void __cdecl sub_10073B10(int a1)
{
  if ( a1 > 0 )
    exit_1(14);
}

//----- (10073B40) --------------------------------------------------------
int __cdecl sub_10073B40(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (10073B60) --------------------------------------------------------
bool __cdecl sub_10073B60(int a1)
{
  return *(_DWORD *)a1 && *(_DWORD *)(a1 + 4) && *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 12);
}

//----- (10073B90) --------------------------------------------------------
void *__cdecl sub_10073B90(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5)
{
  void *v5; // eax@1

  *(_DWORD *)a5 = a1;
  *(_DWORD *)(a5 + 4) = a2;
  *(_DWORD *)(a5 + 8) = a3;
  v5 = (void *)a4(a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
  *(_DWORD *)(a5 + 12) = v5;
  return memset(v5, 0, a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
}

//----- (10073BD0) --------------------------------------------------------
unsigned int __usercall sub_10073BD0@<eax>(int a1@<edx>, int a2, int a3)
{
  return *(_DWORD *)(a1 + 12) + ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3) * (a3 + a2 * *(_DWORD *)(a1 + 4));
}

//----- (10073BF0) --------------------------------------------------------
int __usercall sub_10073BF0@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_BYTE *)(result + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(result + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)result = *(_BYTE *)a2;
  return result;
}

//----- (10073C10) --------------------------------------------------------
char __cdecl sub_10073C10(void (__cdecl *a1)(_DWORD), int a2)
{
  char result; // al@1

  result = sub_10073B60(a2);
  if ( result )
  {
    a1(*(_DWORD *)(a2 + 12));
    result = sub_10073B40(a2);
  }
  return result;
}

//----- (10073C40) --------------------------------------------------------
signed int __cdecl sub_10073C40(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5)
{
  int v5; // ebp@1
  signed int result; // eax@1
  unsigned int v7; // ebx@1
  bool v8; // zf@1
  unsigned int v9; // esi@2
  unsigned int v10; // edi@3
  _BYTE *v11; // eax@3
  _BYTE *v12; // ecx@3
  __int64 v13; // rax@3
  __int64 v14; // rax@4
  __int64 v15; // rax@5
  int v16; // eax@6
  signed int v17; // [sp+Ch] [bp+4h]@1

  v5 = (int)a1;
  result = 0;
  v7 = 0;
  v8 = *a1 == 0;
  v17 = 0;
  if ( v8 )
  {
    *a5 = 0;
  }
  else
  {
    do
    {
      v9 = 0;
      if ( *(_DWORD *)(v5 + 4) )
      {
        do
        {
          v10 = sub_10073BD0(v5, v7, v9);
          v11 = (_BYTE *)sub_10073BD0(a2, v7, v9);
          v12 = v11;
          v13 = *(_BYTE *)v10 - *v11;
          if ( (signed int)((HIDWORD(v13) ^ v13) - HIDWORD(v13)) > a3
            || (v14 = *(_BYTE *)(v10 + 1) - v12[1], (signed int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) > a3)
            || (v15 = *(_BYTE *)(v10 + 2) - v12[2], (signed int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) > a3) )
          {
            v17 = 4;
            v16 = sub_10073BD0(a4, v7, v9);
            sub_10073BF0(v16, (int)&unk_101584FC);
          }
          ++v9;
        }
        while ( v9 < *(_DWORD *)(v5 + 4) );
      }
      ++v7;
    }
    while ( v7 < *(_DWORD *)v5 );
    result = v17;
    *a5 = 0;
  }
  return result;
}

//----- (10073D20) --------------------------------------------------------
void __cdecl sub_10073D20(int a1, int a2, int a3)
{
  unsigned int *v3; // edx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // eax@2
  unsigned int v6; // esi@3
  unsigned int v7; // edi@4
  unsigned int v8; // ebx@4
  unsigned int v9; // ebp@4
  __int64 v10; // rax@4
  __int64 v11; // rax@4
  unsigned int v12; // [sp+4h] [bp-4h]@1

  v3 = (unsigned int *)a1;
  v4 = 0;
  v12 = 0;
  if ( *(_DWORD *)a1 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    do
    {
      v6 = 0;
      if ( v5 )
      {
        do
        {
          v7 = sub_10073BD0((int)v3, v4, v6);
          v8 = sub_10073BD0(a2, v4, v6);
          v9 = sub_10073BD0(a3, v4, v6);
          v10 = *(_BYTE *)(v7 + 2) - *(_BYTE *)(v8 + 2);
          *(_BYTE *)(v9 + 2) = (BYTE4(v10) ^ v10) - BYTE4(v10);
          v11 = *(_BYTE *)(v7 + 1) - *(_BYTE *)(v8 + 1);
          *(_BYTE *)(v9 + 1) = (BYTE4(v11) ^ v11) - BYTE4(v11);
          v3 = (unsigned int *)a1;
          *(_BYTE *)v9 = abs(*(_BYTE *)v7 - *(_BYTE *)v8);
          v5 = *(_DWORD *)(a1 + 4);
          v4 = v12;
          ++v6;
        }
        while ( v6 < v5 );
      }
      v12 = ++v4;
    }
    while ( v4 < *v3 );
  }
}

//----- (10073DD0) --------------------------------------------------------
void *__usercall sub_10073DD0@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3)
{
  int v3; // eax@1
  unsigned int v4; // ebx@3
  int v5; // ebp@4
  int v6; // eax@4
  int v7; // ebp@4
  int v8; // eax@4
  int v9; // ST5C_4@4
  int v10; // eax@4
  int v11; // ebp@4
  int v12; // eax@4
  unsigned int v13; // ebx@6
  size_t v14; // ST3C_4@7
  const void *v15; // ST38_4@7
  void *v16; // eax@7
  unsigned int i; // ebp@8
  unsigned int v18; // ebx@9
  int v19; // ST5C_4@10
  int v20; // eax@10
  int v21; // ST5C_4@10
  int v22; // eax@10
  size_t v23; // ST3C_4@11
  const void *v24; // ST38_4@11
  void *v25; // eax@11
  unsigned int v26; // ebx@12
  size_t v27; // ST3C_4@13
  const void *v28; // ST38_4@13
  void *v29; // eax@13
  void *result; // eax@13
  int v31; // [sp+8h] [bp-18h]@1
  unsigned int v32; // [sp+Ch] [bp-14h]@1
  int v33; // [sp+10h] [bp-10h]@3
  int v34; // [sp+14h] [bp-Ch]@1
  int v35; // [sp+18h] [bp-8h]@1

  v3 = 2 * a3 + *(_DWORD *)a2;
  v35 = 2 * a3 + *(_DWORD *)a2;
  v34 = 2 * a3 + *(_DWORD *)(a2 + 4);
  v32 = (unsigned int)(*(_DWORD *)(a2 + 8) + 7) >> 3;
  v31 = 0;
  while ( 1 )
  {
    v4 = 0;
    v33 = v3 - v31 - 1;
    do
    {
      v5 = sub_10073BD0(a1, v31, v4);
      v6 = sub_10073BD0(a2, 0, 0);
      sub_10073BF0(v5, v6);
      v7 = sub_10073BD0(a1, v33, v4);
      v8 = sub_10073BD0(a2, *(_DWORD *)a2 - 1, 0);
      sub_10073BF0(v7, v8);
      v9 = sub_10073BD0(a1, v31, v34 - v4 - 1);
      v10 = sub_10073BD0(a2, 0, *(_DWORD *)(a2 + 4) - 1);
      sub_10073BF0(v9, v10);
      v11 = sub_10073BD0(a1, v33, v34 - v4 - 1);
      v12 = sub_10073BD0(a2, *(_DWORD *)a2 - 1, *(_DWORD *)(a2 + 4) - 1);
      sub_10073BF0(v11, v12);
      ++v4;
    }
    while ( v4 <= a3 );
    if ( ++v31 > a3 )
      break;
    v3 = v35;
  }
  v13 = 0;
  do
  {
    v14 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v15 = (const void *)sub_10073BD0(a2, 0, 1);
    v16 = (void *)sub_10073BD0(a1, v13, a3 + 1);
    memcpy(v16, v15, v14);
    ++v13;
  }
  while ( v13 <= a3 );
  for ( i = 1; i < *(_DWORD *)a2 - 1; ++i )
  {
    v18 = 0;
    do
    {
      v19 = sub_10073BD0(a1, a3 + i, v18);
      v20 = sub_10073BD0(a2, i, 0);
      sub_10073BF0(v19, v20);
      v21 = sub_10073BD0(a1, i + a3, v34 - v18 - 1);
      v22 = sub_10073BD0(a2, i, *(_DWORD *)(a2 + 4) - 1);
      sub_10073BF0(v21, v22);
      ++v18;
    }
    while ( v18 <= a3 );
    v23 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v24 = (const void *)sub_10073BD0(a2, i, 1);
    v25 = (void *)sub_10073BD0(a1, a3 + i, a3 + 1);
    memcpy(v25, v24, v23);
  }
  v26 = 0;
  do
  {
    v27 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v28 = (const void *)sub_10073BD0(a2, *(_DWORD *)a2 - 1, 1);
    v29 = (void *)sub_10073BD0(a1, v35 - v26 - 1, a3 + 1);
    result = memcpy(v29, v28, v27);
    ++v26;
  }
  while ( v26 <= a3 );
  return result;
}

//----- (10074050) --------------------------------------------------------
void __cdecl sub_10074050(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  unsigned int v4; // esi@3
  unsigned int v5; // edi@4
  unsigned int v6; // ecx@4
  char v7; // al@4

  v2 = 0;
  if ( *(_DWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    do
    {
      v4 = 0;
      if ( v3 )
      {
        do
        {
          v5 = sub_10073BD0(a1, v2, v4);
          v6 = sub_10073BD0(a2, v2, v4++);
          v7 = (signed int)((double)*(_BYTE *)(v5 + 2) * 0.300000011920929
                          + (double)*(_BYTE *)(v5 + 1) * 0.5899999737739563
                          + (double)*(_BYTE *)v5 * 0.1099999994039536);
          *(_BYTE *)(v6 + 2) = v7;
          *(_BYTE *)(v6 + 1) = v7;
          *(_BYTE *)v6 = v7;
          v3 = *(_DWORD *)(a1 + 4);
        }
        while ( v4 < v3 );
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)a1 );
  }
}

//----- (10074120) --------------------------------------------------------
char __cdecl sub_10074120(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4)
{
  char result; // al@1

  result = sub_10073B60(a1);
  if ( result )
  {
    result = sub_10073B60(a4);
    if ( result )
    {
      sub_10073C10(a3, a4);
      sub_10073B90(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), a2, a4);
      result = (unsigned int)memcpy(
                               *(void **)(a4 + 12),
                               *(const void **)(a1 + 12),
                               *(_DWORD *)(a1 + 4) * *(_DWORD *)a1 * ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3));
    }
  }
  return result;
}

//----- (10074190) --------------------------------------------------------
int __usercall sub_10074190@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9)
{
  int (__cdecl *v9)(unsigned int); // edi@1
  long double v10; // st7@1
  unsigned int v11; // ecx@1
  signed int v12; // kr00_4@1
  int v13; // ebx@1
  int v14; // esi@3
  int result; // eax@5
  double v16; // st6@7
  int v17; // eax@7
  double v18; // st3@7
  int v19; // edi@9
  double v20; // rt0@11
  double v21; // st3@11
  double v22; // st6@11
  int v23; // eax@11
  int v24; // ecx@12
  int v25; // ebp@14
  float *v26; // esi@14
  unsigned int v27; // eax@15
  signed int v28; // ecx@15
  float v29; // ST50_4@15
  signed int v30; // edx@15
  signed int v31; // eax@15
  int v32; // ecx@20
  double v33; // st2@20
  double v34; // rtt@21
  double v35; // rt0@23
  double v36; // st2@23
  double v37; // st3@23
  double v38; // rtt@26
  unsigned int v39; // eax@28
  bool v40; // sf@28
  unsigned __int8 v41; // of@28
  float v42; // [sp+8h] [bp-48h]@11
  int v43; // [sp+Ch] [bp-44h]@8
  int v44; // [sp+10h] [bp-40h]@9
  int v45; // [sp+14h] [bp-3Ch]@6
  int v46; // [sp+18h] [bp-38h]@7
  int v47; // [sp+20h] [bp-30h]@11
  signed int v48; // [sp+24h] [bp-2Ch]@1
  int v49; // [sp+28h] [bp-28h]@12
  float v50; // [sp+30h] [bp-20h]@22
  float v51; // [sp+34h] [bp-1Ch]@11
  float v52; // [sp+38h] [bp-18h]@11
  float v53; // [sp+3Ch] [bp-14h]@11
  char v54; // [sp+40h] [bp-10h]@6

  v9 = a2;
  v10 = sqrt((double)a1);
  v11 = (signed int)v10;
  v12 = (signed int)v10;
  v13 = (signed int)v10 / 2;
  v48 = (signed int)v10;
  if ( v9 && a7 )
  {
    v14 = a3;
    if ( *(_DWORD *)(a3 + 4) >= v11 || *(_DWORD *)a3 >= v11 )
    {
      *(_DWORD *)a9 = 0;
      sub_10073B90(2 * v13 + *(_DWORD *)a3, 2 * v13 + *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8), v9, (int)&v54);
      sub_10073DD0((int)&v54, a3, v12 / 2);
      v45 = v12 / 2;
      if ( v13 < v13 + *(_DWORD *)a3 )
      {
        v16 = 0.0;
        v17 = v13 + *(_DWORD *)(a3 + 4);
        v46 = 0;
        v18 = a6;
        do
        {
          v43 = v12 / 2;
          if ( v13 < v17 )
          {
            v19 = v12 / -2;
            v44 = 0;
            while ( 1 )
            {
              v20 = v18;
              v21 = v16;
              v22 = v20;
              v51 = 0.0;
              v42 = v21;
              v52 = 0.0;
              v53 = 0.0;
              v23 = v19;
              v47 = v19;
              if ( v19 <= v13 )
              {
                v24 = v48 * (v19 + v13);
                v49 = v48 * (v19 + v13);
                do
                {
                  if ( v19 <= v13 )
                  {
                    v25 = v23 + v45;
                    v26 = (float *)(a4 + 4 * (v13 + v19 + v24));
                    do
                    {
                      v27 = sub_10073BD0((int)&v54, v25, v19 + v43);
                      v28 = *(_BYTE *)(v27 + 2);
                      v29 = *v26;
                      v30 = *(_BYTE *)(v27 + 1);
                      v31 = *(_BYTE *)v27;
                      ++v19;
                      ++v26;
                      v51 = (double)v28 * v29 + v51;
                      v52 = (double)v30 * v29 + v52;
                      v53 = (double)v31 * v29 + v53;
                      v42 = v29 + v42;
                    }
                    while ( v19 <= v13 );
                    v14 = a3;
                    v23 = v47;
                    v24 = v49;
                    v19 = v12 / -2;
                  }
                  v24 += v48;
                  v47 = ++v23;
                  v49 = v24;
                }
                while ( v23 <= v13 );
              }
              if ( v21 == v22 )
                v22 = v42;
              v32 = 0;
              v33 = a5 + v22;
              while ( 1 )
              {
                v50 = *(&v51 + v32) / v33;
                *(&v51 + v32) = v50;
                if ( v50 > v21 )
                {
                  if ( v50 > 255.0 )
                    *(&v51 + v32) = 255.0;
                  v38 = v33;
                  v36 = v21;
                  v37 = v38;
                }
                else
                {
                  v35 = v33;
                  v36 = v21;
                  v37 = v35;
                  *(&v51 + v32) = v36;
                }
                if ( (unsigned int)++v32 >= 3 )
                  break;
                v34 = v36;
                v33 = v37;
                v21 = v34;
              }
              v39 = sub_10073BD0(a8, v46, v44++);
              *(_BYTE *)(v39 + 2) = (signed int)v51;
              *(_BYTE *)(v39 + 1) = (signed int)v52;
              *(_BYTE *)v39 = (signed int)v53;
              v17 = *(_DWORD *)(v14 + 4) + v13;
              v41 = __OFSUB__(v43 + 1, v17);
              v40 = v43++ + 1 - v17 < 0;
              v18 = v22;
              v16 = v36;
              if ( !(v40 ^ v41) )
                break;
              v19 = v12 / -2;
            }
          }
          ++v46;
          ++v45;
        }
        while ( v45 < v13 + *(_DWORD *)v14 );
      }
      sub_10073C10((void (__cdecl *)(_DWORD))a7, (int)&v54);
      result = 0;
    }
    else
    {
      *(_DWORD *)a9 = "Bitmap too small to filter -- filtering has been disabled";
      sub_10074120(a3, v9, (void (__cdecl *)(_DWORD))a7, a8);
      result = 0;
    }
  }
  else
  {
    *(_DWORD *)a9 = "Dynamic memory function pointers are required for bitmap filtering";
    result = 1;
  }
  return result;
}

//----- (100744F0) --------------------------------------------------------
int __usercall sub_100744F0@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7)
{
  int (__cdecl *v7)(unsigned int); // edi@1
  int v8; // esi@1
  unsigned int v9; // ebx@1
  int v10; // ebp@1
  unsigned int v11; // edi@2
  unsigned int v12; // eax@3
  int v13; // eax@6
  int v15; // [sp+24h] [bp-20h]@1
  int v16; // [sp+34h] [bp-10h]@1

  v7 = a1;
  v8 = a2;
  sub_10073B90(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(a2 + 8), a1, (int)&v16);
  sub_10073D20(v8, a3, (int)&v16);
  sub_10073B90(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(v8 + 8), v7, (int)&v15);
  v9 = 0;
  v10 = sub_10074190(9u, v7, (int)&v16, (int)&unk_101584D8, 0.0, 0.0, (int)a5, (int)&v15, a7);
  if ( *(_DWORD *)v8 )
  {
    do
    {
      v11 = 0;
      if ( *(_DWORD *)(v8 + 4) )
      {
        do
        {
          v12 = sub_10073BD0((int)&v15, v9, v11);
          if ( *(_BYTE *)(v12 + 2) > a4 || *(_BYTE *)(v12 + 1) > a4 || *(_BYTE *)v12 > a4 )
          {
            v10 = 4;
            v13 = sub_10073BD0(a6, v9, v11);
            sub_10073BF0(v13, (int)&unk_101584FC);
          }
          ++v11;
        }
        while ( v11 < *(_DWORD *)(v8 + 4) );
      }
      ++v9;
    }
    while ( v9 < *(_DWORD *)v8 );
  }
  sub_10073C10(a5, (int)&v15);
  sub_10073C10(a5, (int)&v16);
  return v10;
}

//----- (10074600) --------------------------------------------------------
int __cdecl sub_10074600(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10)
{
  bool v10; // cl@6
  bool v11; // al@13
  bool v12; // zf@16
  int result; // eax@16
  const char *v14; // ecx@17
  int v15; // ecx@22
  int v16; // eax@23
  char v17; // [sp+Bh] [bp-5h]@1
  const char *v18; // [sp+Ch] [bp-4h]@1

  v17 = 0;
  v18 = 0;
  v10 = a2 && *(_DWORD *)a2 && *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 12);
  v11 = a3 && *(_DWORD *)a3 && *(_DWORD *)(a3 + 4) && *(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 12);
  if ( !v10 )
  {
    v12 = v11 == 0;
    result = 2;
    if ( v12 )
      v14 = "Actual and Expected bitmaps unavailable";
    else
      v14 = "Actual bitmap is unavailable";
    goto LABEL_33;
  }
  if ( !v11 )
  {
    v14 = "Expected bitmap is unavailable";
    result = 2;
    goto LABEL_33;
  }
  if ( *(_DWORD *)a2 != *(_DWORD *)a3
    || (v15 = *(_DWORD *)(a2 + 4), v15 != *(_DWORD *)(a3 + 4))
    || (v16 = *(_DWORD *)(a2 + 8), v16 != *(_DWORD *)(a3 + 8)) )
  {
    v14 = "Bitmap sizes are different";
    result = 3;
    goto LABEL_33;
  }
  if ( !a6 || !a7 )
  {
    v14 = "Dynamic memory function pointers are required for comparison (build environment error)";
    result = 1;
    goto LABEL_33;
  }
  sub_10073B90(*(_DWORD *)a2, v15, v16, a6, a8);
  sub_10074050(a3, a8);
  if ( a1 )
    result = sub_100744F0(a6, a2, a3, a4, a7, a8, (int)&v18);
  else
    result = sub_10073C40((_DWORD *)a2, a3, a4, a8, &v18);
  if ( !a5 )
    goto LABEL_48;
  if ( result == 4 )
  {
    result = 0;
LABEL_32:
    v14 = v18;
    goto LABEL_33;
  }
  if ( result )
  {
LABEL_48:
    if ( result != 4 )
      goto LABEL_32;
  }
  else
  {
    result = 4;
  }
  if ( a5 )
  {
    v14 = "Images match";
  }
  else
  {
    v17 = 1;
    v14 = "Pixel mismatch";
  }
LABEL_33:
  if ( a10 )
    *a10 = v14;
  if ( a9 )
    *a9 = v17;
  return result;
}

//----- (10074790) --------------------------------------------------------
char __cdecl sub_10074790(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3)
{
  char v3; // bl@1
  unsigned int v4; // eax@5
  unsigned int v5; // esi@5
  char *v6; // ebp@11
  int v7; // esi@11
  unsigned int v8; // ebx@11
  int v9; // edi@11
  char result; // al@20
  char v11; // [sp+8h] [bp-40h]@14
  unsigned int v12; // [sp+Ch] [bp-3Ch]@5
  __int16 v13; // [sp+10h] [bp-38h]@6
  int v14; // [sp+1Ah] [bp-2Eh]@8
  char v15; // [sp+20h] [bp-28h]@9
  int v16; // [sp+24h] [bp-24h]@11
  unsigned int v17; // [sp+28h] [bp-20h]@11
  unsigned __int16 v18; // [sp+2Eh] [bp-1Ah]@10
  char v19; // [sp+4Ch] [bp+4h]@11

  v3 = 0;
  if ( a1 && a2 && *a2 )
  {
    if ( a3 )
    {
      v4 = sub_10074AC0((int)a2, 0);
      v5 = v4;
      v12 = v4;
      if ( v4 )
      {
        if ( sub_10074B20(&v13, 14, v4) == 14
          && v13 == 19778
          && v14 == 54
          && sub_10074B20(&v15, 40, v5) == 40
          && v18 == 24 )
        {
          sub_10073B90(v17, v16, 24, a1, a3);
          v6 = *(char **)(a3 + 12);
          v7 = v16 * (((unsigned int)v18 + 7) >> 3);
          v8 = 0;
          v9 = -(v16 * (((unsigned int)v18 + 7) >> 3)) & 3;
          v19 = 1;
          if ( v17 )
          {
            while ( sub_10074B20(v6, v7, v12) == v7 && (!v9 || sub_10074B20(&v11, v9, v12) == v9) )
            {
              ++v8;
              v6 += v7;
              if ( v8 >= v17 )
                goto LABEL_18;
            }
            v19 = 0;
          }
LABEL_18:
          v3 = v19;
          v5 = v12;
        }
        sub_10074A70(v5);
      }
      result = v3;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100748E0) --------------------------------------------------------
char __usercall sub_100748E0@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  unsigned int v6; // esi@1
  unsigned int v7; // edi@1
  int v8; // eax@1
  unsigned int v9; // eax@1
  unsigned int v10; // ebx@1
  int v12; // [sp+10h] [bp-40h]@4
  int v13; // [sp+14h] [bp-3Ch]@4
  __int16 v14; // [sp+18h] [bp-38h]@1
  int v15; // [sp+1Ah] [bp-36h]@1
  __int16 v16; // [sp+1Eh] [bp-32h]@1
  __int16 v17; // [sp+20h] [bp-30h]@1
  int v18; // [sp+22h] [bp-2Eh]@1
  int v19; // [sp+28h] [bp-28h]@1
  int v20; // [sp+2Ch] [bp-24h]@1
  unsigned int v21; // [sp+30h] [bp-20h]@1
  __int16 v22; // [sp+34h] [bp-1Ch]@1
  __int16 v23; // [sp+36h] [bp-1Ah]@1
  int v24; // [sp+38h] [bp-18h]@1
  int v25; // [sp+3Ch] [bp-14h]@1
  int v26; // [sp+40h] [bp-10h]@1
  int v27; // [sp+44h] [bp-Ch]@1
  int v28; // [sp+48h] [bp-8h]@1
  int v29; // [sp+4Ch] [bp-4h]@1
  char v30; // [sp+54h] [bp+4h]@1

  v5 = a3;
  v6 = a1 * ((unsigned int)(a2 + 7) >> 3);
  v7 = -(a1 * ((unsigned int)(a2 + 7) >> 3)) & 3;
  v8 = a3 * (v7 + v6);
  v25 = v8;
  v15 = v8 + 54;
  v16 = 0;
  v17 = 0;
  v29 = 0;
  v28 = 0;
  v24 = 0;
  v26 = 0;
  v27 = 0;
  v30 = 0;
  v14 = 19778;
  v18 = 54;
  v19 = 40;
  v23 = a2;
  v21 = v5;
  v20 = a1;
  v22 = 1;
  v9 = sub_10074AC0(a5, 1);
  v10 = v9;
  if ( v9 )
  {
    if ( sub_10074B40(&v14, 14, v9) == 14 && sub_10074B40(&v19, 40, v10) == 40 )
    {
      v30 = 1;
      v12 = a4;
      v13 = 0;
      if ( v5 )
      {
        while ( sub_10074B40(v12, v6, v10) == v6 && (!v7 || sub_10074B40(&unk_101586A0, v7, v10) == v7) )
        {
          v12 += v6;
          if ( ++v13 >= v5 )
          {
            sub_10074A70(v10);
            return 1;
          }
        }
        v30 = 0;
      }
    }
    sub_10074A70(v10);
  }
  return v30;
}
// 10074B40: using guessed type _DWORD __cdecl sub_10074B40(_DWORD, _DWORD, _DWORD);

//----- (10074A30) --------------------------------------------------------
char __cdecl sub_10074A30(int a1, int a2)
{
  char result; // al@2

  if ( sub_10073B60(a1) )
    result = sub_100748E0(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)a1, *(_DWORD *)(a1 + 12), a2);
  else
    result = 0;
  return result;
}

//----- (10074A70) --------------------------------------------------------
BOOL __cdecl sub_10074A70(unsigned int a1)
{
  j_FIL_vfs_clean_invalidate_cache(a1);
  return sub_1007CE00(a1) == 0;
}
// 1007CDF0: using guessed type int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD);

//----- (10074A90) --------------------------------------------------------
BOOL __cdecl sub_10074A90(int a1)
{
  return j_FIL_vfs_delete(a1) == 0;
}
// 1007CE40: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);

//----- (10074AC0) --------------------------------------------------------
unsigned int __cdecl sub_10074AC0(int a1, char a2)
{
  unsigned int result; // eax@7
  int v3; // [sp-Ch] [bp-Ch]@3
  signed int v4; // [sp-8h] [bp-8h]@2

  switch ( a2 )
  {
    case 0:
      v4 = 4;
      goto LABEL_6;
    case 1:
      v4 = 10;
      v3 = a1;
      goto LABEL_7;
    case 2:
      v4 = 14;
      v3 = a1;
      goto LABEL_7;
    case 3:
      v4 = 78;
LABEL_6:
      v3 = a1;
LABEL_7:
      result = j_FIL_vfs_open(v3, v4, 0);
      if ( result >= 0xFFFFFFC2 || !result )
        goto LABEL_9;
      break;
    default:
LABEL_9:
      result = 0;
      break;
  }
  return result;
}
// 1007CEC0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10074B20) --------------------------------------------------------
signed int __cdecl sub_10074B20(void *a1, int a2, unsigned int a3)
{
  return sub_1007CED0(a3, a1, a2);
}

//----- (10074B40) --------------------------------------------------------
#error "10074B4F: call analysis failed (funcsize=9)"

//----- (10074B60) --------------------------------------------------------
char __cdecl sub_10074B60(const char *a1, const char *a2)
{
  bool v2; // bl@1
  unsigned int v3; // edi@6
  unsigned int v4; // ebp@7
  signed int v5; // esi@8
  bool i; // zf@8
  char v8; // [sp+Ch] [bp-204h]@8

  v2 = 0;
  if ( !a1 || !*a1 || !a2 || !*a2 )
    return v2;
  if ( strcmp(a1, a2) )
  {
    v3 = sub_10074AC0((int)a1, 0);
    if ( v3 )
    {
      v4 = sub_10074AC0((int)a2, 1);
      if ( v4 )
      {
        v5 = sub_10074B20(&v8, 512, v3);
        for ( i = v5 == 0; v5 > 0; i = v5 == 0 )
        {
          v5 -= sub_10074B40(&v8, v5, v4);
          if ( !v5 )
            v5 = sub_10074B20(&v8, 512, v3);
        }
        v2 = i;
        sub_10074A70(v4);
      }
      sub_10074A70(v3);
    }
    return v2;
  }
  return 1;
}
// 10074B40: using guessed type _DWORD __cdecl sub_10074B40(_DWORD, _DWORD, _DWORD);

//----- (10074CA0) --------------------------------------------------------
int __cdecl sub_10074CA0(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // esi@1
  unsigned __int8 v5; // [sp+13h] [bp-1h]@2

  v3 = 0;
  while ( 1 )
  {
    if ( sub_10074B20(&v5, 1, a3) <= 0 || v5 == -1 )
    {
      *(_BYTE *)(v3 + a1) = 0;
      return v3 > 0 ? a1 : 0;
    }
    if ( v5 == 10 )
      break;
    if ( v5 != 13 )
    {
      *(_BYTE *)(v3++ + a1) = v5;
      if ( v3 >= a2 - 2 )
      {
        *(_BYTE *)(v3 + a1 + 1) = 0;
        return a1;
      }
    }
  }
  *(_BYTE *)(v3 + a1) = 0;
  return a1;
}

//----- (10074D20) --------------------------------------------------------
int __cdecl sub_10074D20(int a1, int a2)
{
  unsigned int v2; // eax@5
  int v3; // eax@8
  int v4; // eax@10
  int result; // eax@11

  if ( a2 && *(_DWORD *)(a2 + 8) && *(_WORD *)(a2 + 12) && *(_DWORD *)(a2 + 4) )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 < 0xFFFFFFC2 && v2 )
    {
      j_IOP_pvg_sk_close(v2, *(_DWORD *)(a2 + 20));
      *(_DWORD *)(a1 + 4) = 0;
    }
    *(_BYTE *)(*(_WORD *)(a2 + 12) + *(_DWORD *)(a2 + 8) - 1) = 0;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 30) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 28) = 0;
    v3 = j_IOP_pvg_sk_create_id(*(_WORD *)a2);
    *(_DWORD *)(a1 + 4) = v3;
    if ( *(_DWORD *)(a2 + 36) )
      j_IOP_pvg_sk_set_addr(v3, 0, *(_DWORD *)(a2 + 36));
    v4 = *(_DWORD *)(a1 + 4);
    if ( *(_BYTE *)(a2 + 14) & 8 )
      result = j_IOP_pvg_sk_connect(v4, *(_DWORD *)(a2 + 16));
    else
      result = j_IOP_pvg_sk_accept(v4, a1 + 8, *(_DWORD *)(a2 + 16));
  }
  else
  {
    result = -59;
  }
  return result;
}
// 1007D1D0: using guessed type int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD);
// 1007D1E0: using guessed type int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD);
// 1007D1F0: using guessed type int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD);
// 1007D200: using guessed type int __cdecl j_IOP_pvg_sk_create_id(_DWORD);
// 1007D2B0: using guessed type int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD);

//----- (10074E60) --------------------------------------------------------
char __usercall sub_10074E60@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5)
{
  _WORD *v5; // edx@1
  int v6; // esi@1
  char result; // al@1
  char v8; // cl@5
  unsigned __int16 v9; // cx@11
  signed int v10; // edi@12
  signed int v11; // esi@12
  size_t v12; // ebp@13

  v5 = a4;
  v6 = a1;
  result = 0;
  if ( *a4 >= a3 )
  {
    *a4 = 0;
    *(_BYTE *)a2 = 0;
  }
  if ( a5 == -1 )
    *(_BYTE *)(v6 + 28) = 3;
  v8 = *(_BYTE *)(v6 + 28);
  if ( v8 )
  {
    *(_BYTE *)(v6 + 28) = v8 - 1;
    result = 0;
  }
  else if ( a5 != 13 && a5 != 10 && a5 )
  {
    *(_BYTE *)((*a4)++ + a2) = a5;
  }
  else
  {
    v9 = *a4;
    if ( *a4 )
    {
      v10 = v9;
      v11 = 0;
      if ( (signed int)v9 > 0 )
      {
        v12 = v9 - 1;
        do
        {
          if ( *(_BYTE *)(v11 + a2) == 8 )
          {
            if ( v11 )
            {
              memcpy_0((void *)(v11 + a2 - 1), (const void *)(v11 + a2 + 1), v10 - v11 - 1);
              v10 -= 2;
              v12 -= 2;
              v11 -= 2;
            }
            else
            {
              memcpy_0((void *)a2, (const void *)(a2 + 1), v12);
              --v10;
              --v12;
              v11 = -1;
            }
            v5 = a4;
          }
          ++v11;
        }
        while ( v11 < v10 );
      }
      *(_BYTE *)(v10 + a2) = 0;
      result = 1;
      *v5 = 0;
    }
  }
  return result;
}

//----- (10074F30) --------------------------------------------------------
signed int __cdecl sub_10074F30(_DWORD *a1, char *a2)
{
  int v2; // esi@1
  int v3; // ebx@4
  int v4; // ebp@4
  int v5; // eax@5
  signed int v6; // edi@5
  int v7; // ST0C_4@9
  char v8; // al@11
  int v10; // [sp+4h] [bp-38h]@4
  __int16 v11; // [sp+8h] [bp-34h]@9

  v2 = (int)a1;
  if ( a1 && *a1 && a2 )
  {
    *a2 = 0;
    v3 = *(_DWORD *)v2;
    v10 = *(_DWORD *)v2;
    v4 = 0;
    while ( 1 )
    {
      v5 = sub_1007D210(*(_DWORD *)(v2 + 4), (int)&a1, 1, 0, v4);
      v6 = v5;
      if ( v5 == -57 )
      {
        if ( v4 == *(_DWORD *)(v3 + 24) )
          return v6;
        v4 = *(_DWORD *)(v3 + 24);
        v6 = 1;
      }
      else
      {
        if ( v5 >= 0 )
        {
          v8 = sub_10074E60(v2, *(_DWORD *)(v3 + 8), *(_WORD *)(v3 + 12), (_WORD *)(v2 + 30), (char)a1);
          v3 = v10;
          *a2 = v8;
          *(_DWORD *)(v2 + 24) += v6;
        }
        else
        {
          v7 = *(_DWORD *)(v2 + 4);
          v11 = 0;
          j_IOP_pvg_sk_status(v7, &v11);
          if ( !(v11 & 0x44) )
            sub_10074D20(v2, v3);
        }
        if ( v6 <= 0 )
          return v6;
      }
      if ( *a2 )
        return v6;
    }
  }
  return -59;
}
// 1007D2C0: using guessed type int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD);

//----- (10075010) --------------------------------------------------------
char __usercall sub_10075010@<al>(void *a1@<esi>)
{
  char result; // al@2
  bool v2; // zf@3
  float *v3; // [sp+0h] [bp-8h]@0

  if ( sub_100789B0(4035, v3) )
  {
    result = 1;
  }
  else
  {
    v2 = (unsigned __int8)sub_1003C0C0(1, 741, 0, 4, a1) == 0;
    result = 1;
    if ( v2 )
      result = 0;
  }
  return result;
}

//----- (10075050) --------------------------------------------------------
char __usercall sub_10075050@<al>(float *a1@<esi>)
{
  char result; // al@1
  void *v2; // [sp+0h] [bp-8h]@0

  result = sub_10045BA0(v2);
  if ( result )
    result = 1;
  else
    *a1 = 9.8999998e24;
  return result;
}

//----- (10075070) --------------------------------------------------------
char __cdecl sub_10075070(float *a1)
{
  char v1; // bl@1
  double v2; // st7@1
  char result; // al@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v5 = 9.8999998e24;
  v1 = 0;
  sub_1007C470(6081, &v4, 4, &v5);
  v2 = v4;
  if ( v4 != 9.8999998e24 )
  {
    v1 = 1;
    v4 = v2 / 3600.0;
    v2 = v4;
  }
  result = v1;
  *a1 = v2;
  return result;
}

//----- (100750D0) --------------------------------------------------------
char __cdecl sub_100750D0(float *a1)
{
  char v1; // bl@1
  double v2; // st7@1
  char result; // al@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v5 = 9.8999998e24;
  v1 = 0;
  sub_1007C470(6937, &v4, 4, &v5);
  v2 = v4;
  if ( v4 != 9.8999998e24 )
  {
    v1 = 1;
    v4 = v2 / 3600.0;
    v2 = v4;
  }
  result = v1;
  *a1 = v2;
  return result;
}

//----- (10075130) --------------------------------------------------------
char __cdecl sub_10075130(float *a1)
{
  char v1; // bl@1
  double v2; // st7@1
  char result; // al@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v5 = 9.8999998e24;
  v1 = 0;
  sub_1007C470(6938, &v4, 4, &v5);
  v2 = v4;
  if ( v4 != 9.8999998e24 )
  {
    v1 = 1;
    v4 = v2 / 3600.0;
    v2 = v4;
  }
  result = v1;
  *a1 = v2;
  return result;
}

//----- (10075190) --------------------------------------------------------
char __usercall sub_10075190@<al>(int a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st7@2
  float v4; // ST14_4@5
  char result; // al@5
  float v6; // [sp+Ch] [bp-8h]@1
  float v7; // [sp+10h] [bp-4h]@1

  v1 = sub_10062520(0x4B6u, &v6);
  v2 = sub_10062520(0x4B7u, &v7);
  if ( v1 )
  {
    v3 = v6;
    if ( v2 )
    {
      if ( v7 <= v3 )
        v3 = v7;
      v4 = v3;
      result = sub_10045330(v4, a1);
    }
    else
    {
      result = sub_10045330(v6, a1);
    }
  }
  else if ( v2 )
  {
    result = sub_10045330(v7, a1);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10075230) --------------------------------------------------------
char __cdecl sub_10075230(float *a1)
{
  char result; // al@2
  float v2; // [sp+4h] [bp-4h]@1

  if ( (unsigned __int8)sub_1003C0C0(1, 949, 0, 4, &v2) )
  {
    result = 1;
    *a1 = 1000.0 * v2 / (10.0 - v2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10075280) --------------------------------------------------------
char __cdecl sub_10075280(float *a1)
{
  char result; // al@2
  float v2; // [sp+4h] [bp-4h]@1

  if ( (unsigned __int8)sub_1003C0C0(1, 950, 0, 4, &v2) )
  {
    result = 1;
    *a1 = 1000.0 * v2 / (10.0 - v2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100752D0) --------------------------------------------------------
char __cdecl sub_100752D0(float *a1)
{
  char result; // al@3
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( (unsigned __int8)sub_1003C0C0(0, 400, 0, 4, &v3) && (unsigned __int8)sub_1003C0C0(1, 527, 0, 4, &v2) )
  {
    result = 1;
    *a1 = v2 * v3 * 0.1047197580337524;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10075330) --------------------------------------------------------
char __cdecl sub_10075330(float *a1)
{
  char result; // al@3
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( (unsigned __int8)sub_1003C0C0(0, 401, 0, 4, &v3) && (unsigned __int8)sub_1003C0C0(1, 530, 0, 4, &v2) )
  {
    result = 1;
    *a1 = v2 * v3 * 0.1047197580337524;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10075390) --------------------------------------------------------
char __usercall sub_10075390@<al>(float *a1@<esi>, char a2)
{
  char v2; // bl@1
  char result; // al@6
  float v4; // [sp+4h] [bp-Ch]@1
  int v5; // [sp+8h] [bp-8h]@1
  float v6; // [sp+Ch] [bp-4h]@1
  char v7; // [sp+14h] [bp+4h]@2
  char v8; // [sp+14h] [bp+4h]@7

  v4 = 9.8999998e24;
  v6 = 9.8999998e24;
  v2 = 0;
  v5 = 0;
  if ( a2 )
  {
    v7 = sub_1003C0C0(6, 617, 0, 4, &v5);
    if ( sub_100789B0(4026, &v4) )
    {
      v2 = 1;
      if ( v7 && v5 & 0x1000 && sub_100789B0(4028, &v6) )
      {
LABEL_6:
        result = 1;
        *a1 = v6 + v4;
        return result;
      }
      goto LABEL_11;
    }
  }
  else
  {
    v8 = sub_1003C0C0(6, 620, 0, 4, &v5);
    if ( sub_100789B0(4027, &v4) )
    {
      v2 = 1;
      if ( v8 && v5 & 0x1000 && sub_100789B0(4029, &v6) )
        goto LABEL_6;
LABEL_11:
      *a1 = v4;
      return v2;
    }
  }
  return v2;
}

//----- (10075480) --------------------------------------------------------
char __cdecl sub_10075480(float a1, int a2)
{
  float v2; // ecx@0
  char v3; // al@3
  char result; // al@5
  float v5; // [sp+0h] [bp-4h]@1

  v5 = v2;
  if ( LOBYTE(a1) == 1 )
  {
    if ( !sub_100789B0(65, &v5) )
      return 0;
    v3 = sub_100789B0(498, &a1);
  }
  else
  {
    if ( !sub_100789B0(61, &v5) )
      return 0;
    v3 = sub_100789B0(477, &a1);
  }
  if ( v3 )
  {
    result = 1;
    *(float *)a2 = (a1 + v5) * 0.5;
    return result;
  }
  return 0;
}

//----- (100754F0) --------------------------------------------------------
char __usercall sub_100754F0@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st7@2
  char result; // al@4
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_1003C0C0(1, 740, 0, 4, &v5);
  v2 = sub_1003C0C0(1, 2172, 0, 4, &v6);
  if ( v1 )
  {
    v3 = v5;
    if ( !v2 || (v5 = v3 - v6, LODWORD(v5) &= 0x7FFFFFFFu, v5 <= 304.8) )
    {
      *a1 = v3;
      return 1;
    }
  }
  else if ( v2 )
  {
    result = 1;
    *a1 = v6;
    return result;
  }
  return 0;
}

//----- (10075570) --------------------------------------------------------
char __cdecl sub_10075570(float *a1)
{
  char result; // al@4
  int v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( (unsigned __int8)sub_1003C0C0(1, 120, 0, 4, &v3)
    && (unsigned __int8)sub_1003C0C0(1, 1775, 0, 4, &v2)
    && !(v2 & 0x7C0000) )
  {
    *a1 = v3;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100755D0) --------------------------------------------------------
char __cdecl sub_100755D0(float *a1)
{
  char v1; // bl@1
  int v2; // eax@3
  char result; // al@14
  int v4; // [sp+4h] [bp-8h]@2
  float v5; // [sp+8h] [bp-4h]@1

  v1 = 0;
  if ( !(unsigned __int8)sub_1003C0C0(1, 122, 0, 4, &v5) || !(unsigned __int8)sub_1003C0C0(1, 996, 0, 4, &v4) )
    goto LABEL_18;
  v2 = v4;
  if ( v4 & 0x40000 )
    v1 = 1;
  if ( v2 & 0x80000 )
    ++v1;
  if ( v2 & 0x100000 )
    ++v1;
  if ( v2 & 0x200000 )
    ++v1;
  if ( v2 & 0x400000 )
    ++v1;
  if ( (unsigned __int8)v1 < 2u )
  {
    *a1 = v5;
    result = 1;
  }
  else
  {
LABEL_18:
    result = 0;
  }
  return result;
}

//----- (10075660) --------------------------------------------------------
char __cdecl sub_10075660(float *a1)
{
  char v1; // bl@1
  int v2; // eax@3
  char result; // al@14
  int v4; // [sp+4h] [bp-8h]@2
  float v5; // [sp+8h] [bp-4h]@1

  v1 = 0;
  if ( !(unsigned __int8)sub_1003C0C0(1, 127, 0, 4, &v5) || !(unsigned __int8)sub_1003C0C0(1, 1004, 0, 4, &v4) )
    goto LABEL_18;
  v2 = v4;
  if ( v4 & 0x40000 )
    v1 = 1;
  if ( v2 & 0x80000 )
    ++v1;
  if ( v2 & 0x100000 )
    ++v1;
  if ( v2 & 0x200000 )
    ++v1;
  if ( v2 & 0x400000 )
    ++v1;
  if ( (unsigned __int8)v1 < 2u )
  {
    *a1 = v5;
    result = 1;
  }
  else
  {
LABEL_18:
    result = 0;
  }
  return result;
}

//----- (100756F0) --------------------------------------------------------
char __usercall sub_100756F0@<al>(float *a1@<esi>)
{
  double v1; // st7@15
  double v2; // st6@19
  double v3; // st7@25
  double v4; // st7@31
  char result; // al@36
  char v6; // [sp+4h] [bp-2Ch]@2
  char v7; // [sp+5h] [bp-2Bh]@5
  char v8; // [sp+6h] [bp-2Ah]@8
  char v9; // [sp+7h] [bp-29h]@11
  float v10; // [sp+8h] [bp-28h]@2
  float v11; // [sp+Ch] [bp-24h]@21
  float v12; // [sp+10h] [bp-20h]@17
  float v13; // [sp+14h] [bp-1Ch]@14
  float v14; // [sp+18h] [bp-18h]@23
  float v15; // [sp+1Ch] [bp-14h]@29
  float v16; // [sp+20h] [bp-10h]@1
  float v17; // [sp+24h] [bp-Ch]@21
  double v18; // [sp+28h] [bp-8h]@21

  *a1 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1003C0C0(1, 1744, 0, 4, &v16) )
    goto LABEL_40;
  v16 = v16 * 61.02374267578125;
  v10 = v16;
  if ( (unsigned __int8)sub_1003C0C0(1, 134, 0, 1, &v6) && !v6 )
    v10 = v10 + 39.90000152587891;
  if ( (unsigned __int8)sub_1003C0C0(1, 634, 0, 1, &v7) && !v7 )
    v10 = v10 + 2.5;
  if ( (unsigned __int8)sub_1003C0C0(1, 649, 0, 1, &v8) && !v8 )
    v10 = v10 + 2.5;
  if ( (unsigned __int8)sub_1003C0C0(1, 1757, 0, 1, &v9) && v9 )
    v10 = v10 + 13.5;
  if ( sub_10045BA0(&v13) )
    v1 = v13 * 1.799999952316284 + 32.0;
  else
    v1 = -65.0;
  v13 = v1;
  if ( (unsigned __int8)sub_1003C0C0(1, 1743, 0, 4, &v12) && v12 != 0.0 )
    v2 = v12 * 0.000145037702168338;
  else
    v2 = 3040.0;
  v12 = v2;
  v17 = v13 + 460.0;
  v18 = 0.0000344 - (v17 - 528.0) * 0.00000005;
  v11 = v18 * (v12 - 100.0) + 1.003999948501587;
  v11 = 100.0 - v17 * (v11 * 248.0) / v12;
  if ( v11 > 0.0 )
    v10 = v11 + v10;
  if ( (unsigned __int8)sub_1003C0C0(1, 1741, 0, 4, &v14) && v14 != 0.0 )
    v3 = v14 * 0.000145037702168338;
  else
    v3 = 3040.0;
  v14 = v3;
  v11 = (v14 - 100.0) * v18 + 1.003999948501587;
  v11 = 50.0 - v11 * 124.0 * v17 / v14;
  if ( v11 > 0.0 )
    v10 = v11 + v10;
  v4 = (unsigned __int8)sub_1003C0C0(1, 1742, 0, 4, &v15) && v15 != 0.0 ? v15 * 0.000145037702168338 : 3040.0;
  v15 = v4;
  v16 = (v15 - 100.0) * v18 + 1.003999948501587;
  v11 = 50.0 - v16 * 124.0 * v17 / v15;
  if ( v11 > 0.0 )
    v10 = v11 + v10;
  v17 = v12 * 631.0 / 250000.0;
  v10 = v17 + v10;
  v17 = 631.0 * ((v13 - 59.0) * 0.0004556);
  v17 = v17 + v10;
  v17 = (v17 - 300.0 + 100.0) / 100.0;
  if ( v17 <= 1.25 )
  {
    *a1 = v17;
    result = 1;
  }
  else
  {
LABEL_40:
    result = 0;
  }
  return result;
}

//----- (10075A90) --------------------------------------------------------
char __usercall sub_10075A90@<al>(float *a1@<esi>)
{
  char result; // al@4
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  *a1 = 0.0;
  if ( sub_10062520(0x40Du, &v3) && sub_10062520(0x40Eu, &v2) && v2 != 0.0 )
  {
    result = 1;
    *a1 = v3 / v2 * 11.35624027252197 + 0.1147093996405602;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10075B00) --------------------------------------------------------
char __usercall sub_10075B00@<al>(float *a1@<esi>)
{
  char result; // al@1
  float *v2; // [sp+0h] [bp-8h]@0

  result = sub_10045D70(v2);
  if ( result )
    result = 1;
  else
    *a1 = 9.8999998e24;
  return result;
}

//----- (10075B20) --------------------------------------------------------
char __usercall sub_10075B20@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st6@3
  char result; // al@4
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_10062520(0x4Fu, &v5);
  v2 = sub_10062520(0x7EAu, &v6);
  if ( v1 )
  {
    if ( !v2 )
    {
      result = 1;
      *a1 = v5;
      return result;
    }
    v3 = v5;
    v5 = v6 - v5;
    LODWORD(v5) &= 0x7FFFFFFFu;
    if ( v5 <= 34473.789 )
    {
      result = 1;
      *a1 = (v6 + v3) * 0.5;
      return result;
    }
  }
  else if ( v2 )
  {
    result = 1;
    *a1 = v6;
    return result;
  }
  return 0;
}

//----- (10075BB0) --------------------------------------------------------
void __usercall sub_10075BB0(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st6@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v1 = sub_10062520(0x51u, &v4);
  v2 = sub_10062520(0x7EBu, &v5);
  if ( v1 )
  {
    if ( !v2 )
    {
      *a1 = v4;
      return;
    }
    v3 = v4;
    v4 = v5 - v4;
    LODWORD(v4) &= 0x7FFFFFFFu;
    if ( v4 <= 5.0 )
    {
      *a1 = (v5 + v3) * 0.5;
      return;
    }
  }
  else if ( v2 )
  {
    *a1 = v5;
    return;
  }
  *a1 = 21.1;
}

//----- (10075C40) --------------------------------------------------------
char __cdecl sub_10075C40(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  float v3; // [sp+8h] [bp-18h]@1
  double v4; // [sp+Ch] [bp-14h]@1
  float v5; // [sp+14h] [bp-Ch]@2
  double v6; // [sp+18h] [bp-8h]@2

  v1 = sub_10075B20((float *)&v4);
  sub_10075BB0(&v3);
  if ( v1 )
  {
    v5 = (v3 + 67.77799987792969) / 27.77799987792969;
    v3 = (*(float *)&v4 + 517.0900268554688) / 4137139.5;
    v4 = v5 * 27.79999923706055;
    v5 = pow(315.0 - v4, 2.0);
    v6 = v5 * 5.470000147278498e-11;
    v5 = pow(v3 * 41.40000152587891, 2.0);
    v6 = v5 * v6;
    v5 = pow(215.0 - v4, 2.0);
    v5 = v6 - v5 * 0.00000005260000079942984 * 41.40000152587891 * v3 + 1.0;
    *a1 = v3 / (v4 + 205.3000030517578) * (1.0 / v5 * 127823.0) - 195.0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10075D60) --------------------------------------------------------
char __usercall sub_10075D60@<al>(float *a1@<esi>, float a2)
{
  char v2; // bl@1
  double v3; // st7@3
  long double v4; // st7@3
  float v6; // [sp+0h] [bp-20h]@1
  float v7; // [sp+4h] [bp-1Ch]@1
  float v8; // [sp+8h] [bp-18h]@3
  float v9; // [sp+Ch] [bp-14h]@1
  int v10; // [sp+10h] [bp-10h]@3
  float v11; // [sp+14h] [bp-Ch]@5
  float v12; // [sp+18h] [bp-8h]@5
  float v13; // [sp+1Ch] [bp-4h]@5
  float v14; // [sp+24h] [bp+4h]@3
  float v15; // [sp+24h] [bp+4h]@3
  unsigned __int8 v16; // [sp+24h] [bp+4h]@3

  v2 = 0;
  v9 = a2 * 32.0 * 0.0005787039990536869;
  v7 = 0.0;
  v6 = 0.0;
  if ( sub_10062520(0x4Fu, &v7) && sub_10062520(0x51u, &v6) )
  {
    *(float *)&v10 = v7 / 101325.0;
    v14 = v6 + 273.0;
    v7 = v7 * 0.000145037702168338;
    v6 = v6 * 1.799999952316284 + 32.0;
    v15 = v14 * 0.08205779641866684 / *(float *)&v10;
    v3 = v15 * 0.002983009908348322;
    v16 = 0;
    v8 = v3;
    v4 = v9;
    do
    {
      if ( v16 >= 5u )
        break;
      v12 = pow(v4, 2.0);
      v11 = pow(v8 / v9, 2.0);
      v11 = (v9 - 0.5099999904632568 * v8) * (v11 * 5140.0 + v7 + 14.69999980926514)
          - (v6 + 460.0) * 10.71000003814697 * v8;
      v13 = v11;
      v11 = pow(v8, 2.0);
      v12 = -((v11 * 7864200.0 + 10710.0 * v12 * v6 + v12 * 510.0 * v7 - 10280000.0 * v9 * v8 + v12 * 4934097.0)
            / (v12
             * 1000.0));
      v13 = v13 / v12;
      v8 = v8 - v13;
      v4 = v9;
      v10 = LODWORD(v13) & 0x7FFFFFFF;
      if ( COERCE_FLOAT(LODWORD(v13) & 0x7FFFFFFF) < 0.001 )
      {
        v2 = 1;
        *a1 = v8 / 0.002983009908348322;
      }
      ++v16;
    }
    while ( !v2 );
  }
  return v2;
}

//----- (10075F60) --------------------------------------------------------
char __usercall sub_10075F60@<al>(float *a1@<esi>, float a2)
{
  char v2; // al@3
  char result; // al@5
  float v4; // [sp+4h] [bp-4h]@3

  if ( LOBYTE(a2) )
  {
    if ( !sub_10025390(1, 1516, 0, 4, &a2) )
      return 0;
    v2 = sub_10025390(0, 356, 0, 4, &v4);
  }
  else
  {
    if ( !sub_10025390(1, 2447, 0, 4, &a2) )
      return 0;
    v2 = sub_10025390(0, 357, 0, 4, &v4);
  }
  if ( v2 )
  {
    result = 1;
    *a1 = a2 - v4;
    return result;
  }
  return 0;
}

//----- (10075FF0) --------------------------------------------------------
char __usercall sub_10075FF0@<al>(float *a1@<eax>)
{
  return sub_10044C50(a1);
}

//----- (10076000) --------------------------------------------------------
char __usercall sub_10076000@<al>(float *a1@<eax>)
{
  return sub_10044D20(a1);
}

//----- (10076010) --------------------------------------------------------
char __usercall sub_10076010@<al>(float *a1@<eax>)
{
  return sub_10044DF0(a1);
}

//----- (10076020) --------------------------------------------------------
char __usercall sub_10076020@<al>(float *a1@<eax>)
{
  return sub_10044EC0(a1);
}

//----- (10076030) --------------------------------------------------------
int __usercall sub_10076030@<eax>(char a1@<dl>, int a2@<ecx>, float *a3)
{
  int result; // eax@1
  int v4; // [sp+0h] [bp-4h]@1

  v4 = a2;
  result = sub_1003C0C0(a1, a2, 0, 4, &v4);
  if ( (_BYTE)result )
    *a3 = (double)v4 * 0.00000008381903171539307;
  return result;
}

//----- (10076060) --------------------------------------------------------
char __usercall sub_10076060@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  double v2; // st7@3
  char result; // al@9
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@2

  v1 = 0;
  if ( sub_10025390(6, 41, 0, 4, &v4) && sub_10025390(6, 42, 0, 4, &v5) )
  {
    v2 = (v5 + v4) * 0.5;
LABEL_8:
    *a1 = v2;
    v1 = 1;
    goto LABEL_9;
  }
  if ( sub_10025390(6, 41, 0, 4, &v4) )
  {
    v2 = v4;
    goto LABEL_8;
  }
  if ( sub_10025390(6, 42, 0, 4, &v5) )
  {
    v2 = v5;
    goto LABEL_8;
  }
LABEL_9:
  result = v1;
  *a1 = *a1 * 1.943844437599182;
  return result;
}

//----- (10076100) --------------------------------------------------------
char __usercall sub_10076100@<al>(float *a1@<esi>)
{
  char result; // al@6
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+6h] [bp-B6h]@3
  char v4; // [sp+7h] [bp-B5h]@4
  char v5; // [sp+8h] [bp-B4h]@5
  char v6; // [sp+9h] [bp-B3h]@2
  float v7; // [sp+14h] [bp-A8h]@6
  float v8; // [sp+20h] [bp-9Ch]@9

  if ( (unsigned __int8)sub_1003C0C0(6, 429, 0, 180, &v2) )
  {
    if ( v6 )
    {
LABEL_9:
      result = 1;
      *a1 = v8;
      return result;
    }
    if ( (!v3 || !v4) && v5 )
      goto LABEL_6;
  }
  if ( (unsigned __int8)sub_1003C0C0(6, 430, 0, 180, &v2) )
  {
    if ( v6 )
      goto LABEL_9;
    if ( (!v3 || !v4) && v5 )
    {
LABEL_6:
      result = 1;
      *a1 = v7;
      return result;
    }
  }
  return 0;
}

//----- (100761E0) --------------------------------------------------------
char __cdecl sub_100761E0(float *a1)
{
  char result; // al@3
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( sub_100789B0(87, &v3) && sub_100789B0(88, &v2) )
  {
    result = 1;
    *a1 = (v2 + v3) * 0.5;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10076230) --------------------------------------------------------
char __usercall sub_10076230@<al>(float *a1@<esi>)
{
  char result; // al@5
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+6h] [bp-B6h]@2
  char v4; // [sp+7h] [bp-B5h]@3
  float v5; // [sp+Ch] [bp-B0h]@5
  float v6; // [sp+18h] [bp-A4h]@9

  if ( (unsigned __int8)sub_1003C0C0(6, 429, 0, 180, &v2) )
  {
    if ( v3 && v4 )
      goto LABEL_9;
    if ( v2 )
    {
LABEL_5:
      result = 1;
      *a1 = v5;
      return result;
    }
  }
  if ( (unsigned __int8)sub_1003C0C0(6, 430, 0, 180, &v2) )
  {
    if ( v3 && v4 )
    {
LABEL_9:
      result = 1;
      *a1 = v6;
      return result;
    }
    if ( v2 )
      goto LABEL_5;
  }
  return 0;
}

//----- (10076310) --------------------------------------------------------
char __usercall sub_10076310@<al>(float *a1@<esi>)
{
  char result; // al@5
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+5h] [bp-B7h]@4
  char v4; // [sp+6h] [bp-B6h]@3
  char v5; // [sp+7h] [bp-B5h]@2
  float v6; // [sp+10h] [bp-ACh]@5
  float v7; // [sp+1Ch] [bp-A0h]@9

  if ( (unsigned __int8)sub_1003C0C0(6, 429, 0, 180, &v2) )
  {
    if ( v5 && v4 )
      goto LABEL_9;
    if ( v3 )
    {
LABEL_5:
      result = 1;
      *a1 = v6;
      return result;
    }
  }
  if ( (unsigned __int8)sub_1003C0C0(6, 430, 0, 180, &v2) )
  {
    if ( v5 && v4 )
    {
LABEL_9:
      result = 1;
      *a1 = v7;
      return result;
    }
    if ( v3 )
      goto LABEL_5;
  }
  return 0;
}

//----- (100763F0) --------------------------------------------------------
char __usercall sub_100763F0@<al>(float *a1@<esi>)
{
  char result; // al@3
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+44h] [bp-78h]@2
  float v4; // [sp+50h] [bp-6Ch]@3

  if ( (unsigned __int8)sub_1003C0C0(6, 429, 0, 180, &v2) && v3
    || (unsigned __int8)sub_1003C0C0(6, 430, 0, 180, &v2) && v3 )
  {
    result = 1;
    *a1 = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10076490) --------------------------------------------------------
char __usercall sub_10076490@<al>(float *a1@<esi>)
{
  char result; // al@3
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+40h] [bp-7Ch]@2
  float v4; // [sp+48h] [bp-74h]@3

  if ( (unsigned __int8)sub_1003C0C0(6, 429, 0, 180, &v2) && v3
    || (unsigned __int8)sub_1003C0C0(6, 430, 0, 180, &v2) && v3 )
  {
    result = 1;
    *a1 = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10076530) --------------------------------------------------------
char __usercall sub_10076530@<al>(float *a1@<esi>)
{
  char result; // al@3
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+41h] [bp-7Bh]@2
  float v4; // [sp+4Ch] [bp-70h]@3

  if ( (unsigned __int8)sub_1003C0C0(6, 429, 0, 180, &v2) && v3
    || (unsigned __int8)sub_1003C0C0(6, 430, 0, 180, &v2) && v3 )
  {
    result = 1;
    *a1 = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100765D0) --------------------------------------------------------
char __usercall sub_100765D0@<al>(float *a1@<esi>)
{
  char result; // al@4
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+80h] [bp-3Ch]@2
  char v4; // [sp+81h] [bp-3Bh]@3
  float v5; // [sp+8Ch] [bp-30h]@7
  float v6; // [sp+98h] [bp-24h]@4

  if ( (unsigned __int8)sub_1003C0C0(6, 429, 0, 180, &v2) )
  {
    if ( v3 )
    {
LABEL_7:
      result = 1;
      *a1 = v5;
      return result;
    }
    if ( v4 )
    {
LABEL_4:
      result = 1;
      *a1 = v6;
      return result;
    }
  }
  if ( (unsigned __int8)sub_1003C0C0(6, 430, 0, 180, &v2) )
  {
    if ( v3 )
      goto LABEL_7;
    if ( v4 )
      goto LABEL_4;
  }
  return 0;
}

//----- (100766B0) --------------------------------------------------------
char __cdecl sub_100766B0(float *a1)
{
  double v1; // st7@2
  char result; // al@5
  float v3; // ST04_4@5
  float v4; // [sp+0h] [bp-Ch]@1
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v4 = 9.8999998e24;
  v5 = sub_10044FD0();
  if ( sub_10044B50(&v6) && (v1 = v5, v5 != 9.8999998e24) )
  {
    if ( v1 >= 3785.411865234375 || v6 <= 0.0001051503277267329 )
    {
      result = 1;
      *a1 = v4;
    }
    else
    {
      result = 1;
      v3 = v1 / v6;
      *a1 = v3;
    }
  }
  else
  {
    *a1 = v4;
    result = 0;
  }
  return result;
}

//----- (10076750) --------------------------------------------------------
bool __cdecl sub_10076750(float *a1)
{
  char v1; // bl@1
  bool v2; // al@1
  double v3; // st6@5
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_100766B0(&v5);
  v2 = sub_10041E50(&v6);
  if ( !v1
    || !v2
    || v5 == 9.8999998e24
    || (LODWORD(v6) & 0x7F800000) == 2139095040
    || (v5 = v5 * v6, v3 = v5, v5 > 37040000.0) )
  {
    v5 = 9.8999998e24;
    v3 = (float)9.8999998e24;
  }
  *a1 = v3;
  return v2 && v1 && v3 != 9.8999998e24;
}

//----- (10076800) --------------------------------------------------------
char __usercall sub_10076800@<al>(float *a1@<esi>)
{
  char result; // al@5
  float v2; // [sp+4h] [bp-8h]@1
  float v3; // [sp+8h] [bp-4h]@2

  *a1 = 9.8999998e24;
  if ( (unsigned __int8)sub_1003C0C0(1, 90, 0, 4, &v2)
    && (unsigned __int8)sub_1003C0C0(1, 115, 0, 4, &v3)
    && v2 != 9.8999998e24
    && v3 != 9.8999998e24 )
  {
    result = 1;
    *a1 = v3 - v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10076880) --------------------------------------------------------
char __usercall sub_10076880@<al>(float *a1@<esi>)
{
  char result; // al@5
  float v2; // [sp+4h] [bp-8h]@1
  float v3; // [sp+8h] [bp-4h]@2

  *a1 = 9.8999998e24;
  if ( (unsigned __int8)sub_1003C0C0(1, 527, 0, 4, &v2)
    && (unsigned __int8)sub_1003C0C0(1, 530, 0, 4, &v3)
    && v2 != 9.8999998e24
    && v3 != 9.8999998e24 )
  {
    result = 1;
    *a1 = v3 - v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10076910) --------------------------------------------------------
char __usercall sub_10076910@<al>(float *a1@<esi>)
{
  char result; // al@4
  float v2; // [sp+0h] [bp-Ch]@1
  float v3; // [sp+4h] [bp-8h]@2
  float v4; // [sp+8h] [bp-4h]@3

  *a1 = 9.8999998e24;
  if ( sub_10041E50(&v2) && (v3 = v2, (LODWORD(v2) & 0x7F800000) != 2139095040) && sub_10044B50(&v4) )
  {
    result = 1;
    if ( v4 > 0.0001051503277267329 )
      *a1 = v2 / v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10076980) --------------------------------------------------------
int __cdecl sub_10076980(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_1003C0C0(1, 74, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1003C0C0(1, 75, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1003C0C0(1, 76, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1003C0C0(1, 77, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1003C0C0(1, 78, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1003C0C0(1, 79, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + 0.05000000074505806 >= v6 )
  {
    v2 = 0.05000000074505806;
  }
  else
  {
    v2 = 0.05000000074505806;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (10076BB0) --------------------------------------------------------
int __cdecl sub_10076BB0(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_1003C0C0(1, 99, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1003C0C0(1, 100, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1003C0C0(1, 101, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1003C0C0(1, 102, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1003C0C0(1, 103, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1003C0C0(1, 104, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + 0.05000000074505806 >= v6 )
  {
    v2 = 0.05000000074505806;
  }
  else
  {
    v2 = 0.05000000074505806;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (10076DE0) --------------------------------------------------------
int __cdecl sub_10076DE0(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_1003C0C0(1, 68, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1003C0C0(1, 69, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1003C0C0(1, 70, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1003C0C0(1, 71, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1003C0C0(1, 72, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1003C0C0(1, 73, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + 0.05000000074505806 >= v6 )
  {
    v2 = 0.05000000074505806;
  }
  else
  {
    v2 = 0.05000000074505806;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (10077010) --------------------------------------------------------
int __cdecl sub_10077010(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_1003C0C0(1, 93, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1003C0C0(1, 94, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1003C0C0(1, 95, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1003C0C0(1, 96, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1003C0C0(1, 97, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1003C0C0(1, 98, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + 0.05000000074505806 >= v6 )
  {
    v2 = 0.05000000074505806;
  }
  else
  {
    v2 = 0.05000000074505806;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (10077240) --------------------------------------------------------
char __usercall sub_10077240@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char result; // al@4
  float v3; // [sp+4h] [bp-24h]@1
  float v4; // [sp+8h] [bp-20h]@1
  char v5; // [sp+Ch] [bp-1Ch]@1
  float v6; // [sp+18h] [bp-10h]@1

  v3 = 9.8999998e24;
  v1 = 0;
  v4 = sub_10044FD0();
  sub_1007C470(41109, &v5, 24, &unk_10158788);
  if ( v6 != 9.8999998e24 && v4 != 9.8999998e24 )
  {
    v1 = 1;
    v3 = v4 - v6;
  }
  result = v1;
  *a1 = v3;
  return result;
}

//----- (100772D0) --------------------------------------------------------
char __usercall sub_100772D0@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char result; // al@3
  float v3; // [sp+4h] [bp-20h]@1
  char v4; // [sp+8h] [bp-1Ch]@1
  float v5; // [sp+14h] [bp-10h]@1

  v3 = 9.8999998e24;
  v1 = 0;
  sub_1007C470(41109, &v4, 24, &unk_10158788);
  if ( v5 != 9.8999998e24 )
  {
    v3 = v5;
    v1 = 1;
  }
  result = v1;
  *a1 = v3;
  return result;
}

//----- (10077340) --------------------------------------------------------
bool __cdecl sub_10077340(float *a1)
{
  bool v1; // bl@1
  bool result; // al@3
  float v3; // [sp+4h] [bp-4h]@1

  v3 = 9.8999998e24;
  v1 = sub_100791D0(&v3, 0, 0, 2) != 0;
  if ( 9.8999998e24 != v3 )
    v3 = sub_10079160() + v3;
  result = v1;
  *a1 = v3;
  return result;
}

//----- (100773A0) --------------------------------------------------------
char __cdecl sub_100773A0(float a1, void *a2)
{
  __int16 v2; // cx@1
  char result; // al@4
  double v4; // st7@32
  double v5; // st7@69
  float v6; // ST0C_4@70
  float v7; // [sp+Ch] [bp-4h]@1
  float v8; // [sp+14h] [bp+4h]@32
  float v9; // [sp+14h] [bp+4h]@35

  HIBYTE(v2) = BYTE1(a1);
  v7 = 9.8999998e24;
  if ( (signed int)LOWORD(a1) > 301 )
  {
    switch ( LOWORD(a1) )
    {
      case 0x12Eu:
        v5 = 511.0;
        goto LABEL_70;
      case 0x12Fu:
        v5 = 1000.0;
        goto LABEL_70;
      case 0x191u:
        result = sub_10075A90((float *)a2);
        break;
      case 0x192u:
        result = sub_10075480(0.0, (int)a2);
        break;
      case 0x193u:
        result = sub_10075480(COERCE_FLOAT(1), (int)a2);
        break;
      case 0x194u:
        result = sub_100761E0((float *)a2);
        break;
      case 0x195u:
        result = sub_10075190((int)a2);
        break;
      case 0x196u:
      case 0x197u:
        result = sub_10075390((float *)a2, LOWORD(a1) == 406);
        break;
      case 0x198u:
      case 0x199u:
        LOBYTE(v2) = LOWORD(a1) == 408;
        result = ((char (__usercall *)@<al>(float *@<esi>, __int16))sub_10075F60)((float *)a2, v2);
        break;
      case 0x19Au:
        result = sub_10076060((float *)a2);
        break;
      case 0x19Bu:
        result = sub_10075010(a2);
        break;
      case 0x19Cu:
        result = sub_10076000((float *)a2);
        break;
      case 0x19Du:
        result = sub_10076010((float *)a2);
        break;
      case 0x19Eu:
        result = sub_10075FF0((float *)a2);
        break;
      case 0x19Fu:
        result = sub_10076020((float *)a2);
        break;
      case 0x1A0u:
        result = sub_1007C470(9145, a2, 4, &v7) == 0;
        break;
      default:
LABEL_88:
        sub_10042930("..\\lib\\adl\\dat_custom_proc_prj.c", 724, 0, 0);
        result = 0;
        break;
    }
  }
  else if ( LOWORD(a1) == 301 )
  {
    v5 = 295.0;
LABEL_70:
    v6 = v5;
    result = sub_10075D60((float *)a2, v6);
  }
  else
  {
    switch ( LOWORD(a1) )
    {
      case 0u:
        return sub_100763F0((float *)a2);
      case 1u:
        return sub_100765D0((float *)a2);
      case 2u:
        return sub_10076230((float *)a2);
      case 3u:
        return sub_10076310((float *)a2);
      case 4u:
        return sub_10076100((float *)a2);
      case 5u:
        return sub_10075C40((float *)a2);
      case 7u:
        return sub_10076490((float *)a2);
      case 6u:
        return sub_10076530((float *)a2);
      case 9u:
        return sub_10075230((float *)a2);
      case 0xAu:
        return sub_10075280((float *)a2);
      case 0xBu:
        return sub_100756F0((float *)a2);
      case 0xDu:
        *(float *)a2 = sub_10044500();
        return 1;
      case 0x38u:
        return sub_10075B20((float *)a2);
      case 0x39u:
        sub_10075BB0((float *)a2);
        goto LABEL_18;
      case 0x3Au:
        return sub_100755D0((float *)a2);
      case 0x3Bu:
        return sub_10075660((float *)a2);
      case 0x3Cu:
        return sub_10075570((float *)a2);
      case 0x3Du:
        return sub_100754F0((float *)a2);
      case 8u:
        return sub_10075050((float *)a2);
      case 0xCu:
        return sub_10075B00((float *)a2);
      case 0xEu:
        return sub_10044BE0((float *)a2);
      case 0xFu:
        return sub_10044F60((float *)a2);
      case 0x10u:
        return sub_10044AA0((float *)a2);
      case 0x11u:
        return sub_10045030((float *)a2);
      case 0x12u:
        return sub_10044B10((float *)a2);
      case 0x13u:
        return sub_10044B30((float *)a2);
      case 0x14u:
        return sub_10044B50((float *)a2);
      case 0x15u:
        v8 = sub_10044FD0();
        v4 = v8;
        *(float *)a2 = v8;
        goto LABEL_33;
      case 0x35u:
        v9 = sub_100444D0();
        v4 = v9;
        *(float *)a2 = v9;
LABEL_33:
        if ( 9.8999998e24 == v4 )
          result = 0;
        else
LABEL_18:
          result = 1;
        break;
      case 0x16u:
        result = sub_100752D0((float *)a2);
        break;
      case 0x17u:
        result = sub_10075330((float *)a2);
        break;
      case 0x18u:
        result = sub_100766B0((float *)a2);
        break;
      case 0x19u:
        result = sub_10076750((float *)a2);
        break;
      case 0x1Au:
        result = sub_10076800((float *)a2);
        break;
      case 0x1Bu:
        result = sub_10076880((float *)a2);
        break;
      case 0x1Cu:
        result = sub_10076910((float *)a2);
        break;
      case 0x1Du:
        result = sub_10076980((float *)a2);
        break;
      case 0x1Eu:
        result = sub_10076BB0((float *)a2);
        break;
      case 0x1Fu:
        result = sub_10076DE0((float *)a2);
        break;
      case 0x20u:
        result = sub_10077010((float *)a2);
        break;
      case 0x21u:
        result = sub_10076030(6, 59, (float *)a2);
        break;
      case 0x22u:
        result = sub_10076030(6, 60, (float *)a2);
        break;
      case 0x23u:
        result = sub_10076030(6, 61, (float *)a2);
        break;
      case 0x24u:
        result = sub_10076030(6, 62, (float *)a2);
        break;
      case 0x25u:
        result = sub_10075070((float *)a2);
        break;
      case 0x26u:
        result = sub_100750D0((float *)a2);
        break;
      case 0x27u:
        result = sub_10075130((float *)a2);
        break;
      case 0x2Au:
        result = sub_1007C470(9000, a2, 4, &v7) == 0;
        break;
      case 0x2Bu:
        result = sub_1007C470(9001, a2, 4, &v7) == 0;
        break;
      case 0x2Cu:
        result = sub_1007C470(9002, a2, 4, &v7) == 0;
        break;
      case 0x2Du:
        result = sub_1007C470(9003, a2, 4, &v7) == 0;
        break;
      case 0x2Eu:
        result = sub_1007C470(9004, a2, 4, &v7) == 0;
        break;
      case 0x2Fu:
        result = sub_1007C470(9005, a2, 4, &v7) == 0;
        break;
      case 0x30u:
        result = sub_1007C470(9006, a2, 4, &v7) == 0;
        break;
      case 0x31u:
        result = sub_1007C470(9007, a2, 4, &v7) == 0;
        break;
      case 0x32u:
        result = sub_1007C470(9008, a2, 4, &v7) == 0;
        break;
      case 0x33u:
        result = sub_1007C470(9009, a2, 4, &v7) == 0;
        break;
      case 0x34u:
        result = sub_1007C470(9010, a2, 4, &v7) == 0;
        break;
      case 0x28u:
        result = sub_10077240((float *)a2);
        break;
      case 0x29u:
        result = sub_100772D0((float *)a2);
        break;
      case 0x36u:
        result = sub_10077340((float *)a2);
        break;
      case 0x37u:
        result = sub_100791D0((float *)a2, 0, 0, 2) != 0;
        break;
      default:
        goto LABEL_88;
    }
  }
  return result;
}

//----- (10077C50) --------------------------------------------------------
char __cdecl sub_10077C50(char a1)
{
  char result; // al@3

  if ( a1 == 20 )
  {
    result = 0;
  }
  else if ( a1 == 21 )
  {
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10077C70) --------------------------------------------------------
signed int __cdecl sub_10077C70(unsigned __int8 a1)
{
  void *v1; // ecx@0
  bool v2; // dl@2
  unsigned __int8 v3; // cl@2
  signed int v4; // ebp@8
  void *v5; // ecx@8
  unsigned __int8 v6; // bl@9
  signed int result; // eax@14
  int v8; // [sp+8h] [bp-250h]@0
  char v9[68]; // [sp+Ch] [bp-24Ch]@9
  char v10; // [sp+50h] [bp-208h]@2
  char v11[2]; // [sp+A8h] [bp-1B0h]@5
  char v12[426]; // [sp+AAh] [bp-1AEh]@4

  if ( sub_10063870(v1) )
  {
    v2 = sub_1007C3B0(6444, (int)&v10, 514) == 0;
    v3 = 0;
    while ( !v2 || !v12[12 * v3] || !(a1 & (unsigned __int8)v11[v3]) )
    {
      if ( ++v3 >= 2u )
        goto LABEL_7;
    }
    result = 0x8000;
  }
  else
  {
LABEL_7:
    LOBYTE(v8) = 0;
    while ( 1 )
    {
      v4 = sub_100627A0(v8);
      if ( (v4 & sub_100460A0(v5)) == v4 )
        break;
LABEL_13:
      LOBYTE(v8) = v8 + 1;
      if ( (unsigned __int8)v8 >= 2u )
        return 0;
    }
    sub_1004E3B0(v8, v9);
    v6 = 0;
    while ( !sub_10046EC0(v8, byte_10159A39[2 * v6]) || !(a1 & (unsigned __int8)v9[12 * v6]) )
    {
      if ( ++v6 >= 2u )
        goto LABEL_13;
    }
    result = v4;
  }
  return result;
}
// 10077C70: using guessed type char var_1AE[426];
// 10077C70: using guessed type char var_1B0[2];
// 10077C70: using guessed type char var_24C[68];

//----- (10077DA0) --------------------------------------------------------
char __cdecl sub_10077DA0(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // eax@1
  int v4; // [sp+8h] [bp-250h]@0
  char v5[68]; // [sp+Ch] [bp-24Ch]@7
  char v6; // [sp+50h] [bp-208h]@1
  char v7[2]; // [sp+A8h] [bp-1B0h]@5
  char v8[426]; // [sp+AAh] [bp-1AEh]@4

  memset(&v6, 0, 0x202u);
  v2 = sub_10077C70(a2);
  if ( v2 == 256 || v2 == 512 )
  {
    LOBYTE(v4) = sub_10062820(v2);
    sub_1004E3B0(v4, v5);
    if ( sub_10046EC0(v4, byte_10159A39[2 * a1]) && (a2 & (unsigned __int8)v5[12 * a1]) == a2 )
      return 1;
  }
  else if ( v2 == 0x8000 )
  {
    sub_1007C3B0(6444, (int)&v6, 514);
    if ( v8[12 * a1] )
    {
      if ( (a2 & (unsigned __int8)v7[a1]) == a2 )
        return 1;
    }
  }
  return 0;
}
// 10077DA0: using guessed type char var_1AE[426];
// 10077DA0: using guessed type char var_1B0[2];
// 10077DA0: using guessed type char var_24C[68];

//----- (10077ED0) --------------------------------------------------------
int __cdecl sub_10077ED0(char a1, char a2)
{
  int v2; // esi@1
  int result; // eax@4

  v2 = dword_1015A24C[2 * sub_10043FF0(&a1, 1u, (int)&unk_1015A248, 8, 3, 3)];
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = v2 + dword_1015A28C[2 * sub_10043FF0(&a2, 1u, (int)&unk_1015A288, 8, 6, 6)];
    }
    else if ( a1 == 2 )
    {
      result = v2 + dword_1015A2BC[2 * sub_10043FF0(&a2, 1u, (int)&unk_1015A2B8, 8, 5, 5)];
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = v2 + dword_1015A264[2 * sub_10043FF0(&a2, 1u, (int)&unk_1015A260, 8, 5, 5)];
  }
  return result;
}
// 1015A24C: using guessed type int dword_1015A24C[];
// 1015A264: using guessed type int dword_1015A264[];
// 1015A28C: using guessed type int dword_1015A28C[];
// 1015A2BC: using guessed type int dword_1015A2BC[];

//----- (10077F80) --------------------------------------------------------
bool __usercall sub_10077F80@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3)
{
  return a2 == 7 && a3 >= (unsigned __int8)byte_101639CF[44 * a1] - (unsigned __int8)byte_101639CA[44 * a1];
}

//----- (10077FB0) --------------------------------------------------------
char __usercall sub_10077FB0@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6)
{
  int v6; // eax@2
  char result; // al@3
  int v8; // eax@4

  if ( sub_10077F80(a1, a4, a5) )
  {
    v6 = a3
       + sub_10077ED0(a1, 6)
       + 36 * (a5 + (unsigned __int8)byte_101639CA[44 * a1] - (unsigned __int8)byte_101639CF[44 * a1]);
    if ( *(_BYTE *)(v6 + 2) == 6 )
    {
      memcpy(a6, (const void *)(v6 + 4), a2);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v8 = sub_10077ED0(a1, a4);
    memcpy(a6, (const void *)(a3 + v8 + a2 * a5), a2);
    result = 1;
  }
  return result;
}

//----- (10078050) --------------------------------------------------------
char __cdecl sub_10078050(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10063DF0(a1);
  sub_1007C430(v5, (int)&v7, 3684);
  return sub_10077FB0(a2, 0x2Cu, (int)&v7, a3, a4, a5);
}

//----- (100780D0) --------------------------------------------------------
char __cdecl sub_100780D0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10063DF0(a1);
  sub_1007C430(v5, (int)&v7, 3684);
  return sub_10077FB0(a2, 3u, (int)&v7, a3, a4, a5);
}

//----- (10078150) --------------------------------------------------------
char __cdecl sub_10078150(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10063DF0(a1);
  sub_1007C430(v5, (int)&v7, 3684);
  return sub_10077FB0(a2, 0x24u, (int)&v7, a3, a4, a5);
}

//----- (100781D0) --------------------------------------------------------
char __cdecl sub_100781D0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10063DF0(a1);
  sub_1007C430(v5, (int)&v7, 3684);
  return sub_10077FB0(a2, 0xCu, (int)&v7, a3, a4, a5);
}

//----- (10078250) --------------------------------------------------------
char __cdecl sub_10078250(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xC:
    case 0x3F:
      result = 0;
      break;
    case 0xD:
    case 0x40:
      result = 1;
      break;
    case 0xE:
    case 0x41:
      result = 2;
      break;
    case 0x2A:
    case 0x42:
      result = 3;
      break;
    default:
      sub_10042930("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_utl.c", 139, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (100782F0) --------------------------------------------------------
int __cdecl sub_100782F0(int a1)
{
  return (*(int (**)(void))(a1 + 4))();
}

//----- (10078300) --------------------------------------------------------
int __cdecl sub_10078300(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = a3;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 88) = a2;
  return result;
}

//----- (10078320) --------------------------------------------------------
int (__cdecl *__usercall sub_10078320@<eax>(int a1@<eax>, int a2@<ecx>))(int)
{
  int (__cdecl *result)(int); // eax@1

  result = *(int (__cdecl **)(int))(a1 + 88);
  if ( result )
    result = (int (__cdecl *)(int))result(a2);
  return result;
}

//----- (10078330) --------------------------------------------------------
int __usercall sub_10078330@<eax>(unsigned __int8 *a1@<eax>, int a2)
{
  signed int v2; // edi@1
  int v3; // ebp@1
  unsigned __int8 *v4; // ebx@1
  unsigned __int8 v5; // al@2
  int v6; // esi@4

  v2 = 0;
  v3 = a2 + 92;
  *(_BYTE *)(a2 + 92) = 0;
  v4 = a1;
  do
  {
    v5 = *v4;
    if ( !*v4 )
      break;
    switch ( v5 )
    {
      case 0x22u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1869967654;
        *(_WORD *)(v6 + 4) = 15220;
        *(_BYTE *)(v6 + 6) = 0;
        break;
      case 0x3Cu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997485606;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x3Eu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997484326;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x26u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1886216486;
        *(_WORD *)(v6 + 4) = 59;
        break;
      case 7u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 24924;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 8u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 25180;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xCu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 26204;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xAu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 28252;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xDu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29276;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 9u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29788;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xBu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 30300;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      default:
        v6 = v2 + v3;
        if ( isprint(v5) )
        {
          *(_BYTE *)v6 = *v4;
          *(_BYTE *)(v2 + a2 + 93) = 0;
        }
        else
        {
          _snprintf((char *)(v2 + v3), 512 - v2, "\\x%x", *v4);
          *(_BYTE *)(a2 + 603) = 0;
        }
        break;
    }
    v2 += strlen((const char *)v6);
    ++v4;
  }
  while ( v2 < 502 );
  return a2 + 92;
}

//----- (10078560) --------------------------------------------------------
int (__cdecl *__cdecl sub_10078560(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_10078320(a1, (int)word_1009F07C);
  sub_10078320(a1, a2);
  sub_10078320(a1, (int)&unk_1015D2CC);
  v3 = sub_10078330(a3, a1);
  sub_10078320(a1, v3);
  return sub_10078320(a1, (int)&unk_1015D2C8);
}

//----- (100785B0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100785B0(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_10078320(a1, (int)word_1009F07C);
  sub_10078320(a1, a2);
  sub_10078320(a1, (int)&unk_1015D2D4);
  v3 = sub_10078330(a3, a1);
  sub_10078320(a1, v3);
  return sub_10078320(a1, (int)&unk_1015D2D0);
}

//----- (10078600) --------------------------------------------------------
int (__cdecl *__cdecl sub_10078600(int a1, unsigned __int8 *a2))(int)
{
  int (__cdecl *result)(int); // eax@1
  int v3; // eax@4

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      sub_10078320(a1, (int)&unk_1015D2D8);
      *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    }
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 7) = 1;
    v3 = sub_10078330(a2, a1);
    result = sub_10078320(a1, v3);
  }
  return result;
}

//----- (10078650) --------------------------------------------------------
int (__cdecl *__cdecl sub_10078650(int a1))(int)
{
  int (__cdecl *result)(int); // eax@1
  void *v2; // ecx@3
  bool v3; // zf@7

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      v2 = &unk_1015D2E0;
    }
    else
    {
      if ( !*(_BYTE *)(a1 + 8 * (_DWORD)result - 7) )
        sub_10078320(a1, dword_1015D234[(signed int)result]);
      sub_10078320(a1, (int)&unk_1015D2DC);
      sub_10078320(a1, *(_DWORD *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 4));
      v2 = &unk_1015D2D8;
    }
    result = sub_10078320(a1, (int)v2);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    v3 = (*(_DWORD *)(a1 + 80))-- == 1;
    if ( v3 )
      result = sub_10078320(a1, (int)&word_10146234);
  }
  return result;
}
// 10146234: using guessed type __int16 word_10146234;
// 1015D234: using guessed type int dword_1015D234[];

//----- (100786D0) --------------------------------------------------------
int __cdecl sub_100786D0(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@4

  v2 = *(_DWORD *)(a1 + 80);
  if ( v2 > 0 && *(_BYTE *)(a1 + 8 * v2 - 8) )
  {
    sub_10078320(a1, (int)&unk_1015D2D8);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
  }
  sub_10078320(a1, (int)(&off_1015D238)[2 * (*(_DWORD *)(a1 + 80) + *(_DWORD *)(a1 + 84))]);
  sub_10078320(a1, (int)&unk_1015D2E4);
  sub_10078320(a1, a2);
  *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80)) = 1;
  result = *(_DWORD *)(a1 + 80);
  *(_BYTE *)(a1 + 8 * result + 1) = 0;
  *(_DWORD *)(a1 + 8 * (*(_DWORD *)(a1 + 80))++ + 4) = a2;
  return result;
}
// 1015D238: using guessed type __int16 *off_1015D238;

//----- (10078750) --------------------------------------------------------
int (__cdecl *__cdecl sub_10078750(int a1, unsigned __int8 *a2, char a3))(int)
{
  int v3; // eax@2
  int (__cdecl *result)(int); // eax@2

  if ( a3 )
  {
    v3 = sub_10078330(a2, a1);
    sub_10078320(a1, v3);
    result = sub_10078320(a1, (int)&word_10146234);
  }
  else
  {
    sub_10078320(a1, (int)a2);
    result = sub_10078320(a1, (int)&word_10146234);
  }
  return result;
}
// 10146234: using guessed type __int16 word_10146234;

//----- (100787A0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100787A0(int a1, int a2, unsigned __int8 *a3))(int)
{
  sub_100786D0(a1, a2);
  if ( a3 && *a3 )
    sub_10078600(a1, a3);
  return sub_10078650(a1);
}

//----- (100787E0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100787E0(int a1, int a2, int a3))(int)
{
  char v4; // [sp+8h] [bp-24h]@1
  char v5; // [sp+27h] [bp-5h]@1

  _snprintf(&v4, 0x20u, "%d", a3);
  v5 = 0;
  return sub_100787A0(a1, a2, (unsigned __int8 *)&v4);
}

//----- (10078840) --------------------------------------------------------
bool __thiscall sub_10078840(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  return !sub_1007C3B0(6569, (int)&v2 + 3, 1) && (BYTE3(v2) == 4 || BYTE3(v2) == 2 || BYTE3(v2) == 5);
}

//----- (10078880) --------------------------------------------------------
char __cdecl sub_10078880(char a1, void *a2)
{
  void *v3; // ecx@3
  char v4; // al@5

  if ( sub_1007C3B0((unsigned __int8)a1 + 36000, (int)a2, 132) )
    return 0;
  v3 = a2;
  if ( !a2 || *(_BYTE *)a2 )
  {
LABEL_8:
    if ( *((_BYTE *)a2 + 21) == 4 )
    {
      if ( *((_BYTE *)a2 + 24) == 1 )
      {
        if ( !sub_10078840(v3) )
        {
          sub_10042930("..\\lib\\adl\\sys_utl_airframe_tests.c", 206, 0, 0);
          memset(a2, 0, 0x84u);
        }
      }
      else if ( *((_BYTE *)a2 + 24) == 3 && !*((_BYTE *)a2 + 58) )
      {
        *((_DWORD *)a2 + 15) |= 0x200u;
        return 1;
      }
    }
  }
  else
  {
    v4 = 0;
    while ( v4 )
    {
      v4 = *((_BYTE *)v3 + 1);
      v3 = (char *)v3 + 1;
      if ( v4 != *((_BYTE *)v3 + &byte_100930C0 - (_BYTE *)a2) )
        goto LABEL_8;
    }
  }
  return 1;
}

//----- (10078930) --------------------------------------------------------
char __cdecl sub_10078930(char a1)
{
  void *v1; // ecx@0
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      sub_1007C430(6470, (int)&a1, 1);
      result = a1 && sub_10077C70(2u);
    }
    else if ( a1 == 2 )
    {
      result = sub_100471F0(14);
    }
    else
    {
      sub_10042930("..\\lib\\adl\\iop_dl_wx_intf_a.c", 475, 1, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_10069420(v1);
  }
  return result;
}

//----- (100789B0) --------------------------------------------------------
char __cdecl sub_100789B0(int a1, float *a2)
{
  int v2; // ebx@1
  int v3; // eax@1
  void *v4; // ecx@1
  int v5; // edi@1
  char result; // al@5
  int v7; // eax@7
  int v8; // ebp@7
  int v9; // [sp+8h] [bp-10h]@1
  int v10; // [sp+Ch] [bp-Ch]@1
  float v11; // [sp+10h] [bp-8h]@1

  v11 = 9.8999998e24;
  *a2 = 9.8999998e24;
  LOBYTE(v9) = 0;
  v10 = 0;
  v2 = sub_100625C0(a1);
  v3 = sub_10079810(a1);
  v5 = v3;
  if ( !v2 )
    goto LABEL_15;
  if ( !v3 )
    return sub_10062520(a1, a2);
  if ( *(_WORD *)(v2 + 12) != 6 )
    goto LABEL_15;
  if ( sub_100460C0(v4) == 4 )
  {
    *a2 = *(float *)(v2 + 8);
    return 1;
  }
  if ( (unsigned __int8)(*(_BYTE *)(v5 + 2) - 1) <= 2u )
  {
    v7 = sub_10079760(&v9, (void *)(v5 + 4), 0xCu, 27, 100);
    *a2 = v11;
    v8 = v7;
    result = sub_1007C040() - v10 < (unsigned int)(unsigned __int16)word_10161B1C[*(_BYTE *)(v5 + 3)] ? v9 : 0;
    if ( v8 >= 0 )
    {
      if ( result )
        result = sub_10062120(v2, a2);
    }
    else
    {
      sub_10042930("..\\lib\\acl\\dat\\dat_proc_float.c", 174, 0, 0);
      result = 0;
    }
  }
  else
  {
LABEL_15:
    result = 0;
  }
  return result;
}
// 10161B1C: using guessed type __int16 word_10161B1C[];

//----- (10078B10) --------------------------------------------------------
int __cdecl sub_10078B10(char a1, float a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  unsigned int v6; // esi@7
  int result; // eax@7
  double v8; // st6@11
  unsigned int v9; // ecx@14
  unsigned int v10; // edi@14
  char *v11; // edx@14
  signed int v12; // ebx@14
  int v13; // edx@56
  int v14; // edi@56
  char *v15; // ecx@56
  signed int v16; // ebp@56
  int v17; // ebp@63
  unsigned int v18; // ecx@63
  double v19; // st7@63
  signed int v20; // edi@64
  char *v21; // edx@64
  float *v22; // edx@81
  char v23; // [sp+Fh] [bp-4D9h]@7
  int v24; // [sp+18h] [bp-4D0h]@7
  float v25; // [sp+1Ch] [bp-4CCh]@61
  float v26; // [sp+20h] [bp-4C8h]@7
  float v27; // [sp+24h] [bp-4C4h]@11
  float v28[4]; // [sp+28h] [bp-4C0h]@11
  char v29; // [sp+38h] [bp-4B0h]@64
  float v30; // [sp+278h] [bp-270h]@7
  float v31; // [sp+27Ch] [bp-26Ch]@10
  float v32; // [sp+280h] [bp-268h]@9
  char v33; // [sp+284h] [bp-264h]@14
  char v34; // [sp+4C4h] [bp-24h]@56

  v5 = 0;
  if ( a3 )
    *(float *)a3 = 0.0;
  if ( a4 )
    *(float *)a4 = 0.0;
  if ( a5 )
    *(float *)a5 = 0.0;
  *(float *)&v24 = 9.8999998e24;
  v23 = 0;
  v6 = 0;
  memset(&v26, 0, 0x258u);
  result = sub_1007C3B0(42065, (int)&v30, 624);
  if ( !a1 )
  {
    if ( v30 == 0.0 )
    {
      v8 = 9.8999998e24;
    }
    else if ( v32 == 9.8999998e24 || v31 == 9.8999998e24 )
    {
      v8 = 9.8999998e24;
    }
    else
    {
      v6 = 1;
      v26 = v30;
      v28[0] = v32;
      v8 = 9.8999998e24;
      v27 = v31;
    }
    v9 = 12 * v6;
    v10 = 0;
    v11 = &v33;
    v12 = 6;
    do
    {
      if ( 0.0 != *(float *)v11
        && *(float *)((char *)&v26 + v10) < (double)*(float *)v11
        && v8 != *((float *)v11 + 2)
        && v8 != *((float *)v11 + 1) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *(float *)v11;
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 2);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 1);
      }
      if ( 0.0 != *((float *)v11 + 3)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 3)
        && v8 != *((float *)v11 + 5)
        && v8 != *((float *)v11 + 4) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 3);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 5);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 4);
      }
      if ( 0.0 != *((float *)v11 + 6)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 6)
        && v8 != *((float *)v11 + 8)
        && v8 != *((float *)v11 + 7) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 6);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 8);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 7);
      }
      if ( 0.0 != *((float *)v11 + 9)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 9)
        && v8 != *((float *)v11 + 11)
        && v8 != *((float *)v11 + 10) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 9);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 11);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 10);
      }
      if ( 0.0 != *((float *)v11 + 12)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 12)
        && v8 != *((float *)v11 + 14)
        && v8 != *((float *)v11 + 13) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 12);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 14);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 13);
      }
      if ( 0.0 != *((float *)v11 + 15)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 15)
        && v8 != *((float *)v11 + 17)
        && v8 != *((float *)v11 + 16) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 15);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 17);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 16);
      }
      if ( 0.0 != *((float *)v11 + 18)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 18)
        && v8 != *((float *)v11 + 20)
        && v8 != *((float *)v11 + 19) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 18);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 20);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 19);
      }
      if ( 0.0 != *((float *)v11 + 21)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 21)
        && v8 != *((float *)v11 + 23)
        && v8 != *((float *)v11 + 22) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 21);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 23);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 22);
      }
      v11 += 96;
      --v12;
    }
    while ( v12 );
    v13 = 12 * v6;
    v14 = 12 * v5;
    v15 = &v34;
    v16 = 1;
    do
    {
      if ( 0.0 != *(float *)v15
        && *(float *)((char *)&v26 + v14) < (double)*(float *)v15
        && v8 != *((float *)v15 + 2)
        && v8 != *((float *)v15 + 1) )
      {
        v14 = v13;
        *(float *)((char *)&v26 + v13) = *(float *)v15;
        ++v6;
        v13 += 12;
        *(float *)((char *)&v25 + v13) = *((float *)v15 + 2);
        *(int *)((char *)&v24 + v13) = *((int *)v15 + 1);
      }
      v15 += 12;
      --v16;
    }
    while ( v16 );
    v17 = 0;
    v18 = 0;
    v19 = a2;
    if ( (signed int)v6 < 4 )
    {
LABEL_80:
      if ( v18 < v6 )
      {
        v22 = &v26 + 3 * v18;
        do
        {
          if ( v23 )
            break;
          if ( v19 == *v22 )
          {
            v23 = 1;
            v17 = v18;
          }
          else
          {
            v25 = *v22 - v19;
            if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
            {
              v17 = v18;
              v24 = LODWORD(v25) & 0x7FFFFFFF;
            }
          }
          ++v18;
          v22 += 3;
        }
        while ( v18 < v6 );
      }
    }
    else
    {
      v20 = 3;
      v21 = &v29;
      while ( !v23 )
      {
        if ( v19 == *((float *)v21 - 6) )
        {
          v17 = v18;
          break;
        }
        v25 = *((float *)v21 - 6) - v19;
        if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
        {
          v17 = v18;
          v24 = LODWORD(v25) & 0x7FFFFFFF;
        }
        if ( v19 == *((float *)v21 - 3) )
        {
          v17 = v18 + 1;
          break;
        }
        v25 = *((float *)v21 - 3) - v19;
        if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
        {
          v17 = v20 - 2;
          v24 = LODWORD(v25) & 0x7FFFFFFF;
        }
        if ( v19 == *(float *)v21 )
        {
          v17 = v18 + 2;
          break;
        }
        v25 = *(float *)v21 - v19;
        if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
        {
          v17 = v20 - 1;
          v24 = LODWORD(v25) & 0x7FFFFFFF;
        }
        if ( v19 == *((float *)v21 + 3) )
        {
          v23 = 1;
          v17 = v20;
        }
        else
        {
          v25 = *((float *)v21 + 3) - v19;
          if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
          {
            v17 = v20;
            v24 = LODWORD(v25) & 0x7FFFFFFF;
          }
        }
        v18 += 4;
        v21 += 48;
        v20 += 4;
        if ( v18 >= v6 - 3 )
          goto LABEL_80;
      }
    }
    if ( a3 )
      *(float *)a3 = sub_10079850(*(&v26 + 3 * v17));
    if ( a4 )
      *(float *)a4 = v28[3 * v17] * 0.02539999969303608;
    result = a5;
    if ( a5 )
      *(float *)a5 = 0.02539999969303608 * *(&v27 + 3 * v17);
  }
  return result;
}
// 10078B10: using guessed type float var_4C0[4];

//----- (10079160) --------------------------------------------------------
double sub_10079160()
{
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v1 = 0.0;
  v2 = 0.0;
  sub_1007C650(3875, &v1, 4, &v2);
  return v1;
}

//----- (10079190) --------------------------------------------------------
double __cdecl sub_10079190(int a1, float a2, float a3)
{
  int v3; // ecx@0
  double result; // st7@2

  if ( sub_10045F20(v3) == 24 )
  {
    *(float *)a1 = a2 * 453.5924;
    result = a2;
  }
  else
  {
    *(float *)a1 = a3 * 1000.0;
    result = a3;
  }
  return result;
}

//----- (100791D0) --------------------------------------------------------
char __cdecl sub_100791D0(float *a1, float *a2, float *a3, char a4)
{
  float *v4; // ecx@10
  signed int v5; // edx@10
  double v6; // st7@29
  double v7; // st7@34
  double v8; // st7@37
  double v9; // st6@37
  double v10; // st5@43
  double v11; // rtt@48
  double v12; // st5@48
  double v13; // st7@48
  char result; // al@48
  char v15; // [sp+22h] [bp-3EEh]@1
  char v16; // [sp+23h] [bp-3EDh]@1
  float v17; // [sp+24h] [bp-3ECh]@1
  float v18; // [sp+28h] [bp-3E8h]@1
  float v19; // [sp+2Ch] [bp-3E4h]@1
  float v20; // [sp+30h] [bp-3E0h]@1
  float v21; // [sp+34h] [bp-3DCh]@1
  float v22; // [sp+38h] [bp-3D8h]@1
  int v23; // [sp+3Ch] [bp-3D4h]@1
  int v24; // [sp+40h] [bp-3D0h]@1
  float v25; // [sp+44h] [bp-3CCh]@29
  int v26; // [sp+48h] [bp-3C8h]@10
  char v27; // [sp+4Ch] [bp-3C4h]@10
  char v28; // [sp+68h] [bp-3A8h]@10
  char v29; // [sp+6Ch] [bp-3A4h]@10
  char v30; // [sp+8Ch] [bp-384h]@10
  char v31; // [sp+ACh] [bp-364h]@10
  char v32; // [sp+CCh] [bp-344h]@10
  char v33; // [sp+ECh] [bp-324h]@10
  char v34; // [sp+10Ch] [bp-304h]@10
  char v35; // [sp+12Ch] [bp-2E4h]@10
  char v36; // [sp+14Ch] [bp-2C4h]@10
  char v37; // [sp+16Ch] [bp-2A4h]@10
  char v38; // [sp+18Ch] [bp-284h]@10
  char v39; // [sp+1ACh] [bp-264h]@10
  char v40; // [sp+1CCh] [bp-244h]@10
  char v41; // [sp+1ECh] [bp-224h]@10
  char v42; // [sp+20Ch] [bp-204h]@10
  char v43; // [sp+22Ch] [bp-1E4h]@10
  char v44; // [sp+24Ch] [bp-1C4h]@10
  char v45; // [sp+26Ch] [bp-1A4h]@10
  char v46; // [sp+28Ch] [bp-184h]@10
  char v47; // [sp+2ACh] [bp-164h]@10
  char v48; // [sp+2CCh] [bp-144h]@10
  char v49; // [sp+2ECh] [bp-124h]@10
  char v50; // [sp+30Ch] [bp-104h]@10
  char v51; // [sp+32Ch] [bp-E4h]@10
  char v52; // [sp+34Ch] [bp-C4h]@10
  char v53; // [sp+36Ch] [bp-A4h]@10
  char v54; // [sp+38Ch] [bp-84h]@10
  char v55; // [sp+3ACh] [bp-64h]@10
  char v56; // [sp+3CCh] [bp-44h]@10
  char v57; // [sp+3ECh] [bp-24h]@10

  v20 = 0.0;
  *(float *)&v24 = 0.0;
  *(float *)&v23 = 0.0;
  v21 = 0.0;
  v18 = 0.0;
  v19 = 0.0;
  v22 = 0.0;
  v16 = 0;
  v17 = 0.0;
  v15 = 0;
  if ( a1 && 9.8999998e24 != *a1 )
    *a1 = 0.0;
  if ( a3 && 9.8999998e24 != *a3 )
    *a3 = 0.0;
  if ( a2 && 9.8999998e24 != *a2 )
    *a2 = 0.0;
  sub_10079190((int)&v26, 5.0, 2.0);
  sub_1007C3B0(41113, (int)&v15, 1);
  sub_1007C3B0(9149, (int)&v16, 1);
  sub_1007C3B0(42004, (int)&v27, 32);
  sub_1007C3B0(42006, (int)&v29, 32);
  sub_1007C3B0(42008, (int)&v30, 32);
  sub_1007C3B0(42010, (int)&v31, 32);
  sub_1007C3B0(42012, (int)&v32, 32);
  sub_1007C3B0(42014, (int)&v33, 32);
  sub_1007C3B0(42016, (int)&v34, 32);
  sub_1007C3B0(42018, (int)&v35, 32);
  sub_1007C3B0(42020, (int)&v36, 32);
  sub_1007C3B0(42022, (int)&v37, 32);
  sub_1007C3B0(42024, (int)&v38, 32);
  sub_1007C3B0(42026, (int)&v39, 32);
  sub_1007C3B0(42028, (int)&v40, 32);
  sub_1007C3B0(42030, (int)&v41, 32);
  sub_1007C3B0(42032, (int)&v42, 32);
  sub_1007C3B0(42034, (int)&v43, 32);
  sub_1007C3B0(42036, (int)&v44, 32);
  sub_1007C3B0(42038, (int)&v45, 32);
  sub_1007C3B0(42040, (int)&v46, 32);
  sub_1007C3B0(42042, (int)&v47, 32);
  sub_1007C3B0(42044, (int)&v48, 32);
  sub_1007C3B0(42046, (int)&v49, 32);
  sub_1007C3B0(42048, (int)&v50, 32);
  sub_1007C3B0(42050, (int)&v51, 32);
  sub_1007C3B0(42052, (int)&v52, 32);
  sub_1007C3B0(42054, (int)&v53, 32);
  sub_1007C3B0(42056, (int)&v54, 32);
  sub_1007C3B0(42058, (int)&v55, 32);
  sub_1007C3B0(42060, (int)&v56, 32);
  sub_1007C3B0(42062, (int)&v57, 32);
  v4 = (float *)&v28;
  v5 = 30;
  do
  {
    if ( *((_BYTE *)v4 - 28) == 1 )
    {
      if ( 9.8999998e24 != *(v4 - 1) )
        v20 = *(v4 - 1) + v20;
      if ( a4 )
      {
        if ( 9.8999998e24 != *v4 )
        {
          v22 = *v4 + v22;
          if ( 9.8999998e24 != *v4 )
          {
            if ( 9.8999998e24 != *(v4 - 3) )
              v19 = *v4 * *(v4 - 3) + v19;
            if ( 9.8999998e24 != *(v4 - 2) )
              v18 = *v4 * *(v4 - 2) + v18;
          }
        }
      }
      if ( 9.8999998e24 != *(v4 - 1) )
      {
        if ( 9.8999998e24 != *(v4 - 3) )
          v19 = *(v4 - 3) * *(v4 - 1) + v19;
        if ( 9.8999998e24 != *(v4 - 2) )
          v18 = *(v4 - 2) * *(v4 - 1) + v18;
      }
    }
    v4 += 8;
    --v5;
  }
  while ( v5 );
  if ( v16 && a4 == 2 )
  {
    v25 = sub_10044FD0();
    v21 = sub_10079850(v25);
    v21 = sub_1007BD40(v21, *(float *)&v26);
    sub_10078B10(0, v25, 0, (int)&v24, (int)&v23);
    *(float *)&v24 = *(float *)&v24 * 39.37007904052734;
    *(float *)&v23 = 39.37007904052734 * *(float *)&v23;
    v6 = v21;
    v18 = v21 * *(float *)&v24 + v18;
    v19 = v21 * *(float *)&v23 + v19;
  }
  else
  {
    v6 = v21;
  }
  if ( a4 )
  {
    if ( a4 == 1 )
    {
      v7 = v22 + v20;
    }
    else
    {
      if ( a4 != 2 )
      {
        v8 = 0.0;
        goto LABEL_40;
      }
      v7 = v6 + v20 + v22;
    }
  }
  else
  {
    v7 = v20;
  }
  v17 = v7;
  v8 = 0.0;
  v9 = v17;
  if ( v17 >= 0.0 )
    goto LABEL_41;
  v17 = 0.0;
LABEL_40:
  v9 = v17;
LABEL_41:
  if ( a1 )
    *a1 = v9;
  v10 = 0.02539999969303608;
  if ( a3 )
  {
    if ( v9 > v8 )
      *a3 = v18 / v9 * 0.02539999969303608;
    v10 = 0.02539999969303608;
  }
  if ( a2 )
  {
    v11 = v10;
    v12 = v8;
    v13 = v11;
    result = v15;
    if ( v12 < v9 )
      *a2 = v13 * (v19 / v9);
  }
  else
  {
    result = v15;
  }
  return result;
}

//----- (10079760) --------------------------------------------------------
int __cdecl sub_10079760(void *a1, void *a2, size_t a3, int a4, int a5)
{
  int result; // eax@8

  if ( a3 > 4 || a3 == 3 || a3 - 1 > 3 || ((unsigned int)a2 | (unsigned int)a1) & (a3 - 1) )
  {
    if ( sub_1007C110(a4, a5) )
    {
      result = -1;
    }
    else
    {
      memcpy(a1, a2, a3);
      sub_1007C0F0(a4);
      result = 1;
    }
  }
  else
  {
    switch ( a3 )
    {
      case 1u:
        result = 0;
        *(_BYTE *)a1 = *(_BYTE *)a2;
        break;
      case 2u:
        *(_WORD *)a1 = *(_WORD *)a2;
        result = 0;
        break;
      case 4u:
        result = 0;
        *(_DWORD *)a1 = *(_DWORD *)a2;
        break;
      default:
        memcpy(a1, a2, a3);
        result = 0;
        break;
    }
  }
  return result;
}

//----- (10079810) --------------------------------------------------------
int __cdecl sub_10079810(unsigned __int16 a1)
{
  int v1; // ecx@1
  unsigned __int16 v2; // ax@3
  int result; // eax@4

  v1 = sub_1003C0F0();
  if ( v1 && a1 < 0xFE3u && (v2 = *(_WORD *)(v1 + 2 * a1 + 0x2000), v2 < 0x2000u) )
    result = v1 + v2;
  else
    result = 0;
  return result;
}

//----- (10079850) --------------------------------------------------------
double __cdecl sub_10079850(float a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@2
  double result; // st7@4
  float v5; // [sp+8h] [bp+4h]@4
  float v6; // [sp+8h] [bp+4h]@5
  float v7; // [sp+8h] [bp+4h]@6
  float v8; // [sp+8h] [bp+4h]@7

  v2 = (unsigned __int8)sub_10045E70(v1);
  if ( (_BYTE)v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        v6 = (float)778.90802 * a1;
        result = v6;
      }
      else
      {
        v5 = (float)850.76703 * a1;
        result = v5;
      }
    }
    else
    {
      v7 = (float)804.0722 * a1;
      result = v7;
    }
  }
  else
  {
    v8 = (float)718.95856 * a1;
    result = v8;
  }
  return result;
}

//----- (100798D0) --------------------------------------------------------
int __cdecl sub_100798D0(int a1, int a2)
{
  int result; // eax@1

  result = a1 + a2;
  if ( a1 + a2 >= -1073736000 )
  {
    if ( result >= 1073736000 )
      result -= 2147472000;
  }
  else
  {
    result += 2147472000;
  }
  return result;
}

//----- (10079900) --------------------------------------------------------
signed int __cdecl sub_10079900(signed int *a1, signed int a2)
{
  signed int result; // eax@1

  result = a2 >> 1;
  *a1 = a2 >> 1;
  if ( a2 >> 1 >= 1073736000 )
    result = 1073736000;
  *a1 = result;
  if ( result <= -1073736000 )
    result = -1073736000;
  *a1 = result;
  return result;
}

//----- (10079930) --------------------------------------------------------
int __cdecl sub_10079930(int a1, int a2)
{
  int result; // eax@1

  result = a1 - a2;
  if ( a1 - a2 >= -1073736000 )
  {
    if ( result >= 1073736000 )
      result -= 2147472000;
  }
  else
  {
    result += 2147472000;
  }
  return result;
}

//----- (10079960) --------------------------------------------------------
void __cdecl sub_10079960(int a1, signed int a2, signed int a3)
{
  int v3; // ebx@1
  int v4; // ecx@2
  int v5; // edx@3
  int v6; // ecx@4
  int v7; // eax@4

  v3 = 0;
  if ( a2 > 0 )
  {
    v4 = 0;
    do
    {
      v5 = 0;
      if ( a3 > 0 )
      {
        v6 = a3 * v4;
        v7 = 0;
        do
        {
          ++v5;
          *(_WORD *)(a1 + 2 * (v6 + v7)) = -32767;
          v7 = (unsigned __int16)v5;
        }
        while ( (unsigned __int16)v5 < a3 );
      }
      v4 = (unsigned __int16)++v3;
    }
    while ( (unsigned __int16)v3 < a2 );
  }
}

//----- (100799C0) --------------------------------------------------------
signed int sub_100799C0()
{
  signed int result; // eax@1

  memset(&unk_10300FE0, 0, 0x30u);
  dword_10300FE8 = 1073736000;
  dword_10300FEC = 1073736000;
  result = -1073736000;
  byte_10304210 = 0;
  dword_10301000 = -1;
  dword_10300FF0 = -1073736000;
  dword_10300FF4 = -1073736000;
  return result;
}
// 10300FE8: using guessed type int dword_10300FE8;
// 10300FEC: using guessed type int dword_10300FEC;
// 10300FF0: using guessed type int dword_10300FF0;
// 10300FF4: using guessed type int dword_10300FF4;
// 10301000: using guessed type int dword_10301000;
// 10304210: using guessed type char byte_10304210;

//----- (10079A10) --------------------------------------------------------
__int16 __cdecl sub_10079A10(signed int a1, signed int a2, int a3)
{
  int v3; // edi@1
  int v4; // ebp@1
  int v5; // eax@7
  __int16 v6; // ax@9
  unsigned int v7; // eax@10
  char *v8; // ecx@10
  int *v9; // edx@10
  int v10; // esi@14
  int v11; // eax@15
  _BYTE *v12; // ecx@15
  _BYTE *v13; // edx@15
  int v14; // eax@17
  _BYTE *v15; // ecx@17
  _BYTE *v16; // edx@17
  _BYTE *v17; // ecx@19
  _BYTE *v18; // edx@19
  signed int v19; // eax@21
  unsigned int v20; // esi@34
  int v21; // ST28_4@36
  unsigned int v22; // ecx@36
  __int16 v23; // dx@38
  int v25; // [sp+Ch] [bp-34h]@1
  int v26; // [sp+10h] [bp-30h]@1
  int v27; // [sp+14h] [bp-2Ch]@1
  int v28; // [sp+18h] [bp-28h]@9
  int v29; // [sp+1Ch] [bp-24h]@7
  char v30; // [sp+20h] [bp-20h]@6
  __int16 v31[4]; // [sp+28h] [bp-18h]@29
  int v32; // [sp+30h] [bp-10h]@28

  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  *(_DWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 12) = 0;
  *(_DWORD *)(a3 + 16) = 0;
  *(_WORD *)a3 = -32767;
  sub_10079900(&v25, a1);
  sub_10079900(&v26, a2);
  v3 = v26;
  v4 = v25;
  v27 = sub_1007A500(1, v25, v26, &unk_1030B320);
  if ( v27 )
    return *(_WORD *)a3;
  if ( v4 < dword_1030CF9C || v4 >= dword_1030CFA4 || v3 < dword_1030CFA0 || v3 >= dword_1030CFA8 )
  {
    sub_10079E90(v4, v3, dword_1030B330, dword_1030B334, &dword_1030CF9C, &dword_1030CFA0);
    dword_1030CFA4 = dword_1030CF9C + dword_1030B330;
    dword_1030CFA8 = sub_100798D0(dword_1030CFA0, dword_1030B334);
    v5 = sub_10079FC0(v4, v3, (signed int)&unk_1030B320);
    *(_DWORD *)(a3 + 16) = v5;
    v29 = v5;
    if ( v5 == -1 )
      return *(_WORD *)a3;
    v27 = sub_1007A0E0(0, &v30, 0x1Cu, (int)&v29);
    if ( v27 )
      return *(_WORD *)a3;
  }
  else
  {
    qmemcpy(&v30, &dword_1030CF80, 0x1Cu);
    v3 = v26;
    *(_DWORD *)(a3 + 16) = dword_1030CF7C;
  }
  v6 = (unsigned __int8)sub_10079F50(v4, v3, (int)&unk_1030B320);
  *(_WORD *)(a3 + 12) = (unsigned __int8)v6;
  LOWORD(v28) = (unsigned __int8)v6;
  if ( (unsigned __int8)v6 != (_WORD)dword_1030CF78 )
  {
LABEL_28:
    if ( v32 == -1 || v31[(unsigned __int16)v6] == -32767 )
      sub_1007A070(
        (int)word_1030B34C,
        0xE10u,
        (void (__cdecl *)(int, signed int, int, int))nullsub_1,
        0,
        (int)&unk_1030B320,
        a3);
    else
      v27 = sub_1007AA80(
              v6,
              (int)word_1030B34C,
              0xE10u,
              (void (__cdecl *)(int, int, int, int))nullsub_1,
              0,
              (int)&unk_1030B320,
              (int)&v30,
              0,
              a3);
    sub_10079E90(v4, v3, dword_1030B330, dword_1030B334, (int *)(a3 + 4), (int *)(a3 + 8));
    dword_1030CF6C = *(_DWORD *)a3;
    dword_1030CF70 = *(_DWORD *)(a3 + 4);
    dword_1030CF74 = *(_DWORD *)(a3 + 8);
    dword_1030CF78 = *(_DWORD *)(a3 + 12);
    dword_1030CF7C = *(_DWORD *)(a3 + 16);
    qmemcpy(&dword_1030CF80, &v30, 0x1Cu);
    if ( !v27 )
    {
      v3 = v26;
      goto LABEL_34;
    }
    return *(_WORD *)a3;
  }
  v7 = 28;
  v8 = &v30;
  v9 = &dword_1030CF80;
  do
  {
    if ( *v9 != *(_DWORD *)v8 )
      goto LABEL_14;
    v7 -= 4;
    v8 += 4;
    ++v9;
  }
  while ( v7 >= 4 );
  if ( !v7 )
  {
LABEL_24:
    v19 = 0;
    goto LABEL_25;
  }
LABEL_14:
  v10 = *(_BYTE *)v9 - (unsigned __int8)*v8;
  if ( *(_BYTE *)v9 == (unsigned __int8)*v8 )
  {
    v11 = v7 - 1;
    v12 = v8 + 1;
    v13 = (char *)v9 + 1;
    if ( !v11
      || (v10 = *v13 - *v12, *v13 == *v12)
      && ((v14 = v11 - 1, v15 = v12 + 1, v16 = v13 + 1, !v14)
       || (v10 = *v16 - *v15, *v16 == *v15)
       && ((v17 = v15 + 1, v18 = v16 + 1, v14 == 1) || (v10 = *v18 - *v17, *v18 == *v17))) )
    {
      v3 = v26;
      goto LABEL_24;
    }
  }
  v3 = v26;
  v19 = 1;
  if ( v10 <= 0 )
    v19 = -1;
LABEL_25:
  if ( v19 )
  {
    v6 = v28;
    goto LABEL_28;
  }
  *(_DWORD *)a3 = dword_1030CF6C;
  *(_DWORD *)(a3 + 4) = dword_1030CF70;
  *(_DWORD *)(a3 + 8) = dword_1030CF74;
  *(_DWORD *)(a3 + 12) = dword_1030CF78;
  *(_DWORD *)(a3 + 16) = dword_1030CF7C;
LABEL_34:
  v20 = (signed __int16)((v4 - *(_DWORD *)(a3 + 4)) / dword_1030B338);
  if ( v20 >= 0x3B )
    LOWORD(v20) = 59;
  v21 = *(_DWORD *)(a3 + 8);
  *(_WORD *)(a3 + 14) = v20;
  v22 = (signed __int16)(sub_10079930(v3, v21) / dword_1030B33C);
  if ( v22 >= 0x3B )
    LOWORD(v22) = 59;
  *(_WORD *)(a3 + 2) = v22;
  v23 = word_1030B34C[(unsigned __int16)v22 + 60 * (unsigned __int16)v20];
  *(_WORD *)a3 = v23;
  return v23;
}
// 1030B330: using guessed type int dword_1030B330;
// 1030B334: using guessed type int dword_1030B334;
// 1030B338: using guessed type int dword_1030B338;
// 1030B33C: using guessed type int dword_1030B33C;
// 1030B34C: using guessed type __int16 word_1030B34C[];
// 1030CF6C: using guessed type int dword_1030CF6C;
// 1030CF70: using guessed type int dword_1030CF70;
// 1030CF74: using guessed type int dword_1030CF74;
// 1030CF78: using guessed type int dword_1030CF78;
// 1030CF7C: using guessed type int dword_1030CF7C;
// 1030CF80: using guessed type int dword_1030CF80;
// 1030CF9C: using guessed type int dword_1030CF9C;
// 1030CFA0: using guessed type int dword_1030CFA0;
// 1030CFA4: using guessed type int dword_1030CFA4;
// 1030CFA8: using guessed type int dword_1030CFA8;
// 10079A10: using guessed type __int16 var_18[4];

//----- (10079E90) --------------------------------------------------------
signed int __cdecl sub_10079E90(signed int a1, signed int a2, signed int a3, signed int a4, int *a5, int *a6)
{
  int v6; // eax@3
  int v7; // ecx@3
  signed int *v8; // esi@6
  int v9; // eax@8
  signed int *v10; // edx@8
  int v11; // ecx@8
  signed int v12; // eax@14
  signed int result; // eax@18

  if ( a3 && a4 )
  {
    v6 = a1 / a3;
    v7 = a3 * (a1 / a3);
    if ( a1 == v7 )
    {
      v8 = a5;
      *a5 = v7;
    }
    else
    {
      if ( a1 < 0 )
        --v6;
      v8 = a5;
      *a5 = a3 * v6;
    }
    v9 = a2 / a4;
    v10 = a6;
    v11 = a4 * (a2 / a4);
    if ( a2 == v11 )
    {
      *a6 = v11;
    }
    else
    {
      if ( a2 < 0 )
        --v9;
      *a6 = a4 * v9;
    }
  }
  else
  {
    v8 = a5;
    v10 = a6;
    *a5 = 0;
    *a6 = 0;
  }
  v12 = *v8;
  if ( *v8 <= -536868000 )
    v12 = -536868000;
  *v8 = v12;
  if ( v12 >= 536868000 )
    v12 = 536868000;
  *v8 = v12;
  result = *v10;
  if ( *v10 <= -1073736000 )
    result = -1073736000;
  *v10 = result;
  if ( result >= 1073736000 )
    result = 1073736000;
  *v10 = result;
  return result;
}

//----- (10079F50) --------------------------------------------------------
char __cdecl sub_10079F50(signed int a1, signed int a2, int a3)
{
  signed int v3; // ebx@1
  signed int v4; // ebp@1
  int v5; // esi@1
  int v6; // edi@1
  char result; // al@2

  v3 = a2;
  v4 = a1;
  v5 = *(_DWORD *)(a3 + 20);
  v6 = *(_DWORD *)(a3 + 16);
  sub_10079E90(a1, a2, 2 * v6, 2 * v5, &a1, &a3);
  if ( abs(v4 - a1) < v6 )
    result = abs(v3 - a3) >= v5;
  else
    result = (abs(v3 - a3) >= v5) + 2;
  return result;
}

//----- (10079FC0) --------------------------------------------------------
int __cdecl sub_10079FC0(signed int a1, signed int a2, signed int a3)
{
  signed int v3; // ebp@1
  int v4; // edi@1
  int v5; // esi@1
  signed int v6; // ebx@5
  int result; // eax@7
  int v8; // [sp+10h] [bp-4h]@7

  v3 = a3;
  v4 = 2 * *(_DWORD *)(a3 + 16);
  v5 = 2 * *(_DWORD *)(a3 + 20);
  if ( v4
    && v5
    && a1 >= *(_DWORD *)a3
    && a1 < *(_DWORD *)(a3 + 8)
    && (v6 = *(_DWORD *)(a3 + 4), a2 >= v6)
    && a2 < *(_DWORD *)(a3 + 12) )
  {
    sub_10079E90(a1, a2, v4, v5, &a3, &v8);
    result = *(_DWORD *)(v3 + 32)
           + 28
           * ((unsigned __int16)(v8 / v5 - v6 / v5)
            + (unsigned __int16)(*(_DWORD *)(v3 + 12) / v5 - v6 / v5) * (unsigned __int16)(a3 / v4 - *(_DWORD *)v3 / v4));
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1007A070) --------------------------------------------------------
void __cdecl sub_1007A070(int a1, unsigned __int16 a2, void (__cdecl *a3)(int, signed int, int, int), int a4, int a5, int a6)
{
  signed int v6; // ebx@1
  unsigned __int16 v7; // bp@1
  signed int v8; // edi@1
  int v9; // esi@1

  v6 = (unsigned __int16)(*(_WORD *)(a5 + 38) >> 1);
  v7 = *(_WORD *)(a5 + 36) >> 1;
  v8 = 1;
  v9 = (unsigned __int16)(a2 / v6);
  sub_10079960(a1, a2, 1);
  if ( v7 >= 1u )
  {
    do
    {
      if ( !(_WORD)v9 )
        break;
      a3(v9, v6, a6, a4);
      v8 += v9;
    }
    while ( (unsigned __int16)v8 <= v7 );
  }
}

//----- (1007A0E0) --------------------------------------------------------
int __cdecl sub_1007A0E0(char a1, void *a2, size_t a3, int a4)
{
  int result; // eax@1

  result = sub_10029FB0(a1, a2, a3, *(_DWORD *)a4);
  if ( !result )
    *(_DWORD *)a4 += a3;
  return result;
}

//----- (1007A110) --------------------------------------------------------
int __usercall sub_1007A110@<eax>(int a1@<esi>)
{
  int result; // eax@1
  int v2; // [sp+0h] [bp-4h]@1

  v2 = 152;
  result = sub_1007A0E0(1, (void *)a1, 0x14u, (int)&v2);
  if ( !result )
  {
    result = 4;
    if ( *(_DWORD *)(a1 + 8) )
    {
      if ( *(_DWORD *)(a1 + 12) )
        result = 0;
    }
  }
  return result;
}

//----- (1007A150) --------------------------------------------------------
int __cdecl sub_1007A150(char a1, void *a2, char a3)
{
  int result; // eax@1
  int v4; // ebx@4
  int v5; // [sp+8h] [bp-90h]@4
  char v6; // [sp+Ch] [bp-8Ch]@4
  char v7; // [sp+74h] [bp-24h]@5

  memset(a2, 0, (unsigned __int8)a3);
  result = 4;
  if ( !a1 || a1 == 1 || a1 == 2 )
  {
    v5 = 16;
    result = sub_1007A0E0(a1, &v6, 0x88u, (int)&v5);
    v4 = result;
    if ( !result )
    {
      sub_100421E0((int)a2, &v7, (unsigned __int8)a3);
      result = v4;
    }
  }
  return result;
}

//----- (1007A1F0) --------------------------------------------------------
int __cdecl sub_1007A1F0(char a1, void *a2, size_t a3, int a4, size_t a5, int a6, size_t a7, int a8, size_t a9, int a10, int a11, int a12, size_t a13)
{
  int result; // eax@4
  const char *v14; // ebp@6
  char v15; // dl@9
  __int16 v16; // ax@9
  char v17; // dl@14
  __int16 v18; // ax@14
  int v19; // [sp+10h] [bp-298h]@5
  void *v20; // [sp+14h] [bp-294h]@1
  void *v21; // [sp+18h] [bp-290h]@1
  void *v22; // [sp+1Ch] [bp-28Ch]@1
  void *v23; // [sp+20h] [bp-288h]@1
  int v24; // [sp+24h] [bp-284h]@5
  int v25; // [sp+28h] [bp-280h]@8
  int v26; // [sp+2Ch] [bp-27Ch]@19
  char v27; // [sp+30h] [bp-278h]@6
  char v28; // [sp+43h] [bp-265h]@6
  char v29; // [sp+44h] [bp-264h]@6
  char v30; // [sp+6Bh] [bp-23Dh]@6
  char v31; // [sp+6Ch] [bp-23Ch]@6
  char v32; // [sp+8Bh] [bp-21Dh]@6
  char v33; // [sp+9Ah] [bp-20Eh]@6
  char v34; // [sp+9Fh] [bp-209h]@6
  int v35; // [sp+A6h] [bp-202h]@11
  int v36; // [sp+AAh] [bp-1FEh]@13
  char v37; // [sp+B0h] [bp-1F8h]@19
  char v38; // [sp+B8h] [bp-1F0h]@20

  v21 = (void *)a6;
  v23 = (void *)a4;
  v22 = (void *)a8;
  v20 = (void *)a12;
  memset(a2, 0, a3);
  memset((void *)a4, 0, a5);
  memset((void *)a6, 0, a7);
  memset((void *)a8, 0, a9);
  memset((void *)a12, 0, a13);
  *(_BYTE *)(a10 + 1) = 0;
  *(_BYTE *)a10 = 0;
  *(_WORD *)(a10 + 2) = 0;
  *(_BYTE *)(a11 + 1) = 0;
  *(_BYTE *)a11 = 0;
  *(_WORD *)(a11 + 2) = 0;
  if ( a1 && a1 != 1 && a1 != 2 )
  {
    result = 4;
  }
  else
  {
    v19 = 16;
    v19 = sub_1007A0E0(a1, &v24, 0x88u, (int)&v19);
    if ( !v19 )
    {
      v32 = 0;
      v34 = 0;
      v28 = 0;
      v30 = 0;
      sub_100421E0((int)a2, &v31, a3);
      v14 = (const char *)v23;
      sub_100421E0((int)v23, &v33, a5);
      sub_100421E0((int)v21, &v27, a7);
      sub_100421E0((int)v22, &v29, a9);
      if ( (unsigned __int16)(v24 - 1) <= 0x1Eu
        && (unsigned __int16)(HIWORD(v24) - 1) <= 0xBu
        && (unsigned __int16)(v25 - 1990) <= 0x6Eu )
      {
        v15 = BYTE2(v24);
        v16 = v25;
        *(_BYTE *)(a10 + 1) = v24;
        *(_BYTE *)a10 = v15;
        *(_WORD *)(a10 + 2) = v16;
      }
      if ( a1 == 1
        && (unsigned __int16)(v35 - 1) <= 0x1Eu
        && (unsigned __int16)(HIWORD(v35) - 1) <= 0xBu
        && (unsigned __int16)(v36 - 1990) <= 0x6Eu )
      {
        v17 = BYTE2(v35);
        v18 = v36;
        *(_BYTE *)(a11 + 1) = v35;
        *(_BYTE *)a11 = v17;
        *(_WORD *)(a11 + 2) = v18;
      }
      sub_100421E0((int)v20, "____", a13);
      if ( !memcmp(v14, "2.00", 5u) )
      {
        if ( (unsigned __int8)a1 < 3u )
          sub_100421E0((int)v20, off_10167860[(unsigned __int8)a1], a13);
      }
      else if ( memcmp(v14, "2.01", 5) >= 0 )
      {
        v19 = v26 - 501;
        v19 = sub_1007A0E0(a1, &v37, 0x1F4u, (int)&v19);
        if ( !v19 )
          sub_100421E0((int)v20, &v38, a13);
      }
    }
    result = v19;
  }
  return result;
}
// 10167860: using guessed type char *off_10167860[3];

//----- (1007A500) --------------------------------------------------------
int __cdecl sub_1007A500(char a1, int a2, int a3, void *a4)
{
  int result; // eax@7
  char v5; // bl@8
  unsigned __int16 v6; // bp@11
  int v7; // [sp+8h] [bp-20h]@10
  char v8; // [sp+Ch] [bp-1Ch]@10
  int v9; // [sp+20h] [bp-8h]@11
  unsigned __int16 v10; // [sp+24h] [bp-4h]@12

  if ( byte_1030CFD8 == a1
    && (unsigned __int8)a1 >= 1u
    && a2 >= dword_1030CFAC
    && a2 < dword_1030CFB4
    && a3 >= dword_1030CFB0
    && a3 < dword_1030CFB8 )
  {
    qmemcpy(a4, &dword_1030CFAC, 0x2Cu);
    return 0;
  }
  v5 = 0;
  if ( (unsigned __int8)a1 < 1u )
  {
    byte_1030CFD8 = 0;
    return 9;
  }
  v7 = 28 * ((unsigned __int8)a1 - 1) + 156;
  result = sub_1007A0E0(0, &v8, 0x1Cu, (int)&v7);
  if ( result )
    goto LABEL_23;
  v6 = 0;
  v7 = v9;
  do
  {
    if ( v6 >= v10 )
      break;
    if ( result )
      goto LABEL_23;
    result = sub_1007A0E0(0, a4, 0x2Cu, (int)&v7);
    if ( !result )
    {
      if ( a2 >= *(_DWORD *)a4 && a2 < *((_DWORD *)a4 + 2) )
      {
        *((_DWORD *)a4 + 4) >>= 1;
        *((_DWORD *)a4 + 5) >>= 1;
        v5 = 1;
        result = 13;
        if ( a3 >= *((_DWORD *)a4 + 1) && a3 < *((_DWORD *)a4 + 3) )
          result = 0;
      }
      ++v6;
    }
  }
  while ( !v5 );
  if ( result )
  {
LABEL_23:
    if ( result != 13 )
    {
LABEL_31:
      byte_1030CFD8 = 0;
      return result;
    }
  }
  if ( !v5 )
  {
    result = 8;
    goto LABEL_31;
  }
  if ( *((_DWORD *)a4 + 4) && *((_DWORD *)a4 + 5) && *((_DWORD *)a4 + 6) )
  {
    if ( *((_DWORD *)a4 + 7) )
    {
      byte_1030CFD8 = a1;
      qmemcpy(&dword_1030CFAC, a4, 0x2Cu);
    }
  }
  return result;
}
// 1030CFAC: using guessed type int dword_1030CFAC;
// 1030CFB0: using guessed type int dword_1030CFB0;
// 1030CFB4: using guessed type int dword_1030CFB4;
// 1030CFB8: using guessed type int dword_1030CFB8;
// 1030CFD8: using guessed type char byte_1030CFD8;

//----- (1007A660) --------------------------------------------------------
char sub_1007A660()
{
  int v0; // edi@1
  int v1; // ebp@1
  int v2; // eax@1
  int v4; // [sp+10h] [bp-18h]@1
  char v5; // [sp+14h] [bp-14h]@1
  __int16 v6; // [sp+24h] [bp-4h]@2

  word_1033708E = 0;
  word_10337090 = 0;
  word_10337094 = 0;
  memset(&dword_1030CFAC, 0, 0x2Cu);
  byte_1030CFD8 = 0;
  v4 = 152;
  v0 = sub_1007A0E0(2, &word_10337090, 2u, (int)&v4);
  v4 = 152;
  v1 = sub_1007A0E0(0, &word_10337094, 2u, (int)&v4);
  v2 = sub_1007A110((int)&v5);
  if ( v2 )
    byte_1033708C = 7;
  else
    word_1033708E = v6;
  if ( v0 || v2 || v1 )
  {
    byte_10337092 = 0;
    byte_10337096 = 0;
  }
  else
  {
    LOBYTE(v2) = 1;
    byte_10337092 = 1;
    byte_10337096 = 1;
  }
  return v2;
}
// 1030CFAC: using guessed type int dword_1030CFAC;
// 1030CFD8: using guessed type char byte_1030CFD8;
// 1033708C: using guessed type char byte_1033708C;
// 1033708E: using guessed type __int16 word_1033708E;
// 10337090: using guessed type __int16 word_10337090;
// 10337092: using guessed type char byte_10337092;
// 10337094: using guessed type __int16 word_10337094;
// 10337096: using guessed type char byte_10337096;

//----- (1007A720) --------------------------------------------------------
void *sub_1007A720()
{
  void *v0; // esi@1
  signed int v1; // edi@1
  void *result; // eax@3

  byte_1033708C = 1;
  byte_10337092 = 1;
  word_10337094 = 0;
  word_10337090 = 0;
  word_1033708E = 0;
  byte_10337096 = 0;
  sub_1007A660();
  sub_10079960((int)&unk_10301010, 80, 80);
  sub_100799C0();
  sub_10079960((int)word_1030B34C, 60, 60);
  memset(&unk_1030B320, 0, 0x2Cu);
  dword_1030CF6C = 0;
  dword_1030CF70 = 0;
  dword_1030CF74 = 0;
  dword_1030CF78 = 0;
  dword_1030CF7C = 0;
  dword_1030CF80 = 0;
  dword_1030CF84 = 0;
  dword_1030CF88 = 0;
  dword_1030CF8C = 0;
  dword_1030CF90 = 0;
  dword_1030CF94 = 0;
  dword_1030CF98 = 0;
  dword_1030CFA4 = -536868000;
  dword_1030CFA8 = -1073736000;
  dword_1030CF9C = 536868000;
  dword_1030CFA0 = 1073736000;
  memset(&unk_10304220, 0, 0x2Cu);
  v0 = &unk_1030424C;
  v1 = 4;
  do
  {
    sub_10079960((int)v0, 60, 60);
    v0 = (char *)v0 + 7200;
    --v1;
  }
  while ( v1 );
  result = memset(&unk_1030B2CC, 0, 0x50u);
  dword_1030B31C = 0;
  return result;
}
// 1030B31C: using guessed type int dword_1030B31C;
// 1030B34C: using guessed type __int16 word_1030B34C[];
// 1030CF6C: using guessed type int dword_1030CF6C;
// 1030CF70: using guessed type int dword_1030CF70;
// 1030CF74: using guessed type int dword_1030CF74;
// 1030CF78: using guessed type int dword_1030CF78;
// 1030CF7C: using guessed type int dword_1030CF7C;
// 1030CF80: using guessed type int dword_1030CF80;
// 1030CF84: using guessed type int dword_1030CF84;
// 1030CF88: using guessed type int dword_1030CF88;
// 1030CF8C: using guessed type int dword_1030CF8C;
// 1030CF90: using guessed type int dword_1030CF90;
// 1030CF94: using guessed type int dword_1030CF94;
// 1030CF98: using guessed type int dword_1030CF98;
// 1030CF9C: using guessed type int dword_1030CF9C;
// 1030CFA0: using guessed type int dword_1030CFA0;
// 1030CFA4: using guessed type int dword_1030CFA4;
// 1030CFA8: using guessed type int dword_1030CFA8;
// 1033708C: using guessed type char byte_1033708C;
// 1033708E: using guessed type __int16 word_1033708E;
// 10337090: using guessed type __int16 word_10337090;
// 10337092: using guessed type char byte_10337092;
// 10337094: using guessed type __int16 word_10337094;
// 10337096: using guessed type char byte_10337096;

//----- (1007A750) --------------------------------------------------------
signed int __usercall sub_1007A750@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<esi>)
{
  signed int result; // eax@10

  if ( a4 && a3 )
  {
    *(_BYTE *)(a1 + 513) = 0;
    *(_WORD *)(a1 + 544) = *(_WORD *)(a3 + 2);
    *(_WORD *)(a1 + 546) = 0x3FFF;
    *(_WORD *)(a1 + 548) = *(_WORD *)(a3 + 6);
    *(_WORD *)(a1 + 550) = *(_WORD *)a3;
    *(_WORD *)(a1 + 556) = *(_WORD *)(a4 + 36);
    *(_WORD *)(a1 + 554) = *(_WORD *)(a4 + 38);
  }
  else if ( a2 )
  {
    *(_BYTE *)(a1 + 513) = 2;
    *(_WORD *)(a1 + 544) = *(_WORD *)(a2 + 42);
    *(_WORD *)(a1 + 546) = 0x3FFF;
    *(_WORD *)(a1 + 548) = *(_WORD *)(a2 + 46);
    *(_WORD *)(a1 + 550) = *(_WORD *)(a2 + 36);
    *(_WORD *)(a1 + 556) = *(_WORD *)(a2 + 38);
    *(_WORD *)(a1 + 554) = *(_WORD *)(a2 + 40);
  }
  if ( *(_WORD *)(a1 + 556) > 0x78u
    || *(_WORD *)(a1 + 554) > 0x78u
    || *(_WORD *)(a1 + 546) > 0x3FFFu
    || *(_WORD *)(a1 + 544) > 0x1Eu )
  {
    result = 11;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1007A820) --------------------------------------------------------
int __thiscall sub_1007A820(int this)
{
  _WORD *v1; // esi@1
  unsigned int v2; // edi@1
  signed __int16 i; // bx@1
  signed int v4; // esi@2
  int v6; // [sp+Ch] [bp-20Ch]@1
  __int16 v7; // [sp+10h] [bp-208h]@1
  char v8; // [sp+14h] [bp-204h]@4

  v1 = (_WORD *)this;
  v6 = *(_DWORD *)(this + 16);
  sub_1007A0E0(0, &v7, 4u, (int)&v6);
  v2 = *v1;
  for ( i = -1; (signed int)v2 > 0; i = sub_1007B820(&v8, v4, i, 2) )
  {
    v4 = v2;
    if ( v2 > 0x200 )
      v4 = 512;
    sub_1007A0E0(0, &v8, v4, (int)&v6);
    v2 -= v4;
  }
  return i != v7 ? 3 : 0;
}

//----- (1007A8D0) --------------------------------------------------------
int __usercall sub_1007A8D0@<eax>(int a1@<eax>, __int16 a2@<bx>, int a3@<esi>, int a4)
{
  unsigned __int16 v4; // bp@1
  int v5; // edi@1
  unsigned __int16 v6; // ax@1
  __int16 v7; // ax@2
  bool v8; // cf@6
  bool v9; // zf@6
  __int16 v10; // dx@10
  __int64 v11; // rax@18
  __int16 v12; // di@18
  _BYTE *v13; // ecx@18
  _WORD *v14; // eax@18
  signed int v15; // edx@18
  int result; // eax@20

  v4 = *(_WORD *)(a3 + 546);
  v5 = a1;
  v6 = *(_WORD *)(a3 + 544);
  if ( v6 )
    v7 = (unsigned int)((2 * v6 + v4) / (2 * v6 + 1)) + 1;
  else
    v7 = v4 + 1;
  *(_WORD *)(a3 + 558) = v7;
  *(_BYTE *)a3 = 1;
  if ( v4 + 1 > 2 )
  {
    do
      ++*(_BYTE *)a3;
    while ( 1 << *(_BYTE *)a3 < *(_WORD *)(a3 + 546) + 1 );
  }
  v8 = *(_WORD *)(a3 + 558) < 2u;
  v9 = *(_WORD *)(a3 + 558) == 2;
  *(_BYTE *)(a3 + 523) = 1;
  if ( !v8 && !v9 )
  {
    do
      ++*(_BYTE *)(a3 + 523);
    while ( 1 << *(_BYTE *)(a3 + 523) < *(_WORD *)(a3 + 558) );
  }
  *(_BYTE *)(a3 + 516) = 4 * *(_BYTE *)a3 - *(_BYTE *)(a3 + 523) - 1;
  if ( v5 )
  {
    *(_DWORD *)(a3 + 568) = *(_DWORD *)(v5 + 16) + 4;
    *(_WORD *)(a3 + 552) = *(_WORD *)(v5 + 20);
    if ( a2 == 1 )
    {
      *(_DWORD *)(a3 + 568) += *(_WORD *)(v5 + 20);
      v10 = *(_WORD *)(v5 + 22);
LABEL_17:
      *(_WORD *)(a3 + 552) = v10;
      goto LABEL_18;
    }
    if ( a2 == 2 )
    {
      *(_DWORD *)(a3 + 568) += *(_WORD *)(v5 + 20) + *(_WORD *)(v5 + 22);
      v10 = *(_WORD *)(v5 + 24);
      goto LABEL_17;
    }
    if ( a2 == 3 )
    {
      *(_DWORD *)(a3 + 568) += *(_WORD *)(v5 + 20) + *(_WORD *)(v5 + 24) + *(_WORD *)(v5 + 22);
      *(_WORD *)(a3 + 552) = *(_WORD *)(a3 + 550) - *(_WORD *)(v5 + 22) - *(_WORD *)(v5 + 24) - *(_WORD *)(v5 + 20);
    }
  }
  else if ( a4 )
  {
    v10 = *(_WORD *)(a3 + 550);
    *(_DWORD *)(a3 + 568) = *(_DWORD *)(a4 + 32) + 4;
    goto LABEL_17;
  }
LABEL_18:
  sub_1007B110(a3);
  v11 = *(_WORD *)(a3 + 558) + 32;
  v12 = ((BYTE4(v11) & 0x3F) + (signed int)v11) >> 6;
  v13 = (_BYTE *)(a3 + 519);
  v14 = (_WORD *)(a3 + 534);
  v15 = 4;
  do
  {
    *(v14 - 4) = v12;
    *v14 = 0;
    *v13 = 1;
    ++v14;
    ++v13;
    --v15;
  }
  while ( v15 );
  result = a3;
  *(_BYTE *)(a3 + 515) = 0;
  *(_BYTE *)(a3 + 524) = 0;
  *(_WORD *)(a3 + 560) = 1;
  return result;
}

//----- (1007AA80) --------------------------------------------------------
int __cdecl sub_1007AA80(__int16 a1, int a2, unsigned __int16 a3, void (__cdecl *a4)(int, int, int, int), int a5, int a6, int a7, int a8, int a9)
{
  signed int v9; // edi@1
  char *v10; // ebp@1
  int result; // eax@2
  int v12; // esi@4
  unsigned __int16 v13; // cx@6
  _WORD *v14; // ecx@14
  int v15; // ebx@14
  __int16 v16; // dx@15
  char *v17; // eax@20
  unsigned __int16 v18; // [sp+10h] [bp-460h]@1
  unsigned __int16 v19; // [sp+14h] [bp-45Ch]@4
  __int16 v20; // [sp+18h] [bp-458h]@4
  char *v21; // [sp+1Ch] [bp-454h]@1
  signed int v22; // [sp+20h] [bp-450h]@1
  char v23; // [sp+3Ch] [bp-434h]@1
  unsigned __int16 v24; // [sp+266h] [bp-20Ah]@6
  unsigned __int16 v25; // [sp+268h] [bp-208h]@6
  char v26; // [sp+27Ch] [bp-1F4h]@1
  char v27; // [sp+374h] [bp-FCh]@1

  memset(&v23, 0, 0x240u);
  sub_1007B060((int)&v23);
  memset(&v26, 0, 0xF6u);
  memset(&v27, 0, 0xF6u);
  v9 = 1;
  v21 = &v26;
  v10 = &v27;
  v18 = 0;
  v22 = 1;
  if ( a7 )
  {
    result = sub_1007A820(a7);
    if ( result )
      return result;
  }
  result = sub_1007A750((int)&v23, a8, a7, a6);
  if ( result )
    return result;
  sub_1007A8D0(a7, a1, (int)&v23, a8);
  v12 = 0;
  v19 = 0;
  v20 = 0;
  if ( a7 && a6 )
  {
    v13 = v25 >> 1;
    v12 = v24 >> 1;
    v20 = word_10337094;
LABEL_9:
    v19 = v13;
    goto LABEL_10;
  }
  if ( a8 )
  {
    v13 = v25;
    v12 = v24;
    v20 = word_10337090;
    goto LABEL_9;
  }
LABEL_10:
  if ( v19 >= 1u )
  {
    do
    {
      *(_WORD *)v10 = *((_WORD *)v21 + 1);
      sub_1007B6E0((int)v21, (unsigned __int16 *)v10, (int)&v23, v12);
      if ( (unsigned __int16)v12 + v18 > a3 )
      {
        *(_WORD *)(a9 + 14) = v9 - 3;
        a4(v9 - v22, v12, a9, a5);
        v22 = (unsigned __int16)v9;
        v18 = 0;
      }
      memcpy_0((void *)(a2 + 2 * v18), v10 + 2, 2 * (unsigned __int16)v12);
      if ( (_WORD)v12 )
      {
        v14 = (_WORD *)(a2 + 2 * v18);
        v15 = (unsigned __int16)v12;
        do
        {
          v16 = *v14 - v20;
          *v14 = v16;
          if ( v16 > -870 )
          {
            if ( v16 <= -770 )
              *v14 = 0;
          }
          else
          {
            *v14 = -32767;
          }
          ++v14;
          --v15;
        }
        while ( v15 );
      }
      v18 += v12;
      *(_WORD *)&v10[2 * v24 + 2] = *(_WORD *)&v10[2 * v24];
      v17 = v10;
      v10 = v21;
      ++v9;
      v21 = v17;
    }
    while ( (unsigned __int16)v9 <= v19 );
  }
  *(_WORD *)(a9 + 14) = v9 - 3;
  a4(v9 - v22, v12, a9, a5);
  return sub_1007AF50((int)&v23);
}
// 10337090: using guessed type __int16 word_10337090;
// 10337094: using guessed type __int16 word_10337094;

//----- (1007AD40) --------------------------------------------------------
int __cdecl sub_1007AD40(char a1, int a2)
{
  int v2; // esi@1
  bool v3; // sf@1
  int result; // eax@1
  unsigned __int8 v5; // dl@4
  char v6; // cl@4
  int v7; // edx@4

  v2 = a2;
  *(_DWORD *)(v2 + 564) <<= a1;
  v3 = (char)(a1 + *(_BYTE *)(a2 + 525)) < 0;
  *(_BYTE *)(v2 + 525) += a1;
  result = 0;
  if ( !v3 )
  {
    do
    {
      if ( *(_WORD *)(a2 + 542) >= 508 )
      {
        result = sub_1007B080(a2);
        if ( result )
          break;
      }
      v5 = *(_BYTE *)((*(_WORD *)(a2 + 542))++ + a2 + 5);
      v6 = *(_BYTE *)(a2 + 525);
      v7 = v5 << v6;
      v6 -= 8;
      *(_BYTE *)(a2 + 525) = v6;
      *(_DWORD *)(a2 + 564) |= v7;
    }
    while ( v6 >= 0 );
  }
  return result;
}

//----- (1007ADD0) --------------------------------------------------------
unsigned __int16 __cdecl sub_1007ADD0(unsigned __int16 a1, int a2)
{
  unsigned __int16 v2; // di@1
  unsigned __int8 v3; // al@2
  char v4; // dl@2
  char v5; // bl@4
  unsigned __int8 v6; // al@6
  unsigned __int8 v7; // al@7
  char v8; // cl@7
  char v9; // al@11
  __int16 v10; // di@12
  char v11; // al@13
  unsigned __int8 v12; // al@14
  char v13; // cl@14
  unsigned __int8 v15; // al@17
  unsigned __int8 v16; // al@18
  char v17; // cl@18
  unsigned __int16 v18; // [sp+10h] [bp-8h]@1
  char v19; // [sp+14h] [bp-4h]@4

  v18 = 0;
  v2 = 0;
  while ( 1 )
  {
    v3 = *(_BYTE *)(a2 + 567);
    v4 = 0;
    if ( v3 >= 0x80u )
      v4 = byte_101678A0[(unsigned __int8)~v3];
    v5 = 1;
    v19 = 1;
    if ( (unsigned __int8)v4 >= 1u )
      break;
LABEL_9:
    if ( v4 != 8 )
    {
      sub_1007AD40(v4 + 1, a2);
      v9 = *(_BYTE *)(a2 + 524);
      if ( v9 )
      {
        v10 = *(_DWORD *)(a2 + 564) >> (32 - v9);
        sub_1007AD40(v9, a2);
        v2 = v10 + v18;
      }
      *(_BYTE *)(a2 + 518) = *(_BYTE *)(a2 + 524) + 1;
      v11 = *(_BYTE *)(a2 + 515);
      if ( v11 )
      {
        v12 = v11 - 1;
        *(_BYTE *)(a2 + 515) = v12;
        v13 = byte_1016787C[v12];
        *(_BYTE *)(a2 + 524) = v13;
        *(_WORD *)(a2 + 560) = 1 << v13;
      }
      return v2;
    }
    sub_1007AD40(8, a2);
  }
  while ( 1 )
  {
    v2 += *(_WORD *)(a2 + 560);
    v18 = v2;
    if ( v2 >= a1 )
      break;
    v6 = *(_BYTE *)(a2 + 515);
    if ( v6 < 0x20u )
    {
      v7 = v6 + 1;
      *(_BYTE *)(a2 + 515) = v7;
      v8 = byte_1016787C[v7];
      *(_BYTE *)(a2 + 524) = v8;
      *(_WORD *)(a2 + 560) = 1 << v8;
    }
    v19 = ++v5;
    if ( (unsigned __int8)v5 > (unsigned __int8)v4 )
      goto LABEL_9;
  }
  if ( v2 == a1 )
  {
    v15 = *(_BYTE *)(a2 + 515);
    if ( v15 < 0x20u )
    {
      v16 = v15 + 1;
      *(_BYTE *)(a2 + 515) = v16;
      v17 = byte_1016787C[v16];
      *(_BYTE *)(a2 + 524) = v17;
      *(_WORD *)(a2 + 560) = 1 << v17;
    }
  }
  sub_1007AD40(v19, a2);
  return a1;
}

//----- (1007AF50) --------------------------------------------------------
signed int __cdecl sub_1007AF50(int a1)
{
  int v1; // ebp@1
  char v2; // cl@1
  int v3; // esi@1
  int i; // eax@1
  char v5; // dl@2
  int v6; // edi@2
  _BYTE *v7; // esi@3
  int v8; // ebp@3
  int v9; // ebx@4
  char v10; // cl@8
  int v11; // eax@11
  signed int result; // eax@14
  int v13; // [sp+14h] [bp-4h]@1

  v1 = a1;
  v2 = 24 - *(_BYTE *)(a1 + 525);
  v3 = v2;
  v13 = v2;
  for ( i = (v2 + 2) / 8; ; LOBYTE(i) = i - 1 )
  {
    v5 = 0;
    v6 = 0;
    if ( (char)i > 0 )
    {
      v7 = (_BYTE *)(*(_WORD *)(v1 + 542) - (char)i + v1 + 5);
      v8 = (unsigned __int8)i;
      do
      {
        v9 = *v7 << (24 - v5);
        v5 += 8;
        ++v7;
        v6 |= v9;
        --v8;
      }
      while ( v8 );
      v2 = 24 - *(_BYTE *)(a1 + 525);
      v1 = a1;
      v3 = v13;
    }
    if ( v5 <= v2 )
      break;
  }
  v10 = v2 - v5;
  if ( v3 - v5 > 7 || v6 != *(_DWORD *)(v1 + 564) << v10 || (((1 << v10) - 1) << (32 - v10)) & *(_DWORD *)(v1 + 564) )
  {
    result = 14;
  }
  else
  {
    *(_WORD *)(v1 + 542) -= (char)i;
    v11 = *(_WORD *)(v1 + 542) + v1;
    if ( *(_BYTE *)(v11 + 4) == -1 && !*(_BYTE *)(v11 + 5) )
      ++*(_WORD *)(v1 + 542);
    result = 0;
    *(_BYTE *)(v1 + 525) = 0;
    *(_DWORD *)(v1 + 564) = 0;
  }
  return result;
}

//----- (1007B060) --------------------------------------------------------
int __cdecl sub_1007B060(int a1)
{
  int result; // eax@1

  result = a1;
  *(_WORD *)(a1 + 542) = 508;
  *(_BYTE *)(a1 + 514) = 0;
  return result;
}

//----- (1007B080) --------------------------------------------------------
int __cdecl sub_1007B080(int a1)
{
  int v1; // esi@1
  signed int v2; // eax@1
  _BYTE *v3; // ecx@1
  signed int v4; // edi@1
  int v5; // eax@3
  size_t v6; // edi@3
  int result; // eax@5

  v1 = a1;
  v2 = -4;
  v3 = (_BYTE *)(a1 + 1);
  v4 = 4;
  do
  {
    *v3++ = *(_BYTE *)(v2++ + *(_WORD *)(v1 + 542) + v1 + 5);
    --v4;
  }
  while ( v4 );
  v5 = *(_DWORD *)(v1 + 572);
  v6 = *(_WORD *)(v1 + 552) - v5;
  a1 = v5 + *(_DWORD *)(v1 + 568);
  if ( v6 > 0x1FC )
    v6 = 508;
  result = sub_1007A0E0(*(_BYTE *)(v1 + 513), (void *)(v1 + 5), v6, (int)&a1);
  if ( !result )
  {
    *(_DWORD *)(v1 + 572) += v6;
    *(_WORD *)(v1 + 542) = 0;
  }
  return result;
}

//----- (1007B110) --------------------------------------------------------
int __cdecl sub_1007B110(int a1)
{
  *(_DWORD *)(a1 + 564) = 0;
  *(_BYTE *)(a1 + 525) = 0;
  return sub_1007AD40(24, a1);
}

//----- (1007B130) --------------------------------------------------------
__int16 __usercall sub_1007B130@<ax>(int a1@<ecx>, int a2@<esi>, unsigned __int16 a3, unsigned __int16 a4, unsigned __int8 a5)
{
  int v5; // edi@1
  unsigned int v6; // eax@2
  char v7; // bl@4
  int v8; // eax@7
  signed int v9; // ebp@7
  unsigned __int8 v10; // cl@10
  char v11; // al@10
  unsigned __int8 v12; // al@15
  __int16 v13; // bp@17
  int v14; // ebp@18
  char v15; // al@23
  int v16; // eax@26
  int v17; // ecx@26
  int v18; // ebp@28
  int v19; // ecx@28
  __int16 v20; // ax@28
  __int16 v21; // ax@36
  __int16 result; // ax@43
  int v23; // [sp+4h] [bp-Ch]@7
  int v24; // [sp+4h] [bp-Ch]@25
  __int16 v25; // [sp+4h] [bp-Ch]@28
  int v26; // [sp+8h] [bp-8h]@0
  char v27; // [sp+Ch] [bp-4h]@4
  int v28; // [sp+1Ch] [bp+Ch]@29
  int v29; // [sp+1Ch] [bp+Ch]@41

  LOWORD(v26) = a5;
  v5 = (unsigned __int16)(a5 + 2);
  if ( a5 )
    LOWORD(v6) = *(_WORD *)(a2 + 2 * v5 + 526) + (unsigned __int8)(*(_BYTE *)(v5 + a2 + 519) >> 1);
  else
    LOWORD(v6) = *(_WORD *)(a2 + 2 * v5 + 526);
  v6 = (unsigned __int16)v6;
  v7 = 0;
  v27 = 0;
  if ( *(_BYTE *)(v5 + a2 + 519) < (unsigned int)(unsigned __int16)v6 )
  {
    do
      ++v7;
    while ( (unsigned int)*(_BYTE *)(v5 + a2 + 519) << v7 < v6 );
    v27 = v7;
  }
  v8 = 0;
  v23 = 0;
  v9 = 100;
  while ( !v8 )
  {
    if ( --v9 <= 0 )
      break;
    v10 = *(_BYTE *)(a2 + 567);
    v11 = 0;
    if ( v10 < 0x80u )
      v11 = byte_101678A0[v10];
    LOWORD(v23) = (unsigned __int8)v11 + (_WORD)v23;
    if ( v11 != 8 )
    {
      sub_1007AD40(v11 + 1, a2);
      break;
    }
    v8 = sub_1007AD40(8, a2);
  }
  v12 = *(_BYTE *)(a2 + 516) - *(_BYTE *)(a2 + 518);
  *(_BYTE *)(a2 + 517) = v12;
  if ( (signed __int16)v23 >= v12 )
  {
    v14 = (unsigned __int16)(*(_DWORD *)(a2 + 564) >> (32 - *(_BYTE *)(a2 + 523)));
    sub_1007AD40(*(_BYTE *)(a2 + 523), a2);
    v23 = v14 + 1;
LABEL_19:
    if ( v7 )
      goto LABEL_24;
    goto LABEL_20;
  }
  if ( v7 )
  {
    v13 = *(_DWORD *)(a2 + 564) >> (32 - v7);
    sub_1007AD40(v27, a2);
    v23 = (unsigned __int16)(v13 + ((_WORD)v23 << v7));
    goto LABEL_19;
  }
LABEL_20:
  if ( a5 || (_WORD)v23 )
  {
    a1 = *(_BYTE *)(v5 + a2 + 519);
    if ( 2 * *(_WORD *)(a2 + 2 * v5 + 534) < a1 )
    {
      v15 = 1;
      goto LABEL_25;
    }
  }
LABEL_24:
  v15 = 0;
LABEL_25:
  LOWORD(a1) = (unsigned __int8)v15;
  v24 = a1 + v26 + v23;
  if ( v24 & 1 )
  {
    v16 = (unsigned __int16)((unsigned __int8)v15 - (unsigned __int16)(((signed __int16)v24 + 1) / 2));
    v17 = -(v16 + v26);
    ++*(_WORD *)(a2 + 2 * v5 + 534);
  }
  else
  {
    LOWORD(v16) = (signed __int16)v24 / 2;
    LOWORD(v17) = (signed __int16)v24 / 2 - a5;
  }
  v18 = *(_WORD *)(a2 + 544);
  v25 = v17;
  v19 = 2 * v18 + 1;
  v20 = v16 * (2 * v18 + 1);
  if ( a5 )
  {
    v28 = (unsigned __int16)(a3 + v20);
  }
  else if ( a4 >= a3 )
  {
    if ( a4 <= a3 )
      v28 = 0;
    else
      v28 = (unsigned __int16)(a4 + v20);
  }
  else
  {
    v28 = (unsigned __int16)(a4 - v20);
  }
  if ( (signed __int16)v28 >= -(signed __int16)v18 )
  {
    if ( (signed __int16)v28 <= (signed __int16)(v18 + *(_WORD *)(a2 + 546)) )
      goto LABEL_40;
    v21 = v28 - v19 * *(_WORD *)(a2 + 558);
  }
  else
  {
    v21 = v19 * *(_WORD *)(a2 + 558) + v28;
  }
  LOWORD(v28) = v21;
LABEL_40:
  if ( v28 & 0x8000 )
    v29 = 0;
  else
    v29 = v28 & 0x3FFF;
  *(_WORD *)(a2 + 2 * v5 + 526) += v25;
  result = v29;
  if ( *(_BYTE *)(v5 + a2 + 519) == 64 )
  {
    *(_BYTE *)(v5 + a2 + 519) = 32;
    *(_WORD *)(a2 + 2 * v5 + 526) >>= 1;
    *(_WORD *)(a2 + 2 * v5 + 534) >>= 1;
  }
  ++*(_BYTE *)(v5 + a2 + 519);
  return result;
}

//----- (1007B3F0) --------------------------------------------------------
__int16 __usercall sub_1007B3F0@<ax>(int a1@<edi>, int a2@<esi>, char a3, __int16 a4)
{
  char v4; // bl@4
  signed __int16 v5; // bp@7
  unsigned __int8 v6; // cl@8
  char v7; // al@8
  __int16 v8; // bp@14
  __int16 v9; // bp@15
  __int16 v10; // ax@18
  __int16 v11; // cx@26
  signed __int16 v12; // dx@29
  __int16 v13; // dx@32
  unsigned __int8 v14; // cl@41
  __int16 v15; // ax@41
  __int16 v16; // cx@42
  __int16 result; // ax@44
  __int16 v18; // ax@47
  bool v19; // zf@47
  bool v20; // sf@47
  signed __int16 v21; // [sp+0h] [bp-8h]@12
  __int16 v22; // [sp+0h] [bp-8h]@18
  char v23; // [sp+4h] [bp-4h]@4
  int v24; // [sp+Ch] [bp+4h]@31
  int v25; // [sp+Ch] [bp+4h]@37
  int v26; // [sp+10h] [bp+8h]@2

  if ( a4 & 0x8000 )
    v26 = 0;
  else
    v26 = a4 & 0x3FFF;
  a1 = (unsigned __int16)a1;
  v4 = 0;
  v23 = 0;
  if ( (unsigned __int16)*(_BYTE *)((unsigned __int16)a1 + a2 + 519) < *(_WORD *)(a2 + 2 * (unsigned __int16)a1 + 526) )
  {
    do
      ++v4;
    while ( *(_BYTE *)(a1 + a2 + 519) << v4 < *(_WORD *)(a2 + 2 * a1 + 526) );
    v23 = v4;
  }
  v5 = 0;
  while ( 1 )
  {
    v6 = *(_BYTE *)(a2 + 567);
    v7 = 0;
    if ( v6 < 0x80u )
      v7 = byte_101678A0[v6];
    v5 += (unsigned __int8)v7;
    if ( v7 != 8 )
      break;
    sub_1007AD40(8, a2);
  }
  v21 = v5;
  sub_1007AD40(v7 + 1, a2);
  if ( v5 >= *(_BYTE *)(a2 + 516) )
  {
    v9 = *(_DWORD *)(a2 + 564) >> (32 - *(_BYTE *)(a2 + 523));
    sub_1007AD40(*(_BYTE *)(a2 + 523), a2);
    v21 = v9 + 1;
  }
  else
  {
    if ( !v4 )
      goto LABEL_17;
    v8 = *(_DWORD *)(a2 + 564) >> (32 - v4);
    sub_1007AD40(v23, a2);
    v21 = v8 + (v21 << v4);
  }
  v5 = v21;
LABEL_17:
  if ( v21 & 1 )
  {
    v22 = (v5 + 1) / 2;
    v10 = (v5 + 1) / -2;
  }
  else
  {
    v22 = v5 / 2;
    v10 = v5 / 2;
  }
  if ( !v4 && !*(_WORD *)(a2 + 544) && 2 * *(_WORD *)(a2 + 2 * a1 + 534) <= -*(_BYTE *)(a1 + a2 + 519) )
  {
    v10 = -1 - v10;
    if ( v10 >= 0 )
      v22 = v10;
    else
      v22 = -v10;
  }
  v11 = *(_WORD *)(a2 + 544);
  if ( v11 )
    v10 *= 2 * v11 + 1;
  if ( a3 == -1 )
    v12 = v26 - v10;
  else
    v12 = v10 + v26;
  v24 = (unsigned __int16)v12;
  if ( v12 >= -v11 )
  {
    if ( v12 <= (signed __int16)(v11 + *(_WORD *)(a2 + 546)) )
      goto LABEL_36;
    v13 = v12 - *(_WORD *)(a2 + 558) * (2 * v11 + 1);
  }
  else
  {
    v13 = *(_WORD *)(a2 + 558) * (2 * v11 + 1) + v12;
  }
  LOWORD(v24) = v13;
LABEL_36:
  if ( v24 & 0x8000 )
    v25 = 0;
  else
    v25 = v24 & 0x3FFF;
  *(_WORD *)(a2 + 2 * a1 + 534) += v10;
  *(_WORD *)(a2 + 2 * a1 + 526) += v22;
  if ( *(_BYTE *)(a1 + a2 + 519) == 64 )
  {
    *(_BYTE *)(a1 + a2 + 519) = 32;
    *(_WORD *)(a2 + 2 * a1 + 526) >>= 1;
    *(_WORD *)(a2 + 2 * a1 + 534) >>= 1;
  }
  v14 = ++*(_BYTE *)(a1 + a2 + 519);
  v15 = *(_WORD *)(a2 + 2 * a1 + 534);
  if ( *(_WORD *)(a2 + 2 * a1 + 534) <= -*(_BYTE *)(a1 + a2 + 519) )
  {
    v16 = v15 + v14;
    *(_WORD *)(a2 + 2 * a1 + 534) = v16;
    if ( v16 <= -*(_BYTE *)(a1 + a2 + 519) )
      *(_WORD *)(a2 + 2 * a1 + 534) = 1 - *(_BYTE *)(a1 + a2 + 519);
    return v25;
  }
  if ( v15 <= 0 )
    return v25;
  v18 = v15 - v14;
  *(_WORD *)(a2 + 2 * a1 + 534) = v18;
  v19 = v18 == 0;
  v20 = v18 < 0;
  result = v25;
  if ( !v20 && !v19 )
    *(_WORD *)(a2 + 2 * a1 + 534) = 0;
  return result;
}

//----- (1007B6E0) --------------------------------------------------------
int __cdecl sub_1007B6E0(int a1, unsigned __int16 *a2, int a3, unsigned __int16 a4)
{
  unsigned __int16 v4; // cx@1
  unsigned __int16 v5; // bp@1
  int result; // eax@1
  unsigned __int16 *v7; // esi@1
  signed int v8; // ebx@1
  unsigned __int16 v9; // di@1
  int v10; // edx@6
  __int16 v11; // ax@9
  unsigned __int16 v12; // [sp+10h] [bp-10h]@1

  v4 = *(_WORD *)a1;
  v5 = *(_WORD *)(a1 + 2);
  result = *(_WORD *)(a1 + 4);
  v7 = a2;
  v8 = 1;
  v9 = *a2;
  v12 = *(_WORD *)(a1 + 4);
  if ( a4 >= 1u )
  {
    while ( 1 )
    {
      if ( (unsigned __int16)abs(v5 - v9) > *(_WORD *)(a3 + 544) )
      {
        v11 = sub_1007B3F0(1, a3, 2 * (v5 > v9) - 1, v9 + v5 - v4);
      }
      else
      {
        result = sub_1007ADD0(a4 - v8 + 1, a3);
        if ( (_WORD)result )
        {
          do
          {
            v10 = (unsigned __int16)v8;
            result += 0xFFFF;
            ++v8;
            v7[v10] = v9;
          }
          while ( (_WORD)result );
          if ( (unsigned __int16)v8 > a4 )
            return result;
          v5 = *(_WORD *)(a1 + 2 * (unsigned __int16)v8);
          v12 = *(_WORD *)(a1 + 2 * (unsigned __int16)v8 + 2);
        }
        v11 = sub_1007B130(*(_WORD *)(a3 + 544), a3, v9, v5, abs(v5 - v9) <= (signed int)*(_WORD *)(a3 + 544));
      }
      v9 = v11;
      a2[(unsigned __int16)v8] = v11;
      result = a1;
      ++v8;
      v4 = v5;
      v5 = v12;
      v12 = *(_WORD *)(a1 + 2 * (unsigned __int16)v8 + 2);
      if ( (unsigned __int16)v8 > a4 )
        return result;
      v7 = a2;
    }
  }
  return result;
}

//----- (1007B820) --------------------------------------------------------
unsigned __int16 __cdecl sub_1007B820(_BYTE *a1, int a2, unsigned __int16 a3, char a4)
{
  _BYTE *v4; // ecx@1
  int v5; // esi@2
  unsigned __int16 result; // ax@3
  __int16 v7; // bx@4
  unsigned int v8; // edx@4
  int v9; // edx@6
  int v10; // esi@8

  v4 = a1;
  if ( a4 == 1 )
  {
    v5 = a2;
    if ( a2 )
    {
      result = a3;
      do
      {
        LOBYTE(v7) = 0;
        HIBYTE(v7) = result;
        v8 = *v4 ^ ((unsigned int)result >> 8);
        --v5;
        ++v4;
        result = word_10167A20[v8] ^ v7;
      }
      while ( v5 );
      return result;
    }
    return a3;
  }
  v9 = a2;
  if ( !a2 )
    return a3;
  result = a3;
  do
  {
    v10 = (unsigned __int8)result ^ *v4;
    --v9;
    ++v4;
    result = word_10167C20[v10] ^ HIBYTE(result);
  }
  while ( v9 );
  return result;
}
// 10167A20: using guessed type __int16 word_10167A20[];
// 10167C20: using guessed type __int16 word_10167C20[];

//----- (1007B8A0) --------------------------------------------------------
int __cdecl sub_1007B8A0(unsigned __int8 a1, unsigned int a2)
{
  return dword_10167E20[a1 ^ (unsigned __int8)a2] ^ (a2 >> 8);
}
// 10167E20: using guessed type int dword_10167E20[];

//----- (1007B8C0) --------------------------------------------------------
unsigned int __cdecl sub_1007B8C0(unsigned int *a1, signed int a2, unsigned int a3)
{
  unsigned int *v3; // edx@1
  unsigned int result; // eax@1
  signed int i; // esi@1
  unsigned int v6; // edi@5
  unsigned int v7; // eax@6
  unsigned int v8; // eax@6
  unsigned int v9; // eax@6
  unsigned int v10; // eax@6
  unsigned int v11; // ecx@6
  unsigned int v12; // ecx@6
  unsigned int v13; // ecx@6

  v3 = a1;
  result = a3;
  for ( i = a2; i; --i )
  {
    if ( !((unsigned __int8)v3 & 3) )
      break;
    result = dword_10167E20[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    v3 = (unsigned int *)((char *)v3 + 1);
  }
  if ( i >= 8 )
  {
    v6 = (unsigned int)i >> 3;
    do
    {
      v7 = dword_10167E20[(unsigned __int8)result ^ (unsigned __int8)*v3] ^ (result >> 8);
      v8 = dword_10167E20[(unsigned __int8)v7 ^ (unsigned __int8)(*(_WORD *)v3 >> 8)] ^ (v7 >> 8);
      v9 = dword_10167E20[(unsigned __int8)v8 ^ (unsigned __int8)(*v3 >> 16)] ^ (v8 >> 8);
      v10 = dword_10167E20[(unsigned __int8)v9 ^ (*v3 >> 24)] ^ (v9 >> 8);
      v3 += 2;
      v11 = dword_10167E20[(unsigned __int8)v10 ^ (unsigned __int8)*(v3 - 1)] ^ (v10 >> 8);
      v12 = dword_10167E20[(unsigned __int8)v11 ^ (unsigned __int8)(*((_WORD *)v3 - 2) >> 8)] ^ (v11 >> 8);
      v13 = dword_10167E20[(unsigned __int8)v12 ^ (unsigned __int8)(*(v3 - 1) >> 16)] ^ (v12 >> 8);
      i -= 8;
      --v6;
      result = dword_10167E20[(unsigned __int8)v13 ^ (*(v3 - 1) >> 24)] ^ (v13 >> 8);
    }
    while ( v6 );
  }
  for ( ; i > 0; v3 = (unsigned int *)((char *)v3 + 1) )
  {
    result = dword_10167E20[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    --i;
  }
  return result;
}
// 10167E20: using guessed type int dword_10167E20[];

//----- (1007B9F0) --------------------------------------------------------
unsigned int __cdecl sub_1007B9F0(_BYTE *a1, int a2, unsigned int a3)
{
  int v3; // ecx@1
  unsigned int result; // eax@1
  _BYTE *i; // esi@1

  v3 = a2;
  result = a3;
  for ( i = a1; v3; ++i )
  {
    result = dword_10168220[(unsigned __int8)(result ^ *i)] ^ (result >> 8);
    --v3;
  }
  return result;
}
// 10168220: using guessed type int dword_10168220[];

//----- (1007BA30) --------------------------------------------------------
double __cdecl sub_1007BA30(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 != v4 && (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v11 = v2 + v9;
        result = v11;
      }
      else
      {
        v10 = v4;
        result = v10;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (1007BAD0) --------------------------------------------------------
int __cdecl sub_1007BAD0(signed int a1, signed int a2)
{
  int result; // eax@2

  if ( a2 > 0 )
  {
    result = a2 * (a1 / a2);
    if ( a1 == result )
    {
      result = a1;
    }
    else if ( a1 < 0 )
    {
      result -= a2;
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (1007BB10) --------------------------------------------------------
double __cdecl sub_1007BB10(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 == v4 || (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v10 = v4;
        result = v10;
      }
      else
      {
        v11 = v9 - v2;
        result = v11;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (1007BBB0) --------------------------------------------------------
double __cdecl sub_1007BBB0(double a1, double a2)
{
  double result; // st7@1
  double v3; // [sp+0h] [bp-8h]@2

  result = 0.0;
  if ( a2 > 0.0 )
  {
    v3 = a2 + a2;
    result = fmod(a1, v3);
    if ( a2 > result )
    {
      if ( -a2 > result )
        result = result + v3;
    }
    else
    {
      result = result - v3;
    }
  }
  return result;
}

//----- (1007BC10) --------------------------------------------------------
double __cdecl sub_1007BC10(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@5
  float v6; // [sp+8h] [bp+8h]@3
  float v7; // [sp+8h] [bp+8h]@3
  float v8; // [sp+8h] [bp+8h]@4
  float v9; // [sp+8h] [bp+8h]@6

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v6 = v2 + v2;
    v4 = v6;
    v7 = a1 - (double)(signed int)(a1 / v6) * v6;
    if ( v7 < v2 )
    {
      v5 = v2;
      result = v7;
      if ( -v5 > v7 )
      {
        v9 = result + v4;
        result = v9;
      }
    }
    else
    {
      v8 = v7 - v4;
      result = v8;
    }
  }
  else
  {
    result = 0.0;
  }
  return result;
}

//----- (1007BC90) --------------------------------------------------------
void __cdecl sub_1007BC90(double a1)
{
  sub_1007BBB0(a1, 3.1415926535898);
}

//----- (1007BCB0) --------------------------------------------------------
double __cdecl sub_1007BCB0(float a1)
{
  double result; // st7@3

  if ( a1 == -3.141592741012573 || a1 == 3.141592741012573 )
    result = -3.1415925;
  else
    result = sub_1007BC10(a1, 3.1415927);
  return result;
}

//----- (1007BCF0) --------------------------------------------------------
int __cdecl sub_1007BCF0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(float *)a2 = *(double *)a1;
  *(float *)(a2 + 4) = *(double *)(a1 + 8);
  return result;
}

//----- (1007BD10) --------------------------------------------------------
int __cdecl sub_1007BD10(float a1)
{
  double v1; // st7@1
  int result; // eax@2

  v1 = a1;
  if ( a1 >= 0.0 )
    result = (signed int)(v1 + 0.5);
  else
    result = (signed int)(v1 - 0.5);
  return result;
}

//----- (1007BD40) --------------------------------------------------------
double __cdecl sub_1007BD40(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  float v4; // [sp+8h] [bp+8h]@5

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    if ( a1 < 0.0 )
      a2 = -v2;
    v4 = v2 * (double)(signed int)((a1 + a2 * 0.5) / v2);
    result = v4;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (1007BDB0) --------------------------------------------------------
int __cdecl sub_1007BDB0(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a3;
  *(float *)a3 = cos(a1);
  *(float *)a2 = sin(a1);
  return result;
}

//----- (1007BDD0) --------------------------------------------------------
int __cdecl sub_1007BDD0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(double *)a2 = *(float *)a1;
  *(double *)(a2 + 8) = *(float *)(a1 + 4);
  return result;
}

//----- (1007BDF0) --------------------------------------------------------
int __cdecl sub_1007BDF0(float a1)
{
  double v1; // st7@1
  int result; // eax@3
  float v3; // [sp+8h] [bp+4h]@1
  float v4; // [sp+8h] [bp+4h]@2
  float v5; // [sp+8h] [bp+4h]@3

  v3 = sub_1007BCB0(a1);
  v1 = v3;
  if ( v3 < 0.0 )
  {
    v4 = v1 + 6.283185482025146;
    v1 = v4;
  }
  v5 = v1 * 180.0 / 3.1415926535898;
  result = (signed int)(v5 + 0.5);
  if ( result >= 360 )
    result = 0;
  return result;
}

//----- (1007BE50) --------------------------------------------------------
double __cdecl sub_1007BE50(double a1, double a2)
{
  double result; // st7@1

  result = 0.0;
  if ( a2 == 0.0 )
  {
    if ( a1 != 0.0 )
    {
      if ( a1 <= 0.0 )
        result = -1.5707963267949;
      else
        result = 1.5707963267949;
    }
  }
  else
  {
    result = atan(a1 / a2);
    if ( a2 < 0.0 )
    {
      result = result + 3.1415926535898;
      sub_1007BC90(result);
    }
  }
  return result;
}

//----- (1007BEC0) --------------------------------------------------------
double __cdecl sub_1007BEC0(float a1, float a2)
{
  double result; // st7@1
  float v3; // [sp+4h] [bp-4h]@6
  float v4; // [sp+10h] [bp+8h]@7

  result = 0.0;
  if ( a2 == 0.0 )
  {
    if ( a1 != 0.0 )
    {
      if ( a1 <= 0.0 )
        result = -1.5707964;
      else
        result = 1.5707964;
    }
  }
  else
  {
    v3 = atan(a1 / a2);
    if ( a2 < 0.0 )
    {
      v4 = v3 + 3.141592741012573;
      v3 = sub_1007BCB0(v4);
    }
    result = v3;
  }
  return result;
}

//----- (1007BF50) --------------------------------------------------------
int __cdecl sub_1007BF50(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(float *)a3 = *(float *)a1 + *(float *)a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) + *(float *)(a2 + 4);
  *(float *)(a3 + 8) = *(float *)(a1 + 8) + *(float *)(a2 + 8);
  return result;
}

//----- (1007BF80) --------------------------------------------------------
int __cdecl sub_1007BF80(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a2;
  *(float *)a3 = *(float *)a2 * a1;
  *(float *)(a3 + 4) = *(float *)(a2 + 4) * a1;
  *(float *)(a3 + 8) = a1 * *(float *)(a2 + 8);
  return result;
}

//----- (1007BFB0) --------------------------------------------------------
int __cdecl sub_1007BFB0(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_crit_lvl(a1);
  SYS_exit_krnl();
  return v1;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DA68: using guessed type int __cdecl TSK_pvg_get_crit_lvl(_DWORD);

//----- (1007BFD0) --------------------------------------------------------
int sub_1007BFD0()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_id();
  SYS_exit_krnl();
  return v0;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DA6E: using guessed type int TSK_pvg_get_id(void);

//----- (1007BFF0) --------------------------------------------------------
int __cdecl sub_1007BFF0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_get_msg(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DA74: using guessed type int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD);

//----- (1007C020) --------------------------------------------------------
__int16 __cdecl sub_1007C020(int a1)
{
  __int16 v1; // si@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_run_state(a1);
  SYS_exit_krnl();
  return v1;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DA7A: using guessed type int __cdecl TSK_pvg_get_run_state(_DWORD);

//----- (1007C040) --------------------------------------------------------
int sub_1007C040()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_timer();
  SYS_exit_krnl();
  return v0;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DA80: using guessed type int TSK_pvg_get_timer(void);

//----- (1007C060) --------------------------------------------------------
int __cdecl sub_1007C060(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_get_tsk_info(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DA86: using guessed type int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1007C0A0) --------------------------------------------------------
int __cdecl sub_1007C0A0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_kill_process(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DA92: using guessed type int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1007C0D0) --------------------------------------------------------
int __cdecl sub_1007C0D0(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_proc_status(a1);
  SYS_exit_krnl();
  return v1;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DA98: using guessed type int __cdecl TSK_pvg_proc_status(_DWORD);

//----- (1007C0F0) --------------------------------------------------------
int __cdecl sub_1007C0F0(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_release_smphr(a1);
  SYS_exit_krnl();
  return v1;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DA9E: using guessed type int __cdecl TSK_pvg_release_smphr(_DWORD);

//----- (1007C110) --------------------------------------------------------
int __cdecl sub_1007C110(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_reserve_smphr(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DAA4: using guessed type int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD);

//----- (1007C140) --------------------------------------------------------
int __cdecl sub_1007C140(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_evnt(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DAAA: using guessed type int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD);

//----- (1007C170) --------------------------------------------------------
int __cdecl sub_1007C170(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_send_msg(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DAB0: using guessed type int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1007C1A0) --------------------------------------------------------
int __cdecl sub_1007C1A0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_msg_ex(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DAB6: using guessed type int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD);

//----- (1007C1D0) --------------------------------------------------------
int __cdecl sub_1007C1D0(int a1)
{
  SYS_enter_krnl();
  TSK_pvg_set_proc_status(a1);
  return SYS_exit_krnl();
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DABC: using guessed type int __cdecl TSK_pvg_set_proc_status(_DWORD);

//----- (1007C1F0) --------------------------------------------------------
int __cdecl sub_1007C1F0(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_suspend(a1);
  SYS_exit_krnl();
  return v1;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DAC2: using guessed type int __cdecl TSK_pvg_suspend(_DWORD);

//----- (1007C210) --------------------------------------------------------
char __cdecl sub_1007C210(int a1, int a2)
{
  unsigned int v2; // esi@1
  char result; // al@4

  v2 = a2 + sub_1007C040();
  if ( sub_1007C0D0(a1) == 5 )
    goto LABEL_4;
  while ( sub_1007C040() < v2 )
  {
    sub_1007C1F0(20);
    if ( sub_1007C0D0(a1) == 5 )
      goto LABEL_4;
  }
  if ( sub_1007C0D0(a1) == 5 )
  {
LABEL_4:
    result = 1;
  }
  else
  {
    sub_10042930("..\\lib\\acl\\tsk\\tsk_usr.c", 1769, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1007C280) --------------------------------------------------------
int __cdecl sub_1007C280(_BYTE *a1)
{
  int v1; // edi@1
  int v2; // eax@2
  char v4; // [sp+8h] [bp-4h]@2

  SYS_enter_krnl();
  v1 = TSK_pvg_wait_evnt(a1);
  SYS_exit_krnl();
  if ( *a1 & 0x20 )
  {
    v2 = sub_1007BFD0();
    sub_1007C060((int)&v4, 5, v2, 4);
  }
  return v1;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DAC8: using guessed type int __cdecl TSK_pvg_wait_evnt(_DWORD);

//----- (1007C2C0) --------------------------------------------------------
int __cdecl sub_1007C2C0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) != 1 && !a1 )
    result = sub_1007C0F0(a2);
  return result;
}
// 10092A1C: using guessed type void *tsk_app_hdr_ptr;

//----- (1007C2F0) --------------------------------------------------------
int __cdecl sub_1007C2F0(int a1, int a2)
{
  int result; // eax@2

  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) == 1 )
    result = 0;
  else
    result = sub_1007C110(a1, a2);
  return result;
}
// 10092A1C: using guessed type void *tsk_app_hdr_ptr;

//----- (1007C310) --------------------------------------------------------
int __cdecl sub_1007C310(int a1)
{
  int v1; // ecx@1
  int result; // eax@1

  v1 = 0;
  result = 42066;
  while ( dword_1016C080[2 * v1] != a1 )
  {
    if ( (unsigned int)++v1 >= 0xA5 )
      return result;
  }
  return dword_1016C084[2 * v1];
}
// 1016C080: using guessed type int dword_1016C080[];
// 1016C084: using guessed type int dword_1016C084[];

//----- (1007C360) --------------------------------------------------------
unsigned int __cdecl sub_1007C360(unsigned int a1)
{
  unsigned int result; // eax@1

  result = 43;
  if ( a1 < 0xA452 )
    result = (unsigned __int16)a1 / 0x3E8u;
  return result;
}

//----- (1007C3B0) --------------------------------------------------------
int __cdecl sub_1007C3B0(int a1, int a2, int a3)
{
  return reg_read(a1, a2, a3, 0);
}
// 1007DAE0: using guessed type int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1007C3D0) --------------------------------------------------------
int __cdecl sub_1007C3D0(int a1, int a2, __int16 a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+8h] [bp-8h]@1

  v7 = 0;
  *(_DWORD *)a5 = 0;
  LOWORD(v7) = a3;
  *(_DWORD *)(a5 + 4) = -1;
  return reg_read_from_xml(a1, &v6, a4, a2, v7, a5);
}
// 1007DAE6: using guessed type int __cdecl reg_read_from_xml(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1007C430) --------------------------------------------------------
char __cdecl sub_1007C430(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_1007C3B0(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10042930("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1255, 1, 0);
  return v3;
}

//----- (1007C470) --------------------------------------------------------
int __cdecl sub_1007C470(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // esi@1

  result = sub_1007C3B0(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    result = v5;
  }
  return result;
}

//----- (1007C4B0) --------------------------------------------------------
int __cdecl sub_1007C4B0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_1007C3B0(a1 | 0x20000, a2, a3);
  if ( result == -46 )
    result = 0;
  return result;
}

//----- (1007C4E0) --------------------------------------------------------
int __cdecl sub_1007C4E0(int a1, int a2, int a3)
{
  return sub_1007C4B0(a1 | 0x40000, a2, a3);
}

//----- (1007C500) --------------------------------------------------------
int __cdecl sub_1007C500(int a1, int a2, int a3)
{
  return reg_write(a1, a2, a3, 0);
}
// 1007DAEC: using guessed type int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1007C520) --------------------------------------------------------
int __cdecl sub_1007C520(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // eax@2
  int result; // eax@4
  int v6; // [sp+10h] [bp-4h]@1

  v6 = sub_1007C500(a1, a2, a3);
  v3 = 0;
  if ( (unsigned __int8)sub_1007D4E0() )
  {
    v4 = sub_1007C310(a1);
    if ( v4 != 42066 )
      v3 = sub_1007C500(v4, a2, a3);
  }
  result = v6;
  if ( !v6 )
    result = v3;
  return result;
}
// 1007D4E0: using guessed type int sub_1007D4E0(void);

//----- (1007C580) --------------------------------------------------------
int __cdecl sub_1007C580(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  result = sub_1007C520(a1, a2, a3);
  v4 = result;
  if ( result )
  {
    sub_10042930("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1742, 1, 0);
    result = v4;
  }
  return result;
}

//----- (1007C5C0) --------------------------------------------------------
int __cdecl sub_1007C5C0(int a1, int a2, int a3, int a4)
{
  return reg_write(a1 | 0x10000, a2, a3, a4);
}
// 1007DAEC: using guessed type int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1007C5E0) --------------------------------------------------------
char __cdecl sub_1007C5E0(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_1007C500(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10042930("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1826, 1, 0);
  return v3;
}

//----- (1007C650) --------------------------------------------------------
int __cdecl sub_1007C650(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // edi@1

  result = sub_1007C3B0(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    sub_1007C500(a1, (int)a4, a3);
    result = v5;
  }
  return result;
}

//----- (1007C6B0) --------------------------------------------------------
__int16 __cdecl sub_1007C6B0(int a1, int a2, int a3, int a4)
{
  __int16 v4; // si@1

  SYS_enter_krnl();
  v4 = HWM_pvg_read_rgn(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DB04: using guessed type int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1007C6E0) --------------------------------------------------------
int __cdecl sub_1007C6E0(char a1)
{
  int result; // eax@1
  int v2; // ecx@1

  result = 0xFFFF;
  v2 = 0;
  while ( byte_101691D0[8 * v2] != a1 )
  {
    if ( (unsigned int)++v2 >= 0x1A )
      goto LABEL_6;
  }
  result = (unsigned __int16)word_101691D2[4 * v2];
LABEL_6:
  if ( a1 == 10 )
  {
    sub_1007C3B0(6585, (int)&a1, 1);
    result = (a1 != 1) + 37;
  }
  return result;
}
// 101691D2: using guessed type __int16 word_101691D2[];

//----- (1007C760) --------------------------------------------------------
__int16 __cdecl sub_1007C760(int a1, _DWORD *a2, _BYTE *a3)
{
  __int16 result; // ax@1
  char v4; // [sp+8h] [bp-ECh]@1
  unsigned __int8 v5; // [sp+Ah] [bp-EAh]@1
  int v6; // [sp+10h] [bp-E4h]@1

  j_HWM_pvg_rgn_get_info(a1, &v4);
  result = v5;
  *a2 = v6;
  *a3 = 2;
  return result;
}
// 1007C740: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (1007C7C0) --------------------------------------------------------
__int16 __cdecl sub_1007C7C0(int a1, _DWORD *a2)
{
  int v2; // ecx@0
  int v4; // [sp-2h] [bp-4h]@1

  v4 = v2;
  return sub_1007C760(a1, a2, (_BYTE *)&v4 + 3);
}

//----- (1007C870) --------------------------------------------------------
int sub_1007C870()
{
  int result; // eax@2

  if ( sub_1007D4F0() )
    result = j_HWM_pvg_get_anlg_outp(4);
  else
    result = j_HWM_pvg_get_anlg_outp(0);
  return result;
}
// 1007C7E0: using guessed type int __cdecl j_HWM_pvg_get_anlg_outp(_DWORD);

//----- (1007C890) --------------------------------------------------------
int __cdecl sub_1007C890(int a1, int a2)
{
  int v2; // esi@3

  if ( *(_DWORD *)(a1 + 8) < 0 )
    sub_10042930("..\\lib\\acl\\kernel\\mem_usr_share.c", 127, 0, 0);
  v2 = j_mem_unmap(a2 - 12, *(_DWORD *)(a1 + 8) + 12);
  if ( v2 )
    sub_10042930("..\\lib\\acl\\kernel\\mem_usr_share.c", 132, 1, 0);
  return v2;
}
// 1007D510: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (1007C8F0) --------------------------------------------------------
signed int __cdecl sub_1007C8F0(int a1)
{
  unsigned int v1; // eax@1
  signed int result; // eax@3

  v1 = **(_DWORD **)(a1 + 16);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    if ( *(_BYTE *)(v1 - 3) || *(_BYTE *)(a1 + 4) & 8 )
    {
      if ( *(_BYTE *)(a1 + 4) & 1 )
      {
        *(_BYTE *)(v1 - 3) = 0;
        result = 1;
      }
      else
      {
        sub_10042930("..\\lib\\acl\\kernel\\mem_usr_share.c", 474, 1, 0);
        result = 0;
      }
    }
    else
    {
      sub_10042930("..\\lib\\acl\\kernel\\mem_usr_share.c", 465, 1, 0);
      result = 1;
    }
  }
  else
  {
    sub_10042930("..\\lib\\acl\\kernel\\mem_usr_share.c", 455, 1, 0);
    result = 0;
  }
  return result;
}

//----- (1007C970) --------------------------------------------------------
int __usercall sub_1007C970@<eax>(const char **a1@<esi>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // edi@2
  char v3; // ST28_1@2
  unsigned int v4; // eax@5
  char *v5; // edi@9
  char v6; // al@10
  unsigned int v7; // eax@12
  char v8; // ST28_1@12
  signed int v9; // ebx@15
  int v10; // eax@19
  int result; // eax@47
  unsigned int v12; // [sp+Ch] [bp-98h]@1
  int v13; // [sp+14h] [bp-90h]@29
  char v14; // [sp+1Dh] [bp-87h]@30
  char v15; // [sp+1Fh] [bp-85h]@9
  char v16; // [sp+20h] [bp-84h]@8

  v1 = 0;
  v12 = 0;
  if ( *((_BYTE *)a1 + 4) & 2 )
  {
    v2 = j_FIL_vfs_open(*a1, 4, 0);
    v3 = 4;
  }
  else
  {
    strncpy(&v16, *a1, 0x7Du);
    if ( !(*((_BYTE *)a1 + 4) & 8) )
    {
      v5 = &v15;
      do
        v6 = (v5++)[1];
      while ( v6 );
      *(_DWORD *)v5 = 7368052;
    }
    v12 = j_FIL_vfs_open(*a1, 6, 1809);
    v7 = j_FIL_vfs_open(&v16, 14, 1809);
    v2 = v7;
    v8 = 6;
    if ( v7 >= 0xFFFFFFC2 || !v7 )
    {
      sub_10042930("..\\lib\\acl\\kernel\\mem_usr_share.c", 589, 1, 0);
      goto LABEL_39;
    }
    v9 = sub_1007D0A0(v7, 0, 2);
    if ( v9 < 0 )
    {
      sub_10042930("..\\lib\\acl\\kernel\\mem_usr_share.c", 602, 1, 0);
      goto LABEL_39;
    }
    if ( (signed int)a1[2] < 0 )
      sub_10042930("..\\lib\\acl\\kernel\\mem_usr_share.c", 610, 0, 0);
    v10 = (int)(a1[2] + 12);
    if ( v9 < v10 && sub_1007D0C0(v2, v10, (unsigned __int64)v10 >> 32) < 0 )
    {
      sub_10042930("..\\lib\\acl\\kernel\\mem_usr_share.c", 625, 1, 0);
      goto LABEL_39;
    }
  }
  if ( v2 >= 0xFFFFFFC2 )
    goto LABEL_42;
  if ( v2 )
  {
    v4 = ((int (__cdecl *)(unsigned int, _DWORD, const char *, _DWORD))j_FIL_vfs_mmap)(v2, 0, a1[2] + 12, 0);
    v1 = v4;
    if ( v4 < 0xFFFFFFC2 && v4 )
    {
      if ( !(*((_BYTE *)a1 + 4) & 1) )
      {
        if ( *(_BYTE *)(v4 + 9) || *(_BYTE *)(v4 + 8) != 56 )
        {
          sub_1007C890((int)a1, v4 + 12);
          v1 = 0;
        }
        goto LABEL_39;
      }
      *(_DWORD *)(v4 + 4) = sub_1007C040();
      if ( *((_BYTE *)a1 + 4) & 4 )
        memset((void *)(v1 + 12), (int)a1[3], (size_t)a1[2]);
      if ( v12 < 0xFFFFFFC2 && v12 )
      {
        if ( *((_BYTE *)a1 + 4) & 8 )
        {
          ++*(_DWORD *)v1;
        }
        else if ( sub_1007CED0(v12, &v13, 12) == 12 )
        {
          *(_DWORD *)v1 = ++v13;
          v14 = 1;
          *(_BYTE *)(v1 + 9) = 1;
          if ( sub_1007D050(v12, (int)&v13, 12, 0) != 12 )
          {
            sub_10042930("..\\lib\\acl\\kernel\\mem_usr_share.c", 725, 1, 0);
            goto LABEL_39;
          }
        }
      }
      else
      {
        *(_BYTE *)(v1 + 9) = 1;
        *(_DWORD *)v1 = 1;
      }
      *(_BYTE *)(v1 + 8) = 56;
      if ( !(*((_BYTE *)a1 + 4) & 8) && j_FIL_vfs_rename(&v16, *a1) )
        sub_10042930("..\\lib\\acl\\kernel\\mem_usr_share.c", 759, 1, 0);
      goto LABEL_39;
    }
    sub_10042930("..\\lib\\acl\\kernel\\mem_usr_share.c", 664, 0, 0);
  }
LABEL_39:
  if ( v2 < 0xFFFFFFC2 && v2 )
    sub_1007CE00(v2);
LABEL_42:
  if ( v12 < 0xFFFFFFC2 && v12 )
    sub_1007CE00(v12);
  if ( v1 < 0xFFFFFFC2 && v1 )
    result = v1 + 12;
  else
    result = v1;
  return result;
}
// 1007CEB0: using guessed type int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1007CEC0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1007CF90: using guessed type int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD);

//----- (1007CC70) --------------------------------------------------------
int __usercall sub_1007CC70@<eax>(int a1@<eax>, int a2@<ecx>)
{
  return j_mem_unmap(a2 - 12, a1 + 12);
}
// 1007D510: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (1007CC90) --------------------------------------------------------
signed int __cdecl sub_1007CC90(int a1)
{
  unsigned int v1; // eax@1
  char v2; // bl@1
  int *v3; // edi@6
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // ebp@6
  unsigned int v8; // eax@15

  v1 = **(_DWORD **)(a1 + 16);
  v2 = 0;
  if ( v1 != -858993460 && (v1 < 0xFFFFFFC2 && v1 || v1 == -15) )
  {
    if ( v1 < 0xFFFFFFC2 && v1 && !*(_BYTE *)(v1 - 3) )
      return 1;
  }
  else
  {
    sub_10042930("..\\lib\\acl\\kernel\\mem_usr_share.c", 211, 0, *(char **)a1);
    **(_DWORD **)(a1 + 16) = -15;
  }
  v3 = *(int **)(a1 + 16);
  v4 = sub_1007C2F0(81, 5000);
  v5 = *v3;
  v6 = v4;
  if ( (unsigned int)*v3 < 0xFFFFFFC2 && v5 )
  {
    if ( !*(_BYTE *)(v5 - 3) )
    {
      sub_1007C2C0(v4, 81);
      return 1;
    }
    *v3 = -15;
    sub_1007CC70(*(_DWORD *)(a1 + 8), v5);
  }
  v8 = sub_1007C970((const char **)a1);
  if ( v8 < 0xFFFFFFC2 && v8 )
  {
    *v3 = v8;
    if ( !*(_BYTE *)(v8 - 3) )
      v2 = 1;
  }
  sub_1007C2C0(v6, 81);
  return (unsigned __int8)v2;
}

//----- (1007CD60) --------------------------------------------------------
int __cdecl sub_1007CD60(LONG Value)
{
  char v1; // al@1
  int result; // eax@3
  int v3; // edi@3
  unsigned __int32 v4; // eax@5
  int v5; // ebx@5

  v1 = *(_BYTE *)(Value + 4);
  if ( v1 & 2 || !(v1 & 1) )
  {
    sub_10042930("..\\lib\\acl\\kernel\\mem_usr_share.c", 360, 1, 0);
    result = 0;
  }
  else
  {
    result = sub_1007C970((const char **)Value);
    v3 = result;
    if ( (unsigned int)result < 0xFFFFFFC2 && result )
    {
      v4 = InterlockedExchange(*(volatile LONG **)(Value + 16), result);
      v5 = v4;
      if ( v4 < 0xFFFFFFC2 && v4 )
      {
        if ( *(_DWORD *)(Value + 8) < 0 )
          sub_10042930("..\\lib\\acl\\kernel\\mem_usr_share.c", 388, 0, 0);
        sub_1007CC70(*(_DWORD *)(Value + 8), v5);
      }
      result = v3;
    }
  }
  return result;
}

//----- (1007CE00) --------------------------------------------------------
signed int __cdecl sub_1007CE00(unsigned int a1)
{
  signed int result; // eax@4
  int v2; // eax@8
  int v3; // edx@9

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_16;
  if ( (a1 & 3) == 1 )
    return sub_10041EF0(a1);
  if ( a1 && (a1 & 3) == 2 )
  {
    v2 = 0;
    if ( !dword_1031F848 )
      goto LABEL_11;
    while ( 1 )
    {
      v3 = dword_1031F850[v2];
      if ( *(_DWORD *)v3 == a1 )
        break;
      if ( ++v2 >= (unsigned int)dword_1031F848 )
        goto LABEL_11;
    }
    if ( v2 != -1 )
    {
      sub_1007D520(
        v2,
        *(_DWORD *)(dword_1031F850[v2] + 12),
        *(_DWORD *)(v3 + 16),
        *(_BYTE *)(v3 + 32),
        *(_WORD *)(v3 + 20),
        *(_DWORD *)(v3 + 4));
      result = sub_1007CE00(a1 & 0xFFFFFFFC);
    }
    else
    {
LABEL_11:
      result = -6;
    }
  }
  else
  {
LABEL_16:
    result = FIL_vfs_close();
  }
  return result;
}
// 1007DB52: using guessed type int FIL_vfs_close(void);
// 1031F848: using guessed type int dword_1031F848;
// 1031F850: using guessed type int dword_1031F850[];

//----- (1007CE60) --------------------------------------------------------
int __cdecl sub_1007CE60(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-1Ch]@1
  __int64 v7; // [sp+4h] [bp-18h]@1
  __int64 v8; // [sp+10h] [bp-Ch]@1

  v7 = a2;
  v8 = a4;
  return FIL_vfs_memmove_swi(&v6, a1, v7, HIDWORD(v7), a3, v8, HIDWORD(v8), a5);
}
// 1007DB64: using guessed type int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1007CED0) --------------------------------------------------------
signed int __cdecl sub_1007CED0(unsigned int a1, void *a2, int a3)
{
  unsigned int v3; // eax@4
  signed int result; // eax@4
  int v5; // eax@7

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
  {
    v3 = sub_10050A40(a1);
    return sub_10052450(v3, (int)a2, a3);
  }
  if ( a1 && (a1 & 3) == 2 )
  {
    v5 = sub_1007D0A0(a1 & 0xFFFFFFFC, 0, 1);
    result = sub_1007D8C0(a1, a2, a3, v5, (unsigned __int64)v5 >> 32);
  }
  else
  {
LABEL_11:
    result = FIL_vfs_read();
  }
  return result;
}
// 1007DB76: using guessed type int FIL_vfs_read(void);

//----- (1007CF10) --------------------------------------------------------
signed int __cdecl sub_1007CF10(unsigned int a1, void *a2, int a3, int a4, int a5)
{
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
    return sub_10041F30(a1, (int)a2, a3, a4);
  if ( a1 && (a1 & 3) == 2 )
    result = sub_1007D8C0(a1, a2, a3, a4, a5);
  else
LABEL_11:
    result = FIL_vfs_read_ofst(a1, a2, a3, &a4);
  return result;
}
// 1007DB7C: using guessed type int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1007CFA0) --------------------------------------------------------
signed int __cdecl sub_1007CFA0(unsigned int a1, int a2, int a3, int a4)
{
  signed int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = sub_10041F90(a1, a2, a4);
  else
    result = FIL_vfs_seek(a1 & 0xFFFFFFFC, a2, a3, a4);
  return result;
}
// 1007DB88: using guessed type int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1007CFF0) --------------------------------------------------------
__int64 __cdecl sub_1007CFF0(int a1)
{
  return FIL_vfs_size(a1 & 0xFFFFFFFC);
}
// 1007DB8E: using guessed type int __cdecl FIL_vfs_size(_DWORD);

//----- (1007D020) --------------------------------------------------------
int __cdecl sub_1007D020(int a1, int a2, int a3)
{
  return FIL_vfs_truncate(a1, a2, a3);
}
// 1007DB9A: using guessed type int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD);

//----- (1007D050) --------------------------------------------------------
int __cdecl sub_1007D050(int a1, int a2, int a3, char a4)
{
  return FIL_vfs_write_ofst(a1, a2, a3, &a4);
}
// 1007DBA6: using guessed type int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1007D070) --------------------------------------------------------
char __cdecl sub_1007D070(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 516, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_1007CE00(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1007CEC0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1007D0A0) --------------------------------------------------------
signed int __cdecl sub_1007D0A0(unsigned int a1, int a2, int a3)
{
  return sub_1007CFA0(a1, a2, (unsigned __int64)a2 >> 32, a3);
}

//----- (1007D0C0) --------------------------------------------------------
int __cdecl sub_1007D0C0(int a1, int a2, int a3)
{
  return sub_1007D020(a1, a2, a3);
}

//----- (1007D0E0) --------------------------------------------------------
int __cdecl sub_1007D0E0(int a1, int a2)
{
  void *v2; // ecx@0
  int result; // eax@3
  unsigned __int8 v4; // [sp+4h] [bp-40h]@2

  if ( sub_100429D0(v2) == a1 || j_HWM_pvg_hsdb_get_router_entry(a1, &v4) )
    result = 0;
  else
    result = a2 + 7 * v4;
  return result;
}
// 1007C820: using guessed type int __cdecl j_HWM_pvg_hsdb_get_router_entry(_DWORD, _DWORD);

//----- (1007D150) --------------------------------------------------------
int __cdecl sub_1007D150(char a1)
{
  int result; // eax@1
  int v2; // ecx@1

  result = -1;
  v2 = 0;
  while ( byte_10169948[8 * v2] != a1 )
  {
    if ( (unsigned int)++v2 >= 8 )
      return result;
  }
  return dword_1016994C[2 * v2];
}
// 1016994C: using guessed type int dword_1016994C[];

//----- (1007D180) --------------------------------------------------------
void __cdecl sub_1007D180(int a1, _BYTE *a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_get(a1, a2);
  SYS_exit_krnl();
  sub_1007DA10(a1, a2);
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DBAC: using guessed type int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD);

//----- (1007D1B0) --------------------------------------------------------
int __cdecl sub_1007D1B0(int a1, int a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_set(a1, a2);
  return SYS_exit_krnl();
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DBB2: using guessed type int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD);

//----- (1007D210) --------------------------------------------------------
int __cdecl sub_1007D210(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_recv_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DBD0: using guessed type int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD);

//----- (1007D260) --------------------------------------------------------
int __cdecl sub_1007D260(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_send_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 1007DA38: using guessed type int SYS_exit_krnl(void);
// 1007DA44: using guessed type int SYS_enter_krnl(void);
// 1007DBD6: using guessed type int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD);

//----- (1007D2D0) --------------------------------------------------------
int __cdecl sub_1007D2D0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100429D0(v1);
  a1 = v2;
  v3 = sub_10043FF0(&a1, 4u, (int)&unk_1016A3D8, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1016A3DC[2 * v3];
}
// 1016A3DC: using guessed type int dword_1016A3DC[];

//----- (1007D310) --------------------------------------------------------
int __cdecl sub_1007D310(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100429D0(v1);
  a1 = v2;
  v3 = sub_10043FF0(&a1, 4u, (int)&unk_1016A410, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1016A414[2 * v3];
}
// 1016A414: using guessed type int dword_1016A414[];

//----- (1007D350) --------------------------------------------------------
int __cdecl sub_1007D350(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100429D0(v1);
  a1 = v2;
  v3 = sub_10043FF0(&a1, 4u, (int)&unk_1016A448, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1016A44C[2 * v3];
}
// 1016A44C: using guessed type int dword_1016A44C[];

//----- (1007D390) --------------------------------------------------------
int __cdecl sub_1007D390(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100429D0(v1);
  a1 = v2;
  v3 = sub_10043FF0(&a1, 4u, (int)&unk_1016A480, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1016A484[2 * v3];
}
// 1016A484: using guessed type int dword_1016A484[];

//----- (1007D3D0) --------------------------------------------------------
int __cdecl sub_1007D3D0(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // eax@2
  int v6; // eax@8

  result = 0;
  if ( a1 )
  {
    v5 = sub_1007D310(a4);
    result = sub_1007C3B0(v5, a1, 104);
  }
  if ( a2 && !result )
    result = sub_1007C3B0(3532, a2, 2);
  if ( a3 )
  {
    if ( !result )
    {
      v6 = sub_1007D2D0(a4);
      result = sub_1007C3B0(v6, a3, 6);
    }
  }
  return result;
}

//----- (1007D440) --------------------------------------------------------
int __cdecl sub_1007D440(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  int v5; // eax@3
  int v6; // eax@6
  int v7; // eax@7

  result = 0;
  if ( a1 )
  {
    v4 = sub_1007D390(a3);
    result = sub_1007C3B0(v4, a1, 64);
    if ( result == -7 )
    {
      sub_1007C1F0(100);
      v5 = sub_1007D390(a3);
      result = sub_1007C3B0(v5, a1, 64);
    }
  }
  if ( a2 && !result )
  {
    v6 = sub_1007D350(a3);
    result = sub_1007C3B0(v6, a2, 8);
    if ( result == -7 )
    {
      sub_1007C1F0(100);
      v7 = sub_1007D350(a3);
      result = sub_1007C3B0(v7, a2, 8);
    }
  }
  return result;
}

//----- (1007D4F0) --------------------------------------------------------
bool sub_1007D4F0()
{
  unsigned int v0; // eax@1

  v0 = j_HWM_pvg_read_reg(0);
  return v0 >= 0x17 && (v0 <= 0x18 || v0 == 40);
}
// 1007C860: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1007D520) --------------------------------------------------------
unsigned int __cdecl sub_1007D520(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6)
{
  size_t v6; // ebp@1
  int *v7; // esi@1
  size_t v8; // ebx@1
  int v9; // edx@1
  unsigned int v10; // edi@1
  int v11; // ebx@2
  int v12; // edx@3
  int *v13; // ebp@3
  int v14; // eax@3
  int v15; // eax@3
  unsigned int result; // eax@4
  void **v17; // [sp+10h] [bp-Ch]@1
  void **v18; // [sp+20h] [bp+4h]@1

  v6 = 8 * a5;
  v7 = &dword_1031F850[a1];
  v8 = 32 * (a3 / (1 << a4));
  v9 = a2 - v8 - v6;
  *v7 = v9 + a3 - 52;
  v17 = (void **)&dword_1031F808[a1];
  dword_1031F808[a1] = a3 + v9;
  dword_1031F7C8[a1] = a3 + a2 - v8;
  v18 = (void **)&dword_1031F7C8[a1];
  memset((void *)(v9 + a3 - 52), 0, 0x34u);
  memset(*v17, 0, v6);
  memset(*v18, 0, v8);
  *(_DWORD *)(*v7 + 24) = 1 << a4;
  *(_DWORD *)(*v7 + 28) = ~(*(_DWORD *)(*v7 + 24) - 1);
  *(_BYTE *)(*v7 + 32) = a4;
  *(_DWORD *)(*v7 + 12) = a2;
  *(_DWORD *)(*v7 + 16) = a3;
  *(_DWORD *)(*v7 + 8) = a3 / (1 << a4) - (v8 + v6 + 52) / (1 << a4) - 1;
  *(_DWORD *)(*v7 + 4) = a6;
  *(_WORD *)(*v7 + 20) = a5;
  *(_DWORD *)*v7 = -1;
  *(_DWORD *)(*v7 + 36) = *v7 + 36;
  *(_DWORD *)(*v7 + 40) = *v7 + 36;
  *(_DWORD *)(*v7 + 44) = *v7 + 44;
  *(_DWORD *)(*v7 + 48) = *v7 + 44;
  v10 = 0;
  if ( *(_DWORD *)(*v7 + 8) )
  {
    v11 = 0;
    do
    {
      v12 = *v7;
      v13 = *(int **)(*v7 + 40);
      v14 = (int)*v18 + v11;
      *(_DWORD *)(v12 + 40) = v14;
      *(_DWORD *)v14 = v12 + 36;
      *(_DWORD *)(v14 + 4) = v13;
      *v13 = v14;
      v15 = a2 + v10++ * *(_DWORD *)(*v7 + 24);
      *(_DWORD *)((char *)*v18 + v11 + 28) = v15;
      v11 += 32;
    }
    while ( v10 < *(_DWORD *)(*v7 + 8) );
  }
  result = 0;
  if ( *(_WORD *)(*v7 + 20) )
  {
    do
    {
      *((_DWORD *)*v17 + 2 * result) = (char *)*v17 + 8 * result;
      *((_DWORD *)*v17 + 2 * result + 1) = (char *)*v17 + 8 * result;
      ++result;
    }
    while ( result < *(_WORD *)(*v7 + 20) );
  }
  return result;
}
// 1031F808: using guessed type int dword_1031F808[];
// 1031F850: using guessed type int dword_1031F850[];

//----- (1007D6D0) --------------------------------------------------------
int __usercall sub_1007D6D0@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int *v2; // ecx@1
  int result; // eax@2
  int v4; // eax@3
  int v5; // ecx@3
  _DWORD *v6; // edx@3
  int v7; // ecx@3
  _DWORD *v8; // edx@3
  int v9; // ecx@3
  int v10; // edx@3

  v1 = dword_1031F850[a1];
  v2 = (int *)(v1 + 36);
  if ( (int *)*v2 == v2 )
  {
    v4 = *(_DWORD *)(v1 + 44);
    v5 = *(_DWORD *)(v4 - 8);
    v6 = *(_DWORD **)(v4 - 4);
    result = v4 - 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v7 = *(_DWORD *)(result + 8);
    v8 = *(_DWORD **)(result + 12);
    *(_DWORD *)(v7 + 4) = v8;
    *v8 = v7;
    v9 = dword_1031F850[a1];
    v10 = *(_DWORD *)(v9 + 36);
    v9 += 36;
    *(_DWORD *)(v10 + 4) = result;
    *(_DWORD *)result = v10;
    *(_DWORD *)(result + 4) = v9;
    *(_DWORD *)v9 = result;
  }
  else
  {
    result = *v2;
  }
  return result;
}
// 1031F850: using guessed type int dword_1031F850[];

//----- (1007D780) --------------------------------------------------------
int __cdecl sub_1007D780(int a1, unsigned __int64 a2)
{
  int v2; // edi@1
  int *v3; // ebx@1
  signed int v4; // eax@1
  _DWORD *v5; // ecx@2
  int v6; // eax@2
  int *v7; // eax@2
  int v8; // ecx@2
  _DWORD *v9; // edx@2
  int v10; // eax@2
  int v11; // ecx@2
  int result; // eax@2

  v2 = sub_1007D6D0(a1);
  v3 = &dword_1031F850[a1];
  v4 = sub_1007CF10(
         *(_DWORD *)dword_1031F850[a1] & 0xFFFFFFFC,
         *(void **)(v2 + 28),
         *(_DWORD *)(dword_1031F850[a1] + 24),
         a2,
         SHIDWORD(a2));
  if ( v4 <= 0 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD **)(v2 + 4);
    *(_WORD *)(v2 + 24) = v4;
    v6 = *(_DWORD *)v2;
    *(_QWORD *)(v2 + 16) = a2;
    *(_DWORD *)(v6 + 4) = v5;
    *v5 = v6;
    v7 = (int *)(dword_1031F808[a1] + 8 * ((unsigned int)(a2 >> *(_BYTE *)(*v3 + 32)) % *(_WORD *)(*v3 + 20)));
    v8 = *v7;
    *(_DWORD *)(v8 + 4) = v2;
    *(_DWORD *)(v2 + 4) = v7;
    *(_DWORD *)v2 = v8;
    *v7 = v2;
    v9 = *(_DWORD **)(*v3 + 48);
    v10 = *v3 + 44;
    v11 = v2 + 8;
    *(_DWORD *)(v10 + 4) = v2 + 8;
    *(_DWORD *)v11 = v10;
    result = v2;
    *(_DWORD *)(v11 + 4) = v9;
    *v9 = v2 + 8;
  }
  return result;
}
// 1031F808: using guessed type int dword_1031F808[];
// 1031F850: using guessed type int dword_1031F850[];

//----- (1007D830) --------------------------------------------------------
int __usercall sub_1007D830@<eax>(int a1@<ebx>, unsigned __int64 a2)
{
  int *v2; // edi@1
  int *v3; // ecx@1
  int result; // eax@1
  int v5; // edx@5
  _DWORD *v6; // esi@5
  int v7; // ecx@5
  _DWORD *v8; // esi@5
  int v9; // edx@5

  v2 = &dword_1031F850[a1];
  v3 = (int *)(dword_1031F808[a1]
             + 8 * ((unsigned int)(a2 >> *(_BYTE *)(dword_1031F850[a1] + 32)) % *(_WORD *)(dword_1031F850[a1] + 20)));
  result = *v3;
  if ( (int *)*v3 == v3 )
  {
LABEL_4:
    result = sub_1007D780(a1, a2);
  }
  else
  {
    while ( *(_QWORD *)(result + 16) != a2 )
    {
      result = *(_DWORD *)result;
      if ( (int *)result == v3 )
        goto LABEL_4;
    }
    v5 = *(_DWORD *)(result + 8);
    v6 = *(_DWORD **)(result + 12);
    v7 = result + 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v8 = *(_DWORD **)(*v2 + 48);
    v9 = *v2 + 44;
    *(_DWORD *)(v9 + 4) = result + 8;
    *(_DWORD *)(v7 + 4) = v8;
    *(_DWORD *)v7 = v9;
    *v8 = result + 8;
  }
  return result;
}
// 1031F808: using guessed type int dword_1031F808[];
// 1031F850: using guessed type int dword_1031F850[];

//----- (1007D8C0) --------------------------------------------------------
unsigned int __cdecl sub_1007D8C0(int a1, void *a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // edx@2
  unsigned int result; // eax@4
  int v10; // eax@7
  int v11; // esi@10
  int v12; // eax@10
  int v13; // ecx@11
  unsigned int v14; // eax@11
  const void *v15; // ecx@11
  size_t v16; // esi@12
  int v17; // ecx@13
  int v18; // et0@17

  v5 = a3;
  v6 = 0;
  v7 = a4;
  if ( !dword_1031F848 )
    goto LABEL_24;
  while ( 1 )
  {
    v8 = dword_1031F850[v6];
    if ( *(_DWORD *)v8 == a1 )
      break;
    if ( ++v6 >= (unsigned int)dword_1031F848 )
      return -1;
  }
  if ( v6 != -1 )
  {
    v10 = *(_DWORD *)(v8 + 4);
    if ( v10 != 138 )
      sub_1007C110(v10, -1);
    if ( a3 )
    {
      while ( 1 )
      {
        v11 = v7 & ~*(_DWORD *)(dword_1031F850[v6] + 28);
        v12 = sub_1007D830(v6, (unsigned int)v7 & *(_DWORD *)(dword_1031F850[v6] + 28));
        if ( !v12 )
          break;
        v13 = *(_DWORD *)(v12 + 28);
        v14 = *(_WORD *)(v12 + 24) - v11;
        v15 = (const void *)(v11 + v13);
        if ( v5 <= v14 )
        {
          v16 = v5;
        }
        else
        {
          v16 = v14;
          if ( !v14 )
            goto LABEL_13;
        }
        memcpy(a2, v15, v16);
        v5 -= v16;
        v18 = (v16 + __PAIR__((unsigned int)a5, v7)) >> 32;
        v7 += v16;
        a5 = v18;
        a2 = (char *)a2 + v16;
        if ( !v5 )
          goto LABEL_13;
      }
      if ( *(_DWORD *)(dword_1031F850[v6] + 4) != 138 )
        sub_1007C0F0(*(_DWORD *)(dword_1031F850[v6] + 4));
      result = -1;
    }
    else
    {
LABEL_13:
      v17 = dword_1031F850[v6];
      if ( *(_DWORD *)(v17 + 4) != 138 )
        sub_1007C0F0(*(_DWORD *)(v17 + 4));
      result = a3 - v5;
    }
  }
  else
  {
LABEL_24:
    result = -1;
  }
  return result;
}
// 1031F848: using guessed type int dword_1031F848;
// 1031F850: using guessed type int dword_1031F850[];

//----- (1007DA10) --------------------------------------------------------
void __cdecl sub_1007DA10(__int16 a1, _BYTE *a2)
{
  void *v2; // ecx@0
  void *v3; // ecx@2

  if ( a1 == 29 && sub_10046060(v2) && sub_10046100(v3) != 1 )
    *a2 = 0;
}

//----- (10080408) --------------------------------------------------------
int __cdecl sub_10080408(int a1, int a2, char a3)
{
  return vscan_fn(sub_100885EF, a2, 0, &a3);
}
// 100803A0: using guessed type int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10081404) --------------------------------------------------------
int __cdecl sub_10081404(int a1, FILE *a2)
{
  FILE *v2; // esi@1
  int v3; // eax@1
  unsigned int v5; // eax@9
  int v6; // eax@15
  char *v7; // edi@15
  signed __int32 v8; // edi@15
  _BYTE *v9; // eax@20
  __int64 v10; // rax@23
  _WORD *v11; // [sp+4h] [bp-4h]@9

  v2 = a2;
  a2 = (FILE *)_fileno(a2);
  v3 = v2->_flag;
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    v2->_flag |= 0x20u;
    return -1;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v3 & 1 )
  {
    v2->_cnt = 0;
    if ( !(v3 & 0x10) )
    {
      v2->_flag = v3 | 0x20;
      return -1;
    }
    v2->_ptr = v2->_base;
    v2->_flag = v3 & 0xFFFFFFFE;
  }
  v5 = v2->_flag & 0xFFFFFFEF | 2;
  v2->_flag = v5;
  v2->_cnt = 0;
  v11 = 0;
  if ( !(v5 & 0x10C)
    && ((void **)v2 != sub_1008B1AE() + 8 && (void **)v2 != sub_1008B1AE() + 16 || !sub_1008B150((signed int)a2)) )
  {
    _getbuf(v2);
  }
  if ( v2->_flag & 0x108 )
  {
    v6 = (int)v2->_base;
    v7 = v2->_ptr;
    v2->_ptr = (char *)(v6 + 1);
    v8 = (signed __int32)&v7[-v6];
    v2->_cnt = v2->_bufsiz - 1;
    if ( v8 <= 0 )
    {
      if ( a2 == (FILE *)-1 || a2 == (FILE *)-2 )
        v9 = &unk_1017C2C0;
      else
        v9 = (_BYTE *)(dword_103380E0[(signed int)a2 >> 5] + (((unsigned __int8)a2 & 0x1F) << 6));
      if ( v9[4] & 0x20 )
      {
        v10 = _lseeki64((int)a2, 0i64, 2);
        if ( (HIDWORD(v10) & (unsigned int)v10) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v11 = sub_1008B030((int)a2, v6, v8);
    }
    *v2->_base = a1;
  }
  else
  {
    v8 = 1;
    v11 = sub_1008B030((int)a2, (int)&a1, 1u);
  }
  if ( v11 != (_WORD *)v8 )
  {
LABEL_27:
    v2->_flag |= 0x20u;
    return -1;
  }
  return (unsigned __int8)a1;
}
// 1008B10C: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 103380E0: using guessed type int dword_103380E0[];

//----- (10081F99) --------------------------------------------------------
int __cdecl sub_10081F99(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1031FBEC = a1;
  return result;
}
// 1031FBEC: using guessed type int dword_1031FBEC;

//----- (1008216C) --------------------------------------------------------
signed int __cdecl sub_1008216C(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_1031FBF4 )
  {
    *a1 = dword_1031FBF4;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1008209F: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1031FBF4: using guessed type int dword_1031FBF4;

//----- (100821A3) --------------------------------------------------------
signed int __cdecl sub_100821A3(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_1031FBF4 )
  {
    *a1 = dword_1031FC00;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1008209F: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1031FBF4: using guessed type int dword_1031FBF4;
// 1031FC00: using guessed type int dword_1031FC00;

//----- (10082DE9) --------------------------------------------------------
void sub_10082DE9()
{
  void **v0; // esi@1
  void *v1; // edi@2
  unsigned int i; // eax@3

  v0 = (void **)dword_103380E0;
  do
  {
    v1 = *v0;
    if ( *v0 )
    {
      for ( i = (unsigned int)v1 + 2048; (unsigned int)v1 < i; i = (unsigned int)*v0 + 2048 )
      {
        if ( *((_DWORD *)v1 + 2) )
          DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
        v1 = (char *)v1 + 64;
      }
      free(*v0);
      *v0 = 0;
    }
    ++v0;
  }
  while ( (signed int)v0 < (signed int)&dword_103381E0 );
}
// 103380E0: using guessed type int dword_103380E0[];
// 103381E0: using guessed type int dword_103381E0;

//----- (10083296) --------------------------------------------------------
int (*sub_10083296())(void)
{
  int (*result)(void); // eax@1
  int (**v1)(void); // esi@1

  result = (int (*)(void))&unk_1017A380;
  v1 = (int (**)(void))&unk_1017A380;
  if ( &unk_1017A380 < &unk_1017A380 )
  {
    do
    {
      result = *v1;
      if ( *v1 )
        result = (int (*)(void))result();
      ++v1;
    }
    while ( v1 < (int (**)(void))&unk_1017A380 );
  }
  return result;
}

//----- (100832BA) --------------------------------------------------------
void __cdecl sub_100832BA()
{
  void (**v0)(void); // esi@1

  v0 = (void (**)(void))&unk_1017A388;
  if ( &unk_1017A388 < &unk_1017A388 )
  {
    do
    {
      if ( *v0 )
        (*v0)();
      ++v0;
    }
    while ( v0 < (void (**)(void))&unk_1017A388 );
  }
}

//----- (100885EF) --------------------------------------------------------
int __cdecl sub_100885EF(FILE *a1, int a2, struct localeinfo_struct *a3, int a4)
{
  unsigned __int8 *v4; // edi@1
  int result; // eax@2
  int *v6; // edi@7
  _BYTE *v7; // eax@7
  int *v8; // edi@12
  _BYTE *v9; // eax@12
  unsigned __int8 v10; // al@16
  unsigned __int8 *v11; // edi@17
  int v12; // eax@19
  _WORD *v13; // esi@24
  int v14; // ebx@25
  int v15; // eax@25
  int v16; // ST10_4@25
  int v17; // ecx@25
  int v18; // eax@35
  unsigned __int8 v19; // al@59
  signed int v20; // ebx@62
  int v21; // eax@65
  int v22; // ecx@69
  int v23; // edi@79
  signed int v24; // ebx@82
  int v25; // ebx@84
  int i; // eax@90
  int v27; // eax@91
  int v28; // ecx@92
  int v29; // eax@96
  int j; // eax@98
  int v31; // eax@99
  int v32; // ecx@100
  int v33; // eax@106
  int v34; // ecx@107
  int v35; // ecx@108
  int v36; // eax@112
  int k; // eax@115
  int v38; // eax@116
  int v39; // ecx@117
  void *v40; // ST0C_4@124
  _WORD *v41; // ST08_4@124
  int v42; // ST04_4@124
  void (__cdecl *v43)(int, _WORD *, void *, struct localeinfo_struct *); // eax@124
  _WORD *v44; // edi@129
  int v45; // ST10_4@130
  int v46; // eax@132
  signed int v47; // eax@133
  _BYTE *v48; // edi@156
  unsigned __int8 *v49; // esi@156
  unsigned __int8 v50; // dl@159
  unsigned __int8 v51; // al@165
  unsigned int v52; // edi@168
  int v53; // edx@168
  unsigned int v54; // ecx@172
  unsigned int v55; // eax@172
  unsigned __int8 v56; // al@173
  int v57; // eax@181
  int v58; // ecx@181
  int v59; // eax@219
  int v60; // ST10_4@219
  int v61; // ecx@219
  unsigned int v62; // esi@222
  int v63; // eax@225
  int v64; // ST10_4@225
  int v65; // eax@238
  int v66; // ST10_4@238
  int v67; // ecx@238
  int v68; // edi@241
  int v69; // eax@244
  int v70; // ST10_4@244
  int v71; // ebx@265
  int v72; // eax@265
  int v73; // eax@267
  int v74; // ecx@267
  bool v75; // zf@275
  int v76; // [sp-4h] [bp-80h]@18
  int v77; // [sp-4h] [bp-80h]@94
  int v78; // [sp-4h] [bp-80h]@143
  int v79; // [sp-4h] [bp-80h]@266
  _WORD **v80; // [sp+Ch] [bp-70h]@0
  struct localeinfo_struct Locale; // [sp+10h] [bp-6Ch]@16
  int v82; // [sp+18h] [bp-64h]@288
  char v83; // [sp+1Ch] [bp-60h]@287
  wchar_t DstCh[2]; // [sp+20h] [bp-5Ch]@1
  _WORD **v85; // [sp+24h] [bp-58h]@1
  int v86; // [sp+28h] [bp-54h]@24
  char SrcCh; // [sp+2Ch] [bp-50h]@143
  char v88; // [sp+2Dh] [bp-4Fh]@144
  int v89; // [sp+30h] [bp-4Ch]@1
  int v90; // [sp+34h] [bp-48h]@24
  int v91; // [sp+38h] [bp-44h]@1
  unsigned __int8 v92; // [sp+3Fh] [bp-3Dh]@24
  int v93; // [sp+40h] [bp-3Ch]@16
  _WORD *v94; // [sp+44h] [bp-38h]@58
  unsigned __int64 v95; // [sp+48h] [bp-34h]@36
  int v96; // [sp+50h] [bp-2Ch]@24
  unsigned __int8 *v97; // [sp+54h] [bp-28h]@1
  void *v98; // [sp+58h] [bp-24h]@1
  int v99; // [sp+5Ch] [bp-20h]@62
  int v100; // [sp+60h] [bp-1Ch]@24
  char v101; // [sp+64h] [bp-18h]@24
  char v102; // [sp+65h] [bp-17h]@24
  char v103; // [sp+66h] [bp-16h]@24
  char v104; // [sp+67h] [bp-15h]@16
  FILE *v105; // [sp+68h] [bp-14h]@1
  char v106; // [sp+6Eh] [bp-Eh]@24
  char v107; // [sp+6Fh] [bp-Dh]@24
  int v108; // [sp+70h] [bp-Ch]@24
  char v109; // [sp+77h] [bp-5h]@24
  int v110; // [sp+78h] [bp-4h]@1
  char v111; // [sp+7Fh] [bp+3h]@24
  int v112; // [sp+80h] [bp+4h]@16
  char v113; // [sp+84h] [bp+8h]@1
  char v114[11]; // [sp+1E4h] [bp+168h]@140
  char v115; // [sp+1EFh] [bp+173h]@159

  v4 = (unsigned __int8 *)a2;
  v85 = (_WORD **)a4;
  v105 = a1;
  v97 = (unsigned __int8 *)a2;
  v98 = &v113;
  v89 = 350;
  v91 = 0;
  *(_DWORD *)DstCh = 0;
  v110 = 0;
  if ( !a2 || !a1 )
    goto LABEL_294;
  if ( a1->_flag & 0x40 )
    goto LABEL_16;
  if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
  {
    v7 = &unk_1017C2C0;
  }
  else
  {
    v6 = &dword_103380E0[_fileno(a1) >> 5];
    v7 = (_BYTE *)(*v6 + ((_fileno(a1) & 0x1F) << 6));
  }
  if ( v7[36] & 0x7F
    || (_fileno(a1) == -1 || _fileno(a1) == -2 ? (v9 = &unk_1017C2C0) : (v8 = &dword_103380E0[_fileno(a1) >> 5],
                                                                         v9 = (_BYTE *)(*v8 + ((_fileno(a1) & 0x1F) << 6))),
        v9[36] & 0x80) )
  {
LABEL_294:
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v4 = v97;
LABEL_16:
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a3);
  v10 = *v4;
  v75 = *v4 == 0;
  v104 = 0;
  v112 = 0;
  v93 = 0;
  if ( v75 )
    goto LABEL_289;
  v11 = v97;
  while ( 2 )
  {
    if ( isspace(v10) )
    {
      --v112;
      v12 = _whiteout(v105);
      if ( v12 != -1 )
        sub_1008EDEC(v12, v105);
      do
        ++v11;
      while ( isspace(*v11) );
      goto LABEL_273;
    }
    if ( *v11 != 37 )
    {
      ++v112;
      v71 = _inc(v76, v105);
      v72 = *v11++;
      v110 = v71;
      v97 = v11;
      if ( v72 == v71 )
      {
        if ( !isleadbyte((unsigned __int8)v71) )
          goto LABEL_269;
        ++v112;
        v73 = _inc(v79, v105);
        v74 = *v11++;
        v97 = v11;
        if ( v74 == v73 )
        {
          --v112;
          goto LABEL_269;
        }
        if ( v73 != -1 )
          sub_1008EDEC(v73, v105);
      }
      v75 = v71 == -1;
      goto LABEL_279;
    }
    v86 = 0;
    v92 = 0;
    v100 = 0;
    v96 = 0;
    v108 = 0;
    v101 = 0;
    v102 = 0;
    v107 = 0;
    v111 = 0;
    v103 = 0;
    v109 = 0;
    v106 = 1;
    v90 = 0;
    v13 = 0;
    do
    {
      v14 = *++v11;
      v15 = isdigit(v14);
      v17 = v16;
      if ( v15 )
      {
        ++v96;
        v108 = 10 * v108 + v14 - 48;
        continue;
      }
      if ( v14 > 78 )
      {
        if ( v14 == 104 )
        {
          --v106;
          --v109;
        }
        else
        {
          if ( v14 == 108 )
          {
            v18 = (int)(v11 + 1);
            if ( v11[1] == 108 )
              goto LABEL_36;
            ++v106;
          }
          else if ( v14 != 119 )
          {
            goto LABEL_50;
          }
          ++v109;
        }
      }
      else
      {
        if ( v14 == 78 )
          continue;
        if ( v14 == 42 )
        {
          ++v107;
          continue;
        }
        if ( v14 == 70 )
          continue;
        if ( v14 != 73 )
        {
          if ( v14 == 76 )
          {
            ++v106;
            continue;
          }
LABEL_50:
          ++v111;
          continue;
        }
        LOBYTE(v17) = v11[1];
        if ( (_BYTE)v17 == 54 )
        {
          v18 = (int)(v11 + 2);
          if ( v11[2] == 52 )
          {
LABEL_36:
            ++v90;
            v11 = (unsigned __int8 *)v18;
            v95 = 0i64;
            continue;
          }
        }
        if ( (_BYTE)v17 == 51 && v11[2] == 50 )
        {
          v11 += 2;
          continue;
        }
        if ( (_BYTE)v17 != 100 && (_BYTE)v17 != 105 && (_BYTE)v17 != 111 && (_BYTE)v17 != 120 && (_BYTE)v17 != 88 )
          goto LABEL_50;
      }
    }
    while ( !v111 );
    v97 = v11;
    if ( !v107 )
    {
      v13 = *v85;
      v80 = v85;
      ++v85;
    }
    v94 = v13;
    v111 = 0;
    if ( !v109 )
    {
      v19 = *v11;
      if ( *v11 == 83 || (v109 = -1, v19 == 67) )
        v109 = 1;
    }
    v99 = *v11 | 0x20;
    v20 = v99;
    if ( v99 != 110 )
    {
      if ( v99 == 99 || v99 == 123 )
      {
        ++v112;
        v21 = _inc(v17, v105);
      }
      else
      {
        v21 = _whiteout(v105);
      }
      v110 = v21;
      if ( v21 == -1 )
        goto LABEL_281;
      v13 = v94;
      v11 = v97;
    }
    v22 = v96;
    if ( v96 && !v108 )
      goto LABEL_275;
    if ( v20 > 111 )
    {
      if ( v20 == 112 )
      {
        v106 = 1;
      }
      else
      {
        if ( v20 == 115 )
        {
LABEL_127:
          if ( v109 > 0 )
            v103 = 1;
          goto LABEL_129;
        }
        if ( v20 != 117 )
        {
          if ( v20 == 120 )
            goto LABEL_82;
          if ( v20 != 123 )
            goto LABEL_151;
          if ( v109 > 0 )
            v103 = 1;
          v48 = v11 + 1;
          v49 = v48;
          if ( *v48 == 94 )
          {
            v49 = v48 + 1;
            v101 = -1;
          }
          memset(v114, 0, 0x20u);
          if ( *v49 == 93 )
          {
            v50 = 93;
            ++v49;
            v115 = 32;
          }
          else
          {
            v50 = v92;
          }
          while ( 1 )
          {
            v56 = *v49;
            if ( *v49 == 93 )
              break;
            ++v49;
            if ( v56 == 45 && v50 && (LOBYTE(v22) = *v49, *v49 != 93) )
            {
              ++v49;
              if ( v50 >= (unsigned __int8)v22 )
              {
                v51 = v50;
                v50 = v22;
              }
              else
              {
                v51 = v22;
              }
              if ( v50 <= v51 )
              {
                v52 = v50;
                v53 = (unsigned __int8)(v51 - v50 + 1);
                do
                {
                  v22 = v52 & 7;
                  v114[v52 >> 3] |= 1 << v22;
                  ++v52;
                  --v53;
                }
                while ( v53 );
                v20 = v99;
              }
              v50 = 0;
            }
            else
            {
              v54 = v56;
              v50 = v56;
              v55 = v54;
              v22 = v54 & 7;
              v114[v55 >> 3] |= 1 << v22;
              v20 = v99;
            }
          }
          v97 = v49;
          v13 = v94;
LABEL_129:
          --v112;
          v44 = v13;
          if ( v110 != -1 )
          {
            sub_1008EDEC(v110, v105);
            v22 = v45;
          }
          while ( 1 )
          {
            if ( v96 )
            {
              v46 = v108--;
              if ( !v46 )
                goto LABEL_200;
            }
            ++v112;
            v47 = _inc(v22, v105);
            v110 = v47;
            if ( v47 == -1 )
              goto LABEL_198;
            if ( v20 != 99 )
            {
              if ( v20 != 115 )
                goto LABEL_295;
              if ( v47 >= 9 && v47 <= 13 )
              {
LABEL_198:
                --v112;
                if ( v47 != -1 )
                  sub_1008EDEC(v47, v105);
LABEL_200:
                if ( v44 != v13 )
                {
                  if ( !v107 )
                  {
                    ++v93;
                    if ( v20 != 99 )
                    {
                      if ( v103 )
                        *v94 = 0;
                      else
                        *(_BYTE *)v94 = 0;
                    }
                  }
                  goto LABEL_264;
                }
                goto LABEL_281;
              }
              if ( v47 == 32 )
              {
LABEL_295:
                if ( v20 != 123 )
                  goto LABEL_198;
                v22 = v101 ^ v114[v47 >> 3];
                v20 = v99;
                if ( !((1 << (v47 & 7)) & v22) )
                  goto LABEL_198;
              }
            }
            if ( v107 )
            {
              v44 = (_WORD *)((char *)v44 + 1);
            }
            else
            {
              if ( v103 )
              {
                SrcCh = v47;
                if ( isleadbyte((unsigned __int8)v47) )
                {
                  ++v112;
                  v88 = _inc(v78, v105);
                }
                *(_DWORD *)DstCh = 63;
                _mbtowc_l(DstCh, &SrcCh, Locale.locinfo->mb_cur_max, &Locale);
                *v13 = DstCh[0];
                ++v13;
              }
              else
              {
                *(_BYTE *)v13 = v47;
                v13 = (_WORD *)((char *)v13 + 1);
              }
              v94 = v13;
            }
          }
        }
      }
LABEL_207:
      v24 = v110;
      if ( v110 == 45 )
      {
        v102 = 1;
      }
      else if ( v110 != 43 )
      {
        goto LABEL_215;
      }
      if ( !--v108 && v96 )
      {
        v111 = 1;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v96, v105);
      goto LABEL_214;
    }
    if ( v20 == 111 )
      goto LABEL_207;
    if ( v20 == 99 )
    {
      if ( !v96 )
      {
        ++v108;
        v96 = 1;
      }
      goto LABEL_127;
    }
    if ( v20 == 100 )
      goto LABEL_207;
    if ( v20 <= 100 )
      goto LABEL_151;
    if ( v20 <= 103 )
    {
      v25 = 0;
      if ( v110 == 45 )
      {
        *(_BYTE *)v98 = 45;
        v25 = 1;
        goto LABEL_87;
      }
      if ( v110 == 43 )
      {
LABEL_87:
        --v108;
        ++v112;
        v110 = _inc(v22, v105);
      }
      if ( !v96 )
        v108 = -1;
      for ( i = (unsigned __int8)v110; isdigit(i); i = (unsigned __int8)v110 )
      {
        v27 = v108--;
        if ( !v27 )
          break;
        ++v100;
        *((_BYTE *)v98 + v25++) = v110;
        if ( !__check_float_string(v25, &v113, (int)&v91) )
          goto LABEL_281;
        ++v112;
        v110 = _inc(v28, v105);
      }
      v101 = **(_BYTE **)Locale.locinfo->lconv;
      if ( v101 == (_BYTE)v110 )
      {
        v29 = v108--;
        if ( v29 )
        {
          ++v112;
          v110 = _inc(v77, v105);
          *((_BYTE *)v98 + v25++) = v101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          for ( j = (unsigned __int8)v110; isdigit(j); j = (unsigned __int8)v110 )
          {
            v31 = v108--;
            if ( !v31 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v32, v105);
          }
        }
      }
      if ( v100 && (v110 == 101 || v110 == 69) )
      {
        v33 = v108--;
        if ( v33 )
        {
          *((_BYTE *)v98 + v25++) = 101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          ++v112;
          v110 = _inc(v34, v105);
          if ( v110 == 45 )
          {
            *((_BYTE *)v98 + v25++) = 45;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
LABEL_112:
            v36 = v108--;
            if ( v36 )
            {
              ++v112;
              v110 = _inc(v35, v105);
            }
            else
            {
              v108 = 0;
            }
          }
          else if ( v110 == 43 )
          {
            goto LABEL_112;
          }
          for ( k = (unsigned __int8)v110; isdigit(k); k = (unsigned __int8)v110 )
          {
            v38 = v108--;
            if ( !v38 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v39, v105);
          }
        }
      }
      --v112;
      if ( v110 != -1 )
        sub_1008EDEC(v110, v105);
      if ( v100 )
      {
        if ( !v107 )
        {
          ++v93;
          v40 = v98;
          v41 = v94;
          *((_BYTE *)v98 + v25) = 0;
          v42 = v106 - 1;
          v43 = (void (__cdecl *)(int, _WORD *, void *, struct localeinfo_struct *))_decode_pointer(off_1017C29C[0]);
          v43(v42, v41, v40, &Locale);
        }
        goto LABEL_264;
      }
      goto LABEL_281;
    }
    if ( v20 != 105 )
    {
      if ( v20 == 110 )
      {
        v23 = v112;
        if ( !v107 )
        {
LABEL_259:
          if ( v90 )
          {
            *(_QWORD *)v13 = v95;
          }
          else if ( v106 )
          {
            *(_DWORD *)v13 = v23;
          }
          else
          {
            *v13 = v23;
          }
        }
        goto LABEL_264;
      }
LABEL_151:
      if ( *v11 == v110 )
      {
        --v104;
        if ( !v107 )
          v85 = v80;
        goto LABEL_264;
      }
LABEL_275:
      v75 = v110 == -1;
LABEL_279:
      if ( !v75 )
        sub_1008EDEC(v110, v105);
      goto LABEL_281;
    }
    v99 = 100;
LABEL_82:
    v24 = v110;
    if ( v110 == 45 )
    {
      v102 = 1;
      goto LABEL_176;
    }
    if ( v110 == 43 )
    {
LABEL_176:
      if ( --v108 || !v96 )
      {
        ++v112;
        v24 = _inc(v96, v105);
        v110 = v24;
      }
      else
      {
        v111 = 1;
      }
    }
    if ( v24 == 48 )
    {
      ++v112;
      v57 = _inc(v22, v105);
      v24 = v57;
      v110 = v57;
      if ( (_BYTE)v57 != 120 && (_BYTE)v57 != 88 )
      {
        v100 = 1;
        if ( v99 != 120 )
        {
          if ( v96 )
          {
            if ( !--v108 )
              ++v111;
          }
          v99 = 111;
          goto LABEL_215;
        }
        --v112;
        if ( v57 != -1 )
          sub_1008EDEC(v57, v105);
        v24 = 48;
LABEL_214:
        v110 = v24;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v58, v105);
      v110 = v24;
      if ( v96 )
      {
        v108 -= 2;
        if ( v108 < 1 )
          ++v111;
      }
      v99 = 120;
    }
LABEL_215:
    if ( !v90 )
    {
      v23 = v86;
      if ( !v111 )
      {
        while ( 1 )
        {
          if ( v99 == 120 || v99 == 112 )
          {
            if ( !isxdigit((unsigned __int8)v24) )
            {
LABEL_250:
              --v112;
              if ( v24 != -1 )
                sub_1008EDEC(v24, v105);
              break;
            }
            v68 = 16 * v23;
            v69 = isdigit((unsigned __int8)v24);
            v67 = v70;
            v24 = (char)v24;
            if ( !v69 )
              v24 = (v24 & 0xFFFFFFDF) - 7;
            v110 = v24;
          }
          else
          {
            v65 = isdigit((unsigned __int8)v24);
            v67 = v66;
            if ( !v65 )
              goto LABEL_250;
            if ( v99 == 111 )
            {
              if ( v24 >= 56 )
                goto LABEL_250;
              v68 = 8 * v23;
            }
            else
            {
              v68 = 10 * v23;
            }
          }
          ++v100;
          v23 = v68 + v24 - 48;
          if ( v96 )
          {
            if ( !--v108 )
              break;
          }
          ++v112;
          v24 = _inc(v67, v105);
          v110 = v24;
        }
      }
      if ( v102 )
        v23 = -v23;
      goto LABEL_254;
    }
    if ( v111 )
      goto LABEL_233;
    while ( 2 )
    {
      if ( v99 != 120 && v99 != 112 )
      {
        v59 = isdigit((unsigned __int8)v24);
        v61 = v60;
        if ( !v59 )
          break;
        if ( v99 == 111 )
        {
          if ( v24 >= 56 )
            break;
          v62 = 8 * v95;
          HIDWORD(v95) = v95 >> 29;
        }
        else
        {
          HIDWORD(v95) = 10 * v95 >> 32;
          v62 = 10 * v95;
        }
        goto LABEL_228;
      }
      if ( isxdigit((unsigned __int8)v24) )
      {
        v62 = 16 * v95;
        HIDWORD(v95) = v95 >> 28;
        v63 = isdigit((unsigned __int8)v24);
        v61 = v64;
        v24 = (char)v24;
        if ( !v63 )
          v24 = (v24 & 0xFFFFFFDF) - 7;
        v110 = v24;
LABEL_228:
        ++v100;
        v95 = v24 - 48 + __PAIR__(HIDWORD(v95), v62);
        if ( v96 )
        {
          if ( !--v108 )
            goto LABEL_233;
        }
        ++v112;
        v24 = _inc(v61, v105);
        v110 = v24;
        continue;
      }
      break;
    }
    --v112;
    if ( v24 != -1 )
      sub_1008EDEC(v24, v105);
LABEL_233:
    v23 = v86;
    if ( v102 )
      v95 = -(signed __int64)v95;
LABEL_254:
    if ( v99 == 70 )
      v100 = 0;
    if ( !v100 )
      goto LABEL_281;
    if ( !v107 )
    {
      ++v93;
      v13 = v94;
      goto LABEL_259;
    }
LABEL_264:
    ++v104;
    v11 = v97++ + 1;
LABEL_269:
    if ( v110 != -1 )
    {
LABEL_273:
      v10 = *v11;
      if ( !*v11 )
        goto LABEL_281;
      continue;
    }
    break;
  }
  if ( *v11 == 37 && v97[1] == 110 )
  {
    v11 = v97;
    goto LABEL_273;
  }
LABEL_281:
  if ( v91 == 1 )
    free(v98);
  if ( v110 == -1 )
  {
    result = v93;
    if ( !v93 && v104 == (_BYTE)v93 )
      result = -1;
    if ( v83 )
      *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
    return result;
  }
LABEL_289:
  if ( v83 )
    *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
  return v93;
}
// 1008209F: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100824A2: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 100885B4: using guessed type int __fastcall _inc(_DWORD, _DWORD);
// 100885CA: using guessed type _DWORD __cdecl _whiteout(_DWORD);
// 1017C29C: using guessed type int (*off_1017C29C[3])();
// 103380E0: using guessed type int dword_103380E0[];
// 100885EF: using guessed type char var_24[11];

//----- (10089634) --------------------------------------------------------
#error "10089639: positive sp value has been found (funcsize=0)"

//----- (1008963F) --------------------------------------------------------
#error "10089644: positive sp value has been found (funcsize=0)"

//----- (1008964A) --------------------------------------------------------
#error "1008964F: positive sp value has been found (funcsize=0)"

//----- (10089650) --------------------------------------------------------
#error "10089655: positive sp value has been found (funcsize=0)"

//----- (10089656) --------------------------------------------------------
#error "1008965B: positive sp value has been found (funcsize=0)"

//----- (1008965C) --------------------------------------------------------
#error "10089661: positive sp value has been found (funcsize=0)"

//----- (10089662) --------------------------------------------------------
#error "1008967D: positive sp value has been found (funcsize=0)"

//----- (10089683) --------------------------------------------------------
#error "10089698: positive sp value has been found (funcsize=0)"

//----- (1008969E) --------------------------------------------------------
#error "100896B9: positive sp value has been found (funcsize=0)"

//----- (100896BA) --------------------------------------------------------
#error "100896C9: positive sp value has been found (funcsize=0)"

//----- (100896CA) --------------------------------------------------------
#error "100896DD: positive sp value has been found (funcsize=0)"

//----- (100896DE) --------------------------------------------------------
#error "100896ED: positive sp value has been found (funcsize=0)"

//----- (100896EE) --------------------------------------------------------
#error "1008970D: positive sp value has been found (funcsize=0)"

//----- (10089713) --------------------------------------------------------
#error "1008972C: positive sp value has been found (funcsize=0)"

//----- (10089732) --------------------------------------------------------
#error "10089751: positive sp value has been found (funcsize=0)"

//----- (10089752) --------------------------------------------------------
#error "10089765: positive sp value has been found (funcsize=0)"

//----- (10089766) --------------------------------------------------------
#error "1008977D: positive sp value has been found (funcsize=0)"

//----- (1008977E) --------------------------------------------------------
#error "10089791: positive sp value has been found (funcsize=0)"

//----- (10089792) --------------------------------------------------------
#error "100897B1: positive sp value has been found (funcsize=0)"

//----- (100897B7) --------------------------------------------------------
#error "100897D0: positive sp value has been found (funcsize=0)"

//----- (100897D6) --------------------------------------------------------
#error "100897F5: positive sp value has been found (funcsize=0)"

//----- (100897F6) --------------------------------------------------------
#error "10089809: positive sp value has been found (funcsize=0)"

//----- (1008980A) --------------------------------------------------------
#error "10089821: positive sp value has been found (funcsize=0)"

//----- (10089822) --------------------------------------------------------
#error "10089835: positive sp value has been found (funcsize=0)"

//----- (10089836) --------------------------------------------------------
#error "10089855: positive sp value has been found (funcsize=0)"

//----- (1008985B) --------------------------------------------------------
#error "10089874: positive sp value has been found (funcsize=0)"

//----- (1008987A) --------------------------------------------------------
#error "10089899: positive sp value has been found (funcsize=0)"

//----- (1008989A) --------------------------------------------------------
#error "100898AD: positive sp value has been found (funcsize=0)"

//----- (100898AE) --------------------------------------------------------
#error "100898C5: positive sp value has been found (funcsize=0)"

//----- (100898C6) --------------------------------------------------------
#error "100898D9: positive sp value has been found (funcsize=0)"

//----- (100898DA) --------------------------------------------------------
#error "100898F9: positive sp value has been found (funcsize=0)"

//----- (100898FF) --------------------------------------------------------
#error "10089918: positive sp value has been found (funcsize=0)"

//----- (1008991E) --------------------------------------------------------
#error "1008993D: positive sp value has been found (funcsize=0)"

//----- (1008993E) --------------------------------------------------------
#error "10089951: positive sp value has been found (funcsize=0)"

//----- (10089952) --------------------------------------------------------
#error "10089969: positive sp value has been found (funcsize=0)"

//----- (1008996A) --------------------------------------------------------
#error "1008997D: positive sp value has been found (funcsize=0)"

//----- (1008997E) --------------------------------------------------------
#error "1008999D: positive sp value has been found (funcsize=0)"

//----- (100899A3) --------------------------------------------------------
#error "100899BC: positive sp value has been found (funcsize=0)"

//----- (100899C2) --------------------------------------------------------
#error "100899E1: positive sp value has been found (funcsize=0)"

//----- (100899E2) --------------------------------------------------------
#error "100899F5: positive sp value has been found (funcsize=0)"

//----- (100899F6) --------------------------------------------------------
#error "10089A0D: positive sp value has been found (funcsize=0)"

//----- (10089A0E) --------------------------------------------------------
#error "10089A21: positive sp value has been found (funcsize=0)"

//----- (10089A22) --------------------------------------------------------
#error "10089A41: positive sp value has been found (funcsize=0)"

//----- (10089A47) --------------------------------------------------------
#error "10089A60: positive sp value has been found (funcsize=0)"

//----- (10089A66) --------------------------------------------------------
#error "10089A85: positive sp value has been found (funcsize=0)"

//----- (10089A86) --------------------------------------------------------
#error "10089A99: positive sp value has been found (funcsize=0)"

//----- (10089A9A) --------------------------------------------------------
#error "10089AB1: positive sp value has been found (funcsize=0)"

//----- (10089AB2) --------------------------------------------------------
#error "10089AC5: positive sp value has been found (funcsize=0)"

//----- (1008A29B) --------------------------------------------------------
void sub_1008A29B()
{
  dword_103380C4 = 0;
}
// 103380C4: using guessed type int dword_103380C4;

//----- (1008A353) --------------------------------------------------------
int sub_1008A353()
{
  dword_103381F8 = _get_sse2_info();
  return 0;
}
// 1008A2F3: using guessed type int _get_sse2_info(void);
// 103381F8: using guessed type int dword_103381F8;

//----- (1008A360) --------------------------------------------------------
int __cdecl sub_1008A360(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_1008DE4D((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 10086F6B: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1008A406) --------------------------------------------------------
int __cdecl sub_1008A406(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_1008E38F((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 10086F6B: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1008A872) --------------------------------------------------------
DWORD __cdecl sub_1008A872(int a1, int a2, int a3, DWORD dwMoveMethod)
{
  void *v4; // eax@1
  DWORD v6; // eax@5
  _BYTE *v7; // eax@7
  DWORD lDistanceToMove; // [sp+8h] [bp-8h]@4
  LONG DistanceToMoveHigh; // [sp+Ch] [bp-4h]@1

  DistanceToMoveHigh = a3;
  v4 = (void *)sub_1008FDAC(a1);
  if ( v4 == (void *)-1 )
  {
    *_errno() = 9;
    return -1;
  }
  lDistanceToMove = SetFilePointer(v4, a2, &DistanceToMoveHigh, dwMoveMethod);
  if ( lDistanceToMove == -1 )
  {
    v6 = GetLastError();
    if ( v6 )
    {
      _dosmaperr(v6);
      return -1;
    }
  }
  v7 = (_BYTE *)(dword_103380E0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4);
  *v7 &= 0xFDu;
  return lDistanceToMove;
}
// 10080523: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 103380E0: using guessed type int dword_103380E0[];

//----- (1008AA0E) --------------------------------------------------------
_WORD *__cdecl sub_1008AA0E(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // esi@5
  int v5; // edi@5
  int v6; // eax@5
  char v7; // bl@5
  int v8; // eax@13
  void *v9; // ST18_4@13
  DWORD v10; // eax@16
  const char *v11; // ebx@16
  char v12; // cl@19
  int *v13; // esi@19
  int v14; // eax@19
  int v15; // eax@20
  int v16; // eax@27
  signed int v17; // esi@27
  int v18; // eax@31
  int v19; // esi@36
  __int16 v20; // ax@39
  int v21; // ecx@45
  char v22; // dl@45
  int v23; // eax@46
  DWORD v24; // ecx@51
  char *v25; // eax@51
  char *v26; // edx@53
  char v27; // dl@53
  int v28; // ebx@56
  DWORD v29; // ecx@64
  char *v30; // eax@64
  __int16 *v31; // edx@66
  __int16 v32; // dx@66
  int v33; // ebx@69
  DWORD v34; // ecx@74
  WCHAR *v35; // eax@74
  WCHAR v36; // dx@76
  int v37; // esi@79
  int v38; // ebx@79
  DWORD Mode; // [sp+4h] [bp-7Ch]@13
  int v40; // [sp+8h] [bp-78h]@13
  char v41; // [sp+Fh] [bp-71h]@5
  int *v42; // [sp+10h] [bp-70h]@5
  DWORD v43; // [sp+14h] [bp-6Ch]@56
  int v44; // [sp+18h] [bp-68h]@1
  LPCVOID lpBuffer; // [sp+1Ch] [bp-64h]@1
  _WORD *v46; // [sp+20h] [bp-60h]@1
  DWORD NumberOfBytesWritten; // [sp+24h] [bp-5Ch]@16
  WCHAR WideCharStr[2]; // [sp+28h] [bp-58h]@20
  _WORD *v49; // [sp+2Ch] [bp-54h]@17
  char Buffer; // [sp+30h] [bp-50h]@51
  CHAR v51[688]; // [sp+184h] [bp+104h]@79
  WCHAR v52; // [sp+434h] [bp+3B4h]@74
  CHAR MultiByteStr; // [sp+588h] [bp+508h]@20
  char v54; // [sp+589h] [bp+509h]@20

  lpBuffer = (LPCVOID)a2;
  v46 = 0;
  v44 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a2 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  v4 = &dword_103380E0[a1 >> 5];
  v5 = (a1 & 0x1F) << 6;
  v6 = v5 + *v4;
  v7 = (char)(2 * *(_BYTE *)(v6 + 36)) >> 1;
  v42 = &dword_103380E0[a1 >> 5];
  v41 = v7;
  if ( (v7 == 2 || v7 == 1) && !(~(_BYTE)nNumberOfBytesToWrite & 1) )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  if ( *(_BYTE *)(v6 + 4) & 0x20 )
    sub_1008A872(a1, 0, 0, 2u);
  if ( sub_1008B150(a1) )
  {
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x80 )
    {
      v8 = _getptd();
      v9 = *(void **)(v5 + *v4);
      v40 = *(_DWORD *)(*(_DWORD *)(v8 + 108) + 20) == 0;
      if ( GetConsoleMode(v9, &Mode) )
      {
        if ( !v40 || v7 )
        {
          v10 = GetConsoleCP();
          v11 = (const char *)lpBuffer;
          Mode = v10;
          NumberOfBytesWritten = 0;
          if ( nNumberOfBytesToWrite )
          {
            v49 = 0;
            while ( 1 )
            {
              if ( v41 )
              {
                if ( v41 == 1 || v41 == 2 )
                {
                  v19 = *(_WORD *)v11;
                  v11 += 2;
                  ++v49;
                  *(_DWORD *)WideCharStr = v19;
                  v40 = (_WORD)v19 == 10;
                }
                if ( v41 == 1 || v41 == 2 )
                {
                  v20 = _putwch_nolock(WideCharStr[0]);
                  if ( v20 != WideCharStr[0] )
                    goto LABEL_89;
                  v46 = (_WORD *)((char *)v46 + 1);
                  if ( v40 )
                  {
                    *(_DWORD *)WideCharStr = 13;
                    if ( (unsigned __int16)_putwch_nolock(13) != 13 )
                      goto LABEL_89;
                    v46 = (_WORD *)((char *)v46 + 1);
                    ++v44;
                  }
                }
                goto LABEL_43;
              }
              v12 = *v11;
              v13 = v42;
              v40 = *v11 == 10;
              v14 = v5 + *v42;
              if ( *(_DWORD *)(v14 + 56) )
              {
                MultiByteStr = *(_BYTE *)(v14 + 52);
                v54 = v12;
                *(_DWORD *)(v14 + 56) = 0;
                v15 = mbtowc(WideCharStr, &MultiByteStr, 2u);
              }
              else
              {
                if ( isleadbyte(v12) )
                {
                  if ( nNumberOfBytesToWrite + (_BYTE *)lpBuffer - v11 <= 1 )
                  {
                    v21 = *v13;
                    v22 = *v11;
                    v46 = (_WORD *)((char *)v46 + 1);
                    *(_BYTE *)(v5 + v21 + 52) = v22;
                    *(_DWORD *)(v5 + *v13 + 56) = 1;
                    goto LABEL_90;
                  }
                  if ( mbtowc(WideCharStr, v11, 2u) == -1 )
                    goto LABEL_90;
                  ++v11;
                  v49 = (_WORD *)((char *)v49 + 1);
                  goto LABEL_27;
                }
                v15 = mbtowc(WideCharStr, v11, 1u);
              }
              if ( v15 == -1 )
                goto LABEL_90;
LABEL_27:
              ++v11;
              v49 = (_WORD *)((char *)v49 + 1);
              v16 = WideCharToMultiByte(Mode, 0, WideCharStr, 1, &MultiByteStr, 5, 0, 0);
              v17 = v16;
              if ( !v16 )
                goto LABEL_90;
              if ( !WriteFile(*(HANDLE *)(v5 + *v42), &MultiByteStr, v16, &NumberOfBytesWritten, 0) )
                goto LABEL_89;
              v46 = (_WORD *)((char *)v49 + v44);
              if ( (signed int)NumberOfBytesWritten < v17 )
                goto LABEL_90;
              if ( v40 )
              {
                v18 = *v42;
                MultiByteStr = 13;
                if ( !WriteFile(*(HANDLE *)(v5 + v18), &MultiByteStr, 1u, &NumberOfBytesWritten, 0) )
                  goto LABEL_89;
                if ( (signed int)NumberOfBytesWritten < 1 )
                  goto LABEL_90;
                ++v44;
                v46 = (_WORD *)((char *)v46 + 1);
              }
LABEL_43:
              if ( (unsigned int)v49 >= nNumberOfBytesToWrite )
                goto LABEL_90;
            }
          }
          goto LABEL_91;
        }
      }
    }
  }
  v23 = v5 + *v4;
  if ( *(_BYTE *)(v23 + 4) & 0x80 )
  {
    *(_DWORD *)WideCharStr = 0;
    if ( v7 )
    {
      v49 = lpBuffer;
      if ( v7 == 2 )
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v29 = (char *)v49 - (_BYTE *)lpBuffer;
          v30 = &Buffer;
          do
          {
            if ( v29 >= nNumberOfBytesToWrite )
              break;
            v31 = v49;
            ++v49;
            v32 = *v31;
            v29 += 2;
            if ( v32 == 10 )
            {
              v44 += 2;
              *(_WORD *)v30 = 13;
              v30 += 2;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *(_WORD *)v30 = v32;
            v30 += 2;
          }
          while ( NumberOfBytesWritten < 0x3FF );
          v33 = v30 - &Buffer;
          if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v30 - &Buffer, &v43, 0) )
            break;
          v46 = (_WORD *)((char *)v46 + v43);
          if ( (signed int)v43 < v33 || (char *)v49 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
            goto LABEL_90;
          v4 = v42;
        }
      }
      else
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v34 = (char *)v49 - (_BYTE *)lpBuffer;
          v35 = &v52;
          do
          {
            if ( v34 >= nNumberOfBytesToWrite )
              break;
            v36 = *v49;
            ++v49;
            v34 += 2;
            if ( v36 == 10 )
            {
              *v35 = 13;
              ++v35;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *v35 = v36;
            ++v35;
          }
          while ( NumberOfBytesWritten < 0x152 );
          v37 = 0;
          v38 = WideCharToMultiByte(0xFDE9u, 0, &v52, v35 - &v52, v51, 683, 0, 0);
          if ( !v38 )
            break;
          while ( WriteFile(*(HANDLE *)(v5 + *v42), &v51[v37], v38 - v37, &v43, 0) )
          {
            v37 += v43;
            if ( v38 <= v37 )
              goto LABEL_84;
          }
          *(_DWORD *)WideCharStr = GetLastError();
LABEL_84:
          if ( v38 <= v37 )
          {
            v46 = (_WORD *)((char *)v49 - (_BYTE *)lpBuffer);
            if ( (char *)v49 - (_BYTE *)lpBuffer < nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_90;
        }
      }
    }
    else
    {
      NumberOfBytesWritten = (DWORD)lpBuffer;
      if ( nNumberOfBytesToWrite <= 0 )
        goto LABEL_96;
      while ( 1 )
      {
        v49 = 0;
        v24 = NumberOfBytesWritten - (_DWORD)lpBuffer;
        v25 = &Buffer;
        do
        {
          if ( v24 >= nNumberOfBytesToWrite )
            break;
          v26 = (char *)NumberOfBytesWritten++;
          v27 = *v26;
          ++v24;
          if ( v27 == 10 )
          {
            ++v44;
            *v25++ = 13;
            v49 = (_WORD *)((char *)v49 + 1);
          }
          *v25++ = v27;
          v49 = (_WORD *)((char *)v49 + 1);
        }
        while ( (unsigned int)v49 < 0x400 );
        v28 = v25 - &Buffer;
        if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v25 - &Buffer, &v43, 0) )
          break;
        v46 = (_WORD *)((char *)v46 + v43);
        if ( (signed int)v43 < v28 || NumberOfBytesWritten - (unsigned int)lpBuffer >= nNumberOfBytesToWrite )
          goto LABEL_90;
        v4 = v42;
      }
    }
  }
  else if ( WriteFile(*(HANDLE *)v23, lpBuffer, nNumberOfBytesToWrite, &v43, 0) )
  {
    *(_DWORD *)WideCharStr = 0;
    v46 = (_WORD *)v43;
    goto LABEL_90;
  }
LABEL_89:
  *(_DWORD *)WideCharStr = GetLastError();
LABEL_90:
  if ( !v46 )
  {
LABEL_91:
    if ( *(_DWORD *)WideCharStr )
    {
      if ( *(_DWORD *)WideCharStr == 5 )
      {
        *_errno() = 9;
        *__doserrno() = 5;
      }
      else
      {
        _dosmaperr(*(_DWORD *)WideCharStr);
      }
      return (_WORD *)-1;
    }
    v4 = v42;
LABEL_96:
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x40 && *(_BYTE *)lpBuffer == 26 )
      return 0;
    *_errno() = 28;
    *__doserrno() = 0;
    return (_WORD *)-1;
  }
  return (_WORD *)((char *)v46 - v44);
}
// 10080523: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 1008209F: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100826BE: using guessed type int _getptd(void);
// 103380E0: using guessed type int dword_103380E0[];
// 1008AA0E: using guessed type CHAR var_410[688];

//----- (1008B030) --------------------------------------------------------
_WORD *__cdecl sub_1008B030(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // ebx@7
  int v5; // esi@7
  _WORD *v6; // [sp+14h] [bp-1Ch]@9

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return (_WORD *)-1;
  }
  if ( a1 < 0
    || a1 >= uNumber
    || (v4 = &dword_103380E0[a1 >> 5], v5 = (a1 & 0x1F) << 6, !(*(_BYTE *)(*v4 + v5 + 4) & 1)) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  __lock_fhandle(a1);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    v6 = sub_1008AA0E(a1, a2, nNumberOfBytesToWrite);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    v6 = (_WORD *)-1;
  }
  sub_1008FEBD(a1);
  return v6;
}
// 1008209F: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1008FE1D: using guessed type _DWORD __cdecl __lock_fhandle(_DWORD);
// 103380E0: using guessed type int dword_103380E0[];

//----- (1008B150) --------------------------------------------------------
int __cdecl sub_1008B150(signed int a1)
{
  int result; // eax@2

  if ( a1 == -2 )
  {
    *_errno() = 9;
    result = 0;
  }
  else if ( a1 >= 0 && a1 < uNumber )
  {
    result = *(_BYTE *)(dword_103380E0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) & 0x40;
  }
  else
  {
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 0;
  }
  return result;
}
// 1008209F: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 103380E0: using guessed type int dword_103380E0[];

//----- (1008B1AE) --------------------------------------------------------
void **sub_1008B1AE()
{
  return &off_1017CD10;
}
// 1017CD10: using guessed type void *off_1017CD10;

//----- (1008B1B4) --------------------------------------------------------
signed int sub_1008B1B4()
{
  size_t v0; // eax@1
  void *v1; // eax@6
  signed int result; // eax@8
  int v3; // edx@9
  void **v4; // ecx@9
  signed int v5; // edx@12
  _DWORD *v6; // ecx@12
  int v7; // eax@13

  v0 = dword_103380C0;
  if ( !dword_103380C0 )
  {
    v0 = 512;
LABEL_5:
    dword_103380C0 = v0;
    goto LABEL_6;
  }
  if ( dword_103380C0 < 20 )
  {
    v0 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v1 = (void *)_calloc_crt(v0, 4);
  dword_103370B0 = v1;
  if ( v1 || (dword_103380C0 = 20, v1 = (void *)_calloc_crt(0x14u, 4), (dword_103370B0 = v1) != 0) )
  {
    v3 = 0;
    v4 = &off_1017CD10;
    while ( 1 )
    {
      *(_DWORD *)((char *)v1 + v3) = v4;
      v4 += 8;
      v3 += 4;
      if ( (signed int)v4 >= (signed int)&dword_1017CF90 )
        break;
      v1 = dword_103370B0;
    }
    v5 = 0;
    v6 = &unk_1017CD20;
    do
    {
      v7 = *(_DWORD *)(((v5 & 0x1F) << 6) + dword_103380E0[v5 >> 5]);
      if ( v7 == -1 || v7 == -2 || !v7 )
        *v6 = -2;
      v6 += 8;
      ++v5;
    }
    while ( (signed int)v6 < (signed int)&unk_1017CD80 );
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 10082AB2: using guessed type _DWORD __cdecl _calloc_crt(size_t, _DWORD);
// 1017CD10: using guessed type void *off_1017CD10;
// 1017CF90: using guessed type int dword_1017CF90;
// 103380C0: using guessed type int dword_103380C0;
// 103380E0: using guessed type int dword_103380E0[];

//----- (1008BA92) --------------------------------------------------------
int sub_1008BA92()
{
  return _decode_pointer(dword_10320228);
}
// 100824A2: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 10320228: using guessed type int dword_10320228;

//----- (1008BC4F) --------------------------------------------------------
int __cdecl sub_1008BC4F(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10320234 = a1;
  return result;
}
// 10320234: using guessed type int dword_10320234;

//----- (1008BC59) --------------------------------------------------------
int __cdecl sub_1008BC59(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10320240 = a1;
  return result;
}
// 10320240: using guessed type int dword_10320240;

//----- (1008BC63) --------------------------------------------------------
int __cdecl sub_1008BC63(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10320244 = a1;
  return result;
}
// 10320244: using guessed type int dword_10320244;

//----- (1008BD42) --------------------------------------------------------
int __cdecl sub_1008BD42(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10320248 = a1;
  return result;
}
// 10320248: using guessed type int dword_10320248;

//----- (1008CEC7) --------------------------------------------------------
int sub_1008CEC7()
{
  return 0;
}

//----- (1008DE4D) --------------------------------------------------------
signed int __cdecl sub_1008DE4D(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_1017D298 - 1;
    v64 = v3;
    v65 = dword_1017D298 / 32;
    v9 = dword_1017D298 % 32;
    v10 = (int *)(&v60 + dword_1017D298 / 32);
    v66 = 31 - dword_1017D298 % 32;
    if ( (1 << (31 - dword_1017D298 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_1017D294 - dword_1017D298 )
    {
      if ( v3 > dword_1017D294 )
      {
        if ( v3 < dword_1017D290 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_1017D2A4 + v3;
          v50 = dword_1017D29C / 32;
          v51 = dword_1017D29C % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_1017D29C % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_1017D29C / 32;
          v44 = dword_1017D29C % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_1017D29C % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_1017D2A4 + dword_1017D290;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_1017D294 - v64) / 32;
      v62 = v59;
      v18 = (dword_1017D294 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_1017D298 - 1;
      v25 = dword_1017D298 / 32;
      v65 = dword_1017D298 / 32;
      v26 = (int *)(&v60 + dword_1017D298 / 32);
      v64 = 31 - dword_1017D298 % 32;
      if ( (1 << (31 - dword_1017D298 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_1017D298 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_1017D29C + 1) / 32;
      v37 = (dword_1017D29C + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_1017D29C));
  if ( dword_1017D2A0 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_1017D2A0 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 1017D290: using guessed type int dword_1017D290;
// 1017D294: using guessed type int dword_1017D294;
// 1017D298: using guessed type int dword_1017D298;
// 1017D29C: using guessed type int dword_1017D29C;
// 1017D2A0: using guessed type int dword_1017D2A0;
// 1017D2A4: using guessed type int dword_1017D2A4;

//----- (1008E38F) --------------------------------------------------------
signed int __cdecl sub_1008E38F(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_1017D2B0 - 1;
    v64 = v3;
    v65 = dword_1017D2B0 / 32;
    v9 = dword_1017D2B0 % 32;
    v10 = (int *)(&v60 + dword_1017D2B0 / 32);
    v66 = 31 - dword_1017D2B0 % 32;
    if ( (1 << (31 - dword_1017D2B0 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_1017D2AC - dword_1017D2B0 )
    {
      if ( v3 > dword_1017D2AC )
      {
        if ( v3 < dword_1017D2A8 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_1017D2BC + v3;
          v50 = dword_1017D2B4 / 32;
          v51 = dword_1017D2B4 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_1017D2B4 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_1017D2B4 / 32;
          v44 = dword_1017D2B4 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_1017D2B4 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_1017D2BC + dword_1017D2A8;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_1017D2AC - v64) / 32;
      v62 = v59;
      v18 = (dword_1017D2AC - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_1017D2B0 - 1;
      v25 = dword_1017D2B0 / 32;
      v65 = dword_1017D2B0 / 32;
      v26 = (int *)(&v60 + dword_1017D2B0 / 32);
      v64 = 31 - dword_1017D2B0 % 32;
      if ( (1 << (31 - dword_1017D2B0 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_1017D2B0 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_1017D2B4 + 1) / 32;
      v37 = (dword_1017D2B4 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_1017D2B4));
  if ( dword_1017D2B8 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_1017D2B8 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 1017D2A8: using guessed type int dword_1017D2A8;
// 1017D2AC: using guessed type int dword_1017D2AC;
// 1017D2B0: using guessed type int dword_1017D2B0;
// 1017D2B4: using guessed type int dword_1017D2B4;
// 1017D2B8: using guessed type int dword_1017D2B8;
// 1017D2BC: using guessed type int dword_1017D2BC;

//----- (1008ECCC) --------------------------------------------------------
int __cdecl sub_1008ECCC(FILE *a1)
{
  int v1; // eax@3
  int v2; // eax@7
  int v3; // ST10_4@10
  char *v4; // ST0C_4@10
  int v5; // eax@10
  int v6; // eax@10
  int *v7; // edi@15
  _BYTE *v8; // eax@15
  int v9; // eax@20
  char *v10; // ecx@23
  int result; // eax@23

  if ( !a1 )
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v1 = a1->_flag;
  if ( !(v1 & 0x83) || v1 & 0x40 )
    return -1;
  if ( v1 & 2 )
  {
    a1->_flag = v1 | 0x20;
    return -1;
  }
  v2 = v1 | 1;
  a1->_flag = v2;
  if ( v2 & 0x10C )
    a1->_ptr = a1->_base;
  else
    _getbuf(a1);
  v3 = a1->_bufsiz;
  v4 = a1->_base;
  v5 = _fileno(a1);
  v6 = _read(v5, v4, v3);
  a1->_cnt = v6;
  if ( !v6 || v6 == -1 )
  {
    a1->_flag |= v6 != 0 ? 32 : 16;
    a1->_cnt = 0;
    return -1;
  }
  if ( !(a1->_flag & 0x82) )
  {
    if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
    {
      v8 = &unk_1017C2C0;
    }
    else
    {
      v7 = &dword_103380E0[_fileno(a1) >> 5];
      v8 = (_BYTE *)(*v7 + ((_fileno(a1) & 0x1F) << 6));
    }
    if ( (v8[4] & 0x82) == -126 )
      a1->_flag |= 0x2000u;
  }
  if ( a1->_bufsiz == 512 )
  {
    v9 = a1->_flag;
    if ( v9 & 8 )
    {
      if ( !(v9 & 0x400) )
        a1->_bufsiz = 4096;
    }
  }
  v10 = a1->_ptr;
  --a1->_cnt;
  result = (unsigned __int8)*v10;
  a1->_ptr = v10 + 1;
  return result;
}
// 1008209F: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1008B10C: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 103380E0: using guessed type int dword_103380E0[];

//----- (1008EDEC) --------------------------------------------------------
int __cdecl sub_1008EDEC(int a1, FILE *a2)
{
  int *v2; // edi@4
  _BYTE *v3; // eax@4
  int *v4; // edi@9
  _BYTE *v5; // eax@9
  int v7; // eax@16
  char *v8; // eax@24
  int v9; // eax@28

  if ( !(a2->_flag & 0x40) )
  {
    if ( _fileno(a2) == -1 || _fileno(a2) == -2 )
    {
      v3 = &unk_1017C2C0;
    }
    else
    {
      v2 = &dword_103380E0[_fileno(a2) >> 5];
      v3 = (_BYTE *)(*v2 + ((_fileno(a2) & 0x1F) << 6));
    }
    if ( v3[36] & 0x7F
      || (_fileno(a2) == -1 || _fileno(a2) == -2 ? (v5 = &unk_1017C2C0) : (v4 = &dword_103380E0[_fileno(a2) >> 5],
                                                                           v5 = (_BYTE *)(*v4
                                                                                        + ((_fileno(a2) & 0x1F) << 6))),
          v5[36] & 0x80) )
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
  }
  if ( a1 == -1 )
    return -1;
  v7 = a2->_flag;
  if ( !(v7 & 1) && ((char)v7 >= 0 || v7 & 2) )
    return -1;
  if ( !a2->_base )
    _getbuf(a2);
  if ( a2->_ptr == a2->_base )
  {
    if ( a2->_cnt )
      return -1;
    ++a2->_ptr;
  }
  v8 = --a2->_ptr;
  if ( a2->_flag & 0x40 )
  {
    if ( *v8 != (_BYTE)a1 )
    {
      a2->_ptr = v8 + 1;
      return -1;
    }
  }
  else
  {
    *v8 = a1;
  }
  v9 = a2->_flag;
  ++a2->_cnt;
  a2->_flag = v9 & 0xFFFFFFEF | 1;
  return (unsigned __int8)a1;
}
// 1008209F: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1008B10C: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 103380E0: using guessed type int dword_103380E0[];

//----- (1008FD2B) --------------------------------------------------------
signed int __cdecl sub_1008FD2B(signed int a1)
{
  int *v1; // edi@3
  int v2; // esi@3
  int v3; // eax@3
  DWORD v5; // [sp-8h] [bp-14h]@9

  if ( a1 >= 0 && a1 < uNumber )
  {
    v1 = &dword_103380E0[a1 >> 5];
    v2 = (a1 & 0x1F) << 6;
    v3 = v2 + *v1;
    if ( *(_BYTE *)(v3 + 4) & 1 )
    {
      if ( *(_DWORD *)v3 != -1 )
      {
        if ( dword_1031F8C0 == 1 )
        {
          if ( !a1 )
          {
            v5 = -10;
            goto LABEL_12;
          }
          if ( a1 == 1 )
          {
            v5 = -11;
            goto LABEL_12;
          }
          if ( a1 == 2 )
          {
            v5 = -12;
LABEL_12:
            SetStdHandle(v5, 0);
            goto LABEL_13;
          }
        }
LABEL_13:
        *(_DWORD *)(v2 + *v1) = -1;
        return 0;
      }
    }
  }
  *_errno() = 9;
  *__doserrno() = 0;
  return -1;
}
// 1031F8C0: using guessed type int dword_1031F8C0;
// 103380E0: using guessed type int dword_103380E0[];

//----- (1008FDAC) --------------------------------------------------------
signed int __cdecl sub_1008FDAC(signed int a1)
{
  signed int result; // eax@2
  int v2; // eax@5

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    result = -1;
  }
  else if ( a1 >= 0 && a1 < uNumber && (v2 = dword_103380E0[a1 >> 5] + ((a1 & 0x1F) << 6), *(_BYTE *)(v2 + 4) & 1) )
  {
    result = *(_DWORD *)v2;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  return result;
}
// 1008209F: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 103380E0: using guessed type int dword_103380E0[];

//----- (1008FEBD) --------------------------------------------------------
void __cdecl sub_1008FEBD(signed int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(dword_103380E0[a1 >> 5] + ((a1 & 0x1F) << 6) + 12));
}
// 103380E0: using guessed type int dword_103380E0[];

//----- (100901BE) --------------------------------------------------------
int sub_100901BE()
{
  return flsall(1);
}
// 100900E4: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (100901C7) --------------------------------------------------------
int __cdecl sub_100901C7(int a1, int a2, int a3)
{
  HMODULE v3; // eax@2
  HMODULE v4; // edi@2
  FARPROC v5; // eax@3
  FARPROC v6; // eax@4
  FARPROC v7; // eax@4
  FARPROC v8; // eax@7
  FARPROC v9; // eax@8
  int (*v10)(void); // esi@11
  int (__stdcall *v11)(int, signed int, char *, signed int, char *); // eax@11
  int (__stdcall *v12)(int, signed int, char *, signed int, char *); // edi@11
  int v13; // eax@13
  int (*v14)(void); // eax@22
  int (__stdcall *v15)(int); // eax@25
  int (__stdcall *v16)(int, int, int, int); // eax@27
  char v18; // [sp+10h] [bp-20h]@14
  char v19; // [sp+18h] [bp-18h]@15
  char v20; // [sp+1Ch] [bp-14h]@14
  unsigned int v21; // [sp+20h] [bp-10h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+28h] [bp-8h]@1
  int v24; // [sp+2Ch] [bp-4h]@1

  v23 = _encoded_null();
  v24 = 0;
  v22 = 0;
  v21 = 0;
  if ( !dword_10320264 )
  {
    v3 = LoadLibraryA("USER32.DLL");
    v4 = v3;
    if ( !v3 )
      return 0;
    v5 = GetProcAddress(v3, "MessageBoxA");
    if ( !v5 )
      return 0;
    dword_10320264 = _encode_pointer(v5);
    v6 = GetProcAddress(v4, "GetActiveWindow");
    dword_10320268 = _encode_pointer(v6);
    v7 = GetProcAddress(v4, "GetLastActivePopup");
    dword_1032026C = _encode_pointer(v7);
    if ( sub_1008216C(&v22) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v22 == 2 )
    {
      v8 = GetProcAddress(v4, "GetUserObjectInformationA");
      dword_10320274 = _encode_pointer(v8);
      if ( dword_10320274 )
      {
        v9 = GetProcAddress(v4, "GetProcessWindowStation");
        dword_10320270 = _encode_pointer(v9);
      }
    }
  }
  if ( dword_10320270 == v23
    || dword_10320274 == v23
    || (v10 = (int (*)(void))_decode_pointer(dword_10320270),
        v11 = (int (__stdcall *)(int, signed int, char *, signed int, char *))_decode_pointer(dword_10320274),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, &v18, 12, &v20) && v19 & 1 )
  {
    if ( dword_10320268 != v23 )
    {
      v14 = (int (*)(void))_decode_pointer(dword_10320268);
      if ( v14 )
      {
        v24 = v14();
        if ( v24 )
        {
          if ( dword_1032026C != v23 )
          {
            v15 = (int (__stdcall *)(int))_decode_pointer(dword_1032026C);
            if ( v15 )
              v24 = v15(v24);
          }
        }
      }
    }
  }
  else
  {
    if ( sub_100821A3(&v21) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v21 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_10320264);
  if ( v16 )
    return v16(v24, a1, a2, a3);
  return 0;
}
// 10081FA3: using guessed type int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1008242B: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 10082499: using guessed type int _encoded_null(void);
// 100824A2: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 10320264: using guessed type int dword_10320264;
// 10320268: using guessed type int dword_10320268;
// 1032026C: using guessed type int dword_1032026C;
// 10320270: using guessed type int dword_10320270;
// 10320274: using guessed type int dword_10320274;

//----- (10090FD1) --------------------------------------------------------
signed int __cdecl sub_10090FD1(signed int a1)
{
  signed int v1; // edi@6
  void *v2; // eax@7
  DWORD v3; // edi@8
  signed int result; // eax@11

  if ( sub_1008FDAC(a1) == -1
    || (a1 == 1 && *(_BYTE *)(dword_103380E0[0] + 132) & 1 || a1 == 2 && *(_BYTE *)(dword_103380E0[0] + 68) & 1)
    && (v1 = sub_1008FDAC(2), sub_1008FDAC(1) == v1)
    || (v2 = (void *)sub_1008FDAC(a1), CloseHandle(v2)) )
  {
    v3 = 0;
  }
  else
  {
    v3 = GetLastError();
  }
  sub_1008FD2B(a1);
  *(_BYTE *)(dword_103380E0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) = 0;
  if ( v3 )
  {
    _dosmaperr(v3);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10080523: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 103380E0: using guessed type int dword_103380E0[];

//----- (10091170) --------------------------------------------------------
void __cdecl sub_10091170(float *a1, float *a2, float *a3, int a4)
{
  float v4; // [sp+0h] [bp-4h]@1

  sub_1002B7F0(a1, a2, a4);
  v4 = sqrt(sub_1002B8B0(a4, a4));
  *a3 = v4;
  if ( v4 >= 0.1000000014901161 )
  {
    *(float *)a4 = *(float *)a4 / v4;
    *(float *)(a4 + 4) = *(float *)(a4 + 4) / *a3;
  }
  else
  {
    *(float *)(a4 + 4) = 1.0;
    *(float *)a4 = 0.0;
  }
}

//----- (100911D0) --------------------------------------------------------
int __cdecl sub_100911D0(float a1, float a2, int a3)
{
  float v3; // ST00_4@1
  float v4; // ST04_4@1
  float v5; // ST00_4@1
  float v6; // ST04_4@1
  double v7; // ST08_8@1
  float v8; // ST04_4@1
  float v9; // ST00_4@1
  float v10; // ST04_4@1
  float v11; // ST04_4@1
  double v12; // ST08_8@1
  float v13; // ST04_4@1
  float v14; // ST00_4@1
  float v15; // ST04_4@1
  float v16; // ST04_4@1
  double v17; // ST08_8@1
  float v18; // ST04_4@1
  float v19; // ST00_4@1
  float v20; // ST04_4@1
  float v21; // ST04_4@1
  double v22; // ST08_8@1
  float v23; // ST04_4@1
  float v24; // ST00_4@1
  float v25; // ST04_4@1
  int result; // eax@1
  float v27; // ST04_4@1
  float v28; // ST04_4@1
  float v29; // [sp+18h] [bp+8h]@1
  float v30; // [sp+18h] [bp+8h]@1

  v3 = sin(a2 * 4.0);
  v4 = v3;
  v5 = sin(a1 * 4.0);
  v6 = v4 - v5;
  v7 = v6 * 0.00001062759019987425 * 0.25;
  v8 = sin(a2 + a2);
  v9 = v8;
  v10 = sin(a1 + a1);
  v11 = v9 - v10;
  v12 = v7 - v11 * 0.00506310909986496 * 0.5;
  v13 = sin(a2 * 6.0);
  v14 = v13;
  v15 = sin(a1 * 6.0);
  v16 = v14 - v15;
  v17 = v12 - v16 * 0.00000002082037831030448 / 6.0;
  v18 = sin(a2 * 8.0);
  v19 = v18;
  v20 = sin(a1 * 8.0);
  v21 = v19 - v20;
  v22 = v21 * 3.932370748471747e-11 * 0.125 + v17;
  v23 = sin(a2 * 10.0);
  v24 = v23;
  v25 = sin(a1 * 10.0);
  result = a3;
  v27 = v24 - v25;
  v28 = v22 - v27 * 7.108452959288594e-14 / 10.0;
  v29 = a2 - a1;
  v30 = v29 * 1.005052447319031;
  *(float *)a3 = fabs((v28 + v30) * 6335439.327292892);
  return result;
}

//----- (10091390) --------------------------------------------------------
void __cdecl sub_10091390(int a1, int a2, float *a3, float *a4, float *a5)
{
  float v5; // ST38_4@1
  float v6; // ST38_4@1
  long double v7; // ST38_8@5
  long double v8; // ST48_8@5
  long double v9; // st7@5
  signed int v10; // ebx@5
  long double v11; // st5@5
  long double v12; // st7@5
  long double v13; // st7@6
  double v14; // st7@6
  double v15; // st4@6
  double v16; // st3@6
  double v17; // st2@8
  double v18; // STB8_8@8
  double v19; // ST60_8@10
  double v20; // ST50_8@10
  long double v21; // st7@10
  long double v22; // st7@10
  double v23; // [sp+40h] [bp-90h]@6
  double v24; // [sp+48h] [bp-88h]@6
  double v25; // [sp+50h] [bp-80h]@5
  double v26; // [sp+58h] [bp-78h]@5
  double v27; // [sp+60h] [bp-70h]@5
  double v28; // [sp+68h] [bp-68h]@6
  double v29; // [sp+70h] [bp-60h]@6
  double v30; // [sp+78h] [bp-58h]@5
  double v31; // [sp+80h] [bp-50h]@6
  double v32; // [sp+88h] [bp-48h]@6
  double v33; // [sp+90h] [bp-40h]@5
  double v34; // [sp+98h] [bp-38h]@5
  double v35; // [sp+A0h] [bp-30h]@8
  double v36; // [sp+A8h] [bp-28h]@6
  double v37; // [sp+B0h] [bp-20h]@5
  double v38; // [sp+C0h] [bp-10h]@5

  v5 = *(float *)(a2 + 4) - *(float *)(a1 + 4);
  v6 = fabs(sub_1007BCB0(v5));
  if ( v6 >= 0.000001 )
  {
    v7 = sin(*(float *)a1) * 0.9966471893352525 / cos(*(float *)a1);
    v8 = sin(*(float *)a2) * 0.9966471893352525 / cos(*(float *)a2);
    v33 = 1.0 / sqrt(v7 * v7 + 1.0);
    v9 = 1.0 / sqrt(v8 * v8 + 1.0);
    v10 = 0;
    v37 = v9;
    v34 = v33 * v9;
    v25 = v34 * v8;
    v27 = v25 * v7;
    v26 = *(float *)(a2 + 4) - *(float *)(a1 + 4);
    v11 = v9;
    v12 = v26;
    v30 = v11 * (v33 * v7);
    v38 = v27 + v27;
    do
    {
      v29 = sin(v12);
      v13 = cos(v26);
      v32 = v13;
      v24 = v25 - v13 * v30;
      v36 = sqrt(v29 * v37 * (v29 * v37) + v24 * v24);
      v28 = v13 * v34 + v27;
      v23 = sub_1007BE50(v36, v28);
      v14 = v29 * v34 / v36;
      v15 = 1.0 - v14 * v14;
      v16 = v38;
      v31 = v38;
      if ( v15 > 0.0 )
      {
        v16 = v28 - v38 / v15;
        v31 = v16;
      }
      ++v10;
      v35 = v16 * v16 + v16 * v16 - 1.0;
      v17 = v15 * ((4.0 - v15 * 3.0) * 0.00335281066474748 + 4.0) * 0.00335281066474748 * 0.0625;
      v18 = v26;
      v12 = 0.00335281066474748 * ((1.0 - v17) * (v14 * (v36 * (v16 + v35 * v28 * v17) * v17 + v23)))
          + *(float *)(a2 + 4)
          - *(float *)(a1 + 4);
      v26 = v12;
    }
    while ( fabs(v18 - v12) > 0.00000005 && v10 < 20 );
    v19 = sub_1007BE50(v29 * v37, v24);
    v20 = sub_1007BE50(v29 * v33, v32 * v25 - v30);
    v21 = sqrt(v15 * 0.006739496742276252 + 1.0);
    v22 = (v21 + 1.0 - 2.0) / (v21 + 1.0);
    *a3 = (0.25 * (v22 * v22) + 1.0)
        / (1.0 - v22)
        * ((v22 * 0.375 * v22 - 1.0)
         * v22
         * (v36
          * (v31
           + ((1.0 - v35 - v35) * (v36 * v36 * 4.0 - 3.0) * v31 * ((v22 * 0.375 * v22 - 1.0) * v22) / 6.0 - v35 * v28)
           * ((v22 * 0.375 * v22 - 1.0)
            * v22)
           * 0.25))
         + v23)
        * 6378137.0
        * 0.9966471893352525;
    *a4 = v19;
    *a5 = v20;
  }
  else
  {
    sub_100911D0(*(float *)a1, *(float *)a2, (int)a3);
    if ( *(float *)a1 >= (double)*(float *)a2 )
    {
      *a4 = 3.1415925;
      *a5 = 3.1415925;
    }
    else
    {
      *a4 = 0.0;
      *a5 = 0.0;
    }
  }
}

//----- (10091760) --------------------------------------------------------
void __cdecl sub_10091760(int a1, int a2, float *a3, float *a4)
{
  float v4; // ST14_4@1
  float v5; // ST14_4@1
  float v6; // [sp+Ch] [bp-1Ch]@1
  float v7; // [sp+10h] [bp-18h]@1
  float v8; // [sp+14h] [bp-14h]@1
  float v9; // [sp+18h] [bp-10h]@1
  float v10; // [sp+1Ch] [bp-Ch]@1
  float v11; // [sp+20h] [bp-8h]@3
  float v12; // [sp+24h] [bp-4h]@3

  sub_1007BCF0(a1, (int)&v9);
  sub_1007BCF0(a2, (int)&v7);
  v4 = v10 - v8;
  v6 = sub_1007BCB0(v4);
  v5 = v9 - v7;
  if ( COERCE_FLOAT(LODWORD(v5) & 0x7FFFFFFF) >= 0.0014486233 || COERCE_FLOAT(LODWORD(v6) & 0x7FFFFFFF) >= 0.0014486233 )
  {
    sub_10091390((int)&v9, (int)&v7, a3, a4, &v6);
  }
  else
  {
    sub_10091170(&v9, &v7, a3, (int)&v11);
    *a4 = sub_1007BEC0(v11, v12);
  }
}

//----- (10091840) --------------------------------------------------------
double __cdecl sub_10091840(float a1)
{
  float v2; // [sp+4h] [bp+4h]@1

  v2 = pow(a1 / 101325.0, 0.190228059887886);
  return (float)((1.0 - v2) * -44330.765625);
}

//----- (10091870) --------------------------------------------------------
double __cdecl sub_10091870(float a1, float a2, float a3, float a4, float a5)
{
  double v5; // st5@1
  double v6; // st4@1
  double v7; // st3@1
  double v8; // st2@1
  double v9; // st6@2
  double v10; // st7@5
  double v11; // st4@6
  double v12; // st3@6
  double v13; // rtt@9
  double v14; // st4@9
  double v15; // st7@9
  double result; // st7@10
  float v17; // [sp+0h] [bp-18h]@1
  float v18; // [sp+4h] [bp-14h]@1
  float v19; // [sp+1Ch] [bp+4h]@11
  float v20; // [sp+1Ch] [bp+4h]@11
  float v21; // [sp+20h] [bp+8h]@3
  float v22; // [sp+28h] [bp+10h]@9
  float v23; // [sp+2Ch] [bp+14h]@11

  v17 = a1 - a2;
  v18 = a3 - a2;
  v5 = v18;
  v6 = 273.1499938964844;
  v7 = a5;
  v8 = v17;
  if ( a4 == 9.9999996e24 )
  {
    v9 = 0.006500000134110451;
    if ( 9.9999996e24 == v7 )
    {
      v21 = 288.1499938964844 - v8 * 0.006500000134110451;
    }
    else
    {
      v21 = v7 - (v8 - v5) * 0.006500000134110451 + 273.1499938964844;
      v6 = 273.1499938964844;
    }
  }
  else
  {
    v9 = 0.006500000134110451;
    v21 = a4 + 273.1499938964844;
  }
  v10 = v17;
  if ( 9.9999996e24 == v7 )
  {
    v11 = v21;
    v12 = v21 - (v10 - v5) * -0.006500000134110451;
  }
  else
  {
    v12 = v6 + v7;
    v11 = v21;
  }
  v13 = v11;
  v14 = v10 - v5;
  v15 = v13;
  v22 = v14;
  if ( COERCE_FLOAT(LODWORD(v22) & 0x7FFFFFFF) >= 1.0 )
  {
    v19 = log(1.0 - v14 * v9 / (288.1499938964844 - v9 * v5));
    v23 = v12;
    v20 = a3
        - (v15 - v23) / 0.006500000134110451
        + (v23 * v17 - v21 * v18 - 288.1499938964844 * (v15 - v23) / -0.006500000134110451)
        / (-0.006500000134110451
         * v14)
        * v19;
    result = v20;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (100919F0) --------------------------------------------------------
double __cdecl sub_100919F0(float a1, float a2, float a3, float a4)
{
  unsigned int v4; // esi@1
  float v5; // ST20_4@2
  float v7; // [sp+18h] [bp-Ch]@1

  v7 = a1;
  v4 = 0;
  do
  {
    ++v4;
    v5 = sub_10091870(v7, a2, a3, 9.9999996e24, a4) - a1;
    v7 = v7 - v5;
  }
  while ( COERCE_FLOAT(LODWORD(v5) & 0x7FFFFFFF) > 1.0 && v4 < 0xA );
  return v7;
}

#error "There were 54 decompilation failure(s) on 2729 function(s)"
