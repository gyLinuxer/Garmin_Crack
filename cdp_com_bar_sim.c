/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

char __cdecl sub_10001000(int a1);
bool __cdecl sub_100010B0(int a1, int a2);
// int __usercall sub_100010D0@<eax>(int result@<eax>, int a2@<esi>);
int __cdecl sub_10001180(int a1, int a2);
char __cdecl sub_100011B0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
char __cdecl sub_100012F0(int a1, int a2);
int sub_100014D0(void); // weak
unsigned int sub_100014E0();
int __cdecl sub_10001590(int a1, int a2);
int __cdecl sub_100015B0(int a1);
int __cdecl sub_100015E0(int a1, int a2);
int __cdecl sub_10001600(int a1, char *a2, int a3, int a4);
char __cdecl sub_10001690(int a1, int a2, int a3);
char __cdecl sub_10001700(int a1, int a2, int a3);
int sub_10001770();
_DWORD *__cdecl sub_10001790(int a1);
unsigned int __cdecl sub_100017B0(int a1, int a2, int a3);
// void __usercall sub_10001820(int a1@<esi>);
// char __usercall sub_10001870@<al>(int a1@<esi>);
// void __usercall sub_10001950(int a1@<esi>, int a2);
// void __usercall sub_10001A20(int a1@<esi>, int a2);
// int __usercall sub_10001AC0@<eax>(int a1@<edi>, int a2);
char __thiscall sub_10001C90(int this);
signed int __cdecl sub_10001CB0(int a1, int a2);
char __cdecl sub_10001E00(int a1, int a2, __int16 a3);
char __cdecl sub_10001E30(int a1, int a2, __int16 a3);
char __cdecl sub_10001E60(unsigned int a1);
// int __usercall sub_10002190@<eax>(unsigned int a1@<eax>);
// void __usercall __noreturn sub_10002220(char *a1@<edi>);
int __cdecl sub_10002460(int a1, int a2);
char __cdecl sub_10002480(int a1, unsigned int a2);
char sub_100024C0();
char __thiscall sub_100024E0(int this);
// void *__usercall sub_10002650@<eax>(unsigned int a1@<ecx>, int a2@<ebx>);
char __cdecl sub_10002800(int a1);
int __cdecl sub_10002820(int a1, int a2);
int __cdecl sub_100028A0(int a1, __int16 a2, __int16 a3);
__int16 __cdecl sub_100028E0(unsigned __int8 a1);
char __cdecl sub_10002900(int (__cdecl *a1)(int));
char __cdecl sub_10002940(int (__cdecl *a1)(int));
char __cdecl sub_10002960(int a1, __int16 *a2, _BYTE *a3);
// char __usercall sub_100029E0@<al>(int a1@<ecx>, int a2@<edi>, unsigned int a3);
_WORD *__cdecl sub_10002B40(int a1);
// int __usercall sub_10002BB0@<eax>(int a1@<esi>);
// char __usercall sub_10002BE0@<al>(int a1@<edi>);
// char __usercall sub_10002E90@<al>(int a1@<esi>);
// int __usercall sub_10002F50@<eax>(int a1@<eax>, char a2);
// int __usercall sub_10002FB0@<eax>(int a1@<edi>);
char __cdecl sub_100030B0(int a1);
// char __usercall sub_10003170@<al>(int a1@<edi>);
// char __usercall sub_10003250@<al>(int a1@<esi>);
// char __usercall sub_100032B0@<al>(int a1@<edi>);
// char __usercall sub_10003380@<al>(int a1@<esi>);
// void __usercall sub_100033C0(int a1@<esi>);
// char __usercall sub_100035B0@<al>(int a1@<esi>);
// char __usercall sub_10003610@<al>(int a1@<edi>);
int __cdecl sub_100036C0(int a1);
char __cdecl sub_10003820(int a1);
void __cdecl sub_10003970(int a1);
char __cdecl sub_10003A80(int a1);
int sub_10003AE0(void); // weak
char __cdecl sub_10003AF0(char a1);
char sub_10003B10();
char __cdecl sub_10003B20(int a1);
void __cdecl sub_10003B60(unsigned int a1);
char sub_10003CC0();
// char __usercall sub_10003CD0@<al>(int a1@<edi>, unsigned int a2);
char __cdecl sub_10003CF0(int a1);
char sub_10003D60();
void __cdecl sub_10003D70(unsigned int a1);
int sub_10003DD0(void); // weak
_DWORD sub_10003DE0(); // weak
char __cdecl sub_10003E60(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5);
char __cdecl sub_10003F90(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_100041C0(int a1, int a2, int a3, _BYTE *a4, _WORD *a5);
int __cdecl sub_100042A0(unsigned int a1, char a2, int a3, int a4);
char __cdecl sub_10004300(int a1, int a2, int a3, double *a4);
// char __usercall sub_10004800@<al>(float *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4);
// char __usercall sub_100048E0@<al>(int a1@<eax>, int a2, int a3, int a4);
// char __usercall sub_100053B0@<al>(int a1@<eax>, float *a2@<ecx>, int a3@<ebx>, int a4@<esi>, int a5);
// char __usercall sub_10005470@<al>(int a1@<edx>, float *a2@<ecx>, int a3, int a4);
char __cdecl sub_100054B0(int a1, int a2, int *a3, float *a4, int a5);
// char __usercall sub_10005DA0@<al>(int a1@<eax>, int a2@<edx>);
// char __usercall sub_10005DC0@<al>(int a1@<edi>, int a2@<esi>);
// int __usercall sub_10005EA0@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_10005ED0@<eax>(int a1@<eax>, int a2@<ecx>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
// char __usercall sub_10006450@<al>(int a1@<ecx>, int a2@<edi>, int a3, int a4);
char __cdecl sub_100067E0(int a1, int a2, int a3, int a4, int a5);
// void *__usercall sub_10006CB0@<eax>(int a1@<ecx>, int a2@<esi>, unsigned int *a3);
// int __usercall sub_10006D80@<eax>(unsigned int a1@<eax>, int a2@<esi>, char a3, int a4);
// signed int __usercall sub_10006DD0@<eax>(int a1@<eax>, void *a2@<ecx>, unsigned int *a3, int a4);
// int __usercall sub_10006F50@<eax>(int a1@<ebx>, int a2, unsigned int *a3);
// char __usercall sub_100070A0@<al>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>);
// char __usercall sub_10007100@<al>(int a1@<ebx>, int a2@<edi>, int a3, unsigned int *a4);
// char __usercall sub_100071A0@<al>(unsigned int *a1@<edx>, int a2@<ecx>, int a3@<edi>);
// int __usercall sub_10007230@<eax>(int a1@<eax>, void *a2@<ecx>, int a3, int a4);
char __cdecl sub_100073F0(int a1, int a2, __int64 a3, int a4);
// int __usercall sub_10007870@<eax>(int a1@<eax>, int a2@<ecx>, unsigned __int8 a3);
char __cdecl sub_10007950(int a1, int a2, int a3, int a4, _WORD *a5);
// unsigned int __usercall sub_10007F00@<eax>(int a1@<ebx>, int a2@<esi>, unsigned __int16 *a3);
char __cdecl sub_10007FB0(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5);
// __int16 __usercall sub_10008050@<ax>(int a1@<eax>, int a2@<esi>);
// const char *__usercall sub_10008090@<eax>(const char *result@<eax>, unsigned __int8 a2@<bl>, char *a3);
char __cdecl sub_10008190(int a1, int a2, int a3, int a4, _WORD *a5);
signed int __cdecl sub_10008240(_BYTE *a1, int a2);
signed int __cdecl sub_100082B0(int a1, signed int a2, int a3);
// void __usercall sub_100082F0(int a1@<eax>, int a2);
// int __usercall sub_100083E0@<eax>(int a1@<edi>, int a2, int a3, float a4, float a5, float a6, float a7);
int __cdecl sub_100085B0(int, int, int, float, float, float, float); // idb
void __cdecl sub_100085F0(int a1, int a2);
// void __usercall sub_100086C0(int a1@<esi>, int a2);
char __cdecl sub_100087D0(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_10008890(int a1, int a2, int a3, int a4, _WORD *a5);
__int16 __cdecl sub_10008ED0(unsigned int a1);
char __cdecl sub_10008EF0(int a1, _WORD *a2, char **a3, int a4, int a5, int a6);
bool __cdecl sub_10009010(int a1, _WORD *a2, char *a3, int a4, int a5, int a6);
int __cdecl sub_10009110(unsigned int a1);
char *__cdecl sub_10009140(unsigned int a1);
signed int __cdecl sub_10009160(__int16 a1);
signed int __cdecl sub_10009190(int a1);
void *sub_100091C0();
// int __usercall sub_100091D0@<eax>(_BYTE *a1@<eax>);
// char __usercall sub_10009200@<al>(unsigned __int8 a1@<cl>, int a2@<edi>, unsigned __int8 a3);
// char __usercall sub_10009250@<al>(size_t a1@<edx>, signed int a2@<ecx>, int a3@<esi>, const char *a4, int *a5, char a6, char a7);
int __cdecl sub_10009750(unsigned int a1, unsigned int a2, float *a3);
int sub_10009780();
int __cdecl sub_10009820(int a1, int a2, int a3, unsigned __int8 a4);
int __cdecl sub_100099A0(unsigned int a1, char a2);
char __cdecl sub_10009A00(int a1, const char *a2, int *a3, int a4);
int __cdecl sub_10009C10(int a1, int a2, unsigned int a3, int a4);
char __cdecl sub_10009CE0(int a1, char *a2, const char *a3, __int16 a4, __int16 a5, unsigned int a6, __int16 a7);
void __cdecl sub_10009F00(int a1, int (__cdecl *a2)(int));
// unsigned int __usercall sub_10009F50@<eax>(unsigned int result@<eax>);
// int __usercall sub_10009F90@<eax>(int result@<eax>);
void __cdecl sub_10009FC0(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4, int a5);
void __cdecl sub_1000A370(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4);
void __cdecl sub_1000A390(int a1, unsigned __int8 a2);
void __cdecl sub_1000A3F0(int a1);
char __thiscall sub_1000A680(void *this);
char __cdecl sub_1000A6D0(char a1);
int __cdecl sub_1000A780(int a1);
void sub_1000A810();
signed int sub_1000A820();
char __cdecl sub_1000A830(int a1);
int __cdecl sub_1000A8B0(unsigned __int16 a1, char a2, int a3);
int sub_1000A980();
void sub_1000A9E0();
signed int sub_1000A9F0();
int __cdecl sub_1000AA00(int a1, int a2);
int __cdecl sub_1000AA70(int, char, void *); // idb
char __cdecl sub_1000AAF0(__int64 a1);
signed int __cdecl sub_1000AB20(unsigned __int8 a1);
char __cdecl sub_1000AB60(unsigned __int8 a1);
signed int __cdecl sub_1000ABA0(unsigned __int8 a1, unsigned __int8 a2);
signed int __cdecl sub_1000AC00(unsigned __int8 a1);
char __cdecl sub_1000AC40(int a1);
char __cdecl sub_1000AC80(int a1);
char __cdecl sub_1000ACC0(int a1);
char __cdecl sub_1000AD00(int a1);
char __cdecl sub_1000AD40(int a1);
char __cdecl sub_1000AD80(unsigned __int8 a1);
char __cdecl sub_1000ADC0(unsigned __int8 a1);
char __cdecl sub_1000AE00(unsigned __int8 a1);
char __cdecl sub_1000AE40(unsigned __int8 a1);
char __cdecl sub_1000AE80(unsigned __int8 a1);
char __cdecl sub_1000AEC0(unsigned __int8 a1, int a2, unsigned __int8 a3, unsigned __int8 a4);
// char __usercall sub_1000AEF0@<al>(signed int a1@<eax>, unsigned __int8 a2@<cl>, int a3@<edi>, unsigned __int8 a4, signed int *a5, _BYTE *a6);
// char __usercall sub_1000AF90@<al>(int a1@<ebx>, _BYTE *a2, int *a3);
double *__cdecl sub_1000B1E0(char a1, char a2, double *a3);
int __cdecl sub_1000B310(int a1);
signed int __thiscall sub_1000B350(int this);
// signed int __usercall sub_1000B400@<eax>(int a1@<edi>);
signed int __thiscall sub_1000B490(int this);
// char __usercall sub_1000B530@<al>(int a1@<eax>, char a2);
// int __usercall sub_1000B580@<eax>(int a1@<esi>);
// char __usercall sub_1000B5A0@<al>(unsigned int a1@<eax>, unsigned int *a2@<ebx>, _BYTE *a3@<edi>, int a4@<esi>, _DWORD *a5, int *a6);
// void *__usercall sub_1000B660@<eax>(int a1@<eax>, char *a2@<esi>);
// __int16 __usercall sub_1000B6C0@<ax>(int a1@<eax>, int a2@<esi>, int a3);
char __cdecl sub_1000B830(unsigned int a1, int a2);
void *__cdecl sub_1000BAB0(unsigned int a1, char *a2);
signed int __cdecl sub_1000BB00(unsigned __int8 a1);
// signed int __usercall sub_1000BB80@<eax>(int a1@<edi>, unsigned __int8 a2);
signed int __cdecl sub_1000BBF0(unsigned __int8 a1);
// int __usercall sub_1000BC60@<eax>(int a1@<eax>, char a2);
// void __usercall sub_1000BCF0(int a1@<edi>, int a2, int a3);
int __cdecl sub_1000BD30(__int64 a1);
int __cdecl sub_1000BDE0(int a1, int a2);
char __cdecl sub_1000BF70(int a1, int a2);
__int16 __cdecl sub_1000BFE0(int a1, int a2);
unsigned __int8 __cdecl sub_1000C020(unsigned int a1);
int __cdecl sub_1000C050(unsigned int a1, unsigned __int8 a2, char a3);
int __cdecl sub_1000C0D0(unsigned int a1);
char __cdecl sub_1000C100(__int64 a1);
_DWORD __cdecl sub_1000C1A0(_DWORD, _DWORD); // weak
// char __usercall sub_1000C1B0@<al>(unsigned __int16 a1@<ax>, void *a2);
// int __usercall sub_1000C210@<eax>(int result@<eax>, int a2@<ecx>);
int __cdecl sub_1000C230(unsigned __int16 a1, int a2);
int __cdecl sub_1000C2A0(unsigned __int8 a1);
unsigned int __cdecl sub_1000C2E0(unsigned int a1, _BYTE *a2, _BYTE *a3);
char __cdecl sub_1000C300(unsigned __int8 a1, int a2, char a3, int a4);
// char __usercall sub_1000C380@<al>(int a1@<eax>, unsigned __int8 a2);
int __fastcall sub_1000C420(int a1, int a2);
void __cdecl sub_1000C450(unsigned int a1, int a2);
char __cdecl sub_1000C590(unsigned int a1, int a2);
// void __usercall sub_1000C640(int a1@<ecx>, int a2@<esi>);
char __cdecl sub_1000C670(unsigned int a1, int a2);
int sub_1000C790();
char __cdecl sub_1000C830(float *a1);
char __cdecl sub_1000CAF0(int a1, float *a2);
char *__cdecl sub_1000CB10(unsigned __int8 a1);
signed int sub_1000CBD0();
int sub_1000CBF0();
int sub_1000CC50();
char *sub_1000CCC0();
int __cdecl sub_1000CD90(const void *a1);
void __cdecl sub_1000CE40(unsigned int a1, int a2);
char __cdecl sub_1000D020(unsigned int a1, int a2);
int __cdecl sub_1000D090(_BYTE *a1, _BYTE *a2);
int sub_1000D0C0();
int __fastcall sub_1000D0D0(unsigned __int8 a1);
int __fastcall sub_1000D0F0(unsigned __int8 a1);
void *__cdecl sub_1000D110(char a1, void *a2);
int __cdecl sub_1000D1E0(int a1);
char sub_1000D3A0();
char *__cdecl sub_1000D500(int a1, char *a2, int a3, char *a4, int a5);
char sub_1000D630();
char __cdecl sub_1000D640(char *a1, int a2, char a3, char *a4, int a5);
char __cdecl sub_1000D740(char *a1, int a2, char a3, char *a4);
char __cdecl sub_1000D7B0(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5);
// int __usercall sub_1000D7D0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
char __cdecl sub_1000D820(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_1000D8A0(int a1, int a2, int a3, int a4, _WORD *a5);
int __cdecl sub_1000DB20(unsigned __int16 a1);
char __cdecl sub_1000DB30(int a1, int a2, int a3, int a4, __int16 *a5);
char __cdecl sub_1000E190(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_1000E2E0(int a1, int a2, int *a3, int a4, int a5);
_DWORD *__cdecl sub_1000E350(_DWORD *a1);
int __cdecl sub_1000E360(int *a1, int a2);
_DWORD *__cdecl sub_1000E390(_DWORD *a1, int a2);
char __cdecl sub_1000E3A0(int a1, int a2, int a3);
char __cdecl sub_1000E3D0(int a1, _WORD *a2, int a3);
bool __cdecl sub_1000E400(char *a1, int *a2, _DWORD *a3);
char __cdecl sub_1000E450(int a1, char *a2);
int __cdecl sub_1000E4B0(int a1, int a2, char *a3, int a4);
char __cdecl sub_1000E520(int a1, char *a2, int a3);
int __cdecl sub_1000E5D0(int a1);
char __thiscall sub_1000E650(void *this);
char __thiscall sub_1000E680(void *this);
char __fastcall sub_1000E6B0(int a1);
char __thiscall sub_1000E720(void *this);
char __fastcall sub_1000E750(int a1);
char sub_1000E7A0();
BOOL __thiscall sub_1000E7B0(void *this);
char __thiscall sub_1000E7D0(void *this);
char __thiscall sub_1000E800(void *this);
char __fastcall sub_1000E830(int a1);
bool __thiscall sub_1000E880(void *this);
int sub_1000E950();
char __thiscall sub_1000E980(void *this);
char __fastcall sub_1000E9B0(int a1);
char __cdecl sub_1000EA00(int a1);
char sub_1000EA20();
int __cdecl sub_1000EA50(int, char *); // idb
char __thiscall sub_1000EAB0(void *this);
int __thiscall sub_1000EAD0(void *this);
int __thiscall sub_1000EAF0(void *this);
char __thiscall sub_1000EB10(void *this);
int __thiscall sub_1000EB30(void *this);
char __thiscall sub_1000EB50(void *this);
char __thiscall sub_1000EB70(void *this);
char sub_1000EB90();
int __cdecl sub_1000EBB0(char a1);
char __cdecl sub_1000EBC0(char a1);
char __cdecl sub_1000EC00(char a1);
signed int __cdecl sub_1000EC70(char a1);
char __cdecl sub_1000ECF0(char a1);
char __cdecl sub_1000ED60(char a1);
char __cdecl sub_1000EE10(int a1);
char __thiscall sub_1000EF10(void *this);
int __cdecl sub_1000EF20(int *a1);
// char __usercall sub_1000EF50@<al>(int a1@<eax>, int a2@<ecx>);
int __cdecl sub_1000EFF0(const char *a1);
char __cdecl sub_1000F030(void *a1);
signed int __cdecl sub_1000F080(unsigned int a1, int a2);
char **sub_1000F420();
int __cdecl j_nullsub_1(_DWORD); // weak
int __cdecl sub_1000F440(int a1);
int __cdecl sub_1000F450(int a1);
int sub_1000F460(void); // weak
char __cdecl sub_1000F490(char a1, unsigned __int16 a2, char a3);
bool __cdecl sub_1000F4C0(signed int a1, signed int a2, _BYTE *a3);
int __cdecl sub_1000F530(int a1, _BYTE *a2, int a3);
int __cdecl sub_1000F580(void *, size_t); // idb
int __cdecl sub_1000F5B0(int, char *, int); // idb
int __cdecl sub_1000F610(char *, size_t, char *, va_list); // idb
int sub_1000F650(char *arg0, size_t arg4, char *arg8, ...);
int __cdecl sub_1000F680(const char *a1, _BYTE *a2, int a3);
int __cdecl sub_1000F6C0(int a1, int a2);
signed int __cdecl sub_1000F6E0(int (__cdecl *a1)(int));
char *__cdecl sub_1000F710(unsigned __int8 a1);
int __cdecl sub_1000F740(float); // idb
int __cdecl sub_1000F7D0(int a1, _WORD *a2, char *a3, int a4, int a5, int a6, int a7);
int __cdecl sub_1000F910(int a1, _WORD *a2, char *a3, int a4, int a5, int a6);
// void __usercall sub_1000F950(int a1@<eax>, int a2@<edi>, int a3@<esi>, float a4);
void *sub_1000FAA0();
// int __usercall sub_1000FAB0@<eax>(int a1@<edi>, int a2@<esi>, char a3);
void __cdecl sub_1000FB80(int a1, int a2, int a3);
int __cdecl sub_1000FBA0(int a1, int a2);
void __cdecl sub_1000FBC0(float a1, float a2, float a3, float a4, char a5);
void __cdecl sub_1000FE10(float a1, float a2, float a3, float a4, float a5, float a6, char a7);
// int __usercall sub_1000FE90@<eax>(float a1@<eax>, int a2@<ecx>, int a3@<ebx>, int a4);
int __cdecl sub_1000FF70(int a1, int a2, int a3);
int __cdecl sub_1000FF90(int a1, int a2, int a3);
int __cdecl sub_1000FFB0(int a1, int a2, int a3);
int __cdecl sub_10010020(char *, char *); // idb
// void *__usercall sub_10010060@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>);
signed int sub_100100B0();
int __cdecl sub_10011EB0(signed int a1, char a2);
char __cdecl sub_10012070(char a1, char a2, int a3);
char __cdecl sub_10012230(char a1);
char __cdecl sub_10012260(char a1, void *a2);
int __cdecl sub_100122E0(char a1, _DWORD *a2);
bool __cdecl sub_10012330(char a1);
bool __cdecl sub_100123A0(char a1);
bool __cdecl sub_10012400(char a1);
char __cdecl sub_10012460(char a1, char a2);
void __cdecl sub_100124C0(char a1, char a2);
char __cdecl sub_10012530(signed int a1);
int __thiscall sub_10012560(void *this);
// bool __usercall sub_10012630@<al>(int a1@<esi>);
bool __cdecl sub_10012660(_BYTE *a1);
char __thiscall sub_10012680(void *this);
char __cdecl sub_10012710(int a1, char a2);
char __cdecl sub_100127D0(char a1, char a2);
char __cdecl sub_10012820(char a1);
char __cdecl sub_10012850(char a1);
char __thiscall sub_10012890(void *this);
int __thiscall sub_100128C0(void *this);
_DWORD sub_100128E0(); // weak
int sub_100128F0();
BOOL __cdecl sub_10012910(unsigned int a1);
char __thiscall sub_10012980(void *this);
void __cdecl sub_100129A0(_BYTE *a1, _BYTE *a2, _BYTE *a3);
int __cdecl sub_100129D0(int a1);
signed int sub_100129F0();
void __cdecl sub_10012A20(_BYTE *a1);
char __cdecl sub_10012A40(int a1, size_t a2, void *a3);
int __cdecl sub_10012A80(int a1);
char __fastcall sub_10012AA0(int *a1);
char sub_10012CC0();
char __cdecl sub_10012CE0(unsigned __int16 a1, float *a2);
void sub_10012E00();
int sub_10012E10();
char sub_10012E40();
int __cdecl sub_10012EE0(double, double); // idb
void sub_10012F30();
signed int sub_10012F40();
signed int sub_10012F50();
bool __cdecl sub_10012F80(char a1, int a2);
char sub_100131A0();
int __cdecl sub_10013210(char a1);
signed int sub_10013230();
// signed int __usercall sub_10013280@<eax>(char a1@<al>, int a2@<ecx>);
// int __usercall sub_10013320@<eax>(char a1@<al>);
// int __usercall sub_10013340@<eax>(char a1@<al>);
// signed __int16 __usercall sub_10013360@<ax>(char a1@<al>, unsigned __int16 a2@<si>);
char __cdecl sub_100135A0(char a1, unsigned __int16 a2, _BYTE *a3);
char __cdecl sub_10013700(char a1, unsigned __int16 a2, void *a3);
char __cdecl sub_10013880(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_100139E0(int a1, int a2, void *a3, char a4, __int16 a5, char a6);
char __cdecl sub_10013B20(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_10013C00(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6);
char __cdecl sub_10013E80(char a1, int a2, __int16 a3, __int16 a4, void *a5);
char __cdecl sub_10013EB0(char a1, int a2, void *a3);
char __cdecl sub_10013EE0(char a1, int a2, void *a3, int a4);
int __cdecl sub_10013F10(int a1, int a2);
signed int sub_10013F30();
int sub_10013F50();
int __cdecl nullsub_1(_DWORD, _DWORD);
int __cdecl sub_10013F70(unsigned __int16 a1);
char *__cdecl sub_10013F90(unsigned __int16 a1);
char __thiscall sub_10013FD0(void *this);
char __cdecl sub_10014000(char a1);
signed int __cdecl sub_10014030(signed int a1);
signed int __fastcall sub_10014070(int a1, unsigned __int8 a2);
int __cdecl sub_100140C0(char, void *); // idb
unsigned __int8 __cdecl sub_10014100(int a1, unsigned __int8 a2);
bool __cdecl sub_10014180(char a1);
char *__cdecl sub_100141B0(unsigned __int8 a1);
char *__cdecl sub_100141C0(unsigned int a1, float *a2);
char __cdecl sub_100141F0(unsigned __int16 a1, int a2, char a3);
char __cdecl sub_100143F0(char a1);
char __cdecl sub_10014410(unsigned int a1, float *a2);
double __cdecl sub_10014830(int a1, unsigned __int16 a2, char a3, char *a4);
double __cdecl sub_10014C00(int a1, unsigned int a2);
double __cdecl sub_10015230(int a1, unsigned int a2);
char __cdecl sub_10015920(signed int a1, char a2);
int __cdecl sub_100159B0(unsigned __int8 a1);
char __fastcall sub_100159D0(int a1);
char __cdecl sub_10015A10(char a1, void *a2);
char __cdecl sub_10015A60(char a1, bool *a2);
unsigned __int8 __cdecl sub_10015AB0(unsigned __int8 a1, unsigned __int8 a2);
char __cdecl sub_10015AF0(char a1);
int __cdecl sub_10015B60(char a1, _DWORD *a2);
char __cdecl sub_10015BA0(int a1, int a2, unsigned __int16 a3, int a4, char a5);
void __cdecl sub_10015D70(int a1);
// void __usercall sub_10015DB0(int a1@<ebx>, int a2@<esi>, char a3);
void __cdecl sub_10015E50(int a1, int a2);
char __cdecl sub_10015E70(float a1, int a2, char a3, int a4);
char __cdecl sub_10015F60(char a1, _DWORD *a2, int *a3, char a4, int a5);
char __cdecl sub_10015FF0(char a1, _DWORD *a2, int *a3, char a4, int a5);
int __cdecl sub_10016080(int a1);
double __cdecl sub_100160A0(float a1, float a2, int a3, float a4);
char __cdecl sub_10016180(bool *a1);
double __cdecl sub_100162C0(_DWORD); // weak
bool sub_100162D0();
bool sub_100162E0();
double sub_10016300();
// char __usercall sub_10016330@<al>(float *a1@<edi>, unsigned __int16 a2@<si>, unsigned __int8 a3);
char __cdecl sub_10016420(float *a1);
char __cdecl sub_10016440(float *a1);
char __cdecl sub_10016460(float *a1);
double sub_100164F0();
signed int __cdecl sub_10016550(int a1);
double __cdecl sub_10016570(signed int a1, char a2);
void __cdecl sub_100165B0(_BYTE *a1, signed int a2, int a3);
bool __cdecl sub_10016650(unsigned int a1, unsigned __int16 a2);
int __cdecl sub_10016690(unsigned __int16 a1);
int __cdecl sub_100166C0(int a1, signed int a2, signed int a3);
int __cdecl sub_100166E0(_BYTE *a1);
char __cdecl sub_10016710(_BYTE *a1, _BYTE *a2);
char __cdecl sub_10016760(_BYTE *a1, _BYTE *a2);
int sub_100167B0();
__int16 sub_10016880();
// int __usercall sub_100168E0@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4);
signed int __cdecl sub_10016960(int a1);
unsigned __int8 sub_10016A50();
char sub_10016B20();
int (__cdecl *(*sub_10016CE0())[2])(int, int);
char __cdecl sub_10016E10(char a1);
char __thiscall sub_10016E40(void *this);
int __cdecl sub_10016EA0(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6);
bool __cdecl sub_10017030(float *a1);
int sub_100170D0();
int __cdecl sub_10017100(int a1);
signed int __cdecl sub_10017200(int a1, int a2);
unsigned int __cdecl sub_100172A0(char *a1);
int __cdecl sub_100172C0(unsigned __int8 *a1);
int __cdecl sub_100172E0(_BYTE *a1);
int __cdecl sub_10017300(unsigned __int8 *a1);
unsigned int __cdecl sub_10017320(int a1, int a2);
unsigned int __cdecl sub_10017650(int a1, int a2);
int __cdecl sub_10017A90(unsigned __int8 *a1);
int __cdecl sub_10017AB0(unsigned __int8 *a1);
int __cdecl sub_10017AD0(int a1);
unsigned int __cdecl sub_10017B00(_BYTE *a1);
int __cdecl sub_10017B20(unsigned __int8 *a1);
int __cdecl sub_10017B40(unsigned __int8 *a1);
int __cdecl sub_10017B60(_BYTE *a1);
int __cdecl sub_10017B80(int a1);
// void __cdecl __noreturn exit(int);
int __cdecl sub_10017BD0(unsigned __int8 *a1);
int __cdecl sub_10017BF0(int a1);
unsigned int __cdecl sub_10017C80(int a1);
signed int __cdecl sub_10017CA0(int a1);
unsigned int __cdecl sub_10017CF0(int a1);
int __cdecl sub_10017D50(_BYTE *a1);
unsigned int __cdecl sub_10017D70(_BYTE *a1);
int __cdecl sub_10017D90(unsigned __int8 *a1);
int __cdecl sub_10017DB0(_BYTE *a1);
signed int __cdecl sub_10017DD0(_BYTE *a1, int a2);
int __cdecl sub_10017E00(_BYTE *a1, int a2);
signed int __cdecl sub_10017E40(_BYTE *a1, int a2);
int __cdecl sub_10017E70(int a1, int a2);
int __cdecl sub_10017F00(int a1);
int __cdecl sub_10017F30(unsigned __int8 *a1);
unsigned int __cdecl sub_10017F50(int a1);
int __cdecl sub_10017F80(int a1);
int __cdecl sub_10018070(int a1);
signed int __cdecl sub_10018180(unsigned __int8 *a1, int a2);
int __cdecl sub_100181B0(unsigned __int8 *a1);
int __cdecl sub_10018210(int a1);
signed int __cdecl sub_10018220(_BYTE *a1, int a2);
int __cdecl sub_10018250(int a1, int a2);
unsigned int __cdecl sub_100182D0(int a1);
unsigned int __cdecl sub_10018310(int a1);
int __cdecl sub_10018360(int a1);
int __cdecl sub_10018390(int a1);
unsigned int __cdecl sub_100183C0(int a1);
unsigned int __cdecl sub_100183F0(int a1);
unsigned int __cdecl sub_10018410(int a1);
void __cdecl __noreturn sub_10018450(int a1);
signed int __cdecl sub_100185C0(int a1, int a2);
// time_t __cdecl static _mkgmtime(struct tm *Tm);
// signed int __usercall sub_10018620@<eax>(int a1@<eax>, int a2@<edi>);
signed int __cdecl sub_100186F0(int a1);
char __cdecl sub_10018700(char a1);
int __cdecl sub_10018740(char *a1, char a2);
bool __cdecl sub_100187B0(int a1, void *a2);
char __cdecl sub_10018870(int a1, bool *a2);
char __cdecl sub_10018930(char *a1);
// unsigned int __usercall sub_10018960@<eax>(int a1@<eax>);
char __cdecl sub_10018BA0(int a1, int a2, int a3, int a4, __int16 *a5);
signed int __fastcall sub_10018C80(unsigned __int8 a1);
char __cdecl sub_10018C90(unsigned __int8 a1);
__int16 __cdecl sub_10018CB0(unsigned __int8 a1);
char *__cdecl sub_10018CD0(char **a1);
int sub_10018D20();
int __cdecl sub_10018D60(_BYTE *a1, int a2);
signed int __cdecl sub_10018DD0(_BYTE *a1, int a2);
// int __usercall sub_10018E70@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>);
// signed int __usercall sub_10018EA0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5);
// char *__usercall sub_10019070@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>);
// int __usercall sub_100190D0@<eax>(int a1@<esi>, int a2, _DWORD *a3);
// int __usercall sub_10019160@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4);
// char **__usercall sub_100191B0@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3);
// const char *__usercall sub_10019210@<eax>(int a1@<eax>);
// int __usercall sub_10019230@<eax>(unsigned int a1@<ebx>);
// int __usercall sub_10019270@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5);
// int __usercall sub_10019300@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4);
// int __usercall sub_10019450@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>);
// int __usercall sub_100194F0@<eax>(int result@<eax>);
char *__cdecl sub_10019530(int a1, char *a2, int a3, const char *a4);
// int __usercall sub_100196E0@<eax>(int a1@<eax>);
// int __usercall sub_10019710@<eax>(int a1@<esi>);
void __cdecl sub_10019740(int (**a1)(void), char **a2, _DWORD *a3);
int sub_10019BB0();
void *sub_10019C00();
char *sub_10019C60();
char sub_10019C80();
char __cdecl sub_10019C90(int a1, int a2, unsigned int a3);
// int *__usercall sub_10019CD0@<eax>(_DWORD *a1@<ebx>, int a2);
char **sub_10019D20();
int __cdecl sub_10019D30(_DWORD *a1, int a2, int a3);
int __cdecl sub_10019DE0(int a1, int a2, int a3, const char *a4, const char *a5);
// char *__usercall sub_10019FF0@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6);
char *__cdecl sub_1001A0B0(char a1);
int *__cdecl sub_1001A150(_BYTE *a1);
// int __usercall sub_1001A210@<eax>(int a1@<eax>);
// signed int __usercall sub_1001A370@<eax>(int a1@<esi>);
int __cdecl sub_1001A3E0(int, int); // weak
char **sub_1001A6C0();
// int __usercall sub_1001A6D0@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6);
int __cdecl sub_1001A7C0(char *a1);
int sub_1001AA00();
int __cdecl sub_1001AAE0(int a1, int a2, char a3);
int __cdecl sub_1001AB30(int a1);
int __cdecl sub_1001AB40(void *); // idb
int __cdecl sub_1001ABC0(int a1, int a2);
signed int __cdecl sub_1001ABF0(int a1, int a2, int a3);
char __cdecl sub_1001AC10(_DWORD *a1);
char __cdecl sub_1001AD20(int a1, unsigned int a2);
bool __cdecl sub_1001AD50(const void **a1, int a2);
bool __cdecl sub_1001AD80(const void **a1, int a2);
bool __cdecl sub_1001ADB0(const void **a1, int a2);
bool __cdecl sub_1001ADE0(const void **a1, int a2);
bool __cdecl sub_1001AE10(const void **a1, int a2);
bool __cdecl sub_1001AE40(int a1, int a2);
bool __cdecl sub_1001AE80(int a1, int a2);
bool __cdecl sub_1001AEC0(const void **a1, int a2);
bool __cdecl sub_1001AEF0(const void **a1, int a2);
char __cdecl sub_1001AF20(int a1, unsigned int a2);
bool __cdecl sub_1001AF50(const void **a1, int a2);
bool __cdecl sub_1001AF80(const void **a1, int a2);
bool __cdecl sub_1001AFB0(const void **a1, int a2);
bool __cdecl sub_1001AFE0(const void **a1, int a2);
bool __cdecl sub_1001B010(const void **a1, int a2);
bool __cdecl sub_1001B040(const void **a1, int a2);
bool __cdecl sub_1001B070(const void **a1, int a2);
bool __cdecl sub_1001B0A0(const void **a1, int a2);
bool __cdecl sub_1001B0D0(const void **a1, int a2);
bool __cdecl sub_1001B100(const void **a1, int a2);
int __cdecl sub_1001B130(int a1, int a2, int a3);
// void __cdecl __noreturn exit_0(int);
int __cdecl sub_1001B1A0(int a1, char a2);
int __cdecl sub_1001B1C0(int a1, int a2, int a3);
int __cdecl sub_1001B1F0(int a1, int a2, int a3, int a4);
int __cdecl sub_1001B220(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1001B260(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_1001B2A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
char __cdecl sub_1001B2F0(int a1);
char __cdecl sub_1001B320(int a1);
char __cdecl sub_1001B330(int a1, int a2);
signed int __cdecl sub_1001B4B0(int a1);
signed int __cdecl sub_1001B4F0(int a1, int a2, int a3);
char __cdecl sub_1001B590(int a1);
char __cdecl sub_1001B5F0(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_1001B660(char *a1);
int __cdecl sub_1001B700(int a1, int a2, int a3);
bool __cdecl sub_1001B770(int a1, unsigned int a2, int a3);
char __cdecl sub_1001B800(int a1, int a2, char a3, char a4);
char __cdecl sub_1001B8B0(int a1);
char __cdecl sub_1001B8C0(int a1, void (__cdecl *a2)(int));
int (__cdecl *__cdecl sub_1001B940(int a1, const char *a2))(const char *);
signed int __cdecl sub_1001B990(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_1001B9E0(int a1, int a2, int a3, size_t a4, char *a5);
int sub_1001BB60();
const char *__cdecl sub_1001BB70(unsigned int a1);
int __cdecl sub_1001BB90(int a1, int a2, int a3, int a4);
int __cdecl sub_1001BC40(int a1);
int __cdecl sub_1001BC60(int a1);
char *sub_1001BC80(char *a1, ...);
// char *__usercall sub_1001BCC0@<eax>(char a1@<al>, unsigned __int8 a2@<cl>);
// char __usercall sub_1001BCE0@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5);
int sub_1001BEC0();
int sub_1001BEE0();
int __cdecl sub_1001BF00(int a1, int a2);
int __cdecl sub_1001BF60(int a1);
int __cdecl sub_1001BF70(int a1, int a2);
int __cdecl sub_1001BFD0(int a1);
bool __cdecl sub_1001BFE0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1001C120(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1001C4D0(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9);
bool __cdecl sub_1001C920(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9);
bool __cdecl sub_1001CDE0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1001D1A0(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9);
bool __cdecl sub_1001D5A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1001D960(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9);
bool __cdecl sub_1001DEA0(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9);
bool __cdecl sub_1001E280(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1001E640(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1001E9E0(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9);
bool __cdecl sub_1001EDE0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1001F180(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9);
bool __cdecl sub_1001F760(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9);
bool __cdecl sub_1001FB50(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
int sub_1001FEF0();
// BOOL __usercall sub_1001FF20@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6);
// bool __usercall sub_10020090@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9);
char __cdecl sub_10020300(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
bool __cdecl sub_10020600(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
bool __cdecl sub_100206B0(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8);
const char *__cdecl sub_100206F0(int a1, int a2);
char __cdecl sub_10020730(int a1, int *a2, unsigned int a3);
signed int __cdecl sub_100214E0(int a1, int a2);
char **__cdecl sub_10021560(int a1);
int (**sub_100215A0())();
int (__cdecl *__cdecl sub_100215B0(const char *a1))(const char *);
const char *sub_100215D0();
__int64 sub_100215E0();
const char *sub_100215F0();
// int __usercall sub_10021600@<eax>(_BYTE *a1@<edi>, int a2);
signed int __cdecl sub_10021650(int a1, int a2);
int sub_10021680(); // weak
// int __usercall sub_100217A0@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3);
char __cdecl sub_10021B20(int a1, const void **a2, unsigned int a3);
char **__cdecl sub_10022940(int a1);
char __thiscall sub_100229B0(void *this);
// char __usercall sub_10022A20@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4);
// void *__usercall sub_10022A60@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4);
char __cdecl sub_10022B00(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10022B40(char a1, char a2, void *a3);
char __cdecl sub_10022BA0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10022BE0(char a1, char a2, void *a3);
char __cdecl sub_10022C10(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10022C50(char a1, char a2, void *a3);
char __cdecl sub_10022C90(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10022CD0(char a1, char a2, void *a3);
char __cdecl sub_10022D20(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10022D60(char a1, char a2, void *a3);
char __cdecl sub_10022DA0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10022DE0(char a1, char a2, void *a3);
char __cdecl sub_10022E20(char a1, void *a2);
char __cdecl sub_10022E50(char a1, void *a2);
char __cdecl sub_10022E80(char a1, void *a2);
char __cdecl sub_10022EB0(char a1, void *a2);
char __cdecl sub_10022EE0(char a1, void *a2);
char __cdecl sub_10022F10(char a1, void *a2);
char __cdecl sub_10022F40(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10022F80(char a1, char a2, void *a3);
char __cdecl sub_10022FD0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10023010(char a1, char a2, void *a3);
char __cdecl sub_10023040(char a1, void *a2);
char __cdecl sub_10023070(char a1, void *a2);
char __cdecl sub_100230A0(char a1, void *a2);
char __cdecl sub_100230D0(int a1, char a2, char a3, int a4, void *a5);
bool __cdecl sub_10023470(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_100234E0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10023540(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_100235B0(char a1, _BYTE *a2);
char __thiscall sub_100235F0(void *this);
char __cdecl sub_10023660(char a1, int a2);
char __cdecl sub_10023690(char a1, int a2);
char __cdecl sub_100236C0(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6);
int __cdecl sub_10023890(int a1);
bool __cdecl sub_100238D0(void *a1);
int __cdecl sub_10023910(char a1);
char __cdecl sub_10023990(int a1);
char __cdecl sub_100239F0(char a1);
char __cdecl sub_10023A20(char a1, int a2);
char __cdecl sub_10023A60(char a1);
BOOL __cdecl sub_10023A90(unsigned __int8 a1);
// BOOL __usercall sub_10023AA0@<eax>(unsigned __int8 a1@<al>, char a2);
bool __cdecl sub_10023AD0(char a1, char a2, unsigned __int8 a3, int a4);
bool __cdecl sub_10023C80(unsigned __int8 a1, int a2);
char __cdecl sub_10023CC0(unsigned __int8 a1, char a2);
bool __cdecl sub_10023D10(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6);
signed int __cdecl sub_10023E00(char a1, char a2);
int __cdecl sub_10023E60(char a1);
signed int __cdecl sub_10023EA0(char a1, char a2, char a3);
int __cdecl sub_10023F10(char a1);
int __cdecl sub_10023F50(char a1);
char __cdecl sub_10023F90(char a1, int a2);
char __cdecl sub_10023FB0(char a1, int a2);
char __cdecl sub_10023FE0(char a1, int a2);
char __cdecl sub_10024030(char a1, int a2);
char __cdecl sub_10024060(char a1, int a2);
char __cdecl sub_10024080(int a1);
char __cdecl sub_100240A0(char a1);
char sub_100240D0();
BOOL __cdecl sub_10024170(int a1, int a2);
char __cdecl sub_10024190(int a1, char a2, int a3, int a4, int a5);
char __thiscall sub_100241D0(void *this);
// _DWORD *__usercall sub_100241F0@<eax>(int a1@<eax>, int a2@<esi>, char *a3, char *a4);
int sub_10024220(); // weak
int sub_10024280(); // weak
char __cdecl sub_100242D0(int a1, int a2);
_DWORD *sub_100243D0();
signed int __cdecl sub_10024460(_BYTE *a1, char a2, int a3);
int __cdecl sub_100244B0(int, float, float, int, int); // idb
unsigned int __cdecl sub_100245A0(char *a1, char a2, char a3, char a4, int a5);
unsigned int __cdecl sub_100245F0(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5);
unsigned int __cdecl sub_100246B0(void *a1, size_t a2, int a3);
int __cdecl sub_10024710(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
int __cdecl sub_10024760(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5);
int __cdecl sub_10024800(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
char __cdecl sub_100248B0(unsigned __int16 a1, _BYTE *a2, _WORD *a3);
double __cdecl sub_10024910(int a1);
char __cdecl sub_10024960(int a1, int a2);
char __cdecl sub_10024A80(int a1);
bool __cdecl sub_10024A90(unsigned int a1);
int __cdecl sub_10024AC0(int, float); // idb
int __cdecl sub_10024AE0(int, float); // idb
bool __cdecl sub_10024B00(int a1, void *a2, int a3);
char __cdecl sub_10024B80(unsigned __int16 a1);
bool __cdecl sub_10024BF0(int a1, void *a2);
char __cdecl sub_10024C20(unsigned __int16 a1);
char __cdecl sub_10024CC0(char a1, char a2, char a3, int a4, void *a5);
int __cdecl sub_10024DD0(char a1);
char __cdecl sub_10024E20(int a1, int a2);
char __cdecl sub_10024E70(int a1, int a2);
char __cdecl sub_10024F20(int a1, int a2);
char __cdecl sub_10024F80(int a1, int a2);
char sub_10025050();
char sub_10025060();
signed int sub_100250E0();
// char __usercall sub_100250F0@<al>(unsigned __int8 a1@<al>, char a2, void *a3);
char __cdecl sub_100251D0(int a1, char a2, void *a3);
int __cdecl sub_10025250(char a1);
// int __usercall sub_10025260@<eax>(char *a1@<eax>, char a2@<cl>);
// char __usercall sub_10025270@<al>(char a1@<bl>, char a2);
char __cdecl sub_10025330(char a1, char a2);
int __cdecl sub_10025350(unsigned __int8 *a1);
unsigned int __cdecl sub_10025370(void *a1);
unsigned int __cdecl sub_10025390(void *a1);
unsigned int __cdecl sub_100253B0(void *a1);
unsigned int __cdecl sub_100253D0(void *a1);
unsigned int __cdecl sub_100253F0(void *a1);
unsigned int __cdecl sub_10025410(void *a1);
int __cdecl sub_10025470(unsigned __int8 *a1, int a2);
int __cdecl sub_100254A0(int a1, unsigned int a2);
__int16 __cdecl sub_10025590(int a1, unsigned int a2);
__int16 __cdecl sub_100255E0(unsigned int *a1, _WORD *a2, _WORD *a3);
int __cdecl sub_10025660(int a1);
char __cdecl sub_10025670(signed int a1, _DWORD *a2, _DWORD *a3);
char *__cdecl sub_100256B0(const char *a1, int a2);
// char *__usercall sub_10025720@<eax>(char *result@<eax>);
void __cdecl sub_10025750(char *a1);
void __cdecl sub_10025810(char *a1, char *a2);
void *__cdecl sub_10025870(int a1);
int __cdecl sub_10025A00(int a1, int a2);
// char __usercall sub_10025B40@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5);
signed int __cdecl sub_10025C10(_DWORD *a1, char *a2);
BOOL __cdecl sub_10025CF0(unsigned int a1);
BOOL __cdecl sub_10025D10(int a1);
_DWORD __cdecl sub_10025D30(_DWORD); // weak
unsigned int __cdecl sub_10025D40(int a1, char a2);
signed int __cdecl sub_10025DA0(void *a1, int a2, unsigned int a3);
int __cdecl sub_10025DC0(int a1, int a2, int a3);
char __cdecl sub_10025DE0(const char *a1, const char *a2);
int __cdecl sub_10025F20(int a1, int a2, unsigned int a3);
int sub_10025FA0();
void __cdecl sub_10025FB0(int a1);
int __cdecl sub_10025FE0(int a1);
bool __cdecl sub_10026000(int a1);
void *__cdecl sub_10026030(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5);
// unsigned int __usercall sub_10026070@<eax>(int a1@<edx>, int a2, int a3);
// int __usercall sub_10026090@<eax>(int result@<eax>, int a2@<ecx>);
char __cdecl sub_100260B0(void (__cdecl *a1)(_DWORD), int a2);
signed int __cdecl sub_100260E0(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5);
void __cdecl sub_100261C0(int a1, int a2, int a3);
// void *__usercall sub_10026270@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3);
void __cdecl sub_100264F0(int a1, int a2);
char __cdecl sub_100265C0(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4);
// int __usercall sub_10026630@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9);
// int __usercall sub_10026990@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7);
int __cdecl sub_10026AA0(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10);
char __cdecl sub_10026C30(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3);
// char __usercall sub_10026D80@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5);
char __cdecl sub_10026ED0(int a1, int a2);
signed int __cdecl sub_10026F10(int a1, int a2);
bool __cdecl sub_10026F70(signed int a1);
int sub_10026FE0();
char sub_10027300();
char sub_10027520();
char sub_10027720();
char sub_100278A0();
char sub_10027A20();
char sub_10027B90();
char sub_10027C90();
char sub_10027DF0();
char sub_10027F50();
char sub_100280B0();
char sub_10028220();
char sub_10028380();
char sub_100284E0();
char sub_10028700();
char sub_10028860();
char sub_100289C0();
char sub_10028B20();
char sub_10028C90();
char sub_10028DF0();
char sub_10028F50();
char sub_10029170();
char sub_10029370();
char sub_100294F0();
char sub_10029670();
char sub_100297E0();
char sub_100298D0();
char sub_10029A30();
char sub_10029B90();
char sub_10029CF0();
char sub_10029E60();
char sub_10029FC0();
char sub_1002A120();
char sub_1002A320();
char sub_1002A480();
char sub_1002A5E0();
char sub_1002A740();
char sub_1002A8B0();
char sub_1002AA10();
char sub_1002AB70();
char sub_1002B110();
char sub_1002B320();
char sub_1002B510();
char sub_1002B680();
char sub_1002B7F0();
char sub_1002B950();
char sub_1002BA40();
char sub_1002BBA0();
char sub_1002BD00();
char sub_1002BE60();
char sub_1002BFD0();
char sub_1002C130();
char sub_1002C290();
char sub_1002C490();
char sub_1002C5F0();
char sub_1002C750();
char sub_1002C8B0();
char sub_1002CA20();
char sub_1002CB80();
char sub_1002CCE0();
char sub_1002CEF0();
char sub_1002D0E0();
char sub_1002D250();
char sub_1002D3C0();
char sub_1002D520();
char sub_1002D610();
char sub_1002D770();
char sub_1002D8D0();
char sub_1002DA30();
char sub_1002DBA0();
char sub_1002DD00();
char sub_1002DE60();
char sub_1002E060();
char sub_1002E1C0();
char sub_1002E320();
char sub_1002E480();
char sub_1002E5F0();
char sub_1002E750();
char **sub_1002E8B0();
int __cdecl sub_1002E8C0(int a1, int a2, int a3);
// int (__cdecl *__usercall sub_1002E8E0@<eax>(int a1@<eax>, int a2@<ecx>))(int);
// int __usercall sub_1002E8F0@<eax>(unsigned __int8 *a1@<eax>, int a2);
int (__cdecl *__cdecl sub_1002EB20(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1002EB70(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1002EBC0(int a1, unsigned __int8 *a2))(int);
int (__cdecl *__cdecl sub_1002EC10(int a1))(int);
int __cdecl sub_1002EC90(int a1, int a2);
int (__cdecl *__cdecl sub_1002ED10(int a1, unsigned __int8 *a2, char a3))(int);
int (__cdecl *__cdecl sub_1002ED60(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1002EDA0(int a1, int a2, int a3))(int);
int __cdecl sub_1002EE00(char a1);
bool __cdecl sub_1002EE50(unsigned __int8 a1, char a2, unsigned int a3);
bool __cdecl sub_1002EEE0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6);
char __cdecl sub_1002EF80(char a1);
char __cdecl sub_1002F000(char a1, int a2);
// int __usercall sub_1002F170@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3);
// int __usercall sub_1002F1B0@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3);
signed int sub_1002F1F0();
char __cdecl sub_1002F200(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_1002F260(char a1, void *a2);
char __cdecl sub_1002F380(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1002F400(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6);
int __cdecl sub_1002F5B0(int a1, int a2);
char __cdecl sub_1002F5D0(char a1, char a2, char a3, char a4, char a5, int a6, char a7, __int16 a8, char *a9);
char __cdecl sub_1002F6A0(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
int __cdecl sub_1002F700(char a1, char a2);
// bool __usercall sub_1002F7B0@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3);
// char __usercall sub_1002F7E0@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6);
char __cdecl sub_1002F880(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1002F900(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1002F980(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1002FA00(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1002FA80(char a1);
int __cdecl sub_1002FB20(char a1);
_DWORD __cdecl sub_1002FB50(char); // weak
int __cdecl sub_1002FB60(char a1, char *a2);
int __cdecl sub_1002FBB0(char a1);
int __cdecl sub_1002FBD0(int, void *); // idb
// int __usercall sub_1002FC30@<eax>(char a1@<al>);
BOOL __cdecl sub_1002FC60(char a1, int a2);
int __cdecl sub_1002FC90(int, char, int, int, void *); // idb
char __cdecl sub_1002FCC0(void *a1);
BOOL __cdecl sub_1002FCE0(int a1);
char __cdecl sub_1002FD00(int a1, char a2, int a3, int a4, void *a5);
bool __cdecl sub_1002FD30(char a1, void *a2);
// signed int __usercall sub_1002FD70@<eax>(char a1@<al>);
bool __cdecl sub_1002FD90(char a1, void *a2);
bool __cdecl sub_1002FE80(char a1, char a2, int a3, int a4, void *a5);
char __cdecl sub_1002FEB0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_1002FF50(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1002FFD0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10030040(char a1, void *a2);
char __cdecl sub_100300C0(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10030140(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_100301C0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10030230(char a1, char a2, char a3, unsigned __int8 *a4, int a5);
char __cdecl sub_10030340(char a1, void *a2);
bool __cdecl sub_10030360(unsigned __int8 a1, char *a2);
char __cdecl sub_100303A0(int a1, char a2, int a3, int a4, void *a5);
BOOL sub_100303E0();
char __cdecl sub_10030440(int a1, char *a2);
BOOL __cdecl sub_10030530(int a1, int a2);
char __cdecl sub_10030550(int a1, char a2, int a3, int a4, char *a5);
char __cdecl sub_10030590(int a1, int a2);
BOOL __cdecl sub_10030640(int a1, int a2);
char __cdecl sub_10030660(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_100306A0(void *a1);
char __cdecl sub_100306C0(void *a1);
char __cdecl sub_10030810(int a1, char a2, char a3, int a4, void *a5, size_t a6);
char __cdecl sub_100309B0(char a1);
// __int16 __usercall sub_100309F0@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_10030A00(unsigned __int8 a1, char *a2);
char __cdecl sub_10030AD0(char a1, char a2, char a3, int a4, char *a5, unsigned int a6);
char __cdecl sub_10030B50(unsigned __int16 a1, char *a2, char a3);
char __cdecl sub_10030C80(char a1, int a2);
bool __cdecl sub_10030D00(void *a1);
char __cdecl sub_10030D50(char a1, int a2);
// __int16 __usercall sub_10030E30@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_10030E40(unsigned __int8 a1, int *a2, const void *a3);
char __cdecl sub_10030ED0(unsigned __int8 a1, char a2);
bool __cdecl sub_10030F90(__int16 a1, char a2, int a3, int a4, void *a5);
char __cdecl sub_10031090(char a1);
char __cdecl sub_100310D0(char a1);
// int __cdecl BMP_get_bm_def(_DWORD); weak
// int __cdecl FNT_get_fnt_hdr(_DWORD); weak
// int __cdecl BMP_get_xfrm(_DWORD); weak
// int TXT_get_static_string(void); weak
char __cdecl sub_10031100(float a1, int a2, int a3);
void __cdecl sub_100311B0(int a1, int a2, int a3, float *a4, int a5);
void __cdecl sub_100312E0(int a1, int a2, int a3, int a4, int a5, float a6);
char __cdecl sub_10031350(float a1, int a2, int a3);
int __cdecl j_gdi_pvg_begin(_DWORD); // weak
int __cdecl sub_100315C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD); // weak
int __cdecl j_gdi_pvg_color_u32(_DWORD); // weak
int __cdecl j_gdi_pvg_disable(_DWORD); // weak
int __cdecl sub_10031640(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl j_gdi_pvg_enable(_DWORD); // weak
int j_gdi_pvg_end(void); // weak
int j_gdi_pvg_flush(void); // weak
int sub_100316C0();
int __cdecl sub_100316D0(float); // idb
int __cdecl j_gdi_pvg_load_identity(_DWORD); // weak
int __cdecl j_gdi_pvg_make_window_active(_DWORD); // weak
int __cdecl j_gdi_pvg_make_window_current(_DWORD); // weak
int __cdecl j_gdi_pvg_matrix_mode(_DWORD); // weak
int __cdecl sub_10031720(float, float, float, float, float, float); // idb
int j_gdi_pvg_pop_attrib(void); // weak
int __cdecl j_gdi_pvg_push_attrib(_DWORD); // weak
int __cdecl j_gdi_pvg_read_matrix(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_gdi_pvg_text_out_verts(_DWORD, _DWORD, _DWORD); // weak
int j_gdi_pvg_update_display_wdw(void); // weak
int __cdecl sub_100317B0(float, float); // idb
int __cdecl j_gdi_pvg_viewport(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_100317E0(int a1, int a2, int a3);
int __cdecl j_gdi_pvg_destroy_window(_DWORD); // weak
int sub_10031820();
int __cdecl sub_10031870(int a1);
int __cdecl sub_10031880(int a1);
int sub_100318A0();
int __cdecl sub_100318C0(int a1, int a2);
__int16 __cdecl sub_100318F0(int a1);
int sub_10031910();
int __cdecl sub_10031930(int a1, int a2, int a3, int a4);
int j_TSK_pvg_get_us_timer(void); // weak
int __cdecl sub_10031970(int a1, int a2, int a3, int a4);
int __cdecl sub_100319A0(int a1);
int __cdecl sub_100319C0(int a1);
int __cdecl sub_100319E0(int a1, int a2);
int __cdecl sub_10031A10(int a1, int a2, int a3, int a4);
int __cdecl sub_10031A40(int a1, int a2);
int __cdecl sub_10031A70(int a1);
int __cdecl sub_10031A90(int a1);
char __cdecl sub_10031AB0(int a1, int a2);
int __cdecl sub_10031B20(_BYTE *a1);
int __cdecl sub_10031B60(int a1, int a2);
int __cdecl sub_10031B90(int a1, int a2);
int __cdecl sub_10031BB0(int a1);
int __cdecl sub_10031BF0(int a1, int a2, int a3);
char __cdecl sub_10031C10(int a1, int a2, int a3);
int __cdecl sub_10031C50(int, void *, int, void *); // idb
int __cdecl sub_10031C90(int a1, int a2, int a3);
int __cdecl sub_10031CC0(int a1, int a2, int a3);
int __cdecl sub_10031CE0(int a1, int a2, int a3);
int __cdecl sub_10031D40(int a1, int a2, int a3);
char __cdecl sub_10031D80(int a1, int a2, int a3);
int __cdecl sub_10031DC0(int, void *, int, void *); // idb
void sub_10031E10();
signed int __fastcall sub_10031E20(char *a1);
// int __usercall sub_10031E70@<eax>(unsigned int a1@<eax>);
double __cdecl sub_10031E80(int a1, int a2, float a3, float a4, float a5);
double __cdecl sub_10032020(int a1, int a2, float a3);
int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD); // weak
signed int __cdecl sub_10032090(unsigned int a1);
int __cdecl j_FIL_vfs_delete(_DWORD); // weak
int j_FIL_vfs_dyn_linker(void); // weak
int __cdecl sub_100320F0(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_10032160(unsigned int a1, void *a2, int a3);
signed int __cdecl sub_100321A0(unsigned int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD); // weak
signed int __cdecl sub_10032230(unsigned int a1, int a2, int a3, int a4);
__int64 __cdecl sub_10032280(int a1);
int __cdecl sub_100322A0(int a1, int a2, int a3);
int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_100322D0(int a1, int a2, int a3, char a4);
char __cdecl sub_100322F0(int a1);
signed int __cdecl sub_10032320(unsigned int a1, int a2, int a3);
int __cdecl sub_10032340(int a1, int a2, int a3);
void __cdecl sub_10032360(int a1, _BYTE *a2);
int __cdecl sub_10032390(int a1, int a2);
int __cdecl j_HWM_pvg_get_color(_DWORD, _DWORD, _DWORD); // weak
int j_HWM_pvg_hsdb_get_lrus_online(void); // weak
int __cdecl j_HWM_pvg_log_err(_DWORD); // weak
int __cdecl j_HWM_pvg_read_reg(_DWORD); // weak
void sub_100323F0();
signed int sub_10032400();
int __cdecl sub_10032410(unsigned int a1);
int sub_10032440(void); // weak
int __cdecl sub_10032450(int a1, int a2);
// int __usercall sub_100324B0@<eax>(const char **a1@<esi>);
// int __usercall sub_100327B0@<eax>(int a1@<eax>, int a2@<ecx>);
signed int __cdecl sub_100327D0(int a1);
__int16 __cdecl sub_100328A0(int a1, int a2, int a3, int a4);
int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD); // weak
__int16 __cdecl sub_100328E0(int a1, _DWORD *a2, _BYTE *a3);
int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_create_id(_DWORD); // weak
int __cdecl sub_10032980(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl sub_100329D0(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD); // weak
int __cdecl sub_10032A40(int a1);
int __cdecl sub_10032A80(int a1);
int __cdecl sub_10032AC0(int a1);
int __cdecl sub_10032B00(int a1);
int __cdecl sub_10032B40(int a1, int a2, int a3, int a4);
int __cdecl sub_10032BB0(int a1, int a2, int a3);
int sub_10032C50(void); // weak
unsigned int __cdecl sub_10032C60(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6);
// int __usercall sub_10032E10@<eax>(int a1@<esi>);
int __cdecl sub_10032EC0(int a1, unsigned __int64 a2);
// int __usercall sub_10032F70@<eax>(int a1@<ebx>, unsigned __int64 a2);
unsigned int __cdecl sub_10033000(int a1, void *a2, int a3, int a4, int a5);
void __cdecl sub_10033150(__int16 a1, _BYTE *a2);
int __cdecl j_mem_unmap(_DWORD, _DWORD); // weak
char sub_10033190();
double __cdecl sub_100331E0(char a1);
char sub_10033270();
char __cdecl sub_10033290(char a1);
char __cdecl sub_10033300(int a1);
void __cdecl sub_10033550(float *a1, float *a2, float *a3, int a4);
int __cdecl sub_100335B0(float, float, int); // idb
void __cdecl sub_10033770(int a1, int a2, float *a3, float *a4, float *a5);
void __cdecl sub_10033B40(int a1, int a2, float *a3, float *a4);
void __cdecl sub_10033C20(float *a1, float *a2, int a3);
double __cdecl sub_10033CE0(int a1, int a2);
int __cdecl sub_10033D00(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
unsigned int __cdecl sub_10033E10(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8);
int __cdecl sub_10033EF0(int a1);
int __cdecl sub_10034240(int a1);
unsigned int __cdecl sub_10034420(int a1);
int __cdecl sub_10034950(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8);
_WORD *__cdecl sub_100349B0(int a1);
int __cdecl sub_10034A10(int a1, int a2, char a3);
void sub_10034B00();
int __cdecl sub_10034B10(int a1, _BYTE *a2, int a3);
char __cdecl sub_10034B50(char a1, char a2);
int __cdecl sub_10034B70(int a1, int a2, _BYTE *a3, __int16 a4, int a5, __int16 a6, int a7);
bool __cdecl sub_100353B0(_BYTE *a1);
bool __cdecl sub_10035450(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, char a5);
int __cdecl sub_10035560(int a1, _BYTE *a2, int a3);
int __cdecl sub_10035650(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
int __cdecl sub_100358B0(int a1, __int16 a2, __int16 a3, char a4);
int __cdecl sub_10035E00(int a1);
int __cdecl sub_10035FD0(int a1, signed int a2, signed int a3);
int __cdecl sub_100364A0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
char __cdecl sub_10036590(int a1);
char *__cdecl sub_10036700(int a1);
int __cdecl sub_10036850(int a1, int a2);
unsigned int __cdecl sub_10036970(int a1, int a2);
int __cdecl sub_10036B10(int a1, int a2, int a3);
int __cdecl sub_10036B90(int a1, int a2, int a3);
char __cdecl sub_10036C10(int a1, signed int a2, int a3, int a4);
int __cdecl sub_10036D20(int a1, signed int a2, signed int a3);
int __cdecl sub_10036E10(int a1, signed int a2, int a3, int a4);
int __cdecl sub_10036F10(int a1, int a2);
char *__cdecl sub_10037040(int a1, signed int a2, int a3, int *a4);
char *__cdecl sub_10037180(int a1, signed int a2, int a3, int *a4);
int __cdecl sub_100373D0(int a1, signed int a2, int a3);
int __cdecl sub_10037510(int a1, signed int a2, int a3);
double __cdecl sub_10037650(float a1, float a2);
double __cdecl sub_100376F0(float a1, float a2);
double __cdecl sub_10037790(double a1, double a2);
double __cdecl sub_100377F0(float a1, float a2);
int __cdecl sub_10037870(double); // idb
double __cdecl sub_10037890(float a1);
int __cdecl sub_100378D0(int a1, int a2);
int __cdecl sub_100378F0(double); // idb
double __cdecl sub_10037920(float a1, float a2);
int __cdecl sub_10037990(float, int, int); // idb
int __cdecl sub_100379B0(int a1, int a2);
int __cdecl sub_100379D0(float); // idb
double __cdecl sub_10037A30(double a1, double a2);
double __cdecl sub_10037AA0(float a1, float a2);
int __cdecl sub_10037B30(int a1, int a2, int a3);
int __cdecl sub_10037B60(float, int, int); // idb
int __cdecl sub_10037B90(unsigned __int8 a1, unsigned int a2);
unsigned int __cdecl sub_10037BB0(unsigned int *a1, signed int a2, unsigned int a3);
// int __cdecl SIM_proc_rqst(_DWORD); weak
// int SYS_exit_krnl(void); weak
// int __cdecl SYS_pvg_is_booting(_DWORD); weak
// int SYS_enter_krnl(void); weak
// int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD); weak
// int __cdecl gdi_pvg_bitblt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_draw_pixels(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int gdi_pvg_init(void); weak
// int __cdecl gdi_pvg_line_width(_DWORD); weak
// int __cdecl gdi_pvg_ortho(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_vertex2f(_DWORD, _DWORD); weak
// int __cdecl gdi_pvg_create_window(_DWORD); weak
// int __cdecl TSK_pvg_get_crit_lvl(_DWORD); weak
// int TSK_pvg_get_id(void); weak
// int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_run_state(_DWORD); weak
// int TSK_pvg_get_timer(void); weak
// int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_release_smphr(_DWORD); weak
// int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_set_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_suspend(_DWORD); weak
// int __cdecl TSK_pvg_wait_evnt(_DWORD); weak
// int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_close(void); weak
// int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_read(void); weak
// int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_size(_DWORD); weak
// int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD); weak
// int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD); weak
__int32 __cdecl j__atol(const char *);
// char *__cdecl strstr(const char *, const char *);
// void *__cdecl memset(void *, int, size_t);
// char *__cdecl strncpy(char *, const char *, size_t);
// int __cdecl strncmp(const char *, const char *, size_t);
// int sprintf(char *, const char *, ...);
// int _snprintf(char *, size_t, const char *, ...);
// _DWORD __thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *); idb
// double __cdecl atof(const char *);
// char *__cdecl strchr(const char *, int);
// char *__cdecl strncat(char *, const char *, size_t);
// int __cdecl isdigit(int);
// int __cdecl isxdigit(int);
// int __cdecl isspace(int);
// int __cdecl isprint(int);
// void *__cdecl memcpy(void *, const void *, size_t);
// void *__cdecl memcpy_0(void *, const void *, size_t);
// char *__cdecl strrchr(const char *, int);
// int __cdecl tolower(int);
// void *__cdecl memchr(const void *, int, size_t);
// int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
// double __cdecl floor(double);
// int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_1003A3B9(int a1, int a2, char a3);
// char *__cdecl strpbrk(const char *, const char *);
// int *__cdecl _errno();
// unsigned __int32 *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
signed int __cdecl sub_1003B8B5(_DWORD *a1);
signed int __cdecl sub_1003B8EC(_DWORD *a1);
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
// int _getptd(void); weak
// void __cdecl free(void *);
// _DWORD __cdecl _calloc_crt(size_t, _DWORD); weak
void sub_1003C532();
int (*sub_1003C9DF())(void);
void __cdecl sub_1003CA03(); // idb
int __cdecl sub_1003CF5A(int, FILE *); // idb
int __cdecl sub_1003DAEF(int a1);
// int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl isleadbyte(int);
// int __cdecl __check_float_string(int, void *, int); idb
// int __fastcall _inc(_DWORD, _DWORD); weak
// _DWORD __cdecl _whiteout(_DWORD); weak
int __cdecl sub_1004326B(FILE *, int, struct localeinfo_struct *, int); // idb
int __cdecl sub_10044690(int, int, struct localeinfo_struct *); // idb
int __cdecl sub_10044736(int, int, struct localeinfo_struct *); // idb
void sub_10044BA2();
// int _get_sse2_info(void); weak
int sub_10044CF5();
int sub_100451F2();
int __cdecl sub_100453AF(int a1);
int __cdecl sub_100453B9(int a1);
int __cdecl sub_100453C3(int a1);
int __cdecl sub_100454A2(int a1);
DWORD __cdecl sub_100465B7(int a1, int a2, int a3, DWORD dwMoveMethod);
// __int64 __cdecl _lseeki64(int, __int64, int);
_WORD *__cdecl sub_10046753(int a1, int a2, DWORD nNumberOfBytesToWrite);
_WORD *__cdecl sub_10046D75(int a1, int a2, DWORD nNumberOfBytesToWrite);
// _DWORD __cdecl _getbuf(_DWORD); weak
int __cdecl sub_10046E95(signed int a1);
void **sub_10046EF3();
signed int sub_10046EF9();
// int __cdecl _fileno(FILE *);
signed int __cdecl sub_10047819(int a1, int a2);
signed int __cdecl sub_10047D5B(int a1, int a2);
int sub_10048965();
int __cdecl sub_1004914A(FILE *); // idb
int __cdecl sub_1004926A(int, FILE *); // idb
// int __cdecl _mbtowc_l(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes, _locale_t Locale);
// int __cdecl mbtowc(wchar_t *, const char *, size_t);
int __cdecl sub_1004A1A9(int a1, int a2, int a3);
signed int __cdecl sub_1004A67B(signed int a1);
signed int __cdecl sub_1004A6FC(signed int a1);
// _DWORD __cdecl __lock_fhandle(_DWORD); weak
void __cdecl sub_1004A80D(signed int a1);
// int __cdecl _putwch_nolock(__int16 Buffer); idb
// _DWORD __cdecl flsall(_DWORD); weak
int sub_1004AB0E();
// int __cdecl _read(int, void *, unsigned int);
signed int __cdecl sub_1004B451(signed int a1);
unsigned int __cdecl sub_1004B5F0(unsigned int a1);
bool __cdecl sub_1004B610(int a1);
int __cdecl sub_1004B6E0(int a1);
int __cdecl sub_1004B700(int a1, int a2);
signed int __cdecl sub_1004B740(int a1, void *a2, unsigned __int16 a3, __int16 a4);
int __cdecl sub_1004B800(int a1);
// int __usercall sub_1004B840@<eax>(int a1@<eax>, int a2@<esi>);
// signed int __usercall sub_1004B8F0@<eax>(int a1@<eax>, int a2@<esi>);
// char __usercall sub_1004BAC0@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_1004BAD0@<eax>(int result@<eax>);
// char __usercall sub_1004BAF0@<al>(int a1@<eax>);
// int __usercall sub_1004BB10@<eax>(int a1@<esi>, unsigned __int8 a2);
int __fastcall sub_1004BB50(int a1, int a2);
// int __usercall sub_1004BB70@<eax>(int a1@<esi>);
// signed int __usercall sub_1004BBB0@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_1004BDC0(int a1);
signed int __cdecl sub_1004C030(unsigned int a1, int a2, int a3);
// int __usercall sub_1004C0D0@<eax>(int a1@<eax>);
// int __usercall sub_1004C0F0@<eax>(int a1@<edi>, int a2);
// signed int __usercall sub_1004C120@<eax>(int a1@<eax>, int a2@<ebx>);
// void __cdecl __noreturn exit_1(int);
// char __usercall sub_1004C210@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>);
// signed int __usercall sub_1004C240@<eax>(int a1@<eax>);
signed int __cdecl sub_1004C270(unsigned int a1);
signed int __cdecl sub_1004C2C0(int a1, int a2);
signed int __cdecl sub_1004C4B0(unsigned int a1, int a2, int a3);
signed int __cdecl sub_1004C510(unsigned int a1, int a2, int a3);
signed int __cdecl sub_1004C6E0(unsigned int a1, int a2, int a3, int a4);
signed int __cdecl sub_1004C740(unsigned int a1, int a2, int a3);
// signed int __usercall sub_1004C760@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_1004D810@<eax>(int a1@<esi>, int a2, unsigned int a3);
// signed int __usercall sub_1004D870@<eax>(int a1@<eax>, int a2, int a3);
// void *__usercall sub_1004E5F0@<eax>(void *a1@<eax>);
unsigned int __cdecl sub_1004E610(int a1, unsigned int a2);
// int __usercall sub_1004E670@<eax>(int result@<eax>);
// int __usercall sub_1004E6B0@<eax>(int result@<eax>);
// unsigned int __usercall sub_1004FDD0@<eax>(int a1@<esi>, int a2);
// void *__usercall sub_1004FED0@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3);
// void *__usercall sub_1004FF50@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3);
// int __usercall sub_1004FFF0@<eax>(int a1@<edi>, int a2, size_t a3);
// int __usercall sub_100500B0@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3);
// int __usercall sub_10050110@<eax>(char *a1@<edi>);
// int __usercall sub_100501D0@<eax>(int a1@<ebx>);
char __cdecl sub_10050290(char *a1, size_t a2, int a3);
char __cdecl sub_100502E0(char *a1, unsigned int a2, int a3);
bool __cdecl sub_10050330(int a1, int a2);
// int __usercall sub_10050360@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7);
// int __usercall sub_10050570@<eax>(void *a1@<eax>, int a2);
char *__cdecl sub_100505C0(int a1, int a2);
signed int __cdecl sub_10050650(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6);
bool __cdecl sub_10050780(void *a1, int a2);
// BOOL __usercall sub_10050800@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_100508A0@<eax>(int result@<eax>);
unsigned int __fastcall sub_10050930(unsigned int a1, int a2);
// int __usercall sub_10050950@<eax>(int result@<eax>);
// int __usercall sub_100509E0@<eax>(int result@<eax>, int a2, int a3);
// int __usercall sub_10050E60@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>);
// void *__usercall sub_10050F10@<eax>(int a1@<edi>);
// int __usercall sub_10050F70@<eax>(int result@<eax>, int a2@<edx>);
// signed int __usercall sub_10051140@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>);
_WORD *__fastcall sub_100511C0(int a1, int a2);
// unsigned int __usercall sub_10051230@<eax>(int a1@<esi>, unsigned int a2);
// unsigned int __usercall sub_100513E0@<eax>(int a1@<esi>, int a2);
// int __usercall sub_100514B0@<eax>(int result@<eax>, int a2@<edi>, int a3);
// int __usercall sub_10051560@<eax>(int result@<eax>, __int16 a2@<cx>);
// unsigned int __usercall sub_100515A0@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3);
// signed int __usercall sub_10051600@<eax>(signed int result@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_100516E0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_10051C80@<eax>(int a1@<eax>);
// int __usercall sub_10051EC0@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4);
// signed int __usercall sub_10051F60@<eax>(int a1@<esi>, int a2);
// unsigned int __usercall sub_10052140@<eax>(int a1@<edi>);
// int __usercall sub_10052280@<eax>(int a1@<eax>, int a2, int a3, int a4);
signed int __cdecl sub_10052530(int a1, int a2);
// signed int __usercall sub_100527F0@<eax>(int a1@<eax>);
// _WORD *__usercall sub_100528C0@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
signed int __cdecl sub_10052AE0(int a1, int a2);
signed int __cdecl sub_10052DF0(int a1, int a2);
signed int __cdecl sub_10053200(int a1, int a2);
int __cdecl sub_10053370(unsigned int a1, _BYTE *a2, unsigned int a3);
signed int __cdecl sub_10053470(int a1);
// signed int __usercall sub_10053490@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10);
// int (__cdecl *__usercall sub_10053930@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD);
// int __usercall sub_10053980@<eax>(int result@<eax>, char a2, char a3, int a4, int a5);
signed int __cdecl sub_100539A0(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_10053D50@<eax>(int a1@<edi>, int a2@<esi>, int a3);
// signed int __usercall sub_10053E90@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4);
// signed int __usercall sub_10053EE0@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9);
// int __usercall sub_10053F80@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4);
signed int __cdecl sub_10053FA0(int a1);
// int __usercall sub_10053FB0@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_10054650@<eax>(int a1@<eax>, int a2, int a3);
// signed int __usercall sub_10055030@<eax>(int a1@<edi>, int a2);
signed int __cdecl sub_10055360(int a1, int a2);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// UINT __stdcall GetConsoleCP();
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall GetLastError();

//-------------------------------------------------------------------------
// Data declarations

int dword_10056DD0[] = { 10 }; // weak
int (__cdecl *off_10056DD4)(int, int, int, int, int) = &sub_10008890; // weak
int dword_10056DD8[] = { 12 }; // weak
int dword_10056DDC[] = { 129 }; // weak
int (__cdecl *off_10056DE0)(int, int, int, int, int) = &sub_100087D0; // weak
int dword_10056DE4[] = { 4 }; // weak
int dword_10056DE8[] = { 18 }; // weak
int (__cdecl *off_10056DEC)(int, int, int, int, int) = &sub_1000E2E0; // weak
int dword_10056DF0[] = { 4 }; // weak
int dword_10056DF4[] = { 26 }; // weak
int (__cdecl *off_10056DF8)(int, int, int, int, int) = &sub_1000E190; // weak
int dword_10056DFC[] = { 28 }; // weak
_UNKNOWN unk_10057440; // weak
_UNKNOWN unk_10057448; // weak
_UNKNOWN unk_10057468; // weak
_UNKNOWN unk_100586AC; // weak
_UNKNOWN unk_100586B0; // weak
_UNKNOWN unk_10058C68; // weak
_UNKNOWN unk_10058E50; // weak
_UNKNOWN unk_10058EA4; // weak
_UNKNOWN unk_100594C0; // weak
_UNKNOWN unk_100594D8; // weak
_UNKNOWN unk_100594F4; // weak
_UNKNOWN unk_10059514; // weak
_UNKNOWN unk_10059600; // weak
void *off_1005A76C = &unk_100F1960; // weak
char byte_1005B21C[] = { '\0' }; // weak
int (__cdecl *off_1005B228)(int) = &sub_10003970; // weak
char byte_1005B22C[] = { '\0' }; // weak
_UNKNOWN unk_1005B22D; // weak
void *tsk_app_hdr_ptr = &tsk_app_hdr; // weak
__int16 word_1005DA40 = 48; // weak
char *(*off_1005E668)[14] = &off_1005E630; // weak
char *off_1005E670 = "1"; // idb
_UNKNOWN unk_1005E69C; // weak
_UNKNOWN unk_1005FD84; // weak
_UNKNOWN unk_10060950; // weak
_UNKNOWN unk_1006095C; // weak
int dword_10061FD4 = 9117; // idb
char *off_10062530 = "/shr_mem/iop_gma_dig_intf.shr"; // weak
_UNKNOWN unk_10062A95; // weak
_UNKNOWN unk_10062ACE; // weak
char byte_10062AD0[] = { '\x0E' }; // weak
char *off_10062B00 = "/shr_mem/udb_intf.shr"; // weak
char byte_10064D78[] = { ' ' }; // weak
char byte_10064D80[] = { ' ' }; // weak
_UNKNOWN unk_10064D88; // weak
char byte_10065DAC[] = { '\x05' }; // weak
char byte_10065DB0[] = { '\b' }; // weak
int dword_10065DB4[] = { 9 }; // weak
char byte_10066394[] = { '\0' }; // weak
char byte_10066395[] = { '\0' }; // weak
char byte_10066396[] = { '\xFF' }; // weak
char byte_10066397[] = { '\xFF' }; // weak
char byte_10066398[] = { '\xFF' }; // weak
char a______[7] = "______"; // weak
char aWgs84[21] = "WGS 84              "; // weak
int dword_1006A050[] = { 0 }; // weak
_UNKNOWN unk_1006A2C0; // weak
_UNKNOWN unk_1006A390; // weak
_UNKNOWN unk_1006A460; // weak
_UNKNOWN unk_1006A530; // weak
_UNKNOWN unk_1006A600; // weak
_UNKNOWN unk_1006A6D0; // weak
_UNKNOWN unk_1006A7A0; // weak
_UNKNOWN unk_1006A870; // weak
_UNKNOWN unk_1006A940; // weak
_UNKNOWN unk_1006AA10; // weak
_UNKNOWN unk_1006AAE0; // weak
_UNKNOWN unk_1006ABB0; // weak
_UNKNOWN unk_1006AC80; // weak
_UNKNOWN unk_1006AD50; // weak
_UNKNOWN unk_1006AE20; // weak
_UNKNOWN unk_1006AEF0; // weak
_UNKNOWN unk_1006AFC0; // weak
_UNKNOWN unk_1006B090; // weak
_UNKNOWN unk_1006B160; // weak
_UNKNOWN unk_1006B230; // weak
_UNKNOWN unk_1006B300; // weak
_UNKNOWN unk_1006B3D0; // weak
_UNKNOWN unk_1006B4A0; // weak
_UNKNOWN unk_1006B570; // weak
_UNKNOWN unk_1006B640; // weak
_UNKNOWN unk_1006B710; // weak
_UNKNOWN unk_1006B7E0; // weak
_UNKNOWN unk_1006B8B0; // weak
_UNKNOWN unk_1006B980; // weak
_UNKNOWN unk_1006BA50; // weak
_UNKNOWN unk_1006BB20; // weak
_UNKNOWN unk_1006BBF0; // weak
_UNKNOWN unk_1006BCC0; // weak
_UNKNOWN unk_1006BD90; // weak
_UNKNOWN unk_1006BE60; // weak
_UNKNOWN unk_1006BF30; // weak
_UNKNOWN unk_1006C000; // weak
_UNKNOWN unk_1006C0D0; // weak
_UNKNOWN unk_1006C1A0; // weak
_UNKNOWN unk_1006C270; // weak
_UNKNOWN unk_1006C340; // weak
_UNKNOWN unk_1006C410; // weak
_UNKNOWN unk_1006C4E0; // weak
_UNKNOWN unk_1006C5B0; // weak
_UNKNOWN unk_1006C680; // weak
_UNKNOWN unk_1006C750; // weak
_UNKNOWN unk_1006C820; // weak
_UNKNOWN unk_1006C8F0; // weak
_UNKNOWN unk_1006C9C0; // weak
_UNKNOWN unk_1006CA90; // weak
_UNKNOWN unk_1006CB60; // weak
_UNKNOWN unk_1006CC30; // weak
_UNKNOWN unk_1006CD00; // weak
_UNKNOWN unk_1006CDD0; // weak
_UNKNOWN unk_1006CEA0; // weak
_UNKNOWN unk_1006CF70; // weak
_UNKNOWN unk_1006D040; // weak
_UNKNOWN unk_1006D110; // weak
_UNKNOWN unk_1006D1E0; // weak
_UNKNOWN unk_1006D2B0; // weak
_UNKNOWN unk_1006D380; // weak
_UNKNOWN unk_1006D450; // weak
_UNKNOWN unk_1006D520; // weak
_UNKNOWN unk_1006D5F0; // weak
_UNKNOWN unk_1006D6C0; // weak
_UNKNOWN unk_1006D790; // weak
_UNKNOWN unk_1006D860; // weak
_UNKNOWN unk_1006DED8; // weak
_UNKNOWN unk_1006F51C; // weak
_UNKNOWN unk_1006F534; // weak
_UNKNOWN unk_1006F5E0; // weak
void *off_1006F5E4 = &unk_1006F554; // weak
_UNKNOWN unk_1006FCEC; // weak
char byte_1006FCED[] = { '\x0E' }; // weak
_UNKNOWN unk_1006FDE8; // weak
__int16 word_1006FDEC[] = { 2 }; // weak
char *off_100707A0[3] = { ".\\test\\tst_tsk_common.c", "$Id$", &off_10070610 }; // weak
_UNKNOWN unk_100707B4; // weak
_BYTE word_10071EC8[540] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  128,
  4,
  0,
  45,
  0,
  37,
  0,
  47,
  0,
  45,
  0,
  44,
  0,
  45,
  0,
  45,
  0,
  37,
  0,
  37,
  0,
  47,
  0,
  45,
  0,
  37,
  0,
  60,
  0,
  61,
  0,
  45,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  0,
  37,
  0,
  37,
  0,
  36,
  0,
  44,
  0,
  36,
  0,
  45,
  32,
  44,
  13,
  0,
  5,
  0,
  5,
  0,
  5,
  0,
  13,
  0,
  5,
  0,
  1,
  0,
  1,
  0,
  9,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  9,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  9,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  0,
  36,
  0,
  36,
  0,
  36,
  0,
  44,
  64,
  45,
  0,
  4,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  0,
  44,
  0,
  44,
  0,
  44,
  0,
  44,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  32,
  0,
  32,
  0,
  32,
  0,
  32,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  65,
  66,
  67,
  68,
  69,
  70,
  0,
  0,
  0,
  0,
  87,
  83,
  0,
  0,
  69,
  78,
  0,
  0
}; // idb
_UNKNOWN unk_10072BE0; // weak
_UNKNOWN unk_10077448; // weak
char byte_10077449[] = { '\0' }; // weak
int (__cdecl *off_10079870)(int, size_t, void *) = &sub_10012A40; // weak
char *off_1007A120 = "/shr_mem/nav_intf.shr"; // weak
char *off_1007A14C = "/shr_mem/pvt_intf.shr"; // weak
int dword_1007AB3C[] = { 88 }; // weak
__int16 word_1007AFEC[] = { 836 }; // weak
char *off_1007B00C = "/shr_mem/iop_a_pkt_intf.shr"; // weak
char *off_1007B020 = "/shr_mem/iop_b_pkt_intf.shr"; // weak
char *off_1007B034 = "/shr_mem/iop_c_pkt_intf.shr"; // weak
char *off_1007B048 = "/shr_mem/iop_d_dbg_pkt_intf.shr"; // weak
char *off_1007B05C = "/shr_mem/iop_d_pkt_intf.shr"; // weak
char *off_1007B070 = "/shr_mem/iop_m_pkt_intf.shr"; // weak
int (*off_1007B650[4])() = { &sub_10013F40, &sub_10013F30, &sub_10013F20, &sub_10013F30 }; // weak
_UNKNOWN unk_1007B6BC; // weak
char byte_1007BC68[] = { '?' }; // weak
int (__cdecl *off_1007BCAC)(int, int) = &sub_100122E0; // weak
int (__cdecl *off_1007BCB0[2])(char, int) = { &sub_100124C0, &sub_10015B60 }; // weak
char *off_1007C468[24] =
{
  "A",
  "AMPS",
  "",
  "",
  "",
  "T",
  "",
  "",
  "",
  "C",
  "",
  "",
  "E",
  "E",
  "",
  "",
  "",
  "",
  "W",
  "W",
  "",
  "F",
  "",
  "FPM"
}; // weak
int dword_1007DBB8[] = { 9032 }; // weak
int dword_1007DBE0[] = { 1600085855 }; // weak
_UNKNOWN unk_1007E810; // weak
int dword_1007E814 = 4294967295; // weak
int dword_1007E818 = 0; // weak
int dword_1007E81C = 4278255615; // weak
int dword_1007E820 = 0; // weak
int dword_1007E82C = 0; // weak
_UNKNOWN unk_1007F038; // weak
_UNKNOWN unk_1007F5E8; // weak
_UNKNOWN unk_1007F5F0; // weak
char byte_1007F5F8[] = { '\x01' }; // weak
char a006D0170[11] = "006-D0170-"; // weak
char *off_1008108C = "006-D0170-"; // weak
int (__cdecl *(*off_10081090)[2])(int, int) = &off_100A27C8; // weak
_UNKNOWN unk_10081608; // weak
char byte_1008160C[] = { '\0' }; // weak
_UNKNOWN unk_10095CB8; // weak
_UNKNOWN unk_10096268; // weak
int (__cdecl *off_10098648[3])(char) = { &sub_1000ECF0, &sub_1000EC00, &sub_1000EBC0 }; // weak
__int16 word_10099138[] = { 43 }; // weak
char byte_1009913C[] = { '\x06' }; // weak
_UNKNOWN unk_10099738; // weak
char *off_100998DC[3] = { "***global-commands***", "..\\lib\\utf\\utf_runner.c", &off_100998F0 }; // weak
char *off_10099A80 = "true"; // weak
char byte_10099A84[] = { '\x01' }; // weak
char *off_10099AE8 = "failure listener"; // weak
_UNKNOWN unk_1009A288; // weak
char *off_1009A488[5] = { "FAIL", "PASS", "normal", "robust", "EQ" }; // weak
char *off_1009A490[3] = { "normal", "robust", "EQ" }; // weak
char *off_1009A498 = "EQ"; // weak
char *off_1009A4B4[7] =
{
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_1009A4C0[4] = { "FALSE", "TRUE", "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
char *off_1009A4C8[2] = { "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
_UNKNOWN unk_1009A780; // weak
_UNKNOWN unk_1009A7BC; // weak
char *off_1009AB78 = "printf_listener"; // weak
__int16 word_1009B7AC = 2573; // weak
int (*off_1009B868[2])() = { &sub_1002E8B0, &sub_1000F420 }; // weak
char *off_1009B918 = "gate_listener"; // weak
__int16 word_1009E0F2[] = { 537 }; // weak
__int16 word_1009E0F8[] = { 1565 }; // weak
__int16 word_1009E0FC[] = { 534 }; // weak
char byte_1009E100[] = { '\x04' }; // weak
__int16 word_1009E102[] = { 6512 }; // weak
int dword_1009E118[] = { 118000 }; // weak
_UNKNOWN unk_1009E220; // weak
_UNKNOWN unk_1009E238; // weak
_UNKNOWN unk_1009E280; // weak
int dword_1009E284[] = { 6767 }; // weak
_UNKNOWN unk_1009E290; // weak
_UNKNOWN unk_1009E2A8; // weak
_UNKNOWN unk_1009E2C0; // weak
int dword_1009E2C4[] = { 6769 }; // weak
_UNKNOWN unk_1009E2D8; // weak
int dword_1009E2DC[] = { 6093 }; // weak
char byte_100A0580[] = { '\x01' }; // weak
__int16 word_100A0582[] = { 3020 }; // weak
_UNKNOWN unk_100A0D60; // weak
int dword_100A0D64[] = { 1312 }; // weak
_UNKNOWN unk_100A2778; // weak
int dword_100A277C[] = { 6006 }; // weak
int (__cdecl *off_100A27C8[2])(int, int) = { &sub_10024F20, &sub_10024F80 }; // weak
char *off_100A34B8 = "/shr_mem/iop_fltr_data_intf.shr"; // weak
char *off_100A5744 = "Cannot send message. Data radio failed."; // weak
_UNKNOWN unk_100A57E0; // weak
_UNKNOWN unk_100A5804; // weak
_UNKNOWN unk_100A59A8; // weak
char off_100A65D8[] = { 't', '', '\t', '\x10' }; // idb
int dword_100A65F4 = 1; // idb
char byte_100A6610[] = { '\x01' }; // weak
char *off_100A6614[3] = { "1", "2", "fail_normal_1" }; // weak
char *off_100A6618[2] = { "2", "fail_normal_1" }; // weak
char off_100A661C[8] = { '', 'e', '\n', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100A66A0[] = { '\0' }; // weak
char byte_100A66A1[] = { '\0' }; // weak
int dword_100A66A4[] = { 0 }; // weak
char *off_100A66A8 = "0, 0, 0"; // weak
double dbl_100A6910[] = {  0.0 }; // weak
double dbl_100A6918[] = {  0.0 }; // weak
double dbl_100A6920[] = {  0.0 }; // weak
int dword_100A6928[] = { 0 }; // weak
char off_100A692C[32] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_100A7530[] = {  0.0 }; // weak
float flt_100A7534[] = {  0.0 }; // weak
float flt_100A7538[] = {  0.0 }; // weak
int dword_100A753C[] = { 0 }; // weak
char *off_100A7540 = "0, 0, 0"; // weak
char *off_100A7CC4[3] =
{
  "..\\lib\\utf\\utf_validate.c",
  "..\\lib\\utf\\utf_validate.c",
  &off_100BC920
}; // weak
int dword_100A7CD8[] = { 0 }; // weak
int dword_100A7CDC[] = { 0 }; // weak
int dword_100A7CE0[] = { 0 }; // weak
int dword_100A7CE4[] = { 0 }; // weak
char off_100A7CE8[20] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100A8470[] = { 0 }; // weak
__int16 word_100A8472[] = { 0 }; // weak
__int16 word_100A8474[] = { 0 }; // weak
int dword_100A8478[] = { 0 }; // weak
char off_100A847C[16] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100A8A80[] = { 0 }; // weak
int dword_100A8A84[] = { 0 }; // weak
int dword_100A8A88[] = { 0 }; // weak
int dword_100A8A8C[] = { 0 }; // weak
char *off_100A8A90 = "0, 0, 0"; // weak
int dword_100A9218[] = { 0 }; // weak
int dword_100A921C[] = { 0 }; // weak
int dword_100A9220[] = { 0 }; // weak
int dword_100A9224[] = { 0 }; // weak
int dword_100A9228[] = { 0 }; // weak
int dword_100A922C[] = { 0 }; // weak
int dword_100A9230[] = { 0 }; // weak
char off_100A9234[32] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100A9E38[] = { '\0' }; // weak
char byte_100A9E39[] = { '\0' }; // weak
char byte_100A9E3A[] = { '\0' }; // weak
int dword_100A9E3C[] = { 0 }; // weak
char *off_100A9E40 = "0, 0, 0"; // weak
int dword_100AA2C8[] = { 0 }; // weak
int dword_100AA2CC[] = { 0 }; // weak
int dword_100AA2D0[] = { 0 }; // weak
int dword_100AA2D4[] = { 0 }; // weak
char off_100AA2D8[20] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100AAA60[] = { 0 }; // weak
int dword_100AAA64[] = { 0 }; // weak
int dword_100AAA68[] = { 0 }; // weak
int dword_100AAA6C[] = { 0 }; // weak
char *off_100AAA70 = "0, 0, 0"; // weak
__int16 word_100AADD0[] = { 0 }; // weak
__int16 word_100AADD2[] = { 0 }; // weak
__int16 word_100AADD4[] = { 0 }; // weak
int dword_100AADD8[] = { 0 }; // weak
char off_100AADDC[16] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100AB090[] = { 0 }; // weak
int dword_100AB094[] = { 0 }; // weak
int dword_100AB098[] = { 0 }; // weak
int dword_100AB09C[] = { 0 }; // weak
char *off_100AB0A0 = "0, 0, 0"; // weak
int dword_100AB400[] = { 0 }; // weak
int dword_100AB404[] = { 0 }; // weak
int dword_100AB408[] = { 0 }; // weak
int dword_100AB40C[] = { 0 }; // weak
int dword_100AB410[] = { 0 }; // weak
int dword_100AB414[] = { 0 }; // weak
int dword_100AB418[] = { 0 }; // weak
char off_100AB41C[32] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100AB980[] = { '\0' }; // weak
char byte_100AB981[] = { '\0' }; // weak
char byte_100AB982[] = { '\0' }; // weak
int dword_100AB984[] = { 0 }; // weak
char *off_100AB988 = "0, 0, 0"; // weak
int dword_100ABB90[] = { 0 }; // weak
int dword_100ABB94[] = { 0 }; // weak
int dword_100ABB98[] = { 0 }; // weak
int dword_100ABB9C[] = { 0 }; // weak
char *off_100ABBA0 = "0, 0, 0"; // weak
char byte_100ABF00[] = { '\x01' }; // weak
char *off_100ABF04[3] = { "1", "2", "fail_robust_1" }; // weak
char *off_100ABF08[2] = { "2", "fail_robust_1" }; // weak
char off_100ABF0C[8] = { '8', 'a', '\n', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100ABF90[] = { '\0' }; // weak
char byte_100ABF91[] = { '\0' }; // weak
int dword_100ABF94[] = { 0 }; // weak
char *off_100ABF98 = "0, 0, 0"; // weak
double dbl_100AC200[] = {  0.0 }; // weak
double dbl_100AC208[] = {  0.0 }; // weak
double dbl_100AC210[] = {  0.0 }; // weak
int dword_100AC218[] = { 0 }; // weak
char off_100AC21C[32] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_100ACE20[] = {  0.0 }; // weak
float flt_100ACE24[] = {  0.0 }; // weak
float flt_100ACE28[] = {  0.0 }; // weak
int dword_100ACE2C[] = { 0 }; // weak
char *off_100ACE30 = "0, 0, 0"; // weak
int dword_100AD5B8[] = { 0 }; // weak
int dword_100AD5BC[] = { 0 }; // weak
int dword_100AD5C0[] = { 0 }; // weak
int dword_100AD5C4[] = { 0 }; // weak
char off_100AD5C8[20] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100ADD50[] = { 0 }; // weak
__int16 word_100ADD52[] = { 0 }; // weak
__int16 word_100ADD54[] = { 0 }; // weak
int dword_100ADD58[] = { 0 }; // weak
char off_100ADD5C[16] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100AE360[] = { 0 }; // weak
int dword_100AE364[] = { 0 }; // weak
int dword_100AE368[] = { 0 }; // weak
int dword_100AE36C[] = { 0 }; // weak
char *off_100AE370 = "0, 0, 0"; // weak
int dword_100AEAF8[] = { 0 }; // weak
int dword_100AEAFC[] = { 0 }; // weak
int dword_100AEB00[] = { 0 }; // weak
int dword_100AEB04[] = { 0 }; // weak
int dword_100AEB08[] = { 0 }; // weak
int dword_100AEB0C[] = { 0 }; // weak
int dword_100AEB10[] = { 0 }; // weak
char off_100AEB14[32] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100AF718[] = { '\0' }; // weak
char byte_100AF719[] = { '\0' }; // weak
char byte_100AF71A[] = { '\0' }; // weak
int dword_100AF71C[] = { 0 }; // weak
char *off_100AF720 = "0, 0, 0"; // weak
int dword_100AFBA8[] = { 0 }; // weak
int dword_100AFBAC[] = { 0 }; // weak
int dword_100AFBB0[] = { 0 }; // weak
int dword_100AFBB4[] = { 0 }; // weak
char off_100AFBB8[20] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B0340[] = { 0 }; // weak
int dword_100B0344[] = { 0 }; // weak
int dword_100B0348[] = { 0 }; // weak
int dword_100B034C[] = { 0 }; // weak
char *off_100B0350 = "0, 0, 0"; // weak
__int16 word_100B06B0[] = { 0 }; // weak
__int16 word_100B06B2[] = { 0 }; // weak
__int16 word_100B06B4[] = { 0 }; // weak
int dword_100B06B8[] = { 0 }; // weak
char off_100B06BC[16] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B0970[] = { 0 }; // weak
int dword_100B0974[] = { 0 }; // weak
int dword_100B0978[] = { 0 }; // weak
int dword_100B097C[] = { 0 }; // weak
char *off_100B0980 = "0, 0, 0"; // weak
int dword_100B0CE0[] = { 0 }; // weak
int dword_100B0CE4[] = { 0 }; // weak
int dword_100B0CE8[] = { 0 }; // weak
int dword_100B0CEC[] = { 0 }; // weak
int dword_100B0CF0[] = { 0 }; // weak
int dword_100B0CF4[] = { 0 }; // weak
int dword_100B0CF8[] = { 0 }; // weak
char off_100B0CFC[32] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100B1260[] = { '\0' }; // weak
char byte_100B1261[] = { '\0' }; // weak
char byte_100B1262[] = { '\0' }; // weak
int dword_100B1264[] = { 0 }; // weak
char *off_100B1268 = "0, 0, 0"; // weak
int dword_100B1470[] = { 0 }; // weak
int dword_100B1474[] = { 0 }; // weak
int dword_100B1478[] = { 0 }; // weak
int dword_100B147C[] = { 0 }; // weak
char *off_100B1480 = "0, 0, 0"; // weak
char byte_100B17E0[] = { '\x01' }; // weak
char *off_100B17E4[3] = { "1", "1", "pass_normal_1" }; // weak
char *off_100B17E8[2] = { "1", "pass_normal_1" }; // weak
char off_100B17EC[8] = { '', '`', '\n', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100B1830[] = { '\0' }; // weak
char byte_100B1831[] = { '\0' }; // weak
int dword_100B1834[] = { 0 }; // weak
char *off_100B1838 = "0, 0, 0"; // weak
double dbl_100B1AA0[] = {  0.0 }; // weak
double dbl_100B1AA8[] = {  0.0 }; // weak
double dbl_100B1AB0[] = {  0.0 }; // weak
int dword_100B1AB8[] = { 0 }; // weak
char off_100B1ABC[32] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_100B26C0[] = {  0.0 }; // weak
float flt_100B26C4[] = {  0.0 }; // weak
float flt_100B26C8[] = {  0.0 }; // weak
int dword_100B26CC[] = { 0 }; // weak
char *off_100B26D0 = "0, 0, 0"; // weak
int dword_100B2E58[] = { 0 }; // weak
int dword_100B2E5C[] = { 0 }; // weak
int dword_100B2E60[] = { 0 }; // weak
int dword_100B2E64[] = { 0 }; // weak
char off_100B2E68[20] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100B35F0[] = { 0 }; // weak
__int16 word_100B35F2[] = { 0 }; // weak
__int16 word_100B35F4[] = { 0 }; // weak
int dword_100B35F8[] = { 0 }; // weak
char off_100B35FC[16] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B3C00[] = { 0 }; // weak
int dword_100B3C04[] = { 0 }; // weak
int dword_100B3C08[] = { 0 }; // weak
int dword_100B3C0C[] = { 0 }; // weak
char *off_100B3C10 = "0, 0, 0"; // weak
int dword_100B4398[] = { 0 }; // weak
int dword_100B439C[] = { 0 }; // weak
int dword_100B43A0[] = { 0 }; // weak
int dword_100B43A4[] = { 0 }; // weak
int dword_100B43A8[] = { 0 }; // weak
int dword_100B43AC[] = { 0 }; // weak
int dword_100B43B0[] = { 0 }; // weak
char off_100B43B4[32] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100B4FB8[] = { '\0' }; // weak
char byte_100B4FB9[] = { '\0' }; // weak
char byte_100B4FBA[] = { '\0' }; // weak
int dword_100B4FBC[] = { 0 }; // weak
char *off_100B4FC0 = "0, 0, 0"; // weak
int dword_100B5448[] = { 0 }; // weak
int dword_100B544C[] = { 0 }; // weak
int dword_100B5450[] = { 0 }; // weak
int dword_100B5454[] = { 0 }; // weak
char off_100B5458[20] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B5BE0[] = { 0 }; // weak
int dword_100B5BE4[] = { 0 }; // weak
int dword_100B5BE8[] = { 0 }; // weak
int dword_100B5BEC[] = { 0 }; // weak
char *off_100B5BF0 = "0, 0, 0"; // weak
__int16 word_100B5F50[] = { 0 }; // weak
__int16 word_100B5F52[] = { 0 }; // weak
__int16 word_100B5F54[] = { 0 }; // weak
int dword_100B5F58[] = { 0 }; // weak
char off_100B5F5C[16] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B6210[] = { 0 }; // weak
int dword_100B6214[] = { 0 }; // weak
int dword_100B6218[] = { 0 }; // weak
int dword_100B621C[] = { 0 }; // weak
char *off_100B6220 = "0, 0, 0"; // weak
int dword_100B6580[] = { 0 }; // weak
int dword_100B6584[] = { 0 }; // weak
int dword_100B6588[] = { 0 }; // weak
int dword_100B658C[] = { 0 }; // weak
int dword_100B6590[] = { 0 }; // weak
int dword_100B6594[] = { 0 }; // weak
int dword_100B6598[] = { 0 }; // weak
char off_100B659C[32] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100B6B00[] = { '\0' }; // weak
char byte_100B6B01[] = { '\0' }; // weak
char byte_100B6B02[] = { '\0' }; // weak
int dword_100B6B04[] = { 0 }; // weak
char *off_100B6B08 = "0, 0, 0"; // weak
int dword_100B6D10[] = { 0 }; // weak
int dword_100B6D14[] = { 0 }; // weak
int dword_100B6D18[] = { 0 }; // weak
int dword_100B6D1C[] = { 0 }; // weak
char *off_100B6D20 = "0, 0, 0"; // weak
char byte_100B7080[] = { '\x01' }; // weak
char *off_100B7084[3] = { "1", "1", "pass_robust_1" }; // weak
char *off_100B7088[2] = { "1", "pass_robust_1" }; // weak
char off_100B708C[8] = { 'X', '`', '\n', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100B70D0[] = { '\0' }; // weak
char byte_100B70D1[] = { '\0' }; // weak
int dword_100B70D4[] = { 0 }; // weak
char *off_100B70D8 = "0, 0, 0"; // weak
double dbl_100B7340[] = {  0.0 }; // weak
double dbl_100B7348[] = {  0.0 }; // weak
double dbl_100B7350[] = {  0.0 }; // weak
int dword_100B7358[] = { 0 }; // weak
char off_100B735C[32] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_100B7F60[] = {  0.0 }; // weak
float flt_100B7F64[] = {  0.0 }; // weak
float flt_100B7F68[] = {  0.0 }; // weak
int dword_100B7F6C[] = { 0 }; // weak
char *off_100B7F70 = "0, 0, 0"; // weak
int dword_100B86F8[] = { 0 }; // weak
int dword_100B86FC[] = { 0 }; // weak
int dword_100B8700[] = { 0 }; // weak
int dword_100B8704[] = { 0 }; // weak
char off_100B8708[20] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100B8E90[] = { 0 }; // weak
__int16 word_100B8E92[] = { 0 }; // weak
__int16 word_100B8E94[] = { 0 }; // weak
int dword_100B8E98[] = { 0 }; // weak
char off_100B8E9C[16] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B94A0[] = { 0 }; // weak
int dword_100B94A4[] = { 0 }; // weak
int dword_100B94A8[] = { 0 }; // weak
int dword_100B94AC[] = { 0 }; // weak
char *off_100B94B0 = "0, 0, 0"; // weak
int dword_100B9C38[] = { 0 }; // weak
int dword_100B9C3C[] = { 0 }; // weak
int dword_100B9C40[] = { 0 }; // weak
int dword_100B9C44[] = { 0 }; // weak
int dword_100B9C48[] = { 0 }; // weak
int dword_100B9C4C[] = { 0 }; // weak
int dword_100B9C50[] = { 0 }; // weak
char off_100B9C54[32] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100BA858[] = { '\0' }; // weak
char byte_100BA859[] = { '\0' }; // weak
char byte_100BA85A[] = { '\0' }; // weak
int dword_100BA85C[] = { 0 }; // weak
char *off_100BA860 = "0, 0, 0"; // weak
int dword_100BACE8[] = { 0 }; // weak
int dword_100BACEC[] = { 0 }; // weak
int dword_100BACF0[] = { 0 }; // weak
int dword_100BACF4[] = { 0 }; // weak
char off_100BACF8[20] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100BB480[] = { 0 }; // weak
int dword_100BB484[] = { 0 }; // weak
int dword_100BB488[] = { 0 }; // weak
int dword_100BB48C[] = { 0 }; // weak
char *off_100BB490 = "0, 0, 0"; // weak
__int16 word_100BB7F0[] = { 0 }; // weak
__int16 word_100BB7F2[] = { 0 }; // weak
__int16 word_100BB7F4[] = { 0 }; // weak
int dword_100BB7F8[] = { 0 }; // weak
char off_100BB7FC[16] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100BBAB0[] = { 0 }; // weak
int dword_100BBAB4[] = { 0 }; // weak
int dword_100BBAB8[] = { 0 }; // weak
int dword_100BBABC[] = { 0 }; // weak
char *off_100BBAC0 = "0, 0, 0"; // weak
int dword_100BBE20[] = { 0 }; // weak
int dword_100BBE24[] = { 0 }; // weak
int dword_100BBE28[] = { 0 }; // weak
int dword_100BBE2C[] = { 0 }; // weak
int dword_100BBE30[] = { 0 }; // weak
int dword_100BBE34[] = { 0 }; // weak
int dword_100BBE38[] = { 0 }; // weak
char off_100BBE3C[32] =
{
  '(',
  'e',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100BC3A0[] = { '\0' }; // weak
char byte_100BC3A1[] = { '\0' }; // weak
char byte_100BC3A2[] = { '\0' }; // weak
int dword_100BC3A4[] = { 0 }; // weak
char *off_100BC3A8 = "0, 0, 0"; // weak
int dword_100BC5B0[] = { 0 }; // weak
int dword_100BC5B4[] = { 0 }; // weak
int dword_100BC5B8[] = { 0 }; // weak
int dword_100BC5BC[] = { 0 }; // weak
char *off_100BC5C0 = "0, 0, 0"; // weak
_UNKNOWN unk_100BD5A0; // weak
int dword_100C077C[] = { 0 }; // weak
_UNKNOWN off_100C0780; // weak
_UNKNOWN unk_100C0810; // weak
_UNKNOWN unk_100C0814; // weak
_UNKNOWN unk_100C0818; // weak
_UNKNOWN unk_100C081C; // weak
_UNKNOWN unk_100C0820; // weak
_UNKNOWN unk_100C0824; // weak
_UNKNOWN unk_100C0828; // weak
_UNKNOWN unk_100C082C; // weak
_UNKNOWN unk_100C22A0; // weak
int dword_100C22A4[] = { 0 }; // weak
int dword_100C33A8 = 64; // weak
__int16 word_100C33AC[] = { 6782 }; // weak
__int16 word_100C33B0[] = { 128 }; // weak
_UNKNOWN unk_100C33CC; // weak
_DWORD dword_100C33D0[10] = { 64, 24, 62, 18, 65, 27525120, 27394467, 27721729, 27591078, 0 }; // idb
char *off_100C5270 = "/shr_mem/iop_gtx_intf.shr"; // weak
_UNKNOWN unk_100C65F0; // weak
int dword_100C65F4[] = { 0 }; // weak
_UNKNOWN unk_100C6608; // weak
int dword_100C660C[] = { 0 }; // weak
_UNKNOWN unk_100C6630; // weak
int dword_100C6634[] = { 0 }; // weak
_UNKNOWN unk_100C6660; // weak
int dword_100C6664[] = { 0 }; // weak
_UNKNOWN unk_100C69A0; // weak
void *off_100C69A4 = &unk_100C6718; // weak
_UNKNOWN unk_100C6B48; // weak
_UNKNOWN unk_100C6B49; // weak
_UNKNOWN unk_100C9820; // weak
int dword_100C9824[] = { 6829 }; // weak
__int16 word_100CA85A[] = { 233 }; // weak
int dword_100CA860[] = { 6201 }; // weak
__int16 word_100CD410[] = { 114 }; // weak
__int16 word_100CD520[] = { 551 }; // weak
char byte_100CD6C8[] = { '\x01' }; // weak
__int16 word_100CD6CA[] = { 3020 }; // weak
char byte_100D0422[] = { '\x04' }; // weak
char byte_100D0427[] = { '\a' }; // weak
char *off_100D71C4 = "/shr_mem/cdp_mngr_intf.shr"; // weak
_UNKNOWN unk_100D7EB8; // weak
int dword_100D7EBC[] = { 3535 }; // weak
_UNKNOWN unk_100D7EF0; // weak
int dword_100D7EF4[] = { 6813 }; // weak
_UNKNOWN unk_100D7F28; // weak
int dword_100D7F2C[] = { 9036 }; // weak
_UNKNOWN unk_100D7F60; // weak
int dword_100D7F64[] = { 6763 }; // weak
int dword_100D9B60[] = { 6103 }; // weak
int dword_100D9B64[] = { 8000 }; // weak
char byte_100DA7F0[] = { '\0' }; // weak
char byte_100DA7FC[12] =
{
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\xFF',
  '\0',
  '\x01',
  '\0'
}; // idb
int dword_100DA808 = 0; // idb
int dword_100DB150[] = { 0 }; // weak
_WORD dword_100E9720[512] =
{
  25542,
  42339,
  31992,
  33916,
  30702,
  39287,
  31734,
  36219,
  62207,
  3570,
  27606,
  48491,
  28638,
  45423,
  50577,
  21701,
  12384,
  20528,
  258,
  769,
  26574,
  43367,
  11094,
  32043,
  65255,
  6654,
  55221,
  25303,
  43853,
  59051,
  30444,
  39542,
  51855,
  17866,
  33311,
  40322,
  51593,
  16585,
  32250,
  34685,
  64239,
  5626,
  22962,
  60249,
  18318,
  51527,
  61691,
  3056,
  44353,
  60589,
  54451,
  26580,
  41567,
  64930,
  44869,
  60079,
  39971,
  49052,
  42067,
  63396,
  29412,
  38514,
  49307,
  23488,
  46965,
  49847,
  64993,
  7421,
  37693,
  44691,
  9804,
  27174,
  13932,
  23094,
  16254,
  16703,
  63477,
  759,
  52355,
  20428,
  13416,
  23604,
  42321,
  62629,
  58833,
  13541,
  61945,
  2289,
  29154,
  37745,
  55467,
  29656,
  12642,
  21297,
  5418,
  16149,
  1032,
  3076,
  51093,
  21191,
  9030,
  25891,
  50077,
  24259,
  6192,
  10264,
  38455,
  41366,
  1290,
  3845,
  39471,
  46490,
  1806,
  2311,
  4644,
  13842,
  32795,
  39808,
  58079,
  15842,
  60365,
  9963,
  10062,
  26919,
  45695,
  52658,
  30186,
  40821,
  2322,
  6921,
  33565,
  40579,
  11352,
  29740,
  6708,
  11802,
  6966,
  11547,
  28380,
  45678,
  23220,
  61018,
  41051,
  64416,
  21156,
  63058,
  15222,
  19771,
  54967,
  25046,
  45949,
  52915,
  10578,
  31529,
  58333,
  16099,
  12126,
  28975,
  33811,
  38788,
  21414,
  62803,
  53689,
  26833,
  0,
  0,
  60865,
  11501,
  8256,
  24608,
  64739,
  8188,
  45433,
  51377,
  23478,
  60763,
  27348,
  48746,
  52109,
  18123,
  48743,
  55742,
  14706,
  19257,
  19092,
  56906,
  19608,
  54348,
  22704,
  59480,
  53125,
  19151,
  53435,
  27600,
  61381,
  10991,
  43599,
  58794,
  64493,
  5883,
  17286,
  50499,
  19866,
  55117,
  13158,
  21811,
  34065,
  38021,
  17802,
  53061,
  63977,
  4345,
  516,
  1538,
  32766,
  33151,
  20640,
  61520,
  15480,
  17468,
  40741,
  47775,
  43083,
  58280,
  20898,
  62289,
  41821,
  65187,
  16512,
  49216,
  36613,
  35471,
  37439,
  44434,
  40225,
  48285,
  14448,
  18488,
  62961,
  1269,
  48227,
  57276,
  46711,
  49590,
  55983,
  30170,
  8514,
  25377,
  4128,
  12304,
  65509,
  6911,
  62461,
  3827,
  53951,
  28114,
  52609,
  19661,
  3096,
  5132,
  4902,
  13587,
  60611,
  12268,
  24510,
  57695,
  38709,
  41623,
  17544,
  52292,
  5934,
  14615,
  50323,
  22468,
  42837,
  62119,
  32508,
  33406,
  15738,
  18237,
  25800,
  44132,
  23994,
  59229,
  6450,
  11033,
  29670,
  38259,
  24768,
  41056,
  33049,
  39041,
  20382,
  53583,
  56483,
  32732,
  8772,
  26146,
  10836,
  32298,
  36923,
  43920,
  34827,
  33672,
  18060,
  51782,
  61127,
  10734,
  47211,
  54200,
  5160,
  15380,
  56999,
  31198,
  24252,
  57950,
  2838,
  7435,
  56237,
  30427,
  57563,
  15328,
  12900,
  22066,
  14964,
  20026,
  2580,
  7690,
  18834,
  56137,
  1548,
  2566,
  9288,
  27684,
  23736,
  58460,
  49823,
  24002,
  54205,
  28371,
  44099,
  61356,
  25284,
  42594,
  37177,
  43153,
  38193,
  42133,
  58579,
  14308,
  31218,
  35705,
  59349,
  13031,
  51339,
  17352,
  14190,
  22839,
  28122,
  46957,
  36097,
  35981,
  54705,
  25813,
  20124,
  53838,
  43337,
  57513,
  27864,
  46188,
  22188,
  64086,
  62707,
  2036,
  60111,
  9706,
  26058,
  44901,
  31476,
  36474,
  44615,
  59822,
  2064,
  6152,
  47727,
  54714,
  30960,
  34936,
  9546,
  28453,
  11868,
  29230,
  7224,
  9244,
  42583,
  61862,
  46195,
  51124,
  50839,
  20934,
  59595,
  9192,
  56737,
  31965,
  29928,
  40052,
  7998,
  8479,
  19350,
  56651,
  48481,
  56509,
  35597,
  34443,
  35343,
  34186,
  28896,
  36976,
  15996,
  16958,
  46449,
  50357,
  26316,
  43622,
  18576,
  55368,
  774,
  1283,
  63223,
  502,
  3612,
  4622,
  25026,
  41825,
  13674,
  24373,
  22446,
  63831,
  47465,
  53433,
  34327,
  37254,
  49561,
  22721,
  7482,
  10013,
  40487,
  47518,
  57817,
  14561,
  63723,
  5112,
  38955,
  45976,
  4386,
  13073,
  27090,
  47977,
  55721,
  28889,
  36359,
  35214,
  37939,
  42900,
  39725,
  46747,
  7740,
  8734,
  34581,
  37511,
  59849,
  8425,
  52871,
  18894,
  21930,
  65365,
  10320,
  30760,
  57253,
  31455,
  35843,
  36748,
  41305,
  63649,
  35081,
  32905,
  3354,
  5901,
  48997,
  55999,
  59095,
  12774,
  17028,
  50754,
  26832,
  47208,
  16770,
  49985,
  39209,
  45209,
  11610,
  30509,
  3870,
  4367,
  45179,
  52144,
  21672,
  64596,
  47981,
  54971,
  5676,
  14870
}; // idb
_WORD dword_100E9B20[512] =
{
  50853,
  25443,
  63620,
  31868,
  61081,
  30583,
  63117,
  31611,
  65293,
  62194,
  54973,
  27499,
  57009,
  28527,
  37204,
  50629,
  24656,
  12336,
  515,
  257,
  52905,
  26471,
  22141,
  11051,
  59161,
  65278,
  46434,
  55255,
  19942,
  43947,
  60570,
  30326,
  36677,
  51914,
  8093,
  33410,
  35136,
  51657,
  64135,
  32125,
  61205,
  64250,
  45803,
  22873,
  36553,
  18247,
  64267,
  61680,
  16876,
  44461,
  45927,
  54484,
  24573,
  41634,
  17898,
  44975,
  9151,
  40092,
  21495,
  42148,
  58518,
  29298,
  39771,
  49344,
  30146,
  47031,
  57628,
  65021,
  15790,
  37779,
  19562,
  9766,
  27738,
  13878,
  32321,
  16191,
  62722,
  63479,
  33615,
  52428,
  26716,
  13364,
  20980,
  42405,
  53556,
  58853,
  63752,
  61937,
  58003,
  29041,
  43891,
  55512,
  25171,
  12593,
  10815,
  5397,
  2060,
  1028,
  38226,
  51143,
  18021,
  8995,
  40286,
  50115,
  12328,
  6168,
  14241,
  38550,
  2575,
  1285,
  12213,
  39578,
  3593,
  1799,
  9270,
  4626,
  7067,
  32896,
  57149,
  58082,
  52518,
  60395,
  20073,
  10023,
  32717,
  45746,
  60063,
  30069,
  4635,
  2313,
  7582,
  33667,
  22644,
  11308,
  13358,
  6682,
  13869,
  6939,
  56498,
  28270,
  46318,
  23130,
  23547,
  41120,
  42230,
  21074,
  30285,
  15163,
  46945,
  54998,
  32206,
  46003,
  21115,
  10537,
  56638,
  58339,
  24177,
  12079,
  5015,
  33924,
  42741,
  21331,
  47464,
  53713,
  0,
  0,
  49452,
  60909,
  16480,
  8224,
  58143,
  64764,
  31176,
  45489,
  46829,
  23387,
  54462,
  27242,
  36166,
  52171,
  26585,
  48830,
  29259,
  14649,
  38110,
  19018,
  39124,
  19532,
  45288,
  22616,
  34122,
  53199,
  47979,
  53456,
  50474,
  61423,
  20453,
  43690,
  60694,
  64507,
  34501,
  17219,
  39639,
  19789,
  26197,
  13107,
  4500,
  34181,
  35535,
  17733,
  59664,
  63993,
  1030,
  514,
  65153,
  32639,
  41200,
  20560,
  30788,
  15420,
  9658,
  40863,
  19427,
  43176,
  41715,
  20817,
  24062,
  41891,
  32960,
  16448,
  1418,
  36751,
  16301,
  37522,
  8636,
  40349,
  28744,
  14392,
  61700,
  62965,
  25567,
  48316,
  30657,
  46774,
  44917,
  56026,
  16995,
  8481,
  8240,
  4112,
  58650,
  65535,
  64782,
  62451,
  49005,
  53970,
  33100,
  52685,
  6164,
  3084,
  9781,
  4883,
  49967,
  60652,
  48865,
  24415,
  13730,
  38807,
  35020,
  17476,
  11833,
  5911,
  37719,
  50372,
  22002,
  42919,
  64642,
  32382,
  31303,
  15677,
  51372,
  25700,
  47847,
  23901,
  12843,
  6425,
  59029,
  29555,
  49312,
  24672,
  6552,
  33153,
  40657,
  20303,
  41855,
  56540,
  17510,
  8738,
  21630,
  10794,
  15275,
  37008,
  2947,
  34952,
  36042,
  17990,
  50985,
  61166,
  27603,
  47288,
  10300,
  5140,
  42873,
  57054,
  48354,
  24158,
  5661,
  2827,
  44406,
  56283,
  56123,
  57568,
  25686,
  12850,
  29774,
  14906,
  5150,
  2570,
  37595,
  18761,
  3082,
  1542,
  18540,
  9252,
  47332,
  23644,
  40797,
  49858,
  48494,
  54227,
  17391,
  44204,
  50342,
  25186,
  14760,
  37265,
  12708,
  38293,
  54071,
  58596,
  62091,
  31097,
  54578,
  59367,
  35651,
  51400,
  28249,
  14135,
  55991,
  28013,
  396,
  36237,
  45412,
  54741,
  40146,
  20046,
  18912,
  43433,
  55476,
  27756,
  44282,
  22102,
  62215,
  62708,
  53029,
  60138,
  51887,
  25957,
  62606,
  31354,
  18409,
  44718,
  4120,
  2056,
  28629,
  47802,
  61576,
  30840,
  19055,
  9509,
  23666,
  11822,
  14372,
  7196,
  22513,
  42662,
  29639,
  46260,
  38737,
  50886,
  52003,
  59624,
  41340,
  56797,
  59548,
  29812,
  15905,
  7967,
  38621,
  19275,
  25052,
  48573,
  3462,
  35723,
  3973,
  35466,
  57488,
  28784,
  31810,
  15934,
  29124,
  46517,
  52394,
  26214,
  37080,
  18504,
  1541,
  771,
  63233,
  63222,
  7186,
  3598,
  49827,
  24929,
  27231,
  13621,
  44793,
  22359,
  27088,
  47545,
  6033,
  34438,
  39256,
  49601,
  14887,
  7453,
  10169,
  40606,
  55608,
  57825,
  60179,
  63736,
  11187,
  39064,
  8755,
  4369,
  53947,
  26985,
  43376,
  55769,
  1929,
  36494,
  13223,
  38036,
  11702,
  39835,
  15394,
  7710,
  5522,
  34695,
  51488,
  59881,
  34633,
  52942,
  43775,
  21845,
  20600,
  10280,
  42362,
  57311,
  911,
  35980,
  23032,
  41377,
  2432,
  35209,
  6679,
  3341,
  26074,
  49087,
  55089,
  59110,
  33990,
  16962,
  53432,
  26728,
  33475,
  16705,
  10672,
  39321,
  23159,
  11565,
  7697,
  3855,
  31691,
  45232,
  43260,
  21588,
  28118,
  48059,
  11322,
  5654
}; // idb
_WORD dword_100E9F20[512] =
{
  42339,
  25542,
  33916,
  31992,
  39287,
  30702,
  36219,
  31734,
  3570,
  62207,
  48491,
  27606,
  45423,
  28638,
  21701,
  50577,
  20528,
  12384,
  769,
  258,
  43367,
  26574,
  32043,
  11094,
  6654,
  65255,
  25303,
  55221,
  59051,
  43853,
  39542,
  30444,
  17866,
  51855,
  40322,
  33311,
  16585,
  51593,
  34685,
  32250,
  5626,
  64239,
  60249,
  22962,
  51527,
  18318,
  3056,
  61691,
  60589,
  44353,
  26580,
  54451,
  64930,
  41567,
  60079,
  44869,
  49052,
  39971,
  63396,
  42067,
  38514,
  29412,
  23488,
  49307,
  49847,
  46965,
  7421,
  64993,
  44691,
  37693,
  27174,
  9804,
  23094,
  13932,
  16703,
  16254,
  759,
  63477,
  20428,
  52355,
  23604,
  13416,
  62629,
  42321,
  13541,
  58833,
  2289,
  61945,
  37745,
  29154,
  29656,
  55467,
  21297,
  12642,
  16149,
  5418,
  3076,
  1032,
  21191,
  51093,
  25891,
  9030,
  24259,
  50077,
  10264,
  6192,
  41366,
  38455,
  3845,
  1290,
  46490,
  39471,
  2311,
  1806,
  13842,
  4644,
  39808,
  32795,
  15842,
  58079,
  9963,
  60365,
  26919,
  10062,
  52658,
  45695,
  40821,
  30186,
  6921,
  2322,
  40579,
  33565,
  29740,
  11352,
  11802,
  6708,
  11547,
  6966,
  45678,
  28380,
  61018,
  23220,
  64416,
  41051,
  63058,
  21156,
  19771,
  15222,
  25046,
  54967,
  52915,
  45949,
  31529,
  10578,
  16099,
  58333,
  28975,
  12126,
  38788,
  33811,
  62803,
  21414,
  26833,
  53689,
  0,
  0,
  11501,
  60865,
  24608,
  8256,
  8188,
  64739,
  51377,
  45433,
  60763,
  23478,
  48746,
  27348,
  18123,
  52109,
  55742,
  48743,
  19257,
  14706,
  56906,
  19092,
  54348,
  19608,
  59480,
  22704,
  19151,
  53125,
  27600,
  53435,
  10991,
  61381,
  58794,
  43599,
  5883,
  64493,
  50499,
  17286,
  55117,
  19866,
  21811,
  13158,
  38021,
  34065,
  53061,
  17802,
  4345,
  63977,
  1538,
  516,
  33151,
  32766,
  61520,
  20640,
  17468,
  15480,
  47775,
  40741,
  58280,
  43083,
  62289,
  20898,
  65187,
  41821,
  49216,
  16512,
  35471,
  36613,
  44434,
  37439,
  48285,
  40225,
  18488,
  14448,
  1269,
  62961,
  57276,
  48227,
  49590,
  46711,
  30170,
  55983,
  25377,
  8514,
  12304,
  4128,
  6911,
  65509,
  3827,
  62461,
  28114,
  53951,
  19661,
  52609,
  5132,
  3096,
  13587,
  4902,
  12268,
  60611,
  57695,
  24510,
  41623,
  38709,
  52292,
  17544,
  14615,
  5934,
  22468,
  50323,
  62119,
  42837,
  33406,
  32508,
  18237,
  15738,
  44132,
  25800,
  59229,
  23994,
  11033,
  6450,
  38259,
  29670,
  41056,
  24768,
  39041,
  33049,
  53583,
  20382,
  32732,
  56483,
  26146,
  8772,
  32298,
  10836,
  43920,
  36923,
  33672,
  34827,
  51782,
  18060,
  10734,
  61127,
  54200,
  47211,
  15380,
  5160,
  31198,
  56999,
  57950,
  24252,
  7435,
  2838,
  30427,
  56237,
  15328,
  57563,
  22066,
  12900,
  20026,
  14964,
  7690,
  2580,
  56137,
  18834,
  2566,
  1548,
  27684,
  9288,
  58460,
  23736,
  24002,
  49823,
  28371,
  54205,
  61356,
  44099,
  42594,
  25284,
  43153,
  37177,
  42133,
  38193,
  14308,
  58579,
  35705,
  31218,
  13031,
  59349,
  17352,
  51339,
  22839,
  14190,
  46957,
  28122,
  35981,
  36097,
  25813,
  54705,
  53838,
  20124,
  57513,
  43337,
  46188,
  27864,
  64086,
  22188,
  2036,
  62707,
  9706,
  60111,
  44901,
  26058,
  36474,
  31476,
  59822,
  44615,
  6152,
  2064,
  54714,
  47727,
  34936,
  30960,
  28453,
  9546,
  29230,
  11868,
  9244,
  7224,
  61862,
  42583,
  51124,
  46195,
  20934,
  50839,
  9192,
  59595,
  31965,
  56737,
  40052,
  29928,
  8479,
  7998,
  56651,
  19350,
  56509,
  48481,
  34443,
  35597,
  34186,
  35343,
  36976,
  28896,
  16958,
  15996,
  50357,
  46449,
  43622,
  26316,
  55368,
  18576,
  1283,
  774,
  502,
  63223,
  4622,
  3612,
  41825,
  25026,
  24373,
  13674,
  63831,
  22446,
  53433,
  47465,
  37254,
  34327,
  22721,
  49561,
  10013,
  7482,
  47518,
  40487,
  14561,
  57817,
  5112,
  63723,
  45976,
  38955,
  13073,
  4386,
  47977,
  27090,
  28889,
  55721,
  35214,
  36359,
  42900,
  37939,
  46747,
  39725,
  8734,
  7740,
  37511,
  34581,
  8425,
  59849,
  18894,
  52871,
  65365,
  21930,
  30760,
  10320,
  31455,
  57253,
  36748,
  35843,
  63649,
  41305,
  32905,
  35081,
  5901,
  3354,
  55999,
  48997,
  12774,
  59095,
  50754,
  17028,
  47208,
  26832,
  49985,
  16770,
  45209,
  39209,
  30509,
  11610,
  4367,
  3870,
  52144,
  45179,
  64596,
  21672,
  54971,
  47981,
  14870,
  5676
}; // idb
_WORD dword_100EA320[512] =
{
  25443,
  50853,
  31868,
  63620,
  30583,
  61081,
  31611,
  63117,
  62194,
  65293,
  27499,
  54973,
  28527,
  57009,
  50629,
  37204,
  12336,
  24656,
  257,
  515,
  26471,
  52905,
  11051,
  22141,
  65278,
  59161,
  55255,
  46434,
  43947,
  19942,
  30326,
  60570,
  51914,
  36677,
  33410,
  8093,
  51657,
  35136,
  32125,
  64135,
  64250,
  61205,
  22873,
  45803,
  18247,
  36553,
  61680,
  64267,
  44461,
  16876,
  54484,
  45927,
  41634,
  24573,
  44975,
  17898,
  40092,
  9151,
  42148,
  21495,
  29298,
  58518,
  49344,
  39771,
  47031,
  30146,
  65021,
  57628,
  37779,
  15790,
  9766,
  19562,
  13878,
  27738,
  16191,
  32321,
  63479,
  62722,
  52428,
  33615,
  13364,
  26716,
  42405,
  20980,
  58853,
  53556,
  61937,
  63752,
  29041,
  58003,
  55512,
  43891,
  12593,
  25171,
  5397,
  10815,
  1028,
  2060,
  51143,
  38226,
  8995,
  18021,
  50115,
  40286,
  6168,
  12328,
  38550,
  14241,
  1285,
  2575,
  39578,
  12213,
  1799,
  3593,
  4626,
  9270,
  32896,
  7067,
  58082,
  57149,
  60395,
  52518,
  10023,
  20073,
  45746,
  32717,
  30069,
  60063,
  2313,
  4635,
  33667,
  7582,
  11308,
  22644,
  6682,
  13358,
  6939,
  13869,
  28270,
  56498,
  23130,
  46318,
  41120,
  23547,
  21074,
  42230,
  15163,
  30285,
  54998,
  46945,
  46003,
  32206,
  10537,
  21115,
  58339,
  56638,
  12079,
  24177,
  33924,
  5015,
  21331,
  42741,
  53713,
  47464,
  0,
  0,
  60909,
  49452,
  8224,
  16480,
  64764,
  58143,
  45489,
  31176,
  23387,
  46829,
  27242,
  54462,
  52171,
  36166,
  48830,
  26585,
  14649,
  29259,
  19018,
  38110,
  19532,
  39124,
  22616,
  45288,
  53199,
  34122,
  53456,
  47979,
  61423,
  50474,
  43690,
  20453,
  64507,
  60694,
  17219,
  34501,
  19789,
  39639,
  13107,
  26197,
  34181,
  4500,
  17733,
  35535,
  63993,
  59664,
  514,
  1030,
  32639,
  65153,
  20560,
  41200,
  15420,
  30788,
  40863,
  9658,
  43176,
  19427,
  20817,
  41715,
  41891,
  24062,
  16448,
  32960,
  36751,
  1418,
  37522,
  16301,
  40349,
  8636,
  14392,
  28744,
  62965,
  61700,
  48316,
  25567,
  46774,
  30657,
  56026,
  44917,
  8481,
  16995,
  4112,
  8240,
  65535,
  58650,
  62451,
  64782,
  53970,
  49005,
  52685,
  33100,
  3084,
  6164,
  4883,
  9781,
  60652,
  49967,
  24415,
  48865,
  38807,
  13730,
  17476,
  35020,
  5911,
  11833,
  50372,
  37719,
  42919,
  22002,
  32382,
  64642,
  15677,
  31303,
  25700,
  51372,
  23901,
  47847,
  6425,
  12843,
  29555,
  59029,
  24672,
  49312,
  33153,
  6552,
  20303,
  40657,
  56540,
  41855,
  8738,
  17510,
  10794,
  21630,
  37008,
  15275,
  34952,
  2947,
  17990,
  36042,
  61166,
  50985,
  47288,
  27603,
  5140,
  10300,
  57054,
  42873,
  24158,
  48354,
  2827,
  5661,
  56283,
  44406,
  57568,
  56123,
  12850,
  25686,
  14906,
  29774,
  2570,
  5150,
  18761,
  37595,
  1542,
  3082,
  9252,
  18540,
  23644,
  47332,
  49858,
  40797,
  54227,
  48494,
  44204,
  17391,
  25186,
  50342,
  37265,
  14760,
  38293,
  12708,
  58596,
  54071,
  31097,
  62091,
  59367,
  54578,
  51400,
  35651,
  14135,
  28249,
  28013,
  55991,
  36237,
  396,
  54741,
  45412,
  20046,
  40146,
  43433,
  18912,
  27756,
  55476,
  22102,
  44282,
  62708,
  62215,
  60138,
  53029,
  25957,
  51887,
  31354,
  62606,
  44718,
  18409,
  2056,
  4120,
  47802,
  28629,
  30840,
  61576,
  9509,
  19055,
  11822,
  23666,
  7196,
  14372,
  42662,
  22513,
  46260,
  29639,
  50886,
  38737,
  59624,
  52003,
  56797,
  41340,
  29812,
  59548,
  7967,
  15905,
  19275,
  38621,
  48573,
  25052,
  35723,
  3462,
  35466,
  3973,
  28784,
  57488,
  15934,
  31810,
  46517,
  29124,
  26214,
  52394,
  18504,
  37080,
  771,
  1541,
  63222,
  63233,
  3598,
  7186,
  24929,
  49827,
  13621,
  27231,
  22359,
  44793,
  47545,
  27088,
  34438,
  6033,
  49601,
  39256,
  7453,
  14887,
  40606,
  10169,
  57825,
  55608,
  63736,
  60179,
  39064,
  11187,
  4369,
  8755,
  26985,
  53947,
  55769,
  43376,
  36494,
  1929,
  38036,
  13223,
  39835,
  11702,
  7710,
  15394,
  34695,
  5522,
  59881,
  51488,
  52942,
  34633,
  21845,
  43775,
  10280,
  20600,
  57311,
  42362,
  35980,
  911,
  41377,
  23032,
  35209,
  2432,
  3341,
  6679,
  49087,
  26074,
  59110,
  55089,
  16962,
  33990,
  26728,
  53432,
  16705,
  33475,
  39321,
  10672,
  11565,
  23159,
  3855,
  7697,
  45232,
  31691,
  21588,
  43260,
  48059,
  28118,
  5654,
  11322
}; // idb
int dword_100EA720[] = { 99 }; // weak
int dword_100EAB20[] = { 25344 }; // weak
int dword_100EAF20[] = { 6488064 }; // weak
int dword_100EB320[] = { 1660944384 }; // weak
int dword_100EB748[] = { 128 }; // weak
int dword_100EB758[] = { 0 }; // weak
int dword_100EB768[] = { 0 }; // weak
char byte_100EB7D9[] = { '\0' }; // weak
char byte_100EB7DA[] = { '\0' }; // weak
char byte_100EB7DB[] = { '\0' }; // weak
char byte_100EB7DC[] = { '\x10' }; // weak
int dword_100EB7F0[] = { 0 }; // weak
_UNKNOWN unk_100EB868; // weak
_UNKNOWN unk_100EBCE8; // weak
char byte_100EBD60[] = { '\0' }; // weak
char byte_100EBE60[] = { '\0' }; // weak
char byte_100EBF60[] = { '\0' }; // weak
int dword_100EC060[] = { 0 }; // weak
int dword_100EC0D8[] = { 0 }; // weak
int (__cdecl *off_100EC158)(int, int) = &sub_10053200; // weak
int dword_100EC340[] = { 0 }; // weak
int dword_100EC388[] = { 16 }; // weak
_UNKNOWN unk_100EC3D8; // weak
_UNKNOWN unk_100EC458; // weak
_UNKNOWN unk_100EC4D8; // weak
_UNKNOWN unk_100EC550; // weak
_UNKNOWN unk_100EC5C8; // weak
_UNKNOWN unk_100ED5C8; // weak
_UNKNOWN unk_100ED720; // weak
_UNKNOWN unk_100ED728; // weak
int (*off_100EF28C[3])() = { &_fptrap, &_fptrap, &_fptrap }; // weak
_UNKNOWN unk_100EF2A8; // weak
void *off_100EFDD0 = &unk_101F0400; // weak
_UNKNOWN unk_100EFDE0; // weak
_UNKNOWN unk_100EFE40; // weak
wchar_t *off_100F0050 = L"         (((((                  H"; // weak
int dword_100F0160 = 1024; // weak
int dword_100F0164 = 4294966273; // weak
int dword_100F0168 = 53; // weak
int dword_100F016C = 11; // weak
int dword_100F0170 = 64; // weak
int dword_100F0174 = 1023; // weak
int dword_100F0178 = 128; // weak
int dword_100F017C = 4294967169; // weak
int dword_100F0180 = 24; // weak
int dword_100F0184 = 8; // weak
int dword_100F0188 = 32; // weak
int dword_100F018C = 127; // weak
_UNKNOWN unk_100F07C0; // weak
char byte_100F07C4 = '\0'; // weak
int dword_100F07C8 = 0; // weak
_UNKNOWN unk_100F07D0; // weak
char byte_100F08A0 = '\0'; // weak
char byte_100F08A8 = '\0'; // idb
int dword_100F18A8; // weak
char byte_100F18B0[]; // weak
char byte_100F18B2; // weak
__int16 word_100F18B4[]; // weak
int dword_100F18B8; // weak
int dword_100F18BC; // weak
__int16 word_100F18C0[]; // weak
_UNKNOWN unk_100F18C8; // weak
_UNKNOWN unk_100F1960; // weak
_UNKNOWN unk_100F8960; // weak
int dword_100FD808; // weak
__int16 word_100FD810[]; // weak
char byte_100FD838[]; // weak
__int16 word_10102F24; // weak
__int16 word_10102F28; // weak
__int16 word_10102F2C; // weak
int dword_10102F30; // weak
void (__cdecl *dword_10102F38[8])(_DWORD, _DWORD, _DWORD); // idb
_UNKNOWN unk_10102F58; // weak
char byte_101080CC; // weak
char byte_101080CD; // weak
int dword_101080D0[]; // weak
int dword_101080E4; // weak
int dword_101080E8; // weak
_UNKNOWN unk_101080F0; // weak
_UNKNOWN unk_101080F1; // weak
_UNKNOWN unk_10108107; // weak
_UNKNOWN unk_10108108; // weak
_UNKNOWN unk_10108109; // weak
_UNKNOWN unk_1010810A; // weak
_UNKNOWN unk_1010810C; // weak
_UNKNOWN unk_10108110; // weak
_UNKNOWN unk_10108114; // weak
_UNKNOWN unk_10108134; // weak
_UNKNOWN unk_10108154; // weak
_UNKNOWN unk_10108174; // weak
_UNKNOWN unk_10108194; // weak
_UNKNOWN unk_101081B4; // weak
_UNKNOWN unk_101081D4; // weak
_UNKNOWN unk_101081F4; // weak
_UNKNOWN unk_10108214; // weak
_UNKNOWN unk_10108234; // weak
_UNKNOWN unk_10108254; // weak
_UNKNOWN unk_10108274; // weak
_UNKNOWN unk_10108294; // weak
_UNKNOWN unk_101082B4; // weak
_UNKNOWN unk_101082D4; // weak
_UNKNOWN unk_101082F4; // weak
_UNKNOWN unk_10108314; // weak
_UNKNOWN unk_10108334; // weak
_UNKNOWN unk_10108354; // weak
_UNKNOWN unk_10108374; // weak
_UNKNOWN unk_10108394; // weak
_UNKNOWN unk_101083B4; // weak
_UNKNOWN unk_101083D4; // weak
_UNKNOWN unk_101083F4; // weak
_UNKNOWN unk_10108414; // weak
_UNKNOWN unk_10108434; // weak
_UNKNOWN unk_10108454; // weak
_UNKNOWN unk_10108474; // weak
_UNKNOWN unk_10108494; // weak
_UNKNOWN unk_10108498; // weak
_UNKNOWN unk_1010849C; // weak
_UNKNOWN unk_101084A0; // weak
_UNKNOWN unk_101084A4; // weak
_UNKNOWN unk_101084A8; // weak
_UNKNOWN unk_101084AC; // weak
_UNKNOWN unk_101084CC; // weak
_UNKNOWN unk_101084EC; // weak
_UNKNOWN unk_1010850C; // weak
_UNKNOWN unk_1010852C; // weak
_UNKNOWN unk_1010854C; // weak
_UNKNOWN unk_1010856C; // weak
_UNKNOWN unk_1010858C; // weak
_UNKNOWN unk_101085AC; // weak
_UNKNOWN unk_101085AD; // weak
_UNKNOWN unk_101085AE; // weak
_UNKNOWN unk_10108600; // weak
_UNKNOWN unk_10108620; // weak
_UNKNOWN unk_10108640; // weak
_UNKNOWN unk_10108644; // weak
_UNKNOWN unk_10108648; // weak
_UNKNOWN unk_1010864C; // weak
_UNKNOWN unk_1010866C; // weak
_UNKNOWN unk_1010868C; // weak
_UNKNOWN unk_101086AC; // weak
_UNKNOWN unk_101086CC; // weak
_UNKNOWN unk_101086EC; // weak
_UNKNOWN unk_1010870C; // weak
_UNKNOWN unk_1010872C; // weak
_UNKNOWN unk_1010874C; // weak
_UNKNOWN unk_1010876C; // weak
_UNKNOWN unk_101087B4; // weak
_UNKNOWN unk_101087FC; // weak
_UNKNOWN unk_10108844; // weak
_UNKNOWN unk_1010888C; // weak
_UNKNOWN unk_101088D4; // weak
_UNKNOWN unk_1010891C; // weak
_UNKNOWN unk_10108964; // weak
_UNKNOWN unk_101089AC; // weak
_UNKNOWN unk_101089F4; // weak
_UNKNOWN unk_10108A3C; // weak
_UNKNOWN unk_10108A84; // weak
_UNKNOWN unk_10108ACC; // weak
_UNKNOWN unk_10108B14; // weak
_UNKNOWN unk_10108B5C; // weak
_UNKNOWN unk_10108BA4; // weak
_UNKNOWN unk_10108BEC; // weak
_UNKNOWN unk_10108C34; // weak
_UNKNOWN unk_10108C7C; // weak
_UNKNOWN unk_10108CC4; // weak
_UNKNOWN unk_10108D0C; // weak
_UNKNOWN unk_10108D54; // weak
_UNKNOWN unk_10108D9C; // weak
_UNKNOWN unk_10108DE4; // weak
_UNKNOWN unk_10108E2C; // weak
_UNKNOWN unk_10108E74; // weak
_UNKNOWN unk_10108EBC; // weak
_UNKNOWN unk_10108F04; // weak
_UNKNOWN unk_10108F4C; // weak
_UNKNOWN unk_10108F94; // weak
_UNKNOWN unk_10108FDC; // weak
_UNKNOWN unk_10108FF4; // weak
_UNKNOWN unk_10109014; // weak
_UNKNOWN unk_10109034; // weak
_UNKNOWN unk_10109038; // weak
_UNKNOWN unk_101090DC; // weak
_UNKNOWN unk_10109180; // weak
_UNKNOWN unk_10109224; // weak
_UNKNOWN unk_101092C8; // weak
_UNKNOWN unk_1010936C; // weak
_UNKNOWN unk_10109410; // weak
_UNKNOWN unk_101094B4; // weak
_UNKNOWN unk_10109558; // weak
_UNKNOWN unk_101095FC; // weak
_UNKNOWN unk_101096A0; // weak
_UNKNOWN unk_10109744; // weak
_UNKNOWN unk_101097E8; // weak
_UNKNOWN unk_1010988C; // weak
_UNKNOWN unk_10109930; // weak
_UNKNOWN unk_101099D4; // weak
_UNKNOWN unk_10109A78; // weak
_UNKNOWN unk_10109B1C; // weak
_UNKNOWN unk_10109BC0; // weak
_UNKNOWN unk_10109C64; // weak
_UNKNOWN unk_10109D08; // weak
_UNKNOWN unk_10109DAC; // weak
_UNKNOWN unk_10109E50; // weak
_UNKNOWN unk_10109EF4; // weak
_UNKNOWN unk_10109F98; // weak
_UNKNOWN unk_1010A03C; // weak
_UNKNOWN unk_1010A0E0; // weak
_UNKNOWN unk_1010A184; // weak
_UNKNOWN unk_1010A228; // weak
_UNKNOWN unk_1010A2CC; // weak
_UNKNOWN unk_1010A370; // weak
_UNKNOWN unk_1010A414; // weak
_UNKNOWN unk_1010A4B8; // weak
_UNKNOWN unk_1010A55C; // weak
_UNKNOWN unk_1010A600; // weak
_UNKNOWN unk_1010A6A4; // weak
_UNKNOWN unk_1010A748; // weak
_UNKNOWN unk_1010A7EC; // weak
_UNKNOWN unk_1010A890; // weak
_UNKNOWN unk_1010A934; // weak
_UNKNOWN unk_1010A9D8; // weak
_UNKNOWN unk_1010AA7C; // weak
_UNKNOWN unk_1010AB20; // weak
_UNKNOWN unk_1010ABC4; // weak
_UNKNOWN unk_1010AC68; // weak
_UNKNOWN unk_1010AD0C; // weak
_UNKNOWN unk_1010ADB0; // weak
_UNKNOWN unk_1010AE54; // weak
_UNKNOWN unk_1010AEF8; // weak
_UNKNOWN unk_1010AF9C; // weak
_UNKNOWN unk_1010B040; // weak
_UNKNOWN unk_1010B0E4; // weak
_UNKNOWN unk_1010B188; // weak
_UNKNOWN unk_1010B22C; // weak
_UNKNOWN unk_1010B2D0; // weak
_UNKNOWN unk_1010B374; // weak
_UNKNOWN unk_1010B418; // weak
_UNKNOWN unk_1010B4BC; // weak
_UNKNOWN unk_1010B560; // weak
_UNKNOWN unk_1010B604; // weak
_UNKNOWN unk_1010B6A8; // weak
_UNKNOWN unk_1010B74C; // weak
_UNKNOWN unk_1010B7F0; // weak
_UNKNOWN unk_1010B894; // weak
_UNKNOWN unk_1010B938; // weak
_UNKNOWN unk_1010B9DC; // weak
_UNKNOWN unk_1010BA80; // weak
_UNKNOWN unk_1010BB24; // weak
_UNKNOWN unk_1010BBC8; // weak
_UNKNOWN unk_1010BC6C; // weak
_UNKNOWN unk_1010BD10; // weak
_UNKNOWN unk_1010BDB4; // weak
_UNKNOWN unk_1010BE58; // weak
_UNKNOWN unk_1010BEFC; // weak
_UNKNOWN unk_1010BFA0; // weak
_UNKNOWN unk_1010C044; // weak
_UNKNOWN unk_1010C0E8; // weak
_UNKNOWN unk_1010C18C; // weak
_UNKNOWN unk_1010C230; // weak
_UNKNOWN unk_1010C2D4; // weak
_UNKNOWN unk_1010C378; // weak
_UNKNOWN unk_1010C41C; // weak
_UNKNOWN unk_1010C4C0; // weak
_UNKNOWN unk_1010C564; // weak
_UNKNOWN unk_1010C608; // weak
_UNKNOWN unk_1010C6AC; // weak
_UNKNOWN unk_1010C750; // weak
_UNKNOWN unk_1010C7F4; // weak
_UNKNOWN unk_1010C898; // weak
_UNKNOWN unk_1010C93C; // weak
_UNKNOWN unk_1010C9E0; // weak
_UNKNOWN unk_1010CA84; // weak
_UNKNOWN unk_1010CB28; // weak
_UNKNOWN unk_1010CBCC; // weak
_UNKNOWN unk_1010CC70; // weak
_UNKNOWN unk_1010CD14; // weak
_UNKNOWN unk_1010CDB8; // weak
_UNKNOWN unk_1010CE5C; // weak
_UNKNOWN unk_1010CF00; // weak
_UNKNOWN unk_1010CFA4; // weak
_UNKNOWN unk_1010D048; // weak
_UNKNOWN unk_1010D068; // weak
_UNKNOWN unk_1010D088; // weak
_UNKNOWN unk_1010D0A8; // weak
_UNKNOWN unk_1010D0C8; // weak
_UNKNOWN unk_1010D0F0; // weak
_UNKNOWN unk_1010D10C; // weak
_UNKNOWN unk_1010D128; // weak
_UNKNOWN unk_1010D144; // weak
_UNKNOWN unk_1010D160; // weak
_UNKNOWN unk_1010D17C; // weak
_UNKNOWN unk_1010D198; // weak
_UNKNOWN unk_1010D1B4; // weak
_UNKNOWN unk_1010D1D0; // weak
_UNKNOWN unk_1010D1EC; // weak
_UNKNOWN unk_1010D208; // weak
_UNKNOWN unk_1010D224; // weak
_UNKNOWN unk_1010D240; // weak
_UNKNOWN unk_1010D25C; // weak
_UNKNOWN unk_1010D278; // weak
_UNKNOWN unk_1010D294; // weak
_UNKNOWN unk_1010D2B0; // weak
_UNKNOWN unk_1010D2CC; // weak
_UNKNOWN unk_1010D2E8; // weak
_UNKNOWN unk_1010D304; // weak
_UNKNOWN unk_1010D320; // weak
_UNKNOWN unk_1010D33C; // weak
_UNKNOWN unk_1010D358; // weak
_UNKNOWN unk_1010D374; // weak
_UNKNOWN unk_1010D390; // weak
_UNKNOWN unk_1010D3AC; // weak
_UNKNOWN unk_1010D3C8; // weak
_UNKNOWN unk_1010D3E4; // weak
_UNKNOWN unk_1010D400; // weak
_UNKNOWN unk_1010D41C; // weak
_UNKNOWN unk_1010D438; // weak
_UNKNOWN unk_1010D454; // weak
_UNKNOWN unk_1010D470; // weak
_UNKNOWN unk_1010D48C; // weak
_UNKNOWN unk_1010D4A8; // weak
_UNKNOWN unk_1010D4C4; // weak
_UNKNOWN unk_1010D4E0; // weak
_UNKNOWN unk_1010D4FC; // weak
_UNKNOWN unk_1010D518; // weak
_UNKNOWN unk_1010D534; // weak
_UNKNOWN unk_1010D550; // weak
_UNKNOWN unk_1010D56C; // weak
_UNKNOWN unk_1010D588; // weak
_UNKNOWN unk_1010D5A4; // weak
_UNKNOWN unk_1010D5C0; // weak
_UNKNOWN unk_1010D5DC; // weak
_UNKNOWN unk_1010D5F8; // weak
_UNKNOWN unk_1010D614; // weak
_UNKNOWN unk_1010D630; // weak
_UNKNOWN unk_1010D64C; // weak
_UNKNOWN unk_1010D668; // weak
_UNKNOWN unk_1010D684; // weak
_UNKNOWN unk_1010D6A0; // weak
_UNKNOWN unk_1010D6BC; // weak
_UNKNOWN unk_1010D6D8; // weak
_UNKNOWN unk_1010D6F4; // weak
_UNKNOWN unk_1010D710; // weak
_UNKNOWN unk_1010D72C; // weak
_UNKNOWN unk_1010D748; // weak
_UNKNOWN unk_1010D764; // weak
_UNKNOWN unk_1010D780; // weak
_UNKNOWN unk_1010D79C; // weak
_UNKNOWN unk_1010D7B8; // weak
_UNKNOWN unk_1010D7D4; // weak
_UNKNOWN unk_1010D7F0; // weak
_UNKNOWN unk_1010D80C; // weak
_UNKNOWN unk_1010D828; // weak
_UNKNOWN unk_1010D844; // weak
_UNKNOWN unk_1010D860; // weak
_UNKNOWN unk_1010D87C; // weak
_UNKNOWN unk_1010D898; // weak
_UNKNOWN unk_1010D8B4; // weak
_UNKNOWN unk_1010D8D0; // weak
_UNKNOWN unk_1010D8EC; // weak
_UNKNOWN unk_1010D908; // weak
_UNKNOWN unk_1010D924; // weak
_UNKNOWN unk_1010D940; // weak
_UNKNOWN unk_1010D95C; // weak
_UNKNOWN unk_1010D978; // weak
_UNKNOWN unk_1010D994; // weak
_UNKNOWN unk_1010D9B0; // weak
_UNKNOWN unk_1010D9CC; // weak
_UNKNOWN unk_1010D9E8; // weak
_UNKNOWN unk_1010DA04; // weak
_UNKNOWN unk_1010DA20; // weak
_UNKNOWN unk_1010DA3C; // weak
_UNKNOWN unk_1010DA58; // weak
_UNKNOWN unk_1010DA74; // weak
_UNKNOWN unk_1010DA90; // weak
_UNKNOWN unk_1010DAAC; // weak
_UNKNOWN unk_1010DAC8; // weak
_UNKNOWN unk_1010DAE4; // weak
_UNKNOWN unk_1010DB00; // weak
_UNKNOWN unk_1010DB1C; // weak
_UNKNOWN unk_1010DB38; // weak
_UNKNOWN unk_1010DB54; // weak
_UNKNOWN unk_1010DB70; // weak
_UNKNOWN unk_1010DB8C; // weak
_UNKNOWN unk_1010DBA8; // weak
_UNKNOWN unk_1010DBC4; // weak
_UNKNOWN unk_1010DBE0; // weak
_UNKNOWN unk_1010DBE4; // weak
_UNKNOWN unk_1010DBE8; // weak
_UNKNOWN unk_1010DBEC; // weak
_UNKNOWN unk_1010DBF0; // weak
_UNKNOWN unk_1010DBF4; // weak
_UNKNOWN unk_1010DBF8; // weak
_UNKNOWN unk_1010DBFC; // weak
_UNKNOWN unk_1010DC00; // weak
_UNKNOWN unk_1010DC04; // weak
_UNKNOWN unk_1010DC08; // weak
_UNKNOWN unk_1010DC0C; // weak
_UNKNOWN unk_1010DC10; // weak
_UNKNOWN unk_1010DC14; // weak
_UNKNOWN unk_1010DC18; // weak
_UNKNOWN unk_1010DC1C; // weak
_UNKNOWN unk_1010DC20; // weak
_UNKNOWN unk_1010DC24; // weak
_UNKNOWN unk_1010DC28; // weak
_UNKNOWN unk_1010DD0C; // weak
_UNKNOWN unk_1010EECC; // weak
_UNKNOWN unk_1010EED0; // weak
_UNKNOWN unk_1010EEF8; // weak
_UNKNOWN unk_1010EF20; // weak
_UNKNOWN unk_1010EF60; // weak
_UNKNOWN unk_1010EFE0; // weak
_UNKNOWN unk_1010EFE4; // weak
_UNKNOWN unk_1010EFE8; // weak
_UNKNOWN unk_1010EFEA; // weak
_UNKNOWN unk_1010EFEC; // weak
_UNKNOWN unk_1010EFED; // weak
_UNKNOWN unk_1010EFEE; // weak
_UNKNOWN unk_1010EFF0; // weak
_UNKNOWN unk_1010F054; // weak
_UNKNOWN unk_1010F05C; // weak
_UNKNOWN unk_1010F064; // weak
_UNKNOWN unk_1010F06C; // weak
_UNKNOWN unk_1010F074; // weak
_UNKNOWN unk_1010F07C; // weak
_UNKNOWN unk_1010F084; // weak
_UNKNOWN unk_1010F08C; // weak
_UNKNOWN unk_1010F094; // weak
_UNKNOWN unk_1010F09C; // weak
_UNKNOWN unk_1010F0A4; // weak
_UNKNOWN unk_1010F0AC; // weak
_UNKNOWN unk_1010F0B4; // weak
_UNKNOWN unk_1010F0BC; // weak
_UNKNOWN unk_1010F0C4; // weak
_UNKNOWN unk_1010F0CC; // weak
_UNKNOWN unk_1010F0D4; // weak
_UNKNOWN unk_1010F0DC; // weak
_UNKNOWN unk_1010F0E4; // weak
_UNKNOWN unk_1010F0EC; // weak
_UNKNOWN unk_1010F0F4; // weak
_UNKNOWN unk_1010F0FC; // weak
_UNKNOWN unk_1010F104; // weak
_UNKNOWN unk_1010F10C; // weak
_UNKNOWN unk_1010F114; // weak
_UNKNOWN unk_1010F11C; // weak
_UNKNOWN unk_1010F124; // weak
_UNKNOWN unk_1010F12C; // weak
_UNKNOWN unk_1010F134; // weak
_UNKNOWN unk_1010F13C; // weak
_UNKNOWN unk_1010F144; // weak
_UNKNOWN unk_1010F14C; // weak
_UNKNOWN unk_1010F154; // weak
_UNKNOWN unk_1010F15C; // weak
_UNKNOWN unk_1010F164; // weak
_UNKNOWN unk_1010F16C; // weak
_UNKNOWN unk_1010F174; // weak
_UNKNOWN unk_1010F17C; // weak
_UNKNOWN unk_1010F184; // weak
_UNKNOWN unk_1010F18C; // weak
_UNKNOWN unk_1010F374; // weak
_UNKNOWN unk_1010F384; // weak
_UNKNOWN unk_1010F394; // weak
_UNKNOWN unk_1010F3A4; // weak
_UNKNOWN unk_1010F3A5; // weak
_UNKNOWN unk_1010F3A6; // weak
_UNKNOWN unk_1010F3A8; // weak
_UNKNOWN unk_1010F3AC; // weak
_UNKNOWN unk_1010F454; // weak
_UNKNOWN unk_1010F458; // weak
_UNKNOWN unk_1010F45C; // weak
_UNKNOWN unk_1010F4AC; // weak
_UNKNOWN unk_1010F4B0; // weak
_UNKNOWN unk_1010F4B4; // weak
_UNKNOWN unk_1010F5A4; // weak
_UNKNOWN unk_1010F694; // weak
_UNKNOWN unk_1010F698; // weak
_UNKNOWN unk_1010F6A0; // weak
_UNKNOWN unk_1010F6A8; // weak
_UNKNOWN unk_1010F6B0; // weak
_UNKNOWN unk_1010F6B8; // weak
_UNKNOWN unk_1010F6C0; // weak
_UNKNOWN unk_1010F6C8; // weak
_UNKNOWN unk_1010F6D0; // weak
_UNKNOWN unk_1010F6D8; // weak
_UNKNOWN unk_1010F6E0; // weak
_UNKNOWN unk_1010F6E8; // weak
_UNKNOWN unk_1010F6F0; // weak
_UNKNOWN unk_1010F6F4; // weak
_UNKNOWN unk_1010F6F8; // weak
_UNKNOWN unk_1010F6FC; // weak
_UNKNOWN unk_1010F750; // weak
_UNKNOWN unk_1010F7A4; // weak
_UNKNOWN unk_1010F7AC; // weak
_UNKNOWN unk_1010F7B0; // weak
_UNKNOWN unk_1010F7B4; // weak
_UNKNOWN unk_1010F7B8; // weak
_UNKNOWN unk_1010F7BC; // weak
_UNKNOWN unk_1010F9C4; // weak
_UNKNOWN unk_1010FB24; // weak
_UNKNOWN unk_1010FB3C; // weak
_UNKNOWN unk_1010FB54; // weak
_UNKNOWN unk_1010FB5E; // weak
_UNKNOWN unk_1010FB60; // weak
_UNKNOWN unk_1010FB70; // weak
_UNKNOWN unk_1010FB74; // weak
_UNKNOWN unk_1010FB78; // weak
_UNKNOWN unk_1010FB7C; // weak
_UNKNOWN unk_1010FB7D; // weak
_UNKNOWN unk_1010FB80; // weak
_UNKNOWN unk_1010FBD0; // weak
_UNKNOWN unk_1010FBD4; // weak
_UNKNOWN unk_1010FBD5; // weak
_UNKNOWN unk_1010FBD6; // weak
_UNKNOWN unk_1010FBD7; // weak
_UNKNOWN unk_1010FBEB; // weak
_UNKNOWN unk_1010FBEC; // weak
_UNKNOWN unk_1010FBED; // weak
_UNKNOWN unk_1010FBEE; // weak
_UNKNOWN unk_1010FBF0; // weak
_UNKNOWN unk_1010FC90; // weak
_UNKNOWN unk_1010FCE0; // weak
_UNKNOWN unk_1010FCE4; // weak
_UNKNOWN unk_1010FCE8; // weak
_UNKNOWN unk_1010FCEC; // weak
_UNKNOWN unk_1010FCF0; // weak
_UNKNOWN unk_1010FCF4; // weak
_UNKNOWN unk_1010FCF8; // weak
_UNKNOWN unk_1010FCFC; // weak
_UNKNOWN unk_1010FD00; // weak
_UNKNOWN unk_1010FD04; // weak
_UNKNOWN unk_1010FD08; // weak
_UNKNOWN unk_1010FD0C; // weak
_UNKNOWN unk_1010FD10; // weak
_UNKNOWN unk_1010FE50; // weak
_UNKNOWN unk_1010FE5C; // weak
_UNKNOWN unk_1010FEA4; // weak
_UNKNOWN unk_1010FEA5; // weak
_UNKNOWN unk_1010FED0; // weak
_UNKNOWN unk_1010FF00; // weak
_UNKNOWN unk_1010FF28; // weak
_UNKNOWN unk_1010FF2C; // weak
_UNKNOWN unk_1010FF30; // weak
_UNKNOWN unk_1010FF34; // weak
_UNKNOWN unk_1010FF64; // weak
_UNKNOWN unk_1010FF65; // weak
_UNKNOWN unk_1010FF66; // weak
_UNKNOWN unk_1010FF68; // weak
_UNKNOWN unk_1010FF6C; // weak
_UNKNOWN unk_1010FF70; // weak
_UNKNOWN unk_1010FF74; // weak
_UNKNOWN unk_1010FF78; // weak
_UNKNOWN unk_1010FF7C; // weak
_UNKNOWN unk_1010FF80; // weak
_UNKNOWN unk_1010FF84; // weak
_UNKNOWN unk_1010FF88; // weak
_UNKNOWN unk_1010FF8C; // weak
_UNKNOWN unk_101102EC; // weak
_UNKNOWN unk_101102F0; // weak
_UNKNOWN unk_101102FA; // weak
_UNKNOWN unk_10110304; // weak
__int16 word_10111AC0; // weak
int dword_10111AC8; // weak
_UNKNOWN unk_10111AD0; // weak
char byte_10111DA8[]; // weak
char byte_10111DA9[]; // weak
_UNKNOWN unk_10113010; // weak
int dword_101149C0; // weak
int dword_101149C4; // weak
int dword_101149C8; // weak
int dword_101149CC; // weak
int dword_101149D0; // weak
int dword_101149D4; // weak
int dword_101149D8; // weak
int dword_101149DC; // weak
int dword_101149E0; // weak
int dword_101149E4; // weak
int dword_101149E8; // weak
int dword_101149EC; // weak
int dword_101149F0; // weak
int dword_101149F4; // weak
int dword_10114A64; // weak
int dword_10114A68; // weak
int dword_10114A6C; // weak
int dword_10114A70; // weak
char byte_10114A74; // weak
_UNKNOWN unk_10114A9C; // weak
_UNKNOWN unk_10114AA0; // weak
int dword_10114AA4; // weak
int dword_10114AB0[]; // weak
int dword_10114AB4; // weak
int dword_10114AB8; // weak
int dword_10114ABC; // weak
int dword_10114AC0; // weak
int dword_10114AC4[]; // weak
int dword_10114AC8; // weak
int dword_10114ACC; // weak
int dword_10114AD0; // weak
int dword_10114AD4; // weak
_UNKNOWN unk_10114AD8; // weak
char byte_10114BF0; // idb
char byte_10114CF0[254]; // idb
char byte_10114DEE[]; // weak
char byte_10114DEF[]; // weak
char byte_101151F0[2800]; // idb
char byte_10115CE0[1022]; // idb
char byte_101160DE[]; // weak
char byte_101160DF[]; // weak
char byte_101160E0[1022]; // idb
char byte_101164DE[]; // weak
char byte_101164DF[]; // weak
char byte_101164E0[1022]; // idb
char byte_101168DE[]; // weak
char byte_101168DF[]; // weak
int dword_101198E0[]; // weak
int dword_101198F4[]; // weak
char byte_10119908[2800]; // idb
char byte_1011A3F8[2800]; // idb
char byte_1011AEE8[2800]; // idb
int dword_1011B9D8[]; // weak
int dword_1011B9EC[]; // weak
char byte_1011BA00[2796]; // idb
char byte_1011C4EC[]; // weak
char byte_1011C4F0[559]; // idb
char byte_1011C71F[]; // weak
int dword_1011CFE0[]; // weak
int dword_1011CFF4[]; // weak
char byte_1011D008[2800]; // idb
int dword_1011DAF8; // weak
_UNKNOWN unk_1011DB00; // weak
_UNKNOWN unk_1011E658; // weak
int dword_101209C0; // weak
_UNKNOWN unk_101209C8; // weak
int dword_10121F08; // weak
char byte_10121F10[]; // weak
char byte_10121F14[]; // weak
char byte_10121F15[]; // weak
int dword_10121F1C[]; // weak
int dword_10121F24[]; // weak
int dword_10121F58; // weak
int dword_10121F5C; // weak
int dword_10121F60; // weak
int dword_10121F64; // weak
_UNKNOWN unk_10121F68; // weak
_UNKNOWN unk_10121F70; // weak
_UNKNOWN unk_10121F78; // weak
int dword_10181CC8; // weak
char byte_10181CD0[]; // weak
char byte_10181D20[]; // weak
char byte_10189070; // weak
char byte_10189071; // weak
char byte_1018B918[]; // weak
char byte_1018B919[]; // weak
_UNKNOWN unk_1018B9B8; // weak
int dword_1018BC88[]; // weak
int dword_1018BC8C[]; // weak
_UNKNOWN unk_1018C1A8; // weak
_UNKNOWN unk_1018F0B0; // weak
_UNKNOWN unk_1018F5B0; // weak
_UNKNOWN unk_1018F658; // weak
char byte_1018F678; // weak
char byte_1018F679; // weak
char byte_1018F67A; // weak
char byte_1018F67B; // weak
_UNKNOWN unk_1018F680; // weak
_UNKNOWN unk_1018F6A0; // weak
int dword_10190880; // weak
int dword_10190884; // weak
int dword_10190888; // weak
int dword_1019088C; // weak
int dword_10190890; // weak
int dword_10190894; // weak
int dword_10196118; // weak
int dword_101A1F48; // weak
_DWORD dword_101AEF38[16]; // idb
int dword_101AEF78[]; // weak
int dword_101AEFB8; // weak
int dword_101AEFC0[]; // weak
char byte_101AF000; // weak
char byte_101AF001; // weak
int dword_101AF01C; // weak
int dword_101AF348; // weak
int dword_101AF354; // weak
int dword_101AF4B0; // weak
int dword_101AF978; // weak
int dword_101AF984; // weak
int dword_101AF990; // weak
int dword_101AF994; // weak
int dword_101AF998; // weak
int dword_101AF9B4; // weak
int dword_101AF9B8; // weak
int dword_101AF9BC; // weak
int dword_101AF9C0; // weak
int dword_101AF9C4; // weak
int dword_101BD3B8; // weak
char byte_101BD3BC; // weak
char byte_101BD3BD; // weak
char byte_101BD3BE; // weak
int dword_101BD3C0; // weak
_UNKNOWN unk_101BD3C4; // weak
char byte_101EF3E0; // weak
char byte_101EF3E1; // weak
char byte_101EF3E2; // weak
char byte_101EF3E4; // weak
char byte_101EF3EB; // weak
__int16 word_101EF3EE; // weak
__int16 word_101EF3F0; // weak
__int16 word_101EF3F4; // weak
int dword_101EF3F8; // weak
int dword_101EF3FC; // weak
int dword_101EF414; // weak
int dword_101EF420; // weak
int dword_101EF428; // weak
char byte_101EF568; // weak
int dword_101EF5BC; // weak
char byte_101EF5C0; // weak
int dword_101EF5E0[]; // weak
_BYTE dword_101EF5E4[1120]; // idb
int dword_101EFA48; // weak
int dword_101EFA4C; // weak
char byte_101EFA50; // weak
int dword_101EFA54; // weak
char byte_101EFA58; // weak
int dword_101EFA5C; // weak
char byte_101EFA60; // weak
int dword_101EFA64; // weak
int dword_101EFA68; // weak
_UNKNOWN unk_101EFA80; // weak
int dword_101EFA84[]; // weak
char byte_101EFA8F[]; // weak
char byte_101EFA91[]; // weak
int dword_101EFB48; // weak
int dword_101EFB4C; // weak
int dword_101EFB50; // weak
char byte_101EFB54; // weak
int dword_101EFB60[]; // weak
__int16 word_101EFB64[]; // weak
int dword_101EFB68[]; // weak
int dword_101EFB6C; // weak
int dword_101EFB70; // weak
int dword_101EFB74; // weak
int dword_101EFB78; // weak
__int16 word_101EFB7C; // weak
int dword_101EFB80; // weak
__int16 word_101EFBC4; // weak
int dword_101EFBC8; // weak
int dword_101EFBE4; // weak
__int16 word_101EFBE8; // weak
int dword_101EFC28; // weak
int dword_101EFC58; // weak
int dword_101EFCA0; // weak
int dword_101EFD48; // weak
int dword_101EFD54; // weak
int dword_101EFD64; // weak
__int16 word_101EFD68; // weak
int dword_101EFD70; // weak
__int16 word_101EFD74; // weak
int dword_101EFD7C; // weak
__int16 word_101EFD80; // weak
int dword_101EFE84; // weak
int dword_101EFEFC; // weak
__int16 word_101EFF00; // weak
_UNKNOWN unk_101F0268; // weak
_UNKNOWN unk_101F0269; // weak
_UNKNOWN unk_101F026A; // weak
__int16 word_101F0280[]; // weak
__int16 word_101F0282; // weak
__int16 word_101F0284; // weak
__int16 word_101F0286; // weak
__int16 word_101F0288; // weak
__int16 word_101F028A; // weak
__int16 word_101F028C; // weak
__int16 word_101F028E; // weak
__int16 word_101F02A4; // weak
__int16 word_101F02A6; // weak
char byte_101F03AC; // weak
char byte_101F03AD; // weak
int dword_101F03B0; // weak
char byte_101F03B4; // weak
char byte_101F03BC[]; // weak
int dword_101F03C0; // weak
int dword_101F03D0; // weak
int dword_101F03D4; // weak
int dword_101F03D8; // weak
int dword_101F03DC; // weak
int dword_101F03E0; // weak
void *dword_101F03E4; // idb
int dword_101F1400; // weak
int dword_101F141C; // weak
UINT uNumber; // idb
int dword_101F1440[]; // weak
int dword_101F1540; // weak
int dword_101F1558; // weak


//----- (10001000) --------------------------------------------------------
char __cdecl sub_10001000(int a1)
{
  int *v1; // ecx@1
  __int16 v2; // bx@1
  __int16 v3; // di@1
  char result; // al@1
  bool v5; // zf@1
  __int16 v6; // bp@1
  int v7; // ecx@3
  __int16 v8; // si@4
  __int16 v9; // dx@5
  char v10; // [sp+13h] [bp-1h]@1
  int v11; // [sp+18h] [bp+4h]@1

  v1 = (int *)a1;
  v2 = *(_WORD *)(a1 + 30);
  v3 = *(_WORD *)(a1 + 28);
  result = 0;
  v5 = a1 == dword_101EFA48;
  v10 = 0;
  v6 = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 34) - 1;
  v11 = (unsigned __int16)(*(_WORD *)(a1 + 28) + *(_WORD *)(a1 + 32) - 1);
  if ( v5 )
  {
    result = 1;
    v10 = 1;
  }
  v7 = *v1;
  if ( v7 )
  {
    while ( 1 )
    {
      v8 = *(_WORD *)(v7 + 28);
      if ( v3 >= v8 )
      {
        v9 = *(_WORD *)(v7 + 30);
        if ( v2 >= v9 && v6 <= *(_WORD *)(v7 + 34) + v9 - 1 && (signed __int16)v11 <= *(_WORD *)(v7 + 32) + v8 - 1 )
          break;
      }
      v7 = *(_DWORD *)v7;
      if ( !v7 )
        return v10;
    }
    result = 1;
  }
  return result;
}
// 101EFA48: using guessed type int dword_101EFA48;

//----- (100010B0) --------------------------------------------------------
bool __cdecl sub_100010B0(int a1, int a2)
{
  char v2; // al@1

  v2 = *(_BYTE *)(a2 + 24);
  return v2 == 1 || v2 == 3;
}

//----- (100010D0) --------------------------------------------------------
int __usercall sub_100010D0@<eax>(int result@<eax>, int a2@<esi>)
{
  signed int v2; // ST1C_4@2
  float v3; // ST10_4@2
  float v4; // ST08_4@2

  if ( *(_BYTE *)(result + 11) )
  {
    j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
    j_gdi_pvg_matrix_mode(51);
    ((void (*)(void))j_gdi_pvg_load_identity)();
    v2 = *(_WORD *)(a2 + 32);
    v3 = (double)*(_WORD *)(a2 + 34);
    v4 = (double)v2;
    sub_10031720(0.0, v4, 0.0, v3, 0.0, 1.0);
    j_gdi_pvg_matrix_mode(52);
    j_gdi_pvg_load_identity(v2);
    if ( (*(_BYTE *)(a2 + 24) & 3) == 2 )
      result = j_gdi_pvg_viewport(0, 0, *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
    else
      result = j_gdi_pvg_viewport(*(_WORD *)(a2 + 28), *(_WORD *)(a2 + 30), *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
  }
  return result;
}
// 100316E0: using guessed type int __cdecl j_gdi_pvg_load_identity(_DWORD);
// 10031700: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 10031710: using guessed type int __cdecl j_gdi_pvg_matrix_mode(_DWORD);
// 100317D0: using guessed type int __cdecl j_gdi_pvg_viewport(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001180) --------------------------------------------------------
int __cdecl sub_10001180(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // edx@2

  v2 = a2;
  if ( a2 )
  {
    v3 = a1;
    do
    {
      if ( sub_100010B0(v3, v2) )
        break;
      v2 = *(_DWORD *)(v2 + 4);
    }
    while ( v2 );
  }
  return v2;
}

//----- (100011B0) --------------------------------------------------------
char __cdecl sub_100011B0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)
{
  int v6; // eax@2

  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 24) = a6;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) = a5;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) = a4;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 28) = a2;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 30) = a3;
  switch ( a6 & 3 )
  {
    case 0:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = sub_100028A0(a1, a4, a5);
      LOBYTE(v6) = -1;
      if ( *(_DWORD *)(a1 + 24) == -1 || *(_BYTE *)(a1 + 11) != 1 )
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = -1;
      }
      else
      {
        sub_10031820();
        sub_10031870(1);
        v6 = sub_100317E0(a4, a5, 57);
        *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = v6;
      }
      break;
    case 1:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = &unk_100F1960;
      v6 = *(_DWORD *)(a1 + 28);
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = v6;
      break;
    case 2:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = 0;
      sub_10031820();
      sub_10031870(1);
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = sub_100317E0(a4, a5, 59);
      LOBYTE(v6) = sub_100010D0(a1, *(_DWORD *)(a1 + 56));
      break;
    case 3:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = 0;
      v6 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)(v6 + 52) = *(_DWORD *)(a1 + 24);
      break;
    default:
      LOBYTE(v6) = sub_1000D740(".\\cdp_cnvs_utl.c", 250, 1, 0);
      break;
  }
  return v6;
}
// 1005A76C: using guessed type void *off_1005A76C;

//----- (100012F0) --------------------------------------------------------
char __cdecl sub_100012F0(int a1, int a2)
{
  __int64 v2; // rax@4
  char result; // al@4
  int v4; // eax@5
  int v5; // eax@6
  int v6; // edx@6
  int v7; // eax@7
  int v8; // esi@9

  if ( !a2 )
    sub_1000D740(".\\cdp_cnvs_utl.c", 388, 1, 0);
  switch ( *(_BYTE *)(a2 + 24) & 3 )
  {
    case 0:
      *(_WORD *)(a1 + 270) = *(_WORD *)(a2 + 32);
      *(_WORD *)(a1 + 268) = *(_WORD *)(a2 + 34);
      *(_BYTE *)(a1 + 272) = 8;
      v2 = *(_WORD *)(a2 + 32) + 255;
      *(_WORD *)(a1 + 274) = (unsigned __int16)((BYTE4(v2) + (signed int)v2) >> 8) << 8;
      *(_DWORD *)(a1 + 264) = *(_DWORD *)(a2 + 48);
      *(_BYTE *)(a1 + 273) = 0;
      *(_DWORD *)(a1 + 444) = a1 + 264;
      *(_WORD *)(a1 + 418) = 0;
      *(_WORD *)(a1 + 416) = 0;
      *(_DWORD *)(a1 + 420) = *(_DWORD *)(a1 + 268);
      *(_WORD *)(a1 + 434) = 0;
      *(_WORD *)(a1 + 432) = 0;
      result = 1;
      break;
    case 1:
      v4 = *(_DWORD *)(a1 + 56);
      if ( *(_DWORD *)(v4 + 8) != *(_DWORD *)(a1 + 44) )
      {
        *(_DWORD *)(v4 + 52) = *(_DWORD *)(a1 + 24);
        sub_100010D0(a1, *(_DWORD *)(a1 + 56));
        v5 = *(_DWORD *)(a1 + 56);
        v6 = *(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 44) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(v5 + 52) = v6;
      }
      *(_DWORD *)(a1 + 264) = &unk_100F1960;
      v7 = a1 + 264;
      *(_DWORD *)(v7 + 4) = *(&off_1005A76C + 1);
      *(_DWORD *)(v7 + 8) = *(&off_1005A76C + 2);
      *(_DWORD *)(a1 + 444) = a1 + 264;
      *(_WORD *)(a1 + 418) = 0;
      *(_WORD *)(a1 + 416) = 0;
      *(_DWORD *)(a1 + 420) = *(_DWORD *)(a1 + 268);
      sub_10033D00(a1 + 392, *(_WORD *)(a2 + 28), *(_WORD *)(a2 + 30), *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
      *(_WORD *)(a1 + 434) = *(_WORD *)(a2 + 28);
      *(_WORD *)(a1 + 432) = *(_WORD *)(a2 + 30);
      result = 1;
      break;
    case 2:
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
      result = 1;
      break;
    case 3:
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
      v8 = *(_DWORD *)(a1 + 56);
      if ( *(_DWORD *)(v8 + 8) == *(_DWORD *)(a1 + 44) )
        goto LABEL_12;
      sub_100010D0(a1, v8);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 8);
      result = 1;
      break;
    default:
      sub_1000D740(".\\cdp_cnvs_utl.c", 473, 1, 0);
LABEL_12:
      result = 1;
      break;
  }
  return result;
}
// 10031700: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 1005A76C: using guessed type void *off_1005A76C;

//----- (100014E0) --------------------------------------------------------
unsigned int sub_100014E0()
{
  int *v0; // ecx@1
  unsigned int result; // eax@1
  int v2; // ecx@3
  int v3; // ecx@3
  int v4; // ecx@3
  int v5; // ecx@3
  int v6; // edx@3

  v0 = dword_101EF5E4;
  result = 0;
  do
  {
    *(v0 - 1) = 0;
    *(_BYTE *)v0 = 0;
    v0 += 2;
  }
  while ( (signed int)v0 < (signed int)&dword_101EFA4C );
  do
  {
    v2 = dword_10056DD0[result];
    dword_101EF5E0[2 * v2] = *(int *)((char *)&off_10056DD4 + result * 4);
    dword_101EF5E4[2 * v2] = dword_10056DD8[result];
    v3 = dword_10056DDC[result];
    dword_101EF5E0[2 * v3] = *(int *)((char *)&off_10056DE0 + result * 4);
    dword_101EF5E4[2 * v3] = dword_10056DE4[result];
    v4 = dword_10056DE8[result];
    dword_101EF5E0[2 * v4] = *(int *)((char *)&off_10056DEC + result * 4);
    dword_101EF5E4[2 * v4] = dword_10056DF0[result];
    v5 = dword_10056DF4[result];
    dword_101EF5E0[2 * v5] = *(int *)((char *)&off_10056DF8 + result * 4);
    v6 = dword_10056DFC[result];
    result += 12;
    dword_101EF5E4[2 * v5] = v6;
  }
  while ( result < 48 );
  return result * 4;
}
// 10056DD0: using guessed type int dword_10056DD0[];
// 10056DD4: using guessed type int (__cdecl *off_10056DD4)(int, int, int, int, int);
// 10056DD8: using guessed type int dword_10056DD8[];
// 10056DDC: using guessed type int dword_10056DDC[];
// 10056DE0: using guessed type int (__cdecl *off_10056DE0)(int, int, int, int, int);
// 10056DE4: using guessed type int dword_10056DE4[];
// 10056DE8: using guessed type int dword_10056DE8[];
// 10056DEC: using guessed type int (__cdecl *off_10056DEC)(int, int, int, int, int);
// 10056DF0: using guessed type int dword_10056DF0[];
// 10056DF4: using guessed type int dword_10056DF4[];
// 10056DF8: using guessed type int (__cdecl *off_10056DF8)(int, int, int, int, int);
// 10056DFC: using guessed type int dword_10056DFC[];
// 101EF5E0: using guessed type int dword_101EF5E0[];
// 101EF5E4: using guessed type int dword_101EF5E4[];
// 101EFA4C: using guessed type int dword_101EFA4C;

//----- (10001590) --------------------------------------------------------
int __cdecl sub_10001590(int a1, int a2)
{
  int result; // eax@1

  for ( result = *(_DWORD *)(a1 + 48); result; result = *(_DWORD *)(result + 4) )
  {
    if ( *(_DWORD *)(result + 8) == a2 )
      break;
  }
  return result;
}

//----- (100015B0) --------------------------------------------------------
int __cdecl sub_100015B0(int a1)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 3) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_BYTE *)(a1 + 5) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 10) = 0;
  *(_BYTE *)(a1 + 7) = 1;
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}

//----- (100015E0) --------------------------------------------------------
int __cdecl sub_100015E0(int a1, int a2)
{
  byte_101EF5C0 = 0;
  sub_1000E350(&unk_100F07C0);
  return nullsub_1(a1, a2);
}
// 101EF5C0: using guessed type char byte_101EF5C0;

//----- (10001600) --------------------------------------------------------
int __cdecl sub_10001600(int a1, char *a2, int a3, int a4)
{
  if ( !a2 )
    sub_1000D740(".\\cdp_main.c", 890, 1, 0);
  if ( a3 > 0 )
    *((_DWORD *)a2 + 3) = sub_10002820(a1, a3);
  *((_DWORD *)a2 + 14) = sub_10002820(a1, 4 * a4 + 4);
  a2[68] = a4;
  a2[231] = 0;
  if ( a4 > 0 )
  {
    *((_DWORD *)a2 + 15) = sub_10002820(a1, 4 * a4);
    *((_DWORD *)a2 + 16) = sub_10002820(a1, a4);
  }
  return *((_DWORD *)a2 + 3);
}

//----- (10001690) --------------------------------------------------------
char __cdecl sub_10001690(int a1, int a2, int a3)
{
  int v3; // ST08_4@1
  int v4; // eax@1
  int v6; // [sp+0h] [bp-14h]@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v9 = 0;
  v10 = 0;
  v8 = 0;
  v6 = a2;
  v7 = a3;
  v3 = *(_DWORD *)(a1 + 64);
  v10 = 1;
  v9 = 1000;
  v4 = sub_10031A40(v3, (int)&v6);
  if ( v4 )
    LOBYTE(v4) = sub_1000D740(".\\cdp_main.c", 1068, 0, 0);
  return v4;
}

//----- (10001700) --------------------------------------------------------
char __cdecl sub_10001700(int a1, int a2, int a3)
{
  int v3; // ST08_4@1
  int v4; // eax@1
  int v6; // [sp+0h] [bp-14h]@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v9 = 0;
  v10 = 0;
  v8 = 0;
  v6 = a2;
  v7 = a3;
  v3 = *(_DWORD *)(a1 + 64);
  v10 = 2;
  v9 = 1000;
  v4 = sub_10031A40(v3, (int)&v6);
  if ( v4 )
    LOBYTE(v4) = sub_1000D740(".\\cdp_main.c", 1136, 0, 0);
  return v4;
}

//----- (10001770) --------------------------------------------------------
int sub_10001770()
{
  int result; // eax@1

  result = sub_10031910();
  dword_100F07C8 = result;
  byte_100F07C4 = 0;
  return result;
}
// 100F07C4: using guessed type char byte_100F07C4;
// 100F07C8: using guessed type int dword_100F07C8;

//----- (10001790) --------------------------------------------------------
_DWORD *__cdecl sub_10001790(int a1)
{
  return sub_1000E390(&unk_100F07C0, a1);
}

//----- (100017B0) --------------------------------------------------------
unsigned int __cdecl sub_100017B0(int a1, int a2, int a3)
{
  unsigned int result; // eax@1

  result = (a3 * (1000 / *(_WORD *)(a1 + 20)) + 500) / 1000;
  if ( result >= 1 )
  {
    if ( result >= 0xFF )
      result = 255;
    *(_BYTE *)(a2 + 243) = result;
    *(_BYTE *)(a2 + 244) = result;
  }
  else
  {
    result = 1;
    *(_BYTE *)(a2 + 243) = 1;
    *(_BYTE *)(a2 + 244) = 1;
  }
  return result;
}

//----- (10001820) --------------------------------------------------------
void __usercall sub_10001820(int a1@<esi>)
{
  if ( *(_BYTE *)(a1 + 11) )
  {
    sub_100316C0();
    sub_10031820();
    sub_10031870(1);
    *(_DWORD *)(a1 + 28) = sub_100317E0(*(_WORD *)(a1 + 16), *(_WORD *)(a1 + 14), 57);
    sub_10031820();
    *(_DWORD *)(a1 + 24) = sub_100317E0(*(_WORD *)(a1 + 16), *(_WORD *)(a1 + 14), 59);
  }
}

//----- (10001870) --------------------------------------------------------
char __usercall sub_10001870@<al>(int a1@<esi>)
{
  _WORD *v1; // eax@1
  int v2; // edi@1
  void *v3; // ecx@1
  int v4; // eax@1
  int v5; // eax@9
  char result; // al@13
  char v7; // [sp+8h] [bp-8h]@1
  int v8; // [sp+Ch] [bp-4h]@1

  v1 = *(_WORD **)(a1 + 52);
  v8 = 2;
  byte_101BD3BE = *v1 == -32749;
  byte_101EF5C0 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  v2 = *(_DWORD *)(a1 + 56);
  sub_10031C50(9129, &v7, 2, &v8);
  v4 = *(_DWORD *)(a1 + 64);
  if ( (v4 == 1 || v4 == 9) && sub_1000EF10(v3) != 2 && v7 & 0x1C )
  {
    byte_101BD3BE = 0;
    byte_101EF5C0 = 0;
  }
  if ( *(_DWORD *)(a1 + 64) == 1 && sub_1000EB90() )
  {
    byte_101BD3BE = 0;
    byte_101EF5C0 = 0;
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 238) = 1;
  }
  v5 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 56) = v5;
  if ( v5 && *(_BYTE *)(v5 + 230) != -1 && !*(_BYTE *)(v5 + 238) )
  {
    sub_1000E520(a1, (char *)v5, (int)&unk_1006F534);
    *(_BYTE *)(a1 + 1) = 1;
  }
  *(_DWORD *)(a1 + 56) = v2;
  result = sub_10003CF0(a1);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 101BD3BE: using guessed type char byte_101BD3BE;
// 101EF5C0: using guessed type char byte_101EF5C0;

//----- (10001950) --------------------------------------------------------
void __usercall sub_10001950(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  __int64 v3; // rax@8

  v2 = *(_DWORD *)(a1 + 52);
  if ( v2 != -1 )
  {
    if ( *(_BYTE *)(a1 + 24) & 3 )
    {
      if ( (*(_BYTE *)(a1 + 24) & 3) == 2 )
        sub_100315C0(v2, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), 0, 0, *(_WORD *)(a1 + 32), *(_WORD *)(a1 + 34));
    }
    else if ( *(_DWORD *)(a1 + 48) && *(_BYTE *)(a1 + 26) && !sub_10001000(a1) )
    {
      j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 52));
      v3 = *(_WORD *)(a1 + 32) + 255;
      sub_10031640(0, 0, (BYTE4(v3) + (signed int)v3) >> 8 << 8, *(_WORD *)(a1 + 34), 57, 15, *(_DWORD *)(a1 + 48));
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 24));
      sub_100315C0(
        *(_DWORD *)(a1 + 52),
        *(_WORD *)(a1 + 28),
        *(_WORD *)(a1 + 30),
        0,
        0,
        *(_WORD *)(a1 + 32),
        *(_WORD *)(a1 + 34));
    }
  }
}
// 10031700: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);

//----- (10001A20) --------------------------------------------------------
void __usercall sub_10001A20(int a1@<esi>, int a2)
{
  __int16 v2; // ST1C_2@5
  __int16 v3; // ST14_2@5
  __int16 v4; // ST10_2@5
  int v5; // [sp+0h] [bp-Ch]@5
  __int16 v6; // [sp+4h] [bp-8h]@5
  __int16 v7; // [sp+6h] [bp-6h]@5
  char v8; // [sp+8h] [bp-4h]@5
  char v9; // [sp+9h] [bp-3h]@5
  __int16 v10; // [sp+Ah] [bp-2h]@5

  if ( !(*(_BYTE *)(a1 + 24) & 3) && *(_DWORD *)(a1 + 48) && *(_BYTE *)(a1 + 26) && !sub_10001000(a1) )
  {
    v2 = *(_WORD *)(a1 + 34);
    v7 = *(_WORD *)(a1 + 32);
    v3 = *(_WORD *)(a1 + 30);
    v4 = *(_WORD *)(a1 + 28);
    v10 = (unsigned __int16)((v7 + 255) / 256) << 8;
    v5 = *(_DWORD *)(a1 + 48);
    v6 = v2;
    v8 = 8;
    v9 = 0;
    sub_10033E10(a2 + 392, (int)&v5, 0, 0, v4, v3, v7, v2);
  }
}

//----- (10001AC0) --------------------------------------------------------
int __usercall sub_10001AC0@<eax>(int a1@<edi>, int a2)
{
  int v2; // esi@1
  __int64 v3; // rax@8
  int result; // eax@11

  v2 = *(_DWORD *)(a1 + 48);
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 444) = a2;
  *(_WORD *)(a1 + 418) = 0;
  *(_WORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 420) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 434) = 0;
  for ( *(_WORD *)(a1 + 432) = 0; v2; v2 = *(_DWORD *)(v2 + 4) )
  {
    if ( !*(_DWORD *)(v2 + 4) )
      break;
    if ( sub_100010B0(a1, v2) )
      break;
  }
  if ( *(_DWORD *)(a1 + 24) != -1 )
  {
    j_gdi_pvg_make_window_active(*(_DWORD *)(a1 + 24));
    j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 24));
    if ( v2 )
    {
      if ( (*(_BYTE *)(v2 + 24) & 3) == 1 )
      {
        j_gdi_pvg_make_window_current(*(_DWORD *)(v2 + 52));
        v3 = *(_WORD *)(a1 + 16) + 255;
        sub_10031640(0, 0, (BYTE4(v3) + (signed int)v3) >> 8 << 8, *(_WORD *)(v2 + 34), 57, 15, *(_DWORD *)(v2 + 48));
        j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 24));
        sub_100315C0(
          *(_DWORD *)(v2 + 52),
          *(_WORD *)(v2 + 28),
          *(_WORD *)(v2 + 30),
          *(_WORD *)(v2 + 28),
          *(_WORD *)(v2 + 30),
          *(_WORD *)(v2 + 32),
          *(_WORD *)(v2 + 34));
      }
      nullsub_1(a1, 1);
      do
      {
        sub_10001950(v2, a1);
        v2 = *(_DWORD *)v2;
      }
      while ( v2 );
    }
    result = nullsub_1(a1, 0);
    goto LABEL_21;
  }
  if ( *(_BYTE *)(a1 + 11) )
  {
    j_gdi_pvg_make_window_active(*(_DWORD *)(a1 + 28));
    j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 28));
  }
  if ( v2 && *(_BYTE *)(v2 + 26) )
    nullsub_1(a1, 1);
  *(_DWORD *)(a1 + 444) = a2;
  *(_WORD *)(a1 + 418) = 0;
  *(_WORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 420) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 434) = 0;
  for ( *(_WORD *)(a1 + 432) = 0; v2; v2 = *(_DWORD *)v2 )
    sub_10001A20(v2, a1);
  result = nullsub_1(a1, 0);
  if ( *(_BYTE *)(a1 + 11) )
  {
    result = sub_10031640(
               0,
               0,
               *(_WORD *)(*(_DWORD *)(a1 + 444) + 10),
               *(_WORD *)(*(_DWORD *)(a1 + 444) + 4),
               57,
               15,
               **(_DWORD **)(a1 + 444));
LABEL_21:
    if ( *(_BYTE *)(a1 + 11) )
      result = j_gdi_pvg_update_display_wdw();
  }
  *(_BYTE *)(a1 + 392) = 0;
  return result;
}
// 100316F0: using guessed type int __cdecl j_gdi_pvg_make_window_active(_DWORD);
// 10031700: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 100317A0: using guessed type int j_gdi_pvg_update_display_wdw(void);

//----- (10001C90) --------------------------------------------------------
char __thiscall sub_10001C90(int this)
{
  char result; // al@1

  result = 0;
  if ( !*(_BYTE *)(*(_DWORD *)(this + 56) + 26) && **(_WORD **)(this + 52) == -32696 )
  {
    result = 1;
    *(_BYTE *)(this + 6) = 2;
  }
  return result;
}

//----- (10001CB0) --------------------------------------------------------
signed int __cdecl sub_10001CB0(int a1, int a2)
{
  const void *v2; // edx@1
  int v3; // ebx@1
  char v4; // al@4
  char v6; // al@13
  char v7; // al@14
  int v8; // [sp-Ch] [bp-FCh]@15
  __int16 *v9; // [sp-8h] [bp-F8h]@15
  int v10; // [sp+Ch] [bp-E4h]@1
  __int16 v11; // [sp+18h] [bp-D8h]@7
  int v12; // [sp+1Ch] [bp-D4h]@12

  v2 = (const void *)a2;
  v3 = *(_DWORD *)(a2 + 4);
  v10 = 0;
  if ( !v3 )
  {
    if ( *(_WORD *)a2 > 0x8001u && *(_WORD *)a2 < 0x800Du )
    {
      v3 = *(_DWORD *)(a1 + 48);
      v4 = 1;
      goto LABEL_7;
    }
    v3 = 0;
  }
  v4 = 0;
LABEL_7:
  qmemcpy(&v11, (const void *)a2, 0xCCu);
  if ( !v4 )
  {
    sub_10001690(a1, (int)&v11, 204);
    return 1;
  }
  if ( v3 )
  {
    while ( 1 )
    {
      qmemcpy(&v11, v2, 0xCCu);
      v12 = v3;
      if ( v11 != -32760 )
        break;
      v6 = *(_BYTE *)(v3 + 243);
      if ( v6 )
      {
        v7 = v6 - 1;
        *(_BYTE *)(v3 + 243) = v7;
        if ( !v7 )
        {
          v11 = -32648;
          v9 = &v11;
          *(_BYTE *)(v3 + 243) = *(_BYTE *)(v3 + 244);
          v8 = a1;
LABEL_17:
          sub_10001690(v8, (int)v9, 204);
          ++v10;
          goto LABEL_18;
        }
      }
LABEL_18:
      if ( sub_100010B0(a1, v3) )
        return v10;
      v3 = *(_DWORD *)(v3 + 4);
      if ( !v3 )
        return v10;
      v2 = (const void *)a2;
    }
    v9 = &v11;
    v8 = a1;
    goto LABEL_17;
  }
  return v10;
}

//----- (10001E00) --------------------------------------------------------
char __cdecl sub_10001E00(int a1, int a2, __int16 a3)
{
  __int16 v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = a2;
  v4 = a3;
  return sub_10001690(a1, (int)&v4, 8);
}

//----- (10001E30) --------------------------------------------------------
char __cdecl sub_10001E30(int a1, int a2, __int16 a3)
{
  __int16 v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = a2;
  v4 = a3;
  return sub_10001700(a1, (int)&v4, 8);
}

//----- (10001E60) --------------------------------------------------------
char __cdecl sub_10001E60(unsigned int a1)
{
  int v1; // eax@1
  int v2; // ecx@2
  __int16 v3; // dx@2
  unsigned int v4; // ebx@3
  _DWORD *v5; // eax@3
  char v6; // dl@3
  __int16 v7; // ax@10
  unsigned __int16 v8; // cx@14
  int v9; // eax@31
  int v10; // eax@31
  int v11; // eax@41
  __int16 v12; // ax@48
  char v13; // al@52
  _WORD *v14; // edx@55
  int v15; // ebp@58
  int v17; // [sp+0h] [bp-10h]@0

  v1 = *(_DWORD *)(a1 + 52);
  if ( *(_WORD *)v1 < 0x8000u )
  {
    v2 = *(_DWORD *)(v1 + 4);
    v3 = *(_WORD *)(v1 + 8);
    *(_WORD *)v1 = -32670;
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4) = *(_DWORD *)(a1 + 48);
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 12) = v2;
    *(_WORD *)(*(_DWORD *)(a1 + 52) + 8) = v3;
  }
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4);
  sub_1000E360((int *)&unk_100F07C0, a1);
  v5 = *(_DWORD **)(a1 + 32);
  v6 = 0;
  if ( v5 )
  {
    while ( *(_DWORD **)(*(_DWORD *)(a1 + 52) + 4) != v5 )
    {
      v5 = (_DWORD *)*v5;
      if ( !v5 )
        goto LABEL_8;
    }
    v6 = 1;
  }
LABEL_8:
  if ( v4 )
  {
    if ( !v6 )
    {
      v7 = **(_WORD **)(a1 + 52);
      if ( v7 != -32703 )
      {
        if ( v7 == -32744 )
          return v7;
        v4 = 0;
        *(_DWORD *)(a1 + 56) = 0;
      }
    }
  }
  LOBYTE(v7) = sub_10003CC0();
  if ( !(_BYTE)v7 )
  {
    v8 = **(_WORD **)(a1 + 52);
    switch ( **(_WORD **)(a1 + 52) )
    {
      case 0x8013:
      case 0x8014:
        sub_10001870(a1);
        goto LABEL_40;
      case 0x8018:
        if ( *(_DWORD *)(a1 + 24) != -1 && (!(*(_BYTE *)(v4 + 24) & 3) || (*(_BYTE *)(v4 + 24) & 3) == 2) )
          j_gdi_pvg_destroy_window(*(_DWORD *)(v4 + 52));
        if ( v4 != *(_DWORD *)(a1 + 32) && *(_DWORD *)(v4 + 4) )
        {
          *(_DWORD *)(a1 + 48) = *(_DWORD *)(v4 + 4);
          **(_DWORD **)(v4 + 4) = 0;
        }
        else
        {
          sub_100015B0(a1);
        }
        goto LABEL_40;
      case 0x8022:
      case 0x8078:
        if ( *(_BYTE *)(a1 + 4) || v4 && sub_10001000(v4) )
          v4 = 0;
        if ( *(_DWORD *)(a1 + 64) == 1 && sub_1000EB90() != byte_100F07C4 )
        {
          **(_WORD **)(a1 + 52) = -32734;
          byte_100F07C4 = sub_1000EB90();
        }
        goto LABEL_40;
      case 0x8041:
        v9 = sub_10002820(a1, 332);
        v4 = v9;
        qmemcpy((void *)v9, &unk_10057468, 0x14Cu);
        *(_DWORD *)(v9 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 8);
        v10 = *(_DWORD *)(a1 + 48);
        if ( v10 )
        {
          *(_DWORD *)(v4 + 4) = v10;
          **(_DWORD **)(a1 + 48) = v4;
          *(_BYTE *)(v4 + 243) = *(_BYTE *)(*(_DWORD *)(v4 + 4) + 243);
        }
        if ( !*(_DWORD *)(a1 + 32) )
          *(_DWORD *)(a1 + 32) = v4;
        --*(_BYTE *)(a1 + 4);
        *(_DWORD *)(a1 + 48) = v4;
        goto LABEL_40;
      default:
        if ( !v4 )
        {
          if ( v8 <= 0x800Eu || v8 >= 0xFFFFu )
            goto LABEL_67;
          v4 = *(_DWORD *)(a1 + 48);
LABEL_40:
          if ( !v4 )
            goto LABEL_67;
        }
        v11 = *(_DWORD *)(a1 + 52);
        *(_DWORD *)(a1 + 56) = v4;
        *(_BYTE *)(a1 + 6) = 1;
        *(_DWORD *)(v11 + 4) = v4;
        if ( **(_WORD **)(a1 + 52) == -32665 )
          *(_BYTE *)(*(_DWORD *)(a1 + 56) + 237) = 0;
        sub_10003B60(a1);
        if ( *(_BYTE *)(a1 + 6) == 1 && !sub_10001C90(a1) )
          (*(void (__cdecl **)(unsigned int))(v4 + 8))(a1);
        if ( !v4 || v4 > *(_DWORD *)(a1 + 48) && (v12 = **(_WORD **)(a1 + 52), v12 != -32703) && v12 != -32744 )
        {
LABEL_67:
          v4 = 0;
          *(_DWORD *)(a1 + 56) = 0;
        }
        LOBYTE(v7) = nullsub_1(a1, v17);
        if ( v4 )
        {
          v13 = *(_BYTE *)(a1 + 6);
          if ( v13 == 1 || v13 == 3 )
            sub_10003B20(a1);
          v14 = *(_WORD **)(a1 + 52);
          if ( *v14 == 32792 )
          {
            LOBYTE(v7) = sub_10002480(0, v4);
            if ( !*(_DWORD *)(a1 + 32) )
              *(_DWORD *)(a1 + 56) = 0;
            *(_BYTE *)(a1 + 1) = 1;
          }
          else if ( *v14 == 32871 )
          {
            LOBYTE(v7) = sub_10001E00(a1, *(_DWORD *)(a1 + 56), -32734);
          }
          else
          {
            v7 = *v14 + 32648;
            if ( *v14 == 32888 )
            {
              v15 = *(_DWORD *)(a1 + 56);
              if ( v15 )
                *(_BYTE *)(v15 + 26) = 1;
            }
          }
        }
        break;
    }
  }
  return v7;
}
// 10031810: using guessed type int __cdecl j_gdi_pvg_destroy_window(_DWORD);
// 100F07C4: using guessed type char byte_100F07C4;

//----- (10002190) --------------------------------------------------------
int __usercall sub_10002190@<eax>(unsigned int a1@<eax>)
{
  unsigned int v1; // edi@1
  int result; // eax@1
  __int16 v3; // ax@2
  bool v4; // al@4
  char v5; // [sp+4h] [bp-4h]@1

  v1 = a1;
  for ( result = sub_100318C0(*(_DWORD *)(a1 + 52), (int)&v5);
        result != 1;
        result = sub_100318C0(*(_DWORD *)(v1 + 52), (int)&v5) )
  {
    v3 = **(_WORD **)(v1 + 52);
    v4 = v3 == -32696 || v3 == -32734;
    *(_BYTE *)(v1 + 10) = v4;
    sub_10001E60(v1);
    if ( *(_BYTE *)(v1 + 6) != 1 && *(_BYTE *)(v1 + 10) && (*(_BYTE *)(v1 + 392) || *(_BYTE *)(v1 + 1)) )
    {
      sub_10001AC0(v1, (int)&off_1005A76C);
      *(_BYTE *)(v1 + 10) = 0;
    }
  }
  return result;
}
// 1005A76C: using guessed type void *off_1005A76C;

//----- (10002220) --------------------------------------------------------
void __usercall __noreturn sub_10002220(char *a1@<edi>)
{
  void *v1; // ecx@8
  unsigned int v2; // esi@16
  int v3; // eax@19
  int v4; // [sp+10h] [bp-ECh]@1
  char v5; // [sp+14h] [bp-E8h]@9
  char v6; // [sp+18h] [bp-E4h]@5

  dword_101EF5BC = (int)&dword_101BD3C0;
  sub_10031B20(&v4);
  if ( !(v4 & 0x10) )
    sub_1000D740(".\\cdp_main.c", 403, 1, 0);
  v4 |= 0x10u;
  if ( !sub_10031AB0(1, 20000) )
    sub_1000D740(".\\cdp_main.c", 428, 1, 0);
  sub_1000F460();
  sub_1000F030(&v6);
  sub_10031E10();
  while ( 1 )
  {
    byte_101EF568 = 0;
    if ( v4 & 0x10 || v4 & 0x8000 )
    {
      sub_100015B0((int)&byte_101EF3E0);
      byte_101EF3E2 = sub_1000EB10(v1);
      byte_101EF3E4 = 0;
      dword_101EF414 = (int)&unk_100F07D0;
      word_101EF3EE = 56;
      word_101EF3F0 = 264;
      dword_101EF420 = 2;
      word_101EF3F4 = 250;
      dword_101EF3F8 = -1;
      dword_101EF3FC = -1;
      byte_101EF3EB = 1;
      dword_101EF428 = 0;
      byte_101EF3E0 = 0;
      while ( sub_100318C0(dword_101EF414, (int)&v5) != 1 )
        ;
      sub_100014D0();
      sub_10002800((int)&byte_101EF3E0);
      sub_10003CD0((int)a1, (unsigned int)&byte_101EF3E0);
      sub_1000F450((int)&unk_10057440);
      sub_1000F440((int)&unk_10057448);
      sub_10001820((int)&byte_101EF3E0);
      sub_10003D70((unsigned int)&byte_101EF3E0);
    }
    if ( v4 & 2 )
      sub_10002190((unsigned int)&byte_101EF3E0);
    if ( v4 & 1 )
    {
      v4 |= 0x20000000u;
      if ( (unsigned int)(sub_10031910() - dword_100F07C8) >= 0x3E8 )
      {
        dword_100F07C8 += 1000;
        j_nullsub_1(&byte_101EF3E0);
        sub_1000EF20((int *)&v6);
      }
    }
    v2 = 0x40000000;
    do
    {
      if ( v2 != 0x8000 && v2 & v4 )
      {
        v3 = sub_1000E5D0(v2);
        sub_10001CB0((int)&byte_101EF3E0, v3);
        sub_10002190((unsigned int)&byte_101EF3E0);
      }
      v2 >>= 1;
    }
    while ( v2 >= 0x200 );
    if ( byte_101EF568 || byte_101EF3E1 )
    {
      a1 = &byte_101EF3E0;
      sub_10001AC0((int)&byte_101EF3E0, (int)&off_1005A76C);
    }
    sub_10031B20(&v4);
  }
}
// 100014D0: using guessed type int sub_100014D0(void);
// 1000F430: using guessed type int __cdecl j_nullsub_1(_DWORD);
// 1000F460: using guessed type int sub_1000F460(void);
// 1005A76C: using guessed type void *off_1005A76C;
// 100F07C8: using guessed type int dword_100F07C8;
// 101BD3C0: using guessed type int dword_101BD3C0;
// 101EF3E0: using guessed type char byte_101EF3E0;
// 101EF3E1: using guessed type char byte_101EF3E1;
// 101EF3E2: using guessed type char byte_101EF3E2;
// 101EF3E4: using guessed type char byte_101EF3E4;
// 101EF3EB: using guessed type char byte_101EF3EB;
// 101EF3EE: using guessed type __int16 word_101EF3EE;
// 101EF3F0: using guessed type __int16 word_101EF3F0;
// 101EF3F4: using guessed type __int16 word_101EF3F4;
// 101EF3F8: using guessed type int dword_101EF3F8;
// 101EF3FC: using guessed type int dword_101EF3FC;
// 101EF414: using guessed type int dword_101EF414;
// 101EF420: using guessed type int dword_101EF420;
// 101EF428: using guessed type int dword_101EF428;
// 101EF568: using guessed type char byte_101EF568;
// 101EF5BC: using guessed type int dword_101EF5BC;

//----- (10002460) --------------------------------------------------------
int __cdecl sub_10002460(int a1, int a2)
{
  return a2 * ((a1 + 255) / 256) << 8;
}

//----- (10002480) --------------------------------------------------------
char __cdecl sub_10002480(int a1, unsigned int a2)
{
  char result; // al@4

  if ( !a2 || a2 < (unsigned int)&unk_101BD3C4 || a2 >= dword_101BD3C0 )
    result = sub_1000D740(".\\cdp_mem.c", 222, 1, 0);
  dword_101BD3C0 = a2;
  return result;
}
// 101BD3C0: using guessed type int dword_101BD3C0;

//----- (100024C0) --------------------------------------------------------
char sub_100024C0()
{
  char result; // al@1

  byte_100F08A0 = 0;
  result = sub_100322F0((int)"/mnt/card0/enable_heap_mntr.txt");
  if ( result )
    byte_100F08A0 = 1;
  return result;
}
// 100F08A0: using guessed type char byte_100F08A0;

//----- (100024E0) --------------------------------------------------------
char __thiscall sub_100024E0(int this)
{
  unsigned int v1; // eax@1
  unsigned int v2; // esi@2
  int v3; // ecx@5
  int v4; // eax@5
  char *v5; // edi@6
  char v7[4]; // [sp+4h] [bp-ACh]@1
  int v8; // [sp+8h] [bp-A8h]@1
  int v9; // [sp+Ch] [bp-A4h]@1
  int v10; // [sp+10h] [bp-A0h]@1
  int v11; // [sp+14h] [bp-9Ch]@1
  char v12; // [sp+18h] [bp-98h]@1
  char v13; // [sp+2Ch] [bp-84h]@1

  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  sub_10031930((int)&v12, 1, *(_DWORD *)(this + 64), 20);
  sub_1000F650(&v13, 0x80u, "/mnt/card0/%s_heap_stats.txt", &v12);
  LOBYTE(v1) = sub_100322F0((int)&v13);
  if ( (_BYTE)v1 )
  {
    v1 = j_FIL_vfs_open(&v13, 4, 0);
    v2 = v1;
    if ( v1 < 0xFFFFFFC2
      && v1
      && (sub_10032160(v1, &byte_100F08A8, 4096),
          sub_10032090(v2),
          (v1 = (unsigned int)strstr(&byte_100F08A8, "usage:")) != 0) )
    {
      v3 = v1 - (_DWORD)&byte_100F08A8;
      v4 = v1 - (_DWORD)&byte_100F08A8 + 7;
      if ( v4 < v3 + 27 )
      {
        v5 = &v7[-v4];
        do
        {
          if ( !((word_10071EC8[2 * (unsigned __int8)*(&byte_100F08A8 + v4)] >> 4) & 1) )
            break;
          v5[v4] = *(&byte_100F08A8 + v4);
          ++v4;
        }
        while ( v4 < v3 + 27 );
      }
      v1 = j__atol(v7);
      dword_100F18A8 = v1;
    }
    else
    {
      dword_100F18A8 = 0;
    }
  }
  else
  {
    dword_100F18A8 = 0;
  }
  return v1;
}
// 10032150: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 100F18A8: using guessed type int dword_100F18A8;

//----- (10002650) --------------------------------------------------------
void *__usercall sub_10002650@<eax>(unsigned int a1@<ecx>, int a2@<ebx>)
{
  int v2; // edi@1
  unsigned int v3; // esi@1
  void *result; // eax@1
  int v5; // ecx@3
  unsigned int v6; // ebp@3
  _DWORD *i; // esi@5
  int v8; // esi@9
  int v9; // [sp+8h] [bp-198h]@1
  char v10; // [sp+Ch] [bp-194h]@3
  char v11; // [sp+20h] [bp-180h]@1
  char v12; // [sp+54h] [bp-14Ch]@4
  char v13; // [sp+11Ch] [bp-84h]@3

  v2 = 0;
  v3 = a1;
  result = memset(&v11, 0, 0x32u);
  v9 = 0;
  if ( a2 && dword_100F18A8 < v3 )
  {
    v5 = *(_DWORD *)(a2 + 64);
    dword_100F18A8 = v3;
    sub_10031930((int)&v10, 1, v5, 20);
    sub_1000F650(&v13, 0x80u, "/mnt/card0/%s_heap_stats.txt", &v10);
    v6 = j_FIL_vfs_open(&v13, 10, 0);
    sub_1000F530((int)&byte_100F08A8, "HEAP STATISTICS:\r\n", 4096);
    if ( v3 > 0x32000 )
    {
      sub_1000F530((int)&v12, "\r\n!!!HEAP LIMIT EXCEEDED!!!\r\n", 200);
      sub_1000F680(&byte_100F08A8, &v12, 4096);
    }
    sub_1000F650(&v12, 0xC8u, "%s maximum heap usage: %d bytes out of %d bytes\r\n", &v10, v3, 204800);
    result = (void *)sub_1000F680(&byte_100F08A8, &v12, 4096);
    for ( i = *(_DWORD **)(a2 + 32); i; ++v2 )
    {
      sub_10002960((int)i, (__int16 *)&v9, &v11);
      sub_1000F650(&v12, 0xC8u, "  Page[%d]: %s\r\n", v2, &v11);
      result = (void *)sub_1000F680(&byte_100F08A8, &v12, 4096);
      i = (_DWORD *)*i;
    }
    if ( v6 < 0xFFFFFFC2 )
    {
      if ( v6 )
      {
        v8 = sub_1000F580(&byte_100F08A8, 0x1000u);
        j_FIL_vfs_write(v6, &byte_100F08A8, v8);
        sub_100322A0(v6, v8, 0);
        result = (void *)sub_10032090(v6);
      }
    }
  }
  return result;
}
// 10032150: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 100322C0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 100F18A8: using guessed type int dword_100F18A8;

//----- (10002800) --------------------------------------------------------
char __cdecl sub_10002800(int a1)
{
  char result; // al@2

  dword_101BD3C0 = (int)&unk_101BD3C4;
  if ( byte_100F08A0 )
    result = sub_100024E0(a1);
  return result;
}
// 100F08A0: using guessed type char byte_100F08A0;
// 101BD3C0: using guessed type int dword_101BD3C0;

//----- (10002820) --------------------------------------------------------
int __cdecl sub_10002820(int a1, int a2)
{
  unsigned int v2; // esi@1
  int result; // eax@4

  v2 = (unsigned int)(a2 + 3) >> 2;
  if ( byte_100F08A0 )
    sub_10002650(dword_101BD3C0 + 4 * v2 - *(_DWORD *)(a1 + 476), a1);
  if ( !a2 || (result = dword_101BD3C0, dword_101BD3C0 + 4 * v2 > *(_DWORD *)(a1 + 476) + 204804) )
  {
    sub_1000D740(".\\cdp_mem.c", 371, 1, 0);
    result = dword_101BD3C0;
  }
  dword_101BD3C0 = result + 4 * v2;
  return result;
}
// 100F08A0: using guessed type char byte_100F08A0;
// 101BD3C0: using guessed type int dword_101BD3C0;

//----- (100028A0) --------------------------------------------------------
int __cdecl sub_100028A0(int a1, __int16 a2, __int16 a3)
{
  int v3; // eax@1

  v3 = sub_10002460(a2, a3);
  return sub_10002820(a1, v3);
}

//----- (100028E0) --------------------------------------------------------
__int16 __cdecl sub_100028E0(unsigned __int8 a1)
{
  return *(_WORD *)(dword_101BD3B8 + 4 * (unsigned __int8)byte_100F18B0[a1] + 2);
}
// 101BD3B8: using guessed type int dword_101BD3B8;

//----- (10002900) --------------------------------------------------------
char __cdecl sub_10002900(int (__cdecl *a1)(int))
{
  signed int v1; // esi@1

  v1 = sub_1000F6E0(a1);
  if ( v1 == -1 )
    sub_1000D740(".\\cdp_page_list.c", 705, 1, 0);
  return byte_1005B22C[56 * v1];
}

//----- (10002940) --------------------------------------------------------
char __cdecl sub_10002940(int (__cdecl *a1)(int))
{
  return *(_BYTE *)(dword_101BD3B8 + 4 * (unsigned __int8)byte_100F18B0[(unsigned __int8)sub_10002900(a1)] + 1);
}
// 101BD3B8: using guessed type int dword_101BD3B8;

//----- (10002960) --------------------------------------------------------
char __cdecl sub_10002960(int a1, __int16 *a2, _BYTE *a3)
{
  int v3; // esi@1
  _BYTE *v4; // ecx@1
  _BYTE *v5; // edx@1
  char *v6; // eax@2
  char v7; // cl@3

  v3 = 56 * sub_1000F6E0(*(int (__cdecl **)(int))(a1 + 8));
  *a2 = sub_100028E0(byte_1005B22C[v3]);
  v4 = *(_BYTE **)(a1 + 252);
  v5 = a3;
  if ( v4 )
  {
    do
    {
      LOBYTE(v6) = *v4;
      *v5++ = *v4++;
    }
    while ( (_BYTE)v6 );
  }
  else
  {
    v6 = (char *)&unk_1005B22D + v3;
    do
    {
      v7 = *v6;
      v6[a3 - ((char *)&unk_1005B22D + v3)] = *v6;
      ++v6;
    }
    while ( v7 );
  }
  return (unsigned int)v6;
}

//----- (100029E0) --------------------------------------------------------
char __usercall sub_100029E0@<al>(int a1@<ecx>, int a2@<edi>, unsigned int a3)
{
  signed int v3; // eax@1
  signed int v4; // esi@3
  char *v5; // edi@3
  int v6; // eax@4
  signed int v7; // eax@8
  char *v8; // esi@8
  int v9; // ecx@9
  signed int v10; // edi@13
  int (__cdecl **v11)(int); // ebp@13
  int v13; // [sp-Eh] [bp-10h]@3
  int v14; // [sp-2h] [bp-4h]@1

  v14 = a1;
  dword_101BD3B8 = (int)byte_1005B21C;
  dword_100F18B8 = 0;
  BYTE3(v14) = 0;
  byte_100F18B2 = 1;
  v3 = 0;
  do
  {
    byte_100F18B0[(unsigned __int8)byte_1005B21C[4 * v3]] = v3;
    ++v3;
  }
  while ( v3 <= 1 );
  v4 = 0;
  v13 = a2;
  v5 = byte_1005B22C;
  memset(&unk_100F18C8, 1, 2u);
  do
  {
    LOBYTE(v6) = *v5;
    if ( (unsigned __int8)*v5 < 1u )
    {
      v6 = (unsigned __int8)v6;
      if ( !*((_BYTE *)&v14 + (unsigned __int8)v6 + 3) )
      {
        word_100F18B4[v6] = v4;
        *((_BYTE *)&v14 + (unsigned __int8)v6 + 3) = 1;
      }
    }
    ++v4;
    v5 += 56;
  }
  while ( v4 < 2 );
  dword_100F18BC = (int)*(&off_1005B228 + 14 * (unsigned __int16)word_100F18B4[0]);
  v7 = 1;
  BYTE3(v14) = 0;
  v8 = &byte_1005B22C[56];
  do
  {
    LOBYTE(v9) = *v8;
    if ( (unsigned __int8)*v8 < 1u )
    {
      v9 = (unsigned __int8)v9;
      if ( !*((_BYTE *)&v14 + (unsigned __int8)v9 + 3) )
      {
        word_100F18C0[v9] = v7;
        *((_BYTE *)&v14 + (unsigned __int8)v9 + 3) = 1;
      }
    }
    --v7;
    v8 -= 56;
  }
  while ( v7 >= 0 );
  sub_10003D60();
  sub_10002B40(a3);
  sub_10003B60(a3);
  v10 = 0;
  v11 = &off_1005B228;
  do
  {
    (*v11)(a3);
    ++v10;
    v11 += 14;
  }
  while ( v10 < 2 );
  nullsub_1(a3, v13);
  sub_10003B20(a3);
  return sub_10002480(0, *(_DWORD *)(a3 + 56));
}
// 100029E0: could not find valid save-restore pair for edi
// 1005B228: using guessed type int (__cdecl *off_1005B228)(int);
// 100F18B2: using guessed type char byte_100F18B2;
// 100F18B4: using guessed type __int16 word_100F18B4[];
// 100F18B8: using guessed type int dword_100F18B8;
// 100F18BC: using guessed type int dword_100F18BC;
// 100F18C0: using guessed type __int16 word_100F18C0[];
// 101BD3B8: using guessed type int dword_101BD3B8;

//----- (10002B40) --------------------------------------------------------
_WORD *__cdecl sub_10002B40(int a1)
{
  void *v1; // eax@1

  v1 = (void *)sub_10002820(a1, 332);
  *(_DWORD *)(a1 + 56) = v1;
  qmemcpy(v1, &unk_10057468, 0x14Cu);
  sub_10001600(a1, *(char **)(a1 + 56), 0, 0);
  **(_WORD **)(a1 + 52) = -32671;
  sub_10034A10(a1 + 392, (int)&off_1005A76C, 0);
  *(_WORD *)(a1 + 428) = 0;
  *(_WORD *)(a1 + 430) = 0;
  return sub_100349B0(a1 + 392);
}
// 1005A76C: using guessed type void *off_1005A76C;

//----- (10002BB0) --------------------------------------------------------
int __usercall sub_10002BB0@<eax>(int a1@<esi>)
{
  int result; // eax@1

  result = sub_1000F910(
             a1,
             *(_WORD **)(a1 + 52),
             (char *)&unk_10058E50,
             *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 8,
             *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12),
             255);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10002BE0) --------------------------------------------------------
char __usercall sub_10002BE0@<al>(int a1@<edi>)
{
  int v1; // esi@1
  int v2; // ebp@1
  double v3; // st7@1
  char result; // al@1

  v1 = sub_10001600(a1, *(char **)(a1 + 56), 820, 0);
  sub_100011B0(a1, 0, 0, 264, 56, 3);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  sub_100017B0(a1, *(_DWORD *)(a1 + 56), 1000);
  v2 = v1 + 28;
  *(_DWORD *)v2 = 0;
  *(_BYTE *)(v2 + 4) = 0;
  sub_100085B0(v1 + 48, (int)&unk_100586B0, dword_101F03E0 + 6700, 65.0, 20.0, 60.0, 25.0);
  *(float *)(v1 + 328) = *(float *)(v1 + 328) + 67.0;
  v3 = *(float *)(v1 + 76);
  *(_WORD *)(v1 + 564) = 30;
  *(_DWORD *)(v1 + 92) = -16711681;
  *(_BYTE *)(v1 + 488) = 1;
  *(_BYTE *)(v1 + 512) = 1;
  *(float *)(v1 + 76) = v3 + 5.0;
  sub_1000F530(v1 + 344, &unk_100586AC, 21);
  *(float *)(v1 + 36) = 3.7854118;
  *(float *)(v1 + 40) = 9.8999998e24;
  *(float *)(v1 + 44) = 9.8999998e24;
  *(_BYTE *)(v1 + 223) = 2;
  sub_100082B0(v1 + 36, 1, v1 + 48);
  *(float *)(v1 + 672) = 15.0;
  *(_DWORD *)(v1 + 692) = 0x7FFFFFFF;
  *(_WORD *)(v1 + 660) = 4143;
  *(_DWORD *)(v1 + 668) = 0;
  *(_DWORD *)(v1 + 664) = -16711681;
  *(_DWORD *)(v1 + 680) = sub_1000F740(15.0);
  *(float *)(v1 + 684) = 0.0;
  *(_BYTE *)(v1 + 744) = 1;
  *(float *)(v1 + 688) = 1.0;
  *(_DWORD *)(v1 + 764) = 0;
  *(_WORD *)(v1 + 704) = 43;
  *(_DWORD *)(v1 + 740) = 0;
  *(float *)(v1 + 676) = 0.0;
  *(_DWORD *)(v1 + 716) = 0;
  *(_DWORD *)(v1 + 712) = -16711681;
  *(float *)(v1 + 696) = 210.0;
  *(float *)(v1 + 700) = 20.0;
  *(float *)(v1 + 708) = 9.8999998e24;
  *(float *)(v1 + 720) = 15.0;
  *(_DWORD *)(v1 + 728) = sub_1000F740(15.0);
  *(float *)(v1 + 724) = 0.0;
  *(_DWORD *)(v1 + 776) = 26;
  *(float *)(v1 + 732) = 0.0;
  *(_DWORD *)(v1 + 780) = -16711681;
  *(_DWORD *)(v1 + 784) = 4;
  *(float *)(v1 + 736) = 1.0;
  *(float *)(v1 + 788) = 15.0;
  *(float *)(v1 + 792) = 0.0;
  *(float *)(v1 + 796) = 1.0;
  *(_BYTE *)(v1 + 768) = sub_10033190();
  *(float *)(v1 + 772) = 6.2831855;
  *(_DWORD *)(v1 + 816) = v1 + 768;
  *(_WORD *)(v1 + 806) = 0;
  *(_WORD *)(v1 + 808) = 0;
  *(_DWORD *)(v1 + 812) = v1 + 776;
  *(_BYTE *)(v1 + 804) = 0;
  *(_DWORD *)(v1 + 16) = v1 + 660;
  *(_DWORD *)(v1 + 24) = v1 + 804;
  *(_BYTE *)(v1 + 805) = 0;
  *(_DWORD *)(v1 + 8) = v1 + 28;
  *(_DWORD *)(v1 + 12) = v1 + 48;
  *(_DWORD *)(v1 + 20) = v1 + 704;
  *(_DWORD *)v1 = 50529027;
  *(_BYTE *)(v1 + 4) = 3;
  result = sub_10001E30(a1, *(_DWORD *)(a1 + 56), -32734);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 101F03E0: using guessed type int dword_101F03E0;

//----- (10002E90) --------------------------------------------------------
char __usercall sub_10002E90@<al>(int a1@<esi>)
{
  int v1; // edi@1
  char result; // al@4
  char v3; // [sp+6h] [bp-6h]@1
  char v4; // [sp+7h] [bp-5h]@1
  int v5; // [sp+8h] [bp-4h]@4

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 8);
  v3 = 0;
  if ( sub_10031C50(9117, &v4, 1, &v3) )
    sub_1000D740(".\\cdp_pg_alt_com_bar.c", 643, 0, 0);
  if ( v4 )
  {
    result = sub_100122E0(1, &v5);
    if ( result && v1 != v5 && v1 != 0xFFFF )
      result = sub_10012070(1, 0, v1);
  }
  else
  {
    result = sub_100122E0(0, &v5);
    if ( result && v1 != v5 && v1 != 0xFFFF )
    {
      result = sub_10012070(0, 0, v1);
      *(_BYTE *)(a1 + 6) = 2;
      return result;
    }
  }
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10002F50) --------------------------------------------------------
int __usercall sub_10002F50@<eax>(int a1@<eax>, char a2)
{
  int result; // eax@1

  result = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( a2 == 1 )
  {
    *(_DWORD *)(result + 664) = -256;
    *(_DWORD *)(result + 712) = -256;
    *(_DWORD *)(result + 780) = -256;
    *(_BYTE *)(result + 488) = 2;
    *(_BYTE *)(result + 512) = 2;
  }
  else
  {
    *(_DWORD *)(result + 664) = -16711681;
    *(_DWORD *)(result + 712) = -16711681;
    *(_DWORD *)(result + 780) = -16711681;
    *(_BYTE *)(result + 488) = 1;
    *(_BYTE *)(result + 512) = 1;
  }
  return result;
}

//----- (10002FB0) --------------------------------------------------------
int __usercall sub_10002FB0@<eax>(int a1@<edi>)
{
  int v1; // esi@1
  char v2; // al@3
  int v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@1
  float v7; // [sp+10h] [bp-10h]@1
  char v8; // [sp+14h] [bp-Ch]@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_1000A3F0((int)&v4);
  sub_1000F530(v1 + 28, &v8, 5);
  *(float *)(v1 + 772) = v6;
  *(_BYTE *)(v1 + 768) = sub_10033190();
  *(_DWORD *)(v1 + 692) = v4;
  *(float *)(v1 + 708) = v5;
  *(float *)(v1 + 40) = v7;
  if ( 9.8999998e24 == v7 )
    *(float *)(v1 + 40) = 760.8678;
  sub_1000A390(v1 + 36, 1u);
  v2 = sub_10033270();
  return sub_10002F50(a1, v2);
}

//----- (100030B0) --------------------------------------------------------
char __cdecl sub_100030B0(int a1)
{
  int v1; // edi@5
  int v2; // esi@5
  int v3; // eax@1

  v3 = **(_WORD **)(a1 + 52);
  switch ( v3 )
  {
    case 32789:
    case 32790:
      LOBYTE(v3) = sub_10002BB0(a1);
      break;
    default:
      return v3;
    case 32833:
      LOBYTE(v3) = sub_10002BE0(a1);
      break;
    case 32875:
      LOBYTE(v3) = sub_10002E90(a1);
      break;
    case 32802:
    case 32888:
      v1 = a1;
      v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
      sub_10002FB0(a1);
      sub_1000F910(v1, *(_WORD **)(v1 + 52), (char *)&unk_10058C68, (int)&unk_10058EA4, 0, 255);
      LOBYTE(v3) = sub_1000F910(v1, *(_WORD **)(v1 + 52), (char *)&unk_10058E50, v2 + 8, v2, 255);
      *(_BYTE *)(a1 + 6) = 2;
      break;
  }
  return v3;
}

//----- (10003170) --------------------------------------------------------
char __usercall sub_10003170@<al>(int a1@<edi>)
{
  int v1; // eax@1
  int v2; // esi@1
  void *v3; // ecx@1
  char v5; // [sp+Bh] [bp-5h]@1
  int v6; // [sp+Ch] [bp-4h]@7

  v1 = *(_DWORD *)(a1 + 56);
  v5 = 0;
  v2 = *(_DWORD *)(v1 + 12);
  if ( sub_10012660(&v5) != 1 )
  {
    if ( sub_1000A830((int)&v6) != 1 )
      return sub_10001E30(a1, *(_DWORD *)(a1 + 56), -32648);
    if ( (_BYTE)v6 == 1 )
      goto LABEL_11;
    if ( BYTE1(v6) != 1 )
    {
      if ( BYTE2(v6) == 1 )
      {
LABEL_11:
        *(_BYTE *)(v2 + 22) = 1;
        *(_BYTE *)(v2 + 42) = 0;
LABEL_14:
        sub_1000A6D0(*(_BYTE *)(v2 + 42));
        return sub_10001E30(a1, *(_DWORD *)(a1 + 56), -32648);
      }
      if ( BYTE3(v6) != 1 )
        goto LABEL_14;
    }
    *(_BYTE *)(v2 + 42) = 1;
    *(_BYTE *)(v2 + 22) = 0;
    goto LABEL_14;
  }
  switch ( v5 )
  {
    case 2:
      goto LABEL_3;
    case 4:
      if ( sub_1000EF10(v3) )
        goto LABEL_5;
LABEL_3:
      *(_BYTE *)(v2 + 22) = 0;
      *(_BYTE *)(v2 + 42) = 1;
      sub_1000A6D0(1);
      return sub_10001E30(a1, *(_DWORD *)(a1 + 56), -32648);
    case 1:
    case 6:
LABEL_5:
      *(_BYTE *)(v2 + 42) = 0;
      *(_BYTE *)(v2 + 22) = 1;
      break;
    default:
      break;
  }
  sub_1000A6D0(*(_BYTE *)(v2 + 42));
  return sub_10001E30(a1, *(_DWORD *)(a1 + 56), -32648);
}

//----- (10003250) --------------------------------------------------------
char __usercall sub_10003250@<al>(int a1@<esi>)
{
  _WORD *v1; // eax@1
  int v2; // edx@1
  char result; // al@1
  void *v4; // ecx@1
  char v5; // [sp+0h] [bp-8h]@1
  int v6; // [sp+4h] [bp-4h]@1

  v1 = *(_WORD **)(a1 + 52);
  v2 = *(_DWORD *)(a1 + 56);
  v6 = 0;
  **(_BYTE **)(v2 + 12) = *v1 == -32747;
  result = sub_10031C50(9129, &v5, 2, &v6);
  if ( v5 & 4 )
  {
    result = sub_1000EF10(v4);
    if ( result != 2 )
      result = sub_10001E30(a1, *(_DWORD *)(a1 + 56), -32648);
  }
  return result;
}

//----- (100032B0) --------------------------------------------------------
char __usercall sub_100032B0@<al>(int a1@<edi>)
{
  int v1; // eax@1
  int v2; // esi@1
  void *v3; // ecx@1
  unsigned int v4; // eax@2
  int v6; // [sp+8h] [bp-8h]@1
  int v7; // [sp+Ch] [bp-4h]@1

  v1 = *(_DWORD *)(a1 + 56);
  v7 = 0;
  v2 = *(_DWORD *)(v1 + 12);
  v6 = 0;
  *(_WORD *)(v2 + 72) = 6543;
  *(_WORD *)(v2 + 70) = 59;
  *(_WORD *)(v2 + 68) = 268;
  *(_WORD *)(v2 + 76) = -1;
  *(_WORD *)(v2 + 78) = -2;
  sub_10031C50(9129, &v6, 2, &v7);
  if ( v6 & 4 && (LOBYTE(v4) = sub_1000EF10(v3), (_BYTE)v4 != 2) )
  {
    if ( !*(_BYTE *)(v2 + 8) )
    {
      v4 = sub_10031910();
      *(_DWORD *)(v2 + 4) = v4;
      *(_BYTE *)(v2 + 8) = 1;
    }
    if ( *(_BYTE *)v2 || (v4 = sub_10031910() - *(_DWORD *)(v2 + 4), v4 >= 0x1388) )
    {
      *(_WORD *)(v2 + 76) = 0;
      *(_WORD *)(v2 + 78) = 0;
      *(_WORD *)(v2 + 72) = 10630;
      *(_WORD *)(v2 + 70) = 56;
      *(_WORD *)(v2 + 68) = 264;
    }
  }
  else
  {
    *(_BYTE *)(v2 + 8) = 0;
    v4 = *(_DWORD *)(a1 + 56);
    if ( *(_WORD *)(v4 + 240) != -128 )
      *(_WORD *)(v4 + 240) = -128;
  }
  return v4;
}

//----- (10003380) --------------------------------------------------------
char __usercall sub_10003380@<al>(int a1@<esi>)
{
  char result; // al@1

  sub_10009010(
    a1,
    *(_WORD **)(a1 + 52),
    (char *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 52),
    (int)&unk_10059514,
    0,
    255);
  result = sub_10001E30(a1, *(_DWORD *)(a1 + 56), -32648);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (100033C0) --------------------------------------------------------
void __usercall sub_100033C0(int a1@<esi>)
{
  int v1; // edx@1
  int v2; // edi@1
  int v3; // eax@2
  void *v4; // ecx@2
  char v5; // al@6
  void *v6; // ecx@6
  int v7; // edx@8
  char v8; // al@8
  bool v9; // zf@11
  char v10; // al@15

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 12);
  if ( *(_BYTE *)(a1 + 6) == 1 )
  {
    v3 = *(_DWORD *)(a1 + 52);
    v4 = (void *)*(_WORD *)(v3 + 10);
    if ( (signed int)v4 <= 0x2000 )
    {
      if ( v4 == (void *)0x2000 )
      {
LABEL_21:
        if ( *(_BYTE *)(v2 + 22) )
        {
          *(_BYTE *)(a1 + 6) = sub_1000E4B0(a1, v3, (char *)&unk_100594C0, v2 + 12);
          *(_BYTE *)(a1 + 6) = 2;
        }
        else
        {
          *(_BYTE *)(a1 + 6) = sub_1000E4B0(a1, v3, (char *)&unk_100594D8, v2 + 32);
LABEL_24:
          *(_BYTE *)(a1 + 6) = 2;
        }
      }
      else
      {
        switch ( v4 )
        {
          case 0x25u:
            if ( *(_BYTE *)(v2 + 22) )
              v5 = sub_1000E4B0(a1, v3, (char *)&unk_100594C0, v2 + 12);
            else
              v5 = sub_1000E4B0(a1, v3, (char *)&unk_100594D8, v2 + 32);
            v7 = *(_DWORD *)(a1 + 52);
            *(_BYTE *)(a1 + 6) = v5;
            v8 = *(_BYTE *)(v7 + 16);
            if ( (v8 == 1 || v8 == 4) && sub_1000E880(v6) != 1 )
              goto LABEL_24;
            v9 = *(_BYTE *)(v2 + 42) == 0;
            *(_BYTE *)(v2 + 22) = *(_BYTE *)(v2 + 22) == 0;
            *(_BYTE *)(v2 + 42) = v9;
            sub_1000A6D0(v9);
            *(_BYTE *)(a1 + 6) = 2;
            break;
          case 0x38u:
          case 0x39u:
            if ( *(_BYTE *)(v3 + 16) != 1 )
              goto LABEL_24;
            if ( !*(_BYTE *)(v2 + 8) )
              goto LABEL_24;
            if ( *(_BYTE *)(v2 + 84) != 1 )
              goto LABEL_24;
            v10 = sub_1000EF10(v4);
            if ( !sub_100127D0(v10, 6) )
              goto LABEL_24;
            *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) += 10;
            if ( *(_BYTE *)(v2 + 22) )
            {
              *(_BYTE *)(a1 + 6) = sub_1000E4B0(a1, *(_DWORD *)(a1 + 52), (char *)&unk_100594C0, v2 + 12);
              *(_BYTE *)(a1 + 6) = 2;
            }
            else
            {
              *(_BYTE *)(a1 + 6) = sub_1000E4B0(a1, *(_DWORD *)(a1 + 52), (char *)&unk_100594D8, v2 + 32);
              *(_BYTE *)(a1 + 6) = 2;
            }
            break;
          case 0x2Bu:
            if ( *(_WORD *)(v1 + 240) != -128 )
              *(_WORD *)(v1 + 240) = -128;
            break;
          case 2u:
          case 0x20u:
          case 0x21u:
          case 0x2Au:
          case 0x3Au:
          case 0x42u:
          case 0x43u:
          case 0x49u:
          case 0x52u:
            goto LABEL_21;
          default:
            return;
        }
      }
    }
  }
}

//----- (100035B0) --------------------------------------------------------
char __usercall sub_100035B0@<al>(int a1@<esi>)
{
  int v1; // ecx@1
  int v2; // eax@1
  int v3; // ST08_4@4
  int v4; // ST08_4@7

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 8);
  if ( *(_BYTE *)(v1 + 22) )
  {
    if ( v2 != *(_DWORD *)(v1 + 12) && v2 != 0xFFFF )
    {
      v3 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 8);
      *(_DWORD *)(v1 + 16) = v2;
      sub_10012070(0, 0, v3);
    }
  }
  else if ( v2 != *(_DWORD *)(v1 + 32) && v2 != 0xFFFF )
  {
    v4 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 8);
    *(_DWORD *)(v1 + 36) = v2;
    sub_10012070(1, 0, v4);
  }
  return sub_10001E30(a1, *(_DWORD *)(a1 + 56), -32648);
}

//----- (10003610) --------------------------------------------------------
char __usercall sub_10003610@<al>(int a1@<edi>)
{
  int v1; // esi@1
  int v2; // eax@2
  char result; // al@4
  int v4; // eax@5

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( *(_BYTE *)(v1 + 22) )
  {
    v2 = *(_DWORD *)(v1 + 12);
    if ( v2 != 121500 )
      *(_DWORD *)(v1 + 16) = v2;
    *(_DWORD *)(v1 + 12) = 121500;
    sub_10012070(0, 1, 121500);
    sub_10012070(0, 0, *(_DWORD *)(v1 + 16));
    *(_DWORD *)(v1 + 24) = sub_10031910();
    result = sub_10001E30(a1, *(_DWORD *)(a1 + 56), -32648);
  }
  else
  {
    v4 = *(_DWORD *)(v1 + 32);
    if ( v4 != 121500 )
      *(_DWORD *)(v1 + 36) = v4;
    *(_DWORD *)(v1 + 32) = 121500;
    sub_10012070(1, 1, 121500);
    sub_10012070(1, 0, *(_DWORD *)(v1 + 36));
    *(_DWORD *)(v1 + 44) = sub_10031910();
    result = sub_10001E30(a1, *(_DWORD *)(a1 + 56), -32648);
  }
  return result;
}

//----- (100036C0) --------------------------------------------------------
int __cdecl sub_100036C0(int a1)
{
  int v1; // esi@1
  char v2; // bl@1
  int v3; // eax@1
  int v4; // ecx@1
  unsigned int v5; // ecx@4
  int v6; // edi@19
  int v7; // ebp@19
  int v8; // eax@19
  int v9; // ecx@19
  char v10; // dl@20
  void *v11; // ecx@25
  int result; // eax@28
  char v13; // [sp+0h] [bp-2h]@1
  char v14; // [sp+1h] [bp-1h]@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = 0;
  v13 = 0;
  v14 = *(_BYTE *)(v1 + 42);
  v3 = sub_10031910();
  v4 = *(_DWORD *)(v1 + 24);
  if ( v4 && (unsigned int)(v3 - v4) > 0x3E8 )
    *(_DWORD *)(v1 + 24) = 0;
  v5 = *(_DWORD *)(v1 + 44);
  if ( v5 > 0 && v3 - v5 > 0x3E8 )
    *(_DWORD *)(v1 + 44) = 0;
  if ( *(_DWORD *)(v1 + 24) )
    v2 = 1;
  else
    *(_BYTE *)(v1 + 23) = sub_100122E0(0, (_DWORD *)(v1 + 12));
  if ( *(_DWORD *)(v1 + 44) )
    v13 = 1;
  else
    *(_BYTE *)(v1 + 43) = sub_100122E0(1, (_DWORD *)(v1 + 32));
  if ( *(_BYTE *)(v1 + 23) != 1 || v2 == 1 )
    *(_DWORD *)(v1 + 12) = sub_10011EB0(0, 1);
  if ( *(_BYTE *)(v1 + 43) != 1 || v13 == 1 )
    *(_DWORD *)(v1 + 32) = sub_10011EB0(1, 1);
  v6 = *(_DWORD *)(v1 + 16);
  v7 = *(_DWORD *)(v1 + 36);
  *(_DWORD *)(v1 + 16) = sub_10011EB0(0, 0);
  v8 = sub_10011EB0(1, 0);
  *(_DWORD *)(v1 + 36) = v8;
  v9 = *(_DWORD *)(a1 + 56);
  if ( *(_WORD *)(v9 + 240) != -128 )
  {
    v10 = *(_BYTE *)(v1 + 22);
    if ( v10 )
    {
      if ( v6 != *(_DWORD *)(v1 + 16) )
      {
LABEL_24:
        *(_WORD *)(v9 + 240) = -128;
        goto LABEL_25;
      }
      if ( v10 )
        goto LABEL_25;
    }
    if ( v7 == v8 )
      goto LABEL_25;
    goto LABEL_24;
  }
LABEL_25:
  sub_10012460(0, 1);
  sub_10012460(1, 1);
  if ( sub_1000A680(v11) )
  {
    *(_BYTE *)(v1 + 22) = 0;
    *(_BYTE *)(v1 + 42) = 1;
  }
  else
  {
    *(_BYTE *)(v1 + 22) = 1;
    *(_BYTE *)(v1 + 42) = 0;
  }
  result = *(_DWORD *)(a1 + 56);
  if ( *(_WORD *)(result + 240) != -128 && v14 != *(_BYTE *)(v1 + 42) )
    *(_WORD *)(result + 240) = -128;
  return result;
}

//----- (10003820) --------------------------------------------------------
char __cdecl sub_10003820(int a1)
{
  int v1; // ebp@1
  int v2; // eax@1
  int v3; // edx@1
  int v4; // ebx@1
  char result; // al@1
  int v6; // [sp+14h] [bp+4h]@1

  v1 = a1;
  v2 = sub_10001600(a1, *(char **)(a1 + 56), 88, 2);
  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60);
  v4 = v2;
  qmemcpy((void *)(v2 + 52), &unk_100594F4, 0x20u);
  v6 = v3;
  sub_100011B0(v1, 0, 0, 264, 56, 1);
  sub_1000E450(*(_DWORD *)(v1 + 56), (char *)&unk_100594C0);
  *(_BYTE *)v4 = 0;
  *(_DWORD *)(v4 + 4) = 0;
  *(_BYTE *)(v4 + 8) = 0;
  *(_BYTE *)(*(_DWORD *)(v1 + 56) + 230) = 0;
  sub_10032360(93, (_BYTE *)(v4 + 84));
  *(_BYTE *)(v4 + 21) = 1;
  *(_BYTE *)(v4 + 22) = 1;
  *(_DWORD *)(v4 + 24) = 0;
  *(_BYTE *)(v4 + 41) = 0;
  *(_BYTE *)(v4 + 42) = 0;
  *(_DWORD *)(v4 + 44) = 0;
  sub_100036C0(v1);
  *(_DWORD *)v6 = v4 + 12;
  *(_DWORD *)(v6 + 4) = v4 + 32;
  sub_10003170(v1);
  sub_10008EF0(
    v1,
    *(_WORD **)(v1 + 52),
    *(char ***)(*(_DWORD *)(v1 + 56) + 56),
    *(_DWORD *)(*(_DWORD *)(v1 + 56) + 60),
    0,
    *(_BYTE *)(*(_DWORD *)(v1 + 56) + 230));
  sub_100017B0(v1, *(_DWORD *)(v1 + 56), 250);
  result = sub_10001E30(v1, *(_DWORD *)(v1 + 56), -32734);
  *(_BYTE *)(v1 + 6) = 2;
  return result;
}

//----- (10003970) --------------------------------------------------------
void __cdecl sub_10003970(int a1)
{
  int v1; // edi@8
  int v2; // esi@8

  switch ( **(_WORD **)(a1 + 52) )
  {
    case 0x8015:
    case 0x8016:
      sub_10003250(a1);
      break;
    case 0x8022:
      sub_10003380(a1);
      break;
    case 0x8041:
      sub_10003820(a1);
      break;
    case 0x8048:
      sub_100033C0(a1);
      break;
    case 0x806B:
      sub_100035B0(a1);
      break;
    case 0x8077:
      sub_10003610(a1);
      break;
    case 0x8078:
      v1 = a1;
      v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
      sub_100036C0(a1);
      sub_100032B0(a1);
      sub_10009010(v1, *(_WORD **)(v1 + 52), (char *)(v2 + 52), (int)&unk_10059514, 0, 255);
      sub_10009010(
        v1,
        *(_WORD **)(v1 + 52),
        (char *)&unk_100594C0,
        *(_DWORD *)(*(_DWORD *)(v1 + 56) + 60),
        0,
        *(_BYTE *)(*(_DWORD *)(v1 + 56) + 230));
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 0x8002:
      sub_10003170(a1);
      break;
    case 0x8003:
    case 0x8004:
    case 0x8005:
    case 0x8006:
    case 0x8007:
    case 0x8008:
    case 0x8009:
    case 0x800A:
    case 0x800B:
    case 0x800C:
    case 0x800D:
    case 0x800E:
    case 0x800F:
    case 0x8010:
    case 0x8011:
    case 0x8012:
    case 0x8013:
    case 0x8014:
    case 0x8017:
    case 0x8018:
    case 0x8019:
    case 0x801A:
    case 0x801B:
    case 0x801C:
    case 0x801D:
    case 0x801E:
    case 0x801F:
    case 0x8020:
    case 0x8021:
    case 0x8023:
    case 0x8024:
    case 0x8025:
    case 0x8026:
    case 0x8027:
    case 0x8028:
    case 0x8029:
    case 0x802A:
    case 0x802B:
    case 0x802C:
    case 0x802D:
    case 0x802E:
    case 0x802F:
    case 0x8030:
    case 0x8031:
    case 0x8032:
    case 0x8033:
    case 0x8034:
    case 0x8035:
    case 0x8036:
    case 0x8037:
    case 0x8038:
    case 0x8039:
    case 0x803A:
    case 0x803B:
    case 0x803C:
    case 0x803D:
    case 0x803E:
    case 0x803F:
    case 0x8040:
    case 0x8042:
    case 0x8043:
    case 0x8044:
    case 0x8045:
    case 0x8046:
    case 0x8047:
    case 0x8049:
    case 0x804A:
    case 0x804B:
    case 0x804C:
    case 0x804D:
    case 0x804E:
    case 0x804F:
    case 0x8050:
    case 0x8051:
    case 0x8052:
    case 0x8053:
    case 0x8054:
    case 0x8055:
    case 0x8056:
    case 0x8057:
    case 0x8058:
    case 0x8059:
    case 0x805A:
    case 0x805B:
    case 0x805C:
    case 0x805D:
    case 0x805E:
    case 0x805F:
    case 0x8060:
    case 0x8061:
    case 0x8062:
    case 0x8063:
    case 0x8064:
    case 0x8065:
    case 0x8066:
    case 0x8067:
    case 0x8068:
    case 0x8069:
    case 0x806A:
    case 0x806C:
    case 0x806D:
    case 0x806E:
    case 0x806F:
    case 0x8070:
    case 0x8071:
    case 0x8072:
    case 0x8073:
    case 0x8074:
    case 0x8075:
    case 0x8076:
      return;
  }
}

//----- (10003A80) --------------------------------------------------------
char __cdecl sub_10003A80(int a1)
{
  __int16 v2; // [sp+4h] [bp-D0h]@1
  int v3; // [sp+8h] [bp-CCh]@1

  v3 = sub_10001590(a1, (int)sub_10003970);
  v2 = -32649;
  return sub_10001700(a1, (int)&v2, 204);
}

//----- (10003AF0) --------------------------------------------------------
char __cdecl sub_10003AF0(char a1)
{
  return sub_10034B50(a1, -122);
}

//----- (10003B10) --------------------------------------------------------
char sub_10003B10()
{
  sub_10034B00();
  return sub_10003AF0(0);
}

//----- (10003B20) --------------------------------------------------------
char __cdecl sub_10003B20(int a1)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 + 52);
  if ( *(_WORD *)v1 == -32696 )
  {
    LOWORD(v1) = *(_WORD *)(v1 + 10);
    if ( (_WORD)v1 == 43 )
    {
      LOBYTE(v1) = sub_10003A80(a1);
    }
    else if ( v1 & 0xC000 )
    {
      *(_BYTE *)(a1 + 6) = 2;
    }
    if ( *(_BYTE *)(a1 + 6) == 1 )
      *(_BYTE *)(a1 + 6) = 0;
  }
  return v1;
}

//----- (10003B60) --------------------------------------------------------
void __cdecl sub_10003B60(unsigned int a1)
{
  __int16 v1; // di@1
  void *v2; // ecx@1
  char v3; // bl@1
  int v4; // eax@1
  void *v5; // ecx@5
  int v6; // ecx@10
  void (__cdecl *v7)(int); // eax@10
  signed int v8; // eax@16
  int v9; // edi@25
  int v10; // eax@25

  v1 = j_HWM_pvg_read_reg(0);
  v3 = sub_1000EB70(v2);
  v4 = *(_DWORD *)(a1 + 52);
  if ( *(_WORD *)v4 != 32840 )
  {
    if ( *(_WORD *)v4 == 32888 )
    {
      if ( *(char (__cdecl **)(int))(*(_DWORD *)(a1 + 48) + 8) != sub_100030B0
        && v3 != 1
        && sub_1000EA20()
        && (v1 == 132 || v1 == 20)
        && sub_100128C0(v5) == 4 )
      {
        sub_1000A370(a1, -1, (int (__cdecl *)(int))sub_100030B0, 0);
      }
      else
      {
        v6 = *(_DWORD *)(a1 + 48);
        v7 = *(void (__cdecl **)(int))(v6 + 8);
        if ( v7 != sub_10003970 && (v3 == 1 || v7 != sub_10003970 && v3 == 2 && sub_100128C0((void *)v6) == 1) )
          sub_1000A370(a1, -1, (int (__cdecl *)(int))sub_10003970, 0);
      }
    }
    return;
  }
  v8 = *(_WORD *)(v4 + 10);
  if ( v8 > 58 )
  {
    if ( v8 > 82 )
    {
      if ( v8 != 0x2000 )
        return;
    }
    else if ( v8 != 82 && (v8 < 66 || v8 > 67) )
    {
      return;
    }
    goto LABEL_25;
  }
  if ( v8 == 58 )
  {
LABEL_25:
    v9 = *(_DWORD *)(a1 + 56);
    v10 = sub_10001590(a1, (int)sub_10003970);
    *(_DWORD *)(a1 + 56) = v10;
    if ( v10 )
      sub_10003970(a1);
    *(_DWORD *)(a1 + 56) = v9;
    return;
  }
  switch ( v8 )
  {
    case 2:
    case 32:
    case 33:
    case 37:
    case 42:
      goto LABEL_25;
    default:
      return;
  }
}
// 100323E0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10003CC0) --------------------------------------------------------
char sub_10003CC0()
{
  return 0;
}

//----- (10003CD0) --------------------------------------------------------
char __usercall sub_10003CD0@<al>(int a1@<edi>, unsigned int a2)
{
  int v2; // ecx@1
  char result; // al@1

  sub_10002B40(a2);
  result = sub_100029E0(v2, a1, a2);
  dword_101EFA48 = 0;
  return result;
}
// 101EFA48: using guessed type int dword_101EFA48;

//----- (10003CF0) --------------------------------------------------------
char __cdecl sub_10003CF0(int a1)
{
  int v1; // eax@1
  bool v2; // zf@1
  __int16 v4; // [sp+4h] [bp-D0h]@1
  int v5; // [sp+8h] [bp-CCh]@1

  v1 = sub_10001590(a1, (int)sub_10003970);
  v2 = **(_WORD **)(a1 + 52) == -32749;
  v5 = v1;
  v4 = !v2 - 32747;
  return sub_10001700(a1, (int)&v4, 204);
}

//----- (10003D60) --------------------------------------------------------
char sub_10003D60()
{
  char result; // al@1

  result = 0;
  byte_101BD3BC = 0;
  byte_101BD3BD = 0;
  return result;
}
// 101BD3BC: using guessed type char byte_101BD3BC;
// 101BD3BD: using guessed type char byte_101BD3BD;

//----- (10003D70) --------------------------------------------------------
void __cdecl sub_10003D70(unsigned int a1)
{
  __int16 v1; // si@1
  void *v2; // ecx@1
  void *v3; // ecx@2
  bool v4; // zf@5
  int (__cdecl *v5)(int); // eax@5

  v1 = j_HWM_pvg_read_reg(0);
  if ( sub_1000EB70(v2) == 1
    || !sub_1000EA20()
    || v1 != 132 && v1 != 20
    || (v4 = sub_100128C0(v3) == 4, v5 = (int (__cdecl *)(int))sub_100030B0, !v4) )
  {
    v5 = (int (__cdecl *)(int))sub_10003970;
  }
  sub_1000A370(a1, -1, v5, 0);
}
// 100323E0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10003DE0) --------------------------------------------------------
#error "10003DF9: call analysis failed (funcsize=31)"

//----- (10003E60) --------------------------------------------------------
char __cdecl sub_10003E60(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5)
{
  char result; // al@1
  char *v6; // edi@4
  signed int v7; // eax@4
  unsigned int v8; // ST1C_4@4
  int v9; // eax@4
  unsigned int v10; // ST18_4@4
  char *v11; // eax@4
  __int16 v12; // dx@4
  int v13; // ST10_4@4
  signed int v14; // eax@4
  __int16 v15; // dx@4
  int v16; // edx@4
  int v17; // eax@6
  int v18; // edi@7
  int v19; // ebx@7
  char *v20; // eax@7
  int v21; // [sp+8h] [bp-18h]@4
  int v22; // [sp+Ch] [bp-14h]@4
  int v23; // [sp+10h] [bp-10h]@4
  __int16 v24; // [sp+14h] [bp-Ch]@4
  int v25; // [sp+16h] [bp-Ah]@4
  int v26; // [sp+1Ch] [bp-4h]@4

  result = 1;
  if ( *a5 == 32802 )
  {
LABEL_4:
    v6 = sub_10013F90(*a4);
    v7 = sub_10009160(*(_DWORD *)(a2 + 4));
    v8 = *(_DWORD *)(a2 + 4);
    v22 = v7;
    v9 = sub_100099A0(v8, 0);
    v10 = *(_DWORD *)(a2 + 4);
    v23 = v9;
    v25 = sub_10009110(v10);
    v11 = sub_10009140(*(_DWORD *)(a2 + 4));
    v12 = *(_WORD *)(a2 + 8);
    v13 = *(_DWORD *)(a2 + 4);
    v21 = *(_DWORD *)v11;
    v24 = v12;
    v14 = sub_10009190(v13);
    v15 = *(_WORD *)a3;
    v26 = v14;
    *(_WORD *)(a1 + 438) = v15;
    v16 = v21;
    *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
    sub_10009A00(a1, v6, &v21, *(_WORD *)(v16 + 30));
    return 2;
  }
  if ( *a5 != 32832 )
  {
    if ( *a5 != 32888 )
      return result;
    goto LABEL_4;
  }
  LOWORD(v17) = *(_WORD *)(a2 + 8);
  if ( (_WORD)v17 )
  {
    v17 = (signed __int16)v17;
  }
  else
  {
    v18 = sub_10009160(*(_DWORD *)(a2 + 4));
    v19 = *(_DWORD *)sub_10009140(*(_DWORD *)(a2 + 4));
    v20 = sub_10013F90(*a4);
    v17 = sub_10034B10(v19, v20, v18);
  }
  sub_10009C10(a1 + 276, *(_DWORD *)a3, *(_DWORD *)(a2 + 4), v17);
  return 2;
}

//----- (10003F90) --------------------------------------------------------
char __cdecl sub_10003F90(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@1
  __int16 v6; // cx@4
  unsigned int v7; // eax@4
  __int16 v8; // cx@4
  int v9; // eax@4
  int v10; // ecx@8
  __int16 v11; // bp@8
  __int16 *v12; // ebx@9
  char v13; // dl@10
  __int16 v14; // ax@14
  __int16 v15; // cx@16
  int v16; // [sp+4h] [bp-14h]@9
  __int16 v17; // [sp+8h] [bp-10h]@4
  __int16 v18; // [sp+Ch] [bp-Ch]@4
  __int16 v19; // [sp+Eh] [bp-Ah]@4
  __int16 v20; // [sp+10h] [bp-8h]@4
  __int16 v21; // [sp+12h] [bp-6h]@4
  __int16 v22; // [sp+14h] [bp-4h]@4
  __int16 v23; // [sp+16h] [bp-2h]@4
  int v24; // [sp+2Ch] [bp+14h]@9

  result = 1;
  if ( *a5 != 32802 )
  {
    if ( *a5 == 32832 )
    {
      *(_WORD *)(a1 + 276) = *(_WORD *)a3;
      *(_WORD *)(a1 + 278) = *(_WORD *)(a3 + 2);
      *(_WORD *)(a1 + 280) = *(_WORD *)a3 + *(_WORD *)(a2 + 4) - 1;
      result = 2;
      *(_WORD *)(a1 + 282) = *(_WORD *)(a3 + 2) + *(_WORD *)(a2 + 6) - 1;
      return result;
    }
    if ( *a5 != 32888 )
      return result;
  }
  v18 = word_100FD810[1];
  v19 = word_100FD810[0];
  v20 = word_100FD810[0];
  v21 = word_100FD810[0];
  v22 = word_100FD810[0];
  v6 = word_100FD810[(unsigned __int8)sub_10014000(15)];
  v7 = *(_WORD *)(a2 + 8);
  v23 = v6;
  v8 = v7;
  v9 = ((v7 >> 12) & 3) + 1;
  *(_WORD *)(a1 + 426) = v9;
  *(_WORD *)(a1 + 424) = v9;
  v17 = v8 & 0xC00;
  if ( (*(_WORD *)(a2 + 8) & 0xC000) == -32768 )
  {
    *(_WORD *)(a1 + 398) = 1;
    *(_DWORD *)(a1 + 452) = &unk_10059600;
    *(_WORD *)(a1 + 440) = 0;
    *(_WORD *)(a1 + 442) = *(_WORD *)(a4 + 2);
  }
  else
  {
    *(_WORD *)(a1 + 440) = *(_WORD *)(a4 + 2);
    *(_WORD *)(a1 + 442) = *(_WORD *)(a4 + 2);
    *(_WORD *)(a1 + 398) = 3;
  }
  v10 = 3 - v9;
  v11 = 0;
  if ( 3 - v9 < 3 )
  {
    v24 = v10 + 1;
    v12 = &v18 + 2 * v10;
    v16 = 3 - v10;
    do
    {
      v13 = 2;
      if ( v24 >= 3 && (*(_WORD *)(a2 + 8) & 0xC000) != 0x4000 )
        v13 = 3;
      if ( v17 == 2048 )
      {
        *(_WORD *)(a1 + 428) = *(_WORD *)a4;
        v14 = *(_WORD *)a4;
      }
      else
      {
        if ( v17 )
        {
          v15 = v12[1];
          v14 = *v12;
        }
        else
        {
          v15 = *v12;
          v14 = v12[1];
        }
        *(_WORD *)(a1 + 428) = v15;
      }
      *(_WORD *)(a1 + 430) = v14;
      sub_10035650(
        a1 + 392,
        v11 + *(_WORD *)a3,
        v11 + *(_WORD *)(a3 + 2),
        *(_WORD *)(a2 + 4) - 2 * v11,
        *(_WORD *)(a2 + 6) - 2 * v11,
        v13);
      ++v24;
      v12 += 2;
      ++v11;
      --v16;
    }
    while ( v16 );
  }
  return 2;
}
// 100FD810: using guessed type __int16 word_100FD810[];

//----- (100041C0) --------------------------------------------------------
char __cdecl sub_100041C0(int a1, int a2, int a3, _BYTE *a4, _WORD *a5)
{
  int v5; // edx@1
  int v6; // ecx@1
  char v7; // ST10_1@2
  __int16 v8; // cx@2
  __int16 v9; // ax@2
  __int16 v11; // [sp+10h] [bp-14h]@4
  __int16 v12; // [sp+12h] [bp-12h]@4
  int v13; // [sp+14h] [bp-10h]@1
  int v14; // [sp+18h] [bp-Ch]@1
  int v15; // [sp+1Ch] [bp-8h]@1

  v5 = *(_DWORD *)(a2 + 8);
  v6 = *(_DWORD *)(a2 + 4);
  v13 = *(_DWORD *)a2;
  v14 = v6;
  v15 = v5;
  if ( (_WORD)v5 == -1 )
  {
    v7 = *a4 & 0x1F;
    LOWORD(v15) = *(_WORD *)a4;
    v8 = word_100FD810[(unsigned __int8)sub_10014000(v7)];
    v9 = word_100FD810[((unsigned int)*(_WORD *)a4 >> 5) & 0x1F];
  }
  else
  {
    v8 = word_100FD810[(unsigned __int8)sub_10014000(v5 & 0x1F)];
    v9 = word_100FD810[((unsigned int)*(_WORD *)(a2 + 8) >> 5) & 0x1F];
  }
  v11 = v8;
  v12 = v9;
  return sub_10003F90(a1, (int)&v13, a3, (int)&v11, a5);
}
// 100FD810: using guessed type __int16 word_100FD810[];

//----- (100042A0) --------------------------------------------------------
int __cdecl sub_100042A0(unsigned int a1, char a2, int a3, int a4)
{
  int result; // eax@1

  result = a3 * byte_101EFA91[20 * ((a1 >> 10) & 0xF)]
         + (a3 - 1) * *(_WORD *)(dword_101EFA84[5 * ((a1 >> 10) & 0xF)] + 28);
  if ( a4 > 0 )
  {
    if ( a2 & 0x80 )
      result += *((_BYTE *)&unk_101EFA80 + 20 * ((a1 >> 10) & 0xF) + 15) - byte_101EFA91[20 * ((a1 >> 10) & 0xF)];
  }
  return result;
}
// 101EFA84: using guessed type int dword_101EFA84[];

//----- (10004300) --------------------------------------------------------
char __cdecl sub_10004300(int a1, int a2, int a3, double *a4)
{
  int v4; // esi@1
  bool v5; // zf@1
  unsigned int v6; // ecx@1
  int v7; // eax@1
  __int16 v8; // bx@1
  double v9; // st7@3
  __int16 v10; // cx@5
  __int16 v11; // cx@5
  int v12; // ebx@8
  size_t v13; // edi@9
  int v14; // eax@9
  int v15; // edx@14
  __int16 v16; // ax@14
  float v17; // ST4C_4@20
  char *v18; // edi@27
  char v19; // al@28
  char *v20; // edi@30
  char v21; // al@31
  char v22; // al@33
  char *v23; // eax@35
  char v24; // cl@36
  signed int v25; // ecx@37
  char v26; // cl@38
  int v27; // ecx@40
  int v28; // edi@43
  int i; // eax@47
  char v30; // dl@50
  signed int v31; // ecx@52
  char v32; // al@53
  int v33; // eax@63
  signed int v34; // ebx@69
  signed int v35; // eax@69
  unsigned int v36; // ST18_4@71
  char *v37; // eax@71
  int v38; // edi@80
  unsigned int v39; // ebx@80
  __int16 v40; // ax@80
  bool v42; // [sp+2Fh] [bp-59h]@21
  int v43; // [sp+30h] [bp-58h]@1
  int v44; // [sp+30h] [bp-58h]@14
  int v45; // [sp+34h] [bp-54h]@1
  char *v46; // [sp+38h] [bp-50h]@14
  char v47; // [sp+3Ch] [bp-4Ch]@71
  char v48; // [sp+3Dh] [bp-4Bh]@71
  char v49; // [sp+3Eh] [bp-4Ah]@71
  int v50; // [sp+40h] [bp-48h]@3
  int v51; // [sp+44h] [bp-44h]@1
  int v52; // [sp+48h] [bp-40h]@1
  int v53; // [sp+4Ch] [bp-3Ch]@1
  double v54; // [sp+50h] [bp-38h]@5
  char v55[2]; // [sp+58h] [bp-30h]@21
  char v56; // [sp+63h] [bp-25h]@12
  char v57; // [sp+64h] [bp-24h]@9
  char v58; // [sp+65h] [bp-23h]@64

  v4 = a2;
  v5 = *(_BYTE *)a2 == 89;
  v45 = *(_BYTE *)(a2 + 10);
  v6 = *(_WORD *)(a2 + 8);
  v53 = a1;
  v7 = *(_BYTE *)(a2 + 11);
  v8 = v6;
  v52 = a2;
  v51 = (unsigned __int16)v6;
  v43 = v7;
  if ( v5 && 9.899999762399947e24 != *a4 )
  {
    *(float *)&v50 = *a4;
    v9 = sub_10014C00(v50, v6);
  }
  else
  {
    *(float *)&v50 = 9.8999998e24;
    v9 = *a4;
  }
  v10 = *(_WORD *)(a2 + 8);
  v54 = v9;
  v11 = v10 & 0x3F;
  if ( v11 == 28 )
  {
    if ( v9 > 1.0 || v9 < 0.0 )
    {
LABEL_8:
      v12 = v53;
LABEL_9:
      v13 = *(_BYTE *)(v4 + 10);
      memset(&v57, 95, v13);
      v14 = v43;
      if ( v43 > 0 )
      {
        if ( (signed int)(v13 - v43) <= 1 )
          v14 = v13 - 2;
        *(&v56 + v13 - v14) = 46;
      }
      *(&v57 + v13) = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( v9 >= 1.0e25 )
      goto LABEL_8;
    if ( v9 <= -1.0e25 )
      goto LABEL_8;
    if ( 9.899999762399947e24 == v9 )
      goto LABEL_8;
    v17 = v9;
    if ( v17 == 9.8999998e24 )
      goto LABEL_8;
  }
  v42 = 1;
  strcpy(v55, "%");
  if ( v8 & 0x800 || v8 & 0x40 || v11 == 27 || v11 == 28 )
  {
    ++v45;
    v18 = (char *)&v54 + 7;
    do
      v19 = (v18++)[1];
    while ( v19 );
    *(_WORD *)v18 = 43;
  }
  else if ( v11 == 7 )
  {
    ++v45;
  }
  v20 = (char *)&v54 + 7;
  if ( v8 & 0x100 )
  {
    do
      v21 = (v20++)[1];
    while ( v21 );
    *(_WORD *)v20 = 48;
  }
  else
  {
    do
      v22 = (v20++)[1];
    while ( v22 );
    *(_WORD *)v20 = 45;
  }
  v23 = (char *)&v54 + 7;
  if ( v11 == 7 )
  {
    do
      v24 = (v23++)[1];
    while ( v24 );
    v25 = 1697263146;
  }
  else
  {
    do
      v26 = (v23++)[1];
    while ( v26 );
    v25 = 1714040362;
  }
  *(_DWORD *)v23 = v25;
  v27 = *(_BYTE *)(a2 + 10);
  v23[4] = 0;
  v12 = _snprintf(&v57, 0x1Eu, v55, v27, *(_BYTE *)(a2 + 11), LODWORD(v9), (_DWORD)(*(unsigned __int64 *)&v9 >> 32));
  if ( v12 > v45 )
  {
    v42 = 0;
    if ( !(v51 & 0x80) && v43 > 0 )
    {
      v28 = v43;
      do
      {
        if ( v42 )
          break;
        v12 = sprintf(&v57, v55, *(_BYTE *)(a2 + 10), --v28, v54);
        v42 = v12 <= v45;
      }
      while ( v28 > 0 );
      v43 = v28;
    }
  }
  for ( i = v12 - 1; i >= 0; --i )
  {
    if ( *(&v57 + i) != 32 )
      break;
    *(&v57 + i) = 0;
    --v12;
  }
  v30 = 1;
  if ( v57 == 45 || v57 == 43 )
  {
    v31 = 1;
    if ( v12 <= 1 )
      goto LABEL_89;
    do
    {
      v32 = *(&v57 + v31);
      if ( v32 != 46 && v32 != 48 && v32 != 101 && v32 != 43 )
      {
        v30 = 0;
        v31 = v12;
      }
      ++v31;
    }
    while ( v31 < v12 );
    if ( v30 )
    {
LABEL_89:
      if ( (*(_WORD *)(a2 + 8) & 0x3F) == 17 && *(_WORD *)(a2 + 8) & 0x40 )
      {
        v57 = 43;
      }
      else
      {
        --v12;
        v33 = 0;
        if ( v12 > 0 )
        {
          qmemcpy(&v57, &v58, v12);
          v4 = v52;
          v33 = v12;
        }
        *(&v57 + v33) = 0;
      }
    }
  }
  if ( !v42 )
    goto LABEL_9;
LABEL_14:
  v46 = sub_100141C0(*(_WORD *)(v4 + 8), (float *)&v50);
  v15 = (signed __int16)sub_10009750(*(_DWORD *)(v4 + 4), *(_WORD *)(v4 + 8), (float *)&v50);
  v16 = *(_WORD *)(v4 + 8) & 0x3F;
  v44 = v15;
  if ( v16 == 27 )
  {
    if ( v57 == 45 )
    {
      v57 = -100;
    }
    else if ( v57 == 43 )
    {
      --v45;
      v34 = v12 - 1;
      v35 = 0;
      if ( v34 > 0 )
      {
        qmemcpy(&v57, &v58, v34);
        v4 = v52;
        v35 = v34;
      }
      *(&v57 + v35) = 0;
      v36 = *(_DWORD *)(v4 + 4);
      v47 = *v46;
      v48 = -99;
      v49 = 0;
      v46 = &v47;
      v37 = sub_10009140(v36);
      v44 += sub_10034B10(*((_DWORD *)v37 + 1), "", 0);
    }
  }
  else if ( v16 == 28 && !strncmp(&v57, "+0.", 3u) )
  {
    strncpy(&v57, "M ", 2u);
  }
  if ( v51 & 0x800 )
  {
    if ( v57 == 45 )
    {
      v57 = -92;
    }
    else if ( v57 == 43 )
    {
      v57 = -93;
    }
  }
  v38 = v53;
  *(_WORD *)(v53 + 438) = *(_WORD *)a3;
  *(_WORD *)(v38 + 436) = *(_WORD *)(a3 + 2);
  v39 = *(_DWORD *)(v4 + 4);
  v40 = *(_WORD *)(v4 + 12);
  if ( (*(_DWORD *)(v4 + 4) & 0xC000) != 0x4000 )
  {
    if ( ~(unsigned __int8)(*(_WORD *)(v4 + 8) >> 9) & 1 )
    {
      v40 -= v44;
      if ( v44 > 0 )
        v40 -= *(_WORD *)(dword_101EFA84[5 * ((v39 >> 10) & 0xF)] + 28);
    }
  }
  if ( !*(_WORD *)(v4 + 12) )
    v40 = sub_100042A0(v39, *(_WORD *)(v4 + 8), v45, *(_BYTE *)(v4 + 11));
  return sub_10009CE0(v38, &v57, v46, v40, v44, v39, v51);
}
// 101EFA84: using guessed type int dword_101EFA84[];

//----- (10004800) --------------------------------------------------------
char __usercall sub_10004800@<al>(float *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4)
{
  int v4; // ebp@1
  double v5; // st7@4
  double v6; // st7@6
  __int16 v7; // ax@6
  const char *v8; // esi@8
  int v10; // [sp+14h] [bp+4h]@6
  float v11; // [sp+14h] [bp+4h]@12

  v4 = a4;
  if ( *a1 >= 1.0e25 || *a1 <= -1.0e25 || 9.8999998e24 == *a1 )
    v5 = 0.0;
  else
    v5 = *a1;
  *(float *)&v10 = v5;
  v6 = sub_10014C00(v10, *(_WORD *)(a2 + 8));
  v7 = *(_WORD *)(a2 + 8);
  if ( v7 & 0x40 )
  {
    if ( (v7 & 0x3F) == 7 )
      v8 = "%+0*.*e";
    else
      v8 = "%+0*.*f";
  }
  else
  {
    v8 = "%0*.*e";
    if ( (v7 & 0x3F) != 7 )
      v8 = "%0*.*f";
  }
  v11 = v6;
  if ( sprintf((char *)(*(_DWORD *)(v4 + 56) + 69), v8, a3, *(_BYTE *)(a2 + 11), v11) > a3 )
    sprintf((char *)(*(_DWORD *)(v4 + 56) + 69), v8, a3, *(_BYTE *)(a2 + 11), 0.0);
  *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = 0;
  return 4;
}

//----- (100048E0) --------------------------------------------------------
char __usercall sub_100048E0@<al>(int a1@<eax>, int a2, int a3, int a4)
{
  int v4; // esi@1
  __int16 v5; // ax@1
  int v6; // edi@1
  __int16 v7; // ax@2
  int v8; // ecx@8
  const char *v9; // ecx@11
  char v10; // bl@11
  char *v11; // eax@11
  char v12; // dl@11
  char v13; // cl@12
  const char *v14; // edx@14
  char *v15; // eax@14
  char v16; // di@14
  char v17; // cl@15
  char v18; // bl@16
  char *v19; // eax@16
  char v20; // dl@16
  char v21; // cl@17
  unsigned __int16 v22; // ax@20
  int v23; // ecx@22
  signed __int16 v24; // di@22
  char *v25; // eax@25
  char v26; // dl@26
  char v27; // bl@27
  char *v28; // eax@27
  char v29; // dl@27
  char v30; // cl@28
  int v31; // ecx@32
  unsigned __int8 v32; // al@32
  char *v33; // eax@36
  char v34; // dl@37
  char v35; // bl@38
  char *v36; // eax@38
  char v37; // dl@38
  char v38; // cl@39
  const char *v39; // ecx@42
  char v40; // bl@42
  char *v41; // eax@42
  char v42; // dl@42
  char v43; // cl@43
  int v44; // eax@47
  unsigned __int16 v45; // ax@53
  const char *v46; // ecx@59
  char v47; // bl@59
  char *v48; // eax@59
  char v49; // dl@59
  char v50; // cl@60
  int v51; // edx@62
  char v52; // al@64
  int v53; // ebp@64
  bool v54; // zf@71
  bool v55; // sf@71
  char *v56; // eax@72
  int v57; // edi@72
  char v58; // dl@73
  char v59; // bl@74
  char *v60; // eax@74
  char v61; // dl@74
  char v62; // cl@75
  int v63; // ecx@81
  unsigned __int8 v64; // al@81
  char *v65; // eax@85
  char v66; // dl@86
  char v67; // bl@87
  char *v68; // eax@87
  char v69; // dl@87
  char v70; // cl@88
  const char *v71; // ecx@93
  char v72; // kr00_1@93
  char *v73; // eax@93
  char v74; // dl@93
  char v75; // cl@94
  signed int v76; // eax@96
  char *v77; // eax@104
  int v78; // edi@104
  char v79; // dl@105
  char v80; // bl@106
  char *v81; // eax@106
  char v82; // dl@106
  char v83; // cl@107
  char *v84; // eax@116
  int v85; // edi@116
  char v86; // dl@117
  char v87; // bl@118
  char *v88; // eax@118
  char v89; // dl@118
  char v90; // cl@119
  char *v91; // eax@122
  int v92; // edi@122
  char v93; // dl@123
  char v94; // bl@124
  char *v95; // eax@124
  char v96; // dl@124
  char v97; // cl@125
  int v98; // ecx@126
  const char *v99; // edx@127
  char *v100; // eax@127
  char v101; // di@127
  char v102; // cl@128
  char v103; // bl@129
  char *v104; // eax@129
  char v105; // di@129
  char v106; // cl@130
  char *v107; // eax@131
  int v108; // ecx@131
  char v109; // dl@132
  char v110; // bl@133
  char *v111; // eax@133
  char v112; // dl@133
  char v113; // cl@134
  int v114; // ebp@142
  int v115; // ecx@147
  const char *v116; // edx@152
  char *v117; // eax@152
  char v118; // di@152
  char v119; // cl@153
  char v120; // bl@154
  char *v121; // eax@154
  char v122; // dl@154
  char v123; // cl@155
  int v124; // edx@158
  signed int v125; // eax@158
  char *v126; // eax@165
  int v127; // edi@165
  char v128; // dl@166
  char v129; // bl@167
  char *v130; // eax@167
  char v131; // dl@167
  char v132; // cl@168
  int v133; // eax@170
  char v135; // [sp+1Bh] [bp-Dh]@1
  float v136; // [sp+1Ch] [bp-Ch]@1
  char *v137; // [sp+20h] [bp-8h]@3
  int v138; // [sp+24h] [bp-4h]@1
  __int32 v139; // [sp+2Ch] [bp+4h]@71
  float v140; // [sp+2Ch] [bp+4h]@76

  v4 = a1;
  v136 = 0.0;
  v5 = *(_WORD *)(a2 + 8);
  v6 = a4;
  v135 = 1;
  v138 = 1;
  if ( v5 & 0x40 )
  {
    v7 = v5 & 0x3F;
    if ( v7 == 7 )
      v137 = "%+0*.*e";
    else
      v137 = "%+0*.*f";
  }
  else
  {
    v7 = v5 & 0x3F;
    v137 = "%0*.*e";
    if ( v7 != 7 )
      v137 = "%0*.*f";
  }
  if ( *(_WORD *)(a4 + 10) == 84 )
  {
    v8 = *(_DWORD *)(v4 + 56);
    if ( *(_WORD *)(v8 + 240) == -128 )
    {
      *(_WORD *)(a4 + 14) = 45;
    }
    else
    {
      if ( v7 != 7 )
        goto LABEL_176;
      v9 = (const char *)(v8 + 69);
      v10 = strlen(v9);
      v11 = strchr(v9, 101);
      v12 = (_BYTE)v11 + 1;
      do
        v13 = *v11++;
      while ( v13 );
      v8 = *(_DWORD *)(v4 + 56);
      if ( *(_WORD *)(v8 + 240) <= (signed __int16)(char)(v10 - ((_BYTE)v11 - v12)) )
      {
LABEL_176:
        v6 = a4;
        *(_WORD *)(a4 + 14) = 2 * (*(_BYTE *)(v8 + 69) != 45) + 43;
      }
      else
      {
        v14 = (const char *)(v8 + 69);
        v15 = (char *)(v8 + 69);
        v16 = v8 + 70;
        do
          v17 = *v15++;
        while ( v17 );
        v18 = (_BYTE)v15 - v16;
        v19 = strchr(v14, 101);
        v20 = (_BYTE)v19 + 1;
        do
          v21 = *v19++;
        while ( v21 );
        v6 = a4;
        *(_WORD *)(a4 + 14) = 2 * (*(_BYTE *)((char)(v18 - ((_BYTE)v19 - v20)) + *(_DWORD *)(v4 + 56) + 70) == 43) + 43;
      }
    }
  }
  v22 = *(_WORD *)(v6 + 14);
  if ( v22 < 0x30u || v22 > 0x39u )
  {
    if ( (*(_WORD *)(a2 + 8) & 0x3F) != 7 || v22 != 69 )
    {
      if ( (v22 == 43 || v22 == 45) && (sub_10014180(*(_WORD *)(a2 + 8)) || *(_BYTE *)(a2 + 8) & 0x40) )
      {
        if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == -128 )
        {
          sub_10004800(&v136, a2, a3, v4);
          if ( *(_BYTE *)(a2 + 11) )
          {
            v84 = (char *)(*(_DWORD *)(v4 + 56) + 69);
            v85 = *(_DWORD *)(v4 + 56) + 70;
            do
              v86 = *v84++;
            while ( v86 );
            v87 = (_BYTE)v84 - v85;
            v88 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
            v89 = (_BYTE)v88 + 1;
            do
              v90 = *v88++;
            while ( v90 );
            *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v87 - ((_BYTE)v88 - v89)) - 1;
          }
          else
          {
            *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = a3 - ((*(_WORD *)(a2 + 8) >> 13) & 3) - 1;
          }
        }
        if ( (*(_BYTE *)(a2 + 8) & 0x3F) != 7 )
          goto LABEL_177;
        v91 = (char *)(*(_DWORD *)(v4 + 56) + 69);
        v92 = *(_DWORD *)(v4 + 56) + 70;
        do
          v93 = *v91++;
        while ( v93 );
        v94 = (_BYTE)v91 - v92;
        v95 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 101);
        v96 = (_BYTE)v95 + 1;
        do
          v97 = *v95++;
        while ( v97 );
        v98 = *(_DWORD *)(v4 + 56);
        if ( *(_WORD *)(v98 + 240) <= (signed __int16)(char)(v94 - ((_BYTE)v95 - v96)) )
        {
LABEL_177:
          if ( (*(_WORD *)(a4 + 14) != 45 || atof((const char *)(*(_DWORD *)(v4 + 56) + 69)) < 0.0)
            && (*(_WORD *)(a4 + 14) != 43 || atof((const char *)(*(_DWORD *)(v4 + 56) + 69)) > 0.0) )
          {
            v114 = a2;
          }
          else
          {
            v114 = a2;
            if ( *(_BYTE *)(a2 + 8) & 0x40 || *(_WORD *)(a4 + 14) == 45 )
            {
              *(_BYTE *)(*(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
              v135 = 2;
            }
            else
            {
              *(_BYTE *)(*(_DWORD *)(v4 + 56) + 69) = 48;
              v135 = 2;
            }
          }
          v115 = *(_DWORD *)(v4 + 56);
          if ( !*(_WORD *)(v115 + 240)
            && (*(_BYTE *)(*(_WORD *)(v115 + 240) + v115 + 69) == 43
             || *(_BYTE *)(*(_WORD *)(v115 + 240) + v115 + 69) == 45
             || (*(_BYTE *)(v114 + 8) & 0x3F) == 7) )
          {
            if ( (*(_BYTE *)(v114 + 8) & 0x3F) == 7 )
            {
              v116 = (const char *)(v115 + 69);
              v117 = (char *)(v115 + 69);
              v118 = v115 + 70;
              do
                v119 = *v117++;
              while ( v119 );
              v120 = (_BYTE)v117 - v118;
              v121 = strchr(v116, 46);
              v122 = (_BYTE)v121 + 1;
              do
                v123 = *v121++;
              while ( v123 );
              *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v120 - ((_BYTE)v121 - v122)) - 1;
            }
            else
            {
              ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
            }
            v124 = *(_DWORD *)(v4 + 56);
            v125 = a3 - (((unsigned int)*(_WORD *)(v114 + 8) >> 13) & 3) - 1;
            if ( *(_WORD *)(v124 + 240) < v125 )
              LOWORD(v125) = *(_WORD *)(v124 + 240);
            *(_WORD *)(v124 + 240) = (char)v125;
          }
        }
        else
        {
          v99 = (const char *)(v98 + 69);
          v100 = (char *)(v98 + 69);
          v101 = v98 + 70;
          do
            v102 = *v100++;
          while ( v102 );
          v103 = (_BYTE)v100 - v101;
          v104 = strchr(v99, 101);
          v105 = (_BYTE)v104 + 1;
          do
            v106 = *v104++;
          while ( v106 );
          *(_BYTE *)((char)(v103 - ((_BYTE)v104 - v105)) + *(_DWORD *)(v4 + 56) + 70) = *(_BYTE *)(a4 + 14);
          v107 = (char *)(*(_DWORD *)(v4 + 56) + 69);
          v108 = *(_DWORD *)(v4 + 56) + 70;
          do
            v109 = *v107++;
          while ( v109 );
          v110 = (_BYTE)v107 - v108;
          v111 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 101);
          v112 = (_BYTE)v111 + 1;
          do
            v113 = *v111++;
          while ( v113 );
          if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == (char)(v110 - ((_BYTE)v111 - v112)) + 1 )
            ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
          v135 = 2;
        }
      }
      else if ( *(_WORD *)(v6 + 14) == 46 && *(_BYTE *)(a2 + 11) > 0 )
      {
        if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == -128 )
          sub_10004800(&v136, a2, a3, v4);
        v126 = (char *)(*(_DWORD *)(v4 + 56) + 69);
        v127 = *(_DWORD *)(v4 + 56) + 70;
        do
          v128 = *v126++;
        while ( v128 );
        v129 = (_BYTE)v126 - v127;
        v130 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
        v131 = (_BYTE)v130 + 1;
        do
          v132 = *v130++;
        while ( v132 );
        *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v129 - ((_BYTE)v130 - v131)) + 1;
      }
    }
    else
    {
      if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == -128 )
        sub_10004800(&v136, a2, a3, v4);
      v77 = (char *)(*(_DWORD *)(v4 + 56) + 69);
      v78 = *(_DWORD *)(v4 + 56) + 70;
      do
        v79 = *v77++;
      while ( v79 );
      v80 = (_BYTE)v77 - v78;
      v81 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 101);
      v82 = (_BYTE)v81 + 1;
      do
        v83 = *v81++;
      while ( v83 );
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v80 - ((_BYTE)v81 - v82)) + 1;
      v135 = 2;
    }
    goto LABEL_170;
  }
  v23 = *(_DWORD *)(v4 + 56);
  v24 = *(_WORD *)(v23 + 240);
  if ( v24 == -128 )
  {
    sub_10004800(&v136, a2, a3, v4);
    if ( *(_BYTE *)(a2 + 11) )
    {
      v25 = (char *)(*(_DWORD *)(v4 + 56) + 69);
      do
        v26 = *v25++;
      while ( v26 );
      v27 = (_BYTE)v25 - (*(_BYTE *)(v4 + 56) + 70);
      v28 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
      v29 = (_BYTE)v28 + 1;
      do
        v30 = *v28++;
      while ( v30 );
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v27 - ((_BYTE)v28 - v29)) - 1;
    }
    else
    {
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = a3 - ((*(_WORD *)(a2 + 8) >> 13) & 3) - 1;
    }
    *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
    if ( *(_BYTE *)(a2 + 11) > 0 )
    {
      if ( (*(_BYTE *)(a2 + 8) & 0x3F) == 7
        || (v31 = *(_DWORD *)(v4 + 56), v32 = *(_BYTE *)(v31 + 69), v32 > 0x30u)
        || (v32 == 43 || v32 == 45) && *(_BYTE *)(v31 + 70) != 48 )
      {
        v33 = (char *)(*(_DWORD *)(v4 + 56) + 69);
        do
          v34 = *v33++;
        while ( v34 );
        v35 = (_BYTE)v33 - (*(_BYTE *)(v4 + 56) + 70);
        v36 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
        v37 = (_BYTE)v36 + 1;
        do
          v38 = *v36++;
        while ( v38 );
        *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v35 - ((_BYTE)v36 - v37)) + 1;
        v135 = 2;
        goto LABEL_170;
      }
    }
LABEL_99:
    v135 = 2;
    goto LABEL_170;
  }
  if ( (*(_BYTE *)(a2 + 8) & 0x3F) == 7 )
  {
    v39 = (const char *)(v23 + 69);
    v40 = strlen(v39);
    v41 = strchr(v39, 101);
    v42 = (_BYTE)v41 + 1;
    do
      v43 = *v41++;
    while ( v43 );
    v23 = *(_DWORD *)(v4 + 56);
    v24 = *(_WORD *)(v23 + 240);
    if ( v24 > (char)(v40 - ((_BYTE)v41 - v42)) )
    {
      if ( a3 - v24 != 2 )
      {
        if ( a3 - v24 != 3 )
        {
          v44 = *(_DWORD *)(v4 + 56);
          if ( a3 - v24 != 4 )
          {
            if ( *(_BYTE *)(*(_WORD *)(v44 + 240) + v44 + 68) < 0x33u || *(_WORD *)(a4 + 14) < 0x38u )
            {
              *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
              v135 = 2;
              goto LABEL_170;
            }
            goto LABEL_99;
          }
          ++*(_WORD *)(v44 + 240);
        }
        ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
      }
      v45 = *(_WORD *)(a4 + 14);
      if ( v45 >= 0x30u
        && v45 <= 0x33u
        && (*(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 70) < 0x38u || v45 < 0x33u) )
      {
        *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v4 + 56) + 240))++ + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
        v135 = 2;
        goto LABEL_170;
      }
      goto LABEL_99;
    }
  }
  if ( *(_BYTE *)(a2 + 11) <= 0 )
    goto LABEL_178;
  v46 = (const char *)(v23 + 69);
  v47 = strlen(v46);
  v48 = strchr(v46, 46);
  v49 = (_BYTE)v48 + 1;
  do
    v50 = *v48++;
  while ( v50 );
  v23 = *(_DWORD *)(v4 + 56);
  v24 = *(_WORD *)(v23 + 240);
  if ( *(_WORD *)(v23 + 240) != (char)(v47 - ((_BYTE)v48 - v49)) - 1 )
  {
LABEL_178:
    v51 = a2;
    if ( !*(_BYTE *)(a2 + 11) )
    {
      if ( v24 == a3 - (((unsigned int)*(_WORD *)(a2 + 8) >> 13) & 3) - 1 )
        goto LABEL_64;
      v51 = a2;
    }
    if ( (*(_BYTE *)(v51 + 8) & 0x3F) == 7 && !v24 )
    {
      v71 = (const char *)(v23 + 69);
      v72 = strlen(v71);
      v73 = strchr(v71, 46);
      v74 = (_BYTE)v73 + 1;
      do
        v75 = *v73++;
      while ( v75 );
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v72 - ((_BYTE)v73 - v74)) - 1;
      v51 = a2;
    }
    *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v4 + 56) + 240))++ + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
    v76 = a3 - (((unsigned int)*(_WORD *)(v51 + 8) >> 13) & 3) - 1;
    if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) < v76 )
      LOWORD(v76) = *(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
    *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)v76;
    goto LABEL_99;
  }
LABEL_64:
  v52 = *(_BYTE *)(v23 + 69);
  v53 = a2;
  if ( v52 == 48 && (*(_BYTE *)(a2 + 8) & 0x3F) != 7 || (v52 == 43 || v52 == 45) && *(_BYTE *)(v23 + 70) == 48 )
  {
    if ( v52 == 45 )
    {
      *(_BYTE *)(v23 + 69) = 48;
      v138 = -1;
    }
    v139 = j__atol((const char *)(*(_DWORD *)(v4 + 56) + 69));
    v54 = *(_BYTE *)(v53 + 11) == 0;
    v55 = *(_BYTE *)(v53 + 11) < 0;
    v136 = (double)v139 * 10.0;
    if ( !v55 && !v54 )
    {
      v56 = (char *)(*(_DWORD *)(v4 + 56) + 69);
      v57 = *(_DWORD *)(v4 + 56) + 70;
      do
        v58 = *v56++;
      while ( v58 );
      v59 = (_BYTE)v56 - v57;
      v60 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
      v61 = (_BYTE)v60 + 1;
      do
        v62 = *v60++;
      while ( v62 );
      v140 = atof((const char *)((char)(v59 - ((_BYTE)v60 - v61)) + *(_DWORD *)(v4 + 56) + 69));
      v136 = v140 + v136;
    }
    sprintf((char *)(*(_DWORD *)(v4 + 56) + 69), v137, a3, *(_BYTE *)(v53 + 11), v136);
    if ( v138 == -1 )
      *(_BYTE *)(*(_DWORD *)(v4 + 56) + 69) = 45;
  }
  *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
  if ( *(_BYTE *)(v53 + 11) <= 0 )
    goto LABEL_99;
  if ( (*(_BYTE *)(v53 + 8) & 0x3F) != 7 )
  {
    v63 = *(_DWORD *)(v4 + 56);
    v64 = *(_BYTE *)(v63 + 69);
    if ( v64 <= 0x30u && (v64 != 43 && v64 != 45 || *(_BYTE *)(v63 + 70) == 48) )
      goto LABEL_99;
  }
  v65 = (char *)(*(_DWORD *)(v4 + 56) + 69);
  do
    v66 = *v65++;
  while ( v66 );
  v67 = (_BYTE)v65 - (*(_BYTE *)(v4 + 56) + 70);
  v68 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
  v69 = (_BYTE)v68 + 1;
  do
    v70 = *v68++;
  while ( v70 );
  *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v67 - ((_BYTE)v68 - v69)) + 1;
  v135 = 2;
LABEL_170:
  v133 = *(_DWORD *)(v4 + 56);
  if ( *(_BYTE *)(*(_WORD *)(v133 + 240) + v133 + 69) == 101 || *(_BYTE *)(*(_WORD *)(v133 + 240) + v133 + 69) == 46 )
    ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
  return v135;
}

//----- (100053B0) --------------------------------------------------------
char __usercall sub_100053B0@<al>(int a1@<eax>, float *a2@<ecx>, int a3@<ebx>, int a4@<esi>, int a5)
{
  float *v5; // edi@1
  __int16 v6; // ax@1
  unsigned int v7; // edi@1
  int v8; // ebp@1
  __int16 v9; // ax@1
  char *v11; // [sp+8h] [bp-4h]@1

  v5 = a2;
  *(_WORD *)(a3 + 438) = *(_WORD *)a1;
  *(_WORD *)(a3 + 436) = *(_WORD *)(a1 + 2);
  v11 = sub_100141C0(*(_WORD *)(a4 + 8), a2);
  v6 = sub_10009750(*(_DWORD *)(a4 + 4), *(_WORD *)(a4 + 8), v5);
  v7 = *(_DWORD *)(a4 + 4);
  v8 = v6;
  v9 = *(_WORD *)(a4 + 12);
  if ( (*(_DWORD *)(a4 + 4) & 0xC000) != 0x4000 )
  {
    v9 -= v8;
    if ( v8 > 0 )
      v9 -= *(_WORD *)(dword_101EFA84[5 * ((v7 >> 10) & 0xF)] + 28);
  }
  if ( !*(_WORD *)(a4 + 12) )
    v9 = sub_100042A0(v7, *(_WORD *)(a4 + 8), a5, *(_BYTE *)(a4 + 11));
  return sub_10009CE0(a3, (char *)(*(_DWORD *)(a3 + 56) + 69), v11, v9, v8, v7, *(_WORD *)(a4 + 8));
}
// 101EFA84: using guessed type int dword_101EFA84[];

//----- (10005470) --------------------------------------------------------
char __usercall sub_10005470@<al>(int a1@<edx>, float *a2@<ecx>, int a3, int a4)
{
  double v4; // st7@2
  double v6; // [sp+0h] [bp-8h]@4

  if ( 9.8999998e24 == *a2 )
    v4 = 9.899999762399947e24;
  else
    v4 = *a2;
  v6 = v4;
  return sub_10004300(a3, a1, a4, &v6);
}

//----- (100054B0) --------------------------------------------------------
char __cdecl sub_100054B0(int a1, int a2, int *a3, float *a4, int a5)
{
  __int16 v5; // cx@2
  __int16 v6; // cx@4
  __int16 v7; // ax@9
  _WORD *v8; // esi@9
  unsigned int v9; // ebp@10
  int v10; // eax@10
  int v11; // edx@12
  __int16 v12; // ax@16
  int v13; // eax@17
  __int16 v14; // cx@17
  int v16; // eax@19
  signed __int16 v17; // si@19
  signed int v18; // eax@20
  char v19; // al@27
  char v20; // al@33
  __int16 v21; // ax@36
  signed int v22; // ecx@40
  int v23; // ecx@42
  int v24; // ecx@43
  int v25; // ecx@45
  int v26; // ecx@47
  int v27; // edi@49
  const char *v28; // eax@50
  char v29; // ST38_1@50
  bool v30; // zf@58
  bool v31; // sf@58
  int v32; // esi@65
  char v33; // dl@68
  bool v34; // zf@73
  bool v35; // sf@73
  bool v36; // zf@80
  bool v37; // sf@80
  char v38; // al@87
  int v39; // esi@94
  double v40; // st7@96
  int v41; // esi@101
  unsigned int v42; // edx@101
  __int16 v43; // bx@101
  unsigned __int8 v44; // cl@103
  int v45; // ecx@109
  _WORD *v46; // eax@109
  char v47; // dl@109
  char *v48; // eax@114
  int v49; // esi@114
  char v50; // dl@115
  char v51; // bl@116
  char *v52; // eax@116
  char v53; // dl@116
  char v54; // cl@117
  char v55; // cl@118
  int v56; // eax@118
  int v57; // edx@118
  char *v58; // eax@120
  int v59; // esi@120
  char v60; // dl@121
  char v61; // bl@122
  char *v62; // eax@122
  char v63; // dl@122
  char v64; // cl@123
  char v65; // cl@124
  int v66; // eax@124
  int v67; // edx@124
  char v68; // [sp-4h] [bp-2Ch]@64
  unsigned __int16 v69; // [sp+0h] [bp-28h]@64
  char v70; // [sp+4h] [bp-24h]@64
  char v71; // [sp+1Bh] [bp-Dh]@1
  size_t v72; // [sp+1Ch] [bp-Ch]@2
  unsigned int v73; // [sp+3Ch] [bp+14h]@50
  int v74; // [sp+3Ch] [bp+14h]@99

  v71 = 1;
  if ( *(_WORD *)a5 == -32703 )
  {
    v72 = 0;
  }
  else
  {
    v72 = *(_BYTE *)(a2 + 10);
    v5 = *(_WORD *)(a2 + 8);
    if ( v5 & 0x40 || *(_WORD *)(a2 + 8) & 0x800 || (v6 = v5 & 0x3F, v6 == 7) || v6 == 28 )
      ++v72;
  }
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      v7 = *(_WORD *)(a2 + 12);
      v8 = (_WORD *)(a1 + 276);
      if ( v7 )
      {
        sub_10009C10(a1 + 276, *a3, *(_DWORD *)(a2 + 4), v7);
      }
      else
      {
        v9 = *(_DWORD *)(a2 + 4);
        v10 = sub_100042A0(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), *(_BYTE *)(a2 + 10), *(_BYTE *)(a2 + 11));
        sub_10009C10((int)v8, *a3, v9, v10);
      }
      v11 = (signed __int16)sub_10009750(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), a4);
      if ( (!*(_WORD *)(a2 + 12) || (*(_DWORD *)(a2 + 4) & 0xC000) == 0x4000)
        && ~(unsigned __int8)(*(_WORD *)(a2 + 8) >> 9) & 1
        && v11 > 0 )
      {
        v12 = *(_WORD *)(dword_101EFA84[5 * ((*(_DWORD *)(a2 + 4) >> 10) & 0xF)] + 28);
        *(_WORD *)(a1 + 280) += v11 + v12;
        if ( (*(_DWORD *)(a2 + 4) & 0xC000) == 0x8000 )
        {
          v13 = (v12 + v11 + 1) / 2;
          v14 = *(_WORD *)(a1 + 280) - v13;
          *v8 -= v13;
          *(_WORD *)(a1 + 280) = v14;
        }
      }
      return 2;
    case 0x8048:
      v16 = *(_DWORD *)(a1 + 56);
      v17 = *(_WORD *)(v16 + 240);
      if ( v17 == -128 )
      {
        v18 = *(_WORD *)(a5 + 10);
        if ( v18 > 84 )
        {
          if ( v18 != 0x2000 )
            return v71;
        }
        else if ( v18 != 84 )
        {
          if ( v18 == 32 )
          {
            if ( *(_WORD *)(a2 + 8) & 0x400 || (*(_WORD *)(a2 + 8) & 0x3F) == 27 || *(_WORD *)(a2 + 8) & 0x800 )
              return v71;
            v71 = sub_10004800(a4, a2, v72, a1);
            memset((void *)(*(_DWORD *)(a1 + 56) + 69), 48, v72);
            if ( (*(_BYTE *)(a2 + 8) & 0x3F) == 7 )
            {
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + 71) = 46;
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + v72 + 64) = 101;
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + v72 + 65) = 43;
            }
            else
            {
              v20 = *(_BYTE *)(a2 + 11);
              if ( v20 > 0 )
                *(_BYTE *)(*(_DWORD *)(a1 + 56) - v20 + v72 + 68) = 46;
            }
            goto LABEL_132;
          }
          if ( v18 != 56
            || *(_WORD *)(a2 + 8) & 0x400
            || (*(_WORD *)(a2 + 8) & 0x3F) == 27
            || *(_WORD *)(a2 + 8) & 0x800 )
          {
            return v71;
          }
          v19 = sub_10004800(a4, a2, v72, a1);
LABEL_131:
          v71 = v19;
LABEL_132:
          if ( v71 != 4 && v71 != 2 )
            return v71;
          goto LABEL_134;
        }
        v21 = *(_WORD *)(a2 + 8);
        if ( *(_WORD *)(a2 + 8) & 0x400 || (v21 & 0x3F) == 27 || *(_WORD *)(a2 + 8) & 0x800 )
          return v71;
        v19 = sub_100048E0(a1, a2, v72, a5);
        goto LABEL_131;
      }
      v22 = *(_WORD *)(a5 + 10);
      if ( v22 > 57 )
      {
        if ( v22 != 84 && v22 != 0x2000 )
          return v71;
        v19 = sub_100048E0(a1, a2, v72, a5);
        goto LABEL_131;
      }
      if ( v22 == 57 )
      {
        *(_WORD *)(v16 + 240) += *(_BYTE *)(a5 + 8);
        v41 = *(_DWORD *)(a1 + 56);
        v42 = *(_WORD *)(a2 + 8);
        v43 = *(_WORD *)(v41 + 240);
        v71 = 2;
        if ( v43 >= 0 )
        {
          v44 = *(_BYTE *)(a2 + 10);
          if ( v43 <= (signed int)(v44 - ((v42 >> 13) & 3) - 1) || v42 & 0x40 || (v42 & 0x3F) == 7 )
          {
            if ( v43 <= (signed int)v44 )
            {
              while ( 1 )
              {
                v45 = *(_DWORD *)(a1 + 56);
                v46 = (_WORD *)(v45 + 240);
                v47 = *(_BYTE *)(*(_WORD *)(v45 + 240) + v45 + 69);
                if ( v47 != 46 && v47 != 101 )
                {
                  if ( (*(_BYTE *)(a2 + 8) & 0x3F) != 7 || *(_WORD *)(v45 + 240) <= 0 )
                    break;
                  if ( !strchr((const char *)(v45 + 69), 46) )
                    goto LABEL_142;
                  v48 = (char *)(*(_DWORD *)(a1 + 56) + 69);
                  v49 = *(_DWORD *)(a1 + 56) + 70;
                  do
                    v50 = *v48++;
                  while ( v50 );
                  v51 = (_BYTE)v48 - v49;
                  v52 = strchr((const char *)(*(_DWORD *)(a1 + 56) + 69), 46);
                  v53 = (_BYTE)v52 + 1;
                  do
                    v54 = *v52++;
                  while ( v54 );
                  v55 = (_BYTE)v52 - v53;
                  v56 = *(_DWORD *)(a1 + 56);
                  v57 = *(_WORD *)(v56 + 240);
                  v46 = (_WORD *)(v56 + 240);
                  if ( v57 >= (char)(v51 - v55) - 1 )
                  {
LABEL_142:
                    if ( strchr((const char *)(*(_DWORD *)(a1 + 56) + 69), 46) )
                      break;
                    v58 = (char *)(*(_DWORD *)(a1 + 56) + 69);
                    v59 = *(_DWORD *)(a1 + 56) + 70;
                    do
                      v60 = *v58++;
                    while ( v60 );
                    v61 = (_BYTE)v58 - v59;
                    v62 = strchr((const char *)(*(_DWORD *)(a1 + 56) + 69), 101);
                    v63 = (_BYTE)v62 + 1;
                    do
                      v64 = *v62++;
                    while ( v64 );
                    v65 = (_BYTE)v62 - v63;
                    v66 = *(_DWORD *)(a1 + 56);
                    v67 = *(_WORD *)(v66 + 240);
                    v46 = (_WORD *)(v66 + 240);
                    if ( v67 >= (char)(v61 - v65) - 1 )
                      break;
                  }
                }
                if ( *(_BYTE *)(a5 + 8) <= 0 )
                  --*v46;
                else
                  ++*v46;
              }
            }
            else
            {
              *(_WORD *)(v41 + 240) = (char)v44;
            }
          }
          else
          {
            *(_WORD *)(v41 + 240) = (char)(v44 - ((v42 >> 13) & 3) - 1);
          }
        }
        else
        {
          *(_WORD *)(v41 + 240) = 0;
        }
        goto LABEL_134;
      }
      v23 = v22 - 32;
      if ( !v23 )
      {
        *(_WORD *)(v16 + 240) = -128;
        sub_10005470(a2, a4, a1, (int)a3);
        return 6;
      }
      v24 = v23 - 1;
      if ( v24 )
      {
        if ( v24 != 23 )
          return v71;
        v25 = *(_WORD *)(a2 + 8);
        if ( v25 & 0x40 && !v17 )
        {
          LOBYTE(v25) = *(_BYTE *)(v16 + 69) != 45;
          v26 = 2 * v25 + 43;
LABEL_48:
          *(_BYTE *)(v16 + 69) = v26;
          v71 = 2;
LABEL_134:
          sub_100053B0((int)a3, a4, a1, a2, v72);
          return v71;
        }
        v27 = 2 * (*(_BYTE *)(a5 + 8) >= 0) - 1;
        if ( (v25 & 0x3F) != 7
          || (v28 = (const char *)(v16 + 69),
              v73 = strlen(v28),
              v29 = strlen(strchr(v28, 101)),
              v16 = *(_DWORD *)(a1 + 56),
              v17 = *(_WORD *)(v16 + 240),
              v17 <= (char)(v73 - v29))
          && v17 )
        {
          v38 = *(_BYTE *)(v17 + v16 + 69);
          if ( (v38 == 48 && v27 < 0 || v38 == 57 && v27 > 0) && !v17 && sub_10014180(*(_WORD *)(a2 + 8)) )
          {
            *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69) = 45;
            v71 = 2;
            goto LABEL_134;
          }
          v39 = *(_DWORD *)(a1 + 56);
          *(_BYTE *)(*(_WORD *)(v39 + 240) + v39 + 69) = sub_1000F490(
                                                           *(_BYTE *)(*(_WORD *)(v39 + 240) + v39 + 69),
                                                           0x10u,
                                                           v27);
        }
        else
        {
          if ( !v17 )
          {
            v71 = 2;
            *(_BYTE *)(v16 + 69) = *(_BYTE *)(v16 + 69) != 45 ? 45 : 48;
            goto LABEL_134;
          }
          if ( v72 - v17 == 2 )
          {
            v16 += v17;
            if ( *(_BYTE *)(v16 + 70) > 0x37u )
            {
              v34 = v27 == 0;
              v35 = v27 < 0;
              if ( v27 < 0 )
              {
                if ( *(_BYTE *)(v16 + 69) == 48 )
                {
                  *(_BYTE *)(v16 + 69) = 50;
                  v71 = 2;
                  goto LABEL_134;
                }
                v34 = v27 == 0;
                v35 = v27 < 0;
              }
              if ( !v35 && !v34 && *(_BYTE *)(v16 + 69) >= 0x32u )
              {
                *(_BYTE *)(v16 + 69) = 48;
                v71 = 2;
                goto LABEL_134;
              }
LABEL_64:
              v70 = v27;
              v69 = 16;
              v68 = *(_BYTE *)(v16 + 69);
LABEL_65:
              v32 = *(_DWORD *)(a1 + 56);
              *(_BYTE *)(*(_WORD *)(v32 + 240) + v32 + 69) = sub_1000F490(v68, v69, v70);
              v71 = 2;
              goto LABEL_134;
            }
            v36 = v27 == 0;
            v37 = v27 < 0;
            if ( v27 < 0 )
            {
              if ( *(_BYTE *)(v16 + 69) == 48 )
              {
                *(_BYTE *)(v16 + 69) = 51;
                v71 = 2;
                goto LABEL_134;
              }
              v36 = v27 == 0;
              v37 = v27 < 0;
            }
            if ( !v37 && !v36 && *(_BYTE *)(v16 + 69) >= 0x33u )
            {
              *(_BYTE *)(v16 + 69) = 48;
              v71 = 2;
              goto LABEL_134;
            }
LABEL_66:
            v70 = v27;
            v69 = 16;
            v68 = *(_BYTE *)(v16 + 69);
            goto LABEL_65;
          }
          if ( v72 - v17 != 3 )
          {
            if ( v72 - v17 == 4 )
            {
              v71 = 2;
              *(_BYTE *)(v17 + v16 + 69) = 2 * (*(_BYTE *)(v17 + v16 + 69) != 45) + 43;
              goto LABEL_134;
            }
            v16 += v17;
            if ( *(_BYTE *)(v16 + 68) >= 0x33u )
            {
              v30 = v27 == 0;
              v31 = v27 < 0;
              LOBYTE(v26) = 48;
              if ( v27 < 0 )
              {
                if ( *(_BYTE *)(v16 + 69) == 48 )
                {
                  *(_BYTE *)(v16 + 69) = 55;
                  v71 = 2;
                  goto LABEL_134;
                }
                v30 = v27 == 0;
                v31 = v27 < 0;
              }
              if ( !v31 && !v30 && *(_BYTE *)(v16 + 69) >= 0x37u )
                goto LABEL_48;
              goto LABEL_64;
            }
            goto LABEL_66;
          }
          v33 = *(_BYTE *)(v17 + v16 + 69);
          if ( v33 == 45 )
          {
            *(_BYTE *)(v17 + v16 + 69) = 43;
            v71 = 2;
            goto LABEL_134;
          }
          if ( v33 == 43 )
          {
            *(_BYTE *)(v17 + v16 + 69) = 45;
            v71 = 2;
            goto LABEL_134;
          }
        }
        v71 = 2;
        goto LABEL_134;
      }
      *(_WORD *)(v16 + 240) = -128;
      v40 = atof((const char *)(*(_DWORD *)(a1 + 56) + 69));
      if ( v40 > 1.0e25 || v40 < -1.0e25 )
        v40 = 9.899999762399947e24;
      *(float *)&v74 = v40;
      *a4 = sub_10015230(v74, *(_WORD *)(a2 + 8));
      sub_10005470(a2, a4, a1, (int)a3);
      return 3;
    case 0x8022:
    case 0x8078:
      if ( !*(_BYTE *)(a1 + 3) || *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 )
      {
        sub_10005470(a2, a4, a1, (int)a3);
        return v71;
      }
      sub_100053B0((int)a3, a4, a1, a2, v72);
      return 1;
    default:
      return v71;
  }
}
// 101EFA84: using guessed type int dword_101EFA84[];

//----- (10005DA0) --------------------------------------------------------
char __usercall sub_10005DA0@<al>(int a1@<eax>, int a2@<edx>)
{
  return ((*(_BYTE *)(a1 + 16) & 0x3F) != 44 ? 3 : 0) + (*(_BYTE *)(a2 + 9) == 0);
}

//----- (10005DC0) --------------------------------------------------------
char __usercall sub_10005DC0@<al>(int a1@<edi>, int a2@<esi>)
{
  char v2; // bl@1
  int v3; // ecx@1
  char v4; // al@3
  bool v5; // zf@9
  char v6; // al@21
  char result; // al@26
  char v8; // [sp+7h] [bp-5h]@1
  int v9; // [sp+8h] [bp-4h]@11

  v8 = 0;
  v2 = 0;
  if ( sub_10012660(&v8) == 1 )
  {
    LOBYTE(v3) = *(_BYTE *)(a1 + 16) & 0x3F;
    if ( (_BYTE)v3 == 44 )
    {
      v4 = *(_BYTE *)(a2 + 9);
      LOBYTE(v3) = v8;
      if ( v4 == 1 )
      {
        if ( v8 == 1 )
          goto LABEL_19;
      }
      else
      {
        if ( v8 == 2 )
          goto LABEL_19;
        if ( v4 != 1 )
        {
LABEL_9:
          v5 = v8 == 4;
          goto LABEL_18;
        }
      }
      if ( v8 != 6 )
        goto LABEL_9;
LABEL_19:
      v2 = 1;
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  if ( (*(_BYTE *)(a1 + 16) & 0x3F) == 44 && sub_1000A830((int)&v9) )
  {
    v3 = v9;
    if ( *(_BYTE *)(a2 + 9) != 1 )
    {
      if ( BYTE1(v3) != 1 )
      {
        v5 = BYTE3(v9) == 1;
LABEL_18:
        if ( v5 )
          goto LABEL_19;
        goto LABEL_20;
      }
      goto LABEL_19;
    }
    if ( (_BYTE)v9 == 1 || BYTE2(v9) == 1 )
      goto LABEL_19;
LABEL_20:
    v2 = 0;
  }
LABEL_21:
  v6 = sub_100159D0(v3);
  if ( (*(_BYTE *)(a1 + 16) & 0x3F) == 44 )
    goto LABEL_27;
  if ( *(_BYTE *)(a2 + 9) != 1 )
  {
    if ( v6 == 2 )
      goto LABEL_26;
LABEL_27:
    result = 0;
    goto LABEL_28;
  }
  if ( v6 != 1 )
    goto LABEL_27;
LABEL_26:
  result = 1;
LABEL_28:
  if ( v2 || result )
    result = 1;
  return result;
}

//----- (10005EA0) --------------------------------------------------------
int __usercall sub_10005EA0@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  __int16 v3; // dx@1
  __int16 v4; // cx@1
  int v6; // [sp+0h] [bp-4h]@1

  v6 = a2;
  v3 = *(_WORD *)a1 + *(_WORD *)(a2 + 4);
  v4 = *(_WORD *)(a1 + 2) + *(_WORD *)(a2 + 6);
  LOWORD(v6) = v3;
  HIWORD(v6) = v4;
  return sub_10009820(a3, a1, (int)&v6, 0);
}

//----- (10005ED0) --------------------------------------------------------
int __usercall sub_10005ED0@<eax>(int a1@<eax>, int a2@<ecx>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11)
{
  int v11; // ebp@1
  int v12; // edi@1
  int v13; // ebx@1
  int v14; // esi@1
  __int64 v15; // rax@1
  int v16; // ST20_4@1
  char *v17; // eax@1
  char *v18; // ST3C_4@1
  signed int v19; // esi@1
  __int16 v20; // ax@1
  unsigned int v21; // eax@4
  unsigned int v22; // eax@5
  char v23; // cl@5
  int v24; // eax@8
  _WORD *v25; // ecx@11
  __int16 v26; // si@14
  __int16 v27; // ax@14
  __int16 v28; // si@15
  int result; // eax@15
  __int16 v30; // bp@15
  __int16 v31; // cx@16
  __int16 v32; // si@17
  __int16 v33; // ax@18
  __int16 v34; // ax@18
  __int16 v35; // ax@18
  int v36; // eax@19
  int v37; // eax@19
  __int16 v38; // ax@20
  __int16 v39; // ax@20
  int v40; // edx@21
  int v41; // ecx@22
  int v42; // eax@22
  __int16 v43; // bx@22
  __int16 v44; // ax@23
  int v45; // [sp+10h] [bp-10h]@1
  __int16 v46; // [sp+14h] [bp-Ch]@1
  int v47; // [sp+18h] [bp-8h]@1
  int v48; // [sp+1Ch] [bp-4h]@1
  int v49; // [sp+28h] [bp+8h]@19
  int v50; // [sp+38h] [bp+18h]@1

  v11 = a8;
  v12 = a2;
  v13 = a1;
  v50 = *(_DWORD *)(a5 + 16);
  v14 = *(_WORD *)(*((_DWORD *)sub_10009140(*(_DWORD *)(a2 + 8)) + 1) + 26);
  v15 = *(_WORD *)(*((_DWORD *)sub_10009140(*(_DWORD *)(v12 + 8)) + 1) + 24) - v14;
  v46 = *(_WORD *)(a4 + 2) + *(_WORD *)(v12 + 6) / 2 + (((signed int)v15 - HIDWORD(v15)) >> 1);
  v16 = sub_10009160(*(_DWORD *)(v12 + 12));
  v17 = sub_10009140(*(_DWORD *)(v12 + 12));
  v48 = sub_10034B10(*((_DWORD *)v17 + 1), &word_1005DA40, v16);
  v18 = sub_10009140(*(_DWORD *)(v12 + 8));
  v19 = sub_10009160(*(_DWORD *)(v12 + 8));
  v45 = sub_10034B10(*((_DWORD *)v18 + 1), &word_1005DA40, v19);
  v20 = sub_10008ED0(v19);
  *(_DWORD *)a6 = 107;
  *(_DWORD *)(a6 + 4) = *(_DWORD *)(v12 + 12);
  v47 = v20;
  *(_WORD *)(a6 + 8) = 0;
  *(_WORD *)(a6 + 14) = v46;
  *(_DWORD *)v11 = 78;
  *(_WORD *)(v11 + 8) = *(_WORD *)(v12 + 16);
  *(_DWORD *)(v11 + 4) = *(_DWORD *)(v12 + 8) & 0xFFFFFD8F | 0x18F;
  if ( sub_10005DC0(v12, a5) == 1 )
  {
    *(_DWORD *)(v11 + 4) = *(_DWORD *)(v11 + 4) & 0xFFFFFFE5 | 0x185;
    *(_BYTE *)(a5 + 8) = (*(_BYTE *)(v12 + 16) & 0x3F) != 44;
  }
  else
  {
    *(_BYTE *)(a5 + 8) = 0;
  }
  *(_WORD *)(v11 + 18) = v46;
  *(_DWORD *)v13 = 78;
  *(_WORD *)(v13 + 8) = *(_WORD *)(v12 + 16);
  v21 = *(_DWORD *)(v12 + 8) & 0xFFFFFD80 | *(_BYTE *)(v50 + 4) & 0x1F | 0x180;
  *(_DWORD *)(v13 + 4) = v21;
  if ( *(_BYTE *)(a5 + 10) == 1 )
  {
    v22 = v21 & 0xFFFFFFE0;
    *(_DWORD *)(v13 + 4) = v22;
    v23 = *(_BYTE *)(v50 + 1);
    if ( v23 && *(_WORD *)(*(_DWORD *)(a3 + 56) + 240) == -128 && v23 )
      v24 = v22 | 0x18F;
    else
      v24 = v22 | 0x186;
    *(_DWORD *)(v13 + 4) = v24;
  }
  v25 = (_WORD *)a4;
  *(_WORD *)(v13 + 18) = v46;
  *(_DWORD *)a10 = 96;
  *(_WORD *)(a10 + 14) = *(_WORD *)(a4 + 2) + 2;
  *(_WORD *)(a10 + 6) = *(_WORD *)(v12 + 6) - 3;
  *(_WORD *)(a10 + 8) = 18822;
  if ( !*(_BYTE *)(v50 + 1) )
    *(_DWORD *)(v13 + 4) = *(_DWORD *)(v13 + 4) & 0xFFFFF7FF | 0x1000;
  if ( (*(_BYTE *)(v12 + 16) & 0x3F) == 44 )
  {
    *(_BYTE *)(v13 + 11) = 3;
    *(_WORD *)(v13 + 12) = 0;
    *(_BYTE *)(v13 + 10) = 7;
    *(_WORD *)(v13 + 14) = 66;
    *(_WORD *)(v11 + 14) = 66;
    *(_BYTE *)(v11 + 10) = 7;
    *(_BYTE *)(v11 + 11) = 3;
    *(_WORD *)(v11 + 12) = 0;
    v26 = 6 * v45;
    *(_WORD *)(a10 + 4) = 6 * v45 + v47 + 6;
    v27 = *(_WORD *)a4 + *(_WORD *)(v12 + 4) - 2;
    *(_WORD *)(a6 + 12) = v27;
    *(_WORD *)(a10 + 12) = v27 - 5 * v48 - *(_WORD *)(a10 + 4) + 5;
    if ( *(_BYTE *)(v50 + 1) )
    {
      *(_WORD *)(v11 + 16) = v26 + 15;
      v28 = *(_WORD *)(a10 + 4) + *(_WORD *)(a10 + 12) - 2;
      *(_WORD *)(v13 + 16) = v28;
      result = a11;
      *(_WORD *)(a11 + 16) = v28 - 6 * v45 / 2;
      *(_DWORD *)(a11 + 4) = 20870;
      v30 = *(_WORD *)(v11 + 16) + 6;
      *(_WORD *)(a9 + 4) = v30;
      *(_WORD *)(a7 + 12) = v30 + 18;
    }
    else
    {
      v31 = v26 + v47 - 13;
      if ( *(_BYTE *)v50 )
      {
        v33 = *(_WORD *)a4 + *(_WORD *)(v12 + 4) - 2;
        *(_WORD *)(v13 + 16) = v33;
        v34 = v33 - v31 - 21;
        *(_WORD *)(a9 + 4) = v34;
        v34 -= 8;
        *(_WORD *)(v11 + 16) = v34;
        v35 = v34 - v31 - 23;
        *(_WORD *)(a7 + 12) = v35;
        *(_WORD *)(a6 + 12) = v35 - 29;
        *(_WORD *)(a11 + 16) = *(_WORD *)(v13 + 16) - 39;
        result = a11;
      }
      else
      {
        *(_WORD *)(v11 + 16) = v26 + 40;
        v32 = *(_WORD *)(a6 + 12) - 5 * v48 - 2;
        *(_WORD *)(v13 + 16) = v32;
        *(_WORD *)(a11 + 16) = v32 - 6 * v45 / 2 + 12;
        *(_WORD *)(a9 + 4) = *(_WORD *)(v11 + 16) + 7;
        *(_WORD *)(a7 + 12) = *(_WORD *)(v11 + 16) - v31 - 20;
        result = a11;
      }
    }
  }
  else
  {
    *(_WORD *)(v11 + 12) = 0;
    *(_BYTE *)(v11 + 10) = 6;
    *(_BYTE *)(v11 + 11) = 2;
    *(_WORD *)(v11 + 14) = 61;
    *(_WORD *)(v13 + 14) = 61;
    *(_WORD *)(v13 + 12) = 0;
    v49 = v47 + 4 * v45 + v45;
    *(_BYTE *)(v13 + 10) = 6;
    *(_BYTE *)(v13 + 11) = 2;
    *(_WORD *)(a10 + 4) = v49 + 5;
    v36 = *v25;
    LOWORD(v36) = v36 + 4;
    *(_WORD *)(a6 + 12) = v36;
    v37 = v36 + 5 * v48 - 8;
    *(_WORD *)(a10 + 12) = v37;
    if ( *(_BYTE *)(v50 + 1) )
    {
      v38 = v37 + *(_WORD *)(a10 + 4) - 2;
      *(_WORD *)(v13 + 16) = v38;
      *(_WORD *)(a11 + 16) = v38;
      *(_DWORD *)(a11 + 4) = 20870;
      v39 = *(_WORD *)(a10 + 4) + *(_WORD *)(a10 + 12) + 4;
      *(_WORD *)(a7 + 12) = v39;
      *(_WORD *)(v11 + 16) = v39 + 95;
      *(_WORD *)(a9 + 4) = *(_WORD *)(a7 + 12);
      result = a11;
    }
    else
    {
      v40 = (signed __int16)(v49 - 11);
      if ( *(_BYTE *)v50 )
      {
        v44 = v40 + *v25 + 1;
        *(_WORD *)(v13 + 16) = v44;
        *(_WORD *)(a9 + 4) = v44 + 8;
        *(_WORD *)(a11 + 16) = *(_WORD *)(v13 + 16) + 23;
        *(_WORD *)(v11 + 16) = v40 + *(_WORD *)(a9 + 4) + 38;
        *(_WORD *)(a7 + 12) = *(_WORD *)(a9 + 4) + 2;
        *(_WORD *)(a6 + 12) = *(_WORD *)(v11 + 16) + 60;
        result = a11;
      }
      else
      {
        v41 = *v25;
        LOWORD(v41) = v41 + 4;
        *(_WORD *)(a6 + 12) = v41;
        v42 = 5 * v48 + v41 + v40 - 6;
        *(_WORD *)(v13 + 16) = v42;
        *(_WORD *)(a11 + 16) = v42 + 11;
        v43 = *(_WORD *)(v13 + 16) + 6;
        *(_WORD *)(a7 + 12) = v43;
        *(_WORD *)(a9 + 4) = v43 + 2;
        *(_WORD *)(v11 + 16) = *(_WORD *)(a7 + 12) + 95;
        result = a11;
      }
    }
  }
  *(_DWORD *)a7 = 107;
  *(_DWORD *)(a7 + 4) = *(_DWORD *)(v12 + 12);
  *(_WORD *)(a7 + 14) = v46;
  *(_WORD *)(a7 + 8) = 0;
  *(_DWORD *)a9 = 63;
  *(_WORD *)(a9 + 6) = v46 - 12;
  if ( !*(_BYTE *)(v50 + 1) )
    *(_DWORD *)(result + 4) = 20870;
  *(_WORD *)(result + 12) = 0;
  *(_DWORD *)result = 89;
  *(_WORD *)(result + 8) = 10;
  *(_BYTE *)(result + 10) = 3;
  *(_WORD *)(result + 18) = v46;
  *(_BYTE *)(result + 11) = 1;
  return result;
}
// 1005DA40: using guessed type __int16 word_1005DA40;

//----- (10006450) --------------------------------------------------------
char __usercall sub_10006450@<al>(int a1@<ecx>, int a2@<edi>, int a3, int a4)
{
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // ecx@1
  char v7; // dl@1
  bool v8; // al@3
  bool v9; // bl@5
  bool v10; // al@5
  signed int v11; // ecx@5
  char v12; // cl@15
  bool v13; // zf@15
  __int16 v14; // si@23
  char v15; // dl@23
  bool v16; // al@37
  char result; // al@48
  char v18; // [sp-Ch] [bp-B8h]@3
  bool v19; // [sp+Eh] [bp-9Eh]@3
  bool v20; // [sp+Eh] [bp-9Eh]@19
  char v21; // [sp+Fh] [bp-9Dh]@29
  int v22; // [sp+10h] [bp-9Ch]@5
  int v23; // [sp+14h] [bp-98h]@1
  char v24; // [sp+1Bh] [bp-91h]@15
  int v25; // [sp+1Ch] [bp-90h]@5
  int v26; // [sp+20h] [bp-8Ch]@13
  float v27; // [sp+24h] [bp-88h]@21
  int v28; // [sp+28h] [bp-84h]@1
  int v29; // [sp+2Ch] [bp-80h]@23
  int v30; // [sp+30h] [bp-7Ch]@1
  char v31; // [sp+34h] [bp-78h]@1
  char v32; // [sp+3Ch] [bp-70h]@1
  __int16 v33; // [sp+4Ch] [bp-60h]@24
  char v34; // [sp+50h] [bp-5Ch]@1
  char v35; // [sp+64h] [bp-48h]@1
  __int16 v36; // [sp+70h] [bp-3Ch]@23
  char v37; // [sp+74h] [bp-38h]@1
  char v38; // [sp+84h] [bp-28h]@1
  char v39; // [sp+94h] [bp-18h]@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 16);
  v23 = *(_DWORD *)(a1 + 16);
  sub_10005ED0((int)&v32, a3, a2, a4, a1, (int)&v35, (int)&v37, (int)&v34, (int)&v31, (int)&v38, (int)&v39);
  v6 = *(_DWORD *)v4;
  v7 = *(_BYTE *)(a3 + 16) & 0x3F;
  v30 = *(_DWORD *)(v4 + 4);
  v28 = v6;
  if ( v7 == 44 )
  {
    if ( *(_BYTE *)(v4 + 9) == 1 )
    {
      v19 = sub_100123A0(0);
      v8 = sub_10012400(0);
      v18 = 0;
    }
    else
    {
      v19 = sub_100123A0(1);
      v8 = sub_10012400(1);
      v18 = 1;
    }
    v9 = v8;
    v10 = sub_10012330(v18);
    v25 = 1482 - (*(_BYTE *)(v4 + 9) != 0);
    LOWORD(v11) = 6;
    v22 = 6;
    if ( v9 )
    {
      v5 = v23;
      LOWORD(v11) = 6734;
      v22 = 6734;
      goto LABEL_12;
    }
    if ( *(_BYTE *)(v23 + 2) && v10 )
    {
      v11 = 6091;
    }
    else
    {
      if ( !*(_BYTE *)(v23 + 3) || !v19 )
        goto LABEL_11;
      v11 = 5772;
    }
    v22 = v11;
LABEL_11:
    v5 = v23;
    goto LABEL_12;
  }
  if ( *(_BYTE *)(v4 + 9) == 1 )
  {
    v25 = 4689;
    sub_10015A60(3, (bool *)&v21);
  }
  else
  {
    v25 = 4692;
    sub_10015A60(4, (bool *)&v21);
  }
  v11 = v21 != 1 ? 6 : 3744;
  v22 = v21 != 1 ? 6 : 3744;
LABEL_12:
  if ( !*(_BYTE *)(v4 + 10) || (v26 = 53, (_WORD)v11 == 3744) )
    v26 = 54;
  v12 = *(_BYTE *)(a2 + 3);
  *(_BYTE *)(a2 + 3) = 0;
  v13 = *(_BYTE *)(v4 + 10) == 0;
  v24 = v12;
  if ( v13 && *(_BYTE *)(v5 + 7) == *(_BYTE *)(v4 + 9) )
    *(_DWORD *)(v5 + 8) = 0;
  if ( *(_BYTE *)(v4 + 11) == 1 )
  {
    v20 = (unsigned int)sub_10031910() < *(_DWORD *)(v5 + 8);
    if ( v20 && *(_BYTE *)(v5 + 7) == *(_BYTE *)(v4 + 9) )
    {
      v23 = *(_BYTE *)(v5 + 6);
      v27 = (double)v23 / 31.0;
      if ( *(_BYTE *)(v5 + 1) || *(_BYTE *)v5 != 1 )
      {
        v25 = 6926;
        sub_1000E4B0(a2, (int)&unk_1006F51C, &v39, (int)&v27);
      }
      else
      {
        v14 = v36;
        v15 = *(_BYTE *)(a3 + 16) & 0x3F;
        v29 = 6917;
        if ( v15 == 44 )
          v36 = v33;
        else
          v36 = 4;
        sub_1000E4B0(a2, (int)&unk_1006F51C, &v35, (int)&v29);
        v36 = v14;
        sub_1000E4B0(a2, (int)&unk_1006F51C, &v39, (int)&v27);
      }
    }
    else
    {
      sub_1000E4B0(a2, (int)&unk_1006F51C, &v31, (int)&v26);
      v16 = *(_BYTE *)(v4 + 10) && *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) != -128;
      *(_BYTE *)(a2 + 3) = v16;
      sub_1000E4B0(a2, (int)&unk_1006F51C, &v32, (int)&v30);
      if ( *(_BYTE *)(v5 + 1) && *(_BYTE *)(v4 + 10) )
        sub_1000E4B0(a2, (int)&unk_1006F51C, &v38, 0);
    }
    *(_BYTE *)(a2 + 3) = 0;
    sub_1000E4B0(a2, (int)&unk_1006F51C, &v34, (int)&v28);
    if ( (_WORD)v22 != 6
      && (*(_BYTE *)(v5 + 1) || (*(_BYTE *)(a3 + 16) & 0x3F) != 44 && !v20 || (*(_BYTE *)(a3 + 16) & 0x3F) == 44) )
    {
      sub_1000E4B0(a2, (int)&unk_1006F51C, &v37, (int)&v22);
    }
  }
  sub_1000E4B0(a2, (int)&unk_1006F51C, &v35, (int)&v25);
  result = v24;
  *(_BYTE *)(a2 + 3) = v24;
  return result;
}

//----- (100067E0) --------------------------------------------------------
char __cdecl sub_100067E0(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // eax@1
  int v6; // edx@2
  int v7; // edi@5
  char v8; // al@5
  __int16 v9; // ax@8
  void *v10; // ecx@8
  __int16 v11; // dx@13
  _BYTE *v12; // edi@18
  char v13; // cl@18
  bool v14; // sf@18
  void *v15; // ecx@29
  int v16; // eax@40
  int v17; // eax@40
  int v18; // ST30_4@40
  unsigned __int8 v19; // ST30_1@43
  int v20; // eax@43
  char v22; // [sp+13h] [bp-85h]@1
  signed int v23; // [sp+14h] [bp-84h]@0
  int v24; // [sp+1Ch] [bp-7Ch]@0
  int v25; // [sp+20h] [bp-78h]@6
  char v26; // [sp+28h] [bp-70h]@6
  char v27; // [sp+3Ch] [bp-5Ch]@6
  char v28; // [sp+50h] [bp-48h]@6
  char v29; // [sp+60h] [bp-38h]@6
  char v30; // [sp+70h] [bp-28h]@6
  char v31; // [sp+80h] [bp-18h]@6

  v5 = a3;
  v22 = 1;
  if ( *(_WORD *)a5 == -32703 )
  {
    v6 = v24;
  }
  else
  {
    v6 = *(_DWORD *)(a4 + 16);
    v24 = *(_DWORD *)(a4 + 16);
  }
  switch ( *(_WORD *)a5 )
  {
    case 0x8041:
      v7 = sub_10002820(a1, 12);
      *(_DWORD *)(a4 + 16) = v7;
      *(_BYTE *)(v7 + 6) = 0;
      *(_DWORD *)(v7 + 8) = 0;
      *(_BYTE *)(v7 + 5) = 0;
      sub_10032360(71, (_BYTE *)v7);
      sub_10032360(74, (_BYTE *)(v7 + 1));
      sub_10032360(1, (_BYTE *)(v7 + 3));
      sub_10032360(2, (_BYTE *)(v7 + 4));
      sub_10032360(51, (_BYTE *)(v7 + 2));
      v8 = sub_10005DA0(a2, a4);
      sub_100140C0(v8, (void *)(v7 + 6));
      break;
    case 0x8040:
      sub_10005ED0((int)&v26, a2, a1, a3, a4, (int)&v29, (int)&v30, (int)&v27, (int)&v25, (int)&v28, (int)&v31);
      v22 = sub_1000E4B0(a1, a5, &v26, a4 + 4);
      break;
    case 0x8048:
      if ( *(_BYTE *)(a4 + 11) == 1 )
      {
        *(_DWORD *)(v6 + 8) = 0;
        LOBYTE(v23) = sub_10005DA0(a2, a4);
        v9 = *(_WORD *)(a2 + 16) & 0x3F;
        v10 = (void *)*(_WORD *)(a5 + 10);
        if ( (unsigned __int16)v10 == (v9 != 44 ? 27 : 2) || *(_WORD *)(a5 + 10) == 82 )
        {
          if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != -128 )
          {
            sub_10005ED0((int)&v26, a2, a1, a3, a4, (int)&v29, (int)&v30, (int)&v27, (int)&v25, (int)&v28, (int)&v31);
            sub_1000E4B0(a1, a5, &v26, a4 + 4);
          }
          if ( !*(_BYTE *)(a5 + 16) || sub_1000E880(v10) == 1 )
          {
            v16 = *(_DWORD *)a4;
            *(_DWORD *)a4 = *(_DWORD *)(a4 + 4);
            *(_DWORD *)(a4 + 4) = v16;
            v17 = sub_10031910();
            v18 = *(_DWORD *)a4;
            *(_DWORD *)(a4 + 12) = v17;
            sub_10012070(v23, 1, v18);
            sub_10012070(v23, 0, *(_DWORD *)(a4 + 4));
          }
          goto LABEL_46;
        }
        if ( (unsigned __int16)v10 == (v9 != 44 ? 61 : 66)
          || (unsigned __int16)v10 == (v9 != 44 ? 62 : 67)
          || (unsigned __int16)v10 == (v9 != 44 ? 34 : 37)
          || (v11 = *(_WORD *)(a5 + 10), v25 = *(_WORD *)(a5 + 10), v11 == 0x2000)
          || v11 == 73
          || v11 == 33
          || v11 == 32 )
        {
          sub_10005ED0((int)&v26, a2, a1, a3, a4, (int)&v29, (int)&v30, (int)&v27, (int)&v25, (int)&v28, (int)&v31);
          v22 = sub_1000E4B0(a1, a5, &v26, a4 + 4);
          if ( v22 == 3 )
          {
            if ( !*(_BYTE *)(a5 + 16) || sub_1000E880(v15) == 1 )
              sub_10012070(v23, 0, *(_DWORD *)(a4 + 4));
            v22 = 2;
          }
          if ( *(_BYTE *)(v24 + 1) )
            sub_1000E4B0(a1, (int)&unk_1006F51C, &v28, 0);
        }
        else
        {
          if ( (unsigned __int16)v10 == (v9 != 44) + 58 )
          {
            v12 = (_BYTE *)(v24 + 6);
            sub_100140C0(v23, (void *)(v24 + 6));
            v13 = *(_BYTE *)(a5 + 8);
            v14 = (char)(v13 + *(_BYTE *)(v24 + 6)) < 0;
            *v12 += v13;
            if ( v14 )
            {
              *v12 = 0;
            }
            else if ( *(_BYTE *)(v24 + 6) > 0x1Fu )
            {
              *v12 = 31;
            }
            *(_BYTE *)(v24 + 5) = 1;
            *(_DWORD *)(v24 + 8) = sub_10031910() + 2000;
            *(_BYTE *)(v24 + 7) = *(_BYTE *)(a4 + 9);
            goto LABEL_46;
          }
          if ( v9 == 44 )
          {
            if ( (_WORD)v25 == 42 )
            {
              sub_10012530(v23);
              goto LABEL_46;
            }
          }
          else if ( (_WORD)v25 == 41 )
          {
            sub_10015AF0(v23);
            goto LABEL_46;
          }
        }
      }
      else
      {
        v22 = 2;
        sub_10005EA0(a3, a2, a1);
      }
      break;
    case 0x8022:
    case 0x8078:
      if ( *(_BYTE *)(v6 + 5) )
      {
        v19 = *(_BYTE *)(v6 + 6);
        LOBYTE(v20) = sub_10005DA0(a2, a4);
        sub_10014100(v20, v19);
        v5 = a3;
        *(_BYTE *)(v24 + 5) = 0;
      }
      sub_10006450(a4, a1, a2, v5);
      if ( *(_BYTE *)(a4 + 11) != 1 )
        sub_10005EA0(a3, a2, a1);
LABEL_46:
      v22 = 2;
      break;
    default:
      return v22;
  }
  return v22;
}

//----- (10006CB0) --------------------------------------------------------
void *__usercall sub_10006CB0@<eax>(int a1@<ecx>, int a2@<esi>, unsigned int *a3)
{
  unsigned int v3; // eax@1
  int v4; // edi@1
  unsigned int v5; // ebx@2
  void *result; // eax@2
  char v7; // [sp+4h] [bp-44h]@2
  char v8[32]; // [sp+24h] [bp-24h]@2

  v3 = *a3;
  v4 = 3 - ((*(_BYTE *)(a1 + 8) & 0x3F) != 44);
  if ( *a3 == 0xFFFF )
  {
    result = memset((void *)a2, 95, v4 + 4);
    *(_BYTE *)(a2 + 3) = 46;
    *(_BYTE *)(a2 + v4 + 4) = 0;
  }
  else
  {
    v5 = v3 % 0x3E8;
    sprintf(&v7, "%0*i", 3, v3 / 0x3E8);
    sprintf(v8, "%03i", v5);
    v8[v4] = 0;
    strncat(&v7, ".", 0x1Bu);
    strncat(&v7, v8, 0x1Au);
    result = strncpy((char *)a2, &v7, 0x1Eu);
  }
  return result;
}
// 10006CB0: using guessed type char var_24[32];

//----- (10006D80) --------------------------------------------------------
int __usercall sub_10006D80@<eax>(unsigned int a1@<eax>, int a2@<esi>, char a3, int a4)
{
  int v4; // edx@1
  char *v5; // ecx@1
  int result; // eax@1

  v4 = byte_101EFA91[20 * ((a1 >> 10) & 0xF)];
  v5 = (char *)&unk_101EFA80 + 20 * ((a1 >> 10) & 0xF);
  result = a2 * v4 + (a2 - 1) * *(_WORD *)(dword_101EFA84[5 * ((a1 >> 10) & 0xF)] + 28);
  if ( a4 > 0 )
  {
    if ( a3 & 0x80 )
      result += v5[15] - v4;
  }
  return result;
}
// 101EFA84: using guessed type int dword_101EFA84[];

//----- (10006DD0) --------------------------------------------------------
signed int __usercall sub_10006DD0@<eax>(int a1@<eax>, void *a2@<ecx>, unsigned int *a3, int a4)
{
  unsigned int *v4; // ebp@1
  signed int v5; // edi@1
  unsigned int v6; // ebx@4
  signed int v7; // esi@4
  unsigned int v8; // edx@6
  int v9; // eax@9
  int v10; // edx@9
  unsigned int v11; // edx@10
  int v12; // ebx@17
  signed int result; // eax@17
  signed int v14; // [sp+10h] [bp-4h]@2
  signed int v15; // [sp+18h] [bp+4h]@2

  v4 = a3;
  v5 = (signed int)a2;
  LOWORD(a2) = *(_WORD *)(a1 + 8) & 0x3F;
  if ( (_WORD)a2 == 45 )
  {
    v15 = 108;
    v14 = 117;
  }
  else
  {
    v15 = 118;
    v14 = 136;
  }
  v6 = *v4 / 0x3E8;
  v7 = *v4 % 0x3E8;
  if ( v5 )
  {
    if ( (_WORD)a2 == 45 )
    {
      v8 = (signed int)((unsigned __int64)(1374389535i64 * (50 * v5 + v7)) >> 32) >> 4;
      v7 = 50 * (v8 + (v8 >> 31));
    }
    else if ( sub_10013FD0(a2) == 1 )
    {
      v7 = 25 * ((25 * v5 + v7) / 25);
    }
    else
    {
      v9 = v5 % 4 + v7 % 25 / 5;
      v10 = 0;
      if ( v5 >= 0 )
      {
        v11 = v9 < 4 ? 0 : 5;
      }
      else
      {
        LOBYTE(v10) = v9 >= 0;
        v11 = (v10 - 1) & 0xFFFFFFFB;
      }
      v7 = 5
         * (((signed int)((unsigned __int64)(1717986919i64 * (signed int)(v5 % 4 + v11 + 4 * (v5 % 4) + v7)) >> 32) >> 1)
          + 5 * (v5 / 4)
          + ((unsigned int)((unsigned __int64)(1717986919i64 * (signed int)(v5 % 4 + v11 + 4 * (v5 % 4) + v7)) >> 32) >> 31));
    }
    if ( v7 >= 0 )
    {
      if ( v7 >= 1000 )
        v7 -= 1000;
    }
    else
    {
      v7 += 1000;
    }
  }
  v12 = a4 + v6;
  result = v14;
  if ( v12 <= v14 )
  {
    if ( v12 < v15 )
      v12 = v14;
    *v4 = v7 + 1000 * v12;
  }
  else
  {
    *v4 = v7 + 1000 * v15;
  }
  return result;
}

//----- (10006F50) --------------------------------------------------------
int __usercall sub_10006F50@<eax>(int a1@<ebx>, int a2, unsigned int *a3)
{
  unsigned int v3; // esi@1
  char v4; // cl@1
  unsigned int v5; // edi@2
  unsigned int v6; // ecx@2
  unsigned int v7; // edx@2
  unsigned int v8; // eax@2
  int result; // eax@10
  float v10; // ST04_4@15
  float v11; // ST00_4@15
  double v12; // st7@15
  unsigned int v13; // ecx@15
  signed int v14; // edx@18

  v3 = *a3;
  v4 = *(_BYTE *)(a1 + 8) & 0x3F;
  if ( v4 == 45 )
  {
    v5 = 50;
    v6 = 117950;
    v7 = 108000;
    v8 = 117000;
  }
  else
  {
    if ( sub_10013FD0((void *)v4) == 1 )
    {
      v5 = 25;
      v6 = 136975;
    }
    else
    {
      v5 = 5;
      v6 = 136990;
    }
    v8 = 1000 * (v6 / 0x3E8);
    v7 = 118000;
  }
  if ( *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) == 2 )
  {
    if ( v3 < v7 || v3 > v6 )
      return -1;
    goto LABEL_13;
  }
  if ( v3 <= v6 )
  {
LABEL_13:
    if ( v3 < v7 )
      v3 = v7;
    goto LABEL_15;
  }
  v3 = v8;
LABEL_15:
  v10 = (double)v5;
  v11 = (double)v3;
  v12 = sub_10037920(v11, v10);
  v13 = (signed __int64)v12;
  if ( (*(_BYTE *)(a1 + 8) & 0x3F) != 44 || v5 != 5 || v13 % 0x19 / 5 != 4 )
  {
    result = (signed __int64)v12;
  }
  else
  {
    v14 = *a3 % 0xA != 0 ? -1 : 1;
    result = v14 + v13 + 4 * v14;
  }
  return result;
}

//----- (100070A0) --------------------------------------------------------
char __usercall sub_100070A0@<al>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // ax@1

  v3 = *(_WORD *)(a3 + 12);
  *(_WORD *)(a2 + 438) = *(_WORD *)a1;
  *(_WORD *)(a2 + 436) = *(_WORD *)(a1 + 2);
  if ( !*(_WORD *)(a3 + 12) )
    v3 = sub_10006D80(*(_DWORD *)(a3 + 4), *(_BYTE *)(a3 + 10), *(_WORD *)(a3 + 8), *(_BYTE *)(a3 + 11));
  return sub_10009CE0(
           a2,
           (char *)(*(_DWORD *)(a2 + 56) + 69),
           (const char *)&unk_1005E69C,
           v3,
           0,
           *(_DWORD *)(a3 + 4),
           *(_WORD *)(a3 + 8));
}

//----- (10007100) --------------------------------------------------------
char __usercall sub_10007100@<al>(int a1@<ebx>, int a2@<edi>, int a3, unsigned int *a4)
{
  __int16 v4; // ax@1
  char v6; // [sp+8h] [bp-24h]@1

  sub_10006CB0(a2, (int)&v6, a4);
  *(_WORD *)(a1 + 438) = *(_WORD *)a3;
  *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
  v4 = *(_WORD *)(a2 + 12);
  if ( !v4 )
    v4 = sub_10006D80(*(_DWORD *)(a2 + 4), *(_BYTE *)(a2 + 10), *(_WORD *)(a2 + 8), *(_BYTE *)(a2 + 11));
  return sub_10009CE0(a1, &v6, (const char *)&unk_1005E69C, v4, 0, *(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8));
}

//----- (100071A0) --------------------------------------------------------
char __usercall sub_100071A0@<al>(unsigned int *a1@<edx>, int a2@<ecx>, int a3@<edi>)
{
  size_t v3; // ebp@1
  char *v4; // eax@1
  int v5; // esi@1
  char v6; // dl@2
  char v7; // bl@3
  char *v8; // eax@3
  char v9; // dl@3
  char v10; // cl@4

  v3 = 3 - ((*(_BYTE *)(a2 + 8) & 0x3F) != 44);
  sub_10006CB0(a2, *(_DWORD *)(a3 + 56) + 69, a1);
  v4 = (char *)(*(_DWORD *)(a3 + 56) + 69);
  v5 = *(_DWORD *)(a3 + 56) + 70;
  do
    v6 = *v4++;
  while ( v6 );
  v7 = (_BYTE)v4 - v5;
  v8 = strchr((const char *)(*(_DWORD *)(a3 + 56) + 69), 46);
  v9 = (_BYTE)v8 + 1;
  do
    v10 = *v8++;
  while ( v10 );
  memset((void *)((char)(v7 - ((_BYTE)v8 - v9)) + *(_DWORD *)(a3 + 56) + 70), 48, v3);
  *(_WORD *)(*(_DWORD *)(a3 + 56) + 240) = 0;
  return 4;
}

//----- (10007230) --------------------------------------------------------
int __usercall sub_10007230@<eax>(int a1@<eax>, void *a2@<ecx>, int a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  double v6; // st7@1
  int v7; // eax@1
  unsigned __int8 v8; // bl@1
  char *v9; // eax@3
  char v10; // dl@4
  double v11; // st7@10
  int v12; // eax@10
  int v13; // esi@10
  int v14; // edx@11
  int v15; // eax@11
  int result; // eax@15
  int v17; // [sp+18h] [bp-4h]@1

  v4 = a1;
  v5 = (unsigned __int8)sub_10013FD0(a2);
  v6 = atof((const char *)(*(_DWORD *)(v4 + 56) + 69));
  v7 = sub_100378F0(v6 * 1000.0);
  v8 = *(_BYTE *)(a4 + 14);
  v17 = v7;
  if ( v8 != 46 || *(_BYTE *)(a3 + 11) <= 0 )
  {
    if ( (*(_BYTE *)(a3 + 8) & 0x3F) == 45 && strchr((&off_1005E670)[4 * *(_WORD *)(*(_DWORD *)(v4 + 56) + 240)], v8)
      || (*(_BYTE *)(a3 + 8) & 0x3F) == 44
      && strchr((**(&off_1005E668 + v5))[*(_WORD *)(*(_DWORD *)(v4 + 56) + 240)], v8) )
    {
      *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = v8;
      v11 = atof((const char *)(*(_DWORD *)(v4 + 56) + 69));
      a4 = sub_100378F0(v11 * 1000.0);
      v12 = sub_10006F50(a3, v4, (unsigned int *)&a4);
      v13 = *(_DWORD *)(v4 + 56) + 69;
      a4 = v12;
      if ( v12 == -1 )
      {
        sub_10006CB0(a3, v13, (unsigned int *)&v17);
      }
      else
      {
        sub_10006CB0(a3, v13, (unsigned int *)&a4);
        ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
        v14 = *(_DWORD *)(v4 + 56);
        v15 = *(_BYTE *)(a3 + 10) - 1;
        if ( *(_WORD *)(v14 + 240) < v15 )
          LOWORD(v15) = *(_WORD *)(v14 + 240);
        *(_WORD *)(v14 + 240) = (char)v15;
      }
    }
  }
  else
  {
    v9 = (char *)(*(_DWORD *)(v4 + 56) + 69);
    do
      v10 = *v9++;
    while ( v10 );
    *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)((_BYTE)v9
                                                  - (*(_BYTE *)(v4 + 56)
                                                   + 70)
                                                  - strlen(strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46)))
                                           + 1;
  }
  result = *(_DWORD *)(v4 + 56);
  if ( *(_BYTE *)(*(_WORD *)(result + 240) + result + 69) == 46 )
    ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
  return result;
}
// 1005E668: using guessed type char *(*off_1005E668)[14];

//----- (100073F0) --------------------------------------------------------
char __cdecl sub_100073F0(int a1, int a2, __int64 a3, int a4)
{
  __int16 v4; // cx@2
  unsigned int v5; // edi@3
  int v6; // eax@3
  char result; // al@3
  unsigned __int16 v8; // cx@6
  unsigned __int16 v9; // ax@6
  int v10; // ecx@12
  int v11; // eax@12
  int v12; // eax@14
  void *v13; // ecx@17
  double v14; // st7@28
  unsigned __int16 v15; // ax@36
  void *v16; // ecx@39
  char v17; // [sp+1Bh] [bp-1h]@1

  v17 = 1;
  switch ( *(_WORD *)a4 )
  {
    case 0x8040:
      v4 = *(_WORD *)(a2 + 12);
      if ( v4 )
      {
        sub_10009C10(a1 + 276, *(_DWORD *)a3, *(_DWORD *)(a2 + 4), v4);
        result = 2;
      }
      else
      {
        v5 = *(_DWORD *)(a2 + 4);
        v6 = sub_10006D80(*(_DWORD *)(a2 + 4), *(_BYTE *)(a2 + 10), *(_WORD *)(a2 + 8), *(_BYTE *)(a2 + 11));
        sub_10009C10(a1 + 276, *(_DWORD *)a3, v5, v6);
        result = 2;
      }
      return result;
    case 0x8048:
      if ( ~((unsigned int)*(_WORD *)(a2 + 8) >> 10) & 1 )
      {
        v8 = *(_WORD *)(a2 + 14);
        v9 = *(_WORD *)(a4 + 10);
        if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 )
        {
          if ( v9 == v8 )
          {
            sub_10006DD0(a2, (void *)*(_BYTE *)(a4 + 8), (unsigned int *)HIDWORD(a3), 0);
            v17 = 3;
            goto LABEL_44;
          }
          if ( v9 == v8 + 1 )
          {
            sub_10006DD0(a2, 0, (unsigned int *)HIDWORD(a3), *(_BYTE *)(a4 + 8));
            v17 = 3;
            goto LABEL_44;
          }
          if ( v9 == 33 )
          {
            sub_1000A780(*(_DWORD *)HIDWORD(a3));
            return 1;
          }
          if ( v9 != 0x2000 )
            return v17;
          v15 = *(_WORD *)(a4 + 14);
          if ( (v15 < 0x30u || v15 > 0x39u) && v15 != 46 )
            return v17;
          v17 = sub_100071A0((unsigned int *)HIDWORD(a3), a2, a1);
          sub_10007230(a1, v16, a2, a4);
          if ( v17 != 4 )
          {
            if ( v17 != 3 )
              return v17;
            goto LABEL_44;
          }
        }
        else
        {
          v17 = 4;
          if ( v9 == v8 )
          {
            sub_10006DD0(a2, (void *)*(_BYTE *)(a4 + 8), (unsigned int *)HIDWORD(a3), 0);
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = -128;
            v17 = 3;
LABEL_44:
            sub_10007100(a1, a2, a3, (unsigned int *)HIDWORD(a3));
            return v17;
          }
          if ( v9 == v8 + 1 )
          {
            sub_10006DD0(a2, 0, (unsigned int *)HIDWORD(a3), *(_BYTE *)(a4 + 8));
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = -128;
            v17 = 3;
            goto LABEL_44;
          }
          if ( v9 == 73 )
          {
            v10 = --*(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = (char)(v10 <= 0 ? 0 : v10);
            v11 = *(_BYTE *)(a2 + 10) - 1;
            if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) < v11 )
              LOWORD(v11) = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = (char)v11;
            v12 = *(_DWORD *)(a1 + 56);
            if ( *(_BYTE *)(*(_WORD *)(v12 + 240) + v12 + 69) == 46 )
            {
              --*(_WORD *)(v12 + 240);
              sub_100070A0(a3, a1, a2);
              return 4;
            }
            goto LABEL_40;
          }
          if ( v9 == 0x2000 )
          {
            if ( (v13 = (void *)*(_WORD *)(a4 + 14), (unsigned __int16)v13 >= 0x30u) && (unsigned __int16)v13 <= 0x39u
              || (_WORD)v13 == 46 )
            {
              sub_10007230(a1, v13, a2, a4);
              sub_100070A0(a3, a1, a2);
              return 4;
            }
          }
          if ( v9 == 33 || v9 == ((*(_WORD *)(a2 + 8) & 0x3F) != 44 ? 27 : 2) || v9 == 82 )
          {
            v14 = atof((const char *)(*(_DWORD *)(a1 + 56) + 69));
            *(_DWORD *)HIDWORD(a3) = sub_100378F0(v14 * 1000.0);
LABEL_27:
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = -128;
            v17 = 3;
            goto LABEL_44;
          }
          if ( v9 == 37 || v9 == 34 || v9 == 32 )
            goto LABEL_27;
        }
LABEL_40:
        sub_100070A0(a3, a1, a2);
        return v17;
      }
      if ( *(_WORD *)(a4 + 10) != 33 )
        return v17;
      sub_1000A780(*(_DWORD *)HIDWORD(a3));
      return 1;
    case 0x8022:
    case 0x8078:
      if ( !*(_BYTE *)(a1 + 3) || *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 )
      {
        sub_10007100(a1, a2, a3, (unsigned int *)HIDWORD(a3));
        return 2;
      }
      sub_100070A0(a3, a1, a2);
      return 2;
    default:
      return v17;
  }
}

//----- (10007870) --------------------------------------------------------
int __usercall sub_10007870@<eax>(int a1@<eax>, int a2@<ecx>, unsigned __int8 a3)
{
  unsigned __int8 v3; // bl@1
  int v4; // edi@1
  int v5; // esi@1

  v3 = 0;
  v4 = a1;
  v5 = a2;
  if ( a3 )
  {
    do
    {
      sub_10035650(
        v5 + 392,
        v3,
        v3,
        *(_WORD *)(*(_DWORD *)(v5 + 56) + 32) - 2 * v3,
        *(_WORD *)(*(_DWORD *)(v5 + 56) + 34) - 2 * v3,
        0);
      ++v3;
    }
    while ( v3 < a3 );
  }
  *(_WORD *)(v5 + 428) = word_100FD810[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 430) = word_100FD810[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 440) = word_100FD810[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 442) = word_100FD810[*(_BYTE *)(v4 + 4) & 0x1F];
  return sub_10035650(
           v5 + 392,
           a3,
           a3,
           *(_WORD *)(*(_DWORD *)(v5 + 56) + 32) - 2 * a3,
           *(_WORD *)(*(_DWORD *)(v5 + 56) + 34) - 2 * a3,
           1);
}
// 100FD810: using guessed type __int16 word_100FD810[];

//----- (10007950) --------------------------------------------------------
char __cdecl sub_10007950(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@1
  __int16 v6; // bx@5
  int v7; // ecx@5
  int v8; // eax@8
  signed int v9; // ebp@8
  int v10; // eax@10
  int v11; // eax@15
  int v12; // eax@15
  int v13; // eax@15
  int v14; // eax@17
  char v15; // al@19
  bool v16; // zf@19
  int v17; // eax@23
  int v18; // eax@28
  int v19; // esi@28

  result = 1;
  if ( *a5 == 32802 || *a5 == 32888 )
  {
    if ( *(_DWORD *)(a1 + 64) == 9 )
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 248) = 1;
    v6 = word_100FD810[(unsigned __int8)sub_10014000(*(_BYTE *)(a2 + 4) & 0x1F)];
    v7 = *(_BYTE *)(a2 + 4) & 0xE0;
    if ( !(*(_BYTE *)(a2 + 4) & 0xE0) )
    {
      v17 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 428) = v6;
      *(_WORD *)(a1 + 430) = v6;
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      if ( !*(_BYTE *)(v17 + 25)
        && (*(_WORD *)(v17 + 40) || *(_WORD *)(v17 + 42) || *(_WORD *)(v17 + 44) || *(_WORD *)(v17 + 46)) )
      {
        sub_10035650(a1 + 392, 0, 0, *(_WORD *)(v17 + 32), *(_WORD *)(v17 + 42), 1);
        sub_10035650(
          a1 + 392,
          0,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 42),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 40),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 46),
          1);
        v18 = *(_DWORD *)(a1 + 56);
        sub_10035650(
          a1 + 392,
          *(_WORD *)(v18 + 44) + *(_WORD *)(v18 + 40),
          *(_WORD *)(v18 + 42),
          *(_WORD *)(v18 + 32) - *(_WORD *)(v18 + 40) - *(_WORD *)(v18 + 44),
          *(_WORD *)(v18 + 46),
          1);
        v19 = *(_DWORD *)(a1 + 56);
        sub_10035650(
          a1 + 392,
          0,
          *(_WORD *)(v19 + 46) + *(_WORD *)(v19 + 42),
          *(_WORD *)(v19 + 32),
          *(_WORD *)(v19 + 34) - *(_WORD *)(v19 + 42) - *(_WORD *)(v19 + 46),
          1);
        return 2;
      }
      sub_10035650(a1 + 392, 0, 0, *(_WORD *)(v17 + 32), *(_WORD *)(v17 + 34), 1);
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 25) = 0;
      return 2;
    }
    if ( v7 == 32 )
    {
      *(_WORD *)(a1 + 428) = word_100FD810[(unsigned __int8)sub_10014000(15)];
      *(_WORD *)(a1 + 430) = word_100FD810[(unsigned __int8)sub_10014000(15)];
      *(_WORD *)(a1 + 440) = word_100FD810[(unsigned __int8)sub_10014000(15)];
      *(_WORD *)(a1 + 442) = word_100FD810[(unsigned __int8)sub_10014000(15)];
      sub_10007870(a2, a1, 2u);
      return 2;
    }
    if ( v7 != 96 )
    {
      *(_WORD *)(a1 + 428) = word_100FD810[1];
      *(_WORD *)(a1 + 430) = word_100FD810[1];
      *(_WORD *)(a1 + 440) = word_100FD810[1];
      v8 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 442) = word_100FD810[1];
      sub_10035650(a1 + 392, 0, 0, *(_WORD *)(v8 + 32), *(_WORD *)(v8 + 34), 1);
      *(_WORD *)(a1 + 428) = word_100FD810[15];
      *(_WORD *)(a1 + 430) = word_100FD810[14];
      sub_10035650(a1 + 392, 0, 3, *(_WORD *)(*(_DWORD *)(a1 + 56) + 32), *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 6, 2);
      *(_WORD *)(a1 + 428) = word_100FD810[13];
      *(_WORD *)(a1 + 430) = word_100FD810[1];
      sub_10035650(
        a1 + 392,
        1,
        4,
        *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) - 2,
        *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 8,
        2);
      *(_WORD *)(a1 + 428) = word_100FD810[14];
      *(_WORD *)(a1 + 430) = word_100FD810[12];
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      v9 = 2;
      do
      {
        sub_10035650(
          a1 + 392,
          v9,
          v9 + 3,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) - 2 * v9,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 2 * (v9 + 3),
          2);
        ++v9;
      }
      while ( v9 < 6 );
      v10 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      if ( !*(_BYTE *)(v10 + 25)
        && (*(_WORD *)(v10 + 40) || *(_WORD *)(v10 + 42) || *(_WORD *)(v10 + 44) || *(_WORD *)(v10 + 46)) )
      {
        sub_10035650(a1 + 392, 6, 9, *(_WORD *)(v10 + 32) - 12, *(_WORD *)(v10 + 34) - 18, 2);
        v11 = *(_DWORD *)(a1 + 56);
        *(_WORD *)(a1 + 428) = v6;
        *(_WORD *)(a1 + 430) = v6;
        sub_10035650(a1 + 392, 6, 9, *(_WORD *)(v11 + 32) - 12, *(_WORD *)(v11 + 42) - 9, 1);
        sub_10035650(
          a1 + 392,
          6,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 42),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 40) - 6,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 46),
          1);
        v12 = *(_DWORD *)(a1 + 56);
        sub_10035650(
          a1 + 392,
          *(_WORD *)(v12 + 44) + *(_WORD *)(v12 + 40),
          *(_WORD *)(v12 + 42),
          *(_WORD *)(v12 + 32) - *(_WORD *)(v12 + 40) - *(_WORD *)(v12 + 44) - 6,
          *(_WORD *)(v12 + 46),
          1);
        v13 = *(_DWORD *)(a1 + 56);
        sub_10035650(
          a1 + 392,
          6,
          *(_WORD *)(v13 + 46) + *(_WORD *)(v13 + 42),
          *(_WORD *)(v13 + 32) - 12,
          *(_WORD *)(v13 + 34) - *(_WORD *)(v13 + 42) - *(_WORD *)(v13 + 46) - 9,
          1);
      }
      else
      {
        sub_10035650(a1 + 392, 6, 9, *(_WORD *)(v10 + 32) - 12, *(_WORD *)(v10 + 34) - 18, 3);
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 25) = 0;
      }
      v14 = *(_DWORD *)(a1 + 56);
      if ( *(_BYTE *)(v14 + 247) )
      {
        *(_WORD *)(a1 + 428) = word_100FD810[15];
        *(_WORD *)(a1 + 430) = word_100FD810[15];
        *(_WORD *)(a1 + 440) = word_100FD810[1];
        *(_WORD *)(a1 + 442) = word_100FD810[1];
        sub_10035650(a1 + 392, 10, 13, *(_WORD *)(v14 + 32) - 20, *(_WORD *)(v14 + 34) - 26, 3);
        return 2;
      }
      return 2;
    }
    *(_WORD *)(a1 + 428) = word_100FD810[(unsigned __int8)sub_10014000(15)];
    *(_WORD *)(a1 + 430) = word_100FD810[(unsigned __int8)sub_10014000(15)];
    *(_WORD *)(a1 + 440) = word_100FD810[(unsigned __int8)sub_10014000(15)];
    v15 = sub_10014000(15);
    v16 = (*(_BYTE *)(a1 + 22) & 0x1E) == 0;
    *(_WORD *)(a1 + 442) = word_100FD810[(unsigned __int8)v15];
    if ( v16 )
    {
      sub_10007870(a2, a1, 2u);
      result = 2;
    }
    else
    {
      sub_10007870(a2, a1, 5u);
      result = 2;
    }
  }
  return result;
}
// 100FD810: using guessed type __int16 word_100FD810[];

//----- (10007F00) --------------------------------------------------------
unsigned int __usercall sub_10007F00@<eax>(int a1@<ebx>, int a2@<esi>, unsigned __int16 *a3)
{
  int v3; // edi@1
  int v4; // ST38_4@1
  int v5; // eax@1
  __int16 v6; // cx@1
  unsigned int result; // eax@1
  char v8; // [sp+Ch] [bp-204h]@1

  v3 = BMP_get_bm_def(*a3);
  v4 = *(_DWORD *)(a2 + 460);
  v5 = sub_1000A8B0(*a3, *(_BYTE *)(a2 + 3), (int)&v8);
  v6 = *(_WORD *)(a2 + 432);
  *(_DWORD *)(a2 + 460) = v5;
  result = sub_10033E10(
             a2 + 392,
             v3,
             0,
             0,
             *(_WORD *)a1 + *(_WORD *)(a2 + 434),
             *(_WORD *)(a1 + 2) + v6,
             *(_WORD *)(v3 + 6),
             *(_WORD *)(v3 + 4));
  *(_DWORD *)(a2 + 460) = v4;
  return result;
}
// 100310E8: using guessed type int __cdecl BMP_get_bm_def(_DWORD);

//----- (10007FB0) --------------------------------------------------------
char __cdecl sub_10007FB0(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5)
{
  char result; // al@1
  int v6; // eax@8
  __int16 v7; // dx@8
  __int16 v8; // si@8

  result = 1;
  if ( *a5 == 32802 )
    goto LABEL_11;
  if ( *a5 == 32832 )
  {
    v6 = BMP_get_bm_def(*a4);
    v7 = *(_WORD *)(v6 + 6);
    v8 = *(_WORD *)(v6 + 4);
    *(_WORD *)(a1 + 276) = *(_WORD *)a3;
    *(_WORD *)(a1 + 278) = *(_WORD *)(a3 + 2);
    *(_WORD *)(a1 + 280) = v7 + *(_WORD *)a3 - 1;
    *(_WORD *)(a1 + 282) = v8 + *(_WORD *)(a3 + 2) - 1;
    return 2;
  }
  if ( *a5 == 32888 )
  {
LABEL_11:
    if ( *a4 != -1 )
      sub_10007F00(a3, a1, a4);
    result = 2;
  }
  return result;
}
// 100310E8: using guessed type int __cdecl BMP_get_bm_def(_DWORD);

//----- (10008050) --------------------------------------------------------
__int16 __usercall sub_10008050@<ax>(int a1@<eax>, int a2@<esi>)
{
  unsigned int v2; // ecx@1
  unsigned int v3; // ecx@1
  __int16 result; // ax@1

  v2 = *(_DWORD *)(a1 + 32);
  *(_WORD *)a2 = v2 / 0xE10;
  v3 = -3600 * (signed __int16)(v2 / 0xE10) + v2;
  *(_BYTE *)(a2 + 2) = v3 / 0x3C;
  result = 60 * (char)(v3 / 0x3C);
  *(_BYTE *)(a2 + 3) = v3 % 0x3C;
  return result;
}

//----- (10008090) --------------------------------------------------------
const char *__usercall sub_10008090@<eax>(const char *result@<eax>, unsigned __int8 a2@<bl>, char *a3)
{
  int v3; // edi@1
  char v4; // cl@11
  int v5; // [sp+8h] [bp-4h]@4

  v3 = *result & 0x3F;
  if ( v3 < 46 || v3 > 49 )
  {
    *a3 = 0;
  }
  else if ( *((_DWORD *)result + 8) >= 0x7FFFFFFFu )
  {
    result = "__:__:__";
    do
    {
      v4 = *result;
      result[a3 - "__:__:__"] = *result;
      ++result;
    }
    while ( v4 );
    if ( v3 == 46 || v3 == 47 )
      a3[5] = 0;
  }
  else
  {
    sub_10008050((int)result, (int)&v5);
    if ( v3 == 47 )
    {
      if ( !(_WORD)v5 )
        return (const char *)sub_1000F650(
                               a3,
                               a2,
                               "%02u:%c%c",
                               BYTE2(v5),
                               (unsigned __int8)(BYTE3(v5) / 10 + 48),
                               (unsigned __int8)((unsigned __int16)(BYTE3(v5) % 10) + 48));
    }
    else if ( v3 != 46 )
    {
      return (const char *)_snprintf(a3, a2, "%01u:%02u:%02u", (signed __int16)v5, BYTE2(v5), BYTE3(v5));
    }
    result = (const char *)_snprintf(a3, a2, "%01u:%02u", (signed __int16)v5, BYTE2(v5));
  }
  return result;
}

//----- (10008190) --------------------------------------------------------
char __cdecl sub_10008190(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v5; // ecx@3
  int v6; // edx@3
  double v7; // st7@3
  double v8; // st7@3
  int v9; // edx@3
  float v11; // [sp+4h] [bp-34h]@3
  float v12; // [sp+8h] [bp-30h]@3
  int v13; // [sp+Ch] [bp-2Ch]@3
  float v14; // [sp+10h] [bp-28h]@3
  int v15; // [sp+14h] [bp-24h]@3
  int v16; // [sp+18h] [bp-20h]@3
  float v17; // [sp+1Ch] [bp-1Ch]@3
  float v18; // [sp+20h] [bp-18h]@3
  float v19; // [sp+24h] [bp-14h]@3
  char v20; // [sp+28h] [bp-10h]@3

  if ( *a5 == 32802 || *a5 == 32888 )
  {
    v5 = *(_DWORD *)(a4 + 4);
    v6 = *(_DWORD *)(a4 + 8);
    v14 = *(float *)(a4 + 12);
    v7 = *(float *)(a4 + 24);
    v16 = v5;
    v17 = v7;
    v8 = *(float *)(a4 + 28);
    v15 = v6;
    v9 = *(_DWORD *)(a4 + 20);
    v18 = v8;
    v19 = *(float *)(a4 + 16);
    v11 = *(float *)(a4 + 36);
    v13 = v9;
    v12 = *(float *)(a4 + 40);
    sub_10008090((const char *)a4, 0xCu, &v20);
    sub_1000FFB0(a1, (int)&v20, (int)&v11);
    *(_BYTE *)(a1 + 6) = 2;
  }
  return 1;
}

//----- (10008240) --------------------------------------------------------
signed int __cdecl sub_10008240(_BYTE *a1, int a2)
{
  signed int result; // eax@1
  float *v3; // ecx@2
  float *v4; // edi@2
  float *v5; // ecx@6
  int v6; // edx@6

  result = 0;
  if ( *a1 )
  {
    v3 = (float *)(a2 + 440);
    v4 = (float *)(a1 + 12);
    while ( result < 10 )
    {
      ++result;
      *(v3 - 1) = *v4;
      *(_BYTE *)v3 = a1[result + 91];
      ++v4;
      v3 += 2;
      if ( result >= *a1 )
      {
        if ( result >= 10 )
          return result;
        goto LABEL_6;
      }
    }
  }
  else
  {
LABEL_6:
    v5 = (float *)(a2 + 8 * result + 440);
    v6 = 10 - result;
    do
    {
      *(v5 - 1) = 9.8999998e24;
      *(_BYTE *)v5 = 10;
      v5 += 2;
      --v6;
    }
    while ( v6 );
  }
  return result;
}

//----- (100082B0) --------------------------------------------------------
signed int __cdecl sub_100082B0(int a1, signed int a2, int a3)
{
  signed int result; // eax@1
  int *v4; // edx@2
  int v5; // ecx@2

  result = 0;
  if ( a2 > 0 )
  {
    v4 = (int *)(a3 + 48);
    v5 = a1 + 8;
    do
    {
      if ( result >= 3 )
        break;
      *v4 = v5;
      ++result;
      v5 += 12;
      v4 += 12;
    }
    while ( result < a2 );
  }
  return result;
}

//----- (100082F0) --------------------------------------------------------
void __usercall sub_100082F0(int a1@<eax>, int a2)
{
  int v2; // esi@1
  unsigned __int8 v3; // bl@1
  float **v4; // ebp@1
  int v5; // edi@1
  float *v6; // ecx@2
  char v7; // al@4
  unsigned __int8 v8; // [sp+23h] [bp-5h]@1
  char v9; // [sp+24h] [bp-4h]@1

  v2 = a1;
  v9 = 0;
  v8 = 0;
  v3 = 0;
  v4 = (float **)(a1 + 48);
  v5 = a1 + 528;
  do
  {
    v6 = *v4;
    if ( *v4 )
    {
      if ( 9.8999998e24 != *v6 )
      {
        v7 = sub_10015E70(*v6, v2 + 436, 10, v5);
        if ( (unsigned __int8)v9 < (unsigned __int8)v7 )
        {
          v9 = v7;
          v8 = v3;
        }
      }
    }
    ++v3;
    v5 += 28;
    v4 += 12;
  }
  while ( v3 < 3u );
  sub_10015FF0(v9, (_DWORD *)(v2 + 188), (int *)(v2 + 184), *(_BYTE *)(v2 + 175), *(_DWORD *)(v2 + 28 * v8 + 536));
  sub_10015FF0(v9, (_DWORD *)(v2 + 240), (int *)(v2 + 236), *(_BYTE *)(v2 + 175), *(_DWORD *)(v2 + 28 * v8 + 536));
  sub_10015E50(a2, v2 + 176);
  sub_10015E50(a2, v2 + 228);
}

//----- (100083E0) --------------------------------------------------------
int __usercall sub_100083E0@<eax>(int a1@<edi>, int a2, int a3, float a4, float a5, float a6, float a7)
{
  int v7; // eax@1
  double v8; // st6@1
  int v9; // ebp@1
  int v10; // esi@1
  double v11; // st5@1
  char *v12; // eax@4
  char v13; // cl@5
  int v14; // eax@6
  signed int v15; // ecx@6
  double v16; // st6@6
  double v17; // st5@6
  double v18; // st4@6
  double v19; // st3@6
  double v20; // st7@6
  double v21; // rt1@7
  double v22; // st3@7
  double v23; // rtt@7
  double v24; // rt0@8
  double v25; // st3@8
  double v26; // st6@8
  double v27; // rt1@8
  double v28; // st3@8
  double v29; // st5@8
  double v30; // rt2@8
  double v31; // st3@8
  double v32; // st4@8
  double v33; // rtt@8
  double v34; // st3@8
  double v35; // st7@8
  double v36; // rt0@8
  double v37; // st3@8
  double v38; // st6@8
  float v40; // [sp+14h] [bp+14h]@1
  float v41; // [sp+18h] [bp+18h]@3

  v7 = a3;
  *(float *)a1 = a4;
  *(float *)(a1 + 4) = a5;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = a6;
  *(float *)(a1 + 8) = a6;
  v9 = a1 + 528;
  *(float *)(a1 + 12) = a7;
  v10 = a1 + 32;
  LODWORD(v40) = 3;
  *(float *)(a1 + 20) = *(float *)(a3 + 4);
  v11 = *(float *)(a3 + 8);
  *(_BYTE *)(a1 + 172) = 1;
  *(float *)(a1 + 24) = v11;
  while ( 1 )
  {
    *(_DWORD *)(v10 + 4) = 0;
    v41 = a4 + v8;
    *(float *)(v10 - 4) = v41;
    *(_DWORD *)(v10 + 8) = -1;
    *(_DWORD *)(v10 + 12) = -1;
    *(float *)v10 = a5;
    *(_BYTE *)(v10 + 42) = 0;
    *(float *)(v10 + 20) = *(float *)(v7 + 4);
    *(float *)(v10 + 24) = *(float *)(v7 + 8);
    *(_DWORD *)(v10 + 16) = 0;
    *(_BYTE *)(v10 + 41) = 0;
    *(_BYTE *)(v10 + 40) = 0;
    *(float *)(v10 + 28) = 1.0;
    *(float *)(v10 + 32) = 1.0;
    *(float *)(v10 + 36) = 15.0;
    sub_10016080(v9);
    v10 += 48;
    v9 += 28;
    --LODWORD(v40);
    if ( v40 == 0.0 )
      break;
    v7 = a3;
  }
  v12 = (char *)a2;
  *(float *)(a1 + 176) = a4;
  *(float *)(a1 + 180) = a5;
  *(_WORD *)(a1 + 516) = 12;
  *(_DWORD *)(a1 + 520) = &unk_1005FD84;
  *(_BYTE *)(a1 + 524) = 1;
  *(_DWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 188) = -1;
  do
  {
    v13 = *v12;
    v12[a1 - a2 + 192] = *v12;
    ++v12;
  }
  while ( v13 );
  *(_DWORD *)(a1 + 236) = 0;
  *(float *)(a1 + 216) = 0.0;
  *(_DWORD *)(a1 + 240) = -1;
  *(_BYTE *)(a1 + 244) = 0;
  *(float *)(a1 + 220) = 1.0;
  v14 = a1 + 284;
  v15 = 3;
  *(float *)(a1 + 224) = 12.0;
  *(float *)(a1 + 228) = a4;
  v16 = a4;
  *(float *)(a1 + 232) = a5;
  v17 = a5;
  *(float *)(a1 + 268) = 0.0;
  v18 = 0.0;
  *(float *)(a1 + 272) = 1.0;
  v19 = 12.0;
  v20 = 1.0;
  *(float *)(a1 + 276) = 12.0;
  while ( 1 )
  {
    v24 = v19;
    v25 = v16;
    v26 = v24;
    *(_DWORD *)(v14 + 4) = 0;
    *(float *)(v14 - 4) = v25;
    *(_DWORD *)(v14 + 8) = -1;
    v27 = v25;
    v28 = v17;
    v29 = v27;
    *(_BYTE *)(v14 + 12) = 0;
    *(float *)v14 = v28;
    v14 += 52;
    --v15;
    v30 = v28;
    v31 = v18;
    v32 = v30;
    *(float *)(v14 - 16) = v31;
    v33 = v31;
    v34 = v20;
    v35 = v33;
    *(float *)(v14 - 12) = v34;
    v36 = v34;
    v37 = v26;
    v38 = v36;
    *(float *)(v14 - 8) = v37;
    if ( !v15 )
      break;
    v21 = v37;
    v22 = v35;
    v20 = v38;
    v23 = v22;
    v16 = v29;
    v17 = v32;
    v19 = v21;
    v18 = v23;
  }
  *(_WORD *)(a1 + 173) = 0;
  *(_BYTE *)(a1 + 175) = 0;
  return sub_10008240((_BYTE *)a3, a1);
}

//----- (100085B0) --------------------------------------------------------
int __cdecl sub_100085B0(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  return sub_100083E0(a1, a2, a3, a4, a5, a6, a7);
}

//----- (100085F0) --------------------------------------------------------
void __cdecl sub_100085F0(int a1, int a2)
{
  int v2; // esi@1
  int *v3; // ebx@1
  int v4; // edi@1
  float *v5; // ecx@3
  char v6; // ST40_1@9
  signed int v7; // [sp+20h] [bp-8h]@1

  v2 = a2 + 288;
  v3 = (int *)(a2 + 536);
  v4 = a2 + 48;
  v7 = 3;
  do
  {
    if ( *(_BYTE *)(v2 + 8) )
    {
      v5 = *(float **)v4;
      if ( *(_DWORD *)v4 )
      {
        if ( *(_BYTE *)(v4 + 26)
          || 9.8999998e24 != *v5
          && (!*(_BYTE *)(v4 + 24) || *(float *)(v4 + 4) <= (double)*v5 && *(float *)(v4 + 8) >= (double)*v5) )
        {
          v6 = sub_10015E70(*v5, a2 + 436, 10, (int)(v3 - 2));
          sub_10015FF0(v6, (_DWORD *)(v2 + 4), (int *)v2, *(_BYTE *)(a2 + 173), *v3);
          sub_10015E50(a1, v2 - 8);
        }
      }
    }
    v4 += 48;
    v3 += 7;
    v2 += 52;
    --v7;
  }
  while ( v7 );
}

//----- (100086C0) --------------------------------------------------------
void __usercall sub_100086C0(int a1@<esi>, int a2)
{
  signed int v2; // ebx@1
  int *v3; // ebp@2
  int v4; // edi@2
  float *v5; // ecx@4
  char v6; // ST44_1@11

  v2 = 0;
  if ( *(_BYTE *)(a1 + 172) )
  {
    v3 = (int *)(a1 + 536);
    v4 = a1 + 48;
    do
    {
      if ( v2 >= 3 )
        break;
      v5 = *(float **)v4;
      if ( *(_DWORD *)v4 && *(_BYTE *)(a1 + 174) != 1 )
      {
        if ( !*(_BYTE *)(v4 + 26)
          && (9.8999998e24 == *v5
           || *(_BYTE *)(v4 + 24) && (*(float *)(v4 + 4) > (double)*v5 || *(float *)(v4 + 8) < (double)*v5)) )
        {
          sub_10015D70(v4 - 20);
        }
        else
        {
          v6 = sub_10015E70(*v5, a1 + 436, 10, (int)(v3 - 2));
          sub_10015F60(v6, (_DWORD *)(v4 - 8), (int *)(v4 - 12), *(_BYTE *)(a1 + 174), *v3);
          sub_10015BA0(a2, v4 - 20, *(_WORD *)(a1 + 516), *(_DWORD *)(a1 + 520), *(_BYTE *)(a1 + 524));
        }
      }
      ++v2;
      v3 += 7;
      v4 += 48;
    }
    while ( v2 < *(_BYTE *)(a1 + 172) );
  }
}

//----- (100087D0) --------------------------------------------------------
char __cdecl sub_100087D0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  switch ( *a5 )
  {
    case 0x8015:
    case 0x8016:
    case 0x8022:
    case 0x8078:
      sub_100082F0(a4, a1);
      sub_100085F0(a1, a4);
      sub_100086C0(a4, a1);
      break;
    default:
      return 1;
  }
  return 1;
}

//----- (10008890) --------------------------------------------------------
char __cdecl sub_10008890(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v6; // eax@4
  float v7; // ST38_4@5
  float v8; // ST38_4@5
  float v9; // ST24_4@5
  float v10; // ST38_4@5
  float v11; // ST20_4@5
  float v12; // ST38_4@5
  float v13; // ST28_4@5
  float v14; // ST2C_4@5
  float v15; // ST1C_4@5
  float v16; // ST30_4@5
  float v17; // ST24_4@5
  float v18; // ST20_4@5
  float v19; // ST30_4@5
  float v20; // ST2C_4@5
  float v21; // ST38_4@5
  float v22; // ST28_4@5
  float v23; // ST34_4@5
  float v24; // ST38_4@6
  float v25; // ST30_4@6
  float v26; // ST34_4@6
  float v27; // ST38_4@6
  float v28; // ST38_4@6
  float v29; // ST34_4@6
  float v30; // ST38_4@6
  double v31; // st7@6
  float v32; // ST08_4@8
  float v33; // [sp+4h] [bp-30h]@6
  float v34; // [sp+10h] [bp-24h]@4
  float v35; // [sp+48h] [bp+14h]@4
  float v36; // [sp+48h] [bp+14h]@6

  if ( *a5 != 32802 && *a5 != 32888 )
    return 1;
  v6 = *(_DWORD *)(a1 + 56);
  v34 = (double)*(_WORD *)(v6 + 34);
  v35 = (double)*(_WORD *)(v6 + 32);
  if ( !(*(_BYTE *)(a2 + 4) & 1) )
  {
    j_gdi_pvg_begin(72);
    j_gdi_pvg_color_u32(*(_DWORD *)(a2 + 8));
    sub_100317B0(0.0, 0.0);
    sub_100317B0(v35, 0.0);
    sub_100317B0(v35, v34);
    v33 = v34;
    v31 = 0.0;
    goto LABEL_8;
  }
  j_gdi_pvg_begin(72);
  j_gdi_pvg_color_u32(*(_DWORD *)(a2 + 8));
  sub_100317B0(0.0, 0.0);
  sub_100317B0(v35, 0.0);
  sub_100317B0(v35, v34);
  sub_100317B0(0.0, v34);
  j_gdi_pvg_color_u32(-16777216);
  sub_100317B0(0.0, 0.0);
  sub_100317B0(v35, 0.0);
  v7 = 0.0 + 3.0;
  sub_100317B0(v35, v7);
  sub_100317B0(0.0, v7);
  v8 = v34 - 3.0;
  sub_100317B0(0.0, v8);
  sub_100317B0(v35, v8);
  sub_100317B0(v35, v34);
  sub_100317B0(0.0, v34);
  j_gdi_pvg_end();
  sub_100316D0(1.0);
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-1);
  v9 = v34 - 3.5;
  v10 = 0.0 + 0.5;
  sub_100317B0(v10, v9);
  v11 = 0.0 + 3.5;
  sub_100317B0(v10, v11);
  v12 = v35 - 0.0;
  sub_100317B0(v12, v11);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-8355712);
  v13 = 0.0 + 1.5;
  sub_100317B0(v13, v9);
  v14 = v35 - 0.5;
  sub_100317B0(v14, v9);
  sub_100317B0(v14, v11);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-4144960);
  v15 = v34 - 4.5;
  sub_100317B0(v13, v15);
  v16 = 0.0 + 4.5;
  sub_100317B0(v13, v16);
  sub_100317B0(v14, v16);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-16777216);
  v17 = 0.0 + 2.5;
  sub_100317B0(v17, v15);
  v18 = v35 - 1.5;
  sub_100317B0(v18, v15);
  sub_100317B0(v18, v16);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(73);
  j_gdi_pvg_color_u32(-14671840);
  sub_100317B0(v17, v15);
  v19 = v34 - 9.5;
  v20 = 0.0 + 7.5;
  sub_100317B0(v20, v19);
  sub_100317B0(v18, v15);
  v21 = v35 - 6.5;
  sub_100317B0(v21, v19);
  v22 = 0.0 + 5.5;
  sub_100317B0(v18, v22);
  v23 = 0.0 + 10.5;
  sub_100317B0(v21, v23);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(73);
  j_gdi_pvg_color_u32(-8355712);
  sub_100317B0(v17, v15);
  sub_100317B0(v20, v19);
  sub_100317B0(v17, v22);
  sub_100317B0(v20, v23);
  sub_100317B0(v18, v22);
  sub_100317B0(v21, v23);
  j_gdi_pvg_end();
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 247) )
  {
    j_gdi_pvg_begin(72);
    j_gdi_pvg_color_u32(-1);
    v24 = 0.0 + 14.0;
    v25 = 0.0 + 11.0;
    sub_100317B0(v25, v24);
    v26 = v35 - 11.0;
    sub_100317B0(v26, v24);
    v27 = v34 - 14.0;
    sub_100317B0(v26, v27);
    sub_100317B0(v25, v27);
    j_gdi_pvg_color_u32(*(_DWORD *)(a2 + 8));
    v28 = 0.0 + 15.0;
    v29 = 0.0 + 12.0;
    sub_100317B0(v29, v28);
    v36 = v35 - 12.0;
    sub_100317B0(v36, v28);
    v30 = v34 - 15.0;
    sub_100317B0(v36, v30);
    v33 = v30;
    v31 = v29;
LABEL_8:
    v32 = v31;
    sub_100317B0(v32, v33);
    j_gdi_pvg_end();
  }
  return 2;
}
// 100315B0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10031620: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 100316A0: using guessed type int j_gdi_pvg_end(void);

//----- (10008ED0) --------------------------------------------------------
__int16 __cdecl sub_10008ED0(unsigned int a1)
{
  return byte_101EFA8F[20 * ((a1 >> 10) & 0xF)];
}

//----- (10008EF0) --------------------------------------------------------
char __cdecl sub_10008EF0(int a1, _WORD *a2, char **a3, int a4, int a5, int a6)
{
  int v6; // edi@1
  char result; // al@1
  char **v8; // ebp@1
  int v9; // esi@1
  int v10; // ebx@1
  bool v11; // al@7
  bool v12; // al@11
  int v13; // [sp+10h] [bp-4h]@5
  int v14; // [sp+18h] [bp+4h]@2

  v6 = a1;
  result = sub_100012F0(a1, *(_DWORD *)(a1 + 56));
  v8 = a3;
  v9 = *(_DWORD *)*a3 & 0xFF;
  v10 = 0;
  if ( v9 == 141 )
  {
    *(_BYTE *)(a1 + 3) = 0;
  }
  else
  {
    v14 = 0;
    do
    {
      if ( *v8 )
      {
        result = sub_1000E3A0(v6, a5, v10);
        if ( result )
        {
          sub_1000E400(*v8, &v13, 0);
          v11 = v10 == a6 && sub_1000E3D0(v6, a2, *(_DWORD *)(v6 + 56));
          *(_BYTE *)(v6 + 3) = v11;
          v12 = v10 == a6 && *(_DWORD *)(v6 + 56) == *(_DWORD *)(*(_DWORD *)(v6 + 48) + 4);
          *(_BYTE *)(v6 + 9) = v12;
          result = ((int (__cdecl *)(int, char *, int, _DWORD, _WORD *))dword_101EF5E0[2 * v9])(
                     v6,
                     *v8,
                     v13,
                     *(_DWORD *)(v14 + a4),
                     a2);
        }
      }
      v14 = 4 * ++v10;
      v8 = &a3[v10];
      v9 = *(_DWORD *)a3[v10] & 0xFF;
    }
    while ( v9 != 141 );
    *(_BYTE *)(v6 + 3) = 0;
  }
  return result;
}
// 101EF5E0: using guessed type int dword_101EF5E0[];

//----- (10009010) --------------------------------------------------------
bool __cdecl sub_10009010(int a1, _WORD *a2, char *a3, int a4, int a5, int a6)
{
  int v6; // esi@1
  char *v7; // ebp@1
  int v8; // edi@1
  bool result; // al@1
  _WORD *v10; // ebx@2
  int v11; // eax@4
  bool v12; // al@6
  bool v13; // zf@8
  bool v14; // al@10
  char *v15; // [sp+Ch] [bp-8h]@1
  int v16; // [sp+10h] [bp-4h]@1

  v6 = a1;
  sub_100012F0(a1, *(_DWORD *)(a1 + 56));
  v7 = a3;
  v8 = 0;
  result = sub_1000E400(a3, &v16, &v15);
  if ( result )
  {
    v10 = a2;
    do
    {
      if ( sub_1000E3A0(v6, a5, v8) )
      {
        v11 = *(_DWORD *)(v6 + 56);
        LOWORD(a1) = *(_WORD *)v16 + *(_WORD *)(v11 + 36);
        HIWORD(a1) = *(_WORD *)(v16 + 2) + *(_WORD *)(v11 + 38);
        v12 = v8 == a6 && sub_1000E3D0(v6, v10, v11);
        v13 = v8 == a6;
        *(_BYTE *)(v6 + 3) = v12;
        v14 = v13 && *(_DWORD *)(v6 + 56) == *(_DWORD *)(*(_DWORD *)(v6 + 48) + 4);
        *(_BYTE *)(v6 + 9) = v14;
        ((void (__cdecl *)(int, char *, int *, _DWORD, _WORD *))dword_101EF5E0[2 * (*(_DWORD *)v7 & 0xFF)])(
          v6,
          v7,
          &a1,
          *(_DWORD *)(a4 + 4 * v8),
          v10);
      }
      v7 = v15;
      ++v8;
      result = sub_1000E400(v15, &v16, &v15);
    }
    while ( result );
  }
  *(_BYTE *)(v6 + 3) = 0;
  return result;
}
// 101EF5E0: using guessed type int dword_101EF5E0[];

//----- (10009110) --------------------------------------------------------
int __cdecl sub_10009110(unsigned int a1)
{
  __int16 v1; // ax@1
  int v3; // [sp+4h] [bp+4h]@1

  v1 = word_100FD810[(a1 >> 5) & 0x1F];
  HIWORD(v3) = word_100FD810[a1 & 0x1F];
  LOWORD(v3) = v1;
  return v3;
}
// 100FD810: using guessed type __int16 word_100FD810[];

//----- (10009140) --------------------------------------------------------
char *__cdecl sub_10009140(unsigned int a1)
{
  return (char *)&unk_101EFA80 + 20 * ((a1 >> 10) & 0xF);
}

//----- (10009160) --------------------------------------------------------
signed int __cdecl sub_10009160(__int16 a1)
{
  signed int result; // eax@1

  result = 1073741828;
  if ( a1 & 0xC000 )
  {
    if ( (a1 & 0xC000) == 0x8000 )
      result = 1073741829;
  }
  else
  {
    result = 1073741830;
  }
  return result;
}

//----- (10009190) --------------------------------------------------------
signed int __cdecl sub_10009190(int a1)
{
  int v1; // eax@1
  signed int result; // eax@3

  v1 = a1 & 0xC00000;
  if ( a1 & 0xC00000 )
  {
    if ( v1 == 0x400000 )
      result = 1;
    else
      result = v1 != 0x800000 ? 0 : 2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100091C0) --------------------------------------------------------
void *sub_100091C0()
{
  void *result; // eax@1

  result = (void *)dword_101080E8;
  if ( !dword_101080E8 )
    result = &unk_10060950;
  return result;
}
// 101080E8: using guessed type int dword_101080E8;

//----- (100091D0) --------------------------------------------------------
int __usercall sub_100091D0@<eax>(_BYTE *a1@<eax>)
{
  int result; // eax@5

  if ( !*a1 )
    goto LABEL_9;
  do
  {
    if ( *a1 == 10 )
      break;
    ++a1;
  }
  while ( *a1 );
  if ( *a1 )
  {
    *a1 = 0;
    result = (int)(a1 + 1);
  }
  else
  {
LABEL_9:
    result = 0;
  }
  return result;
}

//----- (10009200) --------------------------------------------------------
char __usercall sub_10009200@<al>(unsigned __int8 a1@<cl>, int a2@<edi>, unsigned __int8 a3)
{
  signed int v3; // ebx@1
  char result; // al@1
  char v5; // al@2
  char v6; // [sp+Bh] [bp-5h]@1
  char v7; // [sp+Ch] [bp-4h]@2
  char v8; // [sp+Dh] [bp-3h]@1

  v3 = a1;
  result = 0;
  v6 = 0;
  v8 = 0;
  if ( a1 <= (signed int)a3 )
  {
    do
    {
      v7 = v3;
      v5 = sub_10034B10(a2, &v7, 0);
      if ( v5 > v6 )
        v6 = v5;
      ++v3;
    }
    while ( v3 <= a3 );
    result = v6;
  }
  return result;
}

//----- (10009250) --------------------------------------------------------
char __usercall sub_10009250@<al>(size_t a1@<edx>, signed int a2@<ecx>, int a3@<esi>, const char *a4, int *a5, char a6, char a7)
{
  unsigned int v7; // ecx@1
  int v8; // edi@1
  int v9; // ebx@1
  int v10; // ecx@1
  char *v11; // eax@4
  char v12; // cl@6
  signed __int16 v13; // dx@9
  int v14; // eax@25
  unsigned int v15; // ebx@29
  unsigned __int8 v16; // al@29
  __int16 v17; // dx@37
  __int16 v18; // cx@37
  unsigned int v19; // edi@42
  signed int v20; // ecx@44
  int v21; // edi@46
  unsigned int v22; // edi@52
  __int16 v23; // ax@52
  __int16 v24; // dx@55
  __int16 v25; // cx@55
  int v26; // eax@58
  char result; // al@63
  int v28; // [sp+0h] [bp-6Ch]@0
  int v29; // [sp+Ch] [bp-60h]@1
  char *v30; // [sp+10h] [bp-5Ch]@6
  signed int v31; // [sp+14h] [bp-58h]@1
  int v32; // [sp+18h] [bp-54h]@1
  int v33; // [sp+1Ch] [bp-50h]@1
  int v34; // [sp+20h] [bp-4Ch]@1
  int v35; // [sp+24h] [bp-48h]@1
  int v36; // [sp+28h] [bp-44h]@1
  int v37; // [sp+2Ch] [bp-40h]@1
  int v38; // [sp+30h] [bp-3Ch]@1
  __int16 v39; // [sp+30h] [bp-3Ch]@29
  __int16 v40; // [sp+32h] [bp-3Ah]@29
  int v41; // [sp+34h] [bp-38h]@1
  size_t v42; // [sp+3Ch] [bp-30h]@1
  signed int v43; // [sp+40h] [bp-2Ch]@9
  int v44; // [sp+44h] [bp-28h]@21
  int v45; // [sp+48h] [bp-24h]@15
  unsigned int v46; // [sp+4Ch] [bp-20h]@29
  signed int v47; // [sp+50h] [bp-1Ch]@1
  char v48; // [sp+54h] [bp-18h]@4

  v31 = a2;
  v42 = a1;
  v7 = strlen(a4);
  v34 = a5[2];
  v8 = a5[1];
  v35 = a5[3];
  v9 = v7;
  v36 = a5[4];
  v47 = v7;
  v32 = *a5;
  v33 = v8;
  v37 = a5[5];
  v29 = 0;
  v41 = *(_WORD *)(*a5 + 28);
  v10 = sub_10034B10(*a5, a4, v8);
  v38 = v10;
  if ( (signed __int16)v35 <= 0 )
    LOWORD(v35) = v10;
  if ( (unsigned int)v9 >= 0x14 )
    v11 = (char *)sub_10002820(a3, v9 + 1);
  else
    v11 = &v48;
  v12 = *(_BYTE *)(a3 + 3);
  v30 = v11;
  if ( v12 && a6 && v31 > 0 )
  {
    v13 = 1;
    v43 = 1;
  }
  else
  {
    v43 = 0;
    v13 = 1;
  }
  v45 = v12 && (!a6 || v31 >= 0 && v31 + 1 <= v9);
  v44 = *(_BYTE *)(a3 + 3) && a6 && (v31 < 0 || (signed int)(v31 + v42) < v9);
  if ( (v8 & 3) != 2 )
  {
    if ( v8 & 3 )
    {
      *(_WORD *)(a3 + 438) += (signed __int16)v35 / -2;
      v14 = ((signed __int16)v35 - v38) / 2;
    }
    else
    {
      *(_WORD *)(a3 + 438) += v13 - v35;
      v14 = (signed __int16)v35 - v38;
    }
    v8 = v8 & 0xFFFFFFFE | 2;
    v33 = v8;
    if ( v14 > 0 )
      v29 = v14;
  }
  v15 = v8 & 0xFFFFFFF7 | 4;
  v39 = v35 + v41 + *(_WORD *)(a3 + 438);
  v16 = v34;
  v40 = *(_WORD *)(a3 + 436);
  v46 = v8 & 0xFFFFFFF7 | 4;
  if ( !v43 && !v45 && v44 )
    v16 = 0;
  if ( *(_BYTE *)(a3 + 3) && !a6 && (byte_101BD3BE || byte_101EF5C0) )
  {
    v17 = v36;
    v18 = HIWORD(v35);
  }
  else
  {
    v17 = HIWORD(v35);
    v18 = v36;
  }
  *(_WORD *)(a3 + 428) = v17;
  *(_WORD *)(a3 + 430) = v18;
  sub_10034B70(a3 + 392, v32, &unk_1005E69C, v35, v8 & 0xFFFFFFF7 | 4, v16, v28);
  *(_WORD *)(a3 + 438) += v29;
  if ( *(_BYTE *)(a3 + 3) )
  {
    if ( v43 )
    {
      v19 = v8 & 0xFFFFFFF3;
      if ( a7 )
        --*(_WORD *)(a3 + 438);
      strncpy(v30, a4, v31);
      v20 = v31;
      if ( v31 >= v47 )
        v20 = v47;
      v30[v20] = 0;
      *(_WORD *)(a3 + 428) = HIWORD(v35);
      *(_WORD *)(a3 + 430) = v36;
      v21 = sub_10034B70(a3 + 392, v32, v30, v35 - v29, v19 | 0x80000000, 0, v37) + v29;
      if ( a7 )
        *(_WORD *)(a3 + 438) += v41 + 1;
      else
        *(_WORD *)(a3 + 438) += v41;
      v15 = v46;
      v29 = v41 + v21;
      v8 = v33;
    }
    if ( v45 )
    {
      if ( a6 )
      {
        v22 = v34 & 0xFFFF0001 | 1;
        strncpy(v30, &a4[v31], v42);
        v30[v42] = 0;
        v23 = 0;
      }
      else
      {
        LOWORD(v22) = (unsigned __int8)v34;
        strcpy(v30, a4);
        v23 = v35 - v29;
      }
      if ( byte_101BD3BE || byte_101EF5C0 )
      {
        v24 = v36;
        v25 = HIWORD(v35);
      }
      else
      {
        v24 = HIWORD(v35);
        v25 = v36;
      }
      *(_WORD *)(a3 + 428) = v24;
      *(_WORD *)(a3 + 430) = v25;
      v26 = sub_10034B70(a3 + 392, v32, v30, v23, v15 | 0x80000000, v22, v37);
      v8 = v33;
      *(_WORD *)(a3 + 438) += v41;
      v29 += v41 + v26;
    }
    if ( v44 )
    {
      if ( a7 )
        ++*(_WORD *)(a3 + 438);
      *(_WORD *)(a3 + 428) = HIWORD(v35);
      *(_WORD *)(a3 + 430) = v36;
      sub_10034B70(
        a3 + 392,
        v32,
        &a4[((v42 + v31) & 0x80000000) != 0 ? 0 : v42 + v31],
        v35 - v29,
        v8 & 0xFFFFFFF3 | 0x80000000,
        0,
        v37);
    }
  }
  else
  {
    *(_WORD *)(a3 + 428) = HIWORD(v35);
    *(_WORD *)(a3 + 430) = v36;
    sub_10034B70(a3 + 392, v32, a4, v35 - v29, v8 | 0x80000000, v34, v37);
  }
  *(_WORD *)(a3 + 436) = v40;
  result = (char)v30;
  *(_WORD *)(a3 + 438) = v39;
  if ( v30 != &v48 )
    result = sub_10002480(a3, (unsigned int)v30);
  return result;
}
// 101BD3BE: using guessed type char byte_101BD3BE;
// 101EF5C0: using guessed type char byte_101EF5C0;

//----- (10009750) --------------------------------------------------------
int __cdecl sub_10009750(unsigned int a1, unsigned int a2, float *a3)
{
  int v3; // esi@1
  char *v4; // eax@1

  v3 = *((_DWORD *)sub_10009140(a1) + 1);
  v4 = sub_100141C0(a2, a3);
  return sub_10034B10(v3, v4, 0);
}

//----- (10009780) --------------------------------------------------------
int sub_10009780()
{
  void *v0; // ebx@1
  unsigned __int8 v1; // al@2
  char *v2; // esi@2
  char v3; // al@2
  int v4; // eax@2
  char v5; // al@2
  int v6; // edi@2
  char v7; // al@2
  int v8; // edi@2
  char v9; // al@2
  int result; // eax@2

  v0 = &unk_1006095C;
  do
  {
    v1 = *(_BYTE *)v0;
    v2 = (char *)&unk_101EFA80 + 20 * ((*((_DWORD *)v0 - 1) >> 10) & 0xF);
    v2[12] = *(_BYTE *)v0;
    *(_DWORD *)v2 = FNT_get_fnt_hdr(v1);
    v3 = *((_BYTE *)v0 + 1);
    v2[13] = v3;
    v4 = FNT_get_fnt_hdr((unsigned __int8)v3);
    *((_DWORD *)v2 + 1) = v4;
    v5 = sub_10034B10(v4, ".", 0);
    v6 = *((_DWORD *)v2 + 1);
    v2[15] = v5;
    v7 = sub_10009200(0x20u, v6, 0x5Fu);
    v8 = *((_DWORD *)v2 + 1);
    v2[16] = v7;
    v2[17] = sub_10009200(0x30u, v8, 0x39u);
    v9 = *((_BYTE *)v0 + 2);
    v2[14] = v9;
    result = FNT_get_fnt_hdr((unsigned __int8)v9);
    v0 = (char *)v0 + 8;
    *((_DWORD *)v2 + 2) = result;
  }
  while ( (signed int)v0 < (signed int)"ib\\adl\\cdp_fld_2d_utl.c" );
  return result;
}
// 100310EE: using guessed type int __cdecl FNT_get_fnt_hdr(_DWORD);

//----- (10009820) --------------------------------------------------------
int __cdecl sub_10009820(int a1, int a2, int a3, unsigned __int8 a4)
{
  _WORD *v4; // eax@1
  int v5; // esi@1
  __int16 v6; // cx@1
  __int16 v7; // dx@1
  _WORD *v8; // edi@1
  int v9; // edx@1
  int result; // eax@3
  int v11; // [sp+10h] [bp-8h]@1
  __int16 v12; // [sp+14h] [bp-4h]@1
  __int16 v13; // [sp+1Ch] [bp+4h]@1
  __int16 v14; // [sp+1Eh] [bp+6h]@1

  v4 = sub_100091C0();
  v5 = a1;
  v6 = *(_WORD *)(a1 + 426);
  v7 = *(_WORD *)(a1 + 424);
  v8 = v4;
  LOWORD(v4) = *(_WORD *)(a1 + 396);
  *(_WORD *)(a1 + 396) = 2;
  v12 = (signed __int16)v4;
  v13 = v6;
  *(_WORD *)(v5 + 426) = v8[3];
  v14 = v7;
  v9 = *(_DWORD *)(v5 + 428);
  *(_WORD *)(v5 + 424) = v8[3];
  v11 = v9;
  if ( a4 >= 2u )
    sub_1000D740("..\\lib\\adl\\cdp_fld_2d_utl.c", 982, 1, 0);
  *(_WORD *)(v5 + 428) = word_100FD810[*((_BYTE *)v8 + a4)];
  *(_WORD *)(v5 + 430) = word_100FD810[*((_BYTE *)v8 + a4 + 2)];
  *(_WORD *)(v5 + 438) = *(_WORD *)a2 + v8[3];
  *(_WORD *)(v5 + 436) = *(_WORD *)(a2 + 2) + v8[3];
  sub_100358B0(v5 + 392, *(_WORD *)a3 - v8[3], *(_WORD *)(a3 + 2) - v8[3], 0);
  *(_WORD *)(v5 + 438) = *(_WORD *)a3 - v8[3];
  *(_WORD *)(v5 + 436) = *(_WORD *)(a2 + 2) + v8[3];
  sub_100358B0(v5 + 392, v8[3] + *(_WORD *)a2, *(_WORD *)(a3 + 2) - v8[3], 0);
  *(_WORD *)(v5 + 426) = v13;
  *(_WORD *)(v5 + 424) = v14;
  result = HIWORD(v11);
  *(_WORD *)(v5 + 396) = v12;
  *(_WORD *)(v5 + 428) = v11;
  *(_WORD *)(v5 + 430) = HIWORD(v11);
  return result;
}
// 100FD810: using guessed type __int16 word_100FD810[];

//----- (100099A0) --------------------------------------------------------
int __cdecl sub_100099A0(unsigned int a1, char a2)
{
  int v2; // eax@1
  int v3; // edx@1
  char v4; // si@1
  signed int v5; // eax@4

  v2 = *((_DWORD *)sub_10009140(a1) + 1);
  v3 = 1;
  v4 = 1;
  if ( !a2 )
  {
    if ( *(_WORD *)(v2 + 22) - *(_WORD *)(v2 + 24) > 1 )
      v3 = *(_WORD *)(v2 + 22) - *(_WORD *)(v2 + 24);
    v5 = *(_WORD *)(v2 + 26);
    if ( v5 > 1 )
      v4 = v5;
  }
  return (((v3 << 8) | (unsigned __int8)v4) << 16) | 0x101;
}

//----- (10009A00) --------------------------------------------------------
char __cdecl sub_10009A00(int a1, const char *a2, int *a3, int a4)
{
  int v4; // eax@1
  unsigned int v5; // edi@1
  int v6; // ebp@1
  int v7; // esi@1
  int v8; // eax@1
  char *v9; // edi@1
  int v10; // ecx@2
  int v11; // ebp@2
  int v12; // ecx@6
  char v14; // [sp+13h] [bp-11h]@1
  char *v15; // [sp+14h] [bp-10h]@1
  unsigned int v16; // [sp+18h] [bp-Ch]@1
  unsigned int v17; // [sp+1Ch] [bp-8h]@1
  __int16 v18; // [sp+20h] [bp-4h]@1
  signed int v19; // [sp+28h] [bp+4h]@1
  __int16 v20; // [sp+2Ch] [bp+8h]@1
  __int16 v21; // [sp+2Eh] [bp+Ah]@1

  v4 = a3[2];
  v5 = (unsigned int)a3[2] >> 24;
  v6 = ((unsigned int)a3[2] >> 16) & 0xFF;
  v16 = v4 & 0xFFFF0001 | 1;
  v14 = 1;
  v17 = (v4 & 0xFFFFFF ^ ((v5 + a4) << 24)) & 0xFFFF0001 | 1;
  v7 = a1;
  v15 = (char *)sub_10002820(a1, strlen(a2) + 1);
  strcpy(v15, a2);
  v21 = *(_WORD *)(a1 + 436);
  v19 = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
  v20 = *(_WORD *)(v7 + 438);
  v8 = v5 + v6 + *(_WORD *)(*a3 + 24) - *(_WORD *)(*a3 + 26);
  v9 = v15;
  v18 = a4 + v8;
  do
  {
    v11 = sub_100091D0(v9);
    *(_WORD *)(v7 + 438) = v20;
    *(_WORD *)(v7 + 436) = v21;
    if ( v11 )
      *(_DWORD *)(v10 + 8) = v17;
    else
      *(_DWORD *)(v10 + 8) = v16;
    if ( *(_BYTE *)(v7 + 3) && (v12 = *(_DWORD *)(v7 + 56), *(_WORD *)(v12 + 240) != -128) )
    {
      if ( v19 >= (signed int)strlen(v9) || v19 < 0 )
      {
        *(_BYTE *)(v7 + 3) = 0;
        sub_10009250(*(_BYTE *)(v12 + 242), -128, v7, v9, a3, 0, 0);
        *(_BYTE *)(v7 + 3) = 1;
      }
      else
      {
        sub_10009250(*(_BYTE *)(v12 + 242), v19, v7, v9, a3, 1, 0);
      }
      v19 -= strlen(v9);
    }
    else
    {
      if ( !v14 )
      {
        LOBYTE(a4) = *(_BYTE *)(v7 + 3);
        *(_BYTE *)(v7 + 3) = 0;
      }
      sub_10009250(
        *(_BYTE *)(*(_DWORD *)(v7 + 56) + 242),
        v19,
        v7,
        v9,
        a3,
        *(_WORD *)(*(_DWORD *)(v7 + 56) + 240) != -128,
        1);
      if ( !v14 )
        *(_BYTE *)(v7 + 3) = a4;
    }
    v21 += v18;
    v9 = (char *)v11;
    v14 = 0;
  }
  while ( v11 );
  return sub_10002480(v7, (unsigned int)v15);
}

//----- (10009C10) --------------------------------------------------------
int __cdecl sub_10009C10(int a1, int a2, unsigned int a3, int a4)
{
  unsigned int v4; // edi@1
  int v5; // eax@1
  unsigned int v6; // ecx@1
  int v7; // edi@1
  int v8; // eax@3
  int result; // eax@3
  int v10; // [sp+18h] [bp+Ch]@1

  v4 = a3;
  v10 = sub_100099A0(a3, 0);
  v5 = *((_DWORD *)sub_10009140(v4) + 1);
  *(_WORD *)(a1 + 2) = HIWORD(a2) + *(_WORD *)(v5 + 26) - BYTE2(v10) - *(_WORD *)(v5 + 24) + 1;
  v7 = v4 & 0xC000;
  *(_WORD *)(a1 + 6) = HIWORD(a2) + *(_WORD *)(v5 + 22) + (v6 >> 24) - *(_WORD *)(v5 + 24) - 1;
  if ( v7 )
  {
    if ( v7 == 0x4000 )
    {
      *(_WORD *)(a1 + 4) = a2 + 1;
      result = a2 + 1 - a4 - 1;
      *(_WORD *)a1 = result;
    }
    else
    {
      v8 = a2 - (a4 + 2) / 2 - 1;
      *(_WORD *)a1 = v8;
      result = v8 + a4 + 2 - 1;
      *(_WORD *)(a1 + 4) = result;
    }
  }
  else
  {
    result = a2 - 1;
    *(_WORD *)(a1 + 4) = a2 - 1 + a4 + 1;
    *(_WORD *)a1 = a2 - 1;
  }
  return result;
}

//----- (10009CE0) --------------------------------------------------------
char __cdecl sub_10009CE0(int a1, char *a2, const char *a3, __int16 a4, __int16 a5, unsigned int a6, __int16 a7)
{
  char *v7; // eax@1
  int v8; // ebx@1
  signed int v9; // edi@1
  signed int v10; // eax@4
  int v11; // ebp@4
  unsigned int v12; // ebx@4
  int v13; // eax@4
  __int16 v14; // cx@4
  int v15; // edx@4
  int v16; // edi@9
  signed int v17; // ecx@12
  __int64 v18; // rax@12
  __int16 v19; // dx@15
  __int16 v20; // dx@15
  int v21; // eax@17
  signed int v22; // edi@17
  int v24; // [sp+10h] [bp-30h]@1
  unsigned int v25; // [sp+14h] [bp-2Ch]@1
  unsigned int v26; // [sp+18h] [bp-28h]@1
  __int16 v27; // [sp+1Ch] [bp-24h]@2
  int v28; // [sp+1Eh] [bp-22h]@1
  int v29; // [sp+24h] [bp-1Ch]@4
  int v30; // [sp+28h] [bp-18h]@4
  unsigned int v31; // [sp+2Ch] [bp-14h]@4
  int v32; // [sp+30h] [bp-10h]@4
  char v33[6]; // [sp+34h] [bp-Ch]@4
  int v34; // [sp+3Ch] [bp-4h]@4

  v28 = sub_10009110(a6);
  v7 = sub_10009140(a6);
  v8 = *((_DWORD *)v7 + 1);
  v24 = *((_DWORD *)v7 + 1);
  v26 = sub_100099A0(a6, 0) & 0xFFFFFF00;
  v9 = sub_10009160(a6);
  v25 = v9 & 0xFFFFFFFE | 2;
  if ( a7 & 0x200 )
  {
    v27 = 0;
    a3 = (const char *)&unk_1005E69C;
  }
  else
  {
    v27 = a5;
  }
  v10 = sub_10009190(a6);
  v11 = v10;
  v29 = v10;
  *(_DWORD *)&v33[2] = sub_10009110(a6);
  v30 = v8;
  v12 = v9 & 0xFFFFFFFC;
  v34 = v11;
  v32 = sub_100099A0(a6, 0);
  v31 = v9 & 0xFFFFFFFC;
  *(_WORD *)v33 = a4;
  v13 = sub_10034B10(v30, a2, v9 & 0xFFFFFFFC);
  v14 = v27;
  v15 = 0;
  if ( v27 > 0 && a4 > 0 )
    v15 = *(_WORD *)(v30 + 28);
  if ( a6 & 0xC000 )
  {
    if ( (a6 & 0xC000) == 0x8000 )
    {
      if ( v27 && a4 )
      {
        v17 = v15 + v27 + a4;
        v18 = v13 - *(_WORD *)(v30 + 28) - v27 + 1;
        v16 = (((signed int)v18 - HIDWORD(v18)) >> 1) - 1;
        LODWORD(v18) = v17 / 2 + v16 + 1;
        LOWORD(v17) = v17 - *(_WORD *)(v30 + 28);
        *(_WORD *)v33 = v18;
        v14 = v17 - v18;
        v27 = v14;
      }
      else
      {
        LOWORD(v16) = 0;
        v31 = v12 & 0xFFFFFFFD | 1;
        v25 = v25 & 0xFFFFFFFD | 1;
      }
    }
    else
    {
      v16 = -v27;
    }
  }
  else
  {
    if ( a4 > v13 )
    {
      v19 = v15 - *(_WORD *)(v30 + 28);
      *(_WORD *)v33 = v13;
      v20 = a4 + v19 - v13;
      v14 = v20 + v27;
      v27 += v20;
    }
    LOWORD(v16) = *(_WORD *)v33 - 1;
  }
  *(_WORD *)(a1 + 438) += v16;
  v21 = *(_DWORD *)(a1 + 56);
  v22 = *(_WORD *)(v21 + 240);
  if ( *(_WORD *)v33 > 0 )
  {
    LOBYTE(v21) = sub_10009250(*(_BYTE *)(v21 + 242), v22, a1, a2, &v30, *(_WORD *)(v21 + 240) != -128, 1);
    v14 = v27;
  }
  if ( v14 > 0 )
  {
    if ( v22 != -128 )
      v22 -= strlen(a2);
    LOBYTE(v21) = sub_10009250(
                    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242),
                    v22,
                    a1,
                    a3,
                    &v24,
                    *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != -128,
                    1);
  }
  return v21;
}

//----- (10009F00) --------------------------------------------------------
void __cdecl sub_10009F00(int a1, int (__cdecl *a2)(int))
{
  char v2; // bl@2

  if ( !*(_DWORD *)(a1 + 72) )
  {
    v2 = sub_10002900(*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 32) + 8));
    if ( sub_10002900(a2) != v2 )
      *(_DWORD *)(a1 + 72) = *(_DWORD *)(*(_DWORD *)(a1 + 32) + 8);
  }
}

//----- (10009F50) --------------------------------------------------------
unsigned int __usercall sub_10009F50@<eax>(unsigned int result@<eax>)
{
  int *v1; // ecx@2
  unsigned int v2; // ecx@3

  if ( !dword_101EFA48 )
  {
    dword_101EFA48 = *(_DWORD *)(result + 32);
    v1 = *(int **)(result + 32);
    if ( v1 )
    {
      v2 = *v1;
      *(_DWORD *)(result + 32) = v2;
      if ( !v2 || *(_DWORD *)(result + 48) < v2 )
        *(_DWORD *)(result + 48) = v2;
      result = v2;
      if ( v2 )
        *(_DWORD *)(v2 + 4) = 0;
    }
  }
  return result;
}
// 101EFA48: using guessed type int dword_101EFA48;

//----- (10009F90) --------------------------------------------------------
int __usercall sub_10009F90@<eax>(int result@<eax>)
{
  if ( dword_101EFA48 )
  {
    *(_DWORD *)(*(_DWORD *)(result + 32) + 4) = dword_101EFA48;
    *(_DWORD *)dword_101EFA48 = *(_DWORD *)(result + 32);
    *(_DWORD *)(result + 32) = dword_101EFA48;
    dword_101EFA48 = 0;
  }
  return result;
}
// 101EFA48: using guessed type int dword_101EFA48;

//----- (10009FC0) --------------------------------------------------------
void __cdecl sub_10009FC0(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4, int a5)
{
  void *v5; // ecx@0
  int v6; // ebx@1
  int v7; // esi@1
  int v8; // edi@1
  int v9; // eax@2
  char v10; // bl@13
  int v11; // eax@22
  int v12; // edx@26
  int v13; // ecx@26
  int v14; // edx@26
  int v15; // ecx@26
  int v16; // edx@26
  int v17; // eax@29
  unsigned int v18; // eax@32
  unsigned int v19; // ebx@34
  int v20; // eax@46
  int v21; // eax@59
  bool v22; // al@63
  int v23; // edx@63
  int (__cdecl *v24)(int); // [sp+10h] [bp-D8h]@1
  unsigned int v25; // [sp+14h] [bp-D4h]@32
  __int16 i; // [sp+18h] [bp-D0h]@25
  unsigned int v27; // [sp+1Ch] [bp-CCh]@25
  int v28; // [sp+20h] [bp-C8h]@25
  int v29; // [sp+24h] [bp-C4h]@25
  int v30; // [sp+28h] [bp-C0h]@26
  int v31; // [sp+2Ch] [bp-BCh]@26
  int v32; // [sp+30h] [bp-B8h]@26
  int v33; // [sp+34h] [bp-B4h]@26
  int v34; // [sp+38h] [bp-B0h]@26
  int v35; // [sp+3Ch] [bp-ACh]@26

  v6 = (int)a3;
  v7 = *(_DWORD *)(a1 + 48);
  v8 = 0;
  v24 = a3;
  if ( v7 )
  {
    v9 = a2;
    switch ( a2 )
    {
      case -1:
        sub_10009F90(a1);
        goto LABEL_4;
      case -5:
LABEL_4:
        v8 = *(_DWORD *)(a1 + 32);
        v7 = 0;
        goto LABEL_20;
      case -2:
        v8 = 0;
        do
        {
          if ( sub_10002940(*(int (__cdecl **)(int))(v7 + 8)) != -1 )
            break;
          v8 = v7;
          v7 = *(_DWORD *)(v7 + 4);
        }
        while ( v7 );
        goto LABEL_20;
      case -3:
        do
        {
          if ( sub_10002940(*(int (__cdecl **)(int))(v7 + 8)) != -1 )
            break;
          v7 = *(_DWORD *)(v7 + 4);
        }
        while ( v7 );
        v8 = v7;
        if ( v7 )
          v7 = *(_DWORD *)(v7 + 4);
        goto LABEL_20;
      case -6:
        v8 = *(_DWORD *)(a1 + 48);
        v10 = sub_10002940(a3);
        if ( !v7 )
          goto LABEL_16;
        break;
      case -7:
        if ( (unsigned __int8)sub_1000E7B0(v5) )
        {
          sub_10009F50(a1);
          v8 = *(_DWORD *)(a1 + 32);
          v7 = 0;
        }
        else
        {
          sub_10009F00(a1, a3);
          v8 = *(_DWORD *)(a1 + 32);
          v7 = 0;
        }
        goto LABEL_20;
      case -8:
        if ( (unsigned __int8)sub_1000E7B0(v5) )
        {
          sub_10009F90(a1);
LABEL_45:
          v7 = *(_DWORD *)(a1 + 32);
          v8 = *(_DWORD *)v7;
        }
        else
        {
          v20 = *(_DWORD *)(a1 + 72);
          if ( v20 )
          {
            v8 = *(_DWORD *)(a1 + 32);
            v7 = 0;
            v24 = *(int (__cdecl **)(int))(a1 + 72);
            *(_DWORD *)(a1 + 72) = 0;
            v6 = v20;
          }
        }
        goto LABEL_20;
      case -4:
        goto LABEL_45;
      default:
        if ( a2 > 0 )
        {
          do
          {
            if ( !v7 )
              break;
            --v9;
            v8 = v7;
            v7 = *(_DWORD *)(v7 + 4);
          }
          while ( v9 > 0 );
        }
        goto LABEL_20;
    }
    do
    {
      if ( sub_10002940(*(int (__cdecl **)(int))(v8 + 8)) == v10 )
      {
        if ( *(int (__cdecl **)(int))(v8 + 8) == a3 )
        {
          v8 = *(_DWORD *)v8;
          v24 = 0;
        }
        v7 = *(_DWORD *)(v8 + 4);
        goto LABEL_19;
      }
      v8 = *(_DWORD *)(v8 + 4);
    }
    while ( v8 );
LABEL_16:
    v7 = *(_DWORD *)(a1 + 48);
    v8 = 0;
    if ( v7 )
    {
      while ( sub_10002940(*(int (__cdecl **)(int))(v7 + 8)) == -1 )
      {
        v7 = *(_DWORD *)(v7 + 4);
        if ( !v7 )
          goto LABEL_19;
      }
      v8 = *(_DWORD *)v7;
    }
LABEL_19:
    v6 = (int)v24;
  }
LABEL_20:
  if ( v6 )
  {
    if ( a4 || (v11 = v7) == 0 )
    {
LABEL_25:
      ++*(_BYTE *)(a1 + 4);
      i = -32703;
      v27 = 0;
      v28 = v6;
      LOBYTE(v29) = 0;
      if ( a5 )
      {
        v12 = *(_DWORD *)(a5 + 4);
        v30 = *(_DWORD *)a5;
        v13 = *(_DWORD *)(a5 + 8);
        v31 = v12;
        v14 = *(_DWORD *)(a5 + 12);
        v32 = v13;
        v15 = *(_DWORD *)(a5 + 16);
        v33 = v14;
        v16 = *(_DWORD *)(a5 + 20);
        v34 = v15;
        v35 = v16;
        LOBYTE(v29) = 1;
      }
      sub_10001700(a1, (int)&i, 204);
    }
    else
    {
      while ( *(_DWORD *)(v11 + 8) != v6 )
      {
        v11 = *(_DWORD *)(v11 + 4);
        if ( !v11 )
          goto LABEL_25;
      }
      v7 = *(_DWORD *)(v11 + 4);
      v8 = v11;
      v24 = 0;
      v6 = 0;
    }
  }
  if ( v8 )
  {
    v17 = sub_10001590(a1, v6);
    if ( !v6 || !v17 || !sub_100010B0(a1, v17) )
    {
      v18 = sub_10001180(a1, v7);
      v25 = v18;
      if ( v18 )
        *(_BYTE *)(v18 + 26) = 0;
      v19 = v7;
      if ( v7 )
      {
        while ( v19 >= v18 )
        {
          i = -32734;
          v27 = v19;
          sub_10001700(a1, (int)&i, 204);
          v19 = *(_DWORD *)(v19 + 4);
          if ( !v19 )
            break;
          v18 = v25;
        }
      }
      v6 = (int)v24;
    }
  }
  if ( !v6 || v8 )
  {
    if ( v7 && v8 )
    {
      i = -32665;
      v27 = v7;
      v22 = sub_100010B0(a1, *(_DWORD *)v7);
      v23 = *(_DWORD *)(a1 + 56);
      LOBYTE(v28) = v22;
      v29 = *(_DWORD *)(v8 + 8);
      *(_BYTE *)(v23 + 25) = v22;
      sub_10001700(a1, (int)&i, 204);
    }
  }
  else
  {
    v21 = *(_DWORD *)(a1 + 48);
    if ( v21 )
    {
      i = -32695;
      v27 = v21;
      sub_10001700(a1, (int)&i, 204);
    }
  }
  for ( i = -32744; v8; v8 = *(_DWORD *)v8 )
  {
    v27 = v8;
    sub_10001700(a1, (int)&i, 204);
  }
}

//----- (1000A370) --------------------------------------------------------
void __cdecl sub_1000A370(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4)
{
  sub_10009FC0(a1, a2, a3, a4, 0);
}

//----- (1000A390) --------------------------------------------------------
void __cdecl sub_1000A390(int a1, unsigned __int8 a2)
{
  int v2; // edi@1
  double v3; // st7@2
  float *v4; // esi@2

  v2 = a2;
  if ( (signed int)a2 > 0 )
  {
    v3 = 9.8999998e24;
    v4 = (float *)(a1 + 8);
    do
    {
      if ( v3 == *(v4 - 1) )
      {
        *v4 = v3;
      }
      else
      {
        *v4 = sub_100160A0(*(v4 - 1), *v4, 40, *(v4 - 2));
        v3 = 9.8999998e24;
      }
      v4 += 3;
      --v2;
    }
    while ( v2 );
  }
}

//----- (1000A3F0) --------------------------------------------------------
void __cdecl sub_1000A3F0(int a1)
{
  unsigned __int8 v1; // bl@1
  int v2; // edi@1
  float v3; // edx@2
  int v4; // eax@7
  char v5; // al@10
  char v6; // al@12
  double v7; // st7@20
  char v8; // [sp+Dh] [bp-9Bh]@1
  char v9; // [sp+Eh] [bp-9Ah]@1
  unsigned __int8 v10; // [sp+Fh] [bp-99h]@1
  float v11; // [sp+10h] [bp-98h]@1
  float v12; // [sp+14h] [bp-94h]@1
  int v13; // [sp+18h] [bp-90h]@1
  int v14; // [sp+1Ch] [bp-8Ch]@1
  float v15; // [sp+20h] [bp-88h]@1
  float v16; // [sp+24h] [bp-84h]@1
  float v17; // [sp+28h] [bp-80h]@1
  int v18; // [sp+2Ch] [bp-7Ch]@1
  int v19; // [sp+30h] [bp-78h]@1
  int v20; // [sp+34h] [bp-74h]@1
  float v21; // [sp+38h] [bp-70h]@1
  int v22; // [sp+3Ch] [bp-6Ch]@1
  char v23; // [sp+40h] [bp-68h]@7
  char v24; // [sp+50h] [bp-58h]@7
  char v25; // [sp+60h] [bp-48h]@7
  char v26; // [sp+80h] [bp-28h]@7

  v15 = sub_100164F0();
  v8 = 1;
  v16 = 6.283185;
  v1 = -1;
  v17 = 6.283185;
  v9 = sub_10016460(&v21);
  LOBYTE(v12) = -1;
  v13 = 0x3FFFF;
  LOBYTE(v11) = -1;
  LOBYTE(v18) = sub_1000AD80(0);
  LOBYTE(v22) = sub_1000AE00(0);
  v2 = sub_1000AB20(0);
  LOBYTE(v20) = sub_1000ADC0(0);
  LOBYTE(v19) = sub_1000AE40(0);
  v14 = sub_1000AC00(0);
  v10 = sub_1000AE80(0);
  if ( sub_10012E40() )
  {
    sub_100162E0();
    v1 = *(_BYTE *)(dword_101F03DC + 812);
    v16 = *(float *)(dword_101F03DC + 776);
    v3 = *(float *)(dword_101F03DC + 780);
    LOBYTE(v11) = v1;
    v17 = v3;
    if ( v1 >= 0x66u && v1 != -1 )
    {
      v1 = -1;
      LOBYTE(v11) = -1;
    }
    sub_100162D0();
    sub_1000AF90(v1, &v12, &v13);
  }
  if ( LOBYTE(v12) == -1 )
  {
    sub_1000F530(a1 + 16, "____", 5);
    *(float *)(a1 + 8) = 6.2831855;
    v7 = 9.8999998e24;
    *(_DWORD *)a1 = 0x7FFFFFFF;
    *(float *)(a1 + 4) = 9.8999998e24;
  }
  else
  {
    sub_1000B830(v13, (int)&v25);
    sub_1000F530(a1 + 16, &v26, 5);
    sub_100379B0((int)&v16, (int)&v24);
    sub_1000B1E0(0, v13, (double *)&v23);
    LOBYTE(v4) = sub_10033190();
    sub_100311B0((int)&v24, (int)&v23, v4, (float *)(a1 + 4), a1 + 8);
    if ( v2 != 0x3FFFF && (sub_1000AEC0(LOBYTE(v11), v2, v18, v22) || sub_1000AEC0(LOBYTE(v11), v14, v20, v19)) )
    {
      v5 = v10;
      if ( v1 > v10 )
        v5 = LOBYTE(v12);
      LOBYTE(v11) = v5;
      v6 = sub_10031100(v11, a1 + 4, a1);
    }
    else
    {
      v6 = sub_10031100(v12, a1 + 4, a1);
    }
    if ( v6 && v9 == 1 && *(_DWORD *)a1 != 0x7FFFFFFF && 9.8999998e24 != v15 && sub_10016180((bool *)&v8) && !v8 )
      v7 = v15 - (double)*(unsigned int *)a1 * v21;
    else
      v7 = 9.8999998e24;
  }
  *(float *)(a1 + 12) = v7;
}
// 101F03DC: using guessed type int dword_101F03DC;

//----- (1000A680) --------------------------------------------------------
char __thiscall sub_1000A680(void *this)
{
  void *v1; // ecx@1
  void *v2; // ecx@2
  int v3; // eax@4
  void *v5; // [sp-2h] [bp-4h]@1

  v5 = this;
  BYTE2(v5) = 0;
  v3 = sub_100128C0(this) == 2 || !(sub_1000EB30(v1) & 2) && sub_100128C0(v2) == 4;
  sub_10031DC0(*(&dword_10061FD4 + v3), (char *)&v5 + 3, 1, (char *)&v5 + 2);
  return BYTE3(v5);
}

//----- (1000A6D0) --------------------------------------------------------
char __cdecl sub_1000A6D0(char a1)
{
  void *v1; // ecx@0
  void *v2; // ecx@1
  void *v3; // ecx@2
  bool v4; // bl@4
  void *v5; // ecx@6
  char result; // al@6
  void *v7; // ecx@6
  char v8; // al@7
  void *v9; // ecx@7
  char v10; // al@8
  void *v11; // ecx@8
  char v12; // al@9

  v4 = sub_100128C0(v1) == 2 || !(sub_1000EB30(v2) & 2) && sub_100128C0(v3) == 4;
  sub_10031CC0(*(&dword_10061FD4 + v4), (int)&a1, 1);
  result = sub_1000EB30(v5);
  if ( !(result & 2) )
  {
    v8 = sub_1000EF10(v7);
    if ( sub_100127D0(v8, 4)
      || (v10 = sub_1000EF10(v9), sub_100127D0(v10, 6))
      || (v12 = sub_1000EF10(v11), (result = sub_100127D0(v12, 8)) != 0) )
    {
      result = sub_10031CC0(*(&dword_10061FD4 + (v4 == 0)), (int)&a1, 1);
    }
  }
  return result;
}

//----- (1000A780) --------------------------------------------------------
int __cdecl sub_1000A780(int a1)
{
  int result; // eax@1
  int v2; // [sp-10h] [bp-E0h]@2
  __int16 *v3; // [sp-Ch] [bp-DCh]@2
  __int16 v4; // [sp+0h] [bp-D0h]@2
  int v5; // [sp+4h] [bp-CCh]@5
  int v6; // [sp+8h] [bp-C8h]@5

  result = a1;
  if ( (unsigned int)(a1 - 108000) > 0x26DE )
  {
    if ( (unsigned int)(a1 - 118000) > 0x4A2E )
      return result;
    v3 = &v4;
    v4 = -32661;
    v2 = 2;
  }
  else
  {
    v3 = &v4;
    v4 = -32660;
    v2 = 10;
  }
  v5 = 0;
  v6 = a1;
  return sub_10031A10(v2, (int)v3, 60000, 1);
}

//----- (1000A810) --------------------------------------------------------
void sub_1000A810()
{
  dword_100FD808 = -15;
}
// 100FD808: using guessed type int dword_100FD808;

//----- (1000A820) --------------------------------------------------------
signed int sub_1000A820()
{
  return sub_100327D0((int)&off_10062530);
}
// 10062530: using guessed type char *off_10062530;

//----- (1000A830) --------------------------------------------------------
char __cdecl sub_1000A830(int a1)
{
  char v1; // bl@1

  v1 = 0;
  if ( (unsigned __int8)sub_1000A820() && !sub_100319E0(98, 500) )
  {
    *(_BYTE *)a1 = *(_BYTE *)(dword_100FD808 + 89561);
    *(_BYTE *)(a1 + 1) = *(_BYTE *)(dword_100FD808 + 89562);
    *(_BYTE *)(a1 + 2) = *(_BYTE *)(dword_100FD808 + 90421);
    *(_BYTE *)(a1 + 3) = *(_BYTE *)(dword_100FD808 + 90422);
    v1 = 1;
    sub_100319C0(98);
  }
  return v1;
}
// 100FD808: using guessed type int dword_100FD808;

//----- (1000A8B0) --------------------------------------------------------
int __cdecl sub_1000A8B0(unsigned __int16 a1, char a2, int a3)
{
  int result; // eax@1
  int v4; // ebp@1
  char v5; // cl@2
  signed int v6; // edi@2
  unsigned __int16 v7; // si@3
  int v8; // ecx@4
  char v9; // dl@5
  int v10; // esi@10
  int v11; // ecx@11
  __int16 v12; // dx@12
  char v13; // bl@13

  result = BMP_get_xfrm(a1);
  v4 = result;
  if ( a2 )
  {
    v5 = *(_BYTE *)(BMP_get_bm_def(a1) + 8);
    result = a3;
    v6 = 1 << v5;
    if ( v4 )
    {
      v10 = 0;
      if ( v6 > 0 )
      {
        v11 = 0;
        do
        {
          v12 = *(_WORD *)(v4 + 2 * v11);
          if ( (unsigned __int16)v12 < 0x100u )
          {
            v13 = byte_100FD838[(unsigned __int16)v12];
            if ( v13 != 127 )
              v12 = word_100FD810[(unsigned __int8)byte_10062AD0[(unsigned __int8)v13]];
          }
          ++v10;
          *(_WORD *)(a3 + 2 * v11) = v12;
          v11 = (unsigned __int16)v10;
        }
        while ( (unsigned __int16)v10 < v6 );
      }
    }
    else
    {
      v7 = 0;
      if ( v6 > 0 )
      {
        v8 = 0;
        do
        {
          v9 = byte_100FD838[v8];
          if ( v9 == 127 )
            *(_WORD *)(a3 + 2 * v8) = v7;
          else
            *(_WORD *)(a3 + 2 * v8) = word_100FD810[(unsigned __int8)byte_10062AD0[(unsigned __int8)v9]];
          v8 = ++v7;
        }
        while ( v7 < v6 );
      }
    }
  }
  return result;
}
// 100310E8: using guessed type int __cdecl BMP_get_bm_def(_DWORD);
// 100310F4: using guessed type int __cdecl BMP_get_xfrm(_DWORD);
// 100FD810: using guessed type __int16 word_100FD810[];

//----- (1000A980) --------------------------------------------------------
int sub_1000A980()
{
  int v0; // ebx@1
  void *v1; // esi@1
  int result; // eax@2

  memset(byte_100FD838, 127, 0x100u);
  v0 = 0;
  v1 = &unk_10062A95;
  do
  {
    LOBYTE(result) = j_HWM_pvg_get_color(*((char *)v1 - 1), *(_BYTE *)v1, *((_BYTE *)v1 + 1));
    word_100FD810[v0] = (unsigned __int8)result;
    result = (unsigned __int8)result;
    byte_100FD838[(unsigned __int8)result] = v0;
    v1 = (char *)v1 + 3;
    ++v0;
  }
  while ( (signed int)v1 < (signed int)&unk_10062ACE );
  return result;
}
// 100323B0: using guessed type int __cdecl j_HWM_pvg_get_color(_DWORD, _DWORD, _DWORD);
// 100FD810: using guessed type __int16 word_100FD810[];

//----- (1000A9E0) --------------------------------------------------------
void sub_1000A9E0()
{
  dword_101EFA68 = -15;
}
// 101EFA68: using guessed type int dword_101EFA68;

//----- (1000A9F0) --------------------------------------------------------
signed int sub_1000A9F0()
{
  return sub_100327D0((int)&off_10062B00);
}
// 10062B00: using guessed type char *off_10062B00;

//----- (1000AA00) --------------------------------------------------------
int __cdecl sub_1000AA00(int a1, int a2)
{
  int result; // eax@1

  result = a2;
  *(float *)a2 = 6.2831855;
  *(float *)(a2 + 4) = 6.2831855;
  switch ( *(_BYTE *)a1 )
  {
    case 1:
    case 4:
    case 0x12:
    case 0x14:
    case 0x15:
      *(_DWORD *)a2 = *(_DWORD *)(a1 + 44);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 48);
      break;
    case 2:
    case 5:
    case 0x13:
    case 0x16:
      *(_DWORD *)a2 = *(_DWORD *)(a1 + 52);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 56);
      break;
    default:
      return result;
  }
  return result;
}

//----- (1000AA70) --------------------------------------------------------
int __cdecl sub_1000AA70(int a1, char a2, void *a3)
{
  int v3; // eax@1
  int result; // eax@3

  sub_100319E0(54, 60000);
  v3 = sub_1000C2A0(a1);
  if ( v3 && (unsigned __int8)a2 < *(_BYTE *)(v3 + 1) )
  {
    qmemcpy(a3, (const void *)(84 * (unsigned __int8)a2 + v3 + 148), 0x3Cu);
    result = sub_100319C0(54);
  }
  else
  {
    memset(a3, 0, 0x3Cu);
    *(_BYTE *)a3 = 24;
    *((_BYTE *)a3 + 1) = 0;
    *((_BYTE *)a3 + 4) = 0;
    *((_BYTE *)a3 + 6) = 0;
    *((_BYTE *)a3 + 7) = 4;
    result = sub_100319C0(54);
  }
  return result;
}

//----- (1000AAF0) --------------------------------------------------------
char __cdecl sub_1000AAF0(__int64 a1)
{
  char result; // al@5

  if ( (unsigned int)a1 < 0x3E8 || (_DWORD)a1 == 262141 )
  {
    result = 4;
  }
  else if ( (_DWORD)a1 == 0x3FFFF || (_DWORD)a1 == 262142 )
  {
    result = 9;
  }
  else
  {
    result = sub_1000C100(a1);
  }
  return result;
}

//----- (1000AB20) --------------------------------------------------------
signed int __cdecl sub_1000AB20(unsigned __int8 a1)
{
  signed int v1; // esi@1
  int v2; // eax@1

  v1 = 0x3FFFF;
  sub_100319E0(54, 60000);
  v2 = sub_1000C2A0(a1);
  if ( v2 && *(_BYTE *)(v2 + 90) != -1 )
    v1 = *(_DWORD *)(v2 + 104);
  sub_100319C0(54);
  return v1;
}

//----- (1000AB60) --------------------------------------------------------
char __cdecl sub_1000AB60(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_100319E0(54, 60000);
  v1 = 0;
  v2 = sub_1000C2A0(a1);
  if ( v2 )
    v1 = *(_BYTE *)(v2 + 1);
  sub_100319C0(54);
  return v1;
}

//----- (1000ABA0) --------------------------------------------------------
signed int __cdecl sub_1000ABA0(unsigned __int8 a1, unsigned __int8 a2)
{
  signed int v2; // esi@1
  int v3; // eax@1

  sub_100319E0(54, 60000);
  v2 = 0x3FFFF;
  v3 = sub_1000C2A0(a1);
  if ( v3 && a2 < *(_BYTE *)(v3 + 1) )
    v2 = sub_10016550(84 * a2 + v3 + 148);
  sub_100319C0(54);
  return v2;
}

//----- (1000AC00) --------------------------------------------------------
signed int __cdecl sub_1000AC00(unsigned __int8 a1)
{
  signed int v1; // esi@1
  int v2; // eax@1

  sub_100319E0(54, 60000);
  v1 = 0x3FFFF;
  v2 = sub_1000C2A0(a1);
  if ( v2 && *(_BYTE *)(v2 + 60) != 3 && *(_BYTE *)(v2 + 61) != 3 )
    v1 = *(_DWORD *)(v2 + 64);
  sub_100319C0(54);
  return v1;
}

//----- (1000AC40) --------------------------------------------------------
char __cdecl sub_1000AC40(int a1)
{
  char result; // al@1
  unsigned __int8 v2; // dl@2
  char v3; // cl@2

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1);
    v3 = 0;
    if ( v2 )
    {
      while ( !(*(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 125) & 1) )
      {
        if ( (unsigned __int8)++v3 >= v2 )
          return result;
      }
      result = v3;
    }
  }
  return result;
}

//----- (1000AC80) --------------------------------------------------------
char __cdecl sub_1000AC80(int a1)
{
  char result; // al@1
  unsigned __int8 v2; // dl@2
  char v3; // cl@2

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1);
    v3 = 0;
    if ( v2 )
    {
      while ( !(*(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 125) & 4) )
      {
        if ( (unsigned __int8)++v3 >= v2 )
          return result;
      }
      result = v3;
    }
  }
  return result;
}

//----- (1000ACC0) --------------------------------------------------------
char __cdecl sub_1000ACC0(int a1)
{
  char result; // al@1
  int v2; // ecx@2
  _BYTE *v3; // edx@3

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1) - 1;
    if ( v2 >= 0 )
    {
      v3 = (_BYTE *)(84 * v2 + a1 + 125);
      while ( !(*v3 & 1) )
      {
        --v2;
        v3 -= 84;
        if ( v2 < 0 )
          return result;
      }
      result = v2;
    }
  }
  return result;
}

//----- (1000AD00) --------------------------------------------------------
char __cdecl sub_1000AD00(int a1)
{
  char result; // al@1
  int v2; // ecx@2
  _BYTE *v3; // edx@3

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1) - 1;
    if ( v2 >= 0 )
    {
      v3 = (_BYTE *)(84 * v2 + a1 + 125);
      while ( !(*v3 & 4) )
      {
        --v2;
        v3 -= 84;
        if ( v2 < 0 )
          return result;
      }
      result = v2;
    }
  }
  return result;
}

//----- (1000AD40) --------------------------------------------------------
char __cdecl sub_1000AD40(int a1)
{
  char result; // al@1
  unsigned __int8 v2; // dl@2
  char v3; // cl@2

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1);
    v3 = 0;
    if ( v2 )
    {
      while ( *(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 154) != 3 )
      {
        if ( (unsigned __int8)++v3 >= v2 )
          return result;
      }
      result = v3;
    }
  }
  return result;
}

//----- (1000AD80) --------------------------------------------------------
char __cdecl sub_1000AD80(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_100319E0(54, 60000);
  v1 = -1;
  v2 = sub_1000C2A0(a1);
  if ( v2 )
    v1 = sub_1000AC40(v2);
  sub_100319C0(54);
  return v1;
}

//----- (1000ADC0) --------------------------------------------------------
char __cdecl sub_1000ADC0(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_100319E0(54, 60000);
  v1 = -1;
  v2 = sub_1000C2A0(a1);
  if ( v2 )
    v1 = sub_1000AC80(v2);
  sub_100319C0(54);
  return v1;
}

//----- (1000AE00) --------------------------------------------------------
char __cdecl sub_1000AE00(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_100319E0(54, 60000);
  v1 = -1;
  v2 = sub_1000C2A0(a1);
  if ( v2 )
    v1 = sub_1000ACC0(v2);
  sub_100319C0(54);
  return v1;
}

//----- (1000AE40) --------------------------------------------------------
char __cdecl sub_1000AE40(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_100319E0(54, 60000);
  v1 = -1;
  v2 = sub_1000C2A0(a1);
  if ( v2 )
    v1 = sub_1000AD00(v2);
  sub_100319C0(54);
  return v1;
}

//----- (1000AE80) --------------------------------------------------------
char __cdecl sub_1000AE80(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_100319E0(54, 60000);
  v1 = -1;
  v2 = sub_1000C2A0(a1);
  if ( v2 )
    v1 = sub_1000AD40(v2);
  sub_100319C0(54);
  return v1;
}

//----- (1000AEC0) --------------------------------------------------------
char __cdecl sub_1000AEC0(unsigned __int8 a1, int a2, unsigned __int8 a3, unsigned __int8 a4)
{
  char result; // al@1

  result = 0;
  if ( a2 != 0x3FFFF && a1 != -1 && a1 >= a3 && a1 <= a4 )
    result = 1;
  return result;
}

//----- (1000AEF0) --------------------------------------------------------
char __usercall sub_1000AEF0@<al>(signed int a1@<eax>, unsigned __int8 a2@<cl>, int a3@<edi>, unsigned __int8 a4, signed int *a5, _BYTE *a6)
{
  signed int v6; // esi@3
  int v7; // ebx@6
  int v8; // edi@6
  signed int v9; // esi@7
  __int64 v11; // [sp-Ch] [bp-14h]@6
  __int64 v12; // [sp-4h] [bp-Ch]@0

  *a5 = 0x3FFFF;
  *a6 = -1;
  if ( (_BYTE)a1 == -1 || a2 )
  {
    HIDWORD(v11) = a3;
    v7 = a2;
    v8 = (unsigned __int8)a1;
    if ( a2 >= (signed int)(unsigned __int8)a1 )
    {
      while ( 1 )
      {
        a1 = sub_1000ABA0(a4, v7);
        v9 = a1;
        if ( a1 != 0x3FFFF )
        {
          LODWORD(v11) = a1;
          LOBYTE(a1) = sub_1000C100(v11);
          if ( !(_BYTE)a1 )
            break;
        }
        if ( --v7 < v8 )
          return a1;
      }
      LOBYTE(a1) = (_BYTE)a5;
      *a6 = v7;
      *a5 = v9;
    }
  }
  else
  {
    a1 = sub_1000ABA0(a4, 0);
    v6 = a1;
    if ( a1 != 0x3FFFF )
    {
      LODWORD(v12) = a1;
      LOBYTE(a1) = sub_1000C100(v12);
      if ( !(_BYTE)a1 )
      {
        LOBYTE(a1) = (_BYTE)a6;
        *a6 = 0;
        *a5 = v6;
      }
    }
  }
  return a1;
}
// 1000AEF0: could not find valid save-restore pair for edi

//----- (1000AF90) --------------------------------------------------------
char __usercall sub_1000AF90@<al>(int a1@<ebx>, _BYTE *a2, int *a3)
{
  int v3; // ebp@1
  signed int v4; // esi@1
  int *v5; // esi@4
  _BYTE *v6; // edi@4
  signed int v7; // eax@4
  char v8; // bl@5
  unsigned __int8 v9; // dl@15
  char v10; // cl@20
  unsigned __int8 v11; // cl@26
  unsigned __int8 v13; // [sp-10h] [bp-38h]@23
  signed int *v14; // [sp-Ch] [bp-34h]@23
  __int64 v15; // [sp-8h] [bp-30h]@5
  _BYTE *v16; // [sp-8h] [bp-30h]@23
  char v17; // [sp+Ch] [bp-1Ch]@1
  char v18; // [sp+Dh] [bp-1Bh]@1
  char v19; // [sp+Eh] [bp-1Ah]@2
  char v20; // [sp+Fh] [bp-19h]@15
  int v21; // [sp+10h] [bp-18h]@1
  unsigned __int8 v22; // [sp+14h] [bp-14h]@1
  int v23; // [sp+18h] [bp-10h]@5
  unsigned __int8 v24; // [sp+1Ch] [bp-Ch]@1
  unsigned __int8 v25; // [sp+20h] [bp-8h]@1
  unsigned __int8 v26; // [sp+24h] [bp-4h]@1
  char v27; // [sp+2Ch] [bp+4h]@5
  unsigned __int8 v28; // [sp+30h] [bp+8h]@5
  char v29; // [sp+30h] [bp+8h]@15

  v18 = sub_1000AB60(0);
  v25 = sub_1000AD80(0);
  v26 = sub_1000AE00(0);
  v3 = sub_1000AB20(0);
  v24 = sub_1000ADC0(0);
  v22 = sub_1000AE40(0);
  v4 = sub_1000AC00(0);
  v21 = v4;
  v17 = sub_1000AE80(0);
  if ( v3 != 0x3FFFF || (v19 = 0, v4 != 0x3FFFF) )
    v19 = 1;
  v5 = a3;
  v6 = a2;
  *a3 = 0x3FFFF;
  *a2 = -1;
  LOBYTE(v7) = sub_10012E40();
  if ( (_BYTE)v7 )
  {
    HIDWORD(v15) = a1;
    sub_100162E0();
    v8 = *(_BYTE *)(dword_101F03DC + 812);
    v27 = *(_BYTE *)(dword_101F03DC + 816);
    v23 = *(_DWORD *)(dword_101F03DC + 840);
    v28 = v8;
    if ( (unsigned __int8)v8 >= 0x66u && v8 != -1 )
    {
      v8 = -1;
      v28 = -1;
    }
    if ( ((unsigned __int8)v8 > (unsigned __int8)v18
       || *(_BYTE *)(dword_101F03D0 + 4) != v18
       || *(_DWORD *)(dword_101F03D0 + 264) != v3
       || *(_DWORD *)(dword_101F03D0 + 604) != v21)
      && *(_BYTE *)(dword_101F03DC + 816) != 3 )
    {
      v8 = -1;
      v28 = -1;
    }
    LOBYTE(v7) = sub_100162D0();
    if ( v8 != -1 )
    {
      v29 = sub_1000AEC0(v28, v3, v25, v26);
      LOBYTE(v7) = sub_1000AEC0(v9, v21, v24, v22);
      v20 = v7;
      if ( v27 == 3 )
      {
        LODWORD(v15) = v23;
        if ( !sub_1000C100(v15) )
        {
          LOBYTE(v7) = v23;
          *v5 = v23;
          *v6 = v8;
          return v7;
        }
        LOBYTE(v7) = v20;
LABEL_29:
        if ( v29 == 1 )
        {
          LOBYTE(v7) = v17;
          if ( (unsigned __int8)v8 > (unsigned __int8)v17 )
          {
            v11 = v26;
LABEL_37:
            v16 = v6;
            v14 = v5;
            LOBYTE(v7) = v8;
            v13 = 0;
            goto LABEL_38;
          }
          *v5 = v3;
          *v6 = v17;
          goto LABEL_39;
        }
LABEL_33:
        if ( (_BYTE)v7 == 1 )
        {
          if ( v3 == 0x3FFFF )
          {
            v11 = v22;
            goto LABEL_37;
          }
          *v5 = v3;
          *v6 = v17;
        }
LABEL_39:
        if ( v27 != 3 && *v5 == 0x3FFFF && *v6 == -1 )
        {
          if ( v3 == 0x3FFFF )
          {
            LOBYTE(v7) = v21;
            if ( v21 != 0x3FFFF )
            {
              *v5 = v21;
              LOBYTE(v7) = v22;
              *v6 = v22;
            }
          }
          else
          {
            *v5 = v3;
            *v6 = v17;
          }
        }
        return v7;
      }
      if ( v27 != 2 && v27 != 1 )
        goto LABEL_29;
      v10 = v18;
      if ( !v18 || v29 )
        goto LABEL_29;
      if ( (_BYTE)v7 )
        goto LABEL_33;
      v16 = v6;
      v14 = v5;
      LOBYTE(v7) = v8;
      v13 = 0;
      if ( v19 == 1 )
      {
        if ( v21 == 0x3FFFF )
        {
          v11 = v25 - 1;
          goto LABEL_38;
        }
        v10 = v24;
      }
      v11 = v10 - 1;
LABEL_38:
      LOBYTE(v7) = sub_1000AEF0(v7, v11, (int)v6, v13, v14, v16);
      goto LABEL_39;
    }
  }
  return v7;
}
// 1000AF90: could not find valid save-restore pair for ebx
// 101F03D0: using guessed type int dword_101F03D0;
// 101F03DC: using guessed type int dword_101F03DC;

//----- (1000B1E0) --------------------------------------------------------
double *__cdecl sub_1000B1E0(char a1, char a2, double *a3)
{
  unsigned int v3; // esi@1
  double *result; // eax@10
  __int64 v5; // [sp-4h] [bp-60h]@0
  int v6; // [sp+4h] [bp-58h]@7
  char v7; // [sp+8h] [bp-54h]@10
  double v8; // [sp+10h] [bp-4Ch]@3
  double v9; // [sp+18h] [bp-44h]@10
  char v10; // [sp+20h] [bp-3Ch]@10

  v3 = a2;
  if ( a2 == 0x3FFFF )
    goto LABEL_11;
  if ( (unsigned int)a2 >= 0x3E8 )
  {
    if ( a2 == 262141 )
    {
      sub_10012F80(a1, (int)&v8);
      goto LABEL_13;
    }
    LODWORD(v5) = a2;
    if ( sub_1000AAF0(v5) != 11 )
    {
      sub_1000C670(v3, (int)&v8);
      goto LABEL_13;
    }
    sub_1000C2E0(v3, &v6, &a2);
    if ( (_BYTE)v6 != -1 && a2 != -1 && sub_1000ABA0(v6, a2) == v3 )
    {
      sub_1000AA70(v6, a2, &v10);
      sub_1000AA00((int)&v10, (int)&v7);
      sub_100379B0((int)&v7, (int)&v8);
      result = a3;
      *a3 = v8;
      result[1] = v9;
      return result;
    }
LABEL_11:
    result = a3;
    v8 = 6.2831853071796;
    v9 = 6.2831853071796;
    *a3 = 6.2831853071796;
    result[1] = v9;
    return result;
  }
  sub_1000C230(a2, (int)&v8);
LABEL_13:
  result = a3;
  *a3 = v8;
  result[1] = v9;
  return result;
}

//----- (1000B310) --------------------------------------------------------
int __cdecl sub_1000B310(int a1)
{
  int result; // eax@1
  signed int v2; // ecx@1
  unsigned __int16 v3; // [sp+Ch] [bp+4h]@1

  result = 0;
  v3 = *(_WORD *)(a1 + 4);
  v2 = 0;
  do
  {
    if ( v3 & (unsigned __int16)(1 << v2) )
      result += (unsigned __int16)word_101F0282;
    ++v2;
  }
  while ( v2 < 16 );
  return result;
}
// 101F0282: using guessed type __int16 word_101F0282;

//----- (1000B350) --------------------------------------------------------
signed int __thiscall sub_1000B350(int this)
{
  int v1; // edi@1
  signed int result; // eax@1
  int v3; // ebx@2
  int v4; // esi@2
  __int16 v5; // cx@2
  char *v6; // eax@2
  unsigned __int16 v7; // [sp+4h] [bp-A4h]@2

  v1 = this;
  result = 0xFFFFFF;
  if ( *(_BYTE *)(this + 4) & 0x10 )
  {
    v3 = *(_DWORD *)this;
    v4 = v3 + sub_1000B310(this);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_101EFA5C)(v3, 160, &v7);
    v5 = *(_WORD *)(v1 + 4);
    v6 = (char *)&v7;
    if ( v5 & 1 )
    {
      v4 += v7;
      v6 = (char *)&v7 + (unsigned __int16)word_101F0282;
    }
    if ( v5 & 2 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_101F0282;
    }
    if ( v5 & 4 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_101F0282;
    }
    if ( v5 & 8 )
      v4 += *(_WORD *)v6;
    result = v4;
  }
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101F0282: using guessed type __int16 word_101F0282;

//----- (1000B400) --------------------------------------------------------
signed int __usercall sub_1000B400@<eax>(int a1@<edi>)
{
  signed int result; // eax@1
  int v2; // ebx@2
  int v3; // esi@2
  __int16 v4; // ax@2
  char *v5; // ecx@2
  unsigned __int16 v6; // [sp+0h] [bp-A4h]@2

  result = 0xFFFFFF;
  if ( *(_BYTE *)(a1 + 4) & 4 )
  {
    v2 = *(_DWORD *)a1;
    v3 = v2 + sub_1000B310(a1);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_101EFA5C)(v2, 160, &v6);
    v4 = *(_WORD *)(a1 + 4);
    v5 = (char *)&v6;
    if ( v4 & 1 )
    {
      v3 += v6;
      v5 = (char *)&v6 + (unsigned __int16)word_101F0282;
    }
    if ( v4 & 2 )
      v3 += *(_WORD *)v5;
    result = v3;
  }
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101F0282: using guessed type __int16 word_101F0282;

//----- (1000B490) --------------------------------------------------------
signed int __thiscall sub_1000B490(int this)
{
  int v1; // edi@1
  signed int result; // eax@1
  int v3; // ebx@2
  int v4; // esi@2
  __int16 v5; // cx@2
  char *v6; // eax@2
  unsigned __int16 v7; // [sp+4h] [bp-A4h]@2

  v1 = this;
  result = 0xFFFFFF;
  if ( *(_BYTE *)(this + 4) & 8 )
  {
    v3 = *(_DWORD *)this;
    v4 = v3 + sub_1000B310(this);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_101EFA5C)(v3, 160, &v7);
    v5 = *(_WORD *)(v1 + 4);
    v6 = (char *)&v7;
    if ( v5 & 1 )
    {
      v4 += v7;
      v6 = (char *)&v7 + (unsigned __int16)word_101F0282;
    }
    if ( v5 & 2 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_101F0282;
    }
    if ( v5 & 4 )
      v4 += *(_WORD *)v6;
    result = v4;
  }
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101F0282: using guessed type __int16 word_101F0282;

//----- (1000B530) --------------------------------------------------------
char __usercall sub_1000B530@<al>(int a1@<eax>, char a2)
{
  int v2; // ecx@2
  char v3; // cl@2
  int v4; // eax@2
  unsigned int v5; // eax@3
  unsigned int v6; // ecx@3
  int v7; // eax@5

  if ( a2 == 2 )
  {
    v2 = *(_DWORD *)(a1 + 12) >> 22;
    v4 = *(_DWORD *)(a1 + 4) >> 30;
    v3 = v2 & 3;
    LOBYTE(v4) = v4 & 3;
  }
  else
  {
    v5 = *(_DWORD *)(a1 + 12);
    v6 = v5 >> 23;
    v4 = v5 >> 22;
    v3 = v6 & 1;
    LOBYTE(v4) = v4 & 1;
  }
  if ( v3 == 1 )
  {
    LOBYTE(v4) = (_BYTE)v4 == 1;
    v7 = 2 * v4 + 1;
  }
  else if ( (_BYTE)v4 == 1 )
  {
    LOBYTE(v7) = 2;
  }
  else if ( v3 == 2 || (_BYTE)v4 == 2 )
  {
    LOBYTE(v7) = 5;
  }
  else
  {
    LOBYTE(v7) = 0;
  }
  return v7;
}

//----- (1000B580) --------------------------------------------------------
int __usercall sub_1000B580@<eax>(int a1@<esi>)
{
  int result; // eax@1

  result = 0xFFFFFF;
  if ( *(_BYTE *)(a1 + 4) & 1 )
    result = *(_DWORD *)a1 + sub_1000B310(a1);
  return result;
}

//----- (1000B5A0) --------------------------------------------------------
char __usercall sub_1000B5A0@<al>(unsigned int a1@<eax>, unsigned int *a2@<ebx>, _BYTE *a3@<edi>, int a4@<esi>, _DWORD *a5, int *a6)
{
  int *v6; // ebp@1

  v6 = a6;
  *a6 = 1000;
  *(_BYTE *)a1 = 95;
  *a2 = 1000;
  *a3 = 95;
  if ( *(_BYTE *)(a4 + 3) & 0x1F )
  {
    *v6 = *(_BYTE *)(a4 + 3) & 0x1F;
    *(_BYTE *)a1 = byte_10064D80[((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7];
    *a2 = (*(_BYTE *)(a4 + 3) & 0x1F) + 18;
    a1 = ((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7;
    *a3 = byte_10064D78[a1];
  }
  if ( *(_BYTE *)(a4 + 5) & 4 )
  {
    (*(void (__cdecl **)(_DWORD, signed int, int **))dword_101EFA5C)(*a5, 1, &a6);
    *a5 += (unsigned __int16)word_101F0286;
    LOBYTE(a1) = (_BYTE)a6;
    if ( (unsigned __int8)a6 & 0x1F )
    {
      a1 = ((unsigned __int8)a6 & 0x1F) + 18;
      *a2 = a1;
      *a3 = byte_10064D78[((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7];
    }
    else
    {
      *a2 = 1000;
      *a3 = 95;
    }
  }
  return a1;
}
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101F0286: using guessed type __int16 word_101F0286;

//----- (1000B660) --------------------------------------------------------
void *__usercall sub_1000B660@<eax>(int a1@<eax>, char *a2@<esi>)
{
  int v2; // ST0C_4@2
  int v3; // eax@2
  void *result; // eax@2

  if ( *(_WORD *)(a1 + 10) & 0x8000 )
  {
    LOWORD(v2) = *(_WORD *)(a1 + 22);
    HIWORD(v2) = (*(_DWORD *)(a1 + 16) >> 25) & 0x7F;
    v3 = v2 + dword_101EFBE4;
    *(_DWORD *)a2 = v2 + dword_101EFBE4;
    result = (void *)(*(int (__cdecl **)(int, signed int, char *, int))dword_101EFA5C)(v3, 2, a2 + 4, v2);
    *(_DWORD *)a2 += (unsigned __int16)word_101EFBE8;
  }
  else
  {
    result = memcpy(a2, &unk_10064D88, 6u);
  }
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101EFBE4: using guessed type int dword_101EFBE4;
// 101EFBE8: using guessed type __int16 word_101EFBE8;

//----- (1000B6C0) --------------------------------------------------------
__int16 __usercall sub_1000B6C0@<ax>(int a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // edi@1
  int v4; // eax@1
  int v5; // edi@2
  int v6; // ecx@6
  int v7; // edx@10
  char v8; // cl@10
  unsigned int v9; // eax@10
  int v10; // edx@16
  int v12; // [sp+0h] [bp-20h]@0
  __int16 v13; // [sp+Ch] [bp-14h]@2
  __int16 v14; // [sp+Eh] [bp-12h]@6
  int v15; // [sp+10h] [bp-10h]@2

  v3 = a1;
  sub_1000C590(a3 & 0x3FFFF, v12);
  *(_DWORD *)a2 >>= 7;
  *(_DWORD *)(a2 + 4) >>= 7;
  LOWORD(v4) = HIWORD(a3) >> 10;
  if ( HIWORD(a3) >> 10 != 5 )
  {
    if ( (_WORD)v4 == 6 )
    {
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_101EFA5C)(v3, 9, &v13);
      v7 = *(_DWORD *)a2 - 16 * v14;
      v8 = v15;
      v9 = (unsigned int)(unsigned __int8)v15 >> 4;
    }
    else
    {
      if ( (_WORD)v4 == 7 )
      {
        (*(void (__cdecl **)(int, signed int, __int16 *))dword_101EFA5C)(v3, 11, &v13);
      }
      else
      {
        if ( (_WORD)v4 != 8 )
          return v4;
        (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_101EFA5C)(v3, 15, &v13);
      }
      v7 = *(_DWORD *)a2 - 16 * v14;
      v8 = v15;
      v9 = (unsigned __int8)v15 >> 4;
    }
    *(_DWORD *)a2 = (v7 - (v8 & 0xF)) << 7;
    v10 = *(_DWORD *)(a2 + 4) - v9;
    v4 = 16 * v13;
    *(_DWORD *)(a2 + 4) = (v10 - v4) << 7;
    return v4;
  }
  (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_101EFA5C)(v3, 7, &v13);
  LOWORD(v4) = v15;
  v5 = (unsigned __int16)word_101F0284 + v3;
  if ( BYTE1(v15) & 8 )
  {
    if ( BYTE1(v15) & 4 )
      v5 += (unsigned __int16)word_101F0286;
    (*(void (__cdecl **)(int, signed int, __int16 *))dword_101EFA5C)(v5, 19, &v13);
    if ( (HIWORD(a3) & 0x3FCu) > 0x1FC )
    {
      v4 = (signed __int16)v15;
      *(_DWORD *)a2 -= SHIWORD(v15);
      *(_DWORD *)(a2 + 4) -= v4;
      *(_DWORD *)a2 <<= 7;
      *(_DWORD *)(a2 + 4) <<= 7;
    }
    else
    {
      LOWORD(v4) = v14;
      v6 = v13;
      *(_DWORD *)a2 -= v14;
      *(_DWORD *)(a2 + 4) -= v6;
      *(_DWORD *)a2 <<= 7;
      *(_DWORD *)(a2 + 4) <<= 7;
    }
  }
  else
  {
    *(_DWORD *)a2 = 0x7FFFFFFF;
    *(_DWORD *)(a2 + 4) = 0x7FFFFFFF;
  }
  return v4;
}
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101F0284: using guessed type __int16 word_101F0284;
// 101F0286: using guessed type __int16 word_101F0286;

//----- (1000B830) --------------------------------------------------------
char __cdecl sub_1000B830(unsigned int a1, int a2)
{
  int v2; // esi@1
  int v3; // ebp@1
  __int64 v4; // ST00_8@1
  char result; // al@1
  int v6; // eax@2
  unsigned int v7; // edi@2
  unsigned int v8; // ecx@2
  unsigned __int8 v9; // al@2
  char v10; // dl@2
  unsigned __int8 v11; // cl@3
  char v12; // dl@3
  char v13; // cl@3
  unsigned int v14; // ebp@4
  unsigned __int8 v15; // cl@4
  unsigned int v16; // eax@5
  char v17; // [sp+14h] [bp-20h]@2
  unsigned int v18; // [sp+18h] [bp-1Ch]@2
  int v19; // [sp+1Eh] [bp-16h]@2
  unsigned int v20; // [sp+24h] [bp-10h]@2
  unsigned int v21; // [sp+28h] [bp-Ch]@2
  __int16 v22; // [sp+2Dh] [bp-7h]@8
  unsigned __int8 v23; // [sp+2Fh] [bp-5h]@3
  unsigned __int8 v24; // [sp+30h] [bp-4h]@3
  unsigned __int8 v25; // [sp+3Ch] [bp+8h]@1
  int v26; // [sp+3Ch] [bp+8h]@8

  v2 = a2;
  v3 = a2 + 32;
  memcpy((void *)(a2 + 32), "______", 7u);
  *(double *)a2 = 6.2831853071796;
  *(double *)(a2 + 8) = 6.2831853071796;
  *(float *)(a2 + 16) = 9.9999996e24;
  *(_BYTE *)(a2 + 62) = byte_101EFB54;
  *(_BYTE *)(a2 + 58) = 0;
  *(_BYTE *)(a2 + 63) = 0;
  *(_BYTE *)(a2 + 64) = 0;
  *(_BYTE *)(a2 + 65) = 0;
  *(_BYTE *)(a2 + 66) = 0;
  *(_DWORD *)(a2 + 20) = 0;
  *(_DWORD *)(a2 + 28) = 0x3FFFF;
  *(_DWORD *)(a2 + 24) = 0;
  *(_BYTE *)(a2 + 67) = 2;
  *(_BYTE *)(a2 + 59) = 0;
  *(_BYTE *)(a2 + 60) = 0;
  *(_BYTE *)(a2 + 61) = 0;
  sub_1000F530(a2 + 39, " ", 9);
  sub_1000F530(a2 + 52, " ", 6);
  sub_1000F530(a2 + 48, " ", 4);
  LODWORD(v4) = a1;
  v25 = sub_10016A50();
  result = sub_1000C100(v4);
  if ( !result )
  {
    sub_1000C450(a1, v3);
    sub_1000C670(a1, v2);
    v6 = sub_1000C0D0(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_101EFA5C)(v6, 29, &v17);
    v7 = v18;
    v8 = v21 >> 13;
    v9 = (v18 >> 26) & 7;
    v10 = (v20 >> 23) & 1;
    *(float *)(v2 + 16) = (double)((v19 & 0x7FFF) - 5000) * 0.3048000037670135;
    *(_BYTE *)(v2 + 62) = v9;
    *(_BYTE *)(v2 + 58) = v10;
    *(_BYTE *)(v2 + 63) = v8 & 7;
    if ( v25 == 2 )
    {
      v11 = v24;
      *(_BYTE *)(v2 + 65) = v24 & 7;
      *(_BYTE *)(v2 + 66) = (v23 >> 4) & 7;
      *(_BYTE *)(v2 + 67) = (*(unsigned int *)((char *)&v19 + 2) >> 29) & 3;
      *(_BYTE *)(v2 + 59) = (v11 >> 3) & 1;
      v12 = v11 >> 4;
      v13 = v11 >> 5;
    }
    else
    {
      v14 = *(int *)((char *)&v19 + 2);
      *(_BYTE *)(v2 + 65) = (*(unsigned int *)((char *)&v19 + 2) >> 30) & 3;
      *(_BYTE *)(v2 + 66) = (v7 >> 30) & 3;
      *(_BYTE *)(v2 + 67) = (v14 >> 29) & 1;
      v15 = v23;
      *(_BYTE *)(v2 + 59) = (v23 >> 2) & 1;
      v12 = v15 >> 3;
      v13 = v15 >> 4;
    }
    *(_BYTE *)(v2 + 61) = v13 & 1;
    *(_BYTE *)(v2 + 60) = v12 & 1;
    sub_1000F530(v2 + 39, (_BYTE *)(dword_101F03B0 + 25 * (v9 + 64)), 9);
    sub_1000F530(v2 + 52, (_BYTE *)(dword_101F03B0 + 25 * (*(_BYTE *)(v2 + 66) + 128)), 6);
    sub_1000F530(v2 + 48, (_BYTE *)(dword_101F03B0 + 25 * (*(_BYTE *)(v2 + 65) + 192)), 4);
    v16 = (*(unsigned int *)((char *)&v19 + 2) >> 24) & 0x1F;
    *(_DWORD *)(v2 + 20) = v16;
    if ( v16 != 31 )
      *(_DWORD *)(v2 + 20) = 12 - v16;
    *(_DWORD *)(v2 + 24) = v21 & 0x1FFF;
    result = sub_1000B530((int)&v17, v25);
    *(_BYTE *)(v2 + 64) = result;
    if ( (unsigned __int16)word_101EFBC4 >= 0x1Cu )
    {
      result = v22;
      HIWORD(v26) = v23 & 3;
      LOWORD(v26) = v22;
      *(_DWORD *)(v2 + 28) = v26;
    }
  }
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101EFB54: using guessed type char byte_101EFB54;
// 101EFBC4: using guessed type __int16 word_101EFBC4;
// 101F03B0: using guessed type int dword_101F03B0;

//----- (1000BAB0) --------------------------------------------------------
void *__cdecl sub_1000BAB0(unsigned int a1, char *a2)
{
  int v2; // eax@2
  __int64 v4; // [sp-4h] [bp-24h]@0
  char v5; // [sp+4h] [bp-1Ch]@2
  __int16 v6; // [sp+Eh] [bp-12h]@1

  v6 &= 0x7FFFu;
  LODWORD(v4) = a1;
  if ( !sub_1000C100(v4) )
  {
    v2 = sub_1000C0D0(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_101EFA5C)(v2, 28, &v5);
  }
  return sub_1000B660((int)&v5, a2);
}
// 101EFA5C: using guessed type int dword_101EFA5C;

//----- (1000BB00) --------------------------------------------------------
signed int __cdecl sub_1000BB00(unsigned __int8 a1)
{
  int v1; // ecx@0
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-10h]@3
  int v6; // [sp+Eh] [bp-6h]@3

  result = sub_1000B350(v1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a1 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_101EFA5C)(v3, 15, &v5);
        if ( !(v6 & 0x400) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_101F028C;
        if ( v6 & 0x200 )
          v3 += (unsigned __int16)word_101F028E;
        if ( v4 >= a1 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101F028C: using guessed type __int16 word_101F028C;
// 101F028E: using guessed type __int16 word_101F028E;

//----- (1000BB80) --------------------------------------------------------
signed int __usercall sub_1000BB80@<eax>(int a1@<edi>, unsigned __int8 a2)
{
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-Ch]@3
  char v6; // [sp+9h] [bp-7h]@3

  result = sub_1000B400(a1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a2 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_101EFA5C)(v3, 9, &v5);
        if ( !(v6 & 1) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_101F02A4;
        if ( v4 >= a2 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101F02A4: using guessed type __int16 word_101F02A4;

//----- (1000BBF0) --------------------------------------------------------
signed int __cdecl sub_1000BBF0(unsigned __int8 a1)
{
  int v1; // ecx@0
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-Ch]@3
  int v6; // [sp+Ch] [bp-4h]@3

  result = sub_1000B490(v1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a1 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_101EFA5C)(v3, 11, &v5);
        if ( !(v6 & 0x8000) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_101F02A6;
        if ( v4 >= a1 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101F02A6: using guessed type __int16 word_101F02A6;

//----- (1000BC60) --------------------------------------------------------
int __usercall sub_1000BC60@<eax>(int a1@<eax>, char a2)
{
  int result; // eax@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // [sp+4h] [bp-8h]@3
  char v6; // [sp+6h] [bp-6h]@3
  char v7; // [sp+9h] [bp-3h]@4

  result = sub_1000B580(a1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a2 > 0 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(int, signed int, char *))dword_101EFA5C)(v3, 7, &v5);
        if ( !(v6 & 0x80) )
          break;
        v3 += (unsigned __int16)word_101F0284;
        ++v4;
        if ( v7 & 4 )
          v3 += (unsigned __int16)word_101F0286;
        if ( v7 & 8 )
          v3 += (unsigned __int16)word_101F0288;
        if ( v7 & 0x10 )
          v3 += (unsigned __int16)word_101F028A;
        if ( v4 >= a2 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101F0284: using guessed type __int16 word_101F0284;
// 101F0286: using guessed type __int16 word_101F0286;
// 101F0288: using guessed type __int16 word_101F0288;
// 101F028A: using guessed type __int16 word_101F028A;

//----- (1000BCF0) --------------------------------------------------------
void __usercall sub_1000BCF0(int a1@<edi>, int a2, int a3)
{
  int v3; // [sp+4h] [bp-8h]@1
  int v4; // [sp+8h] [bp-4h]@1

  sub_1000B6C0(a3, (int)&v3, a2);
  *(double *)a1 = sub_10016570(v3, 24);
  *(double *)(a1 + 8) = sub_10016570(v4, 24);
}

//----- (1000BD30) --------------------------------------------------------
int __cdecl sub_1000BD30(__int64 a1)
{
  int result; // eax@2
  char v2; // [sp+0h] [bp-8h]@1

  sub_1000BAB0(a1 & 0x3FFFF, &v2);
  switch ( (unsigned int)WORD1(a1) >> 10 )
  {
    case 5u:
      result = sub_1000BC60((int)&v2, (*(_DWORD *)((char *)&a1 + 2) >> 2) & 0x7F);
      break;
    case 6u:
      result = sub_1000BB80((int)&v2, *(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    case 7u:
      result = sub_1000BBF0(*(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    case 8u:
      result = sub_1000BB00(*(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    default:
      result = 0xFFFFFF;
      break;
  }
  return result;
}

//----- (1000BDE0) --------------------------------------------------------
int __cdecl sub_1000BDE0(int a1, int a2)
{
  int result; // eax@1
  int v3; // esi@1
  __int16 v4; // ax@2
  signed int v5; // eax@4
  char v6; // bl@4
  __int64 v7; // [sp-4h] [bp-58h]@0
  char v8; // [sp+Eh] [bp-46h]@3
  char v9; // [sp+Fh] [bp-45h]@3
  int v10; // [sp+10h] [bp-44h]@3
  int v11; // [sp+14h] [bp-40h]@3
  int v12; // [sp+18h] [bp-3Ch]@3
  char v13; // [sp+1Ch] [bp-38h]@3
  char v14; // [sp+23h] [bp-31h]@12
  char v15; // [sp+24h] [bp-30h]@10

  *(_DWORD *)a2 = 1600085855;
  *(_WORD *)(a2 + 4) = 24415;
  LODWORD(v7) = a1;
  *(_BYTE *)(a2 + 6) = 0;
  result = sub_1000BD30(v7);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = HIWORD(a1) >> 10;
    if ( HIWORD(a1) >> 10 == 5 )
    {
      (*(void (__cdecl **)(int, signed int, char *))dword_101EFA5C)(v3, 12, &v13);
      v10 = (unsigned __int16)word_101F0284 + v3;
      sub_1000B5A0((unsigned int)&v9, (unsigned int *)&v12, &v8, (int)&v13, &v10, &v11);
      if ( (HIWORD(a1) & 0x3FCu) <= 0x1FC )
      {
        v6 = v9;
        v5 = v11;
      }
      else
      {
        v5 = v12;
        v6 = v8;
      }
      *(_BYTE *)a2 = 82;
      *(_BYTE *)(a2 + 1) = 87;
      if ( sub_1000F4C0(v5, 2, (_BYTE *)(a2 + 2)) )
      {
        *(_BYTE *)(a2 + 4) = v6;
        *(_BYTE *)(a2 + 6) = 0;
      }
      else
      {
        *(_DWORD *)(a2 + 2) = 1600085855;
        *(_BYTE *)(a2 + 6) = 0;
      }
    }
    else if ( v4 == 6 )
    {
      (*(void (__cdecl **)(int, signed int, char *))dword_101EFA5C)(v3, 9, &v13);
      sub_100165B0(&v15, 5, a2);
      *(_BYTE *)(a2 + 5) = 0;
    }
    else if ( v4 == 7 )
    {
      (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_101EFA5C)(v3, 11, &v13);
      sub_100165B0(&v14, 3, a2);
      *(_BYTE *)(a2 + 3) = 0;
    }
    else
    {
      (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_101EFA5C)(v3, 15, &v13);
      sub_100165B0(&v14, 4, a2);
      *(_BYTE *)(a2 + 4) = 0;
    }
    result = sub_1000F6C0(a2, 0);
  }
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101F0284: using guessed type __int16 word_101F0284;

//----- (1000BF70) --------------------------------------------------------
char __cdecl sub_1000BF70(int a1, int a2)
{
  char v2; // bl@1
  int v3; // ebp@1
  int v4; // eax@2
  __int64 v6; // [sp-4h] [bp-30h]@0
  char v7; // [sp+10h] [bp-1Ch]@2
  unsigned int v8; // [sp+14h] [bp-18h]@2

  *(double *)a2 = 6.2831853071796;
  LODWORD(v6) = a1;
  *(double *)(a2 + 8) = 6.2831853071796;
  v2 = 0;
  v3 = sub_1000BD30(v6);
  if ( v3 != 0xFFFFFF )
  {
    v4 = sub_1000C0D0(a1 & 0x3FFFF);
    (*(void (__cdecl **)(int, signed int, char *))dword_101EFA5C)(v4, 28, &v7);
    v2 = (v8 >> 29) & 1;
    sub_1000BCF0(a2, a1, v3);
  }
  return v2;
}
// 101EFA5C: using guessed type int dword_101EFA5C;

//----- (1000BFE0) --------------------------------------------------------
__int16 __cdecl sub_1000BFE0(int a1, int a2)
{
  int v2; // eax@1
  __int64 v4; // [sp-4h] [bp-Ch]@0

  LODWORD(v4) = a1;
  *(_DWORD *)a2 = 2147483648;
  *(_DWORD *)(a2 + 4) = 2147483648;
  v2 = sub_1000BD30(v4);
  if ( v2 != 0xFFFFFF )
    LOWORD(v2) = sub_1000B6C0(v2, a2, a1);
  return v2;
}

//----- (1000C020) --------------------------------------------------------
unsigned __int8 __cdecl sub_1000C020(unsigned int a1)
{
  unsigned __int8 result; // al@1

  result = 0;
  do
  {
    if ( a1 < *(_DWORD *)(dword_101F03B0 + 4 * result + 20816) )
      break;
    ++result;
  }
  while ( result < 4u );
  return result;
}
// 101F03B0: using guessed type int dword_101F03B0;

//----- (1000C050) --------------------------------------------------------
int __cdecl sub_1000C050(unsigned int a1, unsigned __int8 a2, char a3)
{
  unsigned int v3; // esi@2
  char v4; // bl@4
  int result; // eax@5

  if ( a2 >= 4u )
  {
    result = 0xFFFFFF;
  }
  else
  {
    v3 = a1;
    if ( a3 )
      v3 = a1 - *(_DWORD *)(dword_101F03B0 + 4 * a2 + 20812);
    v4 = byte_10065DB0[12 * a2];
    if ( sub_10016650(v3, (unsigned __int8)byte_10065DB0[12 * a2]) )
      result = dword_101EFB60[3 * (unsigned __int8)v4] + v3 * (unsigned __int16)word_101EFB64[6 * (unsigned __int8)v4];
    else
      result = 0xFFFFFF;
  }
  return result;
}
// 101EFB60: using guessed type int dword_101EFB60[];
// 101EFB64: using guessed type __int16 word_101EFB64[];
// 101F03B0: using guessed type int dword_101F03B0;

//----- (1000C0D0) --------------------------------------------------------
int __cdecl sub_1000C0D0(unsigned int a1)
{
  unsigned __int8 v1; // ST14_1@1

  v1 = sub_1000C020(a1);
  return sub_1000C050(a1, v1, 1);
}

//----- (1000C100) --------------------------------------------------------
char __cdecl sub_1000C100(__int64 a1)
{
  char v1; // bl@1
  char result; // al@3
  unsigned __int16 v3; // ax@7

  v1 = 9;
  if ( (unsigned int)a1 < 0x3E8 )
  {
LABEL_13:
    result = v1;
  }
  else
  {
    switch ( sub_1000C020(a1) )
    {
      case 0u:
        result = 0;
        break;
      case 1u:
        result = 1;
        break;
      case 2u:
        result = 2;
        break;
      case 3u:
        result = 3;
        break;
      default:
        v3 = WORD1(a1) >> 10;
        if ( (unsigned __int16)(WORD1(a1) >> 10) >= 0xBu && v3 < 0xDu
          || v3 >= 5u && v3 <= 8u && (unsigned __int16)(a1 - 1000) < (unsigned int)sub_10016690(8u) )
        {
          v1 = (*(_DWORD *)((char *)&a1 + 2) >> 10) & 0x3F;
        }
        goto LABEL_13;
    }
  }
  return result;
}

//----- (1000C1B0) --------------------------------------------------------
char __usercall sub_1000C1B0@<al>(unsigned __int16 a1@<ax>, void *a2)
{
  unsigned __int16 v2; // si@1
  char result; // al@4

  v2 = a1;
  if ( (unsigned __int8)sub_1000A9F0() && v2 < 0x3E8u && *(_WORD *)(dword_101EFA68 + 56 * v2 + 880428) == v2 )
  {
    qmemcpy(a2, (const void *)(dword_101EFA68 + 56 * (v2 + 15721)), 0x38u);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101EFA68: using guessed type int dword_101EFA68;

//----- (1000C210) --------------------------------------------------------
int __usercall sub_1000C210@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(double *)result = (double)*(signed int *)a2 * 0.000000001462918079267163;
  *(double *)(result + 8) = 0.000000001462918079267163 * (double)*(signed int *)(a2 + 4);
  return result;
}

//----- (1000C230) --------------------------------------------------------
int __cdecl sub_1000C230(unsigned __int16 a1, int a2)
{
  char v3; // [sp+4h] [bp-3Ch]@1
  char v4; // [sp+Ch] [bp-34h]@3

  sub_100319E0(58, 60000);
  if ( sub_1000C1B0(a1, &v3) )
  {
    sub_1000C210(a2, (int)&v4);
  }
  else
  {
    *(double *)a2 = 6.2831853071796;
    *(double *)(a2 + 8) = 6.2831853071796;
  }
  return sub_100319C0(58);
}

//----- (1000C2A0) --------------------------------------------------------
int __cdecl sub_1000C2A0(unsigned __int8 a1)
{
  int v1; // eax@3
  bool v2; // zf@3
  int result; // eax@3

  if ( a1 >= 0x67u
    || !(unsigned __int8)sub_1000A9F0()
    || (v1 = 8524 * a1, v2 = a1 == *(_BYTE *)(v1 + dword_101EFA68 + 2004), result = v1 + dword_101EFA68 + 2004, !v2) )
  {
    result = 0;
  }
  return result;
}
// 101EFA68: using guessed type int dword_101EFA68;

//----- (1000C2E0) --------------------------------------------------------
unsigned int __cdecl sub_1000C2E0(unsigned int a1, _BYTE *a2, _BYTE *a3)
{
  unsigned int result; // eax@1

  *a2 = a1;
  result = a1 >> 8;
  *a3 = BYTE1(a1);
  return result;
}

//----- (1000C300) --------------------------------------------------------
char __cdecl sub_1000C300(unsigned __int8 a1, int a2, char a3, int a4)
{
  char result; // al@2

  if ( (unsigned __int8)(*(int (__cdecl **)(int, signed int, int))dword_101EFA5C)(
                          a2 + dword_10065DB4[3 * a1] - 3,
                          4,
                          a4) )
  {
    *(_BYTE *)(a4 + 4) = a3;
    *(_BYTE *)a4 &= byte_10066394[5 * a1];
    *(_BYTE *)(a4 + 1) &= byte_10066395[5 * a1];
    *(_BYTE *)(a4 + 2) &= byte_10066396[5 * a1];
    *(_BYTE *)(a4 + 3) &= byte_10066397[5 * a1];
    *(_BYTE *)(a4 + 4) &= byte_10066398[5 * a1];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10065DB4: using guessed type int dword_10065DB4[];
// 101EFA5C: using guessed type int dword_101EFA5C;

//----- (1000C380) --------------------------------------------------------
char __usercall sub_1000C380@<al>(int a1@<eax>, unsigned __int8 a2)
{
  int v2; // edi@1
  unsigned int v3; // edi@2
  char v4; // dl@2
  signed int v5; // eax@2
  char result; // al@6
  __int16 v7; // [sp+Ch] [bp-1ECh]@1
  char v8[490]; // [sp+Eh] [bp-1EAh]@3

  v2 = a1;
  if ( (unsigned __int8)(*(int (__cdecl **)(int, signed int, __int16 *))dword_101EFA5C)(
                          dword_101EFB60[3 * (unsigned __int8)byte_10065DAC[12 * a2]],
                          492,
                          &v7) )
  {
    v3 = v2 - *(_DWORD *)(dword_101F03B0 + 4 * a2 + 20812);
    v4 = 0;
    v5 = 163;
    do
    {
      if ( *(unsigned __int16 *)((char *)&v7 + 3 * v5) + ((v8[3 * v5] & 3u) << 16) <= v3 )
      {
        v4 = v5;
        v5 = 0;
      }
      --v5;
    }
    while ( v5 >= 0 );
    result = v4 + 4;
  }
  else
  {
    result = -92;
  }
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101EFB60: using guessed type int dword_101EFB60[];
// 101F03B0: using guessed type int dword_101F03B0;
// 1000C380: using guessed type char var_1EA[490];

//----- (1000C420) --------------------------------------------------------
int __fastcall sub_1000C420(int a1, int a2)
{
  int result; // eax@1

  result = ((*(_WORD *)a1 << 9) + (*(_WORD *)(a1 + 5) & 0x1FF)) << 7;
  *(_DWORD *)a2 = (*(_BYTE *)(a1 + 4) + (*(_WORD *)(a1 + 2) << 8)) << 7;
  *(_DWORD *)(a2 + 4) = result;
  return result;
}

//----- (1000C450) --------------------------------------------------------
void __cdecl sub_1000C450(unsigned int a1, int a2)
{
  unsigned __int8 v2; // bl@4
  int v3; // ebp@4
  char v4; // ST34_1@4
  char v5; // [sp+Ch] [bp-Ch]@4
  char v6; // [sp+10h] [bp-8h]@5

  if ( a1 >= 0x3E8 )
  {
    if ( a1 >= *(_DWORD *)(dword_101F03B0 + 20828) )
    {
      if ( ((a1 >> 16) & 0xFC00) == 12288 )
        sub_1000CE40(a1, a2);
      else
        sub_1000BDE0(a1, a2);
    }
    else
    {
      v2 = sub_1000C020(a1);
      v3 = sub_1000C050(a1, v2, 1);
      v4 = sub_1000C380(a1, v2);
      if ( sub_1000C300(v2, v3, v4, (int)&v5) )
      {
        sub_100165B0(&v6, 6, a2);
        sub_1000F6C0(a2, 6);
      }
      else
      {
        *(_DWORD *)a2 = *(_DWORD *)"______";
        *(_WORD *)(a2 + 4) = *(_WORD *)"__";
        *(_BYTE *)(a2 + 6) = a______[6];
      }
    }
  }
  else
  {
    *(_DWORD *)a2 = *(_DWORD *)"______";
    *(_WORD *)(a2 + 4) = *(_WORD *)"__";
    *(_BYTE *)(a2 + 6) = a______[6];
  }
}
// 101F03B0: using guessed type int dword_101F03B0;

//----- (1000C590) --------------------------------------------------------
char __cdecl sub_1000C590(unsigned int a1, int a2)
{
  char result; // al@2
  unsigned __int8 v3; // al@4
  int v4; // eax@4
  char v5; // [sp+4h] [bp-8h]@4

  if ( a1 >= 0x3E8 )
  {
    if ( a1 >= *(_DWORD *)(dword_101F03B0 + 20828) )
    {
      if ( ((a1 >> 16) & 0xFC00) == 12288 )
        result = sub_1000D020(a1, a2);
      else
        result = sub_1000BFE0(a1, a2);
    }
    else
    {
      v3 = sub_1000C020(a1);
      v4 = sub_1000C050(a1, v3, 1);
      (*(void (__cdecl **)(int, signed int, char *))dword_101EFA5C)(v4, 7, &v5);
      result = sub_1000C420((int)&v5, a2);
    }
  }
  else
  {
    result = a2;
    *(_DWORD *)a2 = 2147483648;
    *(_DWORD *)(a2 + 4) = 2147483648;
  }
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101F03B0: using guessed type int dword_101F03B0;

//----- (1000C640) --------------------------------------------------------
void __usercall sub_1000C640(int a1@<ecx>, int a2@<esi>)
{
  int v2; // [sp+0h] [bp-8h]@1
  int v3; // [sp+4h] [bp-4h]@1

  sub_1000C420(a1, (int)&v2);
  *(double *)a2 = sub_10016570(v2, 24);
  *(double *)(a2 + 8) = sub_10016570(v3, 24);
}

//----- (1000C670) --------------------------------------------------------
char __cdecl sub_1000C670(unsigned int a1, int a2)
{
  char result; // al@2
  unsigned __int8 v3; // bl@4
  int v4; // eax@4
  unsigned int v5; // ebx@7
  char v6; // bl@13
  int v7; // [sp+4h] [bp-20h]@4
  int v8; // [sp+8h] [bp-1Ch]@10
  unsigned __int8 v9; // [sp+Ch] [bp-18h]@9
  unsigned int v10; // [sp+Eh] [bp-16h]@7
  unsigned int v11; // [sp+14h] [bp-10h]@8

  if ( a1 >= 0x3E8 )
  {
    if ( a1 >= *(_DWORD *)(dword_101F03B0 + 20828) )
    {
      if ( ((a1 >> 16) & 0xFC00) == 12288 )
      {
        v6 = sub_1000D020(a1, (int)&v7);
        if ( v6 )
        {
          sub_100166C0(a2, v7, v8);
          result = v6;
        }
        else
        {
          *(double *)a2 = 6.2831853071796;
          *(double *)(a2 + 8) = 6.2831853071796;
          result = 0;
        }
      }
      else
      {
        result = sub_1000BF70(a1, a2);
      }
    }
    else
    {
      v3 = sub_1000C020(a1);
      v4 = sub_1000C050(a1, v3, 1);
      (*(void (__cdecl **)(int, signed int, int *))dword_101EFA5C)(v4, 32, &v7);
      if ( v3 )
      {
        if ( v3 == 1 )
        {
          LOBYTE(v5) = v9 >> 1;
        }
        else if ( v3 == 2 )
        {
          v5 = v11 >> 14;
        }
        else
        {
          v5 = v10 >> 23;
        }
      }
      else
      {
        v5 = (unsigned int)v8 >> 29;
      }
      sub_1000C640((int)&v7, a2);
      result = v5 & 1;
    }
  }
  else
  {
    *(double *)a2 = 6.2831853071796;
    *(double *)(a2 + 8) = 6.2831853071796;
    result = 0;
  }
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101F03B0: using guessed type int dword_101F03B0;

//----- (1000C790) --------------------------------------------------------
int sub_1000C790()
{
  int result; // eax@2
  unsigned __int8 v1; // [sp+0h] [bp-Ch]@4
  int v2; // [sp+2h] [bp-Ah]@4
  int v3; // [sp+6h] [bp-6h]@4

  if ( sub_10016650(0x4Du, 1u) )
  {
    result = dword_101EFEFC;
    dword_10102F30 = dword_101EFEFC;
    if ( dword_101EFEFC )
    {
      (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_101EFA5C)(dword_101EFEFC, 8, &v1);
      word_10102F28 = v1;
      result = v3 & 0x1FF;
      dword_10102F30 += (unsigned __int16)word_101EFF00;
      word_10102F2C = v2 & 0x1FF;
      word_10102F24 = v3 & 0x1FF;
    }
  }
  else
  {
    word_10102F28 = 6;
    word_10102F2C = 6;
    result = dword_101EFD7C;
    word_10102F24 = 60;
    dword_10102F30 = dword_101EFD7C;
  }
  return result;
}
// 10102F24: using guessed type __int16 word_10102F24;
// 10102F28: using guessed type __int16 word_10102F28;
// 10102F2C: using guessed type __int16 word_10102F2C;
// 10102F30: using guessed type int dword_10102F30;
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101EFD7C: using guessed type int dword_101EFD7C;
// 101EFEFC: using guessed type int dword_101EFEFC;
// 101EFF00: using guessed type __int16 word_101EFF00;

//----- (1000C830) --------------------------------------------------------
char __cdecl sub_1000C830(float *a1)
{
  int v1; // ecx@0
  int v2; // esi@1
  char v3; // bl@1
  char v4; // al@1
  float v5; // ST44_4@4
  double v6; // st6@4
  signed __int16 v7; // si@4
  signed int v8; // eax@4
  signed __int16 v9; // di@4
  float v10; // ST44_4@7
  __int16 v11; // cx@8
  __int16 v12; // ax@8
  signed int v13; // edi@8
  __int16 v14; // bp@8
  int v15; // esi@8
  __int16 v16; // bx@8
  signed int v17; // esi@8
  int *v18; // edi@8
  signed int v19; // ecx@10
  __int64 v20; // rax@11
  __int16 v21; // si@16
  float v23; // [sp+Ch] [bp-1Ch]@8
  float v24; // [sp+10h] [bp-18h]@4
  float v25; // [sp+10h] [bp-18h]@8
  int v26; // [sp+18h] [bp-10h]@8
  int v27; // [sp+1Ch] [bp-Ch]@8

  *a1 = 0.0;
  v2 = v1;
  v3 = 0;
  v4 = sub_10017200(v1, 0);
  if ( dword_10102F30 && v4 && sub_10016650(0, 0x2Du) )
  {
    v24 = (*(float *)v2 + 1.570796370506287) * 57.29578018188477;
    v5 = 57.29578018188477 * (*(float *)(v2 + 4) + 3.141592741012573);
    v6 = v5;
    v7 = (signed int)v24;
    v8 = (signed int)v5;
    v9 = v8;
    if ( v7 > 179 )
      v7 = 179;
    if ( v9 >= 360 )
    {
      v9 = v8 - 360;
      v10 = v6 - 360.0;
      v6 = v10;
    }
    v11 = v7 / word_10102F28;
    v12 = v9 / word_10102F2C;
    v13 = (signed __int16)(v7 / word_10102F28);
    v14 = v7 / word_10102F28 + 1;
    v23 = v24 / (double)word_10102F28 - (double)v13;
    v15 = v12;
    v25 = v6 / (double)word_10102F2C - (double)v12;
    v16 = (v12 + 1) % word_10102F24;
    (*(void (__cdecl **)(int, signed int, int *))dword_101EFA5C)(
      dword_10102F30 + (unsigned __int16)word_101EFD80 * (v12 + v11 * word_10102F24),
      2,
      &v26);
    (*(void (__cdecl **)(int, signed int, char *))dword_101EFA5C)(
      dword_10102F30 + (unsigned __int16)word_101EFD80 * (v16 + v13 * word_10102F24),
      2,
      (char *)&v26 + 2);
    (*(void (__cdecl **)(int, signed int, int *))dword_101EFA5C)(
      dword_10102F30 + (unsigned __int16)word_101EFD80 * (v15 + v14 * word_10102F24),
      2,
      &v27);
    (*(void (__cdecl **)(int, _DWORD, char *))dword_101EFA5C)(
      dword_10102F30 + (unsigned __int16)word_101EFD80 * (v16 + v14 * word_10102F24),
      2,
      (char *)&v27 + 2);
    v3 = 1;
    v17 = 1;
    v18 = &v26;
    do
    {
      if ( !v3 )
        break;
      v19 = v17;
      if ( v17 < 4 )
      {
        while ( 1 )
        {
          v20 = (signed __int16)(*(_WORD *)v18 - *((_WORD *)&v26 + v19));
          if ( (signed int)((HIDWORD(v20) ^ v20) - HIDWORD(v20)) > 1820 )
            break;
          if ( ++v19 >= 4 )
            goto LABEL_15;
        }
        v3 = 0;
      }
LABEL_15:
      ++v17;
      v18 = (int *)((char *)v18 + 2);
    }
    while ( v17 - 1 < 3 );
    v21 = v26 + (signed int)((double)(signed __int16)(v27 - v26) * v23);
    *a1 = (double)(signed __int16)(v21
                                 + (signed int)((double)(signed __int16)(HIWORD(v26)
                                                                       + (signed int)(v23
                                                                                    * (double)(signed __int16)(HIWORD(v27) - HIWORD(v26)))
                                                                       - v21)
                                              * v25))
        * 0.0000958738019107841;
  }
  return v3;
}
// 10102F24: using guessed type __int16 word_10102F24;
// 10102F28: using guessed type __int16 word_10102F28;
// 10102F2C: using guessed type __int16 word_10102F2C;
// 10102F30: using guessed type int dword_10102F30;
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101EFD80: using guessed type __int16 word_101EFD80;

//----- (1000CAF0) --------------------------------------------------------
char __cdecl sub_1000CAF0(int a1, float *a2)
{
  return sub_1000C830(a2);
}

//----- (1000CB10) --------------------------------------------------------
char *__cdecl sub_1000CB10(unsigned __int8 a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *result; // eax@1
  signed int v4; // ebp@1
  int v5; // esi@1
  int v6; // edi@1
  int v7; // esi@2
  char v8; // cl@4
  int v9; // ecx@8
  int v10; // [sp+10h] [bp-28h]@2
  int v11; // [sp+14h] [bp-24h]@1
  char v12[28]; // [sp+18h] [bp-20h]@2

  v2 = dword_101EFB60[3 * a1];
  result = (char *)(12 * a1);
  v4 = *(_DWORD *)&result[(_DWORD)dword_101EFB68];
  v5 = v1;
  v6 = *(_WORD *)&result[(_DWORD)word_101EFB64];
  v11 = v1;
  if ( v4 > 0 )
  {
    v7 = v1 - (_DWORD)v12;
    v10 = *(_DWORD *)&result[(_DWORD)dword_101EFB68];
    do
    {
      (*(void (__cdecl **)(int, int, char *))dword_101EFA5C)(v2, v6, v12);
      v12[v6] = 0;
      result = v12;
      do
      {
        v8 = *result;
        result[v7] = *result;
        ++result;
      }
      while ( v8 );
      v2 += v6;
      v7 += 25;
      --v10;
    }
    while ( v10 );
    v5 = v11;
  }
  if ( v4 < 64 )
  {
    result = (char *)(v5 + 25 * v4);
    v9 = 64 - v4;
    do
    {
      *result = 0;
      result += 25;
      --v9;
    }
    while ( v9 );
  }
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101EFB60: using guessed type int dword_101EFB60[];
// 101EFB64: using guessed type __int16 word_101EFB64[];
// 101EFB68: using guessed type int dword_101EFB68[];
// 1000CB10: using guessed type char var_20[28];

//----- (1000CBD0) --------------------------------------------------------
signed int sub_1000CBD0()
{
  signed int result; // eax@1

  result = 0xFFFFFF;
  byte_101EFA60 = 0;
  dword_101EFA64 = 0xFFFFFF;
  byte_101EFA50 = 0;
  dword_101EFA54 = 0xFFFFFF;
  return result;
}
// 101EFA50: using guessed type char byte_101EFA50;
// 101EFA54: using guessed type int dword_101EFA54;
// 101EFA60: using guessed type char byte_101EFA60;
// 101EFA64: using guessed type int dword_101EFA64;

//----- (1000CBF0) --------------------------------------------------------
int sub_1000CBF0()
{
  int result; // eax@1

  result = (*(int (**)(void))(dword_101EFA5C + 16))();
  byte_101EFA58 = (_BYTE)result == 0;
  return result;
}
// 101EFA58: using guessed type char byte_101EFA58;
// 101EFA5C: using guessed type int dword_101EFA5C;

//----- (1000CC50) --------------------------------------------------------
int sub_1000CC50()
{
  int result; // eax@1

  *(_DWORD *)(dword_101F03B0 + 20812) = 1000;
  *(_DWORD *)(dword_101F03B0 + 20816) = dword_101EFBC8 + *(_DWORD *)(dword_101F03B0 + 20812);
  *(_DWORD *)(dword_101F03B0 + 20820) = dword_101EFC28 + *(_DWORD *)(dword_101F03B0 + 20816);
  *(_DWORD *)(dword_101F03B0 + 20824) = dword_101EFC58 + *(_DWORD *)(dword_101F03B0 + 20820);
  result = dword_101F03B0;
  *(_DWORD *)(dword_101F03B0 + 20828) = dword_101EFCA0 + *(_DWORD *)(dword_101F03B0 + 20824);
  return result;
}
// 101EFBC8: using guessed type int dword_101EFBC8;
// 101EFC28: using guessed type int dword_101EFC28;
// 101EFC58: using guessed type int dword_101EFC58;
// 101EFCA0: using guessed type int dword_101EFCA0;
// 101F03B0: using guessed type int dword_101F03B0;

//----- (1000CCC0) --------------------------------------------------------
char *sub_1000CCC0()
{
  sub_1000CB10(0x40u);
  sub_1000CB10(0x39u);
  sub_1000CB10(0x33u);
  sub_1000CB10(0x31u);
  sub_1000CB10(0x32u);
  sub_1000CB10(0x4Eu);
  sub_1000CB10(0x4Fu);
  sub_1000CB10(0x3Du);
  sub_1000CB10(0x3Eu);
  sub_1000CB10(0x45u);
  return sub_1000CB10(0x38u);
}
// 101F03B0: using guessed type int dword_101F03B0;

//----- (1000CD90) --------------------------------------------------------
int __cdecl sub_1000CD90(const void *a1)
{
  int result; // eax@1

  qmemcpy(dword_10102F38, a1, 0x1Cu);
  dword_101EFA5C = (int)dword_10102F38;
  dword_101F03B0 = (int)&unk_10102F58;
  memset(&unk_10102F58, 0, 0x516Cu);
  dword_10102F38[5](dword_101F03B0 + 20832, dword_101F03B0 + 20833, dword_101F03B0 + 20836);
  (*(void (__cdecl **)(int))(dword_101EFA5C + 24))(dword_101F03B0 + 20840);
  sub_10016CE0();
  sub_100167B0();
  sub_10016B20();
  sub_10016880();
  sub_1000CCC0();
  sub_1000CBD0();
  sub_1000D3A0();
  sub_1000C790();
  sub_1000CBF0();
  sub_1000CC50();
  *(_DWORD *)(dword_101F03B0 + 20800) = 0;
  *(_DWORD *)(dword_101F03B0 + 20804) = dword_101EFD48;
  result = dword_101F03B0;
  *(_DWORD *)(dword_101F03B0 + 20808) = dword_101EFD54 + *(_DWORD *)(dword_101F03B0 + 20804);
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101EFD48: using guessed type int dword_101EFD48;
// 101EFD54: using guessed type int dword_101EFD54;
// 101F03B0: using guessed type int dword_101F03B0;

//----- (1000CE40) --------------------------------------------------------
void __cdecl sub_1000CE40(unsigned int a1, int a2)
{
  unsigned int v2; // ebx@3
  unsigned int v3; // ebp@4
  unsigned int v4; // eax@5
  int v5; // ecx@5
  int v6; // eax@6
  char v7; // dl@10
  char v8; // cl@10
  char v9; // al@10
  char v10; // cl@11
  char v11; // dl@11
  char v12; // dl@13
  char v13; // cl@13
  char v14; // al@13
  char v15; // cl@14
  char v16; // dl@14
  char v17; // cl@14
  char v18; // [sp+4h] [bp-10h]@5
  char v19; // [sp+5h] [bp-Fh]@10
  char v20; // [sp+6h] [bp-Eh]@10
  char v21; // [sp+8h] [bp-Ch]@5
  char v22; // [sp+Ah] [bp-Ah]@10
  char v23; // [sp+Bh] [bp-9h]@10

  if ( a2 )
  {
    if ( (a1 & 0xFC000000) != 805306368 || (v2 = a1 & 0x1FF, v2 > 0x168) || (v3 = (a1 >> 9) & 0x1FF, v3 > 0x168) )
    {
      *(_DWORD *)a2 = *(_DWORD *)"______";
      *(_WORD *)(a2 + 4) = *(_WORD *)"__";
      *(_BYTE *)(a2 + 6) = a______[6];
    }
    else
    {
      sub_1000F650(&v18, 4u, "%+03d", (signed int)(v2 - 180) / 2);
      sub_1000F650(&v21, 5u, "%+04d", v3 - 180);
      v4 = (v3 - 180) >> 31;
      v5 = (v3 - 180 - v4) ^ ((signed int)(v3 - 180 - v4) >> 31);
      if ( v2 < 0xB4 )
      {
        LOBYTE(v4) = v3 < 0xB4;
        v6 = 4 * v4 + 83;
      }
      else
      {
        LOBYTE(v6) = v3 < 0xB4 ? 78 : 69;
      }
      *(_BYTE *)(a2 + 5) = 0;
      if ( a1 & 1 )
      {
        if ( v5 >= 100 )
        {
          v10 = v22;
          *(_BYTE *)a2 = v19;
          v11 = v23;
          *(_BYTE *)(a2 + 1) = v6;
          *(_BYTE *)(a2 + 2) = v20;
          *(_BYTE *)(a2 + 3) = v10;
          *(_BYTE *)(a2 + 4) = v11;
        }
        else
        {
          v7 = v20;
          *(_BYTE *)(a2 + 1) = v19;
          v8 = v23;
          *(_BYTE *)a2 = v6;
          v9 = v22;
          *(_BYTE *)(a2 + 2) = v7;
          *(_BYTE *)(a2 + 3) = v9;
          *(_BYTE *)(a2 + 4) = v8;
        }
      }
      else if ( v5 < 100 )
      {
        v15 = v20;
        *(_BYTE *)a2 = v19;
        v16 = v22;
        *(_BYTE *)(a2 + 1) = v15;
        v17 = v23;
        *(_BYTE *)(a2 + 2) = v16;
        *(_BYTE *)(a2 + 3) = v17;
        *(_BYTE *)(a2 + 4) = v6;
      }
      else
      {
        v12 = v20;
        *(_BYTE *)a2 = v19;
        v13 = v23;
        *(_BYTE *)(a2 + 2) = v6;
        v14 = v22;
        *(_BYTE *)(a2 + 1) = v12;
        *(_BYTE *)(a2 + 3) = v14;
        *(_BYTE *)(a2 + 4) = v13;
      }
    }
  }
}

//----- (1000D020) --------------------------------------------------------
char __cdecl sub_1000D020(unsigned int a1, int a2)
{
  char result; // al@1
  unsigned int v3; // edx@3
  unsigned int v4; // ecx@4

  result = 0;
  if ( a2 )
  {
    if ( (a1 & 0xFC000000) == 805306368 )
    {
      v3 = a1 & 0x1FF;
      if ( v3 <= 0x168 )
      {
        v4 = (a1 >> 9) & 0x1FF;
        if ( v4 <= 0x168 )
        {
          *(_DWORD *)a2 = (signed int)(11930464 * (v3 - 180)) / 2;
          *(_DWORD *)(a2 + 4) = 11930464 * (v4 - 180);
          result = 1;
        }
      }
    }
  }
  return result;
}

//----- (1000D090) --------------------------------------------------------
int __cdecl sub_1000D090(_BYTE *a1, _BYTE *a2)
{
  int result; // eax@1

  result = sub_10016690(0x2Bu);
  *a1 = result;
  if ( (_BYTE)result )
  {
    result = (int)a2;
    *a2 = 1;
  }
  else
  {
    *a2 = 0;
    *a1 = 1;
  }
  return result;
}

//----- (1000D0C0) --------------------------------------------------------
int sub_1000D0C0()
{
  return (*(int (**)(void))(dword_101EFA5C + 8))();
}
// 101EFA5C: using guessed type int dword_101EFA5C;

//----- (1000D0D0) --------------------------------------------------------
int __fastcall sub_1000D0D0(unsigned __int8 a1)
{
  return dword_101EFD64 + a1 * (unsigned __int16)word_101EFD68;
}
// 101EFD64: using guessed type int dword_101EFD64;
// 101EFD68: using guessed type __int16 word_101EFD68;

//----- (1000D0F0) --------------------------------------------------------
int __fastcall sub_1000D0F0(unsigned __int8 a1)
{
  return dword_101EFD70 + a1 * (unsigned __int16)word_101EFD74;
}
// 101EFD70: using guessed type int dword_101EFD70;
// 101EFD74: using guessed type __int16 word_101EFD74;

//----- (1000D110) --------------------------------------------------------
void *__cdecl sub_1000D110(char a1, void *a2)
{
  void *result; // eax@2
  int v3; // eax@4
  int v4; // eax@4
  char v5; // [sp+6h] [bp-1Eh]@1
  unsigned __int8 v6; // [sp+7h] [bp-1Dh]@1
  char v7; // [sp+8h] [bp-1Ch]@4
  char v8; // [sp+16h] [bp-Eh]@4

  sub_1000D090(&v6, &v5);
  if ( (unsigned __int8)a1 < v6 )
  {
    if ( v5 )
    {
      v3 = sub_1000D0D0(a1);
      v4 = (*(int (__cdecl **)(int, signed int, char *))dword_101EFA5C)(v3, 22, &v7);
      result = (void *)sub_100168E0(v4, &v8, 20, (int)a2);
      *((_BYTE *)a2 + 20) = 0;
    }
    else
    {
      result = memcpy(a2, &aWgs84[21 * (unsigned __int8)a1], 0x14u);
      *((_BYTE *)a2 + 20) = 0;
    }
  }
  else
  {
    result = (void *)1600085855;
    *(_DWORD *)a2 = 1600085855;
    *((_DWORD *)a2 + 1) = 1600085855;
    *((_DWORD *)a2 + 2) = 1600085855;
    *((_DWORD *)a2 + 3) = 1600085855;
    *((_DWORD *)a2 + 4) = 1600085855;
    *((_BYTE *)a2 + 20) = 0;
  }
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;

//----- (1000D1E0) --------------------------------------------------------
int __cdecl sub_1000D1E0(int a1)
{
  bool v1; // zf@1
  int v2; // eax@2
  signed int v3; // eax@2
  float v4; // ST24_4@2
  unsigned __int8 v5; // cl@2
  int v6; // eax@2
  char v7; // al@2
  char v8; // cl@2
  float v9; // ST24_4@3
  double v10; // st6@3
  float v11; // ST24_4@3
  float v12; // ST24_4@3
  double v13; // st7@3
  float v14; // ST24_4@3
  float v16; // [sp+10h] [bp-34h]@2
  char v17; // [sp+14h] [bp-30h]@2
  char v18; // [sp+15h] [bp-2Fh]@2
  char v19; // [sp+16h] [bp-2Eh]@2
  char v20; // [sp+17h] [bp-2Dh]@2
  char v21; // [sp+26h] [bp-1Eh]@2
  char v22; // [sp+28h] [bp-1Ch]@2
  char v23; // [sp+36h] [bp-Eh]@2
  unsigned __int8 v24; // [sp+37h] [bp-Dh]@2
  __int16 v25; // [sp+38h] [bp-Ch]@2
  __int16 v26; // [sp+3Ah] [bp-Ah]@2
  __int16 v27; // [sp+3Ch] [bp-8h]@2

  *(float *)(a1 + 24) = 0.0;
  *(float *)(a1 + 28) = 0.0;
  *(float *)(a1 + 32) = 0.0;
  *(float *)(a1 + 36) = 6378137.0;
  *(float *)(a1 + 40) = 0.0033528106;
  *(_BYTE *)(a1 + 56) = 0;
  memcpy((void *)(a1 + 1), "WGS 84              ", 0x15u);
  v1 = *(_BYTE *)(a1 + 81) == 0;
  *(_BYTE *)(a1 + 80) = 1;
  if ( !v1 )
  {
    v2 = sub_1000D0D0(*(_BYTE *)a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_101EFA5C)(v2, 22, &v22);
    sub_100168E0((int)&v23, &v23, 20, a1 + 1);
    v3 = v27;
    LODWORD(v4) = v26;
    v5 = v24;
    *(float *)(a1 + 24) = (double)v25;
    *(_BYTE *)(a1 + 21) = 0;
    *(float *)(a1 + 28) = (double)SLODWORD(v4);
    *(float *)(a1 + 32) = (double)v3;
    v6 = sub_1000D0F0(v5);
    (*(void (__cdecl **)(int, signed int, float *))dword_101EFA5C)(v6, 23, &v16);
    v7 = v18;
    v8 = v19;
    LOBYTE(v4) = v17;
    *(float *)(a1 + 36) = v16;
    BYTE1(v4) = v7;
    BYTE2(v4) = v8;
    BYTE3(v4) = v20;
    *(float *)(a1 + 40) = v4;
    sub_100168E0((int)&v21, &v21, 20, a1 + 56);
    *(_BYTE *)(a1 + 76) = 0;
  }
  *(float *)(a1 + 44) = *(float *)(a1 + 40) + *(float *)(a1 + 40) - *(float *)(a1 + 40) * *(float *)(a1 + 40);
  v9 = *(float *)(a1 + 36) - 6378137.0;
  v10 = v9;
  *(float *)(a1 + 48) = v9;
  v11 = *(float *)(a1 + 40) - 0.003352810628712177;
  v12 = 6378137.0 * v11;
  v13 = v12;
  v14 = v10 * 0.00335281066474748;
  *(float *)(a1 + 52) = v13 + v14;
  return (*(int (__cdecl **)(int))(dword_101EFA5C + 12))(a1);
}
// 101EFA5C: using guessed type int dword_101EFA5C;

//----- (1000D3A0) --------------------------------------------------------
char sub_1000D3A0()
{
  int v0; // eax@1
  unsigned __int8 v1; // bl@1
  char v2; // al@7
  unsigned __int8 v3; // bl@10
  unsigned __int8 v5; // [sp+6h] [bp-76h]@1
  unsigned __int8 v6; // [sp+7h] [bp-75h]@1
  char v7[4]; // [sp+8h] [bp-74h]@1
  char v8; // [sp+Ch] [bp-70h]@10
  unsigned __int8 v9; // [sp+5Ch] [bp-20h]@5
  char v10; // [sp+5Dh] [bp-1Fh]@8
  char v11; // [sp+5Eh] [bp-1Eh]@6
  char v12; // [sp+60h] [bp-1Ch]@2

  sub_1000D0C0();
  sub_1000D090(&v6, &v5);
  LOBYTE(v0) = v6;
  v1 = 0;
  v5 = v6;
  v7[0] = 0;
  if ( v6 )
  {
    do
    {
      sub_1000D110(v7[0], &v12);
      v0 = strcmp(&v12, "WGS 84              ");
      if ( !v0 )
        v5 = v1;
      v7[0] = ++v1;
    }
    while ( v1 < v6 );
  }
  if ( !v9 || v5 != v11 )
  {
    v2 = sub_10016690(0x2Bu);
    v9 = v2;
    if ( v2 )
    {
      v10 = 1;
    }
    else
    {
      v2 = 1;
      v10 = 0;
      v9 = 1;
    }
    v3 = 0;
    v8 = v2;
    v11 = v2;
    v7[0] = 0;
    if ( v2 )
    {
      do
      {
        sub_1000D110(v7[0], &v12);
        if ( !strcmp(&v12, "WGS 84              ") )
        {
          v11 = v3;
          v8 = v3;
        }
        v7[0] = ++v3;
      }
      while ( v3 < v9 );
    }
    LOBYTE(v0) = sub_1000D1E0((int)&v8);
  }
  return v0;
}

//----- (1000D500) --------------------------------------------------------
char *__cdecl sub_1000D500(int a1, char *a2, int a3, char *a4, int a5)
{
  char *v5; // edi@1
  char *result; // eax@4
  char v7[4]; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v5 = a2;
  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  *(_DWORD *)(a5 + 16) = sub_100318A0();
  *(_DWORD *)(a5 + 596) = sub_10031910();
  sub_10031930((int)v7, 1, *(_DWORD *)(a5 + 16), 40);
  *(_WORD *)(a5 + 594) = 0x7FFF;
  sub_1000F530(a5 + 585, "14.01", 8);
  *(_DWORD *)a5 = a1;
  sub_10018930((char *)(a5 + 4));
  *(_DWORD *)(a5 + 460) = a3;
  if ( strrchr(a2, 92) )
    v5 = strrchr(a2, 92) + 1;
  strncpy((char *)(a5 + 464), v5, 0x14u);
  *(_BYTE *)(a5 + 484) = 0;
  if ( a4 )
  {
    result = strncpy((char *)(a5 + 485), a4, 0x63u);
    *(_BYTE *)(a5 + 584) = 0;
  }
  else
  {
    result = strncpy((char *)(a5 + 485), v7, 0x64u);
  }
  return result;
}

//----- (1000D630) --------------------------------------------------------
char sub_1000D630()
{
  char result; // al@1

  result = 0;
  byte_101080CC = 0;
  byte_101080CD = 0;
  return result;
}
// 101080CC: using guessed type char byte_101080CC;
// 101080CD: using guessed type char byte_101080CD;

//----- (1000D640) --------------------------------------------------------
char __cdecl sub_1000D640(char *a1, int a2, char a3, char *a4, int a5)
{
  char result; // al@7
  char v6; // [sp+Bh] [bp-2Dh]@4
  int v7; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( a3 & 3 )
    sub_1000D500(-5, a1, a2, a4, a5);
  else
    sub_1000D500(-44, a1, a2, a4, a5);
  v6 = a3 & 8;
  if ( a3 & 8 )
    sub_1000F680((const char *)(a5 + 485), " DBGA", 100);
  sub_10031930((int)&v7, 0, 0, 40);
  if ( a3 & 3 )
  {
    result = a3 & 8;
    if ( v6 )
    {
      if ( byte_101080CC )
        return result;
      if ( v6 )
        goto LABEL_15;
    }
    if ( !byte_101080CD )
LABEL_15:
      result = sub_10031970(36, 1, *(_DWORD *)a5, a5);
  }
  else
  {
    result = j_HWM_pvg_log_err(a5);
  }
  return result;
}
// 100323D0: using guessed type int __cdecl j_HWM_pvg_log_err(_DWORD);
// 101080CC: using guessed type char byte_101080CC;
// 101080CD: using guessed type char byte_101080CD;

//----- (1000D740) --------------------------------------------------------
char __cdecl sub_1000D740(char *a1, int a2, char a3, char *a4)
{
  int v5; // [sp+8h] [bp-284h]@1

  memset(&v5, 0, 0x280u);
  return sub_1000D640(a1, a2, a3, a4, (int)&v5);
}

//----- (1000D7B0) --------------------------------------------------------
char __cdecl sub_1000D7B0(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5)
{
  char *v5; // eax@1

  v5 = sub_10013F90(*a4);
  return sub_1000D820(a1, a2, a3, (int)v5, a5);
}

//----- (1000D7D0) --------------------------------------------------------
int __usercall sub_1000D7D0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  *(_DWORD *)(result + 16) = *(_DWORD *)(a3 + 8);
  *(_DWORD *)(result + 20) = *(_DWORD *)(a3 + 4);
  *(float *)(result + 12) = *(float *)(a3 + 12);
  *(_DWORD *)(result + 8) = *(_DWORD *)(a3 + 20);
  *(float *)(result + 24) = *(float *)(a3 + 24);
  *(float *)(result + 28) = *(float *)(a3 + 28);
  *(float *)(result + 32) = *(float *)(a3 + 16);
  *(float *)result = (double)*(_WORD *)a2;
  *(float *)(result + 4) = (double)*(_WORD *)(a2 + 2);
  return result;
}

//----- (1000D820) --------------------------------------------------------
char __cdecl sub_1000D820(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v6; // eax@5
  int v7; // eax@6
  char v8; // [sp+0h] [bp-24h]@5

  if ( *a5 != 32802 )
  {
    if ( *a5 == 32832 )
    {
      v6 = sub_1000D7D0((int)&v8, a3, a2);
      sub_1000FB80(a1, a4, v6);
      return 2;
    }
    if ( *a5 != 32888 )
      return 1;
  }
  v7 = sub_1000D7D0((int)&v8, a3, a2);
  sub_1000FFB0(a1, a4, v7);
  return 2;
}

//----- (1000D8A0) --------------------------------------------------------
char __cdecl sub_1000D8A0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@3
  signed int v6; // ecx@4
  signed int v7; // edx@4
  signed int v8; // eax@4
  float v9; // ST1C_4@5
  float v10; // ST20_4@5
  double v11; // st7@5
  float v12; // ST0C_4@7
  float v13; // [sp+4h] [bp-24h]@5
  float v14; // [sp+Ch] [bp-1Ch]@4
  float v15; // [sp+10h] [bp-18h]@4
  float v16; // [sp+14h] [bp-14h]@4
  float v17; // [sp+18h] [bp-10h]@4
  float v18; // [sp+1Ch] [bp-Ch]@4
  float v19; // [sp+20h] [bp-8h]@4
  float v20; // [sp+24h] [bp-4h]@4
  float v21; // [sp+3Ch] [bp+14h]@4

  if ( *a5 == 32802 || *a5 == 32888 )
  {
    v6 = *(_WORD *)(a3 + 2);
    v7 = *(_WORD *)a3;
    v14 = *(float *)(a2 + 20) + (double)v6;
    v16 = (double)v7;
    v21 = *(float *)(a2 + 16) + (double)v7;
    v15 = (double)v6;
    v20 = v14 - *(float *)(a2 + 24);
    v18 = *(float *)(a2 + 24) + v16;
    v19 = v21 - *(float *)(a2 + 24);
    v17 = *(float *)(a2 + 24) + v15;
    j_gdi_pvg_enable(35);
    j_gdi_pvg_blend_func(4, 5);
    v8 = sub_10014030(*(_DWORD *)(a2 + 8));
    j_gdi_pvg_color_u32(v8);
    if ( 1.0 == *(float *)(a2 + 24) )
    {
      j_gdi_pvg_begin(66);
      v9 = v15 + 0.5;
      v10 = v16 + 0.5;
      sub_100317B0(v10, v9);
      sub_100317B0(v21, v9);
      sub_100317B0(v21, v14);
      v13 = v14;
      v11 = v10;
    }
    else
    {
      j_gdi_pvg_begin(73);
      sub_100317B0(v16, v15);
      sub_100317B0(v18, v17);
      sub_100317B0(v21, v15);
      sub_100317B0(v19, v17);
      sub_100317B0(v21, v14);
      sub_100317B0(v19, v20);
      sub_100317B0(v16, v14);
      sub_100317B0(v18, v20);
      sub_100317B0(v16, v15);
      v13 = v17;
      v11 = v18;
    }
    v12 = v11;
    sub_100317B0(v12, v13);
    j_gdi_pvg_end();
    if ( !(*(_BYTE *)(a2 + 4) & 0x10) )
    {
      j_gdi_pvg_begin(72);
      j_gdi_pvg_color_u32(*(_DWORD *)(a2 + 12));
      sub_100317B0(v18, v17);
      sub_100317B0(v19, v17);
      sub_100317B0(v19, v20);
      sub_100317B0(v18, v20);
      j_gdi_pvg_end();
    }
    j_gdi_pvg_disable(35);
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 100315B0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10031610: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10031620: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10031630: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10031690: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 100316A0: using guessed type int j_gdi_pvg_end(void);

//----- (1000DB20) --------------------------------------------------------
int __cdecl sub_1000DB20(unsigned __int16 a1)
{
  return dword_1006A050[a1];
}
// 1006A050: using guessed type int dword_1006A050[];

//----- (1000DB30) --------------------------------------------------------
char __cdecl sub_1000DB30(int a1, int a2, int a3, int a4, __int16 *a5)
{
  __int16 v5; // ax@1
  unsigned __int16 v6; // dx@4
  double v7; // st7@4
  int v8; // ST04_4@4
  double v9; // st7@4
  int v10; // eax@4
  char *v11; // edi@5
  const char *v12; // esi@6
  bool v13; // zf@97
  const char *v14; // ebx@98
  __int16 v15; // cx@98
  __int16 v16; // dx@98
  char v18; // [sp+1Eh] [bp-11Ah]@1
  char v19; // [sp+1Fh] [bp-119h]@1
  __int16 v20; // [sp+20h] [bp-118h]@98
  __int16 v21; // [sp+22h] [bp-116h]@98
  __int16 *v22; // [sp+24h] [bp-114h]@1
  int v23; // [sp+28h] [bp-110h]@1
  int v24; // [sp+2Ch] [bp-10Ch]@1
  int v25; // [sp+30h] [bp-108h]@98
  float v26; // [sp+34h] [bp-104h]@4
  char v27; // [sp+38h] [bp-100h]@4
  char *v28; // [sp+54h] [bp-E4h]@1
  int v29; // [sp+58h] [bp-E0h]@98
  int v30; // [sp+5Ch] [bp-DCh]@98
  char v31; // [sp+60h] [bp-D8h]@1
  char v32; // [sp+6Bh] [bp-CDh]@99

  v23 = a1;
  v22 = a5;
  v5 = *a5;
  v24 = a3;
  v19 = 1;
  v18 = 31;
  v28 = &v31;
  if ( v5 == -32648 || v5 == -32734 || v5 == -32704 )
  {
    v6 = *(_WORD *)a4;
    v7 = *(float *)(a4 + 4);
    qmemcpy(&v27, (const void *)(a4 + 8), 0x1Cu);
    *(float *)&v8 = v7;
    v9 = sub_10014830(v8, v6, *(_BYTE *)(a4 + 40), &v18);
    v10 = *(_WORD *)a4;
    v26 = v9;
    switch ( v10 )
    {
      case 0:
        v11 = &v31;
        if ( v18 == 21 )
          v12 = "\a_.__";
        else
          v12 = "\a_.__";
        goto LABEL_97;
      case 42:
      case 46:
        v12 = (const char *)&unk_1006A2C0;
        goto LABEL_96;
      case 1:
      case 45:
        v12 = (const char *)&unk_1006A390;
        goto LABEL_96;
      case 4:
        v12 = (const char *)&unk_1006A460;
        goto LABEL_96;
      case 5:
        v12 = (const char *)&unk_1006A530;
        goto LABEL_96;
      case 6:
      case 10:
      case 37:
        v12 = (const char *)&unk_1006A600;
        goto LABEL_96;
      case 11:
        v12 = (const char *)&unk_1006A6D0;
        goto LABEL_96;
      case 7:
      case 12:
      case 36:
        v12 = (const char *)&unk_1006A7A0;
        goto LABEL_96;
      case 13:
        v12 = (const char *)&unk_1006A870;
        goto LABEL_96;
      case 8:
        v12 = (const char *)&unk_1006A940;
        goto LABEL_96;
      case 9:
        v12 = (const char *)&unk_1006AA10;
        goto LABEL_96;
      case 14:
        v11 = &v31;
        if ( v18 == 40 )
          v12 = (const char *)&unk_1006A600;
        else
          v12 = (const char *)&unk_1006ABB0;
        goto LABEL_97;
      case 15:
        v11 = &v31;
        if ( v18 == 40 )
          v12 = (const char *)&unk_1006A7A0;
        else
          v12 = (const char *)&unk_1006AC80;
        goto LABEL_97;
      case 16:
        v11 = &v31;
        if ( v18 == 40 )
          v12 = (const char *)&unk_1006AAE0;
        else
          v12 = (const char *)&unk_1006AD50;
        goto LABEL_97;
      case 17:
        v11 = &v31;
        if ( v18 == 10 )
          v12 = (const char *)&unk_1006AE20;
        else
          v12 = (const char *)&unk_1006B090;
        goto LABEL_97;
      case 19:
        v11 = &v31;
        if ( v18 == 10 )
          v12 = (const char *)&unk_1006AEF0;
        else
          v12 = (const char *)&unk_1006B160;
        goto LABEL_97;
      case 18:
        v11 = &v31;
        if ( v18 == 10 )
          v12 = (const char *)&unk_1006AFC0;
        else
          v12 = (const char *)&unk_1006B230;
        goto LABEL_97;
      case 20:
        v12 = (const char *)&unk_1006B300;
        goto LABEL_96;
      case 21:
        v12 = (const char *)&unk_1006B3D0;
        goto LABEL_96;
      case 22:
        v12 = (const char *)&unk_1006B4A0;
        goto LABEL_96;
      case 23:
        v12 = (const char *)&unk_1006B570;
        goto LABEL_96;
      case 24:
        v12 = (const char *)&unk_1006B640;
        goto LABEL_96;
      case 25:
        v12 = (const char *)&unk_1006B710;
        goto LABEL_96;
      case 43:
        v11 = &v31;
        switch ( v18 )
        {
          case 12:
            v12 = (const char *)&unk_1006BBF0;
            break;
          case 21:
            v12 = (const char *)&unk_1006BD90;
            break;
          case 30:
            v12 = (const char *)&unk_1006B8B0;
            break;
          default:
            v12 = (const char *)&unk_1006BF30;
            break;
        }
        goto LABEL_97;
      case 26:
      case 38:
        v11 = &v31;
        switch ( v18 )
        {
          case 12:
            v12 = (const char *)&unk_1006B980;
            break;
          case 21:
            v12 = (const char *)&unk_1006BCC0;
            break;
          case 30:
            v12 = (const char *)&unk_1006B7E0;
            break;
          default:
            v12 = (const char *)&unk_1006BE60;
            break;
        }
        goto LABEL_97;
      case 48:
        v12 = (const char *)&unk_1006BA50;
        goto LABEL_96;
      case 49:
        v12 = (const char *)&unk_1006BB20;
        goto LABEL_96;
      case 27:
        v11 = &v31;
        if ( v18 == 28 )
          v12 = (const char *)&unk_1006C000;
        else
          v12 = (const char *)&unk_1006C1A0;
        goto LABEL_97;
      case 29:
        v11 = &v31;
        if ( v18 == 28 )
          v12 = (const char *)&unk_1006C0D0;
        else
          v12 = (const char *)&unk_1006C270;
        goto LABEL_97;
      case 30:
        switch ( v18 )
        {
          case 0xD:
            v12 = (const char *)&unk_1006C340;
            break;
          case 0x10:
            v12 = (const char *)&unk_1006C4E0;
            break;
          case 0x18:
            v12 = (const char *)&unk_1006C820;
            break;
          default:
            v12 = (const char *)&unk_1006C9C0;
            break;
          case 0x13:
            goto LABEL_95;
        }
        goto LABEL_96;
      case 31:
        switch ( v18 )
        {
          case 0xD:
            v12 = (const char *)&unk_1006C410;
            break;
          case 0x10:
            v12 = (const char *)&unk_1006C5B0;
            break;
          case 0x13:
            v12 = (const char *)&unk_1006C750;
            break;
          case 0x18:
            v12 = (const char *)&unk_1006C8F0;
            break;
          default:
            v12 = (const char *)&unk_1006CA90;
            break;
        }
        goto LABEL_96;
      case 32:
        switch ( v18 )
        {
          case 0xE:
            v12 = (const char *)&unk_1006CB60;
            break;
          case 0x11:
            v12 = (const char *)&unk_1006CD00;
            break;
          case 0x14:
            v12 = (const char *)&unk_1006CEA0;
            break;
          case 0x19:
            v12 = (const char *)&unk_1006D040;
            break;
          default:
            v12 = (const char *)&unk_1006D1E0;
            break;
        }
        goto LABEL_96;
      case 33:
        switch ( v18 )
        {
          case 0xE:
            v12 = (const char *)&unk_1006CC30;
            break;
          case 0x11:
            v12 = (const char *)&unk_1006CDD0;
            break;
          case 0x14:
            v12 = (const char *)&unk_1006CF70;
            break;
          case 0x19:
            v12 = (const char *)&unk_1006D110;
            break;
          default:
            v12 = (const char *)&unk_1006D2B0;
            break;
        }
        goto LABEL_96;
      case 35:
        v12 = (const char *)&unk_1006D380;
        goto LABEL_96;
      case 34:
        v12 = (const char *)&unk_1006D450;
        goto LABEL_96;
      case 39:
        v12 = (const char *)&unk_1006D520;
        goto LABEL_96;
      case 40:
        v12 = (const char *)&unk_1006D5F0;
        goto LABEL_96;
      case 41:
        v12 = (const char *)&unk_1006D6C0;
        goto LABEL_96;
      case 44:
        v12 = (const char *)&unk_1006D790;
        goto LABEL_96;
      case 47:
        v12 = (const char *)&unk_1006D860;
        goto LABEL_96;
      case 50:
        v12 = (const char *)&unk_1006C820;
        if ( v18 == 19 )
LABEL_95:
          v12 = (const char *)&unk_1006C680;
LABEL_96:
        v11 = &v31;
LABEL_97:
        v13 = v28 == 0;
        qmemcpy(v11, v12, 0xCCu);
        if ( !v13 )
        {
          v14 = *(const char **)(a4 + 36);
          v30 = *(_DWORD *)(a4 + 60);
          v15 = *(_WORD *)v24;
          v29 = a4 + 41;
          v16 = *(_WORD *)(v24 + 2);
          v25 = 27;
          v20 = v15;
          v21 = v16;
          if ( v14 )
            strcpy(&v32, v14);
          v19 = sub_10018BA0(v23, (int)&v25, (int)&v20, (int)&v26, v22);
        }
        break;
      default:
        return v19;
    }
  }
  return v19;
}

//----- (1000E190) --------------------------------------------------------
char __cdecl sub_1000E190(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@3
  signed int v6; // ecx@4
  signed int v7; // ST18_4@4
  double v8; // st7@4
  signed int v9; // ST18_4@4
  int v10; // ecx@4
  double v11; // st7@4
  int v12; // eax@6
  unsigned __int8 v13; // al@9
  char *v14; // eax@9
  float v15; // [sp+Ch] [bp-30h]@4
  float v16; // [sp+10h] [bp-2Ch]@4
  int v17; // [sp+14h] [bp-28h]@4
  float v18; // [sp+18h] [bp-24h]@4
  int v19; // [sp+1Ch] [bp-20h]@4
  int v20; // [sp+20h] [bp-1Ch]@4
  float v21; // [sp+24h] [bp-18h]@4
  float v22; // [sp+28h] [bp-14h]@4
  float v23; // [sp+2Ch] [bp-10h]@4
  char v24; // [sp+30h] [bp-Ch]@8

  if ( *a5 == 32802 || *a5 == 32888 )
  {
    v6 = *(_WORD *)(a3 + 2);
    v7 = *(_WORD *)a3;
    v17 = *(_DWORD *)(a2 + 8);
    v8 = (double)v7;
    v9 = v6;
    v10 = *(_DWORD *)(a2 + 4);
    v19 = 0;
    v15 = v8;
    v20 = v10;
    v16 = (double)v9;
    v18 = *(float *)(a2 + 12);
    v21 = *(float *)(a2 + 16);
    v22 = *(float *)(a2 + 20);
    v23 = 0.0;
    v11 = *(float *)(a4 + 4);
    if ( v11 < -3.141592741012573 || v11 >= 3.141592741012573 )
    {
      sub_1000F530((int)&v24, &unk_1006DED8, 6);
    }
    else
    {
      v12 = sub_100379D0(*(float *)(a4 + 4));
      if ( !v12 )
        v12 = 360;
      sub_1000F650(&v24, 6u, "%03d", v12);
    }
    v13 = sub_100143F0(*(_BYTE *)a4);
    v14 = sub_100141B0(v13);
    sub_1000F680(&v24, v14, 6);
    sub_1000FBA0((int)&v24, (int)&v15);
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1000E2E0) --------------------------------------------------------
char __cdecl sub_1000E2E0(int a1, int a2, int *a3, int a4, int a5)
{
  int v5; // ecx@1
  char result; // al@1
  bool v7; // zf@2
  __int16 v8; // dx@3

  v5 = a4;
  result = 1;
  if ( *(_DWORD *)(a4 + 8) )
  {
    v7 = *(_BYTE *)a4 == 0;
    a4 = *a3;
    if ( !v7 )
    {
      v8 = *(_WORD *)(v5 + 4);
      if ( *(_BYTE *)(v5 + 1) )
      {
        LOWORD(a4) = *(_WORD *)(v5 + 2) + a4;
        HIWORD(a4) += v8;
      }
      else
      {
        LOWORD(a4) = *(_WORD *)(v5 + 2);
        HIWORD(a4) = v8;
      }
    }
    result = ((int (__cdecl *)(int, _DWORD, int *, _DWORD, int))dword_101EF5E0[2 * (**(_DWORD **)(v5 + 8) & 0xFF)])(
               a1,
               *(_DWORD *)(v5 + 8),
               &a4,
               *(_DWORD *)(v5 + 12),
               a5);
  }
  return result;
}
// 101EF5E0: using guessed type int dword_101EF5E0[];

//----- (1000E350) --------------------------------------------------------
_DWORD *__cdecl sub_1000E350(_DWORD *a1)
{
  _DWORD *result; // eax@1

  result = a1;
  *a1 = 0;
  return result;
}

//----- (1000E360) --------------------------------------------------------
int __cdecl sub_1000E360(int *a1, int a2)
{
  int result; // eax@1
  int i; // esi@1

  result = (int)a1;
  for ( i = *a1; i; i = *(_DWORD *)(i + 4) )
    result = (*(int (__cdecl **)(int, int))i)(i, a2);
  return result;
}

//----- (1000E390) --------------------------------------------------------
_DWORD *__cdecl sub_1000E390(_DWORD *a1, int a2)
{
  _DWORD *result; // eax@1

  result = a1;
  *(_DWORD *)(a2 + 4) = *a1;
  *a1 = a2;
  return result;
}

//----- (1000E3A0) --------------------------------------------------------
char __cdecl sub_1000E3A0(int a1, int a2, int a3)
{
  char result; // al@1

  result = 0;
  if ( **(_WORD **)(a1 + 52) == -32744 || !a2 || *(_BYTE *)(a2 + a3) & 2 )
    result = 1;
  return result;
}

//----- (1000E3D0) --------------------------------------------------------
char __cdecl sub_1000E3D0(int a1, _WORD *a2, int a3)
{
  char result; // al@1

  result = 0;
  if ( *a2 == -32665 || !*(_BYTE *)(a1 + 5) && a3 && *(_DWORD *)(a1 + 48) == a3 )
    result = 1;
  return result;
}

//----- (1000E400) --------------------------------------------------------
bool __cdecl sub_1000E400(char *a1, int *a2, _DWORD *a3)
{
  int v3; // ecx@1
  bool v4; // zf@1
  int v5; // eax@2

  v3 = *(_DWORD *)a1 & 0xFF;
  v4 = v3 == 141;
  if ( v3 != 141 )
  {
    v5 = (int)&a1[dword_101EF5E4[8 * v3]];
    if ( a2 )
      *a2 = v5;
    if ( a3 )
      *a3 = v5 + 4;
    v4 = v3 == 141;
  }
  return !v4;
}

//----- (1000E450) --------------------------------------------------------
char __cdecl sub_1000E450(int a1, char *a2)
{
  char *v2; // edi@1
  int v3; // esi@1
  char **v4; // eax@2

  v2 = a2;
  v3 = 0;
  if ( sub_1000E400(a2, 0, &a2) )
  {
    do
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4 * v3) = v2;
      v2 = a2;
      *(_BYTE *)(v3++ + *(_DWORD *)(a1 + 64)) = 3;
      LOBYTE(v4) = sub_1000E400(v2, 0, &a2);
    }
    while ( (_BYTE)v4 );
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4 * v3) = v2;
  }
  else
  {
    v4 = *(char ***)(a1 + 56);
    *v4 = v2;
  }
  return (unsigned int)v4;
}

//----- (1000E4B0) --------------------------------------------------------
int __cdecl sub_1000E4B0(int a1, int a2, char *a3, int a4)
{
  char *v4; // edi@1
  int v5; // eax@1
  int v6; // ecx@1
  int v8; // [sp+8h] [bp-4h]@1

  v4 = a3;
  sub_1000E400(a3, &v8, 0);
  sub_100012F0(a1, *(_DWORD *)(a1 + 56));
  v5 = *(_DWORD *)(a1 + 56);
  LOWORD(a3) = *(_WORD *)v8 + *(_WORD *)(v5 + 36);
  v6 = *(_DWORD *)v4;
  HIWORD(a3) = *(_WORD *)(v8 + 2) + *(_WORD *)(v5 + 38);
  return ((int (__cdecl *)(int, char *, char **, int, int))dword_101EF5E0[2 * (unsigned __int8)v6])(a1, v4, &a3, a4, a2);
}
// 101EF5E0: using guessed type int dword_101EF5E0[];

//----- (1000E520) --------------------------------------------------------
char __cdecl sub_1000E520(int a1, char *a2, int a3)
{
  char *v3; // edi@1
  int v4; // ebp@3
  signed int v5; // ebx@3
  char result; // al@3
  _WORD *v7; // ST2C_4@6

  v3 = a2;
  if ( !a2 )
    sub_1000D740("..\\lib\\adl\\cdp_fld_utl.c", 323, 1, a2);
  v4 = *(_DWORD *)(a1 + 56);
  v5 = (unsigned __int8)v3[230];
  result = 1;
  if ( (*(_BYTE *)(v4 + 26) || v4 != *(_DWORD *)(a1 + 48)) && v5 < (unsigned __int8)v3[68] )
  {
    v7 = (_WORD *)a3;
    *(_DWORD *)(a1 + 56) = v3;
    *(_BYTE *)(a1 + 3) = sub_1000E3D0(a1, v7, (int)v3);
    sub_1000E400(*(char **)(*((_DWORD *)v3 + 14) + 4 * v5), (int *)&a2, 0);
    sub_100012F0(a1, (int)v3);
    result = ((int (__cdecl *)(int, _DWORD, char *, _DWORD, int))dword_101EF5E0[2
                                                                              * (**(_DWORD **)(*((_DWORD *)v3 + 14)
                                                                                             + 4 * v5) & 0xFF)])(
               a1,
               *(_DWORD *)(*((_DWORD *)v3 + 14) + 4 * v5),
               a2,
               *(_DWORD *)(*((_DWORD *)v3 + 15) + 4 * v5),
               a3);
    *(_DWORD *)(a1 + 56) = v4;
    *(_BYTE *)(a1 + 3) = 0;
  }
  return result;
}
// 101EF5E0: using guessed type int dword_101EF5E0[];

//----- (1000E5D0) --------------------------------------------------------
int __cdecl sub_1000E5D0(int a1)
{
  int v1; // eax@1
  int v2; // esi@1
  char v4; // [sp+4h] [bp-68h]@3

  v1 = sub_10016EA0(&a1, 4u, (int)&unk_1006F5E0, 8, 20, -1);
  v2 = v1;
  if ( v1 < 0 || (unsigned int)v1 >= 0x14 )
  {
    sprintf(&v4, "UNKNOWN EVENT %lu\n", a1);
    sub_1000D740(".\\cdp_evnt_map.c", 328, 1, &v4);
  }
  return (int)*(&off_1006F5E4 + 2 * v2);
}
// 1006F5E4: using guessed type void *off_1006F5E4;

//----- (1000E650) --------------------------------------------------------
char __thiscall sub_1000E650(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 12;
  sub_10031DC0(3000, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1000E680) --------------------------------------------------------
char __thiscall sub_1000E680(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 30;
  sub_10031DC0(3001, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1000E6B0) --------------------------------------------------------
char __fastcall sub_1000E6B0(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_10032360(3, (_BYTE *)&v2 + 2);
  BYTE2(v2) = byte_1006FCED[2 * sub_10016EA0((int *)((char *)&v2 + 2), 1u, (int)&unk_1006FCEC, 2, 5, -1)];
  if ( sub_10031BF0(3002, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_10031D80(3002, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (1000E720) --------------------------------------------------------
char __thiscall sub_1000E720(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_10031DC0(6077, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1000E750) --------------------------------------------------------
char __fastcall sub_1000E750(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_10032360(3, (_BYTE *)&v2 + 2);
  if ( sub_10031BF0(3003, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_10031D80(3003, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (1000E7A0) --------------------------------------------------------
char sub_1000E7A0()
{
  return 18;
}

//----- (1000E7B0) --------------------------------------------------------
BOOL __thiscall sub_1000E7B0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10032360(97, (_BYTE *)&v2 + 3);
  return BYTE3(v2) == 1;
}

//----- (1000E7D0) --------------------------------------------------------
char __thiscall sub_1000E7D0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 18;
  sub_10031DC0(3005, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1000E800) --------------------------------------------------------
char __thiscall sub_1000E800(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 23;
  sub_10031DC0(3006, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1000E830) --------------------------------------------------------
char __fastcall sub_1000E830(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_10032360(5, (_BYTE *)&v2 + 2);
  if ( sub_10031BF0(3007, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_10031D80(3007, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (1000E880) --------------------------------------------------------
bool __thiscall sub_1000E880(void *this)
{
  int v1; // eax@2
  bool result; // al@2
  unsigned __int16 v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1
  int v5; // [sp+Ch] [bp-4h]@1

  LOBYTE(v4) = sub_1000EF10(this);
  v5 = 2;
  sub_10031C50(9129, &v3, 2, &v5);
  if ( sub_100127D0(v4, 4) )
  {
    v1 = sub_10016EA0(&v4, 1u, (int)&unk_1006FDE8, 8, 2, 2);
    result = (v3 & (unsigned __int16)word_1006FDEC[4 * v1]) != 0;
  }
  else
  {
    result = sub_100127D0(v4, 2) || sub_10012850(6) || sub_10012850(8) || sub_100127D0(v4, 12) || sub_100127D0(v4, 16);
  }
  return result;
}
// 1006FDEC: using guessed type __int16 word_1006FDEC[];

//----- (1000E950) --------------------------------------------------------
int sub_1000E950()
{
  int v1; // [sp+0h] [bp-8h]@1
  int v2; // [sp+4h] [bp-4h]@1

  v1 = 0;
  sub_10031DC0(3012, &v2, 4, &v1);
  return v2;
}

//----- (1000E980) --------------------------------------------------------
char __thiscall sub_1000E980(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 11;
  sub_10031DC0(3009, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1000E9B0) --------------------------------------------------------
char __fastcall sub_1000E9B0(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_10032360(42, (_BYTE *)&v2 + 2);
  if ( sub_10031BF0(3162, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_10031D80(3162, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (1000EA00) --------------------------------------------------------
char __cdecl sub_1000EA00(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_is_booting(a1);
  SYS_exit_krnl();
  return v1;
}
// 10037CD8: using guessed type int SYS_exit_krnl(void);
// 10037CDE: using guessed type int __cdecl SYS_pvg_is_booting(_DWORD);
// 10037CE4: using guessed type int SYS_enter_krnl(void);

//----- (1000EA20) --------------------------------------------------------
char sub_1000EA20()
{
  char v0; // cl@1
  char result; // al@1

  v0 = *(_BYTE *)dword_101F03E0;
  result = 0;
  if ( *(_BYTE *)dword_101F03E0 == 37 || v0 == 3 || v0 == 35 || v0 == 36 || v0 == 40 || v0 == 47 )
    result = 1;
  return result;
}
// 101F03E0: using guessed type int dword_101F03E0;

//----- (1000EA50) --------------------------------------------------------
int __cdecl sub_1000EA50(int a1, char *a2)
{
  if ( (unsigned __int8)a1 >= 0x5Fu )
    sub_1000D740("..\\lib\\adl\\sys_usr.c", 5389, 1, 0);
  if ( !a2 )
    sub_1000D740("..\\lib\\adl\\sys_usr.c", 5390, 1, 0);
  SYS_enter_krnl();
  SYS_pvg_var_ctrl(a1, a2);
  return SYS_exit_krnl();
}
// 10037CD8: using guessed type int SYS_exit_krnl(void);
// 10037CE4: using guessed type int SYS_enter_krnl(void);
// 10037CEA: using guessed type int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD);

//----- (1000EAB0) --------------------------------------------------------
char __thiscall sub_1000EAB0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1000EA50(18, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1000EAD0) --------------------------------------------------------
int __thiscall sub_1000EAD0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_1000EA50(15, (char *)&v2);
  return (int)v2;
}

//----- (1000EAF0) --------------------------------------------------------
int __thiscall sub_1000EAF0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_1000EA50(16, (char *)&v2);
  return (int)v2;
}

//----- (1000EB10) --------------------------------------------------------
char __thiscall sub_1000EB10(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1000EA50(17, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1000EB30) --------------------------------------------------------
int __thiscall sub_1000EB30(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_1000EA50(29, (char *)&v2);
  return (int)v2;
}

//----- (1000EB50) --------------------------------------------------------
char __thiscall sub_1000EB50(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1000EA50(34, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1000EB70) --------------------------------------------------------
char __thiscall sub_1000EB70(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1000EA50(44, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1000EB90) --------------------------------------------------------
char sub_1000EB90()
{
  char v1; // [sp+1h] [bp-1h]@1

  v1 = 0;
  sub_1000EA50(48, &v1);
  return v1;
}

//----- (1000EBB0) --------------------------------------------------------
int __cdecl sub_1000EBB0(char a1)
{
  return sub_1000EA50(56, &a1);
}

//----- (1000EBC0) --------------------------------------------------------
char __cdecl sub_1000EBC0(char a1)
{
  char result; // al@1

  result = -80;
  switch ( a1 )
  {
    case 3:
      result = -126;
      break;
    case 4:
      result = -123;
      break;
    case 5:
      result = -108;
      break;
    case 6:
      result = -105;
      break;
    default:
      return result;
  }
  return result;
}

//----- (1000EC00) --------------------------------------------------------
char __cdecl sub_1000EC00(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 74;
      break;
    case 1:
      result = 73;
      break;
    case 2:
      result = 75;
      break;
    case 3:
      result = -127;
      break;
    case 4:
      result = -124;
      break;
    case 5:
      result = -109;
      break;
    case 6:
      result = -106;
      break;
    default:
      sub_1000D740("..\\lib\\adl\\iop_cdu_unit_intf.c", 564, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (1000EC70) --------------------------------------------------------
signed int __cdecl sub_1000EC70(char a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = 4;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 64;
      break;
    case 4:
      result = 128;
      break;
    case 5:
      result = 16;
      break;
    case 6:
      result = 32;
      break;
    default:
      sub_1000D740("..\\lib\\adl\\iop_cdu_unit_intf.c", 638, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1000ECF0) --------------------------------------------------------
char __cdecl sub_1000ECF0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 13;
      break;
    case 1:
      result = 12;
      break;
    case 2:
      result = 14;
      break;
    case 3:
      result = -128;
      break;
    case 4:
      result = -125;
      break;
    case 5:
      result = -110;
      break;
    case 6:
      result = -107;
      break;
    default:
      sub_1000D740("..\\lib\\adl\\iop_cdu_unit_intf.c", 712, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (1000ED60) --------------------------------------------------------
char __cdecl sub_1000ED60(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 3:
      result = 0;
      break;
    case 4:
      result = 1;
      break;
    case 5:
      result = 2;
      break;
    case 0x28:
      result = 3;
      break;
    case 0x29:
      result = 4;
      break;
    case 0x33:
      result = 5;
      break;
    case 0x34:
      result = 6;
      break;
    default:
      sub_1000D740("..\\lib\\adl\\iop_cdu_unit_intf.c", 786, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (1000EE10) --------------------------------------------------------
char __cdecl sub_1000EE10(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 4:
      result = 0;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      sub_1000D740("..\\lib\\adl\\iop_cdu_unit_intf.c", 1096, 1, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (1000EF10) --------------------------------------------------------
char __thiscall sub_1000EF10(void *this)
{
  int v1; // eax@1

  v1 = sub_100128C0(this);
  return sub_1000EE10(v1);
}

//----- (1000EF20) --------------------------------------------------------
int __cdecl sub_1000EF20(int *a1)
{
  int result; // eax@1

  result = sub_1001ABC0((int)(a1 + 1), 0);
  if ( result )
  {
    *a1 = sub_10031910();
    result = sub_1001AA00();
  }
  return result;
}

//----- (1000EF50) --------------------------------------------------------
char __usercall sub_1000EF50@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@2
  char *v3; // eax@2
  char result; // al@2
  int v5; // eax@4
  char *v6; // eax@4

  if ( a2 == 13 )
  {
    v2 = sub_100319E0(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 88));
    v3 = sub_1001BC80("%i %i\r\n", 13, v2);
    sub_1001B220(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"356", (int)v3);
    result = 1;
  }
  else if ( a2 == 14 )
  {
    v5 = sub_100319C0(*(_DWORD *)(a1 + 4));
    v6 = sub_1001BC80("%i %i\r\n", 14, v5);
    sub_1001B220(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)&unk_100707B4, (int)v6);
    result = 1;
  }
  else
  {
    sub_1000D740(".\\test\\tst_tsk_common.c", 405, 1, 0);
    result = 0;
  }
  return result;
}

//----- (1000EFF0) --------------------------------------------------------
int __cdecl sub_1000EFF0(const char *a1)
{
  int result; // eax@1

  result = sub_10018D20();
  if ( a1 )
    result = sub_1001ABF0(dword_101080D0[result] + 4, (int)a1, strlen(a1));
  return result;
}
// 101080D0: using guessed type int dword_101080D0[];

//----- (1000F030) --------------------------------------------------------
char __cdecl sub_1000F030(void *a1)
{
  int (**v1)(); // eax@1
  char **v2; // eax@1

  memset(a1, 0, 0xE0u);
  sub_1001AB40((char *)a1 + 4);
  v1 = sub_100215A0();
  sub_1001AAE0((int)v1, 0, 0);
  dword_101080D0[sub_10018D20()] = (int)a1;
  v2 = sub_10021560((int)sub_1000EFF0);
  return sub_1001AC10(v2);
}
// 101080D0: using guessed type int dword_101080D0[];

//----- (1000F080) --------------------------------------------------------
signed int __cdecl sub_1000F080(unsigned int a1, int a2)
{
  signed int v2; // edi@1
  int v3; // eax@1
  unsigned int v4; // ebx@1
  int v5; // ebp@1
  signed int result; // eax@3
  char *v7; // eax@10
  __int16 v8; // ax@11
  char *v9; // eax@13
  char *v10; // eax@14
  char *v11; // eax@16
  int v12; // ebx@17
  char *v13; // eax@18
  char *v14; // eax@19
  char **v15; // eax@23
  char **v16; // eax@23
  char **v17; // eax@23
  char **v18; // eax@24
  char **v19; // eax@24
  char **v20; // eax@24
  int v21; // [sp-4h] [bp-30h]@9
  int v22; // [sp-4h] [bp-30h]@17
  char v23; // [sp+10h] [bp-1Ch]@6
  char v24; // [sp+14h] [bp-18h]@14

  v2 = 4;
  v3 = sub_10031910();
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3;
  if ( a1 < 8 )
  {
LABEL_28:
    result = v2;
  }
  else
  {
    switch ( a1 )
    {
      case 0xBu:
        sub_10031A90(*(_DWORD *)(a2 + 4));
        result = 0;
        break;
      case 0xCu:
        if ( sub_10031910() - v3 < v4 )
        {
          do
          {
            if ( *(_BYTE *)(a2 + 88) )
              sub_10031B20(&v23);
          }
          while ( sub_10031910() - v5 < v4 );
        }
        result = 0;
        break;
      case 8u:
        v21 = *(_DWORD *)(a2 + 4);
        if ( v4 < 0x40 )
        {
          v8 = sub_100318F0(v21);
          if ( v8 & 0xF32 || v8 & 0xC4 )
          {
            sub_10031930((int)&v24, 1, *(_DWORD *)(a2 + 4), 20);
            v10 = sub_1001BC80("The %s task is loaded.", &v24);
            sub_1001B220(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"512", (int)v10);
            result = 0;
          }
          else
          {
            v9 = sub_1001BC80("Task #%d is not loaded.", *(_DWORD *)(a2 + 4));
            sub_1001B220(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"520", (int)v9);
            result = 12;
          }
        }
        else
        {
          v7 = sub_1001BC80("Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.", v21);
          sub_1001B220(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"489", (int)v7);
          result = 9;
        }
        break;
      case 9u:
        if ( v4 >= 0x40 )
        {
          v11 = sub_1001BC80(
                  "Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.",
                  *(_DWORD *)(a2 + 4));
          sub_1001B220(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"543", (int)v11);
        }
        v12 = sub_10031880(*(_DWORD *)(a2 + 4));
        v22 = *(_DWORD *)(a2 + 88);
        if ( v12 == *(_DWORD *)(a2 + 88) )
        {
          v13 = sub_1001BC80("The %d task's level is equal to %d.", *(_DWORD *)(a2 + 4), v22);
          sub_1001B220(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"557", (int)v13);
          v2 = 0;
        }
        else
        {
          v14 = sub_1001BC80("The %d task's level is equal to %d, not %d.", *(_DWORD *)(a2 + 4), v12, v22);
          sub_1001B220(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"562", (int)v14);
          v2 = 12;
        }
        if ( v12 )
          goto LABEL_28;
        sub_1001B220(
          3,
          (int)"**MSG**",
          (int)".\\test\\tst_tsk_common.c",
          (int)"572",
          (int)"The task's criticality level is zero, make sure the task is running.");
        result = v2;
        break;
      case 0xAu:
        sub_10031970(v4, *(_DWORD *)(a2 + 88), 0, 0);
        result = 4;
        break;
      case 0x12u:
        v15 = sub_10021560((int)sub_1000EFF0);
        sub_1001B2F0((int)v15);
        v16 = sub_10022940((int)sub_1000EFF0);
        sub_1001B2F0((int)v16);
        v17 = sub_10022940((int)sub_1000EFF0);
        sub_1001AC10(v17);
        result = 4;
        break;
      case 0x13u:
        v18 = sub_10021560((int)sub_1000EFF0);
        sub_1001B2F0((int)v18);
        v19 = sub_10022940((int)sub_1000EFF0);
        sub_1001B2F0((int)v19);
        v20 = sub_10021560((int)sub_1000EFF0);
        sub_1001AC10(v20);
        result = 4;
        break;
      default:
        if ( a1 - 13 > 4 )
        {
          v2 = 11;
          goto LABEL_28;
        }
        result = sub_1000EF50(a2, a1) != 0 ? 0 : 12;
        break;
    }
  }
  return result;
}

//----- (1000F420) --------------------------------------------------------
char **sub_1000F420()
{
  return off_100707A0;
}
// 100707A0: using guessed type char *off_100707A0[3];

//----- (1000F440) --------------------------------------------------------
int __cdecl sub_1000F440(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101080E4 = a1;
  return result;
}
// 101080E4: using guessed type int dword_101080E4;

//----- (1000F450) --------------------------------------------------------
int __cdecl sub_1000F450(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101080E8 = a1;
  return result;
}
// 101080E8: using guessed type int dword_101080E8;

//----- (1000F460) --------------------------------------------------------
#error "1000F465: call analysis failed (funcsize=28)"

//----- (1000F490) --------------------------------------------------------
char __cdecl sub_1000F490(char a1, unsigned __int16 a2, char a3)
{
  char result; // al@1

  result = a1;
  do
    result += a3;
  while ( !(a2 & (unsigned __int16)word_10071EC8[(unsigned __int8)result]) && result != a1 );
  return result;
}
// 10071EC8: using guessed type __int16 word_10071EC8[];

//----- (1000F4C0) --------------------------------------------------------
bool __cdecl sub_1000F4C0(signed int a1, signed int a2, _BYTE *a3)
{
  bool result; // al@2
  signed int v4; // ebx@3
  signed int v5; // edi@3
  signed int i; // esi@5

  if ( a3 )
  {
    v4 = a1;
    v5 = 0;
    if ( a1 < 0 )
    {
      v4 = -a1;
      *a3 = 45;
      v5 = 1;
    }
    for ( i = a2; i > v5; v4 /= 10 )
      a3[--i] = v4 % 10 + 48;
    result = v4 == 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000F530) --------------------------------------------------------
int __cdecl sub_1000F530(int a1, _BYTE *a2, int a3)
{
  int v3; // esi@2
  int v4; // eax@2
  _BYTE *v5; // ecx@3
  int result; // eax@7

  if ( a3 <= 0 )
    goto LABEL_11;
  v3 = a3 - 1;
  v4 = 0;
  if ( a3 - 1 > 0 )
  {
    v5 = a2;
    do
    {
      if ( !*v5 )
        break;
      v5[a1 - (_DWORD)a2] = *v5;
      ++v4;
      ++v5;
    }
    while ( v4 < v3 );
  }
  *(_BYTE *)(v4 + a1) = 0;
  *(_BYTE *)(v3 + a1) = 0;
  if ( a2[v4] )
LABEL_11:
    result = -1;
  else
    result = v4 + 1;
  return result;
}

//----- (1000F580) --------------------------------------------------------
int __cdecl sub_1000F580(void *a1, size_t a2)
{
  _BYTE *v2; // eax@1
  int result; // eax@2

  v2 = memchr(a1, 0, a2);
  if ( v2 )
    result = v2 - (_BYTE *)a1;
  else
    result = -2;
  return result;
}

//----- (1000F5B0) --------------------------------------------------------
int __cdecl sub_1000F5B0(int a1, char *a2, int a3)
{
  int v3; // eax@3
  int i; // esi@5
  int v5; // esi@8
  int result; // eax@8

  if ( a1 && a2 )
  {
    v3 = a3;
    if ( !a3 )
      v3 = strlen((const char *)a1);
    for ( i = v3 - 1; i >= 0; --i )
    {
      if ( !strchr(a2, *(_BYTE *)(i + a1)) )
        break;
    }
    v5 = i + 1;
    *(_BYTE *)(v5 + a1) = 0;
    result = v5;
  }
  else
  {
    result = a3;
  }
  return result;
}

//----- (1000F610) --------------------------------------------------------
int __cdecl sub_1000F610(char *a1, size_t a2, char *a3, va_list a4)
{
  int result; // eax@2

  if ( (signed int)a2 > 0 )
  {
    result = _vsnprintf(a1, a2, a3, a4);
    if ( result < 0 )
      result = -1;
    a1[a2 - 1] = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1000F650) --------------------------------------------------------
int sub_1000F650(char *a1, size_t a2, char *a3, ...)
{
  int result; // eax@1
  va_list va; // [sp+10h] [bp+10h]@1

  va_start(va, a3);
  result = sub_1000F610(a1, a2, a3, va);
  if ( result < 0 )
    result = -1;
  return result;
}

//----- (1000F680) --------------------------------------------------------
int __cdecl sub_1000F680(const char *a1, _BYTE *a2, int a3)
{
  unsigned int v3; // kr00_4@1

  v3 = strlen(a1);
  return sub_1000F530((int)&a1[v3], a2, a3 - v3);
}

//----- (1000F6C0) --------------------------------------------------------
int __cdecl sub_1000F6C0(int a1, int a2)
{
  return sub_1000F5B0(a1, "_ ", a2);
}

//----- (1000F6E0) --------------------------------------------------------
signed int __cdecl sub_1000F6E0(int (__cdecl *a1)(int))
{
  signed int result; // eax@1
  int (__cdecl **v2)(int); // ecx@1

  result = 0;
  v2 = &off_1005B228;
  do
  {
    if ( *v2 == a1 )
      break;
    ++result;
    v2 += 14;
  }
  while ( result < 2 );
  if ( result == 2 )
    result = -1;
  return result;
}
// 1005B228: using guessed type int (__cdecl *off_1005B228)(int);

//----- (1000F710) --------------------------------------------------------
char *__cdecl sub_1000F710(unsigned __int8 a1)
{
  char *result; // eax@2

  if ( (signed int)a1 >= 2 )
    result = (char *)&unk_1005E69C;
  else
    result = (char *)&unk_1005B22D + 56 * a1;
  return result;
}

//----- (1000F740) --------------------------------------------------------
int __cdecl sub_1000F740(float a1)
{
  double v1; // st7@1
  signed int v2; // ecx@1
  int result; // eax@13

  v1 = a1;
  v2 = 6;
  if ( a1 > 0.0 )
    v2 = 0;
  if ( v1 > 8.0 )
    v2 = 1;
  if ( v1 > 10.0 )
    v2 = 2;
  if ( v1 > 12.5 )
    v2 = 3;
  if ( v1 > 14.0 )
    v2 = 4;
  if ( v1 > 16.0 )
    v2 = 6;
  result = 7;
  if ( v1 <= 20.0 )
    result = v2;
  return result;
}

//----- (1000F7D0) --------------------------------------------------------
int __cdecl sub_1000F7D0(int a1, _WORD *a2, char *a3, int a4, int a5, int a6, int a7)
{
  int v7; // esi@1
  char *v8; // ebp@1
  int v9; // edi@1
  int v10; // eax@3
  int v11; // ebx@3
  bool v12; // al@5
  bool v13; // al@9
  _WORD *v14; // edx@11
  int result; // eax@13
  char *v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v7 = a1;
  sub_100012F0(a1, *(_DWORD *)(a1 + 56));
  v8 = a3;
  v9 = 0;
  if ( sub_1000E400(a3, &v17, &v16) )
  {
    do
    {
      if ( sub_1000E3A0(v7, a5, v9) )
      {
        v10 = *(_DWORD *)(v7 + 56);
        LOWORD(a1) = *(_WORD *)a6 + *(_WORD *)v17 + *(_WORD *)(v10 + 36);
        HIWORD(a1) = *(_WORD *)(a6 + 2) + *(_WORD *)(v17 + 2) + *(_WORD *)(v10 + 38);
        v11 = a7;
        v12 = v9 == a7 && sub_1000E3D0(v7, a2, v10);
        *(_BYTE *)(v7 + 3) = v12;
        v13 = v9 == v11 && *(_DWORD *)(v7 + 56) == *(_DWORD *)(*(_DWORD *)(v7 + 48) + 4);
        v14 = a2;
        *(_BYTE *)(v7 + 9) = v13;
        ((void (__cdecl *)(int, char *, int *, _DWORD, _WORD *))dword_101EF5E0[2 * (*(_DWORD *)v8 & 0xFF)])(
          v7,
          v8,
          &a1,
          *(_DWORD *)(a4 + 4 * v9),
          v14);
      }
      v8 = v16;
      ++v9;
    }
    while ( sub_1000E400(v16, &v17, &v16) );
  }
  result = *a2 - 32802;
  if ( *a2 == 32802 )
  {
    *(_BYTE *)(v7 + 1) = 1;
  }
  else
  {
    result = *a2 - 32888;
    if ( *a2 == 32888 )
    {
      *(_BYTE *)(v7 + 1) = 1;
      result = j_gdi_pvg_flush();
      *(_BYTE *)(v7 + 3) = 0;
      return result;
    }
  }
  *(_BYTE *)(v7 + 3) = 0;
  return result;
}
// 100316B0: using guessed type int j_gdi_pvg_flush(void);
// 101EF5E0: using guessed type int dword_101EF5E0[];

//----- (1000F910) --------------------------------------------------------
int __cdecl sub_1000F910(int a1, _WORD *a2, char *a3, int a4, int a5, int a6)
{
  __int16 v7; // [sp+0h] [bp-4h]@1
  __int16 v8; // [sp+2h] [bp-2h]@1

  v7 = 0;
  v8 = 0;
  return sub_1000F7D0(a1, a2, a3, a4, a5, (int)&v7, a6);
}

//----- (1000F950) --------------------------------------------------------
void __usercall sub_1000F950(int a1@<eax>, int a2@<edi>, int a3@<esi>, float a4)
{
  double v4; // st7@1
  double v5; // st6@1
  double v6; // st5@2
  double v7; // st6@6
  float v8; // ST18_4@6
  double v9; // st5@6
  double v10; // st7@6
  float v11; // [sp+8h] [bp-14h]@4
  float v12; // [sp+Ch] [bp-10h]@4
  float v13; // [sp+10h] [bp-Ch]@1
  float v14; // [sp+14h] [bp-8h]@4
  float v15; // [sp+18h] [bp-4h]@1
  float v16; // [sp+20h] [bp+4h]@6
  float v17; // [sp+20h] [bp+4h]@6
  float v18; // [sp+20h] [bp+4h]@6

  v13 = sub_10032020(*(_DWORD *)(a3 + 8), a1, *(float *)(a3 + 12));
  v4 = 4.0;
  v15 = *(float *)(a3 + 12) + 4.0;
  v5 = v13;
  if ( 0.0 == *(float *)(a3 + 32) )
    v6 = v13;
  else
    v6 = *(float *)(a3 + 32);
  v14 = v6 + 4.0;
  v11 = *(float *)a3 - *(float *)(a3 + 24) * v5;
  v12 = *(float *)(a3 + 4) - *(float *)(a3 + 28) * *(float *)(a3 + 12);
  if ( LOBYTE(a4) )
  {
    v11 = sub_100376F0(v11, 1.0) + 0.5;
    v12 = sub_10037920(v12, 1.0);
    v4 = 4.0;
    v5 = v13;
  }
  v16 = (v4 + v5) * *(float *)(a3 + 24) + v11 - 2.0;
  v7 = v14;
  v8 = v16 - *(float *)(a3 + 24) * v14;
  v17 = *(float *)(a3 + 12) * 0.5 + v12;
  v18 = v17 - 0.5 * v15;
  *(float *)(a2 + 304) = v15 + v18;
  *(float *)(a2 + 292) = v8;
  *(float *)(a2 + 300) = v7 + v8;
  v9 = v18;
  *(float *)(a2 + 296) = *(float *)&v9;
  v10 = v12;
  *(float *)(a2 + 36) = v11;
  *(float *)(a2 + 40) = *(float *)&v10;
}

//----- (1000FAA0) --------------------------------------------------------
void *sub_1000FAA0()
{
  void *result; // eax@1

  result = (void *)dword_101080E4;
  if ( !dword_101080E4 )
    result = &unk_10072BE0;
  return result;
}
// 101080E4: using guessed type int dword_101080E4;

//----- (1000FAB0) --------------------------------------------------------
int __usercall sub_1000FAB0@<eax>(int a1@<edi>, int a2@<esi>, char a3)
{
  float v3; // ST18_4@1
  float v5; // [sp+Ch] [bp-8h]@1
  float v6; // [sp+10h] [bp-4h]@1

  v3 = sub_10032020(*(_DWORD *)(a2 + 8) & 0x3FFFFFFF, a1, *(float *)(a2 + 12));
  v6 = *(float *)a2 - *(float *)(a2 + 24) * v3;
  v5 = *(float *)(a2 + 4) - *(float *)(a2 + 28) * *(float *)(a2 + 12);
  if ( a3 )
  {
    v6 = sub_100376F0(v6, 1.0) + 0.5;
    v5 = sub_10037920(v5, 1.0);
  }
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_color_u32(*(_DWORD *)(a2 + 20));
  sub_10031E80(*(_DWORD *)(a2 + 8), a1, v6, v5, *(float *)(a2 + 12));
  return j_gdi_pvg_disable(35);
}
// 10031610: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10031620: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10031630: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10031690: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (1000FB80) --------------------------------------------------------
void __cdecl sub_1000FB80(int a1, int a2, int a3)
{
  sub_1000F950(a2, a1, a3, COERCE_FLOAT(1));
}

//----- (1000FBA0) --------------------------------------------------------
int __cdecl sub_1000FBA0(int a1, int a2)
{
  return sub_1000FAB0(a1, a2, 1);
}

//----- (1000FBC0) --------------------------------------------------------
void __cdecl sub_1000FBC0(float a1, float a2, float a3, float a4, char a5)
{
  void *v5; // ebp@3
  void *v6; // ecx@5
  void *v7; // ecx@5
  float v8; // ST28_4@5
  float v9; // ST2C_4@5
  double v10; // st7@5
  float v11; // ST28_4@7
  float v12; // ST2C_4@7
  float v13; // ST28_4@7
  float v14; // [sp+1Ch] [bp-44h]@5
  char v15; // [sp+20h] [bp-40h]@5
  float v16; // [sp+30h] [bp-30h]@5
  float v17; // [sp+34h] [bp-2Ch]@5
  float v18; // [sp+38h] [bp-28h]@5

  if ( a3 != a1 && a4 != a2 )
  {
    v5 = sub_1000FAA0();
    j_gdi_pvg_push_attrib(0x2000);
    j_gdi_pvg_enable(38);
    j_gdi_pvg_enable(35);
    j_gdi_pvg_blend_func(4, 5);
    if ( (unsigned __int8)a5 >= 2u )
      sub_1000D740("..\\lib\\adl\\cdp_fld_3d_utl.c", 1596, 1, 0);
    j_gdi_pvg_color_u32(*((_DWORD *)v5 + (unsigned __int8)a5));
    j_gdi_pvg_begin(72);
    sub_100317B0(a1, a2);
    sub_100317B0(a3, a2);
    sub_100317B0(a3, a4);
    sub_100317B0(a1, a4);
    j_gdi_pvg_end();
    j_gdi_pvg_read_matrix(&v15, 4, 4, 0);
    v8 = (double)((unsigned int)sub_1000EAF0(v6) >> 1);
    v9 = (double)((unsigned int)sub_1000EAD0(v7) >> 1);
    v14 = sqrt(v9 * (v9 * v16 * v16) + v8 * (v8 * v17 * v17) + v18 * v18 * 0.5);
    v10 = 0.0;
    if ( v14 != 0.0 )
      v10 = *((float *)v5 + 7) * 0.5 / v14;
    v11 = v10;
    sub_100316D0(*((float *)v5 + 7));
    j_gdi_pvg_color_u32(*((_DWORD *)v5 + (unsigned __int8)a5 + 2));
    j_gdi_pvg_begin(64);
    v12 = v11 + a2;
    sub_100317B0(a1, v12);
    v13 = a4 - v11;
    sub_100317B0(a3, v13);
    sub_100317B0(a3, v12);
    sub_100317B0(a1, v13);
    j_gdi_pvg_end();
    sub_100316D0(1.0);
    j_gdi_pvg_pop_attrib();
  }
}
// 100315B0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10031610: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10031620: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10031690: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 100316A0: using guessed type int j_gdi_pvg_end(void);
// 10031760: using guessed type int j_gdi_pvg_pop_attrib(void);
// 10031770: using guessed type int __cdecl j_gdi_pvg_push_attrib(_DWORD);
// 10031780: using guessed type int __cdecl j_gdi_pvg_read_matrix(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1000FE10) --------------------------------------------------------
void __cdecl sub_1000FE10(float a1, float a2, float a3, float a4, float a5, float a6, char a7)
{
  double v7; // st6@1
  double v8; // st4@1
  float v9; // ST0C_4@1
  float v10; // ST08_4@1
  float v11; // ST04_4@1
  float v12; // [sp+24h] [bp+10h]@1
  float v13; // [sp+24h] [bp+10h]@1
  float v14; // [sp+24h] [bp+10h]@1
  float v15; // [sp+24h] [bp+10h]@1

  v7 = a4 * a6;
  v8 = a3 * a5;
  v12 = a4 + a2 - v7;
  v9 = v12;
  v13 = a3 + a1 - v8;
  v10 = v13;
  v14 = a2 - v7;
  v11 = v14;
  v15 = a1 - v8;
  sub_1000FBC0(v15, v11, v10, v9, a7);
}

//----- (1000FE90) --------------------------------------------------------
int __usercall sub_1000FE90@<eax>(float a1@<eax>, int a2@<ecx>, int a3@<ebx>, int a4)
{
  int v4; // edi@1
  int v5; // esi@1

  v4 = a4;
  v5 = a2;
  sub_1000F950(a3, a4, a2, a1);
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_color_u32(*(_DWORD *)(v5 + 16));
  j_gdi_pvg_begin(72);
  sub_100317B0(*(float *)(v4 + 292), *(float *)(v4 + 296));
  sub_100317B0(*(float *)(v4 + 300), *(float *)(v4 + 296));
  sub_100317B0(*(float *)(v4 + 300), *(float *)(v4 + 304));
  sub_100317B0(*(float *)(v4 + 292), *(float *)(v4 + 304));
  j_gdi_pvg_end();
  j_gdi_pvg_color_u32(*(_DWORD *)(v5 + 20));
  sub_10031E80(*(_DWORD *)(v5 + 8), a3, *(float *)(v4 + 36), *(float *)(v4 + 40), *(float *)(v5 + 12));
  return j_gdi_pvg_disable(35);
}
// 100315B0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10031610: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10031620: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10031630: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10031690: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 100316A0: using guessed type int j_gdi_pvg_end(void);

//----- (1000FF70) --------------------------------------------------------
int __cdecl sub_1000FF70(int a1, int a2, int a3)
{
  float v3; // eax@1

  v3 = *(float *)&a1;
  LOBYTE(v3) = 0;
  return sub_1000FE90(v3, a3, a2, a1);
}

//----- (1000FF90) --------------------------------------------------------
int __cdecl sub_1000FF90(int a1, int a2, int a3)
{
  float v3; // eax@1

  v3 = *(float *)&a1;
  LOBYTE(v3) = 1;
  return sub_1000FE90(v3, a3, a2, a1);
}

//----- (1000FFB0) --------------------------------------------------------
int __cdecl sub_1000FFB0(int a1, int a2, int a3)
{
  int v3; // eax@5
  char v5; // [sp+8h] [bp-24h]@1
  int v6; // [sp+18h] [bp-14h]@5
  int v7; // [sp+1Ch] [bp-10h]@5

  qmemcpy(&v5, (const void *)a3, 0x24u);
  if ( *(_BYTE *)(a1 + 3) && *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 && (byte_101BD3BE || byte_101EF5C0) )
  {
    v3 = *(_DWORD *)(a3 + 16);
    v6 = *(_DWORD *)(a3 + 20);
    v7 = v3;
  }
  return sub_1000FF90(a1, a2, (int)&v5);
}
// 101BD3BE: using guessed type char byte_101BD3BE;
// 101EF5C0: using guessed type char byte_101EF5C0;

//----- (10010020) --------------------------------------------------------
int __cdecl sub_10010020(char *a1, char *a2)
{
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  char v4; // al@2
  int result; // eax@4

  v2 = strstr(a1, a2);
  v3 = strlen(a2);
  result = 0;
  if ( v2 )
  {
    v4 = v2[v3];
    if ( !v4 || v4 == 44 )
      result = 1;
  }
  return result;
}

//----- (10010060) --------------------------------------------------------
void *__usercall sub_10010060@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>)
{
  void *result; // eax@1
  int v4; // [sp+0h] [bp-Ch]@0
  int v5; // [sp+4h] [bp-8h]@0
  int v6; // [sp+8h] [bp-4h]@0

  result = (void *)sub_10031BF0(v4, v5, v6);
  if ( a2 == 6011 )
  {
    if ( result || *(_BYTE *)a3 > 0x3Fu )
    {
      *(_BYTE *)a3 = 63;
      result = (void *)sub_10031D40(6011, (int)a3, a1);
    }
  }
  else if ( result )
  {
    result = memset(a3, 204, a1);
  }
  return result;
}

//----- (100100B0) --------------------------------------------------------
signed int sub_100100B0()
{
  int v0; // edi@5
  void *v1; // esi@5
  signed int v2; // ebp@5
  signed int result; // eax@7
  char v4; // [sp+13h] [bp-1h]@1

  dword_101F03E0 = 0;
  v4 = 0;
  sub_10032360(94, &v4);
  if ( v4 == 3 )
  {
    v4 = 1;
    sub_10031CC0(3201, (int)&v4, 1);
    sub_10032390(94, (int)&v4);
  }
  else if ( v4 == 2 )
  {
    v4 = 0;
    sub_10031CC0(3201, (int)&v4, 1);
    sub_10032390(94, (int)&v4);
  }
  sub_10010060(1u, 6011, &unk_101080F0);
  sub_10010060(0x16u, 6194, &unk_101080F1);
  sub_10010060(1u, 6012, &unk_10108107);
  sub_10010060(1u, 6013, &unk_10108108);
  sub_10010060(1u, 6014, &unk_10108109);
  sub_10010060(1u, 6015, &unk_1010810A);
  sub_10010060(4u, 6078, &unk_1010810C);
  sub_10010060(4u, 6104, &unk_10108110);
  sub_10010060(0x20u, 6016, &unk_10108114);
  sub_10010060(0x20u, 6017, &unk_10108134);
  sub_10010060(0x20u, 6018, &unk_10108154);
  sub_10010060(0x20u, 6019, &unk_10108174);
  sub_10010060(0x20u, 6020, &unk_10108194);
  sub_10010060(0x20u, 6021, &unk_101081B4);
  sub_10010060(0x20u, 6022, &unk_101081D4);
  sub_10010060(0x20u, 6023, &unk_101081F4);
  sub_10010060(0x20u, 6024, &unk_10108214);
  sub_10010060(0x20u, 6025, &unk_10108234);
  sub_10010060(0x20u, 6026, &unk_10108254);
  sub_10010060(0x20u, 6027, &unk_10108274);
  sub_10010060(0x20u, 6028, &unk_10108294);
  sub_10010060(0x20u, 6029, &unk_101082B4);
  sub_10010060(0x20u, 6030, &unk_101082D4);
  sub_10010060(0x20u, 6031, &unk_101082F4);
  sub_10010060(0x20u, 6032, &unk_10108314);
  sub_10010060(0x20u, 6033, &unk_10108334);
  sub_10010060(0x20u, 6034, &unk_10108354);
  sub_10010060(0x20u, 6035, &unk_10108374);
  sub_10010060(0x20u, 6036, &unk_10108394);
  sub_10010060(0x20u, 6037, &unk_101083B4);
  sub_10010060(0x20u, 6038, &unk_101083D4);
  sub_10010060(0x20u, 6039, &unk_101083F4);
  sub_10010060(0x20u, 6040, &unk_10108414);
  sub_10010060(0x20u, 6041, &unk_10108434);
  sub_10010060(0x20u, 6042, &unk_10108454);
  sub_10010060(0x20u, 6043, &unk_10108474);
  sub_10010060(4u, 6044, &unk_10108494);
  sub_10010060(4u, 6045, &unk_10108498);
  sub_10010060(4u, 6046, &unk_1010849C);
  sub_10010060(4u, 6357, &unk_101084A0);
  sub_10010060(4u, 6358, &unk_101084A4);
  sub_10010060(4u, 6359, &unk_101084A8);
  sub_10010060(0x20u, 6047, &unk_101084AC);
  sub_10010060(0x20u, 6048, &unk_101084CC);
  sub_10010060(0x20u, 6049, &unk_101084EC);
  sub_10010060(0x20u, 6050, &unk_1010850C);
  sub_10010060(0x20u, 6051, &unk_1010852C);
  sub_10010060(0x20u, 6052, &unk_1010854C);
  sub_10010060(0x20u, 6053, &unk_1010856C);
  sub_10010060(0x20u, 6054, &unk_1010858C);
  sub_10010060(1u, 6511, &unk_101085AC);
  sub_10010060(1u, 6522, &unk_101085AD);
  sub_10010060(1u, 6057, &unk_101085AE);
  sub_10010060(0x20u, 6075, &unk_10108600);
  sub_10010060(0x20u, 6076, &unk_10108620);
  sub_10010060(1u, 6077, &unk_10108640);
  sub_10010060(4u, 6079, &unk_10108644);
  sub_10010060(4u, 6080, &unk_10108648);
  sub_10010060(0x20u, 6082, &unk_1010864C);
  sub_10010060(0x20u, 6083, &unk_1010866C);
  sub_10010060(0x20u, 6084, &unk_1010868C);
  sub_10010060(0x20u, 6085, &unk_101086AC);
  sub_10010060(0x20u, 6086, &unk_101086CC);
  sub_10010060(0x20u, 6087, &unk_101086EC);
  sub_10010060(0x20u, 6088, &unk_1010870C);
  sub_10010060(0x20u, 6089, &unk_1010872C);
  sub_10010060(0x20u, 6123, &unk_1010874C);
  sub_10010060(0x48u, 6906, &unk_1010876C);
  sub_10010060(0x48u, 6907, &unk_101087B4);
  sub_10010060(0x48u, 6908, &unk_101087FC);
  sub_10010060(0x48u, 6909, &unk_10108844);
  sub_10010060(0x48u, 6910, &unk_1010888C);
  sub_10010060(0x48u, 6911, &unk_101088D4);
  sub_10010060(0x48u, 6912, &unk_1010891C);
  sub_10010060(0x48u, 6913, &unk_10108964);
  sub_10010060(0x48u, 6914, &unk_101089AC);
  sub_10010060(0x48u, 6915, &unk_101089F4);
  sub_10010060(0x48u, 6916, &unk_10108A3C);
  sub_10010060(0x48u, 6917, &unk_10108A84);
  sub_10010060(0x48u, 6918, &unk_10108ACC);
  sub_10010060(0x48u, 6919, &unk_10108B14);
  sub_10010060(0x48u, 6920, &unk_10108B5C);
  sub_10010060(0x48u, 6921, &unk_10108BA4);
  sub_10010060(0x48u, 6922, &unk_10108BEC);
  sub_10010060(0x48u, 6923, &unk_10108C34);
  sub_10010060(0x48u, 6924, &unk_10108C7C);
  sub_10010060(0x48u, 6925, &unk_10108CC4);
  sub_10010060(0x48u, 6926, &unk_10108D0C);
  sub_10010060(0x48u, 6927, &unk_10108D54);
  sub_10010060(0x48u, 6928, &unk_10108D9C);
  sub_10010060(0x48u, 6929, &unk_10108DE4);
  sub_10010060(0x48u, 6930, &unk_10108E2C);
  sub_10010060(0x48u, 6931, &unk_10108E74);
  sub_10010060(0x48u, 6932, &unk_10108EBC);
  sub_10010060(0x48u, 6933, &unk_10108F04);
  sub_10010060(0x48u, 6934, &unk_10108F4C);
  sub_10010060(0x48u, 6935, &unk_10108F94);
  sub_10010060(0x18u, 6163, &unk_10108FDC);
  sub_10010060(0x20u, 6164, &unk_10108FF4);
  sub_10010060(0x20u, 6165, &unk_10109014);
  sub_10010060(2u, 6166, &unk_10109034);
  sub_10010060(0xA4u, 40100, &unk_10109038);
  sub_10010060(0xA4u, 40101, &unk_101090DC);
  sub_10010060(0xA4u, 40102, &unk_10109180);
  sub_10010060(0xA4u, 40103, &unk_10109224);
  sub_10010060(0xA4u, 40104, &unk_101092C8);
  sub_10010060(0xA4u, 40105, &unk_1010936C);
  sub_10010060(0xA4u, 40106, &unk_10109410);
  sub_10010060(0xA4u, 40107, &unk_101094B4);
  sub_10010060(0xA4u, 40108, &unk_10109558);
  sub_10010060(0xA4u, 40109, &unk_101095FC);
  sub_10010060(0xA4u, 40110, &unk_101096A0);
  sub_10010060(0xA4u, 40111, &unk_10109744);
  sub_10010060(0xA4u, 40112, &unk_101097E8);
  sub_10010060(0xA4u, 40113, &unk_1010988C);
  sub_10010060(0xA4u, 40114, &unk_10109930);
  sub_10010060(0xA4u, 40115, &unk_101099D4);
  sub_10010060(0xA4u, 40116, &unk_10109A78);
  sub_10010060(0xA4u, 40117, &unk_10109B1C);
  sub_10010060(0xA4u, 40118, &unk_10109BC0);
  sub_10010060(0xA4u, 40119, &unk_10109C64);
  sub_10010060(0xA4u, 40120, &unk_10109D08);
  sub_10010060(0xA4u, 40121, &unk_10109DAC);
  sub_10010060(0xA4u, 40122, &unk_10109E50);
  sub_10010060(0xA4u, 40123, &unk_10109EF4);
  sub_10010060(0xA4u, 40124, &unk_10109F98);
  sub_10010060(0xA4u, 40125, &unk_1010A03C);
  sub_10010060(0xA4u, 40126, &unk_1010A0E0);
  sub_10010060(0xA4u, 40127, &unk_1010A184);
  sub_10010060(0xA4u, 40128, &unk_1010A228);
  sub_10010060(0xA4u, 40129, &unk_1010A2CC);
  sub_10010060(0xA4u, 40130, &unk_1010A370);
  sub_10010060(0xA4u, 40131, &unk_1010A414);
  sub_10010060(0xA4u, 40132, &unk_1010A4B8);
  sub_10010060(0xA4u, 40133, &unk_1010A55C);
  sub_10010060(0xA4u, 40134, &unk_1010A600);
  sub_10010060(0xA4u, 40135, &unk_1010A6A4);
  sub_10010060(0xA4u, 40136, &unk_1010A748);
  sub_10010060(0xA4u, 40137, &unk_1010A7EC);
  sub_10010060(0xA4u, 40138, &unk_1010A890);
  sub_10010060(0xA4u, 40139, &unk_1010A934);
  sub_10010060(0xA4u, 40140, &unk_1010A9D8);
  sub_10010060(0xA4u, 40141, &unk_1010AA7C);
  sub_10010060(0xA4u, 40142, &unk_1010AB20);
  sub_10010060(0xA4u, 40143, &unk_1010ABC4);
  sub_10010060(0xA4u, 40144, &unk_1010AC68);
  sub_10010060(0xA4u, 40145, &unk_1010AD0C);
  sub_10010060(0xA4u, 40146, &unk_1010ADB0);
  sub_10010060(0xA4u, 40147, &unk_1010AE54);
  sub_10010060(0xA4u, 40148, &unk_1010AEF8);
  sub_10010060(0xA4u, 40149, &unk_1010AF9C);
  sub_10010060(0xA4u, 40150, &unk_1010B040);
  sub_10010060(0xA4u, 40151, &unk_1010B0E4);
  sub_10010060(0xA4u, 40152, &unk_1010B188);
  sub_10010060(0xA4u, 40153, &unk_1010B22C);
  sub_10010060(0xA4u, 40154, &unk_1010B2D0);
  sub_10010060(0xA4u, 40155, &unk_1010B374);
  sub_10010060(0xA4u, 40156, &unk_1010B418);
  sub_10010060(0xA4u, 40157, &unk_1010B4BC);
  sub_10010060(0xA4u, 40158, &unk_1010B560);
  sub_10010060(0xA4u, 40159, &unk_1010B604);
  sub_10010060(0xA4u, 40160, &unk_1010B6A8);
  sub_10010060(0xA4u, 40161, &unk_1010B74C);
  sub_10010060(0xA4u, 40162, &unk_1010B7F0);
  sub_10010060(0xA4u, 40163, &unk_1010B894);
  sub_10010060(0xA4u, 40164, &unk_1010B938);
  sub_10010060(0xA4u, 40165, &unk_1010B9DC);
  sub_10010060(0xA4u, 40166, &unk_1010BA80);
  sub_10010060(0xA4u, 40167, &unk_1010BB24);
  sub_10010060(0xA4u, 40168, &unk_1010BBC8);
  sub_10010060(0xA4u, 40169, &unk_1010BC6C);
  sub_10010060(0xA4u, 40170, &unk_1010BD10);
  sub_10010060(0xA4u, 40171, &unk_1010BDB4);
  sub_10010060(0xA4u, 40172, &unk_1010BE58);
  sub_10010060(0xA4u, 40173, &unk_1010BEFC);
  sub_10010060(0xA4u, 40174, &unk_1010BFA0);
  sub_10010060(0xA4u, 40175, &unk_1010C044);
  sub_10010060(0xA4u, 40176, &unk_1010C0E8);
  sub_10010060(0xA4u, 40177, &unk_1010C18C);
  sub_10010060(0xA4u, 40178, &unk_1010C230);
  sub_10010060(0xA4u, 40179, &unk_1010C2D4);
  sub_10010060(0xA4u, 40180, &unk_1010C378);
  sub_10010060(0xA4u, 40181, &unk_1010C41C);
  sub_10010060(0xA4u, 40182, &unk_1010C4C0);
  sub_10010060(0xA4u, 40183, &unk_1010C564);
  sub_10010060(0xA4u, 40184, &unk_1010C608);
  sub_10010060(0xA4u, 40185, &unk_1010C6AC);
  sub_10010060(0xA4u, 40186, &unk_1010C750);
  sub_10010060(0xA4u, 40187, &unk_1010C7F4);
  sub_10010060(0xA4u, 40188, &unk_1010C898);
  sub_10010060(0xA4u, 40189, &unk_1010C93C);
  sub_10010060(0xA4u, 40190, &unk_1010C9E0);
  sub_10010060(0xA4u, 40191, &unk_1010CA84);
  sub_10010060(0xA4u, 40192, &unk_1010CB28);
  sub_10010060(0xA4u, 40193, &unk_1010CBCC);
  sub_10010060(0xA4u, 40194, &unk_1010CC70);
  sub_10010060(0xA4u, 40195, &unk_1010CD14);
  sub_10010060(0xA4u, 40196, &unk_1010CDB8);
  sub_10010060(0xA4u, 40197, &unk_1010CE5C);
  sub_10010060(0xA4u, 40198, &unk_1010CF00);
  sub_10010060(0xA4u, 40199, &unk_1010CFA4);
  sub_10010060(0x20u, 6190, &unk_1010D048);
  sub_10010060(0x20u, 6191, &unk_1010D068);
  sub_10010060(0x20u, 6192, &unk_1010D088);
  sub_10010060(0x20u, 6199, &unk_1010D0A8);
  sub_10010060(0x28u, 6207, &unk_1010D0C8);
  sub_10010060(4u, 6231, &unk_1010DBE0);
  sub_10010060(4u, 6232, &unk_1010DBE4);
  sub_10010060(4u, 6233, &unk_1010DBE8);
  sub_10010060(4u, 6234, &unk_1010DBEC);
  sub_10010060(0x1Cu, 40000, &unk_1010D0F0);
  sub_10010060(0x1Cu, 40001, &unk_1010D10C);
  sub_10010060(0x1Cu, 40002, &unk_1010D128);
  sub_10010060(0x1Cu, 40003, &unk_1010D144);
  sub_10010060(0x1Cu, 40004, &unk_1010D160);
  sub_10010060(0x1Cu, 40005, &unk_1010D17C);
  sub_10010060(0x1Cu, 40006, &unk_1010D198);
  sub_10010060(0x1Cu, 40007, &unk_1010D1B4);
  sub_10010060(0x1Cu, 40008, &unk_1010D1D0);
  sub_10010060(0x1Cu, 40009, &unk_1010D1EC);
  sub_10010060(0x1Cu, 40010, &unk_1010D208);
  sub_10010060(0x1Cu, 40011, &unk_1010D224);
  sub_10010060(0x1Cu, 40012, &unk_1010D240);
  sub_10010060(0x1Cu, 40013, &unk_1010D25C);
  sub_10010060(0x1Cu, 40014, &unk_1010D278);
  sub_10010060(0x1Cu, 40015, &unk_1010D294);
  sub_10010060(0x1Cu, 40016, &unk_1010D2B0);
  sub_10010060(0x1Cu, 40017, &unk_1010D2CC);
  sub_10010060(0x1Cu, 40018, &unk_1010D2E8);
  sub_10010060(0x1Cu, 40019, &unk_1010D304);
  sub_10010060(0x1Cu, 40020, &unk_1010D320);
  sub_10010060(0x1Cu, 40021, &unk_1010D33C);
  sub_10010060(0x1Cu, 40022, &unk_1010D358);
  sub_10010060(0x1Cu, 40023, &unk_1010D374);
  sub_10010060(0x1Cu, 40024, &unk_1010D390);
  sub_10010060(0x1Cu, 40025, &unk_1010D3AC);
  sub_10010060(0x1Cu, 40026, &unk_1010D3C8);
  sub_10010060(0x1Cu, 40027, &unk_1010D3E4);
  sub_10010060(0x1Cu, 40028, &unk_1010D400);
  sub_10010060(0x1Cu, 40029, &unk_1010D41C);
  sub_10010060(0x1Cu, 40030, &unk_1010D438);
  sub_10010060(0x1Cu, 40031, &unk_1010D454);
  sub_10010060(0x1Cu, 40032, &unk_1010D470);
  sub_10010060(0x1Cu, 40033, &unk_1010D48C);
  sub_10010060(0x1Cu, 40034, &unk_1010D4A8);
  sub_10010060(0x1Cu, 40035, &unk_1010D4C4);
  sub_10010060(0x1Cu, 40036, &unk_1010D4E0);
  sub_10010060(0x1Cu, 40037, &unk_1010D4FC);
  sub_10010060(0x1Cu, 40038, &unk_1010D518);
  sub_10010060(0x1Cu, 40039, &unk_1010D534);
  sub_10010060(0x1Cu, 40040, &unk_1010D550);
  sub_10010060(0x1Cu, 40041, &unk_1010D56C);
  sub_10010060(0x1Cu, 40042, &unk_1010D588);
  sub_10010060(0x1Cu, 40043, &unk_1010D5A4);
  sub_10010060(0x1Cu, 40044, &unk_1010D5C0);
  sub_10010060(0x1Cu, 40045, &unk_1010D5DC);
  sub_10010060(0x1Cu, 40046, &unk_1010D5F8);
  sub_10010060(0x1Cu, 40047, &unk_1010D614);
  sub_10010060(0x1Cu, 40048, &unk_1010D630);
  sub_10010060(0x1Cu, 40049, &unk_1010D64C);
  sub_10010060(0x1Cu, 40050, &unk_1010D668);
  sub_10010060(0x1Cu, 40051, &unk_1010D684);
  sub_10010060(0x1Cu, 40052, &unk_1010D6A0);
  sub_10010060(0x1Cu, 40053, &unk_1010D6BC);
  sub_10010060(0x1Cu, 40054, &unk_1010D6D8);
  sub_10010060(0x1Cu, 40055, &unk_1010D6F4);
  sub_10010060(0x1Cu, 40056, &unk_1010D710);
  sub_10010060(0x1Cu, 40057, &unk_1010D72C);
  sub_10010060(0x1Cu, 40058, &unk_1010D748);
  sub_10010060(0x1Cu, 40059, &unk_1010D764);
  sub_10010060(0x1Cu, 40060, &unk_1010D780);
  sub_10010060(0x1Cu, 40061, &unk_1010D79C);
  sub_10010060(0x1Cu, 40062, &unk_1010D7B8);
  sub_10010060(0x1Cu, 40063, &unk_1010D7D4);
  sub_10010060(0x1Cu, 40064, &unk_1010D7F0);
  sub_10010060(0x1Cu, 40065, &unk_1010D80C);
  sub_10010060(0x1Cu, 40066, &unk_1010D828);
  sub_10010060(0x1Cu, 40067, &unk_1010D844);
  sub_10010060(0x1Cu, 40068, &unk_1010D860);
  sub_10010060(0x1Cu, 40069, &unk_1010D87C);
  sub_10010060(0x1Cu, 40070, &unk_1010D898);
  sub_10010060(0x1Cu, 40071, &unk_1010D8B4);
  sub_10010060(0x1Cu, 40072, &unk_1010D8D0);
  sub_10010060(0x1Cu, 40073, &unk_1010D8EC);
  sub_10010060(0x1Cu, 40074, &unk_1010D908);
  sub_10010060(0x1Cu, 40075, &unk_1010D924);
  sub_10010060(0x1Cu, 40076, &unk_1010D940);
  sub_10010060(0x1Cu, 40077, &unk_1010D95C);
  sub_10010060(0x1Cu, 40078, &unk_1010D978);
  sub_10010060(0x1Cu, 40079, &unk_1010D994);
  sub_10010060(0x1Cu, 40080, &unk_1010D9B0);
  sub_10010060(0x1Cu, 40081, &unk_1010D9CC);
  sub_10010060(0x1Cu, 40082, &unk_1010D9E8);
  sub_10010060(0x1Cu, 40083, &unk_1010DA04);
  sub_10010060(0x1Cu, 40084, &unk_1010DA20);
  sub_10010060(0x1Cu, 40085, &unk_1010DA3C);
  sub_10010060(0x1Cu, 40086, &unk_1010DA58);
  sub_10010060(0x1Cu, 40087, &unk_1010DA74);
  sub_10010060(0x1Cu, 40088, &unk_1010DA90);
  sub_10010060(0x1Cu, 40089, &unk_1010DAAC);
  sub_10010060(0x1Cu, 40090, &unk_1010DAC8);
  sub_10010060(0x1Cu, 40091, &unk_1010DAE4);
  sub_10010060(0x1Cu, 40092, &unk_1010DB00);
  sub_10010060(0x1Cu, 40093, &unk_1010DB1C);
  sub_10010060(0x1Cu, 40094, &unk_1010DB38);
  sub_10010060(0x1Cu, 40095, &unk_1010DB54);
  sub_10010060(0x1Cu, 40096, &unk_1010DB70);
  sub_10010060(0x1Cu, 40097, &unk_1010DB8C);
  sub_10010060(0x1Cu, 40098, &unk_1010DBA8);
  sub_10010060(0x1Cu, 40099, &unk_1010DBC4);
  sub_10010060(4u, 6238, &unk_1010DBF0);
  sub_10010060(4u, 6239, &unk_1010DBF4);
  sub_10010060(4u, 6240, &unk_1010DBF8);
  sub_10010060(4u, 6242, &unk_1010DBFC);
  sub_10010060(4u, 6244, &unk_1010DC00);
  sub_10010060(4u, 6245, &unk_1010DC04);
  sub_10010060(4u, 6246, &unk_1010DC08);
  sub_10010060(4u, 6251, &unk_1010DC0C);
  sub_10010060(4u, 6252, &unk_1010DC10);
  sub_10010060(4u, 6253, &unk_1010DC14);
  sub_10010060(4u, 6254, &unk_1010DC18);
  sub_10010060(1u, 6255, &unk_1010DC1C);
  sub_10010060(4u, 6256, &unk_1010DC20);
  sub_10010060(4u, 6257, &unk_1010DC24);
  sub_10010060(0xE2u, 6286, &unk_1010DC28);
  v0 = 18000;
  v1 = &unk_1010DD0C;
  v2 = 16;
  do
  {
    sub_10010060(0x11Cu, v0, v1);
    v1 = (char *)v1 + 284;
    ++v0;
    --v2;
  }
  while ( v2 );
  sub_10010060(4u, 6262, &unk_1010EECC);
  sub_10010060(0x28u, 6263, &unk_1010EED0);
  sub_10010060(0x28u, 6264, &unk_1010EEF8);
  sub_10010060(0x40u, 6268, &unk_1010EF20);
  sub_10010060(4u, 6272, &unk_1010EFE0);
  sub_10010060(4u, 6273, &unk_1010EFE4);
  sub_10010060(1u, 6274, &unk_1010EFE8);
  sub_10010060(2u, 6275, &unk_1010EFEA);
  sub_10010060(1u, 6276, &unk_1010EFEC);
  sub_10010060(1u, 6277, &unk_1010EFED);
  sub_10010060(1u, 6278, &unk_1010EFEE);
  sub_10010060(0x40u, 6279, &unk_1010EFF0);
  sub_10010060(0x28u, 6753, &unk_1010FEA5);
  sub_10010060(0x30u, 6754, &unk_1010FED0);
  sub_10010060(0x28u, 6958, &unk_1010FF00);
  sub_10010060(0x80u, 6802, &unk_1010EF60);
  sub_10010060(1u, 6760, &unk_1010FF28);
  sub_10010060(0x10u, 6312, &unk_1010F374);
  sub_10010060(0x10u, 6313, &unk_1010F384);
  sub_10010060(0x10u, 6314, &unk_1010F394);
  sub_10010060(1u, 6307, &unk_1010F3A4);
  sub_10010060(1u, 6308, &unk_1010F3A5);
  sub_10010060(1u, 6309, &unk_1010F3A6);
  sub_10010060(4u, 6285, &unk_1010F3A8);
  sub_10010060(0xA8u, 6318, &unk_1010F3AC);
  sub_10010060(4u, 6319, &unk_1010F454);
  sub_10010060(1u, 6350, &unk_1010F458);
  sub_10010060(0x50u, 6351, &unk_1010F45C);
  sub_10010060(4u, 6352, &unk_1010F4AC);
  sub_10010060(4u, 6353, &unk_1010F4B0);
  sub_10010060(0x54u, 6448, &unk_1010F6FC);
  sub_10010060(0x54u, 6449, &unk_1010F750);
  sub_10010060(8u, 6287, &unk_1010F054);
  sub_10010060(8u, 6288, &unk_1010F05C);
  sub_10010060(8u, 6289, &unk_1010F064);
  sub_10010060(8u, 6290, &unk_1010F06C);
  sub_10010060(8u, 6291, &unk_1010F074);
  sub_10010060(8u, 6292, &unk_1010F07C);
  sub_10010060(8u, 6293, &unk_1010F084);
  sub_10010060(8u, 6294, &unk_1010F08C);
  sub_10010060(8u, 6295, &unk_1010F094);
  sub_10010060(8u, 6296, &unk_1010F09C);
  sub_10010060(8u, 6297, &unk_1010F0A4);
  sub_10010060(8u, 6298, &unk_1010F0AC);
  sub_10010060(8u, 6299, &unk_1010F0B4);
  sub_10010060(8u, 6300, &unk_1010F0BC);
  sub_10010060(8u, 6301, &unk_1010F0C4);
  sub_10010060(8u, 6302, &unk_1010F0CC);
  sub_10010060(8u, 6303, &unk_1010F0D4);
  sub_10010060(8u, 6304, &unk_1010F0DC);
  sub_10010060(8u, 6305, &unk_1010F0E4);
  sub_10010060(8u, 6306, &unk_1010F0EC);
  sub_10010060(8u, 6409, &unk_1010F0F4);
  sub_10010060(8u, 6410, &unk_1010F0FC);
  sub_10010060(8u, 6411, &unk_1010F104);
  sub_10010060(8u, 6412, &unk_1010F10C);
  sub_10010060(8u, 6413, &unk_1010F114);
  sub_10010060(8u, 6414, &unk_1010F11C);
  sub_10010060(8u, 6415, &unk_1010F124);
  sub_10010060(8u, 6416, &unk_1010F12C);
  sub_10010060(8u, 6417, &unk_1010F134);
  sub_10010060(8u, 6418, &unk_1010F13C);
  sub_10010060(8u, 6419, &unk_1010F144);
  sub_10010060(8u, 6420, &unk_1010F14C);
  sub_10010060(8u, 6421, &unk_1010F154);
  sub_10010060(8u, 6422, &unk_1010F15C);
  sub_10010060(8u, 6423, &unk_1010F164);
  sub_10010060(8u, 6424, &unk_1010F16C);
  sub_10010060(8u, 6425, &unk_1010F174);
  sub_10010060(8u, 6426, &unk_1010F17C);
  sub_10010060(8u, 6427, &unk_1010F184);
  sub_10010060(8u, 6428, &unk_1010F18C);
  sub_10010060(4u, 6429, &unk_1010F694);
  sub_10010060(8u, 6430, &unk_1010F698);
  sub_10010060(8u, 6431, &unk_1010F6A0);
  sub_10010060(8u, 6432, &unk_1010F6A8);
  sub_10010060(8u, 6433, &unk_1010F6B0);
  sub_10010060(8u, 6434, &unk_1010F6B8);
  sub_10010060(8u, 6435, &unk_1010F6C0);
  sub_10010060(8u, 6436, &unk_1010F6C8);
  sub_10010060(8u, 6437, &unk_1010F6D0);
  sub_10010060(8u, 6438, &unk_1010F6D8);
  sub_10010060(8u, 6439, &unk_1010F6E0);
  sub_10010060(8u, 6440, &unk_1010F6E8);
  sub_10010060(0xAu, 6519, &unk_1010FB54);
  sub_10010060(4u, 6442, &unk_1010F6F0);
  sub_10010060(4u, 6443, &unk_1010F6F4);
  sub_10010060(0xF0u, 6367, &unk_1010F4B4);
  sub_10010060(0xF0u, 6368, &unk_1010F5A4);
  sub_10010060(1u, 6446, &unk_1010F6F8);
  sub_10010060(6u, 6452, &unk_1010F7A4);
  sub_10010060(4u, 6457, &unk_1010F7AC);
  sub_10010060(4u, 6458, &unk_1010F7B0);
  sub_10010060(4u, 6459, &unk_1010F7B4);
  sub_10010060(4u, 6460, &unk_1010F7B8);
  sub_10010060(0x208u, 6515, &unk_1010F7BC);
  sub_10010060(0x160u, 6516, &unk_1010F9C4);
  sub_10010060(0x18u, 6517, &unk_1010FB24);
  sub_10010060(0x18u, 6518, &unk_1010FB3C);
  sub_10010060(1u, 6520, &unk_1010FB5E);
  sub_10010060(0x10u, 6521, &unk_1010FB60);
  sub_10010060(4u, 6523, &unk_1010FB70);
  sub_10010060(4u, 6524, &unk_1010FB74);
  sub_10010060(4u, 6525, &unk_1010FB78);
  sub_10010060(1u, 6526, &unk_1010FB7C);
  sub_10010060(1u, 6527, &unk_1010FB7D);
  sub_10010060(0x50u, 6528, &unk_1010FB80);
  sub_10010060(4u, 6529, &unk_1010FBD0);
  sub_10010060(1u, 6530, &unk_1010FBD4);
  sub_10010060(1u, 6531, &unk_1010FBD5);
  sub_10010060(1u, 6532, &unk_1010FBD6);
  sub_10010060(0x14u, 6533, &unk_1010FBD7);
  sub_10010060(0xAu, 6883, &unk_101102F0);
  sub_10010060(0xAu, 6884, &unk_101102FA);
  sub_10010060(0xAu, 6885, &unk_10110304);
  sub_10010060(1u, 6664, &unk_1010FBEB);
  sub_10010060(1u, 6666, &unk_1010FBEC);
  sub_10010060(1u, 6667, &unk_1010FBED);
  sub_10010060(1u, 6668, &unk_1010FBEE);
  sub_10010060(0xA0u, 6669, &unk_1010FBF0);
  sub_10010060(2u, 6670, &unk_1010FCE0);
  sub_10010060(4u, 6671, &unk_1010FCE4);
  sub_10010060(4u, 6672, &unk_1010FCE8);
  sub_10010060(4u, 6673, &unk_1010FCEC);
  sub_10010060(4u, 6674, &unk_1010FCF0);
  sub_10010060(4u, 6675, &unk_1010FCF4);
  sub_10010060(4u, 6676, &unk_1010FCFC);
  sub_10010060(4u, 6677, &unk_1010FD04);
  sub_10010060(4u, 6678, &unk_1010FD08);
  sub_10010060(1u, 6679, &unk_1010FD0C);
  sub_10010060(0x140u, 6680, &unk_1010FD10);
  sub_10010060(4u, 6882, &unk_101102EC);
  sub_10010060(0xCu, 6652, &unk_1010FE50);
  sub_10010060(0x48u, 6653, &unk_1010FE5C);
  sub_10010060(1u, 6688, &unk_1010FEA4);
  sub_10010060(4u, 6771, &unk_1010FF2C);
  sub_10010060(4u, 6772, &unk_1010FF30);
  sub_10010060(8u, 6787, &unk_1010FF34);
  sub_10010060(1u, 6832, &unk_1010FF64);
  sub_10010060(1u, 6833, &unk_1010FF65);
  sub_10010060(1u, 6834, &unk_1010FF66);
  sub_10010060(4u, 6835, &unk_1010FF68);
  sub_10010060(4u, 6836, &unk_1010FF6C);
  sub_10010060(4u, 6837, &unk_1010FF70);
  sub_10010060(4u, 6838, &unk_1010FF74);
  sub_10010060(1u, 6839, &unk_1010FF78);
  sub_10010060(0x50u, 6840, &unk_1010FC90);
  sub_10010060(4u, 6841, &unk_1010FF7C);
  sub_10010060(4u, 6842, &unk_1010FF80);
  sub_10010060(4u, 6843, &unk_1010FF84);
  sub_10010060(1u, 6844, &unk_1010FF88);
  sub_10010060(0x360u, 6845, &unk_1010FF8C);
  sub_10010060(4u, 6846, &unk_1010FCF8);
  sub_10010060(4u, 6847, &unk_1010FD00);
  result = 1;
  dword_101F03E0 = (int)&unk_101080F0;
  return result;
}
// 101F03E0: using guessed type int dword_101F03E0;

//----- (10011EB0) --------------------------------------------------------
int __cdecl sub_10011EB0(signed int a1, char a2)
{
  int result; // eax@3
  int v3; // [sp+0h] [bp-4h]@1

  v3 = 0;
  switch ( (unsigned __int8)a1 )
  {
    case 0u:
      if ( a2 == 1 )
      {
        a1 = 136975;
        sub_10031C50(10018, &v3, 4, &a1);
        result = v3;
      }
      else
      {
        a1 = 118000;
        sub_10031C50(10022, &v3, 4, &a1);
        result = v3;
      }
      break;
    case 1u:
      if ( a2 == 1 )
      {
        a1 = 136975;
        sub_10031C50(10019, &v3, 4, &a1);
        result = v3;
      }
      else
      {
        a1 = 118000;
        sub_10031C50(10023, &v3, 4, &a1);
        result = v3;
      }
      break;
    case 3u:
      if ( a2 == 1 )
      {
        a1 = 117950;
        sub_10031C50(10020, &v3, 4, &a1);
        result = v3;
      }
      else
      {
        a1 = 108000;
        sub_10031C50(10024, &v3, 4, &a1);
        result = v3;
      }
      break;
    case 4u:
      if ( a2 == 1 )
      {
        a1 = 117950;
        sub_10031C50(10021, &v3, 4, &a1);
        result = v3;
      }
      else
      {
        a1 = 108000;
        sub_10031C50(10025, &v3, 4, &a1);
        result = v3;
      }
      break;
    case 2u:
      result = sub_10023910(a2);
      v3 = result;
      break;
    default:
      sub_1000D740("..\\lib\\adl\\iop_freq_intf.c", 180, 1, 0);
      result = v3;
      break;
  }
  return result;
}

//----- (10012070) --------------------------------------------------------
char __cdecl sub_10012070(char a1, char a2, int a3)
{
  char result; // al@1
  int v4; // ecx@17
  signed int v5; // eax@17
  int v6; // [sp-Ch] [bp-Ch]@16
  int *v7; // [sp-8h] [bp-8h]@16

  result = a1;
  switch ( a1 )
  {
    case 0:
      result = sub_100122E0(a1, &a1);
      if ( result && (unsigned int)(a3 - 118000) <= 0x4A2E )
      {
        if ( a2 == 1 )
          result = sub_10031CC0(10018, (int)&a3, 4);
        else
          result = sub_10031CC0(10022, (int)&a3, 4);
      }
      break;
    case 1:
      result = sub_100122E0(a1, &a1);
      if ( result )
      {
        result = a3 + 16;
        if ( (unsigned int)(a3 - 118000) <= 0x4A2E )
        {
          if ( a2 == 1 )
            result = sub_10031CC0(10019, (int)&a3, 4);
          else
            result = sub_10031CC0(10023, (int)&a3, 4);
        }
      }
      break;
    case 3:
      result = sub_10015B60(a1, &a1);
      if ( result && (unsigned int)(a3 - 108000) <= 0x26DE )
      {
        if ( a2 == 1 )
        {
          v7 = &a3;
          v6 = 10020;
          goto LABEL_17;
        }
        result = sub_10031CC0(10024, (int)&a3, 4);
      }
      break;
    case 4:
      result = sub_10015B60(a1, &a1);
      if ( result )
      {
        result = a3 + 32;
        if ( (unsigned int)(a3 - 108000) <= 0x26DE )
        {
          if ( a2 == 1 )
          {
            v7 = &a3;
            v6 = 10021;
LABEL_17:
            sub_10031CC0(v6, (int)v7, 4);
            LOBYTE(v5) = sub_100159D0(v4);
            result = sub_10015920(v5, 1);
          }
          else
          {
            result = sub_10031CC0(10025, (int)&a3, 4);
          }
        }
      }
      break;
    case 2:
      result = sub_100122E0(a1, &a1);
      if ( result )
        result = sub_10023A20(a2, a3);
      break;
    default:
      return result;
  }
  return result;
}

//----- (10012230) --------------------------------------------------------
char __cdecl sub_10012230(char a1)
{
  return byte_10077449[2 * (unsigned __int8)sub_10016EA0(&a1, 1u, (int)&unk_10077448, 2, 4, 3)];
}

//----- (10012260) --------------------------------------------------------
char __cdecl sub_10012260(char a1, void *a2)
{
  int v3; // esi@6
  char v4; // al@6

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v3 = (int)a2;
      v4 = sub_10013EB0(1, 546, a2);
    }
    else
    {
      if ( a1 != 2 )
      {
        sub_1000D740("..\\lib\\acl\\iop\\iop_com_intf.c", 187, 0, 0);
        return 0;
      }
      v3 = (int)a2;
      v4 = sub_100238D0(a2);
    }
  }
  else
  {
    v3 = (int)a2;
    v4 = sub_10013EB0(1, 538, a2);
  }
  if ( !v4 || sub_10018360(v3) )
    return 0;
  return 1;
}

//----- (100122E0) --------------------------------------------------------
int __cdecl sub_100122E0(char a1, _DWORD *a2)
{
  int result; // eax@1
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  LOBYTE(result) = sub_10012260(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (10012330) --------------------------------------------------------
bool __cdecl sub_10012330(char a1)
{
  bool result; // al@2
  int v2; // [sp+4h] [bp-Ch]@1
  int v3; // [sp+8h] [bp-8h]@1

  v2 = 0;
  v3 = 0;
  if ( sub_10012260(a1, &v2) == 1 )
    result = (v2 & 0x200) == 512;
  else
    result = 0;
  return result;
}

//----- (100123A0) --------------------------------------------------------
bool __cdecl sub_100123A0(char a1)
{
  bool result; // al@2
  int v2; // [sp+4h] [bp-Ch]@1
  int v3; // [sp+8h] [bp-8h]@1

  v2 = 0;
  v3 = 0;
  if ( sub_10012260(a1, &v2) == 1 )
    result = (v2 & 8) == 8;
  else
    result = 0;
  return result;
}

//----- (10012400) --------------------------------------------------------
bool __cdecl sub_10012400(char a1)
{
  bool result; // al@2
  int v2; // [sp+4h] [bp-Ch]@1
  int v3; // [sp+8h] [bp-8h]@1

  v2 = 0;
  v3 = 0;
  if ( sub_10012260(a1, &v2) == 1 )
    result = (v2 & 0x10) == 16;
  else
    result = 0;
  return result;
}

//----- (10012460) --------------------------------------------------------
char __cdecl sub_10012460(char a1, char a2)
{
  char result; // al@3

  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_100139E0(1, 548, &a2, 0, 1, 1);
    else
      result = sub_1000D740("..\\lib\\acl\\iop\\iop_com_intf.c", 594, 0, 0);
  }
  else
  {
    result = sub_100139E0(1, 540, &a2, 0, 1, 1);
  }
  return result;
}

//----- (100124C0) --------------------------------------------------------
void __cdecl sub_100124C0(char a1, char a2)
{
  if ( (unsigned __int8)a2 <= 0x3Fu )
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sub_10031CC0(2011, (int)&a2, 1);
      }
      else
      {
        if ( a1 == 2 )
          sub_10023A60(a2);
        sub_1000D740("..\\lib\\acl\\iop\\iop_com_intf.c", 658, 0, 0);
      }
    }
    else
    {
      sub_10031CC0(2010, (int)&a2, 1);
    }
  }
}

//----- (10012530) --------------------------------------------------------
char __cdecl sub_10012530(signed int a1)
{
  char result; // al@1

  result = a1;
  if ( (unsigned __int8)a1 <= 1u )
  {
    result = sub_10023CC0(a1, 39);
  }
  else if ( (_BYTE)a1 == 2 )
  {
    a1 = 2;
    sub_100139E0(1, 1670, &a1, 0, 1, 1);
    result = sub_10013B20(1, 0x686u, 0xFFFFFFF);
  }
  return result;
}

//----- (10012560) --------------------------------------------------------
int __thiscall sub_10012560(void *this)
{
  char v1; // si@1
  void *v2; // ecx@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // ebx@1
  char v6; // al@1
  int result; // eax@1

  v1 = sub_1000EB30(this) & 7;
  v3 = sub_100128C0(v2);
  v4 = ((v1 & 1) == 1) + ((v1 & 2) == 2) + ((v1 & 4) == 4);
  v5 = sub_10012820(15) == 1;
  v6 = sub_10012820(8);
  word_10111AC0 = 552;
  result = v5 + (v6 == 1);
  if ( v4 != 2 )
  {
    if ( v4 != 3 )
      return result;
    if ( result == 2 )
    {
      if ( v3 == 2 )
      {
        word_10111AC0 = 557;
        return result;
      }
    }
    else if ( result != 1 )
    {
      return result;
    }
    goto LABEL_10;
  }
  if ( result == 1 )
  {
LABEL_10:
    word_10111AC0 = 552;
    return result;
  }
  if ( result == 2 )
    word_10111AC0 = v3 != 4 ? 552 : 557;
  return result;
}
// 10111AC0: using guessed type __int16 word_10111AC0;

//----- (10012630) --------------------------------------------------------
bool __usercall sub_10012630@<al>(int a1@<esi>)
{
  void *v2; // [sp+0h] [bp-4h]@0

  return sub_10013EB0(1, (unsigned __int16)word_10111AC0, v2) && !sub_10017AD0(a1);
}
// 10111AC0: using guessed type __int16 word_10111AC0;

//----- (10012660) --------------------------------------------------------
bool __cdecl sub_10012660(_BYTE *a1)
{
  bool result; // al@1
  char v2; // [sp+4h] [bp-4h]@1

  result = sub_10012630((int)&v2);
  if ( result )
    *a1 = v2;
  return result;
}

//----- (10012680) --------------------------------------------------------
char __thiscall sub_10012680(void *this)
{
  char v1; // di@1
  void *v2; // esi@1
  char v3; // di@3
  void *v4; // esi@3
  char result; // al@4

  dword_10111AC8 = sub_1000EB50(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_10111AD0, 0, 0x1540u);
  memset(&unk_10113010, 0, 0x19B0u);
  v1 = 0;
  v2 = &unk_10111AD0;
  do
  {
    sub_10023FB0(v1, (int)v2);
    v2 = (char *)v2 + 2720;
    ++v1;
  }
  while ( (signed int)v2 < (signed int)&unk_10113010 );
  v3 = 0;
  v4 = &unk_10113010;
  do
  {
    result = sub_10024030(v3, (int)v4);
    v4 = (char *)v4 + 2192;
    ++v3;
  }
  while ( (signed int)v4 < (signed int)&dword_101149C0 );
  return result;
}
// 10111AC8: using guessed type int dword_10111AC8;
// 101149C0: using guessed type int dword_101149C0;

//----- (10012710) --------------------------------------------------------
char __cdecl sub_10012710(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_10111AC8 != 1379255385;
  v7 = 0;
  v8 = dword_10111AC8 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10031B90(86, 10);
      memset((char *)&unk_10111AD0 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_10023FB0(a1, (int)&unk_10111AD0 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 4 * (680 * (unsigned __int8)a1 + v5);
      if ( byte_10111DA8[v6] == a2 || byte_10111DA9[v6] == a2 )
        break;
      if ( ++v5 >= 8u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_10031B60(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10111AC8: using guessed type int dword_10111AC8;

//----- (100127D0) --------------------------------------------------------
char __cdecl sub_100127D0(char a1, char a2)
{
  unsigned __int8 v2; // bl@1
  unsigned __int8 v4; // [sp+8h] [bp-8h]@1
  char v5; // [sp+Ch] [bp-4h]@2

  v2 = 0;
  v4 = 0;
  while ( 1 )
  {
    sub_10023540(a1, v4, (int)&v5);
    if ( v5 == a2 )
      break;
    v4 = ++v2;
    if ( v2 >= 2u )
      return 0;
  }
  return 1;
}

//----- (10012820) --------------------------------------------------------
char __cdecl sub_10012820(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_10012710(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (10012850) --------------------------------------------------------
char __cdecl sub_10012850(char a1)
{
  char result; // al@1
  unsigned __int8 v2; // bl@1
  char v3; // [sp+8h] [bp-4h]@1

  result = 0;
  v2 = 0;
  v3 = 0;
  do
  {
    if ( result )
      break;
    result = sub_100127D0(v3, a1);
    v3 = ++v2;
  }
  while ( v2 < 3u );
  return result;
}

//----- (10012890) --------------------------------------------------------
char __thiscall sub_10012890(void *this)
{
  char result; // al@1
  bool v2; // zf@2
  void *v3; // [sp-2h] [bp-4h]@1

  v3 = this;
  sub_1000EA50(4, (char *)&v3 + 3);
  result = BYTE3(v3);
  if ( BYTE3(v3) == 1 )
  {
    v2 = SIM_proc_rqst(50) == 0;
    result = 2;
    if ( v2 )
      result = BYTE3(v3);
  }
  return result;
}
// 10037CD2: using guessed type int __cdecl SIM_proc_rqst(_DWORD);

//----- (100128C0) --------------------------------------------------------
int __thiscall sub_100128C0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_1000EA50(46, (char *)&v2);
  return (int)v2;
}

//----- (100128E0) --------------------------------------------------------
#error "100128E0: call analysis failed (funcsize=2)"

//----- (100128F0) --------------------------------------------------------
#error "100128FF: call analysis failed (funcsize=5)"

//----- (10012910) --------------------------------------------------------
BOOL __cdecl sub_10012910(unsigned int a1)
{
  int v1; // edi@1
  __int16 i; // si@1
  char v4; // [sp+Bh] [bp-1h]@1

  v1 = sub_10031910();
  for ( i = sub_100328A0(6, 0, 1, (int)&v4); i == 12; i = sub_100328A0(6, 0, 1, (int)&v4) )
  {
    if ( sub_10031910() - v1 >= a1 )
      break;
    sub_10031A90(100);
  }
  return i == 12;
}

//----- (10012980) --------------------------------------------------------
char __thiscall sub_10012980(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10032360(81, (_BYTE *)&v2 + 3);
  return BYTE3(v2);
}

//----- (100129A0) --------------------------------------------------------
void __cdecl sub_100129A0(_BYTE *a1, _BYTE *a2, _BYTE *a3)
{
  sub_10032360(120, a1);
  sub_10032360(124, a2);
  sub_10032360(121, a3);
}

//----- (100129D0) --------------------------------------------------------
int __cdecl sub_100129D0(int a1)
{
  return sub_10031BF0(3025, a1, 84);
}

//----- (100129F0) --------------------------------------------------------
signed int sub_100129F0()
{
  bool v0; // zf@1
  signed int result; // eax@1
  char v2; // [sp+3h] [bp-5h]@1
  int v3; // [sp+4h] [bp-4h]@1

  v0 = sub_100328E0(6, &v3, &v2) == 0;
  result = -4;
  if ( v0 )
    result = v3;
  return result;
}

//----- (10012A20) --------------------------------------------------------
void __cdecl sub_10012A20(_BYTE *a1)
{
  sub_10032360(129, a1);
}

//----- (10012A40) --------------------------------------------------------
char __cdecl sub_10012A40(int a1, size_t a2, void *a3)
{
  char result; // al@2

  if ( sub_100328A0(6, a1, a2, (int)a3) )
  {
    memset(a3, 0, a2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10012A80) --------------------------------------------------------
int __cdecl sub_10012A80(int a1)
{
  return sub_10031CC0(3025, a1, 84);
}

//----- (10012AA0) --------------------------------------------------------
char __fastcall sub_10012AA0(int *a1)
{
  char v1; // bl@1
  unsigned int v2; // eax@7
  int *v3; // edx@7
  int v4; // esi@11
  int v5; // eax@12
  _BYTE *v6; // edx@12
  int v7; // eax@14
  _BYTE *v8; // edx@14
  _BYTE *v9; // edx@16
  signed int v10; // eax@18
  char result; // al@25
  char v12; // [sp+4h] [bp-68h]@1
  int v13; // [sp+8h] [bp-64h]@2
  int v14; // [sp+Ch] [bp-60h]@29
  int v15; // [sp+10h] [bp-5Ch]@29
  char v16; // [sp+12h] [bp-5Ah]@3
  char v17; // [sp+13h] [bp-59h]@4
  int v18; // [sp+14h] [bp-58h]@5
  char v19; // [sp+18h] [bp-54h]@6
  int v20; // [sp+1Ch] [bp-50h]@2
  int v21; // [sp+20h] [bp-4Ch]@29
  int v22; // [sp+24h] [bp-48h]@29
  char v23; // [sp+26h] [bp-46h]@3
  char v24; // [sp+27h] [bp-45h]@4
  int v25; // [sp+28h] [bp-44h]@5
  char v26; // [sp+2Ch] [bp-40h]@6
  int v27; // [sp+2Dh] [bp-3Fh]@7
  int v28; // [sp+31h] [bp-3Bh]@29
  int v29; // [sp+35h] [bp-37h]@29
  int v30; // [sp+3Ch] [bp-30h]@2
  int v31; // [sp+40h] [bp-2Ch]@2
  int v32; // [sp+44h] [bp-28h]@2
  int v33; // [sp+48h] [bp-24h]@2
  int v34; // [sp+4Ch] [bp-20h]@2
  int v35; // [sp+50h] [bp-1Ch]@2
  int v36; // [sp+54h] [bp-18h]@2
  char v37; // [sp+58h] [bp-14h]@2
  int v38; // [sp+5Ch] [bp-10h]@2
  int v39; // [sp+60h] [bp-Ch]@29
  int v40; // [sp+64h] [bp-8h]@29

  v1 = 1;
  v12 = 1;
  if ( byte_101F03B4 )
  {
    v1 = 3;
    goto LABEL_24;
  }
  sub_10012A40(147, 0xCu, &v38);
  sub_10012A40(129, 0x11u, &v13);
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  sub_10031C50(2000, &v20, 29, &v30);
  LOWORD(a1) = v20;
  if ( (_WORD)v20 != (_WORD)v13
    || v23 != v16
    || v24 != v17
    || (LOWORD(a1) = v25, v25 != v18)
    || (LOBYTE(a1) = v26, v26 != v19) )
  {
LABEL_22:
    v1 = 2;
LABEL_24:
    v12 = v1;
    goto LABEL_25;
  }
  v2 = 12;
  a1 = &v38;
  v3 = &v27;
  do
  {
    if ( *v3 != *a1 )
      goto LABEL_11;
    v2 -= 4;
    ++a1;
    ++v3;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_20:
    v10 = 0;
    goto LABEL_21;
  }
LABEL_11:
  v4 = *(_BYTE *)v3 - *(_BYTE *)a1;
  if ( *(_BYTE *)v3 == *(_BYTE *)a1 )
  {
    v5 = v2 - 1;
    a1 = (int *)((char *)a1 + 1);
    v6 = (char *)v3 + 1;
    if ( !v5 )
      goto LABEL_20;
    v4 = *v6 - *(_BYTE *)a1;
    if ( *v6 == *(_BYTE *)a1 )
    {
      v7 = v5 - 1;
      a1 = (int *)((char *)a1 + 1);
      v8 = v6 + 1;
      if ( !v7 )
        goto LABEL_20;
      v4 = *v8 - *(_BYTE *)a1;
      if ( *v8 == *(_BYTE *)a1 )
      {
        a1 = (int *)((char *)a1 + 1);
        v9 = v8 + 1;
        if ( v7 == 1 )
          goto LABEL_20;
        v4 = *v9 - *(_BYTE *)a1;
        if ( *v9 == *(_BYTE *)a1 )
          goto LABEL_20;
      }
    }
  }
  v10 = 1;
  if ( v4 <= 0 )
    v10 = -1;
LABEL_21:
  if ( v10 )
    goto LABEL_22;
LABEL_25:
  result = sub_10012890(a1);
  if ( !result || result == 3 )
    result = sub_1000EBB0(v12);
  if ( v1 == 2 )
  {
    v22 = v15;
    v20 = v13;
    v21 = v14;
    v27 = v38;
    v25 = v18;
    v26 = v19;
    v28 = v39;
    v29 = v40;
    result = sub_10031CC0(2000, (int)&v20, 29);
  }
  return result;
}
// 101F03B4: using guessed type char byte_101F03B4;

//----- (10012CC0) --------------------------------------------------------
char sub_10012CC0()
{
  int *v0; // ecx@1

  sub_10012910(0x9C40u);
  sub_1000CD90(&off_10079870);
  return sub_10012AA0(v0);
}
// 10079870: using guessed type int (__cdecl *off_10079870)(int, size_t, void *);

//----- (10012CE0) --------------------------------------------------------
char __cdecl sub_10012CE0(unsigned __int16 a1, float *a2)
{
  unsigned __int16 v2; // ax@2
  char result; // al@5
  char v4[4]; // [sp+1Ch] [bp-74h]@1
  int v5; // [sp+20h] [bp-70h]@3
  int v6; // [sp+24h] [bp-6Ch]@1
  char v7; // [sp+28h] [bp-68h]@1

  memset(&v7, 0, 0x64u);
  v6 = 0;
  if ( sub_100248B0(a1, v4, &v6) == 1 )
  {
    v2 = sub_10013210(v4[0]);
    if ( (unsigned __int16)v6 >= v2 )
    {
      if ( a1 )
      {
        sprintf(&v7, "NO PKT FOR TYPE %d\n", a1);
        sub_1000D740("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 593, 0, &v7);
      }
    }
    else if ( sub_10013EB0(v4[0], v6, &v5) && !sub_100244B0((int)&v5, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0) )
    {
      result = 1;
      *a2 = *(float *)&v5;
      return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10012E00) --------------------------------------------------------
void sub_10012E00()
{
  dword_101149C0 = -15;
}
// 101149C0: using guessed type int dword_101149C0;

//----- (10012E10) --------------------------------------------------------
int sub_10012E10()
{
  int result; // eax@1

  result = 0;
  dword_101149C4 = -15;
  dword_101F03DC = 0;
  dword_101F03D0 = 0;
  dword_101F03D4 = 0;
  dword_101F03D8 = 0;
  return result;
}
// 101149C4: using guessed type int dword_101149C4;
// 101F03D0: using guessed type int dword_101F03D0;
// 101F03D4: using guessed type int dword_101F03D4;
// 101F03D8: using guessed type int dword_101F03D8;
// 101F03DC: using guessed type int dword_101F03DC;

//----- (10012E40) --------------------------------------------------------
char sub_10012E40()
{
  char v0; // bl@1
  signed int v1; // esi@2
  char result; // al@4

  v0 = sub_100327D0((int)&off_1007A120);
  if ( v0 )
  {
    dword_101F03DC = dword_101149C4;
    v1 = *(_BYTE *)(dword_101149C4 + 667) != 0 ? 1100 : 2000;
    if ( v1 + *(_DWORD *)(dword_101F03DC + 36) < (unsigned int)sub_10031910() )
      v0 = 0;
    dword_101F03D8 = dword_101149C4 + 56116;
    result = v0;
    dword_101F03D0 = dword_101149C4 + 1516;
    dword_101F03D4 = dword_101149C4 + 20484;
  }
  else
  {
    dword_101F03DC = 0;
    dword_101F03D0 = 0;
    dword_101F03D4 = 0;
    dword_101F03D8 = 0;
    result = 0;
  }
  return result;
}
// 1007A120: using guessed type char *off_1007A120;
// 101149C4: using guessed type int dword_101149C4;
// 101F03D0: using guessed type int dword_101F03D0;
// 101F03D4: using guessed type int dword_101F03D4;
// 101F03D8: using guessed type int dword_101F03D8;
// 101F03DC: using guessed type int dword_101F03DC;

//----- (10012EE0) --------------------------------------------------------
int __cdecl sub_10012EE0(double a1, double a2)
{
  double *v2; // ecx@0
  double v3; // ST00_8@1
  double v4; // st7@1
  int result; // eax@4

  v3 = *v2;
  v4 = a1;
  if ( (HIDWORD(v3) & 0x7FF00000) == 2146435072 || a1 < *v2 || (v4 = a2, a2 > *v2) )
  {
    *v2 = v4;
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10012F30) --------------------------------------------------------
void sub_10012F30()
{
  dword_101F03C0 = -15;
}
// 101F03C0: using guessed type int dword_101F03C0;

//----- (10012F40) --------------------------------------------------------
signed int sub_10012F40()
{
  return sub_100327D0((int)&off_1007A14C);
}
// 1007A14C: using guessed type char *off_1007A14C;

//----- (10012F50) --------------------------------------------------------
signed int sub_10012F50()
{
  char v0; // bl@1
  signed int result; // eax@3

  v0 = 1;
  if ( (unsigned __int8)sub_10012F40() )
    v0 = *(_BYTE *)(dword_101F03C0 + 1456);
  result = (unsigned __int8)v0;
  if ( (unsigned __int8)v0 >= 8u )
    result = 1;
  return result;
}
// 101F03C0: using guessed type int dword_101F03C0;

//----- (10012F80) --------------------------------------------------------
bool __cdecl sub_10012F80(char a1, int a2)
{
  bool v2; // bl@1
  double v3; // st7@4
  int v4; // eax@4
  int v5; // ecx@8
  int v6; // eax@8
  double v7; // st5@14
  double v8; // st6@14
  float v9; // ST40_4@15
  double v10; // st5@16
  double v11; // st7@19
  float v13; // ST40_4@23
  float v14; // [sp+40h] [bp-10h]@5
  float v15; // [sp+40h] [bp-10h]@12
  float v16; // [sp+40h] [bp-10h]@16
  int v17; // [sp+44h] [bp-Ch]@8
  float v18; // [sp+48h] [bp-8h]@9
  float v19; // [sp+4Ch] [bp-4h]@9

  v2 = 0;
  if ( sub_10031BF0(2047, a2, 16) )
  {
    *(double *)a2 = 0.68067840827779;
    *(double *)(a2 + 8) = -1.658062789394617;
  }
  if ( (unsigned __int8)sub_10012F40() )
  {
    sub_100319E0(101, 10000);
    v3 = 0.0;
    v4 = dword_101F03C0;
    v2 = *(_WORD *)(dword_101F03C0 + 1456) > 1u;
    if ( *(_BYTE *)(dword_101F03C0 + 1296) )
    {
      v14 = sub_10024910(*(_DWORD *)(dword_101F03C0 + 1292));
      v4 = dword_101F03C0;
      v3 = 0.0;
    }
    else
    {
      v14 = 0.0;
    }
    if ( v2 )
    {
      v5 = *(_DWORD *)(v4 + 1524);
      v6 = v4 + 1524;
      *(_DWORD *)a2 = v5;
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(v6 + 4);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v6 + 8);
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(v6 + 12);
      sub_10012EE0(6.2831853071796, -6.2831853071796);
      sub_10012EE0(6.2831853071796, -6.2831853071796);
      sub_10037B60(v14, dword_101F03C0 + 1512, (int)&v17);
      v4 = dword_101F03C0;
      v3 = 0.0;
    }
    else
    {
      *(float *)&v17 = v3;
      v18 = v3;
      v19 = v3;
    }
    if ( a1 == 1 )
    {
      sub_10037B30((int)&v17, v4 + 1432, (int)&v17);
      v3 = 0.0;
      v4 = dword_101F03C0;
    }
    v15 = *(float *)(v4 + 1280);
    if ( (LODWORD(v15) & 0x7F800000) == 2139095040 || v15 > 0.0053898906 )
    {
      v8 = 0.0053898906;
    }
    else
    {
      v7 = v15;
      v8 = 0.0053898906;
      if ( v15 >= v3 )
        goto LABEL_16;
    }
    v9 = v3;
    v7 = v9;
LABEL_16:
    *(double *)a2 = v7 * v18 + *(double *)a2;
    v16 = *(float *)(dword_101F03C0 + 1284);
    v10 = v16;
    if ( (LODWORD(v16) & 0x7F800000) == 2139095040 || v10 > v8 || v10 < v3 )
    {
      v13 = v3;
      v11 = v13;
    }
    else
    {
      v11 = v16;
    }
    *(double *)(a2 + 8) = v11 * *(float *)&v17 + *(double *)(a2 + 8);
    sub_100319C0(101);
    sub_10017100(a2);
  }
  return v2;
}
// 101F03C0: using guessed type int dword_101F03C0;

//----- (100131A0) --------------------------------------------------------
char sub_100131A0()
{
  char v0; // bl@1

  v0 = 0;
  if ( (unsigned __int8)sub_10012F40() )
  {
    sub_100319E0(101, 10000);
    if ( !*(_BYTE *)(dword_101F03C0 + 1444)
      || !*(_BYTE *)(dword_101F03C0 + 1451)
      || (v0 = 1, *(_WORD *)(dword_101F03C0 + 1456) <= 1u)
      || *(float *)(dword_101F03C0 + 1480) <= 15.433242 )
    {
      v0 = 0;
    }
    sub_100319C0(101);
  }
  return v0;
}
// 101F03C0: using guessed type int dword_101F03C0;

//----- (10013210) --------------------------------------------------------
int __cdecl sub_10013210(char a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 7 )
    result = (unsigned __int16)word_1007AFEC[a1];
  return result;
}
// 1007AFEC: using guessed type __int16 word_1007AFEC[];

//----- (10013230) --------------------------------------------------------
signed int sub_10013230()
{
  signed int result; // eax@1

  result = -15;
  dword_101149E4 = -15;
  dword_101149F0 = -15;
  dword_101149CC = -15;
  dword_101149F4 = -15;
  dword_101149E0 = -15;
  dword_101149D0 = -15;
  dword_101149C8 = -15;
  dword_101149DC = -15;
  dword_101149EC = -15;
  dword_101149E8 = -15;
  dword_101149D8 = -15;
  dword_101149D4 = -15;
  return result;
}
// 101149C8: using guessed type int dword_101149C8;
// 101149CC: using guessed type int dword_101149CC;
// 101149D0: using guessed type int dword_101149D0;
// 101149D4: using guessed type int dword_101149D4;
// 101149D8: using guessed type int dword_101149D8;
// 101149DC: using guessed type int dword_101149DC;
// 101149E0: using guessed type int dword_101149E0;
// 101149E4: using guessed type int dword_101149E4;
// 101149E8: using guessed type int dword_101149E8;
// 101149EC: using guessed type int dword_101149EC;
// 101149F0: using guessed type int dword_101149F0;
// 101149F4: using guessed type int dword_101149F4;

//----- (10013280) --------------------------------------------------------
signed int __usercall sub_10013280@<eax>(char a1@<al>, int a2@<ecx>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = sub_100327D0((int)&off_1007B00C);
      break;
    case 0:
      result = sub_100327D0((int)&off_1007B020);
      break;
    case 1:
      result = sub_100327D0((int)&off_1007B034);
      break;
    case 2:
      result = sub_100327D0((int)&off_1007B05C);
      break;
    case 3:
      result = sub_100327D0((int)&off_1007B048);
      break;
    case 5:
      result = sub_100327D0((int)&off_1007B070);
      break;
    default:
      result = sub_100327D0(a2);
      break;
  }
  return result;
}
// 1007B00C: using guessed type char *off_1007B00C;
// 1007B020: using guessed type char *off_1007B020;
// 1007B034: using guessed type char *off_1007B034;
// 1007B048: using guessed type char *off_1007B048;
// 1007B05C: using guessed type char *off_1007B05C;
// 1007B070: using guessed type char *off_1007B070;

//----- (10013320) --------------------------------------------------------
int __usercall sub_10013320@<eax>(char a1@<al>)
{
  return sub_100319C0(dword_1007AB3C[a1]);
}
// 1007AB3C: using guessed type int dword_1007AB3C[];

//----- (10013340) --------------------------------------------------------
int __usercall sub_10013340@<eax>(char a1@<al>)
{
  return sub_100319E0(dword_1007AB3C[a1], 10);
}
// 1007AB3C: using guessed type int dword_1007AB3C[];

//----- (10013360) --------------------------------------------------------
signed __int16 __usercall sub_10013360@<ax>(char a1@<al>, unsigned __int16 a2@<si>)
{
  signed __int16 result; // ax@3
  bool v3; // cf@8

  switch ( a1 )
  {
    case 6:
      if ( a2 < 0x2E5u )
      {
        if ( !(unsigned __int8)sub_10013280(a1, a1) )
        {
          sub_1000D740("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3201, 0, 0);
          goto LABEL_6;
        }
        result = *(_WORD *)(dword_101149E4 + 2 * a2 + 241212);
        v3 = (unsigned __int16)result < 0x256u;
        goto LABEL_32;
      }
      sub_1000D740("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3186, 0, 0);
      return -1;
    default:
      goto LABEL_6;
    case 0:
      if ( a2 >= 0x344u )
      {
        sub_1000D740("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3224, 0, 0);
        return -1;
      }
      if ( (unsigned __int8)sub_10013280(a1, a1) )
      {
        result = *(_WORD *)(dword_101149F0 + 2 * a2 + 284664);
        v3 = (unsigned __int16)result < 0x211u;
        goto LABEL_32;
      }
      if ( sub_1000EA00(15000) )
        goto LABEL_6;
      sub_1000D740("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3242, 0, 0);
      return 0;
    case 1:
      if ( a2 >= 0xBCCu )
      {
        sub_1000D740("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3265, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10013280(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_101149CC + 2 * a2 + 447808);
      v3 = (unsigned __int16)result < 0x979u;
      goto LABEL_32;
    case 2:
      if ( a2 >= 0x388u )
      {
        sub_1000D740("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3302, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10013280(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_101149F4 + 2 * a2 + 356016);
      v3 = (unsigned __int16)result < 0x23Du;
      goto LABEL_32;
    case 3:
      if ( a2 >= 0xBEu )
      {
        sub_1000D740("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3339, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10013280(a1, a1) )
      {
        sub_1000D740("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3354, 0, 0);
        return 0;
      }
      result = *(_WORD *)(dword_101149E0 + 2 * a2 + 23096);
      v3 = (unsigned __int16)result < 0x52u;
      goto LABEL_32;
    case 5:
      if ( a2 < 4u )
      {
        if ( (unsigned __int8)sub_10013280(a1, a1) )
        {
          result = *(_WORD *)(dword_101149D0 + 2 * a2 + 1804);
          v3 = (unsigned __int16)result < 4u;
LABEL_32:
          if ( !v3 )
            result = -1;
        }
        else
        {
LABEL_6:
          result = 0;
        }
      }
      else
      {
        sub_1000D740("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3377, 0, 0);
        result = -1;
      }
      return result;
  }
}
// 101149CC: using guessed type int dword_101149CC;
// 101149D0: using guessed type int dword_101149D0;
// 101149E0: using guessed type int dword_101149E0;
// 101149E4: using guessed type int dword_101149E4;
// 101149F0: using guessed type int dword_101149F0;
// 101149F4: using guessed type int dword_101149F4;

//----- (100135A0) --------------------------------------------------------
char __cdecl sub_100135A0(char a1, unsigned __int16 a2, _BYTE *a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v6; // eax@9

  v3 = sub_10013360(a1, a2);
  if ( v3 != -1 && !sub_10013340(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10013280(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_101149E4);
        sub_10013320(a1);
        return 1;
      case 0:
        if ( (unsigned __int8)sub_10013280(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_101149F0);
        sub_10013320(a1);
        return 1;
      case 1:
        if ( (unsigned __int8)sub_10013280(a1, v4) != 1 )
          goto LABEL_17;
        v6 = dword_101149CC;
        goto LABEL_16;
      case 2:
        if ( (unsigned __int8)sub_10013280(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_101149F4);
        sub_10013320(a1);
        return 1;
      case 3:
        if ( (unsigned __int8)sub_10013280(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_101149E0);
        sub_10013320(a1);
        return 1;
      case 5:
        if ( (unsigned __int8)sub_10013280(a1, v4) != 1 )
          goto LABEL_17;
        v6 = dword_101149D0;
LABEL_16:
        *a3 = *(_BYTE *)((unsigned __int16)v3 + v6);
        sub_10013320(a1);
        return 1;
      default:
LABEL_17:
        sub_10013320(a1);
        break;
    }
  }
  return 0;
}
// 101149CC: using guessed type int dword_101149CC;
// 101149D0: using guessed type int dword_101149D0;
// 101149E0: using guessed type int dword_101149E0;
// 101149E4: using guessed type int dword_101149E4;
// 101149F0: using guessed type int dword_101149F0;
// 101149F4: using guessed type int dword_101149F4;

//----- (10013700) --------------------------------------------------------
char __cdecl sub_10013700(char a1, unsigned __int16 a2, void *a3)
{
  int v3; // ecx@1
  signed __int16 v4; // si@1
  char result; // al@2

  v4 = sub_10013360(a1, a2);
  if ( v4 == -1 )
  {
    result = 0;
  }
  else
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10013280(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101149E4 + 210116), 0x34u);
        result = 1;
        break;
      case 0:
        if ( (unsigned __int8)sub_10013280(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101149F0 + 257156), 0x34u);
        result = 1;
        break;
      case 1:
        result = sub_10013280(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101149CC + 321708), 0x34u);
        break;
      case 2:
        if ( (unsigned __int8)sub_10013280(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101149F4 + 326220), 0x34u);
        result = 1;
        break;
      case 3:
        if ( (unsigned __int8)sub_10013280(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101149E0 + 18832), 0x34u);
        result = 1;
        break;
      case 5:
        result = sub_10013280(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101149D0 + 1596), 0x34u);
        break;
      default:
LABEL_16:
        result = 0;
        break;
    }
  }
  return result;
}
// 101149CC: using guessed type int dword_101149CC;
// 101149D0: using guessed type int dword_101149D0;
// 101149E0: using guessed type int dword_101149E0;
// 101149E4: using guessed type int dword_101149E4;
// 101149F0: using guessed type int dword_101149F0;
// 101149F4: using guessed type int dword_101149F4;

//----- (10013880) --------------------------------------------------------
char __cdecl sub_10013880(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v5; // eax@5

  v3 = sub_10013360(a1, a2);
  if ( v3 != -1 && !sub_10013340(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10013280(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101149E4 + 24 * ((unsigned __int16)v3 + 25);
        goto LABEL_16;
      case 0:
        if ( (unsigned __int8)sub_10013280(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101149F0 + 24 * (unsigned __int16)v3 + 532;
        goto LABEL_16;
      case 1:
        if ( (unsigned __int8)sub_10013280(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101149CC + 24 * (unsigned __int16)v3 + 2428;
        goto LABEL_16;
      case 2:
        if ( (unsigned __int8)sub_10013280(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101149F4 + 24 * ((unsigned __int16)v3 + 24);
        goto LABEL_16;
      case 3:
        if ( (unsigned __int8)sub_10013280(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101149E0 + 24 * (unsigned __int16)v3 + 84;
        goto LABEL_16;
      case 5:
        if ( (unsigned __int8)sub_10013280(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101149D0 + 24 * (unsigned __int16)v3 + 4;
LABEL_16:
        *(_DWORD *)a3 = *(_DWORD *)v5;
        *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(a3 + 12) = *(_DWORD *)(v5 + 12);
        *(_DWORD *)(a3 + 16) = *(_DWORD *)(v5 + 16);
        *(_DWORD *)(a3 + 20) = *(_DWORD *)(v5 + 20);
        sub_10013320(a1);
        return 1;
      default:
LABEL_17:
        sub_10013320(a1);
        break;
    }
  }
  return 0;
}
// 101149CC: using guessed type int dword_101149CC;
// 101149D0: using guessed type int dword_101149D0;
// 101149E0: using guessed type int dword_101149E0;
// 101149E4: using guessed type int dword_101149E4;
// 101149F0: using guessed type int dword_101149F0;
// 101149F4: using guessed type int dword_101149F4;

//----- (100139E0) --------------------------------------------------------
char __cdecl sub_100139E0(int a1, int a2, void *a3, char a4, __int16 a5, char a6)
{
  int v6; // ecx@0
  signed __int16 v7; // ax@1
  int v8; // edi@2
  __int16 v9; // si@11
  __int16 v11; // [sp+8h] [bp-560h]@13
  __int16 v12; // [sp+3Ch] [bp-52Ch]@10
  char v13; // [sp+40h] [bp-528h]@16
  char v14; // [sp+41h] [bp-527h]@10
  __int16 v15; // [sp+42h] [bp-526h]@10
  char v16; // [sp+44h] [bp-524h]@10
  __int16 v17; // [sp+46h] [bp-522h]@15
  int v18; // [sp+48h] [bp-520h]@16
  char v19; // [sp+4Ch] [bp-51Ch]@15

  LOBYTE(v7) = a1;
  switch ( (char)a1 )
  {
    case 6:
      v8 = 28;
      goto LABEL_8;
    case 0:
      v8 = 29;
      goto LABEL_8;
    case 1:
      v8 = 30;
      goto LABEL_8;
    case 2:
      v8 = 31;
      goto LABEL_8;
    case 3:
      v8 = 32;
      goto LABEL_8;
    case 5:
      v8 = 33;
LABEL_8:
      LOBYTE(v7) = sub_10013280(a1, v6);
      if ( !(_BYTE)v7 )
        return v7;
      v7 = sub_10013360(a1, a2);
      if ( v7 == -1 )
        return v7;
      v14 = a6;
      LOBYTE(v7) = a4;
      v12 = -32768;
      v15 = a2;
      v16 = a4;
      if ( a4 == 1 )
      {
        v9 = a5;
        if ( (unsigned __int16)a5 > 0x514u )
          return v7;
      }
      else
      {
        if ( sub_10013700(a1, a2, &v11) != 1 )
          goto LABEL_16;
        v9 = v11;
      }
      memcpy_0(&v19, a3, (unsigned __int16)v9);
      v17 = v9;
LABEL_16:
      v18 = sub_10031910();
      v13 = 0;
      LOBYTE(v7) = sub_10024960(v8, (int)&v12);
      return v7;
    default:
      return v7;
  }
}

//----- (10013B20) --------------------------------------------------------
char __cdecl sub_10013B20(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // ax@1
  int v4; // edi@2
  __int16 v6; // [sp+4h] [bp-52Ch]@8
  unsigned __int16 v7; // [sp+8h] [bp-528h]@9
  int v8; // [sp+Ch] [bp-524h]@9

  LOBYTE(v3) = a1;
  switch ( a1 )
  {
    case 6:
      v4 = 28;
      goto LABEL_8;
    case 0:
      v4 = 29;
      goto LABEL_8;
    case 1:
      v4 = 30;
      goto LABEL_8;
    case 2:
      v4 = 31;
      goto LABEL_8;
    case 3:
      v4 = 32;
      goto LABEL_8;
    case 5:
      v4 = 33;
LABEL_8:
      memset(&v6, 0, 0x528u);
      v3 = sub_10013360(a1, a2);
      if ( v3 != -1 )
      {
        v6 = -32766;
        v7 = a2;
        v8 = a3;
        LOBYTE(v3) = sub_10024960(v4, (int)&v6);
      }
      break;
    default:
      return v3;
  }
  return v3;
}

//----- (10013C00) --------------------------------------------------------
char __cdecl sub_10013C00(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6)
{
  char result; // al@2
  int v7; // ecx@3
  signed __int16 v8; // si@3
  int v9; // eax@7
  int v10; // ebp@7
  int v11; // esi@7
  int v12; // edi@7
  unsigned int v13; // ebx@7
  int v14; // eax@9
  int v15; // eax@11
  int v16; // eax@13
  int v17; // eax@15
  int v18; // eax@17
  int v19; // eax@25
  char v20; // [sp+7h] [bp-9h]@19
  __int16 v21; // [sp+8h] [bp-8h]@1
  unsigned int v22; // [sp+Ch] [bp-4h]@1

  v22 = sub_10031910();
  v21 = 0;
  if ( a1 < 7 )
  {
    v8 = sub_10013360(a1, a2);
    if ( v8 == -1 )
    {
      result = 0;
    }
    else
    {
      switch ( a1 )
      {
        case 6:
          if ( !(unsigned __int8)sub_10013280(a1, v7) )
            goto LABEL_30;
          v9 = 3 * (unsigned __int16)v8 + 75;
          v10 = dword_101149E4 + 14952;
          v11 = 52 * (unsigned __int16)v8 + dword_101149E4 + 210116;
          v12 = dword_101149E4 + 8 * v9;
          v13 = 195164;
          goto LABEL_18;
        case 0:
          if ( !(unsigned __int8)sub_10013280(a1, v7) )
            goto LABEL_30;
          v14 = 3 * (unsigned __int16)v8;
          v10 = dword_101149F0 + 13228;
          v11 = 52 * (unsigned __int16)v8 + dword_101149F0 + 257156;
          v12 = dword_101149F0 + 8 * v14 + 532;
          v13 = 243928;
          goto LABEL_18;
        case 1:
          if ( !(unsigned __int8)sub_10013280(a1, v7) )
            goto LABEL_30;
          v15 = 3 * (unsigned __int16)v8;
          v10 = dword_101149CC + 60628;
          v11 = 52 * (unsigned __int16)v8 + dword_101149CC + 321708;
          v12 = dword_101149CC + 8 * v15 + 2428;
          v13 = 261080;
          goto LABEL_18;
        case 2:
          if ( !(unsigned __int8)sub_10013280(a1, v7) )
            goto LABEL_30;
          v16 = 3 * (unsigned __int16)v8 + 72;
          v10 = dword_101149F4 + 14328;
          v11 = 52 * (unsigned __int16)v8 + dword_101149F4 + 326220;
          v12 = dword_101149F4 + 8 * v16;
          v13 = 311892;
          goto LABEL_18;
        case 3:
          if ( !(unsigned __int8)sub_10013280(a1, v7) )
            goto LABEL_30;
          v17 = 3 * (unsigned __int16)v8;
          v10 = dword_101149E0 + 2052;
          v11 = 52 * (unsigned __int16)v8 + dword_101149E0 + 18832;
          v12 = dword_101149E0 + 8 * v17 + 84;
          v13 = 16780;
          goto LABEL_18;
        case 5:
          if ( !(unsigned __int8)sub_10013280(a1, v7) )
            goto LABEL_30;
          v18 = 3 * (unsigned __int16)v8;
          v10 = dword_101149D0 + 100;
          v11 = 52 * (unsigned __int16)v8 + dword_101149D0 + 1596;
          v12 = dword_101149D0 + 8 * v18 + 4;
          v13 = 1496;
LABEL_18:
          if ( sub_10013340(a1) )
            goto LABEL_30;
          v20 = *(_BYTE *)(v12 + 1);
          if ( *(_BYTE *)(v12 + 1) == 1 && v10 )
          {
            if ( *(_DWORD *)(v11 + 12) && v22 > *(_DWORD *)(v11 + 16) + *(_DWORD *)(v12 + 16) )
              goto LABEL_33;
            v21 = a4;
            if ( !a4 )
              v21 = *(_WORD *)(v12 + 4) - a3;
            v19 = *(_DWORD *)(v11 + 4) + (unsigned __int16)a3;
            if ( !v21 || (unsigned int)(unsigned __int16)v21 + v19 > v13 )
LABEL_33:
              v20 = 0;
            else
              memcpy_0(a5, (const void *)(v10 + v19), (unsigned __int16)v21);
          }
          *(_WORD *)a6 = v21;
          sub_10013320(a1);
          result = v20;
          break;
        default:
LABEL_30:
          result = 0;
          break;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101149C8: using guessed type int dword_101149C8;
// 101149CC: using guessed type int dword_101149CC;
// 101149D0: using guessed type int dword_101149D0;
// 101149DC: using guessed type int dword_101149DC;
// 101149E0: using guessed type int dword_101149E0;
// 101149E4: using guessed type int dword_101149E4;
// 101149EC: using guessed type int dword_101149EC;
// 101149F0: using guessed type int dword_101149F0;
// 101149F4: using guessed type int dword_101149F4;

//----- (10013E80) --------------------------------------------------------
char __cdecl sub_10013E80(char a1, int a2, __int16 a3, __int16 a4, void *a5)
{
  int v5; // ecx@0
  int v7; // [sp+0h] [bp-4h]@1

  v7 = v5;
  return sub_10013C00(a1, a2, a3, a4, a5, (int)&v7);
}

//----- (10013EB0) --------------------------------------------------------
char __cdecl sub_10013EB0(char a1, int a2, void *a3)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v3;
  return sub_10013C00(a1, a2, 0, 0, a3, (int)&v5);
}

//----- (10013EE0) --------------------------------------------------------
char __cdecl sub_10013EE0(char a1, int a2, void *a3, int a4)
{
  return sub_10013C00(a1, a2, 0, 0, a3, a4);
}

//----- (10013F10) --------------------------------------------------------
int __cdecl sub_10013F10(int a1, int a2)
{
  byte_101F03BC[0] = 0;
  return nullsub_1(a1, a2);
}

//----- (10013F30) --------------------------------------------------------
signed int sub_10013F30()
{
  return 1000;
}

//----- (10013F50) --------------------------------------------------------
int sub_10013F50()
{
  return sub_10023890((int)off_1007B650);
}
// 1007B650: using guessed type int (*off_1007B650[4])();

//----- (10013F70) --------------------------------------------------------
int __cdecl sub_10013F70(unsigned __int16 a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 > 0x1C8Au && a1 < 0x1C8Bu )
    result = (unsigned __int16)(a1 - 7307);
  return result;
}

//----- (10013F90) --------------------------------------------------------
char *__cdecl sub_10013F90(unsigned __int16 a1)
{
  bool v1; // cf@1
  bool v2; // zf@1
  char *result; // eax@1

  v1 = a1 < 0x1C8Au;
  v2 = a1 == 7306;
  result = (char *)&unk_1007B6BC;
  if ( a1 < 0x1C8Au )
  {
    if ( a1 != -1 )
      return (char *)TXT_get_static_string();
    v1 = 0;
    v2 = 0;
  }
  if ( !v1 && !v2 && a1 < 0x1C8Bu )
    result = &byte_101F03BC[(unsigned __int16)sub_10013F70(a1)];
  return result;
}
// 100310FA: using guessed type int TXT_get_static_string(void);

//----- (10013FD0) --------------------------------------------------------
char __thiscall sub_10013FD0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 1;
  sub_10031C50(3024, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10014000) --------------------------------------------------------
char __cdecl sub_10014000(char a1)
{
  char v1; // bl@1
  char result; // al@4

  v1 = a1;
  sub_10032360(69, &a1);
  if ( a1 && (v1 == 15 || v1 == 13) )
    result = 17;
  else
    result = v1;
  return result;
}

//----- (10014030) --------------------------------------------------------
signed int __cdecl sub_10014030(signed int a1)
{
  signed int v1; // esi@1
  signed int result; // eax@4

  v1 = a1;
  sub_10032360(69, &a1);
  if ( (_BYTE)a1 && (v1 == -1 || v1 == -4144960) )
    result = -11250604;
  else
    result = v1;
  return result;
}

//----- (10014070) --------------------------------------------------------
signed int __fastcall sub_10014070(int a1, unsigned __int8 a2)
{
  signed int result; // eax@1

  result = 42066;
  switch ( a2 )
  {
    case 3u:
    case 4u:
      result = (unsigned __int16)(a2 + 9997);
      break;
    case 0u:
    case 1u:
      result = (unsigned __int16)(a2 + 2008);
      break;
    default:
      return result;
  }
  return result;
}

//----- (100140C0) --------------------------------------------------------
int __cdecl sub_100140C0(char a1, void *a2)
{
  int v2; // ecx@0
  int result; // eax@1
  int v4; // [sp-2h] [bp-4h]@1

  v4 = v2;
  BYTE3(v4) = 2;
  result = (unsigned __int16)sub_10014070(v2, a1);
  if ( (_WORD)result == -23470 )
    *(_BYTE *)a2 = 2;
  else
    result = sub_10031DC0((unsigned __int16)result, a2, 1, (char *)&v4 + 3);
  return result;
}

//----- (10014100) --------------------------------------------------------
unsigned __int8 __cdecl sub_10014100(int a1, unsigned __int8 a2)
{
  int v2; // ecx@0
  int v3; // ebx@1
  unsigned __int16 v4; // di@1
  unsigned __int8 result; // al@1
  int v6; // esi@3

  v3 = a1;
  v4 = sub_10014070(v2, a1);
  result = (unsigned __int8)(v3 - 3) <= 1u;
  if ( v4 != -23470 && a2 < 0x20u )
  {
    v6 = 2 * result;
    if ( (unsigned __int8)(*(&off_1007BCAC + 2 * result))(v3, &a1) )
      off_1007BCB0[v6](v3, (unsigned __int8)byte_1007BC68[a2]);
    result = sub_10031CC0(v4, (int)&a2, 1);
  }
  return result;
}
// 1007BCAC: using guessed type int (__cdecl *off_1007BCAC)(int, int);
// 1007BCB0: using guessed type int (__cdecl *off_1007BCB0[2])(char, int);

//----- (10014180) --------------------------------------------------------
bool __cdecl sub_10014180(char a1)
{
  int v1; // eax@1

  v1 = a1 & 0x3F;
  return !(a1 & 0x3F) || v1 == 6 || v1 == 7 || v1 == 21 || v1 == 9 || v1 == 16 || v1 == 20;
}

//----- (100141B0) --------------------------------------------------------
char *__cdecl sub_100141B0(unsigned __int8 a1)
{
  return off_1007C468[2 * a1];
}
// 1007C468: using guessed type char *off_1007C468[24];

//----- (100141C0) --------------------------------------------------------
char *__cdecl sub_100141C0(unsigned int a1, float *a2)
{
  unsigned __int8 v2; // ST0C_1@1

  v2 = sub_10014410(a1, a2);
  return sub_100141B0(v2);
}

//----- (100141F0) --------------------------------------------------------
char __cdecl sub_100141F0(unsigned __int16 a1, int a2, char a3)
{
  int v3; // ecx@0
  char result; // al@1
  int v5; // [sp-2h] [bp-4h]@1

  v5 = v3;
  result = 31;
  BYTE3(v5) = 31;
  switch ( a1 )
  {
    case 0x1Au:
      if ( a3 )
      {
        sub_10032360(44, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_1000E650((void *)a1);
      }
      break;
    case 0u:
    case 0x26u:
    case 0x2Bu:
      if ( a3 )
      {
        sub_10032360(77, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_1000E680((void *)a1);
      }
      break;
    case 0x30u:
    case 0x31u:
      result = 18;
      break;
    case 8u:
    case 9u:
      result = 32;
      break;
    case 0xEu:
    case 0xFu:
    case 0x10u:
      if ( a3 )
      {
        sub_10032360(17, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = 33;
      }
      break;
    case 4u:
    case 5u:
      result = sub_1000E7A0();
      break;
    case 0x11u:
    case 0x12u:
    case 0x13u:
      if ( a3 )
      {
        sub_10032360(14, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_1000E830(a1);
      }
      break;
    case 0x14u:
    case 0x15u:
      result = 39;
      break;
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Du:
      if ( a3 )
      {
        sub_10032360(45, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_1000E980((void *)a1);
      }
      break;
    case 0x1Eu:
    case 0x1Fu:
      if ( a3 )
      {
        sub_10032360(15, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_1000E750(a1);
      }
      break;
    case 0x20u:
    case 0x21u:
      if ( a3 )
      {
        sub_10032360(16, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_1000E6B0(a1);
      }
      break;
    case 0x22u:
    case 0x23u:
      sub_10032360(67, (_BYTE *)&v5 + 3);
      result = BYTE3(v5);
      break;
    case 0x16u:
    case 0x17u:
    case 0x18u:
    case 0x19u:
      result = 0;
      break;
    case 6u:
    case 7u:
      result = 34;
      break;
    case 0x24u:
    case 0x25u:
      result = 41;
      break;
    case 0x29u:
      result = 23;
      break;
    case 1u:
    case 2u:
    case 3u:
    case 0x2Du:
    case 0x2Eu:
      result = 5;
      break;
    case 0x2Fu:
      result = 51;
      break;
    case 0x32u:
      if ( a3 )
      {
        sub_10032360(136, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_1000E9B0(a1);
      }
      break;
    default:
      return result;
  }
  return result;
}

//----- (100143F0) --------------------------------------------------------
char __cdecl sub_100143F0(char a1)
{
  char result; // al@3

  if ( a1 == 1 )
  {
    result = 2;
  }
  else if ( a1 == 3 )
  {
    result = 3;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10014410) --------------------------------------------------------
char __cdecl sub_10014410(unsigned int a1, float *a2)
{
  __int16 v2; // si@1
  int v3; // edx@1
  char v4; // al@1
  char v5; // cl@1
  char result; // al@3
  float *v7; // edi@37
  int v8; // esi@37
  char v9; // al@51

  v2 = a1;
  v3 = a1 & 0x3F;
  v4 = (a1 >> 12) & 1;
  v5 = 31;
  LOBYTE(a1) = 31;
  switch ( v3 )
  {
    case 0:
    case 1:
      if ( v4 )
      {
        sub_10032360(44, &a1);
        result = a1;
      }
      else
      {
        result = sub_1000E650((void *)31);
      }
      break;
    case 2:
    case 27:
      if ( v4 )
      {
        sub_10032360(77, &a1);
        result = a1;
      }
      else
      {
        result = sub_1000E680((void *)31);
      }
      break;
    case 3:
      result = sub_1000E680((void *)31) != 30 ? 29 : 12;
      break;
    case 4:
      v5 = sub_1000E680((void *)31);
      if ( v5 == 21 )
      {
        if ( !a2 || *a2 >= 1000.0 )
          goto LABEL_60;
        result = 29;
      }
      else
      {
        if ( !a2 || *a2 >= 185.2 )
          goto LABEL_60;
        result = 12;
      }
      break;
    case 5:
      result = 18;
      break;
    case 10:
      result = 32;
      break;
    case 11:
      result = sub_1000E7D0((void *)31);
      break;
    case 12:
      if ( v4 )
      {
        sub_10032360(17, &a1);
        result = a1;
      }
      else
      {
        result = 33;
      }
      break;
    case 13:
    case 14:
      result = sub_1000E7A0();
      break;
    case 15:
      if ( v4 )
      {
        sub_10032360(49, &a1);
        result = a1;
      }
      else
      {
        result = sub_1000E800((void *)31);
      }
      break;
    case 16:
    case 17:
      if ( v4 )
      {
        sub_10032360(14, &a1);
        result = a1;
      }
      else
      {
        result = sub_1000E830(31);
      }
      break;
    case 18:
      result = 49;
      break;
    case 19:
      result = 39;
      break;
    case 20:
      if ( v4 )
      {
        sub_10032360(45, &a1);
        result = a1;
      }
      else
      {
        result = sub_1000E980((void *)31);
      }
      break;
    case 21:
      if ( v4 )
      {
        sub_10032360(15, &a1);
        result = a1;
      }
      else
      {
        result = sub_1000E750(31);
      }
      break;
    case 36:
      v7 = a2;
      v8 = v2 & 0x1000;
      switch ( (unsigned __int8)sub_10014410(v8 | 0x15, a2) )
      {
        case 0xDu:
          result = (unsigned __int8)sub_10014410(v8 | 2, v7) != 21 ? 45 : 57;
          break;
        case 0x18u:
          result = (unsigned __int8)sub_10014410(v8 | 2, v7) != 21 ? 54 : 59;
          break;
        case 0x10u:
          result = (unsigned __int8)sub_10014410(v8 | 2, v7) != 21 ? 53 : 58;
          break;
        case 0x13u:
          result = (unsigned __int8)sub_10014410(v8 | 2, v7) != 21 ? 55 : 60;
          break;
        default:
          result = 4 * ((unsigned __int8)sub_10014410(v8 | 2, v7) == 21) + 52;
          break;
      }
      break;
    case 22:
      if ( v4 )
      {
        sub_10032360(16, &a1);
        result = a1;
      }
      else
      {
        result = sub_1000E6B0(31);
      }
      break;
    case 23:
      result = 50;
      break;
    case 24:
      result = 0;
      break;
    case 25:
      result = 34;
      break;
    case 26:
      result = 1;
      break;
    case 38:
    case 39:
    case 42:
    case 43:
      result = 5;
      break;
    case 40:
    case 41:
      v9 = sub_10033190();
      result = sub_100143F0(v9);
      break;
    case 29:
      result = 41;
      break;
    case 30:
      result = 42;
      break;
    case 31:
      result = 43;
      break;
    case 32:
      result = sub_1000E9B0(31);
      break;
    case 33:
      result = 46;
      break;
    case 34:
      result = 47;
      break;
    case 35:
      result = 48;
      break;
    case 37:
      v5 = (sub_1000E9B0(31) != 19) + 61;
      goto LABEL_60;
    default:
LABEL_60:
      result = v5;
      break;
  }
  return result;
}

//----- (10014830) --------------------------------------------------------
double __cdecl sub_10014830(int a1, unsigned __int16 a2, char a3, char *a4)
{
  unsigned __int16 v4; // si@1
  char v5; // al@1
  double v6; // st7@3
  double result; // st7@16
  int v8; // eax@22
  int v9; // eax@23
  int v10; // eax@29
  int v11; // eax@30
  int v12; // eax@39
  int v13; // eax@40
  int v14; // eax@46
  int v15; // eax@47
  float v16; // [sp+4h] [bp-4h]@1

  v16 = 1.0;
  v4 = a2;
  v5 = sub_100141F0(a2, 0, a3);
  *a4 = v5;
  switch ( v4 )
  {
    case 0u:
    case 0x1Au:
    case 0x26u:
    case 0x2Bu:
    case 0x30u:
    case 0x31u:
      switch ( v5 )
      {
        case 0x12:
          v6 = 39.370079;
          goto LABEL_64;
        case 0xC:
          v6 = 3.2808399;
          goto LABEL_64;
        case 0x1E:
          v6 = 0.00053995679;
          goto LABEL_64;
        case 0x15:
          goto LABEL_63;
        default:
          goto LABEL_67;
      }
      goto LABEL_67;
    case 8u:
    case 9u:
      v6 = 100.0;
      goto LABEL_64;
    case 0xEu:
    case 0xFu:
    case 0x10u:
      if ( v5 == 40 )
        v6 = 0.0000099999997;
      else
        v6 = 0.0001450377;
      goto LABEL_64;
    case 4u:
    case 5u:
      v6 = 0.00029530001;
      goto LABEL_64;
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Du:
      if ( v5 == 28 )
        v6 = 60.0;
      else
        v6 = 196.85039;
      goto LABEL_64;
    case 0x11u:
    case 0x12u:
      if ( v5 != 10 || *(float *)&a1 == 9.8999998e24 )
        goto LABEL_67;
      sub_10024AC0((int)&a1, *(float *)&a1);
      return *(float *)&a1;
    case 0x13u:
      if ( v5 != 10 )
        goto LABEL_65;
      v6 = 1.8;
      goto LABEL_64;
    case 0x1Eu:
    case 0x1Fu:
      switch ( v5 )
      {
        case 0xD:
          v6 = 0.26417205;
          goto LABEL_64;
        case 0x10:
          v6 = 0.21997361;
          goto LABEL_64;
        case 0x13:
          v8 = (unsigned __int8)sub_1000E720((void *)v4);
          if ( (_BYTE)v8 )
          {
            v9 = v8 - 1;
            if ( v9 )
            {
              if ( v9 == 1 )
                v6 = 0.77890778;
              else
                v6 = 0.84999973;
            }
            else
            {
              v6 = 0.80407244;
            }
          }
          else
          {
            v6 = 0.71895844;
          }
          goto LABEL_64;
        case 0x18:
          v10 = (unsigned __int8)sub_1000E720((void *)v4);
          if ( (_BYTE)v10 )
          {
            v11 = v10 - 1;
            if ( v11 )
            {
              if ( v11 == 1 )
                v6 = 1.7171981;
              else
                v6 = 1.8756201;
            }
            else
            {
              v6 = 1.7726756;
            }
          }
          else
          {
            v6 = 1.5850322;
          }
          goto LABEL_64;
        default:
          goto LABEL_67;
      }
      goto LABEL_67;
    case 0x20u:
    case 0x21u:
      switch ( v5 )
      {
        case 0xE:
          v6 = 951.01935;
          break;
        case 0x11:
          v6 = 791.90497;
          break;
        case 0x14:
          v12 = (unsigned __int8)sub_1000E720((void *)v4);
          if ( (_BYTE)v12 )
          {
            v13 = v12 - 1;
            if ( v13 )
            {
              if ( v13 == 1 )
                v6 = 2804.0679;
              else
                v6 = 3059.999;
            }
            else
            {
              v6 = 2894.6609;
            }
          }
          else
          {
            v6 = 2588.2505;
          }
          break;
        case 0x19:
          v14 = (unsigned __int8)sub_1000E720((void *)v4);
          if ( (_BYTE)v14 )
          {
            v15 = v14 - 1;
            if ( v15 )
            {
              if ( v15 == 1 )
                v6 = 6181.9131;
              else
                v6 = 6752.2324;
            }
            else
            {
              v6 = 6381.6323;
            }
          }
          else
          {
            v6 = 5706.1162;
          }
          break;
        default:
          v6 = 3600.0;
          break;
      }
      goto LABEL_64;
    case 0x22u:
    case 0x23u:
      if ( v5 == 45 )
        v6 = 0.0020439588;
      else
        v6 = 0.0023521457;
      goto LABEL_64;
    case 0x28u:
      v6 = 0.73756248;
      goto LABEL_64;
    case 0x29u:
      v6 = 1.9438444;
      goto LABEL_64;
    case 0x2Du:
    case 0x2Eu:
      v6 = 57.29578;
      goto LABEL_64;
    case 0x2Fu:
      v6 = 61.023743;
      goto LABEL_64;
    case 0x32u:
      if ( v5 == 19 )
LABEL_63:
        v6 = 0.001;
      else
        v6 = 0.0022046;
LABEL_64:
      v16 = v6;
LABEL_65:
      if ( *(float *)&a1 == 9.8999998e24 )
        goto LABEL_67;
      *(float *)&a1 = *(float *)&a1 * v16;
      result = *(float *)&a1;
      break;
    default:
LABEL_67:
      result = *(float *)&a1;
      break;
  }
  return result;
}

//----- (10014C00) --------------------------------------------------------
double __cdecl sub_10014C00(int a1, unsigned int a2)
{
  __int16 v2; // si@1
  char v3; // al@1
  void *v4; // ecx@1
  double result; // st7@3
  int v6; // eax@26
  int v7; // eax@27
  int v8; // eax@33
  int v9; // eax@34
  double v10; // st7@42
  float v11; // ST0C_4@44
  int v12; // eax@48
  int v13; // eax@49
  int v14; // eax@55
  int v15; // eax@56
  float v16; // [sp+Ch] [bp-4h]@1

  v2 = a2;
  v16 = 1.0;
  v3 = sub_10014410(a2, (float *)&a1);
  v4 = (void *)(v2 & 0x3F);
  switch ( v4 )
  {
    case 0u:
    case 1u:
    case 2u:
    case 3u:
    case 4u:
    case 0x1Bu:
      switch ( v3 )
      {
        case 0xC:
          *(float *)&a1 = (float)3.2808399 * *(float *)&a1;
          return *(float *)&a1;
        case 0x1E:
          *(float *)&a1 = (float)0.00053995679 * *(float *)&a1;
          return *(float *)&a1;
        case 0x12:
          *(float *)&a1 = (float)39.370079 * *(float *)&a1;
          return *(float *)&a1;
        case 0x15:
          goto LABEL_67;
        default:
          goto LABEL_69;
      }
      goto LABEL_69;
    case 0xAu:
      *(float *)&a1 = (float)100.0 * *(float *)&a1;
      return *(float *)&a1;
    case 0xBu:
      if ( v3 != 15 )
        goto LABEL_8;
      *(float *)&a1 = (float)0.0099999998 * *(float *)&a1;
      return *(float *)&a1;
    case 0xDu:
    case 0xEu:
LABEL_8:
      *(float *)&a1 = (float)0.00029530001 * *(float *)&a1;
      return *(float *)&a1;
    case 0xCu:
      if ( v3 == 40 )
      {
        *(float *)&a1 = (float)0.0000099999997 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.0001450377 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0xFu:
      if ( v3 == 22 )
      {
        *(float *)&a1 = (float)3.5999999 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)1.9438444 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x14u:
      if ( v3 == 28 )
      {
        *(float *)&a1 = (float)60.0 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)196.85039 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x10u:
      if ( v3 != 10 )
        goto LABEL_69;
      sub_10024AC0((int)&a1, *(float *)&a1);
      return *(float *)&a1;
    case 0x11u:
      if ( v3 != 10 )
        goto LABEL_68;
      *(float *)&a1 = (float)1.8 * *(float *)&a1;
      return *(float *)&a1;
    case 0x15u:
      switch ( v3 )
      {
        case 0xD:
          *(float *)&a1 = (float)0.26417205 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x10:
          *(float *)&a1 = (float)0.21997361 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x13:
          v6 = (unsigned __int8)sub_1000E720(v4);
          if ( (_BYTE)v6 )
          {
            v7 = v6 - 1;
            if ( v7 )
            {
              if ( v7 == 1 )
              {
                *(float *)&a1 = (float)0.77890778 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.84999973 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.80407244 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.71895844 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x18:
          v8 = (unsigned __int8)sub_1000E720(v4);
          if ( (_BYTE)v8 )
          {
            v9 = v8 - 1;
            if ( v9 )
            {
              if ( v9 == 1 )
              {
                *(float *)&a1 = (float)1.7171981 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)1.8756201 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)1.7726756 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)1.5850322 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          goto LABEL_69;
      }
      return result;
    case 0x24u:
      if ( (unsigned __int8)v3 < 0x38u || (unsigned __int8)v3 > 0x3Cu )
        v10 = 0.00053995679;
      else
        v10 = 0.001;
      v11 = v10;
      *(float *)&a1 = v11 * *(float *)&a1;
      *(float *)&a1 = sub_10015230(a1, v2 & 0x1000 | 0x15u);
      return *(float *)&a1;
    case 0x16u:
      switch ( v3 )
      {
        case 0xE:
          *(float *)&a1 = (float)951.01935 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x11:
          *(float *)&a1 = (float)791.90497 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x14:
          v12 = (unsigned __int8)sub_1000E720(v4);
          if ( (_BYTE)v12 )
          {
            v13 = v12 - 1;
            if ( v13 )
            {
              if ( v13 == 1 )
              {
                *(float *)&a1 = (float)2804.0679 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)3059.999 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)2894.6609 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)2588.2505 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x19:
          v14 = (unsigned __int8)sub_1000E720(v4);
          if ( (_BYTE)v14 )
          {
            v15 = v14 - 1;
            if ( v15 )
            {
              if ( v15 == 1 )
              {
                *(float *)&a1 = (float)6181.9131 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)6752.2324 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)6381.6323 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)5706.1162 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          *(float *)&a1 = (float)3600.0 * *(float *)&a1;
          result = *(float *)&a1;
          break;
      }
      return result;
    case 0x20u:
      if ( v3 == 19 )
        goto LABEL_67;
      *(float *)&a1 = (float)0.0022046 * *(float *)&a1;
      return *(float *)&a1;
    case 0x25u:
      if ( v3 == 61 )
      {
LABEL_67:
        v16 = 0.001;
LABEL_68:
        *(float *)&a1 = v16 * *(float *)&a1;
LABEL_69:
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.0022046 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    default:
      goto LABEL_69;
  }
}

//----- (10015230) --------------------------------------------------------
double __cdecl sub_10015230(int a1, unsigned int a2)
{
  __int16 v2; // di@1
  unsigned int v3; // esi@1
  void *v4; // ecx@1
  char v5; // bl@1
  double result; // st7@5
  int v7; // eax@28
  int v8; // eax@29
  int v9; // eax@35
  int v10; // eax@36
  double v11; // st7@44
  float v12; // ST1C_4@46
  int v13; // eax@50
  int v14; // eax@51
  int v15; // eax@57
  int v16; // eax@58
  float v17; // [sp+14h] [bp-4h]@1

  v17 = 1.0;
  v2 = a2;
  v3 = a2 & 0x3F;
  v5 = sub_10014410(a2, 0);
  if ( v3 == 4 )
    sub_1000D740("..\\lib\\adl\\cdp_cnvt.c", 1174, 1, 0);
  switch ( v3 )
  {
    case 0u:
    case 1u:
    case 2u:
    case 3u:
    case 0x1Bu:
      switch ( v5 )
      {
        case 0xC:
          *(float *)&a1 = (float)0.3048 * *(float *)&a1;
          return *(float *)&a1;
        case 0x1E:
          *(float *)&a1 = (float)1852.0 * *(float *)&a1;
          return *(float *)&a1;
        case 0x12:
          *(float *)&a1 = (float)0.0254 * *(float *)&a1;
          return *(float *)&a1;
        case 0x15:
          goto LABEL_69;
        default:
          goto LABEL_71;
      }
      goto LABEL_71;
    case 0xAu:
      *(float *)&a1 = (float)0.0099999998 * *(float *)&a1;
      return *(float *)&a1;
    case 0xBu:
      if ( v5 != 15 )
        goto LABEL_10;
      *(float *)&a1 = (float)100.0 * *(float *)&a1;
      return *(float *)&a1;
    case 0xDu:
    case 0xEu:
LABEL_10:
      *(float *)&a1 = (float)3386.3867 * *(float *)&a1;
      return *(float *)&a1;
    case 0xCu:
      if ( v5 == 40 )
      {
        *(float *)&a1 = (float)100000.0 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)6894.7593 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0xFu:
      if ( v5 == 22 )
      {
        *(float *)&a1 = (float)0.27777779 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.51444447 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x14u:
      if ( v5 == 11 )
      {
        *(float *)&a1 = (float)0.00508 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.016666668 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x10u:
      if ( v5 != 10 )
        goto LABEL_71;
      sub_10024AE0((int)&a1, *(float *)&a1);
      return *(float *)&a1;
    case 0x11u:
      if ( v5 != 10 )
        goto LABEL_70;
      *(float *)&a1 = (float)0.55555558 * *(float *)&a1;
      return *(float *)&a1;
    case 0x15u:
      switch ( v5 )
      {
        case 0xD:
          *(float *)&a1 = (float)3.7854118 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x10:
          *(float *)&a1 = (float)4.546 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x13:
          v7 = (unsigned __int8)sub_1000E720(v4);
          if ( (_BYTE)v7 )
          {
            v8 = v7 - 1;
            if ( v8 )
            {
              if ( v8 == 1 )
              {
                *(float *)&a1 = (float)1.283849 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)1.176471 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)1.243669 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)1.390901 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x18:
          v9 = (unsigned __int8)sub_1000E720(v4);
          if ( (_BYTE)v9 )
          {
            v10 = v9 - 1;
            if ( v10 )
            {
              if ( v10 == 1 )
              {
                *(float *)&a1 = (float)0.582344 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.53315699 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.56411898 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.63090199 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          goto LABEL_71;
      }
      return result;
    case 0x24u:
      if ( (unsigned __int8)v5 < 0x38u || (unsigned __int8)v5 > 0x3Cu )
        v11 = 1852.0;
      else
        v11 = 1000.0;
      v12 = v11;
      *(float *)&a1 = v12 * *(float *)&a1;
      *(float *)&a1 = sub_10014C00(a1, v2 & 0x1000 | 0x15u);
      return *(float *)&a1;
    case 0x16u:
      switch ( v5 )
      {
        case 0xE:
          *(float *)&a1 = (float)0.0010515032 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x11:
          *(float *)&a1 = (float)0.0012627778 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x14:
          v13 = (unsigned __int8)sub_1000E720(v4);
          if ( (_BYTE)v13 )
          {
            v14 = v13 - 1;
            if ( v14 )
            {
              if ( v14 == 1 )
              {
                *(float *)&a1 = (float)0.00035662472 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.00032679751 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.00034546363 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.00038636138 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x19:
          v15 = (unsigned __int8)sub_1000E720(v4);
          if ( (_BYTE)v15 )
          {
            v16 = v15 - 1;
            if ( v16 )
            {
              if ( v16 == 1 )
              {
                *(float *)&a1 = (float)0.00016176222 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.00014809916 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.00015669972 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.00017525055 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          *(float *)&a1 = (float)0.00027777778 * *(float *)&a1;
          result = *(float *)&a1;
          break;
      }
      return result;
    case 0x20u:
      if ( v5 == 19 )
        goto LABEL_69;
      *(float *)&a1 = (float)453.59241 * *(float *)&a1;
      return *(float *)&a1;
    case 0x25u:
      if ( v5 == 61 )
      {
LABEL_69:
        v17 = 1000.0;
LABEL_70:
        *(float *)&a1 = v17 * *(float *)&a1;
LABEL_71:
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)453.59241 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    default:
      goto LABEL_71;
  }
}

//----- (10015920) --------------------------------------------------------
char __cdecl sub_10015920(signed int a1, char a2)
{
  void *v2; // ecx@0
  char result; // al@1
  char v4; // bl@2
  int v5; // eax@2
  int v6; // eax@6
  unsigned __int16 v7; // si@6
  void *v8; // [sp-2h] [bp-4h]@1

  v8 = v2;
  result = a1;
  BYTE3(v8) = 5;
  if ( (_BYTE)a1 )
  {
    v4 = ((_BYTE)a1 == 2) + 3;
    LOBYTE(a1) = ((_BYTE)a1 == 2) + 3;
    v5 = sub_10011EB0(a1, 1);
    if ( sub_10024A90(v5) == 1 )
      result = (v4 != 3) + 3;
    else
      result = (v4 != 3) + 1;
  }
  BYTE3(v8) = result;
  if ( a2 )
  {
    v6 = sub_100128C0(v2);
    v7 = 27 - (v6 != 2);
    sub_100139E0(1, 27 - (v6 != 2), (char *)&v8 + 3, 0, 1, 1);
    sub_10013B20(1, v7, 0xFFFFFFF);
    result = BYTE3(v8);
  }
  return result;
}

//----- (100159B0) --------------------------------------------------------
int __cdecl sub_100159B0(unsigned __int8 a1)
{
  void *v1; // ecx@0

  return dword_1007DBB8[(unsigned __int8)sub_10016E40(v1) + 2 * a1];
}
// 1007DBB8: using guessed type int dword_1007DBB8[];

//----- (100159D0) --------------------------------------------------------
char __fastcall sub_100159D0(int a1)
{
  int v1; // eax@1
  char result; // al@1
  int v3; // [sp-2h] [bp-4h]@1

  v3 = a1;
  HIWORD(v3) = 0;
  v1 = sub_100159B0(0);
  sub_10031C50(v1, (char *)&v3 + 2, 1, (char *)&v3 + 3);
  result = BYTE2(v3);
  if ( BYTE2(v3) >= 3u )
    result = 0;
  return result;
}

//----- (10015A10) --------------------------------------------------------
char __cdecl sub_10015A10(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  *(_DWORD *)a2 = 0;
  *((_DWORD *)a2 + 1) = 0;
  *((_DWORD *)a2 + 2) = 0;
  *((_DWORD *)a2 + 3) = 0;
  *((_DWORD *)a2 + 4) = 0;
  if ( a1 == 3 )
  {
    result = sub_10013EB0(0, 176, a2);
  }
  else if ( a1 == 4 )
  {
    result = sub_10013EB0(0, 183, a2);
  }
  return result;
}

//----- (10015A60) --------------------------------------------------------
char __cdecl sub_10015A60(char a1, bool *a2)
{
  char result; // al@1
  char v3; // [sp+4h] [bp-18h]@1

  result = sub_10015A10(a1, &v3);
  *a2 = (v3 & 0x10) == 16;
  return result;
}

//----- (10015AB0) --------------------------------------------------------
unsigned __int8 __cdecl sub_10015AB0(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int8 result; // al@1

  result = a2;
  if ( a2 + 1 >= 1 && a2 <= 0x3Fu )
  {
    result = a1;
    if ( (unsigned __int8)(a1 - 3) <= 1u )
      result = sub_10031CC0(dword_1007DBE0[a1], (int)&a2, 1);
  }
  return result;
}
// 1007DBE0: using guessed type int dword_1007DBE0[];

//----- (10015AF0) --------------------------------------------------------
char __cdecl sub_10015AF0(char a1)
{
  int v1; // ecx@0
  char result; // al@2
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  BYTE3(v3) = 34;
  if ( a1 == 3 )
  {
    sub_100139E0(0, 175, (char *)&v3 + 3, 0, 1, 1);
    result = sub_10013B20(0, 0xAFu, 0xFFFFFFF);
  }
  else
  {
    result = a1 - 4;
    if ( a1 == 4 )
    {
      sub_100139E0(0, 182, (char *)&v3 + 3, 0, 1, 1);
      result = sub_10013B20(0, 0xB6u, 0xFFFFFFF);
    }
  }
  return result;
}

//----- (10015B60) --------------------------------------------------------
int __cdecl sub_10015B60(char a1, _DWORD *a2)
{
  int result; // eax@1
  char v3; // [sp+4h] [bp-18h]@1
  int v4; // [sp+8h] [bp-14h]@1

  LOBYTE(result) = sub_10015A10(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (10015BA0) --------------------------------------------------------
char __cdecl sub_10015BA0(int a1, int a2, unsigned __int16 a3, int a4, char a5)
{
  int v5; // edx@1
  double v6; // st7@1
  int v7; // eax@1
  float v8; // ST10_4@1
  int v9; // eax@1
  const char *v10; // edi@1
  double v11; // st7@2
  char v12; // al@2
  int v13; // edx@3
  char *v14; // ecx@3
  double v15; // st7@11
  float *v16; // ecx@13
  int v17; // eax@16
  double v18; // st6@17
  bool v19; // zf@17
  char v21; // [sp+1Fh] [bp-65h]@1
  __int16 v22; // [sp+20h] [bp-64h]@17
  __int16 v23; // [sp+22h] [bp-62h]@17
  float v24; // [sp+24h] [bp-60h]@11
  float v25; // [sp+28h] [bp-5Ch]@13
  int v26; // [sp+2Ch] [bp-58h]@1
  float v27; // [sp+30h] [bp-54h]@15
  int v28; // [sp+34h] [bp-50h]@1
  int v29; // [sp+38h] [bp-4Ch]@1
  float v30; // [sp+3Ch] [bp-48h]@1
  float v31; // [sp+40h] [bp-44h]@1
  int v32; // [sp+44h] [bp-40h]@1
  float v33; // [sp+48h] [bp-3Ch]@1
  float v34; // [sp+4Ch] [bp-38h]@1
  int v35; // [sp+50h] [bp-34h]@1
  int v36; // [sp+54h] [bp-30h]@1
  int v37; // [sp+68h] [bp-1Ch]@1
  char v38; // [sp+6Ch] [bp-18h]@2

  v5 = *(_DWORD *)(a2 + 12);
  v30 = *(float *)(a2 + 40);
  v35 = a4;
  v31 = 0.0;
  v6 = *(float *)(a2 + 40);
  LOBYTE(v36) = a5;
  v7 = *(_DWORD *)(a2 + 8);
  v8 = v6;
  v21 = 31;
  LOWORD(v26) = a3;
  v37 = 0;
  v28 = v5;
  v29 = v7;
  v9 = sub_1000F740(v8);
  v33 = *(float *)(a2 + 32);
  v34 = *(float *)(a2 + 36);
  v32 = v9;
  v10 = (const char *)sub_1000DB20(a3);
  if ( v10 )
  {
    v11 = sub_10014830(COERCE_INT(*(float *)(a2 + 28)), v26, v36, &v21);
    sprintf(&v38, v10, LODWORD(v11), (_DWORD)(*(unsigned __int64 *)&v11 >> 32));
    v12 = v38;
    if ( v38 )
    {
      v13 = v37;
      v14 = &v38;
      do
      {
        if ( (unsigned __int8)v12 >= 0x30u && (unsigned __int8)v12 <= 0x39u )
          ++v13;
        v12 = (v14++)[1];
      }
      while ( v12 );
      v37 = v13;
    }
  }
  else
  {
    v37 = 0;
  }
  if ( *(float *)(a2 + 28) >= (double)*(float *)(a2 + 24) )
  {
    v24 = *(float *)(a2 + 24);
    v15 = *(float *)(a2 + 28);
  }
  else
  {
    v24 = *(float *)(a2 + 28);
    v15 = *(float *)(a2 + 24);
  }
  v16 = *(float **)(a2 + 20);
  v25 = v15;
  if ( v24 > (double)*v16 || v25 < (double)*v16 )
  {
    v17 = *(_DWORD *)(a2 + 16);
    v27 = 9.8999998e24;
    v29 = 0;
    v28 = v17;
  }
  else
  {
    v27 = *v16;
  }
  v18 = *(float *)(a2 + 4);
  v22 = (signed int)*(float *)a2;
  v19 = *(_BYTE *)(a2 + 46) == 0;
  v23 = (signed int)v18;
  if ( !v19 && 9.8999998e24 == v27 )
    v23 += (signed int)(*(float *)(a2 + 40) * -0.5);
  return sub_1000DB30(a1, 0, (int)&v22, (int)&v26, (__int16 *)&unk_1006F534);
}

//----- (10015D70) --------------------------------------------------------
void __cdecl sub_10015D70(int a1)
{
  sub_1000FE10(
    *(float *)a1,
    *(float *)(a1 + 4),
    25.0,
    *(float *)(a1 + 40),
    *(float *)(a1 + 32),
    *(float *)(a1 + 36),
    *(_BYTE *)(a1 + 45));
}

//----- (10015DB0) --------------------------------------------------------
void __usercall sub_10015DB0(int a1@<ebx>, int a2@<esi>, char a3)
{
  int v3; // eax@2
  int v4; // ecx@2
  int v5; // edx@2
  float v6; // [sp+8h] [bp-24h]@2
  float v7; // [sp+Ch] [bp-20h]@2
  int v8; // [sp+10h] [bp-1Ch]@2
  float v9; // [sp+14h] [bp-18h]@2
  int v10; // [sp+18h] [bp-14h]@2
  int v11; // [sp+1Ch] [bp-10h]@2
  float v12; // [sp+20h] [bp-Ch]@2
  float v13; // [sp+24h] [bp-8h]@2
  float v14; // [sp+28h] [bp-4h]@2

  if ( *(_BYTE *)(a2 + 16) )
  {
    v12 = *(float *)(a2 + 40);
    v13 = *(float *)(a2 + 44);
    v6 = *(float *)a2;
    v7 = *(float *)(a2 + 4);
    v3 = sub_1000F740(*(float *)(a2 + 48));
    v4 = *(_DWORD *)(a2 + 8);
    v5 = *(_DWORD *)(a2 + 12);
    v9 = *(float *)(a2 + 48);
    v8 = v3;
    v10 = v4;
    v11 = v5;
    v14 = sub_10032020(v3, a2 + 16, v9);
    if ( a3 )
      sub_1000FF90(a1, a2 + 16, (int)&v6);
    else
      sub_1000FF70(a1, a2 + 16, (int)&v6);
  }
}

//----- (10015E50) --------------------------------------------------------
void __cdecl sub_10015E50(int a1, int a2)
{
  sub_10015DB0(a1, a2, 1);
}

//----- (10015E70) --------------------------------------------------------
char __cdecl sub_10015E70(float a1, int a2, char a3, int a4)
{
  char v4; // bl@1
  int v5; // ebp@1
  double v6; // st6@1
  unsigned __int8 v7; // dl@4
  int v8; // ecx@5
  int v9; // ecx@17
  bool v10; // zf@17
  int v11; // ebp@19
  char v13; // [sp+13h] [bp-1h]@1

  v4 = *(_BYTE *)(a2 + 4);
  v13 = 0;
  v5 = sub_10031910();
  v6 = a1;
  if ( a1 == 9.8999998e24 )
  {
    v4 = 10;
    v13 = 10;
  }
  else if ( *(_BYTE *)(a4 + 24) )
  {
    v4 = *(_BYTE *)a4;
    v13 = *(_BYTE *)(a4 + 12);
  }
  else
  {
    v7 = 1;
    if ( (unsigned __int8)a3 > 1u )
    {
      v8 = a2;
      do
      {
        if ( 9.8999998e24 != *(float *)(v8 + 8)
          && (*(float *)v8 < (double)*(float *)(v8 + 8) && *(float *)v8 < v6
           || *(float *)v8 > (double)*(float *)(v8 + 8) && *(float *)v8 > v6) )
        {
          v4 = *(_BYTE *)(v8 + 12);
          v13 = v7;
        }
        ++v7;
        v8 += 8;
      }
      while ( v7 < (unsigned __int8)a3 );
    }
  }
  if ( v4 != *(_BYTE *)a4 )
  {
    *(_DWORD *)(a4 + 8) = 0;
    *(_DWORD *)(a4 + 4) = v5;
  }
  v9 = v5 - *(_DWORD *)(a4 + 4);
  v10 = v13 == *(_BYTE *)(a4 + 12);
  *(_BYTE *)a4 = v4;
  *(_DWORD *)(a4 + 8) = v9;
  if ( !v10 )
  {
    *(_DWORD *)(a4 + 20) = 0;
    *(_DWORD *)(a4 + 16) = v5;
  }
  v11 = v5 - *(_DWORD *)(a4 + 16);
  *(_BYTE *)(a4 + 12) = v13;
  *(_DWORD *)(a4 + 20) = v11;
  return v4;
}

//----- (10015F60) --------------------------------------------------------
char __cdecl sub_10015F60(char a1, _DWORD *a2, int *a3, char a4, int a5)
{
  int v5; // eax@1
  int *v6; // ecx@2
  int v7; // ecx@4
  int v8; // edx@8

  LOBYTE(v5) = a4;
  if ( a4 == 1 )
  {
    LOBYTE(v5) = (_BYTE)a2;
    v6 = a3;
    *a2 = 0;
    *v6 = 0;
  }
  else if ( !a4 )
  {
    v5 = 32 * sub_10016EA0(&a1, 1u, (int)&unk_1007E810, 32, 20, 0);
    v7 = *(int *)((char *)&dword_1007E82C + v5);
    if ( !v7 || v7 != -1 && a5 > v7 || byte_101BD3BE )
    {
      *a2 = *(int *)((char *)&dword_1007E81C + v5);
      v5 = *(int *)((char *)&dword_1007E820 + v5);
      *a3 = v5;
    }
    else
    {
      *a2 = *(int *)((char *)&dword_1007E820 + v5);
      v8 = *(int *)((char *)&dword_1007E81C + v5);
      LOBYTE(v5) = (_BYTE)a3;
      *a3 = v8;
    }
  }
  return v5;
}
// 1007E81C: using guessed type int dword_1007E81C;
// 1007E820: using guessed type int dword_1007E820;
// 1007E82C: using guessed type int dword_1007E82C;
// 101BD3BE: using guessed type char byte_101BD3BE;

//----- (10015FF0) --------------------------------------------------------
char __cdecl sub_10015FF0(char a1, _DWORD *a2, int *a3, char a4, int a5)
{
  int v5; // eax@1
  int *v6; // ecx@2
  int v7; // ecx@4
  int v8; // edx@8

  LOBYTE(v5) = a4;
  if ( a4 == 1 )
  {
    LOBYTE(v5) = (_BYTE)a2;
    v6 = a3;
    *a2 = 0;
    *v6 = 0;
  }
  else if ( !a4 )
  {
    v5 = 32 * sub_10016EA0(&a1, 1u, (int)&unk_1007E810, 32, 20, 0);
    v7 = *(int *)((char *)&dword_1007E82C + v5);
    if ( !v7 || v7 != -1 && a5 > v7 || byte_101BD3BE )
    {
      *a2 = *(int *)((char *)&dword_1007E814 + v5);
      v5 = *(int *)((char *)&dword_1007E818 + v5);
      *a3 = v5;
    }
    else
    {
      *a2 = *(int *)((char *)&dword_1007E818 + v5);
      v8 = *(int *)((char *)&dword_1007E814 + v5);
      LOBYTE(v5) = (_BYTE)a3;
      *a3 = v8;
    }
  }
  return v5;
}
// 1007E814: using guessed type int dword_1007E814;
// 1007E818: using guessed type int dword_1007E818;
// 1007E82C: using guessed type int dword_1007E82C;
// 101BD3BE: using guessed type char byte_101BD3BE;

//----- (10016080) --------------------------------------------------------
int __cdecl sub_10016080(int a1)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)(a1 + 12) = 10;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_BYTE *)a1 = 10;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  return result;
}

//----- (100160A0) --------------------------------------------------------
double __cdecl sub_100160A0(float a1, float a2, int a3, float a4)
{
  double v4; // st7@2
  double v5; // st7@4
  bool v6; // c0@5
  double v7; // st7@5
  double v9; // st5@7
  bool v10; // c0@7
  bool v11; // c3@7
  float v12; // [sp+8h] [bp-8h]@4
  float v13; // [sp+Ch] [bp-4h]@4
  int v14; // [sp+1Ch] [bp+Ch]@4
  int v15; // [sp+1Ch] [bp+Ch]@4
  int v16; // [sp+1Ch] [bp+Ch]@4
  int v17; // [sp+1Ch] [bp+Ch]@9

  if ( (unsigned __int8)a3 <= 0x64u )
    v4 = (double)(unsigned __int8)a3;
  else
    v4 = 100.0;
  *(float *)&v14 = v4;
  *(float *)&v15 = *(float *)&v14 / 100.0 * a4;
  v12 = (*(float *)&v15 + a4) * 0.5;
  v13 = sub_100376F0(a1, a4);
  *(float *)&v16 = sub_10037650(a1, a4);
  v5 = a1;
  if ( a1 < (double)a2 )
  {
    v9 = *(float *)&v16 - v12;
    v10 = v9 < v5;
    v11 = v9 == v5;
    v7 = *(float *)&v16;
    if ( !v10 && !v11 )
      v7 = v13;
  }
  else
  {
    v6 = v13 + v12 < v5;
    v7 = v13;
    if ( v6 )
      return *(float *)&v16;
  }
  *(float *)&v17 = v7;
  return *(float *)&v17;
}

//----- (10016180) --------------------------------------------------------
char __cdecl sub_10016180(bool *a1)
{
  unsigned __int8 v1; // bl@1
  unsigned __int16 *v2; // esi@1
  signed int v3; // edi@4
  void *v4; // ecx@5
  char v5; // al@9
  void *v6; // ecx@13
  char v8; // [sp+1h] [bp-Bh]@1
  char v9; // [sp+2h] [bp-Ah]@1
  unsigned __int8 v10; // [sp+3h] [bp-9h]@1
  unsigned __int8 v11; // [sp+4h] [bp-8h]@1
  bool v12; // [sp+5h] [bp-7h]@1
  char v13; // [sp+6h] [bp-6h]@6
  bool v14; // [sp+7h] [bp-5h]@1
  float v15; // [sp+8h] [bp-4h]@1

  v14 = (unsigned __int8)sub_10012F50() > 1u;
  v1 = 0;
  v12 = sub_10017030(&v15);
  v8 = 1;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v2 = (unsigned __int16 *)&unk_1007F5F0;
  if ( sub_10024B80(0x2E6u) || sub_10024B80(0x2E7u) )
    v2 = (unsigned __int16 *)&unk_1007F5E8;
  v3 = 4;
  do
  {
    if ( sub_10024B80(*v2) && sub_10024BF0(*v2, &v13) )
    {
      v10 += v13;
      ++v1;
      LOBYTE(v4) = v13 == 0;
      v11 += v13 == 0;
    }
    ++v2;
    --v3;
  }
  while ( v3 );
  v5 = byte_1007F5F8[v1];
  if ( v10 >= (unsigned __int8)v5 )
    goto LABEL_20;
  if ( v11 >= (unsigned __int8)v5 )
    goto LABEL_19;
  if ( v14 )
  {
    if ( !sub_100131A0() )
    {
      if ( !v12 )
        goto LABEL_20;
      goto LABEL_18;
    }
LABEL_19:
    v8 = 1;
LABEL_21:
    v9 = 1;
    goto LABEL_22;
  }
  if ( v12 )
  {
LABEL_18:
    if ( v15 > 25.72207 )
      goto LABEL_19;
LABEL_20:
    v8 = 0;
    goto LABEL_21;
  }
  if ( sub_1000EB50(v4) == 2 || sub_1000EB50(v6) == 8 )
  {
    *a1 = 1;
    return 0;
  }
LABEL_22:
  *a1 = v8 == 0;
  return v9;
}

//----- (100162D0) --------------------------------------------------------
bool sub_100162D0()
{
  return sub_100319C0(99) == 0;
}

//----- (100162E0) --------------------------------------------------------
bool sub_100162E0()
{
  return sub_100319E0(99, 10000) == 0;
}

//----- (10016300) --------------------------------------------------------
double sub_10016300()
{
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v1 = 9.8999998e24;
  sub_10031C50(10002, &v2, 4, &v1);
  return v2;
}

//----- (10016330) --------------------------------------------------------
char __usercall sub_10016330@<al>(float *a1@<edi>, unsigned __int16 a2@<si>, unsigned __int8 a3)
{
  double v3; // st7@8
  char result; // al@10
  char v5; // [sp+7h] [bp-29h]@3
  float v6; // [sp+8h] [bp-28h]@1
  float v7; // [sp+Ch] [bp-24h]@3
  int v8; // [sp+10h] [bp-20h]@1
  int v9; // [sp+14h] [bp-1Ch]@1
  int v10; // [sp+18h] [bp-18h]@1
  int v11; // [sp+1Ch] [bp-14h]@1
  float v12[4]; // [sp+20h] [bp-10h]@1

  v6 = 0.0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  if ( sub_10031C50(6117, v12, 16, &v8) )
    sub_1000D740("..\\lib\\adl\\iop_eis_intf.c", 2716, 0, 0);
  sub_100135A0(1, 0x50u, &v5);
  if ( sub_10031C90(6354, (int)&v7, 4) )
    sub_1000D740("..\\lib\\adl\\iop_eis_intf.c", 2735, 0, 0);
  if ( (sub_10024C20(a2) || v5) && sub_10012CE0(a2, &v6) )
  {
    v6 = v12[2 * a3] * v6;
    v3 = v6;
    *a1 = v6;
    if ( v7 > v3 )
      *a1 = 0.0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10016330: using guessed type float var_10[4];

//----- (10016420) --------------------------------------------------------
char __cdecl sub_10016420(float *a1)
{
  return sub_10016330(a1, 0x14u, 0);
}

//----- (10016440) --------------------------------------------------------
char __cdecl sub_10016440(float *a1)
{
  return sub_10016330(a1, 0x2Du, 1u);
}

//----- (10016460) --------------------------------------------------------
char __cdecl sub_10016460(float *a1)
{
  char v1; // bl@1
  char result; // al@4
  float v3; // [sp+4h] [bp-8h]@1
  float v4; // [sp+8h] [bp-4h]@1

  v3 = 0.0;
  v4 = 0.0;
  v1 = 0;
  if ( sub_10016420(&v3) )
  {
    v1 = 1;
    v4 = v3 + 0.0;
  }
  if ( sub_10016440(&v3) )
  {
    result = 1;
    v4 = v4 + v3;
    *a1 = v4;
  }
  else if ( v1 )
  {
    result = v1;
    *a1 = v4;
  }
  else
  {
    *a1 = 9.8999998e24;
    result = 0;
  }
  return result;
}

//----- (100164F0) --------------------------------------------------------
double sub_100164F0()
{
  int v0; // eax@1
  double result; // st7@1
  float v2; // [sp+0h] [bp-10h]@1
  float v3; // [sp+4h] [bp-Ch]@1
  double v4; // [sp+8h] [bp-8h]@2

  v3 = 9.8999998e24;
  v0 = sub_10031C50(10009, &v2, 4, &v3);
  result = v2;
  if ( !v0 )
  {
    v4 = v2;
    v2 = v4 - sub_10016300();
    if ( v2 >= 0.0 )
    {
      result = v2;
    }
    else
    {
      v2 = 0.0;
      result = (float)0.0;
    }
  }
  return result;
}

//----- (10016550) --------------------------------------------------------
signed int __cdecl sub_10016550(int a1)
{
  signed int result; // eax@1

  result = 0x3FFFF;
  if ( a1 )
  {
    if ( *(_BYTE *)a1 < 0x17u )
      result = *(_DWORD *)(a1 + 36);
  }
  return result;
}

//----- (10016570) --------------------------------------------------------
double __cdecl sub_10016570(signed int a1, char a2)
{
  return (double)(a1 >> (31 - a2)) / (double)(1 << a2) * 3.1415926535898;
}

//----- (100165B0) --------------------------------------------------------
void __cdecl sub_100165B0(_BYTE *a1, signed int a2, int a3)
{
  signed int v3; // esi@1
  _BYTE *v4; // ecx@2
  unsigned int v5; // edx@2
  unsigned int v6; // eax@6
  unsigned __int16 v7; // ax@7
  char v8; // al@10

  v3 = 0;
  if ( a2 > 0 )
  {
    v4 = a1;
    v5 = a2;
    do
    {
      if ( v3 & 3 )
      {
        if ( (v3 & 3) == 1 )
        {
          v6 = v5 >> 4;
        }
        else
        {
          --v4;
          if ( (v3 & 3) == 2 )
          {
            HIBYTE(v7) = v4[1];
            LOBYTE(v7) = *v4;
            v5 = v7;
            v6 = (unsigned int)v7 >> 6;
          }
          else
          {
            LOBYTE(v6) = v5;
          }
        }
      }
      else
      {
        BYTE1(v5) = *v4--;
        LOBYTE(v5) = *v4;
        v5 = (unsigned __int16)v5;
        LOWORD(v6) = (unsigned __int16)v5 >> 10;
      }
      v8 = v6 & 0x3F;
      if ( v8 )
      {
        if ( (unsigned __int8)(v8 - 1) > 0x19u )
        {
          if ( (unsigned __int8)(v8 - 32) <= 9u )
            v8 += 16;
        }
        else
        {
          v8 += 64;
        }
        *(_BYTE *)(v3 + a3) = v8;
      }
      else
      {
        *(_BYTE *)(v3 + a3) = 32;
      }
      ++v3;
    }
    while ( v3 < a2 );
  }
}

//----- (10016650) --------------------------------------------------------
bool __cdecl sub_10016650(unsigned int a1, unsigned __int16 a2)
{
  unsigned int v2; // eax@2
  bool result; // al@5

  result = 0;
  if ( a2 < 0x96u )
  {
    v2 = 12 * a2;
    if ( a1 < dword_101EFB68[v2 / 4] && word_101EFB64[v2 / 2] && dword_101EFB60[v2 / 4] )
      result = 1;
  }
  return result;
}
// 101EFB60: using guessed type int dword_101EFB60[];
// 101EFB64: using guessed type __int16 word_101EFB64[];
// 101EFB68: using guessed type int dword_101EFB68[];

//----- (10016690) --------------------------------------------------------
int __cdecl sub_10016690(unsigned __int16 a1)
{
  unsigned __int16 v1; // dx@1
  int result; // eax@2

  if ( sub_10016650(0, a1) )
    result = dword_101EFB68[3 * v1];
  else
    result = 0;
  return result;
}
// 101EFB68: using guessed type int dword_101EFB68[];

//----- (100166C0) --------------------------------------------------------
int __cdecl sub_100166C0(int a1, signed int a2, signed int a3)
{
  int result; // eax@1

  result = a1;
  *(double *)(a1 + 8) = (double)a3 * 0.000000001462918079267163;
  *(double *)a1 = 0.000000001462918079267163 * (double)a2;
  return result;
}

//----- (100166E0) --------------------------------------------------------
int __cdecl sub_100166E0(_BYTE *a1)
{
  int result; // eax@1

  result = (int)a1;
  *a1 = 0;
  if ( !byte_101F03B4 )
    result = (*(int (__cdecl **)(signed int, signed int, _BYTE *))dword_101EFA5C)(146, 1, a1);
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101F03B4: using guessed type char byte_101F03B4;

//----- (10016710) --------------------------------------------------------
char __cdecl sub_10016710(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  char v3; // [sp+8h] [bp-14h]@2
  unsigned __int8 v4; // [sp+9h] [bp-13h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_101F03B4 )
  {
    (*(void (__cdecl **)(int, signed int, char *))dword_101EFA5C)(dword_101EFE84, 18, &v3);
    result = v4 & 0xF;
    *a2 = v4 >> 4;
    *a1 = result;
  }
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101EFE84: using guessed type int dword_101EFE84;
// 101F03B4: using guessed type char byte_101F03B4;

//----- (10016760) --------------------------------------------------------
char __cdecl sub_10016760(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  unsigned __int8 v3; // [sp+8h] [bp-14h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_101F03B4 )
  {
    (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_101EFA5C)(dword_101EFE84, 18, &v3);
    result = v3 & 0xF;
    *a2 = v3 >> 4;
    *a1 = result;
  }
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101EFE84: using guessed type int dword_101EFE84;
// 101F03B4: using guessed type char byte_101F03B4;

//----- (100167B0) --------------------------------------------------------
int sub_100167B0()
{
  int result; // eax@1
  unsigned int v1; // ecx@1
  int v2; // edi@4
  int *v3; // esi@5
  int v4; // ebx@5
  int v5; // edx@6
  int v6; // [sp+4h] [bp-Ch]@1
  int v7; // [sp+8h] [bp-8h]@4
  unsigned int v8; // [sp+Ch] [bp-4h]@4

  memset(dword_101EFB60, 0, 0x708u);
  result = (*(int (__cdecl **)(signed int, int *))dword_101EFA4C)(512, &v6);
  v1 = 0;
  do
  {
    word_101EFB64[v1 / 2] = 0;
    dword_101EFB68[v1 / 4] = 0;
    dword_101EFB60[v1 / 4] = 0;
    v1 += 12;
  }
  while ( v1 < 0x708 );
  if ( (_BYTE)result )
  {
    dword_101EFB6C = v6;
    result = v8;
    v2 = (unsigned __int16)v7 + 512;
    dword_101EFB70 = v7;
    dword_101EFB74 = v8;
    if ( v8 >= 2 )
    {
      v3 = &dword_101EFB78;
      v4 = v8 - 1;
      do
      {
        (*(void (__cdecl **)(int, int *))dword_101EFA4C)(v2, &v6);
        v5 = v7;
        result = v8;
        *v3 = v6;
        v3[1] = v5;
        v3[2] = result;
        v2 += (unsigned __int16)dword_101EFB70;
        v3 += 3;
        --v4;
      }
      while ( v4 );
    }
  }
  return result;
}
// 101EFA4C: using guessed type int dword_101EFA4C;
// 101EFB60: using guessed type int dword_101EFB60[];
// 101EFB64: using guessed type __int16 word_101EFB64[];
// 101EFB68: using guessed type int dword_101EFB68[];
// 101EFB6C: using guessed type int dword_101EFB6C;
// 101EFB70: using guessed type int dword_101EFB70;
// 101EFB74: using guessed type int dword_101EFB74;
// 101EFB78: using guessed type int dword_101EFB78;

//----- (10016880) --------------------------------------------------------
__int16 sub_10016880()
{
  __int16 result; // ax@1
  unsigned int v1; // ebx@1
  unsigned int v2; // esi@1
  int v3; // edi@1
  int v4; // ebp@2
  __int16 v5; // [sp+Ch] [bp-4h]@3

  result = word_101EFB7C;
  v1 = dword_101EFB80;
  v2 = 1;
  v3 = dword_101EFB78;
  if ( (unsigned int)dword_101EFB80 >= 1 )
  {
    v4 = (unsigned __int16)word_101EFB7C;
    do
    {
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_101EFA5C)(v3, 2, &v5);
      result = v5;
      word_101F0280[v2++] = v5;
      v3 += v4;
    }
    while ( v2 <= v1 );
  }
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101EFB78: using guessed type int dword_101EFB78;
// 101EFB7C: using guessed type __int16 word_101EFB7C;
// 101EFB80: using guessed type int dword_101EFB80;
// 101F0280: using guessed type __int16 word_101F0280[];

//----- (100168E0) --------------------------------------------------------
int __usercall sub_100168E0@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4)
{
  signed int v4; // edx@1
  _BYTE *v5; // ecx@2
  unsigned int v6; // ebx@2
  unsigned __int16 v7; // ax@7

  v4 = 0;
  if ( a3 > 0 )
  {
    v5 = a2;
    v6 = a3;
    do
    {
      if ( v4 & 3 )
      {
        if ( (v4 & 3) == 1 )
        {
          result = v6 >> 4;
        }
        else
        {
          --v5;
          result = (v4 & 3) - 2;
          if ( (v4 & 3) == 2 )
          {
            HIBYTE(v7) = v5[1];
            LOBYTE(v7) = *v5;
            v6 = v7;
            result = (unsigned int)v7 >> 6;
          }
          else
          {
            LOBYTE(result) = v6;
          }
        }
      }
      else
      {
        HIWORD(result) = 0;
        BYTE1(result) = *v5--;
        LOBYTE(result) = *v5;
        v6 = (unsigned __int16)result;
        LOWORD(result) = (unsigned __int16)result >> 10;
      }
      LOBYTE(result) = (result & 0x3F) + 32;
      *(_BYTE *)(v4++ + a4) = result;
    }
    while ( v4 < a3 );
  }
  return result;
}

//----- (10016960) --------------------------------------------------------
signed int __cdecl sub_10016960(int a1)
{
  signed int result; // eax@1
  char v2; // [sp+8h] [bp-10h]@3
  char v3; // [sp+13h] [bp-5h]@3

  result = 538976288;
  *(_DWORD *)a1 = 538976288;
  *(_DWORD *)(a1 + 4) = 538976288;
  *(_DWORD *)(a1 + 8) = 538976288;
  *(_DWORD *)(a1 + 12) = 538976288;
  if ( byte_101F03B4 )
  {
    LOBYTE(dword_10114A64) = 0;
    *(_BYTE *)(a1 + 16) = 0;
  }
  else if ( (_BYTE)dword_10114A64 )
  {
    *(_DWORD *)a1 = dword_10114A64;
    *(_DWORD *)(a1 + 4) = dword_10114A68;
    *(_DWORD *)(a1 + 8) = dword_10114A6C;
    result = dword_10114A70;
    *(_DWORD *)(a1 + 12) = dword_10114A70;
    *(_BYTE *)(a1 + 16) = 0;
  }
  else
  {
    (*(void (__cdecl **)(signed int, signed int, char *))dword_101EFA5C)(147, 12, &v2);
    sub_100168E0((int)&v3, &v3, 16, a1);
    dword_10114A64 = *(_DWORD *)a1;
    dword_10114A68 = *(_DWORD *)(a1 + 4);
    result = *(_DWORD *)(a1 + 8);
    dword_10114A6C = *(_DWORD *)(a1 + 8);
    dword_10114A70 = *(_DWORD *)(a1 + 12);
    byte_10114A74 = *(_BYTE *)(a1 + 16);
    *(_BYTE *)(a1 + 16) = 0;
  }
  return result;
}
// 10114A64: using guessed type int dword_10114A64;
// 10114A68: using guessed type int dword_10114A68;
// 10114A6C: using guessed type int dword_10114A6C;
// 10114A70: using guessed type int dword_10114A70;
// 10114A74: using guessed type char byte_10114A74;
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101F03B4: using guessed type char byte_101F03B4;

//----- (10016A50) --------------------------------------------------------
unsigned __int8 sub_10016A50()
{
  unsigned __int8 result; // al@1
  unsigned int v1; // edx@2
  char *v2; // ecx@2
  char *v3; // esi@2
  int v4; // edi@6
  int v5; // edx@7
  _BYTE *v6; // ecx@7
  _BYTE *v7; // esi@7
  int v8; // edx@9
  _BYTE *v9; // ecx@9
  _BYTE *v10; // esi@9
  _BYTE *v11; // ecx@11
  _BYTE *v12; // esi@11
  signed int v13; // ecx@13
  char v14; // [sp+0h] [bp-18h]@1

  sub_10016960((int)&v14);
  result = 0;
  do
  {
    v1 = 10;
    v2 = &a006D0170[11 * result];
    v3 = &v14;
    do
    {
      if ( *(_DWORD *)v3 != *(_DWORD *)v2 )
        goto LABEL_6;
      v1 -= 4;
      v2 += 4;
      v3 += 4;
    }
    while ( v1 >= 4 );
    if ( !v1 )
    {
LABEL_15:
      v13 = 0;
      goto LABEL_16;
    }
LABEL_6:
    v4 = (unsigned __int8)*v3 - (unsigned __int8)*v2;
    if ( (unsigned __int8)*v3 == (unsigned __int8)*v2 )
    {
      v5 = v1 - 1;
      v6 = v2 + 1;
      v7 = v3 + 1;
      if ( !v5 )
        goto LABEL_15;
      v4 = *v7 - *v6;
      if ( *v7 == *v6 )
      {
        v8 = v5 - 1;
        v9 = v6 + 1;
        v10 = v7 + 1;
        if ( !v8 )
          goto LABEL_15;
        v4 = *v10 - *v9;
        if ( *v10 == *v9 )
        {
          v11 = v9 + 1;
          v12 = v10 + 1;
          if ( v8 == 1 )
            goto LABEL_15;
          v4 = *v12 - *v11;
          if ( *v12 == *v11 )
            goto LABEL_15;
        }
      }
    }
    v13 = 1;
    if ( v4 <= 0 )
      v13 = -1;
LABEL_16:
    if ( !v13 )
      break;
    ++result;
  }
  while ( result < 3u );
  return result;
}

//----- (10016B20) --------------------------------------------------------
char sub_10016B20()
{
  char v0; // al@1
  unsigned __int8 v1; // bl@2
  unsigned int v2; // ecx@3
  char *v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // ecx@8
  _BYTE *v7; // eax@8
  _BYTE *v8; // edx@8
  int v9; // ecx@10
  _BYTE *v10; // eax@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // eax@12
  _BYTE *v13; // edx@12
  signed int v14; // eax@14
  char result; // al@24
  char v16; // [sp+Fh] [bp-25h]@20
  char v17; // [sp+10h] [bp-24h]@1
  char v18; // [sp+1Bh] [bp-19h]@2
  char v19; // [sp+1Ch] [bp-18h]@2

  byte_101F03B4 = 1;
  v0 = (*(int (__cdecl **)(signed int, signed int, char *))dword_101EFA5C)(147, 12, &v17);
  byte_101F03B4 = 1;
  dword_10114A64 = 0;
  dword_10114A68 = 0;
  dword_10114A6C = 0;
  dword_10114A70 = 0;
  byte_10114A74 = 0;
  if ( !v0 )
    return (unsigned int)memset(dword_101EFB60, 0, 0x708u);
  sub_100168E0((int)&v19, &v18, 16, (int)&v19);
  v1 = 0;
  while ( 1 )
  {
    v2 = 10;
    v3 = &a006D0170[11 * v1];
    v4 = &v19;
    do
    {
      if ( *(_DWORD *)v4 != *(_DWORD *)v3 )
        goto LABEL_7;
      v2 -= 4;
      v3 += 4;
      v4 += 4;
    }
    while ( v2 >= 4 );
    if ( !v2 )
    {
LABEL_16:
      v14 = 0;
      goto LABEL_17;
    }
LABEL_7:
    v5 = (unsigned __int8)*v4 - (unsigned __int8)*v3;
    if ( (unsigned __int8)*v4 == (unsigned __int8)*v3 )
    {
      v6 = v2 - 1;
      v7 = v3 + 1;
      v8 = v4 + 1;
      if ( !v6 )
        goto LABEL_16;
      v5 = *v8 - *v7;
      if ( *v8 == *v7 )
      {
        v9 = v6 - 1;
        v10 = v7 + 1;
        v11 = v8 + 1;
        if ( !v9 )
          goto LABEL_16;
        v5 = *v11 - *v10;
        if ( *v11 == *v10 )
        {
          v12 = v10 + 1;
          v13 = v11 + 1;
          if ( v9 == 1 )
            goto LABEL_16;
          v5 = *v13 - *v12;
          if ( *v13 == *v12 )
            goto LABEL_16;
        }
      }
    }
    v14 = 1;
    if ( v5 <= 0 )
      v14 = -1;
LABEL_17:
    if ( !v14 )
      break;
    if ( ++v1 >= 3u )
      return (unsigned int)memset(dword_101EFB60, 0, 0x708u);
  }
  byte_101F03B4 = 0;
  sub_100166E0(&v16);
  if ( v16 != 101 )
  {
    byte_101F03B4 = 2;
    return (unsigned int)memset(dword_101EFB60, 0, 0x708u);
  }
  if ( byte_101F03B4 )
    return (unsigned int)memset(dword_101EFB60, 0, 0x708u);
  sub_10016760(&unk_101F0268, &byte_101F03AD);
  byte_101F03AC = byte_101F03AD - 1;
  if ( byte_101F03B4 )
    return (unsigned int)memset(dword_101EFB60, 0, 0x708u);
  result = sub_10016710(&unk_101F0269, &unk_101F026A);
  byte_101EFB54 = 0;
  if ( byte_101F03B4 )
    return (unsigned int)memset(dword_101EFB60, 0, 0x708u);
  return result;
}
// 10114A64: using guessed type int dword_10114A64;
// 10114A68: using guessed type int dword_10114A68;
// 10114A6C: using guessed type int dword_10114A6C;
// 10114A70: using guessed type int dword_10114A70;
// 10114A74: using guessed type char byte_10114A74;
// 101EFA5C: using guessed type int dword_101EFA5C;
// 101EFB54: using guessed type char byte_101EFB54;
// 101EFB60: using guessed type int dword_101EFB60[];
// 101F03AC: using guessed type char byte_101F03AC;
// 101F03AD: using guessed type char byte_101F03AD;
// 101F03B4: using guessed type char byte_101F03B4;

//----- (10016CE0) --------------------------------------------------------
int (__cdecl *(*sub_10016CE0())[2])(int, int)
{
  int (__cdecl *(*result)[2])(int, int); // eax@1
  unsigned int v1; // edi@2
  char *v2; // ecx@3
  unsigned int v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // eax@8
  _BYTE *v7; // ecx@8
  _BYTE *v8; // edx@8
  int v9; // eax@10
  _BYTE *v10; // ecx@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // ecx@12
  _BYTE *v13; // edx@12
  char v14; // [sp+0h] [bp-24h]@1
  char v15; // [sp+Bh] [bp-19h]@2
  char v16; // [sp+Ch] [bp-18h]@2

  dword_101EFA4C = (int)off_100A27C8;
  result = (int (__cdecl *(*)[2])(int, int))(*(int (__cdecl **)(signed int, signed int, char *))dword_101EFA5C)(
                                              147,
                                              12,
                                              &v14);
  if ( (_BYTE)result )
  {
    sub_100168E0((int)&v16, &v15, 16, (int)&v16);
    v1 = 0;
    do
    {
      v2 = (&off_1008108C)[8 * v1];
      v3 = strlen((&off_1008108C)[8 * v1]);
      v4 = &v16;
      if ( v3 < 4 )
      {
LABEL_6:
        if ( !v3 )
          goto LABEL_16;
      }
      else
      {
        while ( *(_DWORD *)v4 == *(_DWORD *)v2 )
        {
          v3 -= 4;
          v2 += 4;
          v4 += 4;
          if ( v3 < 4 )
            goto LABEL_6;
        }
      }
      v5 = (unsigned __int8)*v4 - (unsigned __int8)*v2;
      if ( (unsigned __int8)*v4 == (unsigned __int8)*v2 )
      {
        v6 = v3 - 1;
        v7 = v2 + 1;
        v8 = v4 + 1;
        if ( !v6
          || (v5 = *v8 - *v7, *v8 == *v7)
          && ((v9 = v6 - 1, v10 = v7 + 1, v11 = v8 + 1, !v9)
           || (v5 = *v11 - *v10, *v11 == *v10)
           && ((v12 = v10 + 1, v13 = v11 + 1, v9 == 1) || (v5 = *v13 - *v12, *v13 == *v12))) )
        {
LABEL_16:
          result = 0;
          goto LABEL_17;
        }
      }
      result = (int (__cdecl *(*)[2])(int, int))1;
      if ( v5 <= 0 )
        result = (int (__cdecl *(*)[2])(int, int))-1;
LABEL_17:
      if ( !result )
      {
        result = (&off_10081090)[v1];
        dword_101EFA4C = (int)(&off_10081090)[v1];
        return result;
      }
      ++v1;
    }
    while ( v1 < 3 );
  }
  return result;
}
// 1008108C: using guessed type char *off_1008108C;
// 10081090: using guessed type int (__cdecl *(*off_10081090)[2])(int, int);
// 100A27C8: using guessed type int (__cdecl *off_100A27C8[2])(int, int);
// 101EFA4C: using guessed type int dword_101EFA4C;
// 101EFA5C: using guessed type int dword_101EFA5C;

//----- (10016E10) --------------------------------------------------------
char __cdecl sub_10016E10(char a1)
{
  char result; // al@1

  result = sub_10025050();
  if ( result == 2 )
    result = byte_1008160C[8 * sub_10016EA0(&a1, 4u, (int)&unk_10081608, 8, 7, 7)];
  return result;
}

//----- (10016E40) --------------------------------------------------------
char __thiscall sub_10016E40(void *this)
{
  char v1; // al@1

  v1 = sub_100128C0(this);
  return sub_10016E10(v1);
}

//----- (10016EA0) --------------------------------------------------------
int __cdecl sub_10016EA0(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@6
  int v7; // ebx@6
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  _DWORD *v21; // esi@23
  unsigned int v22; // ecx@23
  _DWORD *v23; // edx@23
  int v24; // edi@27
  int v25; // ecx@28
  _BYTE *v26; // edx@28
  _BYTE *v27; // esi@28
  int v28; // ecx@30
  _BYTE *v29; // edx@30
  _BYTE *v30; // esi@30
  _BYTE *v31; // edx@32
  _BYTE *v32; // esi@32
  int v33; // edx@33
  signed int v34; // ecx@34
  int v35; // [sp+4h] [bp-4h]@6

  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && a5 > 0 )
  {
    result = a5 - 1;
    v7 = a3 + a4 * (a5 - 1);
    v35 = a5 - 1;
    if ( a5 - 1 > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v35;
        if ( v20 )
        {
          v7 -= a4;
          result = v35 - 1;
          v35 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a1;
    v22 = a2;
    v23 = (_DWORD *)v7;
    if ( a2 < 4 )
    {
LABEL_26:
      if ( !v22 )
        goto LABEL_36;
    }
    else
    {
      while ( *v21 == *v23 )
      {
        v22 -= 4;
        ++v23;
        ++v21;
        if ( v22 < 4 )
          goto LABEL_26;
      }
    }
    v24 = *(_BYTE *)v21 - *(_BYTE *)v23;
    if ( *(_BYTE *)v21 != *(_BYTE *)v23
      || (v25 = v22 - 1, v26 = (char *)v23 + 1, v27 = (char *)v21 + 1, v25)
      && ((v24 = *v27 - *v26, *v27 != *v26)
       || (v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, v28)
       && ((v24 = *v30 - *v29, *v30 != *v29)
        || (v31 = v29 + 1, v32 = v30 + 1, v28 != 1) && (v33 = *v31, v24 = *v32 - v33, *v32 != v33))) )
    {
      v34 = 1;
      if ( v24 <= 0 )
        v34 = -1;
LABEL_37:
      if ( !v34 )
        return result;
      return a6;
    }
LABEL_36:
    v34 = 0;
    goto LABEL_37;
  }
  return a6;
}

//----- (10017030) --------------------------------------------------------
bool __cdecl sub_10017030(float *a1)
{
  void *v1; // ecx@0
  float *v2; // edi@1
  unsigned int v3; // ebp@1
  char v4; // bl@1
  _DWORD *v5; // esi@1
  char v6; // al@3
  bool result; // al@6
  int v8; // [sp+10h] [bp-8h]@1
  float v9; // [sp+14h] [bp-4h]@3
  char v10; // [sp+1Ch] [bp+4h]@1

  v2 = a1;
  *a1 = 0.0;
  v3 = 0;
  v4 = 0;
  v8 = sub_1000EB30(v1);
  v10 = 0;
  v5 = &unk_10096268;
  do
  {
    if ( v8 & *v5 )
    {
      v6 = sub_10025330(v10, 0);
      if ( sub_100251D0(3, v6, &v9) )
      {
        ++v3;
        *v2 = *v2 + v9;
      }
    }
    ++v4;
    ++v5;
    v10 = v4;
  }
  while ( (unsigned __int8)v4 < 2u );
  result = v3 != 0;
  if ( v3 )
    *v2 = *v2 / (double)v3;
  return result;
}

//----- (100170D0) --------------------------------------------------------
int sub_100170D0()
{
  int result; // eax@1

  sub_10031C90(6361, (int)&unk_10114A9C, 4);
  result = sub_10031C90(6362, (int)&unk_10114AA0, 4);
  dword_10114AA4 = 1379255385;
  return result;
}
// 10114AA4: using guessed type int dword_10114AA4;

//----- (10017100) --------------------------------------------------------
int __cdecl sub_10017100(int a1)
{
  double v1; // ST0C_8@2
  double v2; // st6@4
  double v3; // st7@4
  double v4; // ST0C_8@7
  double v5; // rt2@8
  double v6; // st6@8
  double v7; // st7@8
  double v8; // st7@14
  double v9; // st7@18
  int result; // eax@18

  if ( a1 )
  {
    v1 = *(double *)a1;
    if ( (HIDWORD(v1) & 0x7FF00000) == 2146435072 || *(double *)a1 > 6.2831853071796 )
    {
      *(double *)a1 = 6.2831853071796;
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
    }
    else
    {
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
      if ( *(double *)a1 < -6.2831853071796 )
        *(double *)a1 = -6.2831853071796;
    }
    v4 = *(double *)(a1 + 8);
    if ( (HIDWORD(v4) & 0x7FF00000) == 2146435072 )
    {
      *(double *)(a1 + 8) = v3;
    }
    else
    {
      v5 = v2;
      v6 = v3;
      v7 = v5;
      if ( v6 < *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v6;
      }
      else if ( v7 > *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v7;
      }
    }
    if ( *(double *)a1 <= 1.5707963267949 )
    {
      if ( *(double *)a1 >= -1.5707963267949 )
      {
LABEL_18:
        v9 = *(double *)(a1 + 8);
        result = sub_10037870(v9);
        *(double *)(a1 + 8) = v9;
        return result;
      }
      *(double *)a1 = -3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    else
    {
      *(double *)a1 = 3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    *(double *)(a1 + 8) = v8;
    goto LABEL_18;
  }
  return result;
}

//----- (10017200) --------------------------------------------------------
signed int __cdecl sub_10017200(int a1, int a2)
{
  signed int result; // eax@2

  if ( a1 )
  {
    if ( (COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
      || (COERCE_UNSIGNED_INT(*(float *)(a1 + 4)) & 0x7F800000) == 2139095040
      || *(float *)a1 >= 1.570796370506287
      || *(float *)a1 < -1.570796370506287
      || *(float *)(a1 + 4) >= 3.141592741012573
      || *(float *)(a1 + 4) < -3.141592741012573 )
    {
      if ( a2 )
      {
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
      }
      result = 0;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (100172A0) --------------------------------------------------------
unsigned int __cdecl sub_100172A0(char *a1)
{
  return sub_100245A0(a1, -100, 100, 0, 0);
}

//----- (100172C0) --------------------------------------------------------
int __cdecl sub_100172C0(unsigned __int8 *a1)
{
  return sub_10024710(a1, 0, 2u, 0, 0);
}

//----- (100172E0) --------------------------------------------------------
int __cdecl sub_100172E0(_BYTE *a1)
{
  return sub_10024800(a1, 0x1CCF0u, 0x2171Eu, 0x2171Eu, 0);
}

//----- (10017300) --------------------------------------------------------
int __cdecl sub_10017300(unsigned __int8 *a1)
{
  return sub_10024710(a1, 0, 1u, 1u, 0);
}

//----- (10017320) --------------------------------------------------------
unsigned int __cdecl sub_10017320(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_10024460((_BYTE *)(a1 + 6), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_10024710((unsigned __int8 *)(a1 + 12), 0, 0xFFu, 0, a2) == 1 )
    v2 = 1;
  result = sub_10024460((_BYTE *)a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 2), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 9), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 3), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100245A0((char *)(a1 + 14), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024710((unsigned __int8 *)(a1 + 7), 0, 0x40u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 10), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 5), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 11), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024710((unsigned __int8 *)(a1 + 4), 0, 0x40u, 0x30u, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 1), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100245A0((char *)(a1 + 17), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 24), 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10017650) --------------------------------------------------------
unsigned int __cdecl sub_10017650(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_10024460((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 24), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 26), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100245A0((char *)(a1 + 10), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 31), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 28), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 17), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100245A0((char *)(a1 + 13), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100245A0((char *)(a1 + 5), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100245A0((char *)a1, -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100245A0((char *)(a1 + 1), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100245A0((char *)(a1 + 2), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100245A0((char *)(a1 + 3), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100245A0((char *)(a1 + 4), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100245A0((char *)(a1 + 12), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100245A0((char *)(a1 + 11), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100245A0((char *)(a1 + 7), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100245A0((char *)(a1 + 9), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024460((_BYTE *)(a1 + 25), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100245A0((char *)(a1 + 6), -31, 31, 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10017A90) --------------------------------------------------------
int __cdecl sub_10017A90(unsigned __int8 *a1)
{
  return sub_10024710(a1, 0, 7u, 7u, 0);
}

//----- (10017AB0) --------------------------------------------------------
int __cdecl sub_10017AB0(unsigned __int8 *a1)
{
  return sub_10024710(a1, 0, 0x7Fu, 0x7Fu, 0);
}

//----- (10017AD0) --------------------------------------------------------
int __cdecl sub_10017AD0(int a1)
{
  int result; // eax@1

  result = sub_10017A90((unsigned __int8 *)a1);
  if ( !result )
  {
    result = sub_10017A90((unsigned __int8 *)(a1 + 1));
    if ( !result )
      result = sub_10017AB0((unsigned __int8 *)(a1 + 2));
  }
  return result;
}

//----- (10017B00) --------------------------------------------------------
unsigned int __cdecl sub_10017B00(_BYTE *a1)
{
  return sub_100245F0(a1, -1, 5, -1, 0);
}

//----- (10017B20) --------------------------------------------------------
int __cdecl sub_10017B20(unsigned __int8 *a1)
{
  return sub_10024710(a1, 0, 5u, 0, 0);
}

//----- (10017B40) --------------------------------------------------------
int __cdecl sub_10017B40(unsigned __int8 *a1)
{
  return sub_10024710(a1, 0, 4u, 2u, 0);
}

//----- (10017B60) --------------------------------------------------------
int __cdecl sub_10017B60(_BYTE *a1)
{
  return sub_10024800(a1, 0, 2u, 0, 0);
}

//----- (10017B80) --------------------------------------------------------
int __cdecl sub_10017B80(int a1)
{
  return sub_100244B0(a1, 0.1, 4.0, COERCE_INT(1.5), 0);
}

//----- (10017BD0) --------------------------------------------------------
int __cdecl sub_10017BD0(unsigned __int8 *a1)
{
  int result; // eax@1

  result = sub_10017B80((int)(a1 + 4));
  if ( !result )
    result = sub_10017B40(a1);
  return result;
}

//----- (10017BF0) --------------------------------------------------------
int __cdecl sub_10017BF0(int a1)
{
  int result; // eax@1

  result = sub_10017B20((unsigned __int8 *)(a1 + 1));
  if ( !result )
  {
    result = sub_10017B20((unsigned __int8 *)(a1 + 2));
    if ( !result )
    {
      result = sub_10017B20((unsigned __int8 *)(a1 + 3));
      if ( !result )
      {
        result = sub_10025350((unsigned __int8 *)(a1 + 7));
        if ( !result )
        {
          result = sub_10024460((_BYTE *)(a1 + 5), 0, 0);
          if ( !result )
          {
            result = sub_10024460((_BYTE *)a1, 0, 0);
            if ( !result )
            {
              result = sub_10024460((_BYTE *)(a1 + 4), 0, 0);
              if ( !result )
                result = sub_10024460((_BYTE *)(a1 + 6), 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (10017C80) --------------------------------------------------------
unsigned int __cdecl sub_10017C80(int a1)
{
  unsigned int result; // eax@1

  result = sub_10017B00((_BYTE *)a1);
  if ( !result )
    result = sub_10017B00((_BYTE *)(a1 + 4));
  return result;
}

//----- (10017CA0) --------------------------------------------------------
signed int __cdecl sub_10017CA0(int a1)
{
  int v1; // esi@1
  signed int result; // eax@2
  signed int v3; // esi@4

  v1 = 0;
  while ( 1 )
  {
    result = sub_10024460((_BYTE *)(v1 + a1), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      v3 = 0;
      do
      {
        result = sub_10024460((_BYTE *)(a1 + v3 + 6), 0, 0);
        if ( result )
          break;
        ++v3;
      }
      while ( v3 < 6 );
      return result;
    }
  }
  return result;
}

//----- (10017CF0) --------------------------------------------------------
unsigned int __cdecl sub_10017CF0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10017B00((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10017B00((_BYTE *)(a1 + 4));
    if ( !result )
    {
      result = sub_10017B00((_BYTE *)(a1 + 8));
      if ( !result )
      {
        result = sub_10017B00((_BYTE *)(a1 + 12));
        if ( !result )
          result = sub_10024460((_BYTE *)(a1 + 16), 1, 0);
      }
    }
  }
  return result;
}

//----- (10017D50) --------------------------------------------------------
int __cdecl sub_10017D50(_BYTE *a1)
{
  return sub_10024800(a1, 0, 0x20u, 2u, 0);
}

//----- (10017D70) --------------------------------------------------------
unsigned int __cdecl sub_10017D70(_BYTE *a1)
{
  return sub_100245F0(a1, -1, 4, -1, 0);
}

//----- (10017D90) --------------------------------------------------------
int __cdecl sub_10017D90(unsigned __int8 *a1)
{
  return sub_10024710(a1, 0, 9u, 0, 0);
}

//----- (10017DB0) --------------------------------------------------------
int __cdecl sub_10017DB0(_BYTE *a1)
{
  return sub_10024800(a1, 0x81u, 0xFFu, 0xC0u, 0);
}

//----- (10017DD0) --------------------------------------------------------
signed int __cdecl sub_10017DD0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10024800(a1, 0, 0xFFFFFFFF, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10017E00) --------------------------------------------------------
int __cdecl sub_10017E00(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_10024760(a1, 0, 0xFFFu, 640, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10017E40) --------------------------------------------------------
signed int __cdecl sub_10017E40(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10024760(a1, 0, 0xFFFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10017E70) --------------------------------------------------------
int __cdecl sub_10017E70(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@3

  v2 = 0;
  if ( sub_10017DD0((_BYTE *)(a1 + 8), a2) == 1 )
    v2 = 1;
  result = sub_10017E00((_BYTE *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10017E00((_BYTE *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025470((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10017E00((_BYTE *)(a1 + 6), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10017F00) --------------------------------------------------------
int __cdecl sub_10017F00(int a1)
{
  int result; // eax@1

  result = sub_10024710((unsigned __int8 *)a1, 0, 0x78u, 0, 0);
  if ( !result )
    result = sub_10024710((unsigned __int8 *)(a1 + 1), 0, 0x78u, 0, 0);
  return result;
}

//----- (10017F30) --------------------------------------------------------
int __cdecl sub_10017F30(unsigned __int8 *a1)
{
  return sub_10024710(a1, 0, 3u, 1u, 0);
}

//----- (10017F50) --------------------------------------------------------
unsigned int __cdecl sub_10017F50(int a1)
{
  unsigned int result; // eax@1

  result = sub_100245F0((_BYTE *)a1, -1, 5, -1, 0);
  if ( !result )
    result = sub_100245F0((_BYTE *)(a1 + 4), -1, 5, -1, 0);
  return result;
}

//----- (10017F80) --------------------------------------------------------
int __cdecl sub_10017F80(int a1)
{
  int result; // eax@1

  result = sub_100244B0(a1, 0.0, 5.0, COERCE_INT(0.23), 0);
  if ( !result )
  {
    result = sub_100244B0(a1 + 4, -10.0, 10.0, COERCE_INT(0.0), 0);
    if ( !result )
    {
      result = sub_100244B0(a1 + 8, 0.0, 12.9, COERCE_INT(0.86000001), 0);
      if ( !result )
      {
        result = sub_100244B0(a1 + 12, 0.0, 5.0, COERCE_INT(0.23), 0);
        if ( !result )
          result = sub_100244B0(a1 + 16, -10.0, 10.0, COERCE_INT(0.0), 0);
      }
    }
  }
  return result;
}

//----- (10018070) --------------------------------------------------------
int __cdecl sub_10018070(int a1)
{
  int v1; // edi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_10024460((_BYTE *)(a1 + v1 + 44), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      result = sub_10024710((unsigned __int8 *)(a1 + 1), 0, 3u, 1u, 0);
      if ( !result )
      {
        result = sub_10017F50(a1 + 36);
        if ( !result )
        {
          result = sub_100244B0(a1 + 52, -9.9999996e24, 9.9999996e24, COERCE_INT(77.166664), 0);
          if ( !result )
          {
            result = sub_10017F80(a1 + 8);
            if ( !result )
            {
              result = sub_10017F50(a1 + 28);
              if ( !result )
              {
                result = sub_10024760((_BYTE *)(a1 + 2), 0x1F4u, 0x800u, 600, 0);
                if ( !result )
                {
                  result = sub_100172C0((unsigned __int8 *)(a1 + 50));
                  if ( !result )
                  {
                    result = sub_10017F00(a1 + 57);
                    if ( !result )
                    {
                      result = sub_10024460((_BYTE *)(a1 + 56), 0, 0);
                      if ( !result )
                        result = sub_10017F30((unsigned __int8 *)(a1 + 51));
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
  }
  return result;
}

//----- (10018180) --------------------------------------------------------
signed int __cdecl sub_10018180(unsigned __int8 *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10024710(a1, 0, 0xFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (100181B0) --------------------------------------------------------
int __cdecl sub_100181B0(unsigned __int8 *a1)
{
  return sub_10024710(a1, 0, 0x64u, 0x64u, 0);
}

//----- (10018210) --------------------------------------------------------
int __cdecl sub_10018210(int a1)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_10024460((_BYTE *)(v1 + a1 + 4), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 3 )
      return sub_100181B0((unsigned __int8 *)(a1 + 10));
  }
  return result;
}

//----- (10018220) --------------------------------------------------------
signed int __cdecl sub_10018220(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10024800(a1, 0, 0xFFFFFFFF, 0xFFFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10018250) --------------------------------------------------------
int __cdecl sub_10018250(int a1, int a2)
{
  signed int v2; // ebp@1
  unsigned __int8 v3; // bl@1
  int result; // eax@3

  v2 = 0;
  v3 = 0;
  do
  {
    switch ( v3 )
    {
      case 4u:
      case 5u:
      case 6u:
      case 9u:
      case 0xAu:
        result = sub_10024710((unsigned __int8 *)(a1 + v3), 0, 0x3Fu, 0, a2);
        break;
      default:
        result = sub_10024710((unsigned __int8 *)(a1 + v3), 0, 0xFFu, 0xFFu, a2);
        break;
    }
    if ( result == 1 )
    {
      v2 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v3;
  }
  while ( v3 < 0xDu );
  return v2;
}

//----- (100182D0) --------------------------------------------------------
unsigned int __cdecl sub_100182D0(int a1)
{
  unsigned int result; // eax@1

  result = sub_100172A0((char *)(a1 + 3));
  if ( !result )
  {
    result = sub_100172A0((char *)(a1 + 2));
    if ( !result )
    {
      result = sub_100172A0((char *)a1);
      if ( !result )
        result = sub_100172A0((char *)(a1 + 1));
    }
  }
  return result;
}

//----- (10018310) --------------------------------------------------------
unsigned int __cdecl sub_10018310(int a1)
{
  signed int v1; // esi@1
  int v2; // edi@1
  unsigned int result; // eax@2

  v1 = 0;
  v2 = a1;
  while ( 1 )
  {
    result = sub_100182D0(v2);
    if ( result )
      break;
    ++v1;
    v2 += 4;
    if ( v1 >= 3 )
    {
      result = sub_100172C0((unsigned __int8 *)(a1 + 12));
      if ( !result )
        result = sub_10017300((unsigned __int8 *)(a1 + 13));
      return result;
    }
  }
  return result;
}

//----- (10018360) --------------------------------------------------------
int __cdecl sub_10018360(int a1)
{
  int result; // eax@1

  result = sub_100172E0((_BYTE *)(a1 + 4));
  if ( !result )
    result = sub_10024760((_BYTE *)a1, 0, 0x3FFFu, 0x3FFF, 0);
  return result;
}

//----- (10018390) --------------------------------------------------------
int __cdecl sub_10018390(int a1)
{
  int result; // eax@1

  result = sub_10017B60((_BYTE *)a1);
  if ( !result )
    result = sub_10017DB0((_BYTE *)(a1 + 4));
  return result;
}

//----- (100183C0) --------------------------------------------------------
unsigned int __cdecl sub_100183C0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10017B00((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10017B00((_BYTE *)(a1 + 4));
    if ( !result )
      result = sub_10017D70((_BYTE *)(a1 + 8));
  }
  return result;
}

//----- (100183F0) --------------------------------------------------------
unsigned int __cdecl sub_100183F0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10017B00((_BYTE *)a1);
  if ( !result )
    result = sub_10017D90((unsigned __int8 *)(a1 + 4));
  return result;
}

//----- (10018410) --------------------------------------------------------
unsigned int __cdecl sub_10018410(int a1)
{
  unsigned int result; // eax@1

  result = sub_10017B00((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10024710((unsigned __int8 *)(a1 + 8), 0, 0x1Eu, 0x1Eu, 0);
    if ( !result )
      result = sub_10017D70((_BYTE *)(a1 + 4));
  }
  return result;
}

//----- (10018450) --------------------------------------------------------
void __cdecl __noreturn sub_10018450(int a1)
{
  exit(a1 + 4);
}

//----- (100185C0) --------------------------------------------------------
signed int __cdecl sub_100185C0(int a1, int a2)
{
  signed int v2; // ebx@1
  bool v3; // zf@5
  signed int result; // eax@5

  v2 = 0;
  if ( sub_10018180((unsigned __int8 *)a1, a2) == 1 )
    v2 = 1;
  if ( sub_10017E40((_BYTE *)(a1 + 2), a2) == 1 )
    v2 = 1;
  v3 = sub_10018180((unsigned __int8 *)(a1 + 1), a2) == 1;
  result = 1;
  if ( !v3 )
    result = v2;
  return result;
}

//----- (10018620) --------------------------------------------------------
signed int __usercall sub_10018620@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  signed int v3; // ebx@1
  char v4; // al@5
  signed int result; // eax@8
  int v6; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  if ( sub_100185C0(a1, v6) == 1 )
    v3 = 1;
  if ( a2 == 2 )
  {
    *(_BYTE *)(v2 + 1) = 40;
    v3 = 1;
  }
  v4 = *(_BYTE *)(v2 + 1);
  if ( v4 == 26 || v4 == 12 )
  {
    result = sub_10024710((unsigned __int8 *)(v2 + 4), 0x20u, 0x20u, 0x20u, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    result = sub_10024460((_BYTE *)(v2 + 37), 0, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    if ( *(_BYTE *)(v2 + 1) == 26 )
      result = sub_10017650(v2 + 5, a2);
    else
      result = sub_10017320(v2 + 5, a2);
    if ( result != 1 )
    {
      if ( result )
        return result;
      goto LABEL_25;
    }
    return 1;
  }
  if ( v4 != 40 )
  {
    if ( a2 != 1 )
      return -4;
    *(_BYTE *)(v2 + 1) = 40;
    return 1;
  }
  result = sub_10018220((_BYTE *)(v2 + 4), a2);
  if ( result != 1 )
LABEL_25:
    result = v3;
  return result;
}

//----- (100186F0) --------------------------------------------------------
signed int __cdecl sub_100186F0(int a1)
{
  return sub_10018620(a1, 0);
}

//----- (10018700) --------------------------------------------------------
char __cdecl sub_10018700(char a1)
{
  char result; // al@3

  if ( a1 == 6 )
  {
    result = 0;
  }
  else if ( a1 == 7 )
  {
    result = 1;
  }
  else
  {
    sub_1000D740("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 294, 0, 0);
    result = 2;
  }
  return result;
}

//----- (10018740) --------------------------------------------------------
int __cdecl sub_10018740(char *a1, char a2)
{
  signed int v2; // eax@2
  int result; // eax@4
  int v4; // [sp+8h] [bp-ECh]@1
  char v5; // [sp+24h] [bp-D0h]@4

  v4 = 0;
  if ( a2 == 1 )
    v2 = 2;
  else
    v2 = a2 == 2;
  result = j_HWM_pvg_rgn_get_info(v2, &v4);
  qmemcpy(a1, &v5, 0x74u);
  return result;
}
// 100328D0: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (100187B0) --------------------------------------------------------
bool __cdecl sub_100187B0(int a1, void *a2)
{
  void *v2; // ecx@0
  char v3; // si@1
  char v4; // bl@1
  int v5; // esi@4
  bool result; // al@7

  v3 = sub_1000EF10(v2);
  v4 = 0;
  do
  {
    if ( (_BYTE)a1 == (char)off_10098648[(unsigned __int8)v4](v3) )
    {
      sub_10018740((char *)a2, v4);
      return 1;
    }
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  v5 = (unsigned __int16)sub_10018CB0(a1);
  if ( (unsigned __int16)v5 >= (unsigned __int16)sub_10013210(2) )
    result = 0;
  else
    result = sub_10013EB0(2, v5, a2) == 1 && !sub_10025410(a2);
  return result;
}
// 10098648: using guessed type int (__cdecl *off_10098648[3])(char);

//----- (10018870) --------------------------------------------------------
char __cdecl sub_10018870(int a1, bool *a2)
{
  char result; // al@3
  char v3; // [sp+8h] [bp-78h]@2
  int v4; // [sp+78h] [bp-8h]@3

  switch ( (unsigned __int8)a1 )
  {
    case 1u:
    case 4u:
    case 7u:
    case 0xAu:
      if ( sub_100187B0(a1, &v3) )
      {
        *a2 = (v4 & 1) == 1;
        result = 1;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      *a2 = sub_10018C90(a1) != 67;
      result = 1;
      break;
  }
  return result;
}

//----- (10018930) --------------------------------------------------------
char __cdecl sub_10018930(char *a1)
{
  int v1; // ecx@0
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  sub_1000EA50(13, (char *)&v3 + 3);
  sub_1000EA50(12, a1);
  return BYTE3(v3);
}

//----- (10018960) --------------------------------------------------------
unsigned int __usercall sub_10018960@<eax>(int a1@<eax>)
{
  int v1; // ebx@1
  int v2; // ebp@1
  char v3; // dl@1
  int v4; // ecx@5
  int v5; // esi@5
  float *v6; // edx@6
  _BYTE *v7; // edx@11
  char *v8; // ecx@11
  char v9; // al@12
  int v10; // eax@14
  int v11; // edi@16
  char *v12; // eax@16
  long double v13; // ST28_8@19
  long double v14; // st6@19
  int v15; // edi@19
  char *v16; // eax@21
  _BYTE *v17; // esi@21
  char v18; // cl@22
  unsigned int result; // eax@23
  _BYTE *v20; // edi@23
  char v21; // cl@24
  const void *v22; // ebx@25
  char *v23; // eax@28
  char v24; // cl@29
  char v25; // cl@31
  char *v26; // eax@34
  _BYTE *v27; // edx@34
  char v28; // cl@35
  _BYTE *v29; // edi@36
  char v30; // cl@37
  __int32 v31; // [sp+18h] [bp-8h]@17

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 32);
  v3 = 0;
  if ( *(_BYTE *)v2 <= 1u )
    v3 = 1;
  if ( 9.8999998e24 == *(float *)a1 )
    goto LABEL_10;
  if ( !v3 )
  {
    v4 = *(_BYTE *)v2 - 1;
    v5 = 0;
    if ( v4 > 0 )
    {
      v6 = (float *)(v2 + 44);
      while ( *(v6 - 5) > (double)*(float *)a1 || *v6 <= (double)*(float *)a1 )
      {
        ++v5;
        v6 += 5;
        if ( v5 >= v4 )
          goto LABEL_10;
      }
      v10 = v5 + 1;
      if ( *(float *)v1 >= 0.0 )
        v10 = v5;
      v11 = 20 * v10;
      sprintf(*(char **)(v1 + 36), (const char *)(20 * v10 + v2 + 28), *(float *)v1);
      v12 = strrchr((const char *)(v11 + *(_DWORD *)(v1 + 32) + 28), 46);
      if ( v12 )
        v31 = j__atol(v12 + 1);
      else
        v31 = 0;
      v13 = pow(10.0, (double)v31);
      v14 = atof((const char *)*(_DWORD *)(v1 + 36)) * v13;
      v15 = *(_DWORD *)(v1 + 32);
      if ( (signed int)v14 != (signed int)(v13 * *(float *)(v15 + 20 * v5 + 24)) )
        ++v5;
      sprintf(*(char **)(v1 + 36), (const char *)(v15 + 20 * v5 + 28), *(float *)v1);
      v16 = (char *)(*(_DWORD *)(v1 + 32) + 11);
      v17 = (_BYTE *)(*(_DWORD *)(v1 + 32) + 11);
      do
        v18 = *v16++;
      while ( v18 );
      result = v16 - v17;
      v20 = (_BYTE *)(*(_DWORD *)(v1 + 36) - 1);
      do
        v21 = (v20++)[1];
      while ( v21 );
      goto LABEL_25;
    }
LABEL_10:
    if ( *(_DWORD *)(a1 + 40) )
    {
      memset(*(void **)(a1 + 36), 95, *(_DWORD *)(a1 + 40));
      *(_BYTE *)(*(_DWORD *)(v1 + 40) + *(_DWORD *)(v1 + 36)) = 0;
    }
    else
    {
      v7 = *(_BYTE **)(a1 + 36);
      v8 = (char *)(v2 + 1);
      do
      {
        v9 = *v8;
        *v7++ = *v8++;
      }
      while ( v9 );
    }
    v26 = (char *)(*(_DWORD *)(v1 + 32) + 11);
    v27 = (_BYTE *)(*(_DWORD *)(v1 + 32) + 11);
    do
      v28 = *v26++;
    while ( v28 );
    result = v26 - v27;
    v29 = (_BYTE *)(*(_DWORD *)(v1 + 36) - 1);
    do
      v30 = (v29++)[1];
    while ( v30 );
    qmemcpy(v29, v27, result);
    return result;
  }
  sprintf(*(char **)(a1 + 36), (const char *)(v2 + 28), *(float *)a1);
  v23 = (char *)(*(_DWORD *)(v1 + 32) + 11);
  v17 = (_BYTE *)(*(_DWORD *)(v1 + 32) + 11);
  do
    v24 = *v23++;
  while ( v24 );
  result = v23 - v17;
  v20 = (_BYTE *)(*(_DWORD *)(v1 + 36) - 1);
  do
    v25 = (v20++)[1];
  while ( v25 );
LABEL_25:
  qmemcpy(v20, v17, result);
  v22 = *(const void **)(v1 + 36);
  if ( !memcmp(v22, &unk_1007F038, 3u) )
    *(_WORD *)v22 = 48;
  return result;
}

//----- (10018BA0) --------------------------------------------------------
char __cdecl sub_10018BA0(int a1, int a2, int a3, int a4, __int16 *a5)
{
  int v5; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  signed int v8; // ecx@1
  signed int v9; // edx@1
  __int16 v10; // ax@1
  float v12; // [sp+4h] [bp-24h]@1
  float v13; // [sp+8h] [bp-20h]@1
  int v14; // [sp+Ch] [bp-1Ch]@1
  float v15; // [sp+10h] [bp-18h]@1
  int v16; // [sp+14h] [bp-14h]@1
  int v17; // [sp+18h] [bp-10h]@1
  float v18; // [sp+1Ch] [bp-Ch]@1
  float v19; // [sp+20h] [bp-8h]@1
  float v20; // [sp+24h] [bp-4h]@1

  v5 = *(_DWORD *)(a4 + 8);
  v6 = *(_DWORD *)(a4 + 4);
  v15 = *(float *)(a4 + 12);
  v7 = *(_DWORD *)(a4 + 20);
  v18 = *(float *)(a4 + 24);
  v16 = v5;
  v19 = *(float *)(a4 + 28);
  v17 = v6;
  v8 = *(_WORD *)a3;
  v20 = *(float *)(a4 + 16);
  v14 = v7;
  v9 = *(_WORD *)(a3 + 2);
  v12 = (double)v8;
  v10 = *a5;
  v13 = (double)v9;
  if ( v10 == -32648 || v10 == -32734 || v10 == -32704 )
    sub_10018960(a4);
  if ( (unsigned __int16)*a5 != 32802 )
  {
    if ( (unsigned __int16)*a5 == 32832 )
    {
      sub_1000FB80(a1, *(_DWORD *)(a4 + 36), (int)&v12);
      return 2;
    }
    if ( (unsigned __int16)*a5 != 32888 )
      return 1;
  }
  sub_1000FFB0(a1, *(_DWORD *)(a4 + 36), (int)&v12);
  return 2;
}

//----- (10018C80) --------------------------------------------------------
signed int __fastcall sub_10018C80(unsigned __int8 a1)
{
  signed int result; // eax@1

  result = 176;
  if ( a1 < 0xB0u )
    result = a1;
  return result;
}

//----- (10018C90) --------------------------------------------------------
char __cdecl sub_10018C90(unsigned __int8 a1)
{
  return byte_1009913C[6 * sub_10018C80(a1)];
}

//----- (10018CB0) --------------------------------------------------------
__int16 __cdecl sub_10018CB0(unsigned __int8 a1)
{
  return word_10099138[3 * sub_10018C80(a1)];
}
// 10099138: using guessed type __int16 word_10099138[];

//----- (10018CD0) --------------------------------------------------------
char *__cdecl sub_10018CD0(char **a1)
{
  char *v1; // edx@1
  int v2; // edi@1
  char *result; // eax@1
  char *v4; // eax@3
  char v5; // cl@4
  int v6; // eax@5
  char v7; // cl@7

  v1 = *a1;
  v2 = 0;
  result = (char *)&unk_1005E69C;
  if ( *a1 && *v1 )
  {
    v4 = *a1;
    do
      v5 = *v4++;
    while ( v5 );
    v6 = v4 - (v1 + 1) - 1;
    do
    {
      if ( v6 < 0 )
        break;
      v7 = v1[v6];
      if ( v7 == 47 || v7 == 92 )
        v2 = v6 + 1;
      --v6;
    }
    while ( !v2 );
    result = &v1[v2];
  }
  return result;
}

//----- (10018D20) --------------------------------------------------------
int sub_10018D20()
{
  int v0; // esi@1
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@2

  v0 = 0;
  v1 = sub_100318A0();
  result = 0;
  while ( 1 )
  {
    v3 = dword_10114AC4[result];
    if ( v3 == v1 )
      break;
    if ( !v0 && v3 == -1 )
      v0 = result;
    if ( (unsigned int)++result >= 5 )
    {
      dword_10114AC4[v0] = v1;
      return v0;
    }
  }
  return result;
}
// 10114AC4: using guessed type int dword_10114AC4[];

//----- (10018D60) --------------------------------------------------------
int __cdecl sub_10018D60(_BYTE *a1, int a2)
{
  int result; // eax@3
  int v3; // esi@3
  _BYTE *v4; // ecx@4
  char v5; // dl@5

  if ( a1 )
  {
    if ( a2 )
    {
      result = 0;
      v3 = 0;
      if ( *a1 )
      {
        v4 = a1;
        do
        {
          v5 = v4[a2 - (_DWORD)a1];
          if ( !v5 )
            break;
          if ( *v4 != v5 )
          {
            result = a1[v3] - *(_BYTE *)(v3 + a2);
            if ( a1[v3] != *(_BYTE *)(v3 + a2) )
              return result;
            break;
          }
          ++v4;
          ++v3;
        }
        while ( *v4 );
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(v3 + a2) )
      {
        result = -1;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10018DD0) --------------------------------------------------------
signed int __cdecl sub_10018DD0(_BYTE *a1, int a2)
{
  _BYTE *v2; // esi@1
  int v3; // ebp@1
  int v4; // ebx@4
  int v5; // edi@6
  int v6; // eax@6
  signed int result; // eax@11
  int v8; // [sp+8h] [bp-4h]@3

  v2 = a1;
  v3 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v8 = 0;
      if ( *a1 )
      {
        v4 = a2 - (_DWORD)a1;
        while ( v2[v4] )
        {
          v5 = tolower(*v2);
          v6 = tolower(v2[v4]);
          if ( v5 != v6 )
          {
            v8 = v5 - v6;
            if ( v5 != v6 )
              goto LABEL_16;
            break;
          }
          ++v2;
          ++v3;
          if ( !*v2 )
            break;
        }
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(a2 + v3) )
      {
        result = -1;
      }
      else
      {
LABEL_16:
        result = v8;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10018E70) --------------------------------------------------------
int __usercall sub_10018E70@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>)
{
  int result; // eax@5

  if ( a1 && *a1 )
  {
    if ( a2 && *a2 )
      result = 3 - (sub_10018DD0(a2, (int)a1) != 0);
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10018EA0) --------------------------------------------------------
signed int __usercall sub_10018EA0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5)
{
  int v5; // ebp@1
  int v6; // edi@1
  signed int result; // eax@2
  const char *v8; // [sp-8h] [bp-18h]@11
  int v9; // [sp-4h] [bp-14h]@11
  int v10; // [sp+8h] [bp-8h]@14
  int v11; // [sp+Ch] [bp-4h]@17
  signed int v12; // [sp+14h] [bp+4h]@3

  v5 = a4;
  v6 = 0;
  *(_DWORD *)a4 = a1;
  switch ( a1 )
  {
    case 0:
      sprintf(a5, "Too many arguments for command");
      result = 8;
      break;
    case 1:
      v12 = 9;
      while ( sub_10018DD0((_BYTE *)a3, (int)(&off_10099A80)[8 * v6]) )
      {
        if ( (unsigned int)++v6 >= 0xD )
        {
          sprintf(a5, "Error converting '%s' to a boolean", a3);
          goto LABEL_25;
        }
      }
      ++*a2;
      result = 0;
      *(_BYTE *)(v5 + 4) = byte_10099A84[8 * v6];
      break;
    case 2:
      if ( !*(_BYTE *)a3 || *(_BYTE *)(a3 + 1) )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a char";
        goto LABEL_12;
      }
      *(_BYTE *)(a4 + 4) = *(_BYTE *)a3;
      result = 0;
      break;
    case 3:
      if ( sub_1003A3B9(a3, (int)"%ld", (unsigned int)&v10) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a sint32";
        goto LABEL_12;
      }
      *(_DWORD *)(a4 + 4) = v10;
      ++*a2;
      result = 0;
      break;
    case 4:
      if ( sub_1003A3B9(a3, (int)"%lu", (unsigned int)&v11) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a uint32";
LABEL_12:
        sprintf(a5, v8, v9);
        goto LABEL_13;
      }
      *(_DWORD *)(a4 + 4) = v11;
      ++*a2;
      result = 0;
      break;
    case 6:
      if ( sub_1003A3B9(a3, (int)"%f", a4 + 4) == 1 )
        goto LABEL_23;
      sprintf(a5, "Error converting '%s' to a float", a3);
LABEL_13:
      result = 9;
      break;
    case 5:
      strncpy((char *)(a4 + 4), (const char *)a3, 0x50u);
LABEL_23:
      ++*a2;
      result = 0;
      break;
    default:
      v12 = 9;
      *(_DWORD *)v5 = 0;
      sprintf(a5, "Command definition error: Unsupported argument type (%d)", a1);
LABEL_25:
      result = v12;
      break;
  }
  return result;
}
// 10099A80: using guessed type char *off_10099A80;

//----- (10019070) --------------------------------------------------------
char *__usercall sub_10019070@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>)
{
  if ( a2 )
  {
    if ( (_BYTE)result && *(_BYTE *)a3 )
    {
      if ( *a2 )
      {
        strncat((char *)a3, " ", 0x100u);
        result = strncat((char *)a3, a2, 0x100u);
        *(_BYTE *)(a3 + 255) = 0;
        return result;
      }
    }
    else
    {
      result = strncpy((char *)a3, a2, 0x100u);
    }
    *(_BYTE *)(a3 + 255) = 0;
  }
  else if ( !(_BYTE)result )
  {
    *(_BYTE *)a3 = 0;
  }
  return result;
}

//----- (100190D0) --------------------------------------------------------
int __usercall sub_100190D0@<eax>(int a1@<esi>, int a2, _DWORD *a3)
{
  unsigned int v3; // edi@4
  int v4; // ebx@5
  int v5; // eax@6
  int result; // eax@9
  int v7; // ecx@10

  if ( a1 && *(_DWORD *)(a1 + 8) && *(_BYTE *)(80 * *a3 + a2) )
  {
    v3 = 0;
    if ( *(_DWORD *)(a1 + 12) <= 0u )
    {
      result = 0;
    }
    else
    {
      v4 = 0;
      while ( 1 )
      {
        v5 = v4 + *(_DWORD *)(a1 + 8);
        if ( *(_DWORD *)(v5 + 12) < 2u && !sub_10018DD0((_BYTE *)(a2 + 80 * *a3), *(_DWORD *)v5) )
          break;
        ++v3;
        v4 += 40;
        if ( v3 >= *(_DWORD *)(a1 + 12) )
          return 0;
      }
      v7 = *(_DWORD *)(a1 + 8);
      ++*a3;
      result = v7 + 40 * v3;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10019160) --------------------------------------------------------
int __usercall sub_10019160@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4)
{
  int v4; // edi@1
  unsigned int v5; // ebp@1
  int v6; // esi@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  do
  {
    if ( v5 >= a3 )
      break;
    if ( *(_DWORD *)(v6 + 12) >= 2u && sub_10018E70(*(_BYTE **)v6, (_BYTE *)(a4 + 80 * *a2)) == 3 )
    {
      ++*a2;
      v4 = v6;
    }
    ++v5;
    v6 += 40;
  }
  while ( !v4 );
  return v4;
}

//----- (100191B0) --------------------------------------------------------
char **__usercall sub_100191B0@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3)
{
  char **result; // eax@1
  int v4; // edi@1
  int (**v5)(void); // eax@2
  char **v6; // eax@3
  char **v7; // esi@3
  char *v8; // eax@3

  result = 0;
  v4 = 0;
  if ( *a1 )
  {
    v5 = a1;
    while ( 1 )
    {
      v6 = (char **)(*v5)();
      v7 = v6;
      v8 = sub_10018CD0(v6);
      if ( !sub_10018DD0((_BYTE *)(a2 + 80 * *a3), (int)v8) )
        break;
      v5 = &a1[++v4];
      if ( !a1[v4] )
        return 0;
    }
    ++*a3;
    result = v7;
  }
  return result;
}

//----- (10019210) --------------------------------------------------------
const char *__usercall sub_10019210@<eax>(int a1@<eax>)
{
  const char *result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
      result = "Group";
    else
      result = "Command";
  }
  else
  {
    result = "Case";
  }
  return result;
}

//----- (10019230) --------------------------------------------------------
int __usercall sub_10019230@<eax>(unsigned int a1@<ebx>)
{
  int (**v1)(void); // esi@1
  unsigned int v2; // edi@1
  int result; // eax@4

  v1 = (int (**)(void))dword_10114AB0[sub_10018D20()];
  v2 = 0;
  if ( a1 )
  {
    while ( v1 && *v1 )
    {
      result = (*v1)();
      ++v2;
      ++v1;
      if ( v2 >= a1 )
        return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10114AB0: using guessed type int dword_10114AB0[];

//----- (10019270) --------------------------------------------------------
int __usercall sub_10019270@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5)
{
  signed int *v5; // ebx@1
  int result; // eax@1
  _DWORD *v7; // edi@2
  int *v8; // ebp@2
  _BYTE *v9; // esi@4
  signed int v10; // ebx@9
  signed int v11; // [sp+8h] [bp-4h]@2

  v5 = a1;
  result = 0;
  if ( a3 )
  {
    v7 = a2;
    v8 = (int *)(a3 + 16);
    v11 = 5;
    do
    {
      if ( result || (v9 = (_BYTE *)(80 * *v5 + a4), !*v9) )
        *v7 = 0;
      else
        result = sub_10018EA0(*v8, v5, (int)v9, (int)v7, a5);
      ++v8;
      v7 += 21;
      --v11;
    }
    while ( v11 );
    if ( !result )
    {
      v10 = *v5;
      if ( v10 < 5 )
      {
        if ( *(_DWORD *)(a3 + 4 * v10 + 16) )
        {
          sprintf(a5, "Missing required command argument");
          result = 7;
        }
      }
    }
  }
  return result;
}

//----- (10019300) --------------------------------------------------------
int __usercall sub_10019300@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4)
{
  int v4; // ebx@1
  signed int v5; // edx@1
  _BYTE *v6; // edi@1
  signed int v7; // ebp@1
  signed int v8; // ecx@1
  int v9; // ecx@3
  char v10; // al@4
  signed int v11; // edi@21
  int result; // eax@27
  char v13; // [sp+Fh] [bp-9h]@1
  signed int v14; // [sp+10h] [bp-8h]@1
  int v15; // [sp+14h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  v14 = 3;
  v15 = 0;
  v7 = 0;
  v13 = 0;
  *a2 = 0;
  v8 = 9;
  do
  {
    *a1 = 0;
    a1 += 80;
    --v8;
  }
  while ( v8 );
  v9 = a3;
  if ( !*(_BYTE *)a3 )
    return 3;
  while ( 1 )
  {
    v10 = *(_BYTE *)(v4 + v9);
    if ( v13 )
    {
      if ( v13 != v10 )
        goto LABEL_15;
      v13 = 0;
LABEL_18:
      v9 = a3;
      goto LABEL_19;
    }
    if ( v10 != 34 && v10 != 39 )
      break;
    v13 = *(_BYTE *)(v4 + v9);
LABEL_19:
    if ( !*(_BYTE *)(++v4 + v9) )
      goto LABEL_23;
  }
  if ( v10 == 32 || v10 == 9 )
  {
    if ( v7 )
    {
      ++*a2;
      v7 = 0;
      v5 = 0;
    }
    v15 = v4;
    goto LABEL_19;
  }
LABEL_15:
  if ( *a2 >= 8 )
  {
    v11 = 5;
    sprintf(a4, "Too many parameters. Maximum of %d parameters supported.", 8);
    goto LABEL_24;
  }
  if ( v5 < 80 )
  {
    *(&v6[80 * *a2] + v5) = v10;
    v7 = 1;
    ++v5;
    v14 = 0;
    *(&v6[80 * *a2] + v5) = 0;
    goto LABEL_18;
  }
  v14 = 6;
  sprintf(a4, "Parameter too long (starting at %s). Maximum parameter length supported is %d.", v15 + a3 + 1, 80);
LABEL_23:
  v11 = v14;
LABEL_24:
  if ( v7 )
  {
    if ( !v13 )
    {
      ++*a2;
      goto LABEL_27;
    }
    sprintf(a4, "Parameter %d missing closing quote", *a2);
    result = 6;
  }
  else
  {
LABEL_27:
    result = v11;
  }
  return result;
}

//----- (10019450) --------------------------------------------------------
int __usercall sub_10019450@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>)
{
  _DWORD *v3; // edi@1
  int result; // eax@1
  int v5; // ecx@2
  int v6; // eax@4
  int v7; // edi@4
  int v8; // edi@7

  v3 = a1;
  result = 0;
  if ( a3 )
  {
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        sub_1001B1A0(5, *(_DWORD *)a3);
        v6 = (*(int (**)(void))(a3 + 8))();
        sub_10019D30(v3, v6, 0);
        v7 = -*v3;
        sub_1001B1A0(9, *(_DWORD *)a3);
        result = v7;
      }
    }
    else
    {
      sub_1001B1A0(6, *(_DWORD *)a3);
      if ( a2 )
        a2(5, &unk_10099738);
      sub_10025660(a3);
      v8 = -*v3;
      if ( a2 )
        a2(6, &unk_10099738);
      sub_1001B1A0(8, *(_DWORD *)a3);
      result = v8;
    }
  }
  return result;
}

//----- (100194F0) --------------------------------------------------------
int __usercall sub_100194F0@<eax>(int result@<eax>)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_BYTE *)(result + 33) = 0;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 24) = 1;
  *(_BYTE *)(result + 32) = 1;
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 52) = 0;
  return result;
}

//----- (10019530) --------------------------------------------------------
char *__cdecl sub_10019530(int a1, char *a2, int a3, const char *a4)
{
  const char *v4; // ecx@0
  const char *v5; // ebx@1
  char *v6; // eax@1
  char *v7; // ecx@1
  char *result; // eax@3
  char *v9; // eax@5
  const char *v10; // edi@5
  const char **v11; // ebx@8
  char *v12; // eax@10
  const char *v13; // edi@10
  char **v14; // ebp@10
  const char *v15; // edi@12
  char *v16; // [sp+10h] [bp-624h]@8
  signed int v17; // [sp+14h] [bp-620h]@10
  int v18[6]; // [sp+18h] [bp-61Ch]@2
  char v19; // [sp+30h] [bp-604h]@1
  char v20; // [sp+130h] [bp-504h]@5
  char v21; // [sp+230h] [bp-404h]@7
  char v22; // [sp+330h] [bp-304h]@10
  char v23; // [sp+430h] [bp-204h]@10
  char v24; // [sp+530h] [bp-104h]@10

  v5 = v4;
  v6 = 0;
  v7 = &v19;
  do
  {
    v18[(signed int)v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( (unsigned int)v6 < 6 );
  LOBYTE(v6) = 0;
  result = sub_10019070(v6, "command", (int)&v19);
  if ( a3 )
  {
    LOBYTE(result) = 0;
    if ( a4 )
    {
      v9 = sub_10019070(result, a4, (int)&v20);
      v10 = v5;
    }
    else
    {
      v9 = sub_10019070(result, v5, (int)&v20);
      v10 = (const char *)&unk_1005E69C;
    }
    LOBYTE(v9) = 0;
    sub_10019070(v9, v10, (int)&v21);
    result = a2;
    if ( a2 )
    {
      v11 = (const char **)(a1 + 36);
      v16 = a2;
      do
      {
        if ( (unsigned int)*(v11 - 6) >= 2 )
        {
          LOBYTE(result) = 0;
          v12 = sub_10019070(result, *v11, (int)&v24);
          v13 = *(v11 - 9);
          LOBYTE(v12) = 1;
          v22 = 0;
          sub_10019070(v12, v13, (int)&v22);
          v23 = 0;
          v14 = (char **)(v11 - 5);
          v17 = 5;
          do
          {
            switch ( *v14 )
            {
              case 1u:
                v15 = "<bool>";
                goto LABEL_19;
              case 2u:
                v15 = "<char>";
                goto LABEL_19;
              case 3u:
                v15 = "<sint32>";
                goto LABEL_19;
              case 4u:
                v15 = "<uint32>";
                goto LABEL_19;
              case 6u:
                v15 = "<float>";
                goto LABEL_19;
              case 5u:
                v15 = "<str>";
                goto LABEL_19;
              case 0u:
                break;
              default:
                v15 = "<*?*>";
LABEL_19:
                sub_10019070(*v14, v15, (int)&v23);
                break;
            }
            ++v14;
            --v17;
          }
          while ( v17 );
          result = (char *)sub_1001B130(2, (int)v18, 6);
        }
        v11 += 10;
        --v16;
      }
      while ( v16 );
    }
  }
  return result;
}
// 10019530: using guessed type int var_61C[6];

//----- (100196E0) --------------------------------------------------------
int __usercall sub_100196E0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ST08_4@1
  char *v3; // eax@1
  int result; // eax@1
  int (__cdecl *v5)(signed int, void *); // esi@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = sub_10018CD0((char **)a1);
  result = sub_1001B1C0(4, (int)v3, v2);
  v5 = *(int (__cdecl **)(signed int, void *))(v1 + 16);
  if ( v5 )
    result = v5(4, &unk_10099738);
  return result;
}

//----- (10019710) --------------------------------------------------------
int __usercall sub_10019710@<eax>(int a1@<esi>)
{
  void (__cdecl *v1)(signed int, void *); // eax@1
  char v2; // al@3

  v1 = *(void (__cdecl **)(signed int, void *))(a1 + 16);
  if ( v1 )
    v1(7, &unk_10099738);
  v2 = (unsigned int)sub_10018CD0((char **)a1);
  return sub_1001B1A0(10, v2);
}

//----- (10019740) --------------------------------------------------------
void __cdecl sub_10019740(int (**a1)(void), char **a2, _DWORD *a3)
{
  int v3; // esi@3
  int (**v4)(void); // ebx@4
  char **v5; // eax@6
  char *v6; // ST1C_4@6
  char *v7; // eax@6
  char *v8; // eax@7
  char *v9; // eax@9
  char *v10; // eax@10
  int v11; // ebp@12
  signed int v12; // ebx@12
  const char *v13; // eax@14
  char *v14; // ST18_4@14
  int v15; // ST14_4@14
  char *v16; // eax@14
  int v17; // ecx@18
  unsigned int v18; // eax@18
  int v19; // eax@20
  int v20; // ecx@20
  char v21; // dl@20
  int v22; // ST14_4@30
  char *v23; // ST10_4@30
  const char *v24; // eax@31
  char *v25; // ST18_4@31
  int v26; // ST14_4@31
  char *v27; // ST10_4@31
  int v28; // edx@34
  int v29; // ecx@34
  int v30; // eax@34
  int v31; // ST14_4@37
  char *v32; // eax@37
  int v33; // eax@38
  int v34; // ST14_4@39
  char *v35; // ST10_4@39
  int v36; // ST14_4@41
  char *v37; // eax@41
  int v38; // eax@42
  int v39; // ST14_4@43
  char *v40; // eax@43
  int v41; // ST14_4@45
  char *v42; // eax@45
  int v43; // ST14_4@48
  char *v44; // eax@48
  int v45; // edx@49
  int v46; // ST14_4@50
  char *v47; // ST10_4@50
  char *v48; // eax@54
  unsigned int v49; // [sp+4h] [bp-8h]@12
  unsigned int v50; // [sp+8h] [bp-4h]@15
  int v51; // [sp+10h] [bp+4h]@16

  if ( a1 )
  {
    if ( *a1 )
    {
      v3 = (*a1)();
      if ( !a2 )
      {
        v4 = a1 + 1;
        if ( a1 != (int (**)(void))-4 )
        {
          do
          {
            if ( !*v4 )
              break;
            v5 = (char **)(*v4)();
            v6 = sub_10018CD0(v5);
            v7 = sub_10018CD0((char **)v3);
            if ( !sub_10018D60(v7, (int)v6) )
            {
              v8 = sub_10018CD0((char **)v3);
              sub_1001B260(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"2872",
                (int)v8,
                (int)"Suite name has been used more than once");
              *a3 = 12;
            }
            ++v4;
          }
          while ( v4 );
        }
      }
      v9 = sub_10018CD0((char **)v3);
      if ( strchr(v9, 32) )
      {
        v10 = sub_10018CD0((char **)v3);
        sub_1001B260(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"2903",
          (int)v10,
          (int)"Suite name includes spaces so it must be quoted");
        *a3 = 10;
      }
      if ( *(_DWORD *)(v3 + 12) )
      {
        v11 = 0;
        v49 = 1;
        v12 = 20;
        while ( 1 )
        {
          if ( strchr(*(const char **)(*(_DWORD *)(v3 + 8) + v11), 32) )
          {
            v13 = sub_10019210(*(_DWORD *)(*(_DWORD *)(v3 + 8) + v11 + 12));
            v14 = sub_1001BC80("%s name includes spaces so it must be quoted", v13);
            v15 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
            v16 = sub_10018CD0((char **)v3);
            sub_1001B2A0(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_runner.c", (int)"2915", (int)v16, v15, (int)v14);
            *a3 = 10;
          }
          v50 = v49;
          if ( v49 < *(_DWORD *)(v3 + 12) )
          {
            v51 = v11 + 40;
            do
            {
              if ( !sub_10018D60(*(_BYTE **)(*(_DWORD *)(v3 + 8) + v11), *(_DWORD *)(v51 + *(_DWORD *)(v3 + 8))) )
              {
                v17 = *(_DWORD *)(v3 + 8);
                v18 = *(_DWORD *)(v17 + v11 + 12);
                if ( v18 < 2 || *(_DWORD *)(v51 + v17 + 12) < 2u )
                {
                  v24 = sub_10019210(v18);
                  v25 = sub_1001BC80("%s name has been used more than once", v24);
                  v26 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
                  v27 = sub_10018CD0((char **)v3);
                  sub_1001B2A0(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2958",
                    (int)v27,
                    v26,
                    (int)v25);
                }
                else
                {
                  v19 = *(_DWORD *)(v3 + 8);
                  v20 = *(_DWORD *)(v51 + v17 + 16);
                  v21 = 0;
                  if ( *(_DWORD *)(v12 + v19 - 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 8) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 12) != v20 || v21 )
                    goto LABEL_33;
                  v22 = *(_DWORD *)(v19 + v11);
                  v23 = sub_10018CD0((char **)v3);
                  sub_1001B2A0(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2946",
                    (int)v23,
                    v22,
                    (int)"Command name has been used more than once");
                }
                *a3 = 12;
              }
LABEL_33:
              v51 += 40;
              ++v50;
            }
            while ( v50 < *(_DWORD *)(v3 + 12) );
          }
          v28 = *(_DWORD *)(v3 + 8);
          v29 = *(_DWORD *)(v28 + v11 + 12);
          v30 = v28 + v11;
          if ( !v29 )
            break;
          if ( v29 == 1 )
          {
            if ( !*(_DWORD *)(v30 + 8) )
            {
              v36 = *(_DWORD *)v30;
              v37 = sub_10018CD0((char **)v3);
              sub_1001B2A0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3047",
                (int)v37,
                v36,
                (int)"Test group has a NULL function pointer or a command uses a reserved ID");
              *a3 = 12;
            }
            v38 = *(_DWORD *)(v3 + 8) + v11;
            if ( *(_DWORD *)(v38 + 4) )
            {
              v39 = *(_DWORD *)v38;
              v40 = sub_10018CD0((char **)v3);
              sub_1001B2A0(
                3,
                (int)"**Warning**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3058",
                (int)v40,
                v39,
                (int)"Test group has a non-NULL test case function pointer");
              *a3 = 10;
            }
            if ( a2 )
            {
              v41 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
              v42 = sub_10018CD0((char **)v3);
              sub_1001B2A0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3070",
                (int)v42,
                v41,
                (int)"Test group contains a test group");
              *a3 = 12;
            }
            else
            {
              sub_10019740(*(_DWORD *)(v3 + 8) + v11 + 8, v3, a3);
            }
            goto LABEL_52;
          }
          if ( *(_DWORD *)(v30 + 4) )
          {
            v31 = *(_DWORD *)v30;
            v32 = sub_10018CD0((char **)v3);
            sub_1001B2A0(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3088",
              (int)v32,
              v31,
              (int)"Command include a non-NULL test case function pointer");
            *a3 = 10;
          }
          v33 = *(_DWORD *)(v3 + 8) + v11;
          if ( *(_DWORD *)(v33 + 8) )
          {
            v34 = *(_DWORD *)v33;
            v35 = sub_10018CD0((char **)v3);
            sub_1001B2A0(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3099",
              (int)v35,
              v34,
              (int)"Command include a non-NULL test group function pointer");
LABEL_51:
            *a3 = 10;
          }
LABEL_52:
          ++v49;
          v12 += 40;
          v11 += 40;
          if ( v49 - 1 >= *(_DWORD *)(v3 + 12) )
            return;
        }
        if ( !*(_DWORD *)(v30 + 4) )
        {
          v43 = *(_DWORD *)v30;
          v44 = sub_10018CD0((char **)v3);
          sub_1001B2A0(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"3022",
            (int)v44,
            v43,
            (int)"Test case has a NULL function pointer or a command uses a reserved ID");
          *a3 = 12;
        }
        v45 = *(_DWORD *)(v3 + 8);
        if ( !*(_DWORD *)(v45 + v11 + 8) )
          goto LABEL_52;
        v46 = *(_DWORD *)(v45 + v11);
        v47 = sub_10018CD0((char **)v3);
        sub_1001B2A0(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"3033",
          (int)v47,
          v46,
          (int)"Test case has a non-NULL group function pointer");
        goto LABEL_51;
      }
    }
    else
    {
      v48 = sub_10018CD0(a2);
      sub_1001B260(
        3,
        (int)"**Error**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"3114",
        (int)v48,
        (int)"Test suite has a NULL function pointer or a command uses a reserved ID");
      *a3 = 12;
    }
  }
}

//----- (10019BB0) --------------------------------------------------------
int sub_10019BB0()
{
  int (**i)(void); // esi@1
  int v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  for ( i = (int (**)(void))dword_10114AB0[sub_10018D20()]; i; ++i )
  {
    if ( !*i )
      break;
    sub_10019740(i, 0, &v2);
  }
  return v2;
}
// 10114AB0: using guessed type int dword_10114AB0[];

//----- (10019C00) --------------------------------------------------------
void *sub_10019C00()
{
  void *result; // eax@1
  signed int v1; // esi@1

  dword_10114AB0[0] = 0;
  dword_10114AB4 = 0;
  dword_10114AB8 = 0;
  dword_10114ABC = 0;
  dword_10114AC0 = 0;
  result = &unk_10114AD8;
  dword_10114AC4[0] = -1;
  dword_10114AC8 = -1;
  dword_10114ACC = -1;
  dword_10114AD0 = -1;
  dword_10114AD4 = -1;
  v1 = 5;
  do
  {
    result = (void *)(sub_100194F0((int)result) + 56);
    --v1;
  }
  while ( v1 );
  return result;
}
// 10114AB0: using guessed type int dword_10114AB0[];
// 10114AB4: using guessed type int dword_10114AB4;
// 10114AB8: using guessed type int dword_10114AB8;
// 10114ABC: using guessed type int dword_10114ABC;
// 10114AC0: using guessed type int dword_10114AC0;
// 10114AC4: using guessed type int dword_10114AC4[];
// 10114AC8: using guessed type int dword_10114AC8;
// 10114ACC: using guessed type int dword_10114ACC;
// 10114AD0: using guessed type int dword_10114AD0;
// 10114AD4: using guessed type int dword_10114AD4;

//----- (10019C60) --------------------------------------------------------
char *sub_10019C60()
{
  return (char *)&unk_10114AD8 + 56 * sub_10018D20();
}

//----- (10019C80) --------------------------------------------------------
char sub_10019C80()
{
  return sub_10019C60()[33];
}

//----- (10019C90) --------------------------------------------------------
char __cdecl sub_10019C90(int a1, int a2, unsigned int a3)
{
  char *v3; // esi@1
  char result; // al@1

  v3 = sub_10019C60();
  result = a1 - 6;
  if ( a1 == 6 )
  {
    *(_DWORD *)v3 = 0;
  }
  else
  {
    result = a1 - 7;
    if ( a1 == 7 )
    {
      result = sub_1001AD20(a2, a3);
      if ( result )
        ++*(_DWORD *)v3;
    }
  }
  return result;
}

//----- (10019CD0) --------------------------------------------------------
int *__usercall sub_10019CD0@<eax>(_DWORD *a1@<ebx>, int a2)
{
  int *v2; // edi@1
  unsigned int v3; // ebp@1
  int **v4; // esi@1

  v2 = 0;
  v3 = 0;
  v4 = (int **)(sub_10019C60() + 36);
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 && !sub_10018DD0((_BYTE *)(a2 + 80 * *a1), **v4) )
    {
      v2 = *v4;
      ++*a1;
    }
    ++v3;
    ++v4;
  }
  while ( !v2 );
  return v2;
}

//----- (10019D20) --------------------------------------------------------
char **sub_10019D20()
{
  return &off_10099AE8;
}
// 10099AE8: using guessed type char *off_10099AE8;

//----- (10019D30) --------------------------------------------------------
int __cdecl sub_10019D30(_DWORD *a1, int a2, int a3)
{
  char *v3; // esi@1
  int result; // eax@2
  unsigned int v5; // ebp@7
  int v6; // [sp+8h] [bp-8h]@0
  int v7; // [sp+8h] [bp-8h]@7
  int v8; // [sp+Ch] [bp-4h]@8

  sub_1001FEF0();
  v3 = sub_10019C60();
  if ( v3[34] )
  {
    result = v6;
  }
  else
  {
    result = sub_10019BB0();
    if ( result != 12 )
      v3[34] = 1;
  }
  if ( v3[34] )
  {
    sub_100196E0(a2);
    if ( a3 )
    {
      v7 = sub_10019450(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), a3);
    }
    else
    {
      v5 = 0;
      v7 = 0;
      if ( *(_DWORD *)(a2 + 12) )
      {
        v8 = 0;
        do
        {
          v7 += sub_10019450(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), v8 + *(_DWORD *)(a2 + 8));
          v8 += 40;
          ++v5;
        }
        while ( v5 < *(_DWORD *)(a2 + 12) );
        sub_10019710(a2);
        return v7;
      }
    }
    sub_10019710(a2);
    result = v7;
  }
  return result;
}

//----- (10019DE0) --------------------------------------------------------
int __cdecl sub_10019DE0(int a1, int a2, int a3, const char *a4, const char *a5)
{
  int v5; // ebp@1
  unsigned int v6; // eax@1
  char *v7; // ecx@1
  int result; // eax@3
  int v9; // eax@5
  char *v10; // eax@7
  char *v11; // eax@7
  char *v12; // eax@7
  char *v13; // eax@7
  char *v14; // eax@7
  char **v15; // eax@7
  char **v16; // esi@7
  char *v17; // eax@7
  char *v18; // eax@7
  char *v19; // eax@7
  char *v20; // eax@7
  char *v21; // eax@8
  char *v22; // eax@9
  const char *v23; // edi@9
  char *v24; // eax@11
  int v25; // [sp+8h] [bp-41Ch]@4
  int v26[4]; // [sp+10h] [bp-414h]@2
  char v27; // [sp+20h] [bp-404h]@1
  char v28; // [sp+120h] [bp-304h]@7
  char v29; // [sp+220h] [bp-204h]@7
  char v30; // [sp+320h] [bp-104h]@11

  v5 = a1;
  v6 = 0;
  v7 = &v27;
  do
  {
    v26[v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( v6 < 4 );
  result = a2;
  if ( a2 )
  {
    v25 = a2;
    do
    {
      v9 = *(_DWORD *)(v5 + 12);
      if ( v9 )
      {
        result = v9 - 1;
        if ( !result )
        {
          v10 = sub_10019070(0, "group", (int)&v27);
          LOBYTE(v10) = 0;
          v11 = sub_10019070(v10, a4, (int)&v28);
          LOBYTE(v11) = 0;
          sub_10019070(v11, *(const char **)v5, (int)&v29);
          v12 = (char *)sub_1001B130(2, (int)v26, 3);
          LOBYTE(v12) = 0;
          v13 = sub_10019070(v12, "group", (int)&v27);
          LOBYTE(v13) = 0;
          v14 = sub_10019070(v13, a4, (int)&v28);
          LOBYTE(v14) = 0;
          sub_10019070(v14, "group-begin", (int)&v29);
          sub_1001B130(2, (int)v26, 3);
          v15 = (char **)(*(int (**)(void))(v5 + 8))();
          v16 = v15;
          v17 = sub_10018CD0(v15);
          sub_10019DE0(v16[2], v16[3], v16[4], v17, a4);
          sub_10018CD0(v16);
          v18 = sub_10019530((int)v16[2], v16[3], (int)v16[4], a4);
          LOBYTE(v18) = 0;
          v19 = sub_10019070(v18, "group", (int)&v27);
          LOBYTE(v19) = 0;
          v20 = sub_10019070(v19, a4, (int)&v28);
          LOBYTE(v20) = 0;
          sub_10019070(v20, "group-end", (int)&v29);
          result = sub_1001B130(2, (int)v26, 3);
        }
      }
      else
      {
        v21 = sub_10019070(0, "case", (int)&v27);
        LOBYTE(v21) = 0;
        if ( a5 )
        {
          v22 = sub_10019070(v21, a5, (int)&v28);
          v23 = a4;
        }
        else
        {
          v22 = sub_10019070(v21, a4, (int)&v28);
          v23 = (const char *)&unk_1005E69C;
        }
        LOBYTE(v22) = 0;
        v24 = sub_10019070(v22, v23, (int)&v29);
        LOBYTE(v24) = 0;
        sub_10019070(v24, *(const char **)v5, (int)&v30);
        result = sub_1001B130(2, (int)v26, 4);
      }
      v5 += 40;
      --v25;
    }
    while ( v25 );
  }
  return result;
}
// 10019DE0: using guessed type int var_414[4];

//----- (10019FF0) --------------------------------------------------------
char *__usercall sub_10019FF0@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6)
{
  const char *v6; // edi@1
  char *v7; // eax@1
  char *v8; // ecx@1
  char *v9; // eax@3
  char *result; // eax@3
  int v11[2]; // [sp+Ch] [bp-20Ch]@2
  char v12; // [sp+14h] [bp-204h]@1
  char v13; // [sp+114h] [bp-104h]@3

  v6 = a1;
  v7 = 0;
  v8 = &v12;
  do
  {
    v11[(signed int)v7] = (int)v8;
    *v8 = 0;
    ++v7;
    v8 += 256;
  }
  while ( (unsigned int)v7 < 2 );
  LOBYTE(v7) = 0;
  v9 = sub_10019070(v7, v6, (int)&v12);
  LOBYTE(v9) = 0;
  result = sub_10019070(v9, a2, (int)&v13);
  if ( v13 )
    result = (char *)sub_1001B130(2, (int)v11, 2);
  if ( a6 )
  {
    sub_10019DE0(a3, (int)a4, a5, a2, 0);
    result = sub_10019530(a3, a4, a5, 0);
  }
  return result;
}
// 10019FF0: using guessed type int var_20C[2];

//----- (1001A0B0) --------------------------------------------------------
char *__cdecl sub_1001A0B0(char a1)
{
  int (**i)(void); // edi@1
  int v2; // esi@3
  char *v3; // ebx@3
  char **v4; // esi@4
  signed int v5; // edi@4
  char *result; // eax@5

  for ( i = (int (**)(void))dword_10114AB0[sub_10018D20()]; i; ++i )
  {
    if ( !*i )
      break;
    v2 = (*i)();
    v3 = sub_10018CD0((char **)v2);
    sub_10019FF0("suite", v3, *(_DWORD *)(v2 + 8), *(char **)(v2 + 12), *(_DWORD *)(v2 + 16), a1);
  }
  v4 = (char **)(sub_10019C60() + 36);
  v5 = 5;
  do
  {
    result = *v4;
    if ( *v4 )
    {
      if ( *((_DWORD *)result + 2) )
        result = sub_10019FF0(
                   "listener",
                   *(const char **)result,
                   *((_DWORD *)result + 3),
                   *((char **)result + 4),
                   *((_DWORD *)result + 2),
                   a1);
    }
    ++v4;
    --v5;
  }
  while ( v5 );
  return result;
}
// 10114AB0: using guessed type int dword_10114AB0[];

//----- (1001A150) --------------------------------------------------------
int *__cdecl sub_1001A150(_BYTE *a1)
{
  int (**v1)(void); // edi@1
  char **v2; // eax@3
  char **v3; // esi@3
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // ebx@7
  unsigned int v7; // esi@7
  int **v8; // edi@7
  int *result; // eax@8

  v1 = (int (**)(void))dword_10114AB0[sub_10018D20()];
  if ( v1 )
  {
    while ( *v1 )
    {
      v2 = (char **)(*v1)();
      v3 = v2;
      v4 = sub_10018CD0(v2);
      if ( !sub_10018DD0(a1, (int)v4) )
      {
        v5 = sub_10018CD0(v3);
        sub_10019FF0("suite", v5, (int)v3[2], v3[3], (int)v3[4], 1);
        break;
      }
      ++v1;
      if ( !v1 )
        break;
    }
  }
  v6 = sub_10019C60();
  v7 = 0;
  v8 = (int **)(v6 + 36);
  while ( 1 )
  {
    result = *v8;
    if ( *v8 )
    {
      result = (int *)sub_10018DD0(a1, *result);
      if ( !result )
        break;
    }
    ++v7;
    ++v8;
    if ( v7 >= 5 )
      return result;
  }
  return (int *)sub_10019FF0(
                  "listener",
                  **(const char ***)&v6[4 * v7 + 36],
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 12),
                  *(char **)(*(_DWORD *)&v6[4 * v7 + 36] + 16),
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 8),
                  1);
}
// 10114AB0: using guessed type int dword_10114AB0[];

//----- (1001A210) --------------------------------------------------------
int __usercall sub_1001A210@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  bool v2; // zf@1
  int result; // eax@1
  signed int v4; // ebp@3
  int v5; // eax@5
  int v6; // eax@8
  int v7; // ecx@14
  int v8; // esi@18
  unsigned int v9; // eax@18
  int v10; // eax@19
  int v11; // edi@25

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 20) == 0;
  result = 12;
  if ( !v2 && !*(_BYTE *)(v1 + 24) )
  {
    v4 = 2;
    if ( !*(_DWORD *)(v1 + 16) )
    {
      *(_DWORD *)(v1 + 16) = sub_10019230(++*(_DWORD *)(v1 + 12));
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 4) = 0;
    }
    v5 = *(_DWORD *)(v1 + 16);
    if ( v5 )
    {
      if ( *(_DWORD *)(v1 + 20) == 1 )
      {
        sub_10019D30((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        v6 = sub_10019230(++*(_DWORD *)(v1 + 12));
        v2 = *(_DWORD *)(v1 + 28) == 0;
        *(_DWORD *)(v1 + 16) = v6;
        *(_DWORD *)(v1 + 8) = 0;
        if ( !v2 || !v6 )
          *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 28) == 2 )
      {
        sub_10019D30((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 8)
             || (*(_DWORD *)(v1 + 4) = 0, v7 = *(_DWORD *)(v5 + 8), (*(_DWORD *)(v1 + 8) = v7) != 0) )
      {
        if ( !*(_DWORD *)(v1 + 4) )
          sub_100196E0(v5);
        sub_10019450(
          (_DWORD *)v1,
          *(void (__cdecl **)(signed int, void *))(*(_DWORD *)(v1 + 16) + 16),
          *(_DWORD *)(v1 + 8));
        v8 = *(_DWORD *)(v1 + 16);
        v9 = ++*(_DWORD *)(v1 + 4);
        if ( *(_DWORD *)(v8 + 12) > v9 )
        {
          *(_DWORD *)(v1 + 8) = *(_DWORD *)(v8 + 8) + 40 * v9;
        }
        else
        {
          sub_10019710(v8);
          v10 = sub_10019230(++*(_DWORD *)(v1 + 12));
          *(_DWORD *)(v1 + 16) = v10;
          *(_DWORD *)(v1 + 4) = 0;
          *(_DWORD *)(v1 + 8) = 0;
          if ( !v10 || *(_DWORD *)(v1 + 28) )
            *(_BYTE *)(v1 + 24) = 1;
        }
      }
      else
      {
        *(_BYTE *)(v1 + 24) = 1;
        v4 = 12;
      }
    }
    else
    {
      *(_BYTE *)(v1 + 24) = 1;
      v4 = 12;
    }
    if ( *(_BYTE *)(v1 + 24) && v4 == 2 )
    {
      v11 = *(_DWORD *)v1;
      if ( v11 )
        result = v11 + 12;
      else
        result = 0;
    }
    else
    {
      result = v4;
    }
  }
  return result;
}

//----- (1001A370) --------------------------------------------------------
signed int __usercall sub_1001A370@<eax>(int a1@<esi>)
{
  signed int v1; // ebp@1
  int (**i)(void); // edi@2
  int v3; // eax@4
  signed int result; // eax@5

  v1 = 0;
  if ( *(_DWORD *)(a1 + 20) )
  {
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(_BYTE *)(a1 + 24) = 0;
      result = 1;
    }
    else
    {
      result = 12;
    }
  }
  else
  {
    for ( i = (int (**)(void))dword_10114AB0[sub_10018D20()]; i; ++i )
    {
      if ( !*i )
        break;
      v3 = (*i)();
      v1 += sub_10019D30((_DWORD *)a1, v3, 0);
    }
    result = v1;
  }
  return result;
}
// 10114AB0: using guessed type int dword_10114AB0[];

//----- (1001A3E0) --------------------------------------------------------
int __cdecl sub_1001A3E0(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  int v4; // ebx@3
  int result; // eax@3
  _BYTE *v6; // esi@5
  int v7; // ebx@6
  int v8; // ebx@8
  int v9; // ebx@9
  int (**i)(void); // edi@11
  int v11; // eax@13
  int (__cdecl *v12)(int, int); // eax@14
  int (**v13)(void); // esi@19
  int v14; // eax@21
  int (__cdecl *v15)(int, int); // eax@22

  v2 = 0;
  v3 = sub_10019C60();
  switch ( a1 )
  {
    case 9:
      sub_1001B1A0(2, (unsigned int)"begin");
      if ( *(_DWORD *)a2 )
      {
        if ( *(_DWORD *)a2 == 5 )
        {
          v6 = (_BYTE *)(a2 + 4);
          if ( sub_10018DD0((_BYTE *)(a2 + 4), (int)"-v") )
          {
            if ( sub_10018DD0(v6, (int)"-q") )
            {
              sub_1001A150(v6);
              v9 = sub_10019BB0();
              sub_1001B1A0(2, (unsigned int)"end");
              result = v9;
            }
            else
            {
              sub_1001A0B0(0);
              v8 = sub_10019BB0();
              sub_1001B1A0(2, (unsigned int)"end");
              result = v8;
            }
          }
          else
          {
            sub_1001A0B0(1);
            v7 = sub_10019BB0();
            sub_1001B1A0(2, (unsigned int)"end");
            result = v7;
          }
        }
        else
        {
          sub_1001B220(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"1719",
            (int)"Unsupported argument type for help command (internal error)");
          sub_1001B1A0(2, (unsigned int)"end");
          result = 4;
        }
      }
      else
      {
        sub_1001A0B0(0);
        v4 = sub_10019BB0();
        sub_1001B1A0(2, (unsigned int)"end");
        result = v4;
      }
      return result;
    case 2:
      sub_1001B1A0(0, (unsigned int)"Global reset command");
      for ( i = (int (**)(void))dword_10114AB0[sub_10018D20()]; i; ++i )
      {
        if ( !*i )
          break;
        v11 = (*i)();
        if ( v11 )
        {
          v12 = *(int (__cdecl **)(int, int))(v11 + 16);
          if ( v12 )
          {
            if ( v12 != sub_1001A3E0 )
              v12(2, (int)&unk_10099738);
          }
        }
      }
      sub_1001FEF0();
      v3[34] = 0;
      return 0;
    case 3:
      sub_1001B1A0(1, (unsigned int)"Global clear command");
      v13 = (int (**)(void))dword_10114AB0[sub_10018D20()];
      if ( !v13 )
        return v2;
      break;
    case 10:
      if ( !*((_DWORD *)v3 + 5) )
      {
        sub_1001B220(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1764", (int)"Step mode not enabled");
        goto LABEL_29;
      }
      return sub_1001A210((int)v3);
    case 11:
      if ( v3[24] )
      {
        *((_DWORD *)v3 + 5) = 0;
        v3[24] = 0;
        result = 0;
      }
      else
      {
        sub_1001B220(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1783", (int)"Step mode is busy");
LABEL_29:
        result = 12;
      }
      return result;
    case 12:
      *((_DWORD *)v3 + 5) = 1;
      return 0;
    case 13:
      *((_DWORD *)v3 + 5) = 2;
      return 0;
    case 8:
      return sub_1001A370((int)v3);
    case 14:
      exit_0(12);
      return result;
    case 4:
    case 5:
    case 6:
    case 7:
      return v2;
    default:
      sub_1001B220(
        3,
        (int)"**Warning**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"1820",
        (int)"Unknown/unsupported command (internal error)");
      return 4;
  }
  while ( *v13 )
  {
    v14 = (*v13)();
    if ( v14 )
    {
      v15 = *(int (__cdecl **)(int, int))(v14 + 16);
      if ( v15 )
      {
        if ( v15 != sub_1001A3E0 )
          v15(3, (int)&unk_10099738);
      }
    }
    ++v13;
    if ( !v13 )
      return 0;
  }
  return v2;
}
// 1001A3E0: using guessed type int __cdecl sub_1001A3E0(int, int);
// 10114AB0: using guessed type int dword_10114AB0[];

//----- (1001A6C0) --------------------------------------------------------
char **sub_1001A6C0()
{
  return off_100998DC;
}
// 100998DC: using guessed type char *off_100998DC[3];

//----- (1001A6D0) --------------------------------------------------------
int __usercall sub_1001A6D0@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int result; // eax@2
  char **v9; // eax@6
  signed int v10; // ebx@6
  int v11; // [sp+0h] [bp-1C0h]@0
  int (__cdecl *v12)(_DWORD, char *); // [sp+14h] [bp-1ACh]@1
  char v13; // [sp+18h] [bp-1A8h]@2

  v12 = a2;
  v6 = sub_10019160(a4, a5, a1, v11);
  v7 = v6;
  if ( v6 )
  {
    result = sub_10019270(a5, &v13, v6, a3, a6);
    if ( !result )
    {
      if ( v12 )
      {
        result = v12(*(_DWORD *)(v7 + 12), &v13);
      }
      else
      {
        sprintf(a6, "'%s' does not support commands", a3);
        result = 11;
      }
    }
  }
  else
  {
    v9 = sub_1001A6C0();
    v10 = *a5;
    if ( (char *)a4 == v9[2] )
      sprintf(a6, "Invalid or missing test suite, listener, or command: '%s'", a3 + 80 * v10);
    else
      sprintf(a6, "Invalid or mising test case or command: '%s'", a3 + 80 * v10);
    result = 10;
  }
  return result;
}

//----- (1001A7C0) --------------------------------------------------------
int __cdecl sub_1001A7C0(char *a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *v3; // edi@1
  char *v4; // eax@1
  int result; // eax@1
  int v6; // eax@4
  char **v7; // ebx@4
  int v8; // eax@5
  int *v9; // eax@20
  char **v10; // eax@22
  int v11; // [sp+10h] [bp-2DCh]@4
  int v12; // [sp+14h] [bp-2D8h]@1
  char v13[720]; // [sp+18h] [bp-2D4h]@1

  v2 = v1;
  v3 = sub_10019C60();
  *a1 = 0;
  v4 = sub_1001BC80("Processing command '%s'", v2);
  sub_1001B220(3, (int)&unk_1009A288, (int)"..\\lib\\utf\\utf_runner.c", (int)"1215", (int)v4);
  result = sub_10019300(v13, &v12, v2, a1);
  if ( result )
  {
    if ( result == 3 )
    {
      if ( *((_DWORD *)v3 + 5) && !v3[24] )
        result = sub_1001A210((int)v3);
    }
    else
    {
      sprintf(a1, "Invalid command: '%s'", v2);
      result = 10;
    }
  }
  else
  {
    if ( !v12 )
      return sub_1001A370((int)v3);
    v11 = 0;
    v6 = sub_10018D20();
    v7 = sub_100191B0((int (**)(void))dword_10114AB0[v6], (int)v13, &v11);
    if ( v7 )
    {
      v8 = sub_100190D0((int)v7, (int)v13, &v11);
      if ( !v8 )
        goto LABEL_30;
      if ( *(_DWORD *)(v8 + 12) == 1 )
      {
        v7 = (char **)(*(int (**)(void))(v8 + 8))();
        v8 = sub_100190D0((int)v7, (int)v13, &v11);
      }
      if ( v8 )
      {
        if ( v11 >= v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_10019D30(v3, (int)v7, v8);
          *((_DWORD *)v3 + 2) = v8;
          *((_DWORD *)v3 + 4) = v7;
          *((_DWORD *)v3 + 3) = 0;
          *((_DWORD *)v3 + 1) = 0;
          *((_DWORD *)v3 + 7) = 2;
          v3[24] = 0;
          result = 1;
        }
        else
        {
          sprintf(a1, "Unsupported argument to test case: '%s'", &v13[80 * v11]);
          result = 9;
        }
      }
      else
      {
LABEL_30:
        if ( v11 == v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_10019D30(v3, (int)v7, v8);
          if ( v3[24] )
          {
            *((_DWORD *)v3 + 2) = v8;
            result = 1;
            *((_DWORD *)v3 + 4) = v7;
            *((_DWORD *)v3 + 3) = 0;
            *((_DWORD *)v3 + 1) = 0;
            *((_DWORD *)v3 + 7) = 1;
            v3[24] = 0;
          }
          else
          {
            result = 12;
          }
        }
        else
        {
          result = sub_1001A6D0(
                     (unsigned int)v7[3],
                     (int (__cdecl *)(_DWORD, char *))v7[4],
                     (int)v13,
                     (int)v7[2],
                     &v11,
                     a1);
        }
      }
    }
    else
    {
      v9 = sub_10019CD0(&v11, (int)v13);
      if ( v9 )
      {
        result = sub_1001A6D0(v9[4], (int (__cdecl *)(_DWORD, char *))v9[2], (int)v13, v9[3], &v11, a1);
      }
      else
      {
        v10 = sub_1001A6C0();
        result = sub_1001A6D0(
                   (unsigned int)v10[3],
                   (int (__cdecl *)(_DWORD, char *))v10[4],
                   (int)v13,
                   (int)v10[2],
                   &v11,
                   a1);
      }
    }
  }
  return result;
}
// 10114AB0: using guessed type int dword_10114AB0[];
// 1001A7C0: using guessed type char var_2D4[720];

//----- (1001AA00) --------------------------------------------------------
int sub_1001AA00()
{
  int v0; // esi@1
  char *v1; // eax@4
  int result; // eax@4
  char *v3; // eax@5
  char v4; // [sp+4h] [bp-104h]@1

  v4 = 0;
  v0 = sub_1001A7C0(&v4);
  if ( !sub_10019C60()[32] )
    sub_1001B1A0(11, (unsigned int)"Non-interactive command complete");
  if ( v4 )
  {
    v3 = sub_1001BC80("%s %i, %s", "Command status:", v0, &v4);
    sub_1001B220(3, (int)&unk_1009A288, (int)"..\\lib\\utf\\utf_runner.c", (int)"773", (int)v3);
    result = v0;
  }
  else
  {
    v1 = sub_1001BC80("%s %i", "Command status:", v0);
    sub_1001B220(3, (int)&unk_1009A288, (int)"..\\lib\\utf\\utf_runner.c", (int)"767", (int)v1);
    result = v0;
  }
  return result;
}

//----- (1001AAE0) --------------------------------------------------------
int __cdecl sub_1001AAE0(int a1, int a2, char a3)
{
  char **v3; // eax@1

  dword_10114AB0[sub_10018D20()] = a1;
  sub_10019C60()[32] = a3;
  sub_1001FEF0();
  sub_10025870(a2);
  v3 = sub_10019D20();
  sub_1001AC10(v3);
  return sub_1001AA00();
}
// 10114AB0: using guessed type int dword_10114AB0[];

//----- (1001AB30) --------------------------------------------------------
int __cdecl sub_1001AB30(int a1)
{
  return a1 + 9;
}

//----- (1001AB40) --------------------------------------------------------
int __cdecl sub_1001AB40(void *a1)
{
  int v1; // edi@1
  __int16 v2; // ax@1
  _WORD *v3; // ecx@1

  v1 = sub_100318A0();
  memset(a1, 0, 0xDCu);
  sub_1000F650((char *)a1 + 204, 0xFu, "test sk %i", v1);
  v2 = sub_1001AB30(v1);
  *v3 = v2;
  *((_DWORD *)a1 + 10) = (char *)a1 + 204;
  *((_DWORD *)a1 + 11) = (char *)a1 + 76;
  *((_WORD *)a1 + 24) = 128;
  *((_BYTE *)a1 + 50) = 22;
  *((_DWORD *)a1 + 13) = 0;
  *((_DWORD *)a1 + 14) = 300;
  *((_DWORD *)a1 + 15) = 0;
  *((_DWORD *)a1 + 16) = 500;
  *((_DWORD *)a1 + 17) = 0;
  return sub_10025A00((int)a1, (int)v3);
}

//----- (1001ABC0) --------------------------------------------------------
int __cdecl sub_1001ABC0(int a1, int a2)
{
  int v2; // esi@1
  _DWORD *v3; // ST00_4@1
  int result; // eax@2

  v2 = a1;
  v3 = (_DWORD *)a1;
  *(_DWORD *)(a1 + 60) = a2;
  sub_10025C10(v3, (char *)&a1);
  if ( (_BYTE)a1 )
    result = v2 + 76;
  else
    result = 0;
  return result;
}

//----- (1001ABF0) --------------------------------------------------------
signed int __cdecl sub_1001ABF0(int a1, int a2, int a3)
{
  signed int result; // eax@1
  int v4; // esi@2
  __int16 v5; // ax@4
  int v6; // eax@6
  int v7; // ebx@6

  result = 0;
  if ( a3 )
  {
    v4 = *(_DWORD *)a1;
    if ( !*(_DWORD *)a1 )
      return -59;
    v5 = 0;
    if ( *(_BYTE *)(v4 + 14) & 0x10 )
      v5 = 2;
    v6 = sub_100329D0(*(_DWORD *)(a1 + 4), a2, a3, v5, *(_DWORD *)(v4 + 28));
    v7 = v6;
    if ( v6 >= 0 )
    {
      *(_DWORD *)(a1 + 32) = sub_10031910();
    }
    else if ( v6 != -57 || (unsigned int)(sub_10031910() - *(_DWORD *)(a1 + 32)) >= *(_DWORD *)(v4 + 32) )
    {
      sub_10025A00(a1, v4);
      return v7;
    }
    result = v7;
  }
  return result;
}

//----- (1001AC10) --------------------------------------------------------
char __cdecl sub_1001AC10(_DWORD *a1)
{
  char v1; // bl@1
  unsigned int v2; // ebp@1
  char *v3; // edi@1
  char *v4; // eax@4
  char *v5; // eax@7
  char v7; // [sp+13h] [bp-105h]@1
  char v8; // [sp+14h] [bp-104h]@5
  char v9; // [sp+113h] [bp-5h]@5

  v1 = 0;
  v7 = 0;
  v2 = 0;
  v3 = sub_10019C60() + 36;
  do
  {
    if ( v2 >= 5 )
      break;
    if ( !*(_DWORD *)v3 )
    {
      v1 = 1;
      v7 = 1;
      *(_DWORD *)v3 = a1;
      v4 = sub_100256B0("CFG_OutputFile", 0);
      if ( v4 )
      {
        _snprintf(&v8, 0x100u, "'%s' file '%s'", *a1, v4);
        v9 = 0;
        if ( sub_1001AA00() )
          v7 = 0;
      }
      v5 = sub_100256B0("CFG_OutputPath", 0);
      if ( v5 )
      {
        _snprintf(&v8, 0x100u, "'%s' path '%s'", *a1, v5);
        v9 = 0;
        if ( sub_1001AA00() )
          v7 = 0;
      }
    }
    ++v2;
    v3 += 4;
  }
  while ( !v1 );
  return v7;
}

//----- (1001AD20) --------------------------------------------------------
char __cdecl sub_1001AD20(int a1, unsigned int a2)
{
  char result; // al@1

  result = 1;
  if ( a2 > 4 && !memcmp(*(const void **)(a1 + 16), "PASS", 5u) )
    result = 0;
  return result;
}

//----- (1001AD50) --------------------------------------------------------
bool __cdecl sub_1001AD50(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "begin", 6u);
}

//----- (1001AD80) --------------------------------------------------------
bool __cdecl sub_1001AD80(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "case", 5u);
}

//----- (1001ADB0) --------------------------------------------------------
bool __cdecl sub_1001ADB0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "command", 8u);
}

//----- (1001ADE0) --------------------------------------------------------
bool __cdecl sub_1001ADE0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "end", 4u);
}

//----- (1001AE10) --------------------------------------------------------
bool __cdecl sub_1001AE10(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "group", 6u);
}

//----- (1001AE40) --------------------------------------------------------
bool __cdecl sub_1001AE40(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-begin", 0xCu);
}

//----- (1001AE80) --------------------------------------------------------
bool __cdecl sub_1001AE80(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-end", 0xAu);
}

//----- (1001AEC0) --------------------------------------------------------
bool __cdecl sub_1001AEC0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "listener", 9u);
}

//----- (1001AEF0) --------------------------------------------------------
bool __cdecl sub_1001AEF0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "suite", 6u);
}

//----- (1001AF20) --------------------------------------------------------
char __cdecl sub_1001AF20(int a1, unsigned int a2)
{
  char result; // al@1

  result = 0;
  if ( a2 > 5 && !memcmp(*(const void **)(a1 + 20), "robust", 7u) )
    result = 1;
  return result;
}

//----- (1001AF50) --------------------------------------------------------
bool __cdecl sub_1001AF50(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Error**", 0xAu);
}

//----- (1001AF80) --------------------------------------------------------
bool __cdecl sub_1001AF80(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**MSG**", 8u);
}

//----- (1001AFB0) --------------------------------------------------------
bool __cdecl sub_1001AFB0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**METHOD**", 0xBu);
}

//----- (1001AFE0) --------------------------------------------------------
bool __cdecl sub_1001AFE0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**RESULT**", 0xBu);
}

//----- (1001B010) --------------------------------------------------------
bool __cdecl sub_1001B010(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, &unk_1009A288, 9u);
}

//----- (1001B040) --------------------------------------------------------
bool __cdecl sub_1001B040(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**SUBGROUP**", 0xDu);
}

//----- (1001B070) --------------------------------------------------------
bool __cdecl sub_1001B070(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TITLE**", 0xAu);
}

//----- (1001B0A0) --------------------------------------------------------
bool __cdecl sub_1001B0A0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "Tested Requirement:", 0x14u);
}

//----- (1001B0D0) --------------------------------------------------------
bool __cdecl sub_1001B0D0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TYPE**", 9u);
}

//----- (1001B100) --------------------------------------------------------
bool __cdecl sub_1001B100(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Warning**", 0xCu);
}

//----- (1001B130) --------------------------------------------------------
int __cdecl sub_1001B130(int a1, int a2, int a3)
{
  int *v3; // esi@1
  signed int v4; // edi@1
  int result; // eax@2

  v3 = (int *)(sub_10019C60() + 36);
  v4 = 5;
  do
  {
    result = *v3;
    if ( *v3 )
    {
      result = *(_DWORD *)(result + 4);
      if ( result )
        result = ((int (__cdecl *)(int, int, int))result)(a1, a2, a3);
    }
    ++v3;
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (1001B1A0) --------------------------------------------------------
int __cdecl sub_1001B1A0(int a1, char a2)
{
  return sub_1001B130(a1, (int)&a2, 1);
}

//----- (1001B1C0) --------------------------------------------------------
int __cdecl sub_1001B1C0(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = a2;
  v5 = a3;
  return sub_1001B130(a1, (int)&v4, 2);
}

//----- (1001B1F0) --------------------------------------------------------
int __cdecl sub_1001B1F0(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-Ch]@1
  int v6; // [sp+4h] [bp-8h]@1
  int v7; // [sp+8h] [bp-4h]@1

  v5 = a2;
  v6 = a3;
  v7 = a4;
  return sub_1001B130(a1, (int)&v5, 3);
}

//----- (1001B220) --------------------------------------------------------
int __cdecl sub_1001B220(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+4h] [bp-Ch]@1
  int v8; // [sp+8h] [bp-8h]@1
  int v9; // [sp+Ch] [bp-4h]@1

  v7 = a3;
  v8 = a4;
  v6 = a2;
  v9 = a5;
  return sub_1001B130(a1, (int)&v6, 4);
}

//----- (1001B260) --------------------------------------------------------
int __cdecl sub_1001B260(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [sp+0h] [bp-14h]@1
  int v8; // [sp+4h] [bp-10h]@1
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1
  int v11; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v9 = a4;
  v10 = a5;
  v8 = a3;
  v11 = a6;
  return sub_1001B130(a1, (int)&v7, 5);
}

//----- (1001B2A0) --------------------------------------------------------
int __cdecl sub_1001B2A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-18h]@1
  int v9; // [sp+4h] [bp-14h]@1
  int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v8 = a2;
  v9 = a3;
  v11 = a5;
  v12 = a6;
  v10 = a4;
  v13 = a7;
  return sub_1001B130(a1, (int)&v8, 6);
}

//----- (1001B2F0) --------------------------------------------------------
char __cdecl sub_1001B2F0(int a1)
{
  char v1; // bl@1
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  _DWORD *v4; // eax@1

  v1 = 0;
  v2 = sub_10019C60();
  v3 = 0;
  v4 = v2 + 36;
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 == a1 )
    {
      v1 = 1;
      *v4 = 0;
    }
    ++v3;
    ++v4;
  }
  while ( !v1 );
  return v1;
}

//----- (1001B320) --------------------------------------------------------
char __cdecl sub_1001B320(int a1)
{
  ++*(_DWORD *)(a1 + 328);
  return *(_BYTE *)(a1 + 52);
}

//----- (1001B330) --------------------------------------------------------
char __cdecl sub_1001B330(int a1, int a2)
{
  int v2; // esi@1
  bool v3; // zf@1
  int v4; // ebp@1
  char *v5; // eax@1
  int v6; // edi@1
  int v7; // ecx@2
  char *v8; // ecx@7
  char v9; // dl@8
  char v10; // cl@9
  const char *v11; // ecx@10
  char *v12; // edx@13
  char v13; // cl@14
  int v14; // eax@17
  char v16[255]; // [sp+10h] [bp-104h]@12
  char v17; // [sp+10Fh] [bp-5h]@12

  v2 = a1;
  ++*(_DWORD *)(v2 + 324);
  ++*(_DWORD *)(v2 + 328);
  v3 = *(_BYTE *)(a1 + 53) == 0;
  v4 = *(_DWORD *)(a1 + 324);
  v5 = (char *)(a1 + 53);
  v6 = *(_DWORD *)(a1 + 328);
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  if ( !v3 )
  {
    v7 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
    if ( !v7 )
    {
LABEL_6:
      if ( *(_BYTE *)(a1 + 52) )
      {
        v8 = (char *)(a1 + 53);
        do
          v9 = *v8++;
        while ( v9 );
        v10 = *(&v8[a1 - 2] - a1);
        if ( v10 == 92 || (v3 = v10 == 47, v11 = "/", v3) )
          v11 = (const char *)&unk_1005E69C;
        _snprintf(v16, 0x100u, "%s%s%s%s", a1 + 53, v11, a2, *(_DWORD *)(a1 + 48));
        v17 = 0;
      }
      else
      {
        v12 = (char *)(v16 - v5);
        do
        {
          v13 = *v5;
          v5[(_DWORD)v12] = *v5;
          ++v5;
        }
        while ( v13 );
      }
      if ( (unsigned __int8)sub_10025D30(v16) )
        sub_10025D10((int)v16);
      *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = sub_10025D40((int)v16, 1);
      v14 = *(_DWORD *)a1;
      if ( !*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) && v14 > 0 )
        *(_DWORD *)a1 = v14 - 1;
      return 1;
    }
    if ( *(_BYTE *)(a1 + 52) )
    {
      if ( v7 )
        ++*(_DWORD *)a1;
      goto LABEL_6;
    }
  }
  if ( v6 == 1 && v4 == 1 )
    return 1;
  return 0;
}
// 10025D30: using guessed type _DWORD __cdecl sub_10025D30(_DWORD);
// 1001B330: using guessed type char var_104[255];

//----- (1001B4B0) --------------------------------------------------------
signed int __cdecl sub_1001B4B0(int a1)
{
  signed int result; // eax@1
  int v2; // edx@1
  int v3; // edx@1

  result = 1;
  v2 = 16 * *(_DWORD *)a1;
  *(_DWORD *)(v2 + a1 + 4) = 0;
  v3 = v2 + a1 + 4;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 312) = 5;
  return result;
}

//----- (1001B4F0) --------------------------------------------------------
signed int __cdecl sub_1001B4F0(int a1, int a2, int a3)
{
  char *v3; // eax@3
  char v4; // cl@4
  signed int result; // eax@5

  switch ( a1 )
  {
    case 8:
    case 9:
      if ( *(_DWORD *)a2 != 5 )
        goto LABEL_6;
      v3 = (char *)(a2 + 4);
      do
      {
        v4 = *v3;
        v3[a3 + 53 - (a2 + 4)] = *v3;
        ++v3;
      }
      while ( v4 );
      *(_BYTE *)(a3 + 52) = a1 != 8;
      result = 0;
      break;
    case 10:
      if ( *(_DWORD *)a2 )
        goto LABEL_6;
      *(_BYTE *)(a3 + 53) = 0;
      *(_BYTE *)(a3 + 52) = 0;
      result = 0;
      break;
    case 11:
      if ( *(_DWORD *)a2 == 1 )
      {
        *(_BYTE *)(a3 + 309) = *(_BYTE *)(a2 + 4);
        result = 0;
      }
      else
      {
LABEL_6:
        result = 9;
      }
      break;
    default:
      result = 4;
      break;
  }
  return result;
}

//----- (1001B590) --------------------------------------------------------
char __cdecl sub_1001B590(int a1)
{
  int v1; // edx@3

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( *(_DWORD *)(a1 + 328) == 1 )
    {
      v1 = 16 * *(_DWORD *)a1 + a1 + 4;
      *(_DWORD *)v1 = 0;
      *(_DWORD *)(v1 + 4) = 0;
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 12) = 0;
      if ( *(_DWORD *)a1 > 0 )
        --*(_DWORD *)a1;
    }
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return *(_BYTE *)(a1 + 52);
}

//----- (1001B5F0) --------------------------------------------------------
char __cdecl sub_1001B5F0(int a1, void (__cdecl *a2)(int))
{
  char result; // al@6

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( a2 )
      a2(a1);
    sub_10025CF0(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    result = 1;
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return result;
}

//----- (1001B660) --------------------------------------------------------
char *__cdecl sub_1001B660(char *a1)
{
  char *v1; // esi@1
  size_t v2; // edi@1
  char *v3; // eax@1
  char *v4; // eax@2
  unsigned int v5; // eax@3
  char *v6; // eax@5
  char *v7; // eax@7

  v1 = a1;
  v2 = 255;
  v3 = strstr(a1, "$Id: ");
  if ( v3 )
  {
    v1 = v3 + 5;
    v4 = strchr(v3 + 5, 44);
    if ( v4 )
    {
      v5 = v4 - v1;
      if ( v5 < 0x100 )
        goto LABEL_9;
    }
  }
  else
  {
    v6 = strrchr(a1, 47);
    if ( v6 )
    {
      v1 = v6 + 1;
      v2 = strlen(v6 + 1);
    }
    v7 = strrchr(v1, 92);
    if ( v7 )
    {
      v1 = v7 + 1;
      v5 = strlen(v7 + 1);
LABEL_9:
      v2 = v5;
      goto LABEL_10;
    }
  }
LABEL_10:
  strncpy(&byte_10114BF0, v1, v2);
  *(&byte_10114BF0 + v2) = 0;
  return &byte_10114BF0;
}

//----- (1001B700) --------------------------------------------------------
int __cdecl sub_1001B700(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 44) = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 48) = a3;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 53) = 0;
  *(_BYTE *)(a1 + 309) = 1;
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1001B770) --------------------------------------------------------
bool __cdecl sub_1001B770(int a1, unsigned int a2, int a3)
{
  bool result; // al@9
  int v4; // ecx@11
  int v5; // edx@11
  int v6; // [sp+4h] [bp-4h]@3

  if ( a2 <= 4
    || sub_1003A3B9(*(_DWORD *)(a1 + 12), (int)"%d", (unsigned int)&a2) != 1
    || sub_1003A3B9(*(_DWORD *)(a1 + 16), (int)"%d", (unsigned int)&v6) != 1 )
  {
    result = 0;
    *(_BYTE *)(a3 + 316) = 0;
  }
  else
  {
    result = a2 == 4 || !a2 || a2 == 1 || a2 == 2 || a2 == 3;
    v4 = a3;
    *(_DWORD *)(a3 + 312) = a2;
    v5 = v6;
    *(_BYTE *)(v4 + 316) = result;
    *(_DWORD *)(v4 + 320) = v5;
  }
  return result;
}

//----- (1001B800) --------------------------------------------------------
char __cdecl sub_1001B800(int a1, int a2, char a3, char a4)
{
  int v4; // ecx@2
  int v5; // eax@3
  bool v6; // zf@3
  signed int v7; // eax@6
  char result; // al@14

  switch ( a2 )
  {
    case 3:
      v4 = a1;
      if ( a3 )
        goto LABEL_11;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 1;
      goto LABEL_4;
    case 7:
      v4 = a1;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 2;
LABEL_4:
      if ( !v6 && v5 != 3 )
        goto LABEL_12;
      v7 = *(_DWORD *)(v4 + 320);
      if ( v7 <= 1 )
      {
        *(_DWORD *)(v4 + 320) = 0;
LABEL_11:
        *(_DWORD *)(v4 + 312) = 5;
      }
      else
      {
        *(_DWORD *)(v4 + 320) = v7 - 1;
      }
LABEL_12:
      if ( *(_BYTE *)(v4 + 316) )
      {
        if ( *(_DWORD *)(v4 + 312) == 5 )
        {
          result = 1;
          *(_BYTE *)(v4 + 316) = 0;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = a4;
      }
      return result;
    default:
      v4 = a1;
      goto LABEL_11;
  }
}

//----- (1001B8B0) --------------------------------------------------------
char __cdecl sub_1001B8B0(int a1)
{
  return *(_BYTE *)(a1 + 316);
}

//----- (1001B8C0) --------------------------------------------------------
char __cdecl sub_1001B8C0(int a1, void (__cdecl *a2)(int))
{
  char v2; // bl@1

  v2 = 0;
  if ( !*(_BYTE *)(a1 + 52) && *(_DWORD *)(a1 + 324) > 0 || *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    v2 = 1;
    if ( a2 )
      a2(a1);
  }
  if ( *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    sub_10025CF0(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    v2 = 1;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return v2;
}

//----- (1001B940) --------------------------------------------------------
int (__cdecl *__cdecl sub_1001B940(int a1, const char *a2))(const char *)
{
  int v2; // edx@1
  int (__cdecl *result)(const char *); // eax@2

  v2 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
  if ( v2 )
  {
    result = (int (__cdecl *)(const char *))sub_10025DC0((int)a2, strlen(a2), v2);
  }
  else
  {
    result = *(int (__cdecl **)(const char *))(a1 + 44);
    if ( result )
      result = (int (__cdecl *)(const char *))result(a2);
  }
  return result;
}

//----- (1001B990) --------------------------------------------------------
signed int __cdecl sub_1001B990(int a1, void (__cdecl *a2)(int))
{
  signed int result; // eax@1

  sub_1001B8C0(a1, a2);
  result = 1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1001B9E0) --------------------------------------------------------
char *__cdecl sub_1001B9E0(int a1, int a2, int a3, size_t a4, char *a5)
{
  char v5; // cl@1
  int v6; // eax@1
  int v7; // esi@1
  int v8; // edi@2
  char *v9; // eax@14
  char *v10; // eax@14
  char *v11; // eax@15
  unsigned int v12; // ecx@19
  char v13; // cl@20
  bool v14; // zf@21
  const char *v15; // ecx@21
  char v17[256]; // [sp+Ch] [bp-104h]@8

  v5 = *(_BYTE *)a1;
  v6 = 0;
  v7 = 0;
  if ( !*(_BYTE *)a1 )
    goto LABEL_12;
  v8 = a1;
  do
  {
    if ( v5 == 46 )
    {
      v7 = v6;
    }
    else if ( v5 == 47 || v5 == 92 )
    {
      v6 = 0;
      v7 = 0;
      goto LABEL_9;
    }
    v17[v6++] = v5;
LABEL_9:
    v5 = *(_BYTE *)(v8++ + 1);
  }
  while ( v5 );
  if ( v7 )
  {
    v17[v7] = 0;
    goto LABEL_13;
  }
LABEL_12:
  v17[v6] = 0;
LABEL_13:
  switch ( a2 )
  {
    case 1:
      v9 = sub_100256B0("CFG_ActDir", (int)&unk_1005E69C);
      v10 = sub_100256B0("CFG_ActDirRuntime", (int)v9);
      break;
    case 2:
      v11 = sub_100256B0("CFG_ExpDir", (int)&unk_1005E69C);
      v10 = sub_100256B0("CFG_ExpDirRuntime", (int)v11);
      break;
    case 3:
      v10 = sub_100256B0("CFG_ActDir", (int)&unk_1005E69C);
      break;
    case 4:
      v10 = sub_100256B0("CFG_ExpDir", (int)&unk_1005E69C);
      break;
    default:
      v10 = (char *)&unk_1005E69C;
      break;
  }
  v12 = strlen(v10);
  if ( !v12 || (v13 = v10[v12 - 1], v13 == 47) || (v14 = v13 == 92, v15 = "/", v14) )
    v15 = (const char *)&unk_1005E69C;
  _snprintf(a5, a4, "%s%s%s_%s.bmp", v10, v15, v17, a3);
  a5[a4 - 1] = 0;
  return a5;
}
// 1001B9E0: using guessed type char var_104[256];

//----- (1001BB60) --------------------------------------------------------
int sub_1001BB60()
{
  return dword_101198E0[sub_10018D20()];
}
// 101198E0: using guessed type int dword_101198E0[];

//----- (1001BB70) --------------------------------------------------------
const char *__cdecl sub_1001BB70(unsigned int a1)
{
  const char *result; // eax@2

  if ( a1 >= 3 )
    result = "Unknown Type Of Testing";
  else
    result = off_1009A4B4[a1];
  return result;
}
// 1009A4B4: using guessed type char *off_1009A4B4[7];

//----- (1001BB90) --------------------------------------------------------
int __cdecl sub_1001BB90(int a1, int a2, int a3, int a4)
{
  char v5; // [sp+8h] [bp-204h]@1
  char v6; // [sp+107h] [bp-105h]@1
  char v7; // [sp+108h] [bp-104h]@1
  char v8; // [sp+207h] [bp-5h]@1

  _snprintf(&v5, 0x100u, "%d", a3);
  v6 = 0;
  _snprintf(&v7, 0x100u, "%d", a4);
  v8 = 0;
  return sub_1001B260(3, (int)"**SUBGROUP**", a1, a2, (int)&v5, (int)&v7);
}

//----- (1001BC40) --------------------------------------------------------
int __cdecl sub_1001BC40(int a1)
{
  int result; // eax@1

  result = sub_10018D20();
  dword_1011B9EC[result] = a1;
  return result;
}
// 1011B9EC: using guessed type int dword_1011B9EC[];

//----- (1001BC60) --------------------------------------------------------
int __cdecl sub_1001BC60(int a1)
{
  int result; // eax@1

  result = sub_10018D20();
  dword_101198E0[result] = a1;
  return result;
}
// 101198E0: using guessed type int dword_101198E0[];

//----- (1001BC80) --------------------------------------------------------
char *sub_1001BC80(char *a1, ...)
{
  int v1; // esi@1
  char *result; // eax@1
  va_list va; // [sp+10h] [bp+8h]@1

  va_start(va, a1);
  v1 = sub_10018D20() << 8;
  _vsnprintf(&byte_10114CF0[v1], 0x100u, a1, va);
  result = &byte_10114CF0[v1];
  byte_10114DEE[v1] = 42;
  byte_10114DEF[v1] = 0;
  return result;
}

//----- (1001BCC0) --------------------------------------------------------
char *__usercall sub_1001BCC0@<eax>(char a1@<al>, unsigned __int8 a2@<cl>)
{
  char *result; // eax@3

  if ( a2 && a2 != 1 )
    result = off_1009A4C8[a1 & 1];
  else
    result = off_1009A4C0[a2];
  return result;
}
// 1009A4C0: using guessed type char *off_1009A4C0[4];
// 1009A4C8: using guessed type char *off_1009A4C8[2];

//----- (1001BCE0) --------------------------------------------------------
char __usercall sub_1001BCE0@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5)
{
  const char *v5; // ebp@1
  int v6; // edi@1
  char v7; // cl@1
  char result; // al@5
  long double v9; // st7@6
  signed int v10; // eax@7
  int v11; // ecx@10
  int v12; // ebp@10
  int v13; // edx@10
  int v14; // edi@10
  int v15; // edi@16
  int v16; // eax@30
  char v17; // [sp+18h] [bp+4h]@1

  v5 = a2;
  v6 = sub_10018D20();
  v17 = a2[a3 - 2];
  v7 = v17;
  if ( v17 == 100 || v17 == 117 )
  {
    v16 = sub_1001BB60() - 1;
    if ( v16 )
    {
      if ( v16 == 1 )
      {
        strncpy((char *)(a1 + 1), v5, a4 - 1);
        *(_BYTE *)(a1 + 1) = 35;
        *(_BYTE *)a1 = 37;
        result = 0;
        *(_BYTE *)(a3 + a1 - 1) = 111;
      }
      else
      {
        strncpy((char *)a1, v5, a4);
        result = 0;
      }
    }
    else
    {
      strncpy((char *)(a1 + 1), v5, a4 - 1);
      *(_BYTE *)(a1 + 1) = 35;
      *(_BYTE *)a1 = 37;
      result = 0;
      *(_BYTE *)(a3 + a1 - 1) = 120;
    }
  }
  else if ( v17 == 102 || v17 == 103 )
  {
    v9 = fabs(a5);
    if ( 0.0 == v9 )
    {
      v10 = 0;
    }
    else
    {
      v10 = (signed int)floor(log10(v9));
      v7 = v17;
    }
    if ( v7 == 102 )
    {
      v11 = dword_1011CFE0[v6];
      v12 = dword_1011CFF4[v6];
      v13 = v11 + v10;
      v14 = v11 + v10;
      if ( v11 + v10 >= 9 )
        v14 = 9;
      if ( v11 <= v14 )
      {
        if ( v13 >= 9 )
          v13 = 9;
      }
      else
      {
        v13 = v11;
      }
    }
    else
    {
      v11 = dword_101198F4[v6];
      v12 = dword_1011B9D8[v6];
      v13 = v11 + v10;
      v15 = v11 + v10;
      if ( v11 + v10 >= 14 )
        v15 = 14;
      if ( v11 <= v15 )
      {
        if ( v13 >= 14 )
          v13 = 14;
      }
      else
      {
        v13 = v11;
      }
    }
    if ( v12 )
    {
      if ( v12 == 1 )
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
      else if ( v11 <= v10 || v10 < -4 )
      {
        _snprintf((char *)a1, a4, "%%.%de", v13);
        result = 1;
      }
      else
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
    }
    else
    {
      _snprintf((char *)a1, a4, "%%.%de", v13);
      result = 1;
    }
  }
  else
  {
    strncpy((char *)a1, v5, a4);
    result = 0;
  }
  return result;
}
// 101198F4: using guessed type int dword_101198F4[];
// 1011B9D8: using guessed type int dword_1011B9D8[];
// 1011CFE0: using guessed type int dword_1011CFE0[];
// 1011CFF4: using guessed type int dword_1011CFF4[];

//----- (1001BEC0) --------------------------------------------------------
int sub_1001BEC0()
{
  nullsub_1("..\\lib\\utf\\utf_verify.c", "2370");
  return 0;
}

//----- (1001BEE0) --------------------------------------------------------
int sub_1001BEE0()
{
  return nullsub_1("..\\lib\\utf\\utf_verify.c", "2396");
}

//----- (1001BF00) --------------------------------------------------------
int __cdecl sub_1001BF00(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_10018D20();
  dword_1011B9D8[result] = a1;
  if ( a2 >= 0 )
  {
    dword_101198F4[result] = a2;
    if ( a2 > 14 )
    {
      v3 = sub_1001BC80(
             "Floating point (double) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             14);
      result = sub_1001B220(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"909", (int)v3);
    }
  }
  else
  {
    dword_101198F4[result] = 8;
  }
  return result;
}
// 101198F4: using guessed type int dword_101198F4[];
// 1011B9D8: using guessed type int dword_1011B9D8[];

//----- (1001BF60) --------------------------------------------------------
int __cdecl sub_1001BF60(int a1)
{
  return sub_1001BF00(0, a1);
}

//----- (1001BF70) --------------------------------------------------------
int __cdecl sub_1001BF70(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_10018D20();
  dword_1011CFF4[result] = a1;
  if ( a2 >= 0 )
  {
    dword_1011CFE0[result] = a2;
    if ( a2 > 9 )
    {
      v3 = sub_1001BC80(
             "Floating point (float) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             9);
      result = sub_1001B220(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"977", (int)v3);
    }
  }
  else
  {
    dword_1011CFE0[result] = 8;
  }
  return result;
}
// 1011CFE0: using guessed type int dword_1011CFE0[];
// 1011CFF4: using guessed type int dword_1011CFF4[];

//----- (1001BFD0) --------------------------------------------------------
int __cdecl sub_1001BFD0(int a1)
{
  return sub_1001BF70(0, a1);
}

//----- (1001BFE0) --------------------------------------------------------
bool __cdecl sub_1001BFE0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  bool v8; // bl@4
  char *v9; // eax@7
  char *v10; // edx@7
  int v11; // esi@8
  int v12; // edi@19
  char *v14; // [sp+Ch] [bp-2Ch]@7
  int v15; // [sp+10h] [bp-28h]@7
  int v16; // [sp+14h] [bp-24h]@7
  int v17; // [sp+18h] [bp-20h]@7
  char *v18; // [sp+1Ch] [bp-1Ch]@7
  char *v19; // [sp+20h] [bp-18h]@7
  const char *v20; // [sp+24h] [bp-14h]@7
  char *v21; // [sp+28h] [bp-10h]@7
  char *v22; // [sp+2Ch] [bp-Ch]@7
  int v23; // [sp+30h] [bp-8h]@8
  int v24; // [sp+34h] [bp-4h]@8

  if ( a2 )
  {
    if ( a6 == 1 )
    {
      if ( a7 )
        goto LABEL_4;
    }
    else if ( a6 || a7 != 1 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
  else
  {
    if ( a6 == 1 )
    {
      if ( a7 != 1 )
      {
LABEL_4:
        v8 = 0;
        goto LABEL_5;
      }
    }
    else if ( a6 || a7 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
LABEL_5:
  if ( sub_10019C80() )
    v8 = v8 == 0;
  v9 = (&off_1009A498)[4 * a2];
  v15 = a3;
  v14 = v9;
  v17 = a5;
  v16 = a4;
  v20 = "bool";
  v10 = off_1009A488[v8 != 0];
  v19 = off_1009A490[a1];
  v18 = v10;
  v21 = sub_1001BCC0(0, a6);
  v22 = sub_1001BCC0(1, a7);
  if ( a8 )
  {
    v23 = 0;
    v24 = a8;
    v11 = 11;
  }
  else
  {
    v11 = 9;
  }
  v12 = sub_10025FA0();
  sub_1001B130(7, (int)&v14, v11);
  sub_10025FB0(v12);
  return v8;
}
// 1009A488: using guessed type char *off_1009A488[5];
// 1009A490: using guessed type char *off_1009A490[3];
// 1009A498: using guessed type char *off_1009A498;

//----- (1001C120) --------------------------------------------------------
bool __cdecl sub_1001C120(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  int v8; // edi@1
  unsigned __int8 v9; // al@14
  unsigned __int8 v10; // al@17
  int v11; // edi@25
  char *v12; // esi@26
  char *v13; // edx@28
  int v14; // ebx@30
  bool v16; // [sp+1Bh] [bp-5Dh]@2
  char v17; // [sp+1Fh] [bp-59h]@25
  unsigned int v18; // [sp+20h] [bp-58h]@1
  char *v19; // [sp+3Ch] [bp-3Ch]@28
  int v20; // [sp+40h] [bp-38h]@28
  int v21; // [sp+44h] [bp-34h]@28
  int v22; // [sp+48h] [bp-30h]@28
  char *v23; // [sp+4Ch] [bp-2Ch]@28
  char *v24; // [sp+50h] [bp-28h]@28
  const char *v25; // [sp+54h] [bp-24h]@28
  const char *v26; // [sp+58h] [bp-20h]@28
  const char *v27; // [sp+5Ch] [bp-1Ch]@28
  char *v28; // [sp+60h] [bp-18h]@28
  int v29; // [sp+64h] [bp-14h]@29
  char v30; // [sp+68h] [bp-10h]@25

  v8 = sub_10018D20();
  v18 = 9;
  switch ( a2 )
  {
    case 0:
      v16 = a6 == a7;
      break;
    case 1:
      v16 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 4:
      v16 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 6:
      if ( a7 )
        v9 = a7;
      else
        v9 = 0;
      if ( a6 < v9 )
        goto LABEL_38;
      v10 = a7;
      if ( (signed int)a7 >= 255 )
        v10 = -1;
      v16 = 1;
      if ( a6 > v10 )
LABEL_38:
        v16 = 0;
      v18 = 10;
      break;
    default:
LABEL_22:
      v16 = 0;
      break;
  }
  if ( sub_10019C80() )
    v16 = v16 == 0;
  sub_1001BCE0((int)&v30, "%c", 3, 0xCu, (double)a6);
  v11 = 3072 * v8;
  _snprintf(&byte_10115CE0[v11], 0x400u, &v30, a6);
  byte_101160DE[v11] = 42;
  byte_101160DF[v11] = 0;
  v17 = sub_1001BCE0((int)&v30, "%c", 3, 0xCu, (double)a7);
  _snprintf(&byte_101160E0[v11], 0x400u, &v30, a7);
  byte_101164DE[v11] = 42;
  byte_101164DF[v11] = 0;
  if ( v18 <= 9 )
  {
    v12 = &byte_101164E0[v11];
    byte_101164E0[v11] = 0;
  }
  else
  {
    v17 = sub_1001BCE0((int)&v30, "%c", 3, 0xCu, 0.0);
    v12 = &byte_101164E0[v11];
    _snprintf(&byte_101164E0[v11], 0x400u, &v30, 0);
    byte_101168DE[v11] = 42;
    byte_101168DF[v11] = 0;
  }
  v19 = (&off_1009A498)[4 * a2];
  v21 = a4;
  v22 = a5;
  v20 = a3;
  v25 = "char";
  v26 = &byte_10115CE0[v11];
  v27 = &byte_101160E0[v11];
  v13 = off_1009A490[a1];
  v23 = off_1009A488[v16 != 0];
  v24 = v13;
  v28 = v12;
  if ( a8 )
  {
    v29 = a8;
    v18 = 11;
  }
  v14 = sub_10025FA0();
  sub_1001B130(7, (int)&v19, v18);
  if ( v17 && a6 != a7 && fabs((double)(a6 - a7)) > 0.0 && !strcmp(v26, v27) )
  {
    nullsub_1(a3, a4);
    sub_1001B220(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10025FB0(v14);
  return v16;
}
// 1009A488: using guessed type char *off_1009A488[5];
// 1009A490: using guessed type char *off_1009A490[3];
// 1009A498: using guessed type char *off_1009A498;

//----- (1001C4D0) --------------------------------------------------------
bool __cdecl sub_1001C4D0(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9)
{
  double v9; // st6@1
  long double v10; // st7@4
  int v11; // edi@8
  int v12; // edi@21
  char *v13; // esi@22
  double v14; // st5@28
  double v15; // st3@30
  double v16; // st5@30
  char *v17; // ecx@37
  int v18; // ebx@39
  bool v20; // [sp+27h] [bp-61h]@10
  char v21; // [sp+2Bh] [bp-5Dh]@21
  unsigned int v22; // [sp+2Ch] [bp-5Ch]@8
  char *v23; // [sp+4Ch] [bp-3Ch]@37
  int v24; // [sp+50h] [bp-38h]@37
  int v25; // [sp+54h] [bp-34h]@37
  int v26; // [sp+58h] [bp-30h]@37
  char *v27; // [sp+5Ch] [bp-2Ch]@37
  char *v28; // [sp+60h] [bp-28h]@37
  const char *v29; // [sp+64h] [bp-24h]@37
  const char *v30; // [sp+68h] [bp-20h]@37
  const char *v31; // [sp+6Ch] [bp-1Ch]@37
  char *v32; // [sp+70h] [bp-18h]@37
  int v33; // [sp+74h] [bp-14h]@38
  char v34; // [sp+78h] [bp-10h]@21

  v9 = a8;
  if ( a2 != 6
    || -0.000001 != a8
    || (a7 >= 0.0 ? (v9 = a7 * 0.000001, v10 = 0.000001) : (v10 = 0.000001, v9 = -0.000001 * a7), v9 >= v10) )
  {
    v10 = v9;
  }
  v11 = sub_10018D20();
  v22 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 1:
      v20 = a7 != a6;
      break;
    case 2:
      if ( a7 != a6 && a7 < a6 )
        goto LABEL_18;
      goto LABEL_14;
    case 3:
      if ( a7 == a6 || a7 < a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 5:
      if ( a7 != a6 && a7 >= a6 )
        goto LABEL_18;
LABEL_14:
      v20 = 1;
      break;
    case 6:
      v14 = v10 - 1.797693134862316e308;
      if ( a7 > v10 - 1.797693134862316e308 )
        v14 = a7;
      v15 = v14;
      v16 = a7;
      if ( v15 - v10 > a6 )
        goto LABEL_47;
      if ( 1.797693134862316e308 - v10 <= a7 )
        v16 = 1.797693134862316e308 - v10;
      if ( v10 + v16 < a6 )
      {
LABEL_47:
        v20 = 0;
        v22 = 10;
      }
      else
      {
        v20 = 1;
        v22 = 10;
      }
      break;
    default:
LABEL_18:
      v20 = 0;
      break;
  }
  if ( sub_10019C80() )
    v20 = v20 == 0;
  sub_1001BCE0((int)&v34, (char *)&unk_1009A780, 3, 0xCu, a6);
  v12 = 3072 * v11;
  _snprintf(&byte_10115CE0[v12], 0x400u, &v34);
  byte_101160DE[v12] = 42;
  byte_101160DF[v12] = 0;
  v21 = sub_1001BCE0((int)&v34, (char *)&unk_1009A780, 3, 0xCu, a7);
  _snprintf(&byte_101160E0[v12], 0x400u, &v34, a7);
  byte_101164DE[v12] = 42;
  byte_101164DF[v12] = 0;
  if ( v22 <= 9 )
  {
    v13 = &byte_101164E0[v12];
    byte_101164E0[v12] = 0;
  }
  else
  {
    v13 = &byte_101164E0[v12];
    v21 = sub_1001BCE0((int)&v34, (char *)&unk_1009A780, 3, 0xCu, v10);
    _snprintf(&byte_101164E0[v12], 0x400u, &v34, LODWORD(v10), (_DWORD)(*(unsigned __int64 *)&v10 >> 32));
    byte_101168DE[v12] = 42;
    byte_101168DF[v12] = 0;
  }
  v23 = (&off_1009A498)[4 * a2];
  v26 = a5;
  v25 = a4;
  v24 = a3;
  v29 = "double";
  v30 = &byte_10115CE0[v12];
  v32 = v13;
  v17 = off_1009A490[a1];
  v27 = off_1009A488[v20 != 0];
  v28 = v17;
  v31 = &byte_101160E0[v12];
  if ( a9 )
  {
    v33 = a9;
    v22 = 11;
  }
  v18 = sub_10025FA0();
  sub_1001B130(7, (int)&v23, v22);
  if ( v21 && a6 != a7 && fabs(a6 - a7) > v10 && !strcmp(v30, v31) )
  {
    nullsub_1(a3, a4);
    sub_1001B220(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10025FB0(v18);
  return v20;
}
// 1009A488: using guessed type char *off_1009A488[5];
// 1009A490: using guessed type char *off_1009A490[3];
// 1009A498: using guessed type char *off_1009A498;

//----- (1001C920) --------------------------------------------------------
bool __cdecl sub_1001C920(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9)
{
  double v9; // st7@1
  double v10; // st6@1
  double v11; // st7@4
  float v12; // ST38_4@6
  double v13; // st7@6
  double v14; // st7@8
  double v15; // st6@8
  int v16; // edi@8
  double v17; // st5@24
  double v18; // st3@26
  double v19; // st5@26
  int v20; // edi@35
  char *v21; // esi@36
  char *v22; // ecx@38
  int v23; // ebx@40
  bool v25; // [sp+1Bh] [bp-59h]@10
  char v26; // [sp+1Fh] [bp-55h]@35
  unsigned int v27; // [sp+20h] [bp-54h]@8
  float v28; // [sp+24h] [bp-50h]@8
  char *v29; // [sp+38h] [bp-3Ch]@38
  int v30; // [sp+3Ch] [bp-38h]@38
  int v31; // [sp+40h] [bp-34h]@38
  int v32; // [sp+44h] [bp-30h]@38
  char *v33; // [sp+48h] [bp-2Ch]@38
  char *v34; // [sp+4Ch] [bp-28h]@38
  const char *v35; // [sp+50h] [bp-24h]@38
  const char *v36; // [sp+54h] [bp-20h]@38
  const char *v37; // [sp+58h] [bp-1Ch]@38
  char *v38; // [sp+5Ch] [bp-18h]@38
  int v39; // [sp+60h] [bp-14h]@39
  char v40; // [sp+64h] [bp-10h]@35

  v9 = a7;
  v10 = a8;
  if ( a2 != 6
    || -0.0000099999997 != v10
    || (v9 >= 0.0 ? (v11 = v9 * 0.000009999999747378752) : (v11 = v9 * -0.000009999999747378752),
        v12 = v11,
        v13 = 0.0000099999997,
        v10 = v12,
        v12 >= 0.0000099999997) )
  {
    v13 = v10;
  }
  v28 = v13;
  v14 = v28;
  v15 = a6;
  v16 = sub_10018D20();
  v27 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 1:
      v25 = a7 != a6;
      break;
    case 2:
      if ( a7 != v15 && a7 < (double)a6 )
        goto LABEL_32;
      goto LABEL_14;
    case 3:
      if ( a7 == v15 || a7 < (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 4:
      if ( a7 >= (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 5:
      if ( a7 != v15 && a7 >= (double)a6 )
        goto LABEL_32;
LABEL_14:
      v25 = 1;
      break;
    case 6:
      v17 = v14 - 3.402823466385289e38;
      if ( a7 > v14 - 3.402823466385289e38 )
        v17 = a7;
      v18 = v17 - v14;
      v19 = a7;
      if ( v18 > v15 )
        goto LABEL_48;
      if ( 3.402823466385289e38 - v14 <= v19 )
        v19 = 3.402823466385289e38 - v14;
      if ( v15 > v14 + v19 )
      {
LABEL_48:
        v25 = 0;
        v27 = 10;
      }
      else
      {
        v25 = 1;
        v27 = 10;
      }
      break;
    default:
LABEL_32:
      v25 = 0;
      break;
  }
  if ( sub_10019C80() )
    v25 = v25 == 0;
  sub_1001BCE0((int)&v40, "%f", 3, 0xCu, a6);
  v20 = 3072 * v16;
  _snprintf(&byte_10115CE0[v20], 0x400u, &v40);
  byte_101160DE[v20] = 42;
  byte_101160DF[v20] = 0;
  v26 = sub_1001BCE0((int)&v40, "%f", 3, 0xCu, a7);
  _snprintf(&byte_101160E0[v20], 0x400u, &v40, a7);
  byte_101164DE[v20] = 42;
  byte_101164DF[v20] = 0;
  if ( v27 <= 9 )
  {
    v21 = &byte_101164E0[v20];
    byte_101164E0[v20] = 0;
  }
  else
  {
    v21 = &byte_101164E0[v20];
    v26 = sub_1001BCE0((int)&v40, "%f", 3, 0xCu, v28);
    _snprintf(&byte_101164E0[v20], 0x400u, &v40, v28);
    byte_101168DE[v20] = 42;
    byte_101168DF[v20] = 0;
  }
  v29 = (&off_1009A498)[4 * a2];
  v32 = a5;
  v31 = a4;
  v30 = a3;
  v35 = "float";
  v36 = &byte_10115CE0[v20];
  v37 = &byte_101160E0[v20];
  v38 = v21;
  v22 = off_1009A488[v25 != 0];
  v34 = off_1009A490[a1];
  v33 = v22;
  if ( a9 )
  {
    v39 = a9;
    v27 = 11;
  }
  v23 = sub_10025FA0();
  sub_1001B130(7, (int)&v29, v27);
  if ( v26 && a7 != a6 && v28 < fabs(a6 - a7) && !strcmp(v36, v37) )
  {
    nullsub_1(a3, a4);
    sub_1001B220(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10025FB0(v23);
  return v25;
}
// 1009A488: using guessed type char *off_1009A488[5];
// 1009A490: using guessed type char *off_1009A490[3];
// 1009A498: using guessed type char *off_1009A498;

//----- (1001CDE0) --------------------------------------------------------
bool __cdecl sub_1001CDE0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  void *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10018D20();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10019C80() )
    v17 = v17 == 0;
  sub_1001BCE0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10115CE0[v12], 0x400u, &v31, a6);
  byte_101160DE[v12] = 42;
  byte_101160DF[v12] = 0;
  v18 = sub_1001BCE0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_101160E0[v12], 0x400u, &v31, a7);
  byte_101164DE[v12] = 42;
  byte_101164DF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101164E0[v12];
    byte_101164E0[v12] = 0;
  }
  else
  {
    v18 = sub_1001BCE0((int)&v31, "%d", 3, 0xCu, (double)a8);
    v13 = &byte_101164E0[v12];
    _snprintf(&byte_101164E0[v12], 0x400u, &v31, a8);
    byte_101168DE[v12] = 42;
    byte_101168DF[v12] = 0;
  }
  v20 = (&off_1009A498)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = &unk_1009A7BC;
  v27 = &byte_10115CE0[v12];
  v28 = &byte_101160E0[v12];
  v29 = v13;
  v14 = off_1009A488[v17 != 0];
  v25 = off_1009A490[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10025FA0();
  sub_1001B130(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1001B220(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10025FB0(v15);
  return v17;
}
// 1009A488: using guessed type char *off_1009A488[5];
// 1009A490: using guessed type char *off_1009A490[3];
// 1009A498: using guessed type char *off_1009A498;

//----- (1001D1A0) --------------------------------------------------------
bool __cdecl sub_1001D1A0(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9)
{
  int v9; // edi@1
  __int16 v10; // ax@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10018D20();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 0x8000;
      if ( v11 < a7 )
        LOWORD(v11) = a7;
      if ( a6 < (signed __int16)(v11 - a8) )
        goto LABEL_37;
      if ( 0x7FFF - a8 <= a7 )
        v10 = 0x7FFF - a8;
      v17 = 1;
      if ( a6 > (signed __int16)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10019C80() )
    v17 = v17 == 0;
  sub_1001BCE0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10115CE0[v12], 0x400u, &v31, a6);
  byte_101160DE[v12] = 42;
  byte_101160DF[v12] = 0;
  v18 = sub_1001BCE0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_101160E0[v12], 0x400u, &v31, a7);
  byte_101164DE[v12] = 42;
  byte_101164DF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101164E0[v12];
    byte_101164E0[v12] = 0;
  }
  else
  {
    v13 = &byte_101164E0[v12];
    v18 = sub_1001BCE0((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_101164E0[v12], 0x400u, &v31, a8);
    byte_101168DE[v12] = 42;
    byte_101168DF[v12] = 0;
  }
  v20 = (&off_1009A498)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_10115CE0[v12];
  v21 = a3;
  v26 = "sint16";
  v28 = &byte_101160E0[v12];
  v29 = v13;
  v14 = off_1009A490[a1];
  v24 = off_1009A488[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10025FA0();
  sub_1001B130(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1001B220(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10025FB0(v15);
  return v17;
}
// 1009A488: using guessed type char *off_1009A488[5];
// 1009A490: using guessed type char *off_1009A490[3];
// 1009A498: using guessed type char *off_1009A498;

//----- (1001D5A0) --------------------------------------------------------
bool __cdecl sub_1001D5A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10018D20();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10019C80() )
    v17 = v17 == 0;
  sub_1001BCE0((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10115CE0[v12], 0x400u, &v31, a6);
  byte_101160DE[v12] = 42;
  byte_101160DF[v12] = 0;
  v18 = sub_1001BCE0((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_101160E0[v12], 0x400u, &v31, a7);
  byte_101164DE[v12] = 42;
  byte_101164DF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101164E0[v12];
    byte_101164E0[v12] = 0;
  }
  else
  {
    v18 = sub_1001BCE0((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_101164E0[v12];
    _snprintf(&byte_101164E0[v12], 0x400u, &v31, a8);
    byte_101168DE[v12] = 42;
    byte_101168DF[v12] = 0;
  }
  v20 = (&off_1009A498)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "sint32";
  v27 = &byte_10115CE0[v12];
  v28 = &byte_101160E0[v12];
  v29 = v13;
  v14 = off_1009A488[v17 != 0];
  v25 = off_1009A490[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10025FA0();
  sub_1001B130(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1001B220(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10025FB0(v15);
  return v17;
}
// 1009A488: using guessed type char *off_1009A488[5];
// 1009A490: using guessed type char *off_1009A490[3];
// 1009A498: using guessed type char *off_1009A498;

//----- (1001D960) --------------------------------------------------------
bool __cdecl sub_1001D960(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9)
{
  unsigned int v9; // edx@22
  unsigned int v10; // esi@22
  unsigned int v11; // eax@27
  int v12; // ecx@27
  int v13; // edi@37
  char *v14; // esi@38
  char *v15; // edx@40
  int v16; // ebx@42
  bool v18; // [sp+1Bh] [bp-5Dh]@3
  char v19; // [sp+1Fh] [bp-59h]@37
  unsigned int v20; // [sp+20h] [bp-58h]@1
  int v21; // [sp+30h] [bp-48h]@1
  char *v22; // [sp+3Ch] [bp-3Ch]@40
  int v23; // [sp+40h] [bp-38h]@40
  int v24; // [sp+44h] [bp-34h]@40
  int v25; // [sp+48h] [bp-30h]@40
  char *v26; // [sp+4Ch] [bp-2Ch]@40
  char *v27; // [sp+50h] [bp-28h]@40
  const char *v28; // [sp+54h] [bp-24h]@40
  const char *v29; // [sp+58h] [bp-20h]@40
  const char *v30; // [sp+5Ch] [bp-1Ch]@40
  char *v31; // [sp+60h] [bp-18h]@40
  int v32; // [sp+64h] [bp-14h]@41
  char v33; // [sp+68h] [bp-10h]@37

  v21 = sub_10018D20();
  v20 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 1:
      v18 = a6 != a7;
      goto LABEL_35;
    case 2:
      if ( a6 != a7
        && SHIDWORD(a6) >= SHIDWORD(a7)
        && (SHIDWORD(a6) > SHIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || SHIDWORD(a6) > SHIDWORD(a7) )
        goto LABEL_34;
      if ( SHIDWORD(a6) < SHIDWORD(a7) )
      {
LABEL_9:
        v18 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_34:
        v18 = 0;
      }
      else
      {
        v18 = 1;
      }
LABEL_35:
      if ( sub_10019C80() )
        v18 = v18 == 0;
      sub_1001BCE0((int)&v33, "%I64d", 6, 0xCu, (double)a6);
      v13 = 3072 * v21;
      _snprintf(&byte_10115CE0[3072 * v21], 0x400u, &v33, a6);
      byte_101160DE[v13] = 42;
      byte_101160DF[v13] = 0;
      v19 = sub_1001BCE0((int)&v33, "%I64d", 6, 0xCu, (double)a7);
      _snprintf(&byte_101160E0[3072 * v21], 0x400u, &v33, a7);
      byte_101164DE[v13] = 42;
      byte_101164DF[v13] = 0;
      if ( v20 <= 9 )
      {
        v14 = &byte_101164E0[v13];
        byte_101164E0[v13] = 0;
      }
      else
      {
        v19 = sub_1001BCE0((int)&v33, "%I64d", 6, 0xCu, (double)a8);
        v14 = &byte_101164E0[v13];
        _snprintf(&byte_101164E0[v13], 0x400u, &v33, a8);
        byte_101168DE[v13] = 42;
        byte_101168DF[v13] = 0;
      }
      v22 = (&off_1009A498)[4 * a2];
      v24 = a4;
      v25 = a5;
      v23 = a3;
      v28 = "sint64";
      v29 = &byte_10115CE0[3072 * v21];
      v30 = &byte_101160E0[3072 * v21];
      v15 = off_1009A490[a1];
      v26 = off_1009A488[v18 != 0];
      v27 = v15;
      v31 = v14;
      if ( a9 )
      {
        v32 = a9;
        v20 = 11;
      }
      v16 = sub_10025FA0();
      sub_1001B130(7, (int)&v22, v20);
      if ( v19 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v29, v30) )
      {
        nullsub_1(a3, a4);
        sub_1001B220(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_10025FB0(v16);
      return v18;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 5:
      if ( a6 != a7
        && SHIDWORD(a6) <= SHIDWORD(a7)
        && (SHIDWORD(a6) < SHIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      v18 = 1;
      goto LABEL_35;
    case 6:
      v9 = a8;
      v10 = HIDWORD(a8) + 2147483648;
      if ( (signed int)(HIDWORD(a8) + 2147483648) < SHIDWORD(a7)
        || (signed int)(HIDWORD(a8) + 2147483648) <= SHIDWORD(a7) && (unsigned int)a8 < (unsigned int)a7 )
      {
        v10 = HIDWORD(a7);
        v9 = a7;
      }
      if ( a6 < (signed __int64)(__PAIR__(v10, v9) - a8) )
        goto LABEL_50;
      v11 = -1 - a8;
      v12 = 0x7FFFFFFF - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > SHIDWORD(a7) || v12 >= SHIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_50:
        v18 = 0;
        v20 = 10;
      }
      else
      {
        v18 = 1;
        v20 = 10;
      }
      goto LABEL_35;
    default:
      goto LABEL_34;
  }
}
// 1009A488: using guessed type char *off_1009A488[5];
// 1009A490: using guessed type char *off_1009A490[3];
// 1009A498: using guessed type char *off_1009A498;

//----- (1001DEA0) --------------------------------------------------------
bool __cdecl sub_1001DEA0(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9)
{
  int v9; // edi@1
  char v10; // al@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10018D20();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 128;
      if ( v11 < a7 )
        LOBYTE(v11) = a7;
      if ( a6 < (char)(v11 - a8) )
        goto LABEL_37;
      if ( 127 - a8 <= a7 )
        v10 = 127 - a8;
      v17 = 1;
      if ( a6 > (char)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10019C80() )
    v17 = v17 == 0;
  sub_1001BCE0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10115CE0[v12], 0x400u, &v31, a6);
  byte_101160DE[v12] = 42;
  byte_101160DF[v12] = 0;
  v18 = sub_1001BCE0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_101160E0[v12], 0x400u, &v31, a7);
  byte_101164DE[v12] = 42;
  byte_101164DF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101164E0[v12];
    byte_101164E0[v12] = 0;
  }
  else
  {
    v13 = &byte_101164E0[v12];
    v18 = sub_1001BCE0((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_101164E0[v12], 0x400u, &v31, a8);
    byte_101168DE[v12] = 42;
    byte_101168DF[v12] = 0;
  }
  v20 = (&off_1009A498)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_10115CE0[v12];
  v21 = a3;
  v26 = "sint8";
  v28 = &byte_101160E0[v12];
  v29 = v13;
  v14 = off_1009A490[a1];
  v24 = off_1009A488[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10025FA0();
  sub_1001B130(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1001B220(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10025FB0(v15);
  return v17;
}
// 1009A488: using guessed type char *off_1009A488[5];
// 1009A490: using guessed type char *off_1009A490[3];
// 1009A498: using guessed type char *off_1009A498;

//----- (1001E280) --------------------------------------------------------
bool __cdecl sub_1001E280(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10018D20();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10019C80() )
    v17 = v17 == 0;
  sub_1001BCE0((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10115CE0[v12], 0x400u, &v31, a6);
  byte_101160DE[v12] = 42;
  byte_101160DF[v12] = 0;
  v18 = sub_1001BCE0((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_101160E0[v12], 0x400u, &v31, a7);
  byte_101164DE[v12] = 42;
  byte_101164DF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101164E0[v12];
    byte_101164E0[v12] = 0;
  }
  else
  {
    v18 = sub_1001BCE0((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_101164E0[v12];
    _snprintf(&byte_101164E0[v12], 0x400u, &v31, a8);
    byte_101168DE[v12] = 42;
    byte_101168DF[v12] = 0;
  }
  v20 = (&off_1009A498)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "long int";
  v27 = &byte_10115CE0[v12];
  v28 = &byte_101160E0[v12];
  v29 = v13;
  v14 = off_1009A488[v17 != 0];
  v25 = off_1009A490[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10025FA0();
  sub_1001B130(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1001B220(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10025FB0(v15);
  return v17;
}
// 1009A488: using guessed type char *off_1009A488[5];
// 1009A490: using guessed type char *off_1009A490[3];
// 1009A498: using guessed type char *off_1009A498;

//----- (1001E640) --------------------------------------------------------
bool __cdecl sub_1001E640(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10018D20();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10019C80() )
    v17 = v17 == 0;
  sub_1001BCE0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10115CE0[v12], 0x400u, &v31, a6);
  byte_101160DE[v12] = 42;
  byte_101160DF[v12] = 0;
  v18 = sub_1001BCE0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_101160E0[v12], 0x400u, &v31, a7);
  byte_101164DE[v12] = 42;
  byte_101164DF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101164E0[v12];
    byte_101164E0[v12] = 0;
  }
  else
  {
    v18 = sub_1001BCE0((int)&v31, "%u", 3, 0xCu, (double)a8);
    v13 = &byte_101164E0[v12];
    _snprintf(&byte_101164E0[v12], 0x400u, &v31, a8);
    byte_101168DE[v12] = 42;
    byte_101168DF[v12] = 0;
  }
  v20 = (&off_1009A498)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned int";
  v29 = v13;
  v14 = off_1009A488[v17 != 0];
  v25 = off_1009A490[a1];
  v24 = v14;
  v27 = &byte_10115CE0[v12];
  v28 = &byte_101160E0[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10025FA0();
  sub_1001B130(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1001B220(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10025FB0(v15);
  return v17;
}
// 1009A488: using guessed type char *off_1009A488[5];
// 1009A490: using guessed type char *off_1009A490[3];
// 1009A498: using guessed type char *off_1009A498;

//----- (1001E9E0) --------------------------------------------------------
bool __cdecl sub_1001E9E0(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9)
{
  int v9; // edi@1
  unsigned __int16 v10; // ax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10018D20();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int16)(v10 - a8) )
        goto LABEL_37;
      v11 = 0xFFFF - a8;
      if ( v11 > a7 )
        LOWORD(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int16)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10019C80() )
    v17 = v17 == 0;
  sub_1001BCE0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10115CE0[v12], 0x400u, &v31, a6);
  byte_101160DE[v12] = 42;
  byte_101160DF[v12] = 0;
  v18 = sub_1001BCE0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_101160E0[v12], 0x400u, &v31, a7);
  byte_101164DE[v12] = 42;
  byte_101164DF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101164E0[v12];
    byte_101164E0[v12] = 0;
  }
  else
  {
    v13 = &byte_101164E0[v12];
    v18 = sub_1001BCE0((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_101164E0[v12], 0x400u, &v31, a8);
    byte_101168DE[v12] = 42;
    byte_101168DF[v12] = 0;
  }
  v20 = (&off_1009A498)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_10115CE0[v12];
  v21 = a3;
  v26 = "uint16";
  v28 = &byte_101160E0[v12];
  v29 = v13;
  v14 = off_1009A490[a1];
  v24 = off_1009A488[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10025FA0();
  sub_1001B130(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1001B220(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10025FB0(v15);
  return v17;
}
// 1009A488: using guessed type char *off_1009A488[5];
// 1009A490: using guessed type char *off_1009A490[3];
// 1009A498: using guessed type char *off_1009A498;

//----- (1001EDE0) --------------------------------------------------------
bool __cdecl sub_1001EDE0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10018D20();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10019C80() )
    v17 = v17 == 0;
  sub_1001BCE0((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10115CE0[v12], 0x400u, &v31, a6);
  byte_101160DE[v12] = 42;
  byte_101160DF[v12] = 0;
  v18 = sub_1001BCE0((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_101160E0[v12], 0x400u, &v31, a7);
  byte_101164DE[v12] = 42;
  byte_101164DF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101164E0[v12];
    byte_101164E0[v12] = 0;
  }
  else
  {
    v18 = sub_1001BCE0((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_101164E0[v12];
    _snprintf(&byte_101164E0[v12], 0x400u, &v31, a8);
    byte_101168DE[v12] = 42;
    byte_101168DF[v12] = 0;
  }
  v20 = (&off_1009A498)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "uint32";
  v29 = v13;
  v14 = off_1009A488[v17 != 0];
  v25 = off_1009A490[a1];
  v24 = v14;
  v27 = &byte_10115CE0[v12];
  v28 = &byte_101160E0[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10025FA0();
  sub_1001B130(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1001B220(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10025FB0(v15);
  return v17;
}
// 1009A488: using guessed type char *off_1009A488[5];
// 1009A490: using guessed type char *off_1009A490[3];
// 1009A498: using guessed type char *off_1009A498;

//----- (1001F180) --------------------------------------------------------
bool __cdecl sub_1001F180(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9)
{
  unsigned int v9; // esi@22
  unsigned int v10; // edx@23
  unsigned int v11; // eax@26
  unsigned int v12; // ecx@26
  int v13; // edi@36
  char *v14; // ebx@36
  char *v15; // esi@37
  char *v16; // ecx@39
  int v17; // ebx@41
  bool v19; // [sp+18h] [bp-64h]@3
  char v20; // [sp+27h] [bp-55h]@36
  unsigned int v21; // [sp+28h] [bp-54h]@1
  int v22; // [sp+2Ch] [bp-50h]@1
  char *v23; // [sp+2Ch] [bp-50h]@36
  char *v24; // [sp+40h] [bp-3Ch]@39
  int v25; // [sp+44h] [bp-38h]@39
  int v26; // [sp+48h] [bp-34h]@39
  int v27; // [sp+4Ch] [bp-30h]@39
  char *v28; // [sp+50h] [bp-2Ch]@39
  char *v29; // [sp+54h] [bp-28h]@39
  const char *v30; // [sp+58h] [bp-24h]@39
  const char *v31; // [sp+5Ch] [bp-20h]@39
  const char *v32; // [sp+60h] [bp-1Ch]@39
  char *v33; // [sp+64h] [bp-18h]@39
  int v34; // [sp+68h] [bp-14h]@40
  char v35; // [sp+6Ch] [bp-10h]@36

  v22 = sub_10018D20();
  v21 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 1:
      v19 = a6 != a7;
      goto LABEL_34;
    case 2:
      if ( a6 != a7 && HIDWORD(a6) >= HIDWORD(a7) && (HIDWORD(a6) > HIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
        goto LABEL_33;
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || HIDWORD(a6) > HIDWORD(a7) )
        goto LABEL_33;
      if ( HIDWORD(a6) < HIDWORD(a7) )
      {
LABEL_9:
        v19 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_33:
        v19 = 0;
      }
      else
      {
        v19 = 1;
      }
LABEL_34:
      if ( sub_10019C80() )
        v19 = v19 == 0;
      sub_1001BCE0((int)&v35, "%I64u", 6, 0xCu, (double)a6);
      v13 = 3072 * v22;
      v14 = &byte_10115CE0[3072 * v22];
      _snprintf(&byte_10115CE0[3072 * v22], 0x400u, &v35, a6);
      byte_101160DE[v13] = 42;
      byte_101160DF[v13] = 0;
      v20 = sub_1001BCE0((int)&v35, "%I64u", 6, 0xCu, (double)a7);
      v23 = &byte_101160E0[3072 * v22];
      _snprintf(&byte_101160E0[v13], 0x400u, &v35, a7);
      byte_101164DE[v13] = 42;
      byte_101164DF[v13] = 0;
      if ( v21 <= 9 )
      {
        v15 = &byte_101164E0[v13];
        byte_101164E0[v13] = 0;
      }
      else
      {
        v20 = sub_1001BCE0((int)&v35, "%I64u", 6, 0xCu, (double)a8);
        v15 = &byte_101164E0[v13];
        _snprintf(&byte_101164E0[v13], 0x400u, &v35, a8);
        byte_101168DE[v13] = 42;
        byte_101168DF[v13] = 0;
      }
      v24 = (&off_1009A498)[4 * a2];
      v27 = a5;
      v26 = a4;
      v33 = v15;
      v25 = a3;
      v30 = "uint64";
      v31 = v14;
      v16 = off_1009A490[a1];
      v28 = off_1009A488[v19 != 0];
      v29 = v16;
      v32 = v23;
      if ( a9 )
      {
        v34 = a9;
        v21 = 11;
      }
      v17 = sub_10025FA0();
      sub_1001B130(7, (int)&v24, v21);
      if ( v20 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v31, v32) )
      {
        nullsub_1(a3, a4);
        sub_1001B220(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_10025FB0(v17);
      return v19;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 5:
      if ( a6 != a7 && HIDWORD(a6) <= HIDWORD(a7) && (HIDWORD(a6) < HIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 6:
      v9 = HIDWORD(a7);
      if ( a8 < a7 )
      {
        v10 = a7;
      }
      else
      {
        v9 = HIDWORD(a8);
        v10 = a8;
      }
      if ( a6 < __PAIR__(v9, v10) - a8 )
        goto LABEL_49;
      v11 = -1 - a8;
      v12 = -1 - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > HIDWORD(a7) || v12 >= HIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_49:
        v19 = 0;
        v21 = 10;
      }
      else
      {
        v19 = 1;
        v21 = 10;
      }
      goto LABEL_34;
    default:
      goto LABEL_33;
  }
}
// 1009A488: using guessed type char *off_1009A488[5];
// 1009A490: using guessed type char *off_1009A490[3];
// 1009A498: using guessed type char *off_1009A498;

//----- (1001F760) --------------------------------------------------------
bool __cdecl sub_1001F760(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9)
{
  int v9; // edi@1
  unsigned __int8 v10; // al@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10018D20();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int8)(v10 - a8) )
        goto LABEL_37;
      v11 = 255 - a8;
      if ( v11 > a7 )
        LOBYTE(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int8)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10019C80() )
    v17 = v17 == 0;
  sub_1001BCE0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10115CE0[v12], 0x400u, &v31, a6);
  byte_101160DE[v12] = 42;
  byte_101160DF[v12] = 0;
  v18 = sub_1001BCE0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_101160E0[v12], 0x400u, &v31, a7);
  byte_101164DE[v12] = 42;
  byte_101164DF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101164E0[v12];
    byte_101164E0[v12] = 0;
  }
  else
  {
    v13 = &byte_101164E0[v12];
    v18 = sub_1001BCE0((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_101164E0[v12], 0x400u, &v31, a8);
    byte_101168DE[v12] = 42;
    byte_101168DF[v12] = 0;
  }
  v20 = (&off_1009A498)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_10115CE0[v12];
  v21 = a3;
  v26 = "uint8";
  v28 = &byte_101160E0[v12];
  v29 = v13;
  v14 = off_1009A490[a1];
  v24 = off_1009A488[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10025FA0();
  sub_1001B130(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1001B220(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10025FB0(v15);
  return v17;
}
// 1009A488: using guessed type char *off_1009A488[5];
// 1009A490: using guessed type char *off_1009A490[3];
// 1009A498: using guessed type char *off_1009A498;

//----- (1001FB50) --------------------------------------------------------
bool __cdecl sub_1001FB50(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10018D20();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10019C80() )
    v17 = v17 == 0;
  sub_1001BCE0((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10115CE0[v12], 0x400u, &v31, a6);
  byte_101160DE[v12] = 42;
  byte_101160DF[v12] = 0;
  v18 = sub_1001BCE0((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_101160E0[v12], 0x400u, &v31, a7);
  byte_101164DE[v12] = 42;
  byte_101164DF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101164E0[v12];
    byte_101164E0[v12] = 0;
  }
  else
  {
    v18 = sub_1001BCE0((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_101164E0[v12];
    _snprintf(&byte_101164E0[v12], 0x400u, &v31, a8);
    byte_101168DE[v12] = 42;
    byte_101168DF[v12] = 0;
  }
  v20 = (&off_1009A498)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned long int";
  v29 = v13;
  v14 = off_1009A488[v17 != 0];
  v25 = off_1009A490[a1];
  v24 = v14;
  v27 = &byte_10115CE0[v12];
  v28 = &byte_101160E0[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10025FA0();
  sub_1001B130(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1001B220(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10025FB0(v15);
  return v17;
}
// 1009A488: using guessed type char *off_1009A488[5];
// 1009A490: using guessed type char *off_1009A490[3];
// 1009A498: using guessed type char *off_1009A498;

//----- (1001FEF0) --------------------------------------------------------
int sub_1001FEF0()
{
  int v0; // esi@1
  int result; // eax@1

  v0 = sub_10018D20();
  sub_1001BC40(1);
  sub_1001BFD0(-1);
  result = sub_1001BF60(-1);
  dword_101198E0[v0] = 0;
  return result;
}
// 101198E0: using guessed type int dword_101198E0[];

//----- (1001FF20) --------------------------------------------------------
BOOL __usercall sub_1001FF20@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6)
{
  const char **v6; // ebp@1
  _BYTE *v7; // esi@1
  int v8; // edi@1
  int v9; // esi@6
  const char *v11; // [sp+Ch] [bp-34h]@6
  char v12; // [sp+10h] [bp-30h]@1
  char v13; // [sp+20h] [bp-20h]@1
  char v14; // [sp+30h] [bp-10h]@1

  v6 = a6;
  v7 = a1;
  LOBYTE(a6) = 0;
  v8 = sub_10018D20();
  sub_10025FE0((int)&v13);
  sub_10025FE0((int)&v14);
  sub_10025FE0((int)&v12);
  if ( !v7 || !*v7 )
  {
    v11 = "Actual file not supplied";
    goto LABEL_13;
  }
  if ( !a2 || !*a2 )
  {
    v11 = "Expected file not supplied";
LABEL_13:
    v9 = 1;
    goto LABEL_14;
  }
  if ( sub_10026C30((int (__cdecl *)(unsigned int))sub_1001BEC0, v7, (int)&v13) )
  {
    if ( sub_10026C30((int (__cdecl *)(unsigned int))sub_1001BEC0, a2, (int)&v14) )
    {
      v9 = sub_10026AA0(
             dword_1011B9EC[v8],
             (int)&v13,
             (int)&v14,
             a3,
             a4,
             (int (__cdecl *)(unsigned int))sub_1001BEC0,
             (void (__cdecl *)(_DWORD))sub_1001BEE0,
             (int)&v12,
             (char *)&a6,
             &v11);
      if ( (_BYTE)a6 )
        sub_10026ED0((int)&v12, a5);
    }
    else
    {
      v11 = "Expected bitmap file read failed";
      v9 = 2;
    }
  }
  else
  {
    v11 = "Actual bitmap file read failed";
    v9 = 2;
  }
LABEL_14:
  sub_100260B0((void (__cdecl *)(_DWORD))sub_1001BEE0, (int)&v12);
  sub_100260B0((void (__cdecl *)(_DWORD))sub_1001BEE0, (int)&v13);
  sub_100260B0((void (__cdecl *)(_DWORD))sub_1001BEE0, (int)&v14);
  if ( v6 )
    *v6 = v11;
  return v9 == 0;
}
// 1011B9EC: using guessed type int dword_1011B9EC[];

//----- (10020090) --------------------------------------------------------
bool __usercall sub_10020090@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9)
{
  const char *v9; // ebp@1
  const char *v10; // esi@1
  unsigned int v11; // ebx@8
  unsigned int v12; // edi@8
  bool v13; // zf@11
  bool v14; // bl@13
  int v15; // esi@15
  char *v16; // eax@15
  char *v17; // edx@15
  char *v18; // ecx@15
  int v19; // esi@16
  int v20; // edi@18
  const char *v22; // [sp+14h] [bp-148h]@1
  int v23; // [sp+18h] [bp-144h]@1
  int v24; // [sp+24h] [bp-138h]@1
  int v25; // [sp+28h] [bp-134h]@1
  char *v26; // [sp+2Ch] [bp-130h]@15
  int v27; // [sp+30h] [bp-12Ch]@15
  int v28; // [sp+34h] [bp-128h]@15
  int v29; // [sp+38h] [bp-124h]@15
  char *v30; // [sp+3Ch] [bp-120h]@15
  char *v31; // [sp+40h] [bp-11Ch]@15
  const char *v32; // [sp+44h] [bp-118h]@15
  char *v33; // [sp+48h] [bp-114h]@15
  char *v34; // [sp+4Ch] [bp-110h]@15
  int v35; // [sp+50h] [bp-10Ch]@16
  int v36; // [sp+54h] [bp-108h]@16
  char v37; // [sp+58h] [bp-104h]@9
  char v38; // [sp+156h] [bp-6h]@9
  char v39; // [sp+157h] [bp-5h]@9

  v9 = a6;
  v10 = a7;
  v25 = a2;
  v23 = a1;
  v22 = a7;
  v24 = sub_10018D20();
  if ( !a6 )
    v9 = "(NULL)";
  if ( !a7 )
  {
    v22 = "(NULL)";
    v10 = "(NULL)";
  }
  if ( a8 )
  {
    if ( !a4 && !sub_10019C80() )
    {
      v11 = strlen(v9);
      v12 = strlen(v10);
      if ( v11 != v12 )
      {
        _snprintf(&v37, 0x100u, "%s - strlen()", v23);
        v38 = 42;
        v39 = 0;
        sub_1001E640(0, 0, (int)"..\\lib\\utf\\utf_verify.c", (int)"2499", (int)&v37, v11, v12, 0, 0);
      }
    }
  }
  if ( !strcmp(v9, v10) )
    v13 = a4 == 0;
  else
    v13 = a4 == 1;
  v14 = v13;
  if ( sub_10019C80() )
    v14 = v14 == 0;
  v15 = 3072 * v24;
  _snprintf(&byte_10115CE0[3072 * v24], 0x400u, "%s", v9);
  byte_101160DE[v15] = 42;
  byte_101160DF[v15] = 0;
  _snprintf(&byte_101160E0[3072 * v24], 0x400u, "%s", v22);
  v16 = (&off_1009A498)[4 * a4];
  v27 = a5;
  v26 = v16;
  v29 = v23;
  v28 = v25;
  byte_101164DE[v15] = 42;
  v17 = off_1009A488[v14 != 0];
  v18 = off_1009A490[a3];
  byte_101164DF[v15] = 0;
  v30 = v17;
  v31 = v18;
  v32 = "string";
  v33 = &byte_10115CE0[3072 * v24];
  v34 = &byte_101160E0[3072 * v24];
  if ( a9 )
  {
    v35 = 0;
    v36 = a9;
    v19 = 11;
  }
  else
  {
    v19 = 9;
  }
  v20 = sub_10025FA0();
  sub_1001B130(7, (int)&v26, v19);
  sub_10025FB0(v20);
  return v14;
}
// 1009A488: using guessed type char *off_1009A488[5];
// 1009A490: using guessed type char *off_1009A490[3];
// 1009A498: using guessed type char *off_1009A498;

//----- (10020300) --------------------------------------------------------
char __cdecl sub_10020300(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  int v9; // esi@1
  int v10; // esi@4
  char *v11; // eax@4
  char v12; // cl@5
  char *v13; // eax@6
  char v14; // cl@7
  char v15; // bl@8
  char *v16; // edx@10
  bool v17; // zf@10
  int v18; // esi@12
  int v19; // edi@17
  unsigned int v21; // [sp+10h] [bp-258h]@2
  char *v22; // [sp+14h] [bp-254h]@4
  int v23; // [sp+18h] [bp-250h]@1
  char *v24; // [sp+1Ch] [bp-24Ch]@4
  int v25; // [sp+20h] [bp-248h]@1
  char *v26; // [sp+24h] [bp-244h]@4
  char *v27; // [sp+28h] [bp-240h]@4
  int v28; // [sp+2Ch] [bp-23Ch]@1
  int v29; // [sp+30h] [bp-238h]@1
  char *v30; // [sp+34h] [bp-234h]@10
  int v31; // [sp+38h] [bp-230h]@10
  int v32; // [sp+3Ch] [bp-22Ch]@10
  int v33; // [sp+40h] [bp-228h]@10
  char *v34; // [sp+44h] [bp-224h]@10
  char *v35; // [sp+48h] [bp-220h]@10
  const char *v36; // [sp+4Ch] [bp-21Ch]@10
  char *v37; // [sp+50h] [bp-218h]@12
  char *v38; // [sp+54h] [bp-214h]@12
  char *v39; // [sp+58h] [bp-210h]@12
  char *v40; // [sp+5Ch] [bp-20Ch]@14
  char v41[2]; // [sp+64h] [bp-204h]@2
  char v42; // [sp+163h] [bp-105h]@3
  char v43; // [sp+164h] [bp-104h]@14
  char v44; // [sp+263h] [bp-5h]@14

  v28 = a4;
  v23 = a5;
  v25 = a7;
  v9 = sub_10018D20();
  v29 = v9;
  if ( a8 == 65278 )
  {
    v21 = dword_1011B9EC[v9] != 0 ? 0x32 : 0;
    strcpy(v41, "0");
  }
  else
  {
    v21 = a8;
    _snprintf(v41, 0x100u, "%u", a8);
    v42 = 0;
  }
  v10 = 560 * v9;
  v22 = &byte_1011D008[v10];
  sub_1001B9E0(a3, 1, a6, 0x230u, &byte_1011D008[v10]);
  v27 = &byte_10119908[v10];
  sub_1001B9E0(a3, 2, a7, 0x230u, &byte_10119908[v10]);
  v24 = &byte_1011AEE8[v10];
  sub_1001B9E0(a3, 3, a6, 0x230u, &byte_1011AEE8[v10]);
  v26 = &byte_1011BA00[v10];
  sub_1001B9E0(a3, 4, a7, 0x230u, &byte_1011BA00[v10]);
  _snprintf(&byte_1011C4F0[v10], 0x230u, "%s_Diff_", a6);
  v11 = &byte_1011C4F0[v10];
  byte_1011C71F[v10] = 0;
  do
    v12 = *v11++;
  while ( v12 );
  sub_1001B9E0(a3, 0, v25, 560 - (v11 - &byte_1011C4F0[v10 + 1]), &byte_1011C4F0[v10] + v11 - &byte_1011C4F0[v10 + 1]);
  v13 = &byte_1011C4F0[v10];
  byte_1011C71F[v10] = 0;
  do
    v14 = *v13++;
  while ( v14 );
  *(&byte_1011C4EC[v10] + v13 - &byte_1011C4F0[v10 + 1]) = 0;
  sub_1001B9E0(a3, 1, (int)&byte_1011C4F0[v10], 0x230u, &byte_101151F0[v10]);
  sub_1001B9E0(a3, 1, (int)&byte_1011C4F0[v10], 0x230u, &byte_1011A3F8[v10]);
  v15 = sub_1001FF20(v22, v27, v21, a2 == 1, (int)&byte_101151F0[v10], (const char **)&v22);
  if ( sub_10019C80() )
    v15 = v15 == 0;
  v30 = (&off_1009A498)[4 * a2];
  v32 = v28;
  v33 = v23;
  v31 = a3;
  v36 = "bitmap-strict";
  v16 = off_1009A490[a1];
  v34 = off_1009A488[v15 != 0];
  v17 = dword_1011B9EC[v29] == 0;
  v35 = v16;
  if ( !v17 )
    v36 = "bitmap-lenient";
  v37 = v24;
  v38 = v26;
  v39 = v41;
  v18 = 10;
  if ( !v15 && v22 )
  {
    _snprintf(&v43, 0x100u, "Info: %s", v22);
    v44 = 0;
    v40 = &v43;
    v18 = 11;
  }
  if ( a9 )
    (&v30)[4 * v18++] = (char *)a9;
  v19 = sub_10025FA0();
  sub_1001B130(7, (int)&v30, v18);
  sub_10025FB0(v19);
  return v15;
}
// 1009A488: using guessed type char *off_1009A488[5];
// 1009A490: using guessed type char *off_1009A490[3];
// 1009A498: using guessed type char *off_1009A498;
// 1011B9EC: using guessed type int dword_1011B9EC[];

//----- (10020600) --------------------------------------------------------
bool __cdecl sub_10020600(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v9; // [sp+Ch] [bp-104h]@1
  char v10; // [sp+10Ah] [bp-6h]@1
  char v11; // [sp+10Bh] [bp-5h]@1

  _snprintf(&v9, 0x100u, "%s (ptr diff)", a5);
  v10 = 42;
  v11 = 0;
  return sub_1001CDE0(a1, a2, a3, a4, (int)&v9, a6 - a7, 0, 0, a8);
}

//----- (100206B0) --------------------------------------------------------
bool __cdecl sub_100206B0(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8)
{
  return sub_10020090(a5, a4, a1, a2, a3, a6, a7, 1, a8);
}

//----- (100206F0) --------------------------------------------------------
const char *__cdecl sub_100206F0(int a1, int a2)
{
  const char *result; // eax@3

  if ( a2 <= 0 )
  {
    result = "\x1B[32;40mPASS\x1B[0m";
    if ( !*(_BYTE *)(a1 + 576) )
      result = "PASS";
  }
  else if ( *(_BYTE *)(a1 + 576) )
  {
    result = "\x1B[31;40mFAILED\x1B[0m";
  }
  else
  {
    result = "FAIL";
  }
  return result;
}

//----- (10020730) --------------------------------------------------------
char __cdecl sub_10020730(int a1, int *a2, unsigned int a3)
{
  int *v3; // ebx@1
  int v4; // ebp@1
  int v5; // eax@1
  char *v6; // ebp@1
  char *v7; // eax@11
  int v8; // ecx@12
  int v9; // ST44_4@13
  bool v10; // zf@18
  signed int v11; // edx@24
  const char *v12; // eax@32
  _BYTE *v13; // eax@39
  int v14; // eax@44
  bool v15; // sf@44
  char v16; // cl@45
  char *v17; // eax@50
  int v18; // edx@52
  int v19; // edi@53
  unsigned int v20; // eax@53
  const char *v21; // ecx@53
  _DWORD *v22; // edx@53
  int v23; // esi@57
  int v24; // eax@58
  _BYTE *v25; // ecx@58
  _BYTE *v26; // edx@58
  int v27; // eax@60
  _BYTE *v28; // ecx@60
  _BYTE *v29; // edx@60
  _BYTE *v30; // ecx@62
  _BYTE *v31; // edx@62
  signed int v32; // eax@64
  signed int v33; // edi@73
  int v34; // esi@74
  int v35; // ecx@76
  int v36; // edx@82
  int v37; // eax@83
  int *v38; // eax@106
  void *v39; // ebx@106
  void *v40; // edi@109
  void *v41; // esi@112
  const char *v42; // eax@114
  int v43; // ST30_4@123
  const char *v44; // eax@142
  const char *v45; // eax@148
  char *v47; // [sp-14h] [bp-340h]@69
  char v48; // [sp+12h] [bp-31Ah]@24
  char v49; // [sp+13h] [bp-319h]@21
  signed int v50; // [sp+18h] [bp-314h]@52
  void *v51; // [sp+18h] [bp-314h]@94
  void *v52; // [sp+1Ch] [bp-310h]@97
  void *v53; // [sp+20h] [bp-30Ch]@103
  void *v54; // [sp+24h] [bp-308h]@45
  char v55[508]; // [sp+28h] [bp-304h]@11
  char v56; // [sp+224h] [bp-108h]@44
  char v57; // [sp+227h] [bp-105h]@11
  char v58; // [sp+228h] [bp-104h]@123
  char v59; // [sp+327h] [bp-5h]@123

  v3 = a2;
  v4 = sub_10018D20();
  LOBYTE(v5) = a1;
  v6 = (char *)&unk_1011DB00 + 580 * v4;
  switch ( a1 )
  {
    case 0:
      LOBYTE(v5) = sub_1001B990((int)v6, 0);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1001B940((int)v6, "Resetting test status\r\n");
      return v5;
    case 1:
      LOBYTE(v5) = sub_1001B4B0((int)v6);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1001B940((int)v6, "Clearing test status\r\n");
      return v5;
    case 11:
      LOBYTE(v5) = sub_1001B990((int)v6, 0);
      return v5;
    case 4:
      sub_1001B330((int)v6, *a2);
      if ( v6[577] && !v6[578] )
      {
        v7 = sub_1001B660((char *)a2[1]);
        _snprintf(v55, 0x200u, "Test Suite: %s (%s)\r\n", *a2, v7);
        v57 = 0;
        sub_1001B940((int)v6, v55);
      }
      LOBYTE(v5) = 0;
      v8 = (int)&v6[16 * *(_DWORD *)v6 + 4];
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      *(_DWORD *)(v8 + 8) = 0;
      *(_DWORD *)(v8 + 12) = 0;
      return v5;
    case 5:
      v9 = *a2;
      LOBYTE(v5) = sub_1001B320((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Group: %s - Begin\r\n\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 6:
      LOBYTE(v5) = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8] = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4] = 0;
      v10 = v6[577] == 0;
      *((_DWORD *)v6 + 143) = 0;
      if ( !v10 && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Case: %s\r\n\r\n", *a2);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1001B940((int)v6, v55);
      }
      return v5;
    case 7:
      v49 = sub_1001AD20((int)a2, a3);
      if ( !v49 && !v6[577] )
        goto LABEL_83;
      if ( v6[578] )
        goto LABEL_81;
      v11 = 0;
      v48 = 0;
      if ( a3 > 7 )
        v11 = strlen((const char *)a2[7]);
      if ( a3 > 8 )
        v11 += strlen((const char *)a2[8]);
      if ( a3 > 3 )
        v11 += strlen((const char *)a2[3]);
      if ( v11 > 100 )
        v48 = 1;
      v12 = sub_100206F0((int)v6, (unsigned __int8)v49);
      _snprintf(v55, 0x200u, "%s ", v12);
      v57 = 0;
      sub_1001B940((int)v6, v55);
      if ( a3 > 7 )
      {
        _snprintf(v55, 0x200u, " ACT: %-17s", a2[7]);
        v57 = 0;
        sub_1001B940((int)v6, v55);
        if ( v48 )
          sub_1001B940((int)v6, "\r\n     ");
      }
      if ( a3 > 8 )
      {
        _snprintf(v55, 0x200u, " EXP: %-17s", a2[8]);
        v57 = 0;
        sub_1001B940((int)v6, v55);
        if ( v48 )
          sub_1001B940((int)v6, "\r\n     ");
      }
      if ( a3 > 9 )
      {
        v13 = (_BYTE *)a2[9];
        if ( v13 )
        {
          if ( *v13 )
          {
            if ( memcmp((const void *)a2[9], &word_1005DA40, 2u) )
            {
              _snprintf(v55, 0x200u, " TOL: %-17s", a2[9]);
              v57 = 0;
              sub_1001B940((int)v6, v55);
              if ( v48 )
                sub_1001B940((int)v6, "\r\n     ");
            }
          }
        }
      }
      v14 = _snprintf(v55, 0x1FCu, " %s", a2[3]);
      v15 = v14 < 0;
      v56 = 0;
      if ( v14 > 0 )
      {
        do
        {
          v16 = *((_BYTE *)&v54 + v14 + 3);
          if ( v16 != 10 && v16 != 13 )
            break;
          *((_BYTE *)&v54 + --v14 + 4) = 0;
        }
        while ( v14 > 0 );
        v15 = v14 < 0;
      }
      if ( !v15 )
      {
        v17 = &v55[v14];
        *(_WORD *)v17 = 2573;
        v17[2] = 0;
      }
      sub_1001B940((int)v6, v55);
      if ( a3 <= 0xA )
        goto LABEL_72;
      v18 = 10;
      v50 = 10;
      if ( (signed int)a3 <= 10 )
        goto LABEL_72;
      do
      {
        v19 = v3[v18];
        v20 = 6;
        v21 = "Info: ";
        v22 = (_DWORD *)v3[v18];
        do
        {
          if ( *v22 != *(_DWORD *)v21 )
            goto LABEL_57;
          v20 -= 4;
          v21 += 4;
          ++v22;
        }
        while ( v20 >= 4 );
        if ( !v20 )
          goto LABEL_67;
LABEL_57:
        v23 = *(_BYTE *)v22 - *v21;
        if ( *(_BYTE *)v22 == *v21 )
        {
          v24 = v20 - 1;
          v25 = v21 + 1;
          v26 = (char *)v22 + 1;
          if ( !v24
            || (v23 = *v26 - *v25, *v26 == *v25)
            && ((v27 = v24 - 1, v28 = v25 + 1, v29 = v26 + 1, !v27)
             || (v23 = *v29 - *v28, *v29 == *v28)
             && ((v30 = v28 + 1, v31 = v29 + 1, v27 == 1) || (v23 = *v31 - *v30, *v31 == *v30))) )
          {
            v3 = a2;
LABEL_67:
            v32 = 0;
            goto LABEL_68;
          }
        }
        v3 = a2;
        v32 = 1;
        if ( v23 <= 0 )
          v32 = -1;
LABEL_68:
        if ( v32 )
        {
          _snprintf(v55, 0x200u, "      Post Analysis: %s\r\n", v19);
          v47 = v55;
        }
        else
        {
          _snprintf(v55, 0x200u, "      Compare Info: %s\r\n", v19 + 6);
          v47 = v55;
        }
        v57 = 0;
        sub_1001B940((int)v6, v47);
        v18 = v50++ + 1;
      }
      while ( v50 < (signed int)a3 );
LABEL_72:
      if ( v6[309] )
      {
        v33 = 0;
        if ( *((_DWORD *)v6 + 143) > 0 )
        {
          v34 = (int)(v6 + 336);
          do
          {
            if ( v33 >= 20 )
              break;
            v35 = *(_DWORD *)(v34 - 4);
            if ( *(_DWORD *)(v34 + 4) )
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s - %s\r\n", v33, v35, *(_DWORD *)v34, *(_DWORD *)(v34 + 4));
            else
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s\r\n", v33, v35, *(_DWORD *)v34);
            v57 = 0;
            sub_1001B940((int)v6, v55);
            ++v33;
            v34 += 12;
          }
          while ( v33 < *((_DWORD *)v6 + 143) );
        }
        _snprintf(v55, 0x200u, "      Location: %s:%s\r\n", v3[1], v3[2]);
        v57 = 0;
        sub_1001B940((int)v6, v55);
      }
LABEL_81:
      if ( v49 )
      {
        v36 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v36 + 4];
        v5 = (int)&v6[v36 + 4];
      }
      else
      {
LABEL_83:
        v37 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v37 + 8];
        v5 = (int)&v6[v37 + 8];
      }
      return v5;
    case 9:
      LOBYTE(v5) = sub_1001B590((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "Test Group: %s - End\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 3:
      LOBYTE(v5) = sub_1001B040((const void **)a2, a3);
      if ( !(_BYTE)v5 && !v6[578] )
      {
        if ( v6[577]
          || sub_1001B100((const void **)a2, a3)
          || (LOBYTE(v5) = sub_1001AF50((const void **)a2, a3), (_BYTE)v5) )
        {
          if ( a3 <= 8 )
            v51 = &unk_1005E69C;
          else
            v51 = (void *)a2[8];
          if ( a3 <= 7 )
            v52 = &unk_1005E69C;
          else
            v52 = (void *)a2[7];
          if ( a3 <= 6 )
            v54 = &unk_1005E69C;
          else
            v54 = (void *)a2[6];
          if ( a3 <= 5 )
            v53 = &unk_1005E69C;
          else
            v53 = (void *)a2[5];
          if ( a3 <= 4 )
          {
            v38 = a2;
            v39 = &unk_1005E69C;
          }
          else
          {
            v38 = a2;
            v39 = (void *)a2[4];
          }
          if ( a3 <= 3 )
            v40 = &unk_1005E69C;
          else
            v40 = (void *)v38[3];
          if ( a3 )
            v41 = (void *)*v38;
          else
            v41 = &unk_1005E69C;
          v10 = sub_1001B010((const void **)a2, a3) == 0;
          v42 = (const char *)&unk_1005E69C;
          if ( v10 )
            v42 = "   ";
          _snprintf(v55, 0x200u, "%s%s %s %s %s %s %s %s\r\n", v42, v41, v40, v39, v53, v54, v52, v51);
          v57 = 0;
          LOBYTE(v5) = (unsigned int)sub_1001B940((int)v6, v55);
        }
      }
      return v5;
    case 2:
      if ( v6[578] )
        return v5;
      if ( sub_1001AD50((const void **)a2, a3) )
      {
        dword_1011DAF8 = 2;
        sub_1001B940((int)v6, (const char *)&word_1009B7AC);
        sub_1001B940((int)v6, "   Command Format:\r\n");
        sub_1001B940(
          (int)v6,
          "       <global-command> [<arguments>]  : Runs the global command with the optional arguments\r\n");
        sub_1001B940(
          (int)v6,
          "                                         Commands may consist of multiple words. Arguments may\r\n");
        sub_1001B940(
          (int)v6,
          "                                         or may not be required and will be either booleans,\r\n");
        sub_1001B940(
          (int)v6,
          "                                         integers (32-bit signed or unsigned), floats, or\r\n");
        sub_1001B940((int)v6, "                                         strings depending upon the command\r\n");
        sub_1001B940((int)v6, "       <suite>                         : Runs all the test cases of the test suite\r\n");
        sub_1001B940(
          (int)v6,
          "       <suite> <case>                  : Runs the specific test case of the test suite\r\n");
        sub_1001B940(
          (int)v6,
          "       <suite> <command> [<arguments>] : Runs the test suite specific command with optional arguments\r\n");
        sub_1001B940((int)v6, (const char *)&word_1009B7AC);
        sub_1001B940((int)v6, "   Notes:\r\n");
        sub_1001B940((int)v6, "       Commands, suite names and test case names are case-insensitive.\r\n");
        sub_1001B940((int)v6, (const char *)&word_1009B7AC);
        sub_1001B940(
          (int)v6,
          "       In the command table below, indentation indicates the command is a sub-command of the unindented\r\n");
        sub_1001B940(
          (int)v6,
          "       command. Each test case and test suite command is shown indented below the test suite. To run\r\n");
        sub_1001B940(
          (int)v6,
          "       a test case or test suite command, you must enter the full command which consists of the both\r\n");
        sub_1001B940((int)v6, "       the suite name and the test case or test suite command.\r\n");
        sub_1001B940((int)v6, (const char *)&word_1009B7AC);
        sub_1001B940(
          (int)v6,
          "       In the command table below, ***global-commands*** is a place-holder to identify the set of\r\n");
        sub_1001B940(
          (int)v6,
          "       global commands and is not a real test suite name. The global commands should be entered\r\n");
        sub_1001B940((int)v6, "       without a test suite name.\r\n");
        sub_1001B940((int)v6, (const char *)&word_1009B7AC);
        sub_1001B940((int)v6, "   Examples:\r\n");
        sub_1001B940(
          (int)v6,
          "       help                            : Displays a brief help message showing all the test suites\r\n");
        sub_1001B940((int)v6, "       help -q                         : Quite help; Equivalent to help\r\n");
        sub_1001B940(
          (int)v6,
          "       help -v                         : Verbose help; Displays all available help information\r\n");
        sub_1001B940(
          (int)v6,
          "       help utf_validate.c             : Displays verbose help for the utf_validate.c test suite\r\n");
        sub_1001B940(
          (int)v6,
          "       all                             : Will run all the test cases of the test suites\r\n");
        sub_1001B940(
          (int)v6,
          "       utf_validate.c                  : Runs all the test cases of the utf_validate.c suite\r\n");
        sub_1001B940(
          (int)v6,
          "       utf_validate.c FAIL ON          : Enables the failing test cases of the utf_validate.c test suite\r\n");
        sub_1001B940(
          (int)v6,
          "       utf_validate.c Failing_Cases    : Runs the failing test case of the utf_validate.c test suite\r\n");
        sub_1001B940((int)v6, (const char *)&word_1009B7AC);
        sub_1001B940((int)v6, "   Command                                 Description\r\n");
        LOBYTE(v5) = (unsigned int)sub_1001B940(
                                     (int)v6,
                                     "   --------------------------------        --------------------------------\r\n");
        return v5;
      }
      if ( sub_1001ADE0((const void **)a2, a3) )
      {
        LOBYTE(v5) = (unsigned int)sub_1001B940((int)v6, (const char *)&word_1009B7AC);
        return v5;
      }
      if ( sub_1001ADB0((const void **)a2, a3) )
      {
        _snprintf(&v58, 0x100u, "%s %s", a2[3], a2[4]);
        v43 = a2[5];
        v59 = 0;
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s %s\r\n",
          dword_1011DAF8,
          &unk_1005E69C,
          &v58,
          6 - dword_1011DAF8,
          " ",
          v43);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1001B940((int)v6, v55);
        return v5;
      }
      if ( sub_1001AE10((const void **)a2, a3) )
      {
        LOBYTE(v5) = sub_1001AE40((int)a2, a3);
        if ( (_BYTE)v5 )
        {
          dword_1011DAF8 += 2;
          return v5;
        }
        if ( sub_1001AE80((int)a2, a3) )
        {
          LOBYTE(v5) = 2;
          if ( dword_1011DAF8 < 2 )
            dword_1011DAF8 = 0;
          else
            dword_1011DAF8 -= 2;
          return v5;
        }
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s group\r\n",
          dword_1011DAF8,
          &unk_1005E69C,
          a2[2],
          6 - dword_1011DAF8,
          " ",
          a2[2]);
LABEL_134:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1001B940((int)v6, v55);
        return v5;
      }
      if ( sub_1001AD80((const void **)a2, a3) )
      {
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s case\r\n",
          dword_1011DAF8,
          &unk_1005E69C,
          a2[3],
          6 - dword_1011DAF8,
          " ",
          a2[3]);
        goto LABEL_134;
      }
      if ( sub_1001AEF0((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s Runs the %s suite\r\n", a2[1], a2[1]);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1001B940((int)v6, v55);
      }
      else if ( sub_1001AEC0((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s A test results listener\r\n", a2[1]);
LABEL_17:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1001B940((int)v6, v55);
      }
      else
      {
        LOBYTE(v5) = (unsigned int)sub_1001B940((int)v6, "Unknown test help event\r\n");
      }
      return v5;
    case 8:
      if ( v6[577] && !v6[578] )
      {
        v44 = sub_100206F0((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        _snprintf(v55, 0x200u, "\r\n   Test Case Results: %s\r\n", v44);
        v57 = 0;
        sub_1001B940((int)v6, v55);
        _snprintf(v55, 0x200u, "      Passed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8]);
        v57 = 0;
        sub_1001B940((int)v6, v55);
        _snprintf(v55, 0x200u, "      Failed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        v57 = 0;
        sub_1001B940((int)v6, v55);
      }
      v5 = (int)&v6[16 * *(_DWORD *)v6];
      if ( *(_DWORD *)(v5 + 4) )
        ++*(_DWORD *)(v5 + 12);
      else
        ++*(_DWORD *)(v5 + 16);
      return v5;
    case 10:
      if ( v6[577] && !v6[578] )
      {
        v45 = sub_100206F0((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        _snprintf(v55, 0x200u, "\r\nTest Suite Results: %s\r\n", v45);
        v57 = 0;
        sub_1001B940((int)v6, v55);
        _snprintf(v55, 0x200u, "   Passed Cases: %4d\r\n", *(_DWORD *)&v6[16 * (*(_DWORD *)v6 + 1)]);
        v57 = 0;
        sub_1001B940((int)v6, v55);
        _snprintf(v55, 0x200u, "   Failed Cases: %4d\r\n\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        v57 = 0;
        sub_1001B940((int)v6, v55);
      }
      LOBYTE(v5) = sub_1001B5F0((int)v6, 0);
      return v5;
    case 12:
      LOBYTE(v5) = sub_1001B8C0((int)v6, 0);
      return v5;
    case 13:
      if ( a3 >= 2 )
      {
        v5 = *((_DWORD *)v6 + 143);
        if ( v5 < 20 )
        {
          *(_DWORD *)&v6[12 * v5 + 332] = *a2;
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143) + 28)] = a2[1];
          v5 = 3 * *((_DWORD *)v6 + 143);
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143))++ + 340] = a2[2];
        }
      }
      return v5;
    case 14:
      --*((_DWORD *)v6 + 143);
      return v5;
    default:
      if ( !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1001B940((int)v6, "Unknown test event\r\n");
      return v5;
  }
}
// 1005DA40: using guessed type __int16 word_1005DA40;
// 1009B7AC: using guessed type __int16 word_1009B7AC;
// 1011DAF8: using guessed type int dword_1011DAF8;
// 10020730: using guessed type char var_304[508];

//----- (100214E0) --------------------------------------------------------
signed int __cdecl sub_100214E0(int a1, int a2)
{
  char *v2; // eax@1

  v2 = (char *)&unk_1011DB00 + 580 * sub_10018D20();
  if ( a1 == 12 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[576] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else if ( a1 == 13 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[577] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else
  {
    if ( a1 != 14 )
      return sub_1001B4F0(a1, a2, (int)v2);
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[578] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  return 9;
}

//----- (10021560) --------------------------------------------------------
char **__cdecl sub_10021560(int a1)
{
  char *v1; // eax@1

  v1 = (char *)&unk_1011DB00 + 580 * sub_10018D20();
  v1[576] = 1;
  v1[577] = 1;
  v1[578] = 0;
  sub_1001B700((int)v1, a1, (int)".txt");
  return &off_1009AB78;
}
// 1009AB78: using guessed type char *off_1009AB78;

//----- (100215A0) --------------------------------------------------------
int (**sub_100215A0())()
{
  return off_1009B868;
}
// 1009B868: using guessed type int (*off_1009B868[2])();

//----- (100215B0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100215B0(const char *a1))(const char *)
{
  int v1; // eax@1

  v1 = sub_10018D20();
  return sub_1001B940((int)&unk_1011E658 + 1812 * v1, a1);
}

//----- (100215D0) --------------------------------------------------------
const char *sub_100215D0()
{
  return "See version control for test execution date";
}

//----- (100215E0) --------------------------------------------------------
__int64 sub_100215E0()
{
  return 0i64;
}

//----- (100215F0) --------------------------------------------------------
const char *sub_100215F0()
{
  return "Not Available";
}

//----- (10021600) --------------------------------------------------------
int __usercall sub_10021600@<eax>(_BYTE *a1@<edi>, int a2)
{
  char v2; // al@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // cl@3
  _BYTE *v6; // edx@4

  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    v4 = *(_BYTE *)(v3 + a2);
    if ( !v4 )
      break;
    v5 = *a1;
    if ( *a1 )
    {
      v6 = a1;
      while ( v5 != v4 )
      {
        v5 = (v6++)[1];
        if ( !v5 )
          goto LABEL_9;
      }
      v2 = 1;
    }
LABEL_9:
    ++v3;
    if ( v2 )
      return v3 - 1;
  }
  if ( v2 )
    --v3;
  return v3;
}

//----- (10021650) --------------------------------------------------------
signed int __cdecl sub_10021650(int a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10018D20();
  return sub_1001B4F0(a1, a2, (int)&unk_1011E658 + 1812 * v2);
}

//----- (100217A0) --------------------------------------------------------
int __usercall sub_100217A0@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3)
{
  char *v3; // edi@1
  char *v4; // eax@1
  unsigned int v5; // kr00_4@1
  char v6; // cl@1
  char *v7; // eax@4
  char *v8; // eax@4
  char *v9; // eax@5
  unsigned __int8 *v10; // eax@6
  unsigned __int8 *v11; // eax@9
  signed int i; // edi@9
  int result; // eax@11
  int v14; // ecx@11
  unsigned __int8 *v15; // [sp+8h] [bp-10Ch]@9
  unsigned __int8 *v16; // [sp+Ch] [bp-108h]@1
  char v17; // [sp+10h] [bp-104h]@1
  char v18[253]; // [sp+11h] [bp-103h]@3
  char v19; // [sp+10Eh] [bp-6h]@1

  v3 = a1;
  sub_1002E8C0((int)&a2[151 * (*a2 + 1)], (int)sub_100215B0, 0);
  *(_QWORD *)&a2[2 * *a2 + 147] = sub_100215E0();
  v4 = sub_100256B0("CFG_StyleSheetDir", (int)"/Starteam/GDU1XXX/Verification/Automated_Test_Scripts/Stylesheets/");
  _snprintf(&v17, 0xFFu, v4);
  v19 = 0;
  v5 = strlen(&v17);
  v6 = (char)(&v16)[v5 + 3];
  if ( v6 != 92 && v6 != 47 )
  {
    *(&v17 + v5) = 47;
    v18[v5] = 0;
  }
  sub_1002ED10((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<?xml version=\"1.0\" encoding=\"Windows-1252\"?>", 0);
  v7 = sub_100256B0("CFG_StyleSheet", (int)"std_output_frmt.xsl");
  _snprintf((char *)&a2[151 * *a2 + 174], 0x200u, "<?xml-stylesheet type=\"text/xsl\" href=\"%s%s\"?>", &v17, v7);
  BYTE3(a2[151 * *a2 + 301]) = 0;
  sub_1002ED10((int)&a2[151 * *a2 + 151], (unsigned __int8 *)&a2[151 * *a2 + 174], 0);
  sub_1002ED10((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<!-- saved from url=(0021)http://www.garmin.com -->", 0);
  sub_1002EC90((int)&a2[151 * (*a2 + 1)], (int)"TestResults");
  sub_1002EB20((int)&a2[151 * (*a2 + 1)], (int)"xmlns", (unsigned __int8 *)"http://www.garmin.com/GATE");
  v8 = sub_100256B0("CFG_OutputTestRevision", (int)"False");
  if ( !sub_10018DD0(v8, (int)"True") )
  {
    v9 = strstr(v3, "$Id: ");
    if ( v9 )
      v10 = (unsigned __int8 *)(v9 + 5);
    else
      v10 = (unsigned __int8 *)v3;
    sub_1002ED60((int)&a2[151 * (*a2 + 1)], (int)"Version", v10);
    sub_1002ED60((int)&a2[151 * (*a2 + 1)], (int)"ResultVersion", (unsigned __int8 *)"$Id$");
  }
  sub_1002EC90((int)&a2[151 * (*a2 + 1)], (int)"Config");
  sub_1002EC90((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
  sub_1002ED60((int)&a2[151 * (*a2 + 1)], (int)"Name", (unsigned __int8 *)"CFG_TestFile");
  v11 = (unsigned __int8 *)sub_1001B660(v3);
  sub_1002ED60((int)&a2[151 * (*a2 + 1)], (int)"Value", v11);
  sub_1002EC10((int)&a2[151 * (*a2 + 1)]);
  for ( i = 0; sub_10025670(i, &v15, &v16); ++i )
  {
    sub_1002EC90((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
    sub_1002ED60((int)&a2[151 * (*a2 + 1)], (int)"Name", v15);
    sub_1002ED60((int)&a2[151 * (*a2 + 1)], (int)"Value", v16);
    sub_1002EC10((int)&a2[151 * (*a2 + 1)]);
  }
  sub_1002EC10((int)&a2[151 * (*a2 + 1)]);
  sub_1002EC90((int)&a2[151 * (*a2 + 1)], (int)"TestProcedure");
  sub_1002EB20((int)&a2[151 * (*a2 + 1)], (int)"name", (unsigned __int8 *)a3);
  result = 0;
  v14 = (int)&a2[4 * *a2 + 1];
  *(_DWORD *)v14 = 0;
  *(_DWORD *)(v14 + 4) = 0;
  *(_DWORD *)(v14 + 8) = 0;
  *(_DWORD *)(v14 + 12) = 0;
  return result;
}
// 100217A0: using guessed type char var_103[253];

//----- (10021B20) --------------------------------------------------------
char __cdecl sub_10021B20(int a1, const void **a2, unsigned int a3)
{
  int v3; // ebp@1
  int v4; // eax@1
  char *v5; // ebp@1
  const char *v6; // ebx@3
  int v7; // esi@4
  int v8; // ST14_4@5
  int v9; // eax@12
  const char *v10; // eax@13
  const char *v11; // eax@15
  int v12; // ST14_4@17
  int v13; // ecx@29
  const void *v14; // ST24_4@43
  int v15; // ST04_4@44
  _BYTE *v16; // eax@87
  _BYTE *v17; // eax@94
  _BYTE *v18; // eax@100
  int v19; // ST20_4@104
  unsigned int v20; // esi@105
  _DWORD *v21; // edx@106
  unsigned int v22; // eax@106
  const char *v23; // ecx@106
  int v24; // esi@110
  int v25; // eax@111
  _BYTE *v26; // ecx@111
  _BYTE *v27; // edx@111
  int v28; // eax@113
  _BYTE *v29; // ecx@113
  _BYTE *v30; // edx@113
  _BYTE *v31; // ecx@115
  _BYTE *v32; // edx@115
  bool v33; // zf@117
  bool v34; // sf@117
  signed int v35; // eax@117
  const char *v36; // eax@129
  const char *v37; // eax@131
  const char *v39; // [sp-10h] [bp-124h]@73
  unsigned __int8 *v40; // [sp-Ch] [bp-120h]@73
  char v41; // [sp+9h] [bp-10Bh]@46
  char v42; // [sp+Ah] [bp-10Ah]@46
  char v43; // [sp+Bh] [bp-109h]@46
  const char *v44; // [sp+Ch] [bp-108h]@91
  signed int v45; // [sp+Ch] [bp-108h]@105
  char v46[255]; // [sp+10h] [bp-104h]@5
  char v47; // [sp+10Fh] [bp-5h]@44

  v3 = sub_10018D20();
  LOBYTE(v4) = a1;
  v5 = (char *)&unk_1011E658 + 1812 * v3;
  switch ( a1 )
  {
    case 3:
      if ( sub_1001B0A0(a2, a3) )
      {
        v6 = (const char *)a2[3];
        do
        {
          v4 = sub_10021600(", \t", (int)v6);
          v7 = v4;
          if ( v4 )
          {
            strncpy(v46, v6, v4);
            v8 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
            v46[v7] = 0;
            sub_1002EC90(v8, (int)"Req");
            sub_1002EB20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"id", (unsigned __int8 *)v46);
            LOBYTE(v4) = (unsigned int)sub_1002EC10((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
            v6 += v7;
          }
          else
          {
            ++v6;
          }
        }
        while ( *v6 );
      }
      else if ( sub_1001B070(a2, a3) )
      {
        if ( sub_1001B800((int)v5, 3, 1, 0) )
          sub_1002EC10((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        v9 = *((_DWORD *)v5 + 146);
        if ( v9 > 0 )
        {
          *((_DWORD *)v5 + 146) = v9 - 1;
          sub_1002EC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
          v10 = "true";
          if ( *((_DWORD *)v5 + 144) <= 0 )
            v10 = "false";
          sub_1002EB20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v10);
          v11 = "true";
          if ( *((_DWORD *)v5 + 145) <= 0 )
            v11 = "false";
          sub_1002EB20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v11);
          sub_1002EC10((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          v12 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          *((_DWORD *)v5 + 144) = 0;
          *((_DWORD *)v5 + 145) = 0;
          sub_1002EC10(v12);
          sub_1002EC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        }
        LOBYTE(v4) = (unsigned int)sub_1002EB20(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"title",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_1001AFB0(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_1002ED60(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"Method",
                                     (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 146);
      }
      else if ( sub_1001B0D0(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_1002ED60(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"TestType",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_1001B040(a2, a3) )
      {
        if ( sub_1001B800((int)v5, 3, 1, 0) )
          sub_1002EC10((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_1001B770((int)a2, a3, (int)v5);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = sub_1002EC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      }
      else if ( sub_1001AFE0(a2, a3) )
      {
        sub_1002EC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Results");
        v13 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        if ( *(_BYTE *)a2[3] == 48 )
        {
          sub_1002EB20(v13, (int)"success", (unsigned __int8 *)&word_1005DA40);
          sub_1002EB20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"error_msg", (unsigned __int8 *)a2[3] + 1);
        }
        else
        {
          sub_1002EB20(v13, (int)"success", (unsigned __int8 *)"1");
        }
        if ( v5[309] )
        {
          sub_1002EB20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
          sub_1002EB20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
        }
        sub_1002EC10((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_1001B800((int)v5, 3, 0, 0);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = (unsigned int)sub_1002EC10((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      else
      {
        LOBYTE(v4) = sub_1001AF80(a2, a3);
        if ( (_BYTE)v4 )
        {
          if ( !sub_1001B8B0((int)v5) )
            sub_1002EC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
          sub_1002ED60((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
          LOBYTE(v4) = sub_1001B800((int)v5, 3, 0, 1);
          if ( (_BYTE)v4 )
            LOBYTE(v4) = (unsigned int)sub_1002EC10((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      return v4;
    case 4:
      LOBYTE(v4) = sub_1001B330((int)v5, (int)*a2);
      if ( (_BYTE)v4 )
        LOBYTE(v4) = sub_100217A0((char *)a2[1], v5, (int)*a2);
      return v4;
    case 5:
      v14 = *a2;
      LOBYTE(v4) = sub_1001B320((int)v5);
      if ( !(_BYTE)v4 )
      {
        sub_1002EC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        _snprintf(v46, 0x100u, "Test Group: %s", *a2);
        v15 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        v47 = 0;
        sub_1002ED60(v15, (int)"Method", (unsigned __int8 *)v46);
        LOBYTE(v4) = (unsigned int)sub_1002EC10((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      return v4;
    case 6:
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      LOBYTE(v4) = sub_1002EC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
      return v4;
    case 7:
      v41 = 0;
      v42 = 0;
      v43 = 0;
      if ( a3 <= 6 )
        goto LABEL_56;
      if ( !memcmp(a2[6], "bool", 5u) || !memcmp(a2[6], "char", 5u) || !memcmp(a2[6], "string", 7u) )
      {
        v42 = 1;
        goto LABEL_56;
      }
      if ( !memcmp(a2[6], "bitmap", 7u) || !memcmp(a2[6], "bitmap-lenient", 0xFu) )
        goto LABEL_55;
      if ( !memcmp(a2[6], "bitmap-strict", 0xEu) )
      {
        v43 = 1;
LABEL_55:
        v41 = 1;
      }
LABEL_56:
      if ( !*((_DWORD *)v5 + 146) )
      {
        sub_1002ED60(
          (int)&v5[604 * (*(_DWORD *)v5 + 1)],
          (int)"Method",
          (unsigned __int8 *)"Method Placeholder -- Add UTF_grp to test case");
        sub_1002ED60((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestType", (unsigned __int8 *)"Low Level Testing");
        ++*((_DWORD *)v5 + 146);
      }
      if ( !sub_1001B8B0((int)v5) )
        sub_1002EC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      if ( sub_1001AF20((int)a2, a3) )
      {
        if ( *(_BYTE *)a2[3] )
        {
          sub_1002EC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction");
          sub_1002EBC0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (unsigned __int8 *)a2[3]);
          sub_1002EC10((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
        ++*((_DWORD *)v5 + 145);
      }
      else
      {
        if ( *(_BYTE *)a2[3] )
          sub_1002ED60((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 144);
      }
      sub_1002EC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Compare");
      if ( sub_1001AD20((int)a2, a3) )
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 4];
        sub_1002EB20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Fail");
      }
      else
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 8];
        sub_1002EB20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Pass");
      }
      sub_1002EB20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"type", (unsigned __int8 *)*a2);
      sub_1002EB20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"class", (unsigned __int8 *)a2[5]);
      if ( a3 <= 6 )
        goto LABEL_77;
      if ( v41 )
      {
        sub_1002EB20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"datatype", (unsigned __int8 *)"bitmap");
        if ( !v43 )
        {
          sub_1002EB20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"strict", (unsigned __int8 *)"false");
          goto LABEL_77;
        }
        v40 = (unsigned __int8 *)"true";
        v39 = "strict";
      }
      else
      {
        v40 = (unsigned __int8 *)a2[6];
        v39 = "datatype";
      }
      sub_1002EB20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)v39, v40);
LABEL_77:
      if ( v5[309] )
      {
        sub_1002EB20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
        sub_1002EB20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
      }
      if ( a3 > 7 )
      {
        sub_1002EC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Actual");
        if ( v42 )
          sub_1002EB70((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        else
          sub_1002EB20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        sub_1002EC10((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      if ( a3 > 8 )
      {
        if ( v42 )
        {
          sub_1002EC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Expected");
          sub_1002EB70((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)a2[8]);
          sub_1002EC10((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          if ( a3 > 9 )
          {
            v16 = a2[9];
            if ( v16 )
            {
              if ( *v16 )
              {
                sub_1002EC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Tolerance");
                sub_1002EB70((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"tolerance", (unsigned __int8 *)a2[9]);
                sub_1002EC10((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
              }
            }
          }
        }
        else
        {
          if ( v41 )
          {
            v44 = "!";
            if ( memcmp(*a2, &unk_10095CB8, 3u) )
              v44 = (const char *)&unk_1005E69C;
            if ( a3 > 9 && (v17 = a2[9]) != 0 && *v17 && memcmp(a2[9], &word_1005DA40, 2u) )
              _snprintf(v46, 0x100u, "%s%s+/-%s", v44, a2[8], a2[9]);
            else
              _snprintf(v46, 0x100u, "%s%s", v44, a2[8]);
          }
          else if ( a3 > 9 && (v18 = a2[9]) != 0 && *v18 )
          {
            _snprintf(v46, 0x100u, "N EQ %s(+/-)%s", a2[8], a2[9]);
          }
          else
          {
            _snprintf(v46, 0x100u, "N %s %s", *a2, a2[8]);
          }
          v19 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          v47 = 0;
          sub_1002EC90(v19, (int)"Expected");
          sub_1002EB20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)v46);
          sub_1002EC10((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      v20 = 10;
      v45 = 10;
      if ( a3 <= 0xA )
        goto LABEL_125;
      break;
    case 8:
      if ( sub_1001B800((int)v5, 8, 1, 0) )
        sub_1002EC10((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      sub_1002EC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
      v36 = "true";
      if ( *((_DWORD *)v5 + 144) <= 0 )
        v36 = "false";
      sub_1002EB20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v36);
      v37 = "true";
      if ( *((_DWORD *)v5 + 145) <= 0 )
        v37 = "false";
      sub_1002EB20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v37);
      sub_1002EC10((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      LOBYTE(v4) = (unsigned int)sub_1002EC10((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      return v4;
    case 9:
      LOBYTE(v4) = sub_1001B590((int)v5);
      return v4;
    case 10:
      LOBYTE(v4) = sub_1001B5F0((int)v5, (void (__cdecl *)(int))sub_10021680);
      return v4;
    case 0:
    case 11:
      sub_1001B990((int)v5, (void (__cdecl *)(int))sub_10021680);
      goto LABEL_139;
    case 1:
      sub_1001B4B0((int)v5);
      goto LABEL_139;
    case 12:
      sub_1001B8C0((int)v5, (void (__cdecl *)(int))sub_10021680);
LABEL_139:
      LOBYTE(v4) = 0;
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      return v4;
    default:
      return v4;
  }
  do
  {
    v21 = a2[v20];
    v22 = 6;
    v23 = "Info: ";
    do
    {
      if ( *v21 != *(_DWORD *)v23 )
        goto LABEL_110;
      v22 -= 4;
      v23 += 4;
      ++v21;
    }
    while ( v22 >= 4 );
    if ( !v22 )
      goto LABEL_120;
LABEL_110:
    v24 = *(_BYTE *)v21 - *v23;
    if ( *(_BYTE *)v21 == *v23 )
    {
      v25 = v22 - 1;
      v26 = v23 + 1;
      v27 = (char *)v21 + 1;
      if ( !v25
        || (v24 = *v27 - *v26, *v27 == *v26)
        && ((v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, !v28)
         || (v24 = *v30 - *v29, *v30 == *v29)
         && ((v31 = v29 + 1, v32 = v30 + 1, v28 == 1) || (v24 = *v32 - *v31, *v32 == *v31))) )
      {
        v20 = v45;
LABEL_120:
        v35 = 0;
        goto LABEL_121;
      }
    }
    v33 = v24 == 0;
    v34 = v24 < 0;
    v20 = v45;
    v35 = 1;
    if ( v34 || v33 )
      v35 = -1;
LABEL_121:
    if ( v35 )
    {
      sub_1002EC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"PostAnalysis");
      sub_1002EB20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"note", (unsigned __int8 *)a2[v20]);
      sub_1002EC10((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    else
    {
      sub_1002EC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"CompareInfo");
      sub_1002EB20((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"comp_info", (unsigned __int8 *)a2[v20] + 6);
      sub_1002EC10((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    v45 = ++v20;
  }
  while ( v20 < a3 );
LABEL_125:
  sub_1002EC10((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  LOBYTE(v4) = sub_1001B800((int)v5, 7, 0, 1);
  if ( (_BYTE)v4 )
    LOBYTE(v4) = (unsigned int)sub_1002EC10((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  return v4;
}
// 10021680: using guessed type int sub_10021680();
// 1005DA40: using guessed type __int16 word_1005DA40;
// 10021B20: using guessed type char var_104[255];

//----- (10022940) --------------------------------------------------------
char **__cdecl sub_10022940(int a1)
{
  char *v1; // esi@1
  int v2; // esi@1
  signed int v3; // edi@1

  v1 = (char *)&unk_1011E658 + 1812 * sub_10018D20();
  *((_DWORD *)v1 + 146) = 0;
  sub_1001B700((int)v1, a1, (int)".xml");
  v2 = (int)(v1 + 604);
  v3 = 2;
  do
  {
    sub_1002E8C0(v2, (int)sub_100215B0, 0);
    v2 += 604;
    --v3;
  }
  while ( v3 );
  return &off_1009B918;
}
// 1009B918: using guessed type char *off_1009B918;

//----- (100229B0) --------------------------------------------------------
char __thiscall sub_100229B0(void *this)
{
  char v1; // bl@1
  void *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_101209C0 = sub_1000EB50(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_101209C8, 0, 0xAA0u);
  v1 = 0;
  v4 = 0;
  v2 = &unk_101209C8;
  do
  {
    result = sub_10023FB0(v4, (int)v2);
    ++v1;
    v2 = (char *)v2 + 2720;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 2u );
  return result;
}
// 101209C0: using guessed type int dword_101209C0;

//----- (10022A20) --------------------------------------------------------
char __usercall sub_10022A20@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4)
{
  char result; // al@1

  memset(a3, 0, (unsigned __int16)a2);
  result = 0;
  if ( a4 )
  {
    if ( a4 == 1 )
      result = sub_10013E80(6, 8, a1, a2, a3);
  }
  else
  {
    result = sub_10013E80(6, 5, a1, a2, a3);
  }
  return result;
}

//----- (10022A60) --------------------------------------------------------
void *__usercall sub_10022A60@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4)
{
  int v4; // edi@1
  void *result; // eax@4

  v4 = 0;
  if ( dword_101209C0 == 1379255385 )
    goto LABEL_4;
  v4 = sub_10031B90(86, 10);
  if ( !v4 )
  {
    memset((char *)&unk_101209C8 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
    sub_10023FB0(a1, (int)&unk_101209C8 + 2720 * (unsigned __int8)a1);
LABEL_4:
    result = memcpy_0(
               a4,
               (char *)&unk_101209C8 + 2720 * (unsigned __int8)a1 + (unsigned __int16)a2,
               (unsigned __int16)a3);
    goto LABEL_6;
  }
  result = memset(a4, 0, (unsigned __int16)a3);
LABEL_6:
  if ( dword_101209C0 != 1379255385 )
    result = (void *)sub_10031B60(v4, 86);
  return result;
}
// 101209C0: using guessed type int dword_101209C0;

//----- (10022B00) --------------------------------------------------------
char __cdecl sub_10022B00(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 <= 0xAu )
    result = sub_10022A20(4 * (a2 + 6), 4, a3, a1);
  return result;
}

//----- (10022B40) --------------------------------------------------------
bool __cdecl sub_10022B40(char a1, char a2, void *a3)
{
  bool result; // al@1
  unsigned __int8 v4; // al@3

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 <= 0xAu )
  {
    sub_10022A60(a1, 4 * ((unsigned __int8)a2 + 6), 4, a3);
    v4 = *((_BYTE *)a3 + 1);
    result = v4 < 0x33u || v4 >= 0x64u && v4 <= 0x81u || v4 >= 0x96u && v4 <= 0x9Eu;
  }
  return result;
}

//----- (10022BA0) --------------------------------------------------------
char __cdecl sub_10022BA0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xAu )
    result = sub_10022A20(a2, 1, a3, a1);
  return result;
}

//----- (10022BE0) --------------------------------------------------------
char __cdecl sub_10022BE0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xAu )
  {
    sub_10022A60(a1, (unsigned __int8)a2, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10022C10) --------------------------------------------------------
char __cdecl sub_10022C10(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xBu )
    result = sub_10022A20(a2 + 10, 1, a3, a1);
  return result;
}

//----- (10022C50) --------------------------------------------------------
char __cdecl sub_10022C50(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xBu )
  {
    sub_10022A60(a1, (unsigned __int8)a2 + 10, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10022C90) --------------------------------------------------------
char __cdecl sub_10022C90(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 2u )
    result = sub_10022A20(16 * (a2 + 50), 16, a3, a1);
  return result;
}

//----- (10022CD0) --------------------------------------------------------
bool __cdecl sub_10022CD0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 2u )
  {
    sub_10022A60(a1, 16 * ((unsigned __int8)a2 + 50), 16, a3);
    result = *(_BYTE *)a3 < 8u && *((_BYTE *)a3 + 1) < 8u;
  }
  return result;
}

//----- (10022D20) --------------------------------------------------------
char __cdecl sub_10022D20(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x29u )
    result = sub_10022A20(12 * a2 + 68, 12, a3, a1);
  return result;
}

//----- (10022D60) --------------------------------------------------------
bool __cdecl sub_10022D60(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x29u )
  {
    sub_10022A60(a1, 12 * (unsigned __int8)a2 + 68, 12, a3);
    result = *((_WORD *)a3 + 1) < 0x319u;
  }
  return result;
}

//----- (10022DA0) --------------------------------------------------------
char __cdecl sub_10022DA0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x2Au )
    result = sub_10022A20(4 * (a2 + 140), 4, a3, a1);
  return result;
}

//----- (10022DE0) --------------------------------------------------------
bool __cdecl sub_10022DE0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x2Au )
  {
    sub_10022A60(a1, 4 * ((unsigned __int8)a2 + 140), 4, a3);
    result = *((_WORD *)a3 + 1) < 0x145u;
  }
  return result;
}

//----- (10022E20) --------------------------------------------------------
char __cdecl sub_10022E20(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10022A20(1229, 1, a2, a1);
  return result;
}

//----- (10022E50) --------------------------------------------------------
char __cdecl sub_10022E50(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10022A60(a1, 1229, 1, a2);
    result = 1;
  }
  return result;
}

//----- (10022E80) --------------------------------------------------------
char __cdecl sub_10022E80(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10022A20(1212, 16, a2, a1);
  return result;
}

//----- (10022EB0) --------------------------------------------------------
char __cdecl sub_10022EB0(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10022A60(a1, 1212, 16, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10022EE0) --------------------------------------------------------
char __cdecl sub_10022EE0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10022A20(2400, 65, a2, a1);
  return result;
}

//----- (10022F10) --------------------------------------------------------
char __cdecl sub_10022F10(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10022A60(a1, 2400, 65, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10022F40) --------------------------------------------------------
char __cdecl sub_10022F40(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 < 8u && (unsigned __int8)a1 < 2u )
    result = sub_10022A20(4 * (a2 + 182), 4, a3, a1);
  return result;
}

//----- (10022F80) --------------------------------------------------------
char __cdecl sub_10022F80(char a1, char a2, void *a3)
{
  char result; // al@2

  if ( (unsigned __int8)a2 > 7u )
    result = sub_1000D740("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 1428, 0, 0);
  else
    result = (unsigned int)sub_10022A60(a1, 4 * ((unsigned __int8)a2 + 182), 4, a3);
  return result;
}

//----- (10022FD0) --------------------------------------------------------
char __cdecl sub_10022FD0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 <= 4u )
    result = sub_10022A20(8 * (a2 + 95), 8, a3, a1);
  return result;
}

//----- (10023010) --------------------------------------------------------
char __cdecl sub_10023010(char a1, char a2, void *a3)
{
  char result; // al@1

  result = a2;
  if ( (unsigned __int8)a2 <= 4u )
    result = (unsigned int)sub_10022A60(a1, 8 * ((unsigned __int8)a2 + 95), 8, a3);
  return result;
}

//----- (10023040) --------------------------------------------------------
char __cdecl sub_10023040(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10022A20(22, 1, a2, a1);
  return result;
}

//----- (10023070) --------------------------------------------------------
char __cdecl sub_10023070(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10022A20(832, 4, a2, a1);
  return result;
}

//----- (100230A0) --------------------------------------------------------
char __cdecl sub_100230A0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10022A60(a1, 832, 4, a2);
    result = 1;
  }
  return result;
}

//----- (100230D0) --------------------------------------------------------
char __cdecl sub_100230D0(int a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@4
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10018700(a1);
  if ( v6 == 2 )
  {
LABEL_44:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 0:
        if ( a2 )
        {
          sub_10022F80(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_10022F40(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 1:
        if ( a2 )
        {
          sub_10023010(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_10022FD0(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 2:
        if ( a2 )
          result = sub_10022B40(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10022B00(v6, *(_BYTE *)a4, a5);
        break;
      case 3:
        if ( a2 )
          result = sub_10022D60(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10022D20(v6, *(_BYTE *)a4, a5);
        break;
      case 4:
        if ( a2 )
          result = sub_10022DE0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10022DA0(v6, *(_BYTE *)a4, a5);
        break;
      case 5:
        if ( a2 )
          result = sub_10022BE0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10022BA0(v6, *(_BYTE *)a4, a5);
        break;
      case 6:
        if ( a2 )
          result = sub_10022C50(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10022C10(v6, *(_BYTE *)a4, a5);
        break;
      case 7:
        result = sub_10023040(v6, a5);
        break;
      case 8:
        if ( a2 )
          result = sub_10022EB0(v6, a5);
        else
          result = sub_10022E80(v6, a5);
        break;
      case 9:
        if ( a2 )
          result = sub_10022CD0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10022C90(v6, *(_BYTE *)a4, a5);
        break;
      case 0x1D:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10022F10(v6, a5);
        else
          result = sub_10022EE0(v6, a5);
        break;
      case 0x21:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10022E50(v6, a5);
        else
          result = sub_10022E20(v6, a5);
        break;
      case 0x1B:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_100230A0(v6, a5);
        else
          result = sub_10023070(v6, a5);
        break;
      default:
        sub_1000D740("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 2329, 0, 0);
        goto LABEL_44;
    }
  }
  return result;
}
// 100323E0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10023470) --------------------------------------------------------
bool __cdecl sub_10023470(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  char v4; // dl@5
  bool result; // al@5

  v3 = a2;
  if ( a2 >= 0xFFu || a2 > 1u )
  {
    result = 0;
  }
  else
  {
    if ( dword_10121F08 != 1379255385 )
    {
      sub_10023F90(a1, (int)&byte_10121F10[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v4 = byte_10121F15[4 * (v3 + 6 * (unsigned __int8)a1)];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_10121F14[4 * (v3 + 6 * (unsigned __int8)a1)];
    result = (unsigned __int8)v4 < 0xBu;
  }
  return result;
}
// 10121F08: using guessed type int dword_10121F08;

//----- (100234E0) --------------------------------------------------------
bool __cdecl sub_100234E0(char a1, unsigned __int8 a2, int a3)
{
  bool result; // al@2

  if ( a2 < 1u )
  {
    if ( dword_10121F08 != 1379255385 )
      sub_10023F90(a1, (int)&byte_10121F10[24 * (unsigned __int8)a1]);
    *(_DWORD *)a3 = dword_10121F24[a2 + 6 * (unsigned __int8)a1];
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10121F08: using guessed type int dword_10121F08;
// 10121F24: using guessed type int dword_10121F24[];

//----- (10023540) --------------------------------------------------------
bool __cdecl sub_10023540(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  bool result; // al@1
  int v5; // edx@5

  v3 = a2;
  result = 0;
  if ( (a2 & 0x80u) == 0 && a2 <= 1u )
  {
    if ( dword_10121F08 != 1379255385 )
    {
      sub_10023F90(a1, (int)&byte_10121F10[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v5 = dword_10121F1C[v3 + 6 * (unsigned __int8)a1];
    *(_DWORD *)a3 = v5;
    result = (unsigned __int8)v5 < 0x13u && *(_BYTE *)(a3 + 1) < 0x13u;
  }
  return result;
}
// 10121F08: using guessed type int dword_10121F08;
// 10121F1C: using guessed type int dword_10121F1C[];

//----- (100235B0) --------------------------------------------------------
char __cdecl sub_100235B0(char a1, _BYTE *a2)
{
  if ( dword_10121F08 != 1379255385 )
    sub_10023F90(a1, (int)&byte_10121F10[24 * (unsigned __int8)a1]);
  *a2 = byte_10121F10[24 * (unsigned __int8)a1];
  return 1;
}
// 10121F08: using guessed type int dword_10121F08;

//----- (100235F0) --------------------------------------------------------
char __thiscall sub_100235F0(void *this)
{
  char v1; // bl@1
  char *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_10121F08 = sub_1000EB50(this) != 2 ? 1379255385 : 1916032632;
  memset(byte_10121F10, 0, 0x48u);
  v1 = 0;
  v4 = 0;
  v2 = byte_10121F10;
  do
  {
    result = sub_10023F90(v4, (int)v2);
    ++v1;
    v2 += 24;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 3u );
  return result;
}
// 10121F08: using guessed type int dword_10121F08;

//----- (10023660) --------------------------------------------------------
char __cdecl sub_10023660(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_1000EC70(a1);
  v3 = sub_10032B40(a2, 0, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (10023690) --------------------------------------------------------
char __cdecl sub_10023690(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_1000EC70(a1);
  v3 = sub_10032BB0(a2, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (100236C0) --------------------------------------------------------
char __cdecl sub_100236C0(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6)
{
  char result; // al@3
  char v7; // [sp+0h] [bp-4h]@1

  v7 = sub_1000ED60(a1);
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        result = sub_10023540(v7, *a4, (int)a5);
      }
      else
      {
        sub_1000D740("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 531, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        result = sub_10023470(v7, *a4, (int)a5);
      }
      else
      {
        sub_1000D740("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 548, 0, 0);
        result = 0;
      }
      break;
    case 3:
      if ( a6 >= 4 )
      {
        result = sub_100234E0(v7, *a4, (int)a5);
      }
      else
      {
        sub_1000D740("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 565, 0, 0);
        result = 0;
      }
      break;
    case 7:
      if ( a6 >= 1 )
      {
        result = sub_100235B0(v7, a5);
      }
      else
      {
        sub_1000D740("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 582, 0, 0);
        result = 0;
      }
      break;
    case 0x10:
      if ( a6 >= 0x40 )
      {
        result = sub_10023690(v7, (int)a5);
      }
      else
      {
        sub_1000D740("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 598, 0, 0);
        result = 0;
      }
      break;
    case 0xF:
      if ( a6 >= 0x68 )
      {
        result = sub_10023660(v7, (int)a5);
      }
      else
      {
        sub_1000D740("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 616, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_1000D740("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 633, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10023890) --------------------------------------------------------
int __cdecl sub_10023890(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10121F58 = *(_DWORD *)a1;
  dword_10121F5C = *(_DWORD *)(a1 + 4);
  dword_10121F60 = *(_DWORD *)(a1 + 8);
  dword_10121F64 = *(_DWORD *)(a1 + 12);
  dword_101EFB50 = (int)&dword_10121F58;
  return result;
}
// 10121F58: using guessed type int dword_10121F58;
// 10121F5C: using guessed type int dword_10121F5C;
// 10121F60: using guessed type int dword_10121F60;
// 10121F64: using guessed type int dword_10121F64;
// 101EFB50: using guessed type int dword_101EFB50;

//----- (100238D0) --------------------------------------------------------
bool __cdecl sub_100238D0(void *a1)
{
  char v1; // cl@1

  v1 = sub_10013EB0(1, 1946, a1);
  *((_DWORD *)a1 + 1) /= 0x3E8u;
  return v1 && !sub_10018360((int)a1);
}

//----- (10023910) --------------------------------------------------------
int __cdecl sub_10023910(char a1)
{
  int result; // eax@2
  int v2; // [sp+0h] [bp-4h]@1

  v2 = 0;
  if ( a1 == 1 )
  {
    sub_10031C90(10026, (int)&v2, 4);
    result = v2;
  }
  else
  {
    sub_10031C90(10027, (int)&v2, 4);
    result = v2;
  }
  return result;
}

//----- (10023990) --------------------------------------------------------
char __cdecl sub_10023990(int a1)
{
  int v2; // [sp+0h] [bp-Ch]@1
  char v3; // [sp+4h] [bp-8h]@1

  v2 = 1000 * a1;
  v3 = 2;
  sub_100139E0(1, 1671, &v2, 0, 8, 1);
  return sub_10013B20(1, 0x687u, 0xFFFFFFF);
}

//----- (100239F0) --------------------------------------------------------
char __cdecl sub_100239F0(char a1)
{
  sub_100139E0(1, 1672, &a1, 0, 1, 1);
  return sub_10013B20(1, 0x688u, 0xFFFFFFF);
}

//----- (10023A20) --------------------------------------------------------
char __cdecl sub_10023A20(char a1, int a2)
{
  int v2; // eax@2

  if ( a1 == 1 )
  {
    v2 = sub_10031CC0(10026, (int)&a2, 4);
    if ( !v2 )
      LOBYTE(v2) = sub_10023990(a2);
  }
  else
  {
    LOBYTE(v2) = sub_10031CC0(10027, (int)&a2, 4);
  }
  return v2;
}

//----- (10023A60) --------------------------------------------------------
char __cdecl sub_10023A60(char a1)
{
  int v1; // eax@1

  v1 = sub_10031CC0(10028, (int)&a1, 1);
  if ( !v1 )
    LOBYTE(v1) = sub_100239F0(a1);
  return v1;
}

//----- (10023A90) --------------------------------------------------------
BOOL __cdecl sub_10023A90(unsigned __int8 a1)
{
  return a1 <= 1u;
}

//----- (10023AA0) --------------------------------------------------------
BOOL __usercall sub_10023AA0@<eax>(unsigned __int8 a1@<al>, char a2)
{
  _BYTE *v2; // ecx@1

  return (unsigned __int8)sub_10023A90(a1) && *v2 < 3u && a2 == 24;
}

//----- (10023AD0) --------------------------------------------------------
bool __cdecl sub_10023AD0(char a1, char a2, unsigned __int8 a3, int a4)
{
  bool v4; // bl@1
  unsigned __int8 v5; // cl@2
  int v6; // esi@3
  char v8; // al@16
  char v9; // cl@16
  char v10; // dl@16
  int v11; // ecx@18
  int v12; // edx@18
  int v13; // eax@18
  char v14; // [sp+Bh] [bp-29h]@3
  int v15; // [sp+Ch] [bp-28h]@9
  struct tm Tm; // [sp+10h] [bp-24h]@5

  v4 = 0;
  if ( a3 < 3u )
  {
    if ( (unsigned __int8)sub_10023A90(a1) )
    {
      v6 = 10 * v5;
      if ( sub_10018870((unsigned __int8)byte_1009E100[20 * v5], (bool *)&v14) )
      {
        if ( v14 )
        {
          if ( !sub_10013EB0(1, (unsigned __int16)word_1009E0F8[v6], &Tm.tm_mon) || sub_10018310((int)&Tm.tm_mon) )
            return 0;
          v4 = 1;
        }
        else
        {
          if ( !(unsigned __int8)sub_100122E0(a1, &v15) || v15 != dword_1009E118[2 * a3] || a2 == 11 )
            return v4;
          Tm.tm_sec = 0;
          Tm.tm_min = 0;
          Tm.tm_hour = 0;
          LOBYTE(Tm.tm_mday) = 0;
          v4 = sub_10013EB0(1, (unsigned __int16)word_1009E0FC[v6], &Tm) && !_mkgmtime(&Tm);
          v8 = BYTE1(Tm.tm_hour);
          v9 = BYTE2(Tm.tm_min);
          *((_BYTE *)&Tm.tm_mon + 4 * a3) = Tm.tm_min;
          v10 = BYTE2(Tm.tm_hour);
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 2) = v8;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 1) = v9;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 3) = v10;
          if ( !v4 )
            return v4;
        }
        if ( a2 == 11 )
        {
          v11 = Tm.tm_year;
          v12 = Tm.tm_wday;
          *(_DWORD *)a4 = Tm.tm_mon;
          v13 = Tm.tm_yday;
          *(_DWORD *)(a4 + 4) = v11;
          *(_DWORD *)(a4 + 8) = v12;
          *(_DWORD *)(a4 + 12) = v13;
          return v4;
        }
        *(_DWORD *)a4 = *(&Tm.tm_mon + a3);
      }
    }
  }
  return v4;
}
// 1009E0F8: using guessed type __int16 word_1009E0F8[];
// 1009E0FC: using guessed type __int16 word_1009E0FC[];
// 1009E118: using guessed type int dword_1009E118[];

//----- (10023C80) --------------------------------------------------------
bool __cdecl sub_10023C80(unsigned __int8 a1, int a2)
{
  bool v2; // dl@1
  unsigned __int8 v3; // cl@1
  bool result; // al@2

  if ( (unsigned __int8)sub_10023A90(a1) )
    result = sub_10031BF0((unsigned __int16)word_1009E102[10 * v3], a2, 32) == 0;
  else
    result = v2;
  return result;
}
// 1009E102: using guessed type __int16 word_1009E102[];

//----- (10023CC0) --------------------------------------------------------
char __cdecl sub_10023CC0(unsigned __int8 a1, char a2)
{
  char result; // al@1
  unsigned __int8 v3; // cl@1
  int v4; // esi@2

  result = sub_10023A90(a1);
  if ( result )
  {
    v4 = 5 * v3;
    sub_100139E0(1, (unsigned __int16)word_1009E0F2[10 * v3], &a2, 0, 1, 1);
    result = sub_10013B20(1, word_1009E0F2[2 * v4], 0xFFFFFFF);
  }
  return result;
}
// 1009E0F2: using guessed type __int16 word_1009E0F2[];

//----- (10023D10) --------------------------------------------------------
bool __cdecl sub_10023D10(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6)
{
  unsigned __int8 v6; // dl@1
  bool result; // al@4
  char v8; // [sp+13h] [bp-29h]@5
  unsigned int v9; // [sp+14h] [bp-28h]@1
  char v10; // [sp+18h] [bp-24h]@7
  int v11[7]; // [sp+1Ch] [bp-20h]@8

  LOBYTE(v9) = sub_10012230(a1);
  if ( !(unsigned __int8)sub_10023AA0(v9, a3) || a6 != 4 )
    goto LABEL_12;
  if ( !a2 )
    return sub_10023AD0(v9, a3, *a4, (int)a5);
  if ( sub_10018870((unsigned __int8)byte_1009E100[20 * v6], (bool *)&v8) && v8 && sub_10023C80(v9, (int)&v10) )
  {
    *a5 = v11[*a4];
    result = 1;
  }
  else
  {
LABEL_12:
    result = 0;
  }
  return result;
}
// 10023D10: using guessed type int var_20[7];

//----- (10023E00) --------------------------------------------------------
signed int __cdecl sub_10023E00(char a1, char a2)
{
  _DWORD *v2; // esi@3
  int v3; // eax@5
  char *v5; // [sp-18h] [bp-20h]@3
  void *v6; // [sp-10h] [bp-18h]@3
  int v7; // [sp-8h] [bp-10h]@3

  if ( a2 == 11 )
  {
    v7 = 3;
    v2 = &unk_1009E220;
    v6 = &unk_1009E220;
    v5 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v7 = 7;
    v2 = &unk_1009E238;
    v6 = &unk_1009E238;
    v5 = &a1;
  }
  v3 = sub_10016EA0(v5, 1u, (int)v6, 8, v7, 7);
  if ( v3 < 7 )
    return v2[2 * v3 + 1];
  return 42066;
}

//----- (10023E60) --------------------------------------------------------
int __cdecl sub_10023E60(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10016EA0(&a1, 1u, (int)&unk_1009E280, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_1009E284[2 * v1];
  return result;
}
// 1009E284: using guessed type int dword_1009E284[];

//----- (10023EA0) --------------------------------------------------------
signed int __cdecl sub_10023EA0(char a1, char a2, char a3)
{
  _DWORD *v3; // esi@3
  int v4; // eax@5
  signed int result; // eax@7
  char *v6; // [sp-18h] [bp-20h]@3
  void *v7; // [sp-10h] [bp-18h]@3

  if ( a2 == 11 )
  {
    v3 = &unk_1009E290;
    v7 = &unk_1009E290;
    v6 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v3 = &unk_1009E2A8;
    v7 = &unk_1009E2A8;
    v6 = &a1;
  }
  v4 = sub_10016EA0(v6, 1u, (int)v7, 12, 2, 2);
  if ( v4 == 2 )
    return 42066;
  if ( a3 )
    result = v3[3 * v4 + 1];
  else
    result = v3[3 * v4 + 2];
  return result;
}

//----- (10023F10) --------------------------------------------------------
int __cdecl sub_10023F10(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10016EA0(&a1, 1u, (int)&unk_1009E2C0, 8, 3, 3);
  if ( v1 == 3 )
    result = 42066;
  else
    result = dword_1009E2C4[2 * v1];
  return result;
}
// 1009E2C4: using guessed type int dword_1009E2C4[];

//----- (10023F50) --------------------------------------------------------
int __cdecl sub_10023F50(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10016EA0(&a1, 1u, (int)&unk_1009E2D8, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_1009E2DC[2 * v1];
  return result;
}
// 1009E2DC: using guessed type int dword_1009E2DC[];

//----- (10023F90) --------------------------------------------------------
char __cdecl sub_10023F90(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10023E00(a1, 11);
  return sub_10031C10(v2, a2, 24);
}

//----- (10023FB0) --------------------------------------------------------
char __cdecl sub_10023FB0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10023E60(a1);
  return sub_10031C10(v2, a2, 2720);
}

//----- (10023FE0) --------------------------------------------------------
char __cdecl sub_10023FE0(char a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@1

  v2 = sub_10023EA0(a1, 11, 1);
  sub_10031C10(v2, a2, 36);
  v3 = sub_10023EA0(a1, 11, 0);
  return sub_10031C10(v3, a2 + 36, 32);
}

//----- (10024030) --------------------------------------------------------
char __cdecl sub_10024030(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10023F10(a1);
  return sub_10031C10(v2, a2, 2192);
}

//----- (10024060) --------------------------------------------------------
char __cdecl sub_10024060(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10023F50(a1);
  return sub_10031C10(v2, a2, 60);
}

//----- (10024080) --------------------------------------------------------
char __cdecl sub_10024080(int a1)
{
  return sub_10031C10(6453, a1, 5);
}

//----- (100240A0) --------------------------------------------------------
char __cdecl sub_100240A0(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_10012820(11);
  }
  else
  {
    result = sub_10012820(5);
  }
  return result;
}

//----- (100240D0) --------------------------------------------------------
char sub_100240D0()
{
  char v1; // [sp+4h] [bp-100h]@1

  memset(&v1, 0, 0xFCu);
  if ( sub_10013EB0(1, 1309, &v1) )
    sub_10018450((int)&v1);
  return 0;
}

//----- (10024170) --------------------------------------------------------
BOOL __cdecl sub_10024170(int a1, int a2)
{
  return sub_10031BF0(6455, a2, 252) == 0;
}

//----- (10024190) --------------------------------------------------------
char __cdecl sub_10024190(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10024170(a1, a5);
  }
  else
  {
    result = sub_100240D0();
  }
  return result;
}

//----- (100241D0) --------------------------------------------------------
char __thiscall sub_100241D0(void *this)
{
  int v1; // eax@1
  char result; // al@3

  v1 = sub_100128C0(this) - 2;
  if ( v1 )
  {
    if ( v1 == 2 )
      result = 2;
    else
      result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (100241F0) --------------------------------------------------------
_DWORD *__usercall sub_100241F0@<eax>(int a1@<eax>, int a2@<esi>, char *a3, char *a4)
{
  _DWORD *result; // eax@1

  sub_1002F5B0(a2, a1);
  result = (_DWORD *)sub_10010020(a3, a4);
  if ( (_BYTE)result )
    result = sub_10001790(a2);
  return result;
}

//----- (100242D0) --------------------------------------------------------
char __cdecl sub_100242D0(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@1
  void *v4; // ecx@2
  int v5; // eax@3
  int v6; // eax@5
  char v7; // al@4
  int v8; // ecx@14
  char v9; // al@17
  char *v10; // eax@22
  char v12; // [sp+4h] [bp-10h]@20
  char v13; // [sp+8h] [bp-Ch]@11
  char v14; // [sp+Ch] [bp-8h]@18
  char v15; // [sp+10h] [bp-4h]@15
  char v16; // [sp+1Ch] [bp+8h]@3

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 52);
  if ( *(_WORD *)v3 != -32696 )
    return v3;
  v4 = (void *)*(_WORD *)(v3 + 10);
  if ( (unsigned __int16)v4 & 0xC000 )
    return v3;
  v5 = *(_DWORD *)(v3 + 4);
  v16 = -1;
  if ( v5 )
  {
    v7 = sub_1000F6E0(*(int (__cdecl **)(int))(v5 + 8));
LABEL_7:
    v16 = v7;
    goto LABEL_8;
  }
  v6 = *(_DWORD *)(v2 + 48);
  if ( v6 )
  {
    v7 = sub_1000F6E0(*(int (__cdecl **)(int))(v6 + 8));
    goto LABEL_7;
  }
LABEL_8:
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 1 )
    goto LABEL_26;
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 2 )
  {
    v13 = 8;
    goto LABEL_14;
  }
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 4 )
  {
LABEL_26:
    v13 = 7;
    goto LABEL_14;
  }
  v13 = sub_100241D0(v4);
LABEL_14:
  v8 = *(_DWORD *)(v2 + 52);
  if ( *(_WORD *)(v8 + 10) == 0x2000 )
    v15 = *(_BYTE *)(v8 + 14) - 92;
  else
    v15 = *(_BYTE *)(v8 + 10);
  v9 = *(_BYTE *)(v8 + 8);
  if ( v9 >= 0 )
  {
    v14 = 0;
  }
  else
  {
    v14 = 1;
    v9 = -v9;
  }
  v12 = v9;
  if ( *(_WORD *)(v8 + 12) )
    v12 = v9 * *(_BYTE *)(v8 + 12);
  v10 = sub_1000F710(v16);
  LOBYTE(v3) = sub_1002F5D0(v13, v16, v15, v12, v14, *(_DWORD *)(v2 + 64), 0, 0, v10);
  return v3;
}

//----- (100243D0) --------------------------------------------------------
_DWORD *sub_100243D0()
{
  char v1; // [sp+4h] [bp-104h]@1

  sub_10031C90(6463, (int)&v1, 256);
  sub_100241F0((int)sub_10024280, (int)&unk_10121F78, &v1, "PAGE_INIT");
  sub_100241F0((int)sub_10024220, (int)&unk_10121F68, &v1, "PAGE_SET_FOCUS");
  return sub_100241F0((int)sub_100242D0, (int)&unk_10121F70, &v1, "KEY_PRESS");
}
// 10024220: using guessed type int sub_10024220();
// 10024280: using guessed type int sub_10024280();

//----- (10024460) --------------------------------------------------------
signed int __cdecl sub_10024460(_BYTE *a1, char a2, int a3)
{
  signed int result; // eax@1

  result = -4;
  if ( a3 && a3 != 1 || (!*a1 || *a1 == 1 ? (result = 0) : (result = -2), a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_11;
  }
  if ( result )
  {
LABEL_11:
    *a1 = a2;
    result = 1;
  }
  return result;
}

//----- (100244B0) --------------------------------------------------------
int __cdecl sub_100244B0(int a1, float a2, float a3, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  char v7; // dl@4
  char v8; // al@4
  char v9; // dl@4
  int result; // eax@5
  double v11; // st7@7
  unsigned int v12; // eax@21

  v5 = a1;
  v6 = a1 & 3;
  if ( a1 & 3 || (unsigned int)&a1 & 3 )
  {
    v7 = *(_BYTE *)(a1 + 1);
    LOBYTE(a1) = *(_BYTE *)a1;
    v8 = *(_BYTE *)(v5 + 2);
    BYTE1(a1) = v7;
    v9 = *(_BYTE *)(v5 + 3);
    BYTE2(a1) = v8;
    BYTE3(a1) = v9;
  }
  else
  {
    a1 = *(int *)a1;
  }
  result = -4;
  if ( a5 && a5 != 1
    || ((v11 = *(float *)&a1, (a1 & 0x7F800000) != 2139095040) ? (a2 <= v11 ? (a3 >= v11 ? (result = 0) : (result = -2)) : (result = -1)) : (result = -3),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v12 = a4;
    *(_BYTE *)(v5 + 1) = BYTE1(a4);
    *(_BYTE *)v5 = v12;
    *(_BYTE *)(v5 + 3) = BYTE3(v12);
    *(_BYTE *)(v5 + 2) = v12 >> 16;
    result = 1;
  }
  else
  {
    *(_DWORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (100245A0) --------------------------------------------------------
unsigned int __cdecl sub_100245A0(char *a1, char a2, char a3, char a4, int a5)
{
  char v5; // dl@1
  unsigned int result; // eax@1
  int v7; // eax@5

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1
    || (v5 >= a2 ? (v7 = v5 < a3, LOBYTE(v7) = v5 <= a3, result = (v7 - 1) & 0xFFFFFFFE) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (100245F0) --------------------------------------------------------
unsigned int __cdecl sub_100245F0(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  _BYTE *v8; // esi@3
  int v9; // eax@9
  signed int v10; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((signed int)v8 >= a2 ? (v9 = (signed int)v8 < a3,
                                LOBYTE(v9) = (signed int)v8 <= a3,
                                result = (v9 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v10 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v10;
    v5[3] = BYTE3(v10);
    v5[2] = v10 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (100246B0) --------------------------------------------------------
unsigned int __cdecl sub_100246B0(void *a1, size_t a2, int a3)
{
  unsigned int result; // eax@1
  int v4; // eax@3
  int v5; // ecx@3
  unsigned int v6; // ecx@3

  result = -4;
  if ( a3 && a3 != 1
    || (v4 = sub_1000F580(a1, a2), v5 = v4 < 0, LOBYTE(v5) = v4 >= 0, v6 = (v5 - 1) & 0xFFFFFFFC, result = v6, a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_7;
  }
  if ( v6 )
  {
LABEL_7:
    memset(a1, 0, a2);
    result = 1;
  }
  return result;
}

//----- (10024710) --------------------------------------------------------
int __cdecl sub_10024710(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
  unsigned __int8 v5; // dl@1
  int result; // eax@1

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1 || (v5 >= a2 ? (result = a3 < v5 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (10024760) --------------------------------------------------------
int __cdecl sub_10024760(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // esi@1
  int result; // eax@1
  char v8; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned __int16)a1 >= a2 ? (result = a3 < (unsigned __int16)a1 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v8 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v8;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10024800) --------------------------------------------------------
int __cdecl sub_10024800(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  int result; // eax@1
  _BYTE *v8; // esi@3
  unsigned int v9; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned int)v8 >= a2 ? (result = a3 < (unsigned int)v8 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v9 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v9;
    v5[3] = BYTE3(v9);
    v5[2] = v9 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (100248B0) --------------------------------------------------------
char __cdecl sub_100248B0(unsigned __int16 a1, _BYTE *a2, _WORD *a3)
{
  char result; // al@4

  if ( a1 < 0x1D8u && a2 && a3 )
  {
    *a2 = byte_100A0580[4 * a1];
    *a3 = word_100A0582[2 * a1];
    result = 1;
  }
  else
  {
    sub_1000D740("..\\lib\\adl\\iop_eau_data_tbl.c", 614, 0, 0);
    result = 0;
  }
  return result;
}
// 100A0582: using guessed type __int16 word_100A0582[];

//----- (10024910) --------------------------------------------------------
double __cdecl sub_10024910(int a1)
{
  double v1; // st6@1

  v1 = (double)(unsigned int)((*(int (**)(void))(dword_101EFB50 + 8))() - a1);
  return (float)(1.0 / (double)(*(int (**)(void))(dword_101EFB50 + 12))() * v1);
}
// 101EFB50: using guessed type int dword_101EFB50;

//----- (10024960) --------------------------------------------------------
char __cdecl sub_10024960(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@11
  int v4; // eax@16
  int v6; // [sp+8h] [bp-54h]@1
  int v7; // [sp+Ch] [bp-50h]@1
  int v8; // [sp+10h] [bp-4Ch]@1
  int v9; // [sp+14h] [bp-48h]@1
  int v10; // [sp+18h] [bp-44h]@1
  char v11; // [sp+1Ch] [bp-40h]@16

  LOBYTE(v2) = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( a1 == 28 || a1 == 29 || a1 == 30 || a1 == 31 || a1 == 32 || a1 == 48 || a1 == 33 || a1 == 34 )
  {
    v2 = sub_10016EA0((_DWORD *)a2, 2u, (int)&unk_100A0D60, 8, 77, 77);
    if ( v2 != 77 )
    {
      if ( *(_WORD *)a2 == -32768 )
      {
        v3 = *(_WORD *)(a2 + 10) + 16;
      }
      else if ( *(_WORD *)a2 == -32767 )
      {
        v3 = *(_DWORD *)(a2 + 4) + 8;
      }
      else
      {
        v3 = dword_100A0D64[2 * v2] + 4;
      }
      v7 = v3;
      v10 = 65;
      v6 = a2;
      v9 = 10;
      v2 = sub_10031A40(a1, (int)&v6);
      if ( v2 == 16 )
      {
        v4 = sub_100318A0();
        sub_1000F650(&v11, 0x3Cu, "message queue timed out sending from: %d to %d", v4, a1);
        LOBYTE(v2) = sub_1000D740("..\\lib\\adl\\iop_msg_intf.c", 433, 0, &v11);
      }
    }
  }
  return v2;
}
// 100A0D64: using guessed type int dword_100A0D64[];

//----- (10024A80) --------------------------------------------------------
char __cdecl sub_10024A80(int a1)
{
  return sub_10024960(31, a1);
}

//----- (10024A90) --------------------------------------------------------
bool __cdecl sub_10024A90(unsigned int a1)
{
  return a1 - 108100 <= 0xF0A && a1 / 0x64 & 1;
}

//----- (10024AC0) --------------------------------------------------------
int __cdecl sub_10024AC0(int a1, float a2)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
    *(float *)a1 = a2 * 1.799999952316284 + 32.0;
  return result;
}

//----- (10024AE0) --------------------------------------------------------
int __cdecl sub_10024AE0(int a1, float a2)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
    *(float *)a1 = (a2 - 32.0) * 0.5555555820465088;
  return result;
}

//----- (10024B00) --------------------------------------------------------
bool __cdecl sub_10024B00(int a1, void *a2, int a3)
{
  unsigned __int16 v3; // ax@2
  bool result; // al@5
  char v5[4]; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v5[0] = -1;
  v6 = 0;
  result = 0;
  if ( sub_1002F6A0(a1, a3, v5, &v6) == 1 )
  {
    v3 = sub_10013210(v5[0]);
    if ( (unsigned __int16)v6 < v3 && sub_10013EB0(v5[0], v6, a2) && !sub_10024460(a2, 0, 0) )
      result = 1;
  }
  return result;
}

//----- (10024B80) --------------------------------------------------------
char __cdecl sub_10024B80(unsigned __int16 a1)
{
  char result; // al@3
  char v2; // [sp+Bh] [bp-9h]@3
  int v3; // [sp+Ch] [bp-8h]@1
  int v4; // [sp+10h] [bp-4h]@1

  LOBYTE(v4) = 7;
  v3 = 0;
  if ( sub_1002F6A0(a1, 0, &v4, &v3) != 1 && sub_1002F6A0(a1, 1u, &v4, &v3) != 1
    || (result = sub_100135A0(v4, v3, &v2), result != 1)
    || v2 != 1 )
  {
    result = 0;
  }
  return result;
}

//----- (10024BF0) --------------------------------------------------------
bool __cdecl sub_10024BF0(int a1, void *a2)
{
  void *v2; // ecx@0
  int v3; // ST0C_4@1

  v3 = (int)v2;
  LOBYTE(v3) = sub_10016E40(v2) != 0;
  return sub_10024B00(a1, a2, v3);
}

//----- (10024C20) --------------------------------------------------------
char __cdecl sub_10024C20(unsigned __int16 a1)
{
  char v1; // bl@1
  char result; // al@5
  char v3; // [sp+Bh] [bp-411h]@2
  int v4; // [sp+Ch] [bp-410h]@1
  int v5; // [sp+10h] [bp-40Ch]@1
  char v6[1028]; // [sp+14h] [bp-408h]@5

  v1 = 0;
  if ( sub_100248B0(a1, &v5, &v4) && sub_100135A0(v5, v4, &v3) && (v1 = v3) != 0
    || a1 >= 0x1D8u
    || (sub_10031C90(6943, (int)v6, 1028), result = 1, !v6[a1]) )
  {
    result = v1;
  }
  return result;
}
// 10024C20: using guessed type char var_408[1028];

//----- (10024CC0) --------------------------------------------------------
char __cdecl sub_10024CC0(char a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@3
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1002FA80(a1);
  switch ( a3 )
  {
    case 5:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1002F880(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 4:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1002F900(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 0xA:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1002F980(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 3:
      if ( a2 != 1 )
        goto LABEL_10;
      result = sub_1002FA00(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      break;
    default:
LABEL_10:
      result = 0;
      break;
  }
  return result;
}

//----- (10024DD0) --------------------------------------------------------
int __cdecl sub_10024DD0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10016EA0(&a1, 1u, (int)&unk_100A2778, 8, 4, 4);
  if ( v1 == 4 )
  {
    sub_1000D740("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_intf.c", 437, 0, 0);
    result = 42066;
  }
  else
  {
    result = dword_100A277C[2 * v1];
  }
  return result;
}
// 100A277C: using guessed type int dword_100A277C[];

//----- (10024E20) --------------------------------------------------------
char __cdecl sub_10024E20(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // ecx@2
  int v5; // [sp+0h] [bp-Ch]@1
  __int16 v6; // [sp+4h] [bp-8h]@2
  int v7; // [sp+8h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_101EFA5C)(a1, 12, &v5);
  if ( result )
  {
    v3 = v6;
    *(_DWORD *)a2 = v5;
    v4 = v7 & 0xFFFFFF;
    *(_WORD *)(a2 + 4) = v3;
    *(_DWORD *)(a2 + 8) = v4;
    result = 1;
  }
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;

//----- (10024E70) --------------------------------------------------------
char __cdecl sub_10024E70(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  __int16 v4; // cx@2
  __int16 v5; // dx@2
  __int16 v6; // cx@2
  int v7; // edx@2
  __int16 v8; // cx@2
  unsigned int v9; // ecx@2
  int v10; // edx@2
  __int16 v11; // [sp+0h] [bp-1Ch]@1
  __int16 v12; // [sp+2h] [bp-1Ah]@2
  __int16 v13; // [sp+4h] [bp-18h]@2
  __int16 v14; // [sp+6h] [bp-16h]@2
  __int16 v15; // [sp+8h] [bp-14h]@2
  int v16; // [sp+Ah] [bp-12h]@2
  __int16 v17; // [sp+Eh] [bp-Eh]@2
  int v18; // [sp+12h] [bp-Ah]@2
  unsigned int v19; // [sp+16h] [bp-6h]@2
  char v20; // [sp+1Ah] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_101EFA5C)(a1, 27, &v11);
  if ( result )
  {
    v3 = v12;
    *(_WORD *)a2 = v11;
    v4 = v13;
    *(_WORD *)(a2 + 2) = v3;
    v5 = v14;
    *(_WORD *)(a2 + 4) = v4;
    v6 = v15;
    *(_WORD *)(a2 + 6) = v5;
    *(_DWORD *)(a2 + 12) = v16;
    v7 = v18;
    *(_WORD *)(a2 + 8) = v6;
    v8 = v17;
    *(_DWORD *)(a2 + 20) = v7;
    *(_WORD *)(a2 + 16) = v8;
    v9 = v19;
    *(_DWORD *)(a2 + 24) = v19 & 3;
    *(_DWORD *)(a2 + 28) = (v9 >> 2) & 1;
    v10 = (v9 >> 3) & 3;
    *(_DWORD *)(a2 + 36) = (v9 >> 5) & 1;
    LOBYTE(v9) = v20;
    *(_DWORD *)(a2 + 32) = v10;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v9 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v9 >> 6;
    result = 1;
  }
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;

//----- (10024F20) --------------------------------------------------------
char __cdecl sub_10024F20(int a1, int a2)
{
  char result; // al@1
  char v3; // ah^2@2
  __int16 v4; // dx@2
  __int16 v5; // dx@2
  int v6; // [sp+0h] [bp-8h]@1
  unsigned int v7; // [sp+4h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_101EFA5C)(a1, 8, &v6);
  if ( result )
  {
    v3 = BYTE3(v6);
    *(_DWORD *)a2 = v6 & 0xFFFFFF;
    LOBYTE(v4) = 0;
    HIBYTE(v4) = v3;
    v5 = (unsigned __int8)v7 ^ v4;
    *(_DWORD *)(a2 + 8) = v7 >> 8;
    *(_WORD *)(a2 + 4) = v5;
    result = 1;
  }
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;

//----- (10024F80) --------------------------------------------------------
char __cdecl sub_10024F80(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // esi@2
  unsigned int v5; // ecx@2
  __int16 v6; // [sp+0h] [bp-14h]@1
  __int16 v7; // [sp+2h] [bp-12h]@2
  __int16 v8; // [sp+4h] [bp-10h]@2
  __int16 v9; // [sp+6h] [bp-Eh]@2
  __int16 v10; // [sp+8h] [bp-Ch]@2
  unsigned __int16 v11; // [sp+Ah] [bp-Ah]@2
  int v12; // [sp+Ch] [bp-8h]@2
  char v13; // [sp+12h] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_101EFA5C)(a1, 19, &v6);
  if ( result )
  {
    v3 = v7;
    *(_WORD *)a2 = v6;
    *(_WORD *)(a2 + 4) = v8;
    *(_WORD *)(a2 + 8) = v10;
    *(_WORD *)(a2 + 2) = v3;
    v4 = v11;
    *(_WORD *)(a2 + 6) = v9;
    LOBYTE(v3) = v13;
    *(_DWORD *)(a2 + 12) = v4 + ((v13 & 7) << 16);
    *(_WORD *)(a2 + 16) = v12 & 0x3FFF;
    v5 = *(int *)((char *)&v12 + 2);
    *(_DWORD *)(a2 + 20) = *(int *)((char *)&v12 + 2) & 0xFFFFFF;
    *(_DWORD *)(a2 + 24) = (v5 >> 24) & 3;
    *(_DWORD *)(a2 + 28) = (v5 >> 26) & 1;
    *(_DWORD *)(a2 + 36) = (v5 >> 29) & 1;
    *(_DWORD *)(a2 + 32) = (v5 >> 27) & 3;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v3 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v3 >> 6;
    result = 1;
  }
  return result;
}
// 101EFA5C: using guessed type int dword_101EFA5C;

//----- (10025050) --------------------------------------------------------
char sub_10025050()
{
  return 2;
}

//----- (10025060) --------------------------------------------------------
char sub_10025060()
{
  unsigned __int16 v0; // dx@1
  int v1; // ecx@2
  unsigned __int16 v2; // ax@9
  int v4[7]; // [sp+8h] [bp-1Ch]@1

  sub_10031C90(6465, (int)v4, 28);
  v0 = 0;
LABEL_2:
  v1 = v4[v0];
  if ( v1 == 1 || v1 == 2 || v1 == 4 || v1 == 64 || v1 == 128 || v1 == 16 || v1 == 32 )
  {
    v2 = 0;
    while ( v2 == v0 || v4[v2] != v1 )
    {
      if ( ++v2 >= 7u )
      {
        if ( ++v0 < 7u )
          goto LABEL_2;
        return 1;
      }
    }
  }
  return 0;
}
// 10025060: using guessed type int var_1C[7];

//----- (100250E0) --------------------------------------------------------
signed int sub_100250E0()
{
  return sub_100327D0((int)&off_100A34B8);
}
// 100A34B8: using guessed type char *off_100A34B8;

//----- (100250F0) --------------------------------------------------------
char __usercall sub_100250F0@<al>(unsigned __int8 a1@<al>, char a2, void *a3)
{
  unsigned __int8 v3; // bl@1
  char result; // al@7

  v3 = a1;
  if ( (unsigned __int8)(a1 - 53) > 0xDu
    || (unsigned __int8)a2 >= 3u
    || !(unsigned __int8)sub_100250E0()
    || sub_100319E0(33, 10) )
  {
    sub_1000D740("..\\lib\\adl\\iop_data.c", 366, 0, 0);
    result = 0;
  }
  else if ( (unsigned int)(sub_10031910()
                         - *(_DWORD *)(dword_101EFB48 + 4 * (v3 - 33 + (unsigned __int8)a2 + 2 * (v3 - 33)))) <= 0x258
         && *(_BYTE *)(v3 + (unsigned __int8)a2 + 2 * v3 + dword_101EFB48 + 37) )
  {
    memcpy_0(
      a3,
      (const void *)(dword_101EFB48 + 4 * (v3 - 53 + (unsigned __int8)a2 + 2 * (v3 - 53))),
      *(_WORD *)(dword_101EFB48 + 2 * v3 + 62));
    sub_100319C0(33);
    result = 1;
  }
  else
  {
    sub_100319C0(33);
    result = 0;
  }
  return result;
}
// 101EFB48: using guessed type int dword_101EFB48;

//----- (100251D0) --------------------------------------------------------
char __cdecl sub_100251D0(int a1, char a2, void *a3)
{
  char result; // al@1
  int v4; // eax@4
  int v5; // esi@6
  int v6; // edi@7

  result = 0;
  if ( (unsigned __int8)a1 < 0x43u && (unsigned __int8)a2 < 3u )
  {
    if ( (unsigned __int8)a1 > 0x34u )
    {
      result = sub_100250F0(a1, a2, a3);
    }
    else
    {
      v4 = sub_1002FB50(a1);
      if ( v4
        && (v5 = v4 + 4 * (unsigned __int8)a2, *(_BYTE *)v5 < 7)
        && (v6 = *(_WORD *)(v5 + 2), (unsigned __int16)v6 < (unsigned __int16)sub_10013210(*(_BYTE *)v5)) )
      {
        result = sub_10013EB0(*(_BYTE *)v5, v6, a3);
      }
      else
      {
        result = 0;
      }
    }
  }
  return result;
}
// 1002FB50: using guessed type _DWORD __cdecl sub_1002FB50(char);

//----- (10025250) --------------------------------------------------------
int __cdecl sub_10025250(char a1)
{
  return 9190 - (a1 != 1);
}

//----- (10025260) --------------------------------------------------------
int __usercall sub_10025260@<eax>(char *a1@<eax>, char a2@<cl>)
{
  return sub_1002FB60(a2, a1);
}

//----- (10025270) --------------------------------------------------------
char __usercall sub_10025270@<al>(char a1@<bl>, char a2)
{
  int v2; // eax@1
  char result; // al@2
  char *v4; // ecx@3
  unsigned __int8 v5; // [sp+4h] [bp-8Ch]@1
  char v6; // [sp+5h] [bp-8Bh]@2
  char v7[68]; // [sp+48h] [bp-48h]@1

  memset(&v5, 0, 0x43u);
  memset(v7, 0, 0x43u);
  sub_10025260((char *)&v5, a2);
  v2 = sub_10025250(a1);
  if ( sub_10031BF0(v2, (int)v7, 67) )
  {
    result = a1 == 1;
  }
  else
  {
    result = v7[v5];
    if ( v6 != 67 )
    {
      v4 = &v6;
      do
        ++v4;
      while ( *v4 != 67 );
    }
  }
  return result;
}
// 10025270: using guessed type char var_48[68];

//----- (10025330) --------------------------------------------------------
char __cdecl sub_10025330(char a1, char a2)
{
  return sub_10025270(a1, a2);
}

//----- (10025350) --------------------------------------------------------
int __cdecl sub_10025350(unsigned __int8 *a1)
{
  return sub_10024710(a1, 0, 0, 0, 0);
}

//----- (10025370) --------------------------------------------------------
unsigned int __cdecl sub_10025370(void *a1)
{
  return sub_100246B0(a1, 0x20u, 0);
}

//----- (10025390) --------------------------------------------------------
unsigned int __cdecl sub_10025390(void *a1)
{
  return sub_100246B0(a1, 0x1Cu, 0);
}

//----- (100253B0) --------------------------------------------------------
unsigned int __cdecl sub_100253B0(void *a1)
{
  return sub_100246B0(a1, 0x10u, 0);
}

//----- (100253D0) --------------------------------------------------------
unsigned int __cdecl sub_100253D0(void *a1)
{
  return sub_100246B0(a1, 0xCu, 0);
}

//----- (100253F0) --------------------------------------------------------
unsigned int __cdecl sub_100253F0(void *a1)
{
  return sub_100246B0(a1, 8u, 0);
}

//----- (10025410) --------------------------------------------------------
unsigned int __cdecl sub_10025410(void *a1)
{
  unsigned int result; // eax@1

  result = sub_10025370((char *)a1 + 64);
  if ( !result )
  {
    result = sub_10025390((char *)a1 + 36);
    if ( !result )
    {
      result = sub_100253B0(a1);
      if ( !result )
      {
        result = sub_100253D0((char *)a1 + 96);
        if ( !result )
        {
          result = sub_100253D0((char *)a1 + 24);
          if ( !result )
            result = sub_100253F0((char *)a1 + 16);
        }
      }
    }
  }
  return result;
}

//----- (10025470) --------------------------------------------------------
int __cdecl sub_10025470(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10024710(a1, 0, 0x7Fu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100254A0) --------------------------------------------------------
int __cdecl sub_100254A0(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int result; // eax@1
  unsigned int v4; // edx@1
  char v5; // bl@8
  char v6; // dl@13
  char v7; // cl@13

  v2 = a2 / 0x15180 % 0x5B5;
  result = a1;
  v4 = 4 * (a2 / 0x15180 / 0x5B5) + 1990;
  *(_WORD *)(a1 + 2) = v4;
  if ( v2 > 0x16D )
  {
    do
    {
      v2 -= 365;
      if ( !((unsigned __int16)v4 % 4) )
        --v2;
      LOWORD(v4) = v4 + 1;
    }
    while ( v2 > 0x16D );
    *(_WORD *)(a1 + 2) = v4;
  }
  if ( v2 >= 1 )
  {
    v5 = 0;
    if ( v2 > 0x3B && !(*(_WORD *)(a1 + 2) % 4) )
    {
      --v2;
      v5 = 1;
    }
    *(_BYTE *)a1 = 12;
    if ( v2 <= 0x14E )
    {
      do
        --*(_BYTE *)a1;
      while ( v2 <= LOWORD((&off_100A5744)[2 * *(_BYTE *)a1 + 2]) );
    }
    v6 = *(_BYTE *)a1;
    v7 = v2 - LOBYTE((&off_100A5744)[2 * *(_BYTE *)a1 + 2]);
    *(_BYTE *)(a1 + 1) = v7;
    if ( v5 == 1 && v6 == 2 )
      *(_BYTE *)(a1 + 1) = v7 + 1;
  }
  else
  {
    --*(_WORD *)(a1 + 2);
    *(_BYTE *)a1 = 12;
    *(_BYTE *)(a1 + 1) = 31;
  }
  return result;
}
// 100A5744: using guessed type char *;

//----- (10025590) --------------------------------------------------------
__int16 __cdecl sub_10025590(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  __int16 result; // ax@1

  v2 = a2 % 0x15180 % 0xE10;
  *(_WORD *)a1 = a2 % 0x15180 / 0xE10;
  *(_BYTE *)(a1 + 2) = v2 / 0x3C;
  result = 60 * (char)(v2 / 0x3C);
  *(_BYTE *)(a1 + 3) = v2 % 0x3C;
  return result;
}

//----- (100255E0) --------------------------------------------------------
__int16 __cdecl sub_100255E0(unsigned int *a1, _WORD *a2, _WORD *a3)
{
  unsigned int v3; // esi@1
  __int16 result; // ax@1
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1

  v3 = *a1;
  sub_10025590((int)&v5, *a1);
  sub_100254A0((int)&v6, v3);
  *a3 = (unsigned __int8)(BYTE3(v5) >> 1) | (unsigned __int16)(32 * (BYTE2(v5) | (unsigned __int16)((_WORD)v5 << 6)));
  result = BYTE1(v6);
  *a2 = BYTE1(v6) | (unsigned __int16)(32 * ((unsigned __int8)v6 | (unsigned __int16)(16 * (HIWORD(v6) - 60))));
  return result;
}

//----- (10025660) --------------------------------------------------------
int __cdecl sub_10025660(int a1)
{
  return (*(int (**)(void))(a1 + 4))();
}

//----- (10025670) --------------------------------------------------------
char __cdecl sub_10025670(signed int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax@2
  char result; // al@4

  if ( a1 < 50 && ((v3 = 592 * a1, byte_10181CD0[592 * a1]) || byte_10181D20[v3]) )
  {
    *a2 = &byte_10181CD0[v3];
    *a3 = &byte_10181D20[v3];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100256B0) --------------------------------------------------------
char *__cdecl sub_100256B0(const char *a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edi@1
  unsigned int v4; // esi@1

  v2 = 0;
  v3 = byte_10181CD0;
  v4 = 0;
  while ( strcmp(v3, a1) )
  {
    v4 += 592;
    ++v2;
    v3 += 592;
    if ( v4 >= 0x73A0 )
      return (char *)a2;
  }
  return &byte_10181D20[592 * v2];
}

//----- (10025720) --------------------------------------------------------
char *__usercall sub_10025720@<eax>(char *result@<eax>)
{
  char v1; // cl@2

  for ( ; *result; ++result )
  {
    v1 = *result;
    if ( *result == 10 || v1 == 35 )
    {
      *result = 0;
    }
    else if ( v1 == 92 )
    {
      *result = 47;
    }
  }
  return result;
}

//----- (10025750) --------------------------------------------------------
void __cdecl sub_10025750(char *a1)
{
  char *v1; // eax@3
  char *v2; // edi@3
  char *v3; // eax@4
  int v4; // ST14_4@5
  char *v5; // eax@5
  char v6; // [sp+4h] [bp-204h]@1

  v6 = 0;
  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = strstr(a1, "$$(");
      v2 = v1;
      if ( v1 )
      {
        v3 = strchr(v1 + 3, 41);
        if ( v3 )
        {
          *v2 = 0;
          *v3 = 0;
          v4 = (int)(v3 + 1);
          v5 = sub_100256B0(v2 + 3, (int)&unk_1005E69C);
          sprintf(&v6, "%s%s%s", a1, v5, v4);
          sub_10025750(&v6);
          strcpy(a1, &v6);
        }
      }
    }
  }
}

//----- (10025810) --------------------------------------------------------
void __cdecl sub_10025810(char *a1, char *a2)
{
  char *v2; // eax@2
  int v3; // edx@2
  char *v4; // esi@2
  char v5; // cl@3
  char *v6; // eax@4
  char *v7; // esi@4
  char *v8; // edx@4
  char v9; // cl@5

  if ( dword_10181CC8 < 50 )
  {
    v2 = a1;
    v3 = 592 * dword_10181CC8;
    v4 = (char *)(&byte_10181CD0[592 * dword_10181CC8] - a1);
    do
    {
      v5 = *v2;
      v2[(_DWORD)v4] = *v2;
      ++v2;
    }
    while ( v5 );
    v6 = a2;
    v7 = &byte_10181D20[v3];
    v8 = (char *)(&byte_10181D20[v3] - a2);
    do
    {
      v9 = *v6;
      v6[(_DWORD)v8] = *v6;
      ++v6;
    }
    while ( v9 );
    sub_10025750(v7);
    ++dword_10181CC8;
  }
}
// 10181CC8: using guessed type int dword_10181CC8;

//----- (10025870) --------------------------------------------------------
void *__cdecl sub_10025870(int a1)
{
  void *result; // eax@1
  unsigned int v2; // eax@2
  unsigned int v3; // ebp@2
  char *v4; // edi@4
  char *v5; // esi@4
  char *v6; // eax@4
  const char *v7; // esi@6
  const char *v8; // ebx@6
  char *v9; // edi@6
  char *v10; // eax@6
  char v11; // [sp+4h] [bp-204h]@3

  result = memset(byte_10181CD0, 0, 0x73A0u);
  dword_10181CC8 = 0;
  if ( a1 )
  {
    v2 = sub_10025D40(a1, 0);
    v3 = v2;
    if ( v2 )
    {
      if ( sub_10025F20((int)&v11, 512, v2) )
      {
        do
        {
          sub_10025720(&v11);
          v4 = strstr(&v11, "=");
          v5 = strstr(&v11, "<Var name=\"");
          v6 = strstr(&v11, " value=\"");
          if ( v5 && v6 )
          {
            v7 = v5 + 11;
            v8 = v6 + 8;
            v9 = strchr(v7, 34);
            v10 = strchr(v8, 34);
            if ( v9 )
            {
              if ( v10 )
              {
                *v9 = 0;
                *v10 = 0;
                sub_10025810((char *)v7, (char *)v8);
              }
            }
          }
          else if ( v4 && !strpbrk(&v11, "<>") )
          {
            *v4 = 0;
            sub_10025810(&v11, v4 + 1);
          }
        }
        while ( sub_10025F20((int)&v11, 512, v3) );
      }
      result = (void *)sub_10025CF0(v3);
    }
    else
    {
      result = (void *)sub_1001B2A0(
                         3,
                         (int)"**Warning**",
                         (int)"..\\lib\\utf\\utf_cnfg.c",
                         (int)"269",
                         (int)"Configuration File",
                         a1,
                         (int)"Unable to open configuration file");
    }
  }
  return result;
}
// 10181CC8: using guessed type int dword_10181CC8;

//----- (10025A00) --------------------------------------------------------
int __cdecl sub_10025A00(int a1, int a2)
{
  unsigned int v2; // eax@5
  int v3; // eax@8
  int v4; // eax@10
  int result; // eax@11

  if ( a2 && *(_DWORD *)(a2 + 8) && *(_WORD *)(a2 + 12) && *(_DWORD *)(a2 + 4) )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 < 0xFFFFFFC2 && v2 )
    {
      j_IOP_pvg_sk_close(v2, *(_DWORD *)(a2 + 20));
      *(_DWORD *)(a1 + 4) = 0;
    }
    *(_BYTE *)(*(_WORD *)(a2 + 12) + *(_DWORD *)(a2 + 8) - 1) = 0;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 30) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 28) = 0;
    v3 = j_IOP_pvg_sk_create_id(*(_WORD *)a2);
    *(_DWORD *)(a1 + 4) = v3;
    if ( *(_DWORD *)(a2 + 36) )
      j_IOP_pvg_sk_set_addr(v3, 0, *(_DWORD *)(a2 + 36));
    v4 = *(_DWORD *)(a1 + 4);
    if ( *(_BYTE *)(a2 + 14) & 8 )
      result = j_IOP_pvg_sk_connect(v4, *(_DWORD *)(a2 + 16));
    else
      result = j_IOP_pvg_sk_accept(v4, a1 + 8, *(_DWORD *)(a2 + 16));
  }
  else
  {
    result = -59;
  }
  return result;
}
// 10032940: using guessed type int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD);
// 10032950: using guessed type int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD);
// 10032960: using guessed type int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD);
// 10032970: using guessed type int __cdecl j_IOP_pvg_sk_create_id(_DWORD);
// 10032A20: using guessed type int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD);

//----- (10025B40) --------------------------------------------------------
char __usercall sub_10025B40@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5)
{
  _WORD *v5; // edx@1
  int v6; // esi@1
  char result; // al@1
  char v8; // cl@5
  unsigned __int16 v9; // cx@11
  signed int v10; // edi@12
  signed int v11; // esi@12
  size_t v12; // ebp@13

  v5 = a4;
  v6 = a1;
  result = 0;
  if ( *a4 >= a3 )
  {
    *a4 = 0;
    *(_BYTE *)a2 = 0;
  }
  if ( a5 == -1 )
    *(_BYTE *)(v6 + 28) = 3;
  v8 = *(_BYTE *)(v6 + 28);
  if ( v8 )
  {
    *(_BYTE *)(v6 + 28) = v8 - 1;
    result = 0;
  }
  else if ( a5 != 13 && a5 != 10 && a5 )
  {
    *(_BYTE *)((*a4)++ + a2) = a5;
  }
  else
  {
    v9 = *a4;
    if ( *a4 )
    {
      v10 = v9;
      v11 = 0;
      if ( (signed int)v9 > 0 )
      {
        v12 = v9 - 1;
        do
        {
          if ( *(_BYTE *)(v11 + a2) == 8 )
          {
            if ( v11 )
            {
              memcpy((void *)(v11 + a2 - 1), (const void *)(v11 + a2 + 1), v10 - v11 - 1);
              v10 -= 2;
              v12 -= 2;
              v11 -= 2;
            }
            else
            {
              memcpy((void *)a2, (const void *)(a2 + 1), v12);
              --v10;
              --v12;
              v11 = -1;
            }
            v5 = a4;
          }
          ++v11;
        }
        while ( v11 < v10 );
      }
      *(_BYTE *)(v10 + a2) = 0;
      result = 1;
      *v5 = 0;
    }
  }
  return result;
}

//----- (10025C10) --------------------------------------------------------
signed int __cdecl sub_10025C10(_DWORD *a1, char *a2)
{
  int v2; // esi@1
  int v3; // ebx@4
  int v4; // ebp@4
  int v5; // eax@5
  signed int v6; // edi@5
  int v7; // ST0C_4@9
  char v8; // al@11
  int v10; // [sp+4h] [bp-38h]@4
  __int16 v11; // [sp+8h] [bp-34h]@9

  v2 = (int)a1;
  if ( a1 && *a1 && a2 )
  {
    *a2 = 0;
    v3 = *(_DWORD *)v2;
    v10 = *(_DWORD *)v2;
    v4 = 0;
    while ( 1 )
    {
      v5 = sub_10032980(*(_DWORD *)(v2 + 4), (int)&a1, 1, 0, v4);
      v6 = v5;
      if ( v5 == -57 )
      {
        if ( v4 == *(_DWORD *)(v3 + 24) )
          return v6;
        v4 = *(_DWORD *)(v3 + 24);
        v6 = 1;
      }
      else
      {
        if ( v5 >= 0 )
        {
          v8 = sub_10025B40(v2, *(_DWORD *)(v3 + 8), *(_WORD *)(v3 + 12), (_WORD *)(v2 + 30), (char)a1);
          v3 = v10;
          *a2 = v8;
          *(_DWORD *)(v2 + 24) += v6;
        }
        else
        {
          v7 = *(_DWORD *)(v2 + 4);
          v11 = 0;
          j_IOP_pvg_sk_status(v7, &v11);
          if ( !(v11 & 0x44) )
            sub_10025A00(v2, v3);
        }
        if ( v6 <= 0 )
          return v6;
      }
      if ( *a2 )
        return v6;
    }
  }
  return -59;
}
// 10032A30: using guessed type int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD);

//----- (10025CF0) --------------------------------------------------------
BOOL __cdecl sub_10025CF0(unsigned int a1)
{
  j_FIL_vfs_clean_invalidate_cache(a1);
  return sub_10032090(a1) == 0;
}
// 10032080: using guessed type int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD);

//----- (10025D10) --------------------------------------------------------
BOOL __cdecl sub_10025D10(int a1)
{
  return j_FIL_vfs_delete(a1) == 0;
}
// 100320D0: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);

//----- (10025D40) --------------------------------------------------------
unsigned int __cdecl sub_10025D40(int a1, char a2)
{
  unsigned int result; // eax@7
  int v3; // [sp-Ch] [bp-Ch]@3
  signed int v4; // [sp-8h] [bp-8h]@2

  switch ( a2 )
  {
    case 0:
      v4 = 4;
      goto LABEL_6;
    case 1:
      v4 = 10;
      v3 = a1;
      goto LABEL_7;
    case 2:
      v4 = 14;
      v3 = a1;
      goto LABEL_7;
    case 3:
      v4 = 78;
LABEL_6:
      v3 = a1;
LABEL_7:
      result = j_FIL_vfs_open(v3, v4, 0);
      if ( result >= 0xFFFFFFC2 || !result )
        goto LABEL_9;
      break;
    default:
LABEL_9:
      result = 0;
      break;
  }
  return result;
}
// 10032150: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10025DA0) --------------------------------------------------------
signed int __cdecl sub_10025DA0(void *a1, int a2, unsigned int a3)
{
  return sub_10032160(a3, a1, a2);
}

//----- (10025DC0) --------------------------------------------------------
int __cdecl sub_10025DC0(int a1, int a2, int a3)
{
  return j_FIL_vfs_write(a3, a1, a2);
}
// 100322C0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10025DE0) --------------------------------------------------------
char __cdecl sub_10025DE0(const char *a1, const char *a2)
{
  bool v2; // bl@1
  unsigned int v3; // edi@6
  unsigned int v4; // ebp@7
  int v5; // esi@8
  bool i; // zf@8
  char v8; // [sp+Ch] [bp-204h]@8

  v2 = 0;
  if ( !a1 || !*a1 || !a2 || !*a2 )
    return v2;
  if ( strcmp(a1, a2) )
  {
    v3 = sub_10025D40((int)a1, 0);
    if ( v3 )
    {
      v4 = sub_10025D40((int)a2, 1);
      if ( v4 )
      {
        v5 = sub_10025DA0(&v8, 512, v3);
        for ( i = v5 == 0; v5 > 0; i = v5 == 0 )
        {
          v5 -= sub_10025DC0((int)&v8, v5, v4);
          if ( !v5 )
            v5 = sub_10025DA0(&v8, 512, v3);
        }
        v2 = i;
        sub_10025CF0(v4);
      }
      sub_10025CF0(v3);
    }
    return v2;
  }
  return 1;
}

//----- (10025F20) --------------------------------------------------------
int __cdecl sub_10025F20(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // esi@1
  unsigned __int8 v5; // [sp+13h] [bp-1h]@2

  v3 = 0;
  while ( 1 )
  {
    if ( sub_10025DA0(&v5, 1, a3) <= 0 || v5 == -1 )
    {
      *(_BYTE *)(v3 + a1) = 0;
      return v3 > 0 ? a1 : 0;
    }
    if ( v5 == 10 )
      break;
    if ( v5 != 13 )
    {
      *(_BYTE *)(v3++ + a1) = v5;
      if ( v3 >= a2 - 2 )
      {
        *(_BYTE *)(v3 + a1 + 1) = 0;
        return a1;
      }
    }
  }
  *(_BYTE *)(v3 + a1) = 0;
  return a1;
}

//----- (10025FA0) --------------------------------------------------------
int sub_10025FA0()
{
  return 0;
}

//----- (10025FB0) --------------------------------------------------------
void __cdecl sub_10025FB0(int a1)
{
  if ( a1 > 0 )
    exit_0(14);
}

//----- (10025FE0) --------------------------------------------------------
int __cdecl sub_10025FE0(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (10026000) --------------------------------------------------------
bool __cdecl sub_10026000(int a1)
{
  return *(_DWORD *)a1 && *(_DWORD *)(a1 + 4) && *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 12);
}

//----- (10026030) --------------------------------------------------------
void *__cdecl sub_10026030(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5)
{
  void *v5; // eax@1

  *(_DWORD *)a5 = a1;
  *(_DWORD *)(a5 + 4) = a2;
  *(_DWORD *)(a5 + 8) = a3;
  v5 = (void *)a4(a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
  *(_DWORD *)(a5 + 12) = v5;
  return memset(v5, 0, a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
}

//----- (10026070) --------------------------------------------------------
unsigned int __usercall sub_10026070@<eax>(int a1@<edx>, int a2, int a3)
{
  return *(_DWORD *)(a1 + 12) + ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3) * (a3 + a2 * *(_DWORD *)(a1 + 4));
}

//----- (10026090) --------------------------------------------------------
int __usercall sub_10026090@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_BYTE *)(result + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(result + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)result = *(_BYTE *)a2;
  return result;
}

//----- (100260B0) --------------------------------------------------------
char __cdecl sub_100260B0(void (__cdecl *a1)(_DWORD), int a2)
{
  char result; // al@1

  result = sub_10026000(a2);
  if ( result )
  {
    a1(*(_DWORD *)(a2 + 12));
    result = sub_10025FE0(a2);
  }
  return result;
}

//----- (100260E0) --------------------------------------------------------
signed int __cdecl sub_100260E0(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5)
{
  int v5; // ebp@1
  signed int result; // eax@1
  unsigned int v7; // ebx@1
  bool v8; // zf@1
  unsigned int v9; // esi@2
  unsigned int v10; // edi@3
  _BYTE *v11; // eax@3
  _BYTE *v12; // ecx@3
  __int64 v13; // rax@3
  __int64 v14; // rax@4
  __int64 v15; // rax@5
  int v16; // eax@6
  signed int v17; // [sp+Ch] [bp+4h]@1

  v5 = (int)a1;
  result = 0;
  v7 = 0;
  v8 = *a1 == 0;
  v17 = 0;
  if ( v8 )
  {
    *a5 = 0;
  }
  else
  {
    do
    {
      v9 = 0;
      if ( *(_DWORD *)(v5 + 4) )
      {
        do
        {
          v10 = sub_10026070(v5, v7, v9);
          v11 = (_BYTE *)sub_10026070(a2, v7, v9);
          v12 = v11;
          v13 = *(_BYTE *)v10 - *v11;
          if ( (signed int)((HIDWORD(v13) ^ v13) - HIDWORD(v13)) > a3
            || (v14 = *(_BYTE *)(v10 + 1) - v12[1], (signed int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) > a3)
            || (v15 = *(_BYTE *)(v10 + 2) - v12[2], (signed int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) > a3) )
          {
            v17 = 4;
            v16 = sub_10026070(a4, v7, v9);
            sub_10026090(v16, (int)&unk_100A5804);
          }
          ++v9;
        }
        while ( v9 < *(_DWORD *)(v5 + 4) );
      }
      ++v7;
    }
    while ( v7 < *(_DWORD *)v5 );
    result = v17;
    *a5 = 0;
  }
  return result;
}

//----- (100261C0) --------------------------------------------------------
void __cdecl sub_100261C0(int a1, int a2, int a3)
{
  unsigned int *v3; // edx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // eax@2
  unsigned int v6; // esi@3
  unsigned int v7; // edi@4
  unsigned int v8; // ebx@4
  unsigned int v9; // ebp@4
  __int64 v10; // rax@4
  __int64 v11; // rax@4
  unsigned int v12; // [sp+4h] [bp-4h]@1

  v3 = (unsigned int *)a1;
  v4 = 0;
  v12 = 0;
  if ( *(_DWORD *)a1 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    do
    {
      v6 = 0;
      if ( v5 )
      {
        do
        {
          v7 = sub_10026070((int)v3, v4, v6);
          v8 = sub_10026070(a2, v4, v6);
          v9 = sub_10026070(a3, v4, v6);
          v10 = *(_BYTE *)(v7 + 2) - *(_BYTE *)(v8 + 2);
          *(_BYTE *)(v9 + 2) = (BYTE4(v10) ^ v10) - BYTE4(v10);
          v11 = *(_BYTE *)(v7 + 1) - *(_BYTE *)(v8 + 1);
          *(_BYTE *)(v9 + 1) = (BYTE4(v11) ^ v11) - BYTE4(v11);
          v3 = (unsigned int *)a1;
          *(_BYTE *)v9 = abs(*(_BYTE *)v7 - *(_BYTE *)v8);
          v5 = *(_DWORD *)(a1 + 4);
          v4 = v12;
          ++v6;
        }
        while ( v6 < v5 );
      }
      v12 = ++v4;
    }
    while ( v4 < *v3 );
  }
}

//----- (10026270) --------------------------------------------------------
void *__usercall sub_10026270@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3)
{
  int v3; // eax@1
  unsigned int v4; // ebx@3
  int v5; // ebp@4
  int v6; // eax@4
  int v7; // ebp@4
  int v8; // eax@4
  int v9; // ST5C_4@4
  int v10; // eax@4
  int v11; // ebp@4
  int v12; // eax@4
  unsigned int v13; // ebx@6
  size_t v14; // ST3C_4@7
  const void *v15; // ST38_4@7
  void *v16; // eax@7
  unsigned int i; // ebp@8
  unsigned int v18; // ebx@9
  int v19; // ST5C_4@10
  int v20; // eax@10
  int v21; // ST5C_4@10
  int v22; // eax@10
  size_t v23; // ST3C_4@11
  const void *v24; // ST38_4@11
  void *v25; // eax@11
  unsigned int v26; // ebx@12
  size_t v27; // ST3C_4@13
  const void *v28; // ST38_4@13
  void *v29; // eax@13
  void *result; // eax@13
  int v31; // [sp+8h] [bp-18h]@1
  unsigned int v32; // [sp+Ch] [bp-14h]@1
  int v33; // [sp+10h] [bp-10h]@3
  int v34; // [sp+14h] [bp-Ch]@1
  int v35; // [sp+18h] [bp-8h]@1

  v3 = 2 * a3 + *(_DWORD *)a2;
  v35 = 2 * a3 + *(_DWORD *)a2;
  v34 = 2 * a3 + *(_DWORD *)(a2 + 4);
  v32 = (unsigned int)(*(_DWORD *)(a2 + 8) + 7) >> 3;
  v31 = 0;
  while ( 1 )
  {
    v4 = 0;
    v33 = v3 - v31 - 1;
    do
    {
      v5 = sub_10026070(a1, v31, v4);
      v6 = sub_10026070(a2, 0, 0);
      sub_10026090(v5, v6);
      v7 = sub_10026070(a1, v33, v4);
      v8 = sub_10026070(a2, *(_DWORD *)a2 - 1, 0);
      sub_10026090(v7, v8);
      v9 = sub_10026070(a1, v31, v34 - v4 - 1);
      v10 = sub_10026070(a2, 0, *(_DWORD *)(a2 + 4) - 1);
      sub_10026090(v9, v10);
      v11 = sub_10026070(a1, v33, v34 - v4 - 1);
      v12 = sub_10026070(a2, *(_DWORD *)a2 - 1, *(_DWORD *)(a2 + 4) - 1);
      sub_10026090(v11, v12);
      ++v4;
    }
    while ( v4 <= a3 );
    if ( ++v31 > a3 )
      break;
    v3 = v35;
  }
  v13 = 0;
  do
  {
    v14 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v15 = (const void *)sub_10026070(a2, 0, 1);
    v16 = (void *)sub_10026070(a1, v13, a3 + 1);
    memcpy_0(v16, v15, v14);
    ++v13;
  }
  while ( v13 <= a3 );
  for ( i = 1; i < *(_DWORD *)a2 - 1; ++i )
  {
    v18 = 0;
    do
    {
      v19 = sub_10026070(a1, a3 + i, v18);
      v20 = sub_10026070(a2, i, 0);
      sub_10026090(v19, v20);
      v21 = sub_10026070(a1, i + a3, v34 - v18 - 1);
      v22 = sub_10026070(a2, i, *(_DWORD *)(a2 + 4) - 1);
      sub_10026090(v21, v22);
      ++v18;
    }
    while ( v18 <= a3 );
    v23 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v24 = (const void *)sub_10026070(a2, i, 1);
    v25 = (void *)sub_10026070(a1, a3 + i, a3 + 1);
    memcpy_0(v25, v24, v23);
  }
  v26 = 0;
  do
  {
    v27 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v28 = (const void *)sub_10026070(a2, *(_DWORD *)a2 - 1, 1);
    v29 = (void *)sub_10026070(a1, v35 - v26 - 1, a3 + 1);
    result = memcpy_0(v29, v28, v27);
    ++v26;
  }
  while ( v26 <= a3 );
  return result;
}

//----- (100264F0) --------------------------------------------------------
void __cdecl sub_100264F0(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  unsigned int v4; // esi@3
  unsigned int v5; // edi@4
  unsigned int v6; // ecx@4
  char v7; // al@4

  v2 = 0;
  if ( *(_DWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    do
    {
      v4 = 0;
      if ( v3 )
      {
        do
        {
          v5 = sub_10026070(a1, v2, v4);
          v6 = sub_10026070(a2, v2, v4++);
          v7 = (signed int)((double)*(_BYTE *)(v5 + 2) * 0.300000011920929
                          + (double)*(_BYTE *)(v5 + 1) * 0.5899999737739563
                          + (double)*(_BYTE *)v5 * 0.1099999994039536);
          *(_BYTE *)(v6 + 2) = v7;
          *(_BYTE *)(v6 + 1) = v7;
          *(_BYTE *)v6 = v7;
          v3 = *(_DWORD *)(a1 + 4);
        }
        while ( v4 < v3 );
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)a1 );
  }
}

//----- (100265C0) --------------------------------------------------------
char __cdecl sub_100265C0(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4)
{
  char result; // al@1

  result = sub_10026000(a1);
  if ( result )
  {
    result = sub_10026000(a4);
    if ( result )
    {
      sub_100260B0(a3, a4);
      sub_10026030(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), a2, a4);
      result = (unsigned int)memcpy_0(
                               *(void **)(a4 + 12),
                               *(const void **)(a1 + 12),
                               *(_DWORD *)(a1 + 4) * *(_DWORD *)a1 * ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3));
    }
  }
  return result;
}

//----- (10026630) --------------------------------------------------------
int __usercall sub_10026630@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9)
{
  int (__cdecl *v9)(unsigned int); // edi@1
  long double v10; // st7@1
  unsigned int v11; // ecx@1
  signed int v12; // kr00_4@1
  int v13; // ebx@1
  int v14; // esi@3
  int result; // eax@5
  double v16; // st6@7
  int v17; // eax@7
  double v18; // st3@7
  int v19; // edi@9
  double v20; // rt0@11
  double v21; // st3@11
  double v22; // st6@11
  int v23; // eax@11
  int v24; // ecx@12
  int v25; // ebp@14
  float *v26; // esi@14
  unsigned int v27; // eax@15
  signed int v28; // ecx@15
  float v29; // ST50_4@15
  signed int v30; // edx@15
  signed int v31; // eax@15
  int v32; // ecx@20
  double v33; // st2@20
  double v34; // rtt@21
  double v35; // rt0@23
  double v36; // st2@23
  double v37; // st3@23
  double v38; // rtt@26
  unsigned int v39; // eax@28
  bool v40; // sf@28
  unsigned __int8 v41; // of@28
  float v42; // [sp+8h] [bp-48h]@11
  int v43; // [sp+Ch] [bp-44h]@8
  int v44; // [sp+10h] [bp-40h]@9
  int v45; // [sp+14h] [bp-3Ch]@6
  int v46; // [sp+18h] [bp-38h]@7
  int v47; // [sp+20h] [bp-30h]@11
  signed int v48; // [sp+24h] [bp-2Ch]@1
  int v49; // [sp+28h] [bp-28h]@12
  float v50; // [sp+30h] [bp-20h]@22
  float v51; // [sp+34h] [bp-1Ch]@11
  float v52; // [sp+38h] [bp-18h]@11
  float v53; // [sp+3Ch] [bp-14h]@11
  char v54; // [sp+40h] [bp-10h]@6

  v9 = a2;
  v10 = sqrt((double)a1);
  v11 = (signed int)v10;
  v12 = (signed int)v10;
  v13 = (signed int)v10 / 2;
  v48 = (signed int)v10;
  if ( v9 && a7 )
  {
    v14 = a3;
    if ( *(_DWORD *)(a3 + 4) >= v11 || *(_DWORD *)a3 >= v11 )
    {
      *(_DWORD *)a9 = 0;
      sub_10026030(2 * v13 + *(_DWORD *)a3, 2 * v13 + *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8), v9, (int)&v54);
      sub_10026270((int)&v54, a3, v12 / 2);
      v45 = v12 / 2;
      if ( v13 < v13 + *(_DWORD *)a3 )
      {
        v16 = 0.0;
        v17 = v13 + *(_DWORD *)(a3 + 4);
        v46 = 0;
        v18 = a6;
        do
        {
          v43 = v12 / 2;
          if ( v13 < v17 )
          {
            v19 = v12 / -2;
            v44 = 0;
            while ( 1 )
            {
              v20 = v18;
              v21 = v16;
              v22 = v20;
              v51 = 0.0;
              v42 = v21;
              v52 = 0.0;
              v53 = 0.0;
              v23 = v19;
              v47 = v19;
              if ( v19 <= v13 )
              {
                v24 = v48 * (v19 + v13);
                v49 = v48 * (v19 + v13);
                do
                {
                  if ( v19 <= v13 )
                  {
                    v25 = v23 + v45;
                    v26 = (float *)(a4 + 4 * (v13 + v19 + v24));
                    do
                    {
                      v27 = sub_10026070((int)&v54, v25, v19 + v43);
                      v28 = *(_BYTE *)(v27 + 2);
                      v29 = *v26;
                      v30 = *(_BYTE *)(v27 + 1);
                      v31 = *(_BYTE *)v27;
                      ++v19;
                      ++v26;
                      v51 = (double)v28 * v29 + v51;
                      v52 = (double)v30 * v29 + v52;
                      v53 = (double)v31 * v29 + v53;
                      v42 = v29 + v42;
                    }
                    while ( v19 <= v13 );
                    v14 = a3;
                    v23 = v47;
                    v24 = v49;
                    v19 = v12 / -2;
                  }
                  v24 += v48;
                  v47 = ++v23;
                  v49 = v24;
                }
                while ( v23 <= v13 );
              }
              if ( v21 == v22 )
                v22 = v42;
              v32 = 0;
              v33 = a5 + v22;
              while ( 1 )
              {
                v50 = *(&v51 + v32) / v33;
                *(&v51 + v32) = v50;
                if ( v50 > v21 )
                {
                  if ( v50 > 255.0 )
                    *(&v51 + v32) = 255.0;
                  v38 = v33;
                  v36 = v21;
                  v37 = v38;
                }
                else
                {
                  v35 = v33;
                  v36 = v21;
                  v37 = v35;
                  *(&v51 + v32) = v36;
                }
                if ( (unsigned int)++v32 >= 3 )
                  break;
                v34 = v36;
                v33 = v37;
                v21 = v34;
              }
              v39 = sub_10026070(a8, v46, v44++);
              *(_BYTE *)(v39 + 2) = (signed int)v51;
              *(_BYTE *)(v39 + 1) = (signed int)v52;
              *(_BYTE *)v39 = (signed int)v53;
              v17 = *(_DWORD *)(v14 + 4) + v13;
              v41 = __OFSUB__(v43 + 1, v17);
              v40 = v43++ + 1 - v17 < 0;
              v18 = v22;
              v16 = v36;
              if ( !(v40 ^ v41) )
                break;
              v19 = v12 / -2;
            }
          }
          ++v46;
          ++v45;
        }
        while ( v45 < v13 + *(_DWORD *)v14 );
      }
      sub_100260B0((void (__cdecl *)(_DWORD))a7, (int)&v54);
      result = 0;
    }
    else
    {
      *(_DWORD *)a9 = "Bitmap too small to filter -- filtering has been disabled";
      sub_100265C0(a3, v9, (void (__cdecl *)(_DWORD))a7, a8);
      result = 0;
    }
  }
  else
  {
    *(_DWORD *)a9 = "Dynamic memory function pointers are required for bitmap filtering";
    result = 1;
  }
  return result;
}

//----- (10026990) --------------------------------------------------------
int __usercall sub_10026990@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7)
{
  int (__cdecl *v7)(unsigned int); // edi@1
  int v8; // esi@1
  unsigned int v9; // ebx@1
  int v10; // ebp@1
  unsigned int v11; // edi@2
  unsigned int v12; // eax@3
  int v13; // eax@6
  int v15; // [sp+24h] [bp-20h]@1
  int v16; // [sp+34h] [bp-10h]@1

  v7 = a1;
  v8 = a2;
  sub_10026030(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(a2 + 8), a1, (int)&v16);
  sub_100261C0(v8, a3, (int)&v16);
  sub_10026030(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(v8 + 8), v7, (int)&v15);
  v9 = 0;
  v10 = sub_10026630(9u, v7, (int)&v16, (int)&unk_100A57E0, 0.0, 0.0, (int)a5, (int)&v15, a7);
  if ( *(_DWORD *)v8 )
  {
    do
    {
      v11 = 0;
      if ( *(_DWORD *)(v8 + 4) )
      {
        do
        {
          v12 = sub_10026070((int)&v15, v9, v11);
          if ( *(_BYTE *)(v12 + 2) > a4 || *(_BYTE *)(v12 + 1) > a4 || *(_BYTE *)v12 > a4 )
          {
            v10 = 4;
            v13 = sub_10026070(a6, v9, v11);
            sub_10026090(v13, (int)&unk_100A5804);
          }
          ++v11;
        }
        while ( v11 < *(_DWORD *)(v8 + 4) );
      }
      ++v9;
    }
    while ( v9 < *(_DWORD *)v8 );
  }
  sub_100260B0(a5, (int)&v15);
  sub_100260B0(a5, (int)&v16);
  return v10;
}

//----- (10026AA0) --------------------------------------------------------
int __cdecl sub_10026AA0(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10)
{
  bool v10; // cl@6
  bool v11; // al@13
  bool v12; // zf@16
  int result; // eax@16
  const char *v14; // ecx@17
  int v15; // ecx@22
  int v16; // eax@23
  char v17; // [sp+Bh] [bp-5h]@1
  const char *v18; // [sp+Ch] [bp-4h]@1

  v17 = 0;
  v18 = 0;
  v10 = a2 && *(_DWORD *)a2 && *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 12);
  v11 = a3 && *(_DWORD *)a3 && *(_DWORD *)(a3 + 4) && *(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 12);
  if ( !v10 )
  {
    v12 = v11 == 0;
    result = 2;
    if ( v12 )
      v14 = "Actual and Expected bitmaps unavailable";
    else
      v14 = "Actual bitmap is unavailable";
    goto LABEL_33;
  }
  if ( !v11 )
  {
    v14 = "Expected bitmap is unavailable";
    result = 2;
    goto LABEL_33;
  }
  if ( *(_DWORD *)a2 != *(_DWORD *)a3
    || (v15 = *(_DWORD *)(a2 + 4), v15 != *(_DWORD *)(a3 + 4))
    || (v16 = *(_DWORD *)(a2 + 8), v16 != *(_DWORD *)(a3 + 8)) )
  {
    v14 = "Bitmap sizes are different";
    result = 3;
    goto LABEL_33;
  }
  if ( !a6 || !a7 )
  {
    v14 = "Dynamic memory function pointers are required for comparison (build environment error)";
    result = 1;
    goto LABEL_33;
  }
  sub_10026030(*(_DWORD *)a2, v15, v16, a6, a8);
  sub_100264F0(a3, a8);
  if ( a1 )
    result = sub_10026990(a6, a2, a3, a4, a7, a8, (int)&v18);
  else
    result = sub_100260E0((_DWORD *)a2, a3, a4, a8, &v18);
  if ( !a5 )
    goto LABEL_48;
  if ( result == 4 )
  {
    result = 0;
LABEL_32:
    v14 = v18;
    goto LABEL_33;
  }
  if ( result )
  {
LABEL_48:
    if ( result != 4 )
      goto LABEL_32;
  }
  else
  {
    result = 4;
  }
  if ( a5 )
  {
    v14 = "Images match";
  }
  else
  {
    v17 = 1;
    v14 = "Pixel mismatch";
  }
LABEL_33:
  if ( a10 )
    *a10 = v14;
  if ( a9 )
    *a9 = v17;
  return result;
}

//----- (10026C30) --------------------------------------------------------
char __cdecl sub_10026C30(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3)
{
  char v3; // bl@1
  unsigned int v4; // eax@5
  unsigned int v5; // esi@5
  char *v6; // ebp@11
  int v7; // esi@11
  unsigned int v8; // ebx@11
  int v9; // edi@11
  char result; // al@20
  char v11; // [sp+8h] [bp-40h]@14
  unsigned int v12; // [sp+Ch] [bp-3Ch]@5
  __int16 v13; // [sp+10h] [bp-38h]@6
  int v14; // [sp+1Ah] [bp-2Eh]@8
  char v15; // [sp+20h] [bp-28h]@9
  int v16; // [sp+24h] [bp-24h]@11
  unsigned int v17; // [sp+28h] [bp-20h]@11
  unsigned __int16 v18; // [sp+2Eh] [bp-1Ah]@10
  char v19; // [sp+4Ch] [bp+4h]@11

  v3 = 0;
  if ( a1 && a2 && *a2 )
  {
    if ( a3 )
    {
      v4 = sub_10025D40((int)a2, 0);
      v5 = v4;
      v12 = v4;
      if ( v4 )
      {
        if ( sub_10025DA0(&v13, 14, v4) == 14
          && v13 == 19778
          && v14 == 54
          && sub_10025DA0(&v15, 40, v5) == 40
          && v18 == 24 )
        {
          sub_10026030(v17, v16, 24, a1, a3);
          v6 = *(char **)(a3 + 12);
          v7 = v16 * (((unsigned int)v18 + 7) >> 3);
          v8 = 0;
          v9 = -(v16 * (((unsigned int)v18 + 7) >> 3)) & 3;
          v19 = 1;
          if ( v17 )
          {
            while ( sub_10025DA0(v6, v7, v12) == v7 && (!v9 || sub_10025DA0(&v11, v9, v12) == v9) )
            {
              ++v8;
              v6 += v7;
              if ( v8 >= v17 )
                goto LABEL_18;
            }
            v19 = 0;
          }
LABEL_18:
          v3 = v19;
          v5 = v12;
        }
        sub_10025CF0(v5);
      }
      result = v3;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10026D80) --------------------------------------------------------
char __usercall sub_10026D80@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // esi@1
  int v7; // edi@1
  int v8; // eax@1
  int v9; // eax@1
  unsigned int v10; // ebx@1
  int v12; // [sp+10h] [bp-40h]@4
  int v13; // [sp+14h] [bp-3Ch]@4
  __int16 v14; // [sp+18h] [bp-38h]@1
  int v15; // [sp+1Ah] [bp-36h]@1
  __int16 v16; // [sp+1Eh] [bp-32h]@1
  __int16 v17; // [sp+20h] [bp-30h]@1
  int v18; // [sp+22h] [bp-2Eh]@1
  int v19; // [sp+28h] [bp-28h]@1
  int v20; // [sp+2Ch] [bp-24h]@1
  unsigned int v21; // [sp+30h] [bp-20h]@1
  __int16 v22; // [sp+34h] [bp-1Ch]@1
  __int16 v23; // [sp+36h] [bp-1Ah]@1
  int v24; // [sp+38h] [bp-18h]@1
  int v25; // [sp+3Ch] [bp-14h]@1
  int v26; // [sp+40h] [bp-10h]@1
  int v27; // [sp+44h] [bp-Ch]@1
  int v28; // [sp+48h] [bp-8h]@1
  int v29; // [sp+4Ch] [bp-4h]@1
  char v30; // [sp+54h] [bp+4h]@1

  v5 = a3;
  v6 = a1 * ((unsigned int)(a2 + 7) >> 3);
  v7 = -(a1 * ((unsigned int)(a2 + 7) >> 3)) & 3;
  v8 = a3 * (v7 + v6);
  v25 = v8;
  v15 = v8 + 54;
  v16 = 0;
  v17 = 0;
  v29 = 0;
  v28 = 0;
  v24 = 0;
  v26 = 0;
  v27 = 0;
  v30 = 0;
  v14 = 19778;
  v18 = 54;
  v19 = 40;
  v23 = a2;
  v21 = v5;
  v20 = a1;
  v22 = 1;
  v9 = sub_10025D40(a5, 1);
  v10 = v9;
  if ( v9 )
  {
    if ( sub_10025DC0((int)&v14, 14, v9) == 14 && sub_10025DC0((int)&v19, 40, v10) == 40 )
    {
      v30 = 1;
      v12 = a4;
      v13 = 0;
      if ( v5 )
      {
        while ( sub_10025DC0(v12, v6, v10) == v6 && (!v7 || sub_10025DC0((int)&unk_100A59A8, v7, v10) == v7) )
        {
          v12 += v6;
          if ( ++v13 >= v5 )
          {
            sub_10025CF0(v10);
            return 1;
          }
        }
        v30 = 0;
      }
    }
    sub_10025CF0(v10);
  }
  return v30;
}

//----- (10026ED0) --------------------------------------------------------
char __cdecl sub_10026ED0(int a1, int a2)
{
  char result; // al@2

  if ( sub_10026000(a1) )
    result = sub_10026D80(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)a1, *(_DWORD *)(a1 + 12), a2);
  else
    result = 0;
  return result;
}

//----- (10026F10) --------------------------------------------------------
signed int __cdecl sub_10026F10(int a1, int a2)
{
  signed int result; // eax@1

  result = 4;
  if ( a1 == 2 )
  {
    byte_10189071 = 1;
    byte_10189070 = 0;
  }
  else
  {
    if ( a1 == 8 )
    {
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_10189070 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    else
    {
      if ( a1 != 9 )
        return result;
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_10189071 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    result = 9;
  }
  return result;
}
// 10189070: using guessed type char byte_10189070;
// 10189071: using guessed type char byte_10189071;

//----- (10026F70) --------------------------------------------------------
bool __cdecl sub_10026F70(signed int a1)
{
  if ( a1 > 1 )
  {
    sub_1001B1F0(13, (int)"..\\lib\\utf\\utf_validate.c", (int)&unk_100BD5A0, (int)"failing_subroutine( depth-1 )");
    sub_10026F70(a1 - 1);
    exit_0(14);
  }
  return sub_100206B0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"583",
           (int)"Check FAIL macro",
           "UTF_verify_fail: forced fail",
           "UTF_verify_fail: fail forced",
           (int)"This test is expected to fail");
}

//----- (10026FE0) --------------------------------------------------------
int sub_10026FE0()
{
  const char *v0; // eax@1

  sub_1001B220(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"All Fail Miscellaneous Test Group");
  v0 = sub_1001BB70(0);
  sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"610", (int)v0);
  sub_1001B220(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"Verify miscellaneous macros");
  if ( byte_10189070 )
  {
    sub_100206B0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"620",
      (int)"Check FAIL macro",
      "UTF_verify_fail: forced fail",
      "UTF_verify_fail: fail forced",
      (int)"This test is expected to fail");
    sub_1001B1F0(13, (int)"..\\lib\\utf\\utf_validate.c", (int)"621", (int)"failing_subroutine( 1 )");
    sub_10026F70(1);
    exit_0(14);
  }
  return sub_1001B220(
           3,
           (int)"**MSG**",
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"616",
           (int)"Failing tests currently disabled. Use FAIL ON command to enable");
}
// 10189070: using guessed type char byte_10189070;

//----- (10027300) --------------------------------------------------------
char sub_10027300()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_1001B220(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"All Fail Test Group For Type 'bitmap'");
  v0 = sub_1001BB70(0);
  sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"700", (int)v0);
  sub_1001B220(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10189070 )
  {
    v2 = 0;
    do
    {
      if ( off_100A6614[v2] )
      {
        sub_1001B9E0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100A661C[v2 * 4], 0x100u, &v11);
        sub_1001B9E0((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_100A6614[v2], 0x100u, &v12);
        sub_10025DE0(&v12, &v11);
      }
      if ( byte_100A6610[v2 * 4] )
      {
        sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"725", 2, 2);
        v3 = off_100A6618[v2];
        v4 = *(char **)&off_100A661C[v2 * 4];
        v5 = sub_1001BC80(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100A661C[v2 * 4],
               off_100A6618[v2]);
        v6 = sub_10020300(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"730",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1001BFE0(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"731",
                   (int)"Return value from previous UTF_verify_eq_bitmap() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"735", 2, 2);
        v7 = off_100A6618[v2];
        v8 = *(char **)&off_100A661C[v2 * 4];
        v9 = sub_1001BC80(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100A661C[v2 * 4],
               off_100A6618[v2]);
        v10 = sub_10020300(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"740",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1001BFE0(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"741",
                   (int)"Return value from previous UTF_verify_ne_bitmap() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 4;
    }
    while ( v2 < 36 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"704",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 100A6614: using guessed type char *off_100A6614[3];
// 100A6618: using guessed type char *off_100A6618[2];
// 10189070: using guessed type char byte_10189070;

//----- (10027520) --------------------------------------------------------
char sub_10027520()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1001B220(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_1001BB70(0);
  sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"768", (int)v0);
  sub_1001B220(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10189070 )
  {
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"776", 2, 2);
    v2 = sub_1001BFE0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"777",
           (int)"UTF_verify_eq_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1001BFE0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"778",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"780", 2, 2);
    v3 = sub_1001BFE0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"781",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1001BFE0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"782",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"784", 2, 2);
    v4 = sub_1001BFE0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"785",
           (int)"UTF_verify_ne_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1001BFE0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"786",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"788", 2, 2);
    v5 = sub_1001BFE0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"789",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1001BFE0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"790",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"772",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10189070: using guessed type char byte_10189070;

//----- (10027720) --------------------------------------------------------
char sub_10027720()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"830", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100A66A4[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"830", 2, 2);
        v3 = byte_100A66A1[v2 * 4];
        v4 = byte_100A66A0[v2 * 4];
        v5 = sub_1001BC80(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + dword_100A66A4[v2])],
               (&off_100A66A8)[v2 * 4]);
        v6 = sub_1001C120(
               0,
               *(&dword_100A65F4 + dword_100A66A4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"830",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1001BC80(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100A66A4[v2]],
               (&off_100A66A8)[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"830",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"830",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A66A4: using guessed type int dword_100A66A4[];
// 100A66A8: using guessed type char *off_100A66A8;
// 10189070: using guessed type char byte_10189070;

//----- (100278A0) --------------------------------------------------------
char sub_100278A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"864", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100A6928[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_100A6920[v2 / 8];
        v4 = dbl_100A6918[v2 / 8];
        v5 = dbl_100A6910[v2 / 8];
        v6 = sub_1001BC80(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               *(_DWORD *)&off_100A692C[v2]);
        v7 = sub_1001C4D0(
               0,
               *(&dword_100A65F4 + dword_100A6928[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"864",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100A6928[v2 / 4]],
               *(_DWORD *)&off_100A692C[v2]);
        LOBYTE(v0) = sub_1001BFE0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"864",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"864",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A6910: using guessed type double dbl_100A6910[];
// 100A6918: using guessed type double dbl_100A6918[];
// 100A6920: using guessed type double dbl_100A6920[];
// 100A6928: using guessed type int dword_100A6928[];
// 10189070: using guessed type char byte_10189070;

//----- (10027A20) --------------------------------------------------------
char sub_10027A20()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"900", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100A753C[v2];
      if ( v0 != 6 )
      {
        v3 = flt_100A7538[v2];
        v4 = flt_100A7534[v2];
        v5 = flt_100A7530[v2];
        v6 = sub_1001BC80(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               (&off_100A7540)[v2 * 4]);
        v7 = sub_1001C920(
               0,
               *(&dword_100A65F4 + dword_100A753C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"900",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100A753C[v2]],
               (&off_100A7540)[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"900",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"900",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A7530: using guessed type float flt_100A7530[];
// 100A7534: using guessed type float flt_100A7534[];
// 100A7538: using guessed type float flt_100A7538[];
// 100A753C: using guessed type int dword_100A753C[];
// 100A7540: using guessed type char *off_100A7540;
// 10189070: using guessed type char byte_10189070;

//----- (10027B90) --------------------------------------------------------
char sub_10027B90()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1001B220(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1001BB70(0);
  sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"922", (int)v0);
  sub_1001B220(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10189070 )
  {
    sub_10020600(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"930",
      (int)"Check ptr for equality",
      (int)sub_10027B90,
      (int)sub_10027B90,
      (int)"This test is expected to fail");
    sub_10020600(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"931",
      (int)"Check ptr for inequality",
      (int)sub_10027B90,
      0,
      (int)"This test is expected to fail");
    result = sub_10020600(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"932",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10027B90,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"926",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10189070: using guessed type char byte_10189070;

//----- (10027C90) --------------------------------------------------------
char sub_10027C90()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"959", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100A7CE4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100A7CE0[v2];
        v4 = dword_100A7CDC[v2];
        v5 = dword_100A7CD8[v2];
        v6 = sub_1001BC80(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               *(_DWORD *)&off_100A7CE8[v2 * 4]);
        v7 = sub_1001CDE0(
               0,
               *(&dword_100A65F4 + dword_100A7CE4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"959",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100A7CE4[v2]],
               *(_DWORD *)&off_100A7CE8[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"959",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"959",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A7CD8: using guessed type int dword_100A7CD8[];
// 100A7CDC: using guessed type int dword_100A7CDC[];
// 100A7CE0: using guessed type int dword_100A7CE0[];
// 100A7CE4: using guessed type int dword_100A7CE4[];
// 10189070: using guessed type char byte_10189070;

//----- (10027DF0) --------------------------------------------------------
char sub_10027DF0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"985", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100A8478[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100A8474[v2 / 2];
        v4 = word_100A8472[v2 / 2];
        v5 = word_100A8470[v2 / 2];
        v6 = sub_1001BC80(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               *(_DWORD *)&off_100A847C[v2]);
        v7 = sub_1001D1A0(
               0,
               *(&dword_100A65F4 + dword_100A8478[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"985",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100A8478[v2 / 4]],
               *(_DWORD *)&off_100A847C[v2]);
        LOBYTE(v0) = sub_1001BFE0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"985",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"985",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A8470: using guessed type __int16 word_100A8470[];
// 100A8472: using guessed type __int16 word_100A8472[];
// 100A8474: using guessed type __int16 word_100A8474[];
// 100A8478: using guessed type int dword_100A8478[];
// 10189070: using guessed type char byte_10189070;

//----- (10027F50) --------------------------------------------------------
char sub_10027F50()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1011", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100A8A8C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100A8A88[v2];
        v4 = dword_100A8A84[v2];
        v5 = dword_100A8A80[v2];
        v6 = sub_1001BC80(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               (&off_100A8A90)[v2 * 4]);
        v7 = sub_1001D5A0(
               0,
               *(&dword_100A65F4 + dword_100A8A8C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1011",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100A8A8C[v2]],
               (&off_100A8A90)[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1011",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1011",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A8A80: using guessed type int dword_100A8A80[];
// 100A8A84: using guessed type int dword_100A8A84[];
// 100A8A88: using guessed type int dword_100A8A88[];
// 100A8A8C: using guessed type int dword_100A8A8C[];
// 100A8A90: using guessed type char *off_100A8A90;
// 10189070: using guessed type char byte_10189070;

//----- (100280B0) --------------------------------------------------------
char sub_100280B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1037", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100A9230[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100A922C[v2];
        LODWORD(v3) = dword_100A9228[v2];
        HIDWORD(v4) = dword_100A9224[v2];
        LODWORD(v4) = dword_100A9220[v2];
        HIDWORD(v5) = dword_100A921C[v2];
        LODWORD(v5) = dword_100A9218[v2];
        v6 = sub_1001BC80(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               *(_DWORD *)&off_100A9234[v2 * 4]);
        v7 = sub_1001D960(
               0,
               *(&dword_100A65F4 + dword_100A9230[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1037",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100A9230[v2]],
               *(_DWORD *)&off_100A9234[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1037",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1037",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A9218: using guessed type int dword_100A9218[];
// 100A921C: using guessed type int dword_100A921C[];
// 100A9220: using guessed type int dword_100A9220[];
// 100A9224: using guessed type int dword_100A9224[];
// 100A9228: using guessed type int dword_100A9228[];
// 100A922C: using guessed type int dword_100A922C[];
// 100A9230: using guessed type int dword_100A9230[];
// 10189070: using guessed type char byte_10189070;

//----- (10028220) --------------------------------------------------------
char sub_10028220()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1063", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100A9E3C[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100A9E3A[v2 * 4];
        v4 = byte_100A9E39[v2 * 4];
        v5 = byte_100A9E38[v2 * 4];
        v6 = sub_1001BC80(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               (&off_100A9E40)[v2 * 4]);
        v7 = sub_1001DEA0(
               0,
               *(&dword_100A65F4 + dword_100A9E3C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1063",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100A9E3C[v2]],
               (&off_100A9E40)[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1063",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1063",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A9E3C: using guessed type int dword_100A9E3C[];
// 100A9E40: using guessed type char *off_100A9E40;
// 10189070: using guessed type char byte_10189070;

//----- (10028380) --------------------------------------------------------
char sub_10028380()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1089", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100AA2D4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100AA2D0[v2];
        v4 = dword_100AA2CC[v2];
        v5 = dword_100AA2C8[v2];
        v6 = sub_1001BC80(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               *(_DWORD *)&off_100AA2D8[v2 * 4]);
        v7 = sub_1001E280(
               0,
               *(&dword_100A65F4 + dword_100AA2D4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1089",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100AA2D4[v2]],
               *(_DWORD *)&off_100AA2D8[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1089",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1089",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AA2C8: using guessed type int dword_100AA2C8[];
// 100AA2CC: using guessed type int dword_100AA2CC[];
// 100AA2D0: using guessed type int dword_100AA2D0[];
// 100AA2D4: using guessed type int dword_100AA2D4[];
// 10189070: using guessed type char byte_10189070;

//----- (100284E0) --------------------------------------------------------
char sub_100284E0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1001B220(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_1001BB70(0);
  sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1113", (int)v0);
  sub_1001B220(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10189070 )
  {
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"1121", 2, 2);
    v2 = sub_100206B0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1122",
           (int)"UTF_verify_eq_str( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_1005E69C,
           (int)"This test is expected to fail");
    sub_1001BFE0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1123",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"1125", 2, 2);
    v3 = sub_100206B0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1126",
           (int)"UTF_verify_eq_str( *, \"\", \"a\" ) data comparison",
           (const char *)&unk_1005E69C,
           "a",
           (int)"This test is expected to fail");
    sub_1001BFE0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1127",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"1129", 2, 2);
    v4 = sub_100206B0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1130",
           (int)"UTF_verify_ne_str( *, \"\", \"\" ) data comparison",
           (const char *)&unk_1005E69C,
           (const char *)&unk_1005E69C,
           (int)"This test is expected to fail");
    sub_1001BFE0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1131",
      (int)"Return value from previous UTF_verify_ne_str() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"1133", 2, 2);
    v5 = sub_100206B0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1134",
           (int)"UTF_verify_ne_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           (int)"This test is expected to fail");
    result = sub_1001BFE0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1135",
               (int)"Return value from previous UTF_verify_ne_str() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1117",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10189070: using guessed type char byte_10189070;

//----- (10028700) --------------------------------------------------------
char sub_10028700()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1162", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100AAA6C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100AAA68[v2];
        v4 = dword_100AAA64[v2];
        v5 = dword_100AAA60[v2];
        v6 = sub_1001BC80(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               (&off_100AAA70)[v2 * 4]);
        v7 = sub_1001E640(
               0,
               *(&dword_100A65F4 + dword_100AAA6C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1162",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100AAA6C[v2]],
               (&off_100AAA70)[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1162",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1162",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AAA60: using guessed type int dword_100AAA60[];
// 100AAA64: using guessed type int dword_100AAA64[];
// 100AAA68: using guessed type int dword_100AAA68[];
// 100AAA6C: using guessed type int dword_100AAA6C[];
// 100AAA70: using guessed type char *off_100AAA70;
// 10189070: using guessed type char byte_10189070;

//----- (10028860) --------------------------------------------------------
char sub_10028860()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1188", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100AADD8[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100AADD4[v2 / 2];
        v4 = word_100AADD2[v2 / 2];
        v5 = word_100AADD0[v2 / 2];
        v6 = sub_1001BC80(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               *(_DWORD *)&off_100AADDC[v2]);
        v7 = sub_1001E9E0(
               0,
               *(&dword_100A65F4 + dword_100AADD8[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1188",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100AADD8[v2 / 4]],
               *(_DWORD *)&off_100AADDC[v2]);
        LOBYTE(v0) = sub_1001BFE0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1188",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1188",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AADD0: using guessed type __int16 word_100AADD0[];
// 100AADD2: using guessed type __int16 word_100AADD2[];
// 100AADD4: using guessed type __int16 word_100AADD4[];
// 100AADD8: using guessed type int dword_100AADD8[];
// 10189070: using guessed type char byte_10189070;

//----- (100289C0) --------------------------------------------------------
char sub_100289C0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1214", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100AB09C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100AB098[v2];
        v4 = dword_100AB094[v2];
        v5 = dword_100AB090[v2];
        v6 = sub_1001BC80(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               (&off_100AB0A0)[v2 * 4]);
        v7 = sub_1001EDE0(
               0,
               *(&dword_100A65F4 + dword_100AB09C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1214",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100AB09C[v2]],
               (&off_100AB0A0)[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1214",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1214",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AB090: using guessed type int dword_100AB090[];
// 100AB094: using guessed type int dword_100AB094[];
// 100AB098: using guessed type int dword_100AB098[];
// 100AB09C: using guessed type int dword_100AB09C[];
// 100AB0A0: using guessed type char *off_100AB0A0;
// 10189070: using guessed type char byte_10189070;

//----- (10028B20) --------------------------------------------------------
char sub_10028B20()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1240", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100AB418[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100AB414[v2];
        LODWORD(v3) = dword_100AB410[v2];
        HIDWORD(v4) = dword_100AB40C[v2];
        LODWORD(v4) = dword_100AB408[v2];
        HIDWORD(v5) = dword_100AB404[v2];
        LODWORD(v5) = dword_100AB400[v2];
        v6 = sub_1001BC80(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               *(_DWORD *)&off_100AB41C[v2 * 4]);
        v7 = sub_1001F180(
               0,
               *(&dword_100A65F4 + dword_100AB418[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1240",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100AB418[v2]],
               *(_DWORD *)&off_100AB41C[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1240",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1240",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AB400: using guessed type int dword_100AB400[];
// 100AB404: using guessed type int dword_100AB404[];
// 100AB408: using guessed type int dword_100AB408[];
// 100AB40C: using guessed type int dword_100AB40C[];
// 100AB410: using guessed type int dword_100AB410[];
// 100AB414: using guessed type int dword_100AB414[];
// 100AB418: using guessed type int dword_100AB418[];
// 10189070: using guessed type char byte_10189070;

//----- (10028C90) --------------------------------------------------------
char sub_10028C90()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1266", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100AB984[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100AB982[v2 * 4];
        v4 = byte_100AB981[v2 * 4];
        v5 = byte_100AB980[v2 * 4];
        v6 = sub_1001BC80(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               (&off_100AB988)[v2 * 4]);
        v7 = sub_1001F760(
               0,
               *(&dword_100A65F4 + dword_100AB984[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1266",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100AB984[v2]],
               (&off_100AB988)[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1266",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1266",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AB984: using guessed type int dword_100AB984[];
// 100AB988: using guessed type char *off_100AB988;
// 10189070: using guessed type char byte_10189070;

//----- (10028DF0) --------------------------------------------------------
char sub_10028DF0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1292", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100ABB9C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100ABB98[v2];
        v4 = dword_100ABB94[v2];
        v5 = dword_100ABB90[v2];
        v6 = sub_1001BC80(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               (&off_100ABBA0)[v2 * 4]);
        v7 = sub_1001FB50(
               0,
               *(&dword_100A65F4 + dword_100ABB9C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1292",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100ABB9C[v2]],
               (&off_100ABBA0)[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1292",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1292",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100ABB90: using guessed type int dword_100ABB90[];
// 100ABB94: using guessed type int dword_100ABB94[];
// 100ABB98: using guessed type int dword_100ABB98[];
// 100ABB9C: using guessed type int dword_100ABB9C[];
// 100ABBA0: using guessed type char *off_100ABBA0;
// 10189070: using guessed type char byte_10189070;

//----- (10028F50) --------------------------------------------------------
char sub_10028F50()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_1001B220(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"All Fail Robustness Test Group For Type 'bitmap'");
  v0 = sub_1001BB70(0);
  sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1337", (int)v0);
  sub_1001B220(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10189070 )
  {
    v2 = 0;
    do
    {
      if ( off_100ABF04[v2] )
      {
        sub_1001B9E0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100ABF0C[v2 * 4], 0x100u, &v11);
        sub_1001B9E0((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_100ABF04[v2], 0x100u, &v12);
        sub_10025DE0(&v12, &v11);
      }
      if ( byte_100ABF00[v2 * 4] )
      {
        sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"1362", 2, 2);
        v3 = off_100ABF08[v2];
        v4 = *(char **)&off_100ABF0C[v2 * 4];
        v5 = sub_1001BC80(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100ABF0C[v2 * 4],
               off_100ABF08[v2]);
        v6 = sub_10020300(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1367",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1001BFE0(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1369",
                   (int)"Return value from previous UTF_verify_eq_bitmap_rt() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"1373", 2, 2);
        v7 = off_100ABF08[v2];
        v8 = *(char **)&off_100ABF0C[v2 * 4];
        v9 = sub_1001BC80(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100ABF0C[v2 * 4],
               off_100ABF08[v2]);
        v10 = sub_10020300(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"1378",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1001BFE0(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1380",
                   (int)"Return value from previous UTF_verify_ne_bitmap_rt() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 4;
    }
    while ( v2 < 36 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1341",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 100ABF04: using guessed type char *off_100ABF04[3];
// 100ABF08: using guessed type char *off_100ABF08[2];
// 10189070: using guessed type char byte_10189070;

//----- (10029170) --------------------------------------------------------
char sub_10029170()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1001B220(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_1001BB70(0);
  sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1407", (int)v0);
  sub_1001B220(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"Verify relationship between boolean values using the UTF_verify_bool_rt() function");
  if ( byte_10189070 )
  {
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"1415", 2, 2);
    v2 = sub_1001BFE0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1416",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1001BFE0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1417",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"1419", 2, 2);
    v3 = sub_1001BFE0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1420",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1001BFE0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1421",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"1423", 2, 2);
    v4 = sub_1001BFE0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1424",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1001BFE0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1425",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"1427", 2, 2);
    v5 = sub_1001BFE0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1428",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1001BFE0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1429",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1411",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10189070: using guessed type char byte_10189070;

//----- (10029370) --------------------------------------------------------
char sub_10029370()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1469", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100ABF94[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"1469", 2, 2);
        v3 = byte_100ABF91[v2 * 4];
        v4 = byte_100ABF90[v2 * 4];
        v5 = sub_1001BC80(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + dword_100ABF94[v2])],
               (&off_100ABF98)[v2 * 4]);
        v6 = sub_1001C120(
               1,
               *(&dword_100A65F4 + dword_100ABF94[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1469",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1001BC80(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100ABF94[v2]],
               (&off_100ABF98)[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1469",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1469",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100ABF94: using guessed type int dword_100ABF94[];
// 100ABF98: using guessed type char *off_100ABF98;
// 10189070: using guessed type char byte_10189070;

//----- (100294F0) --------------------------------------------------------
char sub_100294F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1503", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100AC218[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_100AC210[v2 / 8];
        v4 = dbl_100AC208[v2 / 8];
        v5 = dbl_100AC200[v2 / 8];
        v6 = sub_1001BC80(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               *(_DWORD *)&off_100AC21C[v2]);
        v7 = sub_1001C4D0(
               1,
               *(&dword_100A65F4 + dword_100AC218[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1503",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100AC218[v2 / 4]],
               *(_DWORD *)&off_100AC21C[v2]);
        LOBYTE(v0) = sub_1001BFE0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1503",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1503",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AC200: using guessed type double dbl_100AC200[];
// 100AC208: using guessed type double dbl_100AC208[];
// 100AC210: using guessed type double dbl_100AC210[];
// 100AC218: using guessed type int dword_100AC218[];
// 10189070: using guessed type char byte_10189070;

//----- (10029670) --------------------------------------------------------
char sub_10029670()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1539", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100ACE2C[v2];
      if ( v0 != 6 )
      {
        v3 = flt_100ACE28[v2];
        v4 = flt_100ACE24[v2];
        v5 = flt_100ACE20[v2];
        v6 = sub_1001BC80(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               (&off_100ACE30)[v2 * 4]);
        v7 = sub_1001C920(
               1,
               *(&dword_100A65F4 + dword_100ACE2C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1539",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100ACE2C[v2]],
               (&off_100ACE30)[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1539",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1539",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100ACE20: using guessed type float flt_100ACE20[];
// 100ACE24: using guessed type float flt_100ACE24[];
// 100ACE28: using guessed type float flt_100ACE28[];
// 100ACE2C: using guessed type int dword_100ACE2C[];
// 100ACE30: using guessed type char *off_100ACE30;
// 10189070: using guessed type char byte_10189070;

//----- (100297E0) --------------------------------------------------------
char sub_100297E0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1001B220(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1001BB70(0);
  sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1561", (int)v0);
  sub_1001B220(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10189070 )
  {
    sub_10020600(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1569",
      (int)"Check ptr for equality",
      (int)sub_100297E0,
      (int)sub_100297E0,
      0);
    sub_10020600(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1570",
      (int)"Check ptr for inequality",
      (int)sub_100297E0,
      0,
      0);
    result = sub_10020600(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1571",
               (int)"Check ptr for inequality",
               0,
               (int)sub_100297E0,
               0);
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1565",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10189070: using guessed type char byte_10189070;

//----- (100298D0) --------------------------------------------------------
char sub_100298D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1598", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100AD5C4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100AD5C0[v2];
        v4 = dword_100AD5BC[v2];
        v5 = dword_100AD5B8[v2];
        v6 = sub_1001BC80(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               *(_DWORD *)&off_100AD5C8[v2 * 4]);
        v7 = sub_1001CDE0(
               1,
               *(&dword_100A65F4 + dword_100AD5C4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1598",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100AD5C4[v2]],
               *(_DWORD *)&off_100AD5C8[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1598",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1598",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AD5B8: using guessed type int dword_100AD5B8[];
// 100AD5BC: using guessed type int dword_100AD5BC[];
// 100AD5C0: using guessed type int dword_100AD5C0[];
// 100AD5C4: using guessed type int dword_100AD5C4[];
// 10189070: using guessed type char byte_10189070;

//----- (10029A30) --------------------------------------------------------
char sub_10029A30()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1624", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100ADD58[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100ADD54[v2 / 2];
        v4 = word_100ADD52[v2 / 2];
        v5 = word_100ADD50[v2 / 2];
        v6 = sub_1001BC80(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               *(_DWORD *)&off_100ADD5C[v2]);
        v7 = sub_1001D1A0(
               1,
               *(&dword_100A65F4 + dword_100ADD58[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1624",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100ADD58[v2 / 4]],
               *(_DWORD *)&off_100ADD5C[v2]);
        LOBYTE(v0) = sub_1001BFE0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1624",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1624",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100ADD50: using guessed type __int16 word_100ADD50[];
// 100ADD52: using guessed type __int16 word_100ADD52[];
// 100ADD54: using guessed type __int16 word_100ADD54[];
// 100ADD58: using guessed type int dword_100ADD58[];
// 10189070: using guessed type char byte_10189070;

//----- (10029B90) --------------------------------------------------------
char sub_10029B90()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1650", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100AE36C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100AE368[v2];
        v4 = dword_100AE364[v2];
        v5 = dword_100AE360[v2];
        v6 = sub_1001BC80(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               (&off_100AE370)[v2 * 4]);
        v7 = sub_1001D5A0(
               1,
               *(&dword_100A65F4 + dword_100AE36C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1650",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100AE36C[v2]],
               (&off_100AE370)[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1650",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1650",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AE360: using guessed type int dword_100AE360[];
// 100AE364: using guessed type int dword_100AE364[];
// 100AE368: using guessed type int dword_100AE368[];
// 100AE36C: using guessed type int dword_100AE36C[];
// 100AE370: using guessed type char *off_100AE370;
// 10189070: using guessed type char byte_10189070;

//----- (10029CF0) --------------------------------------------------------
char sub_10029CF0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1676", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100AEB10[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100AEB0C[v2];
        LODWORD(v3) = dword_100AEB08[v2];
        HIDWORD(v4) = dword_100AEB04[v2];
        LODWORD(v4) = dword_100AEB00[v2];
        HIDWORD(v5) = dword_100AEAFC[v2];
        LODWORD(v5) = dword_100AEAF8[v2];
        v6 = sub_1001BC80(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               *(_DWORD *)&off_100AEB14[v2 * 4]);
        v7 = sub_1001D960(
               1,
               *(&dword_100A65F4 + dword_100AEB10[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1676",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100AEB10[v2]],
               *(_DWORD *)&off_100AEB14[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1676",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1676",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AEAF8: using guessed type int dword_100AEAF8[];
// 100AEAFC: using guessed type int dword_100AEAFC[];
// 100AEB00: using guessed type int dword_100AEB00[];
// 100AEB04: using guessed type int dword_100AEB04[];
// 100AEB08: using guessed type int dword_100AEB08[];
// 100AEB0C: using guessed type int dword_100AEB0C[];
// 100AEB10: using guessed type int dword_100AEB10[];
// 10189070: using guessed type char byte_10189070;

//----- (10029E60) --------------------------------------------------------
char sub_10029E60()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1702", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100AF71C[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100AF71A[v2 * 4];
        v4 = byte_100AF719[v2 * 4];
        v5 = byte_100AF718[v2 * 4];
        v6 = sub_1001BC80(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               (&off_100AF720)[v2 * 4]);
        v7 = sub_1001DEA0(
               1,
               *(&dword_100A65F4 + dword_100AF71C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1702",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100AF71C[v2]],
               (&off_100AF720)[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1702",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1702",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AF71C: using guessed type int dword_100AF71C[];
// 100AF720: using guessed type char *off_100AF720;
// 10189070: using guessed type char byte_10189070;

//----- (10029FC0) --------------------------------------------------------
char sub_10029FC0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1728", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100AFBB4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100AFBB0[v2];
        v4 = dword_100AFBAC[v2];
        v5 = dword_100AFBA8[v2];
        v6 = sub_1001BC80(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               *(_DWORD *)&off_100AFBB8[v2 * 4]);
        v7 = sub_1001E280(
               1,
               *(&dword_100A65F4 + dword_100AFBB4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1728",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100AFBB4[v2]],
               *(_DWORD *)&off_100AFBB8[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1728",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1728",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AFBA8: using guessed type int dword_100AFBA8[];
// 100AFBAC: using guessed type int dword_100AFBAC[];
// 100AFBB0: using guessed type int dword_100AFBB0[];
// 100AFBB4: using guessed type int dword_100AFBB4[];
// 10189070: using guessed type char byte_10189070;

//----- (1002A120) --------------------------------------------------------
char sub_1002A120()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1001B220(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_1001BB70(0);
  sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1752", (int)v0);
  sub_1001B220(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10189070 )
  {
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"1760", 2, 2);
    v2 = sub_100206B0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1761",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_1005E69C,
           0);
    sub_1001BFE0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1762",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"1764", 2, 2);
    v3 = sub_100206B0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1765",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"a\" ) data comparison",
           (const char *)&unk_1005E69C,
           "a",
           0);
    sub_1001BFE0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1766",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"1768", 2, 2);
    v4 = sub_100206B0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1769",
           (int)"UTF_verify_ne_str_rt( *, \"\", \"\" ) data comparison",
           (const char *)&unk_1005E69C,
           (const char *)&unk_1005E69C,
           0);
    sub_1001BFE0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1770",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"1772", 2, 2);
    v5 = sub_100206B0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1773",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    result = sub_1001BFE0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1774",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1756",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10189070: using guessed type char byte_10189070;

//----- (1002A320) --------------------------------------------------------
char sub_1002A320()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1801", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100B034C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B0348[v2];
        v4 = dword_100B0344[v2];
        v5 = dword_100B0340[v2];
        v6 = sub_1001BC80(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               (&off_100B0350)[v2 * 4]);
        v7 = sub_1001E640(
               1,
               *(&dword_100A65F4 + dword_100B034C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1801",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100B034C[v2]],
               (&off_100B0350)[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1801",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1801",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B0340: using guessed type int dword_100B0340[];
// 100B0344: using guessed type int dword_100B0344[];
// 100B0348: using guessed type int dword_100B0348[];
// 100B034C: using guessed type int dword_100B034C[];
// 100B0350: using guessed type char *off_100B0350;
// 10189070: using guessed type char byte_10189070;

//----- (1002A480) --------------------------------------------------------
char sub_1002A480()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1827", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100B06B8[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100B06B4[v2 / 2];
        v4 = word_100B06B2[v2 / 2];
        v5 = word_100B06B0[v2 / 2];
        v6 = sub_1001BC80(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               *(_DWORD *)&off_100B06BC[v2]);
        v7 = sub_1001E9E0(
               1,
               *(&dword_100A65F4 + dword_100B06B8[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1827",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100B06B8[v2 / 4]],
               *(_DWORD *)&off_100B06BC[v2]);
        LOBYTE(v0) = sub_1001BFE0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1827",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1827",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B06B0: using guessed type __int16 word_100B06B0[];
// 100B06B2: using guessed type __int16 word_100B06B2[];
// 100B06B4: using guessed type __int16 word_100B06B4[];
// 100B06B8: using guessed type int dword_100B06B8[];
// 10189070: using guessed type char byte_10189070;

//----- (1002A5E0) --------------------------------------------------------
char sub_1002A5E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1853", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100B097C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B0978[v2];
        v4 = dword_100B0974[v2];
        v5 = dword_100B0970[v2];
        v6 = sub_1001BC80(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               (&off_100B0980)[v2 * 4]);
        v7 = sub_1001EDE0(
               1,
               *(&dword_100A65F4 + dword_100B097C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1853",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100B097C[v2]],
               (&off_100B0980)[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1853",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1853",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B0970: using guessed type int dword_100B0970[];
// 100B0974: using guessed type int dword_100B0974[];
// 100B0978: using guessed type int dword_100B0978[];
// 100B097C: using guessed type int dword_100B097C[];
// 100B0980: using guessed type char *off_100B0980;
// 10189070: using guessed type char byte_10189070;

//----- (1002A740) --------------------------------------------------------
char sub_1002A740()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1879", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100B0CF8[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100B0CF4[v2];
        LODWORD(v3) = dword_100B0CF0[v2];
        HIDWORD(v4) = dword_100B0CEC[v2];
        LODWORD(v4) = dword_100B0CE8[v2];
        HIDWORD(v5) = dword_100B0CE4[v2];
        LODWORD(v5) = dword_100B0CE0[v2];
        v6 = sub_1001BC80(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               *(_DWORD *)&off_100B0CFC[v2 * 4]);
        v7 = sub_1001F180(
               1,
               *(&dword_100A65F4 + dword_100B0CF8[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1879",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100B0CF8[v2]],
               *(_DWORD *)&off_100B0CFC[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1879",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1879",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B0CE0: using guessed type int dword_100B0CE0[];
// 100B0CE4: using guessed type int dword_100B0CE4[];
// 100B0CE8: using guessed type int dword_100B0CE8[];
// 100B0CEC: using guessed type int dword_100B0CEC[];
// 100B0CF0: using guessed type int dword_100B0CF0[];
// 100B0CF4: using guessed type int dword_100B0CF4[];
// 100B0CF8: using guessed type int dword_100B0CF8[];
// 10189070: using guessed type char byte_10189070;

//----- (1002A8B0) --------------------------------------------------------
char sub_1002A8B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1905", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100B1264[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100B1262[v2 * 4];
        v4 = byte_100B1261[v2 * 4];
        v5 = byte_100B1260[v2 * 4];
        v6 = sub_1001BC80(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               (&off_100B1268)[v2 * 4]);
        v7 = sub_1001F760(
               1,
               *(&dword_100A65F4 + dword_100B1264[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1905",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100B1264[v2]],
               (&off_100B1268)[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1905",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1905",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B1264: using guessed type int dword_100B1264[];
// 100B1268: using guessed type char *off_100B1268;
// 10189070: using guessed type char byte_10189070;

//----- (1002AA10) --------------------------------------------------------
char sub_1002AA10()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10189070 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1931", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100B147C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B1478[v2];
        v4 = dword_100B1474[v2];
        v5 = dword_100B1470[v2];
        v6 = sub_1001BC80(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * *(&dword_100A65F4 + v0)],
               (&off_100B1480)[v2 * 4]);
        v7 = sub_1001FB50(
               1,
               *(&dword_100A65F4 + dword_100B147C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1931",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001BC80(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100B147C[v2]],
               (&off_100B1480)[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1931",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1931",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B1470: using guessed type int dword_100B1470[];
// 100B1474: using guessed type int dword_100B1474[];
// 100B1478: using guessed type int dword_100B1478[];
// 100B147C: using guessed type int dword_100B147C[];
// 100B1480: using guessed type char *off_100B1480;
// 10189070: using guessed type char byte_10189070;

//----- (1002AB70) --------------------------------------------------------
char sub_1002AB70()
{
  const char *v0; // eax@1
  int v1; // esi@1
  char result; // al@2
  char v3; // al@5

  sub_1001B220(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"All Pass Miscellaneous Test Group");
  v0 = sub_1001BB70(0);
  sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1968", (int)v0);
  sub_1001B220(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"Verify miscellaneous macros");
  v1 = 5;
  if ( byte_10189071 )
  {
    sub_100206B0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1978",
      (int)"Check PASS macro",
      "UTF_verify_pass unconditional pass",
      "UTF_verify_pass unconditional pass",
      0);
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"1987", 0, 0);
    sub_1001B220(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1988", (int)"Sub-group A, msg 1");
    sub_1001B220(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1989", (int)"Sub-group A, msg 2");
    sub_1001B220(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1990", (int)"Sub-group A, msg 3");
    sub_1001B220(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1991", (int)"Sub-group A, msg 4");
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"1993", 0, 0);
    sub_1001B220(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1994", (int)"Sub-group B, msg 1");
    sub_1001B220(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1995", (int)"Sub-group B, msg 2");
    sub_1001B220(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1996", (int)"Sub-group B, msg 3");
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"1998", 1, 2);
    sub_1001CDE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"1999", (int)"Sub-group C verify 1", 1, 1, 0, 0);
    sub_1001B220(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2000", (int)"Sub-group C, msg 1");
    sub_1001B220(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2001", (int)"Sub-group C, msg 2");
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2003", 2, 2);
    sub_1001B220(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2004", (int)"Sub-group D, msg 1");
    sub_1001CDE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2005", (int)"Sub-group D verify 1", 1, 1, 0, 0);
    sub_1001B220(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2006", (int)"Sub-group D, msg 2");
    sub_1001CDE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2007", (int)"Sub-group D verify 2", 2, 2, 0, 0);
    sub_1001B220(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2009", (int)"non sub-group msg 1");
    sub_1001B220(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2010", (int)"non sub-group msg 2");
    sub_1001CDE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2011", (int)"non sub-group verify 1", 1, 1, 0, 0);
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2013", 3, 4);
    sub_1001B220(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2014", (int)"Sub-group E, msg 1");
    sub_1001CDE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2015", (int)"Sub-group E verify 1", 1, 1, 0, 0);
    sub_1001B220(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2016", (int)"Sub-group E, msg 2");
    sub_1001CDE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2017", (int)"Sub-group E verify 2", 2, 2, 0, 0);
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2019", 3, 4);
    sub_1001CDE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2020", (int)"Sub-group F verify 1", 1, 1, 0, 0);
    sub_1001B220(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2021", (int)"Sub-group F, msg 1");
    sub_1001CDE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2022", (int)"Sub-group F verify 2", 2, 2, 0, 0);
    sub_1001B220(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2023", (int)"Sub-group F, msg 2");
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2025", 4, 0);
    sub_1001CDE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2026", (int)"Sub-group G verify 1", 1, 1, 0, 0);
    sub_1001B220(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2027", (int)"Sub-group G, msg 1");
    sub_1001B220(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2028", (int)"Sub-group G, msg 2");
    sub_1001CDE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2029", (int)"Sub-group G verify 2", 2, 2, 0, 0);
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2030", 5, 0);
    sub_1001B220(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2032", (int)"non sub-group msg 3");
    sub_1001B220(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2033", (int)"non sub-group msg 4");
    sub_1001CDE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2034", (int)"non sub-group verify 2", 2, 2, 0, 0);
    if ( !sub_10019C80() )
      v1 = 3;
    sub_1001CDE0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2037",
      (int)"Verify x is 3 using UTF_CALL_UNIT",
      v1,
      3,
      0,
      0);
    v3 = sub_10019C80();
    sub_1001CDE0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2040",
      (int)"Verify x is 4 using UTF_CALL_UNIT2",
      v3 != 0 ? 6 : 4,
      4,
      0,
      0);
    sub_1001B220(
      3,
      (int)"**MSG**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2042",
      (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceeds the int"
           "ernal UTF buffer size, can be written to the output without the system crashing or otherwise demonstrating ha"
           "rmful side-effects. If the system does crash while writing this message, it is a sign that possibly the UTF h"
           "as some buffer overlow issues that should be examined and corrected. If the system runs successfully, it does"
           " not prove the UTF is defect free in this regard, only that this particular scenario is succesfully handled u"
           "nder the current conditions. Other invocations of UTF interfaces with large messages may be problematic, but "
           "at least on the surface, things seem to be OK for now.");
    result = sub_1001CDE0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2043",
               (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceed"
                    "s the internal UTF buffer size, can be written to the output without the system crashing or otherwis"
                    "e demonstrating harmful side-effects. If the system does crash while writing this message, it is a s"
                    "ign that possibly the UTF has some buffer overlow issues that should be examined and corrected. If t"
                    "he system runs successfully, it does not prove the UTF is defect free in this regard, only that this"
                    " particular scenario is succesfully handled under the current conditions. Other invocations of UTF i"
                    "nterfaces with large messages may be problematic, but at least on the surface, things seem to be OK for now.",
               4,
               4,
               0,
               0);
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1974",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10189071: using guessed type char byte_10189071;

//----- (1002B110) --------------------------------------------------------
char sub_1002B110()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  char *v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_1001B220(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"All Pass Test Group For Type 'bitmap'");
  v0 = sub_1001BB70(0);
  sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2085", (int)v0);
  sub_1001B220(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10189071 )
  {
    v2 = 0;
    do
    {
      if ( off_100B17E4[v2] )
      {
        sub_1001B9E0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100B17EC[v2 * 4], 0x100u, &v13);
        sub_1001B9E0((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_100B17E4[v2], 0x100u, &v14);
        sub_10025DE0(&v14, &v13);
      }
      if ( byte_100B17E0[v2 * 4] )
      {
        sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2110", 2, 2);
        v3 = off_100B17E8[v2];
        v4 = *(char **)&off_100B17EC[v2 * 4];
        v5 = sub_1001BC80(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100B17EC[v2 * 4],
               off_100B17E8[v2]);
        v12 = 1;
        v11 = sub_10020300(
                0,
                0,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2114",
                (int)v5,
                (int)v4,
                (int)v3,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_eq_bitmap() call";
        v9 = "2115";
      }
      else
      {
        sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2119", 2, 2);
        v6 = off_100B17E8[v2];
        v7 = *(char **)&off_100B17EC[v2 * 4];
        v8 = sub_1001BC80(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100B17EC[v2 * 4],
               off_100B17E8[v2]);
        v12 = 1;
        v11 = sub_10020300(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2123",
                (int)v8,
                (int)v7,
                (int)v6,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_ne_bitmap() call";
        v9 = "2124";
      }
      result = sub_1001BFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 4;
    }
    while ( v2 < 20 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2089",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B17E4: using guessed type char *off_100B17E4[3];
// 100B17E8: using guessed type char *off_100B17E8[2];
// 10189071: using guessed type char byte_10189071;

//----- (1002B320) --------------------------------------------------------
char sub_1002B320()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1001B220(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_1001BB70(0);
  sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2151", (int)v0);
  sub_1001B220(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10189071 )
  {
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2159", 2, 2);
    v2 = sub_1001BFE0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2160",
           (int)"UTF_verify_eq_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1001BFE0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2161",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      0);
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2163", 2, 2);
    v3 = sub_1001BFE0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2164",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1001BFE0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2165",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      0);
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2167", 2, 2);
    v4 = sub_1001BFE0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2168",
           (int)"UTF_verify_ne_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1001BFE0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2169",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      0);
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2171", 2, 2);
    v5 = sub_1001BFE0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2172",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1001BFE0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2173",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2155",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10189071: using guessed type char byte_10189071;

//----- (1002B510) --------------------------------------------------------
char sub_1002B510()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100B1834[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2213", 2, 2);
        v3 = byte_100B1831[v2 * 4];
        v4 = byte_100B1830[v2 * 4];
        v5 = sub_1001BC80(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * dword_100B1834[v2]],
               (&off_100B1838)[v2 * 4]);
        v6 = sub_1001C120(0, dword_100B1834[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v5, v4, v3, 0);
        v7 = sub_1001BC80(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100B1834[v2]],
               (&off_100B1838)[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2213",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 100B1834: using guessed type int dword_100B1834[];
// 100B1838: using guessed type char *off_100B1838;
// 10189071: using guessed type char byte_10189071;

//----- (1002B680) --------------------------------------------------------
char sub_1002B680()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2247", 2, 2);
      v3 = dbl_100B1AB0[v2 / 2];
      v4 = dbl_100B1AA8[v2 / 2];
      v5 = dbl_100B1AA0[v2 / 2];
      v6 = sub_1001BC80(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100B1AB8[v2]],
             *(_DWORD *)&off_100B1ABC[v2 * 4]);
      v7 = sub_1001C4D0(0, dword_100B1AB8[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100B1AB8[v2]],
             *(_DWORD *)&off_100B1ABC[v2 * 4]);
      result = sub_1001BFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2247",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B1AA0: using guessed type double dbl_100B1AA0[];
// 100B1AA8: using guessed type double dbl_100B1AA8[];
// 100B1AB0: using guessed type double dbl_100B1AB0[];
// 100B1AB8: using guessed type int dword_100B1AB8[];
// 10189071: using guessed type char byte_10189071;

//----- (1002B7F0) --------------------------------------------------------
char sub_1002B7F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2283", 2, 2);
      v3 = flt_100B26C8[v2];
      v4 = flt_100B26C4[v2];
      v5 = flt_100B26C0[v2];
      v6 = sub_1001BC80(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100B26CC[v2]],
             (&off_100B26D0)[v2 * 4]);
      v7 = sub_1001C920(0, dword_100B26CC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100B26CC[v2]],
             (&off_100B26D0)[v2 * 4]);
      result = sub_1001BFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2283",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B26C0: using guessed type float flt_100B26C0[];
// 100B26C4: using guessed type float flt_100B26C4[];
// 100B26C8: using guessed type float flt_100B26C8[];
// 100B26CC: using guessed type int dword_100B26CC[];
// 100B26D0: using guessed type char *off_100B26D0;
// 10189071: using guessed type char byte_10189071;

//----- (1002B950) --------------------------------------------------------
char sub_1002B950()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1001B220(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1001BB70(0);
  sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2305", (int)v0);
  sub_1001B220(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10189071 )
  {
    sub_10020600(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2313",
      (int)"Check ptr for equality",
      (int)sub_1002B950,
      (int)sub_1002B950,
      0);
    sub_10020600(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2314",
      (int)"Check ptr for inequality",
      (int)sub_1002B950,
      0,
      0);
    result = sub_10020600(
               0,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2315",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1002B950,
               0);
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2309",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10189071: using guessed type char byte_10189071;

//----- (1002BA40) --------------------------------------------------------
char sub_1002BA40()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2342", 2, 2);
      v3 = dword_100B2E60[v2];
      v4 = dword_100B2E5C[v2];
      v5 = dword_100B2E58[v2];
      v6 = sub_1001BC80(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100B2E64[v2]],
             *(_DWORD *)&off_100B2E68[v2 * 4]);
      v7 = sub_1001CDE0(0, dword_100B2E64[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100B2E64[v2]],
             *(_DWORD *)&off_100B2E68[v2 * 4]);
      result = sub_1001BFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2342",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B2E58: using guessed type int dword_100B2E58[];
// 100B2E5C: using guessed type int dword_100B2E5C[];
// 100B2E60: using guessed type int dword_100B2E60[];
// 100B2E64: using guessed type int dword_100B2E64[];
// 10189071: using guessed type char byte_10189071;

//----- (1002BBA0) --------------------------------------------------------
char sub_1002BBA0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2368", 2, 2);
      v3 = word_100B35F4[v2 / 2];
      v4 = word_100B35F2[v2 / 2];
      v5 = word_100B35F0[v2 / 2];
      v6 = sub_1001BC80(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100B35F8[v2 / 4]],
             *(_DWORD *)&off_100B35FC[v2]);
      v7 = sub_1001D1A0(
             0,
             dword_100B35F8[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2368",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100B35F8[v2 / 4]],
             *(_DWORD *)&off_100B35FC[v2]);
      result = sub_1001BFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2368",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B35F0: using guessed type __int16 word_100B35F0[];
// 100B35F2: using guessed type __int16 word_100B35F2[];
// 100B35F4: using guessed type __int16 word_100B35F4[];
// 100B35F8: using guessed type int dword_100B35F8[];
// 10189071: using guessed type char byte_10189071;

//----- (1002BD00) --------------------------------------------------------
char sub_1002BD00()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2394", 2, 2);
      v3 = dword_100B3C08[v2];
      v4 = dword_100B3C04[v2];
      v5 = dword_100B3C00[v2];
      v6 = sub_1001BC80(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100B3C0C[v2]],
             (&off_100B3C10)[v2 * 4]);
      v7 = sub_1001D5A0(0, dword_100B3C0C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100B3C0C[v2]],
             (&off_100B3C10)[v2 * 4]);
      result = sub_1001BFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2394",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B3C00: using guessed type int dword_100B3C00[];
// 100B3C04: using guessed type int dword_100B3C04[];
// 100B3C08: using guessed type int dword_100B3C08[];
// 100B3C0C: using guessed type int dword_100B3C0C[];
// 100B3C10: using guessed type char *off_100B3C10;
// 10189071: using guessed type char byte_10189071;

//----- (1002BE60) --------------------------------------------------------
char sub_1002BE60()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2420", 2, 2);
      HIDWORD(v3) = dword_100B43AC[v2];
      LODWORD(v3) = dword_100B43A8[v2];
      HIDWORD(v4) = dword_100B43A4[v2];
      LODWORD(v4) = dword_100B43A0[v2];
      HIDWORD(v5) = dword_100B439C[v2];
      LODWORD(v5) = dword_100B4398[v2];
      v6 = sub_1001BC80(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100B43B0[v2]],
             *(_DWORD *)&off_100B43B4[v2 * 4]);
      v7 = sub_1001D960(0, dword_100B43B0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100B43B0[v2]],
             *(_DWORD *)&off_100B43B4[v2 * 4]);
      result = sub_1001BFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2420",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B4398: using guessed type int dword_100B4398[];
// 100B439C: using guessed type int dword_100B439C[];
// 100B43A0: using guessed type int dword_100B43A0[];
// 100B43A4: using guessed type int dword_100B43A4[];
// 100B43A8: using guessed type int dword_100B43A8[];
// 100B43AC: using guessed type int dword_100B43AC[];
// 100B43B0: using guessed type int dword_100B43B0[];
// 10189071: using guessed type char byte_10189071;

//----- (1002BFD0) --------------------------------------------------------
char sub_1002BFD0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2446", 2, 2);
      v3 = byte_100B4FBA[v2 * 4];
      v4 = byte_100B4FB9[v2 * 4];
      v5 = byte_100B4FB8[v2 * 4];
      v6 = sub_1001BC80(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100B4FBC[v2]],
             (&off_100B4FC0)[v2 * 4]);
      v7 = sub_1001DEA0(0, dword_100B4FBC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100B4FBC[v2]],
             (&off_100B4FC0)[v2 * 4]);
      result = sub_1001BFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2446",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B4FBC: using guessed type int dword_100B4FBC[];
// 100B4FC0: using guessed type char *off_100B4FC0;
// 10189071: using guessed type char byte_10189071;

//----- (1002C130) --------------------------------------------------------
char sub_1002C130()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2472", 2, 2);
      v3 = dword_100B5450[v2];
      v4 = dword_100B544C[v2];
      v5 = dword_100B5448[v2];
      v6 = sub_1001BC80(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100B5454[v2]],
             *(_DWORD *)&off_100B5458[v2 * 4]);
      v7 = sub_1001E280(0, dword_100B5454[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100B5454[v2]],
             *(_DWORD *)&off_100B5458[v2 * 4]);
      result = sub_1001BFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2472",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B5448: using guessed type int dword_100B5448[];
// 100B544C: using guessed type int dword_100B544C[];
// 100B5450: using guessed type int dword_100B5450[];
// 100B5454: using guessed type int dword_100B5454[];
// 10189071: using guessed type char byte_10189071;

//----- (1002C290) --------------------------------------------------------
char sub_1002C290()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1001B220(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_1001BB70(0);
  sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2496", (int)v0);
  sub_1001B220(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10189071 )
  {
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2504", 2, 2);
    v2 = sub_100206B0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2505",
           (int)"UTF_verify_eq_str( *, \"\", \"\" ) data comparison",
           (const char *)&unk_1005E69C,
           (const char *)&unk_1005E69C,
           0);
    sub_1001BFE0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2506",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      0);
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2508", 2, 2);
    v3 = sub_100206B0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2509",
           (int)"UTF_verify_eq_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1001BFE0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2510",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      0);
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2512", 2, 2);
    v4 = sub_100206B0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2513",
           (int)"UTF_verify_ne_str( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_1005E69C,
           0);
    sub_1001BFE0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2514",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v4,
      1u,
      0);
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2516", 2, 2);
    v5 = sub_100206B0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2517",
           (int)"UTF_verify_ne_str( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1001BFE0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2518",
               (int)"Return value from previous UTF_verify_eq_str() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2500",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10189071: using guessed type char byte_10189071;

//----- (1002C490) --------------------------------------------------------
char sub_1002C490()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2545", 2, 2);
      v3 = dword_100B5BE8[v2];
      v4 = dword_100B5BE4[v2];
      v5 = dword_100B5BE0[v2];
      v6 = sub_1001BC80(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100B5BEC[v2]],
             (&off_100B5BF0)[v2 * 4]);
      v7 = sub_1001E640(0, dword_100B5BEC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100B5BEC[v2]],
             (&off_100B5BF0)[v2 * 4]);
      result = sub_1001BFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2545",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B5BE0: using guessed type int dword_100B5BE0[];
// 100B5BE4: using guessed type int dword_100B5BE4[];
// 100B5BE8: using guessed type int dword_100B5BE8[];
// 100B5BEC: using guessed type int dword_100B5BEC[];
// 100B5BF0: using guessed type char *off_100B5BF0;
// 10189071: using guessed type char byte_10189071;

//----- (1002C5F0) --------------------------------------------------------
char sub_1002C5F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2571", 2, 2);
      v3 = word_100B5F54[v2 / 2];
      v4 = word_100B5F52[v2 / 2];
      v5 = word_100B5F50[v2 / 2];
      v6 = sub_1001BC80(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100B5F58[v2 / 4]],
             *(_DWORD *)&off_100B5F5C[v2]);
      v7 = sub_1001E9E0(
             0,
             dword_100B5F58[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2571",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100B5F58[v2 / 4]],
             *(_DWORD *)&off_100B5F5C[v2]);
      result = sub_1001BFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2571",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B5F50: using guessed type __int16 word_100B5F50[];
// 100B5F52: using guessed type __int16 word_100B5F52[];
// 100B5F54: using guessed type __int16 word_100B5F54[];
// 100B5F58: using guessed type int dword_100B5F58[];
// 10189071: using guessed type char byte_10189071;

//----- (1002C750) --------------------------------------------------------
char sub_1002C750()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2597", 2, 2);
      v3 = dword_100B6218[v2];
      v4 = dword_100B6214[v2];
      v5 = dword_100B6210[v2];
      v6 = sub_1001BC80(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100B621C[v2]],
             (&off_100B6220)[v2 * 4]);
      v7 = sub_1001EDE0(0, dword_100B621C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100B621C[v2]],
             (&off_100B6220)[v2 * 4]);
      result = sub_1001BFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2597",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B6210: using guessed type int dword_100B6210[];
// 100B6214: using guessed type int dword_100B6214[];
// 100B6218: using guessed type int dword_100B6218[];
// 100B621C: using guessed type int dword_100B621C[];
// 100B6220: using guessed type char *off_100B6220;
// 10189071: using guessed type char byte_10189071;

//----- (1002C8B0) --------------------------------------------------------
char sub_1002C8B0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2623", 2, 2);
      HIDWORD(v3) = dword_100B6594[v2];
      LODWORD(v3) = dword_100B6590[v2];
      HIDWORD(v4) = dword_100B658C[v2];
      LODWORD(v4) = dword_100B6588[v2];
      HIDWORD(v5) = dword_100B6584[v2];
      LODWORD(v5) = dword_100B6580[v2];
      v6 = sub_1001BC80(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100B6598[v2]],
             *(_DWORD *)&off_100B659C[v2 * 4]);
      v7 = sub_1001F180(0, dword_100B6598[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100B6598[v2]],
             *(_DWORD *)&off_100B659C[v2 * 4]);
      result = sub_1001BFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2623",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B6580: using guessed type int dword_100B6580[];
// 100B6584: using guessed type int dword_100B6584[];
// 100B6588: using guessed type int dword_100B6588[];
// 100B658C: using guessed type int dword_100B658C[];
// 100B6590: using guessed type int dword_100B6590[];
// 100B6594: using guessed type int dword_100B6594[];
// 100B6598: using guessed type int dword_100B6598[];
// 10189071: using guessed type char byte_10189071;

//----- (1002CA20) --------------------------------------------------------
char sub_1002CA20()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2649", 2, 2);
      v3 = byte_100B6B02[v2 * 4];
      v4 = byte_100B6B01[v2 * 4];
      v5 = byte_100B6B00[v2 * 4];
      v6 = sub_1001BC80(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100B6B04[v2]],
             (&off_100B6B08)[v2 * 4]);
      v7 = sub_1001F760(0, dword_100B6B04[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100B6B04[v2]],
             (&off_100B6B08)[v2 * 4]);
      result = sub_1001BFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2649",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B6B04: using guessed type int dword_100B6B04[];
// 100B6B08: using guessed type char *off_100B6B08;
// 10189071: using guessed type char byte_10189071;

//----- (1002CB80) --------------------------------------------------------
char sub_1002CB80()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2675", 2, 2);
      v3 = dword_100B6D18[v2];
      v4 = dword_100B6D14[v2];
      v5 = dword_100B6D10[v2];
      v6 = sub_1001BC80(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100B6D1C[v2]],
             (&off_100B6D20)[v2 * 4]);
      v7 = sub_1001FB50(0, dword_100B6D1C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100B6D1C[v2]],
             (&off_100B6D20)[v2 * 4]);
      result = sub_1001BFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2675",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B6D10: using guessed type int dword_100B6D10[];
// 100B6D14: using guessed type int dword_100B6D14[];
// 100B6D18: using guessed type int dword_100B6D18[];
// 100B6D1C: using guessed type int dword_100B6D1C[];
// 100B6D20: using guessed type char *off_100B6D20;
// 10189071: using guessed type char byte_10189071;

//----- (1002CCE0) --------------------------------------------------------
char sub_1002CCE0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  char *v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_1001B220(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"All Pass Robustness Test Group For Type 'bitmap'");
  v0 = sub_1001BB70(0);
  sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2716", (int)v0);
  sub_1001B220(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10189071 )
  {
    v2 = 0;
    do
    {
      if ( off_100B7084[v2] )
      {
        sub_1001B9E0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100B708C[v2 * 4], 0x100u, &v13);
        sub_1001B9E0((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_100B7084[v2], 0x100u, &v14);
        sub_10025DE0(&v14, &v13);
      }
      if ( byte_100B7080[v2 * 4] )
      {
        sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2741", 2, 2);
        v3 = off_100B7088[v2];
        v4 = *(char **)&off_100B708C[v2 * 4];
        v5 = sub_1001BC80(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100B708C[v2 * 4],
               off_100B7088[v2]);
        v12 = 1;
        v11 = sub_10020300(
                1,
                0,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2745",
                (int)v5,
                (int)v4,
                (int)v3,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_eq_bitmap_rt() call";
        v9 = "2746";
      }
      else
      {
        sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2750", 2, 2);
        v6 = off_100B7088[v2];
        v7 = *(char **)&off_100B708C[v2 * 4];
        v8 = sub_1001BC80(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100B708C[v2 * 4],
               off_100B7088[v2]);
        v12 = 1;
        v11 = sub_10020300(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2754",
                (int)v8,
                (int)v7,
                (int)v6,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_ne_bitmap_rt() call";
        v9 = "2755";
      }
      result = sub_1001BFE0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 4;
    }
    while ( v2 < 20 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2720",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B7084: using guessed type char *off_100B7084[3];
// 100B7088: using guessed type char *off_100B7088[2];
// 10189071: using guessed type char byte_10189071;

//----- (1002CEF0) --------------------------------------------------------
char sub_1002CEF0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1001B220(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_1001BB70(0);
  sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2782", (int)v0);
  sub_1001B220(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10189071 )
  {
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2790", 2, 2);
    v2 = sub_1001BFE0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2791",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1001BFE0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2792",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      0);
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2794", 2, 2);
    v3 = sub_1001BFE0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2795",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1001BFE0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2796",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      0);
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2798", 2, 2);
    v4 = sub_1001BFE0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2799",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1001BFE0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2800",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      0);
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2802", 2, 2);
    v5 = sub_1001BFE0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2803",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1001BFE0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2804",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2786",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10189071: using guessed type char byte_10189071;

//----- (1002D0E0) --------------------------------------------------------
char sub_1002D0E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      v0 = dword_100B70D4[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2844", 2, 2);
        v3 = byte_100B70D1[v2 * 4];
        v4 = byte_100B70D0[v2 * 4];
        v5 = sub_1001BC80(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A65D8[4 * dword_100B70D4[v2]],
               (&off_100B70D8)[v2 * 4]);
        v6 = sub_1001C120(1, dword_100B70D4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v5, v4, v3, 0);
        v7 = sub_1001BC80(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A65D8[4 * dword_100B70D4[v2]],
               (&off_100B70D8)[v2 * 4]);
        LOBYTE(v0) = sub_1001BFE0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1001B220(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2844",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 100B70D4: using guessed type int dword_100B70D4[];
// 100B70D8: using guessed type char *off_100B70D8;
// 10189071: using guessed type char byte_10189071;

//----- (1002D250) --------------------------------------------------------
char sub_1002D250()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2878", 2, 2);
      v3 = dbl_100B7350[v2 / 2];
      v4 = dbl_100B7348[v2 / 2];
      v5 = dbl_100B7340[v2 / 2];
      v6 = sub_1001BC80(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100B7358[v2]],
             *(_DWORD *)&off_100B735C[v2 * 4]);
      v7 = sub_1001C4D0(1, dword_100B7358[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100B7358[v2]],
             *(_DWORD *)&off_100B735C[v2 * 4]);
      result = sub_1001BFE0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2878",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B7340: using guessed type double dbl_100B7340[];
// 100B7348: using guessed type double dbl_100B7348[];
// 100B7350: using guessed type double dbl_100B7350[];
// 100B7358: using guessed type int dword_100B7358[];
// 10189071: using guessed type char byte_10189071;

//----- (1002D3C0) --------------------------------------------------------
char sub_1002D3C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2914", 2, 2);
      v3 = flt_100B7F68[v2];
      v4 = flt_100B7F64[v2];
      v5 = flt_100B7F60[v2];
      v6 = sub_1001BC80(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100B7F6C[v2]],
             (&off_100B7F70)[v2 * 4]);
      v7 = sub_1001C920(1, dword_100B7F6C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100B7F6C[v2]],
             (&off_100B7F70)[v2 * 4]);
      result = sub_1001BFE0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2914",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B7F60: using guessed type float flt_100B7F60[];
// 100B7F64: using guessed type float flt_100B7F64[];
// 100B7F68: using guessed type float flt_100B7F68[];
// 100B7F6C: using guessed type int dword_100B7F6C[];
// 100B7F70: using guessed type char *off_100B7F70;
// 10189071: using guessed type char byte_10189071;

//----- (1002D520) --------------------------------------------------------
char sub_1002D520()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1001B220(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1001BB70(0);
  sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2936", (int)v0);
  sub_1001B220(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10189071 )
  {
    sub_10020600(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2944",
      (int)"Check ptr for equality",
      (int)sub_1002D520,
      (int)sub_1002D520,
      0);
    sub_10020600(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2945",
      (int)"Check ptr for inequality",
      (int)sub_1002D520,
      0,
      0);
    result = sub_10020600(
               1,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2946",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1002D520,
               0);
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2940",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10189071: using guessed type char byte_10189071;

//----- (1002D610) --------------------------------------------------------
char sub_1002D610()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2973", 2, 2);
      v3 = dword_100B8700[v2];
      v4 = dword_100B86FC[v2];
      v5 = dword_100B86F8[v2];
      v6 = sub_1001BC80(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100B8704[v2]],
             *(_DWORD *)&off_100B8708[v2 * 4]);
      v7 = sub_1001CDE0(1, dword_100B8704[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100B8704[v2]],
             *(_DWORD *)&off_100B8708[v2 * 4]);
      result = sub_1001BFE0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2973",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B86F8: using guessed type int dword_100B86F8[];
// 100B86FC: using guessed type int dword_100B86FC[];
// 100B8700: using guessed type int dword_100B8700[];
// 100B8704: using guessed type int dword_100B8704[];
// 10189071: using guessed type char byte_10189071;

//----- (1002D770) --------------------------------------------------------
char sub_1002D770()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"2999", 2, 2);
      v3 = word_100B8E94[v2 / 2];
      v4 = word_100B8E92[v2 / 2];
      v5 = word_100B8E90[v2 / 2];
      v6 = sub_1001BC80(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100B8E98[v2 / 4]],
             *(_DWORD *)&off_100B8E9C[v2]);
      v7 = sub_1001D1A0(
             1,
             dword_100B8E98[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2999",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100B8E98[v2 / 4]],
             *(_DWORD *)&off_100B8E9C[v2]);
      result = sub_1001BFE0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2999",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B8E90: using guessed type __int16 word_100B8E90[];
// 100B8E92: using guessed type __int16 word_100B8E92[];
// 100B8E94: using guessed type __int16 word_100B8E94[];
// 100B8E98: using guessed type int dword_100B8E98[];
// 10189071: using guessed type char byte_10189071;

//----- (1002D8D0) --------------------------------------------------------
char sub_1002D8D0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"3025", 2, 2);
      v3 = dword_100B94A8[v2];
      v4 = dword_100B94A4[v2];
      v5 = dword_100B94A0[v2];
      v6 = sub_1001BC80(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100B94AC[v2]],
             (&off_100B94B0)[v2 * 4]);
      v7 = sub_1001D5A0(1, dword_100B94AC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100B94AC[v2]],
             (&off_100B94B0)[v2 * 4]);
      result = sub_1001BFE0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3025",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B94A0: using guessed type int dword_100B94A0[];
// 100B94A4: using guessed type int dword_100B94A4[];
// 100B94A8: using guessed type int dword_100B94A8[];
// 100B94AC: using guessed type int dword_100B94AC[];
// 100B94B0: using guessed type char *off_100B94B0;
// 10189071: using guessed type char byte_10189071;

//----- (1002DA30) --------------------------------------------------------
char sub_1002DA30()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"3051", 2, 2);
      HIDWORD(v3) = dword_100B9C4C[v2];
      LODWORD(v3) = dword_100B9C48[v2];
      HIDWORD(v4) = dword_100B9C44[v2];
      LODWORD(v4) = dword_100B9C40[v2];
      HIDWORD(v5) = dword_100B9C3C[v2];
      LODWORD(v5) = dword_100B9C38[v2];
      v6 = sub_1001BC80(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100B9C50[v2]],
             *(_DWORD *)&off_100B9C54[v2 * 4]);
      v7 = sub_1001D960(1, dword_100B9C50[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100B9C50[v2]],
             *(_DWORD *)&off_100B9C54[v2 * 4]);
      result = sub_1001BFE0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3051",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B9C38: using guessed type int dword_100B9C38[];
// 100B9C3C: using guessed type int dword_100B9C3C[];
// 100B9C40: using guessed type int dword_100B9C40[];
// 100B9C44: using guessed type int dword_100B9C44[];
// 100B9C48: using guessed type int dword_100B9C48[];
// 100B9C4C: using guessed type int dword_100B9C4C[];
// 100B9C50: using guessed type int dword_100B9C50[];
// 10189071: using guessed type char byte_10189071;

//----- (1002DBA0) --------------------------------------------------------
char sub_1002DBA0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"3077", 2, 2);
      v3 = byte_100BA85A[v2 * 4];
      v4 = byte_100BA859[v2 * 4];
      v5 = byte_100BA858[v2 * 4];
      v6 = sub_1001BC80(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100BA85C[v2]],
             (&off_100BA860)[v2 * 4]);
      v7 = sub_1001DEA0(1, dword_100BA85C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100BA85C[v2]],
             (&off_100BA860)[v2 * 4]);
      result = sub_1001BFE0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3077",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BA85C: using guessed type int dword_100BA85C[];
// 100BA860: using guessed type char *off_100BA860;
// 10189071: using guessed type char byte_10189071;

//----- (1002DD00) --------------------------------------------------------
char sub_1002DD00()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"3103", 2, 2);
      v3 = dword_100BACF0[v2];
      v4 = dword_100BACEC[v2];
      v5 = dword_100BACE8[v2];
      v6 = sub_1001BC80(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100BACF4[v2]],
             *(_DWORD *)&off_100BACF8[v2 * 4]);
      v7 = sub_1001E280(1, dword_100BACF4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100BACF4[v2]],
             *(_DWORD *)&off_100BACF8[v2 * 4]);
      result = sub_1001BFE0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3103",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BACE8: using guessed type int dword_100BACE8[];
// 100BACEC: using guessed type int dword_100BACEC[];
// 100BACF0: using guessed type int dword_100BACF0[];
// 100BACF4: using guessed type int dword_100BACF4[];
// 10189071: using guessed type char byte_10189071;

//----- (1002DE60) --------------------------------------------------------
char sub_1002DE60()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1001B220(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_1001BB70(0);
  sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3127", (int)v0);
  sub_1001B220(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10189071 )
  {
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"3135", 2, 2);
    v2 = sub_100206B0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3136",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"\" ) data comparison",
           (const char *)&unk_1005E69C,
           (const char *)&unk_1005E69C,
           0);
    sub_1001BFE0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3137",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"3139", 2, 2);
    v3 = sub_100206B0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3140",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1001BFE0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3141",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"3143", 2, 2);
    v4 = sub_100206B0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3144",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_1005E69C,
           0);
    sub_1001BFE0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3145",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"3147", 2, 2);
    v5 = sub_100206B0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3148",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1001BFE0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3149",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3131",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10189071: using guessed type char byte_10189071;

//----- (1002E060) --------------------------------------------------------
char sub_1002E060()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"3176", 2, 2);
      v3 = dword_100BB488[v2];
      v4 = dword_100BB484[v2];
      v5 = dword_100BB480[v2];
      v6 = sub_1001BC80(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100BB48C[v2]],
             (&off_100BB490)[v2 * 4]);
      v7 = sub_1001E640(1, dword_100BB48C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100BB48C[v2]],
             (&off_100BB490)[v2 * 4]);
      result = sub_1001BFE0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3176",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BB480: using guessed type int dword_100BB480[];
// 100BB484: using guessed type int dword_100BB484[];
// 100BB488: using guessed type int dword_100BB488[];
// 100BB48C: using guessed type int dword_100BB48C[];
// 100BB490: using guessed type char *off_100BB490;
// 10189071: using guessed type char byte_10189071;

//----- (1002E1C0) --------------------------------------------------------
char sub_1002E1C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"3202", 2, 2);
      v3 = word_100BB7F4[v2 / 2];
      v4 = word_100BB7F2[v2 / 2];
      v5 = word_100BB7F0[v2 / 2];
      v6 = sub_1001BC80(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100BB7F8[v2 / 4]],
             *(_DWORD *)&off_100BB7FC[v2]);
      v7 = sub_1001E9E0(
             1,
             dword_100BB7F8[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"3202",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100BB7F8[v2 / 4]],
             *(_DWORD *)&off_100BB7FC[v2]);
      result = sub_1001BFE0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3202",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BB7F0: using guessed type __int16 word_100BB7F0[];
// 100BB7F2: using guessed type __int16 word_100BB7F2[];
// 100BB7F4: using guessed type __int16 word_100BB7F4[];
// 100BB7F8: using guessed type int dword_100BB7F8[];
// 10189071: using guessed type char byte_10189071;

//----- (1002E320) --------------------------------------------------------
char sub_1002E320()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"3228", 2, 2);
      v3 = dword_100BBAB8[v2];
      v4 = dword_100BBAB4[v2];
      v5 = dword_100BBAB0[v2];
      v6 = sub_1001BC80(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100BBABC[v2]],
             (&off_100BBAC0)[v2 * 4]);
      v7 = sub_1001EDE0(1, dword_100BBABC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100BBABC[v2]],
             (&off_100BBAC0)[v2 * 4]);
      result = sub_1001BFE0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3228",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BBAB0: using guessed type int dword_100BBAB0[];
// 100BBAB4: using guessed type int dword_100BBAB4[];
// 100BBAB8: using guessed type int dword_100BBAB8[];
// 100BBABC: using guessed type int dword_100BBABC[];
// 100BBAC0: using guessed type char *off_100BBAC0;
// 10189071: using guessed type char byte_10189071;

//----- (1002E480) --------------------------------------------------------
char sub_1002E480()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"3254", 2, 2);
      HIDWORD(v3) = dword_100BBE34[v2];
      LODWORD(v3) = dword_100BBE30[v2];
      HIDWORD(v4) = dword_100BBE2C[v2];
      LODWORD(v4) = dword_100BBE28[v2];
      HIDWORD(v5) = dword_100BBE24[v2];
      LODWORD(v5) = dword_100BBE20[v2];
      v6 = sub_1001BC80(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100BBE38[v2]],
             *(_DWORD *)&off_100BBE3C[v2 * 4]);
      v7 = sub_1001F180(1, dword_100BBE38[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100BBE38[v2]],
             *(_DWORD *)&off_100BBE3C[v2 * 4]);
      result = sub_1001BFE0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3254",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BBE20: using guessed type int dword_100BBE20[];
// 100BBE24: using guessed type int dword_100BBE24[];
// 100BBE28: using guessed type int dword_100BBE28[];
// 100BBE2C: using guessed type int dword_100BBE2C[];
// 100BBE30: using guessed type int dword_100BBE30[];
// 100BBE34: using guessed type int dword_100BBE34[];
// 100BBE38: using guessed type int dword_100BBE38[];
// 10189071: using guessed type char byte_10189071;

//----- (1002E5F0) --------------------------------------------------------
char sub_1002E5F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"3280", 2, 2);
      v3 = byte_100BC3A2[v2 * 4];
      v4 = byte_100BC3A1[v2 * 4];
      v5 = byte_100BC3A0[v2 * 4];
      v6 = sub_1001BC80(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100BC3A4[v2]],
             (&off_100BC3A8)[v2 * 4]);
      v7 = sub_1001F760(1, dword_100BC3A4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100BC3A4[v2]],
             (&off_100BC3A8)[v2 * 4]);
      result = sub_1001BFE0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3280",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BC3A4: using guessed type int dword_100BC3A4[];
// 100BC3A8: using guessed type char *off_100BC3A8;
// 10189071: using guessed type char byte_10189071;

//----- (1002E750) --------------------------------------------------------
char sub_1002E750()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10189071 )
  {
    sub_1001B220(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_1001BB70(0);
    sub_1001B220(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v1);
    sub_1001B220(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1001BC60(0);
    v2 = 0;
    do
    {
      sub_1001BB90((int)"..\\lib\\utf\\utf_validate.c", (int)"3306", 2, 2);
      v3 = dword_100BC5B8[v2];
      v4 = dword_100BC5B4[v2];
      v5 = dword_100BC5B0[v2];
      v6 = sub_1001BC80(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A65D8[4 * dword_100BC5BC[v2]],
             (&off_100BC5C0)[v2 * 4]);
      v7 = sub_1001FB50(1, dword_100BC5BC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001BC80(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A65D8[4 * dword_100BC5BC[v2]],
             (&off_100BC5C0)[v2 * 4]);
      result = sub_1001BFE0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1001B220(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3306",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BC5B0: using guessed type int dword_100BC5B0[];
// 100BC5B4: using guessed type int dword_100BC5B4[];
// 100BC5B8: using guessed type int dword_100BC5B8[];
// 100BC5BC: using guessed type int dword_100BC5BC[];
// 100BC5C0: using guessed type char *off_100BC5C0;
// 10189071: using guessed type char byte_10189071;

//----- (1002E8B0) --------------------------------------------------------
char **sub_1002E8B0()
{
  return off_100A7CC4;
}
// 100A7CC4: using guessed type char *off_100A7CC4[3];

//----- (1002E8C0) --------------------------------------------------------
int __cdecl sub_1002E8C0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = a3;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 88) = a2;
  return result;
}

//----- (1002E8E0) --------------------------------------------------------
int (__cdecl *__usercall sub_1002E8E0@<eax>(int a1@<eax>, int a2@<ecx>))(int)
{
  int (__cdecl *result)(int); // eax@1

  result = *(int (__cdecl **)(int))(a1 + 88);
  if ( result )
    result = (int (__cdecl *)(int))result(a2);
  return result;
}

//----- (1002E8F0) --------------------------------------------------------
int __usercall sub_1002E8F0@<eax>(unsigned __int8 *a1@<eax>, int a2)
{
  signed int v2; // edi@1
  int v3; // ebp@1
  unsigned __int8 *v4; // ebx@1
  unsigned __int8 v5; // al@2
  int v6; // esi@4

  v2 = 0;
  v3 = a2 + 92;
  *(_BYTE *)(a2 + 92) = 0;
  v4 = a1;
  do
  {
    v5 = *v4;
    if ( !*v4 )
      break;
    switch ( v5 )
    {
      case 0x22u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1869967654;
        *(_WORD *)(v6 + 4) = 15220;
        *(_BYTE *)(v6 + 6) = 0;
        break;
      case 0x3Cu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997485606;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x3Eu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997484326;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x26u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1886216486;
        *(_WORD *)(v6 + 4) = 59;
        break;
      case 7u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 24924;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 8u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 25180;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xCu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 26204;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xAu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 28252;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xDu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29276;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 9u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29788;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xBu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 30300;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      default:
        v6 = v2 + v3;
        if ( isprint(v5) )
        {
          *(_BYTE *)v6 = *v4;
          *(_BYTE *)(v2 + a2 + 93) = 0;
        }
        else
        {
          _snprintf((char *)(v2 + v3), 512 - v2, "\\x%x", *v4);
          *(_BYTE *)(a2 + 603) = 0;
        }
        break;
    }
    v2 += strlen((const char *)v6);
    ++v4;
  }
  while ( v2 < 502 );
  return a2 + 92;
}

//----- (1002EB20) --------------------------------------------------------
int (__cdecl *__cdecl sub_1002EB20(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_1002E8E0(a1, (int)" ");
  sub_1002E8E0(a1, a2);
  sub_1002E8E0(a1, (int)&unk_100C0814);
  v3 = sub_1002E8F0(a3, a1);
  sub_1002E8E0(a1, v3);
  return sub_1002E8E0(a1, (int)&unk_100C0810);
}

//----- (1002EB70) --------------------------------------------------------
int (__cdecl *__cdecl sub_1002EB70(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_1002E8E0(a1, (int)" ");
  sub_1002E8E0(a1, a2);
  sub_1002E8E0(a1, (int)&unk_100C081C);
  v3 = sub_1002E8F0(a3, a1);
  sub_1002E8E0(a1, v3);
  return sub_1002E8E0(a1, (int)&unk_100C0818);
}

//----- (1002EBC0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1002EBC0(int a1, unsigned __int8 *a2))(int)
{
  int (__cdecl *result)(int); // eax@1
  int v3; // eax@4

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      sub_1002E8E0(a1, (int)&unk_100C0820);
      *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    }
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 7) = 1;
    v3 = sub_1002E8F0(a2, a1);
    result = sub_1002E8E0(a1, v3);
  }
  return result;
}

//----- (1002EC10) --------------------------------------------------------
int (__cdecl *__cdecl sub_1002EC10(int a1))(int)
{
  int (__cdecl *result)(int); // eax@1
  void *v2; // ecx@3
  bool v3; // zf@7

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      v2 = &unk_100C0828;
    }
    else
    {
      if ( !*(_BYTE *)(a1 + 8 * (_DWORD)result - 7) )
        sub_1002E8E0(a1, dword_100C077C[(signed int)result]);
      sub_1002E8E0(a1, (int)&unk_100C0824);
      sub_1002E8E0(a1, *(_DWORD *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 4));
      v2 = &unk_100C0820;
    }
    result = sub_1002E8E0(a1, (int)v2);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    v3 = (*(_DWORD *)(a1 + 80))-- == 1;
    if ( v3 )
      result = sub_1002E8E0(a1, (int)&word_1009B7AC);
  }
  return result;
}
// 1009B7AC: using guessed type __int16 word_1009B7AC;
// 100C077C: using guessed type int dword_100C077C[];

//----- (1002EC90) --------------------------------------------------------
int __cdecl sub_1002EC90(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@4

  v2 = *(_DWORD *)(a1 + 80);
  if ( v2 > 0 && *(_BYTE *)(a1 + 8 * v2 - 8) )
  {
    sub_1002E8E0(a1, (int)&unk_100C0820);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
  }
  sub_1002E8E0(a1, *((_DWORD *)&off_100C0780 + *(_DWORD *)(a1 + 80) + *(_DWORD *)(a1 + 84)));
  sub_1002E8E0(a1, (int)&unk_100C082C);
  sub_1002E8E0(a1, a2);
  *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80)) = 1;
  result = *(_DWORD *)(a1 + 80);
  *(_BYTE *)(a1 + 8 * result + 1) = 0;
  *(_DWORD *)(a1 + 8 * (*(_DWORD *)(a1 + 80))++ + 4) = a2;
  return result;
}

//----- (1002ED10) --------------------------------------------------------
int (__cdecl *__cdecl sub_1002ED10(int a1, unsigned __int8 *a2, char a3))(int)
{
  int v3; // eax@2
  int (__cdecl *result)(int); // eax@2

  if ( a3 )
  {
    v3 = sub_1002E8F0(a2, a1);
    sub_1002E8E0(a1, v3);
    result = sub_1002E8E0(a1, (int)&word_1009B7AC);
  }
  else
  {
    sub_1002E8E0(a1, (int)a2);
    result = sub_1002E8E0(a1, (int)&word_1009B7AC);
  }
  return result;
}
// 1009B7AC: using guessed type __int16 word_1009B7AC;

//----- (1002ED60) --------------------------------------------------------
int (__cdecl *__cdecl sub_1002ED60(int a1, int a2, unsigned __int8 *a3))(int)
{
  sub_1002EC90(a1, a2);
  if ( a3 && *a3 )
    sub_1002EBC0(a1, a3);
  return sub_1002EC10(a1);
}

//----- (1002EDA0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1002EDA0(int a1, int a2, int a3))(int)
{
  char v4; // [sp+8h] [bp-24h]@1
  char v5; // [sp+27h] [bp-5h]@1

  _snprintf(&v4, 0x20u, "%d", a3);
  v5 = 0;
  return sub_1002ED60(a1, a2, (unsigned __int8 *)&v4);
}

//----- (1002EE00) --------------------------------------------------------
int __cdecl sub_1002EE00(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10016EA0(&a1, 1u, (int)&unk_100C22A0, 8, 67, 0);
  if ( v1 )
  {
    result = dword_100C22A4[2 * v1];
  }
  else
  {
    sub_1000D740("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 1932, 0, 0);
    result = 0;
  }
  return result;
}
// 100C22A4: using guessed type int dword_100C22A4[];

//----- (1002EE50) --------------------------------------------------------
bool __cdecl sub_1002EE50(unsigned __int8 a1, char a2, unsigned int a3)
{
  int v3; // eax@1
  bool result; // al@5

  v3 = sub_10016EA0(&a2, 4u, (int)&dword_100C33A8, 12, 3, 3);
  if ( a3 < 0xFFFFFFC2 && a3 && v3 < 3 && a1 < 2u )
  {
    result = sub_10031BF0((unsigned __int16)word_100C33AC[a1 + 6 * v3], a3, (unsigned __int16)word_100C33B0[6 * v3]) == 0;
  }
  else
  {
    sub_1000D740("..\\lib\\acl\\iop\\gtx\\iop_gtx_intf.c", 254, 0, 0);
    result = 0;
  }
  return result;
}
// 100C33A8: using guessed type int dword_100C33A8;
// 100C33AC: using guessed type __int16 word_100C33AC[];
// 100C33B0: using guessed type __int16 word_100C33B0[];

//----- (1002EEE0) --------------------------------------------------------
bool __cdecl sub_1002EEE0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6)
{
  int v6; // eax@1
  int v7; // eax@7
  unsigned int v8; // edx@7
  int v9; // eax@7
  bool result; // al@9
  unsigned __int8 v11; // [sp+4h] [bp-4h]@1

  v11 = sub_1002EF80(a1);
  v6 = sub_10016EA0(&a3, 1u, (int)&unk_100C33CC, 8, 3, 3);
  if ( v6 < 3 )
    v6 = sub_10016EA0(&dword_100C33D0[2 * v6], 4u, (int)&dword_100C33A8, 12, 3, 3);
  if ( a5 < 0xFFFFFFC2
    && a5
    && v6 < 3
    && v11 < 2u
    && (v7 = 6 * v6, v8 = (unsigned __int16)word_100C33B0[v7], v9 = 2 * v7, a6 >= v8)
    && a2 == 1 )
  {
    result = sub_1002EE50(v11, *(int *)((char *)&dword_100C33A8 + v9), a5);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100C33A8: using guessed type int dword_100C33A8;
// 100C33B0: using guessed type __int16 word_100C33B0[];

//----- (1002EF80) --------------------------------------------------------
char __cdecl sub_1002EF80(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xA:
    case 0x30:
      result = 0;
      break;
    case 0xB:
    case 0x31:
      result = 1;
      break;
    default:
      sub_1000D740("..\\lib\\acl\\iop\\iop_xpdr_cnfg_utl.c", 155, 0, 0);
      result = 2;
      break;
  }
  return result;
}

//----- (1002F000) --------------------------------------------------------
char __cdecl sub_1002F000(char a1, int a2)
{
  char v2; // cl@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // eax@1
  int v10; // ecx@1
  bool v11; // zf@1
  int v12; // eax@3
  int v13; // ecx@3
  char v14; // dl@3
  __int16 v15; // ax@5
  char v16; // dl@5
  int v18; // [sp+4h] [bp-58h]@1
  char v19; // [sp+8h] [bp-54h]@1
  __int64 v20; // [sp+Ch] [bp-50h]@1
  int v21; // [sp+14h] [bp-48h]@1
  int v22; // [sp+18h] [bp-44h]@1
  char v23; // [sp+1Ch] [bp-40h]@1
  __int16 v24; // [sp+1Eh] [bp-3Eh]@1
  int v25; // [sp+20h] [bp-3Ch]@4
  int v26; // [sp+24h] [bp-38h]@4
  char v27; // [sp+28h] [bp-34h]@4
  char v28; // [sp+2Ah] [bp-32h]@1
  char v29; // [sp+2Bh] [bp-31h]@1
  int v30; // [sp+2Ch] [bp-30h]@1
  int v31; // [sp+30h] [bp-2Ch]@1
  int v32; // [sp+34h] [bp-28h]@1
  int v33; // [sp+38h] [bp-24h]@1
  int v34; // [sp+3Ch] [bp-20h]@1
  int v35; // [sp+40h] [bp-1Ch]@1
  int v36; // [sp+44h] [bp-18h]@1
  int v37; // [sp+48h] [bp-14h]@1
  int v38; // [sp+4Ch] [bp-10h]@1
  int v39; // [sp+50h] [bp-Ch]@1
  int v40; // [sp+54h] [bp-8h]@1

  memset(&v23, 0, 0x3Cu);
  v20 = 0i64;
  v21 = 0;
  v22 = 0;
  v18 = 0;
  v19 = 0;
  sub_10024060(a1, (int)&v23);
  v2 = v28;
  v3 = v29;
  *(_WORD *)a2 = v24;
  *(_DWORD *)(a2 + 28) = v33;
  v4 = v36;
  *(_BYTE *)(a2 + 12) = v2;
  *(_DWORD *)(a2 + 32) = v34;
  v5 = v37;
  *(_BYTE *)(a2 + 13) = v3;
  *(_DWORD *)(a2 + 36) = v35;
  v6 = v38;
  *(_DWORD *)(a2 + 40) = v4;
  v7 = v30;
  *(_DWORD *)(a2 + 44) = v5;
  v8 = v31;
  *(_DWORD *)(a2 + 16) = v7;
  v9 = v39;
  *(_DWORD *)(a2 + 20) = v8;
  v10 = v40;
  *(_DWORD *)(a2 + 48) = v6;
  v11 = BYTE3(v30) == 1;
  *(_DWORD *)(a2 + 24) = v32;
  *(_DWORD *)(a2 + 52) = v9;
  *(_DWORD *)(a2 + 56) = v10;
  if ( !v11 || sub_10031BF0(2105, (int)&v20, 16) )
  {
    v12 = v25;
    v13 = v26;
    v14 = v27;
  }
  else
  {
    v13 = *(_DWORD *)((char *)&v20 + 6);
    v12 = *(_DWORD *)((char *)&v20 + 2);
    v14 = BYTE2(v21);
  }
  *(_DWORD *)(a2 + 2) = v12;
  *(_DWORD *)(a2 + 6) = v13;
  *(_BYTE *)(a2 + 10) = v14;
  sub_10024080((int)&v18);
  LOBYTE(v15) = v19;
  v16 = v18;
  v11 = (v19 & 1) == 0;
  *(_BYTE *)(a2 + 63) = BYTE3(v18);
  *(_BYTE *)(a2 + 60) = v16;
  *(_BYTE *)(a2 + 64) = 0;
  if ( !v11 )
    *(_BYTE *)(a2 + 64) = 1;
  *(_BYTE *)(a2 + 65) = 0;
  if ( v15 & 4 )
    *(_BYTE *)(a2 + 65) = 1;
  *(_BYTE *)(a2 + 66) = 0;
  if ( v15 & 2 )
  {
    v15 = *(_WORD *)((char *)&v18 + 1);
    *(_BYTE *)(a2 + 66) = 1;
    *(_WORD *)(a2 + 61) = v15;
  }
  else
  {
    *(_WORD *)(a2 + 61) = *(_WORD *)((char *)&v18 + 1);
  }
  return v15;
}

//----- (1002F170) --------------------------------------------------------
int __usercall sub_1002F170@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@1
  int v5[10]; // [sp+1Ch] [bp-2Ch]@1

  sub_1002F000(a1, (int)&v4);
  result = v5[a3];
  *a2 = result;
  return result;
}
// 1002F170: using guessed type int var_2C[10];

//----- (1002F1B0) --------------------------------------------------------
int __usercall sub_1002F1B0@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@3
  int v5[4]; // [sp+34h] [bp-14h]@3

  result = a3;
  if ( (unsigned __int8)a3 < 2u && a1 < 2u )
  {
    sub_1002F000(a3, (int)&v4);
    result = v5[a1];
    *a2 = result;
  }
  return result;
}
// 1002F1B0: using guessed type int var_14[4];

//----- (1002F1F0) --------------------------------------------------------
signed int sub_1002F1F0()
{
  return sub_100327D0((int)&off_100C5270);
}
// 100C5270: using guessed type char *off_100C5270;

//----- (1002F200) --------------------------------------------------------
char __cdecl sub_1002F200(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  int v3; // esi@2
  char result; // al@2

  if ( (unsigned __int8)sub_1002F1F0() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_101EFB4C + 4 * v3 + 29);
    *(_BYTE *)a3 = *(_BYTE *)(dword_101EFB4C + 4 * v3 + 28);
    result = *(_BYTE *)(a2 + 2 * (3 * a1 + 72) + dword_101EFB4C);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101EFB4C: using guessed type int dword_101EFB4C;

//----- (1002F260) --------------------------------------------------------
char __cdecl sub_1002F260(char a1, void *a2)
{
  int v2; // edx@4
  char result; // al@20

  if ( (unsigned __int8)sub_1002F1F0() )
  {
    if ( (sub_100240A0(a1)
       || *(_BYTE *)(dword_101EFB4C + 2 * (3 * (unsigned __int8)a1 + 72))
       && (v2 = dword_101EFB4C + 6 * (unsigned __int8)a1, *(_BYTE *)(dword_101EFB4C + 6 * (unsigned __int8)a1 + 145))
       && *(_BYTE *)(v2 + 146)
       && *(_BYTE *)(v2 + 147)
       && *(_BYTE *)(v2 + 148)
       && *(_BYTE *)(v2 + 149)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101EFB4C + 142)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101EFB4C + 170)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101EFB4C + 168)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101EFB4C + 166)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101EFB4C + 172)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101EFB4C + 174)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101EFB4C + 176))
      && *(_BYTE *)(dword_101EFB4C + 2 * (unsigned __int8)a1 + 158)
      && *(_BYTE *)(dword_101EFB4C + 2 * (unsigned __int8)a1 + 159)
      && *(_BYTE *)((unsigned __int8)a1 + dword_101EFB4C + 156)
      && *(_BYTE *)((unsigned __int8)a1 + dword_101EFB4C + 162) )
    {
      qmemcpy(a2, (const void *)(dword_101EFB4C + 68 * (unsigned __int8)a1), 0x44u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101EFB4C: using guessed type int dword_101EFB4C;

//----- (1002F380) --------------------------------------------------------
char __cdecl sub_1002F380(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@2
  char result; // al@2

  if ( (unsigned __int8)sub_1002F1F0() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 2) = *(_BYTE *)(dword_101EFB4C + 4 * v3 + 54);
    *(_BYTE *)a3 = *(_BYTE *)(dword_101EFB4C + 4 * v3 + 52);
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_101EFB4C + 4 * v3 + 53);
    *(_BYTE *)(a3 + 3) = *(_BYTE *)(dword_101EFB4C + 4 * v3 + 55);
    result = *(_BYTE *)(a2 + 2 * a1 + 158 + dword_101EFB4C);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101EFB4C: using guessed type int dword_101EFB4C;

//----- (1002F400) --------------------------------------------------------
char __cdecl sub_1002F400(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6)
{
  char v6; // cl@2
  char result; // al@7
  unsigned __int16 v8; // ax@13

  if ( (_BYTE)a1 == 10 )
  {
    v6 = 0;
  }
  else
  {
    if ( (_BYTE)a1 != 11 )
    {
      sub_1000D740("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 703, 0, 0);
      return 0;
    }
    v6 = 1;
  }
  LOBYTE(a1) = v6;
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        if ( a2 )
        {
          sub_1002F1B0(*a4, a5, a1);
          result = 1;
        }
        else
        {
          result = sub_1002F380(v6, *a4, (int)a5);
        }
      }
      else
      {
        sub_1000D740("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 718, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        v8 = *a4;
        if ( a2 )
        {
          sub_1002F170(v6, a5, v8);
          result = 1;
        }
        else
        {
          result = sub_1002F200(v6, v8, (int)a5);
        }
      }
      else
      {
        sub_1000D740("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 750, 0, 0);
        result = 0;
      }
      break;
    case 0xB:
    case 0x12:
    case 0x1C:
      if ( a6 >= 0x44 )
      {
        if ( a2 )
        {
          sub_1002F000(v6, (int)a5);
          result = 1;
        }
        else
        {
          result = sub_1002F260(v6, a5);
        }
      }
      else
      {
        sub_1000D740("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 784, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_1000D740("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 809, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1002F5B0) --------------------------------------------------------
int __cdecl sub_1002F5B0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

//----- (1002F5D0) --------------------------------------------------------
char __cdecl sub_1002F5D0(char a1, char a2, char a3, char a4, char a5, int a6, char a7, __int16 a8, char *a9)
{
  char *v9; // eax@1
  char v10; // cl@2
  __int16 v12; // [sp+0h] [bp-52Ch]@1
  char v13; // [sp+4h] [bp-528h]@1
  char v14; // [sp+5h] [bp-527h]@1
  char v15; // [sp+6h] [bp-526h]@1
  char v16; // [sp+7h] [bp-525h]@1
  char v17; // [sp+8h] [bp-524h]@1
  char v18; // [sp+9h] [bp-523h]@1
  __int16 v19; // [sp+Ah] [bp-522h]@1
  int v20; // [sp+Ch] [bp-520h]@1
  char v21[1300]; // [sp+14h] [bp-518h]@2

  memset(&v12, 0, 0x528u);
  v15 = a4;
  v20 = a6;
  v16 = a3;
  v13 = a1;
  v9 = a9;
  v17 = a5;
  v14 = a2;
  v12 = -32708;
  v18 = a7;
  v19 = a8;
  if ( a9 )
  {
    do
    {
      v10 = *v9;
      v9[v21 - a9] = *v9;
      ++v9;
    }
    while ( v10 );
  }
  return sub_10024A80((int)&v12);
}
// 1002F5D0: using guessed type char var_518[1300];

//----- (1002F6A0) --------------------------------------------------------
char __cdecl sub_1002F6A0(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  if ( a1 >= 0x319u )
  {
    sub_1000D740("..\\lib\\acl\\iop\\dscrt\\iop_dscrt_data_tbl_utl.c", 115, 0, 0);
    return 0;
  }
  if ( a2 >= 3u )
    return 0;
  *a3 = byte_100CD6C8[8 * a1];
  *a4 = word_100CD6CA[a2 + 4 * a1];
  return 1;
}
// 100CD6CA: using guessed type __int16 word_100CD6CA[];

//----- (1002F700) --------------------------------------------------------
int __cdecl sub_1002F700(char a1, char a2)
{
  int v2; // esi@1
  int result; // eax@4

  v2 = dword_100C65F4[2 * sub_10016EA0(&a1, 1u, (int)&unk_100C65F0, 8, 3, 3)];
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = v2 + dword_100C6634[2 * sub_10016EA0(&a2, 1u, (int)&unk_100C6630, 8, 6, 6)];
    }
    else if ( a1 == 2 )
    {
      result = v2 + dword_100C6664[2 * sub_10016EA0(&a2, 1u, (int)&unk_100C6660, 8, 5, 5)];
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = v2 + dword_100C660C[2 * sub_10016EA0(&a2, 1u, (int)&unk_100C6608, 8, 5, 5)];
  }
  return result;
}
// 100C65F4: using guessed type int dword_100C65F4[];
// 100C660C: using guessed type int dword_100C660C[];
// 100C6634: using guessed type int dword_100C6634[];
// 100C6664: using guessed type int dword_100C6664[];

//----- (1002F7B0) --------------------------------------------------------
bool __usercall sub_1002F7B0@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3)
{
  return a2 == 7 && a3 >= (unsigned __int8)byte_100D0427[44 * a1] - (unsigned __int8)byte_100D0422[44 * a1];
}

//----- (1002F7E0) --------------------------------------------------------
char __usercall sub_1002F7E0@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6)
{
  int v6; // eax@2
  char result; // al@3
  int v8; // eax@4

  if ( sub_1002F7B0(a1, a4, a5) )
  {
    v6 = a3
       + sub_1002F700(a1, 6)
       + 36 * (a5 + (unsigned __int8)byte_100D0422[44 * a1] - (unsigned __int8)byte_100D0427[44 * a1]);
    if ( *(_BYTE *)(v6 + 2) == 6 )
    {
      memcpy_0(a6, (const void *)(v6 + 4), a2);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v8 = sub_1002F700(a1, a4);
    memcpy_0(a6, (const void *)(a3 + v8 + a2 * a5), a2);
    result = 1;
  }
  return result;
}

//----- (1002F880) --------------------------------------------------------
char __cdecl sub_1002F880(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10024DD0(a1);
  sub_10031C10(v5, (int)&v7, 3684);
  return sub_1002F7E0(a2, 0x2Cu, (int)&v7, a3, a4, a5);
}

//----- (1002F900) --------------------------------------------------------
char __cdecl sub_1002F900(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10024DD0(a1);
  sub_10031C10(v5, (int)&v7, 3684);
  return sub_1002F7E0(a2, 3u, (int)&v7, a3, a4, a5);
}

//----- (1002F980) --------------------------------------------------------
char __cdecl sub_1002F980(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10024DD0(a1);
  sub_10031C10(v5, (int)&v7, 3684);
  return sub_1002F7E0(a2, 0x24u, (int)&v7, a3, a4, a5);
}

//----- (1002FA00) --------------------------------------------------------
char __cdecl sub_1002FA00(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10024DD0(a1);
  sub_10031C10(v5, (int)&v7, 3684);
  return sub_1002F7E0(a2, 0xCu, (int)&v7, a3, a4, a5);
}

//----- (1002FA80) --------------------------------------------------------
char __cdecl sub_1002FA80(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xC:
    case 0x3F:
      result = 0;
      break;
    case 0xD:
    case 0x40:
      result = 1;
      break;
    case 0xE:
    case 0x41:
      result = 2;
      break;
    case 0x2A:
    case 0x42:
      result = 3;
      break;
    default:
      sub_1000D740("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_utl.c", 139, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1002FB20) --------------------------------------------------------
int __cdecl sub_1002FB20(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10016EA0(&a1, 1u, (int)&unk_100C69A0, 8, 53, 67);
  if ( v1 == 67 )
    result = 0;
  else
    result = (int)*(&off_100C69A4 + 2 * v1);
  return result;
}
// 100C69A4: using guessed type void *off_100C69A4;

//----- (1002FB60) --------------------------------------------------------
int __cdecl sub_1002FB60(char a1, char *a2)
{
  int result; // eax@1
  char *v3; // edi@2
  char *v4; // esi@3
  int v5; // edi@3

  result = sub_10016EA0(&a1, 1u, (int)&unk_100C6B48, 68, 4, 4);
  if ( result < 4 )
  {
    v3 = a2;
    if ( a2 )
    {
      v4 = (char *)&unk_100C6B49 + 68 * result;
      qmemcpy(a2, v4, 0x40u);
      v4 += 64;
      v5 = (int)(v3 + 64);
      *(_WORD *)v5 = *(_WORD *)v4;
      *(_BYTE *)(v5 + 2) = v4[2];
    }
  }
  return result;
}

//----- (1002FBB0) --------------------------------------------------------
int __cdecl sub_1002FBB0(char a1)
{
  return sub_10016EA0(&a1, 1u, (int)&unk_100C9820, 8, 2, 2);
}

//----- (1002FBD0) --------------------------------------------------------
BOOL __cdecl sub_1002FBD0(int a1, void *a2)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-18h]@2
  int v5; // [sp+18h] [bp-4h]@3

  v2 = sub_1002EE00(a1);
  return sub_10013EB0(0, 604, a2) && sub_10013880(0, 0x25Cu, (int)&v4) && (v2 & v5) == v2;
}

//----- (1002FC30) --------------------------------------------------------
int __usercall sub_1002FC30@<eax>(char a1@<al>)
{
  unsigned __int8 v1; // al@1
  int result; // eax@2

  v1 = sub_1002FBB0(a1);
  if ( v1 >= 2u )
    result = 42066;
  else
    result = dword_100C9824[2 * v1];
  return result;
}
// 100C9824: using guessed type int dword_100C9824[];

//----- (1002FC60) --------------------------------------------------------
BOOL __cdecl sub_1002FC60(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1002FC30(a1);
  return sub_10031BF0(v2, a2, 16) == 0;
}

//----- (1002FC90) --------------------------------------------------------
int __cdecl sub_1002FC90(int a1, char a2, int a3, int a4, void *a5)
{
  int result; // eax@2

  if ( a2 )
    result = sub_1002FC60(a1, (int)a5);
  else
    result = sub_1002FBD0(a1, a5);
  return result;
}

//----- (1002FCC0) --------------------------------------------------------
char __cdecl sub_1002FCC0(void *a1)
{
  int v1; // ecx@0
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  return sub_10013EE0(1, 1947, a1, (int)&v3);
}

//----- (1002FCE0) --------------------------------------------------------
BOOL __cdecl sub_1002FCE0(int a1)
{
  return sub_10031BF0(6792, a1, 284) == 0;
}

//----- (1002FD00) --------------------------------------------------------
char __cdecl sub_1002FD00(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2

  if ( a2 )
    result = sub_1002FCE0((int)a5);
  else
    result = sub_1002FCC0(a5);
  return result;
}

//----- (1002FD30) --------------------------------------------------------
bool __cdecl sub_1002FD30(char a1, void *a2)
{
  memset(a2, 0, 0x2890u);
  return sub_10031BF0((a1 != 36) + 6534, (int)a2, 10384) == 0;
}

//----- (1002FD70) --------------------------------------------------------
signed int __usercall sub_1002FD70@<eax>(char a1@<al>)
{
  return a1 != 36 ? 0x20000 : 0x10000;
}

//----- (1002FD90) --------------------------------------------------------
bool __cdecl sub_1002FD90(char a1, void *a2)
{
  int v2; // esi@1
  bool result; // al@5
  void *v4; // ecx@6
  int v5; // [sp+Ch] [bp-28h]@4
  char v6; // [sp+10h] [bp-24h]@2
  int v7; // [sp+24h] [bp-10h]@3
  __int16 v8; // [sp+28h] [bp-Ch]@8
  int v9; // [sp+2Ch] [bp-8h]@8

  v2 = sub_1002FD70(a1);
  if ( (v2 & j_HWM_pvg_hsdb_get_lrus_online()) == v2
    && sub_10013880(1, 0x6ACu, (int)&v6)
    && v7 == v2
    && sub_10013EE0(1, 1708, a2, (int)&v5) )
  {
    result = 1;
  }
  else if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    result = sub_1002FD30(a1, a2);
  }
  else
  {
    v9 = sub_100128C0(v4);
    v8 = 1708;
    sub_100139E0(1, 0, &v8, 0, 8, 1);
    sub_10013B20(1, 0, v2);
    result = 0;
  }
  return result;
}
// 100323C0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 100323E0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1002FE80) --------------------------------------------------------
bool __cdecl sub_1002FE80(char a1, char a2, int a3, int a4, void *a5)
{
  bool result; // al@2

  if ( a2 )
    result = sub_1002FD30(a1, a5);
  else
    result = sub_1002FD90(a1, a5);
  return result;
}

//----- (1002FEB0) --------------------------------------------------------
char __cdecl sub_1002FEB0(char a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@3
  char v4; // dl@3

  memset(byte_1018B918, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_1000D740("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 215, 0, 0);
  }
  else
  {
    sub_10024030(a1, (int)byte_1018B918);
    v3 = 4 * a2 - 64;
    v4 = byte_1018B919[v3];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_1018B918[v3];
    if ( (unsigned __int8)v4 < 0x23u
      || (unsigned __int8)v4 >= 0x64u && (unsigned __int8)v4 <= 0x81u
      || (unsigned __int8)v4 >= 0x96u && (unsigned __int8)v4 <= 0x9Bu )
    {
      return 1;
    }
  }
  return 0;
}

//----- (1002FF50) --------------------------------------------------------
bool __cdecl sub_1002FF50(char a1, unsigned __int8 a2, int a3)
{
  char *v3; // eax@3
  bool result; // al@3

  memset(byte_1018B918, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || a2 >= 0x2Du )
  {
    sub_1000D740("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 340, 0, 0);
    result = 0;
  }
  else
  {
    sub_10024030(a1, (int)byte_1018B918);
    v3 = (char *)&unk_1018B9B8 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v3;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v3 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v3 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v3 + 3);
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  return result;
}

//----- (1002FFD0) --------------------------------------------------------
char __cdecl sub_1002FFD0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_1018B918, 0, 0x890u);
  sub_10024030(a1, (int)byte_1018B918);
  if ( a2 > 0x10u )
  {
    sub_1000D740("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 512, 0, 0);
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = dword_1018BC88[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_1018BC8C[2 * a2];
    result = 1;
  }
  return result;
}
// 1018BC88: using guessed type int dword_1018BC88[];
// 1018BC8C: using guessed type int dword_1018BC8C[];

//----- (10030040) --------------------------------------------------------
char __cdecl sub_10030040(char a1, void *a2)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = sub_10013EB0(0, 227, a2);
    }
    else if ( a1 == 2 )
    {
      result = sub_10013EB0(0, 572, a2);
    }
    else
    {
      sub_1000D740("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 991, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_10013EB0(0, 226, a2);
  }
  return result;
}

//----- (100300C0) --------------------------------------------------------
char __cdecl sub_100300C0(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  int v4; // ecx@3

  memset(byte_1018B918, 0, 0x890u);
  if ( a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_1000D740("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 153, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10030040(a1, byte_1018B918);
    v4 = 4 * a2 - 64;
    *(_BYTE *)(a3 + 1) = byte_1018B919[v4];
    *(_BYTE *)a3 = byte_1018B918[v4];
  }
  return result;
}

//----- (10030140) --------------------------------------------------------
char __cdecl sub_10030140(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  char *v4; // ecx@3

  memset(byte_1018B918, 0, 0x890u);
  if ( a1 >= 3u || a2 >= 0x2Du )
  {
    sub_1000D740("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 280, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10030040(a1, byte_1018B918);
    v4 = (char *)&unk_1018B9B8 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v4;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v4 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v4 + 3);
  }
  return result;
}

//----- (100301C0) --------------------------------------------------------
char __cdecl sub_100301C0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_1018B918, 0, 0x890u);
  if ( a2 <= 0x10u )
  {
    result = sub_10030040(a1, byte_1018B918);
    *(_DWORD *)a3 = dword_1018BC88[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_1018BC8C[2 * a2];
  }
  else
  {
    sub_1000D740("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 445, 0, 0);
    result = 0;
  }
  return result;
}
// 1018BC88: using guessed type int dword_1018BC88[];
// 1018BC8C: using guessed type int dword_1018BC8C[];

//----- (10030230) --------------------------------------------------------
char __cdecl sub_10030230(char a1, char a2, char a3, unsigned __int8 *a4, int a5)
{
  char result; // al@6
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10031090(a1);
  if ( v6 == 3 )
    return 0;
  if ( a3 == 1 )
  {
    if ( a2 )
      result = sub_1002FFD0(v6, *a4, a5);
    else
      result = sub_100301C0(v6, *a4, a5);
  }
  else if ( a3 == 2 )
  {
    if ( a2 )
      result = sub_1002FEB0(v6, *a4, a5);
    else
      result = sub_100300C0(v6, *a4, a5);
  }
  else
  {
    if ( a3 != 3 )
    {
      sub_1000D740("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 915, 0, 0);
      return 0;
    }
    if ( a2 )
      result = sub_1002FF50(v6, *a4, a5);
    else
      result = sub_10030140(v6, *a4, a5);
  }
  return result;
}

//----- (10030340) --------------------------------------------------------
char __cdecl sub_10030340(char a1, void *a2)
{
  return sub_10013EB0(6, (unsigned __int16)word_100CA85A[8 * (unsigned __int8)a1], a2);
}
// 100CA85A: using guessed type __int16 word_100CA85A[];

//----- (10030360) --------------------------------------------------------
bool __cdecl sub_10030360(unsigned __int8 a1, char *a2)
{
  int v2; // eax@1
  char v4; // [sp+8h] [bp-30h]@1

  v2 = sub_10031BF0(dword_100CA860[4 * a1], (int)&v4, 48);
  qmemcpy(a2, &v4, 0x2Cu);
  return v2 == 0;
}
// 100CA860: using guessed type int dword_100CA860[];

//----- (100303A0) --------------------------------------------------------
char __cdecl sub_100303A0(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_100310D0(a1);
  if ( a2 )
    result = sub_10030360(v6, (char *)a5);
  else
    result = sub_10030340(v6, a5);
  return result;
}

//----- (100303E0) --------------------------------------------------------
BOOL sub_100303E0()
{
  char v1; // [sp+0h] [bp-78h]@1

  return sub_100187B0(69, &v1) && !strncmp(&v1, "006-B0756-", 0xAu);
}

//----- (10030440) --------------------------------------------------------
char __cdecl sub_10030440(int a1, char *a2)
{
  char result; // al@5
  char v3; // [sp+13h] [bp-7Dh]@1
  char v4; // [sp+14h] [bp-7Ch]@1
  char v5; // [sp+15h] [bp-7Bh]@2
  int v6; // [sp+30h] [bp-60h]@2
  int v7; // [sp+34h] [bp-5Ch]@2
  int v8; // [sp+38h] [bp-58h]@2
  int v9; // [sp+3Ch] [bp-54h]@2
  int v10; // [sp+40h] [bp-50h]@2
  __int16 v11; // [sp+44h] [bp-4Ch]@2
  char v12; // [sp+46h] [bp-4Ah]@2
  char v13; // [sp+47h] [bp-49h]@2
  float v14; // [sp+48h] [bp-48h]@2
  char v15; // [sp+4Ch] [bp-44h]@2
  char v16; // [sp+4Dh] [bp-43h]@2
  char v17; // [sp+4Eh] [bp-42h]@2
  char v18; // [sp+50h] [bp-40h]@1

  memset(&v18, 0, 0x3Cu);
  v3 = sub_10013EB0(1, 292, &v18);
  qmemcpy(&v4, &v18, 0x3Cu);
  if ( !(unsigned __int8)sub_100303E0() )
  {
    v6 = -1;
    v14 = 77.166664;
    v7 = -1;
    v8 = -1;
    v9 = -1;
    v5 = 1;
    v12 = 0;
    v13 = 1;
    v4 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v10 = 0;
    v11 = 0;
  }
  if ( !v3 || sub_10018070((int)&v4) )
  {
    result = 0;
  }
  else
  {
    result = 1;
    qmemcpy(a2, &v18, 0x3Cu);
  }
  return result;
}

//----- (10030530) --------------------------------------------------------
BOOL __cdecl sub_10030530(int a1, int a2)
{
  return sub_10031BF0(6200, a2, 60) == 0;
}

//----- (10030550) --------------------------------------------------------
char __cdecl sub_10030550(int a1, char a2, int a3, int a4, char *a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10030530(a1, (int)a5);
  }
  else
  {
    result = sub_10030440(a1, a5);
  }
  return result;
}

//----- (10030590) --------------------------------------------------------
char __cdecl sub_10030590(int a1, int a2)
{
  int v2; // ecx@3
  int v3; // edx@3
  int v4; // ecx@3
  char result; // al@3
  int v6; // [sp+4h] [bp-1Ch]@1
  int v7; // [sp+8h] [bp-18h]@1
  int v8; // [sp+Ch] [bp-14h]@1
  int v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+14h] [bp-Ch]@1
  __int16 v11; // [sp+18h] [bp-8h]@1
  char v12; // [sp+1Ah] [bp-6h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if ( !sub_10013EB0(2, 284, &v6) || sub_10018210((int)&v6) )
  {
    result = 0;
  }
  else
  {
    v2 = v8;
    *(_DWORD *)a2 = v7;
    v3 = v9;
    *(_DWORD *)(a2 + 4) = v2;
    v4 = v10;
    *(_DWORD *)(a2 + 8) = v3;
    LOWORD(v3) = v11;
    *(_DWORD *)(a2 + 12) = v4;
    LOBYTE(v4) = v12;
    *(_WORD *)(a2 + 16) = v3;
    *(_BYTE *)(a2 + 18) = v4;
    result = 1;
  }
  return result;
}

//----- (10030640) --------------------------------------------------------
BOOL __cdecl sub_10030640(int a1, int a2)
{
  return sub_10031BF0(6169, a2, 40) == 0;
}

//----- (10030660) --------------------------------------------------------
char __cdecl sub_10030660(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10030640(a1, a5);
  }
  else
  {
    result = sub_10030590(a1, a5);
  }
  return result;
}

//----- (100306A0) --------------------------------------------------------
char __cdecl sub_100306A0(void *a1)
{
  *(_DWORD *)a1 = 0;
  return sub_10013EB0(2, 363, a1);
}

//----- (100306C0) --------------------------------------------------------
char __cdecl sub_100306C0(void *a1)
{
  int v1; // edx@2
  int v2; // eax@2
  int v3; // ecx@2
  int v4; // eax@2
  int v5; // ecx@2
  void *v6; // esi@2
  signed int v7; // edi@2
  char *v8; // eax@4
  signed int v9; // edx@4
  char result; // al@6
  char v11; // [sp+8h] [bp-208h]@1
  int v12; // [sp+47h] [bp-1C9h]@2
  int v13; // [sp+4Bh] [bp-1C5h]@2
  int v14; // [sp+4Fh] [bp-1C1h]@2
  int v15; // [sp+53h] [bp-1BDh]@2
  int v16; // [sp+58h] [bp-1B8h]@2
  int v17; // [sp+5Ch] [bp-1B4h]@2
  __int16 v18; // [sp+60h] [bp-1B0h]@2
  char v19; // [sp+62h] [bp-1AEh]@2
  char v20; // [sp+B6h] [bp-15Ah]@2
  char v21; // [sp+F6h] [bp-11Ah]@2

  *(_DWORD *)a1 = 0;
  if ( sub_10031BF0(6444, (int)&v11, 514) )
  {
    result = 0;
  }
  else
  {
    v1 = v13;
    v2 = v14;
    *((_DWORD *)a1 + 3330) = v12;
    v3 = v15;
    *((_DWORD *)a1 + 3331) = v1;
    LOWORD(v1) = v18;
    *((_DWORD *)a1 + 3332) = v2;
    v4 = v16;
    *((_DWORD *)a1 + 3333) = v3;
    qmemcpy((char *)a1 + 13340, &v19, 0x54u);
    v5 = v17;
    *((_WORD *)a1 + 6668) = v1;
    LOBYTE(v1) = v21;
    *((_DWORD *)a1 + 3009) = v5;
    qmemcpy((char *)a1 + 13424, &v20, 0x40u);
    *((_DWORD *)a1 + 3008) = v4;
    *((_BYTE *)a1 + 13488) = v1 & 2;
    v6 = a1;
    v7 = 32;
    do
    {
      memset(v6, 0, 0x38u);
      *((_DWORD *)v6 + 9) = 2048;
      v6 = (char *)v6 + 56;
      --v7;
    }
    while ( v7 );
    v8 = (char *)a1 + 1799;
    v9 = 512;
    do
    {
      *(_DWORD *)(v8 - 7) = 0;
      *(_DWORD *)(v8 - 3) = 0;
      *(_DWORD *)(v8 + 1) = 0;
      *(_DWORD *)(v8 + 5) = 0;
      *(_DWORD *)(v8 + 9) = 0;
      *v8 = -1;
      v8 += 20;
      --v9;
    }
    while ( v9 );
    result = 1;
  }
  return result;
}

//----- (10030810) --------------------------------------------------------
char __cdecl sub_10030810(int a1, char a2, char a3, int a4, void *a5, size_t a6)
{
  char result; // al@3
  char v7; // al@6
  char v8; // bl@8
  char v9; // al@10
  char v10; // bl@12
  char v11; // al@14
  char v12; // bl@16
  char v13; // al@18
  char v14; // bl@20

  switch ( a3 )
  {
    case 0x18:
      if ( a2 )
        result = sub_100306C0(a5);
      else
        result = sub_100306A0(a5);
      break;
    case 0x19:
      if ( a2 )
        v7 = sub_100306C0(&unk_1018C1A8);
      else
        v7 = sub_100306A0(&unk_1018C1A8);
      v8 = v7;
      memcpy_0(a5, (char *)&unk_1018C1A8 + 56 * *(_BYTE *)a4, a6);
      result = v8;
      break;
    case 0x1A:
      if ( a2 )
        v9 = sub_100306C0(&unk_1018C1A8);
      else
        v9 = sub_100306A0(&unk_1018C1A8);
      v10 = v9;
      memcpy_0(a5, (char *)&unk_1018F0B0 + 40 * *(_BYTE *)a4, a6);
      result = v10;
      break;
    case 0x1B:
      if ( a2 )
        v11 = sub_100306C0(&unk_1018C1A8);
      else
        v11 = sub_100306A0(&unk_1018C1A8);
      v12 = v11;
      memcpy_0(a5, (char *)&unk_1018F5B0 + *(_BYTE *)a4, a6);
      result = v12;
      break;
    case 0x2B:
      if ( a2 )
        v13 = sub_100306C0(&unk_1018C1A8);
      else
        v13 = sub_100306A0(&unk_1018C1A8);
      v14 = v13;
      memcpy_0(a5, &unk_1018F658, a6);
      result = v14;
      break;
    default:
      sub_1000D740("..\\lib\\acl\\iop\\gdl59\\iop_gdl59_cnfg_intf.c", 709, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (100309B0) --------------------------------------------------------
char __cdecl sub_100309B0(char a1)
{
  char result; // al@3

  if ( a1 == 15 )
  {
    result = 0;
  }
  else if ( a1 == 16 )
  {
    result = 1;
  }
  else
  {
    sub_1000D740("..\\lib\\acl\\iop\\iop_adc_intf.c", 178, 0, 0);
    result = 0;
  }
  return result;
}

//----- (100309F0) --------------------------------------------------------
__int16 __usercall sub_100309F0@<ax>(unsigned __int8 a1@<al>)
{
  return word_100CD410[a1];
}
// 100CD410: using guessed type __int16 word_100CD410[];

//----- (10030A00) --------------------------------------------------------
char __cdecl sub_10030A00(unsigned __int8 a1, char *a2)
{
  int v2; // eax@2
  char result; // al@5
  int v4; // [sp+4h] [bp-150h]@2
  char v5; // [sp+8h] [bp-14Ch]@1
  char v6; // [sp+9h] [bp-14Bh]@3
  char v7; // [sp+Ch] [bp-148h]@5

  memset(&v5, 0, 0x148u);
  if ( a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    LOWORD(v2) = sub_100309F0(a1);
    if ( sub_10013EE0(0, v2, &v5, (int)&v4) && v6 == 3 && (unsigned int)(unsigned __int16)v4 - 4 >= 0xA0 )
    {
      qmemcpy(a2, &v7, 0xA0u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (10030AD0) --------------------------------------------------------
char __cdecl sub_10030AD0(char a1, char a2, char a3, int a4, char *a5, unsigned int a6)
{
  char result; // al@3
  unsigned __int8 v7; // [sp+4h] [bp-4h]@1

  v7 = sub_100309B0(a1);
  if ( a3 != 11 )
  {
    sub_1000D740("..\\lib\\acl\\iop\\iop_adc_intf.c", 564, 0, 0);
    return 0;
  }
  if ( a6 >= 0xA0 )
  {
    if ( a2 )
      return 0;
    result = sub_10030A00(v7, a5);
  }
  else
  {
    sub_1000D740("..\\lib\\acl\\iop\\iop_adc_intf.c", 551, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10030B50) --------------------------------------------------------
char __cdecl sub_10030B50(unsigned __int16 a1, char *a2, char a3)
{
  char result; // al@4
  char v4; // al@5
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
    {
      sub_1000D740("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 188, 0, 0);
      return 0;
    }
    v4 = sub_10013EE0(1, 555, &v5, (int)&a1);
  }
  else
  {
    v4 = sub_10013EE0(1, 550, &v5, (int)&a1);
  }
  if ( !v4 )
    return 0;
  if ( sub_100186F0((int)&v5) )
    return 0;
  result = 1;
  if ( !BYTE1(v14) || (unsigned int)a1 - 4 < 0x20 )
    return 0;
  if ( a3 )
  {
    if ( BYTE1(v5) == 26 )
    {
      qmemcpy(a2, (char *)&v6 + 1, 0x20u);
      qmemcpy(&unk_1018F680, (char *)&v6 + 1, 0x20u);
      byte_1018F678 = 1;
      byte_1018F679 = 0;
      return result;
    }
  }
  else if ( BYTE1(v5) == 12 )
  {
    qmemcpy(a2, (char *)&v6 + 1, 0x20u);
    qmemcpy(&unk_1018F6A0, (char *)&v6 + 1, 0x20u);
    byte_1018F679 = 1;
    byte_1018F67A = 1;
    return result;
  }
  return 0;
}
// 1018F678: using guessed type char byte_1018F678;
// 1018F679: using guessed type char byte_1018F679;
// 1018F67A: using guessed type char byte_1018F67A;

//----- (10030C80) --------------------------------------------------------
char __cdecl sub_10030C80(char a1, int a2)
{
  char result; // al@3
  char v3; // [sp+4h] [bp-44h]@1
  char v4; // [sp+8h] [bp-40h]@3
  char v5; // [sp+28h] [bp-20h]@3

  memset(&v3, 0, 0x44u);
  if ( (unsigned __int8)a1 < 2u && a2 )
  {
    result = sub_10023FE0(a1, (int)&v3);
    qmemcpy((void *)a2, &v4, 0x20u);
    qmemcpy((void *)(a2 + 32), &v5, 0x20u);
  }
  else
  {
    result = sub_1000D740("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 570, 0, 0);
  }
  return result;
}

//----- (10030D00) --------------------------------------------------------
bool __cdecl sub_10030D00(void *a1)
{
  bool v1; // zf@2
  bool result; // al@4

  if ( a1 )
  {
    v1 = byte_1018F678 == 0;
    qmemcpy(a1, &unk_1018F680, 0x40u);
    result = !v1 && byte_1018F67A;
  }
  else
  {
    sub_1000D740("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 617, 0, 0);
    result = 0;
  }
  return result;
}
// 1018F678: using guessed type char byte_1018F678;
// 1018F67A: using guessed type char byte_1018F67A;

//----- (10030D50) --------------------------------------------------------
char __cdecl sub_10030D50(char a1, int a2)
{
  char result; // al@4
  int v3; // edx@5
  const void *v4; // esi@8
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( j_HWM_pvg_read_reg(1) != 1 )
    sub_1000D740("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 857, 1, 0);
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 != 1 )
      return result;
    result = sub_10012820(15);
    v3 = 555;
  }
  else
  {
    result = sub_10012820(8);
    v3 = 550;
  }
  if ( result )
  {
    v4 = (const void *)a2;
    LOBYTE(v5) = 12;
    BYTE1(v14) = 1;
    LOBYTE(v6) = 32;
    HIWORD(v5) = 34;
    if ( byte_1018F679 )
    {
      BYTE1(v5) = 26;
    }
    else
    {
      BYTE1(v5) = 12;
      v4 = (const void *)(a2 + 32);
    }
    qmemcpy((char *)&v6 + 1, v4, 0x20u);
    result = sub_100139E0(1, v3, &v5, 1, 38, 1);
  }
  return result;
}
// 100323E0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1018F679: using guessed type char byte_1018F679;

//----- (10030E30) --------------------------------------------------------
__int16 __usercall sub_10030E30@<ax>(unsigned __int8 a1@<al>)
{
  return word_100CD520[a1];
}
// 100CD520: using guessed type __int16 word_100CD520[];

//----- (10030E40) --------------------------------------------------------
char __cdecl sub_10030E40(unsigned __int8 a1, int *a2, const void *a3)
{
  int v3; // ebx@1
  int v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int v7; // [sp+14h] [bp-20h]@1
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+28h] [bp-Ch]@1
  int v13; // [sp+2Ch] [bp-8h]@1
  int v14; // [sp+30h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v3 = (unsigned __int16)sub_10030E30(a1);
  v5 = *a2;
  qmemcpy(&v6, a3, 0x24u);
  sub_100139E0(1, v3, &v5, 1, HIWORD(v5) + 4, 1);
  return sub_10013B20(1, v3, 0xFFFFFFF);
}

//----- (10030ED0) --------------------------------------------------------
char __cdecl sub_10030ED0(unsigned __int8 a1, char a2)
{
  int v3; // [sp+4h] [bp-28h]@1
  int v4; // [sp+8h] [bp-24h]@1
  int v5; // [sp+Ch] [bp-20h]@1
  int v6; // [sp+10h] [bp-1Ch]@1
  int v7; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@1
  int v9; // [sp+1Ch] [bp-10h]@1
  int v10; // [sp+20h] [bp-Ch]@1
  int v11; // [sp+24h] [bp-8h]@1
  int v12; // [sp+28h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v3 = 0;
  if ( a1 >= 2u )
  {
    sub_1000D740("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 736, 0, 0);
  }
  else
  {
    HIWORD(v3) = 0;
    LOBYTE(v3) = 12;
    if ( a2 == 11 )
    {
      BYTE1(v3) = byte_1018F679 != 0 ? 25 : 11;
      sub_10030E40(a1, &v3, &v4);
      return 1;
    }
    if ( a2 == 17 )
    {
      LOWORD(v3) = 10042;
      sub_10030E40(a1, &v3, &v4);
      return 1;
    }
  }
  return 0;
}
// 1018F679: using guessed type char byte_1018F679;

//----- (10030F90) --------------------------------------------------------
bool __cdecl sub_10030F90(__int16 a1, char a2, int a3, int a4, void *a5)
{
  char v6; // [sp+4h] [bp-40h]@8
  char v7; // [sp+24h] [bp-20h]@11

  if ( (unsigned __int8)a1 == 8 )
  {
    LOBYTE(a1) = 0;
  }
  else
  {
    if ( (unsigned __int8)a1 != 9 )
      return 0;
    LOBYTE(a1) = 1;
  }
  if ( a2 == 1 )
  {
    sub_10030C80(a1, (int)a5);
    return 1;
  }
  if ( byte_1018F679 )
  {
    if ( sub_10030B50(a1, &v6, 1) )
    {
LABEL_14:
      byte_1018F67B = 0;
      goto LABEL_15;
    }
    if ( (unsigned __int8)++byte_1018F67B >= 5u )
    {
      byte_1018F678 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( sub_10030B50(a1, &v7, 0) )
      goto LABEL_14;
    if ( (unsigned __int8)++byte_1018F67B >= 5u )
    {
      byte_1018F67A = 0;
      goto LABEL_14;
    }
  }
LABEL_15:
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    sub_10030C80(a1, (int)&v6);
    sub_10030D50(a1, (int)&v6);
  }
  sub_10030ED0(a1, 11);
  return sub_10030D00(a5);
}
// 100323E0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1018F678: using guessed type char byte_1018F678;
// 1018F679: using guessed type char byte_1018F679;
// 1018F67A: using guessed type char byte_1018F67A;
// 1018F67B: using guessed type char byte_1018F67B;

//----- (10031090) --------------------------------------------------------
char __cdecl sub_10031090(char a1)
{
  char result; // al@4

  switch ( a1 )
  {
    case 25:
      result = 0;
      break;
    case 26:
      result = 1;
      break;
    case 43:
      result = 2;
      break;
    default:
      sub_1000D740("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 169, 0, 0);
      result = 3;
      break;
  }
  return result;
}

//----- (100310D0) --------------------------------------------------------
char __cdecl sub_100310D0(char a1)
{
  char result; // al@3

  if ( a1 == 20 )
  {
    result = 0;
  }
  else if ( a1 == 21 )
  {
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10031100) --------------------------------------------------------
char __cdecl sub_10031100(float a1, int a2, int a3)
{
  char v3; // bl@8
  char result; // al@8
  unsigned __int8 v5; // [sp+Ch] [bp-28h]@1
  unsigned __int8 v6; // [sp+18h] [bp-1Ch]@2
  char v7; // [sp+1Ah] [bp-1Ah]@6

  sub_10033300((int)&v5);
  if ( LOBYTE(a1) < v5
    || LOBYTE(a1) >= v6 && ((unsigned __int8)(LOBYTE(a1) - 100) > 1u || *(_BYTE *)(dword_101F03DC + 816) != 3)
    || LOBYTE(a1) >= 0x66u
    || v7
    || sub_10033290(1) )
  {
    result = 0;
  }
  else
  {
    sub_100162E0();
    v3 = sub_10031350(a1, a2, a3);
    sub_100162D0();
    result = v3;
  }
  return result;
}
// 101F03DC: using guessed type int dword_101F03DC;

//----- (100311B0) --------------------------------------------------------
void __cdecl sub_100311B0(int a1, int a2, int a3, float *a4, int a5)
{
  int v5; // edi@1
  int v6; // esi@3
  int v7; // ebx@5
  float *v8; // eax@9
  char v9; // [sp+10h] [bp-8h]@5

  v5 = a1;
  *(float *)&a1 = *(double *)a1;
  *(float *)&a1 = *(float *)&a1 - 6.283185005187988;
  a1 &= 0x7FFFFFFFu;
  if ( *(float *)&a1 < 0.1
    || (*(float *)&a1 = *(double *)(v5 + 8),
        *(float *)&a1 = *(float *)&a1 - 6.283185005187988,
        a1 &= 0x7FFFFFFFu,
        *(float *)&a1 < 0.1)
    || (v6 = a2,
        *(float *)&a1 = *(double *)a2,
        *(float *)&a1 = *(float *)&a1 - 6.283185005187988,
        a1 &= 0x7FFFFFFFu,
        *(float *)&a1 < 0.1)
    || (*(float *)&a1 = *(double *)(a2 + 8),
        *(float *)&a1 = *(float *)&a1 - 6.283185005187988,
        a1 &= 0x7FFFFFFFu,
        *(float *)&a1 < 0.1) )
  {
    v8 = (float *)a5;
    *a4 = 9.9999996e24;
    *v8 = 9.9999996e24;
  }
  else
  {
    sub_100378D0(v5, (int)&v9);
    v7 = a3;
    if ( (_BYTE)a3 )
      *(float *)&a1 = sub_100331E0(a3);
    else
      sub_1000C1A0(&v9, &a1);
    sub_100312E0(v5, v6, v7, (int)a4, a5, *(float *)&a1);
  }
}
// 1000C1A0: using guessed type _DWORD __cdecl sub_1000C1A0(_DWORD, _DWORD);

//----- (100312E0) --------------------------------------------------------
void __cdecl sub_100312E0(int a1, int a2, int a3, int a4, int a5, float a6)
{
  double v6; // st7@4
  int v7; // [sp+18h] [bp+Ch]@6
  float v8; // [sp+18h] [bp+Ch]@6

  sub_10033B40(a1, a2, (float *)a4, (float *)a5);
  if ( (_BYTE)a3 != 1 && *(float *)a4 > 25.0 )
  {
    if ( (_BYTE)a3 )
      v6 = sub_100331E0(a3);
    else
      v6 = a6;
    *(float *)&v7 = v6;
    v8 = *(float *)a5 - *(float *)&v7;
    *(float *)a5 = v8;
    *(float *)a5 = sub_10037890(v8);
  }
}

//----- (10031350) --------------------------------------------------------
char __cdecl sub_10031350(float a1, int a2, int a3)
{
  double v3; // st7@1
  unsigned __int8 v4; // bl@1
  float *v5; // esi@1
  int v6; // ebp@1
  unsigned __int8 v7; // cl@1
  char result; // al@1
  int v9; // edx@5
  int v10; // eax@6
  unsigned int v11; // ecx@6
  double v12; // st6@7
  int v13; // eax@10
  int v14; // edi@10
  double v15; // st6@11
  double v16; // st6@13
  double v17; // st7@16
  double v18; // st6@16
  double v19; // rt1@18
  char v20; // bl@22
  double v21; // st6@25
  float v22; // [sp+10h] [bp+4h]@7
  float v23; // [sp+10h] [bp+4h]@7
  float v24; // [sp+10h] [bp+4h]@7
  float v25; // [sp+10h] [bp+4h]@25
  _BYTE *v26; // [sp+14h] [bp+8h]@1

  v3 = 0.0;
  v4 = LOBYTE(a1);
  v5 = (float *)a2;
  *(float *)a2 = 0.0;
  *(_DWORD *)a3 = 0x7FFFFFFF;
  v6 = dword_101F03DC;
  v26 = (_BYTE *)(dword_101F03DC + 812);
  v7 = *(_BYTE *)(dword_101F03DC + 812);
  result = 0;
  if ( LOBYTE(a1) < v7
    || LOBYTE(a1) >= *(_BYTE *)(dword_101F03D0 + 4)
    && ((unsigned __int8)(LOBYTE(a1) - 100) > 1u || *(_BYTE *)(dword_101F03DC + 816) != 3) )
  {
    return result;
  }
  v9 = v7 + 1;
  if ( LOBYTE(a1) - v9 + 1 >= 4 )
  {
    v10 = 180 * v9;
    v11 = (((unsigned int)LOBYTE(a1) - v9 - 3) >> 2) + 1;
    v9 += 4 * v11;
    do
    {
      v12 = *(float *)(v10 + dword_101F03D0 + 696);
      v10 += 720;
      --v11;
      v22 = v12 + *v5;
      *v5 = v22;
      v23 = v22 + *(float *)(v10 + dword_101F03D0 + 156);
      *v5 = v23;
      v24 = v23 + *(float *)(v10 + dword_101F03D0 + 336);
      *v5 = v24;
      *v5 = v24 + *(float *)(v10 + dword_101F03D0 + 516);
    }
    while ( v11 );
    v6 = dword_101F03DC;
  }
  if ( v9 <= v4 )
  {
    v13 = 180 * v9;
    v14 = v4 - v9 + 1;
    do
    {
      v15 = *(float *)(v13 + dword_101F03D0 + 696);
      v13 += 180;
      --v14;
      *v5 = v15 + *v5;
    }
    while ( v14 );
    v6 = dword_101F03DC;
  }
  v16 = 9.9999996e24;
  if ( 9.9999996e24 == *(float *)(v6 + 316) || 9.9999996e24 == *(float *)(v6 + 332) )
  {
    v18 = 0.0;
    v17 = 9.9999996e24;
    *v5 = 0.0;
  }
  else
  {
    if ( *(_BYTE *)(180 * *v26 + dword_101F03D0 + 671) == 21 )
      goto LABEL_19;
    *v5 = sub_100162C0(*(_DWORD *)(v6 + 296)) * *(float *)(dword_101F03DC + 332)
        + *(float *)(dword_101F03DC + 316)
        + *v5;
    v17 = 9.9999996e24;
    v18 = 0.0;
  }
  v19 = v18;
  v16 = v17;
  v3 = v19;
LABEL_19:
  *(_DWORD *)v5 = COERCE_UNSIGNED_INT(*v5) & 0x7FFFFFFF;
  if ( (COERCE_UNSIGNED_INT(*v5) & 0x7F800000) == 2139095040 || v16 < *v5 || v3 > *v5 )
  {
    *v5 = v3;
    v20 = 0;
  }
  else
  {
    v20 = 1;
  }
  if ( *(_BYTE *)(dword_101F03DC + 660) )
  {
    v25 = *v5 / *(float *)(dword_101F03DC + 688) + 0.5;
    v21 = v25;
    if ( (LODWORD(v25) & 0x7F800000) == 2139095040 || v21 > 2147418112.0 || v21 < v3 )
    {
      *(_DWORD *)a3 = 0x7FFFFFFF;
      result = 0;
    }
    else
    {
      *(_DWORD *)a3 = (signed int)v21;
      result = v20;
    }
  }
  else
  {
    result = v20;
  }
  return result;
}
// 100162C0: using guessed type double __cdecl sub_100162C0(_DWORD);
// 101F03D0: using guessed type int dword_101F03D0;
// 101F03DC: using guessed type int dword_101F03DC;

//----- (100315C0) --------------------------------------------------------
int __cdecl sub_100315C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-1Ch]@1

  return gdi_pvg_bitblt(&v8, a2, a3, a7, a1, a4, a5, a6);
}
// 10037CF6: using guessed type int __cdecl gdi_pvg_bitblt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10031640) --------------------------------------------------------
int __cdecl sub_10031640(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-1Ch]@1

  return gdi_pvg_draw_pixels(&v8, a5, a4, a7, a6, a3, a1, a2);
}
// 10037D0E: using guessed type int __cdecl gdi_pvg_draw_pixels(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100316C0) --------------------------------------------------------
int sub_100316C0()
{
  gdi_pvg_init();
  return sub_10031820();
}
// 10037D26: using guessed type int gdi_pvg_init(void);

//----- (100316D0) --------------------------------------------------------
int __cdecl sub_100316D0(float a1)
{
  return gdi_pvg_line_width(LODWORD(a1));
}
// 10037D2C: using guessed type int __cdecl gdi_pvg_line_width(_DWORD);

//----- (10031720) --------------------------------------------------------
int __cdecl sub_10031720(float a1, float a2, float a3, float a4, float a5, float a6)
{
  float v7; // [sp+0h] [bp-18h]@1

  return gdi_pvg_ortho(&v7, LODWORD(a4), LODWORD(a6), LODWORD(a1), LODWORD(a5), LODWORD(a2), LODWORD(a3));
}
// 10037D4A: using guessed type int __cdecl gdi_pvg_ortho(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100317B0) --------------------------------------------------------
int __cdecl sub_100317B0(float a1, float a2)
{
  return gdi_pvg_vertex2f(LODWORD(a1), LODWORD(a2));
}
// 10037D6E: using guessed type int __cdecl gdi_pvg_vertex2f(_DWORD, _DWORD);

//----- (100317E0) --------------------------------------------------------
int __cdecl sub_100317E0(int a1, int a2, int a3)
{
  dword_10190894 = a1;
  dword_10190888 = a2;
  dword_1019088C = a3;
  return gdi_pvg_create_window(&dword_10190880);
}
// 10037D7A: using guessed type int __cdecl gdi_pvg_create_window(_DWORD);
// 10190880: using guessed type int dword_10190880;
// 10190888: using guessed type int dword_10190888;
// 1019088C: using guessed type int dword_1019088C;
// 10190894: using guessed type int dword_10190894;

//----- (10031820) --------------------------------------------------------
int sub_10031820()
{
  int result; // eax@1

  result = 0;
  dword_10190894 = 0;
  dword_10190888 = 0;
  dword_1019088C = 59;
  dword_10190880 = 1;
  dword_10190884 = 0;
  dword_10190890 = 0;
  return result;
}
// 10190880: using guessed type int dword_10190880;
// 10190884: using guessed type int dword_10190884;
// 10190888: using guessed type int dword_10190888;
// 1019088C: using guessed type int dword_1019088C;
// 10190890: using guessed type int dword_10190890;
// 10190894: using guessed type int dword_10190894;

//----- (10031870) --------------------------------------------------------
int __cdecl sub_10031870(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10190880 = a1;
  return result;
}
// 10190880: using guessed type int dword_10190880;

//----- (10031880) --------------------------------------------------------
int __cdecl sub_10031880(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_crit_lvl(a1);
  SYS_exit_krnl();
  return v1;
}
// 10037CD8: using guessed type int SYS_exit_krnl(void);
// 10037CE4: using guessed type int SYS_enter_krnl(void);
// 10037D86: using guessed type int __cdecl TSK_pvg_get_crit_lvl(_DWORD);

//----- (100318A0) --------------------------------------------------------
int sub_100318A0()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_id();
  SYS_exit_krnl();
  return v0;
}
// 10037CD8: using guessed type int SYS_exit_krnl(void);
// 10037CE4: using guessed type int SYS_enter_krnl(void);
// 10037D8C: using guessed type int TSK_pvg_get_id(void);

//----- (100318C0) --------------------------------------------------------
int __cdecl sub_100318C0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_get_msg(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10037CD8: using guessed type int SYS_exit_krnl(void);
// 10037CE4: using guessed type int SYS_enter_krnl(void);
// 10037D92: using guessed type int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD);

//----- (100318F0) --------------------------------------------------------
__int16 __cdecl sub_100318F0(int a1)
{
  __int16 v1; // si@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_run_state(a1);
  SYS_exit_krnl();
  return v1;
}
// 10037CD8: using guessed type int SYS_exit_krnl(void);
// 10037CE4: using guessed type int SYS_enter_krnl(void);
// 10037D98: using guessed type int __cdecl TSK_pvg_get_run_state(_DWORD);

//----- (10031910) --------------------------------------------------------
int sub_10031910()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_timer();
  SYS_exit_krnl();
  return v0;
}
// 10037CD8: using guessed type int SYS_exit_krnl(void);
// 10037CE4: using guessed type int SYS_enter_krnl(void);
// 10037D9E: using guessed type int TSK_pvg_get_timer(void);

//----- (10031930) --------------------------------------------------------
int __cdecl sub_10031930(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_get_tsk_info(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10037CD8: using guessed type int SYS_exit_krnl(void);
// 10037CE4: using guessed type int SYS_enter_krnl(void);
// 10037DA4: using guessed type int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10031970) --------------------------------------------------------
int __cdecl sub_10031970(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_kill_process(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10037CD8: using guessed type int SYS_exit_krnl(void);
// 10037CE4: using guessed type int SYS_enter_krnl(void);
// 10037DB0: using guessed type int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100319A0) --------------------------------------------------------
int __cdecl sub_100319A0(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_proc_status(a1);
  SYS_exit_krnl();
  return v1;
}
// 10037CD8: using guessed type int SYS_exit_krnl(void);
// 10037CE4: using guessed type int SYS_enter_krnl(void);
// 10037DB6: using guessed type int __cdecl TSK_pvg_proc_status(_DWORD);

//----- (100319C0) --------------------------------------------------------
int __cdecl sub_100319C0(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_release_smphr(a1);
  SYS_exit_krnl();
  return v1;
}
// 10037CD8: using guessed type int SYS_exit_krnl(void);
// 10037CE4: using guessed type int SYS_enter_krnl(void);
// 10037DBC: using guessed type int __cdecl TSK_pvg_release_smphr(_DWORD);

//----- (100319E0) --------------------------------------------------------
int __cdecl sub_100319E0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_reserve_smphr(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10037CD8: using guessed type int SYS_exit_krnl(void);
// 10037CE4: using guessed type int SYS_enter_krnl(void);
// 10037DC2: using guessed type int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD);

//----- (10031A10) --------------------------------------------------------
int __cdecl sub_10031A10(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_send_msg(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10037CD8: using guessed type int SYS_exit_krnl(void);
// 10037CE4: using guessed type int SYS_enter_krnl(void);
// 10037DC8: using guessed type int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10031A40) --------------------------------------------------------
int __cdecl sub_10031A40(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_msg_ex(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10037CD8: using guessed type int SYS_exit_krnl(void);
// 10037CE4: using guessed type int SYS_enter_krnl(void);
// 10037DCE: using guessed type int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD);

//----- (10031A70) --------------------------------------------------------
int __cdecl sub_10031A70(int a1)
{
  SYS_enter_krnl();
  TSK_pvg_set_proc_status(a1);
  return SYS_exit_krnl();
}
// 10037CD8: using guessed type int SYS_exit_krnl(void);
// 10037CE4: using guessed type int SYS_enter_krnl(void);
// 10037DD4: using guessed type int __cdecl TSK_pvg_set_proc_status(_DWORD);

//----- (10031A90) --------------------------------------------------------
int __cdecl sub_10031A90(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_suspend(a1);
  SYS_exit_krnl();
  return v1;
}
// 10037CD8: using guessed type int SYS_exit_krnl(void);
// 10037CE4: using guessed type int SYS_enter_krnl(void);
// 10037DDA: using guessed type int __cdecl TSK_pvg_suspend(_DWORD);

//----- (10031AB0) --------------------------------------------------------
char __cdecl sub_10031AB0(int a1, int a2)
{
  unsigned int v2; // esi@1
  char result; // al@4

  v2 = a2 + sub_10031910();
  if ( sub_100319A0(a1) == 5 )
    goto LABEL_4;
  while ( sub_10031910() < v2 )
  {
    sub_10031A90(20);
    if ( sub_100319A0(a1) == 5 )
      goto LABEL_4;
  }
  if ( sub_100319A0(a1) == 5 )
  {
LABEL_4:
    result = 1;
  }
  else
  {
    sub_1000D740("..\\lib\\acl\\tsk\\tsk_usr.c", 1769, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10031B20) --------------------------------------------------------
int __cdecl sub_10031B20(_BYTE *a1)
{
  int v1; // edi@1
  int v2; // eax@2
  char v4; // [sp+8h] [bp-4h]@2

  SYS_enter_krnl();
  v1 = TSK_pvg_wait_evnt(a1);
  SYS_exit_krnl();
  if ( *a1 & 0x20 )
  {
    v2 = sub_100318A0();
    sub_10031930((int)&v4, 5, v2, 4);
  }
  return v1;
}
// 10037CD8: using guessed type int SYS_exit_krnl(void);
// 10037CE4: using guessed type int SYS_enter_krnl(void);
// 10037DE0: using guessed type int __cdecl TSK_pvg_wait_evnt(_DWORD);

//----- (10031B60) --------------------------------------------------------
int __cdecl sub_10031B60(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) != 1 && !a1 )
    result = sub_100319C0(a2);
  return result;
}
// 1005C8F8: using guessed type void *tsk_app_hdr_ptr;

//----- (10031B90) --------------------------------------------------------
int __cdecl sub_10031B90(int a1, int a2)
{
  int result; // eax@2

  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) == 1 )
    result = 0;
  else
    result = sub_100319E0(a1, a2);
  return result;
}
// 1005C8F8: using guessed type void *tsk_app_hdr_ptr;

//----- (10031BB0) --------------------------------------------------------
int __cdecl sub_10031BB0(int a1)
{
  int v1; // ecx@1
  int result; // eax@1

  v1 = 0;
  result = 42066;
  while ( dword_100D9B60[2 * v1] != a1 )
  {
    if ( (unsigned int)++v1 >= 0xA5 )
      return result;
  }
  return dword_100D9B64[2 * v1];
}
// 100D9B60: using guessed type int dword_100D9B60[];
// 100D9B64: using guessed type int dword_100D9B64[];

//----- (10031BF0) --------------------------------------------------------
int __cdecl sub_10031BF0(int a1, int a2, int a3)
{
  return reg_read(a1, a2, a3, 0);
}
// 10037DE6: using guessed type int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10031C10) --------------------------------------------------------
char __cdecl sub_10031C10(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_10031BF0(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_1000D740("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1255, 1, 0);
  return v3;
}

//----- (10031C50) --------------------------------------------------------
int __cdecl sub_10031C50(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // esi@1

  result = sub_10031BF0(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy_0(a2, a4, (unsigned __int16)a3);
    result = v5;
  }
  return result;
}

//----- (10031C90) --------------------------------------------------------
int __cdecl sub_10031C90(int a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_10031BF0(a1 | 0x20000, a2, a3);
  if ( result == -46 )
    result = 0;
  return result;
}

//----- (10031CC0) --------------------------------------------------------
int __cdecl sub_10031CC0(int a1, int a2, int a3)
{
  return reg_write(a1, a2, a3, 0);
}
// 10037DEC: using guessed type int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10031CE0) --------------------------------------------------------
int __cdecl sub_10031CE0(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // eax@2
  int result; // eax@4
  int v6; // [sp+10h] [bp-4h]@1

  v6 = sub_10031CC0(a1, a2, a3);
  v3 = 0;
  if ( (unsigned __int8)sub_10032C50() )
  {
    v4 = sub_10031BB0(a1);
    if ( v4 != 42066 )
      v3 = sub_10031CC0(v4, a2, a3);
  }
  result = v6;
  if ( !v6 )
    result = v3;
  return result;
}
// 10032C50: using guessed type int sub_10032C50(void);

//----- (10031D40) --------------------------------------------------------
int __cdecl sub_10031D40(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  result = sub_10031CE0(a1, a2, a3);
  v4 = result;
  if ( result )
  {
    sub_1000D740("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1742, 1, 0);
    result = v4;
  }
  return result;
}

//----- (10031D80) --------------------------------------------------------
char __cdecl sub_10031D80(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_10031CC0(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_1000D740("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1826, 1, 0);
  return v3;
}

//----- (10031DC0) --------------------------------------------------------
int __cdecl sub_10031DC0(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // edi@1

  result = sub_10031BF0(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy_0(a2, a4, (unsigned __int16)a3);
    sub_10031CC0(a1, (int)a4, a3);
    result = v5;
  }
  return result;
}

//----- (10031E10) --------------------------------------------------------
void sub_10031E10()
{
  dword_10196118 = 0;
  sub_100323F0();
}
// 10196118: using guessed type int dword_10196118;

//----- (10031E20) --------------------------------------------------------
signed int __fastcall sub_10031E20(char *a1)
{
  unsigned __int8 v1; // al@1
  char v2; // dl@1
  char v3; // bl@1
  signed int result; // eax@13

  v1 = *a1;
  v2 = 0;
  v3 = 0;
  if ( !*a1 )
    goto LABEL_17;
  do
  {
    if ( v1 < 0x30u || v1 > 0x39u )
    {
      if ( v1 >= 0x61u && v1 <= 0x7Au || v1 >= 0x41u && v1 <= 0x5Au )
        v2 = 1;
    }
    else
    {
      v3 = 1;
    }
    v1 = (a1++)[1];
  }
  while ( v1 );
  if ( v2 && v3 )
    result = 1;
  else
LABEL_17:
    result = 0;
  return result;
}

//----- (10031E70) --------------------------------------------------------
int __usercall sub_10031E70@<eax>(unsigned int a1@<eax>)
{
  return sub_10032410(a1);
}

//----- (10031E80) --------------------------------------------------------
double __cdecl sub_10031E80(int a1, int a2, float a3, float a4, float a5)
{
  char *v5; // ebp@1
  int v6; // edi@1
  void *v7; // esi@1
  bool v8; // bl@3
  int v9; // eax@6
  int v10; // edi@6
  double v11; // st7@7
  char v12; // al@7
  double v13; // st7@8
  double v14; // st5@8
  int v15; // eax@13
  double v16; // st4@13
  double v17; // st3@13
  double v18; // rt2@13
  double v19; // st3@13
  bool v20; // zf@13
  float v22; // [sp+0h] [bp-8h]@7
  unsigned int v23; // [sp+4h] [bp-4h]@1

  v5 = (char *)a2;
  a4 = a4 + a5;
  v23 = strlen((const char *)a2);
  v6 = a1;
  v7 = &unk_100F8960;
  if ( a1 & 0xC0000000 )
  {
    if ( (a1 & 0xC0000000) == 0x80000000 )
      v8 = (unsigned __int8)sub_10031E20((char *)a2) == 0;
    else
      v8 = 0;
  }
  else
  {
    v8 = 1;
  }
  v9 = sub_10031E70(v6 & 0x3FFFFFFF);
  v10 = v9;
  if ( v9 )
  {
    v11 = a4;
    a4 = a4 - *(float *)(v9 + 8200) * a5;
    v22 = v11 + a5 * *(float *)(v9 + 8204);
    sub_10031BF0(6610, (int)&a1, 1);
    v12 = *v5;
    if ( *v5 )
    {
      v13 = a4;
      v14 = a5;
      do
      {
        if ( (_BYTE)a1 && v8 && v12 == 48 )
          v12 = -122;
        v15 = v10 + 32 * (unsigned __int8)v12;
        ++v5;
        v7 = (char *)v7 + 64;
        a4 = *(float *)(v15 + 16) * v14;
        a3 = *(float *)(v15 + 24) + a3;
        *((float *)v7 - 14) = *(float *)v15;
        *((float *)v7 - 13) = *(float *)(v15 + 8);
        v16 = a3;
        *((float *)v7 - 16) = a3;
        *((float *)v7 - 15) = v13;
        *((float *)v7 - 10) = *(float *)(v15 + 4);
        *((float *)v7 - 9) = *(float *)(v15 + 8);
        a4 = a4 + v16;
        v17 = a4;
        *((float *)v7 - 12) = a4;
        v18 = v17;
        *((float *)v7 - 11) = v13;
        *((float *)v7 - 6) = *(float *)(v15 + 4);
        *((float *)v7 - 5) = *(float *)(v15 + 12);
        *((float *)v7 - 8) = v17;
        *((float *)v7 - 7) = v22;
        *((float *)v7 - 2) = *(float *)v15;
        *((float *)v7 - 1) = *(float *)(v15 + 12);
        *((float *)v7 - 4) = v16;
        *((float *)v7 - 3) = v22;
        v19 = *(float *)(v15 + 28);
        v12 = *v5;
        v20 = *v5 == 0;
        a3 = v18 + v19;
      }
      while ( !v20 );
    }
    j_gdi_pvg_text_out_verts(&unk_100F8960, v23, *(_DWORD *)(v10 + 8212));
  }
  return a3;
}
// 10031790: using guessed type int __cdecl j_gdi_pvg_text_out_verts(_DWORD, _DWORD, _DWORD);

//----- (10032020) --------------------------------------------------------
double __cdecl sub_10032020(int a1, int a2, float a3)
{
  int v3; // eax@1
  double result; // st7@1
  char *v5; // edx@2
  unsigned __int8 i; // cl@2
  int v7; // ecx@3
  float v8; // ST00_4@3
  float v9; // ST00_4@3
  double v10; // st6@3
  float v11; // [sp+0h] [bp-4h]@2

  v3 = sub_10031E70(a1);
  result = 0.0;
  if ( v3 )
  {
    v5 = (char *)a2;
    v11 = 0.0;
    for ( i = *(_BYTE *)a2; *v5; v11 = v10 )
    {
      v7 = v3 + 32 * i;
      ++v5;
      v8 = *(float *)(v7 + 16) * a3 + v11;
      v9 = v8 + *(float *)(v7 + 24);
      v10 = v9 + *(float *)(v7 + 28);
      i = *v5;
    }
    result = v11;
  }
  return result;
}

//----- (10032090) --------------------------------------------------------
signed int __cdecl sub_10032090(unsigned int a1)
{
  signed int result; // eax@7
  int v2; // eax@8
  int v3; // edx@9
  unsigned int v4; // [sp+4h] [bp+4h]@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return FIL_vfs_close();
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_1004B5F0(a1);
    if ( v4 && *(_DWORD *)(v4 + 732) )
    {
      --*(_DWORD *)(*(_DWORD *)(v4 + 732) + 124);
      if ( *(_BYTE *)(v4 + 8) )
        exit_1(v4);
      sub_10053470(v4 + 116);
      result = 0;
      *(_DWORD *)v4 = -858993460;
    }
    else
    {
      result = -6;
    }
    return result;
  }
  if ( !a1 || (a1 & 3) != 2 )
    return FIL_vfs_close();
  v2 = 0;
  if ( !dword_101AEFB8 )
    goto LABEL_11;
  while ( 1 )
  {
    v3 = dword_101AEFC0[v2];
    if ( *(_DWORD *)v3 == a1 )
      break;
    if ( ++v2 >= (unsigned int)dword_101AEFB8 )
      goto LABEL_11;
  }
  if ( v2 != -1 )
  {
    sub_10032C60(
      v2,
      *(_DWORD *)(dword_101AEFC0[v2] + 12),
      *(_DWORD *)(v3 + 16),
      *(_BYTE *)(v3 + 32),
      *(_WORD *)(v3 + 20),
      *(_DWORD *)(v3 + 4));
    result = sub_10032090(a1 & 0xFFFFFFFC);
  }
  else
  {
LABEL_11:
    result = -6;
  }
  return result;
}
// 10037DF8: using guessed type int FIL_vfs_close(void);
// 101AEFB8: using guessed type int dword_101AEFB8;
// 101AEFC0: using guessed type int dword_101AEFC0[];

//----- (100320F0) --------------------------------------------------------
int __cdecl sub_100320F0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-1Ch]@1
  __int64 v7; // [sp+4h] [bp-18h]@1
  __int64 v8; // [sp+10h] [bp-Ch]@1

  v7 = a2;
  v8 = a4;
  return FIL_vfs_memmove_swi(&v6, a1, v7, HIDWORD(v7), a3, v8, HIDWORD(v8), a5);
}
// 10037E0A: using guessed type int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10032160) --------------------------------------------------------
signed int __cdecl sub_10032160(unsigned int a1, void *a2, int a3)
{
  int v3; // eax@7
  unsigned int v4; // eax@4
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_1004B5F0(a1);
    return sub_1004C4B0(v4, (int)a2, a3);
  }
  if ( a1 && (a1 & 3) == 2 )
  {
    v3 = sub_10032320(a1 & 0xFFFFFFFC, 0, 1);
    result = sub_10033000(a1, a2, a3, v3, (unsigned __int64)v3 >> 32);
  }
  else
  {
LABEL_11:
    result = FIL_vfs_read();
  }
  return result;
}
// 10037E1C: using guessed type int FIL_vfs_read(void);

//----- (100321A0) --------------------------------------------------------
signed int __cdecl sub_100321A0(unsigned int a1, void *a2, int a3, int a4, int a5)
{
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
    return sub_1004C6E0(a1, (int)a2, a3, a4);
  if ( a1 && (a1 & 3) == 2 )
    result = sub_10033000(a1, a2, a3, a4, a5);
  else
LABEL_11:
    result = FIL_vfs_read_ofst(a1, a2, a3, &a4);
  return result;
}
// 10037E22: using guessed type int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10032230) --------------------------------------------------------
signed int __cdecl sub_10032230(unsigned int a1, int a2, int a3, int a4)
{
  signed int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = sub_1004C740(a1, a2, a4);
  else
    result = FIL_vfs_seek(a1 & 0xFFFFFFFC, a2, a3, a4);
  return result;
}
// 10037E2E: using guessed type int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10032280) --------------------------------------------------------
__int64 __cdecl sub_10032280(int a1)
{
  return FIL_vfs_size(a1 & 0xFFFFFFFC);
}
// 10037E34: using guessed type int __cdecl FIL_vfs_size(_DWORD);

//----- (100322A0) --------------------------------------------------------
int __cdecl sub_100322A0(int a1, int a2, int a3)
{
  return FIL_vfs_truncate(a1, a2, a3);
}
// 10037E3A: using guessed type int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD);

//----- (100322D0) --------------------------------------------------------
int __cdecl sub_100322D0(int a1, int a2, int a3, char a4)
{
  return FIL_vfs_write_ofst(a1, a2, a3, &a4);
}
// 10037E46: using guessed type int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100322F0) --------------------------------------------------------
char __cdecl sub_100322F0(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 516, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_10032090(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10032150: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10032320) --------------------------------------------------------
signed int __cdecl sub_10032320(unsigned int a1, int a2, int a3)
{
  return sub_10032230(a1, a2, (unsigned __int64)a2 >> 32, a3);
}

//----- (10032340) --------------------------------------------------------
int __cdecl sub_10032340(int a1, int a2, int a3)
{
  return sub_100322A0(a1, a2, a3);
}

//----- (10032360) --------------------------------------------------------
void __cdecl sub_10032360(int a1, _BYTE *a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_get(a1, a2);
  SYS_exit_krnl();
  sub_10033150(a1, a2);
}
// 10037CD8: using guessed type int SYS_exit_krnl(void);
// 10037CE4: using guessed type int SYS_enter_krnl(void);
// 10037E4C: using guessed type int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD);

//----- (10032390) --------------------------------------------------------
int __cdecl sub_10032390(int a1, int a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_set(a1, a2);
  return SYS_exit_krnl();
}
// 10037CD8: using guessed type int SYS_exit_krnl(void);
// 10037CE4: using guessed type int SYS_enter_krnl(void);
// 10037E52: using guessed type int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD);

//----- (100323F0) --------------------------------------------------------
void sub_100323F0()
{
  dword_101A1F48 = -15;
}
// 101A1F48: using guessed type int dword_101A1F48;

//----- (10032400) --------------------------------------------------------
signed int sub_10032400()
{
  return sub_100327D0((int)&off_100D71C4);
}
// 100D71C4: using guessed type char *off_100D71C4;

//----- (10032410) --------------------------------------------------------
int __cdecl sub_10032410(unsigned int a1)
{
  int result; // eax@3

  if ( a1 < 0xC && (unsigned __int8)sub_10032400() )
    result = 8216 * a1 + dword_101A1F48 + 3312;
  else
    result = 0;
  return result;
}
// 101A1F48: using guessed type int dword_101A1F48;

//----- (10032450) --------------------------------------------------------
int __cdecl sub_10032450(int a1, int a2)
{
  int v2; // esi@3

  if ( *(_DWORD *)(a1 + 8) < 0 )
    sub_1000D740("..\\lib\\acl\\kernel\\mem_usr_share.c", 127, 0, 0);
  v2 = j_mem_unmap(a2 - 12, *(_DWORD *)(a1 + 8) + 12);
  if ( v2 )
    sub_1000D740("..\\lib\\acl\\kernel\\mem_usr_share.c", 132, 1, 0);
  return v2;
}
// 10033180: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (100324B0) --------------------------------------------------------
int __usercall sub_100324B0@<eax>(const char **a1@<esi>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // edi@2
  char v3; // ST28_1@2
  unsigned int v4; // eax@5
  char *v5; // edi@9
  char v6; // al@10
  unsigned int v7; // eax@12
  char v8; // ST28_1@12
  signed int v9; // ebx@15
  int v10; // eax@19
  int result; // eax@47
  unsigned int v12; // [sp+Ch] [bp-98h]@1
  int v13; // [sp+14h] [bp-90h]@29
  char v14; // [sp+1Dh] [bp-87h]@30
  char v15; // [sp+1Fh] [bp-85h]@9
  char v16; // [sp+20h] [bp-84h]@8

  v1 = 0;
  v12 = 0;
  if ( *((_BYTE *)a1 + 4) & 2 )
  {
    v2 = j_FIL_vfs_open(*a1, 4, 0);
    v3 = 4;
  }
  else
  {
    strncpy(&v16, *a1, 0x7Du);
    if ( !(*((_BYTE *)a1 + 4) & 8) )
    {
      v5 = &v15;
      do
        v6 = (v5++)[1];
      while ( v6 );
      *(_DWORD *)v5 = 7368052;
    }
    v12 = j_FIL_vfs_open(*a1, 6, 1809);
    v7 = j_FIL_vfs_open(&v16, 14, 1809);
    v2 = v7;
    v8 = 6;
    if ( v7 >= 0xFFFFFFC2 || !v7 )
    {
      sub_1000D740("..\\lib\\acl\\kernel\\mem_usr_share.c", 589, 1, 0);
      goto LABEL_39;
    }
    v9 = sub_10032320(v7, 0, 2);
    if ( v9 < 0 )
    {
      sub_1000D740("..\\lib\\acl\\kernel\\mem_usr_share.c", 602, 1, 0);
      goto LABEL_39;
    }
    if ( (signed int)a1[2] < 0 )
      sub_1000D740("..\\lib\\acl\\kernel\\mem_usr_share.c", 610, 0, 0);
    v10 = (int)(a1[2] + 12);
    if ( v9 < v10 && sub_10032340(v2, v10, (unsigned __int64)v10 >> 32) < 0 )
    {
      sub_1000D740("..\\lib\\acl\\kernel\\mem_usr_share.c", 625, 1, 0);
      goto LABEL_39;
    }
  }
  if ( v2 >= 0xFFFFFFC2 )
    goto LABEL_42;
  if ( v2 )
  {
    v4 = ((int (__cdecl *)(unsigned int, _DWORD, const char *, _DWORD))j_FIL_vfs_mmap)(v2, 0, a1[2] + 12, 0);
    v1 = v4;
    if ( v4 < 0xFFFFFFC2 && v4 )
    {
      if ( !(*((_BYTE *)a1 + 4) & 1) )
      {
        if ( *(_BYTE *)(v4 + 9) || *(_BYTE *)(v4 + 8) != 56 )
        {
          sub_10032450((int)a1, v4 + 12);
          v1 = 0;
        }
        goto LABEL_39;
      }
      *(_DWORD *)(v4 + 4) = sub_10031910();
      if ( *((_BYTE *)a1 + 4) & 4 )
        memset((void *)(v1 + 12), (int)a1[3], (size_t)a1[2]);
      if ( v12 < 0xFFFFFFC2 && v12 )
      {
        if ( *((_BYTE *)a1 + 4) & 8 )
        {
          ++*(_DWORD *)v1;
        }
        else if ( sub_10032160(v12, &v13, 12) == 12 )
        {
          *(_DWORD *)v1 = ++v13;
          v14 = 1;
          *(_BYTE *)(v1 + 9) = 1;
          if ( sub_100322D0(v12, (int)&v13, 12, 0) != 12 )
          {
            sub_1000D740("..\\lib\\acl\\kernel\\mem_usr_share.c", 725, 1, 0);
            goto LABEL_39;
          }
        }
      }
      else
      {
        *(_BYTE *)(v1 + 9) = 1;
        *(_DWORD *)v1 = 1;
      }
      *(_BYTE *)(v1 + 8) = 56;
      if ( !(*((_BYTE *)a1 + 4) & 8) && j_FIL_vfs_rename(&v16, *a1) )
        sub_1000D740("..\\lib\\acl\\kernel\\mem_usr_share.c", 759, 1, 0);
      goto LABEL_39;
    }
    sub_1000D740("..\\lib\\acl\\kernel\\mem_usr_share.c", 664, 0, 0);
  }
LABEL_39:
  if ( v2 < 0xFFFFFFC2 && v2 )
    sub_10032090(v2);
LABEL_42:
  if ( v12 < 0xFFFFFFC2 && v12 )
    sub_10032090(v12);
  if ( v1 < 0xFFFFFFC2 && v1 )
    result = v1 + 12;
  else
    result = v1;
  return result;
}
// 10032140: using guessed type int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10032150: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10032220: using guessed type int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD);

//----- (100327B0) --------------------------------------------------------
int __usercall sub_100327B0@<eax>(int a1@<eax>, int a2@<ecx>)
{
  return j_mem_unmap(a2 - 12, a1 + 12);
}
// 10033180: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (100327D0) --------------------------------------------------------
signed int __cdecl sub_100327D0(int a1)
{
  unsigned int v1; // eax@1
  char v2; // bl@1
  int *v3; // edi@6
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // ebp@6
  unsigned int v8; // eax@15

  v1 = **(_DWORD **)(a1 + 16);
  v2 = 0;
  if ( v1 != -858993460 && (v1 < 0xFFFFFFC2 && v1 || v1 == -15) )
  {
    if ( v1 < 0xFFFFFFC2 && v1 && !*(_BYTE *)(v1 - 3) )
      return 1;
  }
  else
  {
    sub_1000D740("..\\lib\\acl\\kernel\\mem_usr_share.c", 211, 0, *(char **)a1);
    **(_DWORD **)(a1 + 16) = -15;
  }
  v3 = *(int **)(a1 + 16);
  v4 = sub_10031B90(81, 5000);
  v5 = *v3;
  v6 = v4;
  if ( (unsigned int)*v3 < 0xFFFFFFC2 && v5 )
  {
    if ( !*(_BYTE *)(v5 - 3) )
    {
      sub_10031B60(v4, 81);
      return 1;
    }
    *v3 = -15;
    sub_100327B0(*(_DWORD *)(a1 + 8), v5);
  }
  v8 = sub_100324B0((const char **)a1);
  if ( v8 < 0xFFFFFFC2 && v8 )
  {
    *v3 = v8;
    if ( !*(_BYTE *)(v8 - 3) )
      v2 = 1;
  }
  sub_10031B60(v6, 81);
  return (unsigned __int8)v2;
}

//----- (100328A0) --------------------------------------------------------
__int16 __cdecl sub_100328A0(int a1, int a2, int a3, int a4)
{
  __int16 v4; // si@1

  SYS_enter_krnl();
  v4 = HWM_pvg_read_rgn(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10037CD8: using guessed type int SYS_exit_krnl(void);
// 10037CE4: using guessed type int SYS_enter_krnl(void);
// 10037E70: using guessed type int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100328E0) --------------------------------------------------------
__int16 __cdecl sub_100328E0(int a1, _DWORD *a2, _BYTE *a3)
{
  __int16 result; // ax@1
  char v4; // [sp+8h] [bp-ECh]@1
  unsigned __int8 v5; // [sp+Ah] [bp-EAh]@1
  int v6; // [sp+10h] [bp-E4h]@1

  j_HWM_pvg_rgn_get_info(a1, &v4);
  result = v5;
  *a2 = v6;
  *a3 = 2;
  return result;
}
// 100328D0: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (10032980) --------------------------------------------------------
int __cdecl sub_10032980(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_recv_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 10037CD8: using guessed type int SYS_exit_krnl(void);
// 10037CE4: using guessed type int SYS_enter_krnl(void);
// 10037E94: using guessed type int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD);

//----- (100329D0) --------------------------------------------------------
int __cdecl sub_100329D0(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_send_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 10037CD8: using guessed type int SYS_exit_krnl(void);
// 10037CE4: using guessed type int SYS_enter_krnl(void);
// 10037E9A: using guessed type int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD);

//----- (10032A40) --------------------------------------------------------
int __cdecl sub_10032A40(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100128C0(v1);
  a1 = v2;
  v3 = sub_10016EA0(&a1, 4u, (int)&unk_100D7EB8, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100D7EBC[2 * v3];
}
// 100D7EBC: using guessed type int dword_100D7EBC[];

//----- (10032A80) --------------------------------------------------------
int __cdecl sub_10032A80(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100128C0(v1);
  a1 = v2;
  v3 = sub_10016EA0(&a1, 4u, (int)&unk_100D7EF0, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100D7EF4[2 * v3];
}
// 100D7EF4: using guessed type int dword_100D7EF4[];

//----- (10032AC0) --------------------------------------------------------
int __cdecl sub_10032AC0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100128C0(v1);
  a1 = v2;
  v3 = sub_10016EA0(&a1, 4u, (int)&unk_100D7F28, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100D7F2C[2 * v3];
}
// 100D7F2C: using guessed type int dword_100D7F2C[];

//----- (10032B00) --------------------------------------------------------
int __cdecl sub_10032B00(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100128C0(v1);
  a1 = v2;
  v3 = sub_10016EA0(&a1, 4u, (int)&unk_100D7F60, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100D7F64[2 * v3];
}
// 100D7F64: using guessed type int dword_100D7F64[];

//----- (10032B40) --------------------------------------------------------
int __cdecl sub_10032B40(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // eax@2
  int v6; // eax@8

  result = 0;
  if ( a1 )
  {
    v5 = sub_10032A80(a4);
    result = sub_10031BF0(v5, a1, 104);
  }
  if ( a2 && !result )
    result = sub_10031BF0(3532, a2, 2);
  if ( a3 )
  {
    if ( !result )
    {
      v6 = sub_10032A40(a4);
      result = sub_10031BF0(v6, a3, 6);
    }
  }
  return result;
}

//----- (10032BB0) --------------------------------------------------------
int __cdecl sub_10032BB0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  int v5; // eax@3
  int v6; // eax@6
  int v7; // eax@7

  result = 0;
  if ( a1 )
  {
    v4 = sub_10032B00(a3);
    result = sub_10031BF0(v4, a1, 64);
    if ( result == -7 )
    {
      sub_10031A90(100);
      v5 = sub_10032B00(a3);
      result = sub_10031BF0(v5, a1, 64);
    }
  }
  if ( a2 && !result )
  {
    v6 = sub_10032AC0(a3);
    result = sub_10031BF0(v6, a2, 8);
    if ( result == -7 )
    {
      sub_10031A90(100);
      v7 = sub_10032AC0(a3);
      result = sub_10031BF0(v7, a2, 8);
    }
  }
  return result;
}

//----- (10032C60) --------------------------------------------------------
unsigned int __cdecl sub_10032C60(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6)
{
  size_t v6; // ebp@1
  int *v7; // esi@1
  size_t v8; // ebx@1
  int v9; // edx@1
  unsigned int v10; // edi@1
  int v11; // ebx@2
  int v12; // edx@3
  int *v13; // ebp@3
  int v14; // eax@3
  int v15; // eax@3
  unsigned int result; // eax@4
  void **v17; // [sp+10h] [bp-Ch]@1
  void **v18; // [sp+20h] [bp+4h]@1

  v6 = 8 * a5;
  v7 = &dword_101AEFC0[a1];
  v8 = 32 * (a3 / (1 << a4));
  v9 = a2 - v8 - v6;
  *v7 = v9 + a3 - 52;
  v17 = (void **)&dword_101AEF78[a1];
  dword_101AEF78[a1] = a3 + v9;
  dword_101AEF38[a1] = a3 + a2 - v8;
  v18 = (void **)&dword_101AEF38[a1];
  memset((void *)(v9 + a3 - 52), 0, 0x34u);
  memset(*v17, 0, v6);
  memset(*v18, 0, v8);
  *(_DWORD *)(*v7 + 24) = 1 << a4;
  *(_DWORD *)(*v7 + 28) = ~(*(_DWORD *)(*v7 + 24) - 1);
  *(_BYTE *)(*v7 + 32) = a4;
  *(_DWORD *)(*v7 + 12) = a2;
  *(_DWORD *)(*v7 + 16) = a3;
  *(_DWORD *)(*v7 + 8) = a3 / (1 << a4) - (v8 + v6 + 52) / (1 << a4) - 1;
  *(_DWORD *)(*v7 + 4) = a6;
  *(_WORD *)(*v7 + 20) = a5;
  *(_DWORD *)*v7 = -1;
  *(_DWORD *)(*v7 + 36) = *v7 + 36;
  *(_DWORD *)(*v7 + 40) = *v7 + 36;
  *(_DWORD *)(*v7 + 44) = *v7 + 44;
  *(_DWORD *)(*v7 + 48) = *v7 + 44;
  v10 = 0;
  if ( *(_DWORD *)(*v7 + 8) )
  {
    v11 = 0;
    do
    {
      v12 = *v7;
      v13 = *(int **)(*v7 + 40);
      v14 = (int)*v18 + v11;
      *(_DWORD *)(v12 + 40) = v14;
      *(_DWORD *)v14 = v12 + 36;
      *(_DWORD *)(v14 + 4) = v13;
      *v13 = v14;
      v15 = a2 + v10++ * *(_DWORD *)(*v7 + 24);
      *(_DWORD *)((char *)*v18 + v11 + 28) = v15;
      v11 += 32;
    }
    while ( v10 < *(_DWORD *)(*v7 + 8) );
  }
  result = 0;
  if ( *(_WORD *)(*v7 + 20) )
  {
    do
    {
      *((_DWORD *)*v17 + 2 * result) = (char *)*v17 + 8 * result;
      *((_DWORD *)*v17 + 2 * result + 1) = (char *)*v17 + 8 * result;
      ++result;
    }
    while ( result < *(_WORD *)(*v7 + 20) );
  }
  return result;
}
// 101AEF78: using guessed type int dword_101AEF78[];
// 101AEFC0: using guessed type int dword_101AEFC0[];

//----- (10032E10) --------------------------------------------------------
int __usercall sub_10032E10@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int *v2; // ecx@1
  int result; // eax@2
  int v4; // eax@3
  int v5; // ecx@3
  _DWORD *v6; // edx@3
  int v7; // ecx@3
  _DWORD *v8; // edx@3
  int v9; // ecx@3
  int v10; // edx@3

  v1 = dword_101AEFC0[a1];
  v2 = (int *)(v1 + 36);
  if ( (int *)*v2 == v2 )
  {
    v4 = *(_DWORD *)(v1 + 44);
    v5 = *(_DWORD *)(v4 - 8);
    v6 = *(_DWORD **)(v4 - 4);
    result = v4 - 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v7 = *(_DWORD *)(result + 8);
    v8 = *(_DWORD **)(result + 12);
    *(_DWORD *)(v7 + 4) = v8;
    *v8 = v7;
    v9 = dword_101AEFC0[a1];
    v10 = *(_DWORD *)(v9 + 36);
    v9 += 36;
    *(_DWORD *)(v10 + 4) = result;
    *(_DWORD *)result = v10;
    *(_DWORD *)(result + 4) = v9;
    *(_DWORD *)v9 = result;
  }
  else
  {
    result = *v2;
  }
  return result;
}
// 101AEFC0: using guessed type int dword_101AEFC0[];

//----- (10032EC0) --------------------------------------------------------
int __cdecl sub_10032EC0(int a1, unsigned __int64 a2)
{
  int v2; // edi@1
  int *v3; // ebx@1
  signed int v4; // eax@1
  _DWORD *v5; // ecx@2
  int v6; // eax@2
  int *v7; // eax@2
  int v8; // ecx@2
  _DWORD *v9; // edx@2
  int v10; // eax@2
  int v11; // ecx@2
  int result; // eax@2

  v2 = sub_10032E10(a1);
  v3 = &dword_101AEFC0[a1];
  v4 = sub_100321A0(
         *(_DWORD *)dword_101AEFC0[a1] & 0xFFFFFFFC,
         *(void **)(v2 + 28),
         *(_DWORD *)(dword_101AEFC0[a1] + 24),
         a2,
         SHIDWORD(a2));
  if ( v4 <= 0 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD **)(v2 + 4);
    *(_WORD *)(v2 + 24) = v4;
    v6 = *(_DWORD *)v2;
    *(_QWORD *)(v2 + 16) = a2;
    *(_DWORD *)(v6 + 4) = v5;
    *v5 = v6;
    v7 = (int *)(dword_101AEF78[a1] + 8 * ((unsigned int)(a2 >> *(_BYTE *)(*v3 + 32)) % *(_WORD *)(*v3 + 20)));
    v8 = *v7;
    *(_DWORD *)(v8 + 4) = v2;
    *(_DWORD *)(v2 + 4) = v7;
    *(_DWORD *)v2 = v8;
    *v7 = v2;
    v9 = *(_DWORD **)(*v3 + 48);
    v10 = *v3 + 44;
    v11 = v2 + 8;
    *(_DWORD *)(v10 + 4) = v2 + 8;
    *(_DWORD *)v11 = v10;
    result = v2;
    *(_DWORD *)(v11 + 4) = v9;
    *v9 = v2 + 8;
  }
  return result;
}
// 101AEF78: using guessed type int dword_101AEF78[];
// 101AEFC0: using guessed type int dword_101AEFC0[];

//----- (10032F70) --------------------------------------------------------
int __usercall sub_10032F70@<eax>(int a1@<ebx>, unsigned __int64 a2)
{
  int *v2; // edi@1
  int *v3; // ecx@1
  int result; // eax@1
  int v5; // edx@5
  _DWORD *v6; // esi@5
  int v7; // ecx@5
  _DWORD *v8; // esi@5
  int v9; // edx@5

  v2 = &dword_101AEFC0[a1];
  v3 = (int *)(dword_101AEF78[a1]
             + 8 * ((unsigned int)(a2 >> *(_BYTE *)(dword_101AEFC0[a1] + 32)) % *(_WORD *)(dword_101AEFC0[a1] + 20)));
  result = *v3;
  if ( (int *)*v3 == v3 )
  {
LABEL_4:
    result = sub_10032EC0(a1, a2);
  }
  else
  {
    while ( *(_QWORD *)(result + 16) != a2 )
    {
      result = *(_DWORD *)result;
      if ( (int *)result == v3 )
        goto LABEL_4;
    }
    v5 = *(_DWORD *)(result + 8);
    v6 = *(_DWORD **)(result + 12);
    v7 = result + 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v8 = *(_DWORD **)(*v2 + 48);
    v9 = *v2 + 44;
    *(_DWORD *)(v9 + 4) = result + 8;
    *(_DWORD *)(v7 + 4) = v8;
    *(_DWORD *)v7 = v9;
    *v8 = result + 8;
  }
  return result;
}
// 101AEF78: using guessed type int dword_101AEF78[];
// 101AEFC0: using guessed type int dword_101AEFC0[];

//----- (10033000) --------------------------------------------------------
unsigned int __cdecl sub_10033000(int a1, void *a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // edx@2
  unsigned int result; // eax@4
  int v10; // eax@7
  int v11; // esi@10
  int v12; // eax@10
  int v13; // ecx@11
  unsigned int v14; // eax@11
  const void *v15; // ecx@11
  size_t v16; // esi@12
  int v17; // ecx@13
  int v18; // et0@17

  v5 = a3;
  v6 = 0;
  v7 = a4;
  if ( !dword_101AEFB8 )
    goto LABEL_24;
  while ( 1 )
  {
    v8 = dword_101AEFC0[v6];
    if ( *(_DWORD *)v8 == a1 )
      break;
    if ( ++v6 >= (unsigned int)dword_101AEFB8 )
      return -1;
  }
  if ( v6 != -1 )
  {
    v10 = *(_DWORD *)(v8 + 4);
    if ( v10 != 138 )
      sub_100319E0(v10, -1);
    if ( a3 )
    {
      while ( 1 )
      {
        v11 = v7 & ~*(_DWORD *)(dword_101AEFC0[v6] + 28);
        v12 = sub_10032F70(v6, (unsigned int)v7 & *(_DWORD *)(dword_101AEFC0[v6] + 28));
        if ( !v12 )
          break;
        v13 = *(_DWORD *)(v12 + 28);
        v14 = *(_WORD *)(v12 + 24) - v11;
        v15 = (const void *)(v11 + v13);
        if ( v5 <= v14 )
        {
          v16 = v5;
        }
        else
        {
          v16 = v14;
          if ( !v14 )
            goto LABEL_13;
        }
        memcpy_0(a2, v15, v16);
        v5 -= v16;
        v18 = (v16 + __PAIR__((unsigned int)a5, v7)) >> 32;
        v7 += v16;
        a5 = v18;
        a2 = (char *)a2 + v16;
        if ( !v5 )
          goto LABEL_13;
      }
      if ( *(_DWORD *)(dword_101AEFC0[v6] + 4) != 138 )
        sub_100319C0(*(_DWORD *)(dword_101AEFC0[v6] + 4));
      result = -1;
    }
    else
    {
LABEL_13:
      v17 = dword_101AEFC0[v6];
      if ( *(_DWORD *)(v17 + 4) != 138 )
        sub_100319C0(*(_DWORD *)(v17 + 4));
      result = a3 - v5;
    }
  }
  else
  {
LABEL_24:
    result = -1;
  }
  return result;
}
// 101AEFB8: using guessed type int dword_101AEFB8;
// 101AEFC0: using guessed type int dword_101AEFC0[];

//----- (10033150) --------------------------------------------------------
void __cdecl sub_10033150(__int16 a1, _BYTE *a2)
{
  void *v2; // ecx@0
  void *v3; // ecx@2

  if ( a1 == 29 && sub_1000EB10(v2) && sub_1000EB70(v3) != 1 )
    *a2 = 0;
}

//----- (10033190) --------------------------------------------------------
char sub_10033190()
{
  unsigned __int8 v0; // cl@2
  signed int v1; // eax@4

  if ( !sub_10012E40() )
  {
    LOBYTE(v1) = 0;
    return v1;
  }
  v0 = *(_BYTE *)(dword_101F03DC + 1200);
  if ( v0 || (v0 = *(_BYTE *)(dword_101F03DC + 814)) != 0 )
  {
    LOBYTE(v1) = v0;
    if ( v0 < 4u )
      return v1;
    v1 = 4;
  }
  else
  {
    v1 = *(_BYTE *)(dword_101F03DC + 122) == 0;
  }
  if ( v1 == 4 )
    LOBYTE(v1) = 0;
  return v1;
}
// 101F03DC: using guessed type int dword_101F03DC;

//----- (100331E0) --------------------------------------------------------
double __cdecl sub_100331E0(char a1)
{
  double v1; // st7@5
  double result; // st7@9
  float v3; // [sp+0h] [bp-4h]@1

  v3 = 0.0;
  if ( !sub_10012E40() )
    goto LABEL_13;
  if ( !a1 )
  {
    v1 = *(float *)(dword_101F03DC + 124);
    goto LABEL_8;
  }
  if ( a1 == 2 )
  {
    v1 = *(float *)(dword_101F03DC + 860);
    goto LABEL_8;
  }
  if ( a1 == 3 )
  {
    v1 = *(float *)(dword_101F03DC + 1204);
LABEL_8:
    v3 = v1;
  }
  result = v3;
  if ( (LODWORD(v3) & 0x7F800000) == 2139095040 || result > 3.141592502593994 || result < -3.141592502593994 )
  {
    v3 = 0.0;
LABEL_13:
    result = v3;
  }
  return result;
}
// 101F03DC: using guessed type int dword_101F03DC;

//----- (10033270) --------------------------------------------------------
char sub_10033270()
{
  char result; // al@2

  if ( sub_10012E40() )
    result = *(_BYTE *)(dword_101F03DC + 661);
  else
    result = 0;
  return result;
}
// 101F03DC: using guessed type int dword_101F03DC;

//----- (10033290) --------------------------------------------------------
char __cdecl sub_10033290(char a1)
{
  char v1; // bl@1
  unsigned __int8 v2; // al@2
  char v3; // al@3

  v1 = 0;
  if ( sub_10012E40() )
  {
    sub_100162E0();
    v2 = *(_BYTE *)(dword_101F03DC + 812);
    if ( v2 != -1 )
    {
      v3 = *(_BYTE *)(180 * v2 + dword_101F03D0 + 671);
      if ( (v3 == 18 || v3 == 19 || v3 == 20 || v3 == 21 || v3 == 22) && (!a1 || v3 == 21) )
        v1 = 1;
    }
    sub_100162D0();
  }
  return v1;
}
// 101F03D0: using guessed type int dword_101F03D0;
// 101F03DC: using guessed type int dword_101F03DC;

//----- (10033300) --------------------------------------------------------
char __cdecl sub_10033300(int a1)
{
  char result; // al@1
  int v2; // ecx@2
  char v3; // al@4
  unsigned __int8 v4; // al@16

  *(_DWORD *)(a1 + 16) = 0x3FFFF;
  *(_BYTE *)a1 = -1;
  *(_DWORD *)(a1 + 20) = 0x3FFFF;
  *(_BYTE *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_BYTE *)(a1 + 2) = 1;
  *(_BYTE *)(a1 + 3) = 1;
  *(_BYTE *)(a1 + 4) = 6;
  *(_BYTE *)(a1 + 5) = -1;
  *(_BYTE *)(a1 + 6) = 0;
  *(_BYTE *)(a1 + 7) = -1;
  *(_BYTE *)(a1 + 9) = 0;
  *(_BYTE *)(a1 + 13) = 0;
  *(_BYTE *)(a1 + 10) = -1;
  *(_BYTE *)(a1 + 11) = 0;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 12) = 0;
  *(_BYTE *)(a1 + 14) = 1;
  *(_BYTE *)(a1 + 15) = 0;
  result = sub_10012E40();
  if ( result )
  {
    sub_100162E0();
    *(_BYTE *)(a1 + 8) = *(_BYTE *)(dword_101F03DC + 815);
    *(_BYTE *)(a1 + 4) = *(_BYTE *)(dword_101F03DC + 94);
    *(_BYTE *)(a1 + 11) = *(_BYTE *)(dword_101F03DC + 97);
    *(_BYTE *)(a1 + 1) = *(_BYTE *)(dword_101F03D0 + 239);
    *(_BYTE *)(a1 + 15) = *(_BYTE *)(dword_101F03DC + 826);
    strncpy((char *)(a1 + 24), (const char *)(dword_101F03DC + 872), 0xCu);
    *(_BYTE *)(a1 + 35) = 0;
    *(_BYTE *)(a1 + 6) = *(_BYTE *)(dword_101F03DC + 784);
    *(_BYTE *)(a1 + 14) = 0;
    v2 = dword_101F03DC;
    if ( *(_BYTE *)(dword_101F03DC + 669) && !*(_BYTE *)(dword_101F03DC + 667)
      || (v3 = *(_BYTE *)(dword_101F03DC + 159)) != 0
      && *(_BYTE *)(dword_101F03DC + 667)
      && !*(_BYTE *)(dword_101F03DC + 661)
      && (v3 != 2 || -1.0 == *(float *)(dword_101F03DC + 116))
      || !*(_BYTE *)(dword_101F03DC + 672) )
    {
      *(_BYTE *)(a1 + 14) = 1;
      v2 = dword_101F03DC;
    }
    else if ( *(_BYTE *)(dword_101F03DC + 101) == 4
           && *(_BYTE *)(dword_101F03DC + 812) >= *(_BYTE *)(dword_101F03D0 + 241)
           && !*(_BYTE *)(dword_101F03DC + 89)
           && -1.0 == *(float *)(dword_101F03DC + 116) )
    {
      *(_BYTE *)(a1 + 14) = 1;
      v2 = dword_101F03DC;
    }
    *(_BYTE *)(a1 + 9) = *(_BYTE *)(v2 + 816);
    *(_BYTE *)(a1 + 5) = *(_BYTE *)(dword_101F03D0 + 241);
    v4 = *(_BYTE *)(a1 + 9) - 1;
    *(_BYTE *)(a1 + 10) = *(_BYTE *)(dword_101F03D0 + 244);
    if ( v4 > 2u )
    {
      *(_BYTE *)(a1 + 9) = 0;
      *(_DWORD *)(a1 + 16) = 0x3FFFF;
      *(_DWORD *)(a1 + 20) = 0x3FFFF;
      *(_BYTE *)(a1 + 12) = 0;
      *(_BYTE *)a1 = -1;
      *(_BYTE *)(a1 + 2) = 1;
      *(_BYTE *)(a1 + 3) = 1;
      *(_BYTE *)(a1 + 7) = -1;
      *(_BYTE *)(a1 + 14) = 1;
      result = sub_100162D0();
    }
    else
    {
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(dword_101F03DC + 836);
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(dword_101F03DC + 840);
      *(_BYTE *)a1 = *(_BYTE *)(dword_101F03DC + 812);
      *(_BYTE *)(a1 + 13) = *(_BYTE *)(dword_101F03DC + 825);
      if ( *(_DWORD *)(dword_101F03DC + 892) )
        *(_BYTE *)(a1 + 3) = 0;
      else
        *(_BYTE *)(a1 + 3) = *(_BYTE *)(dword_101F03DC + 288);
      *(_BYTE *)(a1 + 2) = *(_BYTE *)(dword_101F03DC + 288);
      *(_BYTE *)(a1 + 7) = *(_BYTE *)(dword_101F03DC + 813);
      *(_BYTE *)(a1 + 12) = *(_BYTE *)(dword_101F03D0 + 4);
      result = sub_100162D0();
    }
  }
  return result;
}
// 101F03D0: using guessed type int dword_101F03D0;
// 101F03DC: using guessed type int dword_101F03DC;

//----- (10033550) --------------------------------------------------------
void __cdecl sub_10033550(float *a1, float *a2, float *a3, int a4)
{
  float v4; // [sp+0h] [bp-4h]@1

  sub_10033C20(a1, a2, a4);
  v4 = sqrt(sub_10033CE0(a4, a4));
  *a3 = v4;
  if ( v4 >= 0.1000000014901161 )
  {
    *(float *)a4 = *(float *)a4 / v4;
    *(float *)(a4 + 4) = *(float *)(a4 + 4) / *a3;
  }
  else
  {
    *(float *)(a4 + 4) = 1.0;
    *(float *)a4 = 0.0;
  }
}

//----- (100335B0) --------------------------------------------------------
int __cdecl sub_100335B0(float a1, float a2, int a3)
{
  float v3; // ST00_4@1
  float v4; // ST04_4@1
  float v5; // ST00_4@1
  float v6; // ST04_4@1
  double v7; // ST08_8@1
  float v8; // ST04_4@1
  float v9; // ST00_4@1
  float v10; // ST04_4@1
  float v11; // ST04_4@1
  double v12; // ST08_8@1
  float v13; // ST04_4@1
  float v14; // ST00_4@1
  float v15; // ST04_4@1
  float v16; // ST04_4@1
  double v17; // ST08_8@1
  float v18; // ST04_4@1
  float v19; // ST00_4@1
  float v20; // ST04_4@1
  float v21; // ST04_4@1
  double v22; // ST08_8@1
  float v23; // ST04_4@1
  float v24; // ST00_4@1
  float v25; // ST04_4@1
  int result; // eax@1
  float v27; // ST04_4@1
  float v28; // ST04_4@1
  float v29; // [sp+18h] [bp+8h]@1
  float v30; // [sp+18h] [bp+8h]@1

  v3 = sin(a2 * 4.0);
  v4 = v3;
  v5 = sin(a1 * 4.0);
  v6 = v4 - v5;
  v7 = v6 * 0.00001062759019987425 * 0.25;
  v8 = sin(a2 + a2);
  v9 = v8;
  v10 = sin(a1 + a1);
  v11 = v9 - v10;
  v12 = v7 - v11 * 0.00506310909986496 * 0.5;
  v13 = sin(a2 * 6.0);
  v14 = v13;
  v15 = sin(a1 * 6.0);
  v16 = v14 - v15;
  v17 = v12 - v16 * 0.00000002082037831030448 / 6.0;
  v18 = sin(a2 * 8.0);
  v19 = v18;
  v20 = sin(a1 * 8.0);
  v21 = v19 - v20;
  v22 = v21 * 3.932370748471747e-11 * 0.125 + v17;
  v23 = sin(a2 * 10.0);
  v24 = v23;
  v25 = sin(a1 * 10.0);
  result = a3;
  v27 = v24 - v25;
  v28 = v22 - v27 * 7.108452959288594e-14 / 10.0;
  v29 = a2 - a1;
  v30 = v29 * 1.005052447319031;
  *(float *)a3 = fabs((v28 + v30) * 6335439.327292892);
  return result;
}

//----- (10033770) --------------------------------------------------------
void __cdecl sub_10033770(int a1, int a2, float *a3, float *a4, float *a5)
{
  float v5; // ST38_4@1
  float v6; // ST38_4@1
  long double v7; // ST38_8@5
  long double v8; // ST48_8@5
  long double v9; // st7@5
  signed int v10; // ebx@5
  long double v11; // st5@5
  long double v12; // st7@5
  long double v13; // st7@6
  double v14; // st7@6
  double v15; // st4@6
  double v16; // st3@6
  double v17; // st2@8
  double v18; // STB8_8@8
  double v19; // ST60_8@10
  double v20; // ST50_8@10
  long double v21; // st7@10
  long double v22; // st7@10
  double v23; // [sp+40h] [bp-90h]@6
  double v24; // [sp+48h] [bp-88h]@6
  double v25; // [sp+50h] [bp-80h]@5
  double v26; // [sp+58h] [bp-78h]@5
  double v27; // [sp+60h] [bp-70h]@5
  double v28; // [sp+68h] [bp-68h]@6
  double v29; // [sp+70h] [bp-60h]@6
  double v30; // [sp+78h] [bp-58h]@5
  double v31; // [sp+80h] [bp-50h]@6
  double v32; // [sp+88h] [bp-48h]@6
  double v33; // [sp+90h] [bp-40h]@5
  double v34; // [sp+98h] [bp-38h]@5
  double v35; // [sp+A0h] [bp-30h]@8
  double v36; // [sp+A8h] [bp-28h]@6
  double v37; // [sp+B0h] [bp-20h]@5
  double v38; // [sp+C0h] [bp-10h]@5

  v5 = *(float *)(a2 + 4) - *(float *)(a1 + 4);
  v6 = fabs(sub_10037890(v5));
  if ( v6 >= 0.000001 )
  {
    v7 = sin(*(float *)a1) * 0.9966471893352525 / cos(*(float *)a1);
    v8 = sin(*(float *)a2) * 0.9966471893352525 / cos(*(float *)a2);
    v33 = 1.0 / sqrt(v7 * v7 + 1.0);
    v9 = 1.0 / sqrt(v8 * v8 + 1.0);
    v10 = 0;
    v37 = v9;
    v34 = v33 * v9;
    v25 = v34 * v8;
    v27 = v25 * v7;
    v26 = *(float *)(a2 + 4) - *(float *)(a1 + 4);
    v11 = v9;
    v12 = v26;
    v30 = v11 * (v33 * v7);
    v38 = v27 + v27;
    do
    {
      v29 = sin(v12);
      v13 = cos(v26);
      v32 = v13;
      v24 = v25 - v13 * v30;
      v36 = sqrt(v29 * v37 * (v29 * v37) + v24 * v24);
      v28 = v13 * v34 + v27;
      v23 = sub_10037A30(v36, v28);
      v14 = v29 * v34 / v36;
      v15 = 1.0 - v14 * v14;
      v16 = v38;
      v31 = v38;
      if ( v15 > 0.0 )
      {
        v16 = v28 - v38 / v15;
        v31 = v16;
      }
      ++v10;
      v35 = v16 * v16 + v16 * v16 - 1.0;
      v17 = v15 * ((4.0 - v15 * 3.0) * 0.00335281066474748 + 4.0) * 0.00335281066474748 * 0.0625;
      v18 = v26;
      v12 = 0.00335281066474748 * ((1.0 - v17) * (v14 * (v36 * (v16 + v35 * v28 * v17) * v17 + v23)))
          + *(float *)(a2 + 4)
          - *(float *)(a1 + 4);
      v26 = v12;
    }
    while ( fabs(v18 - v12) > 0.00000005 && v10 < 20 );
    v19 = sub_10037A30(v29 * v37, v24);
    v20 = sub_10037A30(v29 * v33, v32 * v25 - v30);
    v21 = sqrt(v15 * 0.006739496742276252 + 1.0);
    v22 = (v21 + 1.0 - 2.0) / (v21 + 1.0);
    *a3 = (0.25 * (v22 * v22) + 1.0)
        / (1.0 - v22)
        * ((v22 * 0.375 * v22 - 1.0)
         * v22
         * (v36
          * (v31
           + ((1.0 - v35 - v35) * (v36 * v36 * 4.0 - 3.0) * v31 * ((v22 * 0.375 * v22 - 1.0) * v22) / 6.0 - v35 * v28)
           * ((v22 * 0.375 * v22 - 1.0)
            * v22)
           * 0.25))
         + v23)
        * 6378137.0
        * 0.9966471893352525;
    *a4 = v19;
    *a5 = v20;
  }
  else
  {
    sub_100335B0(*(float *)a1, *(float *)a2, (int)a3);
    if ( *(float *)a1 >= (double)*(float *)a2 )
    {
      *a4 = 3.1415925;
      *a5 = 3.1415925;
    }
    else
    {
      *a4 = 0.0;
      *a5 = 0.0;
    }
  }
}

//----- (10033B40) --------------------------------------------------------
void __cdecl sub_10033B40(int a1, int a2, float *a3, float *a4)
{
  float v4; // ST14_4@1
  float v5; // ST14_4@1
  float v6; // [sp+Ch] [bp-1Ch]@1
  float v7; // [sp+10h] [bp-18h]@1
  float v8; // [sp+14h] [bp-14h]@1
  float v9; // [sp+18h] [bp-10h]@1
  float v10; // [sp+1Ch] [bp-Ch]@1
  float v11; // [sp+20h] [bp-8h]@3
  float v12; // [sp+24h] [bp-4h]@3

  sub_100378D0(a1, (int)&v9);
  sub_100378D0(a2, (int)&v7);
  v4 = v10 - v8;
  v6 = sub_10037890(v4);
  v5 = v9 - v7;
  if ( COERCE_FLOAT(LODWORD(v5) & 0x7FFFFFFF) >= 0.0014486233 || COERCE_FLOAT(LODWORD(v6) & 0x7FFFFFFF) >= 0.0014486233 )
  {
    sub_10033770((int)&v9, (int)&v7, a3, a4, &v6);
  }
  else
  {
    sub_10033550(&v9, &v7, a3, (int)&v11);
    *a4 = sub_10037AA0(v11, v12);
  }
}

//----- (10033C20) --------------------------------------------------------
void __cdecl sub_10033C20(float *a1, float *a2, int a3)
{
  float *v3; // esi@1
  float *v4; // edi@1
  int v5; // [sp+18h] [bp-8h]@1
  int v6; // [sp+1Ch] [bp-4h]@1
  float v7; // [sp+24h] [bp+4h]@1
  float v8; // [sp+24h] [bp+4h]@1
  float v9; // [sp+24h] [bp+4h]@1
  float v10; // [sp+24h] [bp+4h]@1
  float v11; // [sp+28h] [bp+8h]@1
  float v12; // [sp+28h] [bp+8h]@1

  v3 = a1;
  v4 = a2;
  v7 = (*a1 + *a2) * 0.5;
  sub_10037990(v7, (int)&v5, (int)&v6);
  v8 = 1.0 / (1.0 - *(float *)&v5 * (0.00669437999013 * *(float *)&v5));
  v11 = sqrt(v8) * 6378137.0;
  v9 = 0.99330562000987 * v11 * v8;
  v12 = v11 * *(float *)&v6;
  *(float *)(a3 + 4) = (*v4 - *v3) * v9;
  v10 = v4[1] - v3[1];
  *(float *)a3 = v10;
  *(float *)a3 = sub_10037890(v10) * v12;
}

//----- (10033CE0) --------------------------------------------------------
double __cdecl sub_10033CE0(int a1, int a2)
{
  return (float)(*(float *)(a1 + 4) * *(float *)(a2 + 4) + *(float *)a1 * *(float *)a2);
}

//----- (10033D00) --------------------------------------------------------
int __cdecl sub_10033D00(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int result; // eax@17

  if ( a2 < 0 )
    a2 = 0;
  if ( a3 < 0 )
    a3 = 0;
  if ( a4 < 1 )
    a4 = 1;
  if ( a5 < 1 )
    a5 = 1;
  if ( a2 >= (signed int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 6) )
    a2 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) - 1;
  if ( a4 + a2 > *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) )
    a4 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) - a2;
  if ( a3 >= (signed int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 4) )
    a3 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) - 1;
  if ( a5 + a3 > *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) )
    a5 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) - a3;
  *(_WORD *)(a1 + 26) = a2;
  HIWORD(result) = HIWORD(a1);
  *(_WORD *)(a1 + 30) = a4;
  LOWORD(result) = a3;
  *(_WORD *)(a1 + 24) = a3;
  *(_WORD *)(a1 + 28) = a5;
  return result;
}

//----- (10033E10) --------------------------------------------------------
unsigned int __cdecl sub_10033E10(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8)
{
  unsigned int result; // eax@2
  int v9; // [sp+8h] [bp+8h]@1

  v9 = sub_10034950(a1, a2, a3, a4, a5, a6, a7, a8);
  if ( *(_BYTE *)(*(_DWORD *)(v9 + 52) + 8) == 8 )
  {
    if ( *(_DWORD *)(v9 + 68) )
    {
      if ( *(_BYTE *)(*(_DWORD *)(v9 + 56) + 8) == 1 )
      {
        *(_WORD *)(v9 + 38) = **(_WORD **)(v9 + 68);
        *(_WORD *)(v9 + 36) = *(_WORD *)(*(_DWORD *)(v9 + 68) + 2);
        result = sub_10033EF0(v9);
      }
      else
      {
        result = sub_10034420(v9);
      }
    }
    else if ( *(_BYTE *)(*(_DWORD *)(v9 + 56) + 8) == 8 )
    {
      result = sub_10034240(v9);
    }
    else
    {
      result = sub_10034420(v9);
    }
  }
  else
  {
    result = sub_10034420(v9);
  }
  return result;
}

//----- (10033EF0) --------------------------------------------------------
int __cdecl sub_10033EF0(int a1)
{
  int result; // eax@1
  int v2; // ST1C_4@10
  int v3; // [sp+0h] [bp-44h]@3
  unsigned int v4; // [sp+4h] [bp-40h]@5
  unsigned int v5; // [sp+4h] [bp-40h]@9
  unsigned __int16 v6; // [sp+8h] [bp-3Ch]@3
  int v7; // [sp+Ch] [bp-38h]@5
  unsigned __int16 v8; // [sp+10h] [bp-34h]@3
  unsigned __int16 v9; // [sp+14h] [bp-30h]@2
  signed int v10; // [sp+1Ch] [bp-28h]@9
  unsigned int *v11; // [sp+20h] [bp-24h]@9
  int v12; // [sp+24h] [bp-20h]@11
  int v13; // [sp+28h] [bp-1Ch]@9
  unsigned int v14; // [sp+2Ch] [bp-18h]@9
  unsigned __int16 v15; // [sp+30h] [bp-14h]@2
  unsigned int *v16; // [sp+34h] [bp-10h]@3
  int v17; // [sp+38h] [bp-Ch]@4
  unsigned int v18; // [sp+3Ch] [bp-8h]@2
  unsigned __int16 v19; // [sp+40h] [bp-4h]@2
  int v20; // [sp+4Ch] [bp+8h]@1

  result = sub_10035E00(a1);
  v20 = result;
  if ( result )
  {
    v19 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v18 = ((unsigned int)*(_WORD *)(result + 14) >> 3)
        + *(_WORD *)(result + 12) * *(_WORD *)(*(_DWORD *)(result + 56) + 10)
        + **(_DWORD **)(result + 56);
    v9 = 8 * (*(_WORD *)(result + 14) >> 3) - *(_WORD *)(result + 14) + 8;
    v15 = *(_WORD *)(*(_DWORD *)(result + 52) + 10);
    if ( !(*(_WORD *)(*(_DWORD *)(result + 52) + 10) << 30) )
    {
      v16 = (unsigned int *)(**(_DWORD **)(result + 52)
                           + *(_WORD *)(result + 8) * *(_WORD *)(*(_DWORD *)(result + 52) + 10)
                           + 4 * (8 * *(_WORD *)(result + 10) >> 5));
      v8 = 32 * (8 * *(_WORD *)(result + 10) >> 5) - 8 * *(_WORD *)(result + 10) + 32;
      v3 = *(_WORD *)(result + 16);
      v6 = *(_WORD *)(result + 18);
      do
      {
        v17 = v9;
        if ( v18 << 31 )
        {
          v4 = *(_BYTE *)v18;
          v7 = v18 + 1;
        }
        else if ( v18 << 30 )
        {
          v4 = *(_WORD *)v18;
          v7 = v18 + 2;
          v17 = v9 + 8;
        }
        else
        {
          v4 = *(_DWORD *)v18;
          v7 = v18 + 4;
          v17 = v9 + 24;
        }
        v5 = (v4 >> ((-v9 + 8) & 0x1F)) | (v4 << (32 - ((-v9 + 8) & 0x1F)));
        v10 = v8;
        v11 = v16;
        v14 = (*v16 >> ((32 - v8) & 0x1F)) | (*v16 << (32 - ((32 - v8) & 0x1F)));
        v13 = v6;
        do
        {
          v2 = 2 * v5 & 3;
          v5 >>= 1;
          if ( v2 )
            v12 = *(_WORD *)(v20 + 38);
          else
            v12 = *(_WORD *)(v20 + 36);
          if ( (signed __int16)v12 >= 0 )
            v14 = (v14 >> 8) | (v12 << 24);
          else
            v14 = (v14 >> 8) | (v14 << 24);
          if ( --v13 )
          {
            v10 -= 8;
            if ( !v10 )
            {
              *v11 = v14;
              ++v11;
              v10 = 32;
              v14 = *v11;
            }
            if ( !--v17 )
            {
              if ( v7 << 30 )
              {
                v17 = 16;
                v5 = *(_WORD *)v7;
                v7 += 2;
              }
              else
              {
                v17 = 32;
                v5 = *(_DWORD *)v7;
                v7 += 4;
              }
            }
          }
        }
        while ( v13 );
        *v11 = (v14 >> ((v10 - 8) & 0x1F)) | (v14 << (32 - ((v10 - 8) & 0x1F)));
        v18 += v19;
        result = (int)v16 + v15;
        v16 = (unsigned int *)((char *)v16 + v15);
        --v3;
      }
      while ( v3 );
    }
  }
  return result;
}

//----- (10034240) --------------------------------------------------------
int __cdecl sub_10034240(int a1)
{
  int result; // eax@1
  signed int v2; // [sp+4h] [bp-30h]@16
  int v3; // [sp+8h] [bp-2Ch]@9
  char *v4; // [sp+Ch] [bp-28h]@4
  _BYTE *v5; // [sp+Ch] [bp-28h]@10
  _BYTE *v6; // [sp+Ch] [bp-28h]@12
  _BYTE *v7; // [sp+Ch] [bp-28h]@14
  char *v8; // [sp+10h] [bp-24h]@4
  _BYTE *v9; // [sp+10h] [bp-24h]@10
  _BYTE *v10; // [sp+10h] [bp-24h]@12
  _BYTE *v11; // [sp+10h] [bp-24h]@14
  unsigned int v12; // [sp+14h] [bp-20h]@4
  int v13; // [sp+14h] [bp-20h]@10
  int v14; // [sp+14h] [bp-20h]@12
  int v15; // [sp+18h] [bp-1Ch]@2
  int v16; // [sp+1Ch] [bp-18h]@2
  int v17; // [sp+20h] [bp-14h]@2
  size_t v18; // [sp+24h] [bp-10h]@2
  char *v19; // [sp+28h] [bp-Ch]@2
  int v20; // [sp+2Ch] [bp-8h]@2
  char *v21; // [sp+30h] [bp-4h]@2
  _BYTE *v22; // [sp+3Ch] [bp+8h]@1

  result = sub_10035E00(a1);
  v22 = (_BYTE *)result;
  if ( result )
  {
    v18 = *(_WORD *)(result + 18);
    v15 = *(_WORD *)(result + 16);
    v17 = *(_WORD *)(*(_DWORD *)(result + 52) + 10);
    v16 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v21 = (char *)(*(_WORD *)(result + 14) + v16 * *(_WORD *)(result + 12) + **(_DWORD **)(result + 56));
    v19 = (char *)(*(_WORD *)(result + 10) + v17 * *(_WORD *)(result + 8) + **(_DWORD **)(result + 52));
    v20 = 0;
    do
    {
      if ( v20 )
        goto LABEL_26;
      v12 = v18;
      v8 = v21;
      v4 = v19;
      while ( v12 >= 4 )
      {
        if ( *(_DWORD *)v4 != *(_DWORD *)v8 )
          goto LABEL_9;
        v12 -= 4;
        v8 += 4;
        v4 += 4;
      }
      if ( !v12 )
      {
LABEL_16:
        v2 = 0;
        goto LABEL_19;
      }
LABEL_9:
      v3 = (unsigned __int8)*v4 - (unsigned __int8)*v8;
      if ( (unsigned __int8)*v4 == (unsigned __int8)*v8 )
      {
        v13 = v12 - 1;
        v9 = v8 + 1;
        v5 = v4 + 1;
        if ( !v13 )
          goto LABEL_16;
        v3 = *v5 - *v9;
        if ( *v5 == *v9 )
        {
          v14 = v13 - 1;
          v10 = v9 + 1;
          v6 = v5 + 1;
          if ( !v14 )
            goto LABEL_16;
          v3 = *v6 - *v10;
          if ( *v6 == *v10 )
          {
            v11 = v10 + 1;
            v7 = v6 + 1;
            if ( v14 == 1 )
              goto LABEL_16;
            v3 = *v7 - *v11;
            if ( *v7 == *v11 )
              goto LABEL_16;
          }
        }
      }
      v2 = 1;
      if ( v3 <= 0 )
        v2 = -1;
LABEL_19:
      if ( v2 )
      {
LABEL_26:
        ++v20;
        memcpy_0(v19, v21, v18);
      }
      v21 += v16;
      v19 += v17;
      result = v15-- - 1;
    }
    while ( v15 );
    if ( !v20 )
      *v22 = 0;
  }
  return result;
}

//----- (10034420) --------------------------------------------------------
unsigned int __cdecl sub_10034420(int a1)
{
  unsigned int result; // eax@1
  unsigned int v2; // ST08_4@5
  unsigned int v3; // ST28_4@6
  int v4; // ST28_4@13
  int v5; // [sp+0h] [bp-50h]@4
  unsigned int v6; // [sp+4h] [bp-4Ch]@5
  int v7; // [sp+8h] [bp-48h]@4
  unsigned __int16 v8; // [sp+Ch] [bp-44h]@4
  int *v9; // [sp+10h] [bp-40h]@5
  unsigned __int16 v10; // [sp+14h] [bp-3Ch]@4
  int v11; // [sp+18h] [bp-38h]@3
  int v12; // [sp+18h] [bp-38h]@5
  unsigned __int16 v13; // [sp+20h] [bp-30h]@3
  unsigned int *v14; // [sp+2Ch] [bp-24h]@5
  signed int v15; // [sp+30h] [bp-20h]@13
  int v16; // [sp+34h] [bp-1Ch]@5
  unsigned int v17; // [sp+38h] [bp-18h]@5
  unsigned __int16 v18; // [sp+3Ch] [bp-14h]@3
  unsigned int *v19; // [sp+40h] [bp-10h]@4
  int v20; // [sp+48h] [bp-8h]@2
  int v21; // [sp+48h] [bp-8h]@3
  unsigned __int16 v22; // [sp+4Ch] [bp-4h]@2
  unsigned int v23; // [sp+58h] [bp+8h]@1

  result = sub_10035E00(a1);
  v23 = result;
  if ( result )
  {
    v22 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v20 = **(_DWORD **)(result + 56) + *(_WORD *)(result + 12) * *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    result = *(_DWORD *)(result + 56);
    if ( (unsigned int)*(_BYTE *)(result + 8) < 9 )
    {
      v21 = v20 + 4 * ((signed int)*(_WORD *)(v23 + 14) << byte_100DA7F0[*(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)] >> 5);
      v13 = 32 - ((*(_WORD *)(v23 + 14) << byte_100DA7F0[*(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)]) & 0x1F);
      v18 = *(_WORD *)(*(_DWORD *)(v23 + 52) + 10);
      v11 = *(_BYTE *)(*(_DWORD *)(v23 + 56) + 8) | (*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8) << 8);
      result = *(_BYTE *)(*(_DWORD *)(v23 + 52) + 8);
      if ( result < 9 )
      {
        v19 = (unsigned int *)(**(_DWORD **)(v23 + 52)
                             + *(_WORD *)(v23 + 8) * *(_WORD *)(*(_DWORD *)(v23 + 52) + 10)
                             + 4
                             * ((signed int)*(_WORD *)(v23 + 10) << byte_100DA7F0[*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8)] >> 5));
        v10 = 32 - ((*(_WORD *)(v23 + 10) << byte_100DA7F0[*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8)]) & 0x1F);
        v8 = *(_WORD *)(v23 + 18);
        v5 = *(_WORD *)(v23 + 16);
        v7 = (1 << *(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)) - 1;
        do
        {
          v2 = *(_DWORD *)(v21 - (v21 & 3) - 4 * ((v13 - 8 * (v21 & 3) - 1) >> 5));
          v9 = (int *)(v21 - (v21 & 3) - 4 * ((v13 - 8 * (v21 & 3) - 1) >> 5) + 4);
          v6 = (v2 >> (31 * (v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5)) & 0x1F)) | (v2 << (32 - (31 * (v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5)) & 0x1F)));
          v14 = v19;
          v17 = (*v19 >> (31 * v10 & 0x1F)) | (*v19 << (32 - (31 * v10 & 0x1F)));
          v12 = (unsigned __int16)v11 | (((v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5) + 127) | ((v10 + 127) << 8)) << 16);
          v16 = v8;
          if ( *(_DWORD *)(v23 + 68) )
          {
            do
            {
              v4 = v6 & v7;
              v6 = (unsigned __int64)v6 >> v12;
              v15 = *(_WORD *)(*(_DWORD *)(v23 + 68) + 2 * v4);
              if ( (signed __int16)v15 >= 0 )
                v17 = (v15 >> (BYTE1(v12) & 0x1F)) | (v15 << (32 - (BYTE1(v12) & 0x1F))) | ((unsigned __int64)v17 >> SBYTE1(v12));
              else
                v17 = (v17 >> (BYTE1(v12) & 0x1F)) | (v17 << (32 - (BYTE1(v12) & 0x1F)));
              if ( --v16 )
              {
                v12 *= -65535;
                if ( v12 >= 0 )
                {
                  v12 += 0x20000000;
                  *v14 = v17;
                  ++v14;
                  v17 = *v14;
                }
                if ( !(v12 & 0x800000) )
                {
                  v12 += 0x200000;
                  v6 = *v9;
                  ++v9;
                }
              }
            }
            while ( (signed __int16)v16 > 0 );
          }
          else
          {
            do
            {
              v3 = v6 & v7;
              v6 = (unsigned __int64)v6 >> v12;
              v17 = ((unsigned __int64)v17 >> SBYTE1(v12)) | (v3 >> (BYTE1(v12) & 0x1F)) | (v3 << (32
                                                                                                 - (BYTE1(v12) & 0x1F)));
              if ( --v16 )
              {
                v12 *= -65535;
                if ( v12 >= 0 )
                {
                  v12 += 0x20000000;
                  *v14 = v17;
                  ++v14;
                  v17 = *v14;
                }
                if ( !(v12 & 0x800000) )
                {
                  v12 += 0x200000;
                  v6 = *v9;
                  ++v9;
                }
              }
            }
            while ( v16 );
          }
          v11 = -65535 * v12;
          *v14 = (v17 >> ((BYTE3(v11) - 127) & 0x1F)) | (v17 << (32 - ((BYTE3(v11) - 127) & 0x1F)));
          v21 += v22;
          result = (unsigned int)v19 + v18;
          v19 = (unsigned int *)((char *)v19 + v18);
          --v5;
        }
        while ( v5 );
      }
    }
  }
  return result;
}

//----- (10034950) --------------------------------------------------------
int __cdecl sub_10034950(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8)
{
  *(_DWORD *)(a1 + 56) = a2;
  *(_WORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 12) = a4;
  *(_WORD *)(a1 + 10) = a5;
  *(_WORD *)(a1 + 8) = a6;
  *(_WORD *)(a1 + 18) = a7;
  *(_WORD *)(a1 + 16) = a8;
  return a1;
}

//----- (100349B0) --------------------------------------------------------
_WORD *__cdecl sub_100349B0(int a1)
{
  _WORD *result; // eax@1

  result = (_WORD *)a1;
  if ( *(_WORD *)(a1 + 36) != 0xFFFF )
  {
    result = *(_WORD **)(a1 + 52);
    if ( !(result[5] << 30) )
    {
      *(_BYTE *)a1 = 1;
      result = memset(
                 **(void ***)(a1 + 52),
                 *(_WORD *)(a1 + 36),
                 *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) * *(_WORD *)(*(_DWORD *)(a1 + 52) + 4));
    }
  }
  return result;
}

//----- (10034A10) --------------------------------------------------------
int __cdecl sub_10034A10(int a1, int a2, char a3)
{
  int result; // eax@1

  *(_DWORD *)(a1 + 52) = a2;
  sub_10033D00(a1, 0, 0, *(_WORD *)(a2 + 6), *(_WORD *)(a2 + 4));
  *(_WORD *)(a1 + 42) = 0;
  *(_WORD *)(a1 + 40) = 0;
  *(_WORD *)(a1 + 46) = 0;
  *(_WORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_WORD *)(a1 + 2) = 1;
  *(_WORD *)(a1 + 34) = 1;
  *(_WORD *)(a1 + 32) = 1;
  *(_WORD *)(a1 + 4) = 3;
  *(_WORD *)(a1 + 36) = -1;
  *(_WORD *)(a1 + 38) = -1;
  *(_WORD *)(a1 + 6) = 3;
  *(_WORD *)(a1 + 48) = -1;
  *(_WORD *)(a1 + 50) = -1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  result = a1;
  *(_BYTE *)a1 = a3;
  return result;
}

//----- (10034B00) --------------------------------------------------------
void sub_10034B00()
{
  ;
}

//----- (10034B10) --------------------------------------------------------
int __cdecl sub_10034B10(int a1, _BYTE *a2, int a3)
{
  int result; // eax@2

  if ( *(_BYTE *)(a1 + 2) )
    result = 0;
  else
    result = sub_10035560(a1, a2, a3);
  return result;
}

//----- (10034B50) --------------------------------------------------------
char __cdecl sub_10034B50(char a1, char a2)
{
  char result; // al@1

  result = a1;
  byte_101AF001 = a1;
  byte_101AF000 = a2;
  return result;
}
// 101AF000: using guessed type char byte_101AF000;
// 101AF001: using guessed type char byte_101AF001;

//----- (10034B70) --------------------------------------------------------
int __cdecl sub_10034B70(int a1, int a2, _BYTE *a3, __int16 a4, int a5, __int16 a6, int a7)
{
  int result; // eax@12
  __int16 v8; // ST1C_2@20
  __int16 v9; // ST1E_2@43
  __int16 v10; // ST1C_2@56
  __int16 v11; // [sp+8h] [bp-8Ch]@17
  __int16 v12; // [sp+8h] [bp-8Ch]@43
  __int16 v13; // [sp+Ah] [bp-8Ah]@17
  __int16 v14; // [sp+Ah] [bp-8Ah]@43
  __int16 *v15; // [sp+10h] [bp-84h]@3
  unsigned __int8 v16; // [sp+17h] [bp-7Dh]@1
  int v17; // [sp+18h] [bp-7Ch]@47
  int v18; // [sp+1Ch] [bp-78h]@17
  int v19; // [sp+20h] [bp-74h]@11
  __int16 v20; // [sp+28h] [bp-6Ch]@29
  int v21; // [sp+2Ch] [bp-68h]@50
  int v22; // [sp+30h] [bp-64h]@47
  int i; // [sp+34h] [bp-60h]@13
  signed int v24; // [sp+38h] [bp-5Ch]@15
  unsigned __int8 v25; // [sp+3Eh] [bp-56h]@1
  bool v26; // [sp+3Fh] [bp-55h]@1
  char v27; // [sp+40h] [bp-54h]@45
  __int16 v28; // [sp+44h] [bp-50h]@43
  __int16 v29; // [sp+46h] [bp-4Eh]@56
  char v30; // [sp+48h] [bp-4Ch]@43
  char v31; // [sp+49h] [bp-4Bh]@46
  __int16 v32; // [sp+4Ah] [bp-4Ah]@56
  unsigned __int8 v33; // [sp+4Fh] [bp-45h]@1
  int v34; // [sp+50h] [bp-44h]@15
  __int16 v35; // [sp+54h] [bp-40h]@22
  int v36; // [sp+58h] [bp-3Ch]@45
  int v37; // [sp+5Ch] [bp-38h]@44
  int v38; // [sp+60h] [bp-34h]@28
  __int16 v39; // [sp+64h] [bp-30h]@17
  __int16 v40; // [sp+66h] [bp-2Eh]@17
  __int16 v41; // [sp+68h] [bp-2Ch]@55
  __int16 v42; // [sp+6Ah] [bp-2Ah]@55
  unsigned __int16 v43; // [sp+6Ch] [bp-28h]@24
  int v44; // [sp+70h] [bp-24h]@29
  char v45; // [sp+75h] [bp-1Fh]@43
  unsigned __int8 v46; // [sp+76h] [bp-1Eh]@1
  char v47; // [sp+77h] [bp-1Dh]@43
  int v48; // [sp+78h] [bp-1Ch]@22
  int v49; // [sp+7Ch] [bp-18h]@23
  __int16 v50; // [sp+80h] [bp-14h]@55
  __int16 v51; // [sp+82h] [bp-12h]@55
  __int16 v52; // [sp+84h] [bp-10h]@24
  int v53; // [sp+88h] [bp-Ch]@4
  int v54; // [sp+8Ch] [bp-8h]@19
  __int16 v55; // [sp+90h] [bp-4h]@17

  v16 = (a5 & 0xE000u) >> 13;
  v46 = (unsigned __int8)(a5 & 0x70) >> 4;
  v25 = (a5 & 0x380u) >> 7;
  v33 = (a5 & 0x1C00u) >> 10;
  v26 = 1;
  if ( a5 & 0x40000000 || a5 & 0x80000000 )
  {
    v15 = &a6;
    if ( a5 & 0x40000000 )
    {
      v15 = (__int16 *)&a7;
      v53 = a6;
      v16 = (a6 & 0xFF000000) >> 24;
      v46 = a6;
      v25 = (unsigned __int16)(a6 & 0xFF00) >> 8;
      v33 = (a6 & 0xFF0000u) >> 16;
    }
    if ( a5 & 0x80000000 )
    {
      if ( *(_DWORD *)v15 )
      {
        if ( *(_DWORD *)v15 == 2 )
          v26 = sub_100353B0(a3) == 0;
        else
          v26 = 0;
      }
      else
      {
        v26 = 1;
      }
    }
  }
  v19 = 0;
  if ( *(_BYTE *)(a2 + 3) & 3 )
  {
    result = 0;
  }
  else
  {
    i = sub_10034B10(a2, a3, a5);
    if ( !a4 )
      a4 = i;
    v34 = a4;
    v24 = ((a5 & 0x3F0000u) >> 16) - 1;
    if ( v24 < 0 )
      v24 = *(_WORD *)(a2 + 28);
    v18 = *(_WORD *)(a2 + 22);
    v11 = *(_WORD *)(a1 + 46);
    v55 = *(_WORD *)(a1 + 44);
    v13 = v55 - (*(_WORD *)(a2 + 24) - 1);
    v39 = *(_WORD *)(a1 + 42);
    v40 = *(_WORD *)(a1 + 40);
    if ( a5 & 3 )
    {
      if ( (a5 & 3) == 1 )
      {
        v54 = v11 - v34 / 2;
        v11 -= i / 2;
      }
      else
      {
        v54 = v11;
      }
    }
    else
    {
      v8 = v11 + 1;
      v54 = v8 - v34;
      v11 = v8 - i;
    }
    v35 = v13;
    v48 = v18;
    if ( a5 & 0xC )
    {
      v35 += *(_WORD *)(a2 + 26);
      v48 -= v18 - *(_WORD *)(a2 + 24) + *(_WORD *)(a2 + 26);
      v54 -= v46;
      v49 = v25;
      v34 += v25 + v46;
      if ( (a5 & 0xC) == 4 )
      {
        v52 = *(_WORD *)(a1 + 6);
        v43 = *(_WORD *)(a1 + 50);
        *(_WORD *)(a1 + 6) = 3;
        *(_WORD *)(a1 + 50) = *(_WORD *)(a1 + 36);
        v49 = v33;
        v35 -= v33;
        v48 += v33;
        if ( v33 > (signed int)*(_WORD *)(a2 + 26) )
          sub_100364A0(a1, v54, v35, v34, v49 - *(_WORD *)(a2 + 26));
        v49 = v16;
        v48 += v16;
        if ( v16 > v18 - *(_WORD *)(a2 + 24) )
          sub_100364A0(a1, v54, v18 + v13, v34, v49 - (v18 - *(_WORD *)(a2 + 24)));
        v38 = v11 - v54;
        if ( i > a4 )
        {
          v20 = a4 + v11;
          v44 = v25;
        }
        else
        {
          v20 = i + v11;
          v44 = v34 - (i + v38);
        }
        if ( v38 > 0 )
          sub_100364A0(a1, v54, v35, v38, v48);
        if ( v44 > 0 )
          sub_100364A0(a1, v20, v35, v44, v48);
        *(_WORD *)(a1 + 50) = v43;
        *(_WORD *)(a1 + 6) = v52;
      }
    }
    if ( v35 <= v13 )
      v35 = 0;
    else
      v35 -= v13;
    if ( v48 >= v18 - v35 )
      v48 = v18 - v35;
    if ( i < a4 )
      a4 = i;
    v30 = 1;
    v47 = 0;
    v45 = (*(_BYTE *)(a2 + 3) & 3) << 6;
    v12 = v39 + v11;
    v9 = v40 + v13;
    v52 = *(_WORD *)(a1 + 4);
    *(_WORD *)(a1 + 4) = 2;
    v14 = v35 + v9;
    v28 = v18;
    if ( i )
    {
      v37 = (a5 & 0x3FC00000u) >> 22;
      for ( i = 0; !sub_10035450(a2, &a3, &v27, &v36, v26); i += v21 + (signed __int16)v36 )
      {
        v31 = v47;
        if ( v37 <= v36 )
        {
          v22 = 0;
          v17 = 0;
        }
        else
        {
          v22 = (v37 - v36) / 2;
          v17 = v37 - v36 - v22;
        }
        v21 = i <= 0 ? v22 : v22 + v24 + v19;
        if ( v36 + v21 + i > a4 )
          break;
        v19 = v17;
        v43 = *(_WORD *)(a1 + 38);
        if ( v21 > 0 && v43 != 0xFFFF )
        {
          *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 36);
          v50 = v14;
          v51 = v12;
          v41 = v48;
          v42 = v21;
          sub_10035FD0(a1, (signed __int16)v21 + (v12 << 16), (signed __int16)v48 + (v14 << 16));
          *(_WORD *)(a1 + 38) = v43;
        }
        v10 = v21 + v12;
        *(_WORD *)(a1 + 8) = v14;
        *(_WORD *)(a1 + 10) = v10;
        *(_WORD *)(a1 + 16) = v48;
        *(_WORD *)(a1 + 18) = v36;
        v29 = v36;
        *(_WORD *)(a1 + 14) = 0;
        *(_WORD *)(a1 + 12) = v35;
        v32 = (v29 + 7) / 8;
        *(_DWORD *)(a1 + 56) = &v27;
        sub_10033EF0(a1);
        v12 = v36 + v10;
      }
    }
    v43 = *(_WORD *)(a1 + 38);
    if ( i < a4 && v43 != 0xFFFF )
    {
      *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 36);
      v50 = v14;
      v51 = v12;
      v41 = v48;
      v42 = a4 - i;
      sub_10035FD0(a1, (signed __int16)(a4 - i) + (v12 << 16), (signed __int16)v48 + (v14 << 16));
      *(_WORD *)(a1 + 38) = v43;
    }
    *(_WORD *)(a1 + 4) = v52;
    *(_WORD *)(a1 + 46) = v19 + v12 - v39;
    *(_WORD *)(a1 + 44) = v55;
    result = v19 + i;
  }
  return result;
}

//----- (100353B0) --------------------------------------------------------
bool __cdecl sub_100353B0(_BYTE *a1)
{
  char v3; // [sp+6h] [bp-2h]@1
  char v4; // [sp+7h] [bp-1h]@1

  v3 = 0;
  v4 = 0;
  while ( *a1 )
  {
    if ( (signed int)*a1 < 48 || (signed int)*a1 > 57 )
    {
      if ( (signed int)*a1 >= 97 && (signed int)*a1 <= 122 || (signed int)*a1 >= 65 && (signed int)*a1 <= 90 )
        v3 = 1;
    }
    else
    {
      v4 = 1;
    }
    ++a1;
  }
  return v3 && v4;
}

//----- (10035450) --------------------------------------------------------
bool __cdecl sub_10035450(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, char a5)
{
  int v5; // ST18_4@9
  int v7; // [sp+4h] [bp-1Ch]@7
  bool v8; // [sp+Bh] [bp-15h]@1
  unsigned int v9; // [sp+10h] [bp-10h]@7
  int v10; // [sp+14h] [bp-Ch]@1

  v10 = *(_BYTE *)(*a2)++;
  v8 = v10 == 0;
  if ( byte_101AF001 && a5 && v10 == 48 )
    v10 = (unsigned __int8)byte_101AF000;
  if ( !v8 )
  {
    if ( *(_BYTE *)(a1 + 2) )
    {
      v8 = 1;
    }
    else
    {
      v7 = *(_DWORD *)(a1 + 8) + a1;
      v9 = v10 - *(_BYTE *)(v7 + 2);
      if ( v9 >= *(_WORD *)v7 )
        v9 = *(_BYTE *)(v7 + 3);
      v5 = *(_DWORD *)(a1 + 12) + a1 + 4 * v9;
      *a3 = ((*(_BYTE *)(v5 + 2) << 16) | *(_WORD *)v5) + *(_DWORD *)(a1 + 16) + a1;
      *a4 = *(_BYTE *)(v5 + 3);
    }
  }
  return v8;
}
// 101AF000: using guessed type char byte_101AF000;
// 101AF001: using guessed type char byte_101AF001;

//----- (10035560) --------------------------------------------------------
int __cdecl sub_10035560(int a1, _BYTE *a2, int a3)
{
  int v3; // ST00_4@5
  unsigned int v5; // [sp+0h] [bp-20h]@5
  int v6; // [sp+4h] [bp-1Ch]@3
  int v7; // [sp+8h] [bp-18h]@3
  int v8; // [sp+Ch] [bp-14h]@3
  signed int v9; // [sp+10h] [bp-10h]@1
  signed int v10; // [sp+14h] [bp-Ch]@8
  signed int v11; // [sp+18h] [bp-8h]@1
  _BYTE *v12; // [sp+1Ch] [bp-4h]@3

  v11 = (a3 & 0x3FC00000u) >> 22;
  v9 = ((a3 & 0x3F0000u) >> 16) - 1;
  if ( v9 < 0 )
    v9 = *(_WORD *)(a1 + 28);
  v12 = a2;
  v6 = *(_DWORD *)(a1 + 12) + a1;
  v7 = *(_DWORD *)(a1 + 8) + a1;
  v8 = 0;
  while ( *v12 )
  {
    v3 = *v12++;
    v5 = v3 - *(_BYTE *)(v7 + 2);
    if ( v8 > 0 )
      v8 += v9;
    if ( v5 < *(_WORD *)v7 )
      v10 = *(_BYTE *)(v6 + 4 * v5 + 3);
    else
      v10 = *(_BYTE *)(v6 + 4 * *(_BYTE *)(v7 + 3) + 3);
    if ( v11 <= v10 )
      v8 += v10;
    else
      v8 += v11;
  }
  return v8;
}

//----- (10035650) --------------------------------------------------------
int __cdecl sub_10035650(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)
{
  int result; // eax@1
  __int16 v7; // ST1C_2@8
  int v8; // [sp+0h] [bp-14h]@4
  int v9; // [sp+Ch] [bp-8h]@4
  __int16 v10; // [sp+10h] [bp-4h]@8
  __int16 v11; // [sp+28h] [bp+14h]@8
  __int16 v12; // [sp+2Ch] [bp+18h]@8

  result = a4;
  if ( a4 > 0 && a5 > 0 )
  {
    v8 = *(_DWORD *)(a1 + 36);
    v9 = *(_DWORD *)(a1 + 36);
    if ( a6 & 1 )
      sub_100364A0(a1, a2, a3, a4, a5);
    if ( !(a6 & 2) )
      LOWORD(v9) = HIWORD(v9);
    v12 = a5 - 1;
    v11 = a4 - 1;
    v10 = a2;
    v10 = *(_WORD *)(a1 + 42) + a2;
    v7 = *(_WORD *)(a1 + 40) + a3;
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_100DA7FC[0]);
    *(_WORD *)(a1 + 10) = byte_100DA7FC[1] + v10;
    *(_WORD *)(a1 + 8) = v7;
    *(_WORD *)(a1 + 14) = byte_100DA7FC[2] + v11 - byte_100DA7FC[1] + 1;
    sub_10036590(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_100DA7FC[3]);
    *(_WORD *)(a1 + 8) = byte_100DA7FC[4] + v7;
    *(_WORD *)(a1 + 10) = v11 + v10;
    *(_WORD *)(a1 + 12) = byte_100DA7FC[5] + v12 - byte_100DA7FC[4] + 1;
    sub_10036700(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_100DA7FC[6]);
    *(_WORD *)(a1 + 10) = byte_100DA7FC[8] + v11 + v10;
    *(_WORD *)(a1 + 8) = v12 + v7;
    *(_WORD *)(a1 + 14) = byte_100DA7FC[7] - (byte_100DA7FC[8] + v11) - 1;
    sub_10036590(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_100DA7FC[9]);
    *(_WORD *)(a1 + 8) = byte_100DA7FC[11] + v12 + v7;
    *(_WORD *)(a1 + 10) = v10;
    *(_WORD *)(a1 + 12) = byte_100DA7FC[10] - (byte_100DA7FC[11] + v12) - 1;
    sub_10036700(a1);
    result = v8;
    *(_DWORD *)(a1 + 36) = v8;
  }
  return result;
}

//----- (100358B0) --------------------------------------------------------
int __cdecl sub_100358B0(int a1, __int16 a2, __int16 a3, char a4)
{
  int result; // eax@25
  signed int v5; // [sp+4h] [bp-30h]@29
  int v6; // [sp+8h] [bp-2Ch]@44
  int v7; // [sp+8h] [bp-2Ch]@54
  __int16 v8; // [sp+Ch] [bp-28h]@31
  char (__cdecl *v9)(int); // [sp+10h] [bp-24h]@2
  char *(__cdecl *v10)(int); // [sp+14h] [bp-20h]@5
  __int16 v11; // [sp+18h] [bp-1Ch]@31
  signed int v12; // [sp+1Ch] [bp-18h]@31
  __int16 v13; // [sp+20h] [bp-14h]@41
  __int16 v14; // [sp+28h] [bp-Ch]@29
  __int16 v15; // [sp+2Ch] [bp-8h]@29
  __int16 v16; // [sp+30h] [bp-4h]@41

  if ( *(_DWORD *)(a1 + 72) )
    v9 = *(char (__cdecl **)(int))(a1 + 72);
  else
    v9 = sub_10036590;
  if ( *(_DWORD *)(a1 + 76) )
    v10 = *(char *(__cdecl **)(int))(a1 + 76);
  else
    v10 = sub_10036700;
  *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 42) + *(_WORD *)(a1 + 46);
  *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 40) + *(_WORD *)(a1 + 44);
  *(_WORD *)(a1 + 14) = *(_WORD *)(a1 + 42) + a2;
  *(_WORD *)(a1 + 12) = *(_WORD *)(a1 + 40) + a3;
  *(_WORD *)(a1 + 46) = a2;
  *(_WORD *)(a1 + 44) = a3;
  if ( a4 & 1 )
  {
    if ( (signed int)*(_WORD *)(a1 + 10) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 10) < -8192 )
        *(_WORD *)(a1 + 10) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 10) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 8) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 8) < -8192 )
        *(_WORD *)(a1 + 8) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 8) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 14) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 14) < -8192 )
        *(_WORD *)(a1 + 14) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 14) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 12) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 12) < -8192 )
        *(_WORD *)(a1 + 12) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 12) = 0x1FFF;
    }
  }
  if ( *(_WORD *)(a1 + 10) != *(_WORD *)(a1 + 14) || (result = *(_WORD *)(a1 + 12), *(_WORD *)(a1 + 8) != result) )
  {
    v14 = *(_WORD *)(a1 + 14) - *(_WORD *)(a1 + 10);
    v15 = v14;
    v5 = 1;
    if ( v14 < 0 )
    {
      v5 = -1;
      v15 = -v14;
    }
    v8 = *(_WORD *)(a1 + 12) - *(_WORD *)(a1 + 8);
    v11 = v8;
    v12 = 1;
    if ( v8 < 0 )
    {
      v12 = -1;
      v11 = -v8;
    }
    if ( v15 )
    {
      if ( v11 )
      {
        v13 = 2 * v15;
        v16 = 2 * v11;
        if ( v15 <= v11 )
        {
          *(_WORD *)(a1 + 16) = 0;
          *(_WORD *)(a1 + 18) = 1;
          if ( v13 >= v11 )
            *(_WORD *)(a1 + 16) -= (v12 ^ v5) + 1;
          v7 = v13 - v11 - (v5 < 0);
          *(_WORD *)(a1 + 12) = 0;
          while ( v11 )
          {
            *(_WORD *)(a1 + 12) += v12;
            if ( v7 >= 0 )
            {
              v10(a1);
              *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
              *(_WORD *)(a1 + 12) = 0;
              *(_WORD *)(a1 + 10) += v5;
              v7 -= v16;
            }
            v7 += v13;
            --v11;
          }
          if ( a4 & 2 )
            *(_WORD *)(a1 + 12) += v12;
          v10(a1);
          result = a1;
          *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
        }
        else
        {
          *(_WORD *)(a1 + 16) = 1;
          *(_WORD *)(a1 + 18) = 0;
          if ( v16 >= v15 )
            *(_WORD *)(a1 + 18) -= (v12 ^ v5) + 1;
          v6 = v16 - v15 - (v12 < 0);
          *(_WORD *)(a1 + 14) = 0;
          while ( v15 )
          {
            *(_WORD *)(a1 + 14) += v5;
            if ( v6 >= 0 )
            {
              v9(a1);
              *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
              *(_WORD *)(a1 + 14) = 0;
              *(_WORD *)(a1 + 8) += v12;
              v6 -= v13;
            }
            v6 += v16;
            --v15;
          }
          if ( a4 & 2 )
            *(_WORD *)(a1 + 14) += v5;
          v9(a1);
          result = a1;
          *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
        }
      }
      else
      {
        *(_WORD *)(a1 + 16) = 1;
        *(_WORD *)(a1 + 18) = 0;
        *(_WORD *)(a1 + 14) = v14;
        if ( a4 & 2 )
          *(_WORD *)(a1 + 14) += v5;
        result = v9(a1);
      }
    }
    else
    {
      *(_WORD *)(a1 + 16) = 0;
      *(_WORD *)(a1 + 18) = 1;
      *(_WORD *)(a1 + 12) = v8;
      if ( a4 & 2 )
        *(_WORD *)(a1 + 12) += v12;
      result = (int)v10(a1);
    }
  }
  else if ( a4 & 2 )
  {
    *(_WORD *)(a1 + 12) = 1;
    result = (int)v10(a1);
  }
  return result;
}

//----- (10035E00) --------------------------------------------------------
int __cdecl sub_10035E00(int a1)
{
  int result; // eax@6
  __int16 v2; // [sp+0h] [bp-8h]@1
  __int16 v3; // [sp+4h] [bp-4h]@1

  v2 = *(_WORD *)(a1 + 10);
  v3 = *(_WORD *)(a1 + 8);
  if ( *(_WORD *)(a1 + 26) > (signed int)*(_WORD *)(a1 + 10) )
  {
    *(_WORD *)(a1 + 18) -= *(_WORD *)(a1 + 26) - *(_WORD *)(a1 + 10);
    *(_WORD *)(a1 + 14) += *(_WORD *)(a1 + 26) - *(_WORD *)(a1 + 10);
    *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 26);
  }
  if ( *(_WORD *)(a1 + 24) > (signed int)*(_WORD *)(a1 + 8) )
  {
    *(_WORD *)(a1 + 16) -= *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 8);
    *(_WORD *)(a1 + 12) += *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 8);
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 24);
  }
  if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) > v2 )
  {
    if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) - v2 < *(_WORD *)(a1 + 18) )
      *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 26) - v2;
    if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) > v3 )
    {
      if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) - v3 < *(_WORD *)(a1 + 16) )
        *(_WORD *)(a1 + 16) = *(_WORD *)(a1 + 28) + *(_WORD *)(a1 + 24) - v3;
      if ( (signed int)*(_WORD *)(a1 + 18) > 0 )
      {
        if ( (signed int)*(_WORD *)(a1 + 16) > 0 )
        {
          *(_BYTE *)a1 = 1;
          result = a1;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10035FD0) --------------------------------------------------------
int __cdecl sub_10035FD0(int a1, signed int a2, signed int a3)
{
  int result; // eax@5
  int v4; // edx@10
  unsigned int v5; // ST04_4@15
  unsigned int v6; // ST20_4@16
  int v7; // ST28_4@26
  unsigned int v8; // ST18_4@32
  int v9; // [sp+0h] [bp-44h]@28
  unsigned int v10; // [sp+4h] [bp-40h]@15
  int v11; // [sp+8h] [bp-3Ch]@1
  int v12; // [sp+Ch] [bp-38h]@1
  int v13; // [sp+10h] [bp-34h]@31
  unsigned int v14; // [sp+14h] [bp-30h]@13
  int v15; // [sp+1Ch] [bp-28h]@30
  int v16; // [sp+20h] [bp-24h]@17
  int i; // [sp+20h] [bp-24h]@32
  int v18; // [sp+20h] [bp-24h]@34
  int v19; // [sp+24h] [bp-20h]@1
  unsigned int v20; // [sp+28h] [bp-1Ch]@14
  int v21; // [sp+2Ch] [bp-18h]@15
  unsigned int *v22; // [sp+30h] [bp-14h]@15
  int *v23; // [sp+30h] [bp-14h]@32
  int v24; // [sp+34h] [bp-10h]@15
  unsigned int v25; // [sp+38h] [bp-Ch]@15
  unsigned int *v26; // [sp+3Ch] [bp-8h]@13
  int v27; // [sp+40h] [bp-4h]@1

  v11 = (signed __int16)a3;
  v27 = a3 >> 16;
  v12 = (signed __int16)a2;
  v19 = a2 >> 16;
  if ( *(_WORD *)(a1 + 26) > a2 >> 16 )
  {
    v12 = (signed __int16)a2 - (*(_WORD *)(a1 + 26) - v19);
    v19 = *(_WORD *)(a1 + 26);
  }
  if ( *(_WORD *)(a1 + 24) > v27 )
  {
    v11 = (signed __int16)a3 - (*(_WORD *)(a1 + 24) - v27);
    v27 = *(_WORD *)(a1 + 24);
  }
  result = *(_WORD *)(a1 + 30);
  if ( result + *(_WORD *)(a1 + 26) > v19 )
  {
    if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) - v19 <= v12 )
      v12 = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 26) - v19;
    result = *(_WORD *)(a1 + 28);
    if ( result + *(_WORD *)(a1 + 24) > v27 )
    {
      result = a1;
      if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) - v27 <= v11 )
      {
        v4 = *(_WORD *)(a1 + 28);
        result = v4 + *(_WORD *)(a1 + 24) - v27;
        v11 = v4 + *(_WORD *)(a1 + 24) - v27;
      }
      if ( v11 > 0 && v12 > 0 )
      {
        *(_BYTE *)a1 = 1;
        v14 = 32 - (8 * v19 & 0x1F);
        v26 = (unsigned int *)(v27 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10)
                             + **(_DWORD **)(a1 + 52)
                             + 4 * ((unsigned int)(8 * v19) >> 5));
        if ( *(_WORD *)(a1 + 4) == 2 )
        {
          v9 = v11;
          if ( v14 >= 8 * v12 )
            v14 = 8 * v12;
          v15 = 8 * v12 - v14;
          result = *(_WORD *)(a1 + 38) << 16;
          if ( !(*(_WORD *)(a1 + 38) & 0x8000) )
          {
            v13 = *(&dword_100DA808 + *(_WORD *)(a1 + 38));
            do
            {
              v8 = ~(((unsigned int)(0xFFFFFFFFui64 >> v14) >> ((32 - (8 * v19 & 0x1F) - v14) & 0x1F)) | ((unsigned int)(0xFFFFFFFFui64 >> v14) << (32 - ((32 - (8 * v19 & 0x1F) - v14) & 0x1F))));
              *v26 = *v26 & ~v8 | v13 & v8;
              v23 = (int *)(v26 + 1);
              for ( i = v15 - 32; i >= 0; i -= 32 )
              {
                *v23 = v13;
                ++v23;
              }
              v18 = i + 32;
              if ( v18 )
                *v23 = *v23 & ~((1 << v18) - 1) | v13 & ((1 << v18) - 1);
              result = *(_DWORD *)(a1 + 52);
              v26 = (unsigned int *)((char *)v26 + *(_WORD *)(result + 10));
              --v9;
            }
            while ( v9 );
          }
        }
        else
        {
          v20 = (v19 << 16) & 0x1FFFFF | v11 | (v27 << 27);
          do
          {
            v5 = *(_DWORD *)(*(_DWORD *)(a1 + 60) + (v20 >> 25));
            v10 = (v5 >> ((v20 >> 16) & 0x1F)) | (v5 << (32 - ((v20 >> 16) & 0x1F)));
            v22 = v26;
            v21 = 32 - (8 * v19 & 0x1F);
            v25 = (*v26 >> (31 * v14 & 0x1F)) | (*v26 << (32 - (31 * v14 & 0x1F)));
            v24 = v12;
            do
            {
              v6 = v10 << 31;
              v10 = (v10 << 31) | (v10 >> 1);
              if ( v6 >> 31 )
                v16 = *(_WORD *)(a1 + 38);
              else
                v16 = *(_WORD *)(a1 + 36);
              if ( (signed __int16)v16 >= 0 )
                v25 = (v16 << 24) | (v25 >> 8);
              else
                v25 = (v25 >> 8) | (v25 << 24);
              if ( --v24 )
              {
                v21 -= 8;
                if ( !v21 )
                {
                  *v22 = v25;
                  ++v22;
                  v21 = 32;
                  v25 = *v22;
                }
              }
            }
            while ( v24 );
            *v22 = (v25 >> ((v21 - 8) & 0x1F)) | (v25 << (32 - ((v21 - 8) & 0x1F)));
            v26 = (unsigned int *)((char *)v26 + *(_WORD *)(*(_DWORD *)(a1 + 52) + 10));
            v7 = v20 + 0x8000000;
            result = v7 - 1;
            v20 = v7 - 1;
          }
          while ( v20 << 16 );
        }
      }
    }
  }
  return result;
}

//----- (100364A0) --------------------------------------------------------
int __cdecl sub_100364A0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int result; // eax@1
  int v6; // [sp+0h] [bp-8h]@4
  __int16 v7; // [sp+4h] [bp-4h]@6

  result = a4;
  if ( a4 > 0 && a5 > 0 )
  {
    v6 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 48);
    *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 42) + a2;
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 40) + a3;
    if ( *(_WORD *)(a1 + 6) == 3 || *(_WORD *)(a1 + 6) == 1 )
    {
      v7 = *(_WORD *)(a1 + 4);
      if ( *(_WORD *)(a1 + 6) == 3 )
        *(_WORD *)(a1 + 4) = 2;
      else
        *(_WORD *)(a1 + 4) = 0;
      sub_10035FD0(a1, a4 + (*(_WORD *)(a1 + 10) << 16), a5 + (*(_WORD *)(a1 + 8) << 16));
      *(_WORD *)(a1 + 4) = v7;
    }
    result = a1;
    *(_DWORD *)(a1 + 36) = v6;
  }
  return result;
}

//----- (10036590) --------------------------------------------------------
char __cdecl sub_10036590(int a1)
{
  __int16 v1; // ax@1
  int v3; // [sp+8h] [bp-2Ch]@1
  char v4; // [sp+Ch] [bp-28h]@8
  int v5; // [sp+18h] [bp-1Ch]@1

  v5 = *(_WORD *)(a1 + 10);
  v1 = *(_WORD *)(a1 + 14);
  v3 = *(_WORD *)(a1 + 14);
  if ( *(_WORD *)(a1 + 14) )
  {
    if ( v3 < 0 )
    {
      v5 += v3 + 1;
      v3 = 0x8000 - v3;
    }
    v5 = v3 + (v5 << 16);
    if ( (signed int)*(_WORD *)(a1 + 2) > 1 )
    {
      LOBYTE(v1) = a1;
      switch ( *(_WORD *)(a1 + 4) )
      {
        case 0:
        case 2:
          LOBYTE(v1) = sub_10036B10(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 3:
        case 4:
          LOBYTE(v1) = sub_100373D0(a1, v5, (int)&v4);
          break;
        default:
          return v1;
      }
    }
    else
    {
      v1 = *(_WORD *)(a1 + 4);
      switch ( *(_WORD *)(a1 + 4) )
      {
        case 0:
          LOBYTE(v1) = sub_10036B10(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 2:
          LOBYTE(v1) = sub_10036B10(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 3:
          LOBYTE(v1) = sub_10036C10(a1, v5, *(_WORD *)(a1 + 8), (int)&v4);
          break;
        case 4:
          LOBYTE(v1) = (unsigned int)sub_10037040(a1, v5, *(_WORD *)(a1 + 8), *(int **)(a1 + 64));
          break;
        default:
          return v1;
      }
    }
  }
  return v1;
}

//----- (10036700) --------------------------------------------------------
char *__cdecl sub_10036700(int a1)
{
  char *result; // eax@1
  int v2; // ST18_4@3
  int v3; // [sp+8h] [bp-2Ch]@1
  char v4; // [sp+Ch] [bp-28h]@7
  int v5; // [sp+1Ch] [bp-18h]@1

  v5 = *(_WORD *)(a1 + 8);
  result = (char *)*(_WORD *)(a1 + 12);
  v3 = *(_WORD *)(a1 + 12);
  if ( *(_WORD *)(a1 + 12) )
  {
    if ( v3 < 0 )
    {
      v2 = -v3;
      v5 = v5 - v2 + 1;
      v3 = v2 + 0x8000;
    }
    v5 = v3 + (v5 << 16);
    if ( (signed int)*(_WORD *)(a1 + 2) <= 1 )
    {
      result = (char *)*(_WORD *)(a1 + 4);
      switch ( result )
      {
        case 0u:
        case 2u:
          result = (char *)sub_10036B90(a1, v5, *(_WORD *)(a1 + 10));
          break;
        case 3u:
          result = (char *)sub_10036E10(a1, v5, *(_WORD *)(a1 + 10), (int)&v4);
          break;
        case 4u:
          result = sub_10037180(a1, v5, *(_WORD *)(a1 + 10), *(int **)(a1 + 64));
          break;
        default:
          return result;
      }
    }
    else
    {
      result = (char *)*(_WORD *)(a1 + 4);
      switch ( result )
      {
        case 0u:
        case 2u:
          result = (char *)sub_10036B90(a1, v5, *(_WORD *)(a1 + 10));
          break;
        case 3u:
        case 4u:
          result = (char *)sub_10037510(a1, v5, (int)&v4);
          break;
        default:
          return result;
      }
    }
  }
  return result;
}

//----- (10036850) --------------------------------------------------------
int __cdecl sub_10036850(int a1, int a2)
{
  int result; // eax@2

  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = *(_WORD *)(a1 + 26) - *(_DWORD *)(a2 + 12);
  if ( *(_DWORD *)(a2 + 24) <= 0
    || (*(_DWORD *)(a2 + 12) += *(_DWORD *)(a2 + 24),
        result = *(_DWORD *)(a2 + 20) - *(_DWORD *)(a2 + 24),
        *(_DWORD *)(a2 + 20) = result,
        *(_DWORD *)(a2 + 20) > 0) )
  {
    result = *(_WORD *)(a1 + 26);
    if ( result + *(_WORD *)(a1 + 30) > *(_DWORD *)(a2 + 12) )
    {
      if ( *(_WORD *)(a1 + 26) + (signed int)*(_WORD *)(a1 + 30) - *(_WORD *)(a2 + 12) <= *(_DWORD *)(a2 + 20) )
        *(_DWORD *)(a2 + 20) = *(_WORD *)(a1 + 26) + *(_WORD *)(a1 + 30) - *(_WORD *)(a2 + 12);
      result = a1;
      if ( (signed int)*(_WORD *)(a1 + 24) <= *(_DWORD *)(a2 + 16) )
      {
        result = *(_WORD *)(a1 + 24);
        if ( result + *(_WORD *)(a1 + 28) > *(_DWORD *)(a2 + 16) )
        {
          *(_DWORD *)(a2 + 24) &= ~(*(_DWORD *)(a2 + 24) >> 31);
          *(_BYTE *)a1 = 1;
          result = a2;
          *(_DWORD *)a2 = 1;
        }
      }
    }
  }
  return result;
}

//----- (10036970) --------------------------------------------------------
unsigned int __cdecl sub_10036970(int a1, int a2)
{
  unsigned int v2; // ST04_4@1
  __int16 v3; // ST0C_2@2
  char v4; // ST04_1@9
  unsigned int result; // eax@9
  unsigned int v6; // [sp+0h] [bp-1Ch]@1
  int v7; // [sp+4h] [bp-18h]@1
  int v8; // [sp+8h] [bp-14h]@2
  int v9; // [sp+10h] [bp-Ch]@1
  unsigned int v10; // [sp+14h] [bp-8h]@1
  unsigned int *v11; // [sp+18h] [bp-4h]@1

  v9 = *(_DWORD *)(a2 + 20);
  v2 = 8 * *(_DWORD *)(a2 + 12);
  v11 = (unsigned int *)(**(_DWORD **)(a1 + 52)
                       + *(_DWORD *)(a2 + 16) * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10)
                       + 4 * (v2 >> 5));
  v7 = 32 - (v2 & 0x1F);
  v10 = (*v11 >> (31 * v7 & 0x1F)) | (*v11 << (32 - (31 * v7 & 0x1F)));
  v6 = *(_DWORD *)(a2 + 32);
  do
  {
    v8 = 2 * v6 & 3;
    v6 = (v6 >> (*(_BYTE *)(a2 + 36) & 0x1F)) | (v6 << (32 - (*(_BYTE *)(a2 + 36) & 0x1F)));
    v3 = *(_WORD *)(v8 + a1 + 36);
    if ( v3 >= 0 )
      v10 = (v10 >> 8) | (*(_WORD *)(v8 + a1 + 36) << 24);
    else
      v10 = (v10 >> 8) | (v10 << 24);
    if ( --v9 )
    {
      v7 -= 8;
      if ( !v7 )
      {
        *v11 = v10;
        ++v11;
        v7 = 32;
        v10 = *v11;
      }
    }
  }
  while ( v9 );
  v4 = v7 - 8;
  result = v10 >> (v4 & 0x1F);
  *v11 = result | (v10 << (32 - (v4 & 0x1F)));
  return result;
}

//----- (10036B10) --------------------------------------------------------
int __cdecl sub_10036B10(int a1, int a2, int a3)
{
  return sub_10035FD0(
           a1,
           (a2 & 0xFFFF7FFF) + *(_WORD *)(a1 + 34) - 1 - ((unsigned int)*(_WORD *)(a1 + 34) >> 1 << 16),
           ((a3 - ((unsigned int)*(_WORD *)(a1 + 32) >> 1)) << 16) + *(_WORD *)(a1 + 32));
}

//----- (10036B90) --------------------------------------------------------
int __cdecl sub_10036B90(int a1, int a2, int a3)
{
  return sub_10035FD0(
           a1,
           ((a3 - ((unsigned int)*(_WORD *)(a1 + 34) >> 1)) << 16) + *(_WORD *)(a1 + 34),
           (a2 & 0xFFFF7FFF) + *(_WORD *)(a1 + 32) - 1 - ((unsigned int)*(_WORD *)(a1 + 32) >> 1 << 16));
}

//----- (10036C10) --------------------------------------------------------
char __cdecl sub_10036C10(int a1, signed int a2, int a3, int a4)
{
  char result; // al@2
  int v5; // [sp+0h] [bp-Ch]@7
  unsigned int v6; // [sp+4h] [bp-8h]@5
  _BYTE *v7; // [sp+8h] [bp-4h]@5

  *(_DWORD *)(a4 + 20) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 12) = a2 >> 16;
  *(_DWORD *)(a4 + 16) = a3;
  if ( *(_DWORD *)(a4 + 20) == 1 )
  {
    result = sub_10036D20(a1, *(_DWORD *)(a4 + 12), *(_DWORD *)(a4 + 16));
  }
  else
  {
    result = sub_10036850(a1, a4);
    if ( *(_DWORD *)a4 )
    {
      result = a1;
      if ( !(*(_WORD *)(a1 + 38) & 0x8000) )
      {
        v7 = (_BYTE *)(*(_DWORD *)(a4 + 12) + **(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10));
        v6 = *(_DWORD *)(a4 + 20);
        if ( v6 <= 0x10 )
        {
          v5 = *(&dword_100DA808 + *(_WORD *)(a1 + 38));
          do
          {
            result = v5;
            *v7++ = v5;
            --v6;
          }
          while ( v6 );
        }
        else
        {
          result = (unsigned int)memset(v7, *(&dword_100DA808 + *(_WORD *)(a1 + 38)), v6);
        }
      }
    }
  }
  return result;
}

//----- (10036D20) --------------------------------------------------------
int __cdecl sub_10036D20(int a1, signed int a2, signed int a3)
{
  int result; // eax@1
  _BYTE *v4; // ST08_4@5
  unsigned int v5; // [sp+18h] [bp+Ch]@5

  result = a1;
  if ( *(_WORD *)(a1 + 26) <= a2 )
  {
    result = *(_WORD *)(a1 + 26) + *(_WORD *)(a1 + 30);
    if ( result > a2 )
    {
      result = a1;
      if ( *(_WORD *)(a1 + 24) <= a3 )
      {
        result = *(_WORD *)(a1 + 24) + *(_WORD *)(a1 + 28);
        if ( result > a3 )
        {
          *(_BYTE *)a1 = 1;
          v5 = 8 * a2;
          v4 = (_BYTE *)(**(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) + (v5 >> 3));
          result = **(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) + (v5 >> 3);
          *v4 = ((unsigned __int64)*(_WORD *)(a1 + 38) << (v5 & 7)) | ~(unsigned __int8)(255i64 << (v5 & 7)) & *v4;
        }
      }
    }
  }
  return result;
}

//----- (10036E10) --------------------------------------------------------
int __cdecl sub_10036E10(int a1, signed int a2, int a3, int a4)
{
  int result; // eax@1
  _BYTE *v5; // [sp+Ch] [bp-4h]@2
  int v6; // [sp+18h] [bp+8h]@1

  *(_DWORD *)(a4 + 8) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 16) = a2 >> 16;
  *(_DWORD *)(a4 + 12) = a3;
  result = sub_10036F10(a1, a4);
  v6 = result;
  if ( *(_DWORD *)(a4 + 4) )
  {
    v5 = (_BYTE *)((a3 & 0x1FFFFFFF)
                 + *(_DWORD *)(a4 + 16) * *(_WORD *)(*(_DWORD *)(result + 52) + 10)
                 + **(_DWORD **)(result + 52));
    do
    {
      *v5;
      *v5 = *(_WORD *)(v6 + 38);
      v5 += *(_WORD *)(*(_DWORD *)(v6 + 52) + 10);
      result = *(_DWORD *)(a4 + 8) - 1;
      *(_DWORD *)(a4 + 8) = result;
    }
    while ( *(_DWORD *)(a4 + 8) > 0 );
  }
  return result;
}

//----- (10036F10) --------------------------------------------------------
int __cdecl sub_10036F10(int a1, int a2)
{
  int result; // eax@3

  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 28) = *(_WORD *)(a1 + 24) - *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)(a2 + 28) <= 0
    || (*(_DWORD *)(a2 + 16) += *(_DWORD *)(a2 + 28),
        *(_DWORD *)(a2 + 8) -= *(_DWORD *)(a2 + 28),
        *(_DWORD *)(a2 + 8) > 0) )
  {
    if ( *(_WORD *)(a1 + 24) + (signed int)*(_WORD *)(a1 + 28) > *(_DWORD *)(a2 + 16) )
    {
      if ( *(_WORD *)(a1 + 24) + (signed int)*(_WORD *)(a1 + 28) - *(_WORD *)(a2 + 16) <= *(_DWORD *)(a2 + 8) )
        *(_DWORD *)(a2 + 8) = *(_WORD *)(a1 + 24) + *(_WORD *)(a1 + 28) - *(_WORD *)(a2 + 16);
      if ( (signed int)*(_WORD *)(a1 + 26) <= *(_DWORD *)(a2 + 12) )
      {
        if ( *(_WORD *)(a1 + 26) + (signed int)*(_WORD *)(a1 + 30) > *(_DWORD *)(a2 + 12) )
        {
          *(_DWORD *)(a2 + 28) &= ~(*(_DWORD *)(a2 + 28) >> 31);
          *(_BYTE *)a1 = 1;
          *(_DWORD *)(a2 + 4) = 1;
          result = a1;
        }
        else
        {
          result = a1;
        }
      }
      else
      {
        result = a1;
      }
    }
    else
    {
      result = a1;
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10037040) --------------------------------------------------------
char *__cdecl sub_10037040(int a1, signed int a2, int a3, int *a4)
{
  char *result; // eax@3
  char v5; // [sp+0h] [bp-30h]@1
  signed int v6; // [sp+Ch] [bp-24h]@1
  int v7; // [sp+10h] [bp-20h]@1
  int v8; // [sp+14h] [bp-1Ch]@1
  int v9; // [sp+20h] [bp-10h]@1
  int v10; // [sp+24h] [bp-Ch]@1
  char *v11; // [sp+28h] [bp-8h]@1
  int v12; // [sp+2Ch] [bp-4h]@1
  signed int v13; // [sp+3Ch] [bp+Ch]@1
  int v14; // [sp+3Ch] [bp+Ch]@4

  v11 = &v5;
  v8 = a2 & 0x7FFF;
  v6 = a2 >> 16;
  v7 = a3;
  v9 = *a4;
  v12 = *(_BYTE *)(a1 + 1);
  v10 = v8 + v12;
  *(_BYTE *)(a1 + 1) = a2 + v12;
  v13 = (a2 - *((_DWORD *)v11 + 5)) << 16;
  if ( v13 < 0 )
  {
    v12 = *((_DWORD *)v11 + 9) - 1;
    v13 >>= 30;
  }
  *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v12 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v12 & 0x1F)));
  *((_DWORD *)v11 + 9) = v13 + 1;
  sub_10036850(a1, (int)v11);
  result = v11;
  if ( *(_DWORD *)v11 )
  {
    v14 = *((_DWORD *)v11 + 6) * *((_DWORD *)v11 + 9);
    *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v14 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v14 & 0x1F)));
    result = (char *)sub_10036970(a1, (int)v11);
  }
  return result;
}

//----- (10037180) --------------------------------------------------------
char *__cdecl sub_10037180(int a1, signed int a2, int a3, int *a4)
{
  char *result; // eax@3
  char v5; // [sp+0h] [bp-3Ch]@1
  int v6; // [sp+8h] [bp-34h]@1
  int v7; // [sp+Ch] [bp-30h]@1
  signed int v8; // [sp+10h] [bp-2Ch]@1
  int v9; // [sp+20h] [bp-1Ch]@1
  int v10; // [sp+24h] [bp-18h]@1
  char *v11; // [sp+28h] [bp-14h]@1
  int v12; // [sp+2Ch] [bp-10h]@1
  __int16 v13; // [sp+30h] [bp-Ch]@5
  char v14; // [sp+37h] [bp-5h]@6
  char *v15; // [sp+38h] [bp-4h]@4
  int v16; // [sp+44h] [bp+8h]@3
  signed int v17; // [sp+48h] [bp+Ch]@1
  int v18; // [sp+48h] [bp+Ch]@4
  unsigned int v19; // [sp+4Ch] [bp+10h]@4
  int v20; // [sp+4Ch] [bp+10h]@4

  v11 = &v5;
  v6 = a2 & 0x7FFF;
  v8 = a2 >> 16;
  v7 = a3;
  v9 = *a4;
  v12 = *(_BYTE *)(a1 + 1);
  v10 = v6 + v12;
  *(_BYTE *)(a1 + 1) = a2 + v12;
  v17 = (a2 - *((_DWORD *)v11 + 2)) << 16;
  if ( v17 < 0 )
  {
    v12 = *((_DWORD *)v11 + 9) - 1;
    v17 >>= 30;
  }
  *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v12 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v12 & 0x1F)));
  *((_DWORD *)v11 + 9) = v17 + 1;
  v16 = sub_10036F10(a1, (int)v11);
  result = v11;
  if ( *((_DWORD *)v11 + 1) )
  {
    v18 = *((_DWORD *)v11 + 7) * *((_DWORD *)v11 + 9);
    *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v18 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v18 & 0x1F)));
    v19 = 8 * a3;
    v15 = (char *)(**(_DWORD **)(v16 + 52) + (v19 >> 3) + *((_DWORD *)v11 + 4) * *(_WORD *)(*(_DWORD *)(v16 + 52) + 10));
    v20 = v19 & 7;
    do
    {
      v12 = 2 * *((_DWORD *)v11 + 8) & 3;
      *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v11[36] & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v11[36] & 0x1F)));
      v12 += v16 + 36;
      v13 = *(_WORD *)v12;
      if ( v13 >= 0 )
      {
        v14 = *v15;
        v13 <<= v20;
        v14 &= ~(unsigned __int8)(255 << v20);
        v14 |= v13;
        *v15 = v14;
      }
      v15 += *(_WORD *)(*(_DWORD *)(v16 + 52) + 10);
      --*((_DWORD *)v11 + 2);
      result = v11;
    }
    while ( *((_DWORD *)v11 + 2) );
  }
  return result;
}

//----- (100373D0) --------------------------------------------------------
int __cdecl sub_100373D0(int a1, signed int a2, int a3)
{
  int v3; // ST18_4@1
  int v4; // ecx@1
  bool v5; // sf@1
  int result; // eax@6
  unsigned int v7; // [sp+4h] [bp-10h]@1
  signed int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int *v10; // [sp+10h] [bp-4h]@1

  v7 = *(_WORD *)(a1 + 2);
  *(_DWORD *)(a3 + 16) = v7 >> 1;
  *(_DWORD *)(a3 + 12) = a2 - (*(_DWORD *)(a3 + 16) * *(_WORD *)(a1 + 18) << 16);
  *(_DWORD *)(a3 + 16) = *(_WORD *)(a1 + 8) - *(_DWORD *)(a3 + 16);
  v9 = *(_WORD *)(a1 + 18) << 16;
  v3 = *(_BYTE *)(a1 + 1);
  v4 = -256 * (8 * (*(_DWORD *)(a3 + 12) << 16 >> 31) + 4);
  v5 = v3 + v4 < 0;
  v8 = v3 + v4;
  v10 = *(int **)(a1 + 64);
  if ( v5 )
    v10 = (int *)((char *)v10 + -(*(_WORD *)(a1 + 2) * (v8 >> 8)) - 4);
  do
  {
    *(_BYTE *)(a1 + 1) = v8;
    if ( *(_WORD *)(a1 + 4) == 4 )
      sub_10037040(a1, *(_DWORD *)(a3 + 12), *(_DWORD *)(a3 + 16), v10);
    else
      sub_10036C10(a1, a2, *(_DWORD *)(a3 + 16), a3);
    ++*(_DWORD *)(a3 + 16);
    *(_DWORD *)(a3 + 12) += v9;
    result = (int)v10 + (v8 >> 8);
    v10 = (int *)((char *)v10 + (v8 >> 8));
    --v7;
  }
  while ( v7 );
  return result;
}

//----- (10037510) --------------------------------------------------------
int __cdecl sub_10037510(int a1, signed int a2, int a3)
{
  int v3; // ST18_4@1
  int v4; // ecx@1
  bool v5; // sf@1
  int result; // eax@6
  int v7; // [sp+4h] [bp-10h]@1
  signed int v8; // [sp+8h] [bp-Ch]@1
  int *v9; // [sp+Ch] [bp-8h]@1
  unsigned int v10; // [sp+10h] [bp-4h]@1

  v10 = *(_WORD *)(a1 + 2);
  *(_DWORD *)(a3 + 12) = v10 >> 1;
  *(_DWORD *)(a3 + 16) = a2 - (*(_DWORD *)(a3 + 12) * *(_WORD *)(a1 + 16) << 16);
  *(_DWORD *)(a3 + 12) = *(_WORD *)(a1 + 10) - *(_DWORD *)(a3 + 12);
  v7 = *(_WORD *)(a1 + 16) << 16;
  v3 = *(_BYTE *)(a1 + 1);
  v4 = (8 * (*(_DWORD *)(a3 + 16) << 16 >> 31) + 4) << 8;
  v5 = v3 + v4 < 0;
  v8 = v3 + v4;
  v9 = *(int **)(a1 + 64);
  if ( v5 )
    v9 = (int *)((char *)v9 + -(*(_WORD *)(a1 + 2) * (v8 >> 8)) - 4);
  do
  {
    *(_BYTE *)(a1 + 1) = v8;
    if ( *(_WORD *)(a1 + 4) == 4 )
      sub_10037180(a1, *(_DWORD *)(a3 + 16), *(_DWORD *)(a3 + 12), v9);
    else
      sub_10036E10(a1, a2, *(_DWORD *)(a3 + 12), a3);
    ++*(_DWORD *)(a3 + 12);
    *(_DWORD *)(a3 + 16) += v7;
    result = (int)v9 + (v8 >> 8);
    v9 = (int *)((char *)v9 + (v8 >> 8));
    --v10;
  }
  while ( v10 );
  return result;
}

//----- (10037650) --------------------------------------------------------
double __cdecl sub_10037650(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 != v4 && (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v11 = v2 + v9;
        result = v11;
      }
      else
      {
        v10 = v4;
        result = v10;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (100376F0) --------------------------------------------------------
double __cdecl sub_100376F0(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 == v4 || (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v10 = v4;
        result = v10;
      }
      else
      {
        v11 = v9 - v2;
        result = v11;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10037790) --------------------------------------------------------
double __cdecl sub_10037790(double a1, double a2)
{
  double result; // st7@1
  double v3; // [sp+0h] [bp-8h]@2

  result = 0.0;
  if ( a2 > 0.0 )
  {
    v3 = a2 + a2;
    result = fmod(a1, v3);
    if ( a2 > result )
    {
      if ( -a2 > result )
        result = result + v3;
    }
    else
    {
      result = result - v3;
    }
  }
  return result;
}

//----- (100377F0) --------------------------------------------------------
double __cdecl sub_100377F0(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@5
  float v6; // [sp+8h] [bp+8h]@3
  float v7; // [sp+8h] [bp+8h]@3
  float v8; // [sp+8h] [bp+8h]@4
  float v9; // [sp+8h] [bp+8h]@6

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v6 = v2 + v2;
    v4 = v6;
    v7 = a1 - (double)(signed int)(a1 / v6) * v6;
    if ( v7 < v2 )
    {
      v5 = v2;
      result = v7;
      if ( -v5 > v7 )
      {
        v9 = result + v4;
        result = v9;
      }
    }
    else
    {
      v8 = v7 - v4;
      result = v8;
    }
  }
  else
  {
    result = 0.0;
  }
  return result;
}

//----- (10037870) --------------------------------------------------------
void __cdecl sub_10037870(double a1)
{
  sub_10037790(a1, 3.1415926535898);
}

//----- (10037890) --------------------------------------------------------
double __cdecl sub_10037890(float a1)
{
  double result; // st7@3

  if ( a1 == -3.141592741012573 || a1 == 3.141592741012573 )
    result = -3.1415925;
  else
    result = sub_100377F0(a1, 3.1415927);
  return result;
}

//----- (100378D0) --------------------------------------------------------
int __cdecl sub_100378D0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(float *)a2 = *(double *)a1;
  *(float *)(a2 + 4) = *(double *)(a1 + 8);
  return result;
}

//----- (100378F0) --------------------------------------------------------
int __cdecl sub_100378F0(double a1)
{
  int result; // eax@2

  if ( a1 >= 0.0 )
    result = (signed int)(a1 + 0.5);
  else
    result = (signed int)(a1 - 0.5);
  return result;
}

//----- (10037920) --------------------------------------------------------
double __cdecl sub_10037920(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  float v4; // [sp+8h] [bp+8h]@5

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    if ( a1 < 0.0 )
      a2 = -v2;
    v4 = v2 * (double)(signed int)((a1 + a2 * 0.5) / v2);
    result = v4;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10037990) --------------------------------------------------------
int __cdecl sub_10037990(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a3;
  *(float *)a3 = cos(a1);
  *(float *)a2 = sin(a1);
  return result;
}

//----- (100379B0) --------------------------------------------------------
int __cdecl sub_100379B0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(double *)a2 = *(float *)a1;
  *(double *)(a2 + 8) = *(float *)(a1 + 4);
  return result;
}

//----- (100379D0) --------------------------------------------------------
int __cdecl sub_100379D0(float a1)
{
  double v1; // st7@1
  int result; // eax@3
  float v3; // [sp+8h] [bp+4h]@1
  float v4; // [sp+8h] [bp+4h]@2
  float v5; // [sp+8h] [bp+4h]@3

  v3 = sub_10037890(a1);
  v1 = v3;
  if ( v3 < 0.0 )
  {
    v4 = v1 + 6.283185482025146;
    v1 = v4;
  }
  v5 = v1 * 180.0 / 3.1415926535898;
  result = (signed int)(v5 + 0.5);
  if ( result >= 360 )
    result = 0;
  return result;
}

//----- (10037A30) --------------------------------------------------------
double __cdecl sub_10037A30(double a1, double a2)
{
  double result; // st7@1

  result = 0.0;
  if ( a2 == 0.0 )
  {
    if ( a1 != 0.0 )
    {
      if ( a1 <= 0.0 )
        result = -1.5707963267949;
      else
        result = 1.5707963267949;
    }
  }
  else
  {
    result = atan(a1 / a2);
    if ( a2 < 0.0 )
    {
      result = result + 3.1415926535898;
      sub_10037870(result);
    }
  }
  return result;
}

//----- (10037AA0) --------------------------------------------------------
double __cdecl sub_10037AA0(float a1, float a2)
{
  double result; // st7@1
  float v3; // [sp+4h] [bp-4h]@6
  float v4; // [sp+10h] [bp+8h]@7

  result = 0.0;
  if ( a2 == 0.0 )
  {
    if ( a1 != 0.0 )
    {
      if ( a1 <= 0.0 )
        result = -1.5707964;
      else
        result = 1.5707964;
    }
  }
  else
  {
    v3 = atan(a1 / a2);
    if ( a2 < 0.0 )
    {
      v4 = v3 + 3.141592741012573;
      v3 = sub_10037890(v4);
    }
    result = v3;
  }
  return result;
}

//----- (10037B30) --------------------------------------------------------
int __cdecl sub_10037B30(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(float *)a3 = *(float *)a1 + *(float *)a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) + *(float *)(a2 + 4);
  *(float *)(a3 + 8) = *(float *)(a1 + 8) + *(float *)(a2 + 8);
  return result;
}

//----- (10037B60) --------------------------------------------------------
int __cdecl sub_10037B60(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a2;
  *(float *)a3 = *(float *)a2 * a1;
  *(float *)(a3 + 4) = *(float *)(a2 + 4) * a1;
  *(float *)(a3 + 8) = a1 * *(float *)(a2 + 8);
  return result;
}

//----- (10037B90) --------------------------------------------------------
int __cdecl sub_10037B90(unsigned __int8 a1, unsigned int a2)
{
  return dword_100DB150[a1 ^ (unsigned __int8)a2] ^ (a2 >> 8);
}
// 100DB150: using guessed type int dword_100DB150[];

//----- (10037BB0) --------------------------------------------------------
unsigned int __cdecl sub_10037BB0(unsigned int *a1, signed int a2, unsigned int a3)
{
  unsigned int *v3; // edx@1
  unsigned int result; // eax@1
  signed int i; // esi@1
  unsigned int v6; // edi@5
  unsigned int v7; // eax@6
  unsigned int v8; // eax@6
  unsigned int v9; // eax@6
  unsigned int v10; // eax@6
  unsigned int v11; // ecx@6
  unsigned int v12; // ecx@6
  unsigned int v13; // ecx@6

  v3 = a1;
  result = a3;
  for ( i = a2; i; --i )
  {
    if ( !((unsigned __int8)v3 & 3) )
      break;
    result = dword_100DB150[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    v3 = (unsigned int *)((char *)v3 + 1);
  }
  if ( i >= 8 )
  {
    v6 = (unsigned int)i >> 3;
    do
    {
      v7 = dword_100DB150[(unsigned __int8)result ^ (unsigned __int8)*v3] ^ (result >> 8);
      v8 = dword_100DB150[(unsigned __int8)v7 ^ (unsigned __int8)(*(_WORD *)v3 >> 8)] ^ (v7 >> 8);
      v9 = dword_100DB150[(unsigned __int8)v8 ^ (unsigned __int8)(*v3 >> 16)] ^ (v8 >> 8);
      v10 = dword_100DB150[(unsigned __int8)v9 ^ (*v3 >> 24)] ^ (v9 >> 8);
      v3 += 2;
      v11 = dword_100DB150[(unsigned __int8)v10 ^ (unsigned __int8)*(v3 - 1)] ^ (v10 >> 8);
      v12 = dword_100DB150[(unsigned __int8)v11 ^ (unsigned __int8)(*((_WORD *)v3 - 2) >> 8)] ^ (v11 >> 8);
      v13 = dword_100DB150[(unsigned __int8)v12 ^ (unsigned __int8)(*(v3 - 1) >> 16)] ^ (v12 >> 8);
      i -= 8;
      --v6;
      result = dword_100DB150[(unsigned __int8)v13 ^ (*(v3 - 1) >> 24)] ^ (v13 >> 8);
    }
    while ( v6 );
  }
  for ( ; i > 0; v3 = (unsigned int *)((char *)v3 + 1) )
  {
    result = dword_100DB150[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    --i;
  }
  return result;
}
// 100DB150: using guessed type int dword_100DB150[];

//----- (1003A3B9) --------------------------------------------------------
int __cdecl sub_1003A3B9(int a1, int a2, char a3)
{
  return vscan_fn(sub_1004326B, a2, 0, &a3);
}
// 1003A351: using guessed type int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003B8B5) --------------------------------------------------------
signed int __cdecl sub_1003B8B5(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_101AF348 )
  {
    *a1 = dword_101AF348;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1003DBF5: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101AF348: using guessed type int dword_101AF348;

//----- (1003B8EC) --------------------------------------------------------
signed int __cdecl sub_1003B8EC(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_101AF348 )
  {
    *a1 = dword_101AF354;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1003DBF5: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101AF348: using guessed type int dword_101AF348;
// 101AF354: using guessed type int dword_101AF354;

//----- (1003C532) --------------------------------------------------------
void sub_1003C532()
{
  void **v0; // esi@1
  void *v1; // edi@2
  unsigned int i; // eax@3

  v0 = (void **)dword_101F1440;
  do
  {
    v1 = *v0;
    if ( *v0 )
    {
      for ( i = (unsigned int)v1 + 2048; (unsigned int)v1 < i; i = (unsigned int)*v0 + 2048 )
      {
        if ( *((_DWORD *)v1 + 2) )
          DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
        v1 = (char *)v1 + 64;
      }
      free(*v0);
      *v0 = 0;
    }
    ++v0;
  }
  while ( (signed int)v0 < (signed int)&dword_101F1540 );
}
// 101F1440: using guessed type int dword_101F1440[];
// 101F1540: using guessed type int dword_101F1540;

//----- (1003C9DF) --------------------------------------------------------
int (*sub_1003C9DF())(void)
{
  int (*result)(void); // eax@1
  int (**v1)(void); // esi@1

  result = (int (*)(void))&unk_100ED720;
  v1 = (int (**)(void))&unk_100ED720;
  if ( &unk_100ED720 < &unk_100ED720 )
  {
    do
    {
      result = *v1;
      if ( *v1 )
        result = (int (*)(void))result();
      ++v1;
    }
    while ( v1 < (int (**)(void))&unk_100ED720 );
  }
  return result;
}

//----- (1003CA03) --------------------------------------------------------
void __cdecl sub_1003CA03()
{
  void (**v0)(void); // esi@1

  v0 = (void (**)(void))&unk_100ED728;
  if ( &unk_100ED728 < &unk_100ED728 )
  {
    do
    {
      if ( *v0 )
        (*v0)();
      ++v0;
    }
    while ( v0 < (void (**)(void))&unk_100ED728 );
  }
}

//----- (1003CF5A) --------------------------------------------------------
int __cdecl sub_1003CF5A(int a1, FILE *a2)
{
  FILE *v2; // esi@1
  int v3; // eax@1
  unsigned int v5; // eax@9
  int v6; // eax@15
  char *v7; // edi@15
  signed __int32 v8; // edi@15
  _BYTE *v9; // eax@20
  __int64 v10; // rax@23
  _WORD *v11; // [sp+4h] [bp-4h]@9

  v2 = a2;
  a2 = (FILE *)_fileno(a2);
  v3 = v2->_flag;
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    v2->_flag |= 0x20u;
    return -1;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v3 & 1 )
  {
    v2->_cnt = 0;
    if ( !(v3 & 0x10) )
    {
      v2->_flag = v3 | 0x20;
      return -1;
    }
    v2->_ptr = v2->_base;
    v2->_flag = v3 & 0xFFFFFFFE;
  }
  v5 = v2->_flag & 0xFFFFFFEF | 2;
  v2->_flag = v5;
  v2->_cnt = 0;
  v11 = 0;
  if ( !(v5 & 0x10C)
    && ((void **)v2 != sub_10046EF3() + 8 && (void **)v2 != sub_10046EF3() + 16 || !sub_10046E95((signed int)a2)) )
  {
    _getbuf(v2);
  }
  if ( v2->_flag & 0x108 )
  {
    v6 = (int)v2->_base;
    v7 = v2->_ptr;
    v2->_ptr = (char *)(v6 + 1);
    v8 = (signed __int32)&v7[-v6];
    v2->_cnt = v2->_bufsiz - 1;
    if ( v8 <= 0 )
    {
      if ( a2 == (FILE *)-1 || a2 == (FILE *)-2 )
        v9 = &unk_100EF2A8;
      else
        v9 = (_BYTE *)(dword_101F1440[(signed int)a2 >> 5] + (((unsigned __int8)a2 & 0x1F) << 6));
      if ( v9[4] & 0x20 )
      {
        v10 = _lseeki64((int)a2, 0i64, 2);
        if ( (HIDWORD(v10) & (unsigned int)v10) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v11 = sub_10046D75((int)a2, v6, v8);
    }
    *v2->_base = a1;
  }
  else
  {
    v8 = 1;
    v11 = sub_10046D75((int)a2, (int)&a1, 1u);
  }
  if ( v11 != (_WORD *)v8 )
  {
LABEL_27:
    v2->_flag |= 0x20u;
    return -1;
  }
  return (unsigned __int8)a1;
}
// 10046E51: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 101F1440: using guessed type int dword_101F1440[];

//----- (1003DAEF) --------------------------------------------------------
int __cdecl sub_1003DAEF(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101AF4B0 = a1;
  return result;
}
// 101AF4B0: using guessed type int dword_101AF4B0;

//----- (100421F4) --------------------------------------------------------
#error "100421F9: positive sp value has been found (funcsize=0)"

//----- (100421FF) --------------------------------------------------------
#error "10042204: positive sp value has been found (funcsize=0)"

//----- (1004220A) --------------------------------------------------------
#error "1004220F: positive sp value has been found (funcsize=0)"

//----- (10042210) --------------------------------------------------------
#error "10042215: positive sp value has been found (funcsize=0)"

//----- (10042216) --------------------------------------------------------
#error "1004221B: positive sp value has been found (funcsize=0)"

//----- (1004221C) --------------------------------------------------------
#error "10042221: positive sp value has been found (funcsize=0)"

//----- (10042222) --------------------------------------------------------
#error "1004223D: positive sp value has been found (funcsize=0)"

//----- (10042243) --------------------------------------------------------
#error "10042258: positive sp value has been found (funcsize=0)"

//----- (1004225E) --------------------------------------------------------
#error "10042279: positive sp value has been found (funcsize=0)"

//----- (1004227A) --------------------------------------------------------
#error "10042289: positive sp value has been found (funcsize=0)"

//----- (1004228A) --------------------------------------------------------
#error "1004229D: positive sp value has been found (funcsize=0)"

//----- (1004229E) --------------------------------------------------------
#error "100422AD: positive sp value has been found (funcsize=0)"

//----- (100422AE) --------------------------------------------------------
#error "100422CD: positive sp value has been found (funcsize=0)"

//----- (100422D3) --------------------------------------------------------
#error "100422EC: positive sp value has been found (funcsize=0)"

//----- (100422F2) --------------------------------------------------------
#error "10042311: positive sp value has been found (funcsize=0)"

//----- (10042312) --------------------------------------------------------
#error "10042325: positive sp value has been found (funcsize=0)"

//----- (10042326) --------------------------------------------------------
#error "1004233D: positive sp value has been found (funcsize=0)"

//----- (1004233E) --------------------------------------------------------
#error "10042351: positive sp value has been found (funcsize=0)"

//----- (10042352) --------------------------------------------------------
#error "10042371: positive sp value has been found (funcsize=0)"

//----- (10042377) --------------------------------------------------------
#error "10042390: positive sp value has been found (funcsize=0)"

//----- (10042396) --------------------------------------------------------
#error "100423B5: positive sp value has been found (funcsize=0)"

//----- (100423B6) --------------------------------------------------------
#error "100423C9: positive sp value has been found (funcsize=0)"

//----- (100423CA) --------------------------------------------------------
#error "100423E1: positive sp value has been found (funcsize=0)"

//----- (100423E2) --------------------------------------------------------
#error "100423F5: positive sp value has been found (funcsize=0)"

//----- (100423F6) --------------------------------------------------------
#error "10042415: positive sp value has been found (funcsize=0)"

//----- (1004241B) --------------------------------------------------------
#error "10042434: positive sp value has been found (funcsize=0)"

//----- (1004243A) --------------------------------------------------------
#error "10042459: positive sp value has been found (funcsize=0)"

//----- (1004245A) --------------------------------------------------------
#error "1004246D: positive sp value has been found (funcsize=0)"

//----- (1004246E) --------------------------------------------------------
#error "10042485: positive sp value has been found (funcsize=0)"

//----- (10042486) --------------------------------------------------------
#error "10042499: positive sp value has been found (funcsize=0)"

//----- (1004249A) --------------------------------------------------------
#error "100424B9: positive sp value has been found (funcsize=0)"

//----- (100424BF) --------------------------------------------------------
#error "100424D8: positive sp value has been found (funcsize=0)"

//----- (100424DE) --------------------------------------------------------
#error "100424FD: positive sp value has been found (funcsize=0)"

//----- (100424FE) --------------------------------------------------------
#error "10042511: positive sp value has been found (funcsize=0)"

//----- (10042512) --------------------------------------------------------
#error "10042529: positive sp value has been found (funcsize=0)"

//----- (1004252A) --------------------------------------------------------
#error "1004253D: positive sp value has been found (funcsize=0)"

//----- (1004253E) --------------------------------------------------------
#error "1004255D: positive sp value has been found (funcsize=0)"

//----- (10042563) --------------------------------------------------------
#error "1004257C: positive sp value has been found (funcsize=0)"

//----- (10042582) --------------------------------------------------------
#error "100425A1: positive sp value has been found (funcsize=0)"

//----- (100425A2) --------------------------------------------------------
#error "100425B5: positive sp value has been found (funcsize=0)"

//----- (100425B6) --------------------------------------------------------
#error "100425CD: positive sp value has been found (funcsize=0)"

//----- (100425CE) --------------------------------------------------------
#error "100425E1: positive sp value has been found (funcsize=0)"

//----- (100425E2) --------------------------------------------------------
#error "10042601: positive sp value has been found (funcsize=0)"

//----- (10042607) --------------------------------------------------------
#error "10042620: positive sp value has been found (funcsize=0)"

//----- (10042626) --------------------------------------------------------
#error "10042645: positive sp value has been found (funcsize=0)"

//----- (10042646) --------------------------------------------------------
#error "10042659: positive sp value has been found (funcsize=0)"

//----- (1004265A) --------------------------------------------------------
#error "10042671: positive sp value has been found (funcsize=0)"

//----- (10042672) --------------------------------------------------------
#error "10042685: positive sp value has been found (funcsize=0)"

//----- (1004326B) --------------------------------------------------------
int __cdecl sub_1004326B(FILE *a1, int a2, struct localeinfo_struct *a3, int a4)
{
  unsigned __int8 *v4; // edi@1
  int result; // eax@2
  int *v6; // edi@7
  _BYTE *v7; // eax@7
  int *v8; // edi@12
  _BYTE *v9; // eax@12
  unsigned __int8 v10; // al@16
  unsigned __int8 *v11; // edi@17
  int v12; // eax@19
  _WORD *v13; // esi@24
  int v14; // ebx@25
  int v15; // eax@25
  int v16; // ST10_4@25
  int v17; // ecx@25
  int v18; // eax@35
  unsigned __int8 v19; // al@59
  signed int v20; // ebx@62
  int v21; // eax@65
  int v22; // ecx@69
  int v23; // edi@79
  signed int v24; // ebx@82
  int v25; // ebx@84
  int i; // eax@90
  int v27; // eax@91
  int v28; // ecx@92
  int v29; // eax@96
  int j; // eax@98
  int v31; // eax@99
  int v32; // ecx@100
  int v33; // eax@106
  int v34; // ecx@107
  int v35; // ecx@108
  int v36; // eax@112
  int k; // eax@115
  int v38; // eax@116
  int v39; // ecx@117
  void *v40; // ST0C_4@124
  _WORD *v41; // ST08_4@124
  int v42; // ST04_4@124
  void (__cdecl *v43)(int, _WORD *, void *, struct localeinfo_struct *); // eax@124
  _WORD *v44; // edi@129
  int v45; // ST10_4@130
  int v46; // eax@132
  signed int v47; // eax@133
  _BYTE *v48; // edi@156
  unsigned __int8 *v49; // esi@156
  unsigned __int8 v50; // dl@159
  unsigned __int8 v51; // al@165
  unsigned int v52; // edi@168
  int v53; // edx@168
  unsigned int v54; // ecx@172
  unsigned int v55; // eax@172
  unsigned __int8 v56; // al@173
  int v57; // eax@181
  int v58; // ecx@181
  int v59; // eax@219
  int v60; // ST10_4@219
  int v61; // ecx@219
  unsigned int v62; // esi@222
  int v63; // eax@225
  int v64; // ST10_4@225
  int v65; // eax@238
  int v66; // ST10_4@238
  int v67; // ecx@238
  int v68; // edi@241
  int v69; // eax@244
  int v70; // ST10_4@244
  int v71; // ebx@265
  int v72; // eax@265
  int v73; // eax@267
  int v74; // ecx@267
  bool v75; // zf@275
  int v76; // [sp-4h] [bp-80h]@18
  int v77; // [sp-4h] [bp-80h]@94
  int v78; // [sp-4h] [bp-80h]@143
  int v79; // [sp-4h] [bp-80h]@266
  _WORD **v80; // [sp+Ch] [bp-70h]@0
  struct localeinfo_struct Locale; // [sp+10h] [bp-6Ch]@16
  int v82; // [sp+18h] [bp-64h]@288
  char v83; // [sp+1Ch] [bp-60h]@287
  wchar_t DstCh[2]; // [sp+20h] [bp-5Ch]@1
  _WORD **v85; // [sp+24h] [bp-58h]@1
  int v86; // [sp+28h] [bp-54h]@24
  char SrcCh; // [sp+2Ch] [bp-50h]@143
  char v88; // [sp+2Dh] [bp-4Fh]@144
  int v89; // [sp+30h] [bp-4Ch]@1
  int v90; // [sp+34h] [bp-48h]@24
  int v91; // [sp+38h] [bp-44h]@1
  unsigned __int8 v92; // [sp+3Fh] [bp-3Dh]@24
  int v93; // [sp+40h] [bp-3Ch]@16
  _WORD *v94; // [sp+44h] [bp-38h]@58
  unsigned __int64 v95; // [sp+48h] [bp-34h]@36
  int v96; // [sp+50h] [bp-2Ch]@24
  unsigned __int8 *v97; // [sp+54h] [bp-28h]@1
  void *v98; // [sp+58h] [bp-24h]@1
  int v99; // [sp+5Ch] [bp-20h]@62
  int v100; // [sp+60h] [bp-1Ch]@24
  char v101; // [sp+64h] [bp-18h]@24
  char v102; // [sp+65h] [bp-17h]@24
  char v103; // [sp+66h] [bp-16h]@24
  char v104; // [sp+67h] [bp-15h]@16
  FILE *v105; // [sp+68h] [bp-14h]@1
  char v106; // [sp+6Eh] [bp-Eh]@24
  char v107; // [sp+6Fh] [bp-Dh]@24
  int v108; // [sp+70h] [bp-Ch]@24
  char v109; // [sp+77h] [bp-5h]@24
  int v110; // [sp+78h] [bp-4h]@1
  char v111; // [sp+7Fh] [bp+3h]@24
  int v112; // [sp+80h] [bp+4h]@16
  char v113; // [sp+84h] [bp+8h]@1
  char v114[11]; // [sp+1E4h] [bp+168h]@140
  char v115; // [sp+1EFh] [bp+173h]@159

  v4 = (unsigned __int8 *)a2;
  v85 = (_WORD **)a4;
  v105 = a1;
  v97 = (unsigned __int8 *)a2;
  v98 = &v113;
  v89 = 350;
  v91 = 0;
  *(_DWORD *)DstCh = 0;
  v110 = 0;
  if ( !a2 || !a1 )
    goto LABEL_294;
  if ( a1->_flag & 0x40 )
    goto LABEL_16;
  if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
  {
    v7 = &unk_100EF2A8;
  }
  else
  {
    v6 = &dword_101F1440[_fileno(a1) >> 5];
    v7 = (_BYTE *)(*v6 + ((_fileno(a1) & 0x1F) << 6));
  }
  if ( v7[36] & 0x7F
    || (_fileno(a1) == -1 || _fileno(a1) == -2 ? (v9 = &unk_100EF2A8) : (v8 = &dword_101F1440[_fileno(a1) >> 5],
                                                                         v9 = (_BYTE *)(*v8 + ((_fileno(a1) & 0x1F) << 6))),
        v9[36] & 0x80) )
  {
LABEL_294:
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v4 = v97;
LABEL_16:
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a3);
  v10 = *v4;
  v75 = *v4 == 0;
  v104 = 0;
  v112 = 0;
  v93 = 0;
  if ( v75 )
    goto LABEL_289;
  v11 = v97;
  while ( 2 )
  {
    if ( isspace(v10) )
    {
      --v112;
      v12 = _whiteout(v105);
      if ( v12 != -1 )
        sub_1004926A(v12, v105);
      do
        ++v11;
      while ( isspace(*v11) );
      goto LABEL_273;
    }
    if ( *v11 != 37 )
    {
      ++v112;
      v71 = _inc(v76, v105);
      v72 = *v11++;
      v110 = v71;
      v97 = v11;
      if ( v72 == v71 )
      {
        if ( !isleadbyte((unsigned __int8)v71) )
          goto LABEL_269;
        ++v112;
        v73 = _inc(v79, v105);
        v74 = *v11++;
        v97 = v11;
        if ( v74 == v73 )
        {
          --v112;
          goto LABEL_269;
        }
        if ( v73 != -1 )
          sub_1004926A(v73, v105);
      }
      v75 = v71 == -1;
      goto LABEL_279;
    }
    v86 = 0;
    v92 = 0;
    v100 = 0;
    v96 = 0;
    v108 = 0;
    v101 = 0;
    v102 = 0;
    v107 = 0;
    v111 = 0;
    v103 = 0;
    v109 = 0;
    v106 = 1;
    v90 = 0;
    v13 = 0;
    do
    {
      v14 = *++v11;
      v15 = isdigit(v14);
      v17 = v16;
      if ( v15 )
      {
        ++v96;
        v108 = 10 * v108 + v14 - 48;
        continue;
      }
      if ( v14 > 78 )
      {
        if ( v14 == 104 )
        {
          --v106;
          --v109;
        }
        else
        {
          if ( v14 == 108 )
          {
            v18 = (int)(v11 + 1);
            if ( v11[1] == 108 )
              goto LABEL_36;
            ++v106;
          }
          else if ( v14 != 119 )
          {
            goto LABEL_50;
          }
          ++v109;
        }
      }
      else
      {
        if ( v14 == 78 )
          continue;
        if ( v14 == 42 )
        {
          ++v107;
          continue;
        }
        if ( v14 == 70 )
          continue;
        if ( v14 != 73 )
        {
          if ( v14 == 76 )
          {
            ++v106;
            continue;
          }
LABEL_50:
          ++v111;
          continue;
        }
        LOBYTE(v17) = v11[1];
        if ( (_BYTE)v17 == 54 )
        {
          v18 = (int)(v11 + 2);
          if ( v11[2] == 52 )
          {
LABEL_36:
            ++v90;
            v11 = (unsigned __int8 *)v18;
            v95 = 0i64;
            continue;
          }
        }
        if ( (_BYTE)v17 == 51 && v11[2] == 50 )
        {
          v11 += 2;
          continue;
        }
        if ( (_BYTE)v17 != 100 && (_BYTE)v17 != 105 && (_BYTE)v17 != 111 && (_BYTE)v17 != 120 && (_BYTE)v17 != 88 )
          goto LABEL_50;
      }
    }
    while ( !v111 );
    v97 = v11;
    if ( !v107 )
    {
      v13 = *v85;
      v80 = v85;
      ++v85;
    }
    v94 = v13;
    v111 = 0;
    if ( !v109 )
    {
      v19 = *v11;
      if ( *v11 == 83 || (v109 = -1, v19 == 67) )
        v109 = 1;
    }
    v99 = *v11 | 0x20;
    v20 = v99;
    if ( v99 != 110 )
    {
      if ( v99 == 99 || v99 == 123 )
      {
        ++v112;
        v21 = _inc(v17, v105);
      }
      else
      {
        v21 = _whiteout(v105);
      }
      v110 = v21;
      if ( v21 == -1 )
        goto LABEL_281;
      v13 = v94;
      v11 = v97;
    }
    v22 = v96;
    if ( v96 && !v108 )
      goto LABEL_275;
    if ( v20 > 111 )
    {
      if ( v20 == 112 )
      {
        v106 = 1;
      }
      else
      {
        if ( v20 == 115 )
        {
LABEL_127:
          if ( v109 > 0 )
            v103 = 1;
          goto LABEL_129;
        }
        if ( v20 != 117 )
        {
          if ( v20 == 120 )
            goto LABEL_82;
          if ( v20 != 123 )
            goto LABEL_151;
          if ( v109 > 0 )
            v103 = 1;
          v48 = v11 + 1;
          v49 = v48;
          if ( *v48 == 94 )
          {
            v49 = v48 + 1;
            v101 = -1;
          }
          memset(v114, 0, 0x20u);
          if ( *v49 == 93 )
          {
            v50 = 93;
            ++v49;
            v115 = 32;
          }
          else
          {
            v50 = v92;
          }
          while ( 1 )
          {
            v56 = *v49;
            if ( *v49 == 93 )
              break;
            ++v49;
            if ( v56 == 45 && v50 && (LOBYTE(v22) = *v49, *v49 != 93) )
            {
              ++v49;
              if ( v50 >= (unsigned __int8)v22 )
              {
                v51 = v50;
                v50 = v22;
              }
              else
              {
                v51 = v22;
              }
              if ( v50 <= v51 )
              {
                v52 = v50;
                v53 = (unsigned __int8)(v51 - v50 + 1);
                do
                {
                  v22 = v52 & 7;
                  v114[v52 >> 3] |= 1 << v22;
                  ++v52;
                  --v53;
                }
                while ( v53 );
                v20 = v99;
              }
              v50 = 0;
            }
            else
            {
              v54 = v56;
              v50 = v56;
              v55 = v54;
              v22 = v54 & 7;
              v114[v55 >> 3] |= 1 << v22;
              v20 = v99;
            }
          }
          v97 = v49;
          v13 = v94;
LABEL_129:
          --v112;
          v44 = v13;
          if ( v110 != -1 )
          {
            sub_1004926A(v110, v105);
            v22 = v45;
          }
          while ( 1 )
          {
            if ( v96 )
            {
              v46 = v108--;
              if ( !v46 )
                goto LABEL_200;
            }
            ++v112;
            v47 = _inc(v22, v105);
            v110 = v47;
            if ( v47 == -1 )
              goto LABEL_198;
            if ( v20 != 99 )
            {
              if ( v20 != 115 )
                goto LABEL_295;
              if ( v47 >= 9 && v47 <= 13 )
              {
LABEL_198:
                --v112;
                if ( v47 != -1 )
                  sub_1004926A(v47, v105);
LABEL_200:
                if ( v44 != v13 )
                {
                  if ( !v107 )
                  {
                    ++v93;
                    if ( v20 != 99 )
                    {
                      if ( v103 )
                        *v94 = 0;
                      else
                        *(_BYTE *)v94 = 0;
                    }
                  }
                  goto LABEL_264;
                }
                goto LABEL_281;
              }
              if ( v47 == 32 )
              {
LABEL_295:
                if ( v20 != 123 )
                  goto LABEL_198;
                v22 = v101 ^ v114[v47 >> 3];
                v20 = v99;
                if ( !((1 << (v47 & 7)) & v22) )
                  goto LABEL_198;
              }
            }
            if ( v107 )
            {
              v44 = (_WORD *)((char *)v44 + 1);
            }
            else
            {
              if ( v103 )
              {
                SrcCh = v47;
                if ( isleadbyte((unsigned __int8)v47) )
                {
                  ++v112;
                  v88 = _inc(v78, v105);
                }
                *(_DWORD *)DstCh = 63;
                _mbtowc_l(DstCh, &SrcCh, Locale.locinfo->mb_cur_max, &Locale);
                *v13 = DstCh[0];
                ++v13;
              }
              else
              {
                *(_BYTE *)v13 = v47;
                v13 = (_WORD *)((char *)v13 + 1);
              }
              v94 = v13;
            }
          }
        }
      }
LABEL_207:
      v24 = v110;
      if ( v110 == 45 )
      {
        v102 = 1;
      }
      else if ( v110 != 43 )
      {
        goto LABEL_215;
      }
      if ( !--v108 && v96 )
      {
        v111 = 1;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v96, v105);
      goto LABEL_214;
    }
    if ( v20 == 111 )
      goto LABEL_207;
    if ( v20 == 99 )
    {
      if ( !v96 )
      {
        ++v108;
        v96 = 1;
      }
      goto LABEL_127;
    }
    if ( v20 == 100 )
      goto LABEL_207;
    if ( v20 <= 100 )
      goto LABEL_151;
    if ( v20 <= 103 )
    {
      v25 = 0;
      if ( v110 == 45 )
      {
        *(_BYTE *)v98 = 45;
        v25 = 1;
        goto LABEL_87;
      }
      if ( v110 == 43 )
      {
LABEL_87:
        --v108;
        ++v112;
        v110 = _inc(v22, v105);
      }
      if ( !v96 )
        v108 = -1;
      for ( i = (unsigned __int8)v110; isdigit(i); i = (unsigned __int8)v110 )
      {
        v27 = v108--;
        if ( !v27 )
          break;
        ++v100;
        *((_BYTE *)v98 + v25++) = v110;
        if ( !__check_float_string(v25, &v113, (int)&v91) )
          goto LABEL_281;
        ++v112;
        v110 = _inc(v28, v105);
      }
      v101 = **(_BYTE **)Locale.locinfo->lconv;
      if ( v101 == (_BYTE)v110 )
      {
        v29 = v108--;
        if ( v29 )
        {
          ++v112;
          v110 = _inc(v77, v105);
          *((_BYTE *)v98 + v25++) = v101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          for ( j = (unsigned __int8)v110; isdigit(j); j = (unsigned __int8)v110 )
          {
            v31 = v108--;
            if ( !v31 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v32, v105);
          }
        }
      }
      if ( v100 && (v110 == 101 || v110 == 69) )
      {
        v33 = v108--;
        if ( v33 )
        {
          *((_BYTE *)v98 + v25++) = 101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          ++v112;
          v110 = _inc(v34, v105);
          if ( v110 == 45 )
          {
            *((_BYTE *)v98 + v25++) = 45;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
LABEL_112:
            v36 = v108--;
            if ( v36 )
            {
              ++v112;
              v110 = _inc(v35, v105);
            }
            else
            {
              v108 = 0;
            }
          }
          else if ( v110 == 43 )
          {
            goto LABEL_112;
          }
          for ( k = (unsigned __int8)v110; isdigit(k); k = (unsigned __int8)v110 )
          {
            v38 = v108--;
            if ( !v38 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v39, v105);
          }
        }
      }
      --v112;
      if ( v110 != -1 )
        sub_1004926A(v110, v105);
      if ( v100 )
      {
        if ( !v107 )
        {
          ++v93;
          v40 = v98;
          v41 = v94;
          *((_BYTE *)v98 + v25) = 0;
          v42 = v106 - 1;
          v43 = (void (__cdecl *)(int, _WORD *, void *, struct localeinfo_struct *))_decode_pointer(off_100EF28C[0]);
          v43(v42, v41, v40, &Locale);
        }
        goto LABEL_264;
      }
      goto LABEL_281;
    }
    if ( v20 != 105 )
    {
      if ( v20 == 110 )
      {
        v23 = v112;
        if ( !v107 )
        {
LABEL_259:
          if ( v90 )
          {
            *(_QWORD *)v13 = v95;
          }
          else if ( v106 )
          {
            *(_DWORD *)v13 = v23;
          }
          else
          {
            *v13 = v23;
          }
        }
        goto LABEL_264;
      }
LABEL_151:
      if ( *v11 == v110 )
      {
        --v104;
        if ( !v107 )
          v85 = v80;
        goto LABEL_264;
      }
LABEL_275:
      v75 = v110 == -1;
LABEL_279:
      if ( !v75 )
        sub_1004926A(v110, v105);
      goto LABEL_281;
    }
    v99 = 100;
LABEL_82:
    v24 = v110;
    if ( v110 == 45 )
    {
      v102 = 1;
      goto LABEL_176;
    }
    if ( v110 == 43 )
    {
LABEL_176:
      if ( --v108 || !v96 )
      {
        ++v112;
        v24 = _inc(v96, v105);
        v110 = v24;
      }
      else
      {
        v111 = 1;
      }
    }
    if ( v24 == 48 )
    {
      ++v112;
      v57 = _inc(v22, v105);
      v24 = v57;
      v110 = v57;
      if ( (_BYTE)v57 != 120 && (_BYTE)v57 != 88 )
      {
        v100 = 1;
        if ( v99 != 120 )
        {
          if ( v96 )
          {
            if ( !--v108 )
              ++v111;
          }
          v99 = 111;
          goto LABEL_215;
        }
        --v112;
        if ( v57 != -1 )
          sub_1004926A(v57, v105);
        v24 = 48;
LABEL_214:
        v110 = v24;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v58, v105);
      v110 = v24;
      if ( v96 )
      {
        v108 -= 2;
        if ( v108 < 1 )
          ++v111;
      }
      v99 = 120;
    }
LABEL_215:
    if ( !v90 )
    {
      v23 = v86;
      if ( !v111 )
      {
        while ( 1 )
        {
          if ( v99 == 120 || v99 == 112 )
          {
            if ( !isxdigit((unsigned __int8)v24) )
            {
LABEL_250:
              --v112;
              if ( v24 != -1 )
                sub_1004926A(v24, v105);
              break;
            }
            v68 = 16 * v23;
            v69 = isdigit((unsigned __int8)v24);
            v67 = v70;
            v24 = (char)v24;
            if ( !v69 )
              v24 = (v24 & 0xFFFFFFDF) - 7;
            v110 = v24;
          }
          else
          {
            v65 = isdigit((unsigned __int8)v24);
            v67 = v66;
            if ( !v65 )
              goto LABEL_250;
            if ( v99 == 111 )
            {
              if ( v24 >= 56 )
                goto LABEL_250;
              v68 = 8 * v23;
            }
            else
            {
              v68 = 10 * v23;
            }
          }
          ++v100;
          v23 = v68 + v24 - 48;
          if ( v96 )
          {
            if ( !--v108 )
              break;
          }
          ++v112;
          v24 = _inc(v67, v105);
          v110 = v24;
        }
      }
      if ( v102 )
        v23 = -v23;
      goto LABEL_254;
    }
    if ( v111 )
      goto LABEL_233;
    while ( 2 )
    {
      if ( v99 != 120 && v99 != 112 )
      {
        v59 = isdigit((unsigned __int8)v24);
        v61 = v60;
        if ( !v59 )
          break;
        if ( v99 == 111 )
        {
          if ( v24 >= 56 )
            break;
          v62 = 8 * v95;
          HIDWORD(v95) = v95 >> 29;
        }
        else
        {
          HIDWORD(v95) = 10 * v95 >> 32;
          v62 = 10 * v95;
        }
        goto LABEL_228;
      }
      if ( isxdigit((unsigned __int8)v24) )
      {
        v62 = 16 * v95;
        HIDWORD(v95) = v95 >> 28;
        v63 = isdigit((unsigned __int8)v24);
        v61 = v64;
        v24 = (char)v24;
        if ( !v63 )
          v24 = (v24 & 0xFFFFFFDF) - 7;
        v110 = v24;
LABEL_228:
        ++v100;
        v95 = v24 - 48 + __PAIR__(HIDWORD(v95), v62);
        if ( v96 )
        {
          if ( !--v108 )
            goto LABEL_233;
        }
        ++v112;
        v24 = _inc(v61, v105);
        v110 = v24;
        continue;
      }
      break;
    }
    --v112;
    if ( v24 != -1 )
      sub_1004926A(v24, v105);
LABEL_233:
    v23 = v86;
    if ( v102 )
      v95 = -(signed __int64)v95;
LABEL_254:
    if ( v99 == 70 )
      v100 = 0;
    if ( !v100 )
      goto LABEL_281;
    if ( !v107 )
    {
      ++v93;
      v13 = v94;
      goto LABEL_259;
    }
LABEL_264:
    ++v104;
    v11 = v97++ + 1;
LABEL_269:
    if ( v110 != -1 )
    {
LABEL_273:
      v10 = *v11;
      if ( !*v11 )
        goto LABEL_281;
      continue;
    }
    break;
  }
  if ( *v11 == 37 && v97[1] == 110 )
  {
    v11 = v97;
    goto LABEL_273;
  }
LABEL_281:
  if ( v91 == 1 )
    free(v98);
  if ( v110 == -1 )
  {
    result = v93;
    if ( !v93 && v104 == (_BYTE)v93 )
      result = -1;
    if ( v83 )
      *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
    return result;
  }
LABEL_289:
  if ( v83 )
    *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
  return v93;
}
// 1003BBEB: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1003DBF5: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10043230: using guessed type int __fastcall _inc(_DWORD, _DWORD);
// 10043246: using guessed type _DWORD __cdecl _whiteout(_DWORD);
// 100EF28C: using guessed type int (*off_100EF28C[3])();
// 101F1440: using guessed type int dword_101F1440[];
// 1004326B: using guessed type char var_24[11];

//----- (10044690) --------------------------------------------------------
int __cdecl sub_10044690(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_10047819((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 1003E7D1: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10044736) --------------------------------------------------------
int __cdecl sub_10044736(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_10047D5B((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 1003E7D1: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10044BA2) --------------------------------------------------------
void sub_10044BA2()
{
  dword_101F141C = 0;
}
// 101F141C: using guessed type int dword_101F141C;

//----- (10044CF5) --------------------------------------------------------
int sub_10044CF5()
{
  dword_101F1558 = _get_sse2_info();
  return 0;
}
// 10044C95: using guessed type int _get_sse2_info(void);
// 101F1558: using guessed type int dword_101F1558;

//----- (100451F2) --------------------------------------------------------
int sub_100451F2()
{
  return _decode_pointer(dword_101AF978);
}
// 1003BBEB: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 101AF978: using guessed type int dword_101AF978;

//----- (100453AF) --------------------------------------------------------
int __cdecl sub_100453AF(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101AF984 = a1;
  return result;
}
// 101AF984: using guessed type int dword_101AF984;

//----- (100453B9) --------------------------------------------------------
int __cdecl sub_100453B9(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101AF990 = a1;
  return result;
}
// 101AF990: using guessed type int dword_101AF990;

//----- (100453C3) --------------------------------------------------------
int __cdecl sub_100453C3(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101AF994 = a1;
  return result;
}
// 101AF994: using guessed type int dword_101AF994;

//----- (100454A2) --------------------------------------------------------
int __cdecl sub_100454A2(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101AF998 = a1;
  return result;
}
// 101AF998: using guessed type int dword_101AF998;

//----- (100465B7) --------------------------------------------------------
DWORD __cdecl sub_100465B7(int a1, int a2, int a3, DWORD dwMoveMethod)
{
  void *v4; // eax@1
  DWORD v6; // eax@5
  _BYTE *v7; // eax@7
  DWORD lDistanceToMove; // [sp+8h] [bp-8h]@4
  LONG DistanceToMoveHigh; // [sp+Ch] [bp-4h]@1

  DistanceToMoveHigh = a3;
  v4 = (void *)sub_1004A6FC(a1);
  if ( v4 == (void *)-1 )
  {
    *_errno() = 9;
    return -1;
  }
  lDistanceToMove = SetFilePointer(v4, a2, &DistanceToMoveHigh, dwMoveMethod);
  if ( lDistanceToMove == -1 )
  {
    v6 = GetLastError();
    if ( v6 )
    {
      _dosmaperr(v6);
      return -1;
    }
  }
  v7 = (_BYTE *)(dword_101F1440[a1 >> 5] + ((a1 & 0x1F) << 6) + 4);
  *v7 &= 0xFDu;
  return lDistanceToMove;
}
// 1003A801: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 101F1440: using guessed type int dword_101F1440[];

//----- (10046753) --------------------------------------------------------
_WORD *__cdecl sub_10046753(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // esi@5
  int v5; // edi@5
  int v6; // eax@5
  char v7; // bl@5
  int v8; // eax@13
  void *v9; // ST18_4@13
  DWORD v10; // eax@16
  const char *v11; // ebx@16
  char v12; // cl@19
  int *v13; // esi@19
  int v14; // eax@19
  int v15; // eax@20
  int v16; // eax@27
  signed int v17; // esi@27
  int v18; // eax@31
  int v19; // esi@36
  __int16 v20; // ax@39
  int v21; // ecx@45
  char v22; // dl@45
  int v23; // eax@46
  DWORD v24; // ecx@51
  char *v25; // eax@51
  char *v26; // edx@53
  char v27; // dl@53
  int v28; // ebx@56
  DWORD v29; // ecx@64
  char *v30; // eax@64
  __int16 *v31; // edx@66
  __int16 v32; // dx@66
  int v33; // ebx@69
  DWORD v34; // ecx@74
  WCHAR *v35; // eax@74
  WCHAR v36; // dx@76
  int v37; // esi@79
  int v38; // ebx@79
  DWORD Mode; // [sp+4h] [bp-7Ch]@13
  int v40; // [sp+8h] [bp-78h]@13
  char v41; // [sp+Fh] [bp-71h]@5
  int *v42; // [sp+10h] [bp-70h]@5
  DWORD v43; // [sp+14h] [bp-6Ch]@56
  int v44; // [sp+18h] [bp-68h]@1
  LPCVOID lpBuffer; // [sp+1Ch] [bp-64h]@1
  _WORD *v46; // [sp+20h] [bp-60h]@1
  DWORD NumberOfBytesWritten; // [sp+24h] [bp-5Ch]@16
  WCHAR WideCharStr[2]; // [sp+28h] [bp-58h]@20
  _WORD *v49; // [sp+2Ch] [bp-54h]@17
  char Buffer; // [sp+30h] [bp-50h]@51
  CHAR v51[688]; // [sp+184h] [bp+104h]@79
  WCHAR v52; // [sp+434h] [bp+3B4h]@74
  CHAR MultiByteStr; // [sp+588h] [bp+508h]@20
  char v54; // [sp+589h] [bp+509h]@20

  lpBuffer = (LPCVOID)a2;
  v46 = 0;
  v44 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a2 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  v4 = &dword_101F1440[a1 >> 5];
  v5 = (a1 & 0x1F) << 6;
  v6 = v5 + *v4;
  v7 = (char)(2 * *(_BYTE *)(v6 + 36)) >> 1;
  v42 = &dword_101F1440[a1 >> 5];
  v41 = v7;
  if ( (v7 == 2 || v7 == 1) && !(~(_BYTE)nNumberOfBytesToWrite & 1) )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  if ( *(_BYTE *)(v6 + 4) & 0x20 )
    sub_100465B7(a1, 0, 0, 2u);
  if ( sub_10046E95(a1) )
  {
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x80 )
    {
      v8 = _getptd();
      v9 = *(void **)(v5 + *v4);
      v40 = *(_DWORD *)(*(_DWORD *)(v8 + 108) + 20) == 0;
      if ( GetConsoleMode(v9, &Mode) )
      {
        if ( !v40 || v7 )
        {
          v10 = GetConsoleCP();
          v11 = (const char *)lpBuffer;
          Mode = v10;
          NumberOfBytesWritten = 0;
          if ( nNumberOfBytesToWrite )
          {
            v49 = 0;
            while ( 1 )
            {
              if ( v41 )
              {
                if ( v41 == 1 || v41 == 2 )
                {
                  v19 = *(_WORD *)v11;
                  v11 += 2;
                  ++v49;
                  *(_DWORD *)WideCharStr = v19;
                  v40 = (_WORD)v19 == 10;
                }
                if ( v41 == 1 || v41 == 2 )
                {
                  v20 = _putwch_nolock(WideCharStr[0]);
                  if ( v20 != WideCharStr[0] )
                    goto LABEL_89;
                  v46 = (_WORD *)((char *)v46 + 1);
                  if ( v40 )
                  {
                    *(_DWORD *)WideCharStr = 13;
                    if ( (unsigned __int16)_putwch_nolock(13) != 13 )
                      goto LABEL_89;
                    v46 = (_WORD *)((char *)v46 + 1);
                    ++v44;
                  }
                }
                goto LABEL_43;
              }
              v12 = *v11;
              v13 = v42;
              v40 = *v11 == 10;
              v14 = v5 + *v42;
              if ( *(_DWORD *)(v14 + 56) )
              {
                MultiByteStr = *(_BYTE *)(v14 + 52);
                v54 = v12;
                *(_DWORD *)(v14 + 56) = 0;
                v15 = mbtowc(WideCharStr, &MultiByteStr, 2u);
              }
              else
              {
                if ( isleadbyte(v12) )
                {
                  if ( nNumberOfBytesToWrite + (_BYTE *)lpBuffer - v11 <= 1 )
                  {
                    v21 = *v13;
                    v22 = *v11;
                    v46 = (_WORD *)((char *)v46 + 1);
                    *(_BYTE *)(v5 + v21 + 52) = v22;
                    *(_DWORD *)(v5 + *v13 + 56) = 1;
                    goto LABEL_90;
                  }
                  if ( mbtowc(WideCharStr, v11, 2u) == -1 )
                    goto LABEL_90;
                  ++v11;
                  v49 = (_WORD *)((char *)v49 + 1);
                  goto LABEL_27;
                }
                v15 = mbtowc(WideCharStr, v11, 1u);
              }
              if ( v15 == -1 )
                goto LABEL_90;
LABEL_27:
              ++v11;
              v49 = (_WORD *)((char *)v49 + 1);
              v16 = WideCharToMultiByte(Mode, 0, WideCharStr, 1, &MultiByteStr, 5, 0, 0);
              v17 = v16;
              if ( !v16 )
                goto LABEL_90;
              if ( !WriteFile(*(HANDLE *)(v5 + *v42), &MultiByteStr, v16, &NumberOfBytesWritten, 0) )
                goto LABEL_89;
              v46 = (_WORD *)((char *)v49 + v44);
              if ( (signed int)NumberOfBytesWritten < v17 )
                goto LABEL_90;
              if ( v40 )
              {
                v18 = *v42;
                MultiByteStr = 13;
                if ( !WriteFile(*(HANDLE *)(v5 + v18), &MultiByteStr, 1u, &NumberOfBytesWritten, 0) )
                  goto LABEL_89;
                if ( (signed int)NumberOfBytesWritten < 1 )
                  goto LABEL_90;
                ++v44;
                v46 = (_WORD *)((char *)v46 + 1);
              }
LABEL_43:
              if ( (unsigned int)v49 >= nNumberOfBytesToWrite )
                goto LABEL_90;
            }
          }
          goto LABEL_91;
        }
      }
    }
  }
  v23 = v5 + *v4;
  if ( *(_BYTE *)(v23 + 4) & 0x80 )
  {
    *(_DWORD *)WideCharStr = 0;
    if ( v7 )
    {
      v49 = lpBuffer;
      if ( v7 == 2 )
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v29 = (char *)v49 - (_BYTE *)lpBuffer;
          v30 = &Buffer;
          do
          {
            if ( v29 >= nNumberOfBytesToWrite )
              break;
            v31 = v49;
            ++v49;
            v32 = *v31;
            v29 += 2;
            if ( v32 == 10 )
            {
              v44 += 2;
              *(_WORD *)v30 = 13;
              v30 += 2;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *(_WORD *)v30 = v32;
            v30 += 2;
          }
          while ( NumberOfBytesWritten < 0x3FF );
          v33 = v30 - &Buffer;
          if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v30 - &Buffer, &v43, 0) )
            break;
          v46 = (_WORD *)((char *)v46 + v43);
          if ( (signed int)v43 < v33 || (char *)v49 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
            goto LABEL_90;
          v4 = v42;
        }
      }
      else
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v34 = (char *)v49 - (_BYTE *)lpBuffer;
          v35 = &v52;
          do
          {
            if ( v34 >= nNumberOfBytesToWrite )
              break;
            v36 = *v49;
            ++v49;
            v34 += 2;
            if ( v36 == 10 )
            {
              *v35 = 13;
              ++v35;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *v35 = v36;
            ++v35;
          }
          while ( NumberOfBytesWritten < 0x152 );
          v37 = 0;
          v38 = WideCharToMultiByte(0xFDE9u, 0, &v52, v35 - &v52, v51, 683, 0, 0);
          if ( !v38 )
            break;
          while ( WriteFile(*(HANDLE *)(v5 + *v42), &v51[v37], v38 - v37, &v43, 0) )
          {
            v37 += v43;
            if ( v38 <= v37 )
              goto LABEL_84;
          }
          *(_DWORD *)WideCharStr = GetLastError();
LABEL_84:
          if ( v38 <= v37 )
          {
            v46 = (_WORD *)((char *)v49 - (_BYTE *)lpBuffer);
            if ( (char *)v49 - (_BYTE *)lpBuffer < nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_90;
        }
      }
    }
    else
    {
      NumberOfBytesWritten = (DWORD)lpBuffer;
      if ( nNumberOfBytesToWrite <= 0 )
        goto LABEL_96;
      while ( 1 )
      {
        v49 = 0;
        v24 = NumberOfBytesWritten - (_DWORD)lpBuffer;
        v25 = &Buffer;
        do
        {
          if ( v24 >= nNumberOfBytesToWrite )
            break;
          v26 = (char *)NumberOfBytesWritten++;
          v27 = *v26;
          ++v24;
          if ( v27 == 10 )
          {
            ++v44;
            *v25++ = 13;
            v49 = (_WORD *)((char *)v49 + 1);
          }
          *v25++ = v27;
          v49 = (_WORD *)((char *)v49 + 1);
        }
        while ( (unsigned int)v49 < 0x400 );
        v28 = v25 - &Buffer;
        if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v25 - &Buffer, &v43, 0) )
          break;
        v46 = (_WORD *)((char *)v46 + v43);
        if ( (signed int)v43 < v28 || NumberOfBytesWritten - (unsigned int)lpBuffer >= nNumberOfBytesToWrite )
          goto LABEL_90;
        v4 = v42;
      }
    }
  }
  else if ( WriteFile(*(HANDLE *)v23, lpBuffer, nNumberOfBytesToWrite, &v43, 0) )
  {
    *(_DWORD *)WideCharStr = 0;
    v46 = (_WORD *)v43;
    goto LABEL_90;
  }
LABEL_89:
  *(_DWORD *)WideCharStr = GetLastError();
LABEL_90:
  if ( !v46 )
  {
LABEL_91:
    if ( *(_DWORD *)WideCharStr )
    {
      if ( *(_DWORD *)WideCharStr == 5 )
      {
        *_errno() = 9;
        *__doserrno() = 5;
      }
      else
      {
        _dosmaperr(*(_DWORD *)WideCharStr);
      }
      return (_WORD *)-1;
    }
    v4 = v42;
LABEL_96:
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x40 && *(_BYTE *)lpBuffer == 26 )
      return 0;
    *_errno() = 28;
    *__doserrno() = 0;
    return (_WORD *)-1;
  }
  return (_WORD *)((char *)v46 - v44);
}
// 1003A801: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 1003BE07: using guessed type int _getptd(void);
// 1003DBF5: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101F1440: using guessed type int dword_101F1440[];
// 10046753: using guessed type CHAR var_410[688];

//----- (10046D75) --------------------------------------------------------
_WORD *__cdecl sub_10046D75(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // ebx@7
  int v5; // esi@7
  _WORD *v6; // [sp+14h] [bp-1Ch]@9

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return (_WORD *)-1;
  }
  if ( a1 < 0
    || a1 >= uNumber
    || (v4 = &dword_101F1440[a1 >> 5], v5 = (a1 & 0x1F) << 6, !(*(_BYTE *)(*v4 + v5 + 4) & 1)) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  __lock_fhandle(a1);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    v6 = sub_10046753(a1, a2, nNumberOfBytesToWrite);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    v6 = (_WORD *)-1;
  }
  sub_1004A80D(a1);
  return v6;
}
// 1003DBF5: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1004A76D: using guessed type _DWORD __cdecl __lock_fhandle(_DWORD);
// 101F1440: using guessed type int dword_101F1440[];

//----- (10046E95) --------------------------------------------------------
int __cdecl sub_10046E95(signed int a1)
{
  int result; // eax@2

  if ( a1 == -2 )
  {
    *_errno() = 9;
    result = 0;
  }
  else if ( a1 >= 0 && a1 < uNumber )
  {
    result = *(_BYTE *)(dword_101F1440[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) & 0x40;
  }
  else
  {
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 0;
  }
  return result;
}
// 1003DBF5: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101F1440: using guessed type int dword_101F1440[];

//----- (10046EF3) --------------------------------------------------------
void **sub_10046EF3()
{
  return &off_100EFDD0;
}
// 100EFDD0: using guessed type void *off_100EFDD0;

//----- (10046EF9) --------------------------------------------------------
signed int sub_10046EF9()
{
  size_t v0; // eax@1
  void *v1; // eax@6
  signed int result; // eax@8
  int v3; // edx@9
  void **v4; // ecx@9
  signed int v5; // edx@12
  _DWORD *v6; // ecx@12
  int v7; // eax@13

  v0 = dword_101F1400;
  if ( !dword_101F1400 )
  {
    v0 = 512;
LABEL_5:
    dword_101F1400 = v0;
    goto LABEL_6;
  }
  if ( dword_101F1400 < 20 )
  {
    v0 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v1 = (void *)_calloc_crt(v0, 4);
  dword_101F03E4 = v1;
  if ( v1 || (dword_101F1400 = 20, v1 = (void *)_calloc_crt(0x14u, 4), (dword_101F03E4 = v1) != 0) )
  {
    v3 = 0;
    v4 = &off_100EFDD0;
    while ( 1 )
    {
      *(_DWORD *)((char *)v1 + v3) = v4;
      v4 += 8;
      v3 += 4;
      if ( (signed int)v4 >= (signed int)&off_100F0050 )
        break;
      v1 = dword_101F03E4;
    }
    v5 = 0;
    v6 = &unk_100EFDE0;
    do
    {
      v7 = *(_DWORD *)(((v5 & 0x1F) << 6) + dword_101F1440[v5 >> 5]);
      if ( v7 == -1 || v7 == -2 || !v7 )
        *v6 = -2;
      v6 += 8;
      ++v5;
    }
    while ( (signed int)v6 < (signed int)&unk_100EFE40 );
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 1003C1FB: using guessed type _DWORD __cdecl _calloc_crt(size_t, _DWORD);
// 100EFDD0: using guessed type void *off_100EFDD0;
// 100F0050: using guessed type wchar_t *off_100F0050;
// 101F1400: using guessed type int dword_101F1400;
// 101F1440: using guessed type int dword_101F1440[];

//----- (10047819) --------------------------------------------------------
signed int __cdecl sub_10047819(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_100F0168 - 1;
    v64 = v3;
    v65 = dword_100F0168 / 32;
    v9 = dword_100F0168 % 32;
    v10 = (int *)(&v60 + dword_100F0168 / 32);
    v66 = 31 - dword_100F0168 % 32;
    if ( (1 << (31 - dword_100F0168 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_100F0164 - dword_100F0168 )
    {
      if ( v3 > dword_100F0164 )
      {
        if ( v3 < dword_100F0160 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_100F0174 + v3;
          v50 = dword_100F016C / 32;
          v51 = dword_100F016C % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_100F016C % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_100F016C / 32;
          v44 = dword_100F016C % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_100F016C % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_100F0174 + dword_100F0160;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_100F0164 - v64) / 32;
      v62 = v59;
      v18 = (dword_100F0164 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_100F0168 - 1;
      v25 = dword_100F0168 / 32;
      v65 = dword_100F0168 / 32;
      v26 = (int *)(&v60 + dword_100F0168 / 32);
      v64 = 31 - dword_100F0168 % 32;
      if ( (1 << (31 - dword_100F0168 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_100F0168 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_100F016C + 1) / 32;
      v37 = (dword_100F016C + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_100F016C));
  if ( dword_100F0170 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_100F0170 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 100F0160: using guessed type int dword_100F0160;
// 100F0164: using guessed type int dword_100F0164;
// 100F0168: using guessed type int dword_100F0168;
// 100F016C: using guessed type int dword_100F016C;
// 100F0170: using guessed type int dword_100F0170;
// 100F0174: using guessed type int dword_100F0174;

//----- (10047D5B) --------------------------------------------------------
signed int __cdecl sub_10047D5B(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_100F0180 - 1;
    v64 = v3;
    v65 = dword_100F0180 / 32;
    v9 = dword_100F0180 % 32;
    v10 = (int *)(&v60 + dword_100F0180 / 32);
    v66 = 31 - dword_100F0180 % 32;
    if ( (1 << (31 - dword_100F0180 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_100F017C - dword_100F0180 )
    {
      if ( v3 > dword_100F017C )
      {
        if ( v3 < dword_100F0178 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_100F018C + v3;
          v50 = dword_100F0184 / 32;
          v51 = dword_100F0184 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_100F0184 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_100F0184 / 32;
          v44 = dword_100F0184 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_100F0184 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_100F018C + dword_100F0178;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_100F017C - v64) / 32;
      v62 = v59;
      v18 = (dword_100F017C - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_100F0180 - 1;
      v25 = dword_100F0180 / 32;
      v65 = dword_100F0180 / 32;
      v26 = (int *)(&v60 + dword_100F0180 / 32);
      v64 = 31 - dword_100F0180 % 32;
      if ( (1 << (31 - dword_100F0180 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_100F0180 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_100F0184 + 1) / 32;
      v37 = (dword_100F0184 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_100F0184));
  if ( dword_100F0188 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_100F0188 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 100F0178: using guessed type int dword_100F0178;
// 100F017C: using guessed type int dword_100F017C;
// 100F0180: using guessed type int dword_100F0180;
// 100F0184: using guessed type int dword_100F0184;
// 100F0188: using guessed type int dword_100F0188;
// 100F018C: using guessed type int dword_100F018C;

//----- (10048965) --------------------------------------------------------
int sub_10048965()
{
  return 0;
}

//----- (1004914A) --------------------------------------------------------
int __cdecl sub_1004914A(FILE *a1)
{
  int v1; // eax@3
  int v2; // eax@7
  int v3; // ST10_4@10
  char *v4; // ST0C_4@10
  int v5; // eax@10
  int v6; // eax@10
  int *v7; // edi@15
  _BYTE *v8; // eax@15
  int v9; // eax@20
  char *v10; // ecx@23
  int result; // eax@23

  if ( !a1 )
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v1 = a1->_flag;
  if ( !(v1 & 0x83) || v1 & 0x40 )
    return -1;
  if ( v1 & 2 )
  {
    a1->_flag = v1 | 0x20;
    return -1;
  }
  v2 = v1 | 1;
  a1->_flag = v2;
  if ( v2 & 0x10C )
    a1->_ptr = a1->_base;
  else
    _getbuf(a1);
  v3 = a1->_bufsiz;
  v4 = a1->_base;
  v5 = _fileno(a1);
  v6 = _read(v5, v4, v3);
  a1->_cnt = v6;
  if ( !v6 || v6 == -1 )
  {
    a1->_flag |= v6 != 0 ? 32 : 16;
    a1->_cnt = 0;
    return -1;
  }
  if ( !(a1->_flag & 0x82) )
  {
    if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
    {
      v8 = &unk_100EF2A8;
    }
    else
    {
      v7 = &dword_101F1440[_fileno(a1) >> 5];
      v8 = (_BYTE *)(*v7 + ((_fileno(a1) & 0x1F) << 6));
    }
    if ( (v8[4] & 0x82) == -126 )
      a1->_flag |= 0x2000u;
  }
  if ( a1->_bufsiz == 512 )
  {
    v9 = a1->_flag;
    if ( v9 & 8 )
    {
      if ( !(v9 & 0x400) )
        a1->_bufsiz = 4096;
    }
  }
  v10 = a1->_ptr;
  --a1->_cnt;
  result = (unsigned __int8)*v10;
  a1->_ptr = v10 + 1;
  return result;
}
// 1003DBF5: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10046E51: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 101F1440: using guessed type int dword_101F1440[];

//----- (1004926A) --------------------------------------------------------
int __cdecl sub_1004926A(int a1, FILE *a2)
{
  int *v2; // edi@4
  _BYTE *v3; // eax@4
  int *v4; // edi@9
  _BYTE *v5; // eax@9
  int v7; // eax@16
  char *v8; // eax@24
  int v9; // eax@28

  if ( !(a2->_flag & 0x40) )
  {
    if ( _fileno(a2) == -1 || _fileno(a2) == -2 )
    {
      v3 = &unk_100EF2A8;
    }
    else
    {
      v2 = &dword_101F1440[_fileno(a2) >> 5];
      v3 = (_BYTE *)(*v2 + ((_fileno(a2) & 0x1F) << 6));
    }
    if ( v3[36] & 0x7F
      || (_fileno(a2) == -1 || _fileno(a2) == -2 ? (v5 = &unk_100EF2A8) : (v4 = &dword_101F1440[_fileno(a2) >> 5],
                                                                           v5 = (_BYTE *)(*v4
                                                                                        + ((_fileno(a2) & 0x1F) << 6))),
          v5[36] & 0x80) )
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
  }
  if ( a1 == -1 )
    return -1;
  v7 = a2->_flag;
  if ( !(v7 & 1) && ((char)v7 >= 0 || v7 & 2) )
    return -1;
  if ( !a2->_base )
    _getbuf(a2);
  if ( a2->_ptr == a2->_base )
  {
    if ( a2->_cnt )
      return -1;
    ++a2->_ptr;
  }
  v8 = --a2->_ptr;
  if ( a2->_flag & 0x40 )
  {
    if ( *v8 != (_BYTE)a1 )
    {
      a2->_ptr = v8 + 1;
      return -1;
    }
  }
  else
  {
    *v8 = a1;
  }
  v9 = a2->_flag;
  ++a2->_cnt;
  a2->_flag = v9 & 0xFFFFFFEF | 1;
  return (unsigned __int8)a1;
}
// 1003DBF5: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10046E51: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 101F1440: using guessed type int dword_101F1440[];

//----- (1004A1A9) --------------------------------------------------------
int __cdecl sub_1004A1A9(int a1, int a2, int a3)
{
  HMODULE v3; // eax@2
  HMODULE v4; // edi@2
  FARPROC v5; // eax@3
  FARPROC v6; // eax@4
  FARPROC v7; // eax@4
  FARPROC v8; // eax@7
  FARPROC v9; // eax@8
  int (*v10)(void); // esi@11
  int (__stdcall *v11)(int, signed int, char *, signed int, char *); // eax@11
  int (__stdcall *v12)(int, signed int, char *, signed int, char *); // edi@11
  int v13; // eax@13
  int (*v14)(void); // eax@22
  int (__stdcall *v15)(int); // eax@25
  int (__stdcall *v16)(int, int, int, int); // eax@27
  char v18; // [sp+10h] [bp-20h]@14
  char v19; // [sp+18h] [bp-18h]@15
  char v20; // [sp+1Ch] [bp-14h]@14
  unsigned int v21; // [sp+20h] [bp-10h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+28h] [bp-8h]@1
  int v24; // [sp+2Ch] [bp-4h]@1

  v23 = _encoded_null();
  v24 = 0;
  v22 = 0;
  v21 = 0;
  if ( !dword_101AF9B4 )
  {
    v3 = LoadLibraryA("USER32.DLL");
    v4 = v3;
    if ( !v3 )
      return 0;
    v5 = GetProcAddress(v3, "MessageBoxA");
    if ( !v5 )
      return 0;
    dword_101AF9B4 = _encode_pointer(v5);
    v6 = GetProcAddress(v4, "GetActiveWindow");
    dword_101AF9B8 = _encode_pointer(v6);
    v7 = GetProcAddress(v4, "GetLastActivePopup");
    dword_101AF9BC = _encode_pointer(v7);
    if ( sub_1003B8B5(&v22) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v22 == 2 )
    {
      v8 = GetProcAddress(v4, "GetUserObjectInformationA");
      dword_101AF9C4 = _encode_pointer(v8);
      if ( dword_101AF9C4 )
      {
        v9 = GetProcAddress(v4, "GetProcessWindowStation");
        dword_101AF9C0 = _encode_pointer(v9);
      }
    }
  }
  if ( dword_101AF9C0 == v23
    || dword_101AF9C4 == v23
    || (v10 = (int (*)(void))_decode_pointer(dword_101AF9C0),
        v11 = (int (__stdcall *)(int, signed int, char *, signed int, char *))_decode_pointer(dword_101AF9C4),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, &v18, 12, &v20) && v19 & 1 )
  {
    if ( dword_101AF9B8 != v23 )
    {
      v14 = (int (*)(void))_decode_pointer(dword_101AF9B8);
      if ( v14 )
      {
        v24 = v14();
        if ( v24 )
        {
          if ( dword_101AF9BC != v23 )
          {
            v15 = (int (__stdcall *)(int))_decode_pointer(dword_101AF9BC);
            if ( v15 )
              v24 = v15(v24);
          }
        }
      }
    }
  }
  else
  {
    if ( sub_1003B8EC(&v21) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v21 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_101AF9B4);
  if ( v16 )
    return v16(v24, a1, a2, a3);
  return 0;
}
// 1003BB74: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 1003BBE2: using guessed type int _encoded_null(void);
// 1003BBEB: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1003DAF9: using guessed type int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101AF9B4: using guessed type int dword_101AF9B4;
// 101AF9B8: using guessed type int dword_101AF9B8;
// 101AF9BC: using guessed type int dword_101AF9BC;
// 101AF9C0: using guessed type int dword_101AF9C0;
// 101AF9C4: using guessed type int dword_101AF9C4;

//----- (1004A67B) --------------------------------------------------------
signed int __cdecl sub_1004A67B(signed int a1)
{
  int *v1; // edi@3
  int v2; // esi@3
  int v3; // eax@3
  DWORD v5; // [sp-8h] [bp-14h]@9

  if ( a1 >= 0 && a1 < uNumber )
  {
    v1 = &dword_101F1440[a1 >> 5];
    v2 = (a1 & 0x1F) << 6;
    v3 = v2 + *v1;
    if ( *(_BYTE *)(v3 + 4) & 1 )
    {
      if ( *(_DWORD *)v3 != -1 )
      {
        if ( dword_101AF01C == 1 )
        {
          if ( !a1 )
          {
            v5 = -10;
            goto LABEL_12;
          }
          if ( a1 == 1 )
          {
            v5 = -11;
            goto LABEL_12;
          }
          if ( a1 == 2 )
          {
            v5 = -12;
LABEL_12:
            SetStdHandle(v5, 0);
            goto LABEL_13;
          }
        }
LABEL_13:
        *(_DWORD *)(v2 + *v1) = -1;
        return 0;
      }
    }
  }
  *_errno() = 9;
  *__doserrno() = 0;
  return -1;
}
// 101AF01C: using guessed type int dword_101AF01C;
// 101F1440: using guessed type int dword_101F1440[];

//----- (1004A6FC) --------------------------------------------------------
signed int __cdecl sub_1004A6FC(signed int a1)
{
  signed int result; // eax@2
  int v2; // eax@5

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    result = -1;
  }
  else if ( a1 >= 0 && a1 < uNumber && (v2 = dword_101F1440[a1 >> 5] + ((a1 & 0x1F) << 6), *(_BYTE *)(v2 + 4) & 1) )
  {
    result = *(_DWORD *)v2;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  return result;
}
// 1003DBF5: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101F1440: using guessed type int dword_101F1440[];

//----- (1004A80D) --------------------------------------------------------
void __cdecl sub_1004A80D(signed int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(dword_101F1440[a1 >> 5] + ((a1 & 0x1F) << 6) + 12));
}
// 101F1440: using guessed type int dword_101F1440[];

//----- (1004AB0E) --------------------------------------------------------
int sub_1004AB0E()
{
  return flsall(1);
}
// 1004AA34: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (1004B451) --------------------------------------------------------
signed int __cdecl sub_1004B451(signed int a1)
{
  signed int v1; // edi@6
  void *v2; // eax@7
  DWORD v3; // edi@8
  signed int result; // eax@11

  if ( sub_1004A6FC(a1) == -1
    || (a1 == 1 && *(_BYTE *)(dword_101F1440[0] + 132) & 1 || a1 == 2 && *(_BYTE *)(dword_101F1440[0] + 68) & 1)
    && (v1 = sub_1004A6FC(2), sub_1004A6FC(1) == v1)
    || (v2 = (void *)sub_1004A6FC(a1), CloseHandle(v2)) )
  {
    v3 = 0;
  }
  else
  {
    v3 = GetLastError();
  }
  sub_1004A67B(a1);
  *(_BYTE *)(dword_101F1440[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) = 0;
  if ( v3 )
  {
    _dosmaperr(v3);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1003A801: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 101F1440: using guessed type int dword_101F1440[];

//----- (1004B5F0) --------------------------------------------------------
unsigned int __cdecl sub_1004B5F0(unsigned int a1)
{
  unsigned int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = a1 & 0xFFFFFFFC;
  else
    result = 0;
  return result;
}

//----- (1004B610) --------------------------------------------------------
bool __cdecl sub_1004B610(int a1)
{
  bool result; // al@1
  unsigned int v2; // eax@4
  _DWORD *v3; // edx@4
  _DWORD *v4; // esi@4
  int v5; // ecx@8
  int v6; // eax@9
  _BYTE *v7; // edx@9
  _BYTE *v8; // esi@9
  int v9; // eax@11
  _BYTE *v10; // edx@11
  _BYTE *v11; // esi@11
  _BYTE *v12; // edx@13
  _BYTE *v13; // esi@13
  int v14; // edx@14
  signed int v15; // eax@15

  result = *(_DWORD *)(a1 + 88) == ~*(_DWORD *)(a1 + 36);
  if ( *(_WORD *)(a1 + 30) != 99 || !result && *(_WORD *)(a1 + 684) != 2 )
    return result;
  v2 = 10;
  v3 = (_DWORD *)(a1 + 693);
  v4 = (_DWORD *)(a1 + 721);
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_8;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_17:
    v15 = 0;
    return v15 == 0;
  }
LABEL_8:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_17;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_17;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_17;
        v14 = *v12;
        v5 = *v13 - v14;
        if ( *v13 == v14 )
          goto LABEL_17;
      }
    }
  }
  v15 = 1;
  if ( v5 <= 0 )
    return 0;
  return v15 == 0;
}

//----- (1004B6E0) --------------------------------------------------------
int __cdecl sub_1004B6E0(int a1)
{
  return *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 32) + *(_WORD *)(a1 + 28) + 46;
}

//----- (1004B700) --------------------------------------------------------
int __cdecl sub_1004B700(int a1, int a2)
{
  int result; // eax@2

  if ( a2 )
    result = *(_WORD *)(a2 + 28) + *(_WORD *)(a2 + 26) + 30;
  else
    result = -16 - *(_WORD *)(a1 + 52) + sub_1004B6E0(a1 + 20);
  return result;
}

//----- (1004B740) --------------------------------------------------------
signed int __cdecl sub_1004B740(int a1, void *a2, unsigned __int16 a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // ebp@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 732);
  v6 = 0;
  result = -15;
  v8 = *(_WORD *)(a1 + 48) + *(_DWORD *)(a1 + 16) + 46;
  if ( *(_WORD *)(a1 + 50) >= 4u )
  {
    while ( (unsigned int)(v6 + v8) < *(_DWORD *)(v5 + 120) )
    {
      if ( sub_100321A0(*(_DWORD *)(v5 + 4), &a1, 4, v6 + v8, 0) != 4 )
        return -15;
      if ( (_WORD)a1 == a4 && (unsigned int)HIWORD(a1) + 4 <= a3 )
        return sub_100321A0(*(_DWORD *)(v5 + 4), a2, HIWORD(a1) + 4, v6 + v8, 0);
      v6 += HIWORD(a1) + 4;
      result = -15;
      if ( v6 + 4 > (unsigned int)*(_WORD *)(v4 + 50) )
        return result;
    }
  }
  return result;
}

//----- (1004B800) --------------------------------------------------------
int __cdecl sub_1004B800(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (1004B840) --------------------------------------------------------
int __usercall sub_1004B840@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // eax@2
  int result; // eax@2
  int v4; // eax@3
  __int16 v5; // cx@3
  int v6; // edx@3

  sub_10050330(a2 + 721, a1 + 64);
  if ( *(_DWORD *)(a2 + 44) )
  {
    v4 = *(_DWORD *)(a2 + 725);
    v5 = *(_WORD *)(a2 + 729);
    *(_DWORD *)(a2 + 693) = *(_DWORD *)(a2 + 721);
    v6 = *(_DWORD *)(a2 + 732);
    *(_DWORD *)(a2 + 697) = v4;
    *(_WORD *)(a2 + 701) = v5;
    result = j_FIL_vfs_write(*(_DWORD *)(v6 + 116), a2 + 721, 10);
    *(_DWORD *)(a2 + 136) += 10;
    *(_DWORD *)(a2 + 40) += 10;
  }
  else
  {
    v2 = sub_10032280(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116));
    result = sub_100322A0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), v2 - *(_WORD *)(a2 + 50) - *(_DWORD *)(a2 + 40), 0);
    *(_DWORD *)(a2 + 84) -= *(_WORD *)(a2 + 50);
    *(_DWORD *)(a2 + 136) = 0;
    *(_WORD *)(a2 + 28) &= 0xFFFEu;
    *(_DWORD *)(a2 + 40) = 0;
    *(_WORD *)(a2 + 50) = 0;
    *(_WORD *)(a2 + 30) = 0;
    *(_WORD *)(a2 + 80) = 0;
  }
  return result;
}
// 100322C0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (1004B8F0) --------------------------------------------------------
signed int __usercall sub_1004B8F0@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  char v3; // ST30_1@2
  int v4; // ST28_4@2
  int v5; // eax@2
  __int64 v6; // rax@2
  int v7; // ebx@2
  char *v8; // ebp@2
  __int64 v9; // rax@3
  signed int result; // eax@4
  _WORD *v11; // edi@5
  _WORD *v12; // [sp+Ch] [bp-4h]@4

  v2 = a1;
  if ( *(_BYTE *)(a2 + 8) )
  {
    *(_WORD *)(a1 + 532) = -26367;
    *(_WORD *)(a1 + 534) = 7;
    *(_WORD *)(a1 + 536) = 1;
    *(_BYTE *)(a1 + 538) = 65;
    *(_BYTE *)(a1 + 539) = 69;
    v3 = *(_DWORD *)(a2 + 84);
    *(_DWORD *)(a2 + 76) = a1 + 532;
    v4 = a1 + 532;
    v5 = *(_DWORD *)(a2 + 732);
    *(_WORD *)(a2 + 50) = 11;
    *(_WORD *)(a2 + 80) = 11;
    sub_100322D0(*(_DWORD *)(v5 + 116), v4, 11, v3);
    *(_DWORD *)(a2 + 84) += *(_WORD *)(a2 + 80);
    *(_BYTE *)(v2 + 540) = *(_BYTE *)(*(_DWORD *)(a2 + 732) + 112);
    v6 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v6) & 7) + (signed int)v6) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_10050780((void *)(v2 + 555), v7);
  }
  else
  {
    sub_1004B740(a2, (void *)(a1 + 532), 0xBu, -26367);
    v9 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v9) & 7) + (signed int)v9) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_100321A0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 555), v7, *(_DWORD *)(a2 + 84), 0);
    sub_100321A0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 571), 2, v7 + *(_DWORD *)(a2 + 84), 0);
  }
  v12 = (_WORD *)(v2 + 543);
  result = sub_10050650(*(_BYTE *)(v2 + 540), (void *)v2, strlen((const char *)v2), v8, (_WORD *)(v2 + 543), v2 + 64);
  if ( *(_BYTE *)(a2 + 8) )
  {
    sub_100322D0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v8, v7, *(_DWORD *)(a2 + 84));
    v11 = (_WORD *)(v2 + 571);
    *v11 = *v12;
    sub_100322D0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v11, 2, v7 + *(_DWORD *)(a2 + 84));
    result = v7 + 2;
    *(_DWORD *)(a2 + 136) += v7 + 2;
    *(_DWORD *)(a2 + 40) += v7 + 2;
  }
  else
  {
    *(_DWORD *)(a2 + 92) += -12 - v7;
    *(_DWORD *)(a2 + 124) += v7 + 2;
  }
  return result;
}

//----- (1004BAC0) --------------------------------------------------------
char __usercall sub_1004BAC0@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  return sub_100502E0(a2, a3, a1 + 212);
}

//----- (1004BAD0) --------------------------------------------------------
int __usercall sub_1004BAD0@<eax>(int result@<eax>)
{
  if ( *(_WORD *)(result + 30) == 99 )
    result = sub_1004B840(result + 148, result);
  return result;
}

//----- (1004BAF0) --------------------------------------------------------
char __usercall sub_1004BAF0@<al>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = (*(_DWORD *)(a1 + 72) & 0xFFFD | 2) * ((*(_DWORD *)(a1 + 72) & 0xFFFD | 2) ^ 1);
  return BYTE1(v1);
}

//----- (1004BB10) --------------------------------------------------------
int __usercall sub_1004BB10@<eax>(int a1@<esi>, unsigned __int8 a2)
{
  int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@1
  int result; // eax@1

  v2 = sub_10037B90(a2, *(_DWORD *)(a1 + 64));
  v3 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 64) = v2;
  v4 = 134775813 * (*(_DWORD *)(a1 + 68) + (unsigned __int8)v2) + 1;
  *(_DWORD *)(a1 + 68) = v4;
  result = sub_10037B90(BYTE3(v4), v3);
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

//----- (1004BB50) --------------------------------------------------------
int __fastcall sub_1004BB50(int a1, int a2)
{
  int result; // eax@1

  result = *(_WORD *)(a2 + 30);
  if ( *(_WORD *)(a2 + 30) == 99 )
    result = *(_WORD *)(a2 + 689);
  return result;
}

//----- (1004BB70) --------------------------------------------------------
int __usercall sub_1004BB70@<eax>(int a1@<esi>)
{
  int v1; // ST1C_4@1
  unsigned int v2; // ST18_4@1
  int v3; // eax@1
  int v4; // ST00_4@1

  v1 = *(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 24);
  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = v1;
  sub_10032320(v2, v1, 0);
  j_FIL_vfs_write(*(_DWORD *)(a1 + 4), a1 + 8, 22);
  v3 = *(_DWORD *)a1 + 22;
  v4 = *(_DWORD *)(a1 + 116);
  *(_DWORD *)(a1 + 120) = v3;
  return sub_100322A0(v4, v3, 0);
}
// 100322C0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (1004BBB0) --------------------------------------------------------
signed int __usercall sub_1004BBB0@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6)
{
  __int16 v6; // ax@1
  unsigned int *v7; // ecx@1
  int v8; // esi@1
  signed int v9; // eax@1
  unsigned int v10; // eax@1
  int v11; // ebx@1
  int v12; // ebx@1
  int v13; // eax@4
  int v14; // ecx@6
  int v15; // ebp@8
  unsigned int v16; // ebx@11
  __int64 v17; // rax@14
  unsigned int v18; // ecx@15
  unsigned int v19; // ebp@15
  int v21; // ebx@20
  signed int v22; // eax@23
  size_t v23; // ebp@29
  int v24; // ebx@33
  int v25; // [sp+Ch] [bp-8h]@1
  __int16 v26; // [sp+10h] [bp-4h]@1

  v6 = sub_1004BB50(a1, a3);
  v7 = *(unsigned int **)(a2 + 16);
  v8 = a2 + 28;
  v26 = v6;
  *(_DWORD *)v8 = v7;
  v9 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v8 + 4) = v9;
  v25 = 0;
  v10 = sub_10037BB0(v7, v9, *(_DWORD *)a2);
  v11 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)a2 = v10;
  v12 = v11 + 0xFFFFF;
  while ( 1 )
  {
    if ( !*(_DWORD *)(a2 + 32) )
    {
      if ( !a6 )
        goto LABEL_37;
      v13 = *(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(a2 + 44) == v13 && v12 != v13 + 0xFFFFF )
        break;
    }
    v14 = *(_DWORD *)(a2 + 12);
    if ( !v14 )
      break;
    if ( !--v12 )
      break;
    v15 = *(_DWORD *)(a2 + 44);
    if ( !v15 || a6 && v15 != v14 )
    {
      v16 = *(_DWORD *)(a2 + 48);
      if ( v16
        && (v16 >= 0x28
         || *(_WORD *)(a3 + 30) != 99
         || (v17 = ((*(_BYTE *)(a3 + 688) & 3) + 1) << 6, v16 != (((BYTE4(v17) & 7) + (signed int)v17) >> 3) / 2 + 2)) )
      {
        v18 = v14 - v15;
        v19 = v18;
        if ( *(_BYTE *)(a3 + 28) & 1 )
          sub_1004BAC0(a3, *(char **)(a2 + 8), v18);
        if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v19) != v19 )
          return -16;
      }
      else
      {
        v19 = 0;
      }
      v21 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
      v12 = v21 + 0xFFFFF;
      v25 += v19;
      *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    }
    if ( v26 == 8 )
    {
      if ( a6 )
        v22 = sub_10052530(a2 + 28, 4);
      else
        v22 = sub_10052530(a2 + 28, 0);
      if ( v22 && v22 != 1 )
        return -15;
    }
    else
    {
      if ( v26 )
        return -15;
      v23 = *(_DWORD *)(a2 + 44);
      if ( *(_DWORD *)(a2 + 32) < v23 )
        v23 = *(_DWORD *)(a2 + 32);
      memcpy_0(*(void **)(a2 + 40), *(const void **)v8, v23);
      *(_DWORD *)(a2 + 32) -= v23;
      *(_DWORD *)(a2 + 44) -= v23;
      *(_DWORD *)v8 += v23;
      *(_DWORD *)(a2 + 40) += v23;
      *(_DWORD *)(a2 + 36) += v23;
      *(_DWORD *)(a2 + 48) += v23;
    }
  }
  if ( a6 )
  {
    v24 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44);
    if ( *(_BYTE *)(a3 + 28) & 1 )
      sub_1004BAC0(a3, *(char **)(a2 + 8), *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44));
    if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v24) != v24 )
      return -16;
    v25 += v24;
    *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
  }
LABEL_37:
  *(_DWORD *)(a5 + 24) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a5 + 20) = *(_DWORD *)(a2 + 48);
  return v25;
}
// 100322C0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (1004BDC0) --------------------------------------------------------
int __cdecl sub_1004BDC0(int a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  unsigned int v3; // ebp@1
  bool v4; // zf@1
  int v5; // ecx@1
  __int16 v6; // cx@4
  __int16 v7; // ax@4
  __int16 v8; // dx@4
  __int16 v9; // cx@4
  unsigned int v10; // edx@4
  int v11; // eax@4
  unsigned int v12; // ecx@4
  int v13; // eax@4
  int result; // eax@5
  int v15; // eax@6
  unsigned __int16 v16; // ax@7
  int v17; // eax@11
  int v18; // edx@13
  int v19; // edi@13
  int v20; // eax@13
  unsigned __int16 v21; // cx@14
  int v22; // [sp+10h] [bp-28h]@4
  char v23; // [sp+14h] [bp-24h]@3
  int v24; // [sp+18h] [bp-20h]@1
  int v25; // [sp+1Ch] [bp-1Ch]@1
  int v26; // [sp+20h] [bp-18h]@1
  int v27; // [sp+24h] [bp-14h]@1
  __int64 v28; // [sp+28h] [bp-10h]@1
  int v29; // [sp+30h] [bp-8h]@1
  __int16 v30; // [sp+34h] [bp-4h]@1
  int v31; // [sp+3Ch] [bp+4h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 732);
  v31 = *(_DWORD *)(v2 + 116);
  sub_1004BAD0(v1);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_WORD *)(v1 + 32) == 0;
  v5 = ~*(_DWORD *)(v1 + 88);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0i64;
  v29 = 0;
  v30 = 0;
  *(_DWORD *)(v1 + 36) = v5;
  if ( v4 || !*(_WORD *)(v1 + 34) )
  {
    sub_10018930(&v23);
    sub_100255E0((unsigned int *)&v23, (_WORD *)(v1 + 34), (_WORD *)(v1 + 32));
  }
  v6 = *(_WORD *)(v1 + 24);
  v7 = *(_WORD *)(v1 + 30);
  HIWORD(v25) = *(_WORD *)(v1 + 28);
  v8 = *(_WORD *)(v1 + 34);
  LOWORD(v25) = v6;
  v9 = *(_WORD *)(v1 + 32);
  LOWORD(v27) = v8;
  v10 = *(_DWORD *)(v1 + 44);
  LOWORD(v26) = v7;
  v11 = *(_DWORD *)(v1 + 36);
  HIWORD(v26) = v9;
  v12 = *(_DWORD *)(v1 + 40);
  *(int *)((char *)&v27 + 2) = v11;
  LOWORD(v11) = *(_WORD *)(v1 + 48);
  *(__int64 *)((char *)&v28 + 2) = __PAIR__(v10, v12);
  LOWORD(v12) = *(_WORD *)(v1 + 50);
  v24 = 67324752;
  HIWORD(v29) = v11;
  v30 = v12;
  v22 = sub_1004B700(v1, (int)&v24);
  v13 = sub_10032280(v31);
  if ( v3 == v31 )
  {
    result = sub_100320F0(v31, v13, v31, *(_DWORD *)(v2 + 24), *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v15 = *(_DWORD *)(v2 + 24);
    *(_DWORD *)(v1 + 62) = v15;
    *(_DWORD *)(v1 + 84) = v22 + v15;
  }
  sub_10032320(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 62), 0);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), &v24, 30);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72));
  v16 = *(_WORD *)(v1 + 80);
  if ( v16 )
    j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 76), v16);
  if ( v3 == v31 )
  {
    result = sub_100320F0(
               v31,
               *(_DWORD *)(v1 + 84),
               v31,
               v22 + *(_DWORD *)(v2 + 120),
               *(_DWORD *)(v1 + 40) + *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v17 = *(_DWORD *)((char *)&v28 + 2) + v22 + *(_DWORD *)(v2 + 24);
  }
  else
  {
    v17 = 0;
  }
  v18 = v17 + *(_DWORD *)(v2 + 20);
  ++*(_WORD *)(v2 + 16);
  ++*(_WORD *)(v2 + 18);
  *(_DWORD *)(v2 + 8) = 101010256;
  *(_DWORD *)(v2 + 24) = v17;
  *(_WORD *)(v2 + 28) = 0;
  sub_10032320(v3, v18, 0);
  *(_DWORD *)(v2 + 20) += sub_1004B6E0(v1 + 20);
  j_FIL_vfs_write(v3, v1 + 20, 46);
  v19 = j_FIL_vfs_write(v3, *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72)) != *(_WORD *)(v1 + 72) ? 0xFFFFFFF1 : 0;
  v20 = *(_DWORD *)(v1 + 76);
  if ( v20 )
  {
    v21 = *(_WORD *)(v1 + 80);
    if ( v21 )
    {
      v19 |= j_FIL_vfs_write(v3, v20, v21);
      if ( v19 >= 0 )
        v19 = 0;
    }
  }
  *(_DWORD *)v2 = *(_DWORD *)(v2 + 20) + *(_DWORD *)(v2 + 24);
  if ( v3 == v31 )
    sub_1004BB70(v2);
  else
    *(_DWORD *)(v2 + 120) = sub_10032280(v31);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(v2 + 24);
  *(_DWORD *)(v2 + 32) = 0;
  return v19;
}
// 100322C0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (1004C030) --------------------------------------------------------
signed int __cdecl sub_1004C030(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ecx@7
  int v5; // eax@10

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    if ( *(_DWORD *)(a1 + 112) == *(_DWORD *)(a1 + 44) && !*(_DWORD *)(a1 + 124) )
      sub_10032320(*(_DWORD *)(*(_DWORD *)(a1 + 732) + 116), *(_DWORD *)(a1 + 136) + *(_DWORD *)(a1 + 84), 0);
    v4 = *(_DWORD *)(a1 + 112) - a3;
    *(_DWORD *)(a1 + 104) = a2;
    *(_DWORD *)(a1 + 108) = a3;
    v5 = !v4 && *(_DWORD *)(a1 + 136) || !a2;
    result = sub_1004BBB0(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 88,
               a1,
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 20,
               v5);
    if ( result >= 0 )
    {
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 136);
      *(_DWORD *)(a1 + 112) -= a3;
    }
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (1004C0D0) --------------------------------------------------------
int __usercall sub_1004C0D0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // al@1
  unsigned __int8 *v3; // edx@1

  v1 = a1;
  v2 = sub_1004BAF0(a1);
  *v3 ^= v2;
  return sub_1004BB10(v1, *v3);
}

//----- (1004C0F0) --------------------------------------------------------
int __usercall sub_1004C0F0@<eax>(int a1@<edi>, int a2)
{
  int i; // esi@1
  int result; // eax@2

  for ( i = 0; i < a1; ++i )
    result = sub_1004C0D0(a2);
  return result;
}

//----- (1004C120) --------------------------------------------------------
signed int __usercall sub_1004C120@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // esi@1
  signed int v3; // edi@1
  signed int result; // eax@4

  v2 = a1;
  *(_DWORD *)(a1 + 64) = 305419896;
  *(_DWORD *)(a1 + 68) = 591751049;
  *(_DWORD *)(a1 + 72) = 878082192;
  v3 = 0;
  do
  {
    if ( !*(_BYTE *)(v3 + v2) )
      break;
    sub_1004BB10(v2, *(_BYTE *)(v3++ + v2));
  }
  while ( v3 < 64 );
  result = sub_100321A0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 76), 12, *(_DWORD *)(a2 + 84), 0);
  *(_DWORD *)(a2 + 92) -= 12;
  *(_DWORD *)(a2 + 124) += 12;
  return result;
}

//----- (1004C210) --------------------------------------------------------
char __usercall sub_1004C210@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>)
{
  char result; // al@2

  if ( *(_WORD *)(a3 + 30) == 99 )
    result = sub_10050290(a1, a2, a3 + 212);
  else
    result = sub_1004C0F0(a2, a3 + 148);
  return result;
}

//----- (1004C240) --------------------------------------------------------
signed int __usercall sub_1004C240@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@1
  int v3; // eax@1
  signed int result; // eax@2

  v1 = a1;
  v2 = *(_WORD *)(a1 + 30) == 99;
  v3 = a1 + 148;
  if ( v2 )
    result = sub_1004B8F0(v3, v1);
  else
    result = sub_1004C120(v3, v1);
  return result;
}

//----- (1004C270) --------------------------------------------------------
signed int __cdecl sub_1004C270(unsigned int a1)
{
  signed int result; // eax@3
  int v2; // eax@4
  int v3; // ecx@4
  int v4; // edx@4

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    sub_1004B800(a1 + 116);
    v2 = *(_DWORD *)(a1 + 40);
    v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 88) = -1;
    *(_DWORD *)(a1 + 92) = v2;
    *(_DWORD *)(a1 + 112) = v3;
    sub_10053FA0(v4);
    if ( *(_BYTE *)(a1 + 28) & 1 )
      sub_1004C240(a1);
    result = 0;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (1004C2C0) --------------------------------------------------------
signed int __cdecl sub_1004C2C0(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned int v5; // ecx@1
  signed int v6; // eax@4
  size_t v8; // eax@9
  size_t v9; // ebx@10
  int v10; // esi@13
  int v11; // edx@18
  __int16 v12; // ax@20
  size_t v13; // esi@21
  int v14; // ST30_4@25
  unsigned int *v15; // ST34_4@25
  int v16; // ebx@25
  int v17; // [sp+10h] [bp-Ch]@1
  int v18; // [sp+24h] [bp+8h]@7

  v2 = a2;
  v3 = a2 + 28;
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 20);
  v5 = *(_DWORD *)(a2 + 24);
  v17 = 0;
  if ( v4 <= v5 )
    *(_DWORD *)(a2 + 44) = v4;
  else
    *(_DWORD *)(a2 + 44) = v5;
  v6 = 0xFFFFF;
  if ( *(_DWORD *)(a2 + 44) )
  {
    while ( 1 )
    {
      v18 = v6 - 1;
      if ( v6 - 1 <= 0 )
        break;
      if ( *(_DWORD *)(v3 + 4) || (v8 = *(_DWORD *)(v2 + 4)) == 0 )
      {
        v10 = a1;
      }
      else
      {
        v9 = *(_DWORD *)(v2 + 12);
        if ( v8 < v9 )
          v9 = *(_DWORD *)(v2 + 4);
        if ( !v9 )
          return v17;
        v10 = a1;
        if ( sub_100321A0(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               *(void **)(v2 + 8),
               v9,
               *(_DWORD *)(a1 + 84) + *(_DWORD *)(v3 + 8),
               0) != v9 )
          return -15;
        if ( *(_BYTE *)(a1 + 28) & 1 )
        {
          sub_1004C210(*(char **)(v2 + 8), v9, a1);
          if ( *(_DWORD *)(v2 + 4) == v9 && *(_WORD *)(a1 + 30) == 99 )
          {
            sub_100321A0(
              *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
              (void *)(a1 + 721),
              10,
              *(_DWORD *)(a1 + 84) + v9 + *(_DWORD *)(v3 + 4) + *(_DWORD *)(v3 + 8),
              0);
            sub_10050330(a1 + 693, a1 + 212);
            v10 = a1;
          }
        }
        v11 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 4) -= v9;
        v18 = 0xFFFFF;
        *(_DWORD *)v3 = v11;
        *(_DWORD *)(v3 + 4) = v9;
      }
      v12 = sub_1004BB50(v5, v10);
      if ( v12 )
      {
        if ( v12 != 8 )
          return -15;
        v14 = *(_DWORD *)(v3 + 20);
        v15 = *(unsigned int **)(v3 + 12);
        v16 = (char)sub_10055360(v3, 2);
        v17 += *(_DWORD *)(v3 + 20) - v14;
        *(_DWORD *)v2 = sub_10037BB0(v15, *(_DWORD *)(v3 + 20) - v14, *(_DWORD *)v2);
        if ( v16 == 1 )
          return v17;
        if ( v16 < 0 )
          return -14;
      }
      else
      {
        v13 = *(_DWORD *)(v3 + 4);
        if ( *(_DWORD *)(v3 + 16) < v13 )
          v13 = *(_DWORD *)(v3 + 16);
        memcpy_0(*(void **)(v3 + 12), *(const void **)v3, v13);
        *(_DWORD *)v2 = sub_10037BB0(*(unsigned int **)(v3 + 12), v13, *(_DWORD *)v2);
        *(_DWORD *)(v3 + 4) -= v13;
        *(_DWORD *)(v3 + 16) -= v13;
        *(_DWORD *)(v3 + 12) += v13;
        *(_DWORD *)v3 += v13;
        *(_DWORD *)(v3 + 20) += v13;
        *(_DWORD *)(v3 + 8) += v13;
        v17 += v13;
      }
      if ( !*(_DWORD *)(v3 + 16) )
        return v17;
      v6 = v18;
    }
  }
  return v17;
}

//----- (1004C4B0) --------------------------------------------------------
signed int __cdecl sub_1004C4B0(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ST04_4@4
  signed int v5; // eax@4
  signed int v6; // ebx@4
  bool v7; // zf@5

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    v4 = a1 + 88;
    *(_DWORD *)(v4 + 16) = a2;
    *(_DWORD *)(v4 + 20) = a3;
    v5 = sub_1004C2C0(a1, a1 + 88);
    v6 = v5;
    if ( v5 > 0 )
    {
      v7 = *(_DWORD *)(a1 + 112) == v5;
      *(_DWORD *)(a1 + 112) -= v5;
      if ( v7 && !(*(_BYTE *)a1 & 1) && !sub_1004B610(a1) )
        v6 = -14;
    }
    result = v6;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (1004C510) --------------------------------------------------------
signed int __cdecl sub_1004C510(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  unsigned int v4; // edx@4
  int v5; // ebx@4
  int v6; // esi@16
  int v7; // eax@17
  char v8; // [sp+4h] [bp-204h]@19

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return -6;
  v4 = *(_DWORD *)(a1 + 44);
  result = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 112);
  v5 = a2;
  if ( a3 == 1 )
  {
    v5 = result + a2;
  }
  else if ( a3 == 2 )
  {
    v5 = v4 + a2;
  }
  if ( v5 > v4 || v5 < 0 )
    return -15;
  if ( result == v5 )
    return result;
  if ( !v5 )
  {
    sub_1004C270(a1);
    return 0;
  }
  if ( !*(_WORD *)(a1 + 30) && *(_BYTE *)a1 & 3 )
  {
    sub_1004B800(a1 + 116);
    *(_DWORD *)(a1 + 124) = v5;
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 44) - v5;
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 40) - v5;
    return v5;
  }
  if ( result > v5 )
  {
    sub_1004C270(a1);
    result = 0;
  }
  v6 = v5 - result;
  if ( v5 - result <= 0 )
    return v5;
  while ( 1 )
  {
    v7 = 512;
    if ( (unsigned int)v6 < 0x200 )
      v7 = v6;
    result = sub_1004C4B0(a1, (int)&v8, v7);
    if ( result <= 0 )
      break;
    v6 -= result;
    if ( v6 <= 0 )
      return v5;
  }
  return result;
}

//----- (1004C6E0) --------------------------------------------------------
signed int __cdecl sub_1004C6E0(unsigned int a1, int a2, int a3, int a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  signed int result; // eax@3

  v4 = sub_1004B5F0(a1);
  v5 = v4;
  if ( v4 < 0xFFFFFFC2 && v4 )
  {
    if ( sub_1004C510(v4, a4, 0) == a4 )
      result = sub_1004C4B0(v5, a2, a3);
    else
      result = -15;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (1004C740) --------------------------------------------------------
signed int __cdecl sub_1004C740(unsigned int a1, int a2, int a3)
{
  unsigned int v3; // eax@1

  v3 = sub_1004B5F0(a1);
  return sub_1004C510(v3, a2, a3);
}

//----- (1004C760) --------------------------------------------------------
signed int __usercall sub_1004C760@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // edi@1
  signed int result; // eax@1
  int v5; // esi@1
  unsigned __int16 v6; // bx@2
  unsigned __int16 v7; // ax@2
  unsigned int v8; // ebx@2
  unsigned __int16 v9; // dx@2
  int v10; // edx@2
  int v11; // eax@2
  int v12; // esi@2
  unsigned int v13; // edx@2
  int v14; // eax@2
  int v15; // esi@2
  unsigned int v16; // ST2C_4@4
  unsigned int v17; // ST30_4@4
  unsigned int v18; // ST34_4@4
  unsigned int v19; // esi@4
  unsigned int v20; // ST2C_4@5
  unsigned int v21; // ST30_4@5
  unsigned int v22; // ST34_4@5
  unsigned int v23; // esi@5
  unsigned int v24; // ST30_4@6
  unsigned int v25; // ST34_4@6
  unsigned int v26; // edx@6
  unsigned int v27; // esi@6
  __int16 v28; // ST38_2@6
  unsigned int v29; // ST1C_4@6
  unsigned int v30; // ST20_4@6
  unsigned int v31; // ST24_4@6
  unsigned int v32; // esi@6
  unsigned int v33; // edx@6
  unsigned int v34; // ST30_4@6
  unsigned int v35; // ST34_4@6
  unsigned int v36; // esi@6
  unsigned int v37; // ST1C_4@6
  unsigned int v38; // ST20_4@6
  unsigned int v39; // ST24_4@6
  unsigned int v40; // esi@6
  unsigned int v41; // ST30_4@6
  unsigned int v42; // edx@6
  unsigned int v43; // ST34_4@6
  unsigned int v44; // esi@6
  unsigned int v45; // ST1C_4@6
  unsigned int v46; // ST20_4@6
  unsigned int v47; // ST24_4@6
  unsigned int v48; // esi@6
  unsigned int v49; // edx@6
  unsigned int v50; // ST30_4@6
  unsigned int v51; // ST34_4@6
  unsigned int v52; // esi@6
  unsigned int v53; // ST1C_4@6
  unsigned int v54; // ST20_4@6
  unsigned int v55; // ST24_4@6
  unsigned int v56; // ST28_4@6
  unsigned int v57; // ST30_4@6
  unsigned int v58; // edx@6
  unsigned int v59; // ST34_4@6
  unsigned int v60; // ST38_4@6
  unsigned int v61; // ST20_4@6
  unsigned int v62; // ST24_4@6
  unsigned int v63; // ebx@6
  unsigned int v64; // eax@6
  unsigned int v65; // [sp+14h] [bp-20h]@2
  unsigned int v66; // [sp+18h] [bp-1Ch]@2
  unsigned int v67; // [sp+1Ch] [bp-18h]@2
  unsigned int v68; // [sp+20h] [bp-14h]@2

  v3 = a1;
  result = 0;
  v5 = a2;
  if ( *(_BYTE *)(v3 + 260) & 1 )
  {
    BYTE1(result) = *(_BYTE *)(a2 + 3);
    HIBYTE(v6) = *(_BYTE *)(a2 + 7);
    LOBYTE(result) = *(_BYTE *)(a2 + 2);
    LOBYTE(v6) = *(_BYTE *)(a2 + 6);
    v65 = *(_DWORD *)v3 ^ (*(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (result << 8)) << 8));
    HIBYTE(v7) = *(_BYTE *)(a2 + 11);
    v8 = *(_DWORD *)(v3 + 4) ^ (*(_BYTE *)(a2 + 4) | ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8));
    LOBYTE(v7) = *(_BYTE *)(a2 + 10);
    v66 = v8;
    HIBYTE(v9) = *(_BYTE *)(a2 + 15);
    v67 = *(_DWORD *)(v3 + 8) ^ (*(_BYTE *)(v5 + 8) | ((*(_BYTE *)(v5 + 9) | (v7 << 8)) << 8));
    LOBYTE(v9) = *(_BYTE *)(v5 + 14);
    v10 = *(_BYTE *)(v5 + 13) | (v9 << 8);
    v11 = *(_BYTE *)(v5 + 12);
    v12 = *(_DWORD *)(v3 + 256);
    v13 = *(_DWORD *)(v3 + 12) ^ (v11 | (v10 << 8));
    v14 = v3 + 16 * (v12 - 9);
    v15 = v12 - 12;
    v68 = v13;
    if ( v15 )
    {
      if ( v15 != 2 )
      {
LABEL_6:
        v24 = *(_DWORD *)(v14 + 4) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v66] ^ *(_DWORD *)&dword_100EA320[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v68 >> 16)];
        v25 = *(_DWORD *)(v14 + 8) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v66 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v68)];
        v26 = *(_DWORD *)v14 ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v13 >> 24)];
        v27 = *(_DWORD *)(v14 + 12) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v66 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v67 >> 24)];
        v28 = *(_WORD *)(v14 + 12) ^ dword_100E9720[2 * (unsigned __int8)v68] ^ dword_100E9B20[2 * BYTE1(v65)] ^ dword_100E9F20[2 * (unsigned __int8)(v66 >> 16)] ^ dword_100EA320[2 * (v67 >> 24)];
        v29 = *(_DWORD *)(v14 + 16) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v26] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v24)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v25 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v27 >> 24)];
        v30 = *(_DWORD *)(v14 + 20) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v24] ^ *(_DWORD *)&dword_100EA320[2 * (v26 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v25)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v27 >> 16)];
        v31 = *(_DWORD *)(v14 + 24) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v25] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v26 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v24 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * HIBYTE(v28)];
        v32 = *(_DWORD *)(v14 + 28) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v28] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v26)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v24 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v25 >> 24)];
        v33 = *(_DWORD *)(v14 + 32) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v29] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v30)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v31 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v32 >> 24)];
        v34 = *(_DWORD *)(v14 + 36) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v30] ^ *(_DWORD *)&dword_100EA320[2 * (v29 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v31)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v32 >> 16)];
        v35 = *(_DWORD *)(v14 + 40) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v31] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v29 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v30 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v32)];
        v36 = *(_DWORD *)(v14 + 44) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v32] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v29)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v30 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v31 >> 24)];
        v37 = *(_DWORD *)(v14 + 48) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v33] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v34)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v35 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v36 >> 24)];
        v38 = *(_DWORD *)(v14 + 52) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v34] ^ *(_DWORD *)&dword_100EA320[2 * (v33 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v35)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v36 >> 16)];
        v39 = *(_DWORD *)(v14 + 56) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v35] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v33 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v34 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v36)];
        v40 = *(_DWORD *)(v14 + 60) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v36] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v33)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v34 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v35 >> 24)];
        v41 = *(_DWORD *)(v14 + 68) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v38] ^ *(_DWORD *)&dword_100EA320[2 * (v37 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v39)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v40 >> 16)];
        v42 = *(_DWORD *)(v14 + 64) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v37] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v38)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v39 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v40 >> 24)];
        v43 = *(_DWORD *)(v14 + 72) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v39] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v37 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v38 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v40)];
        v44 = *(_DWORD *)(v14 + 76) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v40] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v37)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v38 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v39 >> 24)];
        v45 = *(_DWORD *)(v14 + 80) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v42] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v41)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v43 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v44 >> 24)];
        v46 = *(_DWORD *)(v14 + 84) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v41] ^ *(_DWORD *)&dword_100EA320[2 * (v42 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v43)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v44 >> 16)];
        v47 = *(_DWORD *)(v14 + 88) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v43] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v42 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v41 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v44)];
        v48 = *(_DWORD *)(v14 + 92) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v44] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v42)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v41 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v43 >> 24)];
        v49 = *(_DWORD *)(v14 + 96) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v45] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v46)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v47 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v48 >> 24)];
        v50 = *(_DWORD *)(v14 + 100) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v46] ^ *(_DWORD *)&dword_100EA320[2 * (v45 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v47)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v48 >> 16)];
        v51 = *(_DWORD *)(v14 + 104) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v47] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v45 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v46 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v48)];
        v52 = *(_DWORD *)(v14 + 108) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v48] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v45)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v46 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v47 >> 24)];
        v53 = *(_DWORD *)(v14 + 112) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v49] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v50)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v51 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v52 >> 24)];
        v54 = *(_DWORD *)(v14 + 116) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v50] ^ *(_DWORD *)&dword_100EA320[2 * (v49 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v51)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v52 >> 16)];
        v55 = *(_DWORD *)(v14 + 120) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v51] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v49 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v50 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v52)];
        v56 = *(_DWORD *)(v14 + 124) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v52] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v49)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v50 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v51 >> 24)];
        v57 = *(_DWORD *)(v14 + 132) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v54] ^ *(_DWORD *)&dword_100EA320[2 * (v53 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v55)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v56 >> 16)];
        v58 = *(_DWORD *)(v14 + 128) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v53] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v54)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v55 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v56 >> 24)];
        v59 = *(_DWORD *)(v14 + 136) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v55] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v53 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v54 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v56)];
        v60 = *(_DWORD *)(v14 + 140) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v56] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v53)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v54 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v55 >> 24)];
        v61 = *(_DWORD *)(v14 + 148) ^ dword_100EA720[(unsigned __int8)v57] ^ dword_100EB320[v58 >> 24] ^ dword_100EAB20[BYTE1(v59)] ^ dword_100EAF20[(unsigned __int8)(v60 >> 16)];
        v62 = *(_DWORD *)(v14 + 152) ^ dword_100EA720[(unsigned __int8)v59] ^ dword_100EAF20[(unsigned __int8)(v58 >> 16)] ^ dword_100EB320[v57 >> 24] ^ dword_100EAB20[BYTE1(v60)];
        v63 = *(_DWORD *)(v14 + 156) ^ dword_100EA720[(unsigned __int8)v60] ^ dword_100EAB20[BYTE1(v58)] ^ dword_100EAF20[(unsigned __int8)(v57 >> 16)] ^ dword_100EB320[v59 >> 24];
        v64 = *(_DWORD *)(v14 + 144) ^ dword_100EA720[(unsigned __int8)v58] ^ dword_100EAB20[BYTE1(v57)] ^ dword_100EAF20[(unsigned __int8)(v59 >> 16)] ^ dword_100EB320[v60 >> 24];
        *(_BYTE *)(a3 + 1) = BYTE1(v64);
        *(_BYTE *)a3 = v64;
        *(_BYTE *)(a3 + 2) = v64 >> 16;
        *(_BYTE *)(a3 + 3) = BYTE3(v64);
        *(_BYTE *)(a3 + 5) = BYTE1(v61);
        *(_BYTE *)(a3 + 4) = v61;
        *(_BYTE *)(a3 + 7) = BYTE3(v61);
        *(_BYTE *)(a3 + 6) = v61 >> 16;
        *(_BYTE *)(a3 + 9) = BYTE1(v62);
        *(_BYTE *)(a3 + 8) = v62;
        *(_BYTE *)(a3 + 11) = BYTE3(v62);
        *(_BYTE *)(a3 + 10) = v62 >> 16;
        *(_BYTE *)(a3 + 12) = v63;
        *(_BYTE *)(a3 + 13) = BYTE1(v63);
        *(_BYTE *)(a3 + 15) = BYTE3(v63);
        *(_BYTE *)(a3 + 14) = v63 >> 16;
        return 1;
      }
      v16 = *(_DWORD *)(v14 - 64) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v13 >> 24)];
      v17 = *(_DWORD *)(v14 - 60) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100EA320[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v13 >> 16)];
      v18 = *(_DWORD *)(v14 - 56) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v68)];
      v19 = *(_DWORD *)(v14 - 52) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v13] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v67 >> 24)];
      v8 = *(_DWORD *)(v14 - 44) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v17] ^ *(_DWORD *)&dword_100EA320[2 * (v16 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v18)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v19 >> 16)];
      v67 = *(_DWORD *)(v14 - 40) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v18] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v16 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v17 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v19)];
      v65 = *(_DWORD *)(v14 - 48) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v16] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v17)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v18 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v19 >> 24)];
      v13 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v18 >> 24)];
      v68 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v18 >> 24)];
    }
    v20 = *(_DWORD *)(v14 - 32) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v13 >> 24)];
    v21 = *(_DWORD *)(v14 - 28) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100EA320[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v68 >> 16)];
    v22 = *(_DWORD *)(v14 - 24) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v68)];
    v23 = *(_DWORD *)(v14 - 20) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v67 >> 24)];
    v8 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100EA320[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v23 >> 16)];
    v67 = *(_DWORD *)(v14 - 8) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v22] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v20 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v21 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v23)];
    v65 = *(_DWORD *)(v14 - 16) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v20] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v21)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v22 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v23 >> 24)];
    v66 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100EA320[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v23 >> 16)];
    v13 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v22 >> 24)];
    v68 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100E9720[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100E9B20[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100E9F20[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100EA320[2 * (v22 >> 24)];
    goto LABEL_6;
  }
  return result;
}
// 100EA720: using guessed type int dword_100EA720[];
// 100EAB20: using guessed type int dword_100EAB20[];
// 100EAF20: using guessed type int dword_100EAF20[];
// 100EB320: using guessed type int dword_100EB320[];

//----- (1004D810) --------------------------------------------------------
int __usercall sub_1004D810@<eax>(int a1@<esi>, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@3
  bool v6; // zf@4

  result = *(_DWORD *)(a1 + 456);
  v4 = 0;
  if ( a3 )
  {
    do
    {
      if ( result == 16 )
      {
        v5 = 0;
        do
        {
          v6 = (*(_BYTE *)(v5 + a1))++ == -1;
          if ( !v6 )
            break;
          ++v5;
        }
        while ( v5 < 8 );
        sub_1004C760(a1 + 32, a1, a1 + 16);
        result = 0;
      }
      *(_BYTE *)(v4++ + a2) ^= *(_BYTE *)(a1 + 16 + result++);
    }
    while ( v4 < a3 );
  }
  *(_DWORD *)(a1 + 456) = result;
  return result;
}

//----- (1004D870) --------------------------------------------------------
signed int __usercall sub_1004D870@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned __int16 v4; // dx@1
  int v5; // edx@1
  unsigned __int16 v6; // cx@1
  int v7; // esi@1
  int v8; // edi@1
  unsigned int v9; // ecx@1
  unsigned __int16 v10; // dx@2
  int v11; // edx@2
  int v12; // ebx@2
  int v13; // edx@3
  int v14; // ST20_4@3
  int v15; // edx@3
  int v16; // ST24_4@3
  int v17; // edx@3
  int v18; // ST28_4@3
  unsigned int v19; // edx@3
  int v20; // ebp@3
  int v21; // esi@3
  int v22; // edi@3
  unsigned int v23; // ecx@3
  int v24; // ST20_4@3
  int v25; // ebx@3
  unsigned int v26; // edx@3
  int v27; // ST28_4@3
  int v28; // ebp@3
  int v29; // esi@3
  int v30; // edi@3
  unsigned int v31; // ecx@3
  int v32; // ST10_4@3
  int v33; // ebx@3
  int v34; // ebp@3
  unsigned int v35; // edx@3
  int v36; // ST28_4@3
  int v37; // ST24_4@3
  int v38; // ebp@3
  int v39; // esi@3
  int v40; // edi@3
  unsigned int v41; // ecx@3
  int v42; // ebx@3
  unsigned int v43; // edx@3
  int v44; // ebp@3
  int v45; // esi@3
  int v46; // edi@3
  unsigned int v47; // ecx@3
  int v48; // ST10_4@3
  int v49; // ST20_4@3
  int v50; // ebp@3
  int v51; // ebx@3
  unsigned int v52; // edx@3
  int v53; // ST28_4@3
  int v54; // ST24_4@3
  int v55; // ebp@3
  int v56; // esi@3
  int v57; // edi@3
  unsigned int v58; // ecx@3
  int v59; // ebx@3
  unsigned int v60; // edx@3
  int v61; // ST28_4@3
  int v62; // ST24_4@3
  int v63; // ebp@3
  int v64; // esi@3
  int v65; // edi@3
  unsigned int v66; // ecx@3
  int v67; // ST10_4@3
  int v68; // ebx@3
  unsigned int v69; // edx@3
  int v70; // ebp@3
  int v71; // ebp@3
  int v72; // esi@3
  int v73; // edi@3
  signed int result; // eax@3
  int v75; // edx@4
  int v76; // ST20_4@4
  unsigned int v77; // edx@4
  int v78; // ebp@4
  int v79; // esi@4
  int v80; // edi@4
  int v81; // ecx@4
  unsigned int v82; // edx@4
  int v83; // ST20_4@4
  int v84; // ebp@4
  int v85; // esi@4
  int v86; // edi@4
  int v87; // ecx@4
  int v88; // ebx@4
  unsigned int v89; // edx@4
  int v90; // ebp@4
  int v91; // esi@4
  int v92; // edi@4
  int v93; // ecx@4
  unsigned int v94; // edx@4
  int v95; // ST20_4@4
  int v96; // ebp@4
  int v97; // esi@4
  int v98; // edi@4
  int v99; // ecx@4
  unsigned int v100; // edx@4
  int v101; // ST20_4@4
  int v102; // ST10_4@4
  int v103; // ebp@4
  int v104; // esi@4
  int v105; // edi@4
  int v106; // ST10_4@4
  int v107; // ecx@4
  unsigned int v108; // edx@4
  int v109; // ST20_4@4
  int v110; // ebp@4
  int v111; // esi@4
  int v112; // edi@4
  int v113; // ecx@4
  unsigned int v114; // edx@4
  int v115; // ST20_4@4
  int v116; // ebp@4
  int v117; // esi@4
  int v118; // edi@4
  int v119; // ecx@4
  unsigned int v120; // edx@4
  int v121; // ST10_4@4
  int v122; // ebp@4
  int v123; // ebp@4
  int v124; // esi@4
  int v125; // edi@4
  int v126; // ebp@5
  int v127; // esi@5
  int v128; // edi@5
  unsigned int v129; // ecx@5
  int v130; // edx@5
  int v131; // esi@5
  int v132; // edi@5
  unsigned int v133; // ecx@5
  int v134; // ebp@5
  int v135; // esi@5
  int v136; // edi@5
  unsigned int v137; // ecx@5
  int v138; // edx@5
  int v139; // esi@5
  int v140; // edi@5
  unsigned int v141; // ecx@5
  int v142; // ebp@5
  int v143; // esi@5
  int v144; // edi@5
  unsigned int v145; // ecx@5
  int v146; // edx@5
  int v147; // esi@5
  int v148; // edi@5
  unsigned int v149; // ecx@5
  int v150; // ebp@5
  int v151; // esi@5
  int v152; // edi@5
  unsigned int v153; // ecx@5
  int v154; // edx@5
  int v155; // esi@5
  int v156; // edi@5
  unsigned int v157; // ecx@5
  int v158; // ebp@5
  int v159; // esi@5
  int v160; // edi@5
  unsigned int v161; // ecx@5
  int v162; // edx@5
  int v163; // edx@5
  int v164; // esi@5
  int v165; // edi@5
  int v166; // [sp+10h] [bp-20h]@1

  *(_DWORD *)(a1 + 260) = 17;
  v3 = a2;
  HIBYTE(v4) = *(_BYTE *)(a2 + 3);
  LOBYTE(v4) = *(_BYTE *)(a2 + 2);
  v5 = *(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (v4 << 8)) << 8);
  *(_DWORD *)a1 = v5;
  HIBYTE(v6) = *(_BYTE *)(a2 + 7);
  v166 = v5;
  LOBYTE(v6) = *(_BYTE *)(a2 + 6);
  v7 = ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8) | *(_BYTE *)(a2 + 4);
  *(_DWORD *)(a1 + 4) = v7;
  HIBYTE(v6) = *(_BYTE *)(a2 + 11);
  LOBYTE(v6) = *(_BYTE *)(a2 + 10);
  v8 = ((*(_BYTE *)(v3 + 9) | (v6 << 8)) << 8) | *(_BYTE *)(v3 + 8);
  *(_DWORD *)(a1 + 8) = v8;
  HIBYTE(v6) = *(_BYTE *)(a2 + 15);
  LOBYTE(v6) = *(_BYTE *)(a2 + 14);
  v9 = *(_BYTE *)(v3 + 12) | ((*(_BYTE *)(v3 + 13) | (v6 << 8)) << 8);
  *(_DWORD *)(a1 + 12) = v9;
  if ( a3 == 16 )
  {
    v126 = v5 ^ dword_100EB320[(unsigned __int8)v9] ^ dword_100EA720[BYTE1(v9)] ^ dword_100EAB20[(unsigned __int8)(v9 >> 16)] ^ dword_100EAF20[v9 >> 24] ^ 1;
    v127 = v126 ^ v7;
    *(_DWORD *)(a1 + 16) = v126;
    *(_DWORD *)(a1 + 20) = v127;
    v128 = v127 ^ v8;
    *(_DWORD *)(a1 + 24) = v128;
    v129 = v128 ^ v9;
    *(_DWORD *)(a1 + 28) = v129;
    v130 = v126 ^ dword_100EB320[(unsigned __int8)v129] ^ dword_100EA720[BYTE1(v129)] ^ dword_100EAB20[(unsigned __int8)(v129 >> 16)] ^ dword_100EAF20[v129 >> 24] ^ 2;
    v131 = v130 ^ v127;
    *(_DWORD *)(a1 + 32) = v130;
    *(_DWORD *)(a1 + 36) = v131;
    v132 = v131 ^ v128;
    *(_DWORD *)(a1 + 40) = v132;
    v133 = v132 ^ v129;
    *(_DWORD *)(a1 + 44) = v133;
    v134 = v130 ^ dword_100EB320[(unsigned __int8)v133] ^ dword_100EA720[BYTE1(v133)] ^ dword_100EAB20[(unsigned __int8)(v133 >> 16)] ^ dword_100EAF20[v133 >> 24] ^ 4;
    v135 = v134 ^ v131;
    v136 = v135 ^ v132;
    v137 = v136 ^ v133;
    *(_DWORD *)(a1 + 48) = v134;
    *(_DWORD *)(a1 + 52) = v135;
    *(_DWORD *)(a1 + 56) = v136;
    *(_DWORD *)(a1 + 60) = v137;
    v138 = v134 ^ dword_100EB320[(unsigned __int8)v137] ^ dword_100EA720[BYTE1(v137)] ^ dword_100EAB20[(unsigned __int8)(v137 >> 16)] ^ dword_100EAF20[v137 >> 24] ^ 8;
    *(_DWORD *)(a1 + 64) = v138;
    v139 = v138 ^ v135;
    *(_DWORD *)(a1 + 68) = v139;
    v140 = v139 ^ v136;
    *(_DWORD *)(a1 + 72) = v140;
    v141 = v140 ^ v137;
    *(_DWORD *)(a1 + 76) = v141;
    v142 = v138 ^ dword_100EB320[(unsigned __int8)v141] ^ dword_100EA720[BYTE1(v141)] ^ dword_100EAB20[(unsigned __int8)(v141 >> 16)] ^ dword_100EAF20[v141 >> 24] ^ 0x10;
    v143 = v142 ^ v139;
    v144 = v143 ^ v140;
    v145 = v144 ^ v141;
    *(_DWORD *)(a1 + 80) = v142;
    *(_DWORD *)(a1 + 84) = v143;
    *(_DWORD *)(a1 + 88) = v144;
    *(_DWORD *)(a1 + 92) = v145;
    v146 = v142 ^ dword_100EB320[(unsigned __int8)v145] ^ dword_100EA720[BYTE1(v145)] ^ dword_100EAB20[(unsigned __int8)(v145 >> 16)] ^ dword_100EAF20[v145 >> 24] ^ 0x20;
    v147 = v146 ^ v143;
    v148 = v147 ^ v144;
    v149 = v148 ^ v145;
    *(_DWORD *)(a1 + 100) = v147;
    *(_DWORD *)(a1 + 104) = v148;
    *(_DWORD *)(a1 + 108) = v149;
    *(_DWORD *)(a1 + 96) = v146;
    v150 = v146 ^ dword_100EB320[(unsigned __int8)v149] ^ dword_100EA720[BYTE1(v149)] ^ dword_100EAB20[(unsigned __int8)(v149 >> 16)] ^ dword_100EAF20[v149 >> 24] ^ 0x40;
    v151 = v150 ^ v147;
    v152 = v151 ^ v148;
    v153 = v152 ^ v149;
    *(_DWORD *)(a1 + 112) = v150;
    *(_DWORD *)(a1 + 116) = v151;
    *(_DWORD *)(a1 + 120) = v152;
    *(_DWORD *)(a1 + 124) = v153;
    v154 = v150 ^ dword_100EB320[(unsigned __int8)v153] ^ dword_100EA720[BYTE1(v153)] ^ dword_100EAB20[(unsigned __int8)(v153 >> 16)] ^ dword_100EAF20[v153 >> 24] ^ 0x80;
    v155 = v154 ^ v151;
    *(_DWORD *)(a1 + 128) = v154;
    *(_DWORD *)(a1 + 132) = v155;
    v156 = v155 ^ v152;
    *(_DWORD *)(a1 + 136) = v156;
    v157 = v156 ^ v153;
    *(_DWORD *)(a1 + 140) = v157;
    v158 = v154 ^ dword_100EB320[(unsigned __int8)v157] ^ dword_100EA720[BYTE1(v157)] ^ dword_100EAB20[(unsigned __int8)(v157 >> 16)] ^ dword_100EAF20[v157 >> 24] ^ 0x1B;
    v159 = v158 ^ v155;
    v160 = v159 ^ v156;
    v161 = v160 ^ v157;
    *(_DWORD *)(a1 + 148) = v159;
    *(_DWORD *)(a1 + 152) = v160;
    *(_DWORD *)(a1 + 144) = v158;
    *(_DWORD *)(a1 + 156) = v161;
    v162 = dword_100EB320[(unsigned __int8)v161] ^ dword_100EA720[BYTE1(v161)] ^ dword_100EAB20[(unsigned __int8)(v161 >> 16)] ^ dword_100EAF20[v161 >> 24];
    *(_DWORD *)(a1 + 256) = 10;
    v163 = v158 ^ v162 ^ 0x36;
    v164 = v163 ^ v159;
    v165 = v164 ^ v160;
    *(_DWORD *)(a1 + 168) = v165;
    *(_DWORD *)(a1 + 164) = v164;
    *(_DWORD *)(a1 + 160) = v163;
    *(_DWORD *)(a1 + 172) = v165 ^ v161;
    result = 1;
  }
  else
  {
    HIBYTE(v10) = *(_BYTE *)(a2 + 19);
    LOBYTE(v10) = *(_BYTE *)(a2 + 18);
    v11 = v10 << 8;
    v12 = *(_BYTE *)(a2 + 17);
    if ( a3 == 24 )
    {
      v75 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v75;
      v76 = v75;
      BYTE1(v75) = *(_BYTE *)(a2 + 23);
      LOBYTE(v75) = *(_BYTE *)(a2 + 22);
      v77 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v75 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v77;
      v78 = v166 ^ dword_100EB320[(unsigned __int8)v77] ^ dword_100EA720[BYTE1(v77)] ^ dword_100EAB20[(unsigned __int8)(v77 >> 16)] ^ dword_100EAF20[v77 >> 24] ^ 1;
      v79 = v78 ^ v7;
      v80 = v79 ^ v8;
      v81 = v80 ^ v9;
      *(_DWORD *)(a1 + 40) = v81 ^ v76;
      v82 = v81 ^ v76 ^ v77;
      v83 = v81 ^ v76;
      *(_DWORD *)(a1 + 36) = v81;
      *(_DWORD *)(a1 + 24) = v78;
      *(_DWORD *)(a1 + 28) = v79;
      *(_DWORD *)(a1 + 32) = v80;
      *(_DWORD *)(a1 + 44) = v82;
      v84 = v78 ^ dword_100EB320[(unsigned __int8)v82] ^ dword_100EA720[BYTE1(v82)] ^ dword_100EAB20[(unsigned __int8)(v82 >> 16)] ^ dword_100EAF20[v82 >> 24] ^ 2;
      v85 = v84 ^ v79;
      v86 = v85 ^ v80;
      v87 = v86 ^ v81;
      v89 = v87 ^ v83 ^ v82;
      v88 = v87 ^ v83;
      *(_DWORD *)(a1 + 64) = v87 ^ v83;
      *(_DWORD *)(a1 + 48) = v84;
      *(_DWORD *)(a1 + 52) = v85;
      *(_DWORD *)(a1 + 56) = v86;
      *(_DWORD *)(a1 + 60) = v87;
      *(_DWORD *)(a1 + 68) = v89;
      v90 = v84 ^ dword_100EB320[(unsigned __int8)v89] ^ dword_100EA720[BYTE1(v89)] ^ dword_100EAB20[(unsigned __int8)(v89 >> 16)] ^ dword_100EAF20[v89 >> 24] ^ 4;
      v91 = v90 ^ v85;
      v92 = v91 ^ v86;
      v93 = v92 ^ v87;
      *(_DWORD *)(a1 + 88) = v93 ^ v88;
      v94 = v93 ^ v88 ^ v89;
      v95 = v93 ^ v88;
      *(_DWORD *)(a1 + 84) = v93;
      *(_DWORD *)(a1 + 72) = v90;
      *(_DWORD *)(a1 + 76) = v91;
      *(_DWORD *)(a1 + 80) = v92;
      *(_DWORD *)(a1 + 92) = v94;
      v96 = v90 ^ dword_100EB320[(unsigned __int8)v94] ^ dword_100EA720[BYTE1(v94)] ^ dword_100EAB20[(unsigned __int8)(v94 >> 16)] ^ dword_100EAF20[v94 >> 24] ^ 8;
      v97 = v96 ^ v91;
      v98 = v97 ^ v92;
      v99 = v98 ^ v93;
      *(_DWORD *)(a1 + 112) = v99 ^ v95;
      v100 = v99 ^ v95 ^ v94;
      v101 = v99 ^ v95;
      *(_DWORD *)(a1 + 108) = v99;
      v102 = v96;
      *(_DWORD *)(a1 + 96) = v96;
      *(_DWORD *)(a1 + 100) = v97;
      *(_DWORD *)(a1 + 104) = v98;
      *(_DWORD *)(a1 + 116) = v100;
      v103 = v96 ^ dword_100EB320[(unsigned __int8)v100] ^ dword_100EA720[BYTE1(v100)] ^ dword_100EAB20[(unsigned __int8)(v100 >> 16)] ^ dword_100EAF20[v100 >> 24] ^ 0x10;
      v104 = v103 ^ v97;
      v105 = v104 ^ v98;
      v106 = v102 ^ dword_100EB320[(unsigned __int8)v100] ^ dword_100EA720[BYTE1(v100)] ^ dword_100EAB20[(unsigned __int8)(v100 >> 16)] ^ dword_100EAF20[v100 >> 24] ^ 0x10;
      *(_DWORD *)(a1 + 120) = v103;
      *(_DWORD *)(a1 + 124) = v104;
      *(_DWORD *)(a1 + 128) = v105;
      v107 = v105 ^ v99;
      *(_DWORD *)(a1 + 136) = v107 ^ v101;
      v108 = v107 ^ v101 ^ v100;
      v109 = v107 ^ v101;
      *(_DWORD *)(a1 + 132) = v107;
      *(_DWORD *)(a1 + 140) = v108;
      v110 = v106 ^ dword_100EB320[(unsigned __int8)v108] ^ dword_100EA720[BYTE1(v108)] ^ dword_100EAB20[(unsigned __int8)(v108 >> 16)] ^ dword_100EAF20[v108 >> 24] ^ 0x20;
      v111 = v110 ^ v104;
      v112 = v111 ^ v105;
      v113 = v112 ^ v107;
      *(_DWORD *)(a1 + 160) = v113 ^ v109;
      v114 = v113 ^ v109 ^ v108;
      v115 = v113 ^ v109;
      *(_DWORD *)(a1 + 156) = v113;
      *(_DWORD *)(a1 + 144) = v110;
      *(_DWORD *)(a1 + 148) = v111;
      *(_DWORD *)(a1 + 152) = v112;
      *(_DWORD *)(a1 + 164) = v114;
      v116 = v110 ^ dword_100EB320[(unsigned __int8)v114] ^ dword_100EA720[BYTE1(v114)] ^ dword_100EAB20[(unsigned __int8)(v114 >> 16)] ^ dword_100EAF20[v114 >> 24] ^ 0x40;
      v117 = v116 ^ v111;
      v118 = v117 ^ v112;
      v119 = v118 ^ v113;
      v120 = v119 ^ v115 ^ v114;
      *(_DWORD *)(a1 + 180) = v119;
      *(_DWORD *)(a1 + 184) = v119 ^ v115;
      v121 = v116;
      *(_DWORD *)(a1 + 168) = v116;
      *(_DWORD *)(a1 + 172) = v117;
      *(_DWORD *)(a1 + 176) = v118;
      *(_DWORD *)(a1 + 188) = v120;
      v122 = dword_100EB320[(unsigned __int8)v120] ^ dword_100EA720[BYTE1(v120)] ^ dword_100EAB20[(unsigned __int8)(v120 >> 16)] ^ dword_100EAF20[v120 >> 24];
      *(_DWORD *)(a1 + 256) = 12;
      v123 = v121 ^ v122 ^ 0x80;
      v124 = v123 ^ v117;
      v125 = v124 ^ v118;
      *(_DWORD *)(a1 + 200) = v125;
      *(_DWORD *)(a1 + 196) = v124;
      *(_DWORD *)(a1 + 192) = v123;
      *(_DWORD *)(a1 + 204) = v125 ^ v119;
      result = 1;
    }
    else
    {
      v13 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v13;
      v14 = v13;
      BYTE1(v13) = *(_BYTE *)(a2 + 23);
      LOBYTE(v13) = *(_BYTE *)(a2 + 22);
      v15 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v13 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v15;
      v16 = v15;
      BYTE1(v15) = *(_BYTE *)(a2 + 27);
      LOBYTE(v15) = *(_BYTE *)(a2 + 26);
      v17 = *(_BYTE *)(a2 + 24) | ((*(_BYTE *)(a2 + 25) | ((unsigned __int16)v15 << 8)) << 8);
      *(_DWORD *)(a1 + 24) = v17;
      v18 = v17;
      BYTE1(v17) = *(_BYTE *)(a2 + 31);
      LOBYTE(v17) = *(_BYTE *)(a2 + 30);
      v19 = *(_BYTE *)(a2 + 28) | ((*(_BYTE *)(a2 + 29) | ((unsigned __int16)v17 << 8)) << 8);
      *(_DWORD *)(a1 + 28) = v19;
      v20 = v166 ^ dword_100EB320[(unsigned __int8)v19] ^ dword_100EA720[BYTE1(v19)] ^ dword_100EAB20[(unsigned __int8)(v19 >> 16)] ^ dword_100EAF20[v19 >> 24] ^ 1;
      v21 = v20 ^ v7;
      v22 = v21 ^ v8;
      v23 = v22 ^ v9;
      *(_DWORD *)(a1 + 32) = v20;
      *(_DWORD *)(a1 + 36) = v21;
      *(_DWORD *)(a1 + 40) = v22;
      *(_DWORD *)(a1 + 44) = v23;
      v24 = dword_100EA720[(unsigned __int8)v23] ^ dword_100EAB20[BYTE1(v23)] ^ dword_100EAF20[(unsigned __int8)(v23 >> 16)] ^ dword_100EB320[v23 >> 24] ^ v14;
      *(_DWORD *)(a1 + 48) = v24;
      v25 = v24 ^ v16 ^ v18;
      v26 = v25 ^ v19;
      *(_DWORD *)(a1 + 56) = v25;
      v27 = v24 ^ v16 ^ v18;
      *(_DWORD *)(a1 + 52) = v24 ^ v16;
      *(_DWORD *)(a1 + 60) = v26;
      v28 = v20 ^ dword_100EB320[(unsigned __int8)v26] ^ dword_100EA720[BYTE1(v26)] ^ dword_100EAB20[(unsigned __int8)(v26 >> 16)] ^ dword_100EAF20[v26 >> 24] ^ 2;
      v29 = v28 ^ v21;
      *(_DWORD *)(a1 + 64) = v28;
      v30 = v29 ^ v22;
      v31 = v30 ^ v23;
      *(_DWORD *)(a1 + 76) = v31;
      v32 = v28;
      *(_DWORD *)(a1 + 68) = v29;
      *(_DWORD *)(a1 + 72) = v30;
      v33 = dword_100EA720[(unsigned __int8)v31] ^ dword_100EAB20[BYTE1(v31)] ^ dword_100EAF20[(unsigned __int8)(v31 >> 16)] ^ dword_100EB320[v31 >> 24] ^ v24;
      v34 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 80) = v33;
      *(_DWORD *)(a1 + 88) = v34 ^ v27;
      v35 = v34 ^ v27 ^ v26;
      v36 = v34 ^ v27;
      v37 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 84) = v34;
      *(_DWORD *)(a1 + 92) = v35;
      v38 = v32 ^ dword_100EB320[(unsigned __int8)v35] ^ dword_100EA720[BYTE1(v35)] ^ dword_100EAB20[(unsigned __int8)(v35 >> 16)] ^ dword_100EAF20[v35 >> 24] ^ 4;
      v39 = v38 ^ v29;
      *(_DWORD *)(a1 + 96) = v38;
      *(_DWORD *)(a1 + 100) = v39;
      v40 = v39 ^ v30;
      v41 = v40 ^ v31;
      *(_DWORD *)(a1 + 108) = v41;
      *(_DWORD *)(a1 + 104) = v40;
      v42 = dword_100EA720[(unsigned __int8)v41] ^ dword_100EAB20[BYTE1(v41)] ^ dword_100EAF20[(unsigned __int8)(v41 >> 16)] ^ dword_100EB320[v41 >> 24] ^ v33;
      *(_DWORD *)(a1 + 112) = v42;
      v43 = v42 ^ v37 ^ v36 ^ v35;
      *(_DWORD *)(a1 + 120) = v42 ^ v37 ^ v36;
      *(_DWORD *)(a1 + 116) = v42 ^ v37;
      *(_DWORD *)(a1 + 124) = v43;
      v44 = v38 ^ dword_100EB320[(unsigned __int8)v43] ^ dword_100EA720[BYTE1(v43)] ^ dword_100EAB20[(unsigned __int8)(v43 >> 16)] ^ dword_100EAF20[v43 >> 24] ^ 8;
      v45 = v44 ^ v39;
      v46 = v45 ^ v40;
      v47 = v46 ^ v41;
      *(_DWORD *)(a1 + 128) = v44;
      *(_DWORD *)(a1 + 132) = v45;
      *(_DWORD *)(a1 + 136) = v46;
      *(_DWORD *)(a1 + 140) = v47;
      v48 = v44;
      v49 = dword_100EA720[(unsigned __int8)v47] ^ dword_100EAB20[BYTE1(v47)] ^ dword_100EAF20[(unsigned __int8)(v47 >> 16)] ^ dword_100EB320[v47 >> 24] ^ v42;
      *(_DWORD *)(a1 + 144) = v49;
      v50 = v49 ^ v42 ^ v37;
      v51 = v50 ^ v42 ^ v37 ^ v36;
      v52 = v51 ^ v43;
      *(_DWORD *)(a1 + 152) = v51;
      v53 = v51;
      *(_DWORD *)(a1 + 148) = v50;
      v54 = v50;
      *(_DWORD *)(a1 + 156) = v52;
      v55 = v48 ^ dword_100EB320[(unsigned __int8)v52] ^ dword_100EA720[BYTE1(v52)] ^ dword_100EAB20[(unsigned __int8)(v52 >> 16)] ^ dword_100EAF20[v52 >> 24] ^ 0x10;
      v56 = v55 ^ v45;
      *(_DWORD *)(a1 + 160) = v55;
      v57 = v56 ^ v46;
      v58 = v57 ^ v47;
      *(_DWORD *)(a1 + 172) = v58;
      *(_DWORD *)(a1 + 164) = v56;
      *(_DWORD *)(a1 + 168) = v57;
      v59 = dword_100EA720[(unsigned __int8)v58] ^ dword_100EAB20[BYTE1(v58)] ^ dword_100EAF20[(unsigned __int8)(v58 >> 16)] ^ dword_100EB320[v58 >> 24] ^ v49;
      *(_DWORD *)(a1 + 176) = v59;
      *(_DWORD *)(a1 + 184) = v59 ^ v54 ^ v53;
      v60 = v59 ^ v54 ^ v53 ^ v52;
      v61 = v59 ^ v54 ^ v53;
      v62 = v59 ^ v54;
      *(_DWORD *)(a1 + 180) = v62;
      *(_DWORD *)(a1 + 188) = v60;
      v63 = v55 ^ dword_100EB320[(unsigned __int8)v60] ^ dword_100EA720[BYTE1(v60)] ^ dword_100EAB20[(unsigned __int8)(v60 >> 16)] ^ dword_100EAF20[v60 >> 24] ^ 0x20;
      v64 = v63 ^ v56;
      *(_DWORD *)(a1 + 192) = v63;
      v65 = v64 ^ v57;
      v66 = v65 ^ v58;
      *(_DWORD *)(a1 + 204) = v66;
      v67 = v63;
      *(_DWORD *)(a1 + 196) = v64;
      *(_DWORD *)(a1 + 200) = v65;
      v68 = dword_100EA720[(unsigned __int8)v66] ^ dword_100EAB20[BYTE1(v66)] ^ dword_100EAF20[(unsigned __int8)(v66 >> 16)] ^ dword_100EB320[v66 >> 24] ^ v59;
      *(_DWORD *)(a1 + 208) = v68;
      *(_DWORD *)(a1 + 216) = v68 ^ v62 ^ v61;
      v69 = v68 ^ v62 ^ v61 ^ v60;
      *(_DWORD *)(a1 + 212) = v68 ^ v62;
      *(_DWORD *)(a1 + 220) = v69;
      v70 = dword_100EB320[(unsigned __int8)v69] ^ dword_100EA720[BYTE1(v69)] ^ dword_100EAB20[(unsigned __int8)(v69 >> 16)] ^ dword_100EAF20[v69 >> 24];
      *(_DWORD *)(a1 + 256) = 14;
      v71 = v67 ^ v70 ^ 0x40;
      v72 = v71 ^ v64;
      v73 = v72 ^ v65;
      *(_DWORD *)(a1 + 232) = v73;
      *(_DWORD *)(a1 + 228) = v72;
      *(_DWORD *)(a1 + 224) = v71;
      *(_DWORD *)(a1 + 236) = v73 ^ v66;
      result = 1;
    }
  }
  return result;
}
// 100EA720: using guessed type int dword_100EA720[];
// 100EAB20: using guessed type int dword_100EAB20[];
// 100EAF20: using guessed type int dword_100EAF20[];
// 100EB320: using guessed type int dword_100EB320[];

//----- (1004E5F0) --------------------------------------------------------
void *__usercall sub_1004E5F0@<eax>(void *a1@<eax>)
{
  return memset(a1, 0, 0xA0u);
}

//----- (1004E610) --------------------------------------------------------
unsigned int __cdecl sub_1004E610(int a1, unsigned int a2)
{
  int v2; // eax@1
  unsigned int result; // eax@1
  _BYTE *v4; // ecx@3
  char v5; // dl@3
  unsigned __int64 v6; // [sp+Ch] [bp-8h]@1

  v2 = sub_10031910();
  v6 = ((unsigned __int64)(unsigned int)v2 << 32) + (unsigned int)j_TSK_pvg_get_us_timer();
  result = 0;
  do
  {
    if ( result >= a2 )
      break;
    v4 = (_BYTE *)(result + a1);
    v5 = *((_BYTE *)&v6 + result++ + a1 - a1);
    *v4 = v5;
  }
  while ( result < 8 );
  return result;
}
// 10031960: using guessed type int j_TSK_pvg_get_us_timer(void);

//----- (1004E670) --------------------------------------------------------
int __usercall sub_1004E670@<eax>(int result@<eax>)
{
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 8) = 1732584193;
  *(_DWORD *)(result + 12) = -271733879;
  *(_DWORD *)(result + 16) = -1732584194;
  *(_DWORD *)(result + 20) = 271733878;
  *(_DWORD *)(result + 24) = -1009589776;
  return result;
}

//----- (1004E6B0) --------------------------------------------------------
int __usercall sub_1004E6B0@<eax>(int result@<eax>)
{
  int v1; // ebx@1
  int v2; // esi@1
  int v3; // edx@1
  unsigned int v4; // ST28_4@1
  int v5; // edx@1
  int v6; // ST18_4@1
  unsigned int v7; // ST2C_4@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // ST14_4@1
  int v12; // ST20_4@1
  unsigned int v13; // ST30_4@1
  int v14; // esi@1
  unsigned int v15; // ST34_4@1
  int v16; // edi@1
  int v17; // edi@1
  int v18; // ecx@1
  int v19; // ST1C_4@1
  int v20; // ebx@1
  unsigned int v21; // ebp@1
  unsigned int v22; // ST38_4@1
  int v23; // edx@1
  int v24; // ST10_4@1
  unsigned int v25; // ST3C_4@1
  int v26; // esi@1
  int v27; // esi@1
  int v28; // ST18_4@1
  int v29; // ebp@1
  unsigned int v30; // ST40_4@1
  int v31; // edi@1
  int v32; // ebx@1
  int v33; // ST14_4@1
  unsigned int v34; // ST44_4@1
  int v35; // edi@1
  int v36; // ST20_4@1
  int v37; // ST1C_4@1
  unsigned int v38; // ST48_4@1
  int v39; // ebx@1
  int v40; // ebx@1
  int v41; // ecx@1
  int v42; // ebp@1
  unsigned int v43; // ST4C_4@1
  int v44; // edx@1
  int v45; // edx@1
  int v46; // ST10_4@1
  int v47; // esi@1
  unsigned int v48; // ST50_4@1
  int v49; // esi@1
  int v50; // ST18_4@1
  unsigned int v51; // ST54_4@1
  int v52; // edi@1
  int v53; // ebx@1
  int v54; // ST14_4@1
  unsigned int v55; // ST58_4@1
  int v56; // edi@1
  int v57; // ST20_4@1
  int v58; // ebx@1
  unsigned int v59; // ST5C_4@1
  int v60; // ebx@1
  int v61; // ecx@1
  int v62; // ST14_4@1
  int v63; // ST1C_4@1
  unsigned int v64; // ST60_4@1
  int v65; // edx@1
  int v66; // edx@1
  int v67; // ST10_4@1
  unsigned int v68; // ST64_4@1
  int v69; // esi@1
  int v70; // esi@1
  int v71; // ST18_4@1
  int v72; // ebp@1
  int v73; // ecx@1
  int v74; // ebx@1
  int v75; // ST68_4@1
  int v76; // edi@1
  int v77; // edi@1
  int v78; // ST14_4@1
  int v79; // ST20_4@1
  int v80; // ecx@1
  int v81; // ST6C_4@1
  int v82; // edi@1
  int v83; // ecx@1
  int v84; // ST70_4@1
  int v85; // ebx@1
  int v86; // ST1C_4@1
  int v87; // ebx@1
  int v88; // ecx@1
  int v89; // ST14_4@1
  int v90; // ecx@1
  int v91; // ST74_4@1
  int v92; // edx@1
  int v93; // edx@1
  int v94; // ST10_4@1
  int v95; // ecx@1
  int v96; // ST78_4@1
  int v97; // esi@1
  int v98; // esi@1
  int v99; // ST18_4@1
  int v100; // ebx@1
  int v101; // ecx@1
  int v102; // edi@1
  int v103; // ST7C_4@1
  int v104; // edi@1
  int v105; // ST20_4@1
  int v106; // ecx@1
  int v107; // ST80_4@1
  int v108; // edx@1
  int v109; // edx@1
  int v110; // ecx@1
  int v111; // ST84_4@1
  int v112; // ebx@1
  int v113; // ebx@1
  int v114; // ST14_4@1
  int v115; // ecx@1
  int v116; // ebp@1
  int v117; // ST88_4@1
  int v118; // edi@1
  int v119; // edi@1
  int v120; // ST10_4@1
  int v121; // ebp@1
  int v122; // ecx@1
  int v123; // ST8C_4@1
  int v124; // edx@1
  int v125; // ebp@1
  int v126; // edx@1
  int v127; // ecx@1
  int v128; // ST18_4@1
  int v129; // ST90_4@1
  int v130; // esi@1
  int v131; // esi@1
  int v132; // ST20_4@1
  int v133; // ecx@1
  int v134; // ST94_4@1
  int v135; // edi@1
  int v136; // edi@1
  int v137; // ecx@1
  int v138; // ST98_4@1
  int v139; // ebx@1
  int v140; // ebx@1
  int v141; // ST14_4@1
  int v142; // ecx@1
  int v143; // ebp@1
  int v144; // ST9C_4@1
  int v145; // esi@1
  int v146; // esi@1
  int v147; // ST10_4@1
  int v148; // ebp@1
  int v149; // ecx@1
  int v150; // STA0_4@1
  int v151; // edi@1
  int v152; // ebp@1
  int v153; // edx@1
  int v154; // ecx@1
  int v155; // ST18_4@1
  int v156; // STA4_4@1
  int v157; // edi@1
  int v158; // edi@1
  int v159; // ST20_4@1
  int v160; // ecx@1
  int v161; // STA8_4@1
  int v162; // esi@1
  int v163; // esi@1
  int v164; // ecx@1
  int v165; // STAC_4@1
  int v166; // ebx@1
  int v167; // ebx@1
  int v168; // ST14_4@1
  int v169; // ecx@1
  int v170; // ebp@1
  int v171; // STB0_4@1
  int v172; // edi@1
  int v173; // edi@1
  int v174; // ST10_4@1
  int v175; // ebp@1
  int v176; // ecx@1
  int v177; // STB4_4@1
  int v178; // esi@1
  int v179; // ebp@1
  int v180; // edx@1
  int v181; // ST18_4@1
  int v182; // ecx@1
  int v183; // STB8_4@1
  int v184; // esi@1
  int v185; // ebx@1
  int v186; // ST20_4@1
  int v187; // esi@1
  int v188; // ecx@1
  int v189; // STBC_4@1
  int v190; // edi@1
  int v191; // edi@1
  int v192; // ST1C_4@1
  int v193; // ecx@1
  int v194; // ebp@1
  int v195; // STC0_4@1
  int v196; // edx@1
  int v197; // ecx@1
  int v198; // esi@1
  int v199; // STC4_4@1
  int v200; // ebp@1
  int v201; // esi@1
  int v202; // ST10_4@1
  int v203; // ecx@1
  int v204; // ebp@1
  int v205; // edi@1
  int v206; // STC8_4@1
  int v207; // ST1C_4@1
  int v208; // ecx@1
  int v209; // STCC_4@1
  int v210; // ebx@1
  int v211; // ST18_4@1
  int v212; // ecx@1
  int v213; // STD0_4@1
  int v214; // edx@1
  int v215; // edi@1
  int v216; // ebx@1
  int v217; // ecx@1
  int v218; // edx@1
  int v219; // ebx@1
  int v220; // ecx@1
  int v221; // ST1C_4@1
  int v222; // ebp@1
  int v223; // STD4_4@1
  int v224; // ST10_4@1
  int v225; // edx@1
  int v226; // ecx@1
  int v227; // ST14_4@1
  int v228; // STD8_4@1
  int v229; // ebp@1
  int v230; // ebx@1
  int v231; // ecx@1
  int v232; // esi@1
  int v233; // ST10_4@1
  int v234; // ecx@1
  int v235; // STDC_4@1
  int v236; // edi@1
  int v237; // ebx@1
  int v238; // ecx@1
  int v239; // edi@1
  int v240; // STE0_4@1
  int v241; // ebx@1
  int v242; // ST18_4@1
  int v243; // ST1C_4@1
  int v244; // ecx@1
  int v245; // edx@1
  int v246; // STE4_4@1
  int v247; // edi@1
  int v248; // ebx@1
  int v249; // ecx@1
  int v250; // edx@1
  int v251; // ebx@1
  int v252; // ecx@1
  int v253; // ST1C_4@1
  int v254; // ebp@1
  int v255; // STE8_4@1
  int v256; // ST10_4@1
  int v257; // edx@1
  int v258; // ecx@1
  int v259; // ebx@1
  int v260; // ST14_4@1
  int v261; // STEC_4@1
  int v262; // ebp@1
  int v263; // ecx@1
  int v264; // esi@1
  int v265; // ST10_4@1
  int v266; // ecx@1
  int v267; // edi@1
  int v268; // STF0_4@1
  int v269; // ebx@1
  int v270; // edi@1
  int v271; // ecx@1
  int v272; // ebx@1
  int v273; // STF4_4@1
  int v274; // ST1C_4@1
  int v275; // ST18_4@1
  int v276; // ecx@1
  int v277; // edx@1
  int v278; // edi@1
  int v279; // STF8_4@1
  int v280; // ebx@1
  int v281; // ecx@1
  int v282; // edx@1
  int v283; // ST1C_4@1
  int v284; // ecx@1
  int v285; // ST10_4@1
  int v286; // STFC_4@1
  int v287; // ebp@1
  int v288; // edx@1
  int v289; // ecx@1
  int v290; // ST100_4@1
  int v291; // ST14_4@1
  int v292; // ebp@1
  int v293; // ebx@1
  int v294; // ecx@1
  int v295; // esi@1
  int v296; // ST10_4@1
  int v297; // ecx@1
  int v298; // edi@1
  int v299; // ST104_4@1
  int v300; // ebx@1
  int v301; // edi@1
  int v302; // ecx@1
  int v303; // ebx@1
  int v304; // ST108_4@1
  int v305; // ST1C_4@1
  int v306; // ST18_4@1
  int v307; // ecx@1
  int v308; // edi@1
  int v309; // ST10C_4@1
  int v310; // ebx@1
  int v311; // edx@1
  int v312; // ecx@1
  int v313; // ST1C_4@1
  int v314; // ecx@1
  int v315; // ST110_4@1
  int v316; // ebp@1
  int v317; // ebx@1
  int v318; // edx@1
  int v319; // ecx@1
  int v320; // ST114_4@1
  int v321; // ST14_4@1
  int v322; // ebp@1
  int v323; // edi@1
  int v324; // ecx@1
  int v325; // edx@1
  int v326; // ebp@1
  int v327; // ST118_4@1
  int v328; // esi@1
  int v329; // ST10_4@1
  int v330; // ecx@1
  int v331; // ST18_4@1
  int v332; // ST11C_4@1
  int v333; // ebx@1
  int v334; // esi@1
  int v335; // edi@1
  int v336; // edi@1
  int v337; // ST20_4@1
  int v338; // ebx@1
  int v339; // ecx@1
  int v340; // edx@1
  int v341; // ST120_4@1
  int v342; // edx@1
  int v343; // ecx@1
  int v344; // ST124_4@1
  int v345; // ebx@1
  int v346; // ebx@1
  int v347; // ecx@1
  int v348; // ST14_4@1
  int v349; // ST128_4@1
  int v350; // ebp@1
  int v351; // edi@1
  int v352; // edi@1
  int v353; // ecx@1
  int v354; // ST10_4@1
  int v355; // ST12C_4@1
  int v356; // ebp@1
  int v357; // edx@1
  int v358; // ST18_4@1
  int v359; // ecx@1
  int v360; // ST130_4@1
  int v361; // edx@1
  int v362; // esi@1
  int v363; // esi@1
  int v364; // ST20_4@1
  int v365; // ecx@1
  int v366; // ebx@1
  int v367; // edi@1
  int v368; // ST134_4@1
  int v369; // edi@1
  int v370; // ecx@1
  int v371; // ebp@1
  int v372; // ST138_4@1
  int v373; // ebx@1
  int v374; // ebx@1
  int v375; // ecx@1
  int v376; // ST14_4@1
  int v377; // ST13C_4@1
  int v378; // ebp@1
  int v379; // esi@1
  int v380; // esi@1
  int v381; // ecx@1
  int v382; // ST10_4@1
  int v383; // ST140_4@1
  int v384; // ebp@1
  int v385; // edi@1
  int v386; // edi@1
  int v387; // ecx@1
  int v388; // ebp@1
  int v389; // edx@1
  int v390; // ST18_4@1
  int v391; // ebx@1
  int v392; // ST20_4@1
  int v393; // edx@1
  int v394; // ST14_4@1
  int v395; // esi@1
  int v396; // ST148_4@1
  int v397; // ST10_4@1
  int v398; // ST1C_4@1
  int v399; // edx@1
  int v400; // ebx@1
  int v401; // ST14C_4@1
  int v402; // esi@1
  int v403; // ebx@1
  int v404; // ST18_4@1
  int v405; // ST14_4@1
  int v406; // edx@1
  int v407; // edi@1
  int v408; // esi@1
  int v409; // ebx@1
  int v410; // ST20_4@1
  int v411; // esi@1
  int v412; // ST10_4@1
  int v413; // ebx@1
  int v414; // edi@1
  int v415; // ebp@1
  int v416; // edi@1
  int v417; // ST24_4@1
  int v418; // ST1C_4@1
  int v419; // edi@1
  int v420; // ebx@1
  int v421; // ST20_4@1
  int v422; // edx@1
  int v423; // ebx@1
  int v424; // edx@1
  int v425; // ebx@1
  int v426; // ST1C_4@1
  int v427; // esi@1
  int v428; // ebx@1
  int v429; // esi@1
  int v430; // ecx@1
  int v431; // ebx@1
  int v432; // ebx@1
  int v433; // edx@1
  int v434; // ecx@1

  v1 = *(_DWORD *)(result + 8);
  v2 = *(_DWORD *)(result + 12);
  v3 = __ROL4__(*(_DWORD *)(result + 8), 5);
  v4 = ((*(_DWORD *)(result + 28) & 0xFF00 | (*(_DWORD *)(result + 28) << 16)) << 8) | (((*(_DWORD *)(result + 28) >> 16) | *(_DWORD *)(result + 28) & 0xFF0000u) >> 8);
  v5 = v4
     + *(_DWORD *)(result + 24)
     + v3
     + (v2 & *(_DWORD *)(result + 16) ^ *(_DWORD *)(result + 20) & ~*(_DWORD *)(result + 12))
     + 1518500249;
  v2 = __ROR4__(v2, 2);
  v6 = v2;
  v7 = ((*(_DWORD *)(result + 32) & 0xFF00 | (*(_DWORD *)(result + 32) << 16)) << 8) | (((*(_DWORD *)(result + 32) >> 16) | *(_DWORD *)(result + 32) & 0xFF0000u) >> 8);
  v8 = v1 & v2 ^ *(_DWORD *)(result + 16) & ~v1;
  v9 = __ROL4__(v5, 5);
  v10 = *(_DWORD *)(result + 20) + v7 + v9 + v8 + 1518500249;
  v1 = __ROR4__(v1, 2);
  v11 = v10;
  v10 = __ROL4__(v10, 5);
  v12 = v1;
  v13 = ((*(_DWORD *)(result + 36) & 0xFF00 | (*(_DWORD *)(result + 36) << 16)) << 8) | (((*(_DWORD *)(result + 36) >> 16) | *(_DWORD *)(result + 36) & 0xFF0000u) >> 8);
  v14 = *(_DWORD *)(result + 16) + v13 + v10 + (v1 & v5 ^ v6 & ~v5) + 1518500249;
  v5 = __ROR4__(v5, 2);
  v15 = ((*(_DWORD *)(result + 40) & 0xFF00 | (*(_DWORD *)(result + 40) << 16)) << 8) | (((*(_DWORD *)(result + 40) >> 16) | *(_DWORD *)(result + 40) & 0xFF0000u) >> 8);
  v16 = __ROL4__(v14, 5);
  v17 = v6 + v15 + v16 + (v11 & v5 ^ v1 & ~v11) + 1518500249;
  v18 = __ROR4__(v11, 2);
  v19 = v5;
  v20 = __ROL4__(v17, 5);
  v21 = (((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8))
      + v20
      + (v14 & v18 ^ v5 & ~v14);
  v22 = ((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8);
  v14 = __ROR4__(v14, 2);
  v23 = v12 + v21 + 1518500249;
  v24 = v14;
  v25 = ((*(_DWORD *)(result + 48) & 0xFF00 | (*(_DWORD *)(result + 48) << 16)) << 8) | (((*(_DWORD *)(result + 48) >> 16) | *(_DWORD *)(result + 48) & 0xFF0000u) >> 8);
  v26 = __ROL4__(v23, 5);
  v27 = v19 + v25 + v26 + (v17 & v24 ^ v18 & ~v17) + 1518500249;
  v17 = __ROR4__(v17, 2);
  v28 = v17;
  v29 = v23 & v17;
  v30 = ((*(_DWORD *)(result + 52) & 0xFF00 | (*(_DWORD *)(result + 52) << 16)) << 8) | (((*(_DWORD *)(result + 52) >> 16) | *(_DWORD *)(result + 52) & 0xFF0000u) >> 8);
  v31 = __ROL4__(v27, 5);
  v32 = v18 + v30 + v31 + (v29 ^ v24 & ~v23) + 1518500249;
  v23 = __ROR4__(v23, 2);
  v33 = v32;
  v32 = __ROL4__(v32, 5);
  v34 = ((*(_DWORD *)(result + 56) & 0xFF00 | (*(_DWORD *)(result + 56) << 16)) << 8) | (((*(_DWORD *)(result + 56) >> 16) | *(_DWORD *)(result + 56) & 0xFF0000u) >> 8);
  v35 = v24 + v34 + v32 + (v23 & v27 ^ v28 & ~v27) + 1518500249;
  v27 = __ROR4__(v27, 2);
  v36 = v23;
  v37 = v27;
  v38 = ((*(_DWORD *)(result + 60) & 0xFF00 | (*(_DWORD *)(result + 60) << 16)) << 8) | (((*(_DWORD *)(result + 60) >> 16) | *(_DWORD *)(result + 60) & 0xFF0000u) >> 8);
  v39 = __ROL4__(v35, 5);
  v40 = v28 + v38 + v39 + (v33 & v27 ^ v23 & ~v33) + 1518500249;
  v41 = __ROR4__(v33, 2);
  v42 = v35 & v41 ^ v27 & ~v35;
  v43 = ((*(_DWORD *)(result + 64) & 0xFF00 | (*(_DWORD *)(result + 64) << 16)) << 8) | (((*(_DWORD *)(result + 64) >> 16) | *(_DWORD *)(result + 64) & 0xFF0000u) >> 8);
  v44 = __ROL4__(v40, 5);
  v35 = __ROR4__(v35, 2);
  v45 = v36 + v43 + v44 + v42 + 1518500249;
  v46 = v35;
  v47 = __ROL4__(v45, 5);
  v48 = ((*(_DWORD *)(result + 68) & 0xFF00 | (*(_DWORD *)(result + 68) << 16)) << 8) | (((*(_DWORD *)(result + 68) >> 16) | *(_DWORD *)(result + 68) & 0xFF0000u) >> 8);
  v49 = v37 + v48 + v47 + (v40 & v35 ^ v41 & ~v40) + 1518500249;
  v40 = __ROR4__(v40, 2);
  v50 = v40;
  v51 = ((*(_DWORD *)(result + 72) & 0xFF00 | (*(_DWORD *)(result + 72) << 16)) << 8) | (((*(_DWORD *)(result + 72) >> 16) | *(_DWORD *)(result + 72) & 0xFF0000u) >> 8);
  v52 = __ROL4__(v49, 5);
  v53 = v41 + v51 + v52 + (v45 & v40 ^ v46 & ~v45) + 1518500249;
  v54 = v53;
  v45 = __ROR4__(v45, 2);
  v53 = __ROL4__(v53, 5);
  v55 = ((*(_DWORD *)(result + 76) & 0xFF00 | (*(_DWORD *)(result + 76) << 16)) << 8) | (((*(_DWORD *)(result + 76) >> 16) | *(_DWORD *)(result + 76) & 0xFF0000u) >> 8);
  v56 = v46 + v55 + v53 + (v45 & v49 ^ v50 & ~v49) + 1518500249;
  v49 = __ROR4__(v49, 2);
  v57 = v45;
  v58 = __ROL4__(v56, 5);
  v59 = ((*(_DWORD *)(result + 80) & 0xFF00 | (*(_DWORD *)(result + 80) << 16)) << 8) | (((*(_DWORD *)(result + 80) >> 16) | *(_DWORD *)(result + 80) & 0xFF0000u) >> 8);
  v60 = v50 + v59 + v58 + (v54 & v49 ^ v45 & ~v54) + 1518500249;
  v61 = __ROR4__(v54, 2);
  v62 = v61;
  v63 = v49;
  v64 = ((*(_DWORD *)(result + 84) & 0xFF00 | (*(_DWORD *)(result + 84) << 16)) << 8) | (((*(_DWORD *)(result + 84) >> 16) | *(_DWORD *)(result + 84) & 0xFF0000u) >> 8);
  v65 = __ROL4__(v60, 5);
  v66 = v57 + v64 + v65 + (v56 & v61 ^ v49 & ~v56) + 1518500249;
  v56 = __ROR4__(v56, 2);
  v67 = v56;
  v68 = ((*(_DWORD *)(result + 88) & 0xFF00 | (*(_DWORD *)(result + 88) << 16)) << 8) | (((*(_DWORD *)(result + 88) >> 16) | *(_DWORD *)(result + 88) & 0xFF0000u) >> 8);
  v69 = __ROL4__(v66, 5);
  v70 = v63 + v68 + v69 + (v60 & v56 ^ v61 & ~v60) + 1518500249;
  v60 = __ROR4__(v60, 2);
  v71 = v60;
  v72 = v60;
  v73 = __ROL4__(v4 ^ v13 ^ v38 ^ v59, 1);
  v74 = v56 & ~v66;
  v75 = v73;
  v76 = __ROL4__(v70, 5);
  v77 = v62 + v73 + v76 + (v66 & v72 ^ v74) + 1518500249;
  v66 = __ROR4__(v66, 2);
  v78 = v77;
  v79 = v66;
  v80 = __ROL4__(v7 ^ v15 ^ v43 ^ v64, 1);
  v81 = v80;
  v77 = __ROL4__(v77, 5);
  v82 = v67 + v80 + v77 + (v66 & v70 ^ v71 & ~v70) + 1518500249;
  v70 = __ROR4__(v70, 2);
  v83 = __ROL4__(v13 ^ v22 ^ v48 ^ v68, 1);
  v84 = v83;
  v85 = __ROL4__(v82, 5);
  v86 = v70;
  v87 = v71 + v83 + v85 + (v78 & v70 ^ v66 & ~v78) + 1518500249;
  v88 = __ROR4__(v78, 2);
  v89 = v88;
  v90 = __ROL4__(v15 ^ v25 ^ v51 ^ v75, 1);
  v91 = v90;
  v92 = __ROL4__(v87, 5);
  v93 = v79 + v90 + v92 + (v82 & v89 ^ v70 & ~v82) + 1518500249;
  v82 = __ROR4__(v82, 2);
  v94 = v82;
  v95 = __ROL4__(v22 ^ v30 ^ v55 ^ v81, 1);
  v96 = v95;
  v97 = __ROL4__(v93, 5);
  v98 = v86 + v95 + v97 + (v87 ^ v82 ^ v89) + 1859775393;
  v87 = __ROR4__(v87, 2);
  v99 = v87;
  v100 = v87 ^ v82;
  v101 = __ROL4__(v25 ^ v34 ^ v59 ^ v84, 1);
  v102 = __ROL4__(v98, 5);
  v103 = v101;
  v104 = v89 + v101 + v102 + (v93 ^ v100) + 1859775393;
  v93 = __ROR4__(v93, 2);
  v105 = v93;
  v106 = __ROL4__(v30 ^ v38 ^ v64 ^ v91, 1);
  v107 = v106;
  v108 = __ROL4__(v104, 5);
  v109 = v94 + v106 + v108 + (v105 ^ v99 ^ v98) + 1859775393;
  v98 = __ROR4__(v98, 2);
  v110 = __ROL4__(v34 ^ v43 ^ v68 ^ v96, 1);
  v111 = v110;
  v112 = __ROL4__(v109, 5);
  v113 = v99 + v110 + v112 + (v105 ^ v104 ^ v98) + 1859775393;
  v104 = __ROR4__(v104, 2);
  v114 = v104;
  v115 = __ROL4__(v38 ^ v48 ^ v75 ^ v103, 1);
  v116 = v109 ^ v104 ^ v98;
  v117 = v115;
  v118 = __ROL4__(v113, 5);
  v119 = v105 + v115 + v118 + v116 + 1859775393;
  v109 = __ROR4__(v109, 2);
  v120 = v109;
  v121 = v109 ^ v114;
  v122 = __ROL4__(v43 ^ v51 ^ v81 ^ v107, 1);
  v123 = v122;
  v124 = __ROL4__(v119, 5);
  v125 = v122 + v124 + (v113 ^ v121);
  v113 = __ROR4__(v113, 2);
  v126 = v98 + v125 + 1859775393;
  v127 = __ROL4__(v48 ^ v55 ^ v84 ^ v111, 1);
  v128 = v113;
  v129 = v127;
  v130 = __ROL4__(v126, 5);
  v131 = v114 + v127 + v130 + (v119 ^ v113 ^ v120) + 1859775393;
  v119 = __ROR4__(v119, 2);
  v132 = v119;
  v133 = __ROL4__(v51 ^ v59 ^ v91 ^ v117, 1);
  v134 = v133;
  v135 = __ROL4__(v131, 5);
  v136 = v120 + v133 + v135 + (v132 ^ v113 ^ v126) + 1859775393;
  v126 = __ROR4__(v126, 2);
  v137 = __ROL4__(v55 ^ v64 ^ v96 ^ v123, 1);
  v138 = v137;
  v139 = __ROL4__(v136, 5);
  v140 = v128 + v137 + v139 + (v132 ^ v131 ^ v126) + 1859775393;
  v131 = __ROR4__(v131, 2);
  v141 = v131;
  v142 = __ROL4__(v59 ^ v68 ^ v103 ^ v129, 1);
  v143 = v136 ^ v131 ^ v126;
  v144 = v142;
  v145 = __ROL4__(v140, 5);
  v146 = v132 + v142 + v145 + v143 + 1859775393;
  v136 = __ROR4__(v136, 2);
  v147 = v136;
  v148 = v136 ^ v141;
  v149 = __ROL4__(v64 ^ v75 ^ v107 ^ v134, 1);
  v150 = v149;
  v151 = __ROL4__(v146, 5);
  v152 = v149 + v151 + (v140 ^ v148);
  v140 = __ROR4__(v140, 2);
  v153 = v126 + v152 + 1859775393;
  v154 = __ROL4__(v68 ^ v81 ^ v111 ^ v138, 1);
  v155 = v140;
  v156 = v154;
  v157 = __ROL4__(v153, 5);
  v158 = v141 + v154 + v157 + (v146 ^ v140 ^ v147) + 1859775393;
  v146 = __ROR4__(v146, 2);
  v159 = v146;
  v160 = __ROL4__(v75 ^ v84 ^ v117 ^ v144, 1);
  v161 = v160;
  v162 = __ROL4__(v158, 5);
  v163 = v147 + v160 + v162 + (v159 ^ v140 ^ v153) + 1859775393;
  v153 = __ROR4__(v153, 2);
  v164 = __ROL4__(v81 ^ v91 ^ v123 ^ v150, 1);
  v165 = v164;
  v166 = __ROL4__(v163, 5);
  v167 = v155 + v164 + v166 + (v159 ^ v158 ^ v153) + 1859775393;
  v158 = __ROR4__(v158, 2);
  v168 = v158;
  v169 = __ROL4__(v84 ^ v96 ^ v129 ^ v156, 1);
  v170 = v163 ^ v158 ^ v153;
  v171 = v169;
  v172 = __ROL4__(v167, 5);
  v173 = v159 + v169 + v172 + v170 + 1859775393;
  v163 = __ROR4__(v163, 2);
  v174 = v163;
  v175 = v163 ^ v168;
  v176 = __ROL4__(v91 ^ v103 ^ v134 ^ v161, 1);
  v177 = v176;
  v178 = __ROL4__(v173, 5);
  v179 = v176 + v178 + (v167 ^ v175);
  v167 = __ROR4__(v167, 2);
  v180 = v153 + v179 + 1859775393;
  v181 = v167;
  v182 = __ROL4__(v96 ^ v107 ^ v138 ^ v165, 1);
  v183 = v182;
  v184 = __ROL4__(v180, 5);
  v185 = v168 + v182 + v184 + (v173 ^ v167 ^ v174) + 1859775393;
  v173 = __ROR4__(v173, 2);
  v186 = v173;
  v187 = v173;
  v188 = __ROL4__(v103 ^ v111 ^ v144 ^ v171, 1);
  v189 = v188;
  v190 = __ROL4__(v185, 5);
  v191 = v174 + v188 + v190 + (v187 ^ v181 ^ v180) + 1859775393;
  v180 = __ROR4__(v180, 2);
  v192 = v180;
  v193 = __ROL4__(v107 ^ v117 ^ v150 ^ v177, 1);
  v194 = __ROL4__(v191, 5);
  v195 = v193;
  v196 = v181 + v193 + v194 + (v187 ^ v185 ^ v180) + 1859775393;
  v185 = __ROR4__(v185, 2);
  v197 = __ROL4__(v111 ^ v123 ^ v156 ^ v183, 1);
  v198 = __ROL4__(v196, 5);
  v199 = v197;
  v200 = v197 + v198 + (v191 ^ v185 ^ v192);
  v191 = __ROR4__(v191, 2);
  v201 = v186 + v200 + 1859775393;
  v202 = v191;
  v203 = __ROL4__(v117 ^ v129 ^ v161 ^ v189, 1);
  v204 = __ROL4__(v201, 5);
  v205 = v192 + v203 + (v196 & v191 ^ v185 & (v196 ^ v191)) + v204 - 1894007588;
  v206 = v203;
  v207 = v205;
  v196 = __ROR4__(v196, 2);
  v208 = __ROL4__(v123 ^ v134 ^ v165 ^ v195, 1);
  v209 = v208;
  v210 = v185 + v208 + (v201 & v196 ^ v202 & (v201 ^ v196));
  v205 = __ROL4__(v205, 5);
  v201 = __ROR4__(v201, 2);
  v211 = v196;
  v212 = __ROL4__(v129 ^ v138 ^ v171 ^ v199, 1);
  v213 = v212;
  v214 = v202 + v212 + (v201 & v196 ^ v207 & (v201 ^ v196));
  v215 = v210 + v205 - 1894007588;
  v216 = __ROL4__(v215, 5);
  v217 = __ROR4__(v207, 2);
  v218 = v214 + v216 - 1894007588;
  v219 = v217;
  v220 = __ROL4__(v134 ^ v144 ^ v177 ^ v206, 1);
  v221 = v219;
  v222 = v211 + v220 + (v201 & v215 ^ v219 & (v201 ^ v215));
  v223 = v220;
  v224 = v218;
  v218 = __ROL4__(v218, 5);
  v215 = __ROR4__(v215, 2);
  v225 = v218 + v222 - 1894007588;
  v226 = __ROL4__(v138 ^ v150 ^ v183 ^ v209, 1);
  v227 = v215;
  v228 = v226;
  v229 = v226 + (v224 & v215 ^ v219 & (v224 ^ v215));
  v230 = __ROL4__(v225, 5);
  v231 = __ROR4__(v224, 2);
  v232 = v230 + v201 + v229 - 1894007588;
  v233 = v231;
  v234 = __ROL4__(v144 ^ v156 ^ v189 ^ v213, 1);
  v235 = v234;
  v236 = v221 + v234 + (v225 & v233 ^ v215 & (v225 ^ v233));
  v237 = __ROL4__(v232, 5);
  v225 = __ROR4__(v225, 2);
  v238 = __ROL4__(v150 ^ v161 ^ v195 ^ v223, 1);
  v239 = v236 + v237 - 1894007588;
  v240 = v238;
  v241 = v227 + v238 + (v232 & v225 ^ v233 & (v232 ^ v225));
  v242 = v225;
  v243 = v239;
  v239 = __ROL4__(v239, 5);
  v232 = __ROR4__(v232, 2);
  v244 = __ROL4__(v156 ^ v165 ^ v199 ^ v228, 1);
  v245 = v233 + v244 + (v232 & v225 ^ v243 & (v232 ^ v225));
  v246 = v244;
  v247 = v241 + v239 - 1894007588;
  v248 = __ROL4__(v247, 5);
  v249 = __ROR4__(v243, 2);
  v250 = v245 + v248 - 1894007588;
  v251 = v249;
  v252 = __ROL4__(v161 ^ v171 ^ v206 ^ v235, 1);
  v253 = v251;
  v254 = v242 + v252 + (v232 & v247 ^ v251 & (v232 ^ v247));
  v255 = v252;
  v256 = v250;
  v250 = __ROL4__(v250, 5);
  v247 = __ROR4__(v247, 2);
  v257 = v250 + v254 - 1894007588;
  v258 = __ROL4__(v165 ^ v177 ^ v209 ^ v240, 1);
  v259 = __ROL4__(v257, 5);
  v260 = v247;
  v261 = v258;
  v262 = v258 + (v256 & v247 ^ v253 & (v256 ^ v247));
  v263 = __ROR4__(v256, 2);
  v264 = v259 + v232 + v262 - 1894007588;
  v265 = v263;
  v266 = __ROL4__(v171 ^ v183 ^ v213 ^ v246, 1);
  v267 = v253 + v266 + (v257 & v265 ^ v247 & (v257 ^ v265));
  v268 = v266;
  v269 = __ROL4__(v264, 5);
  v257 = __ROR4__(v257, 2);
  v270 = v267 + v269 - 1894007588;
  v271 = __ROL4__(v177 ^ v189 ^ v223 ^ v255, 1);
  v272 = v260 + v271 + (v264 & v257 ^ v265 & (v264 ^ v257));
  v273 = v271;
  v274 = v270;
  v270 = __ROL4__(v270, 5);
  v264 = __ROR4__(v264, 2);
  v275 = v257;
  v276 = __ROL4__(v183 ^ v195 ^ v228 ^ v261, 1);
  v277 = v265 + v276 + (v264 & v257 ^ v274 & (v264 ^ v257));
  v278 = v272 + v270 - 1894007588;
  v279 = v276;
  v280 = __ROL4__(v278, 5);
  v281 = __ROR4__(v274, 2);
  v282 = v277 + v280 - 1894007588;
  v283 = v281;
  v284 = __ROL4__(v189 ^ v199 ^ v235 ^ v268, 1);
  v285 = v282;
  v282 = __ROL4__(v282, 5);
  v286 = v284;
  v287 = v275 + v284 + (v264 & v278 ^ v283 & (v264 ^ v278));
  v278 = __ROR4__(v278, 2);
  v288 = v282 + v287 - 1894007588;
  v289 = __ROL4__(v195 ^ v206 ^ v240 ^ v273, 1);
  v290 = v289;
  v291 = v278;
  v292 = v289 + (v285 & v278 ^ v283 & (v285 ^ v278));
  v293 = __ROL4__(v288, 5);
  v294 = __ROR4__(v285, 2);
  v295 = v293 + v264 + v292 - 1894007588;
  v296 = v294;
  v297 = __ROL4__(v199 ^ v209 ^ v246 ^ v279, 1);
  v298 = v283 + v297 + (v288 & v296 ^ v278 & (v288 ^ v296));
  v299 = v297;
  v300 = __ROL4__(v295, 5);
  v288 = __ROR4__(v288, 2);
  v301 = v298 + v300 - 1894007588;
  v302 = __ROL4__(v206 ^ v213 ^ v255 ^ v286, 1);
  v303 = v291 + v302 + (v295 & v288 ^ v296 & (v295 ^ v288));
  v304 = v302;
  v305 = v301;
  v306 = v288;
  v301 = __ROL4__(v301, 5);
  v295 = __ROR4__(v295, 2);
  v307 = __ROL4__(v209 ^ v223 ^ v261 ^ v290, 1);
  v308 = v303 + v301 - 1894007588;
  v309 = v307;
  v310 = __ROL4__(v308, 5);
  v311 = v296 + v307 + (v295 & v288 ^ v305 & (v295 ^ v288)) + v310 - 1894007588;
  v312 = __ROR4__(v305, 2);
  v313 = v312;
  v314 = __ROL4__(v213 ^ v228 ^ v268 ^ v299, 1);
  v315 = v314;
  v316 = v306 + v314 + (v295 & v308 ^ v313 & (v295 ^ v308));
  v317 = v311;
  v311 = __ROL4__(v311, 5);
  v308 = __ROR4__(v308, 2);
  v318 = v311 + v316 - 1894007588;
  v319 = __ROL4__(v223 ^ v235 ^ v273 ^ v304, 1);
  v320 = v319;
  v321 = v308;
  v322 = v319 + (v317 & v308 ^ v313 & (v317 ^ v308));
  v323 = v318;
  v318 = __ROL4__(v318, 5);
  v317 = __ROR4__(v317, 2);
  v324 = __ROL4__(v228 ^ v240 ^ v279 ^ v309, 1);
  v325 = v318 + v295 + v322 - 1894007588;
  v326 = v313 + v324 + (v323 ^ v317 ^ v321);
  v327 = v324;
  v328 = __ROL4__(v325, 5);
  v323 = __ROR4__(v323, 2);
  v329 = v317;
  v330 = __ROL4__(v235 ^ v246 ^ v286 ^ v315, 1);
  v331 = v323;
  v332 = v330;
  v333 = v321 + v330 + (v325 ^ v323 ^ v317);
  v334 = v328 + v326 - 899497514;
  v335 = __ROL4__(v334, 5);
  v336 = v333 + v335 - 899497514;
  v325 = __ROR4__(v325, 2);
  v337 = v325;
  v338 = v325 ^ v331 ^ v334;
  v339 = __ROL4__(v240 ^ v255 ^ v290 ^ v320, 1);
  v340 = __ROL4__(v336, 5);
  v341 = v339;
  v334 = __ROR4__(v334, 2);
  v342 = v329 + v339 + v338 + v340 - 899497514;
  v343 = __ROL4__(v246 ^ v261 ^ v299 ^ v327, 1);
  v344 = v343;
  v345 = __ROL4__(v342, 5);
  v346 = v345 + v331 + v343 + (v337 ^ v336 ^ v334) - 899497514;
  v336 = __ROR4__(v336, 2);
  v347 = __ROL4__(v255 ^ v268 ^ v304 ^ v332, 1);
  v348 = v336;
  v349 = v347;
  v350 = v337 + v347 + (v342 ^ v336 ^ v334);
  v351 = __ROL4__(v346, 5);
  v342 = __ROR4__(v342, 2);
  v352 = v351 + v350 - 899497514;
  v353 = __ROL4__(v261 ^ v273 ^ v309 ^ v341, 1);
  v354 = v342;
  v355 = v353;
  v356 = v353 + (v346 ^ v342 ^ v348);
  v357 = __ROL4__(v352, 5);
  v346 = __ROR4__(v346, 2);
  v358 = v346;
  v359 = __ROL4__(v268 ^ v279 ^ v315 ^ v344, 1);
  v360 = v359;
  v361 = v357 + v334 + v356 - 899497514;
  v362 = __ROL4__(v361, 5);
  v363 = v348 + v359 + (v352 ^ v346 ^ v354) + v362 - 899497514;
  v352 = __ROR4__(v352, 2);
  v364 = v352;
  v365 = __ROL4__(v273 ^ v286 ^ v320 ^ v349, 1);
  v366 = v352 ^ v346 ^ v361;
  v367 = __ROL4__(v363, 5);
  v368 = v365;
  v369 = v354 + v365 + v366 + v367 - 899497514;
  v361 = __ROR4__(v361, 2);
  v370 = __ROL4__(v279 ^ v290 ^ v327 ^ v355, 1);
  v371 = v358 + v370 + (v364 ^ v363 ^ v361);
  v372 = v370;
  v373 = __ROL4__(v369, 5);
  v363 = __ROR4__(v363, 2);
  v374 = v373 + v371 - 899497514;
  v375 = __ROL4__(v286 ^ v299 ^ v332 ^ v360, 1);
  v376 = v363;
  v377 = v375;
  v378 = v364 + v375 + (v369 ^ v363 ^ v361);
  v379 = __ROL4__(v374, 5);
  v380 = v379 + v378 - 899497514;
  v369 = __ROR4__(v369, 2);
  v381 = __ROL4__(v290 ^ v304 ^ v341 ^ v368, 1);
  v382 = v369;
  v383 = v381;
  v384 = v381 + (v374 ^ v369 ^ v376);
  v385 = __ROL4__(v380, 5);
  v386 = v385 + v361 + v384 - 899497514;
  v374 = __ROR4__(v374, 2);
  v387 = __ROL4__(v299 ^ v309 ^ v344 ^ v372, 1);
  v388 = v376 + v387 + (v380 ^ v374 ^ v382);
  v389 = __ROL4__(v386, 5);
  v380 = __ROR4__(v380, 2);
  v390 = v374;
  v391 = v389 + v388 - 899497514;
  v392 = v380;
  v393 = __ROL4__(v304 ^ v315 ^ v349 ^ v377, 1);
  v394 = v391;
  v391 = __ROL4__(v391, 5);
  v395 = v382 + v393 + (v380 ^ v390 ^ v386) + v391 - 899497514;
  v386 = __ROR4__(v386, 2);
  v396 = v393;
  v397 = v395;
  v398 = v386;
  v399 = __ROL4__(v309 ^ v320 ^ v355 ^ v383, 1);
  v400 = __ROL4__(v395, 5);
  v401 = v399;
  v402 = __ROR4__(v394, 2);
  v403 = v400 + v390 + v399 + (v392 ^ v394 ^ v386) - 899497514;
  v404 = v403;
  v405 = v402;
  v406 = __ROL4__(v315 ^ v327 ^ v360 ^ v387, 1);
  v403 = __ROL4__(v403, 5);
  v407 = v392 + v406 + (v397 ^ v402 ^ v386) + v403 - 899497514;
  v408 = __ROR4__(v397, 2);
  v409 = v408;
  v410 = v407;
  v411 = __ROL4__(v320 ^ v332 ^ v368 ^ v396, 1);
  v407 = __ROL4__(v407, 5);
  v412 = v409;
  v413 = v407 + v398 + v411 + (v404 ^ v409 ^ v405) - 899497514;
  v414 = __ROR4__(v404, 2);
  v415 = v414;
  v416 = __ROL4__(v327 ^ v341 ^ v372 ^ v401, 1);
  v417 = v416;
  v418 = v413;
  v413 = __ROL4__(v413, 5);
  v419 = v405 + v416 + (v410 ^ v415 ^ v412) + v413 - 899497514;
  v420 = __ROR4__(v410, 2);
  v421 = v420;
  v422 = __ROL4__(v332 ^ v344 ^ v377 ^ v406, 1);
  v423 = __ROL4__(v419, 5);
  v424 = v412 + (v421 ^ v415 ^ v418) + v423 + v422 - 899497514;
  v425 = __ROR4__(v418, 2);
  v426 = v425;
  v427 = __ROL4__(v341 ^ v349 ^ v383 ^ v411, 1);
  v428 = __ROL4__(v424, 5);
  v429 = v415 + (v421 ^ v419 ^ v426) + v428 + v427 - 899497514;
  v419 = __ROR4__(v419, 2);
  v430 = __ROL4__(v417 ^ v344 ^ v355 ^ v387, 1);
  v431 = __ROL4__(v429, 5);
  v432 = v421 + (v424 ^ v419 ^ v426) + v431 + v430 - 899497514 + *(_DWORD *)(result + 8);
  *(_DWORD *)(result + 12) += v429;
  v424 = __ROR4__(v424, 2);
  v433 = *(_DWORD *)(result + 16) + v424;
  *(_DWORD *)(result + 20) += v419;
  v434 = *(_DWORD *)(result + 24);
  *(_DWORD *)(result + 8) = v432;
  *(_DWORD *)(result + 16) = v433;
  *(_DWORD *)(result + 24) = v426 + v434;
  return result;
}

//----- (1004FDD0) --------------------------------------------------------
unsigned int __usercall sub_1004FDD0@<eax>(int a1@<esi>, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@4
  unsigned int v5; // eax@7
  unsigned int result; // eax@7
  int v7; // edx@8

  v2 = *(_DWORD *)a1 & 0x3F;
  v3 = v2 >> 2;
  *(_DWORD *)(a1 + 4 * v3 + 28) = dword_100EB748[*(_BYTE *)a1 & 3] | *(_DWORD *)(a1 + 4 * v3 + 28) & dword_100EB758[*(_BYTE *)a1 & 3];
  if ( v2 > 0x37 )
  {
    if ( v2 < 0x3C )
      *(_DWORD *)(a1 + 88) = 0;
    sub_1004E6B0(a1);
    v4 = 0;
    goto LABEL_6;
  }
  v4 = v3 + 1;
  if ( v3 + 1 < 0xE )
LABEL_6:
    memset((void *)(a1 + 4 * v4 + 28), 0, 4 * (14 - v4));
  v5 = 8 * *(_DWORD *)a1;
  *(_DWORD *)(a1 + 84) = ((((unsigned int)(*(_QWORD *)a1 >> 29) << 16) | (*(_QWORD *)a1 >> 29) & 0xFF00) << 8) | ((((unsigned int)(*(_QWORD *)a1 >> 29) >> 16) | (*(_QWORD *)a1 >> 29) & 0xFF0000) >> 8);
  *(_DWORD *)(a1 + 88) = (((v5 << 16) | v5 & 0xFF00) << 8) | (((v5 >> 16) | v5 & 0xFF0000) >> 8);
  sub_1004E6B0(a1);
  result = 0;
  do
  {
    v7 = *(_DWORD *)(a1 + 4 * (result >> 2) + 8) >> 8 * (~(_BYTE)result & 3);
    *(_BYTE *)(++result + a2 - 1) = v7;
  }
  while ( result < 0x14 );
  return result;
}
// 100EB748: using guessed type int dword_100EB748[];
// 100EB758: using guessed type int dword_100EB758[];

//----- (1004FED0) --------------------------------------------------------
void *__usercall sub_1004FED0@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3)
{
  int v3; // ebp@1
  size_t v4; // ebx@1
  int v5; // edi@1
  unsigned int v6; // eax@1
  size_t v7; // esi@1
  char *v9; // [sp+14h] [bp+4h]@1

  v3 = (int)a3;
  v4 = a1;
  v5 = *a3 & 0x3F;
  v6 = a1 + *a3;
  v7 = 64 - v5;
  v9 = a2;
  *(_DWORD *)v3 = v6;
  if ( v6 < v4 )
    ++*(_DWORD *)(v3 + 4);
  if ( v4 >= v7 )
  {
    do
    {
      memcpy_0((void *)(v5 + v3 + 28), v9, v7);
      v9 += v7;
      v4 -= v7;
      v7 = 64;
      v5 = 0;
      sub_1004E6B0(v3);
    }
    while ( v4 >= 0x40 );
  }
  return memcpy_0((void *)(v5 + v3 + 28), v9, v4);
}

//----- (1004FF50) --------------------------------------------------------
void *__usercall sub_1004FF50@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3)
{
  int v3; // edi@1
  void *result; // eax@1
  unsigned int v5; // eax@4
  _DWORD *v6; // eax@6

  v3 = a1;
  result = *(void **)(a1 + 156);
  if ( result != (void *)-1 )
  {
    if ( (unsigned int)result > 0x40 )
    {
      sub_1004FDD0(v3 + 64, v3);
      *(_DWORD *)(v3 + 156) = 20;
    }
    memset((void *)(v3 + *(_DWORD *)(v3 + 156)), 0, 64 - *(_DWORD *)(v3 + 156));
    v5 = 0;
    do
      *(_DWORD *)(v3 + 4 * v5++) ^= 0x36363636u;
    while ( v5 < 0x10 );
    v6 = (_DWORD *)sub_1004E670(v3 + 64);
    result = sub_1004FED0(0x40u, (char *)v3, v6);
    *(_DWORD *)(v3 + 156) = -1;
  }
  if ( a2 )
    result = sub_1004FED0(a2, a3, (_DWORD *)(v3 + 64));
  return result;
}

//----- (1004FFF0) --------------------------------------------------------
int __usercall sub_1004FFF0@<eax>(int a1@<edi>, int a2, size_t a3)
{
  unsigned int v3; // eax@3
  int result; // eax@5
  char v5; // [sp+8h] [bp-18h]@3

  if ( *(_DWORD *)(a1 + 156) != -1 )
    sub_1004FF50(a1, 0, 0);
  sub_1004FDD0(a1 + 64, (int)&v5);
  v3 = 0;
  do
    *(_DWORD *)(a1 + 4 * v3++) ^= 0x6A6A6A6Au;
  while ( v3 < 0x10 );
  sub_1004E670(a1 + 64);
  sub_1004FED0(0x40u, (char *)a1, (_DWORD *)(a1 + 64));
  sub_1004FED0(0x14u, &v5, (_DWORD *)(a1 + 64));
  result = sub_1004FDD0(a1 + 64, (int)&v5);
  if ( a3 )
    result = (int)memcpy_0((void *)a2, &v5, a3);
  return result;
}

//----- (100500B0) --------------------------------------------------------
int __usercall sub_100500B0@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3)
{
  int v3; // eax@1
  int result; // eax@2

  v3 = *(_DWORD *)(a2 + 156);
  if ( v3 + a1 <= 0x40 )
  {
    memcpy_0((void *)(a2 + v3), a3, a1);
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  else
  {
    sub_1004E670(a2 + 64);
    sub_1004FED0(*(_DWORD *)(a2 + 156), (char *)a2, (_DWORD *)(a2 + 64));
    sub_1004FED0(a1, (char *)a3, (_DWORD *)(a2 + 64));
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  return result;
}

//----- (10050110) --------------------------------------------------------
int __usercall sub_10050110@<eax>(char *a1@<edi>)
{
  unsigned int v1; // ebp@1
  signed int v2; // eax@2
  int v3; // edx@4
  int v4; // ecx@4
  int v5; // edx@4
  unsigned int v6; // esi@4
  size_t v7; // eax@4
  int v8; // ebx@6
  int v9; // edx@8
  int result; // eax@8
  int v11; // ecx@8
  int v12; // edx@8
  char v13; // [sp+Ch] [bp-5Ch]@8
  int v14; // [sp+14h] [bp-54h]@4
  int v15; // [sp+18h] [bp-50h]@4
  int v16; // [sp+1Ch] [bp-4Ch]@4
  int v17; // [sp+20h] [bp-48h]@4
  int v18; // [sp+24h] [bp-44h]@4
  char v19[64]; // [sp+28h] [bp-40h]@6

  v1 = 0;
  do
  {
    v2 = v1;
    if ( !v1 )
      v2 = 260;
    v3 = *(_DWORD *)&a1[v2 - 16];
    v14 = *(_DWORD *)&a1[v2 - 20];
    v4 = *(_DWORD *)&a1[v2 - 12];
    v15 = v3;
    v5 = *(_DWORD *)&a1[v2 - 8];
    v6 = 260 - v1;
    v18 = *(_DWORD *)&a1[v2 - 4];
    v16 = v4;
    v17 = v5;
    v7 = 64;
    if ( 260 - v1 <= 0x40 )
      v7 = 260 - v1;
    v8 = (int)&a1[v1];
    memcpy_0(v19, &a1[v1], v7);
    if ( v6 < 0x40 )
      memcpy_0(&v19[v6], a1, 64 - v6);
    sub_1004E6B0((int)&v13);
    v9 = v15;
    result = v16;
    *(_DWORD *)v8 = v14;
    v11 = v17;
    *(_DWORD *)(v8 + 4) = v9;
    v12 = v18;
    *(_DWORD *)(v8 + 8) = result;
    v1 += 20;
    *(_DWORD *)(v8 + 12) = v11;
    *(_DWORD *)(v8 + 16) = v12;
  }
  while ( v1 < 0x104 );
  return result;
}
// 10050110: using guessed type char var_40[64];

//----- (100501D0) --------------------------------------------------------
int __usercall sub_100501D0@<eax>(int a1@<ebx>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // eax@3
  char v3; // cl@4
  char v4; // dl@4
  char v5; // cl@4
  char v6; // dl@4
  char *v8; // [sp+Ch] [bp-4h]@1

  v8 = (char *)(a1 + 260);
  v1 = 0;
  qmemcpy((void *)(a1 + 260), (const void *)a1, 0x104u);
  do
    v1 += (*(int (__cdecl **)(unsigned int, unsigned int))(a1 + 524))(a1 + v1, 260 - v1);
  while ( v1 < 0x104 );
  v2 = 0;
  do
  {
    v3 = *(_BYTE *)(v2 + a1 + 261);
    *(_BYTE *)(v2 + a1) ^= ~v8[v2];
    v4 = *(_BYTE *)(v2 + a1 + 262);
    *(_BYTE *)(v2 + a1 + 1) ^= ~v3;
    v5 = *(_BYTE *)(v2 + a1 + 263);
    *(_BYTE *)(v2 + a1 + 2) ^= ~v4;
    v6 = *(_BYTE *)(v2 + a1 + 264);
    *(_BYTE *)(v2 + a1 + 3) ^= ~v5;
    *(_BYTE *)(v2 + a1 + 4) ^= ~v6;
    v2 += 5;
  }
  while ( v2 < 0x104 );
  sub_10050110((char *)a1);
  return sub_10050110(v8);
}

//----- (10050290) --------------------------------------------------------
char __cdecl sub_10050290(char *a1, size_t a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_1004FF50(a3 + 296, a2, a1);
    sub_1004D810(a3, (int)a1, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100502E0) --------------------------------------------------------
char __cdecl sub_100502E0(char *a1, unsigned int a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_1004D810(a3, (int)a1, a2);
    sub_1004FF50(a3 + 296, a2, a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10050330) --------------------------------------------------------
bool __cdecl sub_10050330(int a1, int a2)
{
  if ( a2 )
    sub_1004FFF0(a2 + 296, a1, 0xAu);
  return a2 != 0;
}

//----- (10050360) --------------------------------------------------------
int __usercall sub_10050360@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7)
{
  void *v7; // esi@1
  char *v8; // ebx@1
  int result; // eax@1
  unsigned int v10; // edx@1
  unsigned int v11; // ebx@2
  size_t v12; // edx@3
  char v13; // al@6
  char v14; // al@6
  bool v15; // zf@7
  unsigned int v16; // eax@9
  unsigned int v17; // ecx@9
  int *v18; // [sp+10h] [bp-228h]@2
  unsigned int v19; // [sp+14h] [bp-224h]@2
  int v20; // [sp+18h] [bp-220h]@4
  signed int v21; // [sp+1Ch] [bp-21Ch]@2
  unsigned int v22; // [sp+20h] [bp-218h]@1
  char v23; // [sp+28h] [bp-210h]@3
  char v24; // [sp+C8h] [bp-170h]@1
  char v25; // [sp+168h] [bp-D0h]@1
  int v26; // [sp+20Ch] [bp-2Ch]@2
  int v27; // [sp+210h] [bp-28h]@3
  int v28; // [sp+214h] [bp-24h]@3
  int v29; // [sp+218h] [bp-20h]@3
  int v30; // [sp+21Ch] [bp-1Ch]@3
  int v31; // [sp+220h] [bp-18h]@3
  char v32[16]; // [sp+224h] [bp-14h]@6

  v7 = a2;
  v8 = a1;
  sub_1004E5F0(&v24);
  sub_100500B0(a3, (int)&v24, v7);
  qmemcpy(&v25, &v24, 0xA0u);
  sub_1004FF50((int)&v25, a4, v8);
  result = -858993459 * (a7 - 1);
  v10 = (a7 - 1) / 0x14;
  v22 = v10 + 1;
  if ( v10 != -1 )
  {
    v11 = 1;
    v19 = 0;
    v21 = 1;
    v18 = &v26;
    do
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      qmemcpy(&v23, &v25, 0xA0u);
      LOBYTE(v31) = BYTE3(v11);
      BYTE2(v31) = BYTE1(v11);
      BYTE1(v31) = v11 >> 16;
      BYTE3(v31) = v11;
      v12 = 4;
      if ( a5 )
      {
        v20 = a5;
        do
        {
          sub_1004FF50((int)&v23, v12, (char *)&v31);
          sub_1004FFF0((int)&v23, (int)&v31, 0x14u);
          v12 = 0;
          do
          {
            *((_BYTE *)&v26 + v12) ^= *((_BYTE *)&v31 + v12);
            v13 = *((_BYTE *)&v31 + v12 + 2);
            *((_BYTE *)&v26 + v12 + 1) ^= *((_BYTE *)&v31 + v12 + 1);
            *((_BYTE *)&v26 + v12 + 2) ^= v13;
            v14 = v32[v12];
            *((_BYTE *)&v26 + v12 + 3) ^= *((_BYTE *)&v31 + v12 + 3);
            *((_BYTE *)&v27 + v12) ^= v14;
            v12 += 5;
          }
          while ( v12 < 0x14 );
          v15 = v20-- == 1;
          qmemcpy(&v23, &v24, 0xA0u);
        }
        while ( !v15 );
        v11 = v21;
      }
      v16 = v19;
      v17 = 0;
      do
      {
        if ( v16 >= a7 )
          break;
        *(_BYTE *)(v16 + a6) = *((_BYTE *)v18 + v16);
        ++v17;
        ++v16;
      }
      while ( v17 < 0x14 );
      v19 += 20;
      v18 -= 5;
      result = ++v11 - 1;
      v21 = v11;
    }
    while ( v11 - 1 < v22 );
  }
  return result;
}
// 10050360: using guessed type char var_14[16];

//----- (10050570) --------------------------------------------------------
int __usercall sub_10050570@<eax>(void *a1@<eax>, int a2)
{
  int v2; // ebx@1
  signed int v3; // esi@1

  v2 = (int)a1;
  memset(a1, 0, 0x210u);
  *(_DWORD *)(v2 + 524) = a2;
  sub_100501D0(v2);
  v3 = 20;
  do
  {
    sub_10050110((char *)v2);
    --v3;
  }
  while ( v3 );
  return sub_100501D0(v2);
}

//----- (100505C0) --------------------------------------------------------
char *__cdecl sub_100505C0(int a1, int a2)
{
  void *v2; // ecx@0
  char *result; // eax@1
  unsigned int v4; // ebp@1
  int v5; // edi@1
  char *v6; // ebx@1
  size_t v7; // esi@4

  result = (char *)a2;
  v4 = a1;
  v5 = *(_DWORD *)(a2 + 520);
  v6 = (char *)v2;
  if ( a1 )
  {
    while ( 1 )
    {
      v7 = 260 - v5;
      if ( v4 < 260 - v5 )
        v7 = v4;
      result = (char *)memcpy_0(v6, &result[v5 + 260], v7);
      v6 += v7;
      v5 += v7;
      v4 -= v7;
      if ( v5 == 260 )
      {
        result = (char *)sub_100501D0(a2);
        v5 = 0;
      }
      if ( !v4 )
        break;
      result = (char *)a2;
    }
    *(_DWORD *)(a2 + 520) = v5;
  }
  else
  {
    *(_DWORD *)(a2 + 520) = v5;
  }
  return result;
}

//----- (10050650) --------------------------------------------------------
signed int __cdecl sub_10050650(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6)
{
  signed int result; // eax@2
  int v7; // ebx@6
  char v8; // [sp+Ch] [bp-48h]@6
  char v9[8]; // [sp+14h] [bp-40h]@6
  __int16 v10[26]; // [sp+1Ch] [bp-38h]@6

  if ( a3 <= 0x80 )
  {
    if ( (unsigned __int8)(a1 - 1) > 2u )
    {
      result = -101;
    }
    else if ( a6 )
    {
      *(_BYTE *)(a6 + 464) = a1;
      v7 = a1 & 3;
      *(_DWORD *)(a6 + 460) = a3;
      sub_10050360(a4, a2, a3, 4 * v7 + 4, 1000, (int)&v8, 16 * v7 + 18);
      *(_DWORD *)(a6 + 456) = 16;
      *(_DWORD *)a6 = 0;
      *(_DWORD *)(a6 + 4) = 0;
      *(_DWORD *)(a6 + 8) = 0;
      *(_DWORD *)(a6 + 12) = 0;
      sub_1004D870(a6 + 32, (int)&v8, 8 * v7 + 8);
      sub_1004E5F0((void *)(a6 + 296));
      sub_100500B0(8 * v7 + 8, a6 + 296, &v9[8 * v7]);
      *a5 = v10[8 * v7];
      result = 0;
    }
    else
    {
      result = -102;
    }
  }
  else
  {
    result = -100;
  }
  return result;
}
// 10050650: using guessed type char var_40[8];
// 10050650: using guessed type __int16 var_38[26];

//----- (10050780) --------------------------------------------------------
bool __cdecl sub_10050780(void *a1, int a2)
{
  bool v2; // bl@3
  int v4; // [sp+Ch] [bp-214h]@5

  v2 = a1 && a2;
  sub_10050570(&v4, (int)sub_1004E610);
  if ( v2 )
    sub_100505C0(a2, (int)&v4);
  return v2;
}

//----- (10050800) --------------------------------------------------------
BOOL __usercall sub_10050800@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // ecx@3
  int v4; // ecx@4

  *(_WORD *)(*(_DWORD *)(a1 + 5712) + 2 * *(_DWORD *)(a1 + 5728)) = a3;
  *(_BYTE *)(*(_DWORD *)(a1 + 5716) + (*(_DWORD *)(a1 + 5728))++) = a2;
  if ( a3 )
  {
    ++*(_DWORD *)(a1 + 2920);
    ++*(_WORD *)(a1 + 4 * (unsigned __int8)byte_100EBF60[a2] + 3964);
    v3 = a3 - 1;
    if ( v3 >= 0x100 )
      v4 = (unsigned __int8)byte_100EBE60[v3 >> 7];
    else
      v4 = (unsigned __int8)byte_100EBD60[v3];
    ++*(_WORD *)(a1 + 4 * v4 + 5228);
  }
  else
  {
    ++*(_WORD *)(a1 + 4 * a2 + 2936);
  }
  return *(_DWORD *)(a1 + 5728) == *(_DWORD *)(a1 + 5724) - 1;
}

//----- (100508A0) --------------------------------------------------------
int __usercall sub_100508A0@<eax>(int result@<eax>)
{
  signed int v1; // ecx@1
  __int16 v2; // cx@4

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)((*(_DWORD *)(result + 5812))++ + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
    *(_DWORD *)(result + 2932) = 0;
    *(_WORD *)(result + 2924) = 0;
  }
  else if ( v1 >= 8 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) -= 8;
    *(_WORD *)(result + 2924) = v2;
  }
  return result;
}

//----- (10050930) --------------------------------------------------------
unsigned int __fastcall sub_10050930(unsigned int a1, int a2)
{
  unsigned int v2; // eax@1
  int v3; // esi@2

  v2 = 0;
  do
  {
    v3 = a1 & 1;
    --a2;
    a1 >>= 1;
    v2 = 2 * (v3 | v2);
  }
  while ( a2 > 0 );
  return v2 >> 1;
}

//----- (10050950) --------------------------------------------------------
int __usercall sub_10050950@<eax>(int result@<eax>)
{
  signed int v1; // edx@1
  char v2; // bl@2
  int v3; // edx@2

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 <= 8 )
  {
    if ( v1 > 0 )
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    v3 = *(_DWORD *)(result + 5800);
    *(_BYTE *)(++*(_DWORD *)(result + 5812) + v3) = v2;
    ++*(_DWORD *)(result + 5812);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  return result;
}

//----- (100509E0) --------------------------------------------------------
int __usercall sub_100509E0@<eax>(int result@<eax>, int a2, int a3)
{
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // ebp@2
  int v6; // esi@2
  int v7; // ecx@2
  int v8; // edi@3
  int v9; // esi@4
  int v10; // edx@4
  int v11; // ecx@4
  int v12; // edx@4
  int v13; // ecx@4
  int v14; // edx@6
  int v15; // edi@7
  int v16; // edx@7
  int v17; // ecx@7
  int v18; // edx@7
  int v19; // edi@9
  int v20; // esi@10
  int v21; // ecx@10
  int v22; // edx@11
  int v23; // ecx@11
  int v24; // edx@11
  int v25; // ecx@11
  unsigned int v26; // ebp@14
  int v27; // edi@15
  int v28; // edx@17
  int v29; // ecx@17
  unsigned __int16 v30; // si@18
  int v31; // edx@18
  int v32; // ecx@18
  int v33; // edx@18
  int v34; // esi@20
  int v35; // ecx@21
  int v36; // ebp@21
  int v37; // edx@22
  int v38; // ecx@22
  int v39; // edx@22
  int v40; // edi@26
  int v41; // ecx@26
  unsigned __int16 v42; // si@27
  int v43; // edx@27
  int v44; // ecx@27
  int v45; // edx@27
  int v46; // [sp+10h] [bp-Ch]@6
  int v47; // [sp+14h] [bp-8h]@6
  int v48; // [sp+14h] [bp-8h]@17
  unsigned int v49; // [sp+18h] [bp-4h]@2

  v3 = a2;
  v4 = 0;
  if ( *(_DWORD *)(result + 5728) )
  {
    do
    {
      v5 = *(_WORD *)(*(_DWORD *)(result + 5712) + 2 * v4);
      v6 = *(_BYTE *)(v4 + *(_DWORD *)(result + 5716));
      v49 = v4 + 1;
      v7 = *(_DWORD *)(result + 2932);
      if ( v5 )
      {
        v14 = (unsigned __int8)byte_100EBF60[v6];
        v46 = *(_WORD *)(v3 + 4 * v14 + 1030);
        v47 = (unsigned __int8)byte_100EBF60[v6];
        if ( v7 <= 16 - v46 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a2 + 4 * v14 + 1028) << v7;
          *(_DWORD *)(result + 2932) = v46 + v7;
        }
        else
        {
          v15 = *(_WORD *)(a2 + 4 * v14 + 1028);
          v16 = v15 << v7;
          v17 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v16;
          *(_BYTE *)(v17 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v18 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          LOWORD(v15) = (unsigned __int16)v15 >> (16 - v18);
          *(_DWORD *)(result + 2932) = v18 + v46 - 16;
          v14 = v47;
          *(_WORD *)(result + 2924) = v15;
        }
        v19 = dword_100EB768[v14];
        v3 = a2;
        if ( v19 )
        {
          v20 = v6 - dword_100EC060[v14];
          v21 = *(_DWORD *)(result + 2932);
          if ( v21 <= 16 - v19 )
          {
            *(_WORD *)(result + 2924) |= v20 << v21;
            v25 = v19 + v21;
          }
          else
          {
            v22 = v20 << v21;
            v23 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v22;
            *(_BYTE *)(v23 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v24 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v3 = a2;
            v25 = v24 + v19 - 16;
            *(_WORD *)(result + 2924) = (unsigned __int16)v20 >> (16 - v24);
          }
          *(_DWORD *)(result + 2932) = v25;
        }
        v26 = v5 - 1;
        if ( v26 >= 0x100 )
          v27 = (unsigned __int8)byte_100EBE60[v26 >> 7];
        else
          v27 = (unsigned __int8)byte_100EBD60[v26];
        v28 = *(_WORD *)(a3 + 4 * v27 + 2);
        v29 = *(_DWORD *)(result + 2932);
        v48 = *(_WORD *)(a3 + 4 * v27 + 2);
        if ( v29 <= 16 - v28 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a3 + 4 * v27) << v29;
          *(_DWORD *)(result + 2932) = v28 + v29;
        }
        else
        {
          v30 = *(_WORD *)(a3 + 4 * v27);
          v31 = *(_WORD *)(a3 + 4 * v27) << v29;
          v32 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v31;
          *(_BYTE *)(v32 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v33 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v3 = a2;
          *(_DWORD *)(result + 2932) = v33 + v48 - 16;
          *(_WORD *)(result + 2924) = v30 >> (16 - v33);
        }
        v34 = dword_100EB7F0[v27];
        if ( !v34 )
          goto LABEL_25;
        v35 = *(_DWORD *)(result + 2932);
        v36 = v26 - dword_100EC0D8[v27];
        if ( v35 <= 16 - v34 )
        {
          *(_WORD *)(result + 2924) |= v36 << v35;
          v13 = v34 + v35;
        }
        else
        {
          v37 = v36 << v35;
          v38 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v37;
          *(_BYTE *)(v38 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v39 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v39 + v34 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v36 >> (16 - v39);
        }
      }
      else
      {
        v8 = *(_WORD *)(v3 + 4 * v6 + 2);
        if ( v7 <= 16 - v8 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 4 * v6) << v7;
          v13 = v8 + v7;
        }
        else
        {
          v9 = *(_WORD *)(v3 + 4 * v6);
          v10 = v9 << v7;
          v11 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v10;
          *(_BYTE *)(v11 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v12 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v12 + v8 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v9 >> (16 - v12);
        }
      }
      *(_DWORD *)(result + 2932) = v13;
LABEL_25:
      v4 = v49;
    }
    while ( v49 < *(_DWORD *)(result + 5728) );
  }
  v40 = *(_WORD *)(v3 + 1026);
  v41 = *(_DWORD *)(result + 2932);
  if ( v41 <= 16 - v40 )
  {
    *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 1024) << v41;
    *(_DWORD *)(result + 2932) = v40 + v41;
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  else
  {
    v42 = *(_WORD *)(v3 + 1024);
    v43 = *(_WORD *)(v3 + 1024) << v41;
    v44 = *(_DWORD *)(result + 5800);
    *(_WORD *)(result + 2924) |= v43;
    *(_BYTE *)(v44 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2925);
    v45 = *(_DWORD *)(result + 2932);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) = v45 + v40 - 16;
    *(_WORD *)(result + 2924) = v42 >> (16 - v45);
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  return result;
}
// 100EB768: using guessed type int dword_100EB768[];
// 100EB7F0: using guessed type int dword_100EB7F0[];
// 100EC060: using guessed type int dword_100EC060[];
// 100EC0D8: using guessed type int dword_100EC0D8[];

//----- (10050E60) --------------------------------------------------------
int __usercall sub_10050E60@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  _BYTE *v4; // edi@1
  int result; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // edx@1
  int i; // esi@1

  v3 = a3;
  v4 = a2;
  result = sub_10050950(a1);
  v6 = *(_DWORD *)(result + 5812);
  v7 = *(_DWORD *)(result + 5800);
  *(_DWORD *)(result + 2928) = 8;
  *(_BYTE *)(v6 + v7) = v3;
  v8 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v8) = BYTE1(v3);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~(_BYTE)v3;
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~BYTE1(v3);
  for ( i = ++*(_DWORD *)(result + 5812); v3; ++v4 )
  {
    *(_BYTE *)(i + *(_DWORD *)(result + 5800)) = *v4;
    i = ++*(_DWORD *)(result + 5812);
    --v3;
  }
  return result;
}

//----- (10050F10) --------------------------------------------------------
void *__usercall sub_10050F10@<eax>(int a1@<edi>)
{
  void *result; // eax@1
  int v2; // ebx@1
  size_t v3; // esi@1
  bool v4; // zf@4

  result = *(void **)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(v2 + 5812);
  if ( v3 > (unsigned int)result )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    result = memcpy_0(*(void **)(a1 + 12), *(const void **)(v2 + 5808), v3);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v2 + 5808) += v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) -= v3;
    v4 = *(_DWORD *)(v2 + 5812) == v3;
    *(_DWORD *)(v2 + 5812) -= v3;
    if ( v4 )
      *(_DWORD *)(v2 + 5808) = *(_DWORD *)(v2 + 5800);
  }
  return result;
}

//----- (10050F70) --------------------------------------------------------
int __usercall sub_10050F70@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx@1
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@3
  int v9; // ecx@3
  int v10; // esi@6
  int v11; // ebx@8
  int i; // ecx@13
  int v13; // edx@17
  int v14; // ebx@18
  int v15; // ecx@19
  int v16; // esi@20
  int v17; // [sp+Ch] [bp-20h]@1
  int *v18; // [sp+10h] [bp-1Ch]@2
  int v19; // [sp+10h] [bp-1Ch]@17
  signed int v20; // [sp+14h] [bp-18h]@2
  int v21; // [sp+18h] [bp-14h]@1
  int v22; // [sp+1Ch] [bp-10h]@2
  int v23; // [sp+20h] [bp-Ch]@1
  int v24; // [sp+24h] [bp-8h]@1
  int v25; // [sp+28h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)a2;
  v24 = *(_DWORD *)(v2 + 8);
  v4 = *(_DWORD *)(v2 + 16);
  v21 = *(_DWORD *)v2;
  v25 = *(_DWORD *)(v2 + 4);
  v5 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  v23 = v5;
  v6 = 0;
  *(_WORD *)(v3 + 4 * *(_DWORD *)(result + 4 * *(_DWORD *)(result + 2328) + 32) + 2) = 0;
  v7 = *(_DWORD *)(result + 2328) + 1;
  v17 = 0;
  if ( v7 < 573 )
  {
    v18 = (int *)(result + 4 * v7 + 32);
    v22 = 573 - v7;
    v20 = 573;
    do
    {
      v8 = *v18;
      v9 = *(_WORD *)(v3 + 4 * *(_WORD *)(v3 + 4 * *v18 + 2) + 2) + 1;
      if ( v9 > v4 )
      {
        ++v6;
        v9 = v4;
        v17 = v6;
      }
      *(_WORD *)(v3 + 4 * v8 + 2) = v9;
      if ( v8 <= v23 )
      {
        ++*(_WORD *)(result + 2 * v9);
        v10 = 0;
        if ( v8 >= v24 )
          v10 = *(_DWORD *)(v25 + 4 * (v8 - v24));
        v11 = *(_WORD *)(v3 + 4 * v8);
        *(_DWORD *)(result + 2912) += v11 * (v10 + v9);
        if ( v21 )
          *(_DWORD *)(result + 2916) += v11 * (v10 + *(_WORD *)(v21 + 4 * v8 + 2));
        v6 = v17;
      }
      ++v18;
      --v22;
    }
    while ( v22 );
    if ( v6 )
    {
      do
      {
        for ( i = v4 - 1; !*(_WORD *)(result + 2 * i); --i )
          ;
        --*(_WORD *)(result + 2 * i);
        *(_WORD *)(result + 2 * i + 2) += 2;
        --*(_WORD *)(result + 2 * v4);
        v6 -= 2;
      }
      while ( v6 > 0 );
      for ( ; v4; --v4 )
      {
        v13 = *(_WORD *)(result + 2 * v4);
        v19 = *(_WORD *)(result + 2 * v4);
        if ( *(_WORD *)(result + 2 * v4) )
        {
          v14 = result + 4 * v20 + 32;
          do
          {
            v15 = *(_DWORD *)(v14 - 4);
            --v20;
            v14 -= 4;
            if ( v15 <= v23 )
            {
              v16 = *(_WORD *)(v3 + 4 * v15 + 2);
              if ( v16 != v4 )
              {
                *(_DWORD *)(result + 2912) += *(_WORD *)(v3 + 4 * v15) * (v4 - v16);
                *(_WORD *)(v3 + 4 * v15 + 2) = v4;
              }
              v13 = --v19;
            }
          }
          while ( v13 );
        }
      }
    }
  }
  return result;
}

//----- (10051140) --------------------------------------------------------
signed int __usercall sub_10051140@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // cx@1
  signed int result; // eax@1
  int v5; // edx@1
  int i; // esi@3
  int v7; // edx@4
  unsigned int v8; // ecx@5
  __int16 v9; // [sp+4h] [bp-24h]@2
  char v10; // [sp+6h] [bp-22h]@1

  v3 = 0;
  result = 1;
  v5 = a1 - (_DWORD)&v10;
  do
  {
    v3 = 2 * (v3 + *(__int16 *)((char *)&v9 + 2 * result + v5));
    *(&v9 + result++) = v3;
  }
  while ( result <= 15 );
  for ( i = 0; i <= a2; ++i )
  {
    v7 = *(_WORD *)(a3 + 4 * i + 2);
    if ( *(_WORD *)(a3 + 4 * i + 2) )
    {
      v8 = (unsigned __int16)(*(&v9 + v7))++;
      result = sub_10050930(v8, v7);
      *(_WORD *)(a3 + 4 * i) = result;
    }
  }
  return result;
}

//----- (100511C0) --------------------------------------------------------
_WORD *__fastcall sub_100511C0(int a1, int a2)
{
  _WORD *v2; // eax@1
  signed int v3; // ecx@1
  _WORD *v4; // eax@3
  signed int v5; // ecx@3
  _WORD *result; // eax@5
  signed int v7; // ecx@5

  v2 = (_WORD *)(a2 + 2936);
  v3 = 286;
  do
  {
    *v2 = 0;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  v4 = (_WORD *)(a2 + 5228);
  v5 = 30;
  do
  {
    *v4 = 0;
    v4 += 2;
    --v5;
  }
  while ( v5 );
  result = (_WORD *)(a2 + 5472);
  v7 = 19;
  do
  {
    *result = 0;
    result += 2;
    --v7;
  }
  while ( v7 );
  *(_DWORD *)(a2 + 2916) = 0;
  *(_DWORD *)(a2 + 2912) = 0;
  *(_DWORD *)(a2 + 2920) = 0;
  *(_DWORD *)(a2 + 5728) = 0;
  *(_WORD *)(a2 + 3960) = 1;
  return result;
}

//----- (10051230) --------------------------------------------------------
unsigned int __usercall sub_10051230@<eax>(int a1@<esi>, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // edi@1
  int v6; // ecx@4
  unsigned int v7; // ebx@4
  int v8; // edx@8
  char v9; // al@11
  int v10; // edx@11
  unsigned int v11; // ecx@12
  _BYTE *v12; // edx@12
  char v13; // al@13
  _BYTE *v14; // edx@13
  char v15; // al@14
  _BYTE *v16; // edx@14
  char v17; // al@15
  _BYTE *v18; // edx@15
  char v19; // al@16
  _BYTE *v20; // edx@16
  char v21; // al@17
  _BYTE *v22; // edx@17
  char v23; // al@18
  _BYTE *v24; // edx@18
  char v25; // al@19
  _BYTE *v26; // edx@19
  char v27; // al@20
  int v28; // edx@22
  unsigned int result; // eax@27
  char v30; // [sp+Fh] [bp-11h]@4
  unsigned int v31; // [sp+10h] [bp-10h]@1
  int v32; // [sp+14h] [bp-Ch]@4
  unsigned int v33; // [sp+18h] [bp-8h]@2
  char v34; // [sp+24h] [bp+4h]@4

  v2 = *(_DWORD *)(a1 + 5748);
  v3 = *(_DWORD *)(a1 + 5680);
  v4 = a2;
  v31 = *(_DWORD *)(a1 + 5696);
  v5 = *(_DWORD *)(a1 + 5692);
  if ( v3 <= v2 - 262 )
    v33 = 0;
  else
    v33 = v3 - v2 + 262;
  v6 = *(_DWORD *)(a1 + 5740) + v3;
  v34 = *(_BYTE *)(v6 + v5 - 1);
  v32 = *(_DWORD *)(a1 + 5708);
  v7 = v6 + 258;
  v30 = *(_BYTE *)(v6 + v5);
  if ( v5 >= *(_DWORD *)(a1 + 5704) )
    v31 >>= 2;
  if ( *(_DWORD *)(a1 + 5708) > *(_DWORD *)(a1 + 5688) )
    v32 = *(_DWORD *)(a1 + 5688);
  do
  {
    v8 = v4 + *(_DWORD *)(a1 + 5740);
    if ( *(_BYTE *)(v8 + v5) == v30 && *(_BYTE *)(v8 + v5 - 1) == v34 && *(_BYTE *)v8 == *(_BYTE *)v6 )
    {
      v9 = *(_BYTE *)(v8 + 1);
      v10 = v8 + 1;
      if ( v9 == *(_BYTE *)(v6 + 1) )
      {
        v11 = v6 + 2;
        v12 = (_BYTE *)(v10 + 1);
        do
        {
          v13 = *(_BYTE *)(v11++ + 1);
          v14 = v12 + 1;
          if ( v13 != *v14 )
            break;
          v15 = *(_BYTE *)(v11++ + 1);
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *(_BYTE *)(v11++ + 1);
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *(_BYTE *)(v11++ + 1);
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *(_BYTE *)(v11++ + 1);
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *(_BYTE *)(v11++ + 1);
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *(_BYTE *)(v11++ + 1);
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *(_BYTE *)(v11++ + 1);
          v12 = v26 + 1;
          if ( v27 != *v12 )
            break;
        }
        while ( v11 < v7 );
        v28 = v11 - v7 + 258;
        v6 = v7 - 258;
        if ( v28 > (signed int)v5 )
        {
          *(_DWORD *)(a1 + 5684) = v4;
          v5 = v28;
          if ( v28 >= v32 )
            break;
          v34 = *(_BYTE *)(v28 + v6 - 1);
          v30 = *(_BYTE *)(v28 + v6);
        }
      }
    }
    v4 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & *(_DWORD *)(a1 + 5756)));
    if ( v4 <= v33 )
      break;
    --v31;
  }
  while ( v31 );
  result = *(_DWORD *)(a1 + 5688);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (100513E0) --------------------------------------------------------
unsigned int __usercall sub_100513E0@<eax>(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  unsigned int v6; // edi@1
  unsigned int v7; // eax@3
  _BYTE *v8; // ecx@3
  char v9; // dl@4
  _BYTE *v10; // ecx@4
  char v11; // dl@5
  _BYTE *v12; // ecx@5
  char v13; // dl@6
  _BYTE *v14; // ecx@6
  char v15; // dl@7
  _BYTE *v16; // ecx@7
  char v17; // dl@8
  _BYTE *v18; // ecx@8
  char v19; // dl@9
  _BYTE *v20; // ecx@9
  char v21; // dl@10
  _BYTE *v22; // ecx@10
  char v23; // dl@11
  unsigned int v24; // ecx@13
  unsigned int result; // eax@13

  v2 = *(_DWORD *)(a1 + 5740);
  v3 = *(_BYTE *)(v2 + a2);
  v4 = v2 + *(_DWORD *)(a1 + 5680);
  v5 = a2 + v2;
  v6 = v4 + 258;
  if ( v3 != *(_BYTE *)v4 || *(_BYTE *)(v5 + 1) != *(_BYTE *)(v4 + 1) )
  {
    result = 2;
  }
  else
  {
    v7 = v4 + 2;
    v8 = (_BYTE *)(v5 + 2);
    do
    {
      v9 = *(_BYTE *)(v7++ + 1);
      v10 = v8 + 1;
      if ( v9 != *v10 )
        break;
      v11 = *(_BYTE *)(v7++ + 1);
      v12 = v10 + 1;
      if ( v11 != *v12 )
        break;
      v13 = *(_BYTE *)(v7++ + 1);
      v14 = v12 + 1;
      if ( v13 != *v14 )
        break;
      v15 = *(_BYTE *)(v7++ + 1);
      v16 = v14 + 1;
      if ( v15 != *v16 )
        break;
      v17 = *(_BYTE *)(v7++ + 1);
      v18 = v16 + 1;
      if ( v17 != *v18 )
        break;
      v19 = *(_BYTE *)(v7++ + 1);
      v20 = v18 + 1;
      if ( v19 != *v20 )
        break;
      v21 = *(_BYTE *)(v7++ + 1);
      v22 = v20 + 1;
      if ( v21 != *v22 )
        break;
      v23 = *(_BYTE *)(v7++ + 1);
      v8 = v22 + 1;
      if ( v23 != *v8 )
        break;
    }
    while ( v7 < v6 );
    v24 = *(_DWORD *)(a1 + 5688);
    result = v7 - v6 + 258;
    *(_DWORD *)(a1 + 5684) = a2;
    if ( result > v24 )
      result = v24;
  }
  return result;
}

//----- (100514B0) --------------------------------------------------------
int __usercall sub_100514B0@<eax>(int result@<eax>, int a2@<edi>, int a3)
{
  int v3; // edx@1
  int v4; // ebp@1
  int v5; // ecx@1
  bool v6; // sf@1
  unsigned __int8 v7; // of@1
  int v8; // esi@3
  int v9; // ebp@3
  unsigned __int16 v10; // dx@3
  unsigned __int16 v11; // bx@3
  int v12; // esi@8
  unsigned __int16 v13; // dx@8
  unsigned __int16 v14; // bx@8
  int v15; // edx@11
  int v16; // [sp+8h] [bp-4h]@1

  v3 = *(_DWORD *)(result + 2324);
  v4 = *(_DWORD *)(result + 4 * a3 + 32);
  v5 = 2 * a3;
  v7 = __OFSUB__(2 * a3, v3);
  v6 = 2 * a3 - v3 < 0;
  v16 = *(_DWORD *)(result + 4 * a3 + 32);
  if ( 2 * a3 > v3 )
  {
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  else
  {
    while ( 1 )
    {
      if ( v6 ^ v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v5 + 36);
        v9 = *(_DWORD *)(result + 4 * v5 + 32);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 2332) <= *(_BYTE *)(result + v9 + 2332) )
          ++v5;
        v4 = v16;
      }
      v12 = *(_DWORD *)(result + 4 * v5 + 32);
      v13 = *(_WORD *)(a2 + 4 * v4);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 32) = v4;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v4 + 2332) <= *(_BYTE *)(v12 + result + 2332) )
        break;
      *(_DWORD *)(result + 4 * a3 + 32) = v12;
      v15 = *(_DWORD *)(result + 2324);
      a3 = v5;
      v5 *= 2;
      v7 = __OFSUB__(v5, v15);
      v6 = v5 - v15 < 0;
      if ( v5 > v15 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  return result;
}

//----- (10051560) --------------------------------------------------------
int __usercall sub_10051560@<eax>(int result@<eax>, __int16 a2@<cx>)
{
  int v2; // edi@1

  *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = HIBYTE(a2);
  v2 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v2) = a2;
  ++*(_DWORD *)(result + 5812);
  return result;
}

//----- (100515A0) --------------------------------------------------------
unsigned int __usercall sub_100515A0@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3)
{
  int v3; // ecx@1
  unsigned int v4; // edi@1
  unsigned int result; // eax@4

  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 > a1 )
    v4 = a1;
  if ( v4 )
  {
    *(_DWORD *)(a2 + 4) -= v4;
    if ( *(_DWORD *)(v3 + 5780) == 1 )
      *(_DWORD *)(a2 + 28) = sub_10053370(*(_DWORD *)(a2 + 28), *(_BYTE **)a2, v4);
    memcpy_0(a3, *(const void **)a2, v4);
    *(_DWORD *)a2 += v4;
    *(_DWORD *)(a2 + 8) += v4;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10051600) --------------------------------------------------------
signed int __usercall sub_10051600@<eax>(signed int result@<eax>, int a2@<ecx>, int a3)
{
  signed int v3; // edi@1
  signed int v4; // edx@1
  signed int v5; // ebp@1
  int v6; // ebx@1
  signed int v7; // ecx@1
  signed int v8; // esi@1
  _WORD *v9; // [sp+10h] [bp-8h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v3 = *(_WORD *)(result + 2);
  v4 = 0;
  v5 = -1;
  v6 = a2;
  v7 = 7;
  v8 = 4;
  if ( !*(_WORD *)(result + 2) )
  {
    v7 = 138;
    v8 = 3;
  }
  *(_WORD *)(result + 4 * v6 + 6) = -1;
  if ( v6 >= 0 )
  {
    v10 = v6 + 1;
    v9 = (_WORD *)(result + 6);
    do
    {
      result = v3;
      v3 = *v9;
      if ( ++v4 >= v7 || result != v3 )
      {
        if ( v4 >= v8 )
        {
          if ( result )
          {
            if ( result != v5 )
              ++*(_WORD *)(a3 + 4 * result + 5472);
            ++*(_WORD *)(a3 + 5536);
          }
          else if ( v4 > 10 )
          {
            ++*(_WORD *)(a3 + 5544);
          }
          else
          {
            ++*(_WORD *)(a3 + 5540);
          }
        }
        else
        {
          *(_WORD *)(a3 + 4 * result + 5472) += v4;
        }
        v4 = 0;
        v5 = result;
        if ( v3 )
        {
          if ( result == v3 )
          {
            v7 = 6;
            v8 = 3;
          }
          else
          {
            v7 = 7;
            v8 = 4;
          }
        }
        else
        {
          v7 = 138;
          v8 = 3;
        }
      }
      v9 += 2;
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (100516E0) --------------------------------------------------------
int __usercall sub_100516E0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  signed int v3; // esi@1
  int v4; // ebx@1
  signed int v5; // ecx@1
  signed int v6; // edi@1
  signed int v7; // edx@5
  int v8; // edi@8
  int v9; // ecx@8
  unsigned __int16 v10; // si@9
  int v11; // edx@9
  int v12; // ecx@9
  int v13; // edx@9
  __int16 v14; // si@9
  int v15; // ecx@9
  int v16; // ecx@15
  unsigned __int16 v17; // si@16
  int v18; // edi@16
  int v19; // ecx@16
  int v20; // ebx@16
  int v21; // ecx@16
  int v22; // ecx@19
  unsigned __int16 v23; // si@20
  int v24; // edi@20
  int v25; // ecx@20
  int v26; // ebx@20
  int v27; // ecx@20
  int v28; // esi@22
  int v29; // edi@23
  int v30; // ecx@23
  int v31; // ebx@23
  int v32; // ecx@24
  int v33; // ecx@25
  unsigned __int16 v34; // si@27
  int v35; // edi@27
  int v36; // ecx@27
  int v37; // ebx@27
  int v38; // ecx@27
  int v39; // esi@29
  int v40; // edi@30
  int v41; // ecx@30
  int v42; // ebx@30
  unsigned __int16 v43; // si@33
  int v44; // edi@33
  int v45; // ecx@33
  int v46; // ebx@33
  int v47; // ecx@33
  int v48; // esi@35
  int v49; // edi@36
  int v50; // ecx@36
  int v51; // ebx@36
  signed int v52; // [sp+10h] [bp-18h]@5
  signed int v53; // [sp+14h] [bp-14h]@1
  _WORD *v54; // [sp+18h] [bp-10h]@4
  signed int v55; // [sp+1Ch] [bp-Ch]@1
  int v56; // [sp+1Ch] [bp-Ch]@15
  int v57; // [sp+1Ch] [bp-Ch]@19
  int v58; // [sp+1Ch] [bp-Ch]@26
  int v59; // [sp+1Ch] [bp-Ch]@32
  int v60; // [sp+20h] [bp-8h]@4
  signed int v61; // [sp+24h] [bp-4h]@5

  v3 = 0;
  v4 = a3;
  v5 = 7;
  v6 = 4;
  v53 = *(_WORD *)(a2 + 2);
  v55 = -1;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( v4 >= 0 )
  {
    v54 = (_WORD *)(a2 + 6);
    v60 = v4 + 1;
    do
    {
      v7 = v53;
      ++v3;
      v61 = v53;
      v53 = *v54;
      v52 = v3;
      if ( v3 < v5 && v7 == *v54 )
        goto LABEL_44;
      if ( v3 < v6 )
      {
        do
        {
          v8 = *(_WORD *)(result + 4 * v7 + 5474);
          v9 = *(_DWORD *)(result + 2932);
          if ( v9 <= 16 - v8 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v15 = v8 + v9;
          }
          else
          {
            v10 = *(_WORD *)(result + 4 * v7 + 5472);
            v11 = *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v12 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v11;
            *(_BYTE *)(v12 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v13 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v14 = v10 >> (16 - v13);
            v15 = v13 + v8 - 16;
            v7 = v61;
            *(_WORD *)(result + 2924) = v14;
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v15;
          v52 = v3;
        }
        while ( v3 );
        goto LABEL_39;
      }
      if ( v7 )
      {
        if ( v7 != v55 )
        {
          v16 = *(_DWORD *)(result + 2932);
          v56 = *(_WORD *)(result + 4 * v7 + 5474);
          if ( v16 <= 16 - v56 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v21 = v56 + v16;
          }
          else
          {
            v17 = *(_WORD *)(result + 4 * v7 + 5472);
            v18 = *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v19 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v18;
            *(_BYTE *)(v19 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v20 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v21 = v20 + v56 - 16;
            *(_WORD *)(result + 2924) = v17 >> (16 - v20);
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v21;
          v52 = v3;
        }
        v22 = *(_DWORD *)(result + 2932);
        v57 = *(_WORD *)(result + 5538);
        if ( v22 <= 16 - v57 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5536) << v22;
          v27 = v57 + v22;
        }
        else
        {
          v23 = *(_WORD *)(result + 5536);
          v24 = *(_WORD *)(result + 5536) << v22;
          v25 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v24;
          *(_BYTE *)(v25 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v26 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v27 = v26 + v57 - 16;
          *(_WORD *)(result + 2924) = v23 >> (16 - v26);
          v3 = v52;
        }
        v28 = v3 - 3;
        *(_DWORD *)(result + 2932) = v27;
        if ( v27 > 14 )
        {
          v29 = v28 << v27;
          v30 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v29;
          *(_BYTE *)(v30 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v31 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          *(_DWORD *)(result + 2932) = v31 - 14;
          *(_WORD *)(result + 2924) = (unsigned __int16)v28 >> (16 - v31);
          goto LABEL_39;
        }
        *(_WORD *)(result + 2924) |= v28 << v27;
        v32 = v27 + 2;
      }
      else
      {
        v33 = *(_DWORD *)(result + 2932);
        if ( v3 > 10 )
        {
          v59 = *(_WORD *)(result + 5546);
          if ( v33 <= 16 - v59 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5544) << v33;
            v47 = v59 + v33;
          }
          else
          {
            v43 = *(_WORD *)(result + 5544);
            v44 = *(_WORD *)(result + 5544) << v33;
            v45 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v44;
            *(_BYTE *)(v45 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v46 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v47 = v46 + v59 - 16;
            *(_WORD *)(result + 2924) = v43 >> (16 - v46);
            v3 = v52;
          }
          v48 = v3 - 11;
          *(_DWORD *)(result + 2932) = v47;
          if ( v47 > 9 )
          {
            v49 = v48 << v47;
            v50 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v49;
            *(_BYTE *)(v50 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v51 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v51 - 9;
            *(_WORD *)(result + 2924) = (unsigned __int16)v48 >> (16 - v51);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v48 << v47;
          v32 = v47 + 7;
        }
        else
        {
          v58 = *(_WORD *)(result + 5542);
          if ( v33 <= 16 - v58 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5540) << v33;
            v38 = v58 + v33;
          }
          else
          {
            v34 = *(_WORD *)(result + 5540);
            v35 = *(_WORD *)(result + 5540) << v33;
            v36 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v35;
            *(_BYTE *)(v36 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v37 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v38 = v37 + v58 - 16;
            *(_WORD *)(result + 2924) = v34 >> (16 - v37);
            v3 = v52;
          }
          v39 = v3 - 3;
          *(_DWORD *)(result + 2932) = v38;
          if ( v38 > 13 )
          {
            v40 = v39 << v38;
            v41 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v40;
            *(_BYTE *)(v41 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v42 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v42 - 13;
            *(_WORD *)(result + 2924) = (unsigned __int16)v39 >> (16 - v42);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v39 << v38;
          v32 = v38 + 3;
        }
      }
      *(_DWORD *)(result + 2932) = v32;
LABEL_39:
      v3 = 0;
      v55 = v7;
      if ( v53 )
      {
        if ( v7 == v53 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v54 += 2;
      --v60;
    }
    while ( v60 );
  }
  return result;
}

//----- (10051C80) --------------------------------------------------------
int __usercall sub_10051C80@<eax>(int a1@<eax>)
{
  signed int v1; // ecx@1
  int v2; // edx@2
  signed int v3; // ecx@4
  int v4; // edx@5
  int result; // eax@7
  signed int v6; // ecx@7
  int v7; // edx@9
  signed int v8; // ecx@11
  int v9; // edx@12

  v1 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) |= 2 << v1;
  if ( v1 <= 13 )
  {
    *(_DWORD *)(a1 + 2932) = v1 + 3;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v2 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v2 - 13;
    *(_WORD *)(a1 + 2924) = 2u >> (16 - v2);
  }
  v3 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) = *(_WORD *)(a1 + 2924);
  if ( v3 <= 9 )
  {
    *(_DWORD *)(a1 + 2932) = v3 + 7;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v4 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v4 - 9;
    *(_WORD *)(a1 + 2924) = 0;
  }
  result = sub_100508A0(a1);
  v6 = *(_DWORD *)(result + 2932);
  if ( *(_DWORD *)(result + 2928) - v6 + 11 < 9 )
  {
    *(_WORD *)(result + 2924) |= 2 << v6;
    if ( v6 <= 13 )
    {
      *(_DWORD *)(result + 2932) = v6 + 3;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v7 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v7 - 13;
      *(_WORD *)(result + 2924) = 2u >> (16 - v7);
    }
    v8 = *(_DWORD *)(result + 2932);
    *(_WORD *)(result + 2924) = *(_WORD *)(result + 2924);
    if ( v8 > 9 )
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v9 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v9 - 9;
      *(_WORD *)(result + 2924) = 0;
      result = sub_100508A0(result);
      *(_DWORD *)(result + 2928) = 7;
      return result;
    }
    *(_DWORD *)(result + 2932) = v8 + 7;
    result = sub_100508A0(result);
  }
  *(_DWORD *)(result + 2928) = 7;
  return result;
}

//----- (10051EC0) --------------------------------------------------------
int __usercall sub_10051EC0@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4)
{
  int v4; // esi@1
  signed int v5; // ecx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  int result; // eax@2

  v4 = a2;
  v5 = *(_DWORD *)(a1 + 2932);
  if ( v5 <= 13 )
  {
    *(_WORD *)(a1 + 2924) |= v4 << v5;
    *(_DWORD *)(a1 + 2932) = v5 + 3;
    result = sub_10050E60(a1, a3, a4);
  }
  else
  {
    v6 = v4 << v5;
    v7 = *(_DWORD *)(a1 + 5800);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) = (unsigned __int16)v4 >> (16 - v8);
    *(_DWORD *)(a1 + 2932) = v8 - 13;
    result = sub_10050E60(a1, a3, a4);
  }
  return result;
}

//----- (10051F60) --------------------------------------------------------
signed int __usercall sub_10051F60@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax@1
  int v3; // ebp@1
  signed int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@1
  signed int v7; // eax@8
  signed int i; // ebp@14
  int v9; // ebx@16
  int v10; // eax@17
  int v11; // edx@17
  int v12; // ebp@17
  int v13; // eax@17
  unsigned __int8 v14; // cl@17
  int v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)v2;
  v17 = *(_DWORD *)(v2 + 12);
  v4 = -1;
  v5 = *(_DWORD *)a2;
  v6 = 0;
  v16 = -1;
  *(_DWORD *)(a1 + 2324) = 0;
  for ( *(_DWORD *)(a1 + 2328) = 573; v6 < v17; ++v6 )
  {
    if ( *(_WORD *)(v5 + 4 * v6) )
    {
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v6;
      v16 = v6;
      *(_BYTE *)(v6 + a1 + 2332) = 0;
      v4 = v6;
    }
    else
    {
      *(_WORD *)(v5 + 4 * v6 + 2) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 2324) < 2 )
  {
    do
    {
      if ( v4 >= 2 )
        v7 = 0;
      else
        v7 = ++v4;
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v7;
      *(_WORD *)(v5 + 4 * v7) = 1;
      *(_BYTE *)(a1 + v7 + 2332) = 0;
      --*(_DWORD *)(a1 + 2912);
      if ( v3 )
        *(_DWORD *)(a1 + 2916) -= *(_WORD *)(v3 + 4 * v7 + 2);
    }
    while ( *(_DWORD *)(a1 + 2324) < 2 );
    v16 = v4;
  }
  *(_DWORD *)(a2 + 4) = v4;
  for ( i = *(_DWORD *)(a1 + 2324) / 2; i >= 1; --i )
    sub_100514B0(a1, v5, i);
  v9 = v17;
  do
  {
    v10 = *(_DWORD *)(a1 + 2324);
    v11 = *(_DWORD *)(a1 + 4 * v10 + 32);
    v12 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 2324) = v10 - 1;
    *(_DWORD *)(a1 + 36) = v11;
    sub_100514B0(a1, v5, 1);
    v13 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v12;
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v13;
    *(_WORD *)(v5 + 4 * v9) = *(_WORD *)(v5 + 4 * v12) + *(_WORD *)(v5 + 4 * v13);
    v14 = *(_BYTE *)(a1 + v13 + 2332);
    if ( *(_BYTE *)(a1 + v12 + 2332) >= v14 )
      v14 = *(_BYTE *)(a1 + v12 + 2332);
    *(_BYTE *)(a1 + v9 + 2332) = v14 + 1;
    *(_WORD *)(v5 + 4 * v13 + 2) = v9;
    *(_WORD *)(v5 + 4 * v12 + 2) = v9;
    *(_DWORD *)(a1 + 36) = v9++;
    sub_100514B0(a1, v5, 1);
  }
  while ( *(_DWORD *)(a1 + 2324) >= 2 );
  *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = *(_DWORD *)(a1 + 36);
  sub_10050F70(a1, a2);
  return sub_10051140(a1, v16, v5);
}

//----- (10052140) --------------------------------------------------------
unsigned int __usercall sub_10052140@<eax>(int a1@<edi>)
{
  size_t v1; // ebx@1
  unsigned int result; // eax@2
  unsigned int v3; // ebp@2
  int v4; // edx@3
  int v5; // eax@3
  _WORD *v6; // ecx@3
  int v7; // eax@4
  __int16 v8; // ax@5
  size_t v9; // edx@8
  _WORD *v10; // ecx@8
  int v11; // eax@9
  int v12; // esi@14
  unsigned int v13; // edx@15
  int v14; // esi@16
  int v15; // eax@16
  int v16; // ecx@16

  v1 = *(_DWORD *)(a1 + 5748);
  do
  {
    result = *(_DWORD *)(a1 + 5680);
    v3 = *(_DWORD *)(a1 + 5744) - result - *(_DWORD *)(a1 + 5688);
    if ( result >= v1 + *(_DWORD *)(a1 + 5748) - 262 )
    {
      memcpy_0(*(void **)(a1 + 5740), (const void *)(*(_DWORD *)(a1 + 5740) + v1), v1);
      v4 = *(_DWORD *)(a1 + 5764);
      v5 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5684) -= v1;
      *(_DWORD *)(a1 + 5680) -= v1;
      *(_DWORD *)(a1 + 5664) -= v1;
      v6 = (_WORD *)(v5 + 2 * v4);
      do
      {
        v7 = *(v6 - 1);
        --v6;
        if ( v7 < v1 )
          v8 = 0;
        else
          v8 = v7 - v1;
        --v4;
        *v6 = v8;
      }
      while ( v4 );
      v9 = v1;
      v10 = (_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * v1);
      do
      {
        v11 = *(v10 - 1);
        --v10;
        if ( v11 < v1 )
          result = 0;
        else
          result = v11 - v1;
        --v9;
        *v10 = result;
      }
      while ( v9 );
      v3 += v1;
    }
    v12 = *(_DWORD *)(a1 + 2908);
    if ( !*(_DWORD *)(v12 + 4) )
      break;
    result = sub_100515A0(v3, v12, (void *)(*(_DWORD *)(a1 + 5688) + *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)));
    *(_DWORD *)(a1 + 5688) += result;
    v13 = *(_DWORD *)(a1 + 5688);
    if ( v13 >= 3 )
    {
      v14 = *(_DWORD *)(a1 + 5680) + *(_DWORD *)(a1 + 5740);
      v15 = *(_BYTE *)v14;
      v16 = *(_DWORD *)(a1 + 5776);
      *(_DWORD *)(a1 + 5760) = v15;
      result = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v14 + 1) ^ (v15 << v16));
      *(_DWORD *)(a1 + 5760) = result;
    }
  }
  while ( v13 < 0x106 && *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 4) );
  return result;
}

//----- (10052280) --------------------------------------------------------
int __usercall sub_10052280@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  signed int v9; // ecx@4
  int v10; // edx@5
  int v11; // ecx@5
  int v12; // edx@5
  signed int v13; // ecx@7
  int v14; // edx@8
  int v15; // ecx@8
  int v16; // edx@8
  int i; // edi@10
  signed int v18; // ecx@11
  int v19; // edx@11
  unsigned __int16 v20; // si@12
  int v21; // edx@12
  int v22; // ecx@12
  int v23; // edx@12
  int v24; // eax@15

  v4 = *(_DWORD *)(a1 + 2932);
  v5 = a4;
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 2932) = v4 + 5;
  }
  else
  {
    v6 = (a2 - 257) << v4;
    v7 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    v5 = a4;
    *(_DWORD *)(a1 + 2932) = v8 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a2 - 257) >> (16 - v8);
  }
  v9 = *(_DWORD *)(a1 + 2932);
  if ( v9 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a3 - 1) << v9;
    *(_DWORD *)(a1 + 2932) = v9 + 5;
  }
  else
  {
    v10 = (a3 - 1) << v9;
    v11 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v10;
    *(_BYTE *)(v11 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v12 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v12 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a3 - 1) >> (16 - v12);
  }
  v13 = *(_DWORD *)(a1 + 2932);
  if ( v13 <= 12 )
  {
    *(_WORD *)(a1 + 2924) |= (v5 - 4) << v13;
    *(_DWORD *)(a1 + 2932) = v13 + 4;
  }
  else
  {
    v14 = (v5 - 4) << v13;
    v15 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v14;
    *(_BYTE *)(v15 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v16 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v16 - 12;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(v5 - 4) >> (16 - v16);
  }
  for ( i = 0; i < v5; ++i )
  {
    v18 = *(_DWORD *)(a1 + 2932);
    v19 = (unsigned __int8)byte_100EB7DC[i];
    if ( v18 <= 13 )
    {
      *(_WORD *)(a1 + 2924) |= *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      *(_DWORD *)(a1 + 2932) = v18 + 3;
    }
    else
    {
      v20 = *(_WORD *)(a1 + 4 * v19 + 5474);
      v21 = *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      v22 = *(_DWORD *)(a1 + 5812);
      *(_WORD *)(a1 + 2924) |= v21;
      *(_BYTE *)(v22 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
      *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
      v23 = *(_DWORD *)(a1 + 2932);
      ++*(_DWORD *)(a1 + 5812);
      v5 = a4;
      *(_DWORD *)(a1 + 2932) = v23 - 13;
      *(_WORD *)(a1 + 2924) = v20 >> (16 - v23);
    }
  }
  v24 = sub_100516E0(a1, a1 + 2936, a2 - 1);
  return sub_100516E0(v24, v24 + 5228, a3 - 1);
}

//----- (10052530) --------------------------------------------------------
signed int __cdecl sub_10052530(int a1, int a2)
{
  int v2; // esi@3
  int v3; // eax@6
  signed int result; // eax@9
  int v5; // ebx@10
  char v6; // al@12
  int v7; // eax@14
  unsigned int v8; // ecx@17
  int v9; // eax@19
  int v10; // eax@20
  int v11; // eax@29
  signed int v12; // eax@36
  int v13; // eax@50
  bool v14; // zf@50

  if ( !a1 || (unsigned int)a2 > 4 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  if ( !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) )
    return -2;
  v3 = *(_DWORD *)(v2 + 5788);
  if ( v3 == 666 && a2 != 4 )
    return -2;
  if ( !*(_DWORD *)(a1 + 16) )
    return -5;
  v5 = *(_DWORD *)(v2 + 5792);
  *(_DWORD *)(v2 + 2908) = a1;
  *(_DWORD *)(v2 + 5792) = a2;
  if ( v3 == 42 )
  {
    if ( *(_BYTE *)(v2 + 5796) >= 2 || (v6 = *(_BYTE *)(v2 + 5784), v6 < 2) )
    {
      v7 = 0;
    }
    else if ( v6 >= 6 )
    {
      v7 = (v6 != 6) + 2;
    }
    else
    {
      v7 = 1;
    }
    v8 = (v7 << 6) | (((*(_DWORD *)(v2 + 5752) - 8) << 12) + 2048);
    if ( *(_DWORD *)(v2 + 5680) )
      v8 |= 0x20u;
    *(_DWORD *)(v2 + 5788) = 113;
    v9 = sub_10051560(v2, 31 * (v8 / 0x1F + 1));
    if ( *(_DWORD *)(v2 + 5680) )
    {
      v10 = sub_10051560(v9, *(_WORD *)(a1 + 30));
      sub_10051560(v10, *(_WORD *)(a1 + 28));
    }
    *(_DWORD *)(a1 + 28) = sub_10053370(0, 0, 0);
  }
  if ( *(_DWORD *)(v2 + 5812) )
  {
    sub_10050F10(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
LABEL_24:
      *(_DWORD *)(v2 + 5792) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v5 && a2 != 4 )
  {
    return -5;
  }
  v11 = *(_DWORD *)(v2 + 5788);
  if ( v11 == 666 )
  {
    if ( *(_DWORD *)(a1 + 4) )
      return -5;
LABEL_33:
    if ( !*(_DWORD *)(v2 + 5688) && (!a2 || v11 == 666) )
      goto LABEL_47;
    goto LABEL_36;
  }
  if ( !*(_DWORD *)(a1 + 4) )
    goto LABEL_33;
LABEL_36:
  v12 = (*(&off_100EC158 + 3 * *(_BYTE *)(v2 + 5784)))(v2, a2);
  if ( v12 == 2 || v12 == 3 )
    *(_DWORD *)(v2 + 5788) = 666;
  if ( !v12 || v12 == 2 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      return 0;
    *(_DWORD *)(v2 + 5792) = -1;
    return 0;
  }
  if ( v12 == 1 )
  {
    if ( a2 == 1 )
    {
      sub_10051C80(v2);
    }
    else
    {
      sub_10051EC0(v2, 0, 0, 0);
      if ( a2 == 3 )
      {
        *(_WORD *)(*(_DWORD *)(v2 + 5736) + 2 * *(_DWORD *)(v2 + 5764) - 2) = 0;
        memset(*(void **)(v2 + 5736), 0, 2 * *(_DWORD *)(v2 + 5764) - 2);
      }
    }
    sub_10050F10(a1);
    if ( !*(_DWORD *)(a1 + 16) )
      goto LABEL_24;
  }
LABEL_47:
  if ( a2 != 4 )
    return 0;
  if ( *(_DWORD *)(v2 + 5780) > 0 )
  {
    v13 = sub_10051560(v2, *(_WORD *)(a1 + 30));
    sub_10051560(v13, *(_WORD *)(a1 + 28));
    sub_10050F10(a1);
    v14 = *(_DWORD *)(v2 + 5812) == 0;
    *(_DWORD *)(v2 + 5780) = -*(_DWORD *)(v2 + 5780);
    result = v14;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 100EC158: using guessed type int (__cdecl *off_100EC158)(int, int);

//----- (100527F0) --------------------------------------------------------
signed int __usercall sub_100527F0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  signed int result; // eax@1

  v1 = a1;
  sub_10051600(a1 + 2936, *(_DWORD *)(a1 + 5632), a1);
  sub_10051600(v1 + 5228, *(_DWORD *)(v1 + 5644), v1);
  sub_10051F60(v1, v1 + 5652);
  result = 18;
  while ( !*(_WORD *)(v1 + 4 * (unsigned __int8)byte_100EB7DC[result] + 5474) )
  {
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100EB7DB[result] + 5474) )
    {
      *(_DWORD *)(v1 + 2912) += 3 * --result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100EB7DA[result] + 5474) )
    {
      result -= 2;
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100EB7D9[result] + 5474) )
    {
      result -= 3;
      break;
    }
    result -= 4;
    if ( result < 3 )
    {
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
  }
  *(_DWORD *)(v1 + 2912) += 3 * result + 17;
  return result;
}

//----- (100528C0) --------------------------------------------------------
_WORD *__usercall sub_100528C0@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // eax@1
  _BYTE *v7; // edi@2
  signed int v8; // eax@5
  unsigned int v9; // edx@5
  unsigned int v10; // ecx@5
  int v11; // ecx@11
  bool v12; // zf@12
  signed int v13; // ecx@12
  int v14; // eax@13
  int v15; // edx@14
  int v16; // ecx@14
  int v17; // edx@14
  int v18; // edx@17
  int v19; // eax@18
  int v20; // ecx@18
  int v21; // ebx@18
  _WORD *result; // eax@21
  signed int v23; // [sp+14h] [bp+4h]@4

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(_DWORD *)(a2 + 5664);
  if ( v6 < 0 )
    v7 = 0;
  else
    v7 = (_BYTE *)(v6 + *(_DWORD *)(a2 + 5740));
  v23 = 0;
  if ( *(_BYTE *)(a2 + 5784) <= 0 )
  {
    v10 = v5 + 5;
LABEL_8:
    v9 = v10;
    goto LABEL_9;
  }
  sub_10051F60(a2, a2 + 5628);
  sub_10051F60(v4, v4 + 5640);
  v8 = sub_100527F0(v4);
  v9 = (unsigned int)(*(_DWORD *)(v4 + 2912) + 10) >> 3;
  v10 = (unsigned int)(*(_DWORD *)(v4 + 2916) + 10) >> 3;
  v23 = v8;
  if ( v10 <= v9 )
    goto LABEL_8;
LABEL_9:
  if ( v5 + 4 <= v9 && v7 )
  {
    sub_10051EC0(v4, v3, v7, v5);
  }
  else
  {
    v12 = v10 == v9;
    v13 = *(_DWORD *)(v4 + 2932);
    if ( v12 )
    {
      v14 = v3 + 2;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v14 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v15 = v14 << v13;
        v16 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v15;
        *(_BYTE *)(v16 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v17 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v17 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v14 >> (16 - v17);
      }
      sub_100509E0(v4, (int)&unk_100EB868, (int)&unk_100EBCE8);
    }
    else
    {
      v18 = v3 + 4;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v18 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v19 = v18 << v13;
        v20 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v19;
        *(_BYTE *)(v20 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v21 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v21 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v18 >> (16 - v21);
      }
      sub_10052280(v4, *(_DWORD *)(v4 + 5632) + 1, *(_DWORD *)(v4 + 5644) + 1, v23 + 1);
      sub_100509E0(v4, v4 + 2936, v4 + 5228);
    }
  }
  result = sub_100511C0(v11, v4);
  if ( v3 )
    result = (_WORD *)sub_10050950(v4);
  return result;
}

//----- (10052AE0) --------------------------------------------------------
signed int __cdecl sub_10052AE0(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  int v4; // edx@7
  int v5; // edi@7
  int v6; // eax@7
  int v7; // ecx@7
  unsigned int v8; // eax@9
  char v9; // cl@10
  unsigned int v10; // eax@11
  unsigned int v11; // eax@16
  BOOL v12; // eax@17
  unsigned int v13; // ecx@17
  int v14; // edi@20
  int v15; // ecx@20
  int v16; // edx@20
  int v17; // ebx@20
  int v19; // edi@22
  int v20; // ecx@22
  int v21; // edx@22
  int v22; // edi@26
  signed int result; // eax@27
  int v24; // edi@28
  int v25; // eax@28

  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_10052140(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    if ( v2 )
    {
      v8 = *(_DWORD *)(a1 + 5680) - v2;
      if ( v8 <= *(_DWORD *)(a1 + 5748) - 262 )
      {
        v9 = *(_BYTE *)(a1 + 5796);
        if ( v9 < 2 )
        {
          v10 = sub_10051230(a1, v2);
LABEL_15:
          *(_DWORD *)(a1 + 5668) = v10;
          goto LABEL_16;
        }
        if ( v9 == 3 && v8 == 1 )
        {
          v10 = sub_100513E0(a1, v2);
          goto LABEL_15;
        }
      }
    }
LABEL_16:
    v11 = *(_DWORD *)(a1 + 5668);
    if ( v11 < 3 )
    {
      v12 = sub_10050800(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)), 0);
      --*(_DWORD *)(a1 + 5688);
    }
    else
    {
      v12 = sub_10050800(a1, v11 - 3, *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684));
      v13 = *(_DWORD *)(a1 + 5668);
      *(_DWORD *)(a1 + 5688) -= v13;
      if ( v13 > *(_DWORD *)(a1 + 5700) || *(_DWORD *)(a1 + 5688) < 3u )
      {
        *(_DWORD *)(a1 + 5680) += v13;
        v19 = *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680);
        v20 = *(_DWORD *)(a1 + 5776);
        *(_DWORD *)(a1 + 5668) = 0;
        v21 = *(_BYTE *)v19;
        *(_DWORD *)(a1 + 5760) = v21;
        *(_DWORD *)(a1 + 5760) = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v19 + 1) ^ (v21 << v20));
        goto LABEL_25;
      }
      *(_DWORD *)(a1 + 5668) = v13 - 1;
      do
      {
        v14 = ++*(_DWORD *)(a1 + 5680);
        v15 = *(_DWORD *)(a1 + 5736);
        v16 = *(_DWORD *)(a1 + 5772) & ((*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)) ^ *(_BYTE *)(*(_DWORD *)(a1 + 5740) + v14 + 2));
        v17 = *(_DWORD *)(a1 + 5756);
        *(_DWORD *)(a1 + 5760) = v16;
        *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v14 & v17)) = *(_WORD *)(v15 + 2 * v16);
        v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
        *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
      }
      while ( (*(_DWORD *)(a1 + 5668))-- != 1 );
    }
    ++*(_DWORD *)(a1 + 5680);
LABEL_25:
    if ( v12 )
    {
      sub_100528C0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
      v22 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_10050F10(v22);
      if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        return 0;
    }
  }
  sub_100528C0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v24 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10050F10(v24);
  v25 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v25) = a2 == 4;
    result = 2 * v25 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (10052DF0) --------------------------------------------------------
signed int __cdecl sub_10052DF0(int a1, int a2)
{
  unsigned int v2; // ebp@1
  unsigned int v3; // eax@3
  int v4; // edx@8
  int v5; // edi@8
  int v6; // eax@8
  int v7; // ecx@8
  unsigned int v8; // ecx@9
  int v9; // edx@9
  unsigned int v10; // eax@11
  char v11; // cl@12
  unsigned int v12; // eax@13
  unsigned int v13; // eax@18
  unsigned int v14; // eax@23
  int v15; // ecx@25
  unsigned int v16; // ebp@25
  BOOL v17; // eax@25
  int v18; // ecx@25
  BOOL v19; // ebx@25
  unsigned int v20; // edi@26
  int v21; // ecx@27
  int v22; // edx@27
  int v23; // eax@27
  int v25; // eax@29
  int v26; // edi@30
  signed int result; // eax@31
  int v28; // edi@34
  int v29; // ecx@35
  int v30; // edi@40
  unsigned int v31; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v31 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_10052140(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    v8 = *(_DWORD *)(a1 + 5668);
    v9 = *(_DWORD *)(a1 + 5684);
    *(_DWORD *)(a1 + 5692) = v8;
    *(_DWORD *)(a1 + 5672) = v9;
    *(_DWORD *)(a1 + 5668) = 2;
    if ( !v2 )
      goto LABEL_23;
    if ( v8 >= *(_DWORD *)(a1 + 5700) )
      goto LABEL_23;
    v10 = *(_DWORD *)(a1 + 5680) - v2;
    if ( v10 > *(_DWORD *)(a1 + 5748) - 262 )
      goto LABEL_23;
    v11 = *(_BYTE *)(a1 + 5796);
    if ( v11 < 2 )
    {
      v12 = sub_10051230(a1, v2);
LABEL_17:
      *(_DWORD *)(a1 + 5668) = v12;
      goto LABEL_18;
    }
    if ( v11 == 3 && v10 == 1 )
    {
      v12 = sub_100513E0(a1, v2);
      goto LABEL_17;
    }
LABEL_18:
    v13 = *(_DWORD *)(a1 + 5668);
    if ( v13 <= 5
      && (*(_BYTE *)(a1 + 5796) == 1
       || v13 == 3 && (unsigned int)(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684)) > 0x1000) )
    {
      *(_DWORD *)(a1 + 5668) = 2;
    }
LABEL_23:
    v14 = *(_DWORD *)(a1 + 5692);
    if ( v14 < 3 || *(_DWORD *)(a1 + 5668) > v14 )
    {
      if ( *(_DWORD *)(a1 + 5676) )
      {
        if ( sub_10050800(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0) )
        {
          sub_100528C0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
          v28 = *(_DWORD *)(a1 + 2908);
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
          sub_10050F10(v28);
        }
        v29 = *(_DWORD *)(a1 + 2908);
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        if ( !*(_DWORD *)(v29 + 16) )
          return 0;
      }
      else
      {
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        *(_DWORD *)(a1 + 5676) = 1;
      }
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 5680);
      v16 = v15 + *(_DWORD *)(a1 + 5688) - 3;
      v17 = sub_10050800(a1, v14 - 3, v15 - *(_DWORD *)(a1 + 5672) - 1);
      v18 = *(_DWORD *)(a1 + 5692);
      v19 = v17;
      *(_DWORD *)(a1 + 5688) += 1 - v18;
      *(_DWORD *)(a1 + 5692) = v18 - 2;
      do
      {
        v20 = ++*(_DWORD *)(a1 + 5680);
        if ( v20 <= v16 )
        {
          v21 = *(_DWORD *)(a1 + 5736);
          v22 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v20 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
          v23 = *(_DWORD *)(a1 + 5756);
          *(_DWORD *)(a1 + 5760) = v22;
          *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v20 & v23)) = *(_WORD *)(v21 + 2 * v22);
          v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
          *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
        }
      }
      while ( (*(_DWORD *)(a1 + 5692))-- != 1 );
      v25 = ++*(_DWORD *)(a1 + 5680);
      *(_DWORD *)(a1 + 5676) = 0;
      *(_DWORD *)(a1 + 5668) = 2;
      if ( v19 )
      {
        sub_100528C0(v25 - *(_DWORD *)(a1 + 5664), a1, 0);
        v26 = *(_DWORD *)(a1 + 2908);
        *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
        sub_10050F10(v26);
        if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
          return 0;
      }
      v2 = v31;
    }
  }
  if ( *(_DWORD *)(a1 + 5676) )
  {
    sub_10050800(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0);
    *(_DWORD *)(a1 + 5676) = 0;
  }
  sub_100528C0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v30 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10050F10(v30);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
    result = 2 * (a2 == 4) + 1;
  else
    result = a2 != 4 ? 0 : 2;
  return result;
}

//----- (10053200) --------------------------------------------------------
signed int __cdecl sub_10053200(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // eax@3
  bool v4; // zf@5
  int v5; // edx@5
  unsigned int v6; // ecx@5
  unsigned int v7; // eax@5
  int v8; // edi@7
  unsigned int v9; // eax@8
  int v10; // edi@9
  signed int result; // eax@10
  int v12; // edi@12
  int v13; // eax@12

  v2 = 0xFFFF;
  if ( (unsigned int)(*(_DWORD *)(a1 + 5804) - 5) <= 0xFFFF )
    v2 = *(_DWORD *)(a1 + 5804) - 5;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 <= 1 )
    {
      sub_10052140(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( !v3 )
        break;
    }
    v4 = v3 + *(_DWORD *)(a1 + 5680) == 0;
    *(_DWORD *)(a1 + 5680) += v3;
    v5 = *(_DWORD *)(a1 + 5664);
    v6 = *(_DWORD *)(a1 + 5680);
    *(_DWORD *)(a1 + 5688) = 0;
    v7 = v5 + v2;
    if ( !v4 && v6 < v7
      || (*(_DWORD *)(a1 + 5688) = v6 - v7,
          *(_DWORD *)(a1 + 5680) = v7,
          sub_100528C0(v2, a1, 0),
          v8 = *(_DWORD *)(a1 + 2908),
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680),
          sub_10050F10(v8),
          *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16)) )
    {
      v9 = *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664);
      if ( v9 < *(_DWORD *)(a1 + 5748) - 262 )
        continue;
      sub_100528C0(v9, a1, 0);
      v10 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_10050F10(v10);
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  sub_100528C0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v12 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10050F10(v12);
  v13 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v13) = a2 == 4;
    result = 2 * v13 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (10053370) --------------------------------------------------------
int __cdecl sub_10053370(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edi@1
  unsigned int v4; // ecx@1
  unsigned int v5; // esi@1
  int result; // eax@2
  unsigned int i; // ebp@3
  unsigned int v8; // ebx@4
  int v9; // eax@8
  signed int v10; // edx@8
  int v11; // ecx@9
  int v12; // esi@9
  int v13; // ecx@9
  int v14; // esi@9
  int v15; // ecx@9
  int v16; // esi@9
  unsigned int v17; // [sp+Ch] [bp+4h]@7

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = a1 >> 16;
  if ( a2 )
  {
    for ( i = a3; i; v5 %= 0xFFF1u )
    {
      v8 = i;
      if ( i >= 0x15B0 )
        v8 = 5552;
      i -= v8;
      if ( (signed int)v8 >= 16 )
      {
        v17 = v8 >> 4;
        v8 += -16 * (v8 >> 4);
        do
        {
          v9 = (int)(v3 + 1);
          v10 = 4;
          do
          {
            v11 = *(_BYTE *)(v9 - 1) + v4;
            v12 = v11 + v5;
            v13 = *(_BYTE *)v9 + v11;
            v14 = v13 + v12;
            v15 = *(_BYTE *)(v9 + 1) + v13;
            v16 = v15 + v14;
            v4 = *(_BYTE *)(v9 + 2) + v15;
            v5 = v4 + v16;
            v9 += 4;
            --v10;
          }
          while ( v10 );
          v3 += 16;
          --v17;
        }
        while ( v17 );
      }
      for ( ; v8; --v8 )
      {
        v4 += *v3++;
        v5 += v4;
      }
      v4 %= 0xFFF1u;
    }
    result = v4 | (v5 << 16);
  }
  else
  {
    result = (int)(a2 + 1);
  }
  return result;
}

//----- (10053470) --------------------------------------------------------
signed int __cdecl sub_10053470(int a1)
{
  signed int result; // eax@3

  if ( a1 && *(_DWORD *)(a1 + 24) )
  {
    *(_DWORD *)(a1 + 24) = 0;
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10053490) --------------------------------------------------------
signed int __usercall sub_10053490@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10)
{
  unsigned int v10; // ebp@1
  unsigned int *v11; // edi@1
  _DWORD *v12; // eax@1
  unsigned int v13; // edx@1
  signed int result; // eax@4
  unsigned int v15; // eax@5
  int v16; // ecx@7
  signed int v17; // edx@9
  signed int v18; // esi@13
  int i; // edi@13
  int v20; // esi@14
  int v21; // edi@16
  int v22; // esi@16
  int v23; // edi@17
  int v24; // ebx@17
  int v25; // esi@17
  int v26; // edi@18
  _DWORD *v27; // edi@20
  unsigned int v28; // ebx@20
  int v29; // esi@21
  int v30; // edi@22
  signed int v31; // edi@24
  int v32; // ebx@24
  unsigned int v33; // esi@25
  int v34; // edx@27
  int l; // ebp@28
  unsigned int v36; // edx@31
  unsigned int v37; // ecx@33
  int *v38; // ebp@34
  int v39; // eax@34
  unsigned int v40; // edi@36
  unsigned int v41; // eax@36
  unsigned int v42; // edx@39
  int v43; // eax@40
  unsigned int v44; // eax@41
  int v45; // ecx@41
  int v46; // esi@48
  signed int v47; // edx@50
  unsigned int v48; // eax@50
  int v49; // ecx@51
  unsigned int j; // eax@54
  int v51; // [sp+Ch] [bp-F4h]@7
  unsigned int v52; // [sp+Ch] [bp-F4h]@24
  signed int v53; // [sp+Ch] [bp-F4h]@31
  unsigned int v54; // [sp+10h] [bp-F0h]@9
  int v55; // [sp+14h] [bp-ECh]@24
  int v56; // [sp+18h] [bp-E8h]@26
  _DWORD *v57; // [sp+1Ch] [bp-E4h]@21
  int v58; // [sp+1Ch] [bp-E4h]@31
  unsigned int k; // [sp+20h] [bp-E0h]@24
  int *v60; // [sp+24h] [bp-DCh]@25
  int v61; // [sp+28h] [bp-D8h]@0
  unsigned int v62; // [sp+2Ch] [bp-D4h]@0
  int v63; // [sp+30h] [bp-D0h]@24
  unsigned int *v64; // [sp+34h] [bp-CCh]@24
  int v65; // [sp+38h] [bp-C8h]@11
  int v66; // [sp+3Ch] [bp-C4h]@31
  int v67; // [sp+40h] [bp-C0h]@16
  int v68; // [sp+44h] [bp-BCh]@1
  int v69; // [sp+48h] [bp-B8h]@1
  int v70; // [sp+4Ch] [bp-B4h]@1
  int v71; // [sp+50h] [bp-B0h]@1
  int v72; // [sp+54h] [bp-ACh]@1
  int v73; // [sp+58h] [bp-A8h]@1
  int v74; // [sp+5Ch] [bp-A4h]@1
  int v75; // [sp+60h] [bp-A0h]@1
  int v76; // [sp+64h] [bp-9Ch]@1
  int v77; // [sp+68h] [bp-98h]@1
  int v78; // [sp+6Ch] [bp-94h]@1
  int v79; // [sp+70h] [bp-90h]@1
  int v80; // [sp+74h] [bp-8Ch]@1
  int v81; // [sp+78h] [bp-88h]@1
  int v82; // [sp+7Ch] [bp-84h]@1
  int v83; // [sp+80h] [bp-80h]@1
  int v84; // [sp+84h] [bp-7Ch]@22
  int v85[14]; // [sp+88h] [bp-78h]@17
  int v86; // [sp+C0h] [bp-40h]@41
  int v87[15]; // [sp+C4h] [bp-3Ch]@24
  int v88; // [sp+108h] [bp+8h]@24

  v10 = 0;
  v11 = a1;
  v12 = a2;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v13 = a3;
  do
  {
    ++*(&v68 + *v12);
    ++v12;
    --v13;
  }
  while ( v13 );
  if ( v68 == a3 )
  {
    *a7 = 0;
    *v11 = 0;
    return 0;
  }
  v15 = 1;
  if ( !v69 )
  {
    do
      ++v15;
    while ( !*(&v68 + v15) );
  }
  v16 = v15;
  v51 = v15;
  if ( *v11 > v15 )
    v15 = *v11;
  v54 = v15;
  v17 = 15;
  if ( !v83 )
  {
    do
      --v17;
    while ( !*(&v68 + v17) );
  }
  v65 = v17;
  if ( (signed int)v15 > v17 )
  {
    v54 = v17;
    v15 = v17;
  }
  v18 = 1 << v16;
  *v11 = v15;
  for ( i = v16; i < v17; v18 = 2 * v20 )
  {
    v20 = v18 - *(&v68 + i);
    if ( v20 < 0 )
      return -3;
    ++i;
  }
  v21 = *(&v68 + v17);
  v22 = v18 - v21;
  v67 = v22;
  if ( v22 < 0 )
    return -3;
  v23 = v22 + v21;
  v24 = v17 - 1;
  v25 = 0;
  *(&v68 + v17) = v23;
  v85[0] = 0;
  if ( v17 != 1 )
  {
    v26 = 0;
    do
    {
      v25 += *(int *)((char *)&v69 + v26 * 4);
      ++v26;
      --v24;
      v85[v26] = v25;
    }
    while ( v24 );
  }
  v27 = a2;
  v28 = 0;
  do
  {
    v29 = *v27;
    ++v27;
    v57 = v27;
    if ( v29 )
    {
      v30 = *(&v84 + v29);
      a10[v30] = v28;
      v16 = v51;
      *(&v84 + v29) = v30 + 1;
      v27 = v57;
    }
    ++v28;
  }
  while ( v28 < a3 );
  v88 = *(&v84 + v17);
  v31 = -1;
  v32 = -v15;
  v84 = 0;
  k = 0;
  v64 = a10;
  v87[0] = 0;
  v63 = 0;
  v52 = 0;
  v55 = v16;
  if ( v16 > v17 )
  {
LABEL_60:
    if ( v67 && v17 != 1 )
      result = -5;
    else
      result = 0;
  }
  else
  {
    v33 = v62;
    v60 = &v68 + v16;
    while ( 1 )
    {
      v56 = *v60;
      if ( *v60 )
        break;
LABEL_59:
      v17 = v65;
      ++v60;
      v55 = ++v16;
      if ( v16 > v65 )
        goto LABEL_60;
    }
    while ( 1 )
    {
      --v56;
      v34 = v32 + v15;
      if ( (signed int)(v32 + v15) < v16 )
        break;
LABEL_44:
      BYTE1(v61) = v16 - v32;
      if ( v64 < &a10[v88] )
      {
        v33 = *v64;
        if ( *v64 >= a4 )
        {
          v46 = 4 * (v33 - a4);
          LOBYTE(v61) = *(_BYTE *)(v46 + a6) + 80;
          v33 = *(_DWORD *)(v46 + a5);
        }
        else
        {
          LOBYTE(v61) = v33 < 0x100 ? 0 : 96;
        }
        ++v64;
      }
      else
      {
        LOBYTE(v61) = -64;
      }
      v47 = 1 << (v16 - v32);
      v48 = v10 >> v32;
      if ( v10 >> v32 < v52 )
      {
        v49 = v63 + 8 * v48;
        do
        {
          *(_DWORD *)v49 = v61;
          *(_DWORD *)(v49 + 4) = v33;
          v48 += v47;
          v49 += 8 * v47;
        }
        while ( v48 < v52 );
        v10 = k;
      }
      for ( j = 1 << (v55 - 1); v10 & j; j >>= 1 )
        v10 ^= j;
      v10 ^= j;
      for ( k = v10; (v10 & ((1 << v32) - 1)) != *(&v84 + v31); --v31 )
        v32 -= v54;
      v15 = v54;
      v16 = v55;
      if ( !v56 )
        goto LABEL_59;
    }
    for ( l = v32 - v15; ; l = v58 )
    {
      v66 = v15 + v34;
      v32 += v15;
      ++v31;
      v36 = v65 - v32;
      v53 = v31;
      v58 = v15 + l;
      if ( v65 - v32 > v15 )
        v36 = v15;
      v37 = v16 - v32;
      if ( 1 << v37 > (unsigned int)(v56 + 1) )
      {
        v38 = v60;
        v39 = -1 - v56 + (1 << v37);
        if ( v37 < v36 )
        {
          while ( ++v37 < v36 )
          {
            v40 = v38[1];
            ++v38;
            v41 = 2 * v39;
            if ( v41 <= v40 )
              break;
            v39 = v41 - v40;
          }
        }
        v31 = v53;
      }
      v52 = 1 << v37;
      v42 = *a9 + (1 << v37);
      if ( v42 > 0x5A0 )
        break;
      v43 = a8 + 8 * *a9;
      *a9 = v42;
      v10 = k;
      v87[v31] = v43;
      v63 = v43;
      if ( v31 )
      {
        LOBYTE(v61) = v37;
        v44 = k >> v58;
        v45 = *(&v86 + v31);
        BYTE1(v61) = v54;
        v33 = ((v63 - v45) >> 3) - (k >> v58);
        *(_DWORD *)(v45 + 8 * v44) = v61;
        *(&v84 + v31) = k;
        *(_DWORD *)(v45 + 8 * v44 + 4) = v33;
      }
      else
      {
        *a7 = v43;
      }
      v34 = v66;
      v16 = v55;
      if ( v66 >= v55 )
        goto LABEL_44;
      v15 = v54;
    }
    result = -3;
  }
  return result;
}
// 10053490: using guessed type int var_78[14];
// 10053490: using guessed type int var_3C[15];

//----- (10053930) --------------------------------------------------------
int (__cdecl *__usercall sub_10053930@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax@3
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax@3

  if ( a1 )
    *a1 = *(_DWORD *)(a2 + 14124);
  v3 = *(_DWORD *)(a2 + 14104);
  *(_DWORD *)(a2 + 14112) = v3;
  *(_DWORD *)(a2 + 14116) = v3;
  result = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a2 + 14120);
  *(_BYTE *)a2 = 0;
  *(_DWORD *)(a2 + 1424) = 0;
  *(_DWORD *)(a2 + 1428) = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    *(_DWORD *)(a2 + 14124) = result;
    *(_DWORD *)(a3 + 28) = result;
  }
  return result;
}

//----- (10053980) --------------------------------------------------------
int __usercall sub_10053980@<eax>(int result@<eax>, char a2, char a3, int a4, int a5)
{
  *(_BYTE *)(result + 16) = a2;
  *(_BYTE *)(result + 17) = a3;
  *(_BYTE *)result = 0;
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(result + 24) = a5;
  return result;
}

//----- (100539A0) --------------------------------------------------------
signed int __cdecl sub_100539A0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // ebp@1
  unsigned int v7; // ecx@1
  unsigned int v8; // edx@1
  _BYTE *v9; // edi@1
  unsigned int v10; // eax@1
  int v11; // esi@6
  int v12; // ebx@8
  int v13; // esi@8
  int v14; // ecx@8
  int v15; // ecx@11
  int v16; // ebx@13
  unsigned int v17; // eax@13
  unsigned int v18; // edx@13
  int v19; // esi@14
  int v20; // ebx@16
  int v21; // esi@16
  unsigned int v22; // edx@16
  unsigned int v23; // eax@16
  int v24; // ecx@18
  int v25; // ecx@18
  int i; // ebx@19
  char v27; // cl@21
  int v28; // ebx@21
  int v29; // ecx@21
  int v30; // esi@22
  _BYTE *v31; // edi@22
  _BYTE *v32; // esi@22
  unsigned int v33; // ecx@23
  unsigned int v34; // ecx@32
  int v35; // ebp@34
  int v36; // ebx@34
  unsigned int v38; // ecx@35
  int v39; // ebp@37
  int v40; // ebx@37
  int v41; // esi@37
  int v42; // eax@37
  unsigned int v43; // ecx@38
  int v44; // ebp@41
  int v45; // ebx@41
  int v46; // ebp@44
  unsigned int v47; // [sp+10h] [bp-14h]@1
  unsigned int v48; // [sp+14h] [bp-10h]@2
  _BYTE *v49; // [sp+18h] [bp-Ch]@1
  int v50; // [sp+1Ch] [bp-8h]@4
  int v51; // [sp+20h] [bp-4h]@4
  unsigned int v52; // [sp+28h] [bp+4h]@21
  unsigned int v53; // [sp+2Ch] [bp+8h]@13
  int v54; // [sp+2Ch] [bp+8h]@24

  v6 = *(_BYTE **)a6;
  v7 = *(_DWORD *)(a5 + 14112);
  v8 = *(_DWORD *)(a5 + 1428);
  v9 = *(_BYTE **)(a5 + 14116);
  v47 = *(_DWORD *)(a6 + 4);
  v10 = *(_DWORD *)(a5 + 1424);
  v49 = *(_BYTE **)a6;
  if ( (unsigned int)v9 >= v7 )
    v48 = *(_DWORD *)(a5 + 14108) - (_DWORD)v9;
  else
    v48 = v7 - (_DWORD)v9 - 1;
  v50 = dword_100EC340[a1];
  v51 = dword_100EC340[a2];
  while ( 1 )
  {
    if ( v10 < 0x14 )
    {
      do
      {
        --v47;
        v11 = *v6 << v10;
        v10 += 8;
        ++v6;
        v8 |= v11;
      }
      while ( v10 < 0x14 );
      v49 = v6;
    }
    v12 = *(_BYTE *)(a3 + 8 * (v8 & v50));
    v13 = a3 + 8 * (v8 & v50);
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( v12 )
      break;
LABEL_29:
    v10 -= v14;
    *v9++ = *(_BYTE *)(v13 + 4);
    --v48;
LABEL_30:
    if ( v48 < 0x102 || v47 < 0xA )
    {
      v34 = *(_DWORD *)(a6 + 4) - v47;
      if ( v10 >> 3 < v34 )
        v34 = v10 >> 3;
      v35 = (int)&v6[-v34];
      *(_DWORD *)(a6 + 4) = v34 + v47;
      v36 = v35 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v35;
      *(_DWORD *)(a6 + 8) += v36;
      *(_DWORD *)(a5 + 14116) = v9;
      *(_DWORD *)(a5 + 1424) = v10 - 8 * v34;
      *(_DWORD *)(a5 + 1428) = v8;
      return 0;
    }
  }
  v10 -= *(_BYTE *)(v13 + 1);
  if ( v12 & 0x10 )
  {
LABEL_13:
    v16 = v12 & 0xF;
    v17 = v10 - v16;
    v53 = *(_DWORD *)(v13 + 4) + (v8 & dword_100EC340[v16]);
    v18 = v8 >> v16;
    if ( v17 < 0xF )
    {
      do
      {
        --v47;
        v19 = *v6 << v17;
        v17 += 8;
        ++v6;
        v18 |= v19;
      }
      while ( v17 < 0xF );
      v49 = v6;
    }
    v20 = *(_BYTE *)(a4 + 8 * (v18 & v51));
    v21 = a4 + 8 * (v18 & v51);
    v22 = v18 >> *(_BYTE *)(v21 + 1);
    v23 = v17 - *(_BYTE *)(v21 + 1);
    if ( !(v20 & 0x10) )
    {
      while ( !(v20 & 0x40) )
      {
        v24 = *(_DWORD *)(v21 + 4) + (v22 & dword_100EC340[v20]);
        v20 = *(_BYTE *)(v21 + 8 * v24);
        v21 += 8 * v24;
        v25 = *(_BYTE *)(v21 + 1);
        v22 >>= v25;
        v23 -= v25;
        if ( v20 & 0x10 )
          goto LABEL_19;
      }
      v38 = *(_DWORD *)(a6 + 4) - v47;
      if ( v23 >> 3 < v38 )
        v38 = v23 >> 3;
      v39 = (int)&v6[-v38];
      *(_DWORD *)(a6 + 4) = v38 + v47;
      v40 = v39 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v39;
      *(_DWORD *)(a6 + 8) += v40;
      v41 = a5;
      *(_DWORD *)(a5 + 1428) = v22;
      v42 = v23 - 8 * v38;
      goto LABEL_45;
    }
LABEL_19:
    for ( i = v20 & 0xF; v23 < (unsigned __int16)i; ++v49 )
    {
      --v47;
      v22 |= *v6 << v23;
      v6 = v49 + 1;
      v23 += 8;
    }
    v10 = v23 - i;
    v52 = *(_DWORD *)(v21 + 4) + (v22 & dword_100EC340[i]);
    v27 = i;
    v28 = v53;
    v48 -= v53;
    v8 = v22 >> v27;
    v29 = *(_DWORD *)(a5 + 14104);
    if ( (unsigned int)&v9[-v29] < v52 )
    {
      v33 = v52 + v29 - (_DWORD)v9;
      v32 = (_BYTE *)(*(_DWORD *)(a5 + 14108) - v33);
      if ( v53 > v33 )
      {
        v54 = v53 - v33;
        do
        {
          *v9++ = *v32++;
          --v33;
        }
        while ( v33 );
        v32 = *(_BYTE **)(a5 + 14104);
        v28 = v54;
      }
    }
    else
    {
      v30 = (int)&v9[-v52];
      v31 = v9 + 1;
      *(v31 - 1) = *(_BYTE *)v30;
      *v31 = *(_BYTE *)(v30 + 1);
      v9 = v31 + 1;
      v32 = (_BYTE *)(v30 + 2);
      v28 = v53 - 2;
    }
    do
    {
      *v9++ = *v32++;
      --v28;
    }
    while ( v28 );
    goto LABEL_30;
  }
  while ( !(v12 & 0x40) )
  {
    v15 = *(_DWORD *)(v13 + 4) + (v8 & dword_100EC340[v12]);
    v12 = *(_BYTE *)(v13 + 8 * v15);
    v13 += 8 * v15;
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( !v12 )
      goto LABEL_29;
    v10 -= *(_BYTE *)(v13 + 1);
    if ( v12 & 0x10 )
      goto LABEL_13;
  }
  v43 = *(_DWORD *)(a6 + 4) - v47;
  if ( !(v12 & 0x20) )
  {
    if ( v10 >> 3 < v43 )
      v43 = v10 >> 3;
    v46 = (int)&v6[-v43];
    *(_DWORD *)(a6 + 4) = v43 + v47;
    *(_DWORD *)(a6 + 8) += v46 - *(_DWORD *)a6;
    *(_DWORD *)a6 = v46;
    v41 = a5;
    *(_DWORD *)(a5 + 1428) = v8;
    v42 = v10 - 8 * v43;
LABEL_45:
    *(_DWORD *)(v41 + 14116) = v9;
    *(_DWORD *)(v41 + 1424) = v42;
    return -3;
  }
  if ( v10 >> 3 < v43 )
    v43 = v10 >> 3;
  *(_DWORD *)(a6 + 4) = v43 + v47;
  v44 = (int)&v6[-v43];
  v45 = v44 - *(_DWORD *)a6;
  *(_DWORD *)a6 = v44;
  *(_DWORD *)(a6 + 8) += v45;
  *(_DWORD *)(a5 + 1428) = v8;
  *(_DWORD *)(a5 + 14116) = v9;
  *(_DWORD *)(a5 + 1424) = v10 - 8 * v43;
  return 1;
}
// 100EC340: using guessed type int dword_100EC340[];

//----- (10053D50) --------------------------------------------------------
int __usercall sub_10053D50@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  const void *v3; // ebx@1
  unsigned int v4; // ebp@1
  size_t v5; // eax@3
  size_t v6; // ebp@3
  int (__cdecl *v7)(_DWORD, const void *, size_t); // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int v10; // ebx@10
  const void *v11; // ebx@11
  size_t v12; // eax@13
  size_t v13; // ebp@13
  int (__cdecl *v14)(_DWORD, const void *, size_t); // eax@15
  int v15; // eax@16
  int result; // eax@18
  void *v17; // [sp+8h] [bp-4h]@1
  char *v18; // [sp+8h] [bp-4h]@10

  v3 = *(const void **)(a2 + 14112);
  v4 = *(_DWORD *)(a2 + 14116);
  v17 = *(void **)(a1 + 12);
  if ( (unsigned int)v3 > v4 )
    v4 = *(_DWORD *)(a2 + 14108);
  v5 = *(_DWORD *)(a1 + 16);
  v6 = v4 - (_DWORD)v3;
  if ( v6 > v5 )
    v6 = *(_DWORD *)(a1 + 16);
  if ( v6 && a3 == -5 )
    a3 = 0;
  *(_DWORD *)(a1 + 20) += v6;
  *(_DWORD *)(a1 + 16) = v5 - v6;
  v7 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
  if ( v7 )
  {
    v8 = v7(*(_DWORD *)(a2 + 14124), v3, v6);
    *(_DWORD *)(a2 + 14124) = v8;
    *(_DWORD *)(a1 + 28) = v8;
  }
  memcpy_0(v17, v3, v6);
  v9 = *(_DWORD *)(a2 + 14108);
  v18 = (char *)v17 + v6;
  v10 = (int)v3 + v6;
  if ( v10 == v9 )
  {
    v11 = *(const void **)(a2 + 14104);
    if ( *(_DWORD *)(a2 + 14116) == v9 )
      *(_DWORD *)(a2 + 14116) = v11;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a2 + 14116) - (_DWORD)v11;
    if ( v13 > v12 )
      v13 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) += v13;
    *(_DWORD *)(a1 + 16) = v12 - v13;
    v14 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
    if ( v14 )
    {
      v15 = v14(*(_DWORD *)(a2 + 14124), v11, v13);
      *(_DWORD *)(a2 + 14124) = v15;
      *(_DWORD *)(a1 + 28) = v15;
    }
    memcpy_0(v18, v11, v13);
    v18 += v13;
    v10 = (int)v11 + v13;
  }
  *(_DWORD *)(a1 + 12) = v18;
  result = a3;
  *(_DWORD *)(a2 + 14112) = v10;
  return result;
}

//----- (10053E90) --------------------------------------------------------
signed int __usercall sub_10053E90@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4)
{
  signed int result; // eax@1
  int v5; // [sp+0h] [bp-50h]@1
  char v6; // [sp+4h] [bp-4Ch]@1

  v5 = 0;
  result = sub_10053490(a2, a3, 0x13u, 19, 0, 0, a4, a1, (unsigned int *)&v5, (unsigned int *)&v6);
  if ( result == -5 || !*a2 )
    result = -3;
  return result;
}

//----- (10053EE0) --------------------------------------------------------
signed int __usercall sub_10053EE0@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9)
{
  unsigned int *v9; // edi@1
  signed int result; // eax@6
  int v11; // [sp+8h] [bp-4h]@1

  v9 = a1;
  v11 = 0;
  if ( sub_10053490(a7, a6, a4, 257, (int)&unk_100EC3D8, (int)&unk_100EC458, a2, a3, (unsigned int *)&v11, a1)
    || !*a7
    || sub_10053490(a8, &a6[a4], a5, 0, (int)&unk_100EC4D8, (int)&unk_100EC550, a9, a3, (unsigned int *)&v11, v9)
    || !*a8 && a4 > 0x101 )
  {
    result = -3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10053F80) --------------------------------------------------------
int __usercall sub_10053F80@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4)
{
  *a1 = 9;
  *a3 = 5;
  *a2 = &unk_100EC5C8;
  *a4 = &unk_100ED5C8;
  return 0;
}

//----- (10053FA0) --------------------------------------------------------
signed int __cdecl sub_10053FA0(int a1)
{
  signed int result; // eax@2
  int v2; // ecx@3
  int v3; // esi@3

  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    v3 = *(_DWORD *)(v2 + 20);
    *(_BYTE *)v2 = *(_DWORD *)(v2 + 12) != 0 ? 7 : 0;
    sub_10053930(0, v3, a1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10053FB0) --------------------------------------------------------
int __usercall sub_10053FB0@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // edi@1
  _BYTE *v4; // ebx@1
  int v5; // esi@1
  _BYTE *v6; // edx@1
  unsigned int v7; // ebp@1
  unsigned int v8; // eax@1
  unsigned int v9; // eax@2
  unsigned int v10; // ecx@4
  int v11; // ecx@8
  signed int v12; // eax@8
  int v13; // ecx@8
  unsigned int v14; // eax@8
  int v15; // ecx@13
  int v16; // eax@16
  int v17; // eax@17
  int v18; // ecx@17
  int v19; // eax@17
  int v20; // eax@27
  int v21; // eax@28
  int v22; // ecx@28
  int v23; // ecx@28
  int v24; // eax@31
  int v25; // eax@32
  int v26; // ecx@32
  int v27; // eax@32
  int v28; // eax@38
  int v29; // eax@39
  int v30; // ecx@39
  int v31; // ecx@40
  int v32; // eax@41
  unsigned int v33; // eax@46
  unsigned int v34; // ecx@46
  int v35; // eax@51
  unsigned int v36; // eax@51
  unsigned int v37; // ecx@55
  unsigned int v38; // eax@55
  bool v39; // zf@61
  unsigned int v40; // eax@67
  unsigned int v41; // ecx@67
  int v42; // eax@72
  unsigned int v43; // eax@72
  unsigned int v44; // ecx@76
  unsigned int v45; // eax@76
  int v47; // eax@91
  int v48; // ecx@93
  int v49; // eax@97
  int v50; // ecx@98
  int v51; // eax@101
  int v52; // [sp-4h] [bp-2Ch]@85
  unsigned int v53; // [sp+10h] [bp-18h]@1
  unsigned int v54; // [sp+14h] [bp-14h]@1
  unsigned int v55; // [sp+18h] [bp-10h]@4
  unsigned int v56; // [sp+18h] [bp-10h]@54
  unsigned int v57; // [sp+18h] [bp-10h]@75
  _BYTE *v58; // [sp+20h] [bp-8h]@43
  int v59; // [sp+2Ch] [bp+4h]@51

  v3 = a1;
  v4 = *(_BYTE **)a1;
  v5 = a2;
  v6 = *(_BYTE **)(a2 + 14116);
  v7 = *(_DWORD *)(a2 + 1424);
  v54 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)(a2 + 14112);
  v53 = *(_DWORD *)(a2 + 1428);
  if ( (unsigned int)v6 >= v8 )
    v9 = *(_DWORD *)(a2 + 14108) - (_DWORD)v6;
  else
    v9 = v8 - (_DWORD)v6 - 1;
  v10 = *(_BYTE *)(a2 + 4);
  v55 = v9;
  while ( 2 )
  {
    switch ( v10 )
    {
      case 0u:
        if ( v9 >= 0x102 && v54 >= 0xA )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v11 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v11;
          *(_DWORD *)(v5 + 1428) = v53;
          *(_DWORD *)(v5 + 1424) = v7;
          *(_DWORD *)(v5 + 14116) = v6;
          v12 = sub_100539A0(
                  *(_BYTE *)(v5 + 20),
                  *(_BYTE *)(v5 + 21),
                  *(_DWORD *)(v5 + 24),
                  *(_DWORD *)(v5 + 28),
                  v5,
                  v3);
          v4 = *(_BYTE **)v3;
          v7 = *(_DWORD *)(v5 + 1424);
          v13 = v12;
          v54 = *(_DWORD *)(v3 + 4);
          v6 = *(_BYTE **)(v5 + 14116);
          v53 = *(_DWORD *)(v5 + 1428);
          v14 = *(_DWORD *)(v5 + 14112);
          a3 = v13;
          v9 = (unsigned int)v6 >= v14 ? *(_DWORD *)(v5 + 14108) - (_DWORD)v6 : v14 - (_DWORD)v6 - 1;
          v55 = v9;
          if ( v13 )
          {
            *(_BYTE *)(v5 + 4) = 2 * (v13 != 1) + 7;
            goto LABEL_84;
          }
        }
        v15 = *(_DWORD *)(v5 + 24);
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 20);
        *(_DWORD *)(v5 + 12) = v15;
        *(_BYTE *)(v5 + 4) = 1;
        goto LABEL_14;
      case 1u:
LABEL_14:
        if ( v7 >= *(_WORD *)(v5 + 16) )
          goto LABEL_17;
        do
        {
          if ( !v54 )
            goto LABEL_91;
          --v54;
          v16 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v16;
        }
        while ( v7 < *(_WORD *)(v5 + 16) );
LABEL_17:
        v17 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100EC340[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v17 + 1);
        v18 = v17;
        v7 -= *(_BYTE *)(v17 + 1);
        v19 = *(_BYTE *)v17;
        if ( v19 )
        {
          if ( v19 & 0x10 )
          {
            *(_DWORD *)(v5 + 12) = v19 & 0xF;
            *(_DWORD *)(v5 + 8) = *(_DWORD *)(v18 + 4);
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 2;
          }
          else if ( v19 & 0x40 )
          {
            if ( !(v19 & 0x20) )
              goto LABEL_92;
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 7;
          }
          else
          {
            *(_DWORD *)(v5 + 16) = v19;
            v9 = v55;
            *(_DWORD *)(v5 + 12) = v18 + 8 * *(_DWORD *)(v18 + 4);
          }
        }
        else
        {
          v9 = v55;
          *(_DWORD *)(v5 + 12) = *(_DWORD *)(v18 + 4);
          *(_BYTE *)(v5 + 4) = 6;
        }
        goto LABEL_84;
      case 2u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_28;
        do
        {
          if ( !v54 )
            goto LABEL_93;
          --v54;
          v20 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v20;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_28:
        v21 = *(_DWORD *)(v5 + 12);
        v22 = v53 & dword_100EC340[v21];
        *(_BYTE *)(v5 + 4) = 3;
        *(_DWORD *)(v5 + 8) += v22;
        v53 >>= v21;
        v23 = *(_DWORD *)(v5 + 28);
        v7 -= v21;
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 21);
        *(_DWORD *)(v5 + 12) = v23;
LABEL_29:
        if ( v7 < *(_WORD *)(v5 + 16) )
        {
          while ( v54 )
          {
            --v54;
            v24 = *v4 << v7;
            v7 += 8;
            ++v4;
            a3 = 0;
            v53 |= v24;
            if ( v7 >= *(_WORD *)(v5 + 16) )
              goto LABEL_32;
          }
LABEL_91:
          v47 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)(v3 + 4) = 0;
          *(_DWORD *)(v3 + 8) += v47;
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v5 + 14116) = v6;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = a3;
          goto LABEL_90;
        }
LABEL_32:
        v25 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100EC340[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v25 + 1);
        v26 = v25;
        v7 -= *(_BYTE *)(v25 + 1);
        v27 = *(_BYTE *)v25;
        if ( v27 & 0x10 )
        {
          *(_DWORD *)(v5 + 12) = v27 & 0xF;
          v9 = v55;
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(v26 + 4);
          *(_BYTE *)(v5 + 4) = 4;
        }
        else
        {
          if ( v27 & 0x40 )
          {
LABEL_92:
            *(_BYTE *)(v5 + 4) = 9;
            v52 = -3;
            goto LABEL_86;
          }
          *(_DWORD *)(v5 + 16) = v27;
          v9 = v55;
          *(_DWORD *)(v5 + 12) = v26 + 8 * *(_DWORD *)(v26 + 4);
        }
        goto LABEL_84;
      case 3u:
        goto LABEL_29;
      case 4u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_39;
        do
        {
          if ( !v54 )
          {
LABEL_93:
            v48 = (int)&v4[-*(_DWORD *)v3];
            *(_DWORD *)(v3 + 4) = 0;
            *(_DWORD *)(v3 + 8) += v48;
            v52 = a3;
            goto LABEL_88;
          }
          --v54;
          v28 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v28;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_39:
        v29 = *(_DWORD *)(v5 + 12);
        v30 = v53 & dword_100EC340[v29];
        *(_BYTE *)(v5 + 4) = 5;
        *(_DWORD *)(v5 + 16) += v30;
        v53 >>= v29;
        v7 -= v29;
LABEL_40:
        v31 = *(_DWORD *)(v5 + 16);
        if ( (signed int)&v6[-*(_DWORD *)(v5 + 14104)] >= v31 )
          v32 = (int)&v6[-v31];
        else
          v32 = (int)&v6[*(_DWORD *)(v5 + 14108) - v31 - *(_DWORD *)(v5 + 14104)];
        v58 = (_BYTE *)v32;
        v9 = v55;
        if ( !*(_DWORD *)(v5 + 8) )
        {
LABEL_83:
          *(_BYTE *)(v5 + 4) = 0;
LABEL_84:
          v10 = *(_BYTE *)(v5 + 4);
          if ( v10 > 9 )
          {
LABEL_85:
            v52 = -2;
LABEL_86:
            *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
            goto LABEL_87;
          }
          continue;
        }
        while ( 1 )
        {
          if ( !v9 )
          {
            if ( v6 != *(_BYTE **)(v5 + 14108)
              || (v33 = *(_DWORD *)(v5 + 14112), v34 = *(_DWORD *)(v5 + 14104), v33 == v34)
              || ((v6 = *(_BYTE **)(v5 + 14104), v34 >= v33) ? (v9 = *(_DWORD *)(v5 + 14108) - v34) : (v9 = v33 - v34 - 1),
                  !v9) )
            {
              *(_DWORD *)(v5 + 14116) = v6;
              v35 = sub_10053D50(v3, v5, a3);
              v6 = *(_BYTE **)(v5 + 14116);
              v59 = v35;
              v36 = *(_DWORD *)(v5 + 14112);
              if ( (unsigned int)v6 >= v36 )
                v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
              else
                v9 = v36 - (_DWORD)v6 - 1;
              v56 = v9;
              if ( v6 == *(_BYTE **)(v5 + 14108) )
              {
                v37 = *(_DWORD *)(v5 + 14104);
                v38 = *(_DWORD *)(v5 + 14112);
                if ( v38 == v37 )
                {
                  v9 = v56;
                }
                else
                {
                  v6 = *(_BYTE **)(v5 + 14104);
                  if ( v37 >= v38 )
                    v9 = *(_DWORD *)(v5 + 14108) - v37;
                  else
                    v9 = v38 - v37 - 1;
                }
              }
              if ( !v9 )
                break;
            }
          }
          *v6 = *v58;
          --v9;
          ++v6;
          v39 = v58 + 1 == *(_BYTE **)(v5 + 14108);
          a3 = 0;
          v55 = v9;
          ++v58;
          if ( v39 )
            v58 = *(_BYTE **)(v5 + 14104);
          if ( !--*(_DWORD *)(v5 + 8) )
            goto LABEL_83;
        }
LABEL_94:
        *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
        v52 = v59;
LABEL_87:
        *(_DWORD *)(v3 + 4) = v54;
LABEL_88:
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
LABEL_89:
        *(_DWORD *)(v5 + 14116) = v6;
LABEL_90:
        *(_DWORD *)(v5 + 1424) = v7;
        return sub_10053D50(v3, v5, v52);
      case 5u:
        goto LABEL_40;
      case 6u:
        if ( !v9 )
        {
          if ( v6 != *(_BYTE **)(v5 + 14108)
            || (v40 = *(_DWORD *)(v5 + 14112), v41 = *(_DWORD *)(v5 + 14104), v40 == v41)
            || ((v6 = *(_BYTE **)(v5 + 14104), v41 >= v40) ? (v9 = *(_DWORD *)(v5 + 14108) - v41) : (v9 = v40 - v41 - 1),
                !v9) )
          {
            *(_DWORD *)(v5 + 14116) = v6;
            v42 = sub_10053D50(v3, v5, a3);
            v6 = *(_BYTE **)(v5 + 14116);
            v59 = v42;
            v43 = *(_DWORD *)(v5 + 14112);
            if ( (unsigned int)v6 >= v43 )
              v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
            else
              v9 = v43 - (_DWORD)v6 - 1;
            v57 = v9;
            if ( v6 == *(_BYTE **)(v5 + 14108) )
            {
              v44 = *(_DWORD *)(v5 + 14104);
              v45 = *(_DWORD *)(v5 + 14112);
              if ( v45 == v44 )
              {
                v9 = v57;
              }
              else
              {
                v6 = *(_BYTE **)(v5 + 14104);
                if ( v44 >= v45 )
                  v9 = *(_DWORD *)(v5 + 14108) - v44;
                else
                  v9 = v45 - v44 - 1;
              }
            }
            if ( !v9 )
              goto LABEL_94;
          }
        }
        *v6++ = *(_BYTE *)(v5 + 12);
        --v9;
        a3 = 0;
        v55 = v9;
        goto LABEL_83;
      case 7u:
        if ( v7 > 7 )
        {
          ++v54;
          v7 -= 8;
          --v4;
        }
        *(_DWORD *)(v5 + 14116) = v6;
        v49 = sub_10053D50(v3, v5, a3);
        v6 = *(_BYTE **)(v5 + 14116);
        if ( *(_BYTE **)(v5 + 14112) != v6 )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v50 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v50;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = v49;
          goto LABEL_89;
        }
        *(_BYTE *)(v5 + 4) = 8;
LABEL_100:
        v52 = 1;
        goto LABEL_86;
      case 8u:
        goto LABEL_100;
      case 9u:
        v51 = (int)&v4[-*(_DWORD *)v3];
        *(_DWORD *)(v3 + 4) = v54;
        *(_DWORD *)(v3 + 8) += v51;
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
        v52 = -3;
        goto LABEL_89;
      default:
        goto LABEL_85;
    }
  }
}
// 100EC340: using guessed type int dword_100EC340[];

//----- (10054650) --------------------------------------------------------
int __usercall sub_10054650@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // edx@1
  unsigned int v5; // ebx@1
  unsigned int v6; // esi@1
  int v7; // edi@1
  size_t v8; // ecx@1
  char *v9; // eax@1
  char *v10; // ecx@1
  int v11; // edx@2
  unsigned int v12; // edx@4
  int v13; // edx@8
  unsigned int v14; // eax@9
  int v15; // eax@10
  int v16; // ebx@14
  int v17; // ecx@14
  int v18; // edx@17
  char *v19; // edx@24
  unsigned int v20; // eax@25
  unsigned int v21; // ecx@25
  int v22; // eax@27
  int v23; // eax@30
  unsigned int v24; // ecx@30
  int v25; // edx@31
  char *v26; // esi@33
  unsigned int v27; // edx@34
  size_t v28; // esi@39
  bool v29; // zf@43
  int v30; // edx@47
  int v31; // ecx@48
  int v32; // edx@54
  unsigned int v33; // ecx@61
  int v34; // edx@63
  int v35; // edx@64
  int v36; // ecx@64
  unsigned int v37; // edx@64
  int v38; // edx@71
  unsigned int v39; // esi@72
  unsigned int v40; // ecx@72
  unsigned int *v41; // eax@77
  unsigned int v42; // esi@81
  int v43; // eax@81
  int v44; // edx@83
  char *v45; // ecx@84
  unsigned int v46; // eax@84
  int v47; // eax@85
  char *v48; // eax@91
  int v49; // ecx@92
  int v50; // ecx@94
  int v51; // edx@96
  int v52; // edx@97
  int v53; // edx@99
  int v55; // eax@102
  int v56; // edx@103
  int v57; // edx@106
  int v58; // [sp-4h] [bp-3Ch]@91
  size_t v59; // [sp+10h] [bp-28h]@1
  char *v60; // [sp+14h] [bp-24h]@1
  char *v61; // [sp+18h] [bp-20h]@1
  unsigned int v62; // [sp+1Ch] [bp-1Ch]@4
  int v63; // [sp+1Ch] [bp-1Ch]@69
  int v64; // [sp+1Ch] [bp-1Ch]@72
  unsigned int v65; // [sp+20h] [bp-18h]@1
  unsigned int v66; // [sp+24h] [bp-14h]@13
  unsigned int v67; // [sp+28h] [bp-10h]@13
  int v68; // [sp+2Ch] [bp-Ch]@13
  int v69; // [sp+30h] [bp-8h]@13
  unsigned int v70; // [sp+34h] [bp-4h]@69
  unsigned int v71; // [sp+3Ch] [bp+4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 14112);
  v5 = *(_DWORD *)(a2 + 1424);
  v6 = *(_DWORD *)(a2 + 1428);
  v7 = a1;
  v8 = *(_DWORD *)(a1 + 4);
  v9 = *(char **)a1;
  v59 = v8;
  v10 = *(char **)(a2 + 14116);
  v61 = v9;
  v71 = *(_DWORD *)(a2 + 1428);
  v65 = v5;
  v60 = v10;
  if ( (unsigned int)v10 >= v4 )
    v11 = *(_DWORD *)(v3 + 14108) - (_DWORD)v10;
  else
    v11 = v4 - (_DWORD)v10 - 1;
  v62 = v11;
  v12 = *(_BYTE *)v3;
  while ( 2 )
  {
    switch ( v12 )
    {
      case 0u:
        for ( ; v5 < 3; v71 = v6 )
        {
          if ( !v59 )
            goto LABEL_91;
          --v59;
          a3 = 0;
          v13 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v13;
        }
        v14 = (v6 & 7) >> 1;
        *(_DWORD *)(v3 + 1420) = v6 & 1;
        if ( !v14 )
        {
          v16 = v5 - 3;
          v17 = v16 & 7;
          v5 = v16 - v17;
          v65 = v5;
          *(_BYTE *)v3 = 1;
          v71 = v6 >> 3 >> v17;
          goto LABEL_89;
        }
        v15 = v14 - 1;
        if ( !v15 )
        {
          sub_10053F80(&v67, &v69, &v66, &v68);
          sub_10053980(v3 + 4, v67, v66, v69, v68);
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 6;
          goto LABEL_89;
        }
        if ( v15 == 1 )
        {
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 3;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 9;
        v49 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v49;
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v3 + 1428) = v71 >> 3;
        v5 -= 3;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      case 1u:
        if ( v5 >= 0x20 )
          goto LABEL_18;
        do
        {
          if ( !v59 )
          {
LABEL_91:
            v48 = v61;
            *(_DWORD *)(v7 + 4) = 0;
            *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
            v58 = a3;
            goto LABEL_110;
          }
          --v59;
          a3 = 0;
          v18 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v18;
          v71 = v6;
        }
        while ( v5 < 0x20 );
LABEL_18:
        if ( ~v6 >> 16 != (unsigned __int16)v6 )
          goto LABEL_93;
        v5 = 0;
        *(_DWORD *)(v3 + 4) = (unsigned __int16)v6;
        v65 = 0;
        v71 = 0;
        if ( (_WORD)v6 )
          *(_BYTE *)v3 = 2;
        else
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
LABEL_89:
        v12 = *(_BYTE *)v3;
        if ( v12 <= 9 )
        {
          v10 = v60;
          v9 = v61;
          v6 = v71;
          continue;
        }
LABEL_107:
        v58 = -2;
        goto LABEL_108;
      case 2u:
        if ( !v59 )
          goto LABEL_94;
        if ( !v62 )
        {
          if ( (v19 = *(char **)(v3 + 14108), v60 != v19)
            || (v20 = *(_DWORD *)(v3 + 14112), v21 = *(_DWORD *)(v3 + 14104), v21 == v20)
            || ((v60 = *(char **)(v3 + 14104), v21 >= v20) ? (v22 = (int)&v19[-v21], v62 = (unsigned int)&v19[-v21]) : (v22 = v20 - v21 - 1, v62 = v22),
                !v22) )
          {
            *(_DWORD *)(v3 + 14116) = v60;
            v23 = sub_10053D50(v7, v3, a3);
            v24 = *(_DWORD *)(v3 + 14112);
            v60 = *(char **)(v3 + 14116);
            if ( *(_DWORD *)(v3 + 14116) >= v24 )
              v25 = *(_DWORD *)(v3 + 14108) - (_DWORD)v60;
            else
              v25 = v24 - (_DWORD)v60 - 1;
            v26 = *(char **)(v3 + 14108);
            v62 = v25;
            if ( v60 == v26 )
            {
              v27 = *(_DWORD *)(v3 + 14104);
              if ( v27 != v24 )
              {
                v60 = *(char **)(v3 + 14104);
                if ( v27 >= v24 )
                  v62 = (unsigned int)&v26[-v27];
                else
                  v62 = v24 - v27 - 1;
              }
            }
            if ( !v62 )
              goto LABEL_96;
          }
        }
        v28 = *(_DWORD *)(v3 + 4);
        a3 = 0;
        if ( v28 > v59 )
          v28 = v59;
        if ( v28 > v62 )
          v28 = v62;
        memcpy_0(v60, v61, v28);
        v61 += v28;
        v59 -= v28;
        v60 += v28;
        v62 -= v28;
        v29 = *(_DWORD *)(v3 + 4) == v28;
        *(_DWORD *)(v3 + 4) -= v28;
        if ( v29 )
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
        goto LABEL_89;
      case 3u:
        if ( v5 >= 0xE )
          goto LABEL_48;
        break;
      case 4u:
        goto LABEL_51;
      case 5u:
        goto LABEL_60;
      case 6u:
        goto LABEL_83;
      case 7u:
        goto LABEL_102;
      case 8u:
        goto LABEL_105;
      case 9u:
        v57 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v7 + 8) += v57;
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      default:
        goto LABEL_107;
    }
    break;
  }
  do
  {
    if ( !v59 )
      goto LABEL_94;
    --v59;
    v30 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v30;
    v71 = v6;
    v61 = v9;
  }
  while ( v5 < 0xE );
LABEL_48:
  v31 = v6 & 0x3FFF;
  *(_DWORD *)(v3 + 4) = v31;
  if ( (v6 & 0x1F) > 0x1D || (v6 & 0x3E0) > 0x3A0 )
  {
LABEL_93:
    *(_BYTE *)v3 = 9;
    v58 = -3;
LABEL_108:
    *(_DWORD *)(v7 + 4) = v59;
LABEL_109:
    v48 = v61;
    *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
    goto LABEL_110;
  }
  v6 >>= 14;
  v5 -= 14;
  v71 = v6;
  v65 = v5;
  *(_DWORD *)(v3 + 8) = 0;
  *(_BYTE *)v3 = 4;
LABEL_51:
  if ( *(_DWORD *)(v3 + 8) < (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
  {
    while ( v5 >= 3 )
    {
LABEL_55:
      *(_DWORD *)(v3 + 4 * dword_100EC388[(*(_DWORD *)(v3 + 8))++] + 12) = v6 & 7;
      v6 >>= 3;
      v5 -= 3;
      v71 = v6;
      v65 = v5;
      if ( *(_DWORD *)(v3 + 8) >= (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
        goto LABEL_56;
    }
    while ( v59 )
    {
      --v59;
      v32 = (unsigned __int8)*v9++ << v5;
      v5 += 8;
      a3 = 0;
      v6 |= v32;
      v71 = v6;
      v61 = v9;
      if ( v5 >= 3 )
        goto LABEL_55;
    }
    goto LABEL_94;
  }
LABEL_56:
  while ( *(_DWORD *)(v3 + 8) < 0x13u )
    *(_DWORD *)(v3 + 4 * dword_100EC388[(*(_DWORD *)(v3 + 8))++] + 12) = 0;
  *(_DWORD *)(v3 + 1412) = 7;
  v23 = sub_10053E90(v3 + 1432, (unsigned int *)(v3 + 1412), (_DWORD *)(v3 + 12), (int *)(v3 + 1416));
  if ( v23 )
  {
    *(_BYTE *)v3 = 9;
LABEL_96:
    *(_DWORD *)(v7 + 4) = v59;
    v51 = (int)&v61[-*(_DWORD *)v7];
    *(_DWORD *)v7 = v61;
    *(_DWORD *)(v7 + 8) += v51;
    *(_DWORD *)(v3 + 1428) = v71;
    *(_DWORD *)(v3 + 14116) = v60;
    v58 = v23;
    goto LABEL_111;
  }
  v6 = v71;
  *(_DWORD *)(v3 + 8) = 0;
  v9 = v61;
  *(_BYTE *)v3 = 5;
LABEL_60:
  if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
  {
LABEL_81:
    v42 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 1416) = 0;
    v67 = 9;
    v66 = 6;
    v43 = sub_10053EE0(
            (unsigned int *)(v3 + 12952),
            &v69,
            v3 + 1432,
            (v42 & 0x1F) + 257,
            ((v42 >> 5) & 0x1F) + 1,
            (_DWORD *)(v3 + 12),
            &v67,
            &v66,
            &v68);
    if ( v43 )
    {
      *(_BYTE *)v3 = 9;
      *(_DWORD *)(v7 + 4) = v59;
      v53 = (int)&v61[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v61;
      *(_DWORD *)(v7 + 8) += v53;
      *(_DWORD *)(v3 + 1428) = v71;
      *(_DWORD *)(v3 + 1424) = v65;
      *(_DWORD *)(v3 + 14116) = v60;
    }
    else
    {
      sub_10053980(v3 + 4, v67, v66, v69, v68);
      v5 = v65;
      v10 = v60;
      v9 = v61;
      v6 = v71;
      *(_BYTE *)v3 = 6;
LABEL_83:
      *(_DWORD *)(v7 + 4) = v59;
      v44 = (int)&v9[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 8) += v44;
      *(_DWORD *)(v3 + 14116) = v10;
      *(_DWORD *)(v3 + 1428) = v6;
      *(_DWORD *)(v3 + 1424) = v5;
      v43 = sub_10053FB0(v7, v3, a3);
      if ( v43 == 1 )
      {
        v5 = *(_DWORD *)(v3 + 1424);
        v61 = *(char **)v7;
        v45 = *(char **)(v3 + 14116);
        v71 = *(_DWORD *)(v3 + 1428);
        v46 = *(_DWORD *)(v3 + 14112);
        a3 = 0;
        v59 = *(_DWORD *)(v7 + 4);
        v65 = *(_DWORD *)(v3 + 1424);
        v60 = v45;
        if ( (unsigned int)v45 >= v46 )
          v47 = *(_DWORD *)(v3 + 14108) - (_DWORD)v45;
        else
          v47 = v46 - (_DWORD)v45 - 1;
        v62 = v47;
        if ( !*(_DWORD *)(v3 + 1420) )
        {
          *(_BYTE *)v3 = 0;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 7;
LABEL_102:
        *(_DWORD *)(v3 + 14116) = v60;
        v55 = sub_10053D50(v7, v3, a3);
        v60 = *(char **)(v3 + 14116);
        if ( *(_DWORD *)(v3 + 14112) != *(_DWORD *)(v3 + 14116) )
        {
          *(_DWORD *)(v7 + 4) = v59;
          v56 = (int)&v61[-*(_DWORD *)v7];
          *(_DWORD *)v7 = v61;
          *(_DWORD *)(v7 + 8) += v56;
          *(_DWORD *)(v3 + 1428) = v71;
          *(_DWORD *)(v3 + 1424) = v5;
          *(_DWORD *)(v3 + 14116) = v60;
          return sub_10053D50(v7, v3, v55);
        }
        *(_BYTE *)v3 = 8;
LABEL_105:
        *(_DWORD *)(v7 + 4) = v59;
        v58 = 1;
        goto LABEL_109;
      }
    }
    return sub_10053D50(v7, v3, v43);
  }
  while ( 1 )
  {
    v33 = *(_WORD *)(v3 + 1412);
    v67 = *(_WORD *)(v3 + 1412);
    if ( v5 < v33 )
      break;
LABEL_64:
    v35 = *(_DWORD *)(v3 + 1416) + 8 * (v6 & dword_100EC340[*(_DWORD *)(v3 + 1412)]);
    v36 = *(_BYTE *)(v35 + 1);
    v37 = *(_DWORD *)(v35 + 4);
    v66 = v37;
    if ( v37 >= 0x10 )
    {
      if ( v37 == 18 )
        v67 = 7;
      else
        v67 = v37 - 14;
      v63 = 8 * (v37 == 18) + 3;
      v70 = (unsigned __int16)(v36 + v67);
      if ( v5 < v70 )
      {
        while ( v59 )
        {
          --v59;
          v38 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          a3 = 0;
          v6 |= v38;
          v71 = v6;
          v61 = v9;
          if ( v5 >= v70 )
            goto LABEL_72;
        }
        v52 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v52;
        *(_DWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = a3;
        goto LABEL_111;
      }
LABEL_72:
      v39 = v6 >> v36;
      v64 = (v39 & dword_100EC340[v67]) + v63;
      v6 = v39 >> v67;
      v5 -= v36 + v67;
      v40 = *(_DWORD *)(v3 + 8);
      v71 = v6;
      v65 = v5;
      if ( v40 + v64 > ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
        goto LABEL_98;
      if ( v66 == 16 )
      {
        if ( v40 < 1 )
        {
LABEL_98:
          *(_BYTE *)v3 = 9;
          *(_DWORD *)(v7 + 4) = v59;
          v58 = -3;
          goto LABEL_109;
        }
        v66 = *(_DWORD *)(v3 + 4 * v40 + 8);
      }
      else
      {
        v66 = 0;
      }
      v41 = (unsigned int *)(v3 + 4 * v40 + 12);
      do
      {
        *v41 = v66;
        ++v40;
        ++v41;
        --v64;
      }
      while ( v64 );
      v9 = v61;
      *(_DWORD *)(v3 + 8) = v40;
    }
    else
    {
      v6 >>= v36;
      v5 -= v36;
      *(_DWORD *)(v3 + 4 * (*(_DWORD *)(v3 + 8))++ + 12) = v37;
      v71 = v6;
      v65 = v5;
    }
    if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
      goto LABEL_81;
  }
  while ( v59 )
  {
    --v59;
    v34 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v34;
    v71 = v6;
    v61 = v9;
    if ( v5 >= v67 )
      goto LABEL_64;
  }
LABEL_94:
  v48 = v61;
  v50 = (int)&v61[-*(_DWORD *)v7];
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) += v50;
  v58 = a3;
LABEL_110:
  *(_DWORD *)v7 = v48;
  *(_DWORD *)(v3 + 14116) = v60;
  *(_DWORD *)(v3 + 1428) = v71;
LABEL_111:
  *(_DWORD *)(v3 + 1424) = v5;
  return sub_10053D50(v7, v3, v58);
}
// 100EC340: using guessed type int dword_100EC340[];
// 100EC388: using guessed type int dword_100EC388[];

//----- (10055030) --------------------------------------------------------
signed int __usercall sub_10055030@<eax>(int a1@<edi>, int a2)
{
  int v2; // ebp@3
  int v3; // ebx@3
  signed int v4; // esi@3
  unsigned int v5; // eax@3
  int v6; // eax@5
  _BYTE *v7; // ecx@6
  int v8; // eax@9
  int v9; // ecx@10
  int v10; // eax@13
  int v11; // eax@21
  int v12; // eax@23
  _BYTE *v13; // edx@24
  int v14; // eax@25
  _BYTE *v15; // ecx@26
  int v16; // eax@27
  signed int result; // eax@32
  int v18; // eax@34
  int v19; // eax@36
  _BYTE *v20; // edx@37
  int v21; // eax@38
  _BYTE *v22; // ecx@39
  int v23; // eax@40
  signed int v24; // [sp+8h] [bp+4h]@3

  if ( !a1 || !*(_DWORD *)a1 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  v3 = -5;
  v4 = a2 != 4 ? 0 : 0xFFFFFFFB;
  v5 = *(_BYTE *)v2;
  v24 = a2 != 4 ? 0 : 0xFFFFFFFB;
  while ( 2 )
  {
    switch ( v5 )
    {
      case 0u:
        v6 = *(_DWORD *)(a1 + 4);
        if ( !v6 )
          goto LABEL_44;
        v7 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v6 - 1;
        *(_DWORD *)(v2 + 4) = *v7;
        ++*(_DWORD *)a1;
        v3 = v4;
        if ( (*(_DWORD *)(v2 + 4) & 0xF) != 8 || (unsigned int)((*(_DWORD *)(v2 + 4) >> 4) + 8) > *(_DWORD *)(v2 + 16) )
          goto LABEL_29;
        *(_BYTE *)v2 = 1;
        goto LABEL_9;
      case 1u:
LABEL_9:
        v8 = *(_DWORD *)(a1 + 4);
        if ( !v8 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v8 - 1;
        v9 = *(_BYTE *)(*(_DWORD *)a1)++;
        v3 = v4;
        if ( (v9 + (*(_DWORD *)(v2 + 4) << 8)) % 0x1Fu )
          goto LABEL_29;
        if ( !(v9 & 0x20) )
        {
          *(_BYTE *)v2 = 7;
LABEL_31:
          v5 = *(_BYTE *)v2;
          if ( v5 > 0xD )
            return -2;
          continue;
        }
        *(_BYTE *)v2 = 2;
LABEL_34:
        v18 = *(_DWORD *)(a1 + 4);
        if ( !v18 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v18 - 1;
        *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
        v3 = v4;
        *(_BYTE *)v2 = 3;
LABEL_36:
        v19 = *(_DWORD *)(a1 + 4);
        if ( !v19 )
          goto LABEL_44;
        v20 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v19 - 1;
        *(_DWORD *)(v2 + 8) += *v20 << 16;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 4;
LABEL_38:
        v21 = *(_DWORD *)(a1 + 4);
        if ( !v21 )
          goto LABEL_44;
        v22 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v21 - 1;
        *(_DWORD *)(v2 + 8) += *v22 << 8;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 5;
LABEL_40:
        v23 = *(_DWORD *)(a1 + 4);
        if ( v23 )
        {
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v23 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(v2 + 8);
          *(_BYTE *)v2 = 6;
          result = 2;
        }
        else
        {
LABEL_44:
          result = v3;
        }
        return result;
      case 7u:
        v10 = sub_10054650(a1, *(_DWORD *)(v2 + 20), v3);
        v3 = v10;
        if ( v10 == -3 )
        {
          *(_DWORD *)(v2 + 4) = 0;
        }
        else
        {
          if ( !v10 )
            v3 = v4;
          if ( v3 != 1 )
            goto LABEL_44;
          v3 = v4;
          sub_10053930((_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 20), a1);
          v4 = v24;
          if ( *(_DWORD *)(v2 + 12) )
          {
            *(_BYTE *)v2 = 12;
            goto LABEL_31;
          }
          *(_BYTE *)v2 = 8;
LABEL_21:
          v11 = *(_DWORD *)(a1 + 4);
          if ( !v11 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v11 - 1;
          *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
          v3 = v4;
          *(_BYTE *)v2 = 9;
LABEL_23:
          v12 = *(_DWORD *)(a1 + 4);
          if ( !v12 )
            goto LABEL_44;
          v13 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v12 - 1;
          *(_DWORD *)(v2 + 8) += *v13 << 16;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 10;
LABEL_25:
          v14 = *(_DWORD *)(a1 + 4);
          if ( !v14 )
            goto LABEL_44;
          v15 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v14 - 1;
          *(_DWORD *)(v2 + 8) += *v15 << 8;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 11;
LABEL_27:
          v16 = *(_DWORD *)(a1 + 4);
          if ( !v16 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v16 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          v3 = v4;
          if ( *(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
          {
            *(_BYTE *)v2 = 12;
            return 1;
          }
LABEL_29:
          *(_DWORD *)(v2 + 4) = 5;
        }
        *(_BYTE *)v2 = 13;
        goto LABEL_31;
      case 8u:
        goto LABEL_21;
      case 9u:
        goto LABEL_23;
      case 0xAu:
        goto LABEL_25;
      case 0xBu:
        goto LABEL_27;
      case 2u:
        goto LABEL_34;
      case 3u:
        goto LABEL_36;
      case 4u:
        goto LABEL_38;
      case 5u:
        goto LABEL_40;
      case 6u:
        *(_BYTE *)v2 = 13;
        *(_DWORD *)(v2 + 4) = 0;
        return -2;
      case 0xCu:
        return 1;
      case 0xDu:
        return -3;
      default:
        return -2;
    }
  }
}

//----- (10055360) --------------------------------------------------------
signed int __cdecl sub_10055360(int a1, int a2)
{
  return sub_10055030(a1, a2);
}

#error "There were 52 decompilation failure(s) on 1271 function(s)"
