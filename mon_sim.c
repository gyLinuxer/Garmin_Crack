/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

// int __usercall sub_10001000@<eax>(int result@<eax>, _WORD *a2@<edx>, _DWORD *a3@<ecx>);
__int16 __cdecl sub_10001040(int a1, unsigned __int16 a2, int a3);
// __int16 __usercall sub_100011A0@<ax>(signed __int16 a1@<ax>, int a2, int a3);
int __cdecl sub_10001330(int a1);
// char __usercall sub_10001510@<al>(__int16 a1@<bx>, unsigned __int8 a2);
// bool __usercall sub_100015D0@<al>(int a1@<esi>, char a2);
signed int __cdecl sub_10001640(int a1, int a2);
char **sub_10002390();
char __cdecl sub_100023A0(char a1);
char __cdecl sub_10002400(int a1);
char __cdecl sub_10002460(char a1);
int __cdecl nullsub_1(_DWORD);
int __thiscall sub_100024A0(void *this);
char sub_10002570();
int __thiscall sub_100025C0(void *this);
char __cdecl sub_10002600(int *a1);
int __thiscall sub_100026A0(void *this);
int sub_10002710();
int __cdecl sub_10002880(unsigned __int8 a1);
double __cdecl sub_10002900(float a1, float a2);
int sub_10002920();
char __fastcall sub_10002A20(unsigned int a1);
double __cdecl sub_10002A80(float a1);
// bool __usercall sub_10002AC0@<al>(unsigned __int8 a1@<al>, char a2@<bl>, signed int a3, signed int a4, char a5);
// char __usercall sub_10002CC0@<al>(float *a1@<esi>);
// char __usercall sub_10002D30@<al>(float *a1@<esi>);
// char __usercall sub_10002DA0@<al>(float *a1@<esi>);
// bool *__usercall sub_10002E10@<eax>(unsigned __int16 a1@<ax>, bool *a2);
// char __usercall sub_10002E50@<al>(size_t a1@<edi>, int a2@<esi>, __int16 a3, void *a4);
// BOOL __usercall sub_10002EA0@<eax>(_BYTE *a1@<esi>, unsigned __int8 a2);
int __cdecl sub_10002F00(float); // idb
char __cdecl sub_10002FE0(int a1);
// char __usercall sub_10003020@<al>(int a1@<eax>, char *a2);
char __cdecl sub_10003040(_BYTE *a1);
BOOL __cdecl sub_10003110(char *a1);
char __cdecl sub_10003250(char *a1);
// char __usercall sub_100033D0@<al>(_DWORD *a1@<edi>);
char __fastcall sub_100034E0(int a1, float *a2);
__int16 __cdecl sub_10005040(int a1, char a2, int a3, int a4, int a5, char a6);
char sub_10005B80();
char sub_10005C10();
char sub_10005F40();
char sub_10006050();
int sub_100061B0();
__int16 __cdecl sub_10006220(int a1, unsigned __int16 a2);
int __cdecl sub_10006300(char a1);
int sub_100063A0();
int __cdecl sub_10006460(char a1, int a2);
// int __usercall sub_10006480@<eax>(_WORD *a1@<eax>, int a2);
// signed int __usercall sub_100064B0@<eax>(unsigned __int16 a1@<ax>);
char __cdecl sub_100064E0(char a1, _DWORD *a2);
// int __usercall sub_10006530@<eax>(int result@<eax>, int a2@<edx>, char a3, char a4, char a5);
// char __usercall sub_100065E0@<al>(unsigned __int16 a1@<ax>, int a2);
// char __usercall sub_10006620@<al>(char a1@<al>, unsigned __int16 a2@<cx>);
// char __usercall sub_10006670@<al>(unsigned __int16 a1@<ax>, char a2);
// char __usercall sub_100066F0@<al>(int a1@<eax>, int a2@<ecx>, char a3@<bl>, int a4, char a5, _BYTE *a6);
// char __usercall sub_10006860@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, char a4, int a5, int a6);
// char __usercall sub_10006A70@<al>(unsigned __int16 a1@<ax>, int a2@<edi>);
char __cdecl sub_10006AC0(signed __int16 a1, int a2, int a3, int a4);
char sub_10006CD0();
char __cdecl sub_10006D90(int a1, int a2);
char __cdecl sub_10006E90(char a1);
// char __usercall sub_10006F40@<al>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, __int16 a4, unsigned __int16 a5, int a6, char a7);
// char __usercall sub_10007580@<al>(unsigned __int16 a1@<ax>, char a2@<dl>, int a3@<ecx>, int a4);
char __cdecl sub_10007620(int a1, int a2, unsigned __int8 a3, unsigned __int16 a4, char a5);
// int __usercall sub_10007890@<eax>(int a1@<edi>, int a2, int a3, int a4, char a5, __int16 a6, _BYTE *a7, _BYTE *a8, _BYTE *a9, _BYTE *a10);
char __cdecl sub_100079D0(int a1, signed __int16 a2, int a3, int a4, int a5, int a6);
int sub_10008040();
int sub_10008050();
signed int sub_100080F0();
char __fastcall sub_10008160(void *a1);
int sub_100081D0();
int sub_10008270();
void sub_10008330();
// int __usercall sub_100087D0@<eax>(int result@<eax>, float a2, float a3, float a4);
BOOL sub_10008A30();
bool sub_10008A50();
BOOL sub_10008A70();
char sub_10008AB0();
int sub_100090A0();
char sub_100093A0();
int sub_10009480();
void __noreturn sub_10009510();
char **sub_10009820();
char sub_10009830();
bool __cdecl sub_10009840(char a1);
char **sub_10009860();
bool __thiscall sub_10009870(void *this);
bool __thiscall sub_10009920(void *this);
bool __thiscall sub_10009990(void *this);
bool sub_100099D0();
int sub_10009A00();
bool sub_10009A70();
bool sub_10009B00();
bool sub_10009B40();
int (**sub_10009B80())();
__int16 __cdecl sub_10009B90(char a1, int a2, int a3, int a4, void *a5, int a6, int a7, int a8, __int16 a9, __int16 a10, __int16 a11, int a12, void *a13);
_DWORD sub_1000A160(); // weak
void __cdecl sub_1000A1B0(int a1, unsigned int a2, signed int *a3, signed int *a4);
int __cdecl sub_1000A6F0(int a1, _BYTE *a2, int a3);
int __cdecl sub_1000A740(void *, size_t); // idb
int __cdecl sub_1000A770(char *, size_t, char *, va_list); // idb
int sub_1000A7B0(char *arg0, size_t arg4, char *arg8, ...);
int __cdecl sub_1000A7E0(const char *a1, _BYTE *a2, int a3);
char __cdecl sub_1000A820(_DWORD *a1);
char __cdecl sub_1000A930(int a1, unsigned int a2);
bool __cdecl sub_1000A960(const void **a1, int a2);
bool __cdecl sub_1000A990(const void **a1, int a2);
bool __cdecl sub_1000A9C0(const void **a1, int a2);
bool __cdecl sub_1000A9F0(const void **a1, int a2);
bool __cdecl sub_1000AA20(const void **a1, int a2);
bool __cdecl sub_1000AA50(int a1, int a2);
bool __cdecl sub_1000AA90(int a1, int a2);
bool __cdecl sub_1000AAD0(const void **a1, int a2);
bool __cdecl sub_1000AB00(const void **a1, int a2);
char __cdecl sub_1000AB30(int a1, unsigned int a2);
bool __cdecl sub_1000AB60(const void **a1, int a2);
bool __cdecl sub_1000AB90(const void **a1, int a2);
bool __cdecl sub_1000ABC0(const void **a1, int a2);
bool __cdecl sub_1000ABF0(const void **a1, int a2);
bool __cdecl sub_1000AC20(const void **a1, int a2);
bool __cdecl sub_1000AC50(const void **a1, int a2);
bool __cdecl sub_1000AC80(const void **a1, int a2);
bool __cdecl sub_1000ACB0(const void **a1, int a2);
bool __cdecl sub_1000ACE0(const void **a1, int a2);
bool __cdecl sub_1000AD10(const void **a1, int a2);
int __cdecl sub_1000AD40(int a1, int a2, int a3);
// void __cdecl __noreturn exit(int);
int __cdecl sub_1000ADB0(int a1, char a2);
int __cdecl sub_1000ADD0(int a1, int a2, int a3);
int __cdecl sub_1000AE00(int a1, int a2, int a3, int a4);
int __cdecl sub_1000AE30(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1000AE70(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_1000AEB0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
char __cdecl sub_1000AF00(int a1);
char __cdecl sub_1000AF30(int a1);
char __cdecl sub_1000AF40(int a1, int a2);
signed int __cdecl sub_1000B0C0(int a1);
signed int __cdecl sub_1000B100(int a1, int a2, int a3);
char __cdecl sub_1000B1A0(int a1);
char __cdecl sub_1000B200(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_1000B270(char *a1);
int __cdecl sub_1000B310(int a1, int a2, int a3);
bool __cdecl sub_1000B380(int a1, unsigned int a2, int a3);
char __cdecl sub_1000B410(int a1, int a2, char a3, char a4);
char __cdecl sub_1000B4C0(int a1);
char __cdecl sub_1000B4D0(int a1, void (__cdecl *a2)(int));
int (__cdecl *__cdecl sub_1000B550(int a1, const char *a2))(const char *);
signed int __cdecl sub_1000B5A0(int a1, void (__cdecl *a2)(int));
signed int sub_1000B5F0();
signed int sub_1000B600();
signed int sub_1000B610();
char __cdecl sub_1000B620(unsigned __int16 a1, unsigned __int16 a2);
char __cdecl sub_1000B740(unsigned __int16 a1, unsigned __int16 a2);
char __cdecl sub_1000B7F0(int a1, int a2, char a3, bool *a4, char *a5);
double sub_1000B8C0(void); // weak
char __thiscall sub_1000B8E0(void *this);
char __thiscall sub_1000B910(void *this);
char __thiscall sub_1000B950(void *this);
signed int __cdecl sub_1000B980(char a1);
int __cdecl sub_1000B990(int a1, int a2, int a3);
char __thiscall sub_1000B9F0(void *this);
char *__cdecl sub_1000BA20(char a1, char *a2, size_t a3);
int sub_1000BAA0();
char __fastcall sub_1000BAD0(int a1);
char __cdecl sub_1000BB20(int a1);
int __cdecl sub_1000BB40(int a1, char *a2);
char __thiscall sub_1000BBA0(void *this);
char __thiscall sub_1000BBC0(void *this);
char __thiscall sub_1000BBE0(void *this);
int __thiscall sub_1000BC00(void *this);
char __thiscall sub_1000BC20(void *this);
char __thiscall sub_1000BC40(void *this);
BOOL sub_1000BC60();
// int __usercall sub_1000BC80@<eax>(int a1@<edx>, int a2@<ecx>, int a3);
int __cdecl sub_1000BD30(__int16 a1, __int16 a2, char a3, unsigned __int8 a4, char a5);
int __cdecl sub_1000BE60(int a1);
__int16 __cdecl sub_1000BE80(int a1, int a2, int a3);
int __cdecl sub_1000BEB0(int a1);
char __cdecl sub_1000BED0(_DWORD *a1);
char __cdecl sub_1000BF10(int a1, int a2);
char __cdecl sub_1000BF40(int a1, int a2, int a3);
char __cdecl sub_1000BF70(int a1, int a2, int a3, int a4);
char __cdecl sub_1000BFA0(int a1, int a2);
char __cdecl sub_1000BFD0(int a1);
char __cdecl sub_1000BFF0(int a1);
char __cdecl sub_1000C010(__int16 a1, char a2);
char __cdecl sub_1000C080(int a1);
char __cdecl sub_1000C0A0(int a1);
char __cdecl sub_1000C0C0(int a1);
int __cdecl sub_1000C0E0(int a1, int a2, int a3);
int __cdecl sub_1000C110(int a1);
int __cdecl sub_1000C130(int a1);
int __cdecl sub_1000C170(const void *a1, unsigned __int16 a2, char a3, int a4);
int __cdecl sub_1000C2D0(int a1, char a2);
int __cdecl sub_1000C320(int a1, int a2);
int sub_1000C430();
int __cdecl sub_1000C480(int a1, int a2);
int __cdecl sub_1000C4F0(int a1, int a2, int a3);
int __cdecl sub_1000C540(int a1);
int __cdecl sub_1000C580(int a1, char a2);
char *__cdecl sub_1000C5D0(int a1, int a2, int a3, size_t a4, char *a5);
int sub_1000C750();
const char *__cdecl sub_1000C760(unsigned int a1);
int __cdecl sub_1000C780(int a1, int a2, int a3, int a4);
int __cdecl sub_1000C830(int a1);
int __cdecl sub_1000C850(int a1);
char *sub_1000C870(char *a1, ...);
// char *__usercall sub_1000C8B0@<eax>(char a1@<al>, unsigned __int8 a2@<cl>);
// char __usercall sub_1000C8D0@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5);
int sub_1000CAB0();
int sub_1000CAD0();
int __cdecl sub_1000CAF0(int a1, int a2);
int __cdecl sub_1000CB50(int a1);
int __cdecl sub_1000CB60(int a1, int a2);
int __cdecl sub_1000CBC0(int a1);
bool __cdecl sub_1000CBD0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1000CD10(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1000D0C0(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9);
bool __cdecl sub_1000D510(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9);
bool __cdecl sub_1000D9D0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1000DD90(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9);
bool __cdecl sub_1000E190(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1000E550(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9);
bool __cdecl sub_1000EA90(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9);
bool __cdecl sub_1000EE70(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1000F230(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1000F5D0(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9);
bool __cdecl sub_1000F9D0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1000FD70(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9);
bool __cdecl sub_10010350(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9);
bool __cdecl sub_10010740(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
int sub_10010AE0();
// BOOL __usercall sub_10010B10@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6);
// bool __usercall sub_10010C80@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9);
char __cdecl sub_10010EF0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
bool __cdecl sub_100111F0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
bool __cdecl sub_100112A0(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8);
char *__cdecl sub_100112E0(int a1, char *a2, int a3, char *a4, int a5);
char sub_10011410();
char __cdecl sub_10011420(char *a1, int a2, char a3, char *a4, int a5);
char __cdecl sub_10011520(char *a1, int a2, char a3, char *a4);
int __cdecl sub_10011590(char a1);
signed int sub_100115B0();
// signed int __usercall sub_10011600@<eax>(char a1@<al>, int a2@<ecx>);
// int __usercall sub_100116A0@<eax>(char a1@<al>);
// int __usercall sub_100116C0@<eax>(char a1@<al>);
// signed __int16 __usercall sub_100116E0@<ax>(char a1@<al>, unsigned __int16 a2@<si>);
char __cdecl sub_10011920(char a1, unsigned __int16 a2, _BYTE *a3);
char __cdecl sub_10011A80(char a1, unsigned __int16 a2, void *a3);
char __cdecl sub_10011C00(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_10011D60(int a1, int a2, void *a3, char a4, __int16 a5, char a6);
char __cdecl sub_10011EA0(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_10011F80(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6);
char __cdecl sub_10012200(char a1, int a2, __int16 a3, __int16 a4, void *a5);
char __cdecl sub_10012230(char a1, unsigned __int16 a2, _DWORD *a3);
char __cdecl sub_10012260(char a1, int a2, void *a3);
char __cdecl sub_10012290(char a1, int a2, void *a3, int a4);
int __thiscall sub_100122C0(void *this);
char __cdecl sub_100122E0(char a1, void *a2);
char __cdecl sub_10012390(char a1);
char __cdecl sub_100123F0(char a1);
char __cdecl sub_10012430(char a1);
signed int __cdecl sub_100124A0(char a1);
char __cdecl sub_10012520(char a1);
char __cdecl sub_10012590(char a1);
char __cdecl sub_10012640(int a1);
char __cdecl sub_10012750(char a1, void *a2);
char __cdecl sub_10012780(int a1);
char __thiscall sub_10012880(void *this);
char __cdecl sub_10012890(int a1, void *a2);
char __cdecl sub_100128E0(int a1, void *a2);
char __cdecl sub_10012930(int a1, void *a2);
char __cdecl sub_10012950(int a1, void *a2);
char __cdecl sub_10012970(int a1, void *a2);
char __cdecl sub_10012990(unsigned __int8 a1, unsigned __int8 a2);
char sub_100129E0();
char sub_10012B20();
BOOL __cdecl sub_10012C60(int a1);
char __cdecl sub_10012C80(char a1, unsigned __int8 a2);
// signed __int16 __usercall sub_10012D10@<ax>(void *a1@<ecx>, signed __int16 a2@<bx>, const char *a3@<esi>);
char __cdecl sub_10012F60(signed __int16 a1);
bool __cdecl sub_10012FF0(float *a1);
char __cdecl sub_10013090(char a1, float *a2);
int sub_10013180();
// char __usercall sub_100131B0@<al>(int a1@<eax>, float *a2@<esi>, float a3, float a4);
char __cdecl sub_10013210(void *a1);
char __cdecl sub_10013270(float *a1);
char __cdecl sub_10013370(void *a1);
char __cdecl sub_100133D0(void *a1);
char __cdecl sub_10013430(void *a1);
char __cdecl sub_10013490(void *a1);
char __cdecl sub_10013570(float *a1);
char __cdecl sub_100135A0(float *a1);
int __cdecl sub_10013640(void *); // idb
char __cdecl sub_10013670(float *a1);
char __cdecl sub_100136E0(float *a1);
char __cdecl sub_10013750(bool *a1);
int __cdecl sub_10013890(int a1, unsigned int a2);
int __cdecl sub_10013980(int *a1, unsigned int a2);
__int16 __cdecl sub_10013A70(int a1, unsigned int a2);
int __cdecl sub_10013AC0(int *a1, unsigned int a2);
__int16 __cdecl sub_10013AF0(unsigned int *a1, _WORD *a2, _WORD *a3);
int __cdecl sub_10013B70(unsigned __int64 a1);
int __cdecl sub_10013C00(void *); // idb
char __cdecl sub_10013C70(int a1, void *a2);
char __fastcall sub_10013DD0(int a1);
char __cdecl sub_10013E20(unsigned int a1);
char __cdecl sub_10013E90(char a1);
char __cdecl sub_10013EE0(char a1);
char __cdecl sub_10013F10(char a1);
// char __usercall sub_10013F40@<al>(unsigned __int8 a1@<al>, _BYTE *a2);
char __cdecl sub_10013F70(void *a1, int a2);
char __cdecl sub_10014220(void *a1);
signed int sub_10014240();
int sub_10014250();
char sub_10014280();
char __cdecl sub_100142C0(char a1);
int __cdecl sub_10014350(int a1, signed int a2, signed int a3);
int __cdecl sub_10014370(int, double, double); // idb
int __cdecl sub_10014450(double, double); // idb
void sub_100144A0();
signed int sub_100144B0();
// char __usercall sub_100144C0@<al>(float *a1@<esi>);
signed int sub_10014530();
bool __cdecl sub_10014560(char a1, int a2);
char __cdecl sub_10014780(float *a1);
char sub_100147E0();
bool sub_10014850();
bool __cdecl sub_10014890(float *a1);
int __cdecl sub_100148F0(float, float, char); // idb
int __cdecl sub_10014A30(float); // idb
void sub_10014AD0();
char __cdecl sub_10014CB0(int a1, void *a2);
// void *__usercall sub_10014D10@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>);
char __cdecl sub_10016B60(int a1, float *a2);
// char __usercall sub_10016BC0@<al>(unsigned __int16 a1@<ax>, int a2@<esi>, float a3, char a4, char a5);
// double __usercall sub_10016CD0@<st0>(int a1@<eax>, _BYTE *a2@<ebx>, int a3, float a4);
unsigned __int8 __cdecl sub_10016DD0(int a1, int a2, char a3, void *a4);
char __cdecl sub_10016F60(unsigned __int16 a1, void *a2);
double __cdecl sub_10016FC0(float a1, float a2, int a3, float a4);
char __cdecl sub_100170A0(unsigned __int16 a1, float *a2);
double __cdecl sub_100171C0(float a1);
// char __usercall sub_10017220@<al>(int a1@<esi>, unsigned __int16 a2, float *a3);
char __cdecl sub_10017760(char a1, bool *a2);
char __cdecl sub_100177C0(char a1, bool *a2);
char __cdecl sub_10017820(float *a1);
double sub_10017AC0();
double sub_10017AF0();
// void __usercall sub_10017B20(int a1@<esi>, int a2, float a3);
// char __usercall sub_10017C80@<al>(float *a1@<edi>, unsigned __int16 a2@<si>, unsigned __int8 a3);
// char __usercall sub_10017D70@<al>(unsigned __int16 *a1@<eax>, int a2, float *a3, unsigned __int8 a4);
char __cdecl sub_10018050(float *a1);
char __cdecl sub_100180C0(float *a1);
char __cdecl sub_100180E0(float *a1);
char __cdecl sub_10018100(float *a1);
char __cdecl sub_10018190(float *a1);
char __cdecl sub_10018200(float *a1);
char __cdecl sub_100182D0(float *a1);
char __cdecl sub_100183A0(float *a1);
char __cdecl sub_10018470(float *a1);
char __cdecl sub_10018510(float *a1);
double sub_10018580();
char __cdecl sub_100185E0(float *a1);
char __cdecl sub_10018680(float a1, int a2);
char __cdecl sub_10018720(char *a1);
bool __cdecl sub_10018750(int a1, void *a2, int a3);
char __cdecl sub_100187D0(unsigned __int16 a1);
char __cdecl sub_10018840(unsigned __int16 a1, char a2);
bool __cdecl sub_100188B0(int a1, void *a2);
signed int sub_100188E0();
char __thiscall sub_10018920(void *this);
char __cdecl sub_10018940(char a1);
BOOL sub_10018990();
char sub_10018A30();
char sub_10018A60();
double __cdecl sub_10018AA0(char a1);
// bool __usercall sub_10018B20@<al>(int a1@<eax>);
char __cdecl sub_10018B90(char *a1);
double sub_10018D10(void); // weak
double sub_10018D20(void); // weak
signed int __cdecl sub_10018D30(_BYTE *a1, char a2, int a3);
int __cdecl sub_10018D80(int, float, float, int, int); // idb
unsigned int __cdecl sub_10018E70(char *a1, char a2, char a3, char a4, int a5);
unsigned int __cdecl sub_10018EC0(_BYTE *a1, __int16 a2, __int16 a3, __int16 a4, int a5);
unsigned int __cdecl sub_10018F60(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5);
unsigned int __cdecl sub_10019020(void *a1, size_t a2, int a3);
int __cdecl sub_10019080(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
int __cdecl sub_100190D0(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5);
int __cdecl sub_10019170(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
char __cdecl sub_10019220(int a1, int a2, void *a3);
char __cdecl sub_100194C0(unsigned __int16 a1, void *a2);
void sub_10019510();
char __cdecl sub_10019520(const void *a1);
char __cdecl sub_10019590(unsigned __int16 a1, unsigned int a2);
char __cdecl sub_10019640(unsigned __int8 a1, unsigned __int16 a2);
signed int sub_10019700();
char __cdecl sub_10019710(void *a1);
char __cdecl sub_10019760(unsigned __int8 a1, unsigned __int16 a2);
char __cdecl sub_10019860(unsigned __int8 a1);
char __cdecl sub_100198E0(int a1);
char sub_10019910();
unsigned __int8 __cdecl sub_10019990(unsigned __int16 a1);
__int16 __cdecl sub_100199C0(unsigned __int16 a1, unsigned __int8 a2);
bool sub_10019A50();
char __cdecl sub_10019AF0(unsigned int a1);
int __cdecl sub_10019B30(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6);
// void *__usercall sub_10019CC0@<eax>(void *a1@<ebx>, const void *a2@<edi>, int a3@<esi>, int a4);
void *__cdecl sub_10019CF0(void *a1);
BOOL sub_10019D20();
// int __usercall sub_10019D50@<eax>(char a1@<al>, int a2@<ecx>);
char __thiscall sub_10019D80(void *this);
char __thiscall sub_10019DE0(void *this);
char __cdecl sub_10019E50(char a1, char a2, int *a3);
char __cdecl sub_1001A000(char a1, int *a2, char a3);
char __thiscall sub_1001A070(void *this);
char __cdecl sub_1001A100(char a1);
char __cdecl sub_1001A170(int a1, char a2);
char __cdecl sub_1001A230(int a1, char a2);
char __cdecl sub_1001A2F0(int a1, char a2);
char __cdecl sub_1001A3B0(char a1);
char __cdecl sub_1001A3E0(char a1);
char __cdecl sub_1001A410(char a1);
int __cdecl sub_1001A440(char a1);
// int __usercall sub_1001A450@<eax>(char *a1@<eax>, char a2@<cl>);
// char __usercall sub_1001A460@<al>(char a1@<bl>, char a2);
// char __usercall sub_1001A520@<al>(char a1@<dl>, char a2@<cl>, char a3);
char __cdecl sub_1001A570(char a1, char a2);
char __cdecl sub_1001A590(char a1, char a2);
char __cdecl sub_1001A5C0(char a1);
char __thiscall sub_1001A5F0(void *this);
char __cdecl sub_1001A600(const void *a1);
int __cdecl sub_1001A670(int *a1);
// char __usercall sub_1001A6A0@<al>(int a1@<eax>, int a2@<ecx>);
int __cdecl sub_1001A740(const char *a1);
char __cdecl sub_1001A780(void *a1);
signed int __cdecl sub_1001A7D0(unsigned int a1, int a2);
char **sub_1001AB70();
int sub_1001AB80(void); // weak
signed int __cdecl sub_1001ABB0(int a1, int a2);
bool __cdecl sub_1001AC10(signed int a1);
int sub_1001AC80();
char sub_1001AFA0();
char sub_1001B1C0();
char sub_1001B3C0();
char sub_1001B540();
char sub_1001B6C0();
char sub_1001B830();
char sub_1001B930();
char sub_1001BA90();
char sub_1001BBF0();
char sub_1001BD50();
char sub_1001BEC0();
char sub_1001C020();
char sub_1001C180();
char sub_1001C3A0();
char sub_1001C500();
char sub_1001C660();
char sub_1001C7C0();
char sub_1001C930();
char sub_1001CA90();
char sub_1001CBF0();
char sub_1001CE10();
char sub_1001D010();
char sub_1001D190();
char sub_1001D310();
char sub_1001D480();
char sub_1001D570();
char sub_1001D6D0();
char sub_1001D830();
char sub_1001D990();
char sub_1001DB00();
char sub_1001DC60();
char sub_1001DDC0();
char sub_1001DFC0();
char sub_1001E120();
char sub_1001E280();
char sub_1001E3E0();
char sub_1001E550();
char sub_1001E6B0();
char sub_1001E810();
char sub_1001EDB0();
char sub_1001EFC0();
char sub_1001F1B0();
char sub_1001F320();
char sub_1001F490();
char sub_1001F5F0();
char sub_1001F6E0();
char sub_1001F840();
char sub_1001F9A0();
char sub_1001FB00();
char sub_1001FC70();
char sub_1001FDD0();
char sub_1001FF30();
char sub_10020130();
char sub_10020290();
char sub_100203F0();
char sub_10020550();
char sub_100206C0();
char sub_10020820();
char sub_10020980();
char sub_10020B90();
char sub_10020D80();
char sub_10020EF0();
char sub_10021060();
char sub_100211C0();
char sub_100212B0();
char sub_10021410();
char sub_10021570();
char sub_100216D0();
char sub_10021840();
char sub_100219A0();
char sub_10021B00();
char sub_10021D00();
char sub_10021E60();
char sub_10021FC0();
char sub_10022120();
char sub_10022290();
char sub_100223F0();
char **sub_10022550();
char __cdecl sub_10022560(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
char __cdecl sub_100225C0(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
int sub_10022620();
char sub_10022650();
signed int sub_10022700();
int sub_10022720();
void sub_10022730();
signed int sub_10022740();
void sub_10022750();
int __cdecl sub_10022760(char, int, __int16, __int16, void *); // idb
signed int sub_10022770();
int sub_10022780();
int sub_10022790();
void sub_100227B0();
char __cdecl sub_100227C0(unsigned __int8 a1);
signed int sub_10022820();
// char __usercall sub_10022830@<al>(unsigned __int8 a1@<al>, char a2, void *a3);
char __cdecl sub_10022910(int a1, char a2, void *a3);
char __cdecl sub_10022990(int a1, void *a2);
int __cdecl sub_100229B0(int a1);
char *__cdecl sub_100229F0(char **a1);
int sub_10022A40();
int __cdecl sub_10022A80(_BYTE *a1, int a2);
signed int __cdecl sub_10022AF0(_BYTE *a1, int a2);
// int __usercall sub_10022B90@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>);
// signed int __usercall sub_10022BC0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5);
// char *__usercall sub_10022D90@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>);
// int __usercall sub_10022DF0@<eax>(int a1@<esi>, int a2, _DWORD *a3);
// int __usercall sub_10022E80@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4);
// char **__usercall sub_10022ED0@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3);
// const char *__usercall sub_10022F30@<eax>(int a1@<eax>);
// int __usercall sub_10022F50@<eax>(unsigned int a1@<ebx>);
// int __usercall sub_10022F90@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5);
// int __usercall sub_10023020@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4);
// int __usercall sub_10023170@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>);
// int __usercall sub_10023210@<eax>(int result@<eax>);
char *__cdecl sub_10023250(int a1, char *a2, int a3, const char *a4);
// int __usercall sub_10023400@<eax>(int a1@<eax>);
// int __usercall sub_10023430@<eax>(int a1@<esi>);
void __cdecl sub_10023460(int (**a1)(void), char **a2, _DWORD *a3);
int sub_100238D0();
void *sub_10023920();
char *sub_10023980();
char sub_100239A0();
char __cdecl sub_100239B0(int a1, int a2, unsigned int a3);
// int *__usercall sub_100239F0@<eax>(_DWORD *a1@<ebx>, int a2);
char **sub_10023A40();
int __cdecl sub_10023A50(_DWORD *a1, int a2, int a3);
int __cdecl sub_10023B00(int a1, int a2, int a3, const char *a4, const char *a5);
// char *__usercall sub_10023D10@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6);
char *__cdecl sub_10023DD0(char a1);
int *__cdecl sub_10023E70(_BYTE *a1);
// int __usercall sub_10023F30@<eax>(int a1@<eax>);
// signed int __usercall sub_10024090@<eax>(int a1@<esi>);
int __cdecl sub_10024100(int, int); // weak
char **sub_100243E0();
// int __usercall sub_100243F0@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6);
int __cdecl sub_100244E0(char *a1);
int sub_10024720();
int __cdecl sub_10024800(int a1, int a2, char a3);
char __cdecl sub_10024850(signed int a1, _DWORD *a2, _DWORD *a3);
char *__cdecl sub_10024890(const char *a1, int a2);
// char *__usercall sub_10024900@<eax>(char *result@<eax>);
void __cdecl sub_10024930(char *a1);
void __cdecl sub_100249F0(char *a1, char *a2);
void *__cdecl sub_10024A50(int a1);
BOOL __cdecl sub_10024BE0(unsigned int a1);
BOOL __cdecl sub_10024C00(int a1);
_DWORD __cdecl sub_10024C20(_DWORD); // weak
unsigned int __cdecl sub_10024C30(int a1, char a2);
signed int __cdecl sub_10024C90(void *a1, int a2, unsigned int a3);
int __cdecl sub_10024CB0(int a1, int a2, int a3);
char __cdecl sub_10024CD0(const char *a1, const char *a2);
int __cdecl sub_10024E10(int a1, int a2, unsigned int a3);
int sub_10024E90();
void __cdecl sub_10024EA0(int a1);
int __cdecl sub_10024ED0(int a1);
bool __cdecl sub_10024EF0(int a1);
void *__cdecl sub_10024F20(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5);
// unsigned int __usercall sub_10024F60@<eax>(int a1@<edx>, int a2, int a3);
// int __usercall sub_10024F80@<eax>(int result@<eax>, int a2@<ecx>);
char __cdecl sub_10024FA0(void (__cdecl *a1)(_DWORD), int a2);
signed int __cdecl sub_10024FD0(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5);
void __cdecl sub_100250B0(int a1, int a2, int a3);
// void *__usercall sub_10025160@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3);
void __cdecl sub_100253E0(int a1, int a2);
char __cdecl sub_100254B0(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4);
// int __usercall sub_10025520@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9);
// int __usercall sub_10025880@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7);
int __cdecl sub_10025990(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10);
char __cdecl sub_10025B20(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3);
// char __usercall sub_10025C70@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5);
char __cdecl sub_10025DC0(int a1, int a2);
char __cdecl sub_10025E00(int a1, int a2);
char __cdecl sub_10025F20(int a1);
char __cdecl sub_10025F30(int a1);
char __cdecl sub_10025F40(int a1);
int __cdecl sub_10025F50(unsigned __int8 *a1, int a2);
int __cdecl sub_10025F80(unsigned __int8 *a1, int a2);
int __cdecl sub_10025FB0(unsigned __int8 *a1, int a2);
int __cdecl sub_10025FE0(unsigned __int8 *a1, int a2);
int __cdecl sub_10026010(unsigned __int8 *a1, int a2);
signed int __cdecl sub_10026040(unsigned __int8 *a1, int a2);
int __cdecl sub_10026070(unsigned __int8 *a1, int a2);
int __cdecl sub_100260A0(unsigned __int8 *a1, int a2);
int __cdecl sub_100260D0(unsigned __int8 *a1, int a2);
int __cdecl sub_10026100(unsigned __int8 *a1, int a2);
int __cdecl sub_10026130(unsigned __int8 *a1, int a2);
int __cdecl sub_10026160(unsigned __int8 *a1, int a2);
int __cdecl sub_10026190(unsigned __int8 *a1, int a2);
int __cdecl sub_100261C0(unsigned __int8 *a1, int a2);
unsigned int __cdecl sub_100261F0(char *a1);
int __cdecl sub_10026210(_BYTE *a1);
int __cdecl sub_10026230(unsigned __int8 *a1);
int __cdecl sub_10026250(unsigned __int8 *a1, int a2);
unsigned int __cdecl sub_10026280(int a1, int a2);
unsigned int __cdecl sub_100265B0(int a1, int a2);
unsigned int __cdecl sub_100269F0(_BYTE *a1);
int __cdecl sub_10026A10(unsigned __int8 *a1);
int __cdecl sub_10026A30(unsigned __int8 *a1);
int __cdecl sub_10026A50(_BYTE *a1);
int __cdecl sub_10026A70(int a1);
// void __cdecl __noreturn exit_0(int);
int __cdecl sub_10026AC0(unsigned __int8 *a1);
int __cdecl sub_10026AE0(int a1);
unsigned int __cdecl sub_10026B70(int a1);
signed int __cdecl sub_10026B90(int a1);
unsigned int __cdecl sub_10026BE0(int a1);
int __cdecl sub_10026C40(_BYTE *a1);
unsigned int __cdecl sub_10026C60(_BYTE *a1);
int __cdecl sub_10026C80(unsigned __int8 *a1);
int __cdecl sub_10026CA0(_BYTE *a1);
signed int __cdecl sub_10026CC0(_BYTE *a1, int a2);
int __cdecl sub_10026CF0(_BYTE *a1);
int __cdecl sub_10026D10(_BYTE *a1, int a2);
int __cdecl sub_10026D50(int a1, int a2);
int __cdecl sub_10026DE0(unsigned __int8 *a1);
int __cdecl sub_10026E00(int a1);
int __cdecl sub_10026E30(unsigned __int8 *a1);
unsigned int __cdecl sub_10026E50(int a1);
int __cdecl sub_10026E80(int a1);
int __cdecl sub_10026F70(int a1);
signed int __cdecl sub_10027080(_BYTE *a1, int a2);
int __cdecl sub_100270B0(int a1);
signed int __cdecl sub_100270E0(int a1, int a2);
int __cdecl sub_100275F0(_BYTE *a1, int a2);
signed int __cdecl sub_10027620(_BYTE *a1, int a2);
int __cdecl sub_10027690(unsigned __int8 *a1);
int __cdecl sub_100276F0(int a1);
int __cdecl sub_10027700(unsigned __int8 *a1, int a2);
int __cdecl sub_10027730(unsigned __int8 *a1, int a2);
int __cdecl sub_10027760(unsigned __int8 *a1, int a2);
signed int __cdecl sub_10027790(_BYTE *a1, int a2);
int __cdecl sub_100277C0(int a1, int a2);
signed int __cdecl sub_10027860(int a1);
_DWORD __cdecl sub_100278F0(_DWORD); // weak
int __cdecl sub_10027900(int a1);
unsigned int __cdecl sub_10027980(int a1);
unsigned int __cdecl sub_100279C0(int a1);
int __cdecl sub_10027A10(int a1);
int __cdecl sub_10027A40(int a1);
unsigned int __cdecl sub_10027A70(int a1);
unsigned int __cdecl sub_10027AA0(int a1);
unsigned int __cdecl sub_10027AC0(int a1);
void __cdecl __noreturn sub_10027B00(int a1);
signed int __cdecl sub_10027C70(int a1, int a2);
int __cdecl sub_10027CC0(int a1, int a2);
int __cdecl sub_10027D10(_BYTE *a1, int a2);
// time_t __cdecl static _mkgmtime(struct tm *Tm);
// int __usercall sub_10027D30@<eax>(unsigned __int8 *a1@<eax>, int a2@<edi>);
// signed int __usercall sub_10027D80@<eax>(int a1@<eax>, int a2@<edi>);
// int __usercall sub_10027E50@<eax>(unsigned __int8 *a1@<eax>, int a2@<esi>);
int __cdecl sub_10027F40(unsigned __int8 *a1);
int __cdecl sub_10027F50(unsigned __int8 *a1);
signed int __cdecl sub_10027F60(int a1);
int __cdecl sub_10027F70(_BYTE *a1);
int __cdecl sub_10027F90(unsigned __int8 *a1);
int __cdecl sub_10027FB0(unsigned __int8 *a1);
int __cdecl sub_10027FD0(unsigned __int8 *a1);
int __cdecl sub_10027FF0(unsigned __int8 *a1);
_DWORD __cdecl sub_10028010(_DWORD); // weak
int __cdecl sub_10028020(int a1);
int __cdecl sub_10028060(int a1);
signed int __fastcall sub_10028080(unsigned __int8 a1);
char __cdecl sub_10028090(unsigned __int8 a1);
__int16 __cdecl sub_100280B0(unsigned __int8 a1);
int __cdecl sub_100280D0(void *, void *, size_t, int, int); // idb
int __cdecl sub_10028180(unsigned __int16 a1);
// int __usercall sub_100281C0@<eax>(unsigned __int16 a1@<di>);
int __cdecl sub_10028200(unsigned __int16 a1);
bool __cdecl sub_10028230(unsigned __int8 a1, char a2, unsigned int a3);
bool __cdecl sub_100282C0(char a1, char a2, void *a3);
bool __cdecl sub_10028340(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6);
signed int sub_100283E0();
char __cdecl sub_100283F0(void *a1);
bool sub_10028440();
char __cdecl sub_10028480(char a1);
char __cdecl sub_10028500(unsigned __int16 a1, _WORD *a2);
char __cdecl sub_10028560(char a1, int a2);
// int __usercall sub_100286D0@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3);
// int __usercall sub_10028710@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3);
signed int sub_10028750();
char __cdecl sub_10028760(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_100287C0(char a1, void *a2);
char __cdecl sub_100288E0(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10028960(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6);
int __cdecl sub_10028B10(int a1);
double __cdecl sub_10028C10(int a1);
// char __usercall sub_10028C60@<al>(void *a1@<esi>);
// char __usercall sub_10028CA0@<al>(float *a1@<esi>);
char __cdecl sub_10028CC0(float *a1);
char __cdecl sub_10028D20(float *a1);
char __cdecl sub_10028D80(float *a1);
// char __usercall sub_10028DE0@<al>(int a1@<esi>);
char __cdecl sub_10028E80(float *a1);
char __cdecl sub_10028ED0(float *a1);
char __cdecl sub_10028F20(float *a1);
char __cdecl sub_10028F80(float *a1);
// char __usercall sub_10028FE0@<al>(float *a1@<esi>, char a2);
char __cdecl sub_100290D0(float a1, int a2);
// char __usercall sub_10029140@<al>(float *a1@<esi>);
char __cdecl sub_100291C0(float *a1);
char __cdecl sub_10029220(float *a1);
char __cdecl sub_100292B0(float *a1);
// char __usercall sub_10029340@<al>(float *a1@<esi>);
// char __usercall sub_100296E0@<al>(float *a1@<esi>);
// char __usercall sub_10029750@<al>(float *a1@<esi>);
// char __usercall sub_10029770@<al>(float *a1@<esi>);
// void __usercall sub_10029800(float *a1@<esi>);
char __cdecl sub_10029890(float *a1);
// char __usercall sub_100299B0@<al>(float *a1@<esi>, float a2);
// char __usercall sub_10029BB0@<al>(float *a1@<esi>, float a2);
// char __usercall sub_10029C40@<al>(float *a1@<eax>);
// char __usercall sub_10029C50@<al>(float *a1@<eax>);
// char __usercall sub_10029C60@<al>(float *a1@<eax>);
// char __usercall sub_10029C70@<al>(float *a1@<eax>);
// int __usercall sub_10029C80@<eax>(char a1@<dl>, int a2@<ecx>, float *a3);
// char __usercall sub_10029CB0@<al>(float *a1@<esi>);
// char __usercall sub_10029D50@<al>(float *a1@<esi>);
char __cdecl sub_10029E30(float *a1);
// char __usercall sub_10029E80@<al>(float *a1@<esi>);
// char __usercall sub_10029F60@<al>(float *a1@<esi>);
// char __usercall sub_1002A040@<al>(float *a1@<esi>);
// char __usercall sub_1002A0E0@<al>(float *a1@<esi>);
// char __usercall sub_1002A180@<al>(float *a1@<esi>);
// char __usercall sub_1002A220@<al>(float *a1@<esi>);
char __cdecl sub_1002A300(float *a1);
bool __cdecl sub_1002A3A0(float *a1);
// char __usercall sub_1002A450@<al>(float *a1@<esi>);
// char __usercall sub_1002A4D0@<al>(float *a1@<esi>);
// char __usercall sub_1002A560@<al>(float *a1@<esi>);
int __cdecl sub_1002A5D0(float *a1);
int __cdecl sub_1002A800(float *a1);
int __cdecl sub_1002AA30(float *a1);
int __cdecl sub_1002AC60(float *a1);
// char __usercall sub_1002AE90@<al>(float *a1@<esi>);
// char __usercall sub_1002AF20@<al>(float *a1@<esi>);
bool __cdecl sub_1002AF90(float *a1);
char __cdecl sub_1002AFF0(float a1, void *a2);
char __cdecl sub_1002B8A0(unsigned __int16 a1, _BYTE *a2, _WORD *a3);
int __cdecl sub_1002B900(char *a1, char a2);
bool __cdecl sub_1002B970(int a1, void *a2);
char __cdecl sub_1002BA30(int a1, bool *a2);
char __cdecl sub_1002BAF0(unsigned __int16 a1);
char __cdecl sub_1002BB90(char a1, char a2, char a3, int a4, void *a5);
int __cdecl sub_1002BCA0(char a1);
signed int __cdecl sub_1002BCF0(char a1, char a2);
int __cdecl sub_1002BD50(char a1);
signed int __cdecl sub_1002BD90(char a1, char a2, char a3);
int __cdecl sub_1002BE00(char a1);
int __cdecl sub_1002BE40(char a1);
char __cdecl sub_1002BE80(int a1, int a2);
char __cdecl sub_1002BEA0(char a1, int a2);
char __cdecl sub_1002BEC0(char a1, int a2);
char __cdecl sub_1002BEF0(char a1, int a2);
char __cdecl sub_1002BF40(char a1, int a2);
char __cdecl sub_1002BF70(char a1, int a2);
char __cdecl sub_1002BF90(int a1);
_DWORD __cdecl sub_1002BFB0(_DWORD, _DWORD); // weak
char __cdecl sub_1002BFC0(_DWORD *a1);
bool __cdecl sub_1002C030(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_1002C0A0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_1002C100(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1002C170(char a1, _BYTE *a2);
char __thiscall sub_1002C1B0(void *this);
char __cdecl sub_1002C220(char a1, int a2);
char __cdecl sub_1002C250(char a1, int a2);
char __cdecl sub_1002C280(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6);
char __thiscall sub_1002C450(void *this);
// char __usercall sub_1002C4C0@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4);
// void *__usercall sub_1002C500@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4);
char __cdecl sub_1002C5A0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1002C5E0(char a1, char a2, void *a3);
char __cdecl sub_1002C640(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1002C680(char a1, char a2, void *a3);
char __cdecl sub_1002C6B0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1002C6F0(char a1, char a2, void *a3);
char __cdecl sub_1002C730(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1002C770(char a1, char a2, void *a3);
char __cdecl sub_1002C7C0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1002C800(char a1, char a2, void *a3);
char __cdecl sub_1002C840(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1002C880(char a1, char a2, void *a3);
char __cdecl sub_1002C8C0(char a1, void *a2);
char __cdecl sub_1002C8F0(char a1, void *a2);
char __cdecl sub_1002C920(char a1, void *a2);
char __cdecl sub_1002C950(char a1, void *a2);
char __cdecl sub_1002C980(char a1, void *a2);
char __cdecl sub_1002C9B0(char a1, void *a2);
char __cdecl sub_1002C9E0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1002CA20(char a1, char a2, void *a3);
char __cdecl sub_1002CA70(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1002CAB0(char a1, char a2, void *a3);
char __cdecl sub_1002CAE0(char a1, void *a2);
char __cdecl sub_1002CB10(char a1, void *a2);
char __cdecl sub_1002CB40(char a1, void *a2);
char __cdecl sub_1002CB70(int a1, char a2, char a3, int a4, void *a5);
char sub_1002CF10();
BOOL __cdecl sub_1002CFB0(int a1, int a2);
char __cdecl sub_1002CFD0(int a1, char a2, int a3, int a4, int a5);
int __cdecl sub_1002D010(char a1, char *a2);
char sub_1002D060();
int __cdecl sub_1002D070(int a1);
int __cdecl sub_1002D080(void *); // idb
int __cdecl sub_1002D100(int a1, int a2);
signed int __cdecl sub_1002D130(int a1, int a2, int a3);
const char *__cdecl sub_1002D150(int a1, int a2);
char __cdecl sub_1002D190(int a1, int *a2, unsigned int a3);
signed int __cdecl sub_1002DF40(int a1, int a2);
char **__cdecl sub_1002DFC0(int a1);
int (__cdecl *__cdecl sub_1002E000(const char *a1))(const char *);
const char *sub_1002E020();
__int64 sub_1002E030();
const char *sub_1002E040();
// int __usercall sub_1002E050@<eax>(_BYTE *a1@<edi>, int a2);
signed int __cdecl sub_1002E0A0(int a1, int a2);
int sub_1002E0D0(); // weak
// int __usercall sub_1002E1F0@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3);
char __cdecl sub_1002E570(int a1, const void **a2, unsigned int a3);
char **__cdecl sub_1002F390(int a1);
int __cdecl sub_1002F400(char a1);
_DWORD __cdecl sub_1002F430(char); // weak
int __cdecl sub_1002F440(int a1);
int __cdecl sub_1002F450(unsigned __int8 *a1);
unsigned int __cdecl sub_1002F470(void *a1);
unsigned int __cdecl sub_1002F490(void *a1);
unsigned int __cdecl sub_1002F4B0(void *a1);
unsigned int __cdecl sub_1002F4D0(void *a1);
unsigned int __cdecl sub_1002F4F0(void *a1);
int __cdecl sub_1002F510(int a1);
signed int __cdecl sub_1002F560(_BYTE *a1, int a2);
int __cdecl sub_1002F590(void *); // idb
unsigned int __cdecl sub_1002F660(void *a1);
int __cdecl sub_1002F6C0(unsigned __int8 *a1);
int __cdecl sub_1002F6E0(unsigned __int8 *a1, int a2);
int __cdecl sub_1002F710(unsigned __int8 *a1);
int __cdecl sub_1002F730(char, float, int, int, int); // idb
double sub_1002FD80();
double __cdecl sub_1002FDB0(int a1, float a2, float a3);
char __cdecl sub_1002FDF0(float *a1, float *a2, float *a3, char a4);
int __cdecl sub_10030380(char a1, char a2);
// bool __usercall sub_10030430@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3);
// char __usercall sub_10030460@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6);
char __cdecl sub_10030500(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10030580(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10030600(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10030680(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10030700(char a1);
bool __cdecl sub_100307A0(void *a1);
char __cdecl sub_100307E0(char a1);
char __cdecl sub_10030810(char a1, void *a2);
int __cdecl sub_10030890(char a1, _DWORD *a2);
char __cdecl sub_100308E0(char a1);
int __cdecl sub_10030920(char a1);
int __cdecl sub_10030970(int a1, int a2);
// char __usercall sub_10030AB0@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5);
signed int __cdecl sub_10030B80(_DWORD *a1, char *a2);
int __cdecl sub_10030C60(int a1, int a2, int a3);
// int (__cdecl *__usercall sub_10030C80@<eax>(int a1@<eax>, int a2@<ecx>))(int);
// int __usercall sub_10030C90@<eax>(unsigned __int8 *a1@<eax>, int a2);
int (__cdecl *__cdecl sub_10030EC0(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10030F10(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10030F60(int a1, unsigned __int8 *a2))(int);
int (__cdecl *__cdecl sub_10030FB0(int a1))(int);
int __cdecl sub_10031030(int a1, int a2);
int (__cdecl *__cdecl sub_100310B0(int a1, unsigned __int8 *a2, char a3))(int);
int (__cdecl *__cdecl sub_10031100(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10031140(int a1, int a2, int a3))(int);
double __cdecl sub_100311A0(float a1);
BOOL __cdecl sub_10031220(unsigned __int8 a1);
// BOOL __usercall sub_10031230@<eax>(unsigned __int8 a1@<al>, char a2);
bool __cdecl sub_10031260(char a1, char a2, unsigned __int8 a3, int a4);
bool __cdecl sub_10031410(unsigned __int8 a1, int a2);
bool __cdecl sub_10031450(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6);
int __cdecl sub_10031540(char a1);
int __cdecl sub_10031560(int, void *); // idb
// int __usercall sub_100315C0@<eax>(char a1@<al>);
BOOL __cdecl sub_100315F0(char a1, int a2);
int __cdecl sub_10031620(int, char, int, int, void *); // idb
char __cdecl sub_10031650(void *a1);
BOOL __cdecl sub_10031670(int a1);
char __cdecl sub_10031690(int a1, char a2, int a3, int a4, void *a5);
bool __cdecl sub_100316C0(char a1, void *a2);
// signed int __usercall sub_10031700@<eax>(char a1@<al>);
bool __cdecl sub_10031720(char a1, void *a2);
bool __cdecl sub_10031810(char a1, char a2, int a3, int a4, void *a5);
char __cdecl sub_10031840(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_100318E0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10031960(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_100319D0(char a1, void *a2);
char __cdecl sub_10031A50(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10031AD0(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10031B50(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10031BC0(char a1, char a2, char a3, unsigned __int8 *a4, int a5);
char __cdecl sub_10031CD0(char a1, void *a2);
bool __cdecl sub_10031CF0(unsigned __int8 a1, char *a2);
char __cdecl sub_10031D30(int a1, char a2, int a3, int a4, void *a5);
BOOL sub_10031D70();
char __cdecl sub_10031DD0(int a1, char *a2);
BOOL __cdecl sub_10031EC0(int a1, int a2);
char __cdecl sub_10031EE0(int a1, char a2, int a3, int a4, char *a5);
char __cdecl sub_10031F20(int a1, int a2);
BOOL __cdecl sub_10031FD0(int a1, int a2);
char __cdecl sub_10031FF0(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_10032030(void *a1);
char __cdecl sub_10032050(void *a1);
char __cdecl sub_100321A0(int a1, char a2, char a3, int a4, void *a5, size_t a6);
char __cdecl sub_10032340(char a1);
// __int16 __usercall sub_10032380@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_10032390(unsigned __int8 a1, char *a2);
char __cdecl sub_10032460(char a1, char a2, char a3, int a4, char *a5, unsigned int a6);
char __cdecl sub_100324E0(unsigned __int16 a1, char *a2, char a3);
char __cdecl sub_10032610(char a1, int a2);
bool __cdecl sub_10032690(void *a1);
char __cdecl sub_100326E0(char a1, int a2);
// __int16 __usercall sub_100327C0@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_100327D0(unsigned __int8 a1, int *a2, const void *a3);
char __cdecl sub_10032860(unsigned __int8 a1, char a2);
bool __cdecl sub_10032920(__int16 a1, char a2, int a3, int a4, void *a5);
char __cdecl sub_10032A20(char a1);
char __cdecl sub_10032A60(char a1);
int __cdecl sub_10032A80(int a1);
int __fastcall j_reg_get_tag_hdr(_DWORD, _DWORD); // weak
int __cdecl j_reg_get_tag_info(_DWORD, _DWORD); // weak
int __cdecl sub_10032AE0(int a1, int a2, int a3);
char __cdecl sub_10032B00(int a1, int a2, int a3);
int __cdecl sub_10032B40(int, void *, int, void *); // idb
int __cdecl sub_10032B80(int a1, int a2, int a3);
int __cdecl sub_10032BB0(int a1, int a2, int a3);
int __cdecl sub_10032BD0(int a1, int a2, int a3);
int __cdecl sub_10032C30(int a1, int a2, int a3);
char __cdecl sub_10032C70(int a1, int a2, int a3);
char __cdecl sub_10032CB0(int a1, _DWORD *a2, int a3, int a4, int a5, unsigned int a6);
int __cdecl sub_10032DC0(int, void *, int, void *); // idb
int __cdecl sub_10032E10(int a1);
int sub_10032E30();
int __cdecl sub_10032E50(int a1, int a2);
__int16 __cdecl sub_10032E80(int a1);
int __cdecl sub_10032EA0(int a1, int a2);
int sub_10032ED0();
int __cdecl sub_10032EF0(int a1, int a2, int a3, int a4);
int j_TSK_pvg_get_us_timer(void); // weak
int __cdecl sub_10032F30(int a1, int a2, int a3, int a4);
int __cdecl sub_10032F60(int a1);
int __cdecl sub_10032F80(int a1, int a2);
int __cdecl sub_10032FB0(int a1, int a2);
int __cdecl sub_10032FE0(int a1, int a2, int a3, int a4);
int __cdecl sub_10033010(int a1, int a2);
signed int __cdecl sub_10033040(int a1, int a2);
int __cdecl sub_10033090(int a1);
int __cdecl sub_100330B0(_BYTE *a1);
int __cdecl sub_100330F0(int a1, int a2);
int __cdecl sub_10033120(int a1, int a2);
bool __cdecl sub_10033140(int a1);
void __cdecl sub_10033160(int a1, _BYTE *a2);
int __cdecl sub_10033190(int a1, int a2);
int j_HWM_pvg_hsdb_get_lrus_online(void); // weak
int __cdecl j_HWM_pvg_hsdb_get_router_entry(_DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_log_err(_DWORD); // weak
int __cdecl j_HWM_pvg_read_reg(_DWORD); // weak
int __cdecl sub_100331F0(int a1, int a2);
signed int __cdecl sub_10033250(int a1);
// int __usercall sub_100332D0@<eax>(const char **a1@<esi>);
// int __usercall sub_100335D0@<eax>(int a1@<eax>, int a2@<ecx>);
signed int __cdecl sub_100335F0(int a1);
int __cdecl sub_100336C0(LONG Value); // idb
int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD); // weak
signed int __cdecl sub_10033760(unsigned int a1);
int __cdecl j_FIL_vfs_delete(_DWORD); // weak
int j_FIL_vfs_dyn_linker(void); // weak
int __cdecl sub_100337C0(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_10033830(unsigned int a1, void *a2, int a3);
signed int __cdecl sub_10033870(unsigned int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD); // weak
signed int __cdecl sub_10033900(unsigned int a1, int a2, int a3, int a4);
__int64 __cdecl sub_10033950(int a1);
int __cdecl sub_10033970(int a1, int a2, int a3);
int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_100339A0(int a1, int a2, int a3, char a4);
char __cdecl sub_100339C0(int a1);
signed int __cdecl sub_100339F0(unsigned int a1, int a2, int a3);
int __cdecl sub_10033A10(int a1, int a2, int a3);
int sub_10033A30(void); // weak
int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_create_id(_DWORD); // weak
int __cdecl sub_10033A80(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl sub_10033AD0(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD); // weak
int __cdecl sub_10033B50(int a1);
int __cdecl sub_10033B90(int a1);
int __cdecl sub_10033BD0(int a1);
int __cdecl sub_10033C10(int a1);
int __cdecl sub_10033C50(int a1, int a2, int a3, int a4);
int __cdecl sub_10033CC0(int a1, int a2, int a3);
int sub_10033D60(void); // weak
char __cdecl sub_10033D70(unsigned int a1, unsigned int *a2, int *a3);
void __cdecl sub_10034030(__int16 a1, _BYTE *a2);
int __cdecl j_mem_unmap(_DWORD, _DWORD); // weak
unsigned int __cdecl sub_10034070(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6);
// int __usercall sub_10034220@<eax>(int a1@<esi>);
int __cdecl sub_100342D0(int a1, unsigned __int64 a2);
// int __usercall sub_10034380@<eax>(int a1@<ebx>, unsigned __int64 a2);
unsigned int __cdecl sub_10034410(int a1, void *a2, int a3, int a4, int a5);
char sub_10034560();
int __cdecl sub_100345B0(float, float, float); // idb
double __cdecl sub_10034600(char a1);
signed int __cdecl sub_10034690(char a1);
char __cdecl sub_100346B0(float *a1);
bool __cdecl sub_10034820(float *a1, float *a2, float *a3, _BYTE *a4, _BYTE *a5, _BYTE *a6);
bool __cdecl sub_100349A0(float *a1, _BYTE *a2);
double __cdecl sub_100349F0(float a1);
double __cdecl sub_10034A20(float a1, float a2, float a3, float a4, float a5);
int __cdecl sub_10034BA0(float, float); // idb
double __cdecl sub_10034BF0(_BYTE *a1);
char __cdecl sub_10034D30(float *a1);
char __cdecl sub_10034F60(float *a1);
double __cdecl sub_100350D0(float a1);
char __cdecl sub_10035140(float *a1);
char __cdecl sub_100352E0(float *a1);
unsigned int __cdecl sub_10035490(char a1, _BYTE *a2, float *a3);
char __cdecl sub_10035680(int a1);
bool __cdecl sub_100358D0(unsigned __int8 a1, float *a2);
double __cdecl sub_100359D0(float a1, float a2);
int __cdecl sub_10035A70(signed int a1, signed int a2);
double __cdecl sub_10035AB0(float a1, float a2);
double __cdecl sub_10035B50(double a1, double a2);
double __cdecl sub_10035BB0(float a1, float a2);
int __cdecl sub_10035C30(double); // idb
double __cdecl sub_10035C50(float a1);
double __cdecl sub_10035C90(float a1, float a2);
bool __cdecl sub_10035D00(float a1, float a2, float a3);
int __cdecl sub_10035D40(int a1, int a2, int a3);
int __cdecl sub_10035D70(float, int, int); // idb
int __cdecl sub_10035DA0(unsigned __int8 a1, unsigned int a2);
unsigned int __cdecl sub_10035DC0(unsigned int *a1, signed int a2, unsigned int a3);
// int __cdecl SIM_proc_rqst(_DWORD); weak
// int SYS_exit_krnl(void); weak
// int __cdecl SYS_pvg_is_booting(_DWORD); weak
// int SYS_enter_krnl(void); weak
// int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_audio_get(_DWORD); weak
// int __cdecl SYS_pvg_alrt_cnt(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_get_actv_set_audio(_DWORD); weak
// int __cdecl SYS_pvg_alrt_get_hdr(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_get_hdr_text(_DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_get_hdr_text_lvl(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_id_is_set(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_is_acked(_DWORD); weak
// int __cdecl SYS_pvg_alrt_is_set(_DWORD); weak
// int __cdecl SYS_pvg_alrt_is_set_data(_DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_is_set_queued(_DWORD); weak
// int __cdecl SYS_pvg_alrt_is_set_text(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_is_viewed(_DWORD); weak
// int __cdecl SYS_pvg_alrt_queue(_DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_queue_flush(_DWORD); weak
// int __cdecl SYS_pvg_alrt_set(_DWORD); weak
// int __cdecl SYS_pvg_alrt_set_data(_DWORD, _DWORD, _DWORD); weak
// int SYS_pvg_alrt_viewed(void); weak
// int SYS_pvg_trig_share(void); weak
// int __cdecl SYS_pvg_trig_update(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_ack(_DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_clr(_DWORD); weak
// int __cdecl SYS_pvg_alrt_clr_data(_DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_crit_lvl(_DWORD); weak
// int TSK_pvg_get_id(void); weak
// int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_run_state(_DWORD); weak
// int __cdecl TSK_pvg_get_smphr_stats(_DWORD, _DWORD); weak
// int TSK_pvg_get_timer(void); weak
// int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_release_smphr(_DWORD); weak
// int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_suspend(_DWORD); weak
// int __cdecl TSK_pvg_wait_evnt(_DWORD); weak
// int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD); weak
// int FIL_vfs_close(void); weak
// int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_read(void); weak
// int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_size(_DWORD); weak
// int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD); weak
// int sprintf(char *, const char *, ...);
// void *__cdecl memset(void *, int, size_t);
// void *__cdecl memcpy(void *, const void *, size_t);
// char *__cdecl strncpy(char *, const char *, size_t);
// _DWORD __thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *); idb
// int __cdecl isdigit(int);
// int __cdecl isxdigit(int);
// int __cdecl isspace(int);
// int __cdecl isprint(int);
// void *__cdecl memcpy_0(void *, const void *, size_t);
// int __cdecl tolower(int);
// void *__cdecl memchr(const void *, int, size_t);
// char *__cdecl strchr(const char *, int);
// int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
// int _snprintf(char *, size_t, const char *, ...);
// char *__cdecl strrchr(const char *, int);
// char *__cdecl strstr(const char *, const char *);
// int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_10037E8E(int a1, int a2, char a3);
// double __cdecl floor(double);
// char *__cdecl strncat(char *, const char *, size_t);
// char *__cdecl strpbrk(const char *, const char *);
// int __cdecl strncmp(const char *, const char *, size_t);
// int *__cdecl _errno();
// unsigned __int32 *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
int __cdecl sub_100394D5(int, FILE *); // idb
int __cdecl sub_1003A06A(int a1);
// int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
signed int __cdecl sub_1003B877(_DWORD *a1);
signed int __cdecl sub_1003B8AE(_DWORD *a1);
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
// int _getptd(void); weak
// void __cdecl free(void *);
// _DWORD __cdecl _calloc_crt(size_t, _DWORD); weak
void sub_1003C4F4();
int (*sub_1003C9A1())(void);
void __cdecl sub_1003C9C5(); // idb
// int __cdecl isleadbyte(int);
// int __cdecl __check_float_string(int, void *, int); idb
// int __fastcall _inc(_DWORD, _DWORD); weak
// _DWORD __cdecl _whiteout(_DWORD); weak
int __cdecl sub_1003EFBA(FILE *, int, struct localeinfo_struct *, int); // idb
int __cdecl sub_10041DCC(int, int, struct localeinfo_struct *); // idb
int __cdecl sub_10041E72(int, int, struct localeinfo_struct *); // idb
DWORD __cdecl sub_100422E2(int a1, int a2, int a3, DWORD dwMoveMethod);
// __int64 __cdecl _lseeki64(int, __int64, int);
_WORD *__cdecl sub_1004247E(int a1, int a2, DWORD nNumberOfBytesToWrite);
_WORD *__cdecl sub_10042AA0(int a1, int a2, DWORD nNumberOfBytesToWrite);
// _DWORD __cdecl _getbuf(_DWORD); weak
int __cdecl sub_10042BC0(signed int a1);
void **sub_10042C1E();
signed int sub_10042C24();
// int __cdecl _fileno(FILE *);
void sub_10043015();
// int _get_sse2_info(void); weak
int sub_100430CD();
int sub_10043892();
int __cdecl sub_10043A4F(int a1);
int __cdecl sub_10043A59(int a1);
int __cdecl sub_10043A63(int a1);
int __cdecl sub_10043B42(int a1);
int __cdecl sub_1004544C(FILE *); // idb
int __cdecl sub_1004556C(int, FILE *); // idb
// int __cdecl _mbtowc_l(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes, _locale_t Locale);
// int __cdecl mbtowc(wchar_t *, const char *, size_t);
int sub_100457B4();
signed int __cdecl sub_10045F99(int a1, int a2);
signed int __cdecl sub_100464DB(int a1, int a2);
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
signed int __cdecl sub_10047DD4(signed int a1);
signed int __cdecl sub_10047E55(signed int a1);
// _DWORD __cdecl __lock_fhandle(_DWORD); weak
void __cdecl sub_10047F66(signed int a1);
// int __cdecl _putwch_nolock(__int16 Buffer); idb
// _DWORD __cdecl flsall(_DWORD); weak
int sub_10048267();
int __cdecl sub_100484C4(int a1, int a2, int a3);
// int __cdecl _read(int, void *, unsigned int);
signed int __cdecl sub_100494B1(signed int a1);
signed int __cdecl sub_10049690(unsigned int a1, int a2, int a3, int a4);
signed int __cdecl sub_100496F0(unsigned int a1, int a2, int a3);
double __cdecl sub_10049710(_DWORD); // weak
bool sub_10049720();
bool sub_10049730();
unsigned int __cdecl sub_10049750(unsigned int a1);
bool __cdecl sub_10049770(int a1);
int __cdecl sub_10049840(int a1);
int __cdecl sub_10049860(int a1, int a2);
signed int __cdecl sub_100498A0(int a1, void *a2, unsigned __int16 a3, __int16 a4);
int __cdecl sub_10049960(int a1);
// int __usercall sub_100499A0@<eax>(int a1@<eax>, int a2@<esi>);
// signed int __usercall sub_10049A50@<eax>(int a1@<eax>, int a2@<esi>);
// char __usercall sub_10049C20@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_10049C30@<eax>(int result@<eax>);
// char __usercall sub_10049C50@<al>(int a1@<eax>);
// int __usercall sub_10049C70@<eax>(int a1@<esi>, unsigned __int8 a2);
int __fastcall sub_10049CB0(int a1, int a2);
// int __usercall sub_10049CD0@<eax>(int a1@<esi>);
// signed int __usercall sub_10049D10@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_10049F20(int a1);
signed int __cdecl sub_1004A190(unsigned int a1, int a2, int a3);
// int __usercall sub_1004A230@<eax>(int a1@<eax>);
// int __usercall sub_1004A250@<eax>(int a1@<edi>, int a2);
// signed int __usercall sub_1004A280@<eax>(int a1@<eax>, int a2@<ebx>);
// void __cdecl __noreturn exit_1(int);
// char __usercall sub_1004A370@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>);
// signed int __usercall sub_1004A3A0@<eax>(int a1@<eax>);
signed int __cdecl sub_1004A3D0(unsigned int a1);
signed int __cdecl sub_1004A420(int a1, int a2);
signed int __cdecl sub_1004A610(unsigned int a1, int a2, int a3);
signed int __cdecl sub_1004A670(unsigned int a1, int a2, int a3);
// signed int __usercall sub_1004A800@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_1004B8B0@<eax>(int a1@<esi>, int a2, unsigned int a3);
// signed int __usercall sub_1004B910@<eax>(int a1@<eax>, int a2, int a3);
// void *__usercall sub_1004C690@<eax>(void *a1@<eax>);
unsigned int __cdecl sub_1004C6B0(int a1, unsigned int a2);
// int __usercall sub_1004C710@<eax>(int result@<eax>);
// int __usercall sub_1004C750@<eax>(int result@<eax>);
// unsigned int __usercall sub_1004DE70@<eax>(int a1@<esi>, int a2);
// void *__usercall sub_1004DF70@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3);
// void *__usercall sub_1004DFF0@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3);
// int __usercall sub_1004E090@<eax>(int a1@<edi>, int a2, size_t a3);
// int __usercall sub_1004E150@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3);
// int __usercall sub_1004E1B0@<eax>(char *a1@<edi>);
// int __usercall sub_1004E270@<eax>(int a1@<ebx>);
char __cdecl sub_1004E330(char *a1, size_t a2, int a3);
char __cdecl sub_1004E380(char *a1, unsigned int a2, int a3);
bool __cdecl sub_1004E3D0(int a1, int a2);
// int __usercall sub_1004E400@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7);
// int __usercall sub_1004E610@<eax>(void *a1@<eax>, int a2);
char *__cdecl sub_1004E660(int a1, int a2);
signed int __cdecl sub_1004E6F0(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6);
bool __cdecl sub_1004E820(void *a1, int a2);
// BOOL __usercall sub_1004E8A0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_1004E940@<eax>(int result@<eax>);
unsigned int __fastcall sub_1004E9D0(unsigned int a1, int a2);
// int __usercall sub_1004E9F0@<eax>(int result@<eax>);
// int __usercall sub_1004EA80@<eax>(int result@<eax>, int a2, int a3);
// int __usercall sub_1004EF00@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>);
// void *__usercall sub_1004EFB0@<eax>(int a1@<edi>);
// int __usercall sub_1004F010@<eax>(int result@<eax>, int a2@<edx>);
// signed int __usercall sub_1004F1E0@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>);
_WORD *__fastcall sub_1004F260(int a1, int a2);
// unsigned int __usercall sub_1004F2D0@<eax>(int a1@<esi>, unsigned int a2);
// unsigned int __usercall sub_1004F480@<eax>(int a1@<esi>, int a2);
// int __usercall sub_1004F550@<eax>(int result@<eax>, int a2@<edi>, int a3);
// int __usercall sub_1004F600@<eax>(int result@<eax>, __int16 a2@<cx>);
// unsigned int __usercall sub_1004F640@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3);
// signed int __usercall sub_1004F6A0@<eax>(signed int result@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_1004F780@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_1004FD20@<eax>(int a1@<eax>);
// int __usercall sub_1004FF60@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4);
// signed int __usercall sub_10050000@<eax>(int a1@<esi>, int a2);
// unsigned int __usercall sub_100501E0@<eax>(int a1@<edi>);
// int __usercall sub_10050320@<eax>(int a1@<eax>, int a2, int a3, int a4);
signed int __cdecl sub_100505D0(int a1, int a2);
// signed int __usercall sub_10050890@<eax>(int a1@<eax>);
// _WORD *__usercall sub_10050960@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
signed int __cdecl sub_10050B80(int a1, int a2);
signed int __cdecl sub_10050E90(int a1, int a2);
signed int __cdecl sub_100512A0(int a1, int a2);
int __cdecl sub_10051410(unsigned int a1, _BYTE *a2, unsigned int a3);
signed int __cdecl sub_10051510(int a1);
// signed int __usercall sub_10051530@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10);
// int (__cdecl *__usercall sub_100519D0@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD);
// int __usercall sub_10051A20@<eax>(int result@<eax>, char a2, char a3, int a4, int a5);
signed int __cdecl sub_10051A40(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_10051DF0@<eax>(int a1@<edi>, int a2@<esi>, int a3);
// signed int __usercall sub_10051F30@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4);
// signed int __usercall sub_10051F80@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9);
// int __usercall sub_10052020@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4);
signed int __cdecl sub_10052040(int a1);
// int __usercall sub_10052050@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_100526F0@<eax>(int a1@<eax>, int a2, int a3);
// signed int __usercall sub_100530D0@<eax>(int a1@<edi>, int a2);
signed int __cdecl sub_10053400(int a1, int a2);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// UINT __stdcall GetConsoleCP();
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall GetLastError();
// LONG __stdcall InterlockedExchange(volatile LONG *Target, LONG Value);

//-------------------------------------------------------------------------
// Data declarations

// extern _UNKNOWN SIM_intf; weak
char *off_10055058[3] = { ".\\test\\atm_alert_test.c", "$Id$", &off_10054F68 }; // weak
__int16 word_10055084 = 34; // weak
_UNKNOWN unk_10056AF8; // weak
_UNKNOWN unk_10056B90; // weak
__int16 word_10057340[] = { 1 }; // weak
int dword_1005734C[] = { 4294967295 }; // weak
char *off_10059260 = "/shr_mem/mon_main_intf.shr"; // weak
char byte_10059A98[] = { '\a' }; // weak
char byte_10059AA4[] = { '\x10' }; // weak
char byte_10059AB0[] = { '\0' }; // weak
char byte_10059ABC[] = { '\0' }; // weak
char *off_1005A3AC[3] = { "MON_test.c", "$Id$", &off_1005A384 }; // weak
char *off_1005A600[3] = { "tst_grp_mon_arfrm.c", "$Id$", &off_1005A4C0 }; // weak
_UNKNOWN unk_1005AE20; // weak
int (*off_1005AF1C[4])() = { &sub_10022550, &sub_1001AB70, &sub_10009820, &sub_10002390 }; // weak
void *tsk_app_hdr_ptr = &tsk_app_hdr; // weak
_UNKNOWN unk_1005C3A0; // weak
_UNKNOWN unk_1005C3FD; // weak
char *off_1005CC38 = "/shr_mem/mon_log_intf.shr"; // weak
char *off_1005CC4C = "/shr_mem/mon_main_intf.shr"; // weak
int dword_1005D2D8[] = { 1 }; // weak
_UNKNOWN off_1005D2DC; // idb
_UNKNOWN unk_1005D3DC; // weak
_UNKNOWN unk_1005E0A8; // weak
_UNKNOWN unk_1005E0AC; // weak
char word_1005E650[] = { ' ', '\0' }; // idb
char *off_1005E710[18] =
{
  "FAIL",
  "PASS",
  "normal",
  "robust",
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_1005E718[16] =
{
  "normal",
  "robust",
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_1005E720[14] =
{
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_1005E73C[7] =
{
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_1005E748[4] = { "FALSE", "TRUE", "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
char *off_1005E750[2] = { "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
_UNKNOWN unk_1005EA08; // weak
_UNKNOWN unk_1005EA54; // weak
int dword_1005F5A4[] = { 88 }; // weak
__int16 word_1005FA54[] = { 836 }; // weak
char *off_1005FA74 = "/shr_mem/iop_a_pkt_intf.shr"; // weak
char *off_1005FA88 = "/shr_mem/iop_b_pkt_intf.shr"; // weak
char *off_1005FA9C = "/shr_mem/iop_c_pkt_intf.shr"; // weak
char *off_1005FAB0 = "/shr_mem/iop_d_dbg_pkt_intf.shr"; // weak
char *off_1005FAC4 = "/shr_mem/iop_d_pkt_intf.shr"; // weak
char *off_1005FAD8 = "/shr_mem/iop_m_pkt_intf.shr"; // weak
_UNKNOWN unk_100617EC; // weak
__int16 word_100617EE[] = { 136 }; // weak
_UNKNOWN unk_10062B80; // weak
_UNKNOWN unk_10062B88; // weak
_UNKNOWN unk_10062B8C; // weak
_UNKNOWN unk_10063200; // weak
_UNKNOWN unk_10063208; // weak
char byte_10063210[] = { '\x01' }; // weak
_UNKNOWN unk_10063220; // weak
_BYTE word_10063226[110] =
{
  169,
  63,
  0,
  0,
  31,
  0,
  59,
  0,
  90,
  0,
  120,
  0,
  151,
  0,
  181,
  0,
  212,
  0,
  243,
  0,
  17,
  1,
  48,
  1,
  78,
  1,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  74,
  75,
  76,
  77,
  80,
  81,
  82,
  83,
  0,
  0,
  93,
  0,
  90,
  0,
  87,
  0,
  96,
  0,
  1,
  0,
  94,
  0,
  91,
  0,
  88,
  0,
  97,
  0,
  2,
  0,
  95,
  0,
  92,
  0,
  89,
  0,
  98,
  0,
  0,
  0,
  0,
  0,
  226,
  0,
  228,
  0,
  224,
  0,
  1,
  0,
  227,
  0,
  229,
  0,
  225,
  0,
  2,
  0,
  60,
  2,
  61,
  2,
  59,
  2,
  0,
  0,
  220,
  0,
  1,
  0,
  222,
  0,
  2,
  0,
  58,
  2
}; // idb
__int16 word_100632EC[] = { 100 }; // weak
_UNKNOWN unk_100641A0; // weak
__int16 word_100641A2[] = { 492 }; // weak
char byte_100641B0[] = { '@' }; // weak
char byte_100641B1[] = { '\x04' }; // weak
char *off_10064904 = "/shr_mem/iop_gma_dig_intf.shr"; // weak
char *off_10064970 = "/shr_mem/pvt_intf.shr"; // weak
__int16 word_10068804[] = { 464 }; // weak
_UNKNOWN unk_10069EFC; // weak
wchar_t a___0[8] = L":;<=>?@"; // weak
wchar_t aAbcde_0[6] = L"ABCDE"; // weak
__int16 word_1006B690[] = { 241 }; // weak
char *off_1006BF68 = "/shr_mem/iop_gia_aud_queue_intf.shr"; // weak
__int16 word_1006DAA0[] = { 0 }; // weak
__int16 word_1006DAA2[] = { 999 }; // weak
__int16 word_1006DAA4[] = { 1000 }; // weak
int dword_1006DAC4[] = { 14000 }; // weak
_UNKNOWN unk_1007F742; // weak
int dword_1007F744 = 9429; // idb
int dword_1008043C[] = { 9826 }; // weak
_UNKNOWN unk_10080440; // weak
_UNKNOWN unk_100817AC; // weak
_UNKNOWN unk_10082870; // weak
char byte_10082874[] = { '\0' }; // weak
char *off_10082CB0[3] = { ".\\test\\tst_tsk_common.c", "$Id$", &off_10082B20 }; // weak
_UNKNOWN unk_10082CC4; // weak
_UNKNOWN unk_10082CC8; // weak
char off_10083F58[] = { '', '', '\x05', '\x10' }; // idb
int dword_10083F74 = 1; // idb
char byte_10083F90[] = { '\x01' }; // weak
char *off_10083F94[3] = { "1", "2", "fail_normal_1" }; // weak
char *off_10083F98[2] = { "2", "fail_normal_1" }; // weak
char off_10083F9C[8] = { 'D', '?', '\b', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_10084020[] = { '\0' }; // weak
char byte_10084021[] = { '\0' }; // weak
int dword_10084024[] = { 0 }; // weak
char *off_10084028 = "0, 0, 0"; // weak
double dbl_10084290[] = {  0.0 }; // weak
double dbl_10084298[] = {  0.0 }; // weak
double dbl_100842A0[] = {  0.0 }; // weak
int dword_100842A8[] = { 0 }; // weak
char off_100842AC[32] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_10084EB0[] = {  0.0 }; // weak
float flt_10084EB4[] = {  0.0 }; // weak
float flt_10084EB8[] = {  0.0 }; // weak
int dword_10084EBC[] = { 0 }; // weak
char *off_10084EC0 = "0, 0, 0"; // weak
char *off_10085644[3] =
{
  "..\\lib\\utf\\utf_validate.c",
  "..\\lib\\utf\\utf_validate.c",
  &off_1009A2A0
}; // weak
int dword_10085658[] = { 0 }; // weak
int dword_1008565C[] = { 0 }; // weak
int dword_10085660[] = { 0 }; // weak
int dword_10085664[] = { 0 }; // weak
char off_10085668[20] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_10085DF0[] = { 0 }; // weak
__int16 word_10085DF2[] = { 0 }; // weak
__int16 word_10085DF4[] = { 0 }; // weak
int dword_10085DF8[] = { 0 }; // weak
char off_10085DFC[16] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10086400[] = { 0 }; // weak
int dword_10086404[] = { 0 }; // weak
int dword_10086408[] = { 0 }; // weak
int dword_1008640C[] = { 0 }; // weak
char *off_10086410 = "0, 0, 0"; // weak
int dword_10086B98[] = { 0 }; // weak
int dword_10086B9C[] = { 0 }; // weak
int dword_10086BA0[] = { 0 }; // weak
int dword_10086BA4[] = { 0 }; // weak
int dword_10086BA8[] = { 0 }; // weak
int dword_10086BAC[] = { 0 }; // weak
int dword_10086BB0[] = { 0 }; // weak
char off_10086BB4[32] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100877B8[] = { '\0' }; // weak
char byte_100877B9[] = { '\0' }; // weak
char byte_100877BA[] = { '\0' }; // weak
int dword_100877BC[] = { 0 }; // weak
char *off_100877C0 = "0, 0, 0"; // weak
int dword_10087C48[] = { 0 }; // weak
int dword_10087C4C[] = { 0 }; // weak
int dword_10087C50[] = { 0 }; // weak
int dword_10087C54[] = { 0 }; // weak
char off_10087C58[20] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100883E0[] = { 0 }; // weak
int dword_100883E4[] = { 0 }; // weak
int dword_100883E8[] = { 0 }; // weak
int dword_100883EC[] = { 0 }; // weak
char *off_100883F0 = "0, 0, 0"; // weak
__int16 word_10088750[] = { 0 }; // weak
__int16 word_10088752[] = { 0 }; // weak
__int16 word_10088754[] = { 0 }; // weak
int dword_10088758[] = { 0 }; // weak
char off_1008875C[16] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10088A10[] = { 0 }; // weak
int dword_10088A14[] = { 0 }; // weak
int dword_10088A18[] = { 0 }; // weak
int dword_10088A1C[] = { 0 }; // weak
char *off_10088A20 = "0, 0, 0"; // weak
int dword_10088D80[] = { 0 }; // weak
int dword_10088D84[] = { 0 }; // weak
int dword_10088D88[] = { 0 }; // weak
int dword_10088D8C[] = { 0 }; // weak
int dword_10088D90[] = { 0 }; // weak
int dword_10088D94[] = { 0 }; // weak
int dword_10088D98[] = { 0 }; // weak
char off_10088D9C[32] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10089300[] = { '\0' }; // weak
char byte_10089301[] = { '\0' }; // weak
char byte_10089302[] = { '\0' }; // weak
int dword_10089304[] = { 0 }; // weak
char *off_10089308 = "0, 0, 0"; // weak
int dword_10089510[] = { 0 }; // weak
int dword_10089514[] = { 0 }; // weak
int dword_10089518[] = { 0 }; // weak
int dword_1008951C[] = { 0 }; // weak
char *off_10089520 = "0, 0, 0"; // weak
char byte_10089880[] = { '\x01' }; // weak
char *off_10089884[3] = { "1", "2", "fail_robust_1" }; // weak
char *off_10089888[2] = { "2", "fail_robust_1" }; // weak
char off_1008988C[8] = { '', ':', '\b', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_10089910[] = { '\0' }; // weak
char byte_10089911[] = { '\0' }; // weak
int dword_10089914[] = { 0 }; // weak
char *off_10089918 = "0, 0, 0"; // weak
double dbl_10089B80[] = {  0.0 }; // weak
double dbl_10089B88[] = {  0.0 }; // weak
double dbl_10089B90[] = {  0.0 }; // weak
int dword_10089B98[] = { 0 }; // weak
char off_10089B9C[32] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_1008A7A0[] = {  0.0 }; // weak
float flt_1008A7A4[] = {  0.0 }; // weak
float flt_1008A7A8[] = {  0.0 }; // weak
int dword_1008A7AC[] = { 0 }; // weak
char *off_1008A7B0 = "0, 0, 0"; // weak
int dword_1008AF38[] = { 0 }; // weak
int dword_1008AF3C[] = { 0 }; // weak
int dword_1008AF40[] = { 0 }; // weak
int dword_1008AF44[] = { 0 }; // weak
char off_1008AF48[20] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_1008B6D0[] = { 0 }; // weak
__int16 word_1008B6D2[] = { 0 }; // weak
__int16 word_1008B6D4[] = { 0 }; // weak
int dword_1008B6D8[] = { 0 }; // weak
char off_1008B6DC[16] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1008BCE0[] = { 0 }; // weak
int dword_1008BCE4[] = { 0 }; // weak
int dword_1008BCE8[] = { 0 }; // weak
int dword_1008BCEC[] = { 0 }; // weak
char *off_1008BCF0 = "0, 0, 0"; // weak
int dword_1008C478[] = { 0 }; // weak
int dword_1008C47C[] = { 0 }; // weak
int dword_1008C480[] = { 0 }; // weak
int dword_1008C484[] = { 0 }; // weak
int dword_1008C488[] = { 0 }; // weak
int dword_1008C48C[] = { 0 }; // weak
int dword_1008C490[] = { 0 }; // weak
char off_1008C494[32] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1008D098[] = { '\0' }; // weak
char byte_1008D099[] = { '\0' }; // weak
char byte_1008D09A[] = { '\0' }; // weak
int dword_1008D09C[] = { 0 }; // weak
char *off_1008D0A0 = "0, 0, 0"; // weak
int dword_1008D528[] = { 0 }; // weak
int dword_1008D52C[] = { 0 }; // weak
int dword_1008D530[] = { 0 }; // weak
int dword_1008D534[] = { 0 }; // weak
char off_1008D538[20] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1008DCC0[] = { 0 }; // weak
int dword_1008DCC4[] = { 0 }; // weak
int dword_1008DCC8[] = { 0 }; // weak
int dword_1008DCCC[] = { 0 }; // weak
char *off_1008DCD0 = "0, 0, 0"; // weak
__int16 word_1008E030[] = { 0 }; // weak
__int16 word_1008E032[] = { 0 }; // weak
__int16 word_1008E034[] = { 0 }; // weak
int dword_1008E038[] = { 0 }; // weak
char off_1008E03C[16] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1008E2F0[] = { 0 }; // weak
int dword_1008E2F4[] = { 0 }; // weak
int dword_1008E2F8[] = { 0 }; // weak
int dword_1008E2FC[] = { 0 }; // weak
char *off_1008E300 = "0, 0, 0"; // weak
int dword_1008E660[] = { 0 }; // weak
int dword_1008E664[] = { 0 }; // weak
int dword_1008E668[] = { 0 }; // weak
int dword_1008E66C[] = { 0 }; // weak
int dword_1008E670[] = { 0 }; // weak
int dword_1008E674[] = { 0 }; // weak
int dword_1008E678[] = { 0 }; // weak
char off_1008E67C[32] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1008EBE0[] = { '\0' }; // weak
char byte_1008EBE1[] = { '\0' }; // weak
char byte_1008EBE2[] = { '\0' }; // weak
int dword_1008EBE4[] = { 0 }; // weak
char *off_1008EBE8 = "0, 0, 0"; // weak
int dword_1008EDF0[] = { 0 }; // weak
int dword_1008EDF4[] = { 0 }; // weak
int dword_1008EDF8[] = { 0 }; // weak
int dword_1008EDFC[] = { 0 }; // weak
char *off_1008EE00 = "0, 0, 0"; // weak
char byte_1008F160[] = { '\x01' }; // weak
char *off_1008F164[3] = { "1", "1", "pass_normal_1" }; // weak
char *off_1008F168[2] = { "1", "pass_normal_1" }; // weak
char off_1008F16C[8] = { ',', ':', '\b', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_1008F1B0[] = { '\0' }; // weak
char byte_1008F1B1[] = { '\0' }; // weak
int dword_1008F1B4[] = { 0 }; // weak
char *off_1008F1B8 = "0, 0, 0"; // weak
double dbl_1008F420[] = {  0.0 }; // weak
double dbl_1008F428[] = {  0.0 }; // weak
double dbl_1008F430[] = {  0.0 }; // weak
int dword_1008F438[] = { 0 }; // weak
char off_1008F43C[32] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_10090040[] = {  0.0 }; // weak
float flt_10090044[] = {  0.0 }; // weak
float flt_10090048[] = {  0.0 }; // weak
int dword_1009004C[] = { 0 }; // weak
char *off_10090050 = "0, 0, 0"; // weak
int dword_100907D8[] = { 0 }; // weak
int dword_100907DC[] = { 0 }; // weak
int dword_100907E0[] = { 0 }; // weak
int dword_100907E4[] = { 0 }; // weak
char off_100907E8[20] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_10090F70[] = { 0 }; // weak
__int16 word_10090F72[] = { 0 }; // weak
__int16 word_10090F74[] = { 0 }; // weak
int dword_10090F78[] = { 0 }; // weak
char off_10090F7C[16] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10091580[] = { 0 }; // weak
int dword_10091584[] = { 0 }; // weak
int dword_10091588[] = { 0 }; // weak
int dword_1009158C[] = { 0 }; // weak
char *off_10091590 = "0, 0, 0"; // weak
int dword_10091D18[] = { 0 }; // weak
int dword_10091D1C[] = { 0 }; // weak
int dword_10091D20[] = { 0 }; // weak
int dword_10091D24[] = { 0 }; // weak
int dword_10091D28[] = { 0 }; // weak
int dword_10091D2C[] = { 0 }; // weak
int dword_10091D30[] = { 0 }; // weak
char off_10091D34[32] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10092938[] = { '\0' }; // weak
char byte_10092939[] = { '\0' }; // weak
char byte_1009293A[] = { '\0' }; // weak
int dword_1009293C[] = { 0 }; // weak
char *off_10092940 = "0, 0, 0"; // weak
int dword_10092DC8[] = { 0 }; // weak
int dword_10092DCC[] = { 0 }; // weak
int dword_10092DD0[] = { 0 }; // weak
int dword_10092DD4[] = { 0 }; // weak
char off_10092DD8[20] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10093560[] = { 0 }; // weak
int dword_10093564[] = { 0 }; // weak
int dword_10093568[] = { 0 }; // weak
int dword_1009356C[] = { 0 }; // weak
char *off_10093570 = "0, 0, 0"; // weak
__int16 word_100938D0[] = { 0 }; // weak
__int16 word_100938D2[] = { 0 }; // weak
__int16 word_100938D4[] = { 0 }; // weak
int dword_100938D8[] = { 0 }; // weak
char off_100938DC[16] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10093B90[] = { 0 }; // weak
int dword_10093B94[] = { 0 }; // weak
int dword_10093B98[] = { 0 }; // weak
int dword_10093B9C[] = { 0 }; // weak
char *off_10093BA0 = "0, 0, 0"; // weak
int dword_10093F00[] = { 0 }; // weak
int dword_10093F04[] = { 0 }; // weak
int dword_10093F08[] = { 0 }; // weak
int dword_10093F0C[] = { 0 }; // weak
int dword_10093F10[] = { 0 }; // weak
int dword_10093F14[] = { 0 }; // weak
int dword_10093F18[] = { 0 }; // weak
char off_10093F1C[32] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10094480[] = { '\0' }; // weak
char byte_10094481[] = { '\0' }; // weak
char byte_10094482[] = { '\0' }; // weak
int dword_10094484[] = { 0 }; // weak
char *off_10094488 = "0, 0, 0"; // weak
int dword_10094690[] = { 0 }; // weak
int dword_10094694[] = { 0 }; // weak
int dword_10094698[] = { 0 }; // weak
int dword_1009469C[] = { 0 }; // weak
char *off_100946A0 = "0, 0, 0"; // weak
char byte_10094A00[] = { '\x01' }; // weak
char *off_10094A04[3] = { "1", "1", "pass_robust_1" }; // weak
char *off_10094A08[2] = { "1", "pass_robust_1" }; // weak
char off_10094A0C[8] = { '', '9', '\b', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_10094A50[] = { '\0' }; // weak
char byte_10094A51[] = { '\0' }; // weak
int dword_10094A54[] = { 0 }; // weak
char *off_10094A58 = "0, 0, 0"; // weak
double dbl_10094CC0[] = {  0.0 }; // weak
double dbl_10094CC8[] = {  0.0 }; // weak
double dbl_10094CD0[] = {  0.0 }; // weak
int dword_10094CD8[] = { 0 }; // weak
char off_10094CDC[32] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_100958E0[] = {  0.0 }; // weak
float flt_100958E4[] = {  0.0 }; // weak
float flt_100958E8[] = {  0.0 }; // weak
int dword_100958EC[] = { 0 }; // weak
char *off_100958F0 = "0, 0, 0"; // weak
int dword_10096078[] = { 0 }; // weak
int dword_1009607C[] = { 0 }; // weak
int dword_10096080[] = { 0 }; // weak
int dword_10096084[] = { 0 }; // weak
char off_10096088[20] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_10096810[] = { 0 }; // weak
__int16 word_10096812[] = { 0 }; // weak
__int16 word_10096814[] = { 0 }; // weak
int dword_10096818[] = { 0 }; // weak
char off_1009681C[16] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10096E20[] = { 0 }; // weak
int dword_10096E24[] = { 0 }; // weak
int dword_10096E28[] = { 0 }; // weak
int dword_10096E2C[] = { 0 }; // weak
char *off_10096E30 = "0, 0, 0"; // weak
int dword_100975B8[] = { 0 }; // weak
int dword_100975BC[] = { 0 }; // weak
int dword_100975C0[] = { 0 }; // weak
int dword_100975C4[] = { 0 }; // weak
int dword_100975C8[] = { 0 }; // weak
int dword_100975CC[] = { 0 }; // weak
int dword_100975D0[] = { 0 }; // weak
char off_100975D4[32] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100981D8[] = { '\0' }; // weak
char byte_100981D9[] = { '\0' }; // weak
char byte_100981DA[] = { '\0' }; // weak
int dword_100981DC[] = { 0 }; // weak
char *off_100981E0 = "0, 0, 0"; // weak
int dword_10098668[] = { 0 }; // weak
int dword_1009866C[] = { 0 }; // weak
int dword_10098670[] = { 0 }; // weak
int dword_10098674[] = { 0 }; // weak
char off_10098678[20] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10098E00[] = { 0 }; // weak
int dword_10098E04[] = { 0 }; // weak
int dword_10098E08[] = { 0 }; // weak
int dword_10098E0C[] = { 0 }; // weak
char *off_10098E10 = "0, 0, 0"; // weak
__int16 word_10099170[] = { 0 }; // weak
__int16 word_10099172[] = { 0 }; // weak
__int16 word_10099174[] = { 0 }; // weak
int dword_10099178[] = { 0 }; // weak
char off_1009917C[16] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10099430[] = { 0 }; // weak
int dword_10099434[] = { 0 }; // weak
int dword_10099438[] = { 0 }; // weak
int dword_1009943C[] = { 0 }; // weak
char *off_10099440 = "0, 0, 0"; // weak
int dword_100997A0[] = { 0 }; // weak
int dword_100997A4[] = { 0 }; // weak
int dword_100997A8[] = { 0 }; // weak
int dword_100997AC[] = { 0 }; // weak
int dword_100997B0[] = { 0 }; // weak
int dword_100997B4[] = { 0 }; // weak
int dword_100997B8[] = { 0 }; // weak
char off_100997BC[32] =
{
  '',
  '>',
  '\b',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10099D20[] = { '\0' }; // weak
char byte_10099D21[] = { '\0' }; // weak
char byte_10099D22[] = { '\0' }; // weak
int dword_10099D24[] = { 0 }; // weak
char *off_10099D28 = "0, 0, 0"; // weak
int dword_10099F30[] = { 0 }; // weak
int dword_10099F34[] = { 0 }; // weak
int dword_10099F38[] = { 0 }; // weak
int dword_10099F3C[] = { 0 }; // weak
char *off_10099F40 = "0, 0, 0"; // weak
_UNKNOWN unk_1009AF20; // weak
char *off_1009DFA4 = "/shr_mem/nav_intf.shr"; // weak
int (*off_1009E4E0[4])() = { &sub_10022710, &sub_10022700, &sub_100226F0, &sub_10022700 }; // weak
char *off_1009E508 = "/shr_mem/prx_intf.shr"; // weak
char *off_1009E578 = "/shr_mem/dat_intf.shr"; // weak
char *off_1009E5AC = "/shr_mem/iop_fltr_data_intf.shr"; // weak
_UNKNOWN unk_1009E9F8; // weak
char *off_1009EB9C[3] = { "***global-commands***", "..\\lib\\utf\\utf_runner.c", &off_1009EBB0 }; // weak
char *off_1009ED40 = "true"; // weak
char byte_1009ED44[] = { '\x01' }; // weak
char *off_1009EDA8 = "failure listener"; // weak
_UNKNOWN unk_1009F5B8; // weak
_UNKNOWN unk_1009F5DC; // weak
_UNKNOWN unk_1009F780; // weak
_UNKNOWN unk_1009F7E8; // weak
int dword_1009F7EC[] = { 1312 }; // weak
__int16 word_100A0938[] = { 43 }; // weak
char byte_100A093C[] = { '\x06' }; // weak
int dword_100A24D8 = 64; // weak
__int16 word_100A24DC[] = { 6782 }; // weak
__int16 word_100A24E0[] = { 128 }; // weak
_UNKNOWN unk_100A24FC; // weak
_DWORD dword_100A2500[4] = { 64, 24, 62, 18 }; // idb
_UNKNOWN unk_100A2514; // weak
__int16 word_100A2516[] = { 420 }; // weak
int dword_100A2524[] = { 0 }; // weak
char *off_100A2600 = "/shr_mem/iop_tcas_ii_intf.shr"; // weak
char *off_100A43A0 = "/shr_mem/iop_gtx_intf.shr"; // weak
_UNKNOWN unk_100A44E0; // weak
char byte_100A46E8[] = { '\x01' }; // weak
__int16 word_100A46EA[] = { 3020 }; // weak
int (__cdecl *off_100A53B8[3])(char) = { &sub_10012520, &sub_10012430, &sub_100123F0 }; // weak
_UNKNOWN unk_100A5BE0; // weak
int dword_100A5BE4[] = { 6006 }; // weak
_UNKNOWN unk_100A5D08; // weak
_UNKNOWN unk_100A5D20; // weak
_UNKNOWN unk_100A5D68; // weak
int dword_100A5D6C[] = { 6767 }; // weak
_UNKNOWN unk_100A5D78; // weak
_UNKNOWN unk_100A5D90; // weak
_UNKNOWN unk_100A5DA8; // weak
int dword_100A5DAC[] = { 6769 }; // weak
_UNKNOWN unk_100A5DC0; // weak
int dword_100A5DC4[] = { 6093 }; // weak
_UNKNOWN unk_100A7818; // weak
__int16 word_100A781A[] = { 565 }; // weak
_UNKNOWN unk_100A8D68; // weak
_UNKNOWN unk_100A8D69; // weak
char *off_100A90D8 = "printf_listener"; // weak
__int16 word_100A9D0C = 2573; // weak
char *off_100A9E68 = "gate_listener"; // weak
char byte_100AA298[] = { '\x01' }; // weak
__int16 word_100AA29A[] = { 3020 }; // weak
char byte_100ABB60[] = { '\x01' }; // weak
__int16 word_100ABB68[] = { 3020 }; // weak
_UNKNOWN unk_100AD238; // weak
void *off_100AD23C = &unk_100ACFB0; // weak
_UNKNOWN unk_100B04D0; // weak
int dword_100B04D4[] = { 0 }; // weak
_UNKNOWN unk_100B04E8; // weak
int dword_100B04EC[] = { 0 }; // weak
_UNKNOWN unk_100B0510; // weak
int dword_100B0514[] = { 0 }; // weak
_UNKNOWN unk_100B0540; // weak
int dword_100B0544[] = { 0 }; // weak
_UNKNOWN unk_100B2320; // weak
char byte_100B2321[] = { '\0' }; // weak
_UNKNOWN unk_100B3F40; // weak
int dword_100B3F44[] = { 0 }; // weak
int dword_100B438C[] = { 0 }; // weak
__int16 *off_100B4390 = &word_100A9D0C; // weak
_UNKNOWN unk_100B4420; // weak
_UNKNOWN unk_100B4424; // weak
_UNKNOWN unk_100B4428; // weak
_UNKNOWN unk_100B442C; // weak
_UNKNOWN unk_100B4430; // weak
_UNKNOWN unk_100B4434; // weak
_UNKNOWN unk_100B4438; // weak
char byte_100B7532[] = { '\x04' }; // weak
char byte_100B7537[] = { '\a' }; // weak
__int16 word_100B8BE0[] = { 1565 }; // weak
__int16 word_100B8BE4[] = { 534 }; // weak
char byte_100B8BE8[] = { '\x04' }; // weak
__int16 word_100B8BEA[] = { 6512 }; // weak
int dword_100B8C00[] = { 118000 }; // weak
_UNKNOWN unk_100B8C24; // weak
int dword_100B8C28[] = { 6829 }; // weak
__int16 word_100B9C62[] = { 233 }; // weak
int dword_100B9C68[] = { 6201 }; // weak
__int16 word_100BC818[] = { 114 }; // weak
__int16 word_100BC928[] = { 551 }; // weak
_UNKNOWN unk_100C3560; // weak
int dword_100C3564[] = { 3535 }; // weak
_UNKNOWN unk_100C3598; // weak
int dword_100C359C[] = { 6813 }; // weak
_UNKNOWN unk_100C35D0; // weak
int dword_100C35D4[] = { 9036 }; // weak
_UNKNOWN unk_100C3608; // weak
int dword_100C360C[] = { 6763 }; // weak
int dword_100C5208[] = { 6103 }; // weak
int dword_100C520C[] = { 8000 }; // weak
int dword_100C6400[] = { 0 }; // weak
_WORD dword_100D4310[512] =
{
  25542,
  42339,
  31992,
  33916,
  30702,
  39287,
  31734,
  36219,
  62207,
  3570,
  27606,
  48491,
  28638,
  45423,
  50577,
  21701,
  12384,
  20528,
  258,
  769,
  26574,
  43367,
  11094,
  32043,
  65255,
  6654,
  55221,
  25303,
  43853,
  59051,
  30444,
  39542,
  51855,
  17866,
  33311,
  40322,
  51593,
  16585,
  32250,
  34685,
  64239,
  5626,
  22962,
  60249,
  18318,
  51527,
  61691,
  3056,
  44353,
  60589,
  54451,
  26580,
  41567,
  64930,
  44869,
  60079,
  39971,
  49052,
  42067,
  63396,
  29412,
  38514,
  49307,
  23488,
  46965,
  49847,
  64993,
  7421,
  37693,
  44691,
  9804,
  27174,
  13932,
  23094,
  16254,
  16703,
  63477,
  759,
  52355,
  20428,
  13416,
  23604,
  42321,
  62629,
  58833,
  13541,
  61945,
  2289,
  29154,
  37745,
  55467,
  29656,
  12642,
  21297,
  5418,
  16149,
  1032,
  3076,
  51093,
  21191,
  9030,
  25891,
  50077,
  24259,
  6192,
  10264,
  38455,
  41366,
  1290,
  3845,
  39471,
  46490,
  1806,
  2311,
  4644,
  13842,
  32795,
  39808,
  58079,
  15842,
  60365,
  9963,
  10062,
  26919,
  45695,
  52658,
  30186,
  40821,
  2322,
  6921,
  33565,
  40579,
  11352,
  29740,
  6708,
  11802,
  6966,
  11547,
  28380,
  45678,
  23220,
  61018,
  41051,
  64416,
  21156,
  63058,
  15222,
  19771,
  54967,
  25046,
  45949,
  52915,
  10578,
  31529,
  58333,
  16099,
  12126,
  28975,
  33811,
  38788,
  21414,
  62803,
  53689,
  26833,
  0,
  0,
  60865,
  11501,
  8256,
  24608,
  64739,
  8188,
  45433,
  51377,
  23478,
  60763,
  27348,
  48746,
  52109,
  18123,
  48743,
  55742,
  14706,
  19257,
  19092,
  56906,
  19608,
  54348,
  22704,
  59480,
  53125,
  19151,
  53435,
  27600,
  61381,
  10991,
  43599,
  58794,
  64493,
  5883,
  17286,
  50499,
  19866,
  55117,
  13158,
  21811,
  34065,
  38021,
  17802,
  53061,
  63977,
  4345,
  516,
  1538,
  32766,
  33151,
  20640,
  61520,
  15480,
  17468,
  40741,
  47775,
  43083,
  58280,
  20898,
  62289,
  41821,
  65187,
  16512,
  49216,
  36613,
  35471,
  37439,
  44434,
  40225,
  48285,
  14448,
  18488,
  62961,
  1269,
  48227,
  57276,
  46711,
  49590,
  55983,
  30170,
  8514,
  25377,
  4128,
  12304,
  65509,
  6911,
  62461,
  3827,
  53951,
  28114,
  52609,
  19661,
  3096,
  5132,
  4902,
  13587,
  60611,
  12268,
  24510,
  57695,
  38709,
  41623,
  17544,
  52292,
  5934,
  14615,
  50323,
  22468,
  42837,
  62119,
  32508,
  33406,
  15738,
  18237,
  25800,
  44132,
  23994,
  59229,
  6450,
  11033,
  29670,
  38259,
  24768,
  41056,
  33049,
  39041,
  20382,
  53583,
  56483,
  32732,
  8772,
  26146,
  10836,
  32298,
  36923,
  43920,
  34827,
  33672,
  18060,
  51782,
  61127,
  10734,
  47211,
  54200,
  5160,
  15380,
  56999,
  31198,
  24252,
  57950,
  2838,
  7435,
  56237,
  30427,
  57563,
  15328,
  12900,
  22066,
  14964,
  20026,
  2580,
  7690,
  18834,
  56137,
  1548,
  2566,
  9288,
  27684,
  23736,
  58460,
  49823,
  24002,
  54205,
  28371,
  44099,
  61356,
  25284,
  42594,
  37177,
  43153,
  38193,
  42133,
  58579,
  14308,
  31218,
  35705,
  59349,
  13031,
  51339,
  17352,
  14190,
  22839,
  28122,
  46957,
  36097,
  35981,
  54705,
  25813,
  20124,
  53838,
  43337,
  57513,
  27864,
  46188,
  22188,
  64086,
  62707,
  2036,
  60111,
  9706,
  26058,
  44901,
  31476,
  36474,
  44615,
  59822,
  2064,
  6152,
  47727,
  54714,
  30960,
  34936,
  9546,
  28453,
  11868,
  29230,
  7224,
  9244,
  42583,
  61862,
  46195,
  51124,
  50839,
  20934,
  59595,
  9192,
  56737,
  31965,
  29928,
  40052,
  7998,
  8479,
  19350,
  56651,
  48481,
  56509,
  35597,
  34443,
  35343,
  34186,
  28896,
  36976,
  15996,
  16958,
  46449,
  50357,
  26316,
  43622,
  18576,
  55368,
  774,
  1283,
  63223,
  502,
  3612,
  4622,
  25026,
  41825,
  13674,
  24373,
  22446,
  63831,
  47465,
  53433,
  34327,
  37254,
  49561,
  22721,
  7482,
  10013,
  40487,
  47518,
  57817,
  14561,
  63723,
  5112,
  38955,
  45976,
  4386,
  13073,
  27090,
  47977,
  55721,
  28889,
  36359,
  35214,
  37939,
  42900,
  39725,
  46747,
  7740,
  8734,
  34581,
  37511,
  59849,
  8425,
  52871,
  18894,
  21930,
  65365,
  10320,
  30760,
  57253,
  31455,
  35843,
  36748,
  41305,
  63649,
  35081,
  32905,
  3354,
  5901,
  48997,
  55999,
  59095,
  12774,
  17028,
  50754,
  26832,
  47208,
  16770,
  49985,
  39209,
  45209,
  11610,
  30509,
  3870,
  4367,
  45179,
  52144,
  21672,
  64596,
  47981,
  54971,
  5676,
  14870
}; // idb
_WORD dword_100D4710[512] =
{
  50853,
  25443,
  63620,
  31868,
  61081,
  30583,
  63117,
  31611,
  65293,
  62194,
  54973,
  27499,
  57009,
  28527,
  37204,
  50629,
  24656,
  12336,
  515,
  257,
  52905,
  26471,
  22141,
  11051,
  59161,
  65278,
  46434,
  55255,
  19942,
  43947,
  60570,
  30326,
  36677,
  51914,
  8093,
  33410,
  35136,
  51657,
  64135,
  32125,
  61205,
  64250,
  45803,
  22873,
  36553,
  18247,
  64267,
  61680,
  16876,
  44461,
  45927,
  54484,
  24573,
  41634,
  17898,
  44975,
  9151,
  40092,
  21495,
  42148,
  58518,
  29298,
  39771,
  49344,
  30146,
  47031,
  57628,
  65021,
  15790,
  37779,
  19562,
  9766,
  27738,
  13878,
  32321,
  16191,
  62722,
  63479,
  33615,
  52428,
  26716,
  13364,
  20980,
  42405,
  53556,
  58853,
  63752,
  61937,
  58003,
  29041,
  43891,
  55512,
  25171,
  12593,
  10815,
  5397,
  2060,
  1028,
  38226,
  51143,
  18021,
  8995,
  40286,
  50115,
  12328,
  6168,
  14241,
  38550,
  2575,
  1285,
  12213,
  39578,
  3593,
  1799,
  9270,
  4626,
  7067,
  32896,
  57149,
  58082,
  52518,
  60395,
  20073,
  10023,
  32717,
  45746,
  60063,
  30069,
  4635,
  2313,
  7582,
  33667,
  22644,
  11308,
  13358,
  6682,
  13869,
  6939,
  56498,
  28270,
  46318,
  23130,
  23547,
  41120,
  42230,
  21074,
  30285,
  15163,
  46945,
  54998,
  32206,
  46003,
  21115,
  10537,
  56638,
  58339,
  24177,
  12079,
  5015,
  33924,
  42741,
  21331,
  47464,
  53713,
  0,
  0,
  49452,
  60909,
  16480,
  8224,
  58143,
  64764,
  31176,
  45489,
  46829,
  23387,
  54462,
  27242,
  36166,
  52171,
  26585,
  48830,
  29259,
  14649,
  38110,
  19018,
  39124,
  19532,
  45288,
  22616,
  34122,
  53199,
  47979,
  53456,
  50474,
  61423,
  20453,
  43690,
  60694,
  64507,
  34501,
  17219,
  39639,
  19789,
  26197,
  13107,
  4500,
  34181,
  35535,
  17733,
  59664,
  63993,
  1030,
  514,
  65153,
  32639,
  41200,
  20560,
  30788,
  15420,
  9658,
  40863,
  19427,
  43176,
  41715,
  20817,
  24062,
  41891,
  32960,
  16448,
  1418,
  36751,
  16301,
  37522,
  8636,
  40349,
  28744,
  14392,
  61700,
  62965,
  25567,
  48316,
  30657,
  46774,
  44917,
  56026,
  16995,
  8481,
  8240,
  4112,
  58650,
  65535,
  64782,
  62451,
  49005,
  53970,
  33100,
  52685,
  6164,
  3084,
  9781,
  4883,
  49967,
  60652,
  48865,
  24415,
  13730,
  38807,
  35020,
  17476,
  11833,
  5911,
  37719,
  50372,
  22002,
  42919,
  64642,
  32382,
  31303,
  15677,
  51372,
  25700,
  47847,
  23901,
  12843,
  6425,
  59029,
  29555,
  49312,
  24672,
  6552,
  33153,
  40657,
  20303,
  41855,
  56540,
  17510,
  8738,
  21630,
  10794,
  15275,
  37008,
  2947,
  34952,
  36042,
  17990,
  50985,
  61166,
  27603,
  47288,
  10300,
  5140,
  42873,
  57054,
  48354,
  24158,
  5661,
  2827,
  44406,
  56283,
  56123,
  57568,
  25686,
  12850,
  29774,
  14906,
  5150,
  2570,
  37595,
  18761,
  3082,
  1542,
  18540,
  9252,
  47332,
  23644,
  40797,
  49858,
  48494,
  54227,
  17391,
  44204,
  50342,
  25186,
  14760,
  37265,
  12708,
  38293,
  54071,
  58596,
  62091,
  31097,
  54578,
  59367,
  35651,
  51400,
  28249,
  14135,
  55991,
  28013,
  396,
  36237,
  45412,
  54741,
  40146,
  20046,
  18912,
  43433,
  55476,
  27756,
  44282,
  22102,
  62215,
  62708,
  53029,
  60138,
  51887,
  25957,
  62606,
  31354,
  18409,
  44718,
  4120,
  2056,
  28629,
  47802,
  61576,
  30840,
  19055,
  9509,
  23666,
  11822,
  14372,
  7196,
  22513,
  42662,
  29639,
  46260,
  38737,
  50886,
  52003,
  59624,
  41340,
  56797,
  59548,
  29812,
  15905,
  7967,
  38621,
  19275,
  25052,
  48573,
  3462,
  35723,
  3973,
  35466,
  57488,
  28784,
  31810,
  15934,
  29124,
  46517,
  52394,
  26214,
  37080,
  18504,
  1541,
  771,
  63233,
  63222,
  7186,
  3598,
  49827,
  24929,
  27231,
  13621,
  44793,
  22359,
  27088,
  47545,
  6033,
  34438,
  39256,
  49601,
  14887,
  7453,
  10169,
  40606,
  55608,
  57825,
  60179,
  63736,
  11187,
  39064,
  8755,
  4369,
  53947,
  26985,
  43376,
  55769,
  1929,
  36494,
  13223,
  38036,
  11702,
  39835,
  15394,
  7710,
  5522,
  34695,
  51488,
  59881,
  34633,
  52942,
  43775,
  21845,
  20600,
  10280,
  42362,
  57311,
  911,
  35980,
  23032,
  41377,
  2432,
  35209,
  6679,
  3341,
  26074,
  49087,
  55089,
  59110,
  33990,
  16962,
  53432,
  26728,
  33475,
  16705,
  10672,
  39321,
  23159,
  11565,
  7697,
  3855,
  31691,
  45232,
  43260,
  21588,
  28118,
  48059,
  11322,
  5654
}; // idb
_WORD dword_100D4B10[512] =
{
  42339,
  25542,
  33916,
  31992,
  39287,
  30702,
  36219,
  31734,
  3570,
  62207,
  48491,
  27606,
  45423,
  28638,
  21701,
  50577,
  20528,
  12384,
  769,
  258,
  43367,
  26574,
  32043,
  11094,
  6654,
  65255,
  25303,
  55221,
  59051,
  43853,
  39542,
  30444,
  17866,
  51855,
  40322,
  33311,
  16585,
  51593,
  34685,
  32250,
  5626,
  64239,
  60249,
  22962,
  51527,
  18318,
  3056,
  61691,
  60589,
  44353,
  26580,
  54451,
  64930,
  41567,
  60079,
  44869,
  49052,
  39971,
  63396,
  42067,
  38514,
  29412,
  23488,
  49307,
  49847,
  46965,
  7421,
  64993,
  44691,
  37693,
  27174,
  9804,
  23094,
  13932,
  16703,
  16254,
  759,
  63477,
  20428,
  52355,
  23604,
  13416,
  62629,
  42321,
  13541,
  58833,
  2289,
  61945,
  37745,
  29154,
  29656,
  55467,
  21297,
  12642,
  16149,
  5418,
  3076,
  1032,
  21191,
  51093,
  25891,
  9030,
  24259,
  50077,
  10264,
  6192,
  41366,
  38455,
  3845,
  1290,
  46490,
  39471,
  2311,
  1806,
  13842,
  4644,
  39808,
  32795,
  15842,
  58079,
  9963,
  60365,
  26919,
  10062,
  52658,
  45695,
  40821,
  30186,
  6921,
  2322,
  40579,
  33565,
  29740,
  11352,
  11802,
  6708,
  11547,
  6966,
  45678,
  28380,
  61018,
  23220,
  64416,
  41051,
  63058,
  21156,
  19771,
  15222,
  25046,
  54967,
  52915,
  45949,
  31529,
  10578,
  16099,
  58333,
  28975,
  12126,
  38788,
  33811,
  62803,
  21414,
  26833,
  53689,
  0,
  0,
  11501,
  60865,
  24608,
  8256,
  8188,
  64739,
  51377,
  45433,
  60763,
  23478,
  48746,
  27348,
  18123,
  52109,
  55742,
  48743,
  19257,
  14706,
  56906,
  19092,
  54348,
  19608,
  59480,
  22704,
  19151,
  53125,
  27600,
  53435,
  10991,
  61381,
  58794,
  43599,
  5883,
  64493,
  50499,
  17286,
  55117,
  19866,
  21811,
  13158,
  38021,
  34065,
  53061,
  17802,
  4345,
  63977,
  1538,
  516,
  33151,
  32766,
  61520,
  20640,
  17468,
  15480,
  47775,
  40741,
  58280,
  43083,
  62289,
  20898,
  65187,
  41821,
  49216,
  16512,
  35471,
  36613,
  44434,
  37439,
  48285,
  40225,
  18488,
  14448,
  1269,
  62961,
  57276,
  48227,
  49590,
  46711,
  30170,
  55983,
  25377,
  8514,
  12304,
  4128,
  6911,
  65509,
  3827,
  62461,
  28114,
  53951,
  19661,
  52609,
  5132,
  3096,
  13587,
  4902,
  12268,
  60611,
  57695,
  24510,
  41623,
  38709,
  52292,
  17544,
  14615,
  5934,
  22468,
  50323,
  62119,
  42837,
  33406,
  32508,
  18237,
  15738,
  44132,
  25800,
  59229,
  23994,
  11033,
  6450,
  38259,
  29670,
  41056,
  24768,
  39041,
  33049,
  53583,
  20382,
  32732,
  56483,
  26146,
  8772,
  32298,
  10836,
  43920,
  36923,
  33672,
  34827,
  51782,
  18060,
  10734,
  61127,
  54200,
  47211,
  15380,
  5160,
  31198,
  56999,
  57950,
  24252,
  7435,
  2838,
  30427,
  56237,
  15328,
  57563,
  22066,
  12900,
  20026,
  14964,
  7690,
  2580,
  56137,
  18834,
  2566,
  1548,
  27684,
  9288,
  58460,
  23736,
  24002,
  49823,
  28371,
  54205,
  61356,
  44099,
  42594,
  25284,
  43153,
  37177,
  42133,
  38193,
  14308,
  58579,
  35705,
  31218,
  13031,
  59349,
  17352,
  51339,
  22839,
  14190,
  46957,
  28122,
  35981,
  36097,
  25813,
  54705,
  53838,
  20124,
  57513,
  43337,
  46188,
  27864,
  64086,
  22188,
  2036,
  62707,
  9706,
  60111,
  44901,
  26058,
  36474,
  31476,
  59822,
  44615,
  6152,
  2064,
  54714,
  47727,
  34936,
  30960,
  28453,
  9546,
  29230,
  11868,
  9244,
  7224,
  61862,
  42583,
  51124,
  46195,
  20934,
  50839,
  9192,
  59595,
  31965,
  56737,
  40052,
  29928,
  8479,
  7998,
  56651,
  19350,
  56509,
  48481,
  34443,
  35597,
  34186,
  35343,
  36976,
  28896,
  16958,
  15996,
  50357,
  46449,
  43622,
  26316,
  55368,
  18576,
  1283,
  774,
  502,
  63223,
  4622,
  3612,
  41825,
  25026,
  24373,
  13674,
  63831,
  22446,
  53433,
  47465,
  37254,
  34327,
  22721,
  49561,
  10013,
  7482,
  47518,
  40487,
  14561,
  57817,
  5112,
  63723,
  45976,
  38955,
  13073,
  4386,
  47977,
  27090,
  28889,
  55721,
  35214,
  36359,
  42900,
  37939,
  46747,
  39725,
  8734,
  7740,
  37511,
  34581,
  8425,
  59849,
  18894,
  52871,
  65365,
  21930,
  30760,
  10320,
  31455,
  57253,
  36748,
  35843,
  63649,
  41305,
  32905,
  35081,
  5901,
  3354,
  55999,
  48997,
  12774,
  59095,
  50754,
  17028,
  47208,
  26832,
  49985,
  16770,
  45209,
  39209,
  30509,
  11610,
  4367,
  3870,
  52144,
  45179,
  64596,
  21672,
  54971,
  47981,
  14870,
  5676
}; // idb
_WORD dword_100D4F10[512] =
{
  25443,
  50853,
  31868,
  63620,
  30583,
  61081,
  31611,
  63117,
  62194,
  65293,
  27499,
  54973,
  28527,
  57009,
  50629,
  37204,
  12336,
  24656,
  257,
  515,
  26471,
  52905,
  11051,
  22141,
  65278,
  59161,
  55255,
  46434,
  43947,
  19942,
  30326,
  60570,
  51914,
  36677,
  33410,
  8093,
  51657,
  35136,
  32125,
  64135,
  64250,
  61205,
  22873,
  45803,
  18247,
  36553,
  61680,
  64267,
  44461,
  16876,
  54484,
  45927,
  41634,
  24573,
  44975,
  17898,
  40092,
  9151,
  42148,
  21495,
  29298,
  58518,
  49344,
  39771,
  47031,
  30146,
  65021,
  57628,
  37779,
  15790,
  9766,
  19562,
  13878,
  27738,
  16191,
  32321,
  63479,
  62722,
  52428,
  33615,
  13364,
  26716,
  42405,
  20980,
  58853,
  53556,
  61937,
  63752,
  29041,
  58003,
  55512,
  43891,
  12593,
  25171,
  5397,
  10815,
  1028,
  2060,
  51143,
  38226,
  8995,
  18021,
  50115,
  40286,
  6168,
  12328,
  38550,
  14241,
  1285,
  2575,
  39578,
  12213,
  1799,
  3593,
  4626,
  9270,
  32896,
  7067,
  58082,
  57149,
  60395,
  52518,
  10023,
  20073,
  45746,
  32717,
  30069,
  60063,
  2313,
  4635,
  33667,
  7582,
  11308,
  22644,
  6682,
  13358,
  6939,
  13869,
  28270,
  56498,
  23130,
  46318,
  41120,
  23547,
  21074,
  42230,
  15163,
  30285,
  54998,
  46945,
  46003,
  32206,
  10537,
  21115,
  58339,
  56638,
  12079,
  24177,
  33924,
  5015,
  21331,
  42741,
  53713,
  47464,
  0,
  0,
  60909,
  49452,
  8224,
  16480,
  64764,
  58143,
  45489,
  31176,
  23387,
  46829,
  27242,
  54462,
  52171,
  36166,
  48830,
  26585,
  14649,
  29259,
  19018,
  38110,
  19532,
  39124,
  22616,
  45288,
  53199,
  34122,
  53456,
  47979,
  61423,
  50474,
  43690,
  20453,
  64507,
  60694,
  17219,
  34501,
  19789,
  39639,
  13107,
  26197,
  34181,
  4500,
  17733,
  35535,
  63993,
  59664,
  514,
  1030,
  32639,
  65153,
  20560,
  41200,
  15420,
  30788,
  40863,
  9658,
  43176,
  19427,
  20817,
  41715,
  41891,
  24062,
  16448,
  32960,
  36751,
  1418,
  37522,
  16301,
  40349,
  8636,
  14392,
  28744,
  62965,
  61700,
  48316,
  25567,
  46774,
  30657,
  56026,
  44917,
  8481,
  16995,
  4112,
  8240,
  65535,
  58650,
  62451,
  64782,
  53970,
  49005,
  52685,
  33100,
  3084,
  6164,
  4883,
  9781,
  60652,
  49967,
  24415,
  48865,
  38807,
  13730,
  17476,
  35020,
  5911,
  11833,
  50372,
  37719,
  42919,
  22002,
  32382,
  64642,
  15677,
  31303,
  25700,
  51372,
  23901,
  47847,
  6425,
  12843,
  29555,
  59029,
  24672,
  49312,
  33153,
  6552,
  20303,
  40657,
  56540,
  41855,
  8738,
  17510,
  10794,
  21630,
  37008,
  15275,
  34952,
  2947,
  17990,
  36042,
  61166,
  50985,
  47288,
  27603,
  5140,
  10300,
  57054,
  42873,
  24158,
  48354,
  2827,
  5661,
  56283,
  44406,
  57568,
  56123,
  12850,
  25686,
  14906,
  29774,
  2570,
  5150,
  18761,
  37595,
  1542,
  3082,
  9252,
  18540,
  23644,
  47332,
  49858,
  40797,
  54227,
  48494,
  44204,
  17391,
  25186,
  50342,
  37265,
  14760,
  38293,
  12708,
  58596,
  54071,
  31097,
  62091,
  59367,
  54578,
  51400,
  35651,
  14135,
  28249,
  28013,
  55991,
  36237,
  396,
  54741,
  45412,
  20046,
  40146,
  43433,
  18912,
  27756,
  55476,
  22102,
  44282,
  62708,
  62215,
  60138,
  53029,
  25957,
  51887,
  31354,
  62606,
  44718,
  18409,
  2056,
  4120,
  47802,
  28629,
  30840,
  61576,
  9509,
  19055,
  11822,
  23666,
  7196,
  14372,
  42662,
  22513,
  46260,
  29639,
  50886,
  38737,
  59624,
  52003,
  56797,
  41340,
  29812,
  59548,
  7967,
  15905,
  19275,
  38621,
  48573,
  25052,
  35723,
  3462,
  35466,
  3973,
  28784,
  57488,
  15934,
  31810,
  46517,
  29124,
  26214,
  52394,
  18504,
  37080,
  771,
  1541,
  63222,
  63233,
  3598,
  7186,
  24929,
  49827,
  13621,
  27231,
  22359,
  44793,
  47545,
  27088,
  34438,
  6033,
  49601,
  39256,
  7453,
  14887,
  40606,
  10169,
  57825,
  55608,
  63736,
  60179,
  39064,
  11187,
  4369,
  8755,
  26985,
  53947,
  55769,
  43376,
  36494,
  1929,
  38036,
  13223,
  39835,
  11702,
  7710,
  15394,
  34695,
  5522,
  59881,
  51488,
  52942,
  34633,
  21845,
  43775,
  10280,
  20600,
  57311,
  42362,
  35980,
  911,
  41377,
  23032,
  35209,
  2432,
  3341,
  6679,
  49087,
  26074,
  59110,
  55089,
  16962,
  33990,
  26728,
  53432,
  16705,
  33475,
  39321,
  10672,
  11565,
  23159,
  3855,
  7697,
  45232,
  31691,
  21588,
  43260,
  48059,
  28118,
  5654,
  11322
}; // idb
int dword_100D5310[] = { 99 }; // weak
int dword_100D5710[] = { 25344 }; // weak
int dword_100D5B10[] = { 6488064 }; // weak
int dword_100D5F10[] = { 1660944384 }; // weak
int dword_100D6338[] = { 128 }; // weak
int dword_100D6348[] = { 0 }; // weak
int dword_100D6358[] = { 0 }; // weak
char byte_100D63C9[] = { '\0' }; // weak
char byte_100D63CA[] = { '\0' }; // weak
char byte_100D63CB[] = { '\0' }; // weak
char byte_100D63CC[] = { '\x10' }; // weak
int dword_100D63E0[] = { 0 }; // weak
_UNKNOWN unk_100D6458; // weak
_UNKNOWN unk_100D68D8; // weak
char byte_100D6950[] = { '\0' }; // weak
char byte_100D6A50[] = { '\0' }; // weak
char byte_100D6B50[] = { '\0' }; // weak
int dword_100D6C50[] = { 0 }; // weak
int dword_100D6CC8[] = { 0 }; // weak
int (__cdecl *off_100D6D48)(int, int) = &sub_100512A0; // weak
int dword_100D6F30[] = { 0 }; // weak
int dword_100D6F78[] = { 16 }; // weak
_UNKNOWN unk_100D6FC8; // weak
_UNKNOWN unk_100D7048; // weak
_UNKNOWN unk_100D70C8; // weak
_UNKNOWN unk_100D7140; // weak
_UNKNOWN unk_100D71B8; // weak
_UNKNOWN unk_100D81B8; // weak
_UNKNOWN unk_100D8310; // weak
_UNKNOWN unk_100D8318; // weak
int (*off_100DA284[3])() = { &_fptrap, &_fptrap, &_fptrap }; // weak
_UNKNOWN unk_100DA340; // weak
void *off_100DAD10 = &unk_10254480; // weak
_UNKNOWN unk_100DAD20; // weak
_UNKNOWN unk_100DAD80; // weak
double dbl_100DAF90 =  1.797693134862316e308; // weak
int dword_100DB28C = 1024; // weak
int dword_100DB290 = 4294966273; // weak
int dword_100DB294 = 53; // weak
int dword_100DB298 = 11; // weak
int dword_100DB29C = 64; // weak
int dword_100DB2A0 = 1023; // weak
int dword_100DB2A4 = 128; // weak
int dword_100DB2A8 = 4294967169; // weak
int dword_100DB2AC = 24; // weak
int dword_100DB2B0 = 8; // weak
int dword_100DB2B4 = 32; // weak
int dword_100DB2B8 = 127; // weak
__int16 word_100DB7C0[] = { 0 }; // weak
_BYTE byte_100DB7C2[31] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
_BYTE byte_100DB7E1[93] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
char byte_100DB83E[] = { '\0' }; // weak
char byte_100DB83F[] = { '\0' }; // weak
__int16 word_100DB844[] = { 0 }; // weak
char byte_100DB846[] = { '\0' }; // weak
char byte_100DB847[] = { '\0' }; // weak
char byte_100DB848[] = { '\0' }; // weak
char byte_100DB849[] = { '\0' }; // weak
__int16 word_100DB84A[] = { 0 }; // weak
int dword_100DB84C[] = { 0 }; // weak
int dword_100DB850[] = { 0 }; // weak
int dword_100DB858[] = { 0 }; // weak
__int16 word_100DB85C[] = { 0 }; // weak
_UNKNOWN unk_100DF648; // weak
__int16 word_100E1588[]; // weak
__int16 word_100E158A[]; // weak
__int16 word_100E158C[]; // weak
char byte_100E158E[]; // weak
int dword_100F4E08; // weak
int dword_100F4E0C; // weak
int dword_100F4E10[]; // weak
int dword_100F4E14; // weak
int dword_100F4E18; // weak
int dword_100F4E1C; // weak
int dword_100F4E20; // weak
int dword_100F4E24; // weak
int dword_100F4E28; // weak
int dword_100F4E2C; // weak
int dword_100F4E30; // weak
_UNKNOWN unk_100F4E34; // weak
int dword_100F4E38; // weak
float flt_100F4E40; // weak
float flt_100F4E44; // weak
float flt_100F4E48; // weak
float flt_100F4E4C; // weak
float flt_100F4E50; // weak
char byte_100F4E54; // weak
char byte_100F4E55; // weak
char byte_100F4E56; // weak
char byte_100F4E57; // weak
float flt_100F4E58; // weak
int dword_100F4E5C; // weak
_UNKNOWN unk_100F4E60; // weak
int dword_10105030; // weak
int dword_10105034; // weak
char byte_10105038[]; // weak
char byte_10105039[]; // weak
float flt_101050B0; // weak
int dword_101050B4; // weak
_UNKNOWN unk_101050B8; // weak
int dword_1010A8B8; // weak
char byte_1010A8BC; // weak
int dword_1010A8C0; // weak
int dword_1010A8C4; // weak
char byte_1010A8C8; // weak
char byte_1010A8C9; // weak
int dword_1010A8CC; // weak
int dword_1010A8D0; // weak
_UNKNOWN unk_1010A8D8; // weak
char byte_1010A92C; // weak
char byte_1010A92D; // weak
char byte_1010A92E; // weak
_UNKNOWN unk_1010A930; // weak
char byte_1010C0A0[]; // weak
int dword_1010C0A4[]; // weak
char byte_1010C3C0; // weak
int dword_1010C3C4; // weak
char byte_1010C3C8[]; // weak
__int16 word_1010C4C8[]; // weak
_UNKNOWN unk_1010C590; // weak
_UNKNOWN unk_1010C690; // weak
int dword_1011D4B8[]; // weak
_UNKNOWN unk_1011D574; // weak
float flt_1011D578; // weak
char byte_1011D57C; // weak
char byte_1011D57D; // weak
char byte_1011D57E; // weak
int dword_1011D580; // weak
int dword_1011D584; // weak
_UNKNOWN unk_1011D588; // weak
_UNKNOWN unk_10134C88; // weak
_UNKNOWN unk_10148508; // weak
_UNKNOWN unk_1015BD88; // weak
_UNKNOWN unk_101632B8; // weak
_UNKNOWN unk_1018A3B8; // weak
_UNKNOWN unk_1018E238; // weak
_UNKNOWN unk_10197838; // weak
_UNKNOWN unk_1019ED68; // weak
_UNKNOWN unk_1019ED69; // weak
_UNKNOWN unk_101A0668; // weak
_UNKNOWN unk_101A0669; // weak
_UNKNOWN unk_101A066A; // weak
_UNKNOWN unk_101A44EA; // weak
char byte_101A44F0[]; // weak
_UNKNOWN unk_101A6C00; // weak
_UNKNOWN unk_101A8B40; // weak
char byte_101A8BC0; // idb
int dword_101A8CDC; // weak
char byte_101A8CE0[254]; // idb
char byte_101A8DDE[]; // weak
char byte_101A8DDF[]; // weak
char byte_101A91E0[2800]; // idb
char byte_101A9CD0[1022]; // idb
char byte_101AA0CE[]; // weak
char byte_101AA0CF[]; // weak
char byte_101AA0D0[1022]; // idb
char byte_101AA4CE[]; // weak
char byte_101AA4CF[]; // weak
char byte_101AA4D0[1022]; // idb
char byte_101AA8CE[]; // weak
char byte_101AA8CF[]; // weak
int dword_101AD8D0[]; // weak
int dword_101AD8E4[]; // weak
char byte_101AD8F8[2800]; // idb
char byte_101AE3E8[2800]; // idb
char byte_101AEED8[2800]; // idb
int dword_101AF9C8[]; // weak
int dword_101AF9DC[]; // weak
char byte_101AF9F0[2796]; // idb
char byte_101B04DC[]; // weak
char byte_101B04E0[559]; // idb
char byte_101B070F[]; // weak
int dword_101B0FD0[]; // weak
int dword_101B0FE4[]; // weak
char byte_101B0FF8[2800]; // idb
char byte_101B1AE8; // weak
char byte_101B1AE9; // weak
int dword_101B1AEC; // weak
int dword_101B1AF0; // weak
int dword_101B1AF4; // weak
int dword_101B1AF8; // weak
int dword_101B1AFC; // weak
int dword_101B1B00; // weak
int dword_101B1B04; // weak
int dword_101B1B08; // weak
int dword_101B1B0C; // weak
int dword_101B1B10; // weak
int dword_101B1B14; // weak
int dword_101B1B18; // weak
_UNKNOWN unk_101B1B20; // weak
_UNKNOWN unk_101B1DE9; // weak
_UNKNOWN unk_101B2074; // weak
_UNKNOWN unk_101B20D1; // weak
_UNKNOWN unk_101B212E; // weak
int dword_101B2264[]; // weak
__int16 word_101B2268[]; // weak
int dword_101B226C; // weak
__int16 word_101B2270; // weak
int dword_101B2274; // weak
__int16 word_101B2278; // weak
int dword_101B227C; // weak
__int16 word_101B2280; // weak
int dword_101B2284; // weak
__int16 word_101B2288; // weak
_UNKNOWN unk_101B2290; // weak
_UNKNOWN unk_101B22BE; // weak
_UNKNOWN unk_101B22E8; // weak
_UNKNOWN unk_101B22EE; // weak
_UNKNOWN unk_101B22F4; // weak
int dword_101B2308[]; // weak
__int16 word_101B230C[]; // weak
int dword_101B2310; // weak
__int16 word_101B2314; // weak
int dword_101B2318; // weak
__int16 word_101B231C; // weak
int dword_101B2320; // weak
__int16 word_101B2324; // weak
int dword_101B2328; // weak
__int16 word_101B232C; // weak
char byte_101B2330[100]; // idb
float flt_101B2394; // weak
float flt_101B2398; // weak
int dword_101B239C; // weak
int dword_101B23A0; // weak
char byte_101B23A4; // weak
float flt_101B4118[]; // weak
char byte_101B4168; // weak
char byte_101B4169; // weak
char byte_101B416A; // weak
float flt_101B4170[]; // weak
float flt_101B4174[]; // weak
float flt_101B4178[]; // weak
float flt_101B417C[]; // weak
float flt_101B42B0[]; // weak
char byte_101BDCD4; // weak
char byte_102162F8[]; // weak
_UNKNOWN unk_10218298; // weak
__int16 word_10218334[]; // weak
char byte_1021DA20; // weak
int dword_1021DA28; // weak
_UNKNOWN unk_1021DA30; // weak
char byte_1021DA49[]; // weak
char byte_1021DD08[]; // weak
char byte_1021DD09[]; // weak
char byte_1021DD28[]; // weak
char byte_1021DD29[]; // weak
_UNKNOWN unk_1021EF70; // weak
int dword_10220920[]; // weak
char byte_10220934; // weak
char byte_10220935; // weak
int dword_10220938; // weak
int dword_1022093C; // weak
int dword_10220940; // weak
int dword_10220944; // weak
int dword_10220948; // weak
int dword_1022094C; // weak
int dword_10220950[]; // weak
int dword_10220954; // weak
int dword_10220958; // weak
int dword_1022095C; // weak
int dword_10220960; // weak
int dword_10220964[]; // weak
int dword_10220968; // weak
int dword_1022096C; // weak
int dword_10220970; // weak
int dword_10220974; // weak
_UNKNOWN unk_10220978; // weak
int dword_10220A90; // weak
char byte_10220A98[]; // weak
char byte_10220AE8[]; // weak
int dword_10227E38; // weak
int dword_10227E40; // weak
char byte_10227E48[]; // weak
char byte_10227E4C[]; // weak
char byte_10227E4D[]; // weak
int dword_10227E54[]; // weak
int dword_10227E5C[]; // weak
int dword_10227E90; // weak
_UNKNOWN unk_10227E98; // weak
int dword_102293D8; // weak
_UNKNOWN unk_102293E0; // weak
_UNKNOWN unk_10229F38; // weak
char byte_1022EB38[]; // weak
char byte_1022EB39[]; // weak
_UNKNOWN unk_1022EBD8; // weak
int dword_1022EEA8[]; // weak
int dword_1022EEAC[]; // weak
_UNKNOWN unk_1022F3C8; // weak
_UNKNOWN unk_102322D0; // weak
_UNKNOWN unk_102327D0; // weak
_UNKNOWN unk_10232878; // weak
char byte_10232898; // weak
char byte_10232899; // weak
char byte_1023289A; // weak
char byte_1023289B; // weak
_UNKNOWN unk_102328A0; // weak
_UNKNOWN unk_102328C0; // weak
_DWORD dword_10246150[16]; // idb
int dword_10246190[]; // weak
int dword_102461D0; // weak
int dword_102461D8[]; // weak
int dword_10246248; // weak
int dword_1024624C; // weak
int dword_10246578; // weak
int dword_10246584; // weak
int dword_10246BA8; // weak
int dword_10246BB4; // weak
int dword_10246BC0; // weak
int dword_10246BC4; // weak
int dword_10246BC8; // weak
int dword_10246BE4; // weak
int dword_10246BE8; // weak
int dword_10246BEC; // weak
int dword_10246BF0; // weak
int dword_10246BF4; // weak
char byte_102543F8; // weak
int dword_102543FC; // weak
int dword_10254400; // weak
int dword_10254404; // weak
int dword_10254408; // weak
int dword_10254410; // weak
int dword_10254414; // weak
int dword_10254418; // weak
int dword_1025441C; // weak
int dword_10254420; // weak
int dword_10254424; // weak
int dword_10254428; // weak
int dword_1025442C; // weak
int dword_10254430; // weak
int dword_10254434; // weak
int dword_10254438; // weak
int dword_1025443C; // weak
int dword_10254440; // weak
int dword_10254444; // weak
int dword_10254460; // weak
void *dword_10254464; // idb
int dword_10255480; // weak
UINT uNumber; // idb
int dword_102554A0[]; // weak
int dword_102555A0; // weak
int dword_102555B8; // weak


//----- (10001000) --------------------------------------------------------
int __usercall sub_10001000@<eax>(int result@<eax>, _WORD *a2@<edx>, _DWORD *a3@<ecx>)
{
  if ( (unsigned __int16)(result - 1000) > 0x3E7u )
  {
    if ( (unsigned __int16)result > 0x3E7u )
    {
      result -= 2000;
      *a3 = 23000;
      *a2 = result;
    }
    else
    {
      *a3 = 14000;
      *a2 = result;
    }
  }
  else
  {
    result -= 1000;
    *a3 = 12000;
    *a2 = result;
  }
  return result;
}

//----- (10001040) --------------------------------------------------------
__int16 __cdecl sub_10001040(int a1, unsigned __int16 a2, int a3)
{
  int v3; // eax@2
  int v4; // esi@2
  int v5; // ecx@2
  int v6; // edx@2
  int v7; // edx@2
  int v8; // eax@2
  int v9; // ecx@2
  __int16 i; // bx@4
  int v11; // esi@5
  int v12; // edx@5
  int v13; // ecx@5
  int v14; // ecx@5
  signed int v16; // [sp+10h] [bp+Ch]@2
  signed int v17; // [sp+10h] [bp+Ch]@5

  if ( a2 == -1 )
  {
    LOWORD(v8) = a3;
  }
  else
  {
    v3 = a3;
    v4 = 4 * a2;
    v5 = (unsigned __int16)a3;
    v6 = 5 * (unsigned __int16)a3;
    v16 = (unsigned __int16)word_100E158A[4 * a2];
    v7 = a1 + 4 * v6;
    *(_WORD *)(v7 + 164) = a2;
    *(float *)(v7 + 168) = (double)v16;
    *(_WORD *)(a1 + 4 * (5 * v5 + 45)) = (unsigned __int8)byte_100E158E[v4 * 2];
    v8 = v3 + 1;
    *(float *)(v7 + 172) = (double)(unsigned __int16)word_100E158C[v4];
    *(float *)(v7 + 176) = (double)(unsigned __int16)word_100E1588[v4];
    v9 = (unsigned __int16)word_100E158A[v4];
    if ( (_WORD)v9 != -1 )
      v8 = (unsigned __int16)sub_10001040(a1, v9, v8);
    for ( i = word_100E158C[v4]; i != -1; i = word_100E158C[v11] )
    {
      v11 = 4 * (unsigned __int16)i;
      v17 = (unsigned __int16)word_100E158A[4 * (unsigned __int16)i];
      v12 = a1 + 20 * (unsigned __int16)v8;
      *(_WORD *)(v12 + 164) = i;
      v13 = 5 * (unsigned __int16)v8++ + 45;
      *(float *)(v12 + 168) = (double)v17;
      *(_WORD *)(a1 + 4 * v13) = (unsigned __int8)byte_100E158E[v11 * 2];
      *(float *)(v12 + 172) = (double)(unsigned __int16)word_100E158C[v11];
      *(float *)(v12 + 176) = (double)(unsigned __int16)word_100E1588[v11];
      v14 = (unsigned __int16)word_100E158A[v11];
      if ( (_WORD)v14 != -1 )
        v8 = (unsigned __int16)sub_10001040(a1, v14, v8);
    }
  }
  return v8;
}
// 100E1588: using guessed type __int16 word_100E1588[];
// 100E158A: using guessed type __int16 word_100E158A[];
// 100E158C: using guessed type __int16 word_100E158C[];

//----- (100011A0) --------------------------------------------------------
__int16 __usercall sub_100011A0@<ax>(signed __int16 a1@<ax>, int a2, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  unsigned int v5; // ebx@1
  bool v6; // sf@2
  unsigned __int8 v7; // of@2
  __int16 result; // ax@3
  bool v9; // zf@3
  int v10; // [sp+10h] [bp+4h]@1
  __int16 *v11; // [sp+14h] [bp+8h]@1

  v3 = a2;
  v4 = (unsigned __int16)a1 % 100;
  sub_10032AE0(a3 + (unsigned __int16)a1 / 100, (int)word_100DB7C0, 16004);
  v5 = 160 * (unsigned __int16)v4;
  sub_1000A6F0(a2 + 2, &byte_100DB7C2[v5], 31);
  sub_1000A6F0(a2 + 33, &byte_100DB7E1[v5], 51);
  *(_WORD *)a2 = word_100DB7C0[v5 / 2];
  *(_BYTE *)(a2 + 126) = byte_100DB83E[v5];
  *(_BYTE *)(a2 + 127) = byte_100DB83F[v5];
  *(_DWORD *)(a2 + 152) = dword_100DB858[v5 / 4];
  *(_BYTE *)(a2 + 134) = byte_100DB846[v5];
  *(_BYTE *)(a2 + 135) = byte_100DB847[v5];
  *(_DWORD *)(a2 + 140) = dword_100DB84C[v5 / 4];
  *(_DWORD *)(a2 + 144) = dword_100DB850[v5 / 4];
  *(_WORD *)(a2 + 132) = word_100DB844[v5 / 2];
  *(_BYTE *)(a2 + 136) = byte_100DB848[v5];
  *(_BYTE *)(a2 + 137) = byte_100DB849[v5];
  *(_WORD *)(a2 + 138) = word_100DB84A[v5 / 2];
  v10 = 0;
  v11 = word_100E1588;
  do
  {
    sub_10032AE0(v10++ + 21000, (int)&unk_100DF648, 8000);
    v7 = __OFSUB__(v11 + 4000, &dword_100F4E08);
    v6 = (char *)(v11 + 4000) - (char *)&dword_100F4E08 < 0;
    qmemcpy(v11, &unk_100DF648, 0x1F40u);
    v11 += 4000;
  }
  while ( v6 ^ v7 );
  result = sub_10001040(v3, word_100DB85C[v5 / 2], 0);
  v9 = *(_WORD *)v3 == -1;
  *(_WORD *)(v3 + 160) = result;
  if ( v9 || !*(_BYTE *)(v3 + 2) || word_100DB85C[v5 / 2] == -1 )
    *(_WORD *)(v3 + 160) = 0;
  return result;
}
// 100DB7C0: using guessed type __int16 word_100DB7C0[];
// 100DB844: using guessed type __int16 word_100DB844[];
// 100DB84A: using guessed type __int16 word_100DB84A[];
// 100DB84C: using guessed type int dword_100DB84C[];
// 100DB850: using guessed type int dword_100DB850[];
// 100DB858: using guessed type int dword_100DB858[];
// 100DB85C: using guessed type __int16 word_100DB85C[];
// 100E1588: using guessed type __int16 word_100E1588[];
// 100F4E08: using guessed type int dword_100F4E08;

//----- (10001330) --------------------------------------------------------
int __cdecl sub_10001330(int a1)
{
  int v1; // ebx@1
  char v2; // al@3
  char *v3; // edi@9
  char v4; // al@10
  unsigned int v5; // eax@11
  char *v6; // edi@11
  char v7; // cl@12
  char *v8; // edi@13
  char v9; // al@14
  int v10; // ecx@15
  int v11; // eax@15
  char *v12; // edi@16
  char v13; // al@17
  char *v14; // edi@20
  char v15; // al@21
  char v17[4]; // [sp+8h] [bp-984h]@1
  unsigned __int16 *v18; // [sp+Ch] [bp-980h]@1
  int v19; // [sp+10h] [bp-97Ch]@1
  char v20; // [sp+14h] [bp-978h]@1
  unsigned __int16 v21; // [sp+B4h] [bp-8D8h]@1
  char v22; // [sp+B8h] [bp-8D4h]@2
  char v23; // [sp+887h] [bp-105h]@9
  char v24; // [sp+888h] [bp-104h]@1

  v1 = 0;
  memset(&v24, 0, 0x100u);
  *(_DWORD *)v17 = 0;
  sub_10001000(a1, &v19, &v18);
  sub_100011A0(v19, (int)&v20, (int)v18);
  sprintf(&v24, "JSON:[");
  if ( v21 > 0u )
  {
    v18 = (unsigned __int16 *)&v22;
    do
    {
      sprintf(v17, "---");
      v2 = sub_1000B620(a1, *v18);
      if ( v2 & 1 )
        v17[0] = 84;
      if ( v2 & 2 )
        v17[1] = 70;
      if ( v2 & 4 )
        v17[2] = 85;
      v3 = &v23;
      do
        v4 = (v3++)[1];
      while ( v4 );
      *(_WORD *)v3 = 34;
      v5 = strlen(v17) + 1;
      v6 = &v23;
      do
        v7 = (v6++)[1];
      while ( v7 );
      qmemcpy(v6, v17, v5);
      v8 = &v23;
      do
        v9 = (v8++)[1];
      while ( v9 );
      v10 = v21;
      v11 = v21 - 1;
      *(_WORD *)v8 = 34;
      if ( v1 < v11 )
      {
        v12 = &v23;
        do
          v13 = (v12++)[1];
        while ( v13 );
        *(_WORD *)v12 = 44;
      }
      v18 += 10;
      ++v1;
    }
    while ( v1 < v10 );
  }
  v14 = &v23;
  do
    v15 = (v14++)[1];
  while ( v15 );
  *(_WORD *)v14 = 93;
  sub_1000AE30(3, (int)"**RESULT**", (int)".\\test\\atm_alert_test.c", (int)"637", (int)&v24);
  return 0;
}

//----- (10001510) --------------------------------------------------------
char __usercall sub_10001510@<al>(__int16 a1@<bx>, unsigned __int8 a2)
{
  signed int v2; // edi@1
  char *v3; // esi@2
  char result; // al@6
  int v5; // [sp+Ch] [bp-880h]@1
  int v6; // [sp+10h] [bp-87Ch]@1
  char v7; // [sp+14h] [bp-878h]@1
  unsigned __int16 v8; // [sp+B4h] [bp-7D8h]@1
  char v9; // [sp+B8h] [bp-7D4h]@2

  sub_10001000(a1, &v5, &v6);
  sub_100011A0(v5, (int)&v7, v6);
  v2 = 0;
  if ( v8 )
  {
    v3 = &v9;
    while ( *((_WORD *)v3 + 8) != a2 || sub_1000B740(a1, *(_WORD *)v3) != 1 )
    {
      ++v2;
      v3 += 20;
      if ( v2 >= v8 )
        goto LABEL_6;
    }
    result = 1;
  }
  else
  {
LABEL_6:
    result = 0;
  }
  return result;
}

//----- (100015D0) --------------------------------------------------------
bool __usercall sub_100015D0@<al>(int a1@<esi>, char a2)
{
  int v3; // [sp+0h] [bp-880h]@1
  int v4; // [sp+4h] [bp-87Ch]@1
  char v5; // [sp+8h] [bp-878h]@1
  int v6; // [sp+ACh] [bp-7D4h]@1

  sub_10001000(a1, &v3, &v4);
  sub_100011A0(v3, (int)&v5, v4);
  return sub_1000B740(a1, v6) == a2;
}

//----- (10001640) --------------------------------------------------------
signed int __cdecl sub_10001640(int a1, int a2)
{
  signed int v2; // edi@1
  void *v3; // ecx@1
  int v4; // edi@2
  char v5; // al@3
  unsigned int v6; // eax@6
  char *v7; // edi@6
  char v8; // cl@7
  unsigned int v9; // eax@8
  char *v10; // edi@8
  char v11; // cl@9
  unsigned int v12; // eax@10
  char *v13; // edi@10
  char v14; // cl@11
  unsigned int v15; // eax@12
  char *v16; // edi@12
  char v17; // cl@13
  int v18; // edx@14
  unsigned int v19; // eax@14
  char *v20; // edi@14
  char v21; // cl@15
  unsigned int v22; // eax@16
  char *v23; // edi@16
  char v24; // cl@17
  unsigned int v25; // eax@18
  char *v26; // edi@18
  char v27; // cl@19
  char *v28; // edi@20
  char v29; // al@21
  char *v30; // eax@23
  int v31; // edi@24
  char v32; // al@25
  unsigned int v33; // eax@28
  char *v34; // edi@28
  char v35; // cl@29
  int v36; // edx@30
  unsigned int v37; // eax@30
  char *v38; // edi@30
  char v39; // cl@31
  unsigned int v40; // eax@32
  char *v41; // edi@32
  char v42; // cl@33
  unsigned int v43; // eax@34
  char *v44; // edi@34
  char v45; // cl@35
  int v46; // edx@36
  unsigned int v47; // eax@36
  char *v48; // edi@36
  char v49; // cl@37
  unsigned int v50; // eax@38
  char *v51; // edi@38
  char v52; // cl@39
  unsigned int v53; // eax@40
  char *v54; // edi@40
  char v55; // cl@41
  int v56; // edx@42
  unsigned int v57; // eax@42
  char *v58; // edi@42
  char v59; // cl@43
  unsigned int v60; // eax@44
  char *v61; // edi@44
  char v62; // cl@45
  char *v63; // edi@46
  char v64; // al@47
  char *v65; // eax@49
  int v66; // edi@50
  char v67; // al@51
  bool v68; // zf@54
  const char *v69; // eax@54
  unsigned int v70; // eax@56
  char *v71; // edi@56
  char v72; // cl@57
  const char *v73; // eax@59
  char *v74; // edx@61
  unsigned int v75; // eax@61
  char *v76; // edi@61
  char v77; // cl@62
  const char *v78; // eax@64
  char v79; // cl@67
  unsigned int v80; // eax@68
  char *v81; // edi@68
  char v82; // cl@69
  const char *v83; // eax@70
  unsigned int v84; // eax@72
  char *v85; // edi@72
  char v86; // cl@73
  __int16 v87; // bx@74
  const char *v88; // eax@74
  unsigned int v89; // eax@76
  char *v90; // edi@76
  char v91; // cl@77
  __int16 v92; // bx@78
  const char *v93; // eax@78
  unsigned int v94; // eax@80
  char *v95; // edi@80
  char v96; // cl@81
  char *v97; // edi@82
  char v98; // al@83
  char *v99; // eax@85
  int v100; // edi@86
  char v101; // al@87
  char *v102; // eax@91
  signed int v103; // eax@92
  signed int v104; // eax@94
  char *v105; // eax@96
  char *v106; // eax@98
  char *v107; // eax@99
  int v109; // [sp+Ch] [bp-2D8h]@0
  int v110; // [sp+10h] [bp-2D4h]@3
  char v111; // [sp+31h] [bp-2B3h]@10
  unsigned __int8 v112; // [sp+8Eh] [bp-256h]@12
  unsigned __int8 v113; // [sp+8Fh] [bp-255h]@14
  int v114; // [sp+90h] [bp-254h]@16
  unsigned __int16 v115; // [sp+94h] [bp-250h]@18
  unsigned __int8 v116; // [sp+96h] [bp-24Eh]@30
  unsigned __int8 v117; // [sp+97h] [bp-24Dh]@32
  unsigned __int8 v118; // [sp+98h] [bp-24Ch]@34
  unsigned __int8 v119; // [sp+99h] [bp-24Bh]@36
  unsigned __int16 v120; // [sp+9Ah] [bp-24Ah]@42
  int v121; // [sp+9Ch] [bp-248h]@38
  int v122; // [sp+A0h] [bp-244h]@40
  int v123; // [sp+A8h] [bp-23Ch]@44
  __int16 v124; // [sp+ACh] [bp-238h]@98
  char v125; // [sp+E4h] [bp-200h]@59
  char v126; // [sp+184h] [bp-160h]@1
  char v127; // [sp+1C0h] [bp-124h]@2
  char v128; // [sp+1DFh] [bp-105h]@6
  char v129; // [sp+1E0h] [bp-104h]@1

  v2 = 4;
  memset(&v129, 0, 0x100u);
  memset(&v126, 0, 0x3Cu);
  switch ( a1 )
  {
    case 9:
      sprintf(&v129, "JSON:{");
      v4 = *(_WORD *)(a2 + 172);
      LOBYTE(v109) = *(_BYTE *)(a2 + 88);
      sub_1000A6F0((int)&v127, (_BYTE *)(a2 + 4), 31);
      if ( (unsigned __int16)v4 > 0x7CFu )
        v5 = sub_1000BF70((int)&v110, (int)&v127, v109, 3);
      else
        v5 = sub_1000BF10((int)&v110, v4);
      if ( !v5 )
      {
        v30 = sub_1000C870("0Alert does not exist:%s\r\n", &v127);
        sub_1000AE30(3, (int)"**RESULT**", (int)".\\test\\atm_alert_test.c", (int)"319", (int)v30);
        goto LABEL_100;
      }
      sprintf(&v126, "\"id\":%d,", (unsigned __int16)v110);
      v6 = strlen(&v126) + 1;
      v7 = &v128;
      do
        v8 = (v7++)[1];
      while ( v8 );
      qmemcpy(v7, &v126, v6);
      sprintf(&v126, "\"main_txt\":\"%s\",", (char *)&v110 + 2);
      v9 = strlen(&v126) + 1;
      v10 = &v128;
      do
        v11 = (v10++)[1];
      while ( v11 );
      qmemcpy(v10, &v126, v9);
      sprintf(&v126, "\"desc_txt\":\"%s\",", &v111);
      v12 = strlen(&v126) + 1;
      v13 = &v128;
      do
        v14 = (v13++)[1];
      while ( v14 );
      qmemcpy(v13, &v126, v12);
      sprintf(&v126, "\"lvl\":%d,", v112);
      v15 = strlen(&v126) + 1;
      v16 = &v128;
      do
        v17 = (v16++)[1];
      while ( v17 );
      v18 = v113;
      qmemcpy(v16, &v126, v15);
      sprintf(&v126, "\"notify\":%d,", v18);
      v19 = strlen(&v126) + 1;
      v20 = &v128;
      do
        v21 = (v20++)[1];
      while ( v21 );
      qmemcpy(v20, &v126, v19);
      sprintf(&v126, "\"period\":%i,", v114);
      v22 = strlen(&v126) + 1;
      v23 = &v128;
      do
        v24 = (v23++)[1];
      while ( v24 );
      qmemcpy(v23, &v126, v22);
      sprintf(&v126, "\"logs\":%d", v115);
      v25 = strlen(&v126) + 1;
      v26 = &v128;
      do
        v27 = (v26++)[1];
      while ( v27 );
      qmemcpy(v26, &v126, v25);
      v28 = &v128;
      do
        v29 = (v28++)[1];
      while ( v29 );
      *(_WORD *)v28 = 125;
      sub_1000AE30(3, (int)"**RESULT**", (int)".\\test\\atm_alert_test.c", (int)"314", (int)&v129);
      v2 = 0;
      break;
    case 10:
      sprintf(&v129, "JSON:{");
      v31 = *(_WORD *)(a2 + 172);
      LOBYTE(v109) = *(_BYTE *)(a2 + 88);
      sub_1000A6F0((int)&v127, (_BYTE *)(a2 + 4), 31);
      if ( (unsigned __int16)v31 > 0x7CFu )
        v32 = sub_1000BF70((int)&v110, (int)&v127, v109, 3);
      else
        v32 = sub_1000BF10((int)&v110, v31);
      if ( !v32 )
      {
        v65 = sub_1000C870("0Alert does not exist:%s\r\n", &v127);
        sub_1000AE30(3, (int)"**RESULT**", (int)".\\test\\atm_alert_test.c", (int)"388", (int)v65);
        goto LABEL_100;
      }
      sprintf(&v126, "\"id\":%d,", (unsigned __int16)v110);
      v33 = strlen(&v126) + 1;
      v34 = &v128;
      do
        v35 = (v34++)[1];
      while ( v35 );
      v36 = v116;
      qmemcpy(v34, &v126, v33);
      sprintf(&v126, "\"ack_flags\":%d,", v36);
      v37 = strlen(&v126) + 1;
      v38 = &v128;
      do
        v39 = (v38++)[1];
      while ( v39 );
      qmemcpy(v38, &v126, v37);
      sprintf(&v126, "\"clear_flags\":%d,", v117);
      v40 = strlen(&v126) + 1;
      v41 = &v128;
      do
        v42 = (v41++)[1];
      while ( v42 );
      qmemcpy(v41, &v126, v40);
      sprintf(&v126, "\"set_aud_id\":%d,", v118);
      v43 = strlen(&v126) + 1;
      v44 = &v128;
      do
        v45 = (v44++)[1];
      while ( v45 );
      v46 = v119;
      qmemcpy(v44, &v126, v43);
      sprintf(&v126, "\"clr_aud_id\":%d,", v46);
      v47 = strlen(&v126) + 1;
      v48 = &v128;
      do
        v49 = (v48++)[1];
      while ( v49 );
      qmemcpy(v48, &v126, v47);
      sprintf(&v126, "\"act_time\":%lu,", v121);
      v50 = strlen(&v126) + 1;
      v51 = &v128;
      do
        v52 = (v51++)[1];
      while ( v52 );
      qmemcpy(v51, &v126, v50);
      sprintf(&v126, "\"deact_time\":%lu,", v122);
      v53 = strlen(&v126) + 1;
      v54 = &v128;
      do
        v55 = (v54++)[1];
      while ( v55 );
      v56 = v120;
      qmemcpy(v54, &v126, v53);
      sprintf(&v126, "\"dscrt_out\":%d,", v56);
      v57 = strlen(&v126) + 1;
      v58 = &v128;
      do
        v59 = (v58++)[1];
      while ( v59 );
      qmemcpy(v58, &v126, v57);
      sprintf(&v126, "\"flags\":%i", v123);
      v60 = strlen(&v126) + 1;
      v61 = &v128;
      do
        v62 = (v61++)[1];
      while ( v62 );
      qmemcpy(v61, &v126, v60);
      v63 = &v128;
      do
        v64 = (v63++)[1];
      while ( v64 );
      *(_WORD *)v63 = 125;
      sub_1000AE30(3, (int)"**RESULT**", (int)".\\test\\atm_alert_test.c", (int)"383", (int)&v129);
      v2 = 0;
      break;
    case 8:
      sprintf(&v129, "JSON:{");
      v66 = *(_WORD *)(a2 + 172);
      LOBYTE(v109) = *(_BYTE *)(a2 + 88);
      sub_1000A6F0((int)&v127, (_BYTE *)(a2 + 4), 31);
      if ( (unsigned __int16)v66 > 0x7CFu )
        v67 = sub_1000BF70((int)&v110, (int)&v127, v109, 3);
      else
        v67 = sub_1000BF10((int)&v110, v66);
      if ( !v67 )
      {
        v99 = sub_1000C870("0Alert does not exist:%s\r\n", &v127);
        sub_1000AE30(3, (int)"**RESULT**", (int)".\\test\\atm_alert_test.c", (int)"465", (int)v99);
        goto LABEL_100;
      }
      v68 = sub_1000BFD0(v110) == 0;
      v69 = "true";
      if ( v68 )
        v69 = "false";
      sprintf(&v126, "\"acked\":%s,", v69);
      v70 = strlen(&v126) + 1;
      v71 = &v128;
      do
        v72 = (v71++)[1];
      while ( v72 );
      qmemcpy(v71, &v126, v70);
      if ( (unsigned __int16)v110 > 0x7CFu )
      {
        v68 = sub_1000C0A0((int)&v127) == 0;
        v78 = "true";
        if ( v68 )
          v78 = "false";
        sprintf(&v126, "\"set\":%s,", v78);
        v74 = &v126;
        v75 = strlen(&v126) + 1;
        v76 = &v128;
        do
          v79 = (v76++)[1];
        while ( v79 );
      }
      else
      {
        v68 = sub_1000BFA0((int)&v110, (int)&v125) == 0;
        v73 = "true";
        if ( v68 )
          v73 = "false";
        sprintf(&v126, "\"set\":%s,", v73);
        v74 = &v126;
        v75 = strlen(&v126) + 1;
        v76 = &v128;
        do
          v77 = (v76++)[1];
        while ( v77 );
      }
      qmemcpy(v76, v74, v75);
      sprintf(&v126, "\"set_text\": \"%s\",", &v127);
      v80 = strlen(&v126) + 1;
      v81 = &v128;
      do
        v82 = (v81++)[1];
      while ( v82 );
      qmemcpy(v81, &v126, v80);
      v68 = sub_100015D0(v110, 2) == 0;
      v83 = "true";
      if ( v68 )
        v83 = "false";
      sprintf(&v126, "\"unknown\":%s,", v83);
      v84 = strlen(&v126) + 1;
      v85 = &v128;
      do
        v86 = (v85++)[1];
      while ( v86 );
      v87 = v110;
      qmemcpy(v85, &v126, v84);
      v68 = sub_10001510(v87, 0xBu) == 0;
      v88 = "true";
      if ( v68 )
        v88 = "false";
      sprintf(&v126, "\"inhibited\":%s,", v88);
      v89 = strlen(&v126) + 1;
      v90 = &v128;
      do
        v91 = (v90++)[1];
      while ( v91 );
      v92 = v110;
      qmemcpy(v90, &v126, v89);
      v68 = sub_10001510(v92, 0xFu) == 0;
      v93 = "true";
      if ( v68 )
        v93 = "false";
      sprintf(&v126, "\"latched\":%s", v93);
      v94 = strlen(&v126) + 1;
      v95 = &v128;
      do
        v96 = (v95++)[1];
      while ( v96 );
      qmemcpy(v95, &v126, v94);
      v97 = &v128;
      do
        v98 = (v97++)[1];
      while ( v98 );
      *(_WORD *)v97 = 125;
      sub_1000AE30(3, (int)"**RESULT**", (int)".\\test\\atm_alert_test.c", (int)"460", (int)&v129);
      v2 = 0;
      break;
    case 11:
      v100 = *(_WORD *)(a2 + 172);
      LOBYTE(v109) = *(_BYTE *)(a2 + 88);
      sub_1000A6F0((int)&v127, (_BYTE *)(a2 + 4), 31);
      if ( (unsigned __int16)v100 > 0x7CFu )
        v101 = sub_1000BF70((int)&v110, (int)&v127, v109, 3);
      else
        v101 = sub_1000BF10((int)&v110, v100);
      if ( !v101 )
      {
        v102 = sub_1000C870("0Alert does not exist:%s\r\n", &v127);
        sub_1000AE30(3, (int)"**RESULT**", (int)".\\test\\atm_alert_test.c", (int)"504", (int)v102);
        goto LABEL_100;
      }
      sub_10001330(v110);
      v2 = 0;
      break;
    case 12:
      dword_10254430 = dword_10254440 + 40;
      v103 = 0;
      do
      {
        *(_BYTE *)(v103 + dword_10254430 + 8) = 0;
        v103 += 12;
      }
      while ( v103 < 120000 );
      dword_10254430 = dword_10254440 + 205204;
      v104 = 0;
      do
      {
        *(_BYTE *)(v104 + dword_10254430 + 8) = 0;
        v104 += 12;
      }
      while ( v104 < 120000 );
      v105 = sub_1000C870("1");
      sub_1000AE30(3, (int)"**RESULT**", (int)".\\test\\atm_alert_test.c", (int)"534", (int)v105);
      v2 = 0;
      break;
    case 13:
      if ( sub_1000BBA0(v3) )
      {
        v124 = -32752;
        sub_10032FE0(49, (int)&v124, 1000, 1);
        v106 = sub_1000C870("1");
        sub_1000AE30(3, (int)"**RESULT**", (int)".\\test\\atm_alert_test.c", (int)"543", (int)v106);
        v2 = 0;
      }
      else
      {
        v107 = sub_1000C870("0Automated test mode must be enabled.");
        sub_1000AE30(3, (int)"**RESULT**", (int)".\\test\\atm_alert_test.c", (int)"548", (int)v107);
LABEL_100:
        v2 = 12;
      }
      break;
    default:
      return v2;
  }
  return v2;
}
// 10254430: using guessed type int dword_10254430;
// 10254440: using guessed type int dword_10254440;

//----- (10002390) --------------------------------------------------------
char **sub_10002390()
{
  return off_10055058;
}
// 10055058: using guessed type char *off_10055058[3];

//----- (100023A0) --------------------------------------------------------
char __cdecl sub_100023A0(char a1)
{
  char result; // al@2

  if ( sub_1000BED0(0) )
  {
    sub_10011D60(6, 271, &a1, 0, 1, 1);
    result = sub_10011EA0(6, 0x10Fu, 255);
  }
  else
  {
    result = sub_10011520(
               "..\\lib\\acl\\iop\\iop_alrt_data_intf.c",
               121,
               0,
               "Non-alert master attempting to broadcast that it is the master");
  }
  return result;
}

//----- (10002400) --------------------------------------------------------
char __cdecl sub_10002400(int a1)
{
  char result; // al@2
  char v2; // [sp+7h] [bp-1h]@1

  v2 = 0;
  if ( (_BYTE)a1 )
  {
    sub_10011D60(6, 712, &v2, 0, 1, 1);
    result = sub_10011EA0(6, 0x2C8u, a1);
  }
  else
  {
    result = sub_10011520("..\\lib\\acl\\iop\\iop_alrt_data_intf.c", 175, 0, 0);
  }
  return result;
}

//----- (10002460) --------------------------------------------------------
char __cdecl sub_10002460(char a1)
{
  sub_10011D60(6, 269, &a1, 0, 4, 1);
  return sub_10011EA0(6, 0x10Du, 255);
}

//----- (100024A0) --------------------------------------------------------
int __thiscall sub_100024A0(void *this)
{
  int result; // eax@1
  int v2; // [sp+4h] [bp-30h]@1
  int v3; // [sp+8h] [bp-2Ch]@1
  int v4; // [sp+Ch] [bp-28h]@1
  int v5; // [sp+10h] [bp-24h]@1
  int v6; // [sp+14h] [bp-20h]@1
  int v7; // [sp+18h] [bp-1Ch]@1
  int v8; // [sp+1Ch] [bp-18h]@1
  int v9; // [sp+20h] [bp-14h]@1
  int v10; // [sp+24h] [bp-10h]@1
  int v11; // [sp+28h] [bp-Ch]@1
  int v12; // [sp+2Ch] [bp-8h]@1
  int v13; // [sp+30h] [bp-4h]@1

  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  dword_100F4E08 = 0;
  dword_100F4E38 = sub_100122C0(this);
  dword_100F4E2C = 0;
  dword_100F4E0C = 0;
  dword_100F4E30 = 0;
  sub_10032B80(6465, (int)&v7, 28);
  dword_100F4E10[0] = v7;
  dword_100F4E14 = v8;
  dword_100F4E18 = v9;
  dword_100F4E1C = v10;
  dword_100F4E20 = v11;
  dword_100F4E24 = v12;
  dword_100F4E28 = v13;
  sub_10033160(39, &unk_100F4E34);
  sub_10032BB0(9210, (int)&v2, 4);
  result = sub_10032BB0(41098, (int)&v3, 16);
  byte_102543F8 = 0;
  return result;
}
// 100F4E08: using guessed type int dword_100F4E08;
// 100F4E0C: using guessed type int dword_100F4E0C;
// 100F4E10: using guessed type int dword_100F4E10[];
// 100F4E14: using guessed type int dword_100F4E14;
// 100F4E18: using guessed type int dword_100F4E18;
// 100F4E1C: using guessed type int dword_100F4E1C;
// 100F4E20: using guessed type int dword_100F4E20;
// 100F4E24: using guessed type int dword_100F4E24;
// 100F4E28: using guessed type int dword_100F4E28;
// 100F4E2C: using guessed type int dword_100F4E2C;
// 100F4E30: using guessed type int dword_100F4E30;
// 100F4E38: using guessed type int dword_100F4E38;
// 102543F8: using guessed type char byte_102543F8;

//----- (10002570) --------------------------------------------------------
char sub_10002570()
{
  int v0; // eax@1
  int v2; // [sp+0h] [bp-4h]@1

  v2 = 0;
  sub_10032CB0(9, &v2, (int)&unk_10056AF8, 1, 0, 0);
  LOBYTE(v0) = sub_10002460(v2);
  if ( !dword_100F4E0C )
  {
    v0 = sub_10032ED0();
    dword_100F4E0C = v0;
  }
  return v0;
}
// 100F4E0C: using guessed type int dword_100F4E0C;

//----- (100025C0) --------------------------------------------------------
int __thiscall sub_100025C0(void *this)
{
  int result; // eax@1
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  result = sub_10032B80(9210, (int)&v2, 4);
  if ( (void *)dword_100F4E38 == v2 )
  {
    sub_100023A0(0);
    result = sub_10032ED0();
    dword_100F4E30 = result;
  }
  return result;
}
// 100F4E30: using guessed type int dword_100F4E30;
// 100F4E38: using guessed type int dword_100F4E38;

//----- (10002600) --------------------------------------------------------
char __cdecl sub_10002600(int *a1)
{
  int v1; // edi@1
  int v2; // esi@1
  unsigned __int8 v3; // bl@1
  int v4; // eax@2
  char v5; // al@4
  char result; // al@8
  void *v7; // ecx@8

  v1 = 0;
  v2 = dword_100F4E38 | j_HWM_pvg_hsdb_get_lrus_online();
  v3 = 0;
  while ( 1 )
  {
    v4 = dword_100F4E10[v3];
    if ( v4 & v2 )
    {
      if ( !(v4 & 0xF0) )
        break;
      v5 = sub_10012640(dword_100F4E10[v3]);
      if ( sub_10012390(v5) != 2 )
        break;
    }
    if ( ++v3 >= 7u )
      goto LABEL_8;
  }
  v1 = dword_100F4E10[v3];
LABEL_8:
  result = sub_1000BC60();
  if ( result )
  {
    if ( !(dword_100F4E38 & 0xF0) || (result = sub_1000BC20(v7), result != 2) )
      v1 = dword_100F4E38;
  }
  if ( !v1 )
    result = sub_10011520("..\\lib\\adl\\mon_alrt_mstr.c", 871, 0, "Alert master not found.");
  *a1 = v1;
  return result;
}
// 100331B0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 100F4E10: using guessed type int dword_100F4E10[];
// 100F4E38: using guessed type int dword_100F4E38;

//----- (100026A0) --------------------------------------------------------
int __thiscall sub_100026A0(void *this)
{
  int result; // eax@1
  void *v2; // ecx@2
  int v3; // esi@3
  void *v4; // [sp+0h] [bp-4h]@1

  v4 = this;
  result = sub_10032B80(9210, (int)&v4, 4);
  if ( (void *)dword_100F4E38 == v4 )
  {
    if ( (unsigned int)(sub_10032ED0() - dword_100F4E30) > 0xEA60 )
    {
      result = sub_100025C0(v2);
    }
    else
    {
      result = j_HWM_pvg_hsdb_get_lrus_online();
      v3 = (unsigned __int8)result;
      if ( (unsigned __int8)result != dword_100F4E2C )
      {
        result = sub_10032ED0() - 55000;
        dword_100F4E30 = result;
        dword_100F4E2C = v3;
      }
    }
  }
  return result;
}
// 100331B0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 100F4E2C: using guessed type int dword_100F4E2C;
// 100F4E30: using guessed type int dword_100F4E30;
// 100F4E38: using guessed type int dword_100F4E38;

//----- (10002710) --------------------------------------------------------
int sub_10002710()
{
  int result; // eax@3
  void *v1; // ecx@9
  int v2; // ecx@13
  int v3; // [sp+4h] [bp-18h]@1
  int v4; // [sp+8h] [bp-14h]@1
  int v5; // [sp+Ch] [bp-10h]@1
  int v6; // [sp+10h] [bp-Ch]@13
  int v7; // [sp+14h] [bp-8h]@20
  int v8; // [sp+18h] [bp-4h]@21

  sub_10032AE0(41098, (int)&v5, 16);
  sub_10032B80(9210, (int)&v3, 4);
  sub_10002600(&v4);
  if ( dword_100F4E38 == v4 )
  {
    if ( dword_100F4E38 == v3 )
    {
      result = v5;
      if ( v5 == dword_100F4E08 )
        goto LABEL_23;
    }
    if ( dword_100F4E0C && (unsigned int)(sub_10032ED0() - dword_100F4E0C) > 0x3E8 || (unsigned __int8)sub_1000BC60() )
    {
      if ( !byte_102543F8 )
        byte_102543F8 = 1;
      sub_10032BB0(9210, (int)&dword_100F4E38, 4);
      dword_100F4E0C = 0;
      sub_100025C0(v1);
    }
    else if ( !sub_1000BB20(30000) )
    {
      sub_10002570();
    }
    goto LABEL_18;
  }
  result = v5;
  dword_100F4E0C = 0;
  if ( v5 == dword_100F4E08 )
    goto LABEL_23;
  v2 = v6;
  if ( v6 == v4 )
  {
    if ( v3 == dword_100F4E38 )
    {
      sub_10002400(v6);
      v2 = v6;
      result = v5;
      byte_102543F8 = 0;
    }
    if ( v3 != v2 )
    {
      sub_10032BB0(9210, (int)&v6, 4);
LABEL_18:
      result = v5;
      goto LABEL_19;
    }
  }
LABEL_19:
  if ( result != dword_100F4E08 && v7 && (unsigned __int8)v8 < 7u )
  {
    result = sub_10006460(v8, result - v7);
    dword_100F4E08 = v5;
    return result;
  }
LABEL_23:
  dword_100F4E08 = result;
  return result;
}
// 100F4E08: using guessed type int dword_100F4E08;
// 100F4E0C: using guessed type int dword_100F4E0C;
// 100F4E38: using guessed type int dword_100F4E38;
// 102543F8: using guessed type char byte_102543F8;

//----- (10002880) --------------------------------------------------------
int __cdecl sub_10002880(unsigned __int8 a1)
{
  int result; // eax@3
  void *v2; // ecx@7
  int v3; // [sp+4h] [bp-4h]@1

  v3 = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      if ( !byte_102543F8 )
        byte_102543F8 = 1;
      sub_10032BB0(9210, (int)&dword_100F4E38, 4);
      dword_100F4E0C = 0;
      result = sub_100025C0(v2);
    }
    else
    {
      result = a1 - 2;
      if ( a1 == 2 )
        dword_100F4E0C = 0;
    }
  }
  else
  {
    result = sub_10032BB0(9210, (int)&v3, 4);
    byte_102543F8 = 0;
  }
  return result;
}
// 100F4E0C: using guessed type int dword_100F4E0C;
// 100F4E38: using guessed type int dword_100F4E38;
// 102543F8: using guessed type char byte_102543F8;

//----- (10002900) --------------------------------------------------------
double __cdecl sub_10002900(float a1, float a2)
{
  double result; // st7@1

  result = a1;
  if ( a2 >= (double)a1 )
    result = a2;
  return result;
}

//----- (10002920) --------------------------------------------------------
int sub_10002920()
{
  int v0; // esi@1
  double v1; // st6@1
  int result; // eax@1
  signed int v3; // ecx@1
  char v4; // bl@3
  unsigned __int8 *v5; // edi@3
  unsigned __int8 v6; // dl@4
  char v7; // cl@4

  flt_100F4E58 = 0.0;
  flt_100F4E4C = 0.0;
  v0 = 0;
  flt_101050B0 = 0.0;
  flt_100F4E50 = 0.0;
  byte_100F4E56 = 0;
  flt_100F4E44 = 0.0;
  byte_100F4E54 = 0;
  flt_100F4E40 = 0.0;
  dword_10105034 = 0;
  flt_100F4E48 = 0.0;
  dword_1010A8C4 = 0;
  byte_100F4E55 = 0;
  byte_1010A8BC = 0;
  dword_1010A8C0 = 0;
  dword_100F4E5C = 0;
  dword_1010A8B8 = 0;
  dword_10105030 = 0;
  dword_101050B4 = sub_10032ED0();
  sub_10033160(104, &byte_100F4E57);
  v1 = 9.8999998e24;
  result = (int)&unk_100F4E60;
  v3 = 1500;
  do
  {
    *(_DWORD *)(result + 40) = 0;
    *(float *)result = -9.8999998e24;
    result += 44;
    --v3;
    *(float *)(result - 36) = -9.8999998e24;
    *(float *)(result - 40) = *(float *)&v1;
    *(float *)(result - 20) = *(float *)&v1;
  }
  while ( v3 );
  v4 = 0;
  v5 = (unsigned __int8 *)&unk_10056B90;
  do
  {
    v6 = *v5;
    v7 = 0;
    if ( *v5 )
    {
      do
      {
        result = 2 * (unsigned __int16)v0;
        byte_10105039[result] = v7++;
        ++v0;
        byte_10105038[result] = v4;
      }
      while ( (unsigned __int8)v7 < v6 );
    }
    ++v4;
    ++v5;
  }
  while ( (unsigned __int8)v4 < 5u );
  return result;
}
// 100F4E40: using guessed type float flt_100F4E40;
// 100F4E44: using guessed type float flt_100F4E44;
// 100F4E48: using guessed type float flt_100F4E48;
// 100F4E4C: using guessed type float flt_100F4E4C;
// 100F4E50: using guessed type float flt_100F4E50;
// 100F4E54: using guessed type char byte_100F4E54;
// 100F4E55: using guessed type char byte_100F4E55;
// 100F4E56: using guessed type char byte_100F4E56;
// 100F4E57: using guessed type char byte_100F4E57;
// 100F4E58: using guessed type float flt_100F4E58;
// 100F4E5C: using guessed type int dword_100F4E5C;
// 10105030: using guessed type int dword_10105030;
// 10105034: using guessed type int dword_10105034;
// 101050B0: using guessed type float flt_101050B0;
// 101050B4: using guessed type int dword_101050B4;
// 1010A8B8: using guessed type int dword_1010A8B8;
// 1010A8BC: using guessed type char byte_1010A8BC;
// 1010A8C0: using guessed type int dword_1010A8C0;
// 1010A8C4: using guessed type int dword_1010A8C4;

//----- (10002A20) --------------------------------------------------------
char __fastcall sub_10002A20(unsigned int a1)
{
  int v1; // eax@3
  unsigned int v3; // [sp+0h] [bp-4h]@1

  v3 = a1;
  if ( sub_10032AE0(9206, (int)&v3, 4) || v3 <= dword_10105030 )
  {
    LOBYTE(v1) = sub_1000C0A0((int)"_reset_pil_mon");
    if ( (_BYTE)v1 )
    {
      v1 = sub_10032ED0();
      dword_101050B4 = v1;
    }
  }
  else
  {
    v1 = sub_10032ED0();
    dword_10105030 = v3;
    dword_101050B4 = v1;
  }
  return v1;
}
// 10105030: using guessed type int dword_10105030;
// 101050B4: using guessed type int dword_101050B4;

//----- (10002A80) --------------------------------------------------------
double __cdecl sub_10002A80(float a1)
{
  double v1; // st7@1
  double result; // st7@2
  float v3; // [sp+4h] [bp+4h]@2
  float v4; // [sp+4h] [bp+4h]@3

  v1 = a1;
  if ( a1 >= 43030.883 )
  {
    v4 = 15857.9462890625 - v1 * 0.08669999986886978;
    result = v4;
  }
  else
  {
    v3 = 55158.07421875 - v1;
    result = v3;
  }
  return result;
}

//----- (10002AC0) --------------------------------------------------------
bool __usercall sub_10002AC0@<al>(unsigned __int8 a1@<al>, char a2@<bl>, signed int a3, signed int a4, char a5)
{
  signed int v5; // ecx@2
  int v6; // esi@2
  int v7; // edx@2
  signed int v8; // eax@3
  double v9; // st7@5
  bool result; // al@12
  float v11; // [sp+4h] [bp-8h]@5
  float v12; // [sp+8h] [bp-4h]@10

  if ( a1 >= 5u )
  {
    sub_10011520("..\\lib\\adl\\mon_alrt_trgr.c", 1330, 0, 0);
    return a2;
  }
  v5 = a4;
  v6 = a1;
  v7 = dword_1005734C[a1];
  if ( a4 == v7 )
    return a2;
  v8 = a3;
  if ( a3 == v7 )
    return a2;
  switch ( v6 )
  {
    case 0:
      v8 = (unsigned __int8)a3;
      v5 = (unsigned __int8)a4;
      v11 = (double)(unsigned __int8)a3;
      v9 = (double)(unsigned __int8)a4;
      break;
    case 1:
      v11 = (double)(unsigned int)a3;
      v9 = (double)(unsigned int)a4;
      break;
    case 3:
      v8 = (unsigned __int16)a3;
      v5 = (unsigned __int16)a4;
      v11 = (double)(signed __int16)a3;
      v9 = (double)(signed __int16)a4;
      break;
    case 4:
      v11 = (double)a3;
      v9 = (double)a4;
      break;
    default:
      v11 = *(float *)&a3;
      v9 = *(float *)&a4;
      break;
  }
  v12 = v9;
  switch ( a5 )
  {
    case 0:
      if ( v12 <= (double)v11 )
        goto LABEL_12;
      return 1;
    case 1:
      if ( v12 < (double)v11 )
        goto LABEL_12;
      return 1;
    case 2:
      if ( v12 >= (double)v11 )
        goto LABEL_12;
      return 1;
    case 3:
      if ( v12 > (double)v11 )
        goto LABEL_12;
      return 1;
    case 4:
      if ( v12 != v11 )
        goto LABEL_12;
      result = 1;
      break;
    case 5:
      if ( v12 == v11 )
LABEL_12:
        result = 0;
      else
        result = 1;
      break;
    case 7:
      result = (v8 & v5) != 0;
      break;
    case 8:
      result = (v8 & v5) == 0;
      break;
    case 9:
      result = (v5 & v8) == v5;
      break;
    case 0xA:
      result = (v5 & v8) != v5;
      break;
    default:
      return a2;
  }
  return result;
}
// 1005734C: using guessed type int dword_1005734C[];

//----- (10002CC0) --------------------------------------------------------
char __usercall sub_10002CC0@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st7@2
  char result; // al@4
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_10012930(0, &v5);
  v2 = sub_10012950(0, &v6);
  if ( v1 )
  {
    v3 = v5;
    if ( v2 )
    {
      if ( v6 < v3 )
      {
        result = 1;
        *a1 = v5;
        return result;
      }
      v5 = v6;
      v3 = v6;
    }
    *a1 = v3;
    result = 1;
  }
  else if ( v2 )
  {
    result = 1;
    *a1 = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10002D30) --------------------------------------------------------
char __usercall sub_10002D30@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st7@2
  char result; // al@4
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_100128E0(0, &v5);
  v2 = sub_10012890(0, &v6);
  if ( v1 )
  {
    v3 = v5;
    if ( v2 )
    {
      if ( v6 < v3 )
      {
        result = 1;
        *a1 = v5;
        return result;
      }
      v5 = v6;
      v3 = v6;
    }
    *a1 = v3;
    result = 1;
  }
  else if ( v2 )
  {
    result = 1;
    *a1 = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10002DA0) --------------------------------------------------------
char __usercall sub_10002DA0@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st7@2
  char result; // al@4
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_100128E0(1, &v5);
  v2 = sub_10012890(1, &v6);
  if ( v1 )
  {
    v3 = v5;
    if ( v2 )
    {
      if ( v6 < v3 )
      {
        result = 1;
        *a1 = v5;
        return result;
      }
      v5 = v6;
      v3 = v6;
    }
    *a1 = v3;
    result = 1;
  }
  else if ( v2 )
  {
    result = 1;
    *a1 = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10002E10) --------------------------------------------------------
bool *__usercall sub_10002E10@<eax>(unsigned __int16 a1@<ax>, bool *a2)
{
  bool v2; // zf@1
  bool *result; // eax@1

  v2 = sub_10012990(byte_10105038[2 * a1], byte_10105039[2 * a1]) == 0;
  result = a2;
  *a2 = !v2;
  return result;
}

//----- (10002E50) --------------------------------------------------------
char __usercall sub_10002E50@<al>(size_t a1@<edi>, int a2@<esi>, __int16 a3, void *a4)
{
  char v4; // bl@1
  int v5; // eax@1

  v4 = 0;
  v5 = j_reg_get_tag_info((unsigned __int16)a3, 0);
  a2 = (unsigned __int16)a2;
  a1 = (unsigned __int16)a1;
  if ( v5 >= (unsigned __int16)a1 + (unsigned __int16)a2 && !sub_10032AE0((unsigned __int16)a3, (int)&unk_101050B8, v5) )
  {
    v4 = 1;
    memcpy(a4, (char *)&unk_101050B8 + a2, a1);
  }
  return v4;
}
// 10032AD0: using guessed type int __cdecl j_reg_get_tag_info(_DWORD, _DWORD);

//----- (10002EA0) --------------------------------------------------------
BOOL __usercall sub_10002EA0@<eax>(_BYTE *a1@<esi>, unsigned __int8 a2)
{
  BOOL result; // eax@1
  char v3; // [sp+0h] [bp-FCh]@1
  char v4[200]; // [sp+30h] [bp-CCh]@2

  result = sub_10012C60((int)&v3);
  if ( (_BYTE)result )
    *a1 = v4[2 * a2];
  else
    *a1 = 0;
  return result;
}
// 10002EA0: using guessed type char var_CC[200];

//----- (10002F00) --------------------------------------------------------
int __cdecl sub_10002F00(float a1)
{
  float v1; // ST00_4@1
  float v2; // ST00_4@2
  double v3; // st7@2
  double v4; // st6@2
  double v5; // st6@4
  float v7; // [sp+Ch] [bp+4h]@2
  float v8; // [sp+Ch] [bp+4h]@6

  v1 = flt_100F4E48 - a1;
  if ( COERCE_FLOAT(LODWORD(v1) & 0x7FFFFFFF) > 30.48 )
  {
    v2 = pow(a1, 2.0);
    v3 = a1;
    v7 = v2 * 0.00006959750317037106 - 1.345610022544861 * a1 + 6494.43994140625;
    v4 = 0.0;
    if ( v7 > 0.0 )
      v4 = v7;
    flt_100F4E40 = v4;
    v5 = flt_100F4E40;
    if ( flt_100F4E40 >= 1800.0 )
      v5 = 1800.0;
    v8 = v5;
    flt_100F4E40 = v8;
    flt_100F4E48 = v3;
  }
  return (signed __int64)flt_100F4E40;
}
// 100F4E40: using guessed type float flt_100F4E40;
// 100F4E48: using guessed type float flt_100F4E48;

//----- (10002FE0) --------------------------------------------------------
char __cdecl sub_10002FE0(int a1)
{
  char result; // al@1

  result = 1;
  if ( HIWORD(a1) <= 0x7C5u
    || HIWORD(a1) > 0x84Eu
    || HIWORD(a1) == 2126 && (unsigned __int8)a1 > 2u
    || HIWORD(a1) == 2126 && (_BYTE)a1 == 2 && BYTE1(a1) > 4u )
  {
    result = 0;
  }
  return result;
}

//----- (10003020) --------------------------------------------------------
char __usercall sub_10003020@<al>(int a1@<eax>, char *a2)
{
  *a2 = sub_10012F60(*(_WORD *)(a1 + 2));
  return 1;
}

//----- (10003040) --------------------------------------------------------
char __cdecl sub_10003040(_BYTE *a1)
{
  char v1; // cl@1
  double v2; // st6@4
  float v4; // [sp+0h] [bp-10h]@1
  float v5; // [sp+4h] [bp-Ch]@1
  float v6; // [sp+8h] [bp-8h]@1
  float v7; // [sp+Ch] [bp-4h]@1

  v4 = 9.8999998e24;
  sub_10032B40(2103, &v6, 4, &v4);
  sub_10013640(&v7);
  v1 = sub_10013210(&v5);
  if ( v1 )
  {
    if ( v5 < 7467.6 )
    {
      if ( v6 == 9.8999998e24 )
      {
        v2 = 2438.4;
      }
      else
      {
        v2 = 2438.4;
        if ( v6 > 2438.4 )
        {
          *a1 = 1;
          return v1;
        }
      }
      if ( v7 != 9.8999998e24 && v2 < v7 )
      {
        *a1 = 1;
        return v1;
      }
    }
    *a1 = 0;
  }
  return v1;
}

//----- (10003110) --------------------------------------------------------
BOOL __cdecl sub_10003110(char *a1)
{
  char v1; // al@1
  char v2; // bl@1
  bool v3; // zf@21
  char v5; // [sp+5h] [bp-Bh]@1
  char v6; // [sp+6h] [bp-Ah]@1
  char v7; // [sp+7h] [bp-9h]@1
  float v8; // [sp+8h] [bp-8h]@1
  float v9; // [sp+Ch] [bp-4h]@1

  v7 = sub_10013270(&v9);
  sub_10013750((bool *)&v6);
  v1 = sub_10013670(&v8);
  v2 = byte_1010A8BC;
  v5 = v1;
  if ( v6 && !byte_100F4E55 || v1 && v8 < 121.92 && flt_100F4E4C > 121.92 )
  {
    v2 = 1;
    dword_100F4E5C = sub_10032ED0();
  }
  byte_100F4E55 = v6;
  if ( v5 )
    flt_100F4E4C = v8;
  if ( byte_1010A8BC && (unsigned int)(sub_10032ED0() - dword_1010A8C0) > 0x15F90
    || v5 && v8 > 182.88
    || byte_100F4E55 && (unsigned int)(sub_10032ED0() - dword_100F4E5C) > 0x61A8
    || !v7
    || v9 < 20.57777777777778 )
  {
    v2 = 0;
  }
  else if ( v2 && !byte_1010A8BC )
  {
    dword_1010A8C0 = sub_10032ED0();
  }
  v3 = v7 == 0;
  byte_1010A8BC = v2;
  *a1 = v2;
  return !v3 || v5;
}
// 100F4E4C: using guessed type float flt_100F4E4C;
// 100F4E55: using guessed type char byte_100F4E55;
// 100F4E5C: using guessed type int dword_100F4E5C;
// 1010A8BC: using guessed type char byte_1010A8BC;
// 1010A8C0: using guessed type int dword_1010A8C0;

//----- (10003250) --------------------------------------------------------
char __cdecl sub_10003250(char *a1)
{
  char v1; // al@1
  char v2; // bl@1
  char result; // al@18
  char v4; // [sp+5h] [bp-Fh]@1
  char v5; // [sp+6h] [bp-Eh]@1
  char v6; // [sp+7h] [bp-Dh]@1
  float v7; // [sp+8h] [bp-Ch]@1
  float v8; // [sp+Ch] [bp-8h]@1
  float v9; // [sp+10h] [bp-4h]@10

  v4 = sub_10013270(&v7);
  sub_10013750((bool *)&v5);
  v1 = sub_10013210(&v8);
  v2 = byte_100F4E54;
  v6 = v1;
  if ( v1 && (!v5 && byte_100F4E56 || v4 && v7 >= 25.72222222222222 && flt_100F4E58 < 25.72222222222222) )
  {
    v2 = 1;
    dword_1010A8C4 = sub_10032ED0();
    sub_10032BB0(2103, (int)&v8, 4);
  }
  byte_100F4E56 = v5;
  if ( v4 )
    flt_100F4E58 = v7;
  sub_10032AE0(2103, (int)&v9, 4);
  if ( (!byte_100F4E54 || (unsigned int)(sub_10032ED0() - dword_10105034) <= 0x15F90)
    && (!v6 || v9 + 121.9199981689453 >= v8)
    && (byte_100F4E56 || (unsigned int)(sub_10032ED0() - dword_1010A8C4) <= 0x61A8)
    && v4
    && v7 >= 20.57777777777778 )
  {
    if ( v2 )
    {
      if ( !byte_100F4E54 )
        dword_10105034 = sub_10032ED0();
    }
    *a1 = v2;
    result = v4;
    byte_100F4E54 = v2;
  }
  else
  {
    *a1 = 0;
    result = v4;
    byte_100F4E54 = 0;
  }
  return result;
}
// 100F4E54: using guessed type char byte_100F4E54;
// 100F4E56: using guessed type char byte_100F4E56;
// 100F4E58: using guessed type float flt_100F4E58;
// 10105034: using guessed type int dword_10105034;
// 1010A8C4: using guessed type int dword_1010A8C4;

//----- (100033D0) --------------------------------------------------------
char __usercall sub_100033D0@<al>(_DWORD *a1@<edi>)
{
  char v1; // bl@1
  unsigned int v2; // esi@3
  int v3; // ST18_4@3
  unsigned int v4; // esi@5
  unsigned int v5; // eax@5
  int v7; // [sp+8h] [bp-14h]@3
  unsigned __int64 v8; // [sp+Ch] [bp-10h]@1
  unsigned int v9; // [sp+14h] [bp-8h]@1
  unsigned int v10; // [sp+18h] [bp-4h]@1

  v1 = 0;
  v9 = 0;
  v10 = 0;
  v8 = 0i64;
  if ( sub_10012200(1, 1, 0, 8, &v9) )
  {
    if ( sub_10012200(1, 2, 0, 8, &v8) )
    {
      v2 = v10;
      LOBYTE(v3) = (v10 >> 16) & 0xF;
      HIWORD(v3) = (v10 >> 20) & 0xFFF;
      BYTE1(v3) = (v10 >> 11) & 0x1F;
      HIWORD(v7) = (HIDWORD(v8) >> 20) & 0xFFF;
      LOBYTE(v7) = (HIDWORD(v8) >> 16) & 0xF;
      BYTE1(v7) = (HIDWORD(v8) >> 11) & 0x1F;
      if ( sub_10002FE0(v3) )
      {
        if ( sub_10002FE0(v7) )
        {
          v1 = 1;
          v4 = sub_10013B70(__PAIR__(v2, v9));
          v5 = sub_10013B70(v8);
          if ( v4 >= v5 )
          {
            *a1 = v4 - v5;
            return 1;
          }
          *a1 = v5 - v4;
        }
      }
    }
  }
  return v1;
}

//----- (100034E0) --------------------------------------------------------
char __fastcall sub_100034E0(int a1, float *a2)
{
  int v2; // esi@1
  char v3; // bl@1
  float *v4; // edi@1
  char v5; // al@7
  double v6; // st7@12
  double v7; // st6@12
  char v8; // al@41
  unsigned int v9; // eax@57
  char v10; // al@64
  char v11; // al@82
  double v12; // st7@95
  bool v13; // zf@95
  double v14; // st6@95
  char v15; // al@101
  unsigned int v16; // esi@121
  char v17; // al@126
  char v18; // al@129
  char v19; // al@132
  char v20; // al@135
  char v21; // al@138
  bool v22; // cl@144
  char v23; // al@145
  char v24; // al@163
  char v25; // al@173
  double v26; // st7@175
  double v27; // st6@175
  char v28; // al@197
  int v29; // eax@199
  double v30; // st7@211
  double v31; // st7@215
  char v32; // bl@244
  signed int v33; // esi@245
  unsigned int v34; // ST08_4@245
  int v35; // eax@245
  int v36; // ecx@247
  char v37; // al@257
  char v38; // al@262
  char v39; // al@268
  char v40; // al@274
  char v41; // al@289
  int v42; // eax@298
  bool v43; // al@300
  double v44; // st7@305
  double v45; // st7@306
  int v47; // [sp+0h] [bp-5E4h]@274
  int *v48; // [sp+4h] [bp-5E0h]@274
  int *v49; // [sp+Ch] [bp-5D8h]@6
  int v50; // [sp+1Ch] [bp-5C8h]@6
  float v51; // [sp+20h] [bp-5C4h]@5
  char v52[4]; // [sp+24h] [bp-5C0h]@2
  float v53; // [sp+28h] [bp-5BCh]@100
  char v54; // [sp+2Eh] [bp-5B6h]@39
  char v55; // [sp+2Fh] [bp-5B5h]@41
  double v56; // [sp+30h] [bp-5B4h]@70
  int v57; // [sp+38h] [bp-5ACh]@197
  int v58; // [sp+3Ch] [bp-5A8h]@245
  unsigned int v59; // [sp+40h] [bp-5A4h]@244
  int v60; // [sp+44h] [bp-5A0h]@245
  float v61; // [sp+48h] [bp-59Ch]@143
  float v62; // [sp+4Ch] [bp-598h]@153
  float v63; // [sp+50h] [bp-594h]@144
  float v64; // [sp+54h] [bp-590h]@144
  double v65; // [sp+58h] [bp-58Ch]@244
  double v66; // [sp+60h] [bp-584h]@244
  int v67; // [sp+68h] [bp-57Ch]@266
  int v68; // [sp+6Ch] [bp-578h]@266
  int v69; // [sp+70h] [bp-574h]@266
  int v70; // [sp+74h] [bp-570h]@266
  int v71; // [sp+78h] [bp-56Ch]@244
  char v72; // [sp+80h] [bp-564h]@228
  char v73; // [sp+81h] [bp-563h]@229
  double v74; // [sp+88h] [bp-55Ch]@215
  char v75; // [sp+90h] [bp-554h]@35
  char v76; // [sp+A3h] [bp-541h]@35
  char v77; // [sp+CCh] [bp-518h]@213
  float v78; // [sp+F0h] [bp-4F4h]@215
  char v79; // [sp+114h] [bp-4D0h]@224
  char v80; // [sp+115h] [bp-4CFh]@225
  char v81; // [sp+135h] [bp-4AFh]@226

  v2 = a1;
  v3 = 0;
  v4 = a2;
  switch ( *(_WORD *)(a1 + 2) )
  {
    case 0:
      sub_10013750((bool *)v52);
      v3 = 1;
      *(_BYTE *)v4 = v52[0];
      return v3;
    case 1:
      return sub_10013570(a2);
    case 3:
      return sub_10032AE0(10016, (int)a2, 1) == 0;
    case 4:
      if ( !sub_100170A0(0x7Eu, &v51) )
        goto LABEL_10;
      v49 = &v50;
      goto LABEL_7;
    case 5:
      if ( !sub_100170A0(0x7Fu, &v51) )
        goto LABEL_10;
      v5 = sub_100170A0(0x35u, (float *)&v50);
      goto LABEL_8;
    case 6:
      if ( !sub_100170A0(0x7Cu, &v51) )
        goto LABEL_10;
      v49 = &v50;
LABEL_7:
      v5 = sub_100170A0(0x1Cu, (float *)v49);
      goto LABEL_8;
    case 7:
      if ( !sub_100170A0(0x7Du, &v51) )
        goto LABEL_10;
      v5 = sub_100170A0(0x35u, (float *)&v50);
LABEL_8:
      if ( v5 )
        v3 = 1;
      else
LABEL_10:
        v3 = 0;
      *(_BYTE *)v4 = 0;
      if ( !v3 )
        return v3;
      v6 = *(float *)&v50;
      v7 = v51;
      goto LABEL_13;
    case 0xC:
      if ( !sub_10018190(&v51) || !sub_10018510((float *)&v50) )
        goto LABEL_23;
      goto LABEL_112;
    default:
      goto LABEL_23;
    case 8:
      if ( !sub_100170A0(0x1Fu, &v51) || !sub_100170A0(0x38u, (float *)&v50) )
        goto LABEL_23;
      v3 = 1;
      *v4 = sub_10002900(v51, *(float *)&v50);
      return v3;
    case 9:
      return sub_10003110((char *)a2);
    case 0xA:
      return sub_10003250((char *)a2);
    case 0xB:
      return sub_10003040(a2);
    case 0xD:
      return sub_10018190(a2);
    case 0xE:
      return sub_10018050(a2);
    case 0xF:
      return sub_10018510(a2);
    case 0x22:
      return sub_100185E0(a2);
    case 2:
      return sub_10013210(a2);
    case 0x10:
      v3 = sub_10018B90(&v75);
      *(_BYTE *)v4 = (v76 & 1) == 1;
      return v3;
    case 0x11:
      v3 = sub_10018B90(&v75);
      *(_BYTE *)v4 = (v76 & 2) == 2;
      return v3;
    case 0x12:
      if ( !sub_100188B0(111, v52) )
        v52[0] = 0;
      if ( !sub_100188B0(119, &v54) )
        v54 = 0;
      v8 = sub_100188B0(120, &v55);
      if ( v8 )
        v8 = v55;
      v3 = 1;
      if ( !v52[0] || !v54 || !v8 )
        goto LABEL_46;
      goto LABEL_227;
    case 0x13:
      return sub_10017760(0, (bool *)a2);
    case 0x14:
      return sub_10017760(1, (bool *)a2);
    case 0x15:
      if ( *(_BYTE *)(dword_10254424 + 23) == 2 )
        v3 = sub_10032AE0(9139, (int)a2, 1) == 0;
      else
        v3 = sub_100177C0(0, (bool *)a2);
      return v3;
    case 0x16:
      if ( *(_BYTE *)(dword_10254424 + 23) == 2 )
        v3 = sub_10032AE0(9140, (int)a2, 1) == 0;
      else
        v3 = sub_100177C0(1, (bool *)a2);
      return v3;
    case 0x19:
      return sub_10013270(a2);
    case 0x1A:
      v3 = sub_10013490(&v51);
      if ( v3 )
      {
        v9 = sub_10032ED0();
        if ( v9 > dword_1010A8B8 )
        {
          dword_1010A8B8 = v9 + 1000;
          flt_101050B0 = flt_101050B0 * 0.8999999761581421 + v51 * 0.1000000014901161;
        }
        *v4 = flt_101050B0;
      }
      return v3;
    case 0x1B:
      return sub_10013370(a2);
    case 0x1C:
      return sub_10032AE0(9131, (int)a2, 1) == 0;
    case 0x1E:
      return sub_100136E0(a2);
    case 0x1F:
      v3 = 0;
      if ( sub_10032AE0(2103, (int)&v51, 4) )
        return v3;
      v10 = sub_10013210(&v50);
      goto LABEL_65;
    case 0x20:
      v3 = 0;
      sub_10013640(&v50);
      if ( !sub_100170A0(0xC5u, &v51) )
        return sub_10013670(v4);
      if ( *(float *)&v50 == 9.8999998e24 || v51 == 9.8999998e24 )
        return v3;
      *(float *)&v56 = v51 - *(float *)&v50;
      LODWORD(v56) &= 0x7FFFFFFFu;
      if ( *(float *)&v56 < 1.524 && sub_10013570((float *)&v50) )
        goto LABEL_66;
      if ( *(float *)&v56 >= 1.524 )
        return sub_10013670(v4);
      return v3;
    case 0x1D:
      return sub_10013670(v4);
    case 0x21:
      return sub_10018720((char *)a2);
    case 0x24:
      return sub_10017820(a2);
    case 0x25:
      v3 = 0;
      v51 = sub_10018580();
      if ( v51 != 9.8999998e24 )
      {
        *v4 = v51;
        v3 = 1;
      }
      return v3;
    case 0x26:
      if ( sub_100170A0(0x75u, &v51) && sub_10018680(v51, (int)&v50) )
      {
        v3 = 1;
        *v4 = *(float *)&v50;
      }
      return v3;
    case 0x27:
      if ( !sub_100170A0(0x75u, &v51) )
        return v3;
      v11 = sub_100133D0(&v50);
      goto LABEL_83;
    case 0x28:
      *(_BYTE *)a2 = sub_10013DD0(a1);
      return 1;
    case 0x29:
      *(_BYTE *)a2 = sub_1000B8E0((void *)a1);
      return 1;
    case 0x2A:
      *(_BYTE *)a2 = sub_1000B9F0((void *)a1);
      return 1;
    case 0x2B:
      return sub_10002EA0(a2, *(_BYTE *)(a1 + 4));
    case 0x33:
      return sub_100180C0(a2);
    case 0x34:
      return sub_100180E0(a2);
    case 0x35:
      return sub_10017220(a1, 0x4Eu, a2);
    case 0x36:
      return sub_10017220(a1, 0x4Fu, a2);
    case 0x37:
    case 0x38:
      if ( sub_10012200(6, 155, 0, 4, &v51) && sub_10012200(6, 156, 0, 4, &v50) )
      {
        v3 = 1;
        v51 = sub_10016FC0(v51, flt_100F4E50, 40, 0.0017453292);
        *(float *)&v50 = sub_10016FC0(*(float *)&v50, flt_100F4E44, 40, 0.0017453292);
        v12 = v51;
        v13 = *(_WORD *)(v2 + 2) == 55;
        flt_100F4E50 = v51;
        v14 = *(float *)&v50;
        flt_100F4E44 = *(float *)&v50;
        if ( v13 )
        {
          *(float *)&v56 = (v12 + v14) * 0.5;
          *v4 = sub_10035C90(*(float *)&v56, 0.0017453292);
        }
        else
        {
          *(float *)&v56 = v14 - v12;
          LODWORD(v56) &= 0x7FFFFFFFu;
          *v4 = sub_10035C90(*(float *)&v56, 0.0017453292);
        }
      }
      return v3;
    case 0x39:
      if ( sub_10012200(6, 151, 0, 4, &v51) && sub_10012200(6, 174, 0, 4, &v50) )
      {
        v3 = 1;
        v53 = *(float *)&v50 - v51;
        *(_DWORD *)v4 = LODWORD(v53) & 0x7FFFFFFF;
      }
      return v3;
    case 0x3A:
      v52[0] = sub_100170A0(0x6Du, &v51);
      v15 = sub_100170A0(0x6Eu, (float *)&v50);
      if ( v52[0] == 1 )
      {
        v3 = 1;
        if ( v15 == 1 )
          *v4 = *(float *)&v50 + v51;
        else
          *v4 = v51;
      }
      else if ( v15 == 1 )
      {
        v3 = 1;
        *v4 = *(float *)&v50;
      }
      return v3;
    case 0x3B:
      if ( sub_100170A0(0x6Du, &v51) && sub_100170A0(0x6Eu, (float *)&v50) )
      {
        v3 = 1;
        v51 = sub_10002900(v51, 0.0);
        *(float *)&v50 = sub_10002900(*(float *)&v50, 0.0);
        v53 = *(float *)&v50 - v51;
        *(_DWORD *)v4 = LODWORD(v53) & 0x7FFFFFFF;
      }
      return v3;
    case 0x3C:
      if ( sub_100170A0(0x6Du, &v51) && sub_100170A0(0x6Eu, (float *)&v50) )
      {
LABEL_112:
        v3 = 1;
        *v4 = v51 - *(float *)&v50;
      }
      return v3;
    case 0x3D:
      if ( sub_100170A0(0x6Du, &v51) )
      {
        v10 = sub_100170A0(0x6Eu, (float *)&v50);
LABEL_65:
        if ( v10 )
        {
LABEL_66:
          v3 = 1;
          *v4 = *(float *)&v50 - v51;
        }
      }
      return v3;
    case 0x3E:
      return sub_10032AE0(9172, (int)a2, 1) == 0;
    case 0x3F:
      return sub_10013430(a2);
    case 0x40:
      return sub_10002D30(a2);
    case 0x41:
      return sub_10002DA0(a2);
    case 0x42:
      if ( byte_100F4E57 == 1 && sub_10013210(&v51) )
      {
        v3 = 1;
        v16 = (sub_10032ED0() - dword_101050B4) / 0x3E8u;
        *(_BYTE *)v4 = v16 >= sub_10002F00(v51);
      }
      return v3;
    case 0x43:
      if ( byte_100F4E57 == 1 )
      {
        v3 = 1;
        *(_DWORD *)a2 = (sub_10032ED0() - dword_101050B4) / 0x3E8u;
      }
      return v3;
    case 0x44:
      v52[0] = sub_100170A0(0x176u, &v51);
      v11 = sub_100170A0(0x173u, (float *)&v50);
      if ( v52[0] )
        goto LABEL_83;
      return v3;
    case 0x45:
      v52[0] = sub_100170A0(0xABu, &v51);
      v17 = sub_100170A0(0xAEu, (float *)&v50);
      if ( v52[0] && v17 )
      {
        v3 = 1;
        v53 = *(float *)&v50 - v51;
        *(_DWORD *)v4 = LODWORD(v53) & 0x7FFFFFFF;
      }
      return v3;
    case 0x46:
      v52[0] = sub_100170A0(0x169u, &v51);
      v18 = sub_100170A0(0x16Au, (float *)&v50);
      if ( v52[0] && v18 )
      {
        v3 = 1;
        v53 = *(float *)&v50 - v51;
        *(_DWORD *)v4 = LODWORD(v53) & 0x7FFFFFFF;
      }
      return v3;
    case 0x47:
      v52[0] = sub_100170A0(0x19u, &v51);
      v19 = sub_100170A0(0x32u, (float *)&v50);
      if ( v52[0] && v19 )
      {
        v3 = 1;
        v53 = *(float *)&v50 - v51;
        *(_DWORD *)v4 = LODWORD(v53) & 0x7FFFFFFF;
      }
      return v3;
    case 0x48:
      v52[0] = sub_100170A0(0x1Au, &v51);
      v20 = sub_100170A0(0x33u, (float *)&v50);
      if ( v52[0] && v20 )
      {
        v3 = 1;
        v53 = *(float *)&v50 - v51;
        *(_DWORD *)v4 = LODWORD(v53) & 0x7FFFFFFF;
      }
      return v3;
    case 0x49:
      v52[0] = sub_100170A0(0x16Eu, &v51);
      v21 = sub_100170A0(0x16Fu, (float *)&v50);
      if ( v52[0] && v21 )
      {
        v3 = 1;
        v53 = *(float *)&v50 - v51;
        *(_DWORD *)v4 = LODWORD(v53) & 0x7FFFFFFF;
      }
      return v3;
    case 0x4A:
      return sub_10032AE0(9214, (int)a2, 1) == 0;
    case 0x4B:
      if ( !sub_100170A0(0x174u, &v51) || sub_10032AE0(9220, (int)&v61, 16) )
        return v3;
      v22 = v64 < (double)v51;
      if ( v63 <= (double)v51 )
        goto LABEL_146;
      v23 = 1;
      goto LABEL_147;
    case 0x4C:
      if ( sub_100170A0(0x175u, &v51) && !sub_10032AE0(9220, (int)&v61, 16) )
      {
        v22 = v62 < (double)v51;
        if ( v61 <= (double)v51 )
LABEL_146:
          v23 = 0;
        else
          v23 = 1;
LABEL_147:
        if ( v22 || v23 )
        {
          *(_BYTE *)v4 = 0;
          v3 = 1;
        }
        else
        {
          *(_BYTE *)v4 = 1;
          v3 = 1;
        }
      }
      return v3;
    case 0x4D:
      return sub_10014890(a2);
    case 0x4E:
      if ( !sub_100170A0(0x16u, &v51) || !sub_100170A0(0x11Fu, (float *)&v50) )
        return v3;
      *(float *)&v50 = sub_10002A80(*(float *)&v50);
      v6 = v51;
      v3 = 1;
      v7 = *(float *)&v50;
      *(_BYTE *)v4 = 0;
      goto LABEL_13;
    case 0x4F:
      if ( !sub_100170A0(0x2Fu, &v51) || !sub_100170A0(0x120u, (float *)&v50) )
        return v3;
      *(float *)&v50 = sub_10002A80(*(float *)&v50);
      v6 = v51;
      v3 = 1;
      v7 = *(float *)&v50;
      *(_BYTE *)v4 = 0;
      goto LABEL_13;
    case 0x50:
      if ( !sub_100170A0(0x3Cu, &v51) )
        return v3;
      v24 = sub_100170A0(0x41u, (float *)&v50);
      goto LABEL_164;
    case 0x51:
      if ( !sub_100170A0(0x1Du, &v51) || !sub_10012200(1, 1828, 0, 4, &v50) )
        return v3;
      v6 = v51;
      v3 = 1;
      v7 = *(float *)&v50;
      *(_BYTE *)v4 = 0;
      goto LABEL_13;
    case 0x52:
      if ( !sub_100170A0(0x36u, &v51) || !sub_10012200(1, 1829, 0, 4, &v50) )
        return v3;
      v6 = v51;
      v3 = 1;
      v7 = *(float *)&v50;
      *(_BYTE *)v4 = 0;
      goto LABEL_13;
    case 0x53:
      if ( !sub_100170A0(0x1Du, &v51) )
        return v3;
      v25 = sub_100170A0(0x80u, (float *)&v50);
      goto LABEL_174;
    case 0x54:
      if ( !sub_100170A0(0x36u, &v51) )
        return v3;
      v25 = sub_100170A0(0x81u, (float *)&v50);
      goto LABEL_174;
    case 0x55:
      if ( !sub_100170A0(0x186u, &v51) )
        return v3;
      v25 = sub_100170A0(0x188u, (float *)&v50);
      goto LABEL_174;
    case 0x56:
      if ( !sub_100170A0(0x187u, &v51) )
        return v3;
      v25 = sub_100170A0(0x189u, (float *)&v50);
      goto LABEL_174;
    case 0x57:
      if ( !sub_100170A0(0x180u, &v51) )
        return v3;
      v25 = sub_100170A0(0x182u, (float *)&v50);
      goto LABEL_174;
    case 0x58:
      if ( !sub_100170A0(0x181u, &v51) )
        return v3;
      v25 = sub_100170A0(0x183u, (float *)&v50);
      goto LABEL_174;
    case 0x59:
      if ( !sub_10016F60(0x127u, &v51) || !sub_10012200(1, 1971, 0, 4, &v50) )
        return v3;
      v6 = v51;
      v3 = 1;
      v7 = *(float *)&v50;
      *(_BYTE *)v4 = 0;
      goto LABEL_13;
    case 0x5A:
      if ( !sub_10016F60(0x128u, &v51) || !sub_10012200(1, 1972, 0, 4, &v50) )
        return v3;
      v6 = v51;
      v3 = 1;
      v7 = *(float *)&v50;
      *(_BYTE *)v4 = 0;
      goto LABEL_13;
    case 0x5C:
      if ( !sub_100170A0(0x121u, &v51) )
        return v3;
      v25 = sub_10012200(1, 1973, 0, 4, &v50);
      goto LABEL_174;
    case 0x5D:
      if ( !sub_100170A0(0x122u, &v51) )
        return v3;
      v25 = sub_10012200(1, 1974, 0, 4, &v50);
      goto LABEL_174;
    case 0x5E:
      v28 = sub_10012200(1, 996, 0, 4, &v57);
      goto LABEL_198;
    case 0x5F:
      v28 = sub_10012200(1, 1004, 0, 4, &v57);
LABEL_198:
      if ( v28 )
      {
        v29 = v57;
        v13 = (v57 & 0x40000) == 0;
        *(_BYTE *)v4 = 0;
        v3 = 1;
        if ( !v13 )
          *(_BYTE *)v4 = 1;
        if ( v29 & 0x80000 )
          ++*(_BYTE *)v4;
        if ( v29 & 0x100000 )
          ++*(_BYTE *)v4;
        if ( v29 & 0x200000 )
          ++*(_BYTE *)v4;
        if ( v29 & 0x400000 )
          ++*(_BYTE *)v4;
      }
      return v3;
    case 0x60:
      sub_10014AD0();
      if ( sub_10002DA0(&v51) )
      {
        v52[0] = sub_10013210(&v50);
        v56 = v51;
        v30 = *(float *)(dword_10254424 + 23308);
        sub_100148F0(*(float *)(dword_10254424 + 23308), *(float *)&v50, v52[0]);
        *(_BYTE *)v4 = v30 + *(float *)(dword_10254424 + 23316) <= v56;
        v3 = 1;
      }
      if ( sub_10002D30(&v51) )
      {
        v52[0] = 0;
        if ( sub_10014CB0(512, &v77) )
        {
          v13 = *(_BYTE *)v4 == 0;
          v52[0] = 1;
          if ( v13
            && (v74 = v51,
                *(float *)&v56 = v78 * 1.943844437599182,
                v31 = *(float *)&v56,
                sub_10014A30(*(float *)&v56),
                v31 * 0.5144444704055786 + *(float *)(dword_10254424 + 23320) > v74) )
          {
            *(_BYTE *)v4 = 0;
            v3 = 1;
          }
          else
          {
            *(_BYTE *)v4 = 1;
            v3 = 1;
          }
        }
      }
      return v3;
    case 0x61:
      return sub_10032AE0(9361, (int)a2, 1) == 0;
    case 0x66:
      return sub_10002CC0(a2);
    case 0x62:
      v3 = 0;
      if ( sub_10012930(7, &v51) )
      {
        v3 = 1;
        *v4 = sub_1000B8C0() + v51;
      }
      return v3;
    case 0x63:
      v3 = 0;
      if ( sub_10012950(7, &v50) )
      {
        v3 = 1;
        *v4 = sub_1000B8C0() + *(float *)&v50;
      }
      return v3;
    case 0x64:
      v3 = 0;
      if ( sub_10012200(2, 200, 0, 1228, &v79) )
      {
        v3 = 1;
        if ( v80 && v81 == 1 )
LABEL_227:
          *(_BYTE *)v4 = 1;
        else
LABEL_46:
          *(_BYTE *)v4 = 0;
      }
      return v3;
    case 0x65:
      v3 = 0;
      if ( sub_10012200(0, 260, 0, 8, &v72) )
      {
        v3 = 1;
        *(_BYTE *)v4 = v73 == 4 || v73 == 5 || v73 == 6;
      }
      return v3;
    case 0x67:
      if ( !sub_100170A0(0x1Du, &v51) || !sub_10012200(1, 2576, 0, 4, &v50) )
        return v3;
      v6 = v51;
      v3 = 1;
      v7 = *(float *)&v50;
      *(_BYTE *)v4 = 0;
      goto LABEL_13;
    case 0x68:
      if ( sub_100170A0(0x36u, &v51) && sub_10012200(1, 2577, 0, 4, &v50) )
      {
        v6 = v51;
        v3 = 1;
        v7 = *(float *)&v50;
        *(_BYTE *)v4 = 0;
LABEL_13:
        if ( v7 > v6 )
          goto LABEL_14;
      }
      return v3;
    case 0x69:
      if ( !sub_100170A0(0x1Cu, &v51) )
        return v3;
      v25 = sub_100170A0(0x78u, (float *)&v50);
      goto LABEL_174;
    case 0x6A:
      if ( sub_100170A0(0x35u, &v51) )
      {
        v25 = sub_100170A0(0x79u, (float *)&v50);
LABEL_174:
        if ( v25 )
        {
          v26 = v51;
          v3 = 1;
          v27 = *(float *)&v50;
          *(_BYTE *)v4 = 0;
          if ( v27 < v26 )
            *(_BYTE *)v4 = 1;
        }
      }
      return v3;
    case 0x6B:
      v32 = sub_10018720((char *)&v59);
      v3 = sub_10014560(0, (int)&v65) & v32;
      sub_10014370((int)&v71, v65, v66);
      if ( v3 )
      {
        v33 = v59 % 0x15180;
        v34 = v59;
        *(_BYTE *)v4 = 0;
        sub_1000A1B0((int)&v71, v34, &v58, &v60);
        v35 = v58 + 1800;
        if ( (unsigned int)(v58 + 1800) > 0x15180 )
          v35 = v58 - 84600;
        v36 = v60 - 1800;
        if ( v60 - 1800 < 0 )
          v36 += 86400;
        if ( v35 >= v36 )
        {
          if ( v33 > v36 && v33 < v35 )
            *(_BYTE *)v4 = 1;
        }
        else if ( v33 < v35 )
        {
LABEL_14:
          *(_BYTE *)v4 = 1;
        }
        else if ( v33 > v36 )
        {
          *(_BYTE *)v4 = 1;
        }
      }
      return v3;
    case 0x6C:
      if ( !sub_10012930(7, &v51) )
        goto LABEL_23;
      v37 = sub_10012950(7, &v50);
      goto LABEL_258;
    case 0x6D:
      if ( !sub_10012930(2, &v51) )
        goto LABEL_23;
      v37 = sub_10012950(2, &v50);
LABEL_258:
      if ( !v37 )
        goto LABEL_23;
      v3 = 1;
      *v4 = v51 - *(float *)&v50;
      return v3;
    case 0x6E:
      v38 = sub_100142C0(*(_BYTE *)(a1 + 4));
      if ( !v38 || v38 == 1 || v38 == 2 )
      {
        v3 = 1;
        *(_BYTE *)v4 = v38;
      }
      return v3;
    case 0x6F:
      v67 = 0;
      v68 = 0;
      v69 = 0;
      v70 = 0;
      *(_BYTE *)a2 = sub_10014220(&v67);
      return 1;
    case 0x70:
      if ( sub_10032AE0(9002, (int)&v51, 4) )
        return v3;
      v39 = sub_10013C70(35, &v50);
      goto LABEL_269;
    case 0x71:
      if ( !sub_10032AE0(9001, (int)&v51, 4) )
      {
        if ( sub_10013C70(33, &v50) )
          goto LABEL_317;
        v39 = sub_10013C70(31, &v50);
LABEL_269:
        if ( v39 )
        {
LABEL_317:
          v3 = 1;
          *v4 = *(float *)&v50 - v51;
        }
      }
      return v3;
    case 0x72:
      v40 = sub_10013C70(4037, &v51);
      v48 = &v50;
      v47 = 4038;
      goto LABEL_275;
    case 0x73:
      v40 = sub_10013C70(4039, &v51);
      v48 = &v50;
      v47 = 4040;
      goto LABEL_275;
    case 0x74:
      v52[0] = sub_10013C70(4041, &v51);
      v11 = sub_10013C70(4042, &v50);
      goto LABEL_276;
    case 0x75:
      v40 = sub_10013C70(4043, &v51);
      v48 = &v50;
      v47 = 4044;
      goto LABEL_275;
    case 0x76:
      v40 = sub_10013C70(4045, &v51);
      v48 = &v50;
      v47 = 4046;
      goto LABEL_275;
    case 0x77:
      v52[0] = sub_10013C70(4047, &v51);
      v11 = sub_10013C70(4048, &v50);
      goto LABEL_276;
    case 0x78:
      v40 = sub_10013C70(4049, &v51);
      v48 = &v50;
      v47 = 4050;
      goto LABEL_275;
    case 0x79:
      v40 = sub_10013C70(4051, &v51);
      v48 = &v50;
      v47 = 4052;
      goto LABEL_275;
    case 0x7A:
      v52[0] = sub_10013C70(4053, &v51);
      v11 = sub_10013C70(4054, &v50);
      goto LABEL_276;
    case 0x7B:
      v40 = sub_10013C70(4055, &v51);
      v48 = &v50;
      v47 = 4056;
LABEL_275:
      v52[0] = v40;
      v11 = sub_10013C70(v47, v48);
LABEL_276:
      if ( v52[0] )
      {
LABEL_83:
        if ( v11 )
        {
          v3 = 1;
          *v4 = v51 - *(float *)&v50;
        }
      }
      return v3;
    case 0x7C:
      return sub_100033D0(a2);
    case 0x7E:
      if ( sub_10032AE0(9003, (int)&v51, 4) )
        return v3;
      v41 = sub_10013C70(11, &v50);
      goto LABEL_290;
    case 0x7F:
      if ( sub_10032AE0(9003, (int)&v51, 4) )
        return v3;
      v41 = sub_10013C70(12, &v50);
      goto LABEL_290;
    case 0x80:
      if ( sub_10032AE0(9003, (int)&v51, 4) )
        return v3;
      v41 = sub_10013C70(13, &v50);
      goto LABEL_290;
    case 0x81:
      if ( !sub_10032AE0(9003, (int)&v51, 4) )
      {
        v41 = sub_10013C70(14, &v50);
LABEL_290:
        if ( v41 )
        {
          v3 = 1;
          *(float *)&v50 = *(float *)&v50 * 1.799999952316284 + 32.0;
          *v4 = *(float *)&v50 - v51;
        }
      }
      return v3;
    case 0x7D:
      v52[0] = sub_10013C00(&v51);
      v42 = sub_10032AE0(9145, (int)&v50, 4);
      *v4 = 0.0;
      v24 = v42 == 0;
      if ( v52[0] )
      {
LABEL_164:
        if ( v24 )
        {
          v3 = 1;
          *v4 = v51 - *(float *)&v50;
        }
      }
      return v3;
    case 0x82:
      v52[0] = sub_10013C70(1, &v51);
      v43 = sub_10032AE0(41110, (int)&v50, 4) == 0;
      if ( !v52[0] || !v43 )
        return v3;
      v3 = 1;
      v51 = v51 * 100.0;
      if ( *(float *)&v50 >= (double)v51 )
        goto LABEL_304;
      *(_BYTE *)v4 = 1;
      break;
    case 0x83:
      v51 = 0.0;
      sub_10002DA0(&v51);
      v44 = v51;
      if ( v51 >= 0.2300000041723251 )
      {
        if ( v44 >= 0.34 )
          v45 = -2.5999999;
        else
          v45 = 5.300000190734863 - v44 * 23.0;
      }
      else
      {
        v45 = 0.0;
      }
      *(float *)&v50 = v45;
      if ( sub_10012200(6, 738, 0, 4, &v53) || sub_10012200(6, 739, 0, 4, &v53) )
      {
        v3 = 1;
        if ( *(float *)&v50 + 14.5 >= v53 )
LABEL_304:
          *(_BYTE *)v4 = 0;
        else
          *(_BYTE *)v4 = 1;
      }
      else
      {
LABEL_23:
        v3 = 0;
      }
      break;
  }
  return v3;
}
// 1000B8C0: using guessed type double sub_1000B8C0(void);
// 100F4E44: using guessed type float flt_100F4E44;
// 100F4E50: using guessed type float flt_100F4E50;
// 100F4E57: using guessed type char byte_100F4E57;
// 101050B0: using guessed type float flt_101050B0;
// 101050B4: using guessed type int dword_101050B4;
// 1010A8B8: using guessed type int dword_1010A8B8;
// 10254424: using guessed type int dword_10254424;

//----- (10005040) --------------------------------------------------------
__int16 __cdecl sub_10005040(int a1, char a2, int a3, int a4, int a5, char a6)
{
  int v6; // esi@1
  size_t v7; // edi@1
  void *v8; // ecx@1
  _BYTE *v9; // ebp@1
  int v10; // eax@1
  char v11; // bl@1
  int v12; // esi@11
  int v13; // esi@18
  signed int v14; // eax@24
  char v15; // al@39
  int v16; // eax@43
  bool v17; // zf@46
  unsigned int v18; // eax@49
  char *v19; // ecx@64
  double v20; // st7@65
  double v21; // st6@67
  double v22; // rt1@69
  double v23; // st6@69
  double v24; // st7@69
  float v25; // ST24_4@69
  double v26; // st6@69
  double v27; // rt2@71
  double v28; // st6@71
  double v29; // st7@71
  float v30; // ST24_4@71
  float v31; // ST24_4@73
  unsigned int v32; // edx@73
  double v33; // st7@74
  float v34; // ST2C_4@76
  double v35; // st7@76
  float v36; // ST2C_4@78
  double v37; // st7@78
  float v38; // ST2C_4@80
  double v39; // st7@80
  float v40; // ST2C_4@82
  double v41; // st7@82
  float v42; // ST2C_4@84
  double v43; // st7@84
  int v44; // eax@86
  float v45; // ST2C_4@86
  float v46; // ST24_4@87
  double v47; // st7@87
  unsigned __int8 v48; // al@91
  char *v49; // ecx@97
  double v50; // st7@98
  double v51; // st6@100
  double v52; // rt0@102
  double v53; // st6@102
  double v54; // st7@102
  float v55; // ST24_4@102
  double v56; // st6@102
  double v57; // rt1@104
  double v58; // st6@104
  double v59; // st7@104
  float v60; // ST24_4@104
  float v61; // ST24_4@106
  int v62; // eax@107
  char v63; // bl@113
  int v64; // esi@115
  int v65; // eax@133
  signed int v66; // edx@133
  char v67; // ST0C_1@133
  int v68; // eax@136
  char v69; // ST0C_1@136
  int v70; // eax@138
  char v71; // al@143
  unsigned int v72; // edi@144
  unsigned int v73; // eax@159
  unsigned int v74; // ebp@161
  char v75; // al@166
  float v77; // [sp+20h] [bp-5Ch]@64
  float v78; // [sp+20h] [bp-5Ch]@67
  float v79; // [sp+20h] [bp-5Ch]@69
  float v80; // [sp+20h] [bp-5Ch]@71
  float v81; // [sp+20h] [bp-5Ch]@74
  float v82; // [sp+20h] [bp-5Ch]@78
  float v83; // [sp+20h] [bp-5Ch]@82
  float v84; // [sp+20h] [bp-5Ch]@97
  float v85; // [sp+20h] [bp-5Ch]@100
  float v86; // [sp+20h] [bp-5Ch]@102
  float v87; // [sp+20h] [bp-5Ch]@104
  char v88; // [sp+27h] [bp-55h]@42
  float v89; // [sp+28h] [bp-54h]@76
  float v90; // [sp+28h] [bp-54h]@80
  float v91; // [sp+28h] [bp-54h]@84
  __int16 v92; // [sp+28h] [bp-54h]@112
  int v93; // [sp+2Ch] [bp-50h]@1
  int v94; // [sp+30h] [bp-4Ch]@1
  char v95; // [sp+35h] [bp-47h]@1
  char v96; // [sp+36h] [bp-46h]@1
  char v97; // [sp+37h] [bp-45h]@1
  unsigned int v98; // [sp+38h] [bp-44h]@1
  _BYTE v99[60]; // [sp+3Ch] [bp-40h]@24

  HIWORD(v6) = HIWORD(a4);
  HIWORD(v7) = HIWORD(a5);
  v94 = a3;
  v95 = 0;
  v96 = 1;
  v98 = sub_10032ED0();
  v9 = (_BYTE *)(((unsigned __int16)a1 << 6) + a4);
  v10 = *v9 - 1;
  v11 = 0;
  v97 = 0;
  *(float *)&v93 = 0.0;
  switch ( v10 )
  {
    case 0:
      v11 = sub_100188B0(*(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2), &v93);
      break;
    case 1:
      v11 = sub_100170A0(*(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2), (float *)&v93);
      break;
    case 5:
      if ( !sub_1000B7F0(a5, *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2), a6, (bool *)&v96, &v95) || v96 )
      {
        LOBYTE(v93) = 2;
        goto LABEL_8;
      }
      LOBYTE(v93) = v95;
      v11 = 1;
      break;
    case 6:
      LOBYTE(v93) = sub_1000BFD0(*(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2));
      v11 = 1;
      break;
    case 10:
      v11 = sub_10012200(
              6,
              *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2),
              *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4),
              word_10057340[*(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1)],
              &v93);
      break;
    case 2:
      v11 = sub_10012200(
              0,
              *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2),
              *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4),
              word_10057340[*(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1)],
              &v93);
      break;
    case 3:
      v11 = sub_10012200(
              1,
              *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2),
              *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4),
              word_10057340[*(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1)],
              &v93);
      break;
    case 4:
      v11 = sub_10012200(
              2,
              *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2),
              *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4),
              word_10057340[*(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1)],
              &v93);
      break;
    case 11:
      LOWORD(v7) = word_10057340[*(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1)];
      LOWORD(v6) = *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4);
      v11 = sub_10002E50(v7, v6, *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2), &v93);
      break;
    case 9:
      v13 = sub_1000BC00(v8);
      if ( *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4) != 8 )
        goto LABEL_24;
      if ( sub_1000B980(*(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 2)) & v13
        && v13 & *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 12)
        && v13 & *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 20) )
      {
        if ( *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4) == 8 )
          v97 = 1;
LABEL_24:
        v14 = sub_1000B980(*(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 2));
        if ( !j_HWM_pvg_hsdb_get_router_entry(v14, v99) )
        {
          v11 = 1;
          if ( *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1) )
            v93 = *(int *)&v99[*(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4)];
          else
            LOBYTE(v93) = v99[*(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4)];
        }
      }
      break;
    case 7:
      v11 = sub_100034E0(((unsigned __int16)a1 << 6) + a4, (float *)&v93);
      break;
    case 12:
      v11 = sub_10003020(((unsigned __int16)a1 << 6) + a4, (char *)&v93);
      break;
    case 8:
      LOBYTE(v93) = sub_1000C010(
                      *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2),
                      *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4));
      v11 = 1;
      break;
    case 13:
      v11 = sub_10013C70(*(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2), &v93);
      break;
    case 14:
      v11 = sub_100194C0(*(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2), &v93);
      break;
    case 15:
      if ( a6 )
      {
        if ( a6 == 1 )
        {
          v93 = *(int *)(16 * *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2) + dword_10254438 - 15988);
          v11 = 1;
        }
      }
      else
      {
        v93 = *(int *)(16 * *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2) + dword_10254438 + 12);
        v11 = 1;
      }
      break;
    case 16:
      sub_10002E10(*(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2), (bool *)v94);
      LOBYTE(v93) = *(_BYTE *)v94;
      v11 = 1;
      break;
    default:
LABEL_8:
      v11 = 0;
      break;
  }
  if ( !(*(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 8) & 0x10) || a2 )
  {
    v12 = v94;
  }
  else
  {
    v12 = v94;
    *(_BYTE *)v94 = 0;
  }
  v15 = *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1);
  if ( v15 != 2 )
  {
    if ( v15 == 3 )
    {
      if ( !v11 )
        goto LABEL_42;
      v18 = sub_10018EC0(&v93, -32768, 0x7FFF, 0, 0);
    }
    else if ( v15 == 4 )
    {
      if ( !v11 )
        goto LABEL_42;
      v18 = sub_10018F60(&v93, 2147483648, 0x7FFFFFFF, 0, 0);
    }
    else if ( v15 )
    {
      if ( v15 != 1 )
        sub_10011520("..\\lib\\adl\\mon_alrt_trgr.c", 684, 0, 0);
      if ( !v11 )
        goto LABEL_42;
      v18 = sub_10019170(&v93, 0, 0xFFFFFFFF, 0, 0);
    }
    else
    {
      if ( !v11 )
        goto LABEL_42;
      v18 = sub_10019080((unsigned __int8 *)&v93, 0, 0xFFu, 0, 0);
    }
    if ( !v18 )
      goto LABEL_61;
LABEL_42:
    v88 = 0;
    goto LABEL_43;
  }
  if ( !v11 || sub_10018D80((int)&v93, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0) )
    goto LABEL_42;
LABEL_61:
  v88 = 1;
  if ( *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 8) & 8 )
  {
    if ( *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1) != 2 )
      sub_10011520("..\\lib\\adl\\mon_alrt_trgr.c", 709, 0, 0);
    v19 = (char *)&unk_100F4E60 + 44 * (unsigned __int16)a1;
    v77 = *((float *)v19 + 2);
    if ( *(float *)&v93 >= (double)v77 )
    {
      v20 = *(float *)&v93;
      v77 = *(float *)&v93;
    }
    else
    {
      v20 = *(float *)&v93;
    }
    v21 = v77;
    *((float *)v19 + 2) = v77;
    v78 = *((float *)v19 + 6);
    if ( v78 < v20 )
      v20 = v78;
    v22 = v21;
    v23 = v20;
    v24 = v22;
    v25 = v23;
    v26 = v25;
    *((float *)v19 + 6) = v25;
    v79 = *(float *)v19;
    if ( v79 > v22 )
      v24 = v79;
    v27 = v26;
    v28 = v24;
    v29 = v27;
    v30 = v28;
    *(float *)v19 = v30;
    v80 = *((float *)v19 + 1);
    if ( v80 < v27 )
      v29 = v80;
    v31 = v29;
    *((float *)v19 + 1) = v31;
    v32 = v98;
    if ( *((_DWORD *)v19 + 10) + *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 28) / 3u < v98 )
    {
      *(_DWORD *)v19 = *((_DWORD *)v19 + 2);
      *((_DWORD *)v19 + 1) = *((_DWORD *)v19 + 6);
      *((_DWORD *)v19 + 5) = *((_DWORD *)v19 + 4);
      v81 = *((float *)v19 + 5);
      v33 = *(float *)v19;
      if ( v81 >= v33 )
        v33 = v81;
      v34 = v33;
      *(float *)v19 = v34;
      *((_DWORD *)v19 + 9) = *((_DWORD *)v19 + 8);
      v89 = *((float *)v19 + 9);
      v35 = *((float *)v19 + 1);
      if ( v89 <= v35 )
        v35 = v89;
      v36 = v35;
      *((float *)v19 + 1) = v36;
      *((_DWORD *)v19 + 4) = *((_DWORD *)v19 + 3);
      v82 = *((float *)v19 + 4);
      v37 = *(float *)v19;
      if ( v82 >= v37 )
        v37 = v82;
      v38 = v37;
      *(float *)v19 = v38;
      *((_DWORD *)v19 + 8) = *((_DWORD *)v19 + 7);
      v90 = *((float *)v19 + 8);
      v39 = *((float *)v19 + 1);
      if ( v90 <= v39 )
        v39 = v90;
      v40 = v39;
      *((float *)v19 + 1) = v40;
      *((_DWORD *)v19 + 3) = *((_DWORD *)v19 + 2);
      v83 = *((float *)v19 + 3);
      v41 = *(float *)v19;
      if ( v83 >= v41 )
        v41 = v83;
      v42 = v41;
      *(float *)v19 = v42;
      *((_DWORD *)v19 + 7) = *((_DWORD *)v19 + 6);
      v91 = *((float *)v19 + 7);
      v43 = *((float *)v19 + 1);
      if ( v91 <= v43 )
        v43 = v91;
      v44 = v93;
      v45 = v43;
      *((float *)v19 + 2) = *(float *)&v93;
      *((float *)v19 + 1) = v45;
      *((_DWORD *)v19 + 6) = v44;
      *((_DWORD *)v19 + 10) = v32;
    }
    v46 = *(float *)v19 - *((float *)v19 + 1);
    v47 = COERCE_FLOAT(LODWORD(v46) & 0x7FFFFFFF);
LABEL_111:
    *(float *)(v12 + 12) = v47;
    goto LABEL_112;
  }
LABEL_43:
  v16 = *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 8);
  if ( v16 & 0x60 )
  {
    if ( !v88 )
      goto LABEL_112;
    if ( *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1) != 2 )
      sub_10011520("..\\lib\\adl\\mon_alrt_trgr.c", 746, 0, 0);
    v49 = (char *)&unk_100F4E60 + 44 * (unsigned __int16)a1;
    v84 = *((float *)v49 + 2);
    if ( *(float *)&v93 >= (double)v84 )
    {
      v50 = *(float *)&v93;
      v84 = *(float *)&v93;
    }
    else
    {
      v50 = *(float *)&v93;
    }
    v51 = v84;
    *((float *)v49 + 2) = v84;
    v85 = *((float *)v49 + 6);
    if ( v85 < v50 )
      v50 = v85;
    v52 = v51;
    v53 = v50;
    v54 = v52;
    v55 = v53;
    v56 = v55;
    *((float *)v49 + 6) = v55;
    v86 = *(float *)v49;
    if ( v86 > v52 )
      v54 = v86;
    v57 = v56;
    v58 = v54;
    v59 = v57;
    v60 = v58;
    *(float *)v49 = v60;
    v87 = *((float *)v49 + 1);
    if ( v87 < v57 )
      v59 = v87;
    v61 = v59;
    *((float *)v49 + 1) = v61;
    if ( !a2 )
    {
      v62 = v93;
      *((float *)v49 + 2) = *(float *)&v93;
      *(_DWORD *)v49 = v62;
      *((_DWORD *)v49 + 6) = v62;
      *((_DWORD *)v49 + 1) = v62;
    }
    if ( *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 8) & 0x40 )
      v47 = *(float *)v49;
    else
      v47 = *((float *)v49 + 1);
    goto LABEL_111;
  }
  if ( v88 )
  {
    if ( a2 )
      v17 = (*(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 8) & 0x400) == 0;
    else
      v17 = (v16 & 4) == 0;
    if ( v17 )
      *(float *)(v12 + 12) = *(float *)&v93;
  }
  else
  {
    v48 = *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1);
    if ( v48 >= 5u )
    {
      *(_DWORD *)(v12 + 12) = -1;
      sub_10011520("..\\lib\\adl\\mon_alrt_trgr.c", 802, 0, 0);
    }
    else
    {
      *(_DWORD *)(v12 + 12) = dword_1005734C[v48];
    }
  }
LABEL_112:
  HIBYTE(v92) = 4;
  if ( v88 )
  {
    if ( *(_BYTE *)v12 )
    {
      if ( *(_BYTE *)v12 == 1 )
      {
        if ( a2 && *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 8) & 0x800 )
          v63 = 0;
        else
          v63 = sub_10002AC0(
                  *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1),
                  1,
                  *(_DWORD *)(v94 + 12),
                  *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 20),
                  *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 24)) == 0;
      }
      else
      {
        v63 = sub_10002AC0(
                *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1),
                0,
                *(_DWORD *)(v94 + 12),
                *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 12),
                *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 16));
        if ( v63 && *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 8) & 0x800 && 0.0 != *(float *)(v94 + 16) )
          v63 = sub_10002AC0(
                  *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1),
                  0,
                  *(_DWORD *)(v94 + 12),
                  *(_DWORD *)(v94 + 16),
                  *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 16));
      }
    }
    else
    {
      v64 = v94;
      v63 = sub_10002AC0(
              *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1),
              0,
              *(_DWORD *)(v94 + 12),
              *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 12),
              *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 16));
      if ( v63 && *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 8) & 0x800 && 0.0 != *(float *)(v64 + 16) )
      {
        v63 = sub_10002AC0(
                *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1),
                0,
                *(_DWORD *)(v64 + 12),
                *(_DWORD *)(v64 + 16),
                *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 16));
        goto LABEL_129;
      }
    }
  }
  else
  {
    v63 = 2;
  }
  v64 = v94;
LABEL_129:
  if ( v97 && v63 != 1 )
  {
    if ( *(_BYTE *)v64 == 1 )
      goto LABEL_174;
    if ( !j_HWM_pvg_hsdb_get_router_entry(*(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 12), v99) )
    {
      *(_DWORD *)(v64 + 12) = *(_DWORD *)&v99[*(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4)];
      v65 = sub_1000B980(*(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 2));
      v66 = *(_DWORD *)(v64 + 12);
      v67 = *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 16);
      v93 = v65;
      v63 = sub_10002AC0(1u, 0, v66, v65, v67);
      goto LABEL_137;
    }
    if ( *(_BYTE *)v64 == 1 )
    {
LABEL_174:
      if ( !j_HWM_pvg_hsdb_get_router_entry(*(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 20), v99) )
      {
        *(_DWORD *)(v64 + 12) = *(_DWORD *)&v99[*(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4)];
        v68 = sub_1000B980(*(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 2));
        v69 = *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 24);
        v93 = v68;
        v63 = sub_10002AC0(1u, 1, *(_DWORD *)(v64 + 12), v68, v69) == 0;
      }
    }
  }
LABEL_137:
  if ( v63 == 2 )
  {
    v70 = *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 8);
    if ( v70 & 1 )
    {
      v63 = 1;
      HIBYTE(v92) = 2;
      goto LABEL_143;
    }
    if ( !(v70 & 0x200) )
    {
LABEL_156:
      v72 = v98;
      goto LABEL_157;
    }
    v63 = 0;
    HIBYTE(v92) = 3;
LABEL_151:
    if ( *(_BYTE *)(v64 + 8) == 1
      && a6 == 1
      && (*(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 28) || *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 32)) )
    {
      sub_1000C480(a1, 0);
    }
    goto LABEL_156;
  }
  if ( v63 != 1 )
  {
    if ( v63 )
      goto LABEL_156;
    goto LABEL_151;
  }
LABEL_143:
  v71 = *(_BYTE *)(v64 + 8);
  if ( v71 == 1 )
    goto LABEL_156;
  v72 = v98;
  if ( v71 != 2 )
    *(_DWORD *)(v64 + 4) = v98;
  if ( a6 == 1
    && (*(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 28) || *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 32)) )
  {
    sub_1000C480(a1, *(_DWORD *)(v64 + 4));
  }
LABEL_157:
  *(_BYTE *)(v64 + 8) = v63;
  if ( v63 == 1 && !(*(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 8) & 8) )
  {
    if ( (v73 = *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 28)) != 0 && v72 - *(_DWORD *)(v64 + 4) < v73
      || (v74 = *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 32)) != 0 && v72 - *(_DWORD *)(v64 + 4) > v74 )
    {
      v63 = 0;
    }
  }
  *(_BYTE *)v64 = v63;
  if ( v88 )
    *(_DWORD *)(v64 + 16) = *(_DWORD *)(v64 + 12);
  v75 = HIBYTE(v92);
  LOBYTE(v92) = v63;
  if ( HIBYTE(v92) == 4 )
  {
    if ( v63 != 2 )
    {
      HIBYTE(v92) = v63;
      *(_BYTE *)(v64 + 1) = v63;
      return v92;
    }
    v75 = 3;
    HIBYTE(v92) = 3;
  }
  *(_BYTE *)(v64 + 1) = v75;
  return v92;
}
// 100331C0: using guessed type int __cdecl j_HWM_pvg_hsdb_get_router_entry(_DWORD, _DWORD);
// 10057340: using guessed type __int16 word_10057340[];
// 1005734C: using guessed type int dword_1005734C[];
// 10254438: using guessed type int dword_10254438;

//----- (10005B80) --------------------------------------------------------
char sub_10005B80()
{
  unsigned __int8 v0; // bl@1
  char *v1; // esi@1
  char result; // al@2
  unsigned __int8 v3; // [sp+8h] [bp-64h]@1
  char v4; // [sp+Ch] [bp-60h]@1

  sub_1000BE60((int)&v4);
  v0 = 0;
  v3 = 0;
  v1 = &v4;
  do
  {
    result = *v1;
    if ( *v1 == 2 )
    {
      result = sub_10019760(v3, 0x11u);
    }
    else if ( result == 1 )
    {
      result = sub_10019640(v3, 0x11u);
    }
    else if ( (unsigned __int8)result >= 4u )
    {
      result = sub_10011520("..\\lib\\adl\\mon_arfrm.c", 140, 0, "Alert Audio table corrupt");
    }
    ++v0;
    ++v1;
    v3 = v0;
  }
  while ( v0 < 0x5Cu );
  return result;
}

//----- (10005C10) --------------------------------------------------------
char sub_10005C10()
{
  int v0; // eax@24
  unsigned __int8 v1; // bl@40
  char *v2; // esi@40
  __int16 v3; // ax@41
  char v4; // al@42
  char v6; // [sp+1h] [bp-D3h]@15
  char v7; // [sp+2h] [bp-D2h]@1
  char v8; // [sp+3h] [bp-D1h]@1
  int v9; // [sp+4h] [bp-D0h]@5
  int v10; // [sp+8h] [bp-CCh]@1
  char v11; // [sp+Ch] [bp-C8h]@40
  __int16 v12; // [sp+34h] [bp-A0h]@40

  v7 = 0;
  sub_10033160(39, &v10);
  if ( sub_100188B0(139, &v8) )
  {
    if ( !v8 )
    {
      sub_10012C80(16, 0);
      sub_10012C80(16, 1u);
    }
  }
  else
  {
    v8 = 1;
  }
  LOBYTE(v9) = 12;
  if ( !byte_1010A8C9 )
  {
    if ( sub_1000BE80(0, 0, 2) && !sub_10012990(0, v9) )
    {
      v7 = ((v10 & 0x800) != 2048) + 1;
      if ( byte_1010A8C9 )
        goto LABEL_10;
      goto LABEL_9;
    }
    if ( !byte_1010A8C9 )
    {
      v7 = 0;
LABEL_9:
      sub_10032BB0(10007, (int)&v7, 1);
      goto LABEL_10;
    }
  }
LABEL_10:
  LOBYTE(v9) = 11;
  if ( byte_1010A8C9 )
    goto LABEL_15;
  if ( sub_1000BE80(1, 0, 2) && !sub_10012990(0, v9) )
  {
    v7 = ((v10 & 0x1000) == 4096) + 1;
    if ( byte_1010A8C9 )
      goto LABEL_15;
    goto LABEL_14;
  }
  if ( !byte_1010A8C9 )
  {
    v7 = 0;
LABEL_14:
    sub_10032BB0(10008, (int)&v7, 1);
  }
LABEL_15:
  if ( sub_100188B0(129, &v6) && v6 || sub_100188B0(130, &v6) && v6 )
    sub_10012C80(2, 1u);
  if ( (!sub_100188B0(131, &v6) || !v6) && (!sub_100188B0(132, &v6) || !v6) )
  {
    byte_1010A8C8 = 0;
    goto LABEL_40;
  }
  v0 = v10 & 0x6000;
  if ( v0 != 24576 )
  {
    if ( v0 == 0x4000 )
    {
      if ( !sub_1000BE80(0, 0, 3) )
      {
        if ( !byte_1010A8C8 && sub_1000BE80(1, 0, 3) )
          sub_10012C80(2, 1u);
        goto LABEL_38;
      }
    }
    else if ( v0 == 0x2000 )
    {
      sub_10012C80(2, 0);
      sub_10012C80(2, 1u);
      byte_1010A8C8 = 1;
      goto LABEL_40;
    }
    sub_10012C80(2, 0);
LABEL_38:
    byte_1010A8C8 = 1;
    goto LABEL_40;
  }
  sub_10012C80(2, 0);
  sub_10012C80(2, 1u);
  sub_10012C80(2, 2u);
  byte_1010A8C8 = 1;
LABEL_40:
  sub_10032AE0(6310, (int)&v11, 40);
  memset(&v12, 0, 0x9Cu);
  v1 = 0;
  v2 = &v11;
  do
  {
    v3 = *(_WORD *)v2;
    if ( *(_WORD *)v2 != -1 )
    {
      v12 = *(_WORD *)v2;
      v4 = sub_1000BFA0((int)&v12, 0);
      LOBYTE(v3) = sub_10018840(v1 + 83, v4);
    }
    ++v1;
    v2 += 2;
  }
  while ( v1 < 0x14u );
  return v3;
}
// 1010A8C8: using guessed type char byte_1010A8C8;
// 1010A8C9: using guessed type char byte_1010A8C9;

//----- (10005F40) --------------------------------------------------------
char sub_10005F40()
{
  char v0; // cl@4
  char v1; // dl@6
  char result; // al@6
  char v3; // [sp+4h] [bp-4h]@1
  char v4; // [sp+5h] [bp-3h]@1
  char v5; // [sp+6h] [bp-2h]@3
  char v6; // [sp+7h] [bp-1h]@1

  v6 = 0;
  v4 = 0;
  if ( sub_10032DC0(9110, &v3, 1, &v6) )
  {
    v3 = 0;
    byte_1010A8C9 = 0;
    sub_10032BB0(9110, (int)&v3, 1);
  }
  if ( sub_100188B0(137, &v5) )
  {
    v0 = v5;
  }
  else
  {
    v0 = 0;
    v5 = 0;
  }
  v1 = v3;
  result = 2 * v0 | v3 & 0xFD;
  if ( v3 != result )
  {
    v3 = 2 * v0 | v3 & 0xFD;
    result = sub_10032BB0(9110, (int)&v3, 1);
    v1 = v3;
  }
  if ( v1 )
  {
    v4 = 1;
    sub_10032BB0(10007, (int)&v4, 1);
    sub_10032BB0(10008, (int)&v4, 1);
    result = sub_10019760(0x1Au, 0x11u);
    if ( !byte_1010A8C9 )
    {
      byte_1010A8C9 = 1;
      result = sub_10019860(1u);
    }
  }
  else if ( byte_1010A8C9 )
  {
    byte_1010A8C9 = 0;
    result = sub_10019860(0);
  }
  return result;
}
// 1010A8C9: using guessed type char byte_1010A8C9;

//----- (10006050) --------------------------------------------------------
char sub_10006050()
{
  int v0; // ebp@1
  unsigned __int8 v1; // bl@3
  int v2; // eax@4
  unsigned int v3; // ecx@5
  unsigned int v4; // esi@10
  char v5; // bl@11
  char result; // al@18
  int v7; // [sp+4h] [bp-240h]@1
  __int16 v8[2]; // [sp+8h] [bp-23Ch]@6
  int v9; // [sp+Ch] [bp-238h]@5
  int v10[94]; // [sp+10h] [bp-234h]@4
  char v11[92]; // [sp+188h] [bp-BCh]@3
  char v12[92]; // [sp+1E4h] [bp-60h]@3

  v0 = sub_10032ED0();
  if ( sub_10019710(&v7) && v7 != dword_1010A8D0 )
  {
    memset(v12, 0, 0x5Cu);
    memset(v11, 0, 0x5Cu);
    sub_1000BEB0((int)v11);
    v1 = 0;
    do
    {
      v2 = 6 * v1;
      if ( !v10[3 * v1] )
        break;
      v3 = *(int *)((char *)&v9 + v2 * 2);
      if ( v3 >= 0x5C )
      {
        sub_10011520("..\\lib\\adl\\mon_arfrm.c", 555, 0, "GIA returned active audio message out of range.");
      }
      else if ( v8[v2] == 17 )
      {
        v12[v3] = 1;
      }
      ++v1;
    }
    while ( v1 < 0x20u );
    v4 = 0;
    do
    {
      v5 = v12[v4];
      if ( v5 != v11[v4] && sub_10019AF0(v4) )
      {
        if ( v5 == 1 )
          sub_10019640(v4, 0x11u);
        else
          sub_10019760(v4, 0x11u);
      }
      ++v4;
    }
    while ( v4 < 0x5C );
    dword_1010A8D0 = v7;
  }
  result = sub_1000BC60();
  if ( !result )
  {
    result = v0 - dword_1010A8CC;
    if ( (unsigned int)(v0 - dword_1010A8CC) >= 0x3E8 )
    {
      result = sub_10019590(0x11u, 0);
      dword_1010A8CC = v0;
    }
  }
  return result;
}
// 1010A8CC: using guessed type int dword_1010A8CC;
// 1010A8D0: using guessed type int dword_1010A8D0;
// 10006050: using guessed type char var_60[92];
// 10006050: using guessed type char var_BC[92];
// 10006050: using guessed type int var_234[94];
// 10006050: using guessed type __int16 var_23C[2];

//----- (100061B0) --------------------------------------------------------
int sub_100061B0()
{
  unsigned __int8 v0; // bl@1
  int v1; // esi@1
  int result; // eax@2
  int v3; // [sp+8h] [bp-8h]@1
  int v4; // [sp+Ch] [bp-4h]@1

  v0 = 0;
  LOBYTE(v3) = 0;
  LOBYTE(v4) = 0;
  v1 = 29000;
  do
  {
    result = sub_10032AE0(v1, (int)&v3, 1);
    if ( !result )
    {
      if ( (_BYTE)v3 )
      {
        sub_1000C4F0(v3, 0xFFFF, v4);
        LOBYTE(v3) = 0;
        result = sub_10032BB0(v1, (int)&v3, 1);
      }
    }
    ++v0;
    ++v1;
    LOBYTE(v4) = v0;
  }
  while ( v0 <= 5u );
  return result;
}

//----- (10006220) --------------------------------------------------------
__int16 __cdecl sub_10006220(int a1, unsigned __int16 a2)
{
  int v2; // eax@1
  int v3; // edi@2
  int v4; // esi@2
  int v5; // ebp@2

  byte_1010A92E = 0;
  memset(dword_1011D4B8, 0, 0xBCu);
  byte_1010A92C = 0;
  memset(word_1010C4C8, 0, 0xC8u);
  memset(&unk_1010A8D8, 0, 0x54u);
  memset(&unk_1010C590, 0, 0xFAu);
  memset(byte_1010C3C8, 0, 0xFAu);
  sub_10032BB0(9194, (int)byte_1010C3C8, 250);
  sub_10032AE0(6056, (int)&unk_1011D574, 4);
  LOWORD(v2) = a2;
  if ( a2 > 0u )
  {
    v3 = a1;
    v4 = 0;
    v5 = a2;
    do
    {
      v2 = -(sub_100198E0(v3) != 0);
      *(_DWORD *)(v4 + dword_10254438 + 8) = v2;
      *(_DWORD *)(v4 + dword_10254438 + 12) = 0;
      v3 += 160;
      v4 += 16;
      --v5;
    }
    while ( v5 );
  }
  return v2;
}
// 1010A92C: using guessed type char byte_1010A92C;
// 1010A92E: using guessed type char byte_1010A92E;
// 1010C4C8: using guessed type __int16 word_1010C4C8[];
// 1011D4B8: using guessed type int dword_1011D4B8[];
// 10254438: using guessed type int dword_10254438;

//----- (10006300) --------------------------------------------------------
int __cdecl sub_10006300(char a1)
{
  int result; // eax@3

  if ( a1 == 1 )
  {
    dword_10254430 = dword_10254440 + 40;
    result = dword_10254440 + 136044;
    dword_10254434 = dword_10254440 + 120040;
    dword_10254438 = dword_10254440 + 120044;
    dword_1025443C = dword_10254440 + 136044;
  }
  else if ( a1 == 2 )
  {
    dword_10254430 = dword_10254440 + 205204;
    result = dword_10254440 + 237208;
    dword_10254434 = dword_10254440 + 229204;
    dword_10254438 = dword_10254440 + 229208;
    dword_1025443C = dword_10254440 + 237208;
  }
  else
  {
    dword_10254430 = dword_10254444;
    result = dword_10254444 + 120004;
    dword_10254434 = dword_10254444 + 120000;
    dword_10254438 = dword_10254444 + 120004;
    dword_1025443C = (int)&unk_1010C690;
  }
  return result;
}
// 10254430: using guessed type int dword_10254430;
// 10254434: using guessed type int dword_10254434;
// 10254438: using guessed type int dword_10254438;
// 1025443C: using guessed type int dword_1025443C;
// 10254440: using guessed type int dword_10254440;
// 10254444: using guessed type int dword_10254444;

//----- (100063A0) --------------------------------------------------------
int sub_100063A0()
{
  unsigned int v0; // edx@1
  char *v1; // eax@1
  _DWORD *v2; // ecx@1
  int v3; // esi@5
  int v4; // edx@6
  _BYTE *v5; // eax@6
  _BYTE *v6; // ecx@6
  int v7; // edx@8
  _BYTE *v8; // eax@8
  _BYTE *v9; // ecx@8
  _BYTE *v10; // eax@10
  _BYTE *v11; // ecx@10
  int result; // eax@12

  v0 = 250;
  v1 = byte_1010C3C8;
  v2 = &unk_1010C590;
  do
  {
    if ( *v2 != *(_DWORD *)v1 )
      goto LABEL_5;
    v0 -= 4;
    v1 += 4;
    ++v2;
  }
  while ( v0 >= 4 );
  if ( !v0 )
  {
LABEL_14:
    result = 0;
    goto LABEL_15;
  }
LABEL_5:
  v3 = *(_BYTE *)v2 - (unsigned __int8)*v1;
  if ( *(_BYTE *)v2 == (unsigned __int8)*v1 )
  {
    v4 = v0 - 1;
    v5 = v1 + 1;
    v6 = (char *)v2 + 1;
    if ( !v4 )
      goto LABEL_14;
    v3 = *v6 - *v5;
    if ( *v6 == *v5 )
    {
      v7 = v4 - 1;
      v8 = v5 + 1;
      v9 = v6 + 1;
      if ( !v7 )
        goto LABEL_14;
      v3 = *v9 - *v8;
      if ( *v9 == *v8 )
      {
        v10 = v8 + 1;
        v11 = v9 + 1;
        if ( v7 == 1 )
          goto LABEL_14;
        v3 = *v11 - *v10;
        if ( *v11 == *v10 )
          goto LABEL_14;
      }
    }
  }
  result = 1;
  if ( v3 <= 0 )
    result = -1;
LABEL_15:
  if ( result )
  {
    result = sub_10032BB0(9194, (int)byte_1010C3C8, 250);
    qmemcpy(&unk_1010C590, byte_1010C3C8, 0xFAu);
  }
  return result;
}

//----- (10006460) --------------------------------------------------------
int __cdecl sub_10006460(char a1, int a2)
{
  int result; // eax@1

  *(_BYTE *)(dword_10254440 + 306372) = a1;
  result = dword_10254440;
  *(_DWORD *)(dword_10254440 + 306368) = a2;
  return result;
}
// 10254440: using guessed type int dword_10254440;

//----- (10006480) --------------------------------------------------------
int __usercall sub_10006480@<eax>(_WORD *a1@<eax>, int a2)
{
  int result; // eax@2

  if ( byte_1010A92E )
    result = sub_1000C130((int)a1);
  else
    result = sub_1000C0E0(*a1, a2, 1);
  return result;
}
// 1010A92E: using guessed type char byte_1010A92E;

//----- (100064B0) --------------------------------------------------------
signed int __usercall sub_100064B0@<eax>(unsigned __int16 a1@<ax>)
{
  signed int result; // eax@2

  if ( a1 >= 0xFu )
  {
    sub_10011520("..\\lib\\adl\\mon_cas.c", 2201, 0, "Unexpected requested registry for alert sync information");
    result = 42066;
  }
  else
  {
    result = (unsigned __int16)(a1 + 9012);
  }
  return result;
}

//----- (100064E0) --------------------------------------------------------
char __cdecl sub_100064E0(char a1, _DWORD *a2)
{
  __int16 v2; // ax@1
  char result; // al@2

  v2 = sub_10019B30(&a1, 2u, (int)&unk_10080440, 12, 32, -1);
  if ( v2 == -1 )
  {
    result = 0;
  }
  else
  {
    *a2 = dword_1008043C[3 * v2];
    result = 1;
  }
  return result;
}
// 1008043C: using guessed type int dword_1008043C[];

//----- (10006530) --------------------------------------------------------
int __usercall sub_10006530@<eax>(int result@<eax>, int a2@<edx>, char a3, char a4, char a5)
{
  int v5; // ecx@1
  __int16 v6; // dx@1
  unsigned __int16 v7; // si@2
  char v8; // [sp+0h] [bp-4h]@6

  result = (unsigned __int16)result;
  v5 = a2 + 160 * (unsigned __int16)result;
  v6 = *(_WORD *)(v5 + 132);
  if ( v6 )
  {
    v7 = *(_WORD *)(v5 + 148);
    if ( !v7 || (result *= 16, *(_DWORD *)(result + dword_10254438 + 12) <= (unsigned int)v7) )
    {
      if ( a3 )
      {
        if ( !(*(_BYTE *)(v5 + 152) & 0x40) )
        {
          v8 = 1;
          if ( a4 )
            v8 = 3;
          result = sub_1000BD30(*(_WORD *)v5, v6, v8, byte_1010A92C, a5);
        }
      }
      else if ( !(*(_BYTE *)(v5 + 152) & 0x20) )
      {
        result = sub_1000BD30(*(_WORD *)v5, v6, 0, byte_1010A92C, a5);
      }
    }
  }
  return result;
}
// 1010A92C: using guessed type char byte_1010A92C;
// 10254438: using guessed type int dword_10254438;

//----- (100065E0) --------------------------------------------------------
char __usercall sub_100065E0@<al>(unsigned __int16 a1@<ax>, int a2)
{
  unsigned __int16 v2; // ax@1
  bool v3; // zf@2
  char result; // al@2

  v2 = sub_100064B0(a1);
  if ( v2 == -23470 || (v3 = sub_10032AE0(v2, a2, 804) == 0, result = 1, !v3) )
    result = 0;
  return result;
}

//----- (10006620) --------------------------------------------------------
char __usercall sub_10006620@<al>(char a1@<al>, unsigned __int16 a2@<cx>)
{
  signed int v2; // ecx@1
  char result; // al@1

  v2 = 2 * a2;
  result = (a1 << v2 % 8) | byte_1010C3C8[(unsigned __int8)(v2 / 8)] & ~(1 << v2 % 8) & ~(1 << (v2 % 8 + 1));
  byte_1010C3C8[(unsigned __int8)(v2 / 8)] = result;
  return result;
}

//----- (10006670) --------------------------------------------------------
char __usercall sub_10006670@<al>(unsigned __int16 a1@<ax>, char a2)
{
  unsigned __int16 v2; // dx@1
  char v3; // al@1
  char v4; // cl@3
  int v5; // edx@6
  _BYTE *v6; // eax@7
  _BYTE *v7; // esi@9

  v2 = a1 >> 1;
  v3 = a1 & 1;
  if ( a2 )
  {
    if ( a2 == 1 )
      v4 = 1;
    else
      v4 = 4;
  }
  else
  {
    v4 = 2;
  }
  v5 = 3 * v2;
  if ( v3 )
  {
    v6 = (_BYTE *)(dword_10254430 + 4 * v5 + 8);
    if ( !((unsigned __int8)v4 & *v6) )
    {
      *v6 |= v4;
      v6 = (_BYTE *)sub_10032ED0();
      *(_DWORD *)dword_10254434 = v6;
    }
  }
  else
  {
    v7 = (_BYTE *)(dword_10254430 + 4 * v5 + 8);
    LOBYTE(v6) = *v7;
    if ( !((unsigned __int8)(16 * v4) & *v7) )
    {
      *v7 |= 16 * v4;
      v6 = (_BYTE *)sub_10032ED0();
      *(_DWORD *)dword_10254434 = v6;
    }
  }
  return (unsigned int)v6;
}
// 10254430: using guessed type int dword_10254430;
// 10254434: using guessed type int dword_10254434;

//----- (100066F0) --------------------------------------------------------
char __usercall sub_100066F0@<al>(int a1@<eax>, int a2@<ecx>, char a3@<bl>, int a4, char a5, _BYTE *a6)
{
  int v6; // esi@1
  int v7; // edi@1
  int v8; // eax@1
  int v9; // edx@6
  int v10; // eax@7
  int v11; // edi@14
  char result; // al@22
  char v13; // [sp+Fh] [bp-9h]@1
  int v14; // [sp+10h] [bp-8h]@1
  int v15; // [sp+14h] [bp-4h]@1

  a2 = (unsigned __int16)a2;
  v6 = 16 * (unsigned __int16)a2;
  v7 = a1;
  v8 = dword_10254438;
  v14 = *(_DWORD *)(v6 + dword_10254438);
  v13 = 0;
  v15 = *(_DWORD *)(v6 + dword_10254438 + 4);
  if ( a5 == 1 )
  {
    if ( a3 != 1 && !*(_DWORD *)(v6 + dword_10254438) && *(_DWORD *)(160 * a2 + v7 + 140) )
    {
      *(_DWORD *)(v6 + dword_10254438) = a4;
      v8 = dword_10254438;
      v13 = 1;
    }
    *(_DWORD *)(v6 + v8 + 4) = 0;
    v9 = *(_DWORD *)(v6 + dword_10254438);
    if ( v9 )
    {
      v10 = 160 * a2 + v7;
      if ( a4 < v9 + *(_DWORD *)(v10 + 140) )
      {
        *a6 = a3;
        *(_BYTE *)(dword_10254430 + 12 * *(_WORD *)(v10 + 156)) = a3;
      }
    }
  }
  else
  {
    *(_DWORD *)(v6 + dword_10254438) = 0;
    if ( a3 == 1 && !*(_DWORD *)(v6 + dword_10254438 + 4) && *(_DWORD *)(160 * a2 + v7 + 144) )
    {
      *(_DWORD *)(v6 + dword_10254438 + 4) = a4;
      v13 = 2;
    }
    if ( *(_DWORD *)(v6 + dword_10254438 + 4) )
    {
      v11 = 160 * a2 + v7;
      if ( (!(*(_BYTE *)(v11 + 152) & 4) || !sub_1000BFD0(*(_WORD *)v11))
        && a4 < *(_DWORD *)(v11 + 144) + *(_DWORD *)(v6 + dword_10254438 + 4) )
      {
        *a6 = a3;
        *(_BYTE *)(dword_10254430 + 12 * *(_WORD *)(v11 + 156)) = a3;
      }
    }
  }
  if ( *(_DWORD *)(v6 + dword_10254438) || *(_DWORD *)(v6 + dword_10254438 + 4) || !v14 && !v15 )
    result = v13;
  else
    result = 3;
  return result;
}
// 10254430: using guessed type int dword_10254430;
// 10254438: using guessed type int dword_10254438;

//----- (10006860) --------------------------------------------------------
char __usercall sub_10006860@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, char a4, int a5, int a6)
{
  signed int v6; // ecx@4
  char *v7; // edi@12
  unsigned int v8; // eax@12
  char *v9; // ecx@12
  int *v10; // edx@12
  int v11; // esi@16
  int v12; // eax@17
  _BYTE *v13; // ecx@17
  _BYTE *v14; // edx@17
  int v15; // eax@19
  _BYTE *v16; // ecx@19
  _BYTE *v17; // edx@19
  _BYTE *v18; // ecx@21
  _BYTE *v19; // edx@21
  int v20; // eax@23
  int v21; // eax@27
  int v22; // ecx@27
  char v23; // bl@27
  int v24; // edx@28
  int *v25; // ebp@28
  _DWORD *v26; // edi@28
  int v27; // ecx@32
  int v28; // esi@32
  char v30; // [sp+13h] [bp-19h]@27
  signed int v31; // [sp+14h] [bp-18h]@28
  int v32; // [sp+18h] [bp-14h]@27
  int v33; // [sp+1Ch] [bp-10h]@27
  int v34; // [sp+20h] [bp-Ch]@12
  int v35; // [sp+24h] [bp-8h]@27
  int v36; // [sp+28h] [bp-4h]@27

  j_reg_get_tag_hdr(a2, a1);
  if ( a3 > 0x26AF )
  {
    if ( a3 == 9904 )
      v6 = 6;
    else
LABEL_10:
      v6 = 2;
  }
  else if ( a3 == 9903 )
  {
    v6 = 5;
  }
  else
  {
    switch ( a3 )
    {
      case 0x23D9u:
        v6 = 1;
        break;
      case 0x23DBu:
        v6 = 0;
        break;
      case 0x23DCu:
        v6 = 3;
        break;
      case 0x23DDu:
        v6 = 4;
        break;
      default:
        goto LABEL_10;
    }
  }
  v7 = (char *)&unk_1010A8D8 + 12 * v6;
  v8 = 12;
  v9 = (char *)&unk_1010A8D8 + 12 * v6;
  v10 = &v34;
  do
  {
    if ( *v10 != *(_DWORD *)v9 )
      goto LABEL_16;
    v8 -= 4;
    v9 += 4;
    ++v10;
  }
  while ( v8 >= 4 );
  if ( !v8 )
  {
LABEL_25:
    v20 = 0;
    goto LABEL_26;
  }
LABEL_16:
  v11 = *(_BYTE *)v10 - (unsigned __int8)*v9;
  if ( *(_BYTE *)v10 == (unsigned __int8)*v9 )
  {
    v12 = v8 - 1;
    v13 = v9 + 1;
    v14 = (char *)v10 + 1;
    if ( !v12 )
      goto LABEL_25;
    v11 = *v14 - *v13;
    if ( *v14 == *v13 )
    {
      v15 = v12 - 1;
      v16 = v13 + 1;
      v17 = v14 + 1;
      if ( !v15 )
        goto LABEL_25;
      v11 = *v17 - *v16;
      if ( *v17 == *v16 )
      {
        v18 = v16 + 1;
        v19 = v17 + 1;
        if ( v15 == 1 )
          goto LABEL_25;
        v11 = *v19 - *v18;
        if ( *v19 == *v18 )
          goto LABEL_25;
      }
    }
  }
  v20 = 1;
  if ( v11 <= 0 )
    v20 = -1;
LABEL_26:
  if ( v20 )
  {
    v21 = v35;
    v22 = v36;
    *(_DWORD *)v7 = v34;
    *((_DWORD *)v7 + 1) = v21;
    *((_DWORD *)v7 + 2) = v22;
    v30 = sub_1000BED0(0);
    sub_10032AE0(a3, (int)&unk_1010A930, 6000);
    v33 = sub_10032ED0();
    v23 = 0;
    LOBYTE(v20) = sub_10012750(a4, &v32);
    if ( (_BYTE)v20 )
    {
      v24 = a6 + 4;
      v25 = (int *)&unk_1010A930;
      v26 = (_DWORD *)(a5 + 32);
      v31 = 1500;
      do
      {
        if ( *(v26 - 1) || *v26 )
        {
          v20 = *v25;
          if ( *v25 )
          {
            v27 = *(_DWORD *)v24;
            v20 = v33 + v20 - v32;
            v28 = v20;
            if ( v30 )
            {
              LOBYTE(v20) = v20 < v27;
              v23 = 1;
            }
            else
            {
              LOBYTE(v20) = v20 > v27;
            }
            if ( (_BYTE)v20 || !v27 )
            {
              *(_DWORD *)v24 = v28;
              *(_BYTE *)(v24 + 4) = 2;
            }
          }
        }
        v26 += 16;
        ++v25;
        v24 += 20;
        --v31;
      }
      while ( v31 );
      if ( v23 )
      {
        memset(&unk_1010A930, 0, 0x1770u);
        LOBYTE(v20) = sub_10032BB0(a3, (int)&unk_1010A930, 6000);
      }
    }
  }
  return v20;
}
// 10032AC0: using guessed type int __fastcall j_reg_get_tag_hdr(_DWORD, _DWORD);

//----- (10006A70) --------------------------------------------------------
char __usercall sub_10006A70@<al>(unsigned __int16 a1@<ax>, int a2@<edi>)
{
  unsigned __int16 v2; // si@1
  void *v3; // ecx@1
  int v4; // eax@1
  bool v5; // zf@2
  char result; // al@2

  v2 = sub_100064B0(a1);
  v4 = sub_100122C0(v3);
  *(_BYTE *)(a2 + 800) = sub_10012640(v4);
  if ( v2 == -23470 || (v5 = sub_10032BB0(v2, a2, 804) == 0, result = 1, !v5) )
    result = 0;
  return result;
}

//----- (10006AC0) --------------------------------------------------------
char __cdecl sub_10006AC0(signed __int16 a1, int a2, int a3, int a4)
{
  signed __int16 v4; // si@2
  signed __int16 v5; // di@2
  int v6; // eax@6
  unsigned __int16 v7; // si@7
  unsigned __int16 v8; // bx@11
  int *v9; // ebp@11
  int v10; // esi@12
  int v11; // ST08_4@12
  bool v12; // cl@12
  char v13; // al@13
  int v14; // ecx@14
  int v15; // esi@14
  int v16; // ecx@14
  int v17; // eax@16
  int v18; // edx@16
  unsigned int v19; // eax@20
  bool v20; // zf@23
  unsigned __int16 v22; // [sp+Ch] [bp-18h]@7
  int v23; // [sp+10h] [bp-14h]@6
  unsigned int v24; // [sp+14h] [bp-10h]@0
  signed int v25; // [sp+18h] [bp-Ch]@11
  int v26; // [sp+1Ch] [bp-8h]@7
  int v27; // [sp+20h] [bp-4h]@7
  char v28; // [sp+28h] [bp+4h]@8

  if ( (_BYTE)a1 == 1 )
  {
    v4 = 0;
    v5 = 10;
    v24 = 10000;
  }
  else if ( (_BYTE)a1 == 2 )
  {
    v4 = 10;
    v5 = 5;
    v24 = 2000;
  }
  else
  {
    sub_10011520("..\\lib\\adl\\mon_cas.c", 1146, 0, 0);
    v4 = a1;
    v5 = 0;
  }
  v6 = sub_10032ED0();
  v23 = v6;
  if ( v5 )
  {
    v27 = 3 * (unsigned __int8)a1;
    v22 = v4;
    v7 = 0;
    v26 = (unsigned __int16)v5;
    do
    {
      v28 = 1;
      if ( sub_100065E0(v22, (int)byte_1010C0A0) && byte_1010C3C0 == *(_BYTE *)(dword_10254440 + 306372) )
        v28 = 0;
      v8 = v7;
      v9 = dword_1010C0A4;
      v25 = 100;
      do
      {
        v10 = 16 * v8 + a2;
        v11 = (unsigned __int16)(v8 + word_1006DAA0[2 * v27]);
        *(_DWORD *)v10 = 0;
        *(_DWORD *)(v10 + 4) = 0;
        v12 = sub_1000C080(v11) != 0;
        if ( v28 )
          goto LABEL_27;
        v13 = *((_BYTE *)v9 - 4);
        if ( v13 == 1 )
        {
          v14 = *v9 + *(_DWORD *)(dword_10254440 + 306368);
          *(_DWORD *)v10 = v14;
          *(_DWORD *)(v10 + 4) = 0;
          v15 = v14;
          v16 = v14 + *(_DWORD *)(160 * v8 + a4 + 140);
          *v9 = v15;
          v12 = v23 > v16;
          goto LABEL_20;
        }
        if ( v13 == 2 )
        {
          *(_DWORD *)v10 = 0;
          v17 = *v9 + *(_DWORD *)(dword_10254440 + 306368);
          *(_DWORD *)(v10 + 4) = v17;
          v18 = v17 + *(_DWORD *)(160 * v8 + a4 + 144);
          *v9 = v17;
          v12 = v23 <= v18;
          goto LABEL_20;
        }
        if ( v13 != 3 )
LABEL_27:
          *((_BYTE *)v9 - 4) = 0;
        *v9 = 0;
LABEL_20:
        v19 = *(_WORD *)(160 * v8 + a4 + 156);
        if ( v19 <= v24 )
          *(_BYTE *)(a3 + 12 * v19) = v12;
        ++v8;
        v9 += 2;
        --v25;
      }
      while ( v25 );
      LOBYTE(v6) = sub_10006A70(v22, (int)byte_1010C0A0);
      v20 = v26-- == 1;
      v7 = v8;
      ++v22;
    }
    while ( !v20 );
  }
  return v6;
}
// 1006DAA0: using guessed type __int16 word_1006DAA0[];
// 1010C0A4: using guessed type int dword_1010C0A4[];
// 1010C3C0: using guessed type char byte_1010C3C0;
// 10254440: using guessed type int dword_10254440;

//----- (10006CD0) --------------------------------------------------------
char sub_10006CD0()
{
  unsigned __int16 v0; // bp@1
  int v1; // ebx@3
  signed __int16 v2; // si@3
  unsigned __int16 v3; // si@5
  char *v4; // eax@5
  signed int v5; // edi@5
  int v6; // ecx@6
  int v7; // ecx@8
  char result; // al@11
  char v9; // [sp+10h] [bp-324h]@5

  v0 = 0;
  do
  {
    if ( v0 >= 0xAu )
    {
      v1 = dword_10254440 + 229208;
      v2 = 10;
    }
    else
    {
      v1 = dword_10254440 + 120044;
      v2 = 0;
    }
    memset(&v9, 0, 0x324u);
    v3 = 100 * (v0 - v2);
    v4 = &v9;
    v5 = 100;
    do
    {
      v6 = 16 * v3 + v1;
      if ( *(_DWORD *)v6 )
      {
        *((_DWORD *)v4 + 1) = *(_DWORD *)v6;
        *v4 = 1;
      }
      else
      {
        v7 = *(_DWORD *)(v6 + 4);
        if ( v7 )
        {
          *((_DWORD *)v4 + 1) = v7;
          *v4 = 2;
        }
      }
      ++v3;
      v4 += 8;
      --v5;
    }
    while ( v5 );
    result = sub_10006A70(v0++, (int)&v9);
  }
  while ( v0 < 0xFu );
  return result;
}
// 10254440: using guessed type int dword_10254440;

//----- (10006D90) --------------------------------------------------------
char __cdecl sub_10006D90(int a1, int a2)
{
  char v2; // bl@1
  void *v3; // ecx@1
  int v4; // edx@1
  int v5; // ecx@1
  int v6; // esi@1
  char result; // al@22

  v2 = j_HWM_pvg_hsdb_get_lrus_online();
  v6 = sub_100122C0(v3);
  if ( v6 != 1 && v2 & 1 )
    sub_10006860(v4, v5, 0x23D9u, 1, a1, a2);
  if ( v6 != 4 && v2 & 4 )
    sub_10006860(v4, v5, 0x23DBu, 0, a1, a2);
  if ( v6 != 2 && v2 & 2 )
    sub_10006860(v4, v5, 0x23DAu, 2, a1, a2);
  if ( v6 != 64 && v2 & 0x40 )
    sub_10006860(v4, v5, 0x23DCu, 3, a1, a2);
  if ( v6 != 128 && v2 < 0 )
    sub_10006860(v4, v5, 0x23DDu, 4, a1, a2);
  if ( v6 != 16 && v2 & 0x10 )
    sub_10006860(v4, v5, 0x26AFu, 5, a1, a2);
  if ( v6 != 32 && v2 & 0x20 )
    sub_10006860(v4, v5, 0x26B0u, 6, a1, a2);
  result = sub_1000BED0(0);
  if ( result )
  {
    SYS_enter_krnl();
    SYS_pvg_trig_share();
    result = SYS_exit_krnl();
  }
  return result;
}
// 100331B0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F6C: using guessed type int SYS_pvg_trig_share(void);

//----- (10006E90) --------------------------------------------------------
char __cdecl sub_10006E90(char a1)
{
  int v1; // ecx@0
  int v2; // esi@1
  char result; // al@4
  int v4; // [sp+8h] [bp-70h]@1
  char v5; // [sp+Ch] [bp-6Ch]@1
  char v6; // [sp+40h] [bp-38h]@1

  v2 = v1;
  memset(&v5, 0, 0x33u);
  memset(&v6, 0, 0x33u);
  if ( sub_100064E0(a1, &v4) )
    sub_10032DC0(v4, &v5, 51, &v6);
  if ( sub_1000A740(&v5, 0x33u) <= 0 )
  {
    result = 0;
  }
  else
  {
    sub_1000A6F0(v2 + 33, &v5, 51);
    result = 1;
  }
  return result;
}

//----- (10006F40) --------------------------------------------------------
char __usercall sub_10006F40@<al>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, __int16 a4, unsigned __int16 a5, int a6, char a7)
{
  int v7; // edi@1
  int v8; // esi@1
  char v9; // al@1
  int v10; // eax@18
  unsigned __int16 v11; // dx@18
  int v12; // eax@23
  int v13; // ecx@23
  int v14; // esi@23
  int v15; // eax@23
  unsigned __int16 v16; // ax@24
  bool v17; // cf@26
  bool v18; // zf@26
  int v19; // eax@32
  int v20; // ecx@32
  int v21; // eax@32
  char v22; // al@33
  unsigned int v23; // edx@37
  int v24; // eax@37
  signed int v25; // edi@37
  int v26; // ecx@38
  __int16 v27; // kr00_2@38
  int v28; // eax@41
  int v29; // ecx@41
  int v30; // esi@41
  int v31; // eax@41
  char v32; // cl@45
  char v33; // cl@49
  int v34; // eax@55
  char v36; // [sp+Dh] [bp-B3h]@15
  char v37; // [sp+Dh] [bp-B3h]@32
  char v38; // [sp+11h] [bp-AFh]@38
  char v39; // [sp+12h] [bp-AEh]@1
  char v40; // [sp+13h] [bp-ADh]@1
  int v41; // [sp+14h] [bp-ACh]@1
  int v42; // [sp+18h] [bp-A8h]@1
  int v43; // [sp+1Ch] [bp-A4h]@1
  char v44; // [sp+20h] [bp-A0h]@1
  char v45; // [sp+22h] [bp-9Eh]@23
  char v46; // [sp+B8h] [bp-8h]@22

  v7 = a2;
  v8 = a1;
  v43 = a2;
  v42 = a1;
  v41 = a6;
  memset(&v44, 0, 0x9Cu);
  v9 = *(_BYTE *)(a3 + 8 * a5 + 6);
  v39 = 0;
  v40 = 1;
  if ( !v9 || v9 == 16 || v9 == 8 || v9 == 7 || v9 == 9 || v9 == 10 || v9 == 11 || v9 == 15 || v9 == 17 )
  {
    v16 = *(_WORD *)(a3 + 8 * a5);
    if ( v16 == -1 )
      return 0;
    if ( a7 == 1 )
    {
      v17 = v16 < 0x5DCu;
      v18 = v16 == 1500;
    }
    else if ( a7 )
    {
      if ( a7 != 2 )
        goto LABEL_32;
      v17 = v16 < 0x258u;
      v18 = v16 == 600;
    }
    else
    {
      v17 = v16 < 0x5DCu;
      v18 = v16 == 1500;
    }
    if ( !v17 && !v18 )
      return 0;
LABEL_32:
    v19 = v16 << 6;
    v20 = *(_DWORD *)(v19 + v8 + 8);
    v21 = v8 + v19;
    v37 = 1;
    if ( v20 & 0x100 )
    {
      v22 = *(_BYTE *)(v41 + 20 * *(_WORD *)(v21 + 36)) == 1;
    }
    else
    {
      if ( (char)v20 >= 0 )
      {
LABEL_37:
        v23 = (unsigned int)*(_WORD *)(a3 + 8 * a5) >> 5;
        v24 = dword_1011D4B8[v23];
        v25 = 1 << (*(_WORD *)(a3 + 8 * a5) & 0x1F);
        if ( v24 & v25 )
        {
          v36 = *(_BYTE *)(v41 + 20 * *(_WORD *)(a3 + 8 * a5));
          v38 = *(_BYTE *)(v41 + 20 * *(_WORD *)(a3 + 8 * a5) + 1);
        }
        else
        {
          v26 = v43;
          dword_1011D4B8[v23] = v25 | v24;
          v27 = sub_10005040(*(_WORD *)(a3 + 8 * a5), v37, v41 + 20 * *(_WORD *)(a3 + 8 * a5), v8, v26, a7);
          v38 = HIBYTE(v27);
          v36 = v27;
        }
        if ( !(*(_BYTE *)((*(_WORD *)(a3 + 8 * a5) << 6) + v8 + 8) & 2) )
        {
          v28 = 6916 * (unsigned __int8)byte_1010A92C;
          *(_DWORD *)(dword_1025443C
                    + 4 * (1729 * (unsigned __int8)byte_1010A92C + *(_BYTE *)(v28 + dword_1025443C + 2))
                    + 20) = *(_DWORD *)(v41 + 20 * *(_WORD *)(a3 + 8 * a5) + 12);
          *(_BYTE *)(v28 + *(_BYTE *)(v28 + dword_1025443C + 2) + dword_1025443C + 420) = *(_BYTE *)((*(_WORD *)(a3 + 8 * a5) << 6) + v8 + 1);
          v29 = dword_1025443C;
          word_1010C4C8[*(_BYTE *)(v28 + dword_1025443C + 2)] = a5;
          sub_1000A6F0(
            v28 + 21 * *(_BYTE *)(v28 + v29 + 2) + v29 + 520,
            (_BYTE *)((*(_WORD *)(a3 + 8 * a5) << 6) + v8 + 38),
            21);
          v30 = (unsigned __int8)byte_1010A92C;
          v31 = 6916 * (unsigned __int8)byte_1010A92C;
          *(_BYTE *)(v31 + *(_BYTE *)(v31 + dword_1025443C + 2) + dword_1025443C + 3120) = v38;
          *(_BYTE *)(v31 + *(_BYTE *)(v31 + dword_1025443C + 2) + dword_1025443C + 2620) = *(_BYTE *)((*(_WORD *)(a3 + 8 * a5) << 6) + v42 + 59);
          *(_DWORD *)(dword_1025443C + 4 * (1729 * v30 + *(_BYTE *)(v31 + dword_1025443C + 2)) + 2720) = *(_DWORD *)((*(_WORD *)(a3 + 8 * a5) << 6) + v42 + 60);
          *(_WORD *)(dword_1025443C + 2 * (3458 * v30 + *(_BYTE *)(v31 + dword_1025443C + 2)) + 3220) = *(_WORD *)(a3 + 8 * a5);
          v8 = v42;
          ++*(_BYTE *)(v31 + dword_1025443C + 2);
        }
        switch ( *(_BYTE *)(a3 + 8 * a5 + 6) )
        {
          case 7:
            if ( v36 != 2 )
              v36 = v36 == 0;
            break;
          case 9:
            v32 = v36;
            if ( *(_BYTE *)(dword_10254430 + 12 * a5 + 1) != 1 || (v36 = 1, v32 == 1) )
              v36 = 0;
            *(_BYTE *)(dword_10254430 + 12 * a5 + 1) = v32;
            break;
          case 0xA:
            v33 = v36;
            if ( *(_BYTE *)(dword_10254430 + 12 * a5 + 1) == 1 || (v36 = 1, v33 != 1) )
              v36 = 0;
            *(_BYTE *)(dword_10254430 + 12 * a5 + 1) = v33;
            break;
          case 0x10:
            if ( v36 == 1 )
              byte_1010A92E = sub_10006E90(*(_WORD *)((*(_WORD *)(a3 + 8 * a5) << 6) + v8 + 2));
            break;
          default:
            goto LABEL_55;
        }
        goto LABEL_55;
      }
      v22 = sub_1000C080(*(_WORD *)(v21 + 36));
    }
    v37 = v22;
    goto LABEL_37;
  }
  if ( (v9 == 13 || v9 == 14 || v9 == 12) && sub_1000B7F0(v7, *(_WORD *)(a3 + 8 * a5), a7, (bool *)&v40, &v39) )
  {
    if ( v40 )
    {
      v36 = 2;
    }
    else
    {
      v36 = v39 != 0;
      if ( *(_BYTE *)(a3 + 8 * a5 + 6) == 14 )
        v36 = v39 == 0;
    }
    v10 = *(_WORD *)(a3 + 8 * a5);
    v11 = word_1006DAA0[6 * (unsigned __int8)a7];
    if ( (unsigned __int16)v10 < v11 || (unsigned __int16)v10 > (unsigned __int16)word_1006DAA2[6 * (unsigned __int8)a7] )
    {
      if ( !sub_1000BF10((int)&v44, v10) )
      {
LABEL_55:
        v34 = 12 * a5;
        *(_BYTE *)(v34 + dword_10254430) = v36;
        *(_DWORD *)(v34 + dword_10254430 + 4) = *(_DWORD *)(v41 + 20 * *(_WORD *)(a3 + 8 * a5) + 12);
        sub_10006670(a5, v36);
        return v36;
      }
    }
    else
    {
      qmemcpy(&v44, (const void *)(v7 + 160 * (unsigned __int16)(v10 - v11)), 0x9Cu);
    }
    if ( !(v46 & 2) )
    {
      v12 = 6916 * (unsigned __int8)byte_1010A92C;
      *(_BYTE *)(dword_1025443C + 4 * (1729 * (unsigned __int8)byte_1010A92C + *(_BYTE *)(v12 + dword_1025443C + 2)) + 20) = v36;
      *(_BYTE *)(v12 + *(_BYTE *)(v12 + dword_1025443C + 2) + dword_1025443C + 420) = 0;
      v13 = dword_1025443C;
      word_1010C4C8[*(_BYTE *)(v12 + dword_1025443C + 2)] = a5;
      strncpy((char *)(v12 + 21 * *(_BYTE *)(v12 + v13 + 2) + v13 + 520), &v45, 0x15u);
      v14 = (unsigned __int8)byte_1010A92C;
      v15 = 6916 * (unsigned __int8)byte_1010A92C;
      *(_BYTE *)(v15 + 21 * *(_BYTE *)(v15 + dword_1025443C + 2) + dword_1025443C + 540) = 0;
      *(_BYTE *)(v15 + *(_BYTE *)(v15 + dword_1025443C + 2) + dword_1025443C + 3120) = v36;
      *(_BYTE *)(v15 + *(_BYTE *)(v15 + dword_1025443C + 2) + dword_1025443C + 2620) = 0;
      *(_DWORD *)(dword_1025443C + 4 * (1729 * v14 + *(_BYTE *)(v15 + dword_1025443C + 2)) + 2720) = 1;
      *(_WORD *)(dword_1025443C + 2 * (3458 * v14 + (*(_BYTE *)(v15 + dword_1025443C + 2))++) + 3220) = *(_WORD *)(a3 + 8 * a5);
    }
    goto LABEL_55;
  }
  return 0;
}
// 1006DAA0: using guessed type __int16 word_1006DAA0[];
// 1006DAA2: using guessed type __int16 word_1006DAA2[];
// 1010A92C: using guessed type char byte_1010A92C;
// 1010A92E: using guessed type char byte_1010A92E;
// 1010C4C8: using guessed type __int16 word_1010C4C8[];
// 1011D4B8: using guessed type int dword_1011D4B8[];
// 10254430: using guessed type int dword_10254430;
// 1025443C: using guessed type int dword_1025443C;

//----- (10007580) --------------------------------------------------------
char __usercall sub_10007580@<al>(unsigned __int16 a1@<ax>, char a2@<dl>, int a3@<ecx>, int a4)
{
  char v4; // bl@1
  signed __int64 v5; // rax@1
  signed __int64 v6; // rt2@1
  __int16 v7; // cx@1
  unsigned __int16 v8; // ax@1
  unsigned __int16 v9; // si@1
  unsigned int v10; // eax@6

  v4 = a2;
  v5 = *(_WORD *)(160 * a1 + a3) - 1000;
  v6 = v5 % 100;
  v7 = v5 / 100;
  v8 = dword_1010C3C4;
  LOWORD(dword_1010C3C4) = v7;
  v9 = v6;
  if ( v7 == v8 && byte_1010A92D )
    goto LABEL_11;
  if ( v8 != -1 && byte_1010A92D )
    sub_10006A70(v8, (int)byte_1010C0A0);
  LOBYTE(v10) = sub_100065E0(dword_1010C3C4, (int)byte_1010C0A0);
  byte_1010A92D = v10;
  if ( (_BYTE)v10 )
  {
LABEL_11:
    v10 = 8 * v9;
    byte_1010C0A0[v10] = v4;
    dword_1010C0A4[v10 / 4] = v4 != 3 ? a4 : 0;
  }
  return v10;
}
// 1010A92D: using guessed type char byte_1010A92D;
// 1010C0A4: using guessed type int dword_1010C0A4[];
// 1010C3C4: using guessed type int dword_1010C3C4;

//----- (10007620) --------------------------------------------------------
char __cdecl sub_10007620(int a1, int a2, unsigned __int8 a3, unsigned __int16 a4, char a5)
{
  char v5; // cl@1
  char v6; // dl@3
  int v7; // eax@5
  int v8; // ecx@6
  int v9; // edi@6
  char v10; // al@7
  char *v11; // ecx@21
  char v13; // [sp+Bh] [bp-5h]@1
  char v14; // [sp+Ch] [bp-4h]@3

  v5 = a5;
  v13 = 0;
  if ( a5 == 1 || a5 == 2 )
  {
    v14 = 1;
    v6 = 1;
  }
  else
  {
    v6 = 0;
    v14 = 0;
  }
  v7 = a2;
  if ( (_WORD)a2 != -1 )
  {
    do
    {
      v8 = *(_DWORD *)(a1 + 8);
      v9 = (unsigned __int16)v7;
      if ( *(_WORD *)(v8 + 8 * (unsigned __int16)v7 + 2) == -1 )
      {
        v10 = sub_10006F40(
                *(_DWORD *)(a1 + 12),
                *(_DWORD *)a1,
                v8,
                *(_WORD *)(a1 + 4),
                v7,
                *(_DWORD *)(a1 + 16),
                *(_BYTE *)(a1 + 20));
      }
      else if ( a3 >= 0x64u )
      {
        sub_10011520("..\\lib\\adl\\mon_cas.c", 1866, 0, "Exceeded recursion depth limit in get_node_value()");
        v10 = 2;
      }
      else
      {
        v10 = sub_10007620(
                a1,
                *(_WORD *)(v8 + 8 * (unsigned __int16)v7 + 2),
                a3 + 1,
                v7,
                *(_BYTE *)(v8 + 8 * (unsigned __int16)v7 + 6));
      }
      switch ( a5 )
      {
        case 1:
        case 2:
          if ( v10 == 2 )
            v13 = 1;
          else
            v14 &= v10;
          break;
        case 3:
        case 4:
          if ( v10 == 2 )
            v13 = 1;
          else
            v14 |= v10;
          break;
        case 5:
        case 6:
          if ( v10 == 2 )
            v13 = 1;
          else
            v14 ^= v10;
          break;
        case 9:
          v11 = (char *)(dword_10254430 + 12 * v9 + 1);
          if ( *v11 == 1 && v10 != 1 )
            v14 = 1;
          goto LABEL_24;
        case 0xA:
          v11 = (char *)(dword_10254430 + 12 * v9 + 1);
          if ( *v11 == 1 || v10 != 1 )
          {
LABEL_24:
            *v11 = v10;
          }
          else
          {
            v14 = 1;
            *v11 = 1;
          }
          break;
        case 7:
          if ( v10 == 2 )
            v14 = 2;
          else
            v14 = v10 == 0;
          break;
        default:
          v14 = v10;
          break;
      }
      v7 = *(_WORD *)(*(_DWORD *)(a1 + 8) + 8 * v9 + 4);
    }
    while ( (_WORD)v7 != -1 );
    v6 = v14;
    v5 = a5;
  }
  switch ( v5 )
  {
    case 1:
    case 2:
      if ( v13 && v6 == 1 )
      {
        v14 = 2;
        v6 = 2;
      }
      if ( v5 == 2 && v6 != 2 )
      {
        v14 = v6 == 0;
        goto LABEL_52;
      }
      break;
    case 3:
    case 4:
      if ( v13 && !v6 )
      {
        v14 = 2;
        v6 = 2;
      }
      if ( v5 == 4 && v6 != 2 )
      {
        v14 = v6 == 0;
        goto LABEL_52;
      }
      break;
    case 5:
    case 6:
      if ( v13 )
      {
        v14 = 2;
        v6 = 2;
      }
      if ( v5 == 6 && v6 != 2 )
      {
        v14 = v6 == 0;
LABEL_52:
        v6 = v14;
      }
      break;
    default:
      break;
  }
  *(_BYTE *)(dword_10254430 + 12 * a4) = v6;
  sub_10006670(a4, v14);
  return v14;
}
// 10254430: using guessed type int dword_10254430;

//----- (10007890) --------------------------------------------------------
int __usercall sub_10007890@<eax>(int a1@<edi>, int a2, int a3, int a4, char a5, __int16 a6, _BYTE *a7, _BYTE *a8, _BYTE *a9, _BYTE *a10)
{
  _BYTE *v10; // ebx@1
  int result; // eax@1
  int v12; // esi@2
  char v13; // cl@2
  unsigned __int16 v14; // ST0C_2@5
  int v15; // eax@5
  char v16; // al@5
  int v17; // [sp+8h] [bp-18h]@5
  __int16 v18; // [sp+Ch] [bp-14h]@5
  int v19; // [sp+10h] [bp-10h]@5
  int v20; // [sp+14h] [bp-Ch]@5
  int v21; // [sp+18h] [bp-8h]@5
  char v22; // [sp+1Ch] [bp-4h]@5

  *a7 = 0;
  v10 = a8;
  *a10 = 0;
  *a9 = 0;
  *a8 = 0;
  for ( result = *(_WORD *)(a1 + 8 * *(_WORD *)(160 * (unsigned __int16)a6 + a2 + 156) + 4);
        (_WORD)result != -1;
        result = *(_WORD *)(v12 + 4) )
  {
    v12 = a1 + 8 * (unsigned __int16)result;
    v13 = *(_BYTE *)(v12 + 6);
    if ( v13 == 12 || v13 == 17 || *(_WORD *)v12 != -1 )
    {
      v16 = sub_10006F40(a3, a2, a1, a6, result, a4, a5);
      v10 = a8;
    }
    else
    {
      v17 = a2;
      v14 = result;
      v15 = *(_WORD *)(v12 + 2);
      v20 = a3;
      v21 = a4;
      v18 = a6;
      v19 = a1;
      v22 = a5;
      v16 = sub_10007620((int)&v17, v15, 1u, v14, v13);
    }
    if ( v16 == 1 )
    {
      switch ( *(_BYTE *)(v12 + 6) )
      {
        case 8:
          *a7 |= 0x20u;
          break;
        case 0xB:
          *v10 = 1;
          break;
        case 0xF:
          *v10 = 1;
          *a9 = 1;
          break;
        case 0xC:
          *a10 = 1;
          break;
        default:
          continue;
      }
    }
  }
  return result;
}

//----- (100079D0) --------------------------------------------------------
char __cdecl sub_100079D0(int a1, signed __int16 a2, int a3, int a4, int a5, int a6)
{
  char result; // al@1
  void *v7; // ecx@7
  _WORD *v8; // esi@10
  int v9; // edi@10
  signed __int16 v10; // ax@17
  signed __int16 v11; // ax@24
  unsigned __int16 *v12; // ebp@27
  unsigned int v13; // eax@28
  signed int v14; // eax@31
  __int16 v15; // si@33
  int v16; // ebx@33
  int v17; // edi@33
  char v18; // al@34
  unsigned __int16 v19; // ax@35
  char v20; // bl@36
  char v21; // al@40
  unsigned int v22; // eax@60
  unsigned __int16 *v23; // ecx@60
  char *v24; // edx@60
  int v25; // esi@64
  int v26; // eax@65
  _BYTE *v27; // ecx@65
  _BYTE *v28; // edx@65
  int v29; // eax@67
  _BYTE *v30; // ecx@67
  _BYTE *v31; // edx@67
  _BYTE *v32; // ecx@69
  _BYTE *v33; // edx@69
  signed int v34; // eax@71
  char v35; // al@82
  unsigned __int16 v36; // cx@82
  char v37; // [sp+8h] [bp-130h]@33
  char v38; // [sp+9h] [bp-12Fh]@33
  char v39; // [sp+Ah] [bp-12Eh]@33
  char v40; // [sp+Bh] [bp-12Dh]@33
  unsigned int v41; // [sp+Ch] [bp-12Ch]@27
  int v42; // [sp+10h] [bp-128h]@1
  int v43; // [sp+14h] [bp-124h]@27
  int v44; // [sp+18h] [bp-120h]@33
  unsigned int v45; // [sp+1Ch] [bp-11Ch]@1
  unsigned int v46; // [sp+20h] [bp-118h]@3
  int v47; // [sp+24h] [bp-114h]@36
  int v48; // [sp+28h] [bp-110h]@53
  int v49; // [sp+2Ch] [bp-10Ch]@33
  int v50; // [sp+30h] [bp-108h]@1
  int v51; // [sp+34h] [bp-104h]@1
  int v52; // [sp+38h] [bp-100h]@82
  int v53; // [sp+3Ch] [bp-FCh]@1
  int v54; // [sp+40h] [bp-F8h]@1
  int v55; // [sp+44h] [bp-F4h]@35
  __int16 v56; // [sp+48h] [bp-F0h]@35
  int v57; // [sp+4Ch] [bp-ECh]@35
  int v58; // [sp+50h] [bp-E8h]@35
  int v59; // [sp+54h] [bp-E4h]@35
  char v60; // [sp+58h] [bp-E0h]@35
  char v61; // [sp+5Ch] [bp-DCh]@33
  char v62; // [sp+F8h] [bp-40h]@1
  char v63; // [sp+114h] [bp-24h]@9
  int v64; // [sp+140h] [bp+8h]@20

  v42 = a1;
  v53 = a3;
  v51 = a4;
  v50 = a5;
  v45 = sub_10032ED0();
  memset(dword_1011D4B8, 0, 0xBCu);
  sub_10019CF0(&v62);
  v54 = 0;
  result = sub_1000BB20(30000);
  if ( result )
    return result;
  if ( (_BYTE)a6 == 1 )
  {
    if ( !sub_10032DC0(9373, &v46, 4, &v54) && v46 < 0x96 )
    {
      ++v46;
      sub_10032BB0(9373, (int)&v46, 4);
    }
LABEL_7:
    result = sub_1000BC60();
    if ( result || (result = sub_1000BC20(v7), result == 4) && !v63 )
    {
      v8 = (_WORD *)a1;
      v9 = (unsigned __int16)(a2 + 1);
      do
      {
        if ( *v8 != -1 )
        {
          result = sub_1000BFF0((int)v8);
          if ( result )
          {
            sub_1000C4F0(255, *v8, 5);
            result = sub_1000C540(*v8);
          }
        }
        v8 += 80;
        --v9;
      }
      while ( v9 );
      return result;
    }
    goto LABEL_16;
  }
  if ( (_BYTE)a6 != 2 )
    goto LABEL_7;
LABEL_16:
  if ( (_BYTE)a6 )
  {
    v10 = a2;
    if ( (unsigned __int8)a6 == 1 )
    {
      if ( (unsigned __int16)a2 >= 0x3E8u )
        v10 = 1000;
      v64 = (unsigned __int16)v10;
    }
    else
    {
      if ( (unsigned __int16)a2 >= 0x1F4u )
        v10 = 500;
      v64 = (unsigned __int16)v10;
    }
  }
  else
  {
    v11 = a2;
    if ( (unsigned __int16)a2 >= 0x3E8u )
      v11 = 1000;
    v64 = (unsigned __int16)v11;
  }
  LOWORD(dword_1010C3C4) = -1;
  byte_1010A92D = 1;
  v41 = 0;
  v43 = 0;
  v12 = (unsigned __int16 *)(a1 + 156);
  do
  {
    v13 = *(_DWORD *)(v43 + dword_10254438 + 8);
    if ( v13 == -1 || v45 < v13 || *(v12 - 78) == 2300 )
      goto LABEL_100;
    v14 = *((_DWORD *)v12 - 7);
    if ( !v14 )
      v14 = 1000;
    qmemcpy(&v61, v12 - 78, 0x9Cu);
    *(_DWORD *)(v43 + dword_10254438 + 8) = v14 + v45 - 100;
    LOBYTE(v44) = 0;
    v40 = 0;
    v39 = 0;
    LOBYTE(v49) = 0;
    memset((void *)(dword_1025443C + 6916 * (unsigned __int8)byte_1010A92C), 0, 0x1B04u);
    v15 = v41;
    v16 = v42;
    v17 = v53;
    v38 = *(_BYTE *)(dword_10254430 + 12 * *v12);
    v37 = 0;
    byte_1010A92E = 0;
    sub_10007890(v53, v42, v51, v50, a6, v41, &v44, &v49, &v39, &v40);
    if ( *(_WORD *)(v17 + 8 * *v12 + 2) == -1 )
    {
      v18 = sub_10006F40(v51, v42, v17, v15, *v12, v50, a6);
    }
    else
    {
      v58 = v51;
      v19 = *v12;
      v59 = v50;
      v55 = v16;
      v56 = v15;
      v57 = v17;
      v60 = a6;
      v18 = sub_10007620((int)&v55, *(_WORD *)(v17 + 8 * v19 + 2), 1u, v19, *(_BYTE *)(v17 + 8 * v19 + 6));
    }
    v20 = v18;
    LOBYTE(v47) = v18;
    if ( (_BYTE)a6 == 1 )
      sub_10006620(v18, v41);
    if ( *((_DWORD *)v12 - 4) || *((_DWORD *)v12 - 3) )
    {
      v21 = sub_100066F0(v42, v41, v38, v45, v47, &v47);
      v20 = v47;
    }
    else
    {
      v21 = 0;
    }
    if ( (_BYTE)a6 != 1 && (_BYTE)a6 != 2 )
      v21 = 0;
    if ( v20 == 1 && v38 != 1 )
      ++*(_DWORD *)(v43 + dword_10254438 + 12);
    if ( v21 )
      sub_10007580(v41, v21, v42, v45);
    if ( v40 )
    {
      if ( v20 == 2 )
      {
        v20 = 0;
        *(_BYTE *)(dword_10254430 + 12 * *v12) = 0;
      }
LABEL_53:
      LOBYTE(v48) = 0;
      goto LABEL_76;
    }
    if ( v20 != 1 && (v20 != 2 || !(*((_BYTE *)v12 - 4) & 1)) )
      goto LABEL_53;
    LOBYTE(v48) = 1;
    if ( !(_BYTE)v49 )
    {
      if ( sub_1000C080(*(v12 - 78)) )
      {
        v22 = 156;
        v23 = v12 - 78;
        v24 = &v61;
        do
        {
          if ( *(_DWORD *)v24 != *(_DWORD *)v23 )
            goto LABEL_64;
          v22 -= 4;
          v23 += 2;
          v24 += 4;
        }
        while ( v22 >= 4 );
        if ( !v22 )
        {
LABEL_73:
          v34 = 0;
          goto LABEL_74;
        }
LABEL_64:
        v25 = (unsigned __int8)*v24 - *(_BYTE *)v23;
        if ( (unsigned __int8)*v24 == *(_BYTE *)v23 )
        {
          v26 = v22 - 1;
          v27 = (char *)v23 + 1;
          v28 = v24 + 1;
          if ( !v26 )
            goto LABEL_73;
          v25 = *v28 - *v27;
          if ( *v28 == *v27 )
          {
            v29 = v26 - 1;
            v30 = v27 + 1;
            v31 = v28 + 1;
            if ( !v29 )
              goto LABEL_73;
            v25 = *v31 - *v30;
            if ( *v31 == *v30 )
            {
              v32 = v30 + 1;
              v33 = v31 + 1;
              if ( v29 == 1 )
                goto LABEL_73;
              v25 = *v33 - *v32;
              if ( *v33 == *v32 )
                goto LABEL_73;
            }
          }
        }
        v34 = 1;
        if ( v25 <= 0 )
          v34 = -1;
LABEL_74:
        if ( v34 )
        {
          sub_1000C540(*(v12 - 78));
          sub_10006480(v12 - 78, v44);
          v37 = 1;
        }
      }
      else
      {
        sub_10006480(v12 - 78, v44);
      }
    }
LABEL_76:
    if ( (_BYTE)v44 )
      sub_1000C4F0(255, *(v12 - 78), 5);
    if ( !(_BYTE)v48 && !v39 && sub_1000C080(*(v12 - 78)) )
      sub_1000C0E0(*(v12 - 78), 0, 0);
    v35 = sub_1000C080(*(v12 - 78));
    v36 = *(v12 - 9);
    LOBYTE(v52) = v35;
    if ( v36 )
    {
      if ( *((_BYTE *)v12 - 4) & 8 && v35 )
        LOBYTE(v52) = 2;
      sub_10018840(v36, v52);
    }
    if ( v20 == v38 )
      goto LABEL_95;
    v37 = 1;
    if ( v20 == 2 )
    {
      if ( v38 == 1 )
        goto LABEL_93;
    }
    else if ( v20 == 1 && v38 == 2 )
    {
LABEL_93:
      if ( *((_BYTE *)v12 - 4) & 1 )
        v37 = 0;
      goto LABEL_95;
    }
LABEL_95:
    if ( (_BYTE)v48 && *((_BYTE *)v12 - 29) & 0x80 || v37 == 1 )
    {
      sub_10006530(v41, v42, v48, v49, a6);
      if ( (unsigned __int8)++byte_1010A92C >= 0xAu )
        byte_1010A92C = 0;
    }
LABEL_100:
    v43 += 16;
    v12 += 80;
    ++v41;
  }
  while ( (unsigned __int16)v41 <= (unsigned __int16)v64 );
  if ( (_WORD)dword_1010C3C4 != -1 && byte_1010A92D )
    sub_10006A70(dword_1010C3C4, (int)byte_1010C0A0);
  return sub_1000C110(a6);
}
// 1010A92C: using guessed type char byte_1010A92C;
// 1010A92D: using guessed type char byte_1010A92D;
// 1010A92E: using guessed type char byte_1010A92E;
// 1010C3C4: using guessed type int dword_1010C3C4;
// 1011D4B8: using guessed type int dword_1011D4B8[];
// 10254430: using guessed type int dword_10254430;
// 10254438: using guessed type int dword_10254438;
// 1025443C: using guessed type int dword_1025443C;

//----- (10008040) --------------------------------------------------------
int sub_10008040()
{
  return sub_10032FB0(37, 16);
}

//----- (10008050) --------------------------------------------------------
int sub_10008050()
{
  char v1; // [sp+1h] [bp-1h]@1

  v1 = 0;
  *(_DWORD *)dword_10254440 = 0;
  *(_BYTE *)(dword_102543FC + 28) = -1;
  *(_BYTE *)(dword_102543FC + 29) = -1;
  *(_BYTE *)(dword_102543FC + 30) = -1;
  *(_BYTE *)(dword_102543FC + 31) = -1;
  *(_BYTE *)(dword_102543FC + 32) = -1;
  *(_BYTE *)(dword_102543FC + 33) = -1;
  *(_BYTE *)(dword_102543FC + 16) = 0;
  *(_BYTE *)(dword_102543FC + 18) = 0;
  *(_BYTE *)(dword_102543FC + 17) = 0;
  *(_BYTE *)(dword_10254440 + 306372) = 7;
  sub_10032BB0(10007, (int)&v1, 1);
  sub_10032BB0(10008, (int)&v1, 1);
  return sub_10002920();
}
// 102543FC: using guessed type int dword_102543FC;
// 10254440: using guessed type int dword_10254440;

//----- (100080F0) --------------------------------------------------------
signed int sub_100080F0()
{
  sub_1000B5F0();
  dword_102543FC = -15;
  sub_100336C0((LONG)&off_10059260);
  sub_10006300(1);
  dword_102543FC = dword_10254440;
  if ( (unsigned int)dword_10254440 >= 0xFFFFFFC2 || !dword_10254440 )
    sub_10011520("..\\lib\\adl\\mon_init.c", 175, 1, 0);
  sub_10008270();
  sub_10008050();
  return sub_10033250((int)&off_10059260);
}
// 10059260: using guessed type char *off_10059260;
// 102543FC: using guessed type int dword_102543FC;
// 10254440: using guessed type int dword_10254440;

//----- (10008160) --------------------------------------------------------
char __fastcall sub_10008160(void *a1)
{
  int v1; // ebx@1
  void *v2; // ecx@1
  char result; // al@1
  void *v4; // [sp-2h] [bp-4h]@1

  v4 = a1;
  v1 = sub_100122C0(a1);
  BYTE3(v4) = 0;
  sub_10032B40(9187, (char *)&v4 + 2, 1, (char *)&v4 + 3);
  result = sub_1000BC40(v2);
  if ( result != 1 && (v1 == 1 || v1 == 2) && (BYTE2(v4) & (unsigned __int8)v1) == (_BYTE)v1 )
  {
    BYTE2(v4) &= ~(_BYTE)v1;
    result = sub_10032BB0(9187, (int)&v4 + 2, 1);
  }
  return result;
}

//----- (100081D0) --------------------------------------------------------
int sub_100081D0()
{
  char v0; // bl@1
  int result; // eax@8
  char v2; // [sp+7h] [bp-9h]@1
  float v3; // [sp+8h] [bp-8h]@1
  char v4; // [sp+Ch] [bp-4h]@1

  v0 = sub_10013270(&v3);
  sub_10013750((bool *)&v2);
  if ( sub_10013210(&v4)
    && (!v2 && *(_BYTE *)(dword_102543FC + 35) || v0 && v3 >= 25.72222222222222 && flt_1011D578 < 25.72222222222222) )
  {
    sub_10032BB0(2103, (int)&v4, 4);
  }
  result = dword_102543FC;
  *(_BYTE *)(dword_102543FC + 35) = v2;
  if ( v0 )
    flt_1011D578 = v3;
  return result;
}
// 1011D578: using guessed type float flt_1011D578;
// 102543FC: using guessed type int dword_102543FC;

//----- (10008270) --------------------------------------------------------
int sub_10008270()
{
  char v0; // ST0B_1@1
  char v1; // ST0B_1@2
  char v2; // al@2
  char v3; // al@8
  void *v4; // ecx@10
  void *v5; // ecx@10
  int result; // eax@10

  v0 = sub_1001A3B0(4);
  if ( (unsigned __int8)v0 & (unsigned __int8)sub_1001A3B0(3)
    || (v1 = sub_1001A3B0(32), v2 = sub_1001A3B0(31), byte_1011D57C = 0, (unsigned __int8)v1 & (unsigned __int8)v2) )
  {
    byte_1011D57C = 1;
  }
  if ( sub_1001A3B0(1) && sub_1001A3B0(2)
    || sub_1001A3B0(43) && sub_1001A3B0(44)
    || (v3 = sub_10019D20(), byte_1011D57D = 0, v3) )
  {
    byte_1011D57D = 1;
  }
  byte_1011D57E = sub_10018A30();
  dword_1011D580 = sub_1000BC00(v4);
  result = sub_100122C0(v5);
  dword_1011D584 = result;
  return result;
}
// 1011D57C: using guessed type char byte_1011D57C;
// 1011D57D: using guessed type char byte_1011D57D;
// 1011D57E: using guessed type char byte_1011D57E;
// 1011D580: using guessed type int dword_1011D580;
// 1011D584: using guessed type int dword_1011D584;

//----- (10008330) --------------------------------------------------------
void sub_10008330()
{
  char v0; // al@1
  void *v1; // ecx@1
  char v2; // di@4
  char v3; // al@5
  unsigned __int8 v4; // bl@5
  char v5; // al@8
  unsigned __int8 v6; // bl@8
  unsigned __int8 v7; // bl@11
  char v8; // al@13
  bool v9; // bl@14
  int v10; // ecx@22
  char v11; // al@23
  int v12; // esi@23
  bool v13; // zf@24
  int v14; // eax@28
  signed int v15; // esi@28
  char v16; // dl@31
  char v17; // al@48
  unsigned __int8 v18; // bl@48
  char v19; // al@51
  unsigned __int8 v20; // bl@51
  unsigned __int8 v21; // bl@54
  char v22; // al@56
  bool v23; // bl@57
  int v24; // ecx@65
  char v25; // al@66
  int v26; // esi@66
  int v27; // eax@73
  signed int v28; // esi@73
  char v29; // dl@76
  char v30; // [sp+1h] [bp-1Fh]@4
  char v31; // [sp+1h] [bp-1Fh]@47
  char v32; // [sp+2h] [bp-1Eh]@1
  char v33; // [sp+3h] [bp-1Dh]@1
  __int16 v34; // [sp+4h] [bp-1Ch]@1
  char v35; // [sp+6h] [bp-1Ah]@1
  __int16 v36; // [sp+8h] [bp-18h]@1
  char v37; // [sp+Ah] [bp-16h]@1
  float v38; // [sp+Ch] [bp-14h]@1
  int v39; // [sp+10h] [bp-10h]@2
  int v40; // [sp+14h] [bp-Ch]@24
  char v41; // [sp+18h] [bp-8h]@7

  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v0 = sub_10013750((bool *)&v33);
  v38 = 9.8999998e24;
  v32 = v0;
  if ( !sub_1000BB20(30000) )
  {
    LOBYTE(v39) = sub_1001A5F0(v1);
    if ( !sub_10014890(&v38) )
      v38 = 9.8999998e24;
    v2 = v39;
    v30 = sub_1001A570(v39, 0);
    if ( byte_1011D57C )
    {
      v3 = v34;
      v4 = 0;
      do
      {
        if ( v3 )
          break;
        v3 = sub_10012930((unsigned __int8)byte_10059A98[v4++], &v41);
        LOBYTE(v34) = v3;
      }
      while ( v4 < 0xBu );
      v5 = HIBYTE(v34);
      v6 = 0;
      do
      {
        if ( v5 )
          break;
        v5 = sub_10012950((unsigned __int8)byte_10059A98[v6++], &v41);
        HIBYTE(v34) = v5;
      }
      while ( v6 < 0xBu );
      v7 = 0;
      do
      {
        if ( v35 )
          break;
        v8 = sub_10012970((unsigned __int8)byte_10059A98[v7++], &v41);
        v35 = v8;
      }
      while ( v7 < 0xBu );
      v9 = 0;
      if ( v32
        && (!v33 || v38 != 9.8999998e24 && *(float *)(dword_10254424 + 29368) < (double)v38)
        && (unsigned __int8)v30 < 3u
        && (!(_BYTE)v39 || (_BYTE)v39 == 1)
        && !*((_BYTE *)&v34 + (unsigned __int8)v30) )
      {
        v10 = dword_102543FC;
        if ( *(_BYTE *)((unsigned __int8)v30 + dword_102543FC + 28) < 1 )
        {
LABEL_28:
          v14 = 0;
          v15 = 3;
          while ( !*((_BYTE *)&v34 + v14) )
          {
            v16 = *(_BYTE *)(v14 + v10 + 28);
            if ( v16 < 1 && v16 > -1 )
            {
              ++*(_BYTE *)(v14 + v10 + 28);
              goto LABEL_36;
            }
            if ( !v9 )
            {
              *(_BYTE *)(v14 + v10 + 28) = -1;
              goto LABEL_36;
            }
LABEL_37:
            ++v14;
            if ( !--v15 )
              goto LABEL_40;
          }
          *(_BYTE *)(v14 + v10 + 28) = 0;
LABEL_36:
          v10 = dword_102543FC;
          goto LABEL_37;
        }
        v11 = 0;
        v12 = 3 * (unsigned __int8)v39;
        do
        {
          v13 = *((_BYTE *)&v34 + (unsigned __int8)*(&byte_10059AB0[(unsigned __int8)v11] + v12)) == 0;
          LOBYTE(v40) = *(&byte_10059AB0[(unsigned __int8)v11] + v12);
          if ( !v13 )
          {
            v13 = v30 == sub_1001A590(0, v40);
            v11 = 3;
            v9 = v13;
          }
          ++v11;
        }
        while ( (unsigned __int8)v11 < 3u );
      }
      v10 = dword_102543FC;
      goto LABEL_28;
    }
    v10 = dword_102543FC;
LABEL_40:
    *(_BYTE *)(v10 + 36) = v30 == 2
                        || !v34
                        && (v32 && !v33 || v38 != 9.8999998e24 && *(float *)(dword_10254424 + 29368) < (double)v38);
    v31 = sub_1001A570(v2, 1);
    if ( byte_1011D57D )
    {
      v17 = v36;
      v18 = 0;
      do
      {
        if ( v17 )
          break;
        v17 = sub_10012930((unsigned __int8)byte_10059AA4[v18++], &v41);
        LOBYTE(v36) = v17;
      }
      while ( v18 < 0xAu );
      v19 = HIBYTE(v36);
      v20 = 0;
      do
      {
        if ( v19 )
          break;
        v19 = sub_10012950((unsigned __int8)byte_10059AA4[v20++], &v41);
        HIBYTE(v36) = v19;
      }
      while ( v20 < 0xAu );
      v21 = 0;
      do
      {
        if ( v37 )
          break;
        v22 = sub_10012970((unsigned __int8)byte_10059AA4[v21++], &v41);
        v37 = v22;
      }
      while ( v21 < 0xAu );
      v23 = 0;
      if ( v32
        && (!v33 || v38 != 9.8999998e24 && *(float *)(dword_10254424 + 29368) < (double)v38)
        && (unsigned __int8)v31 < 3u
        && (!(_BYTE)v39 || (_BYTE)v39 == 1)
        && !*((_BYTE *)&v36 + (unsigned __int8)v31) )
      {
        v24 = dword_102543FC;
        if ( *(_BYTE *)((unsigned __int8)v31 + dword_102543FC + 31) < 1 )
        {
LABEL_73:
          v27 = 0;
          v28 = 3;
          while ( !*((_BYTE *)&v36 + v27) )
          {
            v29 = *(_BYTE *)(v27 + v24 + 31);
            if ( v29 < 1 && v29 > -1 )
            {
              ++*(_BYTE *)(v27 + v24 + 31);
              goto LABEL_81;
            }
            if ( !v23 )
            {
              *(_BYTE *)(v27 + v24 + 31) = -1;
              goto LABEL_81;
            }
LABEL_82:
            ++v27;
            if ( !--v28 )
              goto LABEL_85;
          }
          *(_BYTE *)(v27 + v24 + 31) = 0;
LABEL_81:
          v24 = dword_102543FC;
          goto LABEL_82;
        }
        v25 = 0;
        v26 = 3 * (unsigned __int8)v39;
        do
        {
          v13 = *((_BYTE *)&v36 + (unsigned __int8)*(&byte_10059AB0[(unsigned __int8)v25] + v26)) == 0;
          LOBYTE(v40) = *(&byte_10059AB0[(unsigned __int8)v25] + v26);
          if ( !v13 )
          {
            v13 = v31 == sub_1001A590(1, v40);
            v25 = 3;
            v23 = v13;
          }
          ++v25;
        }
        while ( (unsigned __int8)v25 < 3u );
      }
      v24 = dword_102543FC;
      goto LABEL_73;
    }
    v24 = dword_102543FC;
LABEL_85:
    *(_BYTE *)(v24 + 37) = v31 == 2
                        || !v36
                        && (v32 && !v33 || v38 != 9.8999998e24 && *(float *)(dword_10254424 + 29368) < (double)v38);
  }
}
// 1011D57C: using guessed type char byte_1011D57C;
// 1011D57D: using guessed type char byte_1011D57D;
// 102543FC: using guessed type int dword_102543FC;
// 10254424: using guessed type int dword_10254424;

//----- (100087D0) --------------------------------------------------------
int __usercall sub_100087D0@<eax>(int result@<eax>, float a2, float a3, float a4)
{
  int v4; // esi@2
  bool v5; // al@3
  double v6; // st7@6
  bool v7; // c0@7
  double v8; // st7@7
  double v9; // st4@8
  double v10; // st4@10
  float v11; // ST10_4@14
  double v12; // st7@14
  double v13; // st6@14
  bool v14; // c0@15
  bool v15; // c3@15
  char v16; // cl@17
  float v17; // [sp+20h] [bp+Ch]@3
  float v18; // [sp+20h] [bp+Ch]@4
  float v19; // [sp+20h] [bp+Ch]@5
  float v20; // [sp+20h] [bp+Ch]@14
  float v21; // [sp+20h] [bp+Ch]@20
  float v22; // [sp+20h] [bp+Ch]@21
  float v23; // [sp+20h] [bp+Ch]@22

  if ( LOBYTE(a4) )
  {
    v4 = (unsigned __int8)result;
    switch ( (unsigned __int8)result )
    {
      case 1u:
        v17 = *(float *)(dword_10254424 + 28420) * 0.01745329238474369;
        v5 = sub_10035D00(a2, a3, v17);
        goto LABEL_24;
      case 2u:
        v18 = *(float *)(dword_10254424 + 28448) * 0.01745329238474369;
        v5 = sub_10035D00(a2, a3, v18);
        goto LABEL_24;
      case 3u:
        v19 = *(float *)(dword_10254424 + 28444) * 0.01745329238474369;
        v5 = sub_10035D00(a2, a3, v19);
        goto LABEL_24;
      case 4u:
        v6 = *(float *)(dword_10254424 + 28424) * 0.5144444704055786;
        if ( a2 >= v6 )
        {
          v8 = a3;
        }
        else
        {
          v7 = a3 < v6;
          v8 = a3;
          if ( v7 )
          {
            v9 = *(float *)(dword_10254424 + 28432);
            goto LABEL_14;
          }
        }
        v10 = *(float *)(dword_10254424 + 28428) * 0.5144444704055786;
        if ( v10 <= a2 || v10 <= v8 )
          v9 = *(float *)(dword_10254424 + 28440);
        else
          v9 = *(float *)(dword_10254424 + 28436);
LABEL_14:
        v11 = 0.5144444704055786 * v9;
        v20 = a2 - v8;
        v12 = COERCE_FLOAT(LODWORD(v20) & 0x7FFFFFFF);
        v13 = v11;
LABEL_15:
        v14 = v13 < v12;
        v15 = v13 == v12;
LABEL_16:
        if ( v14 || v15 )
LABEL_17:
          v16 = 1;
        else
LABEL_25:
          v16 = 0;
        if ( v16 == *(_BYTE *)(v4 + dword_102543FC) )
          *(_BYTE *)(v4 + dword_102543FC + 8) = 0;
        else
          ++*(_BYTE *)(v4 + dword_102543FC + 8);
        result = dword_102543FC;
        if ( *(_BYTE *)(v4 + dword_102543FC + 8) >= (unsigned __int8)byte_10059ABC[v4] )
          *(_BYTE *)(v4 + dword_102543FC) = v16;
        break;
      case 5u:
        v21 = a2 - a3;
        v12 = COERCE_FLOAT(LODWORD(v21) & 0x7FFFFFFF);
        v13 = *(float *)(dword_10254424 + 28416) * 0.3048000037670135;
        goto LABEL_15;
      case 6u:
        v22 = a2 - a3;
        v12 = COERCE_FLOAT(LODWORD(v22) & 0x7FFFFFFF);
        v13 = *(float *)(dword_10254424 + 28452) * 0.3048000037670135;
        goto LABEL_15;
      case 0u:
        v23 = (a2 - a3) * 0.000295300007564947;
        LODWORD(v23) &= 0x7FFFFFFFu;
        v14 = 0.0049999999 < v23;
        v15 = 0.0049999999 == v23;
        goto LABEL_16;
      default:
        v5 = LOBYTE(a4);
LABEL_24:
        if ( v5 )
          goto LABEL_25;
        goto LABEL_17;
    }
  }
  else
  {
    result = (unsigned __int8)result;
    *(_BYTE *)((unsigned __int8)result + dword_102543FC) = 2;
  }
  return result;
}
// 102543FC: using guessed type int dword_102543FC;
// 10254424: using guessed type int dword_10254424;

//----- (10008A30) --------------------------------------------------------
BOOL sub_10008A30()
{
  return dword_1011D584 == 2 || sub_10009830();
}
// 1011D584: using guessed type int dword_1011D584;

//----- (10008A50) --------------------------------------------------------
bool sub_10008A50()
{
  return (dword_1011D580 & 3) == 3;
}
// 1011D580: using guessed type int dword_1011D580;

//----- (10008A70) --------------------------------------------------------
BOOL sub_10008A70()
{
  int v0; // eax@1

  v0 = dword_1011D580 & (dword_1011D584 | j_HWM_pvg_hsdb_get_lrus_online());
  return (v0 & 3) == 3 || sub_10009840(v0);
}
// 100331B0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 1011D580: using guessed type int dword_1011D580;
// 1011D584: using guessed type int dword_1011D584;

//----- (10008AB0) --------------------------------------------------------
char sub_10008AB0()
{
  bool v0; // bl@3
  float v1; // ST0C_4@10
  double v2; // st7@10
  int v3; // eax@10
  float v4; // ST08_4@10
  char result; // al@12
  int v6; // eax@14
  int v7; // eax@18
  char v8; // al@23
  int v9; // eax@23
  char v10; // al@24
  int v11; // eax@33
  int v12; // eax@37
  int v13; // eax@40
  char v14; // al@46
  int v15; // eax@48
  char v16; // al@49
  int v17; // eax@51
  char v18; // al@53
  int v19; // eax@55
  char v20; // al@58
  int v21; // eax@58
  char v22; // al@59
  int v23; // eax@61
  float v24; // [sp+8h] [bp-24h]@40
  char v25; // [sp+12h] [bp-1Ah]@1
  char v26; // [sp+13h] [bp-19h]@1
  float v27; // [sp+14h] [bp-18h]@16
  float v28; // [sp+18h] [bp-14h]@1
  float v29; // [sp+1Ch] [bp-10h]@1
  int v30; // [sp+20h] [bp-Ch]@1
  int v31; // [sp+24h] [bp-8h]@1
  char v32; // [sp+28h] [bp-4h]@1

  v29 = 0.0;
  v28 = 0.0;
  v30 = 0;
  v31 = 0;
  v25 = 0;
  v0 = sub_100349A0((float *)&v32, &v26) && v26 == 1;
  *(_BYTE *)(dword_102543FC + 7) = byte_1011D57E && (unsigned __int8)sub_10018990();
  if ( (unsigned __int8)sub_10008A70() )
  {
    v1 = sub_10018D20();
    v2 = sub_10018D10();
    LOBYTE(v3) = 0;
    v4 = v2;
    sub_100087D0(v3, v4, v1, COERCE_FLOAT(1));
  }
  else
  {
    *(_BYTE *)dword_102543FC = 0;
  }
  sub_10033160(84, &v25);
  result = sub_10008A50();
  if ( result && !v25 )
  {
    if ( !sub_100128E0(7, &v29) || !sub_10012890(7, &v28) || (v6 = sub_10008A70(), LOBYTE(v27) = 1, !(_BYTE)v6) )
      LOBYTE(v27) = 0;
    LOBYTE(v6) = 5;
    sub_100087D0(v6, v29, v28, v27);
    if ( !sub_100128E0(0, &v29) || !sub_10012890(0, &v28) || (v7 = sub_10008A70(), LOBYTE(v27) = 1, !(_BYTE)v7) )
      LOBYTE(v27) = 0;
    LOBYTE(v7) = 4;
    sub_100087D0(v7, v29, v28, v27);
    if ( v0 )
    {
      v8 = sub_1001A570(0, 0);
      if ( !sub_10013090(v8, &v29)
        || (v10 = sub_1001A570(1, 0), !sub_10013090(v10, &v28))
        || (v9 = sub_10008A70(), LOBYTE(v27) = 1, !(_BYTE)v9) )
      {
        LOBYTE(v27) = 0;
      }
      LOBYTE(v9) = 6;
      sub_100087D0(v9, v29, v28, v27);
    }
    else
    {
      *(_BYTE *)(dword_102543FC + 6) = 3;
    }
    if ( sub_100128E0(16, &v30) && sub_10012890(16, &v31) && (unsigned __int8)sub_10008A70() )
    {
      LOBYTE(v27) = 1;
      v29 = (double)v30 * 0.000000001462918079267163;
      v28 = 0.000000001462918079267163 * (double)v31;
    }
    else
    {
      LOBYTE(v27) = 0;
    }
    v11 = LODWORD(v27);
    LOBYTE(v11) = 1;
    sub_100087D0(v11, v29, v28, v27);
    if ( sub_100128E0(18, &v30) && sub_10012890(18, &v31) && (unsigned __int8)sub_10008A70() )
    {
      LOBYTE(v27) = 1;
      v29 = (double)v30 * 0.000000001462918079267163;
      v28 = 0.000000001462918079267163 * (double)v31;
    }
    else
    {
      LOBYTE(v27) = 0;
    }
    v12 = LODWORD(v27);
    LOBYTE(v12) = 3;
    sub_100087D0(v12, v29, v28, v27);
    if ( sub_100128E0(19, &v30) && sub_10012890(19, &v31) && (unsigned __int8)sub_10008A70() )
    {
      LOBYTE(v27) = 1;
      v13 = LODWORD(v27);
      v24 = v27;
      v29 = (double)v30 * 0.000000001462918079267163;
      v28 = 0.000000001462918079267163 * (double)v31;
    }
    else
    {
      LOBYTE(v27) = 0;
      v13 = LODWORD(v27);
      v24 = v27;
    }
    goto LABEL_68;
  }
  if ( byte_1011D57C )
  {
    if ( !sub_10012930(7, &v29) || (v14 = sub_10012950(7, &v28), LOBYTE(v27) = 1, !v14) )
      LOBYTE(v27) = 0;
    v15 = LODWORD(v27);
    LOBYTE(v15) = 5;
    sub_100087D0(v15, v29, v28, v27);
    if ( !sub_10012930(0, &v29) || (v16 = sub_10012950(0, &v28), LOBYTE(v27) = 1, !v16) )
      LOBYTE(v27) = 0;
    v17 = LODWORD(v27);
    LOBYTE(v17) = 4;
    result = sub_100087D0(v17, v29, v28, v27);
    if ( v0 )
    {
      if ( !sub_10013090(0, &v29) || (v18 = sub_10013090(1, &v28), LOBYTE(v27) = 1, !v18) )
        LOBYTE(v27) = 0;
      v19 = LODWORD(v27);
      LOBYTE(v19) = 6;
      result = sub_100087D0(v19, v29, v28, v27);
    }
    else
    {
      *(_BYTE *)(dword_102543FC + 6) = 3;
    }
  }
  if ( byte_1011D57D )
  {
    v20 = sub_10034560();
    if ( sub_1001A000(v20, &v30, 0) && (v22 = sub_10034560(), sub_1001A000(v22, &v31, 1)) )
    {
      LOBYTE(v27) = 1;
      v29 = (double)v30 * 0.000000001462918079267163;
      v28 = 0.000000001462918079267163 * (double)v31;
    }
    else
    {
      LOBYTE(v27) = 0;
    }
    LOBYTE(v21) = 1;
    sub_100087D0(v21, v29, v28, v27);
    if ( sub_10012930(18, &v30) && sub_10012950(18, &v31) )
    {
      LOBYTE(v27) = 1;
      v29 = (double)v30 * 0.000000001462918079267163;
      v28 = 0.000000001462918079267163 * (double)v31;
    }
    else
    {
      LOBYTE(v27) = 0;
    }
    LOBYTE(v23) = 3;
    sub_100087D0(v23, v29, v28, v27);
    if ( sub_10012930(19, &v30) && sub_10012950(19, &v31) )
    {
      LOBYTE(v27) = 1;
      v29 = (double)v30 * 0.000000001462918079267163;
      v28 = 0.000000001462918079267163 * (double)v31;
    }
    else
    {
      LOBYTE(v27) = 0;
    }
    v24 = v27;
LABEL_68:
    LOBYTE(v13) = 2;
    result = sub_100087D0(v13, v29, v28, v24);
  }
  return result;
}
// 10018D10: using guessed type double sub_10018D10(void);
// 10018D20: using guessed type double sub_10018D20(void);
// 1011D57C: using guessed type char byte_1011D57C;
// 1011D57D: using guessed type char byte_1011D57D;
// 1011D57E: using guessed type char byte_1011D57E;
// 102543FC: using guessed type int dword_102543FC;

//----- (100090A0) --------------------------------------------------------
int sub_100090A0()
{
  char v0; // bl@1
  int v1; // eax@3
  bool v2; // zf@3
  bool v3; // al@7
  int v4; // eax@12
  bool v5; // zf@12
  bool v6; // al@16
  int v7; // eax@22
  bool v8; // zf@22
  bool v9; // al@28
  char v10; // al@32
  char v11; // dl@32
  bool v12; // bl@33
  bool v13; // zf@33
  char v14; // al@38
  char v15; // dl@38
  bool v16; // cl@47
  int result; // eax@49
  char v18; // [sp+7h] [bp-91h]@1
  char v19; // [sp+8h] [bp-90h]@33
  char v20; // [sp+Ch] [bp-8Ch]@1
  char v21; // [sp+1Eh] [bp-7Ah]@13
  char v22; // [sp+2Fh] [bp-69h]@33
  char v23; // [sp+3Ch] [bp-5Ch]@40
  char v24; // [sp+50h] [bp-48h]@1
  char v25; // [sp+62h] [bp-36h]@12
  char v26; // [sp+73h] [bp-25h]@32
  char v27; // [sp+80h] [bp-18h]@38

  *(_BYTE *)(dword_102543FC + 22) = 0;
  *(_BYTE *)(dword_102543FC + 19) = 0;
  *(_BYTE *)(dword_102543FC + 24) = 0;
  *(_BYTE *)(dword_102543FC + 21) = 0;
  *(_BYTE *)(dword_102543FC + 23) = 0;
  *(_BYTE *)(dword_102543FC + 20) = 0;
  *(_BYTE *)(dword_102543FC + 25) = 0;
  *(_BYTE *)(dword_102543FC + 27) = 0;
  *(_BYTE *)(dword_102543FC + 26) = 0;
  v0 = sub_10018940(0);
  v18 = sub_10018940(1);
  sub_10032AE0(9189, (int)&v20, 67);
  sub_10032AE0(9190, (int)&v24, 67);
  if ( byte_1011D57C )
  {
    if ( (unsigned __int8)sub_10008A30() )
    {
      *(_BYTE *)(dword_102543FC + 22) = v24;
      v1 = dword_102543FC;
      v2 = *(_BYTE *)(dword_102543FC + 22) == 1;
    }
    else
    {
      *(_BYTE *)(dword_102543FC + 22) = v20;
      v1 = dword_102543FC;
      v2 = *(_BYTE *)(dword_102543FC + 22) == 0;
    }
    *(_BYTE *)(v1 + 23) = !v2;
    v3 = v20 == v24 && (unsigned __int8)sub_10008A70();
    *(_BYTE *)(dword_102543FC + 24) = v3;
  }
  if ( byte_1011D57D )
  {
    if ( (unsigned __int8)sub_10008A30() )
    {
      *(_BYTE *)(dword_102543FC + 19) = v25;
      v4 = dword_102543FC;
      v5 = *(_BYTE *)(dword_102543FC + 19) == 1;
    }
    else
    {
      *(_BYTE *)(dword_102543FC + 19) = v21;
      v4 = dword_102543FC;
      v5 = *(_BYTE *)(dword_102543FC + 19) == 0;
    }
    *(_BYTE *)(v4 + 20) = !v5;
    v6 = v21 == v25 && (unsigned __int8)sub_10008A70();
    *(_BYTE *)(dword_102543FC + 21) = v6;
  }
  if ( byte_1011D57E )
  {
    if ( (unsigned __int8)sub_10008A30() )
    {
      if ( !v18 )
        goto LABEL_26;
      *(_BYTE *)(dword_102543FC + 25) = v18 - 1;
      v7 = dword_102543FC;
      v8 = *(_BYTE *)(dword_102543FC + 25) == 1;
    }
    else
    {
      if ( !v0 )
        goto LABEL_26;
      *(_BYTE *)(dword_102543FC + 25) = v0 - 1;
      v7 = dword_102543FC;
      v8 = *(_BYTE *)(dword_102543FC + 25) == 0;
    }
    *(_BYTE *)(v7 + 26) = !v8;
LABEL_26:
    v9 = v18 == v0 && (unsigned __int8)sub_10008A70();
    *(_BYTE *)(dword_102543FC + 27) = v9;
  }
  if ( sub_10014850() )
  {
    v10 = sub_10008A30();
    v11 = v26;
    if ( v10 )
    {
      v12 = v26 != 1;
      v13 = v22 == v26;
      v19 = v26;
    }
    else
    {
      v19 = v22;
      if ( v22 && sub_10008A50() )
      {
        v13 = v22 == v11;
        v12 = 1;
      }
      else
      {
        v12 = 0;
        v13 = v22 == v11;
      }
    }
  }
  else
  {
    v14 = sub_10008A30();
    v15 = v27;
    if ( v14 )
    {
      v19 = v27;
      v12 = v27 != 1;
    }
    else
    {
      v19 = v23;
      v12 = v23 && sub_10008A50();
    }
    v13 = v23 == v15;
  }
  v16 = v13 && (unsigned __int8)sub_10008A70();
  result = dword_102543FC;
  if ( v19 != *(_BYTE *)(dword_102543FC + 16)
    || v12 != *(_BYTE *)(dword_102543FC + 17)
    || v16 != *(_BYTE *)(dword_102543FC + 18) )
  {
    if ( ++*(_BYTE *)(dword_102543FC + 34) > 0x4Bu || !v12 && !v16 )
    {
      *(_BYTE *)(dword_102543FC + 16) = v19;
      *(_BYTE *)(dword_102543FC + 17) = v12;
      *(_BYTE *)(dword_102543FC + 18) = v16;
      result = dword_102543FC;
      *(_BYTE *)(dword_102543FC + 34) = 0;
    }
  }
  else
  {
    *(_BYTE *)(dword_102543FC + 34) = 0;
  }
  return result;
}
// 1011D57C: using guessed type char byte_1011D57C;
// 1011D57D: using guessed type char byte_1011D57D;
// 1011D57E: using guessed type char byte_1011D57E;
// 102543FC: using guessed type int dword_102543FC;

//----- (100093A0) --------------------------------------------------------
char sub_100093A0()
{
  void *v0; // ecx@1
  signed int v1; // eax@2
  signed int v2; // eax@4
  char v4; // [sp+4h] [bp-1CCh]@1
  char v5; // [sp+C8h] [bp-108h]@6
  char v6; // [sp+C9h] [bp-107h]@1

  v4 = 23;
  memset(&v6, 0, 0x100u);
  if ( sub_1000BBA0(v0) )
  {
    sub_10006300(1);
    v1 = 0;
    do
    {
      *(_BYTE *)(v1 + dword_10254430 + 8) = 0;
      v1 += 12;
    }
    while ( v1 < 120000 );
    sub_10006300(2);
    v2 = 0;
    do
    {
      *(_BYTE *)(v2 + dword_10254430 + 8) = 0;
      v2 += 12;
    }
    while ( v2 < 24000 );
    v5 = 1;
  }
  else
  {
    v5 = 0;
    sub_1000A7B0(&v6, 0x100u, "Auto test mode must be enabled for this command to be processed.");
  }
  return sub_1001A600(&v4);
}
// 10254430: using guessed type int dword_10254430;

//----- (10009480) --------------------------------------------------------
int sub_10009480()
{
  int result; // eax@1
  char v1; // [sp+0h] [bp-Ch]@1
  __int16 v2; // [sp+4h] [bp-8h]@1
  int v3; // [sp+6h] [bp-6h]@3

  for ( result = sub_10032E50((int)&v2, (int)&v1); result != 1; result = sub_10032E50((int)&v2, (int)&v1) )
  {
    switch ( v2 )
    {
      case 0x8002:
        sub_10002880(v3);
        break;
      case 0x8003:
        nullsub_1(&v3);
        break;
      case 0x8004:
        sub_10006CD0();
        break;
      case 0x8001:
        sub_100093A0();
        break;
      default:
        continue;
    }
  }
  return result;
}

//----- (10009510) --------------------------------------------------------
void __noreturn sub_10009510()
{
  int v0; // ST40_4@1
  int v1; // edi@1
  int v2; // ebx@1
  int v3; // ebp@1
  void *v4; // ecx@3
  int v5; // esi@7
  void *v6; // ecx@7
  unsigned int v7; // ecx@8
  void *v8; // ecx@17
  int v9; // [sp+0h] [bp-104h]@0
  char v10; // [sp+13h] [bp-F1h]@1
  int v11; // [sp+14h] [bp-F0h]@1
  int v12; // [sp+18h] [bp-ECh]@1
  int v13; // [sp+1Ch] [bp-E8h]@1
  char v14; // [sp+20h] [bp-E4h]@1

  sub_1001AB80();
  sub_1001A780(&v14);
  sub_10006300(1);
  sub_10009B90(
    1,
    (int)&unk_101632B8,
    (int)&v12,
    (int)&unk_10134C88,
    &unk_1011D588,
    13000,
    12000,
    21000,
    1500,
    1000,
    10000,
    (int)"/mnt/card0/atm/cas_cov.bin",
    &unk_1015BD88);
  sub_10006220((int)&unk_101632B8, 0x3E8u);
  sub_10006300(2);
  sub_10009B90(
    2,
    (int)&unk_10148508,
    (int)&v13,
    (int)&unk_1018A3B8,
    &unk_1018E238,
    25000,
    23000,
    24000,
    600,
    500,
    2000,
    (int)"/mnt/card0/atm/sys_cov.bin",
    &unk_10197838);
  sub_10006220((int)&unk_10148508, 0x1F4u);
  sub_10019A50();
  sub_10019510();
  sub_10006300(1);
  nullsub_1(v0);
  sub_10012B20();
  v11 = 0;
  sub_10033160(104, &v10);
  v1 = sub_10032ED0();
  v2 = v1;
  v3 = v1;
  while ( !sub_10032E80(29) || !sub_10032E80(30) )
    sub_10033090(10);
  sub_100024A0(v4);
  while ( 1 )
  {
    sub_100330B0(&v11);
    if ( v11 & 1 )
    {
      v5 = sub_10032ED0();
      sub_10006300(1);
      sub_10008AB0();
      sub_10008330();
      sub_100090A0();
      sub_100081D0();
      sub_10005F40();
      sub_10002710();
      if ( sub_1000BED0(0) )
      {
        sub_100026A0(v6);
        sub_10006050();
        if ( byte_102543F8 == 1 )
        {
          sub_10006AC0(1, dword_10254440 + 120044, dword_10254440 + 40, (int)&unk_101632B8);
          sub_10006AC0(2, dword_10254440 + 229208, dword_10254440 + 205204, (int)&unk_10148508);
          byte_102543F8 = 2;
        }
        if ( v10 && (unsigned int)(v5 - v2) >= 0x3E8 )
        {
          v2 = v5;
          sub_10002A20(v7);
        }
        sub_1000C430();
        sub_100061B0();
        sub_10006D90((int)&unk_1011D588, (int)&unk_1015BD88);
        sub_100079D0((int)&unk_101632B8, v12, (int)&unk_10134C88, (int)&unk_1011D588, (int)&unk_1015BD88, 1);
        sub_10006300(2);
        sub_100079D0((int)&unk_10148508, v13, (int)&unk_1018A3B8, (int)&unk_1018E238, (int)&unk_10197838, 2);
        sub_10006300(1);
        if ( (unsigned int)(v5 - v1) >= 0x384 )
        {
          v1 = v5;
          sub_100063A0();
        }
        sub_1000C4F0(32, 0xFFFF, 5);
        sub_1000C4F0(4, 0xFFFF, 5);
        sub_10005C10();
      }
      else
      {
        sub_10006D90((int)&unk_1011D588, (int)&unk_1015BD88);
      }
      nullsub_1(v9);
      sub_10005B80();
      if ( (unsigned int)(v5 - v3) >= 0x3E8 )
      {
        v3 = v5;
        sub_10008160(v8);
        sub_1001A670((int *)&v14);
      }
    }
    if ( v11 & 2 )
      sub_10009480();
  }
}
// 1001AB80: using guessed type int sub_1001AB80(void);
// 102543F8: using guessed type char byte_102543F8;
// 10254440: using guessed type int dword_10254440;

//----- (10009820) --------------------------------------------------------
char **sub_10009820()
{
  return off_1005A3AC;
}
// 1005A3AC: using guessed type char *off_1005A3AC[3];

//----- (10009830) --------------------------------------------------------
char sub_10009830()
{
  return 0;
}

//----- (10009840) --------------------------------------------------------
bool __cdecl sub_10009840(char a1)
{
  return (a1 & 6) == 6;
}

//----- (10009860) --------------------------------------------------------
char **sub_10009860()
{
  return off_1005A600;
}
// 1005A600: using guessed type char *off_1005A600[3];

//----- (10009870) --------------------------------------------------------
bool __thiscall sub_10009870(void *this)
{
  int v1; // esi@1
  char v3; // [sp+4h] [bp-A0h]@1

  v1 = sub_100122C0(this);
  sub_1000BF10((int)&v3, 2282);
  sub_1000C170(&v3, 0x21u, 0, v1);
  sub_1000CBD0(0, 0, (int)".\\test\\tst_mon_arfrm.c", (int)"107", (int)"Set GDU ENT key test", 1u, 1u, 0);
  sub_1000BF10((int)&v3, 2282);
  sub_1000C170(&v3, 0x20u, 1, v1);
  return sub_1000CBD0(0, 0, (int)".\\test\\tst_mon_arfrm.c", (int)&unk_1005AE20, (int)"Set GCU CLR key test", 1u, 1u, 0);
}

//----- (10009920) --------------------------------------------------------
bool __thiscall sub_10009920(void *this)
{
  int v1; // esi@1
  char v3; // [sp+4h] [bp-A0h]@1

  v1 = sub_100122C0(this);
  sub_1000BF10((int)&v3, 2290);
  sub_1000C320((int)&v3, v1);
  return sub_1000CBD0(0, 0, (int)".\\test\\tst_mon_arfrm.c", (int)"148", (int)"Set this LRU test", 1u, 1u, 0);
}

//----- (10009990) --------------------------------------------------------
bool __thiscall sub_10009990(void *this)
{
  char v1; // al@1

  v1 = sub_100122C0(this);
  sub_1000C580(2290, v1);
  return sub_1000CBD0(0, 0, (int)".\\test\\tst_mon_arfrm.c", (int)"183", (int)"Clear this LRU test", 1u, 1u, 0);
}

//----- (100099D0) --------------------------------------------------------
bool sub_100099D0()
{
  sub_1000C430();
  return sub_1000CBD0(0, 0, (int)".\\test\\tst_mon_arfrm.c", (int)"208", (int)"Alert viewed test", 1u, 1u, 0);
}

//----- (10009A00) --------------------------------------------------------
int sub_10009A00()
{
  char v1; // [sp+0h] [bp-A0h]@1

  sub_1000BF10((int)&v1, 2169);
  sub_1000C2D0((int)&v1, 4);
  sub_1000CBD0(0, 0, (int)".\\test\\tst_mon_arfrm.c", (int)"239", (int)"Set manifest test", 1u, 1u, 0);
  return sub_1000C540(2169);
}

//----- (10009A70) --------------------------------------------------------
bool sub_10009A70()
{
  char v1; // [sp+0h] [bp-A0h]@1

  sub_1000BF10((int)&v1, 2063);
  sub_1000C130((int)&v1);
  sub_1000CBD0(0, 0, (int)".\\test\\tst_mon_arfrm.c", (int)"271", (int)"Set alert test", 1u, 1u, 0);
  sub_1000C540(2063);
  return sub_1000CBD0(0, 0, (int)".\\test\\tst_mon_arfrm.c", (int)"277", (int)"Clear alert test", 1u, 1u, 0);
}

//----- (10009B00) --------------------------------------------------------
bool sub_10009B00()
{
  sub_1000C4F0(255, 0xFFFF, 5);
  return sub_1000CBD0(0, 0, (int)".\\test\\tst_mon_arfrm.c", (int)"302", (int)"Alert acknowledged test", 1u, 1u, 0);
}

//----- (10009B40) --------------------------------------------------------
bool sub_10009B40()
{
  unsigned __int8 v0; // al@1

  v0 = sub_1000C0C0(2073);
  return sub_1000CBD0(0, 0, (int)".\\test\\tst_mon_arfrm.c", (int)"337", (int)"Alert acknowledged test", v0, 0, 0);
}

//----- (10009B80) --------------------------------------------------------
int (**sub_10009B80())()
{
  return off_1005AF1C;
}
// 1005AF1C: using guessed type int (*off_1005AF1C[4])();

//----- (10009B90) --------------------------------------------------------
__int16 __cdecl sub_10009B90(char a1, int a2, int a3, int a4, void *a5, int a6, int a7, int a8, __int16 a9, __int16 a10, __int16 a11, int a12, void *a13)
{
  int v13; // ebp@1
  int v14; // ebx@1
  char *v15; // edi@3
  void *v16; // esi@3
  int v17; // esi@6
  int v18; // edi@6
  int v19; // ebx@6
  void *v20; // eax@8
  int v21; // ecx@8
  char *v22; // esi@9
  char v23; // dl@10
  char *v24; // esi@11
  char v25; // dl@12
  char *v26; // esi@13
  char v27; // dl@14
  int v28; // esi@23
  int v29; // edi@23
  char *v30; // ebp@24
  char *v31; // ecx@26
  void *v32; // eax@26
  signed int v33; // ebp@29
  char v34; // bl@30
  unsigned __int16 *v35; // esi@30
  signed int v36; // edi@32
  unsigned int v37; // eax@38
  unsigned int v38; // ecx@40
  unsigned int v39; // eax@46
  unsigned int v40; // esi@46
  signed int v41; // eax@49
  int v42; // ecx@52
  signed int v43; // eax@52
  char *v45; // [sp+10h] [bp-94h]@2
  __int16 v46; // [sp+10h] [bp-94h]@6
  char v47; // [sp+1Bh] [bp-89h]@0
  unsigned int v48; // [sp+20h] [bp-84h]@35
  int v49; // [sp+24h] [bp-80h]@6
  int v50; // [sp+28h] [bp-7Ch]@33
  int v51; // [sp+2Ch] [bp-78h]@33
  void *v52; // [sp+30h] [bp-74h]@1
  int v53; // [sp+34h] [bp-70h]@1
  int i; // [sp+38h] [bp-6Ch]@6
  char v55; // [sp+3Ch] [bp-68h]@39

  v52 = (void *)a4;
  v53 = a12;
  memset(a5, 0, (unsigned __int16)a9 << 6);
  memset(a13, 0, 20 * (unsigned __int16)a9);
  memset(&unk_1019ED68, 0, 0x1900u);
  v13 = (unsigned __int16)a9 / 100;
  v14 = 0;
  if ( v13 > 0 )
  {
    v45 = (char *)a5 + 1;
    do
    {
      sub_10032AE0(v14 + a6, (int)&unk_1019ED68, 6400);
      v15 = v45;
      v45 += 6400;
      v16 = &unk_1019ED69;
      do
      {
        *(_DWORD *)(v15 + 31) = *(_DWORD *)((char *)v16 + 31);
        *v15 = *(_BYTE *)v16;
        *(_DWORD *)(v15 + 19) = *(_DWORD *)((char *)v16 + 19);
        v15[23] = *((_BYTE *)v16 + 23);
        *(_DWORD *)(v15 + 7) = *(_DWORD *)((char *)v16 + 7);
        *(_WORD *)(v15 + 35) = *(_WORD *)((char *)v16 + 35);
        *(_WORD *)(v15 + 1) = *(_WORD *)((char *)v16 + 1);
        *(_WORD *)(v15 + 3) = *(_WORD *)((char *)v16 + 3);
        *(_DWORD *)(v15 + 27) = *(_DWORD *)((char *)v16 + 27);
        *(v15 - 1) = *((char *)v16 - 1);
        *(_DWORD *)(v15 + 11) = *(_DWORD *)((char *)v16 + 11);
        v15[15] = *((_BYTE *)v16 + 15);
        v15[58] = *((_BYTE *)v16 + 58);
        *(_DWORD *)(v15 + 59) = *(_DWORD *)((char *)v16 + 59);
        sub_1000A6F0((int)(v15 + 37), (_BYTE *)v16 + 37, 21);
        v16 = (char *)v16 + 64;
        v15 += 64;
      }
      while ( (signed int)v16 < (signed int)&unk_101A0669 );
      ++v14;
    }
    while ( v14 < v13 );
  }
  v46 = 0;
  memset((void *)a2, 0, 160 * (unsigned __int16)a10);
  memset(&unk_101A0668, 0, 0x3E84u);
  v17 = (unsigned __int16)a10 / 100;
  v18 = 0;
  v19 = 0;
  v49 = 0;
  for ( i = (unsigned __int16)a10 / 100; v18 < v17; v49 = v18 )
  {
    if ( !sub_10032AE0(v18 + a7, (int)&unk_101A0668, 16004) )
    {
      v20 = &unk_101A066A;
      v21 = 160 * v19 + a2 + 33;
      do
      {
        *(_WORD *)(v21 + 123) = *((_WORD *)v20 + 77);
        strcpy((char *)(v21 - 31), (const char *)v20);
        v22 = (char *)v20 + 31;
        do
        {
          v23 = *v22;
          v22[v21 - ((_DWORD)v20 + 31)] = *v22;
          ++v22;
        }
        while ( v23 );
        v24 = (char *)v20 + 82;
        do
        {
          v25 = *v24;
          v24[v21 - ((_DWORD)v20 + 82) + 51] = *v24;
          ++v24;
        }
        while ( v25 );
        v26 = (char *)v20 + 103;
        do
        {
          v27 = *v26;
          v26[v21 - ((_DWORD)v20 + 103) + 72] = *v26;
          ++v26;
        }
        while ( v27 );
        *(_BYTE *)(v21 + 101) = *((_BYTE *)v20 + 132);
        *(_DWORD *)(v21 + 107) = *(_DWORD *)((char *)v20 + 138);
        *(_BYTE *)(v21 + 102) = *((_BYTE *)v20 + 133);
        *(_BYTE *)(v21 + 104) = *((_BYTE *)v20 + 135);
        *(_WORD *)(v21 + 99) = *((_WORD *)v20 + 65);
        *(_DWORD *)(v21 + 111) = *(_DWORD *)((char *)v20 + 142);
        *(_WORD *)(v21 + 105) = *((_WORD *)v20 + 68);
        *(_DWORD *)(v21 + 119) = *(_DWORD *)((char *)v20 + 150);
        *(_WORD *)(v21 - 33) = *((_WORD *)v20 - 1);
        *(_BYTE *)(v21 + 93) = *((_BYTE *)v20 + 124);
        *(_BYTE *)(v21 + 94) = *((_BYTE *)v20 + 125);
        *(_DWORD *)(v21 + 95) = *(_DWORD *)((char *)v20 + 126);
        *(_BYTE *)(v21 + 103) = *((_BYTE *)v20 + 134);
        if ( a1 != 1 || *(_BYTE *)(v21 - 31) )
        {
          if ( *(_WORD *)(v21 - 33) != -1 )
            v46 = v19;
        }
        else
        {
          *(_WORD *)(v21 - 33) = -1;
        }
        v20 = (char *)v20 + 160;
        ++v19;
        v21 += 160;
      }
      while ( (signed int)v20 < (signed int)&unk_101A44EA );
      v17 = i;
      v18 = v49;
    }
    ++v18;
  }
  memset(v52, 0, 8 * (unsigned __int16)a11);
  memset(&unk_101A6C00, 0, 0x1F40u);
  v28 = (unsigned __int16)a11 / 1000;
  v29 = 0;
  if ( v28 > 0 )
  {
    v30 = (char *)v52 + 2;
    do
    {
      if ( !sub_10032AE0(v29 + a8, (int)&unk_101A6C00, 8000) )
      {
        v31 = v30;
        v32 = &unk_101A6C00;
        v30 += 8000;
        do
        {
          v31[4] = *((_BYTE *)v32 + 6);
          *((_WORD *)v31 - 1) = *(_WORD *)v32;
          *(_WORD *)v31 = *((_WORD *)v32 + 1);
          *((_WORD *)v31 + 1) = *((_WORD *)v32 + 2);
          v32 = (char *)v32 + 8;
          v31 += 8;
        }
        while ( (signed int)v32 < (signed int)&unk_101A8B40 );
      }
      ++v29;
    }
    while ( v29 < v28 );
  }
  v33 = 0;
  if ( (signed int)(unsigned __int16)a10 > 0 )
  {
    v34 = v47;
    v35 = (unsigned __int16 *)(a2 + 138);
    do
    {
      if ( *v35 )
      {
        v36 = 0;
        do
        {
          if ( sub_100225C0(*v35, v36, &v50, &v51) )
          {
            if ( (char)v50 >= 7 )
              sub_10011520("..\\lib\\adl\\mon_init_prj_mon.c", 314, 0, 0);
            else
              v34 = sub_10012230(v50, v51, &v48);
            if ( v34 )
            {
              v37 = v48 - 100;
              v48 -= 100;
              if ( v48 >= 0xC8 )
              {
                v38 = *(_DWORD *)(v35 - 5);
                if ( !v38 && v37 < 0x3E8 || v37 < v38 )
                  *(_DWORD *)(v35 - 5) = v37;
              }
              else
              {
                sub_1000A7B0(
                  &v55,
                  0x64u,
                  "CAS processing can't update discrete out %i for CAS alert %i quick enough",
                  *v35,
                  v33);
                sub_10011520("..\\lib\\adl\\mon_init_prj_mon.c", 351, 0, &v55);
              }
            }
          }
          ++v36;
        }
        while ( v36 < 3 );
      }
      ++v33;
      v35 += 80;
    }
    while ( v33 < (unsigned __int16)a10 );
  }
  v39 = j_FIL_vfs_open(v53, 4, 0);
  v40 = v39;
  if ( v39 >= 0xFFFFFFC2 )
  {
    LOWORD(v39) = v46;
    *(_WORD *)a3 = v46;
  }
  else if ( v39 )
  {
    if ( sub_10033830(v39, byte_101A44F0, 10000) == 10000 )
    {
      v42 = 0;
      v43 = 0;
      do
      {
        *(_BYTE *)(v43 + dword_10254430 + 8) = byte_101A44F0[v42];
        v43 += 12;
        ++v42;
      }
      while ( v43 < 120000 );
    }
    else
    {
      v41 = 0;
      do
      {
        *(_BYTE *)(v41 + dword_10254430 + 8) = 0;
        v41 += 12;
      }
      while ( v41 < 120000 );
    }
    sub_10033760(v40);
    LOWORD(v39) = a3;
    *(_WORD *)a3 = v46;
  }
  else
  {
    *(_WORD *)a3 = v46;
  }
  return v39;
}
// 10033820: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10254430: using guessed type int dword_10254430;

//----- (1000A160) --------------------------------------------------------
#error "1000A188: call analysis failed (funcsize=1593)"

//----- (1000A1B0) --------------------------------------------------------
void __cdecl sub_1000A1B0(int a1, unsigned int a2, signed int *a3, signed int *a4)
{
  double v4; // st7@1
  float v5; // ST28_4@10
  float v6; // ST14_4@10
  float v7; // ST28_4@10
  float v8; // ST20_4@10
  float v9; // ST28_4@10
  float v10; // ST10_4@10
  float v11; // ST24_4@10
  float v12; // ST1C_4@10
  float v13; // ST28_4@10
  float v14; // ST2C_4@10
  float v15; // ST2C_4@10
  long double v16; // ST3C_8@10
  float v17; // ST2C_4@10
  float v18; // ST2C_4@10
  float v19; // ST2C_4@10
  float v20; // ST2C_4@10
  float v21; // ST14_4@10
  float v22; // ST10_4@10
  float v23; // ST10_4@10
  long double v24; // ST3C_8@10
  float v25; // ST10_4@10
  long double v26; // st7@10
  float v27; // ST28_4@12
  float v28; // ST38_4@12
  float v29; // ST38_4@12
  double v30; // st7@12
  double v31; // st6@12
  float v32; // ST38_4@12
  double v33; // st4@12
  signed int v34; // eax@12
  signed int v35; // esi@12
  float v36; // ST38_4@12
  signed int v37; // ecx@12
  float v38; // [sp+14h] [bp-3Ch]@1
  float v39; // [sp+28h] [bp-28h]@10
  float v40; // [sp+34h] [bp-1Ch]@1
  long double v41; // [sp+40h] [bp-10h]@1
  double v42; // [sp+48h] [bp-8h]@1

  sub_10014350((int)&v41, *(_DWORD *)a1, *(_DWORD *)(a1 + 4));
  v38 = v41;
  v40 = v42;
  v4 = v38;
  if ( (LODWORD(v38) & 0x7F800000) != 2139095040 && v4 <= 1.570796370506287 && v4 >= -1.570796370506287 )
  {
    if ( (LODWORD(v38) & 0x7F800000) == 2139095040 || v4 > 1.558579 )
    {
      v38 = 1.558579;
    }
    else if ( v4 < -1.558579 )
    {
      v38 = -1.558579;
    }
    v5 = (double)(a2 / 0x15180) - 3653.5;
    v6 = v5 / 36525.0;
    v7 = v6 * (0.0003032000095117837 * v6 + 36000.76953125) + 280.4664611816406;
    v8 = sub_10035BB0(v7, 360.0) * 0.01745329238474369;
    v9 = (35999.05078125 - 0.0001537000061944127 * v6) * v6 + 357.5291137695312;
    v10 = 0.01745329238474369 * v9;
    v11 = 0.01670863479375839 - v6 * (0.0000001267000016014208 * v6 + 0.00004203700154903345);
    v12 = sin(v10);
    v13 = sin(v10 + v10);
    v41 = (125.0400009155273 - v6 * 1934.135986328125) * 0.01745329251994333;
    v14 = ((21.44799995422363 - v6 * ((0.000590000010561198 - 0.001812999951653183 * v6) * v6 + 46.81499862670898))
         / 60.0
         + 26.0)
        / 60.0
        + 23.0;
    v15 = cos(v41) * 0.00255999993532896 + v14;
    v16 = v15 * 0.01745329251994333;
    v17 = sin(v10 * 3.0);
    v18 = v17 * 0.0002889999886974692
        + (1.914602041244507 - (0.00001400000019202707 * v6 + 0.00481700012460351) * v6) * v12
        + (0.01999299973249435 - v6 * 0.0001009999978123233) * v13;
    v19 = v18 + v8 * 57.29577951308219;
    v20 = (v19 - 0.005690000019967556 - sin(v41) * 0.004780000075697899) * 0.01745329251994333;
    v41 = sin(v20);
    v21 = asin(sin(v16) * v41);
    v22 = tan(v16 * 0.5);
    v23 = v22 * v22;
    v41 = v8 + v8;
    v41 = sin(v41) * v23 - (v11 + v11) * v12 + cos(v41) * (v11 * 4.0 * v23 * v12);
    v39 = (v41 - sin(v8 * 4.0) * (v23 * (0.5 * v23)) - v11 * (1.25 * v11) * v13) * 57.29577951308219 * 4.0;
    v41 = cos(v21);
    v24 = cos(1.585334922659806) / (cos(v38) * v41);
    v41 = tan(v21);
    v25 = v24 - tan(v38) * v41;
    v26 = v25;
    if ( v25 <= -1.0 || v26 > 1.0 )
    {
      *a3 = 0x7FFFFFFF;
      *a4 = 0x7FFFFFFF;
    }
    else
    {
      v27 = acos(v26) * 57.29577951308219;
      v28 = 720.0 - 57.29577951308219 * v40 * 4.0 - v39;
      v29 = v28 / 1440.0;
      v30 = v27 / 360.0;
      v31 = v29;
      v32 = v29 - v30;
      v33 = v32 * 86400.0;
      v34 = (signed int)v33;
      v35 = (signed int)v33;
      v36 = v30 + v31;
      v37 = (signed int)(86400.0 * v36);
      if ( (signed int)v33 >= 0 )
      {
        if ( v34 >= 86400 )
          v35 += 86400
               * (((signed int)(((unsigned __int64)(1037155065i64 * v34) >> 32) - v34) >> 16)
                + ((unsigned int)(((unsigned __int64)(1037155065i64 * v34) >> 32) - v34) >> 31));
      }
      else
      {
        v35 += 86400 - 86400 * (v34 / 86400);
      }
      if ( v37 >= 0 )
      {
        if ( v37 >= 86400 )
          v37 += 86400
               * (((signed int)(((unsigned __int64)(1037155065i64 * v37) >> 32) - v37) >> 16)
                + ((unsigned int)(((unsigned __int64)(1037155065i64 * v37) >> 32) - v37) >> 31));
        *a3 = v35;
        *a4 = v37;
      }
      else
      {
        *a3 = v35;
        *a4 = 86400 - 86400 * (v37 / 86400) + v37;
      }
    }
  }
  else
  {
    *a3 = 0x7FFFFFFF;
    *a4 = 0x7FFFFFFF;
  }
}

//----- (1000A6F0) --------------------------------------------------------
int __cdecl sub_1000A6F0(int a1, _BYTE *a2, int a3)
{
  int v3; // esi@2
  int v4; // eax@2
  _BYTE *v5; // ecx@3
  int result; // eax@7

  if ( a3 <= 0 )
    goto LABEL_11;
  v3 = a3 - 1;
  v4 = 0;
  if ( a3 - 1 > 0 )
  {
    v5 = a2;
    do
    {
      if ( !*v5 )
        break;
      v5[a1 - (_DWORD)a2] = *v5;
      ++v4;
      ++v5;
    }
    while ( v4 < v3 );
  }
  *(_BYTE *)(v4 + a1) = 0;
  *(_BYTE *)(v3 + a1) = 0;
  if ( a2[v4] )
LABEL_11:
    result = -1;
  else
    result = v4 + 1;
  return result;
}

//----- (1000A740) --------------------------------------------------------
int __cdecl sub_1000A740(void *a1, size_t a2)
{
  _BYTE *v2; // eax@1
  int result; // eax@2

  v2 = memchr(a1, 0, a2);
  if ( v2 )
    result = v2 - (_BYTE *)a1;
  else
    result = -2;
  return result;
}

//----- (1000A770) --------------------------------------------------------
int __cdecl sub_1000A770(char *a1, size_t a2, char *a3, va_list a4)
{
  int result; // eax@2

  if ( (signed int)a2 > 0 )
  {
    result = _vsnprintf(a1, a2, a3, a4);
    if ( result < 0 )
      result = -1;
    a1[a2 - 1] = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1000A7B0) --------------------------------------------------------
int sub_1000A7B0(char *a1, size_t a2, char *a3, ...)
{
  int result; // eax@1
  va_list va; // [sp+10h] [bp+10h]@1

  va_start(va, a3);
  result = sub_1000A770(a1, a2, a3, va);
  if ( result < 0 )
    result = -1;
  return result;
}

//----- (1000A7E0) --------------------------------------------------------
int __cdecl sub_1000A7E0(const char *a1, _BYTE *a2, int a3)
{
  unsigned int v3; // kr00_4@1

  v3 = strlen(a1);
  return sub_1000A6F0((int)&a1[v3], a2, a3 - v3);
}

//----- (1000A820) --------------------------------------------------------
char __cdecl sub_1000A820(_DWORD *a1)
{
  char v1; // bl@1
  unsigned int v2; // ebp@1
  char *v3; // edi@1
  char *v4; // eax@4
  char *v5; // eax@7
  char v7; // [sp+13h] [bp-105h]@1
  char v8; // [sp+14h] [bp-104h]@5
  char v9; // [sp+113h] [bp-5h]@5

  v1 = 0;
  v7 = 0;
  v2 = 0;
  v3 = sub_10023980() + 36;
  do
  {
    if ( v2 >= 5 )
      break;
    if ( !*(_DWORD *)v3 )
    {
      v1 = 1;
      v7 = 1;
      *(_DWORD *)v3 = a1;
      v4 = sub_10024890("CFG_OutputFile", 0);
      if ( v4 )
      {
        _snprintf(&v8, 0x100u, "'%s' file '%s'", *a1, v4);
        v9 = 0;
        if ( sub_10024720() )
          v7 = 0;
      }
      v5 = sub_10024890("CFG_OutputPath", 0);
      if ( v5 )
      {
        _snprintf(&v8, 0x100u, "'%s' path '%s'", *a1, v5);
        v9 = 0;
        if ( sub_10024720() )
          v7 = 0;
      }
    }
    ++v2;
    v3 += 4;
  }
  while ( !v1 );
  return v7;
}

//----- (1000A930) --------------------------------------------------------
char __cdecl sub_1000A930(int a1, unsigned int a2)
{
  char result; // al@1

  result = 1;
  if ( a2 > 4 && !memcmp(*(const void **)(a1 + 16), "PASS", 5u) )
    result = 0;
  return result;
}

//----- (1000A960) --------------------------------------------------------
bool __cdecl sub_1000A960(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "begin", 6u);
}

//----- (1000A990) --------------------------------------------------------
bool __cdecl sub_1000A990(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "case", 5u);
}

//----- (1000A9C0) --------------------------------------------------------
bool __cdecl sub_1000A9C0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "command", 8u);
}

//----- (1000A9F0) --------------------------------------------------------
bool __cdecl sub_1000A9F0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "end", 4u);
}

//----- (1000AA20) --------------------------------------------------------
bool __cdecl sub_1000AA20(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "group", 6u);
}

//----- (1000AA50) --------------------------------------------------------
bool __cdecl sub_1000AA50(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-begin", 0xCu);
}

//----- (1000AA90) --------------------------------------------------------
bool __cdecl sub_1000AA90(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-end", 0xAu);
}

//----- (1000AAD0) --------------------------------------------------------
bool __cdecl sub_1000AAD0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "listener", 9u);
}

//----- (1000AB00) --------------------------------------------------------
bool __cdecl sub_1000AB00(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "suite", 6u);
}

//----- (1000AB30) --------------------------------------------------------
char __cdecl sub_1000AB30(int a1, unsigned int a2)
{
  char result; // al@1

  result = 0;
  if ( a2 > 5 && !memcmp(*(const void **)(a1 + 20), "robust", 7u) )
    result = 1;
  return result;
}

//----- (1000AB60) --------------------------------------------------------
bool __cdecl sub_1000AB60(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Error**", 0xAu);
}

//----- (1000AB90) --------------------------------------------------------
bool __cdecl sub_1000AB90(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**MSG**", 8u);
}

//----- (1000ABC0) --------------------------------------------------------
bool __cdecl sub_1000ABC0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**METHOD**", 0xBu);
}

//----- (1000ABF0) --------------------------------------------------------
bool __cdecl sub_1000ABF0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**RESULT**", 0xBu);
}

//----- (1000AC20) --------------------------------------------------------
bool __cdecl sub_1000AC20(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, &unk_1005C3A0, 9u);
}

//----- (1000AC50) --------------------------------------------------------
bool __cdecl sub_1000AC50(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**SUBGROUP**", 0xDu);
}

//----- (1000AC80) --------------------------------------------------------
bool __cdecl sub_1000AC80(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TITLE**", 0xAu);
}

//----- (1000ACB0) --------------------------------------------------------
bool __cdecl sub_1000ACB0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "Tested Requirement:", 0x14u);
}

//----- (1000ACE0) --------------------------------------------------------
bool __cdecl sub_1000ACE0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TYPE**", 9u);
}

//----- (1000AD10) --------------------------------------------------------
bool __cdecl sub_1000AD10(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Warning**", 0xCu);
}

//----- (1000AD40) --------------------------------------------------------
int __cdecl sub_1000AD40(int a1, int a2, int a3)
{
  int *v3; // esi@1
  signed int v4; // edi@1
  int result; // eax@2

  v3 = (int *)(sub_10023980() + 36);
  v4 = 5;
  do
  {
    result = *v3;
    if ( *v3 )
    {
      result = *(_DWORD *)(result + 4);
      if ( result )
        result = ((int (__cdecl *)(int, int, int))result)(a1, a2, a3);
    }
    ++v3;
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (1000ADB0) --------------------------------------------------------
int __cdecl sub_1000ADB0(int a1, char a2)
{
  return sub_1000AD40(a1, (int)&a2, 1);
}

//----- (1000ADD0) --------------------------------------------------------
int __cdecl sub_1000ADD0(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = a2;
  v5 = a3;
  return sub_1000AD40(a1, (int)&v4, 2);
}

//----- (1000AE00) --------------------------------------------------------
int __cdecl sub_1000AE00(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-Ch]@1
  int v6; // [sp+4h] [bp-8h]@1
  int v7; // [sp+8h] [bp-4h]@1

  v5 = a2;
  v6 = a3;
  v7 = a4;
  return sub_1000AD40(a1, (int)&v5, 3);
}

//----- (1000AE30) --------------------------------------------------------
int __cdecl sub_1000AE30(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+4h] [bp-Ch]@1
  int v8; // [sp+8h] [bp-8h]@1
  int v9; // [sp+Ch] [bp-4h]@1

  v7 = a3;
  v8 = a4;
  v6 = a2;
  v9 = a5;
  return sub_1000AD40(a1, (int)&v6, 4);
}

//----- (1000AE70) --------------------------------------------------------
int __cdecl sub_1000AE70(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [sp+0h] [bp-14h]@1
  int v8; // [sp+4h] [bp-10h]@1
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1
  int v11; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v9 = a4;
  v10 = a5;
  v8 = a3;
  v11 = a6;
  return sub_1000AD40(a1, (int)&v7, 5);
}

//----- (1000AEB0) --------------------------------------------------------
int __cdecl sub_1000AEB0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-18h]@1
  int v9; // [sp+4h] [bp-14h]@1
  int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v8 = a2;
  v9 = a3;
  v11 = a5;
  v12 = a6;
  v10 = a4;
  v13 = a7;
  return sub_1000AD40(a1, (int)&v8, 6);
}

//----- (1000AF00) --------------------------------------------------------
char __cdecl sub_1000AF00(int a1)
{
  char v1; // bl@1
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  _DWORD *v4; // eax@1

  v1 = 0;
  v2 = sub_10023980();
  v3 = 0;
  v4 = v2 + 36;
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 == a1 )
    {
      v1 = 1;
      *v4 = 0;
    }
    ++v3;
    ++v4;
  }
  while ( !v1 );
  return v1;
}

//----- (1000AF30) --------------------------------------------------------
char __cdecl sub_1000AF30(int a1)
{
  ++*(_DWORD *)(a1 + 328);
  return *(_BYTE *)(a1 + 52);
}

//----- (1000AF40) --------------------------------------------------------
char __cdecl sub_1000AF40(int a1, int a2)
{
  int v2; // esi@1
  bool v3; // zf@1
  int v4; // ebp@1
  char *v5; // eax@1
  int v6; // edi@1
  int v7; // ecx@2
  char *v8; // ecx@7
  char v9; // dl@8
  char v10; // cl@9
  const char *v11; // ecx@10
  char *v12; // edx@13
  char v13; // cl@14
  int v14; // eax@17
  char v16[255]; // [sp+10h] [bp-104h]@12
  char v17; // [sp+10Fh] [bp-5h]@12

  v2 = a1;
  ++*(_DWORD *)(v2 + 324);
  ++*(_DWORD *)(v2 + 328);
  v3 = *(_BYTE *)(a1 + 53) == 0;
  v4 = *(_DWORD *)(a1 + 324);
  v5 = (char *)(a1 + 53);
  v6 = *(_DWORD *)(a1 + 328);
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  if ( !v3 )
  {
    v7 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
    if ( !v7 )
    {
LABEL_6:
      if ( *(_BYTE *)(a1 + 52) )
      {
        v8 = (char *)(a1 + 53);
        do
          v9 = *v8++;
        while ( v9 );
        v10 = *(&v8[a1 - 2] - a1);
        if ( v10 == 92 || (v3 = v10 == 47, v11 = "/", v3) )
          v11 = (const char *)&unk_1005C3FD;
        _snprintf(v16, 0x100u, "%s%s%s%s", a1 + 53, v11, a2, *(_DWORD *)(a1 + 48));
        v17 = 0;
      }
      else
      {
        v12 = (char *)(v16 - v5);
        do
        {
          v13 = *v5;
          v5[(_DWORD)v12] = *v5;
          ++v5;
        }
        while ( v13 );
      }
      if ( (unsigned __int8)sub_10024C20(v16) )
        sub_10024C00((int)v16);
      *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = sub_10024C30((int)v16, 1);
      v14 = *(_DWORD *)a1;
      if ( !*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) && v14 > 0 )
        *(_DWORD *)a1 = v14 - 1;
      return 1;
    }
    if ( *(_BYTE *)(a1 + 52) )
    {
      if ( v7 )
        ++*(_DWORD *)a1;
      goto LABEL_6;
    }
  }
  if ( v6 == 1 && v4 == 1 )
    return 1;
  return 0;
}
// 10024C20: using guessed type _DWORD __cdecl sub_10024C20(_DWORD);
// 1000AF40: using guessed type char var_104[255];

//----- (1000B0C0) --------------------------------------------------------
signed int __cdecl sub_1000B0C0(int a1)
{
  signed int result; // eax@1
  int v2; // edx@1
  int v3; // edx@1

  result = 1;
  v2 = 16 * *(_DWORD *)a1;
  *(_DWORD *)(v2 + a1 + 4) = 0;
  v3 = v2 + a1 + 4;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 312) = 5;
  return result;
}

//----- (1000B100) --------------------------------------------------------
signed int __cdecl sub_1000B100(int a1, int a2, int a3)
{
  char *v3; // eax@3
  char v4; // cl@4
  signed int result; // eax@5

  switch ( a1 )
  {
    case 8:
    case 9:
      if ( *(_DWORD *)a2 != 5 )
        goto LABEL_6;
      v3 = (char *)(a2 + 4);
      do
      {
        v4 = *v3;
        v3[a3 + 53 - (a2 + 4)] = *v3;
        ++v3;
      }
      while ( v4 );
      *(_BYTE *)(a3 + 52) = a1 != 8;
      result = 0;
      break;
    case 10:
      if ( *(_DWORD *)a2 )
        goto LABEL_6;
      *(_BYTE *)(a3 + 53) = 0;
      *(_BYTE *)(a3 + 52) = 0;
      result = 0;
      break;
    case 11:
      if ( *(_DWORD *)a2 == 1 )
      {
        *(_BYTE *)(a3 + 309) = *(_BYTE *)(a2 + 4);
        result = 0;
      }
      else
      {
LABEL_6:
        result = 9;
      }
      break;
    default:
      result = 4;
      break;
  }
  return result;
}

//----- (1000B1A0) --------------------------------------------------------
char __cdecl sub_1000B1A0(int a1)
{
  int v1; // edx@3

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( *(_DWORD *)(a1 + 328) == 1 )
    {
      v1 = 16 * *(_DWORD *)a1 + a1 + 4;
      *(_DWORD *)v1 = 0;
      *(_DWORD *)(v1 + 4) = 0;
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 12) = 0;
      if ( *(_DWORD *)a1 > 0 )
        --*(_DWORD *)a1;
    }
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return *(_BYTE *)(a1 + 52);
}

//----- (1000B200) --------------------------------------------------------
char __cdecl sub_1000B200(int a1, void (__cdecl *a2)(int))
{
  char result; // al@6

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( a2 )
      a2(a1);
    sub_10024BE0(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    result = 1;
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return result;
}

//----- (1000B270) --------------------------------------------------------
char *__cdecl sub_1000B270(char *a1)
{
  char *v1; // esi@1
  size_t v2; // edi@1
  char *v3; // eax@1
  char *v4; // eax@2
  unsigned int v5; // eax@3
  char *v6; // eax@5
  char *v7; // eax@7

  v1 = a1;
  v2 = 255;
  v3 = strstr(a1, "$Id: ");
  if ( v3 )
  {
    v1 = v3 + 5;
    v4 = strchr(v3 + 5, 44);
    if ( v4 )
    {
      v5 = v4 - v1;
      if ( v5 < 0x100 )
        goto LABEL_9;
    }
  }
  else
  {
    v6 = strrchr(a1, 47);
    if ( v6 )
    {
      v1 = v6 + 1;
      v2 = strlen(v6 + 1);
    }
    v7 = strrchr(v1, 92);
    if ( v7 )
    {
      v1 = v7 + 1;
      v5 = strlen(v7 + 1);
LABEL_9:
      v2 = v5;
      goto LABEL_10;
    }
  }
LABEL_10:
  strncpy(&byte_101A8BC0, v1, v2);
  *(&byte_101A8BC0 + v2) = 0;
  return &byte_101A8BC0;
}

//----- (1000B310) --------------------------------------------------------
int __cdecl sub_1000B310(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 44) = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 48) = a3;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 53) = 0;
  *(_BYTE *)(a1 + 309) = 1;
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1000B380) --------------------------------------------------------
bool __cdecl sub_1000B380(int a1, unsigned int a2, int a3)
{
  bool result; // al@9
  int v4; // ecx@11
  int v5; // edx@11
  int v6; // [sp+4h] [bp-4h]@3

  if ( a2 <= 4
    || sub_10037E8E(*(_DWORD *)(a1 + 12), (int)"%d", (unsigned int)&a2) != 1
    || sub_10037E8E(*(_DWORD *)(a1 + 16), (int)"%d", (unsigned int)&v6) != 1 )
  {
    result = 0;
    *(_BYTE *)(a3 + 316) = 0;
  }
  else
  {
    result = a2 == 4 || !a2 || a2 == 1 || a2 == 2 || a2 == 3;
    v4 = a3;
    *(_DWORD *)(a3 + 312) = a2;
    v5 = v6;
    *(_BYTE *)(v4 + 316) = result;
    *(_DWORD *)(v4 + 320) = v5;
  }
  return result;
}

//----- (1000B410) --------------------------------------------------------
char __cdecl sub_1000B410(int a1, int a2, char a3, char a4)
{
  int v4; // ecx@2
  int v5; // eax@3
  bool v6; // zf@3
  signed int v7; // eax@6
  char result; // al@14

  switch ( a2 )
  {
    case 3:
      v4 = a1;
      if ( a3 )
        goto LABEL_11;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 1;
      goto LABEL_4;
    case 7:
      v4 = a1;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 2;
LABEL_4:
      if ( !v6 && v5 != 3 )
        goto LABEL_12;
      v7 = *(_DWORD *)(v4 + 320);
      if ( v7 <= 1 )
      {
        *(_DWORD *)(v4 + 320) = 0;
LABEL_11:
        *(_DWORD *)(v4 + 312) = 5;
      }
      else
      {
        *(_DWORD *)(v4 + 320) = v7 - 1;
      }
LABEL_12:
      if ( *(_BYTE *)(v4 + 316) )
      {
        if ( *(_DWORD *)(v4 + 312) == 5 )
        {
          result = 1;
          *(_BYTE *)(v4 + 316) = 0;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = a4;
      }
      return result;
    default:
      v4 = a1;
      goto LABEL_11;
  }
}

//----- (1000B4C0) --------------------------------------------------------
char __cdecl sub_1000B4C0(int a1)
{
  return *(_BYTE *)(a1 + 316);
}

//----- (1000B4D0) --------------------------------------------------------
char __cdecl sub_1000B4D0(int a1, void (__cdecl *a2)(int))
{
  char v2; // bl@1

  v2 = 0;
  if ( !*(_BYTE *)(a1 + 52) && *(_DWORD *)(a1 + 324) > 0 || *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    v2 = 1;
    if ( a2 )
      a2(a1);
  }
  if ( *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    sub_10024BE0(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    v2 = 1;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return v2;
}

//----- (1000B550) --------------------------------------------------------
int (__cdecl *__cdecl sub_1000B550(int a1, const char *a2))(const char *)
{
  int v2; // edx@1
  int (__cdecl *result)(const char *); // eax@2

  v2 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
  if ( v2 )
  {
    result = (int (__cdecl *)(const char *))sub_10024CB0((int)a2, strlen(a2), v2);
  }
  else
  {
    result = *(int (__cdecl **)(const char *))(a1 + 44);
    if ( result )
      result = (int (__cdecl *)(const char *))result(a2);
  }
  return result;
}

//----- (1000B5A0) --------------------------------------------------------
signed int __cdecl sub_1000B5A0(int a1, void (__cdecl *a2)(int))
{
  signed int result; // eax@1

  sub_1000B4D0(a1, a2);
  result = 1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1000B5F0) --------------------------------------------------------
signed int sub_1000B5F0()
{
  signed int result; // eax@1

  result = -15;
  dword_10254444 = -15;
  dword_10254440 = -15;
  return result;
}
// 10254440: using guessed type int dword_10254440;
// 10254444: using guessed type int dword_10254444;

//----- (1000B600) --------------------------------------------------------
signed int sub_1000B600()
{
  return sub_100335F0((int)&off_1005CC38);
}
// 1005CC38: using guessed type char *off_1005CC38;

//----- (1000B610) --------------------------------------------------------
signed int sub_1000B610()
{
  return sub_100335F0((int)&off_1005CC4C);
}
// 1005CC4C: using guessed type char *off_1005CC4C;

//----- (1000B620) --------------------------------------------------------
char __cdecl sub_1000B620(unsigned __int16 a1, unsigned __int16 a2)
{
  char v2; // bl@1
  char result; // al@6

  v2 = 0;
  if ( a2 >= 0x2710u || a1 >= 0x9C4u )
    return v2;
  if ( (unsigned __int16)(a1 - 1000) <= 0x3E7u && (unsigned __int8)sub_1000B610() )
  {
    if ( a2 & 1 )
      result = *(_BYTE *)(dword_10254440 + 12 * (((unsigned int)a2 >> 1) + 4)) & 0xF;
    else
      result = *(_BYTE *)(dword_10254440 + 12 * (((unsigned int)a2 >> 1) + 4)) >> 4;
    return result;
  }
  if ( a1 > 0x3E7u || !(unsigned __int8)sub_1000B600() )
  {
    if ( (unsigned __int16)(a1 - 2000) <= 0x1F3u && (unsigned __int8)sub_1000B610() )
    {
      if ( a2 & 1 )
        return *(_BYTE *)(dword_10254440 + 12 * (((unsigned int)a2 >> 1) + 17101)) & 0xF;
      v2 = *(_BYTE *)(dword_10254440 + 12 * (((unsigned int)a2 >> 1) + 17101)) >> 4;
    }
    return v2;
  }
  if ( a2 & 1 )
    result = *(_BYTE *)(dword_10254444 + 12 * ((unsigned int)a2 >> 1) + 8) & 0xF;
  else
    result = *(_BYTE *)(dword_10254444 + 12 * ((unsigned int)a2 >> 1) + 8) >> 4;
  return result;
}
// 10254440: using guessed type int dword_10254440;
// 10254444: using guessed type int dword_10254444;

//----- (1000B740) --------------------------------------------------------
char __cdecl sub_1000B740(unsigned __int16 a1, unsigned __int16 a2)
{
  char result; // al@5

  if ( a2 >= 0x2710u )
  {
    result = 0;
  }
  else
  {
    if ( a1 >= 0x9C4u )
      goto LABEL_16;
    if ( (unsigned __int16)(a1 - 1000) <= 0x3E7u && (unsigned __int8)sub_1000B610() )
      return *(_BYTE *)(dword_10254440 + 12 * a2 + 40);
    if ( (unsigned __int16)(a1 - 2000) <= 0x1F3u && (unsigned __int8)sub_1000B610() )
      return *(_BYTE *)(dword_10254440 + 12 * a2 + 205204);
    if ( a1 <= 0x3E7u && (unsigned __int8)sub_1000B600() )
      result = *(_BYTE *)(dword_10254444 + 12 * a2);
    else
LABEL_16:
      result = 0;
  }
  return result;
}
// 10254440: using guessed type int dword_10254440;
// 10254444: using guessed type int dword_10254444;

//----- (1000B7F0) --------------------------------------------------------
char __cdecl sub_1000B7F0(int a1, int a2, char a3, bool *a4, char *a5)
{
  unsigned __int8 v5; // al@1
  int v6; // ecx@4
  unsigned __int16 v7; // dx@4
  __int16 v8; // ax@7
  char result; // al@9

  v5 = sub_10019990(a2);
  if ( v5 < 3u && a4 && a5 )
  {
    v6 = 6 * v5;
    v7 = a2 - word_1006DAA0[v6];
    if ( v5 == a3 && v7 < (unsigned __int16)word_1006DAA4[v6] && a1 )
      v8 = *(_WORD *)(160 * v7 + a1 + 156);
    else
      v8 = sub_100199C0(v7, v5);
    *a4 = (unsigned __int8)sub_1000B740(a2, v8) >= 2u;
    *a5 = sub_1000C080(a2);
    result = 1;
  }
  else
  {
    sub_10011520("..\\lib\\adl\\mon_intf.c", 365, 0, 0);
    result = 0;
  }
  return result;
}
// 1006DAA0: using guessed type __int16 word_1006DAA0[];
// 1006DAA4: using guessed type __int16 word_1006DAA4[];

//----- (1000B8C0) --------------------------------------------------------
void sub_1000B8C0()
{
  float v0; // ST00_4@1

  v0 = sub_10018D10();
  sub_100349F0(v0);
}
// 10018D10: using guessed type double sub_10018D10(void);

//----- (1000B8E0) --------------------------------------------------------
char __thiscall sub_1000B8E0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_10032DC0(3180, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1000B910) --------------------------------------------------------
char __thiscall sub_1000B910(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  if ( sub_10032AE0(3137, (int)&v2 + 3, 1) )
  {
    sub_10033160(86, (_BYTE *)&v2 + 3);
    sub_10032BB0(3137, (int)&v2 + 3, 1);
  }
  return BYTE3(v2);
}

//----- (1000B950) --------------------------------------------------------
char __thiscall sub_1000B950(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_10032DC0(6077, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1000B980) --------------------------------------------------------
signed int __cdecl sub_1000B980(char a1)
{
  return 1 << a1;
}

//----- (1000B990) --------------------------------------------------------
int __cdecl sub_1000B990(int a1, int a2, int a3)
{
  void *v3; // ecx@0
  int v4; // eax@1
  unsigned int v5; // esi@3
  int result; // eax@7

  v4 = a1;
  if ( !a1 )
    v4 = sub_100122C0(v3);
  v5 = 0;
  while ( v4 != dword_1005D2D8[2 * v5] )
  {
    if ( ++v5 >= 0x1C )
      return sub_1000A6F0(a2, &unk_1005D3DC, a3);
  }
  result = sub_1000A6F0(a2, off_1005D2DC[2 * v5], a3);
  if ( v5 < 0x1C )
    return result;
  return sub_1000A6F0(a2, &unk_1005D3DC, a3);
}
// 1000B990: too many cbuild loops
// 1005D2D8: using guessed type int dword_1005D2D8[];

//----- (1000B9F0) --------------------------------------------------------
char __thiscall sub_1000B9F0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 18;
  sub_10032DC0(3005, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1000BA20) --------------------------------------------------------
char *__cdecl sub_1000BA20(char a1, char *a2, size_t a3)
{
  char *result; // eax@4

  switch ( a1 )
  {
    case 1:
      result = strncpy(a2, "GCU1", a3);
      break;
    case 2:
      result = strncpy(a2, "GMC", a3);
      break;
    case 4:
      result = strncpy(a2, "GCU2", a3);
      break;
    default:
      result = strncpy(a2, "RMT", a3);
      break;
  }
  return result;
}

//----- (1000BAA0) --------------------------------------------------------
int sub_1000BAA0()
{
  int v1; // [sp+0h] [bp-8h]@1
  int v2; // [sp+4h] [bp-4h]@1

  v1 = 0;
  sub_10032DC0(3012, &v2, 4, &v1);
  return v2;
}

//----- (1000BAD0) --------------------------------------------------------
char __fastcall sub_1000BAD0(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_10033160(42, (_BYTE *)&v2 + 2);
  if ( sub_10032AE0(3162, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_10032C70(3162, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (1000BB20) --------------------------------------------------------
char __cdecl sub_1000BB20(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_is_booting(a1);
  SYS_exit_krnl();
  return v1;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EEE: using guessed type int __cdecl SYS_pvg_is_booting(_DWORD);
// 10035EF4: using guessed type int SYS_enter_krnl(void);

//----- (1000BB40) --------------------------------------------------------
int __cdecl sub_1000BB40(int a1, char *a2)
{
  if ( (unsigned __int8)a1 >= 0x5Fu )
    sub_10011520("..\\lib\\adl\\sys_usr.c", 5389, 1, 0);
  if ( !a2 )
    sub_10011520("..\\lib\\adl\\sys_usr.c", 5390, 1, 0);
  SYS_enter_krnl();
  SYS_pvg_var_ctrl(a1, a2);
  return SYS_exit_krnl();
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035EFA: using guessed type int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD);

//----- (1000BBA0) --------------------------------------------------------
char __thiscall sub_1000BBA0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1000BB40(35, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1000BBC0) --------------------------------------------------------
char __thiscall sub_1000BBC0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1000BB40(18, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1000BBE0) --------------------------------------------------------
char __thiscall sub_1000BBE0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1000BB40(17, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1000BC00) --------------------------------------------------------
int __thiscall sub_1000BC00(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_1000BB40(29, (char *)&v2);
  return (int)v2;
}

//----- (1000BC20) --------------------------------------------------------
char __thiscall sub_1000BC20(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1000BB40(34, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1000BC40) --------------------------------------------------------
char __thiscall sub_1000BC40(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1000BB40(44, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1000BC60) --------------------------------------------------------
BOOL sub_1000BC60()
{
  char v1; // [sp+1h] [bp-1h]@1

  v1 = 1;
  sub_1000BB40(49, &v1);
  return v1 == 0;
}

//----- (1000BC80) --------------------------------------------------------
int __usercall sub_1000BC80@<eax>(int a1@<edx>, int a2@<ecx>, int a3)
{
  int result; // eax@4
  int v4; // [sp+0h] [bp-20h]@1
  int v5; // [sp+4h] [bp-1Ch]@1
  int v6; // [sp+8h] [bp-18h]@1
  int v7; // [sp+Ch] [bp-14h]@1
  int v8; // [sp+10h] [bp-10h]@1
  int *v9; // [sp+14h] [bp-Ch]@1
  int v10; // [sp+18h] [bp-8h]@1
  int v11; // [sp+1Ch] [bp-4h]@1

  v6 = 0;
  v11 = a2 != 0 ? 4 : 1;
  v4 = a2;
  v7 = a1;
  v8 = 56;
  v9 = &v4;
  v10 = 500;
  v5 = a3;
  if ( sub_10032E30() == 37 )
    v10 = 0;
  if ( sub_10033010(49, (int)&v7) )
  {
    sub_10011520("..\\lib\\adl\\mon_log_intf.c", 1267, 0, 0);
    result = 0;
  }
  else
  {
    result = (unsigned __int8)v6;
  }
  return result;
}

//----- (1000BD30) --------------------------------------------------------
int __cdecl sub_1000BD30(__int16 a1, __int16 a2, char a3, unsigned __int8 a4, char a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-7Ch]@2
  __int16 v8; // [sp+8h] [bp-78h]@1
  __int16 v9; // [sp+Ch] [bp-74h]@1
  char v10; // [sp+10h] [bp-70h]@1
  char v11; // [sp+40h] [bp-40h]@1
  unsigned int v12; // [sp+4Ch] [bp-34h]@2
  unsigned int v13; // [sp+74h] [bp-Ch]@2
  unsigned int v14; // [sp+78h] [bp-8h]@2

  v10 = a5;
  v5 = 6916 * a4;
  v9 = a4;
  v8 = -32767;
  *(_WORD *)(v5 + dword_1025443C) = a1;
  *(_BYTE *)(v5 + dword_1025443C + 3) = a3;
  *(_WORD *)(v5 + dword_1025443C + 16) = a2;
  if ( sub_10012200(0, 148, 0, 60, &v11) )
  {
    sub_10013980(&v7, v13);
    *(_DWORD *)(v5 + dword_1025443C + 4) = v7;
    sub_10013AC0(&v7, v14);
    *(_DWORD *)(v5 + dword_1025443C + 4) += v7;
    *(_DWORD *)(v5 + dword_1025443C + 8) = v12 / 0xF4240;
  }
  else if ( !sub_10018720((char *)(v5 + dword_1025443C + 4)) )
  {
    *(_DWORD *)(v5 + dword_1025443C + 4) = 0;
  }
  return sub_1000BC80((int)&v8, 0, 0);
}
// 1025443C: using guessed type int dword_1025443C;

//----- (1000BE60) --------------------------------------------------------
int __cdecl sub_1000BE60(int a1)
{
  SYS_enter_krnl();
  SYS_pvg_alrt_audio_get(a1);
  return SYS_exit_krnl();
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F00: using guessed type int __cdecl SYS_pvg_alrt_audio_get(_DWORD);

//----- (1000BE80) --------------------------------------------------------
__int16 __cdecl sub_1000BE80(int a1, int a2, int a3)
{
  __int16 v3; // si@1

  SYS_enter_krnl();
  v3 = SYS_pvg_alrt_cnt(a1, a2, a3, 2);
  SYS_exit_krnl();
  return v3;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F06: using guessed type int __cdecl SYS_pvg_alrt_cnt(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1000BEB0) --------------------------------------------------------
int __cdecl sub_1000BEB0(int a1)
{
  SYS_enter_krnl();
  SYS_pvg_alrt_get_actv_set_audio(a1);
  return SYS_exit_krnl();
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F0C: using guessed type int __cdecl SYS_pvg_alrt_get_actv_set_audio(_DWORD);

//----- (1000BED0) --------------------------------------------------------
char __cdecl sub_1000BED0(_DWORD *a1)
{
  int v1; // ecx@1
  char result; // al@3
  int v3; // [sp+4h] [bp-4h]@1

  v3 = 0;
  sub_10032B80(9210, (int)&v3, 4);
  v1 = v3;
  if ( a1 )
    *a1 = v3;
  result = 1;
  if ( v1 != dword_101A8CDC )
    result = 0;
  return result;
}
// 101A8CDC: using guessed type int dword_101A8CDC;

//----- (1000BF10) --------------------------------------------------------
char __cdecl sub_1000BF10(int a1, int a2)
{
  char v2; // bl@1

  SYS_enter_krnl();
  v2 = SYS_pvg_alrt_get_hdr(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F12: using guessed type int __cdecl SYS_pvg_alrt_get_hdr(_DWORD, _DWORD);

//----- (1000BF40) --------------------------------------------------------
char __cdecl sub_1000BF40(int a1, int a2, int a3)
{
  char v3; // bl@1

  SYS_enter_krnl();
  v3 = SYS_pvg_alrt_get_hdr_text(a1, a2, a3);
  SYS_exit_krnl();
  return v3;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F18: using guessed type int __cdecl SYS_pvg_alrt_get_hdr_text(_DWORD, _DWORD, _DWORD);

//----- (1000BF70) --------------------------------------------------------
char __cdecl sub_1000BF70(int a1, int a2, int a3, int a4)
{
  char v4; // bl@1

  SYS_enter_krnl();
  v4 = SYS_pvg_alrt_get_hdr_text_lvl(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F1E: using guessed type int __cdecl SYS_pvg_alrt_get_hdr_text_lvl(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1000BFA0) --------------------------------------------------------
char __cdecl sub_1000BFA0(int a1, int a2)
{
  char v2; // bl@1

  SYS_enter_krnl();
  v2 = SYS_pvg_alrt_id_is_set(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F24: using guessed type int __cdecl SYS_pvg_alrt_id_is_set(_DWORD, _DWORD);

//----- (1000BFD0) --------------------------------------------------------
char __cdecl sub_1000BFD0(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_is_acked(a1);
  SYS_exit_krnl();
  return v1;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F2A: using guessed type int __cdecl SYS_pvg_alrt_is_acked(_DWORD);

//----- (1000BFF0) --------------------------------------------------------
char __cdecl sub_1000BFF0(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_is_set(a1);
  SYS_exit_krnl();
  return v1;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F30: using guessed type int __cdecl SYS_pvg_alrt_is_set(_DWORD);

//----- (1000C010) --------------------------------------------------------
char __cdecl sub_1000C010(__int16 a1, char a2)
{
  char v2; // bl@1
  __int16 v4; // [sp+4h] [bp-A0h]@1

  memset(&v4, 0, 0x9Cu);
  v4 = a1;
  SYS_enter_krnl();
  v2 = SYS_pvg_alrt_is_set_data(&v4, &a2, 4);
  SYS_exit_krnl();
  return v2;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F36: using guessed type int __cdecl SYS_pvg_alrt_is_set_data(_DWORD, _DWORD, _DWORD);

//----- (1000C080) --------------------------------------------------------
char __cdecl sub_1000C080(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_is_set_queued(a1);
  SYS_exit_krnl();
  return v1;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F3C: using guessed type int __cdecl SYS_pvg_alrt_is_set_queued(_DWORD);

//----- (1000C0A0) --------------------------------------------------------
char __cdecl sub_1000C0A0(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_is_set_text(a1, 1);
  SYS_exit_krnl();
  return v1;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F42: using guessed type int __cdecl SYS_pvg_alrt_is_set_text(_DWORD, _DWORD);

//----- (1000C0C0) --------------------------------------------------------
char __cdecl sub_1000C0C0(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_is_viewed(a1);
  SYS_exit_krnl();
  return v1;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F48: using guessed type int __cdecl SYS_pvg_alrt_is_viewed(_DWORD);

//----- (1000C0E0) --------------------------------------------------------
int __cdecl sub_1000C0E0(int a1, int a2, int a3)
{
  SYS_enter_krnl();
  SYS_pvg_alrt_queue(a1, a2, a3);
  return SYS_exit_krnl();
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F4E: using guessed type int __cdecl SYS_pvg_alrt_queue(_DWORD, _DWORD, _DWORD);

//----- (1000C110) --------------------------------------------------------
int __cdecl sub_1000C110(int a1)
{
  SYS_enter_krnl();
  SYS_pvg_alrt_queue_flush(a1);
  return SYS_exit_krnl();
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F54: using guessed type int __cdecl SYS_pvg_alrt_queue_flush(_DWORD);

//----- (1000C130) --------------------------------------------------------
int __cdecl sub_1000C130(int a1)
{
  if ( !sub_1000BED0(0) )
    sub_10011520("..\\lib\\adl\\sys_usr_alrt.c", 1371, 0, "Non-alert master attempted to alter the alert's database");
  SYS_enter_krnl();
  SYS_pvg_alrt_set(a1);
  return SYS_exit_krnl();
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F5A: using guessed type int __cdecl SYS_pvg_alrt_set(_DWORD);

//----- (1000C170) --------------------------------------------------------
int __cdecl sub_1000C170(const void *a1, unsigned __int16 a2, char a3, int a4)
{
  int *v4; // edi@6
  char v5; // al@7
  int v6; // ebx@8
  char *v7; // eax@8
  char v8; // dl@9
  unsigned int v9; // eax@10
  const void *v10; // esi@10
  _BYTE *v11; // edi@10
  char v12; // cl@11
  char *v13; // edi@12
  char *v14; // esi@12
  int v15; // ecx@12
  char *v16; // eax@12
  char v17; // dl@13
  unsigned int v18; // eax@14
  int *v19; // edi@14
  char v20; // cl@15
  int v22; // [sp+10h] [bp-B0h]@3
  int v23; // [sp+14h] [bp-ACh]@1
  char v24; // [sp+18h] [bp-A8h]@3
  _BYTE v25[3]; // [sp+19h] [bp-A7h]@10
  char v26; // [sp+1Ah] [bp-A6h]@4
  int v27; // [sp+38h] [bp-88h]@6
  char v28; // [sp+39h] [bp-87h]@4

  v23 = (int)a1;
  if ( !sub_1000BED0(0) )
    sub_10011520("..\\lib\\adl\\sys_usr_alrt.c", 1427, 0, "Non-alert master attempted to alter the alert's database");
  qmemcpy(&v24, a1, 0x9Cu);
  v22 = a2 + 100 * a4;
  if ( a3 )
  {
    sub_1000BA20(a3, &v26, 0x1Fu);
    sub_1000BA20(a3, &v28, 0x33u);
  }
  else
  {
    sub_1000B990(a4, (int)&v26, 31);
    sub_1000B990(a4, (int)&v28, 51);
  }
  v4 = &v27;
  do
  {
    v5 = *((_BYTE *)v4 + 1);
    v4 = (int *)((char *)v4 + 1);
  }
  while ( v5 );
  v6 = v23;
  *(_WORD *)v4 = 32;
  v7 = (char *)(v6 + 2);
  do
    v8 = *v7++;
  while ( v8 );
  v9 = (unsigned int)&v7[-v6 - 2];
  v10 = (const void *)(v6 + 2);
  v11 = v25;
  do
    v12 = (v11++)[1];
  while ( v12 );
  qmemcpy(v11, v10, 4 * (v9 >> 2));
  v14 = (char *)v10 + 4 * (v9 >> 2);
  v13 = &v11[4 * (v9 >> 2)];
  v15 = v9 & 3;
  v16 = (char *)(v6 + 33);
  qmemcpy(v13, v14, v15);
  do
    v17 = *v16++;
  while ( v17 );
  v18 = (unsigned int)&v16[-v6 - 33];
  v19 = &v27;
  do
  {
    v20 = *((_BYTE *)v19 + 1);
    v19 = (int *)((char *)v19 + 1);
  }
  while ( v20 );
  qmemcpy(v19, (const void *)(v6 + 33), v18);
  SYS_enter_krnl();
  SYS_pvg_alrt_set_data(&v24, &v22, 4);
  return SYS_exit_krnl();
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F60: using guessed type int __cdecl SYS_pvg_alrt_set_data(_DWORD, _DWORD, _DWORD);

//----- (1000C2D0) --------------------------------------------------------
int __cdecl sub_1000C2D0(int a1, char a2)
{
  if ( !sub_1000BED0(0) )
    sub_10011520("..\\lib\\adl\\sys_usr_alrt.c", 1501, 0, "Non-alert master attempted to alter the alert's database");
  SYS_enter_krnl();
  SYS_pvg_alrt_set_data(a1, &a2, 1);
  return SYS_exit_krnl();
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F60: using guessed type int __cdecl SYS_pvg_alrt_set_data(_DWORD, _DWORD, _DWORD);

//----- (1000C320) --------------------------------------------------------
int __cdecl sub_1000C320(int a1, int a2)
{
  char *v2; // eax@3
  _BYTE *v3; // edx@3
  char v4; // cl@4
  unsigned int v5; // eax@5
  _BYTE *v6; // edi@5
  char v7; // cl@6
  char *v8; // edi@7
  char *v9; // esi@7
  int v10; // ecx@7
  char *v11; // eax@7
  char v12; // dl@8
  unsigned int v13; // eax@9
  int *v14; // edi@9
  char v15; // cl@10
  char v17; // [sp+10h] [bp-A8h]@1
  _BYTE v18[3]; // [sp+11h] [bp-A7h]@5
  char v19; // [sp+12h] [bp-A6h]@3
  int v20; // [sp+30h] [bp-88h]@9
  char v21; // [sp+31h] [bp-87h]@3

  qmemcpy(&v17, (const void *)a1, 0x9Cu);
  if ( !sub_1000BED0(0) )
    sub_10011520("..\\lib\\adl\\sys_usr_alrt.c", 1555, 0, "Non-alert master attempted to alter the alert's database");
  sub_1000B990(a2, (int)&v19, 31);
  sub_1000B990(a2, (int)&v21, 51);
  v2 = (char *)(a1 + 2);
  v3 = (_BYTE *)(a1 + 2);
  do
    v4 = *v2++;
  while ( v4 );
  v5 = v2 - v3;
  v6 = v18;
  do
    v7 = (v6++)[1];
  while ( v7 );
  qmemcpy(v6, v3, 4 * (v5 >> 2));
  v9 = &v3[4 * (v5 >> 2)];
  v8 = &v6[4 * (v5 >> 2)];
  v10 = v5 & 3;
  v11 = (char *)(a1 + 33);
  qmemcpy(v8, v9, v10);
  do
    v12 = *v11++;
  while ( v12 );
  v13 = (unsigned int)&v11[-a1 - 33];
  v14 = &v20;
  do
  {
    v15 = *((_BYTE *)v14 + 1);
    v14 = (int *)((char *)v14 + 1);
  }
  while ( v15 );
  qmemcpy(v14, (const void *)(a1 + 33), v13);
  SYS_enter_krnl();
  SYS_pvg_alrt_set_data(&v17, &a2, 4);
  return SYS_exit_krnl();
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F60: using guessed type int __cdecl SYS_pvg_alrt_set_data(_DWORD, _DWORD, _DWORD);

//----- (1000C430) --------------------------------------------------------
int sub_1000C430()
{
  if ( !sub_1000BED0(0) )
    sub_10011520("..\\lib\\adl\\sys_usr_alrt.c", 1610, 0, "Non-alert master attempted to alter the alert's database");
  SYS_enter_krnl();
  SYS_pvg_alrt_viewed();
  return SYS_exit_krnl();
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F66: using guessed type int SYS_pvg_alrt_viewed(void);

//----- (1000C480) --------------------------------------------------------
int __cdecl sub_1000C480(int a1, int a2)
{
  SYS_enter_krnl();
  SYS_pvg_trig_update(a1, a2);
  return SYS_exit_krnl();
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F72: using guessed type int __cdecl SYS_pvg_trig_update(_DWORD, _DWORD);

//----- (1000C4F0) --------------------------------------------------------
int __cdecl sub_1000C4F0(int a1, int a2, int a3)
{
  if ( !sub_1000BED0(0) )
    sub_10011520("..\\lib\\adl\\sys_usr_alrt.c", 282, 0, "Non-alert master attempted to alter the alert's database");
  SYS_enter_krnl();
  SYS_pvg_alrt_ack(a1, a2, a3);
  return SYS_exit_krnl();
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F78: using guessed type int __cdecl SYS_pvg_alrt_ack(_DWORD, _DWORD, _DWORD);

//----- (1000C540) --------------------------------------------------------
int __cdecl sub_1000C540(int a1)
{
  if ( !sub_1000BED0(0) )
    sub_10011520("..\\lib\\adl\\sys_usr_alrt.c", 352, 0, "Non-alert master attempted to alter the alert's database");
  SYS_enter_krnl();
  SYS_pvg_alrt_clr(a1);
  return SYS_exit_krnl();
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F7E: using guessed type int __cdecl SYS_pvg_alrt_clr(_DWORD);

//----- (1000C580) --------------------------------------------------------
int __cdecl sub_1000C580(int a1, char a2)
{
  if ( !sub_1000BED0(0) )
    sub_10011520("..\\lib\\adl\\sys_usr_alrt.c", 396, 0, "Non-alert master attempted to alter the alert's database");
  SYS_enter_krnl();
  SYS_pvg_alrt_clr_data(a1, &a2, 4);
  return SYS_exit_krnl();
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035F84: using guessed type int __cdecl SYS_pvg_alrt_clr_data(_DWORD, _DWORD, _DWORD);

//----- (1000C5D0) --------------------------------------------------------
char *__cdecl sub_1000C5D0(int a1, int a2, int a3, size_t a4, char *a5)
{
  char v5; // cl@1
  int v6; // eax@1
  int v7; // esi@1
  int v8; // edi@2
  char *v9; // eax@14
  char *v10; // eax@14
  char *v11; // eax@15
  unsigned int v12; // ecx@19
  char v13; // cl@20
  bool v14; // zf@21
  const char *v15; // ecx@21
  char v17[256]; // [sp+Ch] [bp-104h]@8

  v5 = *(_BYTE *)a1;
  v6 = 0;
  v7 = 0;
  if ( !*(_BYTE *)a1 )
    goto LABEL_12;
  v8 = a1;
  do
  {
    if ( v5 == 46 )
    {
      v7 = v6;
    }
    else if ( v5 == 47 || v5 == 92 )
    {
      v6 = 0;
      v7 = 0;
      goto LABEL_9;
    }
    v17[v6++] = v5;
LABEL_9:
    v5 = *(_BYTE *)(v8++ + 1);
  }
  while ( v5 );
  if ( v7 )
  {
    v17[v7] = 0;
    goto LABEL_13;
  }
LABEL_12:
  v17[v6] = 0;
LABEL_13:
  switch ( a2 )
  {
    case 1:
      v9 = sub_10024890("CFG_ActDir", (int)&unk_1005C3FD);
      v10 = sub_10024890("CFG_ActDirRuntime", (int)v9);
      break;
    case 2:
      v11 = sub_10024890("CFG_ExpDir", (int)&unk_1005C3FD);
      v10 = sub_10024890("CFG_ExpDirRuntime", (int)v11);
      break;
    case 3:
      v10 = sub_10024890("CFG_ActDir", (int)&unk_1005C3FD);
      break;
    case 4:
      v10 = sub_10024890("CFG_ExpDir", (int)&unk_1005C3FD);
      break;
    default:
      v10 = (char *)&unk_1005C3FD;
      break;
  }
  v12 = strlen(v10);
  if ( !v12 || (v13 = v10[v12 - 1], v13 == 47) || (v14 = v13 == 92, v15 = "/", v14) )
    v15 = (const char *)&unk_1005C3FD;
  _snprintf(a5, a4, "%s%s%s_%s.bmp", v10, v15, v17, a3);
  a5[a4 - 1] = 0;
  return a5;
}
// 1000C5D0: using guessed type char var_104[256];

//----- (1000C750) --------------------------------------------------------
int sub_1000C750()
{
  return dword_101AD8D0[sub_10022A40()];
}
// 101AD8D0: using guessed type int dword_101AD8D0[];

//----- (1000C760) --------------------------------------------------------
const char *__cdecl sub_1000C760(unsigned int a1)
{
  const char *result; // eax@2

  if ( a1 >= 3 )
    result = "Unknown Type Of Testing";
  else
    result = off_1005E73C[a1];
  return result;
}
// 1005E73C: using guessed type char *off_1005E73C[7];

//----- (1000C780) --------------------------------------------------------
int __cdecl sub_1000C780(int a1, int a2, int a3, int a4)
{
  char v5; // [sp+8h] [bp-204h]@1
  char v6; // [sp+107h] [bp-105h]@1
  char v7; // [sp+108h] [bp-104h]@1
  char v8; // [sp+207h] [bp-5h]@1

  _snprintf(&v5, 0x100u, "%d", a3);
  v6 = 0;
  _snprintf(&v7, 0x100u, "%d", a4);
  v8 = 0;
  return sub_1000AE70(3, (int)"**SUBGROUP**", a1, a2, (int)&v5, (int)&v7);
}

//----- (1000C830) --------------------------------------------------------
int __cdecl sub_1000C830(int a1)
{
  int result; // eax@1

  result = sub_10022A40();
  dword_101AF9DC[result] = a1;
  return result;
}
// 101AF9DC: using guessed type int dword_101AF9DC[];

//----- (1000C850) --------------------------------------------------------
int __cdecl sub_1000C850(int a1)
{
  int result; // eax@1

  result = sub_10022A40();
  dword_101AD8D0[result] = a1;
  return result;
}
// 101AD8D0: using guessed type int dword_101AD8D0[];

//----- (1000C870) --------------------------------------------------------
char *sub_1000C870(char *a1, ...)
{
  int v1; // esi@1
  char *result; // eax@1
  va_list va; // [sp+10h] [bp+8h]@1

  va_start(va, a1);
  v1 = sub_10022A40() << 8;
  _vsnprintf(&byte_101A8CE0[v1], 0x100u, a1, va);
  result = &byte_101A8CE0[v1];
  byte_101A8DDE[v1] = 42;
  byte_101A8DDF[v1] = 0;
  return result;
}

//----- (1000C8B0) --------------------------------------------------------
char *__usercall sub_1000C8B0@<eax>(char a1@<al>, unsigned __int8 a2@<cl>)
{
  char *result; // eax@3

  if ( a2 && a2 != 1 )
    result = off_1005E750[a1 & 1];
  else
    result = off_1005E748[a2];
  return result;
}
// 1005E748: using guessed type char *off_1005E748[4];
// 1005E750: using guessed type char *off_1005E750[2];

//----- (1000C8D0) --------------------------------------------------------
char __usercall sub_1000C8D0@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5)
{
  const char *v5; // ebp@1
  int v6; // edi@1
  char v7; // cl@1
  char result; // al@5
  long double v9; // st7@6
  signed int v10; // eax@7
  int v11; // ecx@10
  int v12; // ebp@10
  int v13; // edx@10
  int v14; // edi@10
  int v15; // edi@16
  int v16; // eax@30
  char v17; // [sp+18h] [bp+4h]@1

  v5 = a2;
  v6 = sub_10022A40();
  v17 = a2[a3 - 2];
  v7 = v17;
  if ( v17 == 100 || v17 == 117 )
  {
    v16 = sub_1000C750() - 1;
    if ( v16 )
    {
      if ( v16 == 1 )
      {
        strncpy((char *)(a1 + 1), v5, a4 - 1);
        *(_BYTE *)(a1 + 1) = 35;
        *(_BYTE *)a1 = 37;
        result = 0;
        *(_BYTE *)(a3 + a1 - 1) = 111;
      }
      else
      {
        strncpy((char *)a1, v5, a4);
        result = 0;
      }
    }
    else
    {
      strncpy((char *)(a1 + 1), v5, a4 - 1);
      *(_BYTE *)(a1 + 1) = 35;
      *(_BYTE *)a1 = 37;
      result = 0;
      *(_BYTE *)(a3 + a1 - 1) = 120;
    }
  }
  else if ( v17 == 102 || v17 == 103 )
  {
    v9 = fabs(a5);
    if ( 0.0 == v9 )
    {
      v10 = 0;
    }
    else
    {
      v10 = (signed int)floor(log10(v9));
      v7 = v17;
    }
    if ( v7 == 102 )
    {
      v11 = dword_101B0FD0[v6];
      v12 = dword_101B0FE4[v6];
      v13 = v11 + v10;
      v14 = v11 + v10;
      if ( v11 + v10 >= 9 )
        v14 = 9;
      if ( v11 <= v14 )
      {
        if ( v13 >= 9 )
          v13 = 9;
      }
      else
      {
        v13 = v11;
      }
    }
    else
    {
      v11 = dword_101AD8E4[v6];
      v12 = dword_101AF9C8[v6];
      v13 = v11 + v10;
      v15 = v11 + v10;
      if ( v11 + v10 >= 14 )
        v15 = 14;
      if ( v11 <= v15 )
      {
        if ( v13 >= 14 )
          v13 = 14;
      }
      else
      {
        v13 = v11;
      }
    }
    if ( v12 )
    {
      if ( v12 == 1 )
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
      else if ( v11 <= v10 || v10 < -4 )
      {
        _snprintf((char *)a1, a4, "%%.%de", v13);
        result = 1;
      }
      else
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
    }
    else
    {
      _snprintf((char *)a1, a4, "%%.%de", v13);
      result = 1;
    }
  }
  else
  {
    strncpy((char *)a1, v5, a4);
    result = 0;
  }
  return result;
}
// 101AD8E4: using guessed type int dword_101AD8E4[];
// 101AF9C8: using guessed type int dword_101AF9C8[];
// 101B0FD0: using guessed type int dword_101B0FD0[];
// 101B0FE4: using guessed type int dword_101B0FE4[];

//----- (1000CAB0) --------------------------------------------------------
int sub_1000CAB0()
{
  nullsub_1("..\\lib\\utf\\utf_verify.c");
  return 0;
}

//----- (1000CAD0) --------------------------------------------------------
int sub_1000CAD0()
{
  return nullsub_1("..\\lib\\utf\\utf_verify.c");
}

//----- (1000CAF0) --------------------------------------------------------
int __cdecl sub_1000CAF0(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_10022A40();
  dword_101AF9C8[result] = a1;
  if ( a2 >= 0 )
  {
    dword_101AD8E4[result] = a2;
    if ( a2 > 14 )
    {
      v3 = sub_1000C870(
             "Floating point (double) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             14);
      result = sub_1000AE30(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"909", (int)v3);
    }
  }
  else
  {
    dword_101AD8E4[result] = 8;
  }
  return result;
}
// 101AD8E4: using guessed type int dword_101AD8E4[];
// 101AF9C8: using guessed type int dword_101AF9C8[];

//----- (1000CB50) --------------------------------------------------------
int __cdecl sub_1000CB50(int a1)
{
  return sub_1000CAF0(0, a1);
}

//----- (1000CB60) --------------------------------------------------------
int __cdecl sub_1000CB60(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_10022A40();
  dword_101B0FE4[result] = a1;
  if ( a2 >= 0 )
  {
    dword_101B0FD0[result] = a2;
    if ( a2 > 9 )
    {
      v3 = sub_1000C870(
             "Floating point (float) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             9);
      result = sub_1000AE30(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"977", (int)v3);
    }
  }
  else
  {
    dword_101B0FD0[result] = 8;
  }
  return result;
}
// 101B0FD0: using guessed type int dword_101B0FD0[];
// 101B0FE4: using guessed type int dword_101B0FE4[];

//----- (1000CBC0) --------------------------------------------------------
int __cdecl sub_1000CBC0(int a1)
{
  return sub_1000CB60(0, a1);
}

//----- (1000CBD0) --------------------------------------------------------
bool __cdecl sub_1000CBD0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  bool v8; // bl@4
  char *v9; // eax@7
  char *v10; // edx@7
  int v11; // esi@8
  int v12; // edi@19
  char *v14; // [sp+Ch] [bp-2Ch]@7
  int v15; // [sp+10h] [bp-28h]@7
  int v16; // [sp+14h] [bp-24h]@7
  int v17; // [sp+18h] [bp-20h]@7
  char *v18; // [sp+1Ch] [bp-1Ch]@7
  char *v19; // [sp+20h] [bp-18h]@7
  const char *v20; // [sp+24h] [bp-14h]@7
  char *v21; // [sp+28h] [bp-10h]@7
  char *v22; // [sp+2Ch] [bp-Ch]@7
  int v23; // [sp+30h] [bp-8h]@8
  int v24; // [sp+34h] [bp-4h]@8

  if ( a2 )
  {
    if ( a6 == 1 )
    {
      if ( a7 )
        goto LABEL_4;
    }
    else if ( a6 || a7 != 1 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
  else
  {
    if ( a6 == 1 )
    {
      if ( a7 != 1 )
      {
LABEL_4:
        v8 = 0;
        goto LABEL_5;
      }
    }
    else if ( a6 || a7 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
LABEL_5:
  if ( sub_100239A0() )
    v8 = v8 == 0;
  v9 = off_1005E720[a2];
  v15 = a3;
  v14 = v9;
  v17 = a5;
  v16 = a4;
  v20 = "bool";
  v10 = off_1005E710[v8 != 0];
  v19 = off_1005E718[a1];
  v18 = v10;
  v21 = sub_1000C8B0(0, a6);
  v22 = sub_1000C8B0(1, a7);
  if ( a8 )
  {
    v23 = 0;
    v24 = a8;
    v11 = 11;
  }
  else
  {
    v11 = 9;
  }
  v12 = sub_10024E90();
  sub_1000AD40(7, (int)&v14, v11);
  sub_10024EA0(v12);
  return v8;
}
// 1005E710: using guessed type char *off_1005E710[18];
// 1005E718: using guessed type char *off_1005E718[16];
// 1005E720: using guessed type char *off_1005E720[14];

//----- (1000CD10) --------------------------------------------------------
bool __cdecl sub_1000CD10(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  int v8; // edi@1
  unsigned __int8 v9; // al@14
  unsigned __int8 v10; // al@17
  int v11; // edi@25
  char *v12; // esi@26
  char *v13; // edx@28
  int v14; // ebx@30
  bool v16; // [sp+1Bh] [bp-5Dh]@2
  char v17; // [sp+1Fh] [bp-59h]@25
  unsigned int v18; // [sp+20h] [bp-58h]@1
  char *v19; // [sp+3Ch] [bp-3Ch]@28
  int v20; // [sp+40h] [bp-38h]@28
  int v21; // [sp+44h] [bp-34h]@28
  int v22; // [sp+48h] [bp-30h]@28
  char *v23; // [sp+4Ch] [bp-2Ch]@28
  char *v24; // [sp+50h] [bp-28h]@28
  const char *v25; // [sp+54h] [bp-24h]@28
  const char *v26; // [sp+58h] [bp-20h]@28
  const char *v27; // [sp+5Ch] [bp-1Ch]@28
  char *v28; // [sp+60h] [bp-18h]@28
  int v29; // [sp+64h] [bp-14h]@29
  char v30; // [sp+68h] [bp-10h]@25

  v8 = sub_10022A40();
  v18 = 9;
  switch ( a2 )
  {
    case 0:
      v16 = a6 == a7;
      break;
    case 1:
      v16 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 4:
      v16 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 6:
      if ( a7 )
        v9 = a7;
      else
        v9 = 0;
      if ( a6 < v9 )
        goto LABEL_38;
      v10 = a7;
      if ( (signed int)a7 >= 255 )
        v10 = -1;
      v16 = 1;
      if ( a6 > v10 )
LABEL_38:
        v16 = 0;
      v18 = 10;
      break;
    default:
LABEL_22:
      v16 = 0;
      break;
  }
  if ( sub_100239A0() )
    v16 = v16 == 0;
  sub_1000C8D0((int)&v30, "%c", 3, 0xCu, (double)a6);
  v11 = 3072 * v8;
  _snprintf(&byte_101A9CD0[v11], 0x400u, &v30, a6);
  byte_101AA0CE[v11] = 42;
  byte_101AA0CF[v11] = 0;
  v17 = sub_1000C8D0((int)&v30, "%c", 3, 0xCu, (double)a7);
  _snprintf(&byte_101AA0D0[v11], 0x400u, &v30, a7);
  byte_101AA4CE[v11] = 42;
  byte_101AA4CF[v11] = 0;
  if ( v18 <= 9 )
  {
    v12 = &byte_101AA4D0[v11];
    byte_101AA4D0[v11] = 0;
  }
  else
  {
    v17 = sub_1000C8D0((int)&v30, "%c", 3, 0xCu, 0.0);
    v12 = &byte_101AA4D0[v11];
    _snprintf(&byte_101AA4D0[v11], 0x400u, &v30, 0);
    byte_101AA8CE[v11] = 42;
    byte_101AA8CF[v11] = 0;
  }
  v19 = off_1005E720[a2];
  v21 = a4;
  v22 = a5;
  v20 = a3;
  v25 = "char";
  v26 = &byte_101A9CD0[v11];
  v27 = &byte_101AA0D0[v11];
  v13 = off_1005E718[a1];
  v23 = off_1005E710[v16 != 0];
  v24 = v13;
  v28 = v12;
  if ( a8 )
  {
    v29 = a8;
    v18 = 11;
  }
  v14 = sub_10024E90();
  sub_1000AD40(7, (int)&v19, v18);
  if ( v17 && a6 != a7 && fabs((double)(a6 - a7)) > 0.0 && !strcmp(v26, v27) )
  {
    nullsub_1(a3);
    sub_1000AE30(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10024EA0(v14);
  return v16;
}
// 1005E710: using guessed type char *off_1005E710[18];
// 1005E718: using guessed type char *off_1005E718[16];
// 1005E720: using guessed type char *off_1005E720[14];

//----- (1000D0C0) --------------------------------------------------------
bool __cdecl sub_1000D0C0(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9)
{
  double v9; // st6@1
  long double v10; // st7@4
  int v11; // edi@8
  int v12; // edi@21
  char *v13; // esi@22
  double v14; // st5@28
  double v15; // st3@30
  double v16; // st5@30
  char *v17; // ecx@37
  int v18; // ebx@39
  bool v20; // [sp+27h] [bp-61h]@10
  char v21; // [sp+2Bh] [bp-5Dh]@21
  unsigned int v22; // [sp+2Ch] [bp-5Ch]@8
  char *v23; // [sp+4Ch] [bp-3Ch]@37
  int v24; // [sp+50h] [bp-38h]@37
  int v25; // [sp+54h] [bp-34h]@37
  int v26; // [sp+58h] [bp-30h]@37
  char *v27; // [sp+5Ch] [bp-2Ch]@37
  char *v28; // [sp+60h] [bp-28h]@37
  const char *v29; // [sp+64h] [bp-24h]@37
  const char *v30; // [sp+68h] [bp-20h]@37
  const char *v31; // [sp+6Ch] [bp-1Ch]@37
  char *v32; // [sp+70h] [bp-18h]@37
  int v33; // [sp+74h] [bp-14h]@38
  char v34; // [sp+78h] [bp-10h]@21

  v9 = a8;
  if ( a2 != 6
    || -0.000001 != a8
    || (a7 >= 0.0 ? (v9 = a7 * 0.000001, v10 = 0.000001) : (v10 = 0.000001, v9 = -0.000001 * a7), v9 >= v10) )
  {
    v10 = v9;
  }
  v11 = sub_10022A40();
  v22 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 1:
      v20 = a7 != a6;
      break;
    case 2:
      if ( a7 != a6 && a7 < a6 )
        goto LABEL_18;
      goto LABEL_14;
    case 3:
      if ( a7 == a6 || a7 < a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 5:
      if ( a7 != a6 && a7 >= a6 )
        goto LABEL_18;
LABEL_14:
      v20 = 1;
      break;
    case 6:
      v14 = v10 - 1.797693134862316e308;
      if ( a7 > v10 - 1.797693134862316e308 )
        v14 = a7;
      v15 = v14;
      v16 = a7;
      if ( v15 - v10 > a6 )
        goto LABEL_47;
      if ( 1.797693134862316e308 - v10 <= a7 )
        v16 = 1.797693134862316e308 - v10;
      if ( v10 + v16 < a6 )
      {
LABEL_47:
        v20 = 0;
        v22 = 10;
      }
      else
      {
        v20 = 1;
        v22 = 10;
      }
      break;
    default:
LABEL_18:
      v20 = 0;
      break;
  }
  if ( sub_100239A0() )
    v20 = v20 == 0;
  sub_1000C8D0((int)&v34, (char *)&unk_1005EA08, 3, 0xCu, a6);
  v12 = 3072 * v11;
  _snprintf(&byte_101A9CD0[v12], 0x400u, &v34);
  byte_101AA0CE[v12] = 42;
  byte_101AA0CF[v12] = 0;
  v21 = sub_1000C8D0((int)&v34, (char *)&unk_1005EA08, 3, 0xCu, a7);
  _snprintf(&byte_101AA0D0[v12], 0x400u, &v34, a7);
  byte_101AA4CE[v12] = 42;
  byte_101AA4CF[v12] = 0;
  if ( v22 <= 9 )
  {
    v13 = &byte_101AA4D0[v12];
    byte_101AA4D0[v12] = 0;
  }
  else
  {
    v13 = &byte_101AA4D0[v12];
    v21 = sub_1000C8D0((int)&v34, (char *)&unk_1005EA08, 3, 0xCu, v10);
    _snprintf(&byte_101AA4D0[v12], 0x400u, &v34, LODWORD(v10), (_DWORD)(*(unsigned __int64 *)&v10 >> 32));
    byte_101AA8CE[v12] = 42;
    byte_101AA8CF[v12] = 0;
  }
  v23 = off_1005E720[a2];
  v26 = a5;
  v25 = a4;
  v24 = a3;
  v29 = "double";
  v30 = &byte_101A9CD0[v12];
  v32 = v13;
  v17 = off_1005E718[a1];
  v27 = off_1005E710[v20 != 0];
  v28 = v17;
  v31 = &byte_101AA0D0[v12];
  if ( a9 )
  {
    v33 = a9;
    v22 = 11;
  }
  v18 = sub_10024E90();
  sub_1000AD40(7, (int)&v23, v22);
  if ( v21 && a6 != a7 && fabs(a6 - a7) > v10 && !strcmp(v30, v31) )
  {
    nullsub_1(a3);
    sub_1000AE30(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10024EA0(v18);
  return v20;
}
// 1005E710: using guessed type char *off_1005E710[18];
// 1005E718: using guessed type char *off_1005E718[16];
// 1005E720: using guessed type char *off_1005E720[14];

//----- (1000D510) --------------------------------------------------------
bool __cdecl sub_1000D510(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9)
{
  double v9; // st7@1
  double v10; // st6@1
  double v11; // st7@4
  float v12; // ST38_4@6
  double v13; // st7@6
  double v14; // st7@8
  double v15; // st6@8
  int v16; // edi@8
  double v17; // st5@24
  double v18; // st3@26
  double v19; // st5@26
  int v20; // edi@35
  char *v21; // esi@36
  char *v22; // ecx@38
  int v23; // ebx@40
  bool v25; // [sp+1Bh] [bp-59h]@10
  char v26; // [sp+1Fh] [bp-55h]@35
  unsigned int v27; // [sp+20h] [bp-54h]@8
  float v28; // [sp+24h] [bp-50h]@8
  char *v29; // [sp+38h] [bp-3Ch]@38
  int v30; // [sp+3Ch] [bp-38h]@38
  int v31; // [sp+40h] [bp-34h]@38
  int v32; // [sp+44h] [bp-30h]@38
  char *v33; // [sp+48h] [bp-2Ch]@38
  char *v34; // [sp+4Ch] [bp-28h]@38
  const char *v35; // [sp+50h] [bp-24h]@38
  const char *v36; // [sp+54h] [bp-20h]@38
  const char *v37; // [sp+58h] [bp-1Ch]@38
  char *v38; // [sp+5Ch] [bp-18h]@38
  int v39; // [sp+60h] [bp-14h]@39
  char v40; // [sp+64h] [bp-10h]@35

  v9 = a7;
  v10 = a8;
  if ( a2 != 6
    || -0.0000099999997 != v10
    || (v9 >= 0.0 ? (v11 = v9 * 0.000009999999747378752) : (v11 = v9 * -0.000009999999747378752),
        v12 = v11,
        v13 = 0.0000099999997,
        v10 = v12,
        v12 >= 0.0000099999997) )
  {
    v13 = v10;
  }
  v28 = v13;
  v14 = v28;
  v15 = a6;
  v16 = sub_10022A40();
  v27 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 1:
      v25 = a7 != a6;
      break;
    case 2:
      if ( a7 != v15 && a7 < (double)a6 )
        goto LABEL_32;
      goto LABEL_14;
    case 3:
      if ( a7 == v15 || a7 < (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 4:
      if ( a7 >= (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 5:
      if ( a7 != v15 && a7 >= (double)a6 )
        goto LABEL_32;
LABEL_14:
      v25 = 1;
      break;
    case 6:
      v17 = v14 - 3.402823466385289e38;
      if ( a7 > v14 - 3.402823466385289e38 )
        v17 = a7;
      v18 = v17 - v14;
      v19 = a7;
      if ( v18 > v15 )
        goto LABEL_48;
      if ( 3.402823466385289e38 - v14 <= v19 )
        v19 = 3.402823466385289e38 - v14;
      if ( v15 > v14 + v19 )
      {
LABEL_48:
        v25 = 0;
        v27 = 10;
      }
      else
      {
        v25 = 1;
        v27 = 10;
      }
      break;
    default:
LABEL_32:
      v25 = 0;
      break;
  }
  if ( sub_100239A0() )
    v25 = v25 == 0;
  sub_1000C8D0((int)&v40, "%f", 3, 0xCu, a6);
  v20 = 3072 * v16;
  _snprintf(&byte_101A9CD0[v20], 0x400u, &v40);
  byte_101AA0CE[v20] = 42;
  byte_101AA0CF[v20] = 0;
  v26 = sub_1000C8D0((int)&v40, "%f", 3, 0xCu, a7);
  _snprintf(&byte_101AA0D0[v20], 0x400u, &v40, a7);
  byte_101AA4CE[v20] = 42;
  byte_101AA4CF[v20] = 0;
  if ( v27 <= 9 )
  {
    v21 = &byte_101AA4D0[v20];
    byte_101AA4D0[v20] = 0;
  }
  else
  {
    v21 = &byte_101AA4D0[v20];
    v26 = sub_1000C8D0((int)&v40, "%f", 3, 0xCu, v28);
    _snprintf(&byte_101AA4D0[v20], 0x400u, &v40, v28);
    byte_101AA8CE[v20] = 42;
    byte_101AA8CF[v20] = 0;
  }
  v29 = off_1005E720[a2];
  v32 = a5;
  v31 = a4;
  v30 = a3;
  v35 = "float";
  v36 = &byte_101A9CD0[v20];
  v37 = &byte_101AA0D0[v20];
  v38 = v21;
  v22 = off_1005E710[v25 != 0];
  v34 = off_1005E718[a1];
  v33 = v22;
  if ( a9 )
  {
    v39 = a9;
    v27 = 11;
  }
  v23 = sub_10024E90();
  sub_1000AD40(7, (int)&v29, v27);
  if ( v26 && a7 != a6 && v28 < fabs(a6 - a7) && !strcmp(v36, v37) )
  {
    nullsub_1(a3);
    sub_1000AE30(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10024EA0(v23);
  return v25;
}
// 1005E710: using guessed type char *off_1005E710[18];
// 1005E718: using guessed type char *off_1005E718[16];
// 1005E720: using guessed type char *off_1005E720[14];

//----- (1000D9D0) --------------------------------------------------------
bool __cdecl sub_1000D9D0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  void *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10022A40();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_100239A0() )
    v17 = v17 == 0;
  sub_1000C8D0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101A9CD0[v12], 0x400u, &v31, a6);
  byte_101AA0CE[v12] = 42;
  byte_101AA0CF[v12] = 0;
  v18 = sub_1000C8D0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_101AA0D0[v12], 0x400u, &v31, a7);
  byte_101AA4CE[v12] = 42;
  byte_101AA4CF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101AA4D0[v12];
    byte_101AA4D0[v12] = 0;
  }
  else
  {
    v18 = sub_1000C8D0((int)&v31, "%d", 3, 0xCu, (double)a8);
    v13 = &byte_101AA4D0[v12];
    _snprintf(&byte_101AA4D0[v12], 0x400u, &v31, a8);
    byte_101AA8CE[v12] = 42;
    byte_101AA8CF[v12] = 0;
  }
  v20 = off_1005E720[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = &unk_1005EA54;
  v27 = &byte_101A9CD0[v12];
  v28 = &byte_101AA0D0[v12];
  v29 = v13;
  v14 = off_1005E710[v17 != 0];
  v25 = off_1005E718[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10024E90();
  sub_1000AD40(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3);
    sub_1000AE30(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10024EA0(v15);
  return v17;
}
// 1005E710: using guessed type char *off_1005E710[18];
// 1005E718: using guessed type char *off_1005E718[16];
// 1005E720: using guessed type char *off_1005E720[14];

//----- (1000DD90) --------------------------------------------------------
bool __cdecl sub_1000DD90(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9)
{
  int v9; // edi@1
  __int16 v10; // ax@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10022A40();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 0x8000;
      if ( v11 < a7 )
        LOWORD(v11) = a7;
      if ( a6 < (signed __int16)(v11 - a8) )
        goto LABEL_37;
      if ( 0x7FFF - a8 <= a7 )
        v10 = 0x7FFF - a8;
      v17 = 1;
      if ( a6 > (signed __int16)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_100239A0() )
    v17 = v17 == 0;
  sub_1000C8D0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101A9CD0[v12], 0x400u, &v31, a6);
  byte_101AA0CE[v12] = 42;
  byte_101AA0CF[v12] = 0;
  v18 = sub_1000C8D0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_101AA0D0[v12], 0x400u, &v31, a7);
  byte_101AA4CE[v12] = 42;
  byte_101AA4CF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101AA4D0[v12];
    byte_101AA4D0[v12] = 0;
  }
  else
  {
    v13 = &byte_101AA4D0[v12];
    v18 = sub_1000C8D0((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_101AA4D0[v12], 0x400u, &v31, a8);
    byte_101AA8CE[v12] = 42;
    byte_101AA8CF[v12] = 0;
  }
  v20 = off_1005E720[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_101A9CD0[v12];
  v21 = a3;
  v26 = "sint16";
  v28 = &byte_101AA0D0[v12];
  v29 = v13;
  v14 = off_1005E718[a1];
  v24 = off_1005E710[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10024E90();
  sub_1000AD40(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3);
    sub_1000AE30(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10024EA0(v15);
  return v17;
}
// 1005E710: using guessed type char *off_1005E710[18];
// 1005E718: using guessed type char *off_1005E718[16];
// 1005E720: using guessed type char *off_1005E720[14];

//----- (1000E190) --------------------------------------------------------
bool __cdecl sub_1000E190(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10022A40();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_100239A0() )
    v17 = v17 == 0;
  sub_1000C8D0((int)&v31, (char *)&unk_1005E0A8, 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101A9CD0[v12], 0x400u, &v31, a6);
  byte_101AA0CE[v12] = 42;
  byte_101AA0CF[v12] = 0;
  v18 = sub_1000C8D0((int)&v31, (char *)&unk_1005E0A8, 4, 0xCu, (double)a7);
  _snprintf(&byte_101AA0D0[v12], 0x400u, &v31, a7);
  byte_101AA4CE[v12] = 42;
  byte_101AA4CF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101AA4D0[v12];
    byte_101AA4D0[v12] = 0;
  }
  else
  {
    v18 = sub_1000C8D0((int)&v31, (char *)&unk_1005E0A8, 4, 0xCu, (double)a8);
    v13 = &byte_101AA4D0[v12];
    _snprintf(&byte_101AA4D0[v12], 0x400u, &v31, a8);
    byte_101AA8CE[v12] = 42;
    byte_101AA8CF[v12] = 0;
  }
  v20 = off_1005E720[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "sint32";
  v27 = &byte_101A9CD0[v12];
  v28 = &byte_101AA0D0[v12];
  v29 = v13;
  v14 = off_1005E710[v17 != 0];
  v25 = off_1005E718[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10024E90();
  sub_1000AD40(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3);
    sub_1000AE30(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10024EA0(v15);
  return v17;
}
// 1005E710: using guessed type char *off_1005E710[18];
// 1005E718: using guessed type char *off_1005E718[16];
// 1005E720: using guessed type char *off_1005E720[14];

//----- (1000E550) --------------------------------------------------------
bool __cdecl sub_1000E550(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9)
{
  unsigned int v9; // edx@22
  unsigned int v10; // esi@22
  unsigned int v11; // eax@27
  int v12; // ecx@27
  int v13; // edi@37
  char *v14; // esi@38
  char *v15; // edx@40
  int v16; // ebx@42
  bool v18; // [sp+1Bh] [bp-5Dh]@3
  char v19; // [sp+1Fh] [bp-59h]@37
  unsigned int v20; // [sp+20h] [bp-58h]@1
  int v21; // [sp+30h] [bp-48h]@1
  char *v22; // [sp+3Ch] [bp-3Ch]@40
  int v23; // [sp+40h] [bp-38h]@40
  int v24; // [sp+44h] [bp-34h]@40
  int v25; // [sp+48h] [bp-30h]@40
  char *v26; // [sp+4Ch] [bp-2Ch]@40
  char *v27; // [sp+50h] [bp-28h]@40
  const char *v28; // [sp+54h] [bp-24h]@40
  const char *v29; // [sp+58h] [bp-20h]@40
  const char *v30; // [sp+5Ch] [bp-1Ch]@40
  char *v31; // [sp+60h] [bp-18h]@40
  int v32; // [sp+64h] [bp-14h]@41
  char v33; // [sp+68h] [bp-10h]@37

  v21 = sub_10022A40();
  v20 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 1:
      v18 = a6 != a7;
      goto LABEL_35;
    case 2:
      if ( a6 != a7
        && SHIDWORD(a6) >= SHIDWORD(a7)
        && (SHIDWORD(a6) > SHIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || SHIDWORD(a6) > SHIDWORD(a7) )
        goto LABEL_34;
      if ( SHIDWORD(a6) < SHIDWORD(a7) )
      {
LABEL_9:
        v18 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_34:
        v18 = 0;
      }
      else
      {
        v18 = 1;
      }
LABEL_35:
      if ( sub_100239A0() )
        v18 = v18 == 0;
      sub_1000C8D0((int)&v33, "%I64d", 6, 0xCu, (double)a6);
      v13 = 3072 * v21;
      _snprintf(&byte_101A9CD0[3072 * v21], 0x400u, &v33, a6);
      byte_101AA0CE[v13] = 42;
      byte_101AA0CF[v13] = 0;
      v19 = sub_1000C8D0((int)&v33, "%I64d", 6, 0xCu, (double)a7);
      _snprintf(&byte_101AA0D0[3072 * v21], 0x400u, &v33, a7);
      byte_101AA4CE[v13] = 42;
      byte_101AA4CF[v13] = 0;
      if ( v20 <= 9 )
      {
        v14 = &byte_101AA4D0[v13];
        byte_101AA4D0[v13] = 0;
      }
      else
      {
        v19 = sub_1000C8D0((int)&v33, "%I64d", 6, 0xCu, (double)a8);
        v14 = &byte_101AA4D0[v13];
        _snprintf(&byte_101AA4D0[v13], 0x400u, &v33, a8);
        byte_101AA8CE[v13] = 42;
        byte_101AA8CF[v13] = 0;
      }
      v22 = off_1005E720[a2];
      v24 = a4;
      v25 = a5;
      v23 = a3;
      v28 = "sint64";
      v29 = &byte_101A9CD0[3072 * v21];
      v30 = &byte_101AA0D0[3072 * v21];
      v15 = off_1005E718[a1];
      v26 = off_1005E710[v18 != 0];
      v27 = v15;
      v31 = v14;
      if ( a9 )
      {
        v32 = a9;
        v20 = 11;
      }
      v16 = sub_10024E90();
      sub_1000AD40(7, (int)&v22, v20);
      if ( v19 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v29, v30) )
      {
        nullsub_1(a3);
        sub_1000AE30(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_10024EA0(v16);
      return v18;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 5:
      if ( a6 != a7
        && SHIDWORD(a6) <= SHIDWORD(a7)
        && (SHIDWORD(a6) < SHIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      v18 = 1;
      goto LABEL_35;
    case 6:
      v9 = a8;
      v10 = HIDWORD(a8) + 2147483648;
      if ( (signed int)(HIDWORD(a8) + 2147483648) < SHIDWORD(a7)
        || (signed int)(HIDWORD(a8) + 2147483648) <= SHIDWORD(a7) && (unsigned int)a8 < (unsigned int)a7 )
      {
        v10 = HIDWORD(a7);
        v9 = a7;
      }
      if ( a6 < (signed __int64)(__PAIR__(v10, v9) - a8) )
        goto LABEL_50;
      v11 = -1 - a8;
      v12 = 0x7FFFFFFF - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > SHIDWORD(a7) || v12 >= SHIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_50:
        v18 = 0;
        v20 = 10;
      }
      else
      {
        v18 = 1;
        v20 = 10;
      }
      goto LABEL_35;
    default:
      goto LABEL_34;
  }
}
// 1005E710: using guessed type char *off_1005E710[18];
// 1005E718: using guessed type char *off_1005E718[16];
// 1005E720: using guessed type char *off_1005E720[14];

//----- (1000EA90) --------------------------------------------------------
bool __cdecl sub_1000EA90(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9)
{
  int v9; // edi@1
  char v10; // al@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10022A40();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 128;
      if ( v11 < a7 )
        LOBYTE(v11) = a7;
      if ( a6 < (char)(v11 - a8) )
        goto LABEL_37;
      if ( 127 - a8 <= a7 )
        v10 = 127 - a8;
      v17 = 1;
      if ( a6 > (char)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_100239A0() )
    v17 = v17 == 0;
  sub_1000C8D0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101A9CD0[v12], 0x400u, &v31, a6);
  byte_101AA0CE[v12] = 42;
  byte_101AA0CF[v12] = 0;
  v18 = sub_1000C8D0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_101AA0D0[v12], 0x400u, &v31, a7);
  byte_101AA4CE[v12] = 42;
  byte_101AA4CF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101AA4D0[v12];
    byte_101AA4D0[v12] = 0;
  }
  else
  {
    v13 = &byte_101AA4D0[v12];
    v18 = sub_1000C8D0((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_101AA4D0[v12], 0x400u, &v31, a8);
    byte_101AA8CE[v12] = 42;
    byte_101AA8CF[v12] = 0;
  }
  v20 = off_1005E720[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_101A9CD0[v12];
  v21 = a3;
  v26 = "sint8";
  v28 = &byte_101AA0D0[v12];
  v29 = v13;
  v14 = off_1005E718[a1];
  v24 = off_1005E710[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10024E90();
  sub_1000AD40(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3);
    sub_1000AE30(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10024EA0(v15);
  return v17;
}
// 1005E710: using guessed type char *off_1005E710[18];
// 1005E718: using guessed type char *off_1005E718[16];
// 1005E720: using guessed type char *off_1005E720[14];

//----- (1000EE70) --------------------------------------------------------
bool __cdecl sub_1000EE70(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10022A40();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_100239A0() )
    v17 = v17 == 0;
  sub_1000C8D0((int)&v31, (char *)&unk_1005E0A8, 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101A9CD0[v12], 0x400u, &v31, a6);
  byte_101AA0CE[v12] = 42;
  byte_101AA0CF[v12] = 0;
  v18 = sub_1000C8D0((int)&v31, (char *)&unk_1005E0A8, 4, 0xCu, (double)a7);
  _snprintf(&byte_101AA0D0[v12], 0x400u, &v31, a7);
  byte_101AA4CE[v12] = 42;
  byte_101AA4CF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101AA4D0[v12];
    byte_101AA4D0[v12] = 0;
  }
  else
  {
    v18 = sub_1000C8D0((int)&v31, (char *)&unk_1005E0A8, 4, 0xCu, (double)a8);
    v13 = &byte_101AA4D0[v12];
    _snprintf(&byte_101AA4D0[v12], 0x400u, &v31, a8);
    byte_101AA8CE[v12] = 42;
    byte_101AA8CF[v12] = 0;
  }
  v20 = off_1005E720[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "long int";
  v27 = &byte_101A9CD0[v12];
  v28 = &byte_101AA0D0[v12];
  v29 = v13;
  v14 = off_1005E710[v17 != 0];
  v25 = off_1005E718[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10024E90();
  sub_1000AD40(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3);
    sub_1000AE30(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10024EA0(v15);
  return v17;
}
// 1005E710: using guessed type char *off_1005E710[18];
// 1005E718: using guessed type char *off_1005E718[16];
// 1005E720: using guessed type char *off_1005E720[14];

//----- (1000F230) --------------------------------------------------------
bool __cdecl sub_1000F230(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10022A40();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_100239A0() )
    v17 = v17 == 0;
  sub_1000C8D0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101A9CD0[v12], 0x400u, &v31, a6);
  byte_101AA0CE[v12] = 42;
  byte_101AA0CF[v12] = 0;
  v18 = sub_1000C8D0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_101AA0D0[v12], 0x400u, &v31, a7);
  byte_101AA4CE[v12] = 42;
  byte_101AA4CF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101AA4D0[v12];
    byte_101AA4D0[v12] = 0;
  }
  else
  {
    v18 = sub_1000C8D0((int)&v31, "%u", 3, 0xCu, (double)a8);
    v13 = &byte_101AA4D0[v12];
    _snprintf(&byte_101AA4D0[v12], 0x400u, &v31, a8);
    byte_101AA8CE[v12] = 42;
    byte_101AA8CF[v12] = 0;
  }
  v20 = off_1005E720[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned int";
  v29 = v13;
  v14 = off_1005E710[v17 != 0];
  v25 = off_1005E718[a1];
  v24 = v14;
  v27 = &byte_101A9CD0[v12];
  v28 = &byte_101AA0D0[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10024E90();
  sub_1000AD40(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3);
    sub_1000AE30(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10024EA0(v15);
  return v17;
}
// 1005E710: using guessed type char *off_1005E710[18];
// 1005E718: using guessed type char *off_1005E718[16];
// 1005E720: using guessed type char *off_1005E720[14];

//----- (1000F5D0) --------------------------------------------------------
bool __cdecl sub_1000F5D0(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9)
{
  int v9; // edi@1
  unsigned __int16 v10; // ax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10022A40();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int16)(v10 - a8) )
        goto LABEL_37;
      v11 = 0xFFFF - a8;
      if ( v11 > a7 )
        LOWORD(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int16)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_100239A0() )
    v17 = v17 == 0;
  sub_1000C8D0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101A9CD0[v12], 0x400u, &v31, a6);
  byte_101AA0CE[v12] = 42;
  byte_101AA0CF[v12] = 0;
  v18 = sub_1000C8D0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_101AA0D0[v12], 0x400u, &v31, a7);
  byte_101AA4CE[v12] = 42;
  byte_101AA4CF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101AA4D0[v12];
    byte_101AA4D0[v12] = 0;
  }
  else
  {
    v13 = &byte_101AA4D0[v12];
    v18 = sub_1000C8D0((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_101AA4D0[v12], 0x400u, &v31, a8);
    byte_101AA8CE[v12] = 42;
    byte_101AA8CF[v12] = 0;
  }
  v20 = off_1005E720[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_101A9CD0[v12];
  v21 = a3;
  v26 = "uint16";
  v28 = &byte_101AA0D0[v12];
  v29 = v13;
  v14 = off_1005E718[a1];
  v24 = off_1005E710[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10024E90();
  sub_1000AD40(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3);
    sub_1000AE30(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10024EA0(v15);
  return v17;
}
// 1005E710: using guessed type char *off_1005E710[18];
// 1005E718: using guessed type char *off_1005E718[16];
// 1005E720: using guessed type char *off_1005E720[14];

//----- (1000F9D0) --------------------------------------------------------
bool __cdecl sub_1000F9D0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10022A40();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_100239A0() )
    v17 = v17 == 0;
  sub_1000C8D0((int)&v31, (char *)&unk_1005E0AC, 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101A9CD0[v12], 0x400u, &v31, a6);
  byte_101AA0CE[v12] = 42;
  byte_101AA0CF[v12] = 0;
  v18 = sub_1000C8D0((int)&v31, (char *)&unk_1005E0AC, 4, 0xCu, (double)a7);
  _snprintf(&byte_101AA0D0[v12], 0x400u, &v31, a7);
  byte_101AA4CE[v12] = 42;
  byte_101AA4CF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101AA4D0[v12];
    byte_101AA4D0[v12] = 0;
  }
  else
  {
    v18 = sub_1000C8D0((int)&v31, (char *)&unk_1005E0AC, 4, 0xCu, (double)a8);
    v13 = &byte_101AA4D0[v12];
    _snprintf(&byte_101AA4D0[v12], 0x400u, &v31, a8);
    byte_101AA8CE[v12] = 42;
    byte_101AA8CF[v12] = 0;
  }
  v20 = off_1005E720[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "uint32";
  v29 = v13;
  v14 = off_1005E710[v17 != 0];
  v25 = off_1005E718[a1];
  v24 = v14;
  v27 = &byte_101A9CD0[v12];
  v28 = &byte_101AA0D0[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10024E90();
  sub_1000AD40(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3);
    sub_1000AE30(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10024EA0(v15);
  return v17;
}
// 1005E710: using guessed type char *off_1005E710[18];
// 1005E718: using guessed type char *off_1005E718[16];
// 1005E720: using guessed type char *off_1005E720[14];

//----- (1000FD70) --------------------------------------------------------
bool __cdecl sub_1000FD70(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9)
{
  unsigned int v9; // esi@22
  unsigned int v10; // edx@23
  unsigned int v11; // eax@26
  unsigned int v12; // ecx@26
  int v13; // edi@36
  char *v14; // ebx@36
  char *v15; // esi@37
  char *v16; // ecx@39
  int v17; // ebx@41
  bool v19; // [sp+18h] [bp-64h]@3
  char v20; // [sp+27h] [bp-55h]@36
  unsigned int v21; // [sp+28h] [bp-54h]@1
  int v22; // [sp+2Ch] [bp-50h]@1
  char *v23; // [sp+2Ch] [bp-50h]@36
  char *v24; // [sp+40h] [bp-3Ch]@39
  int v25; // [sp+44h] [bp-38h]@39
  int v26; // [sp+48h] [bp-34h]@39
  int v27; // [sp+4Ch] [bp-30h]@39
  char *v28; // [sp+50h] [bp-2Ch]@39
  char *v29; // [sp+54h] [bp-28h]@39
  const char *v30; // [sp+58h] [bp-24h]@39
  const char *v31; // [sp+5Ch] [bp-20h]@39
  const char *v32; // [sp+60h] [bp-1Ch]@39
  char *v33; // [sp+64h] [bp-18h]@39
  int v34; // [sp+68h] [bp-14h]@40
  char v35; // [sp+6Ch] [bp-10h]@36

  v22 = sub_10022A40();
  v21 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 1:
      v19 = a6 != a7;
      goto LABEL_34;
    case 2:
      if ( a6 != a7 && HIDWORD(a6) >= HIDWORD(a7) && (HIDWORD(a6) > HIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
        goto LABEL_33;
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || HIDWORD(a6) > HIDWORD(a7) )
        goto LABEL_33;
      if ( HIDWORD(a6) < HIDWORD(a7) )
      {
LABEL_9:
        v19 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_33:
        v19 = 0;
      }
      else
      {
        v19 = 1;
      }
LABEL_34:
      if ( sub_100239A0() )
        v19 = v19 == 0;
      sub_1000C8D0((int)&v35, "%I64u", 6, 0xCu, (double)a6);
      v13 = 3072 * v22;
      v14 = &byte_101A9CD0[3072 * v22];
      _snprintf(&byte_101A9CD0[3072 * v22], 0x400u, &v35, a6);
      byte_101AA0CE[v13] = 42;
      byte_101AA0CF[v13] = 0;
      v20 = sub_1000C8D0((int)&v35, "%I64u", 6, 0xCu, (double)a7);
      v23 = &byte_101AA0D0[3072 * v22];
      _snprintf(&byte_101AA0D0[v13], 0x400u, &v35, a7);
      byte_101AA4CE[v13] = 42;
      byte_101AA4CF[v13] = 0;
      if ( v21 <= 9 )
      {
        v15 = &byte_101AA4D0[v13];
        byte_101AA4D0[v13] = 0;
      }
      else
      {
        v20 = sub_1000C8D0((int)&v35, "%I64u", 6, 0xCu, (double)a8);
        v15 = &byte_101AA4D0[v13];
        _snprintf(&byte_101AA4D0[v13], 0x400u, &v35, a8);
        byte_101AA8CE[v13] = 42;
        byte_101AA8CF[v13] = 0;
      }
      v24 = off_1005E720[a2];
      v27 = a5;
      v26 = a4;
      v33 = v15;
      v25 = a3;
      v30 = "uint64";
      v31 = v14;
      v16 = off_1005E718[a1];
      v28 = off_1005E710[v19 != 0];
      v29 = v16;
      v32 = v23;
      if ( a9 )
      {
        v34 = a9;
        v21 = 11;
      }
      v17 = sub_10024E90();
      sub_1000AD40(7, (int)&v24, v21);
      if ( v20 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v31, v32) )
      {
        nullsub_1(a3);
        sub_1000AE30(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_10024EA0(v17);
      return v19;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 5:
      if ( a6 != a7 && HIDWORD(a6) <= HIDWORD(a7) && (HIDWORD(a6) < HIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 6:
      v9 = HIDWORD(a7);
      if ( a8 < a7 )
      {
        v10 = a7;
      }
      else
      {
        v9 = HIDWORD(a8);
        v10 = a8;
      }
      if ( a6 < __PAIR__(v9, v10) - a8 )
        goto LABEL_49;
      v11 = -1 - a8;
      v12 = -1 - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > HIDWORD(a7) || v12 >= HIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_49:
        v19 = 0;
        v21 = 10;
      }
      else
      {
        v19 = 1;
        v21 = 10;
      }
      goto LABEL_34;
    default:
      goto LABEL_33;
  }
}
// 1005E710: using guessed type char *off_1005E710[18];
// 1005E718: using guessed type char *off_1005E718[16];
// 1005E720: using guessed type char *off_1005E720[14];

//----- (10010350) --------------------------------------------------------
bool __cdecl sub_10010350(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9)
{
  int v9; // edi@1
  unsigned __int8 v10; // al@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10022A40();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int8)(v10 - a8) )
        goto LABEL_37;
      v11 = 255 - a8;
      if ( v11 > a7 )
        LOBYTE(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int8)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_100239A0() )
    v17 = v17 == 0;
  sub_1000C8D0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101A9CD0[v12], 0x400u, &v31, a6);
  byte_101AA0CE[v12] = 42;
  byte_101AA0CF[v12] = 0;
  v18 = sub_1000C8D0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_101AA0D0[v12], 0x400u, &v31, a7);
  byte_101AA4CE[v12] = 42;
  byte_101AA4CF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101AA4D0[v12];
    byte_101AA4D0[v12] = 0;
  }
  else
  {
    v13 = &byte_101AA4D0[v12];
    v18 = sub_1000C8D0((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_101AA4D0[v12], 0x400u, &v31, a8);
    byte_101AA8CE[v12] = 42;
    byte_101AA8CF[v12] = 0;
  }
  v20 = off_1005E720[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_101A9CD0[v12];
  v21 = a3;
  v26 = "uint8";
  v28 = &byte_101AA0D0[v12];
  v29 = v13;
  v14 = off_1005E718[a1];
  v24 = off_1005E710[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10024E90();
  sub_1000AD40(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3);
    sub_1000AE30(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10024EA0(v15);
  return v17;
}
// 1005E710: using guessed type char *off_1005E710[18];
// 1005E718: using guessed type char *off_1005E718[16];
// 1005E720: using guessed type char *off_1005E720[14];

//----- (10010740) --------------------------------------------------------
bool __cdecl sub_10010740(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10022A40();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_100239A0() )
    v17 = v17 == 0;
  sub_1000C8D0((int)&v31, (char *)&unk_1005E0AC, 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101A9CD0[v12], 0x400u, &v31, a6);
  byte_101AA0CE[v12] = 42;
  byte_101AA0CF[v12] = 0;
  v18 = sub_1000C8D0((int)&v31, (char *)&unk_1005E0AC, 4, 0xCu, (double)a7);
  _snprintf(&byte_101AA0D0[v12], 0x400u, &v31, a7);
  byte_101AA4CE[v12] = 42;
  byte_101AA4CF[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101AA4D0[v12];
    byte_101AA4D0[v12] = 0;
  }
  else
  {
    v18 = sub_1000C8D0((int)&v31, (char *)&unk_1005E0AC, 4, 0xCu, (double)a8);
    v13 = &byte_101AA4D0[v12];
    _snprintf(&byte_101AA4D0[v12], 0x400u, &v31, a8);
    byte_101AA8CE[v12] = 42;
    byte_101AA8CF[v12] = 0;
  }
  v20 = off_1005E720[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned long int";
  v29 = v13;
  v14 = off_1005E710[v17 != 0];
  v25 = off_1005E718[a1];
  v24 = v14;
  v27 = &byte_101A9CD0[v12];
  v28 = &byte_101AA0D0[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10024E90();
  sub_1000AD40(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3);
    sub_1000AE30(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10024EA0(v15);
  return v17;
}
// 1005E710: using guessed type char *off_1005E710[18];
// 1005E718: using guessed type char *off_1005E718[16];
// 1005E720: using guessed type char *off_1005E720[14];

//----- (10010AE0) --------------------------------------------------------
int sub_10010AE0()
{
  int v0; // esi@1
  int result; // eax@1

  v0 = sub_10022A40();
  sub_1000C830(1);
  sub_1000CBC0(-1);
  result = sub_1000CB50(-1);
  dword_101AD8D0[v0] = 0;
  return result;
}
// 101AD8D0: using guessed type int dword_101AD8D0[];

//----- (10010B10) --------------------------------------------------------
BOOL __usercall sub_10010B10@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6)
{
  const char **v6; // ebp@1
  _BYTE *v7; // esi@1
  int v8; // edi@1
  int v9; // esi@6
  const char *v11; // [sp+Ch] [bp-34h]@6
  char v12; // [sp+10h] [bp-30h]@1
  char v13; // [sp+20h] [bp-20h]@1
  char v14; // [sp+30h] [bp-10h]@1

  v6 = a6;
  v7 = a1;
  LOBYTE(a6) = 0;
  v8 = sub_10022A40();
  sub_10024ED0((int)&v13);
  sub_10024ED0((int)&v14);
  sub_10024ED0((int)&v12);
  if ( !v7 || !*v7 )
  {
    v11 = "Actual file not supplied";
    goto LABEL_13;
  }
  if ( !a2 || !*a2 )
  {
    v11 = "Expected file not supplied";
LABEL_13:
    v9 = 1;
    goto LABEL_14;
  }
  if ( sub_10025B20((int (__cdecl *)(unsigned int))sub_1000CAB0, v7, (int)&v13) )
  {
    if ( sub_10025B20((int (__cdecl *)(unsigned int))sub_1000CAB0, a2, (int)&v14) )
    {
      v9 = sub_10025990(
             dword_101AF9DC[v8],
             (int)&v13,
             (int)&v14,
             a3,
             a4,
             (int (__cdecl *)(unsigned int))sub_1000CAB0,
             (void (__cdecl *)(_DWORD))sub_1000CAD0,
             (int)&v12,
             (char *)&a6,
             &v11);
      if ( (_BYTE)a6 )
        sub_10025DC0((int)&v12, a5);
    }
    else
    {
      v11 = "Expected bitmap file read failed";
      v9 = 2;
    }
  }
  else
  {
    v11 = "Actual bitmap file read failed";
    v9 = 2;
  }
LABEL_14:
  sub_10024FA0((void (__cdecl *)(_DWORD))sub_1000CAD0, (int)&v12);
  sub_10024FA0((void (__cdecl *)(_DWORD))sub_1000CAD0, (int)&v13);
  sub_10024FA0((void (__cdecl *)(_DWORD))sub_1000CAD0, (int)&v14);
  if ( v6 )
    *v6 = v11;
  return v9 == 0;
}
// 101AF9DC: using guessed type int dword_101AF9DC[];

//----- (10010C80) --------------------------------------------------------
bool __usercall sub_10010C80@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9)
{
  const char *v9; // ebp@1
  const char *v10; // esi@1
  unsigned int v11; // ebx@8
  unsigned int v12; // edi@8
  bool v13; // zf@11
  bool v14; // bl@13
  int v15; // esi@15
  char *v16; // eax@15
  char *v17; // edx@15
  char *v18; // ecx@15
  int v19; // esi@16
  int v20; // edi@18
  const char *v22; // [sp+14h] [bp-148h]@1
  int v23; // [sp+18h] [bp-144h]@1
  int v24; // [sp+24h] [bp-138h]@1
  int v25; // [sp+28h] [bp-134h]@1
  char *v26; // [sp+2Ch] [bp-130h]@15
  int v27; // [sp+30h] [bp-12Ch]@15
  int v28; // [sp+34h] [bp-128h]@15
  int v29; // [sp+38h] [bp-124h]@15
  char *v30; // [sp+3Ch] [bp-120h]@15
  char *v31; // [sp+40h] [bp-11Ch]@15
  const char *v32; // [sp+44h] [bp-118h]@15
  char *v33; // [sp+48h] [bp-114h]@15
  char *v34; // [sp+4Ch] [bp-110h]@15
  int v35; // [sp+50h] [bp-10Ch]@16
  int v36; // [sp+54h] [bp-108h]@16
  char v37; // [sp+58h] [bp-104h]@9
  char v38; // [sp+156h] [bp-6h]@9
  char v39; // [sp+157h] [bp-5h]@9

  v9 = a6;
  v10 = a7;
  v25 = a2;
  v23 = a1;
  v22 = a7;
  v24 = sub_10022A40();
  if ( !a6 )
    v9 = "(NULL)";
  if ( !a7 )
  {
    v22 = "(NULL)";
    v10 = "(NULL)";
  }
  if ( a8 )
  {
    if ( !a4 && !sub_100239A0() )
    {
      v11 = strlen(v9);
      v12 = strlen(v10);
      if ( v11 != v12 )
      {
        _snprintf(&v37, 0x100u, "%s - strlen()", v23);
        v38 = 42;
        v39 = 0;
        sub_1000F230(0, 0, (int)"..\\lib\\utf\\utf_verify.c", (int)"2499", (int)&v37, v11, v12, 0, 0);
      }
    }
  }
  if ( !strcmp(v9, v10) )
    v13 = a4 == 0;
  else
    v13 = a4 == 1;
  v14 = v13;
  if ( sub_100239A0() )
    v14 = v14 == 0;
  v15 = 3072 * v24;
  _snprintf(&byte_101A9CD0[3072 * v24], 0x400u, "%s", v9);
  byte_101AA0CE[v15] = 42;
  byte_101AA0CF[v15] = 0;
  _snprintf(&byte_101AA0D0[3072 * v24], 0x400u, "%s", v22);
  v16 = off_1005E720[a4];
  v27 = a5;
  v26 = v16;
  v29 = v23;
  v28 = v25;
  byte_101AA4CE[v15] = 42;
  v17 = off_1005E710[v14 != 0];
  v18 = off_1005E718[a3];
  byte_101AA4CF[v15] = 0;
  v30 = v17;
  v31 = v18;
  v32 = "string";
  v33 = &byte_101A9CD0[3072 * v24];
  v34 = &byte_101AA0D0[3072 * v24];
  if ( a9 )
  {
    v35 = 0;
    v36 = a9;
    v19 = 11;
  }
  else
  {
    v19 = 9;
  }
  v20 = sub_10024E90();
  sub_1000AD40(7, (int)&v26, v19);
  sub_10024EA0(v20);
  return v14;
}
// 1005E710: using guessed type char *off_1005E710[18];
// 1005E718: using guessed type char *off_1005E718[16];
// 1005E720: using guessed type char *off_1005E720[14];

//----- (10010EF0) --------------------------------------------------------
char __cdecl sub_10010EF0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  int v9; // esi@1
  int v10; // esi@4
  char *v11; // eax@4
  char v12; // cl@5
  char *v13; // eax@6
  char v14; // cl@7
  char v15; // bl@8
  char *v16; // edx@10
  bool v17; // zf@10
  int v18; // esi@12
  int v19; // edi@17
  unsigned int v21; // [sp+10h] [bp-258h]@2
  char *v22; // [sp+14h] [bp-254h]@4
  int v23; // [sp+18h] [bp-250h]@1
  char *v24; // [sp+1Ch] [bp-24Ch]@4
  int v25; // [sp+20h] [bp-248h]@1
  char *v26; // [sp+24h] [bp-244h]@4
  char *v27; // [sp+28h] [bp-240h]@4
  int v28; // [sp+2Ch] [bp-23Ch]@1
  int v29; // [sp+30h] [bp-238h]@1
  char *v30; // [sp+34h] [bp-234h]@10
  int v31; // [sp+38h] [bp-230h]@10
  int v32; // [sp+3Ch] [bp-22Ch]@10
  int v33; // [sp+40h] [bp-228h]@10
  char *v34; // [sp+44h] [bp-224h]@10
  char *v35; // [sp+48h] [bp-220h]@10
  const char *v36; // [sp+4Ch] [bp-21Ch]@10
  char *v37; // [sp+50h] [bp-218h]@12
  char *v38; // [sp+54h] [bp-214h]@12
  char *v39; // [sp+58h] [bp-210h]@12
  char *v40; // [sp+5Ch] [bp-20Ch]@14
  char v41[2]; // [sp+64h] [bp-204h]@2
  char v42; // [sp+163h] [bp-105h]@3
  char v43; // [sp+164h] [bp-104h]@14
  char v44; // [sp+263h] [bp-5h]@14

  v28 = a4;
  v23 = a5;
  v25 = a7;
  v9 = sub_10022A40();
  v29 = v9;
  if ( a8 == 65278 )
  {
    v21 = dword_101AF9DC[v9] != 0 ? 0x32 : 0;
    strcpy(v41, "0");
  }
  else
  {
    v21 = a8;
    _snprintf(v41, 0x100u, "%u", a8);
    v42 = 0;
  }
  v10 = 560 * v9;
  v22 = &byte_101B0FF8[v10];
  sub_1000C5D0(a3, 1, a6, 0x230u, &byte_101B0FF8[v10]);
  v27 = &byte_101AD8F8[v10];
  sub_1000C5D0(a3, 2, a7, 0x230u, &byte_101AD8F8[v10]);
  v24 = &byte_101AEED8[v10];
  sub_1000C5D0(a3, 3, a6, 0x230u, &byte_101AEED8[v10]);
  v26 = &byte_101AF9F0[v10];
  sub_1000C5D0(a3, 4, a7, 0x230u, &byte_101AF9F0[v10]);
  _snprintf(&byte_101B04E0[v10], 0x230u, "%s_Diff_", a6);
  v11 = &byte_101B04E0[v10];
  byte_101B070F[v10] = 0;
  do
    v12 = *v11++;
  while ( v12 );
  sub_1000C5D0(a3, 0, v25, 560 - (v11 - &byte_101B04E0[v10 + 1]), &byte_101B04E0[v10] + v11 - &byte_101B04E0[v10 + 1]);
  v13 = &byte_101B04E0[v10];
  byte_101B070F[v10] = 0;
  do
    v14 = *v13++;
  while ( v14 );
  *(&byte_101B04DC[v10] + v13 - &byte_101B04E0[v10 + 1]) = 0;
  sub_1000C5D0(a3, 1, (int)&byte_101B04E0[v10], 0x230u, &byte_101A91E0[v10]);
  sub_1000C5D0(a3, 1, (int)&byte_101B04E0[v10], 0x230u, &byte_101AE3E8[v10]);
  v15 = sub_10010B10(v22, v27, v21, a2 == 1, (int)&byte_101A91E0[v10], (const char **)&v22);
  if ( sub_100239A0() )
    v15 = v15 == 0;
  v30 = off_1005E720[a2];
  v32 = v28;
  v33 = v23;
  v31 = a3;
  v36 = "bitmap-strict";
  v16 = off_1005E718[a1];
  v34 = off_1005E710[v15 != 0];
  v17 = dword_101AF9DC[v29] == 0;
  v35 = v16;
  if ( !v17 )
    v36 = "bitmap-lenient";
  v37 = v24;
  v38 = v26;
  v39 = v41;
  v18 = 10;
  if ( !v15 && v22 )
  {
    _snprintf(&v43, 0x100u, "Info: %s", v22);
    v44 = 0;
    v40 = &v43;
    v18 = 11;
  }
  if ( a9 )
    (&v30)[4 * v18++] = (char *)a9;
  v19 = sub_10024E90();
  sub_1000AD40(7, (int)&v30, v18);
  sub_10024EA0(v19);
  return v15;
}
// 1005E710: using guessed type char *off_1005E710[18];
// 1005E718: using guessed type char *off_1005E718[16];
// 1005E720: using guessed type char *off_1005E720[14];
// 101AF9DC: using guessed type int dword_101AF9DC[];

//----- (100111F0) --------------------------------------------------------
bool __cdecl sub_100111F0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v9; // [sp+Ch] [bp-104h]@1
  char v10; // [sp+10Ah] [bp-6h]@1
  char v11; // [sp+10Bh] [bp-5h]@1

  _snprintf(&v9, 0x100u, "%s (ptr diff)", a5);
  v10 = 42;
  v11 = 0;
  return sub_1000D9D0(a1, a2, a3, a4, (int)&v9, a6 - a7, 0, 0, a8);
}

//----- (100112A0) --------------------------------------------------------
bool __cdecl sub_100112A0(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8)
{
  return sub_10010C80(a5, a4, a1, a2, a3, a6, a7, 1, a8);
}

//----- (100112E0) --------------------------------------------------------
char *__cdecl sub_100112E0(int a1, char *a2, int a3, char *a4, int a5)
{
  char *v5; // edi@1
  char *result; // eax@4
  char v7[4]; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v5 = a2;
  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  *(_DWORD *)(a5 + 16) = sub_10032E30();
  *(_DWORD *)(a5 + 596) = sub_10032ED0();
  sub_10032EF0((int)v7, 1, *(_DWORD *)(a5 + 16), 40);
  *(_WORD *)(a5 + 594) = 0x7FFF;
  sub_1000A6F0(a5 + 585, "14.01", 8);
  *(_DWORD *)a5 = a1;
  sub_10018720((char *)(a5 + 4));
  *(_DWORD *)(a5 + 460) = a3;
  if ( strrchr(a2, 92) )
    v5 = strrchr(a2, 92) + 1;
  strncpy((char *)(a5 + 464), v5, 0x14u);
  *(_BYTE *)(a5 + 484) = 0;
  if ( a4 )
  {
    result = strncpy((char *)(a5 + 485), a4, 0x63u);
    *(_BYTE *)(a5 + 584) = 0;
  }
  else
  {
    result = strncpy((char *)(a5 + 485), v7, 0x64u);
  }
  return result;
}

//----- (10011410) --------------------------------------------------------
char sub_10011410()
{
  char result; // al@1

  result = 0;
  byte_101B1AE8 = 0;
  byte_101B1AE9 = 0;
  return result;
}
// 101B1AE8: using guessed type char byte_101B1AE8;
// 101B1AE9: using guessed type char byte_101B1AE9;

//----- (10011420) --------------------------------------------------------
char __cdecl sub_10011420(char *a1, int a2, char a3, char *a4, int a5)
{
  char result; // al@7
  char v6; // [sp+Bh] [bp-2Dh]@4
  int v7; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( a3 & 3 )
    sub_100112E0(-5, a1, a2, a4, a5);
  else
    sub_100112E0(-44, a1, a2, a4, a5);
  v6 = a3 & 8;
  if ( a3 & 8 )
    sub_1000A7E0((const char *)(a5 + 485), " DBGA", 100);
  sub_10032EF0((int)&v7, 0, 0, 40);
  if ( a3 & 3 )
  {
    result = a3 & 8;
    if ( v6 )
    {
      if ( byte_101B1AE8 )
        return result;
      if ( v6 )
        goto LABEL_15;
    }
    if ( !byte_101B1AE9 )
LABEL_15:
      result = sub_10032F30(36, 1, *(_DWORD *)a5, a5);
  }
  else
  {
    result = j_HWM_pvg_log_err(a5);
  }
  return result;
}
// 100331D0: using guessed type int __cdecl j_HWM_pvg_log_err(_DWORD);
// 101B1AE8: using guessed type char byte_101B1AE8;
// 101B1AE9: using guessed type char byte_101B1AE9;

//----- (10011520) --------------------------------------------------------
char __cdecl sub_10011520(char *a1, int a2, char a3, char *a4)
{
  int v5; // [sp+8h] [bp-284h]@1

  memset(&v5, 0, 0x280u);
  return sub_10011420(a1, a2, a3, a4, (int)&v5);
}

//----- (10011590) --------------------------------------------------------
int __cdecl sub_10011590(char a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 7 )
    result = (unsigned __int16)word_1005FA54[a1];
  return result;
}
// 1005FA54: using guessed type __int16 word_1005FA54[];

//----- (100115B0) --------------------------------------------------------
signed int sub_100115B0()
{
  signed int result; // eax@1

  result = -15;
  dword_101B1B08 = -15;
  dword_101B1B14 = -15;
  dword_101B1AF0 = -15;
  dword_101B1B18 = -15;
  dword_101B1B04 = -15;
  dword_101B1AF4 = -15;
  dword_101B1AEC = -15;
  dword_101B1B00 = -15;
  dword_101B1B10 = -15;
  dword_101B1B0C = -15;
  dword_101B1AFC = -15;
  dword_101B1AF8 = -15;
  return result;
}
// 101B1AEC: using guessed type int dword_101B1AEC;
// 101B1AF0: using guessed type int dword_101B1AF0;
// 101B1AF4: using guessed type int dword_101B1AF4;
// 101B1AF8: using guessed type int dword_101B1AF8;
// 101B1AFC: using guessed type int dword_101B1AFC;
// 101B1B00: using guessed type int dword_101B1B00;
// 101B1B04: using guessed type int dword_101B1B04;
// 101B1B08: using guessed type int dword_101B1B08;
// 101B1B0C: using guessed type int dword_101B1B0C;
// 101B1B10: using guessed type int dword_101B1B10;
// 101B1B14: using guessed type int dword_101B1B14;
// 101B1B18: using guessed type int dword_101B1B18;

//----- (10011600) --------------------------------------------------------
signed int __usercall sub_10011600@<eax>(char a1@<al>, int a2@<ecx>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = sub_100335F0((int)&off_1005FA74);
      break;
    case 0:
      result = sub_100335F0((int)&off_1005FA88);
      break;
    case 1:
      result = sub_100335F0((int)&off_1005FA9C);
      break;
    case 2:
      result = sub_100335F0((int)&off_1005FAC4);
      break;
    case 3:
      result = sub_100335F0((int)&off_1005FAB0);
      break;
    case 5:
      result = sub_100335F0((int)&off_1005FAD8);
      break;
    default:
      result = sub_100335F0(a2);
      break;
  }
  return result;
}
// 1005FA74: using guessed type char *off_1005FA74;
// 1005FA88: using guessed type char *off_1005FA88;
// 1005FA9C: using guessed type char *off_1005FA9C;
// 1005FAB0: using guessed type char *off_1005FAB0;
// 1005FAC4: using guessed type char *off_1005FAC4;
// 1005FAD8: using guessed type char *off_1005FAD8;

//----- (100116A0) --------------------------------------------------------
int __usercall sub_100116A0@<eax>(char a1@<al>)
{
  return sub_10032F60(dword_1005F5A4[a1]);
}
// 1005F5A4: using guessed type int dword_1005F5A4[];

//----- (100116C0) --------------------------------------------------------
int __usercall sub_100116C0@<eax>(char a1@<al>)
{
  return sub_10032F80(dword_1005F5A4[a1], 10);
}
// 1005F5A4: using guessed type int dword_1005F5A4[];

//----- (100116E0) --------------------------------------------------------
signed __int16 __usercall sub_100116E0@<ax>(char a1@<al>, unsigned __int16 a2@<si>)
{
  signed __int16 result; // ax@3
  bool v3; // cf@8

  switch ( a1 )
  {
    case 6:
      if ( a2 < 0x2E5u )
      {
        if ( !(unsigned __int8)sub_10011600(a1, a1) )
        {
          sub_10011520("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3201, 0, 0);
          goto LABEL_6;
        }
        result = *(_WORD *)(dword_101B1B08 + 2 * a2 + 241212);
        v3 = (unsigned __int16)result < 0x256u;
        goto LABEL_32;
      }
      sub_10011520("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3186, 0, 0);
      return -1;
    default:
      goto LABEL_6;
    case 0:
      if ( a2 >= 0x344u )
      {
        sub_10011520("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3224, 0, 0);
        return -1;
      }
      if ( (unsigned __int8)sub_10011600(a1, a1) )
      {
        result = *(_WORD *)(dword_101B1B14 + 2 * a2 + 284664);
        v3 = (unsigned __int16)result < 0x211u;
        goto LABEL_32;
      }
      if ( sub_1000BB20(15000) )
        goto LABEL_6;
      sub_10011520("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3242, 0, 0);
      return 0;
    case 1:
      if ( a2 >= 0xBCCu )
      {
        sub_10011520("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3265, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10011600(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_101B1AF0 + 2 * a2 + 447808);
      v3 = (unsigned __int16)result < 0x979u;
      goto LABEL_32;
    case 2:
      if ( a2 >= 0x388u )
      {
        sub_10011520("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3302, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10011600(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_101B1B18 + 2 * a2 + 356016);
      v3 = (unsigned __int16)result < 0x23Du;
      goto LABEL_32;
    case 3:
      if ( a2 >= 0xBEu )
      {
        sub_10011520("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3339, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10011600(a1, a1) )
      {
        sub_10011520("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3354, 0, 0);
        return 0;
      }
      result = *(_WORD *)(dword_101B1B04 + 2 * a2 + 23096);
      v3 = (unsigned __int16)result < 0x52u;
      goto LABEL_32;
    case 5:
      if ( a2 < 4u )
      {
        if ( (unsigned __int8)sub_10011600(a1, a1) )
        {
          result = *(_WORD *)(dword_101B1AF4 + 2 * a2 + 1804);
          v3 = (unsigned __int16)result < 4u;
LABEL_32:
          if ( !v3 )
            result = -1;
        }
        else
        {
LABEL_6:
          result = 0;
        }
      }
      else
      {
        sub_10011520("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3377, 0, 0);
        result = -1;
      }
      return result;
  }
}
// 101B1AF0: using guessed type int dword_101B1AF0;
// 101B1AF4: using guessed type int dword_101B1AF4;
// 101B1B04: using guessed type int dword_101B1B04;
// 101B1B08: using guessed type int dword_101B1B08;
// 101B1B14: using guessed type int dword_101B1B14;
// 101B1B18: using guessed type int dword_101B1B18;

//----- (10011920) --------------------------------------------------------
char __cdecl sub_10011920(char a1, unsigned __int16 a2, _BYTE *a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v6; // eax@9

  v3 = sub_100116E0(a1, a2);
  if ( v3 != -1 && !sub_100116C0(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10011600(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_101B1B08);
        sub_100116A0(a1);
        return 1;
      case 0:
        if ( (unsigned __int8)sub_10011600(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_101B1B14);
        sub_100116A0(a1);
        return 1;
      case 1:
        if ( (unsigned __int8)sub_10011600(a1, v4) != 1 )
          goto LABEL_17;
        v6 = dword_101B1AF0;
        goto LABEL_16;
      case 2:
        if ( (unsigned __int8)sub_10011600(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_101B1B18);
        sub_100116A0(a1);
        return 1;
      case 3:
        if ( (unsigned __int8)sub_10011600(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_101B1B04);
        sub_100116A0(a1);
        return 1;
      case 5:
        if ( (unsigned __int8)sub_10011600(a1, v4) != 1 )
          goto LABEL_17;
        v6 = dword_101B1AF4;
LABEL_16:
        *a3 = *(_BYTE *)((unsigned __int16)v3 + v6);
        sub_100116A0(a1);
        return 1;
      default:
LABEL_17:
        sub_100116A0(a1);
        break;
    }
  }
  return 0;
}
// 101B1AF0: using guessed type int dword_101B1AF0;
// 101B1AF4: using guessed type int dword_101B1AF4;
// 101B1B04: using guessed type int dword_101B1B04;
// 101B1B08: using guessed type int dword_101B1B08;
// 101B1B14: using guessed type int dword_101B1B14;
// 101B1B18: using guessed type int dword_101B1B18;

//----- (10011A80) --------------------------------------------------------
char __cdecl sub_10011A80(char a1, unsigned __int16 a2, void *a3)
{
  int v3; // ecx@1
  signed __int16 v4; // si@1
  char result; // al@2

  v4 = sub_100116E0(a1, a2);
  if ( v4 == -1 )
  {
    result = 0;
  }
  else
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10011600(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101B1B08 + 210116), 0x34u);
        result = 1;
        break;
      case 0:
        if ( (unsigned __int8)sub_10011600(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101B1B14 + 257156), 0x34u);
        result = 1;
        break;
      case 1:
        result = sub_10011600(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101B1AF0 + 321708), 0x34u);
        break;
      case 2:
        if ( (unsigned __int8)sub_10011600(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101B1B18 + 326220), 0x34u);
        result = 1;
        break;
      case 3:
        if ( (unsigned __int8)sub_10011600(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101B1B04 + 18832), 0x34u);
        result = 1;
        break;
      case 5:
        result = sub_10011600(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101B1AF4 + 1596), 0x34u);
        break;
      default:
LABEL_16:
        result = 0;
        break;
    }
  }
  return result;
}
// 101B1AF0: using guessed type int dword_101B1AF0;
// 101B1AF4: using guessed type int dword_101B1AF4;
// 101B1B04: using guessed type int dword_101B1B04;
// 101B1B08: using guessed type int dword_101B1B08;
// 101B1B14: using guessed type int dword_101B1B14;
// 101B1B18: using guessed type int dword_101B1B18;

//----- (10011C00) --------------------------------------------------------
char __cdecl sub_10011C00(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v5; // eax@5

  v3 = sub_100116E0(a1, a2);
  if ( v3 != -1 && !sub_100116C0(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10011600(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101B1B08 + 24 * ((unsigned __int16)v3 + 25);
        goto LABEL_16;
      case 0:
        if ( (unsigned __int8)sub_10011600(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101B1B14 + 24 * (unsigned __int16)v3 + 532;
        goto LABEL_16;
      case 1:
        if ( (unsigned __int8)sub_10011600(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101B1AF0 + 24 * (unsigned __int16)v3 + 2428;
        goto LABEL_16;
      case 2:
        if ( (unsigned __int8)sub_10011600(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101B1B18 + 24 * ((unsigned __int16)v3 + 24);
        goto LABEL_16;
      case 3:
        if ( (unsigned __int8)sub_10011600(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101B1B04 + 24 * (unsigned __int16)v3 + 84;
        goto LABEL_16;
      case 5:
        if ( (unsigned __int8)sub_10011600(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101B1AF4 + 24 * (unsigned __int16)v3 + 4;
LABEL_16:
        *(_DWORD *)a3 = *(_DWORD *)v5;
        *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(a3 + 12) = *(_DWORD *)(v5 + 12);
        *(_DWORD *)(a3 + 16) = *(_DWORD *)(v5 + 16);
        *(_DWORD *)(a3 + 20) = *(_DWORD *)(v5 + 20);
        sub_100116A0(a1);
        return 1;
      default:
LABEL_17:
        sub_100116A0(a1);
        break;
    }
  }
  return 0;
}
// 101B1AF0: using guessed type int dword_101B1AF0;
// 101B1AF4: using guessed type int dword_101B1AF4;
// 101B1B04: using guessed type int dword_101B1B04;
// 101B1B08: using guessed type int dword_101B1B08;
// 101B1B14: using guessed type int dword_101B1B14;
// 101B1B18: using guessed type int dword_101B1B18;

//----- (10011D60) --------------------------------------------------------
char __cdecl sub_10011D60(int a1, int a2, void *a3, char a4, __int16 a5, char a6)
{
  int v6; // ecx@0
  signed __int16 v7; // ax@1
  int v8; // edi@2
  __int16 v9; // si@11
  __int16 v11; // [sp+8h] [bp-560h]@13
  __int16 v12; // [sp+3Ch] [bp-52Ch]@10
  char v13; // [sp+40h] [bp-528h]@16
  char v14; // [sp+41h] [bp-527h]@10
  __int16 v15; // [sp+42h] [bp-526h]@10
  char v16; // [sp+44h] [bp-524h]@10
  __int16 v17; // [sp+46h] [bp-522h]@15
  int v18; // [sp+48h] [bp-520h]@16
  char v19; // [sp+4Ch] [bp-51Ch]@15

  LOBYTE(v7) = a1;
  switch ( (char)a1 )
  {
    case 6:
      v8 = 28;
      goto LABEL_8;
    case 0:
      v8 = 29;
      goto LABEL_8;
    case 1:
      v8 = 30;
      goto LABEL_8;
    case 2:
      v8 = 31;
      goto LABEL_8;
    case 3:
      v8 = 32;
      goto LABEL_8;
    case 5:
      v8 = 33;
LABEL_8:
      LOBYTE(v7) = sub_10011600(a1, v6);
      if ( !(_BYTE)v7 )
        return v7;
      v7 = sub_100116E0(a1, a2);
      if ( v7 == -1 )
        return v7;
      v14 = a6;
      LOBYTE(v7) = a4;
      v12 = -32768;
      v15 = a2;
      v16 = a4;
      if ( a4 == 1 )
      {
        v9 = a5;
        if ( (unsigned __int16)a5 > 0x514u )
          return v7;
      }
      else
      {
        if ( sub_10011A80(a1, a2, &v11) != 1 )
          goto LABEL_16;
        v9 = v11;
      }
      memcpy(&v19, a3, (unsigned __int16)v9);
      v17 = v9;
LABEL_16:
      v18 = sub_10032ED0();
      v13 = 0;
      LOBYTE(v7) = sub_10025E00(v8, (int)&v12);
      return v7;
    default:
      return v7;
  }
}

//----- (10011EA0) --------------------------------------------------------
char __cdecl sub_10011EA0(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // ax@1
  int v4; // edi@2
  __int16 v6; // [sp+4h] [bp-52Ch]@8
  unsigned __int16 v7; // [sp+8h] [bp-528h]@9
  int v8; // [sp+Ch] [bp-524h]@9

  LOBYTE(v3) = a1;
  switch ( a1 )
  {
    case 6:
      v4 = 28;
      goto LABEL_8;
    case 0:
      v4 = 29;
      goto LABEL_8;
    case 1:
      v4 = 30;
      goto LABEL_8;
    case 2:
      v4 = 31;
      goto LABEL_8;
    case 3:
      v4 = 32;
      goto LABEL_8;
    case 5:
      v4 = 33;
LABEL_8:
      memset(&v6, 0, 0x528u);
      v3 = sub_100116E0(a1, a2);
      if ( v3 != -1 )
      {
        v6 = -32766;
        v7 = a2;
        v8 = a3;
        LOBYTE(v3) = sub_10025E00(v4, (int)&v6);
      }
      break;
    default:
      return v3;
  }
  return v3;
}

//----- (10011F80) --------------------------------------------------------
char __cdecl sub_10011F80(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6)
{
  char result; // al@2
  int v7; // ecx@3
  signed __int16 v8; // si@3
  int v9; // eax@7
  int v10; // ebp@7
  int v11; // esi@7
  int v12; // edi@7
  unsigned int v13; // ebx@7
  int v14; // eax@9
  int v15; // eax@11
  int v16; // eax@13
  int v17; // eax@15
  int v18; // eax@17
  int v19; // eax@25
  char v20; // [sp+7h] [bp-9h]@19
  __int16 v21; // [sp+8h] [bp-8h]@1
  unsigned int v22; // [sp+Ch] [bp-4h]@1

  v22 = sub_10032ED0();
  v21 = 0;
  if ( a1 < 7 )
  {
    v8 = sub_100116E0(a1, a2);
    if ( v8 == -1 )
    {
      result = 0;
    }
    else
    {
      switch ( a1 )
      {
        case 6:
          if ( !(unsigned __int8)sub_10011600(a1, v7) )
            goto LABEL_30;
          v9 = 3 * (unsigned __int16)v8 + 75;
          v10 = dword_101B1B08 + 14952;
          v11 = 52 * (unsigned __int16)v8 + dword_101B1B08 + 210116;
          v12 = dword_101B1B08 + 8 * v9;
          v13 = 195164;
          goto LABEL_18;
        case 0:
          if ( !(unsigned __int8)sub_10011600(a1, v7) )
            goto LABEL_30;
          v14 = 3 * (unsigned __int16)v8;
          v10 = dword_101B1B14 + 13228;
          v11 = 52 * (unsigned __int16)v8 + dword_101B1B14 + 257156;
          v12 = dword_101B1B14 + 8 * v14 + 532;
          v13 = 243928;
          goto LABEL_18;
        case 1:
          if ( !(unsigned __int8)sub_10011600(a1, v7) )
            goto LABEL_30;
          v15 = 3 * (unsigned __int16)v8;
          v10 = dword_101B1AF0 + 60628;
          v11 = 52 * (unsigned __int16)v8 + dword_101B1AF0 + 321708;
          v12 = dword_101B1AF0 + 8 * v15 + 2428;
          v13 = 261080;
          goto LABEL_18;
        case 2:
          if ( !(unsigned __int8)sub_10011600(a1, v7) )
            goto LABEL_30;
          v16 = 3 * (unsigned __int16)v8 + 72;
          v10 = dword_101B1B18 + 14328;
          v11 = 52 * (unsigned __int16)v8 + dword_101B1B18 + 326220;
          v12 = dword_101B1B18 + 8 * v16;
          v13 = 311892;
          goto LABEL_18;
        case 3:
          if ( !(unsigned __int8)sub_10011600(a1, v7) )
            goto LABEL_30;
          v17 = 3 * (unsigned __int16)v8;
          v10 = dword_101B1B04 + 2052;
          v11 = 52 * (unsigned __int16)v8 + dword_101B1B04 + 18832;
          v12 = dword_101B1B04 + 8 * v17 + 84;
          v13 = 16780;
          goto LABEL_18;
        case 5:
          if ( !(unsigned __int8)sub_10011600(a1, v7) )
            goto LABEL_30;
          v18 = 3 * (unsigned __int16)v8;
          v10 = dword_101B1AF4 + 100;
          v11 = 52 * (unsigned __int16)v8 + dword_101B1AF4 + 1596;
          v12 = dword_101B1AF4 + 8 * v18 + 4;
          v13 = 1496;
LABEL_18:
          if ( sub_100116C0(a1) )
            goto LABEL_30;
          v20 = *(_BYTE *)(v12 + 1);
          if ( *(_BYTE *)(v12 + 1) == 1 && v10 )
          {
            if ( *(_DWORD *)(v11 + 12) && v22 > *(_DWORD *)(v11 + 16) + *(_DWORD *)(v12 + 16) )
              goto LABEL_33;
            v21 = a4;
            if ( !a4 )
              v21 = *(_WORD *)(v12 + 4) - a3;
            v19 = *(_DWORD *)(v11 + 4) + (unsigned __int16)a3;
            if ( !v21 || (unsigned int)(unsigned __int16)v21 + v19 > v13 )
LABEL_33:
              v20 = 0;
            else
              memcpy(a5, (const void *)(v10 + v19), (unsigned __int16)v21);
          }
          *(_WORD *)a6 = v21;
          sub_100116A0(a1);
          result = v20;
          break;
        default:
LABEL_30:
          result = 0;
          break;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101B1AEC: using guessed type int dword_101B1AEC;
// 101B1AF0: using guessed type int dword_101B1AF0;
// 101B1AF4: using guessed type int dword_101B1AF4;
// 101B1B00: using guessed type int dword_101B1B00;
// 101B1B04: using guessed type int dword_101B1B04;
// 101B1B08: using guessed type int dword_101B1B08;
// 101B1B10: using guessed type int dword_101B1B10;
// 101B1B14: using guessed type int dword_101B1B14;
// 101B1B18: using guessed type int dword_101B1B18;

//----- (10012200) --------------------------------------------------------
char __cdecl sub_10012200(char a1, int a2, __int16 a3, __int16 a4, void *a5)
{
  int v5; // ecx@0
  int v7; // [sp+0h] [bp-4h]@1

  v7 = v5;
  return sub_10011F80(a1, a2, a3, a4, a5, (int)&v7);
}

//----- (10012230) --------------------------------------------------------
char __cdecl sub_10012230(char a1, unsigned __int16 a2, _DWORD *a3)
{
  char result; // al@1
  char v4; // [sp+0h] [bp-34h]@1
  int v5; // [sp+10h] [bp-24h]@2

  result = sub_10011A80(a1, a2, &v4);
  if ( result == 1 )
    *a3 = v5;
  return result;
}

//----- (10012260) --------------------------------------------------------
char __cdecl sub_10012260(char a1, int a2, void *a3)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v3;
  return sub_10011F80(a1, a2, 0, 0, a3, (int)&v5);
}

//----- (10012290) --------------------------------------------------------
char __cdecl sub_10012290(char a1, int a2, void *a3, int a4)
{
  return sub_10011F80(a1, a2, 0, 0, a3, a4);
}

//----- (100122C0) --------------------------------------------------------
int __thiscall sub_100122C0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_1000BB40(46, (char *)&v2);
  return (int)v2;
}

//----- (100122E0) --------------------------------------------------------
char __cdecl sub_100122E0(char a1, void *a2)
{
  int v2; // eax@2
  char result; // al@11
  char *v4; // eax@12
  signed int v5; // ecx@12

  switch ( a1 )
  {
    case 0:
      v2 = 247;
      break;
    case 2:
      v2 = 248;
      break;
    case 3:
      v2 = 1732;
      break;
    case 4:
      v2 = 1733;
      break;
    case 5:
      v2 = 2279;
      break;
    case 6:
      v2 = 2280;
      break;
    default:
      v2 = 246;
      break;
  }
  if ( !sub_10012260(1, v2, a2) || sub_10027900((int)a2) )
  {
    memset(a2, 0, 0xCCCu);
    v4 = (char *)a2 + 26;
    v5 = 14;
    do
    {
      *v4 = 15;
      v4 += 232;
      --v5;
    }
    while ( v5 );
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10012390) --------------------------------------------------------
char __cdecl sub_10012390(char a1)
{
  bool v1; // zf@1
  char result; // al@1
  char v3; // [sp+4h] [bp-CD0h]@1
  char v4; // [sp+10h] [bp-CC4h]@1

  memset(&v3, 0, 0xCCCu);
  v1 = sub_100122E0(a1, &v3) == 0;
  result = v4;
  if ( v1 )
    result = 0;
  return result;
}

//----- (100123F0) --------------------------------------------------------
char __cdecl sub_100123F0(char a1)
{
  char result; // al@1

  result = -80;
  switch ( a1 )
  {
    case 3:
      result = -126;
      break;
    case 4:
      result = -123;
      break;
    case 5:
      result = -108;
      break;
    case 6:
      result = -105;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10012430) --------------------------------------------------------
char __cdecl sub_10012430(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 74;
      break;
    case 1:
      result = 73;
      break;
    case 2:
      result = 75;
      break;
    case 3:
      result = -127;
      break;
    case 4:
      result = -124;
      break;
    case 5:
      result = -109;
      break;
    case 6:
      result = -106;
      break;
    default:
      sub_10011520("..\\lib\\adl\\iop_cdu_unit_intf.c", 564, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (100124A0) --------------------------------------------------------
signed int __cdecl sub_100124A0(char a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = 4;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 64;
      break;
    case 4:
      result = 128;
      break;
    case 5:
      result = 16;
      break;
    case 6:
      result = 32;
      break;
    default:
      sub_10011520("..\\lib\\adl\\iop_cdu_unit_intf.c", 638, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10012520) --------------------------------------------------------
char __cdecl sub_10012520(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 13;
      break;
    case 1:
      result = 12;
      break;
    case 2:
      result = 14;
      break;
    case 3:
      result = -128;
      break;
    case 4:
      result = -125;
      break;
    case 5:
      result = -110;
      break;
    case 6:
      result = -107;
      break;
    default:
      sub_10011520("..\\lib\\adl\\iop_cdu_unit_intf.c", 712, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (10012590) --------------------------------------------------------
char __cdecl sub_10012590(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 3:
      result = 0;
      break;
    case 4:
      result = 1;
      break;
    case 5:
      result = 2;
      break;
    case 0x28:
      result = 3;
      break;
    case 0x29:
      result = 4;
      break;
    case 0x33:
      result = 5;
      break;
    case 0x34:
      result = 6;
      break;
    default:
      sub_10011520("..\\lib\\adl\\iop_cdu_unit_intf.c", 786, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10012640) --------------------------------------------------------
char __cdecl sub_10012640(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 4:
      result = 0;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      if ( !(_BYTE)a1 )
        sub_10011520("..\\lib\\adl\\iop_cdu_unit_intf.c", 859, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10012750) --------------------------------------------------------
char __cdecl sub_10012750(char a1, void *a2)
{
  int v2; // eax@1

  v2 = sub_10019B30(&a1, 1u, (int)&unk_100617EC, 4, 7, 1);
  return sub_10012260(6, (unsigned __int16)word_100617EE[2 * v2], a2);
}
// 100617EE: using guessed type __int16 word_100617EE[];

//----- (10012780) --------------------------------------------------------
char __cdecl sub_10012780(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 4:
      result = 0;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      sub_10011520("..\\lib\\adl\\iop_cdu_unit_intf.c", 1096, 1, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10012880) --------------------------------------------------------
char __thiscall sub_10012880(void *this)
{
  int v1; // eax@1

  v1 = sub_100122C0(this);
  return sub_10012780(v1);
}

//----- (10012890) --------------------------------------------------------
char __cdecl sub_10012890(int a1, void *a2)
{
  char v3[68]; // [sp+4h] [bp-48h]@1

  sub_10032AE0(9190, (int)v3, 67);
  return sub_10022910(a1, v3[(unsigned __int8)a1], a2);
}
// 10012890: using guessed type char var_48[68];

//----- (100128E0) --------------------------------------------------------
char __cdecl sub_100128E0(int a1, void *a2)
{
  char v3[68]; // [sp+4h] [bp-48h]@1

  sub_10032AE0(9189, (int)v3, 67);
  return sub_10022910(a1, v3[(unsigned __int8)a1], a2);
}
// 100128E0: using guessed type char var_48[68];

//----- (10012930) --------------------------------------------------------
char __cdecl sub_10012930(int a1, void *a2)
{
  return sub_10022910(a1, 0, a2);
}

//----- (10012950) --------------------------------------------------------
char __cdecl sub_10012950(int a1, void *a2)
{
  return sub_10022910(a1, 1, a2);
}

//----- (10012970) --------------------------------------------------------
char __cdecl sub_10012970(int a1, void *a2)
{
  return sub_10022910(a1, 2, a2);
}

//----- (10012990) --------------------------------------------------------
char __cdecl sub_10012990(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // edx@1
  unsigned int v3; // eax@2
  int v4; // eax@3

  v2 = 0xFFFF;
  if ( a1 < 5u )
  {
    v3 = 4 * a1;
    if ( a2 < (unsigned __int16)word_101B2268[v3] )
    {
      v4 = dword_101B2264[v3 / 2];
      if ( v4 )
        v2 = *(_WORD *)(v4 + 2 * a2);
    }
  }
  return sub_1000C080(v2);
}
// 101B2264: using guessed type int dword_101B2264[];
// 101B2268: using guessed type __int16 word_101B2268[];

//----- (100129E0) --------------------------------------------------------
char sub_100129E0()
{
  char result; // al@1
  unsigned int v1; // ecx@1
  signed int v2; // edx@1
  unsigned int v3; // esi@3
  signed int v4; // edi@3

  result = 1;
  v1 = 0;
  v2 = 5;
  do
  {
    dword_101B2308[v1 / 4] = 0;
    word_101B230C[v1 / 2] = 0;
    dword_101B2264[v1 / 4] = 0;
    word_101B2268[v1 / 2] = 0;
    v1 += 8;
    --v2;
  }
  while ( v2 );
  word_101B230C[0] = 23;
  word_101B2268[0] = 23;
  word_101B2314 = 21;
  word_101B2270 = 21;
  word_101B231C = 3;
  word_101B2278 = 3;
  word_101B2324 = 3;
  word_101B2280 = 3;
  dword_101B2308[0] = (int)&unk_101B1B20;
  dword_101B2264[0] = (int)&unk_101B2290;
  dword_101B2310 = (int)&unk_101B1DE9;
  dword_101B226C = (int)&unk_101B22BE;
  dword_101B2318 = (int)&unk_101B2074;
  dword_101B2274 = (int)&unk_101B22E8;
  dword_101B2320 = (int)&unk_101B20D1;
  dword_101B227C = (int)&unk_101B22EE;
  dword_101B2328 = (int)&unk_101B212E;
  word_101B232C = 10;
  dword_101B2284 = (int)&unk_101B22F4;
  word_101B2288 = 10;
  v3 = 0;
  v4 = 5;
  do
  {
    if ( !dword_101B2308[v3 / 4] || !word_101B230C[v3 / 2] || !dword_101B2264[v3 / 4] || !word_101B2268[v3 / 2] )
    {
      sub_10011520("..\\lib\\adl\\app_pof_intf.c", 679, 0, 0);
      result = 0;
    }
    v3 += 8;
    --v4;
  }
  while ( v4 );
  return result;
}
// 101B2264: using guessed type int dword_101B2264[];
// 101B2268: using guessed type __int16 word_101B2268[];
// 101B226C: using guessed type int dword_101B226C;
// 101B2270: using guessed type __int16 word_101B2270;
// 101B2274: using guessed type int dword_101B2274;
// 101B2278: using guessed type __int16 word_101B2278;
// 101B227C: using guessed type int dword_101B227C;
// 101B2280: using guessed type __int16 word_101B2280;
// 101B2284: using guessed type int dword_101B2284;
// 101B2288: using guessed type __int16 word_101B2288;
// 101B2308: using guessed type int dword_101B2308[];
// 101B230C: using guessed type __int16 word_101B230C[];
// 101B2310: using guessed type int dword_101B2310;
// 101B2314: using guessed type __int16 word_101B2314;
// 101B2318: using guessed type int dword_101B2318;
// 101B231C: using guessed type __int16 word_101B231C;
// 101B2320: using guessed type int dword_101B2320;
// 101B2324: using guessed type __int16 word_101B2324;
// 101B2328: using guessed type int dword_101B2328;
// 101B232C: using guessed type __int16 word_101B232C;

//----- (10012B20) --------------------------------------------------------
char sub_10012B20()
{
  unsigned __int8 v0; // al@2
  unsigned int v1; // esi@3
  unsigned __int8 v2; // bl@5
  char result; // al@13
  unsigned __int8 v4; // [sp+6h] [bp-A6h]@2
  char v5; // [sp+7h] [bp-A5h]@2
  int v6; // [sp+8h] [bp-A4h]@0
  __int16 v7; // [sp+Ch] [bp-A0h]@6

  if ( sub_10032AE0(6799, (int)&unk_101B1B20, 1860) )
  {
    sub_10011520("..\\lib\\adl\\app_pof_intf.c", 434, 0, 0);
    result = 0;
  }
  else
  {
    v5 = sub_100129E0() & 1;
    v0 = 0;
    v4 = 0;
    do
    {
      v1 = 8 * v0;
      if ( dword_101B2308[v1 / 4] && dword_101B2264[v1 / 4] )
      {
        v2 = 0;
        if ( word_101B230C[v1 / 2] )
        {
          do
          {
            LOBYTE(v6) = v0 != 1;
            if ( sub_1000BF40((int)&v7, dword_101B2308[v1 / 4] + 31 * v2, v6) )
              *(_WORD *)(dword_101B2264[v1 / 4] + 2 * v2) = v7;
            else
              *(_WORD *)(dword_101B2264[v1 / 4] + 2 * v2) = -1;
            v0 = v4;
            ++v2;
          }
          while ( v2 < (unsigned __int16)word_101B230C[v1 / 2] );
        }
      }
      else
      {
        v5 = 0;
      }
      v4 = ++v0;
    }
    while ( v0 < 5u );
    result = v5;
  }
  return result;
}
// 101B2264: using guessed type int dword_101B2264[];
// 101B2308: using guessed type int dword_101B2308[];
// 101B230C: using guessed type __int16 word_101B230C[];

//----- (10012C60) --------------------------------------------------------
BOOL __cdecl sub_10012C60(int a1)
{
  return sub_10032AE0(9360, a1, 248) == 0;
}

//----- (10012C80) --------------------------------------------------------
char __cdecl sub_10012C80(char a1, unsigned __int8 a2)
{
  char v2; // bl@1
  int v3; // esi@2
  int v4; // eax@2
  unsigned __int8 v6; // [sp+7h] [bp-1h]@1

  v2 = a1;
  v6 = 0;
  if ( a2 > 5u )
  {
    sub_1000A7B0(byte_101B2330, 0x64u, "Unrecognized alert level (%u) unable to ack", a2);
    LOBYTE(v4) = sub_10011520("..\\lib\\adl\\sys_updt_alrt_data.c", 284, 0, byte_101B2330);
  }
  else
  {
    v3 = a2 + 29000;
    v4 = sub_10032DC0(v3, &v6, 1, &a1);
    if ( !v4 && ((unsigned __int8)v2 & v6) != v2 )
    {
      v6 |= v2;
      LOBYTE(v4) = sub_10032BB0(v3, (int)&v6, 1);
    }
  }
  return v4;
}

//----- (10012D10) --------------------------------------------------------
signed __int16 __usercall sub_10012D10@<ax>(void *a1@<ecx>, signed __int16 a2@<bx>, const char *a3@<esi>)
{
  signed __int16 v3; // di@1
  void *v4; // ecx@4
  int v5; // eax@19
  char v7; // [sp+4h] [bp-38h]@2

  v3 = a2;
  if ( a3 )
    memset(&v7, 0, 0x33u);
  if ( a2 == 300 )
  {
    switch ( sub_100122C0(a1) )
    {
      case 1:
        v3 = 380;
        if ( !a3 )
          return v3;
        sub_1000A7E0(&v7, "PFD1", 51);
        break;
      case 4:
        v3 = 381;
        if ( !a3 )
          return v3;
        sub_1000A7E0(&v7, "MFD1", 51);
        break;
      case 2:
        v3 = 382;
        if ( !a3 )
          return v3;
        sub_1000A7E0(&v7, "PFD2", 51);
        break;
      case 64:
        v3 = 383;
        if ( !a3 )
          return v3;
        sub_1000A7E0(&v7, "GTC1", 51);
        break;
      case 128:
        v3 = 384;
        if ( !a3 )
          return v3;
        sub_1000A7E0(&v7, "GTC2", 51);
        break;
      case 16:
        v3 = 385;
        if ( !a3 )
          return v3;
        sub_1000A7E0(&v7, "GTC3", 51);
        break;
      case 32:
        v3 = 386;
        if ( !a3 )
          return v3;
        sub_1000A7E0(&v7, "GTC4", 51);
        break;
      default:
        v3 = -1;
        v5 = sub_100122C0(v4);
        sub_1000A7B0(byte_101B2330, 0x64u, "Unrecognized LRU (%u) passed into DB error alert processing.", v5);
        sub_10011520("..\\lib\\adl\\sys_updt_alrt_data.c", 1286, 0, byte_101B2330);
        break;
    }
  }
  if ( a3 )
    sub_1000A7E0(a3, &v7, 51);
  return v3;
}

//----- (10012F60) --------------------------------------------------------
char __cdecl sub_10012F60(signed __int16 a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  char result; // al@2
  char v4; // [sp+Ah] [bp-6h]@1
  char v5; // [sp+Bh] [bp-5h]@1
  int v6; // [sp+Ch] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = (unsigned __int16)sub_10012D10(v1, a1, 0);
  v2 = sub_10019B30(&v6, 2u, (int)&unk_1007F742, 8, 415, -1);
  if ( v2 < 0 )
  {
    sub_10011520("..\\lib\\adl\\sys_updt_alrt_data.c", 152, 0, 0);
    result = 0;
  }
  else
  {
    sub_10032DC0(*(&dword_1007F744 + 2 * v2), &v4, 1, &v5);
    result = v4;
  }
  return result;
}

//----- (10012FF0) --------------------------------------------------------
bool __cdecl sub_10012FF0(float *a1)
{
  void *v1; // ecx@0
  float *v2; // edi@1
  unsigned int v3; // ebp@1
  char v4; // bl@1
  _DWORD *v5; // esi@1
  char v6; // al@3
  bool result; // al@6
  int v8; // [sp+10h] [bp-8h]@1
  float v9; // [sp+14h] [bp-4h]@3
  char v10; // [sp+1Ch] [bp+4h]@1

  v2 = a1;
  *a1 = 0.0;
  v3 = 0;
  v4 = 0;
  v8 = sub_1000BC00(v1);
  v10 = 0;
  v5 = &unk_10062B80;
  do
  {
    if ( v8 & *v5 )
    {
      v6 = sub_1001A570(v10, 0);
      if ( sub_10022910(3, v6, &v9) )
      {
        ++v3;
        *v2 = *v2 + v9;
      }
    }
    ++v4;
    ++v5;
    v10 = v4;
  }
  while ( (unsigned __int8)v4 < 2u );
  result = v3 != 0;
  if ( v3 )
    *v2 = *v2 / (double)v3;
  return result;
}

//----- (10013090) --------------------------------------------------------
char __cdecl sub_10013090(char a1, float *a2)
{
  float v2; // ST04_4@5
  char result; // al@5
  float v4; // [sp+1Ch] [bp-14h]@3
  float v5; // [sp+20h] [bp-10h]@1
  float v6; // [sp+24h] [bp-Ch]@5
  float v7; // [sp+28h] [bp-8h]@2
  float v8; // [sp+2Ch] [bp-4h]@5

  if ( sub_10022910(2, a1, &v5)
    && sub_10022910(7, a1, &v7)
    && !sub_10032B40(9122, &v4, 4, &unk_10062B88)
    && 9.9999996e24 != v4 )
  {
    v6 = sub_1000B8C0();
    sub_10032B40(6781, &v8, 4, &unk_10062B8C);
    v2 = v6;
    v6 = v6 + v7 + v8;
    *a2 = sub_10034A20(v6, v2, v4, v5, 9.9999996e24);
    result = 1;
  }
  else
  {
    *a2 = 9.8999998e24;
    result = 0;
  }
  return result;
}
// 1000B8C0: using guessed type double sub_1000B8C0(void);

//----- (10013180) --------------------------------------------------------
int sub_10013180()
{
  int result; // eax@1

  sub_10032B80(6361, (int)&flt_101B2394, 4);
  result = sub_10032B80(6362, (int)&flt_101B2398, 4);
  dword_101B239C = 1379255385;
  return result;
}
// 101B2394: using guessed type float flt_101B2394;
// 101B2398: using guessed type float flt_101B2398;
// 101B239C: using guessed type int dword_101B239C;

//----- (100131B0) --------------------------------------------------------
char __usercall sub_100131B0@<al>(int a1@<eax>, float *a2@<esi>, float a3, float a4)
{
  char v4; // cl@1
  char result; // al@5
  void *v6; // [sp+0h] [bp-8h]@0

  v4 = sub_10022990(a1, v6);
  if ( v4 && ((COERCE_UNSIGNED_INT(*a2) & 0x7F800000) == 2139095040 || a3 < (double)*a2 || a4 > (double)*a2) )
  {
    result = 0;
    *a2 = 0.0;
  }
  else
  {
    result = v4;
  }
  return result;
}

//----- (10013210) --------------------------------------------------------
char __cdecl sub_10013210(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_10022990(7, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
     || *(float *)a1 > 39950.746
     || *(float *)a1 < -39950.746) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10013270) --------------------------------------------------------
char __cdecl sub_10013270(float *a1)
{
  char v1; // bl@1
  double v2; // st7@2
  double v3; // st7@6
  char result; // al@9
  float v5; // [sp+Ch] [bp-Ch]@1
  float v6; // [sp+10h] [bp-8h]@5
  float v7; // [sp+14h] [bp-4h]@2

  v1 = sub_10022990(53, &v5);
  if ( v1 )
  {
    v2 = v5;
    v7 = v5;
    if ( (LODWORD(v5) & 0x7F800000) == 2139095040 || v2 > 526.79114 || v2 < -526.79114 )
      return 0;
    if ( sub_10022990(59, &v6) )
    {
      v3 = v6;
      v7 = v6;
      if ( (LODWORD(v6) & 0x7F800000) != 2139095040 && v3 <= 526.79114 && v3 >= -526.79114 )
      {
        sub_10034BA0(flt_101B2394, 0.0);
        result = v1;
        v5 = flt_101B2398 * v6 + v5;
        *a1 = v5;
        return result;
      }
    }
    *a1 = v5;
  }
  return v1;
}
// 101B2394: using guessed type float flt_101B2394;
// 101B2398: using guessed type float flt_101B2398;

//----- (10013370) --------------------------------------------------------
char __cdecl sub_10013370(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_10022990(2, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040 || *(float *)a1 > 512.0 || *(float *)a1 < -512.0) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (100133D0) --------------------------------------------------------
char __cdecl sub_100133D0(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_10022990(9, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
     || *(float *)a1 > 216728.75
     || *(float *)a1 < -216728.75) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10013430) --------------------------------------------------------
char __cdecl sub_10013430(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_10022990(56, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
     || *(float *)a1 > 1053.5823
     || *(float *)a1 < -1053.5823) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10013490) --------------------------------------------------------
char __cdecl sub_10013490(void *a1)
{
  char v1; // bl@1
  int v2; // eax@7
  char result; // al@9
  float v4; // [sp+14h] [bp-10h]@1
  float v5; // [sp+18h] [bp-Ch]@1
  float v6; // [sp+1Ch] [bp-8h]@1
  float v7; // [sp+20h] [bp-4h]@2

  v5 = 0.0;
  v4 = 0.0;
  v6 = 0.0;
  v1 = sub_10022990(57, a1);
  if ( v1 )
  {
    v7 = *(float *)a1;
    if ( (LODWORD(v7) & 0x7F800000) == 2139095040 || *(float *)a1 > 166.46144 || *(float *)a1 < -166.46144 )
    {
      v1 = 0;
      *(float *)a1 = 0.0;
    }
  }
  sub_10032B80(6950, (int)&v4, 4);
  if ( 0.0 != v4 && sub_10022990(66, &v5) && (LOBYTE(v2) = 58, sub_100131B0(v2, &v6, 166.46144, -166.46144)) )
  {
    result = 1;
    *(float *)a1 = v4 * v5 + v6;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10013570) --------------------------------------------------------
char __cdecl sub_10013570(float *a1)
{
  float *v1; // esi@1
  char v2; // bl@1

  v1 = a1;
  *a1 = 0.0;
  v2 = sub_10013210(&a1);
  if ( v2 )
    *v1 = sub_1000B8C0() + *(float *)&a1;
  return v2;
}
// 1000B8C0: using guessed type double sub_1000B8C0(void);

//----- (100135A0) --------------------------------------------------------
char __cdecl sub_100135A0(float *a1)
{
  float *v1; // esi@1
  char result; // al@4
  float v3; // [sp+8h] [bp-4h]@1

  v1 = a1;
  *a1 = 9.8999998e24;
  if ( sub_10013370(&v3) && sub_10013570((float *)&a1) )
  {
    *(float *)&a1 = *(float *)&a1 * 3.280839920043945;
    if ( *(float *)&a1 < 36089.0 )
    {
      result = 1;
      *v1 = v3 - (15.0 - *(float *)&a1 / 1000.0 * 1.981199979782104);
    }
    else
    {
      result = 1;
      *v1 = v3 - -56.5;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10013640) --------------------------------------------------------
int __cdecl sub_10013640(void *a1)
{
  float v2; // [sp+0h] [bp-4h]@1

  v2 = 9.8999998e24;
  return sub_10032B40(2102, a1, 4, &v2);
}

//----- (10013670) --------------------------------------------------------
char __cdecl sub_10013670(float *a1)
{
  char v1; // bl@1
  float v3; // [sp+4h] [bp-4h]@1

  v1 = 0;
  if ( sub_10014780(&v3) && (unsigned __int8)sub_10022740() )
  {
    sub_10032F80(100, 60000);
    if ( *(float *)(dword_10254408 + 1548) > -32767.0 )
    {
      v1 = 1;
      *a1 = v3 - *(float *)(dword_10254408 + 1548);
    }
    sub_10032F60(100);
  }
  return v1;
}
// 10254408: using guessed type int dword_10254408;

//----- (100136E0) --------------------------------------------------------
char __cdecl sub_100136E0(float *a1)
{
  char v1; // bl@1
  float v3; // [sp+4h] [bp-4h]@1

  v1 = 0;
  if ( sub_10013210(&v3) && (unsigned __int8)sub_10022740() )
  {
    sub_10032F80(100, 60000);
    if ( *(float *)(dword_10254408 + 1548) > -32767.0 )
    {
      v1 = 1;
      *a1 = v3 - *(float *)(dword_10254408 + 1548);
    }
    sub_10032F60(100);
  }
  return v1;
}
// 10254408: using guessed type int dword_10254408;

//----- (10013750) --------------------------------------------------------
char __cdecl sub_10013750(bool *a1)
{
  unsigned __int8 v1; // bl@1
  unsigned __int16 *v2; // esi@1
  signed int v3; // edi@4
  void *v4; // ecx@5
  char v5; // al@9
  void *v6; // ecx@13
  char v8; // [sp+1h] [bp-Bh]@1
  char v9; // [sp+2h] [bp-Ah]@1
  unsigned __int8 v10; // [sp+3h] [bp-9h]@1
  unsigned __int8 v11; // [sp+4h] [bp-8h]@1
  bool v12; // [sp+5h] [bp-7h]@1
  char v13; // [sp+6h] [bp-6h]@6
  bool v14; // [sp+7h] [bp-5h]@1
  float v15; // [sp+8h] [bp-4h]@1

  v14 = (unsigned __int8)sub_10014530() > 1u;
  v1 = 0;
  v12 = sub_10012FF0(&v15);
  v8 = 1;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v2 = (unsigned __int16 *)&unk_10063208;
  if ( sub_100187D0(0x2E6u) || sub_100187D0(0x2E7u) )
    v2 = (unsigned __int16 *)&unk_10063200;
  v3 = 4;
  do
  {
    if ( sub_100187D0(*v2) && sub_100188B0(*v2, &v13) )
    {
      v10 += v13;
      ++v1;
      LOBYTE(v4) = v13 == 0;
      v11 += v13 == 0;
    }
    ++v2;
    --v3;
  }
  while ( v3 );
  v5 = byte_10063210[v1];
  if ( v10 >= (unsigned __int8)v5 )
    goto LABEL_20;
  if ( v11 >= (unsigned __int8)v5 )
    goto LABEL_19;
  if ( v14 )
  {
    if ( !sub_100147E0() )
    {
      if ( !v12 )
        goto LABEL_20;
      goto LABEL_18;
    }
LABEL_19:
    v8 = 1;
LABEL_21:
    v9 = 1;
    goto LABEL_22;
  }
  if ( v12 )
  {
LABEL_18:
    if ( v15 > 25.72207 )
      goto LABEL_19;
LABEL_20:
    v8 = 0;
    goto LABEL_21;
  }
  if ( sub_1000BC20(v4) == 2 || sub_1000BC20(v6) == 8 )
  {
    *a1 = 1;
    return 0;
  }
LABEL_22:
  *a1 = v8 == 0;
  return v9;
}

//----- (10013890) --------------------------------------------------------
int __cdecl sub_10013890(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int result; // eax@1
  unsigned int v4; // edx@1
  char v5; // bl@8
  char v6; // dl@13
  char v7; // cl@13

  v2 = a2 / 0x15180 % 0x5B5;
  result = a1;
  v4 = 4 * (a2 / 0x15180 / 0x5B5) + 1990;
  *(_WORD *)(a1 + 2) = v4;
  if ( v2 > 0x16D )
  {
    do
    {
      v2 -= 365;
      if ( !((unsigned __int16)v4 % 4) )
        --v2;
      LOWORD(v4) = v4 + 1;
    }
    while ( v2 > 0x16D );
    *(_WORD *)(a1 + 2) = v4;
  }
  if ( v2 >= 1 )
  {
    v5 = 0;
    if ( v2 > 0x3B && !(*(_WORD *)(a1 + 2) % 4) )
    {
      --v2;
      v5 = 1;
    }
    *(_BYTE *)a1 = 12;
    if ( v2 <= 0x14E )
    {
      do
        --*(_BYTE *)a1;
      while ( v2 <= *(_WORD *)&word_10063226[2 * *(_BYTE *)a1] );
    }
    v6 = *(_BYTE *)a1;
    v7 = v2 - word_10063226[2 * *(_BYTE *)a1];
    *(_BYTE *)(a1 + 1) = v7;
    if ( v5 == 1 && v6 == 2 )
      *(_BYTE *)(a1 + 1) = v7 + 1;
  }
  else
  {
    --*(_WORD *)(a1 + 2);
    *(_BYTE *)a1 = 12;
    *(_BYTE *)(a1 + 1) = 31;
  }
  return result;
}

//----- (10013980) --------------------------------------------------------
int __cdecl sub_10013980(int *a1, unsigned int a2)
{
  int result; // eax@1
  int v3; // eax@9
  int v4; // ecx@9
  signed int v5; // eax@9
  int i; // ecx@9
  int v7; // ecx@13

  result = a2 >> 16;
  if ( HIWORD(a2) > 0x7C5u )
  {
    if ( HIWORD(a2) > 0x84Eu
      || HIWORD(a2) == 2126 && (unsigned __int8)a2 > 2u
      || HIWORD(a2) == 2126 && (_BYTE)a2 == 2 && BYTE1(a2) > 5u )
    {
      *a1 = -23296;
    }
    else
    {
      v3 = (HIWORD(a2) - 1990) / 4;
      v4 = v3;
      v5 = 4 * v3 + 1990;
      for ( i = 1461 * v4; v5 < HIWORD(a2); ++v5 )
      {
        i += 365;
        if ( !(v5 % 4) )
          ++i;
      }
      v7 = *(_WORD *)&word_10063226[2 * (unsigned __int8)a2] + i;
      if ( (unsigned __int8)a2 > 2u && !(HIWORD(a2) % 4) )
        ++v7;
      result = 86400 * (v7 + BYTE1(a2));
      *a1 = result;
    }
  }
  else
  {
    result = (int)a1;
    *a1 = 0;
  }
  return result;
}

//----- (10013A70) --------------------------------------------------------
__int16 __cdecl sub_10013A70(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  __int16 result; // ax@1

  v2 = a2 % 0x15180 % 0xE10;
  *(_WORD *)a1 = a2 % 0x15180 / 0xE10;
  *(_BYTE *)(a1 + 2) = v2 / 0x3C;
  result = 60 * (char)(v2 / 0x3C);
  *(_BYTE *)(a1 + 3) = v2 % 0x3C;
  return result;
}

//----- (10013AC0) --------------------------------------------------------
int __cdecl sub_10013AC0(int *a1, unsigned int a2)
{
  int result; // eax@1

  result = (a2 >> 24) + 60 * ((unsigned __int8)(a2 >> 16) + 60 * (unsigned __int16)a2);
  *a1 = result;
  return result;
}

//----- (10013AF0) --------------------------------------------------------
__int16 __cdecl sub_10013AF0(unsigned int *a1, _WORD *a2, _WORD *a3)
{
  unsigned int v3; // esi@1
  __int16 result; // ax@1
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1

  v3 = *a1;
  sub_10013A70((int)&v5, *a1);
  sub_10013890((int)&v6, v3);
  *a3 = (unsigned __int8)(BYTE3(v5) >> 1) | (unsigned __int16)(32 * (BYTE2(v5) | (unsigned __int16)((_WORD)v5 << 6)));
  result = BYTE1(v6);
  *a2 = BYTE1(v6) | (unsigned __int16)(32 * ((unsigned __int8)v6 | (unsigned __int16)(16 * (HIWORD(v6) - 60))));
  return result;
}

//----- (10013B70) --------------------------------------------------------
int __cdecl sub_10013B70(unsigned __int64 a1)
{
  unsigned int v1; // ST10_4@1
  unsigned int v3; // [sp+4h] [bp-4h]@1

  LOBYTE(v1) = (HIDWORD(a1) >> 16) & 0xF;
  HIWORD(v1) = (HIDWORD(a1) >> 20) & 0xFFF;
  BYTE1(v1) = (HIDWORD(a1) >> 11) & 0x1F;
  LOWORD(v3) = (HIDWORD(a1) >> 6) & 0x1F;
  BYTE2(v3) = BYTE4(a1) & 0x3F;
  BYTE3(v3) = (a1 >> 26) & 0x3F;
  sub_10013980((int *)&a1, v1);
  sub_10013AC0((int *)&v3, v3);
  return v3 + a1;
}

//----- (10013C00) --------------------------------------------------------
int __cdecl sub_10013C00(void *a1)
{
  int result; // eax@6

  if ( !sub_10012260(0, 196, a1) )
    return 0;
  if ( (COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040 || *(float *)a1 > 7620.0 )
  {
    result = 0;
    *(float *)a1 = 7620.0;
  }
  else
  {
    if ( *(float *)a1 < -3048.0 )
    {
      *(float *)a1 = -3048.0;
      return 0;
    }
    result = 1;
  }
  return result;
}

//----- (10013C70) --------------------------------------------------------
char __cdecl sub_10013C70(int a1, void *a2)
{
  int v2; // ebx@1
  int v3; // eax@1
  void *v4; // ecx@1
  int v5; // edi@1
  char result; // al@5
  int v7; // eax@7
  int v8; // ebp@7
  int v9; // [sp+8h] [bp-10h]@1
  int v10; // [sp+Ch] [bp-Ch]@1
  float v11; // [sp+10h] [bp-8h]@1

  v11 = 9.8999998e24;
  *(float *)a2 = 9.8999998e24;
  LOBYTE(v9) = 0;
  v10 = 0;
  v2 = sub_10028200(a1);
  v3 = sub_10028180(a1);
  v5 = v3;
  if ( !v2 )
    goto LABEL_15;
  if ( !v3 )
    return sub_10016F60(a1, a2);
  if ( *(_WORD *)(v2 + 12) != 6 )
    goto LABEL_15;
  if ( sub_1000BC20(v4) == 4 )
  {
    *(float *)a2 = *(float *)(v2 + 8);
    return 1;
  }
  if ( (unsigned __int8)(*(_BYTE *)(v5 + 2) - 1) <= 2u )
  {
    v7 = sub_100280D0(&v9, (void *)(v5 + 4), 0xCu, 27, 100);
    *(float *)a2 = v11;
    v8 = v7;
    result = sub_10032ED0() - v10 < (unsigned int)(unsigned __int16)word_100632EC[*(_BYTE *)(v5 + 3)] ? v9 : 0;
    if ( v8 >= 0 )
    {
      if ( result )
        result = sub_10016B60(v2, (float *)a2);
    }
    else
    {
      sub_10011520("..\\lib\\acl\\dat\\dat_proc_float.c", 174, 0, 0);
      result = 0;
    }
  }
  else
  {
LABEL_15:
    result = 0;
  }
  return result;
}
// 100632EC: using guessed type __int16 word_100632EC[];

//----- (10013DD0) --------------------------------------------------------
char __fastcall sub_10013DD0(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  BYTE3(v2) = 0;
  if ( sub_10032AE0(2018, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 2u) )
  {
    BYTE3(v2) = 0;
    sub_10032BB0(2018, (int)&v2 + 3, 1);
    result = BYTE3(v2);
  }
  return result;
}

//----- (10013E20) --------------------------------------------------------
char __cdecl sub_10013E20(unsigned int a1)
{
  unsigned int v1; // ecx@1
  unsigned int v2; // ebx@1
  unsigned int v3; // ebx@1
  unsigned int v4; // eax@1
  unsigned __int8 v5; // bl@4
  char result; // al@4
  unsigned __int8 v7; // [sp+8h] [bp+4h]@1

  v1 = a1 / 0x3E8;
  v2 = a1 % 0x3E8;
  v7 = a1 % 0x3E8 / 0x64;
  v3 = -100 * v7 + v2;
  v4 = v3 / 0xA;
  if ( (unsigned __int8)v1 >= 8u || v7 >= 8u || (unsigned __int8)v4 >= 8u || (v5 = v3 - 10 * v4, result = 1, v5 >= 8u) )
    result = 0;
  return result;
}

//----- (10013E90) --------------------------------------------------------
char __cdecl sub_10013E90(char a1)
{
  char result; // al@1

  result = 0;
  if ( !a1 )
  {
    if ( sub_1001A3E0(33) || sub_1001A410(17) )
      return 1;
    return 0;
  }
  if ( a1 != 1 )
    return result;
  if ( !sub_1001A3E0(34) && !sub_1001A410(19) )
    return 0;
  return 1;
}

//----- (10013EE0) --------------------------------------------------------
char __cdecl sub_10013EE0(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_1001A3E0(11);
  }
  else
  {
    result = sub_1001A3E0(5);
  }
  return result;
}

//----- (10013F10) --------------------------------------------------------
char __cdecl sub_10013F10(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_100187D0(0x1EDu);
  }
  else
  {
    result = sub_100187D0(0x1ECu);
  }
  return result;
}

//----- (10013F40) --------------------------------------------------------
char __usercall sub_10013F40@<al>(unsigned __int8 a1@<al>, _BYTE *a2)
{
  int v2; // ecx@1

  v2 = 0;
  while ( (a1 & (unsigned __int8)byte_100641B0[2 * v2]) != byte_100641B0[2 * v2] )
  {
    if ( ++v2 >= 5 )
      return 0;
  }
  *a2 = byte_100641B1[2 * v2];
  return 1;
}

//----- (10013F70) --------------------------------------------------------
char __cdecl sub_10013F70(void *a1, int a2)
{
  unsigned __int8 v2; // al@3
  char v3; // al@6
  bool v4; // al@8
  bool v5; // zf@8
  char v6; // cl@8
  int v7; // eax@8
  unsigned __int8 v8; // al@18
  int v9; // ecx@18
  int v10; // edx@18
  char v11; // al@22
  char result; // al@32
  char v13; // [sp+Ah] [bp-4Eh]@1
  bool v14; // [sp+Bh] [bp-4Dh]@1
  int v15; // [sp+Ch] [bp-4Ch]@1
  int v16; // [sp+10h] [bp-48h]@1
  unsigned __int8 v17; // [sp+14h] [bp-44h]@13
  int v18; // [sp+18h] [bp-40h]@14
  char v19; // [sp+20h] [bp-38h]@5
  char v20; // [sp+23h] [bp-35h]@10
  char v21; // [sp+26h] [bp-32h]@8
  int v22; // [sp+4Ah] [bp-Eh]@6
  char v23; // [sp+52h] [bp-6h]@8

  *(_DWORD *)a1 = 0;
  *((_DWORD *)a1 + 1) = 0;
  *((_DWORD *)a1 + 2) = 0;
  *((_DWORD *)a1 + 3) = 0;
  v14 = 0;
  v13 = 0;
  v15 = 0;
  v16 = 0;
  if ( (unsigned __int8)a2 >= 2u )
    goto LABEL_25;
  if ( !sub_10013F10(a2) )
  {
    if ( !sub_10013E90(a2) )
    {
      if ( (unsigned __int8)a2 == 1 )
        v11 = sub_10012260(1, 1221, a1);
      else
        v11 = sub_10012260(1, 1209, a1);
      v13 = v11;
      goto LABEL_25;
    }
    if ( sub_100282C0(a2, 1, &v17)
      && sub_10028500(v18, &v15)
      && sub_10028500(HIWORD(v18), &v16)
      && sub_10013F40(v17, (_BYTE *)a1 + 3)
      && sub_100282C0(a2, 2, &v17) )
    {
      v8 = v17;
      v5 = (v17 & 0x80) == -128;
      v9 = (unsigned __int16)v15;
      *(_BYTE *)a1 = (v17 & 0x10) == 16;
      *((_BYTE *)a1 + 2) = v5;
      v10 = (unsigned __int16)v16;
      v13 = 1;
      *((_DWORD *)a1 + 3) = v9;
      *((_DWORD *)a1 + 2) = v10;
      if ( v8 & 2 )
        *((_BYTE *)a1 + 1) = 2;
      else
        *((_BYTE *)a1 + 1) = (v8 & 8) == 8;
      goto LABEL_25;
    }
LABEL_11:
    v13 = 0;
    goto LABEL_25;
  }
  v2 = sub_10019B30(&a2, 1u, (int)&unk_100641A0, 4, 2, 0);
  if ( !sub_100188B0((unsigned __int16)word_100641A2[2 * v2], &v13) || !v13 )
    goto LABEL_11;
  if ( !sub_100283F0(&v19) || (v3 = sub_10028500(v22, &v15), v13 = 1, !v3) )
    v13 = 0;
  v4 = sub_10028440();
  v5 = v23 == 1;
  v6 = v21;
  *(_BYTE *)a1 = v4;
  v7 = (unsigned __int16)v15;
  *((_BYTE *)a1 + 3) = 0;
  *((_BYTE *)a1 + 2) = v6;
  *((_DWORD *)a1 + 3) = v7;
  *((_DWORD *)a1 + 2) = v7;
  if ( v5 )
    *((_BYTE *)a1 + 1) = 2;
  else
    *((_BYTE *)a1 + 1) = v20 == 0;
LABEL_25:
  if ( sub_10027F50((unsigned __int8 *)a1)
    || !sub_10013E20(*((_DWORD *)a1 + 2))
    || !sub_10013E20(*((_DWORD *)a1 + 3))
    || sub_10013EE0(a2) && *((_BYTE *)a1 + 1) == 3 )
  {
    result = 0;
  }
  else
  {
    sub_10032AE0(9241, (int)&v14, 1);
    if ( v14 != (*(_BYTE *)a1 == 1) )
    {
      v14 = *(_BYTE *)a1 == 1;
      sub_10032BB0(9241, (int)&v14, 1);
    }
    result = v13;
  }
  return result;
}
// 100641A2: using guessed type __int16 word_100641A2[];

//----- (10014220) --------------------------------------------------------
char __cdecl sub_10014220(void *a1)
{
  int v1; // ecx@0
  int v2; // ST08_4@1

  v2 = v1;
  LOBYTE(v2) = sub_10013DD0(v1);
  return sub_10013F70(a1, v2);
}

//----- (10014240) --------------------------------------------------------
signed int sub_10014240()
{
  return sub_100335F0((int)&off_10064904);
}
// 10064904: using guessed type char *off_10064904;

//----- (10014250) --------------------------------------------------------
int sub_10014250()
{
  int result; // eax@3

  if ( (unsigned __int8)byte_101B23A4 <= 1u )
  {
    result = sub_10032F60(98);
    byte_101B23A4 = 0;
  }
  else
  {
    --byte_101B23A4;
  }
  return result;
}
// 101B23A4: using guessed type char byte_101B23A4;

//----- (10014280) --------------------------------------------------------
char sub_10014280()
{
  char result; // al@2

  if ( sub_10033140(98) )
  {
    result = 1;
    ++byte_101B23A4;
  }
  else if ( sub_10032F80(98, 500) )
  {
    byte_101B23A4 = 0;
    result = 0;
  }
  else
  {
    result = 1;
    byte_101B23A4 = 1;
  }
  return result;
}
// 101B23A4: using guessed type char byte_101B23A4;

//----- (100142C0) --------------------------------------------------------
char __cdecl sub_100142C0(char a1)
{
  int v1; // ecx@0
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  BYTE3(v3) = 0;
  if ( (unsigned __int8)sub_10014240() && sub_10014280() )
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        BYTE3(v3) = *(_BYTE *)(dword_101B23A0 + 90120);
      }
      else if ( a1 == 2 )
      {
        BYTE3(v3) = *(_BYTE *)(dword_101B23A0 + 90980);
      }
    }
    else
    {
      BYTE3(v3) = *(_BYTE *)(dword_101B23A0 + 90102);
    }
    sub_10014250();
  }
  sub_10019080((unsigned __int8 *)&v3 + 3, 0, 0xFFu, 0, 1);
  return BYTE3(v3);
}
// 101B23A0: using guessed type int dword_101B23A0;

//----- (10014350) --------------------------------------------------------
int __cdecl sub_10014350(int a1, signed int a2, signed int a3)
{
  int result; // eax@1

  result = a1;
  *(double *)(a1 + 8) = (double)a3 * 0.000000001462918079267163;
  *(double *)a1 = 0.000000001462918079267163 * (double)a2;
  return result;
}

//----- (10014370) --------------------------------------------------------
int __cdecl sub_10014370(int a1, double a2, double a3)
{
  long double v3; // st6@1
  long double v4; // st4@1
  int result; // eax@3
  double v6; // st7@6
  double v7; // [sp+0h] [bp-10h]@6
  double v8; // [sp+8h] [bp-8h]@6

  v3 = fabs(a2);
  v4 = fabs(a3);
  if ( v3 > 1.5707963267949 || v4 >= 3.1415926535898 )
  {
    if ( v3 > 4.7123889803847 || v4 > 12.5663706143592 )
    {
      result = a1;
      *(_DWORD *)a1 = 2147483648;
      *(_DWORD *)(a1 + 4) = 2147483648;
    }
    else
    {
      v7 = a2;
      v8 = a3;
      sub_10028B10((int)&v7);
      v6 = 683565275.5764301 * v8;
      *(_DWORD *)a1 = (signed int)(v7 * 683565275.5764301);
      result = (signed int)v6;
      *(_DWORD *)(a1 + 4) = (signed int)v6;
    }
  }
  else
  {
    *(_DWORD *)a1 = (signed int)(a2 * 683565275.5764301);
    result = (signed int)(683565275.5764301 * a3);
    *(_DWORD *)(a1 + 4) = result;
  }
  return result;
}

//----- (10014450) --------------------------------------------------------
int __cdecl sub_10014450(double a1, double a2)
{
  double *v2; // ecx@0
  double v3; // ST00_8@1
  double v4; // st7@1
  int result; // eax@4

  v3 = *v2;
  v4 = a1;
  if ( (HIDWORD(v3) & 0x7FF00000) == 2146435072 || a1 < *v2 || (v4 = a2, a2 > *v2) )
  {
    *v2 = v4;
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (100144A0) --------------------------------------------------------
void sub_100144A0()
{
  dword_10254428 = -15;
}
// 10254428: using guessed type int dword_10254428;

//----- (100144B0) --------------------------------------------------------
signed int sub_100144B0()
{
  return sub_100335F0((int)&off_10064970);
}
// 10064970: using guessed type char *off_10064970;

//----- (100144C0) --------------------------------------------------------
char __usercall sub_100144C0@<al>(float *a1@<esi>)
{
  char result; // al@1
  int v2; // ecx@1
  __int16 v3; // dx@1
  double v4; // st7@4
  float v5; // ST08_4@6

  result = 0;
  *a1 = 9.9999996e24;
  v2 = dword_10254428;
  v3 = *(_WORD *)(dword_10254428 + 1456);
  if ( v3 == 3 || v3 == 5 )
  {
    if ( *(_BYTE *)(dword_10254428 + 1296) )
    {
      v4 = sub_10028C10(*(_DWORD *)(dword_10254428 + 1292));
      v2 = dword_10254428;
    }
    else
    {
      v4 = 0.0;
    }
    v5 = v4;
    result = 1;
    *a1 = *(float *)(v2 + 1520) * v5 + *(float *)(v2 + 1468);
  }
  return result;
}
// 10254428: using guessed type int dword_10254428;

//----- (10014530) --------------------------------------------------------
signed int sub_10014530()
{
  char v0; // bl@1
  signed int result; // eax@3

  v0 = 1;
  if ( (unsigned __int8)sub_100144B0() )
    v0 = *(_BYTE *)(dword_10254428 + 1456);
  result = (unsigned __int8)v0;
  if ( (unsigned __int8)v0 >= 8u )
    result = 1;
  return result;
}
// 10254428: using guessed type int dword_10254428;

//----- (10014560) --------------------------------------------------------
bool __cdecl sub_10014560(char a1, int a2)
{
  bool v2; // bl@1
  double v3; // st7@4
  int v4; // eax@4
  int v5; // ecx@8
  int v6; // eax@8
  double v7; // st5@14
  double v8; // st6@14
  float v9; // ST40_4@15
  double v10; // st5@16
  double v11; // st7@19
  float v13; // ST40_4@23
  float v14; // [sp+40h] [bp-10h]@5
  float v15; // [sp+40h] [bp-10h]@12
  float v16; // [sp+40h] [bp-10h]@16
  int v17; // [sp+44h] [bp-Ch]@8
  float v18; // [sp+48h] [bp-8h]@9
  float v19; // [sp+4Ch] [bp-4h]@9

  v2 = 0;
  if ( sub_10032AE0(2047, a2, 16) )
  {
    *(double *)a2 = 0.68067840827779;
    *(double *)(a2 + 8) = -1.658062789394617;
  }
  if ( (unsigned __int8)sub_100144B0() )
  {
    sub_10032F80(101, 10000);
    v3 = 0.0;
    v4 = dword_10254428;
    v2 = *(_WORD *)(dword_10254428 + 1456) > 1u;
    if ( *(_BYTE *)(dword_10254428 + 1296) )
    {
      v14 = sub_10028C10(*(_DWORD *)(dword_10254428 + 1292));
      v4 = dword_10254428;
      v3 = 0.0;
    }
    else
    {
      v14 = 0.0;
    }
    if ( v2 )
    {
      v5 = *(_DWORD *)(v4 + 1524);
      v6 = v4 + 1524;
      *(_DWORD *)a2 = v5;
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(v6 + 4);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v6 + 8);
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(v6 + 12);
      sub_10014450(6.2831853071796, -6.2831853071796);
      sub_10014450(6.2831853071796, -6.2831853071796);
      sub_10035D70(v14, dword_10254428 + 1512, (int)&v17);
      v4 = dword_10254428;
      v3 = 0.0;
    }
    else
    {
      *(float *)&v17 = v3;
      v18 = v3;
      v19 = v3;
    }
    if ( a1 == 1 )
    {
      sub_10035D40((int)&v17, v4 + 1432, (int)&v17);
      v3 = 0.0;
      v4 = dword_10254428;
    }
    v15 = *(float *)(v4 + 1280);
    if ( (LODWORD(v15) & 0x7F800000) == 2139095040 || v15 > 0.0053898906 )
    {
      v8 = 0.0053898906;
    }
    else
    {
      v7 = v15;
      v8 = 0.0053898906;
      if ( v15 >= v3 )
        goto LABEL_16;
    }
    v9 = v3;
    v7 = v9;
LABEL_16:
    *(double *)a2 = v7 * v18 + *(double *)a2;
    v16 = *(float *)(dword_10254428 + 1284);
    v10 = v16;
    if ( (LODWORD(v16) & 0x7F800000) == 2139095040 || v10 > v8 || v10 < v3 )
    {
      v13 = v3;
      v11 = v13;
    }
    else
    {
      v11 = v16;
    }
    *(double *)(a2 + 8) = v11 * *(float *)&v17 + *(double *)(a2 + 8);
    sub_10032F60(101);
    sub_10028B10(a2);
  }
  return v2;
}
// 10254428: using guessed type int dword_10254428;

//----- (10014780) --------------------------------------------------------
char __cdecl sub_10014780(float *a1)
{
  char v1; // bl@1

  *a1 = 9.9999996e24;
  v1 = 0;
  if ( (unsigned __int8)sub_100144B0() )
  {
    sub_10032F80(101, 60000);
    v1 = sub_100144C0(a1);
    if ( v1 )
      *a1 = *(float *)(dword_10254428 + 1440) + *a1;
    sub_10032F60(101);
  }
  return v1;
}
// 10254428: using guessed type int dword_10254428;

//----- (100147E0) --------------------------------------------------------
char sub_100147E0()
{
  char v0; // bl@1

  v0 = 0;
  if ( (unsigned __int8)sub_100144B0() )
  {
    sub_10032F80(101, 10000);
    if ( !*(_BYTE *)(dword_10254428 + 1444)
      || !*(_BYTE *)(dword_10254428 + 1451)
      || (v0 = 1, *(_WORD *)(dword_10254428 + 1456) <= 1u)
      || *(float *)(dword_10254428 + 1480) <= 15.433242 )
    {
      v0 = 0;
    }
    sub_10032F60(101);
  }
  return v0;
}
// 10254428: using guessed type int dword_10254428;

//----- (10014850) --------------------------------------------------------
bool sub_10014850()
{
  bool v0; // bl@1

  v0 = 0;
  if ( (unsigned __int8)sub_100144B0() )
  {
    sub_10032F80(101, 60000);
    v0 = *(_BYTE *)(dword_10254428 + 1454) == 1;
    sub_10032F60(101);
  }
  return v0;
}
// 10254428: using guessed type int dword_10254428;

//----- (10014890) --------------------------------------------------------
bool __cdecl sub_10014890(float *a1)
{
  bool v1; // bl@1
  int v2; // eax@2

  *a1 = 0.0;
  v1 = 0;
  if ( (unsigned __int8)sub_100144B0() )
  {
    sub_10032F80(101, 60000);
    v2 = dword_10254428;
    if ( *(_BYTE *)(dword_10254428 + 1451) )
    {
      *a1 = *(float *)(dword_10254428 + 1480);
      v2 = dword_10254428;
    }
    v1 = *(_WORD *)(v2 + 1456) > 1u;
    sub_10032F60(101);
  }
  return v1;
}
// 10254428: using guessed type int dword_10254428;

//----- (100148F0) --------------------------------------------------------
void __cdecl sub_100148F0(float a1, float a2, char a3)
{
  int v3; // eax@1
  float *v4; // edi@2
  int v5; // esi@3
  double v6; // st7@8
  float v7; // ST20_4@10
  int v8; // esi@13
  int v9; // edi@14
  float v10; // [sp+0h] [bp-2Ch]@1
  char v11; // [sp+8h] [bp-24h]@3

  v3 = 0;
  v10 = a1;
  if ( byte_101B4168 )
  {
    v4 = flt_101B417C;
    do
    {
      v5 = v3 + 1;
      sub_1000A7B0(&v11, 0x1Fu, "_mach_curve_%d", v3 + 1);
      if ( a3 && *(v4 - 3) <= (double)a2 && *(v4 - 2) >= (double)a2 && sub_1000C0A0((int)&v11) )
      {
        v6 = 9.8999998e24 == *(v4 - 1) ? *v4 : (a2 - *v4) / *(v4 - 1);
        v7 = v6;
        if ( v7 <= (double)v10 )
          v10 = v6;
      }
      v3 = v5;
      v4 += 4;
    }
    while ( v5 < (unsigned __int8)byte_101B4168 );
  }
  v8 = 0;
  if ( byte_101B416A )
  {
    do
    {
      v9 = v8 + 1;
      sub_1000A7B0(&v11, 0x1Fu, "_mach_ovrspd_%d", v8 + 1);
      if ( sub_1000C0A0((int)&v11) )
      {
        if ( v10 > (double)flt_101B42B0[v8] )
          v10 = flt_101B42B0[v8];
      }
      ++v8;
    }
    while ( v9 < (unsigned __int8)byte_101B416A );
  }
}
// 101B4168: using guessed type char byte_101B4168;
// 101B416A: using guessed type char byte_101B416A;
// 101B417C: using guessed type float flt_101B417C[];
// 101B42B0: using guessed type float flt_101B42B0[];

//----- (10014A30) --------------------------------------------------------
void __cdecl sub_10014A30(float a1)
{
  int v1; // esi@1
  int v2; // edi@2
  float v3; // [sp+0h] [bp-2Ch]@1
  float v4; // [sp+4h] [bp-28h]@2
  char v5; // [sp+8h] [bp-24h]@2

  v1 = 0;
  v3 = a1;
  if ( byte_101B4169 )
  {
    do
    {
      v2 = v1 + 1;
      sub_1000A7B0(&v5, 0x1Fu, "_ovrspd_alrt_%d", v1 + 1);
      v4 = flt_101B4118[v1] * 1.943844437599182;
      if ( sub_1000C0A0((int)&v5) )
      {
        if ( v3 > (double)v4 )
          v3 = v4;
      }
      ++v1;
    }
    while ( v2 < (unsigned __int8)byte_101B4169 );
  }
}
// 101B4118: using guessed type float flt_101B4118[];
// 101B4169: using guessed type char byte_101B4169;

//----- (10014AD0) --------------------------------------------------------
void sub_10014AD0()
{
  char v0; // al@1
  char v1; // al@5
  char v2; // al@9
  int v3; // ecx@14
  int v4; // edi@14
  float v5; // esi@15
  float v6; // edx@15
  double v7; // st3@17
  double v8; // st3@19
  double v9; // st3@21
  double v10; // st3@21
  char v11; // [sp+7h] [bp-149h]@1
  float v12; // [sp+8h] [bp-148h]@15
  float v13; // [sp+Ch] [bp-144h]@15
  float v14; // [sp+10h] [bp-140h]@11
  int v15; // [sp+14h] [bp-13Ch]@15
  float v16; // [sp+18h] [bp-138h]@19
  int v17[77]; // [sp+1Ch] [bp-134h]@15

  v11 = 0;
  sub_10032B40(6350, &byte_101B4169, 1, &v11);
  sub_10032B40(6527, &byte_101B416A, 1, &v11);
  sub_10032B40(6679, &byte_101B4168, 1, &v11);
  v0 = byte_101B4169;
  if ( (unsigned __int8)byte_101B4169 >= 0x14u )
    v0 = 20;
  byte_101B4169 = v0;
  if ( sub_10032AE0(6351, (int)flt_101B4118, 80) )
    byte_101B4169 = 0;
  v1 = byte_101B416A;
  if ( (unsigned __int8)byte_101B416A >= 0x14u )
    v1 = 20;
  byte_101B416A = v1;
  if ( sub_10032AE0(6528, (int)flt_101B42B0, 80) )
    byte_101B416A = 0;
  v2 = byte_101B4168;
  if ( (unsigned __int8)byte_101B4168 >= 0x14u )
    v2 = 20;
  byte_101B4168 = v2;
  if ( sub_10032AE0(6680, (int)&v14, 320) )
  {
    byte_101B4168 = 0;
  }
  else if ( (signed int)(unsigned __int8)byte_101B4168 > 0 )
  {
    v3 = 0;
    v4 = (unsigned __int8)byte_101B4168;
    do
    {
      v6 = *(float *)&v17[v3];
      v13 = *(float *)((char *)&v15 + v3 * 4);
      v5 = v13;
      v12 = v13;
      if ( SLODWORD(v13) >= SLODWORD(v6) )
        v12 = v6;
      v7 = (double)SLODWORD(v12);
      v12 = v13;
      flt_101B4170[v3] = v7 * 0.3048000037670135;
      if ( SLODWORD(v5) <= SLODWORD(v6) )
        v12 = v6;
      flt_101B4174[v3] = (double)SLODWORD(v12) * 0.3048000037670135;
      v8 = *(float *)((char *)&v16 + v3 * 4) - *(float *)((char *)&v14 + v3 * 4);
      if ( 0.0 == v8 || (LODWORD(v12) = LODWORD(v5) - LODWORD(v6), (double)(LODWORD(v5) - LODWORD(v6)) == 0.0) )
      {
        flt_101B4178[v3] = 9.8999998e24;
        v10 = *(float *)((char *)&v14 + v3 * 4);
      }
      else
      {
        v12 = (double)(LODWORD(v6) - LODWORD(v5)) * 0.3048000037670135 / v8;
        v9 = v12;
        flt_101B4178[v3] = v12;
        v10 = (double)SLODWORD(v13) * 0.3048000037670135 - v9 * *(float *)((char *)&v14 + v3 * 4);
      }
      flt_101B417C[v3] = v10;
      v3 += 4;
      --v4;
    }
    while ( v4 );
  }
}
// 101B4118: using guessed type float flt_101B4118[];
// 101B4168: using guessed type char byte_101B4168;
// 101B4169: using guessed type char byte_101B4169;
// 101B416A: using guessed type char byte_101B416A;
// 101B4170: using guessed type float flt_101B4170[];
// 101B4174: using guessed type float flt_101B4174[];
// 101B4178: using guessed type float flt_101B4178[];
// 101B417C: using guessed type float flt_101B417C[];
// 101B42B0: using guessed type float flt_101B42B0[];
// 10014AD0: using guessed type int var_134[77];

//----- (10014CB0) --------------------------------------------------------
char __cdecl sub_10014CB0(int a1, void *a2)
{
  char result; // al@1
  unsigned __int8 v3; // dl@1

  memset(a2, 0, 0x48u);
  result = 0;
  v3 = 0;
  do
  {
    if ( result )
      break;
    if ( a1 & *(_DWORD *)(dword_10254424 + 72 * v3 + 1704) )
    {
      qmemcpy(a2, (const void *)(dword_10254424 + 72 * v3 + 1660), 0x48u);
      result = 1;
    }
    ++v3;
  }
  while ( v3 < 0x1Eu );
  return result;
}
// 10254424: using guessed type int dword_10254424;

//----- (10014D10) --------------------------------------------------------
void *__usercall sub_10014D10@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>)
{
  void *result; // eax@1
  int v4; // [sp+0h] [bp-Ch]@0
  int v5; // [sp+4h] [bp-8h]@0
  int v6; // [sp+8h] [bp-4h]@0

  result = (void *)sub_10032AE0(v4, v5, v6);
  if ( a2 == 6011 )
  {
    if ( result || *(_BYTE *)a3 > 0x3Fu )
    {
      *(_BYTE *)a3 = 63;
      result = (void *)sub_10032C30(6011, (int)a3, a1);
    }
  }
  else if ( result )
  {
    result = memset(a3, 204, a1);
  }
  return result;
}

//----- (10016B60) --------------------------------------------------------
char __cdecl sub_10016B60(int a1, float *a2)
{
  char v2; // bl@1
  char result; // al@8

  v2 = 1;
  if ( *(float *)(a1 + 4) > (double)*a2 )
  {
    if ( *(_BYTE *)(a1 + 19) )
    {
      if ( *(_BYTE *)(a1 + 19) == 1 )
        *a2 = *(float *)(a1 + 4);
    }
    else
    {
      v2 = 0;
    }
  }
  if ( *(float *)a1 >= (double)*a2 )
  {
    result = v2;
  }
  else if ( *(_BYTE *)(a1 + 20) )
  {
    result = v2;
    if ( *(_BYTE *)(a1 + 20) == 1 )
      *a2 = *(float *)a1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10016BC0) --------------------------------------------------------
char __usercall sub_10016BC0@<al>(unsigned __int16 a1@<ax>, int a2@<esi>, float a3, char a4, char a5)
{
  unsigned __int8 v5; // cl@1
  char v6; // dl@2
  char v7; // bl@4
  double v8; // st7@6
  int v9; // edi@6
  int v10; // ecx@6
  bool v11; // zf@10
  unsigned int v12; // eax@18
  char v14; // [sp+3h] [bp-5h]@1
  char v15; // [sp+4h] [bp-4h]@2
  char v16; // [sp+10h] [bp+8h]@10
  char v17; // [sp+14h] [bp+Ch]@10

  v5 = *(_BYTE *)(a2 + 10 * a1 + 22535);
  v14 = 10;
  if ( (unsigned __int8)a4 >= 9u )
  {
    v15 = 9;
    v6 = 9;
  }
  else
  {
    v6 = a4;
    v15 = a4;
  }
  v7 = a5;
  if ( (unsigned __int8)a5 >= 9u )
    v7 = 9;
  v8 = a3;
  v9 = v5;
  v10 = 10 * v5;
  if ( *(float *)(a2 + 4 * (v10 + (unsigned __int8)v6) + 53416) >= (double)a3 )
  {
    if ( *(float *)(a2 + 4 * (v10 + (unsigned __int8)v7) + 53416) <= v8 )
    {
      v11 = v7 == v6;
      v16 = 1;
      v17 = 0;
      if ( (unsigned __int8)v7 > (unsigned __int8)v6 )
      {
        v16 = -1;
        v17 = -1;
        v11 = v7 == v6;
      }
      if ( !v11 )
      {
        while ( *(float *)(a2 + 4 * ((unsigned __int8)v7 + v10) + 53416) > v8
             || *(float *)(a2 + 4 * (v10 + (unsigned __int8)v7 + v16) + 53416) < v8 )
        {
          v7 += v16;
          if ( v7 == v15 )
            goto LABEL_18;
        }
        v14 = v7 + v17;
      }
    }
    else
    {
      v14 = v7;
    }
  }
  else
  {
    v14 = v6;
  }
LABEL_18:
  v12 = *(_BYTE *)(44 * v9 + a2 + 52576) - 2;
  if ( (unsigned __int8)v14 < v12 )
    LOBYTE(v12) = v14;
  return v12;
}

//----- (10016CD0) --------------------------------------------------------
double __usercall sub_10016CD0@<st0>(int a1@<eax>, _BYTE *a2@<ebx>, int a3, float a4)
{
  int v4; // esi@1
  unsigned __int8 v5; // al@1
  int v6; // edi@2
  unsigned __int8 v7; // al@2
  char v8; // al@6
  double v9; // st7@7
  double result; // st7@7
  char v11; // [sp+14h] [bp-8h]@4
  char v12; // [sp+18h] [bp-4h]@4
  float v13; // [sp+24h] [bp+8h]@7

  v4 = a1;
  v5 = *(_BYTE *)(a1 + 10 * (unsigned __int16)a3 + 22535);
  if ( v5 >= 0x14u )
  {
    *a2 = 1;
    result = a4;
  }
  else
  {
    v6 = v5;
    v7 = *(_BYTE *)(44 * v5 + v4 + 52576);
    if ( v7 <= 1u || v7 > 0xAu )
      goto LABEL_12;
    v11 = 0;
    v12 = v7 - 1;
    if ( *(float *)(v4 + 4 * (10 * v6 + (unsigned __int8)(v7 - 1)) + 53416) < (double)*(float *)(v4 + 40 * v6 + 53416) )
    {
      v11 = v7 - 1;
      v12 = 0;
    }
    v8 = sub_10016BC0(a3, v4, a4, v12, v11);
    if ( (unsigned __int8)v8 >= 9u )
    {
LABEL_12:
      *a2 = 1;
      result = a4;
    }
    else
    {
      v9 = *(float *)(v4 + 4 * ((unsigned __int8)v8 + 2 * (9 * v6 + 6777))) * a4
         + *(float *)(v4 + 4 * ((unsigned __int8)v8 + 18 * v6) + 54252);
      *a2 = 1;
      v13 = v9;
      result = v13;
    }
  }
  return result;
}

//----- (10016DD0) --------------------------------------------------------
unsigned __int8 __cdecl sub_10016DD0(int a1, int a2, char a3, void *a4)
{
  int v4; // esi@1
  int v5; // ecx@1
  unsigned __int8 result; // al@1
  int v7; // edi@1
  int v8; // esi@4
  char v9; // bl@7
  int v10; // edi@7
  char v11; // al@7
  int v12; // edx@7
  char v13; // al@8
  char v14; // dl@8
  unsigned __int8 v15; // [sp+16h] [bp-156h]@1
  char v16; // [sp+17h] [bp-155h]@7
  int v17; // [sp+18h] [bp-154h]@1
  int v18; // [sp+1Ch] [bp-150h]@1
  int v19; // [sp+20h] [bp-14Ch]@1
  char v20[12]; // [sp+24h] [bp-148h]@7
  float v21[78]; // [sp+30h] [bp-13Ch]@8

  *(float *)a4 = 9.8999998e24;
  v4 = a2;
  v5 = *(_WORD *)(a2 + 16);
  result = 0;
  v7 = a1;
  v17 = a1;
  v19 = a2;
  v15 = 0;
  v18 = v5;
  while ( v15 < *(_BYTE *)(v4 + 18) )
  {
    v5 = (unsigned __int16)v5;
    v8 = v7 + 10 * (unsigned __int16)v5 + 22534;
    switch ( *(_BYTE *)v8 )
    {
      case 1:
        result = sub_10022760(
                   *(_BYTE *)(v7 + 10 * (unsigned __int16)v5 + 22538),
                   *(_WORD *)(v7 + 2 * (5 * v5 + 11270)),
                   *(_WORD *)(v7 + 10 * (unsigned __int16)v5 + 22542),
                   4,
                   a4);
        break;
      case 3:
        result = sub_1002AFF0(COERCE_FLOAT(*(_WORD *)(v7 + 10 * (unsigned __int16)v5 + 22538)), a4);
        break;
      case 4:
        v9 = *(_BYTE *)(v7 + 10 * (unsigned __int16)v5 + 22539);
        v10 = *(_BYTE *)(v7 + 10 * (unsigned __int16)v5 + 22539);
        v11 = sub_10035A70((unsigned int)*(_BYTE *)(v8 + 5) >> 3, 1);
        v12 = *(_BYTE *)(v8 + 4);
        v16 = v11;
        result = sub_10022760(6, (unsigned __int16)word_10068804[v12], 0, 324, v20);
        if ( result )
        {
          v13 = v16;
          v14 = v16;
          *(float *)a4 = v21[v10];
          result = ((unsigned __int8)v20[(unsigned __int8)v13] >> (v9 - 8 * v14)) & 1;
        }
        v7 = v17;
        break;
    }
    ++v15;
    v5 = v18++ + 1;
    if ( result )
    {
      v15 = result;
      goto LABEL_15;
    }
    v4 = v19;
  }
  v15 = result;
  if ( !result )
    return result;
LABEL_15:
  if ( a3 )
  {
    *(float *)a4 = sub_10016CD0(v7, &v15, v5 - 1, *(float *)a4);
    result = v15;
  }
  return result;
}
// 10068804: using guessed type __int16 word_10068804[];
// 10016DD0: using guessed type char var_148[12];
// 10016DD0: using guessed type float var_13C[78];

//----- (10016F60) --------------------------------------------------------
char __cdecl sub_10016F60(unsigned __int16 a1, void *a2)
{
  int v2; // esi@1
  int v3; // eax@1
  char result; // al@4

  *(float *)a2 = 9.8999998e24;
  v2 = sub_10028200(a1);
  v3 = sub_10022780();
  if ( v2 && v3 && *(_WORD *)(v2 + 12) == 6 )
  {
    result = sub_10016DD0(v3, v2, 1, a2);
    if ( result )
      result = sub_10016B60(v2, (float *)a2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10016FC0) --------------------------------------------------------
double __cdecl sub_10016FC0(float a1, float a2, int a3, float a4)
{
  double v4; // st7@2
  double v5; // st7@4
  bool v6; // c0@5
  double v7; // st7@5
  double v9; // st5@7
  bool v10; // c0@7
  bool v11; // c3@7
  float v12; // [sp+8h] [bp-8h]@4
  float v13; // [sp+Ch] [bp-4h]@4
  int v14; // [sp+1Ch] [bp+Ch]@4
  int v15; // [sp+1Ch] [bp+Ch]@4
  int v16; // [sp+1Ch] [bp+Ch]@4
  int v17; // [sp+1Ch] [bp+Ch]@9

  if ( (unsigned __int8)a3 <= 0x64u )
    v4 = (double)(unsigned __int8)a3;
  else
    v4 = 100.0;
  *(float *)&v14 = v4;
  *(float *)&v15 = *(float *)&v14 / 100.0 * a4;
  v12 = (*(float *)&v15 + a4) * 0.5;
  v13 = sub_10035AB0(a1, a4);
  *(float *)&v16 = sub_100359D0(a1, a4);
  v5 = a1;
  if ( a1 < (double)a2 )
  {
    v9 = *(float *)&v16 - v12;
    v10 = v9 < v5;
    v11 = v9 == v5;
    v7 = *(float *)&v16;
    if ( !v10 && !v11 )
      v7 = v13;
  }
  else
  {
    v6 = v13 + v12 < v5;
    v7 = v13;
    if ( v6 )
      return *(float *)&v16;
  }
  *(float *)&v17 = v7;
  return *(float *)&v17;
}

//----- (100170A0) --------------------------------------------------------
char __cdecl sub_100170A0(unsigned __int16 a1, float *a2)
{
  unsigned __int16 v2; // ax@2
  char result; // al@5
  char v4[4]; // [sp+1Ch] [bp-74h]@1
  int v5; // [sp+20h] [bp-70h]@3
  int v6; // [sp+24h] [bp-6Ch]@1
  char v7; // [sp+28h] [bp-68h]@1

  memset(&v7, 0, 0x64u);
  v6 = 0;
  if ( sub_1002B8A0(a1, v4, &v6) == 1 )
  {
    v2 = sub_10011590(v4[0]);
    if ( (unsigned __int16)v6 >= v2 )
    {
      if ( a1 )
      {
        sprintf(&v7, "NO PKT FOR TYPE %d\n", a1);
        sub_10011520("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 593, 0, &v7);
      }
    }
    else if ( sub_10012260(v4[0], v6, &v5) && !sub_10018D80((int)&v5, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0) )
    {
      result = 1;
      *a2 = *(float *)&v5;
      return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100171C0) --------------------------------------------------------
double __cdecl sub_100171C0(float a1)
{
  int v1; // ecx@0
  double result; // st7@1
  float v3; // [sp+0h] [bp-4h]@1
  float v4; // [sp+8h] [bp+4h]@1
  float v5; // [sp+8h] [bp+4h]@3

  v4 = *(float *)v1 * a1 + *(float *)(v1 + 4);
  v3 = *(float *)(v1 + 8);
  result = v4;
  if ( v3 >= (double)v4 )
    result = v3;
  v5 = *(float *)(v1 + 12);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (10017220) --------------------------------------------------------
char __usercall sub_10017220@<al>(int a1@<esi>, unsigned __int16 a2, float *a3)
{
  char v3; // dl@39
  char result; // al@39
  float v5; // [sp+0h] [bp-280h]@11
  float v6[19]; // [sp+4h] [bp-27Ch]@11
  float v7; // [sp+50h] [bp-230h]@11
  float v8[76]; // [sp+54h] [bp-22Ch]@11
  int v9; // [sp+17Ch] [bp-104h]@29
  int v10; // [sp+180h] [bp-100h]@29
  float v11; // [sp+184h] [bp-FCh]@29
  char v12; // [sp+197h] [bp-E9h]@1
  float v13; // [sp+198h] [bp-E8h]@1
  float v14; // [sp+19Ch] [bp-E4h]@1
  float v15; // [sp+1A0h] [bp-E0h]@1
  float v16; // [sp+1A4h] [bp-DCh]@1
  float v17; // [sp+1A8h] [bp-D8h]@1
  float v18; // [sp+1ACh] [bp-D4h]@1
  float v19; // [sp+1B0h] [bp-D0h]@17
  float v20; // [sp+1B4h] [bp-CCh]@37
  float v21; // [sp+1B8h] [bp-C8h]@22
  float v22; // [sp+1BCh] [bp-C4h]@17
  int v23; // [sp+1C0h] [bp-C0h]@1
  int v24[3]; // [sp+1C4h] [bp-BCh]@1
  int v25; // [sp+1D0h] [bp-B0h]@1
  int v26[3]; // [sp+1D4h] [bp-ACh]@1
  int v27; // [sp+1E0h] [bp-A0h]@1
  int v28; // [sp+1E4h] [bp-9Ch]@1
  int v29; // [sp+208h] [bp-78h]@1
  int v30; // [sp+20Ch] [bp-74h]@1
  int v31; // [sp+230h] [bp-50h]@1
  int v32; // [sp+234h] [bp-4Ch]@1
  int v33; // [sp+258h] [bp-28h]@1
  int v34; // [sp+25Ch] [bp-24h]@1

  v12 = 0;
  v25 = 0;
  v26[0] = 0;
  v23 = 0;
  v24[0] = 0;
  v27 = 0;
  v28 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v29 = 0;
  v30 = 0;
  v13 = 0.0;
  v14 = 0.0;
  v15 = 0.0;
  v16 = 0.0;
  v17 = 0.0;
  v18 = 0.0;
  switch ( a2 )
  {
    case 0x3Au:
    case 0x3Bu:
      if ( sub_10032AE0(6091, (int)&v23, 16) )
        sub_10011520("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 192, 0, 0);
      if ( sub_10032AE0(6115, (int)&v25, 16) )
        sub_10011520("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 193, 0, 0);
      v16 = *((float *)&v23 + 2 * a1);
      v15 = *(float *)&v24[2 * a1];
      v13 = *((float *)&v25 + 2 * a1);
      v14 = *(float *)&v26[2 * a1];
      goto LABEL_37;
    case 0x3Cu:
    case 0x3Du:
    case 0x3Eu:
    case 0x3Fu:
    case 0x40u:
      if ( sub_10032AE0(6090, (int)&v31, 40) )
        sub_10011520("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 205, 0, 0);
      if ( sub_10032AE0(6114, (int)&v27, 40) )
        sub_10011520("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 206, 0, 0);
      v16 = *(&v7 + 2 * a2);
      v15 = v8[2 * a2];
      v13 = *(&v5 + 2 * a2);
      v14 = v6[2 * a2];
      goto LABEL_37;
    case 0x41u:
    case 0x42u:
    case 0x43u:
    case 0x44u:
    case 0x45u:
      if ( sub_10032AE0(6092, (int)&v29, 40) )
        sub_10011520("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 218, 0, 0);
      if ( sub_10032AE0(6116, (int)&v33, 40) )
        sub_10011520("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 219, 0, 0);
      v16 = *(&v5 + 2 * a2);
      v15 = v6[2 * a2];
      v13 = *(&v7 + 2 * a2);
      v14 = v8[2 * a2];
      goto LABEL_37;
    case 0x4Eu:
      v19 = 9.8999998e24;
      if ( sub_10032B40(6355, &v22, 4, &v19) )
        sub_10011520("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 228, 0, 0);
      sub_10033160(14, &v12);
      if ( v12 == 10 )
        v22 = v22 * 0.5555555820465088;
      v16 = 9.9999996e24;
      v15 = -9.9999996e24;
      v17 = -9.9999996e24;
      v18 = 9.9999996e24;
      v14 = v22;
      v13 = 1.0;
      goto LABEL_37;
    case 0x4Fu:
      v19 = 9.8999998e24;
      if ( sub_10032B40(6356, &v21, 4, &v19) )
        sub_10011520("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 250, 0, 0);
      sub_10033160(14, &v12);
      if ( v12 == 10 )
        v21 = v21 * 0.5555555820465088;
      v16 = 9.9999996e24;
      v15 = -9.9999996e24;
      v17 = -9.9999996e24;
      v18 = 9.9999996e24;
      v14 = v21;
      v13 = 1.0;
      goto LABEL_37;
    case 0x98u:
    case 0x99u:
      v16 = 9.9999996e24;
      v15 = -9.9999996e24;
      v13 = 1.0;
      v14 = 0.0;
      goto LABEL_37;
    case 0x67u:
      if ( !sub_10032AE0(6162, (int)&v13, 24) )
        goto LABEL_37;
      v11 = 0.0;
      v10 = 0;
      v9 = 282;
      goto LABEL_36;
    case 0x68u:
    case 0xC0u:
      if ( !sub_10032AE0(6161, (int)&v13, 24) )
        goto LABEL_37;
      v11 = 0.0;
      v10 = 0;
      v9 = 287;
      goto LABEL_36;
    case 0x69u:
      if ( !sub_10032AE0(6160, (int)&v13, 24) )
        goto LABEL_37;
      v11 = 0.0;
      v10 = 0;
      v9 = 291;
      goto LABEL_36;
    case 0x70u:
      if ( sub_10032AE0(6235, (int)&v13, 24) )
      {
        v11 = 0.0;
        v10 = 0;
        v9 = 295;
LABEL_36:
        sub_10011520("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", v9, v10, (char *)LODWORD(v11));
      }
LABEL_37:
      if ( sub_100170A0(a2, &v20) && (LODWORD(v20) & 0x7F800000) != 2139095040 )
      {
        *a3 = sub_100171C0(v20);
        result = v3;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 10017220: using guessed type int var_AC[3];
// 10017220: using guessed type int var_BC[3];
// 10017220: using guessed type float var_22C[76];
// 10017220: using guessed type float var_27C[19];

//----- (10017760) --------------------------------------------------------
char __cdecl sub_10017760(char a1, bool *a2)
{
  char result; // al@1
  int v3; // [sp+4h] [bp-8h]@3

  result = 0;
  *a2 = 0;
  if ( a1 )
  {
    if ( a1 != 1 )
      return result;
    result = sub_10012260(0, 257, &v3);
  }
  else
  {
    result = sub_10012260(0, 256, &v3);
  }
  if ( result )
    *a2 = (v3 & 4) == 4;
  return result;
}

//----- (100177C0) --------------------------------------------------------
char __cdecl sub_100177C0(char a1, bool *a2)
{
  char result; // al@1
  int v3; // [sp+4h] [bp-8h]@3

  result = 0;
  *a2 = 0;
  if ( a1 )
  {
    if ( a1 != 1 )
      return result;
    result = sub_10012260(0, 257, &v3);
  }
  else
  {
    result = sub_10012260(0, 256, &v3);
  }
  if ( result )
    *a2 = (v3 & 1) == 1;
  return result;
}

//----- (10017820) --------------------------------------------------------
char __cdecl sub_10017820(float *a1)
{
  double v1; // st7@5
  double v2; // st7@10
  double v3; // st3@13
  char result; // al@13
  double v5; // st7@13
  char v6; // [sp+7h] [bp-29h]@1
  float v7; // [sp+8h] [bp-28h]@3
  float v8; // [sp+Ch] [bp-24h]@1
  float v9; // [sp+10h] [bp-20h]@8
  float v10; // [sp+14h] [bp-1Ch]@13
  float v11; // [sp+18h] [bp-18h]@13
  float v12; // [sp+1Ch] [bp-14h]@13
  float v13; // [sp+20h] [bp-10h]@13
  float v14; // [sp+24h] [bp-Ch]@13
  float v15; // [sp+28h] [bp-8h]@2
  float v16; // [sp+2Ch] [bp-4h]@13

  sub_10013750((bool *)&v6);
  if ( sub_100170A0(0xC9u, &v8) && sub_100170A0(0xCAu, &v15) )
  {
    if ( !sub_100133D0(&v7) )
    {
      if ( v6 )
        v1 = 59501.773;
      else
        v1 = 17857.426;
      v7 = v1;
    }
    if ( !sub_100170A0(0x75u, &v9) )
    {
      if ( v6 )
        v2 = 105007.18;
      else
        v2 = 84667.641;
      v9 = v2;
    }
    v10 = v15 + 273.1499938964844;
    v11 = v10 * v10;
    v12 = v11 * v10;
    v16 = v10 * v12;
    v15 = v7 + v8;
    v13 = v15 * 0.000145037702168338;
    v7 = v13 * v13;
    v8 = v7 * v13;
    v14 = v8 * v13;
    v15 = exp(-v13 / 464.7000122070312);
    v3 = v16;
    v16 = (13.75137901306152 - v10 * 0.1226860210299492 + v11 * 0.0003980170004069805 - v12 * 0.0000004366189898519224)
        * v13
        + 10742.181640625
        - 177.0700836181641 * v10
        + 1.059352517127991 * v11
        - 0.002737746108323336 * v12
        + 0.000002587880089777173 * v16
        + (0.001406852970831096 - v10 * 0.000008421870006714016 + v11 * 0.0000000123934995599484) * v7
        + (v10 * 1.458149920252616e-11 - 0.000000004256659913437488) * v8
        + v14 * 5.409509849069703e-14;
    result = 1;
    v5 = v16 * (1.0 - v15);
    v16 = (0.001010339008644223 - v10 * 0.000006046890121069737 + v11 * 0.000000008856750000063585) * v7
        + v13
        * (4.909426212310791 - v10 * 0.02970160357654095 + v11 * 0.00007757999992463738 - v12
                                                                                        * 0.00000007407909663470491)
        + 329.7364501953125
        - v10 * 4.856092929840088
        + v11 * 0.02650014311075211
        - v12 * 0.00006350519834086299
        + v3 * 0.00000005639689959480165
        + (0.00000001747300082399761 - v10 * 3.771030016030963e-11) * v8
        - v14 * 4.320039985461488e-12;
    v8 = v5 + v16 * v15;
    *a1 = v8 * 6894.75927734375 - v9;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10017AC0) --------------------------------------------------------
double sub_10017AC0()
{
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v1 = 9.8999998e24;
  sub_10032B40(10043, &v2, 4, &v1);
  return v2;
}

//----- (10017AF0) --------------------------------------------------------
double sub_10017AF0()
{
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v1 = 9.8999998e24;
  sub_10032B40(10002, &v2, 4, &v1);
  return v2;
}

//----- (10017B20) --------------------------------------------------------
void __usercall sub_10017B20(int a1@<esi>, int a2, float a3)
{
  signed int v3; // ebx@1
  int v4; // ecx@1
  int v5; // edx@1
  double v6; // st7@3
  double v7; // st6@4
  double v8; // st6@5
  double v9; // st7@5
  double v10; // st6@8
  double v11; // st7@8
  int v12; // edi@10
  signed int v13; // ecx@10
  int v14; // ebx@11
  signed int v15; // edx@11
  int v16; // ebp@13
  float *v17; // eax@19
  int v18; // [sp+4h] [bp-4h]@13
  float *v19; // [sp+10h] [bp+8h]@11
  float v20; // [sp+10h] [bp+8h]@19

  v3 = *(_BYTE *)(a1 + 320);
  v4 = v3 - 1;
  v5 = 0;
  if ( *(float *)(a1 + 8 * v3 - 4) < (double)*(float *)(a1 + 4) )
  {
    v5 = v3 - 1;
    v4 = 0;
  }
  v6 = a3;
  if ( *(float *)(a1 + 8 * v4 + 4) < (double)a3 )
  {
    v7 = 0.0;
    if ( 0.0 != v6 )
    {
      v8 = *(float *)(a1 + 8 * v4) / v6;
      v9 = 0.0;
      *(float *)a2 = v8;
      *(float *)(a2 + 4) = *(float *)&v9;
      return;
    }
LABEL_9:
    *(float *)a2 = v7;
    *(float *)(a2 + 4) = v7;
    return;
  }
  if ( *(float *)(a1 + 8 * v5 + 4) > v6 )
  {
    v7 = 0.0;
    if ( 0.0 != v6 )
    {
      v10 = *(float *)(a1 + 8 * v5) / v6;
      v11 = 0.0;
      *(float *)a2 = v10;
      *(float *)(a2 + 4) = *(float *)&v11;
      return;
    }
    goto LABEL_9;
  }
  v12 = 0;
  v13 = 1;
  if ( v3 <= 1 )
  {
LABEL_18:
    *(float *)a2 = 0.0;
    *(float *)(a2 + 4) = *(float *)(a1 + 8 * v12);
  }
  else
  {
    v14 = 0;
    v15 = 8;
    v19 = (float *)(a1 + 12);
    while ( 1 )
    {
      if ( *(float *)(v14 + a1 + 4) >= (double)*v19 )
      {
        v12 = v13 - 1;
        v14 = v15 - 8;
        v16 = v13;
        v18 = v15;
      }
      else
      {
        v12 = v13;
        v14 = v15;
        v16 = v13 - 1;
        v18 = v15 - 8;
      }
      if ( *(float *)(v14 + a1 + 4) > v6 && *(float *)(v18 + a1 + 4) <= v6 )
        break;
      v19 += 2;
      ++v13;
      v15 += 8;
      if ( v13 >= *(_BYTE *)(a1 + 320) )
        goto LABEL_18;
    }
    v17 = (float *)(a1 + 8 * v12 + 4);
    v20 = (*(float *)(a1 + 8 * v12) - *(float *)(a1 + 8 * v16)) / (*v17 - *(float *)(a1 + 8 * v16 + 4));
    *(float *)a2 = v20;
    *(float *)(a2 + 4) = *(float *)(a1 + 8 * v12) - v20 * *v17;
  }
}

//----- (10017C80) --------------------------------------------------------
char __usercall sub_10017C80@<al>(float *a1@<edi>, unsigned __int16 a2@<si>, unsigned __int8 a3)
{
  double v3; // st7@8
  char result; // al@10
  char v5; // [sp+7h] [bp-29h]@3
  float v6; // [sp+8h] [bp-28h]@1
  float v7; // [sp+Ch] [bp-24h]@3
  int v8; // [sp+10h] [bp-20h]@1
  int v9; // [sp+14h] [bp-1Ch]@1
  int v10; // [sp+18h] [bp-18h]@1
  int v11; // [sp+1Ch] [bp-14h]@1
  float v12[4]; // [sp+20h] [bp-10h]@1

  v6 = 0.0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  if ( sub_10032B40(6117, v12, 16, &v8) )
    sub_10011520("..\\lib\\adl\\iop_eis_intf.c", 2716, 0, 0);
  sub_10011920(1, 0x50u, &v5);
  if ( sub_10032B80(6354, (int)&v7, 4) )
    sub_10011520("..\\lib\\adl\\iop_eis_intf.c", 2735, 0, 0);
  if ( (sub_1002BAF0(a2) || v5) && sub_100170A0(a2, &v6) )
  {
    v6 = v12[2 * a3] * v6;
    v3 = v6;
    *a1 = v6;
    if ( v7 > v3 )
      *a1 = 0.0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10017C80: using guessed type float var_10[4];

//----- (10017D70) --------------------------------------------------------
char __usercall sub_10017D70@<al>(unsigned __int16 *a1@<eax>, int a2, float *a3, unsigned __int8 a4)
{
  int v4; // ecx@1
  unsigned __int16 *v5; // esi@1
  char v6; // al@1
  double v7; // st7@1
  int v8; // ebp@1
  unsigned __int8 v9; // bl@4
  char result; // al@7
  int v11; // eax@9
  unsigned __int16 *v12; // edi@9
  int v13; // eax@11
  int v14; // eax@14
  int v15; // eax@17
  double v16; // st7@22
  double v17; // st7@24
  int v18; // edi@31
  int v19; // [sp-8h] [bp-A0h]@12
  int v20; // [sp-4h] [bp-9Ch]@12
  float v21; // [sp+0h] [bp-98h]@12
  float v22; // [sp+14h] [bp-84h]@1
  float v23; // [sp+18h] [bp-80h]@1
  int v24; // [sp+1Ch] [bp-7Ch]@1
  int v25; // [sp+20h] [bp-78h]@5
  float v26; // [sp+24h] [bp-74h]@6
  float v27; // [sp+28h] [bp-70h]@9
  float v28; // [sp+2Ch] [bp-6Ch]@9
  float v29; // [sp+38h] [bp-60h]@10
  float v30; // [sp+3Ch] [bp-5Ch]@11
  float v31; // [sp+48h] [bp-50h]@13
  float v32; // [sp+4Ch] [bp-4Ch]@14
  float v33; // [sp+70h] [bp-28h]@16
  float v34; // [sp+74h] [bp-24h]@17

  v4 = a2;
  v5 = a1;
  *a3 = -1.0;
  v6 = *(_BYTE *)(a2 + 320);
  v7 = 0.0;
  v8 = 0;
  v22 = 0.0;
  v23 = 0.0;
  v24 = 0;
  if ( !v6 || v6 == 1 && 0.0 == *(float *)a2 )
  {
    if ( a4 )
    {
      v18 = a4;
      do
      {
        if ( sub_1002BAF0(*v5) )
        {
          ++v8;
          if ( sub_10017220((int)v5, *v5, &v22) )
          {
            ++v24;
            v23 = v23 + v22;
          }
        }
        ++v5;
        --v18;
      }
      while ( v18 );
      if ( v8 != v24 )
        goto LABEL_42;
    }
    *a3 = v23;
    if ( v8 <= 0 )
LABEL_42:
      result = 0;
    else
      result = 1;
    return result;
  }
  v9 = 0;
  if ( !a4 )
    goto LABEL_5;
  while ( 2 )
  {
    v28 = v7;
    v11 = v5[v9];
    v27 = v7;
    v12 = &v5[v9];
    switch ( v11 )
    {
      case 58:
      case 59:
        if ( !sub_10032AE0(6091, (int)&v29, 16) )
        {
          v13 = 8 * *v12 - 464;
          v28 = *(float *)((char *)&v29 + v13);
          v27 = *(float *)((char *)&v30 + v13);
          goto LABEL_20;
        }
        v21 = 0.0;
        v20 = 0;
        v19 = 2889;
        goto LABEL_19;
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
        if ( !sub_10032AE0(6090, (int)&v31, 40) )
        {
          v14 = 8 * *v12 - 480;
          v28 = *(float *)((char *)&v31 + v14);
          v27 = *(float *)((char *)&v32 + v14);
          goto LABEL_20;
        }
        v21 = 0.0;
        v20 = 0;
        v19 = 2921;
        goto LABEL_19;
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
        if ( sub_10032AE0(6092, (int)&v33, 40) )
        {
          v21 = 0.0;
          v20 = 0;
          v19 = 2953;
LABEL_19:
          sub_10011520("..\\lib\\adl\\iop_eis_intf.c", v19, v20, (char *)LODWORD(v21));
        }
        else
        {
          v15 = 8 * *v12 - 520;
          v28 = *(float *)((char *)&v33 + v15);
          v27 = *(float *)((char *)&v34 + v15);
        }
LABEL_20:
        if ( sub_1002BAF0(*v12) )
        {
          ++v8;
          if ( sub_100170A0(*v12, &v22) )
          {
            v16 = v22;
            if ( v27 >= (double)v22 )
              v16 = v27;
            v22 = v16;
            v17 = v22;
            if ( v28 <= (double)v22 )
              v17 = v28;
            ++v24;
            v22 = v17;
            v23 = v22 + v23;
          }
        }
        if ( ++v9 < a4 )
        {
          v7 = 0.0;
          continue;
        }
        v4 = a2;
LABEL_5:
        sub_10017B20(v4, (int)&v25, v23);
        if ( v8 != v24 || (*a3 = *(float *)&v25 * v23 + v26, v8 <= 0) )
LABEL_29:
          result = 0;
        else
          result = 1;
        return result;
      default:
        goto LABEL_29;
    }
  }
}

//----- (10018050) --------------------------------------------------------
char __cdecl sub_10018050(float *a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-144h]@1

  if ( sub_10032AE0(6266, (int)&v2, 324) )
  {
    sub_10011520("..\\lib\\adl\\iop_eis_intf.c", 590, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10017D70((unsigned __int16 *)&unk_10069EFC, (int)&v2, a1, 2u);
  }
  return result;
}

//----- (100180C0) --------------------------------------------------------
char __cdecl sub_100180C0(float *a1)
{
  return sub_10017C80(a1, 0x14u, 0);
}

//----- (100180E0) --------------------------------------------------------
char __cdecl sub_100180E0(float *a1)
{
  return sub_10017C80(a1, 0x2Du, 1u);
}

//----- (10018100) --------------------------------------------------------
char __cdecl sub_10018100(float *a1)
{
  char v1; // bl@1
  char result; // al@4
  float v3; // [sp+4h] [bp-8h]@1
  float v4; // [sp+8h] [bp-4h]@1

  v3 = 0.0;
  v4 = 0.0;
  v1 = 0;
  if ( sub_100180C0(&v3) )
  {
    v1 = 1;
    v4 = v3 + 0.0;
  }
  if ( sub_100180E0(&v3) )
  {
    result = 1;
    v4 = v4 + v3;
    *a1 = v4;
  }
  else if ( v1 )
  {
    result = v1;
    *a1 = v4;
  }
  else
  {
    *a1 = 9.8999998e24;
    result = 0;
  }
  return result;
}

//----- (10018190) --------------------------------------------------------
char __cdecl sub_10018190(float *a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-144h]@1

  if ( sub_10032AE0(6265, (int)&v2, 324) )
  {
    sub_10011520("..\\lib\\adl\\iop_eis_intf.c", 1606, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10017D70(L"<=>?@", (int)&v2, a1, 5u);
  }
  return result;
}
// 10069F08: using guessed type wchar_t a__[6];

//----- (10018200) --------------------------------------------------------
char __cdecl sub_10018200(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  const wchar_t *v3; // esi@3
  int v4; // [sp+4h] [bp-154h]@5
  char v5[4]; // [sp+8h] [bp-150h]@5
  int v6; // [sp+Ch] [bp-14Ch]@5
  char v7; // [sp+10h] [bp-148h]@6
  char v8; // [sp+14h] [bp-144h]@1

  v1 = 0;
  if ( sub_10032AE0(6266, (int)&v8, 324) )
  {
    sub_10011520("..\\lib\\adl\\iop_eis_intf.c", 1847, 0, "Center cal points undefined");
    result = 0;
  }
  else
  {
    v3 = L":;<=>?@";
    while ( !v1 )
    {
      LOWORD(v4) = *v3;
      v1 = sub_1002B8A0(v4, v5, &v6);
      if ( v1 )
        v1 = sub_10012260(v5[0], v6, &v7);
      ++v3;
      if ( (signed int)v3 >= (signed int)L"\u3b00\u3c00\u3d00\u3e00\u3f00\u4000" )
      {
        if ( !v1 )
          goto LABEL_10;
        break;
      }
    }
    v1 = sub_10017D70((unsigned __int16 *)&v4, (int)&v8, a1, 1u);
LABEL_10:
    result = v1;
  }
  return result;
}
// 10069F14: using guessed type wchar_t a___0[8];

//----- (100182D0) --------------------------------------------------------
char __cdecl sub_100182D0(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  wchar_t *v3; // esi@3
  int v4; // [sp+4h] [bp-154h]@5
  char v5[4]; // [sp+8h] [bp-150h]@5
  int v6; // [sp+Ch] [bp-14Ch]@5
  char v7; // [sp+10h] [bp-148h]@6
  char v8; // [sp+14h] [bp-144h]@1

  v1 = 0;
  if ( sub_10032AE0(6265, (int)&v8, 324) )
  {
    sub_10011520("..\\lib\\adl\\iop_eis_intf.c", 1946, 0, "Left cal points undefined");
    result = 0;
  }
  else
  {
    v3 = L"\u3b00\u3c00\u3d00\u3e00\u3f00\u4000";
    while ( !v1 )
    {
      LOWORD(v4) = *v3;
      v1 = sub_1002B8A0(v4, v5, &v6);
      if ( v1 )
        v1 = sub_10012260(v5[0], v6, &v7);
      ++v3;
      if ( (signed int)v3 >= (signed int)&a___0[7] )
      {
        if ( !v1 )
          goto LABEL_10;
        break;
      }
    }
    v1 = sub_10017D70((unsigned __int16 *)&v4, (int)&v8, a1, 1u);
LABEL_10:
    result = v1;
  }
  return result;
}
// 10069F14: using guessed type wchar_t a___0[8];

//----- (100183A0) --------------------------------------------------------
char __cdecl sub_100183A0(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  const wchar_t *v3; // esi@3
  int v4; // [sp+4h] [bp-154h]@5
  char v5[4]; // [sp+8h] [bp-150h]@5
  int v6; // [sp+Ch] [bp-14Ch]@5
  char v7; // [sp+10h] [bp-148h]@6
  char v8; // [sp+14h] [bp-144h]@1

  v1 = 0;
  if ( sub_10032AE0(6267, (int)&v8, 324) )
  {
    sub_10011520("..\\lib\\adl\\iop_eis_intf.c", 2045, 0, "Right cal points undefined");
    result = 0;
  }
  else
  {
    v3 = L"ABCDE";
    while ( !v1 )
    {
      LOWORD(v4) = *v3;
      v1 = sub_1002B8A0(v4, v5, &v6);
      if ( v1 )
        v1 = sub_10012260(v5[0], v6, &v7);
      ++v3;
      if ( (signed int)v3 >= (signed int)&aAbcde_0[5] )
      {
        if ( !v1 )
          goto LABEL_10;
        break;
      }
    }
    v1 = sub_10017D70((unsigned __int16 *)&v4, (int)&v8, a1, 1u);
LABEL_10:
    result = v1;
  }
  return result;
}
// 10069F24: using guessed type wchar_t aAbcde_0[6];

//----- (10018470) --------------------------------------------------------
char __cdecl sub_10018470(float *a1)
{
  char v1; // bl@1
  char result; // al@6
  float v3; // [sp+4h] [bp-8h]@1
  float v4; // [sp+8h] [bp-4h]@1

  v3 = 0.0;
  v4 = 0.0;
  v1 = 0;
  if ( sub_10018200(&v3) )
  {
    v1 = 1;
    v4 = v3 + 0.0;
  }
  if ( sub_100182D0(&v3) )
  {
    v1 = 1;
    v4 = v4 + v3;
  }
  if ( sub_100183A0(&v3) )
  {
    v4 = v4 + v3;
    *a1 = v4;
    result = 1;
  }
  else
  {
    if ( v1 )
      *a1 = v4;
    result = v1;
  }
  return result;
}

//----- (10018510) --------------------------------------------------------
char __cdecl sub_10018510(float *a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-144h]@1

  if ( sub_10032AE0(6267, (int)&v2, 324) )
  {
    sub_10011520("..\\lib\\adl\\iop_eis_intf.c", 2199, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10017D70(L"ABCDE", (int)&v2, a1, 5u);
  }
  return result;
}
// 10069F30: using guessed type wchar_t aAbcde[6];

//----- (10018580) --------------------------------------------------------
double sub_10018580()
{
  int v0; // eax@1
  double result; // st7@1
  float v2; // [sp+0h] [bp-10h]@1
  float v3; // [sp+4h] [bp-Ch]@1
  double v4; // [sp+8h] [bp-8h]@2

  v3 = 9.8999998e24;
  v0 = sub_10032B40(10009, &v2, 4, &v3);
  result = v2;
  if ( !v0 )
  {
    v4 = v2;
    v2 = v4 - sub_10017AF0();
    if ( v2 >= 0.0 )
    {
      result = v2;
    }
    else
    {
      v2 = 0.0;
      result = (float)0.0;
    }
  }
  return result;
}

//----- (100185E0) --------------------------------------------------------
char __cdecl sub_100185E0(float *a1)
{
  char v1; // bl@1
  char result; // al@6
  float v3; // [sp+4h] [bp-8h]@1
  float v4; // [sp+8h] [bp-4h]@1

  v3 = 0.0;
  v4 = 0.0;
  v1 = 0;
  if ( sub_10018190(&v3) )
  {
    v1 = 1;
    v4 = v3 + 0.0;
  }
  if ( sub_10018050(&v3) )
  {
    v1 = 1;
    v4 = v4 + v3;
  }
  if ( sub_10018510(&v3) )
  {
    v4 = v4 + v3;
    *a1 = v4;
    result = 1;
  }
  else
  {
    if ( v1 )
      *a1 = v4;
    result = v1;
  }
  return result;
}

//----- (10018680) --------------------------------------------------------
char __cdecl sub_10018680(float a1, int a2)
{
  double v2; // st7@1
  long double v3; // st7@1
  char result; // al@2
  float v5; // [sp+4h] [bp+4h]@1
  float v6; // [sp+4h] [bp+4h]@4
  float v7; // [sp+4h] [bp+4h]@5

  v2 = a1;
  v5 = a1 / 101325.0;
  v3 = v2 / 22631.953125;
  if ( v3 > 0.0 )
  {
    if ( v5 <= 0.223360002040863 )
    {
      v7 = log(v3);
      result = 1;
      *(float *)a2 = 11000.232421875 - v7 * 6341.615234375;
    }
    else
    {
      v6 = pow(v5, 0.1902630904662425);
      result = 1;
      *(float *)a2 = (v6 - 1.0) * -44330.76953125;
    }
  }
  else
  {
    *(float *)a2 = 9.8999998e24;
    result = 0;
  }
  return result;
}

//----- (10018720) --------------------------------------------------------
char __cdecl sub_10018720(char *a1)
{
  int v1; // ecx@0
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  sub_1000BB40(13, (char *)&v3 + 3);
  sub_1000BB40(12, a1);
  return BYTE3(v3);
}

//----- (10018750) --------------------------------------------------------
bool __cdecl sub_10018750(int a1, void *a2, int a3)
{
  unsigned __int16 v3; // ax@2
  bool result; // al@5
  char v5[4]; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v5[0] = -1;
  v6 = 0;
  result = 0;
  if ( sub_10022560(a1, a3, v5, &v6) == 1 )
  {
    v3 = sub_10011590(v5[0]);
    if ( (unsigned __int16)v6 < v3 && sub_10012260(v5[0], v6, a2) && !sub_10018D30(a2, 0, 0) )
      result = 1;
  }
  return result;
}

//----- (100187D0) --------------------------------------------------------
char __cdecl sub_100187D0(unsigned __int16 a1)
{
  char result; // al@3
  char v2; // [sp+Bh] [bp-9h]@3
  int v3; // [sp+Ch] [bp-8h]@1
  int v4; // [sp+10h] [bp-4h]@1

  LOBYTE(v4) = 7;
  v3 = 0;
  if ( sub_10022560(a1, 0, &v4, &v3) != 1 && sub_10022560(a1, 1u, &v4, &v3) != 1
    || (result = sub_10011920(v4, v3, &v2), result != 1)
    || v2 != 1 )
  {
    result = 0;
  }
  return result;
}

//----- (10018840) --------------------------------------------------------
char __cdecl sub_10018840(unsigned __int16 a1, char a2)
{
  void *v2; // ecx@0
  char v3; // al@1
  unsigned __int16 v4; // ax@1
  int v6; // [sp+0h] [bp-Ch]@1
  int v7; // [sp+4h] [bp-8h]@1
  int v8; // [sp+8h] [bp-4h]@1

  LOBYTE(v6) = -1;
  v7 = 0;
  v3 = sub_1001A5F0(v2);
  LOBYTE(v8) = v3 != 0;
  LOBYTE(v4) = sub_100225C0(a1, v3 != 0, &v6, &v7);
  if ( (_BYTE)v4 == 1 )
  {
    v4 = sub_10011590(v6);
    if ( (unsigned __int16)v7 < v4 )
      LOBYTE(v4) = sub_10011D60(v6, v7, &a2, 0, 1, 1);
  }
  return v4;
}

//----- (100188B0) --------------------------------------------------------
bool __cdecl sub_100188B0(int a1, void *a2)
{
  void *v2; // ecx@0
  int v3; // ST0C_4@1

  v3 = (int)v2;
  LOBYTE(v3) = sub_1001A5F0(v2) != 0;
  return sub_10018750(a1, a2, v3);
}

//----- (100188E0) --------------------------------------------------------
signed int sub_100188E0()
{
  signed int result; // eax@3

  if ( (unsigned __int8)byte_101BDCD4 > 2u )
    sub_10011520("..\\lib\\adl\\iop_ap_intf.c", 958, 0, 0);
  result = (unsigned __int8)byte_101BDCD4;
  if ( (unsigned __int8)byte_101BDCD4 >= 2u )
    result = 2;
  byte_101BDCD4 = result;
  return result;
}
// 101BDCD4: using guessed type char byte_101BDCD4;

//----- (10018920) --------------------------------------------------------
char __thiscall sub_10018920(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10032B80(3190, (int)&v2 + 3, 1);
  return BYTE3(v2);
}

//----- (10018940) --------------------------------------------------------
char __cdecl sub_10018940(char a1)
{
  char result; // al@2
  char v2; // [sp+2h] [bp-2h]@1
  char v3; // [sp+3h] [bp-1h]@1

  v3 = 1;
  v2 = 1;
  if ( a1 )
  {
    sub_10032B40(9420, &v2, 1, &v3);
    result = v2;
  }
  else
  {
    sub_10032B40(9419, &v2, 1, &v3);
    result = v2;
  }
  return result;
}

//----- (10018990) --------------------------------------------------------
BOOL sub_10018990()
{
  signed int v0; // esi@1
  int *v1; // edi@1
  bool v2; // al@4
  __int16 v4; // [sp+8h] [bp-1Ch]@1
  __int16 v5; // [sp+10h] [bp-14h]@1
  __int16 v6; // [sp+12h] [bp-12h]@1
  int v7; // [sp+14h] [bp-10h]@1
  int v8; // [sp+18h] [bp-Ch]@1
  int v9; // [sp+1Ch] [bp-8h]@1
  int v10; // [sp+20h] [bp-4h]@1

  v5 = 1104;
  v6 = 1105;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v4 = 0;
  v0 = 0;
  v1 = &v7;
  do
  {
    v2 = sub_10012260(1, (unsigned __int16)*(&v5 + v0), v1) && !sub_10027860((int)v1);
    if ( v2 && *((_BYTE *)v1 + 7) )
      *((_BYTE *)&v4 + v0) = 1;
    ++v0;
    v1 += 2;
  }
  while ( v0 < 2 );
  return v4 != 0;
}

//----- (10018A30) --------------------------------------------------------
char sub_10018A30()
{
  char v1; // [sp+2h] [bp-2h]@1
  char v2; // [sp+3h] [bp-1h]@1

  v1 = 0;
  v2 = 0;
  sub_10032B40(6888, &v1, 1, &v2);
  return v1;
}

//----- (10018A60) --------------------------------------------------------
char sub_10018A60()
{
  char result; // al@1

  byte_101BDCD4 = 2;
  result = sub_1001A410(4);
  if ( result )
  {
    byte_101BDCD4 = 0;
  }
  else
  {
    result = sub_1001A410(7);
    if ( result )
      byte_101BDCD4 = 1;
  }
  return result;
}
// 101BDCD4: using guessed type char byte_101BDCD4;

//----- (10018AA0) --------------------------------------------------------
double __cdecl sub_10018AA0(char a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  void *v3; // ecx@1
  char v5; // [sp+4h] [bp-Ch]@2
  float v6; // [sp+8h] [bp-8h]@2

  v2 = sub_1001A5F0(v1);
  if ( sub_10018920(v3) )
    goto LABEL_2;
  if ( a1 )
  {
    if ( v2 )
    {
      sub_10032B80(2015, (int)&v5, 12);
      return v6;
    }
    sub_10032B80(2101, (int)&v5, 12);
  }
  else
  {
    if ( !v2 )
    {
LABEL_2:
      sub_10032B80(2015, (int)&v5, 12);
      return v6;
    }
    sub_10032B80(2101, (int)&v5, 12);
  }
  return v6;
}

//----- (10018B20) --------------------------------------------------------
bool __usercall sub_10018B20@<al>(int a1@<eax>)
{
  signed int v1; // eax@17
  bool result; // al@19

  result = 0;
  if ( *(_BYTE *)(a1 + 2) < 3u
    && *(_BYTE *)(a1 + 10) < 3u
    && *(_BYTE *)a1 < 8u
    && *(_BYTE *)(a1 + 1) < 0xBu
    && *(_BYTE *)(a1 + 3) < 0xFu
    && *(_BYTE *)(a1 + 4) < 0xDu
    && *(_BYTE *)(a1 + 5) < 6u
    && *(_BYTE *)(a1 + 24) < 0xDu
    && *(_BYTE *)(a1 + 6) < 7u
    && *(_BYTE *)(a1 + 25) < 0xDu
    && *(_BYTE *)(a1 + 7) < 0xEu
    && *(_BYTE *)(a1 + 8) < 0xDu
    && *(_BYTE *)(a1 + 9) < 8u
    && *(_BYTE *)(a1 + 26) < 0xDu
    && *(_BYTE *)(a1 + 11) < 0x13u
    && *(_BYTE *)(a1 + 12) < 0xDu )
  {
    v1 = *(_DWORD *)(a1 + 20);
    if ( v1 >= 0 && v1 <= 357913941 )
      result = 1;
  }
  return result;
}

//----- (10018B90) --------------------------------------------------------
char __cdecl sub_10018B90(char *a1)
{
  char *v1; // edi@1
  char v2; // bl@1
  signed int v3; // ebp@1
  char *v4; // esi@1
  char v5; // al@2
  bool v6; // al@4
  char result; // al@13
  char v8; // dh@15
  bool v9; // al@16
  bool v10; // bl@20
  void *v11; // ecx@22
  char v12; // al@23
  int v13; // eax@23
  __int16 v14; // [sp+10h] [bp-88h]@1
  int v15; // [sp+14h] [bp-84h]@1
  char *v16; // [sp+18h] [bp-80h]@1
  char v17; // [sp+1Ch] [bp-7Ch]@27
  char v18; // [sp+20h] [bp-78h]@16
  char v19; // [sp+3Eh] [bp-5Ah]@29
  char v20; // [sp+58h] [bp-40h]@1
  char v21; // [sp+5Ch] [bp-3Ch]@19
  char v22; // [sp+7Ah] [bp-1Eh]@31

  v16 = a1;
  v15 = 3342386;
  v1 = 0;
  v2 = sub_100188E0();
  v14 = 0;
  v3 = 1;
  v4 = &v20;
  do
  {
    v5 = sub_10012260(1, *((_WORD *)&v15 + v3), v4);
    *((_BYTE *)&v14 + v3) = v5;
    v6 = v5 && !sub_10027F40((unsigned __int8 *)v4);
    *((_BYTE *)&v14 + v3) = v6;
    if ( v6 && *v4 == v2 )
      v1 = v4;
    --v3;
    v4 -= 60;
  }
  while ( v3 >= 0 );
  if ( !v1 )
    return 0;
  if ( v2 )
  {
    if ( v2 != 1 )
      return 0;
    goto LABEL_34;
  }
  v8 = HIBYTE(v14);
  if ( !(_BYTE)v14 || (v9 = sub_10018B20((int)&v18), LOBYTE(v14) = 1, !v9) )
    LOBYTE(v14) = 0;
  v10 = v8 && sub_10018B20((int)&v21);
  if ( sub_10018A30() )
  {
    v12 = sub_1001A5F0(v11);
    LOBYTE(v15) = v12;
    v13 = (unsigned __int8)sub_10018940(v12) - 1;
    if ( v13 )
    {
      if ( v13 != 1 )
        return 0;
      goto LABEL_32;
    }
    if ( !(_BYTE)v14 )
      return 0;
LABEL_27:
    result = 1;
    qmemcpy(v16, &v17, 0x3Cu);
    return result;
  }
  if ( (_BYTE)v14 && (v19 || !v10 || !v22) )
    goto LABEL_27;
LABEL_32:
  if ( !v10 )
    return 0;
  v1 = &v20;
LABEL_34:
  result = 1;
  qmemcpy(v16, v1, 0x3Cu);
  return result;
}

//----- (10018D10) --------------------------------------------------------
void sub_10018D10()
{
  sub_10018AA0(0);
}

//----- (10018D20) --------------------------------------------------------
void sub_10018D20()
{
  sub_10018AA0(1);
}

//----- (10018D30) --------------------------------------------------------
signed int __cdecl sub_10018D30(_BYTE *a1, char a2, int a3)
{
  signed int result; // eax@1

  result = -4;
  if ( a3 && a3 != 1 || (!*a1 || *a1 == 1 ? (result = 0) : (result = -2), a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_11;
  }
  if ( result )
  {
LABEL_11:
    *a1 = a2;
    result = 1;
  }
  return result;
}

//----- (10018D80) --------------------------------------------------------
int __cdecl sub_10018D80(int a1, float a2, float a3, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  char v7; // dl@4
  char v8; // al@4
  char v9; // dl@4
  int result; // eax@5
  double v11; // st7@7
  unsigned int v12; // eax@21

  v5 = a1;
  v6 = a1 & 3;
  if ( a1 & 3 || (unsigned int)&a1 & 3 )
  {
    v7 = *(_BYTE *)(a1 + 1);
    LOBYTE(a1) = *(_BYTE *)a1;
    v8 = *(_BYTE *)(v5 + 2);
    BYTE1(a1) = v7;
    v9 = *(_BYTE *)(v5 + 3);
    BYTE2(a1) = v8;
    BYTE3(a1) = v9;
  }
  else
  {
    a1 = *(int *)a1;
  }
  result = -4;
  if ( a5 && a5 != 1
    || ((v11 = *(float *)&a1, (a1 & 0x7F800000) != 2139095040) ? (a2 <= v11 ? (a3 >= v11 ? (result = 0) : (result = -2)) : (result = -1)) : (result = -3),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v12 = a4;
    *(_BYTE *)(v5 + 1) = BYTE1(a4);
    *(_BYTE *)v5 = v12;
    *(_BYTE *)(v5 + 3) = BYTE3(v12);
    *(_BYTE *)(v5 + 2) = v12 >> 16;
    result = 1;
  }
  else
  {
    *(_DWORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10018E70) --------------------------------------------------------
unsigned int __cdecl sub_10018E70(char *a1, char a2, char a3, char a4, int a5)
{
  char v5; // dl@1
  unsigned int result; // eax@1
  int v7; // eax@5

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1
    || (v5 >= a2 ? (v7 = v5 < a3, LOBYTE(v7) = v5 <= a3, result = (v7 - 1) & 0xFFFFFFFE) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (10018EC0) --------------------------------------------------------
unsigned int __cdecl sub_10018EC0(_BYTE *a1, __int16 a2, __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  int v8; // eax@9
  char v9; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((signed __int16)a1 >= a2 ? (v8 = (signed __int16)a1 < a3,
                                    LOBYTE(v8) = (signed __int16)a1 <= a3,
                                    result = (v8 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v9 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v9;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10018F60) --------------------------------------------------------
unsigned int __cdecl sub_10018F60(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  _BYTE *v8; // esi@3
  int v9; // eax@9
  signed int v10; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((signed int)v8 >= a2 ? (v9 = (signed int)v8 < a3,
                                LOBYTE(v9) = (signed int)v8 <= a3,
                                result = (v9 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v10 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v10;
    v5[3] = BYTE3(v10);
    v5[2] = v10 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (10019020) --------------------------------------------------------
unsigned int __cdecl sub_10019020(void *a1, size_t a2, int a3)
{
  unsigned int result; // eax@1
  int v4; // eax@3
  int v5; // ecx@3
  unsigned int v6; // ecx@3

  result = -4;
  if ( a3 && a3 != 1
    || (v4 = sub_1000A740(a1, a2), v5 = v4 < 0, LOBYTE(v5) = v4 >= 0, v6 = (v5 - 1) & 0xFFFFFFFC, result = v6, a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_7;
  }
  if ( v6 )
  {
LABEL_7:
    memset(a1, 0, a2);
    result = 1;
  }
  return result;
}

//----- (10019080) --------------------------------------------------------
int __cdecl sub_10019080(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
  unsigned __int8 v5; // dl@1
  int result; // eax@1

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1 || (v5 >= a2 ? (result = a3 < v5 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (100190D0) --------------------------------------------------------
int __cdecl sub_100190D0(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // esi@1
  int result; // eax@1
  char v8; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned __int16)a1 >= a2 ? (result = a3 < (unsigned __int16)a1 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v8 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v8;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10019170) --------------------------------------------------------
int __cdecl sub_10019170(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  int result; // eax@1
  _BYTE *v8; // esi@3
  unsigned int v9; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned int)v8 >= a2 ? (result = a3 < (unsigned int)v8 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v9 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v9;
    v5[3] = BYTE3(v9);
    v5[2] = v9 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (10019220) --------------------------------------------------------
char __cdecl sub_10019220(int a1, int a2, void *a3)
{
  char v3; // bl@1
  int v4; // eax@1
  unsigned __int16 v5; // bp@1
  int v6; // esi@4
  int v7; // eax@6
  char v8; // al@7
  unsigned __int8 v9; // dl@10
  __int16 v10; // cx@10
  char v11; // dl@12
  char v12; // ST2C_1@13
  char v13; // bl@14
  float v14; // ST30_4@16
  double v15; // st7@16
  char v16; // ST2C_1@16
  char v18; // [sp+18h] [bp-5Ch]@10
  char v19; // [sp+18h] [bp-5Ch]@14
  unsigned __int8 v20; // [sp+1Bh] [bp-59h]@1
  unsigned __int16 v21; // [sp+1Ch] [bp-58h]@14
  unsigned int v22; // [sp+20h] [bp-54h]@12
  int v23; // [sp+24h] [bp-50h]@1
  int v24; // [sp+28h] [bp-4Ch]@1
  unsigned __int64 v25; // [sp+2Ch] [bp-48h]@13
  char v26[8]; // [sp+34h] [bp-40h]@14
  char v27[8]; // [sp+3Ch] [bp-38h]@15
  char v28[44]; // [sp+44h] [bp-30h]@7

  v3 = 0;
  v24 = a1;
  v4 = a2;
  *(_BYTE *)a3 = 0;
  v5 = *(_WORD *)(a2 + 16);
  v23 = a2;
  v20 = 0;
  while ( v20 < *(_BYTE *)(v4 + 18) )
  {
    v6 = v24 + 10 * v5 + 22534;
    if ( *(_BYTE *)v6 == 1 )
    {
      v14 = (double)*(_WORD *)(v24 + 10 * v5 + 22542) * 0.125;
      v15 = sub_10035AB0(v14, 1.0);
      v16 = *(_WORD *)(v6 + 8) % 8;
      v3 = sub_10022760(*(_BYTE *)(v6 + 4), *(_WORD *)(v6 + 6), (signed int)v15, 1, a3);
      v11 = ((unsigned __int8)(1 << v16) & *(_BYTE *)a3) != 0;
LABEL_17:
      *(_BYTE *)a3 = v11;
    }
    else if ( *(_BYTE *)v6 == 2 )
    {
      v7 = *(_BYTE *)(v24 + 10 * v5 + 22538);
      switch ( v7 )
      {
        case 0:
        case 1:
          v3 = sub_10022760(6, (unsigned __int16)word_1006B690[v7], 0, 44, v28);
          v8 = v28[*(_BYTE *)(v6 + 5)];
          *(_BYTE *)a3 = v8 == 1;
          if ( !v8 || v8 == 3 )
            v3 = 0;
          break;
        case 2:
        case 3:
        case 4:
          v9 = *(_BYTE *)(v24 + 10 * v5 + 22539);
          v10 = 0;
          v18 = *(_BYTE *)(v24 + 10 * v5 + 22539);
          if ( v9 >= 0x18u )
          {
            v10 = 4;
            v18 = v9 - 24;
          }
          v3 = sub_10022760(0, (unsigned __int16)word_1006B690[v7], v10, 4, &v22);
          v11 = (v22 >> v18) & 1;
          goto LABEL_17;
        case 5:
        case 6:
        case 7:
        case 8:
          v12 = *(_BYTE *)(v24 + 10 * v5 + 22539) - 79;
          v3 = sub_10022760(0, (unsigned __int16)word_1006B690[v7], 0, 8, &v25);
          *(_BYTE *)a3 = (v25 >> v12) & 1;
          break;
        case 9:
        case 10:
        case 11:
        case 12:
          v13 = *(_BYTE *)(v24 + 10 * v5 + 22539);
          v21 = sub_10035A70((unsigned int)*(_BYTE *)(v24 + 10 * v5 + 22539) >> 3, 1);
          v19 = v13 - 8 * v21;
          v3 = sub_10022760(6, (unsigned __int16)word_1006B690[*(_BYTE *)(v6 + 4)], 0, 16, v26);
          if ( !v3 )
            break;
          v3 = ((unsigned __int8)v26[v21] >> v19) & 1;
          v11 = ((unsigned __int8)v27[v21] >> v19) & 1;
          goto LABEL_17;
        default:
          break;
      }
    }
    ++v20;
    ++v5;
    if ( v3 )
      break;
    v4 = v23;
  }
  return v3;
}
// 1006B690: using guessed type __int16 word_1006B690[];
// 10019220: using guessed type char var_30[44];
// 10019220: using guessed type char var_40[8];
// 10019220: using guessed type char var_38[8];

//----- (100194C0) --------------------------------------------------------
char __cdecl sub_100194C0(unsigned __int16 a1, void *a2)
{
  int v2; // esi@1
  int v3; // eax@1
  char result; // al@4

  *(_BYTE *)a2 = 0;
  v2 = sub_10028200(a1);
  v3 = sub_10022780();
  if ( v2 && v3 && !*(_WORD *)(v2 + 12) )
    result = sub_10019220(v3, v2, a2);
  else
    result = 0;
  return result;
}

//----- (10019510) --------------------------------------------------------
void sub_10019510()
{
  dword_10254420 = -15;
}
// 10254420: using guessed type int dword_10254420;

//----- (10019520) --------------------------------------------------------
char __cdecl sub_10019520(const void *a1)
{
  __int16 v2; // [sp+8h] [bp-530h]@1
  char v3; // [sp+Ch] [bp-52Ch]@1

  memset(&v2, 0, 0x528u);
  v2 = -32746;
  qmemcpy(&v3, a1, 0x11Cu);
  return sub_10025F30((int)&v2);
}

//----- (10019590) --------------------------------------------------------
char __cdecl sub_10019590(unsigned __int16 a1, unsigned int a2)
{
  char result; // al@3
  int v3; // [sp+0h] [bp-534h]@1
  __int16 v4; // [sp+8h] [bp-52Ch]@1
  int v5; // [sp+Ch] [bp-528h]@3
  unsigned int v6; // [sp+10h] [bp-524h]@3

  HIWORD(v3) = 0;
  memset(&v4, 0, 0x528u);
  if ( a1 >= 0x18u || a2 >= 0x6C )
  {
    result = sub_10011520("..\\lib\\adl\\iop_aud_msg_intf.c", 1198, 0, 0);
  }
  else
  {
    LOWORD(v3) = a1;
    v4 = -32695;
    v5 = v3;
    v6 = a2;
    result = sub_10025F30((int)&v4);
  }
  return result;
}

//----- (10019640) --------------------------------------------------------
char __cdecl sub_10019640(unsigned __int8 a1, unsigned __int16 a2)
{
  char result; // al@3
  char v3; // [sp+4h] [bp-120h]@1
  unsigned __int16 v4; // [sp+1Ch] [bp-108h]@3
  char v5; // [sp+23h] [bp-101h]@3

  memset(&v3, 0, 0x11Cu);
  if ( a1 >= 0x5Cu )
  {
    result = sub_10011520("..\\lib\\adl\\iop_aud_msg_intf.c", 1400, 0, 0);
    if ( a2 < 0x18u )
      return result;
  }
  else if ( a2 < 0x18u )
  {
    sub_1002BE80(a1, (int)&v3);
    v5 = 3;
    v4 = a2;
    sub_10019520(&v3);
    return SIM_proc_rqst(48);
  }
  return sub_10011520("..\\lib\\adl\\iop_aud_msg_intf.c", 1401, 0, 0);
}
// 10035EE2: using guessed type int __cdecl SIM_proc_rqst(_DWORD);

//----- (10019700) --------------------------------------------------------
signed int sub_10019700()
{
  return sub_100335F0((int)&off_1006BF68);
}
// 1006BF68: using guessed type char *off_1006BF68;

//----- (10019710) --------------------------------------------------------
char __cdecl sub_10019710(void *a1)
{
  char result; // al@3

  if ( !(unsigned __int8)sub_10019700() || sub_10032F80(2, 1000) )
  {
    result = 0;
  }
  else
  {
    qmemcpy(a1, (const void *)dword_10254420, 0x184u);
    sub_10032F60(2);
    result = 1;
  }
  return result;
}
// 10254420: using guessed type int dword_10254420;

//----- (10019760) --------------------------------------------------------
char __cdecl sub_10019760(unsigned __int8 a1, unsigned __int16 a2)
{
  void *v2; // ecx@3
  char v3; // bl@3
  char result; // al@3
  char v5; // [sp+4h] [bp-120h]@1
  unsigned __int16 v6; // [sp+1Ch] [bp-108h]@3
  char v7; // [sp+23h] [bp-101h]@3

  memset(&v5, 0, 0x11Cu);
  if ( a1 >= 0x5Cu )
  {
    result = sub_10011520("..\\lib\\adl\\iop_aud_msg_intf.c", 1051, 0, 0);
    if ( a2 < 0x18u )
      return result;
  }
  else if ( a2 < 0x18u )
  {
    sub_1002BE80(a1, (int)&v5);
    v7 = 0;
    v6 = a2;
    sub_10019520(&v5);
    v3 = sub_1000B910(v2);
    sub_1002BFB0(a1, SIM_intf + 24);
    *(_BYTE *)(SIM_intf + 320) = v3;
    return SIM_proc_rqst(49);
  }
  return sub_10011520("..\\lib\\adl\\iop_aud_msg_intf.c", 1052, 0, 0);
}
// 1002BFB0: using guessed type _DWORD __cdecl sub_1002BFB0(_DWORD, _DWORD);
// 10035EE2: using guessed type int __cdecl SIM_proc_rqst(_DWORD);

//----- (10019860) --------------------------------------------------------
char __cdecl sub_10019860(unsigned __int8 a1)
{
  char v1; // cl@1
  char v3; // [sp+0h] [bp-8h]@1
  char v4; // [sp+1h] [bp-7h]@1
  char v5; // [sp+4h] [bp-4h]@1
  char v6; // [sp+5h] [bp-3h]@1
  __int16 v7; // [sp+6h] [bp-2h]@1

  v3 = 33;
  v4 = 35;
  v1 = *(&v3 + a1);
  v5 = 58;
  v6 = v1;
  v7 = 0;
  sub_10011D60(1, 551, &v5, 1, 4, 1);
  sub_10011EA0(1, 0x227u, 768);
  sub_10011D60(1, 556, &v5, 1, 4, 1);
  return sub_10011EA0(1, 0x22Cu, 768);
}

//----- (100198E0) --------------------------------------------------------
char __cdecl sub_100198E0(int a1)
{
  char result; // al@1

  result = 0;
  if ( !a1 || *(_WORD *)a1 == -1 || !*(_BYTE *)(a1 + 2) || *(_BYTE *)(a1 + 127) & 0x40 || *(_WORD *)(a1 + 156) == -1 )
    result = 1;
  return result;
}

//----- (10019910) --------------------------------------------------------
char sub_10019910()
{
  unsigned __int16 v0; // dx@1
  int v1; // ecx@2
  unsigned __int16 v2; // ax@9
  int v4[7]; // [sp+8h] [bp-1Ch]@1

  sub_10032B80(6465, (int)v4, 28);
  v0 = 0;
LABEL_2:
  v1 = v4[v0];
  if ( v1 == 1 || v1 == 2 || v1 == 4 || v1 == 64 || v1 == 128 || v1 == 16 || v1 == 32 )
  {
    v2 = 0;
    while ( v2 == v0 || v4[v2] != v1 )
    {
      if ( ++v2 >= 7u )
      {
        if ( ++v0 < 7u )
          goto LABEL_2;
        return 1;
      }
    }
  }
  return 0;
}
// 10019910: using guessed type int var_1C[7];

//----- (10019990) --------------------------------------------------------
unsigned __int8 __cdecl sub_10019990(unsigned __int16 a1)
{
  unsigned __int8 result; // al@1
  int v2; // ecx@2

  result = 0;
  do
  {
    v2 = 6 * result;
    if ( a1 >= (unsigned __int16)word_1006DAA0[v2] && a1 <= (unsigned __int16)word_1006DAA2[v2] )
      break;
    ++result;
  }
  while ( result < 3u );
  return result;
}
// 1006DAA0: using guessed type __int16 word_1006DAA0[];
// 1006DAA2: using guessed type __int16 word_1006DAA2[];

//----- (100199C0) --------------------------------------------------------
__int16 __cdecl sub_100199C0(unsigned __int16 a1, unsigned __int8 a2)
{
  int v2; // edi@3
  __int16 result; // ax@4

  if ( a2 >= 3u )
  {
    result = -1;
  }
  else if ( a1 >= (unsigned __int16)word_1006DAA4[6 * a2]
         || (memset(&unk_10218298, 0, 0x3E84u),
             v2 = a1 % 100,
             sub_10032AE0(dword_1006DAC4[a2] + a1 / 100, (int)&unk_10218298, 16004)) )
  {
    result = -1;
  }
  else
  {
    result = word_10218334[80 * (unsigned __int16)v2];
  }
  return result;
}
// 1006DAA4: using guessed type __int16 word_1006DAA4[];
// 1006DAC4: using guessed type int dword_1006DAC4[];
// 10218334: using guessed type __int16 word_10218334[];

//----- (10019A50) --------------------------------------------------------
bool sub_10019A50()
{
  unsigned int v0; // esi@1
  bool result; // al@4
  char v2; // [sp+8h] [bp-120h]@1
  __int16 v3; // [sp+24h] [bp-104h]@3

  memset(&v2, 0, 0x11Cu);
  v0 = 0;
  do
  {
    result = !sub_10032AE0((int)(&byte_102162F8[37000 - (_DWORD)byte_102162F8] + v0), (int)&v2, 284) && v3 == -1;
    byte_102162F8[v0++] = result;
  }
  while ( v0 < 0x5C );
  byte_1021DA20 = 1;
  return result;
}
// 1021DA20: using guessed type char byte_1021DA20;

//----- (10019AF0) --------------------------------------------------------
char __cdecl sub_10019AF0(unsigned int a1)
{
  char result; // al@4

  if ( !byte_1021DA20 )
  {
    sub_10011520(
      "..\\lib\\adl\\mon_cnfg_intf.c",
      1236,
      0,
      "Audio Message Is Continuous Array has NOT been initialized.  Initializing now.");
    sub_10019A50();
  }
  if ( a1 >= 0x5C )
    result = 0;
  else
    result = byte_102162F8[a1];
  return result;
}
// 1021DA20: using guessed type char byte_1021DA20;

//----- (10019B30) --------------------------------------------------------
int __cdecl sub_10019B30(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@6
  int v7; // ebx@6
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  _DWORD *v21; // esi@23
  unsigned int v22; // ecx@23
  _DWORD *v23; // edx@23
  int v24; // edi@27
  int v25; // ecx@28
  _BYTE *v26; // edx@28
  _BYTE *v27; // esi@28
  int v28; // ecx@30
  _BYTE *v29; // edx@30
  _BYTE *v30; // esi@30
  _BYTE *v31; // edx@32
  _BYTE *v32; // esi@32
  int v33; // edx@33
  signed int v34; // ecx@34
  int v35; // [sp+4h] [bp-4h]@6

  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && a5 > 0 )
  {
    result = a5 - 1;
    v7 = a3 + a4 * (a5 - 1);
    v35 = a5 - 1;
    if ( a5 - 1 > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v35;
        if ( v20 )
        {
          v7 -= a4;
          result = v35 - 1;
          v35 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a1;
    v22 = a2;
    v23 = (_DWORD *)v7;
    if ( a2 < 4 )
    {
LABEL_26:
      if ( !v22 )
        goto LABEL_36;
    }
    else
    {
      while ( *v21 == *v23 )
      {
        v22 -= 4;
        ++v23;
        ++v21;
        if ( v22 < 4 )
          goto LABEL_26;
      }
    }
    v24 = *(_BYTE *)v21 - *(_BYTE *)v23;
    if ( *(_BYTE *)v21 != *(_BYTE *)v23
      || (v25 = v22 - 1, v26 = (char *)v23 + 1, v27 = (char *)v21 + 1, v25)
      && ((v24 = *v27 - *v26, *v27 != *v26)
       || (v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, v28)
       && ((v24 = *v30 - *v29, *v30 != *v29)
        || (v31 = v29 + 1, v32 = v30 + 1, v28 != 1) && (v33 = *v31, v24 = *v32 - v33, *v32 != v33))) )
    {
      v34 = 1;
      if ( v24 <= 0 )
        v34 = -1;
LABEL_37:
      if ( !v34 )
        return result;
      return a6;
    }
LABEL_36:
    v34 = 0;
    goto LABEL_37;
  }
  return a6;
}

//----- (10019CC0) --------------------------------------------------------
void *__usercall sub_10019CC0@<eax>(void *a1@<ebx>, const void *a2@<edi>, int a3@<esi>, int a4)
{
  void *result; // eax@1
  int v5; // [sp+0h] [bp-Ch]@0
  int v6; // [sp+4h] [bp-8h]@0

  result = (void *)sub_10032AE0(a4, v5, v6);
  if ( result )
  {
    sub_10032BB0(a4, (int)a2, a3);
    result = memcpy(a1, a2, (unsigned __int16)a3);
  }
  return result;
}

//----- (10019CF0) --------------------------------------------------------
void *__cdecl sub_10019CF0(void *a1)
{
  return sub_10019CC0(a1, &unk_100817AC, 60, 2116);
}

//----- (10019D20) --------------------------------------------------------
BOOL sub_10019D20()
{
  return sub_1001A100(9) || sub_1001A100(10);
}

//----- (10019D50) --------------------------------------------------------
int __usercall sub_10019D50@<eax>(char a1@<al>, int a2@<ecx>)
{
  int v2; // esi@3
  int result; // eax@3

  if ( a1 && a1 != 2 )
  {
    v2 = a2 - sub_10034690(a1);
    result = v2 + sub_10034690(0);
  }
  else
  {
    result = a2;
  }
  return result;
}

//----- (10019D80) --------------------------------------------------------
char __thiscall sub_10019D80(void *this)
{
  char v1; // al@1
  char result; // al@2
  char v3; // [sp+4h] [bp-8h]@1
  int v4; // [sp+8h] [bp-4h]@2

  v1 = sub_1001A5F0(this);
  v3 = sub_1001A570(v1, 1);
  if ( (unsigned __int8)sub_10019D20() )
  {
    result = sub_10022910(28, v3, &v4);
    if ( result != 1 || !(v4 & 0x800) )
      result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10019DE0) --------------------------------------------------------
char __thiscall sub_10019DE0(void *this)
{
  char v1; // al@1
  char v3; // [sp+0h] [bp-Ch]@1
  int v4; // [sp+4h] [bp-8h]@2
  int v5; // [sp+8h] [bp-4h]@5

  v1 = sub_1001A5F0(this);
  v3 = sub_1001A570(v1, 1);
  if ( (unsigned __int8)sub_10019D20() )
  {
    if ( sub_10022910(28, v3, &v4) != 1 || v4 & 0x2000 )
      return 0;
  }
  else if ( sub_1002BFC0(&v5) != 1 || !(v5 & 0x10000) )
  {
    return 0;
  }
  return 1;
}

//----- (10019E50) --------------------------------------------------------
char __cdecl sub_10019E50(char a1, char a2, int *a3)
{
  char v3; // bl@1
  void *v4; // ecx@1
  void *v5; // ecx@2
  char result; // al@4
  int v7; // esi@9
  void *v8; // ecx@12
  int v9; // esi@14
  char v10; // [sp+8h] [bp-14h]@1
  char v11; // [sp+9h] [bp-13h]@1
  char v12; // [sp+Ah] [bp-12h]@1
  char v13; // [sp+Bh] [bp-11h]@1
  int v14; // [sp+Ch] [bp-10h]@1
  int v15; // [sp+10h] [bp-Ch]@1
  int v16; // [sp+14h] [bp-8h]@1
  int v17; // [sp+18h] [bp-4h]@1

  v3 = sub_10022910(16, a2, &v14);
  v12 = sub_10022910(17, a2, &v16);
  v10 = sub_10034560();
  v11 = sub_10022910(51, a2, &v15);
  v13 = sub_10022910(52, a2, &v17);
  switch ( a1 )
  {
    case 0:
    case 2:
    case 3:
      if ( sub_10019DE0(v4) )
      {
        if ( !v3 )
          return 0;
        v7 = v14;
        if ( v10 == 1 )
          v7 -= sub_10034690(0);
        *a3 = sub_10019D50(a1, v7);
        result = 1;
      }
      else if ( v3 )
      {
        *a3 = sub_10019D50(a1, v14);
        result = 1;
      }
      else
      {
        if ( !v11 || !sub_10019D80(v5) )
          return 0;
        *a3 = sub_10019D50(a1, v15);
        result = 1;
      }
      return result;
    case 1:
      if ( sub_10019DE0(v4) )
      {
        if ( !v3 )
          return 0;
        v9 = v14;
        if ( v10 == 1 )
          goto LABEL_15;
        *a3 = sub_10034690(0) + v9;
        result = 1;
      }
      else
      {
        if ( v12 )
        {
          v9 = v16;
LABEL_15:
          *a3 = v9;
          return 1;
        }
        if ( !v13 || !sub_10019D80(v8) )
          return 0;
        *a3 = v17;
        result = 1;
      }
      return result;
    default:
      sub_10011520("..\\lib\\acl\\iop\\iop_ahrs_data_intf.c", 1859, 1, 0);
      return 0;
  }
}

//----- (1001A000) --------------------------------------------------------
char __cdecl sub_1001A000(char a1, int *a2, char a3)
{
  char result; // al@3
  char v4; // bl@4
  int v5; // [sp+4h] [bp-4h]@1

  v5 = 0;
  if ( a3 != 2 && sub_1001A100(a3 + 9) )
  {
    result = sub_10019E50(a1, a3, a2);
  }
  else
  {
    v4 = sub_10022910(16, a3, &v5);
    if ( v4 )
      *a2 = sub_10019D50(a1, v5);
    result = v4;
  }
  return result;
}

//----- (1001A070) --------------------------------------------------------
char __thiscall sub_1001A070(void *this)
{
  char v1; // di@1
  void *v2; // esi@1
  char v3; // di@3
  void *v4; // esi@3
  char result; // al@4

  dword_1021DA28 = sub_1000BC20(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_1021DA30, 0, 0x1540u);
  memset(&unk_1021EF70, 0, 0x19B0u);
  v1 = 0;
  v2 = &unk_1021DA30;
  do
  {
    sub_1002BEC0(v1, (int)v2);
    v2 = (char *)v2 + 2720;
    ++v1;
  }
  while ( (signed int)v2 < (signed int)&unk_1021EF70 );
  v3 = 0;
  v4 = &unk_1021EF70;
  do
  {
    result = sub_1002BF40(v3, (int)v4);
    v4 = (char *)v4 + 2192;
    ++v3;
  }
  while ( (signed int)v4 < (signed int)dword_10220920 );
  return result;
}
// 1021DA28: using guessed type int dword_1021DA28;
// 10220920: using guessed type int dword_10220920[];

//----- (1001A100) --------------------------------------------------------
char __cdecl sub_1001A100(char a1)
{
  char v1; // bl@1
  unsigned __int8 v2; // al@3
  char v4; // [sp+4h] [bp-20h]@1
  char v5; // [sp+8h] [bp-1Ch]@3
  char v6[19]; // [sp+Dh] [bp-17h]@5

  v1 = 0;
  v4 = 0;
  do
  {
    if ( v1 )
      break;
    sub_1002BEA0(v4, (int)&v5);
    v2 = 0;
    do
    {
      if ( v1 )
        break;
      if ( v6[4 * v2] == a1 )
        v1 = 1;
      ++v2;
    }
    while ( v2 <= 1u );
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  return v1;
}
// 1001A100: using guessed type char var_17[19];

//----- (1001A170) --------------------------------------------------------
char __cdecl sub_1001A170(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // al@6
  char v6; // [sp+6h] [bp-2h]@1
  bool v7; // [sp+7h] [bp-1h]@1

  v2 = dword_1021DA28 != 1379255385;
  v6 = 0;
  v7 = dword_1021DA28 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10033120(86, 10);
      memset((char *)&unk_1021DA30 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_1002BEC0(a1, (int)&unk_1021DA30 + 2720 * (unsigned __int8)a1);
      v2 = v7;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( byte_1021DA49[4 * (680 * (unsigned __int8)a1 + v5)] != a2 )
    {
      if ( ++v5 >= 0xBu )
        goto LABEL_11;
    }
    v6 = 1;
LABEL_11:
    if ( v2 )
      sub_100330F0(v4, 86);
    result = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1021DA28: using guessed type int dword_1021DA28;

//----- (1001A230) --------------------------------------------------------
char __cdecl sub_1001A230(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_1021DA28 != 1379255385;
  v7 = 0;
  v8 = dword_1021DA28 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10033120(86, 10);
      memset((char *)&unk_1021DA30 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_1002BEC0(a1, (int)&unk_1021DA30 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 4 * (680 * (unsigned __int8)a1 + v5);
      if ( byte_1021DD08[v6] == a2 || byte_1021DD09[v6] == a2 )
        break;
      if ( ++v5 >= 8u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_100330F0(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1021DA28: using guessed type int dword_1021DA28;

//----- (1001A2F0) --------------------------------------------------------
char __cdecl sub_1001A2F0(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_1021DA28 != 1379255385;
  v7 = 0;
  v8 = dword_1021DA28 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10033120(86, 10);
      memset((char *)&unk_1021DA30 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_1002BEC0(a1, (int)&unk_1021DA30 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 8 * (340 * (unsigned __int8)a1 + v5);
      if ( byte_1021DD28[v6] == a2 || byte_1021DD29[v6] == a2 )
        break;
      if ( ++v5 >= 5u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_100330F0(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1021DA28: using guessed type int dword_1021DA28;

//----- (1001A3B0) --------------------------------------------------------
char __cdecl sub_1001A3B0(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_1001A170(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (1001A3E0) --------------------------------------------------------
char __cdecl sub_1001A3E0(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_1001A230(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (1001A410) --------------------------------------------------------
char __cdecl sub_1001A410(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_1001A2F0(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (1001A440) --------------------------------------------------------
int __cdecl sub_1001A440(char a1)
{
  return 9190 - (a1 != 1);
}

//----- (1001A450) --------------------------------------------------------
int __usercall sub_1001A450@<eax>(char *a1@<eax>, char a2@<cl>)
{
  return sub_1002D010(a2, a1);
}

//----- (1001A460) --------------------------------------------------------
char __usercall sub_1001A460@<al>(char a1@<bl>, char a2)
{
  int v2; // eax@1
  char result; // al@2
  char *v4; // ecx@3
  unsigned __int8 v5; // [sp+4h] [bp-8Ch]@1
  char v6; // [sp+5h] [bp-8Bh]@2
  char v7[68]; // [sp+48h] [bp-48h]@1

  memset(&v5, 0, 0x43u);
  memset(v7, 0, 0x43u);
  sub_1001A450((char *)&v5, a2);
  v2 = sub_1001A440(a1);
  if ( sub_10032AE0(v2, (int)v7, 67) )
  {
    result = a1 == 1;
  }
  else
  {
    result = v7[v5];
    if ( v6 != 67 )
    {
      v4 = &v6;
      do
        ++v4;
      while ( *v4 != 67 );
    }
  }
  return result;
}
// 1001A460: using guessed type char var_48[68];

//----- (1001A520) --------------------------------------------------------
char __usercall sub_1001A520@<al>(char a1@<dl>, char a2@<cl>, char a3)
{
  int v4; // [sp+0h] [bp-Ch]@1
  __int16 v5; // [sp+4h] [bp-8h]@1
  char v6; // [sp+6h] [bp-6h]@1

  v4 = 0;
  LOBYTE(v5) = a3;
  LOWORD(v4) = -32706;
  HIBYTE(v5) = a2;
  v6 = a1;
  return sub_10025F20((int)&v4);
}

//----- (1001A570) --------------------------------------------------------
char __cdecl sub_1001A570(char a1, char a2)
{
  return sub_1001A460(a1, a2);
}

//----- (1001A590) --------------------------------------------------------
char __cdecl sub_1001A590(char a1, char a2)
{
  void *v2; // ecx@1
  char v3; // al@1

  sub_1001A520(0, a2, a1);
  v3 = sub_1001A5F0(v2);
  return sub_1001A570(v3, a1);
}

//----- (1001A5C0) --------------------------------------------------------
char __cdecl sub_1001A5C0(char a1)
{
  char result; // al@1

  result = sub_1002D060();
  if ( result == 2 )
    result = byte_10082874[8 * sub_10019B30(&a1, 4u, (int)&unk_10082870, 8, 7, 7)];
  return result;
}

//----- (1001A5F0) --------------------------------------------------------
char __thiscall sub_1001A5F0(void *this)
{
  char v1; // al@1

  v1 = sub_100122C0(this);
  return sub_1001A5C0(v1);
}

//----- (1001A600) --------------------------------------------------------
char __cdecl sub_1001A600(const void *a1)
{
  __int16 v2; // [sp+8h] [bp-530h]@1
  char v3; // [sp+Ch] [bp-52Ch]@1

  memset(&v2, 0, 0x528u);
  v2 = -32723;
  qmemcpy(&v3, a1, 0x1C8u);
  return sub_10025F40((int)&v2);
}

//----- (1001A670) --------------------------------------------------------
int __cdecl sub_1001A670(int *a1)
{
  int result; // eax@1

  result = sub_1002D100((int)(a1 + 1), 0);
  if ( result )
  {
    *a1 = sub_10032ED0();
    result = sub_10024720();
  }
  return result;
}

//----- (1001A6A0) --------------------------------------------------------
char __usercall sub_1001A6A0@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@2
  char *v3; // eax@2
  char result; // al@2
  int v5; // eax@4
  char *v6; // eax@4

  if ( a2 == 13 )
  {
    v2 = sub_10032F80(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 88));
    v3 = sub_1000C870("%i %i\r\n", 13, v2);
    sub_1000AE30(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)&unk_10082CC8, (int)v3);
    result = 1;
  }
  else if ( a2 == 14 )
  {
    v5 = sub_10032F60(*(_DWORD *)(a1 + 4));
    v6 = sub_1000C870("%i %i\r\n", 14, v5);
    sub_1000AE30(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)&unk_10082CC4, (int)v6);
    result = 1;
  }
  else
  {
    sub_10011520(".\\test\\tst_tsk_common.c", 405, 1, 0);
    result = 0;
  }
  return result;
}

//----- (1001A740) --------------------------------------------------------
int __cdecl sub_1001A740(const char *a1)
{
  int result; // eax@1

  result = sub_10022A40();
  if ( a1 )
    result = sub_1002D130(dword_10220920[result] + 4, (int)a1, strlen(a1));
  return result;
}
// 10220920: using guessed type int dword_10220920[];

//----- (1001A780) --------------------------------------------------------
char __cdecl sub_1001A780(void *a1)
{
  int (**v1)(); // eax@1
  char **v2; // eax@1

  memset(a1, 0, 0xE0u);
  sub_1002D080((char *)a1 + 4);
  v1 = sub_10009B80();
  sub_10024800((int)v1, 0, 0);
  dword_10220920[sub_10022A40()] = (int)a1;
  v2 = sub_1002DFC0((int)sub_1001A740);
  return sub_1000A820(v2);
}
// 10220920: using guessed type int dword_10220920[];

//----- (1001A7D0) --------------------------------------------------------
signed int __cdecl sub_1001A7D0(unsigned int a1, int a2)
{
  signed int v2; // edi@1
  int v3; // eax@1
  unsigned int v4; // ebx@1
  int v5; // ebp@1
  signed int result; // eax@3
  char *v7; // eax@10
  __int16 v8; // ax@11
  char *v9; // eax@13
  char *v10; // eax@14
  char *v11; // eax@16
  int v12; // ebx@17
  char *v13; // eax@18
  char *v14; // eax@19
  char **v15; // eax@23
  char **v16; // eax@23
  char **v17; // eax@23
  char **v18; // eax@24
  char **v19; // eax@24
  char **v20; // eax@24
  int v21; // [sp-4h] [bp-30h]@9
  int v22; // [sp-4h] [bp-30h]@17
  char v23; // [sp+10h] [bp-1Ch]@6
  char v24; // [sp+14h] [bp-18h]@14

  v2 = 4;
  v3 = sub_10032ED0();
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3;
  if ( a1 < 8 )
  {
LABEL_28:
    result = v2;
  }
  else
  {
    switch ( a1 )
    {
      case 0xBu:
        sub_10033090(*(_DWORD *)(a2 + 4));
        result = 0;
        break;
      case 0xCu:
        if ( sub_10032ED0() - v3 < v4 )
        {
          do
          {
            if ( *(_BYTE *)(a2 + 88) )
              sub_100330B0(&v23);
          }
          while ( sub_10032ED0() - v5 < v4 );
        }
        result = 0;
        break;
      case 8u:
        v21 = *(_DWORD *)(a2 + 4);
        if ( v4 < 0x40 )
        {
          v8 = sub_10032E80(v21);
          if ( v8 & 0xF32 || v8 & 0xC4 )
          {
            sub_10032EF0((int)&v24, 1, *(_DWORD *)(a2 + 4), 20);
            v10 = sub_1000C870("The %s task is loaded.", &v24);
            sub_1000AE30(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"512", (int)v10);
            result = 0;
          }
          else
          {
            v9 = sub_1000C870("Task #%d is not loaded.", *(_DWORD *)(a2 + 4));
            sub_1000AE30(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"520", (int)v9);
            result = 12;
          }
        }
        else
        {
          v7 = sub_1000C870("Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.", v21);
          sub_1000AE30(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"489", (int)v7);
          result = 9;
        }
        break;
      case 9u:
        if ( v4 >= 0x40 )
        {
          v11 = sub_1000C870(
                  "Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.",
                  *(_DWORD *)(a2 + 4));
          sub_1000AE30(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"543", (int)v11);
        }
        v12 = sub_10032E10(*(_DWORD *)(a2 + 4));
        v22 = *(_DWORD *)(a2 + 88);
        if ( v12 == *(_DWORD *)(a2 + 88) )
        {
          v13 = sub_1000C870("The %d task's level is equal to %d.", *(_DWORD *)(a2 + 4), v22);
          sub_1000AE30(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"557", (int)v13);
          v2 = 0;
        }
        else
        {
          v14 = sub_1000C870("The %d task's level is equal to %d, not %d.", *(_DWORD *)(a2 + 4), v12, v22);
          sub_1000AE30(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"562", (int)v14);
          v2 = 12;
        }
        if ( v12 )
          goto LABEL_28;
        sub_1000AE30(
          3,
          (int)"**MSG**",
          (int)".\\test\\tst_tsk_common.c",
          (int)"572",
          (int)"The task's criticality level is zero, make sure the task is running.");
        result = v2;
        break;
      case 0xAu:
        sub_10032F30(v4, *(_DWORD *)(a2 + 88), 0, 0);
        result = 4;
        break;
      case 0x12u:
        v15 = sub_1002DFC0((int)sub_1001A740);
        sub_1000AF00((int)v15);
        v16 = sub_1002F390((int)sub_1001A740);
        sub_1000AF00((int)v16);
        v17 = sub_1002F390((int)sub_1001A740);
        sub_1000A820(v17);
        result = 4;
        break;
      case 0x13u:
        v18 = sub_1002DFC0((int)sub_1001A740);
        sub_1000AF00((int)v18);
        v19 = sub_1002F390((int)sub_1001A740);
        sub_1000AF00((int)v19);
        v20 = sub_1002DFC0((int)sub_1001A740);
        sub_1000A820(v20);
        result = 4;
        break;
      default:
        if ( a1 - 13 > 4 )
        {
          v2 = 11;
          goto LABEL_28;
        }
        result = sub_1001A6A0(a2, a1) != 0 ? 0 : 12;
        break;
    }
  }
  return result;
}

//----- (1001AB70) --------------------------------------------------------
char **sub_1001AB70()
{
  return off_10082CB0;
}
// 10082CB0: using guessed type char *off_10082CB0[3];

//----- (1001AB80) --------------------------------------------------------
#error "1001AB85: call analysis failed (funcsize=28)"

//----- (1001ABB0) --------------------------------------------------------
signed int __cdecl sub_1001ABB0(int a1, int a2)
{
  signed int result; // eax@1

  result = 4;
  if ( a1 == 2 )
  {
    byte_10220935 = 1;
    byte_10220934 = 0;
  }
  else
  {
    if ( a1 == 8 )
    {
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_10220934 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    else
    {
      if ( a1 != 9 )
        return result;
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_10220935 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    result = 9;
  }
  return result;
}
// 10220934: using guessed type char byte_10220934;
// 10220935: using guessed type char byte_10220935;

//----- (1001AC10) --------------------------------------------------------
bool __cdecl sub_1001AC10(signed int a1)
{
  if ( a1 > 1 )
  {
    sub_1000AE00(13, (int)"..\\lib\\utf\\utf_validate.c", (int)&unk_1009AF20, (int)"failing_subroutine( depth-1 )");
    sub_1001AC10(a1 - 1);
    exit(14);
  }
  return sub_100112A0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"583",
           (int)"Check FAIL macro",
           "UTF_verify_fail: forced fail",
           "UTF_verify_fail: fail forced",
           (int)"This test is expected to fail");
}

//----- (1001AC80) --------------------------------------------------------
int sub_1001AC80()
{
  const char *v0; // eax@1

  sub_1000AE30(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"All Fail Miscellaneous Test Group");
  v0 = sub_1000C760(0);
  sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"610", (int)v0);
  sub_1000AE30(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"Verify miscellaneous macros");
  if ( byte_10220934 )
  {
    sub_100112A0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"620",
      (int)"Check FAIL macro",
      "UTF_verify_fail: forced fail",
      "UTF_verify_fail: fail forced",
      (int)"This test is expected to fail");
    sub_1000AE00(13, (int)"..\\lib\\utf\\utf_validate.c", (int)"621", (int)"failing_subroutine( 1 )");
    sub_1001AC10(1);
    exit(14);
  }
  return sub_1000AE30(
           3,
           (int)"**MSG**",
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"616",
           (int)"Failing tests currently disabled. Use FAIL ON command to enable");
}
// 10220934: using guessed type char byte_10220934;

//----- (1001AFA0) --------------------------------------------------------
char sub_1001AFA0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_1000AE30(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"All Fail Test Group For Type 'bitmap'");
  v0 = sub_1000C760(0);
  sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"700", (int)v0);
  sub_1000AE30(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10220934 )
  {
    v2 = 0;
    do
    {
      if ( off_10083F94[v2] )
      {
        sub_1000C5D0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_10083F9C[v2 * 4], 0x100u, &v11);
        sub_1000C5D0((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_10083F94[v2], 0x100u, &v12);
        sub_10024CD0(&v12, &v11);
      }
      if ( byte_10083F90[v2 * 4] )
      {
        sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"725", 2, 2);
        v3 = off_10083F98[v2];
        v4 = *(char **)&off_10083F9C[v2 * 4];
        v5 = sub_1000C870(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10083F9C[v2 * 4],
               off_10083F98[v2]);
        v6 = sub_10010EF0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"730",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1000CBD0(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"731",
                   (int)"Return value from previous UTF_verify_eq_bitmap() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"735", 2, 2);
        v7 = off_10083F98[v2];
        v8 = *(char **)&off_10083F9C[v2 * 4];
        v9 = sub_1000C870(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10083F9C[v2 * 4],
               off_10083F98[v2]);
        v10 = sub_10010EF0(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"740",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1000CBD0(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"741",
                   (int)"Return value from previous UTF_verify_ne_bitmap() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 4;
    }
    while ( v2 < 36 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"704",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10083F94: using guessed type char *off_10083F94[3];
// 10083F98: using guessed type char *off_10083F98[2];
// 10220934: using guessed type char byte_10220934;

//----- (1001B1C0) --------------------------------------------------------
char sub_1001B1C0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000AE30(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_1000C760(0);
  sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"768", (int)v0);
  sub_1000AE30(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10220934 )
  {
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"776", 2, 2);
    v2 = sub_1000CBD0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"777",
           (int)"UTF_verify_eq_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1000CBD0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"778",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"780", 2, 2);
    v3 = sub_1000CBD0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"781",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1000CBD0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"782",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"784", 2, 2);
    v4 = sub_1000CBD0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"785",
           (int)"UTF_verify_ne_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1000CBD0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"786",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"788", 2, 2);
    v5 = sub_1000CBD0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"789",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1000CBD0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"790",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"772",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10220934: using guessed type char byte_10220934;

//----- (1001B3C0) --------------------------------------------------------
char sub_1001B3C0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"830", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_10084024[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"830", 2, 2);
        v3 = byte_10084021[v2 * 4];
        v4 = byte_10084020[v2 * 4];
        v5 = sub_1000C870(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + dword_10084024[v2])],
               (&off_10084028)[v2 * 4]);
        v6 = sub_1000CD10(
               0,
               *(&dword_10083F74 + dword_10084024[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"830",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1000C870(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_10084024[v2]],
               (&off_10084028)[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"830",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"830",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10084024: using guessed type int dword_10084024[];
// 10084028: using guessed type char *off_10084028;
// 10220934: using guessed type char byte_10220934;

//----- (1001B540) --------------------------------------------------------
char sub_1001B540()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"864", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_100842A8[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_100842A0[v2 / 8];
        v4 = dbl_10084298[v2 / 8];
        v5 = dbl_10084290[v2 / 8];
        v6 = sub_1000C870(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               *(_DWORD *)&off_100842AC[v2]);
        v7 = sub_1000D0C0(
               0,
               *(&dword_10083F74 + dword_100842A8[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"864",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_100842A8[v2 / 4]],
               *(_DWORD *)&off_100842AC[v2]);
        LOBYTE(v0) = sub_1000CBD0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"864",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"864",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10084290: using guessed type double dbl_10084290[];
// 10084298: using guessed type double dbl_10084298[];
// 100842A0: using guessed type double dbl_100842A0[];
// 100842A8: using guessed type int dword_100842A8[];
// 10220934: using guessed type char byte_10220934;

//----- (1001B6C0) --------------------------------------------------------
char sub_1001B6C0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"900", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_10084EBC[v2];
      if ( v0 != 6 )
      {
        v3 = flt_10084EB8[v2];
        v4 = flt_10084EB4[v2];
        v5 = flt_10084EB0[v2];
        v6 = sub_1000C870(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               (&off_10084EC0)[v2 * 4]);
        v7 = sub_1000D510(
               0,
               *(&dword_10083F74 + dword_10084EBC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"900",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_10084EBC[v2]],
               (&off_10084EC0)[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"900",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"900",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10084EB0: using guessed type float flt_10084EB0[];
// 10084EB4: using guessed type float flt_10084EB4[];
// 10084EB8: using guessed type float flt_10084EB8[];
// 10084EBC: using guessed type int dword_10084EBC[];
// 10084EC0: using guessed type char *off_10084EC0;
// 10220934: using guessed type char byte_10220934;

//----- (1001B830) --------------------------------------------------------
char sub_1001B830()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1000AE30(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1000C760(0);
  sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"922", (int)v0);
  sub_1000AE30(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10220934 )
  {
    sub_100111F0(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"930",
      (int)"Check ptr for equality",
      (int)sub_1001B830,
      (int)sub_1001B830,
      (int)"This test is expected to fail");
    sub_100111F0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"931",
      (int)"Check ptr for inequality",
      (int)sub_1001B830,
      0,
      (int)"This test is expected to fail");
    result = sub_100111F0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"932",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1001B830,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"926",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10220934: using guessed type char byte_10220934;

//----- (1001B930) --------------------------------------------------------
char sub_1001B930()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"959", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_10085664[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10085660[v2];
        v4 = dword_1008565C[v2];
        v5 = dword_10085658[v2];
        v6 = sub_1000C870(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               *(_DWORD *)&off_10085668[v2 * 4]);
        v7 = sub_1000D9D0(
               0,
               *(&dword_10083F74 + dword_10085664[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"959",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_10085664[v2]],
               *(_DWORD *)&off_10085668[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"959",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"959",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10085658: using guessed type int dword_10085658[];
// 1008565C: using guessed type int dword_1008565C[];
// 10085660: using guessed type int dword_10085660[];
// 10085664: using guessed type int dword_10085664[];
// 10220934: using guessed type char byte_10220934;

//----- (1001BA90) --------------------------------------------------------
char sub_1001BA90()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"985", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_10085DF8[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_10085DF4[v2 / 2];
        v4 = word_10085DF2[v2 / 2];
        v5 = word_10085DF0[v2 / 2];
        v6 = sub_1000C870(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               *(_DWORD *)&off_10085DFC[v2]);
        v7 = sub_1000DD90(
               0,
               *(&dword_10083F74 + dword_10085DF8[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"985",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_10085DF8[v2 / 4]],
               *(_DWORD *)&off_10085DFC[v2]);
        LOBYTE(v0) = sub_1000CBD0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"985",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"985",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10085DF0: using guessed type __int16 word_10085DF0[];
// 10085DF2: using guessed type __int16 word_10085DF2[];
// 10085DF4: using guessed type __int16 word_10085DF4[];
// 10085DF8: using guessed type int dword_10085DF8[];
// 10220934: using guessed type char byte_10220934;

//----- (1001BBF0) --------------------------------------------------------
char sub_1001BBF0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1011", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_1008640C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10086408[v2];
        v4 = dword_10086404[v2];
        v5 = dword_10086400[v2];
        v6 = sub_1000C870(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               (&off_10086410)[v2 * 4]);
        v7 = sub_1000E190(
               0,
               *(&dword_10083F74 + dword_1008640C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1011",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_1008640C[v2]],
               (&off_10086410)[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1011",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1011",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10086400: using guessed type int dword_10086400[];
// 10086404: using guessed type int dword_10086404[];
// 10086408: using guessed type int dword_10086408[];
// 1008640C: using guessed type int dword_1008640C[];
// 10086410: using guessed type char *off_10086410;
// 10220934: using guessed type char byte_10220934;

//----- (1001BD50) --------------------------------------------------------
char sub_1001BD50()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1037", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_10086BB0[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_10086BAC[v2];
        LODWORD(v3) = dword_10086BA8[v2];
        HIDWORD(v4) = dword_10086BA4[v2];
        LODWORD(v4) = dword_10086BA0[v2];
        HIDWORD(v5) = dword_10086B9C[v2];
        LODWORD(v5) = dword_10086B98[v2];
        v6 = sub_1000C870(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               *(_DWORD *)&off_10086BB4[v2 * 4]);
        v7 = sub_1000E550(
               0,
               *(&dword_10083F74 + dword_10086BB0[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1037",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_10086BB0[v2]],
               *(_DWORD *)&off_10086BB4[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1037",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1037",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10086B98: using guessed type int dword_10086B98[];
// 10086B9C: using guessed type int dword_10086B9C[];
// 10086BA0: using guessed type int dword_10086BA0[];
// 10086BA4: using guessed type int dword_10086BA4[];
// 10086BA8: using guessed type int dword_10086BA8[];
// 10086BAC: using guessed type int dword_10086BAC[];
// 10086BB0: using guessed type int dword_10086BB0[];
// 10220934: using guessed type char byte_10220934;

//----- (1001BEC0) --------------------------------------------------------
char sub_1001BEC0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1063", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_100877BC[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100877BA[v2 * 4];
        v4 = byte_100877B9[v2 * 4];
        v5 = byte_100877B8[v2 * 4];
        v6 = sub_1000C870(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               (&off_100877C0)[v2 * 4]);
        v7 = sub_1000EA90(
               0,
               *(&dword_10083F74 + dword_100877BC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1063",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_100877BC[v2]],
               (&off_100877C0)[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1063",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1063",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100877BC: using guessed type int dword_100877BC[];
// 100877C0: using guessed type char *off_100877C0;
// 10220934: using guessed type char byte_10220934;

//----- (1001C020) --------------------------------------------------------
char sub_1001C020()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1089", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_10087C54[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10087C50[v2];
        v4 = dword_10087C4C[v2];
        v5 = dword_10087C48[v2];
        v6 = sub_1000C870(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               *(_DWORD *)&off_10087C58[v2 * 4]);
        v7 = sub_1000EE70(
               0,
               *(&dword_10083F74 + dword_10087C54[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1089",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_10087C54[v2]],
               *(_DWORD *)&off_10087C58[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1089",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1089",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10087C48: using guessed type int dword_10087C48[];
// 10087C4C: using guessed type int dword_10087C4C[];
// 10087C50: using guessed type int dword_10087C50[];
// 10087C54: using guessed type int dword_10087C54[];
// 10220934: using guessed type char byte_10220934;

//----- (1001C180) --------------------------------------------------------
char sub_1001C180()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000AE30(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_1000C760(0);
  sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1113", (int)v0);
  sub_1000AE30(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10220934 )
  {
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"1121", 2, 2);
    v2 = sub_100112A0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1122",
           (int)"UTF_verify_eq_str( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_1005C3FD,
           (int)"This test is expected to fail");
    sub_1000CBD0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1123",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"1125", 2, 2);
    v3 = sub_100112A0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1126",
           (int)"UTF_verify_eq_str( *, \"\", \"a\" ) data comparison",
           (const char *)&unk_1005C3FD,
           "a",
           (int)"This test is expected to fail");
    sub_1000CBD0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1127",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"1129", 2, 2);
    v4 = sub_100112A0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1130",
           (int)"UTF_verify_ne_str( *, \"\", \"\" ) data comparison",
           (const char *)&unk_1005C3FD,
           (const char *)&unk_1005C3FD,
           (int)"This test is expected to fail");
    sub_1000CBD0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1131",
      (int)"Return value from previous UTF_verify_ne_str() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"1133", 2, 2);
    v5 = sub_100112A0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1134",
           (int)"UTF_verify_ne_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           (int)"This test is expected to fail");
    result = sub_1000CBD0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1135",
               (int)"Return value from previous UTF_verify_ne_str() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1117",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10220934: using guessed type char byte_10220934;

//----- (1001C3A0) --------------------------------------------------------
char sub_1001C3A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1162", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_100883EC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100883E8[v2];
        v4 = dword_100883E4[v2];
        v5 = dword_100883E0[v2];
        v6 = sub_1000C870(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               (&off_100883F0)[v2 * 4]);
        v7 = sub_1000F230(
               0,
               *(&dword_10083F74 + dword_100883EC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1162",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_100883EC[v2]],
               (&off_100883F0)[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1162",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1162",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100883E0: using guessed type int dword_100883E0[];
// 100883E4: using guessed type int dword_100883E4[];
// 100883E8: using guessed type int dword_100883E8[];
// 100883EC: using guessed type int dword_100883EC[];
// 100883F0: using guessed type char *off_100883F0;
// 10220934: using guessed type char byte_10220934;

//----- (1001C500) --------------------------------------------------------
char sub_1001C500()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1188", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_10088758[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_10088754[v2 / 2];
        v4 = word_10088752[v2 / 2];
        v5 = word_10088750[v2 / 2];
        v6 = sub_1000C870(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               *(_DWORD *)&off_1008875C[v2]);
        v7 = sub_1000F5D0(
               0,
               *(&dword_10083F74 + dword_10088758[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1188",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_10088758[v2 / 4]],
               *(_DWORD *)&off_1008875C[v2]);
        LOBYTE(v0) = sub_1000CBD0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1188",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1188",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10088750: using guessed type __int16 word_10088750[];
// 10088752: using guessed type __int16 word_10088752[];
// 10088754: using guessed type __int16 word_10088754[];
// 10088758: using guessed type int dword_10088758[];
// 10220934: using guessed type char byte_10220934;

//----- (1001C660) --------------------------------------------------------
char sub_1001C660()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1214", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_10088A1C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10088A18[v2];
        v4 = dword_10088A14[v2];
        v5 = dword_10088A10[v2];
        v6 = sub_1000C870(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               (&off_10088A20)[v2 * 4]);
        v7 = sub_1000F9D0(
               0,
               *(&dword_10083F74 + dword_10088A1C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1214",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_10088A1C[v2]],
               (&off_10088A20)[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1214",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1214",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10088A10: using guessed type int dword_10088A10[];
// 10088A14: using guessed type int dword_10088A14[];
// 10088A18: using guessed type int dword_10088A18[];
// 10088A1C: using guessed type int dword_10088A1C[];
// 10088A20: using guessed type char *off_10088A20;
// 10220934: using guessed type char byte_10220934;

//----- (1001C7C0) --------------------------------------------------------
char sub_1001C7C0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1240", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_10088D98[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_10088D94[v2];
        LODWORD(v3) = dword_10088D90[v2];
        HIDWORD(v4) = dword_10088D8C[v2];
        LODWORD(v4) = dword_10088D88[v2];
        HIDWORD(v5) = dword_10088D84[v2];
        LODWORD(v5) = dword_10088D80[v2];
        v6 = sub_1000C870(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               *(_DWORD *)&off_10088D9C[v2 * 4]);
        v7 = sub_1000FD70(
               0,
               *(&dword_10083F74 + dword_10088D98[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1240",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_10088D98[v2]],
               *(_DWORD *)&off_10088D9C[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1240",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1240",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10088D80: using guessed type int dword_10088D80[];
// 10088D84: using guessed type int dword_10088D84[];
// 10088D88: using guessed type int dword_10088D88[];
// 10088D8C: using guessed type int dword_10088D8C[];
// 10088D90: using guessed type int dword_10088D90[];
// 10088D94: using guessed type int dword_10088D94[];
// 10088D98: using guessed type int dword_10088D98[];
// 10220934: using guessed type char byte_10220934;

//----- (1001C930) --------------------------------------------------------
char sub_1001C930()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1266", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_10089304[v2];
      if ( v0 != 6 )
      {
        v3 = byte_10089302[v2 * 4];
        v4 = byte_10089301[v2 * 4];
        v5 = byte_10089300[v2 * 4];
        v6 = sub_1000C870(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               (&off_10089308)[v2 * 4]);
        v7 = sub_10010350(
               0,
               *(&dword_10083F74 + dword_10089304[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1266",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_10089304[v2]],
               (&off_10089308)[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1266",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1266",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10089304: using guessed type int dword_10089304[];
// 10089308: using guessed type char *off_10089308;
// 10220934: using guessed type char byte_10220934;

//----- (1001CA90) --------------------------------------------------------
char sub_1001CA90()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1292", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_1008951C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10089518[v2];
        v4 = dword_10089514[v2];
        v5 = dword_10089510[v2];
        v6 = sub_1000C870(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               (&off_10089520)[v2 * 4]);
        v7 = sub_10010740(
               0,
               *(&dword_10083F74 + dword_1008951C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1292",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_1008951C[v2]],
               (&off_10089520)[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1292",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1292",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10089510: using guessed type int dword_10089510[];
// 10089514: using guessed type int dword_10089514[];
// 10089518: using guessed type int dword_10089518[];
// 1008951C: using guessed type int dword_1008951C[];
// 10089520: using guessed type char *off_10089520;
// 10220934: using guessed type char byte_10220934;

//----- (1001CBF0) --------------------------------------------------------
char sub_1001CBF0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_1000AE30(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"All Fail Robustness Test Group For Type 'bitmap'");
  v0 = sub_1000C760(0);
  sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1337", (int)v0);
  sub_1000AE30(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10220934 )
  {
    v2 = 0;
    do
    {
      if ( off_10089884[v2] )
      {
        sub_1000C5D0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_1008988C[v2 * 4], 0x100u, &v11);
        sub_1000C5D0((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_10089884[v2], 0x100u, &v12);
        sub_10024CD0(&v12, &v11);
      }
      if ( byte_10089880[v2 * 4] )
      {
        sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"1362", 2, 2);
        v3 = off_10089888[v2];
        v4 = *(char **)&off_1008988C[v2 * 4];
        v5 = sub_1000C870(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1008988C[v2 * 4],
               off_10089888[v2]);
        v6 = sub_10010EF0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1367",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1000CBD0(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1369",
                   (int)"Return value from previous UTF_verify_eq_bitmap_rt() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"1373", 2, 2);
        v7 = off_10089888[v2];
        v8 = *(char **)&off_1008988C[v2 * 4];
        v9 = sub_1000C870(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1008988C[v2 * 4],
               off_10089888[v2]);
        v10 = sub_10010EF0(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"1378",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1000CBD0(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1380",
                   (int)"Return value from previous UTF_verify_ne_bitmap_rt() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 4;
    }
    while ( v2 < 36 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1341",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10089884: using guessed type char *off_10089884[3];
// 10089888: using guessed type char *off_10089888[2];
// 10220934: using guessed type char byte_10220934;

//----- (1001CE10) --------------------------------------------------------
char sub_1001CE10()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000AE30(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_1000C760(0);
  sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1407", (int)v0);
  sub_1000AE30(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"Verify relationship between boolean values using the UTF_verify_bool_rt() function");
  if ( byte_10220934 )
  {
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"1415", 2, 2);
    v2 = sub_1000CBD0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1416",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1000CBD0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1417",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"1419", 2, 2);
    v3 = sub_1000CBD0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1420",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1000CBD0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1421",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"1423", 2, 2);
    v4 = sub_1000CBD0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1424",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1000CBD0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1425",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"1427", 2, 2);
    v5 = sub_1000CBD0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1428",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1000CBD0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1429",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1411",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10220934: using guessed type char byte_10220934;

//----- (1001D010) --------------------------------------------------------
char sub_1001D010()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1469", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_10089914[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"1469", 2, 2);
        v3 = byte_10089911[v2 * 4];
        v4 = byte_10089910[v2 * 4];
        v5 = sub_1000C870(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + dword_10089914[v2])],
               (&off_10089918)[v2 * 4]);
        v6 = sub_1000CD10(
               1,
               *(&dword_10083F74 + dword_10089914[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1469",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1000C870(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_10089914[v2]],
               (&off_10089918)[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1469",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1469",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10089914: using guessed type int dword_10089914[];
// 10089918: using guessed type char *off_10089918;
// 10220934: using guessed type char byte_10220934;

//----- (1001D190) --------------------------------------------------------
char sub_1001D190()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1503", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_10089B98[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_10089B90[v2 / 8];
        v4 = dbl_10089B88[v2 / 8];
        v5 = dbl_10089B80[v2 / 8];
        v6 = sub_1000C870(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               *(_DWORD *)&off_10089B9C[v2]);
        v7 = sub_1000D0C0(
               1,
               *(&dword_10083F74 + dword_10089B98[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1503",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_10089B98[v2 / 4]],
               *(_DWORD *)&off_10089B9C[v2]);
        LOBYTE(v0) = sub_1000CBD0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1503",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1503",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10089B80: using guessed type double dbl_10089B80[];
// 10089B88: using guessed type double dbl_10089B88[];
// 10089B90: using guessed type double dbl_10089B90[];
// 10089B98: using guessed type int dword_10089B98[];
// 10220934: using guessed type char byte_10220934;

//----- (1001D310) --------------------------------------------------------
char sub_1001D310()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1539", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_1008A7AC[v2];
      if ( v0 != 6 )
      {
        v3 = flt_1008A7A8[v2];
        v4 = flt_1008A7A4[v2];
        v5 = flt_1008A7A0[v2];
        v6 = sub_1000C870(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               (&off_1008A7B0)[v2 * 4]);
        v7 = sub_1000D510(
               1,
               *(&dword_10083F74 + dword_1008A7AC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1539",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_1008A7AC[v2]],
               (&off_1008A7B0)[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1539",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1539",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1008A7A0: using guessed type float flt_1008A7A0[];
// 1008A7A4: using guessed type float flt_1008A7A4[];
// 1008A7A8: using guessed type float flt_1008A7A8[];
// 1008A7AC: using guessed type int dword_1008A7AC[];
// 1008A7B0: using guessed type char *off_1008A7B0;
// 10220934: using guessed type char byte_10220934;

//----- (1001D480) --------------------------------------------------------
char sub_1001D480()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1000AE30(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1000C760(0);
  sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1561", (int)v0);
  sub_1000AE30(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10220934 )
  {
    sub_100111F0(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1569",
      (int)"Check ptr for equality",
      (int)sub_1001D480,
      (int)sub_1001D480,
      0);
    sub_100111F0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1570",
      (int)"Check ptr for inequality",
      (int)sub_1001D480,
      0,
      0);
    result = sub_100111F0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1571",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1001D480,
               0);
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1565",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10220934: using guessed type char byte_10220934;

//----- (1001D570) --------------------------------------------------------
char sub_1001D570()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1598", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_1008AF44[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1008AF40[v2];
        v4 = dword_1008AF3C[v2];
        v5 = dword_1008AF38[v2];
        v6 = sub_1000C870(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               *(_DWORD *)&off_1008AF48[v2 * 4]);
        v7 = sub_1000D9D0(
               1,
               *(&dword_10083F74 + dword_1008AF44[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1598",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_1008AF44[v2]],
               *(_DWORD *)&off_1008AF48[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1598",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1598",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1008AF38: using guessed type int dword_1008AF38[];
// 1008AF3C: using guessed type int dword_1008AF3C[];
// 1008AF40: using guessed type int dword_1008AF40[];
// 1008AF44: using guessed type int dword_1008AF44[];
// 10220934: using guessed type char byte_10220934;

//----- (1001D6D0) --------------------------------------------------------
char sub_1001D6D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1624", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_1008B6D8[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_1008B6D4[v2 / 2];
        v4 = word_1008B6D2[v2 / 2];
        v5 = word_1008B6D0[v2 / 2];
        v6 = sub_1000C870(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               *(_DWORD *)&off_1008B6DC[v2]);
        v7 = sub_1000DD90(
               1,
               *(&dword_10083F74 + dword_1008B6D8[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1624",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_1008B6D8[v2 / 4]],
               *(_DWORD *)&off_1008B6DC[v2]);
        LOBYTE(v0) = sub_1000CBD0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1624",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1624",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1008B6D0: using guessed type __int16 word_1008B6D0[];
// 1008B6D2: using guessed type __int16 word_1008B6D2[];
// 1008B6D4: using guessed type __int16 word_1008B6D4[];
// 1008B6D8: using guessed type int dword_1008B6D8[];
// 10220934: using guessed type char byte_10220934;

//----- (1001D830) --------------------------------------------------------
char sub_1001D830()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1650", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_1008BCEC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1008BCE8[v2];
        v4 = dword_1008BCE4[v2];
        v5 = dword_1008BCE0[v2];
        v6 = sub_1000C870(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               (&off_1008BCF0)[v2 * 4]);
        v7 = sub_1000E190(
               1,
               *(&dword_10083F74 + dword_1008BCEC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1650",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_1008BCEC[v2]],
               (&off_1008BCF0)[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1650",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1650",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1008BCE0: using guessed type int dword_1008BCE0[];
// 1008BCE4: using guessed type int dword_1008BCE4[];
// 1008BCE8: using guessed type int dword_1008BCE8[];
// 1008BCEC: using guessed type int dword_1008BCEC[];
// 1008BCF0: using guessed type char *off_1008BCF0;
// 10220934: using guessed type char byte_10220934;

//----- (1001D990) --------------------------------------------------------
char sub_1001D990()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1676", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_1008C490[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1008C48C[v2];
        LODWORD(v3) = dword_1008C488[v2];
        HIDWORD(v4) = dword_1008C484[v2];
        LODWORD(v4) = dword_1008C480[v2];
        HIDWORD(v5) = dword_1008C47C[v2];
        LODWORD(v5) = dword_1008C478[v2];
        v6 = sub_1000C870(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               *(_DWORD *)&off_1008C494[v2 * 4]);
        v7 = sub_1000E550(
               1,
               *(&dword_10083F74 + dword_1008C490[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1676",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_1008C490[v2]],
               *(_DWORD *)&off_1008C494[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1676",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1676",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1008C478: using guessed type int dword_1008C478[];
// 1008C47C: using guessed type int dword_1008C47C[];
// 1008C480: using guessed type int dword_1008C480[];
// 1008C484: using guessed type int dword_1008C484[];
// 1008C488: using guessed type int dword_1008C488[];
// 1008C48C: using guessed type int dword_1008C48C[];
// 1008C490: using guessed type int dword_1008C490[];
// 10220934: using guessed type char byte_10220934;

//----- (1001DB00) --------------------------------------------------------
char sub_1001DB00()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1702", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_1008D09C[v2];
      if ( v0 != 6 )
      {
        v3 = byte_1008D09A[v2 * 4];
        v4 = byte_1008D099[v2 * 4];
        v5 = byte_1008D098[v2 * 4];
        v6 = sub_1000C870(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               (&off_1008D0A0)[v2 * 4]);
        v7 = sub_1000EA90(
               1,
               *(&dword_10083F74 + dword_1008D09C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1702",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_1008D09C[v2]],
               (&off_1008D0A0)[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1702",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1702",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1008D09C: using guessed type int dword_1008D09C[];
// 1008D0A0: using guessed type char *off_1008D0A0;
// 10220934: using guessed type char byte_10220934;

//----- (1001DC60) --------------------------------------------------------
char sub_1001DC60()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1728", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_1008D534[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1008D530[v2];
        v4 = dword_1008D52C[v2];
        v5 = dword_1008D528[v2];
        v6 = sub_1000C870(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               *(_DWORD *)&off_1008D538[v2 * 4]);
        v7 = sub_1000EE70(
               1,
               *(&dword_10083F74 + dword_1008D534[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1728",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_1008D534[v2]],
               *(_DWORD *)&off_1008D538[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1728",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1728",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1008D528: using guessed type int dword_1008D528[];
// 1008D52C: using guessed type int dword_1008D52C[];
// 1008D530: using guessed type int dword_1008D530[];
// 1008D534: using guessed type int dword_1008D534[];
// 10220934: using guessed type char byte_10220934;

//----- (1001DDC0) --------------------------------------------------------
char sub_1001DDC0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000AE30(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_1000C760(0);
  sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1752", (int)v0);
  sub_1000AE30(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10220934 )
  {
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"1760", 2, 2);
    v2 = sub_100112A0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1761",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_1005C3FD,
           0);
    sub_1000CBD0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1762",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"1764", 2, 2);
    v3 = sub_100112A0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1765",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"a\" ) data comparison",
           (const char *)&unk_1005C3FD,
           "a",
           0);
    sub_1000CBD0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1766",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"1768", 2, 2);
    v4 = sub_100112A0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1769",
           (int)"UTF_verify_ne_str_rt( *, \"\", \"\" ) data comparison",
           (const char *)&unk_1005C3FD,
           (const char *)&unk_1005C3FD,
           0);
    sub_1000CBD0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1770",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"1772", 2, 2);
    v5 = sub_100112A0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1773",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    result = sub_1000CBD0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1774",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1756",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10220934: using guessed type char byte_10220934;

//----- (1001DFC0) --------------------------------------------------------
char sub_1001DFC0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1801", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_1008DCCC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1008DCC8[v2];
        v4 = dword_1008DCC4[v2];
        v5 = dword_1008DCC0[v2];
        v6 = sub_1000C870(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               (&off_1008DCD0)[v2 * 4]);
        v7 = sub_1000F230(
               1,
               *(&dword_10083F74 + dword_1008DCCC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1801",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_1008DCCC[v2]],
               (&off_1008DCD0)[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1801",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1801",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1008DCC0: using guessed type int dword_1008DCC0[];
// 1008DCC4: using guessed type int dword_1008DCC4[];
// 1008DCC8: using guessed type int dword_1008DCC8[];
// 1008DCCC: using guessed type int dword_1008DCCC[];
// 1008DCD0: using guessed type char *off_1008DCD0;
// 10220934: using guessed type char byte_10220934;

//----- (1001E120) --------------------------------------------------------
char sub_1001E120()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1827", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_1008E038[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_1008E034[v2 / 2];
        v4 = word_1008E032[v2 / 2];
        v5 = word_1008E030[v2 / 2];
        v6 = sub_1000C870(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               *(_DWORD *)&off_1008E03C[v2]);
        v7 = sub_1000F5D0(
               1,
               *(&dword_10083F74 + dword_1008E038[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1827",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_1008E038[v2 / 4]],
               *(_DWORD *)&off_1008E03C[v2]);
        LOBYTE(v0) = sub_1000CBD0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1827",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1827",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1008E030: using guessed type __int16 word_1008E030[];
// 1008E032: using guessed type __int16 word_1008E032[];
// 1008E034: using guessed type __int16 word_1008E034[];
// 1008E038: using guessed type int dword_1008E038[];
// 10220934: using guessed type char byte_10220934;

//----- (1001E280) --------------------------------------------------------
char sub_1001E280()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1853", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_1008E2FC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1008E2F8[v2];
        v4 = dword_1008E2F4[v2];
        v5 = dword_1008E2F0[v2];
        v6 = sub_1000C870(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               (&off_1008E300)[v2 * 4]);
        v7 = sub_1000F9D0(
               1,
               *(&dword_10083F74 + dword_1008E2FC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1853",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_1008E2FC[v2]],
               (&off_1008E300)[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1853",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1853",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1008E2F0: using guessed type int dword_1008E2F0[];
// 1008E2F4: using guessed type int dword_1008E2F4[];
// 1008E2F8: using guessed type int dword_1008E2F8[];
// 1008E2FC: using guessed type int dword_1008E2FC[];
// 1008E300: using guessed type char *off_1008E300;
// 10220934: using guessed type char byte_10220934;

//----- (1001E3E0) --------------------------------------------------------
char sub_1001E3E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1879", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_1008E678[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1008E674[v2];
        LODWORD(v3) = dword_1008E670[v2];
        HIDWORD(v4) = dword_1008E66C[v2];
        LODWORD(v4) = dword_1008E668[v2];
        HIDWORD(v5) = dword_1008E664[v2];
        LODWORD(v5) = dword_1008E660[v2];
        v6 = sub_1000C870(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               *(_DWORD *)&off_1008E67C[v2 * 4]);
        v7 = sub_1000FD70(
               1,
               *(&dword_10083F74 + dword_1008E678[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1879",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_1008E678[v2]],
               *(_DWORD *)&off_1008E67C[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1879",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1879",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1008E660: using guessed type int dword_1008E660[];
// 1008E664: using guessed type int dword_1008E664[];
// 1008E668: using guessed type int dword_1008E668[];
// 1008E66C: using guessed type int dword_1008E66C[];
// 1008E670: using guessed type int dword_1008E670[];
// 1008E674: using guessed type int dword_1008E674[];
// 1008E678: using guessed type int dword_1008E678[];
// 10220934: using guessed type char byte_10220934;

//----- (1001E550) --------------------------------------------------------
char sub_1001E550()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1905", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_1008EBE4[v2];
      if ( v0 != 6 )
      {
        v3 = byte_1008EBE2[v2 * 4];
        v4 = byte_1008EBE1[v2 * 4];
        v5 = byte_1008EBE0[v2 * 4];
        v6 = sub_1000C870(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               (&off_1008EBE8)[v2 * 4]);
        v7 = sub_10010350(
               1,
               *(&dword_10083F74 + dword_1008EBE4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1905",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_1008EBE4[v2]],
               (&off_1008EBE8)[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1905",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1905",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1008EBE4: using guessed type int dword_1008EBE4[];
// 1008EBE8: using guessed type char *off_1008EBE8;
// 10220934: using guessed type char byte_10220934;

//----- (1001E6B0) --------------------------------------------------------
char sub_1001E6B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10220934 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1931", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_1008EDFC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1008EDF8[v2];
        v4 = dword_1008EDF4[v2];
        v5 = dword_1008EDF0[v2];
        v6 = sub_1000C870(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * *(&dword_10083F74 + v0)],
               (&off_1008EE00)[v2 * 4]);
        v7 = sub_10010740(
               1,
               *(&dword_10083F74 + dword_1008EDFC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1931",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000C870(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_1008EDFC[v2]],
               (&off_1008EE00)[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1931",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1931",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1008EDF0: using guessed type int dword_1008EDF0[];
// 1008EDF4: using guessed type int dword_1008EDF4[];
// 1008EDF8: using guessed type int dword_1008EDF8[];
// 1008EDFC: using guessed type int dword_1008EDFC[];
// 1008EE00: using guessed type char *off_1008EE00;
// 10220934: using guessed type char byte_10220934;

//----- (1001E810) --------------------------------------------------------
char sub_1001E810()
{
  const char *v0; // eax@1
  int v1; // esi@1
  char result; // al@2
  char v3; // al@5

  sub_1000AE30(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"All Pass Miscellaneous Test Group");
  v0 = sub_1000C760(0);
  sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1968", (int)v0);
  sub_1000AE30(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"Verify miscellaneous macros");
  v1 = 5;
  if ( byte_10220935 )
  {
    sub_100112A0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1978",
      (int)"Check PASS macro",
      "UTF_verify_pass unconditional pass",
      "UTF_verify_pass unconditional pass",
      0);
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"1987", 0, 0);
    sub_1000AE30(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1988", (int)"Sub-group A, msg 1");
    sub_1000AE30(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1989", (int)"Sub-group A, msg 2");
    sub_1000AE30(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1990", (int)"Sub-group A, msg 3");
    sub_1000AE30(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1991", (int)"Sub-group A, msg 4");
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"1993", 0, 0);
    sub_1000AE30(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1994", (int)"Sub-group B, msg 1");
    sub_1000AE30(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1995", (int)"Sub-group B, msg 2");
    sub_1000AE30(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1996", (int)"Sub-group B, msg 3");
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"1998", 1, 2);
    sub_1000D9D0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"1999", (int)"Sub-group C verify 1", 1, 1, 0, 0);
    sub_1000AE30(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2000", (int)"Sub-group C, msg 1");
    sub_1000AE30(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2001", (int)"Sub-group C, msg 2");
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2003", 2, 2);
    sub_1000AE30(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2004", (int)"Sub-group D, msg 1");
    sub_1000D9D0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2005", (int)"Sub-group D verify 1", 1, 1, 0, 0);
    sub_1000AE30(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2006", (int)"Sub-group D, msg 2");
    sub_1000D9D0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2007", (int)"Sub-group D verify 2", 2, 2, 0, 0);
    sub_1000AE30(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2009", (int)"non sub-group msg 1");
    sub_1000AE30(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2010", (int)"non sub-group msg 2");
    sub_1000D9D0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2011", (int)"non sub-group verify 1", 1, 1, 0, 0);
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2013", 3, 4);
    sub_1000AE30(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2014", (int)"Sub-group E, msg 1");
    sub_1000D9D0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2015", (int)"Sub-group E verify 1", 1, 1, 0, 0);
    sub_1000AE30(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2016", (int)"Sub-group E, msg 2");
    sub_1000D9D0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2017", (int)"Sub-group E verify 2", 2, 2, 0, 0);
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2019", 3, 4);
    sub_1000D9D0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2020", (int)"Sub-group F verify 1", 1, 1, 0, 0);
    sub_1000AE30(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2021", (int)"Sub-group F, msg 1");
    sub_1000D9D0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2022", (int)"Sub-group F verify 2", 2, 2, 0, 0);
    sub_1000AE30(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2023", (int)"Sub-group F, msg 2");
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2025", 4, 0);
    sub_1000D9D0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2026", (int)"Sub-group G verify 1", 1, 1, 0, 0);
    sub_1000AE30(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2027", (int)"Sub-group G, msg 1");
    sub_1000AE30(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2028", (int)"Sub-group G, msg 2");
    sub_1000D9D0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2029", (int)"Sub-group G verify 2", 2, 2, 0, 0);
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2030", 5, 0);
    sub_1000AE30(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2032", (int)"non sub-group msg 3");
    sub_1000AE30(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2033", (int)"non sub-group msg 4");
    sub_1000D9D0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2034", (int)"non sub-group verify 2", 2, 2, 0, 0);
    if ( !sub_100239A0() )
      v1 = 3;
    sub_1000D9D0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2037",
      (int)"Verify x is 3 using UTF_CALL_UNIT",
      v1,
      3,
      0,
      0);
    v3 = sub_100239A0();
    sub_1000D9D0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2040",
      (int)"Verify x is 4 using UTF_CALL_UNIT2",
      v3 != 0 ? 6 : 4,
      4,
      0,
      0);
    sub_1000AE30(
      3,
      (int)"**MSG**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2042",
      (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceeds the int"
           "ernal UTF buffer size, can be written to the output without the system crashing or otherwise demonstrating ha"
           "rmful side-effects. If the system does crash while writing this message, it is a sign that possibly the UTF h"
           "as some buffer overlow issues that should be examined and corrected. If the system runs successfully, it does"
           " not prove the UTF is defect free in this regard, only that this particular scenario is succesfully handled u"
           "nder the current conditions. Other invocations of UTF interfaces with large messages may be problematic, but "
           "at least on the surface, things seem to be OK for now.");
    result = sub_1000D9D0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2043",
               (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceed"
                    "s the internal UTF buffer size, can be written to the output without the system crashing or otherwis"
                    "e demonstrating harmful side-effects. If the system does crash while writing this message, it is a s"
                    "ign that possibly the UTF has some buffer overlow issues that should be examined and corrected. If t"
                    "he system runs successfully, it does not prove the UTF is defect free in this regard, only that this"
                    " particular scenario is succesfully handled under the current conditions. Other invocations of UTF i"
                    "nterfaces with large messages may be problematic, but at least on the surface, things seem to be OK for now.",
               4,
               4,
               0,
               0);
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1974",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10220935: using guessed type char byte_10220935;

//----- (1001EDB0) --------------------------------------------------------
char sub_1001EDB0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  char *v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_1000AE30(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"All Pass Test Group For Type 'bitmap'");
  v0 = sub_1000C760(0);
  sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2085", (int)v0);
  sub_1000AE30(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10220935 )
  {
    v2 = 0;
    do
    {
      if ( off_1008F164[v2] )
      {
        sub_1000C5D0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_1008F16C[v2 * 4], 0x100u, &v13);
        sub_1000C5D0((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_1008F164[v2], 0x100u, &v14);
        sub_10024CD0(&v14, &v13);
      }
      if ( byte_1008F160[v2 * 4] )
      {
        sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2110", 2, 2);
        v3 = off_1008F168[v2];
        v4 = *(char **)&off_1008F16C[v2 * 4];
        v5 = sub_1000C870(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1008F16C[v2 * 4],
               off_1008F168[v2]);
        v12 = 1;
        v11 = sub_10010EF0(
                0,
                0,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2114",
                (int)v5,
                (int)v4,
                (int)v3,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_eq_bitmap() call";
        v9 = "2115";
      }
      else
      {
        sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2119", 2, 2);
        v6 = off_1008F168[v2];
        v7 = *(char **)&off_1008F16C[v2 * 4];
        v8 = sub_1000C870(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1008F16C[v2 * 4],
               off_1008F168[v2]);
        v12 = 1;
        v11 = sub_10010EF0(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2123",
                (int)v8,
                (int)v7,
                (int)v6,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_ne_bitmap() call";
        v9 = "2124";
      }
      result = sub_1000CBD0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 4;
    }
    while ( v2 < 20 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2089",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1008F164: using guessed type char *off_1008F164[3];
// 1008F168: using guessed type char *off_1008F168[2];
// 10220935: using guessed type char byte_10220935;

//----- (1001EFC0) --------------------------------------------------------
char sub_1001EFC0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000AE30(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_1000C760(0);
  sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2151", (int)v0);
  sub_1000AE30(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10220935 )
  {
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2159", 2, 2);
    v2 = sub_1000CBD0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2160",
           (int)"UTF_verify_eq_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1000CBD0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2161",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      0);
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2163", 2, 2);
    v3 = sub_1000CBD0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2164",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1000CBD0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2165",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      0);
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2167", 2, 2);
    v4 = sub_1000CBD0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2168",
           (int)"UTF_verify_ne_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1000CBD0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2169",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      0);
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2171", 2, 2);
    v5 = sub_1000CBD0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2172",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1000CBD0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2173",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2155",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10220935: using guessed type char byte_10220935;

//----- (1001F1B0) --------------------------------------------------------
char sub_1001F1B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_1008F1B4[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2213", 2, 2);
        v3 = byte_1008F1B1[v2 * 4];
        v4 = byte_1008F1B0[v2 * 4];
        v5 = sub_1000C870(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * dword_1008F1B4[v2]],
               (&off_1008F1B8)[v2 * 4]);
        v6 = sub_1000CD10(0, dword_1008F1B4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v5, v4, v3, 0);
        v7 = sub_1000C870(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_1008F1B4[v2]],
               (&off_1008F1B8)[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2213",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 1008F1B4: using guessed type int dword_1008F1B4[];
// 1008F1B8: using guessed type char *off_1008F1B8;
// 10220935: using guessed type char byte_10220935;

//----- (1001F320) --------------------------------------------------------
char sub_1001F320()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2247", 2, 2);
      v3 = dbl_1008F430[v2 / 2];
      v4 = dbl_1008F428[v2 / 2];
      v5 = dbl_1008F420[v2 / 2];
      v6 = sub_1000C870(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_1008F438[v2]],
             *(_DWORD *)&off_1008F43C[v2 * 4]);
      v7 = sub_1000D0C0(0, dword_1008F438[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_1008F438[v2]],
             *(_DWORD *)&off_1008F43C[v2 * 4]);
      result = sub_1000CBD0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2247",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1008F420: using guessed type double dbl_1008F420[];
// 1008F428: using guessed type double dbl_1008F428[];
// 1008F430: using guessed type double dbl_1008F430[];
// 1008F438: using guessed type int dword_1008F438[];
// 10220935: using guessed type char byte_10220935;

//----- (1001F490) --------------------------------------------------------
char sub_1001F490()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2283", 2, 2);
      v3 = flt_10090048[v2];
      v4 = flt_10090044[v2];
      v5 = flt_10090040[v2];
      v6 = sub_1000C870(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_1009004C[v2]],
             (&off_10090050)[v2 * 4]);
      v7 = sub_1000D510(0, dword_1009004C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_1009004C[v2]],
             (&off_10090050)[v2 * 4]);
      result = sub_1000CBD0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2283",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10090040: using guessed type float flt_10090040[];
// 10090044: using guessed type float flt_10090044[];
// 10090048: using guessed type float flt_10090048[];
// 1009004C: using guessed type int dword_1009004C[];
// 10090050: using guessed type char *off_10090050;
// 10220935: using guessed type char byte_10220935;

//----- (1001F5F0) --------------------------------------------------------
char sub_1001F5F0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1000AE30(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1000C760(0);
  sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2305", (int)v0);
  sub_1000AE30(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10220935 )
  {
    sub_100111F0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2313",
      (int)"Check ptr for equality",
      (int)sub_1001F5F0,
      (int)sub_1001F5F0,
      0);
    sub_100111F0(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2314",
      (int)"Check ptr for inequality",
      (int)sub_1001F5F0,
      0,
      0);
    result = sub_100111F0(
               0,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2315",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1001F5F0,
               0);
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2309",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10220935: using guessed type char byte_10220935;

//----- (1001F6E0) --------------------------------------------------------
char sub_1001F6E0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2342", 2, 2);
      v3 = dword_100907E0[v2];
      v4 = dword_100907DC[v2];
      v5 = dword_100907D8[v2];
      v6 = sub_1000C870(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_100907E4[v2]],
             *(_DWORD *)&off_100907E8[v2 * 4]);
      v7 = sub_1000D9D0(0, dword_100907E4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_100907E4[v2]],
             *(_DWORD *)&off_100907E8[v2 * 4]);
      result = sub_1000CBD0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2342",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100907D8: using guessed type int dword_100907D8[];
// 100907DC: using guessed type int dword_100907DC[];
// 100907E0: using guessed type int dword_100907E0[];
// 100907E4: using guessed type int dword_100907E4[];
// 10220935: using guessed type char byte_10220935;

//----- (1001F840) --------------------------------------------------------
char sub_1001F840()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2368", 2, 2);
      v3 = word_10090F74[v2 / 2];
      v4 = word_10090F72[v2 / 2];
      v5 = word_10090F70[v2 / 2];
      v6 = sub_1000C870(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_10090F78[v2 / 4]],
             *(_DWORD *)&off_10090F7C[v2]);
      v7 = sub_1000DD90(
             0,
             dword_10090F78[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2368",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_10090F78[v2 / 4]],
             *(_DWORD *)&off_10090F7C[v2]);
      result = sub_1000CBD0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2368",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10090F70: using guessed type __int16 word_10090F70[];
// 10090F72: using guessed type __int16 word_10090F72[];
// 10090F74: using guessed type __int16 word_10090F74[];
// 10090F78: using guessed type int dword_10090F78[];
// 10220935: using guessed type char byte_10220935;

//----- (1001F9A0) --------------------------------------------------------
char sub_1001F9A0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2394", 2, 2);
      v3 = dword_10091588[v2];
      v4 = dword_10091584[v2];
      v5 = dword_10091580[v2];
      v6 = sub_1000C870(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_1009158C[v2]],
             (&off_10091590)[v2 * 4]);
      v7 = sub_1000E190(0, dword_1009158C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_1009158C[v2]],
             (&off_10091590)[v2 * 4]);
      result = sub_1000CBD0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2394",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10091580: using guessed type int dword_10091580[];
// 10091584: using guessed type int dword_10091584[];
// 10091588: using guessed type int dword_10091588[];
// 1009158C: using guessed type int dword_1009158C[];
// 10091590: using guessed type char *off_10091590;
// 10220935: using guessed type char byte_10220935;

//----- (1001FB00) --------------------------------------------------------
char sub_1001FB00()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2420", 2, 2);
      HIDWORD(v3) = dword_10091D2C[v2];
      LODWORD(v3) = dword_10091D28[v2];
      HIDWORD(v4) = dword_10091D24[v2];
      LODWORD(v4) = dword_10091D20[v2];
      HIDWORD(v5) = dword_10091D1C[v2];
      LODWORD(v5) = dword_10091D18[v2];
      v6 = sub_1000C870(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_10091D30[v2]],
             *(_DWORD *)&off_10091D34[v2 * 4]);
      v7 = sub_1000E550(0, dword_10091D30[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_10091D30[v2]],
             *(_DWORD *)&off_10091D34[v2 * 4]);
      result = sub_1000CBD0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2420",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10091D18: using guessed type int dword_10091D18[];
// 10091D1C: using guessed type int dword_10091D1C[];
// 10091D20: using guessed type int dword_10091D20[];
// 10091D24: using guessed type int dword_10091D24[];
// 10091D28: using guessed type int dword_10091D28[];
// 10091D2C: using guessed type int dword_10091D2C[];
// 10091D30: using guessed type int dword_10091D30[];
// 10220935: using guessed type char byte_10220935;

//----- (1001FC70) --------------------------------------------------------
char sub_1001FC70()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2446", 2, 2);
      v3 = byte_1009293A[v2 * 4];
      v4 = byte_10092939[v2 * 4];
      v5 = byte_10092938[v2 * 4];
      v6 = sub_1000C870(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_1009293C[v2]],
             (&off_10092940)[v2 * 4]);
      v7 = sub_1000EA90(0, dword_1009293C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_1009293C[v2]],
             (&off_10092940)[v2 * 4]);
      result = sub_1000CBD0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2446",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1009293C: using guessed type int dword_1009293C[];
// 10092940: using guessed type char *off_10092940;
// 10220935: using guessed type char byte_10220935;

//----- (1001FDD0) --------------------------------------------------------
char sub_1001FDD0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2472", 2, 2);
      v3 = dword_10092DD0[v2];
      v4 = dword_10092DCC[v2];
      v5 = dword_10092DC8[v2];
      v6 = sub_1000C870(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_10092DD4[v2]],
             *(_DWORD *)&off_10092DD8[v2 * 4]);
      v7 = sub_1000EE70(0, dword_10092DD4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_10092DD4[v2]],
             *(_DWORD *)&off_10092DD8[v2 * 4]);
      result = sub_1000CBD0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2472",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10092DC8: using guessed type int dword_10092DC8[];
// 10092DCC: using guessed type int dword_10092DCC[];
// 10092DD0: using guessed type int dword_10092DD0[];
// 10092DD4: using guessed type int dword_10092DD4[];
// 10220935: using guessed type char byte_10220935;

//----- (1001FF30) --------------------------------------------------------
char sub_1001FF30()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000AE30(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_1000C760(0);
  sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2496", (int)v0);
  sub_1000AE30(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10220935 )
  {
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2504", 2, 2);
    v2 = sub_100112A0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2505",
           (int)"UTF_verify_eq_str( *, \"\", \"\" ) data comparison",
           (const char *)&unk_1005C3FD,
           (const char *)&unk_1005C3FD,
           0);
    sub_1000CBD0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2506",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      0);
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2508", 2, 2);
    v3 = sub_100112A0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2509",
           (int)"UTF_verify_eq_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1000CBD0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2510",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      0);
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2512", 2, 2);
    v4 = sub_100112A0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2513",
           (int)"UTF_verify_ne_str( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_1005C3FD,
           0);
    sub_1000CBD0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2514",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v4,
      1u,
      0);
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2516", 2, 2);
    v5 = sub_100112A0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2517",
           (int)"UTF_verify_ne_str( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1000CBD0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2518",
               (int)"Return value from previous UTF_verify_eq_str() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2500",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10220935: using guessed type char byte_10220935;

//----- (10020130) --------------------------------------------------------
char sub_10020130()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2545", 2, 2);
      v3 = dword_10093568[v2];
      v4 = dword_10093564[v2];
      v5 = dword_10093560[v2];
      v6 = sub_1000C870(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_1009356C[v2]],
             (&off_10093570)[v2 * 4]);
      v7 = sub_1000F230(0, dword_1009356C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_1009356C[v2]],
             (&off_10093570)[v2 * 4]);
      result = sub_1000CBD0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2545",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10093560: using guessed type int dword_10093560[];
// 10093564: using guessed type int dword_10093564[];
// 10093568: using guessed type int dword_10093568[];
// 1009356C: using guessed type int dword_1009356C[];
// 10093570: using guessed type char *off_10093570;
// 10220935: using guessed type char byte_10220935;

//----- (10020290) --------------------------------------------------------
char sub_10020290()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2571", 2, 2);
      v3 = word_100938D4[v2 / 2];
      v4 = word_100938D2[v2 / 2];
      v5 = word_100938D0[v2 / 2];
      v6 = sub_1000C870(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_100938D8[v2 / 4]],
             *(_DWORD *)&off_100938DC[v2]);
      v7 = sub_1000F5D0(
             0,
             dword_100938D8[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2571",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_100938D8[v2 / 4]],
             *(_DWORD *)&off_100938DC[v2]);
      result = sub_1000CBD0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2571",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100938D0: using guessed type __int16 word_100938D0[];
// 100938D2: using guessed type __int16 word_100938D2[];
// 100938D4: using guessed type __int16 word_100938D4[];
// 100938D8: using guessed type int dword_100938D8[];
// 10220935: using guessed type char byte_10220935;

//----- (100203F0) --------------------------------------------------------
char sub_100203F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2597", 2, 2);
      v3 = dword_10093B98[v2];
      v4 = dword_10093B94[v2];
      v5 = dword_10093B90[v2];
      v6 = sub_1000C870(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_10093B9C[v2]],
             (&off_10093BA0)[v2 * 4]);
      v7 = sub_1000F9D0(0, dword_10093B9C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_10093B9C[v2]],
             (&off_10093BA0)[v2 * 4]);
      result = sub_1000CBD0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2597",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10093B90: using guessed type int dword_10093B90[];
// 10093B94: using guessed type int dword_10093B94[];
// 10093B98: using guessed type int dword_10093B98[];
// 10093B9C: using guessed type int dword_10093B9C[];
// 10093BA0: using guessed type char *off_10093BA0;
// 10220935: using guessed type char byte_10220935;

//----- (10020550) --------------------------------------------------------
char sub_10020550()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2623", 2, 2);
      HIDWORD(v3) = dword_10093F14[v2];
      LODWORD(v3) = dword_10093F10[v2];
      HIDWORD(v4) = dword_10093F0C[v2];
      LODWORD(v4) = dword_10093F08[v2];
      HIDWORD(v5) = dword_10093F04[v2];
      LODWORD(v5) = dword_10093F00[v2];
      v6 = sub_1000C870(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_10093F18[v2]],
             *(_DWORD *)&off_10093F1C[v2 * 4]);
      v7 = sub_1000FD70(0, dword_10093F18[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_10093F18[v2]],
             *(_DWORD *)&off_10093F1C[v2 * 4]);
      result = sub_1000CBD0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2623",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10093F00: using guessed type int dword_10093F00[];
// 10093F04: using guessed type int dword_10093F04[];
// 10093F08: using guessed type int dword_10093F08[];
// 10093F0C: using guessed type int dword_10093F0C[];
// 10093F10: using guessed type int dword_10093F10[];
// 10093F14: using guessed type int dword_10093F14[];
// 10093F18: using guessed type int dword_10093F18[];
// 10220935: using guessed type char byte_10220935;

//----- (100206C0) --------------------------------------------------------
char sub_100206C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2649", 2, 2);
      v3 = byte_10094482[v2 * 4];
      v4 = byte_10094481[v2 * 4];
      v5 = byte_10094480[v2 * 4];
      v6 = sub_1000C870(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_10094484[v2]],
             (&off_10094488)[v2 * 4]);
      v7 = sub_10010350(0, dword_10094484[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_10094484[v2]],
             (&off_10094488)[v2 * 4]);
      result = sub_1000CBD0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2649",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10094484: using guessed type int dword_10094484[];
// 10094488: using guessed type char *off_10094488;
// 10220935: using guessed type char byte_10220935;

//----- (10020820) --------------------------------------------------------
char sub_10020820()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2675", 2, 2);
      v3 = dword_10094698[v2];
      v4 = dword_10094694[v2];
      v5 = dword_10094690[v2];
      v6 = sub_1000C870(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_1009469C[v2]],
             (&off_100946A0)[v2 * 4]);
      v7 = sub_10010740(0, dword_1009469C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_1009469C[v2]],
             (&off_100946A0)[v2 * 4]);
      result = sub_1000CBD0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2675",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10094690: using guessed type int dword_10094690[];
// 10094694: using guessed type int dword_10094694[];
// 10094698: using guessed type int dword_10094698[];
// 1009469C: using guessed type int dword_1009469C[];
// 100946A0: using guessed type char *off_100946A0;
// 10220935: using guessed type char byte_10220935;

//----- (10020980) --------------------------------------------------------
char sub_10020980()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  char *v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_1000AE30(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"All Pass Robustness Test Group For Type 'bitmap'");
  v0 = sub_1000C760(0);
  sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2716", (int)v0);
  sub_1000AE30(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10220935 )
  {
    v2 = 0;
    do
    {
      if ( off_10094A04[v2] )
      {
        sub_1000C5D0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_10094A0C[v2 * 4], 0x100u, &v13);
        sub_1000C5D0((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_10094A04[v2], 0x100u, &v14);
        sub_10024CD0(&v14, &v13);
      }
      if ( byte_10094A00[v2 * 4] )
      {
        sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2741", 2, 2);
        v3 = off_10094A08[v2];
        v4 = *(char **)&off_10094A0C[v2 * 4];
        v5 = sub_1000C870(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10094A0C[v2 * 4],
               off_10094A08[v2]);
        v12 = 1;
        v11 = sub_10010EF0(
                1,
                0,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2745",
                (int)v5,
                (int)v4,
                (int)v3,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_eq_bitmap_rt() call";
        v9 = "2746";
      }
      else
      {
        sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2750", 2, 2);
        v6 = off_10094A08[v2];
        v7 = *(char **)&off_10094A0C[v2 * 4];
        v8 = sub_1000C870(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10094A0C[v2 * 4],
               off_10094A08[v2]);
        v12 = 1;
        v11 = sub_10010EF0(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2754",
                (int)v8,
                (int)v7,
                (int)v6,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_ne_bitmap_rt() call";
        v9 = "2755";
      }
      result = sub_1000CBD0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 4;
    }
    while ( v2 < 20 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2720",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10094A04: using guessed type char *off_10094A04[3];
// 10094A08: using guessed type char *off_10094A08[2];
// 10220935: using guessed type char byte_10220935;

//----- (10020B90) --------------------------------------------------------
char sub_10020B90()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000AE30(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_1000C760(0);
  sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2782", (int)v0);
  sub_1000AE30(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10220935 )
  {
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2790", 2, 2);
    v2 = sub_1000CBD0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2791",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1000CBD0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2792",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      0);
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2794", 2, 2);
    v3 = sub_1000CBD0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2795",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1000CBD0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2796",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      0);
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2798", 2, 2);
    v4 = sub_1000CBD0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2799",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1000CBD0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2800",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      0);
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2802", 2, 2);
    v5 = sub_1000CBD0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2803",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1000CBD0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2804",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2786",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10220935: using guessed type char byte_10220935;

//----- (10020D80) --------------------------------------------------------
char sub_10020D80()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      v0 = dword_10094A54[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2844", 2, 2);
        v3 = byte_10094A51[v2 * 4];
        v4 = byte_10094A50[v2 * 4];
        v5 = sub_1000C870(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10083F58[4 * dword_10094A54[v2]],
               (&off_10094A58)[v2 * 4]);
        v6 = sub_1000CD10(1, dword_10094A54[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v5, v4, v3, 0);
        v7 = sub_1000C870(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10083F58[4 * dword_10094A54[v2]],
               (&off_10094A58)[v2 * 4]);
        LOBYTE(v0) = sub_1000CBD0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1000AE30(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2844",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 10094A54: using guessed type int dword_10094A54[];
// 10094A58: using guessed type char *off_10094A58;
// 10220935: using guessed type char byte_10220935;

//----- (10020EF0) --------------------------------------------------------
char sub_10020EF0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2878", 2, 2);
      v3 = dbl_10094CD0[v2 / 2];
      v4 = dbl_10094CC8[v2 / 2];
      v5 = dbl_10094CC0[v2 / 2];
      v6 = sub_1000C870(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_10094CD8[v2]],
             *(_DWORD *)&off_10094CDC[v2 * 4]);
      v7 = sub_1000D0C0(1, dword_10094CD8[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_10094CD8[v2]],
             *(_DWORD *)&off_10094CDC[v2 * 4]);
      result = sub_1000CBD0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2878",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10094CC0: using guessed type double dbl_10094CC0[];
// 10094CC8: using guessed type double dbl_10094CC8[];
// 10094CD0: using guessed type double dbl_10094CD0[];
// 10094CD8: using guessed type int dword_10094CD8[];
// 10220935: using guessed type char byte_10220935;

//----- (10021060) --------------------------------------------------------
char sub_10021060()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2914", 2, 2);
      v3 = flt_100958E8[v2];
      v4 = flt_100958E4[v2];
      v5 = flt_100958E0[v2];
      v6 = sub_1000C870(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_100958EC[v2]],
             (&off_100958F0)[v2 * 4]);
      v7 = sub_1000D510(1, dword_100958EC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_100958EC[v2]],
             (&off_100958F0)[v2 * 4]);
      result = sub_1000CBD0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2914",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100958E0: using guessed type float flt_100958E0[];
// 100958E4: using guessed type float flt_100958E4[];
// 100958E8: using guessed type float flt_100958E8[];
// 100958EC: using guessed type int dword_100958EC[];
// 100958F0: using guessed type char *off_100958F0;
// 10220935: using guessed type char byte_10220935;

//----- (100211C0) --------------------------------------------------------
char sub_100211C0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1000AE30(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1000C760(0);
  sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2936", (int)v0);
  sub_1000AE30(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10220935 )
  {
    sub_100111F0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2944",
      (int)"Check ptr for equality",
      (int)sub_100211C0,
      (int)sub_100211C0,
      0);
    sub_100111F0(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2945",
      (int)"Check ptr for inequality",
      (int)sub_100211C0,
      0,
      0);
    result = sub_100111F0(
               1,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2946",
               (int)"Check ptr for inequality",
               0,
               (int)sub_100211C0,
               0);
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2940",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10220935: using guessed type char byte_10220935;

//----- (100212B0) --------------------------------------------------------
char sub_100212B0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2973", 2, 2);
      v3 = dword_10096080[v2];
      v4 = dword_1009607C[v2];
      v5 = dword_10096078[v2];
      v6 = sub_1000C870(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_10096084[v2]],
             *(_DWORD *)&off_10096088[v2 * 4]);
      v7 = sub_1000D9D0(1, dword_10096084[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_10096084[v2]],
             *(_DWORD *)&off_10096088[v2 * 4]);
      result = sub_1000CBD0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2973",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10096078: using guessed type int dword_10096078[];
// 1009607C: using guessed type int dword_1009607C[];
// 10096080: using guessed type int dword_10096080[];
// 10096084: using guessed type int dword_10096084[];
// 10220935: using guessed type char byte_10220935;

//----- (10021410) --------------------------------------------------------
char sub_10021410()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"2999", 2, 2);
      v3 = word_10096814[v2 / 2];
      v4 = word_10096812[v2 / 2];
      v5 = word_10096810[v2 / 2];
      v6 = sub_1000C870(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_10096818[v2 / 4]],
             *(_DWORD *)&off_1009681C[v2]);
      v7 = sub_1000DD90(
             1,
             dword_10096818[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2999",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_10096818[v2 / 4]],
             *(_DWORD *)&off_1009681C[v2]);
      result = sub_1000CBD0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2999",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10096810: using guessed type __int16 word_10096810[];
// 10096812: using guessed type __int16 word_10096812[];
// 10096814: using guessed type __int16 word_10096814[];
// 10096818: using guessed type int dword_10096818[];
// 10220935: using guessed type char byte_10220935;

//----- (10021570) --------------------------------------------------------
char sub_10021570()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"3025", 2, 2);
      v3 = dword_10096E28[v2];
      v4 = dword_10096E24[v2];
      v5 = dword_10096E20[v2];
      v6 = sub_1000C870(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_10096E2C[v2]],
             (&off_10096E30)[v2 * 4]);
      v7 = sub_1000E190(1, dword_10096E2C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_10096E2C[v2]],
             (&off_10096E30)[v2 * 4]);
      result = sub_1000CBD0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3025",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10096E20: using guessed type int dword_10096E20[];
// 10096E24: using guessed type int dword_10096E24[];
// 10096E28: using guessed type int dword_10096E28[];
// 10096E2C: using guessed type int dword_10096E2C[];
// 10096E30: using guessed type char *off_10096E30;
// 10220935: using guessed type char byte_10220935;

//----- (100216D0) --------------------------------------------------------
char sub_100216D0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"3051", 2, 2);
      HIDWORD(v3) = dword_100975CC[v2];
      LODWORD(v3) = dword_100975C8[v2];
      HIDWORD(v4) = dword_100975C4[v2];
      LODWORD(v4) = dword_100975C0[v2];
      HIDWORD(v5) = dword_100975BC[v2];
      LODWORD(v5) = dword_100975B8[v2];
      v6 = sub_1000C870(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_100975D0[v2]],
             *(_DWORD *)&off_100975D4[v2 * 4]);
      v7 = sub_1000E550(1, dword_100975D0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_100975D0[v2]],
             *(_DWORD *)&off_100975D4[v2 * 4]);
      result = sub_1000CBD0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3051",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100975B8: using guessed type int dword_100975B8[];
// 100975BC: using guessed type int dword_100975BC[];
// 100975C0: using guessed type int dword_100975C0[];
// 100975C4: using guessed type int dword_100975C4[];
// 100975C8: using guessed type int dword_100975C8[];
// 100975CC: using guessed type int dword_100975CC[];
// 100975D0: using guessed type int dword_100975D0[];
// 10220935: using guessed type char byte_10220935;

//----- (10021840) --------------------------------------------------------
char sub_10021840()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"3077", 2, 2);
      v3 = byte_100981DA[v2 * 4];
      v4 = byte_100981D9[v2 * 4];
      v5 = byte_100981D8[v2 * 4];
      v6 = sub_1000C870(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_100981DC[v2]],
             (&off_100981E0)[v2 * 4]);
      v7 = sub_1000EA90(1, dword_100981DC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_100981DC[v2]],
             (&off_100981E0)[v2 * 4]);
      result = sub_1000CBD0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3077",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100981DC: using guessed type int dword_100981DC[];
// 100981E0: using guessed type char *off_100981E0;
// 10220935: using guessed type char byte_10220935;

//----- (100219A0) --------------------------------------------------------
char sub_100219A0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"3103", 2, 2);
      v3 = dword_10098670[v2];
      v4 = dword_1009866C[v2];
      v5 = dword_10098668[v2];
      v6 = sub_1000C870(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_10098674[v2]],
             *(_DWORD *)&off_10098678[v2 * 4]);
      v7 = sub_1000EE70(1, dword_10098674[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_10098674[v2]],
             *(_DWORD *)&off_10098678[v2 * 4]);
      result = sub_1000CBD0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3103",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10098668: using guessed type int dword_10098668[];
// 1009866C: using guessed type int dword_1009866C[];
// 10098670: using guessed type int dword_10098670[];
// 10098674: using guessed type int dword_10098674[];
// 10220935: using guessed type char byte_10220935;

//----- (10021B00) --------------------------------------------------------
char sub_10021B00()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000AE30(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_1000C760(0);
  sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3127", (int)v0);
  sub_1000AE30(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10220935 )
  {
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"3135", 2, 2);
    v2 = sub_100112A0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3136",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"\" ) data comparison",
           (const char *)&unk_1005C3FD,
           (const char *)&unk_1005C3FD,
           0);
    sub_1000CBD0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3137",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"3139", 2, 2);
    v3 = sub_100112A0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3140",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1000CBD0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3141",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"3143", 2, 2);
    v4 = sub_100112A0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3144",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_1005C3FD,
           0);
    sub_1000CBD0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3145",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"3147", 2, 2);
    v5 = sub_100112A0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3148",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1000CBD0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3149",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3131",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10220935: using guessed type char byte_10220935;

//----- (10021D00) --------------------------------------------------------
char sub_10021D00()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"3176", 2, 2);
      v3 = dword_10098E08[v2];
      v4 = dword_10098E04[v2];
      v5 = dword_10098E00[v2];
      v6 = sub_1000C870(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_10098E0C[v2]],
             (&off_10098E10)[v2 * 4]);
      v7 = sub_1000F230(1, dword_10098E0C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_10098E0C[v2]],
             (&off_10098E10)[v2 * 4]);
      result = sub_1000CBD0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3176",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10098E00: using guessed type int dword_10098E00[];
// 10098E04: using guessed type int dword_10098E04[];
// 10098E08: using guessed type int dword_10098E08[];
// 10098E0C: using guessed type int dword_10098E0C[];
// 10098E10: using guessed type char *off_10098E10;
// 10220935: using guessed type char byte_10220935;

//----- (10021E60) --------------------------------------------------------
char sub_10021E60()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"3202", 2, 2);
      v3 = word_10099174[v2 / 2];
      v4 = word_10099172[v2 / 2];
      v5 = word_10099170[v2 / 2];
      v6 = sub_1000C870(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_10099178[v2 / 4]],
             *(_DWORD *)&off_1009917C[v2]);
      v7 = sub_1000F5D0(
             1,
             dword_10099178[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"3202",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_10099178[v2 / 4]],
             *(_DWORD *)&off_1009917C[v2]);
      result = sub_1000CBD0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3202",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10099170: using guessed type __int16 word_10099170[];
// 10099172: using guessed type __int16 word_10099172[];
// 10099174: using guessed type __int16 word_10099174[];
// 10099178: using guessed type int dword_10099178[];
// 10220935: using guessed type char byte_10220935;

//----- (10021FC0) --------------------------------------------------------
char sub_10021FC0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"3228", 2, 2);
      v3 = dword_10099438[v2];
      v4 = dword_10099434[v2];
      v5 = dword_10099430[v2];
      v6 = sub_1000C870(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_1009943C[v2]],
             (&off_10099440)[v2 * 4]);
      v7 = sub_1000F9D0(1, dword_1009943C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_1009943C[v2]],
             (&off_10099440)[v2 * 4]);
      result = sub_1000CBD0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3228",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10099430: using guessed type int dword_10099430[];
// 10099434: using guessed type int dword_10099434[];
// 10099438: using guessed type int dword_10099438[];
// 1009943C: using guessed type int dword_1009943C[];
// 10099440: using guessed type char *off_10099440;
// 10220935: using guessed type char byte_10220935;

//----- (10022120) --------------------------------------------------------
char sub_10022120()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"3254", 2, 2);
      HIDWORD(v3) = dword_100997B4[v2];
      LODWORD(v3) = dword_100997B0[v2];
      HIDWORD(v4) = dword_100997AC[v2];
      LODWORD(v4) = dword_100997A8[v2];
      HIDWORD(v5) = dword_100997A4[v2];
      LODWORD(v5) = dword_100997A0[v2];
      v6 = sub_1000C870(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_100997B8[v2]],
             *(_DWORD *)&off_100997BC[v2 * 4]);
      v7 = sub_1000FD70(1, dword_100997B8[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_100997B8[v2]],
             *(_DWORD *)&off_100997BC[v2 * 4]);
      result = sub_1000CBD0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3254",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100997A0: using guessed type int dword_100997A0[];
// 100997A4: using guessed type int dword_100997A4[];
// 100997A8: using guessed type int dword_100997A8[];
// 100997AC: using guessed type int dword_100997AC[];
// 100997B0: using guessed type int dword_100997B0[];
// 100997B4: using guessed type int dword_100997B4[];
// 100997B8: using guessed type int dword_100997B8[];
// 10220935: using guessed type char byte_10220935;

//----- (10022290) --------------------------------------------------------
char sub_10022290()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"3280", 2, 2);
      v3 = byte_10099D22[v2 * 4];
      v4 = byte_10099D21[v2 * 4];
      v5 = byte_10099D20[v2 * 4];
      v6 = sub_1000C870(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_10099D24[v2]],
             (&off_10099D28)[v2 * 4]);
      v7 = sub_10010350(1, dword_10099D24[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_10099D24[v2]],
             (&off_10099D28)[v2 * 4]);
      result = sub_1000CBD0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3280",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10099D24: using guessed type int dword_10099D24[];
// 10099D28: using guessed type char *off_10099D28;
// 10220935: using guessed type char byte_10220935;

//----- (100223F0) --------------------------------------------------------
char sub_100223F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10220935 )
  {
    sub_1000AE30(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_1000C760(0);
    sub_1000AE30(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v1);
    sub_1000AE30(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1000C850(0);
    v2 = 0;
    do
    {
      sub_1000C780((int)"..\\lib\\utf\\utf_validate.c", (int)"3306", 2, 2);
      v3 = dword_10099F38[v2];
      v4 = dword_10099F34[v2];
      v5 = dword_10099F30[v2];
      v6 = sub_1000C870(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10083F58[4 * dword_10099F3C[v2]],
             (&off_10099F40)[v2 * 4]);
      v7 = sub_10010740(1, dword_10099F3C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000C870(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10083F58[4 * dword_10099F3C[v2]],
             (&off_10099F40)[v2 * 4]);
      result = sub_1000CBD0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1000AE30(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3306",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10099F30: using guessed type int dword_10099F30[];
// 10099F34: using guessed type int dword_10099F34[];
// 10099F38: using guessed type int dword_10099F38[];
// 10099F3C: using guessed type int dword_10099F3C[];
// 10099F40: using guessed type char *off_10099F40;
// 10220935: using guessed type char byte_10220935;

//----- (10022550) --------------------------------------------------------
char **sub_10022550()
{
  return off_10085644;
}
// 10085644: using guessed type char *off_10085644[3];

//----- (10022560) --------------------------------------------------------
char __cdecl sub_10022560(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  if ( a1 >= 0x319u )
  {
    sub_10011520("..\\lib\\acl\\iop\\dscrt\\iop_dscrt_data_tbl_utl.c", 115, 0, 0);
    return 0;
  }
  if ( a2 >= 3u )
    return 0;
  *a3 = byte_100AA298[8 * a1];
  *a4 = word_100AA29A[a2 + 4 * a1];
  return 1;
}
// 100AA29A: using guessed type __int16 word_100AA29A[];

//----- (100225C0) --------------------------------------------------------
char __cdecl sub_100225C0(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  if ( a1 >= 0x145u )
  {
    sub_10011520("..\\lib\\acl\\iop\\dscrt\\iop_dscrt_data_tbl_utl.c", 320, 0, 0);
    return 0;
  }
  if ( a2 >= 3u )
    return 0;
  *a3 = byte_100ABB60[16 * a1];
  *a4 = word_100ABB68[a2 + 8 * a1];
  return 1;
}
// 100ABB68: using guessed type __int16 word_100ABB68[];

//----- (10022620) --------------------------------------------------------
int sub_10022620()
{
  int result; // eax@1

  result = 0;
  dword_10220938 = -15;
  dword_1025441C = 0;
  dword_10254410 = 0;
  dword_10254414 = 0;
  dword_10254418 = 0;
  return result;
}
// 10220938: using guessed type int dword_10220938;
// 10254410: using guessed type int dword_10254410;
// 10254414: using guessed type int dword_10254414;
// 10254418: using guessed type int dword_10254418;
// 1025441C: using guessed type int dword_1025441C;

//----- (10022650) --------------------------------------------------------
char sub_10022650()
{
  char v0; // bl@1
  signed int v1; // esi@2
  char result; // al@4

  v0 = sub_100335F0((int)&off_1009DFA4);
  if ( v0 )
  {
    dword_1025441C = dword_10220938;
    v1 = *(_BYTE *)(dword_10220938 + 667) != 0 ? 1100 : 2000;
    if ( v1 + *(_DWORD *)(dword_1025441C + 36) < (unsigned int)sub_10032ED0() )
      v0 = 0;
    dword_10254418 = dword_10220938 + 56116;
    result = v0;
    dword_10254410 = dword_10220938 + 1516;
    dword_10254414 = dword_10220938 + 20484;
  }
  else
  {
    dword_1025441C = 0;
    dword_10254410 = 0;
    dword_10254414 = 0;
    dword_10254418 = 0;
    result = 0;
  }
  return result;
}
// 1009DFA4: using guessed type char *off_1009DFA4;
// 10220938: using guessed type int dword_10220938;
// 10254410: using guessed type int dword_10254410;
// 10254414: using guessed type int dword_10254414;
// 10254418: using guessed type int dword_10254418;
// 1025441C: using guessed type int dword_1025441C;

//----- (10022700) --------------------------------------------------------
signed int sub_10022700()
{
  return 1000;
}

//----- (10022720) --------------------------------------------------------
int sub_10022720()
{
  return sub_100229B0((int)off_1009E4E0);
}
// 1009E4E0: using guessed type int (*off_1009E4E0[4])();

//----- (10022730) --------------------------------------------------------
void sub_10022730()
{
  dword_10254408 = -15;
}
// 10254408: using guessed type int dword_10254408;

//----- (10022740) --------------------------------------------------------
signed int sub_10022740()
{
  return sub_100335F0((int)&off_1009E508);
}
// 1009E508: using guessed type char *off_1009E508;

//----- (10022750) --------------------------------------------------------
void sub_10022750()
{
  dword_1022093C = -15;
}
// 1022093C: using guessed type int dword_1022093C;

//----- (10022770) --------------------------------------------------------
signed int sub_10022770()
{
  return sub_100335F0((int)&off_1009E578);
}
// 1009E578: using guessed type char *off_1009E578;

//----- (10022780) --------------------------------------------------------
int sub_10022780()
{
  return (unsigned __int8)sub_10022770() != 0 ? dword_1022093C : 0;
}
// 1022093C: using guessed type int dword_1022093C;

//----- (10022790) --------------------------------------------------------
int sub_10022790()
{
  int result; // eax@2

  if ( (unsigned __int8)sub_10022770() )
    result = dword_1022093C + 55656;
  else
    result = 0;
  return result;
}
// 1022093C: using guessed type int dword_1022093C;

//----- (100227B0) --------------------------------------------------------
void sub_100227B0()
{
  dword_10254404 = -15;
}
// 10254404: using guessed type int dword_10254404;

//----- (100227C0) --------------------------------------------------------
char __cdecl sub_100227C0(unsigned __int8 a1)
{
  void *v1; // ecx@0
  char v2; // al@1
  int v3; // eax@1
  char result; // al@2
  char v5[68]; // [sp+0h] [bp-48h]@1

  v2 = sub_1001A5F0(v1);
  v3 = sub_1001A440(v2);
  if ( sub_10032AE0(v3, (int)v5, 67) )
    result = 0;
  else
    result = v5[a1];
  return result;
}
// 100227C0: using guessed type char var_48[68];

//----- (10022820) --------------------------------------------------------
signed int sub_10022820()
{
  return sub_100335F0((int)&off_1009E5AC);
}
// 1009E5AC: using guessed type char *off_1009E5AC;

//----- (10022830) --------------------------------------------------------
char __usercall sub_10022830@<al>(unsigned __int8 a1@<al>, char a2, void *a3)
{
  unsigned __int8 v3; // bl@1
  char result; // al@7

  v3 = a1;
  if ( (unsigned __int8)(a1 - 53) > 0xDu
    || (unsigned __int8)a2 >= 3u
    || !(unsigned __int8)sub_10022820()
    || sub_10032F80(33, 10) )
  {
    sub_10011520("..\\lib\\adl\\iop_data.c", 366, 0, 0);
    result = 0;
  }
  else if ( (unsigned int)(sub_10032ED0()
                         - *(_DWORD *)(dword_10254404 + 4 * (v3 - 33 + (unsigned __int8)a2 + 2 * (v3 - 33)))) <= 0x258
         && *(_BYTE *)(v3 + (unsigned __int8)a2 + 2 * v3 + dword_10254404 + 37) )
  {
    memcpy(
      a3,
      (const void *)(dword_10254404 + 4 * (v3 - 53 + (unsigned __int8)a2 + 2 * (v3 - 53))),
      *(_WORD *)(dword_10254404 + 2 * v3 + 62));
    sub_10032F60(33);
    result = 1;
  }
  else
  {
    sub_10032F60(33);
    result = 0;
  }
  return result;
}
// 10254404: using guessed type int dword_10254404;

//----- (10022910) --------------------------------------------------------
char __cdecl sub_10022910(int a1, char a2, void *a3)
{
  char result; // al@1
  int v4; // eax@4
  int v5; // esi@6
  int v6; // edi@7

  result = 0;
  if ( (unsigned __int8)a1 < 0x43u && (unsigned __int8)a2 < 3u )
  {
    if ( (unsigned __int8)a1 > 0x34u )
    {
      result = sub_10022830(a1, a2, a3);
    }
    else
    {
      v4 = sub_1002F430(a1);
      if ( v4
        && (v5 = v4 + 4 * (unsigned __int8)a2, *(_BYTE *)v5 < 7)
        && (v6 = *(_WORD *)(v5 + 2), (unsigned __int16)v6 < (unsigned __int16)sub_10011590(*(_BYTE *)v5)) )
      {
        result = sub_10012260(*(_BYTE *)v5, v6, a3);
      }
      else
      {
        result = 0;
      }
    }
  }
  return result;
}
// 1002F430: using guessed type _DWORD __cdecl sub_1002F430(char);

//----- (10022990) --------------------------------------------------------
char __cdecl sub_10022990(int a1, void *a2)
{
  char v2; // al@1

  v2 = sub_100227C0(a1);
  return sub_10022910(a1, v2, a2);
}

//----- (100229B0) --------------------------------------------------------
int __cdecl sub_100229B0(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10220940 = *(_DWORD *)a1;
  dword_10220944 = *(_DWORD *)(a1 + 4);
  dword_10220948 = *(_DWORD *)(a1 + 8);
  dword_1022094C = *(_DWORD *)(a1 + 12);
  dword_10254400 = (int)&dword_10220940;
  return result;
}
// 10220940: using guessed type int dword_10220940;
// 10220944: using guessed type int dword_10220944;
// 10220948: using guessed type int dword_10220948;
// 1022094C: using guessed type int dword_1022094C;
// 10254400: using guessed type int dword_10254400;

//----- (100229F0) --------------------------------------------------------
char *__cdecl sub_100229F0(char **a1)
{
  char *v1; // edx@1
  int v2; // edi@1
  char *result; // eax@1
  char *v4; // eax@3
  char v5; // cl@4
  int v6; // eax@5
  char v7; // cl@7

  v1 = *a1;
  v2 = 0;
  result = (char *)&unk_1005C3FD;
  if ( *a1 && *v1 )
  {
    v4 = *a1;
    do
      v5 = *v4++;
    while ( v5 );
    v6 = v4 - (v1 + 1) - 1;
    do
    {
      if ( v6 < 0 )
        break;
      v7 = v1[v6];
      if ( v7 == 47 || v7 == 92 )
        v2 = v6 + 1;
      --v6;
    }
    while ( !v2 );
    result = &v1[v2];
  }
  return result;
}

//----- (10022A40) --------------------------------------------------------
int sub_10022A40()
{
  int v0; // esi@1
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@2

  v0 = 0;
  v1 = sub_10032E30();
  result = 0;
  while ( 1 )
  {
    v3 = dword_10220964[result];
    if ( v3 == v1 )
      break;
    if ( !v0 && v3 == -1 )
      v0 = result;
    if ( (unsigned int)++result >= 5 )
    {
      dword_10220964[v0] = v1;
      return v0;
    }
  }
  return result;
}
// 10220964: using guessed type int dword_10220964[];

//----- (10022A80) --------------------------------------------------------
int __cdecl sub_10022A80(_BYTE *a1, int a2)
{
  int result; // eax@3
  int v3; // esi@3
  _BYTE *v4; // ecx@4
  char v5; // dl@5

  if ( a1 )
  {
    if ( a2 )
    {
      result = 0;
      v3 = 0;
      if ( *a1 )
      {
        v4 = a1;
        do
        {
          v5 = v4[a2 - (_DWORD)a1];
          if ( !v5 )
            break;
          if ( *v4 != v5 )
          {
            result = a1[v3] - *(_BYTE *)(v3 + a2);
            if ( a1[v3] != *(_BYTE *)(v3 + a2) )
              return result;
            break;
          }
          ++v4;
          ++v3;
        }
        while ( *v4 );
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(v3 + a2) )
      {
        result = -1;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10022AF0) --------------------------------------------------------
signed int __cdecl sub_10022AF0(_BYTE *a1, int a2)
{
  _BYTE *v2; // esi@1
  int v3; // ebp@1
  int v4; // ebx@4
  int v5; // edi@6
  int v6; // eax@6
  signed int result; // eax@11
  int v8; // [sp+8h] [bp-4h]@3

  v2 = a1;
  v3 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v8 = 0;
      if ( *a1 )
      {
        v4 = a2 - (_DWORD)a1;
        while ( v2[v4] )
        {
          v5 = tolower(*v2);
          v6 = tolower(v2[v4]);
          if ( v5 != v6 )
          {
            v8 = v5 - v6;
            if ( v5 != v6 )
              goto LABEL_16;
            break;
          }
          ++v2;
          ++v3;
          if ( !*v2 )
            break;
        }
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(a2 + v3) )
      {
        result = -1;
      }
      else
      {
LABEL_16:
        result = v8;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10022B90) --------------------------------------------------------
int __usercall sub_10022B90@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>)
{
  int result; // eax@5

  if ( a1 && *a1 )
  {
    if ( a2 && *a2 )
      result = 3 - (sub_10022AF0(a2, (int)a1) != 0);
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10022BC0) --------------------------------------------------------
signed int __usercall sub_10022BC0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5)
{
  int v5; // ebp@1
  int v6; // edi@1
  signed int result; // eax@2
  const char *v8; // [sp-8h] [bp-18h]@11
  int v9; // [sp-4h] [bp-14h]@11
  int v10; // [sp+8h] [bp-8h]@14
  int v11; // [sp+Ch] [bp-4h]@17
  signed int v12; // [sp+14h] [bp+4h]@3

  v5 = a4;
  v6 = 0;
  *(_DWORD *)a4 = a1;
  switch ( a1 )
  {
    case 0:
      sprintf(a5, "Too many arguments for command");
      result = 8;
      break;
    case 1:
      v12 = 9;
      while ( sub_10022AF0((_BYTE *)a3, (int)(&off_1009ED40)[8 * v6]) )
      {
        if ( (unsigned int)++v6 >= 0xD )
        {
          sprintf(a5, "Error converting '%s' to a boolean", a3);
          goto LABEL_25;
        }
      }
      ++*a2;
      result = 0;
      *(_BYTE *)(v5 + 4) = byte_1009ED44[8 * v6];
      break;
    case 2:
      if ( !*(_BYTE *)a3 || *(_BYTE *)(a3 + 1) )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a char";
        goto LABEL_12;
      }
      *(_BYTE *)(a4 + 4) = *(_BYTE *)a3;
      result = 0;
      break;
    case 3:
      if ( sub_10037E8E(a3, (int)&unk_1005E0A8, (unsigned int)&v10) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a sint32";
        goto LABEL_12;
      }
      *(_DWORD *)(a4 + 4) = v10;
      ++*a2;
      result = 0;
      break;
    case 4:
      if ( sub_10037E8E(a3, (int)&unk_1005E0AC, (unsigned int)&v11) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a uint32";
LABEL_12:
        sprintf(a5, v8, v9);
        goto LABEL_13;
      }
      *(_DWORD *)(a4 + 4) = v11;
      ++*a2;
      result = 0;
      break;
    case 6:
      if ( sub_10037E8E(a3, (int)"%f", a4 + 4) == 1 )
        goto LABEL_23;
      sprintf(a5, "Error converting '%s' to a float", a3);
LABEL_13:
      result = 9;
      break;
    case 5:
      strncpy((char *)(a4 + 4), (const char *)a3, 0x50u);
LABEL_23:
      ++*a2;
      result = 0;
      break;
    default:
      v12 = 9;
      *(_DWORD *)v5 = 0;
      sprintf(a5, "Command definition error: Unsupported argument type (%d)", a1);
LABEL_25:
      result = v12;
      break;
  }
  return result;
}
// 1009ED40: using guessed type char *off_1009ED40;

//----- (10022D90) --------------------------------------------------------
char *__usercall sub_10022D90@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>)
{
  if ( a2 )
  {
    if ( (_BYTE)result && *(_BYTE *)a3 )
    {
      if ( *a2 )
      {
        strncat((char *)a3, word_1005E650, 0x100u);
        result = strncat((char *)a3, a2, 0x100u);
        *(_BYTE *)(a3 + 255) = 0;
        return result;
      }
    }
    else
    {
      result = strncpy((char *)a3, a2, 0x100u);
    }
    *(_BYTE *)(a3 + 255) = 0;
  }
  else if ( !(_BYTE)result )
  {
    *(_BYTE *)a3 = 0;
  }
  return result;
}

//----- (10022DF0) --------------------------------------------------------
int __usercall sub_10022DF0@<eax>(int a1@<esi>, int a2, _DWORD *a3)
{
  unsigned int v3; // edi@4
  int v4; // ebx@5
  int v5; // eax@6
  int result; // eax@9
  int v7; // ecx@10

  if ( a1 && *(_DWORD *)(a1 + 8) && *(_BYTE *)(80 * *a3 + a2) )
  {
    v3 = 0;
    if ( *(_DWORD *)(a1 + 12) <= 0u )
    {
      result = 0;
    }
    else
    {
      v4 = 0;
      while ( 1 )
      {
        v5 = v4 + *(_DWORD *)(a1 + 8);
        if ( *(_DWORD *)(v5 + 12) < 2u && !sub_10022AF0((_BYTE *)(a2 + 80 * *a3), *(_DWORD *)v5) )
          break;
        ++v3;
        v4 += 40;
        if ( v3 >= *(_DWORD *)(a1 + 12) )
          return 0;
      }
      v7 = *(_DWORD *)(a1 + 8);
      ++*a3;
      result = v7 + 40 * v3;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10022E80) --------------------------------------------------------
int __usercall sub_10022E80@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4)
{
  int v4; // edi@1
  unsigned int v5; // ebp@1
  int v6; // esi@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  do
  {
    if ( v5 >= a3 )
      break;
    if ( *(_DWORD *)(v6 + 12) >= 2u && sub_10022B90(*(_BYTE **)v6, (_BYTE *)(a4 + 80 * *a2)) == 3 )
    {
      ++*a2;
      v4 = v6;
    }
    ++v5;
    v6 += 40;
  }
  while ( !v4 );
  return v4;
}

//----- (10022ED0) --------------------------------------------------------
char **__usercall sub_10022ED0@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3)
{
  char **result; // eax@1
  int v4; // edi@1
  int (**v5)(void); // eax@2
  char **v6; // eax@3
  char **v7; // esi@3
  char *v8; // eax@3

  result = 0;
  v4 = 0;
  if ( *a1 )
  {
    v5 = a1;
    while ( 1 )
    {
      v6 = (char **)(*v5)();
      v7 = v6;
      v8 = sub_100229F0(v6);
      if ( !sub_10022AF0((_BYTE *)(a2 + 80 * *a3), (int)v8) )
        break;
      v5 = &a1[++v4];
      if ( !a1[v4] )
        return 0;
    }
    ++*a3;
    result = v7;
  }
  return result;
}

//----- (10022F30) --------------------------------------------------------
const char *__usercall sub_10022F30@<eax>(int a1@<eax>)
{
  const char *result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
      result = "Group";
    else
      result = "Command";
  }
  else
  {
    result = "Case";
  }
  return result;
}

//----- (10022F50) --------------------------------------------------------
int __usercall sub_10022F50@<eax>(unsigned int a1@<ebx>)
{
  int (**v1)(void); // esi@1
  unsigned int v2; // edi@1
  int result; // eax@4

  v1 = (int (**)(void))dword_10220950[sub_10022A40()];
  v2 = 0;
  if ( a1 )
  {
    while ( v1 && *v1 )
    {
      result = (*v1)();
      ++v2;
      ++v1;
      if ( v2 >= a1 )
        return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10220950: using guessed type int dword_10220950[];

//----- (10022F90) --------------------------------------------------------
int __usercall sub_10022F90@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5)
{
  signed int *v5; // ebx@1
  int result; // eax@1
  _DWORD *v7; // edi@2
  int *v8; // ebp@2
  _BYTE *v9; // esi@4
  signed int v10; // ebx@9
  signed int v11; // [sp+8h] [bp-4h]@2

  v5 = a1;
  result = 0;
  if ( a3 )
  {
    v7 = a2;
    v8 = (int *)(a3 + 16);
    v11 = 5;
    do
    {
      if ( result || (v9 = (_BYTE *)(80 * *v5 + a4), !*v9) )
        *v7 = 0;
      else
        result = sub_10022BC0(*v8, v5, (int)v9, (int)v7, a5);
      ++v8;
      v7 += 21;
      --v11;
    }
    while ( v11 );
    if ( !result )
    {
      v10 = *v5;
      if ( v10 < 5 )
      {
        if ( *(_DWORD *)(a3 + 4 * v10 + 16) )
        {
          sprintf(a5, "Missing required command argument");
          result = 7;
        }
      }
    }
  }
  return result;
}

//----- (10023020) --------------------------------------------------------
int __usercall sub_10023020@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4)
{
  int v4; // ebx@1
  signed int v5; // edx@1
  _BYTE *v6; // edi@1
  signed int v7; // ebp@1
  signed int v8; // ecx@1
  int v9; // ecx@3
  char v10; // al@4
  signed int v11; // edi@21
  int result; // eax@27
  char v13; // [sp+Fh] [bp-9h]@1
  signed int v14; // [sp+10h] [bp-8h]@1
  int v15; // [sp+14h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  v14 = 3;
  v15 = 0;
  v7 = 0;
  v13 = 0;
  *a2 = 0;
  v8 = 9;
  do
  {
    *a1 = 0;
    a1 += 80;
    --v8;
  }
  while ( v8 );
  v9 = a3;
  if ( !*(_BYTE *)a3 )
    return 3;
  while ( 1 )
  {
    v10 = *(_BYTE *)(v4 + v9);
    if ( v13 )
    {
      if ( v13 != v10 )
        goto LABEL_15;
      v13 = 0;
LABEL_18:
      v9 = a3;
      goto LABEL_19;
    }
    if ( v10 != 34 && v10 != 39 )
      break;
    v13 = *(_BYTE *)(v4 + v9);
LABEL_19:
    if ( !*(_BYTE *)(++v4 + v9) )
      goto LABEL_23;
  }
  if ( v10 == 32 || v10 == 9 )
  {
    if ( v7 )
    {
      ++*a2;
      v7 = 0;
      v5 = 0;
    }
    v15 = v4;
    goto LABEL_19;
  }
LABEL_15:
  if ( *a2 >= 8 )
  {
    v11 = 5;
    sprintf(a4, "Too many parameters. Maximum of %d parameters supported.", 8);
    goto LABEL_24;
  }
  if ( v5 < 80 )
  {
    *(&v6[80 * *a2] + v5) = v10;
    v7 = 1;
    ++v5;
    v14 = 0;
    *(&v6[80 * *a2] + v5) = 0;
    goto LABEL_18;
  }
  v14 = 6;
  sprintf(a4, "Parameter too long (starting at %s). Maximum parameter length supported is %d.", v15 + a3 + 1, 80);
LABEL_23:
  v11 = v14;
LABEL_24:
  if ( v7 )
  {
    if ( !v13 )
    {
      ++*a2;
      goto LABEL_27;
    }
    sprintf(a4, "Parameter %d missing closing quote", *a2);
    result = 6;
  }
  else
  {
LABEL_27:
    result = v11;
  }
  return result;
}

//----- (10023170) --------------------------------------------------------
int __usercall sub_10023170@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>)
{
  _DWORD *v3; // edi@1
  int result; // eax@1
  int v5; // ecx@2
  int v6; // eax@4
  int v7; // edi@4
  int v8; // edi@7

  v3 = a1;
  result = 0;
  if ( a3 )
  {
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        sub_1000ADB0(5, *(_DWORD *)a3);
        v6 = (*(int (**)(void))(a3 + 8))();
        sub_10023A50(v3, v6, 0);
        v7 = -*v3;
        sub_1000ADB0(9, *(_DWORD *)a3);
        result = v7;
      }
    }
    else
    {
      sub_1000ADB0(6, *(_DWORD *)a3);
      if ( a2 )
        a2(5, &unk_1009E9F8);
      sub_1002F440(a3);
      v8 = -*v3;
      if ( a2 )
        a2(6, &unk_1009E9F8);
      sub_1000ADB0(8, *(_DWORD *)a3);
      result = v8;
    }
  }
  return result;
}

//----- (10023210) --------------------------------------------------------
int __usercall sub_10023210@<eax>(int result@<eax>)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_BYTE *)(result + 33) = 0;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 24) = 1;
  *(_BYTE *)(result + 32) = 1;
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 52) = 0;
  return result;
}

//----- (10023250) --------------------------------------------------------
char *__cdecl sub_10023250(int a1, char *a2, int a3, const char *a4)
{
  const char *v4; // ecx@0
  const char *v5; // ebx@1
  char *v6; // eax@1
  char *v7; // ecx@1
  char *result; // eax@3
  char *v9; // eax@5
  const char *v10; // edi@5
  const char **v11; // ebx@8
  char *v12; // eax@10
  const char *v13; // edi@10
  char **v14; // ebp@10
  const char *v15; // edi@12
  char *v16; // [sp+10h] [bp-624h]@8
  signed int v17; // [sp+14h] [bp-620h]@10
  int v18[6]; // [sp+18h] [bp-61Ch]@2
  char v19; // [sp+30h] [bp-604h]@1
  char v20; // [sp+130h] [bp-504h]@5
  char v21; // [sp+230h] [bp-404h]@7
  char v22; // [sp+330h] [bp-304h]@10
  char v23; // [sp+430h] [bp-204h]@10
  char v24; // [sp+530h] [bp-104h]@10

  v5 = v4;
  v6 = 0;
  v7 = &v19;
  do
  {
    v18[(signed int)v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( (unsigned int)v6 < 6 );
  LOBYTE(v6) = 0;
  result = sub_10022D90(v6, "command", (int)&v19);
  if ( a3 )
  {
    LOBYTE(result) = 0;
    if ( a4 )
    {
      v9 = sub_10022D90(result, a4, (int)&v20);
      v10 = v5;
    }
    else
    {
      v9 = sub_10022D90(result, v5, (int)&v20);
      v10 = (const char *)&unk_1005C3FD;
    }
    LOBYTE(v9) = 0;
    sub_10022D90(v9, v10, (int)&v21);
    result = a2;
    if ( a2 )
    {
      v11 = (const char **)(a1 + 36);
      v16 = a2;
      do
      {
        if ( (unsigned int)*(v11 - 6) >= 2 )
        {
          LOBYTE(result) = 0;
          v12 = sub_10022D90(result, *v11, (int)&v24);
          v13 = *(v11 - 9);
          LOBYTE(v12) = 1;
          v22 = 0;
          sub_10022D90(v12, v13, (int)&v22);
          v23 = 0;
          v14 = (char **)(v11 - 5);
          v17 = 5;
          do
          {
            switch ( *v14 )
            {
              case 1u:
                v15 = "<bool>";
                goto LABEL_19;
              case 2u:
                v15 = "<char>";
                goto LABEL_19;
              case 3u:
                v15 = "<sint32>";
                goto LABEL_19;
              case 4u:
                v15 = "<uint32>";
                goto LABEL_19;
              case 6u:
                v15 = "<float>";
                goto LABEL_19;
              case 5u:
                v15 = "<str>";
                goto LABEL_19;
              case 0u:
                break;
              default:
                v15 = "<*?*>";
LABEL_19:
                sub_10022D90(*v14, v15, (int)&v23);
                break;
            }
            ++v14;
            --v17;
          }
          while ( v17 );
          result = (char *)sub_1000AD40(2, (int)v18, 6);
        }
        v11 += 10;
        --v16;
      }
      while ( v16 );
    }
  }
  return result;
}
// 10023250: using guessed type int var_61C[6];

//----- (10023400) --------------------------------------------------------
int __usercall sub_10023400@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ST08_4@1
  char *v3; // eax@1
  int result; // eax@1
  int (__cdecl *v5)(signed int, void *); // esi@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = sub_100229F0((char **)a1);
  result = sub_1000ADD0(4, (int)v3, v2);
  v5 = *(int (__cdecl **)(signed int, void *))(v1 + 16);
  if ( v5 )
    result = v5(4, &unk_1009E9F8);
  return result;
}

//----- (10023430) --------------------------------------------------------
int __usercall sub_10023430@<eax>(int a1@<esi>)
{
  void (__cdecl *v1)(signed int, void *); // eax@1
  char v2; // al@3

  v1 = *(void (__cdecl **)(signed int, void *))(a1 + 16);
  if ( v1 )
    v1(7, &unk_1009E9F8);
  v2 = (unsigned int)sub_100229F0((char **)a1);
  return sub_1000ADB0(10, v2);
}

//----- (10023460) --------------------------------------------------------
void __cdecl sub_10023460(int (**a1)(void), char **a2, _DWORD *a3)
{
  int v3; // esi@3
  int (**v4)(void); // ebx@4
  char **v5; // eax@6
  char *v6; // ST1C_4@6
  char *v7; // eax@6
  char *v8; // eax@7
  char *v9; // eax@9
  char *v10; // eax@10
  int v11; // ebp@12
  signed int v12; // ebx@12
  const char *v13; // eax@14
  char *v14; // ST18_4@14
  int v15; // ST14_4@14
  char *v16; // eax@14
  int v17; // ecx@18
  unsigned int v18; // eax@18
  int v19; // eax@20
  int v20; // ecx@20
  char v21; // dl@20
  int v22; // ST14_4@30
  char *v23; // ST10_4@30
  const char *v24; // eax@31
  char *v25; // ST18_4@31
  int v26; // ST14_4@31
  char *v27; // ST10_4@31
  int v28; // edx@34
  int v29; // ecx@34
  int v30; // eax@34
  int v31; // ST14_4@37
  char *v32; // eax@37
  int v33; // eax@38
  int v34; // ST14_4@39
  char *v35; // ST10_4@39
  int v36; // ST14_4@41
  char *v37; // eax@41
  int v38; // eax@42
  int v39; // ST14_4@43
  char *v40; // eax@43
  int v41; // ST14_4@45
  char *v42; // eax@45
  int v43; // ST14_4@48
  char *v44; // eax@48
  int v45; // edx@49
  int v46; // ST14_4@50
  char *v47; // ST10_4@50
  char *v48; // eax@54
  unsigned int v49; // [sp+4h] [bp-8h]@12
  unsigned int v50; // [sp+8h] [bp-4h]@15
  int v51; // [sp+10h] [bp+4h]@16

  if ( a1 )
  {
    if ( *a1 )
    {
      v3 = (*a1)();
      if ( !a2 )
      {
        v4 = a1 + 1;
        if ( a1 != (int (**)(void))-4 )
        {
          do
          {
            if ( !*v4 )
              break;
            v5 = (char **)(*v4)();
            v6 = sub_100229F0(v5);
            v7 = sub_100229F0((char **)v3);
            if ( !sub_10022A80(v7, (int)v6) )
            {
              v8 = sub_100229F0((char **)v3);
              sub_1000AE70(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"2872",
                (int)v8,
                (int)"Suite name has been used more than once");
              *a3 = 12;
            }
            ++v4;
          }
          while ( v4 );
        }
      }
      v9 = sub_100229F0((char **)v3);
      if ( strchr(v9, 32) )
      {
        v10 = sub_100229F0((char **)v3);
        sub_1000AE70(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"2903",
          (int)v10,
          (int)"Suite name includes spaces so it must be quoted");
        *a3 = 10;
      }
      if ( *(_DWORD *)(v3 + 12) )
      {
        v11 = 0;
        v49 = 1;
        v12 = 20;
        while ( 1 )
        {
          if ( strchr(*(const char **)(*(_DWORD *)(v3 + 8) + v11), 32) )
          {
            v13 = sub_10022F30(*(_DWORD *)(*(_DWORD *)(v3 + 8) + v11 + 12));
            v14 = sub_1000C870("%s name includes spaces so it must be quoted", v13);
            v15 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
            v16 = sub_100229F0((char **)v3);
            sub_1000AEB0(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_runner.c", (int)"2915", (int)v16, v15, (int)v14);
            *a3 = 10;
          }
          v50 = v49;
          if ( v49 < *(_DWORD *)(v3 + 12) )
          {
            v51 = v11 + 40;
            do
            {
              if ( !sub_10022A80(*(_BYTE **)(*(_DWORD *)(v3 + 8) + v11), *(_DWORD *)(v51 + *(_DWORD *)(v3 + 8))) )
              {
                v17 = *(_DWORD *)(v3 + 8);
                v18 = *(_DWORD *)(v17 + v11 + 12);
                if ( v18 < 2 || *(_DWORD *)(v51 + v17 + 12) < 2u )
                {
                  v24 = sub_10022F30(v18);
                  v25 = sub_1000C870("%s name has been used more than once", v24);
                  v26 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
                  v27 = sub_100229F0((char **)v3);
                  sub_1000AEB0(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2958",
                    (int)v27,
                    v26,
                    (int)v25);
                }
                else
                {
                  v19 = *(_DWORD *)(v3 + 8);
                  v20 = *(_DWORD *)(v51 + v17 + 16);
                  v21 = 0;
                  if ( *(_DWORD *)(v12 + v19 - 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 8) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 12) != v20 || v21 )
                    goto LABEL_33;
                  v22 = *(_DWORD *)(v19 + v11);
                  v23 = sub_100229F0((char **)v3);
                  sub_1000AEB0(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2946",
                    (int)v23,
                    v22,
                    (int)"Command name has been used more than once");
                }
                *a3 = 12;
              }
LABEL_33:
              v51 += 40;
              ++v50;
            }
            while ( v50 < *(_DWORD *)(v3 + 12) );
          }
          v28 = *(_DWORD *)(v3 + 8);
          v29 = *(_DWORD *)(v28 + v11 + 12);
          v30 = v28 + v11;
          if ( !v29 )
            break;
          if ( v29 == 1 )
          {
            if ( !*(_DWORD *)(v30 + 8) )
            {
              v36 = *(_DWORD *)v30;
              v37 = sub_100229F0((char **)v3);
              sub_1000AEB0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3047",
                (int)v37,
                v36,
                (int)"Test group has a NULL function pointer or a command uses a reserved ID");
              *a3 = 12;
            }
            v38 = *(_DWORD *)(v3 + 8) + v11;
            if ( *(_DWORD *)(v38 + 4) )
            {
              v39 = *(_DWORD *)v38;
              v40 = sub_100229F0((char **)v3);
              sub_1000AEB0(
                3,
                (int)"**Warning**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3058",
                (int)v40,
                v39,
                (int)"Test group has a non-NULL test case function pointer");
              *a3 = 10;
            }
            if ( a2 )
            {
              v41 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
              v42 = sub_100229F0((char **)v3);
              sub_1000AEB0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3070",
                (int)v42,
                v41,
                (int)"Test group contains a test group");
              *a3 = 12;
            }
            else
            {
              sub_10023460(*(_DWORD *)(v3 + 8) + v11 + 8, v3, a3);
            }
            goto LABEL_52;
          }
          if ( *(_DWORD *)(v30 + 4) )
          {
            v31 = *(_DWORD *)v30;
            v32 = sub_100229F0((char **)v3);
            sub_1000AEB0(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3088",
              (int)v32,
              v31,
              (int)"Command include a non-NULL test case function pointer");
            *a3 = 10;
          }
          v33 = *(_DWORD *)(v3 + 8) + v11;
          if ( *(_DWORD *)(v33 + 8) )
          {
            v34 = *(_DWORD *)v33;
            v35 = sub_100229F0((char **)v3);
            sub_1000AEB0(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3099",
              (int)v35,
              v34,
              (int)"Command include a non-NULL test group function pointer");
LABEL_51:
            *a3 = 10;
          }
LABEL_52:
          ++v49;
          v12 += 40;
          v11 += 40;
          if ( v49 - 1 >= *(_DWORD *)(v3 + 12) )
            return;
        }
        if ( !*(_DWORD *)(v30 + 4) )
        {
          v43 = *(_DWORD *)v30;
          v44 = sub_100229F0((char **)v3);
          sub_1000AEB0(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"3022",
            (int)v44,
            v43,
            (int)"Test case has a NULL function pointer or a command uses a reserved ID");
          *a3 = 12;
        }
        v45 = *(_DWORD *)(v3 + 8);
        if ( !*(_DWORD *)(v45 + v11 + 8) )
          goto LABEL_52;
        v46 = *(_DWORD *)(v45 + v11);
        v47 = sub_100229F0((char **)v3);
        sub_1000AEB0(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"3033",
          (int)v47,
          v46,
          (int)"Test case has a non-NULL group function pointer");
        goto LABEL_51;
      }
    }
    else
    {
      v48 = sub_100229F0(a2);
      sub_1000AE70(
        3,
        (int)"**Error**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"3114",
        (int)v48,
        (int)"Test suite has a NULL function pointer or a command uses a reserved ID");
      *a3 = 12;
    }
  }
}

//----- (100238D0) --------------------------------------------------------
int sub_100238D0()
{
  int (**i)(void); // esi@1
  int v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  for ( i = (int (**)(void))dword_10220950[sub_10022A40()]; i; ++i )
  {
    if ( !*i )
      break;
    sub_10023460(i, 0, &v2);
  }
  return v2;
}
// 10220950: using guessed type int dword_10220950[];

//----- (10023920) --------------------------------------------------------
void *sub_10023920()
{
  void *result; // eax@1
  signed int v1; // esi@1

  dword_10220950[0] = 0;
  dword_10220954 = 0;
  dword_10220958 = 0;
  dword_1022095C = 0;
  dword_10220960 = 0;
  result = &unk_10220978;
  dword_10220964[0] = -1;
  dword_10220968 = -1;
  dword_1022096C = -1;
  dword_10220970 = -1;
  dword_10220974 = -1;
  v1 = 5;
  do
  {
    result = (void *)(sub_10023210((int)result) + 56);
    --v1;
  }
  while ( v1 );
  return result;
}
// 10220950: using guessed type int dword_10220950[];
// 10220954: using guessed type int dword_10220954;
// 10220958: using guessed type int dword_10220958;
// 1022095C: using guessed type int dword_1022095C;
// 10220960: using guessed type int dword_10220960;
// 10220964: using guessed type int dword_10220964[];
// 10220968: using guessed type int dword_10220968;
// 1022096C: using guessed type int dword_1022096C;
// 10220970: using guessed type int dword_10220970;
// 10220974: using guessed type int dword_10220974;

//----- (10023980) --------------------------------------------------------
char *sub_10023980()
{
  return (char *)&unk_10220978 + 56 * sub_10022A40();
}

//----- (100239A0) --------------------------------------------------------
char sub_100239A0()
{
  return sub_10023980()[33];
}

//----- (100239B0) --------------------------------------------------------
char __cdecl sub_100239B0(int a1, int a2, unsigned int a3)
{
  char *v3; // esi@1
  char result; // al@1

  v3 = sub_10023980();
  result = a1 - 6;
  if ( a1 == 6 )
  {
    *(_DWORD *)v3 = 0;
  }
  else
  {
    result = a1 - 7;
    if ( a1 == 7 )
    {
      result = sub_1000A930(a2, a3);
      if ( result )
        ++*(_DWORD *)v3;
    }
  }
  return result;
}

//----- (100239F0) --------------------------------------------------------
int *__usercall sub_100239F0@<eax>(_DWORD *a1@<ebx>, int a2)
{
  int *v2; // edi@1
  unsigned int v3; // ebp@1
  int **v4; // esi@1

  v2 = 0;
  v3 = 0;
  v4 = (int **)(sub_10023980() + 36);
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 && !sub_10022AF0((_BYTE *)(a2 + 80 * *a1), **v4) )
    {
      v2 = *v4;
      ++*a1;
    }
    ++v3;
    ++v4;
  }
  while ( !v2 );
  return v2;
}

//----- (10023A40) --------------------------------------------------------
char **sub_10023A40()
{
  return &off_1009EDA8;
}
// 1009EDA8: using guessed type char *off_1009EDA8;

//----- (10023A50) --------------------------------------------------------
int __cdecl sub_10023A50(_DWORD *a1, int a2, int a3)
{
  char *v3; // esi@1
  int result; // eax@2
  unsigned int v5; // ebp@7
  int v6; // [sp+8h] [bp-8h]@0
  int v7; // [sp+8h] [bp-8h]@7
  int v8; // [sp+Ch] [bp-4h]@8

  sub_10010AE0();
  v3 = sub_10023980();
  if ( v3[34] )
  {
    result = v6;
  }
  else
  {
    result = sub_100238D0();
    if ( result != 12 )
      v3[34] = 1;
  }
  if ( v3[34] )
  {
    sub_10023400(a2);
    if ( a3 )
    {
      v7 = sub_10023170(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), a3);
    }
    else
    {
      v5 = 0;
      v7 = 0;
      if ( *(_DWORD *)(a2 + 12) )
      {
        v8 = 0;
        do
        {
          v7 += sub_10023170(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), v8 + *(_DWORD *)(a2 + 8));
          v8 += 40;
          ++v5;
        }
        while ( v5 < *(_DWORD *)(a2 + 12) );
        sub_10023430(a2);
        return v7;
      }
    }
    sub_10023430(a2);
    result = v7;
  }
  return result;
}

//----- (10023B00) --------------------------------------------------------
int __cdecl sub_10023B00(int a1, int a2, int a3, const char *a4, const char *a5)
{
  int v5; // ebp@1
  unsigned int v6; // eax@1
  char *v7; // ecx@1
  int result; // eax@3
  int v9; // eax@5
  char *v10; // eax@7
  char *v11; // eax@7
  char *v12; // eax@7
  char *v13; // eax@7
  char *v14; // eax@7
  char **v15; // eax@7
  char **v16; // esi@7
  char *v17; // eax@7
  char *v18; // eax@7
  char *v19; // eax@7
  char *v20; // eax@7
  char *v21; // eax@8
  char *v22; // eax@9
  const char *v23; // edi@9
  char *v24; // eax@11
  int v25; // [sp+8h] [bp-41Ch]@4
  int v26[4]; // [sp+10h] [bp-414h]@2
  char v27; // [sp+20h] [bp-404h]@1
  char v28; // [sp+120h] [bp-304h]@7
  char v29; // [sp+220h] [bp-204h]@7
  char v30; // [sp+320h] [bp-104h]@11

  v5 = a1;
  v6 = 0;
  v7 = &v27;
  do
  {
    v26[v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( v6 < 4 );
  result = a2;
  if ( a2 )
  {
    v25 = a2;
    do
    {
      v9 = *(_DWORD *)(v5 + 12);
      if ( v9 )
      {
        result = v9 - 1;
        if ( !result )
        {
          v10 = sub_10022D90(0, "group", (int)&v27);
          LOBYTE(v10) = 0;
          v11 = sub_10022D90(v10, a4, (int)&v28);
          LOBYTE(v11) = 0;
          sub_10022D90(v11, *(const char **)v5, (int)&v29);
          v12 = (char *)sub_1000AD40(2, (int)v26, 3);
          LOBYTE(v12) = 0;
          v13 = sub_10022D90(v12, "group", (int)&v27);
          LOBYTE(v13) = 0;
          v14 = sub_10022D90(v13, a4, (int)&v28);
          LOBYTE(v14) = 0;
          sub_10022D90(v14, "group-begin", (int)&v29);
          sub_1000AD40(2, (int)v26, 3);
          v15 = (char **)(*(int (**)(void))(v5 + 8))();
          v16 = v15;
          v17 = sub_100229F0(v15);
          sub_10023B00(v16[2], v16[3], v16[4], v17, a4);
          sub_100229F0(v16);
          v18 = sub_10023250((int)v16[2], v16[3], (int)v16[4], a4);
          LOBYTE(v18) = 0;
          v19 = sub_10022D90(v18, "group", (int)&v27);
          LOBYTE(v19) = 0;
          v20 = sub_10022D90(v19, a4, (int)&v28);
          LOBYTE(v20) = 0;
          sub_10022D90(v20, "group-end", (int)&v29);
          result = sub_1000AD40(2, (int)v26, 3);
        }
      }
      else
      {
        v21 = sub_10022D90(0, "case", (int)&v27);
        LOBYTE(v21) = 0;
        if ( a5 )
        {
          v22 = sub_10022D90(v21, a5, (int)&v28);
          v23 = a4;
        }
        else
        {
          v22 = sub_10022D90(v21, a4, (int)&v28);
          v23 = (const char *)&unk_1005C3FD;
        }
        LOBYTE(v22) = 0;
        v24 = sub_10022D90(v22, v23, (int)&v29);
        LOBYTE(v24) = 0;
        sub_10022D90(v24, *(const char **)v5, (int)&v30);
        result = sub_1000AD40(2, (int)v26, 4);
      }
      v5 += 40;
      --v25;
    }
    while ( v25 );
  }
  return result;
}
// 10023B00: using guessed type int var_414[4];

//----- (10023D10) --------------------------------------------------------
char *__usercall sub_10023D10@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6)
{
  const char *v6; // edi@1
  char *v7; // eax@1
  char *v8; // ecx@1
  char *v9; // eax@3
  char *result; // eax@3
  int v11[2]; // [sp+Ch] [bp-20Ch]@2
  char v12; // [sp+14h] [bp-204h]@1
  char v13; // [sp+114h] [bp-104h]@3

  v6 = a1;
  v7 = 0;
  v8 = &v12;
  do
  {
    v11[(signed int)v7] = (int)v8;
    *v8 = 0;
    ++v7;
    v8 += 256;
  }
  while ( (unsigned int)v7 < 2 );
  LOBYTE(v7) = 0;
  v9 = sub_10022D90(v7, v6, (int)&v12);
  LOBYTE(v9) = 0;
  result = sub_10022D90(v9, a2, (int)&v13);
  if ( v13 )
    result = (char *)sub_1000AD40(2, (int)v11, 2);
  if ( a6 )
  {
    sub_10023B00(a3, (int)a4, a5, a2, 0);
    result = sub_10023250(a3, a4, a5, 0);
  }
  return result;
}
// 10023D10: using guessed type int var_20C[2];

//----- (10023DD0) --------------------------------------------------------
char *__cdecl sub_10023DD0(char a1)
{
  int (**i)(void); // edi@1
  int v2; // esi@3
  char *v3; // ebx@3
  char **v4; // esi@4
  signed int v5; // edi@4
  char *result; // eax@5

  for ( i = (int (**)(void))dword_10220950[sub_10022A40()]; i; ++i )
  {
    if ( !*i )
      break;
    v2 = (*i)();
    v3 = sub_100229F0((char **)v2);
    sub_10023D10("suite", v3, *(_DWORD *)(v2 + 8), *(char **)(v2 + 12), *(_DWORD *)(v2 + 16), a1);
  }
  v4 = (char **)(sub_10023980() + 36);
  v5 = 5;
  do
  {
    result = *v4;
    if ( *v4 )
    {
      if ( *((_DWORD *)result + 2) )
        result = sub_10023D10(
                   "listener",
                   *(const char **)result,
                   *((_DWORD *)result + 3),
                   *((char **)result + 4),
                   *((_DWORD *)result + 2),
                   a1);
    }
    ++v4;
    --v5;
  }
  while ( v5 );
  return result;
}
// 10220950: using guessed type int dword_10220950[];

//----- (10023E70) --------------------------------------------------------
int *__cdecl sub_10023E70(_BYTE *a1)
{
  int (**v1)(void); // edi@1
  char **v2; // eax@3
  char **v3; // esi@3
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // ebx@7
  unsigned int v7; // esi@7
  int **v8; // edi@7
  int *result; // eax@8

  v1 = (int (**)(void))dword_10220950[sub_10022A40()];
  if ( v1 )
  {
    while ( *v1 )
    {
      v2 = (char **)(*v1)();
      v3 = v2;
      v4 = sub_100229F0(v2);
      if ( !sub_10022AF0(a1, (int)v4) )
      {
        v5 = sub_100229F0(v3);
        sub_10023D10("suite", v5, (int)v3[2], v3[3], (int)v3[4], 1);
        break;
      }
      ++v1;
      if ( !v1 )
        break;
    }
  }
  v6 = sub_10023980();
  v7 = 0;
  v8 = (int **)(v6 + 36);
  while ( 1 )
  {
    result = *v8;
    if ( *v8 )
    {
      result = (int *)sub_10022AF0(a1, *result);
      if ( !result )
        break;
    }
    ++v7;
    ++v8;
    if ( v7 >= 5 )
      return result;
  }
  return (int *)sub_10023D10(
                  "listener",
                  **(const char ***)&v6[4 * v7 + 36],
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 12),
                  *(char **)(*(_DWORD *)&v6[4 * v7 + 36] + 16),
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 8),
                  1);
}
// 10220950: using guessed type int dword_10220950[];

//----- (10023F30) --------------------------------------------------------
int __usercall sub_10023F30@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  bool v2; // zf@1
  int result; // eax@1
  signed int v4; // ebp@3
  int v5; // eax@5
  int v6; // eax@8
  int v7; // ecx@14
  int v8; // esi@18
  unsigned int v9; // eax@18
  int v10; // eax@19
  int v11; // edi@25

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 20) == 0;
  result = 12;
  if ( !v2 && !*(_BYTE *)(v1 + 24) )
  {
    v4 = 2;
    if ( !*(_DWORD *)(v1 + 16) )
    {
      *(_DWORD *)(v1 + 16) = sub_10022F50(++*(_DWORD *)(v1 + 12));
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 4) = 0;
    }
    v5 = *(_DWORD *)(v1 + 16);
    if ( v5 )
    {
      if ( *(_DWORD *)(v1 + 20) == 1 )
      {
        sub_10023A50((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        v6 = sub_10022F50(++*(_DWORD *)(v1 + 12));
        v2 = *(_DWORD *)(v1 + 28) == 0;
        *(_DWORD *)(v1 + 16) = v6;
        *(_DWORD *)(v1 + 8) = 0;
        if ( !v2 || !v6 )
          *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 28) == 2 )
      {
        sub_10023A50((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 8)
             || (*(_DWORD *)(v1 + 4) = 0, v7 = *(_DWORD *)(v5 + 8), (*(_DWORD *)(v1 + 8) = v7) != 0) )
      {
        if ( !*(_DWORD *)(v1 + 4) )
          sub_10023400(v5);
        sub_10023170(
          (_DWORD *)v1,
          *(void (__cdecl **)(signed int, void *))(*(_DWORD *)(v1 + 16) + 16),
          *(_DWORD *)(v1 + 8));
        v8 = *(_DWORD *)(v1 + 16);
        v9 = ++*(_DWORD *)(v1 + 4);
        if ( *(_DWORD *)(v8 + 12) > v9 )
        {
          *(_DWORD *)(v1 + 8) = *(_DWORD *)(v8 + 8) + 40 * v9;
        }
        else
        {
          sub_10023430(v8);
          v10 = sub_10022F50(++*(_DWORD *)(v1 + 12));
          *(_DWORD *)(v1 + 16) = v10;
          *(_DWORD *)(v1 + 4) = 0;
          *(_DWORD *)(v1 + 8) = 0;
          if ( !v10 || *(_DWORD *)(v1 + 28) )
            *(_BYTE *)(v1 + 24) = 1;
        }
      }
      else
      {
        *(_BYTE *)(v1 + 24) = 1;
        v4 = 12;
      }
    }
    else
    {
      *(_BYTE *)(v1 + 24) = 1;
      v4 = 12;
    }
    if ( *(_BYTE *)(v1 + 24) && v4 == 2 )
    {
      v11 = *(_DWORD *)v1;
      if ( v11 )
        result = v11 + 12;
      else
        result = 0;
    }
    else
    {
      result = v4;
    }
  }
  return result;
}

//----- (10024090) --------------------------------------------------------
signed int __usercall sub_10024090@<eax>(int a1@<esi>)
{
  signed int v1; // ebp@1
  int (**i)(void); // edi@2
  int v3; // eax@4
  signed int result; // eax@5

  v1 = 0;
  if ( *(_DWORD *)(a1 + 20) )
  {
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(_BYTE *)(a1 + 24) = 0;
      result = 1;
    }
    else
    {
      result = 12;
    }
  }
  else
  {
    for ( i = (int (**)(void))dword_10220950[sub_10022A40()]; i; ++i )
    {
      if ( !*i )
        break;
      v3 = (*i)();
      v1 += sub_10023A50((_DWORD *)a1, v3, 0);
    }
    result = v1;
  }
  return result;
}
// 10220950: using guessed type int dword_10220950[];

//----- (10024100) --------------------------------------------------------
int __cdecl sub_10024100(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  int v4; // ebx@3
  int result; // eax@3
  _BYTE *v6; // esi@5
  int v7; // ebx@6
  int v8; // ebx@8
  int v9; // ebx@9
  int (**i)(void); // edi@11
  int v11; // eax@13
  int (__cdecl *v12)(int, int); // eax@14
  int (**v13)(void); // esi@19
  int v14; // eax@21
  int (__cdecl *v15)(int, int); // eax@22

  v2 = 0;
  v3 = sub_10023980();
  switch ( a1 )
  {
    case 9:
      sub_1000ADB0(2, (unsigned int)"begin");
      if ( *(_DWORD *)a2 )
      {
        if ( *(_DWORD *)a2 == 5 )
        {
          v6 = (_BYTE *)(a2 + 4);
          if ( sub_10022AF0((_BYTE *)(a2 + 4), (int)"-v") )
          {
            if ( sub_10022AF0(v6, (int)"-q") )
            {
              sub_10023E70(v6);
              v9 = sub_100238D0();
              sub_1000ADB0(2, (unsigned int)"end");
              result = v9;
            }
            else
            {
              sub_10023DD0(0);
              v8 = sub_100238D0();
              sub_1000ADB0(2, (unsigned int)"end");
              result = v8;
            }
          }
          else
          {
            sub_10023DD0(1);
            v7 = sub_100238D0();
            sub_1000ADB0(2, (unsigned int)"end");
            result = v7;
          }
        }
        else
        {
          sub_1000AE30(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"1719",
            (int)"Unsupported argument type for help command (internal error)");
          sub_1000ADB0(2, (unsigned int)"end");
          result = 4;
        }
      }
      else
      {
        sub_10023DD0(0);
        v4 = sub_100238D0();
        sub_1000ADB0(2, (unsigned int)"end");
        result = v4;
      }
      return result;
    case 2:
      sub_1000ADB0(0, (unsigned int)"Global reset command");
      for ( i = (int (**)(void))dword_10220950[sub_10022A40()]; i; ++i )
      {
        if ( !*i )
          break;
        v11 = (*i)();
        if ( v11 )
        {
          v12 = *(int (__cdecl **)(int, int))(v11 + 16);
          if ( v12 )
          {
            if ( v12 != sub_10024100 )
              v12(2, (int)&unk_1009E9F8);
          }
        }
      }
      sub_10010AE0();
      v3[34] = 0;
      return 0;
    case 3:
      sub_1000ADB0(1, (unsigned int)"Global clear command");
      v13 = (int (**)(void))dword_10220950[sub_10022A40()];
      if ( !v13 )
        return v2;
      break;
    case 10:
      if ( !*((_DWORD *)v3 + 5) )
      {
        sub_1000AE30(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1764", (int)"Step mode not enabled");
        goto LABEL_29;
      }
      return sub_10023F30((int)v3);
    case 11:
      if ( v3[24] )
      {
        *((_DWORD *)v3 + 5) = 0;
        v3[24] = 0;
        result = 0;
      }
      else
      {
        sub_1000AE30(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1783", (int)"Step mode is busy");
LABEL_29:
        result = 12;
      }
      return result;
    case 12:
      *((_DWORD *)v3 + 5) = 1;
      return 0;
    case 13:
      *((_DWORD *)v3 + 5) = 2;
      return 0;
    case 8:
      return sub_10024090((int)v3);
    case 14:
      exit(12);
      return result;
    case 4:
    case 5:
    case 6:
    case 7:
      return v2;
    default:
      sub_1000AE30(
        3,
        (int)"**Warning**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"1820",
        (int)"Unknown/unsupported command (internal error)");
      return 4;
  }
  while ( *v13 )
  {
    v14 = (*v13)();
    if ( v14 )
    {
      v15 = *(int (__cdecl **)(int, int))(v14 + 16);
      if ( v15 )
      {
        if ( v15 != sub_10024100 )
          v15(3, (int)&unk_1009E9F8);
      }
    }
    ++v13;
    if ( !v13 )
      return 0;
  }
  return v2;
}
// 10024100: using guessed type int __cdecl sub_10024100(int, int);
// 10220950: using guessed type int dword_10220950[];

//----- (100243E0) --------------------------------------------------------
char **sub_100243E0()
{
  return off_1009EB9C;
}
// 1009EB9C: using guessed type char *off_1009EB9C[3];

//----- (100243F0) --------------------------------------------------------
int __usercall sub_100243F0@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int result; // eax@2
  char **v9; // eax@6
  signed int v10; // ebx@6
  int v11; // [sp+0h] [bp-1C0h]@0
  int (__cdecl *v12)(_DWORD, char *); // [sp+14h] [bp-1ACh]@1
  char v13; // [sp+18h] [bp-1A8h]@2

  v12 = a2;
  v6 = sub_10022E80(a4, a5, a1, v11);
  v7 = v6;
  if ( v6 )
  {
    result = sub_10022F90(a5, &v13, v6, a3, a6);
    if ( !result )
    {
      if ( v12 )
      {
        result = v12(*(_DWORD *)(v7 + 12), &v13);
      }
      else
      {
        sprintf(a6, "'%s' does not support commands", a3);
        result = 11;
      }
    }
  }
  else
  {
    v9 = sub_100243E0();
    v10 = *a5;
    if ( (char *)a4 == v9[2] )
      sprintf(a6, "Invalid or missing test suite, listener, or command: '%s'", a3 + 80 * v10);
    else
      sprintf(a6, "Invalid or mising test case or command: '%s'", a3 + 80 * v10);
    result = 10;
  }
  return result;
}

//----- (100244E0) --------------------------------------------------------
int __cdecl sub_100244E0(char *a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *v3; // edi@1
  char *v4; // eax@1
  int result; // eax@1
  int v6; // eax@4
  char **v7; // ebx@4
  int v8; // eax@5
  int *v9; // eax@20
  char **v10; // eax@22
  int v11; // [sp+10h] [bp-2DCh]@4
  int v12; // [sp+14h] [bp-2D8h]@1
  char v13[720]; // [sp+18h] [bp-2D4h]@1

  v2 = v1;
  v3 = sub_10023980();
  *a1 = 0;
  v4 = sub_1000C870("Processing command '%s'", v2);
  sub_1000AE30(3, (int)&unk_1005C3A0, (int)"..\\lib\\utf\\utf_runner.c", (int)"1215", (int)v4);
  result = sub_10023020(v13, &v12, v2, a1);
  if ( result )
  {
    if ( result == 3 )
    {
      if ( *((_DWORD *)v3 + 5) && !v3[24] )
        result = sub_10023F30((int)v3);
    }
    else
    {
      sprintf(a1, "Invalid command: '%s'", v2);
      result = 10;
    }
  }
  else
  {
    if ( !v12 )
      return sub_10024090((int)v3);
    v11 = 0;
    v6 = sub_10022A40();
    v7 = sub_10022ED0((int (**)(void))dword_10220950[v6], (int)v13, &v11);
    if ( v7 )
    {
      v8 = sub_10022DF0((int)v7, (int)v13, &v11);
      if ( !v8 )
        goto LABEL_30;
      if ( *(_DWORD *)(v8 + 12) == 1 )
      {
        v7 = (char **)(*(int (**)(void))(v8 + 8))();
        v8 = sub_10022DF0((int)v7, (int)v13, &v11);
      }
      if ( v8 )
      {
        if ( v11 >= v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_10023A50(v3, (int)v7, v8);
          *((_DWORD *)v3 + 2) = v8;
          *((_DWORD *)v3 + 4) = v7;
          *((_DWORD *)v3 + 3) = 0;
          *((_DWORD *)v3 + 1) = 0;
          *((_DWORD *)v3 + 7) = 2;
          v3[24] = 0;
          result = 1;
        }
        else
        {
          sprintf(a1, "Unsupported argument to test case: '%s'", &v13[80 * v11]);
          result = 9;
        }
      }
      else
      {
LABEL_30:
        if ( v11 == v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_10023A50(v3, (int)v7, v8);
          if ( v3[24] )
          {
            *((_DWORD *)v3 + 2) = v8;
            result = 1;
            *((_DWORD *)v3 + 4) = v7;
            *((_DWORD *)v3 + 3) = 0;
            *((_DWORD *)v3 + 1) = 0;
            *((_DWORD *)v3 + 7) = 1;
            v3[24] = 0;
          }
          else
          {
            result = 12;
          }
        }
        else
        {
          result = sub_100243F0(
                     (unsigned int)v7[3],
                     (int (__cdecl *)(_DWORD, char *))v7[4],
                     (int)v13,
                     (int)v7[2],
                     &v11,
                     a1);
        }
      }
    }
    else
    {
      v9 = sub_100239F0(&v11, (int)v13);
      if ( v9 )
      {
        result = sub_100243F0(v9[4], (int (__cdecl *)(_DWORD, char *))v9[2], (int)v13, v9[3], &v11, a1);
      }
      else
      {
        v10 = sub_100243E0();
        result = sub_100243F0(
                   (unsigned int)v10[3],
                   (int (__cdecl *)(_DWORD, char *))v10[4],
                   (int)v13,
                   (int)v10[2],
                   &v11,
                   a1);
      }
    }
  }
  return result;
}
// 10220950: using guessed type int dword_10220950[];
// 100244E0: using guessed type char var_2D4[720];

//----- (10024720) --------------------------------------------------------
int sub_10024720()
{
  int v0; // esi@1
  char *v1; // eax@4
  int result; // eax@4
  char *v3; // eax@5
  char v4; // [sp+4h] [bp-104h]@1

  v4 = 0;
  v0 = sub_100244E0(&v4);
  if ( !sub_10023980()[32] )
    sub_1000ADB0(11, (unsigned int)"Non-interactive command complete");
  if ( v4 )
  {
    v3 = sub_1000C870("%s %i, %s", "Command status:", v0, &v4);
    sub_1000AE30(3, (int)&unk_1005C3A0, (int)"..\\lib\\utf\\utf_runner.c", (int)"773", (int)v3);
    result = v0;
  }
  else
  {
    v1 = sub_1000C870("%s %i", "Command status:", v0);
    sub_1000AE30(3, (int)&unk_1005C3A0, (int)"..\\lib\\utf\\utf_runner.c", (int)"767", (int)v1);
    result = v0;
  }
  return result;
}

//----- (10024800) --------------------------------------------------------
int __cdecl sub_10024800(int a1, int a2, char a3)
{
  char **v3; // eax@1

  dword_10220950[sub_10022A40()] = a1;
  sub_10023980()[32] = a3;
  sub_10010AE0();
  sub_10024A50(a2);
  v3 = sub_10023A40();
  sub_1000A820(v3);
  return sub_10024720();
}
// 10220950: using guessed type int dword_10220950[];

//----- (10024850) --------------------------------------------------------
char __cdecl sub_10024850(signed int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax@2
  char result; // al@4

  if ( a1 < 50 && ((v3 = 592 * a1, byte_10220A98[592 * a1]) || byte_10220AE8[v3]) )
  {
    *a2 = &byte_10220A98[v3];
    *a3 = &byte_10220AE8[v3];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10024890) --------------------------------------------------------
char *__cdecl sub_10024890(const char *a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edi@1
  unsigned int v4; // esi@1

  v2 = 0;
  v3 = byte_10220A98;
  v4 = 0;
  while ( strcmp(v3, a1) )
  {
    v4 += 592;
    ++v2;
    v3 += 592;
    if ( v4 >= 0x73A0 )
      return (char *)a2;
  }
  return &byte_10220AE8[592 * v2];
}

//----- (10024900) --------------------------------------------------------
char *__usercall sub_10024900@<eax>(char *result@<eax>)
{
  char v1; // cl@2

  for ( ; *result; ++result )
  {
    v1 = *result;
    if ( *result == 10 || v1 == 35 )
    {
      *result = 0;
    }
    else if ( v1 == 92 )
    {
      *result = 47;
    }
  }
  return result;
}

//----- (10024930) --------------------------------------------------------
void __cdecl sub_10024930(char *a1)
{
  char *v1; // eax@3
  char *v2; // edi@3
  char *v3; // eax@4
  int v4; // ST14_4@5
  char *v5; // eax@5
  char v6; // [sp+4h] [bp-204h]@1

  v6 = 0;
  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = strstr(a1, "$$(");
      v2 = v1;
      if ( v1 )
      {
        v3 = strchr(v1 + 3, 41);
        if ( v3 )
        {
          *v2 = 0;
          *v3 = 0;
          v4 = (int)(v3 + 1);
          v5 = sub_10024890(v2 + 3, (int)&unk_1005C3FD);
          sprintf(&v6, "%s%s%s", a1, v5, v4);
          sub_10024930(&v6);
          strcpy(a1, &v6);
        }
      }
    }
  }
}

//----- (100249F0) --------------------------------------------------------
void __cdecl sub_100249F0(char *a1, char *a2)
{
  char *v2; // eax@2
  int v3; // edx@2
  char *v4; // esi@2
  char v5; // cl@3
  char *v6; // eax@4
  char *v7; // esi@4
  char *v8; // edx@4
  char v9; // cl@5

  if ( dword_10220A90 < 50 )
  {
    v2 = a1;
    v3 = 592 * dword_10220A90;
    v4 = (char *)(&byte_10220A98[592 * dword_10220A90] - a1);
    do
    {
      v5 = *v2;
      v2[(_DWORD)v4] = *v2;
      ++v2;
    }
    while ( v5 );
    v6 = a2;
    v7 = &byte_10220AE8[v3];
    v8 = (char *)(&byte_10220AE8[v3] - a2);
    do
    {
      v9 = *v6;
      v6[(_DWORD)v8] = *v6;
      ++v6;
    }
    while ( v9 );
    sub_10024930(v7);
    ++dword_10220A90;
  }
}
// 10220A90: using guessed type int dword_10220A90;

//----- (10024A50) --------------------------------------------------------
void *__cdecl sub_10024A50(int a1)
{
  void *result; // eax@1
  unsigned int v2; // eax@2
  unsigned int v3; // ebp@2
  char *v4; // edi@4
  char *v5; // esi@4
  char *v6; // eax@4
  const char *v7; // esi@6
  const char *v8; // ebx@6
  char *v9; // edi@6
  char *v10; // eax@6
  char v11; // [sp+4h] [bp-204h]@3

  result = memset(byte_10220A98, 0, 0x73A0u);
  dword_10220A90 = 0;
  if ( a1 )
  {
    v2 = sub_10024C30(a1, 0);
    v3 = v2;
    if ( v2 )
    {
      if ( sub_10024E10((int)&v11, 512, v2) )
      {
        do
        {
          sub_10024900(&v11);
          v4 = strstr(&v11, "=");
          v5 = strstr(&v11, "<Var name=\"");
          v6 = strstr(&v11, " value=\"");
          if ( v5 && v6 )
          {
            v7 = v5 + 11;
            v8 = v6 + 8;
            v9 = strchr(v7, 34);
            v10 = strchr(v8, 34);
            if ( v9 )
            {
              if ( v10 )
              {
                *v9 = 0;
                *v10 = 0;
                sub_100249F0((char *)v7, (char *)v8);
              }
            }
          }
          else if ( v4 && !strpbrk(&v11, "<>") )
          {
            *v4 = 0;
            sub_100249F0(&v11, v4 + 1);
          }
        }
        while ( sub_10024E10((int)&v11, 512, v3) );
      }
      result = (void *)sub_10024BE0(v3);
    }
    else
    {
      result = (void *)sub_1000AEB0(
                         3,
                         (int)"**Warning**",
                         (int)"..\\lib\\utf\\utf_cnfg.c",
                         (int)"269",
                         (int)"Configuration File",
                         a1,
                         (int)"Unable to open configuration file");
    }
  }
  return result;
}
// 10220A90: using guessed type int dword_10220A90;

//----- (10024BE0) --------------------------------------------------------
BOOL __cdecl sub_10024BE0(unsigned int a1)
{
  j_FIL_vfs_clean_invalidate_cache(a1);
  return sub_10033760(a1) == 0;
}
// 10033750: using guessed type int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD);

//----- (10024C00) --------------------------------------------------------
BOOL __cdecl sub_10024C00(int a1)
{
  return j_FIL_vfs_delete(a1) == 0;
}
// 100337A0: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);

//----- (10024C30) --------------------------------------------------------
unsigned int __cdecl sub_10024C30(int a1, char a2)
{
  unsigned int result; // eax@7
  int v3; // [sp-Ch] [bp-Ch]@3
  signed int v4; // [sp-8h] [bp-8h]@2

  switch ( a2 )
  {
    case 0:
      v4 = 4;
      goto LABEL_6;
    case 1:
      v4 = 10;
      v3 = a1;
      goto LABEL_7;
    case 2:
      v4 = 14;
      v3 = a1;
      goto LABEL_7;
    case 3:
      v4 = 78;
LABEL_6:
      v3 = a1;
LABEL_7:
      result = j_FIL_vfs_open(v3, v4, 0);
      if ( result >= 0xFFFFFFC2 || !result )
        goto LABEL_9;
      break;
    default:
LABEL_9:
      result = 0;
      break;
  }
  return result;
}
// 10033820: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10024C90) --------------------------------------------------------
signed int __cdecl sub_10024C90(void *a1, int a2, unsigned int a3)
{
  return sub_10033830(a3, a1, a2);
}

//----- (10024CB0) --------------------------------------------------------
int __cdecl sub_10024CB0(int a1, int a2, int a3)
{
  return j_FIL_vfs_write(a3, a1, a2);
}
// 10033990: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10024CD0) --------------------------------------------------------
char __cdecl sub_10024CD0(const char *a1, const char *a2)
{
  bool v2; // bl@1
  unsigned int v3; // edi@6
  unsigned int v4; // ebp@7
  int v5; // esi@8
  bool i; // zf@8
  char v8; // [sp+Ch] [bp-204h]@8

  v2 = 0;
  if ( !a1 || !*a1 || !a2 || !*a2 )
    return v2;
  if ( strcmp(a1, a2) )
  {
    v3 = sub_10024C30((int)a1, 0);
    if ( v3 )
    {
      v4 = sub_10024C30((int)a2, 1);
      if ( v4 )
      {
        v5 = sub_10024C90(&v8, 512, v3);
        for ( i = v5 == 0; v5 > 0; i = v5 == 0 )
        {
          v5 -= sub_10024CB0((int)&v8, v5, v4);
          if ( !v5 )
            v5 = sub_10024C90(&v8, 512, v3);
        }
        v2 = i;
        sub_10024BE0(v4);
      }
      sub_10024BE0(v3);
    }
    return v2;
  }
  return 1;
}

//----- (10024E10) --------------------------------------------------------
int __cdecl sub_10024E10(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // esi@1
  unsigned __int8 v5; // [sp+13h] [bp-1h]@2

  v3 = 0;
  while ( 1 )
  {
    if ( sub_10024C90(&v5, 1, a3) <= 0 || v5 == -1 )
    {
      *(_BYTE *)(v3 + a1) = 0;
      return v3 > 0 ? a1 : 0;
    }
    if ( v5 == 10 )
      break;
    if ( v5 != 13 )
    {
      *(_BYTE *)(v3++ + a1) = v5;
      if ( v3 >= a2 - 2 )
      {
        *(_BYTE *)(v3 + a1 + 1) = 0;
        return a1;
      }
    }
  }
  *(_BYTE *)(v3 + a1) = 0;
  return a1;
}

//----- (10024E90) --------------------------------------------------------
int sub_10024E90()
{
  return 0;
}

//----- (10024EA0) --------------------------------------------------------
void __cdecl sub_10024EA0(int a1)
{
  if ( a1 > 0 )
    exit(14);
}

//----- (10024ED0) --------------------------------------------------------
int __cdecl sub_10024ED0(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (10024EF0) --------------------------------------------------------
bool __cdecl sub_10024EF0(int a1)
{
  return *(_DWORD *)a1 && *(_DWORD *)(a1 + 4) && *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 12);
}

//----- (10024F20) --------------------------------------------------------
void *__cdecl sub_10024F20(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5)
{
  void *v5; // eax@1

  *(_DWORD *)a5 = a1;
  *(_DWORD *)(a5 + 4) = a2;
  *(_DWORD *)(a5 + 8) = a3;
  v5 = (void *)a4(a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
  *(_DWORD *)(a5 + 12) = v5;
  return memset(v5, 0, a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
}

//----- (10024F60) --------------------------------------------------------
unsigned int __usercall sub_10024F60@<eax>(int a1@<edx>, int a2, int a3)
{
  return *(_DWORD *)(a1 + 12) + ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3) * (a3 + a2 * *(_DWORD *)(a1 + 4));
}

//----- (10024F80) --------------------------------------------------------
int __usercall sub_10024F80@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_BYTE *)(result + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(result + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)result = *(_BYTE *)a2;
  return result;
}

//----- (10024FA0) --------------------------------------------------------
char __cdecl sub_10024FA0(void (__cdecl *a1)(_DWORD), int a2)
{
  char result; // al@1

  result = sub_10024EF0(a2);
  if ( result )
  {
    a1(*(_DWORD *)(a2 + 12));
    result = sub_10024ED0(a2);
  }
  return result;
}

//----- (10024FD0) --------------------------------------------------------
signed int __cdecl sub_10024FD0(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5)
{
  int v5; // ebp@1
  signed int result; // eax@1
  unsigned int v7; // ebx@1
  bool v8; // zf@1
  unsigned int v9; // esi@2
  unsigned int v10; // edi@3
  _BYTE *v11; // eax@3
  _BYTE *v12; // ecx@3
  __int64 v13; // rax@3
  __int64 v14; // rax@4
  __int64 v15; // rax@5
  int v16; // eax@6
  signed int v17; // [sp+Ch] [bp+4h]@1

  v5 = (int)a1;
  result = 0;
  v7 = 0;
  v8 = *a1 == 0;
  v17 = 0;
  if ( v8 )
  {
    *a5 = 0;
  }
  else
  {
    do
    {
      v9 = 0;
      if ( *(_DWORD *)(v5 + 4) )
      {
        do
        {
          v10 = sub_10024F60(v5, v7, v9);
          v11 = (_BYTE *)sub_10024F60(a2, v7, v9);
          v12 = v11;
          v13 = *(_BYTE *)v10 - *v11;
          if ( (signed int)((HIDWORD(v13) ^ v13) - HIDWORD(v13)) > a3
            || (v14 = *(_BYTE *)(v10 + 1) - v12[1], (signed int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) > a3)
            || (v15 = *(_BYTE *)(v10 + 2) - v12[2], (signed int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) > a3) )
          {
            v17 = 4;
            v16 = sub_10024F60(a4, v7, v9);
            sub_10024F80(v16, (int)&unk_1009F5DC);
          }
          ++v9;
        }
        while ( v9 < *(_DWORD *)(v5 + 4) );
      }
      ++v7;
    }
    while ( v7 < *(_DWORD *)v5 );
    result = v17;
    *a5 = 0;
  }
  return result;
}

//----- (100250B0) --------------------------------------------------------
void __cdecl sub_100250B0(int a1, int a2, int a3)
{
  unsigned int *v3; // edx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // eax@2
  unsigned int v6; // esi@3
  unsigned int v7; // edi@4
  unsigned int v8; // ebx@4
  unsigned int v9; // ebp@4
  __int64 v10; // rax@4
  __int64 v11; // rax@4
  unsigned int v12; // [sp+4h] [bp-4h]@1

  v3 = (unsigned int *)a1;
  v4 = 0;
  v12 = 0;
  if ( *(_DWORD *)a1 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    do
    {
      v6 = 0;
      if ( v5 )
      {
        do
        {
          v7 = sub_10024F60((int)v3, v4, v6);
          v8 = sub_10024F60(a2, v4, v6);
          v9 = sub_10024F60(a3, v4, v6);
          v10 = *(_BYTE *)(v7 + 2) - *(_BYTE *)(v8 + 2);
          *(_BYTE *)(v9 + 2) = (BYTE4(v10) ^ v10) - BYTE4(v10);
          v11 = *(_BYTE *)(v7 + 1) - *(_BYTE *)(v8 + 1);
          *(_BYTE *)(v9 + 1) = (BYTE4(v11) ^ v11) - BYTE4(v11);
          v3 = (unsigned int *)a1;
          *(_BYTE *)v9 = abs(*(_BYTE *)v7 - *(_BYTE *)v8);
          v5 = *(_DWORD *)(a1 + 4);
          v4 = v12;
          ++v6;
        }
        while ( v6 < v5 );
      }
      v12 = ++v4;
    }
    while ( v4 < *v3 );
  }
}

//----- (10025160) --------------------------------------------------------
void *__usercall sub_10025160@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3)
{
  int v3; // eax@1
  unsigned int v4; // ebx@3
  int v5; // ebp@4
  int v6; // eax@4
  int v7; // ebp@4
  int v8; // eax@4
  int v9; // ST5C_4@4
  int v10; // eax@4
  int v11; // ebp@4
  int v12; // eax@4
  unsigned int v13; // ebx@6
  size_t v14; // ST3C_4@7
  const void *v15; // ST38_4@7
  void *v16; // eax@7
  unsigned int i; // ebp@8
  unsigned int v18; // ebx@9
  int v19; // ST5C_4@10
  int v20; // eax@10
  int v21; // ST5C_4@10
  int v22; // eax@10
  size_t v23; // ST3C_4@11
  const void *v24; // ST38_4@11
  void *v25; // eax@11
  unsigned int v26; // ebx@12
  size_t v27; // ST3C_4@13
  const void *v28; // ST38_4@13
  void *v29; // eax@13
  void *result; // eax@13
  int v31; // [sp+8h] [bp-18h]@1
  unsigned int v32; // [sp+Ch] [bp-14h]@1
  int v33; // [sp+10h] [bp-10h]@3
  int v34; // [sp+14h] [bp-Ch]@1
  int v35; // [sp+18h] [bp-8h]@1

  v3 = 2 * a3 + *(_DWORD *)a2;
  v35 = 2 * a3 + *(_DWORD *)a2;
  v34 = 2 * a3 + *(_DWORD *)(a2 + 4);
  v32 = (unsigned int)(*(_DWORD *)(a2 + 8) + 7) >> 3;
  v31 = 0;
  while ( 1 )
  {
    v4 = 0;
    v33 = v3 - v31 - 1;
    do
    {
      v5 = sub_10024F60(a1, v31, v4);
      v6 = sub_10024F60(a2, 0, 0);
      sub_10024F80(v5, v6);
      v7 = sub_10024F60(a1, v33, v4);
      v8 = sub_10024F60(a2, *(_DWORD *)a2 - 1, 0);
      sub_10024F80(v7, v8);
      v9 = sub_10024F60(a1, v31, v34 - v4 - 1);
      v10 = sub_10024F60(a2, 0, *(_DWORD *)(a2 + 4) - 1);
      sub_10024F80(v9, v10);
      v11 = sub_10024F60(a1, v33, v34 - v4 - 1);
      v12 = sub_10024F60(a2, *(_DWORD *)a2 - 1, *(_DWORD *)(a2 + 4) - 1);
      sub_10024F80(v11, v12);
      ++v4;
    }
    while ( v4 <= a3 );
    if ( ++v31 > a3 )
      break;
    v3 = v35;
  }
  v13 = 0;
  do
  {
    v14 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v15 = (const void *)sub_10024F60(a2, 0, 1);
    v16 = (void *)sub_10024F60(a1, v13, a3 + 1);
    memcpy(v16, v15, v14);
    ++v13;
  }
  while ( v13 <= a3 );
  for ( i = 1; i < *(_DWORD *)a2 - 1; ++i )
  {
    v18 = 0;
    do
    {
      v19 = sub_10024F60(a1, a3 + i, v18);
      v20 = sub_10024F60(a2, i, 0);
      sub_10024F80(v19, v20);
      v21 = sub_10024F60(a1, i + a3, v34 - v18 - 1);
      v22 = sub_10024F60(a2, i, *(_DWORD *)(a2 + 4) - 1);
      sub_10024F80(v21, v22);
      ++v18;
    }
    while ( v18 <= a3 );
    v23 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v24 = (const void *)sub_10024F60(a2, i, 1);
    v25 = (void *)sub_10024F60(a1, a3 + i, a3 + 1);
    memcpy(v25, v24, v23);
  }
  v26 = 0;
  do
  {
    v27 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v28 = (const void *)sub_10024F60(a2, *(_DWORD *)a2 - 1, 1);
    v29 = (void *)sub_10024F60(a1, v35 - v26 - 1, a3 + 1);
    result = memcpy(v29, v28, v27);
    ++v26;
  }
  while ( v26 <= a3 );
  return result;
}

//----- (100253E0) --------------------------------------------------------
void __cdecl sub_100253E0(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  unsigned int v4; // esi@3
  unsigned int v5; // edi@4
  unsigned int v6; // ecx@4
  char v7; // al@4

  v2 = 0;
  if ( *(_DWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    do
    {
      v4 = 0;
      if ( v3 )
      {
        do
        {
          v5 = sub_10024F60(a1, v2, v4);
          v6 = sub_10024F60(a2, v2, v4++);
          v7 = (signed int)((double)*(_BYTE *)(v5 + 2) * 0.300000011920929
                          + (double)*(_BYTE *)(v5 + 1) * 0.5899999737739563
                          + (double)*(_BYTE *)v5 * 0.1099999994039536);
          *(_BYTE *)(v6 + 2) = v7;
          *(_BYTE *)(v6 + 1) = v7;
          *(_BYTE *)v6 = v7;
          v3 = *(_DWORD *)(a1 + 4);
        }
        while ( v4 < v3 );
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)a1 );
  }
}

//----- (100254B0) --------------------------------------------------------
char __cdecl sub_100254B0(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4)
{
  char result; // al@1

  result = sub_10024EF0(a1);
  if ( result )
  {
    result = sub_10024EF0(a4);
    if ( result )
    {
      sub_10024FA0(a3, a4);
      sub_10024F20(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), a2, a4);
      result = (unsigned int)memcpy(
                               *(void **)(a4 + 12),
                               *(const void **)(a1 + 12),
                               *(_DWORD *)(a1 + 4) * *(_DWORD *)a1 * ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3));
    }
  }
  return result;
}

//----- (10025520) --------------------------------------------------------
int __usercall sub_10025520@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9)
{
  int (__cdecl *v9)(unsigned int); // edi@1
  long double v10; // st7@1
  unsigned int v11; // ecx@1
  signed int v12; // kr00_4@1
  int v13; // ebx@1
  int v14; // esi@3
  int result; // eax@5
  double v16; // st6@7
  int v17; // eax@7
  double v18; // st3@7
  int v19; // edi@9
  double v20; // rt0@11
  double v21; // st3@11
  double v22; // st6@11
  int v23; // eax@11
  int v24; // ecx@12
  int v25; // ebp@14
  float *v26; // esi@14
  unsigned int v27; // eax@15
  signed int v28; // ecx@15
  float v29; // ST50_4@15
  signed int v30; // edx@15
  signed int v31; // eax@15
  int v32; // ecx@20
  double v33; // st2@20
  double v34; // rtt@21
  double v35; // rt0@23
  double v36; // st2@23
  double v37; // st3@23
  double v38; // rtt@26
  unsigned int v39; // eax@28
  bool v40; // sf@28
  unsigned __int8 v41; // of@28
  float v42; // [sp+8h] [bp-48h]@11
  int v43; // [sp+Ch] [bp-44h]@8
  int v44; // [sp+10h] [bp-40h]@9
  int v45; // [sp+14h] [bp-3Ch]@6
  int v46; // [sp+18h] [bp-38h]@7
  int v47; // [sp+20h] [bp-30h]@11
  signed int v48; // [sp+24h] [bp-2Ch]@1
  int v49; // [sp+28h] [bp-28h]@12
  float v50; // [sp+30h] [bp-20h]@22
  float v51; // [sp+34h] [bp-1Ch]@11
  float v52; // [sp+38h] [bp-18h]@11
  float v53; // [sp+3Ch] [bp-14h]@11
  char v54; // [sp+40h] [bp-10h]@6

  v9 = a2;
  v10 = sqrt((double)a1);
  v11 = (signed int)v10;
  v12 = (signed int)v10;
  v13 = (signed int)v10 / 2;
  v48 = (signed int)v10;
  if ( v9 && a7 )
  {
    v14 = a3;
    if ( *(_DWORD *)(a3 + 4) >= v11 || *(_DWORD *)a3 >= v11 )
    {
      *(_DWORD *)a9 = 0;
      sub_10024F20(2 * v13 + *(_DWORD *)a3, 2 * v13 + *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8), v9, (int)&v54);
      sub_10025160((int)&v54, a3, v12 / 2);
      v45 = v12 / 2;
      if ( v13 < v13 + *(_DWORD *)a3 )
      {
        v16 = 0.0;
        v17 = v13 + *(_DWORD *)(a3 + 4);
        v46 = 0;
        v18 = a6;
        do
        {
          v43 = v12 / 2;
          if ( v13 < v17 )
          {
            v19 = v12 / -2;
            v44 = 0;
            while ( 1 )
            {
              v20 = v18;
              v21 = v16;
              v22 = v20;
              v51 = 0.0;
              v42 = v21;
              v52 = 0.0;
              v53 = 0.0;
              v23 = v19;
              v47 = v19;
              if ( v19 <= v13 )
              {
                v24 = v48 * (v19 + v13);
                v49 = v48 * (v19 + v13);
                do
                {
                  if ( v19 <= v13 )
                  {
                    v25 = v23 + v45;
                    v26 = (float *)(a4 + 4 * (v13 + v19 + v24));
                    do
                    {
                      v27 = sub_10024F60((int)&v54, v25, v19 + v43);
                      v28 = *(_BYTE *)(v27 + 2);
                      v29 = *v26;
                      v30 = *(_BYTE *)(v27 + 1);
                      v31 = *(_BYTE *)v27;
                      ++v19;
                      ++v26;
                      v51 = (double)v28 * v29 + v51;
                      v52 = (double)v30 * v29 + v52;
                      v53 = (double)v31 * v29 + v53;
                      v42 = v29 + v42;
                    }
                    while ( v19 <= v13 );
                    v14 = a3;
                    v23 = v47;
                    v24 = v49;
                    v19 = v12 / -2;
                  }
                  v24 += v48;
                  v47 = ++v23;
                  v49 = v24;
                }
                while ( v23 <= v13 );
              }
              if ( v21 == v22 )
                v22 = v42;
              v32 = 0;
              v33 = a5 + v22;
              while ( 1 )
              {
                v50 = *(&v51 + v32) / v33;
                *(&v51 + v32) = v50;
                if ( v50 > v21 )
                {
                  if ( v50 > 255.0 )
                    *(&v51 + v32) = 255.0;
                  v38 = v33;
                  v36 = v21;
                  v37 = v38;
                }
                else
                {
                  v35 = v33;
                  v36 = v21;
                  v37 = v35;
                  *(&v51 + v32) = v36;
                }
                if ( (unsigned int)++v32 >= 3 )
                  break;
                v34 = v36;
                v33 = v37;
                v21 = v34;
              }
              v39 = sub_10024F60(a8, v46, v44++);
              *(_BYTE *)(v39 + 2) = (signed int)v51;
              *(_BYTE *)(v39 + 1) = (signed int)v52;
              *(_BYTE *)v39 = (signed int)v53;
              v17 = *(_DWORD *)(v14 + 4) + v13;
              v41 = __OFSUB__(v43 + 1, v17);
              v40 = v43++ + 1 - v17 < 0;
              v18 = v22;
              v16 = v36;
              if ( !(v40 ^ v41) )
                break;
              v19 = v12 / -2;
            }
          }
          ++v46;
          ++v45;
        }
        while ( v45 < v13 + *(_DWORD *)v14 );
      }
      sub_10024FA0((void (__cdecl *)(_DWORD))a7, (int)&v54);
      result = 0;
    }
    else
    {
      *(_DWORD *)a9 = "Bitmap too small to filter -- filtering has been disabled";
      sub_100254B0(a3, v9, (void (__cdecl *)(_DWORD))a7, a8);
      result = 0;
    }
  }
  else
  {
    *(_DWORD *)a9 = "Dynamic memory function pointers are required for bitmap filtering";
    result = 1;
  }
  return result;
}

//----- (10025880) --------------------------------------------------------
int __usercall sub_10025880@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7)
{
  int (__cdecl *v7)(unsigned int); // edi@1
  int v8; // esi@1
  unsigned int v9; // ebx@1
  int v10; // ebp@1
  unsigned int v11; // edi@2
  unsigned int v12; // eax@3
  int v13; // eax@6
  int v15; // [sp+24h] [bp-20h]@1
  int v16; // [sp+34h] [bp-10h]@1

  v7 = a1;
  v8 = a2;
  sub_10024F20(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(a2 + 8), a1, (int)&v16);
  sub_100250B0(v8, a3, (int)&v16);
  sub_10024F20(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(v8 + 8), v7, (int)&v15);
  v9 = 0;
  v10 = sub_10025520(9u, v7, (int)&v16, (int)&unk_1009F5B8, 0.0, 0.0, (int)a5, (int)&v15, a7);
  if ( *(_DWORD *)v8 )
  {
    do
    {
      v11 = 0;
      if ( *(_DWORD *)(v8 + 4) )
      {
        do
        {
          v12 = sub_10024F60((int)&v15, v9, v11);
          if ( *(_BYTE *)(v12 + 2) > a4 || *(_BYTE *)(v12 + 1) > a4 || *(_BYTE *)v12 > a4 )
          {
            v10 = 4;
            v13 = sub_10024F60(a6, v9, v11);
            sub_10024F80(v13, (int)&unk_1009F5DC);
          }
          ++v11;
        }
        while ( v11 < *(_DWORD *)(v8 + 4) );
      }
      ++v9;
    }
    while ( v9 < *(_DWORD *)v8 );
  }
  sub_10024FA0(a5, (int)&v15);
  sub_10024FA0(a5, (int)&v16);
  return v10;
}

//----- (10025990) --------------------------------------------------------
int __cdecl sub_10025990(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10)
{
  bool v10; // cl@6
  bool v11; // al@13
  bool v12; // zf@16
  int result; // eax@16
  const char *v14; // ecx@17
  int v15; // ecx@22
  int v16; // eax@23
  char v17; // [sp+Bh] [bp-5h]@1
  const char *v18; // [sp+Ch] [bp-4h]@1

  v17 = 0;
  v18 = 0;
  v10 = a2 && *(_DWORD *)a2 && *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 12);
  v11 = a3 && *(_DWORD *)a3 && *(_DWORD *)(a3 + 4) && *(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 12);
  if ( !v10 )
  {
    v12 = v11 == 0;
    result = 2;
    if ( v12 )
      v14 = "Actual and Expected bitmaps unavailable";
    else
      v14 = "Actual bitmap is unavailable";
    goto LABEL_33;
  }
  if ( !v11 )
  {
    v14 = "Expected bitmap is unavailable";
    result = 2;
    goto LABEL_33;
  }
  if ( *(_DWORD *)a2 != *(_DWORD *)a3
    || (v15 = *(_DWORD *)(a2 + 4), v15 != *(_DWORD *)(a3 + 4))
    || (v16 = *(_DWORD *)(a2 + 8), v16 != *(_DWORD *)(a3 + 8)) )
  {
    v14 = "Bitmap sizes are different";
    result = 3;
    goto LABEL_33;
  }
  if ( !a6 || !a7 )
  {
    v14 = "Dynamic memory function pointers are required for comparison (build environment error)";
    result = 1;
    goto LABEL_33;
  }
  sub_10024F20(*(_DWORD *)a2, v15, v16, a6, a8);
  sub_100253E0(a3, a8);
  if ( a1 )
    result = sub_10025880(a6, a2, a3, a4, a7, a8, (int)&v18);
  else
    result = sub_10024FD0((_DWORD *)a2, a3, a4, a8, &v18);
  if ( !a5 )
    goto LABEL_48;
  if ( result == 4 )
  {
    result = 0;
LABEL_32:
    v14 = v18;
    goto LABEL_33;
  }
  if ( result )
  {
LABEL_48:
    if ( result != 4 )
      goto LABEL_32;
  }
  else
  {
    result = 4;
  }
  if ( a5 )
  {
    v14 = "Images match";
  }
  else
  {
    v17 = 1;
    v14 = "Pixel mismatch";
  }
LABEL_33:
  if ( a10 )
    *a10 = v14;
  if ( a9 )
    *a9 = v17;
  return result;
}

//----- (10025B20) --------------------------------------------------------
char __cdecl sub_10025B20(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3)
{
  char v3; // bl@1
  unsigned int v4; // eax@5
  unsigned int v5; // esi@5
  char *v6; // ebp@11
  int v7; // esi@11
  unsigned int v8; // ebx@11
  int v9; // edi@11
  char result; // al@20
  char v11; // [sp+8h] [bp-40h]@14
  unsigned int v12; // [sp+Ch] [bp-3Ch]@5
  __int16 v13; // [sp+10h] [bp-38h]@6
  int v14; // [sp+1Ah] [bp-2Eh]@8
  char v15; // [sp+20h] [bp-28h]@9
  int v16; // [sp+24h] [bp-24h]@11
  unsigned int v17; // [sp+28h] [bp-20h]@11
  unsigned __int16 v18; // [sp+2Eh] [bp-1Ah]@10
  char v19; // [sp+4Ch] [bp+4h]@11

  v3 = 0;
  if ( a1 && a2 && *a2 )
  {
    if ( a3 )
    {
      v4 = sub_10024C30((int)a2, 0);
      v5 = v4;
      v12 = v4;
      if ( v4 )
      {
        if ( sub_10024C90(&v13, 14, v4) == 14
          && v13 == 19778
          && v14 == 54
          && sub_10024C90(&v15, 40, v5) == 40
          && v18 == 24 )
        {
          sub_10024F20(v17, v16, 24, a1, a3);
          v6 = *(char **)(a3 + 12);
          v7 = v16 * (((unsigned int)v18 + 7) >> 3);
          v8 = 0;
          v9 = -(v16 * (((unsigned int)v18 + 7) >> 3)) & 3;
          v19 = 1;
          if ( v17 )
          {
            while ( sub_10024C90(v6, v7, v12) == v7 && (!v9 || sub_10024C90(&v11, v9, v12) == v9) )
            {
              ++v8;
              v6 += v7;
              if ( v8 >= v17 )
                goto LABEL_18;
            }
            v19 = 0;
          }
LABEL_18:
          v3 = v19;
          v5 = v12;
        }
        sub_10024BE0(v5);
      }
      result = v3;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10025C70) --------------------------------------------------------
char __usercall sub_10025C70@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // esi@1
  int v7; // edi@1
  int v8; // eax@1
  int v9; // eax@1
  unsigned int v10; // ebx@1
  int v12; // [sp+10h] [bp-40h]@4
  int v13; // [sp+14h] [bp-3Ch]@4
  __int16 v14; // [sp+18h] [bp-38h]@1
  int v15; // [sp+1Ah] [bp-36h]@1
  __int16 v16; // [sp+1Eh] [bp-32h]@1
  __int16 v17; // [sp+20h] [bp-30h]@1
  int v18; // [sp+22h] [bp-2Eh]@1
  int v19; // [sp+28h] [bp-28h]@1
  int v20; // [sp+2Ch] [bp-24h]@1
  unsigned int v21; // [sp+30h] [bp-20h]@1
  __int16 v22; // [sp+34h] [bp-1Ch]@1
  __int16 v23; // [sp+36h] [bp-1Ah]@1
  int v24; // [sp+38h] [bp-18h]@1
  int v25; // [sp+3Ch] [bp-14h]@1
  int v26; // [sp+40h] [bp-10h]@1
  int v27; // [sp+44h] [bp-Ch]@1
  int v28; // [sp+48h] [bp-8h]@1
  int v29; // [sp+4Ch] [bp-4h]@1
  char v30; // [sp+54h] [bp+4h]@1

  v5 = a3;
  v6 = a1 * ((unsigned int)(a2 + 7) >> 3);
  v7 = -(a1 * ((unsigned int)(a2 + 7) >> 3)) & 3;
  v8 = a3 * (v7 + v6);
  v25 = v8;
  v15 = v8 + 54;
  v16 = 0;
  v17 = 0;
  v29 = 0;
  v28 = 0;
  v24 = 0;
  v26 = 0;
  v27 = 0;
  v30 = 0;
  v14 = 19778;
  v18 = 54;
  v19 = 40;
  v23 = a2;
  v21 = v5;
  v20 = a1;
  v22 = 1;
  v9 = sub_10024C30(a5, 1);
  v10 = v9;
  if ( v9 )
  {
    if ( sub_10024CB0((int)&v14, 14, v9) == 14 && sub_10024CB0((int)&v19, 40, v10) == 40 )
    {
      v30 = 1;
      v12 = a4;
      v13 = 0;
      if ( v5 )
      {
        while ( sub_10024CB0(v12, v6, v10) == v6 && (!v7 || sub_10024CB0((int)&unk_1009F780, v7, v10) == v7) )
        {
          v12 += v6;
          if ( ++v13 >= v5 )
          {
            sub_10024BE0(v10);
            return 1;
          }
        }
        v30 = 0;
      }
    }
    sub_10024BE0(v10);
  }
  return v30;
}

//----- (10025DC0) --------------------------------------------------------
char __cdecl sub_10025DC0(int a1, int a2)
{
  char result; // al@2

  if ( sub_10024EF0(a1) )
    result = sub_10025C70(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)a1, *(_DWORD *)(a1 + 12), a2);
  else
    result = 0;
  return result;
}

//----- (10025E00) --------------------------------------------------------
char __cdecl sub_10025E00(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@11
  int v4; // eax@16
  int v6; // [sp+8h] [bp-54h]@1
  int v7; // [sp+Ch] [bp-50h]@1
  int v8; // [sp+10h] [bp-4Ch]@1
  int v9; // [sp+14h] [bp-48h]@1
  int v10; // [sp+18h] [bp-44h]@1
  char v11; // [sp+1Ch] [bp-40h]@16

  LOBYTE(v2) = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( a1 == 28 || a1 == 29 || a1 == 30 || a1 == 31 || a1 == 32 || a1 == 48 || a1 == 33 || a1 == 34 )
  {
    v2 = sub_10019B30((_DWORD *)a2, 2u, (int)&unk_1009F7E8, 8, 77, 77);
    if ( v2 != 77 )
    {
      if ( *(_WORD *)a2 == -32768 )
      {
        v3 = *(_WORD *)(a2 + 10) + 16;
      }
      else if ( *(_WORD *)a2 == -32767 )
      {
        v3 = *(_DWORD *)(a2 + 4) + 8;
      }
      else
      {
        v3 = dword_1009F7EC[2 * v2] + 4;
      }
      v7 = v3;
      v10 = 65;
      v6 = a2;
      v9 = 10;
      v2 = sub_10033010(a1, (int)&v6);
      if ( v2 == 16 )
      {
        v4 = sub_10032E30();
        sub_1000A7B0(&v11, 0x3Cu, "message queue timed out sending from: %d to %d", v4, a1);
        LOBYTE(v2) = sub_10011520("..\\lib\\adl\\iop_msg_intf.c", 433, 0, &v11);
      }
    }
  }
  return v2;
}
// 1009F7EC: using guessed type int dword_1009F7EC[];

//----- (10025F20) --------------------------------------------------------
char __cdecl sub_10025F20(int a1)
{
  return sub_10025E00(28, a1);
}

//----- (10025F30) --------------------------------------------------------
char __cdecl sub_10025F30(int a1)
{
  return sub_10025E00(29, a1);
}

//----- (10025F40) --------------------------------------------------------
char __cdecl sub_10025F40(int a1)
{
  return sub_10025E00(32, a1);
}

//----- (10025F50) --------------------------------------------------------
int __cdecl sub_10025F50(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10019080(a1, 0, 0xDu, 0xDu, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10025F80) --------------------------------------------------------
int __cdecl sub_10025F80(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10019080(a1, 0, 8u, 8u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10025FB0) --------------------------------------------------------
int __cdecl sub_10025FB0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10019080(a1, 0, 9u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10025FE0) --------------------------------------------------------
int __cdecl sub_10025FE0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10019080(a1, 0, 8u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10026010) --------------------------------------------------------
int __cdecl sub_10026010(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10019080(a1, 0, 0x14u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10026040) --------------------------------------------------------
signed int __cdecl sub_10026040(unsigned __int8 *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10019080(a1, 0, 0xFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10026070) --------------------------------------------------------
int __cdecl sub_10026070(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10019080(a1, 0, 6u, 6u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100260A0) --------------------------------------------------------
int __cdecl sub_100260A0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10019080(a1, 0, 7u, 7u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100260D0) --------------------------------------------------------
int __cdecl sub_100260D0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10019080(a1, 0, 0xFu, 0xFu, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10026100) --------------------------------------------------------
int __cdecl sub_10026100(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10019080(a1, 0, 0xEu, 0xEu, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10026130) --------------------------------------------------------
int __cdecl sub_10026130(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10019080(a1, 0, 0xBu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10026160) --------------------------------------------------------
int __cdecl sub_10026160(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10019080(a1, 0, 0x13u, 0x13u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10026190) --------------------------------------------------------
int __cdecl sub_10026190(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10019080(a1, 0, 2u, 2u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100261C0) --------------------------------------------------------
int __cdecl sub_100261C0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10019080(a1, 0, 3u, 3u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100261F0) --------------------------------------------------------
unsigned int __cdecl sub_100261F0(char *a1)
{
  return sub_10018E70(a1, -100, 100, 0, 0);
}

//----- (10026210) --------------------------------------------------------
int __cdecl sub_10026210(_BYTE *a1)
{
  return sub_10019170(a1, 0x1CCF0u, 0x2171Eu, 0x2171Eu, 0);
}

//----- (10026230) --------------------------------------------------------
int __cdecl sub_10026230(unsigned __int8 *a1)
{
  return sub_10019080(a1, 0, 1u, 1u, 0);
}

//----- (10026250) --------------------------------------------------------
int __cdecl sub_10026250(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10019080(a1, 0, 3u, 2u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10026280) --------------------------------------------------------
unsigned int __cdecl sub_10026280(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_10018D30((_BYTE *)(a1 + 6), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_10019080((unsigned __int8 *)(a1 + 12), 0, 0xFFu, 0, a2) == 1 )
    v2 = 1;
  result = sub_10018D30((_BYTE *)a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 2), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 9), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 3), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018E70((char *)(a1 + 14), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10019080((unsigned __int8 *)(a1 + 7), 0, 0x40u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 10), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 5), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 11), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10019080((unsigned __int8 *)(a1 + 4), 0, 0x40u, 0x30u, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 1), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018E70((char *)(a1 + 17), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 24), 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (100265B0) --------------------------------------------------------
unsigned int __cdecl sub_100265B0(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_10018D30((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 24), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 26), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018E70((char *)(a1 + 10), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 31), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 28), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 17), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018E70((char *)(a1 + 13), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018E70((char *)(a1 + 5), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018E70((char *)a1, -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018E70((char *)(a1 + 1), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018E70((char *)(a1 + 2), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018E70((char *)(a1 + 3), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018E70((char *)(a1 + 4), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018E70((char *)(a1 + 12), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018E70((char *)(a1 + 11), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018E70((char *)(a1 + 7), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018E70((char *)(a1 + 9), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 25), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018E70((char *)(a1 + 6), -31, 31, 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (100269F0) --------------------------------------------------------
unsigned int __cdecl sub_100269F0(_BYTE *a1)
{
  return sub_10018F60(a1, -1, 5, -1, 0);
}

//----- (10026A10) --------------------------------------------------------
int __cdecl sub_10026A10(unsigned __int8 *a1)
{
  return sub_10019080(a1, 0, 5u, 0, 0);
}

//----- (10026A30) --------------------------------------------------------
int __cdecl sub_10026A30(unsigned __int8 *a1)
{
  return sub_10019080(a1, 0, 4u, 2u, 0);
}

//----- (10026A50) --------------------------------------------------------
int __cdecl sub_10026A50(_BYTE *a1)
{
  return sub_10019170(a1, 0, 2u, 0, 0);
}

//----- (10026A70) --------------------------------------------------------
int __cdecl sub_10026A70(int a1)
{
  return sub_10018D80(a1, 0.1, 4.0, COERCE_INT(1.5), 0);
}

//----- (10026AC0) --------------------------------------------------------
int __cdecl sub_10026AC0(unsigned __int8 *a1)
{
  int result; // eax@1

  result = sub_10026A70((int)(a1 + 4));
  if ( !result )
    result = sub_10026A30(a1);
  return result;
}

//----- (10026AE0) --------------------------------------------------------
int __cdecl sub_10026AE0(int a1)
{
  int result; // eax@1

  result = sub_10026A10((unsigned __int8 *)(a1 + 1));
  if ( !result )
  {
    result = sub_10026A10((unsigned __int8 *)(a1 + 2));
    if ( !result )
    {
      result = sub_10026A10((unsigned __int8 *)(a1 + 3));
      if ( !result )
      {
        result = sub_1002F450((unsigned __int8 *)(a1 + 7));
        if ( !result )
        {
          result = sub_10018D30((_BYTE *)(a1 + 5), 0, 0);
          if ( !result )
          {
            result = sub_10018D30((_BYTE *)a1, 0, 0);
            if ( !result )
            {
              result = sub_10018D30((_BYTE *)(a1 + 4), 0, 0);
              if ( !result )
                result = sub_10018D30((_BYTE *)(a1 + 6), 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (10026B70) --------------------------------------------------------
unsigned int __cdecl sub_10026B70(int a1)
{
  unsigned int result; // eax@1

  result = sub_100269F0((_BYTE *)a1);
  if ( !result )
    result = sub_100269F0((_BYTE *)(a1 + 4));
  return result;
}

//----- (10026B90) --------------------------------------------------------
signed int __cdecl sub_10026B90(int a1)
{
  int v1; // esi@1
  signed int result; // eax@2
  signed int v3; // esi@4

  v1 = 0;
  while ( 1 )
  {
    result = sub_10018D30((_BYTE *)(v1 + a1), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      v3 = 0;
      do
      {
        result = sub_10018D30((_BYTE *)(a1 + v3 + 6), 0, 0);
        if ( result )
          break;
        ++v3;
      }
      while ( v3 < 6 );
      return result;
    }
  }
  return result;
}

//----- (10026BE0) --------------------------------------------------------
unsigned int __cdecl sub_10026BE0(int a1)
{
  unsigned int result; // eax@1

  result = sub_100269F0((_BYTE *)a1);
  if ( !result )
  {
    result = sub_100269F0((_BYTE *)(a1 + 4));
    if ( !result )
    {
      result = sub_100269F0((_BYTE *)(a1 + 8));
      if ( !result )
      {
        result = sub_100269F0((_BYTE *)(a1 + 12));
        if ( !result )
          result = sub_10018D30((_BYTE *)(a1 + 16), 1, 0);
      }
    }
  }
  return result;
}

//----- (10026C40) --------------------------------------------------------
int __cdecl sub_10026C40(_BYTE *a1)
{
  return sub_10019170(a1, 0, 0x20u, 2u, 0);
}

//----- (10026C60) --------------------------------------------------------
unsigned int __cdecl sub_10026C60(_BYTE *a1)
{
  return sub_10018F60(a1, -1, 4, -1, 0);
}

//----- (10026C80) --------------------------------------------------------
int __cdecl sub_10026C80(unsigned __int8 *a1)
{
  return sub_10019080(a1, 0, 9u, 0, 0);
}

//----- (10026CA0) --------------------------------------------------------
int __cdecl sub_10026CA0(_BYTE *a1)
{
  return sub_10019170(a1, 0x81u, 0xFFu, 0xC0u, 0);
}

//----- (10026CC0) --------------------------------------------------------
signed int __cdecl sub_10026CC0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10019170(a1, 0, 0xFFFFFFFF, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10026CF0) --------------------------------------------------------
int __cdecl sub_10026CF0(_BYTE *a1)
{
  return sub_100190D0(a1, 0, 0xFFFu, 640, 0);
}

//----- (10026D10) --------------------------------------------------------
int __cdecl sub_10026D10(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_100190D0(a1, 0, 0xFFFu, 640, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10026D50) --------------------------------------------------------
int __cdecl sub_10026D50(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@3

  v2 = 0;
  if ( sub_10026CC0((_BYTE *)(a1 + 8), a2) == 1 )
    v2 = 1;
  result = sub_10026D10((_BYTE *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10026D10((_BYTE *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002F6E0((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10026D10((_BYTE *)(a1 + 6), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10026DE0) --------------------------------------------------------
int __cdecl sub_10026DE0(unsigned __int8 *a1)
{
  return sub_10019080(a1, 0, 2u, 0, 0);
}

//----- (10026E00) --------------------------------------------------------
int __cdecl sub_10026E00(int a1)
{
  int result; // eax@1

  result = sub_10019080((unsigned __int8 *)a1, 0, 0x78u, 0, 0);
  if ( !result )
    result = sub_10019080((unsigned __int8 *)(a1 + 1), 0, 0x78u, 0, 0);
  return result;
}

//----- (10026E30) --------------------------------------------------------
int __cdecl sub_10026E30(unsigned __int8 *a1)
{
  return sub_10019080(a1, 0, 3u, 1u, 0);
}

//----- (10026E50) --------------------------------------------------------
unsigned int __cdecl sub_10026E50(int a1)
{
  unsigned int result; // eax@1

  result = sub_10018F60((_BYTE *)a1, -1, 5, -1, 0);
  if ( !result )
    result = sub_10018F60((_BYTE *)(a1 + 4), -1, 5, -1, 0);
  return result;
}

//----- (10026E80) --------------------------------------------------------
int __cdecl sub_10026E80(int a1)
{
  int result; // eax@1

  result = sub_10018D80(a1, 0.0, 5.0, COERCE_INT(0.23), 0);
  if ( !result )
  {
    result = sub_10018D80(a1 + 4, -10.0, 10.0, COERCE_INT(0.0), 0);
    if ( !result )
    {
      result = sub_10018D80(a1 + 8, 0.0, 12.9, COERCE_INT(0.86000001), 0);
      if ( !result )
      {
        result = sub_10018D80(a1 + 12, 0.0, 5.0, COERCE_INT(0.23), 0);
        if ( !result )
          result = sub_10018D80(a1 + 16, -10.0, 10.0, COERCE_INT(0.0), 0);
      }
    }
  }
  return result;
}

//----- (10026F70) --------------------------------------------------------
int __cdecl sub_10026F70(int a1)
{
  int v1; // edi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_10018D30((_BYTE *)(a1 + v1 + 44), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      result = sub_10019080((unsigned __int8 *)(a1 + 1), 0, 3u, 1u, 0);
      if ( !result )
      {
        result = sub_10026E50(a1 + 36);
        if ( !result )
        {
          result = sub_10018D80(a1 + 52, -9.9999996e24, 9.9999996e24, COERCE_INT(77.166664), 0);
          if ( !result )
          {
            result = sub_10026E80(a1 + 8);
            if ( !result )
            {
              result = sub_10026E50(a1 + 28);
              if ( !result )
              {
                result = sub_100190D0((_BYTE *)(a1 + 2), 0x1F4u, 0x800u, 600, 0);
                if ( !result )
                {
                  result = sub_10026DE0((unsigned __int8 *)(a1 + 50));
                  if ( !result )
                  {
                    result = sub_10026E00(a1 + 57);
                    if ( !result )
                    {
                      result = sub_10018D30((_BYTE *)(a1 + 56), 0, 0);
                      if ( !result )
                        result = sub_10026E30((unsigned __int8 *)(a1 + 51));
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
  }
  return result;
}

//----- (10027080) --------------------------------------------------------
signed int __cdecl sub_10027080(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_100190D0(a1, 0, 0xFFFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (100270B0) --------------------------------------------------------
int __cdecl sub_100270B0(int a1)
{
  int v1; // edi@1
  signed int v2; // esi@1
  int result; // eax@2

  v1 = a1;
  v2 = 0;
  do
  {
    result = sub_10028060(v1);
    if ( result )
      break;
    ++v2;
    v1 += 232;
  }
  while ( v2 < 14 );
  return result;
}

//----- (100270E0) --------------------------------------------------------
signed int __cdecl sub_100270E0(int a1, int a2)
{
  signed int v2; // ebx@1
  signed int result; // eax@9

  v2 = 0;
  if ( sub_10026040((unsigned __int8 *)(a1 + 15), a2) == 1 )
    v2 = 1;
  if ( sub_10026040((unsigned __int8 *)(a1 + 34), a2) == 1 )
    v2 = 1;
  if ( sub_10026040((unsigned __int8 *)(a1 + 38), a2) == 1 )
    v2 = 1;
  if ( sub_10026040((unsigned __int8 *)(a1 + 36), a2) == 1 )
    v2 = 1;
  result = sub_10018D30((_BYTE *)(a1 + 33), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025F80((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025F50((unsigned __int8 *)(a1 + 48), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025FE0((unsigned __int8 *)(a1 + 46), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025F50((unsigned __int8 *)(a1 + 47), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10026010((unsigned __int8 *)(a1 + 45), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025FB0((unsigned __int8 *)(a1 + 44), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025F50((unsigned __int8 *)(a1 + 28), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10026250((unsigned __int8 *)(a1 + 51), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10026130((unsigned __int8 *)(a1 + 31), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_1002F560((_BYTE *)(a1 + 20), a2) == 1 )
    v2 = 1;
  result = sub_10027760((unsigned __int8 *)(a1 + 50), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025F50((unsigned __int8 *)(a1 + 24), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10026070((unsigned __int8 *)(a1 + 5), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025F50((unsigned __int8 *)(a1 + 25), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100260A0((unsigned __int8 *)(a1 + 6), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025F50((unsigned __int8 *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100260D0((unsigned __int8 *)(a1 + 3), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D80(a1 + 40, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025F50((unsigned __int8 *)(a1 + 26), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025F80((unsigned __int8 *)(a1 + 9), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025F50((unsigned __int8 *)(a1 + 8), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10026100((unsigned __int8 *)(a1 + 7), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10026130((unsigned __int8 *)(a1 + 1), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100261C0((unsigned __int8 *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100261C0((unsigned __int8 *)(a1 + 10), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 37), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10026160((unsigned __int8 *)(a1 + 11), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025F50((unsigned __int8 *)(a1 + 12), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30((_BYTE *)(a1 + 32), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10027760((unsigned __int8 *)(a1 + 49), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D80(a1 + 16, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100261C0((unsigned __int8 *)(a1 + 35), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (100275F0) --------------------------------------------------------
int __cdecl sub_100275F0(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_10019170(a1, 0, 0x3FFFFu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10027620) --------------------------------------------------------
signed int __cdecl sub_10027620(_BYTE *a1, int a2)
{
  signed int v2; // ebx@1
  signed int result; // eax@1

  v2 = 0;
  result = sub_10018D30(a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D80((int)(a1 + 4), -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10027690) --------------------------------------------------------
int __cdecl sub_10027690(unsigned __int8 *a1)
{
  return sub_10019080(a1, 0, 0x64u, 0x64u, 0);
}

//----- (100276F0) --------------------------------------------------------
int __cdecl sub_100276F0(int a1)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_10018D30((_BYTE *)(v1 + a1 + 4), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 3 )
      return sub_10027690((unsigned __int8 *)(a1 + 10));
  }
  return result;
}

//----- (10027700) --------------------------------------------------------
int __cdecl sub_10027700(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10019080(a1, 0, 3u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10027730) --------------------------------------------------------
int __cdecl sub_10027730(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10019080(a1, 0, 6u, 2u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10027760) --------------------------------------------------------
int __cdecl sub_10027760(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10019080(a1, 0, 5u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10027790) --------------------------------------------------------
signed int __cdecl sub_10027790(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10019170(a1, 0, 0xFFFFFFFF, 0xFFFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (100277C0) --------------------------------------------------------
int __cdecl sub_100277C0(int a1, int a2)
{
  signed int v2; // ebp@1
  unsigned __int8 v3; // bl@1
  int result; // eax@3

  v2 = 0;
  v3 = 0;
  do
  {
    switch ( v3 )
    {
      case 4u:
      case 5u:
      case 6u:
      case 9u:
      case 0xAu:
        result = sub_10019080((unsigned __int8 *)(a1 + v3), 0, 0x3Fu, 0, a2);
        break;
      default:
        result = sub_10019080((unsigned __int8 *)(a1 + v3), 0, 0xFFu, 0xFFu, a2);
        break;
    }
    if ( result == 1 )
    {
      v2 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v3;
  }
  while ( v3 < 0xDu );
  return v2;
}

//----- (10027860) --------------------------------------------------------
signed int __cdecl sub_10027860(int a1)
{
  signed int result; // eax@1

  result = sub_10018D30((_BYTE *)(a1 + 5), 0, 0);
  if ( !result )
  {
    result = sub_10018D30((_BYTE *)a1, 0, 0);
    if ( !result )
    {
      result = sub_10018D30((_BYTE *)(a1 + 6), 0, 0);
      if ( !result )
      {
        result = sub_10018D30((_BYTE *)(a1 + 7), 0, 0);
        if ( !result )
        {
          result = sub_1002F710((unsigned __int8 *)(a1 + 2));
          if ( !result )
          {
            result = sub_1002F710((unsigned __int8 *)(a1 + 3));
            if ( !result )
            {
              result = sub_1002F710((unsigned __int8 *)(a1 + 4));
              if ( !result )
                result = sub_10018D30((_BYTE *)(a1 + 1), 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (10027900) --------------------------------------------------------
int __cdecl sub_10027900(int a1)
{
  int result; // eax@1

  result = sub_10027F70((_BYTE *)(a1 + 3272));
  if ( !result )
  {
    result = sub_10027F70((_BYTE *)(a1 + 3274));
    if ( !result )
    {
      result = sub_1002F710((unsigned __int8 *)(a1 + 14));
      if ( !result )
      {
        result = sub_100278F0(a1 + 24);
        if ( !result )
        {
          result = sub_1002F710((unsigned __int8 *)(a1 + 15));
          if ( !result )
          {
            result = sub_1002F6C0((unsigned __int8 *)(a1 + 12));
            if ( !result )
              result = sub_1002F710((unsigned __int8 *)(a1 + 13));
          }
        }
      }
    }
  }
  return result;
}
// 100278F0: using guessed type _DWORD __cdecl sub_100278F0(_DWORD);

//----- (10027980) --------------------------------------------------------
unsigned int __cdecl sub_10027980(int a1)
{
  unsigned int result; // eax@1

  result = sub_100261F0((char *)(a1 + 3));
  if ( !result )
  {
    result = sub_100261F0((char *)(a1 + 2));
    if ( !result )
    {
      result = sub_100261F0((char *)a1);
      if ( !result )
        result = sub_100261F0((char *)(a1 + 1));
    }
  }
  return result;
}

//----- (100279C0) --------------------------------------------------------
unsigned int __cdecl sub_100279C0(int a1)
{
  signed int v1; // esi@1
  int v2; // edi@1
  unsigned int result; // eax@2

  v1 = 0;
  v2 = a1;
  while ( 1 )
  {
    result = sub_10027980(v2);
    if ( result )
      break;
    ++v1;
    v2 += 4;
    if ( v1 >= 3 )
    {
      result = sub_10026DE0((unsigned __int8 *)(a1 + 12));
      if ( !result )
        result = sub_10026230((unsigned __int8 *)(a1 + 13));
      return result;
    }
  }
  return result;
}

//----- (10027A10) --------------------------------------------------------
int __cdecl sub_10027A10(int a1)
{
  int result; // eax@1

  result = sub_10026210((_BYTE *)(a1 + 4));
  if ( !result )
    result = sub_100190D0((_BYTE *)a1, 0, 0x3FFFu, 0x3FFF, 0);
  return result;
}

//----- (10027A40) --------------------------------------------------------
int __cdecl sub_10027A40(int a1)
{
  int result; // eax@1

  result = sub_10026A50((_BYTE *)a1);
  if ( !result )
    result = sub_10026CA0((_BYTE *)(a1 + 4));
  return result;
}

//----- (10027A70) --------------------------------------------------------
unsigned int __cdecl sub_10027A70(int a1)
{
  unsigned int result; // eax@1

  result = sub_100269F0((_BYTE *)a1);
  if ( !result )
  {
    result = sub_100269F0((_BYTE *)(a1 + 4));
    if ( !result )
      result = sub_10026C60((_BYTE *)(a1 + 8));
  }
  return result;
}

//----- (10027AA0) --------------------------------------------------------
unsigned int __cdecl sub_10027AA0(int a1)
{
  unsigned int result; // eax@1

  result = sub_100269F0((_BYTE *)a1);
  if ( !result )
    result = sub_10026C80((unsigned __int8 *)(a1 + 4));
  return result;
}

//----- (10027AC0) --------------------------------------------------------
unsigned int __cdecl sub_10027AC0(int a1)
{
  unsigned int result; // eax@1

  result = sub_100269F0((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10019080((unsigned __int8 *)(a1 + 8), 0, 0x1Eu, 0x1Eu, 0);
    if ( !result )
      result = sub_10026C60((_BYTE *)(a1 + 4));
  }
  return result;
}

//----- (10027B00) --------------------------------------------------------
void __cdecl __noreturn sub_10027B00(int a1)
{
  exit_0(a1 + 4);
}

//----- (10027C70) --------------------------------------------------------
signed int __cdecl sub_10027C70(int a1, int a2)
{
  signed int v2; // ebx@1
  bool v3; // zf@5
  signed int result; // eax@5

  v2 = 0;
  if ( sub_10026040((unsigned __int8 *)a1, a2) == 1 )
    v2 = 1;
  if ( sub_10027080((_BYTE *)(a1 + 2), a2) == 1 )
    v2 = 1;
  v3 = sub_10026040((unsigned __int8 *)(a1 + 1), a2) == 1;
  result = 1;
  if ( !v3 )
    result = v2;
  return result;
}

//----- (10027CC0) --------------------------------------------------------
int __cdecl sub_10027CC0(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@1

  v2 = 0;
  result = sub_100275F0((_BYTE *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10027620((_BYTE *)(a1 + 4), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10027D10) --------------------------------------------------------
int __cdecl sub_10027D10(_BYTE *a1, int a2)
{
  return sub_10019170(a1, 0, 0x1FEu, 0, a2);
}

//----- (10027D30) --------------------------------------------------------
int __usercall sub_10027D30@<eax>(unsigned __int8 *a1@<eax>, int a2@<edi>)
{
  unsigned __int8 *v2; // esi@1
  signed int v3; // ebx@1
  int result; // eax@1
  int v5; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  result = sub_10026190(a1, v5);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( *v2 == 1 )
    result = sub_10027CC0((int)(v2 + 4), a2);
  else
    result = sub_100270E0((int)(v2 + 4), a2);
  if ( result != 1 && !result )
    result = v3;
  return result;
}

//----- (10027D80) --------------------------------------------------------
signed int __usercall sub_10027D80@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  signed int v3; // ebx@1
  char v4; // al@5
  signed int result; // eax@8
  int v6; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  if ( sub_10027C70(a1, v6) == 1 )
    v3 = 1;
  if ( a2 == 2 )
  {
    *(_BYTE *)(v2 + 1) = 40;
    v3 = 1;
  }
  v4 = *(_BYTE *)(v2 + 1);
  if ( v4 == 26 || v4 == 12 )
  {
    result = sub_10019080((unsigned __int8 *)(v2 + 4), 0x20u, 0x20u, 0x20u, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    result = sub_10018D30((_BYTE *)(v2 + 37), 0, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    if ( *(_BYTE *)(v2 + 1) == 26 )
      result = sub_100265B0(v2 + 5, a2);
    else
      result = sub_10026280(v2 + 5, a2);
    if ( result != 1 )
    {
      if ( result )
        return result;
      goto LABEL_25;
    }
    return 1;
  }
  if ( v4 != 40 )
  {
    if ( a2 != 1 )
      return -4;
    *(_BYTE *)(v2 + 1) = 40;
    return 1;
  }
  result = sub_10027790((_BYTE *)(v2 + 4), a2);
  if ( result != 1 )
LABEL_25:
    result = v3;
  return result;
}

//----- (10027E50) --------------------------------------------------------
int __usercall sub_10027E50@<eax>(unsigned __int8 *a1@<eax>, int a2@<esi>)
{
  unsigned __int8 *v2; // edi@1
  signed int v3; // ebx@1
  int result; // eax@1
  int v5; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  result = sub_10027700(a1, v5);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10027730(v2 + 1, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10018D30(v2 + 2, 0, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10027760(v2 + 3, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10019170(v2 + 8, 0, 0x1E61u, 0x4B0u, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10019170(v2 + 12, 0, 0x1E61u, 0x4B0u, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10027D10(v2 + 4, a2);
  if ( result != 1 && !result )
    result = v3;
  return result;
}

//----- (10027F40) --------------------------------------------------------
int __cdecl sub_10027F40(unsigned __int8 *a1)
{
  return sub_10027D30(a1, 0);
}

//----- (10027F50) --------------------------------------------------------
int __cdecl sub_10027F50(unsigned __int8 *a1)
{
  return sub_10027E50(a1, 0);
}

//----- (10027F60) --------------------------------------------------------
signed int __cdecl sub_10027F60(int a1)
{
  return sub_10027D80(a1, 0);
}

//----- (10027F70) --------------------------------------------------------
int __cdecl sub_10027F70(_BYTE *a1)
{
  return sub_100190D0(a1, 0, 0x2710u, 5000, 0);
}

//----- (10027F90) --------------------------------------------------------
int __cdecl sub_10027F90(unsigned __int8 *a1)
{
  return sub_10019080(a1, 0, 5u, 5u, 0);
}

//----- (10027FB0) --------------------------------------------------------
int __cdecl sub_10027FB0(unsigned __int8 *a1)
{
  return sub_10019080(a1, 0, 6u, 0, 0);
}

//----- (10027FD0) --------------------------------------------------------
int __cdecl sub_10027FD0(unsigned __int8 *a1)
{
  return sub_10019080(a1, 0, 0xEu, 1u, 0);
}

//----- (10027FF0) --------------------------------------------------------
int __cdecl sub_10027FF0(unsigned __int8 *a1)
{
  return sub_10019080(a1, 0, 1u, 0, 0);
}

//----- (10028020) --------------------------------------------------------
int __cdecl sub_10028020(int a1)
{
  int result; // eax@1

  result = sub_10027F90((unsigned __int8 *)a1);
  if ( !result )
  {
    result = sub_10028010(a1 + 12);
    if ( !result )
    {
      result = sub_10027FF0((unsigned __int8 *)(a1 + 1));
      if ( !result )
        result = sub_10027FD0((unsigned __int8 *)(a1 + 2));
    }
  }
  return result;
}
// 10028010: using guessed type _DWORD __cdecl sub_10028010(_DWORD);

//----- (10028060) --------------------------------------------------------
int __cdecl sub_10028060(int a1)
{
  int result; // eax@1

  result = sub_1002F590((void *)(a1 + 28));
  if ( !result )
    result = sub_10028020(a1);
  return result;
}

//----- (10028080) --------------------------------------------------------
signed int __fastcall sub_10028080(unsigned __int8 a1)
{
  signed int result; // eax@1

  result = 176;
  if ( a1 < 0xB0u )
    result = a1;
  return result;
}

//----- (10028090) --------------------------------------------------------
char __cdecl sub_10028090(unsigned __int8 a1)
{
  return byte_100A093C[6 * sub_10028080(a1)];
}

//----- (100280B0) --------------------------------------------------------
__int16 __cdecl sub_100280B0(unsigned __int8 a1)
{
  return word_100A0938[3 * sub_10028080(a1)];
}
// 100A0938: using guessed type __int16 word_100A0938[];

//----- (100280D0) --------------------------------------------------------
int __cdecl sub_100280D0(void *a1, void *a2, size_t a3, int a4, int a5)
{
  int result; // eax@8

  if ( a3 > 4 || a3 == 3 || a3 - 1 > 3 || ((unsigned int)a2 | (unsigned int)a1) & (a3 - 1) )
  {
    if ( sub_10032F80(a4, a5) )
    {
      result = -1;
    }
    else
    {
      memcpy(a1, a2, a3);
      sub_10032F60(a4);
      result = 1;
    }
  }
  else
  {
    switch ( a3 )
    {
      case 1u:
        result = 0;
        *(_BYTE *)a1 = *(_BYTE *)a2;
        break;
      case 2u:
        *(_WORD *)a1 = *(_WORD *)a2;
        result = 0;
        break;
      case 4u:
        result = 0;
        *(_DWORD *)a1 = *(_DWORD *)a2;
        break;
      default:
        memcpy(a1, a2, a3);
        result = 0;
        break;
    }
  }
  return result;
}

//----- (10028180) --------------------------------------------------------
int __cdecl sub_10028180(unsigned __int16 a1)
{
  int v1; // ecx@1
  unsigned __int16 v2; // ax@3
  int result; // eax@4

  v1 = sub_10022790();
  if ( v1 && a1 < 0xFE3u && (v2 = *(_WORD *)(v1 + 2 * a1 + 0x2000), v2 < 0x2000u) )
    result = v1 + v2;
  else
    result = 0;
  return result;
}

//----- (100281C0) --------------------------------------------------------
int __usercall sub_100281C0@<eax>(unsigned __int16 a1@<di>)
{
  int v1; // eax@1
  unsigned __int16 v2; // cx@3
  int result; // eax@4

  v1 = sub_10022780();
  if ( v1 && a1 < 0xFE3u && (v2 = *(_WORD *)(v1 + 2 * a1 + 14400), v2 < 0x3840u) )
    result = v1 + 24 * v2;
  else
    result = 0;
  return result;
}

//----- (10028200) --------------------------------------------------------
int __cdecl sub_10028200(unsigned __int16 a1)
{
  int result; // eax@1
  int v2; // esi@1

  result = sub_100281C0(a1);
  v2 = result;
  if ( !result )
  {
    sub_10011520("..\\lib\\acl\\dat\\dat_intf.c", 100, 0, 0);
    result = v2;
  }
  return result;
}

//----- (10028230) --------------------------------------------------------
bool __cdecl sub_10028230(unsigned __int8 a1, char a2, unsigned int a3)
{
  int v3; // eax@1
  bool result; // al@5

  v3 = sub_10019B30(&a2, 4u, (int)&dword_100A24D8, 12, 3, 3);
  if ( a3 < 0xFFFFFFC2 && a3 && v3 < 3 && a1 < 2u )
  {
    result = sub_10032AE0((unsigned __int16)word_100A24DC[a1 + 6 * v3], a3, (unsigned __int16)word_100A24E0[6 * v3]) == 0;
  }
  else
  {
    sub_10011520("..\\lib\\acl\\iop\\gtx\\iop_gtx_intf.c", 254, 0, 0);
    result = 0;
  }
  return result;
}
// 100A24D8: using guessed type int dword_100A24D8;
// 100A24DC: using guessed type __int16 word_100A24DC[];
// 100A24E0: using guessed type __int16 word_100A24E0[];

//----- (100282C0) --------------------------------------------------------
bool __cdecl sub_100282C0(char a1, char a2, void *a3)
{
  int v3; // eax@1
  int v4; // esi@3
  void *v5; // edi@3
  int (__cdecl *v6)(void *, _DWORD); // esi@4
  bool result; // al@6

  v3 = sub_10019B30(&a1, 1u, (int)&unk_100A2514, 8, 2, 2);
  if ( v3 >= 2 || (unsigned __int8)a2 >= 3u )
  {
    result = 0;
  }
  else
  {
    v4 = (unsigned __int8)a2;
    v5 = a3;
    result = 0;
    if ( sub_10012260(0, (unsigned __int16)word_100A2516[(unsigned __int8)a2 + 4 * v3], a3) )
    {
      v6 = (int (__cdecl *)(void *, _DWORD))dword_100A2524[v4];
      if ( !v6 || !v6(v5, 0) )
        result = 1;
    }
  }
  return result;
}
// 100A2516: using guessed type __int16 word_100A2516[];
// 100A2524: using guessed type int dword_100A2524[];

//----- (10028340) --------------------------------------------------------
bool __cdecl sub_10028340(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6)
{
  int v6; // eax@1
  int v7; // eax@7
  unsigned int v8; // edx@7
  int v9; // eax@7
  bool result; // al@9
  unsigned __int8 v11; // [sp+4h] [bp-4h]@1

  v11 = sub_10028480(a1);
  v6 = sub_10019B30(&a3, 1u, (int)&unk_100A24FC, 8, 3, 3);
  if ( v6 < 3 )
    v6 = sub_10019B30(&dword_100A2500[2 * v6], 4u, (int)&dword_100A24D8, 12, 3, 3);
  if ( a5 < 0xFFFFFFC2
    && a5
    && v6 < 3
    && v11 < 2u
    && (v7 = 6 * v6, v8 = (unsigned __int16)word_100A24E0[v7], v9 = 2 * v7, a6 >= v8)
    && a2 == 1 )
  {
    result = sub_10028230(v11, *(int *)((char *)&dword_100A24D8 + v9), a5);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100A24D8: using guessed type int dword_100A24D8;
// 100A24E0: using guessed type __int16 word_100A24E0[];

//----- (100283E0) --------------------------------------------------------
signed int sub_100283E0()
{
  return sub_100335F0((int)&off_100A2600);
}
// 100A2600: using guessed type char *off_100A2600;

//----- (100283F0) --------------------------------------------------------
char __cdecl sub_100283F0(void *a1)
{
  char v1; // bl@1

  v1 = 0;
  if ( a1 && (unsigned __int8)sub_100283E0() == 1 && !sub_10032F80(37, 100) )
  {
    qmemcpy(a1, (const void *)(dword_10227E38 + 8), 0x34u);
    v1 = 1;
    sub_10032F60(37);
  }
  return v1;
}
// 10227E38: using guessed type int dword_10227E38;

//----- (10028440) --------------------------------------------------------
bool sub_10028440()
{
  char v0; // bl@1
  unsigned int v2; // [sp+4h] [bp-4h]@1

  v0 = sub_10018720((char *)&v2);
  return (unsigned __int8)sub_100283E0() && v0 && v2 < *(_DWORD *)(dword_10227E38 + 60) + 18;
}
// 10227E38: using guessed type int dword_10227E38;

//----- (10028480) --------------------------------------------------------
char __cdecl sub_10028480(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xA:
    case 0x30:
      result = 0;
      break;
    case 0xB:
    case 0x31:
      result = 1;
      break;
    default:
      sub_10011520("..\\lib\\acl\\iop\\iop_xpdr_cnfg_utl.c", 155, 0, 0);
      result = 2;
      break;
  }
  return result;
}

//----- (10028500) --------------------------------------------------------
char __cdecl sub_10028500(unsigned __int16 a1, _WORD *a2)
{
  unsigned int v2; // ebx@2
  _WORD *v3; // edi@2
  char result; // al@2
  signed __int16 v5; // cx@2
  __int16 v6; // si@2
  __int16 v7; // dx@3

  if ( sub_10026CF0(&a1) )
  {
    result = 0;
  }
  else
  {
    v2 = a1;
    v3 = a2;
    result = 1;
    *a2 = 0;
    v5 = 1;
    v6 = 0;
    do
    {
      v7 = v5 * (v2 & 7);
      v5 *= 10;
      v2 >>= 3;
      v6 += v7;
    }
    while ( (unsigned __int16)v5 <= 0x3E8u );
    *v3 = v6;
  }
  return result;
}

//----- (10028560) --------------------------------------------------------
char __cdecl sub_10028560(char a1, int a2)
{
  char v2; // cl@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // eax@1
  int v10; // ecx@1
  bool v11; // zf@1
  int v12; // eax@3
  int v13; // ecx@3
  char v14; // dl@3
  __int16 v15; // ax@5
  char v16; // dl@5
  int v18; // [sp+4h] [bp-58h]@1
  char v19; // [sp+8h] [bp-54h]@1
  __int64 v20; // [sp+Ch] [bp-50h]@1
  int v21; // [sp+14h] [bp-48h]@1
  int v22; // [sp+18h] [bp-44h]@1
  char v23; // [sp+1Ch] [bp-40h]@1
  __int16 v24; // [sp+1Eh] [bp-3Eh]@1
  int v25; // [sp+20h] [bp-3Ch]@4
  int v26; // [sp+24h] [bp-38h]@4
  char v27; // [sp+28h] [bp-34h]@4
  char v28; // [sp+2Ah] [bp-32h]@1
  char v29; // [sp+2Bh] [bp-31h]@1
  int v30; // [sp+2Ch] [bp-30h]@1
  int v31; // [sp+30h] [bp-2Ch]@1
  int v32; // [sp+34h] [bp-28h]@1
  int v33; // [sp+38h] [bp-24h]@1
  int v34; // [sp+3Ch] [bp-20h]@1
  int v35; // [sp+40h] [bp-1Ch]@1
  int v36; // [sp+44h] [bp-18h]@1
  int v37; // [sp+48h] [bp-14h]@1
  int v38; // [sp+4Ch] [bp-10h]@1
  int v39; // [sp+50h] [bp-Ch]@1
  int v40; // [sp+54h] [bp-8h]@1

  memset(&v23, 0, 0x3Cu);
  v20 = 0i64;
  v21 = 0;
  v22 = 0;
  v18 = 0;
  v19 = 0;
  sub_1002BF70(a1, (int)&v23);
  v2 = v28;
  v3 = v29;
  *(_WORD *)a2 = v24;
  *(_DWORD *)(a2 + 28) = v33;
  v4 = v36;
  *(_BYTE *)(a2 + 12) = v2;
  *(_DWORD *)(a2 + 32) = v34;
  v5 = v37;
  *(_BYTE *)(a2 + 13) = v3;
  *(_DWORD *)(a2 + 36) = v35;
  v6 = v38;
  *(_DWORD *)(a2 + 40) = v4;
  v7 = v30;
  *(_DWORD *)(a2 + 44) = v5;
  v8 = v31;
  *(_DWORD *)(a2 + 16) = v7;
  v9 = v39;
  *(_DWORD *)(a2 + 20) = v8;
  v10 = v40;
  *(_DWORD *)(a2 + 48) = v6;
  v11 = BYTE3(v30) == 1;
  *(_DWORD *)(a2 + 24) = v32;
  *(_DWORD *)(a2 + 52) = v9;
  *(_DWORD *)(a2 + 56) = v10;
  if ( !v11 || sub_10032AE0(2105, (int)&v20, 16) )
  {
    v12 = v25;
    v13 = v26;
    v14 = v27;
  }
  else
  {
    v13 = *(_DWORD *)((char *)&v20 + 6);
    v12 = *(_DWORD *)((char *)&v20 + 2);
    v14 = BYTE2(v21);
  }
  *(_DWORD *)(a2 + 2) = v12;
  *(_DWORD *)(a2 + 6) = v13;
  *(_BYTE *)(a2 + 10) = v14;
  sub_1002BF90((int)&v18);
  LOBYTE(v15) = v19;
  v16 = v18;
  v11 = (v19 & 1) == 0;
  *(_BYTE *)(a2 + 63) = BYTE3(v18);
  *(_BYTE *)(a2 + 60) = v16;
  *(_BYTE *)(a2 + 64) = 0;
  if ( !v11 )
    *(_BYTE *)(a2 + 64) = 1;
  *(_BYTE *)(a2 + 65) = 0;
  if ( v15 & 4 )
    *(_BYTE *)(a2 + 65) = 1;
  *(_BYTE *)(a2 + 66) = 0;
  if ( v15 & 2 )
  {
    v15 = *(_WORD *)((char *)&v18 + 1);
    *(_BYTE *)(a2 + 66) = 1;
    *(_WORD *)(a2 + 61) = v15;
  }
  else
  {
    *(_WORD *)(a2 + 61) = *(_WORD *)((char *)&v18 + 1);
  }
  return v15;
}

//----- (100286D0) --------------------------------------------------------
int __usercall sub_100286D0@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@1
  int v5[10]; // [sp+1Ch] [bp-2Ch]@1

  sub_10028560(a1, (int)&v4);
  result = v5[a3];
  *a2 = result;
  return result;
}
// 100286D0: using guessed type int var_2C[10];

//----- (10028710) --------------------------------------------------------
int __usercall sub_10028710@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@3
  int v5[4]; // [sp+34h] [bp-14h]@3

  result = a3;
  if ( (unsigned __int8)a3 < 2u && a1 < 2u )
  {
    sub_10028560(a3, (int)&v4);
    result = v5[a1];
    *a2 = result;
  }
  return result;
}
// 10028710: using guessed type int var_14[4];

//----- (10028750) --------------------------------------------------------
signed int sub_10028750()
{
  return sub_100335F0((int)&off_100A43A0);
}
// 100A43A0: using guessed type char *off_100A43A0;

//----- (10028760) --------------------------------------------------------
char __cdecl sub_10028760(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  int v3; // esi@2
  char result; // al@2

  if ( (unsigned __int8)sub_10028750() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_1025442C + 4 * v3 + 29);
    *(_BYTE *)a3 = *(_BYTE *)(dword_1025442C + 4 * v3 + 28);
    result = *(_BYTE *)(a2 + 2 * (3 * a1 + 72) + dword_1025442C);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1025442C: using guessed type int dword_1025442C;

//----- (100287C0) --------------------------------------------------------
char __cdecl sub_100287C0(char a1, void *a2)
{
  int v2; // edx@4
  char result; // al@20

  if ( (unsigned __int8)sub_10028750() )
  {
    if ( (sub_10013EE0(a1)
       || *(_BYTE *)(dword_1025442C + 2 * (3 * (unsigned __int8)a1 + 72))
       && (v2 = dword_1025442C + 6 * (unsigned __int8)a1, *(_BYTE *)(dword_1025442C + 6 * (unsigned __int8)a1 + 145))
       && *(_BYTE *)(v2 + 146)
       && *(_BYTE *)(v2 + 147)
       && *(_BYTE *)(v2 + 148)
       && *(_BYTE *)(v2 + 149)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1025442C + 142)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1025442C + 170)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1025442C + 168)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1025442C + 166)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1025442C + 172)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1025442C + 174)
       && *(_BYTE *)((unsigned __int8)a1 + dword_1025442C + 176))
      && *(_BYTE *)(dword_1025442C + 2 * (unsigned __int8)a1 + 158)
      && *(_BYTE *)(dword_1025442C + 2 * (unsigned __int8)a1 + 159)
      && *(_BYTE *)((unsigned __int8)a1 + dword_1025442C + 156)
      && *(_BYTE *)((unsigned __int8)a1 + dword_1025442C + 162) )
    {
      qmemcpy(a2, (const void *)(dword_1025442C + 68 * (unsigned __int8)a1), 0x44u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1025442C: using guessed type int dword_1025442C;

//----- (100288E0) --------------------------------------------------------
char __cdecl sub_100288E0(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@2
  char result; // al@2

  if ( (unsigned __int8)sub_10028750() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 2) = *(_BYTE *)(dword_1025442C + 4 * v3 + 54);
    *(_BYTE *)a3 = *(_BYTE *)(dword_1025442C + 4 * v3 + 52);
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_1025442C + 4 * v3 + 53);
    *(_BYTE *)(a3 + 3) = *(_BYTE *)(dword_1025442C + 4 * v3 + 55);
    result = *(_BYTE *)(a2 + 2 * a1 + 158 + dword_1025442C);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1025442C: using guessed type int dword_1025442C;

//----- (10028960) --------------------------------------------------------
char __cdecl sub_10028960(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6)
{
  char v6; // cl@2
  char result; // al@7
  unsigned __int16 v8; // ax@13

  if ( (_BYTE)a1 == 10 )
  {
    v6 = 0;
  }
  else
  {
    if ( (_BYTE)a1 != 11 )
    {
      sub_10011520("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 703, 0, 0);
      return 0;
    }
    v6 = 1;
  }
  LOBYTE(a1) = v6;
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        if ( a2 )
        {
          sub_10028710(*a4, a5, a1);
          result = 1;
        }
        else
        {
          result = sub_100288E0(v6, *a4, (int)a5);
        }
      }
      else
      {
        sub_10011520("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 718, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        v8 = *a4;
        if ( a2 )
        {
          sub_100286D0(v6, a5, v8);
          result = 1;
        }
        else
        {
          result = sub_10028760(v6, v8, (int)a5);
        }
      }
      else
      {
        sub_10011520("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 750, 0, 0);
        result = 0;
      }
      break;
    case 0xB:
    case 0x12:
    case 0x1C:
      if ( a6 >= 0x44 )
      {
        if ( a2 )
        {
          sub_10028560(v6, (int)a5);
          result = 1;
        }
        else
        {
          result = sub_100287C0(v6, a5);
        }
      }
      else
      {
        sub_10011520("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 784, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10011520("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 809, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10028B10) --------------------------------------------------------
int __cdecl sub_10028B10(int a1)
{
  double v1; // ST0C_8@2
  double v2; // st6@4
  double v3; // st7@4
  double v4; // ST0C_8@7
  double v5; // rt2@8
  double v6; // st6@8
  double v7; // st7@8
  double v8; // st7@14
  double v9; // st7@18
  int result; // eax@18

  if ( a1 )
  {
    v1 = *(double *)a1;
    if ( (HIDWORD(v1) & 0x7FF00000) == 2146435072 || *(double *)a1 > 6.2831853071796 )
    {
      *(double *)a1 = 6.2831853071796;
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
    }
    else
    {
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
      if ( *(double *)a1 < -6.2831853071796 )
        *(double *)a1 = -6.2831853071796;
    }
    v4 = *(double *)(a1 + 8);
    if ( (HIDWORD(v4) & 0x7FF00000) == 2146435072 )
    {
      *(double *)(a1 + 8) = v3;
    }
    else
    {
      v5 = v2;
      v6 = v3;
      v7 = v5;
      if ( v6 < *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v6;
      }
      else if ( v7 > *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v7;
      }
    }
    if ( *(double *)a1 <= 1.5707963267949 )
    {
      if ( *(double *)a1 >= -1.5707963267949 )
      {
LABEL_18:
        v9 = *(double *)(a1 + 8);
        result = sub_10035C30(v9);
        *(double *)(a1 + 8) = v9;
        return result;
      }
      *(double *)a1 = -3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    else
    {
      *(double *)a1 = 3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    *(double *)(a1 + 8) = v8;
    goto LABEL_18;
  }
  return result;
}

//----- (10028C10) --------------------------------------------------------
double __cdecl sub_10028C10(int a1)
{
  double v1; // st6@1

  v1 = (double)(unsigned int)((*(int (**)(void))(dword_10254400 + 8))() - a1);
  return (float)(1.0 / (double)(*(int (**)(void))(dword_10254400 + 12))() * v1);
}
// 10254400: using guessed type int dword_10254400;

//----- (10028C60) --------------------------------------------------------
char __usercall sub_10028C60@<al>(void *a1@<esi>)
{
  char result; // al@2
  bool v2; // zf@3
  void *v3; // [sp+0h] [bp-8h]@0

  if ( sub_10013C70(4035, v3) )
  {
    result = 1;
  }
  else
  {
    v2 = (unsigned __int8)sub_10022760(1, 741, 0, 4, a1) == 0;
    result = 1;
    if ( v2 )
      result = 0;
  }
  return result;
}

//----- (10028CA0) --------------------------------------------------------
char __usercall sub_10028CA0@<al>(float *a1@<esi>)
{
  char result; // al@1
  void *v2; // [sp+0h] [bp-8h]@0

  result = sub_10013370(v2);
  if ( result )
    result = 1;
  else
    *a1 = 9.8999998e24;
  return result;
}

//----- (10028CC0) --------------------------------------------------------
char __cdecl sub_10028CC0(float *a1)
{
  char v1; // bl@1
  double v2; // st7@1
  char result; // al@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v5 = 9.8999998e24;
  v1 = 0;
  sub_10032B40(6081, &v4, 4, &v5);
  v2 = v4;
  if ( v4 != 9.8999998e24 )
  {
    v1 = 1;
    v4 = v2 / 3600.0;
    v2 = v4;
  }
  result = v1;
  *a1 = v2;
  return result;
}

//----- (10028D20) --------------------------------------------------------
char __cdecl sub_10028D20(float *a1)
{
  char v1; // bl@1
  double v2; // st7@1
  char result; // al@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v5 = 9.8999998e24;
  v1 = 0;
  sub_10032B40(6937, &v4, 4, &v5);
  v2 = v4;
  if ( v4 != 9.8999998e24 )
  {
    v1 = 1;
    v4 = v2 / 3600.0;
    v2 = v4;
  }
  result = v1;
  *a1 = v2;
  return result;
}

//----- (10028D80) --------------------------------------------------------
char __cdecl sub_10028D80(float *a1)
{
  char v1; // bl@1
  double v2; // st7@1
  char result; // al@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v5 = 9.8999998e24;
  v1 = 0;
  sub_10032B40(6938, &v4, 4, &v5);
  v2 = v4;
  if ( v4 != 9.8999998e24 )
  {
    v1 = 1;
    v4 = v2 / 3600.0;
    v2 = v4;
  }
  result = v1;
  *a1 = v2;
  return result;
}

//----- (10028DE0) --------------------------------------------------------
char __usercall sub_10028DE0@<al>(int a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st7@2
  float v4; // ST14_4@5
  char result; // al@5
  float v6; // [sp+Ch] [bp-8h]@1
  float v7; // [sp+10h] [bp-4h]@1

  v1 = sub_10016F60(0x4B6u, &v6);
  v2 = sub_10016F60(0x4B7u, &v7);
  if ( v1 )
  {
    v3 = v6;
    if ( v2 )
    {
      if ( v7 <= v3 )
        v3 = v7;
      v4 = v3;
      result = sub_10018680(v4, a1);
    }
    else
    {
      result = sub_10018680(v6, a1);
    }
  }
  else if ( v2 )
  {
    result = sub_10018680(v7, a1);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10028E80) --------------------------------------------------------
char __cdecl sub_10028E80(float *a1)
{
  char result; // al@2
  float v2; // [sp+4h] [bp-4h]@1

  if ( (unsigned __int8)sub_10022760(1, 949, 0, 4, &v2) )
  {
    result = 1;
    *a1 = 1000.0 * v2 / (10.0 - v2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10028ED0) --------------------------------------------------------
char __cdecl sub_10028ED0(float *a1)
{
  char result; // al@2
  float v2; // [sp+4h] [bp-4h]@1

  if ( (unsigned __int8)sub_10022760(1, 950, 0, 4, &v2) )
  {
    result = 1;
    *a1 = 1000.0 * v2 / (10.0 - v2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10028F20) --------------------------------------------------------
char __cdecl sub_10028F20(float *a1)
{
  char result; // al@3
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( (unsigned __int8)sub_10022760(0, 400, 0, 4, &v3) && (unsigned __int8)sub_10022760(1, 527, 0, 4, &v2) )
  {
    result = 1;
    *a1 = v2 * v3 * 0.1047197580337524;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10028F80) --------------------------------------------------------
char __cdecl sub_10028F80(float *a1)
{
  char result; // al@3
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( (unsigned __int8)sub_10022760(0, 401, 0, 4, &v3) && (unsigned __int8)sub_10022760(1, 530, 0, 4, &v2) )
  {
    result = 1;
    *a1 = v2 * v3 * 0.1047197580337524;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10028FE0) --------------------------------------------------------
char __usercall sub_10028FE0@<al>(float *a1@<esi>, char a2)
{
  char v2; // bl@1
  char result; // al@6
  float v4; // [sp+4h] [bp-Ch]@1
  int v5; // [sp+8h] [bp-8h]@1
  float v6; // [sp+Ch] [bp-4h]@1
  char v7; // [sp+14h] [bp+4h]@2
  char v8; // [sp+14h] [bp+4h]@7

  v4 = 9.8999998e24;
  v6 = 9.8999998e24;
  v2 = 0;
  v5 = 0;
  if ( a2 )
  {
    v7 = sub_10022760(6, 617, 0, 4, &v5);
    if ( sub_10013C70(4026, &v4) )
    {
      v2 = 1;
      if ( v7 && v5 & 0x1000 && sub_10013C70(4028, &v6) )
      {
LABEL_6:
        result = 1;
        *a1 = v6 + v4;
        return result;
      }
      goto LABEL_11;
    }
  }
  else
  {
    v8 = sub_10022760(6, 620, 0, 4, &v5);
    if ( sub_10013C70(4027, &v4) )
    {
      v2 = 1;
      if ( v8 && v5 & 0x1000 && sub_10013C70(4029, &v6) )
        goto LABEL_6;
LABEL_11:
      *a1 = v4;
      return v2;
    }
  }
  return v2;
}

//----- (100290D0) --------------------------------------------------------
char __cdecl sub_100290D0(float a1, int a2)
{
  float v2; // ecx@0
  char v3; // al@3
  char result; // al@5
  float v5; // [sp+0h] [bp-4h]@1

  v5 = v2;
  if ( LOBYTE(a1) == 1 )
  {
    if ( !sub_10013C70(65, &v5) )
      return 0;
    v3 = sub_10013C70(498, &a1);
  }
  else
  {
    if ( !sub_10013C70(61, &v5) )
      return 0;
    v3 = sub_10013C70(477, &a1);
  }
  if ( v3 )
  {
    result = 1;
    *(float *)a2 = (a1 + v5) * 0.5;
    return result;
  }
  return 0;
}

//----- (10029140) --------------------------------------------------------
char __usercall sub_10029140@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st7@2
  char result; // al@4
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_10022760(1, 740, 0, 4, &v5);
  v2 = sub_10022760(1, 2172, 0, 4, &v6);
  if ( v1 )
  {
    v3 = v5;
    if ( !v2 || (v5 = v3 - v6, LODWORD(v5) &= 0x7FFFFFFFu, v5 <= 304.8) )
    {
      *a1 = v3;
      return 1;
    }
  }
  else if ( v2 )
  {
    result = 1;
    *a1 = v6;
    return result;
  }
  return 0;
}

//----- (100291C0) --------------------------------------------------------
char __cdecl sub_100291C0(float *a1)
{
  char result; // al@4
  int v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( (unsigned __int8)sub_10022760(1, 120, 0, 4, &v3)
    && (unsigned __int8)sub_10022760(1, 1775, 0, 4, &v2)
    && !(v2 & 0x7C0000) )
  {
    *a1 = v3;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10029220) --------------------------------------------------------
char __cdecl sub_10029220(float *a1)
{
  char v1; // bl@1
  int v2; // eax@3
  char result; // al@14
  int v4; // [sp+4h] [bp-8h]@2
  float v5; // [sp+8h] [bp-4h]@1

  v1 = 0;
  if ( !(unsigned __int8)sub_10022760(1, 122, 0, 4, &v5) || !(unsigned __int8)sub_10022760(1, 996, 0, 4, &v4) )
    goto LABEL_18;
  v2 = v4;
  if ( v4 & 0x40000 )
    v1 = 1;
  if ( v2 & 0x80000 )
    ++v1;
  if ( v2 & 0x100000 )
    ++v1;
  if ( v2 & 0x200000 )
    ++v1;
  if ( v2 & 0x400000 )
    ++v1;
  if ( (unsigned __int8)v1 < 2u )
  {
    *a1 = v5;
    result = 1;
  }
  else
  {
LABEL_18:
    result = 0;
  }
  return result;
}

//----- (100292B0) --------------------------------------------------------
char __cdecl sub_100292B0(float *a1)
{
  char v1; // bl@1
  int v2; // eax@3
  char result; // al@14
  int v4; // [sp+4h] [bp-8h]@2
  float v5; // [sp+8h] [bp-4h]@1

  v1 = 0;
  if ( !(unsigned __int8)sub_10022760(1, 127, 0, 4, &v5) || !(unsigned __int8)sub_10022760(1, 1004, 0, 4, &v4) )
    goto LABEL_18;
  v2 = v4;
  if ( v4 & 0x40000 )
    v1 = 1;
  if ( v2 & 0x80000 )
    ++v1;
  if ( v2 & 0x100000 )
    ++v1;
  if ( v2 & 0x200000 )
    ++v1;
  if ( v2 & 0x400000 )
    ++v1;
  if ( (unsigned __int8)v1 < 2u )
  {
    *a1 = v5;
    result = 1;
  }
  else
  {
LABEL_18:
    result = 0;
  }
  return result;
}

//----- (10029340) --------------------------------------------------------
char __usercall sub_10029340@<al>(float *a1@<esi>)
{
  double v1; // st7@15
  double v2; // st6@19
  double v3; // st7@25
  double v4; // st7@31
  char result; // al@36
  char v6; // [sp+4h] [bp-2Ch]@2
  char v7; // [sp+5h] [bp-2Bh]@5
  char v8; // [sp+6h] [bp-2Ah]@8
  char v9; // [sp+7h] [bp-29h]@11
  float v10; // [sp+8h] [bp-28h]@2
  float v11; // [sp+Ch] [bp-24h]@21
  float v12; // [sp+10h] [bp-20h]@17
  float v13; // [sp+14h] [bp-1Ch]@14
  float v14; // [sp+18h] [bp-18h]@23
  float v15; // [sp+1Ch] [bp-14h]@29
  float v16; // [sp+20h] [bp-10h]@1
  float v17; // [sp+24h] [bp-Ch]@21
  double v18; // [sp+28h] [bp-8h]@21

  *a1 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10022760(1, 1744, 0, 4, &v16) )
    goto LABEL_40;
  v16 = v16 * 61.02374267578125;
  v10 = v16;
  if ( (unsigned __int8)sub_10022760(1, 134, 0, 1, &v6) && !v6 )
    v10 = v10 + 39.90000152587891;
  if ( (unsigned __int8)sub_10022760(1, 634, 0, 1, &v7) && !v7 )
    v10 = v10 + 2.5;
  if ( (unsigned __int8)sub_10022760(1, 649, 0, 1, &v8) && !v8 )
    v10 = v10 + 2.5;
  if ( (unsigned __int8)sub_10022760(1, 1757, 0, 1, &v9) && v9 )
    v10 = v10 + 13.5;
  if ( sub_10013370(&v13) )
    v1 = v13 * 1.799999952316284 + 32.0;
  else
    v1 = -65.0;
  v13 = v1;
  if ( (unsigned __int8)sub_10022760(1, 1743, 0, 4, &v12) && v12 != 0.0 )
    v2 = v12 * 0.000145037702168338;
  else
    v2 = 3040.0;
  v12 = v2;
  v17 = v13 + 460.0;
  v18 = 0.0000344 - (v17 - 528.0) * 0.00000005;
  v11 = v18 * (v12 - 100.0) + 1.003999948501587;
  v11 = 100.0 - v17 * (v11 * 248.0) / v12;
  if ( v11 > 0.0 )
    v10 = v11 + v10;
  if ( (unsigned __int8)sub_10022760(1, 1741, 0, 4, &v14) && v14 != 0.0 )
    v3 = v14 * 0.000145037702168338;
  else
    v3 = 3040.0;
  v14 = v3;
  v11 = (v14 - 100.0) * v18 + 1.003999948501587;
  v11 = 50.0 - v11 * 124.0 * v17 / v14;
  if ( v11 > 0.0 )
    v10 = v11 + v10;
  v4 = (unsigned __int8)sub_10022760(1, 1742, 0, 4, &v15) && v15 != 0.0 ? v15 * 0.000145037702168338 : 3040.0;
  v15 = v4;
  v16 = (v15 - 100.0) * v18 + 1.003999948501587;
  v11 = 50.0 - v16 * 124.0 * v17 / v15;
  if ( v11 > 0.0 )
    v10 = v11 + v10;
  v17 = v12 * 631.0 / 250000.0;
  v10 = v17 + v10;
  v17 = 631.0 * ((v13 - 59.0) * 0.0004556);
  v17 = v17 + v10;
  v17 = (v17 - 300.0 + 100.0) / 100.0;
  if ( v17 <= 1.25 )
  {
    *a1 = v17;
    result = 1;
  }
  else
  {
LABEL_40:
    result = 0;
  }
  return result;
}

//----- (100296E0) --------------------------------------------------------
char __usercall sub_100296E0@<al>(float *a1@<esi>)
{
  char result; // al@4
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  *a1 = 0.0;
  if ( sub_10016F60(0x40Du, &v3) && sub_10016F60(0x40Eu, &v2) && v2 != 0.0 )
  {
    result = 1;
    *a1 = v3 / v2 * 11.35624027252197 + 0.1147093996405602;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10029750) --------------------------------------------------------
char __usercall sub_10029750@<al>(float *a1@<esi>)
{
  char result; // al@1
  float *v2; // [sp+0h] [bp-8h]@0

  result = sub_100135A0(v2);
  if ( result )
    result = 1;
  else
    *a1 = 9.8999998e24;
  return result;
}

//----- (10029770) --------------------------------------------------------
char __usercall sub_10029770@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st6@3
  char result; // al@4
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_10016F60(0x4Fu, &v5);
  v2 = sub_10016F60(0x7EAu, &v6);
  if ( v1 )
  {
    if ( !v2 )
    {
      result = 1;
      *a1 = v5;
      return result;
    }
    v3 = v5;
    v5 = v6 - v5;
    LODWORD(v5) &= 0x7FFFFFFFu;
    if ( v5 <= 34473.789 )
    {
      result = 1;
      *a1 = (v6 + v3) * 0.5;
      return result;
    }
  }
  else if ( v2 )
  {
    result = 1;
    *a1 = v6;
    return result;
  }
  return 0;
}

//----- (10029800) --------------------------------------------------------
void __usercall sub_10029800(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st6@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v1 = sub_10016F60(0x51u, &v4);
  v2 = sub_10016F60(0x7EBu, &v5);
  if ( v1 )
  {
    if ( !v2 )
    {
      *a1 = v4;
      return;
    }
    v3 = v4;
    v4 = v5 - v4;
    LODWORD(v4) &= 0x7FFFFFFFu;
    if ( v4 <= 5.0 )
    {
      *a1 = (v5 + v3) * 0.5;
      return;
    }
  }
  else if ( v2 )
  {
    *a1 = v5;
    return;
  }
  *a1 = 21.1;
}

//----- (10029890) --------------------------------------------------------
char __cdecl sub_10029890(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  float v3; // [sp+8h] [bp-18h]@1
  double v4; // [sp+Ch] [bp-14h]@1
  float v5; // [sp+14h] [bp-Ch]@2
  double v6; // [sp+18h] [bp-8h]@2

  v1 = sub_10029770((float *)&v4);
  sub_10029800(&v3);
  if ( v1 )
  {
    v5 = (v3 + 67.77799987792969) / 27.77799987792969;
    v3 = (*(float *)&v4 + 517.0900268554688) / 4137139.5;
    v4 = v5 * 27.79999923706055;
    v5 = pow(315.0 - v4, 2.0);
    v6 = v5 * 5.470000147278498e-11;
    v5 = pow(v3 * 41.40000152587891, 2.0);
    v6 = v5 * v6;
    v5 = pow(215.0 - v4, 2.0);
    v5 = v6 - v5 * 0.00000005260000079942984 * 41.40000152587891 * v3 + 1.0;
    *a1 = v3 / (v4 + 205.3000030517578) * (1.0 / v5 * 127823.0) - 195.0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100299B0) --------------------------------------------------------
char __usercall sub_100299B0@<al>(float *a1@<esi>, float a2)
{
  char v2; // bl@1
  double v3; // st7@3
  long double v4; // st7@3
  float v6; // [sp+0h] [bp-20h]@1
  float v7; // [sp+4h] [bp-1Ch]@1
  float v8; // [sp+8h] [bp-18h]@3
  float v9; // [sp+Ch] [bp-14h]@1
  int v10; // [sp+10h] [bp-10h]@3
  float v11; // [sp+14h] [bp-Ch]@5
  float v12; // [sp+18h] [bp-8h]@5
  float v13; // [sp+1Ch] [bp-4h]@5
  float v14; // [sp+24h] [bp+4h]@3
  float v15; // [sp+24h] [bp+4h]@3
  unsigned __int8 v16; // [sp+24h] [bp+4h]@3

  v2 = 0;
  v9 = a2 * 32.0 * 0.0005787039990536869;
  v7 = 0.0;
  v6 = 0.0;
  if ( sub_10016F60(0x4Fu, &v7) && sub_10016F60(0x51u, &v6) )
  {
    *(float *)&v10 = v7 / 101325.0;
    v14 = v6 + 273.0;
    v7 = v7 * 0.000145037702168338;
    v6 = v6 * 1.799999952316284 + 32.0;
    v15 = v14 * 0.08205779641866684 / *(float *)&v10;
    v3 = v15 * 0.002983009908348322;
    v16 = 0;
    v8 = v3;
    v4 = v9;
    do
    {
      if ( v16 >= 5u )
        break;
      v12 = pow(v4, 2.0);
      v11 = pow(v8 / v9, 2.0);
      v11 = (v9 - 0.5099999904632568 * v8) * (v11 * 5140.0 + v7 + 14.69999980926514)
          - (v6 + 460.0) * 10.71000003814697 * v8;
      v13 = v11;
      v11 = pow(v8, 2.0);
      v12 = -((v11 * 7864200.0 + 10710.0 * v12 * v6 + v12 * 510.0 * v7 - 10280000.0 * v9 * v8 + v12 * 4934097.0)
            / (v12
             * 1000.0));
      v13 = v13 / v12;
      v8 = v8 - v13;
      v4 = v9;
      v10 = LODWORD(v13) & 0x7FFFFFFF;
      if ( COERCE_FLOAT(LODWORD(v13) & 0x7FFFFFFF) < 0.001 )
      {
        v2 = 1;
        *a1 = v8 / 0.002983009908348322;
      }
      ++v16;
    }
    while ( !v2 );
  }
  return v2;
}

//----- (10029BB0) --------------------------------------------------------
char __usercall sub_10029BB0@<al>(float *a1@<esi>, float a2)
{
  char v2; // al@3
  char result; // al@5
  float v4; // [sp+4h] [bp-4h]@3

  if ( LOBYTE(a2) )
  {
    if ( !sub_10012200(1, 1516, 0, 4, &a2) )
      return 0;
    v2 = sub_10012200(0, 356, 0, 4, &v4);
  }
  else
  {
    if ( !sub_10012200(1, 2447, 0, 4, &a2) )
      return 0;
    v2 = sub_10012200(0, 357, 0, 4, &v4);
  }
  if ( v2 )
  {
    result = 1;
    *a1 = a2 - v4;
    return result;
  }
  return 0;
}

//----- (10029C40) --------------------------------------------------------
char __usercall sub_10029C40@<al>(float *a1@<eax>)
{
  return sub_10018200(a1);
}

//----- (10029C50) --------------------------------------------------------
char __usercall sub_10029C50@<al>(float *a1@<eax>)
{
  return sub_100182D0(a1);
}

//----- (10029C60) --------------------------------------------------------
char __usercall sub_10029C60@<al>(float *a1@<eax>)
{
  return sub_100183A0(a1);
}

//----- (10029C70) --------------------------------------------------------
char __usercall sub_10029C70@<al>(float *a1@<eax>)
{
  return sub_10018470(a1);
}

//----- (10029C80) --------------------------------------------------------
int __usercall sub_10029C80@<eax>(char a1@<dl>, int a2@<ecx>, float *a3)
{
  int result; // eax@1
  int v4; // [sp+0h] [bp-4h]@1

  v4 = a2;
  result = sub_10022760(a1, a2, 0, 4, &v4);
  if ( (_BYTE)result )
    *a3 = (double)v4 * 0.00000008381903171539307;
  return result;
}

//----- (10029CB0) --------------------------------------------------------
char __usercall sub_10029CB0@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  double v2; // st7@3
  char result; // al@9
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@2

  v1 = 0;
  if ( sub_10012200(6, 41, 0, 4, &v4) && sub_10012200(6, 42, 0, 4, &v5) )
  {
    v2 = (v5 + v4) * 0.5;
LABEL_8:
    *a1 = v2;
    v1 = 1;
    goto LABEL_9;
  }
  if ( sub_10012200(6, 41, 0, 4, &v4) )
  {
    v2 = v4;
    goto LABEL_8;
  }
  if ( sub_10012200(6, 42, 0, 4, &v5) )
  {
    v2 = v5;
    goto LABEL_8;
  }
LABEL_9:
  result = v1;
  *a1 = *a1 * 1.943844437599182;
  return result;
}

//----- (10029D50) --------------------------------------------------------
char __usercall sub_10029D50@<al>(float *a1@<esi>)
{
  char result; // al@6
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+6h] [bp-B6h]@3
  char v4; // [sp+7h] [bp-B5h]@4
  char v5; // [sp+8h] [bp-B4h]@5
  char v6; // [sp+9h] [bp-B3h]@2
  float v7; // [sp+14h] [bp-A8h]@6
  float v8; // [sp+20h] [bp-9Ch]@9

  if ( (unsigned __int8)sub_10022760(6, 429, 0, 180, &v2) )
  {
    if ( v6 )
    {
LABEL_9:
      result = 1;
      *a1 = v8;
      return result;
    }
    if ( (!v3 || !v4) && v5 )
      goto LABEL_6;
  }
  if ( (unsigned __int8)sub_10022760(6, 430, 0, 180, &v2) )
  {
    if ( v6 )
      goto LABEL_9;
    if ( (!v3 || !v4) && v5 )
    {
LABEL_6:
      result = 1;
      *a1 = v7;
      return result;
    }
  }
  return 0;
}

//----- (10029E30) --------------------------------------------------------
char __cdecl sub_10029E30(float *a1)
{
  char result; // al@3
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( sub_10013C70(87, &v3) && sub_10013C70(88, &v2) )
  {
    result = 1;
    *a1 = (v2 + v3) * 0.5;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10029E80) --------------------------------------------------------
char __usercall sub_10029E80@<al>(float *a1@<esi>)
{
  char result; // al@5
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+6h] [bp-B6h]@2
  char v4; // [sp+7h] [bp-B5h]@3
  float v5; // [sp+Ch] [bp-B0h]@5
  float v6; // [sp+18h] [bp-A4h]@9

  if ( (unsigned __int8)sub_10022760(6, 429, 0, 180, &v2) )
  {
    if ( v3 && v4 )
      goto LABEL_9;
    if ( v2 )
    {
LABEL_5:
      result = 1;
      *a1 = v5;
      return result;
    }
  }
  if ( (unsigned __int8)sub_10022760(6, 430, 0, 180, &v2) )
  {
    if ( v3 && v4 )
    {
LABEL_9:
      result = 1;
      *a1 = v6;
      return result;
    }
    if ( v2 )
      goto LABEL_5;
  }
  return 0;
}

//----- (10029F60) --------------------------------------------------------
char __usercall sub_10029F60@<al>(float *a1@<esi>)
{
  char result; // al@5
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+5h] [bp-B7h]@4
  char v4; // [sp+6h] [bp-B6h]@3
  char v5; // [sp+7h] [bp-B5h]@2
  float v6; // [sp+10h] [bp-ACh]@5
  float v7; // [sp+1Ch] [bp-A0h]@9

  if ( (unsigned __int8)sub_10022760(6, 429, 0, 180, &v2) )
  {
    if ( v5 && v4 )
      goto LABEL_9;
    if ( v3 )
    {
LABEL_5:
      result = 1;
      *a1 = v6;
      return result;
    }
  }
  if ( (unsigned __int8)sub_10022760(6, 430, 0, 180, &v2) )
  {
    if ( v5 && v4 )
    {
LABEL_9:
      result = 1;
      *a1 = v7;
      return result;
    }
    if ( v3 )
      goto LABEL_5;
  }
  return 0;
}

//----- (1002A040) --------------------------------------------------------
char __usercall sub_1002A040@<al>(float *a1@<esi>)
{
  char result; // al@3
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+44h] [bp-78h]@2
  float v4; // [sp+50h] [bp-6Ch]@3

  if ( (unsigned __int8)sub_10022760(6, 429, 0, 180, &v2) && v3
    || (unsigned __int8)sub_10022760(6, 430, 0, 180, &v2) && v3 )
  {
    result = 1;
    *a1 = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002A0E0) --------------------------------------------------------
char __usercall sub_1002A0E0@<al>(float *a1@<esi>)
{
  char result; // al@3
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+40h] [bp-7Ch]@2
  float v4; // [sp+48h] [bp-74h]@3

  if ( (unsigned __int8)sub_10022760(6, 429, 0, 180, &v2) && v3
    || (unsigned __int8)sub_10022760(6, 430, 0, 180, &v2) && v3 )
  {
    result = 1;
    *a1 = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002A180) --------------------------------------------------------
char __usercall sub_1002A180@<al>(float *a1@<esi>)
{
  char result; // al@3
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+41h] [bp-7Bh]@2
  float v4; // [sp+4Ch] [bp-70h]@3

  if ( (unsigned __int8)sub_10022760(6, 429, 0, 180, &v2) && v3
    || (unsigned __int8)sub_10022760(6, 430, 0, 180, &v2) && v3 )
  {
    result = 1;
    *a1 = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002A220) --------------------------------------------------------
char __usercall sub_1002A220@<al>(float *a1@<esi>)
{
  char result; // al@4
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+80h] [bp-3Ch]@2
  char v4; // [sp+81h] [bp-3Bh]@3
  float v5; // [sp+8Ch] [bp-30h]@7
  float v6; // [sp+98h] [bp-24h]@4

  if ( (unsigned __int8)sub_10022760(6, 429, 0, 180, &v2) )
  {
    if ( v3 )
    {
LABEL_7:
      result = 1;
      *a1 = v5;
      return result;
    }
    if ( v4 )
    {
LABEL_4:
      result = 1;
      *a1 = v6;
      return result;
    }
  }
  if ( (unsigned __int8)sub_10022760(6, 430, 0, 180, &v2) )
  {
    if ( v3 )
      goto LABEL_7;
    if ( v4 )
      goto LABEL_4;
  }
  return 0;
}

//----- (1002A300) --------------------------------------------------------
char __cdecl sub_1002A300(float *a1)
{
  double v1; // st7@2
  char result; // al@5
  float v3; // ST04_4@5
  float v4; // [sp+0h] [bp-Ch]@1
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v4 = 9.8999998e24;
  v5 = sub_10018580();
  if ( sub_10018100(&v6) && (v1 = v5, v5 != 9.8999998e24) )
  {
    if ( v1 >= 3785.411865234375 || v6 <= 0.0001051503277267329 )
    {
      result = 1;
      *a1 = v4;
    }
    else
    {
      result = 1;
      v3 = v1 / v6;
      *a1 = v3;
    }
  }
  else
  {
    *a1 = v4;
    result = 0;
  }
  return result;
}

//----- (1002A3A0) --------------------------------------------------------
bool __cdecl sub_1002A3A0(float *a1)
{
  char v1; // bl@1
  bool v2; // al@1
  double v3; // st6@5
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_1002A300(&v5);
  v2 = sub_10014890(&v6);
  if ( !v1
    || !v2
    || v5 == 9.8999998e24
    || (LODWORD(v6) & 0x7F800000) == 2139095040
    || (v5 = v5 * v6, v3 = v5, v5 > 37040000.0) )
  {
    v5 = 9.8999998e24;
    v3 = (float)9.8999998e24;
  }
  *a1 = v3;
  return v2 && v1 && v3 != 9.8999998e24;
}

//----- (1002A450) --------------------------------------------------------
char __usercall sub_1002A450@<al>(float *a1@<esi>)
{
  char result; // al@5
  float v2; // [sp+4h] [bp-8h]@1
  float v3; // [sp+8h] [bp-4h]@2

  *a1 = 9.8999998e24;
  if ( (unsigned __int8)sub_10022760(1, 90, 0, 4, &v2)
    && (unsigned __int8)sub_10022760(1, 115, 0, 4, &v3)
    && v2 != 9.8999998e24
    && v3 != 9.8999998e24 )
  {
    result = 1;
    *a1 = v3 - v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002A4D0) --------------------------------------------------------
char __usercall sub_1002A4D0@<al>(float *a1@<esi>)
{
  char result; // al@5
  float v2; // [sp+4h] [bp-8h]@1
  float v3; // [sp+8h] [bp-4h]@2

  *a1 = 9.8999998e24;
  if ( (unsigned __int8)sub_10022760(1, 527, 0, 4, &v2)
    && (unsigned __int8)sub_10022760(1, 530, 0, 4, &v3)
    && v2 != 9.8999998e24
    && v3 != 9.8999998e24 )
  {
    result = 1;
    *a1 = v3 - v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002A560) --------------------------------------------------------
char __usercall sub_1002A560@<al>(float *a1@<esi>)
{
  char result; // al@4
  float v2; // [sp+0h] [bp-Ch]@1
  float v3; // [sp+4h] [bp-8h]@2
  float v4; // [sp+8h] [bp-4h]@3

  *a1 = 9.8999998e24;
  if ( sub_10014890(&v2) && (v3 = v2, (LODWORD(v2) & 0x7F800000) != 2139095040) && sub_10018100(&v4) )
  {
    result = 1;
    if ( v4 > 0.0001051503277267329 )
      *a1 = v2 / v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002A5D0) --------------------------------------------------------
int __cdecl sub_1002A5D0(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_10022760(1, 74, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10022760(1, 75, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10022760(1, 76, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10022760(1, 77, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10022760(1, 78, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10022760(1, 79, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + unk_10063220 >= v6 )
  {
    v2 = unk_10063220;
  }
  else
  {
    v2 = unk_10063220;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (1002A800) --------------------------------------------------------
int __cdecl sub_1002A800(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_10022760(1, 99, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10022760(1, 100, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10022760(1, 101, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10022760(1, 102, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10022760(1, 103, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10022760(1, 104, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + unk_10063220 >= v6 )
  {
    v2 = unk_10063220;
  }
  else
  {
    v2 = unk_10063220;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (1002AA30) --------------------------------------------------------
int __cdecl sub_1002AA30(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_10022760(1, 68, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10022760(1, 69, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10022760(1, 70, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10022760(1, 71, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10022760(1, 72, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10022760(1, 73, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + unk_10063220 >= v6 )
  {
    v2 = unk_10063220;
  }
  else
  {
    v2 = unk_10063220;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (1002AC60) --------------------------------------------------------
int __cdecl sub_1002AC60(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_10022760(1, 93, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10022760(1, 94, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10022760(1, 95, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10022760(1, 96, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10022760(1, 97, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10022760(1, 98, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + unk_10063220 >= v6 )
  {
    v2 = unk_10063220;
  }
  else
  {
    v2 = unk_10063220;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (1002AE90) --------------------------------------------------------
char __usercall sub_1002AE90@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char result; // al@4
  float v3; // [sp+4h] [bp-24h]@1
  float v4; // [sp+8h] [bp-20h]@1
  char v5; // [sp+Ch] [bp-1Ch]@1
  float v6; // [sp+18h] [bp-10h]@1

  v3 = 9.8999998e24;
  v1 = 0;
  v4 = sub_10018580();
  sub_10032B40(41109, &v5, 24, &unk_100A44E0);
  if ( v6 != 9.8999998e24 && v4 != 9.8999998e24 )
  {
    v1 = 1;
    v3 = v4 - v6;
  }
  result = v1;
  *a1 = v3;
  return result;
}

//----- (1002AF20) --------------------------------------------------------
char __usercall sub_1002AF20@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char result; // al@3
  float v3; // [sp+4h] [bp-20h]@1
  char v4; // [sp+8h] [bp-1Ch]@1
  float v5; // [sp+14h] [bp-10h]@1

  v3 = 9.8999998e24;
  v1 = 0;
  sub_10032B40(41109, &v4, 24, &unk_100A44E0);
  if ( v5 != 9.8999998e24 )
  {
    v3 = v5;
    v1 = 1;
  }
  result = v1;
  *a1 = v3;
  return result;
}

//----- (1002AF90) --------------------------------------------------------
bool __cdecl sub_1002AF90(float *a1)
{
  bool v1; // bl@1
  bool result; // al@3
  float v3; // [sp+4h] [bp-4h]@1

  v3 = 9.8999998e24;
  v1 = sub_1002FDF0(&v3, 0, 0, 2) != 0;
  if ( 9.8999998e24 != v3 )
    v3 = sub_1002FD80() + v3;
  result = v1;
  *a1 = v3;
  return result;
}

//----- (1002AFF0) --------------------------------------------------------
char __cdecl sub_1002AFF0(float a1, void *a2)
{
  __int16 v2; // cx@1
  char result; // al@4
  double v4; // st7@32
  double v5; // st7@69
  float v6; // ST0C_4@70
  float v7; // [sp+Ch] [bp-4h]@1
  float v8; // [sp+14h] [bp+4h]@32
  float v9; // [sp+14h] [bp+4h]@35

  HIBYTE(v2) = BYTE1(a1);
  v7 = 9.8999998e24;
  if ( (signed int)LOWORD(a1) > 301 )
  {
    switch ( LOWORD(a1) )
    {
      case 0x12Eu:
        v5 = 511.0;
        goto LABEL_70;
      case 0x12Fu:
        v5 = 1000.0;
        goto LABEL_70;
      case 0x191u:
        result = sub_100296E0((float *)a2);
        break;
      case 0x192u:
        result = sub_100290D0(0.0, (int)a2);
        break;
      case 0x193u:
        result = sub_100290D0(COERCE_FLOAT(1), (int)a2);
        break;
      case 0x194u:
        result = sub_10029E30((float *)a2);
        break;
      case 0x195u:
        result = sub_10028DE0((int)a2);
        break;
      case 0x196u:
      case 0x197u:
        result = sub_10028FE0((float *)a2, LOWORD(a1) == 406);
        break;
      case 0x198u:
      case 0x199u:
        LOBYTE(v2) = LOWORD(a1) == 408;
        result = ((char (__usercall *)@<al>(float *@<esi>, __int16))sub_10029BB0)((float *)a2, v2);
        break;
      case 0x19Au:
        result = sub_10029CB0((float *)a2);
        break;
      case 0x19Bu:
        result = sub_10028C60(a2);
        break;
      case 0x19Cu:
        result = sub_10029C50((float *)a2);
        break;
      case 0x19Du:
        result = sub_10029C60((float *)a2);
        break;
      case 0x19Eu:
        result = sub_10029C40((float *)a2);
        break;
      case 0x19Fu:
        result = sub_10029C70((float *)a2);
        break;
      case 0x1A0u:
        result = sub_10032B40(9145, a2, 4, &v7) == 0;
        break;
      default:
LABEL_88:
        sub_10011520("..\\lib\\adl\\dat_custom_proc_prj.c", 724, 0, 0);
        result = 0;
        break;
    }
  }
  else if ( LOWORD(a1) == 301 )
  {
    v5 = 295.0;
LABEL_70:
    v6 = v5;
    result = sub_100299B0((float *)a2, v6);
  }
  else
  {
    switch ( LOWORD(a1) )
    {
      case 0u:
        return sub_1002A040((float *)a2);
      case 1u:
        return sub_1002A220((float *)a2);
      case 2u:
        return sub_10029E80((float *)a2);
      case 3u:
        return sub_10029F60((float *)a2);
      case 4u:
        return sub_10029D50((float *)a2);
      case 5u:
        return sub_10029890((float *)a2);
      case 7u:
        return sub_1002A0E0((float *)a2);
      case 6u:
        return sub_1002A180((float *)a2);
      case 9u:
        return sub_10028E80((float *)a2);
      case 0xAu:
        return sub_10028ED0((float *)a2);
      case 0xBu:
        return sub_10029340((float *)a2);
      case 0xDu:
        *(float *)a2 = sub_10017AF0();
        return 1;
      case 0x38u:
        return sub_10029770((float *)a2);
      case 0x39u:
        sub_10029800((float *)a2);
        goto LABEL_18;
      case 0x3Au:
        return sub_10029220((float *)a2);
      case 0x3Bu:
        return sub_100292B0((float *)a2);
      case 0x3Cu:
        return sub_100291C0((float *)a2);
      case 0x3Du:
        return sub_10029140((float *)a2);
      case 8u:
        return sub_10028CA0((float *)a2);
      case 0xCu:
        return sub_10029750((float *)a2);
      case 0xEu:
        return sub_10018190((float *)a2);
      case 0xFu:
        return sub_10018510((float *)a2);
      case 0x10u:
        return sub_10018050((float *)a2);
      case 0x11u:
        return sub_100185E0((float *)a2);
      case 0x12u:
        return sub_100180C0((float *)a2);
      case 0x13u:
        return sub_100180E0((float *)a2);
      case 0x14u:
        return sub_10018100((float *)a2);
      case 0x15u:
        v8 = sub_10018580();
        v4 = v8;
        *(float *)a2 = v8;
        goto LABEL_33;
      case 0x35u:
        v9 = sub_10017AC0();
        v4 = v9;
        *(float *)a2 = v9;
LABEL_33:
        if ( 9.8999998e24 == v4 )
          result = 0;
        else
LABEL_18:
          result = 1;
        break;
      case 0x16u:
        result = sub_10028F20((float *)a2);
        break;
      case 0x17u:
        result = sub_10028F80((float *)a2);
        break;
      case 0x18u:
        result = sub_1002A300((float *)a2);
        break;
      case 0x19u:
        result = sub_1002A3A0((float *)a2);
        break;
      case 0x1Au:
        result = sub_1002A450((float *)a2);
        break;
      case 0x1Bu:
        result = sub_1002A4D0((float *)a2);
        break;
      case 0x1Cu:
        result = sub_1002A560((float *)a2);
        break;
      case 0x1Du:
        result = sub_1002A5D0((float *)a2);
        break;
      case 0x1Eu:
        result = sub_1002A800((float *)a2);
        break;
      case 0x1Fu:
        result = sub_1002AA30((float *)a2);
        break;
      case 0x20u:
        result = sub_1002AC60((float *)a2);
        break;
      case 0x21u:
        result = sub_10029C80(6, 59, (float *)a2);
        break;
      case 0x22u:
        result = sub_10029C80(6, 60, (float *)a2);
        break;
      case 0x23u:
        result = sub_10029C80(6, 61, (float *)a2);
        break;
      case 0x24u:
        result = sub_10029C80(6, 62, (float *)a2);
        break;
      case 0x25u:
        result = sub_10028CC0((float *)a2);
        break;
      case 0x26u:
        result = sub_10028D20((float *)a2);
        break;
      case 0x27u:
        result = sub_10028D80((float *)a2);
        break;
      case 0x2Au:
        result = sub_10032B40(9000, a2, 4, &v7) == 0;
        break;
      case 0x2Bu:
        result = sub_10032B40(9001, a2, 4, &v7) == 0;
        break;
      case 0x2Cu:
        result = sub_10032B40(9002, a2, 4, &v7) == 0;
        break;
      case 0x2Du:
        result = sub_10032B40(9003, a2, 4, &v7) == 0;
        break;
      case 0x2Eu:
        result = sub_10032B40(9004, a2, 4, &v7) == 0;
        break;
      case 0x2Fu:
        result = sub_10032B40(9005, a2, 4, &v7) == 0;
        break;
      case 0x30u:
        result = sub_10032B40(9006, a2, 4, &v7) == 0;
        break;
      case 0x31u:
        result = sub_10032B40(9007, a2, 4, &v7) == 0;
        break;
      case 0x32u:
        result = sub_10032B40(9008, a2, 4, &v7) == 0;
        break;
      case 0x33u:
        result = sub_10032B40(9009, a2, 4, &v7) == 0;
        break;
      case 0x34u:
        result = sub_10032B40(9010, a2, 4, &v7) == 0;
        break;
      case 0x28u:
        result = sub_1002AE90((float *)a2);
        break;
      case 0x29u:
        result = sub_1002AF20((float *)a2);
        break;
      case 0x36u:
        result = sub_1002AF90((float *)a2);
        break;
      case 0x37u:
        result = sub_1002FDF0((float *)a2, 0, 0, 2) != 0;
        break;
      default:
        goto LABEL_88;
    }
  }
  return result;
}

//----- (1002B8A0) --------------------------------------------------------
char __cdecl sub_1002B8A0(unsigned __int16 a1, _BYTE *a2, _WORD *a3)
{
  char result; // al@4

  if ( a1 < 0x1D8u && a2 && a3 )
  {
    *a2 = byte_100A46E8[4 * a1];
    *a3 = word_100A46EA[2 * a1];
    result = 1;
  }
  else
  {
    sub_10011520("..\\lib\\adl\\iop_eau_data_tbl.c", 614, 0, 0);
    result = 0;
  }
  return result;
}
// 100A46EA: using guessed type __int16 word_100A46EA[];

//----- (1002B900) --------------------------------------------------------
int __cdecl sub_1002B900(char *a1, char a2)
{
  signed int v2; // eax@2
  int result; // eax@4
  int v4; // [sp+8h] [bp-ECh]@1
  char v5; // [sp+24h] [bp-D0h]@4

  v4 = 0;
  if ( a2 == 1 )
    v2 = 2;
  else
    v2 = a2 == 2;
  result = j_HWM_pvg_rgn_get_info(v2, &v4);
  qmemcpy(a1, &v5, 0x74u);
  return result;
}
// 10033B40: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (1002B970) --------------------------------------------------------
bool __cdecl sub_1002B970(int a1, void *a2)
{
  void *v2; // ecx@0
  char v3; // si@1
  char v4; // bl@1
  int v5; // esi@4
  bool result; // al@7

  v3 = sub_10012880(v2);
  v4 = 0;
  do
  {
    if ( (_BYTE)a1 == (char)off_100A53B8[(unsigned __int8)v4](v3) )
    {
      sub_1002B900((char *)a2, v4);
      return 1;
    }
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  v5 = (unsigned __int16)sub_100280B0(a1);
  if ( (unsigned __int16)v5 >= (unsigned __int16)sub_10011590(2) )
    result = 0;
  else
    result = sub_10012260(2, v5, a2) == 1 && !sub_1002F660(a2);
  return result;
}
// 100A53B8: using guessed type int (__cdecl *off_100A53B8[3])(char);

//----- (1002BA30) --------------------------------------------------------
char __cdecl sub_1002BA30(int a1, bool *a2)
{
  char result; // al@3
  char v3; // [sp+8h] [bp-78h]@2
  int v4; // [sp+78h] [bp-8h]@3

  switch ( (unsigned __int8)a1 )
  {
    case 1u:
    case 4u:
    case 7u:
    case 0xAu:
      if ( sub_1002B970(a1, &v3) )
      {
        *a2 = (v4 & 1) == 1;
        result = 1;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      *a2 = sub_10028090(a1) != 67;
      result = 1;
      break;
  }
  return result;
}

//----- (1002BAF0) --------------------------------------------------------
char __cdecl sub_1002BAF0(unsigned __int16 a1)
{
  char v1; // bl@1
  char result; // al@5
  char v3; // [sp+Bh] [bp-411h]@2
  int v4; // [sp+Ch] [bp-410h]@1
  int v5; // [sp+10h] [bp-40Ch]@1
  char v6[1028]; // [sp+14h] [bp-408h]@5

  v1 = 0;
  if ( sub_1002B8A0(a1, &v5, &v4) && sub_10011920(v5, v4, &v3) && (v1 = v3) != 0
    || a1 >= 0x1D8u
    || (sub_10032B80(6943, (int)v6, 1028), result = 1, !v6[a1]) )
  {
    result = v1;
  }
  return result;
}
// 1002BAF0: using guessed type char var_408[1028];

//----- (1002BB90) --------------------------------------------------------
char __cdecl sub_1002BB90(char a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@3
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10030700(a1);
  switch ( a3 )
  {
    case 5:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10030500(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 4:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10030580(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 0xA:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10030600(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 3:
      if ( a2 != 1 )
        goto LABEL_10;
      result = sub_10030680(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      break;
    default:
LABEL_10:
      result = 0;
      break;
  }
  return result;
}

//----- (1002BCA0) --------------------------------------------------------
int __cdecl sub_1002BCA0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10019B30(&a1, 1u, (int)&unk_100A5BE0, 8, 4, 4);
  if ( v1 == 4 )
  {
    sub_10011520("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_intf.c", 437, 0, 0);
    result = 42066;
  }
  else
  {
    result = dword_100A5BE4[2 * v1];
  }
  return result;
}
// 100A5BE4: using guessed type int dword_100A5BE4[];

//----- (1002BCF0) --------------------------------------------------------
signed int __cdecl sub_1002BCF0(char a1, char a2)
{
  _DWORD *v2; // esi@3
  int v3; // eax@5
  char *v5; // [sp-18h] [bp-20h]@3
  void *v6; // [sp-10h] [bp-18h]@3
  int v7; // [sp-8h] [bp-10h]@3

  if ( a2 == 11 )
  {
    v7 = 3;
    v2 = &unk_100A5D08;
    v6 = &unk_100A5D08;
    v5 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v7 = 7;
    v2 = &unk_100A5D20;
    v6 = &unk_100A5D20;
    v5 = &a1;
  }
  v3 = sub_10019B30(v5, 1u, (int)v6, 8, v7, 7);
  if ( v3 < 7 )
    return v2[2 * v3 + 1];
  return 42066;
}

//----- (1002BD50) --------------------------------------------------------
int __cdecl sub_1002BD50(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10019B30(&a1, 1u, (int)&unk_100A5D68, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_100A5D6C[2 * v1];
  return result;
}
// 100A5D6C: using guessed type int dword_100A5D6C[];

//----- (1002BD90) --------------------------------------------------------
signed int __cdecl sub_1002BD90(char a1, char a2, char a3)
{
  _DWORD *v3; // esi@3
  int v4; // eax@5
  signed int result; // eax@7
  char *v6; // [sp-18h] [bp-20h]@3
  void *v7; // [sp-10h] [bp-18h]@3

  if ( a2 == 11 )
  {
    v3 = &unk_100A5D78;
    v7 = &unk_100A5D78;
    v6 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v3 = &unk_100A5D90;
    v7 = &unk_100A5D90;
    v6 = &a1;
  }
  v4 = sub_10019B30(v6, 1u, (int)v7, 12, 2, 2);
  if ( v4 == 2 )
    return 42066;
  if ( a3 )
    result = v3[3 * v4 + 1];
  else
    result = v3[3 * v4 + 2];
  return result;
}

//----- (1002BE00) --------------------------------------------------------
int __cdecl sub_1002BE00(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10019B30(&a1, 1u, (int)&unk_100A5DA8, 8, 3, 3);
  if ( v1 == 3 )
    result = 42066;
  else
    result = dword_100A5DAC[2 * v1];
  return result;
}
// 100A5DAC: using guessed type int dword_100A5DAC[];

//----- (1002BE40) --------------------------------------------------------
int __cdecl sub_1002BE40(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10019B30(&a1, 1u, (int)&unk_100A5DC0, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_100A5DC4[2 * v1];
  return result;
}
// 100A5DC4: using guessed type int dword_100A5DC4[];

//----- (1002BE80) --------------------------------------------------------
char __cdecl sub_1002BE80(int a1, int a2)
{
  return sub_10032B00(a1 + 37000, a2, 284);
}

//----- (1002BEA0) --------------------------------------------------------
char __cdecl sub_1002BEA0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1002BCF0(a1, 11);
  return sub_10032B00(v2, a2, 24);
}

//----- (1002BEC0) --------------------------------------------------------
char __cdecl sub_1002BEC0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1002BD50(a1);
  return sub_10032B00(v2, a2, 2720);
}

//----- (1002BEF0) --------------------------------------------------------
char __cdecl sub_1002BEF0(char a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@1

  v2 = sub_1002BD90(a1, 11, 1);
  sub_10032B00(v2, a2, 36);
  v3 = sub_1002BD90(a1, 11, 0);
  return sub_10032B00(v3, a2 + 36, 32);
}

//----- (1002BF40) --------------------------------------------------------
char __cdecl sub_1002BF40(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1002BE00(a1);
  return sub_10032B00(v2, a2, 2192);
}

//----- (1002BF70) --------------------------------------------------------
char __cdecl sub_1002BF70(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1002BE40(a1);
  return sub_10032B00(v2, a2, 60);
}

//----- (1002BF90) --------------------------------------------------------
char __cdecl sub_1002BF90(int a1)
{
  return sub_10032B00(6453, a1, 5);
}

//----- (1002BFC0) --------------------------------------------------------
char __cdecl sub_1002BFC0(_DWORD *a1)
{
  void *v1; // ecx@0
  char v2; // al@1
  char v3; // al@1
  char result; // al@3
  char v5; // [sp+7h] [bp-5h]@1
  int v6; // [sp+8h] [bp-4h]@2

  v2 = sub_1001A5F0(v1);
  v5 = sub_1001A570(v2, 1);
  v3 = sub_10019B30(&v5, 1u, (int)&unk_100A7818, 4, 3, 2);
  v5 = v3;
  if ( v3 != 2 && sub_10012260(6, (unsigned __int16)word_100A781A[2 * (unsigned __int8)v3], &v6) )
  {
    result = 1;
    *a1 = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100A781A: using guessed type __int16 word_100A781A[];

//----- (1002C030) --------------------------------------------------------
bool __cdecl sub_1002C030(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  char v4; // dl@5
  bool result; // al@5

  v3 = a2;
  if ( a2 >= 0xFFu || a2 > 1u )
  {
    result = 0;
  }
  else
  {
    if ( dword_10227E40 != 1379255385 )
    {
      sub_1002BEA0(a1, (int)&byte_10227E48[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v4 = byte_10227E4D[4 * (v3 + 6 * (unsigned __int8)a1)];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_10227E4C[4 * (v3 + 6 * (unsigned __int8)a1)];
    result = (unsigned __int8)v4 < 0xBu;
  }
  return result;
}
// 10227E40: using guessed type int dword_10227E40;

//----- (1002C0A0) --------------------------------------------------------
bool __cdecl sub_1002C0A0(char a1, unsigned __int8 a2, int a3)
{
  bool result; // al@2

  if ( a2 < 1u )
  {
    if ( dword_10227E40 != 1379255385 )
      sub_1002BEA0(a1, (int)&byte_10227E48[24 * (unsigned __int8)a1]);
    *(_DWORD *)a3 = dword_10227E5C[a2 + 6 * (unsigned __int8)a1];
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10227E40: using guessed type int dword_10227E40;
// 10227E5C: using guessed type int dword_10227E5C[];

//----- (1002C100) --------------------------------------------------------
bool __cdecl sub_1002C100(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  bool result; // al@1
  int v5; // edx@5

  v3 = a2;
  result = 0;
  if ( (a2 & 0x80u) == 0 && a2 <= 1u )
  {
    if ( dword_10227E40 != 1379255385 )
    {
      sub_1002BEA0(a1, (int)&byte_10227E48[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v5 = dword_10227E54[v3 + 6 * (unsigned __int8)a1];
    *(_DWORD *)a3 = v5;
    result = (unsigned __int8)v5 < 0x13u && *(_BYTE *)(a3 + 1) < 0x13u;
  }
  return result;
}
// 10227E40: using guessed type int dword_10227E40;
// 10227E54: using guessed type int dword_10227E54[];

//----- (1002C170) --------------------------------------------------------
char __cdecl sub_1002C170(char a1, _BYTE *a2)
{
  if ( dword_10227E40 != 1379255385 )
    sub_1002BEA0(a1, (int)&byte_10227E48[24 * (unsigned __int8)a1]);
  *a2 = byte_10227E48[24 * (unsigned __int8)a1];
  return 1;
}
// 10227E40: using guessed type int dword_10227E40;

//----- (1002C1B0) --------------------------------------------------------
char __thiscall sub_1002C1B0(void *this)
{
  char v1; // bl@1
  char *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_10227E40 = sub_1000BC20(this) != 2 ? 1379255385 : 1916032632;
  memset(byte_10227E48, 0, 0x48u);
  v1 = 0;
  v4 = 0;
  v2 = byte_10227E48;
  do
  {
    result = sub_1002BEA0(v4, (int)v2);
    ++v1;
    v2 += 24;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 3u );
  return result;
}
// 10227E40: using guessed type int dword_10227E40;

//----- (1002C220) --------------------------------------------------------
char __cdecl sub_1002C220(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_100124A0(a1);
  v3 = sub_10033C50(a2, 0, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (1002C250) --------------------------------------------------------
char __cdecl sub_1002C250(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_100124A0(a1);
  v3 = sub_10033CC0(a2, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (1002C280) --------------------------------------------------------
char __cdecl sub_1002C280(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6)
{
  char result; // al@3
  char v7; // [sp+0h] [bp-4h]@1

  v7 = sub_10012590(a1);
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        result = sub_1002C100(v7, *a4, (int)a5);
      }
      else
      {
        sub_10011520("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 531, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        result = sub_1002C030(v7, *a4, (int)a5);
      }
      else
      {
        sub_10011520("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 548, 0, 0);
        result = 0;
      }
      break;
    case 3:
      if ( a6 >= 4 )
      {
        result = sub_1002C0A0(v7, *a4, (int)a5);
      }
      else
      {
        sub_10011520("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 565, 0, 0);
        result = 0;
      }
      break;
    case 7:
      if ( a6 >= 1 )
      {
        result = sub_1002C170(v7, a5);
      }
      else
      {
        sub_10011520("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 582, 0, 0);
        result = 0;
      }
      break;
    case 0x10:
      if ( a6 >= 0x40 )
      {
        result = sub_1002C250(v7, (int)a5);
      }
      else
      {
        sub_10011520("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 598, 0, 0);
        result = 0;
      }
      break;
    case 0xF:
      if ( a6 >= 0x68 )
      {
        result = sub_1002C220(v7, (int)a5);
      }
      else
      {
        sub_10011520("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 616, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10011520("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 633, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1002C450) --------------------------------------------------------
char __thiscall sub_1002C450(void *this)
{
  char v1; // bl@1
  void *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_10227E90 = sub_1000BC20(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_10227E98, 0, 0xAA0u);
  v1 = 0;
  v4 = 0;
  v2 = &unk_10227E98;
  do
  {
    result = sub_1002BEC0(v4, (int)v2);
    ++v1;
    v2 = (char *)v2 + 2720;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 2u );
  return result;
}
// 10227E90: using guessed type int dword_10227E90;

//----- (1002C4C0) --------------------------------------------------------
char __usercall sub_1002C4C0@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4)
{
  char result; // al@1

  memset(a3, 0, (unsigned __int16)a2);
  result = 0;
  if ( a4 )
  {
    if ( a4 == 1 )
      result = sub_10012200(6, 8, a1, a2, a3);
  }
  else
  {
    result = sub_10012200(6, 5, a1, a2, a3);
  }
  return result;
}

//----- (1002C500) --------------------------------------------------------
void *__usercall sub_1002C500@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4)
{
  int v4; // edi@1
  void *result; // eax@4

  v4 = 0;
  if ( dword_10227E90 == 1379255385 )
    goto LABEL_4;
  v4 = sub_10033120(86, 10);
  if ( !v4 )
  {
    memset((char *)&unk_10227E98 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
    sub_1002BEC0(a1, (int)&unk_10227E98 + 2720 * (unsigned __int8)a1);
LABEL_4:
    result = memcpy(a4, (char *)&unk_10227E98 + 2720 * (unsigned __int8)a1 + (unsigned __int16)a2, (unsigned __int16)a3);
    goto LABEL_6;
  }
  result = memset(a4, 0, (unsigned __int16)a3);
LABEL_6:
  if ( dword_10227E90 != 1379255385 )
    result = (void *)sub_100330F0(v4, 86);
  return result;
}
// 10227E90: using guessed type int dword_10227E90;

//----- (1002C5A0) --------------------------------------------------------
char __cdecl sub_1002C5A0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 <= 0xAu )
    result = sub_1002C4C0(4 * (a2 + 6), 4, a3, a1);
  return result;
}

//----- (1002C5E0) --------------------------------------------------------
bool __cdecl sub_1002C5E0(char a1, char a2, void *a3)
{
  bool result; // al@1
  unsigned __int8 v4; // al@3

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 <= 0xAu )
  {
    sub_1002C500(a1, 4 * ((unsigned __int8)a2 + 6), 4, a3);
    v4 = *((_BYTE *)a3 + 1);
    result = v4 < 0x33u || v4 >= 0x64u && v4 <= 0x81u || v4 >= 0x96u && v4 <= 0x9Eu;
  }
  return result;
}

//----- (1002C640) --------------------------------------------------------
char __cdecl sub_1002C640(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xAu )
    result = sub_1002C4C0(a2, 1, a3, a1);
  return result;
}

//----- (1002C680) --------------------------------------------------------
char __cdecl sub_1002C680(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xAu )
  {
    sub_1002C500(a1, (unsigned __int8)a2, 1, a3);
    result = 1;
  }
  return result;
}

//----- (1002C6B0) --------------------------------------------------------
char __cdecl sub_1002C6B0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xBu )
    result = sub_1002C4C0(a2 + 10, 1, a3, a1);
  return result;
}

//----- (1002C6F0) --------------------------------------------------------
char __cdecl sub_1002C6F0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xBu )
  {
    sub_1002C500(a1, (unsigned __int8)a2 + 10, 1, a3);
    result = 1;
  }
  return result;
}

//----- (1002C730) --------------------------------------------------------
char __cdecl sub_1002C730(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 2u )
    result = sub_1002C4C0(16 * (a2 + 50), 16, a3, a1);
  return result;
}

//----- (1002C770) --------------------------------------------------------
bool __cdecl sub_1002C770(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 2u )
  {
    sub_1002C500(a1, 16 * ((unsigned __int8)a2 + 50), 16, a3);
    result = *(_BYTE *)a3 < 8u && *((_BYTE *)a3 + 1) < 8u;
  }
  return result;
}

//----- (1002C7C0) --------------------------------------------------------
char __cdecl sub_1002C7C0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x29u )
    result = sub_1002C4C0(12 * a2 + 68, 12, a3, a1);
  return result;
}

//----- (1002C800) --------------------------------------------------------
bool __cdecl sub_1002C800(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x29u )
  {
    sub_1002C500(a1, 12 * (unsigned __int8)a2 + 68, 12, a3);
    result = *((_WORD *)a3 + 1) < 0x319u;
  }
  return result;
}

//----- (1002C840) --------------------------------------------------------
char __cdecl sub_1002C840(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x2Au )
    result = sub_1002C4C0(4 * (a2 + 140), 4, a3, a1);
  return result;
}

//----- (1002C880) --------------------------------------------------------
bool __cdecl sub_1002C880(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x2Au )
  {
    sub_1002C500(a1, 4 * ((unsigned __int8)a2 + 140), 4, a3);
    result = *((_WORD *)a3 + 1) < 0x145u;
  }
  return result;
}

//----- (1002C8C0) --------------------------------------------------------
char __cdecl sub_1002C8C0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1002C4C0(1229, 1, a2, a1);
  return result;
}

//----- (1002C8F0) --------------------------------------------------------
char __cdecl sub_1002C8F0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1002C500(a1, 1229, 1, a2);
    result = 1;
  }
  return result;
}

//----- (1002C920) --------------------------------------------------------
char __cdecl sub_1002C920(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1002C4C0(1212, 16, a2, a1);
  return result;
}

//----- (1002C950) --------------------------------------------------------
char __cdecl sub_1002C950(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1002C500(a1, 1212, 16, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002C980) --------------------------------------------------------
char __cdecl sub_1002C980(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1002C4C0(2400, 65, a2, a1);
  return result;
}

//----- (1002C9B0) --------------------------------------------------------
char __cdecl sub_1002C9B0(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1002C500(a1, 2400, 65, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002C9E0) --------------------------------------------------------
char __cdecl sub_1002C9E0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 < 8u && (unsigned __int8)a1 < 2u )
    result = sub_1002C4C0(4 * (a2 + 182), 4, a3, a1);
  return result;
}

//----- (1002CA20) --------------------------------------------------------
char __cdecl sub_1002CA20(char a1, char a2, void *a3)
{
  char result; // al@2

  if ( (unsigned __int8)a2 > 7u )
    result = sub_10011520("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 1428, 0, 0);
  else
    result = (unsigned int)sub_1002C500(a1, 4 * ((unsigned __int8)a2 + 182), 4, a3);
  return result;
}

//----- (1002CA70) --------------------------------------------------------
char __cdecl sub_1002CA70(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 <= 4u )
    result = sub_1002C4C0(8 * (a2 + 95), 8, a3, a1);
  return result;
}

//----- (1002CAB0) --------------------------------------------------------
char __cdecl sub_1002CAB0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = a2;
  if ( (unsigned __int8)a2 <= 4u )
    result = (unsigned int)sub_1002C500(a1, 8 * ((unsigned __int8)a2 + 95), 8, a3);
  return result;
}

//----- (1002CAE0) --------------------------------------------------------
char __cdecl sub_1002CAE0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1002C4C0(22, 1, a2, a1);
  return result;
}

//----- (1002CB10) --------------------------------------------------------
char __cdecl sub_1002CB10(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1002C4C0(832, 4, a2, a1);
  return result;
}

//----- (1002CB40) --------------------------------------------------------
char __cdecl sub_1002CB40(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1002C500(a1, 832, 4, a2);
    result = 1;
  }
  return result;
}

//----- (1002CB70) --------------------------------------------------------
char __cdecl sub_1002CB70(int a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@4
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_100308E0(a1);
  if ( v6 == 2 )
  {
LABEL_44:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 0:
        if ( a2 )
        {
          sub_1002CA20(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_1002C9E0(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 1:
        if ( a2 )
        {
          sub_1002CAB0(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_1002CA70(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 2:
        if ( a2 )
          result = sub_1002C5E0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1002C5A0(v6, *(_BYTE *)a4, a5);
        break;
      case 3:
        if ( a2 )
          result = sub_1002C800(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1002C7C0(v6, *(_BYTE *)a4, a5);
        break;
      case 4:
        if ( a2 )
          result = sub_1002C880(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1002C840(v6, *(_BYTE *)a4, a5);
        break;
      case 5:
        if ( a2 )
          result = sub_1002C680(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1002C640(v6, *(_BYTE *)a4, a5);
        break;
      case 6:
        if ( a2 )
          result = sub_1002C6F0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1002C6B0(v6, *(_BYTE *)a4, a5);
        break;
      case 7:
        result = sub_1002CAE0(v6, a5);
        break;
      case 8:
        if ( a2 )
          result = sub_1002C950(v6, a5);
        else
          result = sub_1002C920(v6, a5);
        break;
      case 9:
        if ( a2 )
          result = sub_1002C770(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1002C730(v6, *(_BYTE *)a4, a5);
        break;
      case 0x1D:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_1002C9B0(v6, a5);
        else
          result = sub_1002C980(v6, a5);
        break;
      case 0x21:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_1002C8F0(v6, a5);
        else
          result = sub_1002C8C0(v6, a5);
        break;
      case 0x1B:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_1002CB40(v6, a5);
        else
          result = sub_1002CB10(v6, a5);
        break;
      default:
        sub_10011520("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 2329, 0, 0);
        goto LABEL_44;
    }
  }
  return result;
}
// 100331E0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1002CF10) --------------------------------------------------------
char sub_1002CF10()
{
  char v1; // [sp+4h] [bp-100h]@1

  memset(&v1, 0, 0xFCu);
  if ( sub_10012260(1, 1309, &v1) )
    sub_10027B00((int)&v1);
  return 0;
}

//----- (1002CFB0) --------------------------------------------------------
BOOL __cdecl sub_1002CFB0(int a1, int a2)
{
  return sub_10032AE0(6455, a2, 252) == 0;
}

//----- (1002CFD0) --------------------------------------------------------
char __cdecl sub_1002CFD0(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1002CFB0(a1, a5);
  }
  else
  {
    result = sub_1002CF10();
  }
  return result;
}

//----- (1002D010) --------------------------------------------------------
int __cdecl sub_1002D010(char a1, char *a2)
{
  int result; // eax@1
  char *v3; // edi@2
  char *v4; // esi@3
  int v5; // edi@3

  result = sub_10019B30(&a1, 1u, (int)&unk_100A8D68, 68, 4, 4);
  if ( result < 4 )
  {
    v3 = a2;
    if ( a2 )
    {
      v4 = (char *)&unk_100A8D69 + 68 * result;
      qmemcpy(a2, v4, 0x40u);
      v4 += 64;
      v5 = (int)(v3 + 64);
      *(_WORD *)v5 = *(_WORD *)v4;
      *(_BYTE *)(v5 + 2) = v4[2];
    }
  }
  return result;
}

//----- (1002D060) --------------------------------------------------------
char sub_1002D060()
{
  return 2;
}

//----- (1002D070) --------------------------------------------------------
int __cdecl sub_1002D070(int a1)
{
  return a1 + 9;
}

//----- (1002D080) --------------------------------------------------------
int __cdecl sub_1002D080(void *a1)
{
  int v1; // edi@1
  __int16 v2; // ax@1
  _WORD *v3; // ecx@1

  v1 = sub_10032E30();
  memset(a1, 0, 0xDCu);
  sub_1000A7B0((char *)a1 + 204, 0xFu, "test sk %i", v1);
  v2 = sub_1002D070(v1);
  *v3 = v2;
  *((_DWORD *)a1 + 10) = (char *)a1 + 204;
  *((_DWORD *)a1 + 11) = (char *)a1 + 76;
  *((_WORD *)a1 + 24) = 128;
  *((_BYTE *)a1 + 50) = 22;
  *((_DWORD *)a1 + 13) = 0;
  *((_DWORD *)a1 + 14) = 300;
  *((_DWORD *)a1 + 15) = 0;
  *((_DWORD *)a1 + 16) = 500;
  *((_DWORD *)a1 + 17) = 0;
  return sub_10030970((int)a1, (int)v3);
}

//----- (1002D100) --------------------------------------------------------
int __cdecl sub_1002D100(int a1, int a2)
{
  int v2; // esi@1
  _DWORD *v3; // ST00_4@1
  int result; // eax@2

  v2 = a1;
  v3 = (_DWORD *)a1;
  *(_DWORD *)(a1 + 60) = a2;
  sub_10030B80(v3, (char *)&a1);
  if ( (_BYTE)a1 )
    result = v2 + 76;
  else
    result = 0;
  return result;
}

//----- (1002D130) --------------------------------------------------------
signed int __cdecl sub_1002D130(int a1, int a2, int a3)
{
  signed int result; // eax@1
  int v4; // esi@2
  __int16 v5; // ax@4
  int v6; // eax@6
  int v7; // ebx@6

  result = 0;
  if ( a3 )
  {
    v4 = *(_DWORD *)a1;
    if ( !*(_DWORD *)a1 )
      return -59;
    v5 = 0;
    if ( *(_BYTE *)(v4 + 14) & 0x10 )
      v5 = 2;
    v6 = sub_10033AD0(*(_DWORD *)(a1 + 4), a2, a3, v5, *(_DWORD *)(v4 + 28));
    v7 = v6;
    if ( v6 >= 0 )
    {
      *(_DWORD *)(a1 + 32) = sub_10032ED0();
    }
    else if ( v6 != -57 || (unsigned int)(sub_10032ED0() - *(_DWORD *)(a1 + 32)) >= *(_DWORD *)(v4 + 32) )
    {
      sub_10030970(a1, v4);
      return v7;
    }
    result = v7;
  }
  return result;
}

//----- (1002D150) --------------------------------------------------------
const char *__cdecl sub_1002D150(int a1, int a2)
{
  const char *result; // eax@3

  if ( a2 <= 0 )
  {
    result = "\x1B[32;40mPASS\x1B[0m";
    if ( !*(_BYTE *)(a1 + 576) )
      result = "PASS";
  }
  else if ( *(_BYTE *)(a1 + 576) )
  {
    result = "\x1B[31;40mFAILED\x1B[0m";
  }
  else
  {
    result = "FAIL";
  }
  return result;
}

//----- (1002D190) --------------------------------------------------------
char __cdecl sub_1002D190(int a1, int *a2, unsigned int a3)
{
  int *v3; // ebx@1
  int v4; // ebp@1
  int v5; // eax@1
  char *v6; // ebp@1
  char *v7; // eax@11
  int v8; // ecx@12
  int v9; // ST44_4@13
  bool v10; // zf@18
  signed int v11; // edx@24
  const char *v12; // eax@32
  _BYTE *v13; // eax@39
  int v14; // eax@44
  bool v15; // sf@44
  char v16; // cl@45
  char *v17; // eax@50
  int v18; // edx@52
  int v19; // edi@53
  unsigned int v20; // eax@53
  const char *v21; // ecx@53
  _DWORD *v22; // edx@53
  int v23; // esi@57
  int v24; // eax@58
  _BYTE *v25; // ecx@58
  _BYTE *v26; // edx@58
  int v27; // eax@60
  _BYTE *v28; // ecx@60
  _BYTE *v29; // edx@60
  _BYTE *v30; // ecx@62
  _BYTE *v31; // edx@62
  signed int v32; // eax@64
  signed int v33; // edi@73
  int v34; // esi@74
  int v35; // ecx@76
  int v36; // edx@82
  int v37; // eax@83
  int *v38; // eax@106
  void *v39; // ebx@106
  void *v40; // edi@109
  void *v41; // esi@112
  const char *v42; // eax@114
  int v43; // ST30_4@123
  const char *v44; // eax@142
  const char *v45; // eax@148
  char *v47; // [sp-14h] [bp-340h]@69
  char v48; // [sp+12h] [bp-31Ah]@24
  char v49; // [sp+13h] [bp-319h]@21
  signed int v50; // [sp+18h] [bp-314h]@52
  void *v51; // [sp+18h] [bp-314h]@94
  void *v52; // [sp+1Ch] [bp-310h]@97
  void *v53; // [sp+20h] [bp-30Ch]@103
  void *v54; // [sp+24h] [bp-308h]@45
  char v55[508]; // [sp+28h] [bp-304h]@11
  char v56; // [sp+224h] [bp-108h]@44
  char v57; // [sp+227h] [bp-105h]@11
  char v58; // [sp+228h] [bp-104h]@123
  char v59; // [sp+327h] [bp-5h]@123

  v3 = a2;
  v4 = sub_10022A40();
  LOBYTE(v5) = a1;
  v6 = (char *)&unk_102293E0 + 580 * v4;
  switch ( a1 )
  {
    case 0:
      LOBYTE(v5) = sub_1000B5A0((int)v6, 0);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1000B550((int)v6, "Resetting test status\r\n");
      return v5;
    case 1:
      LOBYTE(v5) = sub_1000B0C0((int)v6);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1000B550((int)v6, "Clearing test status\r\n");
      return v5;
    case 11:
      LOBYTE(v5) = sub_1000B5A0((int)v6, 0);
      return v5;
    case 4:
      sub_1000AF40((int)v6, *a2);
      if ( v6[577] && !v6[578] )
      {
        v7 = sub_1000B270((char *)a2[1]);
        _snprintf(v55, 0x200u, "Test Suite: %s (%s)\r\n", *a2, v7);
        v57 = 0;
        sub_1000B550((int)v6, v55);
      }
      LOBYTE(v5) = 0;
      v8 = (int)&v6[16 * *(_DWORD *)v6 + 4];
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      *(_DWORD *)(v8 + 8) = 0;
      *(_DWORD *)(v8 + 12) = 0;
      return v5;
    case 5:
      v9 = *a2;
      LOBYTE(v5) = sub_1000AF30((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Group: %s - Begin\r\n\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 6:
      LOBYTE(v5) = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8] = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4] = 0;
      v10 = v6[577] == 0;
      *((_DWORD *)v6 + 143) = 0;
      if ( !v10 && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Case: %s\r\n\r\n", *a2);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1000B550((int)v6, v55);
      }
      return v5;
    case 7:
      v49 = sub_1000A930((int)a2, a3);
      if ( !v49 && !v6[577] )
        goto LABEL_83;
      if ( v6[578] )
        goto LABEL_81;
      v11 = 0;
      v48 = 0;
      if ( a3 > 7 )
        v11 = strlen((const char *)a2[7]);
      if ( a3 > 8 )
        v11 += strlen((const char *)a2[8]);
      if ( a3 > 3 )
        v11 += strlen((const char *)a2[3]);
      if ( v11 > 100 )
        v48 = 1;
      v12 = sub_1002D150((int)v6, (unsigned __int8)v49);
      _snprintf(v55, 0x200u, "%s ", v12);
      v57 = 0;
      sub_1000B550((int)v6, v55);
      if ( a3 > 7 )
      {
        _snprintf(v55, 0x200u, " ACT: %-17s", a2[7]);
        v57 = 0;
        sub_1000B550((int)v6, v55);
        if ( v48 )
          sub_1000B550((int)v6, "\r\n     ");
      }
      if ( a3 > 8 )
      {
        _snprintf(v55, 0x200u, " EXP: %-17s", a2[8]);
        v57 = 0;
        sub_1000B550((int)v6, v55);
        if ( v48 )
          sub_1000B550((int)v6, "\r\n     ");
      }
      if ( a3 > 9 )
      {
        v13 = (_BYTE *)a2[9];
        if ( v13 )
        {
          if ( *v13 )
          {
            if ( memcmp((const void *)a2[9], "0", 2u) )
            {
              _snprintf(v55, 0x200u, " TOL: %-17s", a2[9]);
              v57 = 0;
              sub_1000B550((int)v6, v55);
              if ( v48 )
                sub_1000B550((int)v6, "\r\n     ");
            }
          }
        }
      }
      v14 = _snprintf(v55, 0x1FCu, " %s", a2[3]);
      v15 = v14 < 0;
      v56 = 0;
      if ( v14 > 0 )
      {
        do
        {
          v16 = *((_BYTE *)&v54 + v14 + 3);
          if ( v16 != 10 && v16 != 13 )
            break;
          *((_BYTE *)&v54 + --v14 + 4) = 0;
        }
        while ( v14 > 0 );
        v15 = v14 < 0;
      }
      if ( !v15 )
      {
        v17 = &v55[v14];
        *(_WORD *)v17 = 2573;
        v17[2] = 0;
      }
      sub_1000B550((int)v6, v55);
      if ( a3 <= 0xA )
        goto LABEL_72;
      v18 = 10;
      v50 = 10;
      if ( (signed int)a3 <= 10 )
        goto LABEL_72;
      do
      {
        v19 = v3[v18];
        v20 = 6;
        v21 = "Info: ";
        v22 = (_DWORD *)v3[v18];
        do
        {
          if ( *v22 != *(_DWORD *)v21 )
            goto LABEL_57;
          v20 -= 4;
          v21 += 4;
          ++v22;
        }
        while ( v20 >= 4 );
        if ( !v20 )
          goto LABEL_67;
LABEL_57:
        v23 = *(_BYTE *)v22 - *v21;
        if ( *(_BYTE *)v22 == *v21 )
        {
          v24 = v20 - 1;
          v25 = v21 + 1;
          v26 = (char *)v22 + 1;
          if ( !v24
            || (v23 = *v26 - *v25, *v26 == *v25)
            && ((v27 = v24 - 1, v28 = v25 + 1, v29 = v26 + 1, !v27)
             || (v23 = *v29 - *v28, *v29 == *v28)
             && ((v30 = v28 + 1, v31 = v29 + 1, v27 == 1) || (v23 = *v31 - *v30, *v31 == *v30))) )
          {
            v3 = a2;
LABEL_67:
            v32 = 0;
            goto LABEL_68;
          }
        }
        v3 = a2;
        v32 = 1;
        if ( v23 <= 0 )
          v32 = -1;
LABEL_68:
        if ( v32 )
        {
          _snprintf(v55, 0x200u, "      Post Analysis: %s\r\n", v19);
          v47 = v55;
        }
        else
        {
          _snprintf(v55, 0x200u, "      Compare Info: %s\r\n", v19 + 6);
          v47 = v55;
        }
        v57 = 0;
        sub_1000B550((int)v6, v47);
        v18 = v50++ + 1;
      }
      while ( v50 < (signed int)a3 );
LABEL_72:
      if ( v6[309] )
      {
        v33 = 0;
        if ( *((_DWORD *)v6 + 143) > 0 )
        {
          v34 = (int)(v6 + 336);
          do
          {
            if ( v33 >= 20 )
              break;
            v35 = *(_DWORD *)(v34 - 4);
            if ( *(_DWORD *)(v34 + 4) )
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s - %s\r\n", v33, v35, *(_DWORD *)v34, *(_DWORD *)(v34 + 4));
            else
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s\r\n", v33, v35, *(_DWORD *)v34);
            v57 = 0;
            sub_1000B550((int)v6, v55);
            ++v33;
            v34 += 12;
          }
          while ( v33 < *((_DWORD *)v6 + 143) );
        }
        _snprintf(v55, 0x200u, "      Location: %s:%s\r\n", v3[1], v3[2]);
        v57 = 0;
        sub_1000B550((int)v6, v55);
      }
LABEL_81:
      if ( v49 )
      {
        v36 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v36 + 4];
        v5 = (int)&v6[v36 + 4];
      }
      else
      {
LABEL_83:
        v37 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v37 + 8];
        v5 = (int)&v6[v37 + 8];
      }
      return v5;
    case 9:
      LOBYTE(v5) = sub_1000B1A0((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "Test Group: %s - End\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 3:
      LOBYTE(v5) = sub_1000AC50((const void **)a2, a3);
      if ( !(_BYTE)v5 && !v6[578] )
      {
        if ( v6[577]
          || sub_1000AD10((const void **)a2, a3)
          || (LOBYTE(v5) = sub_1000AB60((const void **)a2, a3), (_BYTE)v5) )
        {
          if ( a3 <= 8 )
            v51 = &unk_1005C3FD;
          else
            v51 = (void *)a2[8];
          if ( a3 <= 7 )
            v52 = &unk_1005C3FD;
          else
            v52 = (void *)a2[7];
          if ( a3 <= 6 )
            v54 = &unk_1005C3FD;
          else
            v54 = (void *)a2[6];
          if ( a3 <= 5 )
            v53 = &unk_1005C3FD;
          else
            v53 = (void *)a2[5];
          if ( a3 <= 4 )
          {
            v38 = a2;
            v39 = &unk_1005C3FD;
          }
          else
          {
            v38 = a2;
            v39 = (void *)a2[4];
          }
          if ( a3 <= 3 )
            v40 = &unk_1005C3FD;
          else
            v40 = (void *)v38[3];
          if ( a3 )
            v41 = (void *)*v38;
          else
            v41 = &unk_1005C3FD;
          v10 = sub_1000AC20((const void **)a2, a3) == 0;
          v42 = (const char *)&unk_1005C3FD;
          if ( v10 )
            v42 = "   ";
          _snprintf(v55, 0x200u, "%s%s %s %s %s %s %s %s\r\n", v42, v41, v40, v39, v53, v54, v52, v51);
          v57 = 0;
          LOBYTE(v5) = (unsigned int)sub_1000B550((int)v6, v55);
        }
      }
      return v5;
    case 2:
      if ( v6[578] )
        return v5;
      if ( sub_1000A960((const void **)a2, a3) )
      {
        dword_102293D8 = 2;
        sub_1000B550((int)v6, (const char *)&word_100A9D0C);
        sub_1000B550((int)v6, "   Command Format:\r\n");
        sub_1000B550(
          (int)v6,
          "       <global-command> [<arguments>]  : Runs the global command with the optional arguments\r\n");
        sub_1000B550(
          (int)v6,
          "                                         Commands may consist of multiple words. Arguments may\r\n");
        sub_1000B550(
          (int)v6,
          "                                         or may not be required and will be either booleans,\r\n");
        sub_1000B550(
          (int)v6,
          "                                         integers (32-bit signed or unsigned), floats, or\r\n");
        sub_1000B550((int)v6, "                                         strings depending upon the command\r\n");
        sub_1000B550((int)v6, "       <suite>                         : Runs all the test cases of the test suite\r\n");
        sub_1000B550(
          (int)v6,
          "       <suite> <case>                  : Runs the specific test case of the test suite\r\n");
        sub_1000B550(
          (int)v6,
          "       <suite> <command> [<arguments>] : Runs the test suite specific command with optional arguments\r\n");
        sub_1000B550((int)v6, (const char *)&word_100A9D0C);
        sub_1000B550((int)v6, "   Notes:\r\n");
        sub_1000B550((int)v6, "       Commands, suite names and test case names are case-insensitive.\r\n");
        sub_1000B550((int)v6, (const char *)&word_100A9D0C);
        sub_1000B550(
          (int)v6,
          "       In the command table below, indentation indicates the command is a sub-command of the unindented\r\n");
        sub_1000B550(
          (int)v6,
          "       command. Each test case and test suite command is shown indented below the test suite. To run\r\n");
        sub_1000B550(
          (int)v6,
          "       a test case or test suite command, you must enter the full command which consists of the both\r\n");
        sub_1000B550((int)v6, "       the suite name and the test case or test suite command.\r\n");
        sub_1000B550((int)v6, (const char *)&word_100A9D0C);
        sub_1000B550(
          (int)v6,
          "       In the command table below, ***global-commands*** is a place-holder to identify the set of\r\n");
        sub_1000B550(
          (int)v6,
          "       global commands and is not a real test suite name. The global commands should be entered\r\n");
        sub_1000B550((int)v6, "       without a test suite name.\r\n");
        sub_1000B550((int)v6, (const char *)&word_100A9D0C);
        sub_1000B550((int)v6, "   Examples:\r\n");
        sub_1000B550(
          (int)v6,
          "       help                            : Displays a brief help message showing all the test suites\r\n");
        sub_1000B550((int)v6, "       help -q                         : Quite help; Equivalent to help\r\n");
        sub_1000B550(
          (int)v6,
          "       help -v                         : Verbose help; Displays all available help information\r\n");
        sub_1000B550(
          (int)v6,
          "       help utf_validate.c             : Displays verbose help for the utf_validate.c test suite\r\n");
        sub_1000B550(
          (int)v6,
          "       all                             : Will run all the test cases of the test suites\r\n");
        sub_1000B550(
          (int)v6,
          "       utf_validate.c                  : Runs all the test cases of the utf_validate.c suite\r\n");
        sub_1000B550(
          (int)v6,
          "       utf_validate.c FAIL ON          : Enables the failing test cases of the utf_validate.c test suite\r\n");
        sub_1000B550(
          (int)v6,
          "       utf_validate.c Failing_Cases    : Runs the failing test case of the utf_validate.c test suite\r\n");
        sub_1000B550((int)v6, (const char *)&word_100A9D0C);
        sub_1000B550((int)v6, "   Command                                 Description\r\n");
        LOBYTE(v5) = (unsigned int)sub_1000B550(
                                     (int)v6,
                                     "   --------------------------------        --------------------------------\r\n");
        return v5;
      }
      if ( sub_1000A9F0((const void **)a2, a3) )
      {
        LOBYTE(v5) = (unsigned int)sub_1000B550((int)v6, (const char *)&word_100A9D0C);
        return v5;
      }
      if ( sub_1000A9C0((const void **)a2, a3) )
      {
        _snprintf(&v58, 0x100u, "%s %s", a2[3], a2[4]);
        v43 = a2[5];
        v59 = 0;
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s %s\r\n",
          dword_102293D8,
          &unk_1005C3FD,
          &v58,
          6 - dword_102293D8,
          word_1005E650,
          v43);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1000B550((int)v6, v55);
        return v5;
      }
      if ( sub_1000AA20((const void **)a2, a3) )
      {
        LOBYTE(v5) = sub_1000AA50((int)a2, a3);
        if ( (_BYTE)v5 )
        {
          dword_102293D8 += 2;
          return v5;
        }
        if ( sub_1000AA90((int)a2, a3) )
        {
          LOBYTE(v5) = 2;
          if ( dword_102293D8 < 2 )
            dword_102293D8 = 0;
          else
            dword_102293D8 -= 2;
          return v5;
        }
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s group\r\n",
          dword_102293D8,
          &unk_1005C3FD,
          a2[2],
          6 - dword_102293D8,
          word_1005E650,
          a2[2]);
LABEL_134:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1000B550((int)v6, v55);
        return v5;
      }
      if ( sub_1000A990((const void **)a2, a3) )
      {
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s case\r\n",
          dword_102293D8,
          &unk_1005C3FD,
          a2[3],
          6 - dword_102293D8,
          word_1005E650,
          a2[3]);
        goto LABEL_134;
      }
      if ( sub_1000AB00((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s Runs the %s suite\r\n", a2[1], a2[1]);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1000B550((int)v6, v55);
      }
      else if ( sub_1000AAD0((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s A test results listener\r\n", a2[1]);
LABEL_17:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1000B550((int)v6, v55);
      }
      else
      {
        LOBYTE(v5) = (unsigned int)sub_1000B550((int)v6, "Unknown test help event\r\n");
      }
      return v5;
    case 8:
      if ( v6[577] && !v6[578] )
      {
        v44 = sub_1002D150((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        _snprintf(v55, 0x200u, "\r\n   Test Case Results: %s\r\n", v44);
        v57 = 0;
        sub_1000B550((int)v6, v55);
        _snprintf(v55, 0x200u, "      Passed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8]);
        v57 = 0;
        sub_1000B550((int)v6, v55);
        _snprintf(v55, 0x200u, "      Failed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        v57 = 0;
        sub_1000B550((int)v6, v55);
      }
      v5 = (int)&v6[16 * *(_DWORD *)v6];
      if ( *(_DWORD *)(v5 + 4) )
        ++*(_DWORD *)(v5 + 12);
      else
        ++*(_DWORD *)(v5 + 16);
      return v5;
    case 10:
      if ( v6[577] && !v6[578] )
      {
        v45 = sub_1002D150((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        _snprintf(v55, 0x200u, "\r\nTest Suite Results: %s\r\n", v45);
        v57 = 0;
        sub_1000B550((int)v6, v55);
        _snprintf(v55, 0x200u, "   Passed Cases: %4d\r\n", *(_DWORD *)&v6[16 * (*(_DWORD *)v6 + 1)]);
        v57 = 0;
        sub_1000B550((int)v6, v55);
        _snprintf(v55, 0x200u, "   Failed Cases: %4d\r\n\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        v57 = 0;
        sub_1000B550((int)v6, v55);
      }
      LOBYTE(v5) = sub_1000B200((int)v6, 0);
      return v5;
    case 12:
      LOBYTE(v5) = sub_1000B4D0((int)v6, 0);
      return v5;
    case 13:
      if ( a3 >= 2 )
      {
        v5 = *((_DWORD *)v6 + 143);
        if ( v5 < 20 )
        {
          *(_DWORD *)&v6[12 * v5 + 332] = *a2;
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143) + 28)] = a2[1];
          v5 = 3 * *((_DWORD *)v6 + 143);
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143))++ + 340] = a2[2];
        }
      }
      return v5;
    case 14:
      --*((_DWORD *)v6 + 143);
      return v5;
    default:
      if ( !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1000B550((int)v6, "Unknown test event\r\n");
      return v5;
  }
}
// 100A9D0C: using guessed type __int16 word_100A9D0C;
// 102293D8: using guessed type int dword_102293D8;
// 1002D190: using guessed type char var_304[508];

//----- (1002DF40) --------------------------------------------------------
signed int __cdecl sub_1002DF40(int a1, int a2)
{
  char *v2; // eax@1

  v2 = (char *)&unk_102293E0 + 580 * sub_10022A40();
  if ( a1 == 12 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[576] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else if ( a1 == 13 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[577] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else
  {
    if ( a1 != 14 )
      return sub_1000B100(a1, a2, (int)v2);
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[578] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  return 9;
}

//----- (1002DFC0) --------------------------------------------------------
char **__cdecl sub_1002DFC0(int a1)
{
  char *v1; // eax@1

  v1 = (char *)&unk_102293E0 + 580 * sub_10022A40();
  v1[576] = 1;
  v1[577] = 1;
  v1[578] = 0;
  sub_1000B310((int)v1, a1, (int)".txt");
  return &off_100A90D8;
}
// 100A90D8: using guessed type char *off_100A90D8;

//----- (1002E000) --------------------------------------------------------
int (__cdecl *__cdecl sub_1002E000(const char *a1))(const char *)
{
  int v1; // eax@1

  v1 = sub_10022A40();
  return sub_1000B550((int)&unk_10229F38 + 1812 * v1, a1);
}

//----- (1002E020) --------------------------------------------------------
const char *sub_1002E020()
{
  return "See version control for test execution date";
}

//----- (1002E030) --------------------------------------------------------
__int64 sub_1002E030()
{
  return 0i64;
}

//----- (1002E040) --------------------------------------------------------
const char *sub_1002E040()
{
  return "Not Available";
}

//----- (1002E050) --------------------------------------------------------
int __usercall sub_1002E050@<eax>(_BYTE *a1@<edi>, int a2)
{
  char v2; // al@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // cl@3
  _BYTE *v6; // edx@4

  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    v4 = *(_BYTE *)(v3 + a2);
    if ( !v4 )
      break;
    v5 = *a1;
    if ( *a1 )
    {
      v6 = a1;
      while ( v5 != v4 )
      {
        v5 = (v6++)[1];
        if ( !v5 )
          goto LABEL_9;
      }
      v2 = 1;
    }
LABEL_9:
    ++v3;
    if ( v2 )
      return v3 - 1;
  }
  if ( v2 )
    --v3;
  return v3;
}

//----- (1002E0A0) --------------------------------------------------------
signed int __cdecl sub_1002E0A0(int a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10022A40();
  return sub_1000B100(a1, a2, (int)&unk_10229F38 + 1812 * v2);
}

//----- (1002E1F0) --------------------------------------------------------
int __usercall sub_1002E1F0@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3)
{
  char *v3; // edi@1
  char *v4; // eax@1
  unsigned int v5; // kr00_4@1
  char v6; // cl@1
  char *v7; // eax@4
  char *v8; // eax@4
  char *v9; // eax@5
  unsigned __int8 *v10; // eax@6
  unsigned __int8 *v11; // eax@9
  signed int i; // edi@9
  int result; // eax@11
  int v14; // ecx@11
  unsigned __int8 *v15; // [sp+8h] [bp-10Ch]@9
  unsigned __int8 *v16; // [sp+Ch] [bp-108h]@1
  char v17; // [sp+10h] [bp-104h]@1
  char v18[253]; // [sp+11h] [bp-103h]@3
  char v19; // [sp+10Eh] [bp-6h]@1

  v3 = a1;
  sub_10030C60((int)&a2[151 * (*a2 + 1)], (int)sub_1002E000, 0);
  *(_QWORD *)&a2[2 * *a2 + 147] = sub_1002E030();
  v4 = sub_10024890("CFG_StyleSheetDir", (int)"/Starteam/GDU1XXX/Verification/Automated_Test_Scripts/Stylesheets/");
  _snprintf(&v17, 0xFFu, v4);
  v19 = 0;
  v5 = strlen(&v17);
  v6 = (char)(&v16)[v5 + 3];
  if ( v6 != 92 && v6 != 47 )
  {
    *(&v17 + v5) = 47;
    v18[v5] = 0;
  }
  sub_100310B0((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<?xml version=\"1.0\" encoding=\"Windows-1252\"?>", 0);
  v7 = sub_10024890("CFG_StyleSheet", (int)"std_output_frmt.xsl");
  _snprintf((char *)&a2[151 * *a2 + 174], 0x200u, "<?xml-stylesheet type=\"text/xsl\" href=\"%s%s\"?>", &v17, v7);
  BYTE3(a2[151 * *a2 + 301]) = 0;
  sub_100310B0((int)&a2[151 * *a2 + 151], (unsigned __int8 *)&a2[151 * *a2 + 174], 0);
  sub_100310B0((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<!-- saved from url=(0021)http://www.garmin.com -->", 0);
  sub_10031030((int)&a2[151 * (*a2 + 1)], (int)"TestResults");
  sub_10030EC0((int)&a2[151 * (*a2 + 1)], (int)"xmlns", (unsigned __int8 *)"http://www.garmin.com/GATE");
  v8 = sub_10024890("CFG_OutputTestRevision", (int)"False");
  if ( !sub_10022AF0(v8, (int)"True") )
  {
    v9 = strstr(v3, "$Id: ");
    if ( v9 )
      v10 = (unsigned __int8 *)(v9 + 5);
    else
      v10 = (unsigned __int8 *)v3;
    sub_10031100((int)&a2[151 * (*a2 + 1)], (int)"Version", v10);
    sub_10031100((int)&a2[151 * (*a2 + 1)], (int)"ResultVersion", (unsigned __int8 *)"$Id$");
  }
  sub_10031030((int)&a2[151 * (*a2 + 1)], (int)"Config");
  sub_10031030((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
  sub_10031100((int)&a2[151 * (*a2 + 1)], (int)"Name", (unsigned __int8 *)"CFG_TestFile");
  v11 = (unsigned __int8 *)sub_1000B270(v3);
  sub_10031100((int)&a2[151 * (*a2 + 1)], (int)"Value", v11);
  sub_10030FB0((int)&a2[151 * (*a2 + 1)]);
  for ( i = 0; sub_10024850(i, &v15, &v16); ++i )
  {
    sub_10031030((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
    sub_10031100((int)&a2[151 * (*a2 + 1)], (int)"Name", v15);
    sub_10031100((int)&a2[151 * (*a2 + 1)], (int)"Value", v16);
    sub_10030FB0((int)&a2[151 * (*a2 + 1)]);
  }
  sub_10030FB0((int)&a2[151 * (*a2 + 1)]);
  sub_10031030((int)&a2[151 * (*a2 + 1)], (int)"TestProcedure");
  sub_10030EC0((int)&a2[151 * (*a2 + 1)], (int)"name", (unsigned __int8 *)a3);
  result = 0;
  v14 = (int)&a2[4 * *a2 + 1];
  *(_DWORD *)v14 = 0;
  *(_DWORD *)(v14 + 4) = 0;
  *(_DWORD *)(v14 + 8) = 0;
  *(_DWORD *)(v14 + 12) = 0;
  return result;
}
// 1002E1F0: using guessed type char var_103[253];

//----- (1002E570) --------------------------------------------------------
char __cdecl sub_1002E570(int a1, const void **a2, unsigned int a3)
{
  int v3; // ebp@1
  int v4; // eax@1
  char *v5; // ebp@1
  const char *v6; // ebx@3
  int v7; // esi@4
  int v8; // ST14_4@5
  int v9; // eax@12
  const char *v10; // eax@13
  const char *v11; // eax@15
  int v12; // ST14_4@17
  int v13; // ecx@29
  const void *v14; // ST24_4@43
  int v15; // ST04_4@44
  _BYTE *v16; // eax@87
  _BYTE *v17; // eax@94
  _BYTE *v18; // eax@100
  int v19; // ST20_4@104
  unsigned int v20; // esi@105
  _DWORD *v21; // edx@106
  unsigned int v22; // eax@106
  const char *v23; // ecx@106
  int v24; // esi@110
  int v25; // eax@111
  _BYTE *v26; // ecx@111
  _BYTE *v27; // edx@111
  int v28; // eax@113
  _BYTE *v29; // ecx@113
  _BYTE *v30; // edx@113
  _BYTE *v31; // ecx@115
  _BYTE *v32; // edx@115
  bool v33; // zf@117
  bool v34; // sf@117
  signed int v35; // eax@117
  const char *v36; // eax@129
  const char *v37; // eax@131
  const char *v39; // [sp-10h] [bp-124h]@73
  unsigned __int8 *v40; // [sp-Ch] [bp-120h]@73
  char v41; // [sp+9h] [bp-10Bh]@46
  char v42; // [sp+Ah] [bp-10Ah]@46
  char v43; // [sp+Bh] [bp-109h]@46
  const char *v44; // [sp+Ch] [bp-108h]@91
  signed int v45; // [sp+Ch] [bp-108h]@105
  char v46[255]; // [sp+10h] [bp-104h]@5
  char v47; // [sp+10Fh] [bp-5h]@44

  v3 = sub_10022A40();
  LOBYTE(v4) = a1;
  v5 = (char *)&unk_10229F38 + 1812 * v3;
  switch ( a1 )
  {
    case 3:
      if ( sub_1000ACB0(a2, a3) )
      {
        v6 = (const char *)a2[3];
        do
        {
          v4 = sub_1002E050(", \t", (int)v6);
          v7 = v4;
          if ( v4 )
          {
            strncpy(v46, v6, v4);
            v8 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
            v46[v7] = 0;
            sub_10031030(v8, (int)"Req");
            sub_10030EC0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"id", (unsigned __int8 *)v46);
            LOBYTE(v4) = (unsigned int)sub_10030FB0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
            v6 += v7;
          }
          else
          {
            ++v6;
          }
        }
        while ( *v6 );
      }
      else if ( sub_1000AC80(a2, a3) )
      {
        if ( sub_1000B410((int)v5, 3, 1, 0) )
          sub_10030FB0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        v9 = *((_DWORD *)v5 + 146);
        if ( v9 > 0 )
        {
          *((_DWORD *)v5 + 146) = v9 - 1;
          sub_10031030((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
          v10 = "true";
          if ( *((_DWORD *)v5 + 144) <= 0 )
            v10 = "false";
          sub_10030EC0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v10);
          v11 = "true";
          if ( *((_DWORD *)v5 + 145) <= 0 )
            v11 = "false";
          sub_10030EC0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v11);
          sub_10030FB0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          v12 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          *((_DWORD *)v5 + 144) = 0;
          *((_DWORD *)v5 + 145) = 0;
          sub_10030FB0(v12);
          sub_10031030((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        }
        LOBYTE(v4) = (unsigned int)sub_10030EC0(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"title",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_1000ABC0(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_10031100(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"Method",
                                     (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 146);
      }
      else if ( sub_1000ACE0(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_10031100(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"TestType",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_1000AC50(a2, a3) )
      {
        if ( sub_1000B410((int)v5, 3, 1, 0) )
          sub_10030FB0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_1000B380((int)a2, a3, (int)v5);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = sub_10031030((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      }
      else if ( sub_1000ABF0(a2, a3) )
      {
        sub_10031030((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Results");
        v13 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        if ( *(_BYTE *)a2[3] == 48 )
        {
          sub_10030EC0(v13, (int)"success", (unsigned __int8 *)"0");
          sub_10030EC0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"error_msg", (unsigned __int8 *)a2[3] + 1);
        }
        else
        {
          sub_10030EC0(v13, (int)"success", (unsigned __int8 *)"1");
        }
        if ( v5[309] )
        {
          sub_10030EC0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
          sub_10030EC0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
        }
        sub_10030FB0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_1000B410((int)v5, 3, 0, 0);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = (unsigned int)sub_10030FB0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      else
      {
        LOBYTE(v4) = sub_1000AB90(a2, a3);
        if ( (_BYTE)v4 )
        {
          if ( !sub_1000B4C0((int)v5) )
            sub_10031030((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
          sub_10031100((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
          LOBYTE(v4) = sub_1000B410((int)v5, 3, 0, 1);
          if ( (_BYTE)v4 )
            LOBYTE(v4) = (unsigned int)sub_10030FB0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      return v4;
    case 4:
      LOBYTE(v4) = sub_1000AF40((int)v5, (int)*a2);
      if ( (_BYTE)v4 )
        LOBYTE(v4) = sub_1002E1F0((char *)a2[1], v5, (int)*a2);
      return v4;
    case 5:
      v14 = *a2;
      LOBYTE(v4) = sub_1000AF30((int)v5);
      if ( !(_BYTE)v4 )
      {
        sub_10031030((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        _snprintf(v46, 0x100u, "Test Group: %s", *a2);
        v15 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        v47 = 0;
        sub_10031100(v15, (int)"Method", (unsigned __int8 *)v46);
        LOBYTE(v4) = (unsigned int)sub_10030FB0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      return v4;
    case 6:
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      LOBYTE(v4) = sub_10031030((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
      return v4;
    case 7:
      v41 = 0;
      v42 = 0;
      v43 = 0;
      if ( a3 <= 6 )
        goto LABEL_56;
      if ( !memcmp(a2[6], "bool", 5u) || !memcmp(a2[6], "char", 5u) || !memcmp(a2[6], "string", 7u) )
      {
        v42 = 1;
        goto LABEL_56;
      }
      if ( !memcmp(a2[6], "bitmap", 7u) || !memcmp(a2[6], "bitmap-lenient", 0xFu) )
        goto LABEL_55;
      if ( !memcmp(a2[6], "bitmap-strict", 0xEu) )
      {
        v43 = 1;
LABEL_55:
        v41 = 1;
      }
LABEL_56:
      if ( !*((_DWORD *)v5 + 146) )
      {
        sub_10031100(
          (int)&v5[604 * (*(_DWORD *)v5 + 1)],
          (int)"Method",
          (unsigned __int8 *)"Method Placeholder -- Add UTF_grp to test case");
        sub_10031100((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestType", (unsigned __int8 *)"Low Level Testing");
        ++*((_DWORD *)v5 + 146);
      }
      if ( !sub_1000B4C0((int)v5) )
        sub_10031030((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      if ( sub_1000AB30((int)a2, a3) )
      {
        if ( *(_BYTE *)a2[3] )
        {
          sub_10031030((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction");
          sub_10030F60((int)&v5[604 * (*(_DWORD *)v5 + 1)], (unsigned __int8 *)a2[3]);
          sub_10030FB0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
        ++*((_DWORD *)v5 + 145);
      }
      else
      {
        if ( *(_BYTE *)a2[3] )
          sub_10031100((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 144);
      }
      sub_10031030((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Compare");
      if ( sub_1000A930((int)a2, a3) )
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 4];
        sub_10030EC0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Fail");
      }
      else
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 8];
        sub_10030EC0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Pass");
      }
      sub_10030EC0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"type", (unsigned __int8 *)*a2);
      sub_10030EC0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"class", (unsigned __int8 *)a2[5]);
      if ( a3 <= 6 )
        goto LABEL_77;
      if ( v41 )
      {
        sub_10030EC0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"datatype", (unsigned __int8 *)"bitmap");
        if ( !v43 )
        {
          sub_10030EC0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"strict", (unsigned __int8 *)"false");
          goto LABEL_77;
        }
        v40 = (unsigned __int8 *)"true";
        v39 = "strict";
      }
      else
      {
        v40 = (unsigned __int8 *)a2[6];
        v39 = "datatype";
      }
      sub_10030EC0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)v39, v40);
LABEL_77:
      if ( v5[309] )
      {
        sub_10030EC0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
        sub_10030EC0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
      }
      if ( a3 > 7 )
      {
        sub_10031030((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Actual");
        if ( v42 )
          sub_10030F10((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        else
          sub_10030EC0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        sub_10030FB0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      if ( a3 > 8 )
      {
        if ( v42 )
        {
          sub_10031030((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Expected");
          sub_10030F10((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)a2[8]);
          sub_10030FB0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          if ( a3 > 9 )
          {
            v16 = a2[9];
            if ( v16 )
            {
              if ( *v16 )
              {
                sub_10031030((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Tolerance");
                sub_10030F10((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"tolerance", (unsigned __int8 *)a2[9]);
                sub_10030FB0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
              }
            }
          }
        }
        else
        {
          if ( v41 )
          {
            v44 = "!";
            if ( memcmp(*a2, "NE", 3u) )
              v44 = (const char *)&unk_1005C3FD;
            if ( a3 > 9 && (v17 = a2[9]) != 0 && *v17 && memcmp(a2[9], "0", 2u) )
              _snprintf(v46, 0x100u, "%s%s+/-%s", v44, a2[8], a2[9]);
            else
              _snprintf(v46, 0x100u, "%s%s", v44, a2[8]);
          }
          else if ( a3 > 9 && (v18 = a2[9]) != 0 && *v18 )
          {
            _snprintf(v46, 0x100u, "N EQ %s(+/-)%s", a2[8], a2[9]);
          }
          else
          {
            _snprintf(v46, 0x100u, "N %s %s", *a2, a2[8]);
          }
          v19 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          v47 = 0;
          sub_10031030(v19, (int)"Expected");
          sub_10030EC0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)v46);
          sub_10030FB0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      v20 = 10;
      v45 = 10;
      if ( a3 <= 0xA )
        goto LABEL_125;
      break;
    case 8:
      if ( sub_1000B410((int)v5, 8, 1, 0) )
        sub_10030FB0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      sub_10031030((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
      v36 = "true";
      if ( *((_DWORD *)v5 + 144) <= 0 )
        v36 = "false";
      sub_10030EC0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v36);
      v37 = "true";
      if ( *((_DWORD *)v5 + 145) <= 0 )
        v37 = "false";
      sub_10030EC0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v37);
      sub_10030FB0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      LOBYTE(v4) = (unsigned int)sub_10030FB0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      return v4;
    case 9:
      LOBYTE(v4) = sub_1000B1A0((int)v5);
      return v4;
    case 10:
      LOBYTE(v4) = sub_1000B200((int)v5, (void (__cdecl *)(int))sub_1002E0D0);
      return v4;
    case 0:
    case 11:
      sub_1000B5A0((int)v5, (void (__cdecl *)(int))sub_1002E0D0);
      goto LABEL_139;
    case 1:
      sub_1000B0C0((int)v5);
      goto LABEL_139;
    case 12:
      sub_1000B4D0((int)v5, (void (__cdecl *)(int))sub_1002E0D0);
LABEL_139:
      LOBYTE(v4) = 0;
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      return v4;
    default:
      return v4;
  }
  do
  {
    v21 = a2[v20];
    v22 = 6;
    v23 = "Info: ";
    do
    {
      if ( *v21 != *(_DWORD *)v23 )
        goto LABEL_110;
      v22 -= 4;
      v23 += 4;
      ++v21;
    }
    while ( v22 >= 4 );
    if ( !v22 )
      goto LABEL_120;
LABEL_110:
    v24 = *(_BYTE *)v21 - *v23;
    if ( *(_BYTE *)v21 == *v23 )
    {
      v25 = v22 - 1;
      v26 = v23 + 1;
      v27 = (char *)v21 + 1;
      if ( !v25
        || (v24 = *v27 - *v26, *v27 == *v26)
        && ((v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, !v28)
         || (v24 = *v30 - *v29, *v30 == *v29)
         && ((v31 = v29 + 1, v32 = v30 + 1, v28 == 1) || (v24 = *v32 - *v31, *v32 == *v31))) )
      {
        v20 = v45;
LABEL_120:
        v35 = 0;
        goto LABEL_121;
      }
    }
    v33 = v24 == 0;
    v34 = v24 < 0;
    v20 = v45;
    v35 = 1;
    if ( v34 || v33 )
      v35 = -1;
LABEL_121:
    if ( v35 )
    {
      sub_10031030((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"PostAnalysis");
      sub_10030EC0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"note", (unsigned __int8 *)a2[v20]);
      sub_10030FB0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    else
    {
      sub_10031030((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"CompareInfo");
      sub_10030EC0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"comp_info", (unsigned __int8 *)a2[v20] + 6);
      sub_10030FB0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    v45 = ++v20;
  }
  while ( v20 < a3 );
LABEL_125:
  sub_10030FB0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  LOBYTE(v4) = sub_1000B410((int)v5, 7, 0, 1);
  if ( (_BYTE)v4 )
    LOBYTE(v4) = (unsigned int)sub_10030FB0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  return v4;
}
// 1002E0D0: using guessed type int sub_1002E0D0();
// 1002E570: using guessed type char var_104[255];

//----- (1002F390) --------------------------------------------------------
char **__cdecl sub_1002F390(int a1)
{
  char *v1; // esi@1
  int v2; // esi@1
  signed int v3; // edi@1

  v1 = (char *)&unk_10229F38 + 1812 * sub_10022A40();
  *((_DWORD *)v1 + 146) = 0;
  sub_1000B310((int)v1, a1, (int)".xml");
  v2 = (int)(v1 + 604);
  v3 = 2;
  do
  {
    sub_10030C60(v2, (int)sub_1002E000, 0);
    v2 += 604;
    --v3;
  }
  while ( v3 );
  return &off_100A9E68;
}
// 100A9E68: using guessed type char *off_100A9E68;

//----- (1002F400) --------------------------------------------------------
int __cdecl sub_1002F400(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10019B30(&a1, 1u, (int)&unk_100AD238, 8, 53, 67);
  if ( v1 == 67 )
    result = 0;
  else
    result = (int)*(&off_100AD23C + 2 * v1);
  return result;
}
// 100AD23C: using guessed type void *off_100AD23C;

//----- (1002F440) --------------------------------------------------------
int __cdecl sub_1002F440(int a1)
{
  return (*(int (**)(void))(a1 + 4))();
}

//----- (1002F450) --------------------------------------------------------
int __cdecl sub_1002F450(unsigned __int8 *a1)
{
  return sub_10019080(a1, 0, 0, 0, 0);
}

//----- (1002F470) --------------------------------------------------------
unsigned int __cdecl sub_1002F470(void *a1)
{
  return sub_10019020(a1, 0xCu, 0);
}

//----- (1002F490) --------------------------------------------------------
unsigned int __cdecl sub_1002F490(void *a1)
{
  return sub_10019020(a1, 0x20u, 0);
}

//----- (1002F4B0) --------------------------------------------------------
unsigned int __cdecl sub_1002F4B0(void *a1)
{
  return sub_10019020(a1, 0x1Cu, 0);
}

//----- (1002F4D0) --------------------------------------------------------
unsigned int __cdecl sub_1002F4D0(void *a1)
{
  return sub_10019020(a1, 0x10u, 0);
}

//----- (1002F4F0) --------------------------------------------------------
unsigned int __cdecl sub_1002F4F0(void *a1)
{
  return sub_10019020(a1, 8u, 0);
}

//----- (1002F510) --------------------------------------------------------
int __cdecl sub_1002F510(int a1)
{
  int result; // eax@1

  result = sub_10019080((unsigned __int8 *)(a1 + 1), 1u, 0x1Fu, 1u, 0);
  if ( !result )
  {
    result = sub_10019080((unsigned __int8 *)a1, 1u, 0xCu, 1u, 0);
    if ( !result )
      result = sub_100190D0((_BYTE *)(a1 + 2), 0x7C6u, 0xFFFFu, 1990, 0);
  }
  return result;
}

//----- (1002F560) --------------------------------------------------------
signed int __cdecl sub_1002F560(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10018F60(a1, 2147483648, 0x7FFFFFFF, 0x7FFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (1002F590) --------------------------------------------------------
int __cdecl sub_1002F590(void *a1)
{
  int result; // eax@1

  result = sub_1002F490((char *)a1 + 64);
  if ( !result )
  {
    result = sub_1002F490((char *)a1 + 128);
    if ( !result )
    {
      result = sub_1002F4F0((char *)a1 + 120);
      if ( !result )
      {
        result = sub_1002F4B0((char *)a1 + 36);
        if ( !result )
        {
          result = sub_1002F510((int)a1 + 168);
          if ( !result )
          {
            result = sub_1002F510((int)a1 + 160);
            if ( !result )
            {
              result = sub_1002F510((int)a1 + 164);
              if ( !result )
              {
                result = sub_1002F4D0(a1);
                if ( !result )
                {
                  result = sub_1002F470((char *)a1 + 96);
                  if ( !result )
                  {
                    result = sub_1002F470((char *)a1 + 24);
                    if ( !result )
                      result = sub_1002F4F0((char *)a1 + 16);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (1002F660) --------------------------------------------------------
unsigned int __cdecl sub_1002F660(void *a1)
{
  unsigned int result; // eax@1

  result = sub_1002F490((char *)a1 + 64);
  if ( !result )
  {
    result = sub_1002F4B0((char *)a1 + 36);
    if ( !result )
    {
      result = sub_1002F4D0(a1);
      if ( !result )
      {
        result = sub_1002F470((char *)a1 + 96);
        if ( !result )
        {
          result = sub_1002F470((char *)a1 + 24);
          if ( !result )
            result = sub_1002F4F0((char *)a1 + 16);
        }
      }
    }
  }
  return result;
}

//----- (1002F6C0) --------------------------------------------------------
int __cdecl sub_1002F6C0(unsigned __int8 *a1)
{
  return sub_10019080(a1, 0, 0x7Fu, 0, 0);
}

//----- (1002F6E0) --------------------------------------------------------
int __cdecl sub_1002F6E0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10019080(a1, 0, 0x7Fu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002F710) --------------------------------------------------------
int __cdecl sub_1002F710(unsigned __int8 *a1)
{
  return sub_10019080(a1, 0, 3u, 0, 0);
}

//----- (1002F730) --------------------------------------------------------
int __cdecl sub_1002F730(char a1, float a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  unsigned int v6; // esi@7
  int result; // eax@7
  double v8; // st6@11
  unsigned int v9; // ecx@14
  unsigned int v10; // edi@14
  char *v11; // edx@14
  signed int v12; // ebx@14
  int v13; // edx@56
  int v14; // edi@56
  char *v15; // ecx@56
  signed int v16; // ebp@56
  int v17; // ebp@63
  unsigned int v18; // ecx@63
  double v19; // st7@63
  signed int v20; // edi@64
  char *v21; // edx@64
  float *v22; // edx@81
  char v23; // [sp+Fh] [bp-4D9h]@7
  int v24; // [sp+18h] [bp-4D0h]@7
  float v25; // [sp+1Ch] [bp-4CCh]@61
  float v26; // [sp+20h] [bp-4C8h]@7
  float v27; // [sp+24h] [bp-4C4h]@11
  float v28[4]; // [sp+28h] [bp-4C0h]@11
  char v29; // [sp+38h] [bp-4B0h]@64
  float v30; // [sp+278h] [bp-270h]@7
  float v31; // [sp+27Ch] [bp-26Ch]@10
  float v32; // [sp+280h] [bp-268h]@9
  char v33; // [sp+284h] [bp-264h]@14
  char v34; // [sp+4C4h] [bp-24h]@56

  v5 = 0;
  if ( a3 )
    *(float *)a3 = 0.0;
  if ( a4 )
    *(float *)a4 = 0.0;
  if ( a5 )
    *(float *)a5 = 0.0;
  *(float *)&v24 = 9.8999998e24;
  v23 = 0;
  v6 = 0;
  memset(&v26, 0, 0x258u);
  result = sub_10032AE0(42065, (int)&v30, 624);
  if ( !a1 )
  {
    if ( v30 == 0.0 )
    {
      v8 = 9.8999998e24;
    }
    else if ( v32 == 9.8999998e24 || v31 == 9.8999998e24 )
    {
      v8 = 9.8999998e24;
    }
    else
    {
      v6 = 1;
      v26 = v30;
      v28[0] = v32;
      v8 = 9.8999998e24;
      v27 = v31;
    }
    v9 = 12 * v6;
    v10 = 0;
    v11 = &v33;
    v12 = 6;
    do
    {
      if ( 0.0 != *(float *)v11
        && *(float *)((char *)&v26 + v10) < (double)*(float *)v11
        && v8 != *((float *)v11 + 2)
        && v8 != *((float *)v11 + 1) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *(float *)v11;
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 2);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 1);
      }
      if ( 0.0 != *((float *)v11 + 3)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 3)
        && v8 != *((float *)v11 + 5)
        && v8 != *((float *)v11 + 4) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 3);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 5);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 4);
      }
      if ( 0.0 != *((float *)v11 + 6)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 6)
        && v8 != *((float *)v11 + 8)
        && v8 != *((float *)v11 + 7) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 6);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 8);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 7);
      }
      if ( 0.0 != *((float *)v11 + 9)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 9)
        && v8 != *((float *)v11 + 11)
        && v8 != *((float *)v11 + 10) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 9);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 11);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 10);
      }
      if ( 0.0 != *((float *)v11 + 12)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 12)
        && v8 != *((float *)v11 + 14)
        && v8 != *((float *)v11 + 13) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 12);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 14);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 13);
      }
      if ( 0.0 != *((float *)v11 + 15)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 15)
        && v8 != *((float *)v11 + 17)
        && v8 != *((float *)v11 + 16) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 15);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 17);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 16);
      }
      if ( 0.0 != *((float *)v11 + 18)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 18)
        && v8 != *((float *)v11 + 20)
        && v8 != *((float *)v11 + 19) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 18);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 20);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 19);
      }
      if ( 0.0 != *((float *)v11 + 21)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 21)
        && v8 != *((float *)v11 + 23)
        && v8 != *((float *)v11 + 22) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 21);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 23);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 22);
      }
      v11 += 96;
      --v12;
    }
    while ( v12 );
    v13 = 12 * v6;
    v14 = 12 * v5;
    v15 = &v34;
    v16 = 1;
    do
    {
      if ( 0.0 != *(float *)v15
        && *(float *)((char *)&v26 + v14) < (double)*(float *)v15
        && v8 != *((float *)v15 + 2)
        && v8 != *((float *)v15 + 1) )
      {
        v14 = v13;
        *(float *)((char *)&v26 + v13) = *(float *)v15;
        ++v6;
        v13 += 12;
        *(float *)((char *)&v25 + v13) = *((float *)v15 + 2);
        *(int *)((char *)&v24 + v13) = *((int *)v15 + 1);
      }
      v15 += 12;
      --v16;
    }
    while ( v16 );
    v17 = 0;
    v18 = 0;
    v19 = a2;
    if ( (signed int)v6 < 4 )
    {
LABEL_80:
      if ( v18 < v6 )
      {
        v22 = &v26 + 3 * v18;
        do
        {
          if ( v23 )
            break;
          if ( v19 == *v22 )
          {
            v23 = 1;
            v17 = v18;
          }
          else
          {
            v25 = *v22 - v19;
            if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
            {
              v17 = v18;
              v24 = LODWORD(v25) & 0x7FFFFFFF;
            }
          }
          ++v18;
          v22 += 3;
        }
        while ( v18 < v6 );
      }
    }
    else
    {
      v20 = 3;
      v21 = &v29;
      while ( !v23 )
      {
        if ( v19 == *((float *)v21 - 6) )
        {
          v17 = v18;
          break;
        }
        v25 = *((float *)v21 - 6) - v19;
        if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
        {
          v17 = v18;
          v24 = LODWORD(v25) & 0x7FFFFFFF;
        }
        if ( v19 == *((float *)v21 - 3) )
        {
          v17 = v18 + 1;
          break;
        }
        v25 = *((float *)v21 - 3) - v19;
        if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
        {
          v17 = v20 - 2;
          v24 = LODWORD(v25) & 0x7FFFFFFF;
        }
        if ( v19 == *(float *)v21 )
        {
          v17 = v18 + 2;
          break;
        }
        v25 = *(float *)v21 - v19;
        if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
        {
          v17 = v20 - 1;
          v24 = LODWORD(v25) & 0x7FFFFFFF;
        }
        if ( v19 == *((float *)v21 + 3) )
        {
          v23 = 1;
          v17 = v20;
        }
        else
        {
          v25 = *((float *)v21 + 3) - v19;
          if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
          {
            v17 = v20;
            v24 = LODWORD(v25) & 0x7FFFFFFF;
          }
        }
        v18 += 4;
        v21 += 48;
        v20 += 4;
        if ( v18 >= v6 - 3 )
          goto LABEL_80;
      }
    }
    if ( a3 )
      *(float *)a3 = sub_100311A0(*(&v26 + 3 * v17));
    if ( a4 )
      *(float *)a4 = v28[3 * v17] * 0.02539999969303608;
    result = a5;
    if ( a5 )
      *(float *)a5 = 0.02539999969303608 * *(&v27 + 3 * v17);
  }
  return result;
}
// 1002F730: using guessed type float var_4C0[4];

//----- (1002FD80) --------------------------------------------------------
double sub_1002FD80()
{
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v1 = 0.0;
  v2 = 0.0;
  sub_10032DC0(3875, &v1, 4, &v2);
  return v1;
}

//----- (1002FDB0) --------------------------------------------------------
double __cdecl sub_1002FDB0(int a1, float a2, float a3)
{
  int v3; // ecx@0
  double result; // st7@2

  if ( sub_1000BAD0(v3) == 24 )
  {
    *(float *)a1 = a2 * 453.5924;
    result = a2;
  }
  else
  {
    *(float *)a1 = a3 * 1000.0;
    result = a3;
  }
  return result;
}

//----- (1002FDF0) --------------------------------------------------------
char __cdecl sub_1002FDF0(float *a1, float *a2, float *a3, char a4)
{
  float *v4; // ecx@10
  signed int v5; // edx@10
  double v6; // st7@29
  double v7; // st7@34
  double v8; // st7@37
  double v9; // st6@37
  double v10; // st5@43
  double v11; // rtt@48
  double v12; // st5@48
  double v13; // st7@48
  char result; // al@48
  char v15; // [sp+22h] [bp-3EEh]@1
  char v16; // [sp+23h] [bp-3EDh]@1
  float v17; // [sp+24h] [bp-3ECh]@1
  float v18; // [sp+28h] [bp-3E8h]@1
  float v19; // [sp+2Ch] [bp-3E4h]@1
  float v20; // [sp+30h] [bp-3E0h]@1
  float v21; // [sp+34h] [bp-3DCh]@1
  float v22; // [sp+38h] [bp-3D8h]@1
  int v23; // [sp+3Ch] [bp-3D4h]@1
  int v24; // [sp+40h] [bp-3D0h]@1
  float v25; // [sp+44h] [bp-3CCh]@29
  int v26; // [sp+48h] [bp-3C8h]@10
  char v27; // [sp+4Ch] [bp-3C4h]@10
  char v28; // [sp+68h] [bp-3A8h]@10
  char v29; // [sp+6Ch] [bp-3A4h]@10
  char v30; // [sp+8Ch] [bp-384h]@10
  char v31; // [sp+ACh] [bp-364h]@10
  char v32; // [sp+CCh] [bp-344h]@10
  char v33; // [sp+ECh] [bp-324h]@10
  char v34; // [sp+10Ch] [bp-304h]@10
  char v35; // [sp+12Ch] [bp-2E4h]@10
  char v36; // [sp+14Ch] [bp-2C4h]@10
  char v37; // [sp+16Ch] [bp-2A4h]@10
  char v38; // [sp+18Ch] [bp-284h]@10
  char v39; // [sp+1ACh] [bp-264h]@10
  char v40; // [sp+1CCh] [bp-244h]@10
  char v41; // [sp+1ECh] [bp-224h]@10
  char v42; // [sp+20Ch] [bp-204h]@10
  char v43; // [sp+22Ch] [bp-1E4h]@10
  char v44; // [sp+24Ch] [bp-1C4h]@10
  char v45; // [sp+26Ch] [bp-1A4h]@10
  char v46; // [sp+28Ch] [bp-184h]@10
  char v47; // [sp+2ACh] [bp-164h]@10
  char v48; // [sp+2CCh] [bp-144h]@10
  char v49; // [sp+2ECh] [bp-124h]@10
  char v50; // [sp+30Ch] [bp-104h]@10
  char v51; // [sp+32Ch] [bp-E4h]@10
  char v52; // [sp+34Ch] [bp-C4h]@10
  char v53; // [sp+36Ch] [bp-A4h]@10
  char v54; // [sp+38Ch] [bp-84h]@10
  char v55; // [sp+3ACh] [bp-64h]@10
  char v56; // [sp+3CCh] [bp-44h]@10
  char v57; // [sp+3ECh] [bp-24h]@10

  v20 = 0.0;
  *(float *)&v24 = 0.0;
  *(float *)&v23 = 0.0;
  v21 = 0.0;
  v18 = 0.0;
  v19 = 0.0;
  v22 = 0.0;
  v16 = 0;
  v17 = 0.0;
  v15 = 0;
  if ( a1 && 9.8999998e24 != *a1 )
    *a1 = 0.0;
  if ( a3 && 9.8999998e24 != *a3 )
    *a3 = 0.0;
  if ( a2 && 9.8999998e24 != *a2 )
    *a2 = 0.0;
  sub_1002FDB0((int)&v26, 5.0, 2.0);
  sub_10032AE0(41113, (int)&v15, 1);
  sub_10032AE0(9149, (int)&v16, 1);
  sub_10032AE0(42004, (int)&v27, 32);
  sub_10032AE0(42006, (int)&v29, 32);
  sub_10032AE0(42008, (int)&v30, 32);
  sub_10032AE0(42010, (int)&v31, 32);
  sub_10032AE0(42012, (int)&v32, 32);
  sub_10032AE0(42014, (int)&v33, 32);
  sub_10032AE0(42016, (int)&v34, 32);
  sub_10032AE0(42018, (int)&v35, 32);
  sub_10032AE0(42020, (int)&v36, 32);
  sub_10032AE0(42022, (int)&v37, 32);
  sub_10032AE0(42024, (int)&v38, 32);
  sub_10032AE0(42026, (int)&v39, 32);
  sub_10032AE0(42028, (int)&v40, 32);
  sub_10032AE0(42030, (int)&v41, 32);
  sub_10032AE0(42032, (int)&v42, 32);
  sub_10032AE0(42034, (int)&v43, 32);
  sub_10032AE0(42036, (int)&v44, 32);
  sub_10032AE0(42038, (int)&v45, 32);
  sub_10032AE0(42040, (int)&v46, 32);
  sub_10032AE0(42042, (int)&v47, 32);
  sub_10032AE0(42044, (int)&v48, 32);
  sub_10032AE0(42046, (int)&v49, 32);
  sub_10032AE0(42048, (int)&v50, 32);
  sub_10032AE0(42050, (int)&v51, 32);
  sub_10032AE0(42052, (int)&v52, 32);
  sub_10032AE0(42054, (int)&v53, 32);
  sub_10032AE0(42056, (int)&v54, 32);
  sub_10032AE0(42058, (int)&v55, 32);
  sub_10032AE0(42060, (int)&v56, 32);
  sub_10032AE0(42062, (int)&v57, 32);
  v4 = (float *)&v28;
  v5 = 30;
  do
  {
    if ( *((_BYTE *)v4 - 28) == 1 )
    {
      if ( 9.8999998e24 != *(v4 - 1) )
        v20 = *(v4 - 1) + v20;
      if ( a4 )
      {
        if ( 9.8999998e24 != *v4 )
        {
          v22 = *v4 + v22;
          if ( 9.8999998e24 != *v4 )
          {
            if ( 9.8999998e24 != *(v4 - 3) )
              v19 = *v4 * *(v4 - 3) + v19;
            if ( 9.8999998e24 != *(v4 - 2) )
              v18 = *v4 * *(v4 - 2) + v18;
          }
        }
      }
      if ( 9.8999998e24 != *(v4 - 1) )
      {
        if ( 9.8999998e24 != *(v4 - 3) )
          v19 = *(v4 - 3) * *(v4 - 1) + v19;
        if ( 9.8999998e24 != *(v4 - 2) )
          v18 = *(v4 - 2) * *(v4 - 1) + v18;
      }
    }
    v4 += 8;
    --v5;
  }
  while ( v5 );
  if ( v16 && a4 == 2 )
  {
    v25 = sub_10018580();
    v21 = sub_100311A0(v25);
    v21 = sub_10035C90(v21, *(float *)&v26);
    sub_1002F730(0, v25, 0, (int)&v24, (int)&v23);
    *(float *)&v24 = *(float *)&v24 * 39.37007904052734;
    *(float *)&v23 = 39.37007904052734 * *(float *)&v23;
    v6 = v21;
    v18 = v21 * *(float *)&v24 + v18;
    v19 = v21 * *(float *)&v23 + v19;
  }
  else
  {
    v6 = v21;
  }
  if ( a4 )
  {
    if ( a4 == 1 )
    {
      v7 = v22 + v20;
    }
    else
    {
      if ( a4 != 2 )
      {
        v8 = 0.0;
        goto LABEL_40;
      }
      v7 = v6 + v20 + v22;
    }
  }
  else
  {
    v7 = v20;
  }
  v17 = v7;
  v8 = 0.0;
  v9 = v17;
  if ( v17 >= 0.0 )
    goto LABEL_41;
  v17 = 0.0;
LABEL_40:
  v9 = v17;
LABEL_41:
  if ( a1 )
    *a1 = v9;
  v10 = 0.02539999969303608;
  if ( a3 )
  {
    if ( v9 > v8 )
      *a3 = v18 / v9 * 0.02539999969303608;
    v10 = 0.02539999969303608;
  }
  if ( a2 )
  {
    v11 = v10;
    v12 = v8;
    v13 = v11;
    result = v15;
    if ( v12 < v9 )
      *a2 = v13 * (v19 / v9);
  }
  else
  {
    result = v15;
  }
  return result;
}

//----- (10030380) --------------------------------------------------------
int __cdecl sub_10030380(char a1, char a2)
{
  int v2; // esi@1
  int result; // eax@4

  v2 = dword_100B04D4[2 * sub_10019B30(&a1, 1u, (int)&unk_100B04D0, 8, 3, 3)];
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = v2 + dword_100B0514[2 * sub_10019B30(&a2, 1u, (int)&unk_100B0510, 8, 6, 6)];
    }
    else if ( a1 == 2 )
    {
      result = v2 + dword_100B0544[2 * sub_10019B30(&a2, 1u, (int)&unk_100B0540, 8, 5, 5)];
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = v2 + dword_100B04EC[2 * sub_10019B30(&a2, 1u, (int)&unk_100B04E8, 8, 5, 5)];
  }
  return result;
}
// 100B04D4: using guessed type int dword_100B04D4[];
// 100B04EC: using guessed type int dword_100B04EC[];
// 100B0514: using guessed type int dword_100B0514[];
// 100B0544: using guessed type int dword_100B0544[];

//----- (10030430) --------------------------------------------------------
bool __usercall sub_10030430@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3)
{
  return a2 == 7 && a3 >= (unsigned __int8)byte_100B7537[44 * a1] - (unsigned __int8)byte_100B7532[44 * a1];
}

//----- (10030460) --------------------------------------------------------
char __usercall sub_10030460@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6)
{
  int v6; // eax@2
  char result; // al@3
  int v8; // eax@4

  if ( sub_10030430(a1, a4, a5) )
  {
    v6 = a3
       + sub_10030380(a1, 6)
       + 36 * (a5 + (unsigned __int8)byte_100B7532[44 * a1] - (unsigned __int8)byte_100B7537[44 * a1]);
    if ( *(_BYTE *)(v6 + 2) == 6 )
    {
      memcpy(a6, (const void *)(v6 + 4), a2);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v8 = sub_10030380(a1, a4);
    memcpy(a6, (const void *)(a3 + v8 + a2 * a5), a2);
    result = 1;
  }
  return result;
}

//----- (10030500) --------------------------------------------------------
char __cdecl sub_10030500(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1002BCA0(a1);
  sub_10032B00(v5, (int)&v7, 3684);
  return sub_10030460(a2, 0x2Cu, (int)&v7, a3, a4, a5);
}

//----- (10030580) --------------------------------------------------------
char __cdecl sub_10030580(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1002BCA0(a1);
  sub_10032B00(v5, (int)&v7, 3684);
  return sub_10030460(a2, 3u, (int)&v7, a3, a4, a5);
}

//----- (10030600) --------------------------------------------------------
char __cdecl sub_10030600(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1002BCA0(a1);
  sub_10032B00(v5, (int)&v7, 3684);
  return sub_10030460(a2, 0x24u, (int)&v7, a3, a4, a5);
}

//----- (10030680) --------------------------------------------------------
char __cdecl sub_10030680(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1002BCA0(a1);
  sub_10032B00(v5, (int)&v7, 3684);
  return sub_10030460(a2, 0xCu, (int)&v7, a3, a4, a5);
}

//----- (10030700) --------------------------------------------------------
char __cdecl sub_10030700(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xC:
    case 0x3F:
      result = 0;
      break;
    case 0xD:
    case 0x40:
      result = 1;
      break;
    case 0xE:
    case 0x41:
      result = 2;
      break;
    case 0x2A:
    case 0x42:
      result = 3;
      break;
    default:
      sub_10011520("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_utl.c", 139, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (100307A0) --------------------------------------------------------
bool __cdecl sub_100307A0(void *a1)
{
  char v1; // cl@1

  v1 = sub_10012260(1, 1946, a1);
  *((_DWORD *)a1 + 1) /= 0x3E8u;
  return v1 && !sub_10027A10((int)a1);
}

//----- (100307E0) --------------------------------------------------------
char __cdecl sub_100307E0(char a1)
{
  return byte_100B2321[2 * (unsigned __int8)sub_10019B30(&a1, 1u, (int)&unk_100B2320, 2, 4, 3)];
}

//----- (10030810) --------------------------------------------------------
char __cdecl sub_10030810(char a1, void *a2)
{
  void *v3; // esi@6
  char v4; // al@6

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v3 = a2;
      v4 = sub_10012260(1, 546, a2);
    }
    else
    {
      if ( a1 != 2 )
      {
        sub_10011520("..\\lib\\acl\\iop\\iop_com_intf.c", 187, 0, 0);
        return 0;
      }
      v3 = a2;
      v4 = sub_100307A0(a2);
    }
  }
  else
  {
    v3 = a2;
    v4 = sub_10012260(1, 538, a2);
  }
  if ( !v4 || sub_10027A10((int)v3) )
    return 0;
  return 1;
}

//----- (10030890) --------------------------------------------------------
int __cdecl sub_10030890(char a1, _DWORD *a2)
{
  int result; // eax@1
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  LOBYTE(result) = sub_10030810(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (100308E0) --------------------------------------------------------
char __cdecl sub_100308E0(char a1)
{
  char result; // al@3

  if ( a1 == 6 )
  {
    result = 0;
  }
  else if ( a1 == 7 )
  {
    result = 1;
  }
  else
  {
    sub_10011520("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 294, 0, 0);
    result = 2;
  }
  return result;
}

//----- (10030920) --------------------------------------------------------
int __cdecl sub_10030920(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10019B30(&a1, 1u, (int)&unk_100B3F40, 8, 67, 0);
  if ( v1 )
  {
    result = dword_100B3F44[2 * v1];
  }
  else
  {
    sub_10011520("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 1932, 0, 0);
    result = 0;
  }
  return result;
}
// 100B3F44: using guessed type int dword_100B3F44[];

//----- (10030970) --------------------------------------------------------
int __cdecl sub_10030970(int a1, int a2)
{
  unsigned int v2; // eax@5
  int v3; // eax@8
  int v4; // eax@10
  int result; // eax@11

  if ( a2 && *(_DWORD *)(a2 + 8) && *(_WORD *)(a2 + 12) && *(_DWORD *)(a2 + 4) )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 < 0xFFFFFFC2 && v2 )
    {
      j_IOP_pvg_sk_close(v2, *(_DWORD *)(a2 + 20));
      *(_DWORD *)(a1 + 4) = 0;
    }
    *(_BYTE *)(*(_WORD *)(a2 + 12) + *(_DWORD *)(a2 + 8) - 1) = 0;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 30) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 28) = 0;
    v3 = j_IOP_pvg_sk_create_id(*(_WORD *)a2);
    *(_DWORD *)(a1 + 4) = v3;
    if ( *(_DWORD *)(a2 + 36) )
      j_IOP_pvg_sk_set_addr(v3, 0, *(_DWORD *)(a2 + 36));
    v4 = *(_DWORD *)(a1 + 4);
    if ( *(_BYTE *)(a2 + 14) & 8 )
      result = j_IOP_pvg_sk_connect(v4, *(_DWORD *)(a2 + 16));
    else
      result = j_IOP_pvg_sk_accept(v4, a1 + 8, *(_DWORD *)(a2 + 16));
  }
  else
  {
    result = -59;
  }
  return result;
}
// 10033A40: using guessed type int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD);
// 10033A50: using guessed type int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD);
// 10033A60: using guessed type int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD);
// 10033A70: using guessed type int __cdecl j_IOP_pvg_sk_create_id(_DWORD);
// 10033B20: using guessed type int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD);

//----- (10030AB0) --------------------------------------------------------
char __usercall sub_10030AB0@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5)
{
  _WORD *v5; // edx@1
  int v6; // esi@1
  char result; // al@1
  char v8; // cl@5
  unsigned __int16 v9; // cx@11
  signed int v10; // edi@12
  signed int v11; // esi@12
  size_t v12; // ebp@13

  v5 = a4;
  v6 = a1;
  result = 0;
  if ( *a4 >= a3 )
  {
    *a4 = 0;
    *(_BYTE *)a2 = 0;
  }
  if ( a5 == -1 )
    *(_BYTE *)(v6 + 28) = 3;
  v8 = *(_BYTE *)(v6 + 28);
  if ( v8 )
  {
    *(_BYTE *)(v6 + 28) = v8 - 1;
    result = 0;
  }
  else if ( a5 != 13 && a5 != 10 && a5 )
  {
    *(_BYTE *)((*a4)++ + a2) = a5;
  }
  else
  {
    v9 = *a4;
    if ( *a4 )
    {
      v10 = v9;
      v11 = 0;
      if ( (signed int)v9 > 0 )
      {
        v12 = v9 - 1;
        do
        {
          if ( *(_BYTE *)(v11 + a2) == 8 )
          {
            if ( v11 )
            {
              memcpy_0((void *)(v11 + a2 - 1), (const void *)(v11 + a2 + 1), v10 - v11 - 1);
              v10 -= 2;
              v12 -= 2;
              v11 -= 2;
            }
            else
            {
              memcpy_0((void *)a2, (const void *)(a2 + 1), v12);
              --v10;
              --v12;
              v11 = -1;
            }
            v5 = a4;
          }
          ++v11;
        }
        while ( v11 < v10 );
      }
      *(_BYTE *)(v10 + a2) = 0;
      result = 1;
      *v5 = 0;
    }
  }
  return result;
}

//----- (10030B80) --------------------------------------------------------
signed int __cdecl sub_10030B80(_DWORD *a1, char *a2)
{
  int v2; // esi@1
  int v3; // ebx@4
  int v4; // ebp@4
  int v5; // eax@5
  signed int v6; // edi@5
  int v7; // ST0C_4@9
  char v8; // al@11
  int v10; // [sp+4h] [bp-38h]@4
  __int16 v11; // [sp+8h] [bp-34h]@9

  v2 = (int)a1;
  if ( a1 && *a1 && a2 )
  {
    *a2 = 0;
    v3 = *(_DWORD *)v2;
    v10 = *(_DWORD *)v2;
    v4 = 0;
    while ( 1 )
    {
      v5 = sub_10033A80(*(_DWORD *)(v2 + 4), (int)&a1, 1, 0, v4);
      v6 = v5;
      if ( v5 == -57 )
      {
        if ( v4 == *(_DWORD *)(v3 + 24) )
          return v6;
        v4 = *(_DWORD *)(v3 + 24);
        v6 = 1;
      }
      else
      {
        if ( v5 >= 0 )
        {
          v8 = sub_10030AB0(v2, *(_DWORD *)(v3 + 8), *(_WORD *)(v3 + 12), (_WORD *)(v2 + 30), (char)a1);
          v3 = v10;
          *a2 = v8;
          *(_DWORD *)(v2 + 24) += v6;
        }
        else
        {
          v7 = *(_DWORD *)(v2 + 4);
          v11 = 0;
          j_IOP_pvg_sk_status(v7, &v11);
          if ( !(v11 & 0x44) )
            sub_10030970(v2, v3);
        }
        if ( v6 <= 0 )
          return v6;
      }
      if ( *a2 )
        return v6;
    }
  }
  return -59;
}
// 10033B30: using guessed type int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD);

//----- (10030C60) --------------------------------------------------------
int __cdecl sub_10030C60(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = a3;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 88) = a2;
  return result;
}

//----- (10030C80) --------------------------------------------------------
int (__cdecl *__usercall sub_10030C80@<eax>(int a1@<eax>, int a2@<ecx>))(int)
{
  int (__cdecl *result)(int); // eax@1

  result = *(int (__cdecl **)(int))(a1 + 88);
  if ( result )
    result = (int (__cdecl *)(int))result(a2);
  return result;
}

//----- (10030C90) --------------------------------------------------------
int __usercall sub_10030C90@<eax>(unsigned __int8 *a1@<eax>, int a2)
{
  signed int v2; // edi@1
  int v3; // ebp@1
  unsigned __int8 *v4; // ebx@1
  unsigned __int8 v5; // al@2
  int v6; // esi@4

  v2 = 0;
  v3 = a2 + 92;
  *(_BYTE *)(a2 + 92) = 0;
  v4 = a1;
  do
  {
    v5 = *v4;
    if ( !*v4 )
      break;
    switch ( v5 )
    {
      case 0x22u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1869967654;
        *(_WORD *)(v6 + 4) = 15220;
        *(_BYTE *)(v6 + 6) = 0;
        break;
      case 0x3Cu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997485606;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x3Eu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997484326;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x26u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1886216486;
        *(_WORD *)(v6 + 4) = 59;
        break;
      case 7u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 24924;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 8u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 25180;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xCu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 26204;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xAu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 28252;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xDu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29276;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 9u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29788;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xBu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 30300;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      default:
        v6 = v2 + v3;
        if ( isprint(v5) )
        {
          *(_BYTE *)v6 = *v4;
          *(_BYTE *)(v2 + a2 + 93) = 0;
        }
        else
        {
          _snprintf((char *)(v2 + v3), 512 - v2, "\\x%x", *v4);
          *(_BYTE *)(a2 + 603) = 0;
        }
        break;
    }
    v2 += strlen((const char *)v6);
    ++v4;
  }
  while ( v2 < 502 );
  return a2 + 92;
}

//----- (10030EC0) --------------------------------------------------------
int (__cdecl *__cdecl sub_10030EC0(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_10030C80(a1, (int)word_1005E650);
  sub_10030C80(a1, a2);
  sub_10030C80(a1, (int)&unk_100B4420);
  v3 = sub_10030C90(a3, a1);
  sub_10030C80(a1, v3);
  return sub_10030C80(a1, (int)&word_10055084);
}
// 10055084: using guessed type __int16 word_10055084;

//----- (10030F10) --------------------------------------------------------
int (__cdecl *__cdecl sub_10030F10(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_10030C80(a1, (int)word_1005E650);
  sub_10030C80(a1, a2);
  sub_10030C80(a1, (int)&unk_100B4428);
  v3 = sub_10030C90(a3, a1);
  sub_10030C80(a1, v3);
  return sub_10030C80(a1, (int)&unk_100B4424);
}

//----- (10030F60) --------------------------------------------------------
int (__cdecl *__cdecl sub_10030F60(int a1, unsigned __int8 *a2))(int)
{
  int (__cdecl *result)(int); // eax@1
  int v3; // eax@4

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      sub_10030C80(a1, (int)&unk_100B442C);
      *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    }
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 7) = 1;
    v3 = sub_10030C90(a2, a1);
    result = sub_10030C80(a1, v3);
  }
  return result;
}

//----- (10030FB0) --------------------------------------------------------
int (__cdecl *__cdecl sub_10030FB0(int a1))(int)
{
  int (__cdecl *result)(int); // eax@1
  void *v2; // ecx@3
  bool v3; // zf@7

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      v2 = &unk_100B4434;
    }
    else
    {
      if ( !*(_BYTE *)(a1 + 8 * (_DWORD)result - 7) )
        sub_10030C80(a1, dword_100B438C[(signed int)result]);
      sub_10030C80(a1, (int)&unk_100B4430);
      sub_10030C80(a1, *(_DWORD *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 4));
      v2 = &unk_100B442C;
    }
    result = sub_10030C80(a1, (int)v2);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    v3 = (*(_DWORD *)(a1 + 80))-- == 1;
    if ( v3 )
      result = sub_10030C80(a1, (int)&word_100A9D0C);
  }
  return result;
}
// 100A9D0C: using guessed type __int16 word_100A9D0C;
// 100B438C: using guessed type int dword_100B438C[];

//----- (10031030) --------------------------------------------------------
int __cdecl sub_10031030(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@4

  v2 = *(_DWORD *)(a1 + 80);
  if ( v2 > 0 && *(_BYTE *)(a1 + 8 * v2 - 8) )
  {
    sub_10030C80(a1, (int)&unk_100B442C);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
  }
  sub_10030C80(a1, (int)(&off_100B4390)[2 * (*(_DWORD *)(a1 + 80) + *(_DWORD *)(a1 + 84))]);
  sub_10030C80(a1, (int)&unk_100B4438);
  sub_10030C80(a1, a2);
  *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80)) = 1;
  result = *(_DWORD *)(a1 + 80);
  *(_BYTE *)(a1 + 8 * result + 1) = 0;
  *(_DWORD *)(a1 + 8 * (*(_DWORD *)(a1 + 80))++ + 4) = a2;
  return result;
}
// 100B4390: using guessed type __int16 *off_100B4390;

//----- (100310B0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100310B0(int a1, unsigned __int8 *a2, char a3))(int)
{
  int v3; // eax@2
  int (__cdecl *result)(int); // eax@2

  if ( a3 )
  {
    v3 = sub_10030C90(a2, a1);
    sub_10030C80(a1, v3);
    result = sub_10030C80(a1, (int)&word_100A9D0C);
  }
  else
  {
    sub_10030C80(a1, (int)a2);
    result = sub_10030C80(a1, (int)&word_100A9D0C);
  }
  return result;
}
// 100A9D0C: using guessed type __int16 word_100A9D0C;

//----- (10031100) --------------------------------------------------------
int (__cdecl *__cdecl sub_10031100(int a1, int a2, unsigned __int8 *a3))(int)
{
  sub_10031030(a1, a2);
  if ( a3 && *a3 )
    sub_10030F60(a1, a3);
  return sub_10030FB0(a1);
}

//----- (10031140) --------------------------------------------------------
int (__cdecl *__cdecl sub_10031140(int a1, int a2, int a3))(int)
{
  char v4; // [sp+8h] [bp-24h]@1
  char v5; // [sp+27h] [bp-5h]@1

  _snprintf(&v4, 0x20u, "%d", a3);
  v5 = 0;
  return sub_10031100(a1, a2, (unsigned __int8 *)&v4);
}

//----- (100311A0) --------------------------------------------------------
double __cdecl sub_100311A0(float a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@2
  double result; // st7@4
  float v5; // [sp+8h] [bp+4h]@4
  float v6; // [sp+8h] [bp+4h]@5
  float v7; // [sp+8h] [bp+4h]@6
  float v8; // [sp+8h] [bp+4h]@7

  v2 = (unsigned __int8)sub_1000B950(v1);
  if ( (_BYTE)v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        v6 = (float)778.90802 * a1;
        result = v6;
      }
      else
      {
        v5 = (float)850.76703 * a1;
        result = v5;
      }
    }
    else
    {
      v7 = (float)804.0722 * a1;
      result = v7;
    }
  }
  else
  {
    v8 = (float)718.95856 * a1;
    result = v8;
  }
  return result;
}

//----- (10031220) --------------------------------------------------------
BOOL __cdecl sub_10031220(unsigned __int8 a1)
{
  return a1 <= 1u;
}

//----- (10031230) --------------------------------------------------------
BOOL __usercall sub_10031230@<eax>(unsigned __int8 a1@<al>, char a2)
{
  _BYTE *v2; // ecx@1

  return (unsigned __int8)sub_10031220(a1) && *v2 < 3u && a2 == 24;
}

//----- (10031260) --------------------------------------------------------
bool __cdecl sub_10031260(char a1, char a2, unsigned __int8 a3, int a4)
{
  bool v4; // bl@1
  unsigned __int8 v5; // cl@2
  int v6; // esi@3
  char v8; // al@16
  char v9; // cl@16
  char v10; // dl@16
  int v11; // ecx@18
  int v12; // edx@18
  int v13; // eax@18
  char v14; // [sp+Bh] [bp-29h]@3
  int v15; // [sp+Ch] [bp-28h]@9
  struct tm Tm; // [sp+10h] [bp-24h]@5

  v4 = 0;
  if ( a3 < 3u )
  {
    if ( (unsigned __int8)sub_10031220(a1) )
    {
      v6 = 10 * v5;
      if ( sub_1002BA30((unsigned __int8)byte_100B8BE8[20 * v5], (bool *)&v14) )
      {
        if ( v14 )
        {
          if ( !sub_10012260(1, (unsigned __int16)word_100B8BE0[v6], &Tm.tm_mon) || sub_100279C0((int)&Tm.tm_mon) )
            return 0;
          v4 = 1;
        }
        else
        {
          if ( !(unsigned __int8)sub_10030890(a1, &v15) || v15 != dword_100B8C00[2 * a3] || a2 == 11 )
            return v4;
          Tm.tm_sec = 0;
          Tm.tm_min = 0;
          Tm.tm_hour = 0;
          LOBYTE(Tm.tm_mday) = 0;
          v4 = sub_10012260(1, (unsigned __int16)word_100B8BE4[v6], &Tm) && !_mkgmtime(&Tm);
          v8 = BYTE1(Tm.tm_hour);
          v9 = BYTE2(Tm.tm_min);
          *((_BYTE *)&Tm.tm_mon + 4 * a3) = Tm.tm_min;
          v10 = BYTE2(Tm.tm_hour);
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 2) = v8;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 1) = v9;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 3) = v10;
          if ( !v4 )
            return v4;
        }
        if ( a2 == 11 )
        {
          v11 = Tm.tm_year;
          v12 = Tm.tm_wday;
          *(_DWORD *)a4 = Tm.tm_mon;
          v13 = Tm.tm_yday;
          *(_DWORD *)(a4 + 4) = v11;
          *(_DWORD *)(a4 + 8) = v12;
          *(_DWORD *)(a4 + 12) = v13;
          return v4;
        }
        *(_DWORD *)a4 = *(&Tm.tm_mon + a3);
      }
    }
  }
  return v4;
}
// 100B8BE0: using guessed type __int16 word_100B8BE0[];
// 100B8BE4: using guessed type __int16 word_100B8BE4[];
// 100B8C00: using guessed type int dword_100B8C00[];

//----- (10031410) --------------------------------------------------------
bool __cdecl sub_10031410(unsigned __int8 a1, int a2)
{
  bool v2; // dl@1
  unsigned __int8 v3; // cl@1
  bool result; // al@2

  if ( (unsigned __int8)sub_10031220(a1) )
    result = sub_10032AE0((unsigned __int16)word_100B8BEA[10 * v3], a2, 32) == 0;
  else
    result = v2;
  return result;
}
// 100B8BEA: using guessed type __int16 word_100B8BEA[];

//----- (10031450) --------------------------------------------------------
bool __cdecl sub_10031450(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6)
{
  unsigned __int8 v6; // dl@1
  bool result; // al@4
  char v8; // [sp+13h] [bp-29h]@5
  unsigned int v9; // [sp+14h] [bp-28h]@1
  char v10; // [sp+18h] [bp-24h]@7
  int v11[7]; // [sp+1Ch] [bp-20h]@8

  LOBYTE(v9) = sub_100307E0(a1);
  if ( !(unsigned __int8)sub_10031230(v9, a3) || a6 != 4 )
    goto LABEL_12;
  if ( !a2 )
    return sub_10031260(v9, a3, *a4, (int)a5);
  if ( sub_1002BA30((unsigned __int8)byte_100B8BE8[20 * v6], (bool *)&v8) && v8 && sub_10031410(v9, (int)&v10) )
  {
    *a5 = v11[*a4];
    result = 1;
  }
  else
  {
LABEL_12:
    result = 0;
  }
  return result;
}
// 10031450: using guessed type int var_20[7];

//----- (10031540) --------------------------------------------------------
int __cdecl sub_10031540(char a1)
{
  return sub_10019B30(&a1, 1u, (int)&unk_100B8C24, 8, 2, 2);
}

//----- (10031560) --------------------------------------------------------
BOOL __cdecl sub_10031560(int a1, void *a2)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-18h]@2
  int v5; // [sp+18h] [bp-4h]@3

  v2 = sub_10030920(a1);
  return sub_10012260(0, 604, a2) && sub_10011C00(0, 0x25Cu, (int)&v4) && (v2 & v5) == v2;
}

//----- (100315C0) --------------------------------------------------------
int __usercall sub_100315C0@<eax>(char a1@<al>)
{
  unsigned __int8 v1; // al@1
  int result; // eax@2

  v1 = sub_10031540(a1);
  if ( v1 >= 2u )
    result = 42066;
  else
    result = dword_100B8C28[2 * v1];
  return result;
}
// 100B8C28: using guessed type int dword_100B8C28[];

//----- (100315F0) --------------------------------------------------------
BOOL __cdecl sub_100315F0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100315C0(a1);
  return sub_10032AE0(v2, a2, 16) == 0;
}

//----- (10031620) --------------------------------------------------------
int __cdecl sub_10031620(int a1, char a2, int a3, int a4, void *a5)
{
  int result; // eax@2

  if ( a2 )
    result = sub_100315F0(a1, (int)a5);
  else
    result = sub_10031560(a1, a5);
  return result;
}

//----- (10031650) --------------------------------------------------------
char __cdecl sub_10031650(void *a1)
{
  int v1; // ecx@0
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  return sub_10012290(1, 1947, a1, (int)&v3);
}

//----- (10031670) --------------------------------------------------------
BOOL __cdecl sub_10031670(int a1)
{
  return sub_10032AE0(6792, a1, 284) == 0;
}

//----- (10031690) --------------------------------------------------------
char __cdecl sub_10031690(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2

  if ( a2 )
    result = sub_10031670((int)a5);
  else
    result = sub_10031650(a5);
  return result;
}

//----- (100316C0) --------------------------------------------------------
bool __cdecl sub_100316C0(char a1, void *a2)
{
  memset(a2, 0, 0x2890u);
  return sub_10032AE0((a1 != 36) + 6534, (int)a2, 10384) == 0;
}

//----- (10031700) --------------------------------------------------------
signed int __usercall sub_10031700@<eax>(char a1@<al>)
{
  return a1 != 36 ? 0x20000 : 0x10000;
}

//----- (10031720) --------------------------------------------------------
bool __cdecl sub_10031720(char a1, void *a2)
{
  int v2; // esi@1
  bool result; // al@5
  void *v4; // ecx@6
  int v5; // [sp+Ch] [bp-28h]@4
  char v6; // [sp+10h] [bp-24h]@2
  int v7; // [sp+24h] [bp-10h]@3
  __int16 v8; // [sp+28h] [bp-Ch]@8
  int v9; // [sp+2Ch] [bp-8h]@8

  v2 = sub_10031700(a1);
  if ( (v2 & j_HWM_pvg_hsdb_get_lrus_online()) == v2
    && sub_10011C00(1, 0x6ACu, (int)&v6)
    && v7 == v2
    && sub_10012290(1, 1708, a2, (int)&v5) )
  {
    result = 1;
  }
  else if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    result = sub_100316C0(a1, a2);
  }
  else
  {
    v9 = sub_100122C0(v4);
    v8 = 1708;
    sub_10011D60(1, 0, &v8, 0, 8, 1);
    sub_10011EA0(1, 0, v2);
    result = 0;
  }
  return result;
}
// 100331B0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 100331E0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10031810) --------------------------------------------------------
bool __cdecl sub_10031810(char a1, char a2, int a3, int a4, void *a5)
{
  bool result; // al@2

  if ( a2 )
    result = sub_100316C0(a1, a5);
  else
    result = sub_10031720(a1, a5);
  return result;
}

//----- (10031840) --------------------------------------------------------
char __cdecl sub_10031840(char a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@3
  char v4; // dl@3

  memset(byte_1022EB38, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10011520("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 215, 0, 0);
  }
  else
  {
    sub_1002BF40(a1, (int)byte_1022EB38);
    v3 = 4 * a2 - 64;
    v4 = byte_1022EB39[v3];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_1022EB38[v3];
    if ( (unsigned __int8)v4 < 0x23u
      || (unsigned __int8)v4 >= 0x64u && (unsigned __int8)v4 <= 0x81u
      || (unsigned __int8)v4 >= 0x96u && (unsigned __int8)v4 <= 0x9Bu )
    {
      return 1;
    }
  }
  return 0;
}

//----- (100318E0) --------------------------------------------------------
bool __cdecl sub_100318E0(char a1, unsigned __int8 a2, int a3)
{
  char *v3; // eax@3
  bool result; // al@3

  memset(byte_1022EB38, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10011520("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 340, 0, 0);
    result = 0;
  }
  else
  {
    sub_1002BF40(a1, (int)byte_1022EB38);
    v3 = (char *)&unk_1022EBD8 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v3;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v3 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v3 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v3 + 3);
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  return result;
}

//----- (10031960) --------------------------------------------------------
char __cdecl sub_10031960(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_1022EB38, 0, 0x890u);
  sub_1002BF40(a1, (int)byte_1022EB38);
  if ( a2 > 0x10u )
  {
    sub_10011520("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 512, 0, 0);
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = dword_1022EEA8[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_1022EEAC[2 * a2];
    result = 1;
  }
  return result;
}
// 1022EEA8: using guessed type int dword_1022EEA8[];
// 1022EEAC: using guessed type int dword_1022EEAC[];

//----- (100319D0) --------------------------------------------------------
char __cdecl sub_100319D0(char a1, void *a2)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = sub_10012260(0, 227, a2);
    }
    else if ( a1 == 2 )
    {
      result = sub_10012260(0, 572, a2);
    }
    else
    {
      sub_10011520("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 991, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_10012260(0, 226, a2);
  }
  return result;
}

//----- (10031A50) --------------------------------------------------------
char __cdecl sub_10031A50(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  int v4; // ecx@3

  memset(byte_1022EB38, 0, 0x890u);
  if ( a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10011520("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 153, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_100319D0(a1, byte_1022EB38);
    v4 = 4 * a2 - 64;
    *(_BYTE *)(a3 + 1) = byte_1022EB39[v4];
    *(_BYTE *)a3 = byte_1022EB38[v4];
  }
  return result;
}

//----- (10031AD0) --------------------------------------------------------
char __cdecl sub_10031AD0(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  char *v4; // ecx@3

  memset(byte_1022EB38, 0, 0x890u);
  if ( a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10011520("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 280, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_100319D0(a1, byte_1022EB38);
    v4 = (char *)&unk_1022EBD8 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v4;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v4 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v4 + 3);
  }
  return result;
}

//----- (10031B50) --------------------------------------------------------
char __cdecl sub_10031B50(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_1022EB38, 0, 0x890u);
  if ( a2 <= 0x10u )
  {
    result = sub_100319D0(a1, byte_1022EB38);
    *(_DWORD *)a3 = dword_1022EEA8[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_1022EEAC[2 * a2];
  }
  else
  {
    sub_10011520("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 445, 0, 0);
    result = 0;
  }
  return result;
}
// 1022EEA8: using guessed type int dword_1022EEA8[];
// 1022EEAC: using guessed type int dword_1022EEAC[];

//----- (10031BC0) --------------------------------------------------------
char __cdecl sub_10031BC0(char a1, char a2, char a3, unsigned __int8 *a4, int a5)
{
  char result; // al@6
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10032A20(a1);
  if ( v6 == 3 )
    return 0;
  if ( a3 == 1 )
  {
    if ( a2 )
      result = sub_10031960(v6, *a4, a5);
    else
      result = sub_10031B50(v6, *a4, a5);
  }
  else if ( a3 == 2 )
  {
    if ( a2 )
      result = sub_10031840(v6, *a4, a5);
    else
      result = sub_10031A50(v6, *a4, a5);
  }
  else
  {
    if ( a3 != 3 )
    {
      sub_10011520("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 915, 0, 0);
      return 0;
    }
    if ( a2 )
      result = sub_100318E0(v6, *a4, a5);
    else
      result = sub_10031AD0(v6, *a4, a5);
  }
  return result;
}

//----- (10031CD0) --------------------------------------------------------
char __cdecl sub_10031CD0(char a1, void *a2)
{
  return sub_10012260(6, (unsigned __int16)word_100B9C62[8 * (unsigned __int8)a1], a2);
}
// 100B9C62: using guessed type __int16 word_100B9C62[];

//----- (10031CF0) --------------------------------------------------------
bool __cdecl sub_10031CF0(unsigned __int8 a1, char *a2)
{
  int v2; // eax@1
  char v4; // [sp+8h] [bp-30h]@1

  v2 = sub_10032AE0(dword_100B9C68[4 * a1], (int)&v4, 48);
  qmemcpy(a2, &v4, 0x2Cu);
  return v2 == 0;
}
// 100B9C68: using guessed type int dword_100B9C68[];

//----- (10031D30) --------------------------------------------------------
char __cdecl sub_10031D30(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10032A60(a1);
  if ( a2 )
    result = sub_10031CF0(v6, (char *)a5);
  else
    result = sub_10031CD0(v6, a5);
  return result;
}

//----- (10031D70) --------------------------------------------------------
BOOL sub_10031D70()
{
  char v1; // [sp+0h] [bp-78h]@1

  return sub_1002B970(69, &v1) && !strncmp(&v1, "006-B0756-", 0xAu);
}

//----- (10031DD0) --------------------------------------------------------
char __cdecl sub_10031DD0(int a1, char *a2)
{
  char result; // al@5
  char v3; // [sp+13h] [bp-7Dh]@1
  char v4; // [sp+14h] [bp-7Ch]@1
  char v5; // [sp+15h] [bp-7Bh]@2
  int v6; // [sp+30h] [bp-60h]@2
  int v7; // [sp+34h] [bp-5Ch]@2
  int v8; // [sp+38h] [bp-58h]@2
  int v9; // [sp+3Ch] [bp-54h]@2
  int v10; // [sp+40h] [bp-50h]@2
  __int16 v11; // [sp+44h] [bp-4Ch]@2
  char v12; // [sp+46h] [bp-4Ah]@2
  char v13; // [sp+47h] [bp-49h]@2
  float v14; // [sp+48h] [bp-48h]@2
  char v15; // [sp+4Ch] [bp-44h]@2
  char v16; // [sp+4Dh] [bp-43h]@2
  char v17; // [sp+4Eh] [bp-42h]@2
  char v18; // [sp+50h] [bp-40h]@1

  memset(&v18, 0, 0x3Cu);
  v3 = sub_10012260(1, 292, &v18);
  qmemcpy(&v4, &v18, 0x3Cu);
  if ( !(unsigned __int8)sub_10031D70() )
  {
    v6 = -1;
    v14 = 77.166664;
    v7 = -1;
    v8 = -1;
    v9 = -1;
    v5 = 1;
    v12 = 0;
    v13 = 1;
    v4 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v10 = 0;
    v11 = 0;
  }
  if ( !v3 || sub_10026F70((int)&v4) )
  {
    result = 0;
  }
  else
  {
    result = 1;
    qmemcpy(a2, &v18, 0x3Cu);
  }
  return result;
}

//----- (10031EC0) --------------------------------------------------------
BOOL __cdecl sub_10031EC0(int a1, int a2)
{
  return sub_10032AE0(6200, a2, 60) == 0;
}

//----- (10031EE0) --------------------------------------------------------
char __cdecl sub_10031EE0(int a1, char a2, int a3, int a4, char *a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10031EC0(a1, (int)a5);
  }
  else
  {
    result = sub_10031DD0(a1, a5);
  }
  return result;
}

//----- (10031F20) --------------------------------------------------------
char __cdecl sub_10031F20(int a1, int a2)
{
  int v2; // ecx@3
  int v3; // edx@3
  int v4; // ecx@3
  char result; // al@3
  int v6; // [sp+4h] [bp-1Ch]@1
  int v7; // [sp+8h] [bp-18h]@1
  int v8; // [sp+Ch] [bp-14h]@1
  int v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+14h] [bp-Ch]@1
  __int16 v11; // [sp+18h] [bp-8h]@1
  char v12; // [sp+1Ah] [bp-6h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if ( !sub_10012260(2, 284, &v6) || sub_100276F0((int)&v6) )
  {
    result = 0;
  }
  else
  {
    v2 = v8;
    *(_DWORD *)a2 = v7;
    v3 = v9;
    *(_DWORD *)(a2 + 4) = v2;
    v4 = v10;
    *(_DWORD *)(a2 + 8) = v3;
    LOWORD(v3) = v11;
    *(_DWORD *)(a2 + 12) = v4;
    LOBYTE(v4) = v12;
    *(_WORD *)(a2 + 16) = v3;
    *(_BYTE *)(a2 + 18) = v4;
    result = 1;
  }
  return result;
}

//----- (10031FD0) --------------------------------------------------------
BOOL __cdecl sub_10031FD0(int a1, int a2)
{
  return sub_10032AE0(6169, a2, 40) == 0;
}

//----- (10031FF0) --------------------------------------------------------
char __cdecl sub_10031FF0(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10031FD0(a1, a5);
  }
  else
  {
    result = sub_10031F20(a1, a5);
  }
  return result;
}

//----- (10032030) --------------------------------------------------------
char __cdecl sub_10032030(void *a1)
{
  *(_DWORD *)a1 = 0;
  return sub_10012260(2, 363, a1);
}

//----- (10032050) --------------------------------------------------------
char __cdecl sub_10032050(void *a1)
{
  int v1; // edx@2
  int v2; // eax@2
  int v3; // ecx@2
  int v4; // eax@2
  int v5; // ecx@2
  void *v6; // esi@2
  signed int v7; // edi@2
  char *v8; // eax@4
  signed int v9; // edx@4
  char result; // al@6
  char v11; // [sp+8h] [bp-208h]@1
  int v12; // [sp+47h] [bp-1C9h]@2
  int v13; // [sp+4Bh] [bp-1C5h]@2
  int v14; // [sp+4Fh] [bp-1C1h]@2
  int v15; // [sp+53h] [bp-1BDh]@2
  int v16; // [sp+58h] [bp-1B8h]@2
  int v17; // [sp+5Ch] [bp-1B4h]@2
  __int16 v18; // [sp+60h] [bp-1B0h]@2
  char v19; // [sp+62h] [bp-1AEh]@2
  char v20; // [sp+B6h] [bp-15Ah]@2
  char v21; // [sp+F6h] [bp-11Ah]@2

  *(_DWORD *)a1 = 0;
  if ( sub_10032AE0(6444, (int)&v11, 514) )
  {
    result = 0;
  }
  else
  {
    v1 = v13;
    v2 = v14;
    *((_DWORD *)a1 + 3330) = v12;
    v3 = v15;
    *((_DWORD *)a1 + 3331) = v1;
    LOWORD(v1) = v18;
    *((_DWORD *)a1 + 3332) = v2;
    v4 = v16;
    *((_DWORD *)a1 + 3333) = v3;
    qmemcpy((char *)a1 + 13340, &v19, 0x54u);
    v5 = v17;
    *((_WORD *)a1 + 6668) = v1;
    LOBYTE(v1) = v21;
    *((_DWORD *)a1 + 3009) = v5;
    qmemcpy((char *)a1 + 13424, &v20, 0x40u);
    *((_DWORD *)a1 + 3008) = v4;
    *((_BYTE *)a1 + 13488) = v1 & 2;
    v6 = a1;
    v7 = 32;
    do
    {
      memset(v6, 0, 0x38u);
      *((_DWORD *)v6 + 9) = 2048;
      v6 = (char *)v6 + 56;
      --v7;
    }
    while ( v7 );
    v8 = (char *)a1 + 1799;
    v9 = 512;
    do
    {
      *(_DWORD *)(v8 - 7) = 0;
      *(_DWORD *)(v8 - 3) = 0;
      *(_DWORD *)(v8 + 1) = 0;
      *(_DWORD *)(v8 + 5) = 0;
      *(_DWORD *)(v8 + 9) = 0;
      *v8 = -1;
      v8 += 20;
      --v9;
    }
    while ( v9 );
    result = 1;
  }
  return result;
}

//----- (100321A0) --------------------------------------------------------
char __cdecl sub_100321A0(int a1, char a2, char a3, int a4, void *a5, size_t a6)
{
  char result; // al@3
  char v7; // al@6
  char v8; // bl@8
  char v9; // al@10
  char v10; // bl@12
  char v11; // al@14
  char v12; // bl@16
  char v13; // al@18
  char v14; // bl@20

  switch ( a3 )
  {
    case 0x18:
      if ( a2 )
        result = sub_10032050(a5);
      else
        result = sub_10032030(a5);
      break;
    case 0x19:
      if ( a2 )
        v7 = sub_10032050(&unk_1022F3C8);
      else
        v7 = sub_10032030(&unk_1022F3C8);
      v8 = v7;
      memcpy(a5, (char *)&unk_1022F3C8 + 56 * *(_BYTE *)a4, a6);
      result = v8;
      break;
    case 0x1A:
      if ( a2 )
        v9 = sub_10032050(&unk_1022F3C8);
      else
        v9 = sub_10032030(&unk_1022F3C8);
      v10 = v9;
      memcpy(a5, (char *)&unk_102322D0 + 40 * *(_BYTE *)a4, a6);
      result = v10;
      break;
    case 0x1B:
      if ( a2 )
        v11 = sub_10032050(&unk_1022F3C8);
      else
        v11 = sub_10032030(&unk_1022F3C8);
      v12 = v11;
      memcpy(a5, (char *)&unk_102327D0 + *(_BYTE *)a4, a6);
      result = v12;
      break;
    case 0x2B:
      if ( a2 )
        v13 = sub_10032050(&unk_1022F3C8);
      else
        v13 = sub_10032030(&unk_1022F3C8);
      v14 = v13;
      memcpy(a5, &unk_10232878, a6);
      result = v14;
      break;
    default:
      sub_10011520("..\\lib\\acl\\iop\\gdl59\\iop_gdl59_cnfg_intf.c", 709, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10032340) --------------------------------------------------------
char __cdecl sub_10032340(char a1)
{
  char result; // al@3

  if ( a1 == 15 )
  {
    result = 0;
  }
  else if ( a1 == 16 )
  {
    result = 1;
  }
  else
  {
    sub_10011520("..\\lib\\acl\\iop\\iop_adc_intf.c", 178, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10032380) --------------------------------------------------------
__int16 __usercall sub_10032380@<ax>(unsigned __int8 a1@<al>)
{
  return word_100BC818[a1];
}
// 100BC818: using guessed type __int16 word_100BC818[];

//----- (10032390) --------------------------------------------------------
char __cdecl sub_10032390(unsigned __int8 a1, char *a2)
{
  int v2; // eax@2
  char result; // al@5
  int v4; // [sp+4h] [bp-150h]@2
  char v5; // [sp+8h] [bp-14Ch]@1
  char v6; // [sp+9h] [bp-14Bh]@3
  char v7; // [sp+Ch] [bp-148h]@5

  memset(&v5, 0, 0x148u);
  if ( a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    LOWORD(v2) = sub_10032380(a1);
    if ( sub_10012290(0, v2, &v5, (int)&v4) && v6 == 3 && (unsigned int)(unsigned __int16)v4 - 4 >= 0xA0 )
    {
      qmemcpy(a2, &v7, 0xA0u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (10032460) --------------------------------------------------------
char __cdecl sub_10032460(char a1, char a2, char a3, int a4, char *a5, unsigned int a6)
{
  char result; // al@3
  unsigned __int8 v7; // [sp+4h] [bp-4h]@1

  v7 = sub_10032340(a1);
  if ( a3 != 11 )
  {
    sub_10011520("..\\lib\\acl\\iop\\iop_adc_intf.c", 564, 0, 0);
    return 0;
  }
  if ( a6 >= 0xA0 )
  {
    if ( a2 )
      return 0;
    result = sub_10032390(v7, a5);
  }
  else
  {
    sub_10011520("..\\lib\\acl\\iop\\iop_adc_intf.c", 551, 0, 0);
    result = 0;
  }
  return result;
}

//----- (100324E0) --------------------------------------------------------
char __cdecl sub_100324E0(unsigned __int16 a1, char *a2, char a3)
{
  char result; // al@4
  char v4; // al@5
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
    {
      sub_10011520("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 188, 0, 0);
      return 0;
    }
    v4 = sub_10012290(1, 555, &v5, (int)&a1);
  }
  else
  {
    v4 = sub_10012290(1, 550, &v5, (int)&a1);
  }
  if ( !v4 )
    return 0;
  if ( sub_10027F60((int)&v5) )
    return 0;
  result = 1;
  if ( !BYTE1(v14) || (unsigned int)a1 - 4 < 0x20 )
    return 0;
  if ( a3 )
  {
    if ( BYTE1(v5) == 26 )
    {
      qmemcpy(a2, (char *)&v6 + 1, 0x20u);
      qmemcpy(&unk_102328A0, (char *)&v6 + 1, 0x20u);
      byte_10232898 = 1;
      byte_10232899 = 0;
      return result;
    }
  }
  else if ( BYTE1(v5) == 12 )
  {
    qmemcpy(a2, (char *)&v6 + 1, 0x20u);
    qmemcpy(&unk_102328C0, (char *)&v6 + 1, 0x20u);
    byte_10232899 = 1;
    byte_1023289A = 1;
    return result;
  }
  return 0;
}
// 10232898: using guessed type char byte_10232898;
// 10232899: using guessed type char byte_10232899;
// 1023289A: using guessed type char byte_1023289A;

//----- (10032610) --------------------------------------------------------
char __cdecl sub_10032610(char a1, int a2)
{
  char result; // al@3
  char v3; // [sp+4h] [bp-44h]@1
  char v4; // [sp+8h] [bp-40h]@3
  char v5; // [sp+28h] [bp-20h]@3

  memset(&v3, 0, 0x44u);
  if ( (unsigned __int8)a1 < 2u && a2 )
  {
    result = sub_1002BEF0(a1, (int)&v3);
    qmemcpy((void *)a2, &v4, 0x20u);
    qmemcpy((void *)(a2 + 32), &v5, 0x20u);
  }
  else
  {
    result = sub_10011520("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 570, 0, 0);
  }
  return result;
}

//----- (10032690) --------------------------------------------------------
bool __cdecl sub_10032690(void *a1)
{
  bool v1; // zf@2
  bool result; // al@4

  if ( a1 )
  {
    v1 = byte_10232898 == 0;
    qmemcpy(a1, &unk_102328A0, 0x40u);
    result = !v1 && byte_1023289A;
  }
  else
  {
    sub_10011520("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 617, 0, 0);
    result = 0;
  }
  return result;
}
// 10232898: using guessed type char byte_10232898;
// 1023289A: using guessed type char byte_1023289A;

//----- (100326E0) --------------------------------------------------------
char __cdecl sub_100326E0(char a1, int a2)
{
  char result; // al@4
  int v3; // edx@5
  const void *v4; // esi@8
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( j_HWM_pvg_read_reg(1) != 1 )
    sub_10011520("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 857, 1, 0);
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 != 1 )
      return result;
    result = sub_1001A3E0(15);
    v3 = 555;
  }
  else
  {
    result = sub_1001A3E0(8);
    v3 = 550;
  }
  if ( result )
  {
    v4 = (const void *)a2;
    LOBYTE(v5) = 12;
    BYTE1(v14) = 1;
    LOBYTE(v6) = 32;
    HIWORD(v5) = 34;
    if ( byte_10232899 )
    {
      BYTE1(v5) = 26;
    }
    else
    {
      BYTE1(v5) = 12;
      v4 = (const void *)(a2 + 32);
    }
    qmemcpy((char *)&v6 + 1, v4, 0x20u);
    result = sub_10011D60(1, v3, &v5, 1, 38, 1);
  }
  return result;
}
// 100331E0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10232899: using guessed type char byte_10232899;

//----- (100327C0) --------------------------------------------------------
__int16 __usercall sub_100327C0@<ax>(unsigned __int8 a1@<al>)
{
  return word_100BC928[a1];
}
// 100BC928: using guessed type __int16 word_100BC928[];

//----- (100327D0) --------------------------------------------------------
char __cdecl sub_100327D0(unsigned __int8 a1, int *a2, const void *a3)
{
  int v3; // ebx@1
  int v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int v7; // [sp+14h] [bp-20h]@1
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+28h] [bp-Ch]@1
  int v13; // [sp+2Ch] [bp-8h]@1
  int v14; // [sp+30h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v3 = (unsigned __int16)sub_100327C0(a1);
  v5 = *a2;
  qmemcpy(&v6, a3, 0x24u);
  sub_10011D60(1, v3, &v5, 1, HIWORD(v5) + 4, 1);
  return sub_10011EA0(1, v3, 0xFFFFFFF);
}

//----- (10032860) --------------------------------------------------------
char __cdecl sub_10032860(unsigned __int8 a1, char a2)
{
  int v3; // [sp+4h] [bp-28h]@1
  int v4; // [sp+8h] [bp-24h]@1
  int v5; // [sp+Ch] [bp-20h]@1
  int v6; // [sp+10h] [bp-1Ch]@1
  int v7; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@1
  int v9; // [sp+1Ch] [bp-10h]@1
  int v10; // [sp+20h] [bp-Ch]@1
  int v11; // [sp+24h] [bp-8h]@1
  int v12; // [sp+28h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v3 = 0;
  if ( a1 >= 2u )
  {
    sub_10011520("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 736, 0, 0);
  }
  else
  {
    HIWORD(v3) = 0;
    LOBYTE(v3) = 12;
    if ( a2 == 11 )
    {
      BYTE1(v3) = byte_10232899 != 0 ? 25 : 11;
      sub_100327D0(a1, &v3, &v4);
      return 1;
    }
    if ( a2 == 17 )
    {
      LOWORD(v3) = 10042;
      sub_100327D0(a1, &v3, &v4);
      return 1;
    }
  }
  return 0;
}
// 10232899: using guessed type char byte_10232899;

//----- (10032920) --------------------------------------------------------
bool __cdecl sub_10032920(__int16 a1, char a2, int a3, int a4, void *a5)
{
  char v6; // [sp+4h] [bp-40h]@8
  char v7; // [sp+24h] [bp-20h]@11

  if ( (unsigned __int8)a1 == 8 )
  {
    LOBYTE(a1) = 0;
  }
  else
  {
    if ( (unsigned __int8)a1 != 9 )
      return 0;
    LOBYTE(a1) = 1;
  }
  if ( a2 == 1 )
  {
    sub_10032610(a1, (int)a5);
    return 1;
  }
  if ( byte_10232899 )
  {
    if ( sub_100324E0(a1, &v6, 1) )
    {
LABEL_14:
      byte_1023289B = 0;
      goto LABEL_15;
    }
    if ( (unsigned __int8)++byte_1023289B >= 5u )
    {
      byte_10232898 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( sub_100324E0(a1, &v7, 0) )
      goto LABEL_14;
    if ( (unsigned __int8)++byte_1023289B >= 5u )
    {
      byte_1023289A = 0;
      goto LABEL_14;
    }
  }
LABEL_15:
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    sub_10032610(a1, (int)&v6);
    sub_100326E0(a1, (int)&v6);
  }
  sub_10032860(a1, 11);
  return sub_10032690(a5);
}
// 100331E0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10232898: using guessed type char byte_10232898;
// 10232899: using guessed type char byte_10232899;
// 1023289A: using guessed type char byte_1023289A;
// 1023289B: using guessed type char byte_1023289B;

//----- (10032A20) --------------------------------------------------------
char __cdecl sub_10032A20(char a1)
{
  char result; // al@4

  switch ( a1 )
  {
    case 25:
      result = 0;
      break;
    case 26:
      result = 1;
      break;
    case 43:
      result = 2;
      break;
    default:
      sub_10011520("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 169, 0, 0);
      result = 3;
      break;
  }
  return result;
}

//----- (10032A60) --------------------------------------------------------
char __cdecl sub_10032A60(char a1)
{
  char result; // al@3

  if ( a1 == 20 )
  {
    result = 0;
  }
  else if ( a1 == 21 )
  {
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10032A80) --------------------------------------------------------
int __cdecl sub_10032A80(int a1)
{
  int v1; // ecx@1
  int result; // eax@1

  v1 = 0;
  result = 42066;
  while ( dword_100C5208[2 * v1] != a1 )
  {
    if ( (unsigned int)++v1 >= 0xA5 )
      return result;
  }
  return dword_100C520C[2 * v1];
}
// 100C5208: using guessed type int dword_100C5208[];
// 100C520C: using guessed type int dword_100C520C[];

//----- (10032AE0) --------------------------------------------------------
int __cdecl sub_10032AE0(int a1, int a2, int a3)
{
  return reg_read(a1, a2, a3, 0);
}
// 10035F96: using guessed type int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10032B00) --------------------------------------------------------
char __cdecl sub_10032B00(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_10032AE0(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10011520("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1255, 1, 0);
  return v3;
}

//----- (10032B40) --------------------------------------------------------
int __cdecl sub_10032B40(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // esi@1

  result = sub_10032AE0(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    result = v5;
  }
  return result;
}

//----- (10032B80) --------------------------------------------------------
int __cdecl sub_10032B80(int a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_10032AE0(a1 | 0x20000, a2, a3);
  if ( result == -46 )
    result = 0;
  return result;
}

//----- (10032BB0) --------------------------------------------------------
int __cdecl sub_10032BB0(int a1, int a2, int a3)
{
  return reg_write(a1, a2, a3, 0);
}
// 10035F9C: using guessed type int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10032BD0) --------------------------------------------------------
int __cdecl sub_10032BD0(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // eax@2
  int result; // eax@4
  int v6; // [sp+10h] [bp-4h]@1

  v6 = sub_10032BB0(a1, a2, a3);
  v3 = 0;
  if ( (unsigned __int8)sub_10033D60() )
  {
    v4 = sub_10032A80(a1);
    if ( v4 != 42066 )
      v3 = sub_10032BB0(v4, a2, a3);
  }
  result = v6;
  if ( !v6 )
    result = v3;
  return result;
}
// 10033D60: using guessed type int sub_10033D60(void);

//----- (10032C30) --------------------------------------------------------
int __cdecl sub_10032C30(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  result = sub_10032BD0(a1, a2, a3);
  v4 = result;
  if ( result )
  {
    sub_10011520("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1742, 1, 0);
    result = v4;
  }
  return result;
}

//----- (10032C70) --------------------------------------------------------
char __cdecl sub_10032C70(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_10032BB0(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10011520("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1826, 1, 0);
  return v3;
}

//----- (10032CB0) --------------------------------------------------------
char __cdecl sub_10032CB0(int a1, _DWORD *a2, int a3, int a4, int a5, unsigned int a6)
{
  char v6; // dl@1
  int v7; // ecx@2
  unsigned int v8; // ebp@4
  unsigned int v9; // esi@5
  char v10; // dl@5
  unsigned int v11; // eax@5
  int v12; // eax@13
  bool v13; // zf@18
  int v15; // [sp+0h] [bp-20h]@1
  int v16; // [sp+4h] [bp-1Ch]@2
  int v17; // [sp+8h] [bp-18h]@13
  int v18; // [sp+Ch] [bp-14h]@2
  unsigned int v19; // [sp+10h] [bp-10h]@4
  char v20; // [sp+14h] [bp-Ch]@13
  int v21; // [sp+18h] [bp-8h]@14
  char v22; // [sp+30h] [bp+10h]@4
  char v23; // [sp+30h] [bp+10h]@13

  v6 = 0;
  v15 = 0;
  if ( a4 )
  {
    v7 = a3 + 4;
    v16 = a3 + 4;
    v18 = a4;
    do
    {
      if ( *(_DWORD *)(v7 - 4) == a1 )
      {
        v22 = 1;
        v19 = *(_DWORD *)(v7 + 4) - *(_DWORD *)v7;
        v8 = 0;
        do
        {
          v9 = v8 + *(_DWORD *)v7;
          v10 = 0;
          v11 = 0;
          if ( a6 )
          {
            v7 = a5;
            while ( !v10 )
            {
              if ( *(_DWORD *)v7 == a1 && *(_DWORD *)(v7 + 4) == v9 )
                v10 = 1;
              ++v11;
              v7 += 10;
              if ( v11 >= a6 )
              {
                if ( v10 )
                  break;
                goto LABEL_13;
              }
            }
          }
          else
          {
LABEL_13:
            v12 = j_reg_get_tag_hdr(v7, v10);
            v23 = v20 & (v12 == 1) & v22;
            v17 = 0;
            if ( !sub_10033D70(v9, (unsigned int *)&v15, &v17) )
              v15 = v21;
            v22 = (v17 == 0) & v23;
            *a2 += v15;
          }
          v7 = v16;
          ++v8;
        }
        while ( v8 <= v19 );
        v6 = v22;
      }
      v7 += 12;
      v13 = v18-- == 1;
      v16 = v7;
    }
    while ( !v13 );
  }
  return v6;
}
// 10032AC0: using guessed type int __fastcall j_reg_get_tag_hdr(_DWORD, _DWORD);

//----- (10032DC0) --------------------------------------------------------
int __cdecl sub_10032DC0(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // edi@1

  result = sub_10032AE0(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    sub_10032BB0(a1, (int)a4, a3);
    result = v5;
  }
  return result;
}

//----- (10032E10) --------------------------------------------------------
int __cdecl sub_10032E10(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_crit_lvl(a1);
  SYS_exit_krnl();
  return v1;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035FA2: using guessed type int __cdecl TSK_pvg_get_crit_lvl(_DWORD);

//----- (10032E30) --------------------------------------------------------
int sub_10032E30()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_id();
  SYS_exit_krnl();
  return v0;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035FA8: using guessed type int TSK_pvg_get_id(void);

//----- (10032E50) --------------------------------------------------------
int __cdecl sub_10032E50(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_get_msg(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035FAE: using guessed type int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD);

//----- (10032E80) --------------------------------------------------------
__int16 __cdecl sub_10032E80(int a1)
{
  __int16 v1; // si@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_run_state(a1);
  SYS_exit_krnl();
  return v1;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035FB4: using guessed type int __cdecl TSK_pvg_get_run_state(_DWORD);

//----- (10032EA0) --------------------------------------------------------
int __cdecl sub_10032EA0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_get_smphr_stats(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035FBA: using guessed type int __cdecl TSK_pvg_get_smphr_stats(_DWORD, _DWORD);

//----- (10032ED0) --------------------------------------------------------
int sub_10032ED0()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_timer();
  SYS_exit_krnl();
  return v0;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035FC0: using guessed type int TSK_pvg_get_timer(void);

//----- (10032EF0) --------------------------------------------------------
int __cdecl sub_10032EF0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_get_tsk_info(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035FC6: using guessed type int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10032F30) --------------------------------------------------------
int __cdecl sub_10032F30(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_kill_process(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035FD2: using guessed type int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10032F60) --------------------------------------------------------
int __cdecl sub_10032F60(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_release_smphr(a1);
  SYS_exit_krnl();
  return v1;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035FD8: using guessed type int __cdecl TSK_pvg_release_smphr(_DWORD);

//----- (10032F80) --------------------------------------------------------
int __cdecl sub_10032F80(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_reserve_smphr(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035FDE: using guessed type int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD);

//----- (10032FB0) --------------------------------------------------------
int __cdecl sub_10032FB0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_evnt(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035FE4: using guessed type int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD);

//----- (10032FE0) --------------------------------------------------------
int __cdecl sub_10032FE0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_send_msg(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035FEA: using guessed type int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10033010) --------------------------------------------------------
int __cdecl sub_10033010(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_msg_ex(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035FF0: using guessed type int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD);

//----- (10033040) --------------------------------------------------------
signed int __cdecl sub_10033040(int a1, int a2)
{
  signed int result; // eax@3
  char v3; // [sp+0h] [bp-10h]@1
  int v4; // [sp+8h] [bp-8h]@4
  char v5; // [sp+Ch] [bp-4h]@3

  if ( sub_10032EA0(a1, (int)&v3) )
  {
    result = -1;
  }
  else if ( a2 == -2 )
  {
    result = v5 & 1;
  }
  else
  {
    result = v4 == a2;
  }
  return result;
}

//----- (10033090) --------------------------------------------------------
int __cdecl sub_10033090(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_suspend(a1);
  SYS_exit_krnl();
  return v1;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035FF6: using guessed type int __cdecl TSK_pvg_suspend(_DWORD);

//----- (100330B0) --------------------------------------------------------
int __cdecl sub_100330B0(_BYTE *a1)
{
  int v1; // edi@1
  int v2; // eax@2
  char v4; // [sp+8h] [bp-4h]@2

  SYS_enter_krnl();
  v1 = TSK_pvg_wait_evnt(a1);
  SYS_exit_krnl();
  if ( *a1 & 0x20 )
  {
    v2 = sub_10032E30();
    sub_10032EF0((int)&v4, 5, v2, 4);
  }
  return v1;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10035FFC: using guessed type int __cdecl TSK_pvg_wait_evnt(_DWORD);

//----- (100330F0) --------------------------------------------------------
int __cdecl sub_100330F0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) != 1 && !a1 )
    result = sub_10032F60(a2);
  return result;
}
// 1005C130: using guessed type void *tsk_app_hdr_ptr;

//----- (10033120) --------------------------------------------------------
int __cdecl sub_10033120(int a1, int a2)
{
  int result; // eax@2

  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) == 1 )
    result = 0;
  else
    result = sub_10032F80(a1, a2);
  return result;
}
// 1005C130: using guessed type void *tsk_app_hdr_ptr;

//----- (10033140) --------------------------------------------------------
bool __cdecl sub_10033140(int a1)
{
  return sub_10033040(a1, -2) > 0;
}

//----- (10033160) --------------------------------------------------------
void __cdecl sub_10033160(int a1, _BYTE *a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_get(a1, a2);
  SYS_exit_krnl();
  sub_10034030(a1, a2);
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10036002: using guessed type int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD);

//----- (10033190) --------------------------------------------------------
int __cdecl sub_10033190(int a1, int a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_set(a1, a2);
  return SYS_exit_krnl();
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10036008: using guessed type int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD);

//----- (100331F0) --------------------------------------------------------
int __cdecl sub_100331F0(int a1, int a2)
{
  int v2; // esi@3

  if ( *(_DWORD *)(a1 + 8) < 0 )
    sub_10011520("..\\lib\\acl\\kernel\\mem_usr_share.c", 127, 0, 0);
  v2 = j_mem_unmap(a2 - 12, *(_DWORD *)(a1 + 8) + 12);
  if ( v2 )
    sub_10011520("..\\lib\\acl\\kernel\\mem_usr_share.c", 132, 1, 0);
  return v2;
}
// 10034060: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (10033250) --------------------------------------------------------
signed int __cdecl sub_10033250(int a1)
{
  unsigned int v1; // eax@1
  signed int result; // eax@3

  v1 = **(_DWORD **)(a1 + 16);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    if ( *(_BYTE *)(v1 - 3) || *(_BYTE *)(a1 + 4) & 8 )
    {
      if ( *(_BYTE *)(a1 + 4) & 1 )
      {
        *(_BYTE *)(v1 - 3) = 0;
        result = 1;
      }
      else
      {
        sub_10011520("..\\lib\\acl\\kernel\\mem_usr_share.c", 474, 1, 0);
        result = 0;
      }
    }
    else
    {
      sub_10011520("..\\lib\\acl\\kernel\\mem_usr_share.c", 465, 1, 0);
      result = 1;
    }
  }
  else
  {
    sub_10011520("..\\lib\\acl\\kernel\\mem_usr_share.c", 455, 1, 0);
    result = 0;
  }
  return result;
}

//----- (100332D0) --------------------------------------------------------
int __usercall sub_100332D0@<eax>(const char **a1@<esi>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // edi@2
  char v3; // ST28_1@2
  unsigned int v4; // eax@5
  char *v5; // edi@9
  char v6; // al@10
  unsigned int v7; // eax@12
  char v8; // ST28_1@12
  signed int v9; // ebx@15
  int v10; // eax@19
  int result; // eax@47
  unsigned int v12; // [sp+Ch] [bp-98h]@1
  int v13; // [sp+14h] [bp-90h]@29
  char v14; // [sp+1Dh] [bp-87h]@30
  char v15; // [sp+1Fh] [bp-85h]@9
  char v16; // [sp+20h] [bp-84h]@8

  v1 = 0;
  v12 = 0;
  if ( *((_BYTE *)a1 + 4) & 2 )
  {
    v2 = j_FIL_vfs_open(*a1, 4, 0);
    v3 = 4;
  }
  else
  {
    strncpy(&v16, *a1, 0x7Du);
    if ( !(*((_BYTE *)a1 + 4) & 8) )
    {
      v5 = &v15;
      do
        v6 = (v5++)[1];
      while ( v6 );
      *(_DWORD *)v5 = 7368052;
    }
    v12 = j_FIL_vfs_open(*a1, 6, 1809);
    v7 = j_FIL_vfs_open(&v16, 14, 1809);
    v2 = v7;
    v8 = 6;
    if ( v7 >= 0xFFFFFFC2 || !v7 )
    {
      sub_10011520("..\\lib\\acl\\kernel\\mem_usr_share.c", 589, 1, 0);
      goto LABEL_39;
    }
    v9 = sub_100339F0(v7, 0, 2);
    if ( v9 < 0 )
    {
      sub_10011520("..\\lib\\acl\\kernel\\mem_usr_share.c", 602, 1, 0);
      goto LABEL_39;
    }
    if ( (signed int)a1[2] < 0 )
      sub_10011520("..\\lib\\acl\\kernel\\mem_usr_share.c", 610, 0, 0);
    v10 = (int)(a1[2] + 12);
    if ( v9 < v10 && sub_10033A10(v2, v10, (unsigned __int64)v10 >> 32) < 0 )
    {
      sub_10011520("..\\lib\\acl\\kernel\\mem_usr_share.c", 625, 1, 0);
      goto LABEL_39;
    }
  }
  if ( v2 >= 0xFFFFFFC2 )
    goto LABEL_42;
  if ( v2 )
  {
    v4 = ((int (__cdecl *)(unsigned int, _DWORD, const char *, _DWORD))j_FIL_vfs_mmap)(v2, 0, a1[2] + 12, 0);
    v1 = v4;
    if ( v4 < 0xFFFFFFC2 && v4 )
    {
      if ( !(*((_BYTE *)a1 + 4) & 1) )
      {
        if ( *(_BYTE *)(v4 + 9) || *(_BYTE *)(v4 + 8) != 56 )
        {
          sub_100331F0((int)a1, v4 + 12);
          v1 = 0;
        }
        goto LABEL_39;
      }
      *(_DWORD *)(v4 + 4) = sub_10032ED0();
      if ( *((_BYTE *)a1 + 4) & 4 )
        memset((void *)(v1 + 12), (int)a1[3], (size_t)a1[2]);
      if ( v12 < 0xFFFFFFC2 && v12 )
      {
        if ( *((_BYTE *)a1 + 4) & 8 )
        {
          ++*(_DWORD *)v1;
        }
        else if ( sub_10033830(v12, &v13, 12) == 12 )
        {
          *(_DWORD *)v1 = ++v13;
          v14 = 1;
          *(_BYTE *)(v1 + 9) = 1;
          if ( sub_100339A0(v12, (int)&v13, 12, 0) != 12 )
          {
            sub_10011520("..\\lib\\acl\\kernel\\mem_usr_share.c", 725, 1, 0);
            goto LABEL_39;
          }
        }
      }
      else
      {
        *(_BYTE *)(v1 + 9) = 1;
        *(_DWORD *)v1 = 1;
      }
      *(_BYTE *)(v1 + 8) = 56;
      if ( !(*((_BYTE *)a1 + 4) & 8) && j_FIL_vfs_rename(&v16, *a1) )
        sub_10011520("..\\lib\\acl\\kernel\\mem_usr_share.c", 759, 1, 0);
      goto LABEL_39;
    }
    sub_10011520("..\\lib\\acl\\kernel\\mem_usr_share.c", 664, 0, 0);
  }
LABEL_39:
  if ( v2 < 0xFFFFFFC2 && v2 )
    sub_10033760(v2);
LABEL_42:
  if ( v12 < 0xFFFFFFC2 && v12 )
    sub_10033760(v12);
  if ( v1 < 0xFFFFFFC2 && v1 )
    result = v1 + 12;
  else
    result = v1;
  return result;
}
// 10033810: using guessed type int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10033820: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 100338F0: using guessed type int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD);

//----- (100335D0) --------------------------------------------------------
int __usercall sub_100335D0@<eax>(int a1@<eax>, int a2@<ecx>)
{
  return j_mem_unmap(a2 - 12, a1 + 12);
}
// 10034060: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (100335F0) --------------------------------------------------------
signed int __cdecl sub_100335F0(int a1)
{
  unsigned int v1; // eax@1
  char v2; // bl@1
  int *v3; // edi@6
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // ebp@6
  unsigned int v8; // eax@15

  v1 = **(_DWORD **)(a1 + 16);
  v2 = 0;
  if ( v1 != -858993460 && (v1 < 0xFFFFFFC2 && v1 || v1 == -15) )
  {
    if ( v1 < 0xFFFFFFC2 && v1 && !*(_BYTE *)(v1 - 3) )
      return 1;
  }
  else
  {
    sub_10011520("..\\lib\\acl\\kernel\\mem_usr_share.c", 211, 0, *(char **)a1);
    **(_DWORD **)(a1 + 16) = -15;
  }
  v3 = *(int **)(a1 + 16);
  v4 = sub_10033120(81, 5000);
  v5 = *v3;
  v6 = v4;
  if ( (unsigned int)*v3 < 0xFFFFFFC2 && v5 )
  {
    if ( !*(_BYTE *)(v5 - 3) )
    {
      sub_100330F0(v4, 81);
      return 1;
    }
    *v3 = -15;
    sub_100335D0(*(_DWORD *)(a1 + 8), v5);
  }
  v8 = sub_100332D0((const char **)a1);
  if ( v8 < 0xFFFFFFC2 && v8 )
  {
    *v3 = v8;
    if ( !*(_BYTE *)(v8 - 3) )
      v2 = 1;
  }
  sub_100330F0(v6, 81);
  return (unsigned __int8)v2;
}

//----- (100336C0) --------------------------------------------------------
int __cdecl sub_100336C0(LONG Value)
{
  char v1; // al@1
  int result; // eax@3
  int v3; // edi@3
  unsigned __int32 v4; // eax@5
  int v5; // ebx@5

  v1 = *(_BYTE *)(Value + 4);
  if ( v1 & 2 || !(v1 & 1) )
  {
    sub_10011520("..\\lib\\acl\\kernel\\mem_usr_share.c", 360, 1, 0);
    result = 0;
  }
  else
  {
    result = sub_100332D0((const char **)Value);
    v3 = result;
    if ( (unsigned int)result < 0xFFFFFFC2 && result )
    {
      v4 = InterlockedExchange(*(volatile LONG **)(Value + 16), result);
      v5 = v4;
      if ( v4 < 0xFFFFFFC2 && v4 )
      {
        if ( *(_DWORD *)(Value + 8) < 0 )
          sub_10011520("..\\lib\\acl\\kernel\\mem_usr_share.c", 388, 0, 0);
        sub_100335D0(*(_DWORD *)(Value + 8), v5);
      }
      result = v3;
    }
  }
  return result;
}

//----- (10033760) --------------------------------------------------------
signed int __cdecl sub_10033760(unsigned int a1)
{
  signed int result; // eax@7
  int v2; // eax@8
  int v3; // edx@9
  unsigned int v4; // [sp+4h] [bp+4h]@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return FIL_vfs_close();
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_10049750(a1);
    if ( v4 && *(_DWORD *)(v4 + 732) )
    {
      --*(_DWORD *)(*(_DWORD *)(v4 + 732) + 124);
      if ( *(_BYTE *)(v4 + 8) )
        exit_1(v4);
      sub_10051510(v4 + 116);
      result = 0;
      *(_DWORD *)v4 = -858993460;
    }
    else
    {
      result = -6;
    }
    return result;
  }
  if ( !a1 || (a1 & 3) != 2 )
    return FIL_vfs_close();
  v2 = 0;
  if ( !dword_102461D0 )
    goto LABEL_11;
  while ( 1 )
  {
    v3 = dword_102461D8[v2];
    if ( *(_DWORD *)v3 == a1 )
      break;
    if ( ++v2 >= (unsigned int)dword_102461D0 )
      goto LABEL_11;
  }
  if ( v2 != -1 )
  {
    sub_10034070(
      v2,
      *(_DWORD *)(dword_102461D8[v2] + 12),
      *(_DWORD *)(v3 + 16),
      *(_BYTE *)(v3 + 32),
      *(_WORD *)(v3 + 20),
      *(_DWORD *)(v3 + 4));
    result = sub_10033760(a1 & 0xFFFFFFFC);
  }
  else
  {
LABEL_11:
    result = -6;
  }
  return result;
}
// 1003602C: using guessed type int FIL_vfs_close(void);
// 102461D0: using guessed type int dword_102461D0;
// 102461D8: using guessed type int dword_102461D8[];

//----- (100337C0) --------------------------------------------------------
int __cdecl sub_100337C0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-1Ch]@1
  __int64 v7; // [sp+4h] [bp-18h]@1
  __int64 v8; // [sp+10h] [bp-Ch]@1

  v7 = a2;
  v8 = a4;
  return FIL_vfs_memmove_swi(&v6, a1, v7, HIDWORD(v7), a3, v8, HIDWORD(v8), a5);
}
// 1003603E: using guessed type int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10033830) --------------------------------------------------------
signed int __cdecl sub_10033830(unsigned int a1, void *a2, int a3)
{
  int v3; // eax@7
  unsigned int v4; // eax@4
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_10049750(a1);
    return sub_1004A610(v4, (int)a2, a3);
  }
  if ( a1 && (a1 & 3) == 2 )
  {
    v3 = sub_100339F0(a1 & 0xFFFFFFFC, 0, 1);
    result = sub_10034410(a1, a2, a3, v3, (unsigned __int64)v3 >> 32);
  }
  else
  {
LABEL_11:
    result = FIL_vfs_read();
  }
  return result;
}
// 10036050: using guessed type int FIL_vfs_read(void);

//----- (10033870) --------------------------------------------------------
signed int __cdecl sub_10033870(unsigned int a1, void *a2, int a3, int a4, int a5)
{
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
    return sub_10049690(a1, (int)a2, a3, a4);
  if ( a1 && (a1 & 3) == 2 )
    result = sub_10034410(a1, a2, a3, a4, a5);
  else
LABEL_11:
    result = FIL_vfs_read_ofst(a1, a2, a3, &a4);
  return result;
}
// 10036056: using guessed type int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10033900) --------------------------------------------------------
signed int __cdecl sub_10033900(unsigned int a1, int a2, int a3, int a4)
{
  signed int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = sub_100496F0(a1, a2, a4);
  else
    result = FIL_vfs_seek(a1 & 0xFFFFFFFC, a2, a3, a4);
  return result;
}
// 10036062: using guessed type int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10033950) --------------------------------------------------------
__int64 __cdecl sub_10033950(int a1)
{
  return FIL_vfs_size(a1 & 0xFFFFFFFC);
}
// 10036068: using guessed type int __cdecl FIL_vfs_size(_DWORD);

//----- (10033970) --------------------------------------------------------
int __cdecl sub_10033970(int a1, int a2, int a3)
{
  return FIL_vfs_truncate(a1, a2, a3);
}
// 1003606E: using guessed type int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD);

//----- (100339A0) --------------------------------------------------------
int __cdecl sub_100339A0(int a1, int a2, int a3, char a4)
{
  return FIL_vfs_write_ofst(a1, a2, a3, &a4);
}
// 1003607A: using guessed type int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100339C0) --------------------------------------------------------
char __cdecl sub_100339C0(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 516, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_10033760(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10033820: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (100339F0) --------------------------------------------------------
signed int __cdecl sub_100339F0(unsigned int a1, int a2, int a3)
{
  return sub_10033900(a1, a2, (unsigned __int64)a2 >> 32, a3);
}

//----- (10033A10) --------------------------------------------------------
int __cdecl sub_10033A10(int a1, int a2, int a3)
{
  return sub_10033970(a1, a2, a3);
}

//----- (10033A80) --------------------------------------------------------
int __cdecl sub_10033A80(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_recv_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 10036098: using guessed type int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD);

//----- (10033AD0) --------------------------------------------------------
int __cdecl sub_10033AD0(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_send_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 10035EE8: using guessed type int SYS_exit_krnl(void);
// 10035EF4: using guessed type int SYS_enter_krnl(void);
// 1003609E: using guessed type int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD);

//----- (10033B50) --------------------------------------------------------
int __cdecl sub_10033B50(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100122C0(v1);
  a1 = v2;
  v3 = sub_10019B30(&a1, 4u, (int)&unk_100C3560, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100C3564[2 * v3];
}
// 100C3564: using guessed type int dword_100C3564[];

//----- (10033B90) --------------------------------------------------------
int __cdecl sub_10033B90(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100122C0(v1);
  a1 = v2;
  v3 = sub_10019B30(&a1, 4u, (int)&unk_100C3598, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100C359C[2 * v3];
}
// 100C359C: using guessed type int dword_100C359C[];

//----- (10033BD0) --------------------------------------------------------
int __cdecl sub_10033BD0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100122C0(v1);
  a1 = v2;
  v3 = sub_10019B30(&a1, 4u, (int)&unk_100C35D0, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100C35D4[2 * v3];
}
// 100C35D4: using guessed type int dword_100C35D4[];

//----- (10033C10) --------------------------------------------------------
int __cdecl sub_10033C10(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100122C0(v1);
  a1 = v2;
  v3 = sub_10019B30(&a1, 4u, (int)&unk_100C3608, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100C360C[2 * v3];
}
// 100C360C: using guessed type int dword_100C360C[];

//----- (10033C50) --------------------------------------------------------
int __cdecl sub_10033C50(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // eax@2
  int v6; // eax@8

  result = 0;
  if ( a1 )
  {
    v5 = sub_10033B90(a4);
    result = sub_10032AE0(v5, a1, 104);
  }
  if ( a2 && !result )
    result = sub_10032AE0(3532, a2, 2);
  if ( a3 )
  {
    if ( !result )
    {
      v6 = sub_10033B50(a4);
      result = sub_10032AE0(v6, a3, 6);
    }
  }
  return result;
}

//----- (10033CC0) --------------------------------------------------------
int __cdecl sub_10033CC0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  int v5; // eax@3
  int v6; // eax@6
  int v7; // eax@7

  result = 0;
  if ( a1 )
  {
    v4 = sub_10033C10(a3);
    result = sub_10032AE0(v4, a1, 64);
    if ( result == -7 )
    {
      sub_10033090(100);
      v5 = sub_10033C10(a3);
      result = sub_10032AE0(v5, a1, 64);
    }
  }
  if ( a2 && !result )
  {
    v6 = sub_10033BD0(a3);
    result = sub_10032AE0(v6, a2, 8);
    if ( result == -7 )
    {
      sub_10033090(100);
      v7 = sub_10033BD0(a3);
      result = sub_10032AE0(v7, a2, 8);
    }
  }
  return result;
}

//----- (10033D70) --------------------------------------------------------
char __cdecl sub_10033D70(unsigned int a1, unsigned int *a2, int *a3)
{
  int *v3; // edi@4
  int *v4; // edi@5
  int *v5; // edi@6
  int *v7; // edi@11
  int *v8; // edi@12
  int *v9; // esi@13
  unsigned int *v10; // [sp-18h] [bp-E94h]@4
  signed int v11; // [sp-14h] [bp-E90h]@4
  int v12; // [sp+14h] [bp-E68h]@1
  int v13; // [sp+18h] [bp-E64h]@6
  int v14; // [sp+1Ch] [bp-E60h]@6
  char v15; // [sp+20h] [bp-E5Ch]@6
  char v16; // [sp+22h] [bp-E5Ah]@6
  char v17; // [sp+23h] [bp-E59h]@6
  char v18; // [sp+25h] [bp-E57h]@6
  char v19; // [sp+27h] [bp-E55h]@6
  char v20; // [sp+28h] [bp-E54h]@6
  char v21; // [sp+29h] [bp-E53h]@6
  int v22; // [sp+2Ch] [bp-E50h]@6
  int v23; // [sp+37h] [bp-E45h]@5
  int v24; // [sp+40h] [bp-E3Ch]@12
  int v25; // [sp+F0h] [bp-D8Ch]@13
  int v26; // [sp+E70h] [bp-Ch]@11
  int v27; // [sp+E74h] [bp-8h]@11

  memset(&v12, 0, 0xE64u);
  *_errno() = 0;
  if ( a1 > 0x183A )
  {
    if ( a1 == 6455 )
    {
      v9 = _errno();
      *v9 = sub_10032AE0(6455, (int)&v12, 252);
      v25 = 0;
      v11 = 252;
LABEL_14:
      v10 = (unsigned int *)&v12;
      goto LABEL_15;
    }
    if ( a1 != 6649 )
    {
      if ( a1 != 6655 )
        return 0;
      goto LABEL_11;
    }
LABEL_12:
    v8 = _errno();
    *v8 = sub_10032AE0(a1, (int)&v12, 48);
    v11 = 48;
    v24 = 0;
    v10 = (unsigned int *)&v12;
    goto LABEL_15;
  }
  if ( a1 >= 0x1839 )
    goto LABEL_12;
  switch ( a1 )
  {
    case 0x17D9u:
    case 0x17DAu:
      v3 = _errno();
      v11 = 36;
      *v3 = sub_10032AE0(a1, (int)&v12, 36);
      v12 = 0;
      v10 = (unsigned int *)&v12;
      goto LABEL_15;
    case 0x1819u:
      v4 = _errno();
      *v4 = sub_10032AE0(a1, (int)&v12, 40);
      v11 = 40;
      v23 = 0;
      v10 = (unsigned int *)&v12;
      goto LABEL_15;
    case 0x17CDu:
    case 0x17CEu:
      v5 = _errno();
      *v5 = sub_10032AE0(a1, (int)&v12, 60);
      v12 = 0;
      v13 = 0;
      v14 = 0;
      v15 = 0;
      v16 = 0;
      v17 = 0;
      v22 = 0;
      v18 = 0;
      v21 = 0;
      v19 = 0;
      v20 = 0;
      v11 = 60;
      goto LABEL_14;
    default:
      return 0;
    case 0x1776u:
    case 0x1777u:
    case 0x1778u:
      break;
  }
LABEL_11:
  v7 = _errno();
  *v7 = sub_10032AE0(a1, (int)&v12, 3684);
  v11 = 3684;
  v26 = 0;
  v27 = 0;
  v10 = (unsigned int *)&v12;
LABEL_15:
  *a2 = sub_10035DC0(v10, v11, 0xFFFFFFFF);
  *a3 = *_errno();
  return 1;
}

//----- (10034030) --------------------------------------------------------
void __cdecl sub_10034030(__int16 a1, _BYTE *a2)
{
  void *v2; // ecx@0
  void *v3; // ecx@2

  if ( a1 == 29 && sub_1000BBE0(v2) && sub_1000BC40(v3) != 1 )
    *a2 = 0;
}

//----- (10034070) --------------------------------------------------------
unsigned int __cdecl sub_10034070(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6)
{
  size_t v6; // ebp@1
  int *v7; // esi@1
  size_t v8; // ebx@1
  int v9; // edx@1
  unsigned int v10; // edi@1
  int v11; // ebx@2
  int v12; // edx@3
  int *v13; // ebp@3
  int v14; // eax@3
  int v15; // eax@3
  unsigned int result; // eax@4
  void **v17; // [sp+10h] [bp-Ch]@1
  void **v18; // [sp+20h] [bp+4h]@1

  v6 = 8 * a5;
  v7 = &dword_102461D8[a1];
  v8 = 32 * (a3 / (1 << a4));
  v9 = a2 - v8 - v6;
  *v7 = v9 + a3 - 52;
  v17 = (void **)&dword_10246190[a1];
  dword_10246190[a1] = a3 + v9;
  dword_10246150[a1] = a3 + a2 - v8;
  v18 = (void **)&dword_10246150[a1];
  memset((void *)(v9 + a3 - 52), 0, 0x34u);
  memset(*v17, 0, v6);
  memset(*v18, 0, v8);
  *(_DWORD *)(*v7 + 24) = 1 << a4;
  *(_DWORD *)(*v7 + 28) = ~(*(_DWORD *)(*v7 + 24) - 1);
  *(_BYTE *)(*v7 + 32) = a4;
  *(_DWORD *)(*v7 + 12) = a2;
  *(_DWORD *)(*v7 + 16) = a3;
  *(_DWORD *)(*v7 + 8) = a3 / (1 << a4) - (v8 + v6 + 52) / (1 << a4) - 1;
  *(_DWORD *)(*v7 + 4) = a6;
  *(_WORD *)(*v7 + 20) = a5;
  *(_DWORD *)*v7 = -1;
  *(_DWORD *)(*v7 + 36) = *v7 + 36;
  *(_DWORD *)(*v7 + 40) = *v7 + 36;
  *(_DWORD *)(*v7 + 44) = *v7 + 44;
  *(_DWORD *)(*v7 + 48) = *v7 + 44;
  v10 = 0;
  if ( *(_DWORD *)(*v7 + 8) )
  {
    v11 = 0;
    do
    {
      v12 = *v7;
      v13 = *(int **)(*v7 + 40);
      v14 = (int)*v18 + v11;
      *(_DWORD *)(v12 + 40) = v14;
      *(_DWORD *)v14 = v12 + 36;
      *(_DWORD *)(v14 + 4) = v13;
      *v13 = v14;
      v15 = a2 + v10++ * *(_DWORD *)(*v7 + 24);
      *(_DWORD *)((char *)*v18 + v11 + 28) = v15;
      v11 += 32;
    }
    while ( v10 < *(_DWORD *)(*v7 + 8) );
  }
  result = 0;
  if ( *(_WORD *)(*v7 + 20) )
  {
    do
    {
      *((_DWORD *)*v17 + 2 * result) = (char *)*v17 + 8 * result;
      *((_DWORD *)*v17 + 2 * result + 1) = (char *)*v17 + 8 * result;
      ++result;
    }
    while ( result < *(_WORD *)(*v7 + 20) );
  }
  return result;
}
// 10246190: using guessed type int dword_10246190[];
// 102461D8: using guessed type int dword_102461D8[];

//----- (10034220) --------------------------------------------------------
int __usercall sub_10034220@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int *v2; // ecx@1
  int result; // eax@2
  int v4; // eax@3
  int v5; // ecx@3
  _DWORD *v6; // edx@3
  int v7; // ecx@3
  _DWORD *v8; // edx@3
  int v9; // ecx@3
  int v10; // edx@3

  v1 = dword_102461D8[a1];
  v2 = (int *)(v1 + 36);
  if ( (int *)*v2 == v2 )
  {
    v4 = *(_DWORD *)(v1 + 44);
    v5 = *(_DWORD *)(v4 - 8);
    v6 = *(_DWORD **)(v4 - 4);
    result = v4 - 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v7 = *(_DWORD *)(result + 8);
    v8 = *(_DWORD **)(result + 12);
    *(_DWORD *)(v7 + 4) = v8;
    *v8 = v7;
    v9 = dword_102461D8[a1];
    v10 = *(_DWORD *)(v9 + 36);
    v9 += 36;
    *(_DWORD *)(v10 + 4) = result;
    *(_DWORD *)result = v10;
    *(_DWORD *)(result + 4) = v9;
    *(_DWORD *)v9 = result;
  }
  else
  {
    result = *v2;
  }
  return result;
}
// 102461D8: using guessed type int dword_102461D8[];

//----- (100342D0) --------------------------------------------------------
int __cdecl sub_100342D0(int a1, unsigned __int64 a2)
{
  int v2; // edi@1
  int *v3; // ebx@1
  signed int v4; // eax@1
  _DWORD *v5; // ecx@2
  int v6; // eax@2
  int *v7; // eax@2
  int v8; // ecx@2
  _DWORD *v9; // edx@2
  int v10; // eax@2
  int v11; // ecx@2
  int result; // eax@2

  v2 = sub_10034220(a1);
  v3 = &dword_102461D8[a1];
  v4 = sub_10033870(
         *(_DWORD *)dword_102461D8[a1] & 0xFFFFFFFC,
         *(void **)(v2 + 28),
         *(_DWORD *)(dword_102461D8[a1] + 24),
         a2,
         SHIDWORD(a2));
  if ( v4 <= 0 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD **)(v2 + 4);
    *(_WORD *)(v2 + 24) = v4;
    v6 = *(_DWORD *)v2;
    *(_QWORD *)(v2 + 16) = a2;
    *(_DWORD *)(v6 + 4) = v5;
    *v5 = v6;
    v7 = (int *)(dword_10246190[a1] + 8 * ((unsigned int)(a2 >> *(_BYTE *)(*v3 + 32)) % *(_WORD *)(*v3 + 20)));
    v8 = *v7;
    *(_DWORD *)(v8 + 4) = v2;
    *(_DWORD *)(v2 + 4) = v7;
    *(_DWORD *)v2 = v8;
    *v7 = v2;
    v9 = *(_DWORD **)(*v3 + 48);
    v10 = *v3 + 44;
    v11 = v2 + 8;
    *(_DWORD *)(v10 + 4) = v2 + 8;
    *(_DWORD *)v11 = v10;
    result = v2;
    *(_DWORD *)(v11 + 4) = v9;
    *v9 = v2 + 8;
  }
  return result;
}
// 10246190: using guessed type int dword_10246190[];
// 102461D8: using guessed type int dword_102461D8[];

//----- (10034380) --------------------------------------------------------
int __usercall sub_10034380@<eax>(int a1@<ebx>, unsigned __int64 a2)
{
  int *v2; // edi@1
  int *v3; // ecx@1
  int result; // eax@1
  int v5; // edx@5
  _DWORD *v6; // esi@5
  int v7; // ecx@5
  _DWORD *v8; // esi@5
  int v9; // edx@5

  v2 = &dword_102461D8[a1];
  v3 = (int *)(dword_10246190[a1]
             + 8 * ((unsigned int)(a2 >> *(_BYTE *)(dword_102461D8[a1] + 32)) % *(_WORD *)(dword_102461D8[a1] + 20)));
  result = *v3;
  if ( (int *)*v3 == v3 )
  {
LABEL_4:
    result = sub_100342D0(a1, a2);
  }
  else
  {
    while ( *(_QWORD *)(result + 16) != a2 )
    {
      result = *(_DWORD *)result;
      if ( (int *)result == v3 )
        goto LABEL_4;
    }
    v5 = *(_DWORD *)(result + 8);
    v6 = *(_DWORD **)(result + 12);
    v7 = result + 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v8 = *(_DWORD **)(*v2 + 48);
    v9 = *v2 + 44;
    *(_DWORD *)(v9 + 4) = result + 8;
    *(_DWORD *)(v7 + 4) = v8;
    *(_DWORD *)v7 = v9;
    *v8 = result + 8;
  }
  return result;
}
// 10246190: using guessed type int dword_10246190[];
// 102461D8: using guessed type int dword_102461D8[];

//----- (10034410) --------------------------------------------------------
unsigned int __cdecl sub_10034410(int a1, void *a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // edx@2
  unsigned int result; // eax@4
  int v10; // eax@7
  int v11; // esi@10
  int v12; // eax@10
  int v13; // ecx@11
  unsigned int v14; // eax@11
  const void *v15; // ecx@11
  size_t v16; // esi@12
  int v17; // ecx@13
  int v18; // et0@17

  v5 = a3;
  v6 = 0;
  v7 = a4;
  if ( !dword_102461D0 )
    goto LABEL_24;
  while ( 1 )
  {
    v8 = dword_102461D8[v6];
    if ( *(_DWORD *)v8 == a1 )
      break;
    if ( ++v6 >= (unsigned int)dword_102461D0 )
      return -1;
  }
  if ( v6 != -1 )
  {
    v10 = *(_DWORD *)(v8 + 4);
    if ( v10 != 138 )
      sub_10032F80(v10, -1);
    if ( a3 )
    {
      while ( 1 )
      {
        v11 = v7 & ~*(_DWORD *)(dword_102461D8[v6] + 28);
        v12 = sub_10034380(v6, (unsigned int)v7 & *(_DWORD *)(dword_102461D8[v6] + 28));
        if ( !v12 )
          break;
        v13 = *(_DWORD *)(v12 + 28);
        v14 = *(_WORD *)(v12 + 24) - v11;
        v15 = (const void *)(v11 + v13);
        if ( v5 <= v14 )
        {
          v16 = v5;
        }
        else
        {
          v16 = v14;
          if ( !v14 )
            goto LABEL_13;
        }
        memcpy(a2, v15, v16);
        v5 -= v16;
        v18 = (v16 + __PAIR__((unsigned int)a5, v7)) >> 32;
        v7 += v16;
        a5 = v18;
        a2 = (char *)a2 + v16;
        if ( !v5 )
          goto LABEL_13;
      }
      if ( *(_DWORD *)(dword_102461D8[v6] + 4) != 138 )
        sub_10032F60(*(_DWORD *)(dword_102461D8[v6] + 4));
      result = -1;
    }
    else
    {
LABEL_13:
      v17 = dword_102461D8[v6];
      if ( *(_DWORD *)(v17 + 4) != 138 )
        sub_10032F60(*(_DWORD *)(v17 + 4));
      result = a3 - v5;
    }
  }
  else
  {
LABEL_24:
    result = -1;
  }
  return result;
}
// 102461D0: using guessed type int dword_102461D0;
// 102461D8: using guessed type int dword_102461D8[];

//----- (10034560) --------------------------------------------------------
char sub_10034560()
{
  unsigned __int8 v0; // cl@2
  signed int v1; // eax@4

  if ( !sub_10022650() )
  {
    LOBYTE(v1) = 0;
    return v1;
  }
  v0 = *(_BYTE *)(dword_1025441C + 1200);
  if ( v0 || (v0 = *(_BYTE *)(dword_1025441C + 814)) != 0 )
  {
    LOBYTE(v1) = v0;
    if ( v0 < 4u )
      return v1;
    v1 = 4;
  }
  else
  {
    v1 = *(_BYTE *)(dword_1025441C + 122) == 0;
  }
  if ( v1 == 4 )
    LOBYTE(v1) = 0;
  return v1;
}
// 1025441C: using guessed type int dword_1025441C;

//----- (100345B0) --------------------------------------------------------
int __cdecl sub_100345B0(float a1, float a2, float a3)
{
  float *v3; // ecx@0
  int result; // eax@4

  if ( (COERCE_UNSIGNED_INT(*v3) & 0x7F800000) == 2139095040 || a1 < (double)*v3 || a2 > (double)*v3 )
  {
    result = 0;
    *v3 = a3;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10034600) --------------------------------------------------------
double __cdecl sub_10034600(char a1)
{
  double v1; // st7@5
  double result; // st7@9
  float v3; // [sp+0h] [bp-4h]@1

  v3 = 0.0;
  if ( !sub_10022650() )
    goto LABEL_13;
  if ( !a1 )
  {
    v1 = *(float *)(dword_1025441C + 124);
    goto LABEL_8;
  }
  if ( a1 == 2 )
  {
    v1 = *(float *)(dword_1025441C + 860);
    goto LABEL_8;
  }
  if ( a1 == 3 )
  {
    v1 = *(float *)(dword_1025441C + 1204);
LABEL_8:
    v3 = v1;
  }
  result = v3;
  if ( (LODWORD(v3) & 0x7F800000) == 2139095040 || result > 3.141592502593994 || result < -3.141592502593994 )
  {
    v3 = 0.0;
LABEL_13:
    result = v3;
  }
  return result;
}
// 1025441C: using guessed type int dword_1025441C;

//----- (10034690) --------------------------------------------------------
signed int __cdecl sub_10034690(char a1)
{
  return (signed int)(sub_10034600(a1) * 683565248.0);
}

//----- (100346B0) --------------------------------------------------------
char __cdecl sub_100346B0(float *a1)
{
  float v1; // ST18_4@6
  char result; // al@6
  float v3; // ST18_4@6
  char v4; // [sp+1Bh] [bp-2Dh]@6
  float v5; // [sp+1Ch] [bp-2Ch]@6
  char v6; // [sp+20h] [bp-28h]@2
  char v7; // [sp+2Eh] [bp-1Ah]@2

  *a1 = 0.0;
  if ( !sub_10022650()
    || (sub_10035680((int)&v6), v7)
    || *(_BYTE *)(dword_1025441C + 661)
    && (!*(_BYTE *)(dword_1025441C + 64)
     || (unsigned int)(*(_DWORD *)(dword_1025441C + 36) - *(_DWORD *)(dword_1025441C + 740)) >= 0x124F80) )
  {
    result = 0;
  }
  else
  {
    sub_10049730();
    sub_10035490(*(_BYTE *)(dword_1025441C + 1201), &v4, &v5);
    *a1 = *(float *)(dword_1025441C + 340);
    v1 = *(float *)(dword_1025441C + 336);
    sub_10034BA0(12756274.0, -12756274.0);
    sub_100345B0(514.44446, -514.44446, 0.0);
    *a1 = sub_10049710(*(_DWORD *)(dword_1025441C + 296)) * v1 + *a1;
    sub_10049720();
    sub_10034BA0(10.0, 0.043196544);
    result = 1;
    v3 = *a1 * 0.0005399567889980972;
    *a1 = v3 / v5;
  }
  return result;
}
// 10049710: using guessed type double __cdecl sub_10049710(_DWORD);
// 1025441C: using guessed type int dword_1025441C;

//----- (10034820) --------------------------------------------------------
bool __cdecl sub_10034820(float *a1, float *a2, float *a3, _BYTE *a4, _BYTE *a5, _BYTE *a6)
{
  bool v6; // bl@1
  float *v7; // eax@4
  float v9; // [sp+18h] [bp-38h]@1
  _BYTE *v10; // [sp+1Ch] [bp-34h]@1
  _BYTE *v11; // [sp+20h] [bp-30h]@1
  _BYTE *v12; // [sp+24h] [bp-2Ch]@1
  char v13; // [sp+28h] [bp-28h]@1
  char v14; // [sp+36h] [bp-1Ah]@2

  *a1 = 0.0;
  *a2 = 9.9999996e24;
  v6 = 0;
  v12 = a4;
  *a3 = 0.0;
  *a4 = 0;
  v10 = a5;
  v11 = a6;
  sub_10035680((int)&v13);
  sub_100346B0(&v9);
  if ( sub_10022650() )
  {
    sub_10049730();
    if ( !v14 )
    {
      if ( sub_10034BA0(300.0, 1.0) )
      {
        *a1 = sub_10049710(*(_DWORD *)(dword_1025441C + 296)) * *(float *)(dword_1025441C + 1220)
            + *(float *)(dword_1025441C + 1216);
        v7 = (float *)(dword_1025441C + 1224);
        *a2 = *(float *)(dword_1025441C + 1224);
        *a3 = *a1 / *v7;
        v6 = *(_BYTE *)(dword_1025441C + 1211) == 0;
        if ( !*(_BYTE *)(dword_1025441C + 1211) )
        {
          LODWORD(v9) &= 0x7FFFFFFFu;
          if ( v9 <= 1.0 )
          {
            if ( *(_BYTE *)(dword_1025441C + 288) )
              *v12 = 1;
          }
        }
      }
    }
    if ( v10 )
      *v10 = *(_BYTE *)(dword_1025441C + 1212);
    if ( v11 )
      *v11 = *(_BYTE *)(dword_1025441C + 821);
    sub_10049720();
  }
  return v6;
}
// 10049710: using guessed type double __cdecl sub_10049710(_DWORD);
// 1025441C: using guessed type int dword_1025441C;

//----- (100349A0) --------------------------------------------------------
bool __cdecl sub_100349A0(float *a1, _BYTE *a2)
{
  bool result; // al@2
  char v3; // [sp+7h] [bp-9h]@2
  char v4; // [sp+8h] [bp-8h]@2
  char v5; // [sp+Ch] [bp-4h]@2

  if ( sub_10022650() )
  {
    *a2 = *(_BYTE *)(dword_1025441C + 1212);
    result = sub_10034820((float *)&v5, (float *)&v4, a1, &v3, a2, 0);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1025441C: using guessed type int dword_1025441C;

//----- (100349F0) --------------------------------------------------------
double __cdecl sub_100349F0(float a1)
{
  float v2; // [sp+4h] [bp+4h]@1

  v2 = pow(a1 / 101325.0, 0.190228059887886);
  return (float)((1.0 - v2) * -44330.765625);
}

//----- (10034A20) --------------------------------------------------------
double __cdecl sub_10034A20(float a1, float a2, float a3, float a4, float a5)
{
  double v5; // st5@1
  double v6; // st4@1
  double v7; // st3@1
  double v8; // st2@1
  double v9; // st6@2
  double v10; // st7@5
  double v11; // st4@6
  double v12; // st3@6
  double v13; // rtt@9
  double v14; // st4@9
  double v15; // st7@9
  double result; // st7@10
  float v17; // [sp+0h] [bp-18h]@1
  float v18; // [sp+4h] [bp-14h]@1
  float v19; // [sp+1Ch] [bp+4h]@11
  float v20; // [sp+1Ch] [bp+4h]@11
  float v21; // [sp+20h] [bp+8h]@3
  float v22; // [sp+28h] [bp+10h]@9
  float v23; // [sp+2Ch] [bp+14h]@11

  v17 = a1 - a2;
  v18 = a3 - a2;
  v5 = v18;
  v6 = 273.1499938964844;
  v7 = a5;
  v8 = v17;
  if ( a4 == 9.9999996e24 )
  {
    v9 = 0.006500000134110451;
    if ( 9.9999996e24 == v7 )
    {
      v21 = 288.1499938964844 - v8 * 0.006500000134110451;
    }
    else
    {
      v21 = v7 - (v8 - v5) * 0.006500000134110451 + 273.1499938964844;
      v6 = 273.1499938964844;
    }
  }
  else
  {
    v9 = 0.006500000134110451;
    v21 = a4 + 273.1499938964844;
  }
  v10 = v17;
  if ( 9.9999996e24 == v7 )
  {
    v11 = v21;
    v12 = v21 - (v10 - v5) * -0.006500000134110451;
  }
  else
  {
    v12 = v6 + v7;
    v11 = v21;
  }
  v13 = v11;
  v14 = v10 - v5;
  v15 = v13;
  v22 = v14;
  if ( COERCE_FLOAT(LODWORD(v22) & 0x7FFFFFFF) >= 1.0 )
  {
    v19 = log(1.0 - v14 * v9 / (288.1499938964844 - v9 * v5));
    v23 = v12;
    v20 = a3
        - (v15 - v23) / 0.006500000134110451
        + (v23 * v17 - v21 * v18 - 288.1499938964844 * (v15 - v23) / -0.006500000134110451)
        / (-0.006500000134110451
         * v14)
        * v19;
    result = v20;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10034BA0) --------------------------------------------------------
int __cdecl sub_10034BA0(float a1, float a2)
{
  float *v2; // ecx@0
  double v3; // st7@1
  double v4; // st7@3
  bool v5; // c0@3
  bool v6; // c3@3
  int result; // eax@4

  v3 = a1;
  if ( (COERCE_UNSIGNED_INT(*v2) & 0x7F800000) != 2139095040
    && *v2 <= v3
    && (v4 = *v2, v5 = a2 < v4, v6 = a2 == v4, v3 = a2, v5 || v6) )
  {
    result = 1;
  }
  else
  {
    *v2 = v3;
    result = 0;
  }
  return result;
}

//----- (10034BF0) --------------------------------------------------------
double __cdecl sub_10034BF0(_BYTE *a1)
{
  _BYTE *v1; // esi@1
  bool v2; // al@1
  int v3; // edx@1
  double v4; // st7@5
  double v5; // st7@8
  float v6; // ST00_4@11
  double result; // st7@13
  double v8; // st7@14
  float v9; // [sp+4h] [bp-10h]@5
  float v10; // [sp+Ch] [bp-8h]@1
  float v11; // [sp+10h] [bp-4h]@5
  float v12; // [sp+18h] [bp+4h]@2
  float v13; // [sp+18h] [bp+4h]@4
  float v14; // [sp+18h] [bp+4h]@10
  float v15; // [sp+18h] [bp+4h]@14

  v1 = a1;
  *a1 = 0;
  v2 = sub_100358D0(*(_BYTE *)(dword_10254410 + 244), &v10);
  v3 = dword_1025441C;
  if ( !v2 )
  {
    v12 = 0.30000001;
    goto LABEL_13;
  }
  if ( *(_BYTE *)(dword_1025441C + 929) )
  {
    v13 = *(float *)(dword_1025441C + 948) + v10;
    if ( *(float *)(dword_1025441C + 964) + 305.0 >= v13 )
    {
      v12 = 0.30000001;
      goto LABEL_13;
    }
    v12 = v13 * 0.0005399567889980972 * *(float *)(dword_1025441C + 976);
    v11 = 0.0005399567889980972 * *(float *)(dword_1025441C + 944);
    v9 = v11;
    v4 = 1.0;
  }
  else
  {
    if ( *(_BYTE *)(dword_10254410 + 237) )
      v5 = 1.0;
    else
      v5 = 0.30000001;
    v11 = v5;
    v14 = v10 + 3048.0;
    v12 = v14 * 0.0005399567889980972 * 0.03492077067494392;
    v9 = 0.057602592;
    v4 = v11;
  }
  v6 = v4;
  if ( sub_10034BA0(v6, v9) )
  {
    *v1 = 1;
    v3 = dword_1025441C;
  }
LABEL_13:
  result = v12;
  if ( *(float *)(v3 + 84) < (double)v12 )
  {
    v8 = *(float *)(v3 + 84);
    *v1 = 0;
    v15 = v8;
    result = v15;
  }
  return result;
}
// 10254410: using guessed type int dword_10254410;
// 1025441C: using guessed type int dword_1025441C;

//----- (10034D30) --------------------------------------------------------
char __cdecl sub_10034D30(float *a1)
{
  int v1; // ST10_4@1
  double v2; // st7@1
  int v3; // ST14_4@1
  int v4; // ST1C_4@1
  int v5; // ST24_4@1
  double v6; // st7@6
  double v7; // st7@10
  double v8; // st7@15
  double v9; // st7@18
  float v10; // ST04_4@26
  char v11; // dl@28
  char result; // al@31
  float v13; // [sp+0h] [bp-24h]@1
  float v14; // [sp+4h] [bp-20h]@1
  float v15; // [sp+14h] [bp-10h]@1
  float v16; // [sp+1Ch] [bp-8h]@1

  v13 = *(float *)(dword_1025441C + 304);
  v1 = *(_DWORD *)(dword_1025441C + 64);
  v14 = *(float *)(dword_1025441C + 320);
  v2 = v13;
  v15 = *(float *)(dword_1025441C + 72);
  v3 = *(_DWORD *)(dword_1025441C + 68);
  v16 = *(float *)(dword_1025441C + 80);
  v4 = *(_DWORD *)(dword_1025441C + 76);
  v5 = *(_DWORD *)(dword_1025441C + 84);
  if ( (LODWORD(v13) & 0x7F800000) == 2139095040 || v2 > 25512548.0 )
  {
    v13 = 25512548.0;
  }
  else if ( v2 < -25512548.0 )
  {
    v13 = -25512548.0;
  }
  v6 = v14;
  if ( (LODWORD(v14) & 0x7F800000) == 2139095040 || v6 > 1028.8889 || v6 < -1028.8889 )
    v14 = 0.0;
  v7 = v16;
  if ( (LODWORD(v16) & 0x7F800000) == 2139095040 || v7 > 2.0 )
  {
    v16 = 2.0;
  }
  else if ( v7 < -2.0 )
  {
    v16 = -2.0;
  }
  v8 = 1.0;
  if ( *(_BYTE *)(dword_1025441C + 929) )
  {
    if ( (LODWORD(v15) & 0x7F800000) == 2139095040 || v15 > 1.0 )
      goto LABEL_25;
    v9 = v15;
  }
  else
  {
    v9 = v15;
    if ( (LODWORD(v15) & 0x7F800000) == 2139095040 || v9 > 0.30000001 )
    {
      v8 = 0.30000001;
      goto LABEL_25;
    }
  }
  if ( v9 >= 0.05760259181261063 )
    goto LABEL_26;
  v8 = 0.057602592;
LABEL_25:
  v15 = v8;
LABEL_26:
  v10 = sub_10049710(*(_DWORD *)(dword_1025441C + 296)) * v14 + v13;
  *a1 = v15 - v16 * v10;
  if ( v10 > 3704.0 )
    *a1 = 1.0;
  v11 = 0;
  if ( v15 + 0.009999999776482582 >= *a1 || *(_BYTE *)(dword_1025441C + 812) > *(_BYTE *)(dword_10254410 + 241) )
  {
    *a1 = v15;
    v11 = 1;
  }
  result = 1;
  if ( !*(_BYTE *)(dword_10254410 + 237) )
    result = v11;
  return result;
}
// 10049710: using guessed type double __cdecl sub_10049710(_DWORD);
// 10254410: using guessed type int dword_10254410;
// 1025441C: using guessed type int dword_1025441C;

//----- (10034F60) --------------------------------------------------------
char __cdecl sub_10034F60(float *a1)
{
  float v1; // ST00_4@1
  double v2; // st7@1
  int v3; // ST04_4@1
  int v4; // ST0C_4@1
  int v5; // ST08_4@1
  int v6; // ST18_4@1
  double v7; // st5@7
  double v8; // st6@7
  double v9; // st4@11
  float v10; // ST14_4@15
  float v11; // ST00_4@16
  float v12; // ST00_4@16
  char result; // al@17
  float v14; // [sp+10h] [bp-Ch]@1
  float v15; // [sp+10h] [bp-Ch]@8
  float v16; // [sp+14h] [bp-8h]@1

  v1 = *(float *)(dword_1025441C + 688);
  v2 = v1;
  v3 = *(_DWORD *)(dword_1025441C + 64);
  v4 = *(_DWORD *)(dword_1025441C + 72);
  v5 = *(_DWORD *)(dword_1025441C + 68);
  v16 = *(float *)(dword_1025441C + 80);
  v14 = *(float *)(dword_1025441C + 76);
  v6 = *(_DWORD *)(dword_1025441C + 84);
  if ( (LODWORD(v1) & 0x7F800000) == 2139095040 || v2 > 1028.8889 || v2 < 0.0 )
    v2 = (float)0.0;
  if ( (LODWORD(v14) & 0x7F800000) == 2139095040 || v14 > 2.0 )
  {
    v8 = 2.0;
    v15 = 2.0;
    goto LABEL_10;
  }
  v7 = v14;
  v8 = 2.0;
  if ( v14 < 0.05760259181261063 )
  {
    v15 = 0.057602592;
LABEL_10:
    v7 = v15;
  }
  v9 = v16;
  if ( (LODWORD(v16) & 0x7F800000) == 2139095040 || v9 > v8 )
  {
    v10 = v8;
    v9 = v10;
  }
  else if ( v9 < -2.0 )
  {
    v9 = (float)-2.0;
  }
  v11 = v2
      * v9
      * ((double)(unsigned int)(*(_DWORD *)(dword_1025441C + 36) - *(_DWORD *)(dword_1025441C + 68))
       / (double)1000);
  v12 = v7 + v11;
  *a1 = v12;
  if ( v12 < 1.990000009536743 )
  {
    result = 0;
  }
  else
  {
    *a1 = v8;
    result = 1;
  }
  return result;
}
// 1025441C: using guessed type int dword_1025441C;

//----- (100350D0) --------------------------------------------------------
double __cdecl sub_100350D0(float a1)
{
  double v1; // st7@1
  double result; // st7@4
  float v3; // [sp+4h] [bp-4h]@1

  v1 = a1;
  v3 = *(float *)(dword_1025441C + 48);
  if ( (LODWORD(a1) & 0x7F800000) == 2139095040 || v1 > 10.0 )
  {
    result = (float)10.0;
  }
  else if ( v3 <= v1 )
  {
    result = a1;
  }
  else
  {
    result = v3;
  }
  return result;
}
// 1025441C: using guessed type int dword_1025441C;

//----- (10035140) --------------------------------------------------------
char __cdecl sub_10035140(float *a1)
{
  float v1; // ST08_4@1
  double v2; // st7@1
  int v3; // ST10_4@1
  int v4; // ST18_4@1
  int v5; // ST14_4@1
  int v6; // ST24_4@1
  double v7; // st6@5
  double v8; // st5@5
  float v9; // ST1C_4@8
  double v10; // st5@9
  double v11; // st4@9
  float v12; // ST20_4@12
  float v13; // ST0C_4@13
  double v14; // st7@13
  char result; // al@17
  float v16; // [sp+0h] [bp-20h]@13
  float v17; // [sp+4h] [bp-1Ch]@5
  float v18; // [sp+14h] [bp-Ch]@1
  float v19; // [sp+18h] [bp-8h]@1

  v1 = *(float *)(dword_1025441C + 688);
  v2 = v1;
  v3 = *(_DWORD *)(dword_1025441C + 64);
  v4 = *(_DWORD *)(dword_1025441C + 72);
  v5 = *(_DWORD *)(dword_1025441C + 68);
  v19 = *(float *)(dword_1025441C + 80);
  v18 = *(float *)(dword_1025441C + 76);
  v6 = *(_DWORD *)(dword_1025441C + 84);
  if ( (LODWORD(v1) & 0x7F800000) == 2139095040 || v2 > 1028.8889 || v2 < 0.0 )
    v2 = (float)0.0;
  v17 = *(float *)(dword_1025441C + 48);
  v7 = v18;
  v8 = 10.0;
  if ( (LODWORD(v18) & 0x7F800000) == 2139095040 || v7 > 10.0 || (v8 = v17, v17 > v7) )
  {
    v9 = v8;
    v7 = v9;
  }
  v10 = v19;
  v11 = 2.0;
  if ( (LODWORD(v19) & 0x7F800000) == 2139095040 || v10 > 2.0 || (v11 = -2.0, v10 < -2.0) )
  {
    v12 = v11;
    v10 = v12;
  }
  v16 = v2
      * v10
      * ((double)(unsigned int)(*(_DWORD *)(dword_1025441C + 36) - *(_DWORD *)(dword_1025441C + 68))
       / (double)1000);
  v13 = v7 + v16;
  v14 = v13;
  *a1 = v13;
  if ( (LODWORD(v16) >> 31) & 1 && *(float *)(dword_1025441C + 72) >= v14 )
  {
    result = 1;
    *a1 = *(float *)(dword_1025441C + 72);
  }
  else if ( (LODWORD(v16) >> 31) & 1 || *(float *)(dword_1025441C + 72) > v14 )
  {
    result = 0;
  }
  else
  {
    *a1 = *(float *)(dword_1025441C + 72);
    result = 1;
  }
  return result;
}
// 1025441C: using guessed type int dword_1025441C;

//----- (100352E0) --------------------------------------------------------
char __cdecl sub_100352E0(float *a1)
{
  float v1; // ST04_4@1
  double v2; // st7@1
  int v3; // ST0C_4@1
  int v4; // ST14_4@1
  int v5; // ST10_4@1
  int v6; // ST20_4@1
  double v7; // st5@7
  double v8; // st6@7
  double v9; // st6@13
  float v10; // ST1C_4@15
  float v11; // ST08_4@16
  double v12; // st7@16
  char result; // al@20
  float v14; // [sp+0h] [bp-20h]@16
  float v15; // [sp+14h] [bp-Ch]@1
  float v16; // [sp+14h] [bp-Ch]@8
  float v17; // [sp+18h] [bp-8h]@1

  v1 = *(float *)(dword_1025441C + 688);
  v2 = v1;
  v3 = *(_DWORD *)(dword_1025441C + 64);
  v4 = *(_DWORD *)(dword_1025441C + 72);
  v5 = *(_DWORD *)(dword_1025441C + 68);
  v17 = *(float *)(dword_1025441C + 80);
  v15 = *(float *)(dword_1025441C + 76);
  v6 = *(_DWORD *)(dword_1025441C + 84);
  if ( (LODWORD(v1) & 0x7F800000) == 2139095040 || v2 > 1028.8889 || v2 < 0.0 )
    v2 = (float)0.0;
  if ( (LODWORD(v15) & 0x7F800000) == 2139095040 || v15 > 2.0 )
  {
    v8 = 2.0;
    v16 = 2.0;
    goto LABEL_10;
  }
  v7 = v15;
  v8 = 2.0;
  if ( v15 < 0.05760259181261063 )
  {
    v16 = 0.057602592;
LABEL_10:
    v7 = v16;
  }
  if ( (LODWORD(v17) & 0x7F800000) != 2139095040 && v17 <= v8 )
  {
    v9 = v17;
    if ( v17 >= -2.0 )
      goto LABEL_16;
    v8 = -2.0;
  }
  v10 = v8;
  v9 = v10;
LABEL_16:
  v14 = v2
      * v9
      * ((double)(unsigned int)(*(_DWORD *)(dword_1025441C + 36) - *(_DWORD *)(dword_1025441C + 68))
       / (double)1000);
  v11 = v7 + v14;
  v12 = v11;
  *a1 = v11;
  if ( (LODWORD(v14) >> 31) & 1 && v12 <= 1.01 )
  {
    result = 1;
    *a1 = 1.0;
  }
  else if ( (LODWORD(v14) >> 31) & 1 || v12 < 0.9900000095367432 )
  {
    result = 0;
  }
  else
  {
    result = 1;
    *a1 = 1.0;
  }
  return result;
}
// 1025441C: using guessed type int dword_1025441C;

//----- (10035490) --------------------------------------------------------
unsigned int __cdecl sub_10035490(char a1, _BYTE *a2, float *a3)
{
  _BYTE *v3; // esi@1
  float *v4; // edi@1
  int v5; // edx@1
  int v6; // ST14_4@1
  int v7; // ST18_4@1
  int v8; // ST1C_4@1
  int v9; // ST20_4@1
  double v10; // st7@3
  char v11; // bl@6
  unsigned int result; // eax@33
  float v13; // [sp+24h] [bp-4h]@1

  v3 = a2;
  *a2 = 1;
  v4 = a3;
  *a3 = 2.0;
  v5 = *(_DWORD *)(dword_1025441C + 64);
  v6 = *(_DWORD *)(dword_1025441C + 68);
  v7 = *(_DWORD *)(dword_1025441C + 72);
  v8 = *(_DWORD *)(dword_1025441C + 76);
  v9 = *(_DWORD *)(dword_1025441C + 80);
  v13 = *(float *)(dword_1025441C + 84);
  *(float *)&a2 = v13;
  if ( (LODWORD(v13) & 0x7F800000) == 2139095040 || v13 > 4.0 )
  {
    v13 = 4.0;
    v10 = 4.0;
  }
  else
  {
    v10 = 4.0;
    if ( v13 < 0.30000001 )
      v13 = 0.30000001;
  }
  v11 = a1;
  if ( !a1 && *(_BYTE *)(dword_1025441C + 99) == a1 )
    v11 = 1;
  if ( BYTE3(v5) == 6 )
  {
    if ( (unsigned __int8)v11 < *(_BYTE *)(dword_1025441C + 94) && *(_BYTE *)(dword_1025441C + 816) )
      v11 = *(_BYTE *)(dword_1025441C + 94);
    if ( -1.0 != *(float *)(dword_1025441C + 116) )
      v11 = 5;
    switch ( v11 )
    {
      case 4:
        *v4 = sub_10034BF0(&a1);
        *v3 = 4;
        break;
      case 3:
        *v4 = 0.30000001;
        *v3 = 3;
        break;
      case 2:
        *v4 = 1.0;
        *v3 = 2;
        break;
      case 0:
        *v4 = v10;
        *v3 = 0;
        break;
      case 5:
        *v4 = sub_100350D0(*(float *)(dword_1025441C + 116));
        *v3 = 5;
        break;
      default:
        break;
    }
LABEL_30:
    if ( v11 == 5 )
      goto LABEL_33;
    goto LABEL_31;
  }
  if ( BYTE3(v5) == 2 )
  {
    sub_100352E0(v4);
    *v3 = 2;
    goto LABEL_30;
  }
  if ( BYTE3(v5) == 4 )
  {
    sub_10034D30(v4);
    *v3 = 4;
    goto LABEL_30;
  }
  if ( BYTE3(v5) == 5 )
  {
    sub_10035140(v4);
    *v3 = 5;
    goto LABEL_30;
  }
  sub_10034F60(v4);
  if ( v11 )
  {
    *v3 = 1;
    goto LABEL_30;
  }
  *v3 = 0;
LABEL_31:
  if ( v13 + 0.009999999776482582 < *v4 )
  {
    *v4 = v13;
    *v3 = *(_BYTE *)(dword_1025441C + 1201);
  }
LABEL_33:
  result = *v3;
  if ( result >= 6 )
    result = 1;
  *v3 = result;
  return result;
}
// 1025441C: using guessed type int dword_1025441C;

//----- (10035680) --------------------------------------------------------
char __cdecl sub_10035680(int a1)
{
  char result; // al@1
  int v2; // ecx@2
  char v3; // al@4
  unsigned __int8 v4; // al@16

  *(_DWORD *)(a1 + 16) = 0x3FFFF;
  *(_BYTE *)a1 = -1;
  *(_DWORD *)(a1 + 20) = 0x3FFFF;
  *(_BYTE *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_BYTE *)(a1 + 2) = 1;
  *(_BYTE *)(a1 + 3) = 1;
  *(_BYTE *)(a1 + 4) = 6;
  *(_BYTE *)(a1 + 5) = -1;
  *(_BYTE *)(a1 + 6) = 0;
  *(_BYTE *)(a1 + 7) = -1;
  *(_BYTE *)(a1 + 9) = 0;
  *(_BYTE *)(a1 + 13) = 0;
  *(_BYTE *)(a1 + 10) = -1;
  *(_BYTE *)(a1 + 11) = 0;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 12) = 0;
  *(_BYTE *)(a1 + 14) = 1;
  *(_BYTE *)(a1 + 15) = 0;
  result = sub_10022650();
  if ( result )
  {
    sub_10049730();
    *(_BYTE *)(a1 + 8) = *(_BYTE *)(dword_1025441C + 815);
    *(_BYTE *)(a1 + 4) = *(_BYTE *)(dword_1025441C + 94);
    *(_BYTE *)(a1 + 11) = *(_BYTE *)(dword_1025441C + 97);
    *(_BYTE *)(a1 + 1) = *(_BYTE *)(dword_10254410 + 239);
    *(_BYTE *)(a1 + 15) = *(_BYTE *)(dword_1025441C + 826);
    strncpy((char *)(a1 + 24), (const char *)(dword_1025441C + 872), 0xCu);
    *(_BYTE *)(a1 + 35) = 0;
    *(_BYTE *)(a1 + 6) = *(_BYTE *)(dword_1025441C + 784);
    *(_BYTE *)(a1 + 14) = 0;
    v2 = dword_1025441C;
    if ( *(_BYTE *)(dword_1025441C + 669) && !*(_BYTE *)(dword_1025441C + 667)
      || (v3 = *(_BYTE *)(dword_1025441C + 159)) != 0
      && *(_BYTE *)(dword_1025441C + 667)
      && !*(_BYTE *)(dword_1025441C + 661)
      && (v3 != 2 || -1.0 == *(float *)(dword_1025441C + 116))
      || !*(_BYTE *)(dword_1025441C + 672) )
    {
      *(_BYTE *)(a1 + 14) = 1;
      v2 = dword_1025441C;
    }
    else if ( *(_BYTE *)(dword_1025441C + 101) == 4
           && *(_BYTE *)(dword_1025441C + 812) >= *(_BYTE *)(dword_10254410 + 241)
           && !*(_BYTE *)(dword_1025441C + 89)
           && -1.0 == *(float *)(dword_1025441C + 116) )
    {
      *(_BYTE *)(a1 + 14) = 1;
      v2 = dword_1025441C;
    }
    *(_BYTE *)(a1 + 9) = *(_BYTE *)(v2 + 816);
    *(_BYTE *)(a1 + 5) = *(_BYTE *)(dword_10254410 + 241);
    v4 = *(_BYTE *)(a1 + 9) - 1;
    *(_BYTE *)(a1 + 10) = *(_BYTE *)(dword_10254410 + 244);
    if ( v4 > 2u )
    {
      *(_BYTE *)(a1 + 9) = 0;
      *(_DWORD *)(a1 + 16) = 0x3FFFF;
      *(_DWORD *)(a1 + 20) = 0x3FFFF;
      *(_BYTE *)(a1 + 12) = 0;
      *(_BYTE *)a1 = -1;
      *(_BYTE *)(a1 + 2) = 1;
      *(_BYTE *)(a1 + 3) = 1;
      *(_BYTE *)(a1 + 7) = -1;
      *(_BYTE *)(a1 + 14) = 1;
      result = sub_10049720();
    }
    else
    {
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(dword_1025441C + 836);
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(dword_1025441C + 840);
      *(_BYTE *)a1 = *(_BYTE *)(dword_1025441C + 812);
      *(_BYTE *)(a1 + 13) = *(_BYTE *)(dword_1025441C + 825);
      if ( *(_DWORD *)(dword_1025441C + 892) )
        *(_BYTE *)(a1 + 3) = 0;
      else
        *(_BYTE *)(a1 + 3) = *(_BYTE *)(dword_1025441C + 288);
      *(_BYTE *)(a1 + 2) = *(_BYTE *)(dword_1025441C + 288);
      *(_BYTE *)(a1 + 7) = *(_BYTE *)(dword_1025441C + 813);
      *(_BYTE *)(a1 + 12) = *(_BYTE *)(dword_10254410 + 4);
      result = sub_10049720();
    }
  }
  return result;
}
// 10254410: using guessed type int dword_10254410;
// 1025441C: using guessed type int dword_1025441C;

//----- (100358D0) --------------------------------------------------------
bool __cdecl sub_100358D0(unsigned __int8 a1, float *a2)
{
  unsigned __int16 v2; // di@1
  int v3; // ecx@5
  __int16 i; // ax@5
  int v5; // eax@6
  bool v6; // cf@7
  bool result; // al@10

  *a2 = 0.0;
  v2 = 0;
  if ( *(_BYTE *)(dword_1025441C + 812) == -1
    || *(_WORD *)(dword_1025441C + 828) == -1
    || 9.9999996e24 == *(float *)(dword_1025441C + 552)
    || 9.9999996e24 == *(float *)(dword_1025441C + 568) )
  {
    result = 0;
  }
  else
  {
    *a2 = *(float *)(dword_1025441C + 552);
    *a2 = sub_10049710(*(_DWORD *)(dword_1025441C + 544)) * *(float *)(dword_1025441C + 568) + *a2;
    v3 = dword_10254414;
    for ( i = *(_WORD *)(44 * *(_WORD *)(dword_1025441C + 828) + dword_10254414 + 332);
          i != -1;
          i = *(_WORD *)(v5 + dword_10254414 + 332) )
    {
      v5 = 44 * i;
      if ( *(_BYTE *)(v5 + v3 + 324) > a1 )
        break;
      v6 = v2 < 0x1F4u;
      if ( v2 >= 0x1F4u )
        goto LABEL_10;
      ++v2;
      *a2 = *(float *)(v5 + v3 + 336) + *a2;
      v3 = dword_10254414;
    }
    v6 = v2 < 0x1F4u;
LABEL_10:
    result = v6;
  }
  return result;
}
// 10049710: using guessed type double __cdecl sub_10049710(_DWORD);
// 10254414: using guessed type int dword_10254414;
// 1025441C: using guessed type int dword_1025441C;

//----- (100359D0) --------------------------------------------------------
double __cdecl sub_100359D0(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 != v4 && (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v11 = v2 + v9;
        result = v11;
      }
      else
      {
        v10 = v4;
        result = v10;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10035A70) --------------------------------------------------------
int __cdecl sub_10035A70(signed int a1, signed int a2)
{
  int result; // eax@2

  if ( a2 > 0 )
  {
    result = a2 * (a1 / a2);
    if ( a1 == result )
    {
      result = a1;
    }
    else if ( a1 < 0 )
    {
      result -= a2;
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10035AB0) --------------------------------------------------------
double __cdecl sub_10035AB0(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 == v4 || (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v10 = v4;
        result = v10;
      }
      else
      {
        v11 = v9 - v2;
        result = v11;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10035B50) --------------------------------------------------------
double __cdecl sub_10035B50(double a1, double a2)
{
  double result; // st7@1
  double v3; // [sp+0h] [bp-8h]@2

  result = 0.0;
  if ( a2 > 0.0 )
  {
    v3 = a2 + a2;
    result = fmod(a1, v3);
    if ( a2 > result )
    {
      if ( -a2 > result )
        result = result + v3;
    }
    else
    {
      result = result - v3;
    }
  }
  return result;
}

//----- (10035BB0) --------------------------------------------------------
double __cdecl sub_10035BB0(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@5
  float v6; // [sp+8h] [bp+8h]@3
  float v7; // [sp+8h] [bp+8h]@3
  float v8; // [sp+8h] [bp+8h]@4
  float v9; // [sp+8h] [bp+8h]@6

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v6 = v2 + v2;
    v4 = v6;
    v7 = a1 - (double)(signed int)(a1 / v6) * v6;
    if ( v7 < v2 )
    {
      v5 = v2;
      result = v7;
      if ( -v5 > v7 )
      {
        v9 = result + v4;
        result = v9;
      }
    }
    else
    {
      v8 = v7 - v4;
      result = v8;
    }
  }
  else
  {
    result = 0.0;
  }
  return result;
}

//----- (10035C30) --------------------------------------------------------
void __cdecl sub_10035C30(double a1)
{
  sub_10035B50(a1, 3.1415926535898);
}

//----- (10035C50) --------------------------------------------------------
double __cdecl sub_10035C50(float a1)
{
  double result; // st7@3

  if ( a1 == -3.141592741012573 || a1 == 3.141592741012573 )
    result = -3.1415925;
  else
    result = sub_10035BB0(a1, 3.1415927);
  return result;
}

//----- (10035C90) --------------------------------------------------------
double __cdecl sub_10035C90(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  float v4; // [sp+8h] [bp+8h]@5

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    if ( a1 < 0.0 )
      a2 = -v2;
    v4 = v2 * (double)(signed int)((a1 + a2 * 0.5) / v2);
    result = v4;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10035D00) --------------------------------------------------------
bool __cdecl sub_10035D00(float a1, float a2, float a3)
{
  float v4; // [sp+8h] [bp+4h]@1
  float v5; // [sp+8h] [bp+4h]@1

  v4 = a1 - a2;
  v5 = fabs(sub_10035C50(v4));
  return a3 >= (double)v5;
}

//----- (10035D40) --------------------------------------------------------
int __cdecl sub_10035D40(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(float *)a3 = *(float *)a1 + *(float *)a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) + *(float *)(a2 + 4);
  *(float *)(a3 + 8) = *(float *)(a1 + 8) + *(float *)(a2 + 8);
  return result;
}

//----- (10035D70) --------------------------------------------------------
int __cdecl sub_10035D70(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a2;
  *(float *)a3 = *(float *)a2 * a1;
  *(float *)(a3 + 4) = *(float *)(a2 + 4) * a1;
  *(float *)(a3 + 8) = a1 * *(float *)(a2 + 8);
  return result;
}

//----- (10035DA0) --------------------------------------------------------
int __cdecl sub_10035DA0(unsigned __int8 a1, unsigned int a2)
{
  return dword_100C6400[a1 ^ (unsigned __int8)a2] ^ (a2 >> 8);
}
// 100C6400: using guessed type int dword_100C6400[];

//----- (10035DC0) --------------------------------------------------------
unsigned int __cdecl sub_10035DC0(unsigned int *a1, signed int a2, unsigned int a3)
{
  unsigned int *v3; // edx@1
  unsigned int result; // eax@1
  signed int i; // esi@1
  unsigned int v6; // edi@5
  unsigned int v7; // eax@6
  unsigned int v8; // eax@6
  unsigned int v9; // eax@6
  unsigned int v10; // eax@6
  unsigned int v11; // ecx@6
  unsigned int v12; // ecx@6
  unsigned int v13; // ecx@6

  v3 = a1;
  result = a3;
  for ( i = a2; i; --i )
  {
    if ( !((unsigned __int8)v3 & 3) )
      break;
    result = dword_100C6400[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    v3 = (unsigned int *)((char *)v3 + 1);
  }
  if ( i >= 8 )
  {
    v6 = (unsigned int)i >> 3;
    do
    {
      v7 = dword_100C6400[(unsigned __int8)result ^ (unsigned __int8)*v3] ^ (result >> 8);
      v8 = dword_100C6400[(unsigned __int8)v7 ^ (unsigned __int8)(*(_WORD *)v3 >> 8)] ^ (v7 >> 8);
      v9 = dword_100C6400[(unsigned __int8)v8 ^ (unsigned __int8)(*v3 >> 16)] ^ (v8 >> 8);
      v10 = dword_100C6400[(unsigned __int8)v9 ^ (*v3 >> 24)] ^ (v9 >> 8);
      v3 += 2;
      v11 = dword_100C6400[(unsigned __int8)v10 ^ (unsigned __int8)*(v3 - 1)] ^ (v10 >> 8);
      v12 = dword_100C6400[(unsigned __int8)v11 ^ (unsigned __int8)(*((_WORD *)v3 - 2) >> 8)] ^ (v11 >> 8);
      v13 = dword_100C6400[(unsigned __int8)v12 ^ (unsigned __int8)(*(v3 - 1) >> 16)] ^ (v12 >> 8);
      i -= 8;
      --v6;
      result = dword_100C6400[(unsigned __int8)v13 ^ (*(v3 - 1) >> 24)] ^ (v13 >> 8);
    }
    while ( v6 );
  }
  for ( ; i > 0; v3 = (unsigned int *)((char *)v3 + 1) )
  {
    result = dword_100C6400[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    --i;
  }
  return result;
}
// 100C6400: using guessed type int dword_100C6400[];

//----- (10037E8E) --------------------------------------------------------
int __cdecl sub_10037E8E(int a1, int a2, char a3)
{
  return vscan_fn(sub_1003EFBA, a2, 0, &a3);
}
// 10037E26: using guessed type int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100394D5) --------------------------------------------------------
int __cdecl sub_100394D5(int a1, FILE *a2)
{
  FILE *v2; // esi@1
  int v3; // eax@1
  unsigned int v5; // eax@9
  int v6; // eax@15
  char *v7; // edi@15
  signed __int32 v8; // edi@15
  _BYTE *v9; // eax@20
  __int64 v10; // rax@23
  _WORD *v11; // [sp+4h] [bp-4h]@9

  v2 = a2;
  a2 = (FILE *)_fileno(a2);
  v3 = v2->_flag;
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    v2->_flag |= 0x20u;
    return -1;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v3 & 1 )
  {
    v2->_cnt = 0;
    if ( !(v3 & 0x10) )
    {
      v2->_flag = v3 | 0x20;
      return -1;
    }
    v2->_ptr = v2->_base;
    v2->_flag = v3 & 0xFFFFFFFE;
  }
  v5 = v2->_flag & 0xFFFFFFEF | 2;
  v2->_flag = v5;
  v2->_cnt = 0;
  v11 = 0;
  if ( !(v5 & 0x10C)
    && ((void **)v2 != sub_10042C1E() + 8 && (void **)v2 != sub_10042C1E() + 16 || !sub_10042BC0((signed int)a2)) )
  {
    _getbuf(v2);
  }
  if ( v2->_flag & 0x108 )
  {
    v6 = (int)v2->_base;
    v7 = v2->_ptr;
    v2->_ptr = (char *)(v6 + 1);
    v8 = (signed __int32)&v7[-v6];
    v2->_cnt = v2->_bufsiz - 1;
    if ( v8 <= 0 )
    {
      if ( a2 == (FILE *)-1 || a2 == (FILE *)-2 )
        v9 = &unk_100DA340;
      else
        v9 = (_BYTE *)(dword_102554A0[(signed int)a2 >> 5] + (((unsigned __int8)a2 & 0x1F) << 6));
      if ( v9[4] & 0x20 )
      {
        v10 = _lseeki64((int)a2, 0i64, 2);
        if ( (HIDWORD(v10) & (unsigned int)v10) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v11 = sub_10042AA0((int)a2, v6, v8);
    }
    *v2->_base = a1;
  }
  else
  {
    v8 = 1;
    v11 = sub_10042AA0((int)a2, (int)&a1, 1u);
  }
  if ( v11 != (_WORD *)v8 )
  {
LABEL_27:
    v2->_flag |= 0x20u;
    return -1;
  }
  return (unsigned __int8)a1;
}
// 10042B7C: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 102554A0: using guessed type int dword_102554A0[];

//----- (1003A06A) --------------------------------------------------------
int __cdecl sub_1003A06A(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1024624C = a1;
  return result;
}
// 1024624C: using guessed type int dword_1024624C;

//----- (1003B877) --------------------------------------------------------
signed int __cdecl sub_1003B877(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_10246578 )
  {
    *a1 = dword_10246578;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1003A170: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10246578: using guessed type int dword_10246578;

//----- (1003B8AE) --------------------------------------------------------
signed int __cdecl sub_1003B8AE(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_10246578 )
  {
    *a1 = dword_10246584;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1003A170: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10246578: using guessed type int dword_10246578;
// 10246584: using guessed type int dword_10246584;

//----- (1003C4F4) --------------------------------------------------------
void sub_1003C4F4()
{
  void **v0; // esi@1
  void *v1; // edi@2
  unsigned int i; // eax@3

  v0 = (void **)dword_102554A0;
  do
  {
    v1 = *v0;
    if ( *v0 )
    {
      for ( i = (unsigned int)v1 + 2048; (unsigned int)v1 < i; i = (unsigned int)*v0 + 2048 )
      {
        if ( *((_DWORD *)v1 + 2) )
          DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
        v1 = (char *)v1 + 64;
      }
      free(*v0);
      *v0 = 0;
    }
    ++v0;
  }
  while ( (signed int)v0 < (signed int)&dword_102555A0 );
}
// 102554A0: using guessed type int dword_102554A0[];
// 102555A0: using guessed type int dword_102555A0;

//----- (1003C9A1) --------------------------------------------------------
int (*sub_1003C9A1())(void)
{
  int (*result)(void); // eax@1
  int (**v1)(void); // esi@1

  result = (int (*)(void))&unk_100D8310;
  v1 = (int (**)(void))&unk_100D8310;
  if ( &unk_100D8310 < &unk_100D8310 )
  {
    do
    {
      result = *v1;
      if ( *v1 )
        result = (int (*)(void))result();
      ++v1;
    }
    while ( v1 < (int (**)(void))&unk_100D8310 );
  }
  return result;
}

//----- (1003C9C5) --------------------------------------------------------
void __cdecl sub_1003C9C5()
{
  void (**v0)(void); // esi@1

  v0 = (void (**)(void))&unk_100D8318;
  if ( &unk_100D8318 < &unk_100D8318 )
  {
    do
    {
      if ( *v0 )
        (*v0)();
      ++v0;
    }
    while ( v0 < (void (**)(void))&unk_100D8318 );
  }
}

//----- (1003EFBA) --------------------------------------------------------
int __cdecl sub_1003EFBA(FILE *a1, int a2, struct localeinfo_struct *a3, int a4)
{
  unsigned __int8 *v4; // edi@1
  int result; // eax@2
  int *v6; // edi@7
  _BYTE *v7; // eax@7
  int *v8; // edi@12
  _BYTE *v9; // eax@12
  unsigned __int8 v10; // al@16
  unsigned __int8 *v11; // edi@17
  int v12; // eax@19
  _WORD *v13; // esi@24
  int v14; // ebx@25
  int v15; // eax@25
  int v16; // ST10_4@25
  int v17; // ecx@25
  int v18; // eax@35
  unsigned __int8 v19; // al@59
  signed int v20; // ebx@62
  int v21; // eax@65
  int v22; // ecx@69
  int v23; // edi@79
  signed int v24; // ebx@82
  int v25; // ebx@84
  int i; // eax@90
  int v27; // eax@91
  int v28; // ecx@92
  int v29; // eax@96
  int j; // eax@98
  int v31; // eax@99
  int v32; // ecx@100
  int v33; // eax@106
  int v34; // ecx@107
  int v35; // ecx@108
  int v36; // eax@112
  int k; // eax@115
  int v38; // eax@116
  int v39; // ecx@117
  void *v40; // ST0C_4@124
  _WORD *v41; // ST08_4@124
  int v42; // ST04_4@124
  void (__cdecl *v43)(int, _WORD *, void *, struct localeinfo_struct *); // eax@124
  _WORD *v44; // edi@129
  int v45; // ST10_4@130
  int v46; // eax@132
  signed int v47; // eax@133
  _BYTE *v48; // edi@156
  unsigned __int8 *v49; // esi@156
  unsigned __int8 v50; // dl@159
  unsigned __int8 v51; // al@165
  unsigned int v52; // edi@168
  int v53; // edx@168
  unsigned int v54; // ecx@172
  unsigned int v55; // eax@172
  unsigned __int8 v56; // al@173
  int v57; // eax@181
  int v58; // ecx@181
  int v59; // eax@219
  int v60; // ST10_4@219
  int v61; // ecx@219
  unsigned int v62; // esi@222
  int v63; // eax@225
  int v64; // ST10_4@225
  int v65; // eax@238
  int v66; // ST10_4@238
  int v67; // ecx@238
  int v68; // edi@241
  int v69; // eax@244
  int v70; // ST10_4@244
  int v71; // ebx@265
  int v72; // eax@265
  int v73; // eax@267
  int v74; // ecx@267
  bool v75; // zf@275
  int v76; // [sp-4h] [bp-80h]@18
  int v77; // [sp-4h] [bp-80h]@94
  int v78; // [sp-4h] [bp-80h]@143
  int v79; // [sp-4h] [bp-80h]@266
  _WORD **v80; // [sp+Ch] [bp-70h]@0
  struct localeinfo_struct Locale; // [sp+10h] [bp-6Ch]@16
  int v82; // [sp+18h] [bp-64h]@288
  char v83; // [sp+1Ch] [bp-60h]@287
  wchar_t DstCh[2]; // [sp+20h] [bp-5Ch]@1
  _WORD **v85; // [sp+24h] [bp-58h]@1
  int v86; // [sp+28h] [bp-54h]@24
  char SrcCh; // [sp+2Ch] [bp-50h]@143
  char v88; // [sp+2Dh] [bp-4Fh]@144
  int v89; // [sp+30h] [bp-4Ch]@1
  int v90; // [sp+34h] [bp-48h]@24
  int v91; // [sp+38h] [bp-44h]@1
  unsigned __int8 v92; // [sp+3Fh] [bp-3Dh]@24
  int v93; // [sp+40h] [bp-3Ch]@16
  _WORD *v94; // [sp+44h] [bp-38h]@58
  unsigned __int64 v95; // [sp+48h] [bp-34h]@36
  int v96; // [sp+50h] [bp-2Ch]@24
  unsigned __int8 *v97; // [sp+54h] [bp-28h]@1
  void *v98; // [sp+58h] [bp-24h]@1
  int v99; // [sp+5Ch] [bp-20h]@62
  int v100; // [sp+60h] [bp-1Ch]@24
  char v101; // [sp+64h] [bp-18h]@24
  char v102; // [sp+65h] [bp-17h]@24
  char v103; // [sp+66h] [bp-16h]@24
  char v104; // [sp+67h] [bp-15h]@16
  FILE *v105; // [sp+68h] [bp-14h]@1
  char v106; // [sp+6Eh] [bp-Eh]@24
  char v107; // [sp+6Fh] [bp-Dh]@24
  int v108; // [sp+70h] [bp-Ch]@24
  char v109; // [sp+77h] [bp-5h]@24
  int v110; // [sp+78h] [bp-4h]@1
  char v111; // [sp+7Fh] [bp+3h]@24
  int v112; // [sp+80h] [bp+4h]@16
  char v113; // [sp+84h] [bp+8h]@1
  char v114[11]; // [sp+1E4h] [bp+168h]@140
  char v115; // [sp+1EFh] [bp+173h]@159

  v4 = (unsigned __int8 *)a2;
  v85 = (_WORD **)a4;
  v105 = a1;
  v97 = (unsigned __int8 *)a2;
  v98 = &v113;
  v89 = 350;
  v91 = 0;
  *(_DWORD *)DstCh = 0;
  v110 = 0;
  if ( !a2 || !a1 )
    goto LABEL_294;
  if ( a1->_flag & 0x40 )
    goto LABEL_16;
  if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
  {
    v7 = &unk_100DA340;
  }
  else
  {
    v6 = &dword_102554A0[_fileno(a1) >> 5];
    v7 = (_BYTE *)(*v6 + ((_fileno(a1) & 0x1F) << 6));
  }
  if ( v7[36] & 0x7F
    || (_fileno(a1) == -1 || _fileno(a1) == -2 ? (v9 = &unk_100DA340) : (v8 = &dword_102554A0[_fileno(a1) >> 5],
                                                                         v9 = (_BYTE *)(*v8 + ((_fileno(a1) & 0x1F) << 6))),
        v9[36] & 0x80) )
  {
LABEL_294:
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v4 = v97;
LABEL_16:
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a3);
  v10 = *v4;
  v75 = *v4 == 0;
  v104 = 0;
  v112 = 0;
  v93 = 0;
  if ( v75 )
    goto LABEL_289;
  v11 = v97;
  while ( 2 )
  {
    if ( isspace(v10) )
    {
      --v112;
      v12 = _whiteout(v105);
      if ( v12 != -1 )
        sub_1004556C(v12, v105);
      do
        ++v11;
      while ( isspace(*v11) );
      goto LABEL_273;
    }
    if ( *v11 != 37 )
    {
      ++v112;
      v71 = _inc(v76, v105);
      v72 = *v11++;
      v110 = v71;
      v97 = v11;
      if ( v72 == v71 )
      {
        if ( !isleadbyte((unsigned __int8)v71) )
          goto LABEL_269;
        ++v112;
        v73 = _inc(v79, v105);
        v74 = *v11++;
        v97 = v11;
        if ( v74 == v73 )
        {
          --v112;
          goto LABEL_269;
        }
        if ( v73 != -1 )
          sub_1004556C(v73, v105);
      }
      v75 = v71 == -1;
      goto LABEL_279;
    }
    v86 = 0;
    v92 = 0;
    v100 = 0;
    v96 = 0;
    v108 = 0;
    v101 = 0;
    v102 = 0;
    v107 = 0;
    v111 = 0;
    v103 = 0;
    v109 = 0;
    v106 = 1;
    v90 = 0;
    v13 = 0;
    do
    {
      v14 = *++v11;
      v15 = isdigit(v14);
      v17 = v16;
      if ( v15 )
      {
        ++v96;
        v108 = 10 * v108 + v14 - 48;
        continue;
      }
      if ( v14 > 78 )
      {
        if ( v14 == 104 )
        {
          --v106;
          --v109;
        }
        else
        {
          if ( v14 == 108 )
          {
            v18 = (int)(v11 + 1);
            if ( v11[1] == 108 )
              goto LABEL_36;
            ++v106;
          }
          else if ( v14 != 119 )
          {
            goto LABEL_50;
          }
          ++v109;
        }
      }
      else
      {
        if ( v14 == 78 )
          continue;
        if ( v14 == 42 )
        {
          ++v107;
          continue;
        }
        if ( v14 == 70 )
          continue;
        if ( v14 != 73 )
        {
          if ( v14 == 76 )
          {
            ++v106;
            continue;
          }
LABEL_50:
          ++v111;
          continue;
        }
        LOBYTE(v17) = v11[1];
        if ( (_BYTE)v17 == 54 )
        {
          v18 = (int)(v11 + 2);
          if ( v11[2] == 52 )
          {
LABEL_36:
            ++v90;
            v11 = (unsigned __int8 *)v18;
            v95 = 0i64;
            continue;
          }
        }
        if ( (_BYTE)v17 == 51 && v11[2] == 50 )
        {
          v11 += 2;
          continue;
        }
        if ( (_BYTE)v17 != 100 && (_BYTE)v17 != 105 && (_BYTE)v17 != 111 && (_BYTE)v17 != 120 && (_BYTE)v17 != 88 )
          goto LABEL_50;
      }
    }
    while ( !v111 );
    v97 = v11;
    if ( !v107 )
    {
      v13 = *v85;
      v80 = v85;
      ++v85;
    }
    v94 = v13;
    v111 = 0;
    if ( !v109 )
    {
      v19 = *v11;
      if ( *v11 == 83 || (v109 = -1, v19 == 67) )
        v109 = 1;
    }
    v99 = *v11 | 0x20;
    v20 = v99;
    if ( v99 != 110 )
    {
      if ( v99 == 99 || v99 == 123 )
      {
        ++v112;
        v21 = _inc(v17, v105);
      }
      else
      {
        v21 = _whiteout(v105);
      }
      v110 = v21;
      if ( v21 == -1 )
        goto LABEL_281;
      v13 = v94;
      v11 = v97;
    }
    v22 = v96;
    if ( v96 && !v108 )
      goto LABEL_275;
    if ( v20 > 111 )
    {
      if ( v20 == 112 )
      {
        v106 = 1;
      }
      else
      {
        if ( v20 == 115 )
        {
LABEL_127:
          if ( v109 > 0 )
            v103 = 1;
          goto LABEL_129;
        }
        if ( v20 != 117 )
        {
          if ( v20 == 120 )
            goto LABEL_82;
          if ( v20 != 123 )
            goto LABEL_151;
          if ( v109 > 0 )
            v103 = 1;
          v48 = v11 + 1;
          v49 = v48;
          if ( *v48 == 94 )
          {
            v49 = v48 + 1;
            v101 = -1;
          }
          memset(v114, 0, 0x20u);
          if ( *v49 == 93 )
          {
            v50 = 93;
            ++v49;
            v115 = 32;
          }
          else
          {
            v50 = v92;
          }
          while ( 1 )
          {
            v56 = *v49;
            if ( *v49 == 93 )
              break;
            ++v49;
            if ( v56 == 45 && v50 && (LOBYTE(v22) = *v49, *v49 != 93) )
            {
              ++v49;
              if ( v50 >= (unsigned __int8)v22 )
              {
                v51 = v50;
                v50 = v22;
              }
              else
              {
                v51 = v22;
              }
              if ( v50 <= v51 )
              {
                v52 = v50;
                v53 = (unsigned __int8)(v51 - v50 + 1);
                do
                {
                  v22 = v52 & 7;
                  v114[v52 >> 3] |= 1 << v22;
                  ++v52;
                  --v53;
                }
                while ( v53 );
                v20 = v99;
              }
              v50 = 0;
            }
            else
            {
              v54 = v56;
              v50 = v56;
              v55 = v54;
              v22 = v54 & 7;
              v114[v55 >> 3] |= 1 << v22;
              v20 = v99;
            }
          }
          v97 = v49;
          v13 = v94;
LABEL_129:
          --v112;
          v44 = v13;
          if ( v110 != -1 )
          {
            sub_1004556C(v110, v105);
            v22 = v45;
          }
          while ( 1 )
          {
            if ( v96 )
            {
              v46 = v108--;
              if ( !v46 )
                goto LABEL_200;
            }
            ++v112;
            v47 = _inc(v22, v105);
            v110 = v47;
            if ( v47 == -1 )
              goto LABEL_198;
            if ( v20 != 99 )
            {
              if ( v20 != 115 )
                goto LABEL_295;
              if ( v47 >= 9 && v47 <= 13 )
              {
LABEL_198:
                --v112;
                if ( v47 != -1 )
                  sub_1004556C(v47, v105);
LABEL_200:
                if ( v44 != v13 )
                {
                  if ( !v107 )
                  {
                    ++v93;
                    if ( v20 != 99 )
                    {
                      if ( v103 )
                        *v94 = 0;
                      else
                        *(_BYTE *)v94 = 0;
                    }
                  }
                  goto LABEL_264;
                }
                goto LABEL_281;
              }
              if ( v47 == 32 )
              {
LABEL_295:
                if ( v20 != 123 )
                  goto LABEL_198;
                v22 = v101 ^ v114[v47 >> 3];
                v20 = v99;
                if ( !((1 << (v47 & 7)) & v22) )
                  goto LABEL_198;
              }
            }
            if ( v107 )
            {
              v44 = (_WORD *)((char *)v44 + 1);
            }
            else
            {
              if ( v103 )
              {
                SrcCh = v47;
                if ( isleadbyte((unsigned __int8)v47) )
                {
                  ++v112;
                  v88 = _inc(v78, v105);
                }
                *(_DWORD *)DstCh = 63;
                _mbtowc_l(DstCh, &SrcCh, Locale.locinfo->mb_cur_max, &Locale);
                *v13 = DstCh[0];
                ++v13;
              }
              else
              {
                *(_BYTE *)v13 = v47;
                v13 = (_WORD *)((char *)v13 + 1);
              }
              v94 = v13;
            }
          }
        }
      }
LABEL_207:
      v24 = v110;
      if ( v110 == 45 )
      {
        v102 = 1;
      }
      else if ( v110 != 43 )
      {
        goto LABEL_215;
      }
      if ( !--v108 && v96 )
      {
        v111 = 1;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v96, v105);
      goto LABEL_214;
    }
    if ( v20 == 111 )
      goto LABEL_207;
    if ( v20 == 99 )
    {
      if ( !v96 )
      {
        ++v108;
        v96 = 1;
      }
      goto LABEL_127;
    }
    if ( v20 == 100 )
      goto LABEL_207;
    if ( v20 <= 100 )
      goto LABEL_151;
    if ( v20 <= 103 )
    {
      v25 = 0;
      if ( v110 == 45 )
      {
        *(_BYTE *)v98 = 45;
        v25 = 1;
        goto LABEL_87;
      }
      if ( v110 == 43 )
      {
LABEL_87:
        --v108;
        ++v112;
        v110 = _inc(v22, v105);
      }
      if ( !v96 )
        v108 = -1;
      for ( i = (unsigned __int8)v110; isdigit(i); i = (unsigned __int8)v110 )
      {
        v27 = v108--;
        if ( !v27 )
          break;
        ++v100;
        *((_BYTE *)v98 + v25++) = v110;
        if ( !__check_float_string(v25, &v113, (int)&v91) )
          goto LABEL_281;
        ++v112;
        v110 = _inc(v28, v105);
      }
      v101 = **(_BYTE **)Locale.locinfo->lconv;
      if ( v101 == (_BYTE)v110 )
      {
        v29 = v108--;
        if ( v29 )
        {
          ++v112;
          v110 = _inc(v77, v105);
          *((_BYTE *)v98 + v25++) = v101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          for ( j = (unsigned __int8)v110; isdigit(j); j = (unsigned __int8)v110 )
          {
            v31 = v108--;
            if ( !v31 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v32, v105);
          }
        }
      }
      if ( v100 && (v110 == 101 || v110 == 69) )
      {
        v33 = v108--;
        if ( v33 )
        {
          *((_BYTE *)v98 + v25++) = 101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          ++v112;
          v110 = _inc(v34, v105);
          if ( v110 == 45 )
          {
            *((_BYTE *)v98 + v25++) = 45;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
LABEL_112:
            v36 = v108--;
            if ( v36 )
            {
              ++v112;
              v110 = _inc(v35, v105);
            }
            else
            {
              v108 = 0;
            }
          }
          else if ( v110 == 43 )
          {
            goto LABEL_112;
          }
          for ( k = (unsigned __int8)v110; isdigit(k); k = (unsigned __int8)v110 )
          {
            v38 = v108--;
            if ( !v38 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v39, v105);
          }
        }
      }
      --v112;
      if ( v110 != -1 )
        sub_1004556C(v110, v105);
      if ( v100 )
      {
        if ( !v107 )
        {
          ++v93;
          v40 = v98;
          v41 = v94;
          *((_BYTE *)v98 + v25) = 0;
          v42 = v106 - 1;
          v43 = (void (__cdecl *)(int, _WORD *, void *, struct localeinfo_struct *))_decode_pointer(off_100DA284[0]);
          v43(v42, v41, v40, &Locale);
        }
        goto LABEL_264;
      }
      goto LABEL_281;
    }
    if ( v20 != 105 )
    {
      if ( v20 == 110 )
      {
        v23 = v112;
        if ( !v107 )
        {
LABEL_259:
          if ( v90 )
          {
            *(_QWORD *)v13 = v95;
          }
          else if ( v106 )
          {
            *(_DWORD *)v13 = v23;
          }
          else
          {
            *v13 = v23;
          }
        }
        goto LABEL_264;
      }
LABEL_151:
      if ( *v11 == v110 )
      {
        --v104;
        if ( !v107 )
          v85 = v80;
        goto LABEL_264;
      }
LABEL_275:
      v75 = v110 == -1;
LABEL_279:
      if ( !v75 )
        sub_1004556C(v110, v105);
      goto LABEL_281;
    }
    v99 = 100;
LABEL_82:
    v24 = v110;
    if ( v110 == 45 )
    {
      v102 = 1;
      goto LABEL_176;
    }
    if ( v110 == 43 )
    {
LABEL_176:
      if ( --v108 || !v96 )
      {
        ++v112;
        v24 = _inc(v96, v105);
        v110 = v24;
      }
      else
      {
        v111 = 1;
      }
    }
    if ( v24 == 48 )
    {
      ++v112;
      v57 = _inc(v22, v105);
      v24 = v57;
      v110 = v57;
      if ( (_BYTE)v57 != 120 && (_BYTE)v57 != 88 )
      {
        v100 = 1;
        if ( v99 != 120 )
        {
          if ( v96 )
          {
            if ( !--v108 )
              ++v111;
          }
          v99 = 111;
          goto LABEL_215;
        }
        --v112;
        if ( v57 != -1 )
          sub_1004556C(v57, v105);
        v24 = 48;
LABEL_214:
        v110 = v24;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v58, v105);
      v110 = v24;
      if ( v96 )
      {
        v108 -= 2;
        if ( v108 < 1 )
          ++v111;
      }
      v99 = 120;
    }
LABEL_215:
    if ( !v90 )
    {
      v23 = v86;
      if ( !v111 )
      {
        while ( 1 )
        {
          if ( v99 == 120 || v99 == 112 )
          {
            if ( !isxdigit((unsigned __int8)v24) )
            {
LABEL_250:
              --v112;
              if ( v24 != -1 )
                sub_1004556C(v24, v105);
              break;
            }
            v68 = 16 * v23;
            v69 = isdigit((unsigned __int8)v24);
            v67 = v70;
            v24 = (char)v24;
            if ( !v69 )
              v24 = (v24 & 0xFFFFFFDF) - 7;
            v110 = v24;
          }
          else
          {
            v65 = isdigit((unsigned __int8)v24);
            v67 = v66;
            if ( !v65 )
              goto LABEL_250;
            if ( v99 == 111 )
            {
              if ( v24 >= 56 )
                goto LABEL_250;
              v68 = 8 * v23;
            }
            else
            {
              v68 = 10 * v23;
            }
          }
          ++v100;
          v23 = v68 + v24 - 48;
          if ( v96 )
          {
            if ( !--v108 )
              break;
          }
          ++v112;
          v24 = _inc(v67, v105);
          v110 = v24;
        }
      }
      if ( v102 )
        v23 = -v23;
      goto LABEL_254;
    }
    if ( v111 )
      goto LABEL_233;
    while ( 2 )
    {
      if ( v99 != 120 && v99 != 112 )
      {
        v59 = isdigit((unsigned __int8)v24);
        v61 = v60;
        if ( !v59 )
          break;
        if ( v99 == 111 )
        {
          if ( v24 >= 56 )
            break;
          v62 = 8 * v95;
          HIDWORD(v95) = v95 >> 29;
        }
        else
        {
          HIDWORD(v95) = 10 * v95 >> 32;
          v62 = 10 * v95;
        }
        goto LABEL_228;
      }
      if ( isxdigit((unsigned __int8)v24) )
      {
        v62 = 16 * v95;
        HIDWORD(v95) = v95 >> 28;
        v63 = isdigit((unsigned __int8)v24);
        v61 = v64;
        v24 = (char)v24;
        if ( !v63 )
          v24 = (v24 & 0xFFFFFFDF) - 7;
        v110 = v24;
LABEL_228:
        ++v100;
        v95 = v24 - 48 + __PAIR__(HIDWORD(v95), v62);
        if ( v96 )
        {
          if ( !--v108 )
            goto LABEL_233;
        }
        ++v112;
        v24 = _inc(v61, v105);
        v110 = v24;
        continue;
      }
      break;
    }
    --v112;
    if ( v24 != -1 )
      sub_1004556C(v24, v105);
LABEL_233:
    v23 = v86;
    if ( v102 )
      v95 = -(signed __int64)v95;
LABEL_254:
    if ( v99 == 70 )
      v100 = 0;
    if ( !v100 )
      goto LABEL_281;
    if ( !v107 )
    {
      ++v93;
      v13 = v94;
      goto LABEL_259;
    }
LABEL_264:
    ++v104;
    v11 = v97++ + 1;
LABEL_269:
    if ( v110 != -1 )
    {
LABEL_273:
      v10 = *v11;
      if ( !*v11 )
        goto LABEL_281;
      continue;
    }
    break;
  }
  if ( *v11 == 37 && v97[1] == 110 )
  {
    v11 = v97;
    goto LABEL_273;
  }
LABEL_281:
  if ( v91 == 1 )
    free(v98);
  if ( v110 == -1 )
  {
    result = v93;
    if ( !v93 && v104 == (_BYTE)v93 )
      result = -1;
    if ( v83 )
      *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
    return result;
  }
LABEL_289:
  if ( v83 )
    *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
  return v93;
}
// 1003A170: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1003BBAD: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1003EF7F: using guessed type int __fastcall _inc(_DWORD, _DWORD);
// 1003EF95: using guessed type _DWORD __cdecl _whiteout(_DWORD);
// 100DA284: using guessed type int (*off_100DA284[3])();
// 102554A0: using guessed type int dword_102554A0[];
// 1003EFBA: using guessed type char var_24[11];

//----- (10040E74) --------------------------------------------------------
#error "10040E79: positive sp value has been found (funcsize=0)"

//----- (10040E7F) --------------------------------------------------------
#error "10040E84: positive sp value has been found (funcsize=0)"

//----- (10040E8A) --------------------------------------------------------
#error "10040E8F: positive sp value has been found (funcsize=0)"

//----- (10040E90) --------------------------------------------------------
#error "10040E95: positive sp value has been found (funcsize=0)"

//----- (10040E96) --------------------------------------------------------
#error "10040E9B: positive sp value has been found (funcsize=0)"

//----- (10040E9C) --------------------------------------------------------
#error "10040EA1: positive sp value has been found (funcsize=0)"

//----- (10040EA2) --------------------------------------------------------
#error "10040EBD: positive sp value has been found (funcsize=0)"

//----- (10040EC3) --------------------------------------------------------
#error "10040ED8: positive sp value has been found (funcsize=0)"

//----- (10040EDE) --------------------------------------------------------
#error "10040EF9: positive sp value has been found (funcsize=0)"

//----- (10040EFA) --------------------------------------------------------
#error "10040F09: positive sp value has been found (funcsize=0)"

//----- (10040F0A) --------------------------------------------------------
#error "10040F1D: positive sp value has been found (funcsize=0)"

//----- (10040F1E) --------------------------------------------------------
#error "10040F2D: positive sp value has been found (funcsize=0)"

//----- (10040F2E) --------------------------------------------------------
#error "10040F4D: positive sp value has been found (funcsize=0)"

//----- (10040F53) --------------------------------------------------------
#error "10040F6C: positive sp value has been found (funcsize=0)"

//----- (10040F72) --------------------------------------------------------
#error "10040F91: positive sp value has been found (funcsize=0)"

//----- (10040F92) --------------------------------------------------------
#error "10040FA5: positive sp value has been found (funcsize=0)"

//----- (10040FA6) --------------------------------------------------------
#error "10040FBD: positive sp value has been found (funcsize=0)"

//----- (10040FBE) --------------------------------------------------------
#error "10040FD1: positive sp value has been found (funcsize=0)"

//----- (10040FD2) --------------------------------------------------------
#error "10040FF1: positive sp value has been found (funcsize=0)"

//----- (10040FF7) --------------------------------------------------------
#error "10041010: positive sp value has been found (funcsize=0)"

//----- (10041016) --------------------------------------------------------
#error "10041035: positive sp value has been found (funcsize=0)"

//----- (10041036) --------------------------------------------------------
#error "10041049: positive sp value has been found (funcsize=0)"

//----- (1004104A) --------------------------------------------------------
#error "10041061: positive sp value has been found (funcsize=0)"

//----- (10041062) --------------------------------------------------------
#error "10041075: positive sp value has been found (funcsize=0)"

//----- (10041076) --------------------------------------------------------
#error "10041095: positive sp value has been found (funcsize=0)"

//----- (1004109B) --------------------------------------------------------
#error "100410B4: positive sp value has been found (funcsize=0)"

//----- (100410BA) --------------------------------------------------------
#error "100410D9: positive sp value has been found (funcsize=0)"

//----- (100410DA) --------------------------------------------------------
#error "100410ED: positive sp value has been found (funcsize=0)"

//----- (100410EE) --------------------------------------------------------
#error "10041105: positive sp value has been found (funcsize=0)"

//----- (10041106) --------------------------------------------------------
#error "10041119: positive sp value has been found (funcsize=0)"

//----- (1004111A) --------------------------------------------------------
#error "10041139: positive sp value has been found (funcsize=0)"

//----- (1004113F) --------------------------------------------------------
#error "10041158: positive sp value has been found (funcsize=0)"

//----- (1004115E) --------------------------------------------------------
#error "1004117D: positive sp value has been found (funcsize=0)"

//----- (1004117E) --------------------------------------------------------
#error "10041191: positive sp value has been found (funcsize=0)"

//----- (10041192) --------------------------------------------------------
#error "100411A9: positive sp value has been found (funcsize=0)"

//----- (100411AA) --------------------------------------------------------
#error "100411BD: positive sp value has been found (funcsize=0)"

//----- (100411BE) --------------------------------------------------------
#error "100411DD: positive sp value has been found (funcsize=0)"

//----- (100411E3) --------------------------------------------------------
#error "100411FC: positive sp value has been found (funcsize=0)"

//----- (10041202) --------------------------------------------------------
#error "10041221: positive sp value has been found (funcsize=0)"

//----- (10041222) --------------------------------------------------------
#error "10041235: positive sp value has been found (funcsize=0)"

//----- (10041236) --------------------------------------------------------
#error "1004124D: positive sp value has been found (funcsize=0)"

//----- (1004124E) --------------------------------------------------------
#error "10041261: positive sp value has been found (funcsize=0)"

//----- (10041262) --------------------------------------------------------
#error "10041281: positive sp value has been found (funcsize=0)"

//----- (10041287) --------------------------------------------------------
#error "100412A0: positive sp value has been found (funcsize=0)"

//----- (100412A6) --------------------------------------------------------
#error "100412C5: positive sp value has been found (funcsize=0)"

//----- (100412C6) --------------------------------------------------------
#error "100412D9: positive sp value has been found (funcsize=0)"

//----- (100412DA) --------------------------------------------------------
#error "100412F1: positive sp value has been found (funcsize=0)"

//----- (100412F2) --------------------------------------------------------
#error "10041305: positive sp value has been found (funcsize=0)"

//----- (10041DCC) --------------------------------------------------------
int __cdecl sub_10041DCC(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_10045F99((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 10046A1D: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10041E72) --------------------------------------------------------
int __cdecl sub_10041E72(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_100464DB((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 10046A1D: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100422E2) --------------------------------------------------------
DWORD __cdecl sub_100422E2(int a1, int a2, int a3, DWORD dwMoveMethod)
{
  void *v4; // eax@1
  DWORD v6; // eax@5
  _BYTE *v7; // eax@7
  DWORD lDistanceToMove; // [sp+8h] [bp-8h]@4
  LONG DistanceToMoveHigh; // [sp+Ch] [bp-4h]@1

  DistanceToMoveHigh = a3;
  v4 = (void *)sub_10047E55(a1);
  if ( v4 == (void *)-1 )
  {
    *_errno() = 9;
    return -1;
  }
  lDistanceToMove = SetFilePointer(v4, a2, &DistanceToMoveHigh, dwMoveMethod);
  if ( lDistanceToMove == -1 )
  {
    v6 = GetLastError();
    if ( v6 )
    {
      _dosmaperr(v6);
      return -1;
    }
  }
  v7 = (_BYTE *)(dword_102554A0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4);
  *v7 &= 0xFDu;
  return lDistanceToMove;
}
// 100387FC: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 102554A0: using guessed type int dword_102554A0[];

//----- (1004247E) --------------------------------------------------------
_WORD *__cdecl sub_1004247E(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // esi@5
  int v5; // edi@5
  int v6; // eax@5
  char v7; // bl@5
  int v8; // eax@13
  void *v9; // ST18_4@13
  DWORD v10; // eax@16
  const char *v11; // ebx@16
  char v12; // cl@19
  int *v13; // esi@19
  int v14; // eax@19
  int v15; // eax@20
  int v16; // eax@27
  signed int v17; // esi@27
  int v18; // eax@31
  int v19; // esi@36
  __int16 v20; // ax@39
  int v21; // ecx@45
  char v22; // dl@45
  int v23; // eax@46
  DWORD v24; // ecx@51
  char *v25; // eax@51
  char *v26; // edx@53
  char v27; // dl@53
  int v28; // ebx@56
  DWORD v29; // ecx@64
  char *v30; // eax@64
  __int16 *v31; // edx@66
  __int16 v32; // dx@66
  int v33; // ebx@69
  DWORD v34; // ecx@74
  WCHAR *v35; // eax@74
  WCHAR v36; // dx@76
  int v37; // esi@79
  int v38; // ebx@79
  DWORD Mode; // [sp+4h] [bp-7Ch]@13
  int v40; // [sp+8h] [bp-78h]@13
  char v41; // [sp+Fh] [bp-71h]@5
  int *v42; // [sp+10h] [bp-70h]@5
  DWORD v43; // [sp+14h] [bp-6Ch]@56
  int v44; // [sp+18h] [bp-68h]@1
  LPCVOID lpBuffer; // [sp+1Ch] [bp-64h]@1
  _WORD *v46; // [sp+20h] [bp-60h]@1
  DWORD NumberOfBytesWritten; // [sp+24h] [bp-5Ch]@16
  WCHAR WideCharStr[2]; // [sp+28h] [bp-58h]@20
  _WORD *v49; // [sp+2Ch] [bp-54h]@17
  char Buffer; // [sp+30h] [bp-50h]@51
  CHAR v51[688]; // [sp+184h] [bp+104h]@79
  WCHAR v52; // [sp+434h] [bp+3B4h]@74
  CHAR MultiByteStr; // [sp+588h] [bp+508h]@20
  char v54; // [sp+589h] [bp+509h]@20

  lpBuffer = (LPCVOID)a2;
  v46 = 0;
  v44 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a2 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  v4 = &dword_102554A0[a1 >> 5];
  v5 = (a1 & 0x1F) << 6;
  v6 = v5 + *v4;
  v7 = (char)(2 * *(_BYTE *)(v6 + 36)) >> 1;
  v42 = &dword_102554A0[a1 >> 5];
  v41 = v7;
  if ( (v7 == 2 || v7 == 1) && !(~(_BYTE)nNumberOfBytesToWrite & 1) )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  if ( *(_BYTE *)(v6 + 4) & 0x20 )
    sub_100422E2(a1, 0, 0, 2u);
  if ( sub_10042BC0(a1) )
  {
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x80 )
    {
      v8 = _getptd();
      v9 = *(void **)(v5 + *v4);
      v40 = *(_DWORD *)(*(_DWORD *)(v8 + 108) + 20) == 0;
      if ( GetConsoleMode(v9, &Mode) )
      {
        if ( !v40 || v7 )
        {
          v10 = GetConsoleCP();
          v11 = (const char *)lpBuffer;
          Mode = v10;
          NumberOfBytesWritten = 0;
          if ( nNumberOfBytesToWrite )
          {
            v49 = 0;
            while ( 1 )
            {
              if ( v41 )
              {
                if ( v41 == 1 || v41 == 2 )
                {
                  v19 = *(_WORD *)v11;
                  v11 += 2;
                  ++v49;
                  *(_DWORD *)WideCharStr = v19;
                  v40 = (_WORD)v19 == 10;
                }
                if ( v41 == 1 || v41 == 2 )
                {
                  v20 = _putwch_nolock(WideCharStr[0]);
                  if ( v20 != WideCharStr[0] )
                    goto LABEL_89;
                  v46 = (_WORD *)((char *)v46 + 1);
                  if ( v40 )
                  {
                    *(_DWORD *)WideCharStr = 13;
                    if ( (unsigned __int16)_putwch_nolock(13) != 13 )
                      goto LABEL_89;
                    v46 = (_WORD *)((char *)v46 + 1);
                    ++v44;
                  }
                }
                goto LABEL_43;
              }
              v12 = *v11;
              v13 = v42;
              v40 = *v11 == 10;
              v14 = v5 + *v42;
              if ( *(_DWORD *)(v14 + 56) )
              {
                MultiByteStr = *(_BYTE *)(v14 + 52);
                v54 = v12;
                *(_DWORD *)(v14 + 56) = 0;
                v15 = mbtowc(WideCharStr, &MultiByteStr, 2u);
              }
              else
              {
                if ( isleadbyte(v12) )
                {
                  if ( nNumberOfBytesToWrite + (_BYTE *)lpBuffer - v11 <= 1 )
                  {
                    v21 = *v13;
                    v22 = *v11;
                    v46 = (_WORD *)((char *)v46 + 1);
                    *(_BYTE *)(v5 + v21 + 52) = v22;
                    *(_DWORD *)(v5 + *v13 + 56) = 1;
                    goto LABEL_90;
                  }
                  if ( mbtowc(WideCharStr, v11, 2u) == -1 )
                    goto LABEL_90;
                  ++v11;
                  v49 = (_WORD *)((char *)v49 + 1);
                  goto LABEL_27;
                }
                v15 = mbtowc(WideCharStr, v11, 1u);
              }
              if ( v15 == -1 )
                goto LABEL_90;
LABEL_27:
              ++v11;
              v49 = (_WORD *)((char *)v49 + 1);
              v16 = WideCharToMultiByte(Mode, 0, WideCharStr, 1, &MultiByteStr, 5, 0, 0);
              v17 = v16;
              if ( !v16 )
                goto LABEL_90;
              if ( !WriteFile(*(HANDLE *)(v5 + *v42), &MultiByteStr, v16, &NumberOfBytesWritten, 0) )
                goto LABEL_89;
              v46 = (_WORD *)((char *)v49 + v44);
              if ( (signed int)NumberOfBytesWritten < v17 )
                goto LABEL_90;
              if ( v40 )
              {
                v18 = *v42;
                MultiByteStr = 13;
                if ( !WriteFile(*(HANDLE *)(v5 + v18), &MultiByteStr, 1u, &NumberOfBytesWritten, 0) )
                  goto LABEL_89;
                if ( (signed int)NumberOfBytesWritten < 1 )
                  goto LABEL_90;
                ++v44;
                v46 = (_WORD *)((char *)v46 + 1);
              }
LABEL_43:
              if ( (unsigned int)v49 >= nNumberOfBytesToWrite )
                goto LABEL_90;
            }
          }
          goto LABEL_91;
        }
      }
    }
  }
  v23 = v5 + *v4;
  if ( *(_BYTE *)(v23 + 4) & 0x80 )
  {
    *(_DWORD *)WideCharStr = 0;
    if ( v7 )
    {
      v49 = lpBuffer;
      if ( v7 == 2 )
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v29 = (char *)v49 - (_BYTE *)lpBuffer;
          v30 = &Buffer;
          do
          {
            if ( v29 >= nNumberOfBytesToWrite )
              break;
            v31 = v49;
            ++v49;
            v32 = *v31;
            v29 += 2;
            if ( v32 == 10 )
            {
              v44 += 2;
              *(_WORD *)v30 = 13;
              v30 += 2;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *(_WORD *)v30 = v32;
            v30 += 2;
          }
          while ( NumberOfBytesWritten < 0x3FF );
          v33 = v30 - &Buffer;
          if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v30 - &Buffer, &v43, 0) )
            break;
          v46 = (_WORD *)((char *)v46 + v43);
          if ( (signed int)v43 < v33 || (char *)v49 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
            goto LABEL_90;
          v4 = v42;
        }
      }
      else
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v34 = (char *)v49 - (_BYTE *)lpBuffer;
          v35 = &v52;
          do
          {
            if ( v34 >= nNumberOfBytesToWrite )
              break;
            v36 = *v49;
            ++v49;
            v34 += 2;
            if ( v36 == 10 )
            {
              *v35 = 13;
              ++v35;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *v35 = v36;
            ++v35;
          }
          while ( NumberOfBytesWritten < 0x152 );
          v37 = 0;
          v38 = WideCharToMultiByte(0xFDE9u, 0, &v52, v35 - &v52, v51, 683, 0, 0);
          if ( !v38 )
            break;
          while ( WriteFile(*(HANDLE *)(v5 + *v42), &v51[v37], v38 - v37, &v43, 0) )
          {
            v37 += v43;
            if ( v38 <= v37 )
              goto LABEL_84;
          }
          *(_DWORD *)WideCharStr = GetLastError();
LABEL_84:
          if ( v38 <= v37 )
          {
            v46 = (_WORD *)((char *)v49 - (_BYTE *)lpBuffer);
            if ( (char *)v49 - (_BYTE *)lpBuffer < nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_90;
        }
      }
    }
    else
    {
      NumberOfBytesWritten = (DWORD)lpBuffer;
      if ( nNumberOfBytesToWrite <= 0 )
        goto LABEL_96;
      while ( 1 )
      {
        v49 = 0;
        v24 = NumberOfBytesWritten - (_DWORD)lpBuffer;
        v25 = &Buffer;
        do
        {
          if ( v24 >= nNumberOfBytesToWrite )
            break;
          v26 = (char *)NumberOfBytesWritten++;
          v27 = *v26;
          ++v24;
          if ( v27 == 10 )
          {
            ++v44;
            *v25++ = 13;
            v49 = (_WORD *)((char *)v49 + 1);
          }
          *v25++ = v27;
          v49 = (_WORD *)((char *)v49 + 1);
        }
        while ( (unsigned int)v49 < 0x400 );
        v28 = v25 - &Buffer;
        if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v25 - &Buffer, &v43, 0) )
          break;
        v46 = (_WORD *)((char *)v46 + v43);
        if ( (signed int)v43 < v28 || NumberOfBytesWritten - (unsigned int)lpBuffer >= nNumberOfBytesToWrite )
          goto LABEL_90;
        v4 = v42;
      }
    }
  }
  else if ( WriteFile(*(HANDLE *)v23, lpBuffer, nNumberOfBytesToWrite, &v43, 0) )
  {
    *(_DWORD *)WideCharStr = 0;
    v46 = (_WORD *)v43;
    goto LABEL_90;
  }
LABEL_89:
  *(_DWORD *)WideCharStr = GetLastError();
LABEL_90:
  if ( !v46 )
  {
LABEL_91:
    if ( *(_DWORD *)WideCharStr )
    {
      if ( *(_DWORD *)WideCharStr == 5 )
      {
        *_errno() = 9;
        *__doserrno() = 5;
      }
      else
      {
        _dosmaperr(*(_DWORD *)WideCharStr);
      }
      return (_WORD *)-1;
    }
    v4 = v42;
LABEL_96:
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x40 && *(_BYTE *)lpBuffer == 26 )
      return 0;
    *_errno() = 28;
    *__doserrno() = 0;
    return (_WORD *)-1;
  }
  return (_WORD *)((char *)v46 - v44);
}
// 100387FC: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 1003A170: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1003BDC9: using guessed type int _getptd(void);
// 102554A0: using guessed type int dword_102554A0[];
// 1004247E: using guessed type CHAR var_410[688];

//----- (10042AA0) --------------------------------------------------------
_WORD *__cdecl sub_10042AA0(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // ebx@7
  int v5; // esi@7
  _WORD *v6; // [sp+14h] [bp-1Ch]@9

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return (_WORD *)-1;
  }
  if ( a1 < 0
    || a1 >= uNumber
    || (v4 = &dword_102554A0[a1 >> 5], v5 = (a1 & 0x1F) << 6, !(*(_BYTE *)(*v4 + v5 + 4) & 1)) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  __lock_fhandle(a1);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    v6 = sub_1004247E(a1, a2, nNumberOfBytesToWrite);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    v6 = (_WORD *)-1;
  }
  sub_10047F66(a1);
  return v6;
}
// 1003A170: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10047EC6: using guessed type _DWORD __cdecl __lock_fhandle(_DWORD);
// 102554A0: using guessed type int dword_102554A0[];

//----- (10042BC0) --------------------------------------------------------
int __cdecl sub_10042BC0(signed int a1)
{
  int result; // eax@2

  if ( a1 == -2 )
  {
    *_errno() = 9;
    result = 0;
  }
  else if ( a1 >= 0 && a1 < uNumber )
  {
    result = *(_BYTE *)(dword_102554A0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) & 0x40;
  }
  else
  {
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 0;
  }
  return result;
}
// 1003A170: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 102554A0: using guessed type int dword_102554A0[];

//----- (10042C1E) --------------------------------------------------------
void **sub_10042C1E()
{
  return &off_100DAD10;
}
// 100DAD10: using guessed type void *off_100DAD10;

//----- (10042C24) --------------------------------------------------------
signed int sub_10042C24()
{
  size_t v0; // eax@1
  void *v1; // eax@6
  signed int result; // eax@8
  int v3; // edx@9
  void **v4; // ecx@9
  signed int v5; // edx@12
  _DWORD *v6; // ecx@12
  int v7; // eax@13

  v0 = dword_10255480;
  if ( !dword_10255480 )
  {
    v0 = 512;
LABEL_5:
    dword_10255480 = v0;
    goto LABEL_6;
  }
  if ( dword_10255480 < 20 )
  {
    v0 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v1 = (void *)_calloc_crt(v0, 4);
  dword_10254464 = v1;
  if ( v1 || (dword_10255480 = 20, v1 = (void *)_calloc_crt(0x14u, 4), (dword_10254464 = v1) != 0) )
  {
    v3 = 0;
    v4 = &off_100DAD10;
    while ( 1 )
    {
      *(_DWORD *)((char *)v1 + v3) = v4;
      v4 += 8;
      v3 += 4;
      if ( (signed int)v4 >= (signed int)&dbl_100DAF90 )
        break;
      v1 = dword_10254464;
    }
    v5 = 0;
    v6 = &unk_100DAD20;
    do
    {
      v7 = *(_DWORD *)(((v5 & 0x1F) << 6) + dword_102554A0[v5 >> 5]);
      if ( v7 == -1 || v7 == -2 || !v7 )
        *v6 = -2;
      v6 += 8;
      ++v5;
    }
    while ( (signed int)v6 < (signed int)&unk_100DAD80 );
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 1003C1BD: using guessed type _DWORD __cdecl _calloc_crt(size_t, _DWORD);
// 100DAD10: using guessed type void *off_100DAD10;
// 100DAF90: using guessed type double dbl_100DAF90;
// 10255480: using guessed type int dword_10255480;
// 102554A0: using guessed type int dword_102554A0[];

//----- (10043015) --------------------------------------------------------
void sub_10043015()
{
  dword_10254460 = 0;
}
// 10254460: using guessed type int dword_10254460;

//----- (100430CD) --------------------------------------------------------
int sub_100430CD()
{
  dword_102555B8 = _get_sse2_info();
  return 0;
}
// 1004306D: using guessed type int _get_sse2_info(void);
// 102555B8: using guessed type int dword_102555B8;

//----- (10043892) --------------------------------------------------------
int sub_10043892()
{
  return _decode_pointer(dword_10246BA8);
}
// 1003BBAD: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 10246BA8: using guessed type int dword_10246BA8;

//----- (10043A4F) --------------------------------------------------------
int __cdecl sub_10043A4F(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10246BB4 = a1;
  return result;
}
// 10246BB4: using guessed type int dword_10246BB4;

//----- (10043A59) --------------------------------------------------------
int __cdecl sub_10043A59(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10246BC0 = a1;
  return result;
}
// 10246BC0: using guessed type int dword_10246BC0;

//----- (10043A63) --------------------------------------------------------
int __cdecl sub_10043A63(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10246BC4 = a1;
  return result;
}
// 10246BC4: using guessed type int dword_10246BC4;

//----- (10043B42) --------------------------------------------------------
int __cdecl sub_10043B42(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10246BC8 = a1;
  return result;
}
// 10246BC8: using guessed type int dword_10246BC8;

//----- (1004544C) --------------------------------------------------------
int __cdecl sub_1004544C(FILE *a1)
{
  int v1; // eax@3
  int v2; // eax@7
  int v3; // ST10_4@10
  char *v4; // ST0C_4@10
  int v5; // eax@10
  int v6; // eax@10
  int *v7; // edi@15
  _BYTE *v8; // eax@15
  int v9; // eax@20
  char *v10; // ecx@23
  int result; // eax@23

  if ( !a1 )
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v1 = a1->_flag;
  if ( !(v1 & 0x83) || v1 & 0x40 )
    return -1;
  if ( v1 & 2 )
  {
    a1->_flag = v1 | 0x20;
    return -1;
  }
  v2 = v1 | 1;
  a1->_flag = v2;
  if ( v2 & 0x10C )
    a1->_ptr = a1->_base;
  else
    _getbuf(a1);
  v3 = a1->_bufsiz;
  v4 = a1->_base;
  v5 = _fileno(a1);
  v6 = _read(v5, v4, v3);
  a1->_cnt = v6;
  if ( !v6 || v6 == -1 )
  {
    a1->_flag |= v6 != 0 ? 32 : 16;
    a1->_cnt = 0;
    return -1;
  }
  if ( !(a1->_flag & 0x82) )
  {
    if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
    {
      v8 = &unk_100DA340;
    }
    else
    {
      v7 = &dword_102554A0[_fileno(a1) >> 5];
      v8 = (_BYTE *)(*v7 + ((_fileno(a1) & 0x1F) << 6));
    }
    if ( (v8[4] & 0x82) == -126 )
      a1->_flag |= 0x2000u;
  }
  if ( a1->_bufsiz == 512 )
  {
    v9 = a1->_flag;
    if ( v9 & 8 )
    {
      if ( !(v9 & 0x400) )
        a1->_bufsiz = 4096;
    }
  }
  v10 = a1->_ptr;
  --a1->_cnt;
  result = (unsigned __int8)*v10;
  a1->_ptr = v10 + 1;
  return result;
}
// 1003A170: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10042B7C: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 102554A0: using guessed type int dword_102554A0[];

//----- (1004556C) --------------------------------------------------------
int __cdecl sub_1004556C(int a1, FILE *a2)
{
  int *v2; // edi@4
  _BYTE *v3; // eax@4
  int *v4; // edi@9
  _BYTE *v5; // eax@9
  int v7; // eax@16
  char *v8; // eax@24
  int v9; // eax@28

  if ( !(a2->_flag & 0x40) )
  {
    if ( _fileno(a2) == -1 || _fileno(a2) == -2 )
    {
      v3 = &unk_100DA340;
    }
    else
    {
      v2 = &dword_102554A0[_fileno(a2) >> 5];
      v3 = (_BYTE *)(*v2 + ((_fileno(a2) & 0x1F) << 6));
    }
    if ( v3[36] & 0x7F
      || (_fileno(a2) == -1 || _fileno(a2) == -2 ? (v5 = &unk_100DA340) : (v4 = &dword_102554A0[_fileno(a2) >> 5],
                                                                           v5 = (_BYTE *)(*v4
                                                                                        + ((_fileno(a2) & 0x1F) << 6))),
          v5[36] & 0x80) )
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
  }
  if ( a1 == -1 )
    return -1;
  v7 = a2->_flag;
  if ( !(v7 & 1) && ((char)v7 >= 0 || v7 & 2) )
    return -1;
  if ( !a2->_base )
    _getbuf(a2);
  if ( a2->_ptr == a2->_base )
  {
    if ( a2->_cnt )
      return -1;
    ++a2->_ptr;
  }
  v8 = --a2->_ptr;
  if ( a2->_flag & 0x40 )
  {
    if ( *v8 != (_BYTE)a1 )
    {
      a2->_ptr = v8 + 1;
      return -1;
    }
  }
  else
  {
    *v8 = a1;
  }
  v9 = a2->_flag;
  ++a2->_cnt;
  a2->_flag = v9 & 0xFFFFFFEF | 1;
  return (unsigned __int8)a1;
}
// 1003A170: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10042B7C: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 102554A0: using guessed type int dword_102554A0[];

//----- (100457B4) --------------------------------------------------------
int sub_100457B4()
{
  return 0;
}

//----- (10045F99) --------------------------------------------------------
signed int __cdecl sub_10045F99(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_100DB294 - 1;
    v64 = v3;
    v65 = dword_100DB294 / 32;
    v9 = dword_100DB294 % 32;
    v10 = (int *)(&v60 + dword_100DB294 / 32);
    v66 = 31 - dword_100DB294 % 32;
    if ( (1 << (31 - dword_100DB294 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_100DB290 - dword_100DB294 )
    {
      if ( v3 > dword_100DB290 )
      {
        if ( v3 < dword_100DB28C )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_100DB2A0 + v3;
          v50 = dword_100DB298 / 32;
          v51 = dword_100DB298 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_100DB298 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_100DB298 / 32;
          v44 = dword_100DB298 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_100DB298 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_100DB2A0 + dword_100DB28C;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_100DB290 - v64) / 32;
      v62 = v59;
      v18 = (dword_100DB290 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_100DB294 - 1;
      v25 = dword_100DB294 / 32;
      v65 = dword_100DB294 / 32;
      v26 = (int *)(&v60 + dword_100DB294 / 32);
      v64 = 31 - dword_100DB294 % 32;
      if ( (1 << (31 - dword_100DB294 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_100DB294 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_100DB298 + 1) / 32;
      v37 = (dword_100DB298 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_100DB298));
  if ( dword_100DB29C == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_100DB29C == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 100DB28C: using guessed type int dword_100DB28C;
// 100DB290: using guessed type int dword_100DB290;
// 100DB294: using guessed type int dword_100DB294;
// 100DB298: using guessed type int dword_100DB298;
// 100DB29C: using guessed type int dword_100DB29C;
// 100DB2A0: using guessed type int dword_100DB2A0;

//----- (100464DB) --------------------------------------------------------
signed int __cdecl sub_100464DB(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_100DB2AC - 1;
    v64 = v3;
    v65 = dword_100DB2AC / 32;
    v9 = dword_100DB2AC % 32;
    v10 = (int *)(&v60 + dword_100DB2AC / 32);
    v66 = 31 - dword_100DB2AC % 32;
    if ( (1 << (31 - dword_100DB2AC % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_100DB2A8 - dword_100DB2AC )
    {
      if ( v3 > dword_100DB2A8 )
      {
        if ( v3 < dword_100DB2A4 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_100DB2B8 + v3;
          v50 = dword_100DB2B0 / 32;
          v51 = dword_100DB2B0 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_100DB2B0 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_100DB2B0 / 32;
          v44 = dword_100DB2B0 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_100DB2B0 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_100DB2B8 + dword_100DB2A4;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_100DB2A8 - v64) / 32;
      v62 = v59;
      v18 = (dword_100DB2A8 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_100DB2AC - 1;
      v25 = dword_100DB2AC / 32;
      v65 = dword_100DB2AC / 32;
      v26 = (int *)(&v60 + dword_100DB2AC / 32);
      v64 = 31 - dword_100DB2AC % 32;
      if ( (1 << (31 - dword_100DB2AC % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_100DB2AC % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_100DB2B0 + 1) / 32;
      v37 = (dword_100DB2B0 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_100DB2B0));
  if ( dword_100DB2B4 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_100DB2B4 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 100DB2A4: using guessed type int dword_100DB2A4;
// 100DB2A8: using guessed type int dword_100DB2A8;
// 100DB2AC: using guessed type int dword_100DB2AC;
// 100DB2B0: using guessed type int dword_100DB2B0;
// 100DB2B4: using guessed type int dword_100DB2B4;
// 100DB2B8: using guessed type int dword_100DB2B8;

//----- (10047DD4) --------------------------------------------------------
signed int __cdecl sub_10047DD4(signed int a1)
{
  int *v1; // edi@3
  int v2; // esi@3
  int v3; // eax@3
  DWORD v5; // [sp-8h] [bp-14h]@9

  if ( a1 >= 0 && a1 < uNumber )
  {
    v1 = &dword_102554A0[a1 >> 5];
    v2 = (a1 & 0x1F) << 6;
    v3 = v2 + *v1;
    if ( *(_BYTE *)(v3 + 4) & 1 )
    {
      if ( *(_DWORD *)v3 != -1 )
      {
        if ( dword_10246248 == 1 )
        {
          if ( !a1 )
          {
            v5 = -10;
            goto LABEL_12;
          }
          if ( a1 == 1 )
          {
            v5 = -11;
            goto LABEL_12;
          }
          if ( a1 == 2 )
          {
            v5 = -12;
LABEL_12:
            SetStdHandle(v5, 0);
            goto LABEL_13;
          }
        }
LABEL_13:
        *(_DWORD *)(v2 + *v1) = -1;
        return 0;
      }
    }
  }
  *_errno() = 9;
  *__doserrno() = 0;
  return -1;
}
// 10246248: using guessed type int dword_10246248;
// 102554A0: using guessed type int dword_102554A0[];

//----- (10047E55) --------------------------------------------------------
signed int __cdecl sub_10047E55(signed int a1)
{
  signed int result; // eax@2
  int v2; // eax@5

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    result = -1;
  }
  else if ( a1 >= 0 && a1 < uNumber && (v2 = dword_102554A0[a1 >> 5] + ((a1 & 0x1F) << 6), *(_BYTE *)(v2 + 4) & 1) )
  {
    result = *(_DWORD *)v2;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  return result;
}
// 1003A170: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 102554A0: using guessed type int dword_102554A0[];

//----- (10047F66) --------------------------------------------------------
void __cdecl sub_10047F66(signed int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(dword_102554A0[a1 >> 5] + ((a1 & 0x1F) << 6) + 12));
}
// 102554A0: using guessed type int dword_102554A0[];

//----- (10048267) --------------------------------------------------------
int sub_10048267()
{
  return flsall(1);
}
// 1004818D: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (100484C4) --------------------------------------------------------
int __cdecl sub_100484C4(int a1, int a2, int a3)
{
  HMODULE v3; // eax@2
  HMODULE v4; // edi@2
  FARPROC v5; // eax@3
  FARPROC v6; // eax@4
  FARPROC v7; // eax@4
  FARPROC v8; // eax@7
  FARPROC v9; // eax@8
  int (*v10)(void); // esi@11
  int (__stdcall *v11)(int, signed int, char *, signed int, char *); // eax@11
  int (__stdcall *v12)(int, signed int, char *, signed int, char *); // edi@11
  int v13; // eax@13
  int (*v14)(void); // eax@22
  int (__stdcall *v15)(int); // eax@25
  int (__stdcall *v16)(int, int, int, int); // eax@27
  char v18; // [sp+10h] [bp-20h]@14
  char v19; // [sp+18h] [bp-18h]@15
  char v20; // [sp+1Ch] [bp-14h]@14
  unsigned int v21; // [sp+20h] [bp-10h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+28h] [bp-8h]@1
  int v24; // [sp+2Ch] [bp-4h]@1

  v23 = _encoded_null();
  v24 = 0;
  v22 = 0;
  v21 = 0;
  if ( !dword_10246BE4 )
  {
    v3 = LoadLibraryA("USER32.DLL");
    v4 = v3;
    if ( !v3 )
      return 0;
    v5 = GetProcAddress(v3, "MessageBoxA");
    if ( !v5 )
      return 0;
    dword_10246BE4 = _encode_pointer(v5);
    v6 = GetProcAddress(v4, "GetActiveWindow");
    dword_10246BE8 = _encode_pointer(v6);
    v7 = GetProcAddress(v4, "GetLastActivePopup");
    dword_10246BEC = _encode_pointer(v7);
    if ( sub_1003B877(&v22) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v22 == 2 )
    {
      v8 = GetProcAddress(v4, "GetUserObjectInformationA");
      dword_10246BF4 = _encode_pointer(v8);
      if ( dword_10246BF4 )
      {
        v9 = GetProcAddress(v4, "GetProcessWindowStation");
        dword_10246BF0 = _encode_pointer(v9);
      }
    }
  }
  if ( dword_10246BF0 == v23
    || dword_10246BF4 == v23
    || (v10 = (int (*)(void))_decode_pointer(dword_10246BF0),
        v11 = (int (__stdcall *)(int, signed int, char *, signed int, char *))_decode_pointer(dword_10246BF4),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, &v18, 12, &v20) && v19 & 1 )
  {
    if ( dword_10246BE8 != v23 )
    {
      v14 = (int (*)(void))_decode_pointer(dword_10246BE8);
      if ( v14 )
      {
        v24 = v14();
        if ( v24 )
        {
          if ( dword_10246BEC != v23 )
          {
            v15 = (int (__stdcall *)(int))_decode_pointer(dword_10246BEC);
            if ( v15 )
              v24 = v15(v24);
          }
        }
      }
    }
  }
  else
  {
    if ( sub_1003B8AE(&v21) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v21 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_10246BE4);
  if ( v16 )
    return v16(v24, a1, a2, a3);
  return 0;
}
// 1003A074: using guessed type int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1003BB36: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 1003BBA4: using guessed type int _encoded_null(void);
// 1003BBAD: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 10246BE4: using guessed type int dword_10246BE4;
// 10246BE8: using guessed type int dword_10246BE8;
// 10246BEC: using guessed type int dword_10246BEC;
// 10246BF0: using guessed type int dword_10246BF0;
// 10246BF4: using guessed type int dword_10246BF4;

//----- (100494B1) --------------------------------------------------------
signed int __cdecl sub_100494B1(signed int a1)
{
  signed int v1; // edi@6
  void *v2; // eax@7
  DWORD v3; // edi@8
  signed int result; // eax@11

  if ( sub_10047E55(a1) == -1
    || (a1 == 1 && *(_BYTE *)(dword_102554A0[0] + 132) & 1 || a1 == 2 && *(_BYTE *)(dword_102554A0[0] + 68) & 1)
    && (v1 = sub_10047E55(2), sub_10047E55(1) == v1)
    || (v2 = (void *)sub_10047E55(a1), CloseHandle(v2)) )
  {
    v3 = 0;
  }
  else
  {
    v3 = GetLastError();
  }
  sub_10047DD4(a1);
  *(_BYTE *)(dword_102554A0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) = 0;
  if ( v3 )
  {
    _dosmaperr(v3);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100387FC: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 102554A0: using guessed type int dword_102554A0[];

//----- (10049690) --------------------------------------------------------
signed int __cdecl sub_10049690(unsigned int a1, int a2, int a3, int a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  signed int result; // eax@3

  v4 = sub_10049750(a1);
  v5 = v4;
  if ( v4 < 0xFFFFFFC2 && v4 )
  {
    if ( sub_1004A670(v4, a4, 0) == a4 )
      result = sub_1004A610(v5, a2, a3);
    else
      result = -15;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (100496F0) --------------------------------------------------------
signed int __cdecl sub_100496F0(unsigned int a1, int a2, int a3)
{
  unsigned int v3; // eax@1

  v3 = sub_10049750(a1);
  return sub_1004A670(v3, a2, a3);
}

//----- (10049720) --------------------------------------------------------
bool sub_10049720()
{
  return sub_10032F60(99) == 0;
}

//----- (10049730) --------------------------------------------------------
bool sub_10049730()
{
  return sub_10032F80(99, 10000) == 0;
}

//----- (10049750) --------------------------------------------------------
unsigned int __cdecl sub_10049750(unsigned int a1)
{
  unsigned int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = a1 & 0xFFFFFFFC;
  else
    result = 0;
  return result;
}

//----- (10049770) --------------------------------------------------------
bool __cdecl sub_10049770(int a1)
{
  bool result; // al@1
  unsigned int v2; // eax@4
  _DWORD *v3; // edx@4
  _DWORD *v4; // esi@4
  int v5; // ecx@8
  int v6; // eax@9
  _BYTE *v7; // edx@9
  _BYTE *v8; // esi@9
  int v9; // eax@11
  _BYTE *v10; // edx@11
  _BYTE *v11; // esi@11
  _BYTE *v12; // edx@13
  _BYTE *v13; // esi@13
  int v14; // edx@14
  signed int v15; // eax@15

  result = *(_DWORD *)(a1 + 88) == ~*(_DWORD *)(a1 + 36);
  if ( *(_WORD *)(a1 + 30) != 99 || !result && *(_WORD *)(a1 + 684) != 2 )
    return result;
  v2 = 10;
  v3 = (_DWORD *)(a1 + 693);
  v4 = (_DWORD *)(a1 + 721);
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_8;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_17:
    v15 = 0;
    return v15 == 0;
  }
LABEL_8:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_17;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_17;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_17;
        v14 = *v12;
        v5 = *v13 - v14;
        if ( *v13 == v14 )
          goto LABEL_17;
      }
    }
  }
  v15 = 1;
  if ( v5 <= 0 )
    return 0;
  return v15 == 0;
}

//----- (10049840) --------------------------------------------------------
int __cdecl sub_10049840(int a1)
{
  return *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 32) + *(_WORD *)(a1 + 28) + 46;
}

//----- (10049860) --------------------------------------------------------
int __cdecl sub_10049860(int a1, int a2)
{
  int result; // eax@2

  if ( a2 )
    result = *(_WORD *)(a2 + 28) + *(_WORD *)(a2 + 26) + 30;
  else
    result = -16 - *(_WORD *)(a1 + 52) + sub_10049840(a1 + 20);
  return result;
}

//----- (100498A0) --------------------------------------------------------
signed int __cdecl sub_100498A0(int a1, void *a2, unsigned __int16 a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // ebp@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 732);
  v6 = 0;
  result = -15;
  v8 = *(_WORD *)(a1 + 48) + *(_DWORD *)(a1 + 16) + 46;
  if ( *(_WORD *)(a1 + 50) >= 4u )
  {
    while ( (unsigned int)(v6 + v8) < *(_DWORD *)(v5 + 120) )
    {
      if ( sub_10033870(*(_DWORD *)(v5 + 4), &a1, 4, v6 + v8, 0) != 4 )
        return -15;
      if ( (_WORD)a1 == a4 && (unsigned int)HIWORD(a1) + 4 <= a3 )
        return sub_10033870(*(_DWORD *)(v5 + 4), a2, HIWORD(a1) + 4, v6 + v8, 0);
      v6 += HIWORD(a1) + 4;
      result = -15;
      if ( v6 + 4 > (unsigned int)*(_WORD *)(v4 + 50) )
        return result;
    }
  }
  return result;
}

//----- (10049960) --------------------------------------------------------
int __cdecl sub_10049960(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (100499A0) --------------------------------------------------------
int __usercall sub_100499A0@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // eax@2
  int result; // eax@2
  int v4; // eax@3
  __int16 v5; // cx@3
  int v6; // edx@3

  sub_1004E3D0(a2 + 721, a1 + 64);
  if ( *(_DWORD *)(a2 + 44) )
  {
    v4 = *(_DWORD *)(a2 + 725);
    v5 = *(_WORD *)(a2 + 729);
    *(_DWORD *)(a2 + 693) = *(_DWORD *)(a2 + 721);
    v6 = *(_DWORD *)(a2 + 732);
    *(_DWORD *)(a2 + 697) = v4;
    *(_WORD *)(a2 + 701) = v5;
    result = j_FIL_vfs_write(*(_DWORD *)(v6 + 116), a2 + 721, 10);
    *(_DWORD *)(a2 + 136) += 10;
    *(_DWORD *)(a2 + 40) += 10;
  }
  else
  {
    v2 = sub_10033950(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116));
    result = sub_10033970(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), v2 - *(_WORD *)(a2 + 50) - *(_DWORD *)(a2 + 40), 0);
    *(_DWORD *)(a2 + 84) -= *(_WORD *)(a2 + 50);
    *(_DWORD *)(a2 + 136) = 0;
    *(_WORD *)(a2 + 28) &= 0xFFFEu;
    *(_DWORD *)(a2 + 40) = 0;
    *(_WORD *)(a2 + 50) = 0;
    *(_WORD *)(a2 + 30) = 0;
    *(_WORD *)(a2 + 80) = 0;
  }
  return result;
}
// 10033990: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10049A50) --------------------------------------------------------
signed int __usercall sub_10049A50@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  char v3; // ST30_1@2
  int v4; // ST28_4@2
  int v5; // eax@2
  __int64 v6; // rax@2
  int v7; // ebx@2
  char *v8; // ebp@2
  __int64 v9; // rax@3
  signed int result; // eax@4
  _WORD *v11; // edi@5
  _WORD *v12; // [sp+Ch] [bp-4h]@4

  v2 = a1;
  if ( *(_BYTE *)(a2 + 8) )
  {
    *(_WORD *)(a1 + 532) = -26367;
    *(_WORD *)(a1 + 534) = 7;
    *(_WORD *)(a1 + 536) = 1;
    *(_BYTE *)(a1 + 538) = 65;
    *(_BYTE *)(a1 + 539) = 69;
    v3 = *(_DWORD *)(a2 + 84);
    *(_DWORD *)(a2 + 76) = a1 + 532;
    v4 = a1 + 532;
    v5 = *(_DWORD *)(a2 + 732);
    *(_WORD *)(a2 + 50) = 11;
    *(_WORD *)(a2 + 80) = 11;
    sub_100339A0(*(_DWORD *)(v5 + 116), v4, 11, v3);
    *(_DWORD *)(a2 + 84) += *(_WORD *)(a2 + 80);
    *(_BYTE *)(v2 + 540) = *(_BYTE *)(*(_DWORD *)(a2 + 732) + 112);
    v6 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v6) & 7) + (signed int)v6) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_1004E820((void *)(v2 + 555), v7);
  }
  else
  {
    sub_100498A0(a2, (void *)(a1 + 532), 0xBu, -26367);
    v9 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v9) & 7) + (signed int)v9) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_10033870(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 555), v7, *(_DWORD *)(a2 + 84), 0);
    sub_10033870(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 571), 2, v7 + *(_DWORD *)(a2 + 84), 0);
  }
  v12 = (_WORD *)(v2 + 543);
  result = sub_1004E6F0(*(_BYTE *)(v2 + 540), (void *)v2, strlen((const char *)v2), v8, (_WORD *)(v2 + 543), v2 + 64);
  if ( *(_BYTE *)(a2 + 8) )
  {
    sub_100339A0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v8, v7, *(_DWORD *)(a2 + 84));
    v11 = (_WORD *)(v2 + 571);
    *v11 = *v12;
    sub_100339A0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v11, 2, v7 + *(_DWORD *)(a2 + 84));
    result = v7 + 2;
    *(_DWORD *)(a2 + 136) += v7 + 2;
    *(_DWORD *)(a2 + 40) += v7 + 2;
  }
  else
  {
    *(_DWORD *)(a2 + 92) += -12 - v7;
    *(_DWORD *)(a2 + 124) += v7 + 2;
  }
  return result;
}

//----- (10049C20) --------------------------------------------------------
char __usercall sub_10049C20@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  return sub_1004E380(a2, a3, a1 + 212);
}

//----- (10049C30) --------------------------------------------------------
int __usercall sub_10049C30@<eax>(int result@<eax>)
{
  if ( *(_WORD *)(result + 30) == 99 )
    result = sub_100499A0(result + 148, result);
  return result;
}

//----- (10049C50) --------------------------------------------------------
char __usercall sub_10049C50@<al>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = (*(_DWORD *)(a1 + 72) & 0xFFFD | 2) * ((*(_DWORD *)(a1 + 72) & 0xFFFD | 2) ^ 1);
  return BYTE1(v1);
}

//----- (10049C70) --------------------------------------------------------
int __usercall sub_10049C70@<eax>(int a1@<esi>, unsigned __int8 a2)
{
  int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@1
  int result; // eax@1

  v2 = sub_10035DA0(a2, *(_DWORD *)(a1 + 64));
  v3 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 64) = v2;
  v4 = 134775813 * (*(_DWORD *)(a1 + 68) + (unsigned __int8)v2) + 1;
  *(_DWORD *)(a1 + 68) = v4;
  result = sub_10035DA0(BYTE3(v4), v3);
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

//----- (10049CB0) --------------------------------------------------------
int __fastcall sub_10049CB0(int a1, int a2)
{
  int result; // eax@1

  result = *(_WORD *)(a2 + 30);
  if ( *(_WORD *)(a2 + 30) == 99 )
    result = *(_WORD *)(a2 + 689);
  return result;
}

//----- (10049CD0) --------------------------------------------------------
int __usercall sub_10049CD0@<eax>(int a1@<esi>)
{
  int v1; // ST1C_4@1
  unsigned int v2; // ST18_4@1
  int v3; // eax@1
  int v4; // ST00_4@1

  v1 = *(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 24);
  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = v1;
  sub_100339F0(v2, v1, 0);
  j_FIL_vfs_write(*(_DWORD *)(a1 + 4), a1 + 8, 22);
  v3 = *(_DWORD *)a1 + 22;
  v4 = *(_DWORD *)(a1 + 116);
  *(_DWORD *)(a1 + 120) = v3;
  return sub_10033970(v4, v3, 0);
}
// 10033990: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10049D10) --------------------------------------------------------
signed int __usercall sub_10049D10@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6)
{
  __int16 v6; // ax@1
  unsigned int *v7; // ecx@1
  int v8; // esi@1
  signed int v9; // eax@1
  unsigned int v10; // eax@1
  int v11; // ebx@1
  int v12; // ebx@1
  int v13; // eax@4
  int v14; // ecx@6
  int v15; // ebp@8
  unsigned int v16; // ebx@11
  __int64 v17; // rax@14
  unsigned int v18; // ecx@15
  unsigned int v19; // ebp@15
  int v21; // ebx@20
  signed int v22; // eax@23
  size_t v23; // ebp@29
  int v24; // ebx@33
  int v25; // [sp+Ch] [bp-8h]@1
  __int16 v26; // [sp+10h] [bp-4h]@1

  v6 = sub_10049CB0(a1, a3);
  v7 = *(unsigned int **)(a2 + 16);
  v8 = a2 + 28;
  v26 = v6;
  *(_DWORD *)v8 = v7;
  v9 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v8 + 4) = v9;
  v25 = 0;
  v10 = sub_10035DC0(v7, v9, *(_DWORD *)a2);
  v11 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)a2 = v10;
  v12 = v11 + 0xFFFFF;
  while ( 1 )
  {
    if ( !*(_DWORD *)(a2 + 32) )
    {
      if ( !a6 )
        goto LABEL_37;
      v13 = *(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(a2 + 44) == v13 && v12 != v13 + 0xFFFFF )
        break;
    }
    v14 = *(_DWORD *)(a2 + 12);
    if ( !v14 )
      break;
    if ( !--v12 )
      break;
    v15 = *(_DWORD *)(a2 + 44);
    if ( !v15 || a6 && v15 != v14 )
    {
      v16 = *(_DWORD *)(a2 + 48);
      if ( v16
        && (v16 >= 0x28
         || *(_WORD *)(a3 + 30) != 99
         || (v17 = ((*(_BYTE *)(a3 + 688) & 3) + 1) << 6, v16 != (((BYTE4(v17) & 7) + (signed int)v17) >> 3) / 2 + 2)) )
      {
        v18 = v14 - v15;
        v19 = v18;
        if ( *(_BYTE *)(a3 + 28) & 1 )
          sub_10049C20(a3, *(char **)(a2 + 8), v18);
        if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v19) != v19 )
          return -16;
      }
      else
      {
        v19 = 0;
      }
      v21 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
      v12 = v21 + 0xFFFFF;
      v25 += v19;
      *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    }
    if ( v26 == 8 )
    {
      if ( a6 )
        v22 = sub_100505D0(a2 + 28, 4);
      else
        v22 = sub_100505D0(a2 + 28, 0);
      if ( v22 && v22 != 1 )
        return -15;
    }
    else
    {
      if ( v26 )
        return -15;
      v23 = *(_DWORD *)(a2 + 44);
      if ( *(_DWORD *)(a2 + 32) < v23 )
        v23 = *(_DWORD *)(a2 + 32);
      memcpy(*(void **)(a2 + 40), *(const void **)v8, v23);
      *(_DWORD *)(a2 + 32) -= v23;
      *(_DWORD *)(a2 + 44) -= v23;
      *(_DWORD *)v8 += v23;
      *(_DWORD *)(a2 + 40) += v23;
      *(_DWORD *)(a2 + 36) += v23;
      *(_DWORD *)(a2 + 48) += v23;
    }
  }
  if ( a6 )
  {
    v24 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44);
    if ( *(_BYTE *)(a3 + 28) & 1 )
      sub_10049C20(a3, *(char **)(a2 + 8), *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44));
    if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v24) != v24 )
      return -16;
    v25 += v24;
    *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
  }
LABEL_37:
  *(_DWORD *)(a5 + 24) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a5 + 20) = *(_DWORD *)(a2 + 48);
  return v25;
}
// 10033990: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10049F20) --------------------------------------------------------
int __cdecl sub_10049F20(int a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  unsigned int v3; // ebp@1
  bool v4; // zf@1
  int v5; // ecx@1
  __int16 v6; // cx@4
  __int16 v7; // ax@4
  __int16 v8; // dx@4
  __int16 v9; // cx@4
  unsigned int v10; // edx@4
  int v11; // eax@4
  unsigned int v12; // ecx@4
  int v13; // eax@4
  int result; // eax@5
  int v15; // eax@6
  unsigned __int16 v16; // ax@7
  int v17; // eax@11
  int v18; // edx@13
  int v19; // edi@13
  int v20; // eax@13
  unsigned __int16 v21; // cx@14
  int v22; // [sp+10h] [bp-28h]@4
  char v23; // [sp+14h] [bp-24h]@3
  int v24; // [sp+18h] [bp-20h]@1
  int v25; // [sp+1Ch] [bp-1Ch]@1
  int v26; // [sp+20h] [bp-18h]@1
  int v27; // [sp+24h] [bp-14h]@1
  __int64 v28; // [sp+28h] [bp-10h]@1
  int v29; // [sp+30h] [bp-8h]@1
  __int16 v30; // [sp+34h] [bp-4h]@1
  int v31; // [sp+3Ch] [bp+4h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 732);
  v31 = *(_DWORD *)(v2 + 116);
  sub_10049C30(v1);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_WORD *)(v1 + 32) == 0;
  v5 = ~*(_DWORD *)(v1 + 88);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0i64;
  v29 = 0;
  v30 = 0;
  *(_DWORD *)(v1 + 36) = v5;
  if ( v4 || !*(_WORD *)(v1 + 34) )
  {
    sub_10018720(&v23);
    sub_10013AF0((unsigned int *)&v23, (_WORD *)(v1 + 34), (_WORD *)(v1 + 32));
  }
  v6 = *(_WORD *)(v1 + 24);
  v7 = *(_WORD *)(v1 + 30);
  HIWORD(v25) = *(_WORD *)(v1 + 28);
  v8 = *(_WORD *)(v1 + 34);
  LOWORD(v25) = v6;
  v9 = *(_WORD *)(v1 + 32);
  LOWORD(v27) = v8;
  v10 = *(_DWORD *)(v1 + 44);
  LOWORD(v26) = v7;
  v11 = *(_DWORD *)(v1 + 36);
  HIWORD(v26) = v9;
  v12 = *(_DWORD *)(v1 + 40);
  *(int *)((char *)&v27 + 2) = v11;
  LOWORD(v11) = *(_WORD *)(v1 + 48);
  *(__int64 *)((char *)&v28 + 2) = __PAIR__(v10, v12);
  LOWORD(v12) = *(_WORD *)(v1 + 50);
  v24 = 67324752;
  HIWORD(v29) = v11;
  v30 = v12;
  v22 = sub_10049860(v1, (int)&v24);
  v13 = sub_10033950(v31);
  if ( v3 == v31 )
  {
    result = sub_100337C0(v31, v13, v31, *(_DWORD *)(v2 + 24), *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v15 = *(_DWORD *)(v2 + 24);
    *(_DWORD *)(v1 + 62) = v15;
    *(_DWORD *)(v1 + 84) = v22 + v15;
  }
  sub_100339F0(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 62), 0);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), &v24, 30);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72));
  v16 = *(_WORD *)(v1 + 80);
  if ( v16 )
    j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 76), v16);
  if ( v3 == v31 )
  {
    result = sub_100337C0(
               v31,
               *(_DWORD *)(v1 + 84),
               v31,
               v22 + *(_DWORD *)(v2 + 120),
               *(_DWORD *)(v1 + 40) + *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v17 = *(_DWORD *)((char *)&v28 + 2) + v22 + *(_DWORD *)(v2 + 24);
  }
  else
  {
    v17 = 0;
  }
  v18 = v17 + *(_DWORD *)(v2 + 20);
  ++*(_WORD *)(v2 + 16);
  ++*(_WORD *)(v2 + 18);
  *(_DWORD *)(v2 + 8) = 101010256;
  *(_DWORD *)(v2 + 24) = v17;
  *(_WORD *)(v2 + 28) = 0;
  sub_100339F0(v3, v18, 0);
  *(_DWORD *)(v2 + 20) += sub_10049840(v1 + 20);
  j_FIL_vfs_write(v3, v1 + 20, 46);
  v19 = j_FIL_vfs_write(v3, *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72)) != *(_WORD *)(v1 + 72) ? 0xFFFFFFF1 : 0;
  v20 = *(_DWORD *)(v1 + 76);
  if ( v20 )
  {
    v21 = *(_WORD *)(v1 + 80);
    if ( v21 )
    {
      v19 |= j_FIL_vfs_write(v3, v20, v21);
      if ( v19 >= 0 )
        v19 = 0;
    }
  }
  *(_DWORD *)v2 = *(_DWORD *)(v2 + 20) + *(_DWORD *)(v2 + 24);
  if ( v3 == v31 )
    sub_10049CD0(v2);
  else
    *(_DWORD *)(v2 + 120) = sub_10033950(v31);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(v2 + 24);
  *(_DWORD *)(v2 + 32) = 0;
  return v19;
}
// 10033990: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (1004A190) --------------------------------------------------------
signed int __cdecl sub_1004A190(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ecx@7
  int v5; // eax@10

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    if ( *(_DWORD *)(a1 + 112) == *(_DWORD *)(a1 + 44) && !*(_DWORD *)(a1 + 124) )
      sub_100339F0(*(_DWORD *)(*(_DWORD *)(a1 + 732) + 116), *(_DWORD *)(a1 + 136) + *(_DWORD *)(a1 + 84), 0);
    v4 = *(_DWORD *)(a1 + 112) - a3;
    *(_DWORD *)(a1 + 104) = a2;
    *(_DWORD *)(a1 + 108) = a3;
    v5 = !v4 && *(_DWORD *)(a1 + 136) || !a2;
    result = sub_10049D10(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 88,
               a1,
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 20,
               v5);
    if ( result >= 0 )
    {
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 136);
      *(_DWORD *)(a1 + 112) -= a3;
    }
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (1004A230) --------------------------------------------------------
int __usercall sub_1004A230@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // al@1
  unsigned __int8 *v3; // edx@1

  v1 = a1;
  v2 = sub_10049C50(a1);
  *v3 ^= v2;
  return sub_10049C70(v1, *v3);
}

//----- (1004A250) --------------------------------------------------------
int __usercall sub_1004A250@<eax>(int a1@<edi>, int a2)
{
  int i; // esi@1
  int result; // eax@2

  for ( i = 0; i < a1; ++i )
    result = sub_1004A230(a2);
  return result;
}

//----- (1004A280) --------------------------------------------------------
signed int __usercall sub_1004A280@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // esi@1
  signed int v3; // edi@1
  signed int result; // eax@4

  v2 = a1;
  *(_DWORD *)(a1 + 64) = 305419896;
  *(_DWORD *)(a1 + 68) = 591751049;
  *(_DWORD *)(a1 + 72) = 878082192;
  v3 = 0;
  do
  {
    if ( !*(_BYTE *)(v3 + v2) )
      break;
    sub_10049C70(v2, *(_BYTE *)(v3++ + v2));
  }
  while ( v3 < 64 );
  result = sub_10033870(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 76), 12, *(_DWORD *)(a2 + 84), 0);
  *(_DWORD *)(a2 + 92) -= 12;
  *(_DWORD *)(a2 + 124) += 12;
  return result;
}

//----- (1004A370) --------------------------------------------------------
char __usercall sub_1004A370@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>)
{
  char result; // al@2

  if ( *(_WORD *)(a3 + 30) == 99 )
    result = sub_1004E330(a1, a2, a3 + 212);
  else
    result = sub_1004A250(a2, a3 + 148);
  return result;
}

//----- (1004A3A0) --------------------------------------------------------
signed int __usercall sub_1004A3A0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@1
  int v3; // eax@1
  signed int result; // eax@2

  v1 = a1;
  v2 = *(_WORD *)(a1 + 30) == 99;
  v3 = a1 + 148;
  if ( v2 )
    result = sub_10049A50(v3, v1);
  else
    result = sub_1004A280(v3, v1);
  return result;
}

//----- (1004A3D0) --------------------------------------------------------
signed int __cdecl sub_1004A3D0(unsigned int a1)
{
  signed int result; // eax@3
  int v2; // eax@4
  int v3; // ecx@4
  int v4; // edx@4

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    sub_10049960(a1 + 116);
    v2 = *(_DWORD *)(a1 + 40);
    v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 88) = -1;
    *(_DWORD *)(a1 + 92) = v2;
    *(_DWORD *)(a1 + 112) = v3;
    sub_10052040(v4);
    if ( *(_BYTE *)(a1 + 28) & 1 )
      sub_1004A3A0(a1);
    result = 0;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (1004A420) --------------------------------------------------------
signed int __cdecl sub_1004A420(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned int v5; // ecx@1
  signed int v6; // eax@4
  size_t v8; // eax@9
  size_t v9; // ebx@10
  int v10; // esi@13
  int v11; // edx@18
  __int16 v12; // ax@20
  size_t v13; // esi@21
  int v14; // ST30_4@25
  unsigned int *v15; // ST34_4@25
  int v16; // ebx@25
  int v17; // [sp+10h] [bp-Ch]@1
  int v18; // [sp+24h] [bp+8h]@7

  v2 = a2;
  v3 = a2 + 28;
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 20);
  v5 = *(_DWORD *)(a2 + 24);
  v17 = 0;
  if ( v4 <= v5 )
    *(_DWORD *)(a2 + 44) = v4;
  else
    *(_DWORD *)(a2 + 44) = v5;
  v6 = 0xFFFFF;
  if ( *(_DWORD *)(a2 + 44) )
  {
    while ( 1 )
    {
      v18 = v6 - 1;
      if ( v6 - 1 <= 0 )
        break;
      if ( *(_DWORD *)(v3 + 4) || (v8 = *(_DWORD *)(v2 + 4)) == 0 )
      {
        v10 = a1;
      }
      else
      {
        v9 = *(_DWORD *)(v2 + 12);
        if ( v8 < v9 )
          v9 = *(_DWORD *)(v2 + 4);
        if ( !v9 )
          return v17;
        v10 = a1;
        if ( sub_10033870(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               *(void **)(v2 + 8),
               v9,
               *(_DWORD *)(a1 + 84) + *(_DWORD *)(v3 + 8),
               0) != v9 )
          return -15;
        if ( *(_BYTE *)(a1 + 28) & 1 )
        {
          sub_1004A370(*(char **)(v2 + 8), v9, a1);
          if ( *(_DWORD *)(v2 + 4) == v9 && *(_WORD *)(a1 + 30) == 99 )
          {
            sub_10033870(
              *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
              (void *)(a1 + 721),
              10,
              *(_DWORD *)(a1 + 84) + v9 + *(_DWORD *)(v3 + 4) + *(_DWORD *)(v3 + 8),
              0);
            sub_1004E3D0(a1 + 693, a1 + 212);
            v10 = a1;
          }
        }
        v11 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 4) -= v9;
        v18 = 0xFFFFF;
        *(_DWORD *)v3 = v11;
        *(_DWORD *)(v3 + 4) = v9;
      }
      v12 = sub_10049CB0(v5, v10);
      if ( v12 )
      {
        if ( v12 != 8 )
          return -15;
        v14 = *(_DWORD *)(v3 + 20);
        v15 = *(unsigned int **)(v3 + 12);
        v16 = (char)sub_10053400(v3, 2);
        v17 += *(_DWORD *)(v3 + 20) - v14;
        *(_DWORD *)v2 = sub_10035DC0(v15, *(_DWORD *)(v3 + 20) - v14, *(_DWORD *)v2);
        if ( v16 == 1 )
          return v17;
        if ( v16 < 0 )
          return -14;
      }
      else
      {
        v13 = *(_DWORD *)(v3 + 4);
        if ( *(_DWORD *)(v3 + 16) < v13 )
          v13 = *(_DWORD *)(v3 + 16);
        memcpy(*(void **)(v3 + 12), *(const void **)v3, v13);
        *(_DWORD *)v2 = sub_10035DC0(*(unsigned int **)(v3 + 12), v13, *(_DWORD *)v2);
        *(_DWORD *)(v3 + 4) -= v13;
        *(_DWORD *)(v3 + 16) -= v13;
        *(_DWORD *)(v3 + 12) += v13;
        *(_DWORD *)v3 += v13;
        *(_DWORD *)(v3 + 20) += v13;
        *(_DWORD *)(v3 + 8) += v13;
        v17 += v13;
      }
      if ( !*(_DWORD *)(v3 + 16) )
        return v17;
      v6 = v18;
    }
  }
  return v17;
}

//----- (1004A610) --------------------------------------------------------
signed int __cdecl sub_1004A610(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ST04_4@4
  signed int v5; // eax@4
  signed int v6; // ebx@4
  bool v7; // zf@5

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    v4 = a1 + 88;
    *(_DWORD *)(v4 + 16) = a2;
    *(_DWORD *)(v4 + 20) = a3;
    v5 = sub_1004A420(a1, a1 + 88);
    v6 = v5;
    if ( v5 > 0 )
    {
      v7 = *(_DWORD *)(a1 + 112) == v5;
      *(_DWORD *)(a1 + 112) -= v5;
      if ( v7 && !(*(_BYTE *)a1 & 1) && !sub_10049770(a1) )
        v6 = -14;
    }
    result = v6;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (1004A670) --------------------------------------------------------
signed int __cdecl sub_1004A670(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  unsigned int v4; // edx@4
  int v5; // ebx@4
  int v6; // esi@16
  int v7; // eax@17
  char v8; // [sp+4h] [bp-204h]@19

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return -6;
  v4 = *(_DWORD *)(a1 + 44);
  result = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 112);
  v5 = a2;
  if ( a3 == 1 )
  {
    v5 = result + a2;
  }
  else if ( a3 == 2 )
  {
    v5 = v4 + a2;
  }
  if ( v5 > v4 || v5 < 0 )
    return -15;
  if ( result == v5 )
    return result;
  if ( !v5 )
  {
    sub_1004A3D0(a1);
    return 0;
  }
  if ( !*(_WORD *)(a1 + 30) && *(_BYTE *)a1 & 3 )
  {
    sub_10049960(a1 + 116);
    *(_DWORD *)(a1 + 124) = v5;
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 44) - v5;
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 40) - v5;
    return v5;
  }
  if ( result > v5 )
  {
    sub_1004A3D0(a1);
    result = 0;
  }
  v6 = v5 - result;
  if ( v5 - result <= 0 )
    return v5;
  while ( 1 )
  {
    v7 = 512;
    if ( (unsigned int)v6 < 0x200 )
      v7 = v6;
    result = sub_1004A610(a1, (int)&v8, v7);
    if ( result <= 0 )
      break;
    v6 -= result;
    if ( v6 <= 0 )
      return v5;
  }
  return result;
}

//----- (1004A800) --------------------------------------------------------
signed int __usercall sub_1004A800@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // edi@1
  signed int result; // eax@1
  int v5; // esi@1
  unsigned __int16 v6; // bx@2
  unsigned __int16 v7; // ax@2
  unsigned int v8; // ebx@2
  unsigned __int16 v9; // dx@2
  int v10; // edx@2
  int v11; // eax@2
  int v12; // esi@2
  unsigned int v13; // edx@2
  int v14; // eax@2
  int v15; // esi@2
  unsigned int v16; // ST2C_4@4
  unsigned int v17; // ST30_4@4
  unsigned int v18; // ST34_4@4
  unsigned int v19; // esi@4
  unsigned int v20; // ST2C_4@5
  unsigned int v21; // ST30_4@5
  unsigned int v22; // ST34_4@5
  unsigned int v23; // esi@5
  unsigned int v24; // ST30_4@6
  unsigned int v25; // ST34_4@6
  unsigned int v26; // edx@6
  unsigned int v27; // esi@6
  __int16 v28; // ST38_2@6
  unsigned int v29; // ST1C_4@6
  unsigned int v30; // ST20_4@6
  unsigned int v31; // ST24_4@6
  unsigned int v32; // esi@6
  unsigned int v33; // edx@6
  unsigned int v34; // ST30_4@6
  unsigned int v35; // ST34_4@6
  unsigned int v36; // esi@6
  unsigned int v37; // ST1C_4@6
  unsigned int v38; // ST20_4@6
  unsigned int v39; // ST24_4@6
  unsigned int v40; // esi@6
  unsigned int v41; // ST30_4@6
  unsigned int v42; // edx@6
  unsigned int v43; // ST34_4@6
  unsigned int v44; // esi@6
  unsigned int v45; // ST1C_4@6
  unsigned int v46; // ST20_4@6
  unsigned int v47; // ST24_4@6
  unsigned int v48; // esi@6
  unsigned int v49; // edx@6
  unsigned int v50; // ST30_4@6
  unsigned int v51; // ST34_4@6
  unsigned int v52; // esi@6
  unsigned int v53; // ST1C_4@6
  unsigned int v54; // ST20_4@6
  unsigned int v55; // ST24_4@6
  unsigned int v56; // ST28_4@6
  unsigned int v57; // ST30_4@6
  unsigned int v58; // edx@6
  unsigned int v59; // ST34_4@6
  unsigned int v60; // ST38_4@6
  unsigned int v61; // ST20_4@6
  unsigned int v62; // ST24_4@6
  unsigned int v63; // ebx@6
  unsigned int v64; // eax@6
  unsigned int v65; // [sp+14h] [bp-20h]@2
  unsigned int v66; // [sp+18h] [bp-1Ch]@2
  unsigned int v67; // [sp+1Ch] [bp-18h]@2
  unsigned int v68; // [sp+20h] [bp-14h]@2

  v3 = a1;
  result = 0;
  v5 = a2;
  if ( *(_BYTE *)(v3 + 260) & 1 )
  {
    BYTE1(result) = *(_BYTE *)(a2 + 3);
    HIBYTE(v6) = *(_BYTE *)(a2 + 7);
    LOBYTE(result) = *(_BYTE *)(a2 + 2);
    LOBYTE(v6) = *(_BYTE *)(a2 + 6);
    v65 = *(_DWORD *)v3 ^ (*(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (result << 8)) << 8));
    HIBYTE(v7) = *(_BYTE *)(a2 + 11);
    v8 = *(_DWORD *)(v3 + 4) ^ (*(_BYTE *)(a2 + 4) | ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8));
    LOBYTE(v7) = *(_BYTE *)(a2 + 10);
    v66 = v8;
    HIBYTE(v9) = *(_BYTE *)(a2 + 15);
    v67 = *(_DWORD *)(v3 + 8) ^ (*(_BYTE *)(v5 + 8) | ((*(_BYTE *)(v5 + 9) | (v7 << 8)) << 8));
    LOBYTE(v9) = *(_BYTE *)(v5 + 14);
    v10 = *(_BYTE *)(v5 + 13) | (v9 << 8);
    v11 = *(_BYTE *)(v5 + 12);
    v12 = *(_DWORD *)(v3 + 256);
    v13 = *(_DWORD *)(v3 + 12) ^ (v11 | (v10 << 8));
    v14 = v3 + 16 * (v12 - 9);
    v15 = v12 - 12;
    v68 = v13;
    if ( v15 )
    {
      if ( v15 != 2 )
      {
LABEL_6:
        v24 = *(_DWORD *)(v14 + 4) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v66] ^ *(_DWORD *)&dword_100D4F10[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v68 >> 16)];
        v25 = *(_DWORD *)(v14 + 8) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v66 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v68)];
        v26 = *(_DWORD *)v14 ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v13 >> 24)];
        v27 = *(_DWORD *)(v14 + 12) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v66 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v67 >> 24)];
        v28 = *(_WORD *)(v14 + 12) ^ dword_100D4310[2 * (unsigned __int8)v68] ^ dword_100D4710[2 * BYTE1(v65)] ^ dword_100D4B10[2 * (unsigned __int8)(v66 >> 16)] ^ dword_100D4F10[2 * (v67 >> 24)];
        v29 = *(_DWORD *)(v14 + 16) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v26] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v24)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v25 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v27 >> 24)];
        v30 = *(_DWORD *)(v14 + 20) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v24] ^ *(_DWORD *)&dword_100D4F10[2 * (v26 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v25)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v27 >> 16)];
        v31 = *(_DWORD *)(v14 + 24) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v25] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v26 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v24 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * HIBYTE(v28)];
        v32 = *(_DWORD *)(v14 + 28) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v28] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v26)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v24 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v25 >> 24)];
        v33 = *(_DWORD *)(v14 + 32) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v29] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v30)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v31 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v32 >> 24)];
        v34 = *(_DWORD *)(v14 + 36) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v30] ^ *(_DWORD *)&dword_100D4F10[2 * (v29 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v31)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v32 >> 16)];
        v35 = *(_DWORD *)(v14 + 40) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v31] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v29 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v30 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v32)];
        v36 = *(_DWORD *)(v14 + 44) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v32] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v29)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v30 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v31 >> 24)];
        v37 = *(_DWORD *)(v14 + 48) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v33] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v34)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v35 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v36 >> 24)];
        v38 = *(_DWORD *)(v14 + 52) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v34] ^ *(_DWORD *)&dword_100D4F10[2 * (v33 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v35)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v36 >> 16)];
        v39 = *(_DWORD *)(v14 + 56) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v35] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v33 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v34 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v36)];
        v40 = *(_DWORD *)(v14 + 60) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v36] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v33)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v34 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v35 >> 24)];
        v41 = *(_DWORD *)(v14 + 68) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v38] ^ *(_DWORD *)&dword_100D4F10[2 * (v37 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v39)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v40 >> 16)];
        v42 = *(_DWORD *)(v14 + 64) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v37] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v38)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v39 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v40 >> 24)];
        v43 = *(_DWORD *)(v14 + 72) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v39] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v37 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v38 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v40)];
        v44 = *(_DWORD *)(v14 + 76) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v40] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v37)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v38 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v39 >> 24)];
        v45 = *(_DWORD *)(v14 + 80) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v42] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v41)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v43 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v44 >> 24)];
        v46 = *(_DWORD *)(v14 + 84) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v41] ^ *(_DWORD *)&dword_100D4F10[2 * (v42 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v43)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v44 >> 16)];
        v47 = *(_DWORD *)(v14 + 88) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v43] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v42 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v41 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v44)];
        v48 = *(_DWORD *)(v14 + 92) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v44] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v42)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v41 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v43 >> 24)];
        v49 = *(_DWORD *)(v14 + 96) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v45] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v46)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v47 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v48 >> 24)];
        v50 = *(_DWORD *)(v14 + 100) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v46] ^ *(_DWORD *)&dword_100D4F10[2 * (v45 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v47)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v48 >> 16)];
        v51 = *(_DWORD *)(v14 + 104) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v47] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v45 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v46 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v48)];
        v52 = *(_DWORD *)(v14 + 108) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v48] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v45)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v46 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v47 >> 24)];
        v53 = *(_DWORD *)(v14 + 112) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v49] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v50)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v51 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v52 >> 24)];
        v54 = *(_DWORD *)(v14 + 116) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v50] ^ *(_DWORD *)&dword_100D4F10[2 * (v49 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v51)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v52 >> 16)];
        v55 = *(_DWORD *)(v14 + 120) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v51] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v49 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v50 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v52)];
        v56 = *(_DWORD *)(v14 + 124) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v52] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v49)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v50 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v51 >> 24)];
        v57 = *(_DWORD *)(v14 + 132) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v54] ^ *(_DWORD *)&dword_100D4F10[2 * (v53 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v55)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v56 >> 16)];
        v58 = *(_DWORD *)(v14 + 128) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v53] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v54)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v55 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v56 >> 24)];
        v59 = *(_DWORD *)(v14 + 136) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v55] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v53 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v54 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v56)];
        v60 = *(_DWORD *)(v14 + 140) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v56] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v53)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v54 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v55 >> 24)];
        v61 = *(_DWORD *)(v14 + 148) ^ dword_100D5310[(unsigned __int8)v57] ^ dword_100D5F10[v58 >> 24] ^ dword_100D5710[BYTE1(v59)] ^ dword_100D5B10[(unsigned __int8)(v60 >> 16)];
        v62 = *(_DWORD *)(v14 + 152) ^ dword_100D5310[(unsigned __int8)v59] ^ dword_100D5B10[(unsigned __int8)(v58 >> 16)] ^ dword_100D5F10[v57 >> 24] ^ dword_100D5710[BYTE1(v60)];
        v63 = *(_DWORD *)(v14 + 156) ^ dword_100D5310[(unsigned __int8)v60] ^ dword_100D5710[BYTE1(v58)] ^ dword_100D5B10[(unsigned __int8)(v57 >> 16)] ^ dword_100D5F10[v59 >> 24];
        v64 = *(_DWORD *)(v14 + 144) ^ dword_100D5310[(unsigned __int8)v58] ^ dword_100D5710[BYTE1(v57)] ^ dword_100D5B10[(unsigned __int8)(v59 >> 16)] ^ dword_100D5F10[v60 >> 24];
        *(_BYTE *)(a3 + 1) = BYTE1(v64);
        *(_BYTE *)a3 = v64;
        *(_BYTE *)(a3 + 2) = v64 >> 16;
        *(_BYTE *)(a3 + 3) = BYTE3(v64);
        *(_BYTE *)(a3 + 5) = BYTE1(v61);
        *(_BYTE *)(a3 + 4) = v61;
        *(_BYTE *)(a3 + 7) = BYTE3(v61);
        *(_BYTE *)(a3 + 6) = v61 >> 16;
        *(_BYTE *)(a3 + 9) = BYTE1(v62);
        *(_BYTE *)(a3 + 8) = v62;
        *(_BYTE *)(a3 + 11) = BYTE3(v62);
        *(_BYTE *)(a3 + 10) = v62 >> 16;
        *(_BYTE *)(a3 + 12) = v63;
        *(_BYTE *)(a3 + 13) = BYTE1(v63);
        *(_BYTE *)(a3 + 15) = BYTE3(v63);
        *(_BYTE *)(a3 + 14) = v63 >> 16;
        return 1;
      }
      v16 = *(_DWORD *)(v14 - 64) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v13 >> 24)];
      v17 = *(_DWORD *)(v14 - 60) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100D4F10[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v13 >> 16)];
      v18 = *(_DWORD *)(v14 - 56) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v68)];
      v19 = *(_DWORD *)(v14 - 52) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v13] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v67 >> 24)];
      v8 = *(_DWORD *)(v14 - 44) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v17] ^ *(_DWORD *)&dword_100D4F10[2 * (v16 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v18)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v19 >> 16)];
      v67 = *(_DWORD *)(v14 - 40) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v18] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v16 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v17 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v19)];
      v65 = *(_DWORD *)(v14 - 48) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v16] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v17)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v18 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v19 >> 24)];
      v13 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v18 >> 24)];
      v68 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v18 >> 24)];
    }
    v20 = *(_DWORD *)(v14 - 32) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v13 >> 24)];
    v21 = *(_DWORD *)(v14 - 28) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100D4F10[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v68 >> 16)];
    v22 = *(_DWORD *)(v14 - 24) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v68)];
    v23 = *(_DWORD *)(v14 - 20) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v67 >> 24)];
    v8 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100D4F10[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v23 >> 16)];
    v67 = *(_DWORD *)(v14 - 8) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v22] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v20 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v21 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v23)];
    v65 = *(_DWORD *)(v14 - 16) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v20] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v21)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v22 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v23 >> 24)];
    v66 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100D4F10[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v23 >> 16)];
    v13 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v22 >> 24)];
    v68 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100D4310[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100D4710[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100D4B10[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100D4F10[2 * (v22 >> 24)];
    goto LABEL_6;
  }
  return result;
}
// 100D5310: using guessed type int dword_100D5310[];
// 100D5710: using guessed type int dword_100D5710[];
// 100D5B10: using guessed type int dword_100D5B10[];
// 100D5F10: using guessed type int dword_100D5F10[];

//----- (1004B8B0) --------------------------------------------------------
int __usercall sub_1004B8B0@<eax>(int a1@<esi>, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@3
  bool v6; // zf@4

  result = *(_DWORD *)(a1 + 456);
  v4 = 0;
  if ( a3 )
  {
    do
    {
      if ( result == 16 )
      {
        v5 = 0;
        do
        {
          v6 = (*(_BYTE *)(v5 + a1))++ == -1;
          if ( !v6 )
            break;
          ++v5;
        }
        while ( v5 < 8 );
        sub_1004A800(a1 + 32, a1, a1 + 16);
        result = 0;
      }
      *(_BYTE *)(v4++ + a2) ^= *(_BYTE *)(a1 + 16 + result++);
    }
    while ( v4 < a3 );
  }
  *(_DWORD *)(a1 + 456) = result;
  return result;
}

//----- (1004B910) --------------------------------------------------------
signed int __usercall sub_1004B910@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned __int16 v4; // dx@1
  int v5; // edx@1
  unsigned __int16 v6; // cx@1
  int v7; // esi@1
  int v8; // edi@1
  unsigned int v9; // ecx@1
  unsigned __int16 v10; // dx@2
  int v11; // edx@2
  int v12; // ebx@2
  int v13; // edx@3
  int v14; // ST20_4@3
  int v15; // edx@3
  int v16; // ST24_4@3
  int v17; // edx@3
  int v18; // ST28_4@3
  unsigned int v19; // edx@3
  int v20; // ebp@3
  int v21; // esi@3
  int v22; // edi@3
  unsigned int v23; // ecx@3
  int v24; // ST20_4@3
  int v25; // ebx@3
  unsigned int v26; // edx@3
  int v27; // ST28_4@3
  int v28; // ebp@3
  int v29; // esi@3
  int v30; // edi@3
  unsigned int v31; // ecx@3
  int v32; // ST10_4@3
  int v33; // ebx@3
  int v34; // ebp@3
  unsigned int v35; // edx@3
  int v36; // ST28_4@3
  int v37; // ST24_4@3
  int v38; // ebp@3
  int v39; // esi@3
  int v40; // edi@3
  unsigned int v41; // ecx@3
  int v42; // ebx@3
  unsigned int v43; // edx@3
  int v44; // ebp@3
  int v45; // esi@3
  int v46; // edi@3
  unsigned int v47; // ecx@3
  int v48; // ST10_4@3
  int v49; // ST20_4@3
  int v50; // ebp@3
  int v51; // ebx@3
  unsigned int v52; // edx@3
  int v53; // ST28_4@3
  int v54; // ST24_4@3
  int v55; // ebp@3
  int v56; // esi@3
  int v57; // edi@3
  unsigned int v58; // ecx@3
  int v59; // ebx@3
  unsigned int v60; // edx@3
  int v61; // ST28_4@3
  int v62; // ST24_4@3
  int v63; // ebp@3
  int v64; // esi@3
  int v65; // edi@3
  unsigned int v66; // ecx@3
  int v67; // ST10_4@3
  int v68; // ebx@3
  unsigned int v69; // edx@3
  int v70; // ebp@3
  int v71; // ebp@3
  int v72; // esi@3
  int v73; // edi@3
  signed int result; // eax@3
  int v75; // edx@4
  int v76; // ST20_4@4
  unsigned int v77; // edx@4
  int v78; // ebp@4
  int v79; // esi@4
  int v80; // edi@4
  int v81; // ecx@4
  unsigned int v82; // edx@4
  int v83; // ST20_4@4
  int v84; // ebp@4
  int v85; // esi@4
  int v86; // edi@4
  int v87; // ecx@4
  int v88; // ebx@4
  unsigned int v89; // edx@4
  int v90; // ebp@4
  int v91; // esi@4
  int v92; // edi@4
  int v93; // ecx@4
  unsigned int v94; // edx@4
  int v95; // ST20_4@4
  int v96; // ebp@4
  int v97; // esi@4
  int v98; // edi@4
  int v99; // ecx@4
  unsigned int v100; // edx@4
  int v101; // ST20_4@4
  int v102; // ST10_4@4
  int v103; // ebp@4
  int v104; // esi@4
  int v105; // edi@4
  int v106; // ST10_4@4
  int v107; // ecx@4
  unsigned int v108; // edx@4
  int v109; // ST20_4@4
  int v110; // ebp@4
  int v111; // esi@4
  int v112; // edi@4
  int v113; // ecx@4
  unsigned int v114; // edx@4
  int v115; // ST20_4@4
  int v116; // ebp@4
  int v117; // esi@4
  int v118; // edi@4
  int v119; // ecx@4
  unsigned int v120; // edx@4
  int v121; // ST10_4@4
  int v122; // ebp@4
  int v123; // ebp@4
  int v124; // esi@4
  int v125; // edi@4
  int v126; // ebp@5
  int v127; // esi@5
  int v128; // edi@5
  unsigned int v129; // ecx@5
  int v130; // edx@5
  int v131; // esi@5
  int v132; // edi@5
  unsigned int v133; // ecx@5
  int v134; // ebp@5
  int v135; // esi@5
  int v136; // edi@5
  unsigned int v137; // ecx@5
  int v138; // edx@5
  int v139; // esi@5
  int v140; // edi@5
  unsigned int v141; // ecx@5
  int v142; // ebp@5
  int v143; // esi@5
  int v144; // edi@5
  unsigned int v145; // ecx@5
  int v146; // edx@5
  int v147; // esi@5
  int v148; // edi@5
  unsigned int v149; // ecx@5
  int v150; // ebp@5
  int v151; // esi@5
  int v152; // edi@5
  unsigned int v153; // ecx@5
  int v154; // edx@5
  int v155; // esi@5
  int v156; // edi@5
  unsigned int v157; // ecx@5
  int v158; // ebp@5
  int v159; // esi@5
  int v160; // edi@5
  unsigned int v161; // ecx@5
  int v162; // edx@5
  int v163; // edx@5
  int v164; // esi@5
  int v165; // edi@5
  int v166; // [sp+10h] [bp-20h]@1

  *(_DWORD *)(a1 + 260) = 17;
  v3 = a2;
  HIBYTE(v4) = *(_BYTE *)(a2 + 3);
  LOBYTE(v4) = *(_BYTE *)(a2 + 2);
  v5 = *(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (v4 << 8)) << 8);
  *(_DWORD *)a1 = v5;
  HIBYTE(v6) = *(_BYTE *)(a2 + 7);
  v166 = v5;
  LOBYTE(v6) = *(_BYTE *)(a2 + 6);
  v7 = ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8) | *(_BYTE *)(a2 + 4);
  *(_DWORD *)(a1 + 4) = v7;
  HIBYTE(v6) = *(_BYTE *)(a2 + 11);
  LOBYTE(v6) = *(_BYTE *)(a2 + 10);
  v8 = ((*(_BYTE *)(v3 + 9) | (v6 << 8)) << 8) | *(_BYTE *)(v3 + 8);
  *(_DWORD *)(a1 + 8) = v8;
  HIBYTE(v6) = *(_BYTE *)(a2 + 15);
  LOBYTE(v6) = *(_BYTE *)(a2 + 14);
  v9 = *(_BYTE *)(v3 + 12) | ((*(_BYTE *)(v3 + 13) | (v6 << 8)) << 8);
  *(_DWORD *)(a1 + 12) = v9;
  if ( a3 == 16 )
  {
    v126 = v5 ^ dword_100D5F10[(unsigned __int8)v9] ^ dword_100D5310[BYTE1(v9)] ^ dword_100D5710[(unsigned __int8)(v9 >> 16)] ^ dword_100D5B10[v9 >> 24] ^ 1;
    v127 = v126 ^ v7;
    *(_DWORD *)(a1 + 16) = v126;
    *(_DWORD *)(a1 + 20) = v127;
    v128 = v127 ^ v8;
    *(_DWORD *)(a1 + 24) = v128;
    v129 = v128 ^ v9;
    *(_DWORD *)(a1 + 28) = v129;
    v130 = v126 ^ dword_100D5F10[(unsigned __int8)v129] ^ dword_100D5310[BYTE1(v129)] ^ dword_100D5710[(unsigned __int8)(v129 >> 16)] ^ dword_100D5B10[v129 >> 24] ^ 2;
    v131 = v130 ^ v127;
    *(_DWORD *)(a1 + 32) = v130;
    *(_DWORD *)(a1 + 36) = v131;
    v132 = v131 ^ v128;
    *(_DWORD *)(a1 + 40) = v132;
    v133 = v132 ^ v129;
    *(_DWORD *)(a1 + 44) = v133;
    v134 = v130 ^ dword_100D5F10[(unsigned __int8)v133] ^ dword_100D5310[BYTE1(v133)] ^ dword_100D5710[(unsigned __int8)(v133 >> 16)] ^ dword_100D5B10[v133 >> 24] ^ 4;
    v135 = v134 ^ v131;
    v136 = v135 ^ v132;
    v137 = v136 ^ v133;
    *(_DWORD *)(a1 + 48) = v134;
    *(_DWORD *)(a1 + 52) = v135;
    *(_DWORD *)(a1 + 56) = v136;
    *(_DWORD *)(a1 + 60) = v137;
    v138 = v134 ^ dword_100D5F10[(unsigned __int8)v137] ^ dword_100D5310[BYTE1(v137)] ^ dword_100D5710[(unsigned __int8)(v137 >> 16)] ^ dword_100D5B10[v137 >> 24] ^ 8;
    *(_DWORD *)(a1 + 64) = v138;
    v139 = v138 ^ v135;
    *(_DWORD *)(a1 + 68) = v139;
    v140 = v139 ^ v136;
    *(_DWORD *)(a1 + 72) = v140;
    v141 = v140 ^ v137;
    *(_DWORD *)(a1 + 76) = v141;
    v142 = v138 ^ dword_100D5F10[(unsigned __int8)v141] ^ dword_100D5310[BYTE1(v141)] ^ dword_100D5710[(unsigned __int8)(v141 >> 16)] ^ dword_100D5B10[v141 >> 24] ^ 0x10;
    v143 = v142 ^ v139;
    v144 = v143 ^ v140;
    v145 = v144 ^ v141;
    *(_DWORD *)(a1 + 80) = v142;
    *(_DWORD *)(a1 + 84) = v143;
    *(_DWORD *)(a1 + 88) = v144;
    *(_DWORD *)(a1 + 92) = v145;
    v146 = v142 ^ dword_100D5F10[(unsigned __int8)v145] ^ dword_100D5310[BYTE1(v145)] ^ dword_100D5710[(unsigned __int8)(v145 >> 16)] ^ dword_100D5B10[v145 >> 24] ^ 0x20;
    v147 = v146 ^ v143;
    v148 = v147 ^ v144;
    v149 = v148 ^ v145;
    *(_DWORD *)(a1 + 100) = v147;
    *(_DWORD *)(a1 + 104) = v148;
    *(_DWORD *)(a1 + 108) = v149;
    *(_DWORD *)(a1 + 96) = v146;
    v150 = v146 ^ dword_100D5F10[(unsigned __int8)v149] ^ dword_100D5310[BYTE1(v149)] ^ dword_100D5710[(unsigned __int8)(v149 >> 16)] ^ dword_100D5B10[v149 >> 24] ^ 0x40;
    v151 = v150 ^ v147;
    v152 = v151 ^ v148;
    v153 = v152 ^ v149;
    *(_DWORD *)(a1 + 112) = v150;
    *(_DWORD *)(a1 + 116) = v151;
    *(_DWORD *)(a1 + 120) = v152;
    *(_DWORD *)(a1 + 124) = v153;
    v154 = v150 ^ dword_100D5F10[(unsigned __int8)v153] ^ dword_100D5310[BYTE1(v153)] ^ dword_100D5710[(unsigned __int8)(v153 >> 16)] ^ dword_100D5B10[v153 >> 24] ^ 0x80;
    v155 = v154 ^ v151;
    *(_DWORD *)(a1 + 128) = v154;
    *(_DWORD *)(a1 + 132) = v155;
    v156 = v155 ^ v152;
    *(_DWORD *)(a1 + 136) = v156;
    v157 = v156 ^ v153;
    *(_DWORD *)(a1 + 140) = v157;
    v158 = v154 ^ dword_100D5F10[(unsigned __int8)v157] ^ dword_100D5310[BYTE1(v157)] ^ dword_100D5710[(unsigned __int8)(v157 >> 16)] ^ dword_100D5B10[v157 >> 24] ^ 0x1B;
    v159 = v158 ^ v155;
    v160 = v159 ^ v156;
    v161 = v160 ^ v157;
    *(_DWORD *)(a1 + 148) = v159;
    *(_DWORD *)(a1 + 152) = v160;
    *(_DWORD *)(a1 + 144) = v158;
    *(_DWORD *)(a1 + 156) = v161;
    v162 = dword_100D5F10[(unsigned __int8)v161] ^ dword_100D5310[BYTE1(v161)] ^ dword_100D5710[(unsigned __int8)(v161 >> 16)] ^ dword_100D5B10[v161 >> 24];
    *(_DWORD *)(a1 + 256) = 10;
    v163 = v158 ^ v162 ^ 0x36;
    v164 = v163 ^ v159;
    v165 = v164 ^ v160;
    *(_DWORD *)(a1 + 168) = v165;
    *(_DWORD *)(a1 + 164) = v164;
    *(_DWORD *)(a1 + 160) = v163;
    *(_DWORD *)(a1 + 172) = v165 ^ v161;
    result = 1;
  }
  else
  {
    HIBYTE(v10) = *(_BYTE *)(a2 + 19);
    LOBYTE(v10) = *(_BYTE *)(a2 + 18);
    v11 = v10 << 8;
    v12 = *(_BYTE *)(a2 + 17);
    if ( a3 == 24 )
    {
      v75 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v75;
      v76 = v75;
      BYTE1(v75) = *(_BYTE *)(a2 + 23);
      LOBYTE(v75) = *(_BYTE *)(a2 + 22);
      v77 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v75 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v77;
      v78 = v166 ^ dword_100D5F10[(unsigned __int8)v77] ^ dword_100D5310[BYTE1(v77)] ^ dword_100D5710[(unsigned __int8)(v77 >> 16)] ^ dword_100D5B10[v77 >> 24] ^ 1;
      v79 = v78 ^ v7;
      v80 = v79 ^ v8;
      v81 = v80 ^ v9;
      *(_DWORD *)(a1 + 40) = v81 ^ v76;
      v82 = v81 ^ v76 ^ v77;
      v83 = v81 ^ v76;
      *(_DWORD *)(a1 + 36) = v81;
      *(_DWORD *)(a1 + 24) = v78;
      *(_DWORD *)(a1 + 28) = v79;
      *(_DWORD *)(a1 + 32) = v80;
      *(_DWORD *)(a1 + 44) = v82;
      v84 = v78 ^ dword_100D5F10[(unsigned __int8)v82] ^ dword_100D5310[BYTE1(v82)] ^ dword_100D5710[(unsigned __int8)(v82 >> 16)] ^ dword_100D5B10[v82 >> 24] ^ 2;
      v85 = v84 ^ v79;
      v86 = v85 ^ v80;
      v87 = v86 ^ v81;
      v89 = v87 ^ v83 ^ v82;
      v88 = v87 ^ v83;
      *(_DWORD *)(a1 + 64) = v87 ^ v83;
      *(_DWORD *)(a1 + 48) = v84;
      *(_DWORD *)(a1 + 52) = v85;
      *(_DWORD *)(a1 + 56) = v86;
      *(_DWORD *)(a1 + 60) = v87;
      *(_DWORD *)(a1 + 68) = v89;
      v90 = v84 ^ dword_100D5F10[(unsigned __int8)v89] ^ dword_100D5310[BYTE1(v89)] ^ dword_100D5710[(unsigned __int8)(v89 >> 16)] ^ dword_100D5B10[v89 >> 24] ^ 4;
      v91 = v90 ^ v85;
      v92 = v91 ^ v86;
      v93 = v92 ^ v87;
      *(_DWORD *)(a1 + 88) = v93 ^ v88;
      v94 = v93 ^ v88 ^ v89;
      v95 = v93 ^ v88;
      *(_DWORD *)(a1 + 84) = v93;
      *(_DWORD *)(a1 + 72) = v90;
      *(_DWORD *)(a1 + 76) = v91;
      *(_DWORD *)(a1 + 80) = v92;
      *(_DWORD *)(a1 + 92) = v94;
      v96 = v90 ^ dword_100D5F10[(unsigned __int8)v94] ^ dword_100D5310[BYTE1(v94)] ^ dword_100D5710[(unsigned __int8)(v94 >> 16)] ^ dword_100D5B10[v94 >> 24] ^ 8;
      v97 = v96 ^ v91;
      v98 = v97 ^ v92;
      v99 = v98 ^ v93;
      *(_DWORD *)(a1 + 112) = v99 ^ v95;
      v100 = v99 ^ v95 ^ v94;
      v101 = v99 ^ v95;
      *(_DWORD *)(a1 + 108) = v99;
      v102 = v96;
      *(_DWORD *)(a1 + 96) = v96;
      *(_DWORD *)(a1 + 100) = v97;
      *(_DWORD *)(a1 + 104) = v98;
      *(_DWORD *)(a1 + 116) = v100;
      v103 = v96 ^ dword_100D5F10[(unsigned __int8)v100] ^ dword_100D5310[BYTE1(v100)] ^ dword_100D5710[(unsigned __int8)(v100 >> 16)] ^ dword_100D5B10[v100 >> 24] ^ 0x10;
      v104 = v103 ^ v97;
      v105 = v104 ^ v98;
      v106 = v102 ^ dword_100D5F10[(unsigned __int8)v100] ^ dword_100D5310[BYTE1(v100)] ^ dword_100D5710[(unsigned __int8)(v100 >> 16)] ^ dword_100D5B10[v100 >> 24] ^ 0x10;
      *(_DWORD *)(a1 + 120) = v103;
      *(_DWORD *)(a1 + 124) = v104;
      *(_DWORD *)(a1 + 128) = v105;
      v107 = v105 ^ v99;
      *(_DWORD *)(a1 + 136) = v107 ^ v101;
      v108 = v107 ^ v101 ^ v100;
      v109 = v107 ^ v101;
      *(_DWORD *)(a1 + 132) = v107;
      *(_DWORD *)(a1 + 140) = v108;
      v110 = v106 ^ dword_100D5F10[(unsigned __int8)v108] ^ dword_100D5310[BYTE1(v108)] ^ dword_100D5710[(unsigned __int8)(v108 >> 16)] ^ dword_100D5B10[v108 >> 24] ^ 0x20;
      v111 = v110 ^ v104;
      v112 = v111 ^ v105;
      v113 = v112 ^ v107;
      *(_DWORD *)(a1 + 160) = v113 ^ v109;
      v114 = v113 ^ v109 ^ v108;
      v115 = v113 ^ v109;
      *(_DWORD *)(a1 + 156) = v113;
      *(_DWORD *)(a1 + 144) = v110;
      *(_DWORD *)(a1 + 148) = v111;
      *(_DWORD *)(a1 + 152) = v112;
      *(_DWORD *)(a1 + 164) = v114;
      v116 = v110 ^ dword_100D5F10[(unsigned __int8)v114] ^ dword_100D5310[BYTE1(v114)] ^ dword_100D5710[(unsigned __int8)(v114 >> 16)] ^ dword_100D5B10[v114 >> 24] ^ 0x40;
      v117 = v116 ^ v111;
      v118 = v117 ^ v112;
      v119 = v118 ^ v113;
      v120 = v119 ^ v115 ^ v114;
      *(_DWORD *)(a1 + 180) = v119;
      *(_DWORD *)(a1 + 184) = v119 ^ v115;
      v121 = v116;
      *(_DWORD *)(a1 + 168) = v116;
      *(_DWORD *)(a1 + 172) = v117;
      *(_DWORD *)(a1 + 176) = v118;
      *(_DWORD *)(a1 + 188) = v120;
      v122 = dword_100D5F10[(unsigned __int8)v120] ^ dword_100D5310[BYTE1(v120)] ^ dword_100D5710[(unsigned __int8)(v120 >> 16)] ^ dword_100D5B10[v120 >> 24];
      *(_DWORD *)(a1 + 256) = 12;
      v123 = v121 ^ v122 ^ 0x80;
      v124 = v123 ^ v117;
      v125 = v124 ^ v118;
      *(_DWORD *)(a1 + 200) = v125;
      *(_DWORD *)(a1 + 196) = v124;
      *(_DWORD *)(a1 + 192) = v123;
      *(_DWORD *)(a1 + 204) = v125 ^ v119;
      result = 1;
    }
    else
    {
      v13 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v13;
      v14 = v13;
      BYTE1(v13) = *(_BYTE *)(a2 + 23);
      LOBYTE(v13) = *(_BYTE *)(a2 + 22);
      v15 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v13 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v15;
      v16 = v15;
      BYTE1(v15) = *(_BYTE *)(a2 + 27);
      LOBYTE(v15) = *(_BYTE *)(a2 + 26);
      v17 = *(_BYTE *)(a2 + 24) | ((*(_BYTE *)(a2 + 25) | ((unsigned __int16)v15 << 8)) << 8);
      *(_DWORD *)(a1 + 24) = v17;
      v18 = v17;
      BYTE1(v17) = *(_BYTE *)(a2 + 31);
      LOBYTE(v17) = *(_BYTE *)(a2 + 30);
      v19 = *(_BYTE *)(a2 + 28) | ((*(_BYTE *)(a2 + 29) | ((unsigned __int16)v17 << 8)) << 8);
      *(_DWORD *)(a1 + 28) = v19;
      v20 = v166 ^ dword_100D5F10[(unsigned __int8)v19] ^ dword_100D5310[BYTE1(v19)] ^ dword_100D5710[(unsigned __int8)(v19 >> 16)] ^ dword_100D5B10[v19 >> 24] ^ 1;
      v21 = v20 ^ v7;
      v22 = v21 ^ v8;
      v23 = v22 ^ v9;
      *(_DWORD *)(a1 + 32) = v20;
      *(_DWORD *)(a1 + 36) = v21;
      *(_DWORD *)(a1 + 40) = v22;
      *(_DWORD *)(a1 + 44) = v23;
      v24 = dword_100D5310[(unsigned __int8)v23] ^ dword_100D5710[BYTE1(v23)] ^ dword_100D5B10[(unsigned __int8)(v23 >> 16)] ^ dword_100D5F10[v23 >> 24] ^ v14;
      *(_DWORD *)(a1 + 48) = v24;
      v25 = v24 ^ v16 ^ v18;
      v26 = v25 ^ v19;
      *(_DWORD *)(a1 + 56) = v25;
      v27 = v24 ^ v16 ^ v18;
      *(_DWORD *)(a1 + 52) = v24 ^ v16;
      *(_DWORD *)(a1 + 60) = v26;
      v28 = v20 ^ dword_100D5F10[(unsigned __int8)v26] ^ dword_100D5310[BYTE1(v26)] ^ dword_100D5710[(unsigned __int8)(v26 >> 16)] ^ dword_100D5B10[v26 >> 24] ^ 2;
      v29 = v28 ^ v21;
      *(_DWORD *)(a1 + 64) = v28;
      v30 = v29 ^ v22;
      v31 = v30 ^ v23;
      *(_DWORD *)(a1 + 76) = v31;
      v32 = v28;
      *(_DWORD *)(a1 + 68) = v29;
      *(_DWORD *)(a1 + 72) = v30;
      v33 = dword_100D5310[(unsigned __int8)v31] ^ dword_100D5710[BYTE1(v31)] ^ dword_100D5B10[(unsigned __int8)(v31 >> 16)] ^ dword_100D5F10[v31 >> 24] ^ v24;
      v34 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 80) = v33;
      *(_DWORD *)(a1 + 88) = v34 ^ v27;
      v35 = v34 ^ v27 ^ v26;
      v36 = v34 ^ v27;
      v37 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 84) = v34;
      *(_DWORD *)(a1 + 92) = v35;
      v38 = v32 ^ dword_100D5F10[(unsigned __int8)v35] ^ dword_100D5310[BYTE1(v35)] ^ dword_100D5710[(unsigned __int8)(v35 >> 16)] ^ dword_100D5B10[v35 >> 24] ^ 4;
      v39 = v38 ^ v29;
      *(_DWORD *)(a1 + 96) = v38;
      *(_DWORD *)(a1 + 100) = v39;
      v40 = v39 ^ v30;
      v41 = v40 ^ v31;
      *(_DWORD *)(a1 + 108) = v41;
      *(_DWORD *)(a1 + 104) = v40;
      v42 = dword_100D5310[(unsigned __int8)v41] ^ dword_100D5710[BYTE1(v41)] ^ dword_100D5B10[(unsigned __int8)(v41 >> 16)] ^ dword_100D5F10[v41 >> 24] ^ v33;
      *(_DWORD *)(a1 + 112) = v42;
      v43 = v42 ^ v37 ^ v36 ^ v35;
      *(_DWORD *)(a1 + 120) = v42 ^ v37 ^ v36;
      *(_DWORD *)(a1 + 116) = v42 ^ v37;
      *(_DWORD *)(a1 + 124) = v43;
      v44 = v38 ^ dword_100D5F10[(unsigned __int8)v43] ^ dword_100D5310[BYTE1(v43)] ^ dword_100D5710[(unsigned __int8)(v43 >> 16)] ^ dword_100D5B10[v43 >> 24] ^ 8;
      v45 = v44 ^ v39;
      v46 = v45 ^ v40;
      v47 = v46 ^ v41;
      *(_DWORD *)(a1 + 128) = v44;
      *(_DWORD *)(a1 + 132) = v45;
      *(_DWORD *)(a1 + 136) = v46;
      *(_DWORD *)(a1 + 140) = v47;
      v48 = v44;
      v49 = dword_100D5310[(unsigned __int8)v47] ^ dword_100D5710[BYTE1(v47)] ^ dword_100D5B10[(unsigned __int8)(v47 >> 16)] ^ dword_100D5F10[v47 >> 24] ^ v42;
      *(_DWORD *)(a1 + 144) = v49;
      v50 = v49 ^ v42 ^ v37;
      v51 = v50 ^ v42 ^ v37 ^ v36;
      v52 = v51 ^ v43;
      *(_DWORD *)(a1 + 152) = v51;
      v53 = v51;
      *(_DWORD *)(a1 + 148) = v50;
      v54 = v50;
      *(_DWORD *)(a1 + 156) = v52;
      v55 = v48 ^ dword_100D5F10[(unsigned __int8)v52] ^ dword_100D5310[BYTE1(v52)] ^ dword_100D5710[(unsigned __int8)(v52 >> 16)] ^ dword_100D5B10[v52 >> 24] ^ 0x10;
      v56 = v55 ^ v45;
      *(_DWORD *)(a1 + 160) = v55;
      v57 = v56 ^ v46;
      v58 = v57 ^ v47;
      *(_DWORD *)(a1 + 172) = v58;
      *(_DWORD *)(a1 + 164) = v56;
      *(_DWORD *)(a1 + 168) = v57;
      v59 = dword_100D5310[(unsigned __int8)v58] ^ dword_100D5710[BYTE1(v58)] ^ dword_100D5B10[(unsigned __int8)(v58 >> 16)] ^ dword_100D5F10[v58 >> 24] ^ v49;
      *(_DWORD *)(a1 + 176) = v59;
      *(_DWORD *)(a1 + 184) = v59 ^ v54 ^ v53;
      v60 = v59 ^ v54 ^ v53 ^ v52;
      v61 = v59 ^ v54 ^ v53;
      v62 = v59 ^ v54;
      *(_DWORD *)(a1 + 180) = v62;
      *(_DWORD *)(a1 + 188) = v60;
      v63 = v55 ^ dword_100D5F10[(unsigned __int8)v60] ^ dword_100D5310[BYTE1(v60)] ^ dword_100D5710[(unsigned __int8)(v60 >> 16)] ^ dword_100D5B10[v60 >> 24] ^ 0x20;
      v64 = v63 ^ v56;
      *(_DWORD *)(a1 + 192) = v63;
      v65 = v64 ^ v57;
      v66 = v65 ^ v58;
      *(_DWORD *)(a1 + 204) = v66;
      v67 = v63;
      *(_DWORD *)(a1 + 196) = v64;
      *(_DWORD *)(a1 + 200) = v65;
      v68 = dword_100D5310[(unsigned __int8)v66] ^ dword_100D5710[BYTE1(v66)] ^ dword_100D5B10[(unsigned __int8)(v66 >> 16)] ^ dword_100D5F10[v66 >> 24] ^ v59;
      *(_DWORD *)(a1 + 208) = v68;
      *(_DWORD *)(a1 + 216) = v68 ^ v62 ^ v61;
      v69 = v68 ^ v62 ^ v61 ^ v60;
      *(_DWORD *)(a1 + 212) = v68 ^ v62;
      *(_DWORD *)(a1 + 220) = v69;
      v70 = dword_100D5F10[(unsigned __int8)v69] ^ dword_100D5310[BYTE1(v69)] ^ dword_100D5710[(unsigned __int8)(v69 >> 16)] ^ dword_100D5B10[v69 >> 24];
      *(_DWORD *)(a1 + 256) = 14;
      v71 = v67 ^ v70 ^ 0x40;
      v72 = v71 ^ v64;
      v73 = v72 ^ v65;
      *(_DWORD *)(a1 + 232) = v73;
      *(_DWORD *)(a1 + 228) = v72;
      *(_DWORD *)(a1 + 224) = v71;
      *(_DWORD *)(a1 + 236) = v73 ^ v66;
      result = 1;
    }
  }
  return result;
}
// 100D5310: using guessed type int dword_100D5310[];
// 100D5710: using guessed type int dword_100D5710[];
// 100D5B10: using guessed type int dword_100D5B10[];
// 100D5F10: using guessed type int dword_100D5F10[];

//----- (1004C690) --------------------------------------------------------
void *__usercall sub_1004C690@<eax>(void *a1@<eax>)
{
  return memset(a1, 0, 0xA0u);
}

//----- (1004C6B0) --------------------------------------------------------
unsigned int __cdecl sub_1004C6B0(int a1, unsigned int a2)
{
  int v2; // eax@1
  unsigned int result; // eax@1
  _BYTE *v4; // ecx@3
  char v5; // dl@3
  unsigned __int64 v6; // [sp+Ch] [bp-8h]@1

  v2 = sub_10032ED0();
  v6 = ((unsigned __int64)(unsigned int)v2 << 32) + (unsigned int)j_TSK_pvg_get_us_timer();
  result = 0;
  do
  {
    if ( result >= a2 )
      break;
    v4 = (_BYTE *)(result + a1);
    v5 = *((_BYTE *)&v6 + result++ + a1 - a1);
    *v4 = v5;
  }
  while ( result < 8 );
  return result;
}
// 10032F20: using guessed type int j_TSK_pvg_get_us_timer(void);

//----- (1004C710) --------------------------------------------------------
int __usercall sub_1004C710@<eax>(int result@<eax>)
{
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 8) = 1732584193;
  *(_DWORD *)(result + 12) = -271733879;
  *(_DWORD *)(result + 16) = -1732584194;
  *(_DWORD *)(result + 20) = 271733878;
  *(_DWORD *)(result + 24) = -1009589776;
  return result;
}

//----- (1004C750) --------------------------------------------------------
int __usercall sub_1004C750@<eax>(int result@<eax>)
{
  int v1; // ebx@1
  int v2; // esi@1
  int v3; // edx@1
  unsigned int v4; // ST28_4@1
  int v5; // edx@1
  int v6; // ST18_4@1
  unsigned int v7; // ST2C_4@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // ST14_4@1
  int v12; // ST20_4@1
  unsigned int v13; // ST30_4@1
  int v14; // esi@1
  unsigned int v15; // ST34_4@1
  int v16; // edi@1
  int v17; // edi@1
  int v18; // ecx@1
  int v19; // ST1C_4@1
  int v20; // ebx@1
  unsigned int v21; // ebp@1
  unsigned int v22; // ST38_4@1
  int v23; // edx@1
  int v24; // ST10_4@1
  unsigned int v25; // ST3C_4@1
  int v26; // esi@1
  int v27; // esi@1
  int v28; // ST18_4@1
  int v29; // ebp@1
  unsigned int v30; // ST40_4@1
  int v31; // edi@1
  int v32; // ebx@1
  int v33; // ST14_4@1
  unsigned int v34; // ST44_4@1
  int v35; // edi@1
  int v36; // ST20_4@1
  int v37; // ST1C_4@1
  unsigned int v38; // ST48_4@1
  int v39; // ebx@1
  int v40; // ebx@1
  int v41; // ecx@1
  int v42; // ebp@1
  unsigned int v43; // ST4C_4@1
  int v44; // edx@1
  int v45; // edx@1
  int v46; // ST10_4@1
  int v47; // esi@1
  unsigned int v48; // ST50_4@1
  int v49; // esi@1
  int v50; // ST18_4@1
  unsigned int v51; // ST54_4@1
  int v52; // edi@1
  int v53; // ebx@1
  int v54; // ST14_4@1
  unsigned int v55; // ST58_4@1
  int v56; // edi@1
  int v57; // ST20_4@1
  int v58; // ebx@1
  unsigned int v59; // ST5C_4@1
  int v60; // ebx@1
  int v61; // ecx@1
  int v62; // ST14_4@1
  int v63; // ST1C_4@1
  unsigned int v64; // ST60_4@1
  int v65; // edx@1
  int v66; // edx@1
  int v67; // ST10_4@1
  unsigned int v68; // ST64_4@1
  int v69; // esi@1
  int v70; // esi@1
  int v71; // ST18_4@1
  int v72; // ebp@1
  int v73; // ecx@1
  int v74; // ebx@1
  int v75; // ST68_4@1
  int v76; // edi@1
  int v77; // edi@1
  int v78; // ST14_4@1
  int v79; // ST20_4@1
  int v80; // ecx@1
  int v81; // ST6C_4@1
  int v82; // edi@1
  int v83; // ecx@1
  int v84; // ST70_4@1
  int v85; // ebx@1
  int v86; // ST1C_4@1
  int v87; // ebx@1
  int v88; // ecx@1
  int v89; // ST14_4@1
  int v90; // ecx@1
  int v91; // ST74_4@1
  int v92; // edx@1
  int v93; // edx@1
  int v94; // ST10_4@1
  int v95; // ecx@1
  int v96; // ST78_4@1
  int v97; // esi@1
  int v98; // esi@1
  int v99; // ST18_4@1
  int v100; // ebx@1
  int v101; // ecx@1
  int v102; // edi@1
  int v103; // ST7C_4@1
  int v104; // edi@1
  int v105; // ST20_4@1
  int v106; // ecx@1
  int v107; // ST80_4@1
  int v108; // edx@1
  int v109; // edx@1
  int v110; // ecx@1
  int v111; // ST84_4@1
  int v112; // ebx@1
  int v113; // ebx@1
  int v114; // ST14_4@1
  int v115; // ecx@1
  int v116; // ebp@1
  int v117; // ST88_4@1
  int v118; // edi@1
  int v119; // edi@1
  int v120; // ST10_4@1
  int v121; // ebp@1
  int v122; // ecx@1
  int v123; // ST8C_4@1
  int v124; // edx@1
  int v125; // ebp@1
  int v126; // edx@1
  int v127; // ecx@1
  int v128; // ST18_4@1
  int v129; // ST90_4@1
  int v130; // esi@1
  int v131; // esi@1
  int v132; // ST20_4@1
  int v133; // ecx@1
  int v134; // ST94_4@1
  int v135; // edi@1
  int v136; // edi@1
  int v137; // ecx@1
  int v138; // ST98_4@1
  int v139; // ebx@1
  int v140; // ebx@1
  int v141; // ST14_4@1
  int v142; // ecx@1
  int v143; // ebp@1
  int v144; // ST9C_4@1
  int v145; // esi@1
  int v146; // esi@1
  int v147; // ST10_4@1
  int v148; // ebp@1
  int v149; // ecx@1
  int v150; // STA0_4@1
  int v151; // edi@1
  int v152; // ebp@1
  int v153; // edx@1
  int v154; // ecx@1
  int v155; // ST18_4@1
  int v156; // STA4_4@1
  int v157; // edi@1
  int v158; // edi@1
  int v159; // ST20_4@1
  int v160; // ecx@1
  int v161; // STA8_4@1
  int v162; // esi@1
  int v163; // esi@1
  int v164; // ecx@1
  int v165; // STAC_4@1
  int v166; // ebx@1
  int v167; // ebx@1
  int v168; // ST14_4@1
  int v169; // ecx@1
  int v170; // ebp@1
  int v171; // STB0_4@1
  int v172; // edi@1
  int v173; // edi@1
  int v174; // ST10_4@1
  int v175; // ebp@1
  int v176; // ecx@1
  int v177; // STB4_4@1
  int v178; // esi@1
  int v179; // ebp@1
  int v180; // edx@1
  int v181; // ST18_4@1
  int v182; // ecx@1
  int v183; // STB8_4@1
  int v184; // esi@1
  int v185; // ebx@1
  int v186; // ST20_4@1
  int v187; // esi@1
  int v188; // ecx@1
  int v189; // STBC_4@1
  int v190; // edi@1
  int v191; // edi@1
  int v192; // ST1C_4@1
  int v193; // ecx@1
  int v194; // ebp@1
  int v195; // STC0_4@1
  int v196; // edx@1
  int v197; // ecx@1
  int v198; // esi@1
  int v199; // STC4_4@1
  int v200; // ebp@1
  int v201; // esi@1
  int v202; // ST10_4@1
  int v203; // ecx@1
  int v204; // ebp@1
  int v205; // edi@1
  int v206; // STC8_4@1
  int v207; // ST1C_4@1
  int v208; // ecx@1
  int v209; // STCC_4@1
  int v210; // ebx@1
  int v211; // ST18_4@1
  int v212; // ecx@1
  int v213; // STD0_4@1
  int v214; // edx@1
  int v215; // edi@1
  int v216; // ebx@1
  int v217; // ecx@1
  int v218; // edx@1
  int v219; // ebx@1
  int v220; // ecx@1
  int v221; // ST1C_4@1
  int v222; // ebp@1
  int v223; // STD4_4@1
  int v224; // ST10_4@1
  int v225; // edx@1
  int v226; // ecx@1
  int v227; // ST14_4@1
  int v228; // STD8_4@1
  int v229; // ebp@1
  int v230; // ebx@1
  int v231; // ecx@1
  int v232; // esi@1
  int v233; // ST10_4@1
  int v234; // ecx@1
  int v235; // STDC_4@1
  int v236; // edi@1
  int v237; // ebx@1
  int v238; // ecx@1
  int v239; // edi@1
  int v240; // STE0_4@1
  int v241; // ebx@1
  int v242; // ST18_4@1
  int v243; // ST1C_4@1
  int v244; // ecx@1
  int v245; // edx@1
  int v246; // STE4_4@1
  int v247; // edi@1
  int v248; // ebx@1
  int v249; // ecx@1
  int v250; // edx@1
  int v251; // ebx@1
  int v252; // ecx@1
  int v253; // ST1C_4@1
  int v254; // ebp@1
  int v255; // STE8_4@1
  int v256; // ST10_4@1
  int v257; // edx@1
  int v258; // ecx@1
  int v259; // ebx@1
  int v260; // ST14_4@1
  int v261; // STEC_4@1
  int v262; // ebp@1
  int v263; // ecx@1
  int v264; // esi@1
  int v265; // ST10_4@1
  int v266; // ecx@1
  int v267; // edi@1
  int v268; // STF0_4@1
  int v269; // ebx@1
  int v270; // edi@1
  int v271; // ecx@1
  int v272; // ebx@1
  int v273; // STF4_4@1
  int v274; // ST1C_4@1
  int v275; // ST18_4@1
  int v276; // ecx@1
  int v277; // edx@1
  int v278; // edi@1
  int v279; // STF8_4@1
  int v280; // ebx@1
  int v281; // ecx@1
  int v282; // edx@1
  int v283; // ST1C_4@1
  int v284; // ecx@1
  int v285; // ST10_4@1
  int v286; // STFC_4@1
  int v287; // ebp@1
  int v288; // edx@1
  int v289; // ecx@1
  int v290; // ST100_4@1
  int v291; // ST14_4@1
  int v292; // ebp@1
  int v293; // ebx@1
  int v294; // ecx@1
  int v295; // esi@1
  int v296; // ST10_4@1
  int v297; // ecx@1
  int v298; // edi@1
  int v299; // ST104_4@1
  int v300; // ebx@1
  int v301; // edi@1
  int v302; // ecx@1
  int v303; // ebx@1
  int v304; // ST108_4@1
  int v305; // ST1C_4@1
  int v306; // ST18_4@1
  int v307; // ecx@1
  int v308; // edi@1
  int v309; // ST10C_4@1
  int v310; // ebx@1
  int v311; // edx@1
  int v312; // ecx@1
  int v313; // ST1C_4@1
  int v314; // ecx@1
  int v315; // ST110_4@1
  int v316; // ebp@1
  int v317; // ebx@1
  int v318; // edx@1
  int v319; // ecx@1
  int v320; // ST114_4@1
  int v321; // ST14_4@1
  int v322; // ebp@1
  int v323; // edi@1
  int v324; // ecx@1
  int v325; // edx@1
  int v326; // ebp@1
  int v327; // ST118_4@1
  int v328; // esi@1
  int v329; // ST10_4@1
  int v330; // ecx@1
  int v331; // ST18_4@1
  int v332; // ST11C_4@1
  int v333; // ebx@1
  int v334; // esi@1
  int v335; // edi@1
  int v336; // edi@1
  int v337; // ST20_4@1
  int v338; // ebx@1
  int v339; // ecx@1
  int v340; // edx@1
  int v341; // ST120_4@1
  int v342; // edx@1
  int v343; // ecx@1
  int v344; // ST124_4@1
  int v345; // ebx@1
  int v346; // ebx@1
  int v347; // ecx@1
  int v348; // ST14_4@1
  int v349; // ST128_4@1
  int v350; // ebp@1
  int v351; // edi@1
  int v352; // edi@1
  int v353; // ecx@1
  int v354; // ST10_4@1
  int v355; // ST12C_4@1
  int v356; // ebp@1
  int v357; // edx@1
  int v358; // ST18_4@1
  int v359; // ecx@1
  int v360; // ST130_4@1
  int v361; // edx@1
  int v362; // esi@1
  int v363; // esi@1
  int v364; // ST20_4@1
  int v365; // ecx@1
  int v366; // ebx@1
  int v367; // edi@1
  int v368; // ST134_4@1
  int v369; // edi@1
  int v370; // ecx@1
  int v371; // ebp@1
  int v372; // ST138_4@1
  int v373; // ebx@1
  int v374; // ebx@1
  int v375; // ecx@1
  int v376; // ST14_4@1
  int v377; // ST13C_4@1
  int v378; // ebp@1
  int v379; // esi@1
  int v380; // esi@1
  int v381; // ecx@1
  int v382; // ST10_4@1
  int v383; // ST140_4@1
  int v384; // ebp@1
  int v385; // edi@1
  int v386; // edi@1
  int v387; // ecx@1
  int v388; // ebp@1
  int v389; // edx@1
  int v390; // ST18_4@1
  int v391; // ebx@1
  int v392; // ST20_4@1
  int v393; // edx@1
  int v394; // ST14_4@1
  int v395; // esi@1
  int v396; // ST148_4@1
  int v397; // ST10_4@1
  int v398; // ST1C_4@1
  int v399; // edx@1
  int v400; // ebx@1
  int v401; // ST14C_4@1
  int v402; // esi@1
  int v403; // ebx@1
  int v404; // ST18_4@1
  int v405; // ST14_4@1
  int v406; // edx@1
  int v407; // edi@1
  int v408; // esi@1
  int v409; // ebx@1
  int v410; // ST20_4@1
  int v411; // esi@1
  int v412; // ST10_4@1
  int v413; // ebx@1
  int v414; // edi@1
  int v415; // ebp@1
  int v416; // edi@1
  int v417; // ST24_4@1
  int v418; // ST1C_4@1
  int v419; // edi@1
  int v420; // ebx@1
  int v421; // ST20_4@1
  int v422; // edx@1
  int v423; // ebx@1
  int v424; // edx@1
  int v425; // ebx@1
  int v426; // ST1C_4@1
  int v427; // esi@1
  int v428; // ebx@1
  int v429; // esi@1
  int v430; // ecx@1
  int v431; // ebx@1
  int v432; // ebx@1
  int v433; // edx@1
  int v434; // ecx@1

  v1 = *(_DWORD *)(result + 8);
  v2 = *(_DWORD *)(result + 12);
  v3 = __ROL4__(*(_DWORD *)(result + 8), 5);
  v4 = ((*(_DWORD *)(result + 28) & 0xFF00 | (*(_DWORD *)(result + 28) << 16)) << 8) | (((*(_DWORD *)(result + 28) >> 16) | *(_DWORD *)(result + 28) & 0xFF0000u) >> 8);
  v5 = v4
     + *(_DWORD *)(result + 24)
     + v3
     + (v2 & *(_DWORD *)(result + 16) ^ *(_DWORD *)(result + 20) & ~*(_DWORD *)(result + 12))
     + 1518500249;
  v2 = __ROR4__(v2, 2);
  v6 = v2;
  v7 = ((*(_DWORD *)(result + 32) & 0xFF00 | (*(_DWORD *)(result + 32) << 16)) << 8) | (((*(_DWORD *)(result + 32) >> 16) | *(_DWORD *)(result + 32) & 0xFF0000u) >> 8);
  v8 = v1 & v2 ^ *(_DWORD *)(result + 16) & ~v1;
  v9 = __ROL4__(v5, 5);
  v10 = *(_DWORD *)(result + 20) + v7 + v9 + v8 + 1518500249;
  v1 = __ROR4__(v1, 2);
  v11 = v10;
  v10 = __ROL4__(v10, 5);
  v12 = v1;
  v13 = ((*(_DWORD *)(result + 36) & 0xFF00 | (*(_DWORD *)(result + 36) << 16)) << 8) | (((*(_DWORD *)(result + 36) >> 16) | *(_DWORD *)(result + 36) & 0xFF0000u) >> 8);
  v14 = *(_DWORD *)(result + 16) + v13 + v10 + (v1 & v5 ^ v6 & ~v5) + 1518500249;
  v5 = __ROR4__(v5, 2);
  v15 = ((*(_DWORD *)(result + 40) & 0xFF00 | (*(_DWORD *)(result + 40) << 16)) << 8) | (((*(_DWORD *)(result + 40) >> 16) | *(_DWORD *)(result + 40) & 0xFF0000u) >> 8);
  v16 = __ROL4__(v14, 5);
  v17 = v6 + v15 + v16 + (v11 & v5 ^ v1 & ~v11) + 1518500249;
  v18 = __ROR4__(v11, 2);
  v19 = v5;
  v20 = __ROL4__(v17, 5);
  v21 = (((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8))
      + v20
      + (v14 & v18 ^ v5 & ~v14);
  v22 = ((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8);
  v14 = __ROR4__(v14, 2);
  v23 = v12 + v21 + 1518500249;
  v24 = v14;
  v25 = ((*(_DWORD *)(result + 48) & 0xFF00 | (*(_DWORD *)(result + 48) << 16)) << 8) | (((*(_DWORD *)(result + 48) >> 16) | *(_DWORD *)(result + 48) & 0xFF0000u) >> 8);
  v26 = __ROL4__(v23, 5);
  v27 = v19 + v25 + v26 + (v17 & v24 ^ v18 & ~v17) + 1518500249;
  v17 = __ROR4__(v17, 2);
  v28 = v17;
  v29 = v23 & v17;
  v30 = ((*(_DWORD *)(result + 52) & 0xFF00 | (*(_DWORD *)(result + 52) << 16)) << 8) | (((*(_DWORD *)(result + 52) >> 16) | *(_DWORD *)(result + 52) & 0xFF0000u) >> 8);
  v31 = __ROL4__(v27, 5);
  v32 = v18 + v30 + v31 + (v29 ^ v24 & ~v23) + 1518500249;
  v23 = __ROR4__(v23, 2);
  v33 = v32;
  v32 = __ROL4__(v32, 5);
  v34 = ((*(_DWORD *)(result + 56) & 0xFF00 | (*(_DWORD *)(result + 56) << 16)) << 8) | (((*(_DWORD *)(result + 56) >> 16) | *(_DWORD *)(result + 56) & 0xFF0000u) >> 8);
  v35 = v24 + v34 + v32 + (v23 & v27 ^ v28 & ~v27) + 1518500249;
  v27 = __ROR4__(v27, 2);
  v36 = v23;
  v37 = v27;
  v38 = ((*(_DWORD *)(result + 60) & 0xFF00 | (*(_DWORD *)(result + 60) << 16)) << 8) | (((*(_DWORD *)(result + 60) >> 16) | *(_DWORD *)(result + 60) & 0xFF0000u) >> 8);
  v39 = __ROL4__(v35, 5);
  v40 = v28 + v38 + v39 + (v33 & v27 ^ v23 & ~v33) + 1518500249;
  v41 = __ROR4__(v33, 2);
  v42 = v35 & v41 ^ v27 & ~v35;
  v43 = ((*(_DWORD *)(result + 64) & 0xFF00 | (*(_DWORD *)(result + 64) << 16)) << 8) | (((*(_DWORD *)(result + 64) >> 16) | *(_DWORD *)(result + 64) & 0xFF0000u) >> 8);
  v44 = __ROL4__(v40, 5);
  v35 = __ROR4__(v35, 2);
  v45 = v36 + v43 + v44 + v42 + 1518500249;
  v46 = v35;
  v47 = __ROL4__(v45, 5);
  v48 = ((*(_DWORD *)(result + 68) & 0xFF00 | (*(_DWORD *)(result + 68) << 16)) << 8) | (((*(_DWORD *)(result + 68) >> 16) | *(_DWORD *)(result + 68) & 0xFF0000u) >> 8);
  v49 = v37 + v48 + v47 + (v40 & v35 ^ v41 & ~v40) + 1518500249;
  v40 = __ROR4__(v40, 2);
  v50 = v40;
  v51 = ((*(_DWORD *)(result + 72) & 0xFF00 | (*(_DWORD *)(result + 72) << 16)) << 8) | (((*(_DWORD *)(result + 72) >> 16) | *(_DWORD *)(result + 72) & 0xFF0000u) >> 8);
  v52 = __ROL4__(v49, 5);
  v53 = v41 + v51 + v52 + (v45 & v40 ^ v46 & ~v45) + 1518500249;
  v54 = v53;
  v45 = __ROR4__(v45, 2);
  v53 = __ROL4__(v53, 5);
  v55 = ((*(_DWORD *)(result + 76) & 0xFF00 | (*(_DWORD *)(result + 76) << 16)) << 8) | (((*(_DWORD *)(result + 76) >> 16) | *(_DWORD *)(result + 76) & 0xFF0000u) >> 8);
  v56 = v46 + v55 + v53 + (v45 & v49 ^ v50 & ~v49) + 1518500249;
  v49 = __ROR4__(v49, 2);
  v57 = v45;
  v58 = __ROL4__(v56, 5);
  v59 = ((*(_DWORD *)(result + 80) & 0xFF00 | (*(_DWORD *)(result + 80) << 16)) << 8) | (((*(_DWORD *)(result + 80) >> 16) | *(_DWORD *)(result + 80) & 0xFF0000u) >> 8);
  v60 = v50 + v59 + v58 + (v54 & v49 ^ v45 & ~v54) + 1518500249;
  v61 = __ROR4__(v54, 2);
  v62 = v61;
  v63 = v49;
  v64 = ((*(_DWORD *)(result + 84) & 0xFF00 | (*(_DWORD *)(result + 84) << 16)) << 8) | (((*(_DWORD *)(result + 84) >> 16) | *(_DWORD *)(result + 84) & 0xFF0000u) >> 8);
  v65 = __ROL4__(v60, 5);
  v66 = v57 + v64 + v65 + (v56 & v61 ^ v49 & ~v56) + 1518500249;
  v56 = __ROR4__(v56, 2);
  v67 = v56;
  v68 = ((*(_DWORD *)(result + 88) & 0xFF00 | (*(_DWORD *)(result + 88) << 16)) << 8) | (((*(_DWORD *)(result + 88) >> 16) | *(_DWORD *)(result + 88) & 0xFF0000u) >> 8);
  v69 = __ROL4__(v66, 5);
  v70 = v63 + v68 + v69 + (v60 & v56 ^ v61 & ~v60) + 1518500249;
  v60 = __ROR4__(v60, 2);
  v71 = v60;
  v72 = v60;
  v73 = __ROL4__(v4 ^ v13 ^ v38 ^ v59, 1);
  v74 = v56 & ~v66;
  v75 = v73;
  v76 = __ROL4__(v70, 5);
  v77 = v62 + v73 + v76 + (v66 & v72 ^ v74) + 1518500249;
  v66 = __ROR4__(v66, 2);
  v78 = v77;
  v79 = v66;
  v80 = __ROL4__(v7 ^ v15 ^ v43 ^ v64, 1);
  v81 = v80;
  v77 = __ROL4__(v77, 5);
  v82 = v67 + v80 + v77 + (v66 & v70 ^ v71 & ~v70) + 1518500249;
  v70 = __ROR4__(v70, 2);
  v83 = __ROL4__(v13 ^ v22 ^ v48 ^ v68, 1);
  v84 = v83;
  v85 = __ROL4__(v82, 5);
  v86 = v70;
  v87 = v71 + v83 + v85 + (v78 & v70 ^ v66 & ~v78) + 1518500249;
  v88 = __ROR4__(v78, 2);
  v89 = v88;
  v90 = __ROL4__(v15 ^ v25 ^ v51 ^ v75, 1);
  v91 = v90;
  v92 = __ROL4__(v87, 5);
  v93 = v79 + v90 + v92 + (v82 & v89 ^ v70 & ~v82) + 1518500249;
  v82 = __ROR4__(v82, 2);
  v94 = v82;
  v95 = __ROL4__(v22 ^ v30 ^ v55 ^ v81, 1);
  v96 = v95;
  v97 = __ROL4__(v93, 5);
  v98 = v86 + v95 + v97 + (v87 ^ v82 ^ v89) + 1859775393;
  v87 = __ROR4__(v87, 2);
  v99 = v87;
  v100 = v87 ^ v82;
  v101 = __ROL4__(v25 ^ v34 ^ v59 ^ v84, 1);
  v102 = __ROL4__(v98, 5);
  v103 = v101;
  v104 = v89 + v101 + v102 + (v93 ^ v100) + 1859775393;
  v93 = __ROR4__(v93, 2);
  v105 = v93;
  v106 = __ROL4__(v30 ^ v38 ^ v64 ^ v91, 1);
  v107 = v106;
  v108 = __ROL4__(v104, 5);
  v109 = v94 + v106 + v108 + (v105 ^ v99 ^ v98) + 1859775393;
  v98 = __ROR4__(v98, 2);
  v110 = __ROL4__(v34 ^ v43 ^ v68 ^ v96, 1);
  v111 = v110;
  v112 = __ROL4__(v109, 5);
  v113 = v99 + v110 + v112 + (v105 ^ v104 ^ v98) + 1859775393;
  v104 = __ROR4__(v104, 2);
  v114 = v104;
  v115 = __ROL4__(v38 ^ v48 ^ v75 ^ v103, 1);
  v116 = v109 ^ v104 ^ v98;
  v117 = v115;
  v118 = __ROL4__(v113, 5);
  v119 = v105 + v115 + v118 + v116 + 1859775393;
  v109 = __ROR4__(v109, 2);
  v120 = v109;
  v121 = v109 ^ v114;
  v122 = __ROL4__(v43 ^ v51 ^ v81 ^ v107, 1);
  v123 = v122;
  v124 = __ROL4__(v119, 5);
  v125 = v122 + v124 + (v113 ^ v121);
  v113 = __ROR4__(v113, 2);
  v126 = v98 + v125 + 1859775393;
  v127 = __ROL4__(v48 ^ v55 ^ v84 ^ v111, 1);
  v128 = v113;
  v129 = v127;
  v130 = __ROL4__(v126, 5);
  v131 = v114 + v127 + v130 + (v119 ^ v113 ^ v120) + 1859775393;
  v119 = __ROR4__(v119, 2);
  v132 = v119;
  v133 = __ROL4__(v51 ^ v59 ^ v91 ^ v117, 1);
  v134 = v133;
  v135 = __ROL4__(v131, 5);
  v136 = v120 + v133 + v135 + (v132 ^ v113 ^ v126) + 1859775393;
  v126 = __ROR4__(v126, 2);
  v137 = __ROL4__(v55 ^ v64 ^ v96 ^ v123, 1);
  v138 = v137;
  v139 = __ROL4__(v136, 5);
  v140 = v128 + v137 + v139 + (v132 ^ v131 ^ v126) + 1859775393;
  v131 = __ROR4__(v131, 2);
  v141 = v131;
  v142 = __ROL4__(v59 ^ v68 ^ v103 ^ v129, 1);
  v143 = v136 ^ v131 ^ v126;
  v144 = v142;
  v145 = __ROL4__(v140, 5);
  v146 = v132 + v142 + v145 + v143 + 1859775393;
  v136 = __ROR4__(v136, 2);
  v147 = v136;
  v148 = v136 ^ v141;
  v149 = __ROL4__(v64 ^ v75 ^ v107 ^ v134, 1);
  v150 = v149;
  v151 = __ROL4__(v146, 5);
  v152 = v149 + v151 + (v140 ^ v148);
  v140 = __ROR4__(v140, 2);
  v153 = v126 + v152 + 1859775393;
  v154 = __ROL4__(v68 ^ v81 ^ v111 ^ v138, 1);
  v155 = v140;
  v156 = v154;
  v157 = __ROL4__(v153, 5);
  v158 = v141 + v154 + v157 + (v146 ^ v140 ^ v147) + 1859775393;
  v146 = __ROR4__(v146, 2);
  v159 = v146;
  v160 = __ROL4__(v75 ^ v84 ^ v117 ^ v144, 1);
  v161 = v160;
  v162 = __ROL4__(v158, 5);
  v163 = v147 + v160 + v162 + (v159 ^ v140 ^ v153) + 1859775393;
  v153 = __ROR4__(v153, 2);
  v164 = __ROL4__(v81 ^ v91 ^ v123 ^ v150, 1);
  v165 = v164;
  v166 = __ROL4__(v163, 5);
  v167 = v155 + v164 + v166 + (v159 ^ v158 ^ v153) + 1859775393;
  v158 = __ROR4__(v158, 2);
  v168 = v158;
  v169 = __ROL4__(v84 ^ v96 ^ v129 ^ v156, 1);
  v170 = v163 ^ v158 ^ v153;
  v171 = v169;
  v172 = __ROL4__(v167, 5);
  v173 = v159 + v169 + v172 + v170 + 1859775393;
  v163 = __ROR4__(v163, 2);
  v174 = v163;
  v175 = v163 ^ v168;
  v176 = __ROL4__(v91 ^ v103 ^ v134 ^ v161, 1);
  v177 = v176;
  v178 = __ROL4__(v173, 5);
  v179 = v176 + v178 + (v167 ^ v175);
  v167 = __ROR4__(v167, 2);
  v180 = v153 + v179 + 1859775393;
  v181 = v167;
  v182 = __ROL4__(v96 ^ v107 ^ v138 ^ v165, 1);
  v183 = v182;
  v184 = __ROL4__(v180, 5);
  v185 = v168 + v182 + v184 + (v173 ^ v167 ^ v174) + 1859775393;
  v173 = __ROR4__(v173, 2);
  v186 = v173;
  v187 = v173;
  v188 = __ROL4__(v103 ^ v111 ^ v144 ^ v171, 1);
  v189 = v188;
  v190 = __ROL4__(v185, 5);
  v191 = v174 + v188 + v190 + (v187 ^ v181 ^ v180) + 1859775393;
  v180 = __ROR4__(v180, 2);
  v192 = v180;
  v193 = __ROL4__(v107 ^ v117 ^ v150 ^ v177, 1);
  v194 = __ROL4__(v191, 5);
  v195 = v193;
  v196 = v181 + v193 + v194 + (v187 ^ v185 ^ v180) + 1859775393;
  v185 = __ROR4__(v185, 2);
  v197 = __ROL4__(v111 ^ v123 ^ v156 ^ v183, 1);
  v198 = __ROL4__(v196, 5);
  v199 = v197;
  v200 = v197 + v198 + (v191 ^ v185 ^ v192);
  v191 = __ROR4__(v191, 2);
  v201 = v186 + v200 + 1859775393;
  v202 = v191;
  v203 = __ROL4__(v117 ^ v129 ^ v161 ^ v189, 1);
  v204 = __ROL4__(v201, 5);
  v205 = v192 + v203 + (v196 & v191 ^ v185 & (v196 ^ v191)) + v204 - 1894007588;
  v206 = v203;
  v207 = v205;
  v196 = __ROR4__(v196, 2);
  v208 = __ROL4__(v123 ^ v134 ^ v165 ^ v195, 1);
  v209 = v208;
  v210 = v185 + v208 + (v201 & v196 ^ v202 & (v201 ^ v196));
  v205 = __ROL4__(v205, 5);
  v201 = __ROR4__(v201, 2);
  v211 = v196;
  v212 = __ROL4__(v129 ^ v138 ^ v171 ^ v199, 1);
  v213 = v212;
  v214 = v202 + v212 + (v201 & v196 ^ v207 & (v201 ^ v196));
  v215 = v210 + v205 - 1894007588;
  v216 = __ROL4__(v215, 5);
  v217 = __ROR4__(v207, 2);
  v218 = v214 + v216 - 1894007588;
  v219 = v217;
  v220 = __ROL4__(v134 ^ v144 ^ v177 ^ v206, 1);
  v221 = v219;
  v222 = v211 + v220 + (v201 & v215 ^ v219 & (v201 ^ v215));
  v223 = v220;
  v224 = v218;
  v218 = __ROL4__(v218, 5);
  v215 = __ROR4__(v215, 2);
  v225 = v218 + v222 - 1894007588;
  v226 = __ROL4__(v138 ^ v150 ^ v183 ^ v209, 1);
  v227 = v215;
  v228 = v226;
  v229 = v226 + (v224 & v215 ^ v219 & (v224 ^ v215));
  v230 = __ROL4__(v225, 5);
  v231 = __ROR4__(v224, 2);
  v232 = v230 + v201 + v229 - 1894007588;
  v233 = v231;
  v234 = __ROL4__(v144 ^ v156 ^ v189 ^ v213, 1);
  v235 = v234;
  v236 = v221 + v234 + (v225 & v233 ^ v215 & (v225 ^ v233));
  v237 = __ROL4__(v232, 5);
  v225 = __ROR4__(v225, 2);
  v238 = __ROL4__(v150 ^ v161 ^ v195 ^ v223, 1);
  v239 = v236 + v237 - 1894007588;
  v240 = v238;
  v241 = v227 + v238 + (v232 & v225 ^ v233 & (v232 ^ v225));
  v242 = v225;
  v243 = v239;
  v239 = __ROL4__(v239, 5);
  v232 = __ROR4__(v232, 2);
  v244 = __ROL4__(v156 ^ v165 ^ v199 ^ v228, 1);
  v245 = v233 + v244 + (v232 & v225 ^ v243 & (v232 ^ v225));
  v246 = v244;
  v247 = v241 + v239 - 1894007588;
  v248 = __ROL4__(v247, 5);
  v249 = __ROR4__(v243, 2);
  v250 = v245 + v248 - 1894007588;
  v251 = v249;
  v252 = __ROL4__(v161 ^ v171 ^ v206 ^ v235, 1);
  v253 = v251;
  v254 = v242 + v252 + (v232 & v247 ^ v251 & (v232 ^ v247));
  v255 = v252;
  v256 = v250;
  v250 = __ROL4__(v250, 5);
  v247 = __ROR4__(v247, 2);
  v257 = v250 + v254 - 1894007588;
  v258 = __ROL4__(v165 ^ v177 ^ v209 ^ v240, 1);
  v259 = __ROL4__(v257, 5);
  v260 = v247;
  v261 = v258;
  v262 = v258 + (v256 & v247 ^ v253 & (v256 ^ v247));
  v263 = __ROR4__(v256, 2);
  v264 = v259 + v232 + v262 - 1894007588;
  v265 = v263;
  v266 = __ROL4__(v171 ^ v183 ^ v213 ^ v246, 1);
  v267 = v253 + v266 + (v257 & v265 ^ v247 & (v257 ^ v265));
  v268 = v266;
  v269 = __ROL4__(v264, 5);
  v257 = __ROR4__(v257, 2);
  v270 = v267 + v269 - 1894007588;
  v271 = __ROL4__(v177 ^ v189 ^ v223 ^ v255, 1);
  v272 = v260 + v271 + (v264 & v257 ^ v265 & (v264 ^ v257));
  v273 = v271;
  v274 = v270;
  v270 = __ROL4__(v270, 5);
  v264 = __ROR4__(v264, 2);
  v275 = v257;
  v276 = __ROL4__(v183 ^ v195 ^ v228 ^ v261, 1);
  v277 = v265 + v276 + (v264 & v257 ^ v274 & (v264 ^ v257));
  v278 = v272 + v270 - 1894007588;
  v279 = v276;
  v280 = __ROL4__(v278, 5);
  v281 = __ROR4__(v274, 2);
  v282 = v277 + v280 - 1894007588;
  v283 = v281;
  v284 = __ROL4__(v189 ^ v199 ^ v235 ^ v268, 1);
  v285 = v282;
  v282 = __ROL4__(v282, 5);
  v286 = v284;
  v287 = v275 + v284 + (v264 & v278 ^ v283 & (v264 ^ v278));
  v278 = __ROR4__(v278, 2);
  v288 = v282 + v287 - 1894007588;
  v289 = __ROL4__(v195 ^ v206 ^ v240 ^ v273, 1);
  v290 = v289;
  v291 = v278;
  v292 = v289 + (v285 & v278 ^ v283 & (v285 ^ v278));
  v293 = __ROL4__(v288, 5);
  v294 = __ROR4__(v285, 2);
  v295 = v293 + v264 + v292 - 1894007588;
  v296 = v294;
  v297 = __ROL4__(v199 ^ v209 ^ v246 ^ v279, 1);
  v298 = v283 + v297 + (v288 & v296 ^ v278 & (v288 ^ v296));
  v299 = v297;
  v300 = __ROL4__(v295, 5);
  v288 = __ROR4__(v288, 2);
  v301 = v298 + v300 - 1894007588;
  v302 = __ROL4__(v206 ^ v213 ^ v255 ^ v286, 1);
  v303 = v291 + v302 + (v295 & v288 ^ v296 & (v295 ^ v288));
  v304 = v302;
  v305 = v301;
  v306 = v288;
  v301 = __ROL4__(v301, 5);
  v295 = __ROR4__(v295, 2);
  v307 = __ROL4__(v209 ^ v223 ^ v261 ^ v290, 1);
  v308 = v303 + v301 - 1894007588;
  v309 = v307;
  v310 = __ROL4__(v308, 5);
  v311 = v296 + v307 + (v295 & v288 ^ v305 & (v295 ^ v288)) + v310 - 1894007588;
  v312 = __ROR4__(v305, 2);
  v313 = v312;
  v314 = __ROL4__(v213 ^ v228 ^ v268 ^ v299, 1);
  v315 = v314;
  v316 = v306 + v314 + (v295 & v308 ^ v313 & (v295 ^ v308));
  v317 = v311;
  v311 = __ROL4__(v311, 5);
  v308 = __ROR4__(v308, 2);
  v318 = v311 + v316 - 1894007588;
  v319 = __ROL4__(v223 ^ v235 ^ v273 ^ v304, 1);
  v320 = v319;
  v321 = v308;
  v322 = v319 + (v317 & v308 ^ v313 & (v317 ^ v308));
  v323 = v318;
  v318 = __ROL4__(v318, 5);
  v317 = __ROR4__(v317, 2);
  v324 = __ROL4__(v228 ^ v240 ^ v279 ^ v309, 1);
  v325 = v318 + v295 + v322 - 1894007588;
  v326 = v313 + v324 + (v323 ^ v317 ^ v321);
  v327 = v324;
  v328 = __ROL4__(v325, 5);
  v323 = __ROR4__(v323, 2);
  v329 = v317;
  v330 = __ROL4__(v235 ^ v246 ^ v286 ^ v315, 1);
  v331 = v323;
  v332 = v330;
  v333 = v321 + v330 + (v325 ^ v323 ^ v317);
  v334 = v328 + v326 - 899497514;
  v335 = __ROL4__(v334, 5);
  v336 = v333 + v335 - 899497514;
  v325 = __ROR4__(v325, 2);
  v337 = v325;
  v338 = v325 ^ v331 ^ v334;
  v339 = __ROL4__(v240 ^ v255 ^ v290 ^ v320, 1);
  v340 = __ROL4__(v336, 5);
  v341 = v339;
  v334 = __ROR4__(v334, 2);
  v342 = v329 + v339 + v338 + v340 - 899497514;
  v343 = __ROL4__(v246 ^ v261 ^ v299 ^ v327, 1);
  v344 = v343;
  v345 = __ROL4__(v342, 5);
  v346 = v345 + v331 + v343 + (v337 ^ v336 ^ v334) - 899497514;
  v336 = __ROR4__(v336, 2);
  v347 = __ROL4__(v255 ^ v268 ^ v304 ^ v332, 1);
  v348 = v336;
  v349 = v347;
  v350 = v337 + v347 + (v342 ^ v336 ^ v334);
  v351 = __ROL4__(v346, 5);
  v342 = __ROR4__(v342, 2);
  v352 = v351 + v350 - 899497514;
  v353 = __ROL4__(v261 ^ v273 ^ v309 ^ v341, 1);
  v354 = v342;
  v355 = v353;
  v356 = v353 + (v346 ^ v342 ^ v348);
  v357 = __ROL4__(v352, 5);
  v346 = __ROR4__(v346, 2);
  v358 = v346;
  v359 = __ROL4__(v268 ^ v279 ^ v315 ^ v344, 1);
  v360 = v359;
  v361 = v357 + v334 + v356 - 899497514;
  v362 = __ROL4__(v361, 5);
  v363 = v348 + v359 + (v352 ^ v346 ^ v354) + v362 - 899497514;
  v352 = __ROR4__(v352, 2);
  v364 = v352;
  v365 = __ROL4__(v273 ^ v286 ^ v320 ^ v349, 1);
  v366 = v352 ^ v346 ^ v361;
  v367 = __ROL4__(v363, 5);
  v368 = v365;
  v369 = v354 + v365 + v366 + v367 - 899497514;
  v361 = __ROR4__(v361, 2);
  v370 = __ROL4__(v279 ^ v290 ^ v327 ^ v355, 1);
  v371 = v358 + v370 + (v364 ^ v363 ^ v361);
  v372 = v370;
  v373 = __ROL4__(v369, 5);
  v363 = __ROR4__(v363, 2);
  v374 = v373 + v371 - 899497514;
  v375 = __ROL4__(v286 ^ v299 ^ v332 ^ v360, 1);
  v376 = v363;
  v377 = v375;
  v378 = v364 + v375 + (v369 ^ v363 ^ v361);
  v379 = __ROL4__(v374, 5);
  v380 = v379 + v378 - 899497514;
  v369 = __ROR4__(v369, 2);
  v381 = __ROL4__(v290 ^ v304 ^ v341 ^ v368, 1);
  v382 = v369;
  v383 = v381;
  v384 = v381 + (v374 ^ v369 ^ v376);
  v385 = __ROL4__(v380, 5);
  v386 = v385 + v361 + v384 - 899497514;
  v374 = __ROR4__(v374, 2);
  v387 = __ROL4__(v299 ^ v309 ^ v344 ^ v372, 1);
  v388 = v376 + v387 + (v380 ^ v374 ^ v382);
  v389 = __ROL4__(v386, 5);
  v380 = __ROR4__(v380, 2);
  v390 = v374;
  v391 = v389 + v388 - 899497514;
  v392 = v380;
  v393 = __ROL4__(v304 ^ v315 ^ v349 ^ v377, 1);
  v394 = v391;
  v391 = __ROL4__(v391, 5);
  v395 = v382 + v393 + (v380 ^ v390 ^ v386) + v391 - 899497514;
  v386 = __ROR4__(v386, 2);
  v396 = v393;
  v397 = v395;
  v398 = v386;
  v399 = __ROL4__(v309 ^ v320 ^ v355 ^ v383, 1);
  v400 = __ROL4__(v395, 5);
  v401 = v399;
  v402 = __ROR4__(v394, 2);
  v403 = v400 + v390 + v399 + (v392 ^ v394 ^ v386) - 899497514;
  v404 = v403;
  v405 = v402;
  v406 = __ROL4__(v315 ^ v327 ^ v360 ^ v387, 1);
  v403 = __ROL4__(v403, 5);
  v407 = v392 + v406 + (v397 ^ v402 ^ v386) + v403 - 899497514;
  v408 = __ROR4__(v397, 2);
  v409 = v408;
  v410 = v407;
  v411 = __ROL4__(v320 ^ v332 ^ v368 ^ v396, 1);
  v407 = __ROL4__(v407, 5);
  v412 = v409;
  v413 = v407 + v398 + v411 + (v404 ^ v409 ^ v405) - 899497514;
  v414 = __ROR4__(v404, 2);
  v415 = v414;
  v416 = __ROL4__(v327 ^ v341 ^ v372 ^ v401, 1);
  v417 = v416;
  v418 = v413;
  v413 = __ROL4__(v413, 5);
  v419 = v405 + v416 + (v410 ^ v415 ^ v412) + v413 - 899497514;
  v420 = __ROR4__(v410, 2);
  v421 = v420;
  v422 = __ROL4__(v332 ^ v344 ^ v377 ^ v406, 1);
  v423 = __ROL4__(v419, 5);
  v424 = v412 + (v421 ^ v415 ^ v418) + v423 + v422 - 899497514;
  v425 = __ROR4__(v418, 2);
  v426 = v425;
  v427 = __ROL4__(v341 ^ v349 ^ v383 ^ v411, 1);
  v428 = __ROL4__(v424, 5);
  v429 = v415 + (v421 ^ v419 ^ v426) + v428 + v427 - 899497514;
  v419 = __ROR4__(v419, 2);
  v430 = __ROL4__(v417 ^ v344 ^ v355 ^ v387, 1);
  v431 = __ROL4__(v429, 5);
  v432 = v421 + (v424 ^ v419 ^ v426) + v431 + v430 - 899497514 + *(_DWORD *)(result + 8);
  *(_DWORD *)(result + 12) += v429;
  v424 = __ROR4__(v424, 2);
  v433 = *(_DWORD *)(result + 16) + v424;
  *(_DWORD *)(result + 20) += v419;
  v434 = *(_DWORD *)(result + 24);
  *(_DWORD *)(result + 8) = v432;
  *(_DWORD *)(result + 16) = v433;
  *(_DWORD *)(result + 24) = v426 + v434;
  return result;
}

//----- (1004DE70) --------------------------------------------------------
unsigned int __usercall sub_1004DE70@<eax>(int a1@<esi>, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@4
  unsigned int v5; // eax@7
  unsigned int result; // eax@7
  int v7; // edx@8

  v2 = *(_DWORD *)a1 & 0x3F;
  v3 = v2 >> 2;
  *(_DWORD *)(a1 + 4 * v3 + 28) = dword_100D6338[*(_BYTE *)a1 & 3] | *(_DWORD *)(a1 + 4 * v3 + 28) & dword_100D6348[*(_BYTE *)a1 & 3];
  if ( v2 > 0x37 )
  {
    if ( v2 < 0x3C )
      *(_DWORD *)(a1 + 88) = 0;
    sub_1004C750(a1);
    v4 = 0;
    goto LABEL_6;
  }
  v4 = v3 + 1;
  if ( v3 + 1 < 0xE )
LABEL_6:
    memset((void *)(a1 + 4 * v4 + 28), 0, 4 * (14 - v4));
  v5 = 8 * *(_DWORD *)a1;
  *(_DWORD *)(a1 + 84) = ((((unsigned int)(*(_QWORD *)a1 >> 29) << 16) | (*(_QWORD *)a1 >> 29) & 0xFF00) << 8) | ((((unsigned int)(*(_QWORD *)a1 >> 29) >> 16) | (*(_QWORD *)a1 >> 29) & 0xFF0000) >> 8);
  *(_DWORD *)(a1 + 88) = (((v5 << 16) | v5 & 0xFF00) << 8) | (((v5 >> 16) | v5 & 0xFF0000) >> 8);
  sub_1004C750(a1);
  result = 0;
  do
  {
    v7 = *(_DWORD *)(a1 + 4 * (result >> 2) + 8) >> 8 * (~(_BYTE)result & 3);
    *(_BYTE *)(++result + a2 - 1) = v7;
  }
  while ( result < 0x14 );
  return result;
}
// 100D6338: using guessed type int dword_100D6338[];
// 100D6348: using guessed type int dword_100D6348[];

//----- (1004DF70) --------------------------------------------------------
void *__usercall sub_1004DF70@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3)
{
  int v3; // ebp@1
  size_t v4; // ebx@1
  int v5; // edi@1
  unsigned int v6; // eax@1
  size_t v7; // esi@1
  char *v9; // [sp+14h] [bp+4h]@1

  v3 = (int)a3;
  v4 = a1;
  v5 = *a3 & 0x3F;
  v6 = a1 + *a3;
  v7 = 64 - v5;
  v9 = a2;
  *(_DWORD *)v3 = v6;
  if ( v6 < v4 )
    ++*(_DWORD *)(v3 + 4);
  if ( v4 >= v7 )
  {
    do
    {
      memcpy((void *)(v5 + v3 + 28), v9, v7);
      v9 += v7;
      v4 -= v7;
      v7 = 64;
      v5 = 0;
      sub_1004C750(v3);
    }
    while ( v4 >= 0x40 );
  }
  return memcpy((void *)(v5 + v3 + 28), v9, v4);
}

//----- (1004DFF0) --------------------------------------------------------
void *__usercall sub_1004DFF0@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3)
{
  int v3; // edi@1
  void *result; // eax@1
  unsigned int v5; // eax@4
  _DWORD *v6; // eax@6

  v3 = a1;
  result = *(void **)(a1 + 156);
  if ( result != (void *)-1 )
  {
    if ( (unsigned int)result > 0x40 )
    {
      sub_1004DE70(v3 + 64, v3);
      *(_DWORD *)(v3 + 156) = 20;
    }
    memset((void *)(v3 + *(_DWORD *)(v3 + 156)), 0, 64 - *(_DWORD *)(v3 + 156));
    v5 = 0;
    do
      *(_DWORD *)(v3 + 4 * v5++) ^= 0x36363636u;
    while ( v5 < 0x10 );
    v6 = (_DWORD *)sub_1004C710(v3 + 64);
    result = sub_1004DF70(0x40u, (char *)v3, v6);
    *(_DWORD *)(v3 + 156) = -1;
  }
  if ( a2 )
    result = sub_1004DF70(a2, a3, (_DWORD *)(v3 + 64));
  return result;
}

//----- (1004E090) --------------------------------------------------------
int __usercall sub_1004E090@<eax>(int a1@<edi>, int a2, size_t a3)
{
  unsigned int v3; // eax@3
  int result; // eax@5
  char v5; // [sp+8h] [bp-18h]@3

  if ( *(_DWORD *)(a1 + 156) != -1 )
    sub_1004DFF0(a1, 0, 0);
  sub_1004DE70(a1 + 64, (int)&v5);
  v3 = 0;
  do
    *(_DWORD *)(a1 + 4 * v3++) ^= 0x6A6A6A6Au;
  while ( v3 < 0x10 );
  sub_1004C710(a1 + 64);
  sub_1004DF70(0x40u, (char *)a1, (_DWORD *)(a1 + 64));
  sub_1004DF70(0x14u, &v5, (_DWORD *)(a1 + 64));
  result = sub_1004DE70(a1 + 64, (int)&v5);
  if ( a3 )
    result = (int)memcpy((void *)a2, &v5, a3);
  return result;
}

//----- (1004E150) --------------------------------------------------------
int __usercall sub_1004E150@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3)
{
  int v3; // eax@1
  int result; // eax@2

  v3 = *(_DWORD *)(a2 + 156);
  if ( v3 + a1 <= 0x40 )
  {
    memcpy((void *)(a2 + v3), a3, a1);
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  else
  {
    sub_1004C710(a2 + 64);
    sub_1004DF70(*(_DWORD *)(a2 + 156), (char *)a2, (_DWORD *)(a2 + 64));
    sub_1004DF70(a1, (char *)a3, (_DWORD *)(a2 + 64));
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  return result;
}

//----- (1004E1B0) --------------------------------------------------------
int __usercall sub_1004E1B0@<eax>(char *a1@<edi>)
{
  unsigned int v1; // ebp@1
  signed int v2; // eax@2
  int v3; // edx@4
  int v4; // ecx@4
  int v5; // edx@4
  unsigned int v6; // esi@4
  size_t v7; // eax@4
  int v8; // ebx@6
  int v9; // edx@8
  int result; // eax@8
  int v11; // ecx@8
  int v12; // edx@8
  char v13; // [sp+Ch] [bp-5Ch]@8
  int v14; // [sp+14h] [bp-54h]@4
  int v15; // [sp+18h] [bp-50h]@4
  int v16; // [sp+1Ch] [bp-4Ch]@4
  int v17; // [sp+20h] [bp-48h]@4
  int v18; // [sp+24h] [bp-44h]@4
  char v19[64]; // [sp+28h] [bp-40h]@6

  v1 = 0;
  do
  {
    v2 = v1;
    if ( !v1 )
      v2 = 260;
    v3 = *(_DWORD *)&a1[v2 - 16];
    v14 = *(_DWORD *)&a1[v2 - 20];
    v4 = *(_DWORD *)&a1[v2 - 12];
    v15 = v3;
    v5 = *(_DWORD *)&a1[v2 - 8];
    v6 = 260 - v1;
    v18 = *(_DWORD *)&a1[v2 - 4];
    v16 = v4;
    v17 = v5;
    v7 = 64;
    if ( 260 - v1 <= 0x40 )
      v7 = 260 - v1;
    v8 = (int)&a1[v1];
    memcpy(v19, &a1[v1], v7);
    if ( v6 < 0x40 )
      memcpy(&v19[v6], a1, 64 - v6);
    sub_1004C750((int)&v13);
    v9 = v15;
    result = v16;
    *(_DWORD *)v8 = v14;
    v11 = v17;
    *(_DWORD *)(v8 + 4) = v9;
    v12 = v18;
    *(_DWORD *)(v8 + 8) = result;
    v1 += 20;
    *(_DWORD *)(v8 + 12) = v11;
    *(_DWORD *)(v8 + 16) = v12;
  }
  while ( v1 < 0x104 );
  return result;
}
// 1004E1B0: using guessed type char var_40[64];

//----- (1004E270) --------------------------------------------------------
int __usercall sub_1004E270@<eax>(int a1@<ebx>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // eax@3
  char v3; // cl@4
  char v4; // dl@4
  char v5; // cl@4
  char v6; // dl@4
  char *v8; // [sp+Ch] [bp-4h]@1

  v8 = (char *)(a1 + 260);
  v1 = 0;
  qmemcpy((void *)(a1 + 260), (const void *)a1, 0x104u);
  do
    v1 += (*(int (__cdecl **)(unsigned int, unsigned int))(a1 + 524))(a1 + v1, 260 - v1);
  while ( v1 < 0x104 );
  v2 = 0;
  do
  {
    v3 = *(_BYTE *)(v2 + a1 + 261);
    *(_BYTE *)(v2 + a1) ^= ~v8[v2];
    v4 = *(_BYTE *)(v2 + a1 + 262);
    *(_BYTE *)(v2 + a1 + 1) ^= ~v3;
    v5 = *(_BYTE *)(v2 + a1 + 263);
    *(_BYTE *)(v2 + a1 + 2) ^= ~v4;
    v6 = *(_BYTE *)(v2 + a1 + 264);
    *(_BYTE *)(v2 + a1 + 3) ^= ~v5;
    *(_BYTE *)(v2 + a1 + 4) ^= ~v6;
    v2 += 5;
  }
  while ( v2 < 0x104 );
  sub_1004E1B0((char *)a1);
  return sub_1004E1B0(v8);
}

//----- (1004E330) --------------------------------------------------------
char __cdecl sub_1004E330(char *a1, size_t a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_1004DFF0(a3 + 296, a2, a1);
    sub_1004B8B0(a3, (int)a1, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004E380) --------------------------------------------------------
char __cdecl sub_1004E380(char *a1, unsigned int a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_1004B8B0(a3, (int)a1, a2);
    sub_1004DFF0(a3 + 296, a2, a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004E3D0) --------------------------------------------------------
bool __cdecl sub_1004E3D0(int a1, int a2)
{
  if ( a2 )
    sub_1004E090(a2 + 296, a1, 0xAu);
  return a2 != 0;
}

//----- (1004E400) --------------------------------------------------------
int __usercall sub_1004E400@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7)
{
  void *v7; // esi@1
  char *v8; // ebx@1
  int result; // eax@1
  unsigned int v10; // edx@1
  unsigned int v11; // ebx@2
  size_t v12; // edx@3
  char v13; // al@6
  char v14; // al@6
  bool v15; // zf@7
  unsigned int v16; // eax@9
  unsigned int v17; // ecx@9
  int *v18; // [sp+10h] [bp-228h]@2
  unsigned int v19; // [sp+14h] [bp-224h]@2
  int v20; // [sp+18h] [bp-220h]@4
  signed int v21; // [sp+1Ch] [bp-21Ch]@2
  unsigned int v22; // [sp+20h] [bp-218h]@1
  char v23; // [sp+28h] [bp-210h]@3
  char v24; // [sp+C8h] [bp-170h]@1
  char v25; // [sp+168h] [bp-D0h]@1
  int v26; // [sp+20Ch] [bp-2Ch]@2
  int v27; // [sp+210h] [bp-28h]@3
  int v28; // [sp+214h] [bp-24h]@3
  int v29; // [sp+218h] [bp-20h]@3
  int v30; // [sp+21Ch] [bp-1Ch]@3
  int v31; // [sp+220h] [bp-18h]@3
  char v32[16]; // [sp+224h] [bp-14h]@6

  v7 = a2;
  v8 = a1;
  sub_1004C690(&v24);
  sub_1004E150(a3, (int)&v24, v7);
  qmemcpy(&v25, &v24, 0xA0u);
  sub_1004DFF0((int)&v25, a4, v8);
  result = -858993459 * (a7 - 1);
  v10 = (a7 - 1) / 0x14;
  v22 = v10 + 1;
  if ( v10 != -1 )
  {
    v11 = 1;
    v19 = 0;
    v21 = 1;
    v18 = &v26;
    do
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      qmemcpy(&v23, &v25, 0xA0u);
      LOBYTE(v31) = BYTE3(v11);
      BYTE2(v31) = BYTE1(v11);
      BYTE1(v31) = v11 >> 16;
      BYTE3(v31) = v11;
      v12 = 4;
      if ( a5 )
      {
        v20 = a5;
        do
        {
          sub_1004DFF0((int)&v23, v12, (char *)&v31);
          sub_1004E090((int)&v23, (int)&v31, 0x14u);
          v12 = 0;
          do
          {
            *((_BYTE *)&v26 + v12) ^= *((_BYTE *)&v31 + v12);
            v13 = *((_BYTE *)&v31 + v12 + 2);
            *((_BYTE *)&v26 + v12 + 1) ^= *((_BYTE *)&v31 + v12 + 1);
            *((_BYTE *)&v26 + v12 + 2) ^= v13;
            v14 = v32[v12];
            *((_BYTE *)&v26 + v12 + 3) ^= *((_BYTE *)&v31 + v12 + 3);
            *((_BYTE *)&v27 + v12) ^= v14;
            v12 += 5;
          }
          while ( v12 < 0x14 );
          v15 = v20-- == 1;
          qmemcpy(&v23, &v24, 0xA0u);
        }
        while ( !v15 );
        v11 = v21;
      }
      v16 = v19;
      v17 = 0;
      do
      {
        if ( v16 >= a7 )
          break;
        *(_BYTE *)(v16 + a6) = *((_BYTE *)v18 + v16);
        ++v17;
        ++v16;
      }
      while ( v17 < 0x14 );
      v19 += 20;
      v18 -= 5;
      result = ++v11 - 1;
      v21 = v11;
    }
    while ( v11 - 1 < v22 );
  }
  return result;
}
// 1004E400: using guessed type char var_14[16];

//----- (1004E610) --------------------------------------------------------
int __usercall sub_1004E610@<eax>(void *a1@<eax>, int a2)
{
  int v2; // ebx@1
  signed int v3; // esi@1

  v2 = (int)a1;
  memset(a1, 0, 0x210u);
  *(_DWORD *)(v2 + 524) = a2;
  sub_1004E270(v2);
  v3 = 20;
  do
  {
    sub_1004E1B0((char *)v2);
    --v3;
  }
  while ( v3 );
  return sub_1004E270(v2);
}

//----- (1004E660) --------------------------------------------------------
char *__cdecl sub_1004E660(int a1, int a2)
{
  void *v2; // ecx@0
  char *result; // eax@1
  unsigned int v4; // ebp@1
  int v5; // edi@1
  char *v6; // ebx@1
  size_t v7; // esi@4

  result = (char *)a2;
  v4 = a1;
  v5 = *(_DWORD *)(a2 + 520);
  v6 = (char *)v2;
  if ( a1 )
  {
    while ( 1 )
    {
      v7 = 260 - v5;
      if ( v4 < 260 - v5 )
        v7 = v4;
      result = (char *)memcpy(v6, &result[v5 + 260], v7);
      v6 += v7;
      v5 += v7;
      v4 -= v7;
      if ( v5 == 260 )
      {
        result = (char *)sub_1004E270(a2);
        v5 = 0;
      }
      if ( !v4 )
        break;
      result = (char *)a2;
    }
    *(_DWORD *)(a2 + 520) = v5;
  }
  else
  {
    *(_DWORD *)(a2 + 520) = v5;
  }
  return result;
}

//----- (1004E6F0) --------------------------------------------------------
signed int __cdecl sub_1004E6F0(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6)
{
  signed int result; // eax@2
  int v7; // ebx@6
  char v8; // [sp+Ch] [bp-48h]@6
  char v9[8]; // [sp+14h] [bp-40h]@6
  __int16 v10[26]; // [sp+1Ch] [bp-38h]@6

  if ( a3 <= 0x80 )
  {
    if ( (unsigned __int8)(a1 - 1) > 2u )
    {
      result = -101;
    }
    else if ( a6 )
    {
      *(_BYTE *)(a6 + 464) = a1;
      v7 = a1 & 3;
      *(_DWORD *)(a6 + 460) = a3;
      sub_1004E400(a4, a2, a3, 4 * v7 + 4, 1000, (int)&v8, 16 * v7 + 18);
      *(_DWORD *)(a6 + 456) = 16;
      *(_DWORD *)a6 = 0;
      *(_DWORD *)(a6 + 4) = 0;
      *(_DWORD *)(a6 + 8) = 0;
      *(_DWORD *)(a6 + 12) = 0;
      sub_1004B910(a6 + 32, (int)&v8, 8 * v7 + 8);
      sub_1004C690((void *)(a6 + 296));
      sub_1004E150(8 * v7 + 8, a6 + 296, &v9[8 * v7]);
      *a5 = v10[8 * v7];
      result = 0;
    }
    else
    {
      result = -102;
    }
  }
  else
  {
    result = -100;
  }
  return result;
}
// 1004E6F0: using guessed type char var_40[8];
// 1004E6F0: using guessed type __int16 var_38[26];

//----- (1004E820) --------------------------------------------------------
bool __cdecl sub_1004E820(void *a1, int a2)
{
  bool v2; // bl@3
  int v4; // [sp+Ch] [bp-214h]@5

  v2 = a1 && a2;
  sub_1004E610(&v4, (int)sub_1004C6B0);
  if ( v2 )
    sub_1004E660(a2, (int)&v4);
  return v2;
}

//----- (1004E8A0) --------------------------------------------------------
BOOL __usercall sub_1004E8A0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // ecx@3
  int v4; // ecx@4

  *(_WORD *)(*(_DWORD *)(a1 + 5712) + 2 * *(_DWORD *)(a1 + 5728)) = a3;
  *(_BYTE *)(*(_DWORD *)(a1 + 5716) + (*(_DWORD *)(a1 + 5728))++) = a2;
  if ( a3 )
  {
    ++*(_DWORD *)(a1 + 2920);
    ++*(_WORD *)(a1 + 4 * (unsigned __int8)byte_100D6B50[a2] + 3964);
    v3 = a3 - 1;
    if ( v3 >= 0x100 )
      v4 = (unsigned __int8)byte_100D6A50[v3 >> 7];
    else
      v4 = (unsigned __int8)byte_100D6950[v3];
    ++*(_WORD *)(a1 + 4 * v4 + 5228);
  }
  else
  {
    ++*(_WORD *)(a1 + 4 * a2 + 2936);
  }
  return *(_DWORD *)(a1 + 5728) == *(_DWORD *)(a1 + 5724) - 1;
}

//----- (1004E940) --------------------------------------------------------
int __usercall sub_1004E940@<eax>(int result@<eax>)
{
  signed int v1; // ecx@1
  __int16 v2; // cx@4

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)((*(_DWORD *)(result + 5812))++ + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
    *(_DWORD *)(result + 2932) = 0;
    *(_WORD *)(result + 2924) = 0;
  }
  else if ( v1 >= 8 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) -= 8;
    *(_WORD *)(result + 2924) = v2;
  }
  return result;
}

//----- (1004E9D0) --------------------------------------------------------
unsigned int __fastcall sub_1004E9D0(unsigned int a1, int a2)
{
  unsigned int v2; // eax@1
  int v3; // esi@2

  v2 = 0;
  do
  {
    v3 = a1 & 1;
    --a2;
    a1 >>= 1;
    v2 = 2 * (v3 | v2);
  }
  while ( a2 > 0 );
  return v2 >> 1;
}

//----- (1004E9F0) --------------------------------------------------------
int __usercall sub_1004E9F0@<eax>(int result@<eax>)
{
  signed int v1; // edx@1
  char v2; // bl@2
  int v3; // edx@2

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 <= 8 )
  {
    if ( v1 > 0 )
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    v3 = *(_DWORD *)(result + 5800);
    *(_BYTE *)(++*(_DWORD *)(result + 5812) + v3) = v2;
    ++*(_DWORD *)(result + 5812);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  return result;
}

//----- (1004EA80) --------------------------------------------------------
int __usercall sub_1004EA80@<eax>(int result@<eax>, int a2, int a3)
{
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // ebp@2
  int v6; // esi@2
  int v7; // ecx@2
  int v8; // edi@3
  int v9; // esi@4
  int v10; // edx@4
  int v11; // ecx@4
  int v12; // edx@4
  int v13; // ecx@4
  int v14; // edx@6
  int v15; // edi@7
  int v16; // edx@7
  int v17; // ecx@7
  int v18; // edx@7
  int v19; // edi@9
  int v20; // esi@10
  int v21; // ecx@10
  int v22; // edx@11
  int v23; // ecx@11
  int v24; // edx@11
  int v25; // ecx@11
  unsigned int v26; // ebp@14
  int v27; // edi@15
  int v28; // edx@17
  int v29; // ecx@17
  unsigned __int16 v30; // si@18
  int v31; // edx@18
  int v32; // ecx@18
  int v33; // edx@18
  int v34; // esi@20
  int v35; // ecx@21
  int v36; // ebp@21
  int v37; // edx@22
  int v38; // ecx@22
  int v39; // edx@22
  int v40; // edi@26
  int v41; // ecx@26
  unsigned __int16 v42; // si@27
  int v43; // edx@27
  int v44; // ecx@27
  int v45; // edx@27
  int v46; // [sp+10h] [bp-Ch]@6
  int v47; // [sp+14h] [bp-8h]@6
  int v48; // [sp+14h] [bp-8h]@17
  unsigned int v49; // [sp+18h] [bp-4h]@2

  v3 = a2;
  v4 = 0;
  if ( *(_DWORD *)(result + 5728) )
  {
    do
    {
      v5 = *(_WORD *)(*(_DWORD *)(result + 5712) + 2 * v4);
      v6 = *(_BYTE *)(v4 + *(_DWORD *)(result + 5716));
      v49 = v4 + 1;
      v7 = *(_DWORD *)(result + 2932);
      if ( v5 )
      {
        v14 = (unsigned __int8)byte_100D6B50[v6];
        v46 = *(_WORD *)(v3 + 4 * v14 + 1030);
        v47 = (unsigned __int8)byte_100D6B50[v6];
        if ( v7 <= 16 - v46 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a2 + 4 * v14 + 1028) << v7;
          *(_DWORD *)(result + 2932) = v46 + v7;
        }
        else
        {
          v15 = *(_WORD *)(a2 + 4 * v14 + 1028);
          v16 = v15 << v7;
          v17 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v16;
          *(_BYTE *)(v17 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v18 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          LOWORD(v15) = (unsigned __int16)v15 >> (16 - v18);
          *(_DWORD *)(result + 2932) = v18 + v46 - 16;
          v14 = v47;
          *(_WORD *)(result + 2924) = v15;
        }
        v19 = dword_100D6358[v14];
        v3 = a2;
        if ( v19 )
        {
          v20 = v6 - dword_100D6C50[v14];
          v21 = *(_DWORD *)(result + 2932);
          if ( v21 <= 16 - v19 )
          {
            *(_WORD *)(result + 2924) |= v20 << v21;
            v25 = v19 + v21;
          }
          else
          {
            v22 = v20 << v21;
            v23 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v22;
            *(_BYTE *)(v23 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v24 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v3 = a2;
            v25 = v24 + v19 - 16;
            *(_WORD *)(result + 2924) = (unsigned __int16)v20 >> (16 - v24);
          }
          *(_DWORD *)(result + 2932) = v25;
        }
        v26 = v5 - 1;
        if ( v26 >= 0x100 )
          v27 = (unsigned __int8)byte_100D6A50[v26 >> 7];
        else
          v27 = (unsigned __int8)byte_100D6950[v26];
        v28 = *(_WORD *)(a3 + 4 * v27 + 2);
        v29 = *(_DWORD *)(result + 2932);
        v48 = *(_WORD *)(a3 + 4 * v27 + 2);
        if ( v29 <= 16 - v28 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a3 + 4 * v27) << v29;
          *(_DWORD *)(result + 2932) = v28 + v29;
        }
        else
        {
          v30 = *(_WORD *)(a3 + 4 * v27);
          v31 = *(_WORD *)(a3 + 4 * v27) << v29;
          v32 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v31;
          *(_BYTE *)(v32 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v33 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v3 = a2;
          *(_DWORD *)(result + 2932) = v33 + v48 - 16;
          *(_WORD *)(result + 2924) = v30 >> (16 - v33);
        }
        v34 = dword_100D63E0[v27];
        if ( !v34 )
          goto LABEL_25;
        v35 = *(_DWORD *)(result + 2932);
        v36 = v26 - dword_100D6CC8[v27];
        if ( v35 <= 16 - v34 )
        {
          *(_WORD *)(result + 2924) |= v36 << v35;
          v13 = v34 + v35;
        }
        else
        {
          v37 = v36 << v35;
          v38 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v37;
          *(_BYTE *)(v38 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v39 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v39 + v34 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v36 >> (16 - v39);
        }
      }
      else
      {
        v8 = *(_WORD *)(v3 + 4 * v6 + 2);
        if ( v7 <= 16 - v8 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 4 * v6) << v7;
          v13 = v8 + v7;
        }
        else
        {
          v9 = *(_WORD *)(v3 + 4 * v6);
          v10 = v9 << v7;
          v11 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v10;
          *(_BYTE *)(v11 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v12 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v12 + v8 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v9 >> (16 - v12);
        }
      }
      *(_DWORD *)(result + 2932) = v13;
LABEL_25:
      v4 = v49;
    }
    while ( v49 < *(_DWORD *)(result + 5728) );
  }
  v40 = *(_WORD *)(v3 + 1026);
  v41 = *(_DWORD *)(result + 2932);
  if ( v41 <= 16 - v40 )
  {
    *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 1024) << v41;
    *(_DWORD *)(result + 2932) = v40 + v41;
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  else
  {
    v42 = *(_WORD *)(v3 + 1024);
    v43 = *(_WORD *)(v3 + 1024) << v41;
    v44 = *(_DWORD *)(result + 5800);
    *(_WORD *)(result + 2924) |= v43;
    *(_BYTE *)(v44 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2925);
    v45 = *(_DWORD *)(result + 2932);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) = v45 + v40 - 16;
    *(_WORD *)(result + 2924) = v42 >> (16 - v45);
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  return result;
}
// 100D6358: using guessed type int dword_100D6358[];
// 100D63E0: using guessed type int dword_100D63E0[];
// 100D6C50: using guessed type int dword_100D6C50[];
// 100D6CC8: using guessed type int dword_100D6CC8[];

//----- (1004EF00) --------------------------------------------------------
int __usercall sub_1004EF00@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  _BYTE *v4; // edi@1
  int result; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // edx@1
  int i; // esi@1

  v3 = a3;
  v4 = a2;
  result = sub_1004E9F0(a1);
  v6 = *(_DWORD *)(result + 5812);
  v7 = *(_DWORD *)(result + 5800);
  *(_DWORD *)(result + 2928) = 8;
  *(_BYTE *)(v6 + v7) = v3;
  v8 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v8) = BYTE1(v3);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~(_BYTE)v3;
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~BYTE1(v3);
  for ( i = ++*(_DWORD *)(result + 5812); v3; ++v4 )
  {
    *(_BYTE *)(i + *(_DWORD *)(result + 5800)) = *v4;
    i = ++*(_DWORD *)(result + 5812);
    --v3;
  }
  return result;
}

//----- (1004EFB0) --------------------------------------------------------
void *__usercall sub_1004EFB0@<eax>(int a1@<edi>)
{
  void *result; // eax@1
  int v2; // ebx@1
  size_t v3; // esi@1
  bool v4; // zf@4

  result = *(void **)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(v2 + 5812);
  if ( v3 > (unsigned int)result )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    result = memcpy(*(void **)(a1 + 12), *(const void **)(v2 + 5808), v3);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v2 + 5808) += v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) -= v3;
    v4 = *(_DWORD *)(v2 + 5812) == v3;
    *(_DWORD *)(v2 + 5812) -= v3;
    if ( v4 )
      *(_DWORD *)(v2 + 5808) = *(_DWORD *)(v2 + 5800);
  }
  return result;
}

//----- (1004F010) --------------------------------------------------------
int __usercall sub_1004F010@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx@1
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@3
  int v9; // ecx@3
  int v10; // esi@6
  int v11; // ebx@8
  int i; // ecx@13
  int v13; // edx@17
  int v14; // ebx@18
  int v15; // ecx@19
  int v16; // esi@20
  int v17; // [sp+Ch] [bp-20h]@1
  int *v18; // [sp+10h] [bp-1Ch]@2
  int v19; // [sp+10h] [bp-1Ch]@17
  signed int v20; // [sp+14h] [bp-18h]@2
  int v21; // [sp+18h] [bp-14h]@1
  int v22; // [sp+1Ch] [bp-10h]@2
  int v23; // [sp+20h] [bp-Ch]@1
  int v24; // [sp+24h] [bp-8h]@1
  int v25; // [sp+28h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)a2;
  v24 = *(_DWORD *)(v2 + 8);
  v4 = *(_DWORD *)(v2 + 16);
  v21 = *(_DWORD *)v2;
  v25 = *(_DWORD *)(v2 + 4);
  v5 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  v23 = v5;
  v6 = 0;
  *(_WORD *)(v3 + 4 * *(_DWORD *)(result + 4 * *(_DWORD *)(result + 2328) + 32) + 2) = 0;
  v7 = *(_DWORD *)(result + 2328) + 1;
  v17 = 0;
  if ( v7 < 573 )
  {
    v18 = (int *)(result + 4 * v7 + 32);
    v22 = 573 - v7;
    v20 = 573;
    do
    {
      v8 = *v18;
      v9 = *(_WORD *)(v3 + 4 * *(_WORD *)(v3 + 4 * *v18 + 2) + 2) + 1;
      if ( v9 > v4 )
      {
        ++v6;
        v9 = v4;
        v17 = v6;
      }
      *(_WORD *)(v3 + 4 * v8 + 2) = v9;
      if ( v8 <= v23 )
      {
        ++*(_WORD *)(result + 2 * v9);
        v10 = 0;
        if ( v8 >= v24 )
          v10 = *(_DWORD *)(v25 + 4 * (v8 - v24));
        v11 = *(_WORD *)(v3 + 4 * v8);
        *(_DWORD *)(result + 2912) += v11 * (v10 + v9);
        if ( v21 )
          *(_DWORD *)(result + 2916) += v11 * (v10 + *(_WORD *)(v21 + 4 * v8 + 2));
        v6 = v17;
      }
      ++v18;
      --v22;
    }
    while ( v22 );
    if ( v6 )
    {
      do
      {
        for ( i = v4 - 1; !*(_WORD *)(result + 2 * i); --i )
          ;
        --*(_WORD *)(result + 2 * i);
        *(_WORD *)(result + 2 * i + 2) += 2;
        --*(_WORD *)(result + 2 * v4);
        v6 -= 2;
      }
      while ( v6 > 0 );
      for ( ; v4; --v4 )
      {
        v13 = *(_WORD *)(result + 2 * v4);
        v19 = *(_WORD *)(result + 2 * v4);
        if ( *(_WORD *)(result + 2 * v4) )
        {
          v14 = result + 4 * v20 + 32;
          do
          {
            v15 = *(_DWORD *)(v14 - 4);
            --v20;
            v14 -= 4;
            if ( v15 <= v23 )
            {
              v16 = *(_WORD *)(v3 + 4 * v15 + 2);
              if ( v16 != v4 )
              {
                *(_DWORD *)(result + 2912) += *(_WORD *)(v3 + 4 * v15) * (v4 - v16);
                *(_WORD *)(v3 + 4 * v15 + 2) = v4;
              }
              v13 = --v19;
            }
          }
          while ( v13 );
        }
      }
    }
  }
  return result;
}

//----- (1004F1E0) --------------------------------------------------------
signed int __usercall sub_1004F1E0@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // cx@1
  signed int result; // eax@1
  int v5; // edx@1
  int i; // esi@3
  int v7; // edx@4
  unsigned int v8; // ecx@5
  __int16 v9; // [sp+4h] [bp-24h]@2
  char v10; // [sp+6h] [bp-22h]@1

  v3 = 0;
  result = 1;
  v5 = a1 - (_DWORD)&v10;
  do
  {
    v3 = 2 * (v3 + *(__int16 *)((char *)&v9 + 2 * result + v5));
    *(&v9 + result++) = v3;
  }
  while ( result <= 15 );
  for ( i = 0; i <= a2; ++i )
  {
    v7 = *(_WORD *)(a3 + 4 * i + 2);
    if ( *(_WORD *)(a3 + 4 * i + 2) )
    {
      v8 = (unsigned __int16)(*(&v9 + v7))++;
      result = sub_1004E9D0(v8, v7);
      *(_WORD *)(a3 + 4 * i) = result;
    }
  }
  return result;
}

//----- (1004F260) --------------------------------------------------------
_WORD *__fastcall sub_1004F260(int a1, int a2)
{
  _WORD *v2; // eax@1
  signed int v3; // ecx@1
  _WORD *v4; // eax@3
  signed int v5; // ecx@3
  _WORD *result; // eax@5
  signed int v7; // ecx@5

  v2 = (_WORD *)(a2 + 2936);
  v3 = 286;
  do
  {
    *v2 = 0;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  v4 = (_WORD *)(a2 + 5228);
  v5 = 30;
  do
  {
    *v4 = 0;
    v4 += 2;
    --v5;
  }
  while ( v5 );
  result = (_WORD *)(a2 + 5472);
  v7 = 19;
  do
  {
    *result = 0;
    result += 2;
    --v7;
  }
  while ( v7 );
  *(_DWORD *)(a2 + 2916) = 0;
  *(_DWORD *)(a2 + 2912) = 0;
  *(_DWORD *)(a2 + 2920) = 0;
  *(_DWORD *)(a2 + 5728) = 0;
  *(_WORD *)(a2 + 3960) = 1;
  return result;
}

//----- (1004F2D0) --------------------------------------------------------
unsigned int __usercall sub_1004F2D0@<eax>(int a1@<esi>, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // edi@1
  int v6; // ecx@4
  unsigned int v7; // ebx@4
  int v8; // edx@8
  char v9; // al@11
  int v10; // edx@11
  unsigned int v11; // ecx@12
  _BYTE *v12; // edx@12
  char v13; // al@13
  _BYTE *v14; // edx@13
  char v15; // al@14
  _BYTE *v16; // edx@14
  char v17; // al@15
  _BYTE *v18; // edx@15
  char v19; // al@16
  _BYTE *v20; // edx@16
  char v21; // al@17
  _BYTE *v22; // edx@17
  char v23; // al@18
  _BYTE *v24; // edx@18
  char v25; // al@19
  _BYTE *v26; // edx@19
  char v27; // al@20
  int v28; // edx@22
  unsigned int result; // eax@27
  char v30; // [sp+Fh] [bp-11h]@4
  unsigned int v31; // [sp+10h] [bp-10h]@1
  int v32; // [sp+14h] [bp-Ch]@4
  unsigned int v33; // [sp+18h] [bp-8h]@2
  char v34; // [sp+24h] [bp+4h]@4

  v2 = *(_DWORD *)(a1 + 5748);
  v3 = *(_DWORD *)(a1 + 5680);
  v4 = a2;
  v31 = *(_DWORD *)(a1 + 5696);
  v5 = *(_DWORD *)(a1 + 5692);
  if ( v3 <= v2 - 262 )
    v33 = 0;
  else
    v33 = v3 - v2 + 262;
  v6 = *(_DWORD *)(a1 + 5740) + v3;
  v34 = *(_BYTE *)(v6 + v5 - 1);
  v32 = *(_DWORD *)(a1 + 5708);
  v7 = v6 + 258;
  v30 = *(_BYTE *)(v6 + v5);
  if ( v5 >= *(_DWORD *)(a1 + 5704) )
    v31 >>= 2;
  if ( *(_DWORD *)(a1 + 5708) > *(_DWORD *)(a1 + 5688) )
    v32 = *(_DWORD *)(a1 + 5688);
  do
  {
    v8 = v4 + *(_DWORD *)(a1 + 5740);
    if ( *(_BYTE *)(v8 + v5) == v30 && *(_BYTE *)(v8 + v5 - 1) == v34 && *(_BYTE *)v8 == *(_BYTE *)v6 )
    {
      v9 = *(_BYTE *)(v8 + 1);
      v10 = v8 + 1;
      if ( v9 == *(_BYTE *)(v6 + 1) )
      {
        v11 = v6 + 2;
        v12 = (_BYTE *)(v10 + 1);
        do
        {
          v13 = *(_BYTE *)(v11++ + 1);
          v14 = v12 + 1;
          if ( v13 != *v14 )
            break;
          v15 = *(_BYTE *)(v11++ + 1);
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *(_BYTE *)(v11++ + 1);
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *(_BYTE *)(v11++ + 1);
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *(_BYTE *)(v11++ + 1);
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *(_BYTE *)(v11++ + 1);
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *(_BYTE *)(v11++ + 1);
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *(_BYTE *)(v11++ + 1);
          v12 = v26 + 1;
          if ( v27 != *v12 )
            break;
        }
        while ( v11 < v7 );
        v28 = v11 - v7 + 258;
        v6 = v7 - 258;
        if ( v28 > (signed int)v5 )
        {
          *(_DWORD *)(a1 + 5684) = v4;
          v5 = v28;
          if ( v28 >= v32 )
            break;
          v34 = *(_BYTE *)(v28 + v6 - 1);
          v30 = *(_BYTE *)(v28 + v6);
        }
      }
    }
    v4 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & *(_DWORD *)(a1 + 5756)));
    if ( v4 <= v33 )
      break;
    --v31;
  }
  while ( v31 );
  result = *(_DWORD *)(a1 + 5688);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (1004F480) --------------------------------------------------------
unsigned int __usercall sub_1004F480@<eax>(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  unsigned int v6; // edi@1
  unsigned int v7; // eax@3
  _BYTE *v8; // ecx@3
  char v9; // dl@4
  _BYTE *v10; // ecx@4
  char v11; // dl@5
  _BYTE *v12; // ecx@5
  char v13; // dl@6
  _BYTE *v14; // ecx@6
  char v15; // dl@7
  _BYTE *v16; // ecx@7
  char v17; // dl@8
  _BYTE *v18; // ecx@8
  char v19; // dl@9
  _BYTE *v20; // ecx@9
  char v21; // dl@10
  _BYTE *v22; // ecx@10
  char v23; // dl@11
  unsigned int v24; // ecx@13
  unsigned int result; // eax@13

  v2 = *(_DWORD *)(a1 + 5740);
  v3 = *(_BYTE *)(v2 + a2);
  v4 = v2 + *(_DWORD *)(a1 + 5680);
  v5 = a2 + v2;
  v6 = v4 + 258;
  if ( v3 != *(_BYTE *)v4 || *(_BYTE *)(v5 + 1) != *(_BYTE *)(v4 + 1) )
  {
    result = 2;
  }
  else
  {
    v7 = v4 + 2;
    v8 = (_BYTE *)(v5 + 2);
    do
    {
      v9 = *(_BYTE *)(v7++ + 1);
      v10 = v8 + 1;
      if ( v9 != *v10 )
        break;
      v11 = *(_BYTE *)(v7++ + 1);
      v12 = v10 + 1;
      if ( v11 != *v12 )
        break;
      v13 = *(_BYTE *)(v7++ + 1);
      v14 = v12 + 1;
      if ( v13 != *v14 )
        break;
      v15 = *(_BYTE *)(v7++ + 1);
      v16 = v14 + 1;
      if ( v15 != *v16 )
        break;
      v17 = *(_BYTE *)(v7++ + 1);
      v18 = v16 + 1;
      if ( v17 != *v18 )
        break;
      v19 = *(_BYTE *)(v7++ + 1);
      v20 = v18 + 1;
      if ( v19 != *v20 )
        break;
      v21 = *(_BYTE *)(v7++ + 1);
      v22 = v20 + 1;
      if ( v21 != *v22 )
        break;
      v23 = *(_BYTE *)(v7++ + 1);
      v8 = v22 + 1;
      if ( v23 != *v8 )
        break;
    }
    while ( v7 < v6 );
    v24 = *(_DWORD *)(a1 + 5688);
    result = v7 - v6 + 258;
    *(_DWORD *)(a1 + 5684) = a2;
    if ( result > v24 )
      result = v24;
  }
  return result;
}

//----- (1004F550) --------------------------------------------------------
int __usercall sub_1004F550@<eax>(int result@<eax>, int a2@<edi>, int a3)
{
  int v3; // edx@1
  int v4; // ebp@1
  int v5; // ecx@1
  bool v6; // sf@1
  unsigned __int8 v7; // of@1
  int v8; // esi@3
  int v9; // ebp@3
  unsigned __int16 v10; // dx@3
  unsigned __int16 v11; // bx@3
  int v12; // esi@8
  unsigned __int16 v13; // dx@8
  unsigned __int16 v14; // bx@8
  int v15; // edx@11
  int v16; // [sp+8h] [bp-4h]@1

  v3 = *(_DWORD *)(result + 2324);
  v4 = *(_DWORD *)(result + 4 * a3 + 32);
  v5 = 2 * a3;
  v7 = __OFSUB__(2 * a3, v3);
  v6 = 2 * a3 - v3 < 0;
  v16 = *(_DWORD *)(result + 4 * a3 + 32);
  if ( 2 * a3 > v3 )
  {
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  else
  {
    while ( 1 )
    {
      if ( v6 ^ v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v5 + 36);
        v9 = *(_DWORD *)(result + 4 * v5 + 32);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 2332) <= *(_BYTE *)(result + v9 + 2332) )
          ++v5;
        v4 = v16;
      }
      v12 = *(_DWORD *)(result + 4 * v5 + 32);
      v13 = *(_WORD *)(a2 + 4 * v4);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 32) = v4;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v4 + 2332) <= *(_BYTE *)(v12 + result + 2332) )
        break;
      *(_DWORD *)(result + 4 * a3 + 32) = v12;
      v15 = *(_DWORD *)(result + 2324);
      a3 = v5;
      v5 *= 2;
      v7 = __OFSUB__(v5, v15);
      v6 = v5 - v15 < 0;
      if ( v5 > v15 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  return result;
}

//----- (1004F600) --------------------------------------------------------
int __usercall sub_1004F600@<eax>(int result@<eax>, __int16 a2@<cx>)
{
  int v2; // edi@1

  *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = HIBYTE(a2);
  v2 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v2) = a2;
  ++*(_DWORD *)(result + 5812);
  return result;
}

//----- (1004F640) --------------------------------------------------------
unsigned int __usercall sub_1004F640@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3)
{
  int v3; // ecx@1
  unsigned int v4; // edi@1
  unsigned int result; // eax@4

  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 > a1 )
    v4 = a1;
  if ( v4 )
  {
    *(_DWORD *)(a2 + 4) -= v4;
    if ( *(_DWORD *)(v3 + 5780) == 1 )
      *(_DWORD *)(a2 + 28) = sub_10051410(*(_DWORD *)(a2 + 28), *(_BYTE **)a2, v4);
    memcpy(a3, *(const void **)a2, v4);
    *(_DWORD *)a2 += v4;
    *(_DWORD *)(a2 + 8) += v4;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004F6A0) --------------------------------------------------------
signed int __usercall sub_1004F6A0@<eax>(signed int result@<eax>, int a2@<ecx>, int a3)
{
  signed int v3; // edi@1
  signed int v4; // edx@1
  signed int v5; // ebp@1
  int v6; // ebx@1
  signed int v7; // ecx@1
  signed int v8; // esi@1
  _WORD *v9; // [sp+10h] [bp-8h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v3 = *(_WORD *)(result + 2);
  v4 = 0;
  v5 = -1;
  v6 = a2;
  v7 = 7;
  v8 = 4;
  if ( !*(_WORD *)(result + 2) )
  {
    v7 = 138;
    v8 = 3;
  }
  *(_WORD *)(result + 4 * v6 + 6) = -1;
  if ( v6 >= 0 )
  {
    v10 = v6 + 1;
    v9 = (_WORD *)(result + 6);
    do
    {
      result = v3;
      v3 = *v9;
      if ( ++v4 >= v7 || result != v3 )
      {
        if ( v4 >= v8 )
        {
          if ( result )
          {
            if ( result != v5 )
              ++*(_WORD *)(a3 + 4 * result + 5472);
            ++*(_WORD *)(a3 + 5536);
          }
          else if ( v4 > 10 )
          {
            ++*(_WORD *)(a3 + 5544);
          }
          else
          {
            ++*(_WORD *)(a3 + 5540);
          }
        }
        else
        {
          *(_WORD *)(a3 + 4 * result + 5472) += v4;
        }
        v4 = 0;
        v5 = result;
        if ( v3 )
        {
          if ( result == v3 )
          {
            v7 = 6;
            v8 = 3;
          }
          else
          {
            v7 = 7;
            v8 = 4;
          }
        }
        else
        {
          v7 = 138;
          v8 = 3;
        }
      }
      v9 += 2;
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (1004F780) --------------------------------------------------------
int __usercall sub_1004F780@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  signed int v3; // esi@1
  int v4; // ebx@1
  signed int v5; // ecx@1
  signed int v6; // edi@1
  signed int v7; // edx@5
  int v8; // edi@8
  int v9; // ecx@8
  unsigned __int16 v10; // si@9
  int v11; // edx@9
  int v12; // ecx@9
  int v13; // edx@9
  __int16 v14; // si@9
  int v15; // ecx@9
  int v16; // ecx@15
  unsigned __int16 v17; // si@16
  int v18; // edi@16
  int v19; // ecx@16
  int v20; // ebx@16
  int v21; // ecx@16
  int v22; // ecx@19
  unsigned __int16 v23; // si@20
  int v24; // edi@20
  int v25; // ecx@20
  int v26; // ebx@20
  int v27; // ecx@20
  int v28; // esi@22
  int v29; // edi@23
  int v30; // ecx@23
  int v31; // ebx@23
  int v32; // ecx@24
  int v33; // ecx@25
  unsigned __int16 v34; // si@27
  int v35; // edi@27
  int v36; // ecx@27
  int v37; // ebx@27
  int v38; // ecx@27
  int v39; // esi@29
  int v40; // edi@30
  int v41; // ecx@30
  int v42; // ebx@30
  unsigned __int16 v43; // si@33
  int v44; // edi@33
  int v45; // ecx@33
  int v46; // ebx@33
  int v47; // ecx@33
  int v48; // esi@35
  int v49; // edi@36
  int v50; // ecx@36
  int v51; // ebx@36
  signed int v52; // [sp+10h] [bp-18h]@5
  signed int v53; // [sp+14h] [bp-14h]@1
  _WORD *v54; // [sp+18h] [bp-10h]@4
  signed int v55; // [sp+1Ch] [bp-Ch]@1
  int v56; // [sp+1Ch] [bp-Ch]@15
  int v57; // [sp+1Ch] [bp-Ch]@19
  int v58; // [sp+1Ch] [bp-Ch]@26
  int v59; // [sp+1Ch] [bp-Ch]@32
  int v60; // [sp+20h] [bp-8h]@4
  signed int v61; // [sp+24h] [bp-4h]@5

  v3 = 0;
  v4 = a3;
  v5 = 7;
  v6 = 4;
  v53 = *(_WORD *)(a2 + 2);
  v55 = -1;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( v4 >= 0 )
  {
    v54 = (_WORD *)(a2 + 6);
    v60 = v4 + 1;
    do
    {
      v7 = v53;
      ++v3;
      v61 = v53;
      v53 = *v54;
      v52 = v3;
      if ( v3 < v5 && v7 == *v54 )
        goto LABEL_44;
      if ( v3 < v6 )
      {
        do
        {
          v8 = *(_WORD *)(result + 4 * v7 + 5474);
          v9 = *(_DWORD *)(result + 2932);
          if ( v9 <= 16 - v8 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v15 = v8 + v9;
          }
          else
          {
            v10 = *(_WORD *)(result + 4 * v7 + 5472);
            v11 = *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v12 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v11;
            *(_BYTE *)(v12 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v13 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v14 = v10 >> (16 - v13);
            v15 = v13 + v8 - 16;
            v7 = v61;
            *(_WORD *)(result + 2924) = v14;
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v15;
          v52 = v3;
        }
        while ( v3 );
        goto LABEL_39;
      }
      if ( v7 )
      {
        if ( v7 != v55 )
        {
          v16 = *(_DWORD *)(result + 2932);
          v56 = *(_WORD *)(result + 4 * v7 + 5474);
          if ( v16 <= 16 - v56 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v21 = v56 + v16;
          }
          else
          {
            v17 = *(_WORD *)(result + 4 * v7 + 5472);
            v18 = *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v19 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v18;
            *(_BYTE *)(v19 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v20 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v21 = v20 + v56 - 16;
            *(_WORD *)(result + 2924) = v17 >> (16 - v20);
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v21;
          v52 = v3;
        }
        v22 = *(_DWORD *)(result + 2932);
        v57 = *(_WORD *)(result + 5538);
        if ( v22 <= 16 - v57 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5536) << v22;
          v27 = v57 + v22;
        }
        else
        {
          v23 = *(_WORD *)(result + 5536);
          v24 = *(_WORD *)(result + 5536) << v22;
          v25 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v24;
          *(_BYTE *)(v25 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v26 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v27 = v26 + v57 - 16;
          *(_WORD *)(result + 2924) = v23 >> (16 - v26);
          v3 = v52;
        }
        v28 = v3 - 3;
        *(_DWORD *)(result + 2932) = v27;
        if ( v27 > 14 )
        {
          v29 = v28 << v27;
          v30 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v29;
          *(_BYTE *)(v30 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v31 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          *(_DWORD *)(result + 2932) = v31 - 14;
          *(_WORD *)(result + 2924) = (unsigned __int16)v28 >> (16 - v31);
          goto LABEL_39;
        }
        *(_WORD *)(result + 2924) |= v28 << v27;
        v32 = v27 + 2;
      }
      else
      {
        v33 = *(_DWORD *)(result + 2932);
        if ( v3 > 10 )
        {
          v59 = *(_WORD *)(result + 5546);
          if ( v33 <= 16 - v59 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5544) << v33;
            v47 = v59 + v33;
          }
          else
          {
            v43 = *(_WORD *)(result + 5544);
            v44 = *(_WORD *)(result + 5544) << v33;
            v45 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v44;
            *(_BYTE *)(v45 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v46 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v47 = v46 + v59 - 16;
            *(_WORD *)(result + 2924) = v43 >> (16 - v46);
            v3 = v52;
          }
          v48 = v3 - 11;
          *(_DWORD *)(result + 2932) = v47;
          if ( v47 > 9 )
          {
            v49 = v48 << v47;
            v50 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v49;
            *(_BYTE *)(v50 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v51 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v51 - 9;
            *(_WORD *)(result + 2924) = (unsigned __int16)v48 >> (16 - v51);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v48 << v47;
          v32 = v47 + 7;
        }
        else
        {
          v58 = *(_WORD *)(result + 5542);
          if ( v33 <= 16 - v58 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5540) << v33;
            v38 = v58 + v33;
          }
          else
          {
            v34 = *(_WORD *)(result + 5540);
            v35 = *(_WORD *)(result + 5540) << v33;
            v36 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v35;
            *(_BYTE *)(v36 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v37 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v38 = v37 + v58 - 16;
            *(_WORD *)(result + 2924) = v34 >> (16 - v37);
            v3 = v52;
          }
          v39 = v3 - 3;
          *(_DWORD *)(result + 2932) = v38;
          if ( v38 > 13 )
          {
            v40 = v39 << v38;
            v41 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v40;
            *(_BYTE *)(v41 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v42 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v42 - 13;
            *(_WORD *)(result + 2924) = (unsigned __int16)v39 >> (16 - v42);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v39 << v38;
          v32 = v38 + 3;
        }
      }
      *(_DWORD *)(result + 2932) = v32;
LABEL_39:
      v3 = 0;
      v55 = v7;
      if ( v53 )
      {
        if ( v7 == v53 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v54 += 2;
      --v60;
    }
    while ( v60 );
  }
  return result;
}

//----- (1004FD20) --------------------------------------------------------
int __usercall sub_1004FD20@<eax>(int a1@<eax>)
{
  signed int v1; // ecx@1
  int v2; // edx@2
  signed int v3; // ecx@4
  int v4; // edx@5
  int result; // eax@7
  signed int v6; // ecx@7
  int v7; // edx@9
  signed int v8; // ecx@11
  int v9; // edx@12

  v1 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) |= 2 << v1;
  if ( v1 <= 13 )
  {
    *(_DWORD *)(a1 + 2932) = v1 + 3;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v2 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v2 - 13;
    *(_WORD *)(a1 + 2924) = 2u >> (16 - v2);
  }
  v3 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) = *(_WORD *)(a1 + 2924);
  if ( v3 <= 9 )
  {
    *(_DWORD *)(a1 + 2932) = v3 + 7;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v4 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v4 - 9;
    *(_WORD *)(a1 + 2924) = 0;
  }
  result = sub_1004E940(a1);
  v6 = *(_DWORD *)(result + 2932);
  if ( *(_DWORD *)(result + 2928) - v6 + 11 < 9 )
  {
    *(_WORD *)(result + 2924) |= 2 << v6;
    if ( v6 <= 13 )
    {
      *(_DWORD *)(result + 2932) = v6 + 3;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v7 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v7 - 13;
      *(_WORD *)(result + 2924) = 2u >> (16 - v7);
    }
    v8 = *(_DWORD *)(result + 2932);
    *(_WORD *)(result + 2924) = *(_WORD *)(result + 2924);
    if ( v8 > 9 )
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v9 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v9 - 9;
      *(_WORD *)(result + 2924) = 0;
      result = sub_1004E940(result);
      *(_DWORD *)(result + 2928) = 7;
      return result;
    }
    *(_DWORD *)(result + 2932) = v8 + 7;
    result = sub_1004E940(result);
  }
  *(_DWORD *)(result + 2928) = 7;
  return result;
}

//----- (1004FF60) --------------------------------------------------------
int __usercall sub_1004FF60@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4)
{
  int v4; // esi@1
  signed int v5; // ecx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  int result; // eax@2

  v4 = a2;
  v5 = *(_DWORD *)(a1 + 2932);
  if ( v5 <= 13 )
  {
    *(_WORD *)(a1 + 2924) |= v4 << v5;
    *(_DWORD *)(a1 + 2932) = v5 + 3;
    result = sub_1004EF00(a1, a3, a4);
  }
  else
  {
    v6 = v4 << v5;
    v7 = *(_DWORD *)(a1 + 5800);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) = (unsigned __int16)v4 >> (16 - v8);
    *(_DWORD *)(a1 + 2932) = v8 - 13;
    result = sub_1004EF00(a1, a3, a4);
  }
  return result;
}

//----- (10050000) --------------------------------------------------------
signed int __usercall sub_10050000@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax@1
  int v3; // ebp@1
  signed int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@1
  signed int v7; // eax@8
  signed int i; // ebp@14
  int v9; // ebx@16
  int v10; // eax@17
  int v11; // edx@17
  int v12; // ebp@17
  int v13; // eax@17
  unsigned __int8 v14; // cl@17
  int v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)v2;
  v17 = *(_DWORD *)(v2 + 12);
  v4 = -1;
  v5 = *(_DWORD *)a2;
  v6 = 0;
  v16 = -1;
  *(_DWORD *)(a1 + 2324) = 0;
  for ( *(_DWORD *)(a1 + 2328) = 573; v6 < v17; ++v6 )
  {
    if ( *(_WORD *)(v5 + 4 * v6) )
    {
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v6;
      v16 = v6;
      *(_BYTE *)(v6 + a1 + 2332) = 0;
      v4 = v6;
    }
    else
    {
      *(_WORD *)(v5 + 4 * v6 + 2) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 2324) < 2 )
  {
    do
    {
      if ( v4 >= 2 )
        v7 = 0;
      else
        v7 = ++v4;
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v7;
      *(_WORD *)(v5 + 4 * v7) = 1;
      *(_BYTE *)(a1 + v7 + 2332) = 0;
      --*(_DWORD *)(a1 + 2912);
      if ( v3 )
        *(_DWORD *)(a1 + 2916) -= *(_WORD *)(v3 + 4 * v7 + 2);
    }
    while ( *(_DWORD *)(a1 + 2324) < 2 );
    v16 = v4;
  }
  *(_DWORD *)(a2 + 4) = v4;
  for ( i = *(_DWORD *)(a1 + 2324) / 2; i >= 1; --i )
    sub_1004F550(a1, v5, i);
  v9 = v17;
  do
  {
    v10 = *(_DWORD *)(a1 + 2324);
    v11 = *(_DWORD *)(a1 + 4 * v10 + 32);
    v12 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 2324) = v10 - 1;
    *(_DWORD *)(a1 + 36) = v11;
    sub_1004F550(a1, v5, 1);
    v13 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v12;
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v13;
    *(_WORD *)(v5 + 4 * v9) = *(_WORD *)(v5 + 4 * v12) + *(_WORD *)(v5 + 4 * v13);
    v14 = *(_BYTE *)(a1 + v13 + 2332);
    if ( *(_BYTE *)(a1 + v12 + 2332) >= v14 )
      v14 = *(_BYTE *)(a1 + v12 + 2332);
    *(_BYTE *)(a1 + v9 + 2332) = v14 + 1;
    *(_WORD *)(v5 + 4 * v13 + 2) = v9;
    *(_WORD *)(v5 + 4 * v12 + 2) = v9;
    *(_DWORD *)(a1 + 36) = v9++;
    sub_1004F550(a1, v5, 1);
  }
  while ( *(_DWORD *)(a1 + 2324) >= 2 );
  *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = *(_DWORD *)(a1 + 36);
  sub_1004F010(a1, a2);
  return sub_1004F1E0(a1, v16, v5);
}

//----- (100501E0) --------------------------------------------------------
unsigned int __usercall sub_100501E0@<eax>(int a1@<edi>)
{
  size_t v1; // ebx@1
  unsigned int result; // eax@2
  unsigned int v3; // ebp@2
  int v4; // edx@3
  int v5; // eax@3
  _WORD *v6; // ecx@3
  int v7; // eax@4
  __int16 v8; // ax@5
  size_t v9; // edx@8
  _WORD *v10; // ecx@8
  int v11; // eax@9
  int v12; // esi@14
  unsigned int v13; // edx@15
  int v14; // esi@16
  int v15; // eax@16
  int v16; // ecx@16

  v1 = *(_DWORD *)(a1 + 5748);
  do
  {
    result = *(_DWORD *)(a1 + 5680);
    v3 = *(_DWORD *)(a1 + 5744) - result - *(_DWORD *)(a1 + 5688);
    if ( result >= v1 + *(_DWORD *)(a1 + 5748) - 262 )
    {
      memcpy(*(void **)(a1 + 5740), (const void *)(*(_DWORD *)(a1 + 5740) + v1), v1);
      v4 = *(_DWORD *)(a1 + 5764);
      v5 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5684) -= v1;
      *(_DWORD *)(a1 + 5680) -= v1;
      *(_DWORD *)(a1 + 5664) -= v1;
      v6 = (_WORD *)(v5 + 2 * v4);
      do
      {
        v7 = *(v6 - 1);
        --v6;
        if ( v7 < v1 )
          v8 = 0;
        else
          v8 = v7 - v1;
        --v4;
        *v6 = v8;
      }
      while ( v4 );
      v9 = v1;
      v10 = (_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * v1);
      do
      {
        v11 = *(v10 - 1);
        --v10;
        if ( v11 < v1 )
          result = 0;
        else
          result = v11 - v1;
        --v9;
        *v10 = result;
      }
      while ( v9 );
      v3 += v1;
    }
    v12 = *(_DWORD *)(a1 + 2908);
    if ( !*(_DWORD *)(v12 + 4) )
      break;
    result = sub_1004F640(v3, v12, (void *)(*(_DWORD *)(a1 + 5688) + *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)));
    *(_DWORD *)(a1 + 5688) += result;
    v13 = *(_DWORD *)(a1 + 5688);
    if ( v13 >= 3 )
    {
      v14 = *(_DWORD *)(a1 + 5680) + *(_DWORD *)(a1 + 5740);
      v15 = *(_BYTE *)v14;
      v16 = *(_DWORD *)(a1 + 5776);
      *(_DWORD *)(a1 + 5760) = v15;
      result = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v14 + 1) ^ (v15 << v16));
      *(_DWORD *)(a1 + 5760) = result;
    }
  }
  while ( v13 < 0x106 && *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 4) );
  return result;
}

//----- (10050320) --------------------------------------------------------
int __usercall sub_10050320@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  signed int v9; // ecx@4
  int v10; // edx@5
  int v11; // ecx@5
  int v12; // edx@5
  signed int v13; // ecx@7
  int v14; // edx@8
  int v15; // ecx@8
  int v16; // edx@8
  int i; // edi@10
  signed int v18; // ecx@11
  int v19; // edx@11
  unsigned __int16 v20; // si@12
  int v21; // edx@12
  int v22; // ecx@12
  int v23; // edx@12
  int v24; // eax@15

  v4 = *(_DWORD *)(a1 + 2932);
  v5 = a4;
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 2932) = v4 + 5;
  }
  else
  {
    v6 = (a2 - 257) << v4;
    v7 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    v5 = a4;
    *(_DWORD *)(a1 + 2932) = v8 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a2 - 257) >> (16 - v8);
  }
  v9 = *(_DWORD *)(a1 + 2932);
  if ( v9 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a3 - 1) << v9;
    *(_DWORD *)(a1 + 2932) = v9 + 5;
  }
  else
  {
    v10 = (a3 - 1) << v9;
    v11 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v10;
    *(_BYTE *)(v11 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v12 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v12 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a3 - 1) >> (16 - v12);
  }
  v13 = *(_DWORD *)(a1 + 2932);
  if ( v13 <= 12 )
  {
    *(_WORD *)(a1 + 2924) |= (v5 - 4) << v13;
    *(_DWORD *)(a1 + 2932) = v13 + 4;
  }
  else
  {
    v14 = (v5 - 4) << v13;
    v15 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v14;
    *(_BYTE *)(v15 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v16 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v16 - 12;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(v5 - 4) >> (16 - v16);
  }
  for ( i = 0; i < v5; ++i )
  {
    v18 = *(_DWORD *)(a1 + 2932);
    v19 = (unsigned __int8)byte_100D63CC[i];
    if ( v18 <= 13 )
    {
      *(_WORD *)(a1 + 2924) |= *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      *(_DWORD *)(a1 + 2932) = v18 + 3;
    }
    else
    {
      v20 = *(_WORD *)(a1 + 4 * v19 + 5474);
      v21 = *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      v22 = *(_DWORD *)(a1 + 5812);
      *(_WORD *)(a1 + 2924) |= v21;
      *(_BYTE *)(v22 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
      *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
      v23 = *(_DWORD *)(a1 + 2932);
      ++*(_DWORD *)(a1 + 5812);
      v5 = a4;
      *(_DWORD *)(a1 + 2932) = v23 - 13;
      *(_WORD *)(a1 + 2924) = v20 >> (16 - v23);
    }
  }
  v24 = sub_1004F780(a1, a1 + 2936, a2 - 1);
  return sub_1004F780(v24, v24 + 5228, a3 - 1);
}

//----- (100505D0) --------------------------------------------------------
signed int __cdecl sub_100505D0(int a1, int a2)
{
  int v2; // esi@3
  int v3; // eax@6
  signed int result; // eax@9
  int v5; // ebx@10
  char v6; // al@12
  int v7; // eax@14
  unsigned int v8; // ecx@17
  int v9; // eax@19
  int v10; // eax@20
  int v11; // eax@29
  signed int v12; // eax@36
  int v13; // eax@50
  bool v14; // zf@50

  if ( !a1 || (unsigned int)a2 > 4 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  if ( !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) )
    return -2;
  v3 = *(_DWORD *)(v2 + 5788);
  if ( v3 == 666 && a2 != 4 )
    return -2;
  if ( !*(_DWORD *)(a1 + 16) )
    return -5;
  v5 = *(_DWORD *)(v2 + 5792);
  *(_DWORD *)(v2 + 2908) = a1;
  *(_DWORD *)(v2 + 5792) = a2;
  if ( v3 == 42 )
  {
    if ( *(_BYTE *)(v2 + 5796) >= 2 || (v6 = *(_BYTE *)(v2 + 5784), v6 < 2) )
    {
      v7 = 0;
    }
    else if ( v6 >= 6 )
    {
      v7 = (v6 != 6) + 2;
    }
    else
    {
      v7 = 1;
    }
    v8 = (v7 << 6) | (((*(_DWORD *)(v2 + 5752) - 8) << 12) + 2048);
    if ( *(_DWORD *)(v2 + 5680) )
      v8 |= 0x20u;
    *(_DWORD *)(v2 + 5788) = 113;
    v9 = sub_1004F600(v2, 31 * (v8 / 0x1F + 1));
    if ( *(_DWORD *)(v2 + 5680) )
    {
      v10 = sub_1004F600(v9, *(_WORD *)(a1 + 30));
      sub_1004F600(v10, *(_WORD *)(a1 + 28));
    }
    *(_DWORD *)(a1 + 28) = sub_10051410(0, 0, 0);
  }
  if ( *(_DWORD *)(v2 + 5812) )
  {
    sub_1004EFB0(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
LABEL_24:
      *(_DWORD *)(v2 + 5792) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v5 && a2 != 4 )
  {
    return -5;
  }
  v11 = *(_DWORD *)(v2 + 5788);
  if ( v11 == 666 )
  {
    if ( *(_DWORD *)(a1 + 4) )
      return -5;
LABEL_33:
    if ( !*(_DWORD *)(v2 + 5688) && (!a2 || v11 == 666) )
      goto LABEL_47;
    goto LABEL_36;
  }
  if ( !*(_DWORD *)(a1 + 4) )
    goto LABEL_33;
LABEL_36:
  v12 = (*(&off_100D6D48 + 3 * *(_BYTE *)(v2 + 5784)))(v2, a2);
  if ( v12 == 2 || v12 == 3 )
    *(_DWORD *)(v2 + 5788) = 666;
  if ( !v12 || v12 == 2 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      return 0;
    *(_DWORD *)(v2 + 5792) = -1;
    return 0;
  }
  if ( v12 == 1 )
  {
    if ( a2 == 1 )
    {
      sub_1004FD20(v2);
    }
    else
    {
      sub_1004FF60(v2, 0, 0, 0);
      if ( a2 == 3 )
      {
        *(_WORD *)(*(_DWORD *)(v2 + 5736) + 2 * *(_DWORD *)(v2 + 5764) - 2) = 0;
        memset(*(void **)(v2 + 5736), 0, 2 * *(_DWORD *)(v2 + 5764) - 2);
      }
    }
    sub_1004EFB0(a1);
    if ( !*(_DWORD *)(a1 + 16) )
      goto LABEL_24;
  }
LABEL_47:
  if ( a2 != 4 )
    return 0;
  if ( *(_DWORD *)(v2 + 5780) > 0 )
  {
    v13 = sub_1004F600(v2, *(_WORD *)(a1 + 30));
    sub_1004F600(v13, *(_WORD *)(a1 + 28));
    sub_1004EFB0(a1);
    v14 = *(_DWORD *)(v2 + 5812) == 0;
    *(_DWORD *)(v2 + 5780) = -*(_DWORD *)(v2 + 5780);
    result = v14;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 100D6D48: using guessed type int (__cdecl *off_100D6D48)(int, int);

//----- (10050890) --------------------------------------------------------
signed int __usercall sub_10050890@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  signed int result; // eax@1

  v1 = a1;
  sub_1004F6A0(a1 + 2936, *(_DWORD *)(a1 + 5632), a1);
  sub_1004F6A0(v1 + 5228, *(_DWORD *)(v1 + 5644), v1);
  sub_10050000(v1, v1 + 5652);
  result = 18;
  while ( !*(_WORD *)(v1 + 4 * (unsigned __int8)byte_100D63CC[result] + 5474) )
  {
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100D63CB[result] + 5474) )
    {
      *(_DWORD *)(v1 + 2912) += 3 * --result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100D63CA[result] + 5474) )
    {
      result -= 2;
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100D63C9[result] + 5474) )
    {
      result -= 3;
      break;
    }
    result -= 4;
    if ( result < 3 )
    {
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
  }
  *(_DWORD *)(v1 + 2912) += 3 * result + 17;
  return result;
}

//----- (10050960) --------------------------------------------------------
_WORD *__usercall sub_10050960@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // eax@1
  _BYTE *v7; // edi@2
  signed int v8; // eax@5
  unsigned int v9; // edx@5
  unsigned int v10; // ecx@5
  int v11; // ecx@11
  bool v12; // zf@12
  signed int v13; // ecx@12
  int v14; // eax@13
  int v15; // edx@14
  int v16; // ecx@14
  int v17; // edx@14
  int v18; // edx@17
  int v19; // eax@18
  int v20; // ecx@18
  int v21; // ebx@18
  _WORD *result; // eax@21
  signed int v23; // [sp+14h] [bp+4h]@4

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(_DWORD *)(a2 + 5664);
  if ( v6 < 0 )
    v7 = 0;
  else
    v7 = (_BYTE *)(v6 + *(_DWORD *)(a2 + 5740));
  v23 = 0;
  if ( *(_BYTE *)(a2 + 5784) <= 0 )
  {
    v10 = v5 + 5;
LABEL_8:
    v9 = v10;
    goto LABEL_9;
  }
  sub_10050000(a2, a2 + 5628);
  sub_10050000(v4, v4 + 5640);
  v8 = sub_10050890(v4);
  v9 = (unsigned int)(*(_DWORD *)(v4 + 2912) + 10) >> 3;
  v10 = (unsigned int)(*(_DWORD *)(v4 + 2916) + 10) >> 3;
  v23 = v8;
  if ( v10 <= v9 )
    goto LABEL_8;
LABEL_9:
  if ( v5 + 4 <= v9 && v7 )
  {
    sub_1004FF60(v4, v3, v7, v5);
  }
  else
  {
    v12 = v10 == v9;
    v13 = *(_DWORD *)(v4 + 2932);
    if ( v12 )
    {
      v14 = v3 + 2;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v14 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v15 = v14 << v13;
        v16 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v15;
        *(_BYTE *)(v16 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v17 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v17 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v14 >> (16 - v17);
      }
      sub_1004EA80(v4, (int)&unk_100D6458, (int)&unk_100D68D8);
    }
    else
    {
      v18 = v3 + 4;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v18 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v19 = v18 << v13;
        v20 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v19;
        *(_BYTE *)(v20 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v21 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v21 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v18 >> (16 - v21);
      }
      sub_10050320(v4, *(_DWORD *)(v4 + 5632) + 1, *(_DWORD *)(v4 + 5644) + 1, v23 + 1);
      sub_1004EA80(v4, v4 + 2936, v4 + 5228);
    }
  }
  result = sub_1004F260(v11, v4);
  if ( v3 )
    result = (_WORD *)sub_1004E9F0(v4);
  return result;
}

//----- (10050B80) --------------------------------------------------------
signed int __cdecl sub_10050B80(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  int v4; // edx@7
  int v5; // edi@7
  int v6; // eax@7
  int v7; // ecx@7
  unsigned int v8; // eax@9
  char v9; // cl@10
  unsigned int v10; // eax@11
  unsigned int v11; // eax@16
  BOOL v12; // eax@17
  unsigned int v13; // ecx@17
  int v14; // edi@20
  int v15; // ecx@20
  int v16; // edx@20
  int v17; // ebx@20
  int v19; // edi@22
  int v20; // ecx@22
  int v21; // edx@22
  int v22; // edi@26
  signed int result; // eax@27
  int v24; // edi@28
  int v25; // eax@28

  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_100501E0(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    if ( v2 )
    {
      v8 = *(_DWORD *)(a1 + 5680) - v2;
      if ( v8 <= *(_DWORD *)(a1 + 5748) - 262 )
      {
        v9 = *(_BYTE *)(a1 + 5796);
        if ( v9 < 2 )
        {
          v10 = sub_1004F2D0(a1, v2);
LABEL_15:
          *(_DWORD *)(a1 + 5668) = v10;
          goto LABEL_16;
        }
        if ( v9 == 3 && v8 == 1 )
        {
          v10 = sub_1004F480(a1, v2);
          goto LABEL_15;
        }
      }
    }
LABEL_16:
    v11 = *(_DWORD *)(a1 + 5668);
    if ( v11 < 3 )
    {
      v12 = sub_1004E8A0(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)), 0);
      --*(_DWORD *)(a1 + 5688);
    }
    else
    {
      v12 = sub_1004E8A0(a1, v11 - 3, *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684));
      v13 = *(_DWORD *)(a1 + 5668);
      *(_DWORD *)(a1 + 5688) -= v13;
      if ( v13 > *(_DWORD *)(a1 + 5700) || *(_DWORD *)(a1 + 5688) < 3u )
      {
        *(_DWORD *)(a1 + 5680) += v13;
        v19 = *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680);
        v20 = *(_DWORD *)(a1 + 5776);
        *(_DWORD *)(a1 + 5668) = 0;
        v21 = *(_BYTE *)v19;
        *(_DWORD *)(a1 + 5760) = v21;
        *(_DWORD *)(a1 + 5760) = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v19 + 1) ^ (v21 << v20));
        goto LABEL_25;
      }
      *(_DWORD *)(a1 + 5668) = v13 - 1;
      do
      {
        v14 = ++*(_DWORD *)(a1 + 5680);
        v15 = *(_DWORD *)(a1 + 5736);
        v16 = *(_DWORD *)(a1 + 5772) & ((*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)) ^ *(_BYTE *)(*(_DWORD *)(a1 + 5740) + v14 + 2));
        v17 = *(_DWORD *)(a1 + 5756);
        *(_DWORD *)(a1 + 5760) = v16;
        *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v14 & v17)) = *(_WORD *)(v15 + 2 * v16);
        v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
        *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
      }
      while ( (*(_DWORD *)(a1 + 5668))-- != 1 );
    }
    ++*(_DWORD *)(a1 + 5680);
LABEL_25:
    if ( v12 )
    {
      sub_10050960(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
      v22 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_1004EFB0(v22);
      if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        return 0;
    }
  }
  sub_10050960(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v24 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_1004EFB0(v24);
  v25 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v25) = a2 == 4;
    result = 2 * v25 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (10050E90) --------------------------------------------------------
signed int __cdecl sub_10050E90(int a1, int a2)
{
  unsigned int v2; // ebp@1
  unsigned int v3; // eax@3
  int v4; // edx@8
  int v5; // edi@8
  int v6; // eax@8
  int v7; // ecx@8
  unsigned int v8; // ecx@9
  int v9; // edx@9
  unsigned int v10; // eax@11
  char v11; // cl@12
  unsigned int v12; // eax@13
  unsigned int v13; // eax@18
  unsigned int v14; // eax@23
  int v15; // ecx@25
  unsigned int v16; // ebp@25
  BOOL v17; // eax@25
  int v18; // ecx@25
  BOOL v19; // ebx@25
  unsigned int v20; // edi@26
  int v21; // ecx@27
  int v22; // edx@27
  int v23; // eax@27
  int v25; // eax@29
  int v26; // edi@30
  signed int result; // eax@31
  int v28; // edi@34
  int v29; // ecx@35
  int v30; // edi@40
  unsigned int v31; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v31 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_100501E0(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    v8 = *(_DWORD *)(a1 + 5668);
    v9 = *(_DWORD *)(a1 + 5684);
    *(_DWORD *)(a1 + 5692) = v8;
    *(_DWORD *)(a1 + 5672) = v9;
    *(_DWORD *)(a1 + 5668) = 2;
    if ( !v2 )
      goto LABEL_23;
    if ( v8 >= *(_DWORD *)(a1 + 5700) )
      goto LABEL_23;
    v10 = *(_DWORD *)(a1 + 5680) - v2;
    if ( v10 > *(_DWORD *)(a1 + 5748) - 262 )
      goto LABEL_23;
    v11 = *(_BYTE *)(a1 + 5796);
    if ( v11 < 2 )
    {
      v12 = sub_1004F2D0(a1, v2);
LABEL_17:
      *(_DWORD *)(a1 + 5668) = v12;
      goto LABEL_18;
    }
    if ( v11 == 3 && v10 == 1 )
    {
      v12 = sub_1004F480(a1, v2);
      goto LABEL_17;
    }
LABEL_18:
    v13 = *(_DWORD *)(a1 + 5668);
    if ( v13 <= 5
      && (*(_BYTE *)(a1 + 5796) == 1
       || v13 == 3 && (unsigned int)(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684)) > 0x1000) )
    {
      *(_DWORD *)(a1 + 5668) = 2;
    }
LABEL_23:
    v14 = *(_DWORD *)(a1 + 5692);
    if ( v14 < 3 || *(_DWORD *)(a1 + 5668) > v14 )
    {
      if ( *(_DWORD *)(a1 + 5676) )
      {
        if ( sub_1004E8A0(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0) )
        {
          sub_10050960(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
          v28 = *(_DWORD *)(a1 + 2908);
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
          sub_1004EFB0(v28);
        }
        v29 = *(_DWORD *)(a1 + 2908);
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        if ( !*(_DWORD *)(v29 + 16) )
          return 0;
      }
      else
      {
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        *(_DWORD *)(a1 + 5676) = 1;
      }
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 5680);
      v16 = v15 + *(_DWORD *)(a1 + 5688) - 3;
      v17 = sub_1004E8A0(a1, v14 - 3, v15 - *(_DWORD *)(a1 + 5672) - 1);
      v18 = *(_DWORD *)(a1 + 5692);
      v19 = v17;
      *(_DWORD *)(a1 + 5688) += 1 - v18;
      *(_DWORD *)(a1 + 5692) = v18 - 2;
      do
      {
        v20 = ++*(_DWORD *)(a1 + 5680);
        if ( v20 <= v16 )
        {
          v21 = *(_DWORD *)(a1 + 5736);
          v22 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v20 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
          v23 = *(_DWORD *)(a1 + 5756);
          *(_DWORD *)(a1 + 5760) = v22;
          *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v20 & v23)) = *(_WORD *)(v21 + 2 * v22);
          v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
          *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
        }
      }
      while ( (*(_DWORD *)(a1 + 5692))-- != 1 );
      v25 = ++*(_DWORD *)(a1 + 5680);
      *(_DWORD *)(a1 + 5676) = 0;
      *(_DWORD *)(a1 + 5668) = 2;
      if ( v19 )
      {
        sub_10050960(v25 - *(_DWORD *)(a1 + 5664), a1, 0);
        v26 = *(_DWORD *)(a1 + 2908);
        *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
        sub_1004EFB0(v26);
        if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
          return 0;
      }
      v2 = v31;
    }
  }
  if ( *(_DWORD *)(a1 + 5676) )
  {
    sub_1004E8A0(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0);
    *(_DWORD *)(a1 + 5676) = 0;
  }
  sub_10050960(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v30 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_1004EFB0(v30);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
    result = 2 * (a2 == 4) + 1;
  else
    result = a2 != 4 ? 0 : 2;
  return result;
}

//----- (100512A0) --------------------------------------------------------
signed int __cdecl sub_100512A0(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // eax@3
  bool v4; // zf@5
  int v5; // edx@5
  unsigned int v6; // ecx@5
  unsigned int v7; // eax@5
  int v8; // edi@7
  unsigned int v9; // eax@8
  int v10; // edi@9
  signed int result; // eax@10
  int v12; // edi@12
  int v13; // eax@12

  v2 = 0xFFFF;
  if ( (unsigned int)(*(_DWORD *)(a1 + 5804) - 5) <= 0xFFFF )
    v2 = *(_DWORD *)(a1 + 5804) - 5;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 <= 1 )
    {
      sub_100501E0(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( !v3 )
        break;
    }
    v4 = v3 + *(_DWORD *)(a1 + 5680) == 0;
    *(_DWORD *)(a1 + 5680) += v3;
    v5 = *(_DWORD *)(a1 + 5664);
    v6 = *(_DWORD *)(a1 + 5680);
    *(_DWORD *)(a1 + 5688) = 0;
    v7 = v5 + v2;
    if ( !v4 && v6 < v7
      || (*(_DWORD *)(a1 + 5688) = v6 - v7,
          *(_DWORD *)(a1 + 5680) = v7,
          sub_10050960(v2, a1, 0),
          v8 = *(_DWORD *)(a1 + 2908),
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680),
          sub_1004EFB0(v8),
          *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16)) )
    {
      v9 = *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664);
      if ( v9 < *(_DWORD *)(a1 + 5748) - 262 )
        continue;
      sub_10050960(v9, a1, 0);
      v10 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_1004EFB0(v10);
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  sub_10050960(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v12 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_1004EFB0(v12);
  v13 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v13) = a2 == 4;
    result = 2 * v13 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (10051410) --------------------------------------------------------
int __cdecl sub_10051410(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edi@1
  unsigned int v4; // ecx@1
  unsigned int v5; // esi@1
  int result; // eax@2
  unsigned int i; // ebp@3
  unsigned int v8; // ebx@4
  int v9; // eax@8
  signed int v10; // edx@8
  int v11; // ecx@9
  int v12; // esi@9
  int v13; // ecx@9
  int v14; // esi@9
  int v15; // ecx@9
  int v16; // esi@9
  unsigned int v17; // [sp+Ch] [bp+4h]@7

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = a1 >> 16;
  if ( a2 )
  {
    for ( i = a3; i; v5 %= 0xFFF1u )
    {
      v8 = i;
      if ( i >= 0x15B0 )
        v8 = 5552;
      i -= v8;
      if ( (signed int)v8 >= 16 )
      {
        v17 = v8 >> 4;
        v8 += -16 * (v8 >> 4);
        do
        {
          v9 = (int)(v3 + 1);
          v10 = 4;
          do
          {
            v11 = *(_BYTE *)(v9 - 1) + v4;
            v12 = v11 + v5;
            v13 = *(_BYTE *)v9 + v11;
            v14 = v13 + v12;
            v15 = *(_BYTE *)(v9 + 1) + v13;
            v16 = v15 + v14;
            v4 = *(_BYTE *)(v9 + 2) + v15;
            v5 = v4 + v16;
            v9 += 4;
            --v10;
          }
          while ( v10 );
          v3 += 16;
          --v17;
        }
        while ( v17 );
      }
      for ( ; v8; --v8 )
      {
        v4 += *v3++;
        v5 += v4;
      }
      v4 %= 0xFFF1u;
    }
    result = v4 | (v5 << 16);
  }
  else
  {
    result = (int)(a2 + 1);
  }
  return result;
}

//----- (10051510) --------------------------------------------------------
signed int __cdecl sub_10051510(int a1)
{
  signed int result; // eax@3

  if ( a1 && *(_DWORD *)(a1 + 24) )
  {
    *(_DWORD *)(a1 + 24) = 0;
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10051530) --------------------------------------------------------
signed int __usercall sub_10051530@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10)
{
  unsigned int v10; // ebp@1
  unsigned int *v11; // edi@1
  _DWORD *v12; // eax@1
  unsigned int v13; // edx@1
  signed int result; // eax@4
  unsigned int v15; // eax@5
  int v16; // ecx@7
  signed int v17; // edx@9
  signed int v18; // esi@13
  int i; // edi@13
  int v20; // esi@14
  int v21; // edi@16
  int v22; // esi@16
  int v23; // edi@17
  int v24; // ebx@17
  int v25; // esi@17
  int v26; // edi@18
  _DWORD *v27; // edi@20
  unsigned int v28; // ebx@20
  int v29; // esi@21
  int v30; // edi@22
  signed int v31; // edi@24
  int v32; // ebx@24
  unsigned int v33; // esi@25
  int v34; // edx@27
  int l; // ebp@28
  unsigned int v36; // edx@31
  unsigned int v37; // ecx@33
  int *v38; // ebp@34
  int v39; // eax@34
  unsigned int v40; // edi@36
  unsigned int v41; // eax@36
  unsigned int v42; // edx@39
  int v43; // eax@40
  unsigned int v44; // eax@41
  int v45; // ecx@41
  int v46; // esi@48
  signed int v47; // edx@50
  unsigned int v48; // eax@50
  int v49; // ecx@51
  unsigned int j; // eax@54
  int v51; // [sp+Ch] [bp-F4h]@7
  unsigned int v52; // [sp+Ch] [bp-F4h]@24
  signed int v53; // [sp+Ch] [bp-F4h]@31
  unsigned int v54; // [sp+10h] [bp-F0h]@9
  int v55; // [sp+14h] [bp-ECh]@24
  int v56; // [sp+18h] [bp-E8h]@26
  _DWORD *v57; // [sp+1Ch] [bp-E4h]@21
  int v58; // [sp+1Ch] [bp-E4h]@31
  unsigned int k; // [sp+20h] [bp-E0h]@24
  int *v60; // [sp+24h] [bp-DCh]@25
  int v61; // [sp+28h] [bp-D8h]@0
  unsigned int v62; // [sp+2Ch] [bp-D4h]@0
  int v63; // [sp+30h] [bp-D0h]@24
  unsigned int *v64; // [sp+34h] [bp-CCh]@24
  int v65; // [sp+38h] [bp-C8h]@11
  int v66; // [sp+3Ch] [bp-C4h]@31
  int v67; // [sp+40h] [bp-C0h]@16
  int v68; // [sp+44h] [bp-BCh]@1
  int v69; // [sp+48h] [bp-B8h]@1
  int v70; // [sp+4Ch] [bp-B4h]@1
  int v71; // [sp+50h] [bp-B0h]@1
  int v72; // [sp+54h] [bp-ACh]@1
  int v73; // [sp+58h] [bp-A8h]@1
  int v74; // [sp+5Ch] [bp-A4h]@1
  int v75; // [sp+60h] [bp-A0h]@1
  int v76; // [sp+64h] [bp-9Ch]@1
  int v77; // [sp+68h] [bp-98h]@1
  int v78; // [sp+6Ch] [bp-94h]@1
  int v79; // [sp+70h] [bp-90h]@1
  int v80; // [sp+74h] [bp-8Ch]@1
  int v81; // [sp+78h] [bp-88h]@1
  int v82; // [sp+7Ch] [bp-84h]@1
  int v83; // [sp+80h] [bp-80h]@1
  int v84; // [sp+84h] [bp-7Ch]@22
  int v85[14]; // [sp+88h] [bp-78h]@17
  int v86; // [sp+C0h] [bp-40h]@41
  int v87[15]; // [sp+C4h] [bp-3Ch]@24
  int v88; // [sp+108h] [bp+8h]@24

  v10 = 0;
  v11 = a1;
  v12 = a2;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v13 = a3;
  do
  {
    ++*(&v68 + *v12);
    ++v12;
    --v13;
  }
  while ( v13 );
  if ( v68 == a3 )
  {
    *a7 = 0;
    *v11 = 0;
    return 0;
  }
  v15 = 1;
  if ( !v69 )
  {
    do
      ++v15;
    while ( !*(&v68 + v15) );
  }
  v16 = v15;
  v51 = v15;
  if ( *v11 > v15 )
    v15 = *v11;
  v54 = v15;
  v17 = 15;
  if ( !v83 )
  {
    do
      --v17;
    while ( !*(&v68 + v17) );
  }
  v65 = v17;
  if ( (signed int)v15 > v17 )
  {
    v54 = v17;
    v15 = v17;
  }
  v18 = 1 << v16;
  *v11 = v15;
  for ( i = v16; i < v17; v18 = 2 * v20 )
  {
    v20 = v18 - *(&v68 + i);
    if ( v20 < 0 )
      return -3;
    ++i;
  }
  v21 = *(&v68 + v17);
  v22 = v18 - v21;
  v67 = v22;
  if ( v22 < 0 )
    return -3;
  v23 = v22 + v21;
  v24 = v17 - 1;
  v25 = 0;
  *(&v68 + v17) = v23;
  v85[0] = 0;
  if ( v17 != 1 )
  {
    v26 = 0;
    do
    {
      v25 += *(int *)((char *)&v69 + v26 * 4);
      ++v26;
      --v24;
      v85[v26] = v25;
    }
    while ( v24 );
  }
  v27 = a2;
  v28 = 0;
  do
  {
    v29 = *v27;
    ++v27;
    v57 = v27;
    if ( v29 )
    {
      v30 = *(&v84 + v29);
      a10[v30] = v28;
      v16 = v51;
      *(&v84 + v29) = v30 + 1;
      v27 = v57;
    }
    ++v28;
  }
  while ( v28 < a3 );
  v88 = *(&v84 + v17);
  v31 = -1;
  v32 = -v15;
  v84 = 0;
  k = 0;
  v64 = a10;
  v87[0] = 0;
  v63 = 0;
  v52 = 0;
  v55 = v16;
  if ( v16 > v17 )
  {
LABEL_60:
    if ( v67 && v17 != 1 )
      result = -5;
    else
      result = 0;
  }
  else
  {
    v33 = v62;
    v60 = &v68 + v16;
    while ( 1 )
    {
      v56 = *v60;
      if ( *v60 )
        break;
LABEL_59:
      v17 = v65;
      ++v60;
      v55 = ++v16;
      if ( v16 > v65 )
        goto LABEL_60;
    }
    while ( 1 )
    {
      --v56;
      v34 = v32 + v15;
      if ( (signed int)(v32 + v15) < v16 )
        break;
LABEL_44:
      BYTE1(v61) = v16 - v32;
      if ( v64 < &a10[v88] )
      {
        v33 = *v64;
        if ( *v64 >= a4 )
        {
          v46 = 4 * (v33 - a4);
          LOBYTE(v61) = *(_BYTE *)(v46 + a6) + 80;
          v33 = *(_DWORD *)(v46 + a5);
        }
        else
        {
          LOBYTE(v61) = v33 < 0x100 ? 0 : 96;
        }
        ++v64;
      }
      else
      {
        LOBYTE(v61) = -64;
      }
      v47 = 1 << (v16 - v32);
      v48 = v10 >> v32;
      if ( v10 >> v32 < v52 )
      {
        v49 = v63 + 8 * v48;
        do
        {
          *(_DWORD *)v49 = v61;
          *(_DWORD *)(v49 + 4) = v33;
          v48 += v47;
          v49 += 8 * v47;
        }
        while ( v48 < v52 );
        v10 = k;
      }
      for ( j = 1 << (v55 - 1); v10 & j; j >>= 1 )
        v10 ^= j;
      v10 ^= j;
      for ( k = v10; (v10 & ((1 << v32) - 1)) != *(&v84 + v31); --v31 )
        v32 -= v54;
      v15 = v54;
      v16 = v55;
      if ( !v56 )
        goto LABEL_59;
    }
    for ( l = v32 - v15; ; l = v58 )
    {
      v66 = v15 + v34;
      v32 += v15;
      ++v31;
      v36 = v65 - v32;
      v53 = v31;
      v58 = v15 + l;
      if ( v65 - v32 > v15 )
        v36 = v15;
      v37 = v16 - v32;
      if ( 1 << v37 > (unsigned int)(v56 + 1) )
      {
        v38 = v60;
        v39 = -1 - v56 + (1 << v37);
        if ( v37 < v36 )
        {
          while ( ++v37 < v36 )
          {
            v40 = v38[1];
            ++v38;
            v41 = 2 * v39;
            if ( v41 <= v40 )
              break;
            v39 = v41 - v40;
          }
        }
        v31 = v53;
      }
      v52 = 1 << v37;
      v42 = *a9 + (1 << v37);
      if ( v42 > 0x5A0 )
        break;
      v43 = a8 + 8 * *a9;
      *a9 = v42;
      v10 = k;
      v87[v31] = v43;
      v63 = v43;
      if ( v31 )
      {
        LOBYTE(v61) = v37;
        v44 = k >> v58;
        v45 = *(&v86 + v31);
        BYTE1(v61) = v54;
        v33 = ((v63 - v45) >> 3) - (k >> v58);
        *(_DWORD *)(v45 + 8 * v44) = v61;
        *(&v84 + v31) = k;
        *(_DWORD *)(v45 + 8 * v44 + 4) = v33;
      }
      else
      {
        *a7 = v43;
      }
      v34 = v66;
      v16 = v55;
      if ( v66 >= v55 )
        goto LABEL_44;
      v15 = v54;
    }
    result = -3;
  }
  return result;
}
// 10051530: using guessed type int var_78[14];
// 10051530: using guessed type int var_3C[15];

//----- (100519D0) --------------------------------------------------------
int (__cdecl *__usercall sub_100519D0@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax@3
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax@3

  if ( a1 )
    *a1 = *(_DWORD *)(a2 + 14124);
  v3 = *(_DWORD *)(a2 + 14104);
  *(_DWORD *)(a2 + 14112) = v3;
  *(_DWORD *)(a2 + 14116) = v3;
  result = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a2 + 14120);
  *(_BYTE *)a2 = 0;
  *(_DWORD *)(a2 + 1424) = 0;
  *(_DWORD *)(a2 + 1428) = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    *(_DWORD *)(a2 + 14124) = result;
    *(_DWORD *)(a3 + 28) = result;
  }
  return result;
}

//----- (10051A20) --------------------------------------------------------
int __usercall sub_10051A20@<eax>(int result@<eax>, char a2, char a3, int a4, int a5)
{
  *(_BYTE *)(result + 16) = a2;
  *(_BYTE *)(result + 17) = a3;
  *(_BYTE *)result = 0;
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(result + 24) = a5;
  return result;
}

//----- (10051A40) --------------------------------------------------------
signed int __cdecl sub_10051A40(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // ebp@1
  unsigned int v7; // ecx@1
  unsigned int v8; // edx@1
  _BYTE *v9; // edi@1
  unsigned int v10; // eax@1
  int v11; // esi@6
  int v12; // ebx@8
  int v13; // esi@8
  int v14; // ecx@8
  int v15; // ecx@11
  int v16; // ebx@13
  unsigned int v17; // eax@13
  unsigned int v18; // edx@13
  int v19; // esi@14
  int v20; // ebx@16
  int v21; // esi@16
  unsigned int v22; // edx@16
  unsigned int v23; // eax@16
  int v24; // ecx@18
  int v25; // ecx@18
  int i; // ebx@19
  char v27; // cl@21
  int v28; // ebx@21
  int v29; // ecx@21
  int v30; // esi@22
  _BYTE *v31; // edi@22
  _BYTE *v32; // esi@22
  unsigned int v33; // ecx@23
  unsigned int v34; // ecx@32
  int v35; // ebp@34
  int v36; // ebx@34
  unsigned int v38; // ecx@35
  int v39; // ebp@37
  int v40; // ebx@37
  int v41; // esi@37
  int v42; // eax@37
  unsigned int v43; // ecx@38
  int v44; // ebp@41
  int v45; // ebx@41
  int v46; // ebp@44
  unsigned int v47; // [sp+10h] [bp-14h]@1
  unsigned int v48; // [sp+14h] [bp-10h]@2
  _BYTE *v49; // [sp+18h] [bp-Ch]@1
  int v50; // [sp+1Ch] [bp-8h]@4
  int v51; // [sp+20h] [bp-4h]@4
  unsigned int v52; // [sp+28h] [bp+4h]@21
  unsigned int v53; // [sp+2Ch] [bp+8h]@13
  int v54; // [sp+2Ch] [bp+8h]@24

  v6 = *(_BYTE **)a6;
  v7 = *(_DWORD *)(a5 + 14112);
  v8 = *(_DWORD *)(a5 + 1428);
  v9 = *(_BYTE **)(a5 + 14116);
  v47 = *(_DWORD *)(a6 + 4);
  v10 = *(_DWORD *)(a5 + 1424);
  v49 = *(_BYTE **)a6;
  if ( (unsigned int)v9 >= v7 )
    v48 = *(_DWORD *)(a5 + 14108) - (_DWORD)v9;
  else
    v48 = v7 - (_DWORD)v9 - 1;
  v50 = dword_100D6F30[a1];
  v51 = dword_100D6F30[a2];
  while ( 1 )
  {
    if ( v10 < 0x14 )
    {
      do
      {
        --v47;
        v11 = *v6 << v10;
        v10 += 8;
        ++v6;
        v8 |= v11;
      }
      while ( v10 < 0x14 );
      v49 = v6;
    }
    v12 = *(_BYTE *)(a3 + 8 * (v8 & v50));
    v13 = a3 + 8 * (v8 & v50);
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( v12 )
      break;
LABEL_29:
    v10 -= v14;
    *v9++ = *(_BYTE *)(v13 + 4);
    --v48;
LABEL_30:
    if ( v48 < 0x102 || v47 < 0xA )
    {
      v34 = *(_DWORD *)(a6 + 4) - v47;
      if ( v10 >> 3 < v34 )
        v34 = v10 >> 3;
      v35 = (int)&v6[-v34];
      *(_DWORD *)(a6 + 4) = v34 + v47;
      v36 = v35 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v35;
      *(_DWORD *)(a6 + 8) += v36;
      *(_DWORD *)(a5 + 14116) = v9;
      *(_DWORD *)(a5 + 1424) = v10 - 8 * v34;
      *(_DWORD *)(a5 + 1428) = v8;
      return 0;
    }
  }
  v10 -= *(_BYTE *)(v13 + 1);
  if ( v12 & 0x10 )
  {
LABEL_13:
    v16 = v12 & 0xF;
    v17 = v10 - v16;
    v53 = *(_DWORD *)(v13 + 4) + (v8 & dword_100D6F30[v16]);
    v18 = v8 >> v16;
    if ( v17 < 0xF )
    {
      do
      {
        --v47;
        v19 = *v6 << v17;
        v17 += 8;
        ++v6;
        v18 |= v19;
      }
      while ( v17 < 0xF );
      v49 = v6;
    }
    v20 = *(_BYTE *)(a4 + 8 * (v18 & v51));
    v21 = a4 + 8 * (v18 & v51);
    v22 = v18 >> *(_BYTE *)(v21 + 1);
    v23 = v17 - *(_BYTE *)(v21 + 1);
    if ( !(v20 & 0x10) )
    {
      while ( !(v20 & 0x40) )
      {
        v24 = *(_DWORD *)(v21 + 4) + (v22 & dword_100D6F30[v20]);
        v20 = *(_BYTE *)(v21 + 8 * v24);
        v21 += 8 * v24;
        v25 = *(_BYTE *)(v21 + 1);
        v22 >>= v25;
        v23 -= v25;
        if ( v20 & 0x10 )
          goto LABEL_19;
      }
      v38 = *(_DWORD *)(a6 + 4) - v47;
      if ( v23 >> 3 < v38 )
        v38 = v23 >> 3;
      v39 = (int)&v6[-v38];
      *(_DWORD *)(a6 + 4) = v38 + v47;
      v40 = v39 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v39;
      *(_DWORD *)(a6 + 8) += v40;
      v41 = a5;
      *(_DWORD *)(a5 + 1428) = v22;
      v42 = v23 - 8 * v38;
      goto LABEL_45;
    }
LABEL_19:
    for ( i = v20 & 0xF; v23 < (unsigned __int16)i; ++v49 )
    {
      --v47;
      v22 |= *v6 << v23;
      v6 = v49 + 1;
      v23 += 8;
    }
    v10 = v23 - i;
    v52 = *(_DWORD *)(v21 + 4) + (v22 & dword_100D6F30[i]);
    v27 = i;
    v28 = v53;
    v48 -= v53;
    v8 = v22 >> v27;
    v29 = *(_DWORD *)(a5 + 14104);
    if ( (unsigned int)&v9[-v29] < v52 )
    {
      v33 = v52 + v29 - (_DWORD)v9;
      v32 = (_BYTE *)(*(_DWORD *)(a5 + 14108) - v33);
      if ( v53 > v33 )
      {
        v54 = v53 - v33;
        do
        {
          *v9++ = *v32++;
          --v33;
        }
        while ( v33 );
        v32 = *(_BYTE **)(a5 + 14104);
        v28 = v54;
      }
    }
    else
    {
      v30 = (int)&v9[-v52];
      v31 = v9 + 1;
      *(v31 - 1) = *(_BYTE *)v30;
      *v31 = *(_BYTE *)(v30 + 1);
      v9 = v31 + 1;
      v32 = (_BYTE *)(v30 + 2);
      v28 = v53 - 2;
    }
    do
    {
      *v9++ = *v32++;
      --v28;
    }
    while ( v28 );
    goto LABEL_30;
  }
  while ( !(v12 & 0x40) )
  {
    v15 = *(_DWORD *)(v13 + 4) + (v8 & dword_100D6F30[v12]);
    v12 = *(_BYTE *)(v13 + 8 * v15);
    v13 += 8 * v15;
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( !v12 )
      goto LABEL_29;
    v10 -= *(_BYTE *)(v13 + 1);
    if ( v12 & 0x10 )
      goto LABEL_13;
  }
  v43 = *(_DWORD *)(a6 + 4) - v47;
  if ( !(v12 & 0x20) )
  {
    if ( v10 >> 3 < v43 )
      v43 = v10 >> 3;
    v46 = (int)&v6[-v43];
    *(_DWORD *)(a6 + 4) = v43 + v47;
    *(_DWORD *)(a6 + 8) += v46 - *(_DWORD *)a6;
    *(_DWORD *)a6 = v46;
    v41 = a5;
    *(_DWORD *)(a5 + 1428) = v8;
    v42 = v10 - 8 * v43;
LABEL_45:
    *(_DWORD *)(v41 + 14116) = v9;
    *(_DWORD *)(v41 + 1424) = v42;
    return -3;
  }
  if ( v10 >> 3 < v43 )
    v43 = v10 >> 3;
  *(_DWORD *)(a6 + 4) = v43 + v47;
  v44 = (int)&v6[-v43];
  v45 = v44 - *(_DWORD *)a6;
  *(_DWORD *)a6 = v44;
  *(_DWORD *)(a6 + 8) += v45;
  *(_DWORD *)(a5 + 1428) = v8;
  *(_DWORD *)(a5 + 14116) = v9;
  *(_DWORD *)(a5 + 1424) = v10 - 8 * v43;
  return 1;
}
// 100D6F30: using guessed type int dword_100D6F30[];

//----- (10051DF0) --------------------------------------------------------
int __usercall sub_10051DF0@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  const void *v3; // ebx@1
  unsigned int v4; // ebp@1
  size_t v5; // eax@3
  size_t v6; // ebp@3
  int (__cdecl *v7)(_DWORD, const void *, size_t); // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int v10; // ebx@10
  const void *v11; // ebx@11
  size_t v12; // eax@13
  size_t v13; // ebp@13
  int (__cdecl *v14)(_DWORD, const void *, size_t); // eax@15
  int v15; // eax@16
  int result; // eax@18
  void *v17; // [sp+8h] [bp-4h]@1
  char *v18; // [sp+8h] [bp-4h]@10

  v3 = *(const void **)(a2 + 14112);
  v4 = *(_DWORD *)(a2 + 14116);
  v17 = *(void **)(a1 + 12);
  if ( (unsigned int)v3 > v4 )
    v4 = *(_DWORD *)(a2 + 14108);
  v5 = *(_DWORD *)(a1 + 16);
  v6 = v4 - (_DWORD)v3;
  if ( v6 > v5 )
    v6 = *(_DWORD *)(a1 + 16);
  if ( v6 && a3 == -5 )
    a3 = 0;
  *(_DWORD *)(a1 + 20) += v6;
  *(_DWORD *)(a1 + 16) = v5 - v6;
  v7 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
  if ( v7 )
  {
    v8 = v7(*(_DWORD *)(a2 + 14124), v3, v6);
    *(_DWORD *)(a2 + 14124) = v8;
    *(_DWORD *)(a1 + 28) = v8;
  }
  memcpy(v17, v3, v6);
  v9 = *(_DWORD *)(a2 + 14108);
  v18 = (char *)v17 + v6;
  v10 = (int)v3 + v6;
  if ( v10 == v9 )
  {
    v11 = *(const void **)(a2 + 14104);
    if ( *(_DWORD *)(a2 + 14116) == v9 )
      *(_DWORD *)(a2 + 14116) = v11;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a2 + 14116) - (_DWORD)v11;
    if ( v13 > v12 )
      v13 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) += v13;
    *(_DWORD *)(a1 + 16) = v12 - v13;
    v14 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
    if ( v14 )
    {
      v15 = v14(*(_DWORD *)(a2 + 14124), v11, v13);
      *(_DWORD *)(a2 + 14124) = v15;
      *(_DWORD *)(a1 + 28) = v15;
    }
    memcpy(v18, v11, v13);
    v18 += v13;
    v10 = (int)v11 + v13;
  }
  *(_DWORD *)(a1 + 12) = v18;
  result = a3;
  *(_DWORD *)(a2 + 14112) = v10;
  return result;
}

//----- (10051F30) --------------------------------------------------------
signed int __usercall sub_10051F30@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4)
{
  signed int result; // eax@1
  int v5; // [sp+0h] [bp-50h]@1
  char v6; // [sp+4h] [bp-4Ch]@1

  v5 = 0;
  result = sub_10051530(a2, a3, 0x13u, 19, 0, 0, a4, a1, (unsigned int *)&v5, (unsigned int *)&v6);
  if ( result == -5 || !*a2 )
    result = -3;
  return result;
}

//----- (10051F80) --------------------------------------------------------
signed int __usercall sub_10051F80@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9)
{
  unsigned int *v9; // edi@1
  signed int result; // eax@6
  int v11; // [sp+8h] [bp-4h]@1

  v9 = a1;
  v11 = 0;
  if ( sub_10051530(a7, a6, a4, 257, (int)&unk_100D6FC8, (int)&unk_100D7048, a2, a3, (unsigned int *)&v11, a1)
    || !*a7
    || sub_10051530(a8, &a6[a4], a5, 0, (int)&unk_100D70C8, (int)&unk_100D7140, a9, a3, (unsigned int *)&v11, v9)
    || !*a8 && a4 > 0x101 )
  {
    result = -3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10052020) --------------------------------------------------------
int __usercall sub_10052020@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4)
{
  *a1 = 9;
  *a3 = 5;
  *a2 = &unk_100D71B8;
  *a4 = &unk_100D81B8;
  return 0;
}

//----- (10052040) --------------------------------------------------------
signed int __cdecl sub_10052040(int a1)
{
  signed int result; // eax@2
  int v2; // ecx@3
  int v3; // esi@3

  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    v3 = *(_DWORD *)(v2 + 20);
    *(_BYTE *)v2 = *(_DWORD *)(v2 + 12) != 0 ? 7 : 0;
    sub_100519D0(0, v3, a1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10052050) --------------------------------------------------------
int __usercall sub_10052050@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // edi@1
  _BYTE *v4; // ebx@1
  int v5; // esi@1
  _BYTE *v6; // edx@1
  unsigned int v7; // ebp@1
  unsigned int v8; // eax@1
  unsigned int v9; // eax@2
  unsigned int v10; // ecx@4
  int v11; // ecx@8
  signed int v12; // eax@8
  int v13; // ecx@8
  unsigned int v14; // eax@8
  int v15; // ecx@13
  int v16; // eax@16
  int v17; // eax@17
  int v18; // ecx@17
  int v19; // eax@17
  int v20; // eax@27
  int v21; // eax@28
  int v22; // ecx@28
  int v23; // ecx@28
  int v24; // eax@31
  int v25; // eax@32
  int v26; // ecx@32
  int v27; // eax@32
  int v28; // eax@38
  int v29; // eax@39
  int v30; // ecx@39
  int v31; // ecx@40
  int v32; // eax@41
  unsigned int v33; // eax@46
  unsigned int v34; // ecx@46
  int v35; // eax@51
  unsigned int v36; // eax@51
  unsigned int v37; // ecx@55
  unsigned int v38; // eax@55
  bool v39; // zf@61
  unsigned int v40; // eax@67
  unsigned int v41; // ecx@67
  int v42; // eax@72
  unsigned int v43; // eax@72
  unsigned int v44; // ecx@76
  unsigned int v45; // eax@76
  int v47; // eax@91
  int v48; // ecx@93
  int v49; // eax@97
  int v50; // ecx@98
  int v51; // eax@101
  int v52; // [sp-4h] [bp-2Ch]@85
  unsigned int v53; // [sp+10h] [bp-18h]@1
  unsigned int v54; // [sp+14h] [bp-14h]@1
  unsigned int v55; // [sp+18h] [bp-10h]@4
  unsigned int v56; // [sp+18h] [bp-10h]@54
  unsigned int v57; // [sp+18h] [bp-10h]@75
  _BYTE *v58; // [sp+20h] [bp-8h]@43
  int v59; // [sp+2Ch] [bp+4h]@51

  v3 = a1;
  v4 = *(_BYTE **)a1;
  v5 = a2;
  v6 = *(_BYTE **)(a2 + 14116);
  v7 = *(_DWORD *)(a2 + 1424);
  v54 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)(a2 + 14112);
  v53 = *(_DWORD *)(a2 + 1428);
  if ( (unsigned int)v6 >= v8 )
    v9 = *(_DWORD *)(a2 + 14108) - (_DWORD)v6;
  else
    v9 = v8 - (_DWORD)v6 - 1;
  v10 = *(_BYTE *)(a2 + 4);
  v55 = v9;
  while ( 2 )
  {
    switch ( v10 )
    {
      case 0u:
        if ( v9 >= 0x102 && v54 >= 0xA )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v11 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v11;
          *(_DWORD *)(v5 + 1428) = v53;
          *(_DWORD *)(v5 + 1424) = v7;
          *(_DWORD *)(v5 + 14116) = v6;
          v12 = sub_10051A40(
                  *(_BYTE *)(v5 + 20),
                  *(_BYTE *)(v5 + 21),
                  *(_DWORD *)(v5 + 24),
                  *(_DWORD *)(v5 + 28),
                  v5,
                  v3);
          v4 = *(_BYTE **)v3;
          v7 = *(_DWORD *)(v5 + 1424);
          v13 = v12;
          v54 = *(_DWORD *)(v3 + 4);
          v6 = *(_BYTE **)(v5 + 14116);
          v53 = *(_DWORD *)(v5 + 1428);
          v14 = *(_DWORD *)(v5 + 14112);
          a3 = v13;
          v9 = (unsigned int)v6 >= v14 ? *(_DWORD *)(v5 + 14108) - (_DWORD)v6 : v14 - (_DWORD)v6 - 1;
          v55 = v9;
          if ( v13 )
          {
            *(_BYTE *)(v5 + 4) = 2 * (v13 != 1) + 7;
            goto LABEL_84;
          }
        }
        v15 = *(_DWORD *)(v5 + 24);
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 20);
        *(_DWORD *)(v5 + 12) = v15;
        *(_BYTE *)(v5 + 4) = 1;
        goto LABEL_14;
      case 1u:
LABEL_14:
        if ( v7 >= *(_WORD *)(v5 + 16) )
          goto LABEL_17;
        do
        {
          if ( !v54 )
            goto LABEL_91;
          --v54;
          v16 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v16;
        }
        while ( v7 < *(_WORD *)(v5 + 16) );
LABEL_17:
        v17 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100D6F30[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v17 + 1);
        v18 = v17;
        v7 -= *(_BYTE *)(v17 + 1);
        v19 = *(_BYTE *)v17;
        if ( v19 )
        {
          if ( v19 & 0x10 )
          {
            *(_DWORD *)(v5 + 12) = v19 & 0xF;
            *(_DWORD *)(v5 + 8) = *(_DWORD *)(v18 + 4);
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 2;
          }
          else if ( v19 & 0x40 )
          {
            if ( !(v19 & 0x20) )
              goto LABEL_92;
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 7;
          }
          else
          {
            *(_DWORD *)(v5 + 16) = v19;
            v9 = v55;
            *(_DWORD *)(v5 + 12) = v18 + 8 * *(_DWORD *)(v18 + 4);
          }
        }
        else
        {
          v9 = v55;
          *(_DWORD *)(v5 + 12) = *(_DWORD *)(v18 + 4);
          *(_BYTE *)(v5 + 4) = 6;
        }
        goto LABEL_84;
      case 2u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_28;
        do
        {
          if ( !v54 )
            goto LABEL_93;
          --v54;
          v20 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v20;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_28:
        v21 = *(_DWORD *)(v5 + 12);
        v22 = v53 & dword_100D6F30[v21];
        *(_BYTE *)(v5 + 4) = 3;
        *(_DWORD *)(v5 + 8) += v22;
        v53 >>= v21;
        v23 = *(_DWORD *)(v5 + 28);
        v7 -= v21;
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 21);
        *(_DWORD *)(v5 + 12) = v23;
LABEL_29:
        if ( v7 < *(_WORD *)(v5 + 16) )
        {
          while ( v54 )
          {
            --v54;
            v24 = *v4 << v7;
            v7 += 8;
            ++v4;
            a3 = 0;
            v53 |= v24;
            if ( v7 >= *(_WORD *)(v5 + 16) )
              goto LABEL_32;
          }
LABEL_91:
          v47 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)(v3 + 4) = 0;
          *(_DWORD *)(v3 + 8) += v47;
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v5 + 14116) = v6;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = a3;
          goto LABEL_90;
        }
LABEL_32:
        v25 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100D6F30[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v25 + 1);
        v26 = v25;
        v7 -= *(_BYTE *)(v25 + 1);
        v27 = *(_BYTE *)v25;
        if ( v27 & 0x10 )
        {
          *(_DWORD *)(v5 + 12) = v27 & 0xF;
          v9 = v55;
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(v26 + 4);
          *(_BYTE *)(v5 + 4) = 4;
        }
        else
        {
          if ( v27 & 0x40 )
          {
LABEL_92:
            *(_BYTE *)(v5 + 4) = 9;
            v52 = -3;
            goto LABEL_86;
          }
          *(_DWORD *)(v5 + 16) = v27;
          v9 = v55;
          *(_DWORD *)(v5 + 12) = v26 + 8 * *(_DWORD *)(v26 + 4);
        }
        goto LABEL_84;
      case 3u:
        goto LABEL_29;
      case 4u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_39;
        do
        {
          if ( !v54 )
          {
LABEL_93:
            v48 = (int)&v4[-*(_DWORD *)v3];
            *(_DWORD *)(v3 + 4) = 0;
            *(_DWORD *)(v3 + 8) += v48;
            v52 = a3;
            goto LABEL_88;
          }
          --v54;
          v28 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v28;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_39:
        v29 = *(_DWORD *)(v5 + 12);
        v30 = v53 & dword_100D6F30[v29];
        *(_BYTE *)(v5 + 4) = 5;
        *(_DWORD *)(v5 + 16) += v30;
        v53 >>= v29;
        v7 -= v29;
LABEL_40:
        v31 = *(_DWORD *)(v5 + 16);
        if ( (signed int)&v6[-*(_DWORD *)(v5 + 14104)] >= v31 )
          v32 = (int)&v6[-v31];
        else
          v32 = (int)&v6[*(_DWORD *)(v5 + 14108) - v31 - *(_DWORD *)(v5 + 14104)];
        v58 = (_BYTE *)v32;
        v9 = v55;
        if ( !*(_DWORD *)(v5 + 8) )
        {
LABEL_83:
          *(_BYTE *)(v5 + 4) = 0;
LABEL_84:
          v10 = *(_BYTE *)(v5 + 4);
          if ( v10 > 9 )
          {
LABEL_85:
            v52 = -2;
LABEL_86:
            *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
            goto LABEL_87;
          }
          continue;
        }
        while ( 1 )
        {
          if ( !v9 )
          {
            if ( v6 != *(_BYTE **)(v5 + 14108)
              || (v33 = *(_DWORD *)(v5 + 14112), v34 = *(_DWORD *)(v5 + 14104), v33 == v34)
              || ((v6 = *(_BYTE **)(v5 + 14104), v34 >= v33) ? (v9 = *(_DWORD *)(v5 + 14108) - v34) : (v9 = v33 - v34 - 1),
                  !v9) )
            {
              *(_DWORD *)(v5 + 14116) = v6;
              v35 = sub_10051DF0(v3, v5, a3);
              v6 = *(_BYTE **)(v5 + 14116);
              v59 = v35;
              v36 = *(_DWORD *)(v5 + 14112);
              if ( (unsigned int)v6 >= v36 )
                v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
              else
                v9 = v36 - (_DWORD)v6 - 1;
              v56 = v9;
              if ( v6 == *(_BYTE **)(v5 + 14108) )
              {
                v37 = *(_DWORD *)(v5 + 14104);
                v38 = *(_DWORD *)(v5 + 14112);
                if ( v38 == v37 )
                {
                  v9 = v56;
                }
                else
                {
                  v6 = *(_BYTE **)(v5 + 14104);
                  if ( v37 >= v38 )
                    v9 = *(_DWORD *)(v5 + 14108) - v37;
                  else
                    v9 = v38 - v37 - 1;
                }
              }
              if ( !v9 )
                break;
            }
          }
          *v6 = *v58;
          --v9;
          ++v6;
          v39 = v58 + 1 == *(_BYTE **)(v5 + 14108);
          a3 = 0;
          v55 = v9;
          ++v58;
          if ( v39 )
            v58 = *(_BYTE **)(v5 + 14104);
          if ( !--*(_DWORD *)(v5 + 8) )
            goto LABEL_83;
        }
LABEL_94:
        *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
        v52 = v59;
LABEL_87:
        *(_DWORD *)(v3 + 4) = v54;
LABEL_88:
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
LABEL_89:
        *(_DWORD *)(v5 + 14116) = v6;
LABEL_90:
        *(_DWORD *)(v5 + 1424) = v7;
        return sub_10051DF0(v3, v5, v52);
      case 5u:
        goto LABEL_40;
      case 6u:
        if ( !v9 )
        {
          if ( v6 != *(_BYTE **)(v5 + 14108)
            || (v40 = *(_DWORD *)(v5 + 14112), v41 = *(_DWORD *)(v5 + 14104), v40 == v41)
            || ((v6 = *(_BYTE **)(v5 + 14104), v41 >= v40) ? (v9 = *(_DWORD *)(v5 + 14108) - v41) : (v9 = v40 - v41 - 1),
                !v9) )
          {
            *(_DWORD *)(v5 + 14116) = v6;
            v42 = sub_10051DF0(v3, v5, a3);
            v6 = *(_BYTE **)(v5 + 14116);
            v59 = v42;
            v43 = *(_DWORD *)(v5 + 14112);
            if ( (unsigned int)v6 >= v43 )
              v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
            else
              v9 = v43 - (_DWORD)v6 - 1;
            v57 = v9;
            if ( v6 == *(_BYTE **)(v5 + 14108) )
            {
              v44 = *(_DWORD *)(v5 + 14104);
              v45 = *(_DWORD *)(v5 + 14112);
              if ( v45 == v44 )
              {
                v9 = v57;
              }
              else
              {
                v6 = *(_BYTE **)(v5 + 14104);
                if ( v44 >= v45 )
                  v9 = *(_DWORD *)(v5 + 14108) - v44;
                else
                  v9 = v45 - v44 - 1;
              }
            }
            if ( !v9 )
              goto LABEL_94;
          }
        }
        *v6++ = *(_BYTE *)(v5 + 12);
        --v9;
        a3 = 0;
        v55 = v9;
        goto LABEL_83;
      case 7u:
        if ( v7 > 7 )
        {
          ++v54;
          v7 -= 8;
          --v4;
        }
        *(_DWORD *)(v5 + 14116) = v6;
        v49 = sub_10051DF0(v3, v5, a3);
        v6 = *(_BYTE **)(v5 + 14116);
        if ( *(_BYTE **)(v5 + 14112) != v6 )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v50 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v50;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = v49;
          goto LABEL_89;
        }
        *(_BYTE *)(v5 + 4) = 8;
LABEL_100:
        v52 = 1;
        goto LABEL_86;
      case 8u:
        goto LABEL_100;
      case 9u:
        v51 = (int)&v4[-*(_DWORD *)v3];
        *(_DWORD *)(v3 + 4) = v54;
        *(_DWORD *)(v3 + 8) += v51;
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
        v52 = -3;
        goto LABEL_89;
      default:
        goto LABEL_85;
    }
  }
}
// 100D6F30: using guessed type int dword_100D6F30[];

//----- (100526F0) --------------------------------------------------------
int __usercall sub_100526F0@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // edx@1
  unsigned int v5; // ebx@1
  unsigned int v6; // esi@1
  int v7; // edi@1
  size_t v8; // ecx@1
  char *v9; // eax@1
  char *v10; // ecx@1
  int v11; // edx@2
  unsigned int v12; // edx@4
  int v13; // edx@8
  unsigned int v14; // eax@9
  int v15; // eax@10
  int v16; // ebx@14
  int v17; // ecx@14
  int v18; // edx@17
  char *v19; // edx@24
  unsigned int v20; // eax@25
  unsigned int v21; // ecx@25
  int v22; // eax@27
  int v23; // eax@30
  unsigned int v24; // ecx@30
  int v25; // edx@31
  char *v26; // esi@33
  unsigned int v27; // edx@34
  size_t v28; // esi@39
  bool v29; // zf@43
  int v30; // edx@47
  int v31; // ecx@48
  int v32; // edx@54
  unsigned int v33; // ecx@61
  int v34; // edx@63
  int v35; // edx@64
  int v36; // ecx@64
  unsigned int v37; // edx@64
  int v38; // edx@71
  unsigned int v39; // esi@72
  unsigned int v40; // ecx@72
  unsigned int *v41; // eax@77
  unsigned int v42; // esi@81
  int v43; // eax@81
  int v44; // edx@83
  char *v45; // ecx@84
  unsigned int v46; // eax@84
  int v47; // eax@85
  char *v48; // eax@91
  int v49; // ecx@92
  int v50; // ecx@94
  int v51; // edx@96
  int v52; // edx@97
  int v53; // edx@99
  int v55; // eax@102
  int v56; // edx@103
  int v57; // edx@106
  int v58; // [sp-4h] [bp-3Ch]@91
  size_t v59; // [sp+10h] [bp-28h]@1
  char *v60; // [sp+14h] [bp-24h]@1
  char *v61; // [sp+18h] [bp-20h]@1
  unsigned int v62; // [sp+1Ch] [bp-1Ch]@4
  int v63; // [sp+1Ch] [bp-1Ch]@69
  int v64; // [sp+1Ch] [bp-1Ch]@72
  unsigned int v65; // [sp+20h] [bp-18h]@1
  unsigned int v66; // [sp+24h] [bp-14h]@13
  unsigned int v67; // [sp+28h] [bp-10h]@13
  int v68; // [sp+2Ch] [bp-Ch]@13
  int v69; // [sp+30h] [bp-8h]@13
  unsigned int v70; // [sp+34h] [bp-4h]@69
  unsigned int v71; // [sp+3Ch] [bp+4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 14112);
  v5 = *(_DWORD *)(a2 + 1424);
  v6 = *(_DWORD *)(a2 + 1428);
  v7 = a1;
  v8 = *(_DWORD *)(a1 + 4);
  v9 = *(char **)a1;
  v59 = v8;
  v10 = *(char **)(a2 + 14116);
  v61 = v9;
  v71 = *(_DWORD *)(a2 + 1428);
  v65 = v5;
  v60 = v10;
  if ( (unsigned int)v10 >= v4 )
    v11 = *(_DWORD *)(v3 + 14108) - (_DWORD)v10;
  else
    v11 = v4 - (_DWORD)v10 - 1;
  v62 = v11;
  v12 = *(_BYTE *)v3;
  while ( 2 )
  {
    switch ( v12 )
    {
      case 0u:
        for ( ; v5 < 3; v71 = v6 )
        {
          if ( !v59 )
            goto LABEL_91;
          --v59;
          a3 = 0;
          v13 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v13;
        }
        v14 = (v6 & 7) >> 1;
        *(_DWORD *)(v3 + 1420) = v6 & 1;
        if ( !v14 )
        {
          v16 = v5 - 3;
          v17 = v16 & 7;
          v5 = v16 - v17;
          v65 = v5;
          *(_BYTE *)v3 = 1;
          v71 = v6 >> 3 >> v17;
          goto LABEL_89;
        }
        v15 = v14 - 1;
        if ( !v15 )
        {
          sub_10052020(&v67, &v69, &v66, &v68);
          sub_10051A20(v3 + 4, v67, v66, v69, v68);
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 6;
          goto LABEL_89;
        }
        if ( v15 == 1 )
        {
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 3;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 9;
        v49 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v49;
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v3 + 1428) = v71 >> 3;
        v5 -= 3;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      case 1u:
        if ( v5 >= 0x20 )
          goto LABEL_18;
        do
        {
          if ( !v59 )
          {
LABEL_91:
            v48 = v61;
            *(_DWORD *)(v7 + 4) = 0;
            *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
            v58 = a3;
            goto LABEL_110;
          }
          --v59;
          a3 = 0;
          v18 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v18;
          v71 = v6;
        }
        while ( v5 < 0x20 );
LABEL_18:
        if ( ~v6 >> 16 != (unsigned __int16)v6 )
          goto LABEL_93;
        v5 = 0;
        *(_DWORD *)(v3 + 4) = (unsigned __int16)v6;
        v65 = 0;
        v71 = 0;
        if ( (_WORD)v6 )
          *(_BYTE *)v3 = 2;
        else
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
LABEL_89:
        v12 = *(_BYTE *)v3;
        if ( v12 <= 9 )
        {
          v10 = v60;
          v9 = v61;
          v6 = v71;
          continue;
        }
LABEL_107:
        v58 = -2;
        goto LABEL_108;
      case 2u:
        if ( !v59 )
          goto LABEL_94;
        if ( !v62 )
        {
          if ( (v19 = *(char **)(v3 + 14108), v60 != v19)
            || (v20 = *(_DWORD *)(v3 + 14112), v21 = *(_DWORD *)(v3 + 14104), v21 == v20)
            || ((v60 = *(char **)(v3 + 14104), v21 >= v20) ? (v22 = (int)&v19[-v21], v62 = (unsigned int)&v19[-v21]) : (v22 = v20 - v21 - 1, v62 = v22),
                !v22) )
          {
            *(_DWORD *)(v3 + 14116) = v60;
            v23 = sub_10051DF0(v7, v3, a3);
            v24 = *(_DWORD *)(v3 + 14112);
            v60 = *(char **)(v3 + 14116);
            if ( *(_DWORD *)(v3 + 14116) >= v24 )
              v25 = *(_DWORD *)(v3 + 14108) - (_DWORD)v60;
            else
              v25 = v24 - (_DWORD)v60 - 1;
            v26 = *(char **)(v3 + 14108);
            v62 = v25;
            if ( v60 == v26 )
            {
              v27 = *(_DWORD *)(v3 + 14104);
              if ( v27 != v24 )
              {
                v60 = *(char **)(v3 + 14104);
                if ( v27 >= v24 )
                  v62 = (unsigned int)&v26[-v27];
                else
                  v62 = v24 - v27 - 1;
              }
            }
            if ( !v62 )
              goto LABEL_96;
          }
        }
        v28 = *(_DWORD *)(v3 + 4);
        a3 = 0;
        if ( v28 > v59 )
          v28 = v59;
        if ( v28 > v62 )
          v28 = v62;
        memcpy(v60, v61, v28);
        v61 += v28;
        v59 -= v28;
        v60 += v28;
        v62 -= v28;
        v29 = *(_DWORD *)(v3 + 4) == v28;
        *(_DWORD *)(v3 + 4) -= v28;
        if ( v29 )
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
        goto LABEL_89;
      case 3u:
        if ( v5 >= 0xE )
          goto LABEL_48;
        break;
      case 4u:
        goto LABEL_51;
      case 5u:
        goto LABEL_60;
      case 6u:
        goto LABEL_83;
      case 7u:
        goto LABEL_102;
      case 8u:
        goto LABEL_105;
      case 9u:
        v57 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v7 + 8) += v57;
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      default:
        goto LABEL_107;
    }
    break;
  }
  do
  {
    if ( !v59 )
      goto LABEL_94;
    --v59;
    v30 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v30;
    v71 = v6;
    v61 = v9;
  }
  while ( v5 < 0xE );
LABEL_48:
  v31 = v6 & 0x3FFF;
  *(_DWORD *)(v3 + 4) = v31;
  if ( (v6 & 0x1F) > 0x1D || (v6 & 0x3E0) > 0x3A0 )
  {
LABEL_93:
    *(_BYTE *)v3 = 9;
    v58 = -3;
LABEL_108:
    *(_DWORD *)(v7 + 4) = v59;
LABEL_109:
    v48 = v61;
    *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
    goto LABEL_110;
  }
  v6 >>= 14;
  v5 -= 14;
  v71 = v6;
  v65 = v5;
  *(_DWORD *)(v3 + 8) = 0;
  *(_BYTE *)v3 = 4;
LABEL_51:
  if ( *(_DWORD *)(v3 + 8) < (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
  {
    while ( v5 >= 3 )
    {
LABEL_55:
      *(_DWORD *)(v3 + 4 * dword_100D6F78[(*(_DWORD *)(v3 + 8))++] + 12) = v6 & 7;
      v6 >>= 3;
      v5 -= 3;
      v71 = v6;
      v65 = v5;
      if ( *(_DWORD *)(v3 + 8) >= (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
        goto LABEL_56;
    }
    while ( v59 )
    {
      --v59;
      v32 = (unsigned __int8)*v9++ << v5;
      v5 += 8;
      a3 = 0;
      v6 |= v32;
      v71 = v6;
      v61 = v9;
      if ( v5 >= 3 )
        goto LABEL_55;
    }
    goto LABEL_94;
  }
LABEL_56:
  while ( *(_DWORD *)(v3 + 8) < 0x13u )
    *(_DWORD *)(v3 + 4 * dword_100D6F78[(*(_DWORD *)(v3 + 8))++] + 12) = 0;
  *(_DWORD *)(v3 + 1412) = 7;
  v23 = sub_10051F30(v3 + 1432, (unsigned int *)(v3 + 1412), (_DWORD *)(v3 + 12), (int *)(v3 + 1416));
  if ( v23 )
  {
    *(_BYTE *)v3 = 9;
LABEL_96:
    *(_DWORD *)(v7 + 4) = v59;
    v51 = (int)&v61[-*(_DWORD *)v7];
    *(_DWORD *)v7 = v61;
    *(_DWORD *)(v7 + 8) += v51;
    *(_DWORD *)(v3 + 1428) = v71;
    *(_DWORD *)(v3 + 14116) = v60;
    v58 = v23;
    goto LABEL_111;
  }
  v6 = v71;
  *(_DWORD *)(v3 + 8) = 0;
  v9 = v61;
  *(_BYTE *)v3 = 5;
LABEL_60:
  if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
  {
LABEL_81:
    v42 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 1416) = 0;
    v67 = 9;
    v66 = 6;
    v43 = sub_10051F80(
            (unsigned int *)(v3 + 12952),
            &v69,
            v3 + 1432,
            (v42 & 0x1F) + 257,
            ((v42 >> 5) & 0x1F) + 1,
            (_DWORD *)(v3 + 12),
            &v67,
            &v66,
            &v68);
    if ( v43 )
    {
      *(_BYTE *)v3 = 9;
      *(_DWORD *)(v7 + 4) = v59;
      v53 = (int)&v61[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v61;
      *(_DWORD *)(v7 + 8) += v53;
      *(_DWORD *)(v3 + 1428) = v71;
      *(_DWORD *)(v3 + 1424) = v65;
      *(_DWORD *)(v3 + 14116) = v60;
    }
    else
    {
      sub_10051A20(v3 + 4, v67, v66, v69, v68);
      v5 = v65;
      v10 = v60;
      v9 = v61;
      v6 = v71;
      *(_BYTE *)v3 = 6;
LABEL_83:
      *(_DWORD *)(v7 + 4) = v59;
      v44 = (int)&v9[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 8) += v44;
      *(_DWORD *)(v3 + 14116) = v10;
      *(_DWORD *)(v3 + 1428) = v6;
      *(_DWORD *)(v3 + 1424) = v5;
      v43 = sub_10052050(v7, v3, a3);
      if ( v43 == 1 )
      {
        v5 = *(_DWORD *)(v3 + 1424);
        v61 = *(char **)v7;
        v45 = *(char **)(v3 + 14116);
        v71 = *(_DWORD *)(v3 + 1428);
        v46 = *(_DWORD *)(v3 + 14112);
        a3 = 0;
        v59 = *(_DWORD *)(v7 + 4);
        v65 = *(_DWORD *)(v3 + 1424);
        v60 = v45;
        if ( (unsigned int)v45 >= v46 )
          v47 = *(_DWORD *)(v3 + 14108) - (_DWORD)v45;
        else
          v47 = v46 - (_DWORD)v45 - 1;
        v62 = v47;
        if ( !*(_DWORD *)(v3 + 1420) )
        {
          *(_BYTE *)v3 = 0;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 7;
LABEL_102:
        *(_DWORD *)(v3 + 14116) = v60;
        v55 = sub_10051DF0(v7, v3, a3);
        v60 = *(char **)(v3 + 14116);
        if ( *(_DWORD *)(v3 + 14112) != *(_DWORD *)(v3 + 14116) )
        {
          *(_DWORD *)(v7 + 4) = v59;
          v56 = (int)&v61[-*(_DWORD *)v7];
          *(_DWORD *)v7 = v61;
          *(_DWORD *)(v7 + 8) += v56;
          *(_DWORD *)(v3 + 1428) = v71;
          *(_DWORD *)(v3 + 1424) = v5;
          *(_DWORD *)(v3 + 14116) = v60;
          return sub_10051DF0(v7, v3, v55);
        }
        *(_BYTE *)v3 = 8;
LABEL_105:
        *(_DWORD *)(v7 + 4) = v59;
        v58 = 1;
        goto LABEL_109;
      }
    }
    return sub_10051DF0(v7, v3, v43);
  }
  while ( 1 )
  {
    v33 = *(_WORD *)(v3 + 1412);
    v67 = *(_WORD *)(v3 + 1412);
    if ( v5 < v33 )
      break;
LABEL_64:
    v35 = *(_DWORD *)(v3 + 1416) + 8 * (v6 & dword_100D6F30[*(_DWORD *)(v3 + 1412)]);
    v36 = *(_BYTE *)(v35 + 1);
    v37 = *(_DWORD *)(v35 + 4);
    v66 = v37;
    if ( v37 >= 0x10 )
    {
      if ( v37 == 18 )
        v67 = 7;
      else
        v67 = v37 - 14;
      v63 = 8 * (v37 == 18) + 3;
      v70 = (unsigned __int16)(v36 + v67);
      if ( v5 < v70 )
      {
        while ( v59 )
        {
          --v59;
          v38 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          a3 = 0;
          v6 |= v38;
          v71 = v6;
          v61 = v9;
          if ( v5 >= v70 )
            goto LABEL_72;
        }
        v52 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v52;
        *(_DWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = a3;
        goto LABEL_111;
      }
LABEL_72:
      v39 = v6 >> v36;
      v64 = (v39 & dword_100D6F30[v67]) + v63;
      v6 = v39 >> v67;
      v5 -= v36 + v67;
      v40 = *(_DWORD *)(v3 + 8);
      v71 = v6;
      v65 = v5;
      if ( v40 + v64 > ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
        goto LABEL_98;
      if ( v66 == 16 )
      {
        if ( v40 < 1 )
        {
LABEL_98:
          *(_BYTE *)v3 = 9;
          *(_DWORD *)(v7 + 4) = v59;
          v58 = -3;
          goto LABEL_109;
        }
        v66 = *(_DWORD *)(v3 + 4 * v40 + 8);
      }
      else
      {
        v66 = 0;
      }
      v41 = (unsigned int *)(v3 + 4 * v40 + 12);
      do
      {
        *v41 = v66;
        ++v40;
        ++v41;
        --v64;
      }
      while ( v64 );
      v9 = v61;
      *(_DWORD *)(v3 + 8) = v40;
    }
    else
    {
      v6 >>= v36;
      v5 -= v36;
      *(_DWORD *)(v3 + 4 * (*(_DWORD *)(v3 + 8))++ + 12) = v37;
      v71 = v6;
      v65 = v5;
    }
    if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
      goto LABEL_81;
  }
  while ( v59 )
  {
    --v59;
    v34 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v34;
    v71 = v6;
    v61 = v9;
    if ( v5 >= v67 )
      goto LABEL_64;
  }
LABEL_94:
  v48 = v61;
  v50 = (int)&v61[-*(_DWORD *)v7];
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) += v50;
  v58 = a3;
LABEL_110:
  *(_DWORD *)v7 = v48;
  *(_DWORD *)(v3 + 14116) = v60;
  *(_DWORD *)(v3 + 1428) = v71;
LABEL_111:
  *(_DWORD *)(v3 + 1424) = v5;
  return sub_10051DF0(v7, v3, v58);
}
// 100D6F30: using guessed type int dword_100D6F30[];
// 100D6F78: using guessed type int dword_100D6F78[];

//----- (100530D0) --------------------------------------------------------
signed int __usercall sub_100530D0@<eax>(int a1@<edi>, int a2)
{
  int v2; // ebp@3
  int v3; // ebx@3
  signed int v4; // esi@3
  unsigned int v5; // eax@3
  int v6; // eax@5
  _BYTE *v7; // ecx@6
  int v8; // eax@9
  int v9; // ecx@10
  int v10; // eax@13
  int v11; // eax@21
  int v12; // eax@23
  _BYTE *v13; // edx@24
  int v14; // eax@25
  _BYTE *v15; // ecx@26
  int v16; // eax@27
  signed int result; // eax@32
  int v18; // eax@34
  int v19; // eax@36
  _BYTE *v20; // edx@37
  int v21; // eax@38
  _BYTE *v22; // ecx@39
  int v23; // eax@40
  signed int v24; // [sp+8h] [bp+4h]@3

  if ( !a1 || !*(_DWORD *)a1 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  v3 = -5;
  v4 = a2 != 4 ? 0 : 0xFFFFFFFB;
  v5 = *(_BYTE *)v2;
  v24 = a2 != 4 ? 0 : 0xFFFFFFFB;
  while ( 2 )
  {
    switch ( v5 )
    {
      case 0u:
        v6 = *(_DWORD *)(a1 + 4);
        if ( !v6 )
          goto LABEL_44;
        v7 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v6 - 1;
        *(_DWORD *)(v2 + 4) = *v7;
        ++*(_DWORD *)a1;
        v3 = v4;
        if ( (*(_DWORD *)(v2 + 4) & 0xF) != 8 || (unsigned int)((*(_DWORD *)(v2 + 4) >> 4) + 8) > *(_DWORD *)(v2 + 16) )
          goto LABEL_29;
        *(_BYTE *)v2 = 1;
        goto LABEL_9;
      case 1u:
LABEL_9:
        v8 = *(_DWORD *)(a1 + 4);
        if ( !v8 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v8 - 1;
        v9 = *(_BYTE *)(*(_DWORD *)a1)++;
        v3 = v4;
        if ( (v9 + (*(_DWORD *)(v2 + 4) << 8)) % 0x1Fu )
          goto LABEL_29;
        if ( !(v9 & 0x20) )
        {
          *(_BYTE *)v2 = 7;
LABEL_31:
          v5 = *(_BYTE *)v2;
          if ( v5 > 0xD )
            return -2;
          continue;
        }
        *(_BYTE *)v2 = 2;
LABEL_34:
        v18 = *(_DWORD *)(a1 + 4);
        if ( !v18 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v18 - 1;
        *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
        v3 = v4;
        *(_BYTE *)v2 = 3;
LABEL_36:
        v19 = *(_DWORD *)(a1 + 4);
        if ( !v19 )
          goto LABEL_44;
        v20 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v19 - 1;
        *(_DWORD *)(v2 + 8) += *v20 << 16;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 4;
LABEL_38:
        v21 = *(_DWORD *)(a1 + 4);
        if ( !v21 )
          goto LABEL_44;
        v22 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v21 - 1;
        *(_DWORD *)(v2 + 8) += *v22 << 8;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 5;
LABEL_40:
        v23 = *(_DWORD *)(a1 + 4);
        if ( v23 )
        {
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v23 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(v2 + 8);
          *(_BYTE *)v2 = 6;
          result = 2;
        }
        else
        {
LABEL_44:
          result = v3;
        }
        return result;
      case 7u:
        v10 = sub_100526F0(a1, *(_DWORD *)(v2 + 20), v3);
        v3 = v10;
        if ( v10 == -3 )
        {
          *(_DWORD *)(v2 + 4) = 0;
        }
        else
        {
          if ( !v10 )
            v3 = v4;
          if ( v3 != 1 )
            goto LABEL_44;
          v3 = v4;
          sub_100519D0((_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 20), a1);
          v4 = v24;
          if ( *(_DWORD *)(v2 + 12) )
          {
            *(_BYTE *)v2 = 12;
            goto LABEL_31;
          }
          *(_BYTE *)v2 = 8;
LABEL_21:
          v11 = *(_DWORD *)(a1 + 4);
          if ( !v11 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v11 - 1;
          *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
          v3 = v4;
          *(_BYTE *)v2 = 9;
LABEL_23:
          v12 = *(_DWORD *)(a1 + 4);
          if ( !v12 )
            goto LABEL_44;
          v13 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v12 - 1;
          *(_DWORD *)(v2 + 8) += *v13 << 16;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 10;
LABEL_25:
          v14 = *(_DWORD *)(a1 + 4);
          if ( !v14 )
            goto LABEL_44;
          v15 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v14 - 1;
          *(_DWORD *)(v2 + 8) += *v15 << 8;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 11;
LABEL_27:
          v16 = *(_DWORD *)(a1 + 4);
          if ( !v16 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v16 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          v3 = v4;
          if ( *(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
          {
            *(_BYTE *)v2 = 12;
            return 1;
          }
LABEL_29:
          *(_DWORD *)(v2 + 4) = 5;
        }
        *(_BYTE *)v2 = 13;
        goto LABEL_31;
      case 8u:
        goto LABEL_21;
      case 9u:
        goto LABEL_23;
      case 0xAu:
        goto LABEL_25;
      case 0xBu:
        goto LABEL_27;
      case 2u:
        goto LABEL_34;
      case 3u:
        goto LABEL_36;
      case 4u:
        goto LABEL_38;
      case 5u:
        goto LABEL_40;
      case 6u:
        *(_BYTE *)v2 = 13;
        *(_DWORD *)(v2 + 4) = 0;
        return -2;
      case 0xCu:
        return 1;
      case 0xDu:
        return -3;
      default:
        return -2;
    }
  }
}

//----- (10053400) --------------------------------------------------------
signed int __cdecl sub_10053400(int a1, int a2)
{
  return sub_100530D0(a1, a2);
}

#error "There were 50 decompilation failure(s) on 1224 function(s)"
